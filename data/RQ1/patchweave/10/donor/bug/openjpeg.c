/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef unsigned long size_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_5 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_5 __sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 106 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef int OPJ_BOOL;
#line 110 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef char OPJ_CHAR;
#line 111 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef float OPJ_FLOAT32;
#line 112 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef double OPJ_FLOAT64;
#line 113 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef unsigned char OPJ_BYTE;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 119 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef int16_t OPJ_INT16;
#line 120 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef uint16_t OPJ_UINT16;
#line 121 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef int32_t OPJ_INT32;
#line 122 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef uint32_t OPJ_UINT32;
#line 123 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef int64_t OPJ_INT64;
#line 124 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef uint64_t OPJ_UINT64;
#line 126 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef int64_t OPJ_OFF_T;
#line 129 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef size_t OPJ_SIZE_T;
#line 242
enum RSIZ_CAPABILITIES {
    OPJ_STD_RSIZ = 0,
    OPJ_CINEMA2K = 3,
    OPJ_CINEMA4K = 4,
    OPJ_MCT = 33024
} ;
#line 247 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef enum RSIZ_CAPABILITIES OPJ_RSIZ_CAPABILITIES;
#line 253
enum CINEMA_MODE {
    OPJ_OFF = 0,
    OPJ_CINEMA2K_24 = 1,
    OPJ_CINEMA2K_48 = 2,
    OPJ_CINEMA4K_24 = 3
} ;
#line 258 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef enum CINEMA_MODE OPJ_CINEMA_MODE;
#line 263
enum PROG_ORDER {
    OPJ_PROG_UNKNOWN = -1,
    OPJ_LRCP = 0,
    OPJ_RLCP = 1,
    OPJ_RPCL = 2,
    OPJ_PCRL = 3,
    OPJ_CPRL = 4
} ;
#line 270 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef enum PROG_ORDER OPJ_PROG_ORDER;
#line 275
enum COLOR_SPACE {
    OPJ_CLRSPC_UNKNOWN = -1,
    OPJ_CLRSPC_UNSPECIFIED = 0,
    OPJ_CLRSPC_SRGB = 1,
    OPJ_CLRSPC_GRAY = 2,
    OPJ_CLRSPC_SYCC = 3,
    OPJ_CLRSPC_EYCC = 4,
    OPJ_CLRSPC_CMYK = 5
} ;
#line 283 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef enum COLOR_SPACE OPJ_COLOR_SPACE;
#line 288
enum CODEC_FORMAT {
    OPJ_CODEC_UNKNOWN = -1,
    OPJ_CODEC_J2K = 0,
    OPJ_CODEC_JPT = 1,
    OPJ_CODEC_JP2 = 2,
    OPJ_CODEC_JPP = 3,
    OPJ_CODEC_JPX = 4
} ;
#line 295 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef enum CODEC_FORMAT OPJ_CODEC_FORMAT;
#line 321 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_poc {
   OPJ_UINT32 resno0 ;
   OPJ_UINT32 compno0 ;
   OPJ_UINT32 layno1 ;
   OPJ_UINT32 resno1 ;
   OPJ_UINT32 compno1 ;
   OPJ_UINT32 layno0 ;
   OPJ_UINT32 precno0 ;
   OPJ_UINT32 precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   OPJ_CHAR progorder[5] ;
   OPJ_UINT32 tile ;
   OPJ_INT32 tx0 ;
   OPJ_INT32 tx1 ;
   OPJ_INT32 ty0 ;
   OPJ_INT32 ty1 ;
   OPJ_UINT32 layS ;
   OPJ_UINT32 resS ;
   OPJ_UINT32 compS ;
   OPJ_UINT32 prcS ;
   OPJ_UINT32 layE ;
   OPJ_UINT32 resE ;
   OPJ_UINT32 compE ;
   OPJ_UINT32 prcE ;
   OPJ_UINT32 txS ;
   OPJ_UINT32 txE ;
   OPJ_UINT32 tyS ;
   OPJ_UINT32 tyE ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 lay_t ;
   OPJ_UINT32 res_t ;
   OPJ_UINT32 comp_t ;
   OPJ_UINT32 prc_t ;
   OPJ_UINT32 tx0_t ;
   OPJ_UINT32 ty0_t ;
};
#line 344 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_poc opj_poc_t;
#line 349 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_cparameters {
   OPJ_BOOL tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t POC[32] ;
   OPJ_UINT32 numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   OPJ_BOOL jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
   OPJ_BOOL jpip_on ;
   void *mct_data ;
   int max_cs_size ;
   OPJ_UINT16 rsiz ;
};
#line 497 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_cparameters opj_cparameters_t;
#line 504 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_dparameters {
   OPJ_UINT32 cp_reduce ;
   OPJ_UINT32 cp_layer ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   OPJ_UINT32 DA_x0 ;
   OPJ_UINT32 DA_x1 ;
   OPJ_UINT32 DA_y0 ;
   OPJ_UINT32 DA_y1 ;
   OPJ_BOOL m_verbose ;
   OPJ_UINT32 tile_index ;
   OPJ_UINT32 nb_tile_to_decode ;
   OPJ_BOOL jpwl_correct ;
   int jpwl_exp_comps ;
   int jpwl_max_tiles ;
   unsigned int flags ;
};
#line 564 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_dparameters opj_dparameters_t;
#line 570 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef void *opj_codec_t;
#line 614 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef void *opj_stream_t;
#line 625 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_image_comp {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 prec ;
   OPJ_UINT32 bpp ;
   OPJ_UINT32 sgnd ;
   OPJ_UINT32 resno_decoded ;
   OPJ_UINT32 factor ;
   OPJ_INT32 *data ;
   OPJ_UINT16 alpha ;
};
#line 652 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_image_comp opj_image_comp_t;
#line 657 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_image {
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 x1 ;
   OPJ_UINT32 y1 ;
   OPJ_UINT32 numcomps ;
   OPJ_COLOR_SPACE color_space ;
   opj_image_comp_t *comps ;
   OPJ_BYTE *icc_profile_buf ;
   OPJ_UINT32 icc_profile_len ;
};
#line 676 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_image opj_image_t;
#line 682 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_image_comptparm {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 prec ;
   OPJ_UINT32 bpp ;
   OPJ_UINT32 sgnd ;
};
#line 701 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_image_comptparm opj_image_cmptparm_t;
#line 714 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_packet_info {
   OPJ_OFF_T start_pos ;
   OPJ_OFF_T end_ph_pos ;
   OPJ_OFF_T end_pos ;
   double disto ;
};
#line 723 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_packet_info opj_packet_info_t;
#line 730 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_marker_info {
   unsigned short type ;
   OPJ_OFF_T pos ;
   int len ;
};
#line 737 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_marker_info opj_marker_info_t;
#line 743 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_tp_info {
   int tp_start_pos ;
   int tp_end_header ;
   int tp_end_pos ;
   int tp_start_pack ;
   int tp_numpacks ;
};
#line 754 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_tp_info opj_tp_info_t;
#line 759 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_tile_info {
   double *thresh ;
   int tileno ;
   int start_pos ;
   int end_header ;
   int end_pos ;
   int pw[33] ;
   int ph[33] ;
   int pdx[33] ;
   int pdy[33] ;
   opj_packet_info_t *packet ;
   int numpix ;
   double distotile ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int num_tps ;
   opj_tp_info_t *tp ;
};
#line 794 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_info opj_tile_info_t;
#line 799 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_codestream_info {
   double D_max ;
   int packno ;
   int index_write ;
   int image_w ;
   int image_h ;
   OPJ_PROG_ORDER prog ;
   int tile_x ;
   int tile_y ;
   int tile_Ox ;
   int tile_Oy ;
   int tw ;
   int th ;
   int numcomps ;
   int numlayers ;
   int *numdecompos ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int main_head_start ;
   int main_head_end ;
   int codestream_size ;
   opj_tile_info_t *tile ;
};
#line 846 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_info opj_codestream_info_t;
#line 854 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_tccp_info {
   OPJ_UINT32 compno ;
   OPJ_UINT32 csty ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 cblkw ;
   OPJ_UINT32 cblkh ;
   OPJ_UINT32 cblksty ;
   OPJ_UINT32 qmfbid ;
   OPJ_UINT32 qntsty ;
   OPJ_UINT32 stepsizes_mant[97] ;
   OPJ_UINT32 stepsizes_expn[97] ;
   OPJ_UINT32 numgbits ;
   OPJ_INT32 roishift ;
   OPJ_UINT32 prcw[33] ;
   OPJ_UINT32 prch[33] ;
};
#line 885 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_tccp_info opj_tccp_info_t;
#line 890 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_tile_v2_info {
   int tileno ;
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 mct ;
   opj_tccp_info_t *tccp_info ;
};
#line 906 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_v2_info opj_tile_info_v2_t;
#line 911 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_codestream_info_v2 {
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_UINT32 nbcomps ;
   opj_tile_info_v2_t m_default_tile_info ;
   opj_tile_info_v2_t *tile_info ;
};
#line 935 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_info_v2 opj_codestream_info_v2_t;
#line 941 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_tp_index {
   OPJ_OFF_T start_pos ;
   OPJ_OFF_T end_header ;
   OPJ_OFF_T end_pos ;
};
#line 949 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_tp_index opj_tp_index_t;
#line 954 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_tile_index {
   OPJ_UINT32 tileno ;
   OPJ_UINT32 nb_tps ;
   OPJ_UINT32 current_nb_tps ;
   OPJ_UINT32 current_tpsno ;
   opj_tp_index_t *tp_index ;
   OPJ_UINT32 marknum ;
   opj_marker_info_t *marker ;
   OPJ_UINT32 maxmarknum ;
   OPJ_UINT32 nb_packet ;
   opj_packet_info_t *packet_index ;
};
#line 981 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_index opj_tile_index_t;
#line 986 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
struct opj_codestream_index {
   OPJ_OFF_T main_head_start ;
   OPJ_OFF_T main_head_end ;
   OPJ_UINT64 codestream_size ;
   OPJ_UINT32 marknum ;
   opj_marker_info_t *marker ;
   OPJ_UINT32 maxmarknum ;
   OPJ_UINT32 nb_of_tiles ;
   opj_tile_index_t *tile_index ;
};
#line 1009 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_index opj_codestream_index_t;
#line 52 "/root/patchweave_new/10/src/lib/openjp2/function_list.h"
typedef void (*opj_procedure)(void);
#line 57 "/root/patchweave_new/10/src/lib/openjp2/function_list.h"
struct opj_procedure_list {
   OPJ_UINT32 m_nb_procedures ;
   OPJ_UINT32 m_nb_max_procedures ;
   opj_procedure *m_procedures ;
};
#line 72 "/root/patchweave_new/10/src/lib/openjp2/function_list.h"
typedef struct opj_procedure_list opj_procedure_list_t;
#line 50 "/root/patchweave_new/10/src/lib/openjp2/event.h"
struct opj_event_mgr {
   void *m_error_data ;
   void *m_warning_data ;
   void *m_info_data ;
   void (*error_handler)(char const   * , void * ) ;
   void (*warning_handler)(char const   * , void * ) ;
   void (*info_handler)(char const   * , void * ) ;
};
#line 64 "/root/patchweave_new/10/src/lib/openjp2/event.h"
typedef struct opj_event_mgr opj_event_mgr_t;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef long ptrdiff_t;
#line 56 "/root/patchweave_new/10/src/lib/openjp2/bio.h"
struct opj_bio {
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
   OPJ_BYTE *bp ;
   OPJ_UINT32 buf ;
   OPJ_UINT32 ct ;
};
#line 67 "/root/patchweave_new/10/src/lib/openjp2/bio.h"
typedef struct opj_bio opj_bio_t;
#line 74 "/root/patchweave_new/10/src/lib/openjp2/cio.h"
enum __anonenum__25 {
    opj_signed_sentinel = -1,
    opj_stream_e_output = 1,
    opj_stream_e_input = 2,
    opj_stream_e_end = 4,
    opj_stream_e_error = 8
} ;
#line 82 "/root/patchweave_new/10/src/lib/openjp2/cio.h"
typedef enum __anonenum__25 opj_stream_flag;
#line 87 "/root/patchweave_new/10/src/lib/openjp2/cio.h"
struct opj_stream_private {
   void *m_user_data ;
   void (*m_free_user_data_fn)(void * ) ;
   OPJ_UINT64 m_user_data_length ;
   OPJ_SIZE_T (*m_read_fn)(void * , OPJ_SIZE_T  , void * ) ;
   OPJ_SIZE_T (*m_write_fn)(void * , OPJ_SIZE_T  , void * ) ;
   OPJ_OFF_T (*m_skip_fn)(OPJ_OFF_T  , void * ) ;
   OPJ_BOOL (*m_seek_fn)(OPJ_OFF_T  , void * ) ;
   OPJ_BYTE *m_stored_data ;
   OPJ_BYTE *m_current_data ;
   OPJ_OFF_T (*m_opj_skip)(struct opj_stream_private * , OPJ_OFF_T  , struct opj_event_mgr * ) ;
   OPJ_BOOL (*m_opj_seek)(struct opj_stream_private * , OPJ_OFF_T  , struct opj_event_mgr * ) ;
   OPJ_SIZE_T m_bytes_in_buffer ;
   OPJ_OFF_T m_byte_offset ;
   OPJ_SIZE_T m_buffer_size ;
   opj_stream_flag m_status ;
};
#line 169 "/root/patchweave_new/10/src/lib/openjp2/cio.h"
typedef struct opj_stream_private opj_stream_private_t;
#line 41 "/root/patchweave_new/10/src/lib/openjp2/image.h"
struct opj_cp ;
#line 135 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
enum MCT_ELEMENT_TYPE {
    MCT_TYPE_INT16 = 0,
    MCT_TYPE_INT32 = 1,
    MCT_TYPE_FLOAT = 2,
    MCT_TYPE_DOUBLE = 3
} ;
#line 141 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
typedef enum MCT_ELEMENT_TYPE J2K_MCT_ELEMENT_TYPE;
#line 146
enum MCT_ARRAY_TYPE {
    MCT_TYPE_DEPENDENCY = 0,
    MCT_TYPE_DECORRELATION = 1,
    MCT_TYPE_OFFSET = 2
} ;
#line 151 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
typedef enum MCT_ARRAY_TYPE J2K_MCT_ARRAY_TYPE;
#line 158
enum T2_MODE {
    THRESH_CALC = 0,
    FINAL_PASS = 1
} ;
#line 161 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
typedef enum T2_MODE J2K_T2_MODE;
#line 166 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
struct opj_stepsize {
   OPJ_INT32 expn ;
   OPJ_INT32 mant ;
};
#line 171 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
typedef struct opj_stepsize opj_stepsize_t;
#line 176 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
struct opj_tccp {
   OPJ_UINT32 csty ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 cblkw ;
   OPJ_UINT32 cblkh ;
   OPJ_UINT32 cblksty ;
   OPJ_UINT32 qmfbid ;
   OPJ_UINT32 qntsty ;
   opj_stepsize_t stepsizes[97] ;
   OPJ_UINT32 numgbits ;
   OPJ_INT32 roishift ;
   OPJ_UINT32 prcw[33] ;
   OPJ_UINT32 prch[33] ;
   OPJ_INT32 m_dc_level_shift ;
};
#line 205 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
typedef struct opj_tccp opj_tccp_t;
#line 212 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
struct opj_mct_data {
   J2K_MCT_ELEMENT_TYPE m_element_type ;
   J2K_MCT_ARRAY_TYPE m_array_type ;
   OPJ_UINT32 m_index ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
};
#line 220 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
typedef struct opj_mct_data opj_mct_data_t;
#line 225 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
struct opj_simple_mcc_decorrelation_data {
   OPJ_UINT32 m_index ;
   OPJ_UINT32 m_nb_comps ;
   opj_mct_data_t *m_decorrelation_array ;
   opj_mct_data_t *m_offset_array ;
   OPJ_UINT32 m_is_irreversible ;
};
#line 233 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
typedef struct opj_simple_mcc_decorrelation_data opj_simple_mcc_decorrelation_data_t;
#line 240 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
struct opj_tcp {
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 num_layers_to_decode ;
   OPJ_UINT32 mct ;
   OPJ_FLOAT32 rates[100] ;
   OPJ_UINT32 numpocs ;
   opj_poc_t pocs[32] ;
   OPJ_BYTE *ppt_data ;
   OPJ_BYTE *ppt_buffer ;
   OPJ_UINT32 ppt_data_size ;
   OPJ_UINT32 ppt_len ;
   OPJ_FLOAT32 distoratio[100] ;
   opj_tccp_t *tccps ;
   OPJ_UINT32 m_nb_tile_parts ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
   OPJ_FLOAT64 *mct_norms ;
   OPJ_FLOAT32 *m_mct_decoding_matrix ;
   OPJ_FLOAT32 *m_mct_coding_matrix ;
   opj_mct_data_t *m_mct_records ;
   OPJ_UINT32 m_nb_mct_records ;
   OPJ_UINT32 m_nb_max_mct_records ;
   opj_simple_mcc_decorrelation_data_t *m_mcc_records ;
   OPJ_UINT32 m_nb_mcc_records ;
   OPJ_UINT32 m_nb_max_mcc_records ;
   OPJ_UINT32 ppt ;
   OPJ_UINT32 POC ;
};
#line 300 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
typedef struct opj_tcp opj_tcp_t;
#line 305 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
struct opj_encoding_param {
   OPJ_UINT32 m_max_comp_size ;
   OPJ_INT32 m_tp_pos ;
   OPJ_INT32 *m_matrice ;
   OPJ_BYTE m_tp_flag ;
   OPJ_UINT32 m_disto_alloc ;
   OPJ_UINT32 m_fixed_alloc ;
   OPJ_UINT32 m_fixed_quality ;
   OPJ_UINT32 m_tp_on ;
};
#line 324 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
typedef struct opj_encoding_param opj_encoding_param_t;
#line 326 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
struct opj_decoding_param {
   OPJ_UINT32 m_reduce ;
   OPJ_UINT32 m_layer ;
};
#line 333 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
typedef struct opj_decoding_param opj_decoding_param_t;
#line 383 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
union __anonunion_26 {
   opj_decoding_param_t m_dec ;
   opj_encoding_param_t m_enc ;
};
#line 339 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
struct opj_cp {
   OPJ_UINT16 rsiz ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_CHAR *comment ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_BYTE *ppm_data ;
   OPJ_UINT32 ppm_len ;
   OPJ_UINT32 ppm_data_read ;
   OPJ_BYTE *ppm_data_current ;
   OPJ_BYTE *ppm_buffer ;
   OPJ_BYTE *ppm_data_first ;
   OPJ_UINT32 ppm_data_size ;
   OPJ_INT32 ppm_store ;
   OPJ_INT32 ppm_previous ;
   opj_tcp_t *tcps ;
   union __anonunion_26 m_specific_param ;
   OPJ_UINT32 ppm ;
   OPJ_UINT32 m_is_decoder ;
};
#line 441 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
typedef struct opj_cp opj_cp_t;
#line 444 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
struct opj_j2k_dec {
   OPJ_UINT32 m_state ;
   opj_tcp_t *m_default_tcp ;
   OPJ_BYTE *m_header_data ;
   OPJ_UINT32 m_header_data_size ;
   OPJ_UINT32 m_sot_length ;
   OPJ_UINT32 m_start_tile_x ;
   OPJ_UINT32 m_start_tile_y ;
   OPJ_UINT32 m_end_tile_x ;
   OPJ_UINT32 m_end_tile_y ;
   OPJ_UINT32 m_DA_x0 ;
   OPJ_UINT32 m_DA_y0 ;
   OPJ_UINT32 m_DA_x1 ;
   OPJ_UINT32 m_DA_y1 ;
   OPJ_INT32 m_tile_ind_to_dec ;
   OPJ_OFF_T m_last_sot_read_pos ;
   OPJ_BOOL m_last_tile_part ;
   OPJ_UINT32 m_can_decode ;
   OPJ_UINT32 m_discard_tiles ;
   OPJ_UINT32 m_skip_data ;
};
#line 485 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_dec opj_j2k_dec_t;
#line 487 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
struct opj_j2k_enc {
   OPJ_UINT32 m_current_poc_tile_part_number ;
   OPJ_UINT32 m_current_tile_part_number ;
   OPJ_OFF_T m_tlm_start ;
   OPJ_BYTE *m_tlm_sot_offsets_buffer ;
   OPJ_BYTE *m_tlm_sot_offsets_current ;
   OPJ_UINT32 m_total_tile_parts ;
   OPJ_BYTE *m_encoded_tile_data ;
   OPJ_UINT32 m_encoded_tile_size ;
   OPJ_BYTE *m_header_tile_data ;
   OPJ_UINT32 m_header_tile_data_size ;
};
#line 526 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_enc opj_j2k_enc_t;
#line 530
struct opj_tcd ;
#line 540 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
union __anonunion_27 {
   opj_j2k_dec_t m_decoder ;
   opj_j2k_enc_t m_encoder ;
};
#line 534 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
struct opj_j2k {
   OPJ_BOOL m_is_decoder ;
   union __anonunion_27 m_specific_param ;
   opj_image_t *m_private_image ;
   opj_image_t *m_output_image ;
   opj_cp_t m_cp ;
   opj_procedure_list_t *m_procedure_list ;
   opj_procedure_list_t *m_validation_list ;
   opj_codestream_index_t *cstr_index ;
   OPJ_UINT32 m_current_tile_number ;
   struct opj_tcd *m_tcd ;
};
#line 572 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
typedef struct opj_j2k opj_j2k_t;
#line 95 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
struct opj_jp2_cdef_info {
   OPJ_UINT16 cn ;
   OPJ_UINT16 typ ;
   OPJ_UINT16 asoc ;
};
#line 98 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cdef_info opj_jp2_cdef_info_t;
#line 103 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
struct opj_jp2_cdef {
   opj_jp2_cdef_info_t *info ;
   OPJ_UINT16 n ;
};
#line 107 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cdef opj_jp2_cdef_t;
#line 112 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
struct opj_jp2_cmap_comp {
   OPJ_UINT16 cmp ;
   OPJ_BYTE mtyp ;
   OPJ_BYTE pcol ;
};
#line 116 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cmap_comp opj_jp2_cmap_comp_t;
#line 121 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
struct opj_jp2_pclr {
   OPJ_UINT32 *entries ;
   OPJ_BYTE *channel_sign ;
   OPJ_BYTE *channel_size ;
   opj_jp2_cmap_comp_t *cmap ;
   OPJ_UINT16 nr_entries ;
   OPJ_BYTE nr_channels ;
};
#line 129 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_pclr opj_jp2_pclr_t;
#line 134 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
struct opj_jp2_color {
   OPJ_BYTE *icc_profile_buf ;
   OPJ_UINT32 icc_profile_len ;
   opj_jp2_cdef_t *jp2_cdef ;
   opj_jp2_pclr_t *jp2_pclr ;
   OPJ_BYTE jp2_has_colr ;
};
#line 142 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_color opj_jp2_color_t;
#line 147 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
struct opj_jp2_comps {
   OPJ_UINT32 depth ;
   OPJ_UINT32 sgnd ;
   OPJ_UINT32 bpcc ;
};
#line 151 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_comps opj_jp2_comps_t;
#line 156 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
struct opj_jp2 {
   opj_j2k_t *j2k ;
   struct opj_procedure_list *m_validation_list ;
   struct opj_procedure_list *m_procedure_list ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 numcomps ;
   OPJ_UINT32 bpc ;
   OPJ_UINT32 C ;
   OPJ_UINT32 UnkC ;
   OPJ_UINT32 IPR ;
   OPJ_UINT32 meth ;
   OPJ_UINT32 approx ;
   OPJ_UINT32 enumcs ;
   OPJ_UINT32 precedence ;
   OPJ_UINT32 brand ;
   OPJ_UINT32 minversion ;
   OPJ_UINT32 numcl ;
   OPJ_UINT32 *cl ;
   opj_jp2_comps_t *comps ;
   OPJ_OFF_T j2k_codestream_offset ;
   OPJ_OFF_T jpip_iptr_offset ;
   OPJ_BOOL jpip_on ;
   OPJ_UINT32 jp2_state ;
   OPJ_UINT32 jp2_img_state ;
   opj_jp2_color_t color ;
   OPJ_BOOL ignore_pclr_cmap_cdef ;
};
#line 199 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
typedef struct opj_jp2 opj_jp2_t;
#line 204 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
struct opj_jp2_box {
   OPJ_UINT32 length ;
   OPJ_UINT32 type ;
   OPJ_INT32 init_pos ;
};
#line 208 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_box opj_jp2_box_t;
#line 210 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
struct opj_jp2_header_handler {
   OPJ_UINT32 id ;
   OPJ_BOOL (*handler)(opj_jp2_t * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 220 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_header_handler opj_jp2_header_handler_t;
#line 223 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
struct opj_jp2_img_header_writer_handler {
   OPJ_BYTE *(*handler)(opj_jp2_t * , OPJ_UINT32 * ) ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_size ;
};
#line 232 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_img_header_writer_handler opj_jp2_img_header_writer_handler_t;
#line 55 "/root/patchweave_new/10/src/lib/openjp2/mqc.h"
struct opj_mqc_state {
   OPJ_UINT32 qeval ;
   OPJ_UINT32 mps ;
   struct opj_mqc_state *nmps ;
   struct opj_mqc_state *nlps ;
};
#line 64 "/root/patchweave_new/10/src/lib/openjp2/mqc.h"
typedef struct opj_mqc_state opj_mqc_state_t;
#line 71 "/root/patchweave_new/10/src/lib/openjp2/mqc.h"
struct opj_mqc {
   OPJ_UINT32 c ;
   OPJ_UINT32 a ;
   OPJ_UINT32 ct ;
   OPJ_BYTE *bp ;
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
   opj_mqc_state_t *ctxs[19] ;
   opj_mqc_state_t **curctx ;
};
#line 83 "/root/patchweave_new/10/src/lib/openjp2/mqc.h"
typedef struct opj_mqc opj_mqc_t;
#line 52 "/root/patchweave_new/10/src/lib/openjp2/raw.h"
struct opj_raw {
   OPJ_BYTE c ;
   OPJ_UINT32 ct ;
   OPJ_UINT32 lenmax ;
   OPJ_UINT32 len ;
   OPJ_BYTE *bp ;
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
};
#line 67 "/root/patchweave_new/10/src/lib/openjp2/raw.h"
typedef struct opj_raw opj_raw_t;
#line 55 "/root/patchweave_new/10/src/lib/openjp2/pi.h"
struct opj_pi_resolution {
   OPJ_UINT32 pdx ;
   OPJ_UINT32 pdy ;
   OPJ_UINT32 pw ;
   OPJ_UINT32 ph ;
};
#line 58 "/root/patchweave_new/10/src/lib/openjp2/pi.h"
typedef struct opj_pi_resolution opj_pi_resolution_t;
#line 63 "/root/patchweave_new/10/src/lib/openjp2/pi.h"
struct opj_pi_comp {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 numresolutions ;
   opj_pi_resolution_t *resolutions ;
};
#line 68 "/root/patchweave_new/10/src/lib/openjp2/pi.h"
typedef struct opj_pi_comp opj_pi_comp_t;
#line 73 "/root/patchweave_new/10/src/lib/openjp2/pi.h"
struct opj_pi_iterator {
   OPJ_BYTE tp_on ;
   OPJ_INT16 *include ;
   OPJ_UINT32 step_l ;
   OPJ_UINT32 step_r ;
   OPJ_UINT32 step_c ;
   OPJ_UINT32 step_p ;
   OPJ_UINT32 compno ;
   OPJ_UINT32 resno ;
   OPJ_UINT32 precno ;
   OPJ_UINT32 layno ;
   OPJ_BOOL first ;
   opj_poc_t poc ;
   OPJ_UINT32 numcomps ;
   opj_pi_comp_t *comps ;
   OPJ_INT32 tx0 ;
   OPJ_INT32 ty0 ;
   OPJ_INT32 tx1 ;
   OPJ_INT32 ty1 ;
   OPJ_INT32 x ;
   OPJ_INT32 y ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
};
#line 108 "/root/patchweave_new/10/src/lib/openjp2/pi.h"
typedef struct opj_pi_iterator opj_pi_iterator_t;
#line 57 "/root/patchweave_new/10/src/lib/openjp2/tgt.h"
struct opj_tgt_node {
   struct opj_tgt_node *parent ;
   OPJ_INT32 value ;
   OPJ_INT32 low ;
   OPJ_UINT32 known ;
};
#line 62 "/root/patchweave_new/10/src/lib/openjp2/tgt.h"
typedef struct opj_tgt_node opj_tgt_node_t;
#line 67 "/root/patchweave_new/10/src/lib/openjp2/tgt.h"
struct opj_tgt_tree {
   OPJ_UINT32 numleafsh ;
   OPJ_UINT32 numleafsv ;
   OPJ_UINT32 numnodes ;
   opj_tgt_node_t *nodes ;
   OPJ_UINT32 nodes_size ;
};
#line 74 "/root/patchweave_new/10/src/lib/openjp2/tgt.h"
typedef struct opj_tgt_tree opj_tgt_tree_t;
#line 55 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
struct opj_tcd_seg {
   OPJ_BYTE **data ;
   OPJ_UINT32 dataindex ;
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 real_num_passes ;
   OPJ_UINT32 len ;
   OPJ_UINT32 maxpasses ;
   OPJ_UINT32 numnewpasses ;
   OPJ_UINT32 newlen ;
};
#line 64 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_seg opj_tcd_seg_t;
#line 69 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
struct opj_tcd_pass {
   OPJ_UINT32 rate ;
   OPJ_FLOAT64 distortiondec ;
   OPJ_UINT32 len ;
   OPJ_UINT32 term ;
};
#line 74 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_pass opj_tcd_pass_t;
#line 79 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
struct opj_tcd_layer {
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 len ;
   OPJ_FLOAT64 disto ;
   OPJ_BYTE *data ;
};
#line 84 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_layer opj_tcd_layer_t;
#line 89 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
struct opj_tcd_cblk_enc {
   OPJ_BYTE *data ;
   opj_tcd_layer_t *layers ;
   opj_tcd_pass_t *passes ;
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numbps ;
   OPJ_UINT32 numlenbits ;
   OPJ_UINT32 data_size ;
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 numpassesinlayers ;
   OPJ_UINT32 totalpasses ;
};
#line 100 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_cblk_enc opj_tcd_cblk_enc_t;
#line 103 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
struct opj_tcd_cblk_dec {
   OPJ_BYTE *data ;
   opj_tcd_seg_t *segs ;
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numbps ;
   OPJ_UINT32 numlenbits ;
   OPJ_UINT32 data_max_size ;
   OPJ_UINT32 data_current_size ;
   OPJ_UINT32 numnewpasses ;
   OPJ_UINT32 numsegs ;
   OPJ_UINT32 real_num_segs ;
   OPJ_UINT32 m_current_max_segs ;
};
#line 115 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_cblk_dec opj_tcd_cblk_dec_t;
#line 123 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
union __anonunion_30 {
   opj_tcd_cblk_enc_t *enc ;
   opj_tcd_cblk_dec_t *dec ;
   void *blocks ;
};
#line 120 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
struct opj_tcd_precinct {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 cw ;
   OPJ_UINT32 ch ;
   union __anonunion_30 cblks ;
   OPJ_UINT32 block_size ;
   opj_tgt_tree_t *incltree ;
   opj_tgt_tree_t *imsbtree ;
};
#line 131 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_precinct opj_tcd_precinct_t;
#line 136 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
struct opj_tcd_band {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 bandno ;
   opj_tcd_precinct_t *precincts ;
   OPJ_UINT32 precincts_data_size ;
   OPJ_INT32 numbps ;
   OPJ_FLOAT32 stepsize ;
};
#line 143 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_band opj_tcd_band_t;
#line 148 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
struct opj_tcd_resolution {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 pw ;
   OPJ_UINT32 ph ;
   OPJ_UINT32 numbands ;
   opj_tcd_band_t bands[3] ;
};
#line 153 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_resolution opj_tcd_resolution_t;
#line 158 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
struct opj_tcd_tilecomp {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 minimum_num_resolutions ;
   opj_tcd_resolution_t *resolutions ;
   OPJ_UINT32 resolutions_size ;
   OPJ_INT32 *data ;
   OPJ_BOOL ownsData ;
   OPJ_UINT32 data_size_needed ;
   OPJ_UINT32 data_size ;
   OPJ_INT32 numpix ;
};
#line 170 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_tilecomp opj_tcd_tilecomp_t;
#line 176 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
struct opj_tcd_tile {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numcomps ;
   opj_tcd_tilecomp_t *comps ;
   OPJ_INT32 numpix ;
   OPJ_FLOAT64 distotile ;
   OPJ_FLOAT64 distolayer[100] ;
   OPJ_UINT32 packno ;
};
#line 184 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_tile opj_tcd_tile_t;
#line 189 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
struct opj_tcd_image {
   opj_tcd_tile_t *tiles ;
};
#line 193 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_image opj_tcd_image_t;
#line 199 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
struct opj_tcd {
   OPJ_INT32 tp_pos ;
   OPJ_UINT32 tp_num ;
   OPJ_UINT32 cur_tp_num ;
   OPJ_UINT32 cur_totnum_tp ;
   OPJ_UINT32 cur_pino ;
   opj_tcd_image_t *tcd_image ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_tcp_t *tcp ;
   OPJ_UINT32 tcd_tileno ;
   OPJ_UINT32 m_is_decoder ;
};
#line 223 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
typedef struct opj_tcd opj_tcd_t;
#line 94 "/root/patchweave_new/10/src/lib/openjp2/t1.h"
typedef OPJ_INT16 opj_flag_t;
#line 99 "/root/patchweave_new/10/src/lib/openjp2/t1.h"
struct opj_t1 {
   opj_mqc_t *mqc ;
   opj_raw_t *raw ;
   OPJ_INT32 *data ;
   opj_flag_t *flags ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 datasize ;
   OPJ_UINT32 flagssize ;
   OPJ_UINT32 flags_stride ;
   OPJ_UINT32 data_stride ;
   OPJ_BOOL encoder ;
};
#line 115 "/root/patchweave_new/10/src/lib/openjp2/t1.h"
typedef struct opj_t1 opj_t1_t;
#line 53 "/root/patchweave_new/10/src/lib/openjp2/t2.h"
struct opj_t2 {
   opj_image_t *image ;
   opj_cp_t *cp ;
};
#line 59 "/root/patchweave_new/10/src/lib/openjp2/t2.h"
typedef struct opj_t2 opj_t2_t;
#line 50 "/root/patchweave_new/10/src/lib/openjp2/opj_codec.h"
struct opj_decompression {
   OPJ_BOOL (*opj_read_header)(struct opj_stream_private * , void * , opj_image_t ** ,
                               struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_decode)(void * , struct opj_stream_private * , opj_image_t * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_read_tile_header)(void * , OPJ_UINT32 * , OPJ_UINT32 * , OPJ_INT32 * ,
                                    OPJ_INT32 * , OPJ_INT32 * , OPJ_INT32 * , OPJ_UINT32 * ,
                                    OPJ_BOOL * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_decode_tile_data)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  ,
                                    struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_decompress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   void (*opj_setup_decoder)(void * , opj_dparameters_t * ) ;
   OPJ_BOOL (*opj_set_decode_area)(void * , opj_image_t * , OPJ_INT32  , OPJ_INT32  ,
                                   OPJ_INT32  , OPJ_INT32  , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_get_decoded_tile)(void * , opj_stream_private_t * , opj_image_t * ,
                                    struct opj_event_mgr * , OPJ_UINT32  ) ;
   OPJ_BOOL (*opj_set_decoded_resolution_factor)(void * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 121 "/root/patchweave_new/10/src/lib/openjp2/opj_codec.h"
struct opj_compression {
   OPJ_BOOL (*opj_start_compress)(void * , struct opj_stream_private * , struct opj_image * ,
                                  struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_encode)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_write_tile)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  , struct opj_stream_private * ,
                              struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_compress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   OPJ_BOOL (*opj_setup_encoder)(void * , opj_cparameters_t * , struct opj_image * ,
                                 struct opj_event_mgr * ) ;
};
#line 45 "/root/patchweave_new/10/src/lib/openjp2/opj_codec.h"
union __anonunion_31 {
   struct opj_decompression m_decompression ;
   struct opj_compression m_compression ;
};
#line 42 "/root/patchweave_new/10/src/lib/openjp2/opj_codec.h"
struct opj_codec_private {
   union __anonunion_31 m_codec_data ;
   void *m_codec ;
   opj_event_mgr_t m_event_mgr ;
   OPJ_BOOL is_decompressor ;
   void (*opj_dump_codec)(void * , OPJ_INT32  , FILE * ) ;
   opj_codestream_info_v2_t *(*opj_get_codec_info)(void * ) ;
   opj_codestream_index_t *(*opj_get_codec_index)(void * ) ;
};
#line 161 "/root/patchweave_new/10/src/lib/openjp2/opj_codec.h"
typedef struct opj_codec_private opj_codec_private_t;
#line 192 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler ;
#line 1187 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
struct j2k_prog_order {
   OPJ_PROG_ORDER enum_prog ;
   char str_prog[5] ;
};
#line 1190 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
typedef struct j2k_prog_order j2k_prog_order_t;
#line 1212 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
typedef void (*opj_j2k_mct_function)(void const   * , void * , OPJ_UINT32  );
#line 1238 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler {
   OPJ_UINT32 id ;
   OPJ_UINT32 states ;
   OPJ_BOOL (*handler)(opj_j2k_t * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 1250 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
typedef struct opj_dec_memory_marker_handler opj_dec_memory_marker_handler_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_35 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 47 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_36 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_37 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 59 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_38 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_39 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_40 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 78 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_41 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 85 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_42 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_43 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_44 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_45 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 109 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_46 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 117 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_47 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_48 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion_35 __annonCompField3 ;
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
   union __anonunion_36 __annonCompField4 ;
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
   union __anonunion_37 __annonCompField5 ;
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
   union __anonunion_38 __annonCompField6 ;
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
   union __anonunion_39 __annonCompField7 ;
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
   union __anonunion_40 __annonCompField8 ;
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
   union __anonunion_41 __annonCompField9 ;
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
   union __anonunion_42 __annonCompField10 ;
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
   union __anonunion_43 __annonCompField11 ;
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
   union __anonunion_44 __annonCompField12 ;
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
   union __anonunion_45 __annonCompField13 ;
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
   union __anonunion_46 __annonCompField14 ;
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
   union __anonunion_47 __annonCompField15 ;
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
   union __anonunion_48 __annonCompField16 ;
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 42 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __m64;
#line 48 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v2si;
#line 49 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v4hi;
#line 50 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v8qi;
#line 69 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
typedef int __m128;
#line 72 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
typedef int __m128_u;
#line 75 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
typedef int __v4sf;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v2df;
#line 41 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v2di;
#line 42 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v2du;
#line 43 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v4si;
#line 44 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v4su;
#line 45 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v8hi;
#line 46 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v8hu;
#line 47 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v16qi;
#line 49 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v16qu;
#line 53 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128i;
#line 54 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128d;
#line 57 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128i_u;
#line 58 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128d_u;
#line 55 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
struct dwt_local {
   OPJ_INT32 *mem ;
   OPJ_INT32 dn ;
   OPJ_INT32 sn ;
   OPJ_INT32 cas ;
};
#line 60 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
typedef struct dwt_local opj_dwt_t;
#line 62 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
union __anonunion_110 {
   OPJ_FLOAT32 f[4] ;
};
#line 64 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
typedef union __anonunion_110 opj_v4_t;
#line 66 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
struct v4dwt_local {
   opj_v4_t *wavelet ;
   OPJ_INT32 dn ;
   OPJ_INT32 sn ;
   OPJ_INT32 cas ;
};
#line 71 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
typedef struct v4dwt_local opj_v4dwt_t;
#line 70 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned short uint16;
#line 73 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned int uint32;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct tiff ;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct tiff TIFF;
#line 65 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef long tmsize_t;
#line 72 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint32 tstrile_t;
#line 73 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tstrile_t tstrip_t;
#line 75 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tmsize_t tsize_t;
#line 76 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void *tdata_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 33 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 45 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 481 "/usr/include/pngconf.h"
typedef unsigned char png_byte;
#line 511 "/usr/include/pngconf.h"
typedef unsigned int png_uint_32;
#line 577 "/usr/include/pngconf.h"
typedef void *png_voidp;
#line 580 "/usr/include/pngconf.h"
typedef png_byte *png_const_bytep;
#line 590 "/usr/include/pngconf.h"
typedef char const   *png_const_charp;
#line 597 "/usr/include/pngconf.h"
typedef FILE *png_FILE_p;
#line 606 "/usr/include/pngconf.h"
typedef png_byte **png_bytepp;
#line 454 "/usr/include/png.h"
struct png_struct_def ;
#line 454 "/usr/include/png.h"
typedef struct png_struct_def png_struct;
#line 456 "/usr/include/png.h"
typedef png_struct *png_structp;
#line 457 "/usr/include/png.h"
typedef png_struct **png_structpp;
#line 468
struct png_info_def ;
#line 468 "/usr/include/png.h"
typedef struct png_info_def png_info;
#line 469 "/usr/include/png.h"
typedef png_info *png_infop;
#line 471 "/usr/include/png.h"
typedef png_info **png_infopp;
#line 484 "/usr/include/png.h"
typedef png_struct *png_structrp;
#line 485 "/usr/include/png.h"
typedef png_struct *png_const_structrp;
#line 486 "/usr/include/png.h"
typedef png_info *png_inforp;
#line 487 "/usr/include/png.h"
typedef png_info *png_const_inforp;
#line 515 "/usr/include/png.h"
struct png_color_8_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
   png_byte gray ;
   png_byte alpha ;
};
#line 522 "/usr/include/png.h"
typedef struct png_color_8_struct png_color_8;
#line 524 "/usr/include/png.h"
typedef png_color_8 *png_const_color_8p;
#line 42 "/root/patchweave_new/10/src/bin/jp2/convert.h"
struct raw_comp_cparameters {
   int dx ;
   int dy ;
};
#line 48 "/root/patchweave_new/10/src/bin/jp2/convert.h"
typedef struct raw_comp_cparameters raw_comp_cparameters_t;
#line 52 "/root/patchweave_new/10/src/bin/jp2/convert.h"
struct raw_cparameters {
   int rawWidth ;
   int rawHeight ;
   int rawComp ;
   int rawBitDepth ;
   OPJ_BOOL rawSigned ;
   raw_comp_cparameters_t *rawComps ;
};
#line 66 "/root/patchweave_new/10/src/bin/jp2/convert.h"
typedef struct raw_cparameters raw_cparameters_t;
#line 617 "/root/patchweave_new/10/src/bin/jp2/convert.c"
typedef unsigned short WORD;
#line 620 "/root/patchweave_new/10/src/bin/jp2/convert.c"
typedef unsigned int DWORD;
#line 622 "/root/patchweave_new/10/src/bin/jp2/convert.c"
struct __anonstruct_151 {
   WORD bfType ;
   DWORD bfSize ;
   WORD bfReserved1 ;
   WORD bfReserved2 ;
   DWORD bfOffBits ;
};
#line 628 "/root/patchweave_new/10/src/bin/jp2/convert.c"
typedef struct __anonstruct_151 BITMAPFILEHEADER_t;
#line 630 "/root/patchweave_new/10/src/bin/jp2/convert.c"
struct __anonstruct_152 {
   DWORD biSize ;
   DWORD biWidth ;
   DWORD biHeight ;
   WORD biPlanes ;
   WORD biBitCount ;
   DWORD biCompression ;
   DWORD biSizeImage ;
   DWORD biXpelsPerMeter ;
   DWORD biYpelsPerMeter ;
   DWORD biClrUsed ;
   DWORD biClrImportant ;
};
#line 642 "/root/patchweave_new/10/src/bin/jp2/convert.c"
typedef struct __anonstruct_152 BITMAPINFOHEADER_t;
#line 1610 "/root/patchweave_new/10/src/bin/jp2/convert.c"
struct pnm_header {
   int width ;
   int height ;
   int maxval ;
   int depth ;
   int format ;
   char rgb ;
   char rgba ;
   char gray ;
   char graya ;
   char bw ;
   char ok ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 6 "/root/patchweave_new/10/src/bin/common/opj_getopt.h"
struct opj_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 12 "/root/patchweave_new/10/src/bin/common/opj_getopt.h"
typedef struct opj_option opj_option_t;
#line 76 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
struct dircnt {
   char *filename_buf ;
   char **filename ;
};
#line 81 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
typedef struct dircnt dircnt_t;
#line 84 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
struct img_folder {
   char *imgdirpath ;
   char const   *out_format ;
   char set_imgdir ;
   char set_out_format ;
};
#line 94 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
typedef struct img_folder img_fol_t;
#line 96
enum opj_prec_mode {
    OPJ_PREC_MODE_CLIP = 0,
    OPJ_PREC_MODE_SCALE = 1
} ;
#line 100 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
typedef enum opj_prec_mode opj_precision_mode;
#line 102 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
struct opj_prec {
   OPJ_UINT32 prec ;
   opj_precision_mode mode ;
};
#line 106 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
typedef struct opj_prec opj_precision;
#line 108 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
struct opj_decompress_params {
   opj_dparameters_t core ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   OPJ_UINT32 DA_x0 ;
   OPJ_UINT32 DA_x1 ;
   OPJ_UINT32 DA_y0 ;
   OPJ_UINT32 DA_y1 ;
   OPJ_BOOL m_verbose ;
   OPJ_UINT32 tile_index ;
   OPJ_UINT32 nb_tile_to_decode ;
   opj_precision *precision ;
   OPJ_UINT32 nb_precision ;
   int force_rgb ;
   int upsample ;
};
#line 145 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
typedef struct opj_decompress_params opj_decompress_parameters;
#line 3197 "/root/patchweave_new/10/src/bin/jp2/convert.c"
union __anonunion_153 ;
#line 3202
union __anonunion_154 ;
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                  size_t __n ) ;
#line 61
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 122
extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src ) ;
#line 125
extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                   size_t __n ) ;
#line 130
extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src ) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 140 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 138 "/usr/include/stdio.h"
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 326
extern int fprintf(FILE *__stream , char const   *__format  , ...) ;
#line 332
extern int printf(char const   *__format  , ...) ;
#line 334
extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__format 
                                                 , ...) ;
#line 358
extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __maxlen , char const   *__format ,
                                                   __gnuc_va_list __arg ) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 564
extern char *fgets(char *__s , int __n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 646
extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 1051 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.h"
char const   *opj_version(void) ;
#line 1067
opj_image_t *opj_image_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                              OPJ_COLOR_SPACE clrspc ) ;
#line 1074
void opj_image_destroy(opj_image_t *image ) ;
#line 1085
opj_image_t *opj_image_tile_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                                   OPJ_COLOR_SPACE clrspc ) ;
#line 1100
opj_stream_t *opj_stream_default_create(OPJ_BOOL l_is_input ) ;
#line 1110
opj_stream_t *opj_stream_create(OPJ_SIZE_T p_buffer_size , OPJ_BOOL l_is_input ) ;
#line 1118
void opj_stream_destroy(opj_stream_t *p_stream ) ;
#line 1125
void opj_stream_set_read_function(opj_stream_t *p_stream , OPJ_SIZE_T (*p_function)(void * ,
                                                                                    OPJ_SIZE_T  ,
                                                                                    void * ) ) ;
#line 1132
void opj_stream_set_write_function(opj_stream_t *p_stream , OPJ_SIZE_T (*p_function)(void * ,
                                                                                     OPJ_SIZE_T  ,
                                                                                     void * ) ) ;
#line 1139
void opj_stream_set_skip_function(opj_stream_t *p_stream , OPJ_OFF_T (*p_function)(OPJ_OFF_T  ,
                                                                                   void * ) ) ;
#line 1146
void opj_stream_set_seek_function(opj_stream_t *p_stream , OPJ_BOOL (*p_function)(OPJ_OFF_T  ,
                                                                                  void * ) ) ;
#line 1154
void opj_stream_set_user_data(opj_stream_t *p_stream , void *p_data , void (*p_function)(void * ) ) ;
#line 1162
void opj_stream_set_user_data_length(opj_stream_t *p_stream , OPJ_UINT64 data_length ) ;
#line 1169
opj_stream_t *opj_stream_create_default_file_stream(char const   *fname , OPJ_BOOL p_is_read_stream ) ;
#line 1176
opj_stream_t *opj_stream_create_file_stream(char const   *fname , OPJ_SIZE_T p_size ,
                                            OPJ_BOOL p_is_read_stream ) ;
#line 1191
OPJ_BOOL opj_set_info_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                        void * ) ,
                              void *p_user_data ) ;
#line 1200
OPJ_BOOL opj_set_warning_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                           void * ) ,
                                 void *p_user_data ) ;
#line 1209
OPJ_BOOL opj_set_error_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                         void * ) ,
                               void *p_user_data ) ;
#line 1225
opj_codec_t *opj_create_decompress(OPJ_CODEC_FORMAT p_format ) ;
#line 1232
void opj_destroy_codec(opj_codec_t *p_codec ) ;
#line 1239
OPJ_BOOL opj_end_decompress(opj_codec_t *p_codec , opj_stream_t *p_stream ) ;
#line 1247
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) ;
#line 1258
OPJ_BOOL opj_setup_decoder(opj_codec_t *p_codec , opj_dparameters_t *parameters ) ;
#line 1270
OPJ_BOOL opj_read_header(opj_stream_t *p_stream , opj_codec_t *p_codec , opj_image_t **p_image ) ;
#line 1286
OPJ_BOOL opj_set_decode_area(opj_codec_t *p_codec , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                             OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ) ;
#line 1299
OPJ_BOOL opj_decode(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ) ;
#line 1313
OPJ_BOOL opj_get_decoded_tile(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ,
                              OPJ_UINT32 tile_index ) ;
#line 1325
OPJ_BOOL opj_set_decoded_resolution_factor(opj_codec_t *p_codec , OPJ_UINT32 res_factor ) ;
#line 1339
OPJ_BOOL opj_write_tile(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                        OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) ;
#line 1366
OPJ_BOOL opj_read_tile_header(opj_codec_t *p_codec , opj_stream_t *p_stream , OPJ_UINT32 *p_tile_index ,
                              OPJ_UINT32 *p_data_size , OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 ,
                              OPJ_INT32 *p_tile_x1 , OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                              OPJ_BOOL *p_should_go_on ) ;
#line 1387
OPJ_BOOL opj_decode_tile_data(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                              OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) ;
#line 1400
opj_codec_t *opj_create_compress(OPJ_CODEC_FORMAT p_format ) ;
#line 1423
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) ;
#line 1431
OPJ_BOOL opj_setup_encoder(opj_codec_t *p_codec , opj_cparameters_t *parameters ,
                           opj_image_t *p_image ) ;
#line 1441
OPJ_BOOL opj_start_compress(opj_codec_t *p_codec , opj_image_t *p_image , opj_stream_t *p_stream ) ;
#line 1450
OPJ_BOOL opj_end_compress(opj_codec_t *p_codec , opj_stream_t *p_stream ) ;
#line 1460
OPJ_BOOL opj_encode(opj_codec_t *p_info , opj_stream_t *p_stream ) ;
#line 1473
void opj_destroy_cstr_info(opj_codestream_info_v2_t **cstr_info ) ;
#line 1484
void opj_dump_codec(opj_codec_t *p_codec , OPJ_INT32 info_flag , FILE *output_stream ) ;
#line 1496
opj_codestream_info_v2_t *opj_get_cstr_info(opj_codec_t *p_codec ) ;
#line 1506
opj_codestream_index_t *opj_get_cstr_index(opj_codec_t *p_codec ) ;
#line 1508
void opj_destroy_cstr_index(opj_codestream_index_t **p_cstr_index ) ;
#line 1548
OPJ_BOOL opj_set_MCT(opj_cparameters_t *parameters , OPJ_FLOAT32 *pEncodingMatrix ,
                     OPJ_INT32 *p_dc_shift , OPJ_UINT32 pNbComp ) ;
#line 51 "/root/patchweave_new/10/src/lib/openjp2/opj_clock.h"
OPJ_FLOAT64 opj_clock(void) ;
#line 81 "/root/patchweave_new/10/src/lib/openjp2/function_list.h"
opj_procedure_list_t *opj_procedure_list_create(void) ;
#line 88
void opj_procedure_list_destroy(opj_procedure_list_t *p_list ) ;
#line 98
OPJ_BOOL opj_procedure_list_add_procedure(opj_procedure_list_t *p_validation_list ,
                                          void (*p_procedure)(void) ) ;
#line 107
OPJ_UINT32 opj_procedure_list_get_nb_procedures(opj_procedure_list_t *p_validation_list ) ;
#line 118
opj_procedure *opj_procedure_list_get_first_procedure(opj_procedure_list_t *p_validation_list ) ;
#line 127
void opj_procedure_list_clear(opj_procedure_list_t *p_validation_list ) ;
#line 90 "/root/patchweave_new/10/src/lib/openjp2/event.h"
OPJ_BOOL opj_event_msg(opj_event_mgr_t *p_event_mgr , OPJ_INT32 event_type , char const   *fmt 
                       , ...) ;
#line 96
void opj_set_default_event_handler(opj_event_mgr_t *p_manager ) ;
#line 76 "/root/patchweave_new/10/src/lib/openjp2/bio.h"
opj_bio_t *opj_bio_create(void) ;
#line 81
void opj_bio_destroy(opj_bio_t *bio ) ;
#line 87
ptrdiff_t opj_bio_numbytes(opj_bio_t *bio ) ;
#line 94
void opj_bio_init_enc(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 101
void opj_bio_init_dec(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 108
void opj_bio_write(opj_bio_t *bio , OPJ_UINT32 v , OPJ_UINT32 n ) ;
#line 115
OPJ_UINT32 opj_bio_read(opj_bio_t *bio , OPJ_UINT32 n ) ;
#line 121
OPJ_BOOL opj_bio_flush(opj_bio_t *bio ) ;
#line 127
OPJ_BOOL opj_bio_inalign(opj_bio_t *bio ) ;
#line 180 "/root/patchweave_new/10/src/lib/openjp2/cio.h"
void opj_write_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 189
void opj_read_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 198
void opj_write_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 207
void opj_read_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 215
void opj_write_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) ;
#line 222
void opj_write_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) ;
#line 229
void opj_read_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) ;
#line 236
void opj_read_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) ;
#line 243
void opj_read_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) ;
#line 250
void opj_read_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) ;
#line 257
void opj_write_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) ;
#line 264
void opj_write_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) ;
#line 274
OPJ_SIZE_T opj_stream_read_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) ;
#line 284
OPJ_SIZE_T opj_stream_write_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                 OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) ;
#line 292
OPJ_BOOL opj_stream_flush(opj_stream_private_t *p_stream , opj_event_mgr_t *p_event_mgr ) ;
#line 301
OPJ_OFF_T opj_stream_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , opj_event_mgr_t *p_event_mgr ) ;
#line 310
OPJ_OFF_T opj_stream_tell(opj_stream_private_t *p_stream ) ;
#line 320
OPJ_OFF_T opj_stream_get_number_byte_left(opj_stream_private_t *p_stream ) ;
#line 329
OPJ_OFF_T opj_stream_write_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                                opj_event_mgr_t *p_event_mgr ) ;
#line 338
OPJ_OFF_T opj_stream_read_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) ;
#line 347
OPJ_BOOL opj_stream_read_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                              opj_event_mgr_t *p_event_mgr ) ;
#line 356
OPJ_BOOL opj_stream_write_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) ;
#line 365
OPJ_BOOL opj_stream_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , struct opj_event_mgr *p_event_mgr ) ;
#line 370
OPJ_BOOL opj_stream_has_seek(opj_stream_private_t *p_stream ) ;
#line 375
OPJ_SIZE_T opj_stream_default_read(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) ;
#line 380
OPJ_SIZE_T opj_stream_default_write(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) ;
#line 385
OPJ_OFF_T opj_stream_default_skip(OPJ_OFF_T p_nb_bytes , void *p_user_data ) ;
#line 390
OPJ_BOOL opj_stream_default_seek(OPJ_OFF_T p_nb_bytes , void *p_user_data ) ;
#line 51 "/root/patchweave_new/10/src/lib/openjp2/image.h"
opj_image_t *opj_image_create0(void) ;
#line 61
void opj_image_comp_header_update(opj_image_t *p_image_header , struct opj_cp *p_cp ) ;
#line 63
void opj_copy_image_header(opj_image_t *p_image_src , opj_image_t *p_image_dest ) ;
#line 56 "/root/patchweave_new/10/src/lib/openjp2/invert.h"
OPJ_BOOL opj_matrix_inversion_f(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix ,
                                OPJ_UINT32 nb_compo ) ;
#line 587 "/root/patchweave_new/10/src/lib/openjp2/j2k.h"
void opj_j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) ;
#line 594
opj_j2k_t *opj_j2k_create_compress(void) ;
#line 597
OPJ_BOOL opj_j2k_setup_encoder(opj_j2k_t *p_j2k , opj_cparameters_t *parameters ,
                               opj_image_t *image , opj_event_mgr_t *p_manager ) ;
#line 605
char *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) ;
#line 616
OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) ;
#line 630
OPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream , opj_j2k_t *p_j2k , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) ;
#line 641
void opj_j2k_destroy(opj_j2k_t *p_j2k ) ;
#line 648
void j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind ) ;
#line 659
OPJ_BOOL opj_j2k_decode_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) ;
#line 680
OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t *p_j2k , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 706
OPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) ;
#line 717
opj_j2k_t *opj_j2k_create_decompress(void) ;
#line 728
void j2k_dump(opj_j2k_t *p_j2k , OPJ_INT32 flag , FILE *out_stream ) ;
#line 739
void j2k_dump_image_header(opj_image_t *img_header , OPJ_BOOL dev_dump_flag , FILE *out_stream ) ;
#line 748
void j2k_dump_image_comp_header(opj_image_comp_t *comp_header , OPJ_BOOL dev_dump_flag ,
                                FILE *out_stream ) ;
#line 757
opj_codestream_info_v2_t *j2k_get_cstr_info(opj_j2k_t *p_j2k ) ;
#line 766
opj_codestream_index_t *j2k_get_cstr_index(opj_j2k_t *p_j2k ) ;
#line 776
OPJ_BOOL opj_j2k_decode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) ;
#line 782
OPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) ;
#line 788
OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) ;
#line 802
OPJ_BOOL opj_j2k_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) ;
#line 812
OPJ_BOOL opj_j2k_encode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 826
OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_image_t *p_image , opj_event_mgr_t *p_manager ) ;
#line 835
OPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) ;
#line 839
OPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t *p_tcp , opj_image_t *p_image ) ;
#line 247 "/root/patchweave_new/10/src/lib/openjp2/jp2.h"
OPJ_BOOL opj_jp2_write_jp2h(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 257
void opj_jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) ;
#line 268
OPJ_BOOL opj_jp2_decode(opj_jp2_t *jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) ;
#line 283
OPJ_BOOL opj_jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ,
                               opj_event_mgr_t *p_manager ) ;
#line 295
OPJ_BOOL opj_jp2_encode(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 310
OPJ_BOOL opj_jp2_start_compress(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_image_t *p_image ,
                                opj_event_mgr_t *p_manager ) ;
#line 320
OPJ_BOOL opj_jp2_end_compress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 330
OPJ_BOOL opj_jp2_end_decompress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 344
OPJ_BOOL opj_jp2_read_header(opj_stream_private_t *p_stream , opj_jp2_t *jp2 , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) ;
#line 363
OPJ_BOOL opj_jp2_read_tile_header(opj_jp2_t *p_jp2 , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 385
OPJ_BOOL opj_jp2_write_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) ;
#line 403
OPJ_BOOL opj_jp2_decode_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) ;
#line 415
opj_jp2_t *opj_jp2_create(OPJ_BOOL p_is_decoder ) ;
#line 421
void opj_jp2_destroy(opj_jp2_t *jp2 ) ;
#line 437
OPJ_BOOL opj_jp2_set_decode_area(opj_jp2_t *p_jp2 , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) ;
#line 446
OPJ_BOOL opj_jp2_get_tile(opj_jp2_t *p_jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) ;
#line 456
OPJ_BOOL opj_jp2_set_decoded_resolution_factor(opj_jp2_t *p_jp2 , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) ;
#line 470
void jp2_dump(opj_jp2_t *p_jp2 , OPJ_INT32 flag , FILE *out_stream ) ;
#line 479
opj_codestream_info_v2_t *jp2_get_cstr_info(opj_jp2_t *p_jp2 ) ;
#line 488
opj_codestream_index_t *jp2_get_cstr_index(opj_jp2_t *p_jp2 ) ;
#line 92 "/root/patchweave_new/10/src/lib/openjp2/mqc.h"
opj_mqc_t *opj_mqc_create(void) ;
#line 97
void opj_mqc_destroy(opj_mqc_t *mqc ) ;
#line 103
OPJ_UINT32 opj_mqc_numbytes(opj_mqc_t *mqc ) ;
#line 109
void opj_mqc_resetstates(opj_mqc_t *mqc ) ;
#line 117
void opj_mqc_setstate(opj_mqc_t *mqc , OPJ_UINT32 ctxno , OPJ_UINT32 msb , OPJ_INT32 prob ) ;
#line 123
void opj_mqc_init_enc(opj_mqc_t *mqc , OPJ_BYTE *bp ) ;
#line 135
void opj_mqc_encode(opj_mqc_t *mqc , OPJ_UINT32 d ) ;
#line 140
void opj_mqc_flush(opj_mqc_t *mqc ) ;
#line 147
void opj_mqc_bypass_init_enc(opj_mqc_t *mqc ) ;
#line 155
void opj_mqc_bypass_enc(opj_mqc_t *mqc , OPJ_UINT32 d ) ;
#line 162
OPJ_UINT32 opj_mqc_bypass_flush_enc(opj_mqc_t *mqc ) ;
#line 167
void opj_mqc_reset_enc(opj_mqc_t *mqc ) ;
#line 173
OPJ_UINT32 opj_mqc_restart_enc(opj_mqc_t *mqc ) ;
#line 178
void opj_mqc_restart_init_enc(opj_mqc_t *mqc ) ;
#line 183
void opj_mqc_erterm_enc(opj_mqc_t *mqc ) ;
#line 188
void opj_mqc_segmark_enc(opj_mqc_t *mqc ) ;
#line 195
OPJ_BOOL opj_mqc_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 201
OPJ_INT32 opj_mqc_decode(opj_mqc_t *mqc ) ;
#line 76 "/root/patchweave_new/10/src/lib/openjp2/raw.h"
opj_raw_t *opj_raw_create(void) ;
#line 81
void opj_raw_destroy(opj_raw_t *raw ) ;
#line 87
OPJ_UINT32 opj_raw_numbytes(opj_raw_t *raw ) ;
#line 94
void opj_raw_init_dec(opj_raw_t *raw , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 100
OPJ_UINT32 opj_raw_decode(opj_raw_t *raw ) ;
#line 123 "/root/patchweave_new/10/src/lib/openjp2/pi.h"
opj_pi_iterator_t *opj_pi_initialise_encode(opj_image_t *p_image , opj_cp_t *p_cp ,
                                            OPJ_UINT32 p_tile_no , J2K_T2_MODE p_t2_mode ) ;
#line 135
void opj_pi_update_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) ;
#line 149
void opj_pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , OPJ_UINT32 tileno ,
                          OPJ_UINT32 pino , OPJ_UINT32 tpnum , OPJ_INT32 tppos , J2K_T2_MODE t2_mode ) ;
#line 165
opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) ;
#line 174
void opj_pi_destroy(opj_pi_iterator_t *p_pi , OPJ_UINT32 p_nb_elements ) ;
#line 182
OPJ_BOOL opj_pi_next(opj_pi_iterator_t *pi ) ;
#line 86 "/root/patchweave_new/10/src/lib/openjp2/tgt.h"
opj_tgt_tree_t *opj_tgt_create(OPJ_UINT32 numleafsh , OPJ_UINT32 numleafsv ) ;
#line 96
opj_tgt_tree_t *opj_tgt_init(opj_tgt_tree_t *p_tree , OPJ_UINT32 p_num_leafs_h , OPJ_UINT32 p_num_leafs_v ) ;
#line 103
void opj_tgt_destroy(opj_tgt_tree_t *p_tree ) ;
#line 108
void opj_tgt_reset(opj_tgt_tree_t *p_tree ) ;
#line 115
void opj_tgt_setvalue(opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 value ) ;
#line 125
void opj_tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 threshold ) ;
#line 137
OPJ_UINT32 opj_tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno ,
                          OPJ_INT32 threshold ) ;
#line 239 "/root/patchweave_new/10/src/lib/openjp2/tcd.h"
opj_tcd_t *opj_tcd_create(OPJ_BOOL p_is_decoder ) ;
#line 245
void opj_tcd_destroy(opj_tcd_t *tcd ) ;
#line 255
OPJ_BOOL opj_tcd_init(opj_tcd_t *p_tcd , opj_image_t *p_image , opj_cp_t *p_cp ) ;
#line 268
OPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ) ;
#line 270
void opj_tcd_makelayer_fixed(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_UINT32 final ) ;
#line 272
void opj_tcd_rateallocate_fixed(opj_tcd_t *tcd ) ;
#line 274
void opj_tcd_makelayer(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_FLOAT64 thresh , OPJ_UINT32 final ) ;
#line 279
OPJ_BOOL opj_tcd_rateallocate(opj_tcd_t *tcd , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 len , opj_codestream_info_t *cstr_info ) ;
#line 288
OPJ_UINT32 opj_tcd_get_decoded_tile_size(opj_tcd_t *p_tcd ) ;
#line 300
OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , OPJ_BYTE *p_dest ,
                             OPJ_UINT32 *p_data_written , OPJ_UINT32 p_max_length ,
                             opj_codestream_info_t *p_cstr_info ) ;
#line 316
OPJ_BOOL opj_tcd_decode_tile(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_UINT32 p_max_length ,
                             OPJ_UINT32 p_tile_no , opj_codestream_index_t *p_cstr_index ) ;
#line 326
OPJ_BOOL opj_tcd_update_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest , OPJ_UINT32 p_dest_length ) ;
#line 333
OPJ_UINT32 opj_tcd_get_encoded_tile_size(opj_tcd_t *p_tcd ) ;
#line 343
OPJ_BOOL opj_tcd_init_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ) ;
#line 349
OPJ_BOOL opj_tcd_copy_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_UINT32 p_src_length ) ;
#line 358
OPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec ) ;
#line 131 "/root/patchweave_new/10/src/lib/openjp2/t1.h"
OPJ_BOOL opj_t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                             OPJ_FLOAT64 *mct_norms , OPJ_UINT32 mct_numcomps ) ;
#line 143
OPJ_BOOL opj_t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) ;
#line 154
opj_t1_t *opj_t1_create(OPJ_BOOL isEncoder ) ;
#line 161
void opj_t1_destroy(opj_t1_t *p_t1 ) ;
#line 61 "/root/patchweave_new/10/src/lib/openjp2/dwt.h"
OPJ_BOOL opj_dwt_encode(opj_tcd_tilecomp_t *tilec ) ;
#line 69
OPJ_BOOL opj_dwt_decode(opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) ;
#line 76
OPJ_UINT32 opj_dwt_getgain(OPJ_UINT32 orient ) ;
#line 83
OPJ_FLOAT64 opj_dwt_getnorm(OPJ_UINT32 level , OPJ_UINT32 orient ) ;
#line 89
OPJ_BOOL opj_dwt_encode_real(opj_tcd_tilecomp_t *tilec ) ;
#line 96
OPJ_BOOL opj_dwt_decode_real(opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) ;
#line 103
OPJ_UINT32 opj_dwt_getgain_real(OPJ_UINT32 orient ) ;
#line 110
OPJ_FLOAT64 opj_dwt_getnorm_real(OPJ_UINT32 level , OPJ_UINT32 orient ) ;
#line 116
void opj_dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , OPJ_UINT32 prec ) ;
#line 80 "/root/patchweave_new/10/src/lib/openjp2/t2.h"
OPJ_BOOL opj_t2_encode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_UINT32 p_maxlayers , OPJ_BYTE *p_dest , OPJ_UINT32 *p_data_written ,
                               OPJ_UINT32 p_max_len , opj_codestream_info_t *cstr_info ,
                               OPJ_UINT32 p_tp_num , OPJ_INT32 p_tp_pos , OPJ_UINT32 p_pino ,
                               J2K_T2_MODE p_t2_mode ) ;
#line 105
OPJ_BOOL opj_t2_decode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_len ,
                               opj_codestream_index_t *p_cstr_index ) ;
#line 120
opj_t2_t *opj_t2_create(opj_image_t *p_image , opj_cp_t *p_cp ) ;
#line 126
void opj_t2_destroy(opj_t2_t *t2 ) ;
#line 63 "/root/patchweave_new/10/src/lib/openjp2/mct.h"
void opj_mct_encode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_UINT32 n ) ;
#line 71
void opj_mct_decode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_UINT32 n ) ;
#line 77
OPJ_FLOAT64 opj_mct_getnorm(OPJ_UINT32 compno ) ;
#line 86
void opj_mct_encode_real(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_UINT32 n ) ;
#line 94
void opj_mct_decode_real(OPJ_FLOAT32 *c0 , OPJ_FLOAT32 *c1 , OPJ_FLOAT32 *c2 , OPJ_UINT32 n ) ;
#line 100
OPJ_FLOAT64 opj_mct_getnorm_real(OPJ_UINT32 compno ) ;
#line 111
OPJ_BOOL opj_mct_encode_custom(OPJ_BYTE *pCodingdata , OPJ_UINT32 n , OPJ_BYTE **pData ,
                               OPJ_UINT32 pNbComp , OPJ_UINT32 isSigned ) ;
#line 126
OPJ_BOOL opj_mct_decode_custom(OPJ_BYTE *pDecodingData , OPJ_UINT32 n , OPJ_BYTE **pData ,
                               OPJ_UINT32 pNbComp , OPJ_UINT32 isSigned ) ;
#line 139
void opj_calculate_norms(OPJ_FLOAT64 *pNorms , OPJ_UINT32 pNbComps , OPJ_FLOAT32 *pMatrix ) ;
#line 145
OPJ_FLOAT64 *opj_mct_get_mct_norms(void) ;
#line 149
OPJ_FLOAT64 *opj_mct_get_mct_norms_real(void) ;
#line 56 "/root/patchweave_new/10/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_min(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 57
  if (a < b) {
#line 57
    tmp = a;
  } else {
#line 57
    tmp = b;
  }
#line 57
  return (tmp);
}
}
#line 64 "/root/patchweave_new/10/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_min(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 65
  if (a < b) {
#line 65
    tmp = a;
  } else {
#line 65
    tmp = b;
  }
#line 65
  return (tmp);
}
}
#line 72 "/root/patchweave_new/10/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_max(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 73
  if (a > b) {
#line 73
    tmp = a;
  } else {
#line 73
    tmp = b;
  }
#line 73
  return (tmp);
}
}
#line 80 "/root/patchweave_new/10/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_max(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 81
  if (a > b) {
#line 81
    tmp = a;
  } else {
#line 81
    tmp = b;
  }
#line 81
  return (tmp);
}
}
#line 93 "/root/patchweave_new/10/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_clamp(OPJ_INT32 a , OPJ_INT32 min , OPJ_INT32 max ) 
{ 


  {
#line 94
  if (a < min) {
#line 95
    return (min);
  }
#line 96
  if (a > max) {
#line 97
    return (max);
  }
#line 98
  return (a);
}
}
#line 103 "/root/patchweave_new/10/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_abs(OPJ_INT32 a ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 104
  if (a < 0) {
#line 104
    tmp = - a;
  } else {
#line 104
    tmp = a;
  }
#line 104
  return (tmp);
}
}
#line 110 "/root/patchweave_new/10/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_ceildiv(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 112
  return (((a + b) - 1) / b);
}
}
#line 119 "/root/patchweave_new/10/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_ceildiv(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 


  {
#line 120
  return (((a + b) - 1U) / b);
}
}
#line 127 "/root/patchweave_new/10/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_ceildivpow2(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 128
  return ((OPJ_INT32 )((((long )a + (OPJ_INT64 )(1 << b)) - 1L) >> b));
}
}
#line 134 "/root/patchweave_new/10/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_floordivpow2(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 135
  return (a >> b);
}
}
#line 141 "/root/patchweave_new/10/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_floorlog2(OPJ_INT32 a ) 
{ 
  OPJ_INT32 l ;

  {
#line 143
  l = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;

#line 143
    if (! (a > 1)) {
#line 143
      goto while_break;
    }
#line 144
    a >>= 1;
#line 143
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 146
  return (l);
}
}
#line 152 "/root/patchweave_new/10/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_floorlog2(OPJ_UINT32 a ) 
{ 
  OPJ_UINT32 l ;

  {
#line 154
  l = (OPJ_UINT32 )0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;

#line 154
    if (! (a > 1U)) {
#line 154
      goto while_break;
    }
#line 156
    a >>= 1;
#line 154
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 158
  return (l);
}
}
#line 167 "/root/patchweave_new/10/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_fix_mul(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT64 temp ;

  {
#line 168
  temp = (OPJ_INT64 )a * (OPJ_INT64 )b;
#line 169
  temp += 4096L;
#line 170
  return ((OPJ_INT32 )(temp >> 13));
}
}
#line 44 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_info_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                        void * ) ,
                              void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 48
  l_codec = (opj_codec_private_t *)p_codec;
#line 49
  if (! l_codec) {
#line 50
    return (0);
  }
#line 53
  l_codec->m_event_mgr.info_handler = p_callback;
#line 54
  l_codec->m_event_mgr.m_info_data = p_user_data;
#line 56
  return (1);
}
}
#line 59 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_warning_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                           void * ) ,
                                 void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 63
  l_codec = (opj_codec_private_t *)p_codec;
#line 64
  if (! l_codec) {
#line 65
    return (0);
  }
#line 68
  l_codec->m_event_mgr.warning_handler = p_callback;
#line 69
  l_codec->m_event_mgr.m_warning_data = p_user_data;
#line 71
  return (1);
}
}
#line 74 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_error_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                         void * ) ,
                               void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 78
  l_codec = (opj_codec_private_t *)p_codec;
#line 79
  if (! l_codec) {
#line 80
    return (0);
  }
#line 83
  l_codec->m_event_mgr.error_handler = p_callback;
#line 84
  l_codec->m_event_mgr.m_error_data = p_user_data;
#line 86
  return (1);
}
}
#line 91 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
static OPJ_SIZE_T opj_read_from_file(void *p_buffer , OPJ_SIZE_T p_nb_bytes , FILE *p_file ) 
{ 
  OPJ_SIZE_T l_nb_read ;
  unsigned long __cil_tmp5 ;
  OPJ_SIZE_T tmp ;

  {
  {
#line 93
  __cil_tmp5 = fread(p_buffer, 1UL, p_nb_bytes, p_file);
#line 93
  l_nb_read = __cil_tmp5;
  }
#line 94
  if (l_nb_read) {
#line 94
    tmp = l_nb_read;
  } else {
#line 94
    tmp = (OPJ_SIZE_T )-1;
  }
#line 94
  return (tmp);
}
}
#line 97 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
static OPJ_UINT64 opj_get_data_length_from_file(FILE *p_file ) 
{ 
  OPJ_OFF_T file_length ;
  __off_t __cil_tmp3 ;

  {
  {
#line 99
  file_length = (OPJ_OFF_T )0;
#line 101
  fseeko(p_file, (__off_t )0, 2);
#line 102
  __cil_tmp3 = ftello(p_file);
#line 102
  file_length = __cil_tmp3;
#line 103
  fseeko(p_file, (__off_t )0, 0);
  }
#line 105
  return ((OPJ_UINT64 )file_length);
}
}
#line 108 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
static OPJ_SIZE_T opj_write_from_file(void *p_buffer , OPJ_SIZE_T p_nb_bytes , FILE *p_file ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 110
  __cil_tmp4 = fwrite((void const   *)p_buffer, 1UL, p_nb_bytes, p_file);
  }
#line 110
  return (__cil_tmp4);
}
}
#line 113 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
static OPJ_OFF_T opj_skip_from_file(OPJ_OFF_T p_nb_bytes , FILE *p_user_data ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 115
  __cil_tmp3 = fseeko(p_user_data, p_nb_bytes, 1);
  }
#line 115
  if (__cil_tmp3) {
#line 116
    return ((OPJ_OFF_T )-1);
  }
#line 119
  return (p_nb_bytes);
}
}
#line 122 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
static OPJ_BOOL opj_seek_from_file(OPJ_OFF_T p_nb_bytes , FILE *p_user_data ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 124
  __cil_tmp3 = fseeko(p_user_data, p_nb_bytes, 0);
  }
#line 124
  if (__cil_tmp3) {
#line 125
    return (0);
  }
#line 128
  return (1);
}
}
#line 157 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
char const   *opj_version(void) 
{ 


  {
#line 158
  return ("2.1.0");
}
}
#line 164 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
opj_codec_t *opj_create_decompress(OPJ_CODEC_FORMAT p_format ) 
{ 
  opj_codec_private_t *l_codec ;
  void *__cil_tmp3 ;
  opj_j2k_t *tmp ;
  opj_jp2_t *tmp___0 ;

  {
  {
#line 166
  l_codec = (opj_codec_private_t *)0;
#line 168
  __cil_tmp3 = calloc(1UL, sizeof(opj_codec_private_t ));
#line 168
  l_codec = (opj_codec_private_t *)__cil_tmp3;
  }
#line 169
  if (! l_codec) {
#line 170
    return ((opj_codec_t *)0);
  }
#line 173
  l_codec->is_decompressor = 1;
#line 176
  if ((int )p_format == 0) {
#line 176
    goto case_0;
  }
#line 251
  if ((int )p_format == 2) {
#line 251
    goto case_2;
  }
#line 328
  goto switch_default;
  case_0: 
  {
#line 177
  l_codec->opj_dump_codec = (void (*)(void * , OPJ_INT32  , FILE * ))(& j2k_dump);
#line 179
  l_codec->opj_get_codec_info = (opj_codestream_info_v2_t *(*)(void * ))(& j2k_get_cstr_info);
#line 181
  l_codec->opj_get_codec_index = (opj_codestream_index_t *(*)(void * ))(& j2k_get_cstr_index);
#line 183
  l_codec->m_codec_data.m_decompression.opj_decode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                   opj_image_t * ,
                                                                   struct opj_event_mgr * ))(& opj_j2k_decode);
#line 188
  l_codec->m_codec_data.m_decompression.opj_end_decompress = (OPJ_BOOL (*)(void * ,
                                                                           struct opj_stream_private * ,
                                                                           struct opj_event_mgr * ))(& opj_j2k_end_decompress);
#line 193
  l_codec->m_codec_data.m_decompression.opj_read_header = (OPJ_BOOL (*)(struct opj_stream_private * ,
                                                                        void * , opj_image_t ** ,
                                                                        struct opj_event_mgr * ))(& opj_j2k_read_header);
#line 199
  l_codec->m_codec_data.m_decompression.opj_destroy = (void (*)(void * ))(& opj_j2k_destroy);
#line 202
  l_codec->m_codec_data.m_decompression.opj_setup_decoder = (void (*)(void * , opj_dparameters_t * ))(& opj_j2k_setup_decoder);
#line 205
  l_codec->m_codec_data.m_decompression.opj_read_tile_header = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_BOOL * ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_j2k_read_tile_header);
#line 216
  l_codec->m_codec_data.m_decompression.opj_decode_tile_data = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32  ,
                                                                             OPJ_BYTE * ,
                                                                             OPJ_UINT32  ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_j2k_decode_tile);
#line 224
  l_codec->m_codec_data.m_decompression.opj_set_decode_area = (OPJ_BOOL (*)(void * ,
                                                                            opj_image_t * ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            struct opj_event_mgr * ))(& opj_j2k_set_decode_area);
#line 230
  l_codec->m_codec_data.m_decompression.opj_get_decoded_tile = (OPJ_BOOL (*)(void * ,
                                                                             opj_stream_private_t * ,
                                                                             opj_image_t * ,
                                                                             struct opj_event_mgr * ,
                                                                             OPJ_UINT32  ))(& opj_j2k_get_tile);
#line 237
  l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor = (OPJ_BOOL (*)(void * ,
                                                                                          OPJ_UINT32  ,
                                                                                          struct opj_event_mgr * ))(& opj_j2k_set_decoded_resolution_factor);
#line 242
  tmp = opj_j2k_create_decompress();
#line 242
  l_codec->m_codec = (void *)tmp;
  }
#line 244
  if (! l_codec->m_codec) {
    {
#line 245
    free((void *)l_codec);
    }
#line 246
    return ((opj_codec_t *)((void *)0));
  }
#line 249
  goto switch_break;
  case_2: 
  {
#line 253
  l_codec->opj_dump_codec = (void (*)(void * , OPJ_INT32  , FILE * ))(& jp2_dump);
#line 255
  l_codec->opj_get_codec_info = (opj_codestream_info_v2_t *(*)(void * ))(& jp2_get_cstr_info);
#line 257
  l_codec->opj_get_codec_index = (opj_codestream_index_t *(*)(void * ))(& jp2_get_cstr_index);
#line 259
  l_codec->m_codec_data.m_decompression.opj_decode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                   opj_image_t * ,
                                                                   struct opj_event_mgr * ))(& opj_jp2_decode);
#line 265
  l_codec->m_codec_data.m_decompression.opj_end_decompress = (OPJ_BOOL (*)(void * ,
                                                                           struct opj_stream_private * ,
                                                                           struct opj_event_mgr * ))(& opj_jp2_end_decompress);
#line 270
  l_codec->m_codec_data.m_decompression.opj_read_header = (OPJ_BOOL (*)(struct opj_stream_private * ,
                                                                        void * , opj_image_t ** ,
                                                                        struct opj_event_mgr * ))(& opj_jp2_read_header);
#line 276
  l_codec->m_codec_data.m_decompression.opj_read_tile_header = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_BOOL * ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_jp2_read_tile_header);
#line 289
  l_codec->m_codec_data.m_decompression.opj_decode_tile_data = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32  ,
                                                                             OPJ_BYTE * ,
                                                                             OPJ_UINT32  ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_jp2_decode_tile);
#line 295
  l_codec->m_codec_data.m_decompression.opj_destroy = (void (*)(void * ))(& opj_jp2_destroy);
#line 297
  l_codec->m_codec_data.m_decompression.opj_setup_decoder = (void (*)(void * , opj_dparameters_t * ))(& opj_jp2_setup_decoder);
#line 300
  l_codec->m_codec_data.m_decompression.opj_set_decode_area = (OPJ_BOOL (*)(void * ,
                                                                            opj_image_t * ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            struct opj_event_mgr * ))(& opj_jp2_set_decode_area);
#line 306
  l_codec->m_codec_data.m_decompression.opj_get_decoded_tile = (OPJ_BOOL (*)(void * ,
                                                                             opj_stream_private_t * ,
                                                                             opj_image_t * ,
                                                                             struct opj_event_mgr * ,
                                                                             OPJ_UINT32  ))(& opj_jp2_get_tile);
#line 313
  l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor = (OPJ_BOOL (*)(void * ,
                                                                                          OPJ_UINT32  ,
                                                                                          opj_event_mgr_t * ))(& opj_jp2_set_decoded_resolution_factor);
#line 318
  tmp___0 = opj_jp2_create(1);
#line 318
  l_codec->m_codec = (void *)tmp___0;
  }
#line 320
  if (! l_codec->m_codec) {
    {
#line 321
    free((void *)l_codec);
    }
#line 322
    return ((opj_codec_t *)0);
  }
#line 325
  goto switch_break;
  switch_default: 
  {
#line 329
  free((void *)l_codec);
  }
#line 330
  return ((opj_codec_t *)0);
  switch_break: 
  {
#line 333
  opj_set_default_event_handler(& l_codec->m_event_mgr);
  }
#line 334
  return ((opj_codec_t *)l_codec);
}
}
#line 337 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) 
{ 


  {
#line 338
  if (parameters) {
    {
#line 339
    memset((void *)parameters, 0, sizeof(opj_dparameters_t ));
#line 341
    parameters->cp_layer = (OPJ_UINT32 )0;
#line 342
    parameters->cp_reduce = (OPJ_UINT32 )0;
#line 344
    parameters->decod_format = -1;
#line 345
    parameters->cod_format = -1;
#line 346
    parameters->flags = 0U;
    }
  }
#line 349
  return;
}
}
#line 357 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_setup_decoder(opj_codec_t *p_codec , opj_dparameters_t *parameters ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 361
  if (p_codec) {
#line 361
    if (parameters) {
#line 362
      l_codec = (opj_codec_private_t *)p_codec;
#line 364
      if (! l_codec->is_decompressor) {
        {
#line 365
        opj_event_msg(& l_codec->m_event_mgr, 1, "Codec provided to the opj_setup_decoder function is not a decompressor handler.\n\240\\\263iEV");
        }
#line 367
        return (0);
      }
      {
#line 370
      (*(l_codec->m_codec_data.m_decompression.opj_setup_decoder))(l_codec->m_codec,
                                                                   parameters);
      }
#line 372
      return (1);
    }
  }
#line 374
  return (0);
}
}
#line 377 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_read_header(opj_stream_t *p_stream , opj_codec_t *p_codec , opj_image_t **p_image ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 381
  if (p_codec) {
#line 381
    if (p_stream) {
#line 382
      l_codec = (opj_codec_private_t *)p_codec;
#line 383
      l_stream = (opj_stream_private_t *)p_stream;
#line 385
      if (! l_codec->is_decompressor) {
        {
#line 386
        opj_event_msg(& l_codec->m_event_mgr, 1, "Codec provided to the opj_read_header function is not a decompressor handler.\n");
        }
#line 388
        return (0);
      }
      {
#line 391
      __cil_tmp6 = (*(l_codec->m_codec_data.m_decompression.opj_read_header))(l_stream,
                                                                              l_codec->m_codec,
                                                                              p_image,
                                                                              & l_codec->m_event_mgr);
      }
#line 391
      return (__cil_tmp6);
    }
  }
#line 397
  return (0);
}
}
#line 400 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_decode(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 404
  if (p_codec) {
#line 404
    if (p_stream) {
#line 405
      l_codec = (opj_codec_private_t *)p_codec;
#line 406
      l_stream = (opj_stream_private_t *)p_stream;
#line 408
      if (! l_codec->is_decompressor) {
#line 409
        return (0);
      }
      {
#line 412
      __cil_tmp6 = (*(l_codec->m_codec_data.m_decompression.opj_decode))(l_codec->m_codec,
                                                                         l_stream,
                                                                         p_image,
                                                                         & l_codec->m_event_mgr);
      }
#line 412
      return (__cil_tmp6);
    }
  }
#line 418
  return (0);
}
}
#line 421 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_decode_area(opj_codec_t *p_codec , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                             OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ) 
{ 
  opj_codec_private_t *l_codec ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 427
  if (p_codec) {
#line 428
    l_codec = (opj_codec_private_t *)p_codec;
#line 430
    if (! l_codec->is_decompressor) {
#line 431
      return (0);
    }
    {
#line 434
    __cil_tmp8 = (*(l_codec->m_codec_data.m_decompression.opj_set_decode_area))(l_codec->m_codec,
                                                                                p_image,
                                                                                p_start_x,
                                                                                p_start_y,
                                                                                p_end_x,
                                                                                p_end_y,
                                                                                & l_codec->m_event_mgr);
    }
#line 434
    return (__cil_tmp8);
  }
#line 440
  return (0);
}
}
#line 443 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_read_tile_header(opj_codec_t *p_codec , opj_stream_t *p_stream , OPJ_UINT32 *p_tile_index ,
                              OPJ_UINT32 *p_data_size , OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 ,
                              OPJ_INT32 *p_tile_x1 , OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                              OPJ_BOOL *p_should_go_on ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp13 ;

  {
#line 452
  if (p_codec) {
#line 452
    if (p_stream) {
#line 452
      if (p_data_size) {
#line 452
        if (p_tile_index) {
#line 453
          l_codec = (opj_codec_private_t *)p_codec;
#line 454
          l_stream = (opj_stream_private_t *)p_stream;
#line 456
          if (! l_codec->is_decompressor) {
#line 457
            return (0);
          }
          {
#line 460
          __cil_tmp13 = (*(l_codec->m_codec_data.m_decompression.opj_read_tile_header))(l_codec->m_codec,
                                                                                        p_tile_index,
                                                                                        p_data_size,
                                                                                        p_tile_x0,
                                                                                        p_tile_y0,
                                                                                        p_tile_x1,
                                                                                        p_tile_y1,
                                                                                        p_nb_comps,
                                                                                        p_should_go_on,
                                                                                        l_stream,
                                                                                        & l_codec->m_event_mgr);
          }
#line 460
          return (__cil_tmp13);
        }
      }
    }
  }
#line 470
  return (0);
}
}
#line 473 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_decode_tile_data(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                              OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 480
  if (p_codec) {
#line 480
    if (p_data) {
#line 480
      if (p_stream) {
#line 481
        l_codec = (opj_codec_private_t *)p_codec;
#line 482
        l_stream = (opj_stream_private_t *)p_stream;
#line 484
        if (! l_codec->is_decompressor) {
#line 485
          return (0);
        }
        {
#line 488
        __cil_tmp8 = (*(l_codec->m_codec_data.m_decompression.opj_decode_tile_data))(l_codec->m_codec,
                                                                                     p_tile_index,
                                                                                     p_data,
                                                                                     p_data_size,
                                                                                     l_stream,
                                                                                     & l_codec->m_event_mgr);
        }
#line 488
        return (__cil_tmp8);
      }
    }
  }
#line 495
  return (0);
}
}
#line 498 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_get_decoded_tile(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ,
                              OPJ_UINT32 tile_index ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 503
  if (p_codec) {
#line 503
    if (p_stream) {
#line 504
      l_codec = (opj_codec_private_t *)p_codec;
#line 505
      l_stream = (opj_stream_private_t *)p_stream;
#line 507
      if (! l_codec->is_decompressor) {
#line 508
        return (0);
      }
      {
#line 511
      __cil_tmp7 = (*(l_codec->m_codec_data.m_decompression.opj_get_decoded_tile))(l_codec->m_codec,
                                                                                   l_stream,
                                                                                   p_image,
                                                                                   & l_codec->m_event_mgr,
                                                                                   tile_index);
      }
#line 511
      return (__cil_tmp7);
    }
  }
#line 518
  return (0);
}
}
#line 521 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_decoded_resolution_factor(opj_codec_t *p_codec , OPJ_UINT32 res_factor ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 524
  l_codec = (opj_codec_private_t *)p_codec;
#line 526
  if (! l_codec) {
    {
#line 527
    fprintf(stderr, "[ERROR] Input parameters of the setup_decoder function are incorrect.\n");
    }
#line 528
    return (0);
  }
  {
#line 531
  (*(l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor))(l_codec->m_codec,
                                                                               res_factor,
                                                                               & l_codec->m_event_mgr);
  }
#line 534
  return (1);
}
}
#line 540 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
opj_codec_t *opj_create_compress(OPJ_CODEC_FORMAT p_format ) 
{ 
  opj_codec_private_t *l_codec ;
  void *__cil_tmp3 ;
  opj_j2k_t *tmp ;
  opj_jp2_t *tmp___0 ;

  {
  {
#line 542
  l_codec = (opj_codec_private_t *)0;
#line 544
  __cil_tmp3 = calloc(1UL, sizeof(opj_codec_private_t ));
#line 544
  l_codec = (opj_codec_private_t *)__cil_tmp3;
  }
#line 545
  if (! l_codec) {
#line 546
    return ((opj_codec_t *)0);
  }
#line 549
  l_codec->is_decompressor = 0;
#line 552
  if ((int )p_format == 0) {
#line 552
    goto case_0;
  }
#line 588
  if ((int )p_format == 2) {
#line 588
    goto case_2;
  }
#line 627
  goto switch_default;
  case_0: 
  {
#line 553
  l_codec->m_codec_data.m_compression.opj_encode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                 struct opj_event_mgr * ))(& opj_j2k_encode);
#line 557
  l_codec->m_codec_data.m_compression.opj_end_compress = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                       struct opj_event_mgr * ))(& opj_j2k_end_compress);
#line 561
  l_codec->m_codec_data.m_compression.opj_start_compress = (OPJ_BOOL (*)(void * ,
                                                                         struct opj_stream_private * ,
                                                                         struct opj_image * ,
                                                                         struct opj_event_mgr * ))(& opj_j2k_start_compress);
#line 566
  l_codec->m_codec_data.m_compression.opj_write_tile = (OPJ_BOOL (*)(void * , OPJ_UINT32  ,
                                                                     OPJ_BYTE * ,
                                                                     OPJ_UINT32  ,
                                                                     struct opj_stream_private * ,
                                                                     struct opj_event_mgr * ))(& opj_j2k_write_tile);
#line 573
  l_codec->m_codec_data.m_compression.opj_destroy = (void (*)(void * ))(& opj_j2k_destroy);
#line 575
  l_codec->m_codec_data.m_compression.opj_setup_encoder = (OPJ_BOOL (*)(void * , opj_cparameters_t * ,
                                                                        struct opj_image * ,
                                                                        struct opj_event_mgr * ))(& opj_j2k_setup_encoder);
#line 580
  tmp = opj_j2k_create_compress();
#line 580
  l_codec->m_codec = (void *)tmp;
  }
#line 581
  if (! l_codec->m_codec) {
    {
#line 582
    free((void *)l_codec);
    }
#line 583
    return ((opj_codec_t *)0);
  }
#line 586
  goto switch_break;
  case_2: 
  {
#line 590
  l_codec->m_codec_data.m_compression.opj_encode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                 struct opj_event_mgr * ))(& opj_jp2_encode);
#line 594
  l_codec->m_codec_data.m_compression.opj_end_compress = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                       struct opj_event_mgr * ))(& opj_jp2_end_compress);
#line 598
  l_codec->m_codec_data.m_compression.opj_start_compress = (OPJ_BOOL (*)(void * ,
                                                                         struct opj_stream_private * ,
                                                                         struct opj_image * ,
                                                                         struct opj_event_mgr * ))(& opj_jp2_start_compress);
#line 603
  l_codec->m_codec_data.m_compression.opj_write_tile = (OPJ_BOOL (*)(void * , OPJ_UINT32  ,
                                                                     OPJ_BYTE * ,
                                                                     OPJ_UINT32  ,
                                                                     struct opj_stream_private * ,
                                                                     struct opj_event_mgr * ))(& opj_jp2_write_tile);
#line 610
  l_codec->m_codec_data.m_compression.opj_destroy = (void (*)(void * ))(& opj_jp2_destroy);
#line 612
  l_codec->m_codec_data.m_compression.opj_setup_encoder = (OPJ_BOOL (*)(void * , opj_cparameters_t * ,
                                                                        struct opj_image * ,
                                                                        struct opj_event_mgr * ))(& opj_jp2_setup_encoder);
#line 617
  tmp___0 = opj_jp2_create(0);
#line 617
  l_codec->m_codec = (void *)tmp___0;
  }
#line 618
  if (! l_codec->m_codec) {
    {
#line 619
    free((void *)l_codec);
    }
#line 620
    return ((opj_codec_t *)0);
  }
#line 623
  goto switch_break;
  switch_default: 
  {
#line 628
  free((void *)l_codec);
  }
#line 629
  return ((opj_codec_t *)0);
  switch_break: 
  {
#line 632
  opj_set_default_event_handler(& l_codec->m_event_mgr);
  }
#line 633
  return ((opj_codec_t *)l_codec);
}
}
#line 636 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) 
{ 


  {
#line 637
  if (parameters) {
    {
#line 638
    memset((void *)parameters, 0, sizeof(opj_cparameters_t ));
#line 640
    parameters->cp_cinema = (OPJ_CINEMA_MODE )0;
#line 641
    parameters->rsiz = (OPJ_UINT16 )0;
#line 642
    parameters->max_comp_size = 0;
#line 643
    parameters->numresolution = 6;
#line 644
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
#line 645
    parameters->cblockw_init = 64;
#line 646
    parameters->cblockh_init = 64;
#line 647
    parameters->prog_order = (OPJ_PROG_ORDER )0;
#line 648
    parameters->roi_compno = -1;
#line 649
    parameters->subsampling_dx = 1;
#line 650
    parameters->subsampling_dy = 1;
#line 651
    parameters->tp_on = (char)0;
#line 652
    parameters->decod_format = -1;
#line 653
    parameters->cod_format = -1;
#line 654
    parameters->tcp_rates[0] = (float )0;
#line 655
    parameters->tcp_numlayers = 0;
#line 656
    parameters->cp_disto_alloc = 0;
#line 657
    parameters->cp_fixed_alloc = 0;
#line 658
    parameters->cp_fixed_quality = 0;
#line 659
    parameters->jpip_on = 0;
    }
  }
#line 662
  return;
}
}
#line 695 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_setup_encoder(opj_codec_t *p_codec , opj_cparameters_t *parameters ,
                           opj_image_t *p_image ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 699
  if (p_codec) {
#line 699
    if (parameters) {
#line 699
      if (p_image) {
#line 700
        l_codec = (opj_codec_private_t *)p_codec;
#line 702
        if (! l_codec->is_decompressor) {
          {
#line 703
          (*(l_codec->m_codec_data.m_compression.opj_setup_encoder))(l_codec->m_codec,
                                                                     parameters, p_image,
                                                                     & l_codec->m_event_mgr);
          }
#line 707
          return (1);
        }
      }
    }
  }
#line 711
  return (0);
}
}
#line 714 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_start_compress(opj_codec_t *p_codec , opj_image_t *p_image , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 718
  if (p_codec) {
#line 718
    if (p_stream) {
#line 719
      l_codec = (opj_codec_private_t *)p_codec;
#line 720
      l_stream = (opj_stream_private_t *)p_stream;
#line 722
      if (! l_codec->is_decompressor) {
        {
#line 723
        __cil_tmp6 = (*(l_codec->m_codec_data.m_compression.opj_start_compress))(l_codec->m_codec,
                                                                                 l_stream,
                                                                                 p_image,
                                                                                 & l_codec->m_event_mgr);
        }
#line 723
        return (__cil_tmp6);
      }
    }
  }
#line 730
  return (0);
}
}
#line 733 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_encode(opj_codec_t *p_info , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 735
  if (p_info) {
#line 735
    if (p_stream) {
#line 736
      l_codec = (opj_codec_private_t *)p_info;
#line 737
      l_stream = (opj_stream_private_t *)p_stream;
#line 739
      if (! l_codec->is_decompressor) {
        {
#line 740
        __cil_tmp5 = (*(l_codec->m_codec_data.m_compression.opj_encode))(l_codec->m_codec,
                                                                         l_stream,
                                                                         & l_codec->m_event_mgr);
        }
#line 740
        return (__cil_tmp5);
      }
    }
  }
#line 746
  return (0);
}
}
#line 750 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_end_compress(opj_codec_t *p_codec , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 753
  if (p_codec) {
#line 753
    if (p_stream) {
#line 754
      l_codec = (opj_codec_private_t *)p_codec;
#line 755
      l_stream = (opj_stream_private_t *)p_stream;
#line 757
      if (! l_codec->is_decompressor) {
        {
#line 758
        __cil_tmp5 = (*(l_codec->m_codec_data.m_compression.opj_end_compress))(l_codec->m_codec,
                                                                               l_stream,
                                                                               & l_codec->m_event_mgr);
        }
#line 758
        return (__cil_tmp5);
      }
    }
  }
#line 763
  return (0);
}
}
#line 767 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_end_decompress(opj_codec_t *p_codec , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 770
  if (p_codec) {
#line 770
    if (p_stream) {
#line 771
      l_codec = (opj_codec_private_t *)p_codec;
#line 772
      l_stream = (opj_stream_private_t *)p_stream;
#line 774
      if (! l_codec->is_decompressor) {
#line 775
        return (0);
      }
      {
#line 778
      __cil_tmp5 = (*(l_codec->m_codec_data.m_decompression.opj_end_decompress))(l_codec->m_codec,
                                                                                 l_stream,
                                                                                 & l_codec->m_event_mgr);
      }
#line 778
      return (__cil_tmp5);
    }
  }
#line 783
  return (0);
}
}
#line 786 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_MCT(opj_cparameters_t *parameters , OPJ_FLOAT32 *pEncodingMatrix ,
                     OPJ_INT32 *p_dc_shift , OPJ_UINT32 pNbComp ) 
{ 
  OPJ_UINT32 l_matrix_size ;
  OPJ_UINT32 l_dc_shift_size ;
  OPJ_UINT32 l_mct_total_size ;

  {
#line 790
  l_matrix_size = (pNbComp * pNbComp) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 791
  l_dc_shift_size = pNbComp * (OPJ_UINT32 )sizeof(OPJ_INT32 );
#line 792
  l_mct_total_size = l_matrix_size + l_dc_shift_size;
#line 795
  if ((int )parameters->rsiz & 32768) {
#line 796
    parameters->rsiz = (OPJ_UINT16 )((int )parameters->rsiz | 256);
  } else {
#line 798
    parameters->rsiz = (OPJ_UINT16 )33024;
  }
  {
#line 800
  parameters->irreversible = 1;
#line 803
  parameters->tcp_mct = (char)2;
#line 804
  parameters->mct_data = malloc((unsigned long )l_mct_total_size);
  }
#line 805
  if (! parameters->mct_data) {
#line 806
    return (0);
  }
  {
#line 809
  memcpy(parameters->mct_data, (void const   *)pEncodingMatrix, (unsigned long )l_matrix_size);
#line 810
  memcpy((void *)((OPJ_BYTE *)parameters->mct_data + l_matrix_size), (void const   *)p_dc_shift,
         (unsigned long )l_dc_shift_size);
  }
#line 812
  return (1);
}
}
#line 815 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_write_tile(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                        OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 821
  if (p_codec) {
#line 821
    if (p_stream) {
#line 821
      if (p_data) {
#line 822
        l_codec = (opj_codec_private_t *)p_codec;
#line 823
        l_stream = (opj_stream_private_t *)p_stream;
#line 825
        if (l_codec->is_decompressor) {
#line 826
          return (0);
        }
        {
#line 829
        __cil_tmp8 = (*(l_codec->m_codec_data.m_compression.opj_write_tile))(l_codec->m_codec,
                                                                             p_tile_index,
                                                                             p_data,
                                                                             p_data_size,
                                                                             l_stream,
                                                                             & l_codec->m_event_mgr);
        }
#line 829
        return (__cil_tmp8);
      }
    }
  }
#line 837
  return (0);
}
}
#line 842 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
void opj_destroy_codec(opj_codec_t *p_codec ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 844
  if (p_codec) {
#line 845
    l_codec = (opj_codec_private_t *)p_codec;
#line 847
    if (l_codec->is_decompressor) {
      {
#line 848
      (*(l_codec->m_codec_data.m_decompression.opj_destroy))(l_codec->m_codec);
      }
    } else {
      {
#line 851
      (*(l_codec->m_codec_data.m_compression.opj_destroy))(l_codec->m_codec);
      }
    }
    {
#line 854
    l_codec->m_codec = (void *)0;
#line 855
    free((void *)l_codec);
    }
  }
#line 858
  return;
}
}
#line 861 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
void opj_dump_codec(opj_codec_t *p_codec , OPJ_INT32 info_flag , FILE *output_stream ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 865
  if (p_codec) {
    {
#line 866
    l_codec = (opj_codec_private_t *)p_codec;
#line 868
    (*(l_codec->opj_dump_codec))(l_codec->m_codec, info_flag, output_stream);
    }
#line 869
    return;
  }
  {
#line 872
  fprintf(stderr, "[ERROR] Input parameter of the dump_codec function are incorrect.\n\264iEV");
  }
#line 873
  return;
}
}
#line 876 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
opj_codestream_info_v2_t *opj_get_cstr_info(opj_codec_t *p_codec ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_codestream_info_v2_t *__cil_tmp3 ;

  {
#line 878
  if (p_codec) {
    {
#line 879
    l_codec = (opj_codec_private_t *)p_codec;
#line 881
    __cil_tmp3 = (*(l_codec->opj_get_codec_info))(l_codec->m_codec);
    }
#line 881
    return (__cil_tmp3);
  }
#line 884
  return ((opj_codestream_info_v2_t *)((void *)0));
}
}
#line 887 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
void opj_destroy_cstr_info(opj_codestream_info_v2_t **cstr_info ) 
{ 


  {
#line 888
  if (cstr_info) {
#line 890
    if ((*cstr_info)->m_default_tile_info.tccp_info) {
      {
#line 891
      free((void *)(*cstr_info)->m_default_tile_info.tccp_info);
      }
    }
    {
#line 898
    free((void *)*cstr_info);
#line 899
    *cstr_info = (opj_codestream_info_v2_t *)((void *)0);
    }
  }
#line 902
  return;
}
}
#line 903 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
opj_codestream_index_t *opj_get_cstr_index(opj_codec_t *p_codec ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_codestream_index_t *__cil_tmp3 ;

  {
#line 905
  if (p_codec) {
    {
#line 906
    l_codec = (opj_codec_private_t *)p_codec;
#line 908
    __cil_tmp3 = (*(l_codec->opj_get_codec_index))(l_codec->m_codec);
    }
#line 908
    return (__cil_tmp3);
  }
#line 911
  return ((opj_codestream_index_t *)((void *)0));
}
}
#line 914 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
void opj_destroy_cstr_index(opj_codestream_index_t **p_cstr_index ) 
{ 


  {
#line 916
  if (*p_cstr_index) {
    {
#line 917
    j2k_destroy_cstr_index(*p_cstr_index);
#line 918
    *p_cstr_index = (opj_codestream_index_t *)((void *)0);
    }
  }
#line 921
  return;
}
}
#line 922 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
opj_stream_t *opj_stream_create_default_file_stream(char const   *fname , OPJ_BOOL p_is_read_stream ) 
{ 
  opj_stream_t *__cil_tmp3 ;

  {
  {
#line 924
  __cil_tmp3 = opj_stream_create_file_stream(fname, (OPJ_SIZE_T )1048576, p_is_read_stream);
  }
#line 924
  return (__cil_tmp3);
}
}
#line 927 "/root/patchweave_new/10/src/lib/openjp2/openjpeg.c"
opj_stream_t *opj_stream_create_file_stream(char const   *fname , OPJ_SIZE_T p_size ,
                                            OPJ_BOOL p_is_read_stream ) 
{ 
  opj_stream_t *l_stream ;
  FILE *p_file ;
  char const   *mode ;
  OPJ_UINT64 __cil_tmp9 ;

  {
#line 932
  l_stream = (opj_stream_t *)0;
#line 936
  if (! fname) {
#line 937
    return ((opj_stream_t *)((void *)0));
  }
#line 940
  if (p_is_read_stream) {
    {
#line 940
    strcpy((char *)mode, "rb");
    }
  } else {
    {
#line 940
    strcpy((char *)mode, "wb");
    }
  }
  {
#line 942
  p_file = fopen(fname, mode);
  }
#line 944
  if (! p_file) {
#line 945
    return ((opj_stream_t *)((void *)0));
  }
  {
#line 948
  l_stream = opj_stream_create(p_size, p_is_read_stream);
  }
#line 949
  if (! l_stream) {
    {
#line 950
    fclose(p_file);
    }
#line 951
    return ((opj_stream_t *)((void *)0));
  }
  {
#line 954
  opj_stream_set_user_data(l_stream, (void *)p_file, (void (*)(void * ))(& fclose));
#line 955
  __cil_tmp9 = opj_get_data_length_from_file(p_file);
#line 955
  opj_stream_set_user_data_length(l_stream, __cil_tmp9);
#line 956
  opj_stream_set_read_function(l_stream, (OPJ_SIZE_T (*)(void * , OPJ_SIZE_T  , void * ))(& opj_read_from_file));
#line 957
  opj_stream_set_write_function(l_stream, (OPJ_SIZE_T (*)(void * , OPJ_SIZE_T  , void * ))(& opj_write_from_file));
#line 958
  opj_stream_set_skip_function(l_stream, (OPJ_OFF_T (*)(OPJ_OFF_T  , void * ))(& opj_skip_from_file));
#line 959
  opj_stream_set_seek_function(l_stream, (OPJ_BOOL (*)(OPJ_OFF_T  , void * ))(& opj_seek_from_file));
  }
#line 961
  return (l_stream);
}
}
#line 54 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_setup_header_reading(opj_j2k_t *p_j2k ) ;
#line 59
OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                       opj_event_mgr_t *p_manager ) ;
#line 72
OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) ;
#line 85
OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) ;
#line 93
void opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k ) ;
#line 99
void opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k ) ;
#line 105
void opj_j2k_setup_end_compress(opj_j2k_t *p_j2k ) ;
#line 116
OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) ;
#line 123
OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                               opj_event_mgr_t *p_manager ) ;
#line 129
OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                               opj_event_mgr_t *p_manager ) ;
#line 140
static OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                   opj_event_mgr_t *p_manager ) ;
#line 154
OPJ_BOOL opj_j2k_exec(opj_j2k_t *p_j2k , opj_procedure_list_t *p_procedure_list ,
                      opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 166
OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) ;
#line 174
static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                                        opj_event_mgr_t *p_manager ) ;
#line 181
static OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) ;
#line 192
struct opj_dec_memory_marker_handler *opj_j2k_get_marker_handler(OPJ_UINT32 p_id ) ;
#line 199
void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp ) ;
#line 206
void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp ) ;
#line 213
void opj_j2k_cp_destroy(opj_cp_t *p_cp ) ;
#line 227
OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                   OPJ_BYTE *p_data , OPJ_UINT32 *p_header_size ,
                                   struct opj_event_mgr *p_manager ) ;
#line 243
OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                        OPJ_UINT32 p_comp_no ) ;
#line 255
OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 compno , OPJ_BYTE *p_header_data ,
                                  OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) ;
#line 270
OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ) ;
#line 285
OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                 OPJ_BYTE *p_data , OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) ;
#line 295
void opj_j2k_update_tlm(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_part_size ) ;
#line 307
OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_header_data ,
                                OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) ;
#line 318
void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k ) ;
#line 325
void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k ) ;
#line 330
OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) ;
#line 334
OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) ;
#line 339
OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data , opj_image_t *p_output_image ) ;
#line 341
void opj_get_tile_dimensions(opj_image_t *l_image , opj_tcd_tilecomp_t *l_tilec ,
                             opj_image_comp_t *l_img_comp , OPJ_UINT32 *l_size_comp ,
                             OPJ_UINT32 *l_width , OPJ_UINT32 *l_height , OPJ_UINT32 *l_offset_x ,
                             OPJ_UINT32 *l_offset_y , OPJ_UINT32 *l_image_width ,
                             OPJ_UINT32 *l_stride , OPJ_UINT32 *l_tile_offset ) ;
#line 353
void opj_j2k_get_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data ) ;
#line 355
OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) ;
#line 363
void opj_j2k_setup_header_writing(opj_j2k_t *p_j2k ) ;
#line 365
OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                       OPJ_UINT32 p_total_data_size , opj_stream_private_t *p_stream ,
                                       struct opj_event_mgr *p_manager ) ;
#line 372
OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                      OPJ_UINT32 p_total_data_size , opj_stream_private_t *p_stream ,
                                      struct opj_event_mgr *p_manager ) ;
#line 386
OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                struct opj_event_mgr *p_manager ) ;
#line 390
OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k ) ;
#line 405
OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 415
static OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) ;
#line 426
OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 437
static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 449
OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 460
static OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 471
OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 482
static OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 524
OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k ) ;
#line 533
static OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 545
OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 556
static OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 595
OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k ) ;
#line 604
static OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 615
OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 626
void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                 opj_event_mgr_t *p_manager ) ;
#line 633
OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k ) ;
#line 643
static OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 651
OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k ) ;
#line 658
OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k ) ;
#line 668
static OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 680
static OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 692
OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                   struct opj_event_mgr *p_manager ) ;
#line 704
static OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 716
static OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 738
OPJ_BOOL j2k_read_ppm_v3(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                         struct opj_event_mgr *p_manager ) ;
#line 752
static OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 763
OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 776
OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                           opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 790
OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                          opj_event_mgr_t *p_manager ) ;
#line 805
OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k , opj_tcd_t *p_tile_coder , OPJ_BYTE *p_data ,
                           OPJ_UINT32 *p_data_written , OPJ_UINT32 p_total_data_size ,
                           opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 820
OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 824 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_update_tlm(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_part_size ) 
{ 


  {
  {
#line 826
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                     p_j2k->m_current_tile_number, (OPJ_UINT32 )1);
#line 827
  (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current) ++;
#line 829
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                     p_tile_part_size, (OPJ_UINT32 )4);
#line 830
  p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current += 4;
  }
#line 832
  return;
}
}
#line 843
OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                           OPJ_UINT32 nb_comps , opj_stream_private_t *p_stream ,
                           opj_event_mgr_t *p_manager ) ;
#line 858
static OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 870
OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 894
OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) ;
#line 905
OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) ;
#line 916
static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index , OPJ_UINT32 type ,
                                     OPJ_OFF_T pos , OPJ_UINT32 len ) ;
#line 925
static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno , opj_codestream_index_t *cstr_index ,
                                     OPJ_UINT32 type , OPJ_OFF_T pos , OPJ_UINT32 len ) ;
#line 937
OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , OPJ_UINT32 *output_marker ,
                          opj_event_mgr_t *p_manager ) ;
#line 950
OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k , opj_mct_data_t *p_mct_record ,
                                  struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) ;
#line 963
static OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 976
OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k , struct opj_simple_mcc_decorrelation_data *p_mcc_record ,
                                  struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) ;
#line 989
OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                          opj_event_mgr_t *p_manager ) ;
#line 1001
OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) ;
#line 1013
static OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1018
OPJ_BOOL opj_j2k_add_mct(opj_tcp_t *p_tcp , opj_image_t *p_image , OPJ_UINT32 p_index ) ;
#line 1020
void opj_j2k_read_int16_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1021
void opj_j2k_read_int32_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1022
void opj_j2k_read_float32_to_float(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) ;
#line 1023
void opj_j2k_read_float64_to_float(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) ;
#line 1025
void opj_j2k_read_int16_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1026
void opj_j2k_read_int32_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1027
void opj_j2k_read_float32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) ;
#line 1028
void opj_j2k_read_float64_to_int32(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) ;
#line 1030
void opj_j2k_write_float_to_int16(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1031
void opj_j2k_write_float_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1032
void opj_j2k_write_float_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1033
void opj_j2k_write_float_to_float64(void const   *p_src_data , void *p_dest_data ,
                                    OPJ_UINT32 p_nb_elem ) ;
#line 1042
OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                              struct opj_event_mgr *p_manager ) ;
#line 1053
OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) ;
#line 1064
static OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1102
OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                               struct opj_event_mgr *p_manager ) ;
#line 1113
OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) ;
#line 1130
OPJ_BOOL opj_j2k_check_poc_val(opj_poc_t *p_pocs , OPJ_UINT32 p_nb_pocs , OPJ_UINT32 p_nb_resolutions ,
                               OPJ_UINT32 p_num_comps , OPJ_UINT32 p_num_layers ,
                               opj_event_mgr_t *p_manager ) ;
#line 1146
OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp , OPJ_UINT32 pino , OPJ_UINT32 tileno ) ;
#line 1160
OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k , opj_cp_t *cp , OPJ_UINT32 *p_nb_tiles ,
                              opj_image_t *image , opj_event_mgr_t *p_manager ) ;
#line 1166
void opj_j2k_dump_MH_info(opj_j2k_t *p_j2k , FILE *out_stream ) ;
#line 1168
void opj_j2k_dump_MH_index(opj_j2k_t *p_j2k , FILE *out_stream ) ;
#line 1170
opj_codestream_index_t *opj_j2k_create_cstr_index(void) ;
#line 1172
OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t *p_tcp ) ;
#line 1174
OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t *p_tcp ) ;
#line 1176
int opj_j2k_initialise_4K_poc(opj_poc_t *POC , int numres ) ;
#line 1178
void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                   opj_event_mgr_t *p_manager ) ;
#line 1180
OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image , OPJ_UINT16 rsiz , opj_event_mgr_t *p_manager ) ;
#line 1192 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
j2k_prog_order_t j2k_prog_order_list[6]  = {      {(OPJ_PROG_ORDER )4, {(char )"CPRL", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )0, {(char )"LRCP", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )3, {(char )"PCRL", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )1, {(char )"RLCP", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )2, {(char )"RPCL", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )-1, {(char )"\250", (char)0, (char)0, (char)0, (char)0}}};
#line 1204 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_UINT32 MCT_ELEMENT_SIZE[4]  = {      (OPJ_UINT32 )2,      (OPJ_UINT32 )4,      (OPJ_UINT32 )4,      (OPJ_UINT32 )8};
#line 1214 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
opj_j2k_mct_function j2k_mct_read_functions_to_float[4]  = {      & opj_j2k_read_int16_to_float,      & opj_j2k_read_int32_to_float,      & opj_j2k_read_float32_to_float,      & opj_j2k_read_float64_to_float};
#line 1222 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
opj_j2k_mct_function j2k_mct_read_functions_to_int32[4]  = {      & opj_j2k_read_int16_to_int32,      & opj_j2k_read_int32_to_int32,      & opj_j2k_read_float32_to_int32,      & opj_j2k_read_float64_to_int32};
#line 1230 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
opj_j2k_mct_function j2k_mct_write_functions_from_float[4]  = {      & opj_j2k_write_float_to_int16,      & opj_j2k_write_float_to_int32,      & opj_j2k_write_float_to_float,      & opj_j2k_write_float_to_float64};
#line 1252 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
opj_dec_memory_marker_handler_t j2k_memory_marker_handler_tab[21]  = 
#line 1252
  {      {(OPJ_UINT32 )65424, (OPJ_UINT32 )12, & opj_j2k_read_sot}, 
        {(OPJ_UINT32 )65362, (OPJ_UINT32 )20, & opj_j2k_read_cod}, 
        {(OPJ_UINT32 )65363, (OPJ_UINT32 )20, & opj_j2k_read_coc}, 
        {(OPJ_UINT32 )65374, (OPJ_UINT32 )20, & opj_j2k_read_rgn}, 
        {(OPJ_UINT32 )65372, (OPJ_UINT32 )20, & opj_j2k_read_qcd}, 
        {(OPJ_UINT32 )65373, (OPJ_UINT32 )20, & opj_j2k_read_qcc}, 
        {(OPJ_UINT32 )65375, (OPJ_UINT32 )20, & opj_j2k_read_poc}, 
        {(OPJ_UINT32 )65361, (OPJ_UINT32 )2, & opj_j2k_read_siz}, 
        {(OPJ_UINT32 )65365, (OPJ_UINT32 )4, & opj_j2k_read_tlm}, 
        {(OPJ_UINT32 )65367, (OPJ_UINT32 )4, & opj_j2k_read_plm}, 
        {(OPJ_UINT32 )65368, (OPJ_UINT32 )16, & opj_j2k_read_plt}, 
        {(OPJ_UINT32 )65376, (OPJ_UINT32 )4, & j2k_read_ppm_v3}, 
        {(OPJ_UINT32 )65377, (OPJ_UINT32 )16, & opj_j2k_read_ppt}, 
        {(OPJ_UINT32 )65425, (OPJ_UINT32 )0, (OPJ_BOOL (*)(opj_j2k_t * , OPJ_BYTE * ,
                                                        OPJ_UINT32  , opj_event_mgr_t * ))0}, 
        {(OPJ_UINT32 )65379,
      (OPJ_UINT32 )4, & opj_j2k_read_crg}, 
        {(OPJ_UINT32 )65380, (OPJ_UINT32 )20, & opj_j2k_read_com}, 
        {(OPJ_UINT32 )65396, (OPJ_UINT32 )20, & opj_j2k_read_mct}, 
        {(OPJ_UINT32 )65400, (OPJ_UINT32 )4, & opj_j2k_read_cbd}, 
        {(OPJ_UINT32 )65397, (OPJ_UINT32 )20, & opj_j2k_read_mcc}, 
        {(OPJ_UINT32 )65399, (OPJ_UINT32 )20, & opj_j2k_read_mco}, 
        {(OPJ_UINT32 )0, (OPJ_UINT32 )20, (OPJ_BOOL (*)(opj_j2k_t * , OPJ_BYTE * , OPJ_UINT32  ,
                                                     opj_event_mgr_t * ))0}};
#line 1289 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_read_int16_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1291
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1292
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1296
  i = (OPJ_UINT32 )0;
  {
#line 1296
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1296
    if (! (i < p_nb_elem)) {
#line 1296
      goto while_break;
    }
    {
#line 1297
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )2);
#line 1299
    l_src_data += sizeof(OPJ_INT16 );
#line 1301
    __cil_tmp8 = l_dest_data;
#line 1301
    l_dest_data ++;
#line 1301
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
#line 1296
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1300
  return;
}
}
#line 1305 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_read_int32_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1307
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1308
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1312
  i = (OPJ_UINT32 )0;
  {
#line 1312
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1312
    if (! (i < p_nb_elem)) {
#line 1312
      goto while_break;
    }
    {
#line 1313
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )4);
#line 1315
    l_src_data += sizeof(OPJ_INT32 );
#line 1317
    __cil_tmp8 = l_dest_data;
#line 1317
    l_dest_data ++;
#line 1317
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
#line 1312
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1316
  return;
}
}
#line 1321 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_read_float32_to_float(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1323
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1324
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1328
  i = (OPJ_UINT32 )0;
  {
#line 1328
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1328
    if (! (i < p_nb_elem)) {
#line 1328
      goto while_break;
    }
    {
#line 1329
    opj_read_float_LE(l_src_data, & l_temp);
#line 1331
    l_src_data += sizeof(OPJ_FLOAT32 );
#line 1333
    __cil_tmp8 = l_dest_data;
#line 1333
    l_dest_data ++;
#line 1333
    *__cil_tmp8 = l_temp;
#line 1328
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1332
  return;
}
}
#line 1337 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_read_float64_to_float(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1339
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1340
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1344
  i = (OPJ_UINT32 )0;
  {
#line 1344
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1344
    if (! (i < p_nb_elem)) {
#line 1344
      goto while_break;
    }
    {
#line 1345
    opj_read_double_LE(l_src_data, & l_temp);
#line 1347
    l_src_data += sizeof(OPJ_FLOAT64 );
#line 1349
    __cil_tmp8 = l_dest_data;
#line 1349
    l_dest_data ++;
#line 1349
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
#line 1344
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1348
  return;
}
}
#line 1353 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_read_int16_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1355
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1356
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1360
  i = (OPJ_UINT32 )0;
  {
#line 1360
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1360
    if (! (i < p_nb_elem)) {
#line 1360
      goto while_break;
    }
    {
#line 1361
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )2);
#line 1363
    l_src_data += sizeof(OPJ_INT16 );
#line 1365
    __cil_tmp8 = l_dest_data;
#line 1365
    l_dest_data ++;
#line 1365
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
#line 1360
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1364
  return;
}
}
#line 1369 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_read_int32_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1371
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1372
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1376
  i = (OPJ_UINT32 )0;
  {
#line 1376
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1376
    if (! (i < p_nb_elem)) {
#line 1376
      goto while_break;
    }
    {
#line 1377
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )4);
#line 1379
    l_src_data += sizeof(OPJ_INT32 );
#line 1381
    __cil_tmp8 = l_dest_data;
#line 1381
    l_dest_data ++;
#line 1381
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
#line 1376
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1380
  return;
}
}
#line 1385 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_read_float32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1387
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1388
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1392
  i = (OPJ_UINT32 )0;
  {
#line 1392
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1392
    if (! (i < p_nb_elem)) {
#line 1392
      goto while_break;
    }
    {
#line 1393
    opj_read_float_LE(l_src_data, & l_temp);
#line 1395
    l_src_data += sizeof(OPJ_FLOAT32 );
#line 1397
    __cil_tmp8 = l_dest_data;
#line 1397
    l_dest_data ++;
#line 1397
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
#line 1392
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1396
  return;
}
}
#line 1401 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_read_float64_to_int32(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1403
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1404
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1408
  i = (OPJ_UINT32 )0;
  {
#line 1408
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1408
    if (! (i < p_nb_elem)) {
#line 1408
      goto while_break;
    }
    {
#line 1409
    opj_read_double_LE(l_src_data, & l_temp);
#line 1411
    l_src_data += sizeof(OPJ_FLOAT64 );
#line 1413
    __cil_tmp8 = l_dest_data;
#line 1413
    l_dest_data ++;
#line 1413
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
#line 1408
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1412
  return;
}
}
#line 1417 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_write_float_to_int16(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1419
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1420
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1424
  i = (OPJ_UINT32 )0;
  {
#line 1424
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1424
    if (! (i < p_nb_elem)) {
#line 1424
      goto while_break;
    }
    {
#line 1425
    __cil_tmp8 = l_src_data;
#line 1425
    l_src_data ++;
#line 1425
    l_temp = (OPJ_UINT32 )*__cil_tmp8;
#line 1427
    opj_write_bytes_LE(l_dest_data, l_temp, (OPJ_UINT32 )sizeof(OPJ_INT16 ));
#line 1429
    l_dest_data += sizeof(OPJ_INT16 );
#line 1424
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1428
  return;
}
}
#line 1433 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_write_float_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1435
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1436
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1440
  i = (OPJ_UINT32 )0;
  {
#line 1440
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1440
    if (! (i < p_nb_elem)) {
#line 1440
      goto while_break;
    }
    {
#line 1441
    __cil_tmp8 = l_src_data;
#line 1441
    l_src_data ++;
#line 1441
    l_temp = (OPJ_UINT32 )*__cil_tmp8;
#line 1443
    opj_write_bytes_LE(l_dest_data, l_temp, (OPJ_UINT32 )sizeof(OPJ_INT32 ));
#line 1445
    l_dest_data += sizeof(OPJ_INT32 );
#line 1440
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1444
  return;
}
}
#line 1449 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_write_float_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1451
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1452
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1456
  i = (OPJ_UINT32 )0;
  {
#line 1456
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1456
    if (! (i < p_nb_elem)) {
#line 1456
      goto while_break;
    }
    {
#line 1457
    __cil_tmp8 = l_src_data;
#line 1457
    l_src_data ++;
#line 1457
    l_temp = *__cil_tmp8;
#line 1459
    opj_write_float_LE(l_dest_data, l_temp);
#line 1461
    l_dest_data += sizeof(OPJ_FLOAT32 );
#line 1456
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1460
  return;
}
}
#line 1465 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_write_float_to_float64(void const   *p_src_data , void *p_dest_data ,
                                    OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1467
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1468
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1472
  i = (OPJ_UINT32 )0;
  {
#line 1472
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1472
    if (! (i < p_nb_elem)) {
#line 1472
      goto while_break;
    }
    {
#line 1473
    __cil_tmp8 = l_src_data;
#line 1473
    l_src_data ++;
#line 1473
    l_temp = (OPJ_FLOAT64 )*__cil_tmp8;
#line 1475
    opj_write_double_LE(l_dest_data, l_temp);
#line 1477
    l_dest_data += sizeof(OPJ_FLOAT64 );
#line 1472
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1476
  return;
}
}
#line 1481 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
char *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) 
{ 
  j2k_prog_order_t *po ;

  {
#line 1483
  po = j2k_prog_order_list;
  {
#line 1483
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1483
    if (! ((int )po->enum_prog != -1)) {
#line 1483
      goto while_break;
    }
#line 1484
    if ((int )po->enum_prog == (int )prg_order) {
#line 1485
      return (po->str_prog);
    }
#line 1483
    po ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1488
  return (po->str_prog);
}
}
#line 1491 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_check_poc_val(opj_poc_t *p_pocs , OPJ_UINT32 p_nb_pocs , OPJ_UINT32 p_nb_resolutions ,
                               OPJ_UINT32 p_num_comps , OPJ_UINT32 p_num_layers ,
                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 *packet_array ;
  OPJ_UINT32 index___0 ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 i ;
  OPJ_UINT32 step_c ;
  OPJ_UINT32 step_r ;
  OPJ_UINT32 step_l ;
  OPJ_BOOL loss ;
  OPJ_UINT32 layno0 ;
  void *__cil_tmp18 ;
  OPJ_UINT32 res_index ;
  OPJ_UINT32 comp_index ;
  OPJ_UINT32 l_last_layno1 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 res_index___0 ;
  OPJ_UINT32 comp_index___0 ;

  {
  {
#line 1501
  step_c = (OPJ_UINT32 )1;
#line 1502
  step_r = p_num_comps * step_c;
#line 1503
  step_l = p_nb_resolutions * step_r;
#line 1504
  loss = 0;
#line 1505
  layno0 = (OPJ_UINT32 )0;
#line 1507
  __cil_tmp18 = calloc((unsigned long )(step_l * p_num_layers), sizeof(OPJ_UINT32 ));
#line 1507
  packet_array = (OPJ_UINT32 *)__cil_tmp18;
  }
#line 1508
  if ((unsigned long )packet_array == (unsigned long )((OPJ_UINT32 *)0)) {
    {
#line 1509
    opj_event_msg(p_manager, 1, "Not enough memory for checking the poc values.\n");
    }
#line 1510
    return (0);
  }
#line 1513
  if (p_nb_pocs == 0U) {
    {
#line 1514
    free((void *)packet_array);
    }
#line 1515
    return (1);
  }
#line 1518
  index___0 = step_r * p_pocs->resno0;
#line 1520
  resno = p_pocs->resno0;
  {
#line 1520
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1520
    if (! (resno < p_pocs->resno1)) {
#line 1520
      goto while_break;
    }
#line 1522
    res_index = index___0 + p_pocs->compno0 * step_c;
#line 1525
    compno = p_pocs->compno0;
    {
#line 1525
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1525
      if (! (compno < p_pocs->compno1)) {
#line 1525
        goto while_break___0;
      }
#line 1526
      comp_index = res_index + layno0 * step_l;
#line 1529
      layno = layno0;
      {
#line 1529
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1529
        if (! (layno < p_pocs->layno1)) {
#line 1529
          goto while_break___1;
        }
#line 1531
        *(packet_array + comp_index) = (OPJ_UINT32 )1;
#line 1532
        comp_index += step_l;
#line 1529
        layno ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___1: 
#line 1535
      res_index += step_c;
#line 1525
      compno ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___0: 
#line 1538
    index___0 += step_r;
#line 1520
    resno ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break: 
#line 1540
  p_pocs ++;
#line 1543
  i = (OPJ_UINT32 )1;
  {
#line 1543
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1543
    if (! (i < p_nb_pocs)) {
#line 1543
      goto while_break___2;
    }
#line 1544
    l_last_layno1 = (p_pocs - 1)->layno1;
#line 1546
    if (p_pocs->layno1 > l_last_layno1) {
#line 1546
      tmp = l_last_layno1;
    } else {
#line 1546
      tmp = 0U;
    }
#line 1546
    layno0 = tmp;
#line 1547
    index___0 = step_r * p_pocs->resno0;
#line 1550
    resno = p_pocs->resno0;
    {
#line 1550
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 1550
      if (! (resno < p_pocs->resno1)) {
#line 1550
        goto while_break___3;
      }
#line 1551
      res_index___0 = index___0 + p_pocs->compno0 * step_c;
#line 1554
      compno = p_pocs->compno0;
      {
#line 1554
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1554
        if (! (compno < p_pocs->compno1)) {
#line 1554
          goto while_break___4;
        }
#line 1555
        comp_index___0 = res_index___0 + layno0 * step_l;
#line 1558
        layno = layno0;
        {
#line 1558
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 1558
          if (! (layno < p_pocs->layno1)) {
#line 1558
            goto while_break___5;
          }
#line 1560
          *(packet_array + comp_index___0) = (OPJ_UINT32 )1;
#line 1561
          comp_index___0 += step_l;
#line 1558
          layno ++;
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break___5: 
#line 1564
        res_index___0 += step_c;
#line 1554
        compno ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___4: 
#line 1567
      index___0 += step_r;
#line 1550
      resno ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___3: 
#line 1570
    p_pocs ++;
#line 1543
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___2: 
#line 1573
  index___0 = (OPJ_UINT32 )0;
#line 1574
  layno = (OPJ_UINT32 )0;
  {
#line 1574
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 1574
    if (! (layno < p_num_layers)) {
#line 1574
      goto while_break___6;
    }
#line 1575
    resno = (OPJ_UINT32 )0;
    {
#line 1575
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 1575
      if (! (resno < p_nb_resolutions)) {
#line 1575
        goto while_break___7;
      }
#line 1576
      compno = (OPJ_UINT32 )0;
      {
#line 1576
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 1576
        if (! (compno < p_num_comps)) {
#line 1576
          goto while_break___8;
        }
#line 1577
        loss |= *(packet_array + index___0) != 1U;
#line 1579
        index___0 += step_c;
#line 1576
        compno ++;
      }
      while_break___18: /* CIL Label */ ;
      }
      while_break___8: 
#line 1575
      resno ++;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___7: 
#line 1574
    layno ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___6: ;
#line 1584
  if (loss) {
    {
#line 1585
    opj_event_msg(p_manager, 1, "Missing packets possible loss of data\n");
    }
  }
  {
#line 1588
  free((void *)packet_array);
  }
#line 1590
  return (! loss);
}
}
#line 1595 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp , OPJ_UINT32 pino , OPJ_UINT32 tileno ) 
{ 
  OPJ_CHAR *prog ;
  OPJ_INT32 i ;
  OPJ_UINT32 tpnum ;
  opj_tcp_t *tcp ;
  opj_poc_t *l_current_poc ;

  {
  {
#line 1597
  prog = (OPJ_CHAR *)0;
#line 1599
  tpnum = (OPJ_UINT32 )1;
#line 1600
  tcp = (opj_tcp_t *)0;
#line 1601
  l_current_poc = (opj_poc_t *)0;
#line 1608
  tcp = cp->tcps + tileno;
#line 1611
  l_current_poc = & tcp->pocs[pino];
#line 1615
  prog = opj_j2k_convert_progression_order(tcp->prg);
  }
#line 1618
  if ((int )cp->m_specific_param.m_enc.m_tp_on == 1) {
#line 1619
    i = 0;
    {
#line 1619
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1619
      if (! (i < 4)) {
#line 1619
        goto while_break;
      }
#line 1623
      if ((int )*(prog + i) == 67) {
#line 1623
        goto case_67;
      }
#line 1627
      if ((int )*(prog + i) == 82) {
#line 1627
        goto case_82;
      }
#line 1631
      if ((int )*(prog + i) == 80) {
#line 1631
        goto case_80;
      }
#line 1635
      if ((int )*(prog + i) == 76) {
#line 1635
        goto case_76;
      }
#line 1620
      goto switch_break;
      case_67: 
#line 1624
      tpnum *= l_current_poc->compE;
#line 1625
      goto switch_break;
      case_82: 
#line 1628
      tpnum *= l_current_poc->resE;
#line 1629
      goto switch_break;
      case_80: 
#line 1632
      tpnum *= l_current_poc->prcE;
#line 1633
      goto switch_break;
      case_76: 
#line 1636
      tpnum *= l_current_poc->layE;
#line 1637
      goto switch_break;
      switch_break: ;
#line 1640
      if ((int )cp->m_specific_param.m_enc.m_tp_flag == (int )*(prog + i)) {
#line 1641
        cp->m_specific_param.m_enc.m_tp_pos = i;
#line 1642
        goto while_break;
      }
#line 1619
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 1647
    tpnum = (OPJ_UINT32 )1;
  }
#line 1650
  return (tpnum);
}
}
#line 1653 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k , opj_cp_t *cp , OPJ_UINT32 *p_nb_tiles ,
                              opj_image_t *image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 tileno ;
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *tcp ;
  OPJ_UINT32 cur_totnum_tp ;
  OPJ_UINT32 tp_num ;
  OPJ_UINT32 __cil_tmp17 ;

  {
#line 1671
  l_nb_tiles = cp->tw * cp->th;
#line 1672
  *p_nb_tiles = (OPJ_UINT32 )0;
#line 1673
  tcp = cp->tcps;
#line 1710
  tileno = (OPJ_UINT32 )0;
  {
#line 1710
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1710
    if (! (tileno < l_nb_tiles)) {
#line 1710
      goto while_break;
    }
    {
#line 1711
    cur_totnum_tp = (OPJ_UINT32 )0;
#line 1713
    opj_pi_update_encoding_parameters(image, cp, tileno);
#line 1715
    pino = (OPJ_UINT32 )0;
    }
    {
#line 1715
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1715
      if (! (pino <= tcp->numpocs)) {
#line 1715
        goto while_break___0;
      }
      {
#line 1716
      __cil_tmp17 = opj_j2k_get_num_tp(cp, pino, tileno);
#line 1716
      tp_num = __cil_tmp17;
#line 1718
      *p_nb_tiles += tp_num;
#line 1720
      cur_totnum_tp += tp_num;
#line 1715
      pino ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 1722
    tcp->m_nb_tile_parts = cur_totnum_tp;
#line 1724
    tcp ++;
#line 1710
    tileno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1728
  return (1);
}
}
#line 1731 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_start_stream ;
  OPJ_SIZE_T __cil_tmp8 ;

  {
  {
#line 1736
  l_start_stream = (OPJ_BYTE *)0;
#line 1743
  l_start_stream = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 1746
  opj_write_bytes_LE(l_start_stream, (OPJ_UINT32 )65359, (OPJ_UINT32 )2);
#line 1748
  __cil_tmp8 = opj_stream_write_data(p_stream, l_start_stream, (OPJ_SIZE_T )2, p_manager);
  }
#line 1748
  if (__cil_tmp8 != 2UL) {
#line 1749
    return (0);
  }
#line 1762
  return (1);
}
}
#line 1771 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_data[2] ;
  OPJ_UINT32 l_marker ;
  OPJ_SIZE_T __cil_tmp9 ;
  OPJ_OFF_T __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 1784
  __cil_tmp9 = opj_stream_read_data(p_stream, l_data, (OPJ_SIZE_T )2, p_manager);
  }
#line 1784
  if (__cil_tmp9 != 2UL) {
#line 1785
    return (0);
  }
  {
#line 1788
  opj_read_bytes_LE(l_data, & l_marker, (OPJ_UINT32 )2);
  }
#line 1789
  if (l_marker != 65359U) {
#line 1790
    return (0);
  }
  {
#line 1794
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )2;
#line 1797
  __cil_tmp10 = opj_stream_tell(p_stream);
#line 1797
  (p_j2k->cstr_index)->main_head_start = __cil_tmp10 - 2L;
#line 1799
  opj_event_msg(p_manager, 4, "Start to read j2k main header (%d).\n", (p_j2k->cstr_index)->main_head_start);
#line 1802
  __cil_tmp11 = opj_j2k_add_mhmarker(p_j2k->cstr_index, (OPJ_UINT32 )65359, (p_j2k->cstr_index)->main_head_start,
                                     (OPJ_UINT32 )2);
  }
#line 1802
  if (0 == __cil_tmp11) {
    {
#line 1803
    opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n");
    }
#line 1804
    return (0);
  }
#line 1806
  return (1);
}
}
#line 1809 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_size_len ;
  OPJ_BYTE *l_current_ptr ;
  opj_image_t *l_image ;
  opj_cp_t *cp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;

  {
#line 1816
  l_image = (opj_image_t *)0;
#line 1817
  cp = (opj_cp_t *)0;
#line 1818
  l_img_comp = (opj_image_comp_t *)0;
#line 1825
  l_image = p_j2k->m_private_image;
#line 1826
  cp = & p_j2k->m_cp;
#line 1827
  l_size_len = 40U + 3U * l_image->numcomps;
#line 1828
  l_img_comp = l_image->comps;
#line 1830
  if (l_size_len > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 1832
    __cil_tmp14 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_size_len);
#line 1832
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp14;
    }
#line 1833
    if (! new_header_tile_data) {
      {
#line 1834
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 1835
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 1836
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 1837
      opj_event_msg(p_manager, 1, "Not enough memory for the SIZ marker\n");
      }
#line 1838
      return (0);
    }
#line 1840
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 1841
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_size_len;
  }
  {
#line 1844
  l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 1847
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )65361, (OPJ_UINT32 )2);
#line 1848
  l_current_ptr += 2;
#line 1850
  opj_write_bytes_LE(l_current_ptr, l_size_len - 2U, (OPJ_UINT32 )2);
#line 1851
  l_current_ptr += 2;
#line 1853
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )cp->rsiz, (OPJ_UINT32 )2);
#line 1854
  l_current_ptr += 2;
#line 1856
  opj_write_bytes_LE(l_current_ptr, l_image->x1, (OPJ_UINT32 )4);
#line 1857
  l_current_ptr += 4;
#line 1859
  opj_write_bytes_LE(l_current_ptr, l_image->y1, (OPJ_UINT32 )4);
#line 1860
  l_current_ptr += 4;
#line 1862
  opj_write_bytes_LE(l_current_ptr, l_image->x0, (OPJ_UINT32 )4);
#line 1863
  l_current_ptr += 4;
#line 1865
  opj_write_bytes_LE(l_current_ptr, l_image->y0, (OPJ_UINT32 )4);
#line 1866
  l_current_ptr += 4;
#line 1868
  opj_write_bytes_LE(l_current_ptr, cp->tdx, (OPJ_UINT32 )4);
#line 1869
  l_current_ptr += 4;
#line 1871
  opj_write_bytes_LE(l_current_ptr, cp->tdy, (OPJ_UINT32 )4);
#line 1872
  l_current_ptr += 4;
#line 1874
  opj_write_bytes_LE(l_current_ptr, cp->tx0, (OPJ_UINT32 )4);
#line 1875
  l_current_ptr += 4;
#line 1877
  opj_write_bytes_LE(l_current_ptr, cp->ty0, (OPJ_UINT32 )4);
#line 1878
  l_current_ptr += 4;
#line 1880
  opj_write_bytes_LE(l_current_ptr, l_image->numcomps, (OPJ_UINT32 )2);
#line 1881
  l_current_ptr += 2;
#line 1883
  i = (OPJ_UINT32 )0;
  }
  {
#line 1883
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1883
    if (! (i < l_image->numcomps)) {
#line 1883
      goto while_break;
    }
    {
#line 1885
    opj_write_bytes_LE(l_current_ptr, (l_img_comp->prec - 1U) + (l_img_comp->sgnd << 7),
                       (OPJ_UINT32 )1);
#line 1886
    l_current_ptr ++;
#line 1888
    opj_write_bytes_LE(l_current_ptr, l_img_comp->dx, (OPJ_UINT32 )1);
#line 1889
    l_current_ptr ++;
#line 1891
    opj_write_bytes_LE(l_current_ptr, l_img_comp->dy, (OPJ_UINT32 )1);
#line 1892
    l_current_ptr ++;
#line 1894
    l_img_comp ++;
#line 1883
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1897
  __cil_tmp15 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_size_len, p_manager);
  }
#line 1897
  if (__cil_tmp15 != (unsigned long )l_size_len) {
#line 1898
    return (0);
  }
#line 1901
  return (1);
}
}
#line 1911 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_comp_remain ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_ty1 ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcp_t *l_current_tile_param ;
  void *__cil_tmp20 ;
  OPJ_UINT32 tmp___2 ;
  OPJ_INT32 __cil_tmp22 ;
  OPJ_INT32 __cil_tmp23 ;
  OPJ_INT32 __cil_tmp24 ;
  OPJ_INT32 __cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;

  {
#line 1923
  l_image = (opj_image_t *)0;
#line 1924
  l_cp = (opj_cp_t *)0;
#line 1925
  l_img_comp = (opj_image_comp_t *)0;
#line 1926
  l_current_tile_param = (opj_tcp_t *)0;
#line 1933
  l_image = p_j2k->m_private_image;
#line 1934
  l_cp = & p_j2k->m_cp;
#line 1937
  if (p_header_size < 36U) {
    {
#line 1938
    opj_event_msg(p_manager, 1, "Error with SIZ marker size\niEV");
    }
#line 1939
    return (0);
  }
#line 1942
  l_remaining_size = p_header_size - 36U;
#line 1943
  l_nb_comp = l_remaining_size / 3U;
#line 1944
  l_nb_comp_remain = l_remaining_size % 3U;
#line 1945
  if (l_nb_comp_remain != 0U) {
    {
#line 1946
    opj_event_msg(p_manager, 1, "Error with SIZ marker size\n");
    }
#line 1947
    return (0);
  }
  {
#line 1950
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 1951
  p_header_data += 2;
#line 1952
  l_cp->rsiz = (OPJ_UINT16 )l_tmp;
#line 1953
  opj_read_bytes_LE(p_header_data, & l_image->x1, (OPJ_UINT32 )4);
#line 1954
  p_header_data += 4;
#line 1955
  opj_read_bytes_LE(p_header_data, & l_image->y1, (OPJ_UINT32 )4);
#line 1956
  p_header_data += 4;
#line 1957
  opj_read_bytes_LE(p_header_data, & l_image->x0, (OPJ_UINT32 )4);
#line 1958
  p_header_data += 4;
#line 1959
  opj_read_bytes_LE(p_header_data, & l_image->y0, (OPJ_UINT32 )4);
#line 1960
  p_header_data += 4;
#line 1961
  opj_read_bytes_LE(p_header_data, & l_cp->tdx, (OPJ_UINT32 )4);
#line 1962
  p_header_data += 4;
#line 1963
  opj_read_bytes_LE(p_header_data, & l_cp->tdy, (OPJ_UINT32 )4);
#line 1964
  p_header_data += 4;
#line 1965
  opj_read_bytes_LE(p_header_data, & l_cp->tx0, (OPJ_UINT32 )4);
#line 1966
  p_header_data += 4;
#line 1967
  opj_read_bytes_LE(p_header_data, & l_cp->ty0, (OPJ_UINT32 )4);
#line 1968
  p_header_data += 4;
#line 1969
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 1970
  p_header_data += 2;
  }
#line 1971
  if (l_tmp < 16385U) {
#line 1972
    l_image->numcomps = (OPJ_UINT32 )((OPJ_UINT16 )l_tmp);
  } else {
    {
#line 1974
    opj_event_msg(p_manager, 1, "Error with SIZ marker: number of component is illegal -> %d\nEV",
                  l_tmp);
    }
#line 1975
    return (0);
  }
#line 1978
  if (l_image->numcomps != l_nb_comp) {
    {
#line 1979
    opj_event_msg(p_manager, 1, "Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\n\t\325iEV",
                  l_image->numcomps, l_nb_comp);
    }
#line 1980
    return (0);
  }
#line 1985
  if (l_image->x0 >= l_image->x1) {
    {
#line 1986
    opj_event_msg(p_manager, 1, "Error with SIZ marker: negative or zero image size (%d x %d)\n",
                  l_image->x1 - l_image->x0, l_image->y1 - l_image->y0);
    }
#line 1987
    return (0);
  } else
#line 1985
  if (l_image->y0 >= l_image->y1) {
    {
#line 1986
    opj_event_msg(p_manager, 1, "Error with SIZ marker: negative or zero image size (%d x %d)\n",
                  l_image->x1 - l_image->x0, l_image->y1 - l_image->y0);
    }
#line 1987
    return (0);
  }
#line 1990
  if (! (l_cp->tdx * l_cp->tdy)) {
    {
#line 1991
    opj_event_msg(p_manager, 1, "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n",
                  l_cp->tdx, l_cp->tdy);
    }
#line 1992
    return (0);
  }
#line 1996
  if ((OPJ_UINT64 )l_image->x1 * (OPJ_UINT64 )l_image->y1 != (unsigned long )(l_image->x1 * l_image->y1)) {
    {
#line 1997
    opj_event_msg(p_manager, 1, "Prevent buffer overflow (x1: %d, y1: %d)\n\353\324iEV",
                  l_image->x1, l_image->y1);
    }
#line 1998
    return (0);
  }
  {
#line 2058
  __cil_tmp20 = calloc((unsigned long )l_image->numcomps, sizeof(opj_image_comp_t ));
#line 2058
  l_image->comps = (opj_image_comp_t *)__cil_tmp20;
  }
#line 2059
  if ((unsigned long )l_image->comps == (unsigned long )((opj_image_comp_t *)0)) {
    {
#line 2060
    l_image->numcomps = (OPJ_UINT32 )0;
#line 2061
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2062
    return (0);
  }
#line 2065
  l_img_comp = l_image->comps;
#line 2068
  i = (OPJ_UINT32 )0;
  {
#line 2068
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2068
    if (! (i < l_image->numcomps)) {
#line 2068
      goto while_break;
    }
    {
#line 2070
    opj_read_bytes_LE(p_header_data, & tmp___2, (OPJ_UINT32 )1);
#line 2071
    p_header_data ++;
#line 2072
    l_img_comp->prec = (tmp___2 & 127U) + 1U;
#line 2073
    l_img_comp->sgnd = tmp___2 >> 7;
#line 2074
    opj_read_bytes_LE(p_header_data, & tmp___2, (OPJ_UINT32 )1);
#line 2075
    p_header_data ++;
#line 2076
    l_img_comp->dx = tmp___2;
#line 2077
    opj_read_bytes_LE(p_header_data, & tmp___2, (OPJ_UINT32 )1);
#line 2078
    p_header_data ++;
#line 2079
    l_img_comp->dy = tmp___2;
    }
#line 2080
    if (l_img_comp->dx < 1U) {
      {
#line 2082
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u\n (should be between 1 and 255 according the JPEG2000 norm)",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
#line 2085
      return (0);
    } else
#line 2080
    if (l_img_comp->dx > 255U) {
      {
#line 2082
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u\n (should be between 1 and 255 according the JPEG2000 norm)",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
#line 2085
      return (0);
    } else
#line 2080
    if (l_img_comp->dy < 1U) {
      {
#line 2082
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u\n (should be between 1 and 255 according the JPEG2000 norm)",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
#line 2085
      return (0);
    } else
#line 2080
    if (l_img_comp->dy > 255U) {
      {
#line 2082
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u\n (should be between 1 and 255 according the JPEG2000 norm)",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
#line 2085
      return (0);
    }
#line 2115
    l_img_comp->resno_decoded = (OPJ_UINT32 )0;
#line 2116
    l_img_comp->factor = l_cp->m_specific_param.m_dec.m_reduce;
#line 2117
    l_img_comp ++;
#line 2068
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 2121
  __cil_tmp22 = (((OPJ_INT32 )(l_image->x1 - l_cp->tx0) + (OPJ_INT32 )l_cp->tdx) - 1) / (OPJ_INT32 )l_cp->tdx;
#line 2121
  l_cp->tw = (OPJ_UINT32 )__cil_tmp22;
#line 2122
  __cil_tmp23 = (((OPJ_INT32 )(l_image->y1 - l_cp->ty0) + (OPJ_INT32 )l_cp->tdy) - 1) / (OPJ_INT32 )l_cp->tdy;
#line 2122
  l_cp->th = (OPJ_UINT32 )__cil_tmp23;
#line 2125
  if (l_cp->tw == 0U) {
    {
#line 2126
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
#line 2129
    return (0);
  } else
#line 2125
  if (l_cp->th == 0U) {
    {
#line 2126
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
#line 2129
    return (0);
  } else
#line 2125
  if (l_cp->tw > 65535U / l_cp->th) {
    {
#line 2126
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
#line 2129
    return (0);
  }
#line 2131
  l_nb_tiles = l_cp->tw * l_cp->th;
#line 2134
  if (p_j2k->m_specific_param.m_decoder.m_discard_tiles) {
    {
#line 2135
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (p_j2k->m_specific_param.m_decoder.m_start_tile_x - l_cp->tx0) / l_cp->tdx;
#line 2136
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (p_j2k->m_specific_param.m_decoder.m_start_tile_y - l_cp->ty0) / l_cp->tdy;
#line 2137
    __cil_tmp24 = opj_int_ceildiv((OPJ_INT32 )(p_j2k->m_specific_param.m_decoder.m_end_tile_x - l_cp->tx0),
                                  (OPJ_INT32 )l_cp->tdx);
#line 2137
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32 )__cil_tmp24;
#line 2138
    __cil_tmp25 = opj_int_ceildiv((OPJ_INT32 )(p_j2k->m_specific_param.m_decoder.m_end_tile_y - l_cp->ty0),
                                  (OPJ_INT32 )l_cp->tdy);
#line 2138
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32 )__cil_tmp25;
    }
  } else {
#line 2141
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 2142
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 2143
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 2144
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
  }
  {
#line 2188
  __cil_tmp26 = calloc((unsigned long )l_nb_tiles, sizeof(opj_tcp_t ));
#line 2188
  l_cp->tcps = (opj_tcp_t *)__cil_tmp26;
  }
#line 2189
  if ((unsigned long )l_cp->tcps == (unsigned long )((opj_tcp_t *)0)) {
    {
#line 2190
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2191
    return (0);
  }
  {
#line 2207
  __cil_tmp27 = calloc((unsigned long )l_image->numcomps, sizeof(opj_tccp_t ));
#line 2207
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps = (opj_tccp_t *)__cil_tmp27;
  }
#line 2209
  if ((unsigned long )(p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps == (unsigned long )((opj_tccp_t *)0)) {
    {
#line 2210
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2211
    return (0);
  }
  {
#line 2214
  __cil_tmp28 = calloc(10UL, sizeof(opj_mct_data_t ));
#line 2214
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mct_records = (opj_mct_data_t *)__cil_tmp28;
  }
#line 2217
  if (! (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mct_records) {
    {
#line 2218
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2219
    return (0);
  }
  {
#line 2221
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_nb_max_mct_records = (OPJ_UINT32 )10;
#line 2223
  __cil_tmp29 = calloc(10UL, sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 2223
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp29;
  }
#line 2227
  if (! (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mcc_records) {
    {
#line 2228
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2229
    return (0);
  }
#line 2231
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_nb_max_mcc_records = (OPJ_UINT32 )10;
#line 2234
  i = (OPJ_UINT32 )0;
  {
#line 2234
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 2234
    if (! (i < l_image->numcomps)) {
#line 2234
      goto while_break___0;
    }
#line 2235
    if (! (l_image->comps + i)->sgnd) {
#line 2236
      ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps + i)->m_dc_level_shift = 1 << ((l_image->comps + i)->prec - 1U);
    }
#line 2234
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 2240
  l_current_tile_param = l_cp->tcps;
#line 2241
  i = (OPJ_UINT32 )0;
  {
#line 2241
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 2241
    if (! (i < l_nb_tiles)) {
#line 2241
      goto while_break___1;
    }
    {
#line 2242
    __cil_tmp30 = calloc((unsigned long )l_image->numcomps, sizeof(opj_tccp_t ));
#line 2242
    l_current_tile_param->tccps = (opj_tccp_t *)__cil_tmp30;
    }
#line 2243
    if ((unsigned long )l_current_tile_param->tccps == (unsigned long )((opj_tccp_t *)0)) {
      {
#line 2244
      opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
      }
#line 2245
      return (0);
    }
#line 2248
    l_current_tile_param ++;
#line 2241
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 2251
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )4;
#line 2252
  opj_image_comp_header_update(l_image, l_cp);
  }
#line 2254
  return (1);
}
}
#line 2257 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_comment_size ;
  OPJ_UINT32 l_total_com_size ;
  OPJ_CHAR *l_comment ;
  OPJ_BYTE *l_current_ptr ;
  unsigned long __cil_tmp11 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 2265
  l_current_ptr = (OPJ_BYTE *)0;
#line 2272
  l_comment = p_j2k->m_cp.comment;
#line 2273
  __cil_tmp11 = strlen((char const   *)l_comment);
#line 2273
  l_comment_size = (OPJ_UINT32 )__cil_tmp11;
#line 2274
  l_total_com_size = l_comment_size + 6U;
  }
#line 2276
  if (l_total_com_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2277
    __cil_tmp13 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_total_com_size);
#line 2277
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp13;
    }
#line 2278
    if (! new_header_tile_data) {
      {
#line 2279
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2280
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2281
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2282
      opj_event_msg(p_manager, 1, "Not enough memory to write the COM marker\n\326iEV");
      }
#line 2283
      return (0);
    }
#line 2285
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2286
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_total_com_size;
  }
  {
#line 2289
  l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2291
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )65380, (OPJ_UINT32 )2);
#line 2292
  l_current_ptr += 2;
#line 2294
  opj_write_bytes_LE(l_current_ptr, l_total_com_size - 2U, (OPJ_UINT32 )2);
#line 2295
  l_current_ptr += 2;
#line 2297
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )1, (OPJ_UINT32 )2);
#line 2298
  l_current_ptr += 2;
#line 2300
  memcpy((void *)l_current_ptr, (void const   *)l_comment, (unsigned long )l_comment_size);
#line 2302
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_total_com_size, p_manager);
  }
#line 2302
  if (__cil_tmp14 != (unsigned long )l_total_com_size) {
#line 2303
    return (0);
  }
#line 2306
  return (1);
}
}
#line 2316 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 


  {
#line 2328
  return (1);
}
}
#line 2331 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_code_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
  {
#line 2335
  l_cp = (opj_cp_t *)0;
#line 2336
  l_tcp = (opj_tcp_t *)0;
#line 2338
  l_current_data = (OPJ_BYTE *)0;
#line 2345
  l_cp = & p_j2k->m_cp;
#line 2346
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 2347
  __cil_tmp12 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, p_j2k->m_current_tile_number,
                                             (OPJ_UINT32 )0);
#line 2347
  l_code_size = 9U + __cil_tmp12;
#line 2348
  l_remaining_size = l_code_size;
  }
#line 2350
  if (l_code_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2351
    __cil_tmp14 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_code_size);
#line 2351
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp14;
    }
#line 2352
    if (! new_header_tile_data) {
      {
#line 2353
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2354
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2355
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2356
      opj_event_msg(p_manager, 1, "Not enough memory to write COD marker\n");
      }
#line 2357
      return (0);
    }
#line 2359
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2360
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_code_size;
  }
  {
#line 2363
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2365
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65362, (OPJ_UINT32 )2);
#line 2366
  l_current_data += 2;
#line 2368
  opj_write_bytes_LE(l_current_data, l_code_size - 2U, (OPJ_UINT32 )2);
#line 2369
  l_current_data += 2;
#line 2371
  opj_write_bytes_LE(l_current_data, l_tcp->csty, (OPJ_UINT32 )1);
#line 2372
  l_current_data ++;
#line 2374
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_tcp->prg, (OPJ_UINT32 )1);
#line 2375
  l_current_data ++;
#line 2377
  opj_write_bytes_LE(l_current_data, l_tcp->numlayers, (OPJ_UINT32 )2);
#line 2378
  l_current_data += 2;
#line 2380
  opj_write_bytes_LE(l_current_data, l_tcp->mct, (OPJ_UINT32 )1);
#line 2381
  l_current_data ++;
#line 2383
  l_remaining_size -= 9U;
#line 2385
  __cil_tmp15 = opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0,
                                          l_current_data, & l_remaining_size, p_manager);
  }
#line 2385
  if (! __cil_tmp15) {
    {
#line 2386
    opj_event_msg(p_manager, 1, "Error writing COD marker\n{\326iEV");
    }
#line 2387
    return (0);
  }
#line 2390
  if (l_remaining_size != 0U) {
    {
#line 2391
    opj_event_msg(p_manager, 1, "Error writing COD marker\n");
    }
#line 2392
    return (0);
  }
  {
#line 2395
  __cil_tmp16 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_code_size, p_manager);
  }
#line 2395
  if (__cil_tmp16 != (unsigned long )l_code_size) {
#line 2396
    return (0);
  }
#line 2399
  return (1);
}
}
#line 2409 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_tmp ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_image_t *l_image ;
  opj_tcp_t *tmp___2 ;
  OPJ_BOOL __cil_tmp14 ;

  {
#line 2418
  l_cp = (opj_cp_t *)0;
#line 2419
  l_tcp = (opj_tcp_t *)0;
#line 2420
  l_image = (opj_image_t *)0;
#line 2427
  l_image = p_j2k->m_private_image;
#line 2428
  l_cp = & p_j2k->m_cp;
#line 2431
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 2431
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 2431
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 2431
  l_tcp = tmp___2;
#line 2436
  if (p_header_size < 5U) {
    {
#line 2437
    opj_event_msg(p_manager, 1, "Error reading COD marker\n\244\326iEV");
    }
#line 2438
    return (0);
  }
  {
#line 2441
  opj_read_bytes_LE(p_header_data, & l_tcp->csty, (OPJ_UINT32 )1);
#line 2442
  p_header_data ++;
  }
#line 2444
  if ((l_tcp->csty & 4294967288U) != 0U) {
    {
#line 2445
    opj_event_msg(p_manager, 1, "Unknown Scod value in COD marker\n}\326iEV");
    }
#line 2446
    return (0);
  }
  {
#line 2448
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 2449
  p_header_data ++;
#line 2450
  l_tcp->prg = (OPJ_PROG_ORDER )l_tmp;
  }
#line 2452
  if ((int )l_tcp->prg > 4) {
    {
#line 2453
    opj_event_msg(p_manager, 1, "Unknown progression order in COD marker\n\220");
#line 2454
    l_tcp->prg = (OPJ_PROG_ORDER )-1;
    }
  }
  {
#line 2456
  opj_read_bytes_LE(p_header_data, & l_tcp->numlayers, (OPJ_UINT32 )2);
#line 2457
  p_header_data += 2;
  }
#line 2460
  if (l_cp->m_specific_param.m_dec.m_layer) {
#line 2461
    l_tcp->num_layers_to_decode = l_cp->m_specific_param.m_dec.m_layer;
  } else {
#line 2464
    l_tcp->num_layers_to_decode = l_tcp->numlayers;
  }
  {
#line 2467
  opj_read_bytes_LE(p_header_data, & l_tcp->mct, (OPJ_UINT32 )1);
#line 2468
  p_header_data ++;
#line 2470
  p_header_size -= 5U;
#line 2471
  i = (OPJ_UINT32 )0;
  }
  {
#line 2471
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2471
    if (! (i < l_image->numcomps)) {
#line 2471
      goto while_break;
    }
#line 2472
    (l_tcp->tccps + i)->csty = l_tcp->csty & 1U;
#line 2471
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2475
  __cil_tmp14 = opj_j2k_read_SPCod_SPCoc(p_j2k, (OPJ_UINT32 )0, p_header_data, & p_header_size,
                                         p_manager);
  }
#line 2475
  if (! __cil_tmp14) {
    {
#line 2476
    opj_event_msg(p_manager, 1, "Error reading COD marker\n\273\326iEV");
    }
#line 2477
    return (0);
  }
#line 2480
  if (p_header_size != 0U) {
    {
#line 2481
    opj_event_msg(p_manager, 1, "Error reading COD marker\nf\326iEV");
    }
#line 2482
    return (0);
  }
  {
#line 2486
  opj_j2k_copy_tile_component_parameters(p_j2k);
  }
#line 2501
  return (1);
}
}
#line 2598 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;

  {
#line 2603
  l_max = (OPJ_UINT32 )0;
#line 2607
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 2608
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 2610
  i = (OPJ_UINT32 )0;
  {
#line 2610
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2610
    if (! (i < l_nb_tiles)) {
#line 2610
      goto while_break;
    }
#line 2611
    j = (OPJ_UINT32 )0;
    {
#line 2611
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 2611
      if (! (j < l_nb_comp)) {
#line 2611
        goto while_break___0;
      }
      {
#line 2612
      __cil_tmp7 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, i, j);
#line 2612
      __cil_tmp8 = opj_uint_max(l_max, __cil_tmp7);
#line 2612
      l_max = __cil_tmp8;
#line 2611
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 2610
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 2616
  return (6U + l_max);
}
}
#line 2626 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_comp_room ;
  OPJ_UINT32 l_comp_no ;
  opj_tcp_t *tmp___2 ;
  int tmp___3 ;
  OPJ_BOOL __cil_tmp15 ;

  {
#line 2632
  l_cp = (opj_cp_t *)((void *)0);
#line 2633
  l_tcp = (opj_tcp_t *)((void *)0);
#line 2634
  l_image = (opj_image_t *)((void *)0);
#line 2643
  l_cp = & p_j2k->m_cp;
#line 2644
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 2644
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 2644
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 2644
  l_tcp = tmp___2;
#line 2647
  l_image = p_j2k->m_private_image;
#line 2649
  if (l_image->numcomps <= 256U) {
#line 2649
    tmp___3 = 1;
  } else {
#line 2649
    tmp___3 = 2;
  }
#line 2649
  l_comp_room = (OPJ_UINT32 )tmp___3;
#line 2652
  if (p_header_size < l_comp_room + 1U) {
    {
#line 2653
    opj_event_msg(p_manager, 1, "Error reading COC marker\n");
    }
#line 2654
    return (0);
  }
  {
#line 2656
  p_header_size -= l_comp_room + 1U;
#line 2658
  opj_read_bytes_LE(p_header_data, & l_comp_no, l_comp_room);
#line 2659
  p_header_data += l_comp_room;
  }
#line 2660
  if (l_comp_no >= l_image->numcomps) {
    {
#line 2661
    opj_event_msg(p_manager, 1, "Error reading COC marker (bad number of components)\nEV");
    }
#line 2662
    return (0);
  }
  {
#line 2665
  opj_read_bytes_LE(p_header_data, & (l_tcp->tccps + l_comp_no)->csty, (OPJ_UINT32 )1);
#line 2666
  p_header_data ++;
#line 2668
  __cil_tmp15 = opj_j2k_read_SPCod_SPCoc(p_j2k, l_comp_no, p_header_data, & p_header_size,
                                         p_manager);
  }
#line 2668
  if (! __cil_tmp15) {
    {
#line 2669
    opj_event_msg(p_manager, 1, "Error reading COC marker\n");
    }
#line 2670
    return (0);
  }
#line 2673
  if (p_header_size != 0U) {
    {
#line 2674
    opj_event_msg(p_manager, 1, "Error reading COC marker\n");
    }
#line 2675
    return (0);
  }
#line 2677
  return (1);
}
}
#line 2680 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_qcd_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 2686
  l_current_data = (OPJ_BYTE *)0;
#line 2693
  __cil_tmp10 = opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0);
#line 2693
  l_qcd_size = 4U + __cil_tmp10;
#line 2694
  l_remaining_size = l_qcd_size;
  }
#line 2696
  if (l_qcd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2697
    __cil_tmp12 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_qcd_size);
#line 2697
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp12;
    }
#line 2698
    if (! new_header_tile_data) {
      {
#line 2699
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2700
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2701
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2702
      opj_event_msg(p_manager, 1, "Not enough memory to write QCD marker\n");
      }
#line 2703
      return (0);
    }
#line 2705
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2706
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcd_size;
  }
  {
#line 2709
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2711
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65372, (OPJ_UINT32 )2);
#line 2712
  l_current_data += 2;
#line 2714
  opj_write_bytes_LE(l_current_data, l_qcd_size - 2U, (OPJ_UINT32 )2);
#line 2715
  l_current_data += 2;
#line 2717
  l_remaining_size -= 4U;
#line 2719
  __cil_tmp13 = opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0,
                                        l_current_data, & l_remaining_size, p_manager);
  }
#line 2719
  if (! __cil_tmp13) {
    {
#line 2720
    opj_event_msg(p_manager, 1, "Error writing QCD marker\n");
    }
#line 2721
    return (0);
  }
#line 2724
  if (l_remaining_size != 0U) {
    {
#line 2725
    opj_event_msg(p_manager, 1, "Error writing QCD marker\n");
    }
#line 2726
    return (0);
  }
  {
#line 2729
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_qcd_size, p_manager);
  }
#line 2729
  if (__cil_tmp14 != (unsigned long )l_qcd_size) {
#line 2730
    return (0);
  }
#line 2733
  return (1);
}
}
#line 2743 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 2754
  __cil_tmp8 = opj_j2k_read_SQcd_SQcc(p_j2k, (OPJ_UINT32 )0, p_header_data, & p_header_size,
                                      p_manager);
  }
#line 2754
  if (! __cil_tmp8) {
    {
#line 2755
    opj_event_msg(p_manager, 1, "Error reading QCD marker\n?\327iEV");
    }
#line 2756
    return (0);
  }
#line 2759
  if (p_header_size != 0U) {
    {
#line 2760
    opj_event_msg(p_manager, 1, "Error reading QCD marker\n<\327iEV");
    }
#line 2761
    return (0);
  }
  {
#line 2765
  opj_j2k_copy_tile_quantization_parameters(p_j2k);
  }
#line 2767
  return (1);
}
}
#line 2862 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
  {
#line 2864
  __cil_tmp2 = opj_j2k_get_max_coc_size(p_j2k);
  }
#line 2864
  return (__cil_tmp2);
}
}
#line 2874 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_num_comp ;
  OPJ_UINT32 l_comp_no ;
  OPJ_BOOL __cil_tmp10 ;

  {
#line 2887
  l_num_comp = (p_j2k->m_private_image)->numcomps;
#line 2889
  if (l_num_comp <= 256U) {
#line 2890
    if (p_header_size < 1U) {
      {
#line 2891
      opj_event_msg(p_manager, 1, "Error reading QCC marker\nY");
      }
#line 2892
      return (0);
    }
    {
#line 2894
    opj_read_bytes_LE(p_header_data, & l_comp_no, (OPJ_UINT32 )1);
#line 2895
    p_header_data ++;
#line 2896
    p_header_size --;
    }
  } else {
#line 2899
    if (p_header_size < 2U) {
      {
#line 2900
      opj_event_msg(p_manager, 1, "Error reading QCC marker\n\240");
      }
#line 2901
      return (0);
    }
    {
#line 2903
    opj_read_bytes_LE(p_header_data, & l_comp_no, (OPJ_UINT32 )2);
#line 2904
    p_header_data += 2;
#line 2905
    p_header_size -= 2U;
    }
  }
#line 2934
  if (l_comp_no >= (p_j2k->m_private_image)->numcomps) {
    {
#line 2935
    opj_event_msg(p_manager, 1, "Invalid component number: %d, regarding the number of components %d\n\002",
                  l_comp_no, (p_j2k->m_private_image)->numcomps);
    }
#line 2938
    return (0);
  }
  {
#line 2941
  __cil_tmp10 = opj_j2k_read_SQcd_SQcc(p_j2k, l_comp_no, p_header_data, & p_header_size,
                                       p_manager);
  }
#line 2941
  if (! __cil_tmp10) {
    {
#line 2942
    opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
    }
#line 2943
    return (0);
  }
#line 2946
  if (p_header_size != 0U) {
    {
#line 2947
    opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
    }
#line 2948
    return (0);
  }
#line 2951
  return (1);
}
}
#line 2954 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_poc ;
  OPJ_UINT32 l_poc_size ;
  OPJ_UINT32 l_written_size ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_poc_room ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;

  {
#line 2962
  l_written_size = (OPJ_UINT32 )0;
#line 2963
  l_tcp = (opj_tcp_t *)0;
#line 2971
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 2972
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 2973
  l_nb_poc = 1U + l_tcp->numpocs;
#line 2975
  if (l_nb_comp <= 256U) {
#line 2976
    l_poc_room = (OPJ_UINT32 )1;
  } else {
#line 2979
    l_poc_room = (OPJ_UINT32 )2;
  }
#line 2981
  l_poc_size = 4U + (5U + 2U * l_poc_room) * l_nb_poc;
#line 2983
  if (l_poc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2984
    __cil_tmp14 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_poc_size);
#line 2984
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp14;
    }
#line 2985
    if (! new_header_tile_data) {
      {
#line 2986
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2987
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2988
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2989
      opj_event_msg(p_manager, 1, "Not enough memory to write POC marker\n");
      }
#line 2990
      return (0);
    }
#line 2992
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2993
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_poc_size;
  }
  {
#line 2996
  opj_j2k_write_poc_in_memory(p_j2k, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              & l_written_size, p_manager);
#line 2998
  __cil_tmp15 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_poc_size, p_manager);
  }
#line 2998
  if (__cil_tmp15 != (unsigned long )l_poc_size) {
#line 2999
    return (0);
  }
#line 3002
  return (1);
}
}
#line 3005 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_poc ;
  OPJ_UINT32 l_poc_size ;
  opj_image_t *l_image ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_poc_t *l_current_poc ;
  OPJ_UINT32 l_poc_room ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;

  {
#line 3012
  l_current_data = (OPJ_BYTE *)0;
#line 3016
  l_image = (opj_image_t *)0;
#line 3017
  l_tcp = (opj_tcp_t *)0;
#line 3018
  l_tccp = (opj_tccp_t *)0;
#line 3019
  l_current_poc = (opj_poc_t *)0;
#line 3026
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 3027
  l_tccp = l_tcp->tccps + 0;
#line 3028
  l_image = p_j2k->m_private_image;
#line 3029
  l_nb_comp = l_image->numcomps;
#line 3030
  l_nb_poc = 1U + l_tcp->numpocs;
#line 3032
  if (l_nb_comp <= 256U) {
#line 3033
    l_poc_room = (OPJ_UINT32 )1;
  } else {
#line 3036
    l_poc_room = (OPJ_UINT32 )2;
  }
  {
#line 3039
  l_poc_size = 4U + (5U + 2U * l_poc_room) * l_nb_poc;
#line 3041
  l_current_data = p_data;
#line 3043
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65375, (OPJ_UINT32 )2);
#line 3044
  l_current_data += 2;
#line 3046
  opj_write_bytes_LE(l_current_data, l_poc_size - 2U, (OPJ_UINT32 )2);
#line 3047
  l_current_data += 2;
#line 3049
  l_current_poc = l_tcp->pocs;
#line 3050
  i = (OPJ_UINT32 )0;
  }
  {
#line 3050
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3050
    if (! (i < l_nb_poc)) {
#line 3050
      goto while_break;
    }
    {
#line 3051
    opj_write_bytes_LE(l_current_data, l_current_poc->resno0, (OPJ_UINT32 )1);
#line 3052
    l_current_data ++;
#line 3054
    opj_write_bytes_LE(l_current_data, l_current_poc->compno0, l_poc_room);
#line 3055
    l_current_data += l_poc_room;
#line 3057
    opj_write_bytes_LE(l_current_data, l_current_poc->layno1, (OPJ_UINT32 )2);
#line 3058
    l_current_data += 2;
#line 3060
    opj_write_bytes_LE(l_current_data, l_current_poc->resno1, (OPJ_UINT32 )1);
#line 3061
    l_current_data ++;
#line 3063
    opj_write_bytes_LE(l_current_data, l_current_poc->compno1, l_poc_room);
#line 3064
    l_current_data += l_poc_room;
#line 3066
    opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_current_poc->prg, (OPJ_UINT32 )1);
#line 3067
    l_current_data ++;
#line 3070
    __cil_tmp17 = opj_int_min((OPJ_INT32 )l_current_poc->layno1, (OPJ_INT32 )l_tcp->numlayers);
#line 3070
    l_current_poc->layno1 = (OPJ_UINT32 )__cil_tmp17;
#line 3071
    __cil_tmp18 = opj_int_min((OPJ_INT32 )l_current_poc->resno1, (OPJ_INT32 )l_tccp->numresolutions);
#line 3071
    l_current_poc->resno1 = (OPJ_UINT32 )__cil_tmp18;
#line 3072
    __cil_tmp19 = opj_int_min((OPJ_INT32 )l_current_poc->compno1, (OPJ_INT32 )l_nb_comp);
#line 3072
    l_current_poc->compno1 = (OPJ_UINT32 )__cil_tmp19;
#line 3074
    l_current_poc ++;
#line 3050
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 3077
  *p_data_written = l_poc_size;
#line 3078
  return;
}
}
#line 3080 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k ) 
{ 
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max_poc ;
  OPJ_UINT32 i ;

  {
#line 3082
  l_tcp = (opj_tcp_t *)0;
#line 3083
  l_nb_tiles = (OPJ_UINT32 )0;
#line 3084
  l_max_poc = (OPJ_UINT32 )0;
#line 3087
  l_tcp = p_j2k->m_cp.tcps;
#line 3088
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 3090
  i = (OPJ_UINT32 )0;
  {
#line 3090
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3090
    if (! (i < l_nb_tiles)) {
#line 3090
      goto while_break;
    }
    {
#line 3091
    l_max_poc = opj_uint_max(l_max_poc, l_tcp->numpocs);
#line 3092
    l_tcp ++;
#line 3090
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 3095
  l_max_poc ++;
#line 3097
  return (4U + 9U * l_max_poc);
}
}
#line 3100 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max ;
  opj_tcp_t *l_tcp ;

  {
#line 3104
  l_max = (OPJ_UINT32 )0;
#line 3105
  l_tcp = (opj_tcp_t *)0;
#line 3107
  l_tcp = p_j2k->m_cp.tcps;
#line 3108
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 3110
  i = (OPJ_UINT32 )0;
  {
#line 3110
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3110
    if (! (i < l_nb_tiles)) {
#line 3110
      goto while_break;
    }
    {
#line 3111
    l_max = opj_uint_max(l_max, l_tcp->m_nb_tile_parts);
#line 3113
    l_tcp ++;
#line 3110
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 3116
  return (12U * l_max);
}
}
#line 3119 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_coc_bytes ;
  OPJ_UINT32 l_qcc_bytes ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp9 ;

  {
  {
#line 3121
  l_nb_bytes = (OPJ_UINT32 )0;
#line 3125
  l_nb_comps = (p_j2k->m_private_image)->numcomps - 1U;
#line 3126
  __cil_tmp6 = opj_j2k_get_max_toc_size(p_j2k);
#line 3126
  l_nb_bytes += __cil_tmp6;
  }
#line 3128
  if ((int )p_j2k->m_cp.rsiz >= 3) {
#line 3128
    if (! ((int )p_j2k->m_cp.rsiz <= 6)) {
      {
#line 3129
      l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k);
#line 3130
      l_nb_bytes += l_nb_comps * l_coc_bytes;
#line 3132
      l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k);
#line 3133
      l_nb_bytes += l_nb_comps * l_qcc_bytes;
      }
    }
  } else {
    {
#line 3129
    l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k);
#line 3130
    l_nb_bytes += l_nb_comps * l_coc_bytes;
#line 3132
    l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k);
#line 3133
    l_nb_bytes += l_nb_comps * l_qcc_bytes;
    }
  }
  {
#line 3136
  __cil_tmp9 = opj_j2k_get_max_poc_size(p_j2k);
#line 3136
  l_nb_bytes += __cil_tmp9;
  }
#line 3140
  return (l_nb_bytes);
}
}
#line 3151 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_tmp ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_old_poc_nb ;
  OPJ_UINT32 l_current_poc_nb ;
  OPJ_UINT32 l_current_poc_remaining ;
  OPJ_UINT32 l_chunk_size ;
  OPJ_UINT32 l_comp_room ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_poc_t *l_current_poc ;
  opj_tcp_t *tmp___2 ;
  OPJ_UINT32 tmp___3 ;

  {
#line 3158
  l_image = (opj_image_t *)0;
#line 3162
  l_cp = (opj_cp_t *)0;
#line 3163
  l_tcp = (opj_tcp_t *)0;
#line 3164
  l_current_poc = (opj_poc_t *)0;
#line 3171
  l_image = p_j2k->m_private_image;
#line 3172
  l_nb_comp = l_image->numcomps;
#line 3173
  if (l_nb_comp <= 256U) {
#line 3174
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 3177
    l_comp_room = (OPJ_UINT32 )2;
  }
#line 3179
  l_chunk_size = 5U + 2U * l_comp_room;
#line 3180
  l_current_poc_nb = p_header_size / l_chunk_size;
#line 3181
  l_current_poc_remaining = p_header_size % l_chunk_size;
#line 3183
  if (l_current_poc_nb <= 0U) {
    {
#line 3184
    opj_event_msg(p_manager, 1, "Error reading POC marker\n");
    }
#line 3185
    return (0);
  } else
#line 3183
  if (l_current_poc_remaining != 0U) {
    {
#line 3184
    opj_event_msg(p_manager, 1, "Error reading POC marker\n");
    }
#line 3185
    return (0);
  }
#line 3188
  l_cp = & p_j2k->m_cp;
#line 3189
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 3189
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 3189
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 3189
  l_tcp = tmp___2;
#line 3192
  if ((int )l_tcp->POC) {
#line 3192
    tmp___3 = l_tcp->numpocs + 1U;
  } else {
#line 3192
    tmp___3 = 0U;
  }
#line 3192
  l_old_poc_nb = tmp___3;
#line 3193
  l_current_poc_nb += l_old_poc_nb;
#line 3195
  if (l_current_poc_nb >= 32U) {
    {
#line 3197
    opj_event_msg(p_manager, 1, "Too many POCs %d\n", l_current_poc_nb);
    }
#line 3198
    return (0);
  }
#line 3203
  l_tcp->POC = (OPJ_UINT32 )1;
#line 3205
  l_current_poc = & l_tcp->pocs[l_old_poc_nb];
#line 3206
  i = l_old_poc_nb;
  {
#line 3206
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3206
    if (! (i < l_current_poc_nb)) {
#line 3206
      goto while_break;
    }
    {
#line 3207
    opj_read_bytes_LE(p_header_data, & l_current_poc->resno0, (OPJ_UINT32 )1);
#line 3208
    p_header_data ++;
#line 3209
    opj_read_bytes_LE(p_header_data, & l_current_poc->compno0, l_comp_room);
#line 3210
    p_header_data += l_comp_room;
#line 3211
    opj_read_bytes_LE(p_header_data, & l_current_poc->layno1, (OPJ_UINT32 )2);
#line 3213
    l_current_poc->layno1 = opj_uint_min(l_current_poc->layno1, l_tcp->numlayers);
#line 3214
    p_header_data += 2;
#line 3215
    opj_read_bytes_LE(p_header_data, & l_current_poc->resno1, (OPJ_UINT32 )1);
#line 3216
    p_header_data ++;
#line 3217
    opj_read_bytes_LE(p_header_data, & l_current_poc->compno1, l_comp_room);
#line 3218
    p_header_data += l_comp_room;
#line 3219
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 3220
    p_header_data ++;
#line 3221
    l_current_poc->prg = (OPJ_PROG_ORDER )l_tmp;
#line 3223
    l_current_poc->compno1 = opj_uint_min(l_current_poc->compno1, l_nb_comp);
#line 3224
    l_current_poc ++;
#line 3206
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 3227
  l_tcp->numpocs = l_current_poc_nb - 1U;
#line 3228
  return (1);
}
}
#line 3239 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;

  {
#line 3251
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 3253
  if (p_header_size != l_nb_comp * 4U) {
    {
#line 3254
    opj_event_msg(p_manager, 1, "Error reading CRG marker\n\372\330iEV");
    }
#line 3255
    return (0);
  }
#line 3268
  return (1);
}
}
#line 3279 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_Ztlm ;
  OPJ_UINT32 l_Stlm ;
  OPJ_UINT32 l_ST ;
  OPJ_UINT32 l_SP ;
  OPJ_UINT32 l_tot_num_tp_remaining ;
  OPJ_UINT32 l_quotient ;
  OPJ_UINT32 l_Ptlm_size ;

  {
#line 3291
  if (p_header_size < 2U) {
    {
#line 3292
    opj_event_msg(p_manager, 1, "Error reading TLM marker\n\017\331iEV");
    }
#line 3293
    return (0);
  }
  {
#line 3295
  p_header_size -= 2U;
#line 3297
  opj_read_bytes_LE(p_header_data, & l_Ztlm, (OPJ_UINT32 )1);
#line 3298
  p_header_data ++;
#line 3299
  opj_read_bytes_LE(p_header_data, & l_Stlm, (OPJ_UINT32 )1);
#line 3300
  p_header_data ++;
#line 3302
  l_ST = (l_Stlm >> 4) & 3U;
#line 3303
  l_SP = (l_Stlm >> 6) & 1U;
#line 3305
  l_Ptlm_size = (l_SP + 1U) * 2U;
#line 3306
  l_quotient = l_Ptlm_size + l_ST;
#line 3308
  l_tot_num_tp_remaining = p_header_size % l_quotient;
  }
#line 3310
  if (l_tot_num_tp_remaining != 0U) {
    {
#line 3311
    opj_event_msg(p_manager, 1, "Error reading TLM marker\n\242\330iEV");
    }
#line 3312
    return (0);
  }
#line 3324
  return (1);
}
}
#line 3335 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 


  {
#line 3346
  if (p_header_size < 1U) {
    {
#line 3347
    opj_event_msg(p_manager, 1, "Error reading PLM marker\n.\331iEV");
    }
#line 3348
    return (0);
  }
#line 3394
  return (1);
}
}
#line 3405 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_Zplt ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_packet_len ;
  OPJ_UINT32 i ;

  {
#line 3411
  l_packet_len = (OPJ_UINT32 )0;
#line 3418
  if (p_header_size < 1U) {
    {
#line 3419
    opj_event_msg(p_manager, 1, "Error reading PLT marker\n");
    }
#line 3420
    return (0);
  }
  {
#line 3423
  opj_read_bytes_LE(p_header_data, & l_Zplt, (OPJ_UINT32 )1);
#line 3424
  p_header_data ++;
#line 3425
  p_header_size --;
#line 3427
  i = (OPJ_UINT32 )0;
  }
  {
#line 3427
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3427
    if (! (i < p_header_size)) {
#line 3427
      goto while_break;
    }
    {
#line 3428
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 3429
    p_header_data ++;
#line 3431
    l_packet_len |= l_tmp & 127U;
    }
#line 3432
    if (l_tmp & 128U) {
#line 3433
      l_packet_len <<= 7;
    } else {
#line 3437
      l_packet_len = (OPJ_UINT32 )0;
    }
#line 3427
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 3441
  if (l_packet_len != 0U) {
    {
#line 3442
    opj_event_msg(p_manager, 1, "Error reading PLT marker\n");
    }
#line 3443
    return (0);
  }
#line 3446
  return (1);
}
}
#line 3552 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL j2k_read_ppm_v3(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                         struct opj_event_mgr *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  OPJ_UINT32 l_remaining_data ;
  OPJ_UINT32 l_Z_ppm ;
  OPJ_UINT32 l_N_ppm ;
  void *__cil_tmp12 ;
  OPJ_BYTE *new_ppm_data ;
  void *__cil_tmp15 ;
  OPJ_BYTE *new_ppm_data___0 ;
  void *__cil_tmp18 ;
  OPJ_BYTE *new_ppm_data___1 ;
  void *__cil_tmp21 ;

  {
#line 3559
  l_cp = (opj_cp_t *)0;
#line 3568
  if (p_header_size < 1U) {
    {
#line 3569
    opj_event_msg(p_manager, 1, "Error reading PPM marker\n");
    }
#line 3570
    return (0);
  }
  {
#line 3573
  l_cp = & p_j2k->m_cp;
#line 3574
  l_cp->ppm = (OPJ_UINT32 )1;
#line 3576
  opj_read_bytes_LE(p_header_data, & l_Z_ppm, (OPJ_UINT32 )1);
#line 3577
  p_header_data ++;
#line 3578
  p_header_size --;
  }
#line 3581
  if (l_Z_ppm == 0U) {
#line 3582
    if ((unsigned long )l_cp->ppm_data != (unsigned long )((void *)0)) {
      {
#line 3583
      opj_event_msg(p_manager, 1, "Zppm O already processed. Found twice.\n");
#line 3584
      free((void *)l_cp->ppm_data);
#line 3585
      l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3586
      l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3587
      l_cp->ppm = (OPJ_UINT32 )0;
      }
#line 3588
      return (0);
    }
#line 3591
    if (p_header_size < 4U) {
      {
#line 3592
      opj_event_msg(p_manager, 1, "Error reading PPM marker\n");
      }
#line 3593
      return (0);
    }
    {
#line 3596
    opj_read_bytes_LE(p_header_data, & l_N_ppm, (OPJ_UINT32 )4);
#line 3597
    p_header_data += 4;
#line 3598
    p_header_size -= 4U;
    }
#line 3601
    if (p_header_size < l_N_ppm) {
      {
#line 3603
      opj_event_msg(p_manager, 1, "Not enough bytes (%u) to hold Ippm series (%u), Index (%d)\n",
                    p_header_size, l_N_ppm, l_Z_ppm);
#line 3604
      free((void *)l_cp->ppm_data);
#line 3605
      l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3606
      l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3607
      l_cp->ppm = (OPJ_UINT32 )0;
      }
#line 3608
      return (0);
    }
    {
#line 3612
    l_cp->ppm_len = l_N_ppm;
#line 3613
    l_cp->ppm_data_read = (OPJ_UINT32 )0;
#line 3615
    __cil_tmp12 = calloc(1UL, (unsigned long )l_cp->ppm_len);
#line 3615
    l_cp->ppm_data = (OPJ_BYTE *)__cil_tmp12;
#line 3616
    l_cp->ppm_buffer = l_cp->ppm_data;
    }
#line 3617
    if ((unsigned long )l_cp->ppm_data == (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 3618
      opj_event_msg(p_manager, 1, "Not enough memory to read ppm marker\n");
      }
#line 3619
      return (0);
    }
#line 3622
    l_cp->ppm_data_current = l_cp->ppm_data;
  } else
#line 3627
  if (p_header_size < 4U) {
    {
#line 3628
    opj_event_msg(p_manager, 2, "Empty PPM marker\n");
    }
#line 3629
    return (1);
  } else
#line 3633
  if (l_cp->ppm_data_read < l_cp->ppm_len) {
#line 3635
    l_cp->ppm_data_current = l_cp->ppm_data + l_cp->ppm_data_read;
#line 3636
    l_N_ppm = l_cp->ppm_len - l_cp->ppm_data_read;
  } else {
    {
#line 3640
    opj_read_bytes_LE(p_header_data, & l_N_ppm, (OPJ_UINT32 )4);
#line 3641
    p_header_data += 4;
#line 3642
    p_header_size -= 4U;
    }
#line 3645
    if (p_header_size < l_N_ppm) {
      {
#line 3647
      opj_event_msg(p_manager, 1, "Not enough bytes (%u) to hold Ippm series (%u), Index (%d)\n",
                    p_header_size, l_N_ppm, l_Z_ppm);
#line 3648
      free((void *)l_cp->ppm_data);
#line 3649
      l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3650
      l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3651
      l_cp->ppm = (OPJ_UINT32 )0;
      }
#line 3652
      return (0);
    }
    {
#line 3656
    __cil_tmp15 = realloc((void *)l_cp->ppm_data, (unsigned long )(l_cp->ppm_len + l_N_ppm));
#line 3656
    new_ppm_data = (OPJ_BYTE *)__cil_tmp15;
    }
#line 3657
    if (! new_ppm_data) {
      {
#line 3658
      free((void *)l_cp->ppm_data);
#line 3659
      l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3660
      l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3661
      l_cp->ppm_len = (OPJ_UINT32 )0;
#line 3662
      opj_event_msg(p_manager, 1, "Not enough memory to increase the size of ppm_data to add the new Ippm series\n");
      }
#line 3663
      return (0);
    }
#line 3665
    l_cp->ppm_data = new_ppm_data;
#line 3666
    l_cp->ppm_buffer = l_cp->ppm_data;
#line 3669
    l_cp->ppm_data_current = l_cp->ppm_data + l_cp->ppm_len;
#line 3670
    l_cp->ppm_len += l_N_ppm;
  }
#line 3675
  l_remaining_data = p_header_size;
  {
#line 3677
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3677
    if (! (l_remaining_data >= l_N_ppm)) {
#line 3677
      goto while_break;
    }
    {
#line 3679
    memcpy((void *)l_cp->ppm_data_current, (void const   *)p_header_data, (unsigned long )l_N_ppm);
#line 3680
    p_header_size -= l_N_ppm;
#line 3681
    p_header_data += l_N_ppm;
#line 3683
    l_cp->ppm_data_read += l_N_ppm;
    }
#line 3685
    if (p_header_size) {
#line 3687
      if (p_header_size < 4U) {
        {
#line 3688
        free((void *)l_cp->ppm_data);
#line 3689
        l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3690
        l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3691
        l_cp->ppm_len = (OPJ_UINT32 )0;
#line 3692
        l_cp->ppm = (OPJ_UINT32 )0;
#line 3693
        opj_event_msg(p_manager, 1, "Error reading PPM marker\n");
        }
#line 3694
        return (0);
      }
      {
#line 3696
      opj_read_bytes_LE(p_header_data, & l_N_ppm, (OPJ_UINT32 )4);
#line 3697
      p_header_data += 4;
#line 3698
      p_header_size -= 4U;
      }
    } else {
#line 3701
      l_remaining_data = p_header_size;
#line 3702
      goto while_break;
    }
#line 3705
    l_remaining_data = p_header_size;
#line 3708
    if (l_remaining_data >= l_N_ppm) {
#line 3713
      if (l_cp->ppm_len + l_N_ppm < l_N_ppm) {
        {
#line 3714
        free((void *)l_cp->ppm_data);
#line 3715
        l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3716
        l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3717
        l_cp->ppm_len = (OPJ_UINT32 )0;
#line 3718
        opj_event_msg(p_manager, 1, "Not enough memory to increase the size of ppm_data to add the new (complete) Ippm series\n");
        }
#line 3719
        return (0);
      }
      {
#line 3721
      __cil_tmp18 = realloc((void *)l_cp->ppm_data, (unsigned long )(l_cp->ppm_len + l_N_ppm));
#line 3721
      new_ppm_data___0 = (OPJ_BYTE *)__cil_tmp18;
      }
#line 3722
      if (! new_ppm_data___0) {
        {
#line 3723
        free((void *)l_cp->ppm_data);
#line 3724
        l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3725
        l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3726
        l_cp->ppm_len = (OPJ_UINT32 )0;
#line 3727
        opj_event_msg(p_manager, 1, "Not enough memory to increase the size of ppm_data to add the new (complete) Ippm series\n");
        }
#line 3728
        return (0);
      }
#line 3730
      l_cp->ppm_data = new_ppm_data___0;
#line 3731
      l_cp->ppm_buffer = l_cp->ppm_data;
#line 3734
      l_cp->ppm_data_current = l_cp->ppm_data + l_cp->ppm_len;
#line 3735
      l_cp->ppm_len += l_N_ppm;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 3741
  if (l_remaining_data) {
#line 3746
    if (l_cp->ppm_len + l_N_ppm < l_N_ppm) {
      {
#line 3747
      free((void *)l_cp->ppm_data);
#line 3748
      l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3749
      l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3750
      l_cp->ppm_len = (OPJ_UINT32 )0;
#line 3751
      opj_event_msg(p_manager, 1, "Not enough memory to increase the size of ppm_data to add the new (complete) Ippm series\n");
      }
#line 3752
      return (0);
    }
    {
#line 3754
    __cil_tmp21 = realloc((void *)l_cp->ppm_data, (unsigned long )(l_cp->ppm_len + l_N_ppm));
#line 3754
    new_ppm_data___1 = (OPJ_BYTE *)__cil_tmp21;
    }
#line 3755
    if (! new_ppm_data___1) {
      {
#line 3756
      free((void *)l_cp->ppm_data);
#line 3757
      l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3758
      l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3759
      l_cp->ppm_len = (OPJ_UINT32 )0;
#line 3760
      opj_event_msg(p_manager, 1, "Not enough memory to increase the size of ppm_data to add the new (incomplete) Ippm series\n");
      }
#line 3761
      return (0);
    }
    {
#line 3763
    l_cp->ppm_data = new_ppm_data___1;
#line 3764
    l_cp->ppm_buffer = l_cp->ppm_data;
#line 3767
    l_cp->ppm_data_current = l_cp->ppm_data + l_cp->ppm_len;
#line 3768
    l_cp->ppm_len += l_N_ppm;
#line 3771
    memcpy((void *)l_cp->ppm_data_current, (void const   *)p_header_data, (unsigned long )l_remaining_data);
#line 3772
    p_header_size -= l_remaining_data;
#line 3773
    p_header_data += l_remaining_data;
#line 3775
    l_cp->ppm_data_read += l_remaining_data;
    }
  }
#line 3824
  return (1);
}
}
#line 3835 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_Z_ppt ;
  void *__cil_tmp11 ;
  OPJ_BYTE *new_ppt_buffer ;
  void *__cil_tmp13 ;

  {
#line 3841
  l_cp = (opj_cp_t *)0;
#line 3842
  l_tcp = (opj_tcp_t *)0;
#line 3851
  if (p_header_size < 1U) {
    {
#line 3852
    opj_event_msg(p_manager, 1, "Error reading PPT marker\n");
    }
#line 3853
    return (0);
  }
#line 3856
  l_cp = & p_j2k->m_cp;
#line 3857
  if (l_cp->ppm) {
    {
#line 3858
    opj_event_msg(p_manager, 1, "Error reading PPT marker: packet header have been previously found in the main header (PPM marker).\nEV");
    }
#line 3859
    return (0);
  }
  {
#line 3862
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 3863
  l_tcp->ppt = (OPJ_UINT32 )1;
#line 3865
  opj_read_bytes_LE(p_header_data, & l_Z_ppt, (OPJ_UINT32 )1);
#line 3866
  p_header_data ++;
#line 3867
  p_header_size --;
  }
#line 3870
  if (l_Z_ppt == 0U) {
    {
#line 3872
    l_tcp->ppt_data_size = (OPJ_UINT32 )0;
#line 3873
    l_tcp->ppt_len = p_header_size;
#line 3875
    free((void *)l_tcp->ppt_buffer);
#line 3876
    __cil_tmp11 = calloc((unsigned long )l_tcp->ppt_len, sizeof(OPJ_BYTE ));
#line 3876
    l_tcp->ppt_buffer = (OPJ_BYTE *)__cil_tmp11;
    }
#line 3877
    if ((unsigned long )l_tcp->ppt_buffer == (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 3878
      opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\nV");
      }
#line 3879
      return (0);
    }
#line 3881
    l_tcp->ppt_data = l_tcp->ppt_buffer;
  } else {
    {
#line 3887
    l_tcp->ppt_len += p_header_size;
#line 3889
    __cil_tmp13 = realloc((void *)l_tcp->ppt_buffer, (unsigned long )l_tcp->ppt_len);
#line 3889
    new_ppt_buffer = (OPJ_BYTE *)__cil_tmp13;
    }
#line 3890
    if (! new_ppt_buffer) {
      {
#line 3891
      free((void *)l_tcp->ppt_buffer);
#line 3892
      l_tcp->ppt_buffer = (OPJ_BYTE *)((void *)0);
#line 3893
      l_tcp->ppt_len = (OPJ_UINT32 )0;
#line 3894
      opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\n");
      }
#line 3895
      return (0);
    }
    {
#line 3897
    l_tcp->ppt_buffer = new_ppt_buffer;
#line 3898
    l_tcp->ppt_data = l_tcp->ppt_buffer;
#line 3900
    memset((void *)(l_tcp->ppt_buffer + l_tcp->ppt_data_size), 0, (unsigned long )p_header_size);
    }
  }
  {
#line 3904
  memcpy((void *)(l_tcp->ppt_buffer + l_tcp->ppt_data_size), (void const   *)p_header_data,
         (unsigned long )p_header_size);
#line 3906
  l_tcp->ppt_data_size += p_header_size;
  }
#line 3908
  return (1);
}
}
#line 3911 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tlm_size ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp12 ;

  {
#line 3916
  l_current_data = (OPJ_BYTE *)0;
#line 3924
  l_tlm_size = 6U + 5U * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;
#line 3926
  if (l_tlm_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 3927
    __cil_tmp10 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_tlm_size);
#line 3927
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp10;
    }
#line 3928
    if (! new_header_tile_data) {
      {
#line 3929
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 3930
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 3931
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 3932
      opj_event_msg(p_manager, 1, "Not enough memory to write TLM marker\n");
      }
#line 3933
      return (0);
    }
#line 3935
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 3936
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_tlm_size;
  }
  {
#line 3939
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 3943
  p_j2k->m_specific_param.m_encoder.m_tlm_start = opj_stream_tell(p_stream);
#line 3945
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65365, (OPJ_UINT32 )2);
#line 3946
  l_current_data += 2;
#line 3948
  opj_write_bytes_LE(l_current_data, l_tlm_size - 2U, (OPJ_UINT32 )2);
#line 3949
  l_current_data += 2;
#line 3951
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 3952
  l_current_data ++;
#line 3954
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )80, (OPJ_UINT32 )1);
#line 3955
  l_current_data ++;
#line 3958
  __cil_tmp12 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_tlm_size, p_manager);
  }
#line 3958
  if (__cil_tmp12 != (unsigned long )l_tlm_size) {
#line 3959
    return (0);
  }
#line 3962
  return (1);
}
}
#line 3965 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                           opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 


  {
  {
#line 3977
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )65424, (OPJ_UINT32 )2);
#line 3978
  p_data += 2;
#line 3980
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )10, (OPJ_UINT32 )2);
#line 3981
  p_data += 2;
#line 3983
  opj_write_bytes_LE(p_data, p_j2k->m_current_tile_number, (OPJ_UINT32 )2);
#line 3984
  p_data += 2;
#line 3987
  p_data += 4;
#line 3989
  opj_write_bytes_LE(p_data, p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,
                     (OPJ_UINT32 )1);
#line 3990
  p_data ++;
#line 3992
  opj_write_bytes_LE(p_data, (p_j2k->m_cp.tcps + p_j2k->m_current_tile_number)->m_nb_tile_parts,
                     (OPJ_UINT32 )1);
#line 3993
  p_data ++;
#line 4004
  *p_data_written = (OPJ_UINT32 )12;
  }
#line 4006
  return (1);
}
}
#line 4009 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                          opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_tot_len ;
  OPJ_UINT32 l_num_parts ;
  OPJ_UINT32 l_current_part ;
  OPJ_UINT32 l_tile_x ;
  OPJ_UINT32 l_tile_y ;
  void *__cil_tmp17 ;
  opj_tp_index_t *new_tp_index ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  opj_tp_index_t *new_tp_index___0 ;
  void *__cil_tmp22 ;
  int tmp___4 ;

  {
#line 4014
  l_cp = (opj_cp_t *)0;
#line 4015
  l_tcp = (opj_tcp_t *)0;
#line 4016
  l_num_parts = (OPJ_UINT32 )0;
#line 4026
  if (p_header_size != 8U) {
    {
#line 4027
    opj_event_msg(p_manager, 1, "Error reading SOT marker\n");
    }
#line 4028
    return (0);
  }
  {
#line 4031
  l_cp = & p_j2k->m_cp;
#line 4032
  opj_read_bytes_LE(p_header_data, & p_j2k->m_current_tile_number, (OPJ_UINT32 )2);
#line 4033
  p_header_data += 2;
  }
#line 4036
  if (p_j2k->m_current_tile_number >= l_cp->tw * l_cp->th) {
    {
#line 4037
    opj_event_msg(p_manager, 1, "Invalid tile number %d\n", p_j2k->m_current_tile_number);
    }
#line 4038
    return (0);
  }
  {
#line 4041
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 4042
  l_tile_x = p_j2k->m_current_tile_number % l_cp->tw;
#line 4043
  l_tile_y = p_j2k->m_current_tile_number / l_cp->tw;
#line 4076
  opj_read_bytes_LE(p_header_data, & l_tot_len, (OPJ_UINT32 )4);
#line 4077
  p_header_data += 4;
  }
#line 4080
  if (l_tot_len != 0U) {
#line 4080
    if (l_tot_len < 14U) {
#line 4082
      if (l_tot_len == 12U) {
        {
#line 4084
        opj_event_msg(p_manager, 2, "Empty SOT marker detected: Psot=%d.\n", l_tot_len);
        }
      } else {
        {
#line 4088
        opj_event_msg(p_manager, 1, "Psot value is not correct regards to the JPEG2000 norm: %d.\n",
                      l_tot_len);
        }
#line 4089
        return (0);
      }
    }
  }
#line 4115
  if (! l_tot_len) {
    {
#line 4116
    opj_event_msg(p_manager, 4, "Psot value of the current tile-part is equal to zero, we assuming it is the last tile-part of the codestream.\n");
#line 4118
    p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
    }
  }
  {
#line 4121
  opj_read_bytes_LE(p_header_data, & l_current_part, (OPJ_UINT32 )1);
#line 4122
  p_header_data ++;
#line 4124
  opj_read_bytes_LE(p_header_data, & l_num_parts, (OPJ_UINT32 )1);
#line 4125
  p_header_data ++;
  }
#line 4127
  if (l_num_parts != 0U) {
#line 4130
    if (l_tcp->m_nb_tile_parts) {
#line 4131
      if (l_current_part >= l_tcp->m_nb_tile_parts) {
        {
#line 4132
        opj_event_msg(p_manager, 1, "In SOT marker, TPSot (%d) is not valid regards to the current number of tile-part (%d), giving up\n",
                      l_current_part, l_tcp->m_nb_tile_parts);
#line 4134
        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
        }
#line 4135
        return (0);
      }
    }
#line 4138
    if (l_current_part >= l_num_parts) {
      {
#line 4140
      opj_event_msg(p_manager, 1, "In SOT marker, TPSot (%d) is not valid regards to the current number of tile-part (header) (%d), giving up\n",
                    l_current_part, l_num_parts);
#line 4142
      p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
      }
#line 4143
      return (0);
    }
#line 4145
    l_tcp->m_nb_tile_parts = l_num_parts;
  }
#line 4149
  if (l_tcp->m_nb_tile_parts) {
#line 4150
    if (l_tcp->m_nb_tile_parts == l_current_part + 1U) {
#line 4151
      p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_UINT32 )1;
    }
  }
#line 4155
  if (! p_j2k->m_specific_param.m_decoder.m_last_tile_part) {
#line 4157
    p_j2k->m_specific_param.m_decoder.m_sot_length = l_tot_len - 12U;
  } else {
#line 4161
    p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32 )0;
  }
#line 4164
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )16;
#line 4167
  if (p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec == -1) {
#line 4168
    if (l_tile_x < p_j2k->m_specific_param.m_decoder.m_start_tile_x) {
#line 4168
      tmp___4 = 1;
    } else
#line 4168
    if (l_tile_x >= p_j2k->m_specific_param.m_decoder.m_end_tile_x) {
#line 4168
      tmp___4 = 1;
    } else
#line 4168
    if (l_tile_y < p_j2k->m_specific_param.m_decoder.m_start_tile_y) {
#line 4168
      tmp___4 = 1;
    } else
#line 4168
    if (l_tile_y >= p_j2k->m_specific_param.m_decoder.m_end_tile_y) {
#line 4168
      tmp___4 = 1;
    } else {
#line 4168
      tmp___4 = 0;
    }
#line 4168
    p_j2k->m_specific_param.m_decoder.m_skip_data = (OPJ_UINT32 )tmp___4;
  } else {
#line 4176
    p_j2k->m_specific_param.m_decoder.m_skip_data = (OPJ_UINT32 )(p_j2k->m_current_tile_number != (OPJ_UINT32 )p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec);
  }
#line 4181
  if (p_j2k->cstr_index) {
#line 4184
    ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tileno = p_j2k->m_current_tile_number;
#line 4185
    ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_tpsno = l_current_part;
#line 4187
    if (l_num_parts != 0U) {
#line 4188
      ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->nb_tps = l_num_parts;
#line 4189
      ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = l_num_parts;
#line 4191
      if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
        {
#line 4192
        __cil_tmp17 = calloc((unsigned long )l_num_parts, sizeof(opj_tp_index_t ));
#line 4192
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)__cil_tmp17;
        }
#line 4194
        if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
          {
#line 4195
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4196
          return (0);
        }
      } else {
        {
#line 4200
        __cil_tmp19 = realloc((void *)((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index,
                              (unsigned long )l_num_parts * sizeof(opj_tp_index_t ));
#line 4200
        new_tp_index = (opj_tp_index_t *)__cil_tmp19;
        }
#line 4202
        if (! new_tp_index) {
          {
#line 4203
          free((void *)((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index);
#line 4204
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)((void *)0);
#line 4205
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4206
          return (0);
        }
#line 4208
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = new_tp_index;
      }
    } else {
#line 4214
      if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
        {
#line 4215
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )10;
#line 4216
        __cil_tmp20 = calloc((unsigned long )((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps,
                             sizeof(opj_tp_index_t ));
#line 4216
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)__cil_tmp20;
        }
#line 4219
        if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
          {
#line 4220
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )0;
#line 4221
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4222
          return (0);
        }
      }
#line 4226
      if (l_current_part >= ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps) {
        {
#line 4228
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = l_current_part + 1U;
#line 4229
        __cil_tmp22 = realloc((void *)((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index,
                              (unsigned long )((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps * sizeof(opj_tp_index_t ));
#line 4229
        new_tp_index___0 = (opj_tp_index_t *)__cil_tmp22;
        }
#line 4232
        if (! new_tp_index___0) {
          {
#line 4233
          free((void *)((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index);
#line 4234
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)((void *)0);
#line 4235
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )0;
#line 4236
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4237
          return (0);
        }
#line 4239
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = new_tp_index___0;
      }
    }
  }
#line 4274
  return (1);
}
}
#line 4277 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k , opj_tcd_t *p_tile_coder , OPJ_BYTE *p_data ,
                           OPJ_UINT32 *p_data_written , OPJ_UINT32 p_total_data_size ,
                           opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  opj_codestream_info_t *l_cstr_info ;
  OPJ_UINT32 l_remaining_data ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 4286
  l_cstr_info = (opj_codestream_info_t *)0;
#line 4294
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )65427, (OPJ_UINT32 )2);
#line 4295
  p_data += 2;
#line 4298
  l_remaining_data = p_total_data_size - 4U;
#line 4301
  p_tile_coder->tp_num = p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number;
#line 4302
  p_tile_coder->cur_tp_num = p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
  }
#line 4332
  if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0U) {
#line 4333
    ((p_tile_coder->tcd_image)->tiles)->packno = (OPJ_UINT32 )0;
#line 4334
    if (l_cstr_info) {
#line 4335
      l_cstr_info->packno = 0;
    }
  }
  {
#line 4339
  *p_data_written = (OPJ_UINT32 )0;
#line 4341
  __cil_tmp13 = opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data,
                                    p_data_written, l_remaining_data, l_cstr_info);
  }
#line 4341
  if (! __cil_tmp13) {
    {
#line 4342
    opj_event_msg(p_manager, 1, "Cannot encode tile\niEV");
    }
#line 4343
    return (0);
  }
#line 4346
  *p_data_written += 2U;
#line 4348
  return (1);
}
}
#line 4351 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_SIZE_T l_current_read_size ;
  opj_codestream_index_t *l_cstr_index ;
  OPJ_BYTE **l_current_data ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 *l_tile_len ;
  OPJ_BOOL l_sot_length_pb_detected ;
  OPJ_OFF_T __cil_tmp13 ;
  OPJ_OFF_T __cil_tmp14 ;
  void *__cil_tmp15 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp17 ;
  OPJ_OFF_T l_current_pos ;
  OPJ_OFF_T __cil_tmp19 ;
  OPJ_UINT32 l_current_tile_part ;
  OPJ_BOOL __cil_tmp21 ;

  {
#line 4357
  l_cstr_index = (opj_codestream_index_t *)0;
#line 4358
  l_current_data = (OPJ_BYTE **)0;
#line 4359
  l_tcp = (opj_tcp_t *)0;
#line 4360
  l_tile_len = (OPJ_UINT32 *)0;
#line 4361
  l_sot_length_pb_detected = 0;
#line 4368
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 4370
  if (p_j2k->m_specific_param.m_decoder.m_last_tile_part) {
    {
#line 4375
    __cil_tmp13 = opj_stream_get_number_byte_left(p_stream);
#line 4375
    p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32 )(__cil_tmp13 - 2L);
    }
  } else
#line 4379
  if (p_j2k->m_specific_param.m_decoder.m_sot_length >= 2U) {
#line 4380
    p_j2k->m_specific_param.m_decoder.m_sot_length -= 2U;
  }
#line 4386
  l_current_data = & l_tcp->m_data;
#line 4387
  l_tile_len = & l_tcp->m_data_size;
#line 4390
  if (p_j2k->m_specific_param.m_decoder.m_sot_length) {
    {
#line 4393
    __cil_tmp14 = opj_stream_get_number_byte_left(p_stream);
    }
#line 4393
    if ((OPJ_OFF_T )p_j2k->m_specific_param.m_decoder.m_sot_length > __cil_tmp14) {
      {
#line 4394
      opj_event_msg(p_manager, 1, "Tile part length size inconsistent with stream length\n");
      }
#line 4395
      return (0);
    }
#line 4397
    if (! *l_current_data) {
      {
#line 4401
      __cil_tmp15 = malloc((unsigned long )p_j2k->m_specific_param.m_decoder.m_sot_length);
#line 4401
      *l_current_data = (OPJ_BYTE *)__cil_tmp15;
      }
    } else {
      {
#line 4404
      __cil_tmp17 = realloc((void *)*l_current_data, (unsigned long )(*l_tile_len + p_j2k->m_specific_param.m_decoder.m_sot_length));
#line 4404
      l_new_current_data = (OPJ_BYTE *)__cil_tmp17;
      }
#line 4405
      if (! l_new_current_data) {
        {
#line 4406
        free((void *)*l_current_data);
        }
      }
#line 4412
      *l_current_data = l_new_current_data;
    }
#line 4415
    if ((unsigned long )*l_current_data == (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 4416
      opj_event_msg(p_manager, 1, "Not enough memory to decode tile\n\266\333iEV");
      }
#line 4417
      return (0);
    }
  } else {
#line 4421
    l_sot_length_pb_detected = 1;
  }
#line 4425
  l_cstr_index = p_j2k->cstr_index;
#line 4426
  if (l_cstr_index) {
    {
#line 4427
    __cil_tmp19 = opj_stream_tell(p_stream);
#line 4427
    l_current_pos = __cil_tmp19 - 2L;
#line 4429
    l_current_tile_part = (l_cstr_index->tile_index + p_j2k->m_current_tile_number)->current_tpsno;
#line 4430
    ((l_cstr_index->tile_index + p_j2k->m_current_tile_number)->tp_index + l_current_tile_part)->end_header = l_current_pos;
#line 4432
    ((l_cstr_index->tile_index + p_j2k->m_current_tile_number)->tp_index + l_current_tile_part)->end_pos = (l_current_pos + (long )p_j2k->m_specific_param.m_decoder.m_sot_length) + 2L;
#line 4435
    __cil_tmp21 = opj_j2k_add_tlmarker(p_j2k->m_current_tile_number, l_cstr_index,
                                       (OPJ_UINT32 )65427, l_current_pos, p_j2k->m_specific_param.m_decoder.m_sot_length + 2U);
    }
#line 4435
    if (0 == __cil_tmp21) {
      {
#line 4440
      opj_event_msg(p_manager, 1, "Not enough memory to add tl marker\niEV");
      }
#line 4441
      return (0);
    }
  }
#line 4448
  if (! l_sot_length_pb_detected) {
    {
#line 4449
    l_current_read_size = opj_stream_read_data(p_stream, *l_current_data + *l_tile_len,
                                               (OPJ_SIZE_T )p_j2k->m_specific_param.m_decoder.m_sot_length,
                                               p_manager);
    }
  } else {
#line 4457
    l_current_read_size = (OPJ_SIZE_T )0;
  }
#line 4460
  if (l_current_read_size != (unsigned long )p_j2k->m_specific_param.m_decoder.m_sot_length) {
#line 4461
    p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
  } else {
#line 4464
    p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
  }
#line 4467
  *l_tile_len += (OPJ_UINT32 )l_current_read_size;
#line 4469
  return (1);
}
}
#line 4472 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                           OPJ_UINT32 nb_comps , opj_stream_private_t *p_stream ,
                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_rgn_size ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 l_comp_room ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
#line 4480
  l_current_data = (OPJ_BYTE *)0;
#line 4482
  l_cp = (opj_cp_t *)0;
#line 4483
  l_tcp = (opj_tcp_t *)0;
#line 4484
  l_tccp = (opj_tccp_t *)0;
#line 4492
  l_cp = & p_j2k->m_cp;
#line 4493
  l_tcp = l_cp->tcps + p_tile_no;
#line 4494
  l_tccp = l_tcp->tccps + p_comp_no;
#line 4496
  if (nb_comps <= 256U) {
#line 4497
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 4500
    l_comp_room = (OPJ_UINT32 )2;
  }
  {
#line 4503
  l_rgn_size = 6U + l_comp_room;
#line 4505
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 4507
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65374, (OPJ_UINT32 )2);
#line 4508
  l_current_data += 2;
#line 4510
  opj_write_bytes_LE(l_current_data, l_rgn_size - 2U, (OPJ_UINT32 )2);
#line 4511
  l_current_data += 2;
#line 4513
  opj_write_bytes_LE(l_current_data, p_comp_no, l_comp_room);
#line 4514
  l_current_data += l_comp_room;
#line 4516
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 4517
  l_current_data ++;
#line 4519
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_tccp->roishift, (OPJ_UINT32 )1);
#line 4520
  l_current_data ++;
#line 4522
  __cil_tmp16 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_rgn_size, p_manager);
  }
#line 4522
  if (__cil_tmp16 != (unsigned long )l_rgn_size) {
#line 4523
    return (0);
  }
#line 4526
  return (1);
}
}
#line 4529 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_SIZE_T __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 4539
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (OPJ_UINT32 )65497,
                     (OPJ_UINT32 )2);
#line 4549
  __cil_tmp7 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                     (OPJ_SIZE_T )2, p_manager);
  }
#line 4549
  if (__cil_tmp7 != 2UL) {
#line 4550
    return (0);
  }
  {
#line 4553
  __cil_tmp8 = opj_stream_flush(p_stream, p_manager);
  }
#line 4553
  if (! __cil_tmp8) {
#line 4554
    return (0);
  }
#line 4557
  return (1);
}
}
#line 4568 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_comp_room ;
  OPJ_UINT32 l_comp_no ;
  OPJ_UINT32 l_roi_sty ;
  opj_tcp_t *tmp___2 ;

  {
#line 4575
  l_image = (opj_image_t *)0;
#line 4577
  l_cp = (opj_cp_t *)0;
#line 4578
  l_tcp = (opj_tcp_t *)0;
#line 4586
  l_image = p_j2k->m_private_image;
#line 4587
  l_nb_comp = l_image->numcomps;
#line 4589
  if (l_nb_comp <= 256U) {
#line 4590
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 4592
    l_comp_room = (OPJ_UINT32 )2;
  }
#line 4594
  if (p_header_size != 2U + l_comp_room) {
    {
#line 4595
    opj_event_msg(p_manager, 1, "Error reading RGN marker\n");
    }
#line 4596
    return (0);
  }
#line 4599
  l_cp = & p_j2k->m_cp;
#line 4600
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 4600
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 4600
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
  {
#line 4600
  l_tcp = tmp___2;
#line 4604
  opj_read_bytes_LE(p_header_data, & l_comp_no, l_comp_room);
#line 4605
  p_header_data += l_comp_room;
#line 4606
  opj_read_bytes_LE(p_header_data, & l_roi_sty, (OPJ_UINT32 )1);
#line 4607
  p_header_data ++;
  }
#line 4625
  if (l_comp_no >= l_nb_comp) {
    {
#line 4626
    opj_event_msg(p_manager, 1, "bad component number in RGN (%d when there are only %d)\n\230\001",
                  l_comp_no, l_nb_comp);
    }
#line 4629
    return (0);
  }
  {
#line 4632
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& (l_tcp->tccps + l_comp_no)->roishift),
                    (OPJ_UINT32 )1);
#line 4633
  p_header_data ++;
  }
#line 4635
  return (1);
}
}
#line 4639 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t *p_tcp ) 
{ 


  {
#line 4641
  return ((OPJ_FLOAT32 )((p_tcp->m_nb_tile_parts - 1U) * 14U));
}
}
#line 4644 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t *p_tcp ) 
{ 


  {
#line 4647
  return ((OPJ_FLOAT32 )0);
}
}
#line 4650 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_image_t *l_image ;
  opj_tcp_t *l_tcp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 l_x0 ;
  OPJ_INT32 l_y0 ;
  OPJ_INT32 l_x1 ;
  OPJ_INT32 l_y1 ;
  OPJ_FLOAT32 *l_rates ;
  OPJ_FLOAT32 l_sot_remove ;
  OPJ_UINT32 l_bits_empty ;
  OPJ_UINT32 l_size_pixel ;
  OPJ_UINT32 l_tile_size ;
  OPJ_UINT32 l_last_res ;
  OPJ_FLOAT32 (*l_tp_stride_func)(opj_tcp_t * ) ;
  OPJ_OFF_T __cil_tmp25 ;
  OPJ_FLOAT32 l_offset ;
  OPJ_FLOAT32 __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;

  {
  {
#line 4654
  l_cp = (opj_cp_t *)0;
#line 4655
  l_image = (opj_image_t *)0;
#line 4656
  l_tcp = (opj_tcp_t *)0;
#line 4657
  l_img_comp = (opj_image_comp_t *)0;
#line 4661
  l_rates = (OPJ_FLOAT32 *)0;
#line 4664
  l_tile_size = (OPJ_UINT32 )0;
#line 4666
  l_tp_stride_func = (OPJ_FLOAT32 (*)(opj_tcp_t * ))0;
#line 4673
  l_cp = & p_j2k->m_cp;
#line 4674
  l_image = p_j2k->m_private_image;
#line 4675
  l_tcp = l_cp->tcps;
#line 4677
  l_bits_empty = (8U * (l_image->comps)->dx) * (l_image->comps)->dy;
#line 4678
  l_size_pixel = l_image->numcomps * (l_image->comps)->prec;
#line 4679
  __cil_tmp25 = opj_stream_tell(p_stream);
#line 4679
  l_sot_remove = (OPJ_FLOAT32 )__cil_tmp25 / (OPJ_FLOAT32 )(l_cp->th * l_cp->tw);
  }
#line 4681
  if (l_cp->m_specific_param.m_enc.m_tp_on) {
#line 4682
    l_tp_stride_func = & opj_j2k_get_tp_stride;
  } else {
#line 4685
    l_tp_stride_func = & opj_j2k_get_default_stride;
  }
#line 4688
  i = (OPJ_UINT32 )0;
  {
#line 4688
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4688
    if (! (i < l_cp->th)) {
#line 4688
      goto while_break;
    }
#line 4689
    j = (OPJ_UINT32 )0;
    {
#line 4689
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 4689
      if (! (j < l_cp->tw)) {
#line 4689
        goto while_break___0;
      }
      {
#line 4690
      __cil_tmp27 = (*l_tp_stride_func)(l_tcp);
#line 4690
      l_offset = __cil_tmp27 / (OPJ_FLOAT32 )l_tcp->numlayers;
#line 4693
      l_x0 = opj_int_max((OPJ_INT32 )(l_cp->tx0 + j * l_cp->tdx), (OPJ_INT32 )l_image->x0);
#line 4694
      l_y0 = opj_int_max((OPJ_INT32 )(l_cp->ty0 + i * l_cp->tdy), (OPJ_INT32 )l_image->y0);
#line 4695
      l_x1 = opj_int_min((OPJ_INT32 )(l_cp->tx0 + (j + 1U) * l_cp->tdx), (OPJ_INT32 )l_image->x1);
#line 4696
      l_y1 = opj_int_min((OPJ_INT32 )(l_cp->ty0 + (i + 1U) * l_cp->tdy), (OPJ_INT32 )l_image->y1);
#line 4698
      l_rates = l_tcp->rates;
      }
#line 4701
      if (*l_rates) {
#line 4702
        *l_rates = (OPJ_FLOAT32 )((l_size_pixel * (OPJ_UINT32 )(l_x1 - l_x0)) * (OPJ_UINT32 )(l_y1 - l_y0)) / (*l_rates * (OPJ_FLOAT32 )l_bits_empty) - l_offset;
      }
#line 4710
      l_rates ++;
#line 4712
      k = (OPJ_UINT32 )1;
      {
#line 4712
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 4712
        if (! (k < l_tcp->numlayers)) {
#line 4712
          goto while_break___1;
        }
#line 4713
        if (*l_rates) {
#line 4714
          *l_rates = (OPJ_FLOAT32 )((l_size_pixel * (OPJ_UINT32 )(l_x1 - l_x0)) * (OPJ_UINT32 )(l_y1 - l_y0)) / (*l_rates * (OPJ_FLOAT32 )l_bits_empty) - l_offset;
        }
#line 4722
        l_rates ++;
#line 4712
        k ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___1: 
#line 4725
      l_tcp ++;
#line 4689
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___0: 
#line 4688
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: 
#line 4730
  l_tcp = l_cp->tcps;
#line 4732
  i = (OPJ_UINT32 )0;
  {
#line 4732
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 4732
    if (! (i < l_cp->th)) {
#line 4732
      goto while_break___2;
    }
#line 4733
    j = (OPJ_UINT32 )0;
    {
#line 4733
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 4733
      if (! (j < l_cp->tw)) {
#line 4733
        goto while_break___3;
      }
#line 4734
      l_rates = l_tcp->rates;
#line 4736
      if (*l_rates) {
#line 4737
        *l_rates -= l_sot_remove;
#line 4739
        if (*l_rates < (float )30) {
#line 4740
          *l_rates = (OPJ_FLOAT32 )30;
        }
      }
#line 4744
      l_rates ++;
#line 4746
      l_last_res = l_tcp->numlayers - 1U;
#line 4748
      k = (OPJ_UINT32 )1;
      {
#line 4748
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 4748
        if (! (k < l_last_res)) {
#line 4748
          goto while_break___4;
        }
#line 4750
        if (*l_rates) {
#line 4751
          *l_rates -= l_sot_remove;
#line 4753
          if (*l_rates < *(l_rates - 1) + (float )10) {
#line 4754
            *l_rates = *(l_rates - 1) + (float )20;
          }
        }
#line 4758
        l_rates ++;
#line 4748
        k ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: ;
#line 4761
      if (*l_rates) {
#line 4762
        *l_rates -= l_sot_remove + 2.f;
#line 4764
        if (*l_rates < *(l_rates - 1) + (float )10) {
#line 4765
          *l_rates = *(l_rates - 1) + (float )20;
        }
      }
#line 4769
      l_tcp ++;
#line 4733
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___3: 
#line 4732
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___2: 
#line 4773
  l_img_comp = l_image->comps;
#line 4774
  l_tile_size = (OPJ_UINT32 )0;
#line 4776
  i = (OPJ_UINT32 )0;
  {
#line 4776
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 4776
    if (! (i < l_image->numcomps)) {
#line 4776
      goto while_break___5;
    }
    {
#line 4777
    __cil_tmp33 = opj_uint_ceildiv(l_cp->tdy, l_img_comp->dy);
#line 4777
    __cil_tmp32 = opj_uint_ceildiv(l_cp->tdx, l_img_comp->dx);
#line 4777
    l_tile_size += (__cil_tmp32 * __cil_tmp33) * l_img_comp->prec;
#line 4784
    l_img_comp ++;
#line 4776
    i ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___5: 
  {
#line 4787
  l_tile_size = (OPJ_UINT32 )((double )l_tile_size * 0.162500000001);
#line 4789
  __cil_tmp34 = opj_j2k_get_specific_header_sizes(p_j2k);
#line 4789
  l_tile_size += __cil_tmp34;
#line 4791
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = l_tile_size;
#line 4792
  __cil_tmp35 = malloc((unsigned long )p_j2k->m_specific_param.m_encoder.m_encoded_tile_size);
#line 4792
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)__cil_tmp35;
  }
#line 4794
  if ((unsigned long )p_j2k->m_specific_param.m_encoder.m_encoded_tile_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 4795
    return (0);
  }
#line 4798
  if ((int )l_cp->rsiz >= 3) {
#line 4798
    if ((int )l_cp->rsiz <= 6) {
      {
#line 4799
      __cil_tmp36 = malloc((unsigned long )(5U * p_j2k->m_specific_param.m_encoder.m_total_tile_parts));
#line 4799
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)__cil_tmp36;
      }
#line 4801
      if (! p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
#line 4802
        return (0);
      }
#line 4805
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer;
    }
  }
#line 4809
  return (1);
}
}
#line 4863 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                struct opj_event_mgr *p_manager ) 
{ 


  {
  {
#line 4872
  (p_j2k->cstr_index)->main_head_end = opj_stream_tell(p_stream);
  }
#line 4874
  return (1);
}
}
#line 4877 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_mct_record ;
  opj_tcp_t *l_tcp ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 4891
  __cil_tmp11 = opj_j2k_write_cbd(p_j2k, p_stream, p_manager);
  }
#line 4891
  if (! __cil_tmp11) {
#line 4892
    return (0);
  }
#line 4895
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 4896
  l_mct_record = l_tcp->m_mct_records;
#line 4898
  i = (OPJ_UINT32 )0;
  {
#line 4898
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4898
    if (! (i < l_tcp->m_nb_mct_records)) {
#line 4898
      goto while_break;
    }
    {
#line 4900
    __cil_tmp12 = opj_j2k_write_mct_record(p_j2k, l_mct_record, p_stream, p_manager);
    }
#line 4900
    if (! __cil_tmp12) {
#line 4901
      return (0);
    }
#line 4904
    l_mct_record ++;
#line 4898
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 4907
  l_mcc_record = l_tcp->m_mcc_records;
#line 4909
  i = (OPJ_UINT32 )0;
  {
#line 4909
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 4909
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 4909
      goto while_break___0;
    }
    {
#line 4911
    __cil_tmp13 = opj_j2k_write_mcc_record(p_j2k, l_mcc_record, p_stream, p_manager);
    }
#line 4911
    if (! __cil_tmp13) {
#line 4912
      return (0);
    }
#line 4915
    l_mcc_record ++;
#line 4909
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 4918
  __cil_tmp14 = opj_j2k_write_mco(p_j2k, p_stream, p_manager);
  }
#line 4918
  if (! __cil_tmp14) {
#line 4919
    return (0);
  }
#line 4922
  return (1);
}
}
#line 4972 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                               struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  opj_tccp_t *l_tccp ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 4977
  l_tccp = (opj_tccp_t *)0;
#line 4984
  l_tccp = (p_j2k->m_cp.tcps)->tccps;
#line 4986
  compno = (OPJ_UINT32 )0;
  {
#line 4986
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4986
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 4986
      goto while_break;
    }
#line 4987
    if (l_tccp->roishift) {
      {
#line 4989
      __cil_tmp9 = opj_j2k_write_rgn(p_j2k, (OPJ_UINT32 )0, compno, (p_j2k->m_private_image)->numcomps,
                                     p_stream, p_manager);
      }
#line 4989
      if (! __cil_tmp9) {
#line 4990
        return (0);
      }
    }
#line 4994
    l_tccp ++;
#line 4986
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 4997
  return (1);
}
}
#line 5000 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) 
{ 
  opj_codestream_index_t *l_cstr_index ;
  OPJ_OFF_T __cil_tmp8 ;

  {
#line 5004
  l_cstr_index = (opj_codestream_index_t *)0;
#line 5011
  l_cstr_index = p_j2k->cstr_index;
#line 5012
  if (l_cstr_index) {
    {
#line 5013
    __cil_tmp8 = opj_stream_tell(p_stream);
#line 5013
    l_cstr_index->codestream_size = (OPJ_UINT64 )__cil_tmp8;
#line 5018
    l_cstr_index->codestream_size -= (OPJ_UINT64 )l_cstr_index->main_head_start;
    }
  }
#line 5035
  return (1);
}
}
#line 5038 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , OPJ_UINT32 *output_marker ,
                          opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_unknown_marker ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  OPJ_UINT32 l_size_unk ;
  OPJ_SIZE_T __cil_tmp11 ;
  OPJ_BOOL res ;
  OPJ_OFF_T __cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;

  {
  {
#line 5046
  l_size_unk = (OPJ_UINT32 )2;
#line 5053
  opj_event_msg(p_manager, 2, "Unknown marker\n");
  }
  {
#line 5055
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5057
    __cil_tmp11 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 5057
    if (__cil_tmp11 != 2UL) {
      {
#line 5058
      opj_event_msg(p_manager, 1, "Stream too short\nO\335iEV");
      }
#line 5059
      return (0);
    }
    {
#line 5063
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_unknown_marker,
                      (OPJ_UINT32 )2);
    }
#line 5065
    if (! (l_unknown_marker < 65280U)) {
      {
#line 5068
      l_marker_handler = opj_j2k_get_marker_handler(l_unknown_marker);
      }
#line 5070
      if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
        {
#line 5071
        opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n\334iEV");
        }
#line 5072
        return (0);
      } else
#line 5075
      if (l_marker_handler->id != 0U) {
#line 5077
        if (l_marker_handler->id != 65424U) {
          {
#line 5079
          __cil_tmp14 = opj_stream_tell(p_stream);
#line 5079
          __cil_tmp15 = opj_j2k_add_mhmarker(p_j2k->cstr_index, (OPJ_UINT32 )0, (OPJ_OFF_T )((OPJ_UINT32 )__cil_tmp14 - l_size_unk),
                                             l_size_unk);
#line 5079
          res = __cil_tmp15;
          }
#line 5082
          if (res == 0) {
            {
#line 5083
            opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n");
            }
#line 5084
            return (0);
          }
        }
#line 5087
        goto while_break;
      } else {
#line 5090
        l_size_unk += 2U;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 5095
  *output_marker = l_marker_handler->id;
#line 5097
  return (1);
}
}
#line 5100 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k , opj_mct_data_t *p_mct_record ,
                                  struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_mct_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tmp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp13 ;

  {
#line 5106
  l_current_data = (OPJ_BYTE *)0;
#line 5114
  l_mct_size = 10U + p_mct_record->m_data_size;
#line 5116
  if (l_mct_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5117
    __cil_tmp12 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_mct_size);
#line 5117
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp12;
    }
#line 5118
    if (! new_header_tile_data) {
      {
#line 5119
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5120
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5121
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5122
      opj_event_msg(p_manager, 1, "Not enough memory to write MCT marker\n");
      }
#line 5123
      return (0);
    }
#line 5125
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5126
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mct_size;
  }
  {
#line 5129
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5131
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65396, (OPJ_UINT32 )2);
#line 5132
  l_current_data += 2;
#line 5134
  opj_write_bytes_LE(l_current_data, l_mct_size - 2U, (OPJ_UINT32 )2);
#line 5135
  l_current_data += 2;
#line 5137
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5138
  l_current_data += 2;
#line 5141
  l_tmp = ((p_mct_record->m_index & 255U) | ((unsigned int )p_mct_record->m_array_type << 8)) | ((unsigned int )p_mct_record->m_element_type << 10);
#line 5143
  opj_write_bytes_LE(l_current_data, l_tmp, (OPJ_UINT32 )2);
#line 5144
  l_current_data += 2;
#line 5146
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5147
  l_current_data += 2;
#line 5149
  memcpy((void *)l_current_data, (void const   *)p_mct_record->m_data, (unsigned long )p_mct_record->m_data_size);
#line 5151
  __cil_tmp13 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mct_size, p_manager);
  }
#line 5151
  if (__cil_tmp13 != (unsigned long )l_mct_size) {
#line 5152
    return (0);
  }
#line 5155
  return (1);
}
}
#line 5166 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_indix ;
  opj_mct_data_t *l_mct_data ;
  opj_tcp_t *tmp___1 ;
  opj_mct_data_t *new_mct_records ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
#line 5173
  l_tcp = (opj_tcp_t *)0;
#line 5182
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 5182
    tmp___1 = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 5182
    tmp___1 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 5182
  l_tcp = tmp___1;
#line 5186
  if (p_header_size < 2U) {
    {
#line 5187
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5188
    return (0);
  }
  {
#line 5192
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5193
  p_header_data += 2;
  }
#line 5194
  if (l_tmp != 0U) {
    {
#line 5195
    opj_event_msg(p_manager, 2, "Cannot take in charge mct data within multiple MCT records\n");
    }
#line 5196
    return (1);
  }
#line 5199
  if (p_header_size <= 6U) {
    {
#line 5200
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5201
    return (0);
  }
  {
#line 5205
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5206
  p_header_data += 2;
#line 5208
  l_indix = l_tmp & 255U;
#line 5209
  l_mct_data = l_tcp->m_mct_records;
#line 5211
  i = (OPJ_UINT32 )0;
  }
  {
#line 5211
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5211
    if (! (i < l_tcp->m_nb_mct_records)) {
#line 5211
      goto while_break;
    }
#line 5212
    if (l_mct_data->m_index == l_indix) {
#line 5213
      goto while_break;
    }
#line 5215
    l_mct_data ++;
#line 5211
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 5219
  if (i == l_tcp->m_nb_mct_records) {
#line 5220
    if (l_tcp->m_nb_mct_records == l_tcp->m_nb_max_mct_records) {
      {
#line 5222
      l_tcp->m_nb_max_mct_records += 10U;
#line 5224
      __cil_tmp14 = realloc((void *)l_tcp->m_mct_records, (unsigned long )l_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 5224
      new_mct_records = (opj_mct_data_t *)__cil_tmp14;
      }
#line 5225
      if (! new_mct_records) {
        {
#line 5226
        free((void *)l_tcp->m_mct_records);
#line 5227
        l_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 5228
        l_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 5229
        l_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
#line 5230
        opj_event_msg(p_manager, 1, "Not enough memory to read MCT marker\n");
        }
#line 5231
        return (0);
      }
      {
#line 5233
      l_tcp->m_mct_records = new_mct_records;
#line 5234
      l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
#line 5235
      memset((void *)l_mct_data, 0, (unsigned long )(l_tcp->m_nb_max_mct_records - l_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
      }
    }
#line 5238
    l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
  }
#line 5241
  if (l_mct_data->m_data) {
    {
#line 5242
    free((void *)l_mct_data->m_data);
#line 5243
    l_mct_data->m_data = (OPJ_BYTE *)0;
    }
  }
  {
#line 5246
  l_mct_data->m_index = l_indix;
#line 5247
  l_mct_data->m_array_type = (J2K_MCT_ARRAY_TYPE )((l_tmp >> 8) & 3U);
#line 5248
  l_mct_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )((l_tmp >> 10) & 3U);
#line 5250
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5251
  p_header_data += 2;
  }
#line 5252
  if (l_tmp != 0U) {
    {
#line 5253
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple MCT markers\n");
    }
#line 5254
    return (1);
  }
  {
#line 5257
  p_header_size -= 6U;
#line 5259
  __cil_tmp15 = malloc((unsigned long )p_header_size);
#line 5259
  l_mct_data->m_data = (OPJ_BYTE *)__cil_tmp15;
  }
#line 5260
  if (! l_mct_data->m_data) {
    {
#line 5261
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5262
    return (0);
  }
  {
#line 5264
  memcpy((void *)l_mct_data->m_data, (void const   *)p_header_data, (unsigned long )p_header_size);
#line 5266
  l_mct_data->m_data_size = p_header_size;
#line 5267
  (l_tcp->m_nb_mct_records) ++;
  }
#line 5269
  return (1);
}
}
#line 5272 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k , struct opj_simple_mcc_decorrelation_data *p_mcc_record ,
                                  struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_mcc_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_bytes_for_comp ;
  OPJ_UINT32 l_mask ;
  OPJ_UINT32 l_tmcc ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp15 ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
#line 5279
  l_current_data = (OPJ_BYTE *)0;
#line 5289
  if (p_mcc_record->m_nb_comps > 255U) {
#line 5290
    l_nb_bytes_for_comp = (OPJ_UINT32 )2;
#line 5291
    l_mask = (OPJ_UINT32 )32768;
  } else {
#line 5294
    l_nb_bytes_for_comp = (OPJ_UINT32 )1;
#line 5295
    l_mask = (OPJ_UINT32 )0;
  }
#line 5298
  l_mcc_size = (p_mcc_record->m_nb_comps * 2U) * l_nb_bytes_for_comp + 19U;
#line 5299
  if (l_mcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5301
    __cil_tmp15 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_mcc_size);
#line 5301
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp15;
    }
#line 5302
    if (! new_header_tile_data) {
      {
#line 5303
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5304
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5305
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5306
      opj_event_msg(p_manager, 1, "Not enough memory to write MCC marker\n");
      }
#line 5307
      return (0);
    }
#line 5309
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5310
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mcc_size;
  }
  {
#line 5313
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5315
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65397, (OPJ_UINT32 )2);
#line 5316
  l_current_data += 2;
#line 5318
  opj_write_bytes_LE(l_current_data, l_mcc_size - 2U, (OPJ_UINT32 )2);
#line 5319
  l_current_data += 2;
#line 5322
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5323
  l_current_data += 2;
#line 5325
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_index, (OPJ_UINT32 )1);
#line 5326
  l_current_data ++;
#line 5329
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5330
  l_current_data += 2;
#line 5332
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )1, (OPJ_UINT32 )2);
#line 5333
  l_current_data += 2;
#line 5335
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
#line 5336
  l_current_data ++;
#line 5338
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_nb_comps | l_mask, (OPJ_UINT32 )2);
#line 5339
  l_current_data += 2;
#line 5341
  i = (OPJ_UINT32 )0;
  }
  {
#line 5341
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5341
    if (! (i < p_mcc_record->m_nb_comps)) {
#line 5341
      goto while_break;
    }
    {
#line 5342
    opj_write_bytes_LE(l_current_data, i, l_nb_bytes_for_comp);
#line 5343
    l_current_data += l_nb_bytes_for_comp;
#line 5341
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 5346
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_nb_comps | l_mask, (OPJ_UINT32 )2);
#line 5347
  l_current_data += 2;
#line 5349
  i = (OPJ_UINT32 )0;
  }
  {
#line 5349
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 5349
    if (! (i < p_mcc_record->m_nb_comps)) {
#line 5349
      goto while_break___0;
    }
    {
#line 5351
    opj_write_bytes_LE(l_current_data, i, l_nb_bytes_for_comp);
#line 5352
    l_current_data += l_nb_bytes_for_comp;
#line 5349
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
#line 5355
  l_tmcc = (OPJ_UINT32 )((! p_mcc_record->m_is_irreversible & 1) << 16);
#line 5357
  if (p_mcc_record->m_decorrelation_array) {
#line 5358
    l_tmcc |= (p_mcc_record->m_decorrelation_array)->m_index;
  }
#line 5361
  if (p_mcc_record->m_offset_array) {
#line 5362
    l_tmcc |= (p_mcc_record->m_offset_array)->m_index << 8;
  }
  {
#line 5365
  opj_write_bytes_LE(l_current_data, l_tmcc, (OPJ_UINT32 )3);
#line 5366
  l_current_data += 3;
#line 5368
  __cil_tmp16 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mcc_size, p_manager);
  }
#line 5368
  if (__cil_tmp16 != (unsigned long )l_mcc_size) {
#line 5369
    return (0);
  }
#line 5372
  return (1);
}
}
#line 5375 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                          opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_indix ;
  opj_tcp_t *l_tcp ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_mct_data ;
  OPJ_UINT32 l_nb_collections ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_nb_bytes_by_comp ;
  opj_tcp_t *tmp___2 ;
  opj_simple_mcc_decorrelation_data_t *new_mcc_records ;
  void *__cil_tmp20 ;

  {
#line 5395
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 5395
    tmp___2 = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 5395
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 5395
  l_tcp = tmp___2;
#line 5399
  if (p_header_size < 2U) {
    {
#line 5400
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
    }
#line 5401
    return (0);
  }
  {
#line 5405
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5406
  p_header_data += 2;
  }
#line 5407
  if (l_tmp != 0U) {
    {
#line 5408
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple data spanning\nV");
    }
#line 5409
    return (1);
  }
#line 5412
  if (p_header_size < 7U) {
    {
#line 5413
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n\027\336iEV");
    }
#line 5414
    return (0);
  }
  {
#line 5417
  opj_read_bytes_LE(p_header_data, & l_indix, (OPJ_UINT32 )1);
#line 5418
  p_header_data ++;
#line 5420
  l_mcc_record = l_tcp->m_mcc_records;
#line 5422
  i = (OPJ_UINT32 )0;
  }
  {
#line 5422
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5422
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 5422
      goto while_break;
    }
#line 5423
    if (l_mcc_record->m_index == l_indix) {
#line 5424
      goto while_break;
    }
#line 5426
    l_mcc_record ++;
#line 5422
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 5430
  if (i == l_tcp->m_nb_mcc_records) {
#line 5431
    if (l_tcp->m_nb_mcc_records == l_tcp->m_nb_max_mcc_records) {
      {
#line 5433
      l_tcp->m_nb_max_mcc_records += 10U;
#line 5435
      __cil_tmp20 = realloc((void *)l_tcp->m_mcc_records, (unsigned long )l_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 5435
      new_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp20;
      }
#line 5437
      if (! new_mcc_records) {
        {
#line 5438
        free((void *)l_tcp->m_mcc_records);
#line 5439
        l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)((void *)0);
#line 5440
        l_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 5441
        l_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
#line 5442
        opj_event_msg(p_manager, 1, "Not enough memory to read MCC marker\nV");
        }
#line 5443
        return (0);
      }
      {
#line 5445
      l_tcp->m_mcc_records = new_mcc_records;
#line 5446
      l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
#line 5447
      memset((void *)l_mcc_record, 0, (unsigned long )(l_tcp->m_nb_max_mcc_records - l_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t ));
      }
    }
#line 5449
    l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
  }
  {
#line 5451
  l_mcc_record->m_index = l_indix;
#line 5454
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5455
  p_header_data += 2;
  }
#line 5456
  if (l_tmp != 0U) {
    {
#line 5457
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple data spanning\n");
    }
#line 5458
    return (1);
  }
  {
#line 5461
  opj_read_bytes_LE(p_header_data, & l_nb_collections, (OPJ_UINT32 )2);
#line 5462
  p_header_data += 2;
  }
#line 5464
  if (l_nb_collections > 1U) {
    {
#line 5465
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple collections\n");
    }
#line 5466
    return (1);
  }
#line 5469
  p_header_size -= 7U;
#line 5471
  i = (OPJ_UINT32 )0;
  {
#line 5471
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 5471
    if (! (i < l_nb_collections)) {
#line 5471
      goto while_break___0;
    }
#line 5472
    if (p_header_size < 3U) {
      {
#line 5473
      opj_event_msg(p_manager, 1, "Error reading MCC marker\nx\336iEV");
      }
#line 5474
      return (0);
    }
    {
#line 5477
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 5478
    p_header_data ++;
    }
#line 5480
    if (l_tmp != 1U) {
      {
#line 5481
      opj_event_msg(p_manager, 2, "Cannot take in charge collections other than array decorrelation\n~\336iEV");
      }
#line 5482
      return (1);
    }
    {
#line 5485
    opj_read_bytes_LE(p_header_data, & l_nb_comps, (OPJ_UINT32 )2);
#line 5487
    p_header_data += 2;
#line 5488
    p_header_size -= 3U;
#line 5490
    l_nb_bytes_by_comp = 1U + (l_nb_comps >> 15);
#line 5491
    l_mcc_record->m_nb_comps = l_nb_comps & 32767U;
    }
#line 5493
    if (p_header_size < l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2U) {
      {
#line 5494
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
      }
#line 5495
      return (0);
    }
#line 5498
    p_header_size -= l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2U;
#line 5500
    j = (OPJ_UINT32 )0;
    {
#line 5500
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 5500
      if (! (j < l_mcc_record->m_nb_comps)) {
#line 5500
        goto while_break___1;
      }
      {
#line 5501
      opj_read_bytes_LE(p_header_data, & l_tmp, l_nb_bytes_by_comp);
#line 5502
      p_header_data += l_nb_bytes_by_comp;
      }
#line 5504
      if (l_tmp != j) {
        {
#line 5505
        opj_event_msg(p_manager, 2, "Cannot take in charge collections with indix shuffle\n");
        }
#line 5506
        return (1);
      }
#line 5500
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 5510
    opj_read_bytes_LE(p_header_data, & l_nb_comps, (OPJ_UINT32 )2);
#line 5511
    p_header_data += 2;
#line 5513
    l_nb_bytes_by_comp = 1U + (l_nb_comps >> 15);
#line 5514
    l_nb_comps &= 32767U;
    }
#line 5516
    if (l_nb_comps != l_mcc_record->m_nb_comps) {
      {
#line 5517
      opj_event_msg(p_manager, 2, "Cannot take in charge collections without same number of indixes\n");
      }
#line 5518
      return (1);
    }
#line 5521
    if (p_header_size < l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3U) {
      {
#line 5522
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
      }
#line 5523
      return (0);
    }
#line 5526
    p_header_size -= l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3U;
#line 5528
    j = (OPJ_UINT32 )0;
    {
#line 5528
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 5528
      if (! (j < l_mcc_record->m_nb_comps)) {
#line 5528
        goto while_break___2;
      }
      {
#line 5529
      opj_read_bytes_LE(p_header_data, & l_tmp, l_nb_bytes_by_comp);
#line 5530
      p_header_data += l_nb_bytes_by_comp;
      }
#line 5532
      if (l_tmp != j) {
        {
#line 5533
        opj_event_msg(p_manager, 2, "Cannot take in charge collections with indix shuffle\n");
        }
#line 5534
        return (1);
      }
#line 5528
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 5538
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )3);
#line 5539
    p_header_data += 3;
#line 5541
    l_mcc_record->m_is_irreversible = (OPJ_UINT32 )(! ((l_tmp >> 16) & 1U));
#line 5542
    l_mcc_record->m_decorrelation_array = (opj_mct_data_t *)0;
#line 5543
    l_mcc_record->m_offset_array = (opj_mct_data_t *)0;
#line 5545
    l_indix = l_tmp & 255U;
    }
#line 5546
    if (l_indix != 0U) {
#line 5547
      l_mct_data = l_tcp->m_mct_records;
#line 5548
      j = (OPJ_UINT32 )0;
      {
#line 5548
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 5548
        if (! (j < l_tcp->m_nb_mct_records)) {
#line 5548
          goto while_break___3;
        }
#line 5549
        if (l_mct_data->m_index == l_indix) {
#line 5550
          l_mcc_record->m_decorrelation_array = l_mct_data;
#line 5551
          goto while_break___3;
        }
#line 5553
        l_mct_data ++;
#line 5548
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: ;
#line 5556
      if ((unsigned long )l_mcc_record->m_decorrelation_array == (unsigned long )((opj_mct_data_t *)0)) {
        {
#line 5557
        opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
        }
#line 5558
        return (0);
      }
    }
#line 5562
    l_indix = (l_tmp >> 8) & 255U;
#line 5563
    if (l_indix != 0U) {
#line 5564
      l_mct_data = l_tcp->m_mct_records;
#line 5565
      j = (OPJ_UINT32 )0;
      {
#line 5565
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 5565
        if (! (j < l_tcp->m_nb_mct_records)) {
#line 5565
          goto while_break___4;
        }
#line 5566
        if (l_mct_data->m_index == l_indix) {
#line 5567
          l_mcc_record->m_offset_array = l_mct_data;
#line 5568
          goto while_break___4;
        }
#line 5570
        l_mct_data ++;
#line 5565
        j ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: ;
#line 5573
      if ((unsigned long )l_mcc_record->m_offset_array == (unsigned long )((opj_mct_data_t *)0)) {
        {
#line 5574
        opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
        }
#line 5575
        return (0);
      }
    }
#line 5471
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: ;
#line 5580
  if (p_header_size != 0U) {
    {
#line 5581
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
    }
#line 5582
    return (0);
  }
#line 5585
  (l_tcp->m_nb_mcc_records) ++;
#line 5587
  return (1);
}
}
#line 5590 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_mco_size ;
  opj_tcp_t *l_tcp ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  OPJ_UINT32 i ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
#line 5595
  l_current_data = (OPJ_BYTE *)0;
#line 5597
  l_tcp = (opj_tcp_t *)0;
#line 5606
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 5607
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5609
  l_mco_size = 5U + l_tcp->m_nb_mcc_records;
#line 5610
  if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5612
    __cil_tmp13 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_mco_size);
#line 5612
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp13;
    }
#line 5613
    if (! new_header_tile_data) {
      {
#line 5614
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5615
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5616
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5617
      opj_event_msg(p_manager, 1, "Not enough memory to write MCO marker\n");
      }
#line 5618
      return (0);
    }
#line 5620
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5621
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;
  }
  {
#line 5624
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65399, (OPJ_UINT32 )2);
#line 5625
  l_current_data += 2;
#line 5627
  opj_write_bytes_LE(l_current_data, l_mco_size - 2U, (OPJ_UINT32 )2);
#line 5628
  l_current_data += 2;
#line 5630
  opj_write_bytes_LE(l_current_data, l_tcp->m_nb_mcc_records, (OPJ_UINT32 )1);
#line 5631
  l_current_data ++;
#line 5633
  l_mcc_record = l_tcp->m_mcc_records;
#line 5634
  i = (OPJ_UINT32 )0;
  }
  {
#line 5634
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5634
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 5634
      goto while_break;
    }
    {
#line 5635
    opj_write_bytes_LE(l_current_data, l_mcc_record->m_index, (OPJ_UINT32 )1);
#line 5636
    l_current_data ++;
#line 5638
    l_mcc_record ++;
#line 5634
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 5641
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mco_size, p_manager);
  }
#line 5641
  if (__cil_tmp14 != (unsigned long )l_mco_size) {
#line 5642
    return (0);
  }
#line 5645
  return (1);
}
}
#line 5656 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_stages ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_t *l_image ;
  opj_tcp_t *tmp___2 ;
  OPJ_BOOL __cil_tmp15 ;

  {
#line 5673
  l_image = p_j2k->m_private_image;
#line 5674
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 5674
    tmp___2 = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 5674
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 5674
  l_tcp = tmp___2;
#line 5678
  if (p_header_size < 1U) {
    {
#line 5679
    opj_event_msg(p_manager, 1, "Error reading MCO marker\n");
    }
#line 5680
    return (0);
  }
  {
#line 5683
  opj_read_bytes_LE(p_header_data, & l_nb_stages, (OPJ_UINT32 )1);
#line 5684
  p_header_data ++;
  }
#line 5686
  if (l_nb_stages > 1U) {
    {
#line 5687
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple transformation stages.\n");
    }
#line 5688
    return (1);
  }
#line 5691
  if (p_header_size != l_nb_stages + 1U) {
    {
#line 5692
    opj_event_msg(p_manager, 2, "Error reading MCO marker\n\336\336iEV");
    }
#line 5693
    return (0);
  }
#line 5696
  l_tccp = l_tcp->tccps;
#line 5698
  i = (OPJ_UINT32 )0;
  {
#line 5698
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5698
    if (! (i < l_image->numcomps)) {
#line 5698
      goto while_break;
    }
#line 5699
    l_tccp->m_dc_level_shift = 0;
#line 5700
    l_tccp ++;
#line 5698
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 5703
  if (l_tcp->m_mct_decoding_matrix) {
    {
#line 5704
    free((void *)l_tcp->m_mct_decoding_matrix);
#line 5705
    l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 5708
  i = (OPJ_UINT32 )0;
  {
#line 5708
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 5708
    if (! (i < l_nb_stages)) {
#line 5708
      goto while_break___0;
    }
    {
#line 5709
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 5710
    p_header_data ++;
#line 5712
    __cil_tmp15 = opj_j2k_add_mct(l_tcp, p_j2k->m_private_image, l_tmp);
    }
#line 5712
    if (! __cil_tmp15) {
#line 5713
      return (0);
    }
#line 5708
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 5717
  return (1);
}
}
#line 5720 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_add_mct(opj_tcp_t *p_tcp , opj_image_t *p_image , OPJ_UINT32 p_index ) 
{ 
  OPJ_UINT32 i ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_deco_array ;
  opj_mct_data_t *l_offset_array ;
  OPJ_UINT32 l_data_size ;
  OPJ_UINT32 l_mct_size ;
  OPJ_UINT32 l_offset_size ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_UINT32 *l_offset_data ;
  OPJ_UINT32 *l_current_offset_data ;
  opj_tccp_t *l_tccp ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  OPJ_UINT32 *__cil_tmp18 ;

  {
#line 5733
  l_mcc_record = p_tcp->m_mcc_records;
#line 5735
  i = (OPJ_UINT32 )0;
  {
#line 5735
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5735
    if (! (i < p_tcp->m_nb_mcc_records)) {
#line 5735
      goto while_break;
    }
#line 5736
    if (l_mcc_record->m_index == p_index) {
#line 5737
      goto while_break;
    }
#line 5735
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 5741
  if (i == p_tcp->m_nb_mcc_records) {
#line 5743
    return (1);
  }
#line 5746
  if (l_mcc_record->m_nb_comps != p_image->numcomps) {
#line 5748
    return (1);
  }
#line 5751
  l_deco_array = l_mcc_record->m_decorrelation_array;
#line 5753
  if (l_deco_array) {
#line 5754
    l_data_size = (MCT_ELEMENT_SIZE[l_deco_array->m_element_type] * p_image->numcomps) * p_image->numcomps;
#line 5755
    if (l_deco_array->m_data_size != l_data_size) {
#line 5756
      return (0);
    }
    {
#line 5759
    l_nb_elem = p_image->numcomps * p_image->numcomps;
#line 5760
    l_mct_size = l_nb_elem * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 5761
    __cil_tmp16 = malloc((unsigned long )l_mct_size);
#line 5761
    p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp16;
    }
#line 5763
    if (! p_tcp->m_mct_decoding_matrix) {
#line 5764
      return (0);
    }
    {
#line 5767
    (*(j2k_mct_read_functions_to_float[l_deco_array->m_element_type]))((void const   *)l_deco_array->m_data,
                                                                       (void *)p_tcp->m_mct_decoding_matrix,
                                                                       l_nb_elem);
    }
  }
#line 5770
  l_offset_array = l_mcc_record->m_offset_array;
#line 5772
  if (l_offset_array) {
#line 5773
    l_data_size = MCT_ELEMENT_SIZE[l_offset_array->m_element_type] * p_image->numcomps;
#line 5774
    if (l_offset_array->m_data_size != l_data_size) {
#line 5775
      return (0);
    }
    {
#line 5778
    l_nb_elem = p_image->numcomps;
#line 5779
    l_offset_size = l_nb_elem * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 5780
    __cil_tmp17 = malloc((unsigned long )l_offset_size);
#line 5780
    l_offset_data = (OPJ_UINT32 *)__cil_tmp17;
    }
#line 5782
    if (! l_offset_data) {
#line 5783
      return (0);
    }
    {
#line 5786
    (*(j2k_mct_read_functions_to_int32[l_offset_array->m_element_type]))((void const   *)l_offset_array->m_data,
                                                                         (void *)l_offset_data,
                                                                         l_nb_elem);
#line 5788
    l_tccp = p_tcp->tccps;
#line 5789
    l_current_offset_data = l_offset_data;
#line 5791
    i = (OPJ_UINT32 )0;
    }
    {
#line 5791
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 5791
      if (! (i < p_image->numcomps)) {
#line 5791
        goto while_break___0;
      }
#line 5792
      __cil_tmp18 = l_current_offset_data;
#line 5792
      l_current_offset_data ++;
#line 5792
      l_tccp->m_dc_level_shift = (OPJ_INT32 )*__cil_tmp18;
#line 5793
      l_tccp ++;
#line 5791
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 5796
    free((void *)l_offset_data);
    }
  }
#line 5799
  return (1);
}
}
#line 5802 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_cbd_size ;
  OPJ_BYTE *l_current_data ;
  opj_image_t *l_image ;
  opj_image_comp_t *l_comp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
#line 5808
  l_current_data = (OPJ_BYTE *)0;
#line 5809
  l_image = (opj_image_t *)0;
#line 5810
  l_comp = (opj_image_comp_t *)0;
#line 5817
  l_image = p_j2k->m_private_image;
#line 5818
  l_cbd_size = 6U + (p_j2k->m_private_image)->numcomps;
#line 5820
  if (l_cbd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5821
    __cil_tmp13 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_cbd_size);
#line 5821
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp13;
    }
#line 5822
    if (! new_header_tile_data) {
      {
#line 5823
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5824
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5825
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5826
      opj_event_msg(p_manager, 1, "Not enough memory to write CBD marker\n");
      }
#line 5827
      return (0);
    }
#line 5829
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5830
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_cbd_size;
  }
  {
#line 5833
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5835
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65400, (OPJ_UINT32 )2);
#line 5836
  l_current_data += 2;
#line 5838
  opj_write_bytes_LE(l_current_data, l_cbd_size - 2U, (OPJ_UINT32 )2);
#line 5839
  l_current_data += 2;
#line 5841
  opj_write_bytes_LE(l_current_data, l_image->numcomps, (OPJ_UINT32 )2);
#line 5842
  l_current_data += 2;
#line 5844
  l_comp = l_image->comps;
#line 5846
  i = (OPJ_UINT32 )0;
  }
  {
#line 5846
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5846
    if (! (i < l_image->numcomps)) {
#line 5846
      goto while_break;
    }
    {
#line 5847
    opj_write_bytes_LE(l_current_data, (l_comp->sgnd << 7) | (l_comp->prec - 1U),
                       (OPJ_UINT32 )1);
#line 5848
    l_current_data ++;
#line 5850
    l_comp ++;
#line 5846
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 5853
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_cbd_size, p_manager);
  }
#line 5853
  if (__cil_tmp14 != (unsigned long )l_cbd_size) {
#line 5854
    return (0);
  }
#line 5857
  return (1);
}
}
#line 5867 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_num_comp ;
  OPJ_UINT32 l_comp_def ;
  OPJ_UINT32 i ;
  opj_image_comp_t *l_comp ;

  {
#line 5876
  l_comp = (opj_image_comp_t *)0;
#line 5883
  l_num_comp = (p_j2k->m_private_image)->numcomps;
#line 5885
  if (p_header_size != (p_j2k->m_private_image)->numcomps + 2U) {
    {
#line 5886
    opj_event_msg(p_manager, 1, "Crror reading CBD marker\n");
    }
#line 5887
    return (0);
  }
  {
#line 5890
  opj_read_bytes_LE(p_header_data, & l_nb_comp, (OPJ_UINT32 )2);
#line 5891
  p_header_data += 2;
  }
#line 5893
  if (l_nb_comp != l_num_comp) {
    {
#line 5894
    opj_event_msg(p_manager, 1, "Crror reading CBD marker\n");
    }
#line 5895
    return (0);
  }
#line 5898
  l_comp = (p_j2k->m_private_image)->comps;
#line 5899
  i = (OPJ_UINT32 )0;
  {
#line 5899
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5899
    if (! (i < l_num_comp)) {
#line 5899
      goto while_break;
    }
    {
#line 5900
    opj_read_bytes_LE(p_header_data, & l_comp_def, (OPJ_UINT32 )1);
#line 5901
    p_header_data ++;
#line 5902
    l_comp->sgnd = (l_comp_def >> 7) & 1U;
#line 5903
    l_comp->prec = (l_comp_def & 127U) + 1U;
#line 5904
    l_comp ++;
#line 5899
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 5907
  return (1);
}
}
#line 5914 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) 
{ 


  {
#line 5916
  if (j2k) {
#line 5916
    if (parameters) {
#line 5917
      j2k->m_cp.m_specific_param.m_dec.m_layer = parameters->cp_layer;
#line 5918
      j2k->m_cp.m_specific_param.m_dec.m_reduce = parameters->cp_reduce;
    }
  }
#line 5921
  return;
}
}
#line 5932 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
opj_j2k_t *opj_j2k_create_compress(void) 
{ 
  opj_j2k_t *l_j2k ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 5934
  __cil_tmp2 = calloc(1UL, sizeof(opj_j2k_t ));
#line 5934
  l_j2k = (opj_j2k_t *)__cil_tmp2;
  }
#line 5935
  if (! l_j2k) {
#line 5936
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 5940
  l_j2k->m_is_decoder = 0;
#line 5941
  l_j2k->m_cp.m_is_decoder = (OPJ_UINT32 )0;
#line 5943
  __cil_tmp3 = malloc(1000UL);
#line 5943
  l_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)__cil_tmp3;
  }
#line 5944
  if (! l_j2k->m_specific_param.m_encoder.m_header_tile_data) {
    {
#line 5945
    opj_j2k_destroy(l_j2k);
    }
#line 5946
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 5949
  l_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )1000;
#line 5952
  l_j2k->m_validation_list = opj_procedure_list_create();
  }
#line 5953
  if (! l_j2k->m_validation_list) {
    {
#line 5954
    opj_j2k_destroy(l_j2k);
    }
#line 5955
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 5959
  l_j2k->m_procedure_list = opj_procedure_list_create();
  }
#line 5960
  if (! l_j2k->m_procedure_list) {
    {
#line 5961
    opj_j2k_destroy(l_j2k);
    }
#line 5962
    return ((opj_j2k_t *)((void *)0));
  }
#line 5965
  return (l_j2k);
}
}
#line 5968 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
int opj_j2k_initialise_4K_poc(opj_poc_t *POC , int numres ) 
{ 


  {
#line 5969
  (POC + 0)->tile = (OPJ_UINT32 )1;
#line 5970
  (POC + 0)->resno0 = (OPJ_UINT32 )0;
#line 5971
  (POC + 0)->compno0 = (OPJ_UINT32 )0;
#line 5972
  (POC + 0)->layno1 = (OPJ_UINT32 )1;
#line 5973
  (POC + 0)->resno1 = (OPJ_UINT32 )(numres - 1);
#line 5974
  (POC + 0)->compno1 = (OPJ_UINT32 )3;
#line 5975
  (POC + 0)->prg1 = (OPJ_PROG_ORDER )4;
#line 5976
  (POC + 1)->tile = (OPJ_UINT32 )1;
#line 5977
  (POC + 1)->resno0 = (OPJ_UINT32 )(numres - 1);
#line 5978
  (POC + 1)->compno0 = (OPJ_UINT32 )0;
#line 5979
  (POC + 1)->layno1 = (OPJ_UINT32 )1;
#line 5980
  (POC + 1)->resno1 = (OPJ_UINT32 )numres;
#line 5981
  (POC + 1)->compno1 = (OPJ_UINT32 )3;
#line 5982
  (POC + 1)->prg1 = (OPJ_PROG_ORDER )4;
#line 5983
  return (2);
}
}
#line 5986 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  int i ;
  int __cil_tmp6 ;

  {
#line 5992
  parameters->tile_size_on = 0;
#line 5993
  parameters->cp_tdx = 1;
#line 5994
  parameters->cp_tdy = 1;
#line 5997
  parameters->tp_flag = (char )'C';
#line 5998
  parameters->tp_on = (char)1;
#line 6001
  parameters->cp_tx0 = 0;
#line 6002
  parameters->cp_ty0 = 0;
#line 6003
  parameters->image_offset_x0 = 0;
#line 6004
  parameters->image_offset_y0 = 0;
#line 6007
  parameters->cblockw_init = 32;
#line 6008
  parameters->cblockh_init = 32;
#line 6011
  parameters->mode = 0;
#line 6014
  parameters->roi_compno = -1;
#line 6017
  parameters->subsampling_dx = 1;
#line 6018
  parameters->subsampling_dy = 1;
#line 6021
  parameters->irreversible = 1;
#line 6024
  if (parameters->tcp_numlayers > 1) {
    {
#line 6025
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n1 single quality layer-> Number of layers forced to 1 (rather than %d)\n-> Rate of the last layer (%3.1f) will be used\230\001",
                  parameters->tcp_numlayers, (double )parameters->tcp_rates[parameters->tcp_numlayers - 1]);
#line 6031
    parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];
#line 6032
    parameters->tcp_numlayers = 1;
    }
  }
#line 6037
  if ((int )parameters->rsiz == 3) {
#line 6037
    goto case_3;
  }
#line 6047
  if ((int )parameters->rsiz == 4) {
#line 6047
    goto case_4;
  }
#line 6064
  goto switch_default;
  case_3: 
#line 6038
  if (parameters->numresolution > 6) {
    {
#line 6039
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nNumber of decomposition levels <= 5\n-> Number of decomposition levels forced to 5 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 6044
    parameters->numresolution = 6;
    }
  }
#line 6046
  goto switch_break;
  case_4: 
#line 6048
  if (parameters->numresolution < 2) {
    {
#line 6049
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 1 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 6054
    parameters->numresolution = 1;
    }
  } else
#line 6055
  if (parameters->numresolution > 7) {
    {
#line 6056
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 6 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 6061
    parameters->numresolution = 7;
    }
  }
#line 6063
  goto switch_break;
  switch_default: 
#line 6065
  goto switch_break;
  switch_break: 
#line 6069
  parameters->csty |= 1;
#line 6070
  parameters->res_spec = parameters->numresolution - 1;
#line 6071
  i = 0;
  {
#line 6071
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6071
    if (! (i < parameters->res_spec)) {
#line 6071
      goto while_break;
    }
#line 6072
    parameters->prcw_init[i] = 256;
#line 6073
    parameters->prch_init[i] = 256;
#line 6071
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 6077
  parameters->prog_order = (OPJ_PROG_ORDER )4;
#line 6080
  if ((int )parameters->rsiz == 4) {
    {
#line 6081
    __cil_tmp6 = opj_j2k_initialise_4K_poc(parameters->POC, parameters->numresolution);
#line 6081
    parameters->numpocs = (OPJ_UINT32 )__cil_tmp6;
    }
  } else {
#line 6083
    parameters->numpocs = (OPJ_UINT32 )0;
  }
#line 6087
  parameters->cp_disto_alloc = 1;
#line 6088
  if (parameters->max_cs_size <= 0) {
    {
#line 6090
    parameters->max_cs_size = 1302083;
#line 6091
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1302083 compressed bytes @ 24fps\nAs no rate has been given, this limit will be used.\n");
    }
  } else
#line 6095
  if (parameters->max_cs_size > 1302083) {
    {
#line 6096
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1302083 compressed bytes @ 24fps\n-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\n");
#line 6100
    parameters->max_cs_size = 1302083;
    }
  }
#line 6103
  if (parameters->max_comp_size <= 0) {
    {
#line 6105
    parameters->max_comp_size = 1041666;
#line 6106
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1041666 compressed bytes @ 24fps\nAs no rate has been given, this limit will be used.\n");
    }
  } else
#line 6110
  if (parameters->max_comp_size > 1041666) {
    {
#line 6111
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1041666 compressed bytes @ 24fps\n-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\n");
#line 6115
    parameters->max_comp_size = 1041666;
    }
  }
#line 6118
  parameters->tcp_rates[0] = (OPJ_FLOAT32 )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (OPJ_FLOAT32 )((((OPJ_UINT32 )parameters->max_cs_size * 8U) * (image->comps + 0)->dx) * (image->comps + 0)->dy);
#line 6119
  return;
}
}
#line 6123 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image , OPJ_UINT16 rsiz , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  char signed_str[7] ;
  char unsigned_str[9] ;
  char *tmp_str ;
  char *tmp ;

  {
#line 6128
  if (image->numcomps != 3U) {
    {
#line 6129
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\n3 components-> Number of components of input image (%d) is not compliant\n-> Non-profile-3 codestream will be generated\n",
                  image->numcomps);
    }
#line 6135
    return (0);
  }
#line 6139
  i = (OPJ_UINT32 )0;
  {
#line 6139
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6139
    if (! (i < image->numcomps)) {
#line 6139
      goto while_break;
    }
#line 6140
    if ((unsigned int )((image->comps + i)->bpp != 12U) | (image->comps + i)->sgnd) {
      {
#line 6141
      strcpy(signed_str, "signed");
#line 6142
      strcpy(unsigned_str, "unsigned\f");
      }
#line 6143
      if ((image->comps + i)->sgnd) {
#line 6143
        tmp = signed_str;
      } else {
#line 6143
        tmp = unsigned_str;
      }
      {
#line 6143
      tmp_str = tmp;
#line 6144
      opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nPrecision of each component shall be 12 bits unsigned-> At least component %d of input image (%d bits, %s) is not compliant\n-> Non-profile-3 codestream will be generated\n",
                    i, (image->comps + i)->bpp, tmp_str);
      }
#line 6150
      return (0);
    }
#line 6139
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 6156
  if ((int )rsiz == 3) {
#line 6156
    goto case_3;
  }
#line 6167
  if ((int )rsiz == 4) {
#line 6167
    goto case_4;
  }
#line 6178
  goto switch_default;
  case_3: 
#line 6157
  if (((image->comps + 0)->w > 2048U) | ((image->comps + 0)->h > 1080U)) {
    {
#line 6158
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nwidth <= 2048 and height <= 1080\n-> Input image size %d x %d is not compliant\n-> Non-profile-3 codestream will be generated\n",
                  (image->comps + 0)->w, (image->comps + 0)->h);
    }
#line 6164
    return (0);
  }
#line 6166
  goto switch_break;
  case_4: 
#line 6168
  if (((image->comps + 0)->w > 4096U) | ((image->comps + 0)->h > 2160U)) {
    {
#line 6169
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nwidth <= 4096 and height <= 2160\n-> Image size %d x %d is not compliant\n-> Non-profile-4 codestream will be generated\n\230\001",
                  (image->comps + 0)->w, (image->comps + 0)->h);
    }
#line 6175
    return (0);
  }
#line 6177
  goto switch_break;
  switch_default: 
#line 6179
  goto switch_break;
  switch_break: ;
#line 6182
  return (1);
}
}
#line 6185 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_setup_encoder(opj_j2k_t *p_j2k , opj_cparameters_t *parameters ,
                               opj_image_t *image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 tileno ;
  OPJ_UINT32 numpocs_tile ;
  opj_cp_t *cp ;
  OPJ_BOOL deprecated_used ;
  OPJ_FLOAT32 temp_size ;
  double __cil_tmp12 ;
  OPJ_FLOAT32 temp_rate ;
  OPJ_BOOL cap ;
  OPJ_BOOL __cil_tmp16 ;
  size_t array_size ;
  void *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  void *__cil_tmp20 ;
  char comment[29] ;
  size_t clen ;
  unsigned long __cil_tmp23 ;
  char const   *version ;
  char const   *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  void *__cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;
  void *__cil_tmp30 ;
  opj_tcp_t *tcp ;
  opj_poc_t *tcp_poc ;
  void *__cil_tmp36 ;
  OPJ_UINT32 lMctSize ;
  OPJ_FLOAT32 *lTmpBuf ;
  void *__cil_tmp39 ;
  OPJ_INT32 *l_dc_shift ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  OPJ_BOOL __cil_tmp43 ;
  void *__cil_tmp44 ;
  opj_tccp_t *tccp ;
  OPJ_BOOL __cil_tmp47 ;
  opj_tccp_t *tccp___0 ;
  opj_image_comp_t *l_comp ;
  opj_tccp_t *tccp___1 ;
  OPJ_INT32 __cil_tmp52 ;
  OPJ_INT32 __cil_tmp53 ;
  int tmp ;
  int tmp___0 ;
  OPJ_INT32 p ;
  OPJ_INT32 it_res ;
  OPJ_INT32 __cil_tmp59 ;
  OPJ_INT32 __cil_tmp60 ;
  OPJ_INT32 res_spec ;
  OPJ_INT32 size_prcw ;
  OPJ_INT32 size_prch ;
  OPJ_INT32 __cil_tmp65 ;
  OPJ_INT32 __cil_tmp66 ;
  OPJ_INT32 __cil_tmp68 ;

  {
#line 6191
  cp = (opj_cp_t *)0;
#line 6193
  if (! p_j2k) {
#line 6194
    return (0);
  } else
#line 6193
  if (! parameters) {
#line 6194
    return (0);
  } else
#line 6193
  if (! image) {
#line 6194
    return (0);
  }
#line 6197
  if (parameters->numresolution <= 0) {
    {
#line 6198
    opj_event_msg(p_manager, 1, "Invalid number of resolutions : %d not in range [1,%d]\n",
                  parameters->numresolution, 33);
    }
#line 6199
    return (0);
  } else
#line 6197
  if (parameters->numresolution > 33) {
    {
#line 6198
    opj_event_msg(p_manager, 1, "Invalid number of resolutions : %d not in range [1,%d]\n",
                  parameters->numresolution, 33);
    }
#line 6199
    return (0);
  }
#line 6203
  cp = & p_j2k->m_cp;
#line 6206
  cp->tw = (OPJ_UINT32 )1;
#line 6207
  cp->th = (OPJ_UINT32 )1;
#line 6210
  if ((int )parameters->rsiz == 0) {
#line 6211
    deprecated_used = 0;
#line 6213
    if ((unsigned int )parameters->cp_cinema == 1U) {
#line 6213
      goto case_1;
    }
#line 6219
    if ((unsigned int )parameters->cp_cinema == 2U) {
#line 6219
      goto case_2;
    }
#line 6225
    if ((unsigned int )parameters->cp_cinema == 3U) {
#line 6225
      goto case_3;
    }
#line 6232
    goto switch_default;
    case_1: 
#line 6214
    parameters->rsiz = (OPJ_UINT16 )3;
#line 6215
    parameters->max_cs_size = 1302083;
#line 6216
    parameters->max_comp_size = 1041666;
#line 6217
    deprecated_used = 1;
#line 6218
    goto switch_break;
    case_2: 
#line 6220
    parameters->rsiz = (OPJ_UINT16 )3;
#line 6221
    parameters->max_cs_size = 651041;
#line 6222
    parameters->max_comp_size = 520833;
#line 6223
    deprecated_used = 1;
#line 6224
    goto switch_break;
    case_3: 
#line 6226
    parameters->rsiz = (OPJ_UINT16 )4;
#line 6227
    parameters->max_cs_size = 1302083;
#line 6228
    parameters->max_comp_size = 1041666;
#line 6229
    deprecated_used = 1;
#line 6230
    goto switch_break;
    switch_default: 
#line 6233
    goto switch_break;
    switch_break: ;
#line 6236
    if ((unsigned int )parameters->cp_rsiz == 3U) {
#line 6236
      goto case_3___0;
    }
#line 6240
    if ((unsigned int )parameters->cp_rsiz == 4U) {
#line 6240
      goto case_4;
    }
#line 6244
    if ((unsigned int )parameters->cp_rsiz == 33024U) {
#line 6244
      goto case_33024;
    }
#line 6248
    goto switch_default___0;
    case_3___0: 
#line 6237
    parameters->rsiz = (OPJ_UINT16 )3;
#line 6238
    deprecated_used = 1;
#line 6239
    goto switch_break___0;
    case_4: 
#line 6241
    parameters->rsiz = (OPJ_UINT16 )4;
#line 6242
    deprecated_used = 1;
#line 6243
    goto switch_break___0;
    case_33024: 
#line 6245
    parameters->rsiz = (OPJ_UINT16 )33024;
#line 6246
    deprecated_used = 1;
    switch_default___0: 
#line 6249
    goto switch_break___0;
    switch_break___0: ;
#line 6251
    if (deprecated_used) {
      {
#line 6252
      opj_event_msg(p_manager, 2, "Deprecated fields cp_cinema or cp_rsiz are used\nPlease consider using only the rsiz field\nSee openjpeg.h documentation for more details\n\220");
      }
    }
  }
#line 6260
  if (parameters->max_cs_size <= 0) {
#line 6261
    if (parameters->tcp_rates[parameters->tcp_numlayers - 1] > (float )0) {
      {
#line 6263
      temp_size = (OPJ_FLOAT32 )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (((parameters->tcp_rates[parameters->tcp_numlayers - 1] * (float )8) * (OPJ_FLOAT32 )(image->comps + 0)->dx) * (OPJ_FLOAT32 )(image->comps + 0)->dy);
#line 6265
      __cil_tmp12 = floor((double )temp_size);
#line 6265
      parameters->max_cs_size = (int )__cil_tmp12;
      }
    } else {
#line 6267
      parameters->max_cs_size = 0;
    }
  } else {
#line 6271
    cap = 0;
#line 6272
    temp_rate = (OPJ_FLOAT32 )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (OPJ_FLOAT32 )((((OPJ_UINT32 )parameters->max_cs_size * 8U) * (image->comps + 0)->dx) * (image->comps + 0)->dy);
#line 6274
    i = (OPJ_UINT32 )0;
    {
#line 6274
    while (1) {
      while_continue: /* CIL Label */ ;

#line 6274
      if (! (i < (OPJ_UINT32 )parameters->tcp_numlayers)) {
#line 6274
        goto while_break;
      }
#line 6275
      if (parameters->tcp_rates[i] < temp_rate) {
#line 6276
        parameters->tcp_rates[i] = temp_rate;
#line 6277
        cap = 1;
      }
#line 6274
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break: ;
#line 6280
    if (cap) {
      {
#line 6281
      opj_event_msg(p_manager, 2, "The desired maximum codestream size has limited\nat least one of the desired quality layers\n");
      }
    }
  }
#line 6289
  if ((int )parameters->rsiz >= 3) {
#line 6289
    if ((int )parameters->rsiz <= 6) {
#line 6290
      if ((int )parameters->rsiz == 5) {
        {
#line 6292
        opj_event_msg(p_manager, 2, "JPEG 2000 Scalable Digital Cinema profiles not yet supported\n");
#line 6294
        parameters->rsiz = (OPJ_UINT16 )0;
        }
      } else
#line 6290
      if ((int )parameters->rsiz == 6) {
        {
#line 6292
        opj_event_msg(p_manager, 2, "JPEG 2000 Scalable Digital Cinema profiles not yet supported\n");
#line 6294
        parameters->rsiz = (OPJ_UINT16 )0;
        }
      } else {
        {
#line 6296
        opj_j2k_set_cinema_parameters(parameters, image, p_manager);
#line 6297
        __cil_tmp16 = opj_j2k_is_cinema_compliant(image, parameters->rsiz, p_manager);
        }
#line 6297
        if (! __cil_tmp16) {
#line 6298
          parameters->rsiz = (OPJ_UINT16 )0;
        }
      }
    } else {
#line 6289
      goto _L___2;
    }
  } else
  _L___2: 
#line 6301
  if ((int )parameters->rsiz == 7) {
    {
#line 6302
    opj_event_msg(p_manager, 2, "JPEG 2000 Long Term Storage profile not yet supported\n");
#line 6304
    parameters->rsiz = (OPJ_UINT16 )0;
    }
  } else
#line 6305
  if ((int )parameters->rsiz >= 256) {
#line 6305
    if ((int )parameters->rsiz <= 779) {
      {
#line 6306
      opj_event_msg(p_manager, 2, "JPEG 2000 Broadcast profiles not yet supported\n");
#line 6308
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    } else {
#line 6305
      goto _L___1;
    }
  } else
  _L___1: 
#line 6309
  if ((int )parameters->rsiz >= 1024) {
#line 6309
    if ((int )parameters->rsiz <= 2203) {
      {
#line 6310
      opj_event_msg(p_manager, 2, "JPEG 2000 IMF profiles not yet supported\n");
#line 6312
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    } else {
#line 6309
      goto _L;
    }
  } else
  _L: 
#line 6313
  if ((int )parameters->rsiz & 32768) {
#line 6314
    if ((int )parameters->rsiz == 32768) {
      {
#line 6315
      opj_event_msg(p_manager, 2, "JPEG 2000 Part-2 profile defined\nbut no Part-2 extension enabled.\nProfile set to NONE.\n");
#line 6319
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    } else
#line 6320
    if ((int )parameters->rsiz != 33024) {
      {
#line 6321
      opj_event_msg(p_manager, 2, "Unsupported Part-2 extension enabled\nProfile set to NONE.\n");
#line 6324
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    }
  }
#line 6331
  cp->m_specific_param.m_enc.m_max_comp_size = (OPJ_UINT32 )parameters->max_comp_size;
#line 6332
  cp->rsiz = parameters->rsiz;
#line 6333
  cp->m_specific_param.m_enc.m_disto_alloc = (OPJ_UINT32 )parameters->cp_disto_alloc & 1U;
#line 6334
  cp->m_specific_param.m_enc.m_fixed_alloc = (OPJ_UINT32 )parameters->cp_fixed_alloc & 1U;
#line 6335
  cp->m_specific_param.m_enc.m_fixed_quality = (OPJ_UINT32 )parameters->cp_fixed_quality & 1U;
#line 6338
  if (parameters->cp_matrice) {
#line 6338
    if (parameters->cp_fixed_alloc) {
      {
#line 6339
      array_size = (((size_t )parameters->tcp_numlayers * (size_t )parameters->numresolution) * 3UL) * sizeof(OPJ_INT32 );
#line 6340
      __cil_tmp18 = malloc(array_size);
#line 6340
      cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *)__cil_tmp18;
      }
#line 6341
      if (! cp->m_specific_param.m_enc.m_matrice) {
        {
#line 6342
        opj_event_msg(p_manager, 1, "Not enough memory to allocate copy of user encoding parameters matrix \n");
        }
#line 6343
        return (0);
      }
      {
#line 6345
      memcpy((void *)cp->m_specific_param.m_enc.m_matrice, (void const   *)parameters->cp_matrice,
             array_size);
      }
    }
  }
#line 6349
  cp->tdx = (OPJ_UINT32 )parameters->cp_tdx;
#line 6350
  cp->tdy = (OPJ_UINT32 )parameters->cp_tdy;
#line 6353
  cp->tx0 = (OPJ_UINT32 )parameters->cp_tx0;
#line 6354
  cp->ty0 = (OPJ_UINT32 )parameters->cp_ty0;
#line 6357
  if (parameters->cp_comment) {
    {
#line 6358
    __cil_tmp19 = strlen((char const   *)parameters->cp_comment);
#line 6358
    __cil_tmp20 = malloc(__cil_tmp19 + 1UL);
#line 6358
    cp->comment = (char *)__cil_tmp20;
    }
#line 6359
    if (! cp->comment) {
      {
#line 6360
      opj_event_msg(p_manager, 1, "Not enough memory to allocate copy of comment string\n");
      }
#line 6361
      return (0);
    }
    {
#line 6363
    strcpy(cp->comment, (char const   *)parameters->cp_comment);
    }
  } else {
    {
#line 6366
    strcpy(comment, "Created by OpenJPEG version ");
#line 6367
    __cil_tmp23 = strlen((char const   *)(comment));
#line 6367
    clen = __cil_tmp23;
#line 6368
    __cil_tmp25 = opj_version();
#line 6368
    version = __cil_tmp25;
#line 6379
    __cil_tmp26 = strlen(version);
#line 6379
    __cil_tmp27 = malloc((clen + __cil_tmp26) + 1UL);
#line 6379
    cp->comment = (char *)__cil_tmp27;
    }
#line 6380
    if (! cp->comment) {
      {
#line 6381
      opj_event_msg(p_manager, 1, "Not enough memory to allocate comment string\n");
      }
#line 6382
      return (0);
    }
    {
#line 6384
    sprintf(cp->comment, "%s%s", (char const   *)(comment), version);
    }
  }
#line 6393
  if (parameters->tile_size_on) {
    {
#line 6394
    __cil_tmp28 = opj_int_ceildiv((OPJ_INT32 )(image->x1 - cp->tx0), (OPJ_INT32 )cp->tdx);
#line 6394
    cp->tw = (OPJ_UINT32 )__cil_tmp28;
#line 6395
    __cil_tmp29 = opj_int_ceildiv((OPJ_INT32 )(image->y1 - cp->ty0), (OPJ_INT32 )cp->tdy);
#line 6395
    cp->th = (OPJ_UINT32 )__cil_tmp29;
    }
  } else {
#line 6397
    cp->tdx = image->x1 - cp->tx0;
#line 6398
    cp->tdy = image->y1 - cp->ty0;
  }
#line 6401
  if (parameters->tp_on) {
#line 6402
    cp->m_specific_param.m_enc.m_tp_flag = (OPJ_BYTE )parameters->tp_flag;
#line 6403
    cp->m_specific_param.m_enc.m_tp_on = (OPJ_UINT32 )1;
  }
  {
#line 6464
  __cil_tmp30 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 6464
  cp->tcps = (opj_tcp_t *)__cil_tmp30;
  }
#line 6465
  if (! cp->tcps) {
    {
#line 6466
    opj_event_msg(p_manager, 1, "Not enough memory to allocate tile coding parameters\n");
    }
#line 6467
    return (0);
  }
#line 6469
  if (parameters->numpocs) {
    {
#line 6471
    opj_j2k_check_poc_val(parameters->POC, parameters->numpocs, (OPJ_UINT32 )parameters->numresolution,
                          image->numcomps, (OPJ_UINT32 )parameters->tcp_numlayers,
                          p_manager);
    }
  }
#line 6475
  tileno = (OPJ_UINT32 )0;
  {
#line 6475
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 6475
    if (! (tileno < cp->tw * cp->th)) {
#line 6475
      goto while_break___0;
    }
#line 6476
    tcp = cp->tcps + tileno;
#line 6477
    tcp->numlayers = (OPJ_UINT32 )parameters->tcp_numlayers;
#line 6479
    j = (OPJ_UINT32 )0;
    {
#line 6479
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 6479
      if (! (j < tcp->numlayers)) {
#line 6479
        goto while_break___1;
      }
#line 6480
      if ((int )cp->rsiz >= 3) {
#line 6480
        if ((int )cp->rsiz <= 6) {
#line 6481
          if (cp->m_specific_param.m_enc.m_fixed_quality) {
#line 6482
            tcp->distoratio[j] = parameters->tcp_distoratio[j];
          }
#line 6484
          tcp->rates[j] = parameters->tcp_rates[j];
        } else {
#line 6480
          goto _L___3;
        }
      } else
      _L___3: 
#line 6486
      if (cp->m_specific_param.m_enc.m_fixed_quality) {
#line 6487
        tcp->distoratio[j] = parameters->tcp_distoratio[j];
      } else {
#line 6489
        tcp->rates[j] = parameters->tcp_rates[j];
      }
#line 6479
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___1: 
#line 6494
    tcp->csty = (OPJ_UINT32 )parameters->csty;
#line 6495
    tcp->prg = parameters->prog_order;
#line 6496
    tcp->mct = (OPJ_UINT32 )parameters->tcp_mct;
#line 6498
    numpocs_tile = (OPJ_UINT32 )0;
#line 6499
    tcp->POC = (OPJ_UINT32 )0;
#line 6501
    if (parameters->numpocs) {
#line 6503
      tcp->POC = (OPJ_UINT32 )1;
#line 6504
      i = (OPJ_UINT32 )0;
      {
#line 6504
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 6504
        if (! (i < parameters->numpocs)) {
#line 6504
          goto while_break___2;
        }
#line 6505
        if (tileno + 1U == parameters->POC[i].tile) {
#line 6506
          tcp_poc = & tcp->pocs[numpocs_tile];
#line 6508
          tcp_poc->resno0 = parameters->POC[numpocs_tile].resno0;
#line 6509
          tcp_poc->compno0 = parameters->POC[numpocs_tile].compno0;
#line 6510
          tcp_poc->layno1 = parameters->POC[numpocs_tile].layno1;
#line 6511
          tcp_poc->resno1 = parameters->POC[numpocs_tile].resno1;
#line 6512
          tcp_poc->compno1 = parameters->POC[numpocs_tile].compno1;
#line 6513
          tcp_poc->prg1 = parameters->POC[numpocs_tile].prg1;
#line 6514
          tcp_poc->tile = parameters->POC[numpocs_tile].tile;
#line 6516
          numpocs_tile ++;
        }
#line 6504
        i ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___2: 
#line 6520
      tcp->numpocs = numpocs_tile - 1U;
    } else {
#line 6522
      tcp->numpocs = (OPJ_UINT32 )0;
    }
    {
#line 6525
    __cil_tmp36 = calloc((unsigned long )image->numcomps, sizeof(opj_tccp_t ));
#line 6525
    tcp->tccps = (opj_tccp_t *)__cil_tmp36;
    }
#line 6526
    if (! tcp->tccps) {
      {
#line 6527
      opj_event_msg(p_manager, 1, "Not enough memory to allocate tile component coding parameters\n");
      }
#line 6528
      return (0);
    }
#line 6530
    if (parameters->mct_data) {
      {
#line 6532
      lMctSize = (image->numcomps * image->numcomps) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 6533
      __cil_tmp39 = malloc((unsigned long )lMctSize);
#line 6533
      lTmpBuf = (OPJ_FLOAT32 *)__cil_tmp39;
#line 6534
      l_dc_shift = (OPJ_INT32 *)((OPJ_BYTE *)parameters->mct_data + lMctSize);
      }
#line 6536
      if (! lTmpBuf) {
        {
#line 6537
        opj_event_msg(p_manager, 1, "Not enough memory to allocate temp buffer\n");
        }
#line 6538
        return (0);
      }
      {
#line 6541
      tcp->mct = (OPJ_UINT32 )2;
#line 6542
      __cil_tmp41 = malloc((unsigned long )lMctSize);
#line 6542
      tcp->m_mct_coding_matrix = (OPJ_FLOAT32 *)__cil_tmp41;
      }
#line 6543
      if (! tcp->m_mct_coding_matrix) {
        {
#line 6544
        free((void *)lTmpBuf);
#line 6545
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 6546
        opj_event_msg(p_manager, 1, "Not enough memory to allocate encoder MCT coding matrix \n");
        }
#line 6547
        return (0);
      }
      {
#line 6549
      memcpy((void *)tcp->m_mct_coding_matrix, (void const   *)parameters->mct_data,
             (unsigned long )lMctSize);
#line 6550
      memcpy((void *)lTmpBuf, (void const   *)parameters->mct_data, (unsigned long )lMctSize);
#line 6552
      __cil_tmp42 = malloc((unsigned long )lMctSize);
#line 6552
      tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp42;
      }
#line 6553
      if (! tcp->m_mct_decoding_matrix) {
        {
#line 6554
        free((void *)lTmpBuf);
#line 6555
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 6556
        opj_event_msg(p_manager, 1, "Not enough memory to allocate encoder MCT decoding matrix \n");
        }
#line 6557
        return (0);
      }
      {
#line 6559
      __cil_tmp43 = opj_matrix_inversion_f(lTmpBuf, tcp->m_mct_decoding_matrix, image->numcomps);
      }
#line 6559
      if (__cil_tmp43 == 0) {
        {
#line 6560
        free((void *)lTmpBuf);
#line 6561
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 6562
        opj_event_msg(p_manager, 1, "Failed to inverse encoder MCT decoding matrix \n");
        }
#line 6563
        return (0);
      }
      {
#line 6566
      __cil_tmp44 = malloc((unsigned long )image->numcomps * sizeof(OPJ_FLOAT64 ));
#line 6566
      tcp->mct_norms = (OPJ_FLOAT64 *)__cil_tmp44;
      }
#line 6568
      if (! tcp->mct_norms) {
        {
#line 6569
        free((void *)lTmpBuf);
#line 6570
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 6571
        opj_event_msg(p_manager, 1, "Not enough memory to allocate encoder MCT norms \n");
        }
#line 6572
        return (0);
      }
      {
#line 6574
      opj_calculate_norms(tcp->mct_norms, image->numcomps, tcp->m_mct_decoding_matrix);
#line 6575
      free((void *)lTmpBuf);
#line 6577
      i = (OPJ_UINT32 )0;
      }
      {
#line 6577
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 6577
        if (! (i < image->numcomps)) {
#line 6577
          goto while_break___3;
        }
#line 6578
        tccp = tcp->tccps + i;
#line 6579
        tccp->m_dc_level_shift = *(l_dc_shift + i);
#line 6577
        i ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___3: 
      {
#line 6582
      __cil_tmp47 = opj_j2k_setup_mct_encoding(tcp, image);
      }
#line 6582
      if (__cil_tmp47 == 0) {
        {
#line 6584
        opj_event_msg(p_manager, 1, "Failed to setup j2k mct encoding\n");
        }
#line 6585
        return (0);
      }
    } else {
#line 6589
      if (tcp->mct == 1U) {
#line 6589
        if (image->numcomps >= 3U) {
#line 6590
          if ((image->comps + 0)->dx != (image->comps + 1)->dx) {
            {
#line 6594
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
#line 6595
            tcp->mct = (OPJ_UINT32 )0;
            }
          } else
#line 6590
          if ((image->comps + 0)->dx != (image->comps + 2)->dx) {
            {
#line 6594
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
#line 6595
            tcp->mct = (OPJ_UINT32 )0;
            }
          } else
#line 6590
          if ((image->comps + 0)->dy != (image->comps + 1)->dy) {
            {
#line 6594
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
#line 6595
            tcp->mct = (OPJ_UINT32 )0;
            }
          } else
#line 6590
          if ((image->comps + 0)->dy != (image->comps + 2)->dy) {
            {
#line 6594
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
#line 6595
            tcp->mct = (OPJ_UINT32 )0;
            }
          }
        }
      }
#line 6598
      i = (OPJ_UINT32 )0;
      {
#line 6598
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 6598
        if (! (i < image->numcomps)) {
#line 6598
          goto while_break___4;
        }
#line 6599
        tccp___0 = tcp->tccps + i;
#line 6600
        l_comp = image->comps + i;
#line 6602
        if (! l_comp->sgnd) {
#line 6603
          tccp___0->m_dc_level_shift = 1 << (l_comp->prec - 1U);
        }
#line 6598
        i ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___4: ;
    }
#line 6608
    i = (OPJ_UINT32 )0;
    {
#line 6608
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 6608
      if (! (i < image->numcomps)) {
#line 6608
        goto while_break___5;
      }
      {
#line 6609
      tccp___1 = tcp->tccps + i;
#line 6611
      tccp___1->csty = (OPJ_UINT32 )(parameters->csty & 1);
#line 6612
      tccp___1->numresolutions = (OPJ_UINT32 )parameters->numresolution;
#line 6613
      __cil_tmp52 = opj_int_floorlog2(parameters->cblockw_init);
#line 6613
      tccp___1->cblkw = (OPJ_UINT32 )__cil_tmp52;
#line 6614
      __cil_tmp53 = opj_int_floorlog2(parameters->cblockh_init);
#line 6614
      tccp___1->cblkh = (OPJ_UINT32 )__cil_tmp53;
#line 6615
      tccp___1->cblksty = (OPJ_UINT32 )parameters->mode;
      }
#line 6616
      if (parameters->irreversible) {
#line 6616
        tmp = 0;
      } else {
#line 6616
        tmp = 1;
      }
#line 6616
      tccp___1->qmfbid = (OPJ_UINT32 )tmp;
#line 6617
      if (parameters->irreversible) {
#line 6617
        tmp___0 = 2;
      } else {
#line 6617
        tmp___0 = 0;
      }
#line 6617
      tccp___1->qntsty = (OPJ_UINT32 )tmp___0;
#line 6618
      tccp___1->numgbits = (OPJ_UINT32 )2;
#line 6620
      if ((OPJ_INT32 )i == parameters->roi_compno) {
#line 6621
        tccp___1->roishift = parameters->roi_shift;
      } else {
#line 6623
        tccp___1->roishift = 0;
      }
#line 6626
      if (parameters->csty & 1) {
#line 6627
        p = 0;
#line 6629
        it_res = (OPJ_INT32 )tccp___1->numresolutions - 1;
        {
#line 6629
        while (1) {
          while_continue___6: /* CIL Label */ ;

#line 6629
          if (! (it_res >= 0)) {
#line 6629
            goto while_break___6;
          }
#line 6630
          if (p < parameters->res_spec) {
#line 6632
            if (parameters->prcw_init[p] < 1) {
#line 6633
              tccp___1->prcw[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 6635
              __cil_tmp59 = opj_int_floorlog2(parameters->prcw_init[p]);
#line 6635
              tccp___1->prcw[it_res] = (OPJ_UINT32 )__cil_tmp59;
              }
            }
#line 6638
            if (parameters->prch_init[p] < 1) {
#line 6639
              tccp___1->prch[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 6641
              __cil_tmp60 = opj_int_floorlog2(parameters->prch_init[p]);
#line 6641
              tccp___1->prch[it_res] = (OPJ_UINT32 )__cil_tmp60;
              }
            }
          } else {
#line 6645
            res_spec = parameters->res_spec;
#line 6646
            size_prcw = 0;
#line 6647
            size_prch = 0;
#line 6650
            size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
#line 6651
            size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));
#line 6654
            if (size_prcw < 1) {
#line 6655
              tccp___1->prcw[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 6657
              __cil_tmp65 = opj_int_floorlog2(size_prcw);
#line 6657
              tccp___1->prcw[it_res] = (OPJ_UINT32 )__cil_tmp65;
              }
            }
#line 6660
            if (size_prch < 1) {
#line 6661
              tccp___1->prch[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 6663
              __cil_tmp66 = opj_int_floorlog2(size_prch);
#line 6663
              tccp___1->prch[it_res] = (OPJ_UINT32 )__cil_tmp66;
              }
            }
          }
#line 6666
          p ++;
#line 6629
          __cil_tmp68 = it_res;
#line 6629
          it_res --;
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break___6: ;
      } else {
#line 6670
        j = (OPJ_UINT32 )0;
        {
#line 6670
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 6670
          if (! (j < tccp___1->numresolutions)) {
#line 6670
            goto while_break___7;
          }
#line 6671
          tccp___1->prcw[j] = (OPJ_UINT32 )15;
#line 6672
          tccp___1->prch[j] = (OPJ_UINT32 )15;
#line 6670
          j ++;
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___7: ;
      }
      {
#line 6676
      opj_dwt_calc_explicit_stepsizes(tccp___1, (image->comps + i)->prec);
#line 6608
      i ++;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___5: 
#line 6475
    tileno ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___0: ;
#line 6680
  if (parameters->mct_data) {
    {
#line 6681
    free(parameters->mct_data);
#line 6682
    parameters->mct_data = (void *)0;
    }
  }
#line 6684
  return (1);
}
}
#line 6687 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index , OPJ_UINT32 type ,
                                     OPJ_OFF_T pos , OPJ_UINT32 len ) 
{ 
  opj_marker_info_t *new_marker ;
  void *__cil_tmp7 ;

  {
#line 6692
  if (cstr_index->marknum + 1U > cstr_index->maxmarknum) {
    {
#line 6694
    cstr_index->maxmarknum = (OPJ_UINT32 )((float )100 + (OPJ_FLOAT32 )cstr_index->maxmarknum);
#line 6695
    __cil_tmp7 = realloc((void *)cstr_index->marker, (unsigned long )cstr_index->maxmarknum * sizeof(opj_marker_info_t ));
#line 6695
    new_marker = (opj_marker_info_t *)__cil_tmp7;
    }
#line 6696
    if (! new_marker) {
      {
#line 6697
      free((void *)cstr_index->marker);
#line 6698
      cstr_index->marker = (opj_marker_info_t *)((void *)0);
#line 6699
      cstr_index->maxmarknum = (OPJ_UINT32 )0;
#line 6700
      cstr_index->marknum = (OPJ_UINT32 )0;
      }
#line 6702
      return (0);
    }
#line 6704
    cstr_index->marker = new_marker;
  }
#line 6708
  (cstr_index->marker + cstr_index->marknum)->type = (OPJ_UINT16 )type;
#line 6709
  (cstr_index->marker + cstr_index->marknum)->pos = (OPJ_OFF_T )((OPJ_INT32 )pos);
#line 6710
  (cstr_index->marker + cstr_index->marknum)->len = (OPJ_INT32 )len;
#line 6711
  (cstr_index->marknum) ++;
#line 6712
  return (1);
}
}
#line 6715 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno , opj_codestream_index_t *cstr_index ,
                                     OPJ_UINT32 type , OPJ_OFF_T pos , OPJ_UINT32 len ) 
{ 
  opj_marker_info_t *new_marker ;
  void *__cil_tmp9 ;
  OPJ_UINT32 l_current_tile_part ;

  {
#line 6721
  if ((cstr_index->tile_index + tileno)->marknum + 1U > (cstr_index->tile_index + tileno)->maxmarknum) {
    {
#line 6723
    (cstr_index->tile_index + tileno)->maxmarknum = (OPJ_UINT32 )((float )100 + (OPJ_FLOAT32 )(cstr_index->tile_index + tileno)->maxmarknum);
#line 6724
    __cil_tmp9 = realloc((void *)(cstr_index->tile_index + tileno)->marker, (unsigned long )(cstr_index->tile_index + tileno)->maxmarknum * sizeof(opj_marker_info_t ));
#line 6724
    new_marker = (opj_marker_info_t *)__cil_tmp9;
    }
#line 6727
    if (! new_marker) {
      {
#line 6728
      free((void *)(cstr_index->tile_index + tileno)->marker);
#line 6729
      (cstr_index->tile_index + tileno)->marker = (opj_marker_info_t *)((void *)0);
#line 6730
      (cstr_index->tile_index + tileno)->maxmarknum = (OPJ_UINT32 )0;
#line 6731
      (cstr_index->tile_index + tileno)->marknum = (OPJ_UINT32 )0;
      }
#line 6733
      return (0);
    }
#line 6735
    (cstr_index->tile_index + tileno)->marker = new_marker;
  }
#line 6739
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->type = (OPJ_UINT16 )type;
#line 6740
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->pos = (OPJ_OFF_T )((OPJ_INT32 )pos);
#line 6741
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->len = (OPJ_INT32 )len;
#line 6742
  ((cstr_index->tile_index + tileno)->marknum) ++;
#line 6744
  if (type == 65424U) {
#line 6745
    l_current_tile_part = (cstr_index->tile_index + tileno)->current_tpsno;
#line 6747
    if ((cstr_index->tile_index + tileno)->tp_index) {
#line 6748
      ((cstr_index->tile_index + tileno)->tp_index + l_current_tile_part)->start_pos = pos;
    }
  }
#line 6751
  return (1);
}
}
#line 6760 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) 
{ 


  {
#line 6768
  return (1);
}
}
#line 6771 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream , opj_j2k_t *p_j2k , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 6782
  p_j2k->m_private_image = opj_image_create0();
  }
#line 6783
  if (! p_j2k->m_private_image) {
#line 6784
    return (0);
  }
  {
#line 6788
  opj_j2k_setup_decoding_validation(p_j2k);
#line 6791
  __cil_tmp9 = opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager);
  }
#line 6791
  if (! __cil_tmp9) {
    {
#line 6792
    opj_image_destroy(p_j2k->m_private_image);
#line 6793
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 6794
    return (0);
  }
  {
#line 6798
  opj_j2k_setup_header_reading(p_j2k);
#line 6801
  __cil_tmp10 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 6801
  if (! __cil_tmp10) {
    {
#line 6802
    opj_image_destroy(p_j2k->m_private_image);
#line 6803
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 6804
    return (0);
  }
  {
#line 6807
  *p_image = opj_image_create0();
  }
#line 6808
  if (! *p_image) {
#line 6809
    return (0);
  }
  {
#line 6813
  opj_copy_image_header(p_j2k->m_private_image, *p_image);
#line 6816
  __cil_tmp12 = opj_j2k_allocate_tile_element_cstr_index(p_j2k);
  }
#line 6816
  if (! __cil_tmp12) {
#line 6817
    return (0);
  }
#line 6820
  return (1);
}
}
#line 6823 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_setup_header_reading(opj_j2k_t *p_j2k ) 
{ 


  {
  {
#line 6828
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_read_header_procedure));
#line 6831
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_copy_default_tcp_and_create_tcd));
  }
#line 6833
  return;
}
}
#line 6835 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k ) 
{ 


  {
  {
#line 6840
  opj_procedure_list_add_procedure(p_j2k->m_validation_list, (void (*)(void))(& opj_j2k_build_decoder));
#line 6841
  opj_procedure_list_add_procedure(p_j2k->m_validation_list, (void (*)(void))(& opj_j2k_decoding_validation));
  }
#line 6843
  return;
}
}
#line 6846 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 6850
  l_is_valid = 1;
#line 6858
  if (((int )p_j2k->m_cp.rsiz & 33280) == 33280) {
#line 6859
    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 6860
    l_tcp = p_j2k->m_cp.tcps;
#line 6862
    i = (OPJ_UINT32 )0;
    {
#line 6862
    while (1) {
      while_continue: /* CIL Label */ ;

#line 6862
      if (! (i < l_nb_tiles)) {
#line 6862
        goto while_break;
      }
#line 6863
      if (l_tcp->mct == 2U) {
#line 6864
        l_tccp = l_tcp->tccps;
#line 6865
        l_is_valid &= (unsigned long )l_tcp->m_mct_coding_matrix != (unsigned long )((OPJ_FLOAT32 *)0);
#line 6867
        j = (OPJ_UINT32 )0;
        {
#line 6867
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 6867
          if (! (j < (p_j2k->m_private_image)->numcomps)) {
#line 6867
            goto while_break___0;
          }
#line 6868
          l_is_valid &= ! (l_tccp->qmfbid & 1U);
#line 6869
          l_tccp ++;
#line 6867
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: ;
      }
#line 6872
      l_tcp ++;
#line 6862
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 6876
  return (l_is_valid);
}
}
#line 6879 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t *p_tcp , opj_image_t *p_image ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_indix ;
  opj_mct_data_t *l_mct_deco_data ;
  opj_mct_data_t *l_mct_offset_data ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_data ;
  OPJ_UINT32 l_mct_size ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_FLOAT32 *l_data ;
  OPJ_FLOAT32 *l_current_data ;
  opj_tccp_t *l_tccp ;
  opj_mct_data_t *new_mct_records ;
  void *__cil_tmp15 ;
  OPJ_UINT32 __cil_tmp16 ;
  void *__cil_tmp17 ;
  opj_mct_data_t *new_mct_records___0 ;
  void *__cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  OPJ_FLOAT32 *__cil_tmp23 ;
  opj_simple_mcc_decorrelation_data_t *new_mcc_records ;
  void *__cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;

  {
#line 6882
  l_indix = (OPJ_UINT32 )1;
#line 6883
  l_mct_deco_data = (opj_mct_data_t *)0;
#line 6883
  l_mct_offset_data = (opj_mct_data_t *)0;
#line 6892
  if (p_tcp->mct != 2U) {
#line 6893
    return (1);
  }
#line 6896
  if (p_tcp->m_mct_decoding_matrix) {
#line 6897
    if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
      {
#line 6899
      p_tcp->m_nb_max_mct_records += 10U;
#line 6901
      __cil_tmp15 = realloc((void *)p_tcp->m_mct_records, (unsigned long )p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 6901
      new_mct_records = (opj_mct_data_t *)__cil_tmp15;
      }
#line 6902
      if (! new_mct_records) {
        {
#line 6903
        free((void *)p_tcp->m_mct_records);
#line 6904
        p_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 6905
        p_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 6906
        p_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
        }
#line 6908
        return (0);
      }
      {
#line 6910
      p_tcp->m_mct_records = new_mct_records;
#line 6911
      l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 6913
      memset((void *)l_mct_deco_data, 0, (unsigned long )(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
      }
    }
#line 6915
    l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 6917
    if (l_mct_deco_data->m_data) {
      {
#line 6918
      free((void *)l_mct_deco_data->m_data);
#line 6919
      l_mct_deco_data->m_data = (OPJ_BYTE *)0;
      }
    }
    {
#line 6922
    __cil_tmp16 = l_indix;
#line 6922
    l_indix ++;
#line 6922
    l_mct_deco_data->m_index = __cil_tmp16;
#line 6923
    l_mct_deco_data->m_array_type = (J2K_MCT_ARRAY_TYPE )1;
#line 6924
    l_mct_deco_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )2;
#line 6925
    l_nb_elem = p_image->numcomps * p_image->numcomps;
#line 6926
    l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_deco_data->m_element_type];
#line 6927
    __cil_tmp17 = malloc((unsigned long )l_mct_size);
#line 6927
    l_mct_deco_data->m_data = (OPJ_BYTE *)__cil_tmp17;
    }
#line 6929
    if (! l_mct_deco_data->m_data) {
#line 6930
      return (0);
    }
    {
#line 6933
    (*(j2k_mct_write_functions_from_float[l_mct_deco_data->m_element_type]))((void const   *)p_tcp->m_mct_decoding_matrix,
                                                                             (void *)l_mct_deco_data->m_data,
                                                                             l_nb_elem);
#line 6935
    l_mct_deco_data->m_data_size = l_mct_size;
#line 6936
    (p_tcp->m_nb_mct_records) ++;
    }
  }
#line 6939
  if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
    {
#line 6941
    p_tcp->m_nb_max_mct_records += 10U;
#line 6942
    __cil_tmp19 = realloc((void *)p_tcp->m_mct_records, (unsigned long )p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 6942
    new_mct_records___0 = (opj_mct_data_t *)__cil_tmp19;
    }
#line 6943
    if (! new_mct_records___0) {
      {
#line 6944
      free((void *)p_tcp->m_mct_records);
#line 6945
      p_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 6946
      p_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 6947
      p_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
      }
#line 6949
      return (0);
    }
    {
#line 6951
    p_tcp->m_mct_records = new_mct_records___0;
#line 6952
    l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 6954
    memset((void *)l_mct_offset_data, 0, (unsigned long )(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
    }
#line 6956
    if (l_mct_deco_data) {
#line 6957
      l_mct_deco_data = l_mct_offset_data - 1;
    }
  }
#line 6961
  l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 6963
  if (l_mct_offset_data->m_data) {
    {
#line 6964
    free((void *)l_mct_offset_data->m_data);
#line 6965
    l_mct_offset_data->m_data = (OPJ_BYTE *)0;
    }
  }
  {
#line 6968
  __cil_tmp20 = l_indix;
#line 6968
  l_indix ++;
#line 6968
  l_mct_offset_data->m_index = __cil_tmp20;
#line 6969
  l_mct_offset_data->m_array_type = (J2K_MCT_ARRAY_TYPE )2;
#line 6970
  l_mct_offset_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )2;
#line 6971
  l_nb_elem = p_image->numcomps;
#line 6972
  l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_offset_data->m_element_type];
#line 6973
  __cil_tmp21 = malloc((unsigned long )l_mct_size);
#line 6973
  l_mct_offset_data->m_data = (OPJ_BYTE *)__cil_tmp21;
  }
#line 6975
  if (! l_mct_offset_data->m_data) {
#line 6976
    return (0);
  }
  {
#line 6979
  __cil_tmp22 = malloc((unsigned long )l_nb_elem * sizeof(OPJ_FLOAT32 ));
#line 6979
  l_data = (OPJ_FLOAT32 *)__cil_tmp22;
  }
#line 6980
  if (! l_data) {
    {
#line 6981
    free((void *)l_mct_offset_data->m_data);
#line 6982
    l_mct_offset_data->m_data = (OPJ_BYTE *)0;
    }
#line 6983
    return (0);
  }
#line 6986
  l_tccp = p_tcp->tccps;
#line 6987
  l_current_data = l_data;
#line 6989
  i = (OPJ_UINT32 )0;
  {
#line 6989
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6989
    if (! (i < l_nb_elem)) {
#line 6989
      goto while_break;
    }
#line 6990
    __cil_tmp23 = l_current_data;
#line 6990
    l_current_data ++;
#line 6990
    *__cil_tmp23 = (OPJ_FLOAT32 )l_tccp->m_dc_level_shift;
#line 6991
    l_tccp ++;
#line 6989
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 6994
  (*(j2k_mct_write_functions_from_float[l_mct_offset_data->m_element_type]))((void const   *)l_data,
                                                                             (void *)l_mct_offset_data->m_data,
                                                                             l_nb_elem);
#line 6996
  free((void *)l_data);
#line 6998
  l_mct_offset_data->m_data_size = l_mct_size;
#line 7000
  (p_tcp->m_nb_mct_records) ++;
  }
#line 7002
  if (p_tcp->m_nb_mcc_records == p_tcp->m_nb_max_mcc_records) {
    {
#line 7004
    p_tcp->m_nb_max_mcc_records += 10U;
#line 7005
    __cil_tmp25 = realloc((void *)p_tcp->m_mcc_records, (unsigned long )p_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 7005
    new_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp25;
    }
#line 7007
    if (! new_mcc_records) {
      {
#line 7008
      free((void *)p_tcp->m_mcc_records);
#line 7009
      p_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)((void *)0);
#line 7010
      p_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 7011
      p_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
      }
#line 7013
      return (0);
    }
    {
#line 7015
    p_tcp->m_mcc_records = new_mcc_records;
#line 7016
    l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
#line 7017
    memset((void *)l_mcc_data, 0, (unsigned long )(p_tcp->m_nb_max_mcc_records - p_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t ));
    }
  }
#line 7021
  l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
#line 7022
  l_mcc_data->m_decorrelation_array = l_mct_deco_data;
#line 7023
  l_mcc_data->m_is_irreversible = (OPJ_UINT32 )1;
#line 7024
  l_mcc_data->m_nb_comps = p_image->numcomps;
#line 7025
  __cil_tmp26 = l_indix;
#line 7025
  l_indix ++;
#line 7025
  l_mcc_data->m_index = __cil_tmp26;
#line 7026
  l_mcc_data->m_offset_array = l_mct_offset_data;
#line 7027
  (p_tcp->m_nb_mcc_records) ++;
#line 7029
  return (1);
}
}
#line 7032 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                               opj_event_mgr_t *p_manager ) 
{ 


  {
#line 7041
  return (1);
}
}
#line 7044 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                               opj_event_mgr_t *p_manager ) 
{ 


  {
#line 7053
  return (1);
}
}
#line 7056 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;

  {
#line 7060
  l_is_valid = 1;
#line 7069
  l_is_valid &= p_j2k->m_specific_param.m_decoder.m_state == 0U;
#line 7073
  l_is_valid &= (unsigned long )p_j2k->m_procedure_list != (unsigned long )((opj_procedure_list_t *)0);
#line 7075
  l_is_valid &= (unsigned long )p_j2k->m_validation_list != (unsigned long )((opj_procedure_list_t *)0);
#line 7081
  if (((p_j2k->m_cp.tcps)->tccps)->numresolutions <= 0U) {
    {
#line 7082
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\n\017");
    }
#line 7083
    return (0);
  } else
#line 7081
  if (((p_j2k->m_cp.tcps)->tccps)->numresolutions > 31U) {
    {
#line 7082
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\n\017");
    }
#line 7083
    return (0);
  }
#line 7086
  if (p_j2k->m_cp.tdx < (OPJ_UINT32 )(1 << ((p_j2k->m_cp.tcps)->tccps)->numresolutions)) {
    {
#line 7087
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\n\020");
    }
#line 7088
    return (0);
  }
#line 7091
  if (p_j2k->m_cp.tdy < (OPJ_UINT32 )(1 << ((p_j2k->m_cp.tcps)->tccps)->numresolutions)) {
    {
#line 7092
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\n\021");
    }
#line 7093
    return (0);
  }
#line 7097
  return (l_is_valid);
}
}
#line 7100 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;

  {
#line 7105
  l_is_valid = 1;
#line 7117
  l_is_valid &= p_j2k->m_specific_param.m_decoder.m_state == 0U;
#line 7122
  l_is_valid &= (unsigned long )p_j2k->m_procedure_list != (unsigned long )((opj_procedure_list_t *)0);
#line 7124
  l_is_valid &= (unsigned long )p_j2k->m_validation_list != (unsigned long )((opj_procedure_list_t *)0);
#line 7127
  return (l_is_valid);
}
}
#line 7130 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                       opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  OPJ_BOOL l_has_siz ;
  OPJ_BOOL l_has_cod ;
  OPJ_BOOL l_has_qcd ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_SIZE_T __cil_tmp18 ;
  OPJ_BYTE *new_header_data ;
  void *__cil_tmp20 ;
  OPJ_SIZE_T __cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;
  OPJ_OFF_T __cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;
  OPJ_SIZE_T __cil_tmp25 ;
  OPJ_OFF_T __cil_tmp26 ;

  {
  {
#line 7136
  l_marker_handler = (opj_dec_memory_marker_handler_t *)0;
#line 7137
  l_has_siz = 0;
#line 7138
  l_has_cod = 0;
#line 7139
  l_has_qcd = 0;
#line 7147
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )1;
#line 7150
  __cil_tmp13 = opj_j2k_read_soc(p_j2k, p_stream, p_manager);
  }
#line 7150
  if (! __cil_tmp13) {
    {
#line 7151
    opj_event_msg(p_manager, 1, "Expected a SOC marker \n");
    }
#line 7152
    return (0);
  }
  {
#line 7156
  __cil_tmp14 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                     (OPJ_SIZE_T )2, p_manager);
  }
#line 7156
  if (__cil_tmp14 != 2UL) {
    {
#line 7157
    opj_event_msg(p_manager, 1, "Stream too short\n\234\327iEV");
    }
#line 7158
    return (0);
  }
  {
#line 7162
  opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                    (OPJ_UINT32 )2);
  }
  {
#line 7165
  while (1) {
    while_continue: /* CIL Label */ ;

#line 7165
    if (! (l_current_marker != 65424U)) {
#line 7165
      goto while_break;
    }
#line 7168
    if (l_current_marker < 65280U) {
      {
#line 7169
      opj_event_msg(p_manager, 1, "We expected read a marker ID (0xff--) instead of %.8x\n",
                    l_current_marker);
      }
#line 7170
      return (0);
    }
    {
#line 7174
    l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
    }
#line 7177
    if (l_marker_handler->id == 0U) {
      {
#line 7178
      __cil_tmp16 = opj_j2k_read_unk(p_j2k, p_stream, & l_current_marker, p_manager);
      }
#line 7178
      if (! __cil_tmp16) {
        {
#line 7179
        opj_event_msg(p_manager, 1, "Unknow marker have been detected and generated error.\n");
        }
#line 7180
        return (0);
      }
#line 7183
      if (l_current_marker == 65424U) {
#line 7184
        goto while_break;
      } else {
        {
#line 7186
        l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
        }
      }
    }
#line 7189
    if (l_marker_handler->id == 65361U) {
#line 7191
      l_has_siz = 1;
    }
#line 7193
    if (l_marker_handler->id == 65362U) {
#line 7195
      l_has_cod = 1;
    }
#line 7197
    if (l_marker_handler->id == 65372U) {
#line 7199
      l_has_qcd = 1;
    }
#line 7203
    if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
      {
#line 7204
      opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n");
      }
#line 7205
      return (0);
    }
    {
#line 7209
    __cil_tmp18 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 7209
    if (__cil_tmp18 != 2UL) {
      {
#line 7210
      opj_event_msg(p_manager, 1, "Stream too short\n>\344iEV");
      }
#line 7211
      return (0);
    }
    {
#line 7215
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_marker_size,
                      (OPJ_UINT32 )2);
#line 7216
    l_marker_size -= 2U;
    }
#line 7219
    if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
      {
#line 7220
      __cil_tmp20 = realloc((void *)p_j2k->m_specific_param.m_decoder.m_header_data,
                            (unsigned long )l_marker_size);
#line 7220
      new_header_data = (OPJ_BYTE *)__cil_tmp20;
      }
#line 7221
      if (! new_header_data) {
        {
#line 7222
        free((void *)p_j2k->m_specific_param.m_decoder.m_header_data);
#line 7223
        p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)((void *)0);
#line 7224
        p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
#line 7225
        opj_event_msg(p_manager, 1, "Not enough memory to read header\n");
        }
#line 7226
        return (0);
      }
#line 7228
      p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
#line 7229
      p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
    }
    {
#line 7233
    __cil_tmp21 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )l_marker_size, p_manager);
    }
#line 7233
    if (__cil_tmp21 != (unsigned long )l_marker_size) {
      {
#line 7234
      opj_event_msg(p_manager, 1, "Stream too short\nS\344iEV");
      }
#line 7235
      return (0);
    }
    {
#line 7239
    __cil_tmp22 = (*(l_marker_handler->handler))(p_j2k, p_j2k->m_specific_param.m_decoder.m_header_data,
                                                 l_marker_size, p_manager);
    }
#line 7239
    if (! __cil_tmp22) {
      {
#line 7240
      opj_event_msg(p_manager, 1, "Marker handler function failed to read the marker segment\n\344iEV");
      }
#line 7241
      return (0);
    }
    {
#line 7245
    __cil_tmp23 = opj_stream_tell(p_stream);
#line 7245
    __cil_tmp24 = opj_j2k_add_mhmarker(p_j2k->cstr_index, l_marker_handler->id, (OPJ_OFF_T )(((OPJ_UINT32 )__cil_tmp23 - l_marker_size) - 4U),
                                       l_marker_size + 4U);
    }
#line 7245
    if (0 == __cil_tmp24) {
      {
#line 7250
      opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\niEV");
      }
#line 7251
      return (0);
    }
    {
#line 7255
    __cil_tmp25 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 7255
    if (__cil_tmp25 != 2UL) {
      {
#line 7256
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 7257
      return (0);
    }
    {
#line 7261
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                      (OPJ_UINT32 )2);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 7264
  if (l_has_siz == 0) {
    {
#line 7265
    opj_event_msg(p_manager, 1, "required SIZ marker not found in main header\n");
    }
#line 7266
    return (0);
  }
#line 7268
  if (l_has_cod == 0) {
    {
#line 7269
    opj_event_msg(p_manager, 1, "required COD marker not found in main header\n");
    }
#line 7270
    return (0);
  }
#line 7272
  if (l_has_qcd == 0) {
    {
#line 7273
    opj_event_msg(p_manager, 1, "required QCD marker not found in main header\n");
    }
#line 7274
    return (0);
  }
  {
#line 7277
  opj_event_msg(p_manager, 4, "Main header has been correctly decoded.\n\220");
#line 7280
  __cil_tmp26 = opj_stream_tell(p_stream);
#line 7280
  (p_j2k->cstr_index)->main_head_end = (OPJ_OFF_T )((OPJ_UINT32 )__cil_tmp26 - 2U);
#line 7283
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
  }
#line 7285
  return (1);
}
}
#line 7288 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_exec(opj_j2k_t *p_j2k , opj_procedure_list_t *p_procedure_list ,
                      opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL (**l_procedure)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ) ;
  OPJ_BOOL l_result ;
  OPJ_UINT32 l_nb_proc ;
  OPJ_UINT32 i ;
  opj_procedure *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  int tmp___3 ;

  {
  {
#line 7293
  l_procedure = (OPJ_BOOL (**)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ))0;
#line 7294
  l_result = 1;
#line 7303
  l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);
#line 7304
  __cil_tmp14 = opj_procedure_list_get_first_procedure(p_procedure_list);
#line 7304
  l_procedure = (OPJ_BOOL (**)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ))__cil_tmp14;
#line 7306
  i = (OPJ_UINT32 )0;
  }
  {
#line 7306
  while (1) {
    while_continue: /* CIL Label */ ;

#line 7306
    if (! (i < l_nb_proc)) {
#line 7306
      goto while_break;
    }
    {
#line 7307
    __cil_tmp15 = (*(*l_procedure))(p_j2k, p_stream, p_manager);
    }
#line 7307
    if (l_result) {
#line 7307
      if (__cil_tmp15) {
#line 7307
        tmp___3 = 1;
      } else {
#line 7307
        tmp___3 = 0;
      }
    } else {
#line 7307
      tmp___3 = 0;
    }
#line 7307
    l_result = tmp___3;
#line 7308
    l_procedure ++;
#line 7306
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 7312
  opj_procedure_list_clear(p_procedure_list);
  }
#line 7313
  return (l_result);
}
}
#line 7317 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                                        opj_event_mgr_t *p_manager ) 
{ 
  opj_tcp_t *l_tcp ;
  opj_tcp_t *l_default_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  opj_tccp_t *l_current_tccp ;
  OPJ_UINT32 l_tccp_size ;
  OPJ_UINT32 l_mct_size ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_mcc_records_size ;
  OPJ_UINT32 l_mct_records_size ;
  opj_mct_data_t *l_src_mct_rec ;
  opj_mct_data_t *l_dest_mct_rec ;
  opj_simple_mcc_decorrelation_data_t *l_src_mcc_rec ;
  opj_simple_mcc_decorrelation_data_t *l_dest_mcc_rec ;
  OPJ_UINT32 l_offset ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  opj_tcd_t *__cil_tmp27 ;
  OPJ_BOOL __cil_tmp28 ;

  {
#line 7322
  l_tcp = (opj_tcp_t *)0;
#line 7323
  l_default_tcp = (opj_tcp_t *)0;
#line 7326
  l_current_tccp = (opj_tccp_t *)0;
#line 7340
  l_image = p_j2k->m_private_image;
#line 7341
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 7342
  l_tcp = p_j2k->m_cp.tcps;
#line 7343
  l_tccp_size = l_image->numcomps * (OPJ_UINT32 )sizeof(opj_tccp_t );
#line 7344
  l_default_tcp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
#line 7345
  l_mct_size = (l_image->numcomps * l_image->numcomps) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 7348
  i = (OPJ_UINT32 )0;
  {
#line 7348
  while (1) {
    while_continue: /* CIL Label */ ;

#line 7348
    if (! (i < l_nb_tiles)) {
#line 7348
      goto while_break;
    }
    {
#line 7350
    l_current_tccp = l_tcp->tccps;
#line 7352
    memcpy((void *)l_tcp, (void const   *)l_default_tcp, sizeof(opj_tcp_t ));
#line 7354
    l_tcp->ppt = (OPJ_UINT32 )0;
#line 7355
    l_tcp->ppt_data = (OPJ_BYTE *)0;
#line 7357
    l_tcp->tccps = l_current_tccp;
    }
#line 7360
    if (l_default_tcp->m_mct_decoding_matrix) {
      {
#line 7361
      __cil_tmp23 = malloc((unsigned long )l_mct_size);
#line 7361
      l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp23;
      }
#line 7362
      if (! l_tcp->m_mct_decoding_matrix) {
#line 7363
        return (0);
      }
      {
#line 7365
      memcpy((void *)l_tcp->m_mct_decoding_matrix, (void const   *)l_default_tcp->m_mct_decoding_matrix,
             (unsigned long )l_mct_size);
      }
    }
    {
#line 7369
    l_mct_records_size = l_default_tcp->m_nb_max_mct_records * (OPJ_UINT32 )sizeof(opj_mct_data_t );
#line 7370
    __cil_tmp24 = malloc((unsigned long )l_mct_records_size);
#line 7370
    l_tcp->m_mct_records = (opj_mct_data_t *)__cil_tmp24;
    }
#line 7371
    if (! l_tcp->m_mct_records) {
#line 7372
      return (0);
    }
    {
#line 7374
    memcpy((void *)l_tcp->m_mct_records, (void const   *)l_default_tcp->m_mct_records,
           (unsigned long )l_mct_records_size);
#line 7377
    l_src_mct_rec = l_default_tcp->m_mct_records;
#line 7378
    l_dest_mct_rec = l_tcp->m_mct_records;
#line 7380
    j = (OPJ_UINT32 )0;
    }
    {
#line 7380
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 7380
      if (! (j < l_default_tcp->m_nb_mct_records)) {
#line 7380
        goto while_break___0;
      }
#line 7382
      if (l_src_mct_rec->m_data) {
        {
#line 7384
        __cil_tmp25 = malloc((unsigned long )l_src_mct_rec->m_data_size);
#line 7384
        l_dest_mct_rec->m_data = (OPJ_BYTE *)__cil_tmp25;
        }
#line 7385
        if (! l_dest_mct_rec->m_data) {
#line 7386
          return (0);
        }
        {
#line 7388
        memcpy((void *)l_dest_mct_rec->m_data, (void const   *)l_src_mct_rec->m_data,
               (unsigned long )l_src_mct_rec->m_data_size);
        }
      }
#line 7391
      l_src_mct_rec ++;
#line 7392
      l_dest_mct_rec ++;
#line 7380
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 7396
    l_mcc_records_size = l_default_tcp->m_nb_max_mcc_records * (OPJ_UINT32 )sizeof(opj_simple_mcc_decorrelation_data_t );
#line 7397
    __cil_tmp26 = malloc((unsigned long )l_mcc_records_size);
#line 7397
    l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp26;
    }
#line 7398
    if (! l_tcp->m_mcc_records) {
#line 7399
      return (0);
    }
    {
#line 7401
    memcpy((void *)l_tcp->m_mcc_records, (void const   *)l_default_tcp->m_mcc_records,
           (unsigned long )l_mcc_records_size);
#line 7404
    l_src_mcc_rec = l_default_tcp->m_mcc_records;
#line 7405
    l_dest_mcc_rec = l_tcp->m_mcc_records;
#line 7407
    j = (OPJ_UINT32 )0;
    }
    {
#line 7407
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 7407
      if (! (j < l_default_tcp->m_nb_max_mcc_records)) {
#line 7407
        goto while_break___1;
      }
#line 7409
      if (l_src_mcc_rec->m_decorrelation_array) {
#line 7410
        l_offset = (OPJ_UINT32 )(l_src_mcc_rec->m_decorrelation_array - l_default_tcp->m_mct_records);
#line 7411
        l_dest_mcc_rec->m_decorrelation_array = l_tcp->m_mct_records + l_offset;
      }
#line 7414
      if (l_src_mcc_rec->m_offset_array) {
#line 7415
        l_offset = (OPJ_UINT32 )(l_src_mcc_rec->m_offset_array - l_default_tcp->m_mct_records);
#line 7416
        l_dest_mcc_rec->m_offset_array = l_tcp->m_mct_records + l_offset;
      }
#line 7419
      l_src_mcc_rec ++;
#line 7420
      l_dest_mcc_rec ++;
#line 7407
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 7424
    memcpy((void *)l_current_tccp, (void const   *)l_default_tcp->tccps, (unsigned long )l_tccp_size);
#line 7427
    l_tcp ++;
#line 7348
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 7431
  __cil_tmp27 = opj_tcd_create(1);
#line 7431
  p_j2k->m_tcd = __cil_tmp27;
  }
#line 7432
  if (! p_j2k->m_tcd) {
#line 7433
    return (0);
  }
  {
#line 7436
  __cil_tmp28 = opj_tcd_init(p_j2k->m_tcd, l_image, & p_j2k->m_cp);
  }
#line 7436
  if (! __cil_tmp28) {
    {
#line 7437
    opj_tcd_destroy(p_j2k->m_tcd);
#line 7438
    p_j2k->m_tcd = (struct opj_tcd *)0;
#line 7439
    opj_event_msg(p_manager, 1, "Cannot decode tile, memory error\n");
    }
#line 7440
    return (0);
  }
#line 7443
  return (1);
}
}
#line 7446 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler *opj_j2k_get_marker_handler(OPJ_UINT32 p_id ) 
{ 
  opj_dec_memory_marker_handler_t *e ;

  {
#line 7449
  e = j2k_memory_marker_handler_tab;
  {
#line 7449
  while (1) {
    while_continue: /* CIL Label */ ;

#line 7449
    if (! (e->id != 0U)) {
#line 7449
      goto while_break;
    }
#line 7450
    if (e->id == p_id) {
#line 7451
      goto while_break;
    }
#line 7449
    e ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 7454
  return (e);
}
}
#line 7457 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_destroy(opj_j2k_t *p_j2k ) 
{ 


  {
#line 7459
  if ((unsigned long )p_j2k == (unsigned long )((opj_j2k_t *)0)) {
#line 7460
    return;
  }
#line 7463
  if (p_j2k->m_is_decoder) {
#line 7465
    if ((unsigned long )p_j2k->m_specific_param.m_decoder.m_default_tcp != (unsigned long )((opj_tcp_t *)0)) {
      {
#line 7466
      opj_j2k_tcp_destroy(p_j2k->m_specific_param.m_decoder.m_default_tcp);
#line 7467
      free((void *)p_j2k->m_specific_param.m_decoder.m_default_tcp);
#line 7468
      p_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t *)0;
      }
    }
#line 7471
    if ((unsigned long )p_j2k->m_specific_param.m_decoder.m_header_data != (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 7472
      free((void *)p_j2k->m_specific_param.m_decoder.m_header_data);
#line 7473
      p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)0;
#line 7474
      p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
      }
    }
  } else {
#line 7479
    if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
      {
#line 7480
      free((void *)p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
#line 7481
      p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)0;
      }
    }
#line 7484
    if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
      {
#line 7485
      free((void *)p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
#line 7486
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)0;
#line 7487
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = (OPJ_BYTE *)0;
      }
    }
#line 7490
    if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
      {
#line 7491
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 7492
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)0;
#line 7493
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
      }
    }
  }
  {
#line 7497
  opj_tcd_destroy(p_j2k->m_tcd);
#line 7499
  opj_j2k_cp_destroy(& p_j2k->m_cp);
#line 7500
  memset((void *)(& p_j2k->m_cp), 0, sizeof(opj_cp_t ));
#line 7502
  opj_procedure_list_destroy(p_j2k->m_procedure_list);
#line 7503
  p_j2k->m_procedure_list = (opj_procedure_list_t *)0;
#line 7505
  opj_procedure_list_destroy(p_j2k->m_validation_list);
#line 7506
  p_j2k->m_procedure_list = (opj_procedure_list_t *)0;
#line 7508
  j2k_destroy_cstr_index(p_j2k->cstr_index);
#line 7509
  p_j2k->cstr_index = (opj_codestream_index_t *)((void *)0);
#line 7511
  opj_image_destroy(p_j2k->m_private_image);
#line 7512
  p_j2k->m_private_image = (opj_image_t *)((void *)0);
#line 7514
  opj_image_destroy(p_j2k->m_output_image);
#line 7515
  p_j2k->m_output_image = (opj_image_t *)((void *)0);
#line 7517
  free((void *)p_j2k);
  }
#line 7519
  return;
}
}
#line 7520 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind ) 
{ 
  OPJ_UINT32 it_tile ;

  {
#line 7522
  if (p_cstr_ind) {
#line 7524
    if (p_cstr_ind->marker) {
      {
#line 7525
      free((void *)p_cstr_ind->marker);
#line 7526
      p_cstr_ind->marker = (opj_marker_info_t *)((void *)0);
      }
    }
#line 7529
    if (p_cstr_ind->tile_index) {
#line 7530
      it_tile = (OPJ_UINT32 )0;
#line 7532
      it_tile = (OPJ_UINT32 )0;
      {
#line 7532
      while (1) {
        while_continue: /* CIL Label */ ;

#line 7532
        if (! (it_tile < p_cstr_ind->nb_of_tiles)) {
#line 7532
          goto while_break;
        }
#line 7534
        if ((p_cstr_ind->tile_index + it_tile)->packet_index) {
          {
#line 7535
          free((void *)(p_cstr_ind->tile_index + it_tile)->packet_index);
#line 7536
          (p_cstr_ind->tile_index + it_tile)->packet_index = (opj_packet_info_t *)((void *)0);
          }
        }
#line 7539
        if ((p_cstr_ind->tile_index + it_tile)->tp_index) {
          {
#line 7540
          free((void *)(p_cstr_ind->tile_index + it_tile)->tp_index);
#line 7541
          (p_cstr_ind->tile_index + it_tile)->tp_index = (opj_tp_index_t *)((void *)0);
          }
        }
#line 7544
        if ((p_cstr_ind->tile_index + it_tile)->marker) {
          {
#line 7545
          free((void *)(p_cstr_ind->tile_index + it_tile)->marker);
#line 7546
          (p_cstr_ind->tile_index + it_tile)->marker = (opj_marker_info_t *)((void *)0);
          }
        }
#line 7532
        it_tile ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 7551
      free((void *)p_cstr_ind->tile_index);
#line 7552
      p_cstr_ind->tile_index = (opj_tile_index_t *)((void *)0);
      }
    }
    {
#line 7555
    free((void *)p_cstr_ind);
    }
  }
#line 7558
  return;
}
}
#line 7559 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp ) 
{ 
  opj_mct_data_t *l_mct_data ;
  OPJ_UINT32 i ;

  {
#line 7561
  if ((unsigned long )p_tcp == (unsigned long )((opj_tcp_t *)0)) {
#line 7562
    return;
  }
#line 7565
  if ((unsigned long )p_tcp->ppt_buffer != (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 7566
    free((void *)p_tcp->ppt_buffer);
#line 7567
    p_tcp->ppt_buffer = (OPJ_BYTE *)0;
    }
  }
#line 7570
  if ((unsigned long )p_tcp->tccps != (unsigned long )((opj_tccp_t *)0)) {
    {
#line 7571
    free((void *)p_tcp->tccps);
#line 7572
    p_tcp->tccps = (opj_tccp_t *)0;
    }
  }
#line 7575
  if ((unsigned long )p_tcp->m_mct_coding_matrix != (unsigned long )((OPJ_FLOAT32 *)0)) {
    {
#line 7576
    free((void *)p_tcp->m_mct_coding_matrix);
#line 7577
    p_tcp->m_mct_coding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 7580
  if ((unsigned long )p_tcp->m_mct_decoding_matrix != (unsigned long )((OPJ_FLOAT32 *)0)) {
    {
#line 7581
    free((void *)p_tcp->m_mct_decoding_matrix);
#line 7582
    p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 7585
  if (p_tcp->m_mcc_records) {
    {
#line 7586
    free((void *)p_tcp->m_mcc_records);
#line 7587
    p_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)0;
#line 7588
    p_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 7589
    p_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
    }
  }
#line 7592
  if (p_tcp->m_mct_records) {
#line 7593
    l_mct_data = p_tcp->m_mct_records;
#line 7596
    i = (OPJ_UINT32 )0;
    {
#line 7596
    while (1) {
      while_continue: /* CIL Label */ ;

#line 7596
      if (! (i < p_tcp->m_nb_mct_records)) {
#line 7596
        goto while_break;
      }
#line 7597
      if (l_mct_data->m_data) {
        {
#line 7598
        free((void *)l_mct_data->m_data);
#line 7599
        l_mct_data->m_data = (OPJ_BYTE *)0;
        }
      }
#line 7602
      l_mct_data ++;
#line 7596
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 7605
    free((void *)p_tcp->m_mct_records);
#line 7606
    p_tcp->m_mct_records = (opj_mct_data_t *)0;
    }
  }
#line 7609
  if ((unsigned long )p_tcp->mct_norms != (unsigned long )((OPJ_FLOAT64 *)0)) {
    {
#line 7610
    free((void *)p_tcp->mct_norms);
#line 7611
    p_tcp->mct_norms = (OPJ_FLOAT64 *)0;
    }
  }
  {
#line 7614
  opj_j2k_tcp_data_destroy(p_tcp);
  }
#line 7616
  return;
}
}
#line 7618 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp ) 
{ 


  {
#line 7620
  if (p_tcp->m_data) {
    {
#line 7621
    free((void *)p_tcp->m_data);
#line 7622
    p_tcp->m_data = (OPJ_BYTE *)((void *)0);
#line 7623
    p_tcp->m_data_size = (OPJ_UINT32 )0;
    }
  }
#line 7626
  return;
}
}
#line 7627 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_cp_destroy(opj_cp_t *p_cp ) 
{ 
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *l_current_tile ;
  OPJ_UINT32 i ;

  {
#line 7630
  l_current_tile = (opj_tcp_t *)0;
#line 7633
  if ((unsigned long )p_cp == (unsigned long )((opj_cp_t *)0)) {
#line 7635
    return;
  }
#line 7637
  if ((unsigned long )p_cp->tcps != (unsigned long )((opj_tcp_t *)0)) {
#line 7639
    l_current_tile = p_cp->tcps;
#line 7640
    l_nb_tiles = p_cp->th * p_cp->tw;
#line 7642
    i = (OPJ_UINT32 )0;
    {
#line 7642
    while (1) {
      while_continue: /* CIL Label */ ;

#line 7642
      if (! (i < l_nb_tiles)) {
#line 7642
        goto while_break;
      }
      {
#line 7644
      opj_j2k_tcp_destroy(l_current_tile);
#line 7645
      l_current_tile ++;
#line 7642
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 7647
    free((void *)p_cp->tcps);
#line 7648
    p_cp->tcps = (opj_tcp_t *)0;
    }
  }
  {
#line 7650
  free((void *)p_cp->ppm_buffer);
#line 7651
  p_cp->ppm_buffer = (OPJ_BYTE *)0;
#line 7652
  p_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 7653
  free((void *)p_cp->comment);
#line 7654
  p_cp->comment = (OPJ_CHAR *)0;
  }
#line 7655
  if (! p_cp->m_is_decoder) {
    {
#line 7657
    free((void *)p_cp->m_specific_param.m_enc.m_matrice);
#line 7658
    p_cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *)0;
    }
  }
#line 7661
  return;
}
}
#line 7662 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t *p_j2k , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_OFF_T __cil_tmp20 ;
  OPJ_SIZE_T __cil_tmp21 ;
  OPJ_OFF_T __cil_tmp22 ;
  OPJ_BYTE *new_header_data ;
  OPJ_OFF_T __cil_tmp25 ;
  void *__cil_tmp26 ;
  OPJ_SIZE_T __cil_tmp27 ;
  OPJ_BOOL __cil_tmp28 ;
  OPJ_OFF_T __cil_tmp29 ;
  OPJ_BOOL __cil_tmp30 ;
  OPJ_UINT32 sot_pos ;
  OPJ_OFF_T __cil_tmp32 ;
  OPJ_OFF_T __cil_tmp33 ;
  OPJ_SIZE_T __cil_tmp34 ;
  OPJ_OFF_T __cil_tmp35 ;
  OPJ_BOOL __cil_tmp36 ;
  OPJ_SIZE_T __cil_tmp37 ;
  OPJ_SIZE_T __cil_tmp38 ;
  OPJ_BOOL __cil_tmp39 ;

  {
#line 7672
  l_current_marker = (OPJ_UINT32 )65424;
#line 7674
  l_marker_handler = (opj_dec_memory_marker_handler_t *)0;
#line 7675
  l_tcp = (opj_tcp_t *)((void *)0);
#line 7684
  if (p_j2k->m_specific_param.m_decoder.m_state == 256U) {
#line 7685
    l_current_marker = (OPJ_UINT32 )65497;
  } else
#line 7688
  if (p_j2k->m_specific_param.m_decoder.m_state != 8U) {
#line 7689
    return (0);
  }
  {
#line 7693
  while (1) {
    while_continue: /* CIL Label */ ;

#line 7693
    if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
#line 7693
      if (! (l_current_marker != 65497U)) {
#line 7693
        goto while_break;
      }
    } else {
#line 7693
      goto while_break;
    }
    {
#line 7696
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 7696
      if (! (l_current_marker != 65427U)) {
#line 7696
        goto while_break___0;
      }
      {
#line 7698
      __cil_tmp20 = opj_stream_get_number_byte_left(p_stream);
      }
#line 7698
      if (__cil_tmp20 == 0L) {
#line 7700
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 7701
        goto while_break___0;
      }
      {
#line 7705
      __cil_tmp21 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )2, p_manager);
      }
#line 7705
      if (__cil_tmp21 != 2UL) {
        {
#line 7706
        opj_event_msg(p_manager, 1, "Stream too short\n");
        }
#line 7707
        return (0);
      }
      {
#line 7711
      opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_marker_size,
                        (OPJ_UINT32 )2);
      }
#line 7714
      if (l_marker_size < 2U) {
        {
#line 7715
        opj_event_msg(p_manager, 1, "Inconsistent marker size\n");
        }
#line 7716
        return (0);
      }
      {
#line 7720
      __cil_tmp22 = opj_stream_get_number_byte_left(p_stream);
      }
#line 7720
      if (l_current_marker == 32896U) {
#line 7720
        if (__cil_tmp22 == 0L) {
#line 7721
          p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 7722
          goto while_break___0;
        }
      }
#line 7726
      if (p_j2k->m_specific_param.m_decoder.m_state & 16U) {
#line 7727
        p_j2k->m_specific_param.m_decoder.m_sot_length -= l_marker_size + 2U;
      }
      {
#line 7729
      l_marker_size -= 2U;
#line 7732
      l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
      }
#line 7735
      if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
        {
#line 7736
        opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n");
        }
#line 7737
        return (0);
      }
#line 7742
      if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
        {
#line 7743
        new_header_data = (OPJ_BYTE *)((void *)0);
#line 7746
        __cil_tmp25 = opj_stream_get_number_byte_left(p_stream);
        }
#line 7746
        if ((OPJ_OFF_T )l_marker_size > __cil_tmp25) {
          {
#line 7747
          opj_event_msg(p_manager, 1, "Marker size inconsistent with stream length\n");
          }
#line 7748
          return (0);
        }
        {
#line 7750
        __cil_tmp26 = realloc((void *)p_j2k->m_specific_param.m_decoder.m_header_data,
                              (unsigned long )l_marker_size);
#line 7750
        new_header_data = (OPJ_BYTE *)__cil_tmp26;
        }
#line 7751
        if (! new_header_data) {
          {
#line 7752
          free((void *)p_j2k->m_specific_param.m_decoder.m_header_data);
#line 7753
          p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)((void *)0);
#line 7754
          p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
#line 7755
          opj_event_msg(p_manager, 1, "Not enough memory to read header\n");
          }
#line 7756
          return (0);
        }
#line 7758
        p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
#line 7759
        p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
      }
      {
#line 7763
      __cil_tmp27 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )l_marker_size, p_manager);
      }
#line 7763
      if (__cil_tmp27 != (unsigned long )l_marker_size) {
        {
#line 7764
        opj_event_msg(p_manager, 1, "Stream too short\n");
        }
#line 7765
        return (0);
      }
#line 7768
      if (! l_marker_handler->handler) {
        {
#line 7770
        opj_event_msg(p_manager, 1, "Not sure how that happened.\n");
        }
#line 7771
        return (0);
      }
      {
#line 7774
      __cil_tmp28 = (*(l_marker_handler->handler))(p_j2k, p_j2k->m_specific_param.m_decoder.m_header_data,
                                                   l_marker_size, p_manager);
      }
#line 7774
      if (! __cil_tmp28) {
        {
#line 7775
        opj_event_msg(p_manager, 1, "Fail to read the current marker segment (%#x)\n",
                      l_current_marker);
        }
#line 7776
        return (0);
      }
      {
#line 7780
      __cil_tmp29 = opj_stream_tell(p_stream);
#line 7780
      __cil_tmp30 = opj_j2k_add_tlmarker(p_j2k->m_current_tile_number, p_j2k->cstr_index,
                                         l_marker_handler->id, (OPJ_OFF_T )(((OPJ_UINT32 )__cil_tmp29 - l_marker_size) - 4U),
                                         l_marker_size + 4U);
      }
#line 7780
      if (0 == __cil_tmp30) {
        {
#line 7785
        opj_event_msg(p_manager, 1, "Not enough memory to add tl marker\n");
        }
#line 7786
        return (0);
      }
#line 7790
      if (l_marker_handler->id == 65424U) {
        {
#line 7791
        __cil_tmp32 = opj_stream_tell(p_stream);
#line 7791
        sot_pos = ((OPJ_UINT32 )__cil_tmp32 - l_marker_size) - 4U;
        }
#line 7792
        if ((long )sot_pos > p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos) {
#line 7794
          p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = (OPJ_OFF_T )sot_pos;
        }
      }
#line 7798
      if (p_j2k->m_specific_param.m_decoder.m_skip_data) {
        {
#line 7800
        __cil_tmp33 = opj_stream_skip(p_stream, (OPJ_OFF_T )p_j2k->m_specific_param.m_decoder.m_sot_length,
                                      p_manager);
        }
#line 7800
        if (__cil_tmp33 != (long )p_j2k->m_specific_param.m_decoder.m_sot_length) {
          {
#line 7801
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 7802
          return (0);
        }
#line 7804
        l_current_marker = (OPJ_UINT32 )65427;
      } else {
        {
#line 7808
        __cil_tmp34 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                           (OPJ_SIZE_T )2, p_manager);
        }
#line 7808
        if (__cil_tmp34 != 2UL) {
          {
#line 7809
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 7810
          return (0);
        }
        {
#line 7813
        opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                          (OPJ_UINT32 )2);
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 7816
    __cil_tmp35 = opj_stream_get_number_byte_left(p_stream);
    }
#line 7816
    if (__cil_tmp35 == 0L) {
#line 7816
      if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 7818
        goto while_break;
      }
    }
#line 7821
    if (! p_j2k->m_specific_param.m_decoder.m_skip_data) {
      {
#line 7823
      __cil_tmp36 = opj_j2k_read_sod(p_j2k, p_stream, p_manager);
      }
#line 7823
      if (! __cil_tmp36) {
#line 7824
        return (0);
      }
#line 7827
      if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
        {
#line 7829
        __cil_tmp37 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                           (OPJ_SIZE_T )2, p_manager);
        }
#line 7829
        if (__cil_tmp37 != 2UL) {
          {
#line 7830
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 7831
          return (0);
        }
        {
#line 7835
        opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                          (OPJ_UINT32 )2);
        }
      }
    } else {
      {
#line 7840
      p_j2k->m_specific_param.m_decoder.m_skip_data = (OPJ_UINT32 )0;
#line 7841
      p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_UINT32 )0;
#line 7842
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
#line 7845
      __cil_tmp38 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )2, p_manager);
      }
#line 7845
      if (__cil_tmp38 != 2UL) {
        {
#line 7846
        opj_event_msg(p_manager, 1, "Stream too short\n");
        }
#line 7847
        return (0);
      }
      {
#line 7851
      opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                        (OPJ_UINT32 )2);
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 7856
  if (l_current_marker == 65497U) {
#line 7857
    if (p_j2k->m_specific_param.m_decoder.m_state != 256U) {
#line 7858
      p_j2k->m_current_tile_number = (OPJ_UINT32 )0;
#line 7859
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
    }
  }
#line 7864
  if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
#line 7865
    l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 7866
    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
    {
#line 7868
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 7868
      if ((unsigned long )l_tcp->m_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 7868
        if (! (p_j2k->m_current_tile_number < l_nb_tiles)) {
#line 7868
          goto while_break___1;
        }
      } else {
#line 7868
        goto while_break___1;
      }
#line 7869
      (p_j2k->m_current_tile_number) ++;
#line 7870
      l_tcp ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
#line 7873
    if (p_j2k->m_current_tile_number == l_nb_tiles) {
#line 7874
      *p_go_on = 0;
#line 7875
      return (1);
    }
  }
  {
#line 7880
  __cil_tmp39 = opj_tcd_init_decode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number);
  }
#line 7880
  if (! __cil_tmp39) {
    {
#line 7881
    opj_event_msg(p_manager, 1, "Cannot decode tile, memory error\n");
    }
#line 7882
    return (0);
  }
  {
#line 7885
  opj_event_msg(p_manager, 4, "Header of tile %d / %d has been read.\n", p_j2k->m_current_tile_number + 1U,
                p_j2k->m_cp.th * p_j2k->m_cp.tw);
#line 7888
  *p_tile_index = p_j2k->m_current_tile_number;
#line 7889
  *p_go_on = 1;
#line 7890
  *p_data_size = opj_tcd_get_decoded_tile_size(p_j2k->m_tcd);
#line 7891
  *p_tile_x0 = (((p_j2k->m_tcd)->tcd_image)->tiles)->x0;
#line 7892
  *p_tile_y0 = (((p_j2k->m_tcd)->tcd_image)->tiles)->y0;
#line 7893
  *p_tile_x1 = (((p_j2k->m_tcd)->tcd_image)->tiles)->x1;
#line 7894
  *p_tile_y1 = (((p_j2k->m_tcd)->tcd_image)->tiles)->y1;
#line 7895
  *p_nb_comps = (((p_j2k->m_tcd)->tcd_image)->tiles)->numcomps;
#line 7897
  p_j2k->m_specific_param.m_decoder.m_state |= 128U;
  }
#line 7899
  return (1);
}
}
#line 7902 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_BYTE l_data[2] ;
  opj_tcp_t *l_tcp ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_OFF_T __cil_tmp15 ;
  OPJ_SIZE_T __cil_tmp16 ;
  OPJ_OFF_T __cil_tmp17 ;

  {
#line 7918
  if (! (p_j2k->m_specific_param.m_decoder.m_state & 128U)) {
#line 7920
    return (0);
  } else
#line 7918
  if (p_tile_index != p_j2k->m_current_tile_number) {
#line 7920
    return (0);
  }
#line 7923
  l_tcp = p_j2k->m_cp.tcps + p_tile_index;
#line 7924
  if (! l_tcp->m_data) {
    {
#line 7925
    opj_j2k_tcp_destroy(l_tcp);
    }
#line 7926
    return (0);
  }
  {
#line 7929
  __cil_tmp13 = opj_tcd_decode_tile(p_j2k->m_tcd, l_tcp->m_data, l_tcp->m_data_size,
                                    p_tile_index, p_j2k->cstr_index);
  }
#line 7929
  if (! __cil_tmp13) {
    {
#line 7934
    opj_j2k_tcp_destroy(l_tcp);
#line 7935
    p_j2k->m_specific_param.m_decoder.m_state |= 32768U;
#line 7936
    opj_event_msg(p_manager, 1, "Failed to decode.\n\346iEV");
    }
#line 7937
    return (0);
  }
  {
#line 7940
  __cil_tmp14 = opj_tcd_update_tile_data(p_j2k->m_tcd, p_data, p_data_size);
  }
#line 7940
  if (! __cil_tmp14) {
#line 7941
    return (0);
  }
  {
#line 7948
  opj_j2k_tcp_data_destroy(l_tcp);
#line 7950
  p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_UINT32 )0;
#line 7951
  p_j2k->m_specific_param.m_decoder.m_state &= 4294967167U;
#line 7953
  __cil_tmp15 = opj_stream_get_number_byte_left(p_stream);
  }
#line 7953
  if (__cil_tmp15 == 0L) {
#line 7953
    if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 7955
      return (1);
    }
  }
#line 7958
  if (p_j2k->m_specific_param.m_decoder.m_state != 256U) {
    {
#line 7959
    __cil_tmp16 = opj_stream_read_data(p_stream, l_data, (OPJ_SIZE_T )2, p_manager);
    }
#line 7959
    if (__cil_tmp16 != 2UL) {
      {
#line 7960
      opj_event_msg(p_manager, 1, "Stream too short\n\027\346iEV");
      }
#line 7961
      return (0);
    }
    {
#line 7964
    opj_read_bytes_LE(l_data, & l_current_marker, (OPJ_UINT32 )2);
    }
#line 7966
    if (l_current_marker == 65497U) {
#line 7967
      p_j2k->m_current_tile_number = (OPJ_UINT32 )0;
#line 7968
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
    } else
#line 7970
    if (l_current_marker != 65424U) {
      {
#line 7972
      __cil_tmp17 = opj_stream_get_number_byte_left(p_stream);
      }
#line 7972
      if (__cil_tmp17 == 0L) {
        {
#line 7973
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 7974
        opj_event_msg(p_manager, 2, "Stream does not end with EOC\nV");
        }
#line 7975
        return (1);
      }
      {
#line 7977
      opj_event_msg(p_manager, 1, "Stream too short, expected SOT\n");
      }
#line 7978
      return (0);
    }
  }
#line 7982
  return (1);
}
}
#line 7985 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data , opj_image_t *p_output_image ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 l_width_src ;
  OPJ_UINT32 l_height_src ;
  OPJ_UINT32 l_width_dest ;
  OPJ_UINT32 l_height_dest ;
  OPJ_INT32 l_offset_x0_src ;
  OPJ_INT32 l_offset_y0_src ;
  OPJ_INT32 l_offset_x1_src ;
  OPJ_INT32 l_offset_y1_src ;
  OPJ_INT32 l_start_offset_src ;
  OPJ_INT32 l_line_offset_src ;
  OPJ_INT32 l_end_offset_src ;
  OPJ_UINT32 l_start_x_dest ;
  OPJ_UINT32 l_start_y_dest ;
  OPJ_UINT32 l_x0_dest ;
  OPJ_UINT32 l_y0_dest ;
  OPJ_UINT32 l_x1_dest ;
  OPJ_UINT32 l_y1_dest ;
  OPJ_INT32 l_start_offset_dest ;
  OPJ_INT32 l_line_offset_dest ;
  opj_image_comp_t *l_img_comp_src ;
  opj_image_comp_t *l_img_comp_dest ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_t *l_image_src ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_INT32 *l_dest_ptr ;
  opj_tcd_resolution_t *l_res ;
  void *__cil_tmp34 ;
  OPJ_INT32 __cil_tmp35 ;
  OPJ_INT32 __cil_tmp36 ;
  OPJ_CHAR *l_src_ptr ;
  OPJ_INT32 *__cil_tmp40 ;
  OPJ_CHAR *__cil_tmp41 ;
  OPJ_INT32 *__cil_tmp42 ;
  OPJ_CHAR *__cil_tmp43 ;
  OPJ_INT16 *l_src_ptr___0 ;
  OPJ_INT32 *__cil_tmp45 ;
  OPJ_INT16 *__cil_tmp46 ;
  OPJ_INT32 *__cil_tmp47 ;
  OPJ_INT16 *__cil_tmp48 ;
  OPJ_INT32 *l_src_ptr___1 ;
  OPJ_INT32 *__cil_tmp50 ;
  OPJ_INT32 *__cil_tmp51 ;

  {
#line 7987
  k = (OPJ_UINT32 )0;
#line 7996
  l_img_comp_src = (opj_image_comp_t *)0;
#line 7997
  l_img_comp_dest = (opj_image_comp_t *)0;
#line 7999
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 8000
  l_image_src = (opj_image_t *)0;
#line 8003
  l_res = (opj_tcd_resolution_t *)0;
#line 8005
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 8006
  l_image_src = p_tcd->image;
#line 8007
  l_img_comp_src = l_image_src->comps;
#line 8009
  l_img_comp_dest = p_output_image->comps;
#line 8011
  i = (OPJ_UINT32 )0;
  {
#line 8011
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8011
    if (! (i < l_image_src->numcomps)) {
#line 8011
      goto while_break;
    }
#line 8014
    if (! l_img_comp_dest->data) {
      {
#line 8016
      __cil_tmp34 = calloc((unsigned long )(l_img_comp_dest->w * l_img_comp_dest->h),
                           sizeof(OPJ_INT32 ));
#line 8016
      l_img_comp_dest->data = (OPJ_INT32 *)__cil_tmp34;
      }
#line 8017
      if (! l_img_comp_dest->data) {
#line 8018
        return (0);
      }
    }
#line 8023
    l_img_comp_dest->resno_decoded = l_img_comp_src->resno_decoded;
#line 8027
    l_size_comp = l_img_comp_src->prec >> 3;
#line 8028
    l_remaining = l_img_comp_src->prec & 7U;
#line 8029
    l_res = l_tilec->resolutions + l_img_comp_src->resno_decoded;
#line 8031
    if (l_remaining) {
#line 8032
      l_size_comp ++;
    }
#line 8035
    if (l_size_comp == 3U) {
#line 8036
      l_size_comp = (OPJ_UINT32 )4;
    }
    {
#line 8046
    l_width_src = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 8047
    l_height_src = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
#line 8050
    __cil_tmp35 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp_dest->x0, (OPJ_INT32 )l_img_comp_dest->factor);
#line 8050
    l_x0_dest = (OPJ_UINT32 )__cil_tmp35;
#line 8051
    __cil_tmp36 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp_dest->y0, (OPJ_INT32 )l_img_comp_dest->factor);
#line 8051
    l_y0_dest = (OPJ_UINT32 )__cil_tmp36;
#line 8052
    l_x1_dest = l_x0_dest + l_img_comp_dest->w;
#line 8053
    l_y1_dest = l_y0_dest + l_img_comp_dest->h;
    }
#line 8069
    if (l_x0_dest < (OPJ_UINT32 )l_res->x0) {
#line 8070
      l_start_x_dest = (OPJ_UINT32 )l_res->x0 - l_x0_dest;
#line 8071
      l_offset_x0_src = 0;
#line 8073
      if (l_x1_dest >= (OPJ_UINT32 )l_res->x1) {
#line 8074
        l_width_dest = l_width_src;
#line 8075
        l_offset_x1_src = 0;
      } else {
#line 8078
        l_width_dest = l_x1_dest - (OPJ_UINT32 )l_res->x0;
#line 8079
        l_offset_x1_src = (OPJ_INT32 )(l_width_src - l_width_dest);
      }
    } else {
#line 8083
      l_start_x_dest = (OPJ_UINT32 )0;
#line 8084
      l_offset_x0_src = (OPJ_INT32 )l_x0_dest - l_res->x0;
#line 8086
      if (l_x1_dest >= (OPJ_UINT32 )l_res->x1) {
#line 8087
        l_width_dest = l_width_src - (OPJ_UINT32 )l_offset_x0_src;
#line 8088
        l_offset_x1_src = 0;
      } else {
#line 8091
        l_width_dest = l_img_comp_dest->w;
#line 8092
        l_offset_x1_src = l_res->x1 - (OPJ_INT32 )l_x1_dest;
      }
    }
#line 8096
    if (l_y0_dest < (OPJ_UINT32 )l_res->y0) {
#line 8097
      l_start_y_dest = (OPJ_UINT32 )l_res->y0 - l_y0_dest;
#line 8098
      l_offset_y0_src = 0;
#line 8100
      if (l_y1_dest >= (OPJ_UINT32 )l_res->y1) {
#line 8101
        l_height_dest = l_height_src;
#line 8102
        l_offset_y1_src = 0;
      } else {
#line 8105
        l_height_dest = l_y1_dest - (OPJ_UINT32 )l_res->y0;
#line 8106
        l_offset_y1_src = (OPJ_INT32 )(l_height_src - l_height_dest);
      }
    } else {
#line 8110
      l_start_y_dest = (OPJ_UINT32 )0;
#line 8111
      l_offset_y0_src = (OPJ_INT32 )l_y0_dest - l_res->y0;
#line 8113
      if (l_y1_dest >= (OPJ_UINT32 )l_res->y1) {
#line 8114
        l_height_dest = l_height_src - (OPJ_UINT32 )l_offset_y0_src;
#line 8115
        l_offset_y1_src = 0;
      } else {
#line 8118
        l_height_dest = l_img_comp_dest->h;
#line 8119
        l_offset_y1_src = l_res->y1 - (OPJ_INT32 )l_y1_dest;
      }
    }
#line 8123
    if (l_offset_x0_src < 0) {
#line 8124
      return (0);
    } else
#line 8123
    if (l_offset_y0_src < 0) {
#line 8124
      return (0);
    } else
#line 8123
    if (l_offset_x1_src < 0) {
#line 8124
      return (0);
    } else
#line 8123
    if (l_offset_y1_src < 0) {
#line 8124
      return (0);
    }
#line 8127
    if ((OPJ_INT32 )l_width_dest < 0) {
#line 8128
      return (0);
    } else
#line 8127
    if ((OPJ_INT32 )l_height_dest < 0) {
#line 8128
      return (0);
    }
#line 8133
    l_start_offset_src = l_offset_x0_src + l_offset_y0_src * (OPJ_INT32 )l_width_src;
#line 8134
    l_line_offset_src = l_offset_x1_src + l_offset_x0_src;
#line 8135
    l_end_offset_src = l_offset_y1_src * (OPJ_INT32 )l_width_src - l_offset_x0_src;
#line 8138
    l_start_offset_dest = (OPJ_INT32 )(l_start_x_dest + l_start_y_dest * l_img_comp_dest->w);
#line 8139
    l_line_offset_dest = (OPJ_INT32 )(l_img_comp_dest->w - l_width_dest);
#line 8142
    l_dest_ptr = l_img_comp_dest->data + l_start_offset_dest;
#line 8159
    if (l_size_comp == 1U) {
#line 8159
      goto case_1;
    }
#line 8189
    if (l_size_comp == 2U) {
#line 8189
      goto case_2;
    }
#line 8219
    if (l_size_comp == 4U) {
#line 8219
      goto case_4;
    }
#line 8158
    goto switch_break;
    case_1: 
#line 8161
    l_src_ptr = (OPJ_CHAR *)p_data;
#line 8162
    l_src_ptr += l_start_offset_src;
#line 8164
    if (l_img_comp_src->sgnd) {
#line 8165
      j = (OPJ_UINT32 )0;
      {
#line 8165
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 8165
        if (! (j < l_height_dest)) {
#line 8165
          goto while_break___0;
        }
#line 8166
        k = (OPJ_UINT32 )0;
        {
#line 8166
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 8166
          if (! (k < l_width_dest)) {
#line 8166
            goto while_break___1;
          }
#line 8167
          __cil_tmp41 = l_src_ptr;
#line 8167
          l_src_ptr ++;
#line 8167
          __cil_tmp40 = l_dest_ptr;
#line 8167
          l_dest_ptr ++;
#line 8167
          *__cil_tmp40 = (OPJ_INT32 )*__cil_tmp41;
#line 8166
          k ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___1: 
#line 8170
        l_dest_ptr += l_line_offset_dest;
#line 8171
        l_src_ptr += l_line_offset_src;
#line 8165
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 8175
      j = (OPJ_UINT32 )0;
      {
#line 8175
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 8175
        if (! (j < l_height_dest)) {
#line 8175
          goto while_break___2;
        }
#line 8176
        k = (OPJ_UINT32 )0;
        {
#line 8176
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 8176
          if (! (k < l_width_dest)) {
#line 8176
            goto while_break___3;
          }
#line 8177
          __cil_tmp43 = l_src_ptr;
#line 8177
          l_src_ptr ++;
#line 8177
          __cil_tmp42 = l_dest_ptr;
#line 8177
          l_dest_ptr ++;
#line 8177
          *__cil_tmp42 = (int )*__cil_tmp43 & 255;
#line 8176
          k ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___3: 
#line 8180
        l_dest_ptr += l_line_offset_dest;
#line 8181
        l_src_ptr += l_line_offset_src;
#line 8175
        j ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___2: ;
    }
#line 8185
    l_src_ptr += l_end_offset_src;
#line 8186
    p_data = (OPJ_BYTE *)l_src_ptr;
#line 8188
    goto switch_break;
    case_2: 
#line 8191
    l_src_ptr___0 = (OPJ_INT16 *)p_data;
#line 8192
    l_src_ptr___0 += l_start_offset_src;
#line 8194
    if (l_img_comp_src->sgnd) {
#line 8195
      j = (OPJ_UINT32 )0;
      {
#line 8195
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 8195
        if (! (j < l_height_dest)) {
#line 8195
          goto while_break___4;
        }
#line 8196
        k = (OPJ_UINT32 )0;
        {
#line 8196
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 8196
          if (! (k < l_width_dest)) {
#line 8196
            goto while_break___5;
          }
#line 8197
          __cil_tmp46 = l_src_ptr___0;
#line 8197
          l_src_ptr___0 ++;
#line 8197
          __cil_tmp45 = l_dest_ptr;
#line 8197
          l_dest_ptr ++;
#line 8197
          *__cil_tmp45 = (OPJ_INT32 )*__cil_tmp46;
#line 8196
          k ++;
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___5: 
#line 8200
        l_dest_ptr += l_line_offset_dest;
#line 8201
        l_src_ptr___0 += l_line_offset_src;
#line 8195
        j ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___4: ;
    } else {
#line 8205
      j = (OPJ_UINT32 )0;
      {
#line 8205
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 8205
        if (! (j < l_height_dest)) {
#line 8205
          goto while_break___6;
        }
#line 8206
        k = (OPJ_UINT32 )0;
        {
#line 8206
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 8206
          if (! (k < l_width_dest)) {
#line 8206
            goto while_break___7;
          }
#line 8207
          __cil_tmp48 = l_src_ptr___0;
#line 8207
          l_src_ptr___0 ++;
#line 8207
          __cil_tmp47 = l_dest_ptr;
#line 8207
          l_dest_ptr ++;
#line 8207
          *__cil_tmp47 = (int )*__cil_tmp48 & 65535;
#line 8206
          k ++;
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___7: 
#line 8210
        l_dest_ptr += l_line_offset_dest;
#line 8211
        l_src_ptr___0 += l_line_offset_src;
#line 8205
        j ++;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___6: ;
    }
#line 8215
    l_src_ptr___0 += l_end_offset_src;
#line 8216
    p_data = (OPJ_BYTE *)l_src_ptr___0;
#line 8218
    goto switch_break;
    case_4: 
#line 8221
    l_src_ptr___1 = (OPJ_INT32 *)p_data;
#line 8222
    l_src_ptr___1 += l_start_offset_src;
#line 8224
    j = (OPJ_UINT32 )0;
    {
#line 8224
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 8224
      if (! (j < l_height_dest)) {
#line 8224
        goto while_break___8;
      }
#line 8225
      k = (OPJ_UINT32 )0;
      {
#line 8225
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 8225
        if (! (k < l_width_dest)) {
#line 8225
          goto while_break___9;
        }
#line 8226
        __cil_tmp51 = l_src_ptr___1;
#line 8226
        l_src_ptr___1 ++;
#line 8226
        __cil_tmp50 = l_dest_ptr;
#line 8226
        l_dest_ptr ++;
#line 8226
        *__cil_tmp50 = *__cil_tmp51;
#line 8225
        k ++;
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___9: 
#line 8229
      l_dest_ptr += l_line_offset_dest;
#line 8230
      l_src_ptr___1 += l_line_offset_src;
#line 8224
      j ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___8: 
#line 8233
    l_src_ptr___1 += l_end_offset_src;
#line 8234
    p_data = (OPJ_BYTE *)l_src_ptr___1;
#line 8236
    goto switch_break;
    switch_break: 
#line 8239
    l_img_comp_dest ++;
#line 8240
    l_img_comp_src ++;
#line 8241
    l_tilec ++;
#line 8011
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break: ;
#line 8244
  return (1);
}
}
#line 8247 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_image_t *l_image ;
  OPJ_UINT32 it_comp ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  opj_image_comp_t *l_img_comp ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  OPJ_INT32 l_h ;
  OPJ_INT32 l_w ;
  OPJ_INT32 __cil_tmp22 ;
  OPJ_INT32 __cil_tmp23 ;
  OPJ_INT32 __cil_tmp26 ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;

  {
#line 8253
  l_cp = & p_j2k->m_cp;
#line 8254
  l_image = p_j2k->m_private_image;
#line 8258
  l_img_comp = (opj_image_comp_t *)((void *)0);
#line 8261
  if (p_j2k->m_specific_param.m_decoder.m_state != 8U) {
    {
#line 8262
    opj_event_msg(p_manager, 1, "Need to decode the main header before begin to decode the remaining codestream");
    }
#line 8263
    return (0);
  }
#line 8266
  if (! p_start_x) {
#line 8266
    if (! p_start_y) {
#line 8266
      if (! p_end_x) {
#line 8266
        if (! p_end_y) {
          {
#line 8267
          opj_event_msg(p_manager, 4, "No decoded area parameters, set the decoded area to the whole image\n");
#line 8269
          p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 8270
          p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 8271
          p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 8272
          p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
          }
#line 8274
          return (1);
        }
      }
    }
  }
#line 8284
  if ((OPJ_UINT32 )p_start_x > l_image->x1) {
    {
#line 8285
    opj_event_msg(p_manager, 1, "Left position of the decoded area (region_x0=%d) is outside the image area (Xsiz=%d).\n",
                  p_start_x, l_image->x1);
    }
#line 8288
    return (0);
  } else
#line 8290
  if ((OPJ_UINT32 )p_start_x < l_image->x0) {
    {
#line 8291
    opj_event_msg(p_manager, 2, "Left position of the decoded area (region_x0=%d) is outside the image area (XOsiz=%d).\n",
                  p_start_x, l_image->x0);
#line 8294
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 8295
    p_image->x0 = l_image->x0;
    }
  } else {
#line 8298
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = ((OPJ_UINT32 )p_start_x - l_cp->tx0) / l_cp->tdx;
#line 8299
    p_image->x0 = (OPJ_UINT32 )p_start_x;
  }
#line 8303
  if ((OPJ_UINT32 )p_start_y > l_image->y1) {
    {
#line 8304
    opj_event_msg(p_manager, 1, "Up position of the decoded area (region_y0=%d) is outside the image area (Ysiz=%d).\nEV",
                  p_start_y, l_image->y1);
    }
#line 8307
    return (0);
  } else
#line 8309
  if ((OPJ_UINT32 )p_start_y < l_image->y0) {
    {
#line 8310
    opj_event_msg(p_manager, 2, "Up position of the decoded area (region_y0=%d) is outside the image area (YOsiz=%d).\n",
                  p_start_y, l_image->y0);
#line 8313
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 8314
    p_image->y0 = l_image->y0;
    }
  } else {
#line 8317
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = ((OPJ_UINT32 )p_start_y - l_cp->ty0) / l_cp->tdy;
#line 8318
    p_image->y0 = (OPJ_UINT32 )p_start_y;
  }
#line 8324
  if ((OPJ_UINT32 )p_end_x < l_image->x0) {
    {
#line 8325
    opj_event_msg(p_manager, 1, "Right position of the decoded area (region_x1=%d) is outside the image area (XOsiz=%d).\n\230\001",
                  p_end_x, l_image->x0);
    }
#line 8328
    return (0);
  } else
#line 8330
  if ((OPJ_UINT32 )p_end_x > l_image->x1) {
    {
#line 8331
    opj_event_msg(p_manager, 2, "Right position of the decoded area (region_x1=%d) is outside the image area (Xsiz=%d).\n",
                  p_end_x, l_image->x1);
#line 8334
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 8335
    p_image->x1 = l_image->x1;
    }
  } else {
    {
#line 8338
    __cil_tmp18 = opj_int_ceildiv(p_end_x - (OPJ_INT32 )l_cp->tx0, (OPJ_INT32 )l_cp->tdx);
#line 8338
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32 )__cil_tmp18;
#line 8339
    p_image->x1 = (OPJ_UINT32 )p_end_x;
    }
  }
#line 8343
  if ((OPJ_UINT32 )p_end_y < l_image->y0) {
    {
#line 8344
    opj_event_msg(p_manager, 1, "Bottom position of the decoded area (region_y1=%d) is outside the image area (YOsiz=%d).\n",
                  p_end_y, l_image->y0);
    }
#line 8347
    return (0);
  }
#line 8349
  if ((OPJ_UINT32 )p_end_y > l_image->y1) {
    {
#line 8350
    opj_event_msg(p_manager, 2, "Bottom position of the decoded area (region_y1=%d) is outside the image area (Ysiz=%d).\n\230\001",
                  p_end_y, l_image->y1);
#line 8353
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
#line 8354
    p_image->y1 = l_image->y1;
    }
  } else {
    {
#line 8357
    __cil_tmp19 = opj_int_ceildiv(p_end_y - (OPJ_INT32 )l_cp->ty0, (OPJ_INT32 )l_cp->tdy);
#line 8357
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32 )__cil_tmp19;
#line 8358
    p_image->y1 = (OPJ_UINT32 )p_end_y;
    }
  }
#line 8362
  p_j2k->m_specific_param.m_decoder.m_discard_tiles = (OPJ_UINT32 )1;
#line 8364
  l_img_comp = p_image->comps;
#line 8365
  it_comp = (OPJ_UINT32 )0;
  {
#line 8365
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8365
    if (! (it_comp < p_image->numcomps)) {
#line 8365
      goto while_break;
    }
    {
#line 8369
    __cil_tmp22 = opj_int_ceildiv((OPJ_INT32 )p_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 8369
    l_img_comp->x0 = (OPJ_UINT32 )__cil_tmp22;
#line 8370
    __cil_tmp23 = opj_int_ceildiv((OPJ_INT32 )p_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 8370
    l_img_comp->y0 = (OPJ_UINT32 )__cil_tmp23;
#line 8371
    l_comp_x1 = opj_int_ceildiv((OPJ_INT32 )p_image->x1, (OPJ_INT32 )l_img_comp->dx);
#line 8372
    l_comp_y1 = opj_int_ceildiv((OPJ_INT32 )p_image->y1, (OPJ_INT32 )l_img_comp->dy);
#line 8374
    __cil_tmp27 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->x0, (OPJ_INT32 )l_img_comp->factor);
#line 8374
    __cil_tmp26 = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32 )l_img_comp->factor);
#line 8374
    l_w = __cil_tmp26 - __cil_tmp27;
    }
#line 8376
    if (l_w < 0) {
      {
#line 8377
      opj_event_msg(p_manager, 1, "Size x of the decoded component image is incorrect (comp[%d].w=%d).\nEV",
                    it_comp, l_w);
      }
#line 8380
      return (0);
    }
    {
#line 8382
    l_img_comp->w = (OPJ_UINT32 )l_w;
#line 8384
    __cil_tmp29 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->y0, (OPJ_INT32 )l_img_comp->factor);
#line 8384
    __cil_tmp28 = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32 )l_img_comp->factor);
#line 8384
    l_h = __cil_tmp28 - __cil_tmp29;
    }
#line 8386
    if (l_h < 0) {
      {
#line 8387
      opj_event_msg(p_manager, 1, "Size y of the decoded component image is incorrect (comp[%d].h=%d).\n",
                    it_comp, l_h);
      }
#line 8390
      return (0);
    }
#line 8392
    l_img_comp->h = (OPJ_UINT32 )l_h;
#line 8394
    l_img_comp ++;
#line 8365
    it_comp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 8397
  opj_event_msg(p_manager, 4, "Setting decoding area to %d,%d,%d,%d\n", p_image->x0,
                p_image->y0, p_image->x1, p_image->y1);
  }
#line 8400
  return (1);
}
}
#line 8403 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
opj_j2k_t *opj_j2k_create_decompress(void) 
{ 
  opj_j2k_t *l_j2k ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 8405
  __cil_tmp2 = calloc(1UL, sizeof(opj_j2k_t ));
#line 8405
  l_j2k = (opj_j2k_t *)__cil_tmp2;
  }
#line 8406
  if (! l_j2k) {
#line 8407
    return ((opj_j2k_t *)0);
  }
  {
#line 8410
  l_j2k->m_is_decoder = 1;
#line 8411
  l_j2k->m_cp.m_is_decoder = (OPJ_UINT32 )1;
#line 8413
  __cil_tmp3 = calloc(1UL, sizeof(opj_tcp_t ));
#line 8413
  l_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t *)__cil_tmp3;
  }
#line 8414
  if (! l_j2k->m_specific_param.m_decoder.m_default_tcp) {
    {
#line 8415
    opj_j2k_destroy(l_j2k);
    }
#line 8416
    return ((opj_j2k_t *)0);
  }
  {
#line 8419
  __cil_tmp4 = calloc(1UL, 1000UL);
#line 8419
  l_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)__cil_tmp4;
  }
#line 8420
  if (! l_j2k->m_specific_param.m_decoder.m_header_data) {
    {
#line 8421
    opj_j2k_destroy(l_j2k);
    }
#line 8422
    return ((opj_j2k_t *)0);
  }
  {
#line 8425
  l_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )1000;
#line 8427
  l_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = -1;
#line 8429
  l_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = (OPJ_OFF_T )0;
#line 8432
  l_j2k->cstr_index = opj_j2k_create_cstr_index();
  }
#line 8433
  if (! l_j2k->cstr_index) {
    {
#line 8434
    opj_j2k_destroy(l_j2k);
    }
#line 8435
    return ((opj_j2k_t *)0);
  }
  {
#line 8439
  l_j2k->m_validation_list = opj_procedure_list_create();
  }
#line 8440
  if (! l_j2k->m_validation_list) {
    {
#line 8441
    opj_j2k_destroy(l_j2k);
    }
#line 8442
    return ((opj_j2k_t *)0);
  }
  {
#line 8446
  l_j2k->m_procedure_list = opj_procedure_list_create();
  }
#line 8447
  if (! l_j2k->m_procedure_list) {
    {
#line 8448
    opj_j2k_destroy(l_j2k);
    }
#line 8449
    return ((opj_j2k_t *)0);
  }
#line 8452
  return (l_j2k);
}
}
#line 8455 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
opj_codestream_index_t *opj_j2k_create_cstr_index(void) 
{ 
  opj_codestream_index_t *cstr_index ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 8457
  __cil_tmp2 = calloc(1UL, sizeof(opj_codestream_index_t ));
#line 8457
  cstr_index = (opj_codestream_index_t *)__cil_tmp2;
  }
#line 8459
  if (! cstr_index) {
#line 8460
    return ((opj_codestream_index_t *)((void *)0));
  }
  {
#line 8462
  cstr_index->maxmarknum = (OPJ_UINT32 )100;
#line 8463
  cstr_index->marknum = (OPJ_UINT32 )0;
#line 8464
  __cil_tmp3 = calloc((unsigned long )cstr_index->maxmarknum, sizeof(opj_marker_info_t ));
#line 8464
  cstr_index->marker = (opj_marker_info_t *)__cil_tmp3;
  }
#line 8466
  if (! cstr_index->marker) {
#line 8467
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 8469
  cstr_index->tile_index = (opj_tile_index_t *)((void *)0);
#line 8471
  return (cstr_index);
}
}
#line 8474 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                        OPJ_UINT32 p_comp_no ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 8478
  l_cp = (opj_cp_t *)0;
#line 8479
  l_tcp = (opj_tcp_t *)0;
#line 8480
  l_tccp = (opj_tccp_t *)0;
#line 8485
  l_cp = & p_j2k->m_cp;
#line 8486
  l_tcp = l_cp->tcps + p_tile_no;
#line 8487
  l_tccp = l_tcp->tccps + p_comp_no;
#line 8493
  if (l_tccp->csty & 1U) {
#line 8494
    return (5U + l_tccp->numresolutions);
  } else {
#line 8497
    return ((OPJ_UINT32 )5);
  }
}
}
#line 8501 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                   OPJ_BYTE *p_data , OPJ_UINT32 *p_header_size ,
                                   struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 8509
  l_cp = (opj_cp_t *)0;
#line 8510
  l_tcp = (opj_tcp_t *)0;
#line 8511
  l_tccp = (opj_tccp_t *)0;
#line 8519
  l_cp = & p_j2k->m_cp;
#line 8520
  l_tcp = l_cp->tcps + p_tile_no;
#line 8521
  l_tccp = l_tcp->tccps + p_comp_no;
#line 8527
  if (*p_header_size < 5U) {
    {
#line 8528
    opj_event_msg(p_manager, 1, "Error writing SPCod SPCoc element\n");
    }
#line 8529
    return (0);
  }
  {
#line 8532
  opj_write_bytes_LE(p_data, l_tccp->numresolutions - 1U, (OPJ_UINT32 )1);
#line 8533
  p_data ++;
#line 8535
  opj_write_bytes_LE(p_data, l_tccp->cblkw - 2U, (OPJ_UINT32 )1);
#line 8536
  p_data ++;
#line 8538
  opj_write_bytes_LE(p_data, l_tccp->cblkh - 2U, (OPJ_UINT32 )1);
#line 8539
  p_data ++;
#line 8541
  opj_write_bytes_LE(p_data, l_tccp->cblksty, (OPJ_UINT32 )1);
#line 8542
  p_data ++;
#line 8544
  opj_write_bytes_LE(p_data, l_tccp->qmfbid, (OPJ_UINT32 )1);
#line 8545
  p_data ++;
#line 8547
  *p_header_size -= 5U;
  }
#line 8549
  if (l_tccp->csty & 1U) {
#line 8551
    if (*p_header_size < l_tccp->numresolutions) {
      {
#line 8552
      opj_event_msg(p_manager, 1, "Error writing SPCod SPCoc element\n\347iEV");
      }
#line 8553
      return (0);
    }
#line 8556
    i = (OPJ_UINT32 )0;
    {
#line 8556
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8556
      if (! (i < l_tccp->numresolutions)) {
#line 8556
        goto while_break;
      }
      {
#line 8557
      opj_write_bytes_LE(p_data, l_tccp->prcw[i] + (l_tccp->prch[i] << 4), (OPJ_UINT32 )1);
#line 8558
      p_data ++;
#line 8556
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 8561
    *p_header_size -= l_tccp->numresolutions;
  }
#line 8564
  return (1);
}
}
#line 8567 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 compno , OPJ_BYTE *p_header_data ,
                                  OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_tmp ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_BYTE *l_current_ptr ;
  opj_tcp_t *tmp___2 ;

  {
#line 8574
  l_cp = (opj_cp_t *)((void *)0);
#line 8575
  l_tcp = (opj_tcp_t *)((void *)0);
#line 8576
  l_tccp = (opj_tccp_t *)((void *)0);
#line 8577
  l_current_ptr = (OPJ_BYTE *)((void *)0);
#line 8584
  l_cp = & p_j2k->m_cp;
#line 8585
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 8585
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 8585
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 8585
  l_tcp = tmp___2;
#line 8592
  l_tccp = l_tcp->tccps + compno;
#line 8593
  l_current_ptr = p_header_data;
#line 8596
  if (*p_header_size < 5U) {
    {
#line 8597
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element\n");
    }
#line 8598
    return (0);
  }
  {
#line 8601
  opj_read_bytes_LE(l_current_ptr, & l_tccp->numresolutions, (OPJ_UINT32 )1);
#line 8602
  (l_tccp->numresolutions) ++;
  }
#line 8603
  if (l_tccp->numresolutions > 33U) {
    {
#line 8604
    opj_event_msg(p_manager, 1, "Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\n",
                  l_tccp->numresolutions, 33);
    }
#line 8607
    return (0);
  }
#line 8609
  l_current_ptr ++;
#line 8612
  if (l_cp->m_specific_param.m_dec.m_reduce >= l_tccp->numresolutions) {
    {
#line 8613
    opj_event_msg(p_manager, 1, "Error decoding component %d.\nThe number of resolutions to remove is higher than the number of resolutions of this component\nModify the cp_reduce parameter.\n\n\360\347iEV",
                  compno);
#line 8615
    p_j2k->m_specific_param.m_decoder.m_state |= 32768U;
    }
#line 8616
    return (0);
  }
  {
#line 8619
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblkw, (OPJ_UINT32 )1);
#line 8620
  l_current_ptr ++;
#line 8621
  l_tccp->cblkw += 2U;
#line 8623
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblkh, (OPJ_UINT32 )1);
#line 8624
  l_current_ptr ++;
#line 8625
  l_tccp->cblkh += 2U;
#line 8627
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblksty, (OPJ_UINT32 )1);
#line 8628
  l_current_ptr ++;
#line 8630
  opj_read_bytes_LE(l_current_ptr, & l_tccp->qmfbid, (OPJ_UINT32 )1);
#line 8631
  l_current_ptr ++;
#line 8633
  *p_header_size -= 5U;
  }
#line 8636
  if (l_tccp->csty & 1U) {
#line 8637
    if (*p_header_size < l_tccp->numresolutions) {
      {
#line 8638
      opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element\n");
      }
#line 8639
      return (0);
    }
#line 8642
    i = (OPJ_UINT32 )0;
    {
#line 8642
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8642
      if (! (i < l_tccp->numresolutions)) {
#line 8642
        goto while_break;
      }
      {
#line 8643
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 8644
      l_current_ptr ++;
      }
#line 8646
      if (i != 0U) {
#line 8646
        if ((l_tmp & 15U) == 0U) {
          {
#line 8647
          opj_event_msg(p_manager, 1, "Invalid precinct size\n");
          }
#line 8648
          return (0);
        } else
#line 8646
        if (l_tmp >> 4 == 0U) {
          {
#line 8647
          opj_event_msg(p_manager, 1, "Invalid precinct size\n");
          }
#line 8648
          return (0);
        }
      }
#line 8650
      l_tccp->prcw[i] = l_tmp & 15U;
#line 8651
      l_tccp->prch[i] = l_tmp >> 4;
#line 8642
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
#line 8654
    *p_header_size -= l_tccp->numresolutions;
  } else {
#line 8658
    i = (OPJ_UINT32 )0;
    {
#line 8658
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 8658
      if (! (i < l_tccp->numresolutions)) {
#line 8658
        goto while_break___0;
      }
#line 8659
      l_tccp->prcw[i] = (OPJ_UINT32 )15;
#line 8660
      l_tccp->prch[i] = (OPJ_UINT32 )15;
#line 8658
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 8681
  return (1);
}
}
#line 8684 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_ref_tccp ;
  opj_tccp_t *l_copied_tccp ;
  OPJ_UINT32 l_prc_size ;
  opj_tcp_t *tmp___0 ;

  {
#line 8688
  l_cp = (opj_cp_t *)((void *)0);
#line 8689
  l_tcp = (opj_tcp_t *)((void *)0);
#line 8690
  l_ref_tccp = (opj_tccp_t *)((void *)0);
#line 8690
  l_copied_tccp = (opj_tccp_t *)((void *)0);
#line 8696
  l_cp = & p_j2k->m_cp;
#line 8697
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 8697
    tmp___0 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 8697
    tmp___0 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 8697
  l_tcp = tmp___0;
#line 8701
  l_ref_tccp = l_tcp->tccps + 0;
#line 8702
  l_copied_tccp = l_ref_tccp + 1;
#line 8703
  l_prc_size = l_ref_tccp->numresolutions * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 8705
  i = (OPJ_UINT32 )1;
  {
#line 8705
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8705
    if (! (i < (p_j2k->m_private_image)->numcomps)) {
#line 8705
      goto while_break;
    }
    {
#line 8706
    l_copied_tccp->numresolutions = l_ref_tccp->numresolutions;
#line 8707
    l_copied_tccp->cblkw = l_ref_tccp->cblkw;
#line 8708
    l_copied_tccp->cblkh = l_ref_tccp->cblkh;
#line 8709
    l_copied_tccp->cblksty = l_ref_tccp->cblksty;
#line 8710
    l_copied_tccp->qmfbid = l_ref_tccp->qmfbid;
#line 8711
    memcpy((void *)(l_copied_tccp->prcw), (void const   *)(l_ref_tccp->prcw), (unsigned long )l_prc_size);
#line 8712
    memcpy((void *)(l_copied_tccp->prch), (void const   *)(l_ref_tccp->prch), (unsigned long )l_prc_size);
#line 8713
    l_copied_tccp ++;
#line 8705
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 8709
  return;
}
}
#line 8717 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ) 
{ 
  OPJ_UINT32 l_num_bands ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  unsigned int tmp___2 ;

  {
#line 8723
  l_cp = (opj_cp_t *)0;
#line 8724
  l_tcp = (opj_tcp_t *)0;
#line 8725
  l_tccp = (opj_tccp_t *)0;
#line 8730
  l_cp = & p_j2k->m_cp;
#line 8731
  l_tcp = l_cp->tcps + p_tile_no;
#line 8732
  l_tccp = l_tcp->tccps + p_comp_no;
#line 8738
  if (l_tccp->qntsty == 1U) {
#line 8738
    tmp___2 = 1U;
  } else {
#line 8738
    tmp___2 = l_tccp->numresolutions * 3U - 2U;
  }
#line 8738
  l_num_bands = tmp___2;
#line 8740
  if (l_tccp->qntsty == 0U) {
#line 8741
    return (1U + l_num_bands);
  } else {
#line 8744
    return (1U + 2U * l_num_bands);
  }
}
}
#line 8748 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                 OPJ_BYTE *p_data , OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_header_size ;
  OPJ_UINT32 l_band_no ;
  OPJ_UINT32 l_num_bands ;
  OPJ_UINT32 l_expn ;
  OPJ_UINT32 l_mant ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  unsigned int tmp___5 ;

  {
#line 8759
  l_cp = (opj_cp_t *)0;
#line 8760
  l_tcp = (opj_tcp_t *)0;
#line 8761
  l_tccp = (opj_tccp_t *)0;
#line 8769
  l_cp = & p_j2k->m_cp;
#line 8770
  l_tcp = l_cp->tcps + p_tile_no;
#line 8771
  l_tccp = l_tcp->tccps + p_comp_no;
#line 8777
  if (l_tccp->qntsty == 1U) {
#line 8777
    tmp___5 = 1U;
  } else {
#line 8777
    tmp___5 = l_tccp->numresolutions * 3U - 2U;
  }
#line 8777
  l_num_bands = tmp___5;
#line 8779
  if (l_tccp->qntsty == 0U) {
#line 8780
    l_header_size = 1U + l_num_bands;
#line 8782
    if (*p_header_size < l_header_size) {
      {
#line 8783
      opj_event_msg(p_manager, 1, "Error writing SQcd SQcc element\n\220");
      }
#line 8784
      return (0);
    }
    {
#line 8787
    opj_write_bytes_LE(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5), (OPJ_UINT32 )1);
#line 8788
    p_data ++;
#line 8790
    l_band_no = (OPJ_UINT32 )0;
    }
    {
#line 8790
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8790
      if (! (l_band_no < l_num_bands)) {
#line 8790
        goto while_break;
      }
      {
#line 8791
      l_expn = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].expn;
#line 8792
      opj_write_bytes_LE(p_data, l_expn << 3, (OPJ_UINT32 )1);
#line 8793
      p_data ++;
#line 8790
      l_band_no ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 8797
    l_header_size = 1U + 2U * l_num_bands;
#line 8799
    if (*p_header_size < l_header_size) {
      {
#line 8800
      opj_event_msg(p_manager, 1, "Error writing SQcd SQcc element\n\220");
      }
#line 8801
      return (0);
    }
    {
#line 8804
    opj_write_bytes_LE(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5), (OPJ_UINT32 )1);
#line 8805
    p_data ++;
#line 8807
    l_band_no = (OPJ_UINT32 )0;
    }
    {
#line 8807
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 8807
      if (! (l_band_no < l_num_bands)) {
#line 8807
        goto while_break___0;
      }
      {
#line 8808
      l_expn = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].expn;
#line 8809
      l_mant = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].mant;
#line 8811
      opj_write_bytes_LE(p_data, (l_expn << 11) + l_mant, (OPJ_UINT32 )2);
#line 8812
      p_data += 2;
#line 8807
      l_band_no ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 8816
  *p_header_size -= l_header_size;
#line 8818
  return (1);
}
}
#line 8821 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_header_data ,
                                OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_band_no ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_BYTE *l_current_ptr ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_num_band ;
  opj_tcp_t *tmp___2 ;
  OPJ_UINT32 tmp___4 ;
  OPJ_INT32 tmp___5 ;

  {
#line 8830
  l_cp = (opj_cp_t *)0;
#line 8831
  l_tcp = (opj_tcp_t *)0;
#line 8832
  l_tccp = (opj_tccp_t *)0;
#line 8833
  l_current_ptr = (OPJ_BYTE *)0;
#line 8841
  l_cp = & p_j2k->m_cp;
#line 8843
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 8843
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 8843
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 8843
  l_tcp = tmp___2;
#line 8850
  l_tccp = l_tcp->tccps + p_comp_no;
#line 8851
  l_current_ptr = p_header_data;
#line 8853
  if (*p_header_size < 1U) {
    {
#line 8854
    opj_event_msg(p_manager, 1, "Error reading SQcd or SQcc element\n");
    }
#line 8855
    return (0);
  }
  {
#line 8857
  (*p_header_size) --;
#line 8859
  opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 8860
  l_current_ptr ++;
#line 8862
  l_tccp->qntsty = l_tmp & 31U;
#line 8863
  l_tccp->numgbits = l_tmp >> 5;
  }
#line 8864
  if (l_tccp->qntsty == 1U) {
#line 8865
    l_num_band = (OPJ_UINT32 )1;
  } else {
#line 8868
    if (l_tccp->qntsty == 0U) {
#line 8868
      tmp___4 = *p_header_size;
    } else {
#line 8868
      tmp___4 = *p_header_size / 2U;
    }
#line 8868
    l_num_band = tmp___4;
#line 8872
    if (l_num_band > 97U) {
      {
#line 8873
      opj_event_msg(p_manager, 2, "While reading CCP_QNTSTY element inside QCD or QCC marker segment, number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to OPJ_J2K_MAXBANDS (%d) and skip the rest. \n",
                    l_num_band, 97, 97);
      }
    }
  }
#line 8902
  if (l_tccp->qntsty == 0U) {
#line 8903
    l_band_no = (OPJ_UINT32 )0;
    {
#line 8903
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8903
      if (! (l_band_no < l_num_band)) {
#line 8903
        goto while_break;
      }
      {
#line 8904
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 8905
      l_current_ptr ++;
      }
#line 8906
      if (l_band_no < 97U) {
#line 8907
        l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32 )(l_tmp >> 3);
#line 8908
        l_tccp->stepsizes[l_band_no].mant = 0;
      }
#line 8903
      l_band_no ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: 
#line 8911
    *p_header_size -= l_num_band;
  } else {
#line 8914
    l_band_no = (OPJ_UINT32 )0;
    {
#line 8914
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 8914
      if (! (l_band_no < l_num_band)) {
#line 8914
        goto while_break___0;
      }
      {
#line 8915
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )2);
#line 8916
      l_current_ptr += 2;
      }
#line 8917
      if (l_band_no < 97U) {
#line 8918
        l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32 )(l_tmp >> 11);
#line 8919
        l_tccp->stepsizes[l_band_no].mant = (OPJ_INT32 )(l_tmp & 2047U);
      }
#line 8914
      l_band_no ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 8922
    *p_header_size -= 2U * l_num_band;
  }
#line 8926
  if (l_tccp->qntsty == 1U) {
#line 8927
    l_band_no = (OPJ_UINT32 )1;
    {
#line 8927
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 8927
      if (! (l_band_no < 97U)) {
#line 8927
        goto while_break___1;
      }
#line 8928
      if (l_tccp->stepsizes[0].expn - (OPJ_INT32 )((l_band_no - 1U) / 3U) > 0) {
#line 8928
        tmp___5 = l_tccp->stepsizes[0].expn - (OPJ_INT32 )((l_band_no - 1U) / 3U);
      } else {
#line 8928
        tmp___5 = 0;
      }
#line 8928
      l_tccp->stepsizes[l_band_no].expn = tmp___5;
#line 8931
      l_tccp->stepsizes[l_band_no].mant = l_tccp->stepsizes[0].mant;
#line 8927
      l_band_no ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 8935
  return (1);
}
}
#line 8938 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_ref_tccp ;
  opj_tccp_t *l_copied_tccp ;
  OPJ_UINT32 l_size ;
  opj_tcp_t *tmp___0 ;

  {
#line 8941
  l_cp = (opj_cp_t *)((void *)0);
#line 8942
  l_tcp = (opj_tcp_t *)((void *)0);
#line 8943
  l_ref_tccp = (opj_tccp_t *)((void *)0);
#line 8944
  l_copied_tccp = (opj_tccp_t *)((void *)0);
#line 8950
  l_cp = & p_j2k->m_cp;
#line 8951
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 8951
    tmp___0 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 8951
    tmp___0 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 8951
  l_tcp = tmp___0;
#line 8955
  l_ref_tccp = l_tcp->tccps + 0;
#line 8956
  l_copied_tccp = l_ref_tccp + 1;
#line 8957
  l_size = (OPJ_UINT32 )(97UL * sizeof(opj_stepsize_t ));
#line 8959
  i = (OPJ_UINT32 )1;
  {
#line 8959
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8959
    if (! (i < (p_j2k->m_private_image)->numcomps)) {
#line 8959
      goto while_break;
    }
    {
#line 8960
    l_copied_tccp->qntsty = l_ref_tccp->qntsty;
#line 8961
    l_copied_tccp->numgbits = l_ref_tccp->numgbits;
#line 8962
    memcpy((void *)(l_copied_tccp->stepsizes), (void const   *)(l_ref_tccp->stepsizes),
           (unsigned long )l_size);
#line 8963
    l_copied_tccp ++;
#line 8959
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 8963
  return;
}
}
#line 8967 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static void opj_j2k_dump_tile_info(opj_tcp_t *l_default_tile , OPJ_INT32 numcomps ,
                                   FILE *out_stream ) 
{ 
  OPJ_INT32 compno ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 resno ;
  OPJ_INT32 bandno ;
  OPJ_INT32 numbands ;
  int tmp ;

  {
#line 8969
  if (l_default_tile) {
    {
#line 8973
    fprintf(out_stream, "\t default tile {\n1\351iEV");
#line 8974
    fprintf(out_stream, "\t\t csty=%#x\n", l_default_tile->csty);
#line 8975
    fprintf(out_stream, "\t\t prg=%#x\niEV", (int )l_default_tile->prg);
#line 8976
    fprintf(out_stream, "\t\t numlayers=%d\n\230\001", l_default_tile->numlayers);
#line 8977
    fprintf(out_stream, "\t\t mct=%x\n", l_default_tile->mct);
#line 8979
    compno = 0;
    }
    {
#line 8979
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8979
      if (! (compno < numcomps)) {
#line 8979
        goto while_break;
      }
      {
#line 8980
      l_tccp = l_default_tile->tccps + compno;
#line 8985
      fprintf(out_stream, "\t\t comp %d {\n", compno);
#line 8986
      fprintf(out_stream, "\t\t\t csty=%#x\n", l_tccp->csty);
#line 8987
      fprintf(out_stream, "\t\t\t numresolutions=%d\n", l_tccp->numresolutions);
#line 8988
      fprintf(out_stream, "\t\t\t cblkw=2^%d\n", l_tccp->cblkw);
#line 8989
      fprintf(out_stream, "\t\t\t cblkh=2^%d\n", l_tccp->cblkh);
#line 8990
      fprintf(out_stream, "\t\t\t cblksty=%#x\n\230\001", l_tccp->cblksty);
#line 8991
      fprintf(out_stream, "\t\t\t qmfbid=%d\n", l_tccp->qmfbid);
#line 8993
      fprintf(out_stream, "\t\t\t preccintsize (w,h)=");
#line 8994
      resno = (OPJ_UINT32 )0;
      }
      {
#line 8994
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 8994
        if (! (resno < l_tccp->numresolutions)) {
#line 8994
          goto while_break___0;
        }
        {
#line 8995
        fprintf(out_stream, "(%d,%d) \230\001", l_tccp->prcw[resno], l_tccp->prch[resno]);
#line 8994
        resno ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: 
      {
#line 8997
      fprintf(out_stream, "\n\030\351iEV");
#line 9000
      fprintf(out_stream, "\t\t\t qntsty=%d\n", l_tccp->qntsty);
#line 9001
      fprintf(out_stream, "\t\t\t numgbits=%d\n\230\001", l_tccp->numgbits);
#line 9002
      fprintf(out_stream, "\t\t\t stepsizes (m,e)=EV");
      }
#line 9003
      if (l_tccp->qntsty == 1U) {
#line 9003
        tmp = 1;
      } else {
#line 9003
        tmp = (OPJ_INT32 )l_tccp->numresolutions * 3 - 2;
      }
#line 9003
      numbands = tmp;
#line 9004
      bandno = 0;
      {
#line 9004
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 9004
        if (! (bandno < numbands)) {
#line 9004
          goto while_break___1;
        }
        {
#line 9005
        fprintf(out_stream, "(%d,%d) \230\001", l_tccp->stepsizes[bandno].mant, l_tccp->stepsizes[bandno].expn);
#line 9004
        bandno ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 9008
      fprintf(out_stream, "\n\022\351iEV");
#line 9011
      fprintf(out_stream, "\t\t\t roishift=%d\n\230\001", l_tccp->roishift);
#line 9013
      fprintf(out_stream, "\t\t }\nV");
#line 8979
      compno ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: 
    {
#line 9015
    fprintf(out_stream, "\t }\n");
    }
  }
#line 9018
  return;
}
}
#line 9019 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void j2k_dump(opj_j2k_t *p_j2k , OPJ_INT32 flag , FILE *out_stream ) 
{ 
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 i ;
  opj_tcp_t *l_tcp ;

  {
#line 9022
  if (flag & 128) {
    {
#line 9023
    fprintf(out_stream, "Wrong flag\n");
    }
#line 9024
    return;
  } else
#line 9022
  if (flag & 256) {
    {
#line 9023
    fprintf(out_stream, "Wrong flag\n");
    }
#line 9024
    return;
  }
#line 9028
  if (flag & 1) {
#line 9029
    if (p_j2k->m_private_image) {
      {
#line 9030
      j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);
      }
    }
  }
#line 9034
  if (flag & 2) {
    {
#line 9035
    opj_j2k_dump_MH_info(p_j2k, out_stream);
    }
  }
#line 9038
  if (flag & 8) {
#line 9039
    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 9041
    l_tcp = p_j2k->m_cp.tcps;
#line 9042
    i = (OPJ_UINT32 )0;
    {
#line 9042
    while (1) {
      while_continue: /* CIL Label */ ;

#line 9042
      if (! (i < l_nb_tiles)) {
#line 9042
        goto while_break;
      }
      {
#line 9043
      opj_j2k_dump_tile_info(l_tcp, (OPJ_INT32 )(p_j2k->m_private_image)->numcomps,
                             out_stream);
#line 9044
      l_tcp ++;
#line 9042
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 9054
  if (flag & 16) {
    {
#line 9055
    opj_j2k_dump_MH_index(p_j2k, out_stream);
    }
  }
#line 9062
  return;
}
}
#line 9065 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_dump_MH_index(opj_j2k_t *p_j2k , FILE *out_stream ) 
{ 
  opj_codestream_index_t *cstr_index ;
  OPJ_UINT32 it_marker ;
  OPJ_UINT32 it_tile ;
  OPJ_UINT32 it_tile_part ;
  OPJ_UINT32 l_acc_nb_of_tile_part ;
  OPJ_UINT32 nb_of_tile_part ;

  {
  {
#line 9067
  cstr_index = p_j2k->cstr_index;
#line 9070
  fprintf(out_stream, "Codestream index from main header: {\n");
#line 9072
  fprintf(out_stream, "\t Main header start position=%li\n\t Main header end position=%li\n",
          cstr_index->main_head_start, cstr_index->main_head_end);
#line 9076
  fprintf(out_stream, "\t Marker list: {\n");
  }
#line 9078
  if (cstr_index->marker) {
#line 9079
    it_marker = (OPJ_UINT32 )0;
    {
#line 9079
    while (1) {
      while_continue: /* CIL Label */ ;

#line 9079
      if (! (it_marker < cstr_index->marknum)) {
#line 9079
        goto while_break;
      }
      {
#line 9080
      fprintf(out_stream, "\t\t type=%#x, pos=%li, len=%d\n", (int )(cstr_index->marker + it_marker)->type,
              (cstr_index->marker + it_marker)->pos, (cstr_index->marker + it_marker)->len);
#line 9079
      it_marker ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 9087
  fprintf(out_stream, "\t }\n");
  }
#line 9089
  if (cstr_index->tile_index) {
#line 9092
    l_acc_nb_of_tile_part = (OPJ_UINT32 )0;
#line 9093
    it_tile = (OPJ_UINT32 )0;
    {
#line 9093
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 9093
      if (! (it_tile < cstr_index->nb_of_tiles)) {
#line 9093
        goto while_break___0;
      }
#line 9094
      l_acc_nb_of_tile_part += (cstr_index->tile_index + it_tile)->nb_tps;
#line 9093
      it_tile ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: ;
#line 9097
    if (l_acc_nb_of_tile_part) {
      {
#line 9099
      fprintf(out_stream, "\t Tile index: {\n\220");
#line 9101
      it_tile = (OPJ_UINT32 )0;
      }
      {
#line 9101
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 9101
        if (! (it_tile < cstr_index->nb_of_tiles)) {
#line 9101
          goto while_break___1;
        }
        {
#line 9102
        nb_of_tile_part = (cstr_index->tile_index + it_tile)->nb_tps;
#line 9104
        fprintf(out_stream, "\t\t nb of tile-part in tile [%d]=%d\n", it_tile, nb_of_tile_part);
        }
#line 9106
        if ((cstr_index->tile_index + it_tile)->tp_index) {
#line 9107
          it_tile_part = (OPJ_UINT32 )0;
          {
#line 9107
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 9107
            if (! (it_tile_part < nb_of_tile_part)) {
#line 9107
              goto while_break___2;
            }
            {
#line 9108
            fprintf(out_stream, "\t\t\t tile-part[%d]: star_pos=%li, end_header=%li, end_pos=%li.\n",
                    it_tile_part, ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->start_pos,
                    ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->end_header,
                    ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->end_pos);
#line 9107
            it_tile_part ++;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
          while_break___2: ;
        }
#line 9116
        if ((cstr_index->tile_index + it_tile)->marker) {
#line 9117
          it_marker = (OPJ_UINT32 )0;
          {
#line 9117
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 9117
            if (! (it_marker < (cstr_index->tile_index + it_tile)->marknum)) {
#line 9117
              goto while_break___3;
            }
            {
#line 9118
            fprintf(out_stream, "\t\t type=%#x, pos=%li, len=%d\n", (int )((cstr_index->tile_index + it_tile)->marker + it_marker)->type,
                    ((cstr_index->tile_index + it_tile)->marker + it_marker)->pos,
                    ((cstr_index->tile_index + it_tile)->marker + it_marker)->len);
#line 9117
            it_marker ++;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___3: ;
        }
#line 9101
        it_tile ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 9125
      fprintf(out_stream, "\t }\n");
      }
    }
  }
  {
#line 9129
  fprintf(out_stream, "}\n");
  }
#line 9131
  return;
}
}
#line 9134 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_dump_MH_info(opj_j2k_t *p_j2k , FILE *out_stream ) 
{ 


  {
  {
#line 9137
  fprintf(out_stream, "Codestream info from main header: {\n");
#line 9139
  fprintf(out_stream, "\t tx0=%d, ty0=%d\n", p_j2k->m_cp.tx0, p_j2k->m_cp.ty0);
#line 9140
  fprintf(out_stream, "\t tdx=%d, tdy=%d\n", p_j2k->m_cp.tdx, p_j2k->m_cp.tdy);
#line 9141
  fprintf(out_stream, "\t tw=%d, th=%d\n", p_j2k->m_cp.tw, p_j2k->m_cp.th);
#line 9142
  opj_j2k_dump_tile_info(p_j2k->m_specific_param.m_decoder.m_default_tcp, (OPJ_INT32 )(p_j2k->m_private_image)->numcomps,
                         out_stream);
#line 9143
  fprintf(out_stream, "}\n");
  }
#line 9145
  return;
}
}
#line 9146 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void j2k_dump_image_header(opj_image_t *img_header , OPJ_BOOL dev_dump_flag , FILE *out_stream ) 
{ 
  char tab[2] ;
  OPJ_UINT32 compno ;

  {
#line 9150
  if (dev_dump_flag) {
    {
#line 9151
    fprintf(stdout, "[DEV] Dump an image_header struct {\n");
#line 9152
    tab[0] = (char )'\000';
    }
  } else {
    {
#line 9155
    fprintf(out_stream, "Image info {\n");
#line 9156
    tab[0] = (char )'\t';
#line 9156
    tab[1] = (char )'\000';
    }
  }
  {
#line 9159
  fprintf(out_stream, "%s x0=%d, y0=%d\n\230\001", tab, img_header->x0, img_header->y0);
#line 9160
  fprintf(out_stream, "%s x1=%d, y1=%d\n\230\001", tab, img_header->x1, img_header->y1);
#line 9161
  fprintf(out_stream, "%s numcomps=%d\n", tab, img_header->numcomps);
  }
#line 9163
  if (img_header->comps) {
#line 9165
    compno = (OPJ_UINT32 )0;
    {
#line 9165
    while (1) {
      while_continue: /* CIL Label */ ;

#line 9165
      if (! (compno < img_header->numcomps)) {
#line 9165
        goto while_break;
      }
      {
#line 9166
      fprintf(out_stream, "%s\t component %d {\n", tab, compno);
#line 9167
      j2k_dump_image_comp_header(img_header->comps + compno, dev_dump_flag, out_stream);
#line 9168
      fprintf(out_stream, "%s}\n", tab);
#line 9165
      compno ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 9172
  fprintf(out_stream, "}\n");
  }
#line 9174
  return;
}
}
#line 9175 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void j2k_dump_image_comp_header(opj_image_comp_t *comp_header , OPJ_BOOL dev_dump_flag ,
                                FILE *out_stream ) 
{ 
  char tab[3] ;

  {
#line 9179
  if (dev_dump_flag) {
    {
#line 9180
    fprintf(stdout, "[DEV] Dump an image_comp_header struct {\n");
#line 9181
    tab[0] = (char )'\000';
    }
  } else {
#line 9183
    tab[0] = (char )'\t';
#line 9183
    tab[1] = (char )'\t';
#line 9183
    tab[2] = (char )'\000';
  }
  {
#line 9186
  fprintf(out_stream, "%s dx=%d, dy=%d\n\230\001", tab, comp_header->dx, comp_header->dy);
#line 9187
  fprintf(out_stream, "%s prec=%d\n", tab, comp_header->prec);
#line 9188
  fprintf(out_stream, "%s sgnd=%d\n", tab, comp_header->sgnd);
  }
#line 9190
  if (dev_dump_flag) {
    {
#line 9191
    fprintf(out_stream, "}\n");
    }
  }
#line 9194
  return;
}
}
#line 9194 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
opj_codestream_info_v2_t *j2k_get_cstr_info(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 numcomps ;
  opj_tcp_t *l_default_tile ;
  opj_codestream_info_v2_t *cstr_info ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_tccp_t *l_tccp ;
  opj_tccp_info_t *l_tccp_info ;
  OPJ_INT32 bandno ;
  OPJ_INT32 numbands ;
  int tmp ;

  {
  {
#line 9197
  numcomps = (p_j2k->m_private_image)->numcomps;
#line 9199
  __cil_tmp6 = calloc(1UL, sizeof(opj_codestream_info_v2_t ));
#line 9199
  cstr_info = (opj_codestream_info_v2_t *)__cil_tmp6;
  }
#line 9200
  if (! cstr_info) {
#line 9201
    return ((opj_codestream_info_v2_t *)((void *)0));
  }
  {
#line 9203
  cstr_info->nbcomps = (p_j2k->m_private_image)->numcomps;
#line 9205
  cstr_info->tx0 = p_j2k->m_cp.tx0;
#line 9206
  cstr_info->ty0 = p_j2k->m_cp.ty0;
#line 9207
  cstr_info->tdx = p_j2k->m_cp.tdx;
#line 9208
  cstr_info->tdy = p_j2k->m_cp.tdy;
#line 9209
  cstr_info->tw = p_j2k->m_cp.tw;
#line 9210
  cstr_info->th = p_j2k->m_cp.th;
#line 9212
  cstr_info->tile_info = (opj_tile_info_v2_t *)((void *)0);
#line 9214
  l_default_tile = p_j2k->m_specific_param.m_decoder.m_default_tcp;
#line 9216
  cstr_info->m_default_tile_info.csty = l_default_tile->csty;
#line 9217
  cstr_info->m_default_tile_info.prg = l_default_tile->prg;
#line 9218
  cstr_info->m_default_tile_info.numlayers = l_default_tile->numlayers;
#line 9219
  cstr_info->m_default_tile_info.mct = l_default_tile->mct;
#line 9221
  __cil_tmp7 = calloc((unsigned long )cstr_info->nbcomps, sizeof(opj_tccp_info_t ));
#line 9221
  cstr_info->m_default_tile_info.tccp_info = (opj_tccp_info_t *)__cil_tmp7;
  }
#line 9222
  if (! cstr_info->m_default_tile_info.tccp_info) {
    {
#line 9224
    opj_destroy_cstr_info(& cstr_info);
    }
#line 9225
    return ((opj_codestream_info_v2_t *)((void *)0));
  }
#line 9228
  compno = (OPJ_UINT32 )0;
  {
#line 9228
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9228
    if (! (compno < numcomps)) {
#line 9228
      goto while_break;
    }
#line 9229
    l_tccp = l_default_tile->tccps + compno;
#line 9230
    l_tccp_info = cstr_info->m_default_tile_info.tccp_info + compno;
#line 9234
    l_tccp_info->csty = l_tccp->csty;
#line 9235
    l_tccp_info->numresolutions = l_tccp->numresolutions;
#line 9236
    l_tccp_info->cblkw = l_tccp->cblkw;
#line 9237
    l_tccp_info->cblkh = l_tccp->cblkh;
#line 9238
    l_tccp_info->cblksty = l_tccp->cblksty;
#line 9239
    l_tccp_info->qmfbid = l_tccp->qmfbid;
#line 9240
    if (l_tccp->numresolutions < 33U) {
      {
#line 9242
      memcpy((void *)(l_tccp_info->prch), (void const   *)(l_tccp->prch), (unsigned long )l_tccp->numresolutions);
#line 9243
      memcpy((void *)(l_tccp_info->prcw), (void const   *)(l_tccp->prcw), (unsigned long )l_tccp->numresolutions);
      }
    }
#line 9247
    l_tccp_info->qntsty = l_tccp->qntsty;
#line 9248
    l_tccp_info->numgbits = l_tccp->numgbits;
#line 9250
    if (l_tccp->qntsty == 1U) {
#line 9250
      tmp = 1;
    } else {
#line 9250
      tmp = (OPJ_INT32 )l_tccp->numresolutions * 3 - 2;
    }
#line 9250
    numbands = tmp;
#line 9251
    if (numbands < 97) {
#line 9252
      bandno = 0;
      {
#line 9252
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 9252
        if (! (bandno < numbands)) {
#line 9252
          goto while_break___0;
        }
#line 9253
        l_tccp_info->stepsizes_mant[bandno] = (OPJ_UINT32 )l_tccp->stepsizes[bandno].mant;
#line 9254
        l_tccp_info->stepsizes_expn[bandno] = (OPJ_UINT32 )l_tccp->stepsizes[bandno].expn;
#line 9252
        bandno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
    }
#line 9259
    l_tccp_info->roishift = l_tccp->roishift;
#line 9228
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 9262
  return (cstr_info);
}
}
#line 9265 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
opj_codestream_index_t *j2k_get_cstr_index(opj_j2k_t *p_j2k ) 
{ 
  opj_codestream_index_t *l_cstr_index ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  OPJ_UINT32 it_tile ;
  void *__cil_tmp7 ;
  OPJ_UINT32 it_tile_free ;
  void *__cil_tmp10 ;
  OPJ_UINT32 it_tile_free___0 ;

  {
  {
#line 9267
  __cil_tmp3 = calloc(1UL, sizeof(opj_codestream_index_t ));
#line 9267
  l_cstr_index = (opj_codestream_index_t *)__cil_tmp3;
  }
#line 9269
  if (! l_cstr_index) {
#line 9270
    return ((opj_codestream_index_t *)((void *)0));
  }
  {
#line 9272
  l_cstr_index->main_head_start = (p_j2k->cstr_index)->main_head_start;
#line 9273
  l_cstr_index->main_head_end = (p_j2k->cstr_index)->main_head_end;
#line 9274
  l_cstr_index->codestream_size = (p_j2k->cstr_index)->codestream_size;
#line 9276
  l_cstr_index->marknum = (p_j2k->cstr_index)->marknum;
#line 9277
  __cil_tmp4 = malloc((unsigned long )l_cstr_index->marknum * sizeof(opj_marker_info_t ));
#line 9277
  l_cstr_index->marker = (opj_marker_info_t *)__cil_tmp4;
  }
#line 9278
  if (! l_cstr_index->marker) {
    {
#line 9279
    free((void *)l_cstr_index);
    }
#line 9280
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 9283
  if ((p_j2k->cstr_index)->marker) {
    {
#line 9284
    memcpy((void *)l_cstr_index->marker, (void const   *)(p_j2k->cstr_index)->marker,
           (unsigned long )l_cstr_index->marknum * sizeof(opj_marker_info_t ));
    }
  } else {
    {
#line 9286
    free((void *)l_cstr_index->marker);
#line 9287
    l_cstr_index->marker = (opj_marker_info_t *)((void *)0);
    }
  }
  {
#line 9290
  l_cstr_index->nb_of_tiles = (p_j2k->cstr_index)->nb_of_tiles;
#line 9291
  __cil_tmp5 = calloc((unsigned long )l_cstr_index->nb_of_tiles, sizeof(opj_tile_index_t ));
#line 9291
  l_cstr_index->tile_index = (opj_tile_index_t *)__cil_tmp5;
  }
#line 9292
  if (! l_cstr_index->tile_index) {
    {
#line 9293
    free((void *)l_cstr_index->marker);
#line 9294
    free((void *)l_cstr_index);
    }
#line 9295
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 9298
  if (! (p_j2k->cstr_index)->tile_index) {
    {
#line 9299
    free((void *)l_cstr_index->tile_index);
#line 9300
    l_cstr_index->tile_index = (opj_tile_index_t *)((void *)0);
    }
  } else {
#line 9303
    it_tile = (OPJ_UINT32 )0;
#line 9304
    it_tile = (OPJ_UINT32 )0;
    {
#line 9304
    while (1) {
      while_continue: /* CIL Label */ ;

#line 9304
      if (! (it_tile < l_cstr_index->nb_of_tiles)) {
#line 9304
        goto while_break;
      }
      {
#line 9307
      (l_cstr_index->tile_index + it_tile)->marknum = ((p_j2k->cstr_index)->tile_index + it_tile)->marknum;
#line 9309
      __cil_tmp7 = malloc((unsigned long )(l_cstr_index->tile_index + it_tile)->marknum * sizeof(opj_marker_info_t ));
#line 9309
      (l_cstr_index->tile_index + it_tile)->marker = (opj_marker_info_t *)__cil_tmp7;
      }
#line 9312
      if (! (l_cstr_index->tile_index + it_tile)->marker) {
#line 9315
        it_tile_free = (OPJ_UINT32 )0;
        {
#line 9315
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 9315
          if (! (it_tile_free < it_tile)) {
#line 9315
            goto while_break___0;
          }
          {
#line 9316
          free((void *)(l_cstr_index->tile_index + it_tile_free)->marker);
#line 9315
          it_tile_free ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        while_break___0: 
        {
#line 9319
        free((void *)l_cstr_index->tile_index);
#line 9320
        free((void *)l_cstr_index->marker);
#line 9321
        free((void *)l_cstr_index);
        }
#line 9322
        return ((opj_codestream_index_t *)((void *)0));
      }
#line 9325
      if (((p_j2k->cstr_index)->tile_index + it_tile)->marker) {
        {
#line 9326
        memcpy((void *)(l_cstr_index->tile_index + it_tile)->marker, (void const   *)((p_j2k->cstr_index)->tile_index + it_tile)->marker,
               (unsigned long )(l_cstr_index->tile_index + it_tile)->marknum * sizeof(opj_marker_info_t ));
        }
      } else {
        {
#line 9330
        free((void *)(l_cstr_index->tile_index + it_tile)->marker);
#line 9331
        (l_cstr_index->tile_index + it_tile)->marker = (opj_marker_info_t *)((void *)0);
        }
      }
      {
#line 9335
      (l_cstr_index->tile_index + it_tile)->nb_tps = ((p_j2k->cstr_index)->tile_index + it_tile)->nb_tps;
#line 9337
      __cil_tmp10 = malloc((unsigned long )(l_cstr_index->tile_index + it_tile)->nb_tps * sizeof(opj_tp_index_t ));
#line 9337
      (l_cstr_index->tile_index + it_tile)->tp_index = (opj_tp_index_t *)__cil_tmp10;
      }
#line 9340
      if (! (l_cstr_index->tile_index + it_tile)->tp_index) {
#line 9343
        it_tile_free___0 = (OPJ_UINT32 )0;
        {
#line 9343
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 9343
          if (! (it_tile_free___0 < it_tile)) {
#line 9343
            goto while_break___1;
          }
          {
#line 9344
          free((void *)(l_cstr_index->tile_index + it_tile_free___0)->marker);
#line 9345
          free((void *)(l_cstr_index->tile_index + it_tile_free___0)->tp_index);
#line 9343
          it_tile_free___0 ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: 
        {
#line 9348
        free((void *)l_cstr_index->tile_index);
#line 9349
        free((void *)l_cstr_index->marker);
#line 9350
        free((void *)l_cstr_index);
        }
#line 9351
        return ((opj_codestream_index_t *)((void *)0));
      }
#line 9354
      if (((p_j2k->cstr_index)->tile_index + it_tile)->tp_index) {
        {
#line 9355
        memcpy((void *)(l_cstr_index->tile_index + it_tile)->tp_index, (void const   *)((p_j2k->cstr_index)->tile_index + it_tile)->tp_index,
               (unsigned long )(l_cstr_index->tile_index + it_tile)->nb_tps * sizeof(opj_tp_index_t ));
        }
      } else {
        {
#line 9360
        free((void *)(l_cstr_index->tile_index + it_tile)->tp_index);
#line 9361
        (l_cstr_index->tile_index + it_tile)->tp_index = (opj_tp_index_t *)((void *)0);
        }
      }
#line 9365
      (l_cstr_index->tile_index + it_tile)->nb_packet = (OPJ_UINT32 )0;
#line 9366
      (l_cstr_index->tile_index + it_tile)->packet_index = (opj_packet_info_t *)((void *)0);
#line 9304
      it_tile ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 9371
  return (l_cstr_index);
}
}
#line 9374 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 it_tile ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 9376
  it_tile = (OPJ_UINT32 )0;
#line 9378
  (p_j2k->cstr_index)->nb_of_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 9379
  __cil_tmp3 = calloc((unsigned long )(p_j2k->cstr_index)->nb_of_tiles, sizeof(opj_tile_index_t ));
#line 9379
  (p_j2k->cstr_index)->tile_index = (opj_tile_index_t *)__cil_tmp3;
  }
#line 9380
  if (! (p_j2k->cstr_index)->tile_index) {
#line 9381
    return (0);
  }
#line 9383
  it_tile = (OPJ_UINT32 )0;
  {
#line 9383
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9383
    if (! (it_tile < (p_j2k->cstr_index)->nb_of_tiles)) {
#line 9383
      goto while_break;
    }
    {
#line 9384
    ((p_j2k->cstr_index)->tile_index + it_tile)->maxmarknum = (OPJ_UINT32 )100;
#line 9385
    ((p_j2k->cstr_index)->tile_index + it_tile)->marknum = (OPJ_UINT32 )0;
#line 9386
    __cil_tmp4 = calloc((unsigned long )((p_j2k->cstr_index)->tile_index + it_tile)->maxmarknum,
                        sizeof(opj_marker_info_t ));
#line 9386
    ((p_j2k->cstr_index)->tile_index + it_tile)->marker = (opj_marker_info_t *)__cil_tmp4;
    }
#line 9388
    if (! ((p_j2k->cstr_index)->tile_index + it_tile)->marker) {
#line 9389
      return (0);
    }
#line 9383
    it_tile ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 9392
  return (1);
}
}
#line 9395 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_go_on ;
  OPJ_UINT32 l_current_tile_no ;
  OPJ_UINT32 l_data_size ;
  OPJ_UINT32 l_max_data_size ;
  OPJ_INT32 l_tile_x0 ;
  OPJ_INT32 l_tile_y0 ;
  OPJ_INT32 l_tile_x1 ;
  OPJ_INT32 l_tile_y1 ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 nr_tiles ;
  void *__cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_OFF_T __cil_tmp21 ;

  {
  {
#line 9399
  l_go_on = 1;
#line 9405
  nr_tiles = (OPJ_UINT32 )0;
#line 9407
  __cil_tmp15 = malloc(1000UL);
#line 9407
  l_current_data = (OPJ_BYTE *)__cil_tmp15;
  }
#line 9408
  if (! l_current_data) {
    {
#line 9409
    opj_event_msg(p_manager, 1, "Not enough memory to decode tiles\n");
    }
#line 9410
    return (0);
  }
#line 9412
  l_max_data_size = (OPJ_UINT32 )1000;
  {
#line 9414
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 9415
    __cil_tmp16 = opj_j2k_read_tile_header(p_j2k, & l_current_tile_no, & l_data_size,
                                           & l_tile_x0, & l_tile_y0, & l_tile_x1,
                                           & l_tile_y1, & l_nb_comps, & l_go_on, p_stream,
                                           p_manager);
    }
#line 9415
    if (! __cil_tmp16) {
      {
#line 9424
      free((void *)l_current_data);
      }
#line 9425
      return (0);
    }
#line 9428
    if (! l_go_on) {
#line 9429
      goto while_break;
    }
#line 9432
    if (l_data_size > l_max_data_size) {
      {
#line 9433
      __cil_tmp18 = realloc((void *)l_current_data, (unsigned long )l_data_size);
#line 9433
      l_new_current_data = (OPJ_BYTE *)__cil_tmp18;
      }
#line 9434
      if (! l_new_current_data) {
        {
#line 9435
        free((void *)l_current_data);
#line 9436
        opj_event_msg(p_manager, 1, "Not enough memory to decode tile %d/%d\n", l_current_tile_no + 1U,
                      p_j2k->m_cp.th * p_j2k->m_cp.tw);
        }
#line 9437
        return (0);
      }
#line 9439
      l_current_data = l_new_current_data;
#line 9440
      l_max_data_size = l_data_size;
    }
    {
#line 9443
    __cil_tmp19 = opj_j2k_decode_tile(p_j2k, l_current_tile_no, l_current_data, l_data_size,
                                      p_stream, p_manager);
    }
#line 9443
    if (! __cil_tmp19) {
      {
#line 9444
      free((void *)l_current_data);
#line 9445
      opj_event_msg(p_manager, 1, "Failed to decode tile %d/%d\nEV", l_current_tile_no + 1U,
                    p_j2k->m_cp.th * p_j2k->m_cp.tw);
      }
#line 9446
      return (0);
    }
    {
#line 9448
    opj_event_msg(p_manager, 4, "Tile %d/%d has been decoded.\nV", l_current_tile_no + 1U,
                  p_j2k->m_cp.th * p_j2k->m_cp.tw);
#line 9450
    __cil_tmp20 = opj_j2k_update_image_data(p_j2k->m_tcd, l_current_data, p_j2k->m_output_image);
    }
#line 9450
    if (! __cil_tmp20) {
      {
#line 9451
      free((void *)l_current_data);
      }
#line 9452
      return (0);
    }
    {
#line 9454
    opj_event_msg(p_manager, 4, "Image data has been updated with tile %d.\n\n", l_current_tile_no + 1U);
#line 9456
    __cil_tmp21 = opj_stream_get_number_byte_left(p_stream);
    }
#line 9456
    if (__cil_tmp21 == 0L) {
#line 9456
      if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 9458
        goto while_break;
      }
    }
#line 9459
    nr_tiles ++;
#line 9459
    if (nr_tiles == p_j2k->m_cp.th * p_j2k->m_cp.tw) {
#line 9460
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 9463
  free((void *)l_current_data);
  }
#line 9465
  return (1);
}
}
#line 9471 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static void opj_j2k_setup_decoding(opj_j2k_t *p_j2k ) 
{ 


  {
  {
#line 9476
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_decode_tiles));
  }
#line 9478
  return;
}
}
#line 9484 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_decode_one_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_go_on ;
  OPJ_UINT32 l_current_tile_no ;
  OPJ_UINT32 l_tile_no_to_dec ;
  OPJ_UINT32 l_data_size ;
  OPJ_UINT32 l_max_data_size ;
  OPJ_INT32 l_tile_x0 ;
  OPJ_INT32 l_tile_y0 ;
  OPJ_INT32 l_tile_x1 ;
  OPJ_INT32 l_tile_y1 ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_BYTE *l_current_data ;
  void *__cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;
  OPJ_BOOL __cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;

  {
  {
#line 9488
  l_go_on = 1;
#line 9496
  __cil_tmp15 = malloc(1000UL);
#line 9496
  l_current_data = (OPJ_BYTE *)__cil_tmp15;
  }
#line 9497
  if (! l_current_data) {
    {
#line 9498
    opj_event_msg(p_manager, 1, "Not enough memory to decode one tile\n");
    }
#line 9499
    return (0);
  }
#line 9501
  l_max_data_size = (OPJ_UINT32 )1000;
#line 9504
  if (! (p_j2k->cstr_index)->tile_index) {
    {
#line 9506
    __cil_tmp16 = opj_j2k_allocate_tile_element_cstr_index(p_j2k);
    }
#line 9506
    if (! __cil_tmp16) {
      {
#line 9507
      free((void *)l_current_data);
      }
#line 9508
      return (0);
    }
  }
#line 9512
  l_tile_no_to_dec = (OPJ_UINT32 )p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec;
#line 9513
  if ((p_j2k->cstr_index)->tile_index) {
#line 9514
    if (((p_j2k->cstr_index)->tile_index)->tp_index) {
#line 9516
      if (! ((p_j2k->cstr_index)->tile_index + l_tile_no_to_dec)->nb_tps) {
        {
#line 9519
        __cil_tmp17 = opj_stream_read_seek(p_stream, p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos + 2L,
                                           p_manager);
        }
#line 9519
        if (! __cil_tmp17) {
          {
#line 9520
          opj_event_msg(p_manager, 1, "Problem with seek function\niEV");
#line 9521
          free((void *)l_current_data);
          }
#line 9522
          return (0);
        }
      } else {
        {
#line 9526
        __cil_tmp18 = opj_stream_read_seek(p_stream, (((p_j2k->cstr_index)->tile_index + l_tile_no_to_dec)->tp_index + 0)->start_pos + 2L,
                                           p_manager);
        }
#line 9526
        if (! __cil_tmp18) {
          {
#line 9527
          opj_event_msg(p_manager, 1, "Problem with seek function\n");
#line 9528
          free((void *)l_current_data);
          }
#line 9529
          return (0);
        }
      }
#line 9533
      if (p_j2k->m_specific_param.m_decoder.m_state == 256U) {
#line 9534
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
      }
    }
  }
  {
#line 9537
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 9538
    __cil_tmp19 = opj_j2k_read_tile_header(p_j2k, & l_current_tile_no, & l_data_size,
                                           & l_tile_x0, & l_tile_y0, & l_tile_x1,
                                           & l_tile_y1, & l_nb_comps, & l_go_on, p_stream,
                                           p_manager);
    }
#line 9538
    if (! __cil_tmp19) {
      {
#line 9547
      free((void *)l_current_data);
      }
#line 9548
      return (0);
    }
#line 9551
    if (! l_go_on) {
#line 9552
      goto while_break;
    }
#line 9555
    if (l_data_size > l_max_data_size) {
      {
#line 9556
      __cil_tmp21 = realloc((void *)l_current_data, (unsigned long )l_data_size);
#line 9556
      l_new_current_data = (OPJ_BYTE *)__cil_tmp21;
      }
#line 9557
      if (! l_new_current_data) {
        {
#line 9558
        free((void *)l_current_data);
#line 9559
        l_current_data = (OPJ_BYTE *)((void *)0);
#line 9562
        opj_event_msg(p_manager, 1, "Not enough memory to decode tile %d/%d\n", l_current_tile_no,
                      p_j2k->m_cp.th * p_j2k->m_cp.tw - 1U);
        }
#line 9563
        return (0);
      }
#line 9565
      l_current_data = l_new_current_data;
#line 9566
      l_max_data_size = l_data_size;
    }
    {
#line 9569
    __cil_tmp22 = opj_j2k_decode_tile(p_j2k, l_current_tile_no, l_current_data, l_data_size,
                                      p_stream, p_manager);
    }
#line 9569
    if (! __cil_tmp22) {
      {
#line 9570
      free((void *)l_current_data);
      }
#line 9571
      return (0);
    }
    {
#line 9573
    opj_event_msg(p_manager, 4, "Tile %d/%d has been decoded.\n", l_current_tile_no,
                  p_j2k->m_cp.th * p_j2k->m_cp.tw - 1U);
#line 9575
    __cil_tmp23 = opj_j2k_update_image_data(p_j2k->m_tcd, l_current_data, p_j2k->m_output_image);
    }
#line 9575
    if (! __cil_tmp23) {
      {
#line 9576
      free((void *)l_current_data);
      }
#line 9577
      return (0);
    }
    {
#line 9579
    opj_event_msg(p_manager, 4, "Image data has been updated with tile %d.\n\n", l_current_tile_no);
    }
#line 9581
    if (l_current_tile_no == l_tile_no_to_dec) {
      {
#line 9584
      __cil_tmp24 = opj_stream_read_seek(p_stream, (p_j2k->cstr_index)->main_head_end + 2L,
                                         p_manager);
      }
#line 9584
      if (! __cil_tmp24) {
        {
#line 9585
        opj_event_msg(p_manager, 1, "Problem with seek function\n");
        }
#line 9586
        return (0);
      }
#line 9588
      goto while_break;
    } else {
      {
#line 9591
      opj_event_msg(p_manager, 2, "Tile read, decode and updated is not the desired (%d vs %d).\n",
                    l_current_tile_no, l_tile_no_to_dec);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 9596
  free((void *)l_current_data);
  }
#line 9598
  return (1);
}
}
#line 9604 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static void opj_j2k_setup_decoding_tile(opj_j2k_t *p_j2k ) 
{ 


  {
  {
#line 9609
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_decode_one_tile));
  }
#line 9611
  return;
}
}
#line 9614 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 9621
  if (! p_image) {
#line 9622
    return (0);
  }
  {
#line 9624
  p_j2k->m_output_image = opj_image_create0();
  }
#line 9625
  if (! p_j2k->m_output_image) {
#line 9626
    return (0);
  }
  {
#line 9628
  opj_copy_image_header(p_image, p_j2k->m_output_image);
#line 9631
  opj_j2k_setup_decoding(p_j2k);
#line 9634
  __cil_tmp7 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 9634
  if (! __cil_tmp7) {
    {
#line 9635
    opj_image_destroy(p_j2k->m_private_image);
#line 9636
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 9637
    return (0);
  }
#line 9641
  compno = (OPJ_UINT32 )0;
  {
#line 9641
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9641
    if (! (compno < p_image->numcomps)) {
#line 9641
      goto while_break;
    }
#line 9642
    (p_image->comps + compno)->resno_decoded = ((p_j2k->m_output_image)->comps + compno)->resno_decoded;
#line 9643
    (p_image->comps + compno)->data = ((p_j2k->m_output_image)->comps + compno)->data;
#line 9651
    ((p_j2k->m_output_image)->comps + compno)->data = (OPJ_INT32 *)((void *)0);
#line 9641
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 9654
  return (1);
}
}
#line 9657 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 l_tile_x ;
  OPJ_UINT32 l_tile_y ;
  opj_image_comp_t *l_img_comp ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  OPJ_BOOL __cil_tmp22 ;

  {
#line 9667
  if (! p_image) {
    {
#line 9668
    opj_event_msg(p_manager, 1, "We need an image previously created.\n");
    }
#line 9669
    return (0);
  }
#line 9672
  if (tile_index >= p_j2k->m_cp.tw * p_j2k->m_cp.th) {
    {
#line 9673
    opj_event_msg(p_manager, 1, "Tile index provided by the user is incorrect %d (max = %d) \n",
                  tile_index, p_j2k->m_cp.tw * p_j2k->m_cp.th - 1U);
    }
#line 9674
    return (0);
  }
#line 9678
  l_tile_x = tile_index % p_j2k->m_cp.tw;
#line 9679
  l_tile_y = tile_index / p_j2k->m_cp.tw;
#line 9681
  p_image->x0 = l_tile_x * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
#line 9682
  if (p_image->x0 < (p_j2k->m_private_image)->x0) {
#line 9683
    p_image->x0 = (p_j2k->m_private_image)->x0;
  }
#line 9684
  p_image->x1 = (l_tile_x + 1U) * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
#line 9685
  if (p_image->x1 > (p_j2k->m_private_image)->x1) {
#line 9686
    p_image->x1 = (p_j2k->m_private_image)->x1;
  }
#line 9688
  p_image->y0 = l_tile_y * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
#line 9689
  if (p_image->y0 < (p_j2k->m_private_image)->y0) {
#line 9690
    p_image->y0 = (p_j2k->m_private_image)->y0;
  }
#line 9691
  p_image->y1 = (l_tile_y + 1U) * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
#line 9692
  if (p_image->y1 > (p_j2k->m_private_image)->y1) {
#line 9693
    p_image->y1 = (p_j2k->m_private_image)->y1;
  }
#line 9695
  l_img_comp = p_image->comps;
#line 9696
  compno = (OPJ_UINT32 )0;
  {
#line 9696
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9696
    if (! (compno < p_image->numcomps)) {
#line 9696
      goto while_break;
    }
    {
#line 9700
    l_img_comp->factor = ((p_j2k->m_private_image)->comps + compno)->factor;
#line 9702
    __cil_tmp12 = opj_int_ceildiv((OPJ_INT32 )p_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 9702
    l_img_comp->x0 = (OPJ_UINT32 )__cil_tmp12;
#line 9703
    __cil_tmp13 = opj_int_ceildiv((OPJ_INT32 )p_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 9703
    l_img_comp->y0 = (OPJ_UINT32 )__cil_tmp13;
#line 9704
    l_comp_x1 = opj_int_ceildiv((OPJ_INT32 )p_image->x1, (OPJ_INT32 )l_img_comp->dx);
#line 9705
    l_comp_y1 = opj_int_ceildiv((OPJ_INT32 )p_image->y1, (OPJ_INT32 )l_img_comp->dy);
#line 9707
    __cil_tmp17 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->x0, (OPJ_INT32 )l_img_comp->factor);
#line 9707
    __cil_tmp16 = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32 )l_img_comp->factor);
#line 9707
    l_img_comp->w = (OPJ_UINT32 )(__cil_tmp16 - __cil_tmp17);
#line 9708
    __cil_tmp19 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->y0, (OPJ_INT32 )l_img_comp->factor);
#line 9708
    __cil_tmp18 = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32 )l_img_comp->factor);
#line 9708
    l_img_comp->h = (OPJ_UINT32 )(__cil_tmp18 - __cil_tmp19);
#line 9710
    l_img_comp ++;
#line 9696
    compno ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 9714
  if (p_j2k->m_output_image) {
    {
#line 9715
    opj_image_destroy(p_j2k->m_output_image);
    }
  }
  {
#line 9718
  p_j2k->m_output_image = opj_image_create0();
  }
#line 9719
  if (! p_j2k->m_output_image) {
#line 9720
    return (0);
  }
  {
#line 9722
  opj_copy_image_header(p_image, p_j2k->m_output_image);
#line 9724
  p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = (OPJ_INT32 )tile_index;
#line 9727
  opj_j2k_setup_decoding_tile(p_j2k);
#line 9730
  __cil_tmp22 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 9730
  if (! __cil_tmp22) {
    {
#line 9731
    opj_image_destroy(p_j2k->m_private_image);
#line 9732
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 9733
    return (0);
  }
#line 9737
  compno = (OPJ_UINT32 )0;
  {
#line 9737
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 9737
    if (! (compno < p_image->numcomps)) {
#line 9737
      goto while_break___0;
    }
#line 9738
    (p_image->comps + compno)->resno_decoded = ((p_j2k->m_output_image)->comps + compno)->resno_decoded;
#line 9740
    if ((p_image->comps + compno)->data) {
      {
#line 9741
      free((void *)(p_image->comps + compno)->data);
      }
    }
#line 9743
    (p_image->comps + compno)->data = ((p_j2k->m_output_image)->comps + compno)->data;
#line 9745
    ((p_j2k->m_output_image)->comps + compno)->data = (OPJ_INT32 *)((void *)0);
#line 9737
    compno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 9748
  return (1);
}
}
#line 9751 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 it_comp ;
  OPJ_UINT32 max_res ;

  {
#line 9757
  p_j2k->m_cp.m_specific_param.m_dec.m_reduce = res_factor;
#line 9759
  if (p_j2k->m_private_image) {
#line 9760
    if ((p_j2k->m_private_image)->comps) {
#line 9761
      if (p_j2k->m_specific_param.m_decoder.m_default_tcp) {
#line 9762
        if ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps) {
#line 9763
          it_comp = (OPJ_UINT32 )0;
          {
#line 9763
          while (1) {
            while_continue: /* CIL Label */ ;

#line 9763
            if (! (it_comp < (p_j2k->m_private_image)->numcomps)) {
#line 9763
              goto while_break;
            }
#line 9764
            max_res = ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps + it_comp)->numresolutions;
#line 9765
            if (res_factor >= max_res) {
              {
#line 9766
              opj_event_msg(p_manager, 1, "Resolution factor is greater than the maximum resolution in the component.\n");
              }
#line 9767
              return (0);
            }
#line 9769
            ((p_j2k->m_private_image)->comps + it_comp)->factor = res_factor;
#line 9763
            it_comp ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          while_break: ;
#line 9771
          return (1);
        }
      }
    }
  }
#line 9777
  return (0);
}
}
#line 9780 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_encode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max_tile_size ;
  OPJ_UINT32 l_current_tile_size ;
  OPJ_BYTE *l_current_data ;
  opj_tcd_t *p_tcd ;
  OPJ_BOOL __cil_tmp14 ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;

  {
#line 9786
  l_max_tile_size = (OPJ_UINT32 )0;
#line 9787
  l_current_data = (OPJ_BYTE *)0;
#line 9788
  p_tcd = (opj_tcd_t *)0;
#line 9795
  p_tcd = p_j2k->m_tcd;
#line 9797
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 9798
  i = (OPJ_UINT32 )0;
  {
#line 9798
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9798
    if (! (i < l_nb_tiles)) {
#line 9798
      goto while_break;
    }
    {
#line 9799
    __cil_tmp14 = opj_j2k_pre_write_tile(p_j2k, i, p_stream, p_manager);
    }
#line 9799
    if (! __cil_tmp14) {
#line 9800
      if (l_current_data) {
        {
#line 9801
        free((void *)l_current_data);
        }
      }
#line 9803
      return (0);
    }
#line 9808
    j = (OPJ_UINT32 )0;
    {
#line 9808
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 9808
      if (! (j < ((p_j2k->m_tcd)->image)->numcomps)) {
#line 9808
        goto while_break___0;
      }
#line 9809
      l_tilec = ((p_tcd->tcd_image)->tiles)->comps + j;
#line 9810
      if (l_nb_tiles == 1U) {
#line 9811
        l_img_comp = (p_tcd->image)->comps + j;
#line 9812
        l_tilec->data = l_img_comp->data;
#line 9813
        l_tilec->ownsData = 0;
      } else {
        {
#line 9815
        __cil_tmp17 = opj_alloc_tile_component_data(l_tilec);
        }
#line 9815
        if (! __cil_tmp17) {
          {
#line 9816
          opj_event_msg(p_manager, 1, "Error allocating tile component data.V");
          }
#line 9817
          if (l_current_data) {
            {
#line 9818
            free((void *)l_current_data);
            }
          }
#line 9820
          return (0);
        }
        {
#line 9822
        opj_alloc_tile_component_data(l_tilec);
        }
      }
#line 9808
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 9825
    l_current_tile_size = opj_tcd_get_encoded_tile_size(p_j2k->m_tcd);
    }
#line 9826
    if (l_nb_tiles > 1U) {
#line 9827
      if (l_current_tile_size > l_max_tile_size) {
        {
#line 9828
        __cil_tmp20 = realloc((void *)l_current_data, (unsigned long )l_current_tile_size);
#line 9828
        l_new_current_data = (OPJ_BYTE *)__cil_tmp20;
        }
#line 9829
        if (! l_new_current_data) {
#line 9830
          if (l_current_data) {
            {
#line 9831
            free((void *)l_current_data);
            }
          }
          {
#line 9833
          opj_event_msg(p_manager, 1, "Not enough memory to encode all tiles\n");
          }
#line 9834
          return (0);
        }
#line 9836
        l_current_data = l_new_current_data;
#line 9837
        l_max_tile_size = l_current_tile_size;
      }
      {
#line 9843
      opj_j2k_get_tile_data(p_j2k->m_tcd, l_current_data);
#line 9846
      __cil_tmp21 = opj_tcd_copy_tile_data(p_j2k->m_tcd, l_current_data, l_current_tile_size);
      }
#line 9846
      if (! __cil_tmp21) {
        {
#line 9847
        opj_event_msg(p_manager, 1, "Size mismatch between tile data and sent data.");
        }
#line 9848
        return (0);
      }
    }
    {
#line 9852
    __cil_tmp22 = opj_j2k_post_write_tile(p_j2k, p_stream, p_manager);
    }
#line 9852
    if (! __cil_tmp22) {
#line 9853
      return (0);
    }
#line 9798
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 9857
  if (l_current_data) {
    {
#line 9858
    free((void *)l_current_data);
    }
  }
#line 9860
  return (1);
}
}
#line 9863 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 9868
  opj_j2k_setup_end_compress(p_j2k);
#line 9870
  __cil_tmp4 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 9870
  if (! __cil_tmp4) {
#line 9872
    return (0);
  }
#line 9875
  return (1);
}
}
#line 9878 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_image_t *p_image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 it_comp ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 9888
  p_j2k->m_private_image = opj_image_create0();
  }
#line 9889
  if (! p_j2k->m_private_image) {
    {
#line 9890
    opj_event_msg(p_manager, 1, "Failed to allocate image header.\220");
    }
#line 9891
    return (0);
  }
  {
#line 9893
  opj_copy_image_header(p_image, p_j2k->m_private_image);
  }
#line 9896
  if (p_image->comps) {
#line 9898
    it_comp = (OPJ_UINT32 )0;
    {
#line 9898
    while (1) {
      while_continue: /* CIL Label */ ;

#line 9898
      if (! (it_comp < p_image->numcomps)) {
#line 9898
        goto while_break;
      }
#line 9899
      if ((p_image->comps + it_comp)->data) {
#line 9900
        ((p_j2k->m_private_image)->comps + it_comp)->data = (p_image->comps + it_comp)->data;
#line 9901
        (p_image->comps + it_comp)->data = (OPJ_INT32 *)((void *)0);
      }
#line 9898
      it_comp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 9908
  opj_j2k_setup_encoding_validation(p_j2k);
#line 9911
  __cil_tmp11 = opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager);
  }
#line 9911
  if (! __cil_tmp11) {
#line 9912
    return (0);
  }
  {
#line 9916
  opj_j2k_setup_header_writing(p_j2k);
#line 9919
  __cil_tmp12 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 9919
  if (! __cil_tmp12) {
#line 9920
    return (0);
  }
#line 9923
  return (1);
}
}
#line 9926 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
#line 9932
  if (p_tile_index != p_j2k->m_current_tile_number) {
    {
#line 9933
    opj_event_msg(p_manager, 1, "The given tile index does not match.");
    }
#line 9934
    return (0);
  }
  {
#line 9937
  opj_event_msg(p_manager, 4, "tile number %d / %d\nEV", p_j2k->m_current_tile_number + 1U,
                p_j2k->m_cp.tw * p_j2k->m_cp.th);
#line 9939
  p_j2k->m_specific_param.m_encoder.m_current_tile_part_number = (OPJ_UINT32 )0;
#line 9940
  (p_j2k->m_tcd)->cur_totnum_tp = (p_j2k->m_cp.tcps + p_tile_index)->m_nb_tile_parts;
#line 9941
  p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = (OPJ_UINT32 )0;
#line 9944
  __cil_tmp5 = opj_tcd_init_encode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number);
  }
#line 9944
  if (! __cil_tmp5) {
#line 9945
    return (0);
  }
#line 9948
  return (1);
}
}
#line 9951 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_get_tile_dimensions(opj_image_t *l_image , opj_tcd_tilecomp_t *l_tilec ,
                             opj_image_comp_t *l_img_comp , OPJ_UINT32 *l_size_comp ,
                             OPJ_UINT32 *l_width , OPJ_UINT32 *l_height , OPJ_UINT32 *l_offset_x ,
                             OPJ_UINT32 *l_offset_y , OPJ_UINT32 *l_image_width ,
                             OPJ_UINT32 *l_stride , OPJ_UINT32 *l_tile_offset ) 
{ 
  OPJ_UINT32 l_remaining ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;

  {
#line 9963
  *l_size_comp = l_img_comp->prec >> 3;
#line 9964
  l_remaining = l_img_comp->prec & 7U;
#line 9965
  if (l_remaining) {
#line 9966
    (*l_size_comp) ++;
  }
#line 9969
  if (*l_size_comp == 3U) {
#line 9970
    *l_size_comp = (OPJ_UINT32 )4;
  }
  {
#line 9973
  *l_width = (OPJ_UINT32 )(l_tilec->x1 - l_tilec->x0);
#line 9974
  *l_height = (OPJ_UINT32 )(l_tilec->y1 - l_tilec->y0);
#line 9975
  __cil_tmp13 = opj_int_ceildiv((OPJ_INT32 )l_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 9975
  *l_offset_x = (OPJ_UINT32 )__cil_tmp13;
#line 9976
  __cil_tmp14 = opj_int_ceildiv((OPJ_INT32 )l_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 9976
  *l_offset_y = (OPJ_UINT32 )__cil_tmp14;
#line 9977
  __cil_tmp15 = opj_int_ceildiv((OPJ_INT32 )l_image->x1 - (OPJ_INT32 )l_image->x0,
                                (OPJ_INT32 )l_img_comp->dx);
#line 9977
  *l_image_width = (OPJ_UINT32 )__cil_tmp15;
#line 9978
  *l_stride = *l_image_width - *l_width;
#line 9979
  *l_tile_offset = ((OPJ_UINT32 )l_tilec->x0 - *l_offset_x) + ((OPJ_UINT32 )l_tilec->y0 - *l_offset_y) * *l_image_width;
  }
#line 9981
  return;
}
}
#line 9982 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_get_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  opj_image_t *l_image ;
  OPJ_INT32 *l_src_ptr ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 l_offset_x ;
  OPJ_UINT32 l_offset_y ;
  OPJ_UINT32 l_image_width ;
  OPJ_UINT32 l_stride ;
  OPJ_UINT32 l_tile_offset ;
  OPJ_CHAR *l_dest_ptr ;
  OPJ_INT16 *l_dest_ptr___0 ;
  OPJ_INT16 *__cil_tmp20 ;
  OPJ_INT32 *__cil_tmp21 ;
  OPJ_INT16 *__cil_tmp22 ;
  OPJ_INT32 *__cil_tmp23 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *__cil_tmp25 ;
  OPJ_INT32 *__cil_tmp26 ;

  {
#line 9984
  k = (OPJ_UINT32 )0;
#line 9986
  i = (OPJ_UINT32 )0;
  {
#line 9986
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9986
    if (! (i < (p_tcd->image)->numcomps)) {
#line 9986
      goto while_break;
    }
    {
#line 9987
    l_image = p_tcd->image;
#line 9989
    l_tilec = ((p_tcd->tcd_image)->tiles)->comps + i;
#line 9990
    l_img_comp = l_image->comps + i;
#line 9993
    opj_get_tile_dimensions(l_image, l_tilec, l_img_comp, & l_size_comp, & l_width,
                            & l_height, & l_offset_x, & l_offset_y, & l_image_width,
                            & l_stride, & l_tile_offset);
#line 10005
    l_src_ptr = l_img_comp->data + l_tile_offset;
    }
#line 10008
    if (l_size_comp == 1U) {
#line 10008
      goto case_1;
    }
#line 10035
    if (l_size_comp == 2U) {
#line 10035
      goto case_2;
    }
#line 10058
    if (l_size_comp == 4U) {
#line 10058
      goto case_4;
    }
#line 10007
    goto switch_break;
    case_1: 
#line 10010
    l_dest_ptr = (OPJ_CHAR *)p_data;
#line 10011
    if (l_img_comp->sgnd) {
#line 10012
      j = (OPJ_UINT32 )0;
      {
#line 10012
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 10012
        if (! (j < l_height)) {
#line 10012
          goto while_break___0;
        }
#line 10013
        k = (OPJ_UINT32 )0;
        {
#line 10013
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 10013
          if (! (k < l_width)) {
#line 10013
            goto while_break___1;
          }
#line 10014
          *l_dest_ptr = (OPJ_CHAR )*l_src_ptr;
#line 10015
          l_dest_ptr ++;
#line 10016
          l_src_ptr ++;
#line 10013
          k ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___1: 
#line 10018
        l_src_ptr += l_stride;
#line 10012
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 10022
      j = (OPJ_UINT32 )0;
      {
#line 10022
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 10022
        if (! (j < l_height)) {
#line 10022
          goto while_break___2;
        }
#line 10023
        k = (OPJ_UINT32 )0;
        {
#line 10023
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 10023
          if (! (k < l_width)) {
#line 10023
            goto while_break___3;
          }
#line 10024
          *l_dest_ptr = (OPJ_CHAR )(*l_src_ptr & 255);
#line 10025
          l_dest_ptr ++;
#line 10026
          l_src_ptr ++;
#line 10023
          k ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___3: 
#line 10028
        l_src_ptr += l_stride;
#line 10022
        j ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___2: ;
    }
#line 10032
    p_data = (OPJ_BYTE *)l_dest_ptr;
#line 10034
    goto switch_break;
    case_2: 
#line 10037
    l_dest_ptr___0 = (OPJ_INT16 *)p_data;
#line 10038
    if (l_img_comp->sgnd) {
#line 10039
      j = (OPJ_UINT32 )0;
      {
#line 10039
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 10039
        if (! (j < l_height)) {
#line 10039
          goto while_break___4;
        }
#line 10040
        k = (OPJ_UINT32 )0;
        {
#line 10040
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 10040
          if (! (k < l_width)) {
#line 10040
            goto while_break___5;
          }
#line 10041
          __cil_tmp21 = l_src_ptr;
#line 10041
          l_src_ptr ++;
#line 10041
          __cil_tmp20 = l_dest_ptr___0;
#line 10041
          l_dest_ptr___0 ++;
#line 10041
          *__cil_tmp20 = (OPJ_INT16 )*__cil_tmp21;
#line 10040
          k ++;
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___5: 
#line 10043
        l_src_ptr += l_stride;
#line 10039
        j ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___4: ;
    } else {
#line 10047
      j = (OPJ_UINT32 )0;
      {
#line 10047
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 10047
        if (! (j < l_height)) {
#line 10047
          goto while_break___6;
        }
#line 10048
        k = (OPJ_UINT32 )0;
        {
#line 10048
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 10048
          if (! (k < l_width)) {
#line 10048
            goto while_break___7;
          }
#line 10049
          __cil_tmp23 = l_src_ptr;
#line 10049
          l_src_ptr ++;
#line 10049
          __cil_tmp22 = l_dest_ptr___0;
#line 10049
          l_dest_ptr___0 ++;
#line 10049
          *__cil_tmp22 = (OPJ_INT16 )(*__cil_tmp23 & 65535);
#line 10048
          k ++;
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___7: 
#line 10051
        l_src_ptr += l_stride;
#line 10047
        j ++;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___6: ;
    }
#line 10055
    p_data = (OPJ_BYTE *)l_dest_ptr___0;
#line 10057
    goto switch_break;
    case_4: 
#line 10060
    l_dest_ptr___1 = (OPJ_INT32 *)p_data;
#line 10061
    j = (OPJ_UINT32 )0;
    {
#line 10061
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 10061
      if (! (j < l_height)) {
#line 10061
        goto while_break___8;
      }
#line 10062
      k = (OPJ_UINT32 )0;
      {
#line 10062
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 10062
        if (! (k < l_width)) {
#line 10062
          goto while_break___9;
        }
#line 10063
        __cil_tmp26 = l_src_ptr;
#line 10063
        l_src_ptr ++;
#line 10063
        __cil_tmp25 = l_dest_ptr___1;
#line 10063
        l_dest_ptr___1 ++;
#line 10063
        *__cil_tmp25 = *__cil_tmp26;
#line 10062
        k ++;
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___9: 
#line 10065
      l_src_ptr += l_stride;
#line 10061
      j ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___8: 
#line 10068
    p_data = (OPJ_BYTE *)l_dest_ptr___1;
#line 10070
    goto switch_break;
    switch_break: 
#line 9986
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break: ;
#line 9990
  return;
}
}
#line 10075 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tile_size ;
  OPJ_UINT32 l_available_data ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
  {
#line 10080
  l_current_data = (OPJ_BYTE *)0;
#line 10081
  l_tile_size = (OPJ_UINT32 )0;
#line 10087
  l_tile_size = p_j2k->m_specific_param.m_encoder.m_encoded_tile_size;
#line 10088
  l_available_data = l_tile_size;
#line 10089
  l_current_data = p_j2k->m_specific_param.m_encoder.m_encoded_tile_data;
#line 10091
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 10092
  __cil_tmp9 = opj_j2k_write_first_tile_part(p_j2k, l_current_data, & l_nb_bytes_written,
                                             l_available_data, p_stream, p_manager);
  }
#line 10092
  if (! __cil_tmp9) {
#line 10093
    return (0);
  }
  {
#line 10095
  l_current_data += l_nb_bytes_written;
#line 10096
  l_available_data -= l_nb_bytes_written;
#line 10098
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 10099
  __cil_tmp10 = opj_j2k_write_all_tile_parts(p_j2k, l_current_data, & l_nb_bytes_written,
                                             l_available_data, p_stream, p_manager);
  }
#line 10099
  if (! __cil_tmp10) {
#line 10100
    return (0);
  }
  {
#line 10103
  l_available_data -= l_nb_bytes_written;
#line 10104
  l_nb_bytes_written = l_tile_size - l_available_data;
#line 10106
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_encoded_tile_data,
                                      (OPJ_SIZE_T )l_nb_bytes_written, p_manager);
  }
#line 10106
  if (__cil_tmp11 != (unsigned long )l_nb_bytes_written) {
#line 10109
    return (0);
  }
#line 10112
  (p_j2k->m_current_tile_number) ++;
#line 10114
  return (1);
}
}
#line 10117 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_setup_end_compress(opj_j2k_t *p_j2k ) 
{ 


  {
  {
#line 10123
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_eoc));
  }
#line 10125
  if ((int )p_j2k->m_cp.rsiz >= 3) {
#line 10125
    if ((int )p_j2k->m_cp.rsiz <= 6) {
      {
#line 10126
      opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_updated_tlm));
      }
    }
  }
  {
#line 10129
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_epc));
#line 10130
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_end_encoding));
#line 10131
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_destroy_header_memory));
  }
#line 10133
  return;
}
}
#line 10134 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k ) 
{ 


  {
  {
#line 10139
  opj_procedure_list_add_procedure(p_j2k->m_validation_list, (void (*)(void))(& opj_j2k_build_encoder));
#line 10140
  opj_procedure_list_add_procedure(p_j2k->m_validation_list, (void (*)(void))(& opj_j2k_encoding_validation));
#line 10143
  opj_procedure_list_add_procedure(p_j2k->m_validation_list, (void (*)(void))(& opj_j2k_mct_validation));
  }
#line 10145
  return;
}
}
#line 10146 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
void opj_j2k_setup_header_writing(opj_j2k_t *p_j2k ) 
{ 


  {
  {
#line 10151
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_init_info));
#line 10152
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_soc));
#line 10153
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_siz));
#line 10154
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_cod));
#line 10155
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_qcd));
  }
#line 10157
  if ((int )p_j2k->m_cp.rsiz >= 3) {
#line 10157
    if ((int )p_j2k->m_cp.rsiz <= 6) {
      {
#line 10162
      opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_tlm));
      }
#line 10164
      if ((int )p_j2k->m_cp.rsiz == 4) {
        {
#line 10165
        opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_poc));
        }
      }
    }
  }
  {
#line 10169
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_regions));
  }
#line 10171
  if ((unsigned long )p_j2k->m_cp.comment != (unsigned long )((OPJ_CHAR *)0)) {
    {
#line 10172
    opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_com));
    }
  }
#line 10176
  if ((int )p_j2k->m_cp.rsiz & 256) {
    {
#line 10177
    opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_mct_data_group));
    }
  }
#line 10181
  if (p_j2k->cstr_index) {
    {
#line 10182
    opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_get_end_header));
    }
  }
  {
#line 10185
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_create_tcd));
#line 10186
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_update_rates));
  }
#line 10188
  return;
}
}
#line 10189 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                       OPJ_UINT32 p_total_data_size , opj_stream_private_t *p_stream ,
                                       struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_UINT32 l_current_nb_bytes_written ;
  OPJ_BYTE *l_begin_data ;
  opj_tcd_t *l_tcd ;
  opj_cp_t *l_cp ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 10196
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 10198
  l_begin_data = (OPJ_BYTE *)0;
#line 10200
  l_tcd = (opj_tcd_t *)0;
#line 10201
  l_cp = (opj_cp_t *)0;
#line 10203
  l_tcd = p_j2k->m_tcd;
#line 10204
  l_cp = & p_j2k->m_cp;
#line 10206
  l_tcd->cur_pino = (OPJ_UINT32 )0;
#line 10209
  p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = (OPJ_UINT32 )0;
#line 10214
  l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 10215
  l_begin_data = p_data;
#line 10216
  __cil_tmp12 = opj_j2k_write_sot(p_j2k, p_data, & l_current_nb_bytes_written, p_stream,
                                  p_manager);
  }
#line 10216
  if (! __cil_tmp12) {
#line 10218
    return (0);
  }
#line 10221
  l_nb_bytes_written += l_current_nb_bytes_written;
#line 10222
  p_data += l_current_nb_bytes_written;
#line 10223
  p_total_data_size -= l_current_nb_bytes_written;
#line 10225
  if ((int )l_cp->rsiz >= 3) {
#line 10225
    if (! ((int )l_cp->rsiz <= 6)) {
#line 10225
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 10242
  if ((l_cp->tcps + p_j2k->m_current_tile_number)->numpocs) {
    {
#line 10243
    l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 10244
    opj_j2k_write_poc_in_memory(p_j2k, p_data, & l_current_nb_bytes_written, p_manager);
#line 10245
    l_nb_bytes_written += l_current_nb_bytes_written;
#line 10246
    p_data += l_current_nb_bytes_written;
#line 10247
    p_total_data_size -= l_current_nb_bytes_written;
    }
  }
  {
#line 10251
  l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 10252
  __cil_tmp13 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                  p_total_data_size, p_stream, p_manager);
  }
#line 10252
  if (! __cil_tmp13) {
#line 10253
    return (0);
  }
  {
#line 10256
  l_nb_bytes_written += l_current_nb_bytes_written;
#line 10257
  *p_data_written = l_nb_bytes_written;
#line 10260
  opj_write_bytes_LE(l_begin_data + 6, l_nb_bytes_written, (OPJ_UINT32 )4);
  }
#line 10262
  if ((int )l_cp->rsiz >= 3) {
#line 10262
    if ((int )l_cp->rsiz <= 6) {
      {
#line 10263
      opj_j2k_update_tlm(p_j2k, l_nb_bytes_written);
      }
    }
  }
#line 10266
  return (1);
}
}
#line 10269 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                      OPJ_UINT32 p_total_data_size , opj_stream_private_t *p_stream ,
                                      struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 tilepartno ;
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_UINT32 l_current_nb_bytes_written ;
  OPJ_UINT32 l_part_tile_size ;
  OPJ_UINT32 tot_num_tp ;
  OPJ_UINT32 pino ;
  OPJ_BYTE *l_begin_data ;
  opj_tcp_t *l_tcp ;
  opj_tcd_t *l_tcd ;
  opj_cp_t *l_cp ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;

  {
  {
#line 10277
  tilepartno = (OPJ_UINT32 )0;
#line 10278
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 10285
  l_tcp = (opj_tcp_t *)0;
#line 10286
  l_tcd = (opj_tcd_t *)0;
#line 10287
  l_cp = (opj_cp_t *)0;
#line 10289
  l_tcd = p_j2k->m_tcd;
#line 10290
  l_cp = & p_j2k->m_cp;
#line 10291
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 10294
  tot_num_tp = opj_j2k_get_num_tp(l_cp, (OPJ_UINT32 )0, p_j2k->m_current_tile_number);
#line 10297
  (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 10298
  tilepartno = (OPJ_UINT32 )1;
  }
  {
#line 10298
  while (1) {
    while_continue: /* CIL Label */ ;

#line 10298
    if (! (tilepartno < tot_num_tp)) {
#line 10298
      goto while_break;
    }
    {
#line 10299
    p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
#line 10300
    l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 10301
    l_part_tile_size = (OPJ_UINT32 )0;
#line 10302
    l_begin_data = p_data;
#line 10304
    __cil_tmp18 = opj_j2k_write_sot(p_j2k, p_data, & l_current_nb_bytes_written, p_stream,
                                    p_manager);
    }
#line 10304
    if (! __cil_tmp18) {
#line 10305
      return (0);
    }
    {
#line 10308
    l_nb_bytes_written += l_current_nb_bytes_written;
#line 10309
    p_data += l_current_nb_bytes_written;
#line 10310
    p_total_data_size -= l_current_nb_bytes_written;
#line 10311
    l_part_tile_size += l_current_nb_bytes_written;
#line 10313
    l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 10314
    __cil_tmp19 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                    p_total_data_size, p_stream, p_manager);
    }
#line 10314
    if (! __cil_tmp19) {
#line 10315
      return (0);
    }
    {
#line 10318
    p_data += l_current_nb_bytes_written;
#line 10319
    l_nb_bytes_written += l_current_nb_bytes_written;
#line 10320
    p_total_data_size -= l_current_nb_bytes_written;
#line 10321
    l_part_tile_size += l_current_nb_bytes_written;
#line 10324
    opj_write_bytes_LE(l_begin_data + 6, l_part_tile_size, (OPJ_UINT32 )4);
    }
#line 10326
    if ((int )l_cp->rsiz >= 3) {
#line 10326
      if ((int )l_cp->rsiz <= 6) {
        {
#line 10327
        opj_j2k_update_tlm(p_j2k, l_part_tile_size);
        }
      }
    }
#line 10330
    (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 10298
    tilepartno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 10333
  pino = (OPJ_UINT32 )1;
  {
#line 10333
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 10333
    if (! (pino <= l_tcp->numpocs)) {
#line 10333
      goto while_break___0;
    }
    {
#line 10334
    l_tcd->cur_pino = pino;
#line 10337
    tot_num_tp = opj_j2k_get_num_tp(l_cp, pino, p_j2k->m_current_tile_number);
#line 10338
    tilepartno = (OPJ_UINT32 )0;
    }
    {
#line 10338
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 10338
      if (! (tilepartno < tot_num_tp)) {
#line 10338
        goto while_break___1;
      }
      {
#line 10339
      p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
#line 10340
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 10341
      l_part_tile_size = (OPJ_UINT32 )0;
#line 10342
      l_begin_data = p_data;
#line 10344
      __cil_tmp21 = opj_j2k_write_sot(p_j2k, p_data, & l_current_nb_bytes_written,
                                      p_stream, p_manager);
      }
#line 10344
      if (! __cil_tmp21) {
#line 10345
        return (0);
      }
      {
#line 10348
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 10349
      p_data += l_current_nb_bytes_written;
#line 10350
      p_total_data_size -= l_current_nb_bytes_written;
#line 10351
      l_part_tile_size += l_current_nb_bytes_written;
#line 10353
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 10355
      __cil_tmp22 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                      p_total_data_size, p_stream, p_manager);
      }
#line 10355
      if (! __cil_tmp22) {
#line 10356
        return (0);
      }
      {
#line 10359
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 10360
      p_data += l_current_nb_bytes_written;
#line 10361
      p_total_data_size -= l_current_nb_bytes_written;
#line 10362
      l_part_tile_size += l_current_nb_bytes_written;
#line 10365
      opj_write_bytes_LE(l_begin_data + 6, l_part_tile_size, (OPJ_UINT32 )4);
      }
#line 10367
      if ((int )l_cp->rsiz >= 3) {
#line 10367
        if ((int )l_cp->rsiz <= 6) {
          {
#line 10368
          opj_j2k_update_tlm(p_j2k, l_part_tile_size);
          }
        }
      }
#line 10371
      (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 10338
      tilepartno ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 10333
    pino ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 10375
  *p_data_written = l_nb_bytes_written;
#line 10377
  return (1);
}
}
#line 10380 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                   struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_tlm_size ;
  OPJ_OFF_T l_tlm_position ;
  OPJ_OFF_T l_current_position ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_SIZE_T __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 10392
  l_tlm_size = 5U * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;
#line 10393
  l_tlm_position = 6L + p_j2k->m_specific_param.m_encoder.m_tlm_start;
#line 10394
  l_current_position = opj_stream_tell(p_stream);
#line 10396
  __cil_tmp11 = opj_stream_seek(p_stream, l_tlm_position, p_manager);
  }
#line 10396
  if (! __cil_tmp11) {
#line 10397
    return (0);
  }
  {
#line 10400
  __cil_tmp12 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer,
                                      (OPJ_SIZE_T )l_tlm_size, p_manager);
  }
#line 10400
  if (__cil_tmp12 != (unsigned long )l_tlm_size) {
#line 10401
    return (0);
  }
  {
#line 10404
  __cil_tmp13 = opj_stream_seek(p_stream, l_current_position, p_manager);
  }
#line 10404
  if (! __cil_tmp13) {
#line 10405
    return (0);
  }
#line 10408
  return (1);
}
}
#line 10411 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                              struct opj_event_mgr *p_manager ) 
{ 


  {
  {
#line 10420
  opj_tcd_destroy(p_j2k->m_tcd);
#line 10421
  p_j2k->m_tcd = (struct opj_tcd *)0;
  }
#line 10423
  if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
    {
#line 10424
    free((void *)p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
#line 10425
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)0;
#line 10426
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = (OPJ_BYTE *)0;
    }
  }
#line 10429
  if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
    {
#line 10430
    free((void *)p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
#line 10431
    p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)0;
    }
  }
#line 10434
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = (OPJ_UINT32 )0;
#line 10436
  return (1);
}
}
#line 10442 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) 
{ 


  {
#line 10452
  if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
    {
#line 10453
    free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 10454
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)0;
    }
  }
#line 10457
  p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 10459
  return (1);
}
}
#line 10462 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) 
{ 
  opj_codestream_info_t *l_cstr_info ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 10466
  l_cstr_info = (opj_codestream_info_t *)0;
#line 10513
  __cil_tmp8 = opj_j2k_calculate_tp(p_j2k, & p_j2k->m_cp, & p_j2k->m_specific_param.m_encoder.m_total_tile_parts,
                                    p_j2k->m_private_image, p_manager);
  }
#line 10513
  return (__cil_tmp8);
}
}
#line 10523 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 10533
  p_j2k->m_tcd = opj_tcd_create(0);
  }
#line 10535
  if (! p_j2k->m_tcd) {
    {
#line 10536
    opj_event_msg(p_manager, 1, "Not enough memory to create Tile Coder\n");
    }
#line 10537
    return (0);
  }
  {
#line 10540
  __cil_tmp8 = opj_tcd_init(p_j2k->m_tcd, p_j2k->m_private_image, & p_j2k->m_cp);
  }
#line 10540
  if (! __cil_tmp8) {
    {
#line 10541
    opj_tcd_destroy(p_j2k->m_tcd);
#line 10542
    p_j2k->m_tcd = (struct opj_tcd *)0;
    }
#line 10543
    return (0);
  }
#line 10546
  return (1);
}
}
#line 10549 "/root/patchweave_new/10/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;
  OPJ_UINT32 j ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 10556
  __cil_tmp7 = opj_j2k_pre_write_tile(p_j2k, p_tile_index, p_stream, p_manager);
  }
#line 10556
  if (! __cil_tmp7) {
    {
#line 10557
    opj_event_msg(p_manager, 1, "Error while opj_j2k_pre_write_tile with tile index = %d\n\230\001",
                  p_tile_index);
    }
#line 10558
    return (0);
  } else {
#line 10563
    j = (OPJ_UINT32 )0;
    {
#line 10563
    while (1) {
      while_continue: /* CIL Label */ ;

#line 10563
      if (! (j < ((p_j2k->m_tcd)->image)->numcomps)) {
#line 10563
        goto while_break;
      }
      {
#line 10564
      l_tilec = (((p_j2k->m_tcd)->tcd_image)->tiles)->comps + j;
#line 10566
      __cil_tmp10 = opj_alloc_tile_component_data(l_tilec);
      }
#line 10566
      if (! __cil_tmp10) {
        {
#line 10567
        opj_event_msg(p_manager, 1, "Error allocating tile component data.V");
        }
#line 10568
        return (0);
      }
#line 10563
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 10573
    __cil_tmp11 = opj_tcd_copy_tile_data(p_j2k->m_tcd, p_data, p_data_size);
    }
#line 10573
    if (! __cil_tmp11) {
      {
#line 10574
      opj_event_msg(p_manager, 1, "Size mismatch between tile data and sent data.");
      }
#line 10575
      return (0);
    }
    {
#line 10577
    __cil_tmp12 = opj_j2k_post_write_tile(p_j2k, p_stream, p_manager);
    }
#line 10577
    if (! __cil_tmp12) {
      {
#line 10578
      opj_event_msg(p_manager, 1, "Error while opj_j2k_post_write_tile with tile index = %d\n",
                    p_tile_index);
      }
#line 10579
      return (0);
    }
  }
#line 10583
  return (1);
}
}
#line 48 "/root/patchweave_new/10/src/lib/openjp2/tgt.c"
opj_tgt_tree_t *opj_tgt_create(OPJ_UINT32 numleafsh , OPJ_UINT32 numleafsv ) 
{ 
  OPJ_INT32 nplh[32] ;
  OPJ_INT32 nplv[32] ;
  opj_tgt_node_t *node ;
  opj_tgt_node_t *l_parent_node ;
  opj_tgt_node_t *l_parent_node0 ;
  opj_tgt_tree_t *tree ;
  OPJ_UINT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 k ;
  OPJ_UINT32 numlvls ;
  OPJ_UINT32 n ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  {
#line 51
  node = (opj_tgt_node_t *)0;
#line 52
  l_parent_node = (opj_tgt_node_t *)0;
#line 53
  l_parent_node0 = (opj_tgt_node_t *)0;
#line 54
  tree = (opj_tgt_tree_t *)0;
#line 60
  __cil_tmp14 = calloc(1UL, sizeof(opj_tgt_tree_t ));
#line 60
  tree = (opj_tgt_tree_t *)__cil_tmp14;
  }
#line 61
  if (! tree) {
    {
#line 62
    fprintf(stderr, "ERROR in tgt_create while allocating tree\n");
    }
#line 63
    return ((opj_tgt_tree_t *)0);
  }
#line 66
  tree->numleafsh = numleafsh;
#line 67
  tree->numleafsv = numleafsv;
#line 69
  numlvls = (OPJ_UINT32 )0;
#line 70
  nplh[0] = (OPJ_INT32 )numleafsh;
#line 71
  nplv[0] = (OPJ_INT32 )numleafsv;
#line 72
  tree->numnodes = (OPJ_UINT32 )0;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    n = (OPJ_UINT32 )(nplh[numlvls] * nplv[numlvls]);
#line 75
    nplh[numlvls + 1U] = (nplh[numlvls] + 1) / 2;
#line 76
    nplv[numlvls + 1U] = (nplv[numlvls] + 1) / 2;
#line 77
    tree->numnodes += n;
#line 78
    numlvls ++;
#line 73
    if (! (n > 1U)) {
#line 73
      goto while_break;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 82
  if (tree->numnodes == 0U) {
    {
#line 83
    free((void *)tree);
#line 84
    fprintf(stderr, "WARNING in tgt_create tree->numnodes == 0, no tree created.\n");
    }
#line 85
    return ((opj_tgt_tree_t *)0);
  }
  {
#line 88
  __cil_tmp15 = calloc((unsigned long )tree->numnodes, sizeof(opj_tgt_node_t ));
#line 88
  tree->nodes = (opj_tgt_node_t *)__cil_tmp15;
  }
#line 89
  if (! tree->nodes) {
    {
#line 90
    fprintf(stderr, "ERROR in tgt_create while allocating node of the tree\n");
#line 91
    free((void *)tree);
    }
#line 92
    return ((opj_tgt_tree_t *)0);
  }
#line 94
  tree->nodes_size = tree->numnodes * (OPJ_UINT32 )sizeof(opj_tgt_node_t );
#line 96
  node = tree->nodes;
#line 97
  l_parent_node = tree->nodes + tree->numleafsh * tree->numleafsv;
#line 98
  l_parent_node0 = l_parent_node;
#line 100
  i = (OPJ_UINT32 )0;
  {
#line 100
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 100
    if (! (i < numlvls - 1U)) {
#line 100
      goto while_break___0;
    }
#line 101
    j = 0;
    {
#line 101
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 101
      if (! (j < nplv[i])) {
#line 101
        goto while_break___1;
      }
#line 102
      k = nplh[i];
      {
#line 103
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 103
        k --;
#line 103
        if (! (k >= 0)) {
#line 103
          goto while_break___2;
        }
#line 104
        node->parent = l_parent_node;
#line 105
        node ++;
#line 106
        k --;
#line 106
        if (k >= 0) {
#line 107
          node->parent = l_parent_node;
#line 108
          node ++;
        }
#line 110
        l_parent_node ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: ;
#line 112
      if (j & 1) {
#line 113
        l_parent_node0 = l_parent_node;
      } else
#line 112
      if (j == nplv[i] - 1) {
#line 113
        l_parent_node0 = l_parent_node;
      } else {
#line 115
        l_parent_node = l_parent_node0;
#line 116
        l_parent_node0 += nplh[i];
      }
#line 101
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 100
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 120
  node->parent = (struct opj_tgt_node *)0;
#line 121
  opj_tgt_reset(tree);
  }
#line 122
  return (tree);
}
}
#line 133 "/root/patchweave_new/10/src/lib/openjp2/tgt.c"
opj_tgt_tree_t *opj_tgt_init(opj_tgt_tree_t *p_tree , OPJ_UINT32 p_num_leafs_h , OPJ_UINT32 p_num_leafs_v ) 
{ 
  OPJ_INT32 l_nplh[32] ;
  OPJ_INT32 l_nplv[32] ;
  opj_tgt_node_t *l_node ;
  opj_tgt_node_t *l_parent_node ;
  opj_tgt_node_t *l_parent_node0 ;
  OPJ_UINT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 k ;
  OPJ_UINT32 l_num_levels ;
  OPJ_UINT32 n ;
  OPJ_UINT32 l_node_size ;
  opj_tgt_node_t *new_nodes ;
  void *__cil_tmp16 ;

  {
#line 137
  l_node = (opj_tgt_node_t *)0;
#line 138
  l_parent_node = (opj_tgt_node_t *)0;
#line 139
  l_parent_node0 = (opj_tgt_node_t *)0;
#line 146
  if (! p_tree) {
#line 147
    return ((opj_tgt_tree_t *)0);
  }
#line 150
  if (p_tree->numleafsh != p_num_leafs_h) {
    _L: 
#line 151
    p_tree->numleafsh = p_num_leafs_h;
#line 152
    p_tree->numleafsv = p_num_leafs_v;
#line 154
    l_num_levels = (OPJ_UINT32 )0;
#line 155
    l_nplh[0] = (OPJ_INT32 )p_num_leafs_h;
#line 156
    l_nplv[0] = (OPJ_INT32 )p_num_leafs_v;
#line 157
    p_tree->numnodes = (OPJ_UINT32 )0;
    {
#line 158
    while (1) {
      while_continue: /* CIL Label */ ;
#line 160
      n = (OPJ_UINT32 )(l_nplh[l_num_levels] * l_nplv[l_num_levels]);
#line 161
      l_nplh[l_num_levels + 1U] = (l_nplh[l_num_levels] + 1) / 2;
#line 162
      l_nplv[l_num_levels + 1U] = (l_nplv[l_num_levels] + 1) / 2;
#line 163
      p_tree->numnodes += n;
#line 164
      l_num_levels ++;
#line 158
      if (! (n > 1U)) {
#line 158
        goto while_break;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
#line 169
    if (p_tree->numnodes == 0U) {
      {
#line 170
      opj_tgt_destroy(p_tree);
      }
#line 171
      return ((opj_tgt_tree_t *)0);
    }
#line 173
    l_node_size = p_tree->numnodes * (OPJ_UINT32 )sizeof(opj_tgt_node_t );
#line 175
    if (l_node_size > p_tree->nodes_size) {
      {
#line 176
      __cil_tmp16 = realloc((void *)p_tree->nodes, (unsigned long )l_node_size);
#line 176
      new_nodes = (opj_tgt_node_t *)__cil_tmp16;
      }
#line 177
      if (! new_nodes) {
        {
#line 178
        fprintf(stderr, "ERROR Not enough memory to reinitialize the tag tree\n");
#line 179
        opj_tgt_destroy(p_tree);
        }
#line 180
        return ((opj_tgt_tree_t *)0);
      }
      {
#line 182
      p_tree->nodes = new_nodes;
#line 183
      memset((void *)((char *)p_tree->nodes + p_tree->nodes_size), 0, (unsigned long )(l_node_size - p_tree->nodes_size));
#line 184
      p_tree->nodes_size = l_node_size;
      }
    }
#line 186
    l_node = p_tree->nodes;
#line 187
    l_parent_node = p_tree->nodes + p_tree->numleafsh * p_tree->numleafsv;
#line 188
    l_parent_node0 = l_parent_node;
#line 190
    i = (OPJ_UINT32 )0;
    {
#line 190
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 190
      if (! (i < l_num_levels - 1U)) {
#line 190
        goto while_break___0;
      }
#line 191
      j = 0;
      {
#line 191
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 191
        if (! (j < l_nplv[i])) {
#line 191
          goto while_break___1;
        }
#line 192
        k = l_nplh[i];
        {
#line 193
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 193
          k --;
#line 193
          if (! (k >= 0)) {
#line 193
            goto while_break___2;
          }
#line 194
          l_node->parent = l_parent_node;
#line 195
          l_node ++;
#line 196
          k --;
#line 196
          if (k >= 0) {
#line 197
            l_node->parent = l_parent_node;
#line 198
            l_node ++;
          }
#line 200
          l_parent_node ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: ;
#line 202
        if (j & 1) {
#line 204
          l_parent_node0 = l_parent_node;
        } else
#line 202
        if (j == l_nplv[i] - 1) {
#line 204
          l_parent_node0 = l_parent_node;
        } else {
#line 208
          l_parent_node = l_parent_node0;
#line 209
          l_parent_node0 += l_nplh[i];
        }
#line 191
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 190
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 213
    l_node->parent = (struct opj_tgt_node *)0;
  } else
#line 150
  if (p_tree->numleafsv != p_num_leafs_v) {
#line 150
    goto _L;
  }
  {
#line 215
  opj_tgt_reset(p_tree);
  }
#line 217
  return (p_tree);
}
}
#line 220 "/root/patchweave_new/10/src/lib/openjp2/tgt.c"
void opj_tgt_destroy(opj_tgt_tree_t *p_tree ) 
{ 


  {
#line 222
  if (! p_tree) {
#line 223
    return;
  }
#line 226
  if (p_tree->nodes) {
    {
#line 227
    free((void *)p_tree->nodes);
#line 228
    p_tree->nodes = (opj_tgt_node_t *)0;
    }
  }
  {
#line 230
  free((void *)p_tree);
  }
#line 232
  return;
}
}
#line 233 "/root/patchweave_new/10/src/lib/openjp2/tgt.c"
void opj_tgt_reset(opj_tgt_tree_t *p_tree ) 
{ 
  OPJ_UINT32 i ;
  opj_tgt_node_t *l_current_node ;

  {
#line 235
  l_current_node = (opj_tgt_node_t *)0;
#line 237
  if (! p_tree) {
#line 238
    return;
  }
#line 241
  l_current_node = p_tree->nodes;
#line 242
  i = (OPJ_UINT32 )0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;

#line 242
    if (! (i < p_tree->numnodes)) {
#line 242
      goto while_break;
    }
#line 244
    l_current_node->value = 999;
#line 245
    l_current_node->low = 0;
#line 246
    l_current_node->known = (OPJ_UINT32 )0;
#line 247
    l_current_node ++;
#line 242
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 246
  return;
}
}
#line 251 "/root/patchweave_new/10/src/lib/openjp2/tgt.c"
void opj_tgt_setvalue(opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 value ) 
{ 
  opj_tgt_node_t *node ;

  {
#line 253
  node = tree->nodes + leafno;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;

#line 254
    if (node) {
#line 254
      if (! (node->value > value)) {
#line 254
        goto while_break;
      }
    } else {
#line 254
      goto while_break;
    }
#line 255
    node->value = value;
#line 256
    node = node->parent;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 260
  return;
}
}
#line 260 "/root/patchweave_new/10/src/lib/openjp2/tgt.c"
void opj_tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  OPJ_INT32 low ;
  opj_tgt_node_t **__cil_tmp9 ;

  {
#line 266
  stkptr = stk;
#line 267
  node = tree->nodes + leafno;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;

#line 268
    if (! node->parent) {
#line 268
      goto while_break;
    }
#line 269
    __cil_tmp9 = stkptr;
#line 269
    stkptr ++;
#line 269
    *__cil_tmp9 = node;
#line 270
    node = node->parent;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 273
  low = 0;
  {
#line 274
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 275
    if (low > node->low) {
#line 276
      node->low = low;
    } else {
#line 278
      low = node->low;
    }
    {
#line 281
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 281
      if (! (low < threshold)) {
#line 281
        goto while_break___1;
      }
#line 282
      if (low >= node->value) {
#line 283
        if (! node->known) {
          {
#line 284
          opj_bio_write(bio, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
#line 285
          node->known = (OPJ_UINT32 )1;
          }
        }
#line 287
        goto while_break___1;
      }
      {
#line 289
      opj_bio_write(bio, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 290
      low ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 293
    node->low = low;
#line 294
    if ((unsigned long )stkptr == (unsigned long )(stk)) {
#line 295
      goto while_break___0;
    }
#line 296
    stkptr --;
#line 296
    node = *stkptr;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 300
  return;
}
}
#line 300 "/root/patchweave_new/10/src/lib/openjp2/tgt.c"
OPJ_UINT32 opj_tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno ,
                          OPJ_INT32 threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  OPJ_INT32 low ;
  opj_tgt_node_t **__cil_tmp9 ;
  OPJ_UINT32 __cil_tmp10 ;
  int tmp ;

  {
#line 306
  stkptr = stk;
#line 307
  node = tree->nodes + leafno;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;

#line 308
    if (! node->parent) {
#line 308
      goto while_break;
    }
#line 309
    __cil_tmp9 = stkptr;
#line 309
    stkptr ++;
#line 309
    *__cil_tmp9 = node;
#line 310
    node = node->parent;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 313
  low = 0;
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 315
    if (low > node->low) {
#line 316
      node->low = low;
    } else {
#line 318
      low = node->low;
    }
    {
#line 320
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 320
      if (low < threshold) {
#line 320
        if (! (low < node->value)) {
#line 320
          goto while_break___1;
        }
      } else {
#line 320
        goto while_break___1;
      }
      {
#line 321
      __cil_tmp10 = opj_bio_read(bio, (OPJ_UINT32 )1);
      }
#line 321
      if (__cil_tmp10) {
#line 322
        node->value = low;
      } else {
#line 324
        low ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 327
    node->low = low;
#line 328
    if ((unsigned long )stkptr == (unsigned long )(stk)) {
#line 329
      goto while_break___0;
    }
#line 331
    stkptr --;
#line 331
    node = *stkptr;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 334
  if (node->value < threshold) {
#line 334
    tmp = 1;
  } else {
#line 334
    tmp = 0;
  }
#line 334
  return ((OPJ_UINT32 )tmp);
}
}
#line 110 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
__inline static OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ,
                                           OPJ_BOOL isEncoder , OPJ_FLOAT32 fraction ,
                                           OPJ_SIZE_T sizeof_block ) ;
#line 115
static OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *p_code_block ) ;
#line 120
void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t *p_precinct ) ;
#line 125
static OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *p_code_block ) ;
#line 130
static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *p_code_block ) ;
#line 135
void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t *p_precinct ) ;
#line 142
void opj_tcd_free_tile(opj_tcd_t *p_tcd ) ;
#line 145
OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd , OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                           OPJ_UINT32 p_max_src_size , opj_codestream_index_t *p_cstr_index ) ;
#line 151
OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd ) ;
#line 153
OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd ) ;
#line 155
OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd ) ;
#line 157
OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd ) ;
#line 160
OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd ) ;
#line 162
OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd ) ;
#line 164
OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd ) ;
#line 166
OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd ) ;
#line 168
OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 *p_data_written ,
                           OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ) ;
#line 174
OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 p_max_dest_size ,
                                      opj_codestream_info_t *p_cstr_info ) ;
#line 184 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
opj_tcd_t *opj_tcd_create(OPJ_BOOL p_is_decoder ) 
{ 
  opj_tcd_t *l_tcd ;
  void *__cil_tmp3 ;
  int tmp ;
  void *__cil_tmp5 ;

  {
  {
#line 186
  l_tcd = (opj_tcd_t *)0;
#line 189
  __cil_tmp3 = calloc(1UL, sizeof(opj_tcd_t ));
#line 189
  l_tcd = (opj_tcd_t *)__cil_tmp3;
  }
#line 190
  if (! l_tcd) {
#line 191
    return ((opj_tcd_t *)0);
  }
#line 194
  if (p_is_decoder) {
#line 194
    tmp = 1;
  } else {
#line 194
    tmp = 0;
  }
  {
#line 194
  l_tcd->m_is_decoder = (OPJ_UINT32 )tmp;
#line 196
  __cil_tmp5 = calloc(1UL, sizeof(opj_tcd_image_t ));
#line 196
  l_tcd->tcd_image = (opj_tcd_image_t *)__cil_tmp5;
  }
#line 197
  if (! l_tcd->tcd_image) {
    {
#line 198
    free((void *)l_tcd);
    }
#line 199
    return ((opj_tcd_t *)0);
  }
#line 202
  return (l_tcd);
}
}
#line 208 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
void opj_tcd_rateallocate_fixed(opj_tcd_t *tcd ) 
{ 
  OPJ_UINT32 layno ;

  {
#line 211
  layno = (OPJ_UINT32 )0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;

#line 211
    if (! (layno < (tcd->tcp)->numlayers)) {
#line 211
      goto while_break;
    }
    {
#line 212
    opj_tcd_makelayer_fixed(tcd, layno, (OPJ_UINT32 )1);
#line 211
    layno ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 215
  return;
}
}
#line 217 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
void opj_tcd_makelayer(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_FLOAT64 thresh , OPJ_UINT32 final ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 passno ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  OPJ_UINT32 n ;
  OPJ_UINT32 dr ;
  OPJ_FLOAT64 dd ;
  opj_tcd_pass_t *pass ;

  {
#line 225
  tcd_tile = (tcd->tcd_image)->tiles;
#line 227
  tcd_tile->distolayer[layno] = (OPJ_FLOAT64 )0;
#line 229
  compno = (OPJ_UINT32 )0;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;

#line 229
    if (! (compno < tcd_tile->numcomps)) {
#line 229
      goto while_break;
    }
#line 230
    tilec = tcd_tile->comps + compno;
#line 232
    resno = (OPJ_UINT32 )0;
    {
#line 232
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 232
      if (! (resno < tilec->numresolutions)) {
#line 232
        goto while_break___0;
      }
#line 233
      res = tilec->resolutions + resno;
#line 235
      bandno = (OPJ_UINT32 )0;
      {
#line 235
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 235
        if (! (bandno < res->numbands)) {
#line 235
          goto while_break___1;
        }
#line 236
        band = & res->bands[bandno];
#line 238
        precno = (OPJ_UINT32 )0;
        {
#line 238
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 238
          if (! (precno < res->pw * res->ph)) {
#line 238
            goto while_break___2;
          }
#line 239
          prc = band->precincts + precno;
#line 241
          cblkno = (OPJ_UINT32 )0;
          {
#line 241
          while (1) {
            while_continue___8: /* CIL Label */ ;
            while_continue___3: ;
#line 241
            if (! (cblkno < prc->cw * prc->ch)) {
#line 241
              goto while_break___3;
            }
#line 242
            cblk = prc->cblks.enc + cblkno;
#line 243
            layer = cblk->layers + layno;
#line 246
            if (layno == 0U) {
#line 247
              cblk->numpassesinlayers = (OPJ_UINT32 )0;
            }
#line 250
            n = cblk->numpassesinlayers;
#line 252
            passno = cblk->numpassesinlayers;
            {
#line 252
            while (1) {
              while_continue___9: /* CIL Label */ ;
              while_continue___4: ;
#line 252
              if (! (passno < cblk->totalpasses)) {
#line 252
                goto while_break___4;
              }
#line 255
              pass = cblk->passes + passno;
#line 257
              if (n == 0U) {
#line 258
                dr = pass->rate;
#line 259
                dd = pass->distortiondec;
              } else {
#line 261
                dr = pass->rate - (cblk->passes + (n - 1U))->rate;
#line 262
                dd = pass->distortiondec - (cblk->passes + (n - 1U))->distortiondec;
              }
#line 265
              if (! dr) {
#line 266
                if (dd != (double )0) {
#line 267
                  n = passno + 1U;
                }
#line 268
                goto while_continue___4;
              }
#line 270
              if (dd / (double )dr >= thresh) {
#line 271
                n = passno + 1U;
              }
#line 252
              passno ++;
            }
            while_break___10: /* CIL Label */ ;
            }
            while_break___4: 
#line 274
            layer->numpasses = n - cblk->numpassesinlayers;
#line 276
            if (! layer->numpasses) {
#line 277
              layer->disto = (OPJ_FLOAT64 )0;
#line 278
              goto while_continue___3;
            }
#line 281
            if (cblk->numpassesinlayers == 0U) {
#line 282
              layer->len = (cblk->passes + (n - 1U))->rate;
#line 283
              layer->data = cblk->data;
#line 284
              layer->disto = (cblk->passes + (n - 1U))->distortiondec;
            } else {
#line 286
              layer->len = (cblk->passes + (n - 1U))->rate - (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 287
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 288
              layer->disto = (cblk->passes + (n - 1U))->distortiondec - (cblk->passes + (cblk->numpassesinlayers - 1U))->distortiondec;
            }
#line 291
            tcd_tile->distolayer[layno] += layer->disto;
#line 293
            if (final) {
#line 294
              cblk->numpassesinlayers = n;
            }
#line 241
            cblkno ++;
          }
          while_break___9: /* CIL Label */ ;
          }
          while_break___3: 
#line 238
          precno ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: 
#line 235
        bandno ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: 
#line 232
      resno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: 
#line 229
    compno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 233
  return;
}
}
#line 302 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
void opj_tcd_makelayer_fixed(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_UINT32 final ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_INT32 value ;
  OPJ_INT32 matrice[10][10][3] ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  OPJ_UINT32 n ;
  OPJ_INT32 imsb ;

  {
#line 308
  cp = tcd->cp;
#line 309
  tcd_tile = (tcd->tcd_image)->tiles;
#line 310
  tcd_tcp = tcd->tcp;
#line 312
  compno = (OPJ_UINT32 )0;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;

#line 312
    if (! (compno < tcd_tile->numcomps)) {
#line 312
      goto while_break;
    }
#line 313
    tilec = tcd_tile->comps + compno;
#line 315
    i = (OPJ_UINT32 )0;
    {
#line 315
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 315
      if (! (i < tcd_tcp->numlayers)) {
#line 315
        goto while_break___0;
      }
#line 316
      j = (OPJ_UINT32 )0;
      {
#line 316
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 316
        if (! (j < tilec->numresolutions)) {
#line 316
          goto while_break___1;
        }
#line 317
        k = (OPJ_UINT32 )0;
        {
#line 317
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 317
          if (! (k < 3U)) {
#line 317
            goto while_break___2;
          }
#line 318
          matrice[i][j][k] = (OPJ_INT32 )((OPJ_FLOAT32 )*(cp->m_specific_param.m_enc.m_matrice + (((i * tilec->numresolutions) * 3U + j * 3U) + k)) * (OPJ_FLOAT32 )((double )((tcd->image)->comps + compno)->prec / 16.));
#line 317
          k ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: 
#line 316
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 315
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 325
    resno = (OPJ_UINT32 )0;
    {
#line 325
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 325
      if (! (resno < tilec->numresolutions)) {
#line 325
        goto while_break___3;
      }
#line 326
      res = tilec->resolutions + resno;
#line 328
      bandno = (OPJ_UINT32 )0;
      {
#line 328
      while (1) {
        while_continue___11: /* CIL Label */ ;

#line 328
        if (! (bandno < res->numbands)) {
#line 328
          goto while_break___4;
        }
#line 329
        band = & res->bands[bandno];
#line 331
        precno = (OPJ_UINT32 )0;
        {
#line 331
        while (1) {
          while_continue___12: /* CIL Label */ ;

#line 331
          if (! (precno < res->pw * res->ph)) {
#line 331
            goto while_break___5;
          }
#line 332
          prc = band->precincts + precno;
#line 334
          cblkno = (OPJ_UINT32 )0;
          {
#line 334
          while (1) {
            while_continue___13: /* CIL Label */ ;
            while_continue___6: ;
#line 334
            if (! (cblkno < prc->cw * prc->ch)) {
#line 334
              goto while_break___6;
            }
#line 335
            cblk = prc->cblks.enc + cblkno;
#line 336
            layer = cblk->layers + layno;
#line 338
            imsb = (OPJ_INT32 )(((tcd->image)->comps + compno)->prec - cblk->numbps);
#line 341
            if (layno == 0U) {
#line 342
              value = matrice[layno][resno][bandno];
#line 343
              if (imsb >= value) {
#line 344
                value = 0;
              } else {
#line 346
                value -= imsb;
              }
            } else {
#line 349
              value = matrice[layno][resno][bandno] - matrice[layno - 1U][resno][bandno];
#line 350
              if (imsb >= matrice[layno - 1U][resno][bandno]) {
#line 351
                value -= imsb - matrice[layno - 1U][resno][bandno];
#line 352
                if (value < 0) {
#line 353
                  value = 0;
                }
              }
            }
#line 358
            if (layno == 0U) {
#line 359
              cblk->numpassesinlayers = (OPJ_UINT32 )0;
            }
#line 362
            n = cblk->numpassesinlayers;
#line 363
            if (cblk->numpassesinlayers == 0U) {
#line 364
              if (value != 0) {
#line 365
                n = (3U * (OPJ_UINT32 )value - 2U) + cblk->numpassesinlayers;
              } else {
#line 367
                n = cblk->numpassesinlayers;
              }
            } else {
#line 370
              n = 3U * (OPJ_UINT32 )value + cblk->numpassesinlayers;
            }
#line 373
            layer->numpasses = n - cblk->numpassesinlayers;
#line 375
            if (! layer->numpasses) {
#line 376
              goto while_continue___6;
            }
#line 378
            if (cblk->numpassesinlayers == 0U) {
#line 379
              layer->len = (cblk->passes + (n - 1U))->rate;
#line 380
              layer->data = cblk->data;
            } else {
#line 382
              layer->len = (cblk->passes + (n - 1U))->rate - (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 383
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
            }
#line 386
            if (final) {
#line 387
              cblk->numpassesinlayers = n;
            }
#line 334
            cblkno ++;
          }
          while_break___14: /* CIL Label */ ;
          }
          while_break___6: 
#line 331
          precno ++;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: 
#line 328
        bandno ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___4: 
#line 325
      resno ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___3: 
#line 312
    compno ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 316
  return;
}
}
#line 395 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_rateallocate(opj_tcd_t *tcd , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 len , opj_codestream_info_t *cstr_info ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 passno ;
  OPJ_FLOAT64 min ;
  OPJ_FLOAT64 max ;
  OPJ_FLOAT64 cumdisto[100] ;
  OPJ_FLOAT64 K ;
  OPJ_FLOAT64 maxSE ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  OPJ_INT32 dr ;
  OPJ_FLOAT64 dd ;
  OPJ_FLOAT64 rdslope ;
  opj_tile_info_t *tile_info ;
  void *__cil_tmp37 ;
  OPJ_FLOAT64 lo ;
  OPJ_FLOAT64 hi ;
  OPJ_BOOL success ;
  OPJ_UINT32 maxlen ;
  double __cil_tmp42 ;
  OPJ_UINT32 __cil_tmp43 ;
  OPJ_UINT32 tmp ;
  OPJ_FLOAT64 goodthresh ;
  OPJ_FLOAT64 stable_thresh ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 distotarget ;
  double __cil_tmp49 ;
  opj_t2_t *t2 ;
  opj_t2_t *__cil_tmp51 ;
  OPJ_FLOAT64 thresh ;
  OPJ_FLOAT64 distoachieved ;
  OPJ_BOOL __cil_tmp54 ;
  OPJ_FLOAT64 tmp___0 ;
  OPJ_FLOAT64 tmp___1 ;
  OPJ_BOOL __cil_tmp57 ;
  OPJ_FLOAT64 tmp___2 ;
  OPJ_FLOAT64 tmp___3 ;

  {
#line 405
  K = (OPJ_FLOAT64 )1;
#line 406
  maxSE = (OPJ_FLOAT64 )0;
#line 408
  cp = tcd->cp;
#line 409
  tcd_tile = (tcd->tcd_image)->tiles;
#line 410
  tcd_tcp = tcd->tcp;
#line 412
  min = (double )1.79769313487e+308L;
#line 413
  max = (OPJ_FLOAT64 )0;
#line 415
  tcd_tile->numpix = 0;
#line 417
  compno = (OPJ_UINT32 )0;
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;

#line 417
    if (! (compno < tcd_tile->numcomps)) {
#line 417
      goto while_break;
    }
#line 418
    tilec = tcd_tile->comps + compno;
#line 419
    tilec->numpix = 0;
#line 421
    resno = (OPJ_UINT32 )0;
    {
#line 421
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 421
      if (! (resno < tilec->numresolutions)) {
#line 421
        goto while_break___0;
      }
#line 422
      res = tilec->resolutions + resno;
#line 424
      bandno = (OPJ_UINT32 )0;
      {
#line 424
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 424
        if (! (bandno < res->numbands)) {
#line 424
          goto while_break___1;
        }
#line 425
        band = & res->bands[bandno];
#line 427
        precno = (OPJ_UINT32 )0;
        {
#line 427
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 427
          if (! (precno < res->pw * res->ph)) {
#line 427
            goto while_break___2;
          }
#line 428
          prc = band->precincts + precno;
#line 430
          cblkno = (OPJ_UINT32 )0;
          {
#line 430
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 430
            if (! (cblkno < prc->cw * prc->ch)) {
#line 430
              goto while_break___3;
            }
#line 431
            cblk = prc->cblks.enc + cblkno;
#line 433
            passno = (OPJ_UINT32 )0;
            {
#line 433
            while (1) {
              while_continue___11: /* CIL Label */ ;
              while_continue___4: ;
#line 433
              if (! (passno < cblk->totalpasses)) {
#line 433
                goto while_break___4;
              }
#line 434
              pass = cblk->passes + passno;
#line 438
              if (passno == 0U) {
#line 439
                dr = (OPJ_INT32 )pass->rate;
#line 440
                dd = pass->distortiondec;
              } else {
#line 442
                dr = (OPJ_INT32 )(pass->rate - (cblk->passes + (passno - 1U))->rate);
#line 443
                dd = pass->distortiondec - (cblk->passes + (passno - 1U))->distortiondec;
              }
#line 446
              if (dr == 0) {
#line 447
                goto while_continue___4;
              }
#line 450
              rdslope = dd / (double )dr;
#line 451
              if (rdslope < min) {
#line 452
                min = rdslope;
              }
#line 455
              if (rdslope > max) {
#line 456
                max = rdslope;
              }
#line 433
              passno ++;
            }
            while_break___12: /* CIL Label */ ;
            }
            while_break___4: 
#line 461
            tcd_tile->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 462
            tilec->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 430
            cblkno ++;
          }
          while_break___11: /* CIL Label */ ;
          }
          while_break___3: 
#line 427
          precno ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: 
#line 424
        bandno ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 421
      resno ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 468
    maxSE += (((OPJ_FLOAT64 )(1 << ((tcd->image)->comps + compno)->prec) - 1.) * ((OPJ_FLOAT64 )(1 << ((tcd->image)->comps + compno)->prec) - 1.)) * (OPJ_FLOAT64 )tilec->numpix;
#line 417
    compno ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 474
  if (cstr_info) {
    {
#line 475
    tile_info = cstr_info->tile + tcd->tcd_tileno;
#line 476
    tile_info->numpix = tcd_tile->numpix;
#line 477
    tile_info->distotile = tcd_tile->distotile;
#line 478
    __cil_tmp37 = malloc((unsigned long )tcd_tcp->numlayers * sizeof(OPJ_FLOAT64 ));
#line 478
    tile_info->thresh = (OPJ_FLOAT64 *)__cil_tmp37;
    }
#line 479
    if (! tile_info->thresh) {
#line 481
      return (0);
    }
  }
#line 485
  layno = (OPJ_UINT32 )0;
  {
#line 485
  while (1) {
    while_continue___12: /* CIL Label */ ;

#line 485
    if (! (layno < tcd_tcp->numlayers)) {
#line 485
      goto while_break___5;
    }
#line 486
    lo = min;
#line 487
    hi = max;
#line 488
    success = 0;
#line 489
    if (tcd_tcp->rates[layno]) {
      {
#line 489
      __cil_tmp42 = ceil((double )tcd_tcp->rates[layno]);
#line 489
      __cil_tmp43 = opj_uint_min((OPJ_UINT32 )__cil_tmp42, len);
#line 489
      tmp = __cil_tmp43;
      }
    } else {
#line 489
      tmp = len;
    }
    {
#line 489
    maxlen = tmp;
#line 490
    goodthresh = (OPJ_FLOAT64 )0;
#line 491
    stable_thresh = (OPJ_FLOAT64 )0;
#line 496
    __cil_tmp49 = pow((double )((OPJ_FLOAT32 )10), (double )(tcd_tcp->distoratio[layno] / (float )10));
#line 496
    distotarget = tcd_tile->distotile - (K * maxSE) / __cil_tmp49;
    }
#line 502
    if ((int )cp->m_specific_param.m_enc.m_disto_alloc == 1) {
#line 502
      if (tcd_tcp->rates[layno] > (float )0) {
        _L___4: 
        {
#line 503
        __cil_tmp51 = opj_t2_create(tcd->image, cp);
#line 503
        t2 = __cil_tmp51;
#line 504
        thresh = (OPJ_FLOAT64 )0;
        }
#line 506
        if ((unsigned long )t2 == (unsigned long )((opj_t2_t *)0)) {
#line 507
          return (0);
        }
#line 510
        i = (OPJ_UINT32 )0;
        {
#line 510
        while (1) {
          while_continue___13: /* CIL Label */ ;
          while_continue___6: ;
#line 510
          if (! (i < 128U)) {
#line 510
            goto while_break___6;
          }
          {
#line 511
          distoachieved = (OPJ_FLOAT64 )0;
#line 513
          thresh = (lo + hi) / (double )2;
#line 515
          opj_tcd_makelayer(tcd, layno, thresh, (OPJ_UINT32 )0);
          }
#line 517
          if (cp->m_specific_param.m_enc.m_fixed_quality) {
#line 518
            if ((int )cp->rsiz >= 3) {
#line 518
              if ((int )cp->rsiz <= 6) {
                {
#line 519
                __cil_tmp54 = opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile,
                                                    layno + 1U, dest, p_data_written,
                                                    maxlen, cstr_info, tcd->cur_tp_num,
                                                    tcd->tp_pos, tcd->cur_pino, (J2K_T2_MODE )0);
                }
#line 519
                if (! __cil_tmp54) {
#line 521
                  lo = thresh;
#line 522
                  goto while_continue___6;
                } else {
#line 525
                  if (layno == 0U) {
#line 525
                    tmp___0 = tcd_tile->distolayer[0];
                  } else {
#line 525
                    tmp___0 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
                  }
#line 525
                  distoachieved = tmp___0;
#line 528
                  if (distoachieved < distotarget) {
#line 529
                    hi = thresh;
#line 530
                    stable_thresh = thresh;
#line 531
                    goto while_continue___6;
                  } else {
#line 533
                    lo = thresh;
                  }
                }
              } else {
#line 518
                goto _L;
              }
            } else {
              _L: 
#line 537
              if (layno == 0U) {
#line 537
                tmp___1 = tcd_tile->distolayer[0];
              } else {
#line 537
                tmp___1 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
              }
#line 537
              distoachieved = tmp___1;
#line 540
              if (distoachieved < distotarget) {
#line 541
                hi = thresh;
#line 542
                stable_thresh = thresh;
#line 543
                goto while_continue___6;
              }
#line 545
              lo = thresh;
            }
          } else {
            {
#line 548
            __cil_tmp57 = opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1U,
                                                dest, p_data_written, maxlen, cstr_info,
                                                tcd->cur_tp_num, tcd->tp_pos, tcd->cur_pino,
                                                (J2K_T2_MODE )0);
            }
#line 548
            if (! __cil_tmp57) {
#line 552
              lo = thresh;
#line 553
              goto while_continue___6;
            }
#line 556
            hi = thresh;
#line 557
            stable_thresh = thresh;
          }
#line 510
          i ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: 
#line 561
        success = 1;
#line 562
        if (stable_thresh == (double )0) {
#line 562
          tmp___2 = thresh;
        } else {
#line 562
          tmp___2 = stable_thresh;
        }
        {
#line 562
        goodthresh = tmp___2;
#line 564
        opj_t2_destroy(t2);
        }
      } else {
#line 502
        goto _L___5;
      }
    } else
    _L___5: 
#line 502
    if ((int )cp->m_specific_param.m_enc.m_fixed_quality == 1) {
#line 502
      if (tcd_tcp->distoratio[layno] > (float )0) {
#line 502
        goto _L___4;
      } else {
#line 566
        success = 1;
#line 567
        goodthresh = min;
      }
    } else {
#line 566
      success = 1;
#line 567
      goodthresh = min;
    }
#line 570
    if (! success) {
#line 571
      return (0);
    }
#line 574
    if (cstr_info) {
#line 575
      *((cstr_info->tile + tcd->tcd_tileno)->thresh + layno) = goodthresh;
    }
    {
#line 578
    opj_tcd_makelayer(tcd, layno, goodthresh, (OPJ_UINT32 )1);
    }
#line 581
    if (layno == 0U) {
#line 581
      tmp___3 = tcd_tile->distolayer[0];
    } else {
#line 581
      tmp___3 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
    }
#line 581
    cumdisto[layno] = tmp___3;
#line 485
    layno ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___5: ;
#line 584
  return (1);
}
}
#line 587 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init(opj_tcd_t *p_tcd , opj_image_t *p_image , opj_cp_t *p_cp ) 
{ 
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 591
  p_tcd->image = p_image;
#line 592
  p_tcd->cp = p_cp;
#line 594
  __cil_tmp4 = calloc(1UL, sizeof(opj_tcd_tile_t ));
#line 594
  (p_tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp4;
  }
#line 595
  if (! (p_tcd->tcd_image)->tiles) {
#line 596
    return (0);
  }
  {
#line 599
  __cil_tmp5 = calloc((unsigned long )p_image->numcomps, sizeof(opj_tcd_tilecomp_t ));
#line 599
  ((p_tcd->tcd_image)->tiles)->comps = (opj_tcd_tilecomp_t *)__cil_tmp5;
  }
#line 600
  if (! ((p_tcd->tcd_image)->tiles)->comps) {
#line 601
    return (0);
  }
#line 604
  ((p_tcd->tcd_image)->tiles)->numcomps = p_image->numcomps;
#line 605
  p_tcd->tp_pos = p_cp->m_specific_param.m_enc.m_tp_pos;
#line 607
  return (1);
}
}
#line 613 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
void opj_tcd_destroy(opj_tcd_t *tcd ) 
{ 


  {
#line 614
  if (tcd) {
    {
#line 615
    opj_tcd_free_tile(tcd);
    }
#line 617
    if (tcd->tcd_image) {
      {
#line 618
      free((void *)tcd->tcd_image);
#line 619
      tcd->tcd_image = (opj_tcd_image_t *)0;
      }
    }
    {
#line 621
    free((void *)tcd);
    }
  }
#line 624
  return;
}
}
#line 625 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec ) 
{ 
  void *__cil_tmp2 ;
  OPJ_INT32 *new_data ;
  void *__cil_tmp4 ;

  {
#line 627
  if ((unsigned long )l_tilec->data == (unsigned long )((OPJ_INT32 *)0)) {
    _L: 
    {
#line 628
    __cil_tmp2 = malloc((unsigned long )l_tilec->data_size_needed);
#line 628
    l_tilec->data = (OPJ_INT32 *)__cil_tmp2;
    }
#line 629
    if (! l_tilec->data) {
#line 630
      return (0);
    }
#line 633
    l_tilec->data_size = l_tilec->data_size_needed;
#line 634
    l_tilec->ownsData = 1;
  } else
#line 627
  if (l_tilec->data_size_needed > l_tilec->data_size) {
#line 627
    if (l_tilec->ownsData == 0) {
#line 627
      goto _L;
    } else {
#line 627
      goto _L___6;
    }
  } else
  _L___6: 
#line 636
  if (l_tilec->data_size_needed > l_tilec->data_size) {
    {
#line 637
    __cil_tmp4 = realloc((void *)l_tilec->data, (unsigned long )l_tilec->data_size_needed);
#line 637
    new_data = (OPJ_INT32 *)__cil_tmp4;
    }
#line 640
    if (! new_data) {
      {
#line 641
      free((void *)l_tilec->data);
#line 642
      l_tilec->data = (OPJ_INT32 *)((void *)0);
#line 643
      l_tilec->data_size = (OPJ_UINT32 )0;
#line 644
      l_tilec->data_size_needed = (OPJ_UINT32 )0;
#line 645
      l_tilec->ownsData = 0;
      }
#line 646
      return (0);
    }
#line 648
    l_tilec->data = new_data;
#line 650
    l_tilec->data_size = l_tilec->data_size_needed;
#line 651
    l_tilec->ownsData = 1;
  }
#line 653
  return (1);
}
}
#line 658 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
__inline static OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ,
                                           OPJ_BOOL isEncoder , OPJ_FLOAT32 fraction ,
                                           OPJ_SIZE_T sizeof_block ) 
{ 
  OPJ_UINT32 (*l_gain_ptr)(OPJ_UINT32  ) ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  opj_tcp_t *l_tcp ;
  opj_cp_t *l_cp ;
  opj_tcd_tile_t *l_tile ;
  opj_tccp_t *l_tccp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_image_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_band_t *l_band ;
  opj_stepsize_t *l_step_size ;
  opj_tcd_precinct_t *l_current_precinct ;
  opj_image_t *l_image ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_level_no ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_gain ;
  OPJ_INT32 l_x0b ;
  OPJ_INT32 l_y0b ;
  OPJ_INT32 l_tl_prc_x_start ;
  OPJ_INT32 l_tl_prc_y_start ;
  OPJ_INT32 l_br_prc_x_end ;
  OPJ_INT32 l_br_prc_y_end ;
  OPJ_UINT32 l_nb_precincts ;
  OPJ_UINT32 l_nb_precinct_size ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_UINT32 l_nb_code_blocks_size ;
  OPJ_UINT32 l_data_size ;
  OPJ_BOOL __cil_tmp48 ;
  void *__cil_tmp49 ;
  opj_tcd_resolution_t *new_resolutions ;
  void *__cil_tmp51 ;
  OPJ_INT32 tlcbgxstart ;
  OPJ_INT32 tlcbgystart ;
  OPJ_UINT32 cbgwidthexpn ;
  OPJ_UINT32 cbgheightexpn ;
  OPJ_UINT32 cblkwidthexpn ;
  OPJ_UINT32 cblkheightexpn ;
  OPJ_INT32 __cil_tmp62 ;
  OPJ_INT32 __cil_tmp63 ;
  OPJ_INT32 __cil_tmp64 ;
  OPJ_INT32 __cil_tmp65 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  OPJ_INT32 numbps ;
  double __cil_tmp82 ;
  void *__cil_tmp83 ;
  opj_tcd_precinct_t *new_precincts ;
  void *__cil_tmp85 ;
  OPJ_INT32 tlcblkxstart ;
  OPJ_INT32 tlcblkystart ;
  OPJ_INT32 brcblkxend ;
  OPJ_INT32 brcblkyend ;
  OPJ_INT32 cbgxstart ;
  OPJ_INT32 cbgystart ;
  OPJ_INT32 cbgxend ;
  OPJ_INT32 cbgyend ;
  OPJ_INT32 __cil_tmp98 ;
  OPJ_INT32 __cil_tmp99 ;
  OPJ_INT32 __cil_tmp100 ;
  OPJ_INT32 __cil_tmp101 ;
  void *new_blocks ;
  void *__cil_tmp104 ;
  OPJ_INT32 cblkxstart ;
  OPJ_INT32 cblkystart ;
  OPJ_INT32 cblkxend ;
  OPJ_INT32 cblkyend ;
  opj_tcd_cblk_enc_t *l_code_block ;
  OPJ_BOOL __cil_tmp114 ;
  OPJ_BOOL __cil_tmp119 ;
  opj_tcd_cblk_dec_t *l_code_block___0 ;
  OPJ_BOOL __cil_tmp121 ;

  {
  {
#line 660
  l_gain_ptr = (OPJ_UINT32 (*)(OPJ_UINT32  ))0;
#line 662
  l_tcp = (opj_tcp_t *)0;
#line 663
  l_cp = (opj_cp_t *)0;
#line 664
  l_tile = (opj_tcd_tile_t *)0;
#line 665
  l_tccp = (opj_tccp_t *)0;
#line 666
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 667
  l_image_comp = (opj_image_comp_t *)0;
#line 668
  l_res = (opj_tcd_resolution_t *)0;
#line 669
  l_band = (opj_tcd_band_t *)0;
#line 670
  l_step_size = (opj_stepsize_t *)0;
#line 671
  l_current_precinct = (opj_tcd_precinct_t *)0;
#line 672
  l_image = (opj_image_t *)0;
#line 691
  l_cp = p_tcd->cp;
#line 692
  l_tcp = l_cp->tcps + p_tile_no;
#line 693
  l_tile = (p_tcd->tcd_image)->tiles;
#line 694
  l_tccp = l_tcp->tccps;
#line 695
  l_tilec = l_tile->comps;
#line 696
  l_image = p_tcd->image;
#line 697
  l_image_comp = (p_tcd->image)->comps;
#line 699
  p = p_tile_no % l_cp->tw;
#line 700
  q = p_tile_no / l_cp->tw;
#line 704
  l_tile->x0 = opj_int_max((OPJ_INT32 )(l_cp->tx0 + p * l_cp->tdx), (OPJ_INT32 )l_image->x0);
#line 705
  l_tile->y0 = opj_int_max((OPJ_INT32 )(l_cp->ty0 + q * l_cp->tdy), (OPJ_INT32 )l_image->y0);
#line 706
  l_tile->x1 = opj_int_min((OPJ_INT32 )(l_cp->tx0 + (p + 1U) * l_cp->tdx), (OPJ_INT32 )l_image->x1);
#line 707
  l_tile->y1 = opj_int_min((OPJ_INT32 )(l_cp->ty0 + (q + 1U) * l_cp->tdy), (OPJ_INT32 )l_image->y1);
  }
#line 709
  if (l_tccp->numresolutions == 0U) {
    {
#line 710
    fprintf(stderr, "tiles require at least one resolution\n");
    }
#line 711
    return (0);
  }
#line 716
  compno = (OPJ_UINT32 )0;
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;

#line 716
    if (! (compno < l_tile->numcomps)) {
#line 716
      goto while_break;
    }
    {
#line 718
    l_image_comp->resno_decoded = (OPJ_UINT32 )0;
#line 720
    l_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32 )l_image_comp->dx);
#line 721
    l_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32 )l_image_comp->dy);
#line 722
    l_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32 )l_image_comp->dx);
#line 723
    l_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32 )l_image_comp->dy);
#line 727
    l_data_size = (OPJ_UINT32 )(l_tilec->x1 - l_tilec->x0);
    }
#line 728
    if (4294967295U / l_data_size < (OPJ_UINT32 )(l_tilec->y1 - l_tilec->y0)) {
#line 730
      return (0);
    }
#line 732
    l_data_size *= (OPJ_UINT32 )(l_tilec->y1 - l_tilec->y0);
#line 734
    if (4294967295U / (OPJ_UINT32 )sizeof(OPJ_UINT32 ) < l_data_size) {
#line 736
      return (0);
    }
#line 738
    l_data_size *= (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 739
    l_tilec->numresolutions = l_tccp->numresolutions;
#line 740
    if (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {
#line 741
      l_tilec->minimum_num_resolutions = (OPJ_UINT32 )1;
    } else {
#line 744
      l_tilec->minimum_num_resolutions = l_tccp->numresolutions - l_cp->m_specific_param.m_dec.m_reduce;
    }
    {
#line 747
    l_tilec->data_size_needed = l_data_size;
#line 748
    __cil_tmp48 = opj_alloc_tile_component_data(l_tilec);
    }
#line 748
    if ((int )p_tcd->m_is_decoder) {
#line 748
      if (! __cil_tmp48) {
#line 749
        return (0);
      }
    }
#line 752
    l_data_size = l_tilec->numresolutions * (OPJ_UINT32 )sizeof(opj_tcd_resolution_t );
#line 754
    if ((unsigned long )l_tilec->resolutions == (unsigned long )((opj_tcd_resolution_t *)0)) {
      {
#line 755
      __cil_tmp49 = malloc((unsigned long )l_data_size);
#line 755
      l_tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp49;
      }
#line 756
      if (! l_tilec->resolutions) {
#line 757
        return (0);
      }
      {
#line 760
      l_tilec->resolutions_size = l_data_size;
#line 761
      memset((void *)l_tilec->resolutions, 0, (unsigned long )l_data_size);
      }
    } else
#line 763
    if (l_data_size > l_tilec->resolutions_size) {
      {
#line 764
      __cil_tmp51 = realloc((void *)l_tilec->resolutions, (unsigned long )l_data_size);
#line 764
      new_resolutions = (opj_tcd_resolution_t *)__cil_tmp51;
      }
#line 765
      if (! new_resolutions) {
        {
#line 767
        fprintf(stderr, "Not enough memory to tile resolutions\n");
#line 768
        free((void *)l_tilec->resolutions);
#line 769
        l_tilec->resolutions = (opj_tcd_resolution_t *)((void *)0);
#line 770
        l_tilec->resolutions_size = (OPJ_UINT32 )0;
        }
#line 771
        return (0);
      }
      {
#line 773
      l_tilec->resolutions = new_resolutions;
#line 775
      memset((void *)((OPJ_BYTE *)l_tilec->resolutions + l_tilec->resolutions_size),
             0, (unsigned long )(l_data_size - l_tilec->resolutions_size));
#line 776
      l_tilec->resolutions_size = l_data_size;
      }
    }
#line 779
    l_level_no = l_tilec->numresolutions - 1U;
#line 780
    l_res = l_tilec->resolutions;
#line 781
    l_step_size = l_tccp->stepsizes;
#line 782
    if (l_tccp->qmfbid == 0U) {
#line 783
      l_gain_ptr = & opj_dwt_getgain_real;
    } else {
#line 786
      l_gain_ptr = & opj_dwt_getgain;
    }
#line 790
    resno = (OPJ_UINT32 )0;
    {
#line 790
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 790
      if (! (resno < l_tilec->numresolutions)) {
#line 790
        goto while_break___0;
      }
      {
#line 797
      l_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 798
      l_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 799
      l_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 800
      l_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
#line 803
      l_pdx = l_tccp->prcw[resno];
#line 804
      l_pdy = l_tccp->prch[resno];
#line 807
      __cil_tmp62 = opj_int_floordivpow2(l_res->x0, (OPJ_INT32 )l_pdx);
#line 807
      l_tl_prc_x_start = __cil_tmp62 << l_pdx;
#line 808
      __cil_tmp63 = opj_int_floordivpow2(l_res->y0, (OPJ_INT32 )l_pdy);
#line 808
      l_tl_prc_y_start = __cil_tmp63 << l_pdy;
#line 809
      __cil_tmp64 = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32 )l_pdx);
#line 809
      l_br_prc_x_end = __cil_tmp64 << l_pdx;
#line 810
      __cil_tmp65 = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32 )l_pdy);
#line 810
      l_br_prc_y_end = __cil_tmp65 << l_pdy;
      }
#line 813
      if (l_res->x0 == l_res->x1) {
#line 813
        tmp = 0U;
      } else {
#line 813
        tmp = (OPJ_UINT32 )((l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);
      }
#line 813
      l_res->pw = tmp;
#line 814
      if (l_res->y0 == l_res->y1) {
#line 814
        tmp___0 = 0U;
      } else {
#line 814
        tmp___0 = (OPJ_UINT32 )((l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);
      }
#line 814
      l_res->ph = tmp___0;
#line 817
      l_nb_precincts = l_res->pw * l_res->ph;
#line 818
      l_nb_precinct_size = l_nb_precincts * (OPJ_UINT32 )sizeof(opj_tcd_precinct_t );
#line 819
      if (resno == 0U) {
#line 820
        tlcbgxstart = l_tl_prc_x_start;
#line 821
        tlcbgystart = l_tl_prc_y_start;
#line 824
        cbgwidthexpn = l_pdx;
#line 825
        cbgheightexpn = l_pdy;
#line 826
        l_res->numbands = (OPJ_UINT32 )1;
      } else {
        {
#line 829
        tlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);
#line 830
        tlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);
#line 833
        cbgwidthexpn = l_pdx - 1U;
#line 834
        cbgheightexpn = l_pdy - 1U;
#line 835
        l_res->numbands = (OPJ_UINT32 )3;
        }
      }
      {
#line 838
      cblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);
#line 839
      cblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);
#line 840
      l_band = l_res->bands;
#line 842
      bandno = (OPJ_UINT32 )0;
      }
      {
#line 842
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 842
        if (! (bandno < l_res->numbands)) {
#line 842
          goto while_break___1;
        }
#line 846
        if (resno == 0U) {
          {
#line 847
          l_band->bandno = (OPJ_UINT32 )0;
#line 848
          l_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 849
          l_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 850
          l_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 851
          l_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
          }
        } else {
          {
#line 854
          l_band->bandno = bandno + 1U;
#line 856
          l_x0b = (OPJ_INT32 )(l_band->bandno & 1U);
#line 858
          l_y0b = (OPJ_INT32 )(l_band->bandno >> 1);
#line 860
          l_band->x0 = opj_int_ceildivpow2(l_tilec->x0 - (1 << l_level_no) * l_x0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
#line 861
          l_band->y0 = opj_int_ceildivpow2(l_tilec->y0 - (1 << l_level_no) * l_y0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
#line 862
          l_band->x1 = opj_int_ceildivpow2(l_tilec->x1 - (1 << l_level_no) * l_x0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
#line 863
          l_band->y1 = opj_int_ceildivpow2(l_tilec->y1 - (1 << l_level_no) * l_y0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
          }
        }
        {
#line 867
        l_gain = (*l_gain_ptr)(l_band->bandno);
#line 868
        numbps = (OPJ_INT32 )(l_image_comp->prec + l_gain);
#line 869
        __cil_tmp82 = pow(2., (double )(numbps - l_step_size->expn));
#line 869
        l_band->stepsize = (OPJ_FLOAT32 )((1. + (double )l_step_size->mant / 2048.) * __cil_tmp82) * fraction;
#line 870
        l_band->numbps = (l_step_size->expn + (OPJ_INT32 )l_tccp->numgbits) - 1;
        }
#line 872
        if (! l_band->precincts) {
          {
#line 873
          __cil_tmp83 = malloc((unsigned long )l_nb_precinct_size);
#line 873
          l_band->precincts = (opj_tcd_precinct_t *)__cil_tmp83;
          }
#line 874
          if (! l_band->precincts) {
#line 875
            return (0);
          }
          {
#line 878
          memset((void *)l_band->precincts, 0, (unsigned long )l_nb_precinct_size);
#line 879
          l_band->precincts_data_size = l_nb_precinct_size;
          }
        } else
#line 881
        if (l_band->precincts_data_size < l_nb_precinct_size) {
          {
#line 883
          __cil_tmp85 = realloc((void *)l_band->precincts, (unsigned long )l_nb_precinct_size);
#line 883
          new_precincts = (opj_tcd_precinct_t *)__cil_tmp85;
          }
#line 884
          if (! new_precincts) {
            {
#line 886
            fprintf(stderr, "Not enough memory to handle band precints\n");
#line 887
            free((void *)l_band->precincts);
#line 888
            l_band->precincts = (opj_tcd_precinct_t *)((void *)0);
#line 889
            l_band->precincts_data_size = (OPJ_UINT32 )0;
            }
#line 890
            return (0);
          }
          {
#line 892
          l_band->precincts = new_precincts;
#line 894
          memset((void *)((OPJ_BYTE *)l_band->precincts + l_band->precincts_data_size),
                 0, (unsigned long )(l_nb_precinct_size - l_band->precincts_data_size));
#line 895
          l_band->precincts_data_size = l_nb_precinct_size;
          }
        }
#line 898
        l_current_precinct = l_band->precincts;
#line 899
        precno = (OPJ_UINT32 )0;
        {
#line 899
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 899
          if (! (precno < l_nb_precincts)) {
#line 899
            goto while_break___2;
          }
          {
#line 901
          cbgxstart = tlcbgxstart + (OPJ_INT32 )(precno % l_res->pw) * (1 << cbgwidthexpn);
#line 902
          cbgystart = tlcbgystart + (OPJ_INT32 )(precno / l_res->pw) * (1 << cbgheightexpn);
#line 903
          cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 904
          cbgyend = cbgystart + (1 << cbgheightexpn);
#line 911
          l_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);
#line 912
          l_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);
#line 913
          l_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);
#line 914
          l_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);
#line 917
          __cil_tmp98 = opj_int_floordivpow2(l_current_precinct->x0, (OPJ_INT32 )cblkwidthexpn);
#line 917
          tlcblkxstart = __cil_tmp98 << cblkwidthexpn;
#line 919
          __cil_tmp99 = opj_int_floordivpow2(l_current_precinct->y0, (OPJ_INT32 )cblkheightexpn);
#line 919
          tlcblkystart = __cil_tmp99 << cblkheightexpn;
#line 921
          __cil_tmp100 = opj_int_ceildivpow2(l_current_precinct->x1, (OPJ_INT32 )cblkwidthexpn);
#line 921
          brcblkxend = __cil_tmp100 << cblkwidthexpn;
#line 923
          __cil_tmp101 = opj_int_ceildivpow2(l_current_precinct->y1, (OPJ_INT32 )cblkheightexpn);
#line 923
          brcblkyend = __cil_tmp101 << cblkheightexpn;
#line 925
          l_current_precinct->cw = (OPJ_UINT32 )((brcblkxend - tlcblkxstart) >> cblkwidthexpn);
#line 926
          l_current_precinct->ch = (OPJ_UINT32 )((brcblkyend - tlcblkystart) >> cblkheightexpn);
#line 928
          l_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;
#line 930
          l_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32 )sizeof_block;
          }
#line 932
          if (! l_current_precinct->cblks.blocks) {
            {
#line 933
            l_current_precinct->cblks.blocks = malloc((unsigned long )l_nb_code_blocks_size);
            }
#line 934
            if (! l_current_precinct->cblks.blocks) {
#line 935
              return (0);
            }
            {
#line 939
            memset(l_current_precinct->cblks.blocks, 0, (unsigned long )l_nb_code_blocks_size);
#line 941
            l_current_precinct->block_size = l_nb_code_blocks_size;
            }
          } else
#line 943
          if (l_nb_code_blocks_size > l_current_precinct->block_size) {
            {
#line 944
            __cil_tmp104 = realloc(l_current_precinct->cblks.blocks, (unsigned long )l_nb_code_blocks_size);
#line 944
            new_blocks = __cil_tmp104;
            }
#line 945
            if (! new_blocks) {
              {
#line 946
              free(l_current_precinct->cblks.blocks);
#line 947
              l_current_precinct->cblks.blocks = (void *)0;
#line 948
              l_current_precinct->block_size = (OPJ_UINT32 )0;
#line 950
              fprintf(stderr, "Not enough memory for current precinct codeblock element\n");
              }
#line 951
              return (0);
            }
            {
#line 953
            l_current_precinct->cblks.blocks = new_blocks;
#line 956
            memset((void *)((OPJ_BYTE *)l_current_precinct->cblks.blocks + l_current_precinct->block_size),
                   0, (unsigned long )(l_nb_code_blocks_size - l_current_precinct->block_size));
#line 960
            l_current_precinct->block_size = l_nb_code_blocks_size;
            }
          }
#line 963
          if (! l_current_precinct->incltree) {
            {
#line 964
            l_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch);
            }
          } else {
            {
#line 968
            l_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,
                                                        l_current_precinct->cw, l_current_precinct->ch);
            }
          }
#line 973
          if (! l_current_precinct->incltree) {
            {
#line 974
            fprintf(stderr, "WARNING: No incltree created.\n");
            }
          }
#line 978
          if (! l_current_precinct->imsbtree) {
            {
#line 979
            l_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch);
            }
          } else {
            {
#line 984
            l_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree,
                                                        l_current_precinct->cw, l_current_precinct->ch);
            }
          }
#line 990
          if (! l_current_precinct->imsbtree) {
            {
#line 991
            fprintf(stderr, "WARNING: No imsbtree created.\n");
            }
          }
#line 995
          cblkno = (OPJ_UINT32 )0;
          {
#line 995
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 995
            if (! (cblkno < l_nb_code_blocks)) {
#line 995
              goto while_break___3;
            }
#line 996
            cblkxstart = tlcblkxstart + (OPJ_INT32 )(cblkno % l_current_precinct->cw) * (1 << cblkwidthexpn);
#line 997
            cblkystart = tlcblkystart + (OPJ_INT32 )(cblkno / l_current_precinct->cw) * (1 << cblkheightexpn);
#line 998
            cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 999
            cblkyend = cblkystart + (1 << cblkheightexpn);
#line 1001
            if (isEncoder) {
              {
#line 1002
              l_code_block = l_current_precinct->cblks.enc + cblkno;
#line 1004
              __cil_tmp114 = opj_tcd_code_block_enc_allocate(l_code_block);
              }
#line 1004
              if (! __cil_tmp114) {
#line 1005
                return (0);
              }
              {
#line 1008
              l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
#line 1009
              l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
#line 1010
              l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
#line 1011
              l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);
#line 1013
              __cil_tmp119 = opj_tcd_code_block_enc_allocate_data(l_code_block);
              }
#line 1013
              if (! __cil_tmp119) {
#line 1014
                return (0);
              }
            } else {
              {
#line 1017
              l_code_block___0 = l_current_precinct->cblks.dec + cblkno;
#line 1019
              __cil_tmp121 = opj_tcd_code_block_dec_allocate(l_code_block___0);
              }
#line 1019
              if (! __cil_tmp121) {
#line 1020
                return (0);
              }
              {
#line 1023
              l_code_block___0->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
#line 1024
              l_code_block___0->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
#line 1025
              l_code_block___0->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
#line 1026
              l_code_block___0->y1 = opj_int_min(cblkyend, l_current_precinct->y1);
              }
            }
#line 995
            cblkno ++;
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___3: 
#line 1029
          l_current_precinct ++;
#line 899
          precno ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: 
#line 1031
        l_band ++;
#line 1032
        l_step_size ++;
#line 842
        bandno ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
#line 1034
      l_res ++;
#line 1035
      l_level_no --;
#line 790
      resno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 1037
    l_tccp ++;
#line 1038
    l_tilec ++;
#line 1039
    l_image_comp ++;
#line 716
    compno ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 1041
  return (1);
}
}
#line 1044 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 1046
  __cil_tmp3 = opj_tcd_init_tile(p_tcd, p_tile_no, 1, 1.f, sizeof(opj_tcd_cblk_enc_t ));
  }
#line 1046
  return (__cil_tmp3);
}
}
#line 1049 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 1051
  __cil_tmp3 = opj_tcd_init_tile(p_tcd, p_tile_no, 0, 0.5f, sizeof(opj_tcd_cblk_dec_t ));
  }
#line 1051
  return (__cil_tmp3);
}
}
#line 1057 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *p_code_block ) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
#line 1059
  if (! p_code_block->layers) {
    {
#line 1061
    __cil_tmp2 = calloc(100UL, sizeof(opj_tcd_layer_t ));
#line 1061
    p_code_block->layers = (opj_tcd_layer_t *)__cil_tmp2;
    }
#line 1062
    if (! p_code_block->layers) {
#line 1063
      return (0);
    }
  }
#line 1066
  if (! p_code_block->passes) {
    {
#line 1067
    __cil_tmp3 = calloc(100UL, sizeof(opj_tcd_pass_t ));
#line 1067
    p_code_block->passes = (opj_tcd_pass_t *)__cil_tmp3;
    }
#line 1068
    if (! p_code_block->passes) {
#line 1069
      return (0);
    }
  }
#line 1072
  return (1);
}
}
#line 1078 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *p_code_block ) 
{ 
  OPJ_UINT32 l_data_size ;
  void *__cil_tmp3 ;

  {
#line 1082
  l_data_size = (OPJ_UINT32 )(((p_code_block->x1 - p_code_block->x0) * (p_code_block->y1 - p_code_block->y0)) * (OPJ_INT32 )sizeof(OPJ_UINT32 ));
#line 1084
  if (l_data_size > p_code_block->data_size) {
#line 1085
    if (p_code_block->data) {
      {
#line 1086
      free((void *)(p_code_block->data - 1));
      }
    }
    {
#line 1088
    __cil_tmp3 = malloc((unsigned long )l_data_size);
#line 1088
    p_code_block->data = (OPJ_BYTE *)__cil_tmp3;
    }
#line 1089
    if (! p_code_block->data) {
#line 1090
      p_code_block->data_size = 0U;
#line 1091
      return (0);
    }
#line 1093
    p_code_block->data_size = l_data_size;
#line 1095
    *(p_code_block->data + 0) = (OPJ_BYTE )0;
#line 1096
    (p_code_block->data) ++;
  }
#line 1098
  return (1);
}
}
#line 1104 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *p_code_block ) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  OPJ_BYTE *l_data ;
  OPJ_UINT32 l_data_max_size ;
  opj_tcd_seg_t *l_segs ;
  OPJ_UINT32 l_current_max_segs ;

  {
#line 1106
  if (! p_code_block->data) {
    {
#line 1108
    __cil_tmp2 = malloc(8192UL);
#line 1108
    p_code_block->data = (OPJ_BYTE *)__cil_tmp2;
    }
#line 1109
    if (! p_code_block->data) {
#line 1110
      return (0);
    }
    {
#line 1112
    p_code_block->data_max_size = (OPJ_UINT32 )8192;
#line 1115
    __cil_tmp3 = calloc(10UL, sizeof(opj_tcd_seg_t ));
#line 1115
    p_code_block->segs = (opj_tcd_seg_t *)__cil_tmp3;
    }
#line 1116
    if (! p_code_block->segs) {
#line 1117
      return (0);
    }
#line 1121
    p_code_block->m_current_max_segs = (OPJ_UINT32 )10;
  } else {
    {
#line 1125
    l_data = p_code_block->data;
#line 1126
    l_data_max_size = p_code_block->data_max_size;
#line 1127
    l_segs = p_code_block->segs;
#line 1128
    l_current_max_segs = p_code_block->m_current_max_segs;
#line 1130
    memset((void *)p_code_block, 0, sizeof(opj_tcd_cblk_dec_t ));
#line 1131
    p_code_block->data = l_data;
#line 1132
    p_code_block->data_max_size = l_data_max_size;
#line 1133
    p_code_block->segs = l_segs;
#line 1134
    p_code_block->m_current_max_segs = l_current_max_segs;
    }
  }
#line 1137
  return (1);
}
}
#line 1140 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_UINT32 opj_tcd_get_decoded_tile_size(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tcd_resolution_t *l_res ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;

  {
#line 1143
  l_data_size = (OPJ_UINT32 )0;
#line 1144
  l_img_comp = (opj_image_comp_t *)0;
#line 1145
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1146
  l_res = (opj_tcd_resolution_t *)0;
#line 1149
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 1150
  l_img_comp = (p_tcd->image)->comps;
#line 1152
  i = (OPJ_UINT32 )0;
  {
#line 1152
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1152
    if (! (i < (p_tcd->image)->numcomps)) {
#line 1152
      goto while_break;
    }
#line 1153
    l_size_comp = l_img_comp->prec >> 3;
#line 1154
    l_remaining = l_img_comp->prec & 7U;
#line 1156
    if (l_remaining) {
#line 1157
      l_size_comp ++;
    }
#line 1160
    if (l_size_comp == 3U) {
#line 1161
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 1164
    l_res = (l_tile_comp->resolutions + l_tile_comp->minimum_num_resolutions) - 1;
#line 1165
    l_data_size += l_size_comp * (OPJ_UINT32 )((l_res->x1 - l_res->x0) * (l_res->y1 - l_res->y0));
#line 1166
    l_img_comp ++;
#line 1167
    l_tile_comp ++;
#line 1152
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1170
  return (l_data_size);
}
}
#line 1173 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , OPJ_BYTE *p_dest ,
                             OPJ_UINT32 *p_data_written , OPJ_UINT32 p_max_length ,
                             opj_codestream_info_t *p_cstr_info ) 
{ 
  OPJ_UINT32 l_num_packs ;
  OPJ_UINT32 i ;
  opj_tcd_tilecomp_t *l_tilec_idx ;
  opj_tccp_t *l_tccp ;
  opj_tcd_resolution_t *l_res_idx ;
  void *__cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;

  {
#line 1181
  if (p_tcd->cur_tp_num == 0U) {
#line 1183
    p_tcd->tcd_tileno = p_tile_no;
#line 1184
    p_tcd->tcp = (p_tcd->cp)->tcps + p_tile_no;
#line 1187
    if (p_cstr_info) {
#line 1188
      l_num_packs = (OPJ_UINT32 )0;
#line 1190
      l_tilec_idx = ((p_tcd->tcd_image)->tiles)->comps + 0;
#line 1191
      l_tccp = (p_tcd->tcp)->tccps;
#line 1193
      i = (OPJ_UINT32 )0;
      {
#line 1193
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1193
        if (! (i < l_tilec_idx->numresolutions)) {
#line 1193
          goto while_break;
        }
#line 1194
        l_res_idx = l_tilec_idx->resolutions + i;
#line 1196
        (p_cstr_info->tile + p_tile_no)->pw[i] = (int )l_res_idx->pw;
#line 1197
        (p_cstr_info->tile + p_tile_no)->ph[i] = (int )l_res_idx->ph;
#line 1199
        l_num_packs += l_res_idx->pw * l_res_idx->ph;
#line 1200
        (p_cstr_info->tile + p_tile_no)->pdx[i] = (int )l_tccp->prcw[i];
#line 1201
        (p_cstr_info->tile + p_tile_no)->pdy[i] = (int )l_tccp->prch[i];
#line 1193
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 1203
      __cil_tmp13 = calloc(((size_t )p_cstr_info->numcomps * (size_t )p_cstr_info->numlayers) * (unsigned long )l_num_packs,
                           sizeof(opj_packet_info_t ));
#line 1203
      (p_cstr_info->tile + p_tile_no)->packet = (opj_packet_info_t *)__cil_tmp13;
      }
#line 1204
      if (! (p_cstr_info->tile + p_tile_no)->packet) {
#line 1206
        return (0);
      }
    }
    {
#line 1213
    __cil_tmp14 = opj_tcd_dc_level_shift_encode(p_tcd);
    }
#line 1213
    if (! __cil_tmp14) {
#line 1214
      return (0);
    }
    {
#line 1219
    __cil_tmp15 = opj_tcd_mct_encode(p_tcd);
    }
#line 1219
    if (! __cil_tmp15) {
#line 1220
      return (0);
    }
    {
#line 1225
    __cil_tmp16 = opj_tcd_dwt_encode(p_tcd);
    }
#line 1225
    if (! __cil_tmp16) {
#line 1226
      return (0);
    }
    {
#line 1231
    __cil_tmp17 = opj_tcd_t1_encode(p_tcd);
    }
#line 1231
    if (! __cil_tmp17) {
#line 1232
      return (0);
    }
    {
#line 1237
    __cil_tmp18 = opj_tcd_rate_allocate_encode(p_tcd, p_dest, p_max_length, p_cstr_info);
    }
#line 1237
    if (! __cil_tmp18) {
#line 1238
      return (0);
    }
  }
#line 1246
  if (p_cstr_info) {
#line 1247
    p_cstr_info->index_write = 1;
  }
  {
#line 1251
  __cil_tmp19 = opj_tcd_t2_encode(p_tcd, p_dest, p_data_written, p_max_length, p_cstr_info);
  }
#line 1251
  if (! __cil_tmp19) {
#line 1252
    return (0);
  }
#line 1258
  return (1);
}
}
#line 1261 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_decode_tile(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_UINT32 p_max_length ,
                             OPJ_UINT32 p_tile_no , opj_codestream_index_t *p_cstr_index ) 
{ 
  OPJ_UINT32 l_data_read ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 1269
  p_tcd->tcd_tileno = p_tile_no;
#line 1270
  p_tcd->tcp = (p_tcd->cp)->tcps + p_tile_no;
#line 1297
  l_data_read = (OPJ_UINT32 )0;
#line 1298
  __cil_tmp7 = opj_tcd_t2_decode(p_tcd, p_src, & l_data_read, p_max_length, p_cstr_index);
  }
#line 1298
  if (! __cil_tmp7) {
#line 1300
    return (0);
  }
  {
#line 1307
  __cil_tmp8 = opj_tcd_t1_decode(p_tcd);
  }
#line 1307
  if (! __cil_tmp8) {
#line 1310
    return (0);
  }
  {
#line 1317
  __cil_tmp9 = opj_tcd_dwt_decode(p_tcd);
  }
#line 1317
  if (! __cil_tmp9) {
#line 1320
    return (0);
  }
  {
#line 1326
  __cil_tmp10 = opj_tcd_mct_decode(p_tcd);
  }
#line 1326
  if (! __cil_tmp10) {
#line 1329
    return (0);
  }
  {
#line 1334
  __cil_tmp11 = opj_tcd_dc_level_shift_decode(p_tcd);
  }
#line 1334
  if (! __cil_tmp11) {
#line 1337
    return (0);
  }
#line 1343
  return (1);
}
}
#line 1346 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_update_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest , OPJ_UINT32 p_dest_length ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_tcd_resolution_t *l_res ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_UINT32 l_stride ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_CHAR *l_dest_ptr ;
  OPJ_INT32 *l_src_ptr ;
  OPJ_CHAR *__cil_tmp19 ;
  OPJ_INT32 *__cil_tmp20 ;
  OPJ_CHAR *__cil_tmp21 ;
  OPJ_INT32 *__cil_tmp22 ;
  OPJ_INT32 *l_src_ptr___0 ;
  OPJ_INT16 *l_dest_ptr___0 ;
  OPJ_INT16 *__cil_tmp25 ;
  OPJ_INT32 *__cil_tmp26 ;
  OPJ_INT16 *__cil_tmp27 ;
  OPJ_INT32 *__cil_tmp28 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *l_src_ptr___1 ;
  OPJ_INT32 *__cil_tmp31 ;
  OPJ_INT32 *__cil_tmp32 ;

  {
  {
#line 1351
  l_data_size = (OPJ_UINT32 )0;
#line 1352
  l_img_comp = (opj_image_comp_t *)0;
#line 1353
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 1358
  l_data_size = opj_tcd_get_decoded_tile_size(p_tcd);
  }
#line 1359
  if (l_data_size > p_dest_length) {
#line 1360
    return (0);
  }
#line 1363
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 1364
  l_img_comp = (p_tcd->image)->comps;
#line 1366
  i = (OPJ_UINT32 )0;
  {
#line 1366
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1366
    if (! (i < (p_tcd->image)->numcomps)) {
#line 1366
      goto while_break;
    }
#line 1367
    l_size_comp = l_img_comp->prec >> 3;
#line 1368
    l_remaining = l_img_comp->prec & 7U;
#line 1369
    l_res = l_tilec->resolutions + l_img_comp->resno_decoded;
#line 1370
    l_width = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 1371
    l_height = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
#line 1372
    l_stride = (OPJ_UINT32 )(l_tilec->x1 - l_tilec->x0) - l_width;
#line 1374
    if (l_remaining) {
#line 1375
      l_size_comp ++;
    }
#line 1378
    if (l_size_comp == 3U) {
#line 1379
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 1384
    if (l_size_comp == 1U) {
#line 1384
      goto case_1;
    }
#line 1409
    if (l_size_comp == 2U) {
#line 1409
      goto case_2;
    }
#line 1434
    if (l_size_comp == 4U) {
#line 1434
      goto case_4;
    }
#line 1382
    goto switch_break;
    case_1: 
#line 1386
    l_dest_ptr = (OPJ_CHAR *)p_dest;
#line 1387
    l_src_ptr = l_tilec->data;
#line 1389
    if (l_img_comp->sgnd) {
#line 1390
      j = (OPJ_UINT32 )0;
      {
#line 1390
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1390
        if (! (j < l_height)) {
#line 1390
          goto while_break___0;
        }
#line 1391
        k = (OPJ_UINT32 )0;
        {
#line 1391
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1391
          if (! (k < l_width)) {
#line 1391
            goto while_break___1;
          }
#line 1392
          __cil_tmp20 = l_src_ptr;
#line 1392
          l_src_ptr ++;
#line 1392
          __cil_tmp19 = l_dest_ptr;
#line 1392
          l_dest_ptr ++;
#line 1392
          *__cil_tmp19 = (OPJ_CHAR )*__cil_tmp20;
#line 1391
          k ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___1: 
#line 1394
        l_src_ptr += l_stride;
#line 1390
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 1398
      j = (OPJ_UINT32 )0;
      {
#line 1398
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1398
        if (! (j < l_height)) {
#line 1398
          goto while_break___2;
        }
#line 1399
        k = (OPJ_UINT32 )0;
        {
#line 1399
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1399
          if (! (k < l_width)) {
#line 1399
            goto while_break___3;
          }
#line 1400
          __cil_tmp22 = l_src_ptr;
#line 1400
          l_src_ptr ++;
#line 1400
          __cil_tmp21 = l_dest_ptr;
#line 1400
          l_dest_ptr ++;
#line 1400
          *__cil_tmp21 = (OPJ_CHAR )(*__cil_tmp22 & 255);
#line 1399
          k ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___3: 
#line 1402
        l_src_ptr += l_stride;
#line 1398
        j ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___2: ;
    }
#line 1406
    p_dest = (OPJ_BYTE *)l_dest_ptr;
#line 1408
    goto switch_break;
    case_2: 
#line 1411
    l_src_ptr___0 = l_tilec->data;
#line 1412
    l_dest_ptr___0 = (OPJ_INT16 *)p_dest;
#line 1414
    if (l_img_comp->sgnd) {
#line 1415
      j = (OPJ_UINT32 )0;
      {
#line 1415
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1415
        if (! (j < l_height)) {
#line 1415
          goto while_break___4;
        }
#line 1416
        k = (OPJ_UINT32 )0;
        {
#line 1416
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 1416
          if (! (k < l_width)) {
#line 1416
            goto while_break___5;
          }
#line 1417
          __cil_tmp26 = l_src_ptr___0;
#line 1417
          l_src_ptr___0 ++;
#line 1417
          __cil_tmp25 = l_dest_ptr___0;
#line 1417
          l_dest_ptr___0 ++;
#line 1417
          *__cil_tmp25 = (OPJ_INT16 )*__cil_tmp26;
#line 1416
          k ++;
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___5: 
#line 1419
        l_src_ptr___0 += l_stride;
#line 1415
        j ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___4: ;
    } else {
#line 1423
      j = (OPJ_UINT32 )0;
      {
#line 1423
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 1423
        if (! (j < l_height)) {
#line 1423
          goto while_break___6;
        }
#line 1424
        k = (OPJ_UINT32 )0;
        {
#line 1424
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 1424
          if (! (k < l_width)) {
#line 1424
            goto while_break___7;
          }
#line 1425
          __cil_tmp28 = l_src_ptr___0;
#line 1425
          l_src_ptr___0 ++;
#line 1425
          __cil_tmp27 = l_dest_ptr___0;
#line 1425
          l_dest_ptr___0 ++;
#line 1425
          *__cil_tmp27 = (OPJ_INT16 )(*__cil_tmp28 & 65535);
#line 1424
          k ++;
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___7: 
#line 1427
        l_src_ptr___0 += l_stride;
#line 1423
        j ++;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___6: ;
    }
#line 1431
    p_dest = (OPJ_BYTE *)l_dest_ptr___0;
#line 1433
    goto switch_break;
    case_4: 
#line 1436
    l_dest_ptr___1 = (OPJ_INT32 *)p_dest;
#line 1437
    l_src_ptr___1 = l_tilec->data;
#line 1439
    j = (OPJ_UINT32 )0;
    {
#line 1439
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 1439
      if (! (j < l_height)) {
#line 1439
        goto while_break___8;
      }
#line 1440
      k = (OPJ_UINT32 )0;
      {
#line 1440
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 1440
        if (! (k < l_width)) {
#line 1440
          goto while_break___9;
        }
#line 1441
        __cil_tmp32 = l_src_ptr___1;
#line 1441
        l_src_ptr___1 ++;
#line 1441
        __cil_tmp31 = l_dest_ptr___1;
#line 1441
        l_dest_ptr___1 ++;
#line 1441
        *__cil_tmp31 = *__cil_tmp32;
#line 1440
        k ++;
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___9: 
#line 1443
      l_src_ptr___1 += l_stride;
#line 1439
      j ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___8: 
#line 1446
    p_dest = (OPJ_BYTE *)l_dest_ptr___1;
#line 1448
    goto switch_break;
    switch_break: 
#line 1451
    l_img_comp ++;
#line 1452
    l_tilec ++;
#line 1366
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break: ;
#line 1455
  return (1);
}
}
#line 1461 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
void opj_tcd_free_tile(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_band_t *l_band ;
  opj_tcd_precinct_t *l_precinct ;
  OPJ_UINT32 l_nb_resolutions ;
  OPJ_UINT32 l_nb_precincts ;
  void (*l_tcd_code_block_deallocate)(opj_tcd_precinct_t * ) ;

  {
#line 1464
  l_tile = (opj_tcd_tile_t *)0;
#line 1465
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1466
  l_res = (opj_tcd_resolution_t *)0;
#line 1467
  l_band = (opj_tcd_band_t *)0;
#line 1468
  l_precinct = (opj_tcd_precinct_t *)0;
#line 1470
  l_tcd_code_block_deallocate = (void (*)(opj_tcd_precinct_t * ))0;
#line 1472
  if (! p_tcd) {
#line 1473
    return;
  }
#line 1476
  if (! p_tcd->tcd_image) {
#line 1477
    return;
  }
#line 1480
  if (p_tcd->m_is_decoder) {
#line 1481
    l_tcd_code_block_deallocate = & opj_tcd_code_block_dec_deallocate;
  } else {
#line 1484
    l_tcd_code_block_deallocate = & opj_tcd_code_block_enc_deallocate;
  }
#line 1487
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1488
  if (! l_tile) {
#line 1489
    return;
  }
#line 1492
  l_tile_comp = l_tile->comps;
#line 1494
  compno = (OPJ_UINT32 )0;
  {
#line 1494
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1494
    if (! (compno < l_tile->numcomps)) {
#line 1494
      goto while_break;
    }
#line 1495
    l_res = l_tile_comp->resolutions;
#line 1496
    if (l_res) {
#line 1498
      l_nb_resolutions = (OPJ_UINT32 )((unsigned long )l_tile_comp->resolutions_size / sizeof(opj_tcd_resolution_t ));
#line 1499
      resno = (OPJ_UINT32 )0;
      {
#line 1499
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1499
        if (! (resno < l_nb_resolutions)) {
#line 1499
          goto while_break___0;
        }
#line 1500
        l_band = l_res->bands;
#line 1501
        bandno = (OPJ_UINT32 )0;
        {
#line 1501
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1501
          if (! (bandno < 3U)) {
#line 1501
            goto while_break___1;
          }
#line 1502
          l_precinct = l_band->precincts;
#line 1503
          if (l_precinct) {
#line 1505
            l_nb_precincts = (OPJ_UINT32 )((unsigned long )l_band->precincts_data_size / sizeof(opj_tcd_precinct_t ));
#line 1506
            precno = (OPJ_UINT32 )0;
            {
#line 1506
            while (1) {
              while_continue___2: /* CIL Label */ ;

#line 1506
              if (! (precno < l_nb_precincts)) {
#line 1506
                goto while_break___2;
              }
              {
#line 1507
              opj_tgt_destroy(l_precinct->incltree);
#line 1508
              l_precinct->incltree = (opj_tgt_tree_t *)0;
#line 1509
              opj_tgt_destroy(l_precinct->imsbtree);
#line 1510
              l_precinct->imsbtree = (opj_tgt_tree_t *)0;
#line 1511
              (*l_tcd_code_block_deallocate)(l_precinct);
#line 1512
              l_precinct ++;
#line 1506
              precno ++;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
            while_break___2: 
            {
#line 1515
            free((void *)l_band->precincts);
#line 1516
            l_band->precincts = (opj_tcd_precinct_t *)0;
            }
          }
#line 1518
          l_band ++;
#line 1501
          bandno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: 
#line 1520
        l_res ++;
#line 1499
        resno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: 
      {
#line 1523
      free((void *)l_tile_comp->resolutions);
#line 1524
      l_tile_comp->resolutions = (opj_tcd_resolution_t *)0;
      }
    }
#line 1527
    if (l_tile_comp->data) {
#line 1527
      if (l_tile_comp->ownsData) {
        {
#line 1528
        free((void *)l_tile_comp->data);
#line 1529
        l_tile_comp->data = (OPJ_INT32 *)0;
#line 1530
        l_tile_comp->ownsData = 0;
#line 1531
        l_tile_comp->data_size = (OPJ_UINT32 )0;
#line 1532
        l_tile_comp->data_size_needed = (OPJ_UINT32 )0;
        }
      }
    }
#line 1534
    l_tile_comp ++;
#line 1494
    compno ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1537
  free((void *)l_tile->comps);
#line 1538
  l_tile->comps = (opj_tcd_tilecomp_t *)0;
#line 1539
  free((void *)(p_tcd->tcd_image)->tiles);
#line 1540
  (p_tcd->tcd_image)->tiles = (opj_tcd_tile_t *)0;
  }
#line 1542
  return;
}
}
#line 1544 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd , OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                           OPJ_UINT32 p_max_src_size , opj_codestream_index_t *p_cstr_index ) 
{ 
  opj_t2_t *l_t2 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1553
  l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);
  }
#line 1554
  if ((unsigned long )l_t2 == (unsigned long )((opj_t2_t *)0)) {
#line 1555
    return (0);
  }
  {
#line 1558
  __cil_tmp8 = opj_t2_decode_packets(l_t2, p_tcd->tcd_tileno, (p_tcd->tcd_image)->tiles,
                                     p_src_data, p_data_read, p_max_src_size, p_cstr_index);
  }
#line 1558
  if (! __cil_tmp8) {
    {
#line 1566
    opj_t2_destroy(l_t2);
    }
#line 1567
    return (0);
  }
  {
#line 1570
  opj_t2_destroy(l_t2);
  }
#line 1573
  return (1);
}
}
#line 1576 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_t1_t *l_t1 ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1580
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1581
  l_tile_comp = l_tile->comps;
#line 1582
  l_tccp = (p_tcd->tcp)->tccps;
#line 1585
  l_t1 = opj_t1_create(0);
  }
#line 1586
  if ((unsigned long )l_t1 == (unsigned long )((opj_t1_t *)0)) {
#line 1587
    return (0);
  }
#line 1590
  compno = (OPJ_UINT32 )0;
  {
#line 1590
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1590
    if (! (compno < l_tile->numcomps)) {
#line 1590
      goto while_break;
    }
    {
#line 1592
    __cil_tmp8 = opj_t1_decode_cblks(l_t1, l_tile_comp, l_tccp);
    }
#line 1592
    if (0 == __cil_tmp8) {
      {
#line 1593
      opj_t1_destroy(l_t1);
      }
#line 1594
      return (0);
    }
#line 1596
    l_tile_comp ++;
#line 1597
    l_tccp ++;
#line 1590
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1600
  opj_t1_destroy(l_t1);
  }
#line 1602
  return (1);
}
}
#line 1606 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 1609
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1610
  l_tile_comp = l_tile->comps;
#line 1611
  l_tccp = (p_tcd->tcp)->tccps;
#line 1612
  l_img_comp = (p_tcd->image)->comps;
#line 1614
  compno = (OPJ_UINT32 )0;
  {
#line 1614
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1614
    if (! (compno < l_tile->numcomps)) {
#line 1614
      goto while_break;
    }
#line 1628
    if (l_tccp->qmfbid == 1U) {
      {
#line 1629
      __cil_tmp7 = opj_dwt_decode(l_tile_comp, l_img_comp->resno_decoded + 1U);
      }
#line 1629
      if (! __cil_tmp7) {
#line 1630
        return (0);
      }
    } else {
      {
#line 1634
      __cil_tmp8 = opj_dwt_decode_real(l_tile_comp, l_img_comp->resno_decoded + 1U);
      }
#line 1634
      if (! __cil_tmp8) {
#line 1635
        return (0);
      }
    }
#line 1639
    l_tile_comp ++;
#line 1640
    l_img_comp ++;
#line 1641
    l_tccp ++;
#line 1614
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1644
  return (1);
}
}
#line 1646 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcp_t *l_tcp ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  OPJ_UINT32 l_samples ;
  OPJ_UINT32 i ;
  OPJ_BYTE **l_data ;
  void *__cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 1648
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1649
  l_tcp = p_tcd->tcp;
#line 1650
  l_tile_comp = l_tile->comps;
#line 1653
  if (! l_tcp->mct) {
#line 1654
    return (1);
  }
#line 1657
  l_samples = (OPJ_UINT32 )((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));
#line 1659
  if (l_tile->numcomps >= 3U) {
#line 1661
    if (((l_tile->comps + 0)->x1 - (l_tile->comps + 0)->x0) * ((l_tile->comps + 0)->y1 - (l_tile->comps + 0)->y0) < (OPJ_INT32 )l_samples) {
      {
#line 1664
      fprintf(stderr, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
      }
#line 1665
      return (0);
    } else
#line 1661
    if (((l_tile->comps + 1)->x1 - (l_tile->comps + 1)->x0) * ((l_tile->comps + 1)->y1 - (l_tile->comps + 1)->y0) < (OPJ_INT32 )l_samples) {
      {
#line 1664
      fprintf(stderr, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
      }
#line 1665
      return (0);
    } else
#line 1661
    if (((l_tile->comps + 2)->x1 - (l_tile->comps + 2)->x0) * ((l_tile->comps + 2)->y1 - (l_tile->comps + 2)->y0) < (OPJ_INT32 )l_samples) {
      {
#line 1664
      fprintf(stderr, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
      }
#line 1665
      return (0);
    } else
#line 1667
    if (l_tcp->mct == 2U) {
#line 1670
      if (! l_tcp->m_mct_decoding_matrix) {
#line 1671
        return (1);
      }
      {
#line 1674
      __cil_tmp8 = malloc((unsigned long )l_tile->numcomps * sizeof(OPJ_BYTE *));
#line 1674
      l_data = (OPJ_BYTE **)__cil_tmp8;
      }
#line 1675
      if (! l_data) {
#line 1676
        return (0);
      }
#line 1679
      i = (OPJ_UINT32 )0;
      {
#line 1679
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1679
        if (! (i < l_tile->numcomps)) {
#line 1679
          goto while_break;
        }
#line 1680
        *(l_data + i) = (OPJ_BYTE *)l_tile_comp->data;
#line 1681
        l_tile_comp ++;
#line 1679
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 1684
      __cil_tmp9 = opj_mct_decode_custom((OPJ_BYTE *)l_tcp->m_mct_decoding_matrix,
                                         l_samples, l_data, l_tile->numcomps, ((p_tcd->image)->comps)->sgnd);
      }
#line 1684
      if (! __cil_tmp9) {
        {
#line 1694
        free((void *)l_data);
        }
#line 1695
        return (0);
      }
      {
#line 1698
      free((void *)l_data);
      }
    } else
#line 1701
    if ((l_tcp->tccps)->qmfbid == 1U) {
      {
#line 1702
      opj_mct_decode((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                     l_samples);
      }
    } else {
      {
#line 1708
      opj_mct_decode_real((OPJ_FLOAT32 *)(l_tile->comps + 0)->data, (OPJ_FLOAT32 *)(l_tile->comps + 1)->data,
                          (OPJ_FLOAT32 *)(l_tile->comps + 2)->data, l_samples);
      }
    }
  } else {
    {
#line 1717
    fprintf(stderr, "Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\n",
            l_tile->numcomps);
    }
  }
#line 1720
  return (1);
}
}
#line 1724 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_tile_t *l_tile ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_INT32 *l_current_ptr ;
  OPJ_INT32 l_min ;
  OPJ_INT32 l_max ;
  OPJ_UINT32 l_stride ;
  OPJ_FLOAT32 l_value ;
  long __cil_tmp19 ;
  OPJ_INT32 __cil_tmp20 ;

  {
#line 1727
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1728
  l_tccp = (opj_tccp_t *)0;
#line 1729
  l_img_comp = (opj_image_comp_t *)0;
#line 1730
  l_res = (opj_tcd_resolution_t *)0;
#line 1737
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1738
  l_tile_comp = l_tile->comps;
#line 1739
  l_tccp = (p_tcd->tcp)->tccps;
#line 1740
  l_img_comp = (p_tcd->image)->comps;
#line 1742
  compno = (OPJ_UINT32 )0;
  {
#line 1742
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1742
    if (! (compno < l_tile->numcomps)) {
#line 1742
      goto while_break;
    }
#line 1743
    l_res = l_tile_comp->resolutions + l_img_comp->resno_decoded;
#line 1744
    l_width = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 1745
    l_height = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
#line 1746
    l_stride = (OPJ_UINT32 )(l_tile_comp->x1 - l_tile_comp->x0) - l_width;
#line 1750
    if (l_img_comp->sgnd) {
#line 1751
      l_min = - (1 << (l_img_comp->prec - 1U));
#line 1752
      l_max = (1 << (l_img_comp->prec - 1U)) - 1;
    } else {
#line 1755
      l_min = 0;
#line 1756
      l_max = (1 << l_img_comp->prec) - 1;
    }
#line 1759
    l_current_ptr = l_tile_comp->data;
#line 1761
    if (l_tccp->qmfbid == 1U) {
#line 1762
      j = (OPJ_UINT32 )0;
      {
#line 1762
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1762
        if (! (j < l_height)) {
#line 1762
          goto while_break___0;
        }
#line 1763
        i = (OPJ_UINT32 )0;
        {
#line 1763
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1763
          if (! (i < l_width)) {
#line 1763
            goto while_break___1;
          }
          {
#line 1764
          *l_current_ptr = opj_int_clamp(*l_current_ptr + l_tccp->m_dc_level_shift,
                                         l_min, l_max);
#line 1765
          l_current_ptr ++;
#line 1763
          i ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: 
#line 1767
        l_current_ptr += l_stride;
#line 1762
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 1771
      j = (OPJ_UINT32 )0;
      {
#line 1771
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1771
        if (! (j < l_height)) {
#line 1771
          goto while_break___2;
        }
#line 1772
        i = (OPJ_UINT32 )0;
        {
#line 1772
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1772
          if (! (i < l_width)) {
#line 1772
            goto while_break___3;
          }
          {
#line 1773
          l_value = *((OPJ_FLOAT32 *)l_current_ptr);
#line 1774
          __cil_tmp19 = lrintf(l_value);
#line 1774
          __cil_tmp20 = opj_int_clamp((OPJ_INT32 )__cil_tmp19 + l_tccp->m_dc_level_shift,
                                      l_min, l_max);
#line 1774
          *l_current_ptr = __cil_tmp20;
#line 1775
          l_current_ptr ++;
#line 1772
          i ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: 
#line 1777
        l_current_ptr += l_stride;
#line 1771
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: ;
    }
#line 1781
    l_img_comp ++;
#line 1782
    l_tccp ++;
#line 1783
    l_tile_comp ++;
#line 1742
    compno ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 1786
  return (1);
}
}
#line 1794 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t *p_precinct ) 
{ 
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_cblk_dec_t *l_code_block ;

  {
#line 1798
  l_code_block = p_precinct->cblks.dec;
#line 1799
  if (l_code_block) {
#line 1806
    l_nb_code_blocks = (OPJ_UINT32 )((unsigned long )p_precinct->block_size / sizeof(opj_tcd_cblk_dec_t ));
#line 1809
    cblkno = (OPJ_UINT32 )0;
    {
#line 1809
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1809
      if (! (cblkno < l_nb_code_blocks)) {
#line 1809
        goto while_break;
      }
#line 1811
      if (l_code_block->data) {
        {
#line 1812
        free((void *)l_code_block->data);
#line 1813
        l_code_block->data = (OPJ_BYTE *)0;
        }
      }
#line 1816
      if (l_code_block->segs) {
        {
#line 1817
        free((void *)l_code_block->segs);
#line 1818
        l_code_block->segs = (opj_tcd_seg_t *)0;
        }
      }
#line 1821
      l_code_block ++;
#line 1809
      cblkno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 1824
    free((void *)p_precinct->cblks.dec);
#line 1825
    p_precinct->cblks.dec = (opj_tcd_cblk_dec_t *)0;
    }
  }
#line 1828
  return;
}
}
#line 1832 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t *p_precinct ) 
{ 
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_cblk_enc_t *l_code_block ;

  {
#line 1836
  l_code_block = p_precinct->cblks.enc;
#line 1837
  if (l_code_block) {
#line 1838
    l_nb_code_blocks = (OPJ_UINT32 )((unsigned long )p_precinct->block_size / sizeof(opj_tcd_cblk_enc_t ));
#line 1840
    cblkno = (OPJ_UINT32 )0;
    {
#line 1840
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1840
      if (! (cblkno < l_nb_code_blocks)) {
#line 1840
        goto while_break;
      }
#line 1841
      if (l_code_block->data) {
        {
#line 1842
        free((void *)(l_code_block->data - 1));
#line 1843
        l_code_block->data = (OPJ_BYTE *)0;
        }
      }
#line 1846
      if (l_code_block->layers) {
        {
#line 1847
        free((void *)l_code_block->layers);
#line 1848
        l_code_block->layers = (opj_tcd_layer_t *)0;
        }
      }
#line 1851
      if (l_code_block->passes) {
        {
#line 1852
        free((void *)l_code_block->passes);
#line 1853
        l_code_block->passes = (opj_tcd_pass_t *)0;
        }
      }
#line 1855
      l_code_block ++;
#line 1840
      cblkno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 1858
    free((void *)p_precinct->cblks.enc);
#line 1860
    p_precinct->cblks.enc = (opj_tcd_cblk_enc_t *)0;
    }
  }
#line 1863
  return;
}
}
#line 1864 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_UINT32 opj_tcd_get_encoded_tile_size(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;

  {
#line 1866
  l_data_size = (OPJ_UINT32 )0;
#line 1867
  l_img_comp = (opj_image_comp_t *)0;
#line 1868
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 1871
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 1872
  l_img_comp = (p_tcd->image)->comps;
#line 1873
  i = (OPJ_UINT32 )0;
  {
#line 1873
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1873
    if (! (i < (p_tcd->image)->numcomps)) {
#line 1873
      goto while_break;
    }
#line 1874
    l_size_comp = l_img_comp->prec >> 3;
#line 1875
    l_remaining = l_img_comp->prec & 7U;
#line 1877
    if (l_remaining) {
#line 1878
      l_size_comp ++;
    }
#line 1881
    if (l_size_comp == 3U) {
#line 1882
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 1885
    l_data_size += l_size_comp * (OPJ_UINT32 )((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0));
#line 1886
    l_img_comp ++;
#line 1887
    l_tilec ++;
#line 1873
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1890
  return (l_data_size);
}
}
#line 1893 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tile_t *l_tile ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_UINT32 i ;
  OPJ_INT32 *l_current_ptr ;

  {
#line 1896
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1897
  l_tccp = (opj_tccp_t *)0;
#line 1898
  l_img_comp = (opj_image_comp_t *)0;
#line 1903
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1904
  l_tile_comp = l_tile->comps;
#line 1905
  l_tccp = (p_tcd->tcp)->tccps;
#line 1906
  l_img_comp = (p_tcd->image)->comps;
#line 1908
  compno = (OPJ_UINT32 )0;
  {
#line 1908
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1908
    if (! (compno < l_tile->numcomps)) {
#line 1908
      goto while_break;
    }
#line 1909
    l_current_ptr = l_tile_comp->data;
#line 1910
    l_nb_elem = (OPJ_UINT32 )((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));
#line 1912
    if (l_tccp->qmfbid == 1U) {
#line 1913
      i = (OPJ_UINT32 )0;
      {
#line 1913
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1913
        if (! (i < l_nb_elem)) {
#line 1913
          goto while_break___0;
        }
#line 1914
        *l_current_ptr -= l_tccp->m_dc_level_shift;
#line 1915
        l_current_ptr ++;
#line 1913
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 1919
      i = (OPJ_UINT32 )0;
      {
#line 1919
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1919
        if (! (i < l_nb_elem)) {
#line 1919
          goto while_break___1;
        }
#line 1920
        *l_current_ptr = (*l_current_ptr - l_tccp->m_dc_level_shift) << 11;
#line 1921
        l_current_ptr ++;
#line 1919
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
    }
#line 1925
    l_img_comp ++;
#line 1926
    l_tccp ++;
#line 1927
    l_tile_comp ++;
#line 1908
    compno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 1930
  return (1);
}
}
#line 1933 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  OPJ_UINT32 samples ;
  OPJ_UINT32 i ;
  OPJ_BYTE **l_data ;
  opj_tcp_t *l_tcp ;
  void *__cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 1935
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1936
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 1937
  samples = (OPJ_UINT32 )((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));
#line 1939
  l_data = (OPJ_BYTE **)0;
#line 1940
  l_tcp = p_tcd->tcp;
#line 1942
  if (! (p_tcd->tcp)->mct) {
#line 1943
    return (1);
  }
#line 1946
  if ((p_tcd->tcp)->mct == 2U) {
#line 1947
    if (! (p_tcd->tcp)->m_mct_coding_matrix) {
#line 1948
      return (1);
    }
    {
#line 1951
    __cil_tmp8 = malloc((unsigned long )l_tile->numcomps * sizeof(OPJ_BYTE *));
#line 1951
    l_data = (OPJ_BYTE **)__cil_tmp8;
    }
#line 1952
    if (! l_data) {
#line 1953
      return (0);
    }
#line 1956
    i = (OPJ_UINT32 )0;
    {
#line 1956
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1956
      if (! (i < l_tile->numcomps)) {
#line 1956
        goto while_break;
      }
#line 1957
      *(l_data + i) = (OPJ_BYTE *)l_tile_comp->data;
#line 1958
      l_tile_comp ++;
#line 1956
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 1961
    __cil_tmp9 = opj_mct_encode_custom((OPJ_BYTE *)(p_tcd->tcp)->m_mct_coding_matrix,
                                       samples, l_data, l_tile->numcomps, ((p_tcd->image)->comps)->sgnd);
    }
#line 1961
    if (! __cil_tmp9) {
      {
#line 1972
      free((void *)l_data);
      }
#line 1973
      return (0);
    }
    {
#line 1976
    free((void *)l_data);
    }
  } else
#line 1978
  if ((l_tcp->tccps)->qmfbid == 0U) {
    {
#line 1979
    opj_mct_encode_real((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                        samples);
    }
  } else {
    {
#line 1982
    opj_mct_encode((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                   samples);
    }
  }
#line 1985
  return (1);
}
}
#line 1988 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 1990
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1991
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 1992
  l_tccp = (p_tcd->tcp)->tccps;
#line 1995
  compno = (OPJ_UINT32 )0;
  {
#line 1995
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1995
    if (! (compno < l_tile->numcomps)) {
#line 1995
      goto while_break;
    }
#line 1996
    if (l_tccp->qmfbid == 1U) {
      {
#line 1997
      __cil_tmp6 = opj_dwt_encode(l_tile_comp);
      }
#line 1997
      if (! __cil_tmp6) {
#line 1998
        return (0);
      }
    } else
#line 2001
    if (l_tccp->qmfbid == 0U) {
      {
#line 2002
      __cil_tmp7 = opj_dwt_encode_real(l_tile_comp);
      }
#line 2002
      if (! __cil_tmp7) {
#line 2003
        return (0);
      }
    }
#line 2007
    l_tile_comp ++;
#line 2008
    l_tccp ++;
#line 1995
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2011
  return (1);
}
}
#line 2014 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_t1_t *l_t1 ;
  OPJ_FLOAT64 *l_mct_norms ;
  OPJ_UINT32 l_mct_numcomps ;
  opj_tcp_t *l_tcp ;
  OPJ_BOOL __cil_tmp9 ;

  {
  {
#line 2018
  l_mct_numcomps = 0U;
#line 2019
  l_tcp = p_tcd->tcp;
#line 2021
  l_t1 = opj_t1_create(1);
  }
#line 2022
  if ((unsigned long )l_t1 == (unsigned long )((opj_t1_t *)0)) {
#line 2023
    return (0);
  }
#line 2026
  if (l_tcp->mct == 1U) {
#line 2027
    l_mct_numcomps = 3U;
#line 2029
    if ((l_tcp->tccps)->qmfbid == 0U) {
      {
#line 2030
      l_mct_norms = opj_mct_get_mct_norms_real();
      }
    } else {
      {
#line 2033
      l_mct_norms = opj_mct_get_mct_norms();
      }
    }
  } else {
#line 2037
    l_mct_numcomps = (p_tcd->image)->numcomps;
#line 2038
    l_mct_norms = l_tcp->mct_norms;
  }
  {
#line 2041
  __cil_tmp9 = opj_t1_encode_cblks(l_t1, (p_tcd->tcd_image)->tiles, l_tcp, l_mct_norms,
                                   l_mct_numcomps);
  }
#line 2041
  if (! __cil_tmp9) {
    {
#line 2042
    opj_t1_destroy(l_t1);
    }
#line 2043
    return (0);
  }
  {
#line 2046
  opj_t1_destroy(l_t1);
  }
#line 2048
  return (1);
}
}
#line 2051 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 *p_data_written ,
                           OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ) 
{ 
  opj_t2_t *l_t2 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 2059
  l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);
  }
#line 2060
  if ((unsigned long )l_t2 == (unsigned long )((opj_t2_t *)0)) {
#line 2061
    return (0);
  }
  {
#line 2064
  __cil_tmp8 = opj_t2_encode_packets(l_t2, p_tcd->tcd_tileno, (p_tcd->tcd_image)->tiles,
                                     (p_tcd->tcp)->numlayers, p_dest_data, p_data_written,
                                     p_max_dest_size, p_cstr_info, p_tcd->tp_num,
                                     p_tcd->tp_pos, p_tcd->cur_pino, (J2K_T2_MODE )1);
  }
#line 2064
  if (! __cil_tmp8) {
    {
#line 2078
    opj_t2_destroy(l_t2);
    }
#line 2079
    return (0);
  }
  {
#line 2082
  opj_t2_destroy(l_t2);
  }
#line 2085
  return (1);
}
}
#line 2089 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 p_max_dest_size ,
                                      opj_codestream_info_t *p_cstr_info ) 
{ 
  opj_cp_t *l_cp ;
  OPJ_UINT32 l_nb_written ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 2094
  l_cp = p_tcd->cp;
#line 2095
  l_nb_written = (OPJ_UINT32 )0;
#line 2097
  if (p_cstr_info) {
#line 2098
    p_cstr_info->index_write = 0;
  }
#line 2101
  if ((int )l_cp->m_specific_param.m_enc.m_disto_alloc) {
    _L: 
    {
#line 2104
    __cil_tmp7 = opj_tcd_rateallocate(p_tcd, p_dest_data, & l_nb_written, p_max_dest_size,
                                      p_cstr_info);
    }
#line 2104
    if (! __cil_tmp7) {
#line 2105
      return (0);
    }
  } else
#line 2101
  if ((int )l_cp->m_specific_param.m_enc.m_fixed_quality) {
#line 2101
    goto _L;
  } else {
    {
#line 2110
    opj_tcd_rateallocate_fixed(p_tcd);
    }
  }
#line 2113
  return (1);
}
}
#line 2117 "/root/patchweave_new/10/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_copy_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_UINT32 p_src_length ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_CHAR *l_src_ptr ;
  OPJ_INT32 *l_dest_ptr ;
  OPJ_INT32 *__cil_tmp15 ;
  OPJ_CHAR *__cil_tmp16 ;
  OPJ_INT32 *__cil_tmp17 ;
  OPJ_CHAR *__cil_tmp18 ;
  OPJ_INT32 *l_dest_ptr___0 ;
  OPJ_INT16 *l_src_ptr___0 ;
  OPJ_INT32 *__cil_tmp21 ;
  OPJ_INT16 *__cil_tmp22 ;
  OPJ_INT32 *__cil_tmp23 ;
  OPJ_INT16 *__cil_tmp24 ;
  OPJ_INT32 *l_src_ptr___1 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *__cil_tmp27 ;
  OPJ_INT32 *__cil_tmp28 ;

  {
  {
#line 2121
  l_data_size = (OPJ_UINT32 )0;
#line 2122
  l_img_comp = (opj_image_comp_t *)0;
#line 2123
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 2127
  l_data_size = opj_tcd_get_encoded_tile_size(p_tcd);
  }
#line 2128
  if (l_data_size != p_src_length) {
#line 2129
    return (0);
  }
#line 2132
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 2133
  l_img_comp = (p_tcd->image)->comps;
#line 2134
  i = (OPJ_UINT32 )0;
  {
#line 2134
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2134
    if (! (i < (p_tcd->image)->numcomps)) {
#line 2134
      goto while_break;
    }
#line 2135
    l_size_comp = l_img_comp->prec >> 3;
#line 2136
    l_remaining = l_img_comp->prec & 7U;
#line 2137
    l_nb_elem = (OPJ_UINT32 )((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0));
#line 2139
    if (l_remaining) {
#line 2140
      l_size_comp ++;
    }
#line 2143
    if (l_size_comp == 3U) {
#line 2144
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 2148
    if (l_size_comp == 1U) {
#line 2148
      goto case_1;
    }
#line 2167
    if (l_size_comp == 2U) {
#line 2167
      goto case_2;
    }
#line 2186
    if (l_size_comp == 4U) {
#line 2186
      goto case_4;
    }
#line 2147
    goto switch_break;
    case_1: 
#line 2150
    l_src_ptr = (OPJ_CHAR *)p_src;
#line 2151
    l_dest_ptr = l_tilec->data;
#line 2153
    if (l_img_comp->sgnd) {
#line 2154
      j = (OPJ_UINT32 )0;
      {
#line 2154
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 2154
        if (! (j < l_nb_elem)) {
#line 2154
          goto while_break___0;
        }
#line 2155
        __cil_tmp16 = l_src_ptr;
#line 2155
        l_src_ptr ++;
#line 2155
        __cil_tmp15 = l_dest_ptr;
#line 2155
        l_dest_ptr ++;
#line 2155
        *__cil_tmp15 = (OPJ_INT32 )*__cil_tmp16;
#line 2154
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 2159
      j = (OPJ_UINT32 )0;
      {
#line 2159
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 2159
        if (! (j < l_nb_elem)) {
#line 2159
          goto while_break___1;
        }
#line 2160
        __cil_tmp18 = l_src_ptr;
#line 2160
        l_src_ptr ++;
#line 2160
        __cil_tmp17 = l_dest_ptr;
#line 2160
        l_dest_ptr ++;
#line 2160
        *__cil_tmp17 = (int )*__cil_tmp18 & 255;
#line 2159
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: ;
    }
#line 2164
    p_src = (OPJ_BYTE *)l_src_ptr;
#line 2166
    goto switch_break;
    case_2: 
#line 2169
    l_dest_ptr___0 = l_tilec->data;
#line 2170
    l_src_ptr___0 = (OPJ_INT16 *)p_src;
#line 2172
    if (l_img_comp->sgnd) {
#line 2173
      j = (OPJ_UINT32 )0;
      {
#line 2173
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 2173
        if (! (j < l_nb_elem)) {
#line 2173
          goto while_break___2;
        }
#line 2174
        __cil_tmp22 = l_src_ptr___0;
#line 2174
        l_src_ptr___0 ++;
#line 2174
        __cil_tmp21 = l_dest_ptr___0;
#line 2174
        l_dest_ptr___0 ++;
#line 2174
        *__cil_tmp21 = (OPJ_INT32 )*__cil_tmp22;
#line 2173
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: ;
    } else {
#line 2178
      j = (OPJ_UINT32 )0;
      {
#line 2178
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 2178
        if (! (j < l_nb_elem)) {
#line 2178
          goto while_break___3;
        }
#line 2179
        __cil_tmp24 = l_src_ptr___0;
#line 2179
        l_src_ptr___0 ++;
#line 2179
        __cil_tmp23 = l_dest_ptr___0;
#line 2179
        l_dest_ptr___0 ++;
#line 2179
        *__cil_tmp23 = (int )*__cil_tmp24 & 65535;
#line 2178
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: ;
    }
#line 2183
    p_src = (OPJ_BYTE *)l_src_ptr___0;
#line 2185
    goto switch_break;
    case_4: 
#line 2188
    l_src_ptr___1 = (OPJ_INT32 *)p_src;
#line 2189
    l_dest_ptr___1 = l_tilec->data;
#line 2191
    j = (OPJ_UINT32 )0;
    {
#line 2191
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 2191
      if (! (j < l_nb_elem)) {
#line 2191
        goto while_break___4;
      }
#line 2192
      __cil_tmp28 = l_src_ptr___1;
#line 2192
      l_src_ptr___1 ++;
#line 2192
      __cil_tmp27 = l_dest_ptr___1;
#line 2192
      l_dest_ptr___1 ++;
#line 2192
      *__cil_tmp27 = *__cil_tmp28;
#line 2191
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: 
#line 2195
    p_src = (OPJ_BYTE *)l_src_ptr___1;
#line 2197
    goto switch_break;
    switch_break: 
#line 2200
    l_img_comp ++;
#line 2201
    l_tilec ++;
#line 2134
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 2204
  return (1);
}
}
#line 48 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
static void opj_t2_putcommacode(opj_bio_t *bio , OPJ_INT32 n ) ;
#line 50
OPJ_UINT32 opj_t2_getcommacode(opj_bio_t *bio ) ;
#line 56
void opj_t2_putnumpasses(opj_bio_t *bio , OPJ_UINT32 n ) ;
#line 57
OPJ_UINT32 opj_t2_getnumpasses(opj_bio_t *bio ) ;
#line 71
OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                              opj_pi_iterator_t *pi , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 length , opj_codestream_info_t *cstr_info ) ;
#line 93
OPJ_BOOL opj_t2_decode_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                              opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                              OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) ;
#line 102
static OPJ_BOOL opj_t2_skip_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) ;
#line 111
OPJ_BOOL opj_t2_read_packet_header(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BOOL *p_is_data_present ,
                                   OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) ;
#line 121
OPJ_BOOL opj_t2_read_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_pi_iterator_t *p_pi ,
                                 OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                 OPJ_UINT32 p_max_length , opj_packet_info_t *pack_info ) ;
#line 129
OPJ_BOOL opj_t2_skip_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_pi_iterator_t *p_pi ,
                                 OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                 opj_packet_info_t *pack_info ) ;
#line 142
OPJ_BOOL opj_t2_init_seg(opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 index___0 , OPJ_UINT32 cblksty ,
                         OPJ_UINT32 first ) ;
#line 154 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
static void opj_t2_putcommacode(opj_bio_t *bio , OPJ_INT32 n ) 
{ 


  {
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    n --;
#line 155
    if (! (n >= 0)) {
#line 155
      goto while_break;
    }
    {
#line 156
    opj_bio_write(bio, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 158
  opj_bio_write(bio, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
  }
#line 160
  return;
}
}
#line 161 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
OPJ_UINT32 opj_t2_getcommacode(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 n ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 163
  n = (OPJ_UINT32 )0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 164
    __cil_tmp3 = opj_bio_read(bio, (OPJ_UINT32 )1);
    }
#line 164
    if (! __cil_tmp3) {
#line 164
      goto while_break;
    }
#line 165
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 167
  return (n);
}
}
#line 170 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
void opj_t2_putnumpasses(opj_bio_t *bio , OPJ_UINT32 n ) 
{ 


  {
#line 171
  if (n == 1U) {
    {
#line 172
    opj_bio_write(bio, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
    }
  } else
#line 173
  if (n == 2U) {
    {
#line 174
    opj_bio_write(bio, (OPJ_UINT32 )2, (OPJ_UINT32 )2);
    }
  } else
#line 175
  if (n <= 5U) {
    {
#line 176
    opj_bio_write(bio, 12U | (n - 3U), (OPJ_UINT32 )4);
    }
  } else
#line 177
  if (n <= 36U) {
    {
#line 178
    opj_bio_write(bio, 480U | (n - 6U), (OPJ_UINT32 )9);
    }
  } else
#line 179
  if (n <= 164U) {
    {
#line 180
    opj_bio_write(bio, 65408U | (n - 37U), (OPJ_UINT32 )16);
    }
  }
#line 183
  return;
}
}
#line 184 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
OPJ_UINT32 opj_t2_getnumpasses(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 n ;
  OPJ_UINT32 __cil_tmp3 ;
  OPJ_UINT32 __cil_tmp4 ;
  OPJ_UINT32 __cil_tmp7 ;

  {
  {
#line 186
  __cil_tmp3 = opj_bio_read(bio, (OPJ_UINT32 )1);
  }
#line 186
  if (! __cil_tmp3) {
#line 187
    return ((OPJ_UINT32 )1);
  }
  {
#line 188
  __cil_tmp4 = opj_bio_read(bio, (OPJ_UINT32 )1);
  }
#line 188
  if (! __cil_tmp4) {
#line 189
    return ((OPJ_UINT32 )2);
  }
  {
#line 190
  n = opj_bio_read(bio, (OPJ_UINT32 )2);
  }
#line 190
  if (n != 3U) {
#line 191
    return (3U + n);
  }
  {
#line 192
  n = opj_bio_read(bio, (OPJ_UINT32 )5);
  }
#line 192
  if (n != 31U) {
#line 193
    return (6U + n);
  }
  {
#line 194
  __cil_tmp7 = opj_bio_read(bio, (OPJ_UINT32 )7);
  }
#line 194
  return (37U + __cil_tmp7);
}
}
#line 199 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_encode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_UINT32 p_maxlayers , OPJ_BYTE *p_dest , OPJ_UINT32 *p_data_written ,
                               OPJ_UINT32 p_max_len , opj_codestream_info_t *cstr_info ,
                               OPJ_UINT32 p_tp_num , OPJ_INT32 p_tp_pos , OPJ_UINT32 p_pino ,
                               J2K_T2_MODE p_t2_mode ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 poc ;
  opj_pi_iterator_t *l_pi ;
  opj_pi_iterator_t *l_current_pi ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 pocno ;
  int tmp ;
  OPJ_UINT32 l_max_comp ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 l_nb_pocs ;
  OPJ_UINT32 l_comp_len ;
  OPJ_UINT32 l_tp_num ;
  OPJ_BOOL __cil_tmp30 ;
  OPJ_BOOL __cil_tmp31 ;
  OPJ_BOOL __cil_tmp32 ;
  OPJ_BOOL __cil_tmp33 ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  OPJ_OFF_T tmp___1 ;

  {
#line 212
  l_current_data = p_dest;
#line 213
  l_nb_bytes = (OPJ_UINT32 )0;
#line 216
  l_pi = (opj_pi_iterator_t *)0;
#line 217
  l_current_pi = (opj_pi_iterator_t *)0;
#line 218
  l_image = p_t2->image;
#line 219
  l_cp = p_t2->cp;
#line 220
  l_tcp = l_cp->tcps + p_tile_no;
#line 221
  if ((int )l_cp->rsiz == 4) {
#line 221
    tmp = 2;
  } else {
#line 221
    tmp = 1;
  }
#line 221
  pocno = (OPJ_UINT32 )tmp;
#line 222
  if (l_cp->m_specific_param.m_enc.m_max_comp_size > 0U) {
#line 222
    tmp___0 = l_image->numcomps;
  } else {
#line 222
    tmp___0 = 1U;
  }
  {
#line 222
  l_max_comp = tmp___0;
#line 223
  l_nb_pocs = l_tcp->numpocs + 1U;
#line 225
  l_pi = opj_pi_initialise_encode(l_image, l_cp, p_tile_no, p_t2_mode);
  }
#line 226
  if (! l_pi) {
#line 227
    return (0);
  }
#line 230
  *p_data_written = (OPJ_UINT32 )0;
#line 232
  if ((unsigned int )p_t2_mode == 0U) {
#line 233
    l_current_pi = l_pi;
#line 235
    compno = (OPJ_UINT32 )0;
    {
#line 235
    while (1) {
      while_continue: /* CIL Label */ ;

#line 235
      if (! (compno < l_max_comp)) {
#line 235
        goto while_break;
      }
#line 236
      l_comp_len = (OPJ_UINT32 )0;
#line 237
      l_current_pi = l_pi;
#line 239
      poc = (OPJ_UINT32 )0;
      {
#line 239
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 239
        if (! (poc < pocno)) {
#line 239
          goto while_break___0;
        }
        {
#line 240
        l_tp_num = compno;
#line 243
        opj_pi_create_encode(l_pi, l_cp, p_tile_no, poc, l_tp_num, p_tp_pos, p_t2_mode);
        }
#line 245
        if ((int )l_current_pi->poc.prg == -1) {
          {
#line 247
          opj_pi_destroy(l_pi, l_nb_pocs);
          }
#line 248
          return (0);
        }
        {
#line 250
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 250
          __cil_tmp30 = opj_pi_next(l_current_pi);
          }
#line 250
          if (! __cil_tmp30) {
#line 250
            goto while_break___1;
          }
#line 251
          if (l_current_pi->layno < p_maxlayers) {
            {
#line 252
            l_nb_bytes = (OPJ_UINT32 )0;
#line 254
            __cil_tmp31 = opj_t2_encode_packet(p_tile_no, p_tile, l_tcp, l_current_pi,
                                               l_current_data, & l_nb_bytes, p_max_len,
                                               cstr_info);
            }
#line 254
            if (! __cil_tmp31) {
              {
#line 255
              opj_pi_destroy(l_pi, l_nb_pocs);
              }
#line 256
              return (0);
            }
#line 259
            l_comp_len += l_nb_bytes;
#line 260
            l_current_data += l_nb_bytes;
#line 261
            p_max_len -= l_nb_bytes;
#line 263
            *p_data_written += l_nb_bytes;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: ;
#line 267
        if (l_cp->m_specific_param.m_enc.m_max_comp_size) {
#line 268
          if (l_comp_len > l_cp->m_specific_param.m_enc.m_max_comp_size) {
            {
#line 269
            opj_pi_destroy(l_pi, l_nb_pocs);
            }
#line 270
            return (0);
          }
        }
#line 274
        l_current_pi ++;
#line 239
        poc ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: 
#line 235
      compno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 279
    opj_pi_create_encode(l_pi, l_cp, p_tile_no, p_pino, p_tp_num, p_tp_pos, p_t2_mode);
#line 281
    l_current_pi = l_pi + p_pino;
    }
#line 282
    if ((int )l_current_pi->poc.prg == -1) {
      {
#line 284
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 285
      return (0);
    }
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 287
      __cil_tmp32 = opj_pi_next(l_current_pi);
      }
#line 287
      if (! __cil_tmp32) {
#line 287
        goto while_break___2;
      }
#line 288
      if (l_current_pi->layno < p_maxlayers) {
        {
#line 289
        l_nb_bytes = (OPJ_UINT32 )0;
#line 291
        __cil_tmp33 = opj_t2_encode_packet(p_tile_no, p_tile, l_tcp, l_current_pi,
                                           l_current_data, & l_nb_bytes, p_max_len,
                                           cstr_info);
        }
#line 291
        if (! __cil_tmp33) {
          {
#line 292
          opj_pi_destroy(l_pi, l_nb_pocs);
          }
#line 293
          return (0);
        }
#line 296
        l_current_data += l_nb_bytes;
#line 297
        p_max_len -= l_nb_bytes;
#line 299
        *p_data_written += l_nb_bytes;
#line 302
        if (cstr_info) {
#line 303
          if (cstr_info->index_write) {
#line 304
            info_TL = cstr_info->tile + p_tile_no;
#line 305
            info_PK = info_TL->packet + cstr_info->packno;
#line 306
            if (! cstr_info->packno) {
#line 307
              info_PK->start_pos = (OPJ_OFF_T )(info_TL->end_header + 1);
            } else {
#line 309
              if ((int )l_cp->m_specific_param.m_enc.m_tp_on | (int )l_tcp->POC) {
#line 309
                if (info_PK->start_pos) {
#line 309
                  tmp___1 = info_PK->start_pos;
                } else {
#line 309
                  tmp___1 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1L;
                }
              } else {
#line 309
                tmp___1 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1L;
              }
#line 309
              info_PK->start_pos = tmp___1;
            }
#line 311
            info_PK->end_pos = (info_PK->start_pos + (long )l_nb_bytes) - 1L;
#line 312
            info_PK->end_ph_pos += info_PK->start_pos - 1L;
          }
#line 316
          (cstr_info->packno) ++;
        }
#line 319
        (p_tile->packno) ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
  {
#line 324
  opj_pi_destroy(l_pi, l_nb_pocs);
  }
#line 326
  return (1);
}
}
#line 334 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
static void opj_null_jas_fprintf(FILE *file , char const   *format  , ...) 
{ 


  {
#line 339
  return;
}
}
#line 342 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_decode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_len ,
                               opj_codestream_index_t *p_cstr_index ) 
{ 
  OPJ_BYTE *l_current_data ;
  opj_pi_iterator_t *l_pi ;
  OPJ_UINT32 pino ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_pocs ;
  opj_pi_iterator_t *l_current_pi ;
  opj_packet_info_t *l_pack_info ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BOOL *first_pass_failed ;
  void *__cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;
  OPJ_BOOL __cil_tmp23 ;
  OPJ_BOOL __cil_tmp25 ;

  {
  {
#line 350
  l_current_data = p_src;
#line 351
  l_pi = (opj_pi_iterator_t *)0;
#line 353
  l_image = p_t2->image;
#line 354
  l_cp = p_t2->cp;
#line 355
  l_tcp = (p_t2->cp)->tcps + p_tile_no;
#line 357
  l_nb_pocs = l_tcp->numpocs + 1U;
#line 358
  l_current_pi = (opj_pi_iterator_t *)0;
#line 363
  l_pack_info = (opj_packet_info_t *)0;
#line 364
  l_img_comp = (opj_image_comp_t *)0;
#line 375
  l_pi = opj_pi_create_decode(l_image, l_cp, p_tile_no);
  }
#line 376
  if (! l_pi) {
#line 377
    return (0);
  }
#line 381
  l_current_pi = l_pi;
#line 383
  pino = (OPJ_UINT32 )0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;

#line 383
    if (! (pino <= l_tcp->numpocs)) {
#line 383
      goto while_break;
    }
#line 390
    first_pass_failed = (OPJ_BOOL *)((void *)0);
#line 392
    if ((int )l_current_pi->poc.prg == -1) {
      {
#line 394
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 395
      return (0);
    }
    {
#line 398
    __cil_tmp21 = malloc((unsigned long )l_image->numcomps * sizeof(OPJ_BOOL ));
#line 398
    first_pass_failed = (OPJ_BOOL *)__cil_tmp21;
    }
#line 399
    if (! first_pass_failed) {
      {
#line 401
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 402
      return (0);
    }
    {
#line 404
    memset((void *)first_pass_failed, 1, (unsigned long )l_image->numcomps * sizeof(OPJ_BOOL ));
    }
    {
#line 406
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 406
      __cil_tmp22 = opj_pi_next(l_current_pi);
      }
#line 406
      if (! __cil_tmp22) {
#line 406
        goto while_break___0;
      }
      {
#line 407
      opj_null_jas_fprintf(stderr, "packet offset=00000166 prg=%d cmptno=%02d rlvlno=%02d prcno=%03d lyrno=%02d\n\n",
                           (int )l_current_pi->poc.prg1, l_current_pi->compno, l_current_pi->resno,
                           l_current_pi->precno, l_current_pi->layno);
      }
#line 410
      if (l_tcp->num_layers_to_decode > l_current_pi->layno) {
#line 410
        if (l_current_pi->resno < (p_tile->comps + l_current_pi->compno)->minimum_num_resolutions) {
          {
#line 412
          l_nb_bytes_read = (OPJ_UINT32 )0;
#line 414
          *(first_pass_failed + l_current_pi->compno) = 0;
#line 416
          __cil_tmp23 = opj_t2_decode_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
                                             & l_nb_bytes_read, p_max_len, l_pack_info);
          }
#line 416
          if (! __cil_tmp23) {
            {
#line 417
            opj_pi_destroy(l_pi, l_nb_pocs);
#line 418
            free((void *)first_pass_failed);
            }
#line 419
            return (0);
          }
          {
#line 422
          l_img_comp = l_image->comps + l_current_pi->compno;
#line 423
          l_img_comp->resno_decoded = opj_uint_max(l_current_pi->resno, l_img_comp->resno_decoded);
          }
        } else {
#line 410
          goto _L;
        }
      } else {
        _L: 
        {
#line 426
        l_nb_bytes_read = (OPJ_UINT32 )0;
#line 427
        __cil_tmp25 = opj_t2_skip_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
                                         & l_nb_bytes_read, p_max_len, l_pack_info);
        }
#line 427
        if (! __cil_tmp25) {
          {
#line 428
          opj_pi_destroy(l_pi, l_nb_pocs);
#line 429
          free((void *)first_pass_failed);
          }
#line 430
          return (0);
        }
      }
#line 434
      if (*(first_pass_failed + l_current_pi->compno)) {
#line 435
        l_img_comp = l_image->comps + l_current_pi->compno;
#line 436
        if (l_img_comp->resno_decoded == 0U) {
#line 437
          l_img_comp->resno_decoded = (p_tile->comps + l_current_pi->compno)->minimum_num_resolutions - 1U;
        }
      }
#line 440
      l_current_data += l_nb_bytes_read;
#line 441
      p_max_len -= l_nb_bytes_read;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 466
    l_current_pi ++;
#line 468
    free((void *)first_pass_failed);
#line 383
    pino ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 480
  opj_pi_destroy(l_pi, l_nb_pocs);
#line 481
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src);
  }
#line 482
  return (1);
}
}
#line 494 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
opj_t2_t *opj_t2_create(opj_image_t *p_image , opj_cp_t *p_cp ) 
{ 
  opj_t2_t *l_t2 ;
  void *__cil_tmp4 ;

  {
  {
#line 497
  __cil_tmp4 = calloc(1UL, sizeof(opj_t2_t ));
#line 497
  l_t2 = (opj_t2_t *)__cil_tmp4;
  }
#line 498
  if (! l_t2) {
#line 499
    return ((opj_t2_t *)((void *)0));
  }
#line 502
  l_t2->image = p_image;
#line 503
  l_t2->cp = p_cp;
#line 505
  return (l_t2);
}
}
#line 508 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
void opj_t2_destroy(opj_t2_t *t2 ) 
{ 


  {
#line 509
  if (t2) {
    {
#line 510
    free((void *)t2);
    }
  }
#line 513
  return;
}
}
#line 514 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_decode_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                              opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                              OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) 
{ 
  OPJ_BOOL l_read_data ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_total_bytes_read ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 524
  l_nb_bytes_read = (OPJ_UINT32 )0;
#line 525
  l_nb_total_bytes_read = (OPJ_UINT32 )0;
#line 527
  *p_data_read = (OPJ_UINT32 )0;
#line 529
  __cil_tmp12 = opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, & l_read_data,
                                          p_src, & l_nb_bytes_read, p_max_length,
                                          p_pack_info);
  }
#line 529
  if (! __cil_tmp12) {
#line 530
    return (0);
  }
#line 533
  p_src += l_nb_bytes_read;
#line 534
  l_nb_total_bytes_read += l_nb_bytes_read;
#line 535
  p_max_length -= l_nb_bytes_read;
#line 538
  if (l_read_data) {
    {
#line 539
    l_nb_bytes_read = (OPJ_UINT32 )0;
#line 541
    __cil_tmp13 = opj_t2_read_packet_data(p_t2, p_tile, p_pi, p_src, & l_nb_bytes_read,
                                          p_max_length, p_pack_info);
    }
#line 541
    if (! __cil_tmp13) {
#line 542
      return (0);
    }
#line 545
    l_nb_total_bytes_read += l_nb_bytes_read;
  }
#line 548
  *p_data_read = l_nb_total_bytes_read;
#line 550
  return (1);
}
}
#line 553 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                              opj_pi_iterator_t *pi , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 length , opj_codestream_info_t *cstr_info ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_BYTE *c ;
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 l_nb_blocks ;
  opj_tcd_band_t *band ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_bio_t *bio ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_precinct_t *prc___0 ;
  opj_tcd_layer_t *layer ;
  opj_tcd_layer_t *layer___0 ;
  OPJ_UINT32 increment ;
  OPJ_UINT32 nump ;
  OPJ_UINT32 len ;
  OPJ_UINT32 passno ;
  OPJ_UINT32 l_nb_passes ;
  OPJ_INT32 __cil_tmp34 ;
  OPJ_INT32 __cil_tmp35 ;
  OPJ_INT32 __cil_tmp36 ;
  OPJ_INT32 __cil_tmp38 ;
  OPJ_BOOL __cil_tmp40 ;
  ptrdiff_t __cil_tmp41 ;
  opj_packet_info_t *info_PK ;
  opj_tcd_precinct_t *prc___1 ;
  opj_tcd_layer_t *layer___1 ;
  opj_packet_info_t *info_PK___0 ;

  {
#line 563
  c = dest;
#line 565
  compno = pi->compno;
#line 566
  resno = pi->resno;
#line 567
  precno = pi->precno;
#line 568
  layno = pi->layno;
#line 570
  band = (opj_tcd_band_t *)0;
#line 571
  cblk = (opj_tcd_cblk_enc_t *)0;
#line 572
  pass = (opj_tcd_pass_t *)0;
#line 574
  tilec = tile->comps + compno;
#line 575
  res = tilec->resolutions + resno;
#line 577
  bio = (opj_bio_t *)0;
#line 580
  if (tcp->csty & 2U) {
#line 581
    *(c + 0) = (OPJ_BYTE )255;
#line 582
    *(c + 1) = (OPJ_BYTE )145;
#line 583
    *(c + 2) = (OPJ_BYTE )0;
#line 584
    *(c + 3) = (OPJ_BYTE )4;
#line 589
    *(c + 4) = (OPJ_BYTE )((tile->packno >> 8) & 255U);
#line 590
    *(c + 5) = (OPJ_BYTE )(tile->packno & 255U);
#line 592
    c += 6;
#line 593
    length -= 6U;
  }
#line 597
  if (! layno) {
#line 598
    band = res->bands;
#line 600
    bandno = (OPJ_UINT32 )0;
    {
#line 600
    while (1) {
      while_continue: /* CIL Label */ ;

#line 600
      if (! (bandno < res->numbands)) {
#line 600
        goto while_break;
      }
      {
#line 601
      prc = band->precincts + precno;
#line 603
      opj_tgt_reset(prc->incltree);
#line 604
      opj_tgt_reset(prc->imsbtree);
#line 606
      l_nb_blocks = prc->cw * prc->ch;
#line 607
      cblkno = (OPJ_UINT32 )0;
      }
      {
#line 607
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 607
        if (! (cblkno < l_nb_blocks)) {
#line 607
          goto while_break___0;
        }
        {
#line 608
        cblk = prc->cblks.enc + cblkno;
#line 610
        cblk->numpasses = (OPJ_UINT32 )0;
#line 611
        opj_tgt_setvalue(prc->imsbtree, cblkno, band->numbps - (OPJ_INT32 )cblk->numbps);
#line 607
        cblkno ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___0: 
#line 613
      band ++;
#line 600
      bandno ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 617
  bio = opj_bio_create();
  }
#line 618
  if (! bio) {
#line 620
    return (0);
  }
  {
#line 622
  opj_bio_init_enc(bio, c, length);
#line 623
  opj_bio_write(bio, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
#line 626
  band = res->bands;
#line 627
  bandno = (OPJ_UINT32 )0;
  }
  {
#line 627
  while (1) {
    while_continue___9: /* CIL Label */ ;

#line 627
    if (! (bandno < res->numbands)) {
#line 627
      goto while_break___1;
    }
#line 628
    prc___0 = band->precincts + precno;
#line 630
    l_nb_blocks = prc___0->cw * prc___0->ch;
#line 631
    cblk = prc___0->cblks.enc;
#line 633
    cblkno = (OPJ_UINT32 )0;
    {
#line 633
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 633
      if (! (cblkno < l_nb_blocks)) {
#line 633
        goto while_break___2;
      }
#line 634
      layer = cblk->layers + layno;
#line 636
      if (! cblk->numpasses) {
#line 636
        if (layer->numpasses) {
          {
#line 637
          opj_tgt_setvalue(prc___0->incltree, cblkno, (OPJ_INT32 )layno);
          }
        }
      }
#line 640
      cblk ++;
#line 633
      cblkno ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___2: 
#line 643
    cblk = prc___0->cblks.enc;
#line 644
    cblkno = (OPJ_UINT32 )0;
    {
#line 644
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___3: ;
#line 644
      if (! (cblkno < l_nb_blocks)) {
#line 644
        goto while_break___3;
      }
#line 645
      layer___0 = cblk->layers + layno;
#line 646
      increment = (OPJ_UINT32 )0;
#line 647
      nump = (OPJ_UINT32 )0;
#line 648
      len = (OPJ_UINT32 )0;
#line 652
      if (! cblk->numpasses) {
        {
#line 653
        opj_tgt_encode(bio, prc___0->incltree, cblkno, (OPJ_INT32 )(layno + 1U));
        }
      } else {
        {
#line 655
        opj_bio_write(bio, (OPJ_UINT32 )(layer___0->numpasses != 0U), (OPJ_UINT32 )1);
        }
      }
#line 659
      if (! layer___0->numpasses) {
#line 660
        cblk ++;
#line 661
        goto while_continue___3;
      }
#line 665
      if (! cblk->numpasses) {
        {
#line 666
        cblk->numlenbits = (OPJ_UINT32 )3;
#line 667
        opj_tgt_encode(bio, prc___0->imsbtree, cblkno, 999);
        }
      }
      {
#line 671
      opj_t2_putnumpasses(bio, layer___0->numpasses);
#line 672
      l_nb_passes = cblk->numpasses + layer___0->numpasses;
#line 673
      pass = cblk->passes + cblk->numpasses;
#line 676
      passno = cblk->numpasses;
      }
      {
#line 676
      while (1) {
        while_continue___12: /* CIL Label */ ;

#line 676
        if (! (passno < l_nb_passes)) {
#line 676
          goto while_break___4;
        }
#line 677
        nump ++;
#line 678
        len += pass->len;
#line 680
        if ((int )pass->term) {
          _L: 
          {
#line 681
          __cil_tmp35 = opj_int_floorlog2((OPJ_INT32 )nump);
#line 681
          __cil_tmp34 = opj_int_floorlog2((OPJ_INT32 )len);
#line 681
          __cil_tmp36 = opj_int_max((OPJ_INT32 )increment, (__cil_tmp34 + 1) - ((OPJ_INT32 )cblk->numlenbits + __cil_tmp35));
#line 681
          increment = (OPJ_UINT32 )__cil_tmp36;
#line 683
          len = (OPJ_UINT32 )0;
#line 684
          nump = (OPJ_UINT32 )0;
          }
        } else
#line 680
        if (passno == (cblk->numpasses + layer___0->numpasses) - 1U) {
#line 680
          goto _L;
        }
#line 687
        pass ++;
#line 676
        passno ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___4: 
      {
#line 689
      opj_t2_putcommacode(bio, (OPJ_INT32 )increment);
#line 692
      cblk->numlenbits += increment;
#line 694
      pass = cblk->passes + cblk->numpasses;
#line 696
      passno = cblk->numpasses;
      }
      {
#line 696
      while (1) {
        while_continue___13: /* CIL Label */ ;

#line 696
        if (! (passno < l_nb_passes)) {
#line 696
          goto while_break___5;
        }
#line 697
        nump ++;
#line 698
        len += pass->len;
#line 700
        if ((int )pass->term) {
          {
#line 701
          __cil_tmp38 = opj_int_floorlog2((OPJ_INT32 )nump);
#line 701
          opj_bio_write(bio, len, cblk->numlenbits + (OPJ_UINT32 )__cil_tmp38);
#line 702
          len = (OPJ_UINT32 )0;
#line 703
          nump = (OPJ_UINT32 )0;
          }
        } else
#line 700
        if (passno == (cblk->numpasses + layer___0->numpasses) - 1U) {
          {
#line 701
          __cil_tmp38 = opj_int_floorlog2((OPJ_INT32 )nump);
#line 701
          opj_bio_write(bio, len, cblk->numlenbits + (OPJ_UINT32 )__cil_tmp38);
#line 702
          len = (OPJ_UINT32 )0;
#line 703
          nump = (OPJ_UINT32 )0;
          }
        }
#line 705
        pass ++;
#line 696
        passno ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___5: 
#line 708
      cblk ++;
#line 644
      cblkno ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___3: 
#line 711
    band ++;
#line 627
    bandno ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 714
  __cil_tmp40 = opj_bio_flush(bio);
  }
#line 714
  if (! __cil_tmp40) {
    {
#line 715
    opj_bio_destroy(bio);
    }
#line 716
    return (0);
  }
  {
#line 719
  __cil_tmp41 = opj_bio_numbytes(bio);
#line 719
  l_nb_bytes = (OPJ_UINT32 )__cil_tmp41;
#line 720
  c += l_nb_bytes;
#line 721
  length -= l_nb_bytes;
#line 723
  opj_bio_destroy(bio);
  }
#line 726
  if (tcp->csty & 4U) {
#line 727
    *(c + 0) = (OPJ_BYTE )255;
#line 728
    *(c + 1) = (OPJ_BYTE )146;
#line 729
    c += 2;
#line 730
    length -= 2U;
  }
#line 737
  if (cstr_info) {
#line 737
    if (cstr_info->index_write) {
#line 738
      info_PK = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 739
      info_PK->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(c - dest));
    }
  }
#line 744
  band = res->bands;
#line 745
  bandno = (OPJ_UINT32 )0;
  {
#line 745
  while (1) {
    while_continue___14: /* CIL Label */ ;

#line 745
    if (! (bandno < res->numbands)) {
#line 745
      goto while_break___6;
    }
#line 746
    prc___1 = band->precincts + precno;
#line 748
    l_nb_blocks = prc___1->cw * prc___1->ch;
#line 749
    cblk = prc___1->cblks.enc;
#line 751
    cblkno = (OPJ_UINT32 )0;
    {
#line 751
    while (1) {
      while_continue___15: /* CIL Label */ ;
      while_continue___7: ;
#line 751
      if (! (cblkno < l_nb_blocks)) {
#line 751
        goto while_break___7;
      }
#line 752
      layer___1 = cblk->layers + layno;
#line 754
      if (! layer___1->numpasses) {
#line 755
        cblk ++;
#line 756
        goto while_continue___7;
      }
#line 759
      if (layer___1->len > length) {
#line 760
        return (0);
      }
      {
#line 763
      memcpy((void *)c, (void const   *)layer___1->data, (unsigned long )layer___1->len);
#line 764
      cblk->numpasses += layer___1->numpasses;
#line 765
      c += layer___1->len;
#line 766
      length -= layer___1->len;
      }
#line 769
      if (cstr_info) {
#line 769
        if (cstr_info->index_write) {
#line 770
          info_PK___0 = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 771
          info_PK___0->disto += layer___1->disto;
#line 772
          if (cstr_info->D_max < info_PK___0->disto) {
#line 773
            cstr_info->D_max = info_PK___0->disto;
          }
        }
      }
#line 777
      cblk ++;
#line 751
      cblkno ++;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___7: 
#line 780
    band ++;
#line 745
    bandno ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___6: 
#line 784
  *p_data_written += (OPJ_UINT32 )(c - dest);
#line 786
  return (1);
}
}
#line 789 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_skip_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) 
{ 
  OPJ_BOOL l_read_data ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_total_bytes_read ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 799
  l_nb_bytes_read = (OPJ_UINT32 )0;
#line 800
  l_nb_total_bytes_read = (OPJ_UINT32 )0;
#line 802
  *p_data_read = (OPJ_UINT32 )0;
#line 804
  __cil_tmp12 = opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, & l_read_data,
                                          p_src, & l_nb_bytes_read, p_max_length,
                                          p_pack_info);
  }
#line 804
  if (! __cil_tmp12) {
#line 805
    return (0);
  }
#line 808
  p_src += l_nb_bytes_read;
#line 809
  l_nb_total_bytes_read += l_nb_bytes_read;
#line 810
  p_max_length -= l_nb_bytes_read;
#line 813
  if (l_read_data) {
    {
#line 814
    l_nb_bytes_read = (OPJ_UINT32 )0;
#line 816
    __cil_tmp13 = opj_t2_skip_packet_data(p_t2, p_tile, p_pi, & l_nb_bytes_read, p_max_length,
                                          p_pack_info);
    }
#line 816
    if (! __cil_tmp13) {
#line 817
      return (0);
    }
#line 820
    l_nb_total_bytes_read += l_nb_bytes_read;
  }
#line 822
  *p_data_read = l_nb_total_bytes_read;
#line 824
  return (1);
}
}
#line 828 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_read_packet_header(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BOOL *p_is_data_present ,
                                   OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_UINT32 l_remaining_length ;
  OPJ_UINT32 l_header_length ;
  OPJ_UINT32 *l_modified_length_ptr ;
  OPJ_BYTE *l_current_data ;
  opj_cp_t *l_cp ;
  opj_bio_t *l_bio ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  OPJ_BYTE *l_header_data ;
  OPJ_BYTE **l_header_data_start ;
  OPJ_UINT32 l_present ;
  opj_tcd_precinct_t *l_prc ;
  ptrdiff_t __cil_tmp28 ;
  opj_tcd_precinct_t *l_prc___0 ;
  OPJ_UINT32 l_included ;
  OPJ_UINT32 l_increment ;
  OPJ_UINT32 l_segno ;
  OPJ_INT32 n ;
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp37 ;
  OPJ_BOOL __cil_tmp40 ;
  OPJ_BOOL __cil_tmp41 ;
  OPJ_INT32 __cil_tmp42 ;
  OPJ_UINT32 __cil_tmp43 ;
  OPJ_UINT32 __cil_tmp44 ;
  OPJ_BOOL __cil_tmp45 ;
  OPJ_BOOL __cil_tmp47 ;
  ptrdiff_t __cil_tmp48 ;

  {
#line 844
  l_modified_length_ptr = (OPJ_UINT32 *)0;
#line 845
  l_current_data = p_src_data;
#line 846
  l_cp = p_t2->cp;
#line 847
  l_bio = (opj_bio_t *)0;
#line 848
  l_band = (opj_tcd_band_t *)0;
#line 849
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 850
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 852
  l_header_data = (OPJ_BYTE *)0;
#line 853
  l_header_data_start = (OPJ_BYTE **)0;
#line 857
  if (p_pi->layno == 0U) {
#line 858
    l_band = l_res->bands;
#line 861
    bandno = (OPJ_UINT32 )0;
    {
#line 861
    while (1) {
      while_continue: /* CIL Label */ ;

#line 861
      if (! (bandno < l_res->numbands)) {
#line 861
        goto while_break;
      }
#line 862
      l_prc = l_band->precincts + p_pi->precno;
#line 864
      if (! (l_band->x1 - l_band->x0 == 0)) {
#line 864
        if (! (l_band->y1 - l_band->y0 == 0)) {
          {
#line 865
          opj_tgt_reset(l_prc->incltree);
#line 866
          opj_tgt_reset(l_prc->imsbtree);
#line 867
          l_cblk = l_prc->cblks.dec;
#line 869
          l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 870
          cblkno = (OPJ_UINT32 )0;
          }
          {
#line 870
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 870
            if (! (cblkno < l_nb_code_blocks)) {
#line 870
              goto while_break___0;
            }
#line 871
            l_cblk->numsegs = (OPJ_UINT32 )0;
#line 872
            l_cblk->real_num_segs = (OPJ_UINT32 )0;
#line 873
            l_cblk ++;
#line 870
            cblkno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
          while_break___0: ;
        }
      }
#line 877
      l_band ++;
#line 861
      bandno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 883
  if (p_tcp->csty & 2U) {
#line 884
    if (p_max_length < 6U) {
      {
#line 886
      fprintf(stderr, "Not enough space for expected SOP marker\n$LjEV");
      }
    } else
#line 887
    if ((int )*l_current_data != 255) {
      {
#line 889
      fprintf(stderr, "Warning: expected SOP marker\nV");
      }
    } else
#line 887
    if ((int )*(l_current_data + 1) != 145) {
      {
#line 889
      fprintf(stderr, "Warning: expected SOP marker\nV");
      }
    } else {
#line 891
      l_current_data += 6;
    }
  }
  {
#line 904
  l_bio = opj_bio_create();
  }
#line 905
  if (! l_bio) {
#line 906
    return (0);
  }
#line 909
  if ((int )l_cp->ppm == 1) {
#line 910
    l_header_data_start = & l_cp->ppm_data;
#line 911
    l_header_data = *l_header_data_start;
#line 912
    l_modified_length_ptr = & l_cp->ppm_len;
  } else
#line 915
  if ((int )p_tcp->ppt == 1) {
#line 916
    l_header_data_start = & p_tcp->ppt_data;
#line 917
    l_header_data = *l_header_data_start;
#line 918
    l_modified_length_ptr = & p_tcp->ppt_len;
  } else {
#line 921
    l_header_data_start = & l_current_data;
#line 922
    l_header_data = *l_header_data_start;
#line 923
    l_remaining_length = (OPJ_UINT32 )((p_src_data + p_max_length) - l_header_data);
#line 924
    l_modified_length_ptr = & l_remaining_length;
  }
  {
#line 927
  opj_bio_init_dec(l_bio, l_header_data, *l_modified_length_ptr);
#line 929
  l_present = opj_bio_read(l_bio, (OPJ_UINT32 )1);
#line 930
  opj_null_jas_fprintf(stderr, "present=%d \n", l_present);
  }
#line 931
  if (! l_present) {
    {
#line 933
    opj_bio_inalign(l_bio);
#line 934
    __cil_tmp28 = opj_bio_numbytes(l_bio);
#line 934
    l_header_data += __cil_tmp28;
#line 935
    opj_bio_destroy(l_bio);
    }
#line 938
    if (p_tcp->csty & 4U) {
#line 939
      if (*l_modified_length_ptr - (OPJ_UINT32 )(l_header_data - *l_header_data_start) < 2U) {
        {
#line 940
        fprintf(stderr, "Not enough space for expected EPH marker\n");
        }
      } else
#line 941
      if ((int )*l_header_data != 255) {
        {
#line 942
        fprintf(stderr, "Error : expected EPH marker\n");
        }
      } else
#line 941
      if ((int )*(l_header_data + 1) != 146) {
        {
#line 942
        fprintf(stderr, "Error : expected EPH marker\n");
        }
      } else {
#line 944
        l_header_data += 2;
      }
    }
#line 948
    l_header_length = (OPJ_UINT32 )(l_header_data - *l_header_data_start);
#line 949
    *l_modified_length_ptr -= l_header_length;
#line 950
    *l_header_data_start += l_header_length;
#line 955
    if (p_pack_info) {
#line 956
      p_pack_info->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(l_current_data - p_src_data));
    }
#line 960
    *p_is_data_present = 0;
#line 961
    *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 962
    return (1);
  }
#line 965
  l_band = l_res->bands;
#line 966
  bandno = (OPJ_UINT32 )0;
  {
#line 966
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: ;
#line 966
    if (! (bandno < l_res->numbands)) {
#line 966
      goto while_break___1;
    }
#line 967
    l_prc___0 = l_band->precincts + p_pi->precno;
#line 969
    if (l_band->x1 - l_band->x0 == 0) {
#line 970
      l_band ++;
#line 971
      goto while_continue___1;
    } else
#line 969
    if (l_band->y1 - l_band->y0 == 0) {
#line 970
      l_band ++;
#line 971
      goto while_continue___1;
    }
#line 974
    l_nb_code_blocks = l_prc___0->cw * l_prc___0->ch;
#line 975
    l_cblk = l_prc___0->cblks.dec;
#line 976
    cblkno = (OPJ_UINT32 )0;
    {
#line 976
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___2: ;
#line 976
      if (! (cblkno < l_nb_code_blocks)) {
#line 976
        goto while_break___2;
      }
#line 981
      if (! l_cblk->numsegs) {
        {
#line 982
        l_included = opj_tgt_decode(l_bio, l_prc___0->incltree, cblkno, (OPJ_INT32 )(p_pi->layno + 1U));
        }
      } else {
        {
#line 986
        l_included = opj_bio_read(l_bio, (OPJ_UINT32 )1);
        }
      }
#line 990
      if (! l_included) {
        {
#line 991
        l_cblk->numnewpasses = (OPJ_UINT32 )0;
#line 992
        l_cblk ++;
#line 993
        opj_null_jas_fprintf(stderr, "included=%d \nV", l_included);
        }
#line 994
        goto while_continue___2;
      }
#line 998
      if (! l_cblk->numsegs) {
#line 999
        i = (OPJ_UINT32 )0;
        {
#line 1001
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 1001
          __cil_tmp37 = opj_tgt_decode(l_bio, l_prc___0->imsbtree, cblkno, (OPJ_INT32 )i);
          }
#line 1001
          if (! (! __cil_tmp37)) {
#line 1001
            goto while_break___3;
          }
#line 1002
          i ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: 
#line 1005
        l_cblk->numbps = ((OPJ_UINT32 )l_band->numbps + 1U) - i;
#line 1006
        l_cblk->numlenbits = (OPJ_UINT32 )3;
      }
      {
#line 1010
      l_cblk->numnewpasses = opj_t2_getnumpasses(l_bio);
#line 1011
      l_increment = opj_t2_getcommacode(l_bio);
#line 1014
      l_cblk->numlenbits += l_increment;
#line 1015
      l_segno = (OPJ_UINT32 )0;
      }
#line 1017
      if (! l_cblk->numsegs) {
        {
#line 1018
        __cil_tmp40 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                      (OPJ_UINT32 )1);
        }
#line 1018
        if (! __cil_tmp40) {
          {
#line 1019
          opj_bio_destroy(l_bio);
          }
#line 1020
          return (0);
        }
      } else {
#line 1024
        l_segno = l_cblk->numsegs - 1U;
#line 1025
        if ((l_cblk->segs + l_segno)->numpasses == (l_cblk->segs + l_segno)->maxpasses) {
          {
#line 1026
          l_segno ++;
#line 1027
          __cil_tmp41 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                        (OPJ_UINT32 )0);
          }
#line 1027
          if (! __cil_tmp41) {
            {
#line 1028
            opj_bio_destroy(l_bio);
            }
#line 1029
            return (0);
          }
        }
      }
#line 1033
      n = (OPJ_INT32 )l_cblk->numnewpasses;
      {
#line 1035
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 1036
        __cil_tmp42 = opj_int_min((OPJ_INT32 )((l_cblk->segs + l_segno)->maxpasses - (l_cblk->segs + l_segno)->numpasses),
                                  n);
#line 1036
        (l_cblk->segs + l_segno)->numnewpasses = (OPJ_UINT32 )__cil_tmp42;
#line 1037
        __cil_tmp43 = opj_uint_floorlog2((l_cblk->segs + l_segno)->numnewpasses);
#line 1037
        __cil_tmp44 = opj_bio_read(l_bio, l_cblk->numlenbits + __cil_tmp43);
#line 1037
        (l_cblk->segs + l_segno)->newlen = __cil_tmp44;
#line 1038
        opj_null_jas_fprintf(stderr, "included=%d numnewpasses=%d increment=%d len=%d \n",
                             l_included, (l_cblk->segs + l_segno)->numnewpasses, l_increment,
                             (l_cblk->segs + l_segno)->newlen);
#line 1040
        n -= (OPJ_INT32 )(l_cblk->segs + l_segno)->numnewpasses;
        }
#line 1041
        if (n > 0) {
          {
#line 1042
          l_segno ++;
#line 1044
          __cil_tmp45 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                        (OPJ_UINT32 )0);
          }
#line 1044
          if (! __cil_tmp45) {
            {
#line 1045
            opj_bio_destroy(l_bio);
            }
#line 1046
            return (0);
          }
        }
#line 1035
        if (! (n > 0)) {
#line 1035
          goto while_break___4;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: 
#line 1051
      l_cblk ++;
#line 976
      cblkno ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: 
#line 1054
    l_band ++;
#line 966
    bandno ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 1057
  __cil_tmp47 = opj_bio_inalign(l_bio);
  }
#line 1057
  if (! __cil_tmp47) {
    {
#line 1058
    opj_bio_destroy(l_bio);
    }
#line 1059
    return (0);
  }
  {
#line 1062
  __cil_tmp48 = opj_bio_numbytes(l_bio);
#line 1062
  l_header_data += __cil_tmp48;
#line 1063
  opj_bio_destroy(l_bio);
  }
#line 1066
  if (p_tcp->csty & 4U) {
#line 1067
    if (*l_modified_length_ptr - (OPJ_UINT32 )(l_header_data - *l_header_data_start) < 2U) {
      {
#line 1068
      fprintf(stderr, "Not enough space for expected EPH marker\n");
      }
    } else
#line 1069
    if ((int )*l_header_data != 255) {
      {
#line 1071
      fprintf(stderr, "Error : expected EPH marker\n");
      }
    } else
#line 1069
    if ((int )*(l_header_data + 1) != 146) {
      {
#line 1071
      fprintf(stderr, "Error : expected EPH marker\n");
      }
    } else {
#line 1073
      l_header_data += 2;
    }
  }
  {
#line 1077
  l_header_length = (OPJ_UINT32 )(l_header_data - *l_header_data_start);
#line 1078
  opj_null_jas_fprintf(stderr, "hdrlen=%d \n", l_header_length);
#line 1079
  opj_null_jas_fprintf(stderr, "packet body\n");
#line 1080
  *l_modified_length_ptr -= l_header_length;
#line 1081
  *l_header_data_start += l_header_length;
  }
#line 1086
  if (p_pack_info) {
#line 1087
    p_pack_info->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(l_current_data - p_src_data));
  }
#line 1091
  *p_is_data_present = 1;
#line 1092
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 1094
  return (1);
}
}
#line 1097 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_read_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_pi_iterator_t *p_pi ,
                                 OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                 OPJ_UINT32 p_max_length , opj_packet_info_t *pack_info ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_BYTE *l_current_data ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_precinct_t *l_prc ;
  opj_tcd_seg_t *l_seg ;
  OPJ_BYTE *new_cblk_data ;
  void *__cil_tmp18 ;

  {
#line 1107
  l_current_data = p_src_data;
#line 1108
  l_band = (opj_tcd_band_t *)0;
#line 1109
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 1110
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 1115
  l_band = l_res->bands;
#line 1116
  bandno = (OPJ_UINT32 )0;
  {
#line 1116
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: ;
#line 1116
    if (! (bandno < l_res->numbands)) {
#line 1116
      goto while_break;
    }
#line 1117
    l_prc = l_band->precincts + p_pi->precno;
#line 1119
    if (l_band->x1 - l_band->x0 == 0) {
#line 1120
      l_band ++;
#line 1121
      goto while_continue;
    } else
#line 1119
    if (l_band->y1 - l_band->y0 == 0) {
#line 1120
      l_band ++;
#line 1121
      goto while_continue;
    }
#line 1124
    l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 1125
    l_cblk = l_prc->cblks.dec;
#line 1127
    cblkno = (OPJ_UINT32 )0;
    {
#line 1127
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: ;
#line 1127
      if (! (cblkno < l_nb_code_blocks)) {
#line 1127
        goto while_break___0;
      }
#line 1128
      l_seg = (opj_tcd_seg_t *)0;
#line 1130
      if (! l_cblk->numnewpasses) {
#line 1132
        l_cblk ++;
#line 1133
        goto while_continue___0;
      }
#line 1136
      if (! l_cblk->numsegs) {
#line 1137
        l_seg = l_cblk->segs;
#line 1138
        (l_cblk->numsegs) ++;
#line 1139
        l_cblk->data_current_size = (OPJ_UINT32 )0;
      } else {
#line 1142
        l_seg = l_cblk->segs + (l_cblk->numsegs - 1U);
#line 1144
        if (l_seg->numpasses == l_seg->maxpasses) {
#line 1145
          l_seg ++;
#line 1146
          (l_cblk->numsegs) ++;
        }
      }
      {
#line 1150
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1152
        if ((unsigned long )(l_current_data + l_seg->newlen) > (unsigned long )(p_src_data + p_max_length)) {
          {
#line 1153
          fprintf(stderr, "read: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\nEV",
                  l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno, p_pi->resno,
                  p_pi->compno);
          }
#line 1155
          return (0);
        } else
#line 1152
        if ((OPJ_SIZE_T )l_current_data + (OPJ_SIZE_T )l_seg->newlen < (OPJ_SIZE_T )l_current_data) {
          {
#line 1153
          fprintf(stderr, "read: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\nEV",
                  l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno, p_pi->resno,
                  p_pi->compno);
          }
#line 1155
          return (0);
        }
#line 1178
        if (l_cblk->data_current_size + l_seg->newlen < l_cblk->data_current_size) {
          {
#line 1179
          fprintf(stderr, "read: segment too long (%d) with current size (%d > %d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\nMjEV",
                  l_seg->newlen, l_cblk->data_current_size, 4294967295U - l_seg->newlen,
                  cblkno, p_pi->precno, bandno, p_pi->resno, p_pi->compno);
          }
#line 1181
          return (0);
        }
#line 1184
        if (l_cblk->data_current_size + l_seg->newlen > l_cblk->data_max_size) {
          {
#line 1185
          __cil_tmp18 = realloc((void *)l_cblk->data, (unsigned long )(l_cblk->data_current_size + l_seg->newlen));
#line 1185
          new_cblk_data = (OPJ_BYTE *)__cil_tmp18;
          }
#line 1186
          if (! new_cblk_data) {
            {
#line 1187
            free((void *)l_cblk->data);
#line 1188
            l_cblk->data = (OPJ_BYTE *)((void *)0);
#line 1189
            l_cblk->data_max_size = (OPJ_UINT32 )0;
            }
#line 1191
            return (0);
          }
#line 1193
          l_cblk->data_max_size = l_cblk->data_current_size + l_seg->newlen;
#line 1194
          l_cblk->data = new_cblk_data;
        }
        {
#line 1197
        memcpy((void *)(l_cblk->data + l_cblk->data_current_size), (void const   *)l_current_data,
               (unsigned long )l_seg->newlen);
        }
#line 1199
        if (l_seg->numpasses == 0U) {
#line 1200
          l_seg->data = & l_cblk->data;
#line 1201
          l_seg->dataindex = l_cblk->data_current_size;
        }
#line 1204
        l_current_data += l_seg->newlen;
#line 1205
        l_seg->numpasses += l_seg->numnewpasses;
#line 1206
        l_cblk->numnewpasses -= l_seg->numnewpasses;
#line 1208
        l_seg->real_num_passes = l_seg->numpasses;
#line 1209
        l_cblk->data_current_size += l_seg->newlen;
#line 1210
        l_seg->len += l_seg->newlen;
#line 1212
        if (l_cblk->numnewpasses > 0U) {
#line 1213
          l_seg ++;
#line 1214
          (l_cblk->numsegs) ++;
        }
#line 1150
        if (! (l_cblk->numnewpasses > 0U)) {
#line 1150
          goto while_break___1;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 1218
      l_cblk->real_num_segs = l_cblk->numsegs;
#line 1219
      l_cblk ++;
#line 1127
      cblkno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 1222
    l_band ++;
#line 1116
    bandno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 1225
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 1228
  return (1);
}
}
#line 1231 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_skip_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_pi_iterator_t *p_pi ,
                                 OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                 opj_packet_info_t *pack_info ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_precinct_t *l_prc ;
  opj_tcd_seg_t *l_seg ;

  {
#line 1240
  l_band = (opj_tcd_band_t *)0;
#line 1241
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 1242
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 1247
  *p_data_read = (OPJ_UINT32 )0;
#line 1248
  l_band = l_res->bands;
#line 1250
  bandno = (OPJ_UINT32 )0;
  {
#line 1250
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: ;
#line 1250
    if (! (bandno < l_res->numbands)) {
#line 1250
      goto while_break;
    }
#line 1251
    l_prc = l_band->precincts + p_pi->precno;
#line 1253
    if (l_band->x1 - l_band->x0 == 0) {
#line 1254
      l_band ++;
#line 1255
      goto while_continue;
    } else
#line 1253
    if (l_band->y1 - l_band->y0 == 0) {
#line 1254
      l_band ++;
#line 1255
      goto while_continue;
    }
#line 1258
    l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 1259
    l_cblk = l_prc->cblks.dec;
#line 1261
    cblkno = (OPJ_UINT32 )0;
    {
#line 1261
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: ;
#line 1261
      if (! (cblkno < l_nb_code_blocks)) {
#line 1261
        goto while_break___0;
      }
#line 1262
      l_seg = (opj_tcd_seg_t *)0;
#line 1264
      if (! l_cblk->numnewpasses) {
#line 1266
        l_cblk ++;
#line 1267
        goto while_continue___0;
      }
#line 1270
      if (! l_cblk->numsegs) {
#line 1271
        l_seg = l_cblk->segs;
#line 1272
        (l_cblk->numsegs) ++;
#line 1273
        l_cblk->data_current_size = (OPJ_UINT32 )0;
      } else {
#line 1276
        l_seg = l_cblk->segs + (l_cblk->numsegs - 1U);
#line 1278
        if (l_seg->numpasses == l_seg->maxpasses) {
#line 1279
          l_seg ++;
#line 1280
          (l_cblk->numsegs) ++;
        }
      }
      {
#line 1284
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1286
        if (*p_data_read + l_seg->newlen < *p_data_read) {
          {
#line 1287
          fprintf(stderr, "skip: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\nEV",
                  l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno, p_pi->resno,
                  p_pi->compno);
          }
#line 1289
          return (0);
        } else
#line 1286
        if (*p_data_read + l_seg->newlen > p_max_length) {
          {
#line 1287
          fprintf(stderr, "skip: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\nEV",
                  l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno, p_pi->resno,
                  p_pi->compno);
          }
#line 1289
          return (0);
        }
        {
#line 1311
        opj_null_jas_fprintf(stderr, "p_data_read (%d) newlen (%d) \n", *p_data_read,
                             l_seg->newlen);
#line 1312
        *p_data_read += l_seg->newlen;
#line 1314
        l_seg->numpasses += l_seg->numnewpasses;
#line 1315
        l_cblk->numnewpasses -= l_seg->numnewpasses;
        }
#line 1316
        if (l_cblk->numnewpasses > 0U) {
#line 1318
          l_seg ++;
#line 1319
          (l_cblk->numsegs) ++;
        }
#line 1284
        if (! (l_cblk->numnewpasses > 0U)) {
#line 1284
          goto while_break___1;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 1323
      l_cblk ++;
#line 1261
      cblkno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 1326
    l_band ++;
#line 1250
    bandno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 1329
  return (1);
}
}
#line 1333 "/root/patchweave_new/10/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_init_seg(opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 index___0 , OPJ_UINT32 cblksty ,
                         OPJ_UINT32 first ) 
{ 
  opj_tcd_seg_t *seg ;
  OPJ_UINT32 l_nb_segs ;
  opj_tcd_seg_t *new_segs ;
  void *__cil_tmp8 ;
  int tmp ;

  {
#line 1338
  seg = (opj_tcd_seg_t *)0;
#line 1339
  l_nb_segs = index___0 + 1U;
#line 1341
  if (l_nb_segs > cblk->m_current_max_segs) {
    {
#line 1343
    cblk->m_current_max_segs += 10U;
#line 1345
    __cil_tmp8 = realloc((void *)cblk->segs, (unsigned long )cblk->m_current_max_segs * sizeof(opj_tcd_seg_t ));
#line 1345
    new_segs = (opj_tcd_seg_t *)__cil_tmp8;
    }
#line 1346
    if (! new_segs) {
      {
#line 1347
      free((void *)cblk->segs);
#line 1348
      cblk->segs = (opj_tcd_seg_t *)((void *)0);
#line 1349
      cblk->m_current_max_segs = (OPJ_UINT32 )0;
      }
#line 1351
      return (0);
    }
#line 1353
    cblk->segs = new_segs;
  }
  {
#line 1356
  seg = cblk->segs + index___0;
#line 1357
  memset((void *)seg, 0, sizeof(opj_tcd_seg_t ));
  }
#line 1359
  if (cblksty & 4U) {
#line 1360
    seg->maxpasses = (OPJ_UINT32 )1;
  } else
#line 1362
  if (cblksty & 1U) {
#line 1363
    if (first) {
#line 1364
      seg->maxpasses = (OPJ_UINT32 )10;
    } else {
#line 1366
      if ((seg - 1)->maxpasses == 1U) {
#line 1366
        tmp = 2;
      } else
#line 1366
      if ((seg - 1)->maxpasses == 10U) {
#line 1366
        tmp = 2;
      } else {
#line 1366
        tmp = 1;
      }
#line 1366
      seg->maxpasses = (OPJ_UINT32 )tmp;
    }
  } else {
#line 1369
    seg->maxpasses = (OPJ_UINT32 )109;
  }
#line 1372
  return (1);
}
}
#line 3 "/root/patchweave_new/10/src/lib/openjp2/t1_luts.h"
static OPJ_BYTE lut_ctxno_zc[1024]  = 
#line 3 "/root/patchweave_new/10/src/lib/openjp2/t1_luts.h"
  {      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )0,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )6, 
        (OPJ_BYTE )3,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8};
#line 38 "/root/patchweave_new/10/src/lib/openjp2/t1_luts.h"
static OPJ_BYTE lut_ctxno_sc[256]  = 
#line 38
  {      (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )9, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )9, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )9, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )9, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13};
#line 57 "/root/patchweave_new/10/src/lib/openjp2/t1_luts.h"
static OPJ_BYTE lut_spb[256]  = 
#line 57
  {      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1};
#line 68 "/root/patchweave_new/10/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_sig[128]  = 
#line 68
  {      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )384,      (OPJ_INT16 )768,      (OPJ_INT16 )1152, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1920,      (OPJ_INT16 )2304,      (OPJ_INT16 )2688, 
        (OPJ_INT16 )3072,      (OPJ_INT16 )3456,      (OPJ_INT16 )3840,      (OPJ_INT16 )4224, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4992,      (OPJ_INT16 )5376,      (OPJ_INT16 )5760, 
        (OPJ_INT16 )6144,      (OPJ_INT16 )6528,      (OPJ_INT16 )6912,      (OPJ_INT16 )7296, 
        (OPJ_INT16 )7680,      (OPJ_INT16 )8064,      (OPJ_INT16 )8448,      (OPJ_INT16 )8832, 
        (OPJ_INT16 )9216,      (OPJ_INT16 )9600,      (OPJ_INT16 )9984,      (OPJ_INT16 )10368, 
        (OPJ_INT16 )10752,      (OPJ_INT16 )11136,      (OPJ_INT16 )11520,      (OPJ_INT16 )11904, 
        (OPJ_INT16 )12288,      (OPJ_INT16 )12672,      (OPJ_INT16 )13056,      (OPJ_INT16 )13440, 
        (OPJ_INT16 )13824,      (OPJ_INT16 )14208,      (OPJ_INT16 )14592,      (OPJ_INT16 )14976, 
        (OPJ_INT16 )15360,      (OPJ_INT16 )15744,      (OPJ_INT16 )16128,      (OPJ_INT16 )16512, 
        (OPJ_INT16 )16896,      (OPJ_INT16 )17280,      (OPJ_INT16 )17664,      (OPJ_INT16 )18048, 
        (OPJ_INT16 )18432,      (OPJ_INT16 )18816,      (OPJ_INT16 )19200,      (OPJ_INT16 )19584, 
        (OPJ_INT16 )19968,      (OPJ_INT16 )20352,      (OPJ_INT16 )20736,      (OPJ_INT16 )21120, 
        (OPJ_INT16 )21504,      (OPJ_INT16 )21888,      (OPJ_INT16 )22272,      (OPJ_INT16 )22656, 
        (OPJ_INT16 )23040,      (OPJ_INT16 )23424,      (OPJ_INT16 )23808,      (OPJ_INT16 )24192, 
        (OPJ_INT16 )24576,      (OPJ_INT16 )24960,      (OPJ_INT16 )25344,      (OPJ_INT16 )25728, 
        (OPJ_INT16 )26112,      (OPJ_INT16 )26496,      (OPJ_INT16 )26880,      (OPJ_INT16 )27264, 
        (OPJ_INT16 )27648,      (OPJ_INT16 )28032,      (OPJ_INT16 )28416,      (OPJ_INT16 )28800, 
        (OPJ_INT16 )29184,      (OPJ_INT16 )29568,      (OPJ_INT16 )29952,      (OPJ_INT16 )30336};
#line 87 "/root/patchweave_new/10/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_sig0[128]  = 
#line 87
  {      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )128,      (OPJ_INT16 )128, 
        (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )256,      (OPJ_INT16 )256, 
        (OPJ_INT16 )256,      (OPJ_INT16 )384,      (OPJ_INT16 )384,      (OPJ_INT16 )512, 
        (OPJ_INT16 )512,      (OPJ_INT16 )640,      (OPJ_INT16 )640,      (OPJ_INT16 )768, 
        (OPJ_INT16 )768,      (OPJ_INT16 )896,      (OPJ_INT16 )1024,      (OPJ_INT16 )1024, 
        (OPJ_INT16 )1152,      (OPJ_INT16 )1280,      (OPJ_INT16 )1408,      (OPJ_INT16 )1408, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1664,      (OPJ_INT16 )1792,      (OPJ_INT16 )1920, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )2176,      (OPJ_INT16 )2304,      (OPJ_INT16 )2432, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2688,      (OPJ_INT16 )2944,      (OPJ_INT16 )3072, 
        (OPJ_INT16 )3200,      (OPJ_INT16 )3328,      (OPJ_INT16 )3584,      (OPJ_INT16 )3712, 
        (OPJ_INT16 )3840,      (OPJ_INT16 )4096,      (OPJ_INT16 )4224,      (OPJ_INT16 )4480, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4864,      (OPJ_INT16 )4992,      (OPJ_INT16 )5248, 
        (OPJ_INT16 )5376,      (OPJ_INT16 )5632,      (OPJ_INT16 )5888,      (OPJ_INT16 )6016, 
        (OPJ_INT16 )6272,      (OPJ_INT16 )6528,      (OPJ_INT16 )6784,      (OPJ_INT16 )6912, 
        (OPJ_INT16 )7168,      (OPJ_INT16 )7424,      (OPJ_INT16 )7680,      (OPJ_INT16 )7936, 
        (OPJ_INT16 )8192,      (OPJ_INT16 )8448,      (OPJ_INT16 )8704,      (OPJ_INT16 )8960, 
        (OPJ_INT16 )9216,      (OPJ_INT16 )9472,      (OPJ_INT16 )9856,      (OPJ_INT16 )10112, 
        (OPJ_INT16 )10368,      (OPJ_INT16 )10624,      (OPJ_INT16 )11008,      (OPJ_INT16 )11264, 
        (OPJ_INT16 )11520,      (OPJ_INT16 )11904,      (OPJ_INT16 )12160,      (OPJ_INT16 )12544, 
        (OPJ_INT16 )12800,      (OPJ_INT16 )13184,      (OPJ_INT16 )13440,      (OPJ_INT16 )13824, 
        (OPJ_INT16 )14080,      (OPJ_INT16 )14464,      (OPJ_INT16 )14848,      (OPJ_INT16 )15104, 
        (OPJ_INT16 )15488,      (OPJ_INT16 )15872,      (OPJ_INT16 )16256,      (OPJ_INT16 )16512, 
        (OPJ_INT16 )16896,      (OPJ_INT16 )17280,      (OPJ_INT16 )17664,      (OPJ_INT16 )18048, 
        (OPJ_INT16 )18432,      (OPJ_INT16 )18816,      (OPJ_INT16 )19200,      (OPJ_INT16 )19584, 
        (OPJ_INT16 )19968,      (OPJ_INT16 )20352,      (OPJ_INT16 )20864,      (OPJ_INT16 )21248, 
        (OPJ_INT16 )21632,      (OPJ_INT16 )22016,      (OPJ_INT16 )22528,      (OPJ_INT16 )22912, 
        (OPJ_INT16 )23296,      (OPJ_INT16 )23808,      (OPJ_INT16 )24192,      (OPJ_INT16 )24704, 
        (OPJ_INT16 )25088,      (OPJ_INT16 )25600,      (OPJ_INT16 )25984,      (OPJ_INT16 )26496, 
        (OPJ_INT16 )26880,      (OPJ_INT16 )27392,      (OPJ_INT16 )27904,      (OPJ_INT16 )28288, 
        (OPJ_INT16 )28800,      (OPJ_INT16 )29312,      (OPJ_INT16 )29824,      (OPJ_INT16 )30208, 
        (OPJ_INT16 )30720,      (OPJ_INT16 )31232,      (OPJ_INT16 )31744,      (OPJ_INT16 )32256};
#line 106 "/root/patchweave_new/10/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_ref[128]  = 
#line 106
  {      (OPJ_INT16 )6144,      (OPJ_INT16 )6016,      (OPJ_INT16 )5888,      (OPJ_INT16 )5760, 
        (OPJ_INT16 )5632,      (OPJ_INT16 )5504,      (OPJ_INT16 )5376,      (OPJ_INT16 )5248, 
        (OPJ_INT16 )5120,      (OPJ_INT16 )4992,      (OPJ_INT16 )4864,      (OPJ_INT16 )4736, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4480,      (OPJ_INT16 )4352,      (OPJ_INT16 )4224, 
        (OPJ_INT16 )4096,      (OPJ_INT16 )3968,      (OPJ_INT16 )3840,      (OPJ_INT16 )3712, 
        (OPJ_INT16 )3584,      (OPJ_INT16 )3456,      (OPJ_INT16 )3328,      (OPJ_INT16 )3200, 
        (OPJ_INT16 )3072,      (OPJ_INT16 )2944,      (OPJ_INT16 )2816,      (OPJ_INT16 )2688, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2432,      (OPJ_INT16 )2304,      (OPJ_INT16 )2176, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )1920,      (OPJ_INT16 )1792,      (OPJ_INT16 )1664, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1408,      (OPJ_INT16 )1280,      (OPJ_INT16 )1152, 
        (OPJ_INT16 )1024,      (OPJ_INT16 )896,      (OPJ_INT16 )768,      (OPJ_INT16 )640, 
        (OPJ_INT16 )512,      (OPJ_INT16 )384,      (OPJ_INT16 )256,      (OPJ_INT16 )128, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )128,      (OPJ_INT16 )256,      (OPJ_INT16 )384, 
        (OPJ_INT16 )512,      (OPJ_INT16 )640,      (OPJ_INT16 )768,      (OPJ_INT16 )896, 
        (OPJ_INT16 )1024,      (OPJ_INT16 )1152,      (OPJ_INT16 )1280,      (OPJ_INT16 )1408, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1664,      (OPJ_INT16 )1792,      (OPJ_INT16 )1920, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )2176,      (OPJ_INT16 )2304,      (OPJ_INT16 )2432, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2688,      (OPJ_INT16 )2816,      (OPJ_INT16 )2944, 
        (OPJ_INT16 )3072,      (OPJ_INT16 )3200,      (OPJ_INT16 )3328,      (OPJ_INT16 )3456, 
        (OPJ_INT16 )3584,      (OPJ_INT16 )3712,      (OPJ_INT16 )3840,      (OPJ_INT16 )3968, 
        (OPJ_INT16 )4096,      (OPJ_INT16 )4224,      (OPJ_INT16 )4352,      (OPJ_INT16 )4480, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4736,      (OPJ_INT16 )4864,      (OPJ_INT16 )4992, 
        (OPJ_INT16 )5120,      (OPJ_INT16 )5248,      (OPJ_INT16 )5376,      (OPJ_INT16 )5504, 
        (OPJ_INT16 )5632,      (OPJ_INT16 )5760,      (OPJ_INT16 )5888,      (OPJ_INT16 )6016};
#line 125 "/root/patchweave_new/10/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_ref0[128]  = 
#line 125
  {      (OPJ_INT16 )8192,      (OPJ_INT16 )7936,      (OPJ_INT16 )7680,      (OPJ_INT16 )7424, 
        (OPJ_INT16 )7168,      (OPJ_INT16 )6912,      (OPJ_INT16 )6784,      (OPJ_INT16 )6528, 
        (OPJ_INT16 )6272,      (OPJ_INT16 )6016,      (OPJ_INT16 )5888,      (OPJ_INT16 )5632, 
        (OPJ_INT16 )5376,      (OPJ_INT16 )5248,      (OPJ_INT16 )4992,      (OPJ_INT16 )4864, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4480,      (OPJ_INT16 )4224,      (OPJ_INT16 )4096, 
        (OPJ_INT16 )3840,      (OPJ_INT16 )3712,      (OPJ_INT16 )3584,      (OPJ_INT16 )3328, 
        (OPJ_INT16 )3200,      (OPJ_INT16 )3072,      (OPJ_INT16 )2944,      (OPJ_INT16 )2688, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2432,      (OPJ_INT16 )2304,      (OPJ_INT16 )2176, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )1920,      (OPJ_INT16 )1792,      (OPJ_INT16 )1664, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1408,      (OPJ_INT16 )1408,      (OPJ_INT16 )1280, 
        (OPJ_INT16 )1152,      (OPJ_INT16 )1024,      (OPJ_INT16 )1024,      (OPJ_INT16 )896, 
        (OPJ_INT16 )768,      (OPJ_INT16 )768,      (OPJ_INT16 )640,      (OPJ_INT16 )640, 
        (OPJ_INT16 )512,      (OPJ_INT16 )512,      (OPJ_INT16 )384,      (OPJ_INT16 )384, 
        (OPJ_INT16 )256,      (OPJ_INT16 )256,      (OPJ_INT16 )256,      (OPJ_INT16 )128, 
        (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )128,      (OPJ_INT16 )128, 
        (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )256,      (OPJ_INT16 )256, 
        (OPJ_INT16 )256,      (OPJ_INT16 )384,      (OPJ_INT16 )384,      (OPJ_INT16 )512, 
        (OPJ_INT16 )512,      (OPJ_INT16 )640,      (OPJ_INT16 )640,      (OPJ_INT16 )768, 
        (OPJ_INT16 )768,      (OPJ_INT16 )896,      (OPJ_INT16 )1024,      (OPJ_INT16 )1024, 
        (OPJ_INT16 )1152,      (OPJ_INT16 )1280,      (OPJ_INT16 )1408,      (OPJ_INT16 )1408, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1664,      (OPJ_INT16 )1792,      (OPJ_INT16 )1920, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )2176,      (OPJ_INT16 )2304,      (OPJ_INT16 )2432, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2688,      (OPJ_INT16 )2944,      (OPJ_INT16 )3072, 
        (OPJ_INT16 )3200,      (OPJ_INT16 )3328,      (OPJ_INT16 )3584,      (OPJ_INT16 )3712, 
        (OPJ_INT16 )3840,      (OPJ_INT16 )4096,      (OPJ_INT16 )4224,      (OPJ_INT16 )4480, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4864,      (OPJ_INT16 )4992,      (OPJ_INT16 )5248, 
        (OPJ_INT16 )5376,      (OPJ_INT16 )5632,      (OPJ_INT16 )5888,      (OPJ_INT16 )6016, 
        (OPJ_INT16 )6272,      (OPJ_INT16 )6528,      (OPJ_INT16 )6784,      (OPJ_INT16 )6912, 
        (OPJ_INT16 )7168,      (OPJ_INT16 )7424,      (OPJ_INT16 )7680,      (OPJ_INT16 )7936};
#line 48 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
OPJ_BYTE opj_t1_getctxno_zc(OPJ_UINT32 f , OPJ_UINT32 orient ) ;
#line 49
OPJ_BYTE opj_t1_getctxno_sc(OPJ_UINT32 f ) ;
#line 50
OPJ_UINT32 opj_t1_getctxno_mag(OPJ_UINT32 f ) ;
#line 51
OPJ_BYTE opj_t1_getspb(OPJ_UINT32 f ) ;
#line 52
OPJ_INT16 opj_t1_getnmsedec_sig(OPJ_UINT32 x , OPJ_UINT32 bitpos ) ;
#line 53
OPJ_INT16 opj_t1_getnmsedec_ref(OPJ_UINT32 x , OPJ_UINT32 bitpos ) ;
#line 54
void opj_t1_updateflags(opj_flag_t *flagsp , OPJ_UINT32 s , OPJ_UINT32 stride ) ;
#line 58
void opj_t1_enc_sigpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_INT32 one ,
                             OPJ_INT32 *nmsedec , OPJ_BYTE type , OPJ_UINT32 vsc ) ;
#line 81
__inline static void opj_t1_dec_sigpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                                 OPJ_INT32 *datap , OPJ_INT32 orient ,
                                                 OPJ_INT32 oneplushalf , OPJ_INT32 vsc ) ;
#line 88
__inline void opj_t1_dec_sigpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 orient , OPJ_INT32 oneplushalf ) ;
#line 94
__inline void opj_t1_dec_sigpass_step_mqc_vsc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                              OPJ_INT32 *datap , OPJ_INT32 orient ,
                                              OPJ_INT32 oneplushalf , OPJ_INT32 vsc ) ;
#line 106
void opj_t1_enc_sigpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_UINT32 orient , OPJ_INT32 *nmsedec ,
                        OPJ_BYTE type , OPJ_UINT32 cblksty ) ;
#line 116
void opj_t1_dec_sigpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient , OPJ_INT32 cblksty ) ;
#line 121
void opj_t1_dec_sigpass_mqc(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ) ;
#line 125
void opj_t1_dec_sigpass_mqc_vsc(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ) ;
#line 135
void opj_t1_enc_refpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_INT32 bpno , OPJ_INT32 one , OPJ_INT32 *nmsedec ,
                             OPJ_BYTE type , OPJ_UINT32 vsc ) ;
#line 148
void opj_t1_enc_refpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 *nmsedec , OPJ_BYTE type ,
                        OPJ_UINT32 cblksty ) ;
#line 157
void opj_t1_dec_refpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 cblksty ) ;
#line 161
void opj_t1_dec_refpass_mqc(opj_t1_t *t1 , OPJ_INT32 bpno ) ;
#line 164
void opj_t1_dec_refpass_mqc_vsc(opj_t1_t *t1 , OPJ_INT32 bpno ) ;
#line 182
__inline void opj_t1_dec_refpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 poshalf , OPJ_INT32 neghalf ,
                                          OPJ_INT32 vsc ) ;
#line 189
__inline void opj_t1_dec_refpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 poshalf , OPJ_INT32 neghalf ) ;
#line 195
__inline void opj_t1_dec_refpass_step_mqc_vsc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                              OPJ_INT32 *datap , OPJ_INT32 poshalf ,
                                              OPJ_INT32 neghalf , OPJ_INT32 vsc ) ;
#line 208
void opj_t1_enc_clnpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_INT32 one ,
                             OPJ_INT32 *nmsedec , OPJ_UINT32 partial , OPJ_UINT32 vsc ) ;
#line 221
static void opj_t1_dec_clnpass_step_partial(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                            OPJ_INT32 orient , OPJ_INT32 oneplushalf ) ;
#line 227
static void opj_t1_dec_clnpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                    OPJ_INT32 orient , OPJ_INT32 oneplushalf ) ;
#line 233
static void opj_t1_dec_clnpass_step_vsc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                        OPJ_INT32 orient , OPJ_INT32 oneplushalf ,
                                        OPJ_INT32 partial , OPJ_INT32 vsc ) ;
#line 244
void opj_t1_enc_clnpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_UINT32 orient , OPJ_INT32 *nmsedec ,
                        OPJ_UINT32 cblksty ) ;
#line 253
static void opj_t1_dec_clnpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ,
                               OPJ_INT32 cblksty ) ;
#line 259
static OPJ_FLOAT64 opj_t1_getwmsedec(OPJ_INT32 nmsedec , OPJ_UINT32 compno , OPJ_UINT32 level ,
                                     OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_UINT32 qmfbid ,
                                     OPJ_FLOAT64 stepsize , OPJ_UINT32 numcomps ,
                                     OPJ_FLOAT64 *mct_norms , OPJ_UINT32 mct_numcomps ) ;
#line 271
void opj_t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , OPJ_UINT32 orient ,
                        OPJ_UINT32 compno , OPJ_UINT32 level , OPJ_UINT32 qmfbid ,
                        OPJ_FLOAT64 stepsize , OPJ_UINT32 cblksty , OPJ_UINT32 numcomps ,
                        opj_tcd_tile_t *tile , OPJ_FLOAT64 *mct_norms , OPJ_UINT32 mct_numcomps ) ;
#line 292
OPJ_BOOL opj_t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 orient ,
                            OPJ_UINT32 roishift , OPJ_UINT32 cblksty ) ;
#line 298
OPJ_BOOL opj_t1_allocate_buffers(opj_t1_t *t1 , OPJ_UINT32 w , OPJ_UINT32 h ) ;
#line 308 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
OPJ_BYTE opj_t1_getctxno_zc(OPJ_UINT32 f , OPJ_UINT32 orient ) 
{ 


  {
#line 309
  return (lut_ctxno_zc[(orient << 8) | (f & 255U)]);
}
}
#line 312 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
OPJ_BYTE opj_t1_getctxno_sc(OPJ_UINT32 f ) 
{ 


  {
#line 313
  return (lut_ctxno_sc[(f & 4080U) >> 4]);
}
}
#line 316 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
OPJ_UINT32 opj_t1_getctxno_mag(OPJ_UINT32 f ) 
{ 
  OPJ_UINT32 tmp1 ;
  int tmp ;
  OPJ_UINT32 tmp2 ;
  unsigned int tmp___0 ;

  {
#line 317
  if (f & 255U) {
#line 317
    tmp = 15;
  } else {
#line 317
    tmp = 14;
  }
#line 317
  tmp1 = (OPJ_UINT32 )tmp;
#line 318
  if (f & 8192U) {
#line 318
    tmp___0 = 16U;
  } else {
#line 318
    tmp___0 = tmp1;
  }
#line 318
  tmp2 = tmp___0;
#line 319
  return (tmp2);
}
}
#line 322 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
OPJ_BYTE opj_t1_getspb(OPJ_UINT32 f ) 
{ 


  {
#line 323
  return (lut_spb[(f & 4080U) >> 4]);
}
}
#line 326 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
OPJ_INT16 opj_t1_getnmsedec_sig(OPJ_UINT32 x , OPJ_UINT32 bitpos ) 
{ 


  {
#line 327
  if (bitpos > 6U) {
#line 328
    return (lut_nmsedec_sig[(x >> (bitpos - 6U)) & (unsigned int )((1 << 7) - 1)]);
  }
#line 331
  return (lut_nmsedec_sig0[x & (unsigned int )((1 << 7) - 1)]);
}
}
#line 334 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
OPJ_INT16 opj_t1_getnmsedec_ref(OPJ_UINT32 x , OPJ_UINT32 bitpos ) 
{ 


  {
#line 335
  if (bitpos > 6U) {
#line 336
    return (lut_nmsedec_ref[(x >> (bitpos - 6U)) & (unsigned int )((1 << 7) - 1)]);
  }
#line 339
  return (lut_nmsedec_ref0[x & (unsigned int )((1 << 7) - 1)]);
}
}
#line 346 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
static opj_flag_t mod[8]  ;
#line 342 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
void opj_t1_updateflags(opj_flag_t *flagsp , OPJ_UINT32 s , OPJ_UINT32 stride ) 
{ 
  opj_flag_t *np ;
  opj_flag_t *sp ;

  {
#line 343
  np = flagsp - stride;
#line 344
  sp = flagsp + stride;
#line 346
  mod[0] = (opj_flag_t )64;
#line 346
  mod[1] = (opj_flag_t )1088;
#line 346
  mod[2] = (opj_flag_t )32;
#line 346
  mod[3] = (opj_flag_t )544;
#line 346
  mod[4] = (opj_flag_t )128;
#line 346
  mod[5] = (opj_flag_t )2176;
#line 346
  mod[6] = (opj_flag_t )16;
#line 346
  mod[7] = (opj_flag_t )272;
#line 353
  *(np + -1) = (opj_flag_t )((int )*(np + -1) | 2);
#line 354
  *(np + 0) = (opj_flag_t )((int )*(np + 0) | (int )mod[s]);
#line 355
  *(np + 1) = (opj_flag_t )((int )*(np + 1) | 4);
#line 357
  *(flagsp + -1) = (opj_flag_t )((int )*(flagsp + -1) | (int )mod[s + 2U]);
#line 358
  *(flagsp + 0) = (opj_flag_t )((int )*(flagsp + 0) | 4096);
#line 359
  *(flagsp + 1) = (opj_flag_t )((int )*(flagsp + 1) | (int )mod[s + 4U]);
#line 361
  *(sp + -1) = (opj_flag_t )((int )*(sp + -1) | 1);
#line 362
  *(sp + 0) = (opj_flag_t )((int )*(sp + 0) | (int )mod[s + 6U]);
#line 363
  *(sp + 1) = (opj_flag_t )((int )*(sp + 1) | 8);
#line 364
  return;
}
}
#line 366 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
void opj_t1_enc_sigpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_INT32 one ,
                             OPJ_INT32 *nmsedec , OPJ_BYTE type , OPJ_UINT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_UINT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 tmp ;
  OPJ_INT32 __cil_tmp14 ;
  int tmp___0 ;
  OPJ_BYTE __cil_tmp16 ;
  int tmp___1 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT16 __cil_tmp19 ;
  OPJ_BYTE __cil_tmp20 ;
  OPJ_BYTE __cil_tmp21 ;

  {
#line 380
  mqc = t1->mqc;
#line 382
  if (vsc) {
#line 382
    tmp = (OPJ_UINT32 )((int )*flagsp & -1095);
  } else {
#line 382
    tmp = (OPJ_UINT32 )*flagsp;
  }
#line 382
  flag = tmp;
#line 383
  if (flag & 255U) {
#line 383
    if (! (flag & 20480U)) {
      {
#line 384
      __cil_tmp14 = opj_int_abs(*datap);
      }
#line 384
      if (__cil_tmp14 & one) {
#line 384
        tmp___0 = 1;
      } else {
#line 384
        tmp___0 = 0;
      }
      {
#line 384
      v = tmp___0;
#line 385
      __cil_tmp16 = opj_t1_getctxno_zc(flag, orient);
#line 385
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp16];
      }
#line 386
      if ((int )type == 1) {
        {
#line 387
        opj_mqc_bypass_enc(mqc, (OPJ_UINT32 )v);
        }
      } else {
        {
#line 389
        opj_mqc_encode(mqc, (OPJ_UINT32 )v);
        }
      }
#line 391
      if (v) {
#line 392
        if (*datap < 0) {
#line 392
          tmp___1 = 1;
        } else {
#line 392
          tmp___1 = 0;
        }
        {
#line 392
        v = tmp___1;
#line 393
        __cil_tmp18 = opj_int_abs(*datap);
#line 393
        __cil_tmp19 = opj_t1_getnmsedec_sig((OPJ_UINT32 )__cil_tmp18, (OPJ_UINT32 )(bpno + 6));
#line 393
        *nmsedec += (int )__cil_tmp19;
#line 394
        __cil_tmp20 = opj_t1_getctxno_sc(flag);
#line 394
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp20];
        }
#line 395
        if ((int )type == 1) {
          {
#line 396
          opj_mqc_bypass_enc(mqc, (OPJ_UINT32 )v);
          }
        } else {
          {
#line 398
          __cil_tmp21 = opj_t1_getspb(flag);
#line 398
          opj_mqc_encode(mqc, (OPJ_UINT32 )(v ^ (int )__cil_tmp21));
          }
        }
        {
#line 400
        opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
        }
      }
#line 402
      *flagsp = (opj_flag_t )((int )*flagsp | 16384);
    }
  }
#line 405
  return;
}
}
#line 407 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
__inline static void opj_t1_dec_sigpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                                 OPJ_INT32 *datap , OPJ_INT32 orient ,
                                                 OPJ_INT32 oneplushalf , OPJ_INT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_raw_t *raw ;
  int tmp ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_INT32 tmp___0 ;

  {
#line 416
  raw = t1->raw;
#line 419
  if (vsc) {
#line 419
    tmp = (int )*flagsp & -1095;
  } else {
#line 419
    tmp = (int )*flagsp;
  }
#line 419
  flag = tmp;
#line 420
  if (flag & 255) {
#line 420
    if (! (flag & 20480)) {
      {
#line 421
      __cil_tmp11 = opj_raw_decode(raw);
      }
#line 421
      if (__cil_tmp11) {
        {
#line 422
        __cil_tmp12 = opj_raw_decode(raw);
#line 422
        v = (OPJ_INT32 )__cil_tmp12;
        }
#line 423
        if (v) {
#line 423
          tmp___0 = - oneplushalf;
        } else {
#line 423
          tmp___0 = oneplushalf;
        }
        {
#line 423
        *datap = tmp___0;
#line 424
        opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
        }
      }
#line 426
      *flagsp = (opj_flag_t )((int )*flagsp | 16384);
    }
  }
#line 429
  return;
}
}
#line 430 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
__inline void opj_t1_dec_sigpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 orient , OPJ_INT32 oneplushalf ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_BYTE __cil_tmp9 ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_BYTE __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_BYTE __cil_tmp13 ;
  OPJ_INT32 tmp ;

  {
#line 439
  mqc = t1->mqc;
#line 441
  flag = (OPJ_INT32 )*flagsp;
#line 442
  if (flag & 255) {
#line 442
    if (! (flag & 20480)) {
      {
#line 443
      __cil_tmp9 = opj_t1_getctxno_zc((OPJ_UINT32 )flag, (OPJ_UINT32 )orient);
#line 443
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp9];
#line 444
      __cil_tmp10 = opj_mqc_decode(mqc);
      }
#line 444
      if (__cil_tmp10) {
        {
#line 445
        __cil_tmp11 = opj_t1_getctxno_sc((OPJ_UINT32 )flag);
#line 445
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp11];
#line 446
        __cil_tmp13 = opj_t1_getspb((OPJ_UINT32 )flag);
#line 446
        __cil_tmp12 = opj_mqc_decode(mqc);
#line 446
        v = __cil_tmp12 ^ (int )__cil_tmp13;
        }
#line 447
        if (v) {
#line 447
          tmp = - oneplushalf;
        } else {
#line 447
          tmp = oneplushalf;
        }
        {
#line 447
        *datap = tmp;
#line 448
        opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
        }
      }
#line 450
      *flagsp = (opj_flag_t )((int )*flagsp | 16384);
    }
  }
#line 453
  return;
}
}
#line 454 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
__inline void opj_t1_dec_sigpass_step_mqc_vsc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                              OPJ_INT32 *datap , OPJ_INT32 orient ,
                                              OPJ_INT32 oneplushalf , OPJ_INT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  OPJ_BYTE __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_BYTE __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_BYTE __cil_tmp15 ;
  OPJ_INT32 tmp___0 ;

  {
#line 464
  mqc = t1->mqc;
#line 466
  if (vsc) {
#line 466
    tmp = (int )*flagsp & -1095;
  } else {
#line 466
    tmp = (int )*flagsp;
  }
#line 466
  flag = tmp;
#line 467
  if (flag & 255) {
#line 467
    if (! (flag & 20480)) {
      {
#line 468
      __cil_tmp11 = opj_t1_getctxno_zc((OPJ_UINT32 )flag, (OPJ_UINT32 )orient);
#line 468
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp11];
#line 469
      __cil_tmp12 = opj_mqc_decode(mqc);
      }
#line 469
      if (__cil_tmp12) {
        {
#line 470
        __cil_tmp13 = opj_t1_getctxno_sc((OPJ_UINT32 )flag);
#line 470
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp13];
#line 471
        __cil_tmp15 = opj_t1_getspb((OPJ_UINT32 )flag);
#line 471
        __cil_tmp14 = opj_mqc_decode(mqc);
#line 471
        v = __cil_tmp14 ^ (int )__cil_tmp15;
        }
#line 472
        if (v) {
#line 472
          tmp___0 = - oneplushalf;
        } else {
#line 472
          tmp___0 = oneplushalf;
        }
        {
#line 472
        *datap = tmp___0;
#line 473
        opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
        }
      }
#line 475
      *flagsp = (opj_flag_t )((int )*flagsp | 16384);
    }
  }
#line 478
  return;
}
}
#line 481 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
void opj_t1_enc_sigpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_UINT32 orient , OPJ_INT32 *nmsedec ,
                        OPJ_BYTE type , OPJ_UINT32 cblksty ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 vsc ;
  OPJ_INT32 one ;
  int tmp ;

  {
#line 492
  *nmsedec = 0;
#line 493
  one = 1 << (bpno + 6);
#line 494
  k = (OPJ_UINT32 )0;
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;

#line 494
    if (! (k < t1->h)) {
#line 494
      goto while_break;
    }
#line 495
    i = (OPJ_UINT32 )0;
    {
#line 495
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 495
      if (! (i < t1->w)) {
#line 495
        goto while_break___0;
      }
#line 496
      j = k;
      {
#line 496
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 496
        if (j < k + 4U) {
#line 496
          if (! (j < t1->h)) {
#line 496
            goto while_break___1;
          }
        } else {
#line 496
          goto while_break___1;
        }
#line 497
        if (cblksty & 8U) {
#line 497
          if (j == k + 3U) {
#line 497
            tmp = 1;
          } else
#line 497
          if (j == t1->h - 1U) {
#line 497
            tmp = 1;
          } else {
#line 497
            tmp = 0;
          }
        } else {
#line 497
          tmp = 0;
        }
        {
#line 497
        vsc = (OPJ_UINT32 )tmp;
#line 498
        opj_t1_enc_sigpass_step(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                t1->data + (j * t1->data_stride + i), orient, bpno,
                                one, nmsedec, type, vsc);
#line 496
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 495
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 494
    k += 4U;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 498
  return;
}
}
#line 513 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
void opj_t1_dec_sigpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient , OPJ_INT32 cblksty ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_INT32 vsc ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  int tmp ;

  {
#line 521
  one = 1 << bpno;
#line 522
  half = one >> 1;
#line 523
  oneplushalf = one | half;
#line 524
  k = (OPJ_UINT32 )0;
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;

#line 524
    if (! (k < t1->h)) {
#line 524
      goto while_break;
    }
#line 525
    i = (OPJ_UINT32 )0;
    {
#line 525
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 525
      if (! (i < t1->w)) {
#line 525
        goto while_break___0;
      }
#line 526
      j = k;
      {
#line 526
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 526
        if (j < k + 4U) {
#line 526
          if (! (j < t1->h)) {
#line 526
            goto while_break___1;
          }
        } else {
#line 526
          goto while_break___1;
        }
#line 527
        if (cblksty & 8) {
#line 527
          if (j == k + 3U) {
#line 527
            tmp = 1;
          } else
#line 527
          if (j == t1->h - 1U) {
#line 527
            tmp = 1;
          } else {
#line 527
            tmp = 0;
          }
        } else {
#line 527
          tmp = 0;
        }
        {
#line 527
        vsc = tmp;
#line 528
        opj_t1_dec_sigpass_step_raw(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                    t1->data + (j * t1->w + i), orient, oneplushalf,
                                    vsc);
#line 526
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 525
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 524
    k += 4U;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 528
  return;
}
}
#line 540 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
void opj_t1_dec_sigpass_mqc(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 *data1 ;
  opj_flag_t *flags1 ;
  OPJ_INT32 *data2 ;
  opj_flag_t *flags2 ;
  OPJ_INT32 *data2___0 ;
  opj_flag_t *flags2___0 ;

  {
#line 547
  data1 = t1->data;
#line 548
  flags1 = t1->flags + 1;
#line 549
  one = 1 << bpno;
#line 550
  half = one >> 1;
#line 551
  oneplushalf = one | half;
#line 552
  k = (OPJ_UINT32 )0;
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;

#line 552
    if (! (k < (t1->h & 4294967292U))) {
#line 552
      goto while_break;
    }
#line 553
    i = (OPJ_UINT32 )0;
    {
#line 553
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 553
      if (! (i < t1->w)) {
#line 553
        goto while_break___0;
      }
      {
#line 554
      data2 = data1 + i;
#line 555
      flags2 = flags1 + i;
#line 556
      flags2 += t1->flags_stride;
#line 557
      opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 558
      data2 += t1->w;
#line 559
      flags2 += t1->flags_stride;
#line 560
      opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 561
      data2 += t1->w;
#line 562
      flags2 += t1->flags_stride;
#line 563
      opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 564
      data2 += t1->w;
#line 565
      flags2 += t1->flags_stride;
#line 566
      opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 567
      data2 += t1->w;
#line 553
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 569
    data1 += t1->w << 2;
#line 570
    flags1 += t1->flags_stride << 2;
#line 552
    k += 4U;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 572
  i = (OPJ_UINT32 )0;
  {
#line 572
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 572
    if (! (i < t1->w)) {
#line 572
      goto while_break___1;
    }
#line 573
    data2___0 = data1 + i;
#line 574
    flags2___0 = flags1 + i;
#line 575
    j = k;
    {
#line 575
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 575
      if (! (j < t1->h)) {
#line 575
        goto while_break___2;
      }
      {
#line 576
      flags2___0 += t1->flags_stride;
#line 577
      opj_t1_dec_sigpass_step_mqc(t1, flags2___0, data2___0, orient, oneplushalf);
#line 578
      data2___0 += t1->w;
#line 575
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 572
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 576
  return;
}
}
#line 583 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
void opj_t1_dec_sigpass_mqc_vsc(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_INT32 vsc ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  int tmp ;

  {
#line 590
  one = 1 << bpno;
#line 591
  half = one >> 1;
#line 592
  oneplushalf = one | half;
#line 593
  k = (OPJ_UINT32 )0;
  {
#line 593
  while (1) {
    while_continue: /* CIL Label */ ;

#line 593
    if (! (k < t1->h)) {
#line 593
      goto while_break;
    }
#line 594
    i = (OPJ_UINT32 )0;
    {
#line 594
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 594
      if (! (i < t1->w)) {
#line 594
        goto while_break___0;
      }
#line 595
      j = k;
      {
#line 595
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 595
        if (j < k + 4U) {
#line 595
          if (! (j < t1->h)) {
#line 595
            goto while_break___1;
          }
        } else {
#line 595
          goto while_break___1;
        }
#line 596
        if (j == k + 3U) {
#line 596
          tmp = 1;
        } else
#line 596
        if (j == t1->h - 1U) {
#line 596
          tmp = 1;
        } else {
#line 596
          tmp = 0;
        }
        {
#line 596
        vsc = tmp;
#line 597
        opj_t1_dec_sigpass_step_mqc_vsc(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                        t1->data + (j * t1->w + i), orient, oneplushalf,
                                        vsc);
#line 595
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 594
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 593
    k += 4U;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 597
  return;
}
}
#line 611 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
void opj_t1_enc_refpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_INT32 bpno , OPJ_INT32 one , OPJ_INT32 *nmsedec ,
                             OPJ_BYTE type , OPJ_UINT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_UINT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 tmp ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT16 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  int tmp___0 ;
  OPJ_UINT32 __cil_tmp17 ;

  {
#line 623
  mqc = t1->mqc;
#line 625
  if (vsc) {
#line 625
    tmp = (OPJ_UINT32 )((int )*flagsp & -1095);
  } else {
#line 625
    tmp = (OPJ_UINT32 )*flagsp;
  }
#line 625
  flag = tmp;
#line 626
  if ((flag & 20480U) == 4096U) {
    {
#line 627
    __cil_tmp13 = opj_int_abs(*datap);
#line 627
    __cil_tmp14 = opj_t1_getnmsedec_ref((OPJ_UINT32 )__cil_tmp13, (OPJ_UINT32 )(bpno + 6));
#line 627
    *nmsedec += (int )__cil_tmp14;
#line 628
    __cil_tmp15 = opj_int_abs(*datap);
    }
#line 628
    if (__cil_tmp15 & one) {
#line 628
      tmp___0 = 1;
    } else {
#line 628
      tmp___0 = 0;
    }
    {
#line 628
    v = tmp___0;
#line 629
    __cil_tmp17 = opj_t1_getctxno_mag(flag);
#line 629
    mqc->curctx = & mqc->ctxs[__cil_tmp17];
    }
#line 630
    if ((int )type == 1) {
      {
#line 631
      opj_mqc_bypass_enc(mqc, (OPJ_UINT32 )v);
      }
    } else {
      {
#line 633
      opj_mqc_encode(mqc, (OPJ_UINT32 )v);
      }
    }
#line 635
    *flagsp = (opj_flag_t )((int )*flagsp | 8192);
  }
#line 637
  return;
}
}
#line 639 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
__inline void opj_t1_dec_refpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 poshalf , OPJ_INT32 neghalf ,
                                          OPJ_INT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 t ;
  OPJ_INT32 flag ;
  opj_raw_t *raw ;
  int tmp ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 tmp___1 ;

  {
#line 649
  raw = t1->raw;
#line 651
  if (vsc) {
#line 651
    tmp = (int )*flagsp & -1095;
  } else {
#line 651
    tmp = (int )*flagsp;
  }
#line 651
  flag = tmp;
#line 652
  if ((flag & 20480) == 4096) {
    {
#line 653
    __cil_tmp12 = opj_raw_decode(raw);
#line 653
    v = (OPJ_INT32 )__cil_tmp12;
    }
#line 654
    if (v) {
#line 654
      tmp___0 = poshalf;
    } else {
#line 654
      tmp___0 = neghalf;
    }
#line 654
    t = tmp___0;
#line 655
    if (*datap < 0) {
#line 655
      tmp___1 = - t;
    } else {
#line 655
      tmp___1 = t;
    }
#line 655
    *datap += tmp___1;
#line 656
    *flagsp = (opj_flag_t )((int )*flagsp | 8192);
  }
#line 658
  return;
}
}
#line 660 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
__inline void opj_t1_dec_refpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 poshalf , OPJ_INT32 neghalf ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 t ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_INT32 tmp ;
  OPJ_INT32 tmp___0 ;

  {
#line 669
  mqc = t1->mqc;
#line 671
  flag = (OPJ_INT32 )*flagsp;
#line 672
  if ((flag & 20480) == 4096) {
    {
#line 673
    __cil_tmp10 = opj_t1_getctxno_mag((OPJ_UINT32 )flag);
#line 673
    mqc->curctx = & mqc->ctxs[__cil_tmp10];
#line 674
    v = opj_mqc_decode(mqc);
    }
#line 675
    if (v) {
#line 675
      tmp = poshalf;
    } else {
#line 675
      tmp = neghalf;
    }
#line 675
    t = tmp;
#line 676
    if (*datap < 0) {
#line 676
      tmp___0 = - t;
    } else {
#line 676
      tmp___0 = t;
    }
#line 676
    *datap += tmp___0;
#line 677
    *flagsp = (opj_flag_t )((int )*flagsp | 8192);
  }
#line 679
  return;
}
}
#line 681 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
__inline void opj_t1_dec_refpass_step_mqc_vsc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                              OPJ_INT32 *datap , OPJ_INT32 poshalf ,
                                              OPJ_INT32 neghalf , OPJ_INT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 t ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 tmp___1 ;

  {
#line 691
  mqc = t1->mqc;
#line 693
  if (vsc) {
#line 693
    tmp = (int )*flagsp & -1095;
  } else {
#line 693
    tmp = (int )*flagsp;
  }
#line 693
  flag = tmp;
#line 694
  if ((flag & 20480) == 4096) {
    {
#line 695
    __cil_tmp12 = opj_t1_getctxno_mag((OPJ_UINT32 )flag);
#line 695
    mqc->curctx = & mqc->ctxs[__cil_tmp12];
#line 696
    v = opj_mqc_decode(mqc);
    }
#line 697
    if (v) {
#line 697
      tmp___0 = poshalf;
    } else {
#line 697
      tmp___0 = neghalf;
    }
#line 697
    t = tmp___0;
#line 698
    if (*datap < 0) {
#line 698
      tmp___1 = - t;
    } else {
#line 698
      tmp___1 = t;
    }
#line 698
    *datap += tmp___1;
#line 699
    *flagsp = (opj_flag_t )((int )*flagsp | 8192);
  }
#line 701
  return;
}
}
#line 704 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
void opj_t1_enc_refpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 *nmsedec , OPJ_BYTE type ,
                        OPJ_UINT32 cblksty ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 vsc ;
  OPJ_INT32 one ;
  int tmp ;

  {
#line 714
  *nmsedec = 0;
#line 715
  one = 1 << (bpno + 6);
#line 716
  k = (OPJ_UINT32 )0;
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;

#line 716
    if (! (k < t1->h)) {
#line 716
      goto while_break;
    }
#line 717
    i = (OPJ_UINT32 )0;
    {
#line 717
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 717
      if (! (i < t1->w)) {
#line 717
        goto while_break___0;
      }
#line 718
      j = k;
      {
#line 718
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 718
        if (j < k + 4U) {
#line 718
          if (! (j < t1->h)) {
#line 718
            goto while_break___1;
          }
        } else {
#line 718
          goto while_break___1;
        }
#line 719
        if (cblksty & 8U) {
#line 719
          if (j == k + 3U) {
#line 719
            tmp = 1;
          } else
#line 719
          if (j == t1->h - 1U) {
#line 719
            tmp = 1;
          } else {
#line 719
            tmp = 0;
          }
        } else {
#line 719
          tmp = 0;
        }
        {
#line 719
        vsc = (OPJ_UINT32 )tmp;
#line 720
        opj_t1_enc_refpass_step(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                t1->data + (j * t1->data_stride + i), bpno, one, nmsedec,
                                type, vsc);
#line 718
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 717
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 716
    k += 4U;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 720
  return;
}
}
#line 734 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
void opj_t1_dec_refpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 cblksty ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 poshalf ;
  OPJ_INT32 neghalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 vsc ;
  OPJ_INT32 tmp ;
  int tmp___0 ;

  {
#line 742
  one = 1 << bpno;
#line 743
  poshalf = one >> 1;
#line 744
  if (bpno > 0) {
#line 744
    tmp = - poshalf;
  } else {
#line 744
    tmp = -1;
  }
#line 744
  neghalf = tmp;
#line 745
  k = (OPJ_UINT32 )0;
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;

#line 745
    if (! (k < t1->h)) {
#line 745
      goto while_break;
    }
#line 746
    i = (OPJ_UINT32 )0;
    {
#line 746
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 746
      if (! (i < t1->w)) {
#line 746
        goto while_break___0;
      }
#line 747
      j = k;
      {
#line 747
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 747
        if (j < k + 4U) {
#line 747
          if (! (j < t1->h)) {
#line 747
            goto while_break___1;
          }
        } else {
#line 747
          goto while_break___1;
        }
#line 748
        if (cblksty & 8) {
#line 748
          if (j == k + 3U) {
#line 748
            tmp___0 = 1;
          } else
#line 748
          if (j == t1->h - 1U) {
#line 748
            tmp___0 = 1;
          } else {
#line 748
            tmp___0 = 0;
          }
        } else {
#line 748
          tmp___0 = 0;
        }
        {
#line 748
        vsc = tmp___0;
#line 749
        opj_t1_dec_refpass_step_raw(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                    t1->data + (j * t1->w + i), poshalf, neghalf,
                                    vsc);
#line 747
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 746
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 745
    k += 4U;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 749
  return;
}
}
#line 761 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
void opj_t1_dec_refpass_mqc(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 poshalf ;
  OPJ_INT32 neghalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 *data1 ;
  opj_flag_t *flags1 ;
  OPJ_INT32 tmp ;
  OPJ_INT32 *data2 ;
  opj_flag_t *flags2 ;
  OPJ_INT32 *data2___0 ;
  opj_flag_t *flags2___0 ;

  {
#line 767
  data1 = t1->data;
#line 768
  flags1 = t1->flags + 1;
#line 769
  one = 1 << bpno;
#line 770
  poshalf = one >> 1;
#line 771
  if (bpno > 0) {
#line 771
    tmp = - poshalf;
  } else {
#line 771
    tmp = -1;
  }
#line 771
  neghalf = tmp;
#line 772
  k = (OPJ_UINT32 )0;
  {
#line 772
  while (1) {
    while_continue: /* CIL Label */ ;

#line 772
    if (! (k < (t1->h & 4294967292U))) {
#line 772
      goto while_break;
    }
#line 773
    i = (OPJ_UINT32 )0;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 773
      if (! (i < t1->w)) {
#line 773
        goto while_break___0;
      }
      {
#line 774
      data2 = data1 + i;
#line 775
      flags2 = flags1 + i;
#line 776
      flags2 += t1->flags_stride;
#line 777
      opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 778
      data2 += t1->w;
#line 779
      flags2 += t1->flags_stride;
#line 780
      opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 781
      data2 += t1->w;
#line 782
      flags2 += t1->flags_stride;
#line 783
      opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 784
      data2 += t1->w;
#line 785
      flags2 += t1->flags_stride;
#line 786
      opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 787
      data2 += t1->w;
#line 773
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 789
    data1 += t1->w << 2;
#line 790
    flags1 += t1->flags_stride << 2;
#line 772
    k += 4U;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 792
  i = (OPJ_UINT32 )0;
  {
#line 792
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 792
    if (! (i < t1->w)) {
#line 792
      goto while_break___1;
    }
#line 793
    data2___0 = data1 + i;
#line 794
    flags2___0 = flags1 + i;
#line 795
    j = k;
    {
#line 795
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 795
      if (! (j < t1->h)) {
#line 795
        goto while_break___2;
      }
      {
#line 796
      flags2___0 += t1->flags_stride;
#line 797
      opj_t1_dec_refpass_step_mqc(t1, flags2___0, data2___0, poshalf, neghalf);
#line 798
      data2___0 += t1->w;
#line 795
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 792
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 796
  return;
}
}
#line 803 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
void opj_t1_dec_refpass_mqc_vsc(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 poshalf ;
  OPJ_INT32 neghalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 vsc ;
  OPJ_INT32 tmp ;
  int tmp___0 ;

  {
#line 810
  one = 1 << bpno;
#line 811
  poshalf = one >> 1;
#line 812
  if (bpno > 0) {
#line 812
    tmp = - poshalf;
  } else {
#line 812
    tmp = -1;
  }
#line 812
  neghalf = tmp;
#line 813
  k = (OPJ_UINT32 )0;
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;

#line 813
    if (! (k < t1->h)) {
#line 813
      goto while_break;
    }
#line 814
    i = (OPJ_UINT32 )0;
    {
#line 814
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 814
      if (! (i < t1->w)) {
#line 814
        goto while_break___0;
      }
#line 815
      j = k;
      {
#line 815
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 815
        if (j < k + 4U) {
#line 815
          if (! (j < t1->h)) {
#line 815
            goto while_break___1;
          }
        } else {
#line 815
          goto while_break___1;
        }
#line 816
        if (j == k + 3U) {
#line 816
          tmp___0 = 1;
        } else
#line 816
        if (j == t1->h - 1U) {
#line 816
          tmp___0 = 1;
        } else {
#line 816
          tmp___0 = 0;
        }
        {
#line 816
        vsc = tmp___0;
#line 817
        opj_t1_dec_refpass_step_mqc_vsc(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                        t1->data + (j * t1->w + i), poshalf, neghalf,
                                        vsc);
#line 815
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 814
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 813
    k += 4U;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 817
  return;
}
}
#line 830 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
void opj_t1_enc_clnpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_INT32 one ,
                             OPJ_INT32 *nmsedec , OPJ_UINT32 partial , OPJ_UINT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_UINT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 tmp ;
  OPJ_BYTE __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  int tmp___0 ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_INT16 __cil_tmp18 ;
  OPJ_BYTE __cil_tmp19 ;
  int tmp___1 ;
  OPJ_BYTE __cil_tmp21 ;

  {
#line 844
  mqc = t1->mqc;
#line 846
  if (vsc) {
#line 846
    tmp = (OPJ_UINT32 )((int )*flagsp & -1095);
  } else {
#line 846
    tmp = (OPJ_UINT32 )*flagsp;
  }
#line 846
  flag = tmp;
#line 847
  if (partial) {
#line 848
    goto LABEL_PARTIAL;
  }
#line 850
  if (! ((int )*flagsp & 20480)) {
    {
#line 851
    __cil_tmp14 = opj_t1_getctxno_zc(flag, orient);
#line 851
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp14];
#line 852
    __cil_tmp15 = opj_int_abs(*datap);
    }
#line 852
    if (__cil_tmp15 & one) {
#line 852
      tmp___0 = 1;
    } else {
#line 852
      tmp___0 = 0;
    }
    {
#line 852
    v = tmp___0;
#line 853
    opj_mqc_encode(mqc, (OPJ_UINT32 )v);
    }
#line 854
    if (v) {
      LABEL_PARTIAL: 
      {
#line 856
      __cil_tmp17 = opj_int_abs(*datap);
#line 856
      __cil_tmp18 = opj_t1_getnmsedec_sig((OPJ_UINT32 )__cil_tmp17, (OPJ_UINT32 )(bpno + 6));
#line 856
      *nmsedec += (int )__cil_tmp18;
#line 857
      __cil_tmp19 = opj_t1_getctxno_sc(flag);
#line 857
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp19];
      }
#line 858
      if (*datap < 0) {
#line 858
        tmp___1 = 1;
      } else {
#line 858
        tmp___1 = 0;
      }
      {
#line 858
      v = tmp___1;
#line 859
      __cil_tmp21 = opj_t1_getspb(flag);
#line 859
      opj_mqc_encode(mqc, (OPJ_UINT32 )(v ^ (int )__cil_tmp21));
#line 860
      opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
      }
    }
  }
#line 863
  *flagsp = (opj_flag_t )((int )*flagsp & -16385);
#line 864
  return;
}
}
#line 866 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass_step_partial(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                            OPJ_INT32 orient , OPJ_INT32 oneplushalf ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_BYTE __cil_tmp9 ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_BYTE __cil_tmp11 ;
  OPJ_INT32 tmp ;

  {
  {
#line 874
  mqc = t1->mqc;
#line 878
  flag = (OPJ_INT32 )*flagsp;
#line 879
  __cil_tmp9 = opj_t1_getctxno_sc((OPJ_UINT32 )flag);
#line 879
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp9];
#line 880
  __cil_tmp11 = opj_t1_getspb((OPJ_UINT32 )flag);
#line 880
  __cil_tmp10 = opj_mqc_decode(mqc);
#line 880
  v = __cil_tmp10 ^ (int )__cil_tmp11;
  }
#line 881
  if (v) {
#line 881
    tmp = - oneplushalf;
  } else {
#line 881
    tmp = oneplushalf;
  }
  {
#line 881
  *datap = tmp;
#line 882
  opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
#line 883
  *flagsp = (opj_flag_t )((int )*flagsp & -16385);
  }
#line 885
  return;
}
}
#line 886 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                    OPJ_INT32 orient , OPJ_INT32 oneplushalf ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_BYTE __cil_tmp9 ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_BYTE __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_BYTE __cil_tmp13 ;
  OPJ_INT32 tmp ;

  {
#line 895
  mqc = t1->mqc;
#line 897
  flag = (OPJ_INT32 )*flagsp;
#line 898
  if (! (flag & 20480)) {
    {
#line 899
    __cil_tmp9 = opj_t1_getctxno_zc((OPJ_UINT32 )flag, (OPJ_UINT32 )orient);
#line 899
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp9];
#line 900
    __cil_tmp10 = opj_mqc_decode(mqc);
    }
#line 900
    if (__cil_tmp10) {
      {
#line 901
      __cil_tmp11 = opj_t1_getctxno_sc((OPJ_UINT32 )flag);
#line 901
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp11];
#line 902
      __cil_tmp13 = opj_t1_getspb((OPJ_UINT32 )flag);
#line 902
      __cil_tmp12 = opj_mqc_decode(mqc);
#line 902
      v = __cil_tmp12 ^ (int )__cil_tmp13;
      }
#line 903
      if (v) {
#line 903
        tmp = - oneplushalf;
      } else {
#line 903
        tmp = oneplushalf;
      }
      {
#line 903
      *datap = tmp;
#line 904
      opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
      }
    }
  }
#line 907
  *flagsp = (opj_flag_t )((int )*flagsp & -16385);
#line 908
  return;
}
}
#line 910 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass_step_vsc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                        OPJ_INT32 orient , OPJ_INT32 oneplushalf ,
                                        OPJ_INT32 partial , OPJ_INT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  OPJ_BYTE __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_BYTE __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_BYTE __cil_tmp16 ;
  OPJ_INT32 tmp___0 ;

  {
#line 921
  mqc = t1->mqc;
#line 923
  if (vsc) {
#line 923
    tmp = (int )*flagsp & -1095;
  } else {
#line 923
    tmp = (int )*flagsp;
  }
#line 923
  flag = tmp;
#line 924
  if (partial) {
#line 925
    goto LABEL_PARTIAL;
  }
#line 927
  if (! (flag & 20480)) {
    {
#line 928
    __cil_tmp12 = opj_t1_getctxno_zc((OPJ_UINT32 )flag, (OPJ_UINT32 )orient);
#line 928
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp12];
#line 929
    __cil_tmp13 = opj_mqc_decode(mqc);
    }
#line 929
    if (__cil_tmp13) {
      LABEL_PARTIAL: 
      {
#line 931
      __cil_tmp14 = opj_t1_getctxno_sc((OPJ_UINT32 )flag);
#line 931
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp14];
#line 932
      __cil_tmp16 = opj_t1_getspb((OPJ_UINT32 )flag);
#line 932
      __cil_tmp15 = opj_mqc_decode(mqc);
#line 932
      v = __cil_tmp15 ^ (int )__cil_tmp16;
      }
#line 933
      if (v) {
#line 933
        tmp___0 = - oneplushalf;
      } else {
#line 933
        tmp___0 = oneplushalf;
      }
      {
#line 933
      *datap = tmp___0;
#line 934
      opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
      }
    }
  }
#line 937
  *flagsp = (opj_flag_t )((int )*flagsp & -16385);
#line 938
  return;
}
}
#line 940 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
void opj_t1_enc_clnpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_UINT32 orient , OPJ_INT32 *nmsedec ,
                        OPJ_UINT32 cblksty ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 one ;
  OPJ_UINT32 agg ;
  OPJ_UINT32 runlen ;
  OPJ_UINT32 vsc ;
  opj_mqc_t *mqc ;
  OPJ_INT32 __cil_tmp14 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 951
  mqc = t1->mqc;
#line 953
  *nmsedec = 0;
#line 954
  one = 1 << (bpno + 6);
#line 955
  k = (OPJ_UINT32 )0;
  {
#line 955
  while (1) {
    while_continue: /* CIL Label */ ;

#line 955
    if (! (k < t1->h)) {
#line 955
      goto while_break;
    }
#line 956
    i = (OPJ_UINT32 )0;
    {
#line 956
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue___0: ;
#line 956
      if (! (i < t1->w)) {
#line 956
        goto while_break___0;
      }
#line 957
      if (k + 3U < t1->h) {
#line 958
        if (cblksty & 8U) {
#line 959
          if ((int )*(t1->flags + ((1U + k) * t1->flags_stride + (1U + i))) & 20735) {
#line 959
            tmp___0 = 0;
          } else
#line 959
          if ((int )*(t1->flags + (((1U + k) + 1U) * t1->flags_stride + (1U + i))) & 20735) {
#line 959
            tmp___0 = 0;
          } else
#line 959
          if ((int )*(t1->flags + (((1U + k) + 2U) * t1->flags_stride + (1U + i))) & 20735) {
#line 959
            tmp___0 = 0;
          } else
#line 959
          if (((int )*(t1->flags + (((1U + k) + 3U) * t1->flags_stride + (1U + i))) & -1095) & 20735) {
#line 959
            tmp___0 = 0;
          } else {
#line 959
            tmp___0 = 1;
          }
#line 959
          agg = (OPJ_UINT32 )tmp___0;
        } else {
#line 965
          if ((int )*(t1->flags + ((1U + k) * t1->flags_stride + (1U + i))) & 20735) {
#line 965
            tmp___1 = 0;
          } else
#line 965
          if ((int )*(t1->flags + (((1U + k) + 1U) * t1->flags_stride + (1U + i))) & 20735) {
#line 965
            tmp___1 = 0;
          } else
#line 965
          if ((int )*(t1->flags + (((1U + k) + 2U) * t1->flags_stride + (1U + i))) & 20735) {
#line 965
            tmp___1 = 0;
          } else
#line 965
          if ((int )*(t1->flags + (((1U + k) + 3U) * t1->flags_stride + (1U + i))) & 20735) {
#line 965
            tmp___1 = 0;
          } else {
#line 965
            tmp___1 = 1;
          }
#line 965
          agg = (OPJ_UINT32 )tmp___1;
        }
      } else {
#line 971
        agg = (OPJ_UINT32 )0;
      }
#line 973
      if (agg) {
#line 974
        runlen = (OPJ_UINT32 )0;
        {
#line 974
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 974
          if (! (runlen < 4U)) {
#line 974
            goto while_break___1;
          }
          {
#line 975
          __cil_tmp14 = opj_int_abs(*(t1->data + ((k + runlen) * t1->data_stride + i)));
          }
#line 975
          if (__cil_tmp14 & one) {
#line 976
            goto while_break___1;
          }
#line 974
          runlen ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: 
        {
#line 978
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )17];
#line 979
        opj_mqc_encode(mqc, (OPJ_UINT32 )(runlen != 4U));
        }
#line 980
        if (runlen == 4U) {
#line 981
          goto while_continue___0;
        }
        {
#line 983
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 984
        opj_mqc_encode(mqc, runlen >> 1);
#line 985
        opj_mqc_encode(mqc, runlen & 1U);
        }
      } else {
#line 987
        runlen = (OPJ_UINT32 )0;
      }
#line 989
      j = k + runlen;
      {
#line 989
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 989
        if (j < k + 4U) {
#line 989
          if (! (j < t1->h)) {
#line 989
            goto while_break___2;
          }
        } else {
#line 989
          goto while_break___2;
        }
#line 990
        if (cblksty & 8U) {
#line 990
          if (j == k + 3U) {
#line 990
            tmp = 1;
          } else
#line 990
          if (j == t1->h - 1U) {
#line 990
            tmp = 1;
          } else {
#line 990
            tmp = 0;
          }
        } else {
#line 990
          tmp = 0;
        }
#line 990
        vsc = (OPJ_UINT32 )tmp;
#line 991
        if (agg) {
#line 991
          if (j == k + runlen) {
#line 991
            tmp___2 = 1;
          } else {
#line 991
            tmp___2 = 0;
          }
        } else {
#line 991
          tmp___2 = 0;
        }
        {
#line 991
        opj_t1_enc_clnpass_step(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                t1->data + (j * t1->data_stride + i), orient, bpno,
                                one, nmsedec, (OPJ_UINT32 )tmp___2, vsc);
#line 989
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 956
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 955
    k += 4U;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 959
  return;
}
}
#line 1006 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ,
                               OPJ_INT32 cblksty ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_INT32 agg ;
  OPJ_INT32 runlen ;
  OPJ_INT32 vsc ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 segsym ;
  opj_mqc_t *mqc ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 __cil_tmp18 ;
  int tmp ;
  OPJ_INT32 *data1 ;
  opj_flag_t *flags1 ;
  OPJ_INT32 *data2 ;
  opj_flag_t *flags2 ;
  OPJ_INT32 __cil_tmp24 ;
  OPJ_INT32 __cil_tmp26 ;
  OPJ_INT32 *data2___0 ;
  opj_flag_t *flags2___0 ;
  OPJ_INT32 v ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_INT32 __cil_tmp32 ;
  OPJ_INT32 __cil_tmp33 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1014
  segsym = cblksty & 32;
#line 1016
  mqc = t1->mqc;
#line 1018
  one = 1 << bpno;
#line 1019
  half = one >> 1;
#line 1020
  oneplushalf = one | half;
#line 1021
  if (cblksty & 8) {
#line 1022
    k = (OPJ_UINT32 )0;
    {
#line 1022
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1022
      if (! (k < t1->h)) {
#line 1022
        goto while_break;
      }
#line 1023
      i = (OPJ_UINT32 )0;
      {
#line 1023
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: ;
#line 1023
        if (! (i < t1->w)) {
#line 1023
          goto while_break___0;
        }
#line 1024
        if (k + 3U < t1->h) {
#line 1025
          if ((int )*(t1->flags + ((1U + k) * t1->flags_stride + (1U + i))) & 20735) {
#line 1025
            tmp___0 = 0;
          } else
#line 1025
          if ((int )*(t1->flags + (((1U + k) + 1U) * t1->flags_stride + (1U + i))) & 20735) {
#line 1025
            tmp___0 = 0;
          } else
#line 1025
          if ((int )*(t1->flags + (((1U + k) + 2U) * t1->flags_stride + (1U + i))) & 20735) {
#line 1025
            tmp___0 = 0;
          } else
#line 1025
          if (((int )*(t1->flags + (((1U + k) + 3U) * t1->flags_stride + (1U + i))) & -1095) & 20735) {
#line 1025
            tmp___0 = 0;
          } else {
#line 1025
            tmp___0 = 1;
          }
#line 1025
          agg = tmp___0;
        } else {
#line 1031
          agg = 0;
        }
#line 1033
        if (agg) {
          {
#line 1034
          mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )17];
#line 1035
          __cil_tmp16 = opj_mqc_decode(mqc);
          }
#line 1035
          if (! __cil_tmp16) {
#line 1036
            goto while_continue___0;
          }
          {
#line 1038
          mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 1039
          runlen = opj_mqc_decode(mqc);
#line 1040
          __cil_tmp18 = opj_mqc_decode(mqc);
#line 1040
          runlen = (runlen << 1) | __cil_tmp18;
          }
        } else {
#line 1042
          runlen = 0;
        }
#line 1044
        j = k + (OPJ_UINT32 )runlen;
        {
#line 1044
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 1044
          if (j < k + 4U) {
#line 1044
            if (! (j < t1->h)) {
#line 1044
              goto while_break___1;
            }
          } else {
#line 1044
            goto while_break___1;
          }
#line 1045
          if (j == k + 3U) {
#line 1045
            tmp = 1;
          } else
#line 1045
          if (j == t1->h - 1U) {
#line 1045
            tmp = 1;
          } else {
#line 1045
            tmp = 0;
          }
#line 1045
          vsc = tmp;
#line 1046
          if (agg) {
#line 1046
            if (j == k + (OPJ_UINT32 )runlen) {
#line 1046
              tmp___1 = 1;
            } else {
#line 1046
              tmp___1 = 0;
            }
          } else {
#line 1046
            tmp___1 = 0;
          }
          {
#line 1046
          opj_t1_dec_clnpass_step_vsc(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                      t1->data + (j * t1->w + i), orient, oneplushalf,
                                      tmp___1, vsc);
#line 1044
          j ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___1: 
#line 1023
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___0: 
#line 1022
      k += 4U;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 1058
    data1 = t1->data;
#line 1059
    flags1 = t1->flags + 1;
#line 1060
    k = (OPJ_UINT32 )0;
    {
#line 1060
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 1060
      if (! (k < (t1->h & 4294967292U))) {
#line 1060
        goto while_break___2;
      }
#line 1061
      i = (OPJ_UINT32 )0;
      {
#line 1061
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___3: ;
#line 1061
        if (! (i < t1->w)) {
#line 1061
          goto while_break___3;
        }
#line 1062
        data2 = data1 + i;
#line 1063
        flags2 = flags1 + i;
#line 1064
        if ((int )*(t1->flags + ((1U + k) * t1->flags_stride + (1U + i))) & 20735) {
#line 1064
          tmp___2 = 0;
        } else
#line 1064
        if ((int )*(t1->flags + (((1U + k) + 1U) * t1->flags_stride + (1U + i))) & 20735) {
#line 1064
          tmp___2 = 0;
        } else
#line 1064
        if ((int )*(t1->flags + (((1U + k) + 2U) * t1->flags_stride + (1U + i))) & 20735) {
#line 1064
          tmp___2 = 0;
        } else
#line 1064
        if ((int )*(t1->flags + (((1U + k) + 3U) * t1->flags_stride + (1U + i))) & 20735) {
#line 1064
          tmp___2 = 0;
        } else {
#line 1064
          tmp___2 = 1;
        }
#line 1064
        agg = tmp___2;
#line 1068
        if (agg) {
          {
#line 1069
          mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )17];
#line 1070
          __cil_tmp24 = opj_mqc_decode(mqc);
          }
#line 1070
          if (! __cil_tmp24) {
#line 1071
            goto while_continue___3;
          }
          {
#line 1073
          mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 1074
          runlen = opj_mqc_decode(mqc);
#line 1075
          __cil_tmp26 = opj_mqc_decode(mqc);
#line 1075
          runlen = (runlen << 1) | __cil_tmp26;
#line 1076
          flags2 += (OPJ_UINT32 )runlen * t1->flags_stride;
#line 1077
          data2 += (OPJ_UINT32 )runlen * t1->w;
#line 1078
          j = k + (OPJ_UINT32 )runlen;
          }
          {
#line 1078
          while (1) {
            while_continue___8: /* CIL Label */ ;

#line 1078
            if (j < k + 4U) {
#line 1078
              if (! (j < t1->h)) {
#line 1078
                goto while_break___4;
              }
            } else {
#line 1078
              goto while_break___4;
            }
#line 1079
            flags2 += t1->flags_stride;
#line 1080
            if (agg) {
#line 1080
              if (j == k + (OPJ_UINT32 )runlen) {
                {
#line 1081
                opj_t1_dec_clnpass_step_partial(t1, flags2, data2, orient, oneplushalf);
                }
              } else {
                {
#line 1083
                opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
                }
              }
            } else {
              {
#line 1083
              opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
              }
            }
#line 1085
            data2 += t1->w;
#line 1078
            j ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___4: ;
        } else {
          {
#line 1088
          flags2 += t1->flags_stride;
#line 1089
          opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1090
          data2 += t1->w;
#line 1091
          flags2 += t1->flags_stride;
#line 1092
          opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1093
          data2 += t1->w;
#line 1094
          flags2 += t1->flags_stride;
#line 1095
          opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1096
          data2 += t1->w;
#line 1097
          flags2 += t1->flags_stride;
#line 1098
          opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1099
          data2 += t1->w;
          }
        }
#line 1061
        i ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___3: 
#line 1102
      data1 += t1->w << 2;
#line 1103
      flags1 += t1->flags_stride << 2;
#line 1060
      k += 4U;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___2: 
#line 1105
    i = (OPJ_UINT32 )0;
    {
#line 1105
    while (1) {
      while_continue___9: /* CIL Label */ ;

#line 1105
      if (! (i < t1->w)) {
#line 1105
        goto while_break___5;
      }
#line 1106
      data2___0 = data1 + i;
#line 1107
      flags2___0 = flags1 + i;
#line 1108
      j = k;
      {
#line 1108
      while (1) {
        while_continue___10: /* CIL Label */ ;

#line 1108
        if (! (j < t1->h)) {
#line 1108
          goto while_break___6;
        }
        {
#line 1109
        flags2___0 += t1->flags_stride;
#line 1110
        opj_t1_dec_clnpass_step(t1, flags2___0, data2___0, orient, oneplushalf);
#line 1111
        data2___0 += t1->w;
#line 1108
        j ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___6: 
#line 1105
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___5: ;
  }
#line 1116
  if (segsym) {
    {
#line 1117
    v = 0;
#line 1118
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 1119
    v = opj_mqc_decode(mqc);
#line 1120
    __cil_tmp31 = opj_mqc_decode(mqc);
#line 1120
    v = (v << 1) | __cil_tmp31;
#line 1121
    __cil_tmp32 = opj_mqc_decode(mqc);
#line 1121
    v = (v << 1) | __cil_tmp32;
#line 1122
    __cil_tmp33 = opj_mqc_decode(mqc);
#line 1122
    v = (v << 1) | __cil_tmp33;
    }
  }
#line 1125
  return;
}
}
#line 1133 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
static OPJ_FLOAT64 opj_t1_getwmsedec(OPJ_INT32 nmsedec , OPJ_UINT32 compno , OPJ_UINT32 level ,
                                     OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_UINT32 qmfbid ,
                                     OPJ_FLOAT64 stepsize , OPJ_UINT32 numcomps ,
                                     OPJ_FLOAT64 *mct_norms , OPJ_UINT32 mct_numcomps ) 
{ 
  OPJ_FLOAT64 w1 ;
  OPJ_FLOAT64 w2 ;
  OPJ_FLOAT64 wmsedec ;

  {
#line 1145
  w1 = (OPJ_FLOAT64 )1;
#line 1148
  if (mct_norms) {
#line 1148
    if (compno < mct_numcomps) {
#line 1149
      w1 = *(mct_norms + compno);
    }
  }
#line 1152
  if (qmfbid == 1U) {
    {
#line 1153
    w2 = opj_dwt_getnorm(level, orient);
    }
  } else {
    {
#line 1155
    w2 = opj_dwt_getnorm_real(level, orient);
    }
  }
#line 1158
  wmsedec = ((w1 * w2) * stepsize) * (double )(1 << bpno);
#line 1159
  wmsedec *= (wmsedec * (double )nmsedec) / 8192.;
#line 1161
  return (wmsedec);
}
}
#line 1164 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
OPJ_BOOL opj_t1_allocate_buffers(opj_t1_t *t1 , OPJ_UINT32 w , OPJ_UINT32 h ) 
{ 
  OPJ_UINT32 datasize ;
  OPJ_UINT32 flagssize ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 1169
  datasize = w * h;
#line 1173
  if (! t1->encoder) {
#line 1174
    if (datasize > t1->datasize) {
      {
#line 1175
      free((void *)t1->data);
#line 1176
      __cil_tmp6 = malloc((unsigned long )datasize * sizeof(OPJ_INT32 ));
#line 1176
      t1->data = (OPJ_INT32 *)__cil_tmp6;
      }
#line 1177
      if (! t1->data) {
#line 1179
        return (0);
      }
#line 1181
      t1->datasize = datasize;
    }
    {
#line 1183
    memset((void *)t1->data, 0, (unsigned long )datasize * sizeof(OPJ_INT32 ));
    }
  }
#line 1185
  t1->flags_stride = w + 2U;
#line 1186
  flagssize = t1->flags_stride * (h + 2U);
#line 1188
  if (flagssize > t1->flagssize) {
    {
#line 1189
    free((void *)t1->flags);
#line 1190
    __cil_tmp7 = malloc((unsigned long )flagssize * sizeof(opj_flag_t ));
#line 1190
    t1->flags = (opj_flag_t *)__cil_tmp7;
    }
#line 1191
    if (! t1->flags) {
#line 1193
      return (0);
    }
#line 1195
    t1->flagssize = flagssize;
  }
  {
#line 1197
  memset((void *)t1->flags, 0, (unsigned long )flagssize * sizeof(opj_flag_t ));
#line 1199
  t1->w = w;
#line 1200
  t1->h = h;
  }
#line 1202
  return (1);
}
}
#line 1213 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
opj_t1_t *opj_t1_create(OPJ_BOOL isEncoder ) 
{ 
  opj_t1_t *l_t1 ;
  void *__cil_tmp3 ;

  {
  {
#line 1215
  l_t1 = (opj_t1_t *)0;
#line 1217
  __cil_tmp3 = calloc(1UL, sizeof(opj_t1_t ));
#line 1217
  l_t1 = (opj_t1_t *)__cil_tmp3;
  }
#line 1218
  if (! l_t1) {
#line 1219
    return ((opj_t1_t *)0);
  }
  {
#line 1223
  l_t1->mqc = opj_mqc_create();
  }
#line 1224
  if (! l_t1->mqc) {
    {
#line 1225
    opj_t1_destroy(l_t1);
    }
#line 1226
    return ((opj_t1_t *)0);
  }
  {
#line 1229
  l_t1->raw = opj_raw_create();
  }
#line 1230
  if (! l_t1->raw) {
    {
#line 1231
    opj_t1_destroy(l_t1);
    }
#line 1232
    return ((opj_t1_t *)0);
  }
#line 1234
  l_t1->encoder = isEncoder;
#line 1236
  return (l_t1);
}
}
#line 1245 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
void opj_t1_destroy(opj_t1_t *p_t1 ) 
{ 


  {
#line 1247
  if (! p_t1) {
#line 1248
    return;
  }
  {
#line 1252
  opj_mqc_destroy(p_t1->mqc);
#line 1253
  p_t1->mqc = (opj_mqc_t *)0;
#line 1254
  opj_raw_destroy(p_t1->raw);
#line 1255
  p_t1->raw = (opj_raw_t *)0;
  }
#line 1258
  if (p_t1->data) {
#line 1258
    if (! p_t1->encoder) {
      {
#line 1259
      free((void *)p_t1->data);
#line 1260
      p_t1->data = (OPJ_INT32 *)0;
      }
    }
  }
#line 1263
  if (p_t1->flags) {
    {
#line 1264
    free((void *)p_t1->flags);
#line 1265
    p_t1->flags = (opj_flag_t *)0;
    }
  }
  {
#line 1268
  free((void *)p_t1);
  }
#line 1270
  return;
}
}
#line 1271 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
OPJ_BOOL opj_t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) 
{ 
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *precinct ;
  opj_tcd_cblk_dec_t *cblk ;
  OPJ_INT32 *datap ;
  OPJ_UINT32 cblk_w ;
  OPJ_UINT32 cblk_h ;
  OPJ_INT32 x ;
  OPJ_INT32 y ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_BOOL __cil_tmp20 ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  OPJ_INT32 thresh ;
  OPJ_INT32 val ;
  OPJ_INT32 mag ;
  int __cil_tmp26 ;
  OPJ_INT32 tmp ;
  OPJ_INT32 *tiledp ;
  OPJ_INT32 tmp___0 ;
  OPJ_FLOAT32 *tiledp___0 ;
  OPJ_FLOAT32 *tiledp2 ;
  OPJ_FLOAT32 tmp___1 ;

  {
#line 1277
  tile_w = (OPJ_UINT32 )(tilec->x1 - tilec->x0);
#line 1279
  resno = (OPJ_UINT32 )0;
  {
#line 1279
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1279
    if (! (resno < tilec->minimum_num_resolutions)) {
#line 1279
      goto while_break;
    }
#line 1280
    res = tilec->resolutions + resno;
#line 1282
    bandno = (OPJ_UINT32 )0;
    {
#line 1282
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1282
      if (! (bandno < res->numbands)) {
#line 1282
        goto while_break___0;
      }
#line 1283
      band = & res->bands[bandno];
#line 1285
      precno = (OPJ_UINT32 )0;
      {
#line 1285
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1285
        if (! (precno < res->pw * res->ph)) {
#line 1285
          goto while_break___1;
        }
#line 1286
        precinct = band->precincts + precno;
#line 1288
        cblkno = (OPJ_UINT32 )0;
        {
#line 1288
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1288
          if (! (cblkno < precinct->cw * precinct->ch)) {
#line 1288
            goto while_break___2;
          }
          {
#line 1289
          cblk = precinct->cblks.dec + cblkno;
#line 1296
          __cil_tmp20 = opj_t1_decode_cblk(t1, cblk, band->bandno, (OPJ_UINT32 )tccp->roishift,
                                           tccp->cblksty);
          }
#line 1296
          if (0 == __cil_tmp20) {
#line 1302
            return (0);
          }
#line 1305
          x = cblk->x0 - band->x0;
#line 1306
          y = cblk->y0 - band->y0;
#line 1307
          if (band->bandno & 1U) {
#line 1308
            pres = tilec->resolutions + (resno - 1U);
#line 1309
            x += pres->x1 - pres->x0;
          }
#line 1311
          if (band->bandno & 2U) {
#line 1312
            pres___0 = tilec->resolutions + (resno - 1U);
#line 1313
            y += pres___0->y1 - pres___0->y0;
          }
#line 1316
          datap = t1->data;
#line 1317
          cblk_w = t1->w;
#line 1318
          cblk_h = t1->h;
#line 1320
          if (tccp->roishift) {
#line 1321
            thresh = 1 << tccp->roishift;
#line 1322
            j = (OPJ_UINT32 )0;
            {
#line 1322
            while (1) {
              while_continue___3: /* CIL Label */ ;

#line 1322
              if (! (j < cblk_h)) {
#line 1322
                goto while_break___3;
              }
#line 1323
              i = (OPJ_UINT32 )0;
              {
#line 1323
              while (1) {
                while_continue___4: /* CIL Label */ ;

#line 1323
                if (! (i < cblk_w)) {
#line 1323
                  goto while_break___4;
                }
                {
#line 1324
                val = *(datap + (j * cblk_w + i));
#line 1325
                __cil_tmp26 = abs(val);
#line 1325
                mag = __cil_tmp26;
                }
#line 1326
                if (mag >= thresh) {
#line 1327
                  mag >>= tccp->roishift;
#line 1328
                  if (val < 0) {
#line 1328
                    tmp = - mag;
                  } else {
#line 1328
                    tmp = mag;
                  }
#line 1328
                  *(datap + (j * cblk_w + i)) = tmp;
                }
#line 1323
                i ++;
              }
              while_break___14: /* CIL Label */ ;
              }
              while_break___4: 
#line 1322
              j ++;
            }
            while_break___13: /* CIL Label */ ;
            }
            while_break___3: ;
          }
#line 1335
          if (tccp->qmfbid == 1U) {
#line 1336
            tiledp = tilec->data + ((OPJ_UINT32 )y * tile_w + (OPJ_UINT32 )x);
#line 1337
            j = (OPJ_UINT32 )0;
            {
#line 1337
            while (1) {
              while_continue___5: /* CIL Label */ ;

#line 1337
              if (! (j < cblk_h)) {
#line 1337
                goto while_break___5;
              }
#line 1338
              i = (OPJ_UINT32 )0;
              {
#line 1338
              while (1) {
                while_continue___6: /* CIL Label */ ;

#line 1338
                if (! (i < cblk_w)) {
#line 1338
                  goto while_break___6;
                }
#line 1339
                tmp___0 = *(datap + (j * cblk_w + i));
#line 1340
                *(tiledp + (j * tile_w + i)) = tmp___0 / 2;
#line 1338
                i ++;
              }
              while_break___16: /* CIL Label */ ;
              }
              while_break___6: 
#line 1337
              j ++;
            }
            while_break___15: /* CIL Label */ ;
            }
            while_break___5: ;
          } else {
#line 1344
            tiledp___0 = (OPJ_FLOAT32 *)(tilec->data + ((OPJ_UINT32 )y * tile_w + (OPJ_UINT32 )x));
#line 1345
            j = (OPJ_UINT32 )0;
            {
#line 1345
            while (1) {
              while_continue___7: /* CIL Label */ ;

#line 1345
              if (! (j < cblk_h)) {
#line 1345
                goto while_break___7;
              }
#line 1346
              tiledp2 = tiledp___0;
#line 1347
              i = (OPJ_UINT32 )0;
              {
#line 1347
              while (1) {
                while_continue___8: /* CIL Label */ ;

#line 1347
                if (! (i < cblk_w)) {
#line 1347
                  goto while_break___8;
                }
#line 1348
                tmp___1 = (OPJ_FLOAT32 )*datap * band->stepsize;
#line 1349
                *tiledp2 = tmp___1;
#line 1350
                datap ++;
#line 1351
                tiledp2 ++;
#line 1347
                i ++;
              }
              while_break___18: /* CIL Label */ ;
              }
              while_break___8: 
#line 1356
              tiledp___0 += tile_w;
#line 1345
              j ++;
            }
            while_break___17: /* CIL Label */ ;
            }
            while_break___7: ;
          }
#line 1288
          cblkno ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___2: 
#line 1285
        precno ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___1: 
#line 1282
      bandno ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___0: 
#line 1279
    resno ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break: ;
#line 1367
  return (1);
}
}
#line 1371 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
OPJ_BOOL opj_t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 orient ,
                            OPJ_UINT32 roishift , OPJ_UINT32 cblksty ) 
{ 
  opj_raw_t *raw ;
  opj_mqc_t *mqc ;
  OPJ_INT32 bpno ;
  OPJ_UINT32 passtype ;
  OPJ_UINT32 segno ;
  OPJ_UINT32 passno ;
  OPJ_BYTE type ;
  OPJ_BOOL __cil_tmp13 ;
  opj_tcd_seg_t *seg ;
  int tmp ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_INT32 __cil_tmp17 ;

  {
  {
#line 1377
  raw = t1->raw;
#line 1378
  mqc = t1->mqc;
#line 1383
  type = (OPJ_BYTE )0;
#line 1385
  __cil_tmp13 = opj_t1_allocate_buffers(t1, (OPJ_UINT32 )(cblk->x1 - cblk->x0), (OPJ_UINT32 )(cblk->y1 - cblk->y0));
  }
#line 1385
  if (! __cil_tmp13) {
#line 1390
    return (0);
  }
  {
#line 1393
  bpno = (OPJ_INT32 )((roishift + cblk->numbps) - 1U);
#line 1394
  passtype = (OPJ_UINT32 )2;
#line 1396
  opj_mqc_resetstates(mqc);
#line 1397
  opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 1398
  opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 1399
  opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
#line 1401
  segno = (OPJ_UINT32 )0;
  }
  {
#line 1401
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1401
    if (! (segno < cblk->real_num_segs)) {
#line 1401
      goto while_break;
    }
#line 1402
    seg = cblk->segs + segno;
#line 1405
    if (bpno <= ((OPJ_INT32 )cblk->numbps - 1) - 4) {
#line 1405
      if (passtype < 2U) {
#line 1405
        if (cblksty & 1U) {
#line 1405
          tmp = 1;
        } else {
#line 1405
          tmp = 0;
        }
      } else {
#line 1405
        tmp = 0;
      }
    } else {
#line 1405
      tmp = 0;
    }
#line 1405
    type = (OPJ_BYTE )tmp;
#line 1407
    if ((unsigned long )seg->data == (unsigned long )((OPJ_BYTE **)0)) {
#line 1408
      goto while_continue;
    }
#line 1410
    if ((int )type == 1) {
      {
#line 1411
      opj_raw_init_dec(raw, *(seg->data) + seg->dataindex, seg->len);
      }
    } else {
      {
#line 1413
      __cil_tmp16 = opj_mqc_init_dec(mqc, *(seg->data) + seg->dataindex, seg->len);
      }
#line 1413
      if (0 == __cil_tmp16) {
#line 1414
        return (0);
      }
    }
#line 1418
    passno = (OPJ_UINT32 )0;
    {
#line 1418
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1418
      if (! (passno < seg->real_num_passes)) {
#line 1418
        goto while_break___0;
      }
#line 1420
      if (passtype == 0U) {
#line 1420
        goto case_0;
      }
#line 1431
      if (passtype == 1U) {
#line 1431
        goto case_1;
      }
#line 1442
      if (passtype == 2U) {
#line 1442
        goto case_2;
      }
#line 1419
      goto switch_break;
      case_0: 
#line 1421
      if ((int )type == 1) {
        {
#line 1422
        opj_t1_dec_sigpass_raw(t1, bpno + 1, (OPJ_INT32 )orient, (OPJ_INT32 )cblksty);
        }
      } else
#line 1424
      if (cblksty & 8U) {
        {
#line 1425
        opj_t1_dec_sigpass_mqc_vsc(t1, bpno + 1, (OPJ_INT32 )orient);
        }
      } else {
        {
#line 1427
        opj_t1_dec_sigpass_mqc(t1, bpno + 1, (OPJ_INT32 )orient);
        }
      }
#line 1430
      goto switch_break;
      case_1: 
#line 1432
      if ((int )type == 1) {
        {
#line 1433
        opj_t1_dec_refpass_raw(t1, bpno + 1, (OPJ_INT32 )cblksty);
        }
      } else
#line 1435
      if (cblksty & 8U) {
        {
#line 1436
        opj_t1_dec_refpass_mqc_vsc(t1, bpno + 1);
        }
      } else {
        {
#line 1438
        opj_t1_dec_refpass_mqc(t1, bpno + 1);
        }
      }
#line 1441
      goto switch_break;
      case_2: 
      {
#line 1443
      opj_t1_dec_clnpass(t1, bpno + 1, (OPJ_INT32 )orient, (OPJ_INT32 )cblksty);
      }
#line 1444
      goto switch_break;
      switch_break: ;
#line 1447
      if (cblksty & 2U) {
#line 1447
        if ((int )type == 0) {
          {
#line 1448
          opj_mqc_resetstates(mqc);
#line 1449
          opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 1450
          opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 1451
          opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
          }
        }
      }
#line 1453
      passtype ++;
#line 1453
      if (passtype == 3U) {
#line 1454
        passtype = (OPJ_UINT32 )0;
#line 1455
        __cil_tmp17 = bpno;
#line 1455
        bpno --;
      }
#line 1418
      passno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 1401
    segno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1459
  return (1);
}
}
#line 1465 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
OPJ_BOOL opj_t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                             OPJ_FLOAT64 *mct_norms , OPJ_UINT32 mct_numcomps ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tccp_t *tccp ;
  OPJ_UINT32 tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  OPJ_INT32 bandconst ;
  double __cil_tmp17 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  OPJ_INT32 *tiledp ;
  OPJ_UINT32 cblk_w ;
  OPJ_UINT32 cblk_h ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 tileIndex ;
  OPJ_UINT32 tileLineAdvance ;
  OPJ_INT32 x ;
  OPJ_INT32 y ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  OPJ_BOOL __cil_tmp31 ;
  OPJ_INT32 tmp ;
  OPJ_INT32 __cil_tmp34 ;

  {
#line 1474
  tile->distotile = (OPJ_FLOAT64 )0;
#line 1476
  compno = (OPJ_UINT32 )0;
  {
#line 1476
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1476
    if (! (compno < tile->numcomps)) {
#line 1476
      goto while_break;
    }
#line 1477
    tilec = tile->comps + compno;
#line 1478
    tccp = tcp->tccps + compno;
#line 1479
    tile_w = (OPJ_UINT32 )(tilec->x1 - tilec->x0);
#line 1481
    resno = (OPJ_UINT32 )0;
    {
#line 1481
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1481
      if (! (resno < tilec->numresolutions)) {
#line 1481
        goto while_break___0;
      }
#line 1482
      res = tilec->resolutions + resno;
#line 1484
      bandno = (OPJ_UINT32 )0;
      {
#line 1484
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1484
        if (! (bandno < res->numbands)) {
#line 1484
          goto while_break___1;
        }
        {
#line 1485
        band = & res->bands[bandno];
#line 1486
        __cil_tmp17 = floor((double )(band->stepsize * (float )8192));
#line 1486
        bandconst = 67108864 / (OPJ_INT32 )__cil_tmp17;
#line 1488
        precno = (OPJ_UINT32 )0;
        }
        {
#line 1488
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1488
          if (! (precno < res->pw * res->ph)) {
#line 1488
            goto while_break___2;
          }
#line 1489
          prc = band->precincts + precno;
#line 1491
          cblkno = (OPJ_UINT32 )0;
          {
#line 1491
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 1491
            if (! (cblkno < prc->cw * prc->ch)) {
#line 1491
              goto while_break___3;
            }
#line 1492
            cblk = prc->cblks.enc + cblkno;
#line 1496
            tileIndex = (OPJ_UINT32 )0;
#line 1498
            x = cblk->x0 - band->x0;
#line 1499
            y = cblk->y0 - band->y0;
#line 1500
            if (band->bandno & 1U) {
#line 1501
              pres = tilec->resolutions + (resno - 1U);
#line 1502
              x += pres->x1 - pres->x0;
            }
#line 1504
            if (band->bandno & 2U) {
#line 1505
              pres___0 = tilec->resolutions + (resno - 1U);
#line 1506
              y += pres___0->y1 - pres___0->y0;
            }
            {
#line 1509
            __cil_tmp31 = opj_t1_allocate_buffers(t1, (OPJ_UINT32 )(cblk->x1 - cblk->x0),
                                                  (OPJ_UINT32 )(cblk->y1 - cblk->y0));
            }
#line 1509
            if (! __cil_tmp31) {
#line 1514
              return (0);
            }
#line 1517
            cblk_w = t1->w;
#line 1518
            cblk_h = t1->h;
#line 1519
            tileLineAdvance = tile_w - cblk_w;
#line 1521
            tiledp = tilec->data + ((OPJ_UINT32 )y * tile_w + (OPJ_UINT32 )x);
#line 1522
            t1->data = tiledp;
#line 1523
            t1->data_stride = tile_w;
#line 1524
            if (tccp->qmfbid == 1U) {
#line 1525
              j = (OPJ_UINT32 )0;
              {
#line 1525
              while (1) {
                while_continue___4: /* CIL Label */ ;

#line 1525
                if (! (j < cblk_h)) {
#line 1525
                  goto while_break___4;
                }
#line 1526
                i = (OPJ_UINT32 )0;
                {
#line 1526
                while (1) {
                  while_continue___5: /* CIL Label */ ;

#line 1526
                  if (! (i < cblk_w)) {
#line 1526
                    goto while_break___5;
                  }
#line 1527
                  *(tiledp + tileIndex) <<= 6;
#line 1528
                  tileIndex ++;
#line 1526
                  i ++;
                }
                while_break___14: /* CIL Label */ ;
                }
                while_break___5: 
#line 1530
                tileIndex += tileLineAdvance;
#line 1525
                j ++;
              }
              while_break___13: /* CIL Label */ ;
              }
              while_break___4: ;
            } else {
#line 1533
              j = (OPJ_UINT32 )0;
              {
#line 1533
              while (1) {
                while_continue___6: /* CIL Label */ ;

#line 1533
                if (! (j < cblk_h)) {
#line 1533
                  goto while_break___6;
                }
#line 1534
                i = (OPJ_UINT32 )0;
                {
#line 1534
                while (1) {
                  while_continue___7: /* CIL Label */ ;

#line 1534
                  if (! (i < cblk_w)) {
#line 1534
                    goto while_break___7;
                  }
                  {
#line 1535
                  tmp = *(tiledp + tileIndex);
#line 1536
                  __cil_tmp34 = opj_int_fix_mul(tmp, bandconst);
#line 1536
                  *(tiledp + tileIndex) = __cil_tmp34 >> 5;
#line 1540
                  tileIndex ++;
#line 1534
                  i ++;
                  }
                }
                while_break___16: /* CIL Label */ ;
                }
                while_break___7: 
#line 1542
                tileIndex += tileLineAdvance;
#line 1533
                j ++;
              }
              while_break___15: /* CIL Label */ ;
              }
              while_break___6: ;
            }
            {
#line 1546
            opj_t1_encode_cblk(t1, cblk, band->bandno, compno, (tilec->numresolutions - 1U) - resno,
                               tccp->qmfbid, (OPJ_FLOAT64 )band->stepsize, tccp->cblksty,
                               tile->numcomps, tile, mct_norms, mct_numcomps);
#line 1491
            cblkno ++;
            }
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___3: 
#line 1488
          precno ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___2: 
#line 1484
        bandno ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___1: 
#line 1481
      resno ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___0: 
#line 1476
    compno ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: ;
#line 1565
  return (1);
}
}
#line 1569 "/root/patchweave_new/10/src/lib/openjp2/t1.c"
void opj_t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , OPJ_UINT32 orient ,
                        OPJ_UINT32 compno , OPJ_UINT32 level , OPJ_UINT32 qmfbid ,
                        OPJ_FLOAT64 stepsize , OPJ_UINT32 cblksty , OPJ_UINT32 numcomps ,
                        opj_tcd_tile_t *tile , OPJ_FLOAT64 *mct_norms , OPJ_UINT32 mct_numcomps ) 
{ 
  OPJ_FLOAT64 cumwmsedec ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 passno ;
  OPJ_INT32 bpno ;
  OPJ_UINT32 passtype ;
  OPJ_INT32 nmsedec ;
  OPJ_INT32 max ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_BYTE type ;
  OPJ_FLOAT64 tempwmsedec ;
  OPJ_INT32 tmp ;
  int __cil_tmp25 ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_UINT32 tmp___0 ;
  opj_tcd_pass_t *pass ;
  OPJ_UINT32 correction ;
  int tmp___1 ;
  OPJ_INT32 __cil_tmp33 ;
  int tmp___2 ;
  OPJ_UINT32 __cil_tmp35 ;
  opj_tcd_pass_t *pass___0 ;
  OPJ_UINT32 __cil_tmp37 ;
  OPJ_UINT32 __cil_tmp39 ;
  unsigned int tmp___3 ;

  {
#line 1582
  cumwmsedec = 0.;
#line 1584
  mqc = t1->mqc;
#line 1589
  nmsedec = 0;
#line 1592
  type = (OPJ_BYTE )0;
#line 1595
  max = 0;
#line 1596
  i = (OPJ_UINT32 )0;
  {
#line 1596
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1596
    if (! (i < t1->w)) {
#line 1596
      goto while_break;
    }
#line 1597
    j = (OPJ_UINT32 )0;
    {
#line 1597
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1597
      if (! (j < t1->h)) {
#line 1597
        goto while_break___0;
      }
      {
#line 1598
      __cil_tmp25 = abs(*(t1->data + (i + j * t1->data_stride)));
#line 1598
      tmp = __cil_tmp25;
#line 1599
      max = opj_int_max(max, tmp);
#line 1597
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 1596
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 1603
  if (max) {
    {
#line 1603
    __cil_tmp27 = opj_int_floorlog2(max);
#line 1603
    tmp___0 = (OPJ_UINT32 )((__cil_tmp27 + 1) - 6);
    }
  } else {
#line 1603
    tmp___0 = 0U;
  }
  {
#line 1603
  cblk->numbps = tmp___0;
#line 1605
  bpno = (OPJ_INT32 )(cblk->numbps - 1U);
#line 1606
  passtype = (OPJ_UINT32 )2;
#line 1608
  opj_mqc_resetstates(mqc);
#line 1609
  opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 1610
  opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 1611
  opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
#line 1612
  opj_mqc_init_enc(mqc, cblk->data);
#line 1614
  passno = (OPJ_UINT32 )0;
  }
  {
#line 1614
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 1614
    if (! (bpno >= 0)) {
#line 1614
      goto while_break___1;
    }
#line 1615
    pass = cblk->passes + passno;
#line 1616
    correction = (OPJ_UINT32 )3;
#line 1617
    if (bpno < (OPJ_INT32 )cblk->numbps - 4) {
#line 1617
      if (passtype < 2U) {
#line 1617
        if (cblksty & 1U) {
#line 1617
          tmp___1 = 1;
        } else {
#line 1617
          tmp___1 = 0;
        }
      } else {
#line 1617
        tmp___1 = 0;
      }
    } else {
#line 1617
      tmp___1 = 0;
    }
#line 1617
    type = (OPJ_BYTE )tmp___1;
#line 1620
    if (passtype == 0U) {
#line 1620
      goto case_0;
    }
#line 1623
    if (passtype == 1U) {
#line 1623
      goto case_1;
    }
#line 1626
    if (passtype == 2U) {
#line 1626
      goto case_2;
    }
#line 1619
    goto switch_break;
    case_0: 
    {
#line 1621
    opj_t1_enc_sigpass(t1, bpno, orient, & nmsedec, type, cblksty);
    }
#line 1622
    goto switch_break;
    case_1: 
    {
#line 1624
    opj_t1_enc_refpass(t1, bpno, & nmsedec, type, cblksty);
    }
#line 1625
    goto switch_break;
    case_2: 
    {
#line 1627
    opj_t1_enc_clnpass(t1, bpno, orient, & nmsedec, cblksty);
    }
#line 1629
    if (cblksty & 32U) {
      {
#line 1630
      opj_mqc_segmark_enc(mqc);
      }
    }
#line 1631
    goto switch_break;
    switch_break: 
    {
#line 1635
    tempwmsedec = opj_t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid,
                                    stepsize, numcomps, mct_norms, mct_numcomps);
#line 1636
    cumwmsedec += tempwmsedec;
#line 1637
    tile->distotile += tempwmsedec;
    }
#line 1640
    if (cblksty & 4U) {
#line 1640
      if (passtype == 2U) {
#line 1640
        if (bpno - 1 < 0) {
#line 1640
          goto _L___8;
        } else {
#line 1640
          goto _L___9;
        }
      } else {
        _L___9: /* CIL Label */ 
#line 1641
        if ((int )type == 1) {
          {
#line 1642
          opj_mqc_flush(mqc);
#line 1643
          correction = (OPJ_UINT32 )1;
          }
        } else {
          {
#line 1646
          opj_mqc_flush(mqc);
#line 1647
          correction = (OPJ_UINT32 )1;
          }
        }
#line 1649
        pass->term = (OPJ_UINT32 )1;
      }
    } else
    _L___8: 
#line 1651
    if (bpno < (OPJ_INT32 )cblk->numbps - 4) {
#line 1651
      if (passtype > 0U) {
        _L: 
#line 1651
        if (cblksty & 1U) {
#line 1653
          if ((int )type == 1) {
            {
#line 1654
            opj_mqc_flush(mqc);
#line 1655
            correction = (OPJ_UINT32 )1;
            }
          } else {
            {
#line 1658
            opj_mqc_flush(mqc);
#line 1659
            correction = (OPJ_UINT32 )1;
            }
          }
#line 1661
          pass->term = (OPJ_UINT32 )1;
        } else {
#line 1663
          pass->term = (OPJ_UINT32 )0;
        }
      } else {
#line 1651
        goto _L___7;
      }
    } else
    _L___7: 
#line 1651
    if (bpno == (OPJ_INT32 )cblk->numbps - 4) {
#line 1651
      if (passtype == 2U) {
#line 1651
        goto _L;
      } else {
#line 1663
        pass->term = (OPJ_UINT32 )0;
      }
    } else {
#line 1663
      pass->term = (OPJ_UINT32 )0;
    }
#line 1667
    passtype ++;
#line 1667
    if (passtype == 3U) {
#line 1668
      passtype = (OPJ_UINT32 )0;
#line 1669
      __cil_tmp33 = bpno;
#line 1669
      bpno --;
    }
#line 1672
    if ((int )pass->term) {
#line 1672
      if (bpno > 0) {
#line 1673
        if (bpno < (OPJ_INT32 )cblk->numbps - 4) {
#line 1673
          if (passtype < 2U) {
#line 1673
            if (cblksty & 1U) {
#line 1673
              tmp___2 = 1;
            } else {
#line 1673
              tmp___2 = 0;
            }
          } else {
#line 1673
            tmp___2 = 0;
          }
        } else {
#line 1673
          tmp___2 = 0;
        }
#line 1673
        type = (OPJ_BYTE )tmp___2;
#line 1674
        if ((int )type == 1) {
          {
#line 1675
          opj_mqc_bypass_init_enc(mqc);
          }
        } else {
          {
#line 1677
          opj_mqc_restart_init_enc(mqc);
          }
        }
      }
    }
    {
#line 1680
    pass->distortiondec = cumwmsedec;
#line 1681
    __cil_tmp35 = opj_mqc_numbytes(mqc);
#line 1681
    pass->rate = __cil_tmp35 + correction;
    }
#line 1684
    if (cblksty & 2U) {
      {
#line 1685
      opj_mqc_reset_enc(mqc);
      }
    }
#line 1614
    passno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 1689
  if (cblksty & 16U) {
    {
#line 1690
    opj_mqc_erterm_enc(mqc);
    }
  } else
#line 1691
  if (! (cblksty & 1U)) {
    {
#line 1692
    opj_mqc_flush(mqc);
    }
  }
#line 1694
  cblk->totalpasses = passno;
#line 1696
  passno = (OPJ_UINT32 )0;
  {
#line 1696
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1696
    if (! (passno < cblk->totalpasses)) {
#line 1696
      goto while_break___2;
    }
    {
#line 1697
    pass___0 = cblk->passes + passno;
#line 1698
    __cil_tmp37 = opj_mqc_numbytes(mqc);
    }
#line 1698
    if (pass___0->rate > __cil_tmp37) {
      {
#line 1699
      pass___0->rate = opj_mqc_numbytes(mqc);
      }
    }
#line 1701
    if (pass___0->rate > 1U) {
#line 1701
      if ((int )*(cblk->data + (pass___0->rate - 1U)) == 255) {
#line 1702
        __cil_tmp39 = pass___0->rate;
#line 1702
        (pass___0->rate) --;
      }
    }
#line 1704
    if (passno == 0U) {
#line 1704
      tmp___3 = 0U;
    } else {
#line 1704
      tmp___3 = (cblk->passes + (passno - 1U))->rate;
    }
#line 1704
    pass___0->len = pass___0->rate - tmp___3;
#line 1696
    passno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 1700
  return;
}
}
#line 51 "/root/patchweave_new/10/src/lib/openjp2/raw.c"
opj_raw_t *opj_raw_create(void) 
{ 
  opj_raw_t *raw ;
  void *__cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = malloc(sizeof(opj_raw_t ));
#line 52
  raw = (opj_raw_t *)__cil_tmp2;
  }
#line 53
  return (raw);
}
}
#line 56 "/root/patchweave_new/10/src/lib/openjp2/raw.c"
void opj_raw_destroy(opj_raw_t *raw ) 
{ 


  {
#line 57
  if (raw) {
    {
#line 58
    free((void *)raw);
    }
  }
#line 61
  return;
}
}
#line 62 "/root/patchweave_new/10/src/lib/openjp2/raw.c"
OPJ_UINT32 opj_raw_numbytes(opj_raw_t *raw ) 
{ 
  ptrdiff_t diff ;

  {
#line 63
  diff = raw->bp - raw->start;
#line 65
  return ((OPJ_UINT32 )diff);
}
}
#line 68 "/root/patchweave_new/10/src/lib/openjp2/raw.c"
void opj_raw_init_dec(opj_raw_t *raw , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 69
  raw->start = bp;
#line 70
  raw->lenmax = len;
#line 71
  raw->len = (OPJ_UINT32 )0;
#line 72
  raw->c = (OPJ_BYTE )0;
#line 73
  raw->ct = (OPJ_UINT32 )0;
#line 74
  return;
}
}
#line 76 "/root/patchweave_new/10/src/lib/openjp2/raw.c"
OPJ_UINT32 opj_raw_decode(opj_raw_t *raw ) 
{ 
  OPJ_UINT32 d ;
  OPJ_UINT32 __cil_tmp4 ;

  {
#line 78
  if (raw->ct == 0U) {
#line 79
    raw->ct = (OPJ_UINT32 )8;
#line 80
    if (raw->len == raw->lenmax) {
#line 81
      raw->c = (OPJ_BYTE )255;
    } else {
#line 83
      if ((int )raw->c == 255) {
#line 84
        raw->ct = (OPJ_UINT32 )7;
      }
#line 86
      raw->c = *(raw->start + raw->len);
#line 87
      (raw->len) ++;
    }
  }
#line 90
  __cil_tmp4 = raw->ct;
#line 90
  (raw->ct) --;
#line 91
  d = (OPJ_UINT32 )(((int )raw->c >> raw->ct) & 1);
#line 93
  return (d);
}
}
#line 52 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t *pi ) ;
#line 58
OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t *pi ) ;
#line 64
OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t *pi ) ;
#line 70
OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t *pi ) ;
#line 76
OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t *pi ) ;
#line 92
void opj_pi_update_encode_poc_and_final(opj_cp_t *p_cp , OPJ_UINT32 p_tileno , OPJ_INT32 p_tx0 ,
                                        OPJ_INT32 p_tx1 , OPJ_INT32 p_ty0 , OPJ_INT32 p_ty1 ,
                                        OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                        OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) ;
#line 118
void opj_pi_update_encode_not_poc(opj_cp_t *p_cp , OPJ_UINT32 p_num_comps , OPJ_UINT32 p_tileno ,
                                  OPJ_INT32 p_tx0 , OPJ_INT32 p_tx1 , OPJ_INT32 p_ty0 ,
                                  OPJ_INT32 p_ty1 , OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                  OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) ;
#line 144
void opj_get_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tileno ,
                                 OPJ_INT32 *p_tx0 , OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                 OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                 OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ) ;
#line 176
void opj_get_all_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 tileno ,
                                     OPJ_INT32 *p_tx0 , OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                     OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                     OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ,
                                     OPJ_UINT32 **p_resolutions ) ;
#line 196
opj_pi_iterator_t *opj_pi_create(opj_image_t *image , opj_cp_t *cp , OPJ_UINT32 tileno ) ;
#line 202
void opj_pi_update_decode_not_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp , OPJ_UINT32 p_max_precision ,
                                  OPJ_UINT32 p_max_res ) ;
#line 209
void opj_pi_update_decode_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp , OPJ_UINT32 p_max_precision ,
                              OPJ_UINT32 p_max_res ) ;
#line 217
OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos , opj_cp_t *cp , OPJ_UINT32 tileno ,
                                 OPJ_UINT32 pino , OPJ_CHAR *prog ) ;
#line 233 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___9 ;

  {
#line 234
  comp = (opj_pi_comp_t *)((void *)0);
#line 235
  res = (opj_pi_resolution_t *)((void *)0);
#line 236
  index___9 = (OPJ_UINT32 )0;
#line 238
  if (! pi->first) {
#line 239
    comp = pi->comps + pi->compno;
#line 240
    res = comp->resolutions + pi->resno;
#line 241
    goto LABEL_SKIP;
  } else {
#line 243
    pi->first = 0;
  }
#line 246
  pi->layno = pi->poc.layno0;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;

#line 246
    if (! (pi->layno < pi->poc.layno1)) {
#line 246
      goto while_break;
    }
#line 247
    pi->resno = pi->poc.resno0;
    {
#line 247
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 247
      if (! (pi->resno < pi->poc.resno1)) {
#line 247
        goto while_break___0;
      }
#line 249
      pi->compno = pi->poc.compno0;
      {
#line 249
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___1: ;
#line 249
        if (! (pi->compno < pi->poc.compno1)) {
#line 249
          goto while_break___1;
        }
#line 250
        comp = pi->comps + pi->compno;
#line 251
        if (pi->resno >= comp->numresolutions) {
#line 252
          goto while_continue___1;
        }
#line 254
        res = comp->resolutions + pi->resno;
#line 255
        if (! pi->tp_on) {
#line 256
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 258
        pi->precno = pi->poc.precno0;
        {
#line 258
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 258
          if (! (pi->precno < pi->poc.precno1)) {
#line 258
            goto while_break___2;
          }
#line 259
          index___9 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 260
          if (! *(pi->include + index___9)) {
#line 261
            *(pi->include + index___9) = (OPJ_INT16 )1;
#line 262
            return (1);
          }
          LABEL_SKIP: 
#line 258
          (pi->precno) ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 249
        (pi->compno) ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 248
      (pi->resno) ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 246
    (pi->layno) ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 270
  return (0);
}
}
#line 273 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___10 ;

  {
#line 274
  comp = (opj_pi_comp_t *)((void *)0);
#line 275
  res = (opj_pi_resolution_t *)((void *)0);
#line 276
  index___10 = (OPJ_UINT32 )0;
#line 278
  if (! pi->first) {
#line 279
    comp = pi->comps + pi->compno;
#line 280
    res = comp->resolutions + pi->resno;
#line 281
    goto LABEL_SKIP;
  } else {
#line 283
    pi->first = 0;
  }
#line 286
  pi->resno = pi->poc.resno0;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;

#line 286
    if (! (pi->resno < pi->poc.resno1)) {
#line 286
      goto while_break;
    }
#line 287
    pi->layno = pi->poc.layno0;
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 287
      if (! (pi->layno < pi->poc.layno1)) {
#line 287
        goto while_break___0;
      }
#line 288
      pi->compno = pi->poc.compno0;
      {
#line 288
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___1: ;
#line 288
        if (! (pi->compno < pi->poc.compno1)) {
#line 288
          goto while_break___1;
        }
#line 289
        comp = pi->comps + pi->compno;
#line 290
        if (pi->resno >= comp->numresolutions) {
#line 291
          goto while_continue___1;
        }
#line 293
        res = comp->resolutions + pi->resno;
#line 294
        if (! pi->tp_on) {
#line 295
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 297
        pi->precno = pi->poc.precno0;
        {
#line 297
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 297
          if (! (pi->precno < pi->poc.precno1)) {
#line 297
            goto while_break___2;
          }
#line 298
          index___10 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 299
          if (! *(pi->include + index___10)) {
#line 300
            *(pi->include + index___10) = (OPJ_INT16 )1;
#line 301
            return (1);
          }
          LABEL_SKIP: 
#line 297
          (pi->precno) ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 288
        (pi->compno) ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 287
      (pi->layno) ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 286
    (pi->resno) ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 309
  return (0);
}
}
#line 312 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___11 ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 levelno ;
  OPJ_INT32 trx0 ;
  OPJ_INT32 try0 ;
  OPJ_INT32 trx1 ;
  OPJ_INT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_INT32 prci ;
  OPJ_INT32 prcj ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_INT32 __cil_tmp32 ;
  OPJ_INT32 __cil_tmp33 ;

  {
#line 313
  comp = (opj_pi_comp_t *)((void *)0);
#line 314
  res = (opj_pi_resolution_t *)((void *)0);
#line 315
  index___11 = (OPJ_UINT32 )0;
#line 317
  if (! pi->first) {
#line 318
    goto LABEL_SKIP;
  } else {
#line 321
    pi->first = 0;
#line 322
    pi->dx = (OPJ_UINT32 )0;
#line 323
    pi->dy = (OPJ_UINT32 )0;
#line 324
    compno = (OPJ_UINT32 )0;
    {
#line 324
    while (1) {
      while_continue: /* CIL Label */ ;

#line 324
      if (! (compno < pi->numcomps)) {
#line 324
        goto while_break;
      }
#line 325
      comp = pi->comps + compno;
#line 326
      resno = (OPJ_UINT32 )0;
      {
#line 326
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 326
        if (! (resno < comp->numresolutions)) {
#line 326
          goto while_break___0;
        }
#line 328
        res = comp->resolutions + resno;
#line 329
        dx = comp->dx * (1U << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 330
        dy = comp->dy * (1U << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 331
        if (! pi->dx) {
#line 331
          tmp = dx;
        } else {
          {
#line 331
          __cil_tmp9 = opj_uint_min(pi->dx, dx);
#line 331
          tmp = __cil_tmp9;
          }
        }
#line 331
        pi->dx = tmp;
#line 332
        if (! pi->dy) {
#line 332
          tmp___0 = dy;
        } else {
          {
#line 332
          __cil_tmp11 = opj_uint_min(pi->dy, dy);
#line 332
          tmp___0 = __cil_tmp11;
          }
        }
#line 332
        pi->dy = tmp___0;
#line 326
        resno ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___0: 
#line 324
      compno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 336
  if (! pi->tp_on) {
#line 337
    pi->poc.ty0 = pi->ty0;
#line 338
    pi->poc.tx0 = pi->tx0;
#line 339
    pi->poc.ty1 = pi->ty1;
#line 340
    pi->poc.tx1 = pi->tx1;
  }
#line 342
  pi->resno = pi->poc.resno0;
  {
#line 342
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 342
    if (! (pi->resno < pi->poc.resno1)) {
#line 342
      goto while_break___1;
    }
#line 343
    pi->y = pi->poc.ty0;
    {
#line 343
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 343
      if (! (pi->y < pi->poc.ty1)) {
#line 343
        goto while_break___2;
      }
#line 344
      pi->x = pi->poc.tx0;
      {
#line 344
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 344
        if (! (pi->x < pi->poc.tx1)) {
#line 344
          goto while_break___3;
        }
#line 345
        pi->compno = pi->poc.compno0;
        {
#line 345
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___4: ;
#line 345
          if (! (pi->compno < pi->poc.compno1)) {
#line 345
            goto while_break___4;
          }
#line 351
          comp = pi->comps + pi->compno;
#line 352
          if (pi->resno >= comp->numresolutions) {
#line 353
            goto while_continue___4;
          }
          {
#line 355
          res = comp->resolutions + pi->resno;
#line 356
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 357
          trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32 )(comp->dx << levelno));
#line 358
          try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32 )(comp->dy << levelno));
#line 359
          trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32 )(comp->dx << levelno));
#line 360
          try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32 )(comp->dy << levelno));
#line 361
          rpx = res->pdx + levelno;
#line 362
          rpy = res->pdy + levelno;
          }
#line 363
          if (! (pi->y % (OPJ_INT32 )(comp->dy << rpy) == 0)) {
#line 363
            if (pi->y == pi->ty0) {
#line 363
              if (! ((try0 << levelno) % (1 << rpy))) {
#line 364
                goto while_continue___4;
              }
            } else {
#line 364
              goto while_continue___4;
            }
          }
#line 366
          if (! (pi->x % (OPJ_INT32 )(comp->dx << rpx) == 0)) {
#line 366
            if (pi->x == pi->tx0) {
#line 366
              if (! ((trx0 << levelno) % (1 << rpx))) {
#line 367
                goto while_continue___4;
              }
            } else {
#line 367
              goto while_continue___4;
            }
          }
#line 370
          if (res->pw == 0U) {
#line 370
            goto while_continue___4;
          } else
#line 370
          if (res->ph == 0U) {
#line 370
            goto while_continue___4;
          }
#line 372
          if (trx0 == trx1) {
#line 372
            goto while_continue___4;
          } else
#line 372
          if (try0 == try1) {
#line 372
            goto while_continue___4;
          }
          {
#line 374
          __cil_tmp30 = opj_int_floordivpow2(trx0, (OPJ_INT32 )res->pdx);
#line 374
          __cil_tmp28 = opj_int_ceildiv(pi->x, (OPJ_INT32 )(comp->dx << levelno));
#line 374
          __cil_tmp29 = opj_int_floordivpow2(__cil_tmp28, (OPJ_INT32 )res->pdx);
#line 374
          prci = __cil_tmp29 - __cil_tmp30;
#line 376
          __cil_tmp33 = opj_int_floordivpow2(try0, (OPJ_INT32 )res->pdy);
#line 376
          __cil_tmp31 = opj_int_ceildiv(pi->y, (OPJ_INT32 )(comp->dy << levelno));
#line 376
          __cil_tmp32 = opj_int_floordivpow2(__cil_tmp31, (OPJ_INT32 )res->pdy);
#line 376
          prcj = __cil_tmp32 - __cil_tmp33;
#line 378
          pi->precno = (OPJ_UINT32 )(prci + prcj * (OPJ_INT32 )res->pw);
#line 379
          pi->layno = pi->poc.layno0;
          }
          {
#line 379
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 379
            if (! (pi->layno < pi->poc.layno1)) {
#line 379
              goto while_break___5;
            }
#line 380
            index___11 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 381
            if (! *(pi->include + index___11)) {
#line 382
              *(pi->include + index___11) = (OPJ_INT16 )1;
#line 383
              return (1);
            }
            LABEL_SKIP: 
#line 379
            (pi->layno) ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___5: 
#line 345
          (pi->compno) ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___4: 
#line 344
        pi->x += (OPJ_INT32 )(pi->dx - (OPJ_UINT32 )(pi->x % (OPJ_INT32 )pi->dx));
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: 
#line 343
      pi->y += (OPJ_INT32 )(pi->dy - (OPJ_UINT32 )(pi->y % (OPJ_INT32 )pi->dy));
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: 
#line 342
    (pi->resno) ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: ;
#line 392
  return (0);
}
}
#line 395 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___12 ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 levelno ;
  OPJ_INT32 trx0 ;
  OPJ_INT32 try0 ;
  OPJ_INT32 trx1 ;
  OPJ_INT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_INT32 prci ;
  OPJ_INT32 prcj ;
  OPJ_INT32 __cil_tmp29 ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_INT32 __cil_tmp32 ;
  OPJ_INT32 __cil_tmp33 ;
  OPJ_INT32 __cil_tmp34 ;

  {
#line 396
  comp = (opj_pi_comp_t *)((void *)0);
#line 397
  res = (opj_pi_resolution_t *)((void *)0);
#line 398
  index___12 = (OPJ_UINT32 )0;
#line 400
  if (! pi->first) {
#line 401
    comp = pi->comps + pi->compno;
#line 402
    goto LABEL_SKIP;
  } else {
#line 405
    pi->first = 0;
#line 406
    pi->dx = (OPJ_UINT32 )0;
#line 407
    pi->dy = (OPJ_UINT32 )0;
#line 408
    compno = (OPJ_UINT32 )0;
    {
#line 408
    while (1) {
      while_continue: /* CIL Label */ ;

#line 408
      if (! (compno < pi->numcomps)) {
#line 408
        goto while_break;
      }
#line 409
      comp = pi->comps + compno;
#line 410
      resno = (OPJ_UINT32 )0;
      {
#line 410
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 410
        if (! (resno < comp->numresolutions)) {
#line 410
          goto while_break___0;
        }
#line 412
        res = comp->resolutions + resno;
#line 413
        dx = comp->dx * (1U << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 414
        dy = comp->dy * (1U << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 415
        if (! pi->dx) {
#line 415
          tmp = dx;
        } else {
          {
#line 415
          __cil_tmp9 = opj_uint_min(pi->dx, dx);
#line 415
          tmp = __cil_tmp9;
          }
        }
#line 415
        pi->dx = tmp;
#line 416
        if (! pi->dy) {
#line 416
          tmp___0 = dy;
        } else {
          {
#line 416
          __cil_tmp11 = opj_uint_min(pi->dy, dy);
#line 416
          tmp___0 = __cil_tmp11;
          }
        }
#line 416
        pi->dy = tmp___0;
#line 410
        resno ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___0: 
#line 408
      compno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 420
  if (! pi->tp_on) {
#line 421
    pi->poc.ty0 = pi->ty0;
#line 422
    pi->poc.tx0 = pi->tx0;
#line 423
    pi->poc.ty1 = pi->ty1;
#line 424
    pi->poc.tx1 = pi->tx1;
  }
#line 426
  pi->y = pi->poc.ty0;
  {
#line 426
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 426
    if (! (pi->y < pi->poc.ty1)) {
#line 426
      goto while_break___1;
    }
#line 427
    pi->x = pi->poc.tx0;
    {
#line 427
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 427
      if (! (pi->x < pi->poc.tx1)) {
#line 427
        goto while_break___2;
      }
#line 428
      pi->compno = pi->poc.compno0;
      {
#line 428
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 428
        if (! (pi->compno < pi->poc.compno1)) {
#line 428
          goto while_break___3;
        }
#line 429
        comp = pi->comps + pi->compno;
#line 430
        pi->resno = pi->poc.resno0;
        {
#line 430
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___4: ;
#line 430
          if (! (pi->resno < __cil_tmp15)) {
#line 430
            goto while_break___4;
          }
          {
#line 436
          res = comp->resolutions + pi->resno;
#line 437
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 438
          trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32 )(comp->dx << levelno));
#line 439
          try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32 )(comp->dy << levelno));
#line 440
          trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32 )(comp->dx << levelno));
#line 441
          try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32 )(comp->dy << levelno));
#line 442
          rpx = res->pdx + levelno;
#line 443
          rpy = res->pdy + levelno;
          }
#line 444
          if (! (pi->y % (OPJ_INT32 )(comp->dy << rpy) == 0)) {
#line 444
            if (pi->y == pi->ty0) {
#line 444
              if (! ((try0 << levelno) % (1 << rpy))) {
#line 445
                goto while_continue___4;
              }
            } else {
#line 445
              goto while_continue___4;
            }
          }
#line 447
          if (! (pi->x % (OPJ_INT32 )(comp->dx << rpx) == 0)) {
#line 447
            if (pi->x == pi->tx0) {
#line 447
              if (! ((trx0 << levelno) % (1 << rpx))) {
#line 448
                goto while_continue___4;
              }
            } else {
#line 448
              goto while_continue___4;
            }
          }
#line 451
          if (res->pw == 0U) {
#line 451
            goto while_continue___4;
          } else
#line 451
          if (res->ph == 0U) {
#line 451
            goto while_continue___4;
          }
#line 453
          if (trx0 == trx1) {
#line 453
            goto while_continue___4;
          } else
#line 453
          if (try0 == try1) {
#line 453
            goto while_continue___4;
          }
          {
#line 455
          __cil_tmp31 = opj_int_floordivpow2(trx0, (OPJ_INT32 )res->pdx);
#line 455
          __cil_tmp29 = opj_int_ceildiv(pi->x, (OPJ_INT32 )(comp->dx << levelno));
#line 455
          __cil_tmp30 = opj_int_floordivpow2(__cil_tmp29, (OPJ_INT32 )res->pdx);
#line 455
          prci = __cil_tmp30 - __cil_tmp31;
#line 457
          __cil_tmp34 = opj_int_floordivpow2(try0, (OPJ_INT32 )res->pdy);
#line 457
          __cil_tmp32 = opj_int_ceildiv(pi->y, (OPJ_INT32 )(comp->dy << levelno));
#line 457
          __cil_tmp33 = opj_int_floordivpow2(__cil_tmp32, (OPJ_INT32 )res->pdy);
#line 457
          prcj = __cil_tmp33 - __cil_tmp34;
#line 459
          pi->precno = (OPJ_UINT32 )(prci + prcj * (OPJ_INT32 )res->pw);
#line 460
          pi->layno = pi->poc.layno0;
          }
          {
#line 460
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 460
            if (! (pi->layno < pi->poc.layno1)) {
#line 460
              goto while_break___5;
            }
#line 461
            index___12 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 462
            if (! *(pi->include + index___12)) {
#line 463
              *(pi->include + index___12) = (OPJ_INT16 )1;
#line 464
              return (1);
            }
            LABEL_SKIP: 
#line 460
            (pi->layno) ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___5: 
#line 430
          (pi->resno) ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___4: 
#line 428
        (pi->compno) ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: 
#line 427
      pi->x += (OPJ_INT32 )(pi->dx - (OPJ_UINT32 )(pi->x % (OPJ_INT32 )pi->dx));
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: 
#line 426
    pi->y += (OPJ_INT32 )(pi->dy - (OPJ_UINT32 )(pi->y % (OPJ_INT32 )pi->dy));
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: ;
#line 473
  return (0);
}
}
#line 476 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___13 ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp8 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 levelno ;
  OPJ_INT32 trx0 ;
  OPJ_INT32 try0 ;
  OPJ_INT32 trx1 ;
  OPJ_INT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_INT32 prci ;
  OPJ_INT32 prcj ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_INT32 __cil_tmp32 ;

  {
#line 477
  comp = (opj_pi_comp_t *)((void *)0);
#line 478
  res = (opj_pi_resolution_t *)((void *)0);
#line 479
  index___13 = (OPJ_UINT32 )0;
#line 481
  if (! pi->first) {
#line 482
    comp = pi->comps + pi->compno;
#line 483
    goto LABEL_SKIP;
  } else {
#line 485
    pi->first = 0;
  }
#line 488
  pi->compno = pi->poc.compno0;
  {
#line 488
  while (1) {
    while_continue: /* CIL Label */ ;

#line 488
    if (! (pi->compno < pi->poc.compno1)) {
#line 488
      goto while_break;
    }
#line 490
    comp = pi->comps + pi->compno;
#line 491
    pi->dx = (OPJ_UINT32 )0;
#line 492
    pi->dy = (OPJ_UINT32 )0;
#line 493
    resno = (OPJ_UINT32 )0;
    {
#line 493
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 493
      if (! (resno < comp->numresolutions)) {
#line 493
        goto while_break___0;
      }
#line 495
      res = comp->resolutions + resno;
#line 496
      dx = comp->dx * (1U << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 497
      dy = comp->dy * (1U << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 498
      if (! pi->dx) {
#line 498
        tmp = dx;
      } else {
        {
#line 498
        __cil_tmp8 = opj_uint_min(pi->dx, dx);
#line 498
        tmp = __cil_tmp8;
        }
      }
#line 498
      pi->dx = tmp;
#line 499
      if (! pi->dy) {
#line 499
        tmp___0 = dy;
      } else {
        {
#line 499
        __cil_tmp10 = opj_uint_min(pi->dy, dy);
#line 499
        tmp___0 = __cil_tmp10;
        }
      }
#line 499
      pi->dy = tmp___0;
#line 493
      resno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: ;
#line 501
    if (! pi->tp_on) {
#line 502
      pi->poc.ty0 = pi->ty0;
#line 503
      pi->poc.tx0 = pi->tx0;
#line 504
      pi->poc.ty1 = pi->ty1;
#line 505
      pi->poc.tx1 = pi->tx1;
    }
#line 507
    pi->y = pi->poc.ty0;
    {
#line 507
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 507
      if (! (pi->y < pi->poc.ty1)) {
#line 507
        goto while_break___1;
      }
#line 508
      pi->x = pi->poc.tx0;
      {
#line 508
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 508
        if (! (pi->x < pi->poc.tx1)) {
#line 508
          goto while_break___2;
        }
#line 509
        pi->resno = pi->poc.resno0;
        {
#line 509
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___3: ;
#line 509
          if (! (pi->resno < __cil_tmp13)) {
#line 509
            goto while_break___3;
          }
          {
#line 515
          res = comp->resolutions + pi->resno;
#line 516
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 517
          trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32 )(comp->dx << levelno));
#line 518
          try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32 )(comp->dy << levelno));
#line 519
          trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32 )(comp->dx << levelno));
#line 520
          try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32 )(comp->dy << levelno));
#line 521
          rpx = res->pdx + levelno;
#line 522
          rpy = res->pdy + levelno;
          }
#line 523
          if (! (pi->y % (OPJ_INT32 )(comp->dy << rpy) == 0)) {
#line 523
            if (pi->y == pi->ty0) {
#line 523
              if (! ((try0 << levelno) % (1 << rpy))) {
#line 524
                goto while_continue___3;
              }
            } else {
#line 524
              goto while_continue___3;
            }
          }
#line 526
          if (! (pi->x % (OPJ_INT32 )(comp->dx << rpx) == 0)) {
#line 526
            if (pi->x == pi->tx0) {
#line 526
              if (! ((trx0 << levelno) % (1 << rpx))) {
#line 527
                goto while_continue___3;
              }
            } else {
#line 527
              goto while_continue___3;
            }
          }
#line 530
          if (res->pw == 0U) {
#line 530
            goto while_continue___3;
          } else
#line 530
          if (res->ph == 0U) {
#line 530
            goto while_continue___3;
          }
#line 532
          if (trx0 == trx1) {
#line 532
            goto while_continue___3;
          } else
#line 532
          if (try0 == try1) {
#line 532
            goto while_continue___3;
          }
          {
#line 534
          __cil_tmp29 = opj_int_floordivpow2(trx0, (OPJ_INT32 )res->pdx);
#line 534
          __cil_tmp27 = opj_int_ceildiv(pi->x, (OPJ_INT32 )(comp->dx << levelno));
#line 534
          __cil_tmp28 = opj_int_floordivpow2(__cil_tmp27, (OPJ_INT32 )res->pdx);
#line 534
          prci = __cil_tmp28 - __cil_tmp29;
#line 536
          __cil_tmp32 = opj_int_floordivpow2(try0, (OPJ_INT32 )res->pdy);
#line 536
          __cil_tmp30 = opj_int_ceildiv(pi->y, (OPJ_INT32 )(comp->dy << levelno));
#line 536
          __cil_tmp31 = opj_int_floordivpow2(__cil_tmp30, (OPJ_INT32 )res->pdy);
#line 536
          prcj = __cil_tmp31 - __cil_tmp32;
#line 538
          pi->precno = (OPJ_UINT32 )(prci + prcj * (OPJ_INT32 )res->pw);
#line 539
          pi->layno = pi->poc.layno0;
          }
          {
#line 539
          while (1) {
            while_continue___8: /* CIL Label */ ;

#line 539
            if (! (pi->layno < pi->poc.layno1)) {
#line 539
              goto while_break___4;
            }
#line 540
            index___13 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 541
            if (! *(pi->include + index___13)) {
#line 542
              *(pi->include + index___13) = (OPJ_INT16 )1;
#line 543
              return (1);
            }
            LABEL_SKIP: 
#line 539
            (pi->layno) ++;
          }
          while_break___10: /* CIL Label */ ;
          }
          while_break___4: 
#line 509
          (pi->resno) ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: 
#line 508
        pi->x += (OPJ_INT32 )(pi->dx - (OPJ_UINT32 )(pi->x % (OPJ_INT32 )pi->dx));
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: 
#line 507
      pi->y += (OPJ_INT32 )(pi->dy - (OPJ_UINT32 )(pi->y % (OPJ_INT32 )pi->dy));
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
#line 488
    (pi->compno) ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 552
  return (0);
}
}
#line 555 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
void opj_get_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tileno ,
                                 OPJ_INT32 *p_tx0 , OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                 OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                 OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_level_no ;
  OPJ_INT32 l_rx0 ;
  OPJ_INT32 l_ry0 ;
  OPJ_INT32 l_rx1 ;
  OPJ_INT32 l_ry1 ;
  OPJ_INT32 l_px0 ;
  OPJ_INT32 l_py0 ;
  OPJ_INT32 l_px1 ;
  OPJ_INT32 py1 ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_pw ;
  OPJ_UINT32 l_ph ;
  OPJ_UINT32 l_product ;
  OPJ_INT32 l_tcx0 ;
  OPJ_INT32 l_tcy0 ;
  OPJ_INT32 l_tcx1 ;
  OPJ_INT32 l_tcy1 ;
  OPJ_UINT32 l_dx ;
  OPJ_UINT32 l_dy ;
  OPJ_INT32 __cil_tmp56 ;
  OPJ_INT32 __cil_tmp57 ;
  OPJ_INT32 __cil_tmp58 ;
  OPJ_INT32 __cil_tmp59 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 570
  l_tcp = (opj_tcp_t *)0;
#line 571
  l_tccp = (opj_tccp_t *)0;
#line 572
  l_img_comp = (opj_image_comp_t *)0;
#line 583
  l_tcp = p_cp->tcps + p_tileno;
#line 584
  l_img_comp = p_image->comps;
#line 585
  l_tccp = l_tcp->tccps;
#line 588
  p = p_tileno % p_cp->tw;
#line 589
  q = p_tileno / p_cp->tw;
#line 592
  *p_tx0 = opj_int_max((OPJ_INT32 )(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32 )p_image->x0);
#line 593
  *p_tx1 = opj_int_min((OPJ_INT32 )(p_cp->tx0 + (p + 1U) * p_cp->tdx), (OPJ_INT32 )p_image->x1);
#line 594
  *p_ty0 = opj_int_max((OPJ_INT32 )(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32 )p_image->y0);
#line 595
  *p_ty1 = opj_int_min((OPJ_INT32 )(p_cp->ty0 + (q + 1U) * p_cp->tdy), (OPJ_INT32 )p_image->y1);
#line 598
  *p_max_prec = (OPJ_UINT32 )0;
#line 599
  *p_max_res = (OPJ_UINT32 )0;
#line 602
  *p_dx_min = (OPJ_UINT32 )2147483647;
#line 603
  *p_dy_min = (OPJ_UINT32 )2147483647;
#line 605
  compno = (OPJ_UINT32 )0;
  }
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;

#line 605
    if (! (compno < p_image->numcomps)) {
#line 605
      goto while_break;
    }
    {
#line 615
    l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32 )l_img_comp->dx);
#line 616
    l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32 )l_img_comp->dy);
#line 617
    l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32 )l_img_comp->dx);
#line 618
    l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32 )l_img_comp->dy);
    }
#line 620
    if (l_tccp->numresolutions > *p_max_res) {
#line 621
      *p_max_res = l_tccp->numresolutions;
    }
#line 625
    resno = (OPJ_UINT32 )0;
    {
#line 625
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 625
      if (! (resno < l_tccp->numresolutions)) {
#line 625
        goto while_break___0;
      }
      {
#line 629
      l_pdx = l_tccp->prcw[resno];
#line 630
      l_pdy = l_tccp->prch[resno];
#line 632
      l_dx = l_img_comp->dx * (1U << (((l_pdx + l_tccp->numresolutions) - 1U) - resno));
#line 633
      l_dy = l_img_comp->dy * (1U << (((l_pdy + l_tccp->numresolutions) - 1U) - resno));
#line 636
      *p_dx_min = opj_uint_min(*p_dx_min, l_dx);
#line 637
      *p_dy_min = opj_uint_min(*p_dy_min, l_dy);
#line 640
      l_level_no = (l_tccp->numresolutions - 1U) - resno;
#line 642
      l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32 )l_level_no);
#line 643
      l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32 )l_level_no);
#line 644
      l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32 )l_level_no);
#line 645
      l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32 )l_level_no);
#line 647
      __cil_tmp56 = opj_int_floordivpow2(l_rx0, (OPJ_INT32 )l_pdx);
#line 647
      l_px0 = __cil_tmp56 << l_pdx;
#line 648
      __cil_tmp57 = opj_int_floordivpow2(l_ry0, (OPJ_INT32 )l_pdy);
#line 648
      l_py0 = __cil_tmp57 << l_pdy;
#line 649
      __cil_tmp58 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32 )l_pdx);
#line 649
      l_px1 = __cil_tmp58 << l_pdx;
#line 651
      __cil_tmp59 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32 )l_pdy);
#line 651
      py1 = __cil_tmp59 << l_pdy;
      }
#line 653
      if (l_rx0 == l_rx1) {
#line 653
        tmp___2 = 0U;
      } else {
#line 653
        tmp___2 = (OPJ_UINT32 )((l_px1 - l_px0) >> l_pdx);
      }
#line 653
      l_pw = tmp___2;
#line 654
      if (l_ry0 == l_ry1) {
#line 654
        tmp___3 = 0U;
      } else {
#line 654
        tmp___3 = (OPJ_UINT32 )((py1 - l_py0) >> l_pdy);
      }
#line 654
      l_ph = tmp___3;
#line 656
      l_product = l_pw * l_ph;
#line 659
      if (l_product > *p_max_prec) {
#line 660
        *p_max_prec = l_product;
      }
#line 625
      resno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 663
    l_img_comp ++;
#line 664
    l_tccp ++;
#line 605
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 609
  return;
}
}
#line 669 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
void opj_get_all_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 tileno ,
                                     OPJ_INT32 *p_tx0 , OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                     OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                     OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ,
                                     OPJ_UINT32 **p_resolutions ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  opj_tcp_t *tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 *lResolutionPtr ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_level_no ;
  OPJ_INT32 l_rx0 ;
  OPJ_INT32 l_ry0 ;
  OPJ_INT32 l_rx1 ;
  OPJ_INT32 l_ry1 ;
  OPJ_INT32 l_px0 ;
  OPJ_INT32 l_py0 ;
  OPJ_INT32 l_px1 ;
  OPJ_INT32 py1 ;
  OPJ_UINT32 l_product ;
  OPJ_INT32 l_tcx0 ;
  OPJ_INT32 l_tcy0 ;
  OPJ_INT32 l_tcx1 ;
  OPJ_INT32 l_tcy1 ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_pw ;
  OPJ_UINT32 l_ph ;
  OPJ_UINT32 l_dx ;
  OPJ_UINT32 l_dy ;
  OPJ_UINT32 *__cil_tmp52 ;
  OPJ_UINT32 *__cil_tmp53 ;
  OPJ_INT32 __cil_tmp54 ;
  OPJ_INT32 __cil_tmp55 ;
  OPJ_INT32 __cil_tmp60 ;
  OPJ_INT32 __cil_tmp61 ;
  OPJ_INT32 __cil_tmp62 ;
  OPJ_INT32 __cil_tmp63 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  OPJ_UINT32 *__cil_tmp66 ;
  OPJ_UINT32 *__cil_tmp67 ;

  {
  {
#line 686
  tcp = (opj_tcp_t *)0;
#line 687
  l_tccp = (opj_tccp_t *)0;
#line 688
  l_img_comp = (opj_image_comp_t *)0;
#line 702
  tcp = p_cp->tcps + tileno;
#line 703
  l_tccp = tcp->tccps;
#line 704
  l_img_comp = p_image->comps;
#line 707
  p = tileno % p_cp->tw;
#line 708
  q = tileno / p_cp->tw;
#line 711
  *p_tx0 = opj_int_max((OPJ_INT32 )(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32 )p_image->x0);
#line 712
  *p_tx1 = opj_int_min((OPJ_INT32 )(p_cp->tx0 + (p + 1U) * p_cp->tdx), (OPJ_INT32 )p_image->x1);
#line 713
  *p_ty0 = opj_int_max((OPJ_INT32 )(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32 )p_image->y0);
#line 714
  *p_ty1 = opj_int_min((OPJ_INT32 )(p_cp->ty0 + (q + 1U) * p_cp->tdy), (OPJ_INT32 )p_image->y1);
#line 717
  *p_max_prec = (OPJ_UINT32 )0;
#line 718
  *p_max_res = (OPJ_UINT32 )0;
#line 721
  *p_dx_min = (OPJ_UINT32 )2147483647;
#line 722
  *p_dy_min = (OPJ_UINT32 )2147483647;
#line 724
  compno = (OPJ_UINT32 )0;
  }
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;

#line 724
    if (! (compno < p_image->numcomps)) {
#line 724
      goto while_break;
    }
    {
#line 733
    lResolutionPtr = *(p_resolutions + compno);
#line 735
    l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32 )l_img_comp->dx);
#line 736
    l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32 )l_img_comp->dy);
#line 737
    l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32 )l_img_comp->dx);
#line 738
    l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32 )l_img_comp->dy);
    }
#line 740
    if (l_tccp->numresolutions > *p_max_res) {
#line 741
      *p_max_res = l_tccp->numresolutions;
    }
#line 745
    l_level_no = l_tccp->numresolutions - 1U;
#line 746
    resno = (OPJ_UINT32 )0;
    {
#line 746
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 746
      if (! (resno < l_tccp->numresolutions)) {
#line 746
        goto while_break___0;
      }
      {
#line 750
      l_pdx = l_tccp->prcw[resno];
#line 751
      l_pdy = l_tccp->prch[resno];
#line 752
      __cil_tmp52 = lResolutionPtr;
#line 752
      lResolutionPtr ++;
#line 752
      *__cil_tmp52 = l_pdx;
#line 753
      __cil_tmp53 = lResolutionPtr;
#line 753
      lResolutionPtr ++;
#line 753
      *__cil_tmp53 = l_pdy;
#line 754
      l_dx = l_img_comp->dx * (1U << (l_pdx + l_level_no));
#line 755
      l_dy = l_img_comp->dy * (1U << (l_pdy + l_level_no));
#line 757
      __cil_tmp54 = opj_int_min((OPJ_INT32 )*p_dx_min, (OPJ_INT32 )l_dx);
#line 757
      *p_dx_min = (OPJ_UINT32 )__cil_tmp54;
#line 758
      __cil_tmp55 = opj_int_min((OPJ_INT32 )*p_dy_min, (OPJ_INT32 )l_dy);
#line 758
      *p_dy_min = (OPJ_UINT32 )__cil_tmp55;
#line 761
      l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32 )l_level_no);
#line 762
      l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32 )l_level_no);
#line 763
      l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32 )l_level_no);
#line 764
      l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32 )l_level_no);
#line 765
      __cil_tmp60 = opj_int_floordivpow2(l_rx0, (OPJ_INT32 )l_pdx);
#line 765
      l_px0 = __cil_tmp60 << l_pdx;
#line 766
      __cil_tmp61 = opj_int_floordivpow2(l_ry0, (OPJ_INT32 )l_pdy);
#line 766
      l_py0 = __cil_tmp61 << l_pdy;
#line 767
      __cil_tmp62 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32 )l_pdx);
#line 767
      l_px1 = __cil_tmp62 << l_pdx;
#line 768
      __cil_tmp63 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32 )l_pdy);
#line 768
      py1 = __cil_tmp63 << l_pdy;
      }
#line 769
      if (l_rx0 == l_rx1) {
#line 769
        tmp___2 = 0U;
      } else {
#line 769
        tmp___2 = (OPJ_UINT32 )((l_px1 - l_px0) >> l_pdx);
      }
#line 769
      l_pw = tmp___2;
#line 770
      if (l_ry0 == l_ry1) {
#line 770
        tmp___3 = 0U;
      } else {
#line 770
        tmp___3 = (OPJ_UINT32 )((py1 - l_py0) >> l_pdy);
      }
#line 770
      l_ph = tmp___3;
#line 771
      __cil_tmp66 = lResolutionPtr;
#line 771
      lResolutionPtr ++;
#line 771
      *__cil_tmp66 = l_pw;
#line 772
      __cil_tmp67 = lResolutionPtr;
#line 772
      lResolutionPtr ++;
#line 772
      *__cil_tmp67 = l_ph;
#line 773
      l_product = l_pw * l_ph;
#line 776
      if (l_product > *p_max_prec) {
#line 777
        *p_max_prec = l_product;
      }
#line 780
      l_level_no --;
#line 746
      resno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 782
    l_tccp ++;
#line 783
    l_img_comp ++;
#line 724
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 728
  return;
}
}
#line 787 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
opj_pi_iterator_t *opj_pi_create(opj_image_t *image , opj_cp_t *cp , OPJ_UINT32 tileno ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 l_poc_bound ;
  opj_pi_iterator_t *l_pi ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_pi_iterator_t *l_current_pi ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp17 ;

  {
  {
#line 797
  l_pi = (opj_pi_iterator_t *)0;
#line 798
  tcp = (opj_tcp_t *)0;
#line 799
  tccp = (opj_tccp_t *)0;
#line 802
  l_current_pi = (opj_pi_iterator_t *)0;
#line 810
  tcp = cp->tcps + tileno;
#line 811
  l_poc_bound = tcp->numpocs + 1U;
#line 814
  __cil_tmp14 = calloc((unsigned long )l_poc_bound, sizeof(opj_pi_iterator_t ));
#line 814
  l_pi = (opj_pi_iterator_t *)__cil_tmp14;
  }
#line 815
  if (! l_pi) {
#line 816
    return ((opj_pi_iterator_t *)((void *)0));
  }
#line 819
  l_current_pi = l_pi;
#line 820
  pino = (OPJ_UINT32 )0;
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;

#line 820
    if (! (pino < l_poc_bound)) {
#line 820
      goto while_break;
    }
    {
#line 822
    __cil_tmp15 = calloc((unsigned long )image->numcomps, sizeof(opj_pi_comp_t ));
#line 822
    l_current_pi->comps = (opj_pi_comp_t *)__cil_tmp15;
    }
#line 823
    if (! l_current_pi->comps) {
      {
#line 824
      opj_pi_destroy(l_pi, l_poc_bound);
      }
#line 825
      return ((opj_pi_iterator_t *)((void *)0));
    }
#line 828
    l_current_pi->numcomps = image->numcomps;
#line 830
    compno = (OPJ_UINT32 )0;
    {
#line 830
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 830
      if (! (compno < image->numcomps)) {
#line 830
        goto while_break___0;
      }
      {
#line 831
      comp = l_current_pi->comps + compno;
#line 833
      tccp = tcp->tccps + compno;
#line 835
      __cil_tmp17 = calloc((unsigned long )tccp->numresolutions, sizeof(opj_pi_resolution_t ));
#line 835
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp17;
      }
#line 836
      if (! comp->resolutions) {
        {
#line 837
        opj_pi_destroy(l_pi, l_poc_bound);
        }
#line 838
        return ((opj_pi_iterator_t *)0);
      }
#line 841
      comp->numresolutions = tccp->numresolutions;
#line 830
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 843
    l_current_pi ++;
#line 820
    pino ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 845
  return (l_pi);
}
}
#line 848 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
void opj_pi_update_encode_poc_and_final(opj_cp_t *p_cp , OPJ_UINT32 p_tileno , OPJ_INT32 p_tx0 ,
                                        OPJ_INT32 p_tx1 , OPJ_INT32 p_ty0 , OPJ_INT32 p_ty1 ,
                                        OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                        OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) 
{ 
  OPJ_UINT32 pino ;
  opj_tcp_t *l_tcp ;
  opj_poc_t *l_current_poc ;
  OPJ_UINT32 l_poc_bound ;
  OPJ_UINT32 tmp___1 ;

  {
#line 862
  l_tcp = (opj_tcp_t *)0;
#line 864
  l_current_poc = (opj_poc_t *)0;
#line 876
  l_tcp = p_cp->tcps + p_tileno;
#line 878
  l_poc_bound = l_tcp->numpocs + 1U;
#line 882
  l_current_poc = l_tcp->pocs;
#line 884
  l_current_poc->compS = l_current_poc->compno0;
#line 885
  l_current_poc->compE = l_current_poc->compno1;
#line 886
  l_current_poc->resS = l_current_poc->resno0;
#line 887
  l_current_poc->resE = l_current_poc->resno1;
#line 888
  l_current_poc->layE = l_current_poc->layno1;
#line 891
  l_current_poc->layS = (OPJ_UINT32 )0;
#line 892
  l_current_poc->prg = l_current_poc->prg1;
#line 893
  l_current_poc->prcS = (OPJ_UINT32 )0;
#line 895
  l_current_poc->prcE = p_max_prec;
#line 896
  l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 897
  l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 898
  l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 899
  l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 900
  l_current_poc->dx = p_dx_min;
#line 901
  l_current_poc->dy = p_dy_min;
#line 903
  l_current_poc ++;
#line 904
  pino = (OPJ_UINT32 )1;
  {
#line 904
  while (1) {
    while_continue: /* CIL Label */ ;

#line 904
    if (! (pino < l_poc_bound)) {
#line 904
      goto while_break;
    }
#line 905
    l_current_poc->compS = l_current_poc->compno0;
#line 906
    l_current_poc->compE = l_current_poc->compno1;
#line 907
    l_current_poc->resS = l_current_poc->resno0;
#line 908
    l_current_poc->resE = l_current_poc->resno1;
#line 909
    l_current_poc->layE = l_current_poc->layno1;
#line 910
    l_current_poc->prg = l_current_poc->prg1;
#line 911
    l_current_poc->prcS = (OPJ_UINT32 )0;
#line 913
    if (l_current_poc->layE > (l_current_poc - 1)->layE) {
#line 913
      tmp___1 = l_current_poc->layE;
    } else {
#line 913
      tmp___1 = 0U;
    }
#line 913
    l_current_poc->layS = tmp___1;
#line 915
    l_current_poc->prcE = p_max_prec;
#line 916
    l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 917
    l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 918
    l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 919
    l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 920
    l_current_poc->dx = p_dx_min;
#line 921
    l_current_poc->dy = p_dy_min;
#line 922
    l_current_poc ++;
#line 904
    pino ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 908
  return;
}
}
#line 926 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
void opj_pi_update_encode_not_poc(opj_cp_t *p_cp , OPJ_UINT32 p_num_comps , OPJ_UINT32 p_tileno ,
                                  OPJ_INT32 p_tx0 , OPJ_INT32 p_tx1 , OPJ_INT32 p_ty0 ,
                                  OPJ_INT32 p_ty1 , OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                  OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) 
{ 
  OPJ_UINT32 pino ;
  opj_tcp_t *l_tcp ;
  opj_poc_t *l_current_poc ;
  OPJ_UINT32 l_poc_bound ;

  {
#line 941
  l_tcp = (opj_tcp_t *)0;
#line 943
  l_current_poc = (opj_poc_t *)0;
#line 952
  l_tcp = p_cp->tcps + p_tileno;
#line 955
  l_poc_bound = l_tcp->numpocs + 1U;
#line 959
  l_current_poc = l_tcp->pocs;
#line 961
  pino = (OPJ_UINT32 )0;
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;

#line 961
    if (! (pino < l_poc_bound)) {
#line 961
      goto while_break;
    }
#line 962
    l_current_poc->compS = (OPJ_UINT32 )0;
#line 963
    l_current_poc->compE = p_num_comps;
#line 964
    l_current_poc->resS = (OPJ_UINT32 )0;
#line 965
    l_current_poc->resE = p_max_res;
#line 966
    l_current_poc->layS = (OPJ_UINT32 )0;
#line 967
    l_current_poc->layE = l_tcp->numlayers;
#line 968
    l_current_poc->prg = l_tcp->prg;
#line 969
    l_current_poc->prcS = (OPJ_UINT32 )0;
#line 970
    l_current_poc->prcE = p_max_prec;
#line 971
    l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 972
    l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 973
    l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 974
    l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 975
    l_current_poc->dx = p_dx_min;
#line 976
    l_current_poc->dy = p_dy_min;
#line 977
    l_current_poc ++;
#line 961
    pino ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 965
  return;
}
}
#line 981 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
void opj_pi_update_decode_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp , OPJ_UINT32 p_max_precision ,
                              OPJ_UINT32 p_max_res ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 l_bound ;
  opj_pi_iterator_t *l_current_pi ;
  opj_poc_t *l_current_poc ;

  {
#line 992
  l_current_pi = (opj_pi_iterator_t *)0;
#line 993
  l_current_poc = (opj_poc_t *)0;
#line 1002
  l_bound = p_tcp->numpocs + 1U;
#line 1003
  l_current_pi = p_pi;
#line 1004
  l_current_poc = p_tcp->pocs;
#line 1006
  pino = (OPJ_UINT32 )0;
  {
#line 1006
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1006
    if (! (pino < l_bound)) {
#line 1006
      goto while_break;
    }
#line 1007
    l_current_pi->poc.prg = l_current_poc->prg;
#line 1008
    l_current_pi->first = 1;
#line 1010
    l_current_pi->poc.resno0 = l_current_poc->resno0;
#line 1011
    l_current_pi->poc.compno0 = l_current_poc->compno0;
#line 1012
    l_current_pi->poc.layno0 = (OPJ_UINT32 )0;
#line 1013
    l_current_pi->poc.precno0 = (OPJ_UINT32 )0;
#line 1014
    l_current_pi->poc.resno1 = l_current_poc->resno1;
#line 1015
    l_current_pi->poc.compno1 = l_current_poc->compno1;
#line 1016
    l_current_pi->poc.layno1 = l_current_poc->layno1;
#line 1017
    l_current_pi->poc.precno1 = p_max_precision;
#line 1018
    l_current_pi ++;
#line 1019
    l_current_poc ++;
#line 1006
    pino ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1010
  return;
}
}
#line 1023 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
void opj_pi_update_decode_not_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp , OPJ_UINT32 p_max_precision ,
                                  OPJ_UINT32 p_max_res ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 l_bound ;
  opj_pi_iterator_t *l_current_pi ;

  {
#line 1034
  l_current_pi = (opj_pi_iterator_t *)0;
#line 1040
  l_bound = p_tcp->numpocs + 1U;
#line 1041
  l_current_pi = p_pi;
#line 1043
  pino = (OPJ_UINT32 )0;
  {
#line 1043
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1043
    if (! (pino < l_bound)) {
#line 1043
      goto while_break;
    }
#line 1044
    l_current_pi->poc.prg = p_tcp->prg;
#line 1045
    l_current_pi->first = 1;
#line 1046
    l_current_pi->poc.resno0 = (OPJ_UINT32 )0;
#line 1047
    l_current_pi->poc.compno0 = (OPJ_UINT32 )0;
#line 1048
    l_current_pi->poc.layno0 = (OPJ_UINT32 )0;
#line 1049
    l_current_pi->poc.precno0 = (OPJ_UINT32 )0;
#line 1050
    l_current_pi->poc.resno1 = p_max_res;
#line 1051
    l_current_pi->poc.compno1 = l_current_pi->numcomps;
#line 1052
    l_current_pi->poc.layno1 = p_tcp->numlayers;
#line 1053
    l_current_pi->poc.precno1 = p_max_precision;
#line 1054
    l_current_pi ++;
#line 1043
    pino ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1047
  return;
}
}
#line 1060 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos , opj_cp_t *cp , OPJ_UINT32 tileno ,
                                 OPJ_UINT32 pino , OPJ_CHAR *prog ) 
{ 
  OPJ_INT32 i ;
  opj_tcp_t *tcps ;
  opj_poc_t *tcp ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;

  {
#line 1067
  tcps = cp->tcps + tileno;
#line 1068
  tcp = & tcps->pocs[pino];
#line 1070
  if (pos >= 0) {
#line 1071
    i = pos;
    {
#line 1071
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1071
      if (! (pos >= 0)) {
#line 1071
        goto while_break;
      }
#line 1073
      if ((int )*(prog + i) == 82) {
#line 1073
        goto case_82;
      }
#line 1084
      if ((int )*(prog + i) == 67) {
#line 1084
        goto case_67;
      }
#line 1095
      if ((int )*(prog + i) == 76) {
#line 1095
        goto case_76;
      }
#line 1106
      if ((int )*(prog + i) == 80) {
#line 1106
        goto case_80;
      }
#line 1109
      if ((int )*(prog + i) == 1) {
#line 1109
        goto case_1;
      }
#line 1109
      if ((int )*(prog + i) == 0) {
#line 1109
        goto case_1;
      }
#line 1120
      goto switch_default;
      case_82: 
#line 1074
      if (tcp->res_t == tcp->resE) {
        {
#line 1075
        __cil_tmp9 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1075
        if (__cil_tmp9) {
#line 1076
          return (1);
        } else {
#line 1078
          return (0);
        }
      } else {
#line 1081
        return (1);
      }
#line 1083
      goto switch_break;
      case_67: 
#line 1085
      if (tcp->comp_t == tcp->compE) {
        {
#line 1086
        __cil_tmp10 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1086
        if (__cil_tmp10) {
#line 1087
          return (1);
        } else {
#line 1089
          return (0);
        }
      } else {
#line 1092
        return (1);
      }
#line 1094
      goto switch_break;
      case_76: 
#line 1096
      if (tcp->lay_t == tcp->layE) {
        {
#line 1097
        __cil_tmp11 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1097
        if (__cil_tmp11) {
#line 1098
          return (1);
        } else {
#line 1100
          return (0);
        }
      } else {
#line 1103
        return (1);
      }
#line 1105
      goto switch_break;
      case_80: 
#line 1109
      if ((int )tcp->prg == 1) {
#line 1109
        goto case_1;
      }
#line 1109
      if ((int )tcp->prg == 0) {
#line 1109
        goto case_1;
      }
#line 1120
      goto switch_default;
      case_1: 
#line 1110
      if (tcp->prc_t == tcp->prcE) {
        {
#line 1111
        __cil_tmp12 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
        }
#line 1111
        if (__cil_tmp12) {
#line 1112
          return (1);
        } else {
#line 1114
          return (0);
        }
      } else {
#line 1117
        return (1);
      }
#line 1119
      goto switch_break___0;
      switch_default: 
#line 1121
      if (tcp->tx0_t == tcp->txE) {
#line 1123
        if (tcp->ty0_t == tcp->tyE) {
          {
#line 1124
          __cil_tmp13 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
          }
#line 1124
          if (__cil_tmp13) {
#line 1125
            return (1);
          } else {
#line 1127
            return (0);
          }
        } else {
#line 1130
          return (1);
        }
      } else {
#line 1133
        return (1);
      }
#line 1135
      goto switch_break___0;
      switch_break___0: ;
      switch_break: 
#line 1071
      __cil_tmp14 = i;
#line 1071
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 1140
  return (0);
}
}
#line 1149 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 *l_tmp_data ;
  OPJ_UINT32 **l_tmp_ptr ;
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_INT32 l_tx0 ;
  OPJ_INT32 l_tx1 ;
  OPJ_INT32 l_ty0 ;
  OPJ_INT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  OPJ_UINT32 l_bound ;
  OPJ_UINT32 l_step_p ;
  OPJ_UINT32 l_step_c ;
  OPJ_UINT32 l_step_r ;
  OPJ_UINT32 l_step_l ;
  OPJ_UINT32 l_data_stride ;
  opj_pi_iterator_t *l_pi ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_pi_comp_t *l_current_comp ;
  opj_image_comp_t *l_img_comp ;
  opj_pi_iterator_t *l_current_pi ;
  OPJ_UINT32 *l_encoding_value_ptr ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp36 ;
  opj_pi_resolution_t *l_res ;
  OPJ_UINT32 *__cil_tmp38 ;
  OPJ_UINT32 *__cil_tmp39 ;
  OPJ_UINT32 *__cil_tmp40 ;
  OPJ_UINT32 *__cil_tmp41 ;
  opj_pi_resolution_t *l_res___0 ;
  OPJ_UINT32 *__cil_tmp44 ;
  OPJ_UINT32 *__cil_tmp45 ;
  OPJ_UINT32 *__cil_tmp46 ;
  OPJ_UINT32 *__cil_tmp47 ;

  {
  {
#line 1171
  l_pi = (opj_pi_iterator_t *)0;
#line 1172
  l_tcp = (opj_tcp_t *)0;
#line 1173
  l_tccp = (opj_tccp_t *)0;
#line 1174
  l_current_comp = (opj_pi_comp_t *)0;
#line 1175
  l_img_comp = (opj_image_comp_t *)0;
#line 1176
  l_current_pi = (opj_pi_iterator_t *)0;
#line 1177
  l_encoding_value_ptr = (OPJ_UINT32 *)0;
#line 1185
  l_tcp = p_cp->tcps + p_tile_no;
#line 1186
  l_bound = l_tcp->numpocs + 1U;
#line 1188
  l_data_stride = (OPJ_UINT32 )132;
#line 1189
  __cil_tmp33 = malloc((unsigned long )(l_data_stride * p_image->numcomps) * sizeof(OPJ_UINT32 ));
#line 1189
  l_tmp_data = (OPJ_UINT32 *)__cil_tmp33;
  }
#line 1191
  if (! l_tmp_data) {
#line 1194
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1196
  __cil_tmp34 = malloc((unsigned long )p_image->numcomps * sizeof(OPJ_UINT32 *));
#line 1196
  l_tmp_ptr = (OPJ_UINT32 **)__cil_tmp34;
  }
#line 1198
  if (! l_tmp_ptr) {
    {
#line 1201
    free((void *)l_tmp_data);
    }
#line 1202
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1206
  l_pi = opj_pi_create(p_image, p_cp, p_tile_no);
  }
#line 1207
  if (! l_pi) {
    {
#line 1208
    free((void *)l_tmp_data);
#line 1209
    free((void *)l_tmp_ptr);
    }
#line 1210
    return ((opj_pi_iterator_t *)0);
  }
#line 1213
  l_encoding_value_ptr = l_tmp_data;
#line 1216
  compno = (OPJ_UINT32 )0;
  {
#line 1215
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1215
    if (! (compno < p_image->numcomps)) {
#line 1215
      goto while_break;
    }
#line 1218
    *(l_tmp_ptr + compno) = l_encoding_value_ptr;
#line 1219
    l_encoding_value_ptr += l_data_stride;
#line 1216
    compno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1222
  opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                                  & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res,
                                  l_tmp_ptr);
#line 1225
  l_step_p = (OPJ_UINT32 )1;
#line 1226
  l_step_c = l_max_prec * l_step_p;
#line 1227
  l_step_r = p_image->numcomps * l_step_c;
#line 1228
  l_step_l = l_max_res * l_step_r;
#line 1231
  l_current_pi = l_pi;
#line 1234
  __cil_tmp36 = calloc((unsigned long )((l_tcp->numlayers + 1U) * l_step_l), sizeof(OPJ_INT16 ));
#line 1234
  l_current_pi->include = (OPJ_INT16 *)__cil_tmp36;
  }
#line 1235
  if (! l_current_pi->include) {
    {
#line 1238
    free((void *)l_tmp_data);
#line 1239
    free((void *)l_tmp_ptr);
#line 1240
    opj_pi_destroy(l_pi, l_bound);
    }
#line 1241
    return ((opj_pi_iterator_t *)0);
  }
#line 1245
  l_current_comp = l_current_pi->comps;
#line 1246
  l_img_comp = p_image->comps;
#line 1247
  l_tccp = l_tcp->tccps;
#line 1249
  l_current_pi->tx0 = l_tx0;
#line 1250
  l_current_pi->ty0 = l_ty0;
#line 1251
  l_current_pi->tx1 = l_tx1;
#line 1252
  l_current_pi->ty1 = l_ty1;
#line 1257
  l_current_pi->step_p = l_step_p;
#line 1258
  l_current_pi->step_c = l_step_c;
#line 1259
  l_current_pi->step_r = l_step_r;
#line 1260
  l_current_pi->step_l = l_step_l;
#line 1264
  compno = (OPJ_UINT32 )0;
  {
#line 1263
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1263
    if (! (compno < l_current_pi->numcomps)) {
#line 1263
      goto while_break___0;
    }
#line 1266
    l_res = l_current_comp->resolutions;
#line 1267
    l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1269
    l_current_comp->dx = l_img_comp->dx;
#line 1270
    l_current_comp->dy = l_img_comp->dy;
#line 1273
    resno = (OPJ_UINT32 )0;
    {
#line 1272
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1272
      if (! (resno < l_current_comp->numresolutions)) {
#line 1272
        goto while_break___1;
      }
#line 1275
      __cil_tmp38 = l_encoding_value_ptr;
#line 1275
      l_encoding_value_ptr ++;
#line 1275
      l_res->pdx = *__cil_tmp38;
#line 1276
      __cil_tmp39 = l_encoding_value_ptr;
#line 1276
      l_encoding_value_ptr ++;
#line 1276
      l_res->pdy = *__cil_tmp39;
#line 1277
      __cil_tmp40 = l_encoding_value_ptr;
#line 1277
      l_encoding_value_ptr ++;
#line 1277
      l_res->pw = *__cil_tmp40;
#line 1278
      __cil_tmp41 = l_encoding_value_ptr;
#line 1278
      l_encoding_value_ptr ++;
#line 1278
      l_res->ph = *__cil_tmp41;
#line 1279
      l_res ++;
#line 1273
      resno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
#line 1281
    l_current_comp ++;
#line 1282
    l_img_comp ++;
#line 1283
    l_tccp ++;
#line 1264
    compno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 1285
  l_current_pi ++;
#line 1287
  pino = (OPJ_UINT32 )1;
  {
#line 1287
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1287
    if (! (pino < l_bound)) {
#line 1287
      goto while_break___2;
    }
#line 1289
    l_current_comp = l_current_pi->comps;
#line 1290
    l_img_comp = p_image->comps;
#line 1291
    l_tccp = l_tcp->tccps;
#line 1293
    l_current_pi->tx0 = l_tx0;
#line 1294
    l_current_pi->ty0 = l_ty0;
#line 1295
    l_current_pi->tx1 = l_tx1;
#line 1296
    l_current_pi->ty1 = l_ty1;
#line 1299
    l_current_pi->step_p = l_step_p;
#line 1300
    l_current_pi->step_c = l_step_c;
#line 1301
    l_current_pi->step_r = l_step_r;
#line 1302
    l_current_pi->step_l = l_step_l;
#line 1306
    compno = (OPJ_UINT32 )0;
    {
#line 1305
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 1305
      if (! (compno < l_current_pi->numcomps)) {
#line 1305
        goto while_break___3;
      }
#line 1308
      l_res___0 = l_current_comp->resolutions;
#line 1309
      l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1311
      l_current_comp->dx = l_img_comp->dx;
#line 1312
      l_current_comp->dy = l_img_comp->dy;
#line 1315
      resno = (OPJ_UINT32 )0;
      {
#line 1314
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1314
        if (! (resno < l_current_comp->numresolutions)) {
#line 1314
          goto while_break___4;
        }
#line 1317
        __cil_tmp44 = l_encoding_value_ptr;
#line 1317
        l_encoding_value_ptr ++;
#line 1317
        l_res___0->pdx = *__cil_tmp44;
#line 1318
        __cil_tmp45 = l_encoding_value_ptr;
#line 1318
        l_encoding_value_ptr ++;
#line 1318
        l_res___0->pdy = *__cil_tmp45;
#line 1319
        __cil_tmp46 = l_encoding_value_ptr;
#line 1319
        l_encoding_value_ptr ++;
#line 1319
        l_res___0->pw = *__cil_tmp46;
#line 1320
        __cil_tmp47 = l_encoding_value_ptr;
#line 1320
        l_encoding_value_ptr ++;
#line 1320
        l_res___0->ph = *__cil_tmp47;
#line 1321
        l_res___0 ++;
#line 1315
        resno ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: 
#line 1323
      l_current_comp ++;
#line 1324
      l_img_comp ++;
#line 1325
      l_tccp ++;
#line 1306
      compno ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: 
#line 1328
    l_current_pi->include = (l_current_pi - 1)->include;
#line 1329
    l_current_pi ++;
#line 1287
    pino ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 1331
  free((void *)l_tmp_data);
#line 1332
  l_tmp_data = (OPJ_UINT32 *)0;
#line 1333
  free((void *)l_tmp_ptr);
#line 1334
  l_tmp_ptr = (OPJ_UINT32 **)0;
  }
#line 1335
  if (l_tcp->POC) {
    {
#line 1338
    opj_pi_update_decode_poc(l_pi, l_tcp, l_max_prec, l_max_res);
    }
  } else {
    {
#line 1342
    opj_pi_update_decode_not_poc(l_pi, l_tcp, l_max_prec, l_max_res);
    }
  }
#line 1344
  return (l_pi);
}
}
#line 1349 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
opj_pi_iterator_t *opj_pi_initialise_encode(opj_image_t *p_image , opj_cp_t *p_cp ,
                                            OPJ_UINT32 p_tile_no , J2K_T2_MODE p_t2_mode ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 *l_tmp_data ;
  OPJ_UINT32 **l_tmp_ptr ;
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_INT32 l_tx0 ;
  OPJ_INT32 l_tx1 ;
  OPJ_INT32 l_ty0 ;
  OPJ_INT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  OPJ_UINT32 l_bound ;
  OPJ_UINT32 l_step_p ;
  OPJ_UINT32 l_step_c ;
  OPJ_UINT32 l_step_r ;
  OPJ_UINT32 l_step_l ;
  OPJ_UINT32 l_data_stride ;
  opj_pi_iterator_t *l_pi ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_pi_comp_t *l_current_comp ;
  opj_image_comp_t *l_img_comp ;
  opj_pi_iterator_t *l_current_pi ;
  OPJ_UINT32 *l_encoding_value_ptr ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp37 ;
  opj_pi_resolution_t *l_res ;
  OPJ_UINT32 *__cil_tmp39 ;
  OPJ_UINT32 *__cil_tmp40 ;
  OPJ_UINT32 *__cil_tmp41 ;
  OPJ_UINT32 *__cil_tmp42 ;
  opj_pi_resolution_t *l_res___0 ;
  OPJ_UINT32 *__cil_tmp45 ;
  OPJ_UINT32 *__cil_tmp46 ;
  OPJ_UINT32 *__cil_tmp47 ;
  OPJ_UINT32 *__cil_tmp48 ;

  {
  {
#line 1372
  l_pi = (opj_pi_iterator_t *)0;
#line 1373
  l_tcp = (opj_tcp_t *)0;
#line 1374
  l_tccp = (opj_tccp_t *)0;
#line 1375
  l_current_comp = (opj_pi_comp_t *)0;
#line 1376
  l_img_comp = (opj_image_comp_t *)0;
#line 1377
  l_current_pi = (opj_pi_iterator_t *)0;
#line 1378
  l_encoding_value_ptr = (OPJ_UINT32 *)0;
#line 1386
  l_tcp = p_cp->tcps + p_tile_no;
#line 1387
  l_bound = l_tcp->numpocs + 1U;
#line 1389
  l_data_stride = (OPJ_UINT32 )132;
#line 1390
  __cil_tmp34 = malloc((unsigned long )(l_data_stride * p_image->numcomps) * sizeof(OPJ_UINT32 ));
#line 1390
  l_tmp_data = (OPJ_UINT32 *)__cil_tmp34;
  }
#line 1392
  if (! l_tmp_data) {
#line 1393
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1396
  __cil_tmp35 = malloc((unsigned long )p_image->numcomps * sizeof(OPJ_UINT32 *));
#line 1396
  l_tmp_ptr = (OPJ_UINT32 **)__cil_tmp35;
  }
#line 1398
  if (! l_tmp_ptr) {
    {
#line 1399
    free((void *)l_tmp_data);
    }
#line 1400
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1404
  l_pi = opj_pi_create(p_image, p_cp, p_tile_no);
  }
#line 1405
  if (! l_pi) {
    {
#line 1406
    free((void *)l_tmp_data);
#line 1407
    free((void *)l_tmp_ptr);
    }
#line 1408
    return ((opj_pi_iterator_t *)0);
  }
#line 1411
  l_encoding_value_ptr = l_tmp_data;
#line 1413
  compno = (OPJ_UINT32 )0;
  {
#line 1413
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1413
    if (! (compno < p_image->numcomps)) {
#line 1413
      goto while_break;
    }
#line 1414
    *(l_tmp_ptr + compno) = l_encoding_value_ptr;
#line 1415
    l_encoding_value_ptr += l_data_stride;
#line 1413
    compno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1419
  opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                                  & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res,
                                  l_tmp_ptr);
#line 1422
  l_step_p = (OPJ_UINT32 )1;
#line 1423
  l_step_c = l_max_prec * l_step_p;
#line 1424
  l_step_r = p_image->numcomps * l_step_c;
#line 1425
  l_step_l = l_max_res * l_step_r;
#line 1428
  l_pi->tp_on = (OPJ_BYTE )p_cp->m_specific_param.m_enc.m_tp_on;
#line 1429
  l_current_pi = l_pi;
#line 1432
  __cil_tmp37 = calloc((unsigned long )(l_tcp->numlayers * l_step_l), sizeof(OPJ_INT16 ));
#line 1432
  l_current_pi->include = (OPJ_INT16 *)__cil_tmp37;
  }
#line 1433
  if (! l_current_pi->include) {
    {
#line 1434
    free((void *)l_tmp_data);
#line 1435
    free((void *)l_tmp_ptr);
#line 1436
    opj_pi_destroy(l_pi, l_bound);
    }
#line 1437
    return ((opj_pi_iterator_t *)0);
  }
#line 1441
  l_current_comp = l_current_pi->comps;
#line 1442
  l_img_comp = p_image->comps;
#line 1443
  l_tccp = l_tcp->tccps;
#line 1444
  l_current_pi->tx0 = l_tx0;
#line 1445
  l_current_pi->ty0 = l_ty0;
#line 1446
  l_current_pi->tx1 = l_tx1;
#line 1447
  l_current_pi->ty1 = l_ty1;
#line 1448
  l_current_pi->dx = l_dx_min;
#line 1449
  l_current_pi->dy = l_dy_min;
#line 1450
  l_current_pi->step_p = l_step_p;
#line 1451
  l_current_pi->step_c = l_step_c;
#line 1452
  l_current_pi->step_r = l_step_r;
#line 1453
  l_current_pi->step_l = l_step_l;
#line 1456
  compno = (OPJ_UINT32 )0;
  {
#line 1456
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1456
    if (! (compno < l_current_pi->numcomps)) {
#line 1456
      goto while_break___0;
    }
#line 1457
    l_res = l_current_comp->resolutions;
#line 1458
    l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1460
    l_current_comp->dx = l_img_comp->dx;
#line 1461
    l_current_comp->dy = l_img_comp->dy;
#line 1464
    resno = (OPJ_UINT32 )0;
    {
#line 1464
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1464
      if (! (resno < l_current_comp->numresolutions)) {
#line 1464
        goto while_break___1;
      }
#line 1465
      __cil_tmp39 = l_encoding_value_ptr;
#line 1465
      l_encoding_value_ptr ++;
#line 1465
      l_res->pdx = *__cil_tmp39;
#line 1466
      __cil_tmp40 = l_encoding_value_ptr;
#line 1466
      l_encoding_value_ptr ++;
#line 1466
      l_res->pdy = *__cil_tmp40;
#line 1467
      __cil_tmp41 = l_encoding_value_ptr;
#line 1467
      l_encoding_value_ptr ++;
#line 1467
      l_res->pw = *__cil_tmp41;
#line 1468
      __cil_tmp42 = l_encoding_value_ptr;
#line 1468
      l_encoding_value_ptr ++;
#line 1468
      l_res->ph = *__cil_tmp42;
#line 1469
      l_res ++;
#line 1464
      resno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
#line 1472
    l_current_comp ++;
#line 1473
    l_img_comp ++;
#line 1474
    l_tccp ++;
#line 1456
    compno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 1476
  l_current_pi ++;
#line 1478
  pino = (OPJ_UINT32 )1;
  {
#line 1478
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1478
    if (! (pino < l_bound)) {
#line 1478
      goto while_break___2;
    }
#line 1479
    l_current_comp = l_current_pi->comps;
#line 1480
    l_img_comp = p_image->comps;
#line 1481
    l_tccp = l_tcp->tccps;
#line 1483
    l_current_pi->tx0 = l_tx0;
#line 1484
    l_current_pi->ty0 = l_ty0;
#line 1485
    l_current_pi->tx1 = l_tx1;
#line 1486
    l_current_pi->ty1 = l_ty1;
#line 1487
    l_current_pi->dx = l_dx_min;
#line 1488
    l_current_pi->dy = l_dy_min;
#line 1489
    l_current_pi->step_p = l_step_p;
#line 1490
    l_current_pi->step_c = l_step_c;
#line 1491
    l_current_pi->step_r = l_step_r;
#line 1492
    l_current_pi->step_l = l_step_l;
#line 1495
    compno = (OPJ_UINT32 )0;
    {
#line 1495
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 1495
      if (! (compno < l_current_pi->numcomps)) {
#line 1495
        goto while_break___3;
      }
#line 1496
      l_res___0 = l_current_comp->resolutions;
#line 1497
      l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1499
      l_current_comp->dx = l_img_comp->dx;
#line 1500
      l_current_comp->dy = l_img_comp->dy;
#line 1502
      resno = (OPJ_UINT32 )0;
      {
#line 1502
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1502
        if (! (resno < l_current_comp->numresolutions)) {
#line 1502
          goto while_break___4;
        }
#line 1503
        __cil_tmp45 = l_encoding_value_ptr;
#line 1503
        l_encoding_value_ptr ++;
#line 1503
        l_res___0->pdx = *__cil_tmp45;
#line 1504
        __cil_tmp46 = l_encoding_value_ptr;
#line 1504
        l_encoding_value_ptr ++;
#line 1504
        l_res___0->pdy = *__cil_tmp46;
#line 1505
        __cil_tmp47 = l_encoding_value_ptr;
#line 1505
        l_encoding_value_ptr ++;
#line 1505
        l_res___0->pw = *__cil_tmp47;
#line 1506
        __cil_tmp48 = l_encoding_value_ptr;
#line 1506
        l_encoding_value_ptr ++;
#line 1506
        l_res___0->ph = *__cil_tmp48;
#line 1507
        l_res___0 ++;
#line 1502
        resno ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: 
#line 1509
      l_current_comp ++;
#line 1510
      l_img_comp ++;
#line 1511
      l_tccp ++;
#line 1495
      compno ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: 
#line 1515
    l_current_pi->include = (l_current_pi - 1)->include;
#line 1516
    l_current_pi ++;
#line 1478
    pino ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 1519
  free((void *)l_tmp_data);
#line 1520
  l_tmp_data = (OPJ_UINT32 *)0;
#line 1521
  free((void *)l_tmp_ptr);
#line 1522
  l_tmp_ptr = (OPJ_UINT32 **)0;
  }
#line 1524
  if ((int )l_tcp->POC) {
#line 1524
    if ((int )p_cp->rsiz >= 3) {
#line 1524
      if ((int )p_cp->rsiz <= 6) {
        {
#line 1525
        opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                           l_max_prec, l_max_res, l_dx_min, l_dy_min);
        }
      } else {
#line 1524
        goto _L;
      }
    } else
    _L: 
#line 1524
    if ((unsigned int )p_t2_mode == 1U) {
      {
#line 1525
      opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                         l_max_prec, l_max_res, l_dx_min, l_dy_min);
      }
    } else {
      {
#line 1528
      opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,
                                   l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min,
                                   l_dy_min);
      }
    }
  } else {
    {
#line 1528
    opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,
                                 l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
  }
#line 1531
  return (l_pi);
}
}
#line 1534 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
void opj_pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , OPJ_UINT32 tileno ,
                          OPJ_UINT32 pino , OPJ_UINT32 tpnum , OPJ_INT32 tppos , J2K_T2_MODE t2_mode ) 
{ 
  OPJ_CHAR *prog ;
  OPJ_INT32 i ;
  OPJ_UINT32 incr_top ;
  OPJ_UINT32 resetX ;
  opj_tcp_t *tcps ;
  opj_poc_t *tcp ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_INT32 __cil_tmp22 ;

  {
  {
#line 1544
  incr_top = (OPJ_UINT32 )1;
#line 1544
  resetX = (OPJ_UINT32 )0;
#line 1545
  tcps = cp->tcps + tileno;
#line 1546
  tcp = & tcps->pocs[pino];
#line 1548
  prog = opj_j2k_convert_progression_order(tcp->prg);
#line 1550
  (pi + pino)->first = 1;
#line 1551
  (pi + pino)->poc.prg = tcp->prg;
  }
#line 1553
  if ((int )cp->m_specific_param.m_enc.m_tp_on) {
#line 1553
    if ((int )cp->rsiz >= 3) {
#line 1553
      if ((int )cp->rsiz <= 6) {
        _L___11: /* CIL Label */ 
#line 1553
        if ((int )cp->rsiz >= 3) {
#line 1553
          if ((int )cp->rsiz <= 6) {
            _L___10: /* CIL Label */ 
#line 1567
            i = tppos + 1;
            {
#line 1567
            while (1) {
              while_continue: /* CIL Label */ ;

#line 1567
              if (! (i < 4)) {
#line 1567
                goto while_break;
              }
#line 1569
              if ((int )*(prog + i) == 82) {
#line 1569
                goto case_82;
              }
#line 1573
              if ((int )*(prog + i) == 67) {
#line 1573
                goto case_67;
              }
#line 1577
              if ((int )*(prog + i) == 76) {
#line 1577
                goto case_76;
              }
#line 1581
              if ((int )*(prog + i) == 80) {
#line 1581
                goto case_80;
              }
#line 1584
              if ((int )*(prog + i) == 1) {
#line 1584
                goto case_1;
              }
#line 1584
              if ((int )*(prog + i) == 0) {
#line 1584
                goto case_1;
              }
#line 1588
              goto switch_default;
              case_82: 
#line 1570
              (pi + pino)->poc.resno0 = tcp->resS;
#line 1571
              (pi + pino)->poc.resno1 = tcp->resE;
#line 1572
              goto switch_break;
              case_67: 
#line 1574
              (pi + pino)->poc.compno0 = tcp->compS;
#line 1575
              (pi + pino)->poc.compno1 = tcp->compE;
#line 1576
              goto switch_break;
              case_76: 
#line 1578
              (pi + pino)->poc.layno0 = tcp->layS;
#line 1579
              (pi + pino)->poc.layno1 = tcp->layE;
#line 1580
              goto switch_break;
              case_80: 
#line 1584
              if ((int )tcp->prg == 1) {
#line 1584
                goto case_1;
              }
#line 1584
              if ((int )tcp->prg == 0) {
#line 1584
                goto case_1;
              }
#line 1588
              goto switch_default;
              case_1: 
#line 1585
              (pi + pino)->poc.precno0 = tcp->prcS;
#line 1586
              (pi + pino)->poc.precno1 = tcp->prcE;
#line 1587
              goto switch_break___0;
              switch_default: 
#line 1589
              (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->txS;
#line 1590
              (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->tyS;
#line 1591
              (pi + pino)->poc.tx1 = (OPJ_INT32 )tcp->txE;
#line 1592
              (pi + pino)->poc.ty1 = (OPJ_INT32 )tcp->tyE;
#line 1593
              goto switch_break___0;
              switch_break___0: ;
#line 1595
              goto switch_break;
              switch_break: 
#line 1567
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
            while_break: ;
#line 1599
            if (tpnum == 0U) {
#line 1600
              i = tppos;
              {
#line 1600
              while (1) {
                while_continue___0: /* CIL Label */ ;

#line 1600
                if (! (i >= 0)) {
#line 1600
                  goto while_break___0;
                }
#line 1602
                if ((int )*(prog + i) == 67) {
#line 1602
                  goto case_67___0;
                }
#line 1608
                if ((int )*(prog + i) == 82) {
#line 1608
                  goto case_82___0;
                }
#line 1614
                if ((int )*(prog + i) == 76) {
#line 1614
                  goto case_76___0;
                }
#line 1620
                if ((int )*(prog + i) == 80) {
#line 1620
                  goto case_80___0;
                }
#line 1623
                if ((int )*(prog + i) == 1) {
#line 1623
                  goto case_1___0;
                }
#line 1623
                if ((int )*(prog + i) == 0) {
#line 1623
                  goto case_1___0;
                }
#line 1629
                goto switch_default___0;
                case_67___0: 
#line 1603
                tcp->comp_t = tcp->compS;
#line 1604
                (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1605
                (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1606
                (tcp->comp_t) ++;
#line 1607
                goto switch_break___1;
                case_82___0: 
#line 1609
                tcp->res_t = tcp->resS;
#line 1610
                (pi + pino)->poc.resno0 = tcp->res_t;
#line 1611
                (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1612
                (tcp->res_t) ++;
#line 1613
                goto switch_break___1;
                case_76___0: 
#line 1615
                tcp->lay_t = tcp->layS;
#line 1616
                (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1617
                (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1618
                (tcp->lay_t) ++;
#line 1619
                goto switch_break___1;
                case_80___0: 
#line 1623
                if ((int )tcp->prg == 1) {
#line 1623
                  goto case_1___0;
                }
#line 1623
                if ((int )tcp->prg == 0) {
#line 1623
                  goto case_1___0;
                }
#line 1629
                goto switch_default___0;
                case_1___0: 
#line 1624
                tcp->prc_t = tcp->prcS;
#line 1625
                (pi + pino)->poc.precno0 = tcp->prc_t;
#line 1626
                (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 1627
                (tcp->prc_t) ++;
#line 1628
                goto switch_break___2;
                switch_default___0: 
#line 1630
                tcp->tx0_t = tcp->txS;
#line 1631
                tcp->ty0_t = tcp->tyS;
#line 1632
                (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->tx0_t;
#line 1633
                (pi + pino)->poc.tx1 = (OPJ_INT32 )((tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1634
                (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->ty0_t;
#line 1635
                (pi + pino)->poc.ty1 = (OPJ_INT32 )((tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1636
                tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
#line 1637
                tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 1638
                goto switch_break___2;
                switch_break___2: ;
#line 1640
                goto switch_break___1;
                switch_break___1: 
#line 1600
                __cil_tmp16 = i;
#line 1600
                i --;
              }
              while_break___3: /* CIL Label */ ;
              }
              while_break___0: 
#line 1643
              incr_top = (OPJ_UINT32 )1;
            } else {
#line 1645
              i = tppos;
              {
#line 1645
              while (1) {
                while_continue___1: /* CIL Label */ ;

#line 1645
                if (! (i >= 0)) {
#line 1645
                  goto while_break___1;
                }
#line 1647
                if ((int )*(prog + i) == 67) {
#line 1647
                  goto case_67___1;
                }
#line 1651
                if ((int )*(prog + i) == 82) {
#line 1651
                  goto case_82___1;
                }
#line 1655
                if ((int )*(prog + i) == 76) {
#line 1655
                  goto case_76___1;
                }
#line 1659
                if ((int )*(prog + i) == 80) {
#line 1659
                  goto case_80___1;
                }
#line 1662
                if ((int )*(prog + i) == 1) {
#line 1662
                  goto case_1___1;
                }
#line 1662
                if ((int )*(prog + i) == 0) {
#line 1662
                  goto case_1___1;
                }
#line 1666
                goto switch_default___1;
                case_67___1: 
#line 1648
                (pi + pino)->poc.compno0 = tcp->comp_t - 1U;
#line 1649
                (pi + pino)->poc.compno1 = tcp->comp_t;
#line 1650
                goto switch_break___3;
                case_82___1: 
#line 1652
                (pi + pino)->poc.resno0 = tcp->res_t - 1U;
#line 1653
                (pi + pino)->poc.resno1 = tcp->res_t;
#line 1654
                goto switch_break___3;
                case_76___1: 
#line 1656
                (pi + pino)->poc.layno0 = tcp->lay_t - 1U;
#line 1657
                (pi + pino)->poc.layno1 = tcp->lay_t;
#line 1658
                goto switch_break___3;
                case_80___1: 
#line 1662
                if ((int )tcp->prg == 1) {
#line 1662
                  goto case_1___1;
                }
#line 1662
                if ((int )tcp->prg == 0) {
#line 1662
                  goto case_1___1;
                }
#line 1666
                goto switch_default___1;
                case_1___1: 
#line 1663
                (pi + pino)->poc.precno0 = tcp->prc_t - 1U;
#line 1664
                (pi + pino)->poc.precno1 = tcp->prc_t;
#line 1665
                goto switch_break___4;
                switch_default___1: 
#line 1667
                (pi + pino)->poc.tx0 = (OPJ_INT32 )((tcp->tx0_t - tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1668
                (pi + pino)->poc.tx1 = (OPJ_INT32 )tcp->tx0_t;
#line 1669
                (pi + pino)->poc.ty0 = (OPJ_INT32 )((tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1670
                (pi + pino)->poc.ty1 = (OPJ_INT32 )tcp->ty0_t;
#line 1671
                goto switch_break___4;
                switch_break___4: ;
#line 1673
                goto switch_break___3;
                switch_break___3: ;
#line 1675
                if (incr_top == 1U) {
#line 1677
                  if ((int )*(prog + i) == 82) {
#line 1677
                    goto case_82___2;
                  }
#line 1695
                  if ((int )*(prog + i) == 67) {
#line 1695
                    goto case_67___2;
                  }
#line 1713
                  if ((int )*(prog + i) == 76) {
#line 1713
                    goto case_76___2;
                  }
#line 1731
                  if ((int )*(prog + i) == 80) {
#line 1731
                    goto case_80___2;
                  }
#line 1734
                  if ((int )*(prog + i) == 1) {
#line 1734
                    goto case_1___2;
                  }
#line 1734
                  if ((int )*(prog + i) == 0) {
#line 1734
                    goto case_1___2;
                  }
#line 1752
                  goto switch_default___2;
                  case_82___2: 
#line 1678
                  if (tcp->res_t == tcp->resE) {
                    {
#line 1679
                    __cil_tmp17 = opj_pi_check_next_level(i - 1, cp, tileno, pino,
                                                          prog);
                    }
#line 1679
                    if (__cil_tmp17) {
#line 1680
                      tcp->res_t = tcp->resS;
#line 1681
                      (pi + pino)->poc.resno0 = tcp->res_t;
#line 1682
                      (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1683
                      (tcp->res_t) ++;
#line 1684
                      incr_top = (OPJ_UINT32 )1;
                    } else {
#line 1686
                      incr_top = (OPJ_UINT32 )0;
                    }
                  } else {
#line 1689
                    (pi + pino)->poc.resno0 = tcp->res_t;
#line 1690
                    (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1691
                    (tcp->res_t) ++;
#line 1692
                    incr_top = (OPJ_UINT32 )0;
                  }
#line 1694
                  goto switch_break___5;
                  case_67___2: 
#line 1696
                  if (tcp->comp_t == tcp->compE) {
                    {
#line 1697
                    __cil_tmp18 = opj_pi_check_next_level(i - 1, cp, tileno, pino,
                                                          prog);
                    }
#line 1697
                    if (__cil_tmp18) {
#line 1698
                      tcp->comp_t = tcp->compS;
#line 1699
                      (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1700
                      (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1701
                      (tcp->comp_t) ++;
#line 1702
                      incr_top = (OPJ_UINT32 )1;
                    } else {
#line 1704
                      incr_top = (OPJ_UINT32 )0;
                    }
                  } else {
#line 1707
                    (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1708
                    (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1709
                    (tcp->comp_t) ++;
#line 1710
                    incr_top = (OPJ_UINT32 )0;
                  }
#line 1712
                  goto switch_break___5;
                  case_76___2: 
#line 1714
                  if (tcp->lay_t == tcp->layE) {
                    {
#line 1715
                    __cil_tmp19 = opj_pi_check_next_level(i - 1, cp, tileno, pino,
                                                          prog);
                    }
#line 1715
                    if (__cil_tmp19) {
#line 1716
                      tcp->lay_t = tcp->layS;
#line 1717
                      (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1718
                      (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1719
                      (tcp->lay_t) ++;
#line 1720
                      incr_top = (OPJ_UINT32 )1;
                    } else {
#line 1722
                      incr_top = (OPJ_UINT32 )0;
                    }
                  } else {
#line 1725
                    (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1726
                    (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1727
                    (tcp->lay_t) ++;
#line 1728
                    incr_top = (OPJ_UINT32 )0;
                  }
#line 1730
                  goto switch_break___5;
                  case_80___2: 
#line 1734
                  if ((int )tcp->prg == 1) {
#line 1734
                    goto case_1___2;
                  }
#line 1734
                  if ((int )tcp->prg == 0) {
#line 1734
                    goto case_1___2;
                  }
#line 1752
                  goto switch_default___2;
                  case_1___2: 
#line 1735
                  if (tcp->prc_t == tcp->prcE) {
                    {
#line 1736
                    __cil_tmp20 = opj_pi_check_next_level(i - 1, cp, tileno, pino,
                                                          prog);
                    }
#line 1736
                    if (__cil_tmp20) {
#line 1737
                      tcp->prc_t = tcp->prcS;
#line 1738
                      (pi + pino)->poc.precno0 = tcp->prc_t;
#line 1739
                      (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 1740
                      (tcp->prc_t) ++;
#line 1741
                      incr_top = (OPJ_UINT32 )1;
                    } else {
#line 1743
                      incr_top = (OPJ_UINT32 )0;
                    }
                  } else {
#line 1746
                    (pi + pino)->poc.precno0 = tcp->prc_t;
#line 1747
                    (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 1748
                    (tcp->prc_t) ++;
#line 1749
                    incr_top = (OPJ_UINT32 )0;
                  }
#line 1751
                  goto switch_break___6;
                  switch_default___2: 
#line 1753
                  if (tcp->tx0_t >= tcp->txE) {
#line 1754
                    if (tcp->ty0_t >= tcp->tyE) {
                      {
#line 1755
                      __cil_tmp21 = opj_pi_check_next_level(i - 1, cp, tileno, pino,
                                                            prog);
                      }
#line 1755
                      if (__cil_tmp21) {
#line 1756
                        tcp->ty0_t = tcp->tyS;
#line 1757
                        (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->ty0_t;
#line 1758
                        (pi + pino)->poc.ty1 = (OPJ_INT32 )((tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1759
                        tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 1760
                        incr_top = (OPJ_UINT32 )1;
#line 1760
                        resetX = (OPJ_UINT32 )1;
                      } else {
#line 1762
                        incr_top = (OPJ_UINT32 )0;
#line 1762
                        resetX = (OPJ_UINT32 )0;
                      }
                    } else {
#line 1765
                      (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->ty0_t;
#line 1766
                      (pi + pino)->poc.ty1 = (OPJ_INT32 )((tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1767
                      tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 1768
                      incr_top = (OPJ_UINT32 )0;
#line 1768
                      resetX = (OPJ_UINT32 )1;
                    }
#line 1770
                    if (resetX == 1U) {
#line 1771
                      tcp->tx0_t = tcp->txS;
#line 1772
                      (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->tx0_t;
#line 1773
                      (pi + pino)->poc.tx1 = (OPJ_INT32 )((tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1774
                      tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
                    }
                  } else {
#line 1777
                    (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->tx0_t;
#line 1778
                    (pi + pino)->poc.tx1 = (OPJ_INT32 )((tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1779
                    tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
#line 1780
                    incr_top = (OPJ_UINT32 )0;
                  }
#line 1782
                  goto switch_break___6;
                  switch_break___6: ;
#line 1784
                  goto switch_break___5;
                  switch_break___5: ;
                }
#line 1645
                __cil_tmp22 = i;
#line 1645
                i --;
              }
              while_break___4: /* CIL Label */ ;
              }
              while_break___1: ;
            }
          } else {
#line 1553
            goto _L___9;
          }
        } else {
#line 1553
          goto _L___9;
        }
      } else {
#line 1553
        goto _L___12;
      }
    } else
    _L___12: /* CIL Label */ 
#line 1553
    if ((unsigned int )t2_mode == 1U) {
#line 1553
      goto _L___10;
    } else {
#line 1553
      goto _L___11;
    }
  } else {
    _L___9: /* CIL Label */ 
#line 1554
    (pi + pino)->poc.resno0 = tcp->resS;
#line 1555
    (pi + pino)->poc.resno1 = tcp->resE;
#line 1556
    (pi + pino)->poc.compno0 = tcp->compS;
#line 1557
    (pi + pino)->poc.compno1 = tcp->compE;
#line 1558
    (pi + pino)->poc.layno0 = tcp->layS;
#line 1559
    (pi + pino)->poc.layno1 = tcp->layE;
#line 1560
    (pi + pino)->poc.precno0 = tcp->prcS;
#line 1561
    (pi + pino)->poc.precno1 = tcp->prcE;
#line 1562
    (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->txS;
#line 1563
    (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->tyS;
#line 1564
    (pi + pino)->poc.tx1 = (OPJ_INT32 )tcp->txE;
#line 1565
    (pi + pino)->poc.ty1 = (OPJ_INT32 )tcp->tyE;
  }
#line 1651
  return;
}
}
#line 1792 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
void opj_pi_destroy(opj_pi_iterator_t *p_pi , OPJ_UINT32 p_nb_elements ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 pino ;
  opj_pi_iterator_t *l_current_pi ;
  opj_pi_comp_t *l_current_component ;

  {
#line 1796
  l_current_pi = p_pi;
#line 1797
  if (p_pi) {
#line 1798
    if (p_pi->include) {
      {
#line 1799
      free((void *)p_pi->include);
#line 1800
      p_pi->include = (OPJ_INT16 *)0;
      }
    }
#line 1802
    pino = (OPJ_UINT32 )0;
    {
#line 1802
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1802
      if (! (pino < p_nb_elements)) {
#line 1802
        goto while_break;
      }
#line 1803
      if (l_current_pi->comps) {
#line 1804
        l_current_component = l_current_pi->comps;
#line 1805
        compno = (OPJ_UINT32 )0;
        {
#line 1805
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 1805
          if (! (compno < l_current_pi->numcomps)) {
#line 1805
            goto while_break___0;
          }
#line 1806
          if (l_current_component->resolutions) {
            {
#line 1807
            free((void *)l_current_component->resolutions);
#line 1808
            l_current_component->resolutions = (opj_pi_resolution_t *)0;
            }
          }
#line 1811
          l_current_component ++;
#line 1805
          compno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: 
        {
#line 1813
        free((void *)l_current_pi->comps);
#line 1814
        l_current_pi->comps = (opj_pi_comp_t *)0;
        }
      }
#line 1816
      l_current_pi ++;
#line 1802
      pino ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 1818
    free((void *)p_pi);
    }
  }
#line 1821
  return;
}
}
#line 1824 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
void opj_pi_update_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_INT32 l_tx0 ;
  OPJ_INT32 l_tx1 ;
  OPJ_INT32 l_ty0 ;
  OPJ_INT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  opj_tcp_t *l_tcp ;

  {
  {
#line 1835
  l_tcp = (opj_tcp_t *)0;
#line 1842
  l_tcp = p_cp->tcps + p_tile_no;
#line 1845
  opj_get_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                              & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res);
  }
#line 1847
  if (l_tcp->POC) {
    {
#line 1848
    opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                       l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
  } else {
    {
#line 1851
    opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,
                                 l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
  }
#line 1855
  return;
}
}
#line 1855 "/root/patchweave_new/10/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next(opj_pi_iterator_t *pi ) 
{ 
  OPJ_BOOL __cil_tmp2 ;
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 1857
  if ((int )pi->poc.prg == 0) {
#line 1857
    goto case_0;
  }
#line 1859
  if ((int )pi->poc.prg == 1) {
#line 1859
    goto case_1;
  }
#line 1861
  if ((int )pi->poc.prg == 2) {
#line 1861
    goto case_2;
  }
#line 1863
  if ((int )pi->poc.prg == 3) {
#line 1863
    goto case_3;
  }
#line 1865
  if ((int )pi->poc.prg == 4) {
#line 1865
    goto case_4;
  }
#line 1867
  if ((int )pi->poc.prg == -1) {
#line 1867
    goto case_neg_1;
  }
#line 1856
  goto switch_break;
  case_0: 
  {
#line 1858
  __cil_tmp2 = opj_pi_next_lrcp(pi);
  }
#line 1858
  return (__cil_tmp2);
  case_1: 
  {
#line 1860
  __cil_tmp3 = opj_pi_next_rlcp(pi);
  }
#line 1860
  return (__cil_tmp3);
  case_2: 
  {
#line 1862
  __cil_tmp4 = opj_pi_next_rpcl(pi);
  }
#line 1862
  return (__cil_tmp4);
  case_3: 
  {
#line 1864
  __cil_tmp5 = opj_pi_next_pcrl(pi);
  }
#line 1864
  return (__cil_tmp5);
  case_4: 
  {
#line 1866
  __cil_tmp6 = opj_pi_next_cprl(pi);
  }
#line 1866
  return (__cil_tmp6);
  case_neg_1: 
#line 1868
  return (0);
  switch_break: ;
#line 1871
  return (0);
}
}
#line 87 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 41 "/root/patchweave_new/10/src/lib/openjp2/opj_clock.c"
OPJ_FLOAT64 opj_clock(void) 
{ 
  struct rusage t ;
  OPJ_FLOAT64 procTime ;

  {
  {
#line 56
  getrusage(0, & t);
#line 59
  procTime = (OPJ_FLOAT64 )(t.ru_utime.tv_sec + t.ru_stime.tv_sec);
  }
#line 61
  return (procTime + (OPJ_FLOAT64 )(t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-06);
}
}
#line 52 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_byteout(opj_mqc_t *mqc ) ;
#line 57
void opj_mqc_renorme(opj_mqc_t *mqc ) ;
#line 62
void opj_mqc_codemps(opj_mqc_t *mqc ) ;
#line 67
void opj_mqc_codelps(opj_mqc_t *mqc ) ;
#line 72
void opj_mqc_setbits(opj_mqc_t *mqc ) ;
#line 78
__inline static OPJ_INT32 opj_mqc_mpsexchange(opj_mqc_t *mqc ) ;
#line 84
__inline static OPJ_INT32 opj_mqc_lpsexchange(opj_mqc_t *mqc ) ;
#line 89
static void opj_mqc_bytein(opj_mqc_t *mqc ) ;
#line 94
__inline static void opj_mqc_renormd(opj_mqc_t *mqc ) ;
#line 102 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
static opj_mqc_state_t mqc_states[94]  = 
#line 102
  {      {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[2], & mqc_states[3]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[3], & mqc_states[2]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )0, & mqc_states[4], & mqc_states[12]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )1, & mqc_states[5], & mqc_states[13]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )0, & mqc_states[6], & mqc_states[18]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )1, & mqc_states[7], & mqc_states[19]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )0, & mqc_states[8], & mqc_states[24]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )1, & mqc_states[9], & mqc_states[25]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )0, & mqc_states[10], & mqc_states[58]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )1, & mqc_states[11], & mqc_states[59]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )0, & mqc_states[76], & mqc_states[66]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )1, & mqc_states[77], & mqc_states[67]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[14], & mqc_states[13]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[15], & mqc_states[12]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )0, & mqc_states[16], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )1, & mqc_states[17], & mqc_states[29]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )0, & mqc_states[18], & mqc_states[28]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )1, & mqc_states[19], & mqc_states[29]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )0, & mqc_states[20], & mqc_states[28]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )1, & mqc_states[21], & mqc_states[29]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )0, & mqc_states[22], & mqc_states[34]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )1, & mqc_states[23], & mqc_states[35]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )0, & mqc_states[24], & mqc_states[36]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )1, & mqc_states[25], & mqc_states[37]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )0, & mqc_states[26], & mqc_states[40]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )1, & mqc_states[27], & mqc_states[41]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )0, & mqc_states[58], & mqc_states[42]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )1, & mqc_states[59], & mqc_states[43]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[30], & mqc_states[29]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[31], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )0, & mqc_states[32], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )1, & mqc_states[33], & mqc_states[29]}, 
        {(OPJ_UINT32 )20737, (OPJ_UINT32 )0, & mqc_states[34], & mqc_states[30]}, 
        {(OPJ_UINT32 )20737, (OPJ_UINT32 )1, & mqc_states[35], & mqc_states[31]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )0, & mqc_states[36], & mqc_states[32]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )1, & mqc_states[37], & mqc_states[33]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )0, & mqc_states[38], & mqc_states[34]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )1, & mqc_states[39], & mqc_states[35]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )0, & mqc_states[40], & mqc_states[36]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )1, & mqc_states[41], & mqc_states[37]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )0, & mqc_states[42], & mqc_states[38]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )1, & mqc_states[43], & mqc_states[39]}, 
        {(OPJ_UINT32 )10241, (OPJ_UINT32 )0, & mqc_states[44], & mqc_states[38]}, 
        {(OPJ_UINT32 )10241, (OPJ_UINT32 )1, & mqc_states[45], & mqc_states[39]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )0, & mqc_states[46], & mqc_states[40]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )1, & mqc_states[47], & mqc_states[41]}, 
        {(OPJ_UINT32 )8705, (OPJ_UINT32 )0, & mqc_states[48], & mqc_states[42]}, 
        {(OPJ_UINT32 )8705, (OPJ_UINT32 )1, & mqc_states[49], & mqc_states[43]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )0, & mqc_states[50], & mqc_states[44]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )1, & mqc_states[51], & mqc_states[45]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )0, & mqc_states[52], & mqc_states[46]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )1, & mqc_states[53], & mqc_states[47]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )0, & mqc_states[54], & mqc_states[48]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )1, & mqc_states[55], & mqc_states[49]}, 
        {(OPJ_UINT32 )5121, (OPJ_UINT32 )0, & mqc_states[56], & mqc_states[50]}, 
        {(OPJ_UINT32 )5121, (OPJ_UINT32 )1, & mqc_states[57], & mqc_states[51]}, 
        {(OPJ_UINT32 )4609, (OPJ_UINT32 )0, & mqc_states[58], & mqc_states[52]}, 
        {(OPJ_UINT32 )4609, (OPJ_UINT32 )1, & mqc_states[59], & mqc_states[53]}, 
        {(OPJ_UINT32 )4353, (OPJ_UINT32 )0, & mqc_states[60], & mqc_states[54]}, 
        {(OPJ_UINT32 )4353, (OPJ_UINT32 )1, & mqc_states[61], & mqc_states[55]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )0, & mqc_states[62], & mqc_states[56]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )1, & mqc_states[63], & mqc_states[57]}, 
        {(OPJ_UINT32 )2497, (OPJ_UINT32 )0, & mqc_states[64], & mqc_states[58]}, 
        {(OPJ_UINT32 )2497, (OPJ_UINT32 )1, & mqc_states[65], & mqc_states[59]}, 
        {(OPJ_UINT32 )2209, (OPJ_UINT32 )0, & mqc_states[66], & mqc_states[60]}, 
        {(OPJ_UINT32 )2209, (OPJ_UINT32 )1, & mqc_states[67], & mqc_states[61]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )0, & mqc_states[68], & mqc_states[62]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )1, & mqc_states[69], & mqc_states[63]}, 
        {(OPJ_UINT32 )1089, (OPJ_UINT32 )0, & mqc_states[70], & mqc_states[64]}, 
        {(OPJ_UINT32 )1089, (OPJ_UINT32 )1, & mqc_states[71], & mqc_states[65]}, 
        {(OPJ_UINT32 )673, (OPJ_UINT32 )0, & mqc_states[72], & mqc_states[66]}, 
        {(OPJ_UINT32 )673, (OPJ_UINT32 )1, & mqc_states[73], & mqc_states[67]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )0, & mqc_states[74], & mqc_states[68]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )1, & mqc_states[75], & mqc_states[69]}, 
        {(OPJ_UINT32 )321, (OPJ_UINT32 )0, & mqc_states[76], & mqc_states[70]}, 
        {(OPJ_UINT32 )321, (OPJ_UINT32 )1, & mqc_states[77], & mqc_states[71]}, 
        {(OPJ_UINT32 )273, (OPJ_UINT32 )0, & mqc_states[78], & mqc_states[72]}, 
        {(OPJ_UINT32 )273, (OPJ_UINT32 )1, & mqc_states[79], & mqc_states[73]}, 
        {(OPJ_UINT32 )133, (OPJ_UINT32 )0, & mqc_states[80], & mqc_states[74]}, 
        {(OPJ_UINT32 )133, (OPJ_UINT32 )1, & mqc_states[81], & mqc_states[75]}, 
        {(OPJ_UINT32 )73, (OPJ_UINT32 )0, & mqc_states[82], & mqc_states[76]}, 
        {(OPJ_UINT32 )73, (OPJ_UINT32 )1, & mqc_states[83], & mqc_states[77]}, 
        {(OPJ_UINT32 )37, (OPJ_UINT32 )0, & mqc_states[84], & mqc_states[78]}, 
        {(OPJ_UINT32 )37, (OPJ_UINT32 )1, & mqc_states[85], & mqc_states[79]}, 
        {(OPJ_UINT32 )21, (OPJ_UINT32 )0, & mqc_states[86], & mqc_states[80]}, 
        {(OPJ_UINT32 )21, (OPJ_UINT32 )1, & mqc_states[87], & mqc_states[81]}, 
        {(OPJ_UINT32 )9, (OPJ_UINT32 )0, & mqc_states[88], & mqc_states[82]}, 
        {(OPJ_UINT32 )9, (OPJ_UINT32 )1, & mqc_states[89], & mqc_states[83]}, 
        {(OPJ_UINT32 )5, (OPJ_UINT32 )0, & mqc_states[90], & mqc_states[84]}, 
        {(OPJ_UINT32 )5, (OPJ_UINT32 )1, & mqc_states[91], & mqc_states[85]}, 
        {(OPJ_UINT32 )1, (OPJ_UINT32 )0, & mqc_states[90], & mqc_states[86]}, 
        {(OPJ_UINT32 )1, (OPJ_UINT32 )1, & mqc_states[91], & mqc_states[87]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[92], & mqc_states[92]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[93], & mqc_states[93]}};
#line 205 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_byteout(opj_mqc_t *mqc ) 
{ 


  {
#line 206
  if ((int )*(mqc->bp) == 255) {
#line 207
    (mqc->bp) ++;
#line 208
    *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 20);
#line 209
    mqc->c &= 1048575U;
#line 210
    mqc->ct = (OPJ_UINT32 )7;
  } else
#line 212
  if ((mqc->c & 134217728U) == 0U) {
#line 213
    (mqc->bp) ++;
#line 214
    *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 19);
#line 215
    mqc->c &= 524287U;
#line 216
    mqc->ct = (OPJ_UINT32 )8;
  } else {
#line 218
    *(mqc->bp) = (OPJ_BYTE )((int )*(mqc->bp) + 1);
#line 219
    if ((int )*(mqc->bp) == 255) {
#line 220
      mqc->c &= 134217727U;
#line 221
      (mqc->bp) ++;
#line 222
      *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 20);
#line 223
      mqc->c &= 1048575U;
#line 224
      mqc->ct = (OPJ_UINT32 )7;
    } else {
#line 226
      (mqc->bp) ++;
#line 227
      *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 19);
#line 228
      mqc->c &= 524287U;
#line 229
      mqc->ct = (OPJ_UINT32 )8;
    }
  }
#line 232
  return;
}
}
#line 235 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_renorme(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    mqc->a <<= 1;
#line 238
    mqc->c <<= 1;
#line 239
    __cil_tmp2 = mqc->ct;
#line 239
    (mqc->ct) --;
#line 240
    if (mqc->ct == 0U) {
      {
#line 241
      opj_mqc_byteout(mqc);
      }
    }
#line 236
    if (! ((mqc->a & 32768U) == 0U)) {
#line 236
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 241
  return;
}
}
#line 246 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_codemps(opj_mqc_t *mqc ) 
{ 


  {
#line 247
  mqc->a -= (*(mqc->curctx))->qeval;
#line 248
  if ((mqc->a & 32768U) == 0U) {
#line 249
    if (mqc->a < (*(mqc->curctx))->qeval) {
#line 250
      mqc->a = (*(mqc->curctx))->qeval;
    } else {
#line 252
      mqc->c += (*(mqc->curctx))->qeval;
    }
    {
#line 254
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
#line 255
    opj_mqc_renorme(mqc);
    }
  } else {
#line 257
    mqc->c += (*(mqc->curctx))->qeval;
  }
#line 259
  return;
}
}
#line 261 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_codelps(opj_mqc_t *mqc ) 
{ 


  {
#line 262
  mqc->a -= (*(mqc->curctx))->qeval;
#line 263
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 264
    mqc->c += (*(mqc->curctx))->qeval;
  } else {
#line 266
    mqc->a = (*(mqc->curctx))->qeval;
  }
  {
#line 268
  *(mqc->curctx) = (*(mqc->curctx))->nlps;
#line 269
  opj_mqc_renorme(mqc);
  }
#line 271
  return;
}
}
#line 272 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_setbits(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 tempc ;

  {
#line 273
  tempc = mqc->c + mqc->a;
#line 274
  mqc->c |= 65535U;
#line 275
  if (mqc->c >= tempc) {
#line 276
    mqc->c -= 32768U;
  }
#line 278
  return;
}
}
#line 280 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
__inline static OPJ_INT32 opj_mqc_mpsexchange(opj_mqc_t *mqc ) 
{ 
  OPJ_INT32 d ;

  {
#line 282
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 283
    d = (OPJ_INT32 )(1U - (*(mqc->curctx))->mps);
#line 284
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  } else {
#line 286
    d = (OPJ_INT32 )(*(mqc->curctx))->mps;
#line 287
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  }
#line 290
  return (d);
}
}
#line 293 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
__inline static OPJ_INT32 opj_mqc_lpsexchange(opj_mqc_t *mqc ) 
{ 
  OPJ_INT32 d ;

  {
#line 295
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 296
    mqc->a = (*(mqc->curctx))->qeval;
#line 297
    d = (OPJ_INT32 )(*(mqc->curctx))->mps;
#line 298
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  } else {
#line 300
    mqc->a = (*(mqc->curctx))->qeval;
#line 301
    d = (OPJ_INT32 )(1U - (*(mqc->curctx))->mps);
#line 302
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  }
#line 305
  return (d);
}
}
#line 316 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
static void opj_mqc_bytein(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 c ;

  {
#line 317
  if ((unsigned long )mqc->bp != (unsigned long )mqc->end) {
#line 319
    if ((unsigned long )(mqc->bp + 1) != (unsigned long )mqc->end) {
#line 320
      c = (OPJ_UINT32 )*(mqc->bp + 1);
    } else {
#line 322
      c = (OPJ_UINT32 )255;
    }
#line 324
    if ((int )*(mqc->bp) == 255) {
#line 325
      if (c > 143U) {
#line 326
        mqc->c += 65280U;
#line 327
        mqc->ct = (OPJ_UINT32 )8;
      } else {
#line 329
        (mqc->bp) ++;
#line 330
        mqc->c += c << 9;
#line 331
        mqc->ct = (OPJ_UINT32 )7;
      }
    } else {
#line 334
      (mqc->bp) ++;
#line 335
      mqc->c += c << 8;
#line 336
      mqc->ct = (OPJ_UINT32 )8;
    }
  } else {
#line 339
    mqc->c += 65280U;
#line 340
    mqc->ct = (OPJ_UINT32 )8;
  }
#line 342
  return;
}
}
#line 345 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
__inline static void opj_mqc_renormd(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;

#line 347
    if (mqc->ct == 0U) {
      {
#line 348
      opj_mqc_bytein(mqc);
      }
    }
#line 350
    mqc->a <<= 1;
#line 351
    mqc->c <<= 1;
#line 352
    __cil_tmp2 = mqc->ct;
#line 352
    (mqc->ct) --;
#line 346
    if (! (mqc->a < 32768U)) {
#line 346
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 351
  return;
}
}
#line 362 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
opj_mqc_t *opj_mqc_create(void) 
{ 
  opj_mqc_t *mqc ;
  void *__cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = malloc(sizeof(opj_mqc_t ));
#line 363
  mqc = (opj_mqc_t *)__cil_tmp2;
  }
#line 369
  return (mqc);
}
}
#line 372 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_destroy(opj_mqc_t *mqc ) 
{ 


  {
#line 373
  if (mqc) {
    {
#line 379
    free((void *)mqc);
    }
  }
#line 382
  return;
}
}
#line 383 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
OPJ_UINT32 opj_mqc_numbytes(opj_mqc_t *mqc ) 
{ 
  ptrdiff_t diff ;

  {
#line 384
  diff = mqc->bp - mqc->start;
#line 388
  return ((OPJ_UINT32 )diff);
}
}
#line 391 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_init_enc(opj_mqc_t *mqc , OPJ_BYTE *bp ) 
{ 


  {
#line 393
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )0];
#line 394
  mqc->a = (OPJ_UINT32 )32768;
#line 395
  mqc->c = (OPJ_UINT32 )0;
#line 396
  mqc->bp = bp - 1;
#line 397
  mqc->ct = (OPJ_UINT32 )12;
#line 398
  if ((int )*(mqc->bp) == 255) {
#line 399
    mqc->ct = (OPJ_UINT32 )13;
  }
#line 401
  mqc->start = bp;
#line 402
  return;
}
}
#line 404 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_encode(opj_mqc_t *mqc , OPJ_UINT32 d ) 
{ 


  {
#line 405
  if ((*(mqc->curctx))->mps == d) {
    {
#line 406
    opj_mqc_codemps(mqc);
    }
  } else {
    {
#line 408
    opj_mqc_codelps(mqc);
    }
  }
#line 411
  return;
}
}
#line 412 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_flush(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 413
  opj_mqc_setbits(mqc);
#line 414
  mqc->c <<= mqc->ct;
#line 415
  opj_mqc_byteout(mqc);
#line 416
  mqc->c <<= mqc->ct;
#line 417
  opj_mqc_byteout(mqc);
  }
#line 419
  if ((int )*(mqc->bp) != 255) {
#line 420
    (mqc->bp) ++;
  }
#line 422
  return;
}
}
#line 424 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_bypass_init_enc(opj_mqc_t *mqc ) 
{ 


  {
#line 425
  mqc->c = (OPJ_UINT32 )0;
#line 426
  mqc->ct = (OPJ_UINT32 )8;
#line 427
  return;
}
}
#line 432 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_bypass_enc(opj_mqc_t *mqc , OPJ_UINT32 d ) 
{ 
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 433
  __cil_tmp3 = mqc->ct;
#line 433
  (mqc->ct) --;
#line 434
  mqc->c += d << mqc->ct;
#line 435
  if (mqc->ct == 0U) {
#line 436
    (mqc->bp) ++;
#line 437
    *(mqc->bp) = (OPJ_BYTE )mqc->c;
#line 438
    mqc->ct = (OPJ_UINT32 )8;
#line 439
    if ((int )*(mqc->bp) == 255) {
#line 440
      mqc->ct = (OPJ_UINT32 )7;
    }
#line 442
    mqc->c = (OPJ_UINT32 )0;
  }
#line 444
  return;
}
}
#line 446 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
OPJ_UINT32 opj_mqc_bypass_flush_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_BYTE bit_padding ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 449
  bit_padding = (OPJ_BYTE )0;
#line 451
  if (mqc->ct != 0U) {
    {
#line 452
    while (1) {
      while_continue: /* CIL Label */ ;

#line 452
      if (! (mqc->ct > 0U)) {
#line 452
        goto while_break;
      }
#line 453
      __cil_tmp3 = mqc->ct;
#line 453
      (mqc->ct) --;
#line 454
      mqc->c += (OPJ_UINT32 )((int )bit_padding << mqc->ct);
#line 455
      bit_padding = (OPJ_BYTE )(((int )bit_padding + 1) & 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 457
    (mqc->bp) ++;
#line 458
    *(mqc->bp) = (OPJ_BYTE )mqc->c;
#line 459
    mqc->ct = (OPJ_UINT32 )8;
#line 460
    mqc->c = (OPJ_UINT32 )0;
  }
#line 463
  return ((OPJ_UINT32 )1);
}
}
#line 466 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_reset_enc(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 467
  opj_mqc_resetstates(mqc);
#line 468
  opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 469
  opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 470
  opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
  }
#line 472
  return;
}
}
#line 473 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
OPJ_UINT32 opj_mqc_restart_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 correction ;
  OPJ_INT32 n ;

  {
#line 474
  correction = (OPJ_UINT32 )1;
#line 477
  n = (OPJ_INT32 )(12U - mqc->ct);
#line 478
  mqc->c <<= mqc->ct;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;

#line 479
    if (! (n > 0)) {
#line 479
      goto while_break;
    }
    {
#line 480
    opj_mqc_byteout(mqc);
#line 481
    n -= (OPJ_INT32 )mqc->ct;
#line 482
    mqc->c <<= mqc->ct;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 484
  opj_mqc_byteout(mqc);
  }
#line 486
  return (correction);
}
}
#line 489 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_restart_init_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_BYTE *__cil_tmp2 ;

  {
#line 491
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )0];
#line 492
  mqc->a = (OPJ_UINT32 )32768;
#line 493
  mqc->c = (OPJ_UINT32 )0;
#line 494
  mqc->ct = (OPJ_UINT32 )12;
#line 495
  __cil_tmp2 = mqc->bp;
#line 495
  (mqc->bp) --;
#line 496
  if ((int )*(mqc->bp) == 255) {
#line 497
    mqc->ct = (OPJ_UINT32 )13;
  }
#line 499
  return;
}
}
#line 501 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_erterm_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_INT32 k ;

  {
#line 502
  k = (OPJ_INT32 )((11U - mqc->ct) + 1U);
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;

#line 504
    if (! (k > 0)) {
#line 504
      goto while_break;
    }
    {
#line 505
    mqc->c <<= mqc->ct;
#line 506
    mqc->ct = (OPJ_UINT32 )0;
#line 507
    opj_mqc_byteout(mqc);
#line 508
    k -= (OPJ_INT32 )mqc->ct;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 511
  if ((int )*(mqc->bp) != 255) {
    {
#line 512
    opj_mqc_byteout(mqc);
    }
  }
#line 515
  return;
}
}
#line 516 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_segmark_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 i ;

  {
#line 518
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 520
  i = (OPJ_UINT32 )1;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;

#line 520
    if (! (i < 5U)) {
#line 520
      goto while_break;
    }
    {
#line 521
    opj_mqc_encode(mqc, i % 2U);
#line 520
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 524
  return;
}
}
#line 525 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
OPJ_BOOL opj_mqc_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 526
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )0];
#line 527
  mqc->start = bp;
#line 528
  mqc->end = bp + len;
#line 529
  mqc->bp = bp;
#line 530
  if (len == 0U) {
#line 530
    mqc->c = (OPJ_UINT32 )(255 << 16);
  } else {
#line 531
    mqc->c = (OPJ_UINT32 )((int )*(mqc->bp) << 16);
  }
  {
#line 577
  opj_mqc_bytein(mqc);
#line 578
  mqc->c <<= 7;
#line 579
  mqc->ct -= 7U;
#line 580
  mqc->a = (OPJ_UINT32 )32768;
  }
#line 581
  return (1);
}
}
#line 584 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
OPJ_INT32 opj_mqc_decode(opj_mqc_t *mqc ) 
{ 
  OPJ_INT32 d ;

  {
#line 586
  mqc->a -= (*(mqc->curctx))->qeval;
#line 587
  if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
    {
#line 588
    d = opj_mqc_lpsexchange(mqc);
#line 589
    opj_mqc_renormd(mqc);
    }
  } else {
#line 591
    mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 592
    if ((mqc->a & 32768U) == 0U) {
      {
#line 593
      d = opj_mqc_mpsexchange(mqc);
#line 594
      opj_mqc_renormd(mqc);
      }
    } else {
#line 596
      d = (OPJ_INT32 )(*(mqc->curctx))->mps;
    }
  }
#line 600
  return (d);
}
}
#line 603 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_resetstates(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 i ;

  {
#line 605
  i = (OPJ_UINT32 )0;
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;

#line 605
    if (! (i < 19U)) {
#line 605
      goto while_break;
    }
#line 606
    mqc->ctxs[i] = mqc_states;
#line 605
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 609
  return;
}
}
#line 610 "/root/patchweave_new/10/src/lib/openjp2/mqc.c"
void opj_mqc_setstate(opj_mqc_t *mqc , OPJ_UINT32 ctxno , OPJ_UINT32 msb , OPJ_INT32 prob ) 
{ 


  {
#line 611
  mqc->ctxs[ctxno] = & mqc_states[msb + (OPJ_UINT32 )(prob << 1)];
#line 612
  return;
}
}
#line 56 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_empty)(void) ;
#line 58
extern int ( /* missing proto */  __builtin_ia32_emms)() ;
#line 56 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_empty)(void) 
{ 


  {
  {
#line 58
  __builtin_ia32_emms();
  }
#line 60
  return;
}
}
#line 62
__inline extern void ( __attribute__((__gnu_inline__)) _m_empty)(void) ;
#line 62 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _m_empty)(void) 
{ 


  {
  {
#line 64
  _mm_empty();
  }
#line 66
  return;
}
}
#line 69
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si64)(int __i ) ;
#line 71
extern int ( /* missing proto */  __builtin_ia32_vec_init_v2si)() ;
#line 69 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si64)(int __i ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 71
  __cil_tmp2 = __builtin_ia32_vec_init_v2si(__i, 0);
  }
#line 71
  return (__cil_tmp2);
}
}
#line 75
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int)(int __i ) ;
#line 75 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int)(int __i ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 77
  __cil_tmp2 = _mm_cvtsi32_si64(__i);
  }
#line 77
  return (__cil_tmp2);
}
}
#line 85
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int64)(long long __i ) ;
#line 85 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int64)(long long __i ) 
{ 


  {
#line 87
  return ((__m64 )__i);
}
}
#line 112
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si32)(__m64 __i ) ;
#line 114
extern int ( /* missing proto */  __builtin_ia32_vec_ext_v2si)() ;
#line 112 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si32)(__m64 __i ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 114
  __cil_tmp2 = __builtin_ia32_vec_ext_v2si(__i, 0);
  }
#line 114
  return (__cil_tmp2);
}
}
#line 118
__inline extern int ( __attribute__((__gnu_inline__)) _m_to_int)(__m64 __i ) ;
#line 118 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _m_to_int)(__m64 __i ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 120
  __cil_tmp2 = _mm_cvtsi64_si32(__i);
  }
#line 120
  return (__cil_tmp2);
}
}
#line 128
__inline extern long long ( __attribute__((__gnu_inline__)) _m_to_int64)(__m64 __i ) ;
#line 128 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _m_to_int64)(__m64 __i ) 
{ 


  {
#line 130
  return ((long long )__i);
}
}
#line 151
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 153
extern int ( /* missing proto */  __builtin_ia32_packsswb)() ;
#line 151 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 153
  __cil_tmp3 = __builtin_ia32_packsswb(__m1, __m2);
  }
#line 153
  return (__cil_tmp3);
}
}
#line 157
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packsswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 157 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packsswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 159
  __cil_tmp3 = _mm_packs_pi16(__m1, __m2);
  }
#line 159
  return (__cil_tmp3);
}
}
#line 166
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 168
extern int ( /* missing proto */  __builtin_ia32_packssdw)() ;
#line 166 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 168
  __cil_tmp3 = __builtin_ia32_packssdw(__m1, __m2);
  }
#line 168
  return (__cil_tmp3);
}
}
#line 172
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packssdw)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 172 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packssdw)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 174
  __cil_tmp3 = _mm_packs_pi32(__m1, __m2);
  }
#line 174
  return (__cil_tmp3);
}
}
#line 181
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pu16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 183
extern int ( /* missing proto */  __builtin_ia32_packuswb)() ;
#line 181 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pu16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 183
  __cil_tmp3 = __builtin_ia32_packuswb(__m1, __m2);
  }
#line 183
  return (__cil_tmp3);
}
}
#line 187
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packuswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 187 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packuswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 189
  __cil_tmp3 = _mm_packs_pu16(__m1, __m2);
  }
#line 189
  return (__cil_tmp3);
}
}
#line 195
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) ;
#line 197
extern int ( /* missing proto */  __builtin_ia32_punpckhbw)() ;
#line 195 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 197
  __cil_tmp3 = __builtin_ia32_punpckhbw(__m1, __m2);
  }
#line 197
  return (__cil_tmp3);
}
}
#line 201
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 201 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 203
  __cil_tmp3 = _mm_unpackhi_pi8(__m1, __m2);
  }
#line 203
  return (__cil_tmp3);
}
}
#line 209
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 211
extern int ( /* missing proto */  __builtin_ia32_punpckhwd)() ;
#line 209 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 211
  __cil_tmp3 = __builtin_ia32_punpckhwd(__m1, __m2);
  }
#line 211
  return (__cil_tmp3);
}
}
#line 215
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 215 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 217
  __cil_tmp3 = _mm_unpackhi_pi16(__m1, __m2);
  }
#line 217
  return (__cil_tmp3);
}
}
#line 223
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 225
extern int ( /* missing proto */  __builtin_ia32_punpckhdq)() ;
#line 223 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 225
  __cil_tmp3 = __builtin_ia32_punpckhdq(__m1, __m2);
  }
#line 225
  return (__cil_tmp3);
}
}
#line 229
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhdq)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 229 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhdq)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 231
  __cil_tmp3 = _mm_unpackhi_pi32(__m1, __m2);
  }
#line 231
  return (__cil_tmp3);
}
}
#line 237
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) ;
#line 239
extern int ( /* missing proto */  __builtin_ia32_punpcklbw)() ;
#line 237 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 239
  __cil_tmp3 = __builtin_ia32_punpcklbw(__m1, __m2);
  }
#line 239
  return (__cil_tmp3);
}
}
#line 243
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 243 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 245
  __cil_tmp3 = _mm_unpacklo_pi8(__m1, __m2);
  }
#line 245
  return (__cil_tmp3);
}
}
#line 251
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 253
extern int ( /* missing proto */  __builtin_ia32_punpcklwd)() ;
#line 251 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 253
  __cil_tmp3 = __builtin_ia32_punpcklwd(__m1, __m2);
  }
#line 253
  return (__cil_tmp3);
}
}
#line 257
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 257 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 259
  __cil_tmp3 = _mm_unpacklo_pi16(__m1, __m2);
  }
#line 259
  return (__cil_tmp3);
}
}
#line 265
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 267
extern int ( /* missing proto */  __builtin_ia32_punpckldq)() ;
#line 265 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 267
  __cil_tmp3 = __builtin_ia32_punpckldq(__m1, __m2);
  }
#line 267
  return (__cil_tmp3);
}
}
#line 271
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckldq)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 271 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckldq)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 273
  __cil_tmp3 = _mm_unpacklo_pi32(__m1, __m2);
  }
#line 273
  return (__cil_tmp3);
}
}
#line 278
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 280
extern int ( /* missing proto */  __builtin_ia32_paddb)() ;
#line 278 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 280
  __cil_tmp3 = __builtin_ia32_paddb(__m1, __m2);
  }
#line 280
  return (__cil_tmp3);
}
}
#line 284
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddb)(__m64 __m1 , __m64 __m2 ) ;
#line 284 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 286
  __cil_tmp3 = _mm_add_pi8(__m1, __m2);
  }
#line 286
  return (__cil_tmp3);
}
}
#line 291
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 293
extern int ( /* missing proto */  __builtin_ia32_paddw)() ;
#line 291 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 293
  __cil_tmp3 = __builtin_ia32_paddw(__m1, __m2);
  }
#line 293
  return (__cil_tmp3);
}
}
#line 297
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddw)(__m64 __m1 , __m64 __m2 ) ;
#line 297 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 299
  __cil_tmp3 = _mm_add_pi16(__m1, __m2);
  }
#line 299
  return (__cil_tmp3);
}
}
#line 304
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 306
extern int ( /* missing proto */  __builtin_ia32_paddd)() ;
#line 304 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 306
  __cil_tmp3 = __builtin_ia32_paddd(__m1, __m2);
  }
#line 306
  return (__cil_tmp3);
}
}
#line 310
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddd)(__m64 __m1 , __m64 __m2 ) ;
#line 310 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 312
  __cil_tmp3 = _mm_add_pi32(__m1, __m2);
  }
#line 312
  return (__cil_tmp3);
}
}
#line 323
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 325
extern int ( /* missing proto */  __builtin_ia32_paddq)() ;
#line 323 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 325
  __cil_tmp3 = __builtin_ia32_paddq(__m1, __m2);
  }
#line 325
  return (__cil_tmp3);
}
}
#line 335
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 337
extern int ( /* missing proto */  __builtin_ia32_paddsb)() ;
#line 335 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 337
  __cil_tmp3 = __builtin_ia32_paddsb(__m1, __m2);
  }
#line 337
  return (__cil_tmp3);
}
}
#line 341
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsb)(__m64 __m1 , __m64 __m2 ) ;
#line 341 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 343
  __cil_tmp3 = _mm_adds_pi8(__m1, __m2);
  }
#line 343
  return (__cil_tmp3);
}
}
#line 349
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 351
extern int ( /* missing proto */  __builtin_ia32_paddsw)() ;
#line 349 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 351
  __cil_tmp3 = __builtin_ia32_paddsw(__m1, __m2);
  }
#line 351
  return (__cil_tmp3);
}
}
#line 355
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsw)(__m64 __m1 , __m64 __m2 ) ;
#line 355 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 357
  __cil_tmp3 = _mm_adds_pi16(__m1, __m2);
  }
#line 357
  return (__cil_tmp3);
}
}
#line 363
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 365
extern int ( /* missing proto */  __builtin_ia32_paddusb)() ;
#line 363 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 365
  __cil_tmp3 = __builtin_ia32_paddusb(__m1, __m2);
  }
#line 365
  return (__cil_tmp3);
}
}
#line 369
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusb)(__m64 __m1 , __m64 __m2 ) ;
#line 369 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 371
  __cil_tmp3 = _mm_adds_pu8(__m1, __m2);
  }
#line 371
  return (__cil_tmp3);
}
}
#line 377
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 379
extern int ( /* missing proto */  __builtin_ia32_paddusw)() ;
#line 377 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 379
  __cil_tmp3 = __builtin_ia32_paddusw(__m1, __m2);
  }
#line 379
  return (__cil_tmp3);
}
}
#line 383
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusw)(__m64 __m1 , __m64 __m2 ) ;
#line 383 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 385
  __cil_tmp3 = _mm_adds_pu16(__m1, __m2);
  }
#line 385
  return (__cil_tmp3);
}
}
#line 390
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 392
extern int ( /* missing proto */  __builtin_ia32_psubb)() ;
#line 390 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 392
  __cil_tmp3 = __builtin_ia32_psubb(__m1, __m2);
  }
#line 392
  return (__cil_tmp3);
}
}
#line 396
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubb)(__m64 __m1 , __m64 __m2 ) ;
#line 396 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 398
  __cil_tmp3 = _mm_sub_pi8(__m1, __m2);
  }
#line 398
  return (__cil_tmp3);
}
}
#line 403
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 405
extern int ( /* missing proto */  __builtin_ia32_psubw)() ;
#line 403 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 405
  __cil_tmp3 = __builtin_ia32_psubw(__m1, __m2);
  }
#line 405
  return (__cil_tmp3);
}
}
#line 409
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubw)(__m64 __m1 , __m64 __m2 ) ;
#line 409 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 411
  __cil_tmp3 = _mm_sub_pi16(__m1, __m2);
  }
#line 411
  return (__cil_tmp3);
}
}
#line 416
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 418
extern int ( /* missing proto */  __builtin_ia32_psubd)() ;
#line 416 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 418
  __cil_tmp3 = __builtin_ia32_psubd(__m1, __m2);
  }
#line 418
  return (__cil_tmp3);
}
}
#line 422
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubd)(__m64 __m1 , __m64 __m2 ) ;
#line 422 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 424
  __cil_tmp3 = _mm_sub_pi32(__m1, __m2);
  }
#line 424
  return (__cil_tmp3);
}
}
#line 435
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 437
extern int ( /* missing proto */  __builtin_ia32_psubq)() ;
#line 435 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 437
  __cil_tmp3 = __builtin_ia32_psubq(__m1, __m2);
  }
#line 437
  return (__cil_tmp3);
}
}
#line 447
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 449
extern int ( /* missing proto */  __builtin_ia32_psubsb)() ;
#line 447 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 449
  __cil_tmp3 = __builtin_ia32_psubsb(__m1, __m2);
  }
#line 449
  return (__cil_tmp3);
}
}
#line 453
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsb)(__m64 __m1 , __m64 __m2 ) ;
#line 453 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = _mm_subs_pi8(__m1, __m2);
  }
#line 455
  return (__cil_tmp3);
}
}
#line 461
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 463
extern int ( /* missing proto */  __builtin_ia32_psubsw)() ;
#line 461 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 463
  __cil_tmp3 = __builtin_ia32_psubsw(__m1, __m2);
  }
#line 463
  return (__cil_tmp3);
}
}
#line 467
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsw)(__m64 __m1 , __m64 __m2 ) ;
#line 467 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 469
  __cil_tmp3 = _mm_subs_pi16(__m1, __m2);
  }
#line 469
  return (__cil_tmp3);
}
}
#line 475
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 477
extern int ( /* missing proto */  __builtin_ia32_psubusb)() ;
#line 475 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 477
  __cil_tmp3 = __builtin_ia32_psubusb(__m1, __m2);
  }
#line 477
  return (__cil_tmp3);
}
}
#line 481
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusb)(__m64 __m1 , __m64 __m2 ) ;
#line 481 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 483
  __cil_tmp3 = _mm_subs_pu8(__m1, __m2);
  }
#line 483
  return (__cil_tmp3);
}
}
#line 489
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 491
extern int ( /* missing proto */  __builtin_ia32_psubusw)() ;
#line 489 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 491
  __cil_tmp3 = __builtin_ia32_psubusw(__m1, __m2);
  }
#line 491
  return (__cil_tmp3);
}
}
#line 495
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusw)(__m64 __m1 , __m64 __m2 ) ;
#line 495 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 497
  __cil_tmp3 = _mm_subs_pu16(__m1, __m2);
  }
#line 497
  return (__cil_tmp3);
}
}
#line 504
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_madd_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 506
extern int ( /* missing proto */  __builtin_ia32_pmaddwd)() ;
#line 504 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_madd_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 506
  __cil_tmp3 = __builtin_ia32_pmaddwd(__m1, __m2);
  }
#line 506
  return (__cil_tmp3);
}
}
#line 510
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaddwd)(__m64 __m1 , __m64 __m2 ) ;
#line 510 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaddwd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 512
  __cil_tmp3 = _mm_madd_pi16(__m1, __m2);
  }
#line 512
  return (__cil_tmp3);
}
}
#line 518
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 520
extern int ( /* missing proto */  __builtin_ia32_pmulhw)() ;
#line 518 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 520
  __cil_tmp3 = __builtin_ia32_pmulhw(__m1, __m2);
  }
#line 520
  return (__cil_tmp3);
}
}
#line 524
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhw)(__m64 __m1 , __m64 __m2 ) ;
#line 524 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 526
  __cil_tmp3 = _mm_mulhi_pi16(__m1, __m2);
  }
#line 526
  return (__cil_tmp3);
}
}
#line 532
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mullo_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 534
extern int ( /* missing proto */  __builtin_ia32_pmullw)() ;
#line 532 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mullo_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 534
  __cil_tmp3 = __builtin_ia32_pmullw(__m1, __m2);
  }
#line 534
  return (__cil_tmp3);
}
}
#line 538
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmullw)(__m64 __m1 , __m64 __m2 ) ;
#line 538 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmullw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 540
  __cil_tmp3 = _mm_mullo_pi16(__m1, __m2);
  }
#line 540
  return (__cil_tmp3);
}
}
#line 545
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi16)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 547
extern int ( /* missing proto */  __builtin_ia32_psllw)() ;
#line 545 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi16)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 547
  __cil_tmp3 = __builtin_ia32_psllw(__m, __count);
  }
#line 547
  return (__cil_tmp3);
}
}
#line 551
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllw)(__m64 __m , __m64 __count ) ;
#line 551 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllw)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 553
  __cil_tmp3 = _mm_sll_pi16(__m, __count);
  }
#line 553
  return (__cil_tmp3);
}
}
#line 557
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi16)(__m64 __m ,
                                                                       int __count ) ;
#line 559
extern int ( /* missing proto */  __builtin_ia32_psllwi)() ;
#line 557 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi16)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 559
  __cil_tmp3 = __builtin_ia32_psllwi(__m, __count);
  }
#line 559
  return (__cil_tmp3);
}
}
#line 563
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllwi)(__m64 __m , int __count ) ;
#line 563 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllwi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 565
  __cil_tmp3 = _mm_slli_pi16(__m, __count);
  }
#line 565
  return (__cil_tmp3);
}
}
#line 570
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi32)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 572
extern int ( /* missing proto */  __builtin_ia32_pslld)() ;
#line 570 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi32)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 572
  __cil_tmp3 = __builtin_ia32_pslld(__m, __count);
  }
#line 572
  return (__cil_tmp3);
}
}
#line 576
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslld)(__m64 __m , __m64 __count ) ;
#line 576 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslld)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 578
  __cil_tmp3 = _mm_sll_pi32(__m, __count);
  }
#line 578
  return (__cil_tmp3);
}
}
#line 582
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi32)(__m64 __m ,
                                                                       int __count ) ;
#line 584
extern int ( /* missing proto */  __builtin_ia32_pslldi)() ;
#line 582 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi32)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 584
  __cil_tmp3 = __builtin_ia32_pslldi(__m, __count);
  }
#line 584
  return (__cil_tmp3);
}
}
#line 588
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslldi)(__m64 __m , int __count ) ;
#line 588 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslldi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 590
  __cil_tmp3 = _mm_slli_pi32(__m, __count);
  }
#line 590
  return (__cil_tmp3);
}
}
#line 595
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_si64)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 597
extern int ( /* missing proto */  __builtin_ia32_psllq)() ;
#line 595 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_si64)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 597
  __cil_tmp3 = __builtin_ia32_psllq(__m, __count);
  }
#line 597
  return (__cil_tmp3);
}
}
#line 601
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllq)(__m64 __m , __m64 __count ) ;
#line 601 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllq)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 603
  __cil_tmp3 = _mm_sll_si64(__m, __count);
  }
#line 603
  return (__cil_tmp3);
}
}
#line 607
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_si64)(__m64 __m ,
                                                                       int __count ) ;
#line 609
extern int ( /* missing proto */  __builtin_ia32_psllqi)() ;
#line 607 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_si64)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 609
  __cil_tmp3 = __builtin_ia32_psllqi(__m, __count);
  }
#line 609
  return (__cil_tmp3);
}
}
#line 613
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllqi)(__m64 __m , int __count ) ;
#line 613 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllqi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 615
  __cil_tmp3 = _mm_slli_si64(__m, __count);
  }
#line 615
  return (__cil_tmp3);
}
}
#line 620
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi16)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 622
extern int ( /* missing proto */  __builtin_ia32_psraw)() ;
#line 620 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi16)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 622
  __cil_tmp3 = __builtin_ia32_psraw(__m, __count);
  }
#line 622
  return (__cil_tmp3);
}
}
#line 626
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psraw)(__m64 __m , __m64 __count ) ;
#line 626 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psraw)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 628
  __cil_tmp3 = _mm_sra_pi16(__m, __count);
  }
#line 628
  return (__cil_tmp3);
}
}
#line 632
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi16)(__m64 __m ,
                                                                       int __count ) ;
#line 634
extern int ( /* missing proto */  __builtin_ia32_psrawi)() ;
#line 632 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi16)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 634
  __cil_tmp3 = __builtin_ia32_psrawi(__m, __count);
  }
#line 634
  return (__cil_tmp3);
}
}
#line 638
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrawi)(__m64 __m , int __count ) ;
#line 638 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrawi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 640
  __cil_tmp3 = _mm_srai_pi16(__m, __count);
  }
#line 640
  return (__cil_tmp3);
}
}
#line 645
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi32)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 647
extern int ( /* missing proto */  __builtin_ia32_psrad)() ;
#line 645 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi32)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 647
  __cil_tmp3 = __builtin_ia32_psrad(__m, __count);
  }
#line 647
  return (__cil_tmp3);
}
}
#line 651
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrad)(__m64 __m , __m64 __count ) ;
#line 651 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrad)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 653
  __cil_tmp3 = _mm_sra_pi32(__m, __count);
  }
#line 653
  return (__cil_tmp3);
}
}
#line 657
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi32)(__m64 __m ,
                                                                       int __count ) ;
#line 659
extern int ( /* missing proto */  __builtin_ia32_psradi)() ;
#line 657 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi32)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 659
  __cil_tmp3 = __builtin_ia32_psradi(__m, __count);
  }
#line 659
  return (__cil_tmp3);
}
}
#line 663
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psradi)(__m64 __m , int __count ) ;
#line 663 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psradi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 665
  __cil_tmp3 = _mm_srai_pi32(__m, __count);
  }
#line 665
  return (__cil_tmp3);
}
}
#line 670
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi16)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 672
extern int ( /* missing proto */  __builtin_ia32_psrlw)() ;
#line 670 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi16)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 672
  __cil_tmp3 = __builtin_ia32_psrlw(__m, __count);
  }
#line 672
  return (__cil_tmp3);
}
}
#line 676
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlw)(__m64 __m , __m64 __count ) ;
#line 676 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlw)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 678
  __cil_tmp3 = _mm_srl_pi16(__m, __count);
  }
#line 678
  return (__cil_tmp3);
}
}
#line 682
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi16)(__m64 __m ,
                                                                       int __count ) ;
#line 684
extern int ( /* missing proto */  __builtin_ia32_psrlwi)() ;
#line 682 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi16)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 684
  __cil_tmp3 = __builtin_ia32_psrlwi(__m, __count);
  }
#line 684
  return (__cil_tmp3);
}
}
#line 688
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlwi)(__m64 __m , int __count ) ;
#line 688 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlwi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 690
  __cil_tmp3 = _mm_srli_pi16(__m, __count);
  }
#line 690
  return (__cil_tmp3);
}
}
#line 695
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi32)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 697
extern int ( /* missing proto */  __builtin_ia32_psrld)() ;
#line 695 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi32)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 697
  __cil_tmp3 = __builtin_ia32_psrld(__m, __count);
  }
#line 697
  return (__cil_tmp3);
}
}
#line 701
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrld)(__m64 __m , __m64 __count ) ;
#line 701 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrld)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 703
  __cil_tmp3 = _mm_srl_pi32(__m, __count);
  }
#line 703
  return (__cil_tmp3);
}
}
#line 707
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi32)(__m64 __m ,
                                                                       int __count ) ;
#line 709
extern int ( /* missing proto */  __builtin_ia32_psrldi)() ;
#line 707 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi32)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 709
  __cil_tmp3 = __builtin_ia32_psrldi(__m, __count);
  }
#line 709
  return (__cil_tmp3);
}
}
#line 713
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrldi)(__m64 __m , int __count ) ;
#line 713 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrldi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 715
  __cil_tmp3 = _mm_srli_pi32(__m, __count);
  }
#line 715
  return (__cil_tmp3);
}
}
#line 720
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_si64)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 722
extern int ( /* missing proto */  __builtin_ia32_psrlq)() ;
#line 720 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_si64)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 722
  __cil_tmp3 = __builtin_ia32_psrlq(__m, __count);
  }
#line 722
  return (__cil_tmp3);
}
}
#line 726
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlq)(__m64 __m , __m64 __count ) ;
#line 726 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlq)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 728
  __cil_tmp3 = _mm_srl_si64(__m, __count);
  }
#line 728
  return (__cil_tmp3);
}
}
#line 732
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_si64)(__m64 __m ,
                                                                       int __count ) ;
#line 734
extern int ( /* missing proto */  __builtin_ia32_psrlqi)() ;
#line 732 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_si64)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 734
  __cil_tmp3 = __builtin_ia32_psrlqi(__m, __count);
  }
#line 734
  return (__cil_tmp3);
}
}
#line 738
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlqi)(__m64 __m , int __count ) ;
#line 738 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlqi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 740
  __cil_tmp3 = _mm_srli_si64(__m, __count);
  }
#line 740
  return (__cil_tmp3);
}
}
#line 745
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_and_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 747
extern int ( /* missing proto */  __builtin_ia32_pand)() ;
#line 745 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_and_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 747
  __cil_tmp3 = __builtin_ia32_pand(__m1, __m2);
  }
#line 747
  return (__cil_tmp3);
}
}
#line 751
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pand)(__m64 __m1 , __m64 __m2 ) ;
#line 751 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pand)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 753
  __cil_tmp3 = _mm_and_si64(__m1, __m2);
  }
#line 753
  return (__cil_tmp3);
}
}
#line 759
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_andnot_si64)(__m64 __m1 ,
                                                                         __m64 __m2 ) ;
#line 761
extern int ( /* missing proto */  __builtin_ia32_pandn)() ;
#line 759 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_andnot_si64)(__m64 __m1 ,
                                                                         __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 761
  __cil_tmp3 = __builtin_ia32_pandn(__m1, __m2);
  }
#line 761
  return (__cil_tmp3);
}
}
#line 765
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pandn)(__m64 __m1 , __m64 __m2 ) ;
#line 765 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pandn)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 767
  __cil_tmp3 = _mm_andnot_si64(__m1, __m2);
  }
#line 767
  return (__cil_tmp3);
}
}
#line 772
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_or_si64)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 774
extern int ( /* missing proto */  __builtin_ia32_por)() ;
#line 772 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_or_si64)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 774
  __cil_tmp3 = __builtin_ia32_por(__m1, __m2);
  }
#line 774
  return (__cil_tmp3);
}
}
#line 778
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_por)(__m64 __m1 , __m64 __m2 ) ;
#line 778 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_por)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 780
  __cil_tmp3 = _mm_or_si64(__m1, __m2);
  }
#line 780
  return (__cil_tmp3);
}
}
#line 785
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_xor_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 787
extern int ( /* missing proto */  __builtin_ia32_pxor)() ;
#line 785 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_xor_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 787
  __cil_tmp3 = __builtin_ia32_pxor(__m1, __m2);
  }
#line 787
  return (__cil_tmp3);
}
}
#line 791
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pxor)(__m64 __m1 , __m64 __m2 ) ;
#line 791 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pxor)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 793
  __cil_tmp3 = _mm_xor_si64(__m1, __m2);
  }
#line 793
  return (__cil_tmp3);
}
}
#line 799
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 801
extern int ( /* missing proto */  __builtin_ia32_pcmpeqb)() ;
#line 799 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 801
  __cil_tmp3 = __builtin_ia32_pcmpeqb(__m1, __m2);
  }
#line 801
  return (__cil_tmp3);
}
}
#line 805
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqb)(__m64 __m1 , __m64 __m2 ) ;
#line 805 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 807
  __cil_tmp3 = _mm_cmpeq_pi8(__m1, __m2);
  }
#line 807
  return (__cil_tmp3);
}
}
#line 811
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 813
extern int ( /* missing proto */  __builtin_ia32_pcmpgtb)() ;
#line 811 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 813
  __cil_tmp3 = __builtin_ia32_pcmpgtb(__m1, __m2);
  }
#line 813
  return (__cil_tmp3);
}
}
#line 817
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtb)(__m64 __m1 , __m64 __m2 ) ;
#line 817 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 819
  __cil_tmp3 = _mm_cmpgt_pi8(__m1, __m2);
  }
#line 819
  return (__cil_tmp3);
}
}
#line 825
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 827
extern int ( /* missing proto */  __builtin_ia32_pcmpeqw)() ;
#line 825 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 827
  __cil_tmp3 = __builtin_ia32_pcmpeqw(__m1, __m2);
  }
#line 827
  return (__cil_tmp3);
}
}
#line 831
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqw)(__m64 __m1 , __m64 __m2 ) ;
#line 831 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 833
  __cil_tmp3 = _mm_cmpeq_pi16(__m1, __m2);
  }
#line 833
  return (__cil_tmp3);
}
}
#line 837
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 839
extern int ( /* missing proto */  __builtin_ia32_pcmpgtw)() ;
#line 837 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 839
  __cil_tmp3 = __builtin_ia32_pcmpgtw(__m1, __m2);
  }
#line 839
  return (__cil_tmp3);
}
}
#line 843
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtw)(__m64 __m1 , __m64 __m2 ) ;
#line 843 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 845
  __cil_tmp3 = _mm_cmpgt_pi16(__m1, __m2);
  }
#line 845
  return (__cil_tmp3);
}
}
#line 851
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 853
extern int ( /* missing proto */  __builtin_ia32_pcmpeqd)() ;
#line 851 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 853
  __cil_tmp3 = __builtin_ia32_pcmpeqd(__m1, __m2);
  }
#line 853
  return (__cil_tmp3);
}
}
#line 857
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqd)(__m64 __m1 , __m64 __m2 ) ;
#line 857 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 859
  __cil_tmp3 = _mm_cmpeq_pi32(__m1, __m2);
  }
#line 859
  return (__cil_tmp3);
}
}
#line 863
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 865
extern int ( /* missing proto */  __builtin_ia32_pcmpgtd)() ;
#line 863 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 865
  __cil_tmp3 = __builtin_ia32_pcmpgtd(__m1, __m2);
  }
#line 865
  return (__cil_tmp3);
}
}
#line 869
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtd)(__m64 __m1 , __m64 __m2 ) ;
#line 869 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 871
  __cil_tmp3 = _mm_cmpgt_pi32(__m1, __m2);
  }
#line 871
  return (__cil_tmp3);
}
}
#line 876
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setzero_si64)(void) ;
#line 876 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setzero_si64)(void) 
{ 


  {
#line 878
  return ((__m64 )0LL);
}
}
#line 883
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi32)(int __i1 , int __i0 ) ;
#line 883 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi32)(int __i1 , int __i0 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 885
  __cil_tmp3 = __builtin_ia32_vec_init_v2si(__i0, __i1);
  }
#line 885
  return (__cil_tmp3);
}
}
#line 890
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi16)(short __w3 ,
                                                                      short __w2 ,
                                                                      short __w1 ,
                                                                      short __w0 ) ;
#line 892
extern int ( /* missing proto */  __builtin_ia32_vec_init_v4hi)() ;
#line 890 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi16)(short __w3 ,
                                                                      short __w2 ,
                                                                      short __w1 ,
                                                                      short __w0 ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 892
  __cil_tmp5 = __builtin_ia32_vec_init_v4hi((int )__w0, (int )__w1, (int )__w2, (int )__w3);
  }
#line 892
  return (__cil_tmp5);
}
}
#line 897
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi8)(char __b7 , char __b6 ,
                                                                     char __b5 , char __b4 ,
                                                                     char __b3 , char __b2 ,
                                                                     char __b1 , char __b0 ) ;
#line 900
extern int ( /* missing proto */  __builtin_ia32_vec_init_v8qi)() ;
#line 897 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi8)(char __b7 , char __b6 ,
                                                                     char __b5 , char __b4 ,
                                                                     char __b3 , char __b2 ,
                                                                     char __b1 , char __b0 ) 
{ 
  int __cil_tmp9 ;

  {
  {
#line 900
  __cil_tmp9 = __builtin_ia32_vec_init_v8qi((int )__b0, (int )__b1, (int )__b2, (int )__b3,
                                            (int )__b4, (int )__b5, (int )__b6, (int )__b7);
  }
#line 900
  return (__cil_tmp9);
}
}
#line 906
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi32)(int __i0 ,
                                                                       int __i1 ) ;
#line 906 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi32)(int __i0 ,
                                                                       int __i1 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 908
  __cil_tmp3 = _mm_set_pi32(__i1, __i0);
  }
#line 908
  return (__cil_tmp3);
}
}
#line 912
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi16)(short __w0 ,
                                                                       short __w1 ,
                                                                       short __w2 ,
                                                                       short __w3 ) ;
#line 912 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi16)(short __w0 ,
                                                                       short __w1 ,
                                                                       short __w2 ,
                                                                       short __w3 ) 
{ 
  __m64 __cil_tmp5 ;

  {
  {
#line 914
  __cil_tmp5 = _mm_set_pi16(__w3, __w2, __w1, __w0);
  }
#line 914
  return (__cil_tmp5);
}
}
#line 918
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi8)(char __b0 ,
                                                                      char __b1 ,
                                                                      char __b2 ,
                                                                      char __b3 ,
                                                                      char __b4 ,
                                                                      char __b5 ,
                                                                      char __b6 ,
                                                                      char __b7 ) ;
#line 918 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi8)(char __b0 ,
                                                                      char __b1 ,
                                                                      char __b2 ,
                                                                      char __b3 ,
                                                                      char __b4 ,
                                                                      char __b5 ,
                                                                      char __b6 ,
                                                                      char __b7 ) 
{ 
  __m64 __cil_tmp9 ;

  {
  {
#line 921
  __cil_tmp9 = _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
  }
#line 921
  return (__cil_tmp9);
}
}
#line 926
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi32)(int __i ) ;
#line 926 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi32)(int __i ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 928
  __cil_tmp2 = _mm_set_pi32(__i, __i);
  }
#line 928
  return (__cil_tmp2);
}
}
#line 933
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi16)(short __w ) ;
#line 933 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi16)(short __w ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 935
  __cil_tmp2 = _mm_set_pi16(__w, __w, __w, __w);
  }
#line 935
  return (__cil_tmp2);
}
}
#line 940
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi8)(char __b ) ;
#line 940 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi8)(char __b ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 942
  __cil_tmp2 = _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
  }
#line 942
  return (__cil_tmp2);
}
}
#line 110 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_undefined_ps)(void) ;
#line 110 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_undefined_ps)(void) 
{ 
  __m128 __Y ;

  {
#line 112
  __Y = __Y;
#line 113
  return (__Y);
}
}
#line 118
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_setzero_ps)(void) ;
#line 118 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_setzero_ps)(void) 
{ 
  __m128 tmp ;

  {
#line 120
  return (tmp);
}
}
#line 128
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 128 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 133
  return;
}
}
#line 152
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ss)(__m128 __A ) ;
#line 154
extern int ( /* missing proto */  __builtin_ia32_sqrtss)() ;
#line 152 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ss)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 154
  __cil_tmp2 = __builtin_ia32_sqrtss(__A);
  }
#line 154
  return (__cil_tmp2);
}
}
#line 158
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ss)(__m128 __A ) ;
#line 160
extern int ( /* missing proto */  __builtin_ia32_rcpss)() ;
#line 158 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ss)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 160
  __cil_tmp2 = __builtin_ia32_rcpss(__A);
  }
#line 160
  return (__cil_tmp2);
}
}
#line 164
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ss)(__m128 __A ) ;
#line 166
extern int ( /* missing proto */  __builtin_ia32_rsqrtss)() ;
#line 164 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ss)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 166
  __cil_tmp2 = __builtin_ia32_rsqrtss(__A);
  }
#line 166
  return (__cil_tmp2);
}
}
#line 170
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 172
extern int ( /* missing proto */  __builtin_ia32_minss)() ;
#line 170 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 172
  __cil_tmp3 = __builtin_ia32_minss(__A, __B);
  }
#line 172
  return (__cil_tmp3);
}
}
#line 176
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 178
extern int ( /* missing proto */  __builtin_ia32_maxss)() ;
#line 176 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 178
  __cil_tmp3 = __builtin_ia32_maxss(__A, __B);
  }
#line 178
  return (__cil_tmp3);
}
}
#line 184
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 184 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 186
  return (__A + __B);
}
}
#line 190
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sub_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 190 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sub_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 192
  return (__A - __B);
}
}
#line 196
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_mul_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 196 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_mul_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 198
  return (__A * __B);
}
}
#line 202
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_div_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 202 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_div_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 204
  return (__A / __B);
}
}
#line 208
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ps)(__m128 __A ) ;
#line 210
extern int ( /* missing proto */  __builtin_ia32_sqrtps)() ;
#line 208 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 210
  __cil_tmp2 = __builtin_ia32_sqrtps(__A);
  }
#line 210
  return (__cil_tmp2);
}
}
#line 214
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ps)(__m128 __A ) ;
#line 216
extern int ( /* missing proto */  __builtin_ia32_rcpps)() ;
#line 214 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 216
  __cil_tmp2 = __builtin_ia32_rcpps(__A);
  }
#line 216
  return (__cil_tmp2);
}
}
#line 220
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ps)(__m128 __A ) ;
#line 222
extern int ( /* missing proto */  __builtin_ia32_rsqrtps)() ;
#line 220 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 222
  __cil_tmp2 = __builtin_ia32_rsqrtps(__A);
  }
#line 222
  return (__cil_tmp2);
}
}
#line 226
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 228
extern int ( /* missing proto */  __builtin_ia32_minps)() ;
#line 226 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 228
  __cil_tmp3 = __builtin_ia32_minps(__A, __B);
  }
#line 228
  return (__cil_tmp3);
}
}
#line 232
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 232 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  float __attribute__((__vector_size__(16)))  __cil_tmp3 ;
  float __attribute__((____vector_size____(16)))  tmp ;

  {
  {
#line 234
  tmp = __builtin_ia32_maxps((float __attribute__((____vector_size____(16)))  )__A,
                             (float __attribute__((____vector_size____(16)))  )__B);
#line 234
  __cil_tmp3 = (float __attribute__((__vector_size__(16)))  )tmp;
  }
#line 234
  return ((__m128 )__cil_tmp3);
}
}
#line 268
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 270
extern int ( /* missing proto */  __builtin_ia32_cmpeqss)() ;
#line 268 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 270
  __cil_tmp3 = __builtin_ia32_cmpeqss(__A, __B);
  }
#line 270
  return (__cil_tmp3);
}
}
#line 274
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 276
extern int ( /* missing proto */  __builtin_ia32_cmpltss)() ;
#line 274 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 276
  __cil_tmp3 = __builtin_ia32_cmpltss(__A, __B);
  }
#line 276
  return (__cil_tmp3);
}
}
#line 280
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 282
extern int ( /* missing proto */  __builtin_ia32_cmpless)() ;
#line 280 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 282
  __cil_tmp3 = __builtin_ia32_cmpless(__A, __B);
  }
#line 282
  return (__cil_tmp3);
}
}
#line 306
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 308
extern int ( /* missing proto */  __builtin_ia32_cmpneqss)() ;
#line 306 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 308
  __cil_tmp3 = __builtin_ia32_cmpneqss(__A, __B);
  }
#line 308
  return (__cil_tmp3);
}
}
#line 312
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 314
extern int ( /* missing proto */  __builtin_ia32_cmpnltss)() ;
#line 312 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 314
  __cil_tmp3 = __builtin_ia32_cmpnltss(__A, __B);
  }
#line 314
  return (__cil_tmp3);
}
}
#line 318
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 320
extern int ( /* missing proto */  __builtin_ia32_cmpnless)() ;
#line 318 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 320
  __cil_tmp3 = __builtin_ia32_cmpnless(__A, __B);
  }
#line 320
  return (__cil_tmp3);
}
}
#line 344
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 346
extern int ( /* missing proto */  __builtin_ia32_cmpordss)() ;
#line 344 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 346
  __cil_tmp3 = __builtin_ia32_cmpordss(__A, __B);
  }
#line 346
  return (__cil_tmp3);
}
}
#line 350
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ss)(__m128 __A ,
                                                                          __m128 __B ) ;
#line 352
extern int ( /* missing proto */  __builtin_ia32_cmpunordss)() ;
#line 350 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ss)(__m128 __A ,
                                                                          __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 352
  __cil_tmp3 = __builtin_ia32_cmpunordss(__A, __B);
  }
#line 352
  return (__cil_tmp3);
}
}
#line 360
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ps)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 362
extern int ( /* missing proto */  __builtin_ia32_cmpeqps)() ;
#line 360 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ps)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 362
  __cil_tmp3 = __builtin_ia32_cmpeqps(__A, __B);
  }
#line 362
  return (__cil_tmp3);
}
}
#line 366
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ps)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 368
extern int ( /* missing proto */  __builtin_ia32_cmpltps)() ;
#line 366 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ps)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 368
  __cil_tmp3 = __builtin_ia32_cmpltps(__A, __B);
  }
#line 368
  return (__cil_tmp3);
}
}
#line 372
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ps)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 374
extern int ( /* missing proto */  __builtin_ia32_cmpleps)() ;
#line 372 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ps)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 374
  __cil_tmp3 = __builtin_ia32_cmpleps(__A, __B);
  }
#line 374
  return (__cil_tmp3);
}
}
#line 390
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 392
extern int ( /* missing proto */  __builtin_ia32_cmpneqps)() ;
#line 390 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 392
  __cil_tmp3 = __builtin_ia32_cmpneqps(__A, __B);
  }
#line 392
  return (__cil_tmp3);
}
}
#line 396
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 398
extern int ( /* missing proto */  __builtin_ia32_cmpnltps)() ;
#line 396 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 398
  __cil_tmp3 = __builtin_ia32_cmpnltps(__A, __B);
  }
#line 398
  return (__cil_tmp3);
}
}
#line 402
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 404
extern int ( /* missing proto */  __builtin_ia32_cmpnleps)() ;
#line 402 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 404
  __cil_tmp3 = __builtin_ia32_cmpnleps(__A, __B);
  }
#line 404
  return (__cil_tmp3);
}
}
#line 420
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 422
extern int ( /* missing proto */  __builtin_ia32_cmpordps)() ;
#line 420 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 422
  __cil_tmp3 = __builtin_ia32_cmpordps(__A, __B);
  }
#line 422
  return (__cil_tmp3);
}
}
#line 426
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ps)(__m128 __A ,
                                                                          __m128 __B ) ;
#line 428
extern int ( /* missing proto */  __builtin_ia32_cmpunordps)() ;
#line 426 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ps)(__m128 __A ,
                                                                          __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 428
  __cil_tmp3 = __builtin_ia32_cmpunordps(__A, __B);
  }
#line 428
  return (__cil_tmp3);
}
}
#line 435
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 437
extern int ( /* missing proto */  __builtin_ia32_comieq)() ;
#line 435 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 437
  __cil_tmp3 = __builtin_ia32_comieq(__A, __B);
  }
#line 437
  return (__cil_tmp3);
}
}
#line 441
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 443
extern int ( /* missing proto */  __builtin_ia32_comilt)() ;
#line 441 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 443
  __cil_tmp3 = __builtin_ia32_comilt(__A, __B);
  }
#line 443
  return (__cil_tmp3);
}
}
#line 447
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 449
extern int ( /* missing proto */  __builtin_ia32_comile)() ;
#line 447 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 449
  __cil_tmp3 = __builtin_ia32_comile(__A, __B);
  }
#line 449
  return (__cil_tmp3);
}
}
#line 453
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 455
extern int ( /* missing proto */  __builtin_ia32_comigt)() ;
#line 453 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = __builtin_ia32_comigt(__A, __B);
  }
#line 455
  return (__cil_tmp3);
}
}
#line 459
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 461
extern int ( /* missing proto */  __builtin_ia32_comige)() ;
#line 459 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 461
  __cil_tmp3 = __builtin_ia32_comige(__A, __B);
  }
#line 461
  return (__cil_tmp3);
}
}
#line 465
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 467
extern int ( /* missing proto */  __builtin_ia32_comineq)() ;
#line 465 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 467
  __cil_tmp3 = __builtin_ia32_comineq(__A, __B);
  }
#line 467
  return (__cil_tmp3);
}
}
#line 471
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 473
extern int ( /* missing proto */  __builtin_ia32_ucomieq)() ;
#line 471 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 473
  __cil_tmp3 = __builtin_ia32_ucomieq(__A, __B);
  }
#line 473
  return (__cil_tmp3);
}
}
#line 477
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 479
extern int ( /* missing proto */  __builtin_ia32_ucomilt)() ;
#line 477 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 479
  __cil_tmp3 = __builtin_ia32_ucomilt(__A, __B);
  }
#line 479
  return (__cil_tmp3);
}
}
#line 483
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 485
extern int ( /* missing proto */  __builtin_ia32_ucomile)() ;
#line 483 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 485
  __cil_tmp3 = __builtin_ia32_ucomile(__A, __B);
  }
#line 485
  return (__cil_tmp3);
}
}
#line 489
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 491
extern int ( /* missing proto */  __builtin_ia32_ucomigt)() ;
#line 489 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 491
  __cil_tmp3 = __builtin_ia32_ucomigt(__A, __B);
  }
#line 491
  return (__cil_tmp3);
}
}
#line 495
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 497
extern int ( /* missing proto */  __builtin_ia32_ucomige)() ;
#line 495 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 497
  __cil_tmp3 = __builtin_ia32_ucomige(__A, __B);
  }
#line 497
  return (__cil_tmp3);
}
}
#line 501
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 503
extern int ( /* missing proto */  __builtin_ia32_ucomineq)() ;
#line 501 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 503
  __cil_tmp3 = __builtin_ia32_ucomineq(__A, __B);
  }
#line 503
  return (__cil_tmp3);
}
}
#line 509
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtss_si32)(__m128 __A ) ;
#line 511
extern int ( /* missing proto */  __builtin_ia32_cvtss2si)() ;
#line 509 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtss_si32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 511
  __cil_tmp2 = __builtin_ia32_cvtss2si(__A);
  }
#line 511
  return (__cil_tmp2);
}
}
#line 515
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvt_ss2si)(__m128 __A ) ;
#line 515 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvt_ss2si)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 517
  __cil_tmp2 = _mm_cvtss_si32(__A);
  }
#line 517
  return (__cil_tmp2);
}
}
#line 526
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtss_si64)(__m128 __A ) ;
#line 528
extern int ( /* missing proto */  __builtin_ia32_cvtss2si64)() ;
#line 526 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtss_si64)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 528
  __cil_tmp2 = __builtin_ia32_cvtss2si64(__A);
  }
#line 528
  return ((long long )__cil_tmp2);
}
}
#line 542
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi32)(__m128 __A ) ;
#line 544
extern int ( /* missing proto */  __builtin_ia32_cvtps2pi)() ;
#line 542 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 544
  __cil_tmp2 = __builtin_ia32_cvtps2pi(__A);
  }
#line 544
  return (__cil_tmp2);
}
}
#line 548
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvt_ps2pi)(__m128 __A ) ;
#line 548 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvt_ps2pi)(__m128 __A ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 550
  __cil_tmp2 = _mm_cvtps_pi32(__A);
  }
#line 550
  return (__cil_tmp2);
}
}
#line 555
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttss_si32)(__m128 __A ) ;
#line 557
extern int ( /* missing proto */  __builtin_ia32_cvttss2si)() ;
#line 555 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttss_si32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 557
  __cil_tmp2 = __builtin_ia32_cvttss2si(__A);
  }
#line 557
  return (__cil_tmp2);
}
}
#line 561
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtt_ss2si)(__m128 __A ) ;
#line 561 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtt_ss2si)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 563
  __cil_tmp2 = _mm_cvttss_si32(__A);
  }
#line 563
  return (__cil_tmp2);
}
}
#line 571
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttss_si64)(__m128 __A ) ;
#line 573
extern int ( /* missing proto */  __builtin_ia32_cvttss2si64)() ;
#line 571 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttss_si64)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 573
  __cil_tmp2 = __builtin_ia32_cvttss2si64(__A);
  }
#line 573
  return ((long long )__cil_tmp2);
}
}
#line 587
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttps_pi32)(__m128 __A ) ;
#line 589
extern int ( /* missing proto */  __builtin_ia32_cvttps2pi)() ;
#line 587 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttps_pi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 589
  __cil_tmp2 = __builtin_ia32_cvttps2pi(__A);
  }
#line 589
  return (__cil_tmp2);
}
}
#line 593
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtt_ps2pi)(__m128 __A ) ;
#line 593 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtt_ps2pi)(__m128 __A ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 595
  __cil_tmp2 = _mm_cvttps_pi32(__A);
  }
#line 595
  return (__cil_tmp2);
}
}
#line 600
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_ss)(__m128 __A ,
                                                                         int __B ) ;
#line 600 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_ss)(__m128 __A ,
                                                                         int __B ) 
{ 


  {
#line 605
  return;
}
}
#line 606
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_si2ss)(__m128 __A ,
                                                                        int __B ) ;
#line 606 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_si2ss)(__m128 __A ,
                                                                        int __B ) 
{ 
  __m128 __cil_tmp3 ;

  {
  {
#line 608
  __cil_tmp3 = _mm_cvtsi32_ss(__A, __B);
  }
#line 608
  return (__cil_tmp3);
}
}
#line 616
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi64_ss)(__m128 __A ,
                                                                         long long __B ) ;
#line 616 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi64_ss)(__m128 __A ,
                                                                         long long __B ) 
{ 


  {
#line 621
  return;
}
}
#line 632
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32_ps)(__m128 __A ,
                                                                         __m64 __B ) ;
#line 634
extern int ( /* missing proto */  __builtin_ia32_cvtpi2ps)() ;
#line 632 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32_ps)(__m128 __A ,
                                                                         __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 634
  __cil_tmp3 = __builtin_ia32_cvtpi2ps(__A, __B);
  }
#line 634
  return (__cil_tmp3);
}
}
#line 638
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_pi2ps)(__m128 __A ,
                                                                        __m64 __B ) ;
#line 638 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_pi2ps)(__m128 __A ,
                                                                        __m64 __B ) 
{ 
  __m128 __cil_tmp3 ;

  {
  {
#line 640
  __cil_tmp3 = _mm_cvtpi32_ps(__A, __B);
  }
#line 640
  return (__cil_tmp3);
}
}
#line 645
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi16_ps)(__m64 __A ) ;
#line 645 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi16_ps)(__m64 __A ) 
{ 
  __v4hi __sign ;
  __v2si __hisi ;
  __v2si __losi ;
  __v4sf __zero ;
  __v4sf __ra ;
  __v4sf __rb ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  __m128 __cil_tmp11 ;

  {
  {
#line 654
  __sign = __builtin_ia32_pcmpgtw((__v4hi )0LL, __A);
#line 657
  __cil_tmp9 = __builtin_ia32_punpcklwd(__A, __sign);
#line 657
  __losi = __cil_tmp9;
#line 658
  __cil_tmp10 = __builtin_ia32_punpckhwd(__A, __sign);
#line 658
  __hisi = __cil_tmp10;
#line 661
  __cil_tmp11 = _mm_setzero_ps();
#line 661
  __zero = __cil_tmp11;
#line 662
  __ra = __builtin_ia32_cvtpi2ps(__zero, __losi);
#line 663
  __rb = __builtin_ia32_cvtpi2ps(__ra, __hisi);
  }
#line 665
  return;
}
}
#line 670
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu16_ps)(__m64 __A ) ;
#line 670 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu16_ps)(__m64 __A ) 
{ 
  __v2si __hisi ;
  __v2si __losi ;
  __v4sf __zero ;
  __v4sf __ra ;
  __v4sf __rb ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  __m128 __cil_tmp9 ;

  {
  {
#line 676
  __cil_tmp7 = __builtin_ia32_punpcklwd(__A, (__v4hi )0LL);
#line 676
  __losi = __cil_tmp7;
#line 677
  __cil_tmp8 = __builtin_ia32_punpckhwd(__A, (__v4hi )0LL);
#line 677
  __hisi = __cil_tmp8;
#line 680
  __cil_tmp9 = _mm_setzero_ps();
#line 680
  __zero = __cil_tmp9;
#line 681
  __ra = __builtin_ia32_cvtpi2ps(__zero, __losi);
#line 682
  __rb = __builtin_ia32_cvtpi2ps(__ra, __hisi);
  }
#line 684
  return;
}
}
#line 689
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi8_ps)(__m64 __A ) ;
#line 689 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi8_ps)(__m64 __A ) 
{ 
  __v8qi __sign ;
  int __cil_tmp4 ;
  __m128 __cil_tmp5 ;

  {
  {
#line 696
  __sign = __builtin_ia32_pcmpgtb((__v8qi )0LL, __A);
#line 699
  __cil_tmp4 = __builtin_ia32_punpcklbw(__A, __sign);
#line 699
  __A = __cil_tmp4;
#line 701
  __cil_tmp5 = _mm_cvtpi16_ps(__A);
  }
#line 701
  return (__cil_tmp5);
}
}
#line 706
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu8_ps)(__m64 __A ) ;
#line 706 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu8_ps)(__m64 __A ) 
{ 
  int __cil_tmp2 ;
  __m128 __cil_tmp3 ;

  {
  {
#line 708
  __cil_tmp2 = __builtin_ia32_punpcklbw(__A, (__v8qi )0LL);
#line 708
  __A = __cil_tmp2;
#line 709
  __cil_tmp3 = _mm_cvtpu16_ps(__A);
  }
#line 709
  return (__cil_tmp3);
}
}
#line 714
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32x2_ps)(__m64 __A ,
                                                                           __m64 __B ) ;
#line 714 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32x2_ps)(__m64 __A ,
                                                                           __m64 __B ) 
{ 
  __v4sf __zero ;
  __m128 __cil_tmp4 ;
  __v4sf __sfa ;
  int __cil_tmp6 ;
  __v4sf __sfb ;
  int __cil_tmp8 ;

  {
  {
#line 716
  __cil_tmp4 = _mm_setzero_ps();
#line 716
  __zero = __cil_tmp4;
#line 717
  __cil_tmp6 = __builtin_ia32_cvtpi2ps(__zero, __A);
#line 717
  __sfa = __cil_tmp6;
#line 718
  __cil_tmp8 = __builtin_ia32_cvtpi2ps(__sfa, __B);
#line 718
  __sfb = __cil_tmp8;
  }
#line 720
  return;
}
}
#line 724
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi16)(__m128 __A ) ;
#line 724 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi16)(__m128 __A ) 
{ 
  __v4sf __hisf ;
  __v4sf __losf ;
  __v2si __hisi ;
  int __cil_tmp5 ;
  __v2si __losi ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 726
  __hisf = __A;
#line 727
  __losf = 0;
#line 728
  __cil_tmp5 = __builtin_ia32_cvtps2pi(__hisf);
#line 728
  __hisi = __cil_tmp5;
#line 729
  __cil_tmp7 = __builtin_ia32_cvtps2pi(__losf);
#line 729
  __losi = __cil_tmp7;
#line 730
  __cil_tmp8 = __builtin_ia32_packssdw(__hisi, __losi);
  }
#line 730
  return (__cil_tmp8);
}
}
#line 735
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi8)(__m128 __A ) ;
#line 735 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi8)(__m128 __A ) 
{ 
  __v4hi __tmp ;
  __m64 __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 737
  __cil_tmp3 = _mm_cvtps_pi16(__A);
#line 737
  __tmp = __cil_tmp3;
#line 738
  __cil_tmp4 = __builtin_ia32_packsswb(__tmp, (__v4hi )0LL);
  }
#line 738
  return (__cil_tmp4);
}
}
#line 771
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadh_pi)(__m128 __A ,
                                                                       __m64 *__P ) ;
#line 771 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadh_pi)(__m128 __A ,
                                                                       __m64 *__P ) 
{ 


  {
#line 776
  return;
}
}
#line 778
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeh_pi)(__m64 *__P ,
                                                                      __m128 __A ) ;
#line 780
extern int ( /* missing proto */  __builtin_ia32_storehps)() ;
#line 778 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeh_pi)(__m64 *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 780
  __builtin_ia32_storehps(__P, __A);
  }
#line 782
  return;
}
}
#line 807
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pi)(__m64 *__P ,
                                                                      __m128 __A ) ;
#line 809
extern int ( /* missing proto */  __builtin_ia32_storelps)() ;
#line 807 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pi)(__m64 *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 809
  __builtin_ia32_storelps(__P, __A);
  }
#line 811
  return;
}
}
#line 814
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_ps)(__m128 __A ) ;
#line 816
extern int ( /* missing proto */  __builtin_ia32_movmskps)() ;
#line 814 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 816
  __cil_tmp2 = __builtin_ia32_movmskps(__A);
  }
#line 816
  return (__cil_tmp2);
}
}
#line 821
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) _mm_getcsr)(void) ;
#line 823
extern int ( /* missing proto */  __builtin_ia32_stmxcsr)() ;
#line 821
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) _mm_getcsr)(void) ;
#line 821 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) _mm_getcsr)(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 823
  __cil_tmp1 = __builtin_ia32_stmxcsr();
  }
#line 823
  return ((unsigned int )__cil_tmp1);
}
}
#line 828
__inline extern unsigned int ( __attribute__((__gnu_inline__)) _MM_GET_EXCEPTION_STATE)(void) ;
#line 828 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) _MM_GET_EXCEPTION_STATE)(void) 
{ 


  {
#line 833
  return (0U);
}
}
#line 853
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_setcsr)(unsigned int __I ) ;
#line 855
extern int ( /* missing proto */  __builtin_ia32_ldmxcsr)() ;
#line 853
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_setcsr)(unsigned int __I ) ;
#line 853 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_setcsr)(unsigned int __I ) 
{ 


  {
  {
#line 855
  __builtin_ia32_ldmxcsr(__I);
  }
#line 857
  return;
}
}
#line 860
__inline extern void ( __attribute__((__gnu_inline__)) _MM_SET_EXCEPTION_STATE)(unsigned int __mask ) ;
#line 860 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _MM_SET_EXCEPTION_STATE)(unsigned int __mask ) 
{ 


  {
#line 865
  return;
}
}
#line 885
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ss)(float __F ) ;
#line 885 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ss)(float __F ) 
{ 
  __v4sf tmp ;

  {
#line 887
  return (tmp);
}
}
#line 898
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps1)(float __F ) ;
#line 898 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps1)(float __F ) 
{ 
  __m128 __cil_tmp2 ;

  {
  {
#line 900
  __cil_tmp2 = _mm_set_ss(__F);
  }
#line 900
  return (__cil_tmp2);
}
}
#line 905
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ss)(float const   *__P ) ;
#line 905 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ss)(float const   *__P ) 
{ 
  __m128 __cil_tmp2 ;

  {
  {
#line 907
  __cil_tmp2 = _mm_set_ss((float )*__P);
  }
#line 907
  return (__cil_tmp2);
}
}
#line 918
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps1)(float const   *__P ) ;
#line 918 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps1)(float const   *__P ) 
{ 
  __m128 __cil_tmp2 ;

  {
  {
#line 920
  __cil_tmp2 = _mm_load_ss(__P);
  }
#line 920
  return (__cil_tmp2);
}
}
#line 925
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps)(float const   *__P ) ;
#line 925 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps)(float const   *__P ) 
{ 


  {
#line 927
  return (*((__m128 *)__P));
}
}
#line 932
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadu_ps)(float const   *__P ) ;
#line 932 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadu_ps)(float const   *__P ) 
{ 


  {
#line 934
  return (*((__m128_u *)__P));
}
}
#line 939
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadr_ps)(float const   *__P ) ;
#line 942
extern int ( /* missing proto */  __builtin_ia32_shufps)() ;
#line 939 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadr_ps)(float const   *__P ) 
{ 
  __v4sf __tmp ;
  int __cil_tmp3 ;

  {
  {
#line 941
  __tmp = *((__v4sf *)__P);
#line 942
  __cil_tmp3 = __builtin_ia32_shufps(__tmp, __tmp, ((1 << 4) | (2 << 2)) | 3);
  }
#line 942
  return (__cil_tmp3);
}
}
#line 947
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps)(float __Z , float __Y ,
                                                                     float __X , float __W ) ;
#line 947 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps)(float __Z , float __Y ,
                                                                     float __X , float __W ) 
{ 
  __v4sf tmp ;

  {
#line 949
  return (tmp);
}
}
#line 961
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ss)(float *__P ,
                                                                     __m128 __A ) ;
#line 961 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ss)(float *__P ,
                                                                     __m128 __A ) 
{ 
  int __cil_tmp3 ;

  {
#line 963
  *__P = (float )__cil_tmp3;
#line 964
  return;
}
}
#line 967
__inline extern float ( __attribute__((__gnu_inline__)) _mm_cvtss_f32)(__m128 __A ) ;
#line 967 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern float ( __attribute__((__gnu_inline__)) _mm_cvtss_f32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
#line 969
  return ((float )__cil_tmp2);
}
}
#line 974
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps)(float *__P ,
                                                                     __m128 __A ) ;
#line 974 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps)(float *__P ,
                                                                     __m128 __A ) 
{ 


  {
#line 976
  *((__m128 *)__P) = __A;
#line 977
  return;
}
}
#line 981
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 981 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 


  {
#line 983
  *((__m128_u *)__P) = __A;
#line 984
  return;
}
}
#line 988
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 988 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 
  __v4sf __va ;
  __v4sf __tmp ;
  int __cil_tmp5 ;

  {
  {
#line 990
  __va = __A;
#line 991
  __cil_tmp5 = __builtin_ia32_shufps(__va, __va, 0);
#line 991
  __tmp = __cil_tmp5;
#line 992
  _mm_storeu_ps(__P, __tmp);
  }
#line 994
  return;
}
}
#line 996
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps1)(float *__P ,
                                                                      __m128 __A ) ;
#line 996 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps1)(float *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 998
  _mm_store1_ps(__P, __A);
  }
#line 1000
  return;
}
}
#line 1003
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 1003 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 
  __v4sf __va ;
  __v4sf __tmp ;
  int __cil_tmp5 ;

  {
  {
#line 1005
  __va = __A;
#line 1006
  __cil_tmp5 = __builtin_ia32_shufps(__va, __va, ((1 << 4) | (2 << 2)) | 3);
#line 1006
  __tmp = __cil_tmp5;
#line 1007
  _mm_store_ps(__P, __tmp);
  }
#line 1009
  return;
}
}
#line 1061
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pi16)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1063
extern int ( /* missing proto */  __builtin_ia32_pmaxsw)() ;
#line 1061 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pi16)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1063
  __cil_tmp3 = __builtin_ia32_pmaxsw(__A, __B);
  }
#line 1063
  return (__cil_tmp3);
}
}
#line 1067
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxsw)(__m64 __A , __m64 __B ) ;
#line 1067 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxsw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1069
  __cil_tmp3 = _mm_max_pi16(__A, __B);
  }
#line 1069
  return (__cil_tmp3);
}
}
#line 1074
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pu8)(__m64 __A , __m64 __B ) ;
#line 1076
extern int ( /* missing proto */  __builtin_ia32_pmaxub)() ;
#line 1074 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1076
  __cil_tmp3 = __builtin_ia32_pmaxub(__A, __B);
  }
#line 1076
  return (__cil_tmp3);
}
}
#line 1080
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxub)(__m64 __A , __m64 __B ) ;
#line 1080 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxub)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1082
  __cil_tmp3 = _mm_max_pu8(__A, __B);
  }
#line 1082
  return (__cil_tmp3);
}
}
#line 1087
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pi16)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1089
extern int ( /* missing proto */  __builtin_ia32_pminsw)() ;
#line 1087 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pi16)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1089
  __cil_tmp3 = __builtin_ia32_pminsw(__A, __B);
  }
#line 1089
  return (__cil_tmp3);
}
}
#line 1093
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminsw)(__m64 __A , __m64 __B ) ;
#line 1093 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminsw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1095
  __cil_tmp3 = _mm_min_pi16(__A, __B);
  }
#line 1095
  return (__cil_tmp3);
}
}
#line 1100
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pu8)(__m64 __A , __m64 __B ) ;
#line 1102
extern int ( /* missing proto */  __builtin_ia32_pminub)() ;
#line 1100 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1102
  __cil_tmp3 = __builtin_ia32_pminub(__A, __B);
  }
#line 1102
  return (__cil_tmp3);
}
}
#line 1106
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminub)(__m64 __A , __m64 __B ) ;
#line 1106 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminub)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1108
  __cil_tmp3 = _mm_min_pu8(__A, __B);
  }
#line 1108
  return (__cil_tmp3);
}
}
#line 1113
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pi8)(__m64 __A ) ;
#line 1115
extern int ( /* missing proto */  __builtin_ia32_pmovmskb)() ;
#line 1113 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pi8)(__m64 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1115
  __cil_tmp2 = __builtin_ia32_pmovmskb(__A);
  }
#line 1115
  return (__cil_tmp2);
}
}
#line 1119
__inline extern int ( __attribute__((__gnu_inline__)) _m_pmovmskb)(__m64 __A ) ;
#line 1119 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _m_pmovmskb)(__m64 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1121
  __cil_tmp2 = _mm_movemask_pi8(__A);
  }
#line 1121
  return (__cil_tmp2);
}
}
#line 1127
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pu16)(__m64 __A ,
                                                                        __m64 __B ) ;
#line 1129
extern int ( /* missing proto */  __builtin_ia32_pmulhuw)() ;
#line 1127 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pu16)(__m64 __A ,
                                                                        __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1129
  __cil_tmp3 = __builtin_ia32_pmulhuw(__A, __B);
  }
#line 1129
  return (__cil_tmp3);
}
}
#line 1133
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhuw)(__m64 __A , __m64 __B ) ;
#line 1133 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhuw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1135
  __cil_tmp3 = _mm_mulhi_pu16(__A, __B);
  }
#line 1135
  return (__cil_tmp3);
}
}
#line 1163
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmove_si64)(__m64 __A ,
                                                                          __m64 __N ,
                                                                          char *__P ) ;
#line 1165
extern int ( /* missing proto */  __builtin_ia32_maskmovq)() ;
#line 1163 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmove_si64)(__m64 __A ,
                                                                          __m64 __N ,
                                                                          char *__P ) 
{ 


  {
  {
#line 1165
  __builtin_ia32_maskmovq(__A, __N, __P);
  }
#line 1167
  return;
}
}
#line 1169
__inline extern void ( __attribute__((__gnu_inline__)) _m_maskmovq)(__m64 __A , __m64 __N ,
                                                                    char *__P ) ;
#line 1169 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _m_maskmovq)(__m64 __A , __m64 __N ,
                                                                    char *__P ) 
{ 


  {
  {
#line 1171
  _mm_maskmove_si64(__A, __N, __P);
  }
#line 1173
  return;
}
}
#line 1176
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu8)(__m64 __A , __m64 __B ) ;
#line 1178
extern int ( /* missing proto */  __builtin_ia32_pavgb)() ;
#line 1176 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1178
  __cil_tmp3 = __builtin_ia32_pavgb(__A, __B);
  }
#line 1178
  return (__cil_tmp3);
}
}
#line 1182
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgb)(__m64 __A , __m64 __B ) ;
#line 1182 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgb)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1184
  __cil_tmp3 = _mm_avg_pu8(__A, __B);
  }
#line 1184
  return (__cil_tmp3);
}
}
#line 1189
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu16)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1191
extern int ( /* missing proto */  __builtin_ia32_pavgw)() ;
#line 1189 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu16)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1191
  __cil_tmp3 = __builtin_ia32_pavgw(__A, __B);
  }
#line 1191
  return (__cil_tmp3);
}
}
#line 1195
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgw)(__m64 __A , __m64 __B ) ;
#line 1195 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1197
  __cil_tmp3 = _mm_avg_pu16(__A, __B);
  }
#line 1197
  return (__cil_tmp3);
}
}
#line 1204
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sad_pu8)(__m64 __A , __m64 __B ) ;
#line 1206
extern int ( /* missing proto */  __builtin_ia32_psadbw)() ;
#line 1204 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sad_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1206
  __cil_tmp3 = __builtin_ia32_psadbw(__A, __B);
  }
#line 1206
  return (__cil_tmp3);
}
}
#line 1210
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psadbw)(__m64 __A , __m64 __B ) ;
#line 1210 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psadbw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1212
  __cil_tmp3 = _mm_sad_pu8(__A, __B);
  }
#line 1212
  return (__cil_tmp3);
}
}
#line 1217
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pi)(__m64 *__P ,
                                                                      __m64 __A ) ;
#line 1217 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pi)(__m64 *__P ,
                                                                      __m64 __A ) 
{ 


  {
#line 1222
  return;
}
}
#line 1224
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 1226
extern int ( /* missing proto */  __builtin_ia32_movntps)() ;
#line 1224 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 1226
  __builtin_ia32_movntps(__P, __A);
  }
#line 1228
  return;
}
}
#line 1232
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_sfence)(void) ;
#line 1234
extern int ( /* missing proto */  __builtin_ia32_sfence)() ;
#line 1232
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_sfence)(void) ;
#line 1232 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_sfence)(void) 
{ 


  {
  {
#line 1234
  __builtin_ia32_sfence();
  }
#line 1236
  return;
}
}
#line 66 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_sd)(double __F ) ;
#line 66 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_sd)(double __F ) 
{ 
  __m128d tmp ;

  {
#line 68
  return (tmp);
}
}
#line 79
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd1)(double __F ) ;
#line 79 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd1)(double __F ) 
{ 
  __m128d __cil_tmp2 ;

  {
  {
#line 81
  __cil_tmp2 = _mm_set_sd(__F);
  }
#line 81
  return (__cil_tmp2);
}
}
#line 86
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd)(double __W ,
                                                                      double __X ) ;
#line 86 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd)(double __W ,
                                                                      double __X ) 
{ 
  __m128d tmp ;

  {
#line 88
  return (tmp);
}
}
#line 100
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_undefined_pd)(void) ;
#line 100 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_undefined_pd)(void) 
{ 
  __m128d __Y ;

  {
#line 102
  __Y = __Y;
#line 103
  return (__Y);
}
}
#line 108
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_setzero_pd)(void) ;
#line 108 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_setzero_pd)(void) 
{ 
  __m128d tmp ;

  {
#line 110
  return (tmp);
}
}
#line 115
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_move_sd)(__m128d __A ,
                                                                       __m128d __B ) ;
#line 115 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_move_sd)(__m128d __A ,
                                                                       __m128d __B ) 
{ 


  {
#line 120
  return;
}
}
#line 122
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd)(double const   *__P ) ;
#line 122 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd)(double const   *__P ) 
{ 


  {
#line 124
  return (*((__m128d *)__P));
}
}
#line 129
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadu_pd)(double const   *__P ) ;
#line 129 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadu_pd)(double const   *__P ) 
{ 


  {
#line 131
  return (*((__m128d_u *)__P));
}
}
#line 136
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load1_pd)(double const   *__P ) ;
#line 136 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load1_pd)(double const   *__P ) 
{ 
  __m128d __cil_tmp2 ;

  {
  {
#line 138
  __cil_tmp2 = _mm_set_sd((double )*__P);
  }
#line 138
  return (__cil_tmp2);
}
}
#line 149
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd1)(double const   *__P ) ;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd1)(double const   *__P ) 
{ 
  __m128d __cil_tmp2 ;

  {
  {
#line 151
  __cil_tmp2 = _mm_load1_pd(__P);
  }
#line 151
  return (__cil_tmp2);
}
}
#line 156
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadr_pd)(double const   *__P ) ;
#line 159
extern int ( /* missing proto */  __builtin_ia32_shufpd)() ;
#line 156 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadr_pd)(double const   *__P ) 
{ 
  __m128d __tmp ;
  __m128d __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 158
  __cil_tmp3 = _mm_load_pd(__P);
#line 158
  __tmp = __cil_tmp3;
#line 159
  __cil_tmp4 = __builtin_ia32_shufpd(__tmp, __tmp, 1);
  }
#line 159
  return (__cil_tmp4);
}
}
#line 164
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd)(double *__P ,
                                                                     __m128d __A ) ;
#line 164 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd)(double *__P ,
                                                                     __m128d __A ) 
{ 


  {
#line 166
  *((__m128d *)__P) = __A;
#line 167
  return;
}
}
#line 171
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 171 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 


  {
#line 173
  *((__m128d_u *)__P) = __A;
#line 174
  return;
}
}
#line 178
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_sd)(double *__P ,
                                                                     __m128d __A ) ;
#line 178 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_sd)(double *__P ,
                                                                     __m128d __A ) 
{ 
  int __cil_tmp3 ;

  {
#line 180
  *__P = (double )__cil_tmp3;
#line 181
  return;
}
}
#line 184
__inline extern double ( __attribute__((__gnu_inline__)) _mm_cvtsd_f64)(__m128d __A ) ;
#line 184 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern double ( __attribute__((__gnu_inline__)) _mm_cvtsd_f64)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
#line 186
  return ((double )__cil_tmp2);
}
}
#line 190
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 190 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 


  {
  {
#line 192
  _mm_store_sd(__P, __A);
  }
#line 194
  return;
}
}
#line 205
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 205 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 207
  __cil_tmp3 = __builtin_ia32_shufpd(__A, __A, 0);
#line 207
  _mm_store_pd(__P, __cil_tmp3);
  }
#line 209
  return;
}
}
#line 211
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd1)(double *__P ,
                                                                      __m128d __A ) ;
#line 211 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd1)(double *__P ,
                                                                      __m128d __A ) 
{ 


  {
  {
#line 213
  _mm_store1_pd(__P, __A);
  }
#line 215
  return;
}
}
#line 218
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 218 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 220
  __cil_tmp3 = __builtin_ia32_shufpd(__A, __A, 1);
#line 220
  _mm_store_pd(__P, __cil_tmp3);
  }
#line 222
  return;
}
}
#line 224
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si32)(__m128i __A ) ;
#line 226
extern int ( /* missing proto */  __builtin_ia32_vec_ext_v4si)() ;
#line 224 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si32)(__m128i __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 226
  __cil_tmp2 = __builtin_ia32_vec_ext_v4si(__A, 0);
  }
#line 226
  return (__cil_tmp2);
}
}
#line 232
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si64)(__m128i __A ) ;
#line 232 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si64)(__m128i __A ) 
{ 
  int __cil_tmp2 ;

  {
#line 234
  return ((long long )__cil_tmp2);
}
}
#line 246
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_add_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 246 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_add_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 248
  return (__A + __B);
}
}
#line 258
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sub_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 258 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sub_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 260
  return (__A - __B);
}
}
#line 270
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_mul_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 270 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_mul_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 272
  return (__A * __B);
}
}
#line 282
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_div_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 282 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_div_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 284
  return (__A / __B);
}
}
#line 294
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_pd)(__m128d __A ) ;
#line 296
extern int ( /* missing proto */  __builtin_ia32_sqrtpd)() ;
#line 294 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_pd)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 296
  __cil_tmp2 = __builtin_ia32_sqrtpd(__A);
  }
#line 296
  return (__cil_tmp2);
}
}
#line 301
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_sd)(__m128d __A ,
                                                                       __m128d __B ) ;
#line 304
extern int ( /* missing proto */  __builtin_ia32_sqrtsd)() ;
#line 301 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_sd)(__m128d __A ,
                                                                       __m128d __B ) 
{ 
  __v2df __tmp ;
  int __cil_tmp4 ;

  {
  {
#line 303
  __tmp = 0;
#line 304
  __cil_tmp4 = __builtin_ia32_sqrtsd(__tmp);
  }
#line 304
  return (__cil_tmp4);
}
}
#line 308
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 310
extern int ( /* missing proto */  __builtin_ia32_minpd)() ;
#line 308 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 310
  __cil_tmp3 = __builtin_ia32_minpd(__A, __B);
  }
#line 310
  return (__cil_tmp3);
}
}
#line 314
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 316
extern int ( /* missing proto */  __builtin_ia32_minsd)() ;
#line 314 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 316
  __cil_tmp3 = __builtin_ia32_minsd(__A, __B);
  }
#line 316
  return (__cil_tmp3);
}
}
#line 320
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 322
extern int ( /* missing proto */  __builtin_ia32_maxpd)() ;
#line 320 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 322
  __cil_tmp3 = __builtin_ia32_maxpd(__A, __B);
  }
#line 322
  return (__cil_tmp3);
}
}
#line 326
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 328
extern int ( /* missing proto */  __builtin_ia32_maxsd)() ;
#line 326 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 328
  __cil_tmp3 = __builtin_ia32_maxsd(__A, __B);
  }
#line 328
  return (__cil_tmp3);
}
}
#line 356
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_pd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 358
extern int ( /* missing proto */  __builtin_ia32_cmpeqpd)() ;
#line 356 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_pd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 358
  __cil_tmp3 = __builtin_ia32_cmpeqpd(__A, __B);
  }
#line 358
  return (__cil_tmp3);
}
}
#line 362
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_pd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 364
extern int ( /* missing proto */  __builtin_ia32_cmpltpd)() ;
#line 362 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_pd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 364
  __cil_tmp3 = __builtin_ia32_cmpltpd(__A, __B);
  }
#line 364
  return (__cil_tmp3);
}
}
#line 368
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_pd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 370
extern int ( /* missing proto */  __builtin_ia32_cmplepd)() ;
#line 368 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_pd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 370
  __cil_tmp3 = __builtin_ia32_cmplepd(__A, __B);
  }
#line 370
  return (__cil_tmp3);
}
}
#line 386
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 388
extern int ( /* missing proto */  __builtin_ia32_cmpneqpd)() ;
#line 386 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 388
  __cil_tmp3 = __builtin_ia32_cmpneqpd(__A, __B);
  }
#line 388
  return (__cil_tmp3);
}
}
#line 392
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 394
extern int ( /* missing proto */  __builtin_ia32_cmpnltpd)() ;
#line 392 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 394
  __cil_tmp3 = __builtin_ia32_cmpnltpd(__A, __B);
  }
#line 394
  return (__cil_tmp3);
}
}
#line 398
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 400
extern int ( /* missing proto */  __builtin_ia32_cmpnlepd)() ;
#line 398 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 400
  __cil_tmp3 = __builtin_ia32_cmpnlepd(__A, __B);
  }
#line 400
  return (__cil_tmp3);
}
}
#line 416
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 418
extern int ( /* missing proto */  __builtin_ia32_cmpordpd)() ;
#line 416 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 418
  __cil_tmp3 = __builtin_ia32_cmpordpd(__A, __B);
  }
#line 418
  return (__cil_tmp3);
}
}
#line 422
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_pd)(__m128d __A ,
                                                                           __m128d __B ) ;
#line 424
extern int ( /* missing proto */  __builtin_ia32_cmpunordpd)() ;
#line 422 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_pd)(__m128d __A ,
                                                                           __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 424
  __cil_tmp3 = __builtin_ia32_cmpunordpd(__A, __B);
  }
#line 424
  return (__cil_tmp3);
}
}
#line 428
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_sd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 430
extern int ( /* missing proto */  __builtin_ia32_cmpeqsd)() ;
#line 428 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_sd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 430
  __cil_tmp3 = __builtin_ia32_cmpeqsd(__A, __B);
  }
#line 430
  return (__cil_tmp3);
}
}
#line 434
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_sd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 436
extern int ( /* missing proto */  __builtin_ia32_cmpltsd)() ;
#line 434 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_sd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 436
  __cil_tmp3 = __builtin_ia32_cmpltsd(__A, __B);
  }
#line 436
  return (__cil_tmp3);
}
}
#line 440
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_sd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 442
extern int ( /* missing proto */  __builtin_ia32_cmplesd)() ;
#line 440 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_sd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 442
  __cil_tmp3 = __builtin_ia32_cmplesd(__A, __B);
  }
#line 442
  return (__cil_tmp3);
}
}
#line 466
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 468
extern int ( /* missing proto */  __builtin_ia32_cmpneqsd)() ;
#line 466 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 468
  __cil_tmp3 = __builtin_ia32_cmpneqsd(__A, __B);
  }
#line 468
  return (__cil_tmp3);
}
}
#line 472
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 474
extern int ( /* missing proto */  __builtin_ia32_cmpnltsd)() ;
#line 472 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 474
  __cil_tmp3 = __builtin_ia32_cmpnltsd(__A, __B);
  }
#line 474
  return (__cil_tmp3);
}
}
#line 478
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 480
extern int ( /* missing proto */  __builtin_ia32_cmpnlesd)() ;
#line 478 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 480
  __cil_tmp3 = __builtin_ia32_cmpnlesd(__A, __B);
  }
#line 480
  return (__cil_tmp3);
}
}
#line 504
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 506
extern int ( /* missing proto */  __builtin_ia32_cmpordsd)() ;
#line 504 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 506
  __cil_tmp3 = __builtin_ia32_cmpordsd(__A, __B);
  }
#line 506
  return (__cil_tmp3);
}
}
#line 510
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_sd)(__m128d __A ,
                                                                           __m128d __B ) ;
#line 512
extern int ( /* missing proto */  __builtin_ia32_cmpunordsd)() ;
#line 510 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_sd)(__m128d __A ,
                                                                           __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 512
  __cil_tmp3 = __builtin_ia32_cmpunordsd(__A, __B);
  }
#line 512
  return (__cil_tmp3);
}
}
#line 516
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 518
extern int ( /* missing proto */  __builtin_ia32_comisdeq)() ;
#line 516 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 518
  __cil_tmp3 = __builtin_ia32_comisdeq(__A, __B);
  }
#line 518
  return (__cil_tmp3);
}
}
#line 522
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 524
extern int ( /* missing proto */  __builtin_ia32_comisdlt)() ;
#line 522 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 524
  __cil_tmp3 = __builtin_ia32_comisdlt(__A, __B);
  }
#line 524
  return (__cil_tmp3);
}
}
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 530
extern int ( /* missing proto */  __builtin_ia32_comisdle)() ;
#line 528 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 530
  __cil_tmp3 = __builtin_ia32_comisdle(__A, __B);
  }
#line 530
  return (__cil_tmp3);
}
}
#line 534
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 536
extern int ( /* missing proto */  __builtin_ia32_comisdgt)() ;
#line 534 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 536
  __cil_tmp3 = __builtin_ia32_comisdgt(__A, __B);
  }
#line 536
  return (__cil_tmp3);
}
}
#line 540
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 542
extern int ( /* missing proto */  __builtin_ia32_comisdge)() ;
#line 540 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 542
  __cil_tmp3 = __builtin_ia32_comisdge(__A, __B);
  }
#line 542
  return (__cil_tmp3);
}
}
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 548
extern int ( /* missing proto */  __builtin_ia32_comisdneq)() ;
#line 546 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 548
  __cil_tmp3 = __builtin_ia32_comisdneq(__A, __B);
  }
#line 548
  return (__cil_tmp3);
}
}
#line 552
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 554
extern int ( /* missing proto */  __builtin_ia32_ucomisdeq)() ;
#line 552 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 554
  __cil_tmp3 = __builtin_ia32_ucomisdeq(__A, __B);
  }
#line 554
  return (__cil_tmp3);
}
}
#line 558
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 560
extern int ( /* missing proto */  __builtin_ia32_ucomisdlt)() ;
#line 558 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 560
  __cil_tmp3 = __builtin_ia32_ucomisdlt(__A, __B);
  }
#line 560
  return (__cil_tmp3);
}
}
#line 564
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 566
extern int ( /* missing proto */  __builtin_ia32_ucomisdle)() ;
#line 564 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 566
  __cil_tmp3 = __builtin_ia32_ucomisdle(__A, __B);
  }
#line 566
  return (__cil_tmp3);
}
}
#line 570
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 572
extern int ( /* missing proto */  __builtin_ia32_ucomisdgt)() ;
#line 570 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 572
  __cil_tmp3 = __builtin_ia32_ucomisdgt(__A, __B);
  }
#line 572
  return (__cil_tmp3);
}
}
#line 576
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 578
extern int ( /* missing proto */  __builtin_ia32_ucomisdge)() ;
#line 576 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 578
  __cil_tmp3 = __builtin_ia32_ucomisdge(__A, __B);
  }
#line 578
  return (__cil_tmp3);
}
}
#line 582
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_sd)(__m128d __A ,
                                                                       __m128d __B ) ;
#line 584
extern int ( /* missing proto */  __builtin_ia32_ucomisdneq)() ;
#line 582 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_sd)(__m128d __A ,
                                                                       __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 584
  __cil_tmp3 = __builtin_ia32_ucomisdneq(__A, __B);
  }
#line 584
  return (__cil_tmp3);
}
}
#line 590
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64x)(long long __q1 ,
                                                                          long long __q0 ) ;
#line 590 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64x)(long long __q1 ,
                                                                          long long __q0 ) 
{ 
  __v2di tmp ;

  {
#line 592
  return (tmp);
}
}
#line 596
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64)(__m64 __q1 ,
                                                                         __m64 __q0 ) ;
#line 596 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64)(__m64 __q1 ,
                                                                         __m64 __q0 ) 
{ 
  __m128i __cil_tmp3 ;

  {
  {
#line 598
  __cil_tmp3 = _mm_set_epi64x((long long )__q1, (long long )__q0);
  }
#line 598
  return (__cil_tmp3);
}
}
#line 602
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi32)(int __q3 ,
                                                                         int __q2 ,
                                                                         int __q1 ,
                                                                         int __q0 ) ;
#line 602 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi32)(int __q3 ,
                                                                         int __q2 ,
                                                                         int __q1 ,
                                                                         int __q0 ) 
{ 
  __v4si tmp ;

  {
#line 604
  return (tmp);
}
}
#line 608
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi16)(short __q7 ,
                                                                         short __q6 ,
                                                                         short __q5 ,
                                                                         short __q4 ,
                                                                         short __q3 ,
                                                                         short __q2 ,
                                                                         short __q1 ,
                                                                         short __q0 ) ;
#line 608 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi16)(short __q7 ,
                                                                         short __q6 ,
                                                                         short __q5 ,
                                                                         short __q4 ,
                                                                         short __q3 ,
                                                                         short __q2 ,
                                                                         short __q1 ,
                                                                         short __q0 ) 
{ 
  __v8hi tmp ;

  {
#line 611
  return (tmp);
}
}
#line 616
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi8)(char __q15 ,
                                                                        char __q14 ,
                                                                        char __q13 ,
                                                                        char __q12 ,
                                                                        char __q11 ,
                                                                        char __q10 ,
                                                                        char __q09 ,
                                                                        char __q08 ,
                                                                        char __q07 ,
                                                                        char __q06 ,
                                                                        char __q05 ,
                                                                        char __q04 ,
                                                                        char __q03 ,
                                                                        char __q02 ,
                                                                        char __q01 ,
                                                                        char __q00 ) ;
#line 616 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi8)(char __q15 ,
                                                                        char __q14 ,
                                                                        char __q13 ,
                                                                        char __q12 ,
                                                                        char __q11 ,
                                                                        char __q10 ,
                                                                        char __q09 ,
                                                                        char __q08 ,
                                                                        char __q07 ,
                                                                        char __q06 ,
                                                                        char __q05 ,
                                                                        char __q04 ,
                                                                        char __q03 ,
                                                                        char __q02 ,
                                                                        char __q01 ,
                                                                        char __q00 ) 
{ 
  __v16qi tmp ;

  {
#line 621
  return (tmp);
}
}
#line 630
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64x)(long long __A ) ;
#line 630 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64x)(long long __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 632
  __cil_tmp2 = _mm_set_epi64x(__A, __A);
  }
#line 632
  return (__cil_tmp2);
}
}
#line 636
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64)(__m64 __A ) ;
#line 636 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64)(__m64 __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 638
  __cil_tmp2 = _mm_set_epi64(__A, __A);
  }
#line 638
  return (__cil_tmp2);
}
}
#line 642
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi32)(int __A ) ;
#line 642 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi32)(int __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 644
  __cil_tmp2 = _mm_set_epi32(__A, __A, __A, __A);
  }
#line 644
  return (__cil_tmp2);
}
}
#line 648
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi16)(short __A ) ;
#line 648 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi16)(short __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 650
  __cil_tmp2 = _mm_set_epi16(__A, __A, __A, __A, __A, __A, __A, __A);
  }
#line 650
  return (__cil_tmp2);
}
}
#line 654
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi8)(char __A ) ;
#line 654 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi8)(char __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 656
  __cil_tmp2 = _mm_set_epi8(__A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A,
                            __A, __A, __A, __A, __A);
  }
#line 656
  return (__cil_tmp2);
}
}
#line 664
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi64)(__m64 __q0 ,
                                                                          __m64 __q1 ) ;
#line 664 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi64)(__m64 __q0 ,
                                                                          __m64 __q1 ) 
{ 
  __m128i __cil_tmp3 ;

  {
  {
#line 666
  __cil_tmp3 = _mm_set_epi64(__q1, __q0);
  }
#line 666
  return (__cil_tmp3);
}
}
#line 670
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi32)(int __q0 ,
                                                                          int __q1 ,
                                                                          int __q2 ,
                                                                          int __q3 ) ;
#line 670 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi32)(int __q0 ,
                                                                          int __q1 ,
                                                                          int __q2 ,
                                                                          int __q3 ) 
{ 
  __m128i __cil_tmp5 ;

  {
  {
#line 672
  __cil_tmp5 = _mm_set_epi32(__q3, __q2, __q1, __q0);
  }
#line 672
  return (__cil_tmp5);
}
}
#line 676
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi16)(short __q0 ,
                                                                          short __q1 ,
                                                                          short __q2 ,
                                                                          short __q3 ,
                                                                          short __q4 ,
                                                                          short __q5 ,
                                                                          short __q6 ,
                                                                          short __q7 ) ;
#line 676 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi16)(short __q0 ,
                                                                          short __q1 ,
                                                                          short __q2 ,
                                                                          short __q3 ,
                                                                          short __q4 ,
                                                                          short __q5 ,
                                                                          short __q6 ,
                                                                          short __q7 ) 
{ 
  __m128i __cil_tmp9 ;

  {
  {
#line 679
  __cil_tmp9 = _mm_set_epi16(__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);
  }
#line 679
  return (__cil_tmp9);
}
}
#line 683
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi8)(char __q00 ,
                                                                         char __q01 ,
                                                                         char __q02 ,
                                                                         char __q03 ,
                                                                         char __q04 ,
                                                                         char __q05 ,
                                                                         char __q06 ,
                                                                         char __q07 ,
                                                                         char __q08 ,
                                                                         char __q09 ,
                                                                         char __q10 ,
                                                                         char __q11 ,
                                                                         char __q12 ,
                                                                         char __q13 ,
                                                                         char __q14 ,
                                                                         char __q15 ) ;
#line 683 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi8)(char __q00 ,
                                                                         char __q01 ,
                                                                         char __q02 ,
                                                                         char __q03 ,
                                                                         char __q04 ,
                                                                         char __q05 ,
                                                                         char __q06 ,
                                                                         char __q07 ,
                                                                         char __q08 ,
                                                                         char __q09 ,
                                                                         char __q10 ,
                                                                         char __q11 ,
                                                                         char __q12 ,
                                                                         char __q13 ,
                                                                         char __q14 ,
                                                                         char __q15 ) 
{ 
  __m128i __cil_tmp17 ;

  {
  {
#line 688
  __cil_tmp17 = _mm_set_epi8(__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08,
                             __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);
  }
#line 688
  return (__cil_tmp17);
}
}
#line 695
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_load_si128)(__m128i *__P ) ;
#line 695 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_load_si128)(__m128i *__P ) 
{ 


  {
#line 697
  return (*__P);
}
}
#line 701
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadu_si128)(__m128i_u *__P ) ;
#line 701 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadu_si128)(__m128i_u *__P ) 
{ 


  {
#line 703
  return (*__P);
}
}
#line 707
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadl_epi64)(__m128i_u *__P ) ;
#line 707 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadl_epi64)(__m128i_u *__P ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 709
  __cil_tmp2 = _mm_set_epi64((__m64 )0LL, *__P);
  }
#line 709
  return (__cil_tmp2);
}
}
#line 713
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_si128)(__m128i *__P ,
                                                                        __m128i __B ) ;
#line 713 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_si128)(__m128i *__P ,
                                                                        __m128i __B ) 
{ 


  {
#line 715
  *__P = __B;
#line 716
  return;
}
}
#line 719
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_si128)(__m128i_u *__P ,
                                                                         __m128i __B ) ;
#line 719 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_si128)(__m128i_u *__P ,
                                                                         __m128i __B ) 
{ 


  {
#line 721
  *__P = __B;
#line 722
  return;
}
}
#line 725
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_epi64)(__m128i_u *__P ,
                                                                         __m128i __B ) ;
#line 725 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_epi64)(__m128i_u *__P ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
#line 727
  *__P = __cil_tmp3;
#line 728
  return;
}
}
#line 731
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_movepi64_pi64)(__m128i __B ) ;
#line 731 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_movepi64_pi64)(__m128i __B ) 
{ 
  int __cil_tmp2 ;

  {
#line 733
  return (__cil_tmp2);
}
}
#line 737
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_movpi64_epi64)(__m64 __A ) ;
#line 737 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_movpi64_epi64)(__m64 __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 739
  __cil_tmp2 = _mm_set_epi64((__m64 )0LL, __A);
  }
#line 739
  return (__cil_tmp2);
}
}
#line 743
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_move_epi64)(__m128i __A ) ;
#line 743 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_move_epi64)(__m128i __A ) 
{ 


  {
#line 748
  return;
}
}
#line 750
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_undefined_si128)(void) ;
#line 750 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_undefined_si128)(void) 
{ 
  __m128i __Y ;

  {
#line 752
  __Y = __Y;
#line 753
  return (__Y);
}
}
#line 758
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setzero_si128)(void) ;
#line 758 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setzero_si128)(void) 
{ 
  __v4si tmp ;

  {
#line 760
  return (tmp);
}
}
#line 764
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtepi32_pd)(__m128i __A ) ;
#line 764 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtepi32_pd)(__m128i __A ) 
{ 


  {
#line 769
  return;
}
}
#line 770
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtepi32_ps)(__m128i __A ) ;
#line 770 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtepi32_ps)(__m128i __A ) 
{ 


  {
#line 775
  return;
}
}
#line 776
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtpd_epi32)(__m128d __A ) ;
#line 778
extern int ( /* missing proto */  __builtin_ia32_cvtpd2dq)() ;
#line 776 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtpd_epi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 778
  __cil_tmp2 = __builtin_ia32_cvtpd2dq(__A);
  }
#line 778
  return (__cil_tmp2);
}
}
#line 782
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtpd_pi32)(__m128d __A ) ;
#line 784
extern int ( /* missing proto */  __builtin_ia32_cvtpd2pi)() ;
#line 782 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtpd_pi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 784
  __cil_tmp2 = __builtin_ia32_cvtpd2pi(__A);
  }
#line 784
  return (__cil_tmp2);
}
}
#line 788
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpd_ps)(__m128d __A ) ;
#line 790
extern int ( /* missing proto */  __builtin_ia32_cvtpd2ps)() ;
#line 788 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpd_ps)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 790
  __cil_tmp2 = __builtin_ia32_cvtpd2ps(__A);
  }
#line 790
  return (__cil_tmp2);
}
}
#line 794
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttpd_epi32)(__m128d __A ) ;
#line 796
extern int ( /* missing proto */  __builtin_ia32_cvttpd2dq)() ;
#line 794 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttpd_epi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 796
  __cil_tmp2 = __builtin_ia32_cvttpd2dq(__A);
  }
#line 796
  return (__cil_tmp2);
}
}
#line 800
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttpd_pi32)(__m128d __A ) ;
#line 802
extern int ( /* missing proto */  __builtin_ia32_cvttpd2pi)() ;
#line 800 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttpd_pi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 802
  __cil_tmp2 = __builtin_ia32_cvttpd2pi(__A);
  }
#line 802
  return (__cil_tmp2);
}
}
#line 806
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtpi32_pd)(__m64 __A ) ;
#line 808
extern int ( /* missing proto */  __builtin_ia32_cvtpi2pd)() ;
#line 806 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtpi32_pd)(__m64 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 808
  __cil_tmp2 = __builtin_ia32_cvtpi2pd(__A);
  }
#line 808
  return (__cil_tmp2);
}
}
#line 812
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtps_epi32)(__m128 __A ) ;
#line 814
extern int ( /* missing proto */  __builtin_ia32_cvtps2dq)() ;
#line 812 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtps_epi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 814
  __cil_tmp2 = __builtin_ia32_cvtps2dq(__A);
  }
#line 814
  return (__cil_tmp2);
}
}
#line 818
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttps_epi32)(__m128 __A ) ;
#line 820
extern int ( /* missing proto */  __builtin_ia32_cvttps2dq)() ;
#line 818 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttps_epi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 820
  __cil_tmp2 = __builtin_ia32_cvttps2dq(__A);
  }
#line 820
  return (__cil_tmp2);
}
}
#line 824
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtps_pd)(__m128 __A ) ;
#line 824 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtps_pd)(__m128 __A ) 
{ 


  {
#line 829
  return;
}
}
#line 830
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsd_si32)(__m128d __A ) ;
#line 832
extern int ( /* missing proto */  __builtin_ia32_cvtsd2si)() ;
#line 830 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsd_si32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 832
  __cil_tmp2 = __builtin_ia32_cvtsd2si(__A);
  }
#line 832
  return (__cil_tmp2);
}
}
#line 838
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsd_si64)(__m128d __A ) ;
#line 840
extern int ( /* missing proto */  __builtin_ia32_cvtsd2si64)() ;
#line 838 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsd_si64)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 840
  __cil_tmp2 = __builtin_ia32_cvtsd2si64(__A);
  }
#line 840
  return ((long long )__cil_tmp2);
}
}
#line 852
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttsd_si32)(__m128d __A ) ;
#line 854
extern int ( /* missing proto */  __builtin_ia32_cvttsd2si)() ;
#line 852 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttsd_si32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 854
  __cil_tmp2 = __builtin_ia32_cvttsd2si(__A);
  }
#line 854
  return (__cil_tmp2);
}
}
#line 860
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttsd_si64)(__m128d __A ) ;
#line 862
extern int ( /* missing proto */  __builtin_ia32_cvttsd2si64)() ;
#line 860 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttsd_si64)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 862
  __cil_tmp2 = __builtin_ia32_cvttsd2si64(__A);
  }
#line 862
  return ((long long )__cil_tmp2);
}
}
#line 874
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsd_ss)(__m128 __A ,
                                                                       __m128d __B ) ;
#line 876
extern int ( /* missing proto */  __builtin_ia32_cvtsd2ss)() ;
#line 874 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsd_ss)(__m128 __A ,
                                                                       __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 876
  __cil_tmp3 = __builtin_ia32_cvtsd2ss(__A, __B);
  }
#line 876
  return (__cil_tmp3);
}
}
#line 880
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi32_sd)(__m128d __A ,
                                                                          int __B ) ;
#line 880 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi32_sd)(__m128d __A ,
                                                                          int __B ) 
{ 


  {
#line 885
  return;
}
}
#line 888
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi64_sd)(__m128d __A ,
                                                                          long long __B ) ;
#line 888 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi64_sd)(__m128d __A ,
                                                                          long long __B ) 
{ 


  {
#line 893
  return;
}
}
#line 902
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtss_sd)(__m128d __A ,
                                                                        __m128 __B ) ;
#line 902 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtss_sd)(__m128d __A ,
                                                                        __m128 __B ) 
{ 


  {
#line 907
  return;
}
}
#line 932
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadh_pd)(__m128d __A ,
                                                                        double const   *__B ) ;
#line 932 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadh_pd)(__m128d __A ,
                                                                        double const   *__B ) 
{ 


  {
#line 937
  return;
}
}
#line 944
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pd)(__m128d __A ) ;
#line 946
extern int ( /* missing proto */  __builtin_ia32_movmskpd)() ;
#line 944 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pd)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 946
  __cil_tmp2 = __builtin_ia32_movmskpd(__A);
  }
#line 946
  return (__cil_tmp2);
}
}
#line 950
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 952
extern int ( /* missing proto */  __builtin_ia32_packsswb128)() ;
#line 950 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 952
  __cil_tmp3 = __builtin_ia32_packsswb128(__A, __B);
  }
#line 952
  return (__cil_tmp3);
}
}
#line 956
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 958
extern int ( /* missing proto */  __builtin_ia32_packssdw128)() ;
#line 956 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 958
  __cil_tmp3 = __builtin_ia32_packssdw128(__A, __B);
  }
#line 958
  return (__cil_tmp3);
}
}
#line 962
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packus_epi16)(__m128i __A ,
                                                                            __m128i __B ) ;
#line 964
extern int ( /* missing proto */  __builtin_ia32_packuswb128)() ;
#line 962 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packus_epi16)(__m128i __A ,
                                                                            __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 964
  __cil_tmp3 = __builtin_ia32_packuswb128(__A, __B);
  }
#line 964
  return (__cil_tmp3);
}
}
#line 968
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_unpackhi_epi8)(__m128i __A ,
                                                                             __m128i __B ) ;
#line 968 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_unpackhi_epi8)(__m128i __A ,
                                                                             __m128i __B ) 
{ 


  {
#line 973
  return;
}
}
#line 1016
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1016 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 


  {
#line 1018
  return (__A + __B);
}
}
#line 1022
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1022 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1024
  return (__A + __B);
}
}
#line 1028
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1028 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1030
  return (__A + __B);
}
}
#line 1034
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1034 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1036
  return (__A + __B);
}
}
#line 1040
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1042
extern int ( /* missing proto */  __builtin_ia32_paddsb128)() ;
#line 1040 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1042
  __cil_tmp3 = __builtin_ia32_paddsb128(__A, __B);
  }
#line 1042
  return (__cil_tmp3);
}
}
#line 1046
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1048
extern int ( /* missing proto */  __builtin_ia32_paddsw128)() ;
#line 1046 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1048
  __cil_tmp3 = __builtin_ia32_paddsw128(__A, __B);
  }
#line 1048
  return (__cil_tmp3);
}
}
#line 1052
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1054
extern int ( /* missing proto */  __builtin_ia32_paddusb128)() ;
#line 1052 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1054
  __cil_tmp3 = __builtin_ia32_paddusb128(__A, __B);
  }
#line 1054
  return (__cil_tmp3);
}
}
#line 1058
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1060
extern int ( /* missing proto */  __builtin_ia32_paddusw128)() ;
#line 1058 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1060
  __cil_tmp3 = __builtin_ia32_paddusw128(__A, __B);
  }
#line 1060
  return (__cil_tmp3);
}
}
#line 1064
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1064 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 


  {
#line 1066
  return (__A - __B);
}
}
#line 1070
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1070 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1072
  return (__A - __B);
}
}
#line 1076
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1076 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1078
  return (__A - __B);
}
}
#line 1082
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1082 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1084
  return (__A - __B);
}
}
#line 1088
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1090
extern int ( /* missing proto */  __builtin_ia32_psubsb128)() ;
#line 1088 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1090
  __cil_tmp3 = __builtin_ia32_psubsb128(__A, __B);
  }
#line 1090
  return (__cil_tmp3);
}
}
#line 1094
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1096
extern int ( /* missing proto */  __builtin_ia32_psubsw128)() ;
#line 1094 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1096
  __cil_tmp3 = __builtin_ia32_psubsw128(__A, __B);
  }
#line 1096
  return (__cil_tmp3);
}
}
#line 1100
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1102
extern int ( /* missing proto */  __builtin_ia32_psubusb128)() ;
#line 1100 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1102
  __cil_tmp3 = __builtin_ia32_psubusb128(__A, __B);
  }
#line 1102
  return (__cil_tmp3);
}
}
#line 1106
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1108
extern int ( /* missing proto */  __builtin_ia32_psubusw128)() ;
#line 1106 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1108
  __cil_tmp3 = __builtin_ia32_psubusw128(__A, __B);
  }
#line 1108
  return (__cil_tmp3);
}
}
#line 1112
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_madd_epi16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1114
extern int ( /* missing proto */  __builtin_ia32_pmaddwd128)() ;
#line 1112 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_madd_epi16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1114
  __cil_tmp3 = __builtin_ia32_pmaddwd128(__A, __B);
  }
#line 1114
  return (__cil_tmp3);
}
}
#line 1118
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1120
extern int ( /* missing proto */  __builtin_ia32_pmulhw128)() ;
#line 1118 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1120
  __cil_tmp3 = __builtin_ia32_pmulhw128(__A, __B);
  }
#line 1120
  return (__cil_tmp3);
}
}
#line 1124
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mullo_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1124 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mullo_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1126
  return (__A * __B);
}
}
#line 1130
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mul_su32)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1132
extern int ( /* missing proto */  __builtin_ia32_pmuludq)() ;
#line 1130 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mul_su32)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1132
  __cil_tmp3 = __builtin_ia32_pmuludq(__A, __B);
  }
#line 1132
  return (__cil_tmp3);
}
}
#line 1136
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mul_epu32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1138
extern int ( /* missing proto */  __builtin_ia32_pmuludq128)() ;
#line 1136 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mul_epu32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1138
  __cil_tmp3 = __builtin_ia32_pmuludq128(__A, __B);
  }
#line 1138
  return (__cil_tmp3);
}
}
#line 1142
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi16)(__m128i __A ,
                                                                          int __B ) ;
#line 1144
extern int ( /* missing proto */  __builtin_ia32_psllwi128)() ;
#line 1142 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi16)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1144
  __cil_tmp3 = __builtin_ia32_psllwi128(__A, __B);
  }
#line 1144
  return (__cil_tmp3);
}
}
#line 1148
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi32)(__m128i __A ,
                                                                          int __B ) ;
#line 1150
extern int ( /* missing proto */  __builtin_ia32_pslldi128)() ;
#line 1148 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi32)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1150
  __cil_tmp3 = __builtin_ia32_pslldi128(__A, __B);
  }
#line 1150
  return (__cil_tmp3);
}
}
#line 1154
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi64)(__m128i __A ,
                                                                          int __B ) ;
#line 1156
extern int ( /* missing proto */  __builtin_ia32_psllqi128)() ;
#line 1154 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi64)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1156
  __cil_tmp3 = __builtin_ia32_psllqi128(__A, __B);
  }
#line 1156
  return (__cil_tmp3);
}
}
#line 1160
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi16)(__m128i __A ,
                                                                          int __B ) ;
#line 1162
extern int ( /* missing proto */  __builtin_ia32_psrawi128)() ;
#line 1160 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi16)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1162
  __cil_tmp3 = __builtin_ia32_psrawi128(__A, __B);
  }
#line 1162
  return (__cil_tmp3);
}
}
#line 1166
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi32)(__m128i __A ,
                                                                          int __B ) ;
#line 1168
extern int ( /* missing proto */  __builtin_ia32_psradi128)() ;
#line 1166 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi32)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1168
  __cil_tmp3 = __builtin_ia32_psradi128(__A, __B);
  }
#line 1168
  return (__cil_tmp3);
}
}
#line 1207
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi16)(__m128i __A ,
                                                                          int __B ) ;
#line 1209
extern int ( /* missing proto */  __builtin_ia32_psrlwi128)() ;
#line 1207 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi16)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1209
  __cil_tmp3 = __builtin_ia32_psrlwi128(__A, __B);
  }
#line 1209
  return (__cil_tmp3);
}
}
#line 1213
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi32)(__m128i __A ,
                                                                          int __B ) ;
#line 1215
extern int ( /* missing proto */  __builtin_ia32_psrldi128)() ;
#line 1213 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi32)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1215
  __cil_tmp3 = __builtin_ia32_psrldi128(__A, __B);
  }
#line 1215
  return (__cil_tmp3);
}
}
#line 1219
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi64)(__m128i __A ,
                                                                          int __B ) ;
#line 1221
extern int ( /* missing proto */  __builtin_ia32_psrlqi128)() ;
#line 1219 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi64)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1221
  __cil_tmp3 = __builtin_ia32_psrlqi128(__A, __B);
  }
#line 1221
  return (__cil_tmp3);
}
}
#line 1225
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1227
extern int ( /* missing proto */  __builtin_ia32_psllw128)() ;
#line 1225 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1227
  __cil_tmp3 = __builtin_ia32_psllw128(__A, __B);
  }
#line 1227
  return (__cil_tmp3);
}
}
#line 1231
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1233
extern int ( /* missing proto */  __builtin_ia32_pslld128)() ;
#line 1231 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1233
  __cil_tmp3 = __builtin_ia32_pslld128(__A, __B);
  }
#line 1233
  return (__cil_tmp3);
}
}
#line 1237
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1239
extern int ( /* missing proto */  __builtin_ia32_psllq128)() ;
#line 1237 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1239
  __cil_tmp3 = __builtin_ia32_psllq128(__A, __B);
  }
#line 1239
  return (__cil_tmp3);
}
}
#line 1243
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1245
extern int ( /* missing proto */  __builtin_ia32_psraw128)() ;
#line 1243 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1245
  __cil_tmp3 = __builtin_ia32_psraw128(__A, __B);
  }
#line 1245
  return (__cil_tmp3);
}
}
#line 1249
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1251
extern int ( /* missing proto */  __builtin_ia32_psrad128)() ;
#line 1249 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1251
  __cil_tmp3 = __builtin_ia32_psrad128(__A, __B);
  }
#line 1251
  return (__cil_tmp3);
}
}
#line 1255
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1257
extern int ( /* missing proto */  __builtin_ia32_psrlw128)() ;
#line 1255 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1257
  __cil_tmp3 = __builtin_ia32_psrlw128(__A, __B);
  }
#line 1257
  return (__cil_tmp3);
}
}
#line 1261
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1263
extern int ( /* missing proto */  __builtin_ia32_psrld128)() ;
#line 1261 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1263
  __cil_tmp3 = __builtin_ia32_psrld128(__A, __B);
  }
#line 1263
  return (__cil_tmp3);
}
}
#line 1267
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1269
extern int ( /* missing proto */  __builtin_ia32_psrlq128)() ;
#line 1267 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1269
  __cil_tmp3 = __builtin_ia32_psrlq128(__A, __B);
  }
#line 1269
  return (__cil_tmp3);
}
}
#line 1273
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_and_si128)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1273 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_and_si128)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1275
  return (__A & __B);
}
}
#line 1285
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_or_si128)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1285 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_or_si128)(__m128i __A ,
                                                                        __m128i __B ) 
{ 


  {
#line 1287
  return (__A | __B);
}
}
#line 1291
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_xor_si128)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1291 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_xor_si128)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1293
  return (__A ^ __B);
}
}
#line 1297
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi8)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1297 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi8)(__m128i __A ,
                                                                          __m128i __B ) 
{ 


  {
#line 1299
  return (__A == __B);
}
}
#line 1303
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1303 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1305
  return (__A == __B);
}
}
#line 1309
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1309 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1311
  return (__A == __B);
}
}
#line 1315
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi8)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1315 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi8)(__m128i __A ,
                                                                          __m128i __B ) 
{ 


  {
#line 1317
  return (__A < __B);
}
}
#line 1321
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1321 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1323
  return (__A < __B);
}
}
#line 1327
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1327 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1329
  return (__A < __B);
}
}
#line 1333
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi8)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1333 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi8)(__m128i __A ,
                                                                          __m128i __B ) 
{ 


  {
#line 1335
  return (__A > __B);
}
}
#line 1339
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1339 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1341
  return (__A > __B);
}
}
#line 1345
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1345 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1347
  return (__A > __B);
}
}
#line 1371
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1373
extern int ( /* missing proto */  __builtin_ia32_pmaxsw128)() ;
#line 1371 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1373
  __cil_tmp3 = __builtin_ia32_pmaxsw128(__A, __B);
  }
#line 1373
  return (__cil_tmp3);
}
}
#line 1377
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1379
extern int ( /* missing proto */  __builtin_ia32_pmaxub128)() ;
#line 1377 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1379
  __cil_tmp3 = __builtin_ia32_pmaxub128(__A, __B);
  }
#line 1379
  return (__cil_tmp3);
}
}
#line 1383
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1385
extern int ( /* missing proto */  __builtin_ia32_pminsw128)() ;
#line 1383 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1385
  __cil_tmp3 = __builtin_ia32_pminsw128(__A, __B);
  }
#line 1385
  return (__cil_tmp3);
}
}
#line 1389
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1391
extern int ( /* missing proto */  __builtin_ia32_pminub128)() ;
#line 1389 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1391
  __cil_tmp3 = __builtin_ia32_pminub128(__A, __B);
  }
#line 1391
  return (__cil_tmp3);
}
}
#line 1395
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_epi8)(__m128i __A ) ;
#line 1397
extern int ( /* missing proto */  __builtin_ia32_pmovmskb128)() ;
#line 1395 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_epi8)(__m128i __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1397
  __cil_tmp2 = __builtin_ia32_pmovmskb128(__A);
  }
#line 1397
  return (__cil_tmp2);
}
}
#line 1401
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epu16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1403
extern int ( /* missing proto */  __builtin_ia32_pmulhuw128)() ;
#line 1401 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epu16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1403
  __cil_tmp3 = __builtin_ia32_pmulhuw128(__A, __B);
  }
#line 1403
  return (__cil_tmp3);
}
}
#line 1434
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmoveu_si128)(__m128i __A ,
                                                                            __m128i __B ,
                                                                            char *__C ) ;
#line 1436
extern int ( /* missing proto */  __builtin_ia32_maskmovdqu)() ;
#line 1434 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmoveu_si128)(__m128i __A ,
                                                                            __m128i __B ,
                                                                            char *__C ) 
{ 


  {
  {
#line 1436
  __builtin_ia32_maskmovdqu(__A, __B, __C);
  }
#line 1438
  return;
}
}
#line 1440
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1442
extern int ( /* missing proto */  __builtin_ia32_pavgb128)() ;
#line 1440 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1442
  __cil_tmp3 = __builtin_ia32_pavgb128(__A, __B);
  }
#line 1442
  return (__cil_tmp3);
}
}
#line 1446
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1448
extern int ( /* missing proto */  __builtin_ia32_pavgw128)() ;
#line 1446 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1448
  __cil_tmp3 = __builtin_ia32_pavgw128(__A, __B);
  }
#line 1448
  return (__cil_tmp3);
}
}
#line 1452
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sad_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1454
extern int ( /* missing proto */  __builtin_ia32_psadbw128)() ;
#line 1452 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sad_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1454
  __cil_tmp3 = __builtin_ia32_psadbw128(__A, __B);
  }
#line 1454
  return (__cil_tmp3);
}
}
#line 1458
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si32)(int *__A ,
                                                                        int __B ) ;
#line 1460
extern int ( /* missing proto */  __builtin_ia32_movnti)() ;
#line 1458 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si32)(int *__A ,
                                                                        int __B ) 
{ 


  {
  {
#line 1460
  __builtin_ia32_movnti(__A, __B);
  }
#line 1462
  return;
}
}
#line 1465
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si64)(long long *__A ,
                                                                        long long __B ) ;
#line 1467
extern int ( /* missing proto */  __builtin_ia32_movnti64)() ;
#line 1465 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si64)(long long *__A ,
                                                                        long long __B ) 
{ 


  {
  {
#line 1467
  __builtin_ia32_movnti64(__A, __B);
  }
#line 1469
  return;
}
}
#line 1472
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si128)(__m128i *__A ,
                                                                         __m128i __B ) ;
#line 1474
extern int ( /* missing proto */  __builtin_ia32_movntdq)() ;
#line 1472 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si128)(__m128i *__A ,
                                                                         __m128i __B ) 
{ 


  {
  {
#line 1474
  __builtin_ia32_movntdq(__A, __B);
  }
#line 1476
  return;
}
}
#line 1478
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pd)(double *__A ,
                                                                      __m128d __B ) ;
#line 1480
extern int ( /* missing proto */  __builtin_ia32_movntpd)() ;
#line 1478 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pd)(double *__A ,
                                                                      __m128d __B ) 
{ 


  {
  {
#line 1480
  __builtin_ia32_movntpd(__A, __B);
  }
#line 1482
  return;
}
}
#line 1484
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_clflush)(void const   *__A ) ;
#line 1486
extern int ( /* missing proto */  __builtin_ia32_clflush)() ;
#line 1484
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_clflush)(void const   *__A ) ;
#line 1484 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_clflush)(void const   *__A ) 
{ 


  {
  {
#line 1486
  __builtin_ia32_clflush(__A);
  }
#line 1488
  return;
}
}
#line 1490
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_lfence)(void) ;
#line 1492
extern int ( /* missing proto */  __builtin_ia32_lfence)() ;
#line 1490
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_lfence)(void) ;
#line 1490 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_lfence)(void) 
{ 


  {
  {
#line 1492
  __builtin_ia32_lfence();
  }
#line 1494
  return;
}
}
#line 1496
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_mfence)(void) ;
#line 1498
extern int ( /* missing proto */  __builtin_ia32_mfence)() ;
#line 1496
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_mfence)(void) ;
#line 1496 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_mfence)(void) 
{ 


  {
  {
#line 1498
  __builtin_ia32_mfence();
  }
#line 1500
  return;
}
}
#line 1502
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si128)(int __A ) ;
#line 1502 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si128)(int __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 1504
  __cil_tmp2 = _mm_set_epi32(0, 0, 0, __A);
  }
#line 1504
  return (__cil_tmp2);
}
}
#line 1510
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si128)(long long __A ) ;
#line 1510 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si128)(long long __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 1512
  __cil_tmp2 = _mm_set_epi64x(0LL, __A);
  }
#line 1512
  return (__cil_tmp2);
}
}
#line 1526
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castpd_ps)(__m128d __A ) ;
#line 1526 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castpd_ps)(__m128d __A ) 
{ 


  {
#line 1528
  return (__A);
}
}
#line 1532
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castpd_si128)(__m128d __A ) ;
#line 1532 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castpd_si128)(__m128d __A ) 
{ 


  {
#line 1534
  return (__A);
}
}
#line 1538
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castps_pd)(__m128 __A ) ;
#line 1538 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castps_pd)(__m128 __A ) 
{ 


  {
#line 1540
  return (__A);
}
}
#line 1544
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castps_si128)(__m128 __A ) ;
#line 1544 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castps_si128)(__m128 __A ) 
{ 


  {
#line 1546
  return (__A);
}
}
#line 1550
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castsi128_ps)(__m128i __A ) ;
#line 1550 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castsi128_ps)(__m128i __A ) 
{ 


  {
#line 1552
  return (__A);
}
}
#line 1556
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castsi128_pd)(__m128i __A ) ;
#line 1556 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castsi128_pd)(__m128i __A ) 
{ 


  {
#line 1558
  return (__A);
}
}
#line 1265 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_pause)(void) ;
#line 1267
extern int ( /* missing proto */  __builtin_ia32_pause)() ;
#line 1265
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_pause)(void) ;
#line 1265 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_pause)(void) 
{ 


  {
  {
#line 1267
  __builtin_ia32_pause();
  }
#line 1269
  return;
}
}
#line 55 "/root/patchweave_new/10/src/lib/openjp2/mct.c"
static OPJ_FLOAT64 opj_mct_norms[3]  = {      1.732,      0.829200000001,      0.829200000001};
#line 60 "/root/patchweave_new/10/src/lib/openjp2/mct.c"
static OPJ_FLOAT64 opj_mct_norms_real[3]  = {      1.732,      1.805,      1.573};
#line 62 "/root/patchweave_new/10/src/lib/openjp2/mct.c"
OPJ_FLOAT64 *opj_mct_get_mct_norms(void) 
{ 


  {
#line 64
  return (opj_mct_norms);
}
}
#line 67 "/root/patchweave_new/10/src/lib/openjp2/mct.c"
OPJ_FLOAT64 *opj_mct_get_mct_norms_real(void) 
{ 


  {
#line 69
  return (opj_mct_norms_real);
}
}
#line 76 "/root/patchweave_new/10/src/lib/openjp2/mct.c"
void opj_mct_encode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_UINT32 n ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_SIZE_T len ;
  __m128i y ;
  __m128i u ;
  __m128i v ;
  __m128i r ;
  __m128i __cil_tmp11 ;
  __m128i g ;
  __m128i __cil_tmp13 ;
  __m128i b ;
  __m128i __cil_tmp15 ;
  OPJ_INT32 r___0 ;
  OPJ_INT32 g___0 ;
  OPJ_INT32 b___0 ;
  OPJ_INT32 y___0 ;
  OPJ_INT32 u___0 ;
  OPJ_INT32 v___0 ;

  {
#line 83
  len = (OPJ_SIZE_T )n;
#line 85
  i = (OPJ_SIZE_T )0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;

#line 85
    if (! (i < (len & 4294967292UL))) {
#line 85
      goto while_break;
    }
    {
#line 87
    __cil_tmp11 = _mm_load_si128(c0 + i);
#line 87
    r = __cil_tmp11;
#line 88
    __cil_tmp13 = _mm_load_si128(c1 + i);
#line 88
    g = __cil_tmp13;
#line 89
    __cil_tmp15 = _mm_load_si128(c2 + i);
#line 89
    b = __cil_tmp15;
#line 90
    y = _mm_add_epi32(g, g);
#line 91
    y = _mm_add_epi32(y, b);
#line 92
    y = _mm_add_epi32(y, r);
#line 93
    y = _mm_srai_epi32(y, 2);
#line 94
    u = _mm_sub_epi32(b, g);
#line 95
    v = _mm_sub_epi32(r, g);
#line 96
    _mm_store_si128(c0 + i, y);
#line 97
    _mm_store_si128(c1 + i, u);
#line 98
    _mm_store_si128(c2 + i, v);
#line 85
    i += 4UL;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 101
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 101
    if (! (i < len)) {
#line 101
      goto while_break___0;
    }
#line 102
    r___0 = *(c0 + i);
#line 103
    g___0 = *(c1 + i);
#line 104
    b___0 = *(c2 + i);
#line 105
    y___0 = ((r___0 + g___0 * 2) + b___0) >> 2;
#line 106
    u___0 = b___0 - g___0;
#line 107
    v___0 = r___0 - g___0;
#line 108
    *(c0 + i) = y___0;
#line 109
    *(c1 + i) = u___0;
#line 110
    *(c2 + i) = v___0;
#line 101
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 105
  return;
}
}
#line 141 "/root/patchweave_new/10/src/lib/openjp2/mct.c"
void opj_mct_decode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_UINT32 n ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_SIZE_T len ;
  __m128i r ;
  __m128i g ;
  __m128i b ;
  __m128i y ;
  __m128i __cil_tmp11 ;
  __m128i u ;
  __m128i __cil_tmp13 ;
  __m128i v ;
  __m128i __cil_tmp15 ;
  __m128i __cil_tmp16 ;
  __m128i __cil_tmp17 ;
  __m128i __cil_tmp18 ;
  OPJ_INT32 y___0 ;
  OPJ_INT32 u___0 ;
  OPJ_INT32 v___0 ;
  OPJ_INT32 g___0 ;
  OPJ_INT32 r___0 ;
  OPJ_INT32 b___0 ;

  {
#line 148
  len = (OPJ_SIZE_T )n;
#line 150
  i = (OPJ_SIZE_T )0;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;

#line 150
    if (! (i < (len & 4294967292UL))) {
#line 150
      goto while_break;
    }
    {
#line 152
    __cil_tmp11 = _mm_load_si128(c0 + i);
#line 152
    y = __cil_tmp11;
#line 153
    __cil_tmp13 = _mm_load_si128(c1 + i);
#line 153
    u = __cil_tmp13;
#line 154
    __cil_tmp15 = _mm_load_si128(c2 + i);
#line 154
    v = __cil_tmp15;
#line 155
    g = y;
#line 156
    __cil_tmp16 = _mm_add_epi32(u, v);
#line 156
    __cil_tmp17 = _mm_srai_epi32(__cil_tmp16, 2);
#line 156
    __cil_tmp18 = _mm_sub_epi32(g, __cil_tmp17);
#line 156
    g = __cil_tmp18;
#line 157
    r = _mm_add_epi32(v, g);
#line 158
    b = _mm_add_epi32(u, g);
#line 159
    _mm_store_si128(c0 + i, r);
#line 160
    _mm_store_si128(c1 + i, g);
#line 161
    _mm_store_si128(c2 + i, b);
#line 150
    i += 4UL;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 163
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 163
    if (! (i < len)) {
#line 163
      goto while_break___0;
    }
#line 164
    y___0 = *(c0 + i);
#line 165
    u___0 = *(c1 + i);
#line 166
    v___0 = *(c2 + i);
#line 167
    g___0 = y___0 - ((u___0 + v___0) >> 2);
#line 168
    r___0 = v___0 + g___0;
#line 169
    b___0 = u___0 + g___0;
#line 170
    *(c0 + i) = r___0;
#line 171
    *(c1 + i) = g___0;
#line 172
    *(c2 + i) = b___0;
#line 163
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 167
  return;
}
}
#line 200 "/root/patchweave_new/10/src/lib/openjp2/mct.c"
OPJ_FLOAT64 opj_mct_getnorm(OPJ_UINT32 compno ) 
{ 


  {
#line 201
  return (opj_mct_norms[compno]);
}
}
#line 349 "/root/patchweave_new/10/src/lib/openjp2/mct.c"
void opj_mct_encode_real(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_UINT32 n ) 
{ 
  OPJ_UINT32 i ;
  OPJ_INT32 r ;
  OPJ_INT32 g ;
  OPJ_INT32 b ;
  OPJ_INT32 y ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_INT32 __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_INT32 u ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 v ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  OPJ_INT32 __cil_tmp20 ;

  {
#line 356
  i = (OPJ_UINT32 )0;
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;

#line 356
    if (! (i < n)) {
#line 356
      goto while_break;
    }
    {
#line 357
    r = *(c0 + i);
#line 358
    g = *(c1 + i);
#line 359
    b = *(c2 + i);
#line 360
    __cil_tmp12 = opj_int_fix_mul(b, 934);
#line 360
    __cil_tmp11 = opj_int_fix_mul(g, 4809);
#line 360
    __cil_tmp10 = opj_int_fix_mul(r, 2449);
#line 360
    y = (__cil_tmp10 + __cil_tmp11) + __cil_tmp12;
#line 361
    __cil_tmp16 = opj_int_fix_mul(b, 4096);
#line 361
    __cil_tmp15 = opj_int_fix_mul(g, 2714);
#line 361
    __cil_tmp14 = opj_int_fix_mul(r, 1382);
#line 361
    u = (- __cil_tmp14 - __cil_tmp15) + __cil_tmp16;
#line 362
    __cil_tmp20 = opj_int_fix_mul(b, 666);
#line 362
    __cil_tmp19 = opj_int_fix_mul(g, 3430);
#line 362
    __cil_tmp18 = opj_int_fix_mul(r, 4096);
#line 362
    v = (__cil_tmp18 - __cil_tmp19) - __cil_tmp20;
#line 363
    *(c0 + i) = y;
#line 364
    *(c1 + i) = u;
#line 365
    *(c2 + i) = v;
#line 356
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 360
  return;
}
}
#line 373 "/root/patchweave_new/10/src/lib/openjp2/mct.c"
void opj_mct_decode_real(OPJ_FLOAT32 *c0 , OPJ_FLOAT32 *c1 , OPJ_FLOAT32 *c2 , OPJ_UINT32 n ) 
{ 
  OPJ_UINT32 i ;
  __m128 vrv ;
  __m128 vgu ;
  __m128 vgv ;
  __m128 vbu ;
  __m128 vy ;
  __m128 vu ;
  __m128 vv ;
  __m128 vr ;
  __m128 vg ;
  __m128 vb ;
  __m128 __cil_tmp23 ;
  __m128 __cil_tmp24 ;
  __m128 __cil_tmp25 ;
  __m128 __cil_tmp26 ;
  __m128 __cil_tmp27 ;
  __m128 __cil_tmp28 ;
  __m128 __cil_tmp29 ;
  __m128 __cil_tmp30 ;
  __m128 __cil_tmp34 ;
  __m128 __cil_tmp35 ;
  __m128 __cil_tmp36 ;
  __m128 __cil_tmp37 ;
  __m128 __cil_tmp38 ;
  __m128 __cil_tmp39 ;
  __m128 __cil_tmp40 ;
  __m128 __cil_tmp41 ;
  OPJ_FLOAT32 y ;
  OPJ_FLOAT32 u ;
  OPJ_FLOAT32 v ;
  OPJ_FLOAT32 r ;
  OPJ_FLOAT32 g ;
  OPJ_FLOAT32 b ;

  {
  {
#line 382
  vrv = _mm_set_ss(1.40199995041f);
#line 383
  vgu = _mm_set_ss(0.344130009413f);
#line 384
  vgv = _mm_set_ss(0.71413999796f);
#line 385
  vbu = _mm_set_ss(1.77199995518f);
#line 386
  i = (OPJ_UINT32 )0;
  }
  {
#line 386
  while (1) {
    while_continue: /* CIL Label */ ;

#line 386
    if (! (i < n >> 3)) {
#line 386
      goto while_break;
    }
    {
#line 390
    vy = _mm_load_ps((float const   *)c0);
#line 391
    vu = _mm_load_ps((float const   *)c1);
#line 392
    vv = _mm_load_ps((float const   *)c2);
#line 393
    __cil_tmp23 = _mm_mul_ps(vv, vrv);
#line 393
    __cil_tmp24 = _mm_add_ps(vy, __cil_tmp23);
#line 393
    vr = __cil_tmp24;
#line 394
    __cil_tmp25 = _mm_mul_ps(vu, vgu);
#line 394
    __cil_tmp26 = _mm_sub_ps(vy, __cil_tmp25);
#line 394
    __cil_tmp27 = _mm_mul_ps(vv, vgv);
#line 394
    __cil_tmp28 = _mm_sub_ps(__cil_tmp26, __cil_tmp27);
#line 394
    vg = __cil_tmp28;
#line 395
    __cil_tmp29 = _mm_mul_ps(vu, vbu);
#line 395
    __cil_tmp30 = _mm_add_ps(vy, __cil_tmp29);
#line 395
    vb = __cil_tmp30;
#line 396
    _mm_store_ps(c0, vr);
#line 397
    _mm_store_ps(c1, vg);
#line 398
    _mm_store_ps(c2, vb);
#line 399
    c0 += 4;
#line 400
    c1 += 4;
#line 401
    c2 += 4;
#line 403
    vy = _mm_load_ps((float const   *)c0);
#line 404
    vu = _mm_load_ps((float const   *)c1);
#line 405
    vv = _mm_load_ps((float const   *)c2);
#line 406
    __cil_tmp34 = _mm_mul_ps(vv, vrv);
#line 406
    __cil_tmp35 = _mm_add_ps(vy, __cil_tmp34);
#line 406
    vr = __cil_tmp35;
#line 407
    __cil_tmp36 = _mm_mul_ps(vu, vgu);
#line 407
    __cil_tmp37 = _mm_sub_ps(vy, __cil_tmp36);
#line 407
    __cil_tmp38 = _mm_mul_ps(vv, vgv);
#line 407
    __cil_tmp39 = _mm_sub_ps(__cil_tmp37, __cil_tmp38);
#line 407
    vg = __cil_tmp39;
#line 408
    __cil_tmp40 = _mm_mul_ps(vu, vbu);
#line 408
    __cil_tmp41 = _mm_add_ps(vy, __cil_tmp40);
#line 408
    vb = __cil_tmp41;
#line 409
    _mm_store_ps(c0, vr);
#line 410
    _mm_store_ps(c1, vg);
#line 411
    _mm_store_ps(c2, vb);
#line 412
    c0 += 4;
#line 413
    c1 += 4;
#line 414
    c2 += 4;
#line 386
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 416
  n &= 7U;
#line 418
  i = (OPJ_UINT32 )0;
  {
#line 418
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 418
    if (! (i < n)) {
#line 418
      goto while_break___0;
    }
#line 419
    y = *(c0 + i);
#line 420
    u = *(c1 + i);
#line 421
    v = *(c2 + i);
#line 422
    r = y + v * 1.40199995041f;
#line 423
    g = (y - u * 0.344130009413f) - v * 0.71413999796f;
#line 424
    b = y + u * 1.77199995518f;
#line 425
    *(c0 + i) = r;
#line 426
    *(c1 + i) = g;
#line 427
    *(c2 + i) = b;
#line 418
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 422
  return;
}
}
#line 434 "/root/patchweave_new/10/src/lib/openjp2/mct.c"
OPJ_FLOAT64 opj_mct_getnorm_real(OPJ_UINT32 compno ) 
{ 


  {
#line 435
  return (opj_mct_norms_real[compno]);
}
}
#line 439 "/root/patchweave_new/10/src/lib/openjp2/mct.c"
OPJ_BOOL opj_mct_encode_custom(OPJ_BYTE *pCodingdata , OPJ_UINT32 n , OPJ_BYTE **pData ,
                               OPJ_UINT32 pNbComp , OPJ_UINT32 isSigned ) 
{ 
  OPJ_FLOAT32 *lMct ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 lNbMatCoeff ;
  OPJ_INT32 *lCurrentData ;
  OPJ_INT32 *lCurrentMatrix ;
  OPJ_INT32 **lData ;
  OPJ_UINT32 lMultiplicator ;
  OPJ_INT32 *lMctPtr ;
  void *__cil_tmp16 ;
  OPJ_FLOAT32 *__cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;

  {
  {
#line 446
  lMct = (OPJ_FLOAT32 *)pCodingdata;
#line 450
  lNbMatCoeff = pNbComp * pNbComp;
#line 451
  lCurrentData = (OPJ_INT32 *)0;
#line 452
  lCurrentMatrix = (OPJ_INT32 *)0;
#line 453
  lData = (OPJ_INT32 **)pData;
#line 454
  lMultiplicator = (OPJ_UINT32 )(1 << 13);
#line 459
  __cil_tmp16 = malloc((unsigned long )(pNbComp + lNbMatCoeff) * sizeof(OPJ_INT32 ));
#line 459
  lCurrentData = (OPJ_INT32 *)__cil_tmp16;
  }
#line 460
  if (! lCurrentData) {
#line 461
    return (0);
  }
#line 464
  lCurrentMatrix = lCurrentData + pNbComp;
#line 466
  i = (OPJ_UINT32 )0;
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;

#line 466
    if (! (i < lNbMatCoeff)) {
#line 466
      goto while_break;
    }
#line 467
    __cil_tmp17 = lMct;
#line 467
    lMct ++;
#line 467
    *(lCurrentMatrix + i) = (OPJ_INT32 )(*__cil_tmp17 * (OPJ_FLOAT32 )lMultiplicator);
#line 466
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 470
  i = (OPJ_UINT32 )0;
  {
#line 470
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 470
    if (! (i < n)) {
#line 470
      goto while_break___0;
    }
#line 471
    lMctPtr = lCurrentMatrix;
#line 472
    j = (OPJ_UINT32 )0;
    {
#line 472
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 472
      if (! (j < pNbComp)) {
#line 472
        goto while_break___1;
      }
#line 473
      *(lCurrentData + j) = *(*(lData + j));
#line 472
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: 
#line 476
    j = (OPJ_UINT32 )0;
    {
#line 476
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 476
      if (! (j < pNbComp)) {
#line 476
        goto while_break___2;
      }
#line 477
      *(*(lData + j)) = 0;
#line 478
      k = (OPJ_UINT32 )0;
      {
#line 478
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 478
        if (! (k < pNbComp)) {
#line 478
          goto while_break___3;
        }
        {
#line 479
        __cil_tmp18 = opj_int_fix_mul(*lMctPtr, *(lCurrentData + k));
#line 479
        *(*(lData + j)) += __cil_tmp18;
#line 480
        lMctPtr ++;
#line 478
        k ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 483
      (*(lData + j)) ++;
#line 476
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 470
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 487
  free((void *)lCurrentData);
  }
#line 489
  return (1);
}
}
#line 492 "/root/patchweave_new/10/src/lib/openjp2/mct.c"
OPJ_BOOL opj_mct_decode_custom(OPJ_BYTE *pDecodingData , OPJ_UINT32 n , OPJ_BYTE **pData ,
                               OPJ_UINT32 pNbComp , OPJ_UINT32 isSigned ) 
{ 
  OPJ_FLOAT32 *lMct ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_FLOAT32 *lCurrentData ;
  OPJ_FLOAT32 *lCurrentResult ;
  OPJ_FLOAT32 **lData ;
  void *__cil_tmp13 ;
  OPJ_FLOAT32 *__cil_tmp14 ;
  OPJ_FLOAT32 *__cil_tmp15 ;

  {
  {
#line 504
  lCurrentData = (OPJ_FLOAT32 *)0;
#line 505
  lCurrentResult = (OPJ_FLOAT32 *)0;
#line 506
  lData = (OPJ_FLOAT32 **)pData;
#line 510
  __cil_tmp13 = malloc((unsigned long )(2U * pNbComp) * sizeof(OPJ_FLOAT32 ));
#line 510
  lCurrentData = (OPJ_FLOAT32 *)__cil_tmp13;
  }
#line 511
  if (! lCurrentData) {
#line 512
    return (0);
  }
#line 514
  lCurrentResult = lCurrentData + pNbComp;
#line 516
  i = (OPJ_UINT32 )0;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;

#line 516
    if (! (i < n)) {
#line 516
      goto while_break;
    }
#line 517
    lMct = (OPJ_FLOAT32 *)pDecodingData;
#line 518
    j = (OPJ_UINT32 )0;
    {
#line 518
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 518
      if (! (j < pNbComp)) {
#line 518
        goto while_break___0;
      }
#line 519
      *(lCurrentData + j) = *(*(lData + j));
#line 518
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 521
    j = (OPJ_UINT32 )0;
    {
#line 521
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 521
      if (! (j < pNbComp)) {
#line 521
        goto while_break___1;
      }
#line 522
      *(lCurrentResult + j) = (OPJ_FLOAT32 )0;
#line 523
      k = (OPJ_UINT32 )0;
      {
#line 523
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 523
        if (! (k < pNbComp)) {
#line 523
          goto while_break___2;
        }
#line 524
        __cil_tmp14 = lMct;
#line 524
        lMct ++;
#line 524
        *(lCurrentResult + j) += *__cil_tmp14 * *(lCurrentData + k);
#line 523
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 526
      __cil_tmp15 = *(lData + j);
#line 526
      (*(lData + j)) ++;
#line 526
      *__cil_tmp15 = *(lCurrentResult + j);
#line 521
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 516
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 529
  free((void *)lCurrentData);
  }
#line 530
  return (1);
}
}
#line 533 "/root/patchweave_new/10/src/lib/openjp2/mct.c"
void opj_calculate_norms(OPJ_FLOAT64 *pNorms , OPJ_UINT32 pNbComps , OPJ_FLOAT32 *pMatrix ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 lIndex ;
  OPJ_FLOAT32 lCurrentValue ;
  OPJ_FLOAT64 *lNorms ;
  OPJ_FLOAT32 *lMatrix ;

  {
#line 539
  lNorms = pNorms;
#line 540
  lMatrix = pMatrix;
#line 542
  i = (OPJ_UINT32 )0;
  {
#line 542
  while (1) {
    while_continue: /* CIL Label */ ;

#line 542
    if (! (i < pNbComps)) {
#line 542
      goto while_break;
    }
#line 543
    *(lNorms + i) = (OPJ_FLOAT64 )0;
#line 544
    lIndex = i;
#line 546
    j = (OPJ_UINT32 )0;
    {
#line 546
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 546
      if (! (j < pNbComps)) {
#line 546
        goto while_break___0;
      }
#line 547
      lCurrentValue = *(lMatrix + lIndex);
#line 548
      lIndex += pNbComps;
#line 549
      *(lNorms + i) += (double )(lCurrentValue * lCurrentValue);
#line 546
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 551
    *(lNorms + i) = sqrt(*(lNorms + i));
#line 542
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 546
  return;
}
}
#line 62 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_ihdr(opj_jp2_t *jp2 , OPJ_BYTE *p_image_header_data , OPJ_UINT32 p_image_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 75
OPJ_BYTE *opj_jp2_write_ihdr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 86
OPJ_BYTE *opj_jp2_write_bpcc(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 99
OPJ_BOOL opj_jp2_read_bpcc(opj_jp2_t *jp2 , OPJ_BYTE *p_bpc_header_data , OPJ_UINT32 p_bpc_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 104
OPJ_BOOL opj_jp2_read_cdef(opj_jp2_t *jp2 , OPJ_BYTE *p_cdef_header_data , OPJ_UINT32 p_cdef_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 109
void opj_jp2_apply_cdef(opj_image_t *image , opj_jp2_color_t *color ) ;
#line 119
static OPJ_BYTE *opj_jp2_write_cdef(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 130
OPJ_BYTE *opj_jp2_write_colr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 142
OPJ_BOOL opj_jp2_write_ftyp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 156
static OPJ_BOOL opj_jp2_read_ftyp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) ;
#line 161
OPJ_BOOL opj_jp2_skip_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 175
static OPJ_BOOL opj_jp2_read_jp2h(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) ;
#line 189
OPJ_BOOL opj_jp2_write_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 235
static OPJ_BOOL opj_jp2_read_jp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                opj_event_mgr_t *p_manager ) ;
#line 249
OPJ_BOOL opj_jp2_write_jp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 258
void opj_jp2_apply_pclr(opj_image_t *image , opj_jp2_color_t *color ) ;
#line 260
void opj_jp2_free_pclr(opj_jp2_color_t *color ) ;
#line 272
OPJ_BOOL opj_jp2_read_pclr(opj_jp2_t *jp2 , OPJ_BYTE *p_pclr_header_data , OPJ_UINT32 p_pclr_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 288
OPJ_BOOL opj_jp2_read_cmap(opj_jp2_t *jp2 , OPJ_BYTE *p_cmap_header_data , OPJ_UINT32 p_cmap_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 303
OPJ_BOOL opj_jp2_read_colr(opj_jp2_t *jp2 , OPJ_BYTE *p_colr_header_data , OPJ_UINT32 p_colr_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 316
void opj_jp2_setup_end_header_writing(opj_jp2_t *jp2 ) ;
#line 322
void opj_jp2_setup_end_header_reading(opj_jp2_t *jp2 ) ;
#line 333
OPJ_BOOL opj_jp2_read_header_procedure(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                       opj_event_mgr_t *p_manager ) ;
#line 347
static OPJ_BOOL opj_jp2_exec(opj_jp2_t *jp2 , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 362
OPJ_BOOL opj_jp2_read_boxhdr(opj_jp2_box_t *box , OPJ_UINT32 *p_number_bytes_read ,
                             opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 371
void opj_jp2_setup_encoding_validation(opj_jp2_t *jp2 ) ;
#line 376
void opj_jp2_setup_header_writing(opj_jp2_t *jp2 ) ;
#line 378
OPJ_BOOL opj_jp2_default_validation(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 389
static opj_jp2_header_handler_t *opj_jp2_img_find_handler(OPJ_UINT32 p_id ) ;
#line 398
opj_jp2_header_handler_t *opj_jp2_find_handler(OPJ_UINT32 p_id ) ;
#line 400 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
opj_jp2_header_handler_t jp2_header[3]  = {      {(OPJ_UINT32 )1783636000, & opj_jp2_read_jp}, 
        {(OPJ_UINT32 )1718909296, & opj_jp2_read_ftyp}, 
        {(OPJ_UINT32 )1785737832, & opj_jp2_read_jp2h}};
#line 407 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
opj_jp2_header_handler_t jp2_img_header[6]  = {      {(OPJ_UINT32 )1768449138, & opj_jp2_read_ihdr}, 
        {(OPJ_UINT32 )1668246642, & opj_jp2_read_colr}, 
        {(OPJ_UINT32 )1651532643, & opj_jp2_read_bpcc}, 
        {(OPJ_UINT32 )1885564018, & opj_jp2_read_pclr}, 
        {(OPJ_UINT32 )1668112752, & opj_jp2_read_cmap}, 
        {(OPJ_UINT32 )1667523942, & opj_jp2_read_cdef}};
#line 429
OPJ_BOOL opj_jp2_read_boxhdr_char(opj_jp2_box_t *box , OPJ_BYTE *p_data , OPJ_UINT32 *p_number_bytes_read ,
                                  OPJ_UINT32 p_box_max_size , opj_event_mgr_t *p_manager ) ;
#line 439
void opj_jp2_setup_decoding_validation(opj_jp2_t *jp2 ) ;
#line 445
void opj_jp2_setup_header_reading(opj_jp2_t *jp2 ) ;
#line 448 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_boxhdr(opj_jp2_box_t *box , OPJ_UINT32 *p_number_bytes_read ,
                             opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_data_header[8] ;
  OPJ_SIZE_T __cil_tmp10 ;
  OPJ_OFF_T bleft ;
  OPJ_OFF_T __cil_tmp12 ;
  OPJ_UINT32 l_xl_part_size ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
  {
#line 462
  __cil_tmp10 = opj_stream_read_data(cio, l_data_header, (OPJ_SIZE_T )8, p_manager);
#line 462
  *p_number_bytes_read = (OPJ_UINT32 )__cil_tmp10;
  }
#line 463
  if (*p_number_bytes_read != 8U) {
#line 464
    return (0);
  }
  {
#line 468
  opj_read_bytes_LE(l_data_header, & box->length, (OPJ_UINT32 )4);
#line 469
  opj_read_bytes_LE(l_data_header + 4, & box->type, (OPJ_UINT32 )4);
  }
#line 471
  if (box->length == 0U) {
    {
#line 473
    __cil_tmp12 = opj_stream_get_number_byte_left(cio);
#line 473
    bleft = __cil_tmp12;
#line 474
    box->length = (OPJ_UINT32 )bleft;
    }
#line 476
    return (1);
  }
#line 481
  if (box->length == 1U) {
    {
#line 484
    __cil_tmp16 = opj_stream_read_data(cio, l_data_header, (OPJ_SIZE_T )8, p_manager);
#line 484
    l_nb_bytes_read = (OPJ_UINT32 )__cil_tmp16;
    }
#line 485
    if (l_nb_bytes_read != 8U) {
#line 486
      if (l_nb_bytes_read > 0U) {
#line 487
        *p_number_bytes_read += l_nb_bytes_read;
      }
#line 490
      return (0);
    }
    {
#line 493
    *p_number_bytes_read = (OPJ_UINT32 )16;
#line 494
    opj_read_bytes_LE(l_data_header, & l_xl_part_size, (OPJ_UINT32 )4);
    }
#line 495
    if (l_xl_part_size != 0U) {
      {
#line 496
      opj_event_msg(p_manager, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 497
      return (0);
    }
    {
#line 499
    opj_read_bytes_LE(l_data_header + 4, & box->length, (OPJ_UINT32 )4);
    }
  }
#line 501
  return (1);
}
}
#line 528 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_ihdr(opj_jp2_t *jp2 , OPJ_BYTE *p_image_header_data , OPJ_UINT32 p_image_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  void *__cil_tmp8 ;

  {
#line 538
  if (p_image_header_size != 14U) {
    {
#line 539
    opj_event_msg(p_manager, 1, "Bad image header box (bad size)\n\220");
    }
#line 540
    return (0);
  }
  {
#line 543
  opj_read_bytes_LE(p_image_header_data, & jp2->h, (OPJ_UINT32 )4);
#line 544
  p_image_header_data += 4;
#line 545
  opj_read_bytes_LE(p_image_header_data, & jp2->w, (OPJ_UINT32 )4);
#line 546
  p_image_header_data += 4;
#line 547
  opj_read_bytes_LE(p_image_header_data, & jp2->numcomps, (OPJ_UINT32 )2);
#line 548
  p_image_header_data += 2;
#line 551
  __cil_tmp8 = calloc((unsigned long )jp2->numcomps, sizeof(opj_jp2_comps_t ));
#line 551
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp8;
  }
#line 552
  if ((unsigned long )jp2->comps == (unsigned long )((opj_jp2_comps_t *)0)) {
    {
#line 553
    opj_event_msg(p_manager, 1, "Not enough memory to handle image header (ihdr)\n\220");
    }
#line 554
    return (0);
  }
  {
#line 557
  opj_read_bytes_LE(p_image_header_data, & jp2->bpc, (OPJ_UINT32 )1);
#line 558
  p_image_header_data ++;
#line 560
  opj_read_bytes_LE(p_image_header_data, & jp2->C, (OPJ_UINT32 )1);
#line 561
  p_image_header_data ++;
  }
#line 564
  if (jp2->C != 7U) {
    {
#line 565
    opj_event_msg(p_manager, 4, "JP2 IHDR box: compression type indicate that the file is not a conforming JP2 file (%d) \n13kEV",
                  jp2->C);
    }
  }
  {
#line 568
  opj_read_bytes_LE(p_image_header_data, & jp2->UnkC, (OPJ_UINT32 )1);
#line 569
  p_image_header_data ++;
#line 570
  opj_read_bytes_LE(p_image_header_data, & jp2->IPR, (OPJ_UINT32 )1);
#line 571
  p_image_header_data ++;
  }
#line 573
  return (1);
}
}
#line 576 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BYTE *opj_jp2_write_ihdr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_BYTE *l_ihdr_data ;
  OPJ_BYTE *l_current_ihdr_ptr ;
  void *__cil_tmp7 ;

  {
  {
#line 587
  __cil_tmp7 = calloc(1UL, 22UL);
#line 587
  l_ihdr_data = (OPJ_BYTE *)__cil_tmp7;
  }
#line 588
  if ((unsigned long )l_ihdr_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 589
    return ((OPJ_BYTE *)0);
  }
  {
#line 592
  l_current_ihdr_ptr = l_ihdr_data;
#line 594
  opj_write_bytes_LE(l_current_ihdr_ptr, (OPJ_UINT32 )22, (OPJ_UINT32 )4);
#line 595
  l_current_ihdr_ptr += 4;
#line 597
  opj_write_bytes_LE(l_current_ihdr_ptr, (OPJ_UINT32 )1768449138, (OPJ_UINT32 )4);
#line 598
  l_current_ihdr_ptr += 4;
#line 600
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->h, (OPJ_UINT32 )4);
#line 601
  l_current_ihdr_ptr += 4;
#line 603
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->w, (OPJ_UINT32 )4);
#line 604
  l_current_ihdr_ptr += 4;
#line 606
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->numcomps, (OPJ_UINT32 )2);
#line 607
  l_current_ihdr_ptr += 2;
#line 609
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->bpc, (OPJ_UINT32 )1);
#line 610
  l_current_ihdr_ptr ++;
#line 612
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->C, (OPJ_UINT32 )1);
#line 613
  l_current_ihdr_ptr ++;
#line 615
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->UnkC, (OPJ_UINT32 )1);
#line 616
  l_current_ihdr_ptr ++;
#line 618
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->IPR, (OPJ_UINT32 )1);
#line 619
  l_current_ihdr_ptr ++;
#line 621
  *p_nb_bytes_written = (OPJ_UINT32 )22;
  }
#line 623
  return (l_ihdr_data);
}
}
#line 626 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BYTE *opj_jp2_write_bpcc(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_bpcc_size ;
  OPJ_BYTE *l_bpcc_data ;
  OPJ_BYTE *l_current_bpcc_ptr ;
  void *__cil_tmp9 ;

  {
  {
#line 632
  l_bpcc_size = 8U + jp2->numcomps;
#line 639
  __cil_tmp9 = calloc(1UL, (unsigned long )l_bpcc_size);
#line 639
  l_bpcc_data = (OPJ_BYTE *)__cil_tmp9;
  }
#line 640
  if ((unsigned long )l_bpcc_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 641
    return ((OPJ_BYTE *)0);
  }
  {
#line 644
  l_current_bpcc_ptr = l_bpcc_data;
#line 646
  opj_write_bytes_LE(l_current_bpcc_ptr, l_bpcc_size, (OPJ_UINT32 )4);
#line 647
  l_current_bpcc_ptr += 4;
#line 649
  opj_write_bytes_LE(l_current_bpcc_ptr, (OPJ_UINT32 )1651532643, (OPJ_UINT32 )4);
#line 650
  l_current_bpcc_ptr += 4;
#line 652
  i = (OPJ_UINT32 )0;
  }
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;

#line 652
    if (! (i < jp2->numcomps)) {
#line 652
      goto while_break;
    }
    {
#line 653
    opj_write_bytes_LE(l_current_bpcc_ptr, (jp2->comps + i)->bpcc, (OPJ_UINT32 )1);
#line 654
    l_current_bpcc_ptr ++;
#line 652
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 657
  *p_nb_bytes_written = l_bpcc_size;
#line 659
  return (l_bpcc_data);
}
}
#line 662 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_bpcc(opj_jp2_t *jp2 , OPJ_BYTE *p_bpc_header_data , OPJ_UINT32 p_bpc_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;

  {
#line 676
  if (jp2->bpc != 255U) {
    {
#line 677
    opj_event_msg(p_manager, 2, "A BPCC header box is available although BPC given by the IHDR box (%d) indicate components bit depth is constant\n",
                  jp2->bpc);
    }
  }
#line 681
  if (p_bpc_header_size != jp2->numcomps) {
    {
#line 682
    opj_event_msg(p_manager, 1, "Bad BPCC header box (bad size)\n");
    }
#line 683
    return (0);
  }
#line 687
  i = (OPJ_UINT32 )0;
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;

#line 687
    if (! (i < jp2->numcomps)) {
#line 687
      goto while_break;
    }
    {
#line 688
    opj_read_bytes_LE(p_bpc_header_data, & (jp2->comps + i)->bpcc, (OPJ_UINT32 )1);
#line 689
    p_bpc_header_data ++;
#line 687
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 692
  return (1);
}
}
#line 694 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
static OPJ_BYTE *opj_jp2_write_cdef(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_UINT32 l_cdef_size ;
  OPJ_BYTE *l_cdef_data ;
  OPJ_BYTE *l_current_cdef_ptr ;
  OPJ_UINT32 l_value ;
  OPJ_UINT16 i ;
  void *__cil_tmp13 ;

  {
  {
#line 697
  l_cdef_size = (OPJ_UINT32 )10;
#line 709
  l_cdef_size += 6U * (unsigned int )(jp2->color.jp2_cdef)->n;
#line 711
  __cil_tmp13 = malloc((unsigned long )l_cdef_size);
#line 711
  l_cdef_data = (OPJ_BYTE *)__cil_tmp13;
  }
#line 712
  if ((unsigned long )l_cdef_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 713
    return ((OPJ_BYTE *)0);
  }
  {
#line 716
  l_current_cdef_ptr = l_cdef_data;
#line 718
  opj_write_bytes_LE(l_current_cdef_ptr, l_cdef_size, (OPJ_UINT32 )4);
#line 719
  l_current_cdef_ptr += 4;
#line 721
  opj_write_bytes_LE(l_current_cdef_ptr, (OPJ_UINT32 )1667523942, (OPJ_UINT32 )4);
#line 722
  l_current_cdef_ptr += 4;
#line 724
  l_value = (OPJ_UINT32 )(jp2->color.jp2_cdef)->n;
#line 725
  opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 726
  l_current_cdef_ptr += 2;
#line 728
  i = (OPJ_UINT16 )0U;
  }
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;

#line 728
    if (! ((int )i < (int )(jp2->color.jp2_cdef)->n)) {
#line 728
      goto while_break;
    }
    {
#line 729
    l_value = (OPJ_UINT32 )((jp2->color.jp2_cdef)->info + (int )i)->cn;
#line 730
    opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 731
    l_current_cdef_ptr += 2;
#line 732
    l_value = (OPJ_UINT32 )((jp2->color.jp2_cdef)->info + (int )i)->typ;
#line 733
    opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 734
    l_current_cdef_ptr += 2;
#line 735
    l_value = (OPJ_UINT32 )((jp2->color.jp2_cdef)->info + (int )i)->asoc;
#line 736
    opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 737
    l_current_cdef_ptr += 2;
#line 728
    i = (OPJ_UINT16 )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 739
  *p_nb_bytes_written = l_cdef_size;
#line 741
  return (l_cdef_data);
}
}
#line 744 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BYTE *opj_jp2_write_colr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_UINT32 l_colr_size ;
  OPJ_BYTE *l_colr_data ;
  OPJ_BYTE *l_current_colr_ptr ;
  void *__cil_tmp10 ;
  OPJ_UINT32 i ;

  {
#line 749
  l_colr_size = (OPJ_UINT32 )11;
#line 758
  if (jp2->meth == 1U) {
#line 758
    goto case_1;
  }
#line 765
  goto switch_default;
  case_1: 
#line 759
  l_colr_size += 4U;
#line 760
  goto switch_break;
#line 763
  l_colr_size += jp2->color.icc_profile_len;
#line 764
  goto switch_break;
  switch_default: 
#line 766
  return ((OPJ_BYTE *)0);
  switch_break: 
  {
#line 769
  __cil_tmp10 = calloc(1UL, (unsigned long )l_colr_size);
#line 769
  l_colr_data = (OPJ_BYTE *)__cil_tmp10;
  }
#line 770
  if ((unsigned long )l_colr_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 771
    return ((OPJ_BYTE *)0);
  }
  {
#line 774
  l_current_colr_ptr = l_colr_data;
#line 776
  opj_write_bytes_LE(l_current_colr_ptr, l_colr_size, (OPJ_UINT32 )4);
#line 777
  l_current_colr_ptr += 4;
#line 779
  opj_write_bytes_LE(l_current_colr_ptr, (OPJ_UINT32 )1668246642, (OPJ_UINT32 )4);
#line 780
  l_current_colr_ptr += 4;
#line 782
  opj_write_bytes_LE(l_current_colr_ptr, jp2->meth, (OPJ_UINT32 )1);
#line 783
  l_current_colr_ptr ++;
#line 785
  opj_write_bytes_LE(l_current_colr_ptr, jp2->precedence, (OPJ_UINT32 )1);
#line 786
  l_current_colr_ptr ++;
#line 788
  opj_write_bytes_LE(l_current_colr_ptr, jp2->approx, (OPJ_UINT32 )1);
#line 789
  l_current_colr_ptr ++;
  }
#line 791
  if (jp2->meth == 1U) {
    {
#line 792
    opj_write_bytes_LE(l_current_colr_ptr, jp2->enumcs, (OPJ_UINT32 )4);
    }
  } else
#line 794
  if (jp2->meth == 2U) {
#line 796
    i = (OPJ_UINT32 )0;
    {
#line 796
    while (1) {
      while_continue: /* CIL Label */ ;

#line 796
      if (! (i < jp2->color.icc_profile_len)) {
#line 796
        goto while_break;
      }
      {
#line 797
      opj_write_bytes_LE(l_current_colr_ptr, (OPJ_UINT32 )*(jp2->color.icc_profile_buf + i),
                         (OPJ_UINT32 )1);
#line 798
      l_current_colr_ptr ++;
#line 796
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 803
  *p_nb_bytes_written = l_colr_size;
#line 805
  return (l_colr_data);
}
}
#line 808 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
void opj_jp2_free_pclr(opj_jp2_color_t *color ) 
{ 


  {
  {
#line 810
  free((void *)(color->jp2_pclr)->channel_sign);
#line 811
  free((void *)(color->jp2_pclr)->channel_size);
#line 812
  free((void *)(color->jp2_pclr)->entries);
  }
#line 814
  if ((color->jp2_pclr)->cmap) {
    {
#line 814
    free((void *)(color->jp2_pclr)->cmap);
    }
  }
  {
#line 816
  free((void *)color->jp2_pclr);
#line 816
  color->jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
  }
#line 818
  return;
}
}
#line 819 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_check_color(opj_image_t *image , opj_jp2_color_t *color ,
                                    opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT16 i ;
  opj_jp2_cdef_info_t *info ;
  OPJ_UINT16 n ;
  OPJ_UINT32 nr_channels ;
  OPJ_UINT16 nr_channels___0 ;
  opj_jp2_cmap_comp_t *cmap ;
  OPJ_BOOL *pcol_usage ;
  OPJ_BOOL is_sane ;
  OPJ_UINT16 pcol ;
  void *tmp___0 ;

  {
#line 824
  if (color->jp2_cdef) {
#line 825
    info = (color->jp2_cdef)->info;
#line 826
    n = (color->jp2_cdef)->n;
#line 827
    nr_channels = image->numcomps;
#line 830
    if (color->jp2_pclr) {
#line 830
      if ((color->jp2_pclr)->cmap) {
#line 831
        nr_channels = (OPJ_UINT32 )(color->jp2_pclr)->nr_channels;
      }
    }
#line 834
    i = (OPJ_UINT16 )0;
    {
#line 834
    while (1) {
      while_continue: /* CIL Label */ ;

#line 834
      if (! ((int )i < (int )n)) {
#line 834
        goto while_break;
      }
#line 835
      if ((unsigned int )(info + (int )i)->cn >= nr_channels) {
        {
#line 836
        opj_event_msg(p_manager, 1, "Invalid component index %d (>= %d).\nEV", (int )(info + (int )i)->cn,
                      nr_channels);
        }
#line 837
        return (0);
      }
#line 839
      if ((int )(info + (int )i)->asoc > 0) {
#line 839
        if ((OPJ_UINT32 )((int )(info + (int )i)->asoc - 1) >= nr_channels) {
          {
#line 840
          opj_event_msg(p_manager, 1, "Invalid component index %d (>= %d).\n", (int )(info + (int )i)->asoc - 1,
                        nr_channels);
          }
#line 841
          return (0);
        }
      }
#line 834
      i = (OPJ_UINT16 )((int )i + 1);
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: ;
    {
#line 847
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 847
      if (! (nr_channels > 0U)) {
#line 847
        goto while_break___0;
      }
#line 849
      i = (OPJ_UINT16 )0;
      {
#line 849
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 849
        if (! ((int )i < (int )n)) {
#line 849
          goto while_break___1;
        }
#line 850
        if ((OPJ_UINT32 )(info + (int )i)->cn == nr_channels - 1U) {
#line 851
          goto while_break___1;
        }
#line 849
        i = (OPJ_UINT16 )((int )i + 1);
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: ;
#line 854
      if ((int )i == (int )n) {
        {
#line 855
        opj_event_msg(p_manager, 1, "Incomplete channel definitions.\n\220");
        }
#line 856
        return (0);
      }
#line 858
      nr_channels --;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 864
  if (color->jp2_pclr) {
#line 864
    if ((color->jp2_pclr)->cmap) {
#line 865
      nr_channels___0 = (OPJ_UINT16 )(color->jp2_pclr)->nr_channels;
#line 866
      cmap = (color->jp2_pclr)->cmap;
#line 867
      is_sane = 1;
#line 870
      i = (OPJ_UINT16 )0;
      {
#line 870
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 870
        if (! ((int )i < (int )nr_channels___0)) {
#line 870
          goto while_break___2;
        }
#line 871
        if ((unsigned int )(cmap + (int )i)->cmp >= image->numcomps) {
          {
#line 872
          opj_event_msg(p_manager, 1, "Invalid component index %d (>= %d).\nEV", (int )(cmap + (int )i)->cmp,
                        image->numcomps);
#line 873
          is_sane = 0;
          }
        }
#line 870
        i = (OPJ_UINT16 )((int )i + 1);
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: 
      {
#line 877
      tmp___0 = calloc((unsigned long )nr_channels___0, sizeof(OPJ_BOOL ));
#line 877
      pcol_usage = (OPJ_BOOL *)tmp___0;
      }
#line 878
      if (! pcol_usage) {
        {
#line 879
        opj_event_msg(p_manager, 1, "Unexpected OOM.\n\220");
        }
#line 880
        return (0);
      }
#line 883
      i = (OPJ_UINT16 )0;
      {
#line 883
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 883
        if (! ((int )i < (int )nr_channels___0)) {
#line 883
          goto while_break___3;
        }
#line 884
        pcol = (OPJ_UINT16 )(cmap + (int )i)->pcol;
#line 886
        if ((int )pcol >= (int )nr_channels___0) {
          {
#line 887
          opj_event_msg(p_manager, 1, "Invalid component/palette index for direct mapping %d.\n",
                        (int )pcol);
#line 888
          is_sane = 0;
          }
        } else
#line 890
        if (*(pcol_usage + (int )pcol)) {
#line 890
          if ((int )(cmap + (int )i)->mtyp == 1) {
            {
#line 891
            opj_event_msg(p_manager, 1, "Component %d is mapped twice.\n", (int )pcol);
#line 892
            is_sane = 0;
            }
          } else {
#line 890
            goto _L;
          }
        } else
        _L: 
#line 894
        if ((int )(cmap + (int )i)->mtyp == 0) {
#line 894
          if ((int )(cmap + (int )i)->pcol != 0) {
            {
#line 897
            opj_event_msg(p_manager, 1, "Direct use at #%d however pcol=%d.\nkEV",
                          (int )i, (int )pcol);
#line 898
            is_sane = 0;
            }
          } else {
#line 901
            *(pcol_usage + (int )pcol) = 1;
          }
        } else {
#line 901
          *(pcol_usage + (int )pcol) = 1;
        }
#line 883
        i = (OPJ_UINT16 )((int )i + 1);
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: 
#line 904
      i = (OPJ_UINT16 )0;
      {
#line 904
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 904
        if (! ((int )i < (int )nr_channels___0)) {
#line 904
          goto while_break___4;
        }
#line 905
        if (! *(pcol_usage + (int )i)) {
#line 905
          if ((int )(cmap + (int )i)->mtyp != 0) {
            {
#line 906
            opj_event_msg(p_manager, 1, "Component %d doesn\'t have a mapping.\n",
                          (int )i);
#line 907
            is_sane = 0;
            }
          }
        }
#line 904
        i = (OPJ_UINT16 )((int )i + 1);
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: 
      {
#line 910
      free((void *)pcol_usage);
      }
#line 911
      if (! is_sane) {
#line 912
        return (0);
      }
    }
  }
#line 916
  return (1);
}
}
#line 920 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
void opj_jp2_apply_pclr(opj_image_t *image , opj_jp2_color_t *color ) 
{ 
  opj_image_comp_t *old_comps ;
  opj_image_comp_t *new_comps ;
  OPJ_BYTE *channel_size ;
  OPJ_BYTE *channel_sign ;
  OPJ_UINT32 *entries ;
  opj_jp2_cmap_comp_t *cmap ;
  OPJ_INT32 *src ;
  OPJ_INT32 *dst ;
  OPJ_UINT32 j ;
  OPJ_UINT32 max ;
  OPJ_UINT16 i ;
  OPJ_UINT16 nr_channels ;
  OPJ_UINT16 cmp ;
  OPJ_UINT16 pcol ;
  OPJ_INT32 k ;
  OPJ_INT32 top_k ;
  void *__cil_tmp19 ;
  void *__cil_tmp22 ;

  {
  {
#line 931
  channel_size = (color->jp2_pclr)->channel_size;
#line 932
  channel_sign = (color->jp2_pclr)->channel_sign;
#line 933
  entries = (color->jp2_pclr)->entries;
#line 934
  cmap = (color->jp2_pclr)->cmap;
#line 935
  nr_channels = (OPJ_UINT16 )(color->jp2_pclr)->nr_channels;
#line 937
  old_comps = image->comps;
#line 938
  __cil_tmp19 = malloc((unsigned long )nr_channels * sizeof(opj_image_comp_t ));
#line 938
  new_comps = (opj_image_comp_t *)__cil_tmp19;
  }
#line 940
  if (! new_comps) {
#line 943
    return;
  }
#line 945
  i = (OPJ_UINT16 )0;
  {
#line 945
  while (1) {
    while_continue: /* CIL Label */ ;

#line 945
    if (! ((int )i < (int )nr_channels)) {
#line 945
      goto while_break;
    }
#line 946
    pcol = (OPJ_UINT16 )(cmap + (int )i)->pcol;
#line 946
    cmp = (cmap + (int )i)->cmp;
#line 949
    if ((int )(cmap + (int )i)->mtyp == 0) {
#line 951
      *(new_comps + (int )i) = *(old_comps + (int )cmp);
    } else {
#line 954
      *(new_comps + (int )pcol) = *(old_comps + (int )cmp);
    }
    {
#line 958
    __cil_tmp22 = malloc((unsigned long )((old_comps + (int )cmp)->w * (old_comps + (int )cmp)->h) * sizeof(OPJ_INT32 ));
#line 958
    (new_comps + (int )i)->data = (OPJ_INT32 *)__cil_tmp22;
    }
#line 960
    if (! (new_comps + (int )i)->data) {
      {
#line 961
      free((void *)new_comps);
#line 962
      new_comps = (opj_image_comp_t *)((void *)0);
      }
#line 965
      return;
    }
#line 967
    (new_comps + (int )i)->prec = (OPJ_UINT32 )*(channel_size + (int )i);
#line 968
    (new_comps + (int )i)->sgnd = (OPJ_UINT32 )*(channel_sign + (int )i);
#line 945
    i = (OPJ_UINT16 )((int )i + 1);
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 971
  top_k = (int )(color->jp2_pclr)->nr_entries - 1;
#line 973
  i = (OPJ_UINT16 )0;
  {
#line 973
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 973
    if (! ((int )i < (int )nr_channels)) {
#line 973
      goto while_break___0;
    }
#line 975
    cmp = (cmap + (int )i)->cmp;
#line 975
    pcol = (OPJ_UINT16 )(cmap + (int )i)->pcol;
#line 976
    src = (old_comps + (int )cmp)->data;
#line 978
    max = (new_comps + (int )pcol)->w * (new_comps + (int )pcol)->h;
#line 981
    if ((int )(cmap + (int )i)->mtyp == 0) {
#line 983
      dst = (new_comps + (int )i)->data;
#line 985
      j = (OPJ_UINT32 )0;
      {
#line 985
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 985
        if (! (j < max)) {
#line 985
          goto while_break___1;
        }
#line 986
        *(dst + j) = *(src + j);
#line 985
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: ;
    } else {
#line 991
      dst = (new_comps + (int )pcol)->data;
#line 993
      j = (OPJ_UINT32 )0;
      {
#line 993
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 993
        if (! (j < max)) {
#line 993
          goto while_break___2;
        }
#line 995
        k = *(src + j);
#line 995
        if (k < 0) {
#line 995
          k = 0;
        } else
#line 995
        if (k > top_k) {
#line 995
          k = top_k;
        }
#line 998
        *(dst + j) = (OPJ_INT32 )*(entries + (k * (int )nr_channels + (int )pcol));
#line 993
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: ;
    }
#line 973
    i = (OPJ_UINT16 )((int )i + 1);
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
#line 1003
  max = image->numcomps;
#line 1004
  i = (OPJ_UINT16 )0;
  {
#line 1004
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 1004
    if (! ((unsigned int )i < max)) {
#line 1004
      goto while_break___3;
    }
#line 1005
    if ((old_comps + (int )i)->data) {
      {
#line 1005
      free((void *)(old_comps + (int )i)->data);
      }
    }
#line 1004
    i = (OPJ_UINT16 )((int )i + 1);
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: 
  {
#line 1008
  free((void *)old_comps);
#line 1009
  image->comps = new_comps;
#line 1010
  image->numcomps = (OPJ_UINT32 )nr_channels;
#line 1012
  opj_jp2_free_pclr(color);
  }
#line 1014
  return;
}
}
#line 1016 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_pclr(opj_jp2_t *jp2 , OPJ_BYTE *p_pclr_header_data , OPJ_UINT32 p_pclr_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_pclr_t *jp2_pclr ;
  OPJ_BYTE *channel_size ;
  OPJ_BYTE *channel_sign ;
  OPJ_UINT32 *entries ;
  OPJ_UINT16 nr_entries ;
  OPJ_UINT16 nr_channels ;
  OPJ_UINT16 i ;
  OPJ_UINT16 j ;
  OPJ_UINT32 l_value ;
  OPJ_BYTE *orig_header_data ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  int tmp___2 ;
  OPJ_UINT32 bytes_to_read ;

  {
#line 1028
  orig_header_data = p_pclr_header_data;
#line 1036
  if (jp2->color.jp2_pclr) {
#line 1037
    return (0);
  }
#line 1039
  if (p_pclr_header_size < 3U) {
#line 1040
    return (0);
  }
  {
#line 1042
  opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )2);
#line 1043
  p_pclr_header_data += 2;
#line 1044
  nr_entries = (OPJ_UINT16 )l_value;
  }
#line 1045
  if ((unsigned int )nr_entries == 0U) {
    {
#line 1046
    opj_event_msg(p_manager, 1, "Invalid PCLR box. Reports %d entries\n", (int )nr_entries);
    }
#line 1047
    return (0);
  } else
#line 1045
  if ((unsigned int )nr_entries > 1024U) {
    {
#line 1046
    opj_event_msg(p_manager, 1, "Invalid PCLR box. Reports %d entries\n", (int )nr_entries);
    }
#line 1047
    return (0);
  }
  {
#line 1050
  opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )1);
#line 1051
  p_pclr_header_data ++;
#line 1052
  nr_channels = (OPJ_UINT16 )l_value;
  }
#line 1053
  if ((unsigned int )nr_channels == 0U) {
    {
#line 1054
    opj_event_msg(p_manager, 1, "Invalid PCLR box. Reports 0 palette columns\n");
    }
#line 1055
    return (0);
  }
#line 1058
  if (p_pclr_header_size < 3U + (OPJ_UINT32 )nr_channels) {
#line 1059
    return (0);
  }
  {
#line 1061
  __cil_tmp18 = malloc(((size_t )nr_channels * (unsigned long )nr_entries) * sizeof(OPJ_UINT32 ));
#line 1061
  entries = (OPJ_UINT32 *)__cil_tmp18;
  }
#line 1062
  if (! entries) {
#line 1063
    return (0);
  }
  {
#line 1064
  __cil_tmp19 = malloc((unsigned long )nr_channels);
#line 1064
  channel_size = (OPJ_BYTE *)__cil_tmp19;
  }
#line 1065
  if (! channel_size) {
    {
#line 1067
    free((void *)entries);
    }
#line 1068
    return (0);
  }
  {
#line 1070
  __cil_tmp20 = malloc((unsigned long )nr_channels);
#line 1070
  channel_sign = (OPJ_BYTE *)__cil_tmp20;
  }
#line 1071
  if (! channel_sign) {
    {
#line 1073
    free((void *)entries);
#line 1074
    free((void *)channel_size);
    }
#line 1075
    return (0);
  }
  {
#line 1078
  __cil_tmp21 = malloc(sizeof(opj_jp2_pclr_t ));
#line 1078
  jp2_pclr = (opj_jp2_pclr_t *)__cil_tmp21;
  }
#line 1079
  if (! jp2_pclr) {
    {
#line 1081
    free((void *)entries);
#line 1082
    free((void *)channel_size);
#line 1083
    free((void *)channel_sign);
    }
#line 1084
    return (0);
  }
#line 1087
  jp2_pclr->channel_sign = channel_sign;
#line 1088
  jp2_pclr->channel_size = channel_size;
#line 1089
  jp2_pclr->entries = entries;
#line 1090
  jp2_pclr->nr_entries = nr_entries;
#line 1091
  jp2_pclr->nr_channels = (OPJ_BYTE )l_value;
#line 1092
  jp2_pclr->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
#line 1094
  jp2->color.jp2_pclr = jp2_pclr;
#line 1096
  i = (OPJ_UINT16 )0;
  {
#line 1096
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1096
    if (! ((int )i < (int )nr_channels)) {
#line 1096
      goto while_break;
    }
    {
#line 1097
    opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )1);
#line 1098
    p_pclr_header_data ++;
#line 1100
    *(channel_size + (int )i) = (OPJ_BYTE )((l_value & 127U) + 1U);
    }
#line 1101
    if (l_value & 128U) {
#line 1101
      tmp___2 = 1;
    } else {
#line 1101
      tmp___2 = 0;
    }
#line 1101
    *(channel_sign + (int )i) = (OPJ_BYTE )tmp___2;
#line 1096
    i = (OPJ_UINT16 )((int )i + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 1104
  j = (OPJ_UINT16 )0;
  {
#line 1104
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1104
    if (! ((int )j < (int )nr_entries)) {
#line 1104
      goto while_break___0;
    }
#line 1105
    i = (OPJ_UINT16 )0;
    {
#line 1105
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1105
      if (! ((int )i < (int )nr_channels)) {
#line 1105
        goto while_break___1;
      }
#line 1106
      bytes_to_read = (OPJ_UINT32 )(((int )*(channel_size + (int )i) + 7) >> 3);
#line 1108
      if ((unsigned long )bytes_to_read > sizeof(OPJ_UINT32 )) {
#line 1109
        bytes_to_read = (OPJ_UINT32 )sizeof(OPJ_UINT32 );
      }
#line 1110
      if ((ptrdiff_t )p_pclr_header_size < (p_pclr_header_data - orig_header_data) + (ptrdiff_t )bytes_to_read) {
#line 1111
        return (0);
      }
      {
#line 1113
      opj_read_bytes_LE(p_pclr_header_data, & l_value, bytes_to_read);
#line 1114
      p_pclr_header_data += bytes_to_read;
#line 1115
      *entries = l_value;
#line 1116
      entries ++;
#line 1105
      i = (OPJ_UINT16 )((int )i + 1);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 1104
    j = (OPJ_UINT16 )((int )j + 1);
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 1120
  return (1);
}
}
#line 1123 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_cmap(opj_jp2_t *jp2 , OPJ_BYTE *p_cmap_header_data , OPJ_UINT32 p_cmap_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_cmap_comp_t *cmap ;
  OPJ_BYTE i ;
  OPJ_BYTE nr_channels ;
  OPJ_UINT32 l_value ;
  void *__cil_tmp12 ;

  {
#line 1140
  if ((unsigned long )jp2->color.jp2_pclr == (unsigned long )((void *)0)) {
    {
#line 1141
    opj_event_msg(p_manager, 1, "Need to read a PCLR box before the CMAP box.\n");
    }
#line 1142
    return (0);
  }
#line 1148
  if ((jp2->color.jp2_pclr)->cmap) {
    {
#line 1149
    opj_event_msg(p_manager, 1, "Only one CMAP box is allowed.\n");
    }
#line 1150
    return (0);
  }
#line 1153
  nr_channels = (jp2->color.jp2_pclr)->nr_channels;
#line 1154
  if (p_cmap_header_size < (OPJ_UINT32 )nr_channels * 4U) {
    {
#line 1155
    opj_event_msg(p_manager, 1, "Insufficient data for CMAP box.\n\220");
    }
#line 1156
    return (0);
  }
  {
#line 1159
  __cil_tmp12 = malloc((unsigned long )nr_channels * sizeof(opj_jp2_cmap_comp_t ));
#line 1159
  cmap = (opj_jp2_cmap_comp_t *)__cil_tmp12;
  }
#line 1160
  if (! cmap) {
#line 1161
    return (0);
  }
#line 1164
  i = (OPJ_BYTE )0;
  {
#line 1164
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1164
    if (! ((int )i < (int )nr_channels)) {
#line 1164
      goto while_break;
    }
    {
#line 1165
    opj_read_bytes_LE(p_cmap_header_data, & l_value, (OPJ_UINT32 )2);
#line 1166
    p_cmap_header_data += 2;
#line 1167
    (cmap + (int )i)->cmp = (OPJ_UINT16 )l_value;
#line 1169
    opj_read_bytes_LE(p_cmap_header_data, & l_value, (OPJ_UINT32 )1);
#line 1170
    p_cmap_header_data ++;
#line 1171
    (cmap + (int )i)->mtyp = (OPJ_BYTE )l_value;
#line 1173
    opj_read_bytes_LE(p_cmap_header_data, & l_value, (OPJ_UINT32 )1);
#line 1174
    p_cmap_header_data ++;
#line 1175
    (cmap + (int )i)->pcol = (OPJ_BYTE )l_value;
#line 1164
    i = (OPJ_BYTE )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1178
  (jp2->color.jp2_pclr)->cmap = cmap;
#line 1180
  return (1);
}
}
#line 1183 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
void opj_jp2_apply_cdef(opj_image_t *image , opj_jp2_color_t *color ) 
{ 
  opj_jp2_cdef_info_t *info ;
  OPJ_UINT16 i ;
  OPJ_UINT16 n ;
  OPJ_UINT16 cn ;
  OPJ_UINT16 asoc ;
  OPJ_UINT16 acn ;
  opj_image_comp_t saved ;
  OPJ_UINT16 j ;

  {
#line 1188
  info = (color->jp2_cdef)->info;
#line 1189
  n = (color->jp2_cdef)->n;
#line 1191
  i = (OPJ_UINT16 )0;
  {
#line 1191
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1191
    if (! ((int )i < (int )n)) {
#line 1191
      goto while_break;
    }
#line 1194
    asoc = (info + (int )i)->asoc;
#line 1195
    cn = (info + (int )i)->cn;
#line 1197
    if ((unsigned int )cn >= image->numcomps) {
      {
#line 1199
      fprintf(stderr, "cn=%d, numcomps=%d\n", (int )cn, image->numcomps);
      }
#line 1200
      goto while_continue;
    }
#line 1202
    if ((int )asoc == 0) {
#line 1204
      (image->comps + (int )cn)->alpha = (info + (int )i)->typ;
#line 1205
      goto while_continue;
    } else
#line 1202
    if ((int )asoc == 65535) {
#line 1204
      (image->comps + (int )cn)->alpha = (info + (int )i)->typ;
#line 1205
      goto while_continue;
    }
#line 1208
    acn = (OPJ_UINT16 )((int )asoc - 1);
#line 1209
    if ((unsigned int )acn >= image->numcomps) {
      {
#line 1211
      fprintf(stderr, "acn=%d, numcomps=%d\nEV", (int )acn, image->numcomps);
      }
#line 1212
      goto while_continue;
    }
#line 1216
    if ((int )cn != (int )acn) {
#line 1216
      if ((int )(info + (int )i)->typ == 0) {
        {
#line 1221
        memcpy((void *)(& saved), (void const   *)(image->comps + (int )cn), sizeof(opj_image_comp_t ));
#line 1222
        memcpy((void *)(image->comps + (int )cn), (void const   *)(image->comps + (int )acn),
               sizeof(opj_image_comp_t ));
#line 1223
        memcpy((void *)(image->comps + (int )acn), (void const   *)(& saved), sizeof(opj_image_comp_t ));
#line 1226
        j = (OPJ_UINT16 )((unsigned int )i + 1U);
        }
        {
#line 1226
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1226
          if (! ((int )j < (int )n)) {
#line 1226
            goto while_break___0;
          }
#line 1228
          if ((int )(info + (int )j)->cn == (int )cn) {
#line 1229
            (info + (int )j)->cn = acn;
          } else
#line 1231
          if ((int )(info + (int )j)->cn == (int )acn) {
#line 1232
            (info + (int )j)->cn = cn;
          }
#line 1226
          j = (OPJ_UINT16 )((int )j + 1);
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: ;
      }
    }
#line 1238
    (image->comps + (int )cn)->alpha = (info + (int )i)->typ;
#line 1191
    i = (OPJ_UINT16 )((int )i + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1241
  if ((color->jp2_cdef)->info) {
    {
#line 1241
    free((void *)(color->jp2_cdef)->info);
    }
  }
  {
#line 1243
  free((void *)color->jp2_cdef);
#line 1243
  color->jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
  }
#line 1245
  return;
}
}
#line 1247 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_cdef(opj_jp2_t *jp2 , OPJ_BYTE *p_cdef_header_data , OPJ_UINT32 p_cdef_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_cdef_info_t *cdef_info ;
  OPJ_UINT16 i ;
  OPJ_UINT32 l_value ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;

  {
#line 1265
  if (jp2->color.jp2_cdef) {
#line 1265
    return (0);
  }
#line 1267
  if (p_cdef_header_size < 2U) {
    {
#line 1268
    opj_event_msg(p_manager, 1, "Insufficient data for CDEF box.\n\220");
    }
#line 1269
    return (0);
  }
  {
#line 1272
  opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1273
  p_cdef_header_data += 2;
  }
#line 1275
  if ((int )((OPJ_UINT16 )l_value) == 0) {
    {
#line 1276
    opj_event_msg(p_manager, 1, "Number of channel description is equal to zero in CDEF box.\n");
    }
#line 1277
    return (0);
  }
#line 1280
  if (p_cdef_header_size < 2U + (OPJ_UINT32 )((OPJ_UINT16 )l_value) * 6U) {
    {
#line 1281
    opj_event_msg(p_manager, 1, "Insufficient data for CDEF box.\n\220");
    }
#line 1282
    return (0);
  }
  {
#line 1285
  __cil_tmp11 = malloc((unsigned long )l_value * sizeof(opj_jp2_cdef_info_t ));
#line 1285
  cdef_info = (opj_jp2_cdef_info_t *)__cil_tmp11;
  }
#line 1286
  if (! cdef_info) {
#line 1287
    return (0);
  }
  {
#line 1289
  __cil_tmp12 = malloc(sizeof(opj_jp2_cdef_t ));
#line 1289
  jp2->color.jp2_cdef = (opj_jp2_cdef_t *)__cil_tmp12;
  }
#line 1290
  if (! jp2->color.jp2_cdef) {
    {
#line 1292
    free((void *)cdef_info);
    }
#line 1293
    return (0);
  }
#line 1295
  (jp2->color.jp2_cdef)->info = cdef_info;
#line 1296
  (jp2->color.jp2_cdef)->n = (OPJ_UINT16 )l_value;
#line 1298
  i = (OPJ_UINT16 )0;
  {
#line 1298
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1298
    if (! ((int )i < (int )(jp2->color.jp2_cdef)->n)) {
#line 1298
      goto while_break;
    }
    {
#line 1299
    opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1300
    p_cdef_header_data += 2;
#line 1301
    (cdef_info + (int )i)->cn = (OPJ_UINT16 )l_value;
#line 1303
    opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1304
    p_cdef_header_data += 2;
#line 1305
    (cdef_info + (int )i)->typ = (OPJ_UINT16 )l_value;
#line 1307
    opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1308
    p_cdef_header_data += 2;
#line 1309
    (cdef_info + (int )i)->asoc = (OPJ_UINT16 )l_value;
#line 1298
    i = (OPJ_UINT16 )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1312
  return (1);
}
}
#line 1315 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_colr(opj_jp2_t *jp2 , OPJ_BYTE *p_colr_header_data , OPJ_UINT32 p_colr_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_value ;
  OPJ_INT32 it_icc_value ;
  OPJ_INT32 icc_len ;
  void *__cil_tmp11 ;

  {
#line 1328
  if (p_colr_header_size < 3U) {
    {
#line 1329
    opj_event_msg(p_manager, 1, "Bad COLR header box (bad size)\n");
    }
#line 1330
    return (0);
  }
#line 1336
  if (jp2->color.jp2_has_colr) {
    {
#line 1337
    opj_event_msg(p_manager, 4, "A conforming JP2 reader shall ignore all Colour Specification boxes after the first, so we ignore this one.\nEV");
#line 1338
    p_colr_header_data += p_colr_header_size;
    }
#line 1339
    return (1);
  }
  {
#line 1342
  opj_read_bytes_LE(p_colr_header_data, & jp2->meth, (OPJ_UINT32 )1);
#line 1343
  p_colr_header_data ++;
#line 1345
  opj_read_bytes_LE(p_colr_header_data, & jp2->precedence, (OPJ_UINT32 )1);
#line 1346
  p_colr_header_data ++;
#line 1348
  opj_read_bytes_LE(p_colr_header_data, & jp2->approx, (OPJ_UINT32 )1);
#line 1349
  p_colr_header_data ++;
  }
#line 1351
  if (jp2->meth == 1U) {
#line 1352
    if (p_colr_header_size < 7U) {
      {
#line 1353
      opj_event_msg(p_manager, 1, "Bad COLR header box (bad size: %d)\nkEV", p_colr_header_size);
      }
#line 1354
      return (0);
    }
#line 1356
    if (p_colr_header_size > 7U) {
      {
#line 1358
      opj_event_msg(p_manager, 2, "Bad COLR header box (bad size: %d)\n", p_colr_header_size);
      }
    }
    {
#line 1361
    opj_read_bytes_LE(p_colr_header_data, & jp2->enumcs, (OPJ_UINT32 )4);
#line 1363
    jp2->color.jp2_has_colr = (OPJ_BYTE )1;
    }
  } else
#line 1365
  if (jp2->meth == 2U) {
    {
#line 1367
    it_icc_value = 0;
#line 1368
    icc_len = (OPJ_INT32 )p_colr_header_size - 3;
#line 1370
    jp2->color.icc_profile_len = (OPJ_UINT32 )icc_len;
#line 1371
    __cil_tmp11 = calloc(1UL, (size_t )icc_len);
#line 1371
    jp2->color.icc_profile_buf = (OPJ_BYTE *)__cil_tmp11;
    }
#line 1372
    if (! jp2->color.icc_profile_buf) {
#line 1374
      jp2->color.icc_profile_len = (OPJ_UINT32 )0;
#line 1375
      return (0);
    }
#line 1378
    it_icc_value = 0;
    {
#line 1378
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1378
      if (! (it_icc_value < icc_len)) {
#line 1378
        goto while_break;
      }
      {
#line 1380
      opj_read_bytes_LE(p_colr_header_data, & l_value, (OPJ_UINT32 )1);
#line 1381
      p_colr_header_data ++;
#line 1382
      *(jp2->color.icc_profile_buf + it_icc_value) = (OPJ_BYTE )l_value;
#line 1378
      it_icc_value ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 1385
    jp2->color.jp2_has_colr = (OPJ_BYTE )1;
  } else
#line 1387
  if (jp2->meth > 2U) {
    {
#line 1391
    opj_event_msg(p_manager, 4, "COLR BOX meth value is not a regular value (%d), so we will ignore the entire Colour Specification box. \n",
                  jp2->meth);
    }
  }
#line 1394
  return (1);
}
}
#line 1397 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_decode(opj_jp2_t *jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 1402
  if (! p_image) {
#line 1403
    return (0);
  }
  {
#line 1406
  __cil_tmp5 = opj_j2k_decode(jp2->j2k, p_stream, p_image, p_manager);
  }
#line 1406
  if (! __cil_tmp5) {
    {
#line 1407
    opj_event_msg(p_manager, 1, "Failed to decode the codestream in the JP2 file\n\220");
    }
#line 1408
    return (0);
  }
#line 1411
  if (! jp2->ignore_pclr_cmap_cdef) {
    {
#line 1412
    __cil_tmp6 = opj_jp2_check_color(p_image, & jp2->color, p_manager);
    }
#line 1412
    if (! __cil_tmp6) {
#line 1413
      return (0);
    }
#line 1417
    if (jp2->enumcs == 16U) {
#line 1418
      p_image->color_space = (OPJ_COLOR_SPACE )1;
    } else
#line 1419
    if (jp2->enumcs == 17U) {
#line 1420
      p_image->color_space = (OPJ_COLOR_SPACE )2;
    } else
#line 1421
    if (jp2->enumcs == 18U) {
#line 1422
      p_image->color_space = (OPJ_COLOR_SPACE )3;
    } else
#line 1423
    if (jp2->enumcs == 24U) {
#line 1424
      p_image->color_space = (OPJ_COLOR_SPACE )4;
    } else {
#line 1426
      p_image->color_space = (OPJ_COLOR_SPACE )-1;
    }
#line 1428
    if (jp2->color.jp2_pclr) {
#line 1430
      if (! (jp2->color.jp2_pclr)->cmap) {
        {
#line 1431
        opj_jp2_free_pclr(& jp2->color);
        }
      } else {
        {
#line 1433
        opj_jp2_apply_pclr(p_image, & jp2->color);
        }
      }
    }
#line 1437
    if (jp2->color.jp2_cdef) {
      {
#line 1438
      opj_jp2_apply_cdef(p_image, & jp2->color);
      }
    }
#line 1441
    if (jp2->color.icc_profile_buf) {
#line 1442
      p_image->icc_profile_buf = jp2->color.icc_profile_buf;
#line 1443
      p_image->icc_profile_len = jp2->color.icc_profile_len;
#line 1444
      jp2->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
    }
  }
#line 1448
  return (1);
}
}
#line 1451 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_jp2h(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_img_header_writer_handler_t l_writers[4] ;
  opj_jp2_img_header_writer_handler_t *l_current_writer ;
  OPJ_INT32 i ;
  OPJ_INT32 l_nb_pass ;
  OPJ_UINT32 l_jp2h_size ;
  OPJ_BOOL l_result ;
  OPJ_BYTE l_jp2h_data[8] ;
  OPJ_SIZE_T __cil_tmp16 ;
  OPJ_SIZE_T __cil_tmp17 ;

  {
  {
#line 1461
  l_jp2h_size = (OPJ_UINT32 )8;
#line 1462
  l_result = 1;
#line 1472
  memset((void *)(l_writers), 0, sizeof(l_writers));
  }
#line 1474
  if (jp2->bpc == 255U) {
#line 1475
    l_nb_pass = 3;
#line 1476
    l_writers[0].handler = & opj_jp2_write_ihdr;
#line 1477
    l_writers[1].handler = & opj_jp2_write_bpcc;
#line 1478
    l_writers[2].handler = & opj_jp2_write_colr;
  } else {
#line 1481
    l_nb_pass = 2;
#line 1482
    l_writers[0].handler = & opj_jp2_write_ihdr;
#line 1483
    l_writers[1].handler = & opj_jp2_write_colr;
  }
#line 1486
  if ((unsigned long )jp2->color.jp2_cdef != (unsigned long )((void *)0)) {
#line 1487
    l_writers[l_nb_pass].handler = & opj_jp2_write_cdef;
#line 1488
    l_nb_pass ++;
  }
  {
#line 1493
  opj_write_bytes_LE(l_jp2h_data + 4, (OPJ_UINT32 )1785737832, (OPJ_UINT32 )4);
#line 1495
  l_current_writer = l_writers;
#line 1496
  i = 0;
  }
  {
#line 1496
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1496
    if (! (i < l_nb_pass)) {
#line 1496
      goto while_break;
    }
    {
#line 1497
    l_current_writer->m_data = (*(l_current_writer->handler))(jp2, & l_current_writer->m_size);
    }
#line 1498
    if ((unsigned long )l_current_writer->m_data == (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 1499
      opj_event_msg(p_manager, 1, "Not enough memory to hold JP2 Header data\n");
#line 1500
      l_result = 0;
      }
#line 1501
      goto while_break;
    }
#line 1504
    l_jp2h_size += l_current_writer->m_size;
#line 1505
    l_current_writer ++;
#line 1496
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 1508
  if (! l_result) {
#line 1509
    l_current_writer = l_writers;
#line 1510
    i = 0;
    {
#line 1510
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1510
      if (! (i < l_nb_pass)) {
#line 1510
        goto while_break___0;
      }
#line 1511
      if ((unsigned long )l_current_writer->m_data != (unsigned long )((OPJ_BYTE *)0)) {
        {
#line 1512
        free((void *)l_current_writer->m_data);
        }
      }
#line 1514
      l_current_writer ++;
#line 1510
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: ;
#line 1517
    return (0);
  }
  {
#line 1521
  opj_write_bytes_LE(l_jp2h_data, l_jp2h_size, (OPJ_UINT32 )4);
#line 1524
  __cil_tmp16 = opj_stream_write_data(stream, l_jp2h_data, (OPJ_SIZE_T )8, p_manager);
  }
#line 1524
  if (__cil_tmp16 != 8UL) {
    {
#line 1525
    opj_event_msg(p_manager, 1, "Stream error while writing JP2 Header box\n");
#line 1526
    l_result = 0;
    }
  }
#line 1529
  if (l_result) {
#line 1530
    l_current_writer = l_writers;
#line 1531
    i = 0;
    {
#line 1531
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1531
      if (! (i < l_nb_pass)) {
#line 1531
        goto while_break___1;
      }
      {
#line 1532
      __cil_tmp17 = opj_stream_write_data(stream, l_current_writer->m_data, (OPJ_SIZE_T )l_current_writer->m_size,
                                          p_manager);
      }
#line 1532
      if (__cil_tmp17 != (unsigned long )l_current_writer->m_size) {
        {
#line 1533
        opj_event_msg(p_manager, 1, "Stream error while writing JP2 Header box\n");
#line 1534
        l_result = 0;
        }
#line 1535
        goto while_break___1;
      }
#line 1537
      l_current_writer ++;
#line 1531
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 1541
  l_current_writer = l_writers;
#line 1544
  i = 0;
  {
#line 1544
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1544
    if (! (i < l_nb_pass)) {
#line 1544
      goto while_break___2;
    }
#line 1545
    if ((unsigned long )l_current_writer->m_data != (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 1546
      free((void *)l_current_writer->m_data);
      }
    }
#line 1548
    l_current_writer ++;
#line 1544
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 1551
  return (l_result);
}
}
#line 1554 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_ftyp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_ftyp_size ;
  OPJ_BYTE *l_ftyp_data ;
  OPJ_BYTE *l_current_data_ptr ;
  OPJ_BOOL l_result ;
  void *__cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 1559
  l_ftyp_size = 16U + 4U * jp2->numcl;
#line 1568
  __cil_tmp12 = calloc(1UL, (unsigned long )l_ftyp_size);
#line 1568
  l_ftyp_data = (OPJ_BYTE *)__cil_tmp12;
  }
#line 1570
  if ((unsigned long )l_ftyp_data == (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 1571
    opj_event_msg(p_manager, 1, "Not enough memory to handle ftyp data\n");
    }
#line 1572
    return (0);
  }
  {
#line 1575
  l_current_data_ptr = l_ftyp_data;
#line 1577
  opj_write_bytes_LE(l_current_data_ptr, l_ftyp_size, (OPJ_UINT32 )4);
#line 1578
  l_current_data_ptr += 4;
#line 1580
  opj_write_bytes_LE(l_current_data_ptr, (OPJ_UINT32 )1718909296, (OPJ_UINT32 )4);
#line 1581
  l_current_data_ptr += 4;
#line 1583
  opj_write_bytes_LE(l_current_data_ptr, jp2->brand, (OPJ_UINT32 )4);
#line 1584
  l_current_data_ptr += 4;
#line 1586
  opj_write_bytes_LE(l_current_data_ptr, jp2->minversion, (OPJ_UINT32 )4);
#line 1587
  l_current_data_ptr += 4;
#line 1589
  i = (OPJ_UINT32 )0;
  }
  {
#line 1589
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1589
    if (! (i < jp2->numcl)) {
#line 1589
      goto while_break;
    }
    {
#line 1590
    opj_write_bytes_LE(l_current_data_ptr, *(jp2->cl + i), (OPJ_UINT32 )4);
#line 1589
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1593
  __cil_tmp14 = opj_stream_write_data(cio, l_ftyp_data, (OPJ_SIZE_T )l_ftyp_size,
                                      p_manager);
#line 1593
  l_result = __cil_tmp14 == (unsigned long )l_ftyp_size;
  }
#line 1594
  if (! l_result) {
    {
#line 1596
    opj_event_msg(p_manager, 1, "Error while writing ftyp data to stream\n\220");
    }
  }
  {
#line 1599
  free((void *)l_ftyp_data);
  }
#line 1601
  return (l_result);
}
}
#line 1604 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_OFF_T j2k_codestream_exit ;
  OPJ_BYTE l_data_header[8] ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 1617
  j2k_codestream_exit = opj_stream_tell(cio);
#line 1618
  opj_write_bytes_LE(l_data_header, (OPJ_UINT32 )(j2k_codestream_exit - jp2->j2k_codestream_offset),
                     (OPJ_UINT32 )4);
#line 1621
  opj_write_bytes_LE(l_data_header + 4, (OPJ_UINT32 )1785737827, (OPJ_UINT32 )4);
#line 1623
  __cil_tmp12 = opj_stream_seek(cio, jp2->j2k_codestream_offset, p_manager);
  }
#line 1623
  if (! __cil_tmp12) {
    {
#line 1624
    opj_event_msg(p_manager, 1, "Failed to seek in the stream.\n");
    }
#line 1625
    return (0);
  }
  {
#line 1628
  __cil_tmp13 = opj_stream_write_data(cio, l_data_header, (OPJ_SIZE_T )8, p_manager);
  }
#line 1628
  if (__cil_tmp13 != 8UL) {
    {
#line 1629
    opj_event_msg(p_manager, 1, "Failed to seek in the stream.\n");
    }
#line 1630
    return (0);
  }
  {
#line 1633
  __cil_tmp14 = opj_stream_seek(cio, j2k_codestream_exit, p_manager);
  }
#line 1633
  if (! __cil_tmp14) {
    {
#line 1634
    opj_event_msg(p_manager, 1, "Failed to seek in the stream.\n");
    }
#line 1635
    return (0);
  }
#line 1638
  return (1);
}
}
#line 1641 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_jp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_signature_data[12] ;
  OPJ_SIZE_T __cil_tmp8 ;

  {
  {
#line 1654
  opj_write_bytes_LE(l_signature_data, (OPJ_UINT32 )12, (OPJ_UINT32 )4);
#line 1656
  opj_write_bytes_LE(l_signature_data + 4, (OPJ_UINT32 )1783636000, (OPJ_UINT32 )4);
#line 1658
  opj_write_bytes_LE(l_signature_data + 8, (OPJ_UINT32 )218793738, (OPJ_UINT32 )4);
#line 1660
  __cil_tmp8 = opj_stream_write_data(cio, l_signature_data, (OPJ_SIZE_T )12, p_manager);
  }
#line 1660
  if (__cil_tmp8 != 12UL) {
#line 1661
    return (0);
  }
#line 1664
  return (1);
}
}
#line 1671 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
void opj_jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) 
{ 


  {
  {
#line 1674
  opj_j2k_setup_decoder(jp2->j2k, parameters);
#line 1677
  jp2->color.jp2_has_colr = (OPJ_BYTE )0;
#line 1678
  jp2->ignore_pclr_cmap_cdef = (OPJ_BOOL )(parameters->flags & 1U);
  }
#line 1680
  return;
}
}
#line 1685 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ,
                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 depth_0 ;
  OPJ_UINT32 sign ;
  OPJ_UINT32 alpha_count ;
  OPJ_UINT32 color_channels ;
  OPJ_UINT32 alpha_channel ;
  OPJ_BOOL __cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  OPJ_UINT32 depth ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
#line 1694
  color_channels = 0U;
#line 1695
  alpha_channel = 0U;
#line 1698
  if (! jp2) {
#line 1699
    return (0);
  } else
#line 1698
  if (! parameters) {
#line 1699
    return (0);
  } else
#line 1698
  if (! image) {
#line 1699
    return (0);
  }
#line 1705
  if (image->numcomps < 1U) {
    {
#line 1706
    opj_event_msg(p_manager, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
#line 1707
    return (0);
  } else
#line 1705
  if (image->numcomps > 16384U) {
    {
#line 1706
    opj_event_msg(p_manager, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
#line 1707
    return (0);
  }
  {
#line 1710
  __cil_tmp11 = opj_j2k_setup_encoder(jp2->j2k, parameters, image, p_manager);
  }
#line 1710
  if (__cil_tmp11 == 0) {
#line 1711
    return (0);
  }
  {
#line 1719
  jp2->brand = (OPJ_UINT32 )1785737760;
#line 1720
  jp2->minversion = (OPJ_UINT32 )0;
#line 1721
  jp2->numcl = (OPJ_UINT32 )1;
#line 1722
  __cil_tmp12 = malloc((unsigned long )jp2->numcl * sizeof(OPJ_UINT32 ));
#line 1722
  jp2->cl = (OPJ_UINT32 *)__cil_tmp12;
  }
#line 1723
  if (! jp2->cl) {
    {
#line 1724
    jp2->cl = (OPJ_UINT32 *)((void *)0);
#line 1725
    opj_event_msg(p_manager, 1, "Not enough memory when setup the JP2 encoder\n");
    }
#line 1726
    return (0);
  }
  {
#line 1728
  *(jp2->cl + 0) = (OPJ_UINT32 )1785737760;
#line 1732
  jp2->numcomps = image->numcomps;
#line 1733
  __cil_tmp13 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 1733
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp13;
  }
#line 1734
  if (! jp2->comps) {
    {
#line 1735
    jp2->comps = (opj_jp2_comps_t *)((void *)0);
#line 1736
    opj_event_msg(p_manager, 1, "Not enough memory when setup the JP2 encoder\n");
    }
#line 1738
    return (0);
  }
#line 1741
  jp2->h = image->y1 - image->y0;
#line 1742
  jp2->w = image->x1 - image->x0;
#line 1744
  depth_0 = (image->comps + 0)->prec - 1U;
#line 1745
  sign = (image->comps + 0)->sgnd;
#line 1746
  jp2->bpc = depth_0 + (sign << 7);
#line 1747
  i = (OPJ_UINT32 )1;
  {
#line 1747
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1747
    if (! (i < image->numcomps)) {
#line 1747
      goto while_break;
    }
#line 1748
    depth = (image->comps + i)->prec - 1U;
#line 1749
    sign = (image->comps + i)->sgnd;
#line 1750
    if (depth_0 != depth) {
#line 1751
      jp2->bpc = (OPJ_UINT32 )255;
    }
#line 1747
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 1753
  jp2->C = (OPJ_UINT32 )7;
#line 1754
  jp2->UnkC = (OPJ_UINT32 )0;
#line 1755
  jp2->IPR = (OPJ_UINT32 )0;
#line 1758
  i = (OPJ_UINT32 )0;
  {
#line 1758
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1758
    if (! (i < image->numcomps)) {
#line 1758
      goto while_break___0;
    }
#line 1759
    (jp2->comps + i)->bpcc = ((image->comps + i)->prec - 1U) + ((image->comps + i)->sgnd << 7);
#line 1758
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: ;
#line 1763
  if (image->icc_profile_len) {
#line 1764
    jp2->meth = (OPJ_UINT32 )2;
#line 1765
    jp2->enumcs = (OPJ_UINT32 )0;
  } else {
#line 1768
    jp2->meth = (OPJ_UINT32 )1;
#line 1769
    if ((int )image->color_space == 1) {
#line 1770
      jp2->enumcs = (OPJ_UINT32 )16;
    } else
#line 1771
    if ((int )image->color_space == 2) {
#line 1772
      jp2->enumcs = (OPJ_UINT32 )17;
    } else
#line 1773
    if ((int )image->color_space == 3) {
#line 1774
      jp2->enumcs = (OPJ_UINT32 )18;
    }
  }
#line 1780
  alpha_count = 0U;
#line 1781
  i = (OPJ_UINT32 )0;
  {
#line 1781
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 1781
    if (! (i < image->numcomps)) {
#line 1781
      goto while_break___1;
    }
#line 1782
    if ((int )(image->comps + i)->alpha != 0) {
#line 1783
      alpha_count ++;
#line 1784
      alpha_channel = i;
    }
#line 1781
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: ;
#line 1787
  if (alpha_count == 1U) {
#line 1790
    if (jp2->enumcs == 18U) {
#line 1790
      goto case_18;
    }
#line 1790
    if (jp2->enumcs == 16U) {
#line 1790
      goto case_18;
    }
#line 1793
    if (jp2->enumcs == 17U) {
#line 1793
      goto case_17;
    }
#line 1796
    goto switch_default;
    case_18: 
#line 1791
    color_channels = (OPJ_UINT32 )3;
#line 1792
    goto switch_break;
    case_17: 
#line 1794
    color_channels = (OPJ_UINT32 )1;
#line 1795
    goto switch_break;
    switch_default: 
#line 1797
    alpha_count = 0U;
#line 1798
    goto switch_break;
    switch_break: ;
#line 1800
    if (alpha_count == 0U) {
      {
#line 1801
      opj_event_msg(p_manager, 2, "Alpha channel specified but unknown enumcs. No cdef box will be created.\n");
      }
    } else
#line 1802
    if (image->numcomps < color_channels + 1U) {
      {
#line 1803
      opj_event_msg(p_manager, 2, "Alpha channel specified but not enough image components for an automatic cdef box creation.\n");
#line 1804
      alpha_count = 0U;
      }
    } else
#line 1805
    if (alpha_channel < color_channels) {
      {
#line 1806
      opj_event_msg(p_manager, 2, "Alpha channel position conflicts with color channel. No cdef box will be created.\n");
#line 1807
      alpha_count = 0U;
      }
    }
  } else
#line 1809
  if (alpha_count > 1U) {
    {
#line 1810
    opj_event_msg(p_manager, 2, "Multiple alpha channels specified. No cdef box will be created.\n\220");
    }
  }
#line 1812
  if (alpha_count == 1U) {
    {
#line 1813
    __cil_tmp19 = malloc(sizeof(opj_jp2_cdef_t ));
#line 1813
    jp2->color.jp2_cdef = (opj_jp2_cdef_t *)__cil_tmp19;
    }
#line 1814
    if (! jp2->color.jp2_cdef) {
      {
#line 1815
      opj_event_msg(p_manager, 1, "Not enough memory to setup the JP2 encoder\n");
      }
#line 1816
      return (0);
    }
    {
#line 1820
    __cil_tmp20 = malloc((unsigned long )image->numcomps * sizeof(opj_jp2_cdef_info_t ));
#line 1820
    (jp2->color.jp2_cdef)->info = (opj_jp2_cdef_info_t *)__cil_tmp20;
    }
#line 1821
    if (! (jp2->color.jp2_cdef)->info) {
      {
#line 1823
      opj_event_msg(p_manager, 1, "Not enough memory to setup the JP2 encoder\n");
      }
#line 1824
      return (0);
    }
#line 1826
    (jp2->color.jp2_cdef)->n = (OPJ_UINT16 )image->numcomps;
#line 1827
    i = 0U;
    {
#line 1827
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 1827
      if (! (i < color_channels)) {
#line 1827
        goto while_break___2;
      }
#line 1828
      ((jp2->color.jp2_cdef)->info + i)->cn = (OPJ_UINT16 )i;
#line 1829
      ((jp2->color.jp2_cdef)->info + i)->typ = (OPJ_UINT16 )0U;
#line 1830
      ((jp2->color.jp2_cdef)->info + i)->asoc = (OPJ_UINT16 )(i + 1U);
#line 1827
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: ;
    {
#line 1832
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 1832
      if (! (i < image->numcomps)) {
#line 1832
        goto while_break___3;
      }
#line 1833
      if ((int )(image->comps + i)->alpha != 0) {
#line 1834
        ((jp2->color.jp2_cdef)->info + i)->cn = (OPJ_UINT16 )i;
#line 1835
        ((jp2->color.jp2_cdef)->info + i)->typ = (OPJ_UINT16 )1U;
#line 1836
        ((jp2->color.jp2_cdef)->info + i)->asoc = (OPJ_UINT16 )0U;
      } else {
#line 1839
        ((jp2->color.jp2_cdef)->info + i)->cn = (OPJ_UINT16 )i;
#line 1840
        ((jp2->color.jp2_cdef)->info + i)->typ = (OPJ_UINT16 )65535U;
#line 1841
        ((jp2->color.jp2_cdef)->info + i)->asoc = (OPJ_UINT16 )65535U;
      }
#line 1832
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: ;
  }
#line 1846
  jp2->precedence = (OPJ_UINT32 )0;
#line 1847
  jp2->approx = (OPJ_UINT32 )0;
#line 1849
  jp2->jpip_on = parameters->jpip_on;
#line 1851
  return (1);
}
}
#line 1854 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_encode(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 1858
  __cil_tmp4 = opj_j2k_encode(jp2->j2k, stream, p_manager);
  }
#line 1858
  return (__cil_tmp4);
}
}
#line 1861 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_end_decompress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1872
  opj_jp2_setup_end_header_reading(jp2);
#line 1875
  __cil_tmp7 = opj_jp2_exec(jp2, jp2->m_procedure_list, cio, p_manager);
  }
#line 1875
  if (! __cil_tmp7) {
#line 1876
    return (0);
  }
  {
#line 1879
  __cil_tmp8 = opj_j2k_end_decompress(jp2->j2k, cio, p_manager);
  }
#line 1879
  return (__cil_tmp8);
}
}
#line 1882 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_end_compress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1893
  opj_jp2_setup_end_header_writing(jp2);
#line 1895
  __cil_tmp7 = opj_j2k_end_compress(jp2->j2k, cio, p_manager);
  }
#line 1895
  if (! __cil_tmp7) {
#line 1896
    return (0);
  }
  {
#line 1900
  __cil_tmp8 = opj_jp2_exec(jp2, jp2->m_procedure_list, cio, p_manager);
  }
#line 1900
  return (__cil_tmp8);
}
}
#line 1903 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
void opj_jp2_setup_end_header_writing(opj_jp2_t *jp2 ) 
{ 


  {
  {
#line 1912
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_write_jp2c));
  }
#line 1914
  return;
}
}
#line 1923 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
void opj_jp2_setup_end_header_reading(opj_jp2_t *jp2 ) 
{ 


  {
  {
#line 1927
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_read_header_procedure));
  }
#line 1929
  return;
}
}
#line 1931 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_default_validation(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;
  OPJ_UINT32 i ;
  OPJ_BOOL __cil_tmp9 ;
  int tmp___2 ;

  {
#line 1936
  l_is_valid = 1;
#line 1948
  l_is_valid &= jp2->jp2_state == 0U;
#line 1951
  l_is_valid &= jp2->jp2_img_state == 0U;
#line 1955
  l_is_valid &= (unsigned long )jp2->j2k != (unsigned long )((opj_j2k_t *)0);
#line 1958
  l_is_valid &= (unsigned long )jp2->m_procedure_list != (unsigned long )((struct opj_procedure_list *)0);
#line 1961
  l_is_valid &= (unsigned long )jp2->m_validation_list != (unsigned long )((struct opj_procedure_list *)0);
#line 1965
  l_is_valid &= jp2->numcl > 0U;
#line 1967
  l_is_valid &= jp2->h > 0U;
#line 1969
  l_is_valid &= jp2->w > 0U;
#line 1971
  i = (OPJ_UINT32 )0;
  {
#line 1971
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1971
    if (! (i < jp2->numcomps)) {
#line 1971
      goto while_break;
    }
#line 1972
    l_is_valid &= (jp2->comps + i)->bpcc > 0U;
#line 1971
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1976
  if (jp2->meth > 0U) {
#line 1976
    if (jp2->meth < 3U) {
#line 1976
      tmp___2 = 1;
    } else {
#line 1976
      tmp___2 = 0;
    }
  } else {
#line 1976
    tmp___2 = 0;
  }
  {
#line 1976
  l_is_valid &= tmp___2;
#line 1980
  __cil_tmp9 = opj_stream_has_seek(cio);
#line 1980
  l_is_valid &= __cil_tmp9;
  }
#line 1982
  return (l_is_valid);
}
}
#line 1985 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_header_procedure(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                       opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_box_t box ;
  OPJ_UINT32 l_nb_bytes_read ;
  opj_jp2_header_handler_t *l_current_handler ;
  OPJ_UINT32 l_last_data_size ;
  OPJ_UINT32 l_current_data_size ;
  OPJ_BYTE *l_current_data ;
  void *__cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_OFF_T __cil_tmp16 ;
  OPJ_OFF_T __cil_tmp17 ;
  OPJ_BYTE *new_current_data ;
  void *__cil_tmp19 ;
  OPJ_SIZE_T __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_OFF_T __cil_tmp22 ;

  {
  {
#line 1993
  l_last_data_size = (OPJ_UINT32 )1024;
#line 1995
  l_current_data = (OPJ_BYTE *)0;
#line 2002
  __cil_tmp13 = calloc(1UL, (unsigned long )l_last_data_size);
#line 2002
  l_current_data = (OPJ_BYTE *)__cil_tmp13;
  }
#line 2004
  if ((unsigned long )l_current_data == (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 2005
    opj_event_msg(p_manager, 1, "Not enough memory to handle jpeg2000 file header\n");
    }
#line 2006
    return (0);
  }
  {
#line 2009
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2009
    __cil_tmp14 = opj_jp2_read_boxhdr(& box, & l_nb_bytes_read, stream, p_manager);
    }
#line 2009
    if (! __cil_tmp14) {
#line 2009
      goto while_break;
    }
#line 2011
    if (box.type == 1785737827U) {
#line 2012
      if (jp2->jp2_state & 4U) {
        {
#line 2013
        jp2->jp2_state |= 8U;
#line 2014
        free((void *)l_current_data);
        }
#line 2015
        return (1);
      } else {
        {
#line 2018
        opj_event_msg(p_manager, 1, "bad placed jpeg codestream\n");
#line 2019
        free((void *)l_current_data);
        }
#line 2020
        return (0);
      }
    } else
#line 2023
    if (box.length == 0U) {
      {
#line 2024
      opj_event_msg(p_manager, 1, "Cannot handle box of undefined sizes\n");
#line 2025
      free((void *)l_current_data);
      }
#line 2026
      return (0);
    } else
#line 2029
    if (box.length < l_nb_bytes_read) {
      {
#line 2030
      opj_event_msg(p_manager, 1, "invalid box size %d (%x)\n", box.length, box.type);
#line 2031
      free((void *)l_current_data);
      }
#line 2032
      return (0);
    }
    {
#line 2035
    l_current_handler = opj_jp2_find_handler(box.type);
#line 2036
    l_current_data_size = box.length - l_nb_bytes_read;
    }
#line 2038
    if ((unsigned long )l_current_handler != (unsigned long )((opj_jp2_header_handler_t *)0)) {
      {
#line 2039
      __cil_tmp16 = opj_stream_get_number_byte_left(stream);
      }
#line 2039
      if ((OPJ_OFF_T )l_current_data_size > __cil_tmp16) {
        {
#line 2041
        __cil_tmp17 = opj_stream_get_number_byte_left(stream);
#line 2041
        opj_event_msg(p_manager, 1, "Invalid box size %d for box \'%c%c%c%c\'. Need %d bytes, %d bytes remaining \n",
                      box.length, (int )((OPJ_BYTE )(box.type >> 24)), (int )((OPJ_BYTE )(box.type >> 16)),
                      (int )((OPJ_BYTE )(box.type >> 8)), (int )((OPJ_BYTE )box.type),
                      l_current_data_size, (OPJ_UINT32 )__cil_tmp17);
#line 2042
        free((void *)l_current_data);
        }
#line 2043
        return (0);
      }
#line 2045
      if (l_current_data_size > l_last_data_size) {
        {
#line 2046
        __cil_tmp19 = realloc((void *)l_current_data, (unsigned long )l_current_data_size);
#line 2046
        new_current_data = (OPJ_BYTE *)__cil_tmp19;
        }
#line 2047
        if (! new_current_data) {
          {
#line 2048
          free((void *)l_current_data);
#line 2049
          opj_event_msg(p_manager, 1, "Not enough memory to handle jpeg2000 box\n");
          }
#line 2050
          return (0);
        }
#line 2052
        l_current_data = new_current_data;
#line 2053
        l_last_data_size = l_current_data_size;
      }
      {
#line 2056
      __cil_tmp20 = opj_stream_read_data(stream, l_current_data, (OPJ_SIZE_T )l_current_data_size,
                                         p_manager);
#line 2056
      l_nb_bytes_read = (OPJ_UINT32 )__cil_tmp20;
      }
#line 2057
      if (l_nb_bytes_read != l_current_data_size) {
        {
#line 2058
        opj_event_msg(p_manager, 1, "Problem with reading JPEG2000 box, stream error\n\220");
#line 2059
        free((void *)l_current_data);
        }
#line 2060
        return (0);
      }
      {
#line 2063
      __cil_tmp21 = (*(l_current_handler->handler))(jp2, l_current_data, l_current_data_size,
                                                    p_manager);
      }
#line 2063
      if (! __cil_tmp21) {
        {
#line 2064
        free((void *)l_current_data);
        }
#line 2065
        return (0);
      }
    } else {
      {
#line 2069
      jp2->jp2_state |= 2147483647U;
#line 2070
      __cil_tmp22 = opj_stream_skip(stream, (OPJ_OFF_T )l_current_data_size, p_manager);
      }
#line 2070
      if (__cil_tmp22 != (long )l_current_data_size) {
        {
#line 2071
        opj_event_msg(p_manager, 1, "Problem with skipping JPEG2000 box, stream error\n");
#line 2072
        free((void *)l_current_data);
        }
#line 2073
        return (0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2078
  free((void *)l_current_data);
  }
#line 2080
  return (1);
}
}
#line 2093 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_exec(opj_jp2_t *jp2 , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL (**l_procedure)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ) ;
  OPJ_BOOL l_result ;
  OPJ_UINT32 l_nb_proc ;
  OPJ_UINT32 i ;
  opj_procedure *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  int tmp___3 ;

  {
  {
#line 2100
  l_procedure = (OPJ_BOOL (**)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ))0;
#line 2101
  l_result = 1;
#line 2110
  l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);
#line 2111
  __cil_tmp14 = opj_procedure_list_get_first_procedure(p_procedure_list);
#line 2111
  l_procedure = (OPJ_BOOL (**)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ))__cil_tmp14;
#line 2113
  i = (OPJ_UINT32 )0;
  }
  {
#line 2113
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2113
    if (! (i < l_nb_proc)) {
#line 2113
      goto while_break;
    }
    {
#line 2114
    __cil_tmp15 = (*(*l_procedure))(jp2, stream, p_manager);
    }
#line 2114
    if (l_result) {
#line 2114
      if (__cil_tmp15) {
#line 2114
        tmp___3 = 1;
      } else {
#line 2114
        tmp___3 = 0;
      }
    } else {
#line 2114
      tmp___3 = 0;
    }
#line 2114
    l_result = tmp___3;
#line 2115
    l_procedure ++;
#line 2113
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2119
  opj_procedure_list_clear(p_procedure_list);
  }
#line 2120
  return (l_result);
}
}
#line 2123 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_start_compress(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_image_t *p_image ,
                                opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;

  {
  {
#line 2135
  opj_jp2_setup_encoding_validation(jp2);
#line 2138
  __cil_tmp8 = opj_jp2_exec(jp2, jp2->m_validation_list, stream, p_manager);
  }
#line 2138
  if (! __cil_tmp8) {
#line 2139
    return (0);
  }
  {
#line 2143
  opj_jp2_setup_header_writing(jp2);
#line 2146
  __cil_tmp9 = opj_jp2_exec(jp2, jp2->m_procedure_list, stream, p_manager);
  }
#line 2146
  if (! __cil_tmp9) {
#line 2147
    return (0);
  }
  {
#line 2150
  __cil_tmp10 = opj_j2k_start_compress(jp2->j2k, stream, p_image, p_manager);
  }
#line 2150
  return (__cil_tmp10);
}
}
#line 2153 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
opj_jp2_header_handler_t *opj_jp2_find_handler(OPJ_UINT32 p_id ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_handler_size ;

  {
#line 2155
  l_handler_size = (OPJ_UINT32 )(sizeof(jp2_header) / sizeof(opj_jp2_header_handler_t ));
#line 2157
  i = (OPJ_UINT32 )0;
  {
#line 2157
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2157
    if (! (i < l_handler_size)) {
#line 2157
      goto while_break;
    }
#line 2158
    if (jp2_header[i].id == p_id) {
#line 2159
      return (& jp2_header[i]);
    }
#line 2157
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2162
  return ((opj_jp2_header_handler_t *)((void *)0));
}
}
#line 2172 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
static opj_jp2_header_handler_t *opj_jp2_img_find_handler(OPJ_UINT32 p_id ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_handler_size ;

  {
#line 2174
  l_handler_size = (OPJ_UINT32 )(sizeof(jp2_img_header) / sizeof(opj_jp2_header_handler_t ));
#line 2175
  i = (OPJ_UINT32 )0;
  {
#line 2175
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2175
    if (! (i < l_handler_size)) {
#line 2175
      goto while_break;
    }
#line 2177
    if (jp2_img_header[i].id == p_id) {
#line 2178
      return (& jp2_img_header[i]);
    }
#line 2175
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2182
  return ((opj_jp2_header_handler_t *)((void *)0));
}
}
#line 2195 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_jp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_magic_number ;

  {
#line 2209
  if (jp2->jp2_state != 0U) {
    {
#line 2210
    opj_event_msg(p_manager, 1, "The signature box must be the first box in the file.\n");
    }
#line 2211
    return (0);
  }
#line 2215
  if (p_header_size != 4U) {
    {
#line 2216
    opj_event_msg(p_manager, 1, "Error with JP signature Box size\n");
    }
#line 2217
    return (0);
  }
  {
#line 2221
  opj_read_bytes_LE(p_header_data, & l_magic_number, (OPJ_UINT32 )4);
  }
#line 2222
  if (l_magic_number != 218793738U) {
    {
#line 2223
    opj_event_msg(p_manager, 1, "Error with JP Signature : bad magic number\n");
    }
#line 2224
    return (0);
  }
#line 2227
  jp2->jp2_state |= 1U;
#line 2229
  return (1);
}
}
#line 2242 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_ftyp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_remaining_bytes ;
  void *__cil_tmp10 ;

  {
#line 2255
  if (jp2->jp2_state != 1U) {
    {
#line 2256
    opj_event_msg(p_manager, 1, "The ftyp box must be the second box in the file.\n");
    }
#line 2257
    return (0);
  }
#line 2261
  if (p_header_size < 8U) {
    {
#line 2262
    opj_event_msg(p_manager, 1, "Error with FTYP signature Box size\n");
    }
#line 2263
    return (0);
  }
  {
#line 2266
  opj_read_bytes_LE(p_header_data, & jp2->brand, (OPJ_UINT32 )4);
#line 2267
  p_header_data += 4;
#line 2269
  opj_read_bytes_LE(p_header_data, & jp2->minversion, (OPJ_UINT32 )4);
#line 2270
  p_header_data += 4;
#line 2272
  l_remaining_bytes = p_header_size - 8U;
  }
#line 2275
  if ((l_remaining_bytes & 3U) != 0U) {
    {
#line 2276
    opj_event_msg(p_manager, 1, "Error with FTYP signature Box size\n");
    }
#line 2277
    return (0);
  }
#line 2281
  jp2->numcl = l_remaining_bytes >> 2;
#line 2282
  if (jp2->numcl) {
    {
#line 2283
    __cil_tmp10 = calloc((unsigned long )jp2->numcl, sizeof(OPJ_UINT32 ));
#line 2283
    jp2->cl = (OPJ_UINT32 *)__cil_tmp10;
    }
#line 2284
    if ((unsigned long )jp2->cl == (unsigned long )((OPJ_UINT32 *)0)) {
      {
#line 2285
      opj_event_msg(p_manager, 1, "Not enough memory with FTYP Box\n\220");
      }
#line 2286
      return (0);
    }
  }
#line 2290
  i = (OPJ_UINT32 )0;
  {
#line 2290
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2290
    if (! (i < jp2->numcl)) {
#line 2290
      goto while_break;
    }
    {
#line 2292
    opj_read_bytes_LE(p_header_data, jp2->cl + i, (OPJ_UINT32 )4);
#line 2293
    p_header_data += 4;
#line 2290
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 2296
  jp2->jp2_state |= 2U;
#line 2298
  return (1);
}
}
#line 2301 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_skip_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_OFF_T __cil_tmp8 ;

  {
  {
#line 2310
  jp2->j2k_codestream_offset = opj_stream_tell(stream);
#line 2312
  __cil_tmp8 = opj_stream_skip(stream, (OPJ_OFF_T )8, p_manager);
  }
#line 2312
  if (__cil_tmp8 != 8L) {
#line 2313
    return (0);
  }
#line 2316
  return (1);
}
}
#line 2319 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jpip_skip_iptr(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  OPJ_OFF_T __cil_tmp8 ;

  {
  {
#line 2328
  jp2->jpip_iptr_offset = opj_stream_tell(stream);
#line 2330
  __cil_tmp8 = opj_stream_skip(stream, (OPJ_OFF_T )24, p_manager);
  }
#line 2330
  if (__cil_tmp8 != 24L) {
#line 2331
    return (0);
  }
#line 2334
  return (1);
}
}
#line 2347 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_jp2h(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_box_size ;
  OPJ_UINT32 l_current_data_size ;
  opj_jp2_box_t box ;
  opj_jp2_header_handler_t *l_current_handler ;
  OPJ_BOOL l_has_ihdr ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp15 ;

  {
#line 2353
  l_box_size = (OPJ_UINT32 )0;
#line 2353
  l_current_data_size = (OPJ_UINT32 )0;
#line 2356
  l_has_ihdr = 0;
#line 2364
  if ((jp2->jp2_state & 2U) != 2U) {
    {
#line 2365
    opj_event_msg(p_manager, 1, "The  box must be the first box in the file.\n");
    }
#line 2366
    return (0);
  }
#line 2369
  jp2->jp2_img_state = (OPJ_UINT32 )0;
  {
#line 2372
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2372
    if (! (p_header_size > 0U)) {
#line 2372
      goto while_break;
    }
    {
#line 2374
    __cil_tmp13 = opj_jp2_read_boxhdr_char(& box, p_header_data, & l_box_size, p_header_size,
                                           p_manager);
    }
#line 2374
    if (! __cil_tmp13) {
      {
#line 2375
      opj_event_msg(p_manager, 1, "Stream error while reading JP2 Header box\n");
      }
#line 2376
      return (0);
    }
#line 2379
    if (box.length > p_header_size) {
      {
#line 2380
      opj_event_msg(p_manager, 1, "Stream error while reading JP2 Header box: box length is inconsistent.\n");
      }
#line 2381
      return (0);
    }
    {
#line 2384
    l_current_handler = opj_jp2_img_find_handler(box.type);
#line 2385
    l_current_data_size = box.length - l_box_size;
#line 2386
    p_header_data += l_box_size;
    }
#line 2388
    if ((unsigned long )l_current_handler != (unsigned long )((opj_jp2_header_handler_t *)0)) {
      {
#line 2389
      __cil_tmp15 = (*(l_current_handler->handler))(jp2, p_header_data, l_current_data_size,
                                                    p_manager);
      }
#line 2389
      if (! __cil_tmp15) {
#line 2390
        return (0);
      }
    } else {
#line 2394
      jp2->jp2_img_state |= 2147483647U;
    }
#line 2397
    if (box.type == 1768449138U) {
#line 2398
      l_has_ihdr = 1;
    }
#line 2401
    p_header_data += l_current_data_size;
#line 2402
    p_header_size -= box.length;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2405
  if (l_has_ihdr == 0) {
    {
#line 2406
    opj_event_msg(p_manager, 1, "Stream error while reading JP2 Header box: no \'ihdr\' box.\n");
    }
#line 2407
    return (0);
  }
#line 2410
  jp2->jp2_state |= 4U;
#line 2412
  return (1);
}
}
#line 2415 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_boxhdr_char(opj_jp2_box_t *box , OPJ_BYTE *p_data , OPJ_UINT32 *p_number_bytes_read ,
                                  OPJ_UINT32 p_box_max_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_value ;
  OPJ_UINT32 l_xl_part_size ;

  {
#line 2430
  if (p_box_max_size < 8U) {
    {
#line 2431
    opj_event_msg(p_manager, 1, "Cannot handle box of less than 8 bytes\n");
    }
#line 2432
    return (0);
  }
  {
#line 2436
  opj_read_bytes_LE(p_data, & l_value, (OPJ_UINT32 )4);
#line 2437
  p_data += 4;
#line 2438
  box->length = l_value;
#line 2440
  opj_read_bytes_LE(p_data, & l_value, (OPJ_UINT32 )4);
#line 2441
  p_data += 4;
#line 2442
  box->type = l_value;
#line 2444
  *p_number_bytes_read = (OPJ_UINT32 )8;
  }
#line 2448
  if (box->length == 1U) {
#line 2451
    if (p_box_max_size < 16U) {
      {
#line 2452
      opj_event_msg(p_manager, 1, "Cannot handle XL box of less than 16 bytes\n");
      }
#line 2453
      return (0);
    }
    {
#line 2456
    opj_read_bytes_LE(p_data, & l_xl_part_size, (OPJ_UINT32 )4);
#line 2457
    p_data += 4;
#line 2458
    *p_number_bytes_read += 4U;
    }
#line 2460
    if (l_xl_part_size != 0U) {
      {
#line 2461
      opj_event_msg(p_manager, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 2462
      return (0);
    }
    {
#line 2465
    opj_read_bytes_LE(p_data, & l_value, (OPJ_UINT32 )4);
#line 2466
    *p_number_bytes_read += 4U;
#line 2467
    box->length = l_value;
    }
#line 2469
    if (box->length == 0U) {
      {
#line 2470
      opj_event_msg(p_manager, 1, "Cannot handle box of undefined sizes\n");
      }
#line 2471
      return (0);
    }
  } else
#line 2474
  if (box->length == 0U) {
    {
#line 2475
    opj_event_msg(p_manager, 1, "Cannot handle box of undefined sizes\n");
    }
#line 2476
    return (0);
  }
#line 2478
  if (box->length < *p_number_bytes_read) {
    {
#line 2479
    opj_event_msg(p_manager, 1, "Box length is inconsistent.\n");
    }
#line 2480
    return (0);
  }
#line 2482
  return (1);
}
}
#line 2485 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_header(opj_stream_private_t *p_stream , opj_jp2_t *jp2 , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;

  {
  {
#line 2497
  opj_jp2_setup_decoding_validation(jp2);
#line 2500
  opj_jp2_setup_header_reading(jp2);
#line 2503
  __cil_tmp8 = opj_jp2_exec(jp2, jp2->m_validation_list, p_stream, p_manager);
  }
#line 2503
  if (! __cil_tmp8) {
#line 2504
    return (0);
  }
  {
#line 2508
  __cil_tmp9 = opj_jp2_exec(jp2, jp2->m_procedure_list, p_stream, p_manager);
  }
#line 2508
  if (! __cil_tmp9) {
#line 2509
    return (0);
  }
  {
#line 2512
  __cil_tmp10 = opj_j2k_read_header(p_stream, jp2->j2k, p_image, p_manager);
  }
#line 2512
  return (__cil_tmp10);
}
}
#line 2518 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
void opj_jp2_setup_encoding_validation(opj_jp2_t *jp2 ) 
{ 


  {
  {
#line 2523
  opj_procedure_list_add_procedure(jp2->m_validation_list, (void (*)(void))(& opj_jp2_default_validation));
  }
#line 2525
  return;
}
}
#line 2527 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
void opj_jp2_setup_decoding_validation(opj_jp2_t *jp2 ) 
{ 


  {
#line 2532
  return;
}
}
#line 2534 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
void opj_jp2_setup_header_writing(opj_jp2_t *jp2 ) 
{ 


  {
  {
#line 2539
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_write_jp));
#line 2540
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_write_ftyp));
#line 2541
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_write_jp2h));
  }
#line 2542
  if (jp2->jpip_on) {
    {
#line 2543
    opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jpip_skip_iptr));
    }
  }
  {
#line 2544
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_skip_jp2c));
  }
#line 2546
  return;
}
}
#line 2550 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
void opj_jp2_setup_header_reading(opj_jp2_t *jp2 ) 
{ 


  {
  {
#line 2555
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_read_header_procedure));
  }
#line 2557
  return;
}
}
#line 2559 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_tile_header(opj_jp2_t *p_jp2 , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 2572
  __cil_tmp12 = opj_j2k_read_tile_header(p_jp2->j2k, p_tile_index, p_data_size, p_tile_x0,
                                         p_tile_y0, p_tile_x1, p_tile_y1, p_nb_comps,
                                         p_go_on, p_stream, p_manager);
  }
#line 2572
  return (__cil_tmp12);
}
}
#line 2583 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;

  {
  {
#line 2592
  __cil_tmp7 = opj_j2k_write_tile(p_jp2->j2k, p_tile_index, p_data, p_data_size, p_stream,
                                  p_manager);
  }
#line 2592
  return (__cil_tmp7);
}
}
#line 2595 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_decode_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;

  {
  {
#line 2603
  __cil_tmp7 = opj_j2k_decode_tile(p_jp2->j2k, p_tile_index, p_data, p_data_size,
                                   p_stream, p_manager);
  }
#line 2603
  return (__cil_tmp7);
}
}
#line 2606 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
void opj_jp2_destroy(opj_jp2_t *jp2 ) 
{ 


  {
#line 2608
  if (jp2) {
    {
#line 2610
    opj_j2k_destroy(jp2->j2k);
#line 2611
    jp2->j2k = (opj_j2k_t *)0;
    }
#line 2613
    if (jp2->comps) {
      {
#line 2614
      free((void *)jp2->comps);
#line 2615
      jp2->comps = (opj_jp2_comps_t *)0;
      }
    }
#line 2618
    if (jp2->cl) {
      {
#line 2619
      free((void *)jp2->cl);
#line 2620
      jp2->cl = (OPJ_UINT32 *)0;
      }
    }
#line 2623
    if (jp2->color.icc_profile_buf) {
      {
#line 2624
      free((void *)jp2->color.icc_profile_buf);
#line 2625
      jp2->color.icc_profile_buf = (OPJ_BYTE *)0;
      }
    }
#line 2628
    if (jp2->color.jp2_cdef) {
#line 2629
      if ((jp2->color.jp2_cdef)->info) {
        {
#line 2630
        free((void *)(jp2->color.jp2_cdef)->info);
#line 2631
        (jp2->color.jp2_cdef)->info = (opj_jp2_cdef_info_t *)((void *)0);
        }
      }
      {
#line 2634
      free((void *)jp2->color.jp2_cdef);
#line 2635
      jp2->color.jp2_cdef = (opj_jp2_cdef_t *)0;
      }
    }
#line 2638
    if (jp2->color.jp2_pclr) {
#line 2639
      if ((jp2->color.jp2_pclr)->cmap) {
        {
#line 2640
        free((void *)(jp2->color.jp2_pclr)->cmap);
#line 2641
        (jp2->color.jp2_pclr)->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
        }
      }
#line 2643
      if ((jp2->color.jp2_pclr)->channel_sign) {
        {
#line 2644
        free((void *)(jp2->color.jp2_pclr)->channel_sign);
#line 2645
        (jp2->color.jp2_pclr)->channel_sign = (OPJ_BYTE *)((void *)0);
        }
      }
#line 2647
      if ((jp2->color.jp2_pclr)->channel_size) {
        {
#line 2648
        free((void *)(jp2->color.jp2_pclr)->channel_size);
#line 2649
        (jp2->color.jp2_pclr)->channel_size = (OPJ_BYTE *)((void *)0);
        }
      }
#line 2651
      if ((jp2->color.jp2_pclr)->entries) {
        {
#line 2652
        free((void *)(jp2->color.jp2_pclr)->entries);
#line 2653
        (jp2->color.jp2_pclr)->entries = (OPJ_UINT32 *)((void *)0);
        }
      }
      {
#line 2656
      free((void *)jp2->color.jp2_pclr);
#line 2657
      jp2->color.jp2_pclr = (opj_jp2_pclr_t *)0;
      }
    }
#line 2660
    if (jp2->m_validation_list) {
      {
#line 2661
      opj_procedure_list_destroy(jp2->m_validation_list);
#line 2662
      jp2->m_validation_list = (struct opj_procedure_list *)0;
      }
    }
#line 2665
    if (jp2->m_procedure_list) {
      {
#line 2666
      opj_procedure_list_destroy(jp2->m_procedure_list);
#line 2667
      jp2->m_procedure_list = (struct opj_procedure_list *)0;
      }
    }
    {
#line 2670
    free((void *)jp2);
    }
  }
#line 2673
  return;
}
}
#line 2674 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_decode_area(opj_jp2_t *p_jp2 , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 2681
  __cil_tmp8 = opj_j2k_set_decode_area(p_jp2->j2k, p_image, p_start_x, p_start_y,
                                       p_end_x, p_end_y, p_manager);
  }
#line 2681
  return (__cil_tmp8);
}
}
#line 2684 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_get_tile(opj_jp2_t *p_jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) 
{ 
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 2691
  if (! p_image) {
#line 2692
    return (0);
  }
  {
#line 2694
  opj_event_msg(p_manager, 2, "JP2 box which are after the codestream will not be read by this function.\n");
#line 2696
  __cil_tmp6 = opj_j2k_get_tile(p_jp2->j2k, p_stream, p_image, p_manager, tile_index);
  }
#line 2696
  if (! __cil_tmp6) {
    {
#line 2697
    opj_event_msg(p_manager, 1, "Failed to decode the codestream in the JP2 file\n\220");
    }
#line 2698
    return (0);
  }
  {
#line 2701
  __cil_tmp7 = opj_jp2_check_color(p_image, & p_jp2->color, p_manager);
  }
#line 2701
  if (! __cil_tmp7) {
#line 2702
    return (0);
  }
#line 2706
  if (p_jp2->enumcs == 16U) {
#line 2707
    p_image->color_space = (OPJ_COLOR_SPACE )1;
  } else
#line 2708
  if (p_jp2->enumcs == 17U) {
#line 2709
    p_image->color_space = (OPJ_COLOR_SPACE )2;
  } else
#line 2710
  if (p_jp2->enumcs == 18U) {
#line 2711
    p_image->color_space = (OPJ_COLOR_SPACE )3;
  } else {
#line 2713
    p_image->color_space = (OPJ_COLOR_SPACE )-1;
  }
#line 2715
  if (p_jp2->color.jp2_pclr) {
#line 2717
    if (! (p_jp2->color.jp2_pclr)->cmap) {
      {
#line 2718
      opj_jp2_free_pclr(& p_jp2->color);
      }
    } else {
      {
#line 2720
      opj_jp2_apply_pclr(p_image, & p_jp2->color);
      }
    }
  }
#line 2724
  if (p_jp2->color.jp2_cdef) {
    {
#line 2725
    opj_jp2_apply_cdef(p_image, & p_jp2->color);
    }
  }
#line 2728
  if (p_jp2->color.icc_profile_buf) {
#line 2729
    p_image->icc_profile_buf = p_jp2->color.icc_profile_buf;
#line 2730
    p_image->icc_profile_len = p_jp2->color.icc_profile_len;
#line 2731
    p_jp2->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
  }
#line 2734
  return (1);
}
}
#line 2741 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
opj_jp2_t *opj_jp2_create(OPJ_BOOL p_is_decoder ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 2743
  __cil_tmp3 = calloc(1UL, sizeof(opj_jp2_t ));
#line 2743
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 2744
  if (jp2) {
#line 2747
    if (! p_is_decoder) {
      {
#line 2748
      jp2->j2k = opj_j2k_create_compress();
      }
    } else {
      {
#line 2751
      jp2->j2k = opj_j2k_create_decompress();
      }
    }
#line 2754
    if ((unsigned long )jp2->j2k == (unsigned long )((opj_j2k_t *)0)) {
      {
#line 2755
      opj_jp2_destroy(jp2);
      }
#line 2756
      return ((opj_jp2_t *)0);
    }
    {
#line 2760
    jp2->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 2761
    jp2->color.icc_profile_len = (OPJ_UINT32 )0;
#line 2762
    jp2->color.jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
#line 2763
    jp2->color.jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
#line 2764
    jp2->color.jp2_has_colr = (OPJ_BYTE )0;
#line 2767
    jp2->m_validation_list = opj_procedure_list_create();
    }
#line 2768
    if (! jp2->m_validation_list) {
      {
#line 2769
      opj_jp2_destroy(jp2);
      }
#line 2770
      return ((opj_jp2_t *)0);
    }
    {
#line 2774
    jp2->m_procedure_list = opj_procedure_list_create();
    }
#line 2775
    if (! jp2->m_procedure_list) {
      {
#line 2776
      opj_jp2_destroy(jp2);
      }
#line 2777
      return ((opj_jp2_t *)0);
    }
  }
#line 2781
  return (jp2);
}
}
#line 2784 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
void jp2_dump(opj_jp2_t *p_jp2 , OPJ_INT32 flag , FILE *out_stream ) 
{ 


  {
  {
#line 2789
  j2k_dump(p_jp2->j2k, flag, out_stream);
  }
#line 2791
  return;
}
}
#line 2794 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
opj_codestream_index_t *jp2_get_cstr_index(opj_jp2_t *p_jp2 ) 
{ 
  opj_codestream_index_t *__cil_tmp2 ;

  {
  {
#line 2796
  __cil_tmp2 = j2k_get_cstr_index(p_jp2->j2k);
  }
#line 2796
  return (__cil_tmp2);
}
}
#line 2799 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
opj_codestream_info_v2_t *jp2_get_cstr_info(opj_jp2_t *p_jp2 ) 
{ 
  opj_codestream_info_v2_t *__cil_tmp2 ;

  {
  {
#line 2801
  __cil_tmp2 = j2k_get_cstr_info(p_jp2->j2k);
  }
#line 2801
  return (__cil_tmp2);
}
}
#line 2804 "/root/patchweave_new/10/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_decoded_resolution_factor(opj_jp2_t *p_jp2 , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 2808
  __cil_tmp4 = opj_j2k_set_decoded_resolution_factor(p_jp2->j2k, res_factor, p_manager);
  }
#line 2808
  return (__cil_tmp4);
}
}
#line 37 "/root/patchweave_new/10/src/lib/openjp2/invert.c"
OPJ_BOOL opj_lupDecompose(OPJ_FLOAT32 *matrix , OPJ_UINT32 *permutations , OPJ_FLOAT32 *p_swap_area ,
                          OPJ_UINT32 nb_compo ) ;
#line 44
void opj_lupSolve(OPJ_FLOAT32 *pResult , OPJ_FLOAT32 *pMatrix , OPJ_FLOAT32 *pVector ,
                  OPJ_UINT32 *pPermutations , OPJ_UINT32 nb_compo , OPJ_FLOAT32 *p_intermediate_data ) ;
#line 54
void opj_lupInvert(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix , OPJ_UINT32 nb_compo ,
                   OPJ_UINT32 *pPermutations , OPJ_FLOAT32 *p_src_temp , OPJ_FLOAT32 *p_dest_temp ,
                   OPJ_FLOAT32 *p_swap_area ) ;
#line 70 "/root/patchweave_new/10/src/lib/openjp2/invert.c"
OPJ_BOOL opj_matrix_inversion_f(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix ,
                                OPJ_UINT32 nb_compo ) 
{ 
  OPJ_BYTE *l_data ;
  OPJ_UINT32 l_permutation_size ;
  OPJ_UINT32 l_swap_size ;
  OPJ_UINT32 l_total_size ;
  OPJ_UINT32 *lPermutations ;
  OPJ_FLOAT32 *l_double_data ;
  void *__cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 74
  l_data = (OPJ_BYTE *)0;
#line 75
  l_permutation_size = nb_compo * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 76
  l_swap_size = nb_compo * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 77
  l_total_size = l_permutation_size + 3U * l_swap_size;
#line 78
  lPermutations = (OPJ_UINT32 *)0;
#line 79
  l_double_data = (OPJ_FLOAT32 *)0;
#line 81
  __cil_tmp10 = malloc((unsigned long )l_total_size);
#line 81
  l_data = (OPJ_BYTE *)__cil_tmp10;
  }
#line 82
  if ((unsigned long )l_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 83
    return (0);
  }
  {
#line 85
  lPermutations = (OPJ_UINT32 *)l_data;
#line 86
  l_double_data = (OPJ_FLOAT32 *)(l_data + l_permutation_size);
#line 87
  memset((void *)lPermutations, 0, (unsigned long )l_permutation_size);
#line 89
  __cil_tmp11 = opj_lupDecompose(pSrcMatrix, lPermutations, l_double_data, nb_compo);
  }
#line 89
  if (! __cil_tmp11) {
    {
#line 90
    free((void *)l_data);
    }
#line 91
    return (0);
  }
  {
#line 94
  opj_lupInvert(pSrcMatrix, pDestMatrix, nb_compo, lPermutations, l_double_data, l_double_data + nb_compo,
                l_double_data + 2U * nb_compo);
#line 95
  free((void *)l_data);
  }
#line 97
  return (1);
}
}
#line 106 "/root/patchweave_new/10/src/lib/openjp2/invert.c"
OPJ_BOOL opj_lupDecompose(OPJ_FLOAT32 *matrix , OPJ_UINT32 *permutations , OPJ_FLOAT32 *p_swap_area ,
                          OPJ_UINT32 nb_compo ) 
{ 
  OPJ_UINT32 *tmpPermutations ;
  OPJ_UINT32 *dstPermutations ;
  OPJ_UINT32 k2 ;
  OPJ_UINT32 t ;
  OPJ_FLOAT32 temp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_FLOAT32 p ;
  OPJ_UINT32 lLastColum ;
  OPJ_UINT32 lSwapSize ;
  OPJ_FLOAT32 *lTmpMatrix ;
  OPJ_FLOAT32 *lColumnMatrix ;
  OPJ_FLOAT32 *lDestMatrix ;
  OPJ_UINT32 offset ;
  OPJ_UINT32 lStride ;
  OPJ_UINT32 *__cil_tmp21 ;
  OPJ_FLOAT32 tmp ;
  OPJ_FLOAT32 *__cil_tmp23 ;
  OPJ_FLOAT32 *__cil_tmp24 ;
  OPJ_FLOAT32 *__cil_tmp25 ;
  OPJ_FLOAT32 *__cil_tmp26 ;

  {
#line 110
  tmpPermutations = permutations;
#line 112
  k2 = (OPJ_UINT32 )0;
#line 116
  lLastColum = nb_compo - 1U;
#line 117
  lSwapSize = nb_compo * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 118
  lTmpMatrix = matrix;
#line 120
  offset = (OPJ_UINT32 )1;
#line 121
  lStride = nb_compo - 1U;
#line 124
  i = (OPJ_UINT32 )0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;

#line 124
    if (! (i < nb_compo)) {
#line 124
      goto while_break;
    }
#line 126
    __cil_tmp21 = tmpPermutations;
#line 126
    tmpPermutations ++;
#line 126
    *__cil_tmp21 = i;
#line 124
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 129
  tmpPermutations = permutations;
#line 130
  k = (OPJ_UINT32 )0;
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 130
    if (! (k < lLastColum)) {
#line 130
      goto while_break___0;
    }
#line 131
    p = (OPJ_FLOAT32 )0.;
#line 134
    lColumnMatrix = lTmpMatrix + k;
#line 137
    i = k;
    {
#line 137
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 137
      if (! (i < nb_compo)) {
#line 137
        goto while_break___1;
      }
#line 138
      if (*lColumnMatrix > (float )0) {
#line 138
        tmp = *lColumnMatrix;
      } else {
#line 138
        tmp = - *lColumnMatrix;
      }
#line 138
      temp = tmp;
#line 139
      if (temp > p) {
#line 140
        p = temp;
#line 141
        k2 = i;
      }
#line 144
      lColumnMatrix += nb_compo;
#line 137
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: ;
#line 148
    if ((double )p == 0.) {
#line 149
      return (0);
    }
#line 153
    if (k2 != k) {
      {
#line 156
      dstPermutations = (tmpPermutations + k2) - k;
#line 158
      t = *tmpPermutations;
#line 159
      *tmpPermutations = *dstPermutations;
#line 160
      *dstPermutations = t;
#line 163
      lColumnMatrix = lTmpMatrix + (k2 - k) * nb_compo;
#line 164
      memcpy((void *)p_swap_area, (void const   *)lColumnMatrix, (unsigned long )lSwapSize);
#line 165
      memcpy((void *)lColumnMatrix, (void const   *)lTmpMatrix, (unsigned long )lSwapSize);
#line 166
      memcpy((void *)lTmpMatrix, (void const   *)p_swap_area, (unsigned long )lSwapSize);
      }
    }
#line 170
    lDestMatrix = lTmpMatrix + k;
#line 171
    lColumnMatrix = lDestMatrix + nb_compo;
#line 173
    __cil_tmp23 = lDestMatrix;
#line 173
    lDestMatrix ++;
#line 173
    temp = *__cil_tmp23;
#line 176
    i = offset;
    {
#line 176
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 176
      if (! (i < nb_compo)) {
#line 176
        goto while_break___2;
      }
#line 182
      p = *lColumnMatrix / temp;
#line 183
      __cil_tmp24 = lColumnMatrix;
#line 183
      lColumnMatrix ++;
#line 183
      *__cil_tmp24 = p;
#line 185
      j = offset;
      {
#line 185
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 185
        if (! (j < nb_compo)) {
#line 185
          goto while_break___3;
        }
#line 187
        __cil_tmp26 = lDestMatrix;
#line 187
        lDestMatrix ++;
#line 187
        __cil_tmp25 = lColumnMatrix;
#line 187
        lColumnMatrix ++;
#line 187
        *__cil_tmp25 -= p * *__cil_tmp26;
#line 185
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 190
      lDestMatrix -= lStride;
#line 192
      lColumnMatrix += k;
#line 176
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 196
    offset ++;
#line 198
    lStride --;
#line 200
    lTmpMatrix += nb_compo;
#line 202
    tmpPermutations ++;
#line 130
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: ;
#line 204
  return (1);
}
}
#line 207 "/root/patchweave_new/10/src/lib/openjp2/invert.c"
void opj_lupSolve(OPJ_FLOAT32 *pResult , OPJ_FLOAT32 *pMatrix , OPJ_FLOAT32 *pVector ,
                  OPJ_UINT32 *pPermutations , OPJ_UINT32 nb_compo , OPJ_FLOAT32 *p_intermediate_data ) 
{ 
  OPJ_INT32 k ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_FLOAT32 sum ;
  OPJ_FLOAT32 u ;
  OPJ_UINT32 lStride ;
  OPJ_FLOAT32 *lCurrentPtr ;
  OPJ_FLOAT32 *lIntermediatePtr ;
  OPJ_FLOAT32 *lDestPtr ;
  OPJ_FLOAT32 *lTmpMatrix ;
  OPJ_FLOAT32 *lLineMatrix ;
  OPJ_FLOAT32 *lBeginPtr ;
  OPJ_FLOAT32 *lGeneratedData ;
  OPJ_UINT32 *lCurrentPermutationPtr ;
  OPJ_FLOAT32 *__cil_tmp21 ;
  OPJ_FLOAT32 *__cil_tmp22 ;
  OPJ_FLOAT32 *__cil_tmp23 ;
  OPJ_UINT32 *__cil_tmp24 ;
  OPJ_FLOAT32 *__cil_tmp26 ;
  OPJ_FLOAT32 *__cil_tmp27 ;
  OPJ_FLOAT32 *__cil_tmp28 ;
  OPJ_FLOAT32 *__cil_tmp29 ;
  OPJ_FLOAT32 *__cil_tmp30 ;
  OPJ_FLOAT32 *__cil_tmp31 ;

  {
#line 217
  lStride = nb_compo + 1U;
#line 222
  lLineMatrix = pMatrix;
#line 223
  lBeginPtr = (pResult + nb_compo) - 1;
#line 225
  lCurrentPermutationPtr = pPermutations;
#line 228
  lIntermediatePtr = p_intermediate_data;
#line 229
  lGeneratedData = (p_intermediate_data + nb_compo) - 1;
#line 231
  i = (OPJ_UINT32 )0;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;

#line 231
    if (! (i < nb_compo)) {
#line 231
      goto while_break;
    }
#line 232
    sum = (OPJ_FLOAT32 )0.;
#line 233
    lCurrentPtr = p_intermediate_data;
#line 234
    lTmpMatrix = lLineMatrix;
#line 235
    j = (OPJ_UINT32 )1;
    {
#line 235
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 235
      if (! (j <= i)) {
#line 235
        goto while_break___0;
      }
#line 238
      __cil_tmp22 = lCurrentPtr;
#line 238
      lCurrentPtr ++;
#line 238
      __cil_tmp21 = lTmpMatrix;
#line 238
      lTmpMatrix ++;
#line 238
      sum += *__cil_tmp21 * *__cil_tmp22;
#line 235
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 241
    __cil_tmp24 = lCurrentPermutationPtr;
#line 241
    lCurrentPermutationPtr ++;
#line 241
    __cil_tmp23 = lIntermediatePtr;
#line 241
    lIntermediatePtr ++;
#line 241
    *__cil_tmp23 = *(pVector + *__cil_tmp24) - sum;
#line 242
    lLineMatrix += nb_compo;
#line 231
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 246
  lLineMatrix = (pMatrix + nb_compo * nb_compo) - 1;
#line 249
  lDestPtr = pResult + nb_compo;
#line 253
  k = (OPJ_INT32 )nb_compo - 1;
  {
#line 253
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 253
    if (! (k != -1)) {
#line 253
      goto while_break___1;
    }
#line 254
    sum = (OPJ_FLOAT32 )0.;
#line 255
    lTmpMatrix = lLineMatrix;
#line 256
    __cil_tmp26 = lTmpMatrix;
#line 256
    lTmpMatrix ++;
#line 256
    u = *__cil_tmp26;
#line 257
    __cil_tmp27 = lDestPtr;
#line 257
    lDestPtr --;
#line 257
    lCurrentPtr = __cil_tmp27;
#line 258
    j = (OPJ_UINT32 )(k + 1);
    {
#line 258
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 258
      if (! (j < nb_compo)) {
#line 258
        goto while_break___2;
      }
#line 260
      __cil_tmp29 = lCurrentPtr;
#line 260
      lCurrentPtr ++;
#line 260
      __cil_tmp28 = lTmpMatrix;
#line 260
      lTmpMatrix ++;
#line 260
      sum += *__cil_tmp28 * *__cil_tmp29;
#line 258
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 263
    __cil_tmp31 = lGeneratedData;
#line 263
    lGeneratedData --;
#line 263
    __cil_tmp30 = lBeginPtr;
#line 263
    lBeginPtr --;
#line 263
    *__cil_tmp30 = (*__cil_tmp31 - sum) / u;
#line 264
    lLineMatrix -= lStride;
#line 253
    k --;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 257
  return;
}
}
#line 269 "/root/patchweave_new/10/src/lib/openjp2/invert.c"
void opj_lupInvert(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix , OPJ_UINT32 nb_compo ,
                   OPJ_UINT32 *pPermutations , OPJ_FLOAT32 *p_src_temp , OPJ_FLOAT32 *p_dest_temp ,
                   OPJ_FLOAT32 *p_swap_area ) 
{ 
  OPJ_UINT32 j ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 *lCurrentPtr ;
  OPJ_FLOAT32 *lLineMatrix ;
  OPJ_UINT32 lSwapSize ;
  OPJ_FLOAT32 *__cil_tmp13 ;

  {
#line 279
  lLineMatrix = pDestMatrix;
#line 280
  lSwapSize = nb_compo * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 282
  j = (OPJ_UINT32 )0;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;

#line 282
    if (! (j < nb_compo)) {
#line 282
      goto while_break;
    }
    {
#line 283
    __cil_tmp13 = lLineMatrix;
#line 283
    lLineMatrix ++;
#line 283
    lCurrentPtr = __cil_tmp13;
#line 284
    memset((void *)p_src_temp, 0, (unsigned long )lSwapSize);
#line 285
    *(p_src_temp + j) = (OPJ_FLOAT32 )1.;
#line 286
    opj_lupSolve(p_dest_temp, pSrcMatrix, p_src_temp, pPermutations, nb_compo, p_swap_area);
#line 288
    i = (OPJ_UINT32 )0;
    }
    {
#line 288
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 288
      if (! (i < nb_compo)) {
#line 288
        goto while_break___0;
      }
#line 289
      *lCurrentPtr = *(p_dest_temp + i);
#line 290
      lCurrentPtr += nb_compo;
#line 288
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 282
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 286
  return;
}
}
#line 34 "/root/patchweave_new/10/src/lib/openjp2/image.c"
opj_image_t *opj_image_create0(void) 
{ 
  opj_image_t *image ;
  void *__cil_tmp2 ;

  {
  {
#line 35
  __cil_tmp2 = calloc(1UL, sizeof(opj_image_t ));
#line 35
  image = (opj_image_t *)__cil_tmp2;
  }
#line 36
  return (image);
}
}
#line 39 "/root/patchweave_new/10/src/lib/openjp2/image.c"
opj_image_t *opj_image_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                              OPJ_COLOR_SPACE clrspc ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_t *image ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_image_comp_t *comp ;
  void *__cil_tmp9 ;

  {
  {
#line 41
  image = (opj_image_t *)((void *)0);
#line 43
  __cil_tmp6 = calloc(1UL, sizeof(opj_image_t ));
#line 43
  image = (opj_image_t *)__cil_tmp6;
  }
#line 44
  if (image) {
    {
#line 45
    image->color_space = clrspc;
#line 46
    image->numcomps = numcmpts;
#line 48
    __cil_tmp7 = calloc(1UL, (unsigned long )image->numcomps * sizeof(opj_image_comp_t ));
#line 48
    image->comps = (opj_image_comp_t *)__cil_tmp7;
    }
#line 49
    if (! image->comps) {
      {
#line 50
      fprintf(stderr, "Unable to allocate memory for image.\nV");
#line 51
      opj_image_destroy(image);
      }
#line 52
      return ((opj_image_t *)((void *)0));
    }
#line 55
    compno = (OPJ_UINT32 )0;
    {
#line 55
    while (1) {
      while_continue: /* CIL Label */ ;

#line 55
      if (! (compno < numcmpts)) {
#line 55
        goto while_break;
      }
      {
#line 56
      comp = image->comps + compno;
#line 57
      comp->dx = (cmptparms + compno)->dx;
#line 58
      comp->dy = (cmptparms + compno)->dy;
#line 59
      comp->w = (cmptparms + compno)->w;
#line 60
      comp->h = (cmptparms + compno)->h;
#line 61
      comp->x0 = (cmptparms + compno)->x0;
#line 62
      comp->y0 = (cmptparms + compno)->y0;
#line 63
      comp->prec = (cmptparms + compno)->prec;
#line 64
      comp->bpp = (cmptparms + compno)->bpp;
#line 65
      comp->sgnd = (cmptparms + compno)->sgnd;
#line 66
      __cil_tmp9 = calloc((unsigned long )(comp->w * comp->h), sizeof(OPJ_INT32 ));
#line 66
      comp->data = (OPJ_INT32 *)__cil_tmp9;
      }
#line 67
      if (! comp->data) {
        {
#line 68
        fprintf(stderr, "Unable to allocate memory for image.\n");
#line 69
        opj_image_destroy(image);
        }
#line 70
        return ((opj_image_t *)((void *)0));
      }
#line 55
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 75
  return (image);
}
}
#line 78 "/root/patchweave_new/10/src/lib/openjp2/image.c"
void opj_image_destroy(opj_image_t *image ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_comp_t *image_comp ;

  {
#line 79
  if (image) {
#line 80
    if (image->comps) {
#line 84
      compno = (OPJ_UINT32 )0;
      {
#line 84
      while (1) {
        while_continue: /* CIL Label */ ;

#line 84
        if (! (compno < image->numcomps)) {
#line 84
          goto while_break;
        }
#line 85
        image_comp = image->comps + compno;
#line 86
        if (image_comp->data) {
          {
#line 87
          free((void *)image_comp->data);
          }
        }
#line 84
        compno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 90
      free((void *)image->comps);
      }
    }
#line 93
    if (image->icc_profile_buf) {
      {
#line 94
      free((void *)image->icc_profile_buf);
      }
    }
    {
#line 97
    free((void *)image);
    }
  }
#line 100
  return;
}
}
#line 107 "/root/patchweave_new/10/src/lib/openjp2/image.c"
void opj_image_comp_header_update(opj_image_t *p_image_header , struct opj_cp *p_cp ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_INT32 l_x0 ;
  OPJ_INT32 l_y0 ;
  OPJ_INT32 l_x1 ;
  OPJ_INT32 l_y1 ;
  OPJ_INT32 l_comp_x0 ;
  OPJ_INT32 l_comp_y0 ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  opj_image_comp_t *l_img_comp ;
  OPJ_INT32 __cil_tmp23 ;
  OPJ_INT32 __cil_tmp24 ;

  {
  {
#line 112
  l_img_comp = (opj_image_comp_t *)((void *)0);
#line 114
  l_x0 = opj_int_max((OPJ_INT32 )p_cp->tx0, (OPJ_INT32 )p_image_header->x0);
#line 115
  l_y0 = opj_int_max((OPJ_INT32 )p_cp->ty0, (OPJ_INT32 )p_image_header->y0);
#line 116
  l_x1 = opj_int_min((OPJ_INT32 )(p_cp->tx0 + p_cp->tw * p_cp->tdx), (OPJ_INT32 )p_image_header->x1);
#line 117
  l_y1 = opj_int_min((OPJ_INT32 )(p_cp->ty0 + p_cp->th * p_cp->tdy), (OPJ_INT32 )p_image_header->y1);
#line 119
  l_img_comp = p_image_header->comps;
#line 120
  i = (OPJ_UINT32 )0;
  }
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;

#line 120
    if (! (i < p_image_header->numcomps)) {
#line 120
      goto while_break;
    }
    {
#line 121
    l_comp_x0 = opj_int_ceildiv(l_x0, (OPJ_INT32 )l_img_comp->dx);
#line 122
    l_comp_y0 = opj_int_ceildiv(l_y0, (OPJ_INT32 )l_img_comp->dy);
#line 123
    l_comp_x1 = opj_int_ceildiv(l_x1, (OPJ_INT32 )l_img_comp->dx);
#line 124
    l_comp_y1 = opj_int_ceildiv(l_y1, (OPJ_INT32 )l_img_comp->dy);
#line 125
    __cil_tmp23 = opj_int_ceildivpow2(l_comp_x1 - l_comp_x0, (OPJ_INT32 )l_img_comp->factor);
#line 125
    l_width = (OPJ_UINT32 )__cil_tmp23;
#line 126
    __cil_tmp24 = opj_int_ceildivpow2(l_comp_y1 - l_comp_y0, (OPJ_INT32 )l_img_comp->factor);
#line 126
    l_height = (OPJ_UINT32 )__cil_tmp24;
#line 127
    l_img_comp->w = l_width;
#line 128
    l_img_comp->h = l_height;
#line 129
    l_img_comp->x0 = (OPJ_UINT32 )l_comp_x0;
#line 130
    l_img_comp->y0 = (OPJ_UINT32 )l_comp_y0;
#line 131
    l_img_comp ++;
#line 120
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 124
  return;
}
}
#line 144 "/root/patchweave_new/10/src/lib/openjp2/image.c"
void opj_copy_image_header(opj_image_t *p_image_src , opj_image_t *p_image_dest ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_comp_t *image_comp ;
  void *__cil_tmp8 ;
  void *__cil_tmp10 ;

  {
#line 152
  p_image_dest->x0 = p_image_src->x0;
#line 153
  p_image_dest->y0 = p_image_src->y0;
#line 154
  p_image_dest->x1 = p_image_src->x1;
#line 155
  p_image_dest->y1 = p_image_src->y1;
#line 157
  if (p_image_dest->comps) {
#line 158
    compno = (OPJ_UINT32 )0;
    {
#line 158
    while (1) {
      while_continue: /* CIL Label */ ;

#line 158
      if (! (compno < p_image_dest->numcomps)) {
#line 158
        goto while_break;
      }
#line 159
      image_comp = p_image_dest->comps + compno;
#line 160
      if (image_comp->data) {
        {
#line 161
        free((void *)image_comp->data);
        }
      }
#line 158
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 164
    free((void *)p_image_dest->comps);
#line 165
    p_image_dest->comps = (opj_image_comp_t *)((void *)0);
    }
  }
  {
#line 168
  p_image_dest->numcomps = p_image_src->numcomps;
#line 170
  __cil_tmp8 = malloc((unsigned long )p_image_dest->numcomps * sizeof(opj_image_comp_t ));
#line 170
  p_image_dest->comps = (opj_image_comp_t *)__cil_tmp8;
  }
#line 171
  if (! p_image_dest->comps) {
#line 172
    p_image_dest->comps = (opj_image_comp_t *)((void *)0);
#line 173
    p_image_dest->numcomps = (OPJ_UINT32 )0;
#line 174
    return;
  }
#line 177
  compno = (OPJ_UINT32 )0;
  {
#line 177
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 177
    if (! (compno < p_image_dest->numcomps)) {
#line 177
      goto while_break___0;
    }
    {
#line 178
    memcpy((void *)(p_image_dest->comps + compno), (void const   *)(p_image_src->comps + compno),
           sizeof(opj_image_comp_t ));
#line 181
    (p_image_dest->comps + compno)->data = (OPJ_INT32 *)((void *)0);
#line 177
    compno ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
#line 184
  p_image_dest->color_space = p_image_src->color_space;
#line 185
  p_image_dest->icc_profile_len = p_image_src->icc_profile_len;
#line 187
  if (p_image_dest->icc_profile_len) {
    {
#line 188
    __cil_tmp10 = malloc((unsigned long )p_image_dest->icc_profile_len);
#line 188
    p_image_dest->icc_profile_buf = (OPJ_BYTE *)__cil_tmp10;
    }
#line 189
    if (! p_image_dest->icc_profile_buf) {
#line 190
      p_image_dest->icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 191
      p_image_dest->icc_profile_len = (OPJ_UINT32 )0;
#line 192
      return;
    }
    {
#line 194
    memcpy((void *)p_image_dest->icc_profile_buf, (void const   *)p_image_src->icc_profile_buf,
           (unsigned long )p_image_src->icc_profile_len);
    }
  } else {
#line 199
    p_image_dest->icc_profile_buf = (OPJ_BYTE *)((void *)0);
  }
#line 201
  return;
}
}
#line 204 "/root/patchweave_new/10/src/lib/openjp2/image.c"
opj_image_t *opj_image_tile_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                                   OPJ_COLOR_SPACE clrspc ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_t *image ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_image_comp_t *comp ;

  {
  {
#line 206
  image = (opj_image_t *)0;
#line 208
  __cil_tmp6 = calloc(1UL, sizeof(opj_image_t ));
#line 208
  image = (opj_image_t *)__cil_tmp6;
  }
#line 209
  if (image) {
    {
#line 212
    image->color_space = clrspc;
#line 213
    image->numcomps = numcmpts;
#line 216
    __cil_tmp7 = calloc((unsigned long )image->numcomps, sizeof(opj_image_comp_t ));
#line 216
    image->comps = (opj_image_comp_t *)__cil_tmp7;
    }
#line 217
    if (! image->comps) {
      {
#line 218
      opj_image_destroy(image);
      }
#line 219
      return ((opj_image_t *)0);
    }
#line 223
    compno = (OPJ_UINT32 )0;
    {
#line 223
    while (1) {
      while_continue: /* CIL Label */ ;

#line 223
      if (! (compno < numcmpts)) {
#line 223
        goto while_break;
      }
#line 224
      comp = image->comps + compno;
#line 225
      comp->dx = (cmptparms + compno)->dx;
#line 226
      comp->dy = (cmptparms + compno)->dy;
#line 227
      comp->w = (cmptparms + compno)->w;
#line 228
      comp->h = (cmptparms + compno)->h;
#line 229
      comp->x0 = (cmptparms + compno)->x0;
#line 230
      comp->y0 = (cmptparms + compno)->y0;
#line 231
      comp->prec = (cmptparms + compno)->prec;
#line 232
      comp->sgnd = (cmptparms + compno)->sgnd;
#line 233
      comp->data = (OPJ_INT32 *)0;
#line 223
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 237
  return (image);
}
}
#line 39 "/root/patchweave_new/10/src/lib/openjp2/function_list.c"
opj_procedure_list_t *opj_procedure_list_create(void) 
{ 
  opj_procedure_list_t *l_validation ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 42
  __cil_tmp2 = calloc(1UL, sizeof(opj_procedure_list_t ));
#line 42
  l_validation = (opj_procedure_list_t *)__cil_tmp2;
  }
#line 43
  if (! l_validation) {
#line 45
    return ((opj_procedure_list_t *)0);
  }
  {
#line 48
  l_validation->m_nb_max_procedures = (OPJ_UINT32 )10;
#line 49
  __cil_tmp3 = calloc(10UL, sizeof(void (*)(void)));
#line 49
  l_validation->m_procedures = (opj_procedure *)__cil_tmp3;
  }
#line 50
  if (! l_validation->m_procedures) {
    {
#line 52
    free((void *)l_validation);
    }
#line 53
    return ((opj_procedure_list_t *)0);
  }
#line 55
  return (l_validation);
}
}
#line 58 "/root/patchweave_new/10/src/lib/openjp2/function_list.c"
void opj_procedure_list_destroy(opj_procedure_list_t *p_list ) 
{ 


  {
#line 60
  if (! p_list) {
#line 62
    return;
  }
#line 65
  if (p_list->m_procedures) {
    {
#line 67
    free((void *)p_list->m_procedures);
    }
  }
  {
#line 69
  free((void *)p_list);
  }
#line 71
  return;
}
}
#line 72 "/root/patchweave_new/10/src/lib/openjp2/function_list.c"
OPJ_BOOL opj_procedure_list_add_procedure(opj_procedure_list_t *p_validation_list ,
                                          void (*p_procedure)(void) ) 
{ 
  opj_procedure *new_procedures ;
  void *__cil_tmp4 ;

  {
#line 74
  if (p_validation_list->m_nb_max_procedures == p_validation_list->m_nb_procedures) {
    {
#line 78
    p_validation_list->m_nb_max_procedures += 10U;
#line 79
    __cil_tmp4 = realloc((void *)p_validation_list->m_procedures, (unsigned long )p_validation_list->m_nb_max_procedures * sizeof(void (*)(void)));
#line 79
    new_procedures = (opj_procedure *)__cil_tmp4;
    }
#line 82
    if (! new_procedures) {
      {
#line 84
      free((void *)p_validation_list->m_procedures);
#line 85
      p_validation_list->m_nb_max_procedures = (OPJ_UINT32 )0;
#line 86
      p_validation_list->m_nb_procedures = (OPJ_UINT32 )0;
#line 88
      fprintf(stderr, "Not enough memory to add a new validation procedure\n");
      }
#line 90
      return (0);
    } else {
#line 94
      p_validation_list->m_procedures = new_procedures;
    }
  }
#line 97
  *(p_validation_list->m_procedures + p_validation_list->m_nb_procedures) = p_procedure;
#line 98
  (p_validation_list->m_nb_procedures) ++;
#line 100
  return (1);
}
}
#line 103 "/root/patchweave_new/10/src/lib/openjp2/function_list.c"
OPJ_UINT32 opj_procedure_list_get_nb_procedures(opj_procedure_list_t *p_validation_list ) 
{ 


  {
#line 105
  return (p_validation_list->m_nb_procedures);
}
}
#line 108 "/root/patchweave_new/10/src/lib/openjp2/function_list.c"
opj_procedure *opj_procedure_list_get_first_procedure(opj_procedure_list_t *p_validation_list ) 
{ 


  {
#line 110
  return (p_validation_list->m_procedures);
}
}
#line 113 "/root/patchweave_new/10/src/lib/openjp2/function_list.c"
void opj_procedure_list_clear(opj_procedure_list_t *p_validation_list ) 
{ 


  {
#line 115
  p_validation_list->m_nb_procedures = (OPJ_UINT32 )0;
#line 116
  return;
}
}
#line 76 "/root/patchweave_new/10/src/lib/openjp2/event.c"
static void opj_default_callback(char const   *msg , void *client_data ) 
{ 


  {
#line 81
  return;
}
}
#line 86 "/root/patchweave_new/10/src/lib/openjp2/event.c"
OPJ_BOOL opj_event_msg(opj_event_mgr_t *p_event_mgr , OPJ_INT32 event_type , char const   *fmt 
                       , ...) 
{ 
  void (*msg_handler)(char const   * , void * ) ;
  void *l_data ;
  va_list arg ;
  size_t str_length ;
  char message[512] ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long tmp ;

  {
#line 88
  msg_handler = (void (*)(char const   * , void * ))0;
#line 89
  l_data = (void *)0;
#line 91
  if ((unsigned long )p_event_mgr != (unsigned long )((opj_event_mgr_t *)0)) {
#line 93
    if (event_type == 1) {
#line 93
      goto case_1;
    }
#line 97
    if (event_type == 2) {
#line 97
      goto case_2;
    }
#line 101
    if (event_type == 4) {
#line 101
      goto case_4;
    }
#line 105
    goto switch_default;
    case_1: 
#line 94
    msg_handler = p_event_mgr->error_handler;
#line 95
    l_data = p_event_mgr->m_error_data;
#line 96
    goto switch_break;
    case_2: 
#line 98
    msg_handler = p_event_mgr->warning_handler;
#line 99
    l_data = p_event_mgr->m_warning_data;
#line 100
    goto switch_break;
    case_4: 
#line 102
    msg_handler = p_event_mgr->info_handler;
#line 103
    l_data = p_event_mgr->m_info_data;
#line 104
    goto switch_break;
    switch_default: 
#line 106
    goto switch_break;
    switch_break: ;
#line 108
    if ((unsigned long )msg_handler == (unsigned long )((void (*)(char const   * ,
                                                                  void * ))0)) {
#line 109
      return (0);
    }
  } else {
#line 112
    return (0);
  }
#line 115
  if ((unsigned long )fmt != (unsigned long )((char const   *)0)) {
#line 115
    if ((unsigned long )p_event_mgr != (unsigned long )((opj_event_mgr_t *)0)) {
      {
#line 119
      memset((void *)(message), 0, 512UL);
#line 121
      __builtin_va_start((__builtin_va_list )((void *)arg), fmt);
#line 123
      __cil_tmp9 = strlen(fmt);
      }
#line 123
      if (__cil_tmp9 > 512UL) {
#line 123
        tmp = 512UL;
      } else {
        {
#line 123
        __cil_tmp10 = strlen(fmt);
#line 123
        tmp = __cil_tmp10;
        }
      }
      {
#line 123
      str_length = tmp;
#line 126
      vsnprintf(message, 512UL, fmt, (__gnuc_va_list )((void *)arg));
#line 128
      __builtin_va_end((__builtin_va_list )((void *)arg));
#line 131
      (*msg_handler)((char const   *)(message), l_data);
      }
    }
  }
#line 134
  return (1);
}
}
#line 137 "/root/patchweave_new/10/src/lib/openjp2/event.c"
void opj_set_default_event_handler(opj_event_mgr_t *p_manager ) 
{ 


  {
#line 139
  p_manager->m_error_data = (void *)0;
#line 140
  p_manager->m_warning_data = (void *)0;
#line 141
  p_manager->m_info_data = (void *)0;
#line 142
  p_manager->error_handler = & opj_default_callback;
#line 143
  p_manager->info_handler = & opj_default_callback;
#line 144
  p_manager->warning_handler = & opj_default_callback;
#line 145
  return;
}
}
#line 73 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
static OPJ_FLOAT32 opj_dwt_alpha  =    1.58613431454f;
#line 74 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
static OPJ_FLOAT32 opj_dwt_beta  =    0.0529801174999f;
#line 75 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
static OPJ_FLOAT32 opj_dwt_gamma  =    - 0.882911086083f;
#line 76 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
static OPJ_FLOAT32 opj_dwt_delta  =    - 0.443506866694f;
#line 78 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
static OPJ_FLOAT32 opj_K  =    1.23017406464f;
#line 79 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
static OPJ_FLOAT32 opj_c13318  =    1.62573242188f;
#line 94
void opj_dwt_deinterleave_h(OPJ_INT32 *a , OPJ_INT32 *b , OPJ_INT32 dn , OPJ_INT32 sn ,
                            OPJ_INT32 cas ) ;
#line 98
void opj_dwt_deinterleave_v(OPJ_INT32 *a , OPJ_INT32 *b , OPJ_INT32 dn , OPJ_INT32 sn ,
                            OPJ_INT32 x , OPJ_INT32 cas ) ;
#line 102
void opj_dwt_interleave_h(opj_dwt_t *h , OPJ_INT32 *a ) ;
#line 106
void opj_dwt_interleave_v(opj_dwt_t *v , OPJ_INT32 *a , OPJ_INT32 x ) ;
#line 110
void opj_dwt_encode_1(OPJ_INT32 *a , OPJ_INT32 dn , OPJ_INT32 sn , OPJ_INT32 cas ) ;
#line 114
void opj_dwt_decode_1(opj_dwt_t *v ) ;
#line 115
void opj_dwt_decode_1_(OPJ_INT32 *a , OPJ_INT32 dn , OPJ_INT32 sn , OPJ_INT32 cas ) ;
#line 119
void opj_dwt_encode_1_real(OPJ_INT32 *a , OPJ_INT32 dn , OPJ_INT32 sn , OPJ_INT32 cas ) ;
#line 123
void opj_dwt_encode_stepsize(OPJ_INT32 stepsize , OPJ_INT32 numbps , opj_stepsize_t *bandno_stepsize ) ;
#line 127
OPJ_BOOL opj_dwt_decode_tile(opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres , void (*dwt_1D)(opj_dwt_t * ) ) ;
#line 129
__inline OPJ_BOOL opj_dwt_encode_procedure(opj_tcd_tilecomp_t *tilec , void (*p_function)(OPJ_INT32 * ,
                                                                                          OPJ_INT32  ,
                                                                                          OPJ_INT32  ,
                                                                                          OPJ_INT32  ) ) ;
#line 132
OPJ_UINT32 opj_dwt_max_resolution(opj_tcd_resolution_t *r , OPJ_UINT32 i ) ;
#line 137
void opj_v4dwt_decode(opj_v4dwt_t *dwt ) ;
#line 139
void opj_v4dwt_interleave_h(opj_v4dwt_t *w , OPJ_FLOAT32 *a , OPJ_INT32 x , OPJ_INT32 size ) ;
#line 141
void opj_v4dwt_interleave_v(opj_v4dwt_t *v , OPJ_FLOAT32 *a , OPJ_INT32 x , OPJ_INT32 nb_elts_read ) ;
#line 144
void opj_v4dwt_decode_step1_sse(opj_v4_t *w , OPJ_INT32 count , __m128 c ) ;
#line 146
void opj_v4dwt_decode_step2_sse(opj_v4_t *l , opj_v4_t *w , OPJ_INT32 k , OPJ_INT32 m ,
                                __m128 c ) ;
#line 170 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
static OPJ_FLOAT64 opj_dwt_norms[4][10]  = { {        1.,        1.5,        2.75,        5.375, 
            10.68,        21.34,        42.6700000001,        85.33, 
            170.7,        341.300000001}, 
   {        1.03800000001,        1.59200000001,        2.91900000001,        5.70300000001, 
            11.3300000001,        22.6400000001,        45.25,        90.4800000001, 
            180.900000001}, 
   {        1.03800000001,        1.59200000001,        2.91900000001,        5.70300000001, 
            11.3300000001,        22.6400000001,        45.25,        90.4800000001, 
            180.900000001}, 
   {        0.718600000001,        0.9218,        1.58600000001,        3.04300000001, 
            6.01900000001,        12.01,        24.,        47.97, 
            95.9300000001}};
#line 180 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
static OPJ_FLOAT64 opj_dwt_norms_real[4][10]  = { {        1.,        1.96500000001,        4.177,        8.40300000001, 
            16.9,        33.8400000001,        67.69,        135.300000001, 
            270.600000001,        540.9}, 
   {        2.022,        3.989,        8.35500000001,        17.04, 
            34.2700000001,        68.63,        137.300000001,        274.600000001, 
            549.}, 
   {        2.022,        3.989,        8.35500000001,        17.04, 
            34.2700000001,        68.63,        137.300000001,        274.600000001, 
            549.}, 
   {        2.08000000001,        3.86500000001,        8.30700000001,        17.18, 
            34.7100000001,        69.5900000001,        139.300000001,        278.600000001, 
            557.200000001}};
#line 196 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
void opj_dwt_deinterleave_h(OPJ_INT32 *a , OPJ_INT32 *b , OPJ_INT32 dn , OPJ_INT32 sn ,
                            OPJ_INT32 cas ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 *l_dest ;
  OPJ_INT32 *l_src ;
  OPJ_INT32 *__cil_tmp9 ;
  OPJ_INT32 *__cil_tmp10 ;

  {
#line 198
  l_dest = b;
#line 199
  l_src = a + cas;
#line 201
  i = 0;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;

#line 201
    if (! (i < sn)) {
#line 201
      goto while_break;
    }
#line 202
    __cil_tmp9 = l_dest;
#line 202
    l_dest ++;
#line 202
    *__cil_tmp9 = *l_src;
#line 203
    l_src += 2;
#line 201
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 206
  l_dest = b + sn;
#line 207
  l_src = (a + 1) - cas;
#line 209
  i = 0;
  {
#line 209
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 209
    if (! (i < dn)) {
#line 209
      goto while_break___0;
    }
#line 210
    __cil_tmp10 = l_dest;
#line 210
    l_dest ++;
#line 210
    *__cil_tmp10 = *l_src;
#line 211
    l_src += 2;
#line 209
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 213
  return;
}
}
#line 218 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
void opj_dwt_deinterleave_v(OPJ_INT32 *a , OPJ_INT32 *b , OPJ_INT32 dn , OPJ_INT32 sn ,
                            OPJ_INT32 x , OPJ_INT32 cas ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 *l_dest ;
  OPJ_INT32 *l_src ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_INT32 __cil_tmp11 ;

  {
#line 219
  i = sn;
#line 220
  l_dest = b;
#line 221
  l_src = a + cas;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    __cil_tmp10 = i;
#line 223
    i --;
#line 223
    if (! __cil_tmp10) {
#line 223
      goto while_break;
    }
#line 224
    *l_dest = *l_src;
#line 225
    l_dest += x;
#line 226
    l_src += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 229
  l_dest = b + sn * x;
#line 230
  l_src = (a + 1) - cas;
#line 232
  i = dn;
  {
#line 233
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 233
    __cil_tmp11 = i;
#line 233
    i --;
#line 233
    if (! __cil_tmp11) {
#line 233
      goto while_break___0;
    }
#line 234
    *l_dest = *l_src;
#line 235
    l_dest += x;
#line 236
    l_src += 2;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 240
  return;
}
}
#line 243 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
void opj_dwt_interleave_h(opj_dwt_t *h , OPJ_INT32 *a ) 
{ 
  OPJ_INT32 *ai ;
  OPJ_INT32 *bi ;
  OPJ_INT32 i ;
  OPJ_INT32 __cil_tmp6 ;
  OPJ_INT32 *__cil_tmp7 ;
  OPJ_INT32 __cil_tmp8 ;
  OPJ_INT32 *__cil_tmp9 ;

  {
#line 244
  ai = a;
#line 245
  bi = h->mem + h->cas;
#line 246
  i = h->sn;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    __cil_tmp6 = i;
#line 247
    i --;
#line 247
    if (! __cil_tmp6) {
#line 247
      goto while_break;
    }
#line 248
    __cil_tmp7 = ai;
#line 248
    ai ++;
#line 248
    *bi = *__cil_tmp7;
#line 249
    bi += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 251
  ai = a + h->sn;
#line 252
  bi = (h->mem + 1) - h->cas;
#line 253
  i = h->dn;
  {
#line 254
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 254
    __cil_tmp8 = i;
#line 254
    i --;
#line 254
    if (! __cil_tmp8) {
#line 254
      goto while_break___0;
    }
#line 255
    __cil_tmp9 = ai;
#line 255
    ai ++;
#line 255
    *bi = *__cil_tmp9;
#line 256
    bi += 2;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 260
  return;
}
}
#line 263 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
void opj_dwt_interleave_v(opj_dwt_t *v , OPJ_INT32 *a , OPJ_INT32 x ) 
{ 
  OPJ_INT32 *ai ;
  OPJ_INT32 *bi ;
  OPJ_INT32 i ;
  OPJ_INT32 __cil_tmp7 ;
  OPJ_INT32 __cil_tmp8 ;

  {
#line 264
  ai = a;
#line 265
  bi = v->mem + v->cas;
#line 266
  i = v->sn;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    __cil_tmp7 = i;
#line 267
    i --;
#line 267
    if (! __cil_tmp7) {
#line 267
      goto while_break;
    }
#line 268
    *bi = *ai;
#line 269
    bi += 2;
#line 270
    ai += x;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 272
  ai = a + v->sn * x;
#line 273
  bi = (v->mem + 1) - v->cas;
#line 274
  i = v->dn;
  {
#line 275
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 275
    __cil_tmp8 = i;
#line 275
    i --;
#line 275
    if (! __cil_tmp8) {
#line 275
      goto while_break___0;
    }
#line 276
    *bi = *ai;
#line 277
    bi += 2;
#line 278
    ai += x;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 282
  return;
}
}
#line 286 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
void opj_dwt_encode_1(OPJ_INT32 *a , OPJ_INT32 dn , OPJ_INT32 sn , OPJ_INT32 cas ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 tmp ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 tmp___1 ;
  OPJ_INT32 tmp___2 ;
  OPJ_INT32 tmp___3 ;
  OPJ_INT32 tmp___4 ;
  OPJ_INT32 tmp___5 ;
  OPJ_INT32 tmp___6 ;
  OPJ_INT32 tmp___7 ;
  OPJ_INT32 tmp___8 ;
  OPJ_INT32 tmp___9 ;
  OPJ_INT32 tmp___10 ;
  OPJ_INT32 tmp___11 ;
  OPJ_INT32 tmp___12 ;
  OPJ_INT32 tmp___13 ;
  OPJ_INT32 tmp___14 ;

  {
#line 289
  if (! cas) {
#line 290
    if (dn > 0) {
      _L: 
#line 291
      i = 0;
      {
#line 291
      while (1) {
        while_continue: /* CIL Label */ ;

#line 291
        if (! (i < dn)) {
#line 291
          goto while_break;
        }
#line 291
        if (i + 1 < 0) {
#line 291
          tmp___2 = *(a + 0);
        } else {
#line 291
          if (i + 1 >= sn) {
#line 291
            tmp___1 = *(a + (sn - 1) * 2);
          } else {
#line 291
            tmp___1 = *(a + (i + 1) * 2);
          }
#line 291
          tmp___2 = tmp___1;
        }
#line 291
        if (i < 0) {
#line 291
          tmp___0 = *(a + 0);
        } else {
#line 291
          if (i >= sn) {
#line 291
            tmp = *(a + (sn - 1) * 2);
          } else {
#line 291
            tmp = *(a + i * 2);
          }
#line 291
          tmp___0 = tmp;
        }
#line 291
        *(a + (1 + i * 2)) -= (tmp___0 + tmp___2) >> 1;
#line 291
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break: 
#line 292
      i = 0;
      {
#line 292
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 292
        if (! (i < sn)) {
#line 292
          goto while_break___0;
        }
#line 292
        if (i < 0) {
#line 292
          tmp___6 = *(a + 1);
        } else {
#line 292
          if (i >= dn) {
#line 292
            tmp___5 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 292
            tmp___5 = *(a + (1 + i * 2));
          }
#line 292
          tmp___6 = tmp___5;
        }
#line 292
        if (i - 1 < 0) {
#line 292
          tmp___4 = *(a + 1);
        } else {
#line 292
          if (i - 1 >= dn) {
#line 292
            tmp___3 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 292
            tmp___3 = *(a + (1 + (i - 1) * 2));
          }
#line 292
          tmp___4 = tmp___3;
        }
#line 292
        *(a + i * 2) += ((tmp___4 + tmp___6) + 2) >> 2;
#line 292
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: ;
    } else
#line 290
    if (sn > 1) {
#line 290
      goto _L;
    }
  } else
#line 295
  if (! sn) {
#line 295
    if (dn == 1) {
#line 296
      *(a + 0) *= 2;
    } else {
#line 295
      goto _L___14;
    }
  } else {
    _L___14: 
#line 298
    i = 0;
    {
#line 298
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 298
      if (! (i < dn)) {
#line 298
        goto while_break___1;
      }
#line 298
      if (i - 1 < 0) {
#line 298
        tmp___10 = *(a + 1);
      } else {
#line 298
        if (i - 1 >= sn) {
#line 298
          tmp___9 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 298
          tmp___9 = *(a + (1 + (i - 1) * 2));
        }
#line 298
        tmp___10 = tmp___9;
      }
#line 298
      if (i < 0) {
#line 298
        tmp___8 = *(a + 1);
      } else {
#line 298
        if (i >= sn) {
#line 298
          tmp___7 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 298
          tmp___7 = *(a + (1 + i * 2));
        }
#line 298
        tmp___8 = tmp___7;
      }
#line 298
      *(a + i * 2) -= (tmp___8 + tmp___10) >> 1;
#line 298
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 299
    i = 0;
    {
#line 299
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 299
      if (! (i < sn)) {
#line 299
        goto while_break___2;
      }
#line 299
      if (i + 1 < 0) {
#line 299
        tmp___14 = *(a + 0);
      } else {
#line 299
        if (i + 1 >= dn) {
#line 299
          tmp___13 = *(a + (dn - 1) * 2);
        } else {
#line 299
          tmp___13 = *(a + (i + 1) * 2);
        }
#line 299
        tmp___14 = tmp___13;
      }
#line 299
      if (i < 0) {
#line 299
        tmp___12 = *(a + 0);
      } else {
#line 299
        if (i >= dn) {
#line 299
          tmp___11 = *(a + (dn - 1) * 2);
        } else {
#line 299
          tmp___11 = *(a + i * 2);
        }
#line 299
        tmp___12 = tmp___11;
      }
#line 299
      *(a + (1 + i * 2)) += ((tmp___12 + tmp___14) + 2) >> 2;
#line 299
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 304
  return;
}
}
#line 307 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
void opj_dwt_decode_1_(OPJ_INT32 *a , OPJ_INT32 dn , OPJ_INT32 sn , OPJ_INT32 cas ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 tmp ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 tmp___1 ;
  OPJ_INT32 tmp___2 ;
  OPJ_INT32 tmp___3 ;
  OPJ_INT32 tmp___4 ;
  OPJ_INT32 tmp___5 ;
  OPJ_INT32 tmp___6 ;
  OPJ_INT32 tmp___7 ;
  OPJ_INT32 tmp___8 ;
  OPJ_INT32 tmp___9 ;
  OPJ_INT32 tmp___10 ;
  OPJ_INT32 tmp___11 ;
  OPJ_INT32 tmp___12 ;
  OPJ_INT32 tmp___13 ;
  OPJ_INT32 tmp___14 ;

  {
#line 310
  if (! cas) {
#line 311
    if (dn > 0) {
      _L: 
#line 312
      i = 0;
      {
#line 312
      while (1) {
        while_continue: /* CIL Label */ ;

#line 312
        if (! (i < sn)) {
#line 312
          goto while_break;
        }
#line 312
        if (i < 0) {
#line 312
          tmp___2 = *(a + 1);
        } else {
#line 312
          if (i >= dn) {
#line 312
            tmp___1 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 312
            tmp___1 = *(a + (1 + i * 2));
          }
#line 312
          tmp___2 = tmp___1;
        }
#line 312
        if (i - 1 < 0) {
#line 312
          tmp___0 = *(a + 1);
        } else {
#line 312
          if (i - 1 >= dn) {
#line 312
            tmp = *(a + (1 + (dn - 1) * 2));
          } else {
#line 312
            tmp = *(a + (1 + (i - 1) * 2));
          }
#line 312
          tmp___0 = tmp;
        }
#line 312
        *(a + i * 2) -= ((tmp___0 + tmp___2) + 2) >> 2;
#line 312
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break: 
#line 313
      i = 0;
      {
#line 313
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 313
        if (! (i < dn)) {
#line 313
          goto while_break___0;
        }
#line 313
        if (i + 1 < 0) {
#line 313
          tmp___6 = *(a + 0);
        } else {
#line 313
          if (i + 1 >= sn) {
#line 313
            tmp___5 = *(a + (sn - 1) * 2);
          } else {
#line 313
            tmp___5 = *(a + (i + 1) * 2);
          }
#line 313
          tmp___6 = tmp___5;
        }
#line 313
        if (i < 0) {
#line 313
          tmp___4 = *(a + 0);
        } else {
#line 313
          if (i >= sn) {
#line 313
            tmp___3 = *(a + (sn - 1) * 2);
          } else {
#line 313
            tmp___3 = *(a + i * 2);
          }
#line 313
          tmp___4 = tmp___3;
        }
#line 313
        *(a + (1 + i * 2)) += (tmp___4 + tmp___6) >> 1;
#line 313
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: ;
    } else
#line 311
    if (sn > 1) {
#line 311
      goto _L;
    }
  } else
#line 316
  if (! sn) {
#line 316
    if (dn == 1) {
#line 317
      *(a + 0) /= 2;
    } else {
#line 316
      goto _L___15;
    }
  } else {
    _L___15: 
#line 319
    i = 0;
    {
#line 319
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 319
      if (! (i < sn)) {
#line 319
        goto while_break___1;
      }
#line 319
      if (i + 1 < 0) {
#line 319
        tmp___10 = *(a + 0);
      } else {
#line 319
        if (i + 1 >= dn) {
#line 319
          tmp___9 = *(a + (dn - 1) * 2);
        } else {
#line 319
          tmp___9 = *(a + (i + 1) * 2);
        }
#line 319
        tmp___10 = tmp___9;
      }
#line 319
      if (i < 0) {
#line 319
        tmp___8 = *(a + 0);
      } else {
#line 319
        if (i >= dn) {
#line 319
          tmp___7 = *(a + (dn - 1) * 2);
        } else {
#line 319
          tmp___7 = *(a + i * 2);
        }
#line 319
        tmp___8 = tmp___7;
      }
#line 319
      *(a + (1 + i * 2)) -= ((tmp___8 + tmp___10) + 2) >> 2;
#line 319
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 320
    i = 0;
    {
#line 320
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 320
      if (! (i < dn)) {
#line 320
        goto while_break___2;
      }
#line 320
      if (i - 1 < 0) {
#line 320
        tmp___14 = *(a + 1);
      } else {
#line 320
        if (i - 1 >= sn) {
#line 320
          tmp___13 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 320
          tmp___13 = *(a + (1 + (i - 1) * 2));
        }
#line 320
        tmp___14 = tmp___13;
      }
#line 320
      if (i < 0) {
#line 320
        tmp___12 = *(a + 1);
      } else {
#line 320
        if (i >= sn) {
#line 320
          tmp___11 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 320
          tmp___11 = *(a + (1 + i * 2));
        }
#line 320
        tmp___12 = tmp___11;
      }
#line 320
      *(a + i * 2) += (tmp___12 + tmp___14) >> 1;
#line 320
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 325
  return;
}
}
#line 328 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
void opj_dwt_decode_1(opj_dwt_t *v ) 
{ 


  {
  {
#line 329
  opj_dwt_decode_1_(v->mem, v->dn, v->sn, v->cas);
  }
#line 331
  return;
}
}
#line 335 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
void opj_dwt_encode_1_real(OPJ_INT32 *a , OPJ_INT32 dn , OPJ_INT32 sn , OPJ_INT32 cas ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 tmp ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 tmp___1 ;
  OPJ_INT32 tmp___2 ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_INT32 tmp___3 ;
  OPJ_INT32 tmp___4 ;
  OPJ_INT32 tmp___5 ;
  OPJ_INT32 tmp___6 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 tmp___7 ;
  OPJ_INT32 tmp___8 ;
  OPJ_INT32 tmp___9 ;
  OPJ_INT32 tmp___10 ;
  OPJ_INT32 __cil_tmp22 ;
  OPJ_INT32 tmp___11 ;
  OPJ_INT32 tmp___12 ;
  OPJ_INT32 tmp___13 ;
  OPJ_INT32 tmp___14 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 tmp___15 ;
  OPJ_INT32 tmp___16 ;
  OPJ_INT32 tmp___17 ;
  OPJ_INT32 tmp___18 ;
  OPJ_INT32 __cil_tmp38 ;
  OPJ_INT32 tmp___19 ;
  OPJ_INT32 tmp___20 ;
  OPJ_INT32 tmp___21 ;
  OPJ_INT32 tmp___22 ;
  OPJ_INT32 __cil_tmp44 ;
  OPJ_INT32 tmp___23 ;
  OPJ_INT32 tmp___24 ;
  OPJ_INT32 tmp___25 ;
  OPJ_INT32 tmp___26 ;
  OPJ_INT32 __cil_tmp50 ;
  OPJ_INT32 tmp___27 ;
  OPJ_INT32 tmp___28 ;
  OPJ_INT32 tmp___29 ;
  OPJ_INT32 tmp___30 ;
  OPJ_INT32 __cil_tmp56 ;

  {
#line 337
  if (! cas) {
#line 338
    if (dn > 0) {
      _L: 
#line 339
      i = 0;
      {
#line 339
      while (1) {
        while_continue: /* CIL Label */ ;

#line 339
        if (! (i < dn)) {
#line 339
          goto while_break;
        }
#line 340
        if (i + 1 < 0) {
#line 340
          tmp___2 = *(a + 0);
        } else {
#line 340
          if (i + 1 >= sn) {
#line 340
            tmp___1 = *(a + (sn - 1) * 2);
          } else {
#line 340
            tmp___1 = *(a + (i + 1) * 2);
          }
#line 340
          tmp___2 = tmp___1;
        }
#line 340
        if (i < 0) {
#line 340
          tmp___0 = *(a + 0);
        } else {
#line 340
          if (i >= sn) {
#line 340
            tmp = *(a + (sn - 1) * 2);
          } else {
#line 340
            tmp = *(a + i * 2);
          }
#line 340
          tmp___0 = tmp;
        }
        {
#line 340
        __cil_tmp10 = opj_int_fix_mul(tmp___0 + tmp___2, 12993);
#line 340
        *(a + (1 + i * 2)) -= __cil_tmp10;
#line 339
        i ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break: 
#line 341
      i = 0;
      {
#line 341
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 341
        if (! (i < sn)) {
#line 341
          goto while_break___0;
        }
#line 342
        if (i < 0) {
#line 342
          tmp___6 = *(a + 1);
        } else {
#line 342
          if (i >= dn) {
#line 342
            tmp___5 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 342
            tmp___5 = *(a + (1 + i * 2));
          }
#line 342
          tmp___6 = tmp___5;
        }
#line 342
        if (i - 1 < 0) {
#line 342
          tmp___4 = *(a + 1);
        } else {
#line 342
          if (i - 1 >= dn) {
#line 342
            tmp___3 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 342
            tmp___3 = *(a + (1 + (i - 1) * 2));
          }
#line 342
          tmp___4 = tmp___3;
        }
        {
#line 342
        __cil_tmp16 = opj_int_fix_mul(tmp___4 + tmp___6, 434);
#line 342
        *(a + i * 2) -= __cil_tmp16;
#line 341
        i ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___0: 
#line 343
      i = 0;
      {
#line 343
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 343
        if (! (i < dn)) {
#line 343
          goto while_break___1;
        }
#line 344
        if (i + 1 < 0) {
#line 344
          tmp___10 = *(a + 0);
        } else {
#line 344
          if (i + 1 >= sn) {
#line 344
            tmp___9 = *(a + (sn - 1) * 2);
          } else {
#line 344
            tmp___9 = *(a + (i + 1) * 2);
          }
#line 344
          tmp___10 = tmp___9;
        }
#line 344
        if (i < 0) {
#line 344
          tmp___8 = *(a + 0);
        } else {
#line 344
          if (i >= sn) {
#line 344
            tmp___7 = *(a + (sn - 1) * 2);
          } else {
#line 344
            tmp___7 = *(a + i * 2);
          }
#line 344
          tmp___8 = tmp___7;
        }
        {
#line 344
        __cil_tmp22 = opj_int_fix_mul(tmp___8 + tmp___10, 7233);
#line 344
        *(a + (1 + i * 2)) += __cil_tmp22;
#line 343
        i ++;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___1: 
#line 345
      i = 0;
      {
#line 345
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 345
        if (! (i < sn)) {
#line 345
          goto while_break___2;
        }
#line 346
        if (i < 0) {
#line 346
          tmp___14 = *(a + 1);
        } else {
#line 346
          if (i >= dn) {
#line 346
            tmp___13 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 346
            tmp___13 = *(a + (1 + i * 2));
          }
#line 346
          tmp___14 = tmp___13;
        }
#line 346
        if (i - 1 < 0) {
#line 346
          tmp___12 = *(a + 1);
        } else {
#line 346
          if (i - 1 >= dn) {
#line 346
            tmp___11 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 346
            tmp___11 = *(a + (1 + (i - 1) * 2));
          }
#line 346
          tmp___12 = tmp___11;
        }
        {
#line 346
        __cil_tmp28 = opj_int_fix_mul(tmp___12 + tmp___14, 3633);
#line 346
        *(a + i * 2) += __cil_tmp28;
#line 345
        i ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___2: 
#line 347
      i = 0;
      {
#line 347
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 347
        if (! (i < dn)) {
#line 347
          goto while_break___3;
        }
        {
#line 348
        *(a + (1 + i * 2)) = opj_int_fix_mul(*(a + (1 + i * 2)), 5038);
#line 347
        i ++;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___3: 
#line 349
      i = 0;
      {
#line 349
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 349
        if (! (i < sn)) {
#line 349
          goto while_break___4;
        }
        {
#line 350
        *(a + i * 2) = opj_int_fix_mul(*(a + i * 2), 6659);
#line 349
        i ++;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___4: ;
    } else
#line 338
    if (sn > 1) {
#line 338
      goto _L;
    }
  } else
#line 353
  if (sn > 0) {
    _L___16: 
#line 354
    i = 0;
    {
#line 354
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 354
      if (! (i < dn)) {
#line 354
        goto while_break___5;
      }
#line 355
      if (i - 1 < 0) {
#line 355
        tmp___18 = *(a + 1);
      } else {
#line 355
        if (i - 1 >= sn) {
#line 355
          tmp___17 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 355
          tmp___17 = *(a + (1 + (i - 1) * 2));
        }
#line 355
        tmp___18 = tmp___17;
      }
#line 355
      if (i < 0) {
#line 355
        tmp___16 = *(a + 1);
      } else {
#line 355
        if (i >= sn) {
#line 355
          tmp___15 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 355
          tmp___15 = *(a + (1 + i * 2));
        }
#line 355
        tmp___16 = tmp___15;
      }
      {
#line 355
      __cil_tmp38 = opj_int_fix_mul(tmp___16 + tmp___18, 12993);
#line 355
      *(a + i * 2) -= __cil_tmp38;
#line 354
      i ++;
      }
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___5: 
#line 356
    i = 0;
    {
#line 356
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 356
      if (! (i < sn)) {
#line 356
        goto while_break___6;
      }
#line 357
      if (i + 1 < 0) {
#line 357
        tmp___22 = *(a + 0);
      } else {
#line 357
        if (i + 1 >= dn) {
#line 357
          tmp___21 = *(a + (dn - 1) * 2);
        } else {
#line 357
          tmp___21 = *(a + (i + 1) * 2);
        }
#line 357
        tmp___22 = tmp___21;
      }
#line 357
      if (i < 0) {
#line 357
        tmp___20 = *(a + 0);
      } else {
#line 357
        if (i >= dn) {
#line 357
          tmp___19 = *(a + (dn - 1) * 2);
        } else {
#line 357
          tmp___19 = *(a + i * 2);
        }
#line 357
        tmp___20 = tmp___19;
      }
      {
#line 357
      __cil_tmp44 = opj_int_fix_mul(tmp___20 + tmp___22, 434);
#line 357
      *(a + (1 + i * 2)) -= __cil_tmp44;
#line 356
      i ++;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___6: 
#line 358
    i = 0;
    {
#line 358
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 358
      if (! (i < dn)) {
#line 358
        goto while_break___7;
      }
#line 359
      if (i - 1 < 0) {
#line 359
        tmp___26 = *(a + 1);
      } else {
#line 359
        if (i - 1 >= sn) {
#line 359
          tmp___25 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 359
          tmp___25 = *(a + (1 + (i - 1) * 2));
        }
#line 359
        tmp___26 = tmp___25;
      }
#line 359
      if (i < 0) {
#line 359
        tmp___24 = *(a + 1);
      } else {
#line 359
        if (i >= sn) {
#line 359
          tmp___23 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 359
          tmp___23 = *(a + (1 + i * 2));
        }
#line 359
        tmp___24 = tmp___23;
      }
      {
#line 359
      __cil_tmp50 = opj_int_fix_mul(tmp___24 + tmp___26, 7233);
#line 359
      *(a + i * 2) += __cil_tmp50;
#line 358
      i ++;
      }
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___7: 
#line 360
    i = 0;
    {
#line 360
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 360
      if (! (i < sn)) {
#line 360
        goto while_break___8;
      }
#line 361
      if (i + 1 < 0) {
#line 361
        tmp___30 = *(a + 0);
      } else {
#line 361
        if (i + 1 >= dn) {
#line 361
          tmp___29 = *(a + (dn - 1) * 2);
        } else {
#line 361
          tmp___29 = *(a + (i + 1) * 2);
        }
#line 361
        tmp___30 = tmp___29;
      }
#line 361
      if (i < 0) {
#line 361
        tmp___28 = *(a + 0);
      } else {
#line 361
        if (i >= dn) {
#line 361
          tmp___27 = *(a + (dn - 1) * 2);
        } else {
#line 361
          tmp___27 = *(a + i * 2);
        }
#line 361
        tmp___28 = tmp___27;
      }
      {
#line 361
      __cil_tmp56 = opj_int_fix_mul(tmp___28 + tmp___30, 3633);
#line 361
      *(a + (1 + i * 2)) += __cil_tmp56;
#line 360
      i ++;
      }
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___8: 
#line 362
    i = 0;
    {
#line 362
    while (1) {
      while_continue___9: /* CIL Label */ ;

#line 362
      if (! (i < dn)) {
#line 362
        goto while_break___9;
      }
      {
#line 363
      *(a + i * 2) = opj_int_fix_mul(*(a + i * 2), 5038);
#line 362
      i ++;
      }
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___9: 
#line 364
    i = 0;
    {
#line 364
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 364
      if (! (i < sn)) {
#line 364
        goto while_break___10;
      }
      {
#line 365
      *(a + (1 + i * 2)) = opj_int_fix_mul(*(a + (1 + i * 2)), 6659);
#line 364
      i ++;
      }
    }
    while_break___22: /* CIL Label */ ;
    }
    while_break___10: ;
  } else
#line 353
  if (dn > 1) {
#line 353
    goto _L___16;
  }
#line 355
  return;
}
}
#line 370 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
void opj_dwt_encode_stepsize(OPJ_INT32 stepsize , OPJ_INT32 numbps , opj_stepsize_t *bandno_stepsize ) 
{ 
  OPJ_INT32 p ;
  OPJ_INT32 n ;
  OPJ_INT32 __cil_tmp6 ;
  OPJ_INT32 __cil_tmp7 ;
  OPJ_INT32 tmp ;

  {
  {
#line 372
  __cil_tmp6 = opj_int_floorlog2(stepsize);
#line 372
  p = __cil_tmp6 - 13;
#line 373
  __cil_tmp7 = opj_int_floorlog2(stepsize);
#line 373
  n = 11 - __cil_tmp7;
  }
#line 374
  if (n < 0) {
#line 374
    tmp = stepsize >> - n;
  } else {
#line 374
    tmp = stepsize << n;
  }
#line 374
  bandno_stepsize->mant = tmp & 2047;
#line 375
  bandno_stepsize->expn = numbps - p;
#line 376
  return;
}
}
#line 388 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
__inline OPJ_BOOL opj_dwt_encode_procedure(opj_tcd_tilecomp_t *tilec , void (*p_function)(OPJ_INT32 * ,
                                                                                          OPJ_INT32  ,
                                                                                          OPJ_INT32  ,
                                                                                          OPJ_INT32  ) ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 k ;
  OPJ_INT32 *a ;
  OPJ_INT32 *aj ;
  OPJ_INT32 *bj ;
  OPJ_INT32 w ;
  OPJ_INT32 l ;
  OPJ_INT32 rw ;
  OPJ_INT32 rh ;
  OPJ_UINT32 l_data_size ;
  opj_tcd_resolution_t *l_cur_res ;
  opj_tcd_resolution_t *l_last_res ;
  OPJ_UINT32 __cil_tmp16 ;
  void *__cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 rw1 ;
  OPJ_INT32 rh1 ;
  OPJ_INT32 cas_col ;
  OPJ_INT32 cas_row ;
  OPJ_INT32 dn ;
  OPJ_INT32 sn ;

  {
  {
#line 391
  a = (OPJ_INT32 *)0;
#line 392
  aj = (OPJ_INT32 *)0;
#line 393
  bj = (OPJ_INT32 *)0;
#line 400
  l_cur_res = (opj_tcd_resolution_t *)0;
#line 401
  l_last_res = (opj_tcd_resolution_t *)0;
#line 403
  w = tilec->x1 - tilec->x0;
#line 404
  l = (OPJ_INT32 )tilec->numresolutions - 1;
#line 405
  a = tilec->data;
#line 407
  l_cur_res = tilec->resolutions + l;
#line 408
  l_last_res = l_cur_res - 1;
#line 410
  __cil_tmp16 = opj_dwt_max_resolution(tilec->resolutions, tilec->numresolutions);
#line 410
  l_data_size = __cil_tmp16 * (OPJ_UINT32 )sizeof(OPJ_INT32 );
#line 411
  __cil_tmp17 = malloc((size_t )l_data_size);
#line 411
  bj = (OPJ_INT32 *)__cil_tmp17;
  }
#line 412
  if (! bj) {
#line 413
    return (0);
  }
#line 415
  i = l;
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    __cil_tmp18 = i;
#line 417
    i --;
#line 417
    if (! __cil_tmp18) {
#line 417
      goto while_break;
    }
#line 424
    rw = l_cur_res->x1 - l_cur_res->x0;
#line 425
    rh = l_cur_res->y1 - l_cur_res->y0;
#line 426
    rw1 = l_last_res->x1 - l_last_res->x0;
#line 427
    rh1 = l_last_res->y1 - l_last_res->y0;
#line 429
    cas_row = l_cur_res->x0 & 1;
#line 430
    cas_col = l_cur_res->y0 & 1;
#line 432
    sn = rh1;
#line 433
    dn = rh - rh1;
#line 434
    j = 0;
    {
#line 434
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 434
      if (! (j < rw)) {
#line 434
        goto while_break___0;
      }
#line 435
      aj = a + j;
#line 436
      k = 0;
      {
#line 436
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 436
        if (! (k < rh)) {
#line 436
          goto while_break___1;
        }
#line 437
        *(bj + k) = *(aj + k * w);
#line 436
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 440
      (*p_function)(bj, dn, sn, cas_col);
#line 442
      opj_dwt_deinterleave_v(bj, aj, dn, sn, w, cas_col);
#line 434
      j ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 445
    sn = rw1;
#line 446
    dn = rw - rw1;
#line 448
    j = 0;
    {
#line 448
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 448
      if (! (j < rh)) {
#line 448
        goto while_break___2;
      }
#line 449
      aj = a + j * w;
#line 450
      k = 0;
      {
#line 450
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 450
        if (! (k < rw)) {
#line 450
          goto while_break___3;
        }
#line 450
        *(bj + k) = *(aj + k);
#line 450
        k ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
      {
#line 451
      (*p_function)(bj, dn, sn, cas_row);
#line 452
      opj_dwt_deinterleave_h(bj, aj, dn, sn, cas_row);
#line 448
      j ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 455
    l_cur_res = l_last_res;
#line 457
    l_last_res --;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 460
  free((void *)bj);
  }
#line 461
  return (1);
}
}
#line 466 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
OPJ_BOOL opj_dwt_encode(opj_tcd_tilecomp_t *tilec ) 
{ 
  OPJ_BOOL __cil_tmp2 ;

  {
  {
#line 468
  __cil_tmp2 = opj_dwt_encode_procedure(tilec, & opj_dwt_encode_1);
  }
#line 468
  return (__cil_tmp2);
}
}
#line 474 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
OPJ_BOOL opj_dwt_decode(opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) 
{ 
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 475
  __cil_tmp3 = opj_dwt_decode_tile(tilec, numres, & opj_dwt_decode_1);
  }
#line 475
  return (__cil_tmp3);
}
}
#line 482 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
OPJ_UINT32 opj_dwt_getgain(OPJ_UINT32 orient ) 
{ 


  {
#line 483
  if (orient == 0U) {
#line 484
    return ((OPJ_UINT32 )0);
  }
#line 485
  if (orient == 1U) {
#line 486
    return ((OPJ_UINT32 )1);
  } else
#line 485
  if (orient == 2U) {
#line 486
    return ((OPJ_UINT32 )1);
  }
#line 487
  return ((OPJ_UINT32 )2);
}
}
#line 493 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
OPJ_FLOAT64 opj_dwt_getnorm(OPJ_UINT32 level , OPJ_UINT32 orient ) 
{ 


  {
#line 494
  return (opj_dwt_norms[orient][level]);
}
}
#line 500 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
OPJ_BOOL opj_dwt_encode_real(opj_tcd_tilecomp_t *tilec ) 
{ 
  OPJ_BOOL __cil_tmp2 ;

  {
  {
#line 502
  __cil_tmp2 = opj_dwt_encode_procedure(tilec, & opj_dwt_encode_1_real);
  }
#line 502
  return (__cil_tmp2);
}
}
#line 508 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
OPJ_UINT32 opj_dwt_getgain_real(OPJ_UINT32 orient ) 
{ 


  {
#line 510
  return ((OPJ_UINT32 )0);
}
}
#line 516 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
OPJ_FLOAT64 opj_dwt_getnorm_real(OPJ_UINT32 level , OPJ_UINT32 orient ) 
{ 


  {
#line 517
  return (opj_dwt_norms_real[orient][level]);
}
}
#line 520 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
void opj_dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , OPJ_UINT32 prec ) 
{ 
  OPJ_UINT32 numbands ;
  OPJ_UINT32 bandno ;
  OPJ_FLOAT64 stepsize ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 level ;
  OPJ_UINT32 orient ;
  OPJ_UINT32 gain ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  OPJ_FLOAT64 norm ;
  double __cil_tmp16 ;

  {
#line 522
  numbands = 3U * tccp->numresolutions - 2U;
#line 523
  bandno = (OPJ_UINT32 )0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;

#line 523
    if (! (bandno < numbands)) {
#line 523
      goto while_break;
    }
#line 527
    if (bandno == 0U) {
#line 527
      tmp = 0U;
    } else {
#line 527
      tmp = (bandno - 1U) / 3U + 1U;
    }
#line 527
    resno = tmp;
#line 528
    if (bandno == 0U) {
#line 528
      tmp___0 = 0U;
    } else {
#line 528
      tmp___0 = (bandno - 1U) % 3U + 1U;
    }
#line 528
    orient = tmp___0;
#line 529
    level = (tccp->numresolutions - 1U) - resno;
#line 530
    if (tccp->qmfbid == 0U) {
#line 530
      tmp___3 = 0;
    } else {
#line 530
      if (orient == 0U) {
#line 530
        tmp___2 = 0;
      } else {
#line 530
        if (orient == 1U) {
#line 530
          tmp___1 = 1;
        } else
#line 530
        if (orient == 2U) {
#line 530
          tmp___1 = 1;
        } else {
#line 530
          tmp___1 = 2;
        }
#line 530
        tmp___2 = tmp___1;
      }
#line 530
      tmp___3 = tmp___2;
    }
#line 530
    gain = (OPJ_UINT32 )tmp___3;
#line 531
    if (tccp->qntsty == 0U) {
#line 532
      stepsize = 1.;
    } else {
#line 534
      norm = opj_dwt_norms_real[orient][level];
#line 535
      stepsize = (double )(1 << gain) / norm;
    }
    {
#line 537
    __cil_tmp16 = floor(stepsize * 8192.);
#line 537
    opj_dwt_encode_stepsize((OPJ_INT32 )__cil_tmp16, (OPJ_INT32 )(prec + gain), & tccp->stepsizes[bandno]);
#line 523
    bandno ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 527
  return;
}
}
#line 544 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
OPJ_UINT32 opj_dwt_max_resolution(opj_tcd_resolution_t *r , OPJ_UINT32 i ) 
{ 
  OPJ_UINT32 mr ;
  OPJ_UINT32 w ;

  {
#line 545
  mr = (OPJ_UINT32 )0;
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    i --;
#line 547
    if (! i) {
#line 547
      goto while_break;
    }
#line 548
    r ++;
#line 549
    w = (OPJ_UINT32 )(r->x1 - r->x0);
#line 549
    if (mr < w) {
#line 550
      mr = w;
    }
#line 551
    w = (OPJ_UINT32 )(r->y1 - r->y0);
#line 551
    if (mr < w) {
#line 552
      mr = w;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 554
  return (mr);
}
}
#line 560 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
OPJ_BOOL opj_dwt_decode_tile(opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres , void (*dwt_1D)(opj_dwt_t * ) ) 
{ 
  opj_dwt_t h ;
  opj_dwt_t v ;
  opj_tcd_resolution_t *tr ;
  OPJ_UINT32 rw ;
  OPJ_UINT32 rh ;
  OPJ_UINT32 w ;
  OPJ_UINT32 __cil_tmp10 ;
  void *__cil_tmp11 ;
  OPJ_INT32 *tiledp ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;

  {
  {
#line 564
  tr = tilec->resolutions;
#line 566
  rw = (OPJ_UINT32 )(tr->x1 - tr->x0);
#line 567
  rh = (OPJ_UINT32 )(tr->y1 - tr->y0);
#line 569
  w = (OPJ_UINT32 )(tilec->x1 - tilec->x0);
#line 571
  __cil_tmp10 = opj_dwt_max_resolution(tr, numres);
#line 571
  __cil_tmp11 = malloc((unsigned long )__cil_tmp10 * sizeof(OPJ_INT32 ));
#line 571
  h.mem = (OPJ_INT32 *)__cil_tmp11;
  }
#line 573
  if (! h.mem) {
#line 575
    return (0);
  }
#line 578
  v.mem = h.mem;
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    numres --;
#line 580
    if (! numres) {
#line 580
      goto while_break;
    }
#line 581
    tiledp = tilec->data;
#line 584
    tr ++;
#line 585
    h.sn = (OPJ_INT32 )rw;
#line 586
    v.sn = (OPJ_INT32 )rh;
#line 588
    rw = (OPJ_UINT32 )(tr->x1 - tr->x0);
#line 589
    rh = (OPJ_UINT32 )(tr->y1 - tr->y0);
#line 591
    h.dn = (OPJ_INT32 )(rw - (OPJ_UINT32 )h.sn);
#line 592
    h.cas = tr->x0 % 2;
#line 594
    j = (OPJ_UINT32 )0;
    {
#line 594
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 594
      if (! (j < rh)) {
#line 594
        goto while_break___0;
      }
      {
#line 595
      opj_dwt_interleave_h(& h, tiledp + j * w);
#line 596
      (*dwt_1D)(& h);
#line 597
      memcpy((void *)(tiledp + j * w), (void const   *)h.mem, (unsigned long )rw * sizeof(OPJ_INT32 ));
#line 594
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 600
    v.dn = (OPJ_INT32 )(rh - (OPJ_UINT32 )v.sn);
#line 601
    v.cas = tr->y0 % 2;
#line 603
    j = (OPJ_UINT32 )0;
    {
#line 603
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 603
      if (! (j < rw)) {
#line 603
        goto while_break___1;
      }
      {
#line 605
      opj_dwt_interleave_v(& v, tiledp + j, (OPJ_INT32 )w);
#line 606
      (*dwt_1D)(& v);
#line 607
      k = (OPJ_UINT32 )0;
      }
      {
#line 607
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 607
        if (! (k < rh)) {
#line 607
          goto while_break___2;
        }
#line 608
        *(tiledp + (k * w + j)) = *(v.mem + k);
#line 607
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 603
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 612
  free((void *)h.mem);
  }
#line 613
  return (1);
}
}
#line 616 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
void opj_v4dwt_interleave_h(opj_v4dwt_t *w , OPJ_FLOAT32 *a , OPJ_INT32 x , OPJ_INT32 size ) 
{ 
  OPJ_FLOAT32 *bi ;
  OPJ_INT32 count ;
  OPJ_INT32 i ;
  OPJ_INT32 k ;
  OPJ_INT32 j ;
  OPJ_INT32 j___0 ;

  {
#line 617
  bi = (OPJ_FLOAT32 *)(w->wavelet + w->cas);
#line 618
  count = w->sn;
#line 621
  k = 0;
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;

#line 621
    if (! (k < 2)) {
#line 621
      goto while_break;
    }
#line 622
    if (count + 3 * x < size) {
#line 622
      if (((size_t )a & 15UL) == 0UL) {
#line 622
        if (((size_t )bi & 15UL) == 0UL) {
#line 622
          if ((x & 15) == 0) {
#line 624
            i = 0;
            {
#line 624
            while (1) {
              while_continue___2: /* CIL Label */ ;

#line 624
              if (! (i < count)) {
#line 624
                goto while_break___0;
              }
#line 625
              j = i;
#line 626
              *(bi + i * 8) = *(a + j);
#line 627
              j += x;
#line 628
              *(bi + (i * 8 + 1)) = *(a + j);
#line 629
              j += x;
#line 630
              *(bi + (i * 8 + 2)) = *(a + j);
#line 631
              j += x;
#line 632
              *(bi + (i * 8 + 3)) = *(a + j);
#line 624
              i ++;
            }
            while_break___3: /* CIL Label */ ;
            }
            while_break___0: ;
          } else {
#line 622
            goto _L;
          }
        } else {
#line 622
          goto _L;
        }
      } else {
#line 622
        goto _L;
      }
    } else {
      _L: 
#line 637
      i = 0;
      {
#line 637
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___1: ;
#line 637
        if (! (i < count)) {
#line 637
          goto while_break___1;
        }
#line 638
        j___0 = i;
#line 639
        *(bi + i * 8) = *(a + j___0);
#line 640
        j___0 += x;
#line 641
        if (j___0 >= size) {
#line 641
          goto while_continue___1;
        }
#line 642
        *(bi + (i * 8 + 1)) = *(a + j___0);
#line 643
        j___0 += x;
#line 644
        if (j___0 >= size) {
#line 644
          goto while_continue___1;
        }
#line 645
        *(bi + (i * 8 + 2)) = *(a + j___0);
#line 646
        j___0 += x;
#line 647
        if (j___0 >= size) {
#line 647
          goto while_continue___1;
        }
#line 648
        *(bi + (i * 8 + 3)) = *(a + j___0);
#line 637
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
    }
#line 652
    bi = (OPJ_FLOAT32 *)((w->wavelet + 1) - w->cas);
#line 653
    a += w->sn;
#line 654
    size -= w->sn;
#line 655
    count = w->dn;
#line 621
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 625
  return;
}
}
#line 659 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
void opj_v4dwt_interleave_v(opj_v4dwt_t *v , OPJ_FLOAT32 *a , OPJ_INT32 x , OPJ_INT32 nb_elts_read ) 
{ 
  opj_v4_t *bi ;
  OPJ_INT32 i ;

  {
#line 660
  bi = v->wavelet + v->cas;
#line 663
  i = 0;
  {
#line 663
  while (1) {
    while_continue: /* CIL Label */ ;

#line 663
    if (! (i < v->sn)) {
#line 663
      goto while_break;
    }
    {
#line 664
    memcpy((void *)(bi + i * 2), (void const   *)(a + i * x), (size_t )nb_elts_read * sizeof(OPJ_FLOAT32 ));
#line 663
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 667
  a += v->sn * x;
#line 668
  bi = (v->wavelet + 1) - v->cas;
#line 670
  i = 0;
  {
#line 670
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 670
    if (! (i < v->dn)) {
#line 670
      goto while_break___0;
    }
    {
#line 671
    memcpy((void *)(bi + i * 2), (void const   *)(a + i * x), (size_t )nb_elts_read * sizeof(OPJ_FLOAT32 ));
#line 670
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 674
  return;
}
}
#line 677 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
void opj_v4dwt_decode_step1_sse(opj_v4_t *w , OPJ_INT32 count , __m128 c ) 
{ 
  __m128 *vw ;
  OPJ_INT32 i ;

  {
#line 678
  vw = (__m128 *)w;
#line 681
  i = 0;
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;

#line 681
    if (! (i < count >> 2)) {
#line 681
      goto while_break;
    }
    {
#line 682
    *vw = _mm_mul_ps(*vw, c);
#line 683
    vw += 2;
#line 684
    *vw = _mm_mul_ps(*vw, c);
#line 685
    vw += 2;
#line 686
    *vw = _mm_mul_ps(*vw, c);
#line 687
    vw += 2;
#line 688
    *vw = _mm_mul_ps(*vw, c);
#line 689
    vw += 2;
#line 681
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 691
  count &= 3;
#line 692
  i = 0;
  {
#line 692
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 692
    if (! (i < count)) {
#line 692
      goto while_break___0;
    }
    {
#line 693
    *vw = _mm_mul_ps(*vw, c);
#line 694
    vw += 2;
#line 692
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 696
  return;
}
}
#line 698 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
void opj_v4dwt_decode_step2_sse(opj_v4_t *l , opj_v4_t *w , OPJ_INT32 k , OPJ_INT32 m ,
                                __m128 c ) 
{ 
  __m128 *vl ;
  __m128 *vw ;
  OPJ_INT32 i ;
  __m128 tmp1 ;
  __m128 tmp2 ;
  __m128 tmp3 ;
  __m128 __cil_tmp12 ;
  __m128 __cil_tmp13 ;
  __m128 __cil_tmp14 ;
  __m128 tmp ;

  {
#line 699
  vl = (__m128 *)l;
#line 700
  vw = (__m128 *)w;
#line 703
  tmp1 = *(vl + 0);
#line 704
  i = 0;
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;

#line 704
    if (! (i < m)) {
#line 704
      goto while_break;
    }
    {
#line 705
    tmp2 = *(vw + -1);
#line 706
    tmp3 = *(vw + 0);
#line 707
    __cil_tmp12 = _mm_add_ps(tmp1, tmp3);
#line 707
    __cil_tmp13 = _mm_mul_ps(__cil_tmp12, c);
#line 707
    __cil_tmp14 = _mm_add_ps(tmp2, __cil_tmp13);
#line 707
    *(vw + -1) = __cil_tmp14;
#line 708
    tmp1 = tmp3;
#line 709
    vw += 2;
#line 704
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 711
  vl = vw - 2;
#line 712
  if (m >= k) {
#line 713
    return;
  }
  {
#line 715
  c = _mm_add_ps(c, c);
#line 716
  c = _mm_mul_ps(c, *(vl + 0));
  }
  {
#line 717
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 717
    if (! (m < k)) {
#line 717
      goto while_break___0;
    }
    {
#line 718
    tmp = *(vw + -1);
#line 719
    *(vw + -1) = _mm_add_ps(tmp, c);
#line 720
    vw += 2;
#line 717
    m ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 721
  return;
}
}
#line 796 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
void opj_v4dwt_decode(opj_v4dwt_t *dwt ) 
{ 
  OPJ_INT32 a ;
  OPJ_INT32 b ;
  __m128 __cil_tmp4 ;
  __m128 __cil_tmp5 ;
  OPJ_INT32 __cil_tmp6 ;
  __m128 __cil_tmp7 ;
  OPJ_INT32 __cil_tmp8 ;
  __m128 __cil_tmp9 ;
  OPJ_INT32 __cil_tmp10 ;
  __m128 __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;
  __m128 __cil_tmp13 ;

  {
#line 799
  if (dwt->cas == 0) {
#line 800
    if (! (dwt->dn > 0)) {
#line 800
      if (! (dwt->sn > 1)) {
#line 801
        return;
      }
    }
#line 803
    a = 0;
#line 804
    b = 1;
  } else {
#line 806
    if (! (dwt->sn > 0)) {
#line 806
      if (! (dwt->dn > 1)) {
#line 807
        return;
      }
    }
#line 809
    a = 1;
#line 810
    b = 0;
  }
  {
#line 813
  __cil_tmp4 = _mm_set_ss(opj_K);
#line 813
  opj_v4dwt_decode_step1_sse(dwt->wavelet + a, dwt->sn, __cil_tmp4);
#line 814
  __cil_tmp5 = _mm_set_ss(opj_c13318);
#line 814
  opj_v4dwt_decode_step1_sse(dwt->wavelet + b, dwt->dn, __cil_tmp5);
#line 815
  __cil_tmp6 = opj_int_min(dwt->sn, dwt->dn - a);
#line 815
  __cil_tmp7 = _mm_set_ss(opj_dwt_delta);
#line 815
  opj_v4dwt_decode_step2_sse(dwt->wavelet + b, (dwt->wavelet + a) + 1, dwt->sn, __cil_tmp6,
                             __cil_tmp7);
#line 816
  __cil_tmp8 = opj_int_min(dwt->dn, dwt->sn - b);
#line 816
  __cil_tmp9 = _mm_set_ss(opj_dwt_gamma);
#line 816
  opj_v4dwt_decode_step2_sse(dwt->wavelet + a, (dwt->wavelet + b) + 1, dwt->dn, __cil_tmp8,
                             __cil_tmp9);
#line 817
  __cil_tmp10 = opj_int_min(dwt->sn, dwt->dn - a);
#line 817
  __cil_tmp11 = _mm_set_ss(opj_dwt_beta);
#line 817
  opj_v4dwt_decode_step2_sse(dwt->wavelet + b, (dwt->wavelet + a) + 1, dwt->sn, __cil_tmp10,
                             __cil_tmp11);
#line 818
  __cil_tmp12 = opj_int_min(dwt->dn, dwt->sn - b);
#line 818
  __cil_tmp13 = _mm_set_ss(opj_dwt_alpha);
#line 818
  opj_v4dwt_decode_step2_sse(dwt->wavelet + a, (dwt->wavelet + b) + 1, dwt->dn, __cil_tmp12,
                             __cil_tmp13);
  }
#line 821
  return;
}
}
#line 833 "/root/patchweave_new/10/src/lib/openjp2/dwt.c"
OPJ_BOOL opj_dwt_decode_real(opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) 
{ 
  opj_v4dwt_t h ;
  opj_v4dwt_t v ;
  opj_tcd_resolution_t *res ;
  OPJ_UINT32 rw ;
  OPJ_UINT32 rh ;
  OPJ_UINT32 w ;
  OPJ_UINT32 __cil_tmp9 ;
  void *__cil_tmp10 ;
  OPJ_FLOAT32 *aj ;
  OPJ_UINT32 bufsize ;
  OPJ_INT32 j ;
  OPJ_INT32 k ;
  OPJ_INT32 k___0 ;
  OPJ_UINT32 k___1 ;
  OPJ_UINT32 k___2 ;

  {
  {
#line 838
  res = tilec->resolutions;
#line 840
  rw = (OPJ_UINT32 )(res->x1 - res->x0);
#line 841
  rh = (OPJ_UINT32 )(res->y1 - res->y0);
#line 843
  w = (OPJ_UINT32 )(tilec->x1 - tilec->x0);
#line 845
  __cil_tmp9 = opj_dwt_max_resolution(res, numres);
#line 845
  __cil_tmp10 = malloc((unsigned long )(__cil_tmp9 + 5U) * sizeof(opj_v4_t ));
#line 845
  h.wavelet = (opj_v4_t *)__cil_tmp10;
  }
#line 846
  if (! h.wavelet) {
#line 848
    return (0);
  }
#line 850
  v.wavelet = h.wavelet;
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    numres --;
#line 852
    if (! numres) {
#line 852
      goto while_break;
    }
#line 853
    aj = (OPJ_FLOAT32 *)tilec->data;
#line 854
    bufsize = (OPJ_UINT32 )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0));
#line 857
    h.sn = (OPJ_INT32 )rw;
#line 858
    v.sn = (OPJ_INT32 )rh;
#line 860
    res ++;
#line 862
    rw = (OPJ_UINT32 )(res->x1 - res->x0);
#line 863
    rh = (OPJ_UINT32 )(res->y1 - res->y0);
#line 865
    h.dn = (OPJ_INT32 )(rw - (OPJ_UINT32 )h.sn);
#line 866
    h.cas = res->x0 % 2;
#line 868
    j = (OPJ_INT32 )rh;
    {
#line 868
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 868
      if (! (j > 3)) {
#line 868
        goto while_break___0;
      }
      {
#line 870
      opj_v4dwt_interleave_h(& h, aj, (OPJ_INT32 )w, (OPJ_INT32 )bufsize);
#line 871
      opj_v4dwt_decode(& h);
#line 873
      k = (OPJ_INT32 )rw;
      }
      {
#line 873
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 873
        if (! (k >= 0)) {
#line 873
          goto while_break___1;
        }
#line 874
        *(aj + k) = (h.wavelet + k)->f[0];
#line 875
        *(aj + (k + (OPJ_INT32 )w)) = (h.wavelet + k)->f[1];
#line 876
        *(aj + (k + (OPJ_INT32 )w * 2)) = (h.wavelet + k)->f[2];
#line 877
        *(aj + (k + (OPJ_INT32 )w * 3)) = (h.wavelet + k)->f[3];
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___1: 
#line 880
      aj += w * 4U;
#line 881
      bufsize -= w * 4U;
#line 868
      j -= 4;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___0: ;
#line 884
    if (rh & 3U) {
      {
#line 886
      j = (OPJ_INT32 )(rh & 3U);
#line 887
      opj_v4dwt_interleave_h(& h, aj, (OPJ_INT32 )w, (OPJ_INT32 )bufsize);
#line 888
      opj_v4dwt_decode(& h);
#line 889
      k___0 = (OPJ_INT32 )rw;
      }
      {
#line 889
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 889
        if (! (k___0 >= 0)) {
#line 889
          goto while_break___2;
        }
#line 891
        if (j == 3) {
#line 891
          goto case_3;
        }
#line 892
        if (j == 2) {
#line 892
          goto case_2;
        }
#line 893
        if (j == 1) {
#line 893
          goto case_1;
        }
#line 890
        goto switch_break;
        case_3: 
#line 891
        *(aj + (k___0 + (OPJ_INT32 )w * 2)) = (h.wavelet + k___0)->f[2];
        case_2: 
#line 892
        *(aj + (k___0 + (OPJ_INT32 )w)) = (h.wavelet + k___0)->f[1];
        case_1: 
#line 893
        *(aj + k___0) = (h.wavelet + k___0)->f[0];
        switch_break: ;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___2: ;
    }
#line 898
    v.dn = (OPJ_INT32 )(rh - (OPJ_UINT32 )v.sn);
#line 899
    v.cas = res->y0 % 2;
#line 901
    aj = (OPJ_FLOAT32 *)tilec->data;
#line 902
    j = (OPJ_INT32 )rw;
    {
#line 902
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 902
      if (! (j > 3)) {
#line 902
        goto while_break___3;
      }
      {
#line 905
      opj_v4dwt_interleave_v(& v, aj, (OPJ_INT32 )w, 4);
#line 906
      opj_v4dwt_decode(& v);
#line 908
      k___1 = (OPJ_UINT32 )0;
      }
      {
#line 908
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 908
        if (! (k___1 < rh)) {
#line 908
          goto while_break___4;
        }
        {
#line 909
        memcpy((void *)(aj + k___1 * w), (void const   *)(v.wavelet + k___1), 4UL * sizeof(OPJ_FLOAT32 ));
#line 908
        k___1 ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: 
#line 911
      aj += 4;
#line 902
      j -= 4;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___3: ;
#line 914
    if (rw & 3U) {
      {
#line 917
      j = (OPJ_INT32 )(rw & 3U);
#line 919
      opj_v4dwt_interleave_v(& v, aj, (OPJ_INT32 )w, j);
#line 920
      opj_v4dwt_decode(& v);
#line 922
      k___2 = (OPJ_UINT32 )0;
      }
      {
#line 922
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 922
        if (! (k___2 < rh)) {
#line 922
          goto while_break___5;
        }
        {
#line 923
        memcpy((void *)(aj + k___2 * w), (void const   *)(v.wavelet + k___2), (size_t )j * sizeof(OPJ_FLOAT32 ));
#line 922
        k___2 ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___5: ;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: 
  {
#line 928
  free((void *)h.wavelet);
  }
#line 929
  return (1);
}
}
#line 47 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_write_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 49
  l_data_ptr = (OPJ_BYTE *)(& p_value) + p_nb_bytes;
#line 53
  memcpy((void *)p_buffer, (void const   *)l_data_ptr, (unsigned long )p_nb_bytes);
  }
#line 55
  return;
}
}
#line 56 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_write_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp7 ;
  OPJ_BYTE *__cil_tmp8 ;

  {
#line 58
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + p_nb_bytes) - 1;
#line 63
  i = (OPJ_UINT32 )0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;

#line 63
    if (! (i < p_nb_bytes)) {
#line 63
      goto while_break;
    }
#line 64
    __cil_tmp8 = l_data_ptr;
#line 64
    l_data_ptr --;
#line 64
    __cil_tmp7 = p_buffer;
#line 64
    p_buffer ++;
#line 64
    *__cil_tmp7 = *__cil_tmp8;
#line 63
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 67
  return;
}
}
#line 68 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_read_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 70
  l_data_ptr = (OPJ_BYTE *)p_value;
#line 74
  *p_value = (OPJ_UINT32 )0;
#line 75
  memcpy((void *)((l_data_ptr + 4) - p_nb_bytes), (void const   *)p_buffer, (unsigned long )p_nb_bytes);
  }
#line 77
  return;
}
}
#line 78 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_read_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp7 ;
  OPJ_BYTE *__cil_tmp8 ;

  {
#line 80
  l_data_ptr = ((OPJ_BYTE *)p_value + p_nb_bytes) - 1;
#line 85
  *p_value = (OPJ_UINT32 )0;
#line 86
  i = (OPJ_UINT32 )0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;

#line 86
    if (! (i < p_nb_bytes)) {
#line 86
      goto while_break;
    }
#line 87
    __cil_tmp8 = p_buffer;
#line 87
    p_buffer ++;
#line 87
    __cil_tmp7 = l_data_ptr;
#line 87
    l_data_ptr --;
#line 87
    *__cil_tmp7 = *__cil_tmp8;
#line 86
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 90
  return;
}
}
#line 91 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_write_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 93
  l_data_ptr = (OPJ_BYTE *)(& p_value);
#line 94
  memcpy((void *)p_buffer, (void const   *)l_data_ptr, sizeof(OPJ_FLOAT64 ));
  }
#line 96
  return;
}
}
#line 97 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_write_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 99
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + sizeof(OPJ_FLOAT64 )) - 1;
#line 101
  i = (OPJ_UINT32 )0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;

#line 101
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT64 ))) {
#line 101
      goto while_break;
    }
#line 102
    __cil_tmp6 = l_data_ptr;
#line 102
    l_data_ptr --;
#line 102
    __cil_tmp5 = p_buffer;
#line 102
    p_buffer ++;
#line 102
    *__cil_tmp5 = *__cil_tmp6;
#line 101
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 105
  return;
}
}
#line 106 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_read_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 108
  l_data_ptr = (OPJ_BYTE *)p_value;
#line 109
  memcpy((void *)l_data_ptr, (void const   *)p_buffer, sizeof(OPJ_FLOAT64 ));
  }
#line 111
  return;
}
}
#line 112 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_read_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 114
  l_data_ptr = ((OPJ_BYTE *)p_value + sizeof(OPJ_FLOAT64 )) - 1;
#line 116
  i = (OPJ_UINT32 )0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;

#line 116
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT64 ))) {
#line 116
      goto while_break;
    }
#line 117
    __cil_tmp6 = p_buffer;
#line 117
    p_buffer ++;
#line 117
    __cil_tmp5 = l_data_ptr;
#line 117
    l_data_ptr --;
#line 117
    *__cil_tmp5 = *__cil_tmp6;
#line 116
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 120
  return;
}
}
#line 121 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_write_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 123
  l_data_ptr = (OPJ_BYTE *)(& p_value);
#line 124
  memcpy((void *)p_buffer, (void const   *)l_data_ptr, sizeof(OPJ_FLOAT32 ));
  }
#line 126
  return;
}
}
#line 127 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_write_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 129
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + sizeof(OPJ_FLOAT32 )) - 1;
#line 131
  i = (OPJ_UINT32 )0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;

#line 131
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT32 ))) {
#line 131
      goto while_break;
    }
#line 132
    __cil_tmp6 = l_data_ptr;
#line 132
    l_data_ptr --;
#line 132
    __cil_tmp5 = p_buffer;
#line 132
    p_buffer ++;
#line 132
    *__cil_tmp5 = *__cil_tmp6;
#line 131
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 135
  return;
}
}
#line 136 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_read_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 138
  l_data_ptr = (OPJ_BYTE *)p_value;
#line 139
  memcpy((void *)l_data_ptr, (void const   *)p_buffer, sizeof(OPJ_FLOAT32 ));
  }
#line 141
  return;
}
}
#line 142 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_read_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 144
  l_data_ptr = ((OPJ_BYTE *)p_value + sizeof(OPJ_FLOAT32 )) - 1;
#line 146
  i = (OPJ_UINT32 )0;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;

#line 146
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT32 ))) {
#line 146
      goto while_break;
    }
#line 147
    __cil_tmp6 = p_buffer;
#line 147
    p_buffer ++;
#line 147
    __cil_tmp5 = l_data_ptr;
#line 147
    l_data_ptr --;
#line 147
    *__cil_tmp5 = *__cil_tmp6;
#line 146
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 150
  return;
}
}
#line 151 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
opj_stream_t *opj_stream_create(OPJ_SIZE_T p_buffer_size , OPJ_BOOL l_is_input ) 
{ 
  opj_stream_private_t *l_stream ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 153
  l_stream = (opj_stream_private_t *)0;
#line 154
  __cil_tmp4 = calloc(1UL, sizeof(opj_stream_private_t ));
#line 154
  l_stream = (opj_stream_private_t *)__cil_tmp4;
  }
#line 155
  if (! l_stream) {
#line 156
    return ((opj_stream_t *)0);
  }
  {
#line 159
  l_stream->m_buffer_size = p_buffer_size;
#line 160
  __cil_tmp5 = malloc(p_buffer_size);
#line 160
  l_stream->m_stored_data = (OPJ_BYTE *)__cil_tmp5;
  }
#line 161
  if (! l_stream->m_stored_data) {
    {
#line 162
    free((void *)l_stream);
    }
#line 163
    return ((opj_stream_t *)0);
  }
#line 166
  l_stream->m_current_data = l_stream->m_stored_data;
#line 168
  if (l_is_input) {
#line 169
    l_stream->m_status = (opj_stream_flag )((int )l_stream->m_status | 2);
#line 170
    l_stream->m_opj_skip = & opj_stream_read_skip;
#line 171
    l_stream->m_opj_seek = & opj_stream_read_seek;
  } else {
#line 174
    l_stream->m_status = (opj_stream_flag )((int )l_stream->m_status | 1);
#line 175
    l_stream->m_opj_skip = & opj_stream_write_skip;
#line 176
    l_stream->m_opj_seek = & opj_stream_write_seek;
  }
#line 179
  l_stream->m_read_fn = & opj_stream_default_read;
#line 180
  l_stream->m_write_fn = & opj_stream_default_write;
#line 181
  l_stream->m_skip_fn = & opj_stream_default_skip;
#line 182
  l_stream->m_seek_fn = & opj_stream_default_seek;
#line 184
  return ((opj_stream_t *)l_stream);
}
}
#line 187 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
opj_stream_t *opj_stream_default_create(OPJ_BOOL l_is_input ) 
{ 
  opj_stream_t *__cil_tmp2 ;

  {
  {
#line 189
  __cil_tmp2 = opj_stream_create((OPJ_SIZE_T )1048576, l_is_input);
  }
#line 189
  return (__cil_tmp2);
}
}
#line 192 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_stream_destroy(opj_stream_t *p_stream ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 194
  l_stream = (opj_stream_private_t *)p_stream;
#line 196
  if (l_stream) {
#line 197
    if (l_stream->m_free_user_data_fn) {
      {
#line 198
      (*(l_stream->m_free_user_data_fn))(l_stream->m_user_data);
      }
    }
    {
#line 200
    free((void *)l_stream->m_stored_data);
#line 201
    l_stream->m_stored_data = (OPJ_BYTE *)0;
#line 202
    free((void *)l_stream);
    }
  }
#line 205
  return;
}
}
#line 206 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_stream_set_read_function(opj_stream_t *p_stream , OPJ_SIZE_T (*p_function)(void * ,
                                                                                    OPJ_SIZE_T  ,
                                                                                    void * ) ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 208
  l_stream = (opj_stream_private_t *)p_stream;
#line 210
  if (! l_stream) {
#line 211
    return;
  } else
#line 210
  if (! ((int )l_stream->m_status & 2)) {
#line 211
    return;
  }
#line 214
  l_stream->m_read_fn = p_function;
#line 215
  return;
}
}
#line 217 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_stream_set_seek_function(opj_stream_t *p_stream , OPJ_BOOL (*p_function)(OPJ_OFF_T  ,
                                                                                  void * ) ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 219
  l_stream = (opj_stream_private_t *)p_stream;
#line 221
  if (! l_stream) {
#line 222
    return;
  }
#line 224
  l_stream->m_seek_fn = p_function;
#line 225
  return;
}
}
#line 227 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_stream_set_write_function(opj_stream_t *p_stream , OPJ_SIZE_T (*p_function)(void * ,
                                                                                     OPJ_SIZE_T  ,
                                                                                     void * ) ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 229
  l_stream = (opj_stream_private_t *)p_stream;
#line 231
  if (! l_stream) {
#line 232
    return;
  } else
#line 231
  if (! ((int )l_stream->m_status & 1)) {
#line 232
    return;
  }
#line 235
  l_stream->m_write_fn = p_function;
#line 236
  return;
}
}
#line 238 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_stream_set_skip_function(opj_stream_t *p_stream , OPJ_OFF_T (*p_function)(OPJ_OFF_T  ,
                                                                                   void * ) ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 240
  l_stream = (opj_stream_private_t *)p_stream;
#line 242
  if (! l_stream) {
#line 243
    return;
  }
#line 246
  l_stream->m_skip_fn = p_function;
#line 247
  return;
}
}
#line 249 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_stream_set_user_data(opj_stream_t *p_stream , void *p_data , void (*p_function)(void * ) ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 251
  l_stream = (opj_stream_private_t *)p_stream;
#line 252
  if (! l_stream) {
#line 253
    return;
  }
#line 254
  l_stream->m_user_data = p_data;
#line 255
  l_stream->m_free_user_data_fn = p_function;
#line 256
  return;
}
}
#line 258 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
void opj_stream_set_user_data_length(opj_stream_t *p_stream , OPJ_UINT64 data_length ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 260
  l_stream = (opj_stream_private_t *)p_stream;
#line 261
  if (! l_stream) {
#line 262
    return;
  }
#line 263
  l_stream->m_user_data_length = data_length;
#line 264
  return;
}
}
#line 266 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_read_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_SIZE_T l_read_nb_bytes ;
  OPJ_SIZE_T tmp ;
  OPJ_SIZE_T tmp___0 ;
  OPJ_SIZE_T tmp___1 ;

  {
#line 268
  l_read_nb_bytes = (OPJ_SIZE_T )0;
#line 269
  if (p_stream->m_bytes_in_buffer >= p_size) {
    {
#line 270
    memcpy((void *)p_buffer, (void const   *)p_stream->m_current_data, p_size);
#line 271
    p_stream->m_current_data += p_size;
#line 272
    p_stream->m_bytes_in_buffer -= p_size;
#line 273
    l_read_nb_bytes += p_size;
#line 274
    p_stream->m_byte_offset += (OPJ_OFF_T )p_size;
    }
#line 275
    return (l_read_nb_bytes);
  }
#line 279
  if ((int )p_stream->m_status & 4) {
    {
#line 280
    l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 281
    memcpy((void *)p_buffer, (void const   *)p_stream->m_current_data, p_stream->m_bytes_in_buffer);
#line 282
    p_stream->m_current_data += p_stream->m_bytes_in_buffer;
#line 283
    p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 284
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
    }
#line 285
    if (l_read_nb_bytes) {
#line 285
      tmp = l_read_nb_bytes;
    } else {
#line 285
      tmp = (OPJ_SIZE_T )-1;
    }
#line 285
    return (tmp);
  }
#line 289
  if (p_stream->m_bytes_in_buffer) {
    {
#line 290
    l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 291
    memcpy((void *)p_buffer, (void const   *)p_stream->m_current_data, p_stream->m_bytes_in_buffer);
#line 292
    p_stream->m_current_data = p_stream->m_stored_data;
#line 293
    p_buffer += p_stream->m_bytes_in_buffer;
#line 294
    p_size -= p_stream->m_bytes_in_buffer;
#line 295
    p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 296
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
    }
  } else {
#line 302
    p_stream->m_current_data = p_stream->m_stored_data;
  }
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;

#line 307
    if (p_size < p_stream->m_buffer_size) {
      {
#line 309
      p_stream->m_bytes_in_buffer = (*(p_stream->m_read_fn))((void *)p_stream->m_stored_data,
                                                             p_stream->m_buffer_size,
                                                             p_stream->m_user_data);
      }
#line 311
      if (p_stream->m_bytes_in_buffer == 0xffffffffffffffffUL) {
        {
#line 313
        opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n");
#line 315
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 316
        p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 4);
        }
#line 318
        if (l_read_nb_bytes) {
#line 318
          tmp___0 = l_read_nb_bytes;
        } else {
#line 318
          tmp___0 = (OPJ_SIZE_T )-1;
        }
#line 318
        return (tmp___0);
      } else
#line 320
      if (p_stream->m_bytes_in_buffer < p_size) {
        {
#line 322
        l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 323
        memcpy((void *)p_buffer, (void const   *)p_stream->m_current_data, p_stream->m_bytes_in_buffer);
#line 324
        p_stream->m_current_data = p_stream->m_stored_data;
#line 325
        p_buffer += p_stream->m_bytes_in_buffer;
#line 326
        p_size -= p_stream->m_bytes_in_buffer;
#line 327
        p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 328
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
        }
      } else {
        {
#line 331
        l_read_nb_bytes += p_size;
#line 332
        memcpy((void *)p_buffer, (void const   *)p_stream->m_current_data, p_size);
#line 333
        p_stream->m_current_data += p_size;
#line 334
        p_stream->m_bytes_in_buffer -= p_size;
#line 335
        p_stream->m_byte_offset += (OPJ_OFF_T )p_size;
        }
#line 336
        return (l_read_nb_bytes);
      }
    } else {
      {
#line 341
      p_stream->m_bytes_in_buffer = (*(p_stream->m_read_fn))((void *)p_buffer, p_size,
                                                             p_stream->m_user_data);
      }
#line 343
      if (p_stream->m_bytes_in_buffer == 0xffffffffffffffffUL) {
        {
#line 345
        opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n");
#line 347
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 348
        p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 4);
        }
#line 350
        if (l_read_nb_bytes) {
#line 350
          tmp___1 = l_read_nb_bytes;
        } else {
#line 350
          tmp___1 = (OPJ_SIZE_T )-1;
        }
#line 350
        return (tmp___1);
      } else
#line 352
      if (p_stream->m_bytes_in_buffer < p_size) {
#line 354
        l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 355
        p_stream->m_current_data = p_stream->m_stored_data;
#line 356
        p_buffer += p_stream->m_bytes_in_buffer;
#line 357
        p_size -= p_stream->m_bytes_in_buffer;
#line 358
        p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 359
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
      } else {
#line 363
        l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 364
        p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 365
        p_stream->m_current_data = p_stream->m_stored_data;
#line 366
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 367
        return (l_read_nb_bytes);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 374
  return (0UL);
}
}
#line 373 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_write_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                 OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_SIZE_T l_remaining_bytes ;
  OPJ_SIZE_T l_write_nb_bytes ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 378
  l_remaining_bytes = (OPJ_SIZE_T )0;
#line 379
  l_write_nb_bytes = (OPJ_SIZE_T )0;
#line 381
  if ((int )p_stream->m_status & 8) {
#line 382
    return ((OPJ_SIZE_T )-1);
  }
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 386
    l_remaining_bytes = p_stream->m_buffer_size - p_stream->m_bytes_in_buffer;
#line 389
    if (l_remaining_bytes >= p_size) {
      {
#line 390
      memcpy((void *)p_stream->m_current_data, (void const   *)p_buffer, p_size);
#line 392
      p_stream->m_current_data += p_size;
#line 393
      p_stream->m_bytes_in_buffer += p_size;
#line 394
      l_write_nb_bytes += p_size;
#line 395
      p_stream->m_byte_offset += (OPJ_OFF_T )p_size;
      }
#line 397
      return (l_write_nb_bytes);
    }
#line 401
    if (l_remaining_bytes) {
      {
#line 402
      l_write_nb_bytes += l_remaining_bytes;
#line 404
      memcpy((void *)p_stream->m_current_data, (void const   *)p_buffer, l_remaining_bytes);
#line 406
      p_stream->m_current_data = p_stream->m_stored_data;
#line 408
      p_buffer += l_remaining_bytes;
#line 409
      p_size -= l_remaining_bytes;
#line 410
      p_stream->m_bytes_in_buffer += l_remaining_bytes;
#line 411
      p_stream->m_byte_offset += (OPJ_OFF_T )l_remaining_bytes;
      }
    }
    {
#line 414
    __cil_tmp7 = opj_stream_flush(p_stream, p_event_mgr);
    }
#line 414
    if (! __cil_tmp7) {
#line 415
      return ((OPJ_SIZE_T )-1);
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 421
  return (0UL);
}
}
#line 421 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_flush(opj_stream_private_t *p_stream , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_SIZE_T l_current_write_nb_bytes ;

  {
#line 424
  l_current_write_nb_bytes = (OPJ_SIZE_T )0;
#line 426
  p_stream->m_current_data = p_stream->m_stored_data;
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;

#line 428
    if (! p_stream->m_bytes_in_buffer) {
#line 428
      goto while_break;
    }
    {
#line 430
    l_current_write_nb_bytes = (*(p_stream->m_write_fn))((void *)p_stream->m_current_data,
                                                         p_stream->m_bytes_in_buffer,
                                                         p_stream->m_user_data);
    }
#line 434
    if (l_current_write_nb_bytes == 0xffffffffffffffffUL) {
      {
#line 435
      p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 8);
#line 436
      opj_event_msg(p_event_mgr, 4, "Error on writing stream!\n");
      }
#line 438
      return (0);
    }
#line 441
    p_stream->m_current_data += l_current_write_nb_bytes;
#line 442
    p_stream->m_bytes_in_buffer -= l_current_write_nb_bytes;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 445
  p_stream->m_current_data = p_stream->m_stored_data;
#line 447
  return (1);
}
}
#line 450 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_read_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_OFF_T l_skip_nb_bytes ;
  OPJ_OFF_T l_current_skip_nb_bytes ;
  OPJ_OFF_T tmp___0 ;
  OPJ_OFF_T tmp___1 ;

  {
#line 452
  l_skip_nb_bytes = (OPJ_OFF_T )0;
#line 453
  l_current_skip_nb_bytes = (OPJ_OFF_T )0;
#line 457
  if (p_stream->m_bytes_in_buffer >= (OPJ_SIZE_T )p_size) {
#line 458
    p_stream->m_current_data += p_size;
#line 461
    p_stream->m_bytes_in_buffer -= (OPJ_SIZE_T )p_size;
#line 462
    l_skip_nb_bytes += p_size;
#line 463
    p_stream->m_byte_offset += l_skip_nb_bytes;
#line 464
    return (l_skip_nb_bytes);
  }
#line 468
  if ((int )p_stream->m_status & 4) {
#line 469
    l_skip_nb_bytes += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 470
    p_stream->m_current_data += p_stream->m_bytes_in_buffer;
#line 471
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 472
    p_stream->m_byte_offset += l_skip_nb_bytes;
#line 473
    if (l_skip_nb_bytes) {
#line 473
      tmp___0 = l_skip_nb_bytes;
    } else {
#line 473
      tmp___0 = (OPJ_OFF_T )-1;
    }
#line 473
    return (tmp___0);
  }
#line 477
  if (p_stream->m_bytes_in_buffer) {
#line 478
    l_skip_nb_bytes += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 479
    p_stream->m_current_data = p_stream->m_stored_data;
#line 480
    p_size -= (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 481
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
  }
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;

#line 484
    if (! (p_size > 0L)) {
#line 484
      goto while_break;
    }
    {
#line 486
    l_current_skip_nb_bytes = (*(p_stream->m_skip_fn))(p_size, p_stream->m_user_data);
    }
#line 487
    if (l_current_skip_nb_bytes == -1L) {
      {
#line 488
      opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n");
#line 490
      p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 4);
#line 491
      p_stream->m_byte_offset += l_skip_nb_bytes;
      }
#line 493
      if (l_skip_nb_bytes) {
#line 493
        tmp___1 = l_skip_nb_bytes;
      } else {
#line 493
        tmp___1 = (OPJ_OFF_T )-1;
      }
#line 493
      return (tmp___1);
    }
#line 495
    p_size -= l_current_skip_nb_bytes;
#line 496
    l_skip_nb_bytes += l_current_skip_nb_bytes;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 499
  p_stream->m_byte_offset += l_skip_nb_bytes;
#line 501
  return (l_skip_nb_bytes);
}
}
#line 504 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_write_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                                opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_BOOL l_is_written ;
  OPJ_OFF_T l_current_skip_nb_bytes ;
  OPJ_OFF_T l_skip_nb_bytes ;
  OPJ_OFF_T tmp ;

  {
#line 506
  l_is_written = 0;
#line 507
  l_current_skip_nb_bytes = (OPJ_OFF_T )0;
#line 508
  l_skip_nb_bytes = (OPJ_OFF_T )0;
#line 510
  if ((int )p_stream->m_status & 8) {
#line 511
    return ((OPJ_OFF_T )-1);
  }
  {
#line 515
  l_is_written = opj_stream_flush(p_stream, p_event_mgr);
  }
#line 516
  if (! l_is_written) {
#line 517
    p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 8);
#line 518
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 519
    return ((OPJ_OFF_T )-1);
  }
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;

#line 523
    if (! (p_size > 0L)) {
#line 523
      goto while_break;
    }
    {
#line 525
    l_current_skip_nb_bytes = (*(p_stream->m_skip_fn))(p_size, p_stream->m_user_data);
    }
#line 527
    if (l_current_skip_nb_bytes == -1L) {
      {
#line 528
      opj_event_msg(p_event_mgr, 4, "Stream error!\n");
#line 530
      p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 8);
#line 531
      p_stream->m_byte_offset += l_skip_nb_bytes;
      }
#line 533
      if (l_skip_nb_bytes) {
#line 533
        tmp = l_skip_nb_bytes;
      } else {
#line 533
        tmp = (OPJ_OFF_T )-1;
      }
#line 533
      return (tmp);
    }
#line 535
    p_size -= l_current_skip_nb_bytes;
#line 536
    l_skip_nb_bytes += l_current_skip_nb_bytes;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 539
  p_stream->m_byte_offset += l_skip_nb_bytes;
#line 541
  return (l_skip_nb_bytes);
}
}
#line 544 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_tell(opj_stream_private_t *p_stream ) 
{ 


  {
#line 546
  return (p_stream->m_byte_offset);
}
}
#line 549 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_get_number_byte_left(opj_stream_private_t *p_stream ) 
{ 
  OPJ_OFF_T tmp___1 ;

  {
#line 553
  if (p_stream->m_user_data_length) {
#line 553
    tmp___1 = (OPJ_OFF_T )p_stream->m_user_data_length - p_stream->m_byte_offset;
  } else {
#line 553
    tmp___1 = 0L;
  }
#line 553
  return (tmp___1);
}
}
#line 558 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_OFF_T __cil_tmp5 ;

  {
  {
#line 561
  __cil_tmp5 = (*(p_stream->m_opj_skip))(p_stream, p_size, p_event_mgr);
  }
#line 561
  return (__cil_tmp5);
}
}
#line 564 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_read_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                              opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 567
  p_stream->m_current_data = p_stream->m_stored_data;
#line 568
  p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 570
  __cil_tmp4 = (*(p_stream->m_seek_fn))(p_size, p_stream->m_user_data);
  }
#line 570
  if (! __cil_tmp4) {
#line 571
    p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 4);
#line 572
    return (0);
  } else {
#line 576
    p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status & -5);
#line 577
    p_stream->m_byte_offset = p_size;
  }
#line 581
  return (1);
}
}
#line 584 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_write_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 586
  __cil_tmp4 = opj_stream_flush(p_stream, p_event_mgr);
  }
#line 586
  if (! __cil_tmp4) {
#line 587
    p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 8);
#line 588
    return (0);
  }
  {
#line 591
  p_stream->m_current_data = p_stream->m_stored_data;
#line 592
  p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 594
  __cil_tmp5 = (*(p_stream->m_seek_fn))(p_size, p_stream->m_user_data);
  }
#line 594
  if (! __cil_tmp5) {
#line 595
    p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 8);
#line 596
    return (0);
  } else {
#line 599
    p_stream->m_byte_offset = p_size;
  }
#line 602
  return (1);
}
}
#line 605 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , struct opj_event_mgr *p_event_mgr ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 608
  __cil_tmp5 = (*(p_stream->m_opj_seek))(p_stream, p_size, p_event_mgr);
  }
#line 608
  return (__cil_tmp5);
}
}
#line 611 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_has_seek(opj_stream_private_t *p_stream ) 
{ 


  {
#line 613
  return ((unsigned long )p_stream->m_seek_fn != (unsigned long )(& opj_stream_default_seek));
}
}
#line 616 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_default_read(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 621
  return ((OPJ_SIZE_T )-1);
}
}
#line 624 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_default_write(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 629
  return ((OPJ_SIZE_T )-1);
}
}
#line 632 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_default_skip(OPJ_OFF_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 636
  return ((OPJ_OFF_T )-1);
}
}
#line 639 "/root/patchweave_new/10/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_default_seek(OPJ_OFF_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 643
  return (0);
}
}
#line 51 "/root/patchweave_new/10/src/lib/openjp2/bio.c"
void opj_bio_putbit(opj_bio_t *bio , OPJ_UINT32 b ) ;
#line 57
OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio ) ;
#line 63
OPJ_BOOL opj_bio_byteout(opj_bio_t *bio ) ;
#line 69
OPJ_BOOL opj_bio_bytein(opj_bio_t *bio ) ;
#line 81 "/root/patchweave_new/10/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_byteout(opj_bio_t *bio ) 
{ 
  int tmp ;
  OPJ_BYTE *__cil_tmp3 ;

  {
#line 82
  bio->buf = (bio->buf << 8) & 65535U;
#line 83
  if (bio->buf == 65280U) {
#line 83
    tmp = 7;
  } else {
#line 83
    tmp = 8;
  }
#line 83
  bio->ct = (OPJ_UINT32 )tmp;
#line 84
  if ((OPJ_SIZE_T )bio->bp >= (OPJ_SIZE_T )bio->end) {
#line 85
    return (0);
  }
#line 87
  __cil_tmp3 = bio->bp;
#line 87
  (bio->bp) ++;
#line 87
  *__cil_tmp3 = (OPJ_BYTE )(bio->buf >> 8);
#line 88
  return (1);
}
}
#line 91 "/root/patchweave_new/10/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_bytein(opj_bio_t *bio ) 
{ 
  int tmp ;
  OPJ_BYTE *__cil_tmp3 ;

  {
#line 92
  bio->buf = (bio->buf << 8) & 65535U;
#line 93
  if (bio->buf == 65280U) {
#line 93
    tmp = 7;
  } else {
#line 93
    tmp = 8;
  }
#line 93
  bio->ct = (OPJ_UINT32 )tmp;
#line 94
  if ((OPJ_SIZE_T )bio->bp >= (OPJ_SIZE_T )bio->end) {
#line 95
    return (0);
  }
#line 97
  __cil_tmp3 = bio->bp;
#line 97
  (bio->bp) ++;
#line 97
  bio->buf |= (unsigned int )*__cil_tmp3;
#line 98
  return (1);
}
}
#line 101 "/root/patchweave_new/10/src/lib/openjp2/bio.c"
void opj_bio_putbit(opj_bio_t *bio , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 102
  if (bio->ct == 0U) {
    {
#line 103
    opj_bio_byteout(bio);
    }
  }
#line 105
  __cil_tmp3 = bio->ct;
#line 105
  (bio->ct) --;
#line 106
  bio->buf |= b << bio->ct;
#line 107
  return;
}
}
#line 109 "/root/patchweave_new/10/src/lib/openjp2/bio.c"
OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
#line 110
  if (bio->ct == 0U) {
    {
#line 111
    opj_bio_bytein(bio);
    }
  }
#line 113
  __cil_tmp2 = bio->ct;
#line 113
  (bio->ct) --;
#line 114
  return ((bio->buf >> bio->ct) & 1U);
}
}
#line 123 "/root/patchweave_new/10/src/lib/openjp2/bio.c"
opj_bio_t *opj_bio_create(void) 
{ 
  opj_bio_t *bio ;
  void *__cil_tmp2 ;

  {
  {
#line 124
  __cil_tmp2 = malloc(sizeof(opj_bio_t ));
#line 124
  bio = (opj_bio_t *)__cil_tmp2;
  }
#line 125
  return (bio);
}
}
#line 128 "/root/patchweave_new/10/src/lib/openjp2/bio.c"
void opj_bio_destroy(opj_bio_t *bio ) 
{ 


  {
#line 129
  if (bio) {
    {
#line 130
    free((void *)bio);
    }
  }
#line 133
  return;
}
}
#line 134 "/root/patchweave_new/10/src/lib/openjp2/bio.c"
ptrdiff_t opj_bio_numbytes(opj_bio_t *bio ) 
{ 


  {
#line 135
  return (bio->bp - bio->start);
}
}
#line 138 "/root/patchweave_new/10/src/lib/openjp2/bio.c"
void opj_bio_init_enc(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 139
  bio->start = bp;
#line 140
  bio->end = bp + len;
#line 141
  bio->bp = bp;
#line 142
  bio->buf = (OPJ_UINT32 )0;
#line 143
  bio->ct = (OPJ_UINT32 )8;
#line 144
  return;
}
}
#line 146 "/root/patchweave_new/10/src/lib/openjp2/bio.c"
void opj_bio_init_dec(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 147
  bio->start = bp;
#line 148
  bio->end = bp + len;
#line 149
  bio->bp = bp;
#line 150
  bio->buf = (OPJ_UINT32 )0;
#line 151
  bio->ct = (OPJ_UINT32 )0;
#line 152
  return;
}
}
#line 154 "/root/patchweave_new/10/src/lib/openjp2/bio.c"
void opj_bio_write(opj_bio_t *bio , OPJ_UINT32 v , OPJ_UINT32 n ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp5 ;

  {
#line 156
  i = n - 1U;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;

#line 156
    if (! (i < n)) {
#line 156
      goto while_break;
    }
    {
#line 157
    opj_bio_putbit(bio, (v >> i) & 1U);
#line 156
    __cil_tmp5 = i;
#line 156
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 160
  return;
}
}
#line 161 "/root/patchweave_new/10/src/lib/openjp2/bio.c"
OPJ_UINT32 opj_bio_read(opj_bio_t *bio , OPJ_UINT32 n ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 v ;
  OPJ_UINT32 __cil_tmp5 ;
  OPJ_UINT32 __cil_tmp6 ;

  {
#line 164
  v = (OPJ_UINT32 )0;
#line 165
  i = n - 1U;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;

#line 165
    if (! (i < n)) {
#line 165
      goto while_break;
    }
    {
#line 166
    __cil_tmp5 = opj_bio_getbit(bio);
#line 166
    v += __cil_tmp5 << i;
#line 165
    __cil_tmp6 = i;
#line 165
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 168
  return (v);
}
}
#line 171 "/root/patchweave_new/10/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_flush(opj_bio_t *bio ) 
{ 
  OPJ_BOOL __cil_tmp2 ;
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 172
  bio->ct = (OPJ_UINT32 )0;
#line 173
  __cil_tmp2 = opj_bio_byteout(bio);
  }
#line 173
  if (! __cil_tmp2) {
#line 174
    return (0);
  }
#line 176
  if (bio->ct == 7U) {
    {
#line 177
    bio->ct = (OPJ_UINT32 )0;
#line 178
    __cil_tmp3 = opj_bio_byteout(bio);
    }
#line 178
    if (! __cil_tmp3) {
#line 179
      return (0);
    }
  }
#line 182
  return (1);
}
}
#line 185 "/root/patchweave_new/10/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_inalign(opj_bio_t *bio ) 
{ 
  OPJ_BOOL __cil_tmp2 ;

  {
#line 186
  bio->ct = (OPJ_UINT32 )0;
#line 187
  if ((bio->buf & 255U) == 255U) {
    {
#line 188
    __cil_tmp2 = opj_bio_bytein(bio);
    }
#line 188
    if (! __cil_tmp2) {
#line 189
      return (0);
    }
#line 191
    bio->ct = (OPJ_UINT32 )0;
  }
#line 193
  return (1);
}
}
#line 47 "/root/patchweave_new/10/src/bin/jp2/index.h"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) ;
#line 49 "/root/patchweave_new/10/src/bin/jp2/index.c"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) 
{ 
  int tileno ;
  int compno ;
  int layno ;
  int resno ;
  int precno ;
  int pack_nb ;
  int x ;
  int y ;
  FILE *stream ;
  double total_disto ;
  int tilepartno ;
  char disto_on ;
  char numpix_on ;
  int __cil_tmp17 ;
  OPJ_OFF_T start_pos ;
  OPJ_OFF_T end_ph_pos ;
  OPJ_OFF_T end_pos ;
  double disto ;
  int max_numdecompos ;
  int prec_max ;
  int prec_max___0 ;
  int numprec ;
  int x0 ;
  double __cil_tmp40 ;
  int y0___19 ;
  double __cil_tmp42 ;
  int x1 ;
  int y1___20 ;
  int pcnx ;
  int pcx ;
  double __cil_tmp47 ;
  int pcy ;
  double __cil_tmp49 ;
  int precno_x ;
  double __cil_tmp51 ;
  int precno_y ;
  double __cil_tmp53 ;
  int x0___0 ;
  double __cil_tmp62 ;
  int y0___21 ;
  double __cil_tmp64 ;
  int x1___0 ;
  int y1___22 ;
  int max_numprec ;
  int numprec___0 ;
  int numprec___1 ;
  int pcnx___0 ;
  int pcx___0 ;
  double __cil_tmp73 ;
  int pcy___0 ;
  double __cil_tmp75 ;
  int precno_x___0 ;
  double __cil_tmp77 ;
  int precno_y___0 ;
  double __cil_tmp79 ;
  int max_numprec___0 ;
  int numprec___2 ;
  int x0___1 ;
  double __cil_tmp91 ;
  int y0___23 ;
  double __cil_tmp93 ;
  int x1___1 ;
  int y1___24 ;
  int numprec___3 ;
  int pcnx___1 ;
  int pcx___1 ;
  double __cil_tmp99 ;
  int pcy___1 ;
  double __cil_tmp101 ;
  int precno_x___1 ;
  double __cil_tmp103 ;
  int precno_y___1 ;
  double __cil_tmp105 ;

  {
#line 51
  stream = (FILE *)((void *)0);
#line 52
  total_disto = (double )0;
#line 63
  if (! cstr_info) {
#line 64
    return (1);
  }
  {
#line 66
  stream = fopen((char const   *)index___0, "w");
  }
#line 67
  if (! stream) {
    {
#line 68
    fprintf(stderr, "failed to open index file [%s] for writing\n", index___0);
    }
#line 69
    return (1);
  }
#line 72
  if ((cstr_info->tile + 0)->distotile) {
#line 73
    disto_on = (char)1;
  } else {
#line 75
    disto_on = (char)0;
  }
#line 77
  if ((cstr_info->tile + 0)->numpix) {
#line 78
    numpix_on = (char)1;
  } else {
#line 80
    numpix_on = (char)0;
  }
  {
#line 82
  fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
#line 83
  fprintf(stream, "%d\n", (int )cstr_info->prog);
#line 84
  fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
#line 85
  fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
#line 86
  fprintf(stream, "%d\n", cstr_info->numcomps);
#line 87
  fprintf(stream, "%d\n", cstr_info->numlayers);
#line 88
  fprintf(stream, "%d\n", *(cstr_info->numdecompos + 0));
#line 90
  resno = *(cstr_info->numdecompos + 0);
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;

#line 90
    if (! (resno >= 0)) {
#line 90
      goto while_break;
    }
    {
#line 91
    fprintf(stream, "[%d,%d] \251", 1 << (cstr_info->tile + 0)->pdx[resno], 1 << (cstr_info->tile + 0)->pdx[resno]);
#line 90
    __cil_tmp17 = resno;
#line 90
    resno --;
    }
  }
  while_break___33: /* CIL Label */ ;
  }
  while_break: 
  {
#line 95
  fprintf(stream, "\n");
#line 97
  fprintf(stream, "%d\n", cstr_info->main_head_start);
#line 99
  fprintf(stream, "%d\n", cstr_info->main_head_end);
#line 100
  fprintf(stream, "%d\n", cstr_info->codestream_size);
#line 102
  fprintf(stream, "\nINFO ON TILES\n");
#line 103
  fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts");
  }
#line 104
  if (disto_on) {
    {
#line 105
    fprintf(stream, "         disto");
    }
  }
#line 106
  if (numpix_on) {
    {
#line 107
    fprintf(stream, "     nbpix");
    }
  }
#line 108
  if ((int )disto_on) {
#line 108
    if ((int )numpix_on) {
      {
#line 109
      fprintf(stream, "  disto/nbpix");
      }
    }
  }
  {
#line 110
  fprintf(stream, "\n");
#line 112
  tileno = 0;
  }
  {
#line 112
  while (1) {
    while_continue___29: /* CIL Label */ ;

#line 112
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 112
      goto while_break___0;
    }
    {
#line 113
    fprintf(stream, "%4d %9d %9d %9d %9d", (cstr_info->tile + tileno)->tileno, (cstr_info->tile + tileno)->start_pos,
            (cstr_info->tile + tileno)->end_header, (cstr_info->tile + tileno)->end_pos,
            (cstr_info->tile + tileno)->num_tps);
    }
#line 119
    if (disto_on) {
      {
#line 120
      fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile);
      }
    }
#line 121
    if (numpix_on) {
      {
#line 122
      fprintf(stream, " %9d", (cstr_info->tile + tileno)->numpix);
      }
    }
#line 123
    if ((int )disto_on) {
#line 123
      if ((int )numpix_on) {
        {
#line 124
        fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile / (double )(cstr_info->tile + tileno)->numpix);
        }
      }
    }
    {
#line 125
    fprintf(stream, "\n");
#line 112
    tileno ++;
    }
  }
  while_break___34: /* CIL Label */ ;
  }
  while_break___0: 
#line 128
  tileno = 0;
  {
#line 128
  while (1) {
    while_continue___30: /* CIL Label */ ;

#line 128
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 128
      goto while_break___1;
    }
#line 130
    disto = (double )0;
#line 131
    max_numdecompos = 0;
#line 132
    pack_nb = 0;
#line 134
    compno = 0;
    {
#line 134
    while (1) {
      while_continue___31: /* CIL Label */ ;

#line 134
      if (! (compno < cstr_info->numcomps)) {
#line 134
        goto while_break___2;
      }
#line 135
      if (max_numdecompos < *(cstr_info->numdecompos + compno)) {
#line 136
        max_numdecompos = *(cstr_info->numdecompos + compno);
      }
#line 134
      compno ++;
    }
    while_break___36: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 139
    fprintf(stream, "\nTILE %d DETAILS\n", tileno);
#line 140
    fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
#line 141
    tilepartno = 0;
    }
    {
#line 141
    while (1) {
      while_continue___32: /* CIL Label */ ;

#line 141
      if (! (tilepartno < (cstr_info->tile + tileno)->num_tps)) {
#line 141
        goto while_break___3;
      }
      {
#line 142
      fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n\230\001", tilepartno, tileno,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pack, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_numpacks,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pos, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_header,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_pos);
#line 141
      tilepartno ++;
      }
    }
    while_break___37: /* CIL Label */ ;
    }
    while_break___3: ;
#line 151
    if ((int )cstr_info->prog == 0) {
      {
#line 152
      fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos");
      }
#line 153
      if (disto_on) {
        {
#line 154
        fprintf(stream, " disto");
        }
      }
      {
#line 155
      fprintf(stream, "\n");
#line 157
      layno = 0;
      }
      {
#line 157
      while (1) {
        while_continue___33: /* CIL Label */ ;

#line 157
        if (! (layno < cstr_info->numlayers)) {
#line 157
          goto while_break___4;
        }
#line 158
        resno = 0;
        {
#line 158
        while (1) {
          while_continue___34: /* CIL Label */ ;

#line 158
          if (! (resno < max_numdecompos + 1)) {
#line 158
            goto while_break___5;
          }
#line 159
          compno = 0;
          {
#line 159
          while (1) {
            while_continue___35: /* CIL Label */ ;

#line 159
            if (! (compno < cstr_info->numcomps)) {
#line 159
              goto while_break___6;
            }
#line 161
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 162
              goto while_break___6;
            }
#line 163
            prec_max = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 164
            precno = 0;
            {
#line 164
            while (1) {
              while_continue___36: /* CIL Label */ ;

#line 164
              if (! (precno < prec_max)) {
#line 164
                goto while_break___7;
              }
              {
#line 165
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 166
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 167
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 168
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 169
              fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6ld     %6ld %7ld", pack_nb,
                      tileno, layno, resno, compno, precno, start_pos, end_ph_pos,
                      end_pos);
              }
#line 171
              if (disto_on) {
                {
#line 172
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 173
              fprintf(stream, "\n");
#line 174
              total_disto += disto;
#line 175
              pack_nb ++;
#line 164
              precno ++;
              }
            }
            while_break___41: /* CIL Label */ ;
            }
            while_break___7: 
#line 159
            compno ++;
          }
          while_break___40: /* CIL Label */ ;
          }
          while_break___6: 
#line 158
          resno ++;
        }
        while_break___39: /* CIL Label */ ;
        }
        while_break___5: 
#line 157
        layno ++;
      }
      while_break___38: /* CIL Label */ ;
      }
      while_break___4: ;
    } else
#line 182
    if ((int )cstr_info->prog == 1) {
      {
#line 183
      fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
      }
#line 184
      if (disto_on) {
        {
#line 185
        fprintf(stream, " disto");
        }
      }
      {
#line 186
      fprintf(stream, "\n");
#line 188
      resno = 0;
      }
      {
#line 188
      while (1) {
        while_continue___37: /* CIL Label */ ;

#line 188
        if (! (resno < max_numdecompos + 1)) {
#line 188
          goto while_break___8;
        }
#line 189
        layno = 0;
        {
#line 189
        while (1) {
          while_continue___38: /* CIL Label */ ;

#line 189
          if (! (layno < cstr_info->numlayers)) {
#line 189
            goto while_break___9;
          }
#line 190
          compno = 0;
          {
#line 190
          while (1) {
            while_continue___39: /* CIL Label */ ;

#line 190
            if (! (compno < cstr_info->numcomps)) {
#line 190
              goto while_break___10;
            }
#line 192
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 193
              goto while_break___10;
            }
#line 194
            prec_max___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 195
            precno = 0;
            {
#line 195
            while (1) {
              while_continue___40: /* CIL Label */ ;

#line 195
              if (! (precno < prec_max___0)) {
#line 195
                goto while_break___11;
              }
              {
#line 196
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 197
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 198
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 199
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 200
              fprintf(stream, "%4d %6d %5d %7d %6d %6d %9ld   %9ld %7ld\230\001",
                      pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos,
                      end_pos);
              }
#line 202
              if (disto_on) {
                {
#line 203
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 204
              fprintf(stream, "\n");
#line 205
              total_disto += disto;
#line 206
              pack_nb ++;
#line 195
              precno ++;
              }
            }
            while_break___45: /* CIL Label */ ;
            }
            while_break___11: 
#line 190
            compno ++;
          }
          while_break___44: /* CIL Label */ ;
          }
          while_break___10: 
#line 189
          layno ++;
        }
        while_break___43: /* CIL Label */ ;
        }
        while_break___9: 
#line 188
        resno ++;
      }
      while_break___42: /* CIL Label */ ;
      }
      while_break___8: ;
    } else
#line 213
    if ((int )cstr_info->prog == 2) {
      {
#line 215
      fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos");
      }
#line 216
      if (disto_on) {
        {
#line 217
        fprintf(stream, " disto");
        }
      }
      {
#line 218
      fprintf(stream, "\n");
#line 220
      resno = 0;
      }
      {
#line 220
      while (1) {
        while_continue___41: /* CIL Label */ ;

#line 220
        if (! (resno < max_numdecompos + 1)) {
#line 220
          goto while_break___12;
        }
#line 221
        numprec = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 222
        precno = 0;
        {
#line 222
        while (1) {
          while_continue___42: /* CIL Label */ ;

#line 222
          if (! (precno < numprec)) {
#line 222
            goto while_break___13;
          }
          {
#line 224
          __cil_tmp40 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 224
          x0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp40 * cstr_info->tw) * cstr_info->tile_x;
#line 225
          __cil_tmp42 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 225
          y0___19 = cstr_info->tile_Ox + (int )__cil_tmp42 * cstr_info->tile_y;
#line 226
          x1 = x0 + cstr_info->tile_x;
#line 227
          y1___20 = y0___19 + cstr_info->tile_y;
#line 228
          compno = 0;
          }
          {
#line 228
          while (1) {
            while_continue___43: /* CIL Label */ ;

#line 228
            if (! (compno < cstr_info->numcomps)) {
#line 228
              goto while_break___14;
            }
            {
#line 229
            pcnx = (cstr_info->tile + tileno)->pw[resno];
#line 230
            __cil_tmp47 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 230
            pcx = (int )__cil_tmp47;
#line 231
            __cil_tmp49 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 231
            pcy = (int )__cil_tmp49;
#line 232
            __cil_tmp51 = floor((double )((float )precno / (float )pcnx));
#line 232
            precno_x = precno - (int )__cil_tmp51 * pcnx;
#line 233
            __cil_tmp53 = floor((double )((float )precno / (float )pcnx));
#line 233
            precno_y = (int )__cil_tmp53;
            }
#line 234
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 235
              goto while_break___14;
            }
#line 236
            y = y0___19;
            {
#line 236
            while (1) {
              while_continue___44: /* CIL Label */ ;

#line 236
              if (! (y < y1___20)) {
#line 236
                goto while_break___15;
              }
#line 237
              if (precno_y * pcy == y) {
#line 238
                x = x0;
                {
#line 238
                while (1) {
                  while_continue___45: /* CIL Label */ ;

#line 238
                  if (! (x < x1)) {
#line 238
                    goto while_break___16;
                  }
#line 239
                  if (precno_x * pcx == x) {
#line 240
                    layno = 0;
                    {
#line 240
                    while (1) {
                      while_continue___46: /* CIL Label */ ;

#line 240
                      if (! (layno < cstr_info->numlayers)) {
#line 240
                        goto while_break___17;
                      }
                      {
#line 241
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 242
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 243
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 244
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 245
                      fprintf(stream, "%4d %6d %5d %6d %6d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno, resno, precno, compno, layno, start_pos,
                              end_ph_pos, end_pos);
                      }
#line 247
                      if (disto_on) {
                        {
#line 248
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 249
                      fprintf(stream, "\n");
#line 250
                      total_disto += disto;
#line 251
                      pack_nb ++;
#line 240
                      layno ++;
                      }
                    }
                    while_break___51: /* CIL Label */ ;
                    }
                    while_break___17: ;
                  }
#line 238
                  x ++;
                }
                while_break___50: /* CIL Label */ ;
                }
                while_break___16: ;
              }
#line 236
              y ++;
            }
            while_break___49: /* CIL Label */ ;
            }
            while_break___15: 
#line 228
            compno ++;
          }
          while_break___48: /* CIL Label */ ;
          }
          while_break___14: 
#line 222
          precno ++;
        }
        while_break___47: /* CIL Label */ ;
        }
        while_break___13: 
#line 220
        resno ++;
      }
      while_break___46: /* CIL Label */ ;
      }
      while_break___12: ;
    } else
#line 262
    if ((int )cstr_info->prog == 3) {
      {
#line 264
      __cil_tmp62 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 264
      x0___0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp62 * cstr_info->tw) * cstr_info->tile_x;
#line 265
      __cil_tmp64 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 265
      y0___21 = cstr_info->tile_Ox + (int )__cil_tmp64 * cstr_info->tile_y;
#line 266
      x1___0 = x0___0 + cstr_info->tile_x;
#line 267
      y1___22 = y0___21 + cstr_info->tile_y;
#line 270
      max_numprec = 0;
#line 271
      resno = 0;
      }
      {
#line 271
      while (1) {
        while_continue___47: /* CIL Label */ ;

#line 271
        if (! (resno < max_numdecompos + 1)) {
#line 271
          goto while_break___18;
        }
#line 272
        numprec___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 273
        if (numprec___0 > max_numprec) {
#line 274
          max_numprec = numprec___0;
        }
#line 271
        resno ++;
      }
      while_break___52: /* CIL Label */ ;
      }
      while_break___18: 
      {
#line 277
      fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos");
      }
#line 278
      if (disto_on) {
        {
#line 279
        fprintf(stream, " disto");
        }
      }
      {
#line 280
      fprintf(stream, "\n");
#line 282
      precno = 0;
      }
      {
#line 282
      while (1) {
        while_continue___48: /* CIL Label */ ;

#line 282
        if (! (precno < max_numprec)) {
#line 282
          goto while_break___19;
        }
#line 283
        compno = 0;
        {
#line 283
        while (1) {
          while_continue___49: /* CIL Label */ ;

#line 283
          if (! (compno < cstr_info->numcomps)) {
#line 283
            goto while_break___20;
          }
#line 284
          resno = 0;
          {
#line 284
          while (1) {
            while_continue___50: /* CIL Label */ ;
            while_continue___21: ;
#line 284
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 284
              goto while_break___21;
            }
            {
#line 285
            numprec___1 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 286
            pcnx___0 = (cstr_info->tile + tileno)->pw[resno];
#line 287
            __cil_tmp73 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 287
            pcx___0 = (int )__cil_tmp73;
#line 288
            __cil_tmp75 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 288
            pcy___0 = (int )__cil_tmp75;
#line 289
            __cil_tmp77 = floor((double )((float )precno / (float )pcnx___0));
#line 289
            precno_x___0 = precno - (int )__cil_tmp77 * pcnx___0;
#line 290
            __cil_tmp79 = floor((double )((float )precno / (float )pcnx___0));
#line 290
            precno_y___0 = (int )__cil_tmp79;
            }
#line 291
            if (precno >= numprec___1) {
#line 292
              goto while_continue___21;
            }
#line 293
            y = y0___21;
            {
#line 293
            while (1) {
              while_continue___51: /* CIL Label */ ;

#line 293
              if (! (y < y1___22)) {
#line 293
                goto while_break___22;
              }
#line 294
              if (precno_y___0 * pcy___0 == y) {
#line 295
                x = x0___0;
                {
#line 295
                while (1) {
                  while_continue___52: /* CIL Label */ ;

#line 295
                  if (! (x < x1___0)) {
#line 295
                    goto while_break___23;
                  }
#line 296
                  if (precno_x___0 * pcx___0 == x) {
#line 297
                    layno = 0;
                    {
#line 297
                    while (1) {
                      while_continue___53: /* CIL Label */ ;

#line 297
                      if (! (layno < cstr_info->numlayers)) {
#line 297
                        goto while_break___24;
                      }
                      {
#line 298
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 299
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 300
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 301
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 302
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno, precno, compno, resno, layno, start_pos,
                              end_ph_pos, end_pos);
                      }
#line 304
                      if (disto_on) {
                        {
#line 305
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 306
                      fprintf(stream, "\n");
#line 307
                      total_disto += disto;
#line 308
                      pack_nb ++;
#line 297
                      layno ++;
                      }
                    }
                    while_break___58: /* CIL Label */ ;
                    }
                    while_break___24: ;
                  }
#line 295
                  x ++;
                }
                while_break___57: /* CIL Label */ ;
                }
                while_break___23: ;
              }
#line 293
              y ++;
            }
            while_break___56: /* CIL Label */ ;
            }
            while_break___22: 
#line 284
            resno ++;
          }
          while_break___55: /* CIL Label */ ;
          }
          while_break___21: 
#line 283
          compno ++;
        }
        while_break___54: /* CIL Label */ ;
        }
        while_break___20: 
#line 282
        precno ++;
      }
      while_break___53: /* CIL Label */ ;
      }
      while_break___19: ;
    } else {
#line 321
      max_numprec___0 = 0;
#line 322
      resno = 0;
      {
#line 322
      while (1) {
        while_continue___54: /* CIL Label */ ;

#line 322
        if (! (resno < max_numdecompos + 1)) {
#line 322
          goto while_break___25;
        }
#line 323
        numprec___2 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 324
        if (numprec___2 > max_numprec___0) {
#line 325
          max_numprec___0 = numprec___2;
        }
#line 322
        resno ++;
      }
      while_break___59: /* CIL Label */ ;
      }
      while_break___25: 
      {
#line 328
      fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos");
      }
#line 329
      if (disto_on) {
        {
#line 330
        fprintf(stream, " disto");
        }
      }
      {
#line 331
      fprintf(stream, "\n");
#line 333
      compno = 0;
      }
      {
#line 333
      while (1) {
        while_continue___55: /* CIL Label */ ;

#line 333
        if (! (compno < cstr_info->numcomps)) {
#line 333
          goto while_break___26;
        }
        {
#line 335
        __cil_tmp91 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 335
        x0___1 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp91 * cstr_info->tw) * cstr_info->tile_x;
#line 336
        __cil_tmp93 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 336
        y0___23 = cstr_info->tile_Ox + (int )__cil_tmp93 * cstr_info->tile_y;
#line 337
        x1___1 = x0___1 + cstr_info->tile_x;
#line 338
        y1___24 = y0___23 + cstr_info->tile_y;
#line 340
        precno = 0;
        }
        {
#line 340
        while (1) {
          while_continue___56: /* CIL Label */ ;

#line 340
          if (! (precno < max_numprec___0)) {
#line 340
            goto while_break___27;
          }
#line 341
          resno = 0;
          {
#line 341
          while (1) {
            while_continue___57: /* CIL Label */ ;
            while_continue___28: ;
#line 341
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 341
              goto while_break___28;
            }
            {
#line 342
            numprec___3 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 343
            pcnx___1 = (cstr_info->tile + tileno)->pw[resno];
#line 344
            __cil_tmp99 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 344
            pcx___1 = (int )__cil_tmp99;
#line 345
            __cil_tmp101 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 345
            pcy___1 = (int )__cil_tmp101;
#line 346
            __cil_tmp103 = floor((double )((float )precno / (float )pcnx___1));
#line 346
            precno_x___1 = precno - (int )__cil_tmp103 * pcnx___1;
#line 347
            __cil_tmp105 = floor((double )((float )precno / (float )pcnx___1));
#line 347
            precno_y___1 = (int )__cil_tmp105;
            }
#line 348
            if (precno >= numprec___3) {
#line 349
              goto while_continue___28;
            }
#line 351
            y = y0___23;
            {
#line 351
            while (1) {
              while_continue___58: /* CIL Label */ ;

#line 351
              if (! (y < y1___24)) {
#line 351
                goto while_break___29;
              }
#line 352
              if (precno_y___1 * pcy___1 == y) {
#line 353
                x = x0___1;
                {
#line 353
                while (1) {
                  while_continue___59: /* CIL Label */ ;

#line 353
                  if (! (x < x1___1)) {
#line 353
                    goto while_break___30;
                  }
#line 354
                  if (precno_x___1 * pcx___1 == x) {
#line 355
                    layno = 0;
                    {
#line 355
                    while (1) {
                      while_continue___60: /* CIL Label */ ;

#line 355
                      if (! (layno < cstr_info->numlayers)) {
#line 355
                        goto while_break___31;
                      }
                      {
#line 356
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 357
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 358
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 359
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 360
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno, compno, precno, resno, layno, start_pos,
                              end_ph_pos, end_pos);
                      }
#line 362
                      if (disto_on) {
                        {
#line 363
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 364
                      fprintf(stream, "\n");
#line 365
                      total_disto += disto;
#line 366
                      pack_nb ++;
#line 355
                      layno ++;
                      }
                    }
                    while_break___65: /* CIL Label */ ;
                    }
                    while_break___31: ;
                  }
#line 353
                  x ++;
                }
                while_break___64: /* CIL Label */ ;
                }
                while_break___30: ;
              }
#line 351
              y ++;
            }
            while_break___63: /* CIL Label */ ;
            }
            while_break___29: 
#line 341
            resno ++;
          }
          while_break___62: /* CIL Label */ ;
          }
          while_break___28: 
#line 340
          precno ++;
        }
        while_break___61: /* CIL Label */ ;
        }
        while_break___27: 
#line 333
        compno ++;
      }
      while_break___60: /* CIL Label */ ;
      }
      while_break___26: ;
    }
#line 128
    tileno ++;
  }
  while_break___35: /* CIL Label */ ;
  }
  while_break___1: ;
#line 378
  if (disto_on) {
    {
#line 379
    fprintf(stream, "%8e\n", cstr_info->D_max);
#line 380
    fprintf(stream, "%.8e\n", total_disto);
    }
  }
#line 384
  if (cstr_info->marknum) {
    {
#line 385
    fprintf(stream, "\nMARKER LIST\n");
#line 386
    fprintf(stream, "%d\n", cstr_info->marknum);
#line 387
    fprintf(stream, "type\tstart_pos    length\n");
#line 388
    x = 0;
    }
    {
#line 388
    while (1) {
      while_continue___61: /* CIL Label */ ;

#line 388
      if (! (x < cstr_info->marknum)) {
#line 388
        goto while_break___32;
      }
      {
#line 389
      fprintf(stream, "%X\t%9ld %9d\n\230\001", (int )(cstr_info->marker + x)->type,
              (cstr_info->marker + x)->pos, (cstr_info->marker + x)->len);
#line 388
      x ++;
      }
    }
    while_break___66: /* CIL Label */ ;
    }
    while_break___32: ;
  }
  {
#line 392
  fclose(stream);
#line 394
  fprintf(stderr, "Generated index file %s\n\230\001", index___0);
  }
#line 396
  return (0);
}
}
#line 293 "/usr/include/x86_64-linux-gnu/tiffio.h"
extern void *_TIFFmalloc(tmsize_t s ) ;
#line 299
extern void _TIFFfree(void *p ) ;
#line 343
extern void TIFFClose(TIFF *tif ) ;
#line 346
extern int TIFFGetField(TIFF *tif , uint32 tag  , ...) ;
#line 348
extern int TIFFGetFieldDefaulted(TIFF *tif , uint32 tag  , ...) ;
#line 358
extern tmsize_t TIFFStripSize(TIFF *tif ) ;
#line 407
extern int TIFFSetField(TIFF * , uint32   , ...) ;
#line 440
extern TIFF *TIFFOpen(char const   * , char const   * ) ;
#line 469
extern tmsize_t TIFFReadEncodedStrip(TIFF *tif , uint32 strip , void *buf , tmsize_t size ) ;
#line 476
extern tmsize_t TIFFWriteEncodedStrip(TIFF *tif , uint32 strip , void *data , tmsize_t cc ) ;
#line 58 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 67
extern  __attribute__((__nothrow__)) void longjmp(struct __jmp_buf_tag *__env , int __val ) ;
#line 929 "/usr/include/png.h"
extern void png_set_sig_bytes(png_structrp png_ptr , int num_bytes ) ;
#line 945
extern png_structp png_create_read_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                          void (*error_fn)(png_structp  , png_const_charp  ) ,
                                          void (*warn_fn)(png_structp  , png_const_charp  ) ) ;
#line 951
extern png_structp png_create_write_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                           void (*error_fn)(png_structp  , png_const_charp  ) ,
                                           void (*warn_fn)(png_structp  , png_const_charp  ) ) ;
#line 973
extern jmp_buf *png_set_longjmp_fn(png_structrp png_ptr , void (*longjmp_fn)(struct __jmp_buf_tag * ,
                                                                             int  ) ,
                                   size_t jmp_buf_size ) ;
#line 1027
extern png_infop png_create_info_struct(png_const_structrp png_ptr ) ;
#line 1040
extern void png_write_info(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1045
extern void png_read_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1074
extern void png_set_expand(png_structrp png_ptr ) ;
#line 1094
extern void png_set_gray_to_rgb(png_structrp png_ptr ) ;
#line 1285
extern void png_set_packing(png_structrp png_ptr ) ;
#line 1373
extern void png_set_gamma(png_structrp png_ptr , double screen_gamma , double override_file_gamma ) ;
#line 1390
extern void png_read_update_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1407
extern void png_read_image(png_structrp png_ptr , png_bytepp image ) ;
#line 1411
extern void png_write_row(png_structrp png_ptr , png_const_bytep row ) ;
#line 1426
extern void png_write_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1439
extern void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                                    png_infopp end_info_ptr_ptr ) ;
#line 1443
extern void png_destroy_write_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ) ;
#line 1531
extern void png_set_compression_level(png_structrp png_ptr , int level ) ;
#line 1583
extern void png_init_io(png_structrp png_ptr , png_FILE_p fp ) ;
#line 1861
extern png_uint_32 png_get_valid(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                 png_uint_32 flag ) ;
#line 1865
extern size_t png_get_rowbytes(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1896
extern png_byte png_get_bit_depth(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1900
extern png_byte png_get_color_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2017
extern png_uint_32 png_get_gAMA(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                double *file_gamma ) ;
#line 2038
extern png_uint_32 png_get_IHDR(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_uint_32 *width , png_uint_32 *height , int *bit_depth ,
                                int *color_type , int *interlace_method , int *compression_method ,
                                int *filter_method ) ;
#line 2043
extern void png_set_IHDR(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 width ,
                         png_uint_32 height , int bit_depth , int color_type , int interlace_method ,
                         int compression_method , int filter_method ) ;
#line 2074
extern png_uint_32 png_get_pHYs(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_uint_32 *res_x , png_uint_32 *res_y , int *unit_type ) ;
#line 2096
extern void png_set_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_8p sig_bit ) ;
#line 2106
extern void png_set_sRGB(png_const_structrp png_ptr , png_inforp info_ptr , int srgb_intent ) ;
#line 69 "/root/patchweave_new/10/src/bin/jp2/convert.h"
void clip_component(opj_image_comp_t *component , OPJ_UINT32 precision ) ;
#line 71
void scale_component(opj_image_comp_t *component , OPJ_UINT32 precision ) ;
#line 74
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 75
int imagetotga(opj_image_t *image , char const   *outfile ) ;
#line 78
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 79
int imagetobmp(opj_image_t *image , char const   *outfile ) ;
#line 82
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 83
int imagetotif(opj_image_t *image , char const   *outfile ) ;
#line 90
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 91
int imagetopgx(opj_image_t *image , char const   *outfile ) ;
#line 93
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 94
int imagetopnm(opj_image_t *image , char const   *outfile ) ;
#line 97
int imagetoraw(opj_image_t *image , char const   *outfile ) ;
#line 98
int imagetorawl(opj_image_t *image , char const   *outfile ) ;
#line 99
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) ;
#line 100
opj_image_t *rawltoimage(char const   *filename , opj_cparameters_t *parameters ,
                         raw_cparameters_t *raw_cp ) ;
#line 103
int imagetopng(opj_image_t *image , char const   *write_idf ) ;
#line 104
opj_image_t *pngtoimage(char const   *read_idf , opj_cparameters_t *params ) ;
#line 62 "/root/patchweave_new/10/src/bin/jp2/convert.c"
static int int_floorlog2(int a ) 
{ 
  int l ;

  {
#line 64
  l = 0;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;

#line 64
    if (! (a > 1)) {
#line 64
      goto while_break;
    }
#line 65
    a >>= 1;
#line 64
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 67
  return (l);
}
}
#line 71 "/root/patchweave_new/10/src/bin/jp2/convert.c"
void clip_component(opj_image_comp_t *component , OPJ_UINT32 precision ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_SIZE_T len ;
  OPJ_UINT32 umax ;
  OPJ_INT32 *l_data ;
  OPJ_INT32 max ;
  OPJ_INT32 min ;
  OPJ_UINT32 *l_data___0 ;

  {
#line 75
  umax = (OPJ_UINT32 )-1;
#line 77
  len = (OPJ_SIZE_T )component->w * (OPJ_SIZE_T )component->h;
#line 78
  if (precision < 32U) {
#line 79
    umax = (1U << precision) - 1U;
  }
#line 82
  if (component->sgnd) {
#line 83
    l_data = component->data;
#line 84
    max = (OPJ_INT32 )(umax / 2U);
#line 85
    min = - max - 1;
#line 86
    i = (OPJ_SIZE_T )0;
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;

#line 86
      if (! (i < len)) {
#line 86
        goto while_break;
      }
#line 87
      if (*(l_data + i) > max) {
#line 88
        *(l_data + i) = max;
      } else
#line 89
      if (*(l_data + i) < min) {
#line 90
        *(l_data + i) = min;
      }
#line 86
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 94
    l_data___0 = (OPJ_UINT32 *)component->data;
#line 95
    i = (OPJ_SIZE_T )0;
    {
#line 95
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 95
      if (! (i < len)) {
#line 95
        goto while_break___0;
      }
#line 96
      if (*(l_data___0 + i) > umax) {
#line 97
        *(l_data___0 + i) = umax;
      }
#line 95
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 101
  component->prec = precision;
#line 102
  return;
}
}
#line 105 "/root/patchweave_new/10/src/bin/jp2/convert.c"
void scale_component(opj_image_comp_t *component , OPJ_UINT32 precision ) 
{ 
  int shift ;
  OPJ_SIZE_T i ;
  OPJ_SIZE_T len ;
  OPJ_INT32 *l_data ;
  OPJ_UINT32 *l_data___0 ;

  {
#line 111
  if (component->prec == precision) {
#line 112
    return;
  }
#line 114
  if (component->prec < precision) {
#line 115
    shift = (int )(precision - component->prec);
  } else {
#line 117
    shift = (int )(component->prec - precision);
  }
#line 119
  len = (OPJ_SIZE_T )component->w * (OPJ_SIZE_T )component->h;
#line 121
  if (component->sgnd) {
#line 122
    l_data = component->data;
#line 123
    if (component->prec < precision) {
#line 124
      i = (OPJ_SIZE_T )0;
      {
#line 124
      while (1) {
        while_continue: /* CIL Label */ ;

#line 124
        if (! (i < len)) {
#line 124
          goto while_break;
        }
#line 125
        *(l_data + i) <<= shift;
#line 124
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break: ;
    } else {
#line 128
      i = (OPJ_SIZE_T )0;
      {
#line 128
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 128
        if (! (i < len)) {
#line 128
          goto while_break___0;
        }
#line 129
        *(l_data + i) >>= shift;
#line 128
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: ;
    }
  } else {
#line 133
    l_data___0 = (OPJ_UINT32 *)component->data;
#line 134
    if (component->prec < precision) {
#line 135
      i = (OPJ_SIZE_T )0;
      {
#line 135
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 135
        if (! (i < len)) {
#line 135
          goto while_break___1;
        }
#line 136
        *(l_data___0 + i) <<= shift;
#line 135
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: ;
    } else {
#line 139
      i = (OPJ_SIZE_T )0;
      {
#line 139
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 139
        if (! (i < len)) {
#line 139
          goto while_break___2;
        }
#line 140
        *(l_data___0 + i) >>= shift;
#line 139
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: ;
    }
  }
#line 144
  component->prec = precision;
#line 145
  return;
}
}
#line 179 "/root/patchweave_new/10/src/bin/jp2/convert.c"
static unsigned short get_ushort(unsigned short val ) 
{ 


  {
#line 184
  return (val);
}
}
#line 191 "/root/patchweave_new/10/src/bin/jp2/convert.c"
static int tga_readheader(FILE *fp , unsigned int *bits_per_pixel , unsigned int *width ,
                          unsigned int *height , int *flip_image ) 
{ 
  int palette_size ;
  unsigned char *tga ;
  unsigned char id_len ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned short cmap_len ;
  unsigned short cmap_entry_size ;
  unsigned short image_w ;
  unsigned short image_h ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned char *id ;
  void *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;

  {
#line 201
  if (! bits_per_pixel) {
#line 202
    return (0);
  } else
#line 201
  if (! width) {
#line 202
    return (0);
  } else
#line 201
  if (! height) {
#line 202
    return (0);
  } else
#line 201
  if (! flip_image) {
#line 202
    return (0);
  }
  {
#line 203
  __cil_tmp16 = malloc(18UL);
#line 203
  tga = (unsigned char *)__cil_tmp16;
#line 205
  __cil_tmp17 = fread((void *)tga, 18UL, 1UL, fp);
  }
#line 205
  if (__cil_tmp17 != 1UL) {
    {
#line 207
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 208
    return (0);
  }
  {
#line 210
  id_len = *(tga + 0);
#line 212
  image_type = *(tga + 2);
#line 214
  cmap_len = get_ushort(*((unsigned short *)(tga + 5)));
#line 215
  cmap_entry_size = (unsigned short )*(tga + 7);
#line 222
  image_w = get_ushort(*((unsigned short *)(tga + 12)));
#line 223
  image_h = get_ushort(*((unsigned short *)(tga + 14)));
#line 224
  pixel_depth = *(tga + 16);
#line 225
  image_desc = *(tga + 17);
#line 227
  free((void *)tga);
#line 229
  *bits_per_pixel = (unsigned int )pixel_depth;
#line 230
  *width = (unsigned int )image_w;
#line 231
  *height = (unsigned int )image_h;
  }
#line 234
  if (id_len) {
    {
#line 236
    __cil_tmp22 = malloc((unsigned long )id_len);
#line 236
    id = (unsigned char *)__cil_tmp22;
#line 237
    __cil_tmp23 = fread((void *)id, (unsigned long )id_len, 1UL, fp);
    }
#line 237
    if (! __cil_tmp23) {
      {
#line 239
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 240
      free((void *)id);
      }
#line 241
      return (0);
    }
    {
#line 243
    free((void *)id);
    }
  }
#line 249
  if ((int )image_type > 8) {
    {
#line 251
    fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
    }
#line 252
    return (0);
  }
#line 255
  *flip_image = ! ((int )image_desc & 32);
#line 258
  palette_size = (int )cmap_len * ((int )cmap_entry_size / 8);
#line 260
  if (palette_size > 0) {
    {
#line 262
    fprintf(stderr, "File contains a palette - not yet supported.");
#line 263
    fseek(fp, (long )palette_size, 1);
    }
  }
#line 265
  return (1);
}
}
#line 278 "/root/patchweave_new/10/src/bin/jp2/convert.c"
static int tga_writeheader(FILE *fp , int bits_per_pixel , int width , int height ,
                           OPJ_BOOL flip_image ) 
{ 
  unsigned short image_w ;
  unsigned short image_h ;
  unsigned short us0 ;
  unsigned char uc0 ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;

  {
#line 285
  if (! bits_per_pixel) {
#line 286
    return (0);
  } else
#line 285
  if (! width) {
#line 286
    return (0);
  } else
#line 285
  if (! height) {
#line 286
    return (0);
  }
#line 288
  pixel_depth = (unsigned char)0;
#line 290
  if (bits_per_pixel < 256) {
#line 291
    pixel_depth = (unsigned char )bits_per_pixel;
  } else {
    {
#line 293
    fprintf(stderr, "ERROR: Wrong bits per pixel inside tga_header");
    }
#line 294
    return (0);
  }
  {
#line 296
  uc0 = (unsigned char)0;
#line 298
  __cil_tmp13 = fwrite((void const   *)(& uc0), 1UL, 1UL, fp);
  }
#line 298
  if (__cil_tmp13 != 1UL) {
#line 298
    goto fails;
  }
  {
#line 299
  __cil_tmp14 = fwrite((void const   *)(& uc0), 1UL, 1UL, fp);
  }
#line 299
  if (__cil_tmp14 != 1UL) {
#line 299
    goto fails;
  }
  {
#line 301
  image_type = (unsigned char)2;
#line 302
  __cil_tmp15 = fwrite((void const   *)(& image_type), 1UL, 1UL, fp);
  }
#line 302
  if (__cil_tmp15 != 1UL) {
#line 302
    goto fails;
  }
  {
#line 304
  us0 = (unsigned short)0;
#line 305
  __cil_tmp16 = fwrite((void const   *)(& us0), 2UL, 1UL, fp);
  }
#line 305
  if (__cil_tmp16 != 1UL) {
#line 305
    goto fails;
  }
  {
#line 306
  __cil_tmp17 = fwrite((void const   *)(& us0), 2UL, 1UL, fp);
  }
#line 306
  if (__cil_tmp17 != 1UL) {
#line 306
    goto fails;
  }
  {
#line 307
  __cil_tmp18 = fwrite((void const   *)(& uc0), 1UL, 1UL, fp);
  }
#line 307
  if (__cil_tmp18 != 1UL) {
#line 307
    goto fails;
  }
  {
#line 309
  __cil_tmp19 = fwrite((void const   *)(& us0), 2UL, 1UL, fp);
  }
#line 309
  if (__cil_tmp19 != 1UL) {
#line 309
    goto fails;
  }
  {
#line 310
  __cil_tmp20 = fwrite((void const   *)(& us0), 2UL, 1UL, fp);
  }
#line 310
  if (__cil_tmp20 != 1UL) {
#line 310
    goto fails;
  }
  {
#line 312
  image_w = (unsigned short )width;
#line 313
  image_h = (unsigned short )height;
#line 316
  __cil_tmp21 = fwrite((void const   *)(& image_w), 2UL, 1UL, fp);
  }
#line 316
  if (__cil_tmp21 != 1UL) {
#line 316
    goto fails;
  }
  {
#line 317
  __cil_tmp22 = fwrite((void const   *)(& image_h), 2UL, 1UL, fp);
  }
#line 317
  if (__cil_tmp22 != 1UL) {
#line 317
    goto fails;
  }
  {
#line 325
  __cil_tmp23 = fwrite((void const   *)(& pixel_depth), 1UL, 1UL, fp);
  }
#line 325
  if (__cil_tmp23 != 1UL) {
#line 325
    goto fails;
  }
#line 327
  image_desc = (unsigned char)8;
#line 329
  if (flip_image) {
#line 330
    image_desc = (unsigned char )((int )image_desc | 32);
  }
  {
#line 331
  __cil_tmp24 = fwrite((void const   *)(& image_desc), 1UL, 1UL, fp);
  }
#line 331
  if (__cil_tmp24 != 1UL) {
#line 331
    goto fails;
  }
#line 333
  return (1);
  fails: 
  {
#line 336
  fputs("\nwrite_tgaheader: write ERROR\n", stderr);
  }
#line 337
  return (0);
}
}
#line 340 "/root/patchweave_new/10/src/bin/jp2/convert.c"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  opj_image_t *image ;
  unsigned int image_width ;
  unsigned int image_height ;
  unsigned int pixel_bit_depth ;
  unsigned int x ;
  unsigned int y ;
  int flip_image ;
  opj_image_cmptparm_t cmptparm[4] ;
  int numcomps ;
  OPJ_COLOR_SPACE color_space ;
  OPJ_BOOL mono ;
  OPJ_BOOL save_alpha ;
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  int __cil_tmp20 ;
  int tmp ;
  int tmp___0 ;
  OPJ_UINT32 tmp___1 ;
  OPJ_UINT32 tmp___2 ;
  int index___25 ;
  unsigned char r ;
  unsigned char g ;
  unsigned char b ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned char r___0 ;
  unsigned char g___0 ;
  unsigned char b___0 ;
  unsigned char a ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 345
  flip_image = 0;
#line 354
  f = fopen(filename, "rb");
  }
#line 355
  if (! f) {
    {
#line 356
    fprintf(stderr, "Failed to open %s for reading !!\n", filename);
    }
#line 357
    return ((opj_image_t *)0);
  }
  {
#line 360
  __cil_tmp20 = tga_readheader(f, & pixel_bit_depth, & image_width, & image_height,
                               & flip_image);
  }
#line 360
  if (! __cil_tmp20) {
#line 361
    return ((opj_image_t *)((void *)0));
  }
#line 364
  if (! (pixel_bit_depth == 24U)) {
#line 364
    if (! (pixel_bit_depth == 32U)) {
#line 365
      return ((opj_image_t *)((void *)0));
    }
  }
  {
#line 368
  memset((void *)(& cmptparm[0]), 0, 4UL * sizeof(opj_image_cmptparm_t ));
  }
#line 370
  if (pixel_bit_depth == 8U) {
#line 370
    tmp___3 = 1;
  } else
#line 370
  if (pixel_bit_depth == 16U) {
#line 370
    tmp___3 = 1;
  } else {
#line 370
    tmp___3 = 0;
  }
#line 370
  mono = tmp___3;
#line 371
  if (pixel_bit_depth == 16U) {
#line 371
    tmp___4 = 1;
  } else
#line 371
  if (pixel_bit_depth == 32U) {
#line 371
    tmp___4 = 1;
  } else {
#line 371
    tmp___4 = 0;
  }
#line 371
  save_alpha = tmp___4;
#line 373
  if (mono) {
#line 374
    color_space = (OPJ_COLOR_SPACE )2;
#line 375
    if (save_alpha) {
#line 375
      tmp = 2;
    } else {
#line 375
      tmp = 1;
    }
#line 375
    numcomps = tmp;
  } else {
#line 378
    if (save_alpha) {
#line 378
      tmp___0 = 4;
    } else {
#line 378
      tmp___0 = 3;
    }
#line 378
    numcomps = tmp___0;
#line 379
    color_space = (OPJ_COLOR_SPACE )1;
  }
#line 382
  subsampling_dx = parameters->subsampling_dx;
#line 383
  subsampling_dy = parameters->subsampling_dy;
#line 385
  i = 0;
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;

#line 385
    if (! (i < numcomps)) {
#line 385
      goto while_break;
    }
#line 386
    cmptparm[i].prec = (OPJ_UINT32 )8;
#line 387
    cmptparm[i].bpp = (OPJ_UINT32 )8;
#line 388
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 389
    cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 390
    cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 391
    cmptparm[i].w = image_width;
#line 392
    cmptparm[i].h = image_height;
#line 385
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 396
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
  }
#line 398
  if (! image) {
#line 399
    return ((opj_image_t *)((void *)0));
  }
#line 402
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 403
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 404
  if (! image->x0) {
#line 404
    tmp___1 = (image_width - 1U) * (OPJ_UINT32 )subsampling_dx + 1U;
  } else {
#line 404
    tmp___1 = (image->x0 + (image_width - 1U) * (OPJ_UINT32 )subsampling_dx) + 1U;
  }
#line 404
  image->x1 = tmp___1;
#line 405
  if (! image->y0) {
#line 405
    tmp___2 = (image_height - 1U) * (OPJ_UINT32 )subsampling_dy + 1U;
  } else {
#line 405
    tmp___2 = (image->y0 + (image_height - 1U) * (OPJ_UINT32 )subsampling_dy) + 1U;
  }
#line 405
  image->y1 = tmp___2;
#line 408
  y = 0U;
  {
#line 408
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 408
    if (! (y < image_height)) {
#line 408
      goto while_break___0;
    }
#line 412
    if (flip_image) {
#line 413
      index___25 = (int )(((image_height - y) - 1U) * image_width);
    } else {
#line 415
      index___25 = (int )(y * image_width);
    }
#line 417
    if (numcomps == 3) {
#line 419
      x = 0U;
      {
#line 419
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 419
        if (! (x < image_width)) {
#line 419
          goto while_break___1;
        }
        {
#line 423
        __cil_tmp31 = fread((void *)(& b), 1UL, 1UL, f);
        }
#line 423
        if (! __cil_tmp31) {
          {
#line 425
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 426
          opj_image_destroy(image);
          }
#line 427
          return ((opj_image_t *)((void *)0));
        }
        {
#line 429
        __cil_tmp32 = fread((void *)(& g), 1UL, 1UL, f);
        }
#line 429
        if (! __cil_tmp32) {
          {
#line 431
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 432
          opj_image_destroy(image);
          }
#line 433
          return ((opj_image_t *)((void *)0));
        }
        {
#line 435
        __cil_tmp33 = fread((void *)(& r), 1UL, 1UL, f);
        }
#line 435
        if (! __cil_tmp33) {
          {
#line 437
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 438
          opj_image_destroy(image);
          }
#line 439
          return ((opj_image_t *)((void *)0));
        }
#line 442
        *((image->comps + 0)->data + index___25) = (OPJ_INT32 )r;
#line 443
        *((image->comps + 1)->data + index___25) = (OPJ_INT32 )g;
#line 444
        *((image->comps + 2)->data + index___25) = (OPJ_INT32 )b;
#line 445
        index___25 ++;
#line 419
        x ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: ;
    } else
#line 448
    if (numcomps == 4) {
#line 450
      x = 0U;
      {
#line 450
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 450
        if (! (x < image_width)) {
#line 450
          goto while_break___2;
        }
        {
#line 453
        __cil_tmp40 = fread((void *)(& b___0), 1UL, 1UL, f);
        }
#line 453
        if (! __cil_tmp40) {
          {
#line 455
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 456
          opj_image_destroy(image);
          }
#line 457
          return ((opj_image_t *)((void *)0));
        }
        {
#line 459
        __cil_tmp41 = fread((void *)(& g___0), 1UL, 1UL, f);
        }
#line 459
        if (! __cil_tmp41) {
          {
#line 461
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 462
          opj_image_destroy(image);
          }
#line 463
          return ((opj_image_t *)((void *)0));
        }
        {
#line 465
        __cil_tmp42 = fread((void *)(& r___0), 1UL, 1UL, f);
        }
#line 465
        if (! __cil_tmp42) {
          {
#line 467
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 468
          opj_image_destroy(image);
          }
#line 469
          return ((opj_image_t *)((void *)0));
        }
        {
#line 471
        __cil_tmp43 = fread((void *)(& a), 1UL, 1UL, f);
        }
#line 471
        if (! __cil_tmp43) {
          {
#line 473
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 474
          opj_image_destroy(image);
          }
#line 475
          return ((opj_image_t *)((void *)0));
        }
#line 478
        *((image->comps + 0)->data + index___25) = (OPJ_INT32 )r___0;
#line 479
        *((image->comps + 1)->data + index___25) = (OPJ_INT32 )g___0;
#line 480
        *((image->comps + 2)->data + index___25) = (OPJ_INT32 )b___0;
#line 481
        *((image->comps + 3)->data + index___25) = (OPJ_INT32 )a;
#line 482
        index___25 ++;
#line 450
        x ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: ;
    } else {
      {
#line 486
      fprintf(stderr, "Currently unsupported bit depth : %s\n", filename);
      }
    }
#line 408
    y ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: ;
#line 489
  return (image);
}
}
#line 492 "/root/patchweave_new/10/src/bin/jp2/convert.c"
int imagetotga(opj_image_t *image , char const   *outfile ) 
{ 
  int width ;
  int height ;
  int bpp ;
  int x ;
  int y ;
  OPJ_BOOL write_alpha ;
  unsigned int i ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int fails ;
  unsigned int alpha_channel ;
  float r ;
  float g ;
  float b ;
  float a ;
  unsigned char value ;
  float scale ;
  FILE *fdest ;
  size_t res ;
  int tmp ;
  int __cil_tmp26 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int index___26 ;
  int __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  int tmp___3 ;

  {
  {
#line 503
  fails = 1;
#line 505
  fdest = fopen(outfile, "wb");
  }
#line 506
  if (! fdest) {
    {
#line 507
    fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
    }
#line 508
    return (1);
  }
#line 511
  i = 0U;
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;

#line 511
    if (! (i < image->numcomps - 1U)) {
#line 511
      goto while_break;
    }
#line 512
    if ((image->comps + 0)->dx != (image->comps + (i + 1U))->dx) {
      {
#line 515
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
#line 516
      return (1);
    } else
#line 512
    if ((image->comps + 0)->dy != (image->comps + (i + 1U))->dy) {
      {
#line 515
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
#line 516
      return (1);
    } else
#line 512
    if ((image->comps + 0)->prec != (image->comps + (i + 1U))->prec) {
      {
#line 515
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
#line 516
      return (1);
    }
#line 511
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 520
  width = (int )(image->comps + 0)->w;
#line 521
  height = (int )(image->comps + 0)->h;
#line 524
  if (image->numcomps == 2U) {
#line 524
    tmp___3 = 1;
  } else
#line 524
  if (image->numcomps == 4U) {
#line 524
    tmp___3 = 1;
  } else {
#line 524
    tmp___3 = 0;
  }
#line 524
  write_alpha = tmp___3;
#line 527
  if (write_alpha) {
#line 527
    tmp = 32;
  } else {
#line 527
    tmp = 24;
  }
  {
#line 527
  bpp = tmp;
#line 529
  __cil_tmp26 = tga_writeheader(fdest, bpp, width, height, 1);
  }
#line 529
  if (! __cil_tmp26) {
#line 530
    goto fin;
  }
#line 532
  alpha_channel = image->numcomps - 1U;
#line 534
  scale = 255.f / (float )((1 << (image->comps + 0)->prec) - 1);
#line 536
  if ((image->comps + 0)->sgnd) {
#line 536
    tmp___0 = 1 << ((image->comps + 0)->prec - 1U);
  } else {
#line 536
    tmp___0 = 0;
  }
#line 536
  adjustR = tmp___0;
#line 537
  if ((image->comps + 1)->sgnd) {
#line 537
    tmp___1 = 1 << ((image->comps + 1)->prec - 1U);
  } else {
#line 537
    tmp___1 = 0;
  }
#line 537
  adjustG = tmp___1;
#line 538
  if ((image->comps + 2)->sgnd) {
#line 538
    tmp___2 = 1 << ((image->comps + 2)->prec - 1U);
  } else {
#line 538
    tmp___2 = 0;
  }
#line 538
  adjustB = tmp___2;
#line 540
  y = 0;
  {
#line 540
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 540
    if (! (y < height)) {
#line 540
      goto while_break___0;
    }
#line 542
    index___26 = (unsigned int )(y * width);
#line 544
    x = 0;
    {
#line 544
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 544
      if (! (x < width)) {
#line 544
        goto while_break___1;
      }
#line 546
      r = (float )(*((image->comps + 0)->data + index___26) + adjustR);
#line 548
      if (image->numcomps > 2U) {
#line 550
        g = (float )(*((image->comps + 1)->data + index___26) + adjustG);
#line 551
        b = (float )(*((image->comps + 2)->data + index___26) + adjustB);
      } else {
#line 555
        g = r;
#line 556
        b = r;
      }
#line 560
      if ((double )b > 255.) {
#line 560
        b = (float )255.;
      } else
#line 560
      if ((double )b < 0.) {
#line 560
        b = (float )0.;
      }
      {
#line 561
      value = (unsigned char )(b * scale);
#line 562
      res = fwrite((void const   *)(& value), 1UL, 1UL, fdest);
      }
#line 564
      if (res < 1UL) {
        {
#line 566
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 567
        goto fin;
      }
#line 569
      if ((double )g > 255.) {
#line 569
        g = (float )255.;
      } else
#line 569
      if ((double )g < 0.) {
#line 569
        g = (float )0.;
      }
      {
#line 570
      value = (unsigned char )(g * scale);
#line 571
      res = fwrite((void const   *)(& value), 1UL, 1UL, fdest);
      }
#line 573
      if (res < 1UL) {
        {
#line 575
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 576
        goto fin;
      }
#line 578
      if ((double )r > 255.) {
#line 578
        r = (float )255.;
      } else
#line 578
      if ((double )r < 0.) {
#line 578
        r = (float )0.;
      }
      {
#line 579
      value = (unsigned char )(r * scale);
#line 580
      res = fwrite((void const   *)(& value), 1UL, 1UL, fdest);
      }
#line 582
      if (res < 1UL) {
        {
#line 584
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 585
        goto fin;
      }
#line 588
      if (write_alpha) {
#line 590
        a = (float )*((image->comps + alpha_channel)->data + index___26);
#line 591
        if ((double )a > 255.) {
#line 591
          a = (float )255.;
        } else
#line 591
        if ((double )a < 0.) {
#line 591
          a = (float )0.;
        }
        {
#line 592
        value = (unsigned char )(a * scale);
#line 593
        res = fwrite((void const   *)(& value), 1UL, 1UL, fdest);
        }
#line 595
        if (res < 1UL) {
          {
#line 597
          fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
          }
#line 598
          goto fin;
        }
      }
#line 544
      __cil_tmp36 = index___26;
#line 544
      index___26 ++;
#line 544
      __cil_tmp35 = x;
#line 544
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 540
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 603
  fails = 0;
  fin: 
  {
#line 605
  fclose(fdest);
  }
#line 607
  return (fails);
}
}
#line 644 "/root/patchweave_new/10/src/bin/jp2/convert.c"
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[3] ;
  opj_image_t *image ;
  FILE *IN ;
  BITMAPFILEHEADER_t File_h ;
  BITMAPINFOHEADER_t Info_h ;
  unsigned char *RGB ;
  unsigned char *table_R ;
  unsigned char *table_G ;
  unsigned char *table_B ;
  unsigned int j ;
  unsigned int PAD ;
  unsigned int x ;
  unsigned int y ;
  int index___27 ;
  int gray_scale ;
  int has_color ;
  DWORD W ;
  DWORD H ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 tmp___0 ;
  unsigned int tmp___1 ;
  void *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned char *scanline ;
  unsigned char *pixel ;
  void *__cil_tmp95 ;
  void *__cil_tmp96 ;
  void *__cil_tmp97 ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  int tmp___2 ;
  int tmp___3 ;
  OPJ_UINT32 tmp___4 ;
  OPJ_UINT32 tmp___5 ;
  void *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned char pixel_index ;
  unsigned char *pix ;
  unsigned char *beyond ;
  int *gray ;
  int *red ;
  int *green ;
  int *blue ;
  unsigned int max ;
  int c ;
  int c1 ;
  unsigned char uc ;
  void *__cil_tmp126 ;
  void *__cil_tmp127 ;
  void *__cil_tmp128 ;
  int __cil_tmp129 ;
  int __cil_tmp130 ;
  int __cil_tmp131 ;
  int tmp___6 ;
  int tmp___7 ;
  OPJ_UINT32 tmp___8 ;
  OPJ_UINT32 tmp___9 ;
  void *__cil_tmp139 ;
  int __cil_tmp142 ;
  unsigned int __cil_tmp143 ;
  unsigned char *__cil_tmp144 ;
  int __cil_tmp149 ;
  unsigned int __cil_tmp150 ;
  unsigned char *__cil_tmp151 ;
  unsigned int __cil_tmp152 ;
  unsigned char *__cil_tmp153 ;
  int *__cil_tmp154 ;
  unsigned int __cil_tmp155 ;
  unsigned char *__cil_tmp156 ;
  int *__cil_tmp157 ;
  int *__cil_tmp158 ;
  int *__cil_tmp159 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 646
  subsampling_dx = parameters->subsampling_dx;
#line 647
  subsampling_dy = parameters->subsampling_dy;
#line 652
  image = (opj_image_t *)((void *)0);
#line 659
  PAD = 0U;
#line 663
  gray_scale = 1;
#line 667
  IN = fopen(filename, "rbHlEV");
  }
#line 668
  if (! IN) {
    {
#line 670
    fprintf(stderr, "Failed to open %s for reading !!\n", filename);
    }
#line 671
    return ((opj_image_t *)((void *)0));
  }
  {
#line 674
  __cil_tmp29 = getc(IN);
#line 674
  File_h.bfType = (WORD )__cil_tmp29;
#line 675
  __cil_tmp30 = getc(IN);
#line 675
  File_h.bfType = (WORD )((__cil_tmp30 << 8) + (int )File_h.bfType);
  }
#line 677
  if ((int )File_h.bfType != 19778) {
    {
#line 679
    fprintf(stderr, "Error, not a BMP file!\n");
#line 680
    fclose(IN);
    }
#line 681
    return ((opj_image_t *)((void *)0));
  }
  {
#line 685
  __cil_tmp31 = getc(IN);
#line 685
  File_h.bfSize = (DWORD )__cil_tmp31;
#line 686
  __cil_tmp32 = getc(IN);
#line 686
  File_h.bfSize = (DWORD )(__cil_tmp32 << 8) + File_h.bfSize;
#line 687
  __cil_tmp33 = getc(IN);
#line 687
  File_h.bfSize = (DWORD )(__cil_tmp33 << 16) + File_h.bfSize;
#line 688
  __cil_tmp34 = getc(IN);
#line 688
  File_h.bfSize = (DWORD )(__cil_tmp34 << 24) + File_h.bfSize;
#line 690
  __cil_tmp35 = getc(IN);
#line 690
  File_h.bfReserved1 = (WORD )__cil_tmp35;
#line 691
  __cil_tmp36 = getc(IN);
#line 691
  File_h.bfReserved1 = (WORD )((__cil_tmp36 << 8) + (int )File_h.bfReserved1);
#line 693
  __cil_tmp37 = getc(IN);
#line 693
  File_h.bfReserved2 = (WORD )__cil_tmp37;
#line 694
  __cil_tmp38 = getc(IN);
#line 694
  File_h.bfReserved2 = (WORD )((__cil_tmp38 << 8) + (int )File_h.bfReserved2);
#line 696
  __cil_tmp39 = getc(IN);
#line 696
  File_h.bfOffBits = (DWORD )__cil_tmp39;
#line 697
  __cil_tmp40 = getc(IN);
#line 697
  File_h.bfOffBits = (DWORD )(__cil_tmp40 << 8) + File_h.bfOffBits;
#line 698
  __cil_tmp41 = getc(IN);
#line 698
  File_h.bfOffBits = (DWORD )(__cil_tmp41 << 16) + File_h.bfOffBits;
#line 699
  __cil_tmp42 = getc(IN);
#line 699
  File_h.bfOffBits = (DWORD )(__cil_tmp42 << 24) + File_h.bfOffBits;
#line 704
  __cil_tmp43 = getc(IN);
#line 704
  Info_h.biSize = (DWORD )__cil_tmp43;
#line 705
  __cil_tmp44 = getc(IN);
#line 705
  Info_h.biSize = (DWORD )(__cil_tmp44 << 8) + Info_h.biSize;
#line 706
  __cil_tmp45 = getc(IN);
#line 706
  Info_h.biSize = (DWORD )(__cil_tmp45 << 16) + Info_h.biSize;
#line 707
  __cil_tmp46 = getc(IN);
#line 707
  Info_h.biSize = (DWORD )(__cil_tmp46 << 24) + Info_h.biSize;
  }
#line 709
  if (Info_h.biSize != 40U) {
    {
#line 711
    fprintf(stderr, "Error, unknown BMP header size %d\n", Info_h.biSize);
#line 712
    fclose(IN);
    }
#line 713
    return ((opj_image_t *)((void *)0));
  }
  {
#line 715
  __cil_tmp47 = getc(IN);
#line 715
  Info_h.biWidth = (DWORD )__cil_tmp47;
#line 716
  __cil_tmp48 = getc(IN);
#line 716
  Info_h.biWidth = (DWORD )(__cil_tmp48 << 8) + Info_h.biWidth;
#line 717
  __cil_tmp49 = getc(IN);
#line 717
  Info_h.biWidth = (DWORD )(__cil_tmp49 << 16) + Info_h.biWidth;
#line 718
  __cil_tmp50 = getc(IN);
#line 718
  Info_h.biWidth = (DWORD )(__cil_tmp50 << 24) + Info_h.biWidth;
#line 719
  w = (int )Info_h.biWidth;
#line 721
  __cil_tmp51 = getc(IN);
#line 721
  Info_h.biHeight = (DWORD )__cil_tmp51;
#line 722
  __cil_tmp52 = getc(IN);
#line 722
  Info_h.biHeight = (DWORD )(__cil_tmp52 << 8) + Info_h.biHeight;
#line 723
  __cil_tmp53 = getc(IN);
#line 723
  Info_h.biHeight = (DWORD )(__cil_tmp53 << 16) + Info_h.biHeight;
#line 724
  __cil_tmp54 = getc(IN);
#line 724
  Info_h.biHeight = (DWORD )(__cil_tmp54 << 24) + Info_h.biHeight;
#line 725
  h = (int )Info_h.biHeight;
#line 727
  __cil_tmp55 = getc(IN);
#line 727
  Info_h.biPlanes = (WORD )__cil_tmp55;
#line 728
  __cil_tmp56 = getc(IN);
#line 728
  Info_h.biPlanes = (WORD )((__cil_tmp56 << 8) + (int )Info_h.biPlanes);
#line 730
  __cil_tmp57 = getc(IN);
#line 730
  Info_h.biBitCount = (WORD )__cil_tmp57;
#line 731
  __cil_tmp58 = getc(IN);
#line 731
  Info_h.biBitCount = (WORD )((__cil_tmp58 << 8) + (int )Info_h.biBitCount);
#line 733
  __cil_tmp59 = getc(IN);
#line 733
  Info_h.biCompression = (DWORD )__cil_tmp59;
#line 734
  __cil_tmp60 = getc(IN);
#line 734
  Info_h.biCompression = (DWORD )(__cil_tmp60 << 8) + Info_h.biCompression;
#line 735
  __cil_tmp61 = getc(IN);
#line 735
  Info_h.biCompression = (DWORD )(__cil_tmp61 << 16) + Info_h.biCompression;
#line 736
  __cil_tmp62 = getc(IN);
#line 736
  Info_h.biCompression = (DWORD )(__cil_tmp62 << 24) + Info_h.biCompression;
#line 738
  __cil_tmp63 = getc(IN);
#line 738
  Info_h.biSizeImage = (DWORD )__cil_tmp63;
#line 739
  __cil_tmp64 = getc(IN);
#line 739
  Info_h.biSizeImage = (DWORD )(__cil_tmp64 << 8) + Info_h.biSizeImage;
#line 740
  __cil_tmp65 = getc(IN);
#line 740
  Info_h.biSizeImage = (DWORD )(__cil_tmp65 << 16) + Info_h.biSizeImage;
#line 741
  __cil_tmp66 = getc(IN);
#line 741
  Info_h.biSizeImage = (DWORD )(__cil_tmp66 << 24) + Info_h.biSizeImage;
#line 743
  __cil_tmp67 = getc(IN);
#line 743
  Info_h.biXpelsPerMeter = (DWORD )__cil_tmp67;
#line 744
  __cil_tmp68 = getc(IN);
#line 744
  Info_h.biXpelsPerMeter = (DWORD )(__cil_tmp68 << 8) + Info_h.biXpelsPerMeter;
#line 745
  __cil_tmp69 = getc(IN);
#line 745
  Info_h.biXpelsPerMeter = (DWORD )(__cil_tmp69 << 16) + Info_h.biXpelsPerMeter;
#line 746
  __cil_tmp70 = getc(IN);
#line 746
  Info_h.biXpelsPerMeter = (DWORD )(__cil_tmp70 << 24) + Info_h.biXpelsPerMeter;
#line 748
  __cil_tmp71 = getc(IN);
#line 748
  Info_h.biYpelsPerMeter = (DWORD )__cil_tmp71;
#line 749
  __cil_tmp72 = getc(IN);
#line 749
  Info_h.biYpelsPerMeter = (DWORD )(__cil_tmp72 << 8) + Info_h.biYpelsPerMeter;
#line 750
  __cil_tmp73 = getc(IN);
#line 750
  Info_h.biYpelsPerMeter = (DWORD )(__cil_tmp73 << 16) + Info_h.biYpelsPerMeter;
#line 751
  __cil_tmp74 = getc(IN);
#line 751
  Info_h.biYpelsPerMeter = (DWORD )(__cil_tmp74 << 24) + Info_h.biYpelsPerMeter;
#line 753
  __cil_tmp75 = getc(IN);
#line 753
  Info_h.biClrUsed = (DWORD )__cil_tmp75;
#line 754
  __cil_tmp76 = getc(IN);
#line 754
  Info_h.biClrUsed = (DWORD )(__cil_tmp76 << 8) + Info_h.biClrUsed;
#line 755
  __cil_tmp77 = getc(IN);
#line 755
  Info_h.biClrUsed = (DWORD )(__cil_tmp77 << 16) + Info_h.biClrUsed;
#line 756
  __cil_tmp78 = getc(IN);
#line 756
  Info_h.biClrUsed = (DWORD )(__cil_tmp78 << 24) + Info_h.biClrUsed;
#line 758
  __cil_tmp79 = getc(IN);
#line 758
  Info_h.biClrImportant = (DWORD )__cil_tmp79;
#line 759
  __cil_tmp80 = getc(IN);
#line 759
  Info_h.biClrImportant = (DWORD )(__cil_tmp80 << 8) + Info_h.biClrImportant;
#line 760
  __cil_tmp81 = getc(IN);
#line 760
  Info_h.biClrImportant = (DWORD )(__cil_tmp81 << 16) + Info_h.biClrImportant;
#line 761
  __cil_tmp82 = getc(IN);
#line 761
  Info_h.biClrImportant = (DWORD )(__cil_tmp82 << 24) + Info_h.biClrImportant;
  }
#line 765
  if ((int )Info_h.biBitCount == 24) {
    {
#line 767
    numcomps = 3;
#line 768
    color_space = (OPJ_COLOR_SPACE )1;
#line 770
    memset((void *)(& cmptparm[0]), 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 771
    i = 0;
    }
    {
#line 771
    while (1) {
      while_continue: /* CIL Label */ ;

#line 771
      if (! (i < numcomps)) {
#line 771
        goto while_break;
      }
#line 773
      cmptparm[i].prec = (OPJ_UINT32 )8;
#line 774
      cmptparm[i].bpp = (OPJ_UINT32 )8;
#line 775
      cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 776
      cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 777
      cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 778
      cmptparm[i].w = (OPJ_UINT32 )w;
#line 779
      cmptparm[i].h = (OPJ_UINT32 )h;
#line 771
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break: 
    {
#line 782
    image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
    }
#line 783
    if (! image) {
      {
#line 785
      fclose(IN);
      }
#line 786
      return ((opj_image_t *)((void *)0));
    }
#line 790
    image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 791
    image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 792
    if (! image->x0) {
#line 792
      tmp = (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx + 1U;
    } else {
#line 792
      tmp = (image->x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
    }
#line 792
    image->x1 = tmp;
#line 793
    if (! image->y0) {
#line 793
      tmp___0 = (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy + 1U;
    } else {
#line 793
      tmp___0 = (image->y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
    }
    {
#line 793
    image->y1 = tmp___0;
#line 798
    fseek(IN, 0L, 0);
#line 799
    fseek(IN, (long )File_h.bfOffBits, 0);
#line 801
    W = Info_h.biWidth;
#line 802
    H = Info_h.biHeight;
    }
#line 806
    if ((3U * W) % 4U) {
#line 806
      tmp___1 = 4U - (3U * W) % 4U;
    } else {
#line 806
      tmp___1 = 0U;
    }
    {
#line 806
    PAD = tmp___1;
#line 808
    __cil_tmp88 = malloc((unsigned long )((3U * W + PAD) * H) * sizeof(unsigned char ));
#line 808
    RGB = (unsigned char *)__cil_tmp88;
#line 811
    __cil_tmp89 = fread((void *)RGB, sizeof(unsigned char ), (unsigned long )((3U * W + PAD) * H),
                        IN);
    }
#line 811
    if (__cil_tmp89 != (unsigned long )((3U * W + PAD) * H)) {
      {
#line 813
      free((void *)RGB);
#line 814
      opj_image_destroy(image);
#line 815
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
      }
#line 816
      return ((opj_image_t *)((void *)0));
    }
#line 819
    index___27 = 0;
#line 821
    y = 0U;
    {
#line 821
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 821
      if (! (y < H)) {
#line 821
        goto while_break___0;
      }
#line 823
      scanline = RGB + (3U * W + PAD) * ((H - 1U) - y);
#line 824
      x = 0U;
      {
#line 824
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 824
        if (! (x < W)) {
#line 824
          goto while_break___1;
        }
#line 826
        pixel = scanline + 3U * x;
#line 827
        *((image->comps + 0)->data + index___27) = (OPJ_INT32 )*(pixel + 2);
#line 828
        *((image->comps + 1)->data + index___27) = (OPJ_INT32 )*(pixel + 1);
#line 829
        *((image->comps + 2)->data + index___27) = (OPJ_INT32 )*(pixel + 0);
#line 830
        index___27 ++;
#line 824
        x ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___1: 
#line 821
      y ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 833
    free((void *)RGB);
    }
  } else
#line 836
  if ((int )Info_h.biBitCount == 8) {
#line 836
    if (Info_h.biCompression == 0U) {
#line 838
      if (Info_h.biClrUsed == 0U) {
#line 838
        Info_h.biClrUsed = (DWORD )256;
      } else
#line 840
      if (Info_h.biClrUsed > 256U) {
#line 840
        Info_h.biClrUsed = (DWORD )256;
      }
      {
#line 842
      __cil_tmp95 = malloc(256UL * sizeof(unsigned char ));
#line 842
      table_R = (unsigned char *)__cil_tmp95;
#line 843
      __cil_tmp96 = malloc(256UL * sizeof(unsigned char ));
#line 843
      table_G = (unsigned char *)__cil_tmp96;
#line 844
      __cil_tmp97 = malloc(256UL * sizeof(unsigned char ));
#line 844
      table_B = (unsigned char *)__cil_tmp97;
#line 846
      has_color = 0;
#line 847
      j = 0U;
      }
      {
#line 847
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 847
        if (! (j < Info_h.biClrUsed)) {
#line 847
          goto while_break___2;
        }
        {
#line 849
        __cil_tmp98 = getc(IN);
#line 849
        *(table_B + j) = (unsigned char )__cil_tmp98;
#line 850
        __cil_tmp99 = getc(IN);
#line 850
        *(table_G + j) = (unsigned char )__cil_tmp99;
#line 851
        __cil_tmp100 = getc(IN);
#line 851
        *(table_R + j) = (unsigned char )__cil_tmp100;
#line 852
        getc(IN);
        }
#line 853
        if ((int )*(table_R + j) == (int )*(table_G + j)) {
#line 853
          if ((int )*(table_R + j) == (int )*(table_B + j)) {
#line 853
            tmp___10 = 0;
          } else {
#line 853
            tmp___10 = 1;
          }
        } else {
#line 853
          tmp___10 = 1;
        }
#line 853
        has_color += tmp___10;
#line 847
        j ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___2: ;
#line 856
      if (has_color) {
#line 856
        gray_scale = 0;
      }
      {
#line 859
      fseek(IN, 0L, 0);
#line 860
      fseek(IN, (long )File_h.bfOffBits, 0);
#line 862
      W = Info_h.biWidth;
#line 863
      H = Info_h.biHeight;
      }
#line 864
      if (Info_h.biWidth % 2U) {
#line 865
        W ++;
      }
#line 867
      if (gray_scale) {
#line 867
        tmp___2 = 1;
      } else {
#line 867
        tmp___2 = 3;
      }
#line 867
      numcomps = tmp___2;
#line 868
      if (gray_scale) {
#line 868
        tmp___3 = 2;
      } else {
#line 868
        tmp___3 = 1;
      }
      {
#line 868
      color_space = (OPJ_COLOR_SPACE )tmp___3;
#line 870
      memset((void *)(& cmptparm[0]), 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 871
      i = 0;
      }
      {
#line 871
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 871
        if (! (i < numcomps)) {
#line 871
          goto while_break___3;
        }
#line 873
        cmptparm[i].prec = (OPJ_UINT32 )8;
#line 874
        cmptparm[i].bpp = (OPJ_UINT32 )8;
#line 875
        cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 876
        cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 877
        cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 878
        cmptparm[i].w = (OPJ_UINT32 )w;
#line 879
        cmptparm[i].h = (OPJ_UINT32 )h;
#line 871
        i ++;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___3: 
      {
#line 882
      image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
      }
#line 883
      if (! image) {
        {
#line 885
        fclose(IN);
#line 886
        free((void *)table_R);
#line 886
        free((void *)table_G);
#line 886
        free((void *)table_B);
        }
#line 887
        return ((opj_image_t *)((void *)0));
      }
#line 891
      image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 892
      image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 893
      if (! image->x0) {
#line 893
        tmp___4 = (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx + 1U;
      } else {
#line 893
        tmp___4 = (image->x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
      }
#line 893
      image->x1 = tmp___4;
#line 894
      if (! image->y0) {
#line 894
        tmp___5 = (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy + 1U;
      } else {
#line 894
        tmp___5 = (image->y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
      }
      {
#line 894
      image->y1 = tmp___5;
#line 898
      __cil_tmp109 = malloc((unsigned long )(W * H) * sizeof(unsigned char ));
#line 898
      RGB = (unsigned char *)__cil_tmp109;
#line 900
      __cil_tmp110 = fread((void *)RGB, sizeof(unsigned char ), (unsigned long )(W * H),
                           IN);
      }
#line 900
      if (__cil_tmp110 != (unsigned long )(W * H)) {
        {
#line 902
        free((void *)table_R);
#line 903
        free((void *)table_G);
#line 904
        free((void *)table_B);
#line 905
        free((void *)RGB);
#line 906
        opj_image_destroy(image);
#line 907
        fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
        }
#line 908
        return ((opj_image_t *)((void *)0));
      }
#line 910
      if (gray_scale) {
#line 912
        index___27 = 0;
#line 913
        j = 0U;
        {
#line 913
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 913
          if (! (j < W * H)) {
#line 913
            goto while_break___4;
          }
#line 915
          if (j % W < W - 1U) {
#line 915
            if (Info_h.biWidth % 2U) {
#line 917
              *((image->comps + 0)->data + index___27) = (OPJ_INT32 )*(table_R + (int )*(RGB + ((W * H - (j / W + 1U) * W) + j % W)));
#line 919
              index___27 ++;
            } else {
#line 915
              goto _L;
            }
          } else
          _L: 
#line 915
          if (! (Info_h.biWidth % 2U)) {
#line 917
            *((image->comps + 0)->data + index___27) = (OPJ_INT32 )*(table_R + (int )*(RGB + ((W * H - (j / W + 1U) * W) + j % W)));
#line 919
            index___27 ++;
          }
#line 913
          j ++;
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___4: ;
      } else {
#line 926
        index___27 = 0;
#line 927
        j = 0U;
        {
#line 927
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 927
          if (! (j < W * H)) {
#line 927
            goto while_break___5;
          }
#line 929
          if (j % W < W - 1U) {
#line 929
            if (Info_h.biWidth % 2U) {
#line 932
              pixel_index = *(RGB + ((W * H - (j / W + 1U) * W) + j % W));
#line 934
              *((image->comps + 0)->data + index___27) = (OPJ_INT32 )*(table_R + (int )pixel_index);
#line 935
              *((image->comps + 1)->data + index___27) = (OPJ_INT32 )*(table_G + (int )pixel_index);
#line 936
              *((image->comps + 2)->data + index___27) = (OPJ_INT32 )*(table_B + (int )pixel_index);
#line 937
              index___27 ++;
            } else {
#line 929
              goto _L___28;
            }
          } else
          _L___28: 
#line 929
          if (! (Info_h.biWidth % 2U)) {
#line 932
            pixel_index = *(RGB + ((W * H - (j / W + 1U) * W) + j % W));
#line 934
            *((image->comps + 0)->data + index___27) = (OPJ_INT32 )*(table_R + (int )pixel_index);
#line 935
            *((image->comps + 1)->data + index___27) = (OPJ_INT32 )*(table_G + (int )pixel_index);
#line 936
            *((image->comps + 2)->data + index___27) = (OPJ_INT32 )*(table_B + (int )pixel_index);
#line 937
            index___27 ++;
          }
#line 927
          j ++;
        }
        while_break___19: /* CIL Label */ ;
        }
        while_break___5: ;
      }
      {
#line 941
      free((void *)RGB);
#line 942
      free((void *)table_R);
#line 943
      free((void *)table_G);
#line 944
      free((void *)table_B);
      }
    } else {
#line 836
      goto _L___29;
    }
  } else
  _L___29: 
#line 947
  if ((int )Info_h.biBitCount == 8) {
#line 947
    if (Info_h.biCompression == 1U) {
#line 955
      if (Info_h.biClrUsed == 0U) {
#line 956
        Info_h.biClrUsed = (DWORD )256;
      } else
#line 957
      if (Info_h.biClrUsed > 256U) {
#line 958
        Info_h.biClrUsed = (DWORD )256;
      }
      {
#line 960
      __cil_tmp126 = malloc(256UL * sizeof(unsigned char ));
#line 960
      table_R = (unsigned char *)__cil_tmp126;
#line 961
      __cil_tmp127 = malloc(256UL * sizeof(unsigned char ));
#line 961
      table_G = (unsigned char *)__cil_tmp127;
#line 962
      __cil_tmp128 = malloc(256UL * sizeof(unsigned char ));
#line 962
      table_B = (unsigned char *)__cil_tmp128;
#line 964
      has_color = 0;
#line 965
      j = 0U;
      }
      {
#line 965
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 965
        if (! (j < Info_h.biClrUsed)) {
#line 965
          goto while_break___6;
        }
        {
#line 967
        __cil_tmp129 = getc(IN);
#line 967
        *(table_B + j) = (unsigned char )__cil_tmp129;
#line 968
        __cil_tmp130 = getc(IN);
#line 968
        *(table_G + j) = (unsigned char )__cil_tmp130;
#line 969
        __cil_tmp131 = getc(IN);
#line 969
        *(table_R + j) = (unsigned char )__cil_tmp131;
#line 970
        getc(IN);
        }
#line 971
        if ((int )*(table_R + j) == (int )*(table_G + j)) {
#line 971
          if ((int )*(table_R + j) == (int )*(table_B + j)) {
#line 971
            tmp___11 = 0;
          } else {
#line 971
            tmp___11 = 1;
          }
        } else {
#line 971
          tmp___11 = 1;
        }
#line 971
        has_color += tmp___11;
#line 965
        j ++;
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___6: ;
#line 974
      if (has_color) {
#line 975
        gray_scale = 0;
      }
#line 977
      if (gray_scale) {
#line 977
        tmp___6 = 1;
      } else {
#line 977
        tmp___6 = 3;
      }
#line 977
      numcomps = tmp___6;
#line 978
      if (gray_scale) {
#line 978
        tmp___7 = 2;
      } else {
#line 978
        tmp___7 = 1;
      }
      {
#line 978
      color_space = (OPJ_COLOR_SPACE )tmp___7;
#line 980
      memset((void *)(& cmptparm[0]), 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 981
      i = 0;
      }
      {
#line 981
      while (1) {
        while_continue___7: /* CIL Label */ ;

#line 981
        if (! (i < numcomps)) {
#line 981
          goto while_break___7;
        }
#line 983
        cmptparm[i].prec = (OPJ_UINT32 )8;
#line 984
        cmptparm[i].bpp = (OPJ_UINT32 )8;
#line 985
        cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 986
        cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 987
        cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 988
        cmptparm[i].w = (OPJ_UINT32 )w;
#line 989
        cmptparm[i].h = (OPJ_UINT32 )h;
#line 981
        i ++;
      }
      while_break___21: /* CIL Label */ ;
      }
      while_break___7: 
      {
#line 992
      image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
      }
#line 993
      if (! image) {
        {
#line 995
        fclose(IN);
#line 996
        free((void *)table_R);
#line 997
        free((void *)table_G);
#line 998
        free((void *)table_B);
        }
#line 999
        return ((opj_image_t *)((void *)0));
      }
#line 1003
      image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 1004
      image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 1005
      if (! image->x0) {
#line 1005
        tmp___8 = (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx + 1U;
      } else {
#line 1005
        tmp___8 = (image->x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
      }
#line 1005
      image->x1 = tmp___8;
#line 1006
      if (! image->y0) {
#line 1006
        tmp___9 = (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy + 1U;
      } else {
#line 1006
        tmp___9 = (image->y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
      }
      {
#line 1006
      image->y1 = tmp___9;
#line 1011
      fseek(IN, 0L, 0);
#line 1012
      fseek(IN, (long )File_h.bfOffBits, 0);
#line 1014
      W = Info_h.biWidth;
#line 1015
      H = Info_h.biHeight;
#line 1016
      __cil_tmp139 = calloc(1UL, (unsigned long )(W * H) * sizeof(unsigned char ));
#line 1016
      RGB = (unsigned char *)__cil_tmp139;
#line 1017
      beyond = RGB + W * H;
#line 1018
      pix = beyond - W;
#line 1019
      y = 0U;
#line 1019
      x = y;
      }
      {
#line 1021
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 1021
        if (! (y < H)) {
#line 1021
          goto while_break___8;
        }
        {
#line 1023
        c = getc(IN);
        }
#line 1025
        if (c) {
          {
#line 1027
          c1 = getc(IN);
#line 1029
          i = 0;
          }
          {
#line 1029
          while (1) {
            while_continue___9: /* CIL Label */ ;

#line 1029
            if ((unsigned long )pix < (unsigned long )beyond) {
#line 1029
              if (i < c) {
#line 1029
                if (! (x < W)) {
#line 1029
                  goto while_break___9;
                }
              } else {
#line 1029
                goto while_break___9;
              }
            } else {
#line 1029
              goto while_break___9;
            }
#line 1030
            *pix = (unsigned char )c1;
#line 1029
            __cil_tmp144 = pix;
#line 1029
            pix ++;
#line 1029
            __cil_tmp143 = x;
#line 1029
            x ++;
#line 1029
            __cil_tmp142 = i;
#line 1029
            i ++;
          }
          while_break___23: /* CIL Label */ ;
          }
          while_break___9: ;
        } else {
          {
#line 1034
          c = getc(IN);
          }
#line 1036
          if (c == 0) {
#line 1038
            x = 0U;
#line 1039
            y ++;
#line 1040
            pix = (RGB + x) + ((H - y) - 1U) * W;
          } else
#line 1042
          if (c == 1) {
#line 1043
            goto while_break___8;
          } else
#line 1044
          if (c == 2) {
            {
#line 1046
            c = getc(IN);
#line 1047
            x += (unsigned int )c;
#line 1048
            c = getc(IN);
#line 1049
            y += (unsigned int )c;
#line 1050
            pix = (RGB + ((H - y) - 1U) * W) + x;
            }
          } else {
#line 1054
            i = 0;
            {
#line 1055
            while (1) {
              while_continue___10: /* CIL Label */ ;

#line 1055
              if ((unsigned long )pix < (unsigned long )beyond) {
#line 1055
                if (i < c) {
#line 1055
                  if (! (x < W)) {
#line 1055
                    goto while_break___10;
                  }
                } else {
#line 1055
                  goto while_break___10;
                }
              } else {
#line 1055
                goto while_break___10;
              }
              {
#line 1057
              c1 = getc(IN);
#line 1058
              *pix = (unsigned char )c1;
#line 1055
              __cil_tmp151 = pix;
#line 1055
              pix ++;
#line 1055
              __cil_tmp150 = x;
#line 1055
              x ++;
#line 1055
              __cil_tmp149 = i;
#line 1055
              i ++;
              }
            }
            while_break___24: /* CIL Label */ ;
            }
            while_break___10: ;
#line 1060
            if (c & 1) {
              {
#line 1061
              getc(IN);
              }
            }
          }
        }
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___8: ;
#line 1066
      if (gray_scale) {
#line 1068
        gray = (image->comps + 0)->data;
#line 1069
        pix = RGB;
#line 1070
        max = W * H;
        {
#line 1072
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1072
          __cil_tmp152 = max;
#line 1072
          max --;
#line 1072
          if (! __cil_tmp152) {
#line 1072
            goto while_break___11;
          }
#line 1074
          __cil_tmp153 = pix;
#line 1074
          pix ++;
#line 1074
          uc = *__cil_tmp153;
#line 1076
          __cil_tmp154 = gray;
#line 1076
          gray ++;
#line 1076
          *__cil_tmp154 = (int )*(table_R + (int )uc);
        }
        while_break___25: /* CIL Label */ ;
        }
        while_break___11: ;
      } else {
#line 1083
        red = (image->comps + 0)->data;
#line 1084
        green = (image->comps + 1)->data;
#line 1085
        blue = (image->comps + 2)->data;
#line 1086
        pix = RGB;
#line 1087
        max = W * H;
        {
#line 1089
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1089
          __cil_tmp155 = max;
#line 1089
          max --;
#line 1089
          if (! __cil_tmp155) {
#line 1089
            goto while_break___12;
          }
#line 1091
          __cil_tmp156 = pix;
#line 1091
          pix ++;
#line 1091
          uc = *__cil_tmp156;
#line 1093
          __cil_tmp157 = red;
#line 1093
          red ++;
#line 1093
          *__cil_tmp157 = (int )*(table_R + (int )uc);
#line 1094
          __cil_tmp158 = green;
#line 1094
          green ++;
#line 1094
          *__cil_tmp158 = (int )*(table_G + (int )uc);
#line 1095
          __cil_tmp159 = blue;
#line 1095
          blue ++;
#line 1095
          *__cil_tmp159 = (int )*(table_B + (int )uc);
        }
        while_break___26: /* CIL Label */ ;
        }
        while_break___12: ;
      }
      {
#line 1098
      free((void *)RGB);
#line 1099
      free((void *)table_R);
#line 1100
      free((void *)table_G);
#line 1101
      free((void *)table_B);
      }
    } else {
      {
#line 1105
      fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
              (int )Info_h.biBitCount);
      }
    }
  } else {
    {
#line 1105
    fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
            (int )Info_h.biBitCount);
    }
  }
  {
#line 1109
  fclose(IN);
  }
#line 1110
  return (image);
}
}
#line 1113 "/root/patchweave_new/10/src/bin/jp2/convert.c"
int imagetobmp(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int pad ;
  FILE *fdest ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  unsigned char rc ;
  unsigned char gc ;
  unsigned char bc ;
  int r ;
  int g ;
  int b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __cil_tmp22 ;
  int r___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp29 ;

  {
#line 1116
  fdest = (FILE *)((void *)0);
#line 1119
  if ((image->comps + 0)->prec < 8U) {
    {
#line 1120
    fprintf(stderr, "Unsupported number of components: %d\n", (image->comps + 0)->prec);
    }
#line 1121
    return (1);
  }
#line 1123
  if (image->numcomps >= 3U) {
#line 1123
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 1123
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 1123
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 1123
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 1123
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 1123
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
                {
#line 1134
                fdest = fopen(outfile, "wb");
                }
#line 1135
                if (! fdest) {
                  {
#line 1136
                  fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
                  }
#line 1137
                  return (1);
                }
                {
#line 1140
                w = (int )(image->comps + 0)->w;
#line 1141
                h = (int )(image->comps + 0)->h;
#line 1143
                fprintf(fdest, "BMJlEV");
#line 1147
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) + 54)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 8)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 16)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 24)) & 255);
#line 1152
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1153
                fprintf(fdest, "%c%c%c%c\251", 54, (54 >> 8) & 255, (54 >> 16) & 255,
                        (54 >> 24) & 255);
#line 1157
                fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255,
                        (40 >> 24) & 255);
#line 1158
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(w & 255)),
                        (int )((unsigned char )(w >> 8)) & 255, (int )((unsigned char )(w >> 16)) & 255,
                        (int )((unsigned char )(w >> 24)) & 255);
#line 1162
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h & 255)),
                        (int )((unsigned char )(h >> 8)) & 255, (int )((unsigned char )(h >> 16)) & 255,
                        (int )((unsigned char )(h >> 24)) & 255);
#line 1166
                fprintf(fdest, "%c%cEV", 1, (1 >> 8) & 255);
#line 1167
                fprintf(fdest, "%c%c", 24, (24 >> 8) & 255);
#line 1168
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1169
                fprintf(fdest, "%c%c%c%c\251", (int )((unsigned char )((3 * h) * w + (3 * h) * (w % 2))) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 8)) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 16)) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 24)) & 255);
#line 1173
                fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                        (7834 >> 24) & 255);
#line 1174
                fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                        (7834 >> 24) & 255);
#line 1175
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1176
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
                }
#line 1178
                if ((image->comps + 0)->prec > 8U) {
                  {
#line 1179
                  adjustR = (int )(image->comps + 0)->prec - 8;
#line 1180
                  printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n",
                         (image->comps + 0)->prec);
                  }
                } else {
#line 1183
                  adjustR = 0;
                }
#line 1184
                if ((image->comps + 1)->prec > 8U) {
                  {
#line 1185
                  adjustG = (int )(image->comps + 1)->prec - 8;
#line 1186
                  printf("BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\n",
                         (image->comps + 1)->prec);
                  }
                } else {
#line 1189
                  adjustG = 0;
                }
#line 1190
                if ((image->comps + 2)->prec > 8U) {
                  {
#line 1191
                  adjustB = (int )(image->comps + 2)->prec - 8;
#line 1192
                  printf("BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\n",
                         (image->comps + 2)->prec);
                  }
                } else {
#line 1195
                  adjustB = 0;
                }
#line 1197
                i = 0;
                {
#line 1197
                while (1) {
                  while_continue: /* CIL Label */ ;

#line 1197
                  if (! (i < w * h)) {
#line 1197
                    goto while_break;
                  }
#line 1201
                  r = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1202
                  if ((image->comps + 0)->sgnd) {
#line 1202
                    tmp = 1 << ((image->comps + 0)->prec - 1U);
                  } else {
#line 1202
                    tmp = 0;
                  }
#line 1202
                  r += tmp;
#line 1203
                  r = (r >> adjustR) + (r >> (adjustR - 1)) % 2;
#line 1204
                  if (r > 255) {
#line 1204
                    r = 255;
                  } else
#line 1204
                  if (r < 0) {
#line 1204
                    r = 0;
                  }
#line 1205
                  rc = (unsigned char )r;
#line 1207
                  g = *((image->comps + 1)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1208
                  if ((image->comps + 1)->sgnd) {
#line 1208
                    tmp___0 = 1 << ((image->comps + 1)->prec - 1U);
                  } else {
#line 1208
                    tmp___0 = 0;
                  }
#line 1208
                  g += tmp___0;
#line 1209
                  g = (g >> adjustG) + (g >> (adjustG - 1)) % 2;
#line 1210
                  if (g > 255) {
#line 1210
                    g = 255;
                  } else
#line 1210
                  if (g < 0) {
#line 1210
                    g = 0;
                  }
#line 1211
                  gc = (unsigned char )g;
#line 1213
                  b = *((image->comps + 2)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1214
                  if ((image->comps + 2)->sgnd) {
#line 1214
                    tmp___1 = 1 << ((image->comps + 2)->prec - 1U);
                  } else {
#line 1214
                    tmp___1 = 0;
                  }
#line 1214
                  b += tmp___1;
#line 1215
                  b = (b >> adjustB) + (b >> (adjustB - 1)) % 2;
#line 1216
                  if (b > 255) {
#line 1216
                    b = 255;
                  } else
#line 1216
                  if (b < 0) {
#line 1216
                    b = 0;
                  }
                  {
#line 1217
                  bc = (unsigned char )b;
#line 1219
                  fprintf(fdest, "%c%c%c", (int )bc, (int )gc, (int )rc);
                  }
#line 1221
                  if ((i + 1) % w == 0) {
#line 1222
                    if ((3 * w) % 4) {
#line 1222
                      tmp___2 = 4 - (3 * w) % 4;
                    } else {
#line 1222
                      tmp___2 = 0;
                    }
#line 1222
                    pad = tmp___2;
                    {
#line 1222
                    while (1) {
                      while_continue___0: /* CIL Label */ ;

#line 1222
                      if (! (pad > 0)) {
#line 1222
                        goto while_break___0;
                      }
                      {
#line 1223
                      fprintf(fdest, "%cIlEV", 0);
#line 1222
                      __cil_tmp22 = pad;
#line 1222
                      pad --;
                      }
                    }
                    while_break___5: /* CIL Label */ ;
                    }
                    while_break___0: ;
                  }
#line 1197
                  i ++;
                }
                while_break___4: /* CIL Label */ ;
                }
                while_break: 
                {
#line 1226
                fclose(fdest);
                }
              } else {
#line 1123
                goto _L;
              }
            } else {
#line 1123
              goto _L;
            }
          } else {
#line 1123
            goto _L;
          }
        } else {
#line 1123
          goto _L;
        }
      } else {
#line 1123
        goto _L;
      }
    } else {
#line 1123
      goto _L;
    }
  } else {
    _L: 
    {
#line 1233
    fdest = fopen(outfile, "wbJlEV");
#line 1234
    w = (int )(image->comps + 0)->w;
#line 1235
    h = (int )(image->comps + 0)->h;
#line 1237
    fprintf(fdest, "BMIlEV");
#line 1241
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(((h * w + 54) + 1024) + h * (w % 2))) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + h * (w % 2)) >> 8)) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + h * (w % 2)) >> 16)) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + w * (w % 2)) >> 24)) & 255);
#line 1245
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1246
    fprintf(fdest, "%c%c%c%c\251", 54, (1078 >> 8) & 255, (1078 >> 16) & 255, (1078 >> 24) & 255);
#line 1252
    fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255, (40 >> 24) & 255);
#line 1253
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(w & 255)), (int )((unsigned char )(w >> 8)) & 255,
            (int )((unsigned char )(w >> 16)) & 255, (int )((unsigned char )(w >> 24)) & 255);
#line 1257
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h & 255)), (int )((unsigned char )(h >> 8)) & 255,
            (int )((unsigned char )(h >> 16)) & 255, (int )((unsigned char )(h >> 24)) & 255);
#line 1261
    fprintf(fdest, "%c%cEV", 1, (1 >> 8) & 255);
#line 1262
    fprintf(fdest, "%c%cEV", 8, (8 >> 8) & 255);
#line 1263
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1264
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h * w + h * (w % 2))) & 255,
            (int )((unsigned char )((h * w + h * (w % 2)) >> 8)) & 255, (int )((unsigned char )((h * w + h * (w % 2)) >> 16)) & 255,
            (int )((unsigned char )((h * w + h * (w % 2)) >> 24)) & 255);
#line 1268
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1269
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1270
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
#line 1271
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
    }
#line 1273
    if ((image->comps + 0)->prec > 8U) {
      {
#line 1274
      adjustR = (int )(image->comps + 0)->prec - 8;
#line 1275
      printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", (image->comps + 0)->prec);
      }
    } else {
#line 1277
      adjustR = 0;
    }
#line 1279
    i = 0;
    {
#line 1279
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1279
      if (! (i < 256)) {
#line 1279
        goto while_break___1;
      }
      {
#line 1280
      fprintf(fdest, "%c%c%c%c\230\001", i, i, i, 0);
#line 1279
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: 
#line 1283
    i = 0;
    {
#line 1283
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 1283
      if (! (i < w * h)) {
#line 1283
        goto while_break___2;
      }
#line 1286
      r___0 = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1287
      if ((image->comps + 0)->sgnd) {
#line 1287
        tmp___3 = 1 << ((image->comps + 0)->prec - 1U);
      } else {
#line 1287
        tmp___3 = 0;
      }
#line 1287
      r___0 += tmp___3;
#line 1288
      r___0 = (r___0 >> adjustR) + (r___0 >> (adjustR - 1)) % 2;
#line 1289
      if (r___0 > 255) {
#line 1289
        r___0 = 255;
      } else
#line 1289
      if (r___0 < 0) {
#line 1289
        r___0 = 0;
      }
      {
#line 1291
      fprintf(fdest, "%c", (int )((unsigned char )r___0));
      }
#line 1293
      if ((i + 1) % w == 0) {
#line 1294
        if (w % 4) {
#line 1294
          tmp___4 = 4 - w % 4;
        } else {
#line 1294
          tmp___4 = 0;
        }
#line 1294
        pad = tmp___4;
        {
#line 1294
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1294
          if (! (pad > 0)) {
#line 1294
            goto while_break___3;
          }
          {
#line 1295
          fprintf(fdest, "%c", 0);
#line 1294
          __cil_tmp29 = pad;
#line 1294
          pad --;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: ;
      }
#line 1283
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 1298
    fclose(fdest);
    }
  }
#line 1301
  return (0);
}
}
#line 1311 "/root/patchweave_new/10/src/bin/jp2/convert.c"
static unsigned char readuchar(FILE *f ) 
{ 
  unsigned char c1 ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 1314
  __cil_tmp3 = fread((void *)(& c1), 1UL, 1UL, f);
  }
#line 1314
  if (! __cil_tmp3) {
    {
#line 1316
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1317
    return ((unsigned char)0);
  }
#line 1319
  return (c1);
}
}
#line 1322 "/root/patchweave_new/10/src/bin/jp2/convert.c"
static unsigned short readushort(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 1325
  __cil_tmp5 = fread((void *)(& c1), 1UL, 1UL, f);
  }
#line 1325
  if (! __cil_tmp5) {
    {
#line 1327
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1328
    return ((unsigned short)0);
  }
  {
#line 1330
  __cil_tmp6 = fread((void *)(& c2), 1UL, 1UL, f);
  }
#line 1330
  if (! __cil_tmp6) {
    {
#line 1332
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1333
    return ((unsigned short)0);
  }
#line 1335
  if (bigendian) {
#line 1336
    return ((unsigned short )(((int )c1 << 8) + (int )c2));
  } else {
#line 1338
    return ((unsigned short )(((int )c2 << 8) + (int )c1));
  }
}
}
#line 1341 "/root/patchweave_new/10/src/bin/jp2/convert.c"
static unsigned int readuint(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char c3 ;
  unsigned char c4 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  {
#line 1344
  __cil_tmp7 = fread((void *)(& c1), 1UL, 1UL, f);
  }
#line 1344
  if (! __cil_tmp7) {
    {
#line 1346
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1347
    return (0U);
  }
  {
#line 1349
  __cil_tmp8 = fread((void *)(& c2), 1UL, 1UL, f);
  }
#line 1349
  if (! __cil_tmp8) {
    {
#line 1351
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1352
    return (0U);
  }
  {
#line 1354
  __cil_tmp9 = fread((void *)(& c3), 1UL, 1UL, f);
  }
#line 1354
  if (! __cil_tmp9) {
    {
#line 1356
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1357
    return (0U);
  }
  {
#line 1359
  __cil_tmp10 = fread((void *)(& c4), 1UL, 1UL, f);
  }
#line 1359
  if (! __cil_tmp10) {
    {
#line 1361
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1362
    return (0U);
  }
#line 1364
  if (bigendian) {
#line 1365
    return ((((unsigned int )((int )c1 << 24) + (unsigned int )((int )c2 << 16)) + (unsigned int )((int )c3 << 8)) + (unsigned int )c4);
  } else {
#line 1367
    return ((((unsigned int )((int )c4 << 24) + (unsigned int )((int )c3 << 16)) + (unsigned int )((int )c2 << 8)) + (unsigned int )c1);
  }
}
}
#line 1370 "/root/patchweave_new/10/src/bin/jp2/convert.c"
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  int w ;
  int h ;
  int prec ;
  int i ;
  int numcomps ;
  int max ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm ;
  opj_image_t *image ;
  int adjustS ;
  int ushift ;
  int dshift ;
  int force8 ;
  char endian1 ;
  char endian2 ;
  char sign ;
  char signtmp[32] ;
  char temp[32] ;
  int bigendian ;
  opj_image_comp_t *comp ;
  int __cil_tmp25 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 tmp___0 ;
  int v ;
  unsigned char __cil_tmp31 ;
  unsigned char __cil_tmp32 ;
  unsigned char __cil_tmp33 ;
  unsigned short __cil_tmp34 ;
  unsigned short __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  int __cil_tmp39 ;

  {
  {
#line 1371
  f = (FILE *)((void *)0);
#line 1376
  image = (opj_image_t *)((void *)0);
#line 1384
  comp = (opj_image_comp_t *)((void *)0);
#line 1386
  numcomps = 1;
#line 1387
  color_space = (OPJ_COLOR_SPACE )2;
#line 1389
  memset((void *)(& cmptparm), 0, sizeof(opj_image_cmptparm_t ));
#line 1391
  max = 0;
#line 1393
  f = fopen(filename, "rb");
  }
#line 1394
  if (! f) {
    {
#line 1395
    fprintf(stderr, "Failed to open %s for reading !\n\230\001", filename);
    }
#line 1396
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1399
  fseek(f, 0L, 0);
#line 1400
  __cil_tmp25 = fscanf(f, "PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d", temp, & endian1,
                       & endian2, signtmp, & prec, temp, & w, temp, & h);
  }
#line 1400
  if (__cil_tmp25 != 9) {
    {
#line 1401
    fprintf(stderr, "ERROR: Failed to read the right number of element from the fscanf() function!\n");
    }
#line 1402
    return ((opj_image_t *)((void *)0));
  }
#line 1405
  i = 0;
#line 1406
  sign = (char )'+';
  {
#line 1407
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1407
    if (! ((int )signtmp[i] != 0)) {
#line 1407
      goto while_break;
    }
#line 1408
    if ((int )signtmp[i] == 45) {
#line 1408
      sign = (char )'-';
    }
#line 1409
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1412
  fgetc(f);
  }
#line 1413
  if ((int )endian1 == 77) {
#line 1413
    if ((int )endian2 == 76) {
#line 1414
      bigendian = 1;
    } else {
#line 1413
      goto _L;
    }
  } else
  _L: 
#line 1415
  if ((int )endian2 == 77) {
#line 1415
    if ((int )endian1 == 76) {
#line 1416
      bigendian = 0;
    } else {
      {
#line 1418
      fprintf(stderr, "Bad pgx header, please check input file\n\220");
      }
#line 1419
      return ((opj_image_t *)((void *)0));
    }
  } else {
    {
#line 1418
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
#line 1419
    return ((opj_image_t *)((void *)0));
  }
#line 1424
  cmptparm.x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 1425
  cmptparm.y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 1426
  if (! cmptparm.x0) {
#line 1426
    tmp = (OPJ_UINT32 )((w - 1) * parameters->subsampling_dx + 1);
  } else {
#line 1426
    tmp = (cmptparm.x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )parameters->subsampling_dx) + 1U;
  }
#line 1426
  cmptparm.w = tmp;
#line 1427
  if (! cmptparm.y0) {
#line 1427
    tmp___0 = (OPJ_UINT32 )((h - 1) * parameters->subsampling_dy + 1);
  } else {
#line 1427
    tmp___0 = (cmptparm.y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )parameters->subsampling_dy) + 1U;
  }
#line 1427
  cmptparm.h = tmp___0;
#line 1429
  if ((int )sign == 45) {
#line 1430
    cmptparm.sgnd = (OPJ_UINT32 )1;
  } else {
#line 1432
    cmptparm.sgnd = (OPJ_UINT32 )0;
  }
#line 1434
  if (prec < 8) {
#line 1436
    force8 = 1;
#line 1437
    ushift = 8 - prec;
#line 1437
    dshift = prec - ushift;
#line 1438
    if (cmptparm.sgnd) {
#line 1438
      adjustS = 1 << (prec - 1);
    } else {
#line 1438
      adjustS = 0;
    }
#line 1439
    cmptparm.sgnd = (OPJ_UINT32 )0;
#line 1440
    prec = 8;
  } else {
#line 1442
    adjustS = 0;
#line 1442
    force8 = adjustS;
#line 1442
    dshift = force8;
#line 1442
    ushift = dshift;
  }
  {
#line 1444
  cmptparm.prec = (OPJ_UINT32 )prec;
#line 1445
  cmptparm.bpp = (OPJ_UINT32 )prec;
#line 1446
  cmptparm.dx = (OPJ_UINT32 )parameters->subsampling_dx;
#line 1447
  cmptparm.dy = (OPJ_UINT32 )parameters->subsampling_dy;
#line 1450
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm, color_space);
  }
#line 1451
  if (! image) {
    {
#line 1452
    fclose(f);
    }
#line 1453
    return ((opj_image_t *)((void *)0));
  }
#line 1456
  image->x0 = cmptparm.x0;
#line 1457
  image->y0 = cmptparm.x0;
#line 1458
  image->x1 = cmptparm.w;
#line 1459
  image->y1 = cmptparm.h;
#line 1463
  comp = image->comps + 0;
#line 1465
  i = 0;
  {
#line 1465
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue___0: ;
#line 1465
    if (! (i < w * h)) {
#line 1465
      goto while_break___0;
    }
#line 1467
    if (force8) {
      {
#line 1469
      __cil_tmp31 = readuchar(f);
#line 1469
      v = (int )__cil_tmp31 + adjustS;
#line 1470
      v = (v << ushift) + (v >> dshift);
#line 1471
      *(comp->data + i) = (OPJ_INT32 )((unsigned char )v);
      }
#line 1473
      if (v > max) {
#line 1473
        max = v;
      }
#line 1475
      goto while_continue___0;
    }
#line 1477
    if (comp->prec == 8U) {
#line 1478
      if (! comp->sgnd) {
        {
#line 1479
        __cil_tmp32 = readuchar(f);
#line 1479
        v = (int )__cil_tmp32;
        }
      } else {
        {
#line 1481
        __cil_tmp33 = readuchar(f);
#line 1481
        v = (int )((char )__cil_tmp33);
        }
      }
    } else
#line 1483
    if (comp->prec <= 16U) {
#line 1484
      if (! comp->sgnd) {
        {
#line 1485
        __cil_tmp34 = readushort(f, bigendian);
#line 1485
        v = (int )__cil_tmp34;
        }
      } else {
        {
#line 1487
        __cil_tmp35 = readushort(f, bigendian);
#line 1487
        v = (int )((short )__cil_tmp35);
        }
      }
    } else
#line 1490
    if (! comp->sgnd) {
      {
#line 1491
      __cil_tmp36 = readuint(f, bigendian);
#line 1491
      v = (int )__cil_tmp36;
      }
    } else {
      {
#line 1493
      __cil_tmp37 = readuint(f, bigendian);
#line 1493
      v = (int )__cil_tmp37;
      }
    }
#line 1496
    if (v > max) {
#line 1497
      max = v;
    }
#line 1498
    *(comp->data + i) = v;
#line 1465
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 1500
  fclose(f);
#line 1501
  __cil_tmp39 = int_floorlog2(max);
#line 1501
  comp->bpp = (OPJ_UINT32 )__cil_tmp39 + 1U;
  }
#line 1503
  return (image);
}
}
#line 1508 "/root/patchweave_new/10/src/bin/jp2/convert.c"
__inline static int clamp(int value , int prec , int sgnd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1510
  if (sgnd) {
#line 1512
    if (prec <= 8) {
#line 1512
      if (value < -128) {
#line 1512
        tmp___0 = -128;
      } else {
#line 1512
        if (value > 127) {
#line 1512
          tmp = 127;
        } else {
#line 1512
          tmp = value;
        }
#line 1512
        tmp___0 = tmp;
      }
#line 1512
      return (tmp___0);
    } else
#line 1513
    if (prec <= 16) {
#line 1513
      if (value < -32768) {
#line 1513
        tmp___2 = -32768;
      } else {
#line 1513
        if (value > 32767) {
#line 1513
          tmp___1 = 32767;
        } else {
#line 1513
          tmp___1 = value;
        }
#line 1513
        tmp___2 = tmp___1;
      }
#line 1513
      return (tmp___2);
    } else {
#line 1514
      if (value < (-0x7FFFFFFF-1)) {
#line 1514
        tmp___4 = (-0x7FFFFFFF-1);
      } else {
#line 1514
        if (value > 2147483647) {
#line 1514
          tmp___3 = 2147483647;
        } else {
#line 1514
          tmp___3 = value;
        }
#line 1514
        tmp___4 = tmp___3;
      }
#line 1514
      return (tmp___4);
    }
  } else
#line 1518
  if (prec <= 8) {
#line 1518
    if (value < 0) {
#line 1518
      tmp___6 = 0;
    } else {
#line 1518
      if (value > 255) {
#line 1518
        tmp___5 = 255;
      } else {
#line 1518
        tmp___5 = value;
      }
#line 1518
      tmp___6 = tmp___5;
    }
#line 1518
    return (tmp___6);
  } else
#line 1519
  if (prec <= 16) {
#line 1519
    if (value < 0) {
#line 1519
      tmp___8 = 0;
    } else {
#line 1519
      if (value > 65535) {
#line 1519
        tmp___7 = 65535;
      } else {
#line 1519
        tmp___7 = value;
      }
#line 1519
      tmp___8 = tmp___7;
    }
#line 1519
    return (tmp___8);
  } else {
#line 1520
    return (value);
  }
}
}
#line 1524 "/root/patchweave_new/10/src/bin/jp2/convert.c"
int imagetopgx(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int j ;
  int fails ;
  unsigned int compno ;
  FILE *fdest ;
  opj_image_comp_t *comp ;
  char bname[256] ;
  char *name ;
  int nbytes ;
  size_t res ;
  size_t olen ;
  unsigned long __cil_tmp16 ;
  size_t dotpos ;
  size_t total ;
  void *__cil_tmp19 ;
  int tmp ;
  int val ;
  int __cil_tmp23 ;
  int v ;
  unsigned char byte ;
  int __cil_tmp27 ;

  {
#line 1527
  fails = 1;
#line 1529
  fdest = (FILE *)((void *)0);
#line 1531
  compno = 0U;
  {
#line 1531
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1531
    if (! (compno < image->numcomps)) {
#line 1531
      goto while_break;
    }
    {
#line 1533
    comp = image->comps + compno;
#line 1535
    name = bname;
#line 1536
    nbytes = 0;
#line 1538
    __cil_tmp16 = strlen(outfile);
#line 1538
    olen = __cil_tmp16;
#line 1539
    dotpos = olen - 4UL;
#line 1540
    total = ((dotpos + 1UL) + 1UL) + 4UL;
    }
#line 1542
    if ((int )*(outfile + dotpos) != 46) {
      {
#line 1545
      fprintf(stderr, "ERROR -> Impossible happen.");
      }
#line 1546
      goto fin;
    }
#line 1548
    if (total > 256UL) {
      {
#line 1550
      __cil_tmp19 = malloc(total + 1UL);
#line 1550
      name = (char *)__cil_tmp19;
      }
    }
    {
#line 1552
    strncpy(name, outfile, dotpos);
#line 1553
    sprintf(name + dotpos, "_%d.pgx", compno);
#line 1554
    fdest = fopen((char const   *)name, "wbLlEV");
    }
#line 1556
    if (total > 256UL) {
      {
#line 1556
      free((void *)name);
      }
    }
#line 1557
    if (! fdest) {
      {
#line 1559
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", name);
      }
#line 1560
      goto fin;
    }
#line 1563
    w = (int )(image->comps + compno)->w;
#line 1564
    h = (int )(image->comps + compno)->h;
#line 1566
    if (comp->sgnd) {
#line 1566
      tmp = '-';
    } else {
#line 1566
      tmp = '+';
    }
    {
#line 1566
    fprintf(fdest, "PG ML %c %d %d %d\nLlEV", tmp, comp->prec, w, h);
    }
#line 1569
    if (comp->prec <= 8U) {
#line 1570
      nbytes = 1;
    } else
#line 1571
    if (comp->prec <= 16U) {
#line 1572
      nbytes = 2;
    } else {
#line 1574
      nbytes = 4;
    }
#line 1576
    i = 0;
    {
#line 1576
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1576
      if (! (i < w * h)) {
#line 1576
        goto while_break___0;
      }
      {
#line 1579
      __cil_tmp23 = clamp(*((image->comps + compno)->data + i), (int )comp->prec,
                          (int )comp->sgnd);
#line 1579
      val = __cil_tmp23;
#line 1582
      j = nbytes - 1;
      }
      {
#line 1582
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1582
        if (! (j >= 0)) {
#line 1582
          goto while_break___1;
        }
        {
#line 1584
        v = val >> j * 8;
#line 1585
        byte = (unsigned char )v;
#line 1586
        res = fwrite((void const   *)(& byte), 1UL, 1UL, fdest);
        }
#line 1588
        if (res < 1UL) {
          {
#line 1590
          fprintf(stderr, "failed to write 1 byte for %s\n", name);
          }
#line 1591
          goto fin;
        }
#line 1582
        __cil_tmp27 = j;
#line 1582
        j --;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 1576
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 1595
    fclose(fdest);
#line 1595
    fdest = (FILE *)((void *)0);
#line 1531
    compno ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 1597
  fails = 0;
  fin: 
#line 1599
  if (fdest) {
    {
#line 1599
    fclose(fdest);
    }
  }
#line 1601
  return (fails);
}
}
#line 1617 "/root/patchweave_new/10/src/bin/jp2/convert.c"
static char *skip_white(char *s ) 
{ 
  unsigned short const   **__cil_tmp2 ;

  {
  {
#line 1619
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1619
    if (! *s) {
#line 1619
      goto while_break;
    }
#line 1621
    if ((int )*s == 10) {
#line 1621
      return ((char *)((void *)0));
    } else
#line 1621
    if ((int )*s == 13) {
#line 1621
      return ((char *)((void *)0));
    }
    {
#line 1622
    __cil_tmp2 = __ctype_b_loc();
    }
#line 1622
    if ((int )*(*__cil_tmp2 + (int )*s) & 8192) {
#line 1622
      s ++;
#line 1622
      goto while_continue;
    }
#line 1623
    return (s);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1625
  return ((char *)((void *)0));
}
}
#line 1628 "/root/patchweave_new/10/src/bin/jp2/convert.c"
static char *skip_int(char *start , int *out_n ) 
{ 
  char *s ;
  char c ;
  unsigned short const   **__cil_tmp6 ;

  {
  {
#line 1633
  *out_n = 0;
#line 1633
  s = start;
#line 1635
  s = skip_white(start);
  }
#line 1636
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1636
    return ((char *)((void *)0));
  }
#line 1637
  start = s;
  {
#line 1639
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1639
    if (! *s) {
#line 1639
      goto while_break;
    }
    {
#line 1641
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1641
    if (! ((int )*(*__cil_tmp6 + (int )*s) & 2048)) {
#line 1641
      goto while_break;
    }
#line 1642
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1644
  c = *s;
#line 1644
  *s = (char)0;
#line 1644
  *out_n = atoi((char const   *)start);
#line 1644
  *s = c;
  }
#line 1645
  return (s);
}
}
#line 1648 "/root/patchweave_new/10/src/bin/jp2/convert.c"
static char *skip_idf(char *start , char *out_idf ) 
{ 
  char *s ;
  char c ;
  unsigned short const   **__cil_tmp6 ;

  {
  {
#line 1653
  s = skip_white(start);
  }
#line 1654
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1654
    return ((char *)((void *)0));
  }
#line 1655
  start = s;
  {
#line 1657
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1657
    if (! *s) {
#line 1657
      goto while_break;
    }
    {
#line 1659
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1659
    if ((int )*(*__cil_tmp6 + (int )*s) & 1024) {
#line 1659
      s ++;
#line 1659
      goto while_continue;
    } else
#line 1659
    if ((int )*s == 95) {
#line 1659
      s ++;
#line 1659
      goto while_continue;
    }
#line 1660
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1662
  c = *s;
#line 1662
  *s = (char)0;
#line 1662
  strncpy((char *)out_idf, (char const   *)start, 255UL);
#line 1662
  *s = c;
  }
#line 1663
  return (s);
}
}
#line 1666 "/root/patchweave_new/10/src/bin/jp2/convert.c"
static void read_pnm_header(FILE *reader , struct pnm_header *ph ) 
{ 
  int format ;
  int have_wh ;
  int end ;
  int ttype ;
  char idf[256] ;
  char type[256] ;
  char line[256] ;
  char *__cil_tmp10 ;
  char *__cil_tmp12 ;
  char *s ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp18 ;
  int __cil_tmp20 ;
  int __cil_tmp22 ;
  int __cil_tmp24 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  char *__cil_tmp33 ;

  {
  {
#line 1672
  __cil_tmp10 = fgets(line, 250, reader);
  }
#line 1672
  if ((unsigned long )__cil_tmp10 == (unsigned long )((void *)0)) {
    {
#line 1674
    fprintf(stderr, "\nWARNING: fgets return a NULL value");
    }
#line 1675
    return;
  }
#line 1678
  if ((int )line[0] != 80) {
    {
#line 1680
    fprintf(stderr, "read_pnm_header:PNM:magic P missing\n");
    }
#line 1680
    return;
  }
  {
#line 1682
  format = atoi((char const   *)(line + 1));
  }
#line 1683
  if (format < 1) {
    {
#line 1685
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
#line 1686
    return;
  } else
#line 1683
  if (format > 7) {
    {
#line 1685
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
#line 1686
    return;
  }
#line 1688
  ph->format = format;
#line 1689
  have_wh = 0;
#line 1689
  end = have_wh;
#line 1689
  ttype = end;
  {
#line 1691
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 1691
    __cil_tmp12 = fgets(line, 250, reader);
    }
#line 1691
    if (! __cil_tmp12) {
#line 1691
      goto while_break;
    }
#line 1695
    if ((int )line[0] == 35) {
#line 1695
      goto while_continue;
    }
#line 1697
    s = line;
#line 1699
    if (format == 7) {
      {
#line 1701
      s = skip_idf(s, (char *)(idf));
      }
#line 1703
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1703
        return;
      } else
#line 1703
      if ((int )*s == 0) {
#line 1703
        return;
      }
      {
#line 1705
      __cil_tmp15 = strcmp((char const   *)(idf), "ENDHDR");
      }
#line 1705
      if (__cil_tmp15 == 0) {
#line 1707
        end = 1;
#line 1707
        goto while_break;
      }
      {
#line 1709
      __cil_tmp16 = strcmp((char const   *)(idf), "WIDTHV");
      }
#line 1709
      if (__cil_tmp16 == 0) {
        {
#line 1711
        s = skip_int(s, & ph->width);
        }
#line 1712
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1712
          return;
        } else
#line 1712
        if ((int )*s == 0) {
#line 1712
          return;
        }
#line 1714
        goto while_continue;
      }
      {
#line 1716
      __cil_tmp18 = strcmp((char const   *)(idf), "HEIGHT");
      }
#line 1716
      if (__cil_tmp18 == 0) {
        {
#line 1718
        s = skip_int(s, & ph->height);
        }
#line 1719
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1719
          return;
        } else
#line 1719
        if ((int )*s == 0) {
#line 1719
          return;
        }
#line 1721
        goto while_continue;
      }
      {
#line 1723
      __cil_tmp20 = strcmp((char const   *)(idf), "DEPTH");
      }
#line 1723
      if (__cil_tmp20 == 0) {
        {
#line 1725
        s = skip_int(s, & ph->depth);
        }
#line 1726
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1726
          return;
        } else
#line 1726
        if ((int )*s == 0) {
#line 1726
          return;
        }
#line 1728
        goto while_continue;
      }
      {
#line 1730
      __cil_tmp22 = strcmp((char const   *)(idf), "MAXVAL");
      }
#line 1730
      if (__cil_tmp22 == 0) {
        {
#line 1732
        s = skip_int(s, & ph->maxval);
        }
#line 1733
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1733
          return;
        } else
#line 1733
        if ((int )*s == 0) {
#line 1733
          return;
        }
#line 1735
        goto while_continue;
      }
      {
#line 1737
      __cil_tmp24 = strcmp((char const   *)(idf), "TUPLTYPE\220");
      }
#line 1737
      if (__cil_tmp24 == 0) {
        {
#line 1739
        s = skip_idf(s, (char *)(type));
        }
#line 1740
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1740
          return;
        } else
#line 1740
        if ((int )*s == 0) {
#line 1740
          return;
        }
        {
#line 1742
        __cil_tmp26 = strcmp((char const   *)(type), "BLACKANDWHITE");
        }
#line 1742
        if (__cil_tmp26 == 0) {
#line 1744
          ph->bw = (char)1;
#line 1744
          ttype = 1;
#line 1744
          goto while_continue;
        }
        {
#line 1746
        __cil_tmp27 = strcmp((char const   *)(type), "GRAYSCALE");
        }
#line 1746
        if (__cil_tmp27 == 0) {
#line 1748
          ph->gray = (char)1;
#line 1748
          ttype = 1;
#line 1748
          goto while_continue;
        }
        {
#line 1750
        __cil_tmp28 = strcmp((char const   *)(type), "GRAYSCALE_ALPHA");
        }
#line 1750
        if (__cil_tmp28 == 0) {
#line 1752
          ph->graya = (char)1;
#line 1752
          ttype = 1;
#line 1752
          goto while_continue;
        }
        {
#line 1754
        __cil_tmp29 = strcmp((char const   *)(type), "RGB");
        }
#line 1754
        if (__cil_tmp29 == 0) {
#line 1756
          ph->rgb = (char)1;
#line 1756
          ttype = 1;
#line 1756
          goto while_continue;
        }
        {
#line 1758
        __cil_tmp30 = strcmp((char const   *)(type), "RGB_ALPHA");
        }
#line 1758
        if (__cil_tmp30 == 0) {
#line 1760
          ph->rgba = (char)1;
#line 1760
          ttype = 1;
#line 1760
          goto while_continue;
        }
        {
#line 1762
        fprintf(stderr, "read_pnm_header:unknown P7 TUPLTYPE %s\n", type);
        }
#line 1763
        return;
      }
      {
#line 1765
      fprintf(stderr, "read_pnm_header:unknown P7 idf %s\n", idf);
      }
#line 1766
      return;
    }
#line 1769
    if (! have_wh) {
      {
#line 1771
      s = skip_int(s, & ph->width);
#line 1773
      s = skip_int(s, & ph->height);
#line 1775
      have_wh = 1;
      }
#line 1777
      if (format == 1) {
#line 1777
        goto while_break;
      } else
#line 1777
      if (format == 4) {
#line 1777
        goto while_break;
      }
#line 1779
      if (format == 2) {
        _L: 
        {
#line 1781
        __cil_tmp33 = skip_int(s, & ph->maxval);
        }
#line 1781
        if ((unsigned long )__cil_tmp33 != (unsigned long )((void *)0)) {
#line 1782
          if (ph->maxval > 65535) {
#line 1783
            return;
          } else {
#line 1786
            goto while_break;
          }
        }
      } else
#line 1779
      if (format == 3) {
#line 1779
        goto _L;
      } else
#line 1779
      if (format == 5) {
#line 1779
        goto _L;
      } else
#line 1779
      if (format == 6) {
#line 1779
        goto _L;
      }
#line 1790
      goto while_continue;
    }
#line 1792
    if (format == 2) {
      _L___37: 
      {
#line 1795
      s = skip_int(s, & ph->maxval);
      }
#line 1797
      if (ph->maxval > 65535) {
#line 1797
        return;
      }
    } else
#line 1792
    if (format == 3) {
#line 1792
      goto _L___37;
    } else
#line 1792
    if (format == 5) {
#line 1792
      goto _L___37;
    } else
#line 1792
    if (format == 6) {
#line 1792
      goto _L___37;
    }
#line 1799
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1801
  if (format == 2) {
    _L___40: 
#line 1803
    if (ph->maxval < 1) {
#line 1803
      return;
    } else
#line 1803
    if (ph->maxval > 65535) {
#line 1803
      return;
    }
  } else
#line 1801
  if (format == 3) {
#line 1801
    goto _L___40;
  } else
#line 1801
  if (format > 4) {
#line 1801
    goto _L___40;
  }
#line 1805
  if (ph->width < 1) {
#line 1805
    return;
  } else
#line 1805
  if (ph->height < 1) {
#line 1805
    return;
  }
#line 1807
  if (format == 7) {
#line 1809
    if (! end) {
      {
#line 1811
      fprintf(stderr, "read_pnm_header:P7 without ENDHDR\n");
      }
#line 1811
      return;
    }
#line 1813
    if (ph->depth < 1) {
#line 1813
      return;
    } else
#line 1813
    if (ph->depth > 4) {
#line 1813
      return;
    }
#line 1815
    if (ph->width) {
#line 1815
      if (ph->height) {
#line 1815
        if (ph->depth) {
#line 1815
          if (ph->maxval) {
#line 1815
            if (ttype) {
#line 1816
              ph->ok = (char)1;
            }
          }
        }
      }
    }
  } else
#line 1820
  if (format != 1) {
#line 1820
    if (format != 4) {
#line 1822
      if (ph->width) {
#line 1822
        if (ph->height) {
#line 1822
          if (ph->maxval) {
#line 1822
            ph->ok = (char)1;
          }
        }
      }
    } else {
#line 1820
      goto _L___42;
    }
  } else {
    _L___42: 
#line 1826
    if (ph->width) {
#line 1826
      if (ph->height) {
#line 1826
        ph->ok = (char)1;
      }
    }
#line 1827
    ph->maxval = 255;
  }
#line 1829
  return;
}
}
#line 1832 "/root/patchweave_new/10/src/bin/jp2/convert.c"
static int has_prec(int val ) 
{ 


  {
#line 1834
  if (val < 2) {
#line 1834
    return (1);
  }
#line 1835
  if (val < 4) {
#line 1835
    return (2);
  }
#line 1836
  if (val < 8) {
#line 1836
    return (3);
  }
#line 1837
  if (val < 16) {
#line 1837
    return (4);
  }
#line 1838
  if (val < 32) {
#line 1838
    return (5);
  }
#line 1839
  if (val < 64) {
#line 1839
    return (6);
  }
#line 1840
  if (val < 128) {
#line 1840
    return (7);
  }
#line 1841
  if (val < 256) {
#line 1841
    return (8);
  }
#line 1842
  if (val < 512) {
#line 1842
    return (9);
  }
#line 1843
  if (val < 1024) {
#line 1843
    return (10);
  }
#line 1844
  if (val < 2048) {
#line 1844
    return (11);
  }
#line 1845
  if (val < 4096) {
#line 1845
    return (12);
  }
#line 1846
  if (val < 8192) {
#line 1846
    return (13);
  }
#line 1847
  if (val < 16384) {
#line 1847
    return (14);
  }
#line 1848
  if (val < 32768) {
#line 1848
    return (15);
  }
#line 1849
  return (16);
}
}
#line 1852 "/root/patchweave_new/10/src/bin/jp2/convert.c"
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *fp ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  int prec ;
  int format ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[4] ;
  opj_image_t *image ;
  struct pnm_header header_info ;
  unsigned int index___43 ;
  int __cil_tmp22 ;
  unsigned char c0 ;
  unsigned char c1 ;
  unsigned char one ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned int index___44 ;
  int __cil_tmp33 ;
  int tmp ;
  int x ;
  int y ;
  int bit ;
  unsigned char uc ;
  int __cil_tmp40 ;
  int tmp___0 ;
  unsigned char uc___0 ;
  unsigned long __cil_tmp43 ;
  int tmp___1 ;

  {
  {
#line 1853
  subsampling_dx = parameters->subsampling_dx;
#line 1854
  subsampling_dy = parameters->subsampling_dy;
#line 1856
  fp = (FILE *)((void *)0);
#line 1860
  image = (opj_image_t *)((void *)0);
#line 1863
  fp = fopen(filename, "rb");
  }
#line 1863
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 1865
    fprintf(stderr, "pnmtoimage:Failed to open %s for reading!\n", filename);
    }
#line 1866
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1868
  memset((void *)(& header_info), 0, sizeof(struct pnm_header ));
#line 1870
  read_pnm_header(fp, & header_info);
  }
#line 1872
  if (! header_info.ok) {
    {
#line 1872
    fclose(fp);
    }
#line 1872
    return ((opj_image_t *)((void *)0));
  }
#line 1874
  format = header_info.format;
#line 1879
  if (format == 4) {
#line 1879
    goto case_4;
  }
#line 1879
  if (format == 1) {
#line 1879
    goto case_4;
  }
#line 1884
  if (format == 5) {
#line 1884
    goto case_5;
  }
#line 1884
  if (format == 2) {
#line 1884
    goto case_5;
  }
#line 1889
  if (format == 6) {
#line 1889
    goto case_6;
  }
#line 1889
  if (format == 3) {
#line 1889
    goto case_6;
  }
#line 1893
  if (format == 7) {
#line 1893
    goto case_7;
  }
#line 1897
  goto switch_default;
  case_4: 
#line 1880
  numcomps = 1;
#line 1881
  goto switch_break;
  case_5: 
#line 1885
  numcomps = 1;
#line 1886
  goto switch_break;
  case_6: 
#line 1890
  numcomps = 3;
#line 1891
  goto switch_break;
  case_7: 
#line 1894
  numcomps = header_info.depth;
#line 1895
  goto switch_break;
  switch_default: 
  {
#line 1897
  fclose(fp);
  }
#line 1897
  return ((opj_image_t *)((void *)0));
  switch_break: ;
#line 1899
  if (numcomps < 3) {
#line 1900
    color_space = (OPJ_COLOR_SPACE )2;
  } else {
#line 1902
    color_space = (OPJ_COLOR_SPACE )1;
  }
  {
#line 1904
  prec = has_prec(header_info.maxval);
  }
#line 1906
  if (prec < 8) {
#line 1906
    prec = 8;
  }
  {
#line 1908
  w = header_info.width;
#line 1909
  h = header_info.height;
#line 1910
  subsampling_dx = parameters->subsampling_dx;
#line 1911
  subsampling_dy = parameters->subsampling_dy;
#line 1913
  memset((void *)(& cmptparm[0]), 0, (size_t )numcomps * sizeof(opj_image_cmptparm_t ));
#line 1915
  i = 0;
  }
  {
#line 1915
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1915
    if (! (i < numcomps)) {
#line 1915
      goto while_break;
    }
#line 1917
    cmptparm[i].prec = (OPJ_UINT32 )prec;
#line 1918
    cmptparm[i].bpp = (OPJ_UINT32 )prec;
#line 1919
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 1920
    cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 1921
    cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 1922
    cmptparm[i].w = (OPJ_UINT32 )w;
#line 1923
    cmptparm[i].h = (OPJ_UINT32 )h;
#line 1915
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1925
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
  }
#line 1927
  if (! image) {
    {
#line 1927
    fclose(fp);
    }
#line 1927
    return ((opj_image_t *)((void *)0));
  }
#line 1930
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 1931
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 1932
  image->x1 = (OPJ_UINT32 )((parameters->image_offset_x0 + (w - 1) * subsampling_dx) + 1);
#line 1933
  image->y1 = (OPJ_UINT32 )((parameters->image_offset_y0 + (h - 1) * subsampling_dy) + 1);
#line 1935
  if (format == 2) {
    _L___47: 
#line 1939
    i = 0;
    {
#line 1939
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1939
      if (! (i < w * h)) {
#line 1939
        goto while_break___0;
      }
#line 1941
      compno = 0;
      {
#line 1941
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1941
        if (! (compno < numcomps)) {
#line 1941
          goto while_break___1;
        }
        {
#line 1943
        index___43 = 0U;
#line 1944
        __cil_tmp22 = fscanf(fp, "%u", & index___43);
        }
#line 1944
        if (__cil_tmp22 != 1) {
          {
#line 1945
          fprintf(stderr, "\nWARNING: fscanf return a number of element different from the expected.\n");
          }
        }
#line 1947
        *((image->comps + compno)->data + i) = (OPJ_INT32 )(index___43 * 255U) / header_info.maxval;
#line 1941
        compno ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___1: 
#line 1939
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___0: ;
  } else
#line 1935
  if (format == 3) {
#line 1935
    goto _L___47;
  } else
#line 1952
  if (format == 5) {
    _L: 
#line 1960
    one = (unsigned char )(prec < 9);
#line 1962
    i = 0;
    {
#line 1962
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 1962
      if (! (i < w * h)) {
#line 1962
        goto while_break___2;
      }
#line 1964
      compno = 0;
      {
#line 1964
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1964
        if (! (compno < numcomps)) {
#line 1964
          goto while_break___3;
        }
        {
#line 1966
        __cil_tmp28 = fread((void *)(& c0), 1UL, 1UL, fp);
        }
#line 1966
        if (! __cil_tmp28) {
          {
#line 1968
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 1969
          opj_image_destroy(image);
          }
#line 1970
          return ((opj_image_t *)((void *)0));
        }
#line 1972
        if (one) {
#line 1974
          *((image->comps + compno)->data + i) = (OPJ_INT32 )c0;
        } else {
          {
#line 1978
          __cil_tmp29 = fread((void *)(& c1), 1UL, 1UL, fp);
          }
#line 1978
          if (! __cil_tmp29) {
            {
#line 1979
            fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
            }
          }
#line 1981
          *((image->comps + compno)->data + i) = ((int )c0 << 8) | (int )c1;
        }
#line 1964
        compno ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___3: 
#line 1962
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___2: ;
  } else
#line 1952
  if (format == 6) {
#line 1952
    goto _L;
  } else
#line 1952
  if (format == 7) {
#line 1952
    if ((int )header_info.gray) {
#line 1952
      goto _L;
    } else
#line 1952
    if ((int )header_info.graya) {
#line 1952
      goto _L;
    } else
#line 1952
    if ((int )header_info.rgb) {
#line 1952
      goto _L;
    } else
#line 1952
    if ((int )header_info.rgba) {
#line 1952
      goto _L;
    } else {
#line 1952
      goto _L___45;
    }
  } else
  _L___45: 
#line 1987
  if (format == 1) {
#line 1989
    i = 0;
    {
#line 1989
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 1989
      if (! (i < w * h)) {
#line 1989
        goto while_break___4;
      }
      {
#line 1993
      __cil_tmp33 = fscanf(fp, "%u", & index___44);
      }
#line 1993
      if (__cil_tmp33 != 1) {
        {
#line 1994
        fprintf(stderr, "\nWARNING: fscanf return a number of element different from the expected.\n");
        }
      }
#line 1996
      if (index___44) {
#line 1996
        tmp = 0;
      } else {
#line 1996
        tmp = 255;
      }
#line 1996
      *((image->comps + 0)->data + i) = tmp;
#line 1989
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___4: ;
  } else
#line 2000
  if (format == 4) {
#line 2005
    i = 0;
#line 2006
    y = 0;
    {
#line 2006
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 2006
      if (! (y < h)) {
#line 2006
        goto while_break___5;
      }
#line 2008
      bit = -1;
#line 2008
      uc = (unsigned char)0;
#line 2010
      x = 0;
      {
#line 2010
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 2010
        if (! (x < w)) {
#line 2010
          goto while_break___6;
        }
#line 2012
        if (bit == -1) {
          {
#line 2014
          bit = 7;
#line 2015
          __cil_tmp40 = getc(fp);
#line 2015
          uc = (unsigned char )__cil_tmp40;
          }
        }
#line 2017
        if (((int )uc >> bit) & 1) {
#line 2017
          tmp___0 = 0;
        } else {
#line 2017
          tmp___0 = 255;
        }
#line 2017
        *((image->comps + 0)->data + i) = tmp___0;
#line 2018
        bit --;
#line 2018
        i ++;
#line 2010
        x ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___6: 
#line 2006
      y ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___5: ;
  } else
#line 2023
  if (format == 7) {
#line 2023
    if ((int )header_info.bw) {
#line 2027
      i = 0;
      {
#line 2027
      while (1) {
        while_continue___7: /* CIL Label */ ;

#line 2027
        if (! (i < w * h)) {
#line 2027
          goto while_break___7;
        }
        {
#line 2029
        __cil_tmp43 = fread((void *)(& uc___0), 1UL, 1UL, fp);
        }
#line 2029
        if (! __cil_tmp43) {
          {
#line 2030
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
          }
        }
#line 2031
        if ((int )uc___0 & 1) {
#line 2031
          tmp___1 = 0;
        } else {
#line 2031
          tmp___1 = 255;
        }
#line 2031
        *((image->comps + 0)->data + i) = tmp___1;
#line 2027
        i ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___7: ;
    }
  }
  {
#line 2034
  fclose(fp);
  }
#line 2036
  return (image);
}
}
#line 2039 "/root/patchweave_new/10/src/bin/jp2/convert.c"
int imagetopnm(opj_image_t *image , char const   *outfile ) 
{ 
  int *red ;
  int *green ;
  int *blue ;
  int *alpha ;
  int wr ;
  int hr ;
  int max ;
  int i ;
  unsigned int compno ;
  unsigned int ncomp ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int adjustA ;
  int fails ;
  int two ;
  int want_gray ;
  int has_alpha ;
  int triple ;
  int prec ;
  int v ;
  FILE *fdest ;
  char const   *tmp ;
  char *destname ;
  char const   *tt ;
  char const   *tmp___48 ;
  char const   *__cil_tmp30 ;
  int tmp___49 ;
  char const   *__cil_tmp32 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int *__cil_tmp36 ;
  int *__cil_tmp37 ;
  int *__cil_tmp38 ;
  int *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  void *__cil_tmp41 ;
  size_t olen ;
  unsigned long __cil_tmp43 ;
  size_t dotpos ;
  char const   *__cil_tmp46 ;
  int tmp___53 ;
  int *__cil_tmp48 ;
  int tmp___54 ;
  int tmp___55 ;

  {
#line 2048
  fdest = (FILE *)((void *)0);
#line 2049
  tmp = outfile;
#line 2052
  alpha = (int *)((void *)0);
#line 2054
  prec = (int )(image->comps + 0)->prec;
#line 2054
  if (prec > 16) {
    {
#line 2056
    fprintf(stderr, "%s:%d:imagetopnm\n\tprecision %d is larger than 16\n\t: refused.\n\265MlEV",
            "/root/patchweave_new/10/src/bin/jp2/convert.cV", 2057, prec);
    }
#line 2058
    return (1);
  }
#line 2060
  has_alpha = 0;
#line 2060
  two = has_alpha;
#line 2060
  fails = 1;
#line 2061
  ncomp = image->numcomps;
  {
#line 2063
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2063
    if (! *tmp) {
#line 2063
      goto while_break;
    }
#line 2063
    tmp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 2063
  tmp -= 2;
#line 2064
  if ((int )*tmp == 103) {
#line 2064
    tmp___54 = 1;
  } else
#line 2064
  if ((int )*tmp == 71) {
#line 2064
    tmp___54 = 1;
  } else {
#line 2064
    tmp___54 = 0;
  }
#line 2064
  want_gray = tmp___54;
#line 2065
  ncomp = image->numcomps;
#line 2067
  if (want_gray) {
#line 2067
    ncomp = 1U;
  }
#line 2069
  if (ncomp == 2U) {
    _L: 
    {
#line 2079
    fdest = fopen(outfile, "wbMlEV");
    }
#line 2081
    if (! fdest) {
      {
#line 2083
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
      }
#line 2084
      return (fails);
    }
#line 2086
    two = prec > 8;
#line 2087
    triple = ncomp > 2U;
#line 2088
    wr = (int )(image->comps + 0)->w;
#line 2088
    hr = (int )(image->comps + 0)->h;
#line 2089
    max = (1 << prec) - 1;
#line 2089
    if (ncomp == 4U) {
#line 2089
      tmp___55 = 1;
    } else
#line 2089
    if (ncomp == 2U) {
#line 2089
      tmp___55 = 1;
    } else {
#line 2089
      tmp___55 = 0;
    }
#line 2089
    has_alpha = tmp___55;
#line 2091
    red = (image->comps + 0)->data;
#line 2093
    if (triple) {
#line 2095
      green = (image->comps + 1)->data;
#line 2096
      blue = (image->comps + 2)->data;
    } else {
#line 2098
      blue = (int *)((void *)0);
#line 2098
      green = blue;
    }
#line 2100
    if (has_alpha) {
#line 2102
      if (triple) {
        {
#line 2102
        strcpy((char *)tmp___48, "RGB_ALPHA");
        }
      } else {
        {
#line 2102
        strcpy((char *)tmp___48, "GRAYSCALE_ALPHA");
        }
      }
      {
#line 2102
      tt = tmp___48;
#line 2104
      __cil_tmp30 = opj_version();
#line 2104
      fprintf(fdest, "P7\n# OpenJPEG-%s\nWIDTH %d\nHEIGHT %d\nDEPTH %d\nMAXVAL %d\nTUPLTYPE %s\nENDHDR\n",
              __cil_tmp30, wr, hr, ncomp, max, tt);
#line 2107
      alpha = (image->comps + (ncomp - 1U))->data;
      }
#line 2108
      if ((image->comps + (ncomp - 1U))->sgnd) {
#line 2108
        tmp___49 = 1 << ((image->comps + (ncomp - 1U))->prec - 1U);
      } else {
#line 2108
        tmp___49 = 0;
      }
#line 2108
      adjustA = tmp___49;
    } else {
      {
#line 2113
      __cil_tmp32 = opj_version();
#line 2113
      fprintf(fdest, "P6\n# OpenJPEG-%s\n%d %d\n%d\nMlEV", __cil_tmp32, wr, hr, max);
#line 2115
      adjustA = 0;
      }
    }
#line 2117
    if ((image->comps + 0)->sgnd) {
#line 2117
      tmp___50 = 1 << ((image->comps + 0)->prec - 1U);
    } else {
#line 2117
      tmp___50 = 0;
    }
#line 2117
    adjustR = tmp___50;
#line 2119
    if (triple) {
#line 2121
      if ((image->comps + 1)->sgnd) {
#line 2121
        tmp___51 = 1 << ((image->comps + 1)->prec - 1U);
      } else {
#line 2121
        tmp___51 = 0;
      }
#line 2121
      adjustG = tmp___51;
#line 2122
      if ((image->comps + 2)->sgnd) {
#line 2122
        tmp___52 = 1 << ((image->comps + 2)->prec - 1U);
      } else {
#line 2122
        tmp___52 = 0;
      }
#line 2122
      adjustB = tmp___52;
    } else {
#line 2124
      adjustB = 0;
#line 2124
      adjustG = adjustB;
    }
#line 2126
    i = 0;
    {
#line 2126
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue___0: ;
#line 2126
      if (! (i < wr * hr)) {
#line 2126
        goto while_break___0;
      }
#line 2128
      if (two) {
#line 2130
        v = *red + adjustR;
#line 2130
        red ++;
#line 2131
        if (v > 65535) {
#line 2131
          v = 65535;
        } else
#line 2131
        if (v < 0) {
#line 2131
          v = 0;
        }
        {
#line 2134
        fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
        }
#line 2136
        if (triple) {
#line 2138
          v = *green + adjustG;
#line 2138
          green ++;
#line 2139
          if (v > 65535) {
#line 2139
            v = 65535;
          } else
#line 2139
          if (v < 0) {
#line 2139
            v = 0;
          }
          {
#line 2142
          fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
#line 2144
          v = *blue + adjustB;
#line 2144
          blue ++;
          }
#line 2145
          if (v > 65535) {
#line 2145
            v = 65535;
          } else
#line 2145
          if (v < 0) {
#line 2145
            v = 0;
          }
          {
#line 2148
          fprintf(fdest, "%c%cEV", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 2152
        if (has_alpha) {
#line 2154
          v = *alpha + adjustA;
#line 2154
          alpha ++;
#line 2155
          if (v > 65535) {
#line 2155
            v = 65535;
          } else
#line 2155
          if (v < 0) {
#line 2155
            v = 0;
          }
          {
#line 2158
          fprintf(fdest, "%c%cEV", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 2160
        goto while_continue___0;
      }
#line 2165
      __cil_tmp36 = red;
#line 2165
      red ++;
#line 2165
      v = *__cil_tmp36;
#line 2166
      if (v > 255) {
#line 2166
        v = 255;
      } else
#line 2166
      if (v < 0) {
#line 2166
        v = 0;
      }
      {
#line 2168
      fprintf(fdest, "%c", (int )((unsigned char )v));
      }
#line 2169
      if (triple) {
#line 2171
        __cil_tmp37 = green;
#line 2171
        green ++;
#line 2171
        v = *__cil_tmp37;
#line 2172
        if (v > 255) {
#line 2172
          v = 255;
        } else
#line 2172
        if (v < 0) {
#line 2172
          v = 0;
        }
        {
#line 2174
        fprintf(fdest, "%cMlEV", (int )((unsigned char )v));
#line 2175
        __cil_tmp38 = blue;
#line 2175
        blue ++;
#line 2175
        v = *__cil_tmp38;
        }
#line 2176
        if (v > 255) {
#line 2176
          v = 255;
        } else
#line 2176
        if (v < 0) {
#line 2176
          v = 0;
        }
        {
#line 2178
        fprintf(fdest, "%cMlEV", (int )((unsigned char )v));
        }
      }
#line 2180
      if (has_alpha) {
#line 2182
        __cil_tmp39 = alpha;
#line 2182
        alpha ++;
#line 2182
        v = *__cil_tmp39;
#line 2183
        if (v > 255) {
#line 2183
          v = 255;
        } else
#line 2183
        if (v < 0) {
#line 2183
          v = 0;
        }
        {
#line 2185
        fprintf(fdest, "%c", (int )((unsigned char )v));
        }
      }
#line 2126
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 2189
    fclose(fdest);
    }
#line 2189
    return (0);
  } else
#line 2069
  if (ncomp > 2U) {
#line 2069
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 2069
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 2069
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 2069
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 2069
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 2069
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
#line 2069
                goto _L;
              }
            }
          }
        }
      }
    }
  }
#line 2194
  if (image->numcomps > ncomp) {
    {
#line 2196
    fprintf(stderr, "WARNING -> [PGM file] Only the first component\n");
#line 2197
    fprintf(stderr, "           is written to the file\nMlEV");
    }
  }
  {
#line 2199
  __cil_tmp40 = strlen(outfile);
#line 2199
  __cil_tmp41 = malloc(__cil_tmp40 + 8UL);
#line 2199
  destname = (char *)__cil_tmp41;
#line 2201
  compno = 0U;
  }
  {
#line 2201
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 2201
    if (! (compno < ncomp)) {
#line 2201
      goto while_break___1;
    }
#line 2203
    if (ncomp > 1U) {
      {
#line 2206
      __cil_tmp43 = strlen(outfile);
#line 2206
      olen = __cil_tmp43;
#line 2207
      dotpos = olen - 4UL;
#line 2209
      strncpy(destname, outfile, dotpos);
#line 2210
      sprintf(destname + dotpos, "_%d.pgm", compno);
      }
    } else {
      {
#line 2213
      sprintf(destname, "%s", outfile);
      }
    }
    {
#line 2215
    fdest = fopen((char const   *)destname, "wb");
    }
#line 2216
    if (! fdest) {
      {
#line 2218
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", destname);
#line 2219
      free((void *)destname);
      }
#line 2220
      return (1);
    }
    {
#line 2222
    wr = (int )(image->comps + compno)->w;
#line 2222
    hr = (int )(image->comps + compno)->h;
#line 2223
    prec = (int )(image->comps + compno)->prec;
#line 2224
    max = (1 << prec) - 1;
#line 2226
    __cil_tmp46 = opj_version();
#line 2226
    fprintf(fdest, "P5\n#OpenJPEG-%s\n%d %d\n%d\n", __cil_tmp46, wr, hr, max);
#line 2229
    red = (image->comps + compno)->data;
    }
#line 2230
    if ((image->comps + compno)->sgnd) {
#line 2230
      tmp___53 = 1 << ((image->comps + compno)->prec - 1U);
    } else {
#line 2230
      tmp___53 = 0;
    }
#line 2230
    adjustR = tmp___53;
#line 2233
    if (prec > 8) {
#line 2235
      i = 0;
      {
#line 2235
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 2235
        if (! (i < wr * hr)) {
#line 2235
          goto while_break___2;
        }
#line 2237
        v = *red + adjustR;
#line 2237
        red ++;
#line 2238
        if (v > 65535) {
#line 2238
          v = 65535;
        } else
#line 2238
        if (v < 0) {
#line 2238
          v = 0;
        }
        {
#line 2241
        fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
        }
#line 2243
        if (has_alpha) {
#line 2245
          __cil_tmp48 = alpha;
#line 2245
          alpha ++;
#line 2245
          v = *__cil_tmp48;
#line 2246
          if (v > 65535) {
#line 2246
            v = 65535;
          } else
#line 2246
          if (v < 0) {
#line 2246
            v = 0;
          }
          {
#line 2249
          fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 2235
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: ;
    } else {
#line 2255
      i = 0;
      {
#line 2255
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 2255
        if (! (i < wr * hr)) {
#line 2255
          goto while_break___3;
        }
#line 2257
        v = *red + adjustR;
#line 2257
        red ++;
#line 2258
        if (v > 255) {
#line 2258
          v = 255;
        } else
#line 2258
        if (v < 0) {
#line 2258
          v = 0;
        }
        {
#line 2260
        fprintf(fdest, "%c", (int )((unsigned char )v));
#line 2255
        i ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: ;
    }
    {
#line 2263
    fclose(fdest);
#line 2201
    compno ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 2265
  free((void *)destname);
  }
#line 2267
  return (0);
}
}
#line 2277 "/root/patchweave_new/10/src/bin/jp2/convert.c"
int imagetotif(opj_image_t *image , char const   *outfile ) 
{ 
  int width ;
  int height ;
  int imgsize ;
  int bps ;
  int index___54 ;
  int adjust ;
  int sgnd ;
  int ushift ;
  int dshift ;
  int has_alpha ;
  int force16 ;
  TIFF *tif ;
  tdata_t buf ;
  tstrip_t strip ;
  tsize_t strip_size ;
  int tmp ;
  uint32 __cil_tmp22 ;
  unsigned char *dat8 ;
  tsize_t i ;
  tsize_t ssize ;
  tsize_t last_i ;
  int step ;
  int restx ;
  int r ;
  int g ;
  int b ;
  int a ;
  int r___0 ;
  int g___0 ;
  int b___0 ;
  int a___0 ;
  int r___1 ;
  int g___1 ;
  int b___1 ;
  int a___1 ;
  int r___2 ;
  int g___2 ;
  int b___2 ;
  int a___2 ;
  int step___0 ;
  uint32 __cil_tmp54 ;
  unsigned char *dat8___0 ;
  tsize_t i___0 ;
  tsize_t ssize___0 ;
  tmsize_t __cil_tmp58 ;
  int r___3 ;
  int a___3 ;
  int r___4 ;
  int a___4 ;

  {
#line 2287
  has_alpha = 0;
#line 2287
  force16 = has_alpha;
#line 2287
  dshift = force16;
#line 2287
  ushift = dshift;
#line 2288
  bps = (int )(image->comps + 0)->prec;
#line 2290
  if (bps > 8) {
#line 2290
    if (bps < 16) {
#line 2292
      ushift = 16 - bps;
#line 2292
      dshift = bps - ushift;
#line 2293
      bps = 16;
#line 2293
      force16 = 1;
    }
  }
#line 2296
  if (bps != 8) {
#line 2296
    if (bps != 16) {
      {
#line 2298
      fprintf(stderr, "imagetotif: Bits=%d, Only 8 and 16 bits implemented\nEV", bps);
#line 2300
      fprintf(stderr, "\tAborting\nNlEV");
      }
#line 2301
      return (1);
    }
  }
  {
#line 2303
  tif = TIFFOpen(outfile, "wb");
  }
#line 2305
  if (! tif) {
    {
#line 2307
    fprintf(stderr, "imagetotif:failed to open %s for writing\n|NlEV", outfile);
    }
#line 2308
    return (1);
  }
#line 2310
  sgnd = (int )(image->comps + 0)->sgnd;
#line 2311
  if (sgnd) {
#line 2311
    tmp = 1 << ((image->comps + 0)->prec - 1U);
  } else {
#line 2311
    tmp = 0;
  }
#line 2311
  adjust = tmp;
#line 2313
  if (image->numcomps >= 3U) {
#line 2313
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 2313
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 2313
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 2313
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 2313
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 2313
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
                {
#line 2321
                has_alpha = image->numcomps == 4U;
#line 2323
                width = (int )(image->comps + 0)->w;
#line 2324
                height = (int )(image->comps + 0)->h;
#line 2325
                imgsize = width * height;
#line 2327
                TIFFSetField(tif, (uint32 )256, width);
#line 2328
                TIFFSetField(tif, (uint32 )257, height);
#line 2329
                TIFFSetField(tif, (uint32 )277, 3 + has_alpha);
#line 2330
                TIFFSetField(tif, (uint32 )258, bps);
#line 2331
                TIFFSetField(tif, (uint32 )274, 1);
#line 2332
                TIFFSetField(tif, (uint32 )284, 1);
#line 2333
                TIFFSetField(tif, (uint32 )262, 2);
#line 2334
                TIFFSetField(tif, (uint32 )278, 1);
#line 2335
                strip_size = TIFFStripSize(tif);
#line 2336
                buf = _TIFFmalloc(strip_size);
#line 2337
                index___54 = 0;
#line 2339
                strip = (tstrip_t )0;
                }
                {
#line 2339
                while (1) {
                  while_continue: /* CIL Label */ ;

#line 2339
                  if (! (strip < __cil_tmp22)) {
#line 2339
                    goto while_break;
                  }
                  {
#line 2342
                  last_i = (tsize_t )0;
#line 2344
                  ssize = TIFFStripSize(tif);
#line 2345
                  dat8 = (unsigned char *)buf;
                  }
#line 2347
                  if (bps == 8) {
#line 2349
                    step = 3 + has_alpha;
#line 2350
                    restx = step - 1;
#line 2352
                    i = (tsize_t )0;
                    {
#line 2352
                    while (1) {
                      while_continue___0: /* CIL Label */ ;

#line 2352
                      if (! (i < ssize - (long )restx)) {
#line 2352
                        goto while_break___0;
                      }
#line 2354
                      a = 0;
#line 2356
                      if (index___54 < imgsize) {
#line 2358
                        r = *((image->comps + 0)->data + index___54);
#line 2359
                        g = *((image->comps + 1)->data + index___54);
#line 2360
                        b = *((image->comps + 2)->data + index___54);
#line 2361
                        if (has_alpha) {
#line 2361
                          a = *((image->comps + 3)->data + index___54);
                        }
#line 2363
                        if (sgnd) {
#line 2365
                          r += adjust;
#line 2366
                          g += adjust;
#line 2367
                          b += adjust;
#line 2368
                          if (has_alpha) {
#line 2368
                            a += adjust;
                          }
                        }
#line 2370
                        if (r > 255) {
#line 2370
                          r = 255;
                        } else
#line 2370
                        if (r < 0) {
#line 2370
                          r = 0;
                        }
#line 2371
                        *(dat8 + i) = (unsigned char )r;
#line 2372
                        if (g > 255) {
#line 2372
                          g = 255;
                        } else
#line 2372
                        if (g < 0) {
#line 2372
                          g = 0;
                        }
#line 2373
                        *(dat8 + (i + 1L)) = (unsigned char )g;
#line 2374
                        if (b > 255) {
#line 2374
                          b = 255;
                        } else
#line 2374
                        if (b < 0) {
#line 2374
                          b = 0;
                        }
#line 2375
                        *(dat8 + (i + 2L)) = (unsigned char )b;
#line 2376
                        if (has_alpha) {
#line 2378
                          if (a > 255) {
#line 2378
                            a = 255;
                          } else
#line 2378
                          if (a < 0) {
#line 2378
                            a = 0;
                          }
#line 2379
                          *(dat8 + (i + 3L)) = (unsigned char )a;
                        }
#line 2382
                        index___54 ++;
#line 2383
                        last_i = i + (long )step;
                      } else {
#line 2386
                        goto while_break___0;
                      }
#line 2352
                      i += (long )step;
                    }
                    while_break___8: /* CIL Label */ ;
                    }
                    while_break___0: ;
#line 2389
                    if (last_i < ssize) {
#line 2391
                      i = last_i;
                      {
#line 2391
                      while (1) {
                        while_continue___1: /* CIL Label */ ;

#line 2391
                        if (! (i < ssize)) {
#line 2391
                          goto while_break___1;
                        }
#line 2393
                        a___0 = 0;
#line 2395
                        if (index___54 < imgsize) {
#line 2397
                          r___0 = *((image->comps + 0)->data + index___54);
#line 2398
                          g___0 = *((image->comps + 1)->data + index___54);
#line 2399
                          b___0 = *((image->comps + 2)->data + index___54);
#line 2400
                          if (has_alpha) {
#line 2400
                            a___0 = *((image->comps + 3)->data + index___54);
                          }
#line 2402
                          if (sgnd) {
#line 2404
                            r___0 += adjust;
#line 2405
                            g___0 += adjust;
#line 2406
                            b___0 += adjust;
#line 2407
                            if (has_alpha) {
#line 2407
                              a___0 += adjust;
                            }
                          }
#line 2409
                          if (r___0 > 255) {
#line 2409
                            r___0 = 255;
                          } else
#line 2409
                          if (r___0 < 0) {
#line 2409
                            r___0 = 0;
                          }
#line 2410
                          if (g___0 > 255) {
#line 2410
                            g___0 = 255;
                          } else
#line 2410
                          if (g___0 < 0) {
#line 2410
                            g___0 = 0;
                          }
#line 2411
                          if (b___0 > 255) {
#line 2411
                            b___0 = 255;
                          } else
#line 2411
                          if (b___0 < 0) {
#line 2411
                            b___0 = 0;
                          }
#line 2413
                          *(dat8 + i) = (unsigned char )r___0;
#line 2414
                          if (i + 1L < ssize) {
#line 2414
                            *(dat8 + (i + 1L)) = (unsigned char )g___0;
                          } else {
#line 2414
                            goto while_break___1;
                          }
#line 2415
                          if (i + 2L < ssize) {
#line 2415
                            *(dat8 + (i + 2L)) = (unsigned char )b___0;
                          } else {
#line 2415
                            goto while_break___1;
                          }
#line 2416
                          if (has_alpha) {
#line 2418
                            if (a___0 > 255) {
#line 2418
                              a___0 = 255;
                            } else
#line 2418
                            if (a___0 < 0) {
#line 2418
                              a___0 = 0;
                            }
#line 2420
                            if (i + 3L < ssize) {
#line 2420
                              *(dat8 + (i + 3L)) = (unsigned char )a___0;
                            } else {
#line 2420
                              goto while_break___1;
                            }
                          }
#line 2422
                          index___54 ++;
                        } else {
#line 2425
                          goto while_break___1;
                        }
#line 2391
                        i += (long )step;
                      }
                      while_break___9: /* CIL Label */ ;
                      }
                      while_break___1: ;
                    }
                  } else
#line 2431
                  if (bps == 16) {
#line 2433
                    step = (6 + has_alpha) + has_alpha;
#line 2434
                    restx = step - 1;
#line 2436
                    i = (tsize_t )0;
                    {
#line 2436
                    while (1) {
                      while_continue___2: /* CIL Label */ ;

#line 2436
                      if (! (i < ssize - (long )restx)) {
#line 2436
                        goto while_break___2;
                      }
#line 2438
                      a___1 = 0;
#line 2440
                      if (index___54 < imgsize) {
#line 2442
                        r___1 = *((image->comps + 0)->data + index___54);
#line 2443
                        g___1 = *((image->comps + 1)->data + index___54);
#line 2444
                        b___1 = *((image->comps + 2)->data + index___54);
#line 2445
                        if (has_alpha) {
#line 2445
                          a___1 = *((image->comps + 3)->data + index___54);
                        }
#line 2447
                        if (sgnd) {
#line 2449
                          r___1 += adjust;
#line 2450
                          g___1 += adjust;
#line 2451
                          b___1 += adjust;
#line 2452
                          if (has_alpha) {
#line 2452
                            a___1 += adjust;
                          }
                        }
#line 2454
                        if (force16) {
#line 2456
                          r___1 = (r___1 << ushift) + (r___1 >> dshift);
#line 2457
                          g___1 = (g___1 << ushift) + (g___1 >> dshift);
#line 2458
                          b___1 = (b___1 << ushift) + (b___1 >> dshift);
#line 2459
                          if (has_alpha) {
#line 2459
                            a___1 = (a___1 << ushift) + (a___1 >> dshift);
                          }
                        }
#line 2461
                        if (r___1 > 65535) {
#line 2461
                          r___1 = 65535;
                        } else
#line 2461
                        if (r___1 < 0) {
#line 2461
                          r___1 = 0;
                        }
#line 2462
                        if (g___1 > 65535) {
#line 2462
                          g___1 = 65535;
                        } else
#line 2462
                        if (g___1 < 0) {
#line 2462
                          g___1 = 0;
                        }
#line 2463
                        if (b___1 > 65535) {
#line 2463
                          b___1 = 65535;
                        } else
#line 2463
                        if (b___1 < 0) {
#line 2463
                          b___1 = 0;
                        }
#line 2465
                        *(dat8 + i) = (unsigned char )r___1;
#line 2466
                        *(dat8 + (i + 1L)) = (unsigned char )(r___1 >> 8);
#line 2467
                        *(dat8 + (i + 2L)) = (unsigned char )g___1;
#line 2468
                        *(dat8 + (i + 3L)) = (unsigned char )(g___1 >> 8);
#line 2469
                        *(dat8 + (i + 4L)) = (unsigned char )b___1;
#line 2470
                        *(dat8 + (i + 5L)) = (unsigned char )(b___1 >> 8);
#line 2471
                        if (has_alpha) {
#line 2473
                          if (a___1 > 65535) {
#line 2473
                            a___1 = 65535;
                          } else
#line 2473
                          if (a___1 < 0) {
#line 2473
                            a___1 = 0;
                          }
#line 2474
                          *(dat8 + (i + 6L)) = (unsigned char )a___1;
#line 2475
                          *(dat8 + (i + 7L)) = (unsigned char )(a___1 >> 8);
                        }
#line 2477
                        index___54 ++;
#line 2478
                        last_i = i + (long )step;
                      } else {
#line 2481
                        goto while_break___2;
                      }
#line 2436
                      i += (long )step;
                    }
                    while_break___10: /* CIL Label */ ;
                    }
                    while_break___2: ;
#line 2484
                    if (last_i < ssize) {
#line 2486
                      i = last_i;
                      {
#line 2486
                      while (1) {
                        while_continue___3: /* CIL Label */ ;

#line 2486
                        if (! (i < ssize)) {
#line 2486
                          goto while_break___3;
                        }
#line 2488
                        a___2 = 0;
#line 2490
                        if (index___54 < imgsize) {
#line 2492
                          r___2 = *((image->comps + 0)->data + index___54);
#line 2493
                          g___2 = *((image->comps + 1)->data + index___54);
#line 2494
                          b___2 = *((image->comps + 2)->data + index___54);
#line 2495
                          if (has_alpha) {
#line 2495
                            a___2 = *((image->comps + 3)->data + index___54);
                          }
#line 2497
                          if (sgnd) {
#line 2499
                            r___2 += adjust;
#line 2500
                            g___2 += adjust;
#line 2501
                            b___2 += adjust;
#line 2502
                            if (has_alpha) {
#line 2502
                              a___2 += adjust;
                            }
                          }
#line 2504
                          if (force16) {
#line 2506
                            r___2 = (r___2 << ushift) + (r___2 >> dshift);
#line 2507
                            g___2 = (g___2 << ushift) + (g___2 >> dshift);
#line 2508
                            b___2 = (b___2 << ushift) + (b___2 >> dshift);
#line 2509
                            if (has_alpha) {
#line 2509
                              a___2 = (a___2 << ushift) + (a___2 >> dshift);
                            }
                          }
#line 2511
                          if (r___2 > 65535) {
#line 2511
                            r___2 = 65535;
                          } else
#line 2511
                          if (r___2 < 0) {
#line 2511
                            r___2 = 0;
                          }
#line 2512
                          if (g___2 > 65535) {
#line 2512
                            g___2 = 65535;
                          } else
#line 2512
                          if (g___2 < 0) {
#line 2512
                            g___2 = 0;
                          }
#line 2513
                          if (b___2 > 65535) {
#line 2513
                            b___2 = 65535;
                          } else
#line 2513
                          if (b___2 < 0) {
#line 2513
                            b___2 = 0;
                          }
#line 2515
                          *(dat8 + i) = (unsigned char )r___2;
#line 2516
                          if (i + 1L < ssize) {
#line 2516
                            *(dat8 + (i + 1L)) = (unsigned char )(r___2 >> 8);
                          } else {
#line 2516
                            goto while_break___3;
                          }
#line 2517
                          if (i + 2L < ssize) {
#line 2517
                            *(dat8 + (i + 2L)) = (unsigned char )g___2;
                          } else {
#line 2517
                            goto while_break___3;
                          }
#line 2518
                          if (i + 3L < ssize) {
#line 2518
                            *(dat8 + (i + 3L)) = (unsigned char )(g___2 >> 8);
                          } else {
#line 2518
                            goto while_break___3;
                          }
#line 2519
                          if (i + 4L < ssize) {
#line 2519
                            *(dat8 + (i + 4L)) = (unsigned char )b___2;
                          } else {
#line 2519
                            goto while_break___3;
                          }
#line 2520
                          if (i + 5L < ssize) {
#line 2520
                            *(dat8 + (i + 5L)) = (unsigned char )(b___2 >> 8);
                          } else {
#line 2520
                            goto while_break___3;
                          }
#line 2522
                          if (has_alpha) {
#line 2524
                            if (a___2 > 65535) {
#line 2524
                              a___2 = 65535;
                            } else
#line 2524
                            if (a___2 < 0) {
#line 2524
                              a___2 = 0;
                            }
#line 2525
                            if (i + 6L < ssize) {
#line 2525
                              *(dat8 + (i + 6L)) = (unsigned char )a___2;
                            } else {
#line 2525
                              goto while_break___3;
                            }
#line 2526
                            if (i + 7L < ssize) {
#line 2526
                              *(dat8 + (i + 7L)) = (unsigned char )(a___2 >> 8);
                            } else {
#line 2526
                              goto while_break___3;
                            }
                          }
#line 2528
                          index___54 ++;
                        } else {
#line 2531
                          goto while_break___3;
                        }
#line 2486
                        i += (long )step;
                      }
                      while_break___11: /* CIL Label */ ;
                      }
                      while_break___3: ;
                    }
                  }
                  {
#line 2536
                  TIFFWriteEncodedStrip(tif, strip, buf, strip_size);
#line 2339
                  strip ++;
                  }
                }
                while_break___7: /* CIL Label */ ;
                }
                while_break: 
                {
#line 2539
                _TIFFfree(buf);
#line 2540
                TIFFClose(tif);
                }
#line 2542
                return (0);
              }
            }
          }
        }
      }
    }
  }
#line 2545
  if (image->numcomps == 1U) {
    _L: 
    {
#line 2553
    has_alpha = image->numcomps == 2U;
#line 2555
    width = (int )(image->comps + 0)->w;
#line 2556
    height = (int )(image->comps + 0)->h;
#line 2557
    imgsize = width * height;
#line 2560
    TIFFSetField(tif, (uint32 )256, width);
#line 2561
    TIFFSetField(tif, (uint32 )257, height);
#line 2562
    TIFFSetField(tif, (uint32 )277, 1 + has_alpha);
#line 2563
    TIFFSetField(tif, (uint32 )258, bps);
#line 2564
    TIFFSetField(tif, (uint32 )274, 1);
#line 2565
    TIFFSetField(tif, (uint32 )284, 1);
#line 2566
    TIFFSetField(tif, (uint32 )262, 1);
#line 2567
    TIFFSetField(tif, (uint32 )278, 1);
#line 2570
    strip_size = TIFFStripSize(tif);
#line 2571
    buf = _TIFFmalloc(strip_size);
#line 2572
    index___54 = 0;
#line 2574
    strip = (tstrip_t )0;
    }
    {
#line 2574
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 2574
      if (! (strip < __cil_tmp54)) {
#line 2574
        goto while_break___4;
      }
      {
#line 2577
      __cil_tmp58 = TIFFStripSize(tif);
#line 2577
      ssize___0 = __cil_tmp58;
#line 2578
      dat8___0 = (unsigned char *)buf;
      }
#line 2580
      if (bps == 8) {
#line 2582
        step___0 = 1 + has_alpha;
#line 2584
        i___0 = (tsize_t )0;
        {
#line 2584
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 2584
          if (! (i___0 < ssize___0)) {
#line 2584
            goto while_break___5;
          }
#line 2586
          if (index___54 < imgsize) {
#line 2588
            a___3 = 0;
#line 2590
            r___3 = *((image->comps + 0)->data + index___54);
#line 2591
            if (has_alpha) {
#line 2591
              a___3 = *((image->comps + 1)->data + index___54);
            }
#line 2593
            if (sgnd) {
#line 2595
              r___3 += adjust;
#line 2596
              if (has_alpha) {
#line 2596
                a___3 += adjust;
              }
            }
#line 2598
            if (r___3 > 255) {
#line 2598
              r___3 = 255;
            } else
#line 2598
            if (r___3 < 0) {
#line 2598
              r___3 = 0;
            }
#line 2599
            *(dat8___0 + i___0) = (unsigned char )r___3;
#line 2601
            if (has_alpha) {
#line 2603
              if (a___3 > 255) {
#line 2603
                a___3 = 255;
              } else
#line 2603
              if (a___3 < 0) {
#line 2603
                a___3 = 0;
              }
#line 2604
              *(dat8___0 + (i___0 + 1L)) = (unsigned char )a___3;
            }
#line 2606
            index___54 ++;
          } else {
#line 2609
            goto while_break___5;
          }
#line 2584
          i___0 += (long )step___0;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: ;
      } else
#line 2613
      if (bps == 16) {
#line 2615
        step___0 = (2 + has_alpha) + has_alpha;
#line 2617
        i___0 = (tsize_t )0;
        {
#line 2617
        while (1) {
          while_continue___6: /* CIL Label */ ;

#line 2617
          if (! (i___0 < ssize___0)) {
#line 2617
            goto while_break___6;
          }
#line 2619
          if (index___54 < imgsize) {
#line 2621
            a___4 = 0;
#line 2623
            r___4 = *((image->comps + 0)->data + index___54);
#line 2624
            if (has_alpha) {
#line 2624
              a___4 = *((image->comps + 1)->data + index___54);
            }
#line 2626
            if (sgnd) {
#line 2628
              r___4 += adjust;
#line 2629
              if (has_alpha) {
#line 2629
                a___4 += adjust;
              }
            }
#line 2631
            if (force16) {
#line 2633
              r___4 = (r___4 << ushift) + (r___4 >> dshift);
#line 2634
              if (has_alpha) {
#line 2634
                a___4 = (a___4 << ushift) + (a___4 >> dshift);
              }
            }
#line 2636
            if (r___4 > 65535) {
#line 2636
              r___4 = 65535;
            } else
#line 2636
            if (r___4 < 0) {
#line 2636
              r___4 = 0;
            }
#line 2637
            *(dat8___0 + i___0) = (unsigned char )r___4;
#line 2638
            *(dat8___0 + (i___0 + 1L)) = (unsigned char )(r___4 >> 8);
#line 2639
            if (has_alpha) {
#line 2641
              if (a___4 > 65535) {
#line 2641
                a___4 = 65535;
              } else
#line 2641
              if (a___4 < 0) {
#line 2641
                a___4 = 0;
              }
#line 2642
              *(dat8___0 + (i___0 + 2L)) = (unsigned char )a___4;
#line 2643
              *(dat8___0 + (i___0 + 3L)) = (unsigned char )(a___4 >> 8);
            }
#line 2645
            index___54 ++;
          } else {
#line 2648
            goto while_break___6;
          }
#line 2617
          i___0 += (long )step___0;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: ;
      }
      {
#line 2651
      TIFFWriteEncodedStrip(tif, strip, buf, strip_size);
#line 2574
      strip ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___4: 
    {
#line 2654
    _TIFFfree(buf);
#line 2655
    TIFFClose(tif);
    }
#line 2657
    return (0);
  } else
#line 2545
  if (image->numcomps == 2U) {
#line 2545
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 2545
      if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 2545
        if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 2545
          goto _L;
        }
      }
    }
  }
  {
#line 2660
  TIFFClose(tif);
#line 2662
  fprintf(stderr, "imagetotif: Bad color format.\n\tOnly RGB(A) and GRAY(A) has been implemented\n\220");
#line 2664
  fprintf(stderr, "\tFOUND: numcomps(%d)\n\tAborting\n", image->numcomps);
  }
#line 2667
  return (1);
}
}
#line 2674 "/root/patchweave_new/10/src/bin/jp2/convert.c"
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  TIFF *tif ;
  tdata_t buf ;
  tstrip_t strip ;
  tsize_t strip_size ;
  int j ;
  int numcomps ;
  int w ;
  int h ;
  int index___55 ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[4] ;
  opj_image_t *image ;
  int imgsize ;
  int has_alpha ;
  unsigned short tiBps ;
  unsigned short tiPhoto ;
  unsigned short tiSf ;
  unsigned short tiSpp ;
  unsigned short tiPC ;
  unsigned int tiWidth ;
  unsigned int tiHeight ;
  OPJ_BOOL is_cinema ;
  uint16 *sampleinfo ;
  uint16 extrasamples ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 tmp___0 ;
  tmsize_t __cil_tmp34 ;
  void *__cil_tmp35 ;
  uint32 __cil_tmp37 ;
  unsigned char *dat8 ;
  int step ;
  tsize_t i ;
  tsize_t ssize ;
  OPJ_UINT32 tmp___1 ;
  OPJ_UINT32 tmp___2 ;
  tmsize_t __cil_tmp49 ;
  void *__cil_tmp50 ;
  uint32 __cil_tmp52 ;
  unsigned char *dat8___0 ;
  tsize_t i___0 ;
  tsize_t ssize___0 ;
  int step___0 ;
  int tmp___3 ;

  {
#line 2676
  subsampling_dx = parameters->subsampling_dx;
#line 2677
  subsampling_dy = parameters->subsampling_dy;
#line 2685
  image = (opj_image_t *)((void *)0);
#line 2686
  imgsize = 0;
#line 2687
  has_alpha = 0;
#line 2690
  if ((int )parameters->rsiz >= 3) {
#line 2690
    if ((int )parameters->rsiz <= 6) {
#line 2690
      tmp___3 = 1;
    } else {
#line 2690
      tmp___3 = 0;
    }
  } else {
#line 2690
    tmp___3 = 0;
  }
  {
#line 2690
  is_cinema = tmp___3;
#line 2692
  tif = TIFFOpen(filename, "r");
  }
#line 2694
  if (! tif) {
    {
#line 2696
    fprintf(stderr, "tiftoimage:Failed to open %s for reading\n", filename);
    }
#line 2697
    return ((opj_image_t *)0);
  }
  {
#line 2699
  tiPC = (unsigned short)0;
#line 2699
  tiSpp = tiPC;
#line 2699
  tiSf = tiSpp;
#line 2699
  tiPhoto = tiSf;
#line 2699
  tiBps = tiPhoto;
#line 2700
  tiHeight = 0U;
#line 2700
  tiWidth = tiHeight;
#line 2702
  TIFFGetField(tif, (uint32 )256, & tiWidth);
#line 2703
  TIFFGetField(tif, (uint32 )257, & tiHeight);
#line 2704
  TIFFGetField(tif, (uint32 )258, & tiBps);
#line 2705
  TIFFGetField(tif, (uint32 )339, & tiSf);
#line 2706
  TIFFGetField(tif, (uint32 )277, & tiSpp);
#line 2707
  TIFFGetField(tif, (uint32 )262, & tiPhoto);
#line 2708
  TIFFGetField(tif, (uint32 )284, & tiPC);
#line 2709
  w = (int )tiWidth;
#line 2710
  h = (int )tiHeight;
  }
#line 2712
  if ((int )tiBps != 8) {
#line 2712
    if ((int )tiBps != 16) {
#line 2712
      if ((int )tiBps != 12) {
#line 2712
        tiBps = (unsigned short)0;
      }
    }
  }
#line 2713
  if ((int )tiPhoto != 1) {
#line 2713
    if ((int )tiPhoto != 2) {
#line 2713
      tiPhoto = (unsigned short)0;
    }
  }
#line 2715
  if (! tiBps) {
    _L: 
#line 2717
    if (! tiBps) {
      {
#line 2718
      fprintf(stderr, "tiftoimage: Bits=%d, Only 8 and 16 bits implemented\n\230\001",
              (int )tiBps);
      }
    } else
#line 2721
    if (! tiPhoto) {
      {
#line 2722
      fprintf(stderr, "tiftoimage: Bad color format %d.\n\tOnly RGB(A) and GRAY(A) has been implemented\n",
              (int )tiPhoto);
      }
    }
    {
#line 2725
    fprintf(stderr, "\tAborting\nOlEV");
#line 2726
    TIFFClose(tif);
    }
#line 2728
    return ((opj_image_t *)((void *)0));
  } else
#line 2715
  if (! tiPhoto) {
#line 2715
    goto _L;
  }
  {
#line 2735
  TIFFGetFieldDefaulted(tif, (uint32 )338, & extrasamples, & sampleinfo);
  }
#line 2738
  if ((int )extrasamples >= 1) {
#line 2742
    if ((int )*(sampleinfo + 0) == 0) {
#line 2742
      goto case_0;
    }
#line 2750
    if ((int )*(sampleinfo + 0) == 2) {
#line 2750
      goto case_2;
    }
#line 2750
    if ((int )*(sampleinfo + 0) == 1) {
#line 2750
      goto case_2;
    }
#line 2740
    goto switch_break;
    case_0: 
#line 2745
    if ((int )tiSpp > 3) {
#line 2746
      has_alpha = 1;
    }
#line 2747
    goto switch_break;
    case_2: 
#line 2751
    has_alpha = 1;
#line 2752
    goto switch_break;
    switch_break: ;
  } else
#line 2756
  if ((int )tiSpp == 4) {
#line 2756
    has_alpha = 1;
  } else
#line 2756
  if ((int )tiSpp == 2) {
#line 2756
    has_alpha = 1;
  }
  {
#line 2761
  memset((void *)(& cmptparm[0]), 0, 4UL * sizeof(opj_image_cmptparm_t ));
  }
#line 2763
  if ((int )tiPhoto == 2) {
#line 2763
    if (is_cinema) {
      {
#line 2764
      fprintf(stdout, "WARNING:\nInput image bitdepth is %d bits\nTIF conversion has automatically rescaled to 12-bits\nto comply with cinema profiles.\nPlEV",
              (int )tiBps);
      }
    }
  }
#line 2771
  if ((int )tiPhoto == 2) {
#line 2773
    numcomps = 3 + has_alpha;
#line 2774
    color_space = (OPJ_COLOR_SPACE )1;
#line 2777
    j = 0;
    {
#line 2777
    while (1) {
      while_continue: /* CIL Label */ ;

#line 2777
      if (! (j < numcomps)) {
#line 2777
        goto while_break;
      }
#line 2779
      if (is_cinema) {
#line 2781
        cmptparm[j].prec = (OPJ_UINT32 )12;
#line 2782
        cmptparm[j].bpp = (OPJ_UINT32 )12;
      } else {
#line 2786
        cmptparm[j].prec = (OPJ_UINT32 )tiBps;
#line 2787
        cmptparm[j].bpp = (OPJ_UINT32 )tiBps;
      }
#line 2789
      cmptparm[j].dx = (OPJ_UINT32 )subsampling_dx;
#line 2790
      cmptparm[j].dy = (OPJ_UINT32 )subsampling_dy;
#line 2791
      cmptparm[j].w = (OPJ_UINT32 )w;
#line 2792
      cmptparm[j].h = (OPJ_UINT32 )h;
#line 2777
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break: 
    {
#line 2802
    image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
    }
#line 2805
    if (! image) {
      {
#line 2807
      TIFFClose(tif);
      }
#line 2808
      return ((opj_image_t *)((void *)0));
    }
#line 2812
    image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 2813
    image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 2814
    if (! image->x0) {
#line 2814
      tmp = (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx + 1U;
    } else {
#line 2814
      tmp = (image->x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
    }
#line 2814
    image->x1 = tmp;
#line 2816
    if (! image->y0) {
#line 2816
      tmp___0 = (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy + 1U;
    } else {
#line 2816
      tmp___0 = (image->y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
    }
    {
#line 2816
    image->y1 = tmp___0;
#line 2819
    __cil_tmp34 = TIFFStripSize(tif);
#line 2819
    __cil_tmp35 = _TIFFmalloc(__cil_tmp34);
#line 2819
    buf = __cil_tmp35;
#line 2821
    strip_size = TIFFStripSize(tif);
#line 2822
    index___55 = 0;
#line 2823
    imgsize = (int )((image->comps + 0)->w * (image->comps + 0)->h);
#line 2826
    strip = (tstrip_t )0;
    }
    {
#line 2826
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 2826
      if (! (strip < __cil_tmp37)) {
#line 2826
        goto while_break___0;
      }
      {
#line 2831
      ssize = TIFFReadEncodedStrip(tif, strip, buf, strip_size);
#line 2832
      dat8 = (unsigned char *)buf;
      }
#line 2834
      if ((int )tiBps == 16) {
#line 2836
        step = (6 + has_alpha) + has_alpha;
#line 2838
        i = (tsize_t )0;
        {
#line 2838
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 2838
          if (! (i < ssize)) {
#line 2838
            goto while_break___1;
          }
#line 2840
          if (index___55 < imgsize) {
#line 2842
            *((image->comps + 0)->data + index___55) = ((int )*(dat8 + (i + 1L)) << 8) | (int )*(dat8 + i);
#line 2843
            *((image->comps + 1)->data + index___55) = ((int )*(dat8 + (i + 3L)) << 8) | (int )*(dat8 + (i + 2L));
#line 2844
            *((image->comps + 2)->data + index___55) = ((int )*(dat8 + (i + 5L)) << 8) | (int )*(dat8 + (i + 4L));
#line 2845
            if (has_alpha) {
#line 2846
              *((image->comps + 3)->data + index___55) = ((int )*(dat8 + (i + 7L)) << 8) | (int )*(dat8 + (i + 6L));
            }
#line 2848
            if (is_cinema) {
#line 2852
              *((image->comps + 0)->data + index___55) = (*((image->comps + 0)->data + index___55) + 8) >> 4;
#line 2854
              *((image->comps + 1)->data + index___55) = (*((image->comps + 1)->data + index___55) + 8) >> 4;
#line 2856
              *((image->comps + 2)->data + index___55) = (*((image->comps + 2)->data + index___55) + 8) >> 4;
#line 2858
              if (has_alpha) {
#line 2859
                *((image->comps + 3)->data + index___55) = (*((image->comps + 3)->data + index___55) + 8) >> 4;
              }
            }
#line 2862
            index___55 ++;
          } else {
#line 2865
            goto while_break___1;
          }
#line 2838
          i += (long )step;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___1: ;
      } else
#line 2869
      if ((int )tiBps == 8) {
#line 2871
        step = 3 + has_alpha;
#line 2873
        i = (tsize_t )0;
        {
#line 2873
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 2873
          if (! (i < ssize)) {
#line 2873
            goto while_break___2;
          }
#line 2875
          if (index___55 < imgsize) {
#line 2878
            *((image->comps + 0)->data + index___55) = (OPJ_INT32 )*(dat8 + i);
#line 2879
            *((image->comps + 1)->data + index___55) = (OPJ_INT32 )*(dat8 + (i + 1L));
#line 2880
            *((image->comps + 2)->data + index___55) = (OPJ_INT32 )*(dat8 + (i + 2L));
#line 2881
            if (has_alpha) {
#line 2882
              *((image->comps + 3)->data + index___55) = (OPJ_INT32 )*(dat8 + (i + 3L));
            }
#line 2885
            if (is_cinema) {
#line 2890
              *((image->comps + 0)->data + index___55) <<= 4;
#line 2891
              *((image->comps + 1)->data + index___55) <<= 4;
#line 2892
              *((image->comps + 2)->data + index___55) <<= 4;
#line 2893
              if (has_alpha) {
#line 2894
                *((image->comps + 3)->data + index___55) <<= 4;
              }
            }
#line 2897
            index___55 ++;
          } else {
#line 2900
            goto while_break___2;
          }
#line 2873
          i += (long )step;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___2: ;
      } else
#line 2904
      if ((int )tiBps == 12) {
#line 2906
        step = 9;
#line 2908
        i = (tsize_t )0;
        {
#line 2908
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 2908
          if (! (i < ssize)) {
#line 2908
            goto while_break___3;
          }
#line 2910
          if (index___55 < imgsize) {
#line 2910
            if (index___55 + 1 < imgsize) {
#line 2912
              *((image->comps + 0)->data + index___55) = ((int )*(dat8 + i) << 4) | ((int )*(dat8 + (i + 1L)) >> 4);
#line 2913
              *((image->comps + 1)->data + index___55) = (((int )*(dat8 + (i + 1L)) & 15) << 8) | (int )*(dat8 + (i + 2L));
#line 2915
              *((image->comps + 2)->data + index___55) = ((int )*(dat8 + (i + 3L)) << 4) | ((int )*(dat8 + (i + 4L)) >> 4);
#line 2916
              *((image->comps + 0)->data + (index___55 + 1)) = (((int )*(dat8 + (i + 4L)) & 15) << 8) | (int )*(dat8 + (i + 5L));
#line 2918
              *((image->comps + 1)->data + (index___55 + 1)) = ((int )*(dat8 + (i + 6L)) << 4) | ((int )*(dat8 + (i + 7L)) >> 4);
#line 2919
              *((image->comps + 2)->data + (index___55 + 1)) = (((int )*(dat8 + (i + 7L)) & 15) << 8) | (int )*(dat8 + (i + 8L));
#line 2921
              index___55 += 2;
            } else {
#line 2924
              goto while_break___3;
            }
          } else {
#line 2924
            goto while_break___3;
          }
#line 2908
          i += (long )step;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___3: ;
      }
#line 2826
      strip ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 2929
    _TIFFfree(buf);
#line 2930
    TIFFClose(tif);
    }
#line 2932
    return (image);
  }
#line 2935
  if ((int )tiPhoto == 1) {
#line 2937
    numcomps = 1 + has_alpha;
#line 2938
    color_space = (OPJ_COLOR_SPACE )2;
#line 2940
    j = 0;
    {
#line 2940
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 2940
      if (! (j < numcomps)) {
#line 2940
        goto while_break___4;
      }
#line 2942
      cmptparm[j].prec = (OPJ_UINT32 )tiBps;
#line 2943
      cmptparm[j].bpp = (OPJ_UINT32 )tiBps;
#line 2944
      cmptparm[j].dx = (OPJ_UINT32 )subsampling_dx;
#line 2945
      cmptparm[j].dy = (OPJ_UINT32 )subsampling_dy;
#line 2946
      cmptparm[j].w = (OPJ_UINT32 )w;
#line 2947
      cmptparm[j].h = (OPJ_UINT32 )h;
#line 2940
      j ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___4: 
    {
#line 2952
    image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
    }
#line 2955
    if (! image) {
      {
#line 2957
      TIFFClose(tif);
      }
#line 2958
      return ((opj_image_t *)((void *)0));
    }
#line 2962
    image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 2963
    image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 2964
    if (! image->x0) {
#line 2964
      tmp___1 = (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx + 1U;
    } else {
#line 2964
      tmp___1 = (image->x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
    }
#line 2964
    image->x1 = tmp___1;
#line 2966
    if (! image->y0) {
#line 2966
      tmp___2 = (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy + 1U;
    } else {
#line 2966
      tmp___2 = (image->y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
    }
    {
#line 2966
    image->y1 = tmp___2;
#line 2969
    __cil_tmp49 = TIFFStripSize(tif);
#line 2969
    __cil_tmp50 = _TIFFmalloc(__cil_tmp49);
#line 2969
    buf = __cil_tmp50;
#line 2971
    strip_size = TIFFStripSize(tif);
#line 2972
    index___55 = 0;
#line 2973
    imgsize = (int )((image->comps + 0)->w * (image->comps + 0)->h);
#line 2976
    strip = (tstrip_t )0;
    }
    {
#line 2976
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 2976
      if (! (strip < __cil_tmp52)) {
#line 2976
        goto while_break___5;
      }
      {
#line 2982
      ssize___0 = TIFFReadEncodedStrip(tif, strip, buf, strip_size);
#line 2983
      dat8___0 = (unsigned char *)buf;
      }
#line 2985
      if ((int )tiBps == 16) {
#line 2987
        step___0 = (2 + has_alpha) + has_alpha;
#line 2989
        i___0 = (tsize_t )0;
        {
#line 2989
        while (1) {
          while_continue___6: /* CIL Label */ ;

#line 2989
          if (! (i___0 < ssize___0)) {
#line 2989
            goto while_break___6;
          }
#line 2991
          if (index___55 < imgsize) {
#line 2993
            *((image->comps + 0)->data + index___55) = ((int )*(dat8___0 + (i___0 + 1L)) << 8) | (int )*(dat8___0 + i___0);
#line 2994
            if (has_alpha) {
#line 2995
              *((image->comps + 1)->data + index___55) = ((int )*(dat8___0 + (i___0 + 3L)) << 8) | (int )*(dat8___0 + (i___0 + 2L));
            }
#line 2996
            index___55 ++;
          } else {
#line 2999
            goto while_break___6;
          }
#line 2989
          i___0 += (long )step___0;
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break___6: ;
      } else
#line 3003
      if ((int )tiBps == 8) {
#line 3005
        step___0 = 1 + has_alpha;
#line 3007
        i___0 = (tsize_t )0;
        {
#line 3007
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 3007
          if (! (i___0 < ssize___0)) {
#line 3007
            goto while_break___7;
          }
#line 3009
          if (index___55 < imgsize) {
#line 3011
            *((image->comps + 0)->data + index___55) = (OPJ_INT32 )*(dat8___0 + i___0);
#line 3012
            if (has_alpha) {
#line 3013
              *((image->comps + 1)->data + index___55) = (OPJ_INT32 )*(dat8___0 + (i___0 + 1L));
            }
#line 3014
            index___55 ++;
          } else {
#line 3017
            goto while_break___7;
          }
#line 3007
          i___0 += (long )step___0;
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___7: ;
      }
#line 2976
      strip ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___5: 
    {
#line 3022
    _TIFFfree(buf);
#line 3023
    TIFFClose(tif);
    }
  }
#line 3027
  return (image);
}
}
#line 3038 "/root/patchweave_new/10/src/bin/jp2/convert.c"
static opj_image_t *rawtoimage_common(char const   *filename , opj_cparameters_t *parameters ,
                                      raw_cparameters_t *raw_cp , OPJ_BOOL big_endian ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *f ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t *cmptparm ;
  opj_image_t *image ;
  unsigned short ch ;
  void *__cil_tmp18 ;
  unsigned char value ;
  int nloop ;
  unsigned long __cil_tmp23 ;
  int tmp ;
  unsigned short value___0 ;
  int nloop___0 ;
  unsigned char temp1 ;
  unsigned char temp2 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int tmp___0 ;
  unsigned long __cil_tmp36 ;

  {
#line 3039
  subsampling_dx = parameters->subsampling_dx;
#line 3040
  subsampling_dy = parameters->subsampling_dy;
#line 3042
  f = (FILE *)((void *)0);
#line 3046
  image = (opj_image_t *)((void *)0);
#line 3049
  if (! (((raw_cp->rawWidth & raw_cp->rawHeight) & raw_cp->rawComp) & raw_cp->rawBitDepth) == 0) {
    {
#line 3051
    fprintf(stderr, "\nError: invalid raw image parameters\n");
#line 3052
    fprintf(stderr, "Please use the Format option -F:\n");
#line 3053
    fprintf(stderr, "-F <width>,<height>,<ncomp>,<bitdepth>,{s,u}@<dx1>x<dy1>:...:<dxn>x<dyn>\n");
#line 3054
    fprintf(stderr, "If subsampling is omitted, 1x1 is assumed for all components\nV");
#line 3055
    fprintf(stderr, "Example: -i image.raw -o image.j2k -F 512,512,3,8,u@1x1:2x2:2x2\n\220");
#line 3056
    fprintf(stderr, "         for raw 512x512 image with 4:2:0 subsampling\n");
#line 3057
    fprintf(stderr, "Aborting.\nOlEV");
    }
#line 3058
    return ((opj_image_t *)((void *)0));
  }
  {
#line 3061
  f = fopen(filename, "rbOlEV");
  }
#line 3062
  if (! f) {
    {
#line 3063
    fprintf(stderr, "Failed to open %s for reading !!\n\372PlEV", filename);
#line 3064
    fprintf(stderr, "Aborting\n");
    }
#line 3065
    return ((opj_image_t *)((void *)0));
  }
#line 3067
  numcomps = raw_cp->rawComp;
#line 3070
  if (numcomps == 0) {
#line 3071
    color_space = (OPJ_COLOR_SPACE )2;
  } else
#line 3072
  if (numcomps >= 3) {
#line 3072
    if ((int )parameters->tcp_mct == 0) {
#line 3073
      color_space = (OPJ_COLOR_SPACE )3;
    } else {
#line 3072
      goto _L;
    }
  } else
  _L: 
#line 3074
  if (numcomps >= 3) {
#line 3074
    if ((int )parameters->tcp_mct != 2) {
#line 3075
      color_space = (OPJ_COLOR_SPACE )1;
    } else {
#line 3077
      color_space = (OPJ_COLOR_SPACE )-1;
    }
  } else {
#line 3077
    color_space = (OPJ_COLOR_SPACE )-1;
  }
  {
#line 3079
  w = raw_cp->rawWidth;
#line 3080
  h = raw_cp->rawHeight;
#line 3081
  __cil_tmp18 = calloc((unsigned long )((OPJ_UINT32 )numcomps), sizeof(opj_image_cmptparm_t ));
#line 3081
  cmptparm = (opj_image_cmptparm_t *)__cil_tmp18;
  }
#line 3082
  if (! cmptparm) {
    {
#line 3083
    fprintf(stderr, "Failed to allocate image components parameters !!\n");
#line 3084
    fprintf(stderr, "Aborting\n\fQlEV");
    }
#line 3085
    return ((opj_image_t *)((void *)0));
  }
#line 3088
  i = 0;
  {
#line 3088
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3088
    if (! (i < numcomps)) {
#line 3088
      goto while_break;
    }
#line 3089
    (cmptparm + i)->prec = (OPJ_UINT32 )raw_cp->rawBitDepth;
#line 3090
    (cmptparm + i)->bpp = (OPJ_UINT32 )raw_cp->rawBitDepth;
#line 3091
    (cmptparm + i)->sgnd = (OPJ_UINT32 )raw_cp->rawSigned;
#line 3092
    (cmptparm + i)->dx = (OPJ_UINT32 )(subsampling_dx * (raw_cp->rawComps + i)->dx);
#line 3093
    (cmptparm + i)->dy = (OPJ_UINT32 )(subsampling_dy * (raw_cp->rawComps + i)->dy);
#line 3094
    (cmptparm + i)->w = (OPJ_UINT32 )w;
#line 3095
    (cmptparm + i)->h = (OPJ_UINT32 )h;
#line 3088
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 3098
  image = opj_image_create((OPJ_UINT32 )numcomps, cmptparm + 0, color_space);
#line 3099
  free((void *)cmptparm);
  }
#line 3100
  if (! image) {
    {
#line 3101
    fclose(f);
    }
#line 3102
    return ((opj_image_t *)((void *)0));
  }
#line 3105
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 3106
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 3107
  image->x1 = ((OPJ_UINT32 )parameters->image_offset_x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
#line 3108
  image->y1 = ((OPJ_UINT32 )parameters->image_offset_y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
#line 3110
  if (raw_cp->rawBitDepth <= 8) {
#line 3112
    value = (unsigned char)0;
#line 3113
    compno = 0;
    {
#line 3113
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 3113
      if (! (compno < numcomps)) {
#line 3113
        goto while_break___0;
      }
#line 3114
      nloop = (w * h) / ((raw_cp->rawComps + compno)->dx * (raw_cp->rawComps + compno)->dy);
#line 3115
      i = 0;
      {
#line 3115
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 3115
        if (! (i < nloop)) {
#line 3115
          goto while_break___1;
        }
        {
#line 3116
        __cil_tmp23 = fread((void *)(& value), 1UL, 1UL, f);
        }
#line 3116
        if (! __cil_tmp23) {
          {
#line 3117
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 3118
          return ((opj_image_t *)((void *)0));
        }
#line 3120
        if (raw_cp->rawSigned) {
#line 3120
          tmp = (int )((char )value);
        } else {
#line 3120
          tmp = (int )value;
        }
#line 3120
        *((image->comps + compno)->data + i) = tmp;
#line 3115
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
#line 3113
      compno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: ;
  } else
#line 3124
  if (raw_cp->rawBitDepth <= 16) {
#line 3127
    compno = 0;
    {
#line 3127
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 3127
      if (! (compno < numcomps)) {
#line 3127
        goto while_break___2;
      }
#line 3128
      nloop___0 = (w * h) / ((raw_cp->rawComps + compno)->dx * (raw_cp->rawComps + compno)->dx);
#line 3129
      i = 0;
      {
#line 3129
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 3129
        if (! (i < nloop___0)) {
#line 3129
          goto while_break___3;
        }
        {
#line 3132
        __cil_tmp31 = fread((void *)(& temp1), 1UL, 1UL, f);
        }
#line 3132
        if (! __cil_tmp31) {
          {
#line 3133
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 3134
          return ((opj_image_t *)((void *)0));
        }
        {
#line 3136
        __cil_tmp32 = fread((void *)(& temp2), 1UL, 1UL, f);
        }
#line 3136
        if (! __cil_tmp32) {
          {
#line 3137
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 3138
          return ((opj_image_t *)((void *)0));
        }
#line 3140
        if (big_endian) {
#line 3142
          value___0 = (unsigned short )(((int )temp1 << 8) + (int )temp2);
        } else {
#line 3146
          value___0 = (unsigned short )(((int )temp2 << 8) + (int )temp1);
        }
#line 3148
        if (raw_cp->rawSigned) {
#line 3148
          tmp___0 = (int )((short )value___0);
        } else {
#line 3148
          tmp___0 = (int )value___0;
        }
#line 3148
        *((image->comps + compno)->data + i) = tmp___0;
#line 3129
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 3127
      compno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: ;
  } else {
    {
#line 3153
    fprintf(stderr, "OpenJPEG cannot encode raw components with bit depth higher than 16 bits.\nQlEV");
    }
#line 3154
    return ((opj_image_t *)((void *)0));
  }
  {
#line 3157
  __cil_tmp36 = fread((void *)(& ch), 1UL, 1UL, f);
  }
#line 3157
  if (__cil_tmp36) {
    {
#line 3158
    fprintf(stderr, "Warning. End of raw file not reached... processing anyway\nQlEV");
    }
  }
  {
#line 3160
  fclose(f);
  }
#line 3162
  return (image);
}
}
#line 3165 "/root/patchweave_new/10/src/bin/jp2/convert.c"
opj_image_t *rawltoimage(char const   *filename , opj_cparameters_t *parameters ,
                         raw_cparameters_t *raw_cp ) 
{ 
  opj_image_t *__cil_tmp4 ;

  {
  {
#line 3166
  __cil_tmp4 = rawtoimage_common(filename, parameters, raw_cp, 0);
  }
#line 3166
  return (__cil_tmp4);
}
}
#line 3169 "/root/patchweave_new/10/src/bin/jp2/convert.c"
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) 
{ 
  opj_image_t *__cil_tmp4 ;

  {
  {
#line 3170
  __cil_tmp4 = rawtoimage_common(filename, parameters, raw_cp, 1);
  }
#line 3170
  return (__cil_tmp4);
}
}
#line 3173 "/root/patchweave_new/10/src/bin/jp2/convert.c"
static int imagetoraw_common(opj_image_t *image , char const   *outfile , OPJ_BOOL big_endian ) 
{ 
  FILE *rawFile ;
  size_t res ;
  unsigned int compno ;
  int w ;
  int h ;
  int fails ;
  int line ;
  int row ;
  int curr ;
  int mask ;
  int *ptr ;
  unsigned char uc ;
  char const   *tmp ;

  {
#line 3175
  rawFile = (FILE *)((void *)0);
#line 3184
  if ((image->numcomps * image->x1) * image->y1 == 0U) {
    {
#line 3186
    fprintf(stderr, "\nError: invalid raw image parameters\nV");
    }
#line 3187
    return (1);
  }
  {
#line 3190
  rawFile = fopen(outfile, "wb");
  }
#line 3191
  if (! rawFile) {
    {
#line 3192
    fprintf(stderr, "Failed to open %s for writing !!\ntQlEV", outfile);
    }
#line 3193
    return (1);
  }
  {
#line 3196
  fails = 1;
#line 3197
  fprintf(stdout, "Raw image characteristics: %d components\n\2371lEV", image->numcomps);
#line 3199
  compno = 0U;
  }
  {
#line 3199
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3199
    if (! (compno < image->numcomps)) {
#line 3199
      goto while_break;
    }
#line 3201
    if ((image->comps + compno)->sgnd == 1U) {
      {
#line 3201
      strcpy((char *)tmp, "signed");
      }
    } else {
      {
#line 3201
      strcpy((char *)tmp, "unsigned\220");
      }
    }
    {
#line 3201
    fprintf(stdout, "Component %d characteristics: %dx%dx%d %s\n", compno, (image->comps + compno)->w,
            (image->comps + compno)->h, (image->comps + compno)->prec, tmp);
#line 3204
    w = (int )(image->comps + compno)->w;
#line 3205
    h = (int )(image->comps + compno)->h;
    }
#line 3207
    if ((image->comps + compno)->prec <= 8U) {
#line 3209
      if ((image->comps + compno)->sgnd == 1U) {
#line 3211
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 3212
        ptr = (image->comps + compno)->data;
#line 3213
        line = 0;
        {
#line 3213
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 3213
          if (! (line < h)) {
#line 3213
            goto while_break___0;
          }
#line 3214
          row = 0;
          {
#line 3214
          while (1) {
            while_continue___1: /* CIL Label */ ;

#line 3214
            if (! (row < w)) {
#line 3214
              goto while_break___1;
            }
#line 3215
            curr = *ptr;
#line 3216
            if (curr > 127) {
#line 3216
              curr = 127;
            } else
#line 3216
            if (curr < -128) {
#line 3216
              curr = -128;
            }
            {
#line 3217
            uc = (unsigned char )(curr & mask);
#line 3218
            res = fwrite((void const   *)(& uc), 1UL, 1UL, rawFile);
            }
#line 3219
            if (res < 1UL) {
              {
#line 3220
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 3221
              goto fin;
            }
#line 3223
            ptr ++;
#line 3214
            row ++;
          }
          while_break___10: /* CIL Label */ ;
          }
          while_break___1: 
#line 3213
          line ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___0: ;
      } else
#line 3227
      if ((image->comps + compno)->sgnd == 0U) {
#line 3229
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 3230
        ptr = (image->comps + compno)->data;
#line 3231
        line = 0;
        {
#line 3231
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 3231
          if (! (line < h)) {
#line 3231
            goto while_break___2;
          }
#line 3232
          row = 0;
          {
#line 3232
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 3232
            if (! (row < w)) {
#line 3232
              goto while_break___3;
            }
#line 3233
            curr = *ptr;
#line 3234
            if (curr > 255) {
#line 3234
              curr = 255;
            } else
#line 3234
            if (curr < 0) {
#line 3234
              curr = 0;
            }
            {
#line 3235
            uc = (unsigned char )(curr & mask);
#line 3236
            res = fwrite((void const   *)(& uc), 1UL, 1UL, rawFile);
            }
#line 3237
            if (res < 1UL) {
              {
#line 3238
              fprintf(stderr, "failed to write 1 byte for %s\n\002", outfile);
              }
#line 3239
              goto fin;
            }
#line 3241
            ptr ++;
#line 3232
            row ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___3: 
#line 3231
          line ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___2: ;
      }
    } else
#line 3246
    if ((image->comps + compno)->prec <= 16U) {
#line 3248
      if ((image->comps + compno)->sgnd == 1U) {
#line 3251
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 3252
        ptr = (image->comps + compno)->data;
#line 3253
        line = 0;
        {
#line 3253
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 3253
          if (! (line < h)) {
#line 3253
            goto while_break___4;
          }
#line 3254
          row = 0;
          {
#line 3254
          while (1) {
            while_continue___5: /* CIL Label */ ;

#line 3254
            if (! (row < w)) {
#line 3254
              goto while_break___5;
            }
#line 3255
            curr = *ptr;
#line 3256
            if (curr > 32767) {
#line 3256
              curr = 32767;
            } else
#line 3256
            if (curr < -32768) {
#line 3256
              curr = -32768;
            }
#line 3259
            if (res < 2UL) {
              {
#line 3260
              fprintf(stderr, "failed to write 2 byte for %s\n", outfile);
              }
#line 3261
              goto fin;
            }
#line 3263
            ptr ++;
#line 3254
            row ++;
          }
          while_break___14: /* CIL Label */ ;
          }
          while_break___5: 
#line 3253
          line ++;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___4: ;
      } else
#line 3267
      if ((image->comps + compno)->sgnd == 0U) {
#line 3270
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 3271
        ptr = (image->comps + compno)->data;
#line 3272
        line = 0;
        {
#line 3272
        while (1) {
          while_continue___6: /* CIL Label */ ;

#line 3272
          if (! (line < h)) {
#line 3272
            goto while_break___6;
          }
#line 3273
          row = 0;
          {
#line 3273
          while (1) {
            while_continue___7: /* CIL Label */ ;

#line 3273
            if (! (row < w)) {
#line 3273
              goto while_break___7;
            }
#line 3274
            curr = *ptr;
#line 3275
            if (curr > 65536) {
#line 3275
              curr = 65536;
            } else
#line 3275
            if (curr < 0) {
#line 3275
              curr = 0;
            }
#line 3278
            if (res < 2UL) {
              {
#line 3279
              fprintf(stderr, "failed to write 2 byte for %s\n", outfile);
              }
#line 3280
              goto fin;
            }
#line 3282
            ptr ++;
#line 3273
            row ++;
          }
          while_break___16: /* CIL Label */ ;
          }
          while_break___7: 
#line 3272
          line ++;
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break___6: ;
      }
    } else
#line 3287
    if ((image->comps + compno)->prec <= 32U) {
      {
#line 3289
      fprintf(stderr, "More than 16 bits per component no handled yet\n");
      }
#line 3290
      goto fin;
    } else {
      {
#line 3294
      fprintf(stderr, "Error: invalid precision: %d\n", (image->comps + compno)->prec);
      }
#line 3295
      goto fin;
    }
#line 3199
    compno ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: 
#line 3298
  fails = 0;
  fin: 
  {
#line 3300
  fclose(rawFile);
  }
#line 3301
  return (fails);
}
}
#line 3304 "/root/patchweave_new/10/src/bin/jp2/convert.c"
int imagetoraw(opj_image_t *image , char const   *outfile ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 3306
  __cil_tmp3 = imagetoraw_common(image, outfile, 1);
  }
#line 3306
  return (__cil_tmp3);
}
}
#line 3309 "/root/patchweave_new/10/src/bin/jp2/convert.c"
int imagetorawl(opj_image_t *image , char const   *outfile ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 3311
  __cil_tmp3 = imagetoraw_common(image, outfile, 0);
  }
#line 3311
  return (__cil_tmp3);
}
}
#line 3320 "/root/patchweave_new/10/src/bin/jp2/convert.c"
opj_image_t *pngtoimage(char const   *read_idf , opj_cparameters_t *params ) 
{ 
  png_structp png ;
  png_infop info ;
  double gamma___0 ;
  double display_exponent ;
  int bit_depth ;
  int interlace_type ;
  int compression_type ;
  int filter_type ;
  int unit ;
  png_uint_32 resx ;
  png_uint_32 resy ;
  unsigned int i ;
  unsigned int j ;
  png_uint_32 width ;
  png_uint_32 height ;
  int color_type ;
  int has_alpha ;
  int is16 ;
  unsigned char *s ;
  FILE *reader ;
  unsigned char **rows ;
  opj_image_t *image ;
  opj_image_cmptparm_t cmptparm[4] ;
  int sub_dx ;
  int sub_dy ;
  unsigned int nr_comp ;
  int *r ;
  int *g ;
  int *b ;
  int *a ;
  unsigned char sigbuf[8] ;
  unsigned long __cil_tmp35 ;
  int __cil_tmp36 ;
  jmp_buf *__cil_tmp39 ;
  int __cil_tmp40 ;
  png_uint_32 __cil_tmp41 ;
  png_uint_32 __cil_tmp42 ;
  int tmp ;
  png_uint_32 __cil_tmp44 ;
  png_byte __cil_tmp45 ;
  png_byte __cil_tmp46 ;
  void *__cil_tmp47 ;
  size_t __cil_tmp48 ;
  void *__cil_tmp49 ;
  int *__cil_tmp51 ;
  int *__cil_tmp52 ;
  int *__cil_tmp53 ;
  int *__cil_tmp54 ;
  int *__cil_tmp55 ;
  unsigned char *__cil_tmp56 ;
  int *__cil_tmp57 ;
  unsigned char *__cil_tmp58 ;
  int *__cil_tmp59 ;
  unsigned char *__cil_tmp60 ;
  int *__cil_tmp61 ;
  unsigned char *__cil_tmp62 ;

  {
  {
#line 3339
  a = (int *)((void *)0);
#line 3342
  reader = fopen(read_idf, "rb");
  }
#line 3342
  if ((unsigned long )reader == (unsigned long )((void *)0)) {
    {
#line 3344
    fprintf(stderr, "pngtoimage: can not open %s\nEV", read_idf);
    }
#line 3345
    return ((opj_image_t *)((void *)0));
  }
  {
#line 3347
  image = (opj_image_t *)((void *)0);
#line 3347
  png = (png_structp )((void *)0);
#line 3347
  rows = (unsigned char **)((void *)0);
#line 3349
  __cil_tmp36 = memcmp((void const   *)(sigbuf), (void const   *)"\211PNG\r\n\032\n\251",
                       8UL);
#line 3349
  __cil_tmp35 = fread((void *)(sigbuf), 1UL, 8UL, reader);
  }
#line 3349
  if (__cil_tmp35 != 8UL) {
    {
#line 3352
    fprintf(stderr, "pngtoimage: %s is no valid PNG file\nEV", read_idf);
    }
#line 3353
    goto fin;
  } else
#line 3349
  if (__cil_tmp36 != 0) {
    {
#line 3352
    fprintf(stderr, "pngtoimage: %s is no valid PNG file\nEV", read_idf);
    }
#line 3353
    goto fin;
  }
  {
#line 3359
  display_exponent = 2.20000000001;
#line 3361
  png = png_create_read_struct("1.6.37", (void *)0, (void (*)(png_structp  , png_const_charp  ))((void *)0),
                               (void (*)(png_structp  , png_const_charp  ))((void *)0));
  }
#line 3361
  if ((unsigned long )png == (unsigned long )((void *)0)) {
#line 3363
    goto fin;
  }
  {
#line 3364
  info = png_create_info_struct(png);
  }
#line 3364
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 3365
    goto fin;
  }
  {
#line 3367
  __cil_tmp39 = png_set_longjmp_fn(png, & longjmp, sizeof(jmp_buf ));
#line 3367
  __cil_tmp40 = _setjmp((struct __jmp_buf_tag *)(*__cil_tmp39));
  }
#line 3367
  if (__cil_tmp40) {
#line 3368
    goto fin;
  }
  {
#line 3370
  png_init_io(png, reader);
#line 3371
  png_set_sig_bytes(png, 8);
#line 3373
  png_read_info(png, info);
#line 3375
  __cil_tmp41 = png_get_IHDR(png, info, & width, & height, & bit_depth, & color_type,
                             & interlace_type, & compression_type, & filter_type);
  }
#line 3375
  if (__cil_tmp41 == 0U) {
#line 3378
    goto fin;
  }
#line 3385
  if (color_type == 3) {
    {
#line 3386
    png_set_expand(png);
    }
  } else
#line 3388
  if (color_type == 0) {
#line 3388
    if (bit_depth < 8) {
      {
#line 3389
      png_set_expand(png);
      }
    }
  }
  {
#line 3391
  __cil_tmp42 = png_get_valid(png, info, 16U);
  }
#line 3391
  if (__cil_tmp42) {
    {
#line 3392
    png_set_expand(png);
    }
  }
#line 3394
  is16 = bit_depth == 16;
#line 3398
  if (color_type == 0) {
    _L: 
    {
#line 3401
    png_set_gray_to_rgb(png);
    }
#line 3402
    if (color_type == 0) {
#line 3402
      tmp = 2;
    } else {
#line 3402
      tmp = 6;
    }
#line 3402
    color_type = tmp;
  } else
#line 3398
  if (color_type == 4) {
#line 3398
    goto _L;
  }
  {
#line 3406
  __cil_tmp44 = png_get_gAMA(png, info, & gamma___0);
  }
#line 3406
  if (! __cil_tmp44) {
#line 3407
    gamma___0 = 0.454550000001;
  }
  {
#line 3409
  png_set_gamma(png, display_exponent, gamma___0);
#line 3411
  png_read_update_info(png, info);
#line 3413
  png_get_pHYs(png, info, & resx, & resy, & unit);
#line 3415
  __cil_tmp45 = png_get_color_type(png, info);
#line 3415
  color_type = (int )__cil_tmp45;
#line 3417
  has_alpha = color_type == 6;
#line 3419
  nr_comp = 3U + (unsigned int )has_alpha;
#line 3421
  __cil_tmp46 = png_get_bit_depth(png, info);
#line 3421
  bit_depth = (int )__cil_tmp46;
#line 3423
  __cil_tmp47 = calloc((unsigned long )(height + 1U), sizeof(unsigned char *));
#line 3423
  rows = (unsigned char **)__cil_tmp47;
#line 3424
  i = 0U;
  }
  {
#line 3424
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3424
    if (! (i < height)) {
#line 3424
      goto while_break;
    }
    {
#line 3425
    __cil_tmp48 = png_get_rowbytes(png, info);
#line 3425
    __cil_tmp49 = malloc(__cil_tmp48);
#line 3425
    *(rows + i) = (unsigned char *)__cil_tmp49;
#line 3424
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 3427
  png_read_image(png, rows);
#line 3429
  memset((void *)(cmptparm), 0, sizeof(cmptparm));
#line 3431
  sub_dx = params->subsampling_dx;
#line 3431
  sub_dy = params->subsampling_dy;
#line 3433
  i = 0U;
  }
  {
#line 3433
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 3433
    if (! (i < nr_comp)) {
#line 3433
      goto while_break___0;
    }
#line 3435
    cmptparm[i].prec = (OPJ_UINT32 )bit_depth;
#line 3437
    cmptparm[i].bpp = (OPJ_UINT32 )bit_depth;
#line 3438
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 3439
    cmptparm[i].dx = (OPJ_UINT32 )sub_dx;
#line 3440
    cmptparm[i].dy = (OPJ_UINT32 )sub_dy;
#line 3441
    cmptparm[i].w = width;
#line 3442
    cmptparm[i].h = height;
#line 3433
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 3445
  image = opj_image_create(nr_comp, & cmptparm[0], (OPJ_COLOR_SPACE )1);
  }
#line 3447
  if ((unsigned long )image == (unsigned long )((void *)0)) {
#line 3447
    goto fin;
  }
#line 3449
  image->x0 = (OPJ_UINT32 )params->image_offset_x0;
#line 3450
  image->y0 = (OPJ_UINT32 )params->image_offset_y0;
#line 3451
  image->x1 = ((image->x0 + (width - 1U) * (OPJ_UINT32 )sub_dx) + 1U) + image->x0;
#line 3452
  image->y1 = ((image->y0 + (height - 1U) * (OPJ_UINT32 )sub_dy) + 1U) + image->y0;
#line 3454
  r = (image->comps + 0)->data;
#line 3455
  g = (image->comps + 1)->data;
#line 3456
  b = (image->comps + 2)->data;
#line 3457
  if (has_alpha) {
#line 3458
    a = (image->comps + 3)->data;
#line 3459
    (image->comps + 3)->alpha = (OPJ_UINT16 )1;
  }
#line 3462
  i = 0U;
  {
#line 3462
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 3462
    if (! (i < height)) {
#line 3462
      goto while_break___1;
    }
#line 3464
    s = *(rows + i);
#line 3466
    j = 0U;
    {
#line 3466
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___2: ;
#line 3466
      if (! (j < width)) {
#line 3466
        goto while_break___2;
      }
#line 3468
      if (is16) {
#line 3470
        __cil_tmp51 = r;
#line 3470
        r ++;
#line 3470
        *__cil_tmp51 = ((int )*(s + 0) << 8) | (int )*(s + 1);
#line 3470
        s += 2;
#line 3472
        __cil_tmp52 = g;
#line 3472
        g ++;
#line 3472
        *__cil_tmp52 = ((int )*(s + 0) << 8) | (int )*(s + 1);
#line 3472
        s += 2;
#line 3474
        __cil_tmp53 = b;
#line 3474
        b ++;
#line 3474
        *__cil_tmp53 = ((int )*(s + 0) << 8) | (int )*(s + 1);
#line 3474
        s += 2;
#line 3476
        if (has_alpha) {
#line 3476
          __cil_tmp54 = a;
#line 3476
          a ++;
#line 3476
          *__cil_tmp54 = ((int )*(s + 0) << 8) | (int )*(s + 1);
#line 3476
          s += 2;
        }
#line 3478
        goto while_continue___2;
      }
#line 3480
      __cil_tmp56 = s;
#line 3480
      s ++;
#line 3480
      __cil_tmp55 = r;
#line 3480
      r ++;
#line 3480
      *__cil_tmp55 = (int )*__cil_tmp56;
#line 3480
      __cil_tmp58 = s;
#line 3480
      s ++;
#line 3480
      __cil_tmp57 = g;
#line 3480
      g ++;
#line 3480
      *__cil_tmp57 = (int )*__cil_tmp58;
#line 3480
      __cil_tmp60 = s;
#line 3480
      s ++;
#line 3480
      __cil_tmp59 = b;
#line 3480
      b ++;
#line 3480
      *__cil_tmp59 = (int )*__cil_tmp60;
#line 3482
      if (has_alpha) {
#line 3482
        __cil_tmp62 = s;
#line 3482
        s ++;
#line 3482
        __cil_tmp61 = a;
#line 3482
        a ++;
#line 3482
        *__cil_tmp61 = (int )*__cil_tmp62;
      }
#line 3466
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 3462
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: ;
  fin: 
#line 3486
  if (rows) {
#line 3488
    i = 0U;
    {
#line 3488
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 3488
      if (! (i < height)) {
#line 3488
        goto while_break___3;
      }
      {
#line 3489
      free((void *)*(rows + i));
#line 3488
      i ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: 
    {
#line 3490
    free((void *)rows);
    }
  }
#line 3492
  if (png) {
    {
#line 3493
    png_destroy_read_struct(& png, & info, (png_infopp )((void *)0));
    }
  }
  {
#line 3495
  fclose(reader);
  }
#line 3497
  return (image);
}
}
#line 3501 "/root/patchweave_new/10/src/bin/jp2/convert.c"
int imagetopng(opj_image_t *image , char const   *write_idf ) 
{ 
  FILE *writer ;
  png_structp png ;
  png_infop info ;
  int *red ;
  int *green ;
  int *blue ;
  int *alpha ;
  unsigned char *row_buf ;
  unsigned char *d ;
  int has_alpha ;
  int width ;
  int height ;
  int nr_comp ;
  int color_type ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int adjustA ;
  int x ;
  int y ;
  int fails ;
  int prec ;
  int ushift ;
  int dshift ;
  int is16 ;
  int force16 ;
  int force8 ;
  unsigned short mask ;
  png_color_8 sig_bit ;
  jmp_buf *__cil_tmp35 ;
  int __cil_tmp36 ;
  int v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp42 ;
  unsigned char *__cil_tmp43 ;
  unsigned char *__cil_tmp44 ;
  unsigned char *__cil_tmp45 ;
  unsigned char *__cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  unsigned char *__cil_tmp48 ;
  unsigned char *__cil_tmp49 ;
  unsigned char *__cil_tmp50 ;
  unsigned char *__cil_tmp51 ;
  unsigned char *__cil_tmp52 ;
  unsigned char *__cil_tmp53 ;
  unsigned char *__cil_tmp54 ;
  int v___0 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp58 ;
  unsigned char *__cil_tmp59 ;
  unsigned char *__cil_tmp60 ;
  int *__cil_tmp61 ;
  unsigned char *__cil_tmp62 ;
  unsigned char *__cil_tmp63 ;
  void *__cil_tmp64 ;
  unsigned char *__cil_tmp65 ;
  unsigned char *__cil_tmp66 ;

  {
#line 3511
  mask = (unsigned short)65535;
#line 3514
  dshift = 0;
#line 3514
  ushift = dshift;
#line 3514
  force8 = ushift;
#line 3514
  force16 = force8;
#line 3514
  is16 = force16;
#line 3514
  fails = 1;
#line 3515
  prec = (int )(image->comps + 0)->prec;
#line 3516
  nr_comp = (int )image->numcomps;
#line 3518
  if (prec > 8) {
#line 3518
    if (prec < 16) {
#line 3520
      ushift = 16 - prec;
#line 3520
      dshift = prec - ushift;
#line 3521
      prec = 16;
#line 3521
      force16 = 1;
    } else {
#line 3518
      goto _L;
    }
  } else
  _L: 
#line 3524
  if (prec < 8) {
#line 3524
    if (nr_comp > 1) {
#line 3526
      ushift = 8 - prec;
#line 3526
      dshift = 8 - ushift;
#line 3527
      prec = 8;
#line 3527
      force8 = 1;
    }
  }
#line 3530
  if (prec != 1) {
#line 3530
    if (prec != 2) {
#line 3530
      if (prec != 4) {
#line 3530
        if (prec != 8) {
#line 3530
          if (prec != 16) {
            {
#line 3532
            fprintf(stderr, "imagetopng: can not create %s\n\twrong bit_depth %d\n",
                    write_idf, prec);
            }
#line 3534
            return (fails);
          }
        }
      }
    }
  }
  {
#line 3536
  writer = fopen(write_idf, "wbRlEV");
  }
#line 3538
  if ((unsigned long )writer == (unsigned long )((void *)0)) {
#line 3538
    return (fails);
  }
  {
#line 3540
  info = (png_infop )((void *)0);
#line 3540
  has_alpha = 0;
#line 3548
  png = png_create_write_struct("1.6.37", (void *)0, (void (*)(png_structp  , png_const_charp  ))((void *)0),
                                (void (*)(png_structp  , png_const_charp  ))((void *)0));
  }
#line 3552
  if ((unsigned long )png == (unsigned long )((void *)0)) {
#line 3552
    goto fin;
  }
  {
#line 3556
  info = png_create_info_struct(png);
  }
#line 3558
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 3558
    goto fin;
  }
  {
#line 3563
  __cil_tmp35 = png_set_longjmp_fn(png, & longjmp, sizeof(jmp_buf ));
#line 3563
  __cil_tmp36 = _setjmp((struct __jmp_buf_tag *)(*__cil_tmp35));
  }
#line 3563
  if (__cil_tmp36) {
#line 3563
    goto fin;
  }
  {
#line 3567
  png_init_io(png, writer);
#line 3586
  png_set_compression_level(png, 9);
  }
#line 3588
  if (prec == 16) {
#line 3588
    mask = (unsigned short)65535;
  } else
#line 3590
  if (prec == 8) {
#line 3590
    mask = (unsigned short)255;
  } else
#line 3592
  if (prec == 4) {
#line 3592
    mask = (unsigned short)15;
  } else
#line 3594
  if (prec == 2) {
#line 3594
    mask = (unsigned short)3;
  } else
#line 3596
  if (prec == 1) {
#line 3596
    mask = (unsigned short)1;
  }
#line 3598
  if (nr_comp >= 3) {
#line 3598
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 3598
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 3598
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 3598
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 3598
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 3598
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
#line 3608
                has_alpha = nr_comp > 3;
#line 3610
                is16 = prec == 16;
#line 3612
                width = (int )(image->comps + 0)->w;
#line 3613
                height = (int )(image->comps + 0)->h;
#line 3615
                red = (image->comps + 0)->data;
#line 3616
                green = (image->comps + 1)->data;
#line 3617
                blue = (image->comps + 2)->data;
#line 3619
                sig_bit.blue = (png_byte )prec;
#line 3619
                sig_bit.green = sig_bit.blue;
#line 3619
                sig_bit.red = sig_bit.green;
#line 3621
                if (has_alpha) {
#line 3623
                  sig_bit.alpha = (png_byte )prec;
#line 3624
                  alpha = (image->comps + 3)->data;
#line 3625
                  color_type = 6;
#line 3626
                  if ((image->comps + 3)->sgnd) {
#line 3626
                    tmp = 1 << ((image->comps + 3)->prec - 1U);
                  } else {
#line 3626
                    tmp = 0;
                  }
#line 3626
                  adjustA = tmp;
                } else {
#line 3630
                  sig_bit.alpha = (png_byte )0;
#line 3630
                  alpha = (int *)((void *)0);
#line 3631
                  color_type = 2;
#line 3632
                  adjustA = 0;
                }
                {
#line 3634
                png_set_sBIT(png, info, & sig_bit);
#line 3636
                png_set_IHDR(png, info, (png_uint_32 )width, (png_uint_32 )height,
                             prec, color_type, 0, 0, 0);
#line 3641
                png_set_gamma(png, 2.20000000001, 1. / 2.20000000001);
#line 3642
                png_set_sRGB(png, info, 0);
#line 3644
                png_write_info(png, info);
                }
#line 3646
                if (prec < 8) {
                  {
#line 3648
                  png_set_packing(png);
                  }
                }
                {
#line 3650
                printf("%s:%d:sgnd(%d,%d,%d) w(%d) h(%d) alpha(%d)\n", "/root/patchweave_new/10/src/bin/jp2/convert.cV",
                       3650, (image->comps + 0)->sgnd, (image->comps + 1)->sgnd, (image->comps + 2)->sgnd,
                       width, height, has_alpha);
                }
#line 3654
                if ((image->comps + 0)->sgnd) {
#line 3654
                  tmp___0 = 1 << ((image->comps + 0)->prec - 1U);
                } else {
#line 3654
                  tmp___0 = 0;
                }
#line 3654
                adjustR = tmp___0;
#line 3655
                if ((image->comps + 1)->sgnd) {
#line 3655
                  tmp___1 = 1 << ((image->comps + 1)->prec - 1U);
                } else {
#line 3655
                  tmp___1 = 0;
                }
#line 3655
                adjustG = tmp___1;
#line 3656
                if ((image->comps + 2)->sgnd) {
#line 3656
                  tmp___2 = 1 << ((image->comps + 2)->prec - 1U);
                } else {
#line 3656
                  tmp___2 = 0;
                }
                {
#line 3656
                adjustB = tmp___2;
#line 3658
                __cil_tmp42 = malloc(((size_t )width * (size_t )nr_comp) * 2UL);
#line 3658
                row_buf = (unsigned char *)__cil_tmp42;
#line 3660
                y = 0;
                }
                {
#line 3660
                while (1) {
                  while_continue: /* CIL Label */ ;

#line 3660
                  if (! (y < height)) {
#line 3660
                    goto while_break;
                  }
#line 3662
                  d = row_buf;
#line 3664
                  x = 0;
                  {
#line 3664
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
                    while_continue___0: ;
#line 3664
                    if (! (x < width)) {
#line 3664
                      goto while_break___0;
                    }
#line 3666
                    if (is16) {
#line 3668
                      v = *red + adjustR;
#line 3668
                      red ++;
#line 3669
                      if (v > 65535) {
#line 3669
                        v = 65535;
                      } else
#line 3669
                      if (v < 0) {
#line 3669
                        v = 0;
                      }
#line 3671
                      if (force16) {
#line 3671
                        v = (v << ushift) + (v >> dshift);
                      }
#line 3673
                      __cil_tmp43 = d;
#line 3673
                      d ++;
#line 3673
                      *__cil_tmp43 = (unsigned char )(v >> 8);
#line 3673
                      __cil_tmp44 = d;
#line 3673
                      d ++;
#line 3673
                      *__cil_tmp44 = (unsigned char )v;
#line 3675
                      v = *green + adjustG;
#line 3675
                      green ++;
#line 3676
                      if (v > 65535) {
#line 3676
                        v = 65535;
                      } else
#line 3676
                      if (v < 0) {
#line 3676
                        v = 0;
                      }
#line 3678
                      if (force16) {
#line 3678
                        v = (v << ushift) + (v >> dshift);
                      }
#line 3680
                      __cil_tmp45 = d;
#line 3680
                      d ++;
#line 3680
                      *__cil_tmp45 = (unsigned char )(v >> 8);
#line 3680
                      __cil_tmp46 = d;
#line 3680
                      d ++;
#line 3680
                      *__cil_tmp46 = (unsigned char )v;
#line 3682
                      v = *blue + adjustB;
#line 3682
                      blue ++;
#line 3683
                      if (v > 65535) {
#line 3683
                        v = 65535;
                      } else
#line 3683
                      if (v < 0) {
#line 3683
                        v = 0;
                      }
#line 3685
                      if (force16) {
#line 3685
                        v = (v << ushift) + (v >> dshift);
                      }
#line 3687
                      __cil_tmp47 = d;
#line 3687
                      d ++;
#line 3687
                      *__cil_tmp47 = (unsigned char )(v >> 8);
#line 3687
                      __cil_tmp48 = d;
#line 3687
                      d ++;
#line 3687
                      *__cil_tmp48 = (unsigned char )v;
#line 3689
                      if (has_alpha) {
#line 3691
                        v = *alpha + adjustA;
#line 3691
                        alpha ++;
#line 3692
                        if (v > 65535) {
#line 3692
                          v = 65535;
                        } else
#line 3692
                        if (v < 0) {
#line 3692
                          v = 0;
                        }
#line 3694
                        if (force16) {
#line 3694
                          v = (v << ushift) + (v >> dshift);
                        }
#line 3696
                        __cil_tmp49 = d;
#line 3696
                        d ++;
#line 3696
                        *__cil_tmp49 = (unsigned char )(v >> 8);
#line 3696
                        __cil_tmp50 = d;
#line 3696
                        d ++;
#line 3696
                        *__cil_tmp50 = (unsigned char )v;
                      }
#line 3698
                      goto while_continue___0;
                    }
#line 3701
                    v = *red + adjustR;
#line 3701
                    red ++;
#line 3702
                    if (v > 255) {
#line 3702
                      v = 255;
                    } else
#line 3702
                    if (v < 0) {
#line 3702
                      v = 0;
                    }
#line 3704
                    if (force8) {
#line 3704
                      v = (v << ushift) + (v >> dshift);
                    }
#line 3706
                    __cil_tmp51 = d;
#line 3706
                    d ++;
#line 3706
                    *__cil_tmp51 = (unsigned char )(v & (int )mask);
#line 3708
                    v = *green + adjustG;
#line 3708
                    green ++;
#line 3709
                    if (v > 255) {
#line 3709
                      v = 255;
                    } else
#line 3709
                    if (v < 0) {
#line 3709
                      v = 0;
                    }
#line 3711
                    if (force8) {
#line 3711
                      v = (v << ushift) + (v >> dshift);
                    }
#line 3713
                    __cil_tmp52 = d;
#line 3713
                    d ++;
#line 3713
                    *__cil_tmp52 = (unsigned char )(v & (int )mask);
#line 3715
                    v = *blue + adjustB;
#line 3715
                    blue ++;
#line 3716
                    if (v > 255) {
#line 3716
                      v = 255;
                    } else
#line 3716
                    if (v < 0) {
#line 3716
                      v = 0;
                    }
#line 3718
                    if (force8) {
#line 3718
                      v = (v << ushift) + (v >> dshift);
                    }
#line 3720
                    __cil_tmp53 = d;
#line 3720
                    d ++;
#line 3720
                    *__cil_tmp53 = (unsigned char )(v & (int )mask);
#line 3722
                    if (has_alpha) {
#line 3724
                      v = *alpha + adjustA;
#line 3724
                      alpha ++;
#line 3725
                      if (v > 255) {
#line 3725
                        v = 255;
                      } else
#line 3725
                      if (v < 0) {
#line 3725
                        v = 0;
                      }
#line 3727
                      if (force8) {
#line 3727
                        v = (v << ushift) + (v >> dshift);
                      }
#line 3729
                      __cil_tmp54 = d;
#line 3729
                      d ++;
#line 3729
                      *__cil_tmp54 = (unsigned char )(v & (int )mask);
                    }
#line 3664
                    x ++;
                  }
                  while_break___6: /* CIL Label */ ;
                  }
                  while_break___0: 
                  {
#line 3733
                  png_write_row(png, row_buf);
#line 3660
                  y ++;
                  }
                }
                while_break___5: /* CIL Label */ ;
                }
                while_break: 
                {
#line 3736
                free((void *)row_buf);
                }
              } else {
#line 3598
                goto _L___57;
              }
            } else {
#line 3598
              goto _L___57;
            }
          } else {
#line 3598
            goto _L___57;
          }
        } else {
#line 3598
          goto _L___57;
        }
      } else {
#line 3598
        goto _L___57;
      }
    } else {
#line 3598
      goto _L___57;
    }
  } else
  _L___57: 
#line 3740
  if (nr_comp == 1) {
    _L___56: 
#line 3748
    red = (image->comps + 0)->data;
#line 3750
    sig_bit.gray = (png_byte )prec;
#line 3751
    sig_bit.alpha = (png_byte )0;
#line 3751
    sig_bit.blue = sig_bit.alpha;
#line 3751
    sig_bit.green = sig_bit.blue;
#line 3751
    sig_bit.red = sig_bit.green;
#line 3752
    alpha = (int *)((void *)0);
#line 3752
    adjustA = 0;
#line 3753
    color_type = 0;
#line 3755
    if (nr_comp == 2) {
#line 3757
      has_alpha = 1;
#line 3757
      sig_bit.alpha = (png_byte )prec;
#line 3758
      alpha = (image->comps + 1)->data;
#line 3759
      color_type = 4;
#line 3760
      if ((image->comps + 1)->sgnd) {
#line 3760
        tmp___3 = 1 << ((image->comps + 1)->prec - 1U);
      } else {
#line 3760
        tmp___3 = 0;
      }
#line 3760
      adjustA = tmp___3;
    }
    {
#line 3762
    width = (int )(image->comps + 0)->w;
#line 3763
    height = (int )(image->comps + 0)->h;
#line 3765
    png_set_IHDR(png, info, (png_uint_32 )width, (png_uint_32 )height, (int )sig_bit.gray,
                 color_type, 0, 0, 0);
#line 3770
    png_set_sBIT(png, info, & sig_bit);
#line 3772
    png_set_gamma(png, 2.20000000001, 1. / 2.20000000001);
#line 3773
    png_set_sRGB(png, info, 0);
#line 3775
    png_write_info(png, info);
    }
#line 3777
    if ((image->comps + 0)->sgnd) {
#line 3777
      tmp___4 = 1 << ((image->comps + 0)->prec - 1U);
    } else {
#line 3777
      tmp___4 = 0;
    }
#line 3777
    adjustR = tmp___4;
#line 3779
    if (prec < 8) {
      {
#line 3781
      png_set_packing(png);
      }
    }
#line 3784
    if (prec > 8) {
      {
#line 3786
      __cil_tmp58 = malloc(((size_t )width * (size_t )nr_comp) * sizeof(unsigned short ));
#line 3786
      row_buf = (unsigned char *)__cil_tmp58;
#line 3789
      y = 0;
      }
      {
#line 3789
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 3789
        if (! (y < height)) {
#line 3789
          goto while_break___1;
        }
#line 3791
        d = row_buf;
#line 3793
        x = 0;
        {
#line 3793
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 3793
          if (! (x < width)) {
#line 3793
            goto while_break___2;
          }
#line 3795
          v___0 = *red + adjustR;
#line 3795
          red ++;
#line 3796
          if (v___0 > 65535) {
#line 3796
            v___0 = 65535;
          } else
#line 3796
          if (v___0 < 0) {
#line 3796
            v___0 = 0;
          }
#line 3798
          if (force16) {
#line 3798
            v___0 = (v___0 << ushift) + (v___0 >> dshift);
          }
#line 3800
          __cil_tmp59 = d;
#line 3800
          d ++;
#line 3800
          *__cil_tmp59 = (unsigned char )(v___0 >> 8);
#line 3800
          __cil_tmp60 = d;
#line 3800
          d ++;
#line 3800
          *__cil_tmp60 = (unsigned char )v___0;
#line 3802
          if (has_alpha) {
#line 3804
            __cil_tmp61 = alpha;
#line 3804
            alpha ++;
#line 3804
            v___0 = *__cil_tmp61;
#line 3805
            if (v___0 > 65535) {
#line 3805
              v___0 = 65535;
            } else
#line 3805
            if (v___0 < 0) {
#line 3805
              v___0 = 0;
            }
#line 3807
            if (force16) {
#line 3807
              v___0 = (v___0 << ushift) + (v___0 >> dshift);
            }
#line 3809
            __cil_tmp62 = d;
#line 3809
            d ++;
#line 3809
            *__cil_tmp62 = (unsigned char )(v___0 >> 8);
#line 3809
            __cil_tmp63 = d;
#line 3809
            d ++;
#line 3809
            *__cil_tmp63 = (unsigned char )v___0;
          }
#line 3793
          x ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: 
        {
#line 3812
        png_write_row(png, row_buf);
#line 3789
        y ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 3815
      free((void *)row_buf);
      }
    } else {
      {
#line 3819
      __cil_tmp64 = calloc((size_t )width, (size_t )nr_comp * 2UL);
#line 3819
      row_buf = (unsigned char *)__cil_tmp64;
#line 3821
      y = 0;
      }
      {
#line 3821
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 3821
        if (! (y < height)) {
#line 3821
          goto while_break___3;
        }
#line 3823
        d = row_buf;
#line 3825
        x = 0;
        {
#line 3825
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 3825
          if (! (x < width)) {
#line 3825
            goto while_break___4;
          }
#line 3827
          v___0 = *red + adjustR;
#line 3827
          red ++;
#line 3828
          if (v___0 > 255) {
#line 3828
            v___0 = 255;
          } else
#line 3828
          if (v___0 < 0) {
#line 3828
            v___0 = 0;
          }
#line 3830
          if (force8) {
#line 3830
            v___0 = (v___0 << ushift) + (v___0 >> dshift);
          }
#line 3832
          __cil_tmp65 = d;
#line 3832
          d ++;
#line 3832
          *__cil_tmp65 = (unsigned char )(v___0 & (int )mask);
#line 3834
          if (has_alpha) {
#line 3836
            v___0 = *alpha + adjustA;
#line 3836
            alpha ++;
#line 3837
            if (v___0 > 255) {
#line 3837
              v___0 = 255;
            } else
#line 3837
            if (v___0 < 0) {
#line 3837
              v___0 = 0;
            }
#line 3839
            if (force8) {
#line 3839
              v___0 = (v___0 << ushift) + (v___0 >> dshift);
            }
#line 3841
            __cil_tmp66 = d;
#line 3841
            d ++;
#line 3841
            *__cil_tmp66 = (unsigned char )(v___0 & (int )mask);
          }
#line 3825
          x ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___4: 
        {
#line 3845
        png_write_row(png, row_buf);
#line 3821
        y ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: 
      {
#line 3848
      free((void *)row_buf);
      }
    }
  } else
#line 3740
  if (nr_comp == 2) {
#line 3740
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 3740
      if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 3740
        if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 3740
          goto _L___56;
        } else {
          {
#line 3853
          fprintf(stderr, "imagetopng: can not create %s\n", write_idf);
          }
#line 3854
          goto fin;
        }
      } else {
        {
#line 3853
        fprintf(stderr, "imagetopng: can not create %s\n", write_idf);
        }
#line 3854
        goto fin;
      }
    } else {
      {
#line 3853
      fprintf(stderr, "imagetopng: can not create %s\n", write_idf);
      }
#line 3854
      goto fin;
    }
  } else {
    {
#line 3853
    fprintf(stderr, "imagetopng: can not create %s\n", write_idf);
    }
#line 3854
    goto fin;
  }
  {
#line 3856
  png_write_end(png, info);
#line 3858
  fails = 0;
  }
  fin: 
#line 3862
  if (png) {
    {
#line 3864
    png_destroy_write_struct(& png, & info);
    }
  }
  {
#line 3866
  fclose(writer);
  }
#line 3868
  if (fails) {
    {
#line 3868
    remove(write_idf);
    }
  }
#line 3870
  return (fails);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 18 "/root/patchweave_new/10/src/bin/common/opj_getopt.h"
int opj_opterr ;
#line 19
int opj_optind ;
#line 20 "/root/patchweave_new/10/src/bin/common/opj_getopt.h"
int opj_optopt  ;
#line 21 "/root/patchweave_new/10/src/bin/common/opj_getopt.h"
int opj_optreset  ;
#line 22 "/root/patchweave_new/10/src/bin/common/opj_getopt.h"
char *opj_optarg  ;
#line 24
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 25
int opj_getopt_long(int argc , char * const  *argv , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) ;
#line 27
void opj_reset_options_reading(void) ;
#line 41 "/root/patchweave_new/10/src/bin/common/color.h"
void color_sycc_to_rgb(opj_image_t *img ) ;
#line 149 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
int get_num_images(char *imgdirpath ) ;
#line 150
int load_images(dircnt_t *dirptr , char *imgdirpath ) ;
#line 151
int get_file_format(char const   *filename ) ;
#line 152
char get_next_file(int imageno , dircnt_t *dirptr , img_fol_t *img_fol , opj_decompress_parameters *parameters ) ;
#line 153
static int infile_format(char const   *fname ) ;
#line 155
int parse_cmdline_decoder(int argc , char **argv , opj_decompress_parameters *parameters ,
                          img_fol_t *img_fol , char *indexfilename ) ;
#line 156
int parse_DA_values(char *inArg , unsigned int *DA_x0 , unsigned int *DA_y0 , unsigned int *DA_x1 ,
                    unsigned int *DA_y1 ) ;
#line 158
static opj_image_t *convert_gray_to_rgb(opj_image_t *original ) ;
#line 161 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
static void decode_help_display(void) 
{ 
  char const   *__cil_tmp1 ;

  {
  {
#line 162
  __cil_tmp1 = opj_version();
#line 162
  fprintf(stdout, "\nThis is the opj_decompress utility from the OpenJPEG project.\nIt decompresses JPEG 2000 codestreams to various image formats.\nIt has been compiled against openjp2 library v%s.\n\n",
          __cil_tmp1);
#line 166
  fprintf(stdout, "Parameters:\n-----------\n\n  -ImgDir <directory> \n\tImage file Directory path \n  -OutFor <PBM|PGM|PPM|PNM|PAM|PGX|PNG|BMP|TIF|RAW|RAWL|TGA>\n    REQUIRED only if -ImgDir is used\n\tOutput format for decompressed images.\n  -i <compressed file>\n    REQUIRED only if an Input image directory is not specified\n    Currently accepts J2K-files, JP2-files and JPT-files. The file type\n    is identified based on its suffix.\n  -o <decompressed file>\n    REQUIRED\n    Currently accepts formats specified above (see OutFor option)\n    Binary data is written to the file (not ascii). If a PGX\n    filename is given, there will be as many output files as there are\n    components: an indice starting from 0 will then be appended to the\n    output filename, just before the \"pgx\" extension. If a PGM filename\n    is given and there are more than one component, only the first component\n    will be written to the file.\n  -r <reduce factor>\n    Set the number of highest resolution levels to be discarded. The\n    image resolution is effectively divided by 2 to the power of the\n    number of discarded levels. The reduce factor is limited by the\n    smallest total number of decomposition levels among tiles.\n  -l <number of quality layers to decode>\n    Set the maximum number of quality layers to decode. If there are\n    less quality layers than the specified number, all the quality layers\n    are decoded.\n  -x  \n    Create an index file *.Idx (-x index_name.Idx) \n  -d <x0,y0,x1,y1>\n    OPTIONAL\n    Decoding area\n    By default all the image is decoded.\n  -t <tile_number>\n    OPTIONAL\n    Set the tile number of the decoded tile. Follow the JPEG2000 convention from left-up to bottom-up\n    By default all tiles are decoded.\n  -p <comp 0 precision>[C|S][,<comp 1 precision>[C|S][,...]]\n    OPTIONAL\n    Force the precision (bit depth) of components.\n    There shall be at least 1 value. Theres no limit on the number of values (comma separated, last values ignored if too much values).\n    If there are less values than components, the last value is used for remaining components.\n    If \'C\' is specified (default), values are clipped.\n    If \'S\' is specified, values are scaled.\n    A 0 value can be specified (meaning original bit depth).\n  -force-rgb\n    Force output image colorspace to RGB\n  -upsample\n    Downsampled components will be upsampled to image size\n\n");
#line 229
  fprintf(stdout, "\n");
  }
#line 231
  return;
}
}
#line 234 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
static OPJ_BOOL parse_precision(char const   *option , opj_decompress_parameters *parameters ) 
{ 
  char const   *l_remaining ;
  OPJ_BOOL l_result ;
  OPJ_UINT32 prec ;
  char mode ;
  char comma ;
  int count ;
  OPJ_UINT32 l_new_size ;
  opj_precision *l_new ;
  char *__cil_tmp16 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 236
  l_remaining = option;
#line 237
  l_result = 1;
#line 240
  if (parameters->precision) {
    {
#line 241
    free((void *)parameters->precision);
#line 242
    parameters->precision = (opj_precision *)((void *)0);
    }
  }
#line 244
  parameters->nb_precision = 0U;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 253
    count = sscanf(l_remaining, "%d%c%c", & prec, & mode, & comma);
    }
#line 254
    if (count == 1) {
#line 255
      mode = (char )'C';
#line 256
      count ++;
    }
#line 258
    if (count == 2) {
      _L: 
#line 259
      if ((int )mode == 44) {
#line 260
        mode = (char )'C';
      }
#line 262
      comma = (char )',';
#line 263
      count = 3;
    } else
#line 258
    if ((int )mode == 44) {
#line 258
      goto _L;
    }
#line 265
    if (count == 3) {
#line 266
      if (prec > 32U) {
        {
#line 267
        fprintf(stderr, "Invalid precision %d in precision option %s\n", prec, option);
#line 268
        l_result = 0;
        }
#line 269
        goto while_break;
      }
#line 271
      if ((int )mode != 67) {
#line 271
        if ((int )mode != 83) {
          {
#line 272
          fprintf(stderr, "Invalid precision mode %c in precision option %s\n", (int )mode,
                  option);
#line 273
          l_result = 0;
          }
#line 274
          goto while_break;
        }
      }
#line 276
      if ((int )comma != 44) {
        {
#line 277
        fprintf(stderr, "Invalid character %c in precision option %s\n", (int )comma,
                option);
#line 278
        l_result = 0;
        }
#line 279
        goto while_break;
      }
#line 282
      if ((unsigned long )parameters->precision == (unsigned long )((void *)0)) {
        {
#line 284
        tmp = malloc(sizeof(opj_precision ));
#line 284
        parameters->precision = (opj_precision *)tmp;
        }
#line 285
        if ((unsigned long )parameters->precision == (unsigned long )((void *)0)) {
          {
#line 286
          fprintf(stderr, "Could not allocate memory for precision option\n");
#line 287
          l_result = 0;
          }
#line 288
          goto while_break;
        }
      } else {
#line 291
        l_new_size = parameters->nb_precision + 1U;
#line 294
        if (l_new_size == 0U) {
          {
#line 295
          fprintf(stderr, "Could not allocate memory for precision option\n");
#line 296
          l_result = 0;
          }
#line 297
          goto while_break;
        }
        {
#line 300
        tmp___0 = realloc((void *)parameters->precision, (unsigned long )l_new_size * sizeof(opj_precision ));
#line 300
        l_new = (opj_precision *)tmp___0;
        }
#line 301
        if ((unsigned long )l_new == (unsigned long )((void *)0)) {
          {
#line 302
          fprintf(stderr, "Could not allocate memory for precision option\n");
#line 303
          l_result = 0;
          }
#line 304
          goto while_break;
        }
#line 306
        parameters->precision = l_new;
      }
#line 309
      (parameters->precision + parameters->nb_precision)->prec = prec;
#line 311
      if ((int )mode == 67) {
#line 311
        goto case_67;
      }
#line 314
      if ((int )mode == 83) {
#line 314
        goto case_83;
      }
#line 317
      goto switch_default;
      case_67: 
#line 312
      (parameters->precision + parameters->nb_precision)->mode = (opj_precision_mode )0;
#line 313
      goto switch_break;
      case_83: 
#line 315
      (parameters->precision + parameters->nb_precision)->mode = (opj_precision_mode )1;
#line 316
      goto switch_break;
      switch_default: 
#line 318
      goto switch_break;
      switch_break: 
      {
#line 320
      (parameters->nb_precision) ++;
#line 322
      __cil_tmp16 = strchr(l_remaining, ',');
#line 322
      l_remaining = (char const   *)__cil_tmp16;
      }
#line 323
      if ((unsigned long )l_remaining == (unsigned long )((void *)0)) {
#line 324
        goto while_break;
      }
#line 326
      l_remaining ++;
    } else {
      {
#line 328
      fprintf(stderr, "Could not parse precision option %s\n", option);
#line 329
      l_result = 0;
      }
#line 330
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 334
  return (l_result);
}
}
#line 339 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
int get_num_images(char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int num_images ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 342
  num_images = 0;
#line 346
  dir = opendir((char const   *)imgdirpath);
  }
#line 347
  if (! dir) {
    {
#line 348
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 349
    return (0);
  }
  {
#line 352
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 352
    content = readdir(dir);
    }
#line 352
    if (! ((unsigned long )content != (unsigned long )((void *)0))) {
#line 352
      goto while_break;
    }
    {
#line 353
    __cil_tmp8 = strcmp("..", (char const   *)(content->d_name));
#line 353
    __cil_tmp7 = strcmp(".", (char const   *)(content->d_name));
    }
#line 353
    if (__cil_tmp7 == 0) {
#line 354
      goto while_continue;
    } else
#line 353
    if (__cil_tmp8 == 0) {
#line 354
      goto while_continue;
    }
#line 355
    num_images ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 357
  return (num_images);
}
}
#line 361 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
int load_images(dircnt_t *dirptr , char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int i ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 364
  i = 0;
#line 368
  dir = opendir((char const   *)imgdirpath);
  }
#line 369
  if (! dir) {
    {
#line 370
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 371
    return (1);
  } else {
    {
#line 373
    fprintf(stderr, "Folder opened successfully\n");
    }
  }
  {
#line 376
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 376
    content = readdir(dir);
    }
#line 376
    if (! ((unsigned long )content != (unsigned long )((void *)0))) {
#line 376
      goto while_break;
    }
    {
#line 377
    __cil_tmp9 = strcmp("..", (char const   *)(content->d_name));
#line 377
    __cil_tmp8 = strcmp(".", (char const   *)(content->d_name));
    }
#line 377
    if (__cil_tmp8 == 0) {
#line 378
      goto while_continue;
    } else
#line 377
    if (__cil_tmp9 == 0) {
#line 378
      goto while_continue;
    }
    {
#line 380
    strcpy(*(dirptr->filename + i), (char const   *)(content->d_name));
#line 381
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 383
  return (0);
}
}
#line 390 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
static char const   *extension[15]  ;
#line 391 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
static int const   format[15]  ;
#line 387 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
int get_file_format(char const   *filename ) 
{ 
  unsigned int i ;
  char *ext ;
  char *__cil_tmp6 ;
  int __cil_tmp8 ;

  {
  {
#line 389
  strcpy((char *)extension[0], "pgx");
#line 389
  strcpy((char *)extension[1], "pnm");
#line 389
  strcpy((char *)extension[2], "pgm");
#line 389
  strcpy((char *)extension[3], "ppm");
#line 389
  strcpy((char *)extension[4], "bmplEV");
#line 389
  strcpy((char *)extension[5], "tiflEV");
#line 389
  strcpy((char *)extension[6], "rawlEV");
#line 389
  strcpy((char *)extension[7], "rawlEV");
#line 389
  strcpy((char *)extension[8], "tgalEV");
#line 389
  strcpy((char *)extension[9], "pnglEV");
#line 389
  strcpy((char *)extension[10], "j2klEV");
#line 389
  strcpy((char *)extension[11], "jp2lEV");
#line 389
  strcpy((char *)extension[12], "jptlEV");
#line 389
  strcpy((char *)extension[13], "j2clEV");
#line 389
  strcpy((char *)extension[14], "jpclEV");
#line 390
  format[0] = (int const   )11;
#line 390
  format[1] = (int const   )10;
#line 390
  format[2] = (int const   )10;
#line 390
  format[3] = (int const   )10;
#line 390
  format[4] = (int const   )12;
#line 390
  format[5] = (int const   )14;
#line 390
  format[6] = (int const   )15;
#line 390
  format[7] = (int const   )18;
#line 390
  format[8] = (int const   )16;
#line 390
  format[9] = (int const   )17;
#line 390
  format[10] = (int const   )0;
#line 390
  format[11] = (int const   )1;
#line 390
  format[12] = (int const   )2;
#line 390
  format[13] = (int const   )0;
#line 390
  format[14] = (int const   )0;
#line 391
  __cil_tmp6 = strrchr(filename, '.');
#line 391
  ext = __cil_tmp6;
  }
#line 392
  if ((unsigned long )ext == (unsigned long )((void *)0)) {
#line 393
    return (-1);
  }
#line 394
  ext ++;
#line 395
  if (*ext) {
#line 396
    i = 0U;
    {
#line 396
    while (1) {
      while_continue: /* CIL Label */ ;

#line 396
      if (! ((unsigned long )i < sizeof(format) / sizeof(format[0]))) {
#line 396
        goto while_break;
      }
      {
#line 397
      __cil_tmp8 = strcasecmp((char const   *)ext, extension[i]);
      }
#line 397
      if (__cil_tmp8 == 0) {
#line 398
        return ((int )format[i]);
      }
#line 396
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 403
  return (-1);
}
}
#line 407 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
char get_next_file(int imageno , dircnt_t *dirptr , img_fol_t *img_fol , opj_decompress_parameters *parameters ) 
{ 
  char image_filename[4096] ;
  char infilename[4096] ;
  char outfilename[4096] ;
  char temp_ofname[4096] ;
  char *temp_p ;
  char temp1[4096] ;
  char *__cil_tmp12 ;

  {
  {
#line 409
  strcpy(temp1, "\002");
#line 411
  strcpy(image_filename, (char const   *)*(dirptr->filename + imageno));
#line 412
  fprintf(stderr, "File Number %d \"%s\"\nEV", imageno, image_filename);
#line 413
  parameters->decod_format = infile_format((char const   *)(image_filename));
  }
#line 414
  if (parameters->decod_format == -1) {
#line 415
    return ((char)1);
  }
  {
#line 416
  sprintf(infilename, "%s/%sV", img_fol->imgdirpath, image_filename);
#line 417
  strncpy(parameters->infile, (char const   *)(infilename), sizeof(infilename));
#line 420
  __cil_tmp12 = strtok(image_filename, ".");
#line 420
  strcpy(temp_ofname, (char const   *)__cil_tmp12);
  }
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 421
    temp_p = strtok((char *)((void *)0), ".");
    }
#line 421
    if (! ((unsigned long )temp_p != (unsigned long )((void *)0))) {
#line 421
      goto while_break;
    }
    {
#line 422
    strcat(temp_ofname, (char const   *)(temp1));
#line 423
    sprintf(temp1, ".%s", temp_p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 425
  if ((int )img_fol->set_out_format == 1) {
    {
#line 426
    sprintf(outfilename, "%s/%s.%s\230\001", img_fol->imgdirpath, temp_ofname, img_fol->out_format);
#line 427
    strncpy(parameters->outfile, (char const   *)(outfilename), sizeof(outfilename));
    }
  }
#line 429
  return ((char)0);
}
}
#line 438 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
static int infile_format(char const   *fname ) 
{ 
  FILE *reader ;
  char const   *s ;
  char const   *magic_s ;
  int ext_format ;
  int magic_format ;
  unsigned char buf[12] ;
  OPJ_SIZE_T l_nb_read ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;

  {
  {
#line 446
  reader = fopen(fname, "rbllEV");
  }
#line 448
  if ((unsigned long )reader == (unsigned long )((void *)0)) {
#line 449
    return (-2);
  }
  {
#line 451
  memset((void *)(buf), 0, 12UL);
#line 452
  l_nb_read = fread((void *)(buf), 1UL, 12UL, reader);
#line 453
  fclose(reader);
  }
#line 454
  if (l_nb_read != 12UL) {
#line 455
    return (-1);
  }
  {
#line 459
  ext_format = get_file_format(fname);
  }
#line 461
  if (ext_format == 2) {
#line 462
    return (2);
  }
  {
#line 464
  __cil_tmp13 = memcmp((void const   *)(buf), (void const   *)"\r\n\207\n", 4UL);
#line 464
  __cil_tmp12 = memcmp((void const   *)(buf), (void const   *)"", 12UL);
  }
#line 464
  if (__cil_tmp12 == 0) {
    {
#line 465
    magic_format = 1;
#line 466
    strcpy((char *)magic_s, ".jp2");
    }
  } else
#line 464
  if (__cil_tmp13 == 0) {
    {
#line 465
    magic_format = 1;
#line 466
    strcpy((char *)magic_s, ".jp2");
    }
  } else {
    {
#line 468
    __cil_tmp14 = memcmp((void const   *)(buf), (void const   *)"\377O\377QEV", 4UL);
    }
#line 468
    if (__cil_tmp14 == 0) {
      {
#line 469
      magic_format = 0;
#line 470
      strcpy((char *)magic_s, ".j2k or .jpc or .j2c");
      }
    } else {
#line 473
      return (-1);
    }
  }
#line 475
  if (magic_format == ext_format) {
#line 476
    return (ext_format);
  }
  {
#line 478
  __cil_tmp15 = strlen(fname);
#line 478
  s = (fname + __cil_tmp15) - 4;
#line 480
  fputs("\n===========================================\n", stderr);
#line 481
  fprintf(stderr, "The extension of this file is incorrect.\nFOUND %s. SHOULD BE %s\n",
          s, magic_s);
#line 483
  fputs("===========================================\n", stderr);
  }
#line 485
  return (magic_format);
}
}
#line 493 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
int parse_cmdline_decoder(int argc , char **argv , opj_decompress_parameters *parameters ,
                          img_fol_t *img_fol , char *indexfilename ) 
{ 
  int totlen ;
  int c ;
  opj_option_t long_option[4] ;
  char optlist[18] ;
  char *infile ;
  char *outfile ;
  char outformat[50] ;
  char *of ;
  unsigned long __cil_tmp18 ;
  void *__cil_tmp19 ;
  int size_optarg ;
  unsigned long __cil_tmp21 ;
  char *ROI_values ;
  void *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  char *index___63 ;
  OPJ_BOOL __cil_tmp27 ;

  {
  {
#line 496
  strcpy((char *)long_option[0].name, "ImgDir");
#line 496
  long_option[0].has_arg = 1;
#line 496
  long_option[0].flag = (int *)((void *)0);
#line 496
  long_option[0].val = 'y';
#line 496
  strcpy((char *)long_option[1].name, "OutFor");
#line 496
  long_option[1].has_arg = 1;
#line 496
  long_option[1].flag = (int *)((void *)0);
#line 496
  long_option[1].val = 'O';
#line 496
  strcpy((char *)long_option[2].name, "force-rgb");
#line 496
  long_option[2].has_arg = 0;
#line 496
  long_option[2].flag = & parameters->force_rgb;
#line 496
  long_option[2].val = 1;
#line 496
  strcpy((char *)long_option[3].name, "upsample\251");
#line 496
  long_option[3].has_arg = 0;
#line 496
  long_option[3].flag = & parameters->upsample;
#line 496
  long_option[3].val = 1;
#line 503
  strcpy(optlist, "i:o:r:l:x:d:t:p:h");
#line 511
  totlen = (int )sizeof(long_option);
#line 512
  opj_reset_options_reading();
#line 513
  img_fol->set_out_format = (char)0;
  }
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 515
    c = opj_getopt_long(argc, argv, (char const   *)(optlist), long_option, totlen);
    }
#line 516
    if (c == -1) {
#line 517
      goto while_break;
    }
#line 519
    if (c == 0) {
#line 519
      goto case_0;
    }
#line 521
    if (c == 105) {
#line 521
      goto case_105;
    }
#line 526
    if (c == 0) {
#line 526
      goto case_0___0;
    }
#line 528
    if (c == 1) {
#line 528
      goto case_1;
    }
#line 530
    if (c == 2) {
#line 530
      goto case_2;
    }
#line 532
    if (c == -2) {
#line 532
      goto case_exp;
    }
#line 550
    if (c == 111) {
#line 550
      goto case_111;
    }
#line 555
    if (c == 11) {
#line 555
      goto case_11;
    }
#line 557
    if (c == 10) {
#line 557
      goto case_10;
    }
#line 559
    if (c == 12) {
#line 559
      goto case_12;
    }
#line 561
    if (c == 14) {
#line 561
      goto case_14;
    }
#line 563
    if (c == 15) {
#line 563
      goto case_15;
    }
#line 565
    if (c == 18) {
#line 565
      goto case_18;
    }
#line 567
    if (c == 16) {
#line 567
      goto case_16;
    }
#line 569
    if (c == 17) {
#line 569
      goto case_17;
    }
#line 581
    if (c == 79) {
#line 581
      goto case_79;
    }
#line 589
    if (c == 11) {
#line 589
      goto case_11___0;
    }
#line 592
    if (c == 10) {
#line 592
      goto case_10___0;
    }
#line 595
    if (c == 12) {
#line 595
      goto case_12___0;
    }
#line 598
    if (c == 14) {
#line 598
      goto case_14___0;
    }
#line 601
    if (c == 15) {
#line 601
      goto case_15___0;
    }
#line 604
    if (c == 18) {
#line 604
      goto case_18___0;
    }
#line 607
    if (c == 16) {
#line 607
      goto case_16___0;
    }
#line 610
    if (c == 17) {
#line 610
      goto case_17___0;
    }
#line 624
    if (c == 114) {
#line 624
      goto case_114;
    }
#line 633
    if (c == 108) {
#line 633
      goto case_108;
    }
#line 641
    if (c == 104) {
#line 641
      goto case_104;
    }
#line 647
    if (c == 121) {
#line 647
      goto case_121;
    }
#line 657
    if (c == 100) {
#line 657
      goto case_100;
    }
#line 673
    if (c == 116) {
#line 673
      goto case_116;
    }
#line 682
    if (c == 120) {
#line 682
      goto case_120;
    }
#line 690
    if (c == 112) {
#line 690
      goto case_112;
    }
#line 773
    goto switch_default___2;
    case_0: 
#line 520
    goto switch_break;
    case_105: 
    {
#line 523
    infile = opj_optarg;
#line 524
    parameters->decod_format = infile_format((char const   *)infile);
    }
#line 526
    if (parameters->decod_format == 0) {
#line 526
      goto case_0___0;
    }
#line 528
    if (parameters->decod_format == 1) {
#line 528
      goto case_1;
    }
#line 530
    if (parameters->decod_format == 2) {
#line 530
      goto case_2;
    }
#line 532
    if (parameters->decod_format == -2) {
#line 532
      goto case_exp;
    }
#line 537
    goto switch_default;
    case_0___0: 
#line 527
    goto switch_break___0;
    case_1: 
#line 529
    goto switch_break___0;
    case_2: 
#line 531
    goto switch_break___0;
    case_exp: 
    {
#line 533
    fprintf(stderr, "!! infile cannot be read: %s !!\n\n", infile);
    }
#line 536
    return (1);
    switch_default: 
    {
#line 538
    fprintf(stderr, "[ERROR] Unknown input file format: %s \n        Known file formats are *.j2k, *.jp2, *.jpc or *.jpt\n",
            infile);
    }
#line 542
    return (1);
    switch_break___0: 
    {
#line 544
    strncpy(parameters->infile, (char const   *)infile, sizeof(parameters->infile) - 1UL);
    }
#line 546
    goto switch_break;
    case_111: 
    {
#line 552
    outfile = opj_optarg;
#line 553
    parameters->cod_format = get_file_format((char const   *)outfile);
    }
#line 555
    if (parameters->cod_format == 11) {
#line 555
      goto case_11;
    }
#line 557
    if (parameters->cod_format == 10) {
#line 557
      goto case_10;
    }
#line 559
    if (parameters->cod_format == 12) {
#line 559
      goto case_12;
    }
#line 561
    if (parameters->cod_format == 14) {
#line 561
      goto case_14;
    }
#line 563
    if (parameters->cod_format == 15) {
#line 563
      goto case_15;
    }
#line 565
    if (parameters->cod_format == 18) {
#line 565
      goto case_18;
    }
#line 567
    if (parameters->cod_format == 16) {
#line 567
      goto case_16;
    }
#line 569
    if (parameters->cod_format == 17) {
#line 569
      goto case_17;
    }
#line 571
    goto switch_default___0;
    case_11: 
#line 556
    goto switch_break___1;
    case_10: 
#line 558
    goto switch_break___1;
    case_12: 
#line 560
    goto switch_break___1;
    case_14: 
#line 562
    goto switch_break___1;
    case_15: 
#line 564
    goto switch_break___1;
    case_18: 
#line 566
    goto switch_break___1;
    case_16: 
#line 568
    goto switch_break___1;
    case_17: 
#line 570
    goto switch_break___1;
    switch_default___0: 
    {
#line 572
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \nTlEV",
            outfile);
    }
#line 573
    return (1);
    switch_break___1: 
    {
#line 575
    strncpy(parameters->outfile, (char const   *)outfile, sizeof(parameters->outfile) - 1UL);
    }
#line 577
    goto switch_break;
    case_79: 
    {
#line 584
    of = opj_optarg;
#line 585
    sprintf(outformat, ".%slEV", of);
#line 586
    img_fol->set_out_format = (char)1;
#line 587
    parameters->cod_format = get_file_format((char const   *)(outformat));
    }
#line 589
    if (parameters->cod_format == 11) {
#line 589
      goto case_11___0;
    }
#line 592
    if (parameters->cod_format == 10) {
#line 592
      goto case_10___0;
    }
#line 595
    if (parameters->cod_format == 12) {
#line 595
      goto case_12___0;
    }
#line 598
    if (parameters->cod_format == 14) {
#line 598
      goto case_14___0;
    }
#line 601
    if (parameters->cod_format == 15) {
#line 601
      goto case_15___0;
    }
#line 604
    if (parameters->cod_format == 18) {
#line 604
      goto case_18___0;
    }
#line 607
    if (parameters->cod_format == 16) {
#line 607
      goto case_16___0;
    }
#line 610
    if (parameters->cod_format == 17) {
#line 610
      goto case_17___0;
    }
#line 613
    goto switch_default___1;
    case_11___0: 
    {
#line 590
    strcpy((char *)img_fol->out_format, "pgxlEV");
    }
#line 591
    goto switch_break___2;
    case_10___0: 
    {
#line 593
    strcpy((char *)img_fol->out_format, "ppm");
    }
#line 594
    goto switch_break___2;
    case_12___0: 
    {
#line 596
    strcpy((char *)img_fol->out_format, "bmp");
    }
#line 597
    goto switch_break___2;
    case_14___0: 
    {
#line 599
    strcpy((char *)img_fol->out_format, "tif");
    }
#line 600
    goto switch_break___2;
    case_15___0: 
    {
#line 602
    strcpy((char *)img_fol->out_format, "raw");
    }
#line 603
    goto switch_break___2;
    case_18___0: 
    {
#line 605
    strcpy((char *)img_fol->out_format, "rawl");
    }
#line 606
    goto switch_break___2;
    case_16___0: 
    {
#line 608
    strcpy((char *)img_fol->out_format, "raw");
    }
#line 609
    goto switch_break___2;
    case_17___0: 
    {
#line 611
    strcpy((char *)img_fol->out_format, "png");
    }
#line 612
    goto switch_break___2;
    switch_default___1: 
    {
#line 614
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n",
            outformat);
    }
#line 615
    return (1);
#line 616
    goto switch_break___2;
    switch_break___2: ;
#line 619
    goto switch_break;
    case_114: 
    {
#line 626
    sscanf((char const   *)opj_optarg, "%ud", & parameters->core.cp_reduce);
    }
#line 628
    goto switch_break;
    case_108: 
    {
#line 635
    sscanf((char const   *)opj_optarg, "%ud", & parameters->core.cp_layer);
    }
#line 637
    goto switch_break;
    case_104: 
    {
#line 642
    decode_help_display();
    }
#line 643
    return (1);
    case_121: 
    {
#line 649
    __cil_tmp18 = strlen((char const   *)opj_optarg);
#line 649
    __cil_tmp19 = malloc(__cil_tmp18 + 1UL);
#line 649
    img_fol->imgdirpath = (char *)__cil_tmp19;
#line 650
    strcpy(img_fol->imgdirpath, (char const   *)opj_optarg);
#line 651
    img_fol->set_imgdir = (char)1;
    }
#line 653
    goto switch_break;
    case_100: 
    {
#line 659
    __cil_tmp21 = strlen((char const   *)opj_optarg);
#line 659
    size_optarg = (int )__cil_tmp21 + 1;
#line 660
    __cil_tmp23 = malloc((size_t )size_optarg);
#line 660
    ROI_values = (char *)__cil_tmp23;
#line 661
    *(ROI_values + 0) = (char )'\000';
#line 662
    __cil_tmp24 = strlen((char const   *)opj_optarg);
#line 662
    strncpy(ROI_values, (char const   *)opj_optarg, __cil_tmp24);
#line 663
    __cil_tmp25 = strlen((char const   *)opj_optarg);
#line 663
    *(ROI_values + __cil_tmp25) = (char )'\000';
#line 665
    parse_DA_values(ROI_values, & parameters->DA_x0, & parameters->DA_y0, & parameters->DA_x1,
                    & parameters->DA_y1);
#line 667
    free((void *)ROI_values);
    }
#line 669
    goto switch_break;
    case_116: 
    {
#line 675
    sscanf((char const   *)opj_optarg, "%ud", & parameters->tile_index);
#line 676
    parameters->nb_tile_to_decode = (OPJ_UINT32 )1;
    }
#line 678
    goto switch_break;
    case_120: 
    {
#line 684
    index___63 = opj_optarg;
#line 685
    strncpy(indexfilename, (char const   *)index___63, 4096UL);
    }
#line 687
    goto switch_break;
    case_112: 
    {
#line 692
    __cil_tmp27 = parse_precision((char const   *)opj_optarg, parameters);
    }
#line 692
    if (! __cil_tmp27) {
#line 694
      return (1);
    }
#line 697
    goto switch_break;
    switch_default___2: 
    {
#line 774
    fprintf(stderr, "[WARNING] An invalid option has been ignored.\n");
    }
#line 775
    goto switch_break;
    switch_break: ;
#line 514
    if (! (c != -1)) {
#line 514
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 780
  if ((int )img_fol->set_imgdir == 1) {
#line 781
    if (! ((int )parameters->infile[0] == 0)) {
      {
#line 782
      fprintf(stderr, "[ERROR] options -ImgDir and -i cannot be used together.\n\220");
      }
#line 783
      return (1);
    }
#line 785
    if ((int )img_fol->set_out_format == 0) {
      {
#line 786
      fprintf(stderr, "[ERROR] When -ImgDir is used, -OutFor <FORMAT> must be used.\n");
#line 787
      fprintf(stderr, "Only one format allowed.\nValid format are PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA.\n");
      }
#line 789
      return (1);
    }
#line 791
    if (! ((int )parameters->outfile[0] == 0)) {
      {
#line 792
      fprintf(stderr, "[ERROR] options -ImgDir and -o cannot be used together.\n\220");
      }
#line 793
      return (1);
    }
  } else
#line 796
  if ((int )parameters->infile[0] == 0) {
    {
#line 797
    fprintf(stderr, "[ERROR] Required parameters are missing\nExample: %s -i image.j2k -o image.pgm\n",
            *(argv + 0));
#line 799
    fprintf(stderr, "   Help: %s -h\n", *(argv + 0));
    }
#line 800
    return (1);
  } else
#line 796
  if ((int )parameters->outfile[0] == 0) {
    {
#line 797
    fprintf(stderr, "[ERROR] Required parameters are missing\nExample: %s -i image.j2k -o image.pgm\n",
            *(argv + 0));
#line 799
    fprintf(stderr, "   Help: %s -h\n", *(argv + 0));
    }
#line 800
    return (1);
  }
#line 804
  return (0);
}
}
#line 813 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
int parse_DA_values(char *inArg , unsigned int *DA_x0 , unsigned int *DA_y0 , unsigned int *DA_x1 ,
                    unsigned int *DA_y1 ) 
{ 
  int it ;
  int values[4] ;
  char delims[2] ;
  char *result ;

  {
  {
#line 815
  it = 0;
#line 817
  strcpy(delims, ",\236blEV");
#line 818
  result = (char *)((void *)0);
#line 819
  result = strtok(inArg, (char const   *)(delims));
  }
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;

#line 821
    if ((unsigned long )result != (unsigned long )((void *)0)) {
#line 821
      if (! (it < 4)) {
#line 821
        goto while_break;
      }
    } else {
#line 821
      goto while_break;
    }
    {
#line 822
    values[it] = atoi((char const   *)result);
#line 823
    result = strtok((char *)((void *)0), (char const   *)(delims));
#line 824
    it ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 827
  if (it != 4) {
#line 828
    return (1);
  } else {
#line 831
    *DA_x0 = (OPJ_UINT32 )values[0];
#line 831
    *DA_y0 = (OPJ_UINT32 )values[1];
#line 832
    *DA_x1 = (OPJ_UINT32 )values[2];
#line 832
    *DA_y1 = (OPJ_UINT32 )values[3];
#line 833
    return (0);
  }
}
}
#line 842 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
static void error_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 844
  fprintf(stdout, "[ERROR] %s", msg);
  }
#line 846
  return;
}
}
#line 849 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
static void warning_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 851
  fprintf(stdout, "[WARNING] %sEV", msg);
  }
#line 853
  return;
}
}
#line 856 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
static void info_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 858
  fprintf(stdout, "[INFO] %s\263blEV", msg);
  }
#line 860
  return;
}
}
#line 861 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
static void set_default_parameters(opj_decompress_parameters *parameters ) 
{ 


  {
#line 863
  if (parameters) {
    {
#line 864
    memset((void *)parameters, 0, sizeof(opj_decompress_parameters ));
#line 867
    parameters->decod_format = -1;
#line 868
    parameters->cod_format = -1;
#line 871
    opj_set_default_decoder_parameters(& parameters->core);
    }
  }
#line 874
  return;
}
}
#line 875 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
static void destroy_parameters(opj_decompress_parameters *parameters ) 
{ 


  {
#line 877
  if (parameters) {
#line 878
    if (parameters->precision) {
      {
#line 879
      free((void *)parameters->precision);
#line 880
      parameters->precision = (opj_precision *)((void *)0);
      }
    }
  }
#line 884
  return;
}
}
#line 887 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
static opj_image_t *convert_gray_to_rgb(opj_image_t *original ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_t *l_new_image ;
  opj_image_cmptparm_t *l_new_components ;
  void *__cil_tmp5 ;

  {
  {
#line 890
  l_new_image = (opj_image_t *)((void *)0);
#line 891
  l_new_components = (opj_image_cmptparm_t *)((void *)0);
#line 893
  __cil_tmp5 = malloc((unsigned long )(original->numcomps + 2U) * sizeof(opj_image_cmptparm_t ));
#line 893
  l_new_components = (opj_image_cmptparm_t *)__cil_tmp5;
  }
#line 894
  if ((unsigned long )l_new_components == (unsigned long )((void *)0)) {
    {
#line 895
    fprintf(stderr, "ERROR -> opj_decompress: failed to allocate memory for RGB image!\n");
#line 896
    opj_image_destroy(original);
    }
#line 897
    return ((opj_image_t *)((void *)0));
  }
#line 900
  (l_new_components + 2)->bpp = (original->comps + 0)->bpp;
#line 900
  (l_new_components + 1)->bpp = (l_new_components + 2)->bpp;
#line 900
  (l_new_components + 0)->bpp = (l_new_components + 1)->bpp;
#line 901
  (l_new_components + 2)->dx = (original->comps + 0)->dx;
#line 901
  (l_new_components + 1)->dx = (l_new_components + 2)->dx;
#line 901
  (l_new_components + 0)->dx = (l_new_components + 1)->dx;
#line 902
  (l_new_components + 2)->dy = (original->comps + 0)->dy;
#line 902
  (l_new_components + 1)->dy = (l_new_components + 2)->dy;
#line 902
  (l_new_components + 0)->dy = (l_new_components + 1)->dy;
#line 903
  (l_new_components + 2)->h = (original->comps + 0)->h;
#line 903
  (l_new_components + 1)->h = (l_new_components + 2)->h;
#line 903
  (l_new_components + 0)->h = (l_new_components + 1)->h;
#line 904
  (l_new_components + 2)->w = (original->comps + 0)->w;
#line 904
  (l_new_components + 1)->w = (l_new_components + 2)->w;
#line 904
  (l_new_components + 0)->w = (l_new_components + 1)->w;
#line 905
  (l_new_components + 2)->prec = (original->comps + 0)->prec;
#line 905
  (l_new_components + 1)->prec = (l_new_components + 2)->prec;
#line 905
  (l_new_components + 0)->prec = (l_new_components + 1)->prec;
#line 906
  (l_new_components + 2)->sgnd = (original->comps + 0)->sgnd;
#line 906
  (l_new_components + 1)->sgnd = (l_new_components + 2)->sgnd;
#line 906
  (l_new_components + 0)->sgnd = (l_new_components + 1)->sgnd;
#line 907
  (l_new_components + 2)->x0 = (original->comps + 0)->x0;
#line 907
  (l_new_components + 1)->x0 = (l_new_components + 2)->x0;
#line 907
  (l_new_components + 0)->x0 = (l_new_components + 1)->x0;
#line 908
  (l_new_components + 2)->y0 = (original->comps + 0)->y0;
#line 908
  (l_new_components + 1)->y0 = (l_new_components + 2)->y0;
#line 908
  (l_new_components + 0)->y0 = (l_new_components + 1)->y0;
#line 910
  compno = 1U;
  {
#line 910
  while (1) {
    while_continue: /* CIL Label */ ;

#line 910
    if (! (compno < original->numcomps)) {
#line 910
      goto while_break;
    }
#line 911
    (l_new_components + (compno + 2U))->bpp = (original->comps + compno)->bpp;
#line 912
    (l_new_components + (compno + 2U))->dx = (original->comps + compno)->dx;
#line 913
    (l_new_components + (compno + 2U))->dy = (original->comps + compno)->dy;
#line 914
    (l_new_components + (compno + 2U))->h = (original->comps + compno)->h;
#line 915
    (l_new_components + (compno + 2U))->w = (original->comps + compno)->w;
#line 916
    (l_new_components + (compno + 2U))->prec = (original->comps + compno)->prec;
#line 917
    (l_new_components + (compno + 2U))->sgnd = (original->comps + compno)->sgnd;
#line 918
    (l_new_components + (compno + 2U))->x0 = (original->comps + compno)->x0;
#line 919
    (l_new_components + (compno + 2U))->y0 = (original->comps + compno)->y0;
#line 910
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 922
  l_new_image = opj_image_create(original->numcomps + 2U, l_new_components, (OPJ_COLOR_SPACE )1);
#line 923
  free((void *)l_new_components);
  }
#line 924
  if ((unsigned long )l_new_image == (unsigned long )((void *)0)) {
    {
#line 925
    fprintf(stderr, "ERROR -> opj_decompress: failed to allocate memory for RGB image!\nllEV");
#line 926
    opj_image_destroy(original);
    }
#line 927
    return ((opj_image_t *)((void *)0));
  }
  {
#line 930
  l_new_image->x0 = original->x0;
#line 931
  l_new_image->x1 = original->x1;
#line 932
  l_new_image->y0 = original->y0;
#line 933
  l_new_image->y1 = original->y1;
#line 935
  (l_new_image->comps + 2)->factor = (original->comps + 0)->factor;
#line 935
  (l_new_image->comps + 1)->factor = (l_new_image->comps + 2)->factor;
#line 935
  (l_new_image->comps + 0)->factor = (l_new_image->comps + 1)->factor;
#line 936
  (l_new_image->comps + 2)->alpha = (original->comps + 0)->alpha;
#line 936
  (l_new_image->comps + 1)->alpha = (l_new_image->comps + 2)->alpha;
#line 936
  (l_new_image->comps + 0)->alpha = (l_new_image->comps + 1)->alpha;
#line 937
  (l_new_image->comps + 2)->resno_decoded = (original->comps + 0)->resno_decoded;
#line 937
  (l_new_image->comps + 1)->resno_decoded = (l_new_image->comps + 2)->resno_decoded;
#line 937
  (l_new_image->comps + 0)->resno_decoded = (l_new_image->comps + 1)->resno_decoded;
#line 939
  memcpy((void *)(l_new_image->comps + 0)->data, (void const   *)(original->comps + 0)->data,
         (unsigned long )((original->comps + 0)->w * (original->comps + 0)->h) * sizeof(OPJ_INT32 ));
#line 940
  memcpy((void *)(l_new_image->comps + 1)->data, (void const   *)(original->comps + 0)->data,
         (unsigned long )((original->comps + 0)->w * (original->comps + 0)->h) * sizeof(OPJ_INT32 ));
#line 941
  memcpy((void *)(l_new_image->comps + 2)->data, (void const   *)(original->comps + 0)->data,
         (unsigned long )((original->comps + 0)->w * (original->comps + 0)->h) * sizeof(OPJ_INT32 ));
#line 943
  compno = 1U;
  }
  {
#line 943
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 943
    if (! (compno < original->numcomps)) {
#line 943
      goto while_break___0;
    }
    {
#line 944
    (l_new_image->comps + (compno + 2U))->factor = (original->comps + compno)->factor;
#line 945
    (l_new_image->comps + (compno + 2U))->alpha = (original->comps + compno)->alpha;
#line 946
    (l_new_image->comps + (compno + 2U))->resno_decoded = (original->comps + compno)->resno_decoded;
#line 947
    memcpy((void *)(l_new_image->comps + (compno + 2U))->data, (void const   *)(original->comps + compno)->data,
           (unsigned long )((original->comps + compno)->w * (original->comps + compno)->h) * sizeof(OPJ_INT32 ));
#line 943
    compno ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 949
  opj_image_destroy(original);
  }
#line 950
  return (l_new_image);
}
}
#line 955 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
static opj_image_t *upsample_image_components(opj_image_t *original ) 
{ 
  opj_image_t *l_new_image ;
  opj_image_cmptparm_t *l_new_components ;
  OPJ_BOOL l_upsample_need ;
  OPJ_UINT32 compno ;
  void *__cil_tmp6 ;
  opj_image_cmptparm_t *l_new_cmp ;
  opj_image_comp_t *l_org_cmp ;
  opj_image_comp_t *l_new_cmp___0 ;
  opj_image_comp_t *l_org_cmp___0 ;
  OPJ_INT32 *l_src ;
  OPJ_INT32 *l_dst ;
  OPJ_UINT32 y ;
  OPJ_UINT32 xoff ;
  OPJ_UINT32 yoff ;
  OPJ_UINT32 x ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 xorg ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 x___0 ;
  OPJ_UINT32 xorg___0 ;
  OPJ_UINT32 dx___0 ;

  {
#line 957
  l_new_image = (opj_image_t *)((void *)0);
#line 958
  l_new_components = (opj_image_cmptparm_t *)((void *)0);
#line 959
  l_upsample_need = 0;
#line 962
  compno = 0U;
  {
#line 962
  while (1) {
    while_continue: /* CIL Label */ ;

#line 962
    if (! (compno < original->numcomps)) {
#line 962
      goto while_break;
    }
#line 963
    if ((original->comps + compno)->factor > 0U) {
      {
#line 964
      fprintf(stderr, "ERROR -> opj_decompress: -upsample not supported with reduction\n\220");
#line 965
      opj_image_destroy(original);
      }
#line 966
      return ((opj_image_t *)((void *)0));
    }
#line 968
    if ((original->comps + compno)->dx > 1U) {
#line 969
      l_upsample_need = 1;
#line 970
      goto while_break;
    } else
#line 968
    if ((original->comps + compno)->dy > 1U) {
#line 969
      l_upsample_need = 1;
#line 970
      goto while_break;
    }
#line 962
    compno ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break: ;
#line 973
  if (! l_upsample_need) {
#line 974
    return (original);
  }
  {
#line 977
  __cil_tmp6 = malloc((unsigned long )original->numcomps * sizeof(opj_image_cmptparm_t ));
#line 977
  l_new_components = (opj_image_cmptparm_t *)__cil_tmp6;
  }
#line 978
  if ((unsigned long )l_new_components == (unsigned long )((void *)0)) {
    {
#line 979
    fprintf(stderr, "ERROR -> opj_decompress: failed to allocate memory for upsampled components!\n");
#line 980
    opj_image_destroy(original);
    }
#line 981
    return ((opj_image_t *)((void *)0));
  }
#line 984
  compno = 0U;
  {
#line 984
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 984
    if (! (compno < original->numcomps)) {
#line 984
      goto while_break___0;
    }
#line 985
    l_new_cmp = l_new_components + compno;
#line 986
    l_org_cmp = original->comps + compno;
#line 988
    l_new_cmp->bpp = l_org_cmp->bpp;
#line 989
    l_new_cmp->prec = l_org_cmp->prec;
#line 990
    l_new_cmp->sgnd = l_org_cmp->sgnd;
#line 991
    l_new_cmp->x0 = original->x0;
#line 992
    l_new_cmp->y0 = original->y0;
#line 993
    l_new_cmp->dx = (OPJ_UINT32 )1;
#line 994
    l_new_cmp->dy = (OPJ_UINT32 )1;
#line 995
    l_new_cmp->w = l_org_cmp->w;
#line 996
    l_new_cmp->h = l_org_cmp->h;
#line 998
    if (l_org_cmp->dx > 1U) {
#line 999
      l_new_cmp->w = original->x1 - original->x0;
    }
#line 1002
    if (l_org_cmp->dy > 1U) {
#line 1003
      l_new_cmp->h = original->y1 - original->y0;
    }
#line 984
    compno ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 1007
  l_new_image = opj_image_create(original->numcomps, l_new_components, original->color_space);
#line 1008
  free((void *)l_new_components);
  }
#line 1009
  if ((unsigned long )l_new_image == (unsigned long )((void *)0)) {
    {
#line 1010
    fprintf(stderr, "ERROR -> opj_decompress: failed to allocate memory for upsampled components!\n");
#line 1011
    opj_image_destroy(original);
    }
#line 1012
    return ((opj_image_t *)((void *)0));
  }
#line 1015
  l_new_image->x0 = original->x0;
#line 1016
  l_new_image->x1 = original->x1;
#line 1017
  l_new_image->y0 = original->y0;
#line 1018
  l_new_image->y1 = original->y1;
#line 1020
  compno = 0U;
  {
#line 1020
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 1020
    if (! (compno < original->numcomps)) {
#line 1020
      goto while_break___1;
    }
#line 1021
    l_new_cmp___0 = l_new_image->comps + compno;
#line 1022
    l_org_cmp___0 = original->comps + compno;
#line 1024
    l_new_cmp___0->factor = l_org_cmp___0->factor;
#line 1025
    l_new_cmp___0->alpha = l_org_cmp___0->alpha;
#line 1026
    l_new_cmp___0->resno_decoded = l_org_cmp___0->resno_decoded;
#line 1028
    if (l_org_cmp___0->dx > 1U) {
      _L: 
#line 1029
      l_src = l_org_cmp___0->data;
#line 1030
      l_dst = l_new_cmp___0->data;
#line 1035
      xoff = l_org_cmp___0->dx * l_org_cmp___0->x0 - original->x0;
#line 1036
      yoff = l_org_cmp___0->dy * l_org_cmp___0->y0 - original->y0;
#line 1037
      if (xoff >= l_org_cmp___0->dx) {
        {
#line 1038
        fprintf(stderr, "ERROR -> opj_decompress: Invalid image/component parameters found when upsampling\nmlEV");
#line 1039
        opj_image_destroy(original);
#line 1040
        opj_image_destroy(l_new_image);
        }
#line 1041
        return ((opj_image_t *)((void *)0));
      } else
#line 1037
      if (yoff >= l_org_cmp___0->dy) {
        {
#line 1038
        fprintf(stderr, "ERROR -> opj_decompress: Invalid image/component parameters found when upsampling\nmlEV");
#line 1039
        opj_image_destroy(original);
#line 1040
        opj_image_destroy(l_new_image);
        }
#line 1041
        return ((opj_image_t *)((void *)0));
      }
#line 1044
      y = 0U;
      {
#line 1044
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1044
        if (! (y < yoff)) {
#line 1044
          goto while_break___2;
        }
        {
#line 1045
        memset((void *)l_dst, 0, (unsigned long )l_new_cmp___0->w * sizeof(OPJ_INT32 ));
#line 1046
        l_dst += l_new_cmp___0->w;
#line 1044
        y ++;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___2: ;
#line 1049
      if (l_new_cmp___0->h > l_org_cmp___0->dy - 1U) {
        {
#line 1050
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1050
          if (! (y < l_new_cmp___0->h - (l_org_cmp___0->dy - 1U))) {
#line 1050
            goto while_break___3;
          }
#line 1054
          xorg = 0U;
#line 1055
          x = 0U;
          {
#line 1055
          while (1) {
            while_continue___4: /* CIL Label */ ;

#line 1055
            if (! (x < xoff)) {
#line 1055
              goto while_break___4;
            }
#line 1056
            *(l_dst + x) = 0;
#line 1055
            x ++;
          }
          while_break___19: /* CIL Label */ ;
          }
          while_break___4: ;
#line 1058
          if (l_new_cmp___0->w > l_org_cmp___0->dx - 1U) {
            {
#line 1059
            while (1) {
              while_continue___5: /* CIL Label */ ;

#line 1059
              if (! (x < l_new_cmp___0->w - (l_org_cmp___0->dx - 1U))) {
#line 1059
                goto while_break___5;
              }
#line 1061
              dx = 0U;
              {
#line 1061
              while (1) {
                while_continue___6: /* CIL Label */ ;

#line 1061
                if (! (dx < l_org_cmp___0->dx)) {
#line 1061
                  goto while_break___6;
                }
#line 1062
                *(l_dst + (x + dx)) = *(l_src + xorg);
#line 1061
                dx ++;
              }
              while_break___21: /* CIL Label */ ;
              }
              while_break___6: 
#line 1059
              xorg ++;
#line 1059
              x += l_org_cmp___0->dx;
            }
            while_break___20: /* CIL Label */ ;
            }
            while_break___5: ;
          }
          {
#line 1066
          while (1) {
            while_continue___7: /* CIL Label */ ;

#line 1066
            if (! (x < l_new_cmp___0->w)) {
#line 1066
              goto while_break___7;
            }
#line 1067
            *(l_dst + x) = *(l_src + xorg);
#line 1066
            x ++;
          }
          while_break___22: /* CIL Label */ ;
          }
          while_break___7: 
#line 1069
          l_dst += l_new_cmp___0->w;
#line 1071
          dy = 1U;
          {
#line 1071
          while (1) {
            while_continue___8: /* CIL Label */ ;

#line 1071
            if (! (dy < l_org_cmp___0->dy)) {
#line 1071
              goto while_break___8;
            }
            {
#line 1072
            memcpy((void *)l_dst, (void const   *)(l_dst - l_new_cmp___0->w), (unsigned long )l_new_cmp___0->w * sizeof(OPJ_INT32 ));
#line 1073
            l_dst += l_new_cmp___0->w;
#line 1071
            dy ++;
            }
          }
          while_break___23: /* CIL Label */ ;
          }
          while_break___8: 
#line 1075
          l_src += l_org_cmp___0->w;
#line 1050
          y += l_org_cmp___0->dy;
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___3: ;
      }
#line 1078
      if (y < l_new_cmp___0->h) {
#line 1082
        xorg___0 = 0U;
#line 1083
        x___0 = 0U;
        {
#line 1083
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 1083
          if (! (x___0 < xoff)) {
#line 1083
            goto while_break___9;
          }
#line 1084
          *(l_dst + x___0) = 0;
#line 1083
          x___0 ++;
        }
        while_break___24: /* CIL Label */ ;
        }
        while_break___9: ;
#line 1086
        if (l_new_cmp___0->w > l_org_cmp___0->dx - 1U) {
          {
#line 1087
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 1087
            if (! (x___0 < l_new_cmp___0->w - (l_org_cmp___0->dx - 1U))) {
#line 1087
              goto while_break___10;
            }
#line 1089
            dx___0 = 0U;
            {
#line 1089
            while (1) {
              while_continue___11: /* CIL Label */ ;

#line 1089
              if (! (dx___0 < l_org_cmp___0->dx)) {
#line 1089
                goto while_break___11;
              }
#line 1090
              *(l_dst + (x___0 + dx___0)) = *(l_src + xorg___0);
#line 1089
              dx___0 ++;
            }
            while_break___26: /* CIL Label */ ;
            }
            while_break___11: 
#line 1087
            xorg___0 ++;
#line 1087
            x___0 += l_org_cmp___0->dx;
          }
          while_break___25: /* CIL Label */ ;
          }
          while_break___10: ;
        }
        {
#line 1094
        while (1) {
          while_continue___12: /* CIL Label */ ;

#line 1094
          if (! (x___0 < l_new_cmp___0->w)) {
#line 1094
            goto while_break___12;
          }
#line 1095
          *(l_dst + x___0) = *(l_src + xorg___0);
#line 1094
          x___0 ++;
        }
        while_break___27: /* CIL Label */ ;
        }
        while_break___12: 
#line 1097
        l_dst += l_new_cmp___0->w;
#line 1098
        y ++;
        {
#line 1099
        while (1) {
          while_continue___13: /* CIL Label */ ;

#line 1099
          if (! (y < l_new_cmp___0->h)) {
#line 1099
            goto while_break___13;
          }
          {
#line 1100
          memcpy((void *)l_dst, (void const   *)(l_dst - l_new_cmp___0->w), (unsigned long )l_new_cmp___0->w * sizeof(OPJ_INT32 ));
#line 1101
          l_dst += l_new_cmp___0->w;
#line 1099
          y ++;
          }
        }
        while_break___28: /* CIL Label */ ;
        }
        while_break___13: ;
      }
    } else
#line 1028
    if (l_org_cmp___0->dy > 1U) {
#line 1028
      goto _L;
    } else {
      {
#line 1106
      memcpy((void *)l_new_cmp___0->data, (void const   *)l_org_cmp___0->data, (unsigned long )(l_org_cmp___0->w * l_org_cmp___0->h) * sizeof(OPJ_INT32 ));
      }
    }
#line 1020
    compno ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 1109
  opj_image_destroy(original);
  }
#line 1110
  return (l_new_image);
}
}
#line 1118 "/root/patchweave_new/10/src/bin/jp2/opj_decompress.c"
int main(int argc , char **argv ) 
{ 
  opj_decompress_parameters parameters ;
  opj_image_t *image ;
  opj_stream_t *l_stream ;
  opj_codec_t *l_codec ;
  opj_codestream_index_t *cstr_index ;
  char indexfilename[4096] ;
  OPJ_INT32 num_images ;
  OPJ_INT32 imageno ;
  img_fol_t img_fol ;
  dircnt_t *dirptr ;
  int failed ;
  int __cil_tmp14 ;
  int it_image ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  int __cil_tmp21 ;
  char __cil_tmp22 ;
  OPJ_BOOL __cil_tmp27 ;
  OPJ_BOOL __cil_tmp28 ;
  OPJ_BOOL __cil_tmp29 ;
  OPJ_BOOL __cil_tmp30 ;
  OPJ_BOOL __cil_tmp31 ;
  OPJ_BOOL __cil_tmp32 ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 prec ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int tmp ;

  {
  {
#line 1121
  image = (opj_image_t *)((void *)0);
#line 1122
  l_stream = (opj_stream_t *)((void *)0);
#line 1123
  l_codec = (opj_codec_t *)((void *)0);
#line 1124
  cstr_index = (opj_codestream_index_t *)((void *)0);
#line 1130
  dirptr = (dircnt_t *)((void *)0);
#line 1131
  failed = 0;
#line 1134
  set_default_parameters(& parameters);
#line 1137
  indexfilename[0] = (char)0;
#line 1140
  memset((void *)(& img_fol), 0, sizeof(img_fol_t ));
#line 1143
  __cil_tmp14 = parse_cmdline_decoder(argc, argv, & parameters, & img_fol, indexfilename);
  }
#line 1143
  if (__cil_tmp14 == 1) {
    {
#line 1144
    destroy_parameters(& parameters);
    }
#line 1145
    return (1);
  }
#line 1149
  if ((int )img_fol.set_imgdir == 1) {
    {
#line 1151
    num_images = get_num_images(img_fol.imgdirpath);
#line 1153
    __cil_tmp17 = malloc(sizeof(dircnt_t ));
#line 1153
    dirptr = (dircnt_t *)__cil_tmp17;
    }
#line 1154
    if (dirptr) {
      {
#line 1155
      __cil_tmp18 = malloc(((size_t )num_images * 4096UL) * sizeof(char ));
#line 1155
      dirptr->filename_buf = (char *)__cil_tmp18;
#line 1156
      __cil_tmp19 = malloc((size_t )num_images * sizeof(char *));
#line 1156
      dirptr->filename = (char **)__cil_tmp19;
      }
#line 1158
      if (! dirptr->filename_buf) {
        {
#line 1159
        destroy_parameters(& parameters);
        }
#line 1160
        return (1);
      }
#line 1162
      it_image = 0;
      {
#line 1162
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1162
        if (! (it_image < num_images)) {
#line 1162
          goto while_break;
        }
#line 1163
        *(dirptr->filename + it_image) = dirptr->filename_buf + it_image * 4096;
#line 1162
        it_image ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: ;
    }
    {
#line 1166
    __cil_tmp21 = load_images(dirptr, img_fol.imgdirpath);
    }
#line 1166
    if (__cil_tmp21 == 1) {
      {
#line 1167
      destroy_parameters(& parameters);
      }
#line 1168
      return (1);
    }
#line 1170
    if (num_images == 0) {
      {
#line 1171
      fprintf(stdout, "Folder is empty\n\220");
#line 1172
      destroy_parameters(& parameters);
      }
#line 1173
      return (1);
    }
  } else {
#line 1176
    num_images = 1;
  }
#line 1180
  imageno = 0;
  {
#line 1180
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue___0: ;
#line 1180
    if (! (imageno < num_images)) {
#line 1180
      goto while_break___0;
    }
    {
#line 1182
    fprintf(stderr, "\n\221nlEV");
    }
#line 1184
    if ((int )img_fol.set_imgdir == 1) {
      {
#line 1185
      __cil_tmp22 = get_next_file(imageno, dirptr, & img_fol, & parameters);
      }
#line 1185
      if (__cil_tmp22) {
        {
#line 1186
        fprintf(stderr, "skipping file...\n");
#line 1187
        destroy_parameters(& parameters);
        }
#line 1188
        goto while_continue___0;
      }
    }
    {
#line 1195
    l_stream = opj_stream_create_default_file_stream((char const   *)(parameters.infile),
                                                     1);
    }
#line 1196
    if (! l_stream) {
      {
#line 1197
      fprintf(stderr, "ERROR -> failed to create the stream from the file %s\n", parameters.infile);
#line 1198
      destroy_parameters(& parameters);
      }
#line 1199
      return (1);
    }
#line 1206
    if (parameters.decod_format == 0) {
#line 1206
      goto case_0;
    }
#line 1212
    if (parameters.decod_format == 1) {
#line 1212
      goto case_1;
    }
#line 1218
    if (parameters.decod_format == 2) {
#line 1218
      goto case_2;
    }
#line 1224
    goto switch_default;
    case_0: 
    {
#line 1209
    l_codec = opj_create_decompress((OPJ_CODEC_FORMAT )0);
    }
#line 1210
    goto switch_break;
    case_1: 
    {
#line 1215
    l_codec = opj_create_decompress((OPJ_CODEC_FORMAT )2);
    }
#line 1216
    goto switch_break;
    case_2: 
    {
#line 1221
    l_codec = opj_create_decompress((OPJ_CODEC_FORMAT )1);
    }
#line 1222
    goto switch_break;
    switch_default: 
    {
#line 1225
    fprintf(stderr, "skipping file..\n\220");
#line 1226
    destroy_parameters(& parameters);
#line 1227
    opj_stream_destroy(l_stream);
    }
#line 1228
    goto while_continue___0;
    switch_break: 
    {
#line 1232
    opj_set_info_handler(l_codec, & info_callback, (void *)0);
#line 1233
    opj_set_warning_handler(l_codec, & warning_callback, (void *)0);
#line 1234
    opj_set_error_handler(l_codec, & error_callback, (void *)0);
#line 1237
    __cil_tmp27 = opj_setup_decoder(l_codec, & parameters.core);
    }
#line 1237
    if (! __cil_tmp27) {
      {
#line 1238
      fprintf(stderr, "ERROR -> opj_compress: failed to setup the decoder\nlEV");
#line 1239
      destroy_parameters(& parameters);
#line 1240
      opj_stream_destroy(l_stream);
#line 1241
      opj_destroy_codec(l_codec);
      }
#line 1242
      return (1);
    }
    {
#line 1247
    __cil_tmp28 = opj_read_header(l_stream, l_codec, & image);
    }
#line 1247
    if (! __cil_tmp28) {
      {
#line 1248
      fprintf(stderr, "ERROR -> opj_decompress: failed to read the header\n");
#line 1249
      destroy_parameters(& parameters);
#line 1250
      opj_stream_destroy(l_stream);
#line 1251
      opj_destroy_codec(l_codec);
#line 1252
      opj_image_destroy(image);
      }
#line 1253
      return (1);
    }
#line 1256
    if (! parameters.nb_tile_to_decode) {
      {
#line 1258
      __cil_tmp29 = opj_set_decode_area(l_codec, image, (OPJ_INT32 )parameters.DA_x0,
                                        (OPJ_INT32 )parameters.DA_y0, (OPJ_INT32 )parameters.DA_x1,
                                        (OPJ_INT32 )parameters.DA_y1);
      }
#line 1258
      if (! __cil_tmp29) {
        {
#line 1260
        fprintf(stderr, "ERROR -> opj_decompress: failed to set the decoded area\n\220");
#line 1261
        destroy_parameters(& parameters);
#line 1262
        opj_stream_destroy(l_stream);
#line 1263
        opj_destroy_codec(l_codec);
#line 1264
        opj_image_destroy(image);
        }
#line 1265
        return (1);
      }
      {
#line 1269
      __cil_tmp31 = opj_end_decompress(l_codec, l_stream);
#line 1269
      __cil_tmp30 = opj_decode(l_codec, l_stream, image);
      }
#line 1269
      if (__cil_tmp30) {
#line 1269
        if (! __cil_tmp31) {
#line 1269
          goto _L___66;
        }
      } else {
        _L___66: /* CIL Label */ 
        {
#line 1270
        fprintf(stderr, "ERROR -> opj_decompress: failed to decode image!\n\366nlEV");
#line 1271
        destroy_parameters(& parameters);
#line 1272
        opj_destroy_codec(l_codec);
#line 1273
        opj_stream_destroy(l_stream);
#line 1274
        opj_image_destroy(image);
        }
#line 1275
        return (1);
      }
    } else {
      {
#line 1289
      __cil_tmp32 = opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index);
      }
#line 1289
      if (! __cil_tmp32) {
        {
#line 1290
        fprintf(stderr, "ERROR -> opj_decompress: failed to decode tile!\n\220");
#line 1291
        destroy_parameters(& parameters);
#line 1292
        opj_destroy_codec(l_codec);
#line 1293
        opj_stream_destroy(l_stream);
#line 1294
        opj_image_destroy(image);
        }
#line 1295
        return (1);
      }
      {
#line 1297
      fprintf(stdout, "tile %d is decoded!\n\n", parameters.tile_index);
      }
    }
    {
#line 1301
    opj_stream_destroy(l_stream);
    }
#line 1303
    if ((int )image->color_space == 3) {
      {
#line 1304
      color_sycc_to_rgb(image);
      }
    }
#line 1307
    if ((int )image->color_space != 3) {
#line 1307
      if (image->numcomps == 3U) {
#line 1307
        if ((image->comps + 0)->dx == (image->comps + 0)->dy) {
#line 1307
          if ((image->comps + 1)->dx != 1U) {
#line 1310
            image->color_space = (OPJ_COLOR_SPACE )3;
          } else {
#line 1307
            goto _L;
          }
        } else {
#line 1307
          goto _L;
        }
      } else {
#line 1307
        goto _L;
      }
    } else
    _L: 
#line 1311
    if (image->numcomps <= 2U) {
#line 1312
      image->color_space = (OPJ_COLOR_SPACE )2;
    }
#line 1314
    if (image->icc_profile_buf) {
      {
#line 1318
      free((void *)image->icc_profile_buf);
#line 1319
      image->icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 1319
      image->icc_profile_len = (OPJ_UINT32 )0;
      }
    }
#line 1324
    if ((unsigned long )parameters.precision != (unsigned long )((void *)0)) {
#line 1327
      compno = (OPJ_UINT32 )0;
      {
#line 1327
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1327
        if (! (compno < image->numcomps)) {
#line 1327
          goto while_break___1;
        }
#line 1329
        precno = compno;
#line 1332
        if (precno >= parameters.nb_precision) {
#line 1333
          precno = parameters.nb_precision - 1U;
        }
#line 1336
        prec = (parameters.precision + precno)->prec;
#line 1337
        if (prec == 0U) {
#line 1338
          prec = (image->comps + compno)->prec;
        }
#line 1342
        if ((unsigned int )(parameters.precision + precno)->mode == 0U) {
#line 1342
          goto case_0___0;
        }
#line 1345
        if ((unsigned int )(parameters.precision + precno)->mode == 1U) {
#line 1345
          goto case_1___0;
        }
#line 1348
        goto switch_default___0;
        case_0___0: 
        {
#line 1343
        clip_component(image->comps + compno, prec);
        }
#line 1344
        goto switch_break___0;
        case_1___0: 
        {
#line 1346
        scale_component(image->comps + compno, prec);
        }
#line 1347
        goto switch_break___0;
        switch_default___0: 
#line 1349
        goto switch_break___0;
        switch_break___0: 
#line 1327
        compno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
    }
#line 1357
    if (parameters.upsample) {
      {
#line 1359
      image = upsample_image_components(image);
      }
#line 1360
      if ((unsigned long )image == (unsigned long )((void *)0)) {
        {
#line 1361
        fprintf(stderr, "ERROR -> opj_decompress: failed to upsample image components!\n");
#line 1362
        destroy_parameters(& parameters);
#line 1363
        opj_destroy_codec(l_codec);
        }
#line 1364
        return (1);
      }
    }
#line 1370
    if (parameters.force_rgb) {
#line 1373
      if ((int )image->color_space == 1) {
#line 1373
        goto case_1___1;
      }
#line 1375
      if ((int )image->color_space == 2) {
#line 1375
        goto case_2___0;
      }
#line 1378
      goto switch_default___1;
      case_1___1: 
#line 1374
      goto switch_break___1;
      case_2___0: 
      {
#line 1376
      image = convert_gray_to_rgb(image);
      }
#line 1377
      goto switch_break___1;
      switch_default___1: 
      {
#line 1379
      fprintf(stderr, "ERROR -> opj_decompress: don\'t know how to convert image to RGB colorspace!\n");
#line 1380
      opj_image_destroy(image);
#line 1381
      image = (opj_image_t *)((void *)0);
      }
#line 1382
      goto switch_break___1;
      switch_break___1: ;
#line 1384
      if ((unsigned long )image == (unsigned long )((void *)0)) {
        {
#line 1385
        fprintf(stderr, "ERROR -> opj_decompress: failed to convert to RGB image!\n2olEV");
#line 1386
        destroy_parameters(& parameters);
#line 1387
        opj_destroy_codec(l_codec);
        }
#line 1388
        return (1);
      }
    }
#line 1395
    if (parameters.cod_format == 10) {
#line 1395
      goto case_10;
    }
#line 1405
    if (parameters.cod_format == 11) {
#line 1405
      goto case_11;
    }
#line 1415
    if (parameters.cod_format == 12) {
#line 1415
      goto case_12;
    }
#line 1425
    if (parameters.cod_format == 14) {
#line 1425
      goto case_14;
    }
#line 1435
    if (parameters.cod_format == 15) {
#line 1435
      goto case_15;
    }
#line 1445
    if (parameters.cod_format == 18) {
#line 1445
      goto case_18;
    }
#line 1455
    if (parameters.cod_format == 16) {
#line 1455
      goto case_16;
    }
#line 1465
    if (parameters.cod_format == 17) {
#line 1465
      goto case_17;
    }
#line 1478
    goto switch_default___2;
    case_10: 
    {
#line 1396
    __cil_tmp38 = imagetopnm(image, (char const   *)(parameters.outfile));
    }
#line 1396
    if (__cil_tmp38) {
      {
#line 1397
      fprintf(stderr, "[ERROR] Outfile %s not generated\n", parameters.outfile);
#line 1398
      failed = 1;
      }
    } else {
      {
#line 1401
      fprintf(stdout, "[INFO] Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 1403
    goto switch_break___2;
    case_11: 
    {
#line 1406
    __cil_tmp39 = imagetopgx(image, (char const   *)(parameters.outfile));
    }
#line 1406
    if (__cil_tmp39) {
      {
#line 1407
      fprintf(stderr, "[ERROR] Outfile %s not generated\n?olEV", parameters.outfile);
#line 1408
      failed = 1;
      }
    } else {
      {
#line 1411
      fprintf(stdout, "[INFO] Generated Outfile %s\nEV", parameters.outfile);
      }
    }
#line 1413
    goto switch_break___2;
    case_12: 
    {
#line 1416
    __cil_tmp40 = imagetobmp(image, (char const   *)(parameters.outfile));
    }
#line 1416
    if (__cil_tmp40) {
      {
#line 1417
      fprintf(stderr, "[ERROR] Outfile %s not generated\n", parameters.outfile);
#line 1418
      failed = 1;
      }
    } else {
      {
#line 1421
      fprintf(stdout, "[INFO] Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 1423
    goto switch_break___2;
    case_14: 
    {
#line 1426
    __cil_tmp41 = imagetotif(image, (char const   *)(parameters.outfile));
    }
#line 1426
    if (__cil_tmp41) {
      {
#line 1427
      fprintf(stderr, "[ERROR] Outfile %s not generated\n", parameters.outfile);
#line 1428
      failed = 1;
      }
    } else {
      {
#line 1431
      fprintf(stdout, "[INFO] Generated Outfile %s\nEV", parameters.outfile);
      }
    }
#line 1433
    goto switch_break___2;
    case_15: 
    {
#line 1436
    __cil_tmp42 = imagetoraw(image, (char const   *)(parameters.outfile));
    }
#line 1436
    if (__cil_tmp42) {
      {
#line 1437
      fprintf(stderr, "[ERROR] Error generating raw file. Outfile %s not generated\n",
              parameters.outfile);
#line 1438
      failed = 1;
      }
    } else {
      {
#line 1441
      fprintf(stdout, "[INFO] Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 1443
    goto switch_break___2;
    case_18: 
    {
#line 1446
    __cil_tmp43 = imagetorawl(image, (char const   *)(parameters.outfile));
    }
#line 1446
    if (__cil_tmp43) {
      {
#line 1447
      fprintf(stderr, "[ERROR] Error generating rawl file. Outfile %s not generated\nV",
              parameters.outfile);
#line 1448
      failed = 1;
      }
    } else {
      {
#line 1451
      fprintf(stdout, "[INFO] Generated Outfile %s\nEV", parameters.outfile);
      }
    }
#line 1453
    goto switch_break___2;
    case_16: 
    {
#line 1456
    __cil_tmp44 = imagetotga(image, (char const   *)(parameters.outfile));
    }
#line 1456
    if (__cil_tmp44) {
      {
#line 1457
      fprintf(stderr, "[ERROR] Error generating tga file. Outfile %s not generated\n",
              parameters.outfile);
#line 1458
      failed = 1;
      }
    } else {
      {
#line 1461
      fprintf(stdout, "[INFO] Generated Outfile %s\nEV", parameters.outfile);
      }
    }
#line 1463
    goto switch_break___2;
    case_17: 
    {
#line 1466
    __cil_tmp45 = imagetopng(image, (char const   *)(parameters.outfile));
    }
#line 1466
    if (__cil_tmp45) {
      {
#line 1467
      fprintf(stderr, "[ERROR] Error generating png file. Outfile %s not generated\nEV",
              parameters.outfile);
#line 1468
      failed = 1;
      }
    } else {
      {
#line 1471
      fprintf(stdout, "[INFO] Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 1473
    goto switch_break___2;
    switch_default___2: 
    {
#line 1479
    fprintf(stderr, "[ERROR] Outfile %s not generated\n", parameters.outfile);
#line 1480
    failed = 1;
    }
    switch_break___2: ;
#line 1484
    if (l_codec) {
      {
#line 1485
      opj_destroy_codec(l_codec);
      }
    }
    {
#line 1490
    opj_image_destroy(image);
#line 1493
    opj_destroy_cstr_index(& cstr_index);
    }
#line 1495
    if (failed) {
      {
#line 1495
      remove((char const   *)(parameters.outfile));
      }
    }
#line 1180
    imageno ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 1497
  destroy_parameters(& parameters);
  }
#line 1498
  if (failed) {
#line 1498
    tmp = 1;
  } else {
#line 1498
    tmp = 0;
  }
#line 1498
  return (tmp);
}
}
#line 46 "/root/patchweave_new/10/src/bin/common/opj_getopt.c"
int opj_opterr  =    1;
#line 47 "/root/patchweave_new/10/src/bin/common/opj_getopt.c"
int opj_optind  =    1;
#line 54 "/root/patchweave_new/10/src/bin/common/opj_getopt.c"
static char EMSG[1]  = {      (char )'\250'};
#line 57 "/root/patchweave_new/10/src/bin/common/opj_getopt.c"
void opj_reset_options_reading(void) 
{ 


  {
#line 58
  opj_opterr = 1;
#line 59
  opj_optind = 1;
#line 60
  return;
}
}
#line 68 "/root/patchweave_new/10/src/bin/common/opj_getopt.c"
static char *place  ;
#line 66 "/root/patchweave_new/10/src/bin/common/opj_getopt.c"
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ 
  char *oli ;
  char *__cil_tmp6 ;

  {
#line 68
  place = EMSG;
#line 69
  oli = (char *)((void *)0);
#line 71
  if (opj_optreset) {
    _L: 
#line 72
    opj_optreset = 0;
#line 73
    place = (char *)*(nargv + opj_optind);
#line 73
    if (opj_optind >= nargc) {
#line 74
      place = EMSG;
#line 75
      return (-1);
    } else
#line 73
    if ((int )*place != 45) {
#line 74
      place = EMSG;
#line 75
      return (-1);
    }
#line 77
    place ++;
#line 77
    if ((int )*(place + 1)) {
#line 77
      if ((int )*place == 45) {
#line 78
        opj_optind ++;
#line 79
        place = EMSG;
#line 80
        return (-1);
      }
    }
  } else
#line 71
  if (! *place) {
#line 71
    goto _L;
  }
  {
#line 83
  oli = strchr(ostr, opj_optopt);
#line 83
  __cil_tmp6 = place;
#line 83
  place ++;
#line 83
  opj_optopt = (int )*__cil_tmp6;
  }
#line 83
  if (! oli) {
    _L___66: 
#line 89
    if (opj_optopt == 45) {
#line 90
      return (-1);
    }
#line 91
    if (! *place) {
#line 92
      opj_optind ++;
    }
#line 93
    if (opj_opterr) {
#line 93
      if ((int )*ostr != 58) {
        {
#line 94
        fprintf(stderr, "%s: illegal option -- %c\n", *(nargv + 0), opj_optopt);
        }
#line 96
        return ('?');
      }
    }
  } else
#line 83
  if (opj_optopt == 58) {
#line 83
    goto _L___66;
  }
#line 99
  oli ++;
#line 99
  if ((int )*oli != 58) {
#line 100
    opj_optarg = (char *)((void *)0);
#line 101
    if (! *place) {
#line 102
      opj_optind ++;
    }
  } else {
#line 104
    if (*place) {
#line 105
      opj_optarg = place;
    } else {
#line 106
      opj_optind ++;
#line 106
      if (nargc <= opj_optind) {
#line 107
        place = EMSG;
#line 108
        if ((int )*ostr == 58) {
#line 109
          return (':');
        }
#line 110
        if (opj_opterr) {
          {
#line 111
          fprintf(stderr, "%s: option requires an argument -- %c\n", *(nargv + 0),
                  opj_optopt);
          }
#line 114
          return ('?');
        }
      } else {
#line 117
        opj_optarg = (char *)*(nargv + opj_optind);
      }
    }
#line 118
    place = EMSG;
#line 119
    opj_optind ++;
  }
#line 121
  return (opj_optopt);
}
}
#line 128 "/root/patchweave_new/10/src/bin/common/opj_getopt.c"
static int lastidx  ;
#line 129 "/root/patchweave_new/10/src/bin/common/opj_getopt.c"
static int lastofs  ;
#line 125 "/root/patchweave_new/10/src/bin/common/opj_getopt.c"
int opj_getopt_long(int argc , char * const  *argv , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) 
{ 
  char *tmp ;
  int i ;
  int len ;
  char param ;
  char *arg ;
  opj_option_t *o ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  opj_option_t *__cil_tmp17 ;

  {
#line 130
  param = (char)1;
  again: 
#line 133
  if (! *(argv + opj_optind)) {
#line 134
    return (-1);
  } else
#line 133
  if (opj_optind >= argc) {
#line 134
    return (-1);
  } else
#line 133
  if ((int )*(*(argv + opj_optind)) != 45) {
#line 134
    return (-1);
  }
#line 136
  if ((int )*(*(argv + opj_optind) + 0) == 45) {
#line 136
    if ((int )*(*(argv + opj_optind) + 1) == 0) {
#line 137
      if (opj_optind >= argc - 1) {
#line 138
        param = (char)0;
      } else
#line 141
      if ((int )*(*(argv + (opj_optind + 1)) + 0) == 45) {
#line 142
        param = (char)0;
      } else {
#line 145
        param = (char)2;
      }
    }
  }
#line 150
  if ((int )param == 0) {
#line 151
    opj_optind ++;
#line 152
    return ('?');
  }
#line 155
  if ((int )*(*(argv + opj_optind) + 0) == 45) {
#line 156
    arg = (char *)(*(argv + opj_optind) + 1);
#line 158
    o = longopts;
#line 159
    len = (int )sizeof(*(longopts + 0));
#line 161
    if ((int )param > 1) {
#line 162
      arg = (char *)*(argv + (opj_optind + 1));
#line 163
      opj_optind ++;
    } else {
#line 166
      arg = (char *)(*(argv + opj_optind) + 1);
    }
    {
#line 168
    __cil_tmp15 = strlen((char const   *)arg);
    }
#line 168
    if (__cil_tmp15 > 1UL) {
#line 169
      i = 0;
      {
#line 169
      while (1) {
        while_continue: /* CIL Label */ ;

#line 169
        if (! (i < totlen)) {
#line 169
          goto while_break;
        }
        {
#line 170
        __cil_tmp16 = strcmp(o->name, (char const   *)arg);
        }
#line 170
        if (! __cil_tmp16) {
#line 171
          if (o->has_arg == 0) {
#line 172
            if (*(argv + (opj_optind + 1))) {
#line 172
              if (! ((int )*(*(argv + (opj_optind + 1)) + 0) == 45)) {
                {
#line 173
                fprintf(stderr, "%s: option does not require an argument. Ignoring %s\n",
                        arg, *(argv + (opj_optind + 1)));
#line 174
                opj_optind ++;
                }
              }
            }
          } else {
#line 177
            opj_optarg = (char *)*(argv + (opj_optind + 1));
#line 178
            if (opj_optarg) {
#line 179
              if ((int )*(opj_optarg + 0) == 45) {
#line 180
                if (opj_opterr) {
                  {
#line 181
                  fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                  }
#line 182
                  return ('?');
                }
              }
            }
#line 186
            if (! opj_optarg) {
#line 186
              if (o->has_arg == 1) {
#line 187
                if (opj_opterr) {
                  {
#line 188
                  fprintf(stderr, "%s: option requires an argument \n}}lEV", arg);
                  }
#line 189
                  return ('?');
                }
              }
            }
#line 192
            opj_optind ++;
          }
#line 194
          opj_optind ++;
#line 195
          if (o->flag) {
#line 196
            *(o->flag) = o->val;
          } else {
#line 198
            return (o->val);
          }
#line 199
          return (0);
        }
#line 169
        __cil_tmp17 = o;
#line 169
        o ++;
#line 169
        i += len;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 202
      fprintf(stderr, "Invalid option %s\n}lEV", arg);
#line 203
      opj_optind ++;
      }
#line 204
      return ('?');
    } else {
#line 206
      if ((int )*optstring == 58) {
#line 206
        return (':');
      }
#line 207
      if (lastidx != opj_optind) {
#line 208
        lastidx = opj_optind;
#line 208
        lastofs = 0;
      }
      {
#line 210
      opj_optopt = (int )*(*(argv + opj_optind) + (lastofs + 1));
#line 211
      tmp = strchr(optstring, opj_optopt);
      }
#line 211
      if (tmp) {
#line 212
        if ((int )*tmp == 0) {
#line 213
          opj_optind ++;
#line 214
          goto again;
        }
#line 216
        if ((int )*(tmp + 1) == 58) {
#line 217
          if ((int )*(tmp + 2) == 58) {
            _L: 
#line 218
            opj_optarg = (char *)((*(argv + opj_optind) + lastofs) + 2);
#line 218
            if (! *opj_optarg) {
#line 218
              opj_optarg = (char *)0;
            }
#line 219
            goto found;
          } else
#line 217
          if ((int )*(*(argv + opj_optind) + (lastofs + 2))) {
#line 217
            goto _L;
          }
#line 221
          opj_optarg = (char *)*(argv + (opj_optind + 1));
#line 222
          if (opj_optarg) {
#line 223
            if ((int )*(opj_optarg + 0) == 45) {
#line 224
              if (opj_opterr) {
                {
#line 225
                fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                }
#line 226
                return ('?');
              }
            }
          }
#line 230
          if (! opj_optarg) {
#line 231
            if (opj_opterr) {
              {
#line 232
              fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
              }
#line 233
              return ('?');
            }
          }
#line 236
          opj_optind ++;
        } else {
#line 238
          lastofs ++;
#line 239
          return (opj_optopt);
        }
        found: 
#line 242
        opj_optind ++;
#line 243
        return (opj_optopt);
      } else {
        {
#line 245
        fprintf(stderr, "Invalid option %s\n", arg);
#line 246
        opj_optind ++;
        }
#line 247
        return ('?');
      }
    }
  }
  {
#line 252
  fprintf(stderr, "Invalid option\n");
#line 253
  opj_optind ++;
  }
#line 254
  return ('?');
}
}
#line 74 "/root/patchweave_new/10/src/bin/common/color.c"
static void sycc_to_rgb(int offset , int upb , int y , int cb , int cr , int *out_r ,
                        int *out_g , int *out_b ) 
{ 
  int r ;
  int g ;
  int b ;

  {
#line 79
  cb -= offset;
#line 79
  cr -= offset;
#line 80
  r = y + (int )(1.402 * (double )((float )cr));
#line 81
  if (r < 0) {
#line 81
    r = 0;
  } else
#line 81
  if (r > upb) {
#line 81
    r = upb;
  }
#line 81
  *out_r = r;
#line 83
  g = y - (int )(0.344 * (double )((float )cb) + 0.714 * (double )((float )cr));
#line 84
  if (g < 0) {
#line 84
    g = 0;
  } else
#line 84
  if (g > upb) {
#line 84
    g = upb;
  }
#line 84
  *out_g = g;
#line 86
  b = y + (int )(1.77200000001 * (double )((float )cb));
#line 87
  if (b < 0) {
#line 87
    b = 0;
  } else
#line 87
  if (b > upb) {
#line 87
    b = upb;
  }
#line 87
  *out_b = b;
#line 88
  return;
}
}
#line 90 "/root/patchweave_new/10/src/bin/common/color.c"
static void sycc444_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  unsigned int maxw ;
  unsigned int maxh ;
  unsigned int max ;
  unsigned int i ;
  int offset ;
  int upb ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
#line 97
  upb = (int )(img->comps + 0)->prec;
#line 98
  offset = 1 << (upb - 1);
#line 98
  upb = (1 << upb) - 1;
#line 100
  maxw = (img->comps + 0)->w;
#line 100
  maxh = (img->comps + 0)->h;
#line 101
  max = maxw * maxh;
#line 103
  y = (int const   *)(img->comps + 0)->data;
#line 104
  cb = (int const   *)(img->comps + 1)->data;
#line 105
  cr = (int const   *)(img->comps + 2)->data;
#line 107
  __cil_tmp17 = malloc(sizeof(int ) * (size_t )max);
#line 107
  r = (int *)__cil_tmp17;
#line 107
  d0 = r;
#line 108
  __cil_tmp18 = malloc(sizeof(int ) * (size_t )max);
#line 108
  g = (int *)__cil_tmp18;
#line 108
  d1 = g;
#line 109
  __cil_tmp19 = malloc(sizeof(int ) * (size_t )max);
#line 109
  b = (int *)__cil_tmp19;
#line 109
  d2 = b;
#line 111
  i = 0U;
  }
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;

#line 111
    if (! (i < max)) {
#line 111
      goto while_break;
    }
    {
#line 113
    sycc_to_rgb(offset, upb, (int )*y, (int )*cb, (int )*cr, r, g, b);
#line 114
    y ++;
#line 114
    cb ++;
#line 114
    cr ++;
#line 114
    r ++;
#line 114
    g ++;
#line 114
    b ++;
#line 111
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 116
  free((void *)(img->comps + 0)->data);
#line 116
  (img->comps + 0)->data = d0;
#line 117
  free((void *)(img->comps + 1)->data);
#line 117
  (img->comps + 1)->data = d1;
#line 118
  free((void *)(img->comps + 2)->data);
#line 118
  (img->comps + 2)->data = d2;
  }
#line 120
  return;
}
}
#line 122 "/root/patchweave_new/10/src/bin/common/color.c"
static void sycc422_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  unsigned int maxw ;
  unsigned int maxh ;
  unsigned int max ;
  int offset ;
  int upb ;
  unsigned int i ;
  unsigned int j ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
  {
#line 130
  upb = (int )(img->comps + 0)->prec;
#line 131
  offset = 1 << (upb - 1);
#line 131
  upb = (1 << upb) - 1;
#line 133
  maxw = (img->comps + 0)->w;
#line 133
  maxh = (img->comps + 0)->h;
#line 134
  max = maxw * maxh;
#line 136
  y = (int const   *)(img->comps + 0)->data;
#line 137
  cb = (int const   *)(img->comps + 1)->data;
#line 138
  cr = (int const   *)(img->comps + 2)->data;
#line 140
  __cil_tmp18 = malloc(sizeof(int ) * (size_t )max);
#line 140
  r = (int *)__cil_tmp18;
#line 140
  d0 = r;
#line 141
  __cil_tmp19 = malloc(sizeof(int ) * (size_t )max);
#line 141
  g = (int *)__cil_tmp19;
#line 141
  d1 = g;
#line 142
  __cil_tmp20 = malloc(sizeof(int ) * (size_t )max);
#line 142
  b = (int *)__cil_tmp20;
#line 142
  d2 = b;
#line 144
  i = 0U;
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;

#line 144
    if (! (i < maxh)) {
#line 144
      goto while_break;
    }
#line 146
    j = 0U;
    {
#line 146
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 146
      if (! (j < (maxw & 4294967294U))) {
#line 146
        goto while_break___0;
      }
      {
#line 148
      sycc_to_rgb(offset, upb, (int )*y, (int )*cb, (int )*cr, r, g, b);
#line 149
      y ++;
#line 149
      r ++;
#line 149
      g ++;
#line 149
      b ++;
#line 150
      sycc_to_rgb(offset, upb, (int )*y, (int )*cb, (int )*cr, r, g, b);
#line 151
      y ++;
#line 151
      r ++;
#line 151
      g ++;
#line 151
      b ++;
#line 151
      cb ++;
#line 151
      cr ++;
#line 146
      j += 2U;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 153
    if (j < maxw) {
      {
#line 154
      sycc_to_rgb(offset, upb, (int )*y, (int )*cb, (int )*cr, r, g, b);
#line 155
      y ++;
#line 155
      r ++;
#line 155
      g ++;
#line 155
      b ++;
#line 155
      cb ++;
#line 155
      cr ++;
      }
    }
#line 144
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 158
  free((void *)(img->comps + 0)->data);
#line 158
  (img->comps + 0)->data = d0;
#line 159
  free((void *)(img->comps + 1)->data);
#line 159
  (img->comps + 1)->data = d1;
#line 160
  free((void *)(img->comps + 2)->data);
#line 160
  (img->comps + 2)->data = d2;
#line 166
  (img->comps + 1)->w = maxw;
#line 166
  (img->comps + 1)->h = maxh;
#line 167
  (img->comps + 2)->w = maxw;
#line 167
  (img->comps + 2)->h = maxh;
#line 169
  (img->comps + 1)->dx = (img->comps + 0)->dx;
#line 170
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 171
  (img->comps + 1)->dy = (img->comps + 0)->dy;
#line 172
  (img->comps + 2)->dy = (img->comps + 0)->dy;
  }
#line 174
  return;
}
}
#line 176 "/root/patchweave_new/10/src/bin/common/color.c"
static void sycc420_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int *nr ;
  int *ng ;
  int *nb ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int const   *ny ;
  unsigned int maxw ;
  unsigned int maxh ;
  unsigned int max ;
  int offset ;
  int upb ;
  unsigned int i ;
  unsigned int j ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;

  {
  {
#line 184
  upb = (int )(img->comps + 0)->prec;
#line 185
  offset = 1 << (upb - 1);
#line 185
  upb = (1 << upb) - 1;
#line 187
  maxw = (img->comps + 0)->w;
#line 187
  maxh = (img->comps + 0)->h;
#line 188
  max = maxw * maxh;
#line 190
  y = (int const   *)(img->comps + 0)->data;
#line 191
  cb = (int const   *)(img->comps + 1)->data;
#line 192
  cr = (int const   *)(img->comps + 2)->data;
#line 194
  __cil_tmp22 = malloc(sizeof(int ) * (size_t )max);
#line 194
  r = (int *)__cil_tmp22;
#line 194
  d0 = r;
#line 195
  __cil_tmp23 = malloc(sizeof(int ) * (size_t )max);
#line 195
  g = (int *)__cil_tmp23;
#line 195
  d1 = g;
#line 196
  __cil_tmp24 = malloc(sizeof(int ) * (size_t )max);
#line 196
  b = (int *)__cil_tmp24;
#line 196
  d2 = b;
#line 198
  i = 0U;
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;

#line 198
    if (! (i < (maxh & 4294967294U))) {
#line 198
      goto while_break;
    }
#line 200
    ny = y + maxw;
#line 201
    nr = r + maxw;
#line 201
    ng = g + maxw;
#line 201
    nb = b + maxw;
#line 203
    j = 0U;
    {
#line 203
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 203
      if (! (j < (maxw & 4294967294U))) {
#line 203
        goto while_break___0;
      }
      {
#line 205
      sycc_to_rgb(offset, upb, (int )*y, (int )*cb, (int )*cr, r, g, b);
#line 206
      y ++;
#line 206
      r ++;
#line 206
      g ++;
#line 206
      b ++;
#line 207
      sycc_to_rgb(offset, upb, (int )*y, (int )*cb, (int )*cr, r, g, b);
#line 208
      y ++;
#line 208
      r ++;
#line 208
      g ++;
#line 208
      b ++;
#line 210
      sycc_to_rgb(offset, upb, (int )*ny, (int )*cb, (int )*cr, nr, ng, nb);
#line 211
      ny ++;
#line 211
      nr ++;
#line 211
      ng ++;
#line 211
      nb ++;
#line 212
      sycc_to_rgb(offset, upb, (int )*ny, (int )*cb, (int )*cr, nr, ng, nb);
#line 213
      ny ++;
#line 213
      nr ++;
#line 213
      ng ++;
#line 213
      nb ++;
#line 213
      cb ++;
#line 213
      cr ++;
#line 203
      j += 2U;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
#line 215
    if (j < maxw) {
      {
#line 217
      sycc_to_rgb(offset, upb, (int )*y, (int )*cb, (int )*cr, r, g, b);
#line 218
      y ++;
#line 218
      r ++;
#line 218
      g ++;
#line 218
      b ++;
#line 220
      sycc_to_rgb(offset, upb, (int )*ny, (int )*cb, (int )*cr, nr, ng, nb);
#line 221
      ny ++;
#line 221
      nr ++;
#line 221
      ng ++;
#line 221
      nb ++;
#line 221
      cb ++;
#line 221
      cr ++;
      }
    }
#line 223
    y += maxw;
#line 223
    r += maxw;
#line 223
    g += maxw;
#line 223
    b += maxw;
#line 198
    i += 2U;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 225
  if (i < maxh) {
#line 227
    j = 0U;
    {
#line 227
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 227
      if (! (j < (maxw & 4294967294U))) {
#line 227
        goto while_break___1;
      }
      {
#line 229
      sycc_to_rgb(offset, upb, (int )*y, (int )*cb, (int )*cr, r, g, b);
#line 231
      y ++;
#line 231
      r ++;
#line 231
      g ++;
#line 231
      b ++;
#line 233
      sycc_to_rgb(offset, upb, (int )*y, (int )*cb, (int )*cr, r, g, b);
#line 235
      y ++;
#line 235
      r ++;
#line 235
      g ++;
#line 235
      b ++;
#line 235
      cb ++;
#line 235
      cr ++;
#line 227
      j += 2U;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
#line 237
    if (j < maxw) {
      {
#line 239
      sycc_to_rgb(offset, upb, (int )*y, (int )*cb, (int )*cr, r, g, b);
      }
    }
  }
  {
#line 243
  free((void *)(img->comps + 0)->data);
#line 243
  (img->comps + 0)->data = d0;
#line 244
  free((void *)(img->comps + 1)->data);
#line 244
  (img->comps + 1)->data = d1;
#line 245
  free((void *)(img->comps + 2)->data);
#line 245
  (img->comps + 2)->data = d2;
#line 251
  (img->comps + 1)->w = maxw;
#line 251
  (img->comps + 1)->h = maxh;
#line 252
  (img->comps + 2)->w = maxw;
#line 252
  (img->comps + 2)->h = maxh;
#line 254
  (img->comps + 1)->dx = (img->comps + 0)->dx;
#line 255
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 256
  (img->comps + 1)->dy = (img->comps + 0)->dy;
#line 257
  (img->comps + 2)->dy = (img->comps + 0)->dy;
  }
#line 259
  return;
}
}
#line 261 "/root/patchweave_new/10/src/bin/common/color.c"
void color_sycc_to_rgb(opj_image_t *img ) 
{ 


  {
#line 263
  if (img->numcomps < 3U) {
#line 265
    img->color_space = (OPJ_COLOR_SPACE )2;
#line 266
    return;
  }
#line 269
  if ((img->comps + 0)->dx == 1U) {
#line 269
    if ((img->comps + 1)->dx == 2U) {
#line 269
      if ((img->comps + 2)->dx == 2U) {
#line 269
        if ((img->comps + 0)->dy == 1U) {
#line 269
          if ((img->comps + 1)->dy == 2U) {
#line 269
            if ((img->comps + 2)->dy == 2U) {
              {
#line 276
              sycc420_to_rgb(img);
              }
            } else {
#line 269
              goto _L___71;
            }
          } else {
#line 269
            goto _L___71;
          }
        } else {
#line 269
          goto _L___71;
        }
      } else {
#line 269
        goto _L___71;
      }
    } else {
#line 269
      goto _L___71;
    }
  } else
  _L___71: 
#line 279
  if ((img->comps + 0)->dx == 1U) {
#line 279
    if ((img->comps + 1)->dx == 2U) {
#line 279
      if ((img->comps + 2)->dx == 2U) {
#line 279
        if ((img->comps + 0)->dy == 1U) {
#line 279
          if ((img->comps + 1)->dy == 1U) {
#line 279
            if ((img->comps + 2)->dy == 1U) {
              {
#line 286
              sycc422_to_rgb(img);
              }
            } else {
#line 279
              goto _L;
            }
          } else {
#line 279
            goto _L;
          }
        } else {
#line 279
          goto _L;
        }
      } else {
#line 279
        goto _L;
      }
    } else {
#line 279
      goto _L;
    }
  } else
  _L: 
#line 289
  if ((img->comps + 0)->dx == 1U) {
#line 289
    if ((img->comps + 1)->dx == 1U) {
#line 289
      if ((img->comps + 2)->dx == 1U) {
#line 289
        if ((img->comps + 0)->dy == 1U) {
#line 289
          if ((img->comps + 1)->dy == 1U) {
#line 289
            if ((img->comps + 2)->dy == 1U) {
              {
#line 296
              sycc444_to_rgb(img);
              }
            } else {
              {
#line 300
              fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patchweave_new/10/src/bin/common/color.c",
                      300);
              }
#line 301
              return;
            }
          } else {
            {
#line 300
            fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patchweave_new/10/src/bin/common/color.c",
                    300);
            }
#line 301
            return;
          }
        } else {
          {
#line 300
          fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patchweave_new/10/src/bin/common/color.c",
                  300);
          }
#line 301
          return;
        }
      } else {
        {
#line 300
        fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patchweave_new/10/src/bin/common/color.c",
                300);
        }
#line 301
        return;
      }
    } else {
      {
#line 300
      fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patchweave_new/10/src/bin/common/color.c",
              300);
      }
#line 301
      return;
    }
  } else {
    {
#line 300
    fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patchweave_new/10/src/bin/common/color.c",
            300);
    }
#line 301
    return;
  }
#line 303
  img->color_space = (OPJ_COLOR_SPACE )1;
#line 304
  return;
}
}
