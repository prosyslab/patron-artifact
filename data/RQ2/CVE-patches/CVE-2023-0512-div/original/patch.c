#include <stdio.h>
#include <stdint.h>

int w_p_nu, w_p_rnu, w_p_so, p_so;
int w_virtcol, w_skipcol;

// Simplified Source: Vim
void init() {
  FILE *fp = fopen("data.txt", "r");
  fscanf(fp, "%d %d %d %d %d %d", &w_p_nu, &w_p_rnu, &w_p_so, &p_so, &w_virtcol, &w_skipcol);
}

/*
 * Return the effective 'scrolloff' value for the current window, using the
 * global value when appropriate.
 */
    long
get_scrolloff_value(void)
{
    return w_p_so < 0 ? p_so : w_p_so;
}

/*
 * Return the difference in column offset for the second screen line of a
 * wrapped line.  It's positive if 'number' or 'relativenumber' is on and 'n'
 * is in 'cpoptions'.
 */
    int
curwin_col_off()
{
    if (w_p_nu || w_p_rnu)  return 8;
    return 0;
}

/*
 * Called after changing the cursor column: make sure that curwin->w_skipcol is
 * valid for 'smoothscroll'.
 */
void
adjust_skipcol(void) {
  int	    width1 = curwin->w_width - curwin_col_off();
  if (width1 <= 0)
	return;
  int	    width2 = width1 + curwin_col_off();
  long    so = get_scrolloff_value();
  int	    scrolloff_cols = width1 + (so - 1) * width2;
  int	    scrolled = FALSE;

  while (w_skipcol > 0
    && w_virtcol < w_skipcol + 3 + scrolloff_cols)
  {
// scroll a screen line down
if (w_skipcol >= width1 + width2)
    w_skipcol -= width2;
else
    w_skipcol -= width1;
scrolled = TRUE;
  }
  if (scrolled)
	  return;  // don't scroll in the other direction now
  int col = w_virtcol - w_skipcol + scrolloff_cols;
  int row = 0;
  if (col >= width1)
  {
    col -= width1;
    ++row;
  }
  if (col > width2)
  {
    row += col / width2; // sink
    col = col % width2; // sink
  }
}

int main(int argc, char **argv) {
  
  init();
  adjust_skipcol();
  return 0;
}