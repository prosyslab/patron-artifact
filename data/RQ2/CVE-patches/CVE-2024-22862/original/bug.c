#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

#define AVERROR_BUFFER_TOO_SMALL -1
#define AVERROR_INVALIDDATA -2
#define INT_MAX 2147483647

typedef struct JXLParseContext {
    int skip;
} JXLParseContext;

typedef struct GetByteContext {
    const uint8_t *buffer, *buffer_end, *buffer_start;
    int eof;
    int error;
    const uint8_t *pos;
} GetByteContext;

int init_source(const uint8_t **buf, JXLParseContext **ctx) {
    int buf_size;
    FILE *fp;
    fp = fopen("test.txt", "w+");
    if (fp == NULL) {
        return -1;
    }
    fscanf(fp, "%d", &buf_size);
    *buf = (const uint8_t *)malloc(buf_size);
    *ctx = (JXLParseContext *)malloc(sizeof(JXLParseContext));
    fscanf(fp, "%d", &(*ctx)->skip);
    return buf_size;
}

void bytestream2_init(GetByteContext *s, const uint8_t *buf, int size) {
    s->buffer = buf;
    s->buffer_start = buf;
    s->buffer_end = buf + size;
    s->pos = buf;
    s->eof = 0;
    s->error = 0;
}

uint32_t bytestream2_get_be32(GetByteContext *s) {
    uint32_t val;
    val = (s->pos[0] << 24) | (s->pos[1] << 16) | (s->pos[2] << 8) | s->pos[3];
    s->pos += 4;
    return val;
}

uint64_t bytestream2_get_be64(GetByteContext *s) {
    uint64_t val;
    val = ((uint64_t)s->pos[0] << 56) | ((uint64_t)s->pos[1] << 48) | ((uint64_t)s->pos[2] << 40) | ((uint64_t)s->pos[3] << 32) |
          ((uint64_t)s->pos[4] << 24) | ((uint64_t)s->pos[5] << 16) | ((uint64_t)s->pos[6] << 8) | s->pos[7];
    s->pos += 8;
    return val;
}

static int skip_boxes(JXLParseContext *ctx, const uint8_t *buf, int buf_size) {
    struct GetByteContext gb;
    if (ctx->skip > buf_size)
        return AVERROR_BUFFER_TOO_SMALL;
    buf += ctx->skip;
    buf_size -= ctx->skip;
    bytestream2_init(&gb, buf, buf_size);
    while (1) {
        uint64_t size;
        int head_size = 4;
        size = bytestream2_get_be32(&gb);
        if (size == 1) {
            size = bytestream2_get_be64(&gb);
            head_size = 12;
        }
        if (!size)
            return AVERROR_INVALIDDATA;
        /* invalid ISOBMFF size */
        if (size <= head_size + 4)
            return AVERROR_INVALIDDATA;
        ctx->skip += size;
    }
    return 0;
}

int main(int argc, char **argv) {
    const uint8_t *buf;
    int buf_size;
    JXLParseContext *ctx;
    buf_size = init_source(&buf, &ctx);
    int res = skip_boxes(ctx, buf, buf_size);

    free((void *)buf);
    free(ctx);
    return 0;
}
