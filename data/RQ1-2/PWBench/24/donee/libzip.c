/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 368 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 370 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 371 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 377 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 386 "/usr/include/zconf.h"
typedef void *voidpf;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 83 "/usr/include/zlib.h"
struct internal_state ;
#line 85 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf  , uInt  , uInt  ) ;
   void (*zfree)(voidpf  , voidpf  ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 104 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 106 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1742 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 134 "/usr/include/stdint.h"
typedef long intmax_t;
#line 135 "/usr/include/stdint.h"
typedef unsigned long uintmax_t;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 22 "./zipconf.h"
typedef uint8_t zip_uint8_t;
#line 25 "./zipconf.h"
typedef int16_t zip_int16_t;
#line 29 "./zipconf.h"
typedef uint16_t zip_uint16_t;
#line 32 "./zipconf.h"
typedef int32_t zip_int32_t;
#line 36 "./zipconf.h"
typedef uint32_t zip_uint32_t;
#line 39 "./zipconf.h"
typedef int64_t zip_int64_t;
#line 43 "./zipconf.h"
typedef uint64_t zip_uint64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE ;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 310 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 208 "/root/libzip/lib/zip.h"
enum zip_source_cmd {
    ZIP_SOURCE_OPEN = 0,
    ZIP_SOURCE_READ = 1,
    ZIP_SOURCE_CLOSE = 2,
    ZIP_SOURCE_STAT = 3,
    ZIP_SOURCE_ERROR = 4,
    ZIP_SOURCE_FREE = 5,
    ZIP_SOURCE_SEEK = 6,
    ZIP_SOURCE_TELL = 7,
    ZIP_SOURCE_BEGIN_WRITE = 8,
    ZIP_SOURCE_COMMIT_WRITE = 9,
    ZIP_SOURCE_ROLLBACK_WRITE = 10,
    ZIP_SOURCE_WRITE = 11,
    ZIP_SOURCE_SEEK_WRITE = 12,
    ZIP_SOURCE_TELL_WRITE = 13,
    ZIP_SOURCE_SUPPORTS = 14,
    ZIP_SOURCE_REMOVE = 15
} ;
#line 226 "/root/libzip/lib/zip.h"
typedef enum zip_source_cmd zip_source_cmd_t;
#line 252 "/root/libzip/lib/zip.h"
struct zip_source_args_seek {
   zip_int64_t offset ;
   int whence ;
};
#line 257 "/root/libzip/lib/zip.h"
typedef struct zip_source_args_seek zip_source_args_seek_t;
#line 263 "/root/libzip/lib/zip.h"
struct zip_error {
   int zip_err ;
   int sys_err ;
   char *str ;
};
#line 279 "/root/libzip/lib/zip.h"
struct zip_stat {
   zip_uint64_t valid ;
   char const   *name ;
   zip_uint64_t index ;
   zip_uint64_t size ;
   zip_uint64_t comp_size ;
   time_t mtime ;
   zip_uint32_t crc ;
   zip_uint16_t comp_method ;
   zip_uint16_t encryption_method ;
   zip_uint32_t flags ;
};
#line 292
struct zip ;
#line 293
struct zip_file ;
#line 294
struct zip_source ;
#line 296 "/root/libzip/lib/zip.h"
typedef struct zip zip_t;
#line 297 "/root/libzip/lib/zip.h"
typedef struct zip_error zip_error_t;
#line 298 "/root/libzip/lib/zip.h"
typedef struct zip_file zip_file_t;
#line 299 "/root/libzip/lib/zip.h"
typedef struct zip_source zip_source_t;
#line 300 "/root/libzip/lib/zip.h"
typedef struct zip_stat zip_stat_t;
#line 302 "/root/libzip/lib/zip.h"
typedef zip_uint32_t zip_flags_t;
#line 214 "/root/libzip/lib/zipint.h"
typedef zip_source_t *(*zip_compression_implementation)(zip_t * , zip_source_t * ,
                                                        zip_int32_t  , int  );
#line 215 "/root/libzip/lib/zipint.h"
typedef zip_source_t *(*zip_encryption_implementation)(zip_t * , zip_source_t * ,
                                                       zip_uint16_t  , int  , char const   * );
#line 264
enum zip_encoding_type {
    ZIP_ENCODING_UNKNOWN = 0,
    ZIP_ENCODING_ASCII = 1,
    ZIP_ENCODING_UTF8_KNOWN = 2,
    ZIP_ENCODING_UTF8_GUESSED = 3,
    ZIP_ENCODING_CP437 = 4,
    ZIP_ENCODING_ERROR = 5
} ;
#line 273 "/root/libzip/lib/zipint.h"
typedef enum zip_encoding_type zip_encoding_type_t;
#line 279
struct zip_hash ;
#line 281
struct zip_cdir ;
#line 281 "/root/libzip/lib/zipint.h"
typedef struct zip_cdir zip_cdir_t;
#line 282
struct zip_dirent ;
#line 282 "/root/libzip/lib/zipint.h"
typedef struct zip_dirent zip_dirent_t;
#line 283
struct zip_entry ;
#line 283 "/root/libzip/lib/zipint.h"
typedef struct zip_entry zip_entry_t;
#line 284
struct zip_extra_field ;
#line 284 "/root/libzip/lib/zipint.h"
typedef struct zip_extra_field zip_extra_field_t;
#line 285
struct zip_string ;
#line 285 "/root/libzip/lib/zipint.h"
typedef struct zip_string zip_string_t;
#line 286
struct zip_buffer ;
#line 286 "/root/libzip/lib/zipint.h"
typedef struct zip_buffer zip_buffer_t;
#line 287 "/root/libzip/lib/zipint.h"
typedef struct zip_hash zip_hash_t;
#line 291 "/root/libzip/lib/zipint.h"
struct zip {
   zip_source_t *src ;
   unsigned int open_flags ;
   zip_error_t error ;
   unsigned int flags ;
   unsigned int ch_flags ;
   char *default_password ;
   zip_string_t *comment_orig ;
   zip_string_t *comment_changes ;
   int comment_changed ;
   zip_uint64_t nentry ;
   zip_uint64_t nentry_alloc ;
   zip_entry_t *entry ;
   unsigned int nopen_source ;
   unsigned int nopen_source_alloc ;
   zip_source_t **open_source ;
   zip_hash_t *names ;
   char *tempdir ;
};
#line 320 "/root/libzip/lib/zipint.h"
struct zip_file {
   zip_t *za ;
   zip_error_t error ;
   int eof ;
   zip_source_t *src ;
};
#line 337 "/root/libzip/lib/zipint.h"
struct zip_dirent {
   zip_uint32_t changed ;
   int local_extra_fields_read ;
   int cloned ;
   zip_uint16_t version_madeby ;
   zip_uint16_t version_needed ;
   zip_uint16_t bitflags ;
   zip_int32_t comp_method ;
   time_t last_mod ;
   zip_uint32_t crc ;
   zip_uint64_t comp_size ;
   zip_uint64_t uncomp_size ;
   zip_string_t *filename ;
   zip_extra_field_t *extra_fields ;
   zip_string_t *comment ;
   zip_uint32_t disk_number ;
   zip_uint16_t int_attrib ;
   zip_uint32_t ext_attrib ;
   zip_uint64_t offset ;
};
#line 361 "/root/libzip/lib/zipint.h"
struct zip_cdir {
   zip_entry_t *entry ;
   zip_uint64_t nentry ;
   zip_uint64_t nentry_alloc ;
   zip_uint64_t size ;
   zip_uint64_t offset ;
   zip_string_t *comment ;
};
#line 371 "/root/libzip/lib/zipint.h"
struct zip_extra_field {
   zip_extra_field_t *next ;
   zip_flags_t flags ;
   zip_uint16_t id ;
   zip_uint16_t size ;
   zip_uint8_t *data ;
};
#line 379
enum zip_source_write_state {
    ZIP_SOURCE_WRITE_CLOSED = 0,
    ZIP_SOURCE_WRITE_OPEN = 1,
    ZIP_SOURCE_WRITE_FAILED = 2,
    ZIP_SOURCE_WRITE_REMOVED = 3
} ;
#line 385 "/root/libzip/lib/zipint.h"
typedef enum zip_source_write_state zip_source_write_state_t;
#line 389 "/root/libzip/lib/zipint.h"
union __anonunion_21 {
   zip_int64_t (*f)(void * , void * , zip_uint64_t  , zip_source_cmd_t  ) ;
   zip_int64_t (*l)(zip_source_t * , void * , void * , zip_uint64_t  , enum zip_source_cmd  ) ;
};
#line 387 "/root/libzip/lib/zipint.h"
struct zip_source {
   zip_source_t *src ;
   union __anonunion_21 cb ;
   void *ud ;
   zip_error_t error ;
   zip_int64_t supports ;
   unsigned int open_count ;
   zip_source_write_state_t write_state ;
   int source_closed ;
   zip_t *source_archive ;
   unsigned int refcount ;
};
#line 409 "/root/libzip/lib/zipint.h"
struct zip_entry {
   zip_dirent_t *orig ;
   zip_dirent_t *changes ;
   zip_source_t *source ;
   int deleted ;
};
#line 419 "/root/libzip/lib/zipint.h"
struct zip_string {
   zip_uint8_t *raw ;
   zip_uint16_t length ;
   enum zip_encoding_type encoding ;
   zip_uint8_t *converted ;
   zip_uint32_t converted_length ;
};
#line 430 "/root/libzip/lib/zipint.h"
struct zip_buffer {
   int ok ;
   int free_data ;
   zip_uint8_t *data ;
   zip_uint64_t size ;
   zip_uint64_t offset ;
};
#line 441 "/root/libzip/lib/zipint.h"
struct zip_filelist {
   zip_uint64_t idx ;
};
#line 446 "/root/libzip/lib/zipint.h"
typedef struct zip_filelist zip_filelist_t;
#line 328 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef int wchar_t;
#line 40 "/root/libzip/lib/zip_source_window.c"
struct window {
   zip_uint64_t start ;
   zip_uint64_t end ;
   zip_uint64_t offset ;
   zip_stat_t stat ;
   zip_error_t error ;
   zip_int64_t supports ;
   int needs_seek ;
};
#line 40 "/root/libzip/lib/zip_source_pkware.c"
struct trad_pkware {
   zip_error_t error ;
   zip_uint32_t key[3] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 67 "/root/libzip/lib/zip_source_filep.c"
struct read_file {
   zip_error_t error ;
   zip_int64_t supports ;
   char *fname ;
   FILE *f ;
   struct zip_stat st ;
   zip_uint64_t start ;
   zip_uint64_t end ;
   zip_uint64_t current ;
   char *tmpname ;
   FILE *fout ;
};
#line 40 "/root/libzip/lib/zip_source_deflate.c"
struct deflate {
   zip_error_t error ;
   int eof ;
   int can_store ;
   int is_stored ;
   int mem_level ;
   zip_uint64_t size ;
   zip_uint8_t buffer[8192] ;
   z_stream zstr ;
};
#line 41 "/root/libzip/lib/zip_source_crc.c"
struct crc_context {
   int validate ;
   int crc_complete ;
   zip_error_t error ;
   zip_uint64_t size ;
   zip_uint64_t position ;
   zip_uint64_t crc_position ;
   zip_uint32_t crc ;
};
#line 43 "/root/libzip/lib/zip_source_buffer.c"
struct buffer {
   zip_uint64_t fragment_size ;
   zip_uint8_t **fragments ;
   zip_uint64_t nfragments ;
   zip_uint64_t fragments_capacity ;
   zip_uint64_t size ;
   zip_uint64_t offset ;
   int free_data ;
};
#line 54 "/root/libzip/lib/zip_source_buffer.c"
typedef struct buffer buffer_t;
#line 56 "/root/libzip/lib/zip_source_buffer.c"
struct read_data {
   zip_error_t error ;
   time_t mtime ;
   buffer_t *in ;
   buffer_t *out ;
};
#line 43 "/root/libzip/lib/zip_open.c"
enum __anonenum__163 {
    EXISTS_ERROR = -1,
    EXISTS_NOT = 0,
    EXISTS_EMPTY = 1,
    EXISTS_NONEMPTY = 2
} ;
#line 48 "/root/libzip/lib/zip_open.c"
typedef enum __anonenum__163 exists_t;
#line 38 "/root/libzip/lib/zip_hash.c"
struct zip_hash_entry {
   zip_uint8_t *name ;
   zip_int64_t orig_index ;
   zip_int64_t current_index ;
   struct zip_hash_entry *next ;
};
#line 44 "/root/libzip/lib/zip_hash.c"
typedef struct zip_hash_entry zip_hash_entry_t;
#line 46 "/root/libzip/lib/zip_hash.c"
struct zip_hash {
   zip_uint16_t table_size ;
   zip_hash_entry_t **table ;
};
#line 58 "/root/libzip/src/ziptool.c"
enum __anonenum__224 {
    SOURCE_TYPE_NONE = 0,
    SOURCE_TYPE_IN_MEMORY = 1,
    SOURCE_TYPE_HOLE = 2
} ;
#line 62 "/root/libzip/src/ziptool.c"
typedef enum __anonenum__224 source_type_t;
#line 64 "/root/libzip/src/ziptool.c"
struct dispatch_table_s {
   char const   *cmdline_name ;
   int argument_count ;
   char const   *arg_names ;
   char const   *description ;
   int (*function)(int  , char ** ) ;
};
#line 70 "/root/libzip/src/ziptool.c"
typedef struct dispatch_table_s dispatch_table_t;
#line 723 "/root/libzip/src/ziptool.c"
struct source_nul {
   zip_error_t error ;
   zip_uint64_t length ;
   zip_uint64_t offset ;
};
#line 727 "/root/libzip/src/ziptool.c"
typedef struct source_nul source_nul_t;
#line 61 "/root/libzip/src/source_hole.c"
struct buffer___0 {
   zip_uint64_t fragment_size ;
   zip_uint8_t **fragment ;
   zip_uint64_t nfragments ;
   zip_uint64_t size ;
   zip_uint64_t offset ;
};
#line 67 "/root/libzip/src/source_hole.c"
typedef struct buffer___0 buffer_t___0;
#line 83 "/root/libzip/src/source_hole.c"
struct hole {
   zip_error_t error ;
   char *fname ;
   buffer_t___0 *in ;
   buffer_t___0 *out ;
};
#line 88 "/root/libzip/src/source_hole.c"
typedef struct hole hole_t;
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
#line 27 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_major)(unsigned long long __dev ) ;
#line 30
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_minor)(unsigned long long __dev ) ;
#line 33
__inline extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__gnu_inline__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                                    unsigned int __minor ) ;
#line 39
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_major)(unsigned long long __dev ) ;
#line 39 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_major)(unsigned long long __dev ) 
{ 


  {
#line 41
  return ((unsigned int )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
#line 45
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_minor)(unsigned long long __dev ) ;
#line 45 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_minor)(unsigned long long __dev ) 
{ 


  {
#line 47
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
#line 51
__inline extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__gnu_inline__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                                    unsigned int __minor ) ;
#line 51 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned long long ( __attribute__((__gnu_inline__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                      unsigned int __minor ) 
{ 


  {
#line 53
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 363
__inline extern ssize_t ( __attribute__((__gnu_inline__)) read)(int __fd , void *__buf ,
                                                                size_t __nbytes ) ;
#line 514
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getcwd)(char *__buf ,
                                                                                              size_t __size ) ;
#line 528
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getwd)(char *__buf ) ;
#line 534
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 626
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) confstr)(int __name ,
                                                                                                char *__buf ,
                                                                                                size_t __len ) ;
#line 692
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getgroups)(int __size ,
                                                                                               __gid_t *__list ) ;
#line 777
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ttyname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 812
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__gnu_inline__)) readlink)(char const   *__path ,
                                                                                                  char *__buf ,
                                                                                                  size_t __len ) ;
#line 823
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__gnu_inline__)) readlinkat)(int __fd ,
                                                                                                    char const   *__path ,
                                                                                                    char *__buf ,
                                                                                                    size_t __len ) ;
#line 829
extern  __attribute__((__nothrow__)) int unlink(char const   *__name ) ;
#line 860
__inline extern int ( __attribute__((__gnu_inline__)) getlogin_r)(char *__buf , size_t __buflen ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 80
extern int optopt ;
#line 150
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 882 "/usr/include/unistd.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) gethostname)(char *__buf ,
                                                                                                 size_t __buflen ) ;
#line 900
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getdomainname)(char *__buf ,
                                                                                                   size_t __buflen ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t __read_chk(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 25
extern ssize_t __read_alias(int __fd , void *__buf , size_t __nbytes ) ;
#line 27
extern ssize_t __read_chk_warn(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__gnu_inline__)) read)(int __fd , void *__buf ,
                                                                size_t __nbytes ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 36
  __cil_tmp4 = __builtin_object_size(__buf, 0);
  }
#line 36
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 38
    __cil_tmp5 = 0;
#line 38
    if (! __cil_tmp5) {
      {
#line 39
      __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 39
      __cil_tmp7 = __read_chk(__fd, __buf, __nbytes, __cil_tmp6);
      }
#line 39
      return (__cil_tmp7);
    }
    {
#line 41
    __cil_tmp8 = __builtin_object_size(__buf, 0);
    }
#line 41
    if (__nbytes > __cil_tmp8) {
      {
#line 42
      __cil_tmp9 = __builtin_object_size(__buf, 0);
#line 42
      __cil_tmp10 = __read_chk_warn(__fd, __buf, __nbytes, __cil_tmp9);
      }
#line 42
      return (__cil_tmp10);
    }
  }
  {
#line 44
  __cil_tmp11 = __read_alias(__fd, __buf, __nbytes);
  }
#line 44
  return (__cil_tmp11);
}
}
#line 123
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk(char const   *__path ,
                                                            char *__buf , size_t __len ,
                                                            size_t __buflen ) ;
#line 127
extern  __attribute__((__nothrow__)) ssize_t __readlink_alias(char const   *__path ,
                                                              char *__buf , size_t __len ) ;
#line 131
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk_warn(char const   *__path ,
                                                                 char *__buf , size_t __len ,
                                                                 size_t __buflen ) ;
#line 139
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__gnu_inline__)) readlink)(char const   *__path ,
                                                                                                  char *__buf ,
                                                                                                  size_t __len ) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__gnu_inline__)) readlink)(char const   *__path ,
                                                                    char *__buf ,
                                                                    size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 142
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 142
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 144
    __cil_tmp5 = 0;
#line 144
    if (! __cil_tmp5) {
      {
#line 145
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 145
      __cil_tmp7 = __readlink_chk(__path, __buf, __len, __cil_tmp6);
      }
#line 145
      return (__cil_tmp7);
    }
    {
#line 147
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 147
    if (__len > __cil_tmp8) {
      {
#line 148
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 148
      __cil_tmp10 = __readlink_chk_warn(__path, __buf, __len, __cil_tmp9);
      }
#line 148
      return (__cil_tmp10);
    }
  }
  {
#line 150
  __cil_tmp11 = __readlink_alias(__path, __buf, __len);
  }
#line 150
  return (__cil_tmp11);
}
}
#line 155
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk(int __fd , char const   *__path ,
                                                              char *__buf , size_t __len ,
                                                              size_t __buflen ) ;
#line 159
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_alias(int __fd , char const   *__path ,
                                                                char *__buf , size_t __len ) ;
#line 164
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk_warn(int __fd , char const   *__path ,
                                                                   char *__buf , size_t __len ,
                                                                   size_t __buflen ) ;
#line 173
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__gnu_inline__)) readlinkat)(int __fd ,
                                                                                                    char const   *__path ,
                                                                                                    char *__buf ,
                                                                                                    size_t __len ) ;
#line 173 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__gnu_inline__)) readlinkat)(int __fd , char const   *__path ,
                                                                      char *__buf ,
                                                                      size_t __len ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  ssize_t __cil_tmp12 ;

  {
  {
#line 176
  __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
  }
#line 176
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 178
    __cil_tmp6 = 0;
#line 178
    if (! __cil_tmp6) {
      {
#line 179
      __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
#line 179
      __cil_tmp8 = __readlinkat_chk(__fd, __path, __buf, __len, __cil_tmp7);
      }
#line 179
      return (__cil_tmp8);
    }
    {
#line 181
    __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
    }
#line 181
    if (__len > __cil_tmp9) {
      {
#line 182
      __cil_tmp10 = __builtin_object_size((void *)__buf, 1);
#line 182
      __cil_tmp11 = __readlinkat_chk_warn(__fd, __path, __buf, __len, __cil_tmp10);
      }
#line 182
      return (__cil_tmp11);
    }
  }
  {
#line 185
  __cil_tmp12 = __readlinkat_alias(__fd, __path, __buf, __len);
  }
#line 185
  return (__cil_tmp12);
}
}
#line 189
extern  __attribute__((__nothrow__)) char *__getcwd_chk(char *__buf , size_t __size ,
                                                        size_t __buflen ) ;
#line 191
extern  __attribute__((__nothrow__)) char *__getcwd_alias(char *__buf , size_t __size ) ;
#line 193
extern  __attribute__((__nothrow__)) char *__getcwd_chk_warn(char *__buf , size_t __size ,
                                                             size_t __buflen ) ;
#line 200
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getcwd)(char *__buf ,
                                                                                              size_t __size ) ;
#line 200 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *( __attribute__((__gnu_inline__)) getcwd)(char *__buf , size_t __size ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 202
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 202
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 204
    __cil_tmp4 = 0;
#line 204
    if (! __cil_tmp4) {
      {
#line 205
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 205
      __cil_tmp6 = __getcwd_chk(__buf, __size, __cil_tmp5);
      }
#line 205
      return (__cil_tmp6);
    }
    {
#line 207
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 207
    if (__size > __cil_tmp7) {
      {
#line 208
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 208
      __cil_tmp9 = __getcwd_chk_warn(__buf, __size, __cil_tmp8);
      }
#line 208
      return (__cil_tmp9);
    }
  }
  {
#line 210
  __cil_tmp10 = __getcwd_alias(__buf, __size);
  }
#line 210
  return (__cil_tmp10);
}
}
#line 214
extern  __attribute__((__nothrow__)) char *__getwd_chk(char *__buf , size_t buflen ) ;
#line 216
extern  __attribute__((__nothrow__)) char *__getwd_warn(char *__buf ) ;
#line 221
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getwd)(char *__buf ) ;
#line 221 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *( __attribute__((__gnu_inline__)) getwd)(char *__buf ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 223
  __cil_tmp2 = __builtin_object_size((void *)__buf, 1);
  }
#line 223
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 224
    __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
#line 224
    __cil_tmp4 = __getwd_chk(__buf, __cil_tmp3);
    }
#line 224
    return (__cil_tmp4);
  }
  {
#line 225
  __cil_tmp5 = __getwd_warn(__buf);
  }
#line 225
  return (__cil_tmp5);
}
}
#line 229
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
#line 231
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen ) ;
#line 240
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) confstr)(int __name ,
                                                                                                char *__buf ,
                                                                                                size_t __len ) ;
#line 240 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) confstr)(int __name , char *__buf ,
                                                                  size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 242
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 242
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 244
    __cil_tmp5 = 0;
#line 244
    if (! __cil_tmp5) {
      {
#line 245
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 245
      __cil_tmp7 = __confstr_chk(__name, __buf, __len, __cil_tmp6);
      }
#line 245
      return (__cil_tmp7);
    }
    {
#line 247
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 247
    if (__cil_tmp8 < __len) {
      {
#line 248
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 248
      __cil_tmp10 = __confstr_chk_warn(__name, __buf, __len, __cil_tmp9);
      }
#line 248
      return (__cil_tmp10);
    }
  }
  {
#line 250
  __cil_tmp11 = __confstr_alias(__name, __buf, __len);
  }
#line 250
  return (__cil_tmp11);
}
}
#line 254
extern  __attribute__((__nothrow__)) int __getgroups_chk(int __size , __gid_t *__list ,
                                                         size_t __listlen ) ;
#line 256
extern  __attribute__((__nothrow__)) int __getgroups_alias(int __size , __gid_t *__list ) ;
#line 258
extern  __attribute__((__nothrow__)) int __getgroups_chk_warn(int __size , __gid_t *__list ,
                                                              size_t __listlen ) ;
#line 265
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getgroups)(int __size ,
                                                                                               __gid_t *__list ) ;
#line 265 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) getgroups)(int __size , __gid_t *__list ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 267
  __cil_tmp3 = __builtin_object_size((void *)__list, 1);
  }
#line 267
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 269
    __cil_tmp4 = 0;
#line 269
    if (! __cil_tmp4) {
      {
#line 270
      __cil_tmp5 = __builtin_object_size((void *)__list, 1);
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
#line 270
      return (__cil_tmp6);
    } else
#line 269
    if (__size < 0) {
      {
#line 270
      __cil_tmp5 = __builtin_object_size((void *)__list, 1);
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
#line 270
      return (__cil_tmp6);
    }
    {
#line 272
    __cil_tmp7 = __builtin_object_size((void *)__list, 1);
    }
#line 272
    if ((unsigned long )__size * sizeof(__gid_t ) > __cil_tmp7) {
      {
#line 273
      __cil_tmp8 = __builtin_object_size((void *)__list, 1);
#line 273
      __cil_tmp9 = __getgroups_chk_warn(__size, __list, __cil_tmp8);
      }
#line 273
      return (__cil_tmp9);
    }
  }
  {
#line 275
  __cil_tmp10 = __getgroups_alias(__size, __list);
  }
#line 275
  return (__cil_tmp10);
}
}
#line 279
extern  __attribute__((__nothrow__)) int __ttyname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 281
extern  __attribute__((__nothrow__)) int __ttyname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 284
extern  __attribute__((__nothrow__)) int __ttyname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 291
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ttyname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 291 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                                 size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 293
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 293
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 295
    __cil_tmp5 = 0;
#line 295
    if (! __cil_tmp5) {
      {
#line 296
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 296
      __cil_tmp7 = __ttyname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 296
      return (__cil_tmp7);
    }
    {
#line 298
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 298
    if (__buflen > __cil_tmp8) {
      {
#line 299
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 299
      __cil_tmp10 = __ttyname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 299
      return (__cil_tmp10);
    }
  }
  {
#line 301
  __cil_tmp11 = __ttyname_r_alias(__fd, __buf, __buflen);
  }
#line 301
  return (__cil_tmp11);
}
}
#line 306
extern int __getlogin_r_chk(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 308
extern int __getlogin_r_alias(char *__buf , size_t __buflen ) ;
#line 310
extern int __getlogin_r_chk_warn(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 317 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) getlogin_r)(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 319
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 319
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 321
    __cil_tmp4 = 0;
#line 321
    if (! __cil_tmp4) {
      {
#line 322
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 322
      __cil_tmp6 = __getlogin_r_chk(__buf, __buflen, __cil_tmp5);
      }
#line 322
      return (__cil_tmp6);
    }
    {
#line 324
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 324
    if (__buflen > __cil_tmp7) {
      {
#line 325
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 325
      __cil_tmp9 = __getlogin_r_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 325
      return (__cil_tmp9);
    }
  }
  {
#line 327
  __cil_tmp10 = __getlogin_r_alias(__buf, __buflen);
  }
#line 327
  return (__cil_tmp10);
}
}
#line 333
extern  __attribute__((__nothrow__)) int __gethostname_chk(char *__buf , size_t __buflen ,
                                                           size_t __nreal ) ;
#line 335
extern  __attribute__((__nothrow__)) int __gethostname_alias(char *__buf , size_t __buflen ) ;
#line 337
extern  __attribute__((__nothrow__)) int __gethostname_chk_warn(char *__buf , size_t __buflen ,
                                                                size_t __nreal ) ;
#line 344
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) gethostname)(char *__buf ,
                                                                                                 size_t __buflen ) ;
#line 344 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) gethostname)(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 346
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 346
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 348
    __cil_tmp4 = 0;
#line 348
    if (! __cil_tmp4) {
      {
#line 349
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 349
      __cil_tmp6 = __gethostname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 349
      return (__cil_tmp6);
    }
    {
#line 351
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 351
    if (__buflen > __cil_tmp7) {
      {
#line 352
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 352
      __cil_tmp9 = __gethostname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 352
      return (__cil_tmp9);
    }
  }
  {
#line 354
  __cil_tmp10 = __gethostname_alias(__buf, __buflen);
  }
#line 354
  return (__cil_tmp10);
}
}
#line 360
extern  __attribute__((__nothrow__)) int __getdomainname_chk(char *__buf , size_t __buflen ,
                                                             size_t __nreal ) ;
#line 362
extern  __attribute__((__nothrow__)) int __getdomainname_alias(char *__buf , size_t __buflen ) ;
#line 365
extern  __attribute__((__nothrow__)) int __getdomainname_chk_warn(char *__buf , size_t __buflen ,
                                                                  size_t __nreal ) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getdomainname)(char *__buf ,
                                                                                                   size_t __buflen ) ;
#line 373 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) getdomainname)(char *__buf ,
                                                                     size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 375
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 375
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 377
    __cil_tmp4 = 0;
#line 377
    if (! __cil_tmp4) {
      {
#line 378
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 378
      __cil_tmp6 = __getdomainname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 378
      return (__cil_tmp6);
    }
    {
#line 380
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 380
    if (__buflen > __cil_tmp7) {
      {
#line 381
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 381
      __cil_tmp9 = __getdomainname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 381
      return (__cil_tmp9);
    }
  }
  {
#line 383
  __cil_tmp10 = __getdomainname_alias(__buf, __buflen);
  }
#line 383
  return (__cil_tmp10);
}
}
#line 246 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 353
extern int deflateEnd(z_streamp strm ) ;
#line 392
extern int inflate(z_streamp strm , int flush ) ;
#line 508
extern int inflateEnd(z_streamp strm ) ;
#line 1600
extern uLong crc32(uLong crc , Bytef *buf , uInt len ) ;
#line 1637
extern int deflateInit2_(z_streamp strm , int level , int method , int windowBits ,
                         int memLevel , int strategy , char const   *version , int stream_size ) ;
#line 1641
extern int inflateInit2_(z_streamp strm , int windowBits , char const   *version ,
                         int stream_size ) ;
#line 1746
extern char const   *zError(int  ) ;
#line 297 "/usr/include/inttypes.h"
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                                                    char **endptr ,
                                                                                                    int base ) ;
#line 301
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                                                     char **endptr ,
                                                                                                     int base ) ;
#line 305
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                                                    __gwchar_t **endptr ,
                                                                                                    int base ) ;
#line 310
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                                                     __gwchar_t **endptr ,
                                                                                                     int base ) ;
#line 318
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   *__nptr ,
                                                            char **__endptr , int __base ,
                                                            int __group ) ;
#line 324
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                                                    char **endptr ,
                                                                                                    int base ) ;
#line 324 "/usr/include/inttypes.h"
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                      char **endptr ,
                                                                      int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 327
  __cil_tmp4 = __strtol_internal(nptr, endptr, base, 0);
  }
#line 327
  return (__cil_tmp4);
}
}
#line 330
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 336
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                                                     char **endptr ,
                                                                                                     int base ) ;
#line 336 "/usr/include/inttypes.h"
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                       char **endptr ,
                                                                       int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 339
  __cil_tmp4 = __strtoul_internal(nptr, endptr, base, 0);
  }
#line 339
  return (__cil_tmp4);
}
}
#line 342
extern  __attribute__((__nothrow__)) long __wcstol_internal(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                            int __base , int __group ) ;
#line 348
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                                                    __gwchar_t **endptr ,
                                                                                                    int base ) ;
#line 348 "/usr/include/inttypes.h"
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                      __gwchar_t **endptr ,
                                                                      int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 351
  __cil_tmp4 = __wcstol_internal(nptr, endptr, base, 0);
  }
#line 351
  return (__cil_tmp4);
}
}
#line 354
extern  __attribute__((__nothrow__)) unsigned long __wcstoul_internal(__gwchar_t *__nptr ,
                                                                      __gwchar_t **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                                                     __gwchar_t **endptr ,
                                                                                                     int base ) ;
#line 362 "/usr/include/inttypes.h"
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                       __gwchar_t **endptr ,
                                                                       int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 365
  __cil_tmp4 = __wcstoul_internal(nptr, endptr, base, 0);
  }
#line 365
  return (__cil_tmp4);
}
}
#line 386 "/usr/include/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 387
extern int __overflow(_IO_FILE * , int  ) ;
#line 429
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 430
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 178
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 180
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 356
__inline extern int ( __attribute__((__gnu_inline__)) fprintf)(FILE *__stream , char const   *__fmt 
                                                               , ...) ;
#line 362
__inline extern int ( __attribute__((__gnu_inline__)) printf)(char const   *__fmt 
                                                              , ...) ;
#line 364
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) sprintf)(char *__s ,
                                                                                             char const   *__fmt 
                                                                                             , ...) ;
#line 371
__inline extern int ( __attribute__((__gnu_inline__)) vfprintf)(FILE *__stream , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) ;
#line 377
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   *__fmt ,
                                                               __gnuc_va_list __ap ) ;
#line 379
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s ,
                                                                                              char const   *__fmt ,
                                                                                              __gnuc_va_list __ap ) ;
#line 386
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) snprintf)(char *__s ,
                                                                                              size_t __n ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 390
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s ,
                                                                                               size_t __n ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 412
__inline extern int ( __attribute__((__gnu_inline__)) vdprintf)(int __fd , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) ;
#line 415
__inline extern int ( __attribute__((__gnu_inline__)) dprintf)(int __fd , char const   *__fmt 
                                                               , ...) ;
#line 538
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 551
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 561
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 580
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 594
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 603
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 622
__inline extern char *( __attribute__((__gnu_inline__)) fgets)(char *__s , int __n ,
                                                               FILE *__stream ) ;
#line 709
__inline extern unsigned long ( __attribute__((__gnu_inline__)) fread)(void *__ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE *__stream ) ;
#line 715
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 737
__inline extern size_t ( __attribute__((__gnu_inline__)) fread_unlocked)(void *__ptr ,
                                                                         size_t __size ,
                                                                         size_t __n ,
                                                                         FILE *__stream ) ;
#line 773
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 778
extern __off_t ftello(FILE *__stream ) ;
#line 826
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 836
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 837
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 44 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 46
  __cil_tmp1 = _IO_getc(stdin);
  }
#line 46
  return (__cil_tmp1);
}
}
#line 53 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  int tmp ;

  {
  {
#line 55
  __cil_tmp2 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                                0L);
  }
#line 55
  if (__cil_tmp2) {
    {
#line 55
    __cil_tmp3 = __uflow(__fp);
#line 55
    tmp = __cil_tmp3;
    }
  } else {
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 55
  return (tmp);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  int tmp ;

  {
  {
#line 72
  __cil_tmp1 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                                0L);
  }
#line 72
  if (__cil_tmp1) {
    {
#line 72
    __cil_tmp2 = __uflow(stdin);
#line 72
    tmp = __cil_tmp2;
    }
  } else {
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 72
  return (tmp);
}
}
#line 79 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 81
  __cil_tmp2 = _IO_putc(__c, stdout);
  }
#line 81
  return (__cil_tmp2);
}
}
#line 88 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                                0L);
  }
#line 90
  if (__cil_tmp3) {
    {
#line 90
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp = __cil_tmp4;
    }
  } else {
#line 90
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    *__cil_tmp5 = (char )__c;
#line 90
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 90
  return (tmp);
}
}
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 107
  __cil_tmp2 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                                0L);
  }
#line 107
  if (__cil_tmp2) {
    {
#line 107
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp = __cil_tmp3;
    }
  } else {
#line 107
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    *__cil_tmp4 = (char )__c;
#line 107
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 107
  return (tmp);
}
}
#line 125
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 125 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 127
  return ((__stream->_flags & 16) != 0);
}
}
#line 132
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 132 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 134
  return ((__stream->_flags & 32) != 0);
}
}
#line 31 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) sprintf)(char *__s ,
                                                                                             char const   *__fmt 
                                                                                             , ...) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) sprintf)(char *__s , char const   *__fmt 
                                                               , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 33
  __cil_tmp3 = __builtin_object_size((void *)__s, 1);
#line 33
  __cil_tmp4 = (int )__builtin_va_arg_pack();
#line 33
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 33
  return (__cil_tmp5);
}
}
#line 43
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s ,
                                                                                              char const   *__fmt ,
                                                                                              __gnuc_va_list __ap ) ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 46
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 46
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 46
  return (__cil_tmp5);
}
}
#line 61
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) snprintf)(char *__s ,
                                                                                              size_t __n ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 61 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) snprintf)(char *__s , size_t __n ,
                                                                char const   *__fmt 
                                                                , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 64
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 64
  __cil_tmp5 = (int )__builtin_va_arg_pack();
#line 64
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 64
  return (__cil_tmp6);
}
}
#line 74
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s ,
                                                                                               size_t __n ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 74 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s , size_t __n ,
                                                                 char const   *__fmt ,
                                                                 __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 77
  __cil_tmp5 = __builtin_object_size((void *)__s, 1);
#line 77
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 77
  return (__cil_tmp6);
}
}
#line 85
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 87
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 88
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) fprintf)(FILE *__stream , char const   *__fmt 
                                                               , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 97
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 97
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 97
  return (__cil_tmp4);
}
}
#line 102 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) printf)(char const   *__fmt 
                                                              , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 104
  __cil_tmp2 = (int )__builtin_va_arg_pack();
#line 104
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 104
  return (__cil_tmp3);
}
}
#line 114 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   *__fmt ,
                                                               __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 117
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 117
  return (__cil_tmp3);
}
}
#line 124 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vfprintf)(FILE *__stream , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 127
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 127
  return (__cil_tmp4);
}
}
#line 131
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 133
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) dprintf)(int __fd , char const   *__fmt 
                                                               , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 141
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 141
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 141
  return (__cil_tmp4);
}
}
#line 150 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vdprintf)(int __fd , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 152
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 152
  return (__cil_tmp4);
}
}
#line 241
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 243
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 246
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 253 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__gnu_inline__)) fgets)(char *__s , int __n ,
                                                               FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 255
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
  }
#line 255
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 257
    __cil_tmp5 = 0;
#line 257
    if (! __cil_tmp5) {
      {
#line 258
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 258
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 258
      return (__cil_tmp7);
    } else
#line 257
    if (__n <= 0) {
      {
#line 258
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 258
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 258
      return (__cil_tmp7);
    }
    {
#line 260
    __cil_tmp8 = __builtin_object_size((void *)__s, 1);
    }
#line 260
    if ((size_t )__n > __cil_tmp8) {
      {
#line 261
      __cil_tmp9 = __builtin_object_size((void *)__s, 1);
#line 261
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 261
      return (__cil_tmp10);
    }
  }
  {
#line 263
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 263
  return (__cil_tmp11);
}
}
#line 266
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 269
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 273
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 282 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long ( __attribute__((__gnu_inline__)) fread)(void *__ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 285
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 285
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 287
    __cil_tmp7 = 0;
#line 287
    __cil_tmp6 = 0;
#line 287
    if (! __cil_tmp6) {
      {
#line 290
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 290
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 290
      return (__cil_tmp9);
    } else
#line 287
    if (! __cil_tmp7) {
      {
#line 290
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 290
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 290
      return (__cil_tmp9);
    } else
#line 287
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
#line 290
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 290
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 290
      return (__cil_tmp9);
    }
    {
#line 292
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 292
    if (__size * __n > __cil_tmp10) {
      {
#line 293
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 293
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 293
      return (__cil_tmp12);
    }
  }
  {
#line 295
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 295
  return (__cil_tmp13);
}
}
#line 327
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 330
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 334
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 343 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) fread_unlocked)(void *__ptr ,
                                                                         size_t __size ,
                                                                         size_t __n ,
                                                                         FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  long __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp ;
  char *__cil_tmp22 ;
  size_t __cil_tmp23 ;

  {
  {
#line 346
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 346
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 348
    __cil_tmp7 = 0;
#line 348
    __cil_tmp6 = 0;
#line 348
    if (! __cil_tmp6) {
      {
#line 351
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 351
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 351
      return (__cil_tmp9);
    } else
#line 348
    if (! __cil_tmp7) {
      {
#line 351
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 351
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 351
      return (__cil_tmp9);
    } else
#line 348
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
#line 351
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 351
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 351
      return (__cil_tmp9);
    }
    {
#line 354
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 354
    if (__size * __n > __cil_tmp10) {
      {
#line 355
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 355
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 355
      return (__cil_tmp12);
    }
  }
#line 360
  __cil_tmp14 = 0;
#line 360
  __cil_tmp13 = 0;
#line 360
  if (__cil_tmp13) {
#line 360
    if (__cil_tmp14) {
#line 360
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 360
        if (__size * __n <= 8UL) {
#line 365
          __cnt = __size * __n;
#line 366
          __cptr = (char *)__ptr;
#line 367
          if (__cnt == 0UL) {
#line 368
            return ((size_t )0);
          }
          {
#line 370
          while (1) {
            while_continue: /* CIL Label */ ;

#line 370
            if (! (__cnt > 0UL)) {
#line 370
              goto while_break;
            }
            {
#line 372
            __cil_tmp18 = __builtin_expect((long )((unsigned long )__stream->_IO_read_ptr >= (unsigned long )__stream->_IO_read_end),
                                           0L);
            }
#line 372
            if (__cil_tmp18) {
              {
#line 372
              __cil_tmp19 = __uflow(__stream);
#line 372
              tmp = __cil_tmp19;
              }
            } else {
#line 372
              (__stream->_IO_read_ptr) ++;
#line 372
              tmp = (int )*((unsigned char *)__stream->_IO_read_ptr);
            }
#line 372
            __c = tmp;
#line 373
            if (__c == -1) {
#line 374
              goto while_break;
            }
#line 375
            __cil_tmp22 = __cptr;
#line 375
            __cptr ++;
#line 375
            *__cil_tmp22 = (char )__c;
#line 370
            __cnt --;
          }
          while_break___0: /* CIL Label */ ;
          }
          while_break: ;
#line 377
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 380
  __cil_tmp23 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 380
  return (__cil_tmp23);
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 199
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 321 "/root/libzip/lib/zip.h"
int zip_archive_set_tempdir(zip_t *za___0 , char const   *tempdir ) ;
#line 322
int zip_close(zip_t *za___0 ) ;
#line 323
int zip_delete(zip_t *za___0 , zip_uint64_t idx ) ;
#line 324
zip_int64_t zip_dir_add(zip_t *za___0 , char const   *name , zip_flags_t flags ) ;
#line 325
void zip_discard(zip_t *za___0 ) ;
#line 327
zip_error_t *zip_get_error(zip_t *za___0 ) ;
#line 328
void zip_error_clear(zip_t *za___0 ) ;
#line 329
int zip_error_code_zip(zip_error_t *error ) ;
#line 330
int zip_error_code_system(zip_error_t *error ) ;
#line 331
void zip_error_fini(zip_error_t *err ) ;
#line 332
void zip_error_init(zip_error_t *err ) ;
#line 333
void zip_error_init_with_code(zip_error_t *error , int ze ) ;
#line 334
void zip_error_set(zip_error_t *err , int ze , int se ) ;
#line 335
char const   *zip_error_strerror(zip_error_t *err ) ;
#line 336
int zip_error_system_type(zip_error_t *error ) ;
#line 337
zip_int64_t zip_error_to_data(zip_error_t *error , void *data , zip_uint64_t length ) ;
#line 339
int zip_fclose(zip_file_t *zf ) ;
#line 340
zip_t *zip_fdopen(int fd_orig , int _flags , int *zep ) ;
#line 341
zip_int64_t zip_file_add(zip_t *za___0 , char const   *name , zip_source_t *source ,
                         zip_flags_t flags ) ;
#line 342
void zip_file_error_clear(zip_file_t *zf ) ;
#line 343
int zip_file_extra_field_delete(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_idx ,
                                zip_flags_t flags ) ;
#line 344
int zip_file_extra_field_delete_by_id(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                                      zip_uint16_t ef_idx , zip_flags_t flags ) ;
#line 345
int zip_file_extra_field_set(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                             zip_uint16_t ef_idx , zip_uint8_t *data , zip_uint16_t len ,
                             zip_flags_t flags ) ;
#line 346
zip_int16_t zip_file_extra_fields_count(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ) ;
#line 347
zip_int16_t zip_file_extra_fields_count_by_id(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                                              zip_flags_t flags ) ;
#line 348
zip_uint8_t *zip_file_extra_field_get(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_idx ,
                                      zip_uint16_t *idp , zip_uint16_t *lenp , zip_flags_t flags ) ;
#line 349
zip_uint8_t *zip_file_extra_field_get_by_id(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                                            zip_uint16_t ef_idx , zip_uint16_t *lenp ,
                                            zip_flags_t flags ) ;
#line 350
char const   *zip_file_get_comment(zip_t *za___0 , zip_uint64_t idx , zip_uint32_t *lenp ,
                                   zip_flags_t flags ) ;
#line 351
zip_error_t *zip_file_get_error(zip_file_t *f ) ;
#line 352
int zip_file_get_external_attributes(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                                     zip_uint8_t *opsys , zip_uint32_t *attributes ) ;
#line 353
int zip_file_rename(zip_t *za___0 , zip_uint64_t idx , char const   *name , zip_flags_t flags ) ;
#line 354
int zip_file_replace(zip_t *za___0 , zip_uint64_t idx , zip_source_t *source , zip_flags_t flags ) ;
#line 355
int zip_file_set_comment(zip_t *za___0 , zip_uint64_t idx , char const   *comment ,
                         zip_uint16_t len , zip_flags_t flags ) ;
#line 356
int zip_file_set_external_attributes(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                                     zip_uint8_t opsys , zip_uint32_t attributes ) ;
#line 357
int zip_file_set_mtime(zip_t *za___0 , zip_uint64_t idx , time_t mtime , zip_flags_t flags ) ;
#line 358
char const   *zip_file_strerror(zip_file_t *zf ) ;
#line 359
zip_file_t *zip_fopen(zip_t *za___0 , char const   *fname , zip_flags_t flags ) ;
#line 360
zip_file_t *zip_fopen_encrypted(zip_t *za___0 , char const   *fname , zip_flags_t flags ,
                                char const   *password ) ;
#line 361
zip_file_t *zip_fopen_index(zip_t *za___0 , zip_uint64_t index___0 , zip_flags_t flags ) ;
#line 362
zip_file_t *zip_fopen_index_encrypted(zip_t *za___0 , zip_uint64_t index___0 , zip_flags_t flags ,
                                      char const   *password ) ;
#line 363
zip_int64_t zip_fread(zip_file_t *zf , void *outbuf , zip_uint64_t toread ) ;
#line 364
char const   *zip_get_archive_comment(zip_t *za___0 , int *lenp , zip_flags_t flags ) ;
#line 365
int zip_get_archive_flag(zip_t *za___0 , zip_flags_t flag , zip_flags_t flags ) ;
#line 366
char const   *zip_get_name(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ) ;
#line 367
zip_int64_t zip_get_num_entries(zip_t *za___0 , zip_flags_t flags ) ;
#line 368
zip_int64_t zip_name_locate(zip_t *za___0 , char const   *fname , zip_flags_t flags ) ;
#line 369
zip_t *zip_open(char const   *fn , int _flags , int *zep ) ;
#line 370
zip_t *zip_open_from_source(zip_source_t *src , int _flags , zip_error_t *error ) ;
#line 371
int zip_set_archive_comment(zip_t *za___0 , char const   *comment , zip_uint16_t len ) ;
#line 372
int zip_set_archive_flag(zip_t *za___0 , zip_flags_t flag , int value ) ;
#line 373
int zip_set_default_password(zip_t *za___0 , char const   *passwd ) ;
#line 374
int zip_set_file_compression(zip_t *za___0 , zip_uint64_t idx , zip_int32_t method ,
                             zip_uint32_t flags ) ;
#line 375
int zip_source_begin_write(zip_source_t *src ) ;
#line 376
zip_source_t *zip_source_buffer(zip_t *za___0 , void const   *data , zip_uint64_t len ,
                                int freep ) ;
#line 377
zip_source_t *zip_source_buffer_create(void const   *data , zip_uint64_t len , int freep ,
                                       zip_error_t *error ) ;
#line 378
int zip_source_close(zip_source_t *src ) ;
#line 379
int zip_source_commit_write(zip_source_t *src ) ;
#line 380
zip_error_t *zip_source_error(zip_source_t *src ) ;
#line 381
zip_source_t *zip_source_file(zip_t *za___0 , char const   *fname , zip_uint64_t start ,
                              zip_int64_t len ) ;
#line 382
zip_source_t *zip_source_file_create(char const   *fname , zip_uint64_t start , zip_int64_t length ,
                                     zip_error_t *error ) ;
#line 383
zip_source_t *zip_source_filep(zip_t *za___0 , FILE *file , zip_uint64_t start , zip_int64_t len ) ;
#line 384
zip_source_t *zip_source_filep_create(FILE *file , zip_uint64_t start , zip_int64_t length ,
                                      zip_error_t *error ) ;
#line 385
void zip_source_free(zip_source_t *src ) ;
#line 386
zip_source_t *zip_source_function(zip_t *za___0 , zip_int64_t (*zcb)(void * , void * ,
                                                                     zip_uint64_t  ,
                                                                     zip_source_cmd_t  ) ,
                                  void *ud ) ;
#line 387
zip_source_t *zip_source_function_create(zip_int64_t (*zcb)(void * , void * , zip_uint64_t  ,
                                                            zip_source_cmd_t  ) ,
                                         void *ud , zip_error_t *error ) ;
#line 388
int zip_source_is_deleted(zip_source_t *src ) ;
#line 389
void zip_source_keep(zip_source_t *src ) ;
#line 390
zip_int64_t zip_source_make_command_bitmap(zip_source_cmd_t cmd0  , ...) ;
#line 391
int zip_source_open(zip_source_t *src ) ;
#line 392
zip_int64_t zip_source_read(zip_source_t *src , void *data , zip_uint64_t len ) ;
#line 393
void zip_source_rollback_write(zip_source_t *src ) ;
#line 394
int zip_source_seek(zip_source_t *src , zip_int64_t offset , int whence ) ;
#line 395
zip_int64_t zip_source_seek_compute_offset(zip_uint64_t offset , zip_uint64_t length ,
                                           void *data , zip_uint64_t data_length ,
                                           zip_error_t *error ) ;
#line 396
int zip_source_seek_write(zip_source_t *src , zip_int64_t offset , int whence ) ;
#line 397
int zip_source_stat(zip_source_t *src , zip_stat_t *st ) ;
#line 398
zip_int64_t zip_source_tell(zip_source_t *src ) ;
#line 399
zip_int64_t zip_source_tell_write(zip_source_t *src ) ;
#line 408
zip_int64_t zip_source_write(zip_source_t *src , void const   *data , zip_uint64_t length ) ;
#line 409
zip_source_t *zip_source_zip(zip_t *za___0 , zip_t *srcza , zip_uint64_t srcidx ,
                             zip_flags_t flags , zip_uint64_t start , zip_int64_t len ) ;
#line 410
int zip_stat(zip_t *za___0 , char const   *fname , zip_flags_t flags , zip_stat_t *st ) ;
#line 411
int zip_stat_index(zip_t *za___0 , zip_uint64_t index___0 , zip_flags_t flags , zip_stat_t *st ) ;
#line 412
void zip_stat_init(zip_stat_t *st ) ;
#line 413
char const   *zip_strerror(zip_t *za___0 ) ;
#line 414
int zip_unchange(zip_t *za___0 , zip_uint64_t idx ) ;
#line 415
int zip_unchange_all(zip_t *za___0 ) ;
#line 416
int zip_unchange_archive(zip_t *za___0 ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 217 "/root/libzip/lib/zipint.h"
zip_compression_implementation _zip_get_compression_implementation(zip_int32_t cm ) ;
#line 218
zip_encryption_implementation _zip_get_encryption_implementation(zip_uint16_t em ) ;
#line 231
zip_source_t *zip_source_crc(zip_t *za___0 , zip_source_t *src , int validate ) ;
#line 232
zip_source_t *zip_source_deflate(zip_t *za___0 , zip_source_t *src , zip_int32_t cm ,
                                 int flags ) ;
#line 233
zip_source_t *zip_source_layered(zip_t *za___0 , zip_source_t *src , zip_int64_t (*cb)(zip_source_t * ,
                                                                                       void * ,
                                                                                       void * ,
                                                                                       zip_uint64_t  ,
                                                                                       enum zip_source_cmd  ) ,
                                 void *ud ) ;
#line 234
zip_source_t *zip_source_layered_create(zip_source_t *src , zip_int64_t (*cb)(zip_source_t * ,
                                                                              void * ,
                                                                              void * ,
                                                                              zip_uint64_t  ,
                                                                              enum zip_source_cmd  ) ,
                                        void *ud , zip_error_t *error ) ;
#line 235
zip_source_t *zip_source_pkware(zip_t *za___0 , zip_source_t *src , zip_uint16_t em ,
                                int flags , char const   *password ) ;
#line 236
int zip_source_remove(zip_source_t *src ) ;
#line 237
zip_int64_t zip_source_supports(zip_source_t *src ) ;
#line 238
zip_source_t *zip_source_window(zip_t *za___0 , zip_source_t *src , zip_uint64_t start ,
                                zip_uint64_t len ) ;
#line 449
char const   * const  _zip_err_str[31] ;
#line 450
int const   _zip_nerr_str ;
#line 451
int const   _zip_err_type[31] ;
#line 461
zip_int64_t _zip_add_entry(zip_t *za___0 ) ;
#line 463
zip_uint8_t *_zip_buffer_data(zip_buffer_t *buffer ) ;
#line 464
int _zip_buffer_eof(zip_buffer_t *buffer ) ;
#line 465
void _zip_buffer_free(zip_buffer_t *buffer ) ;
#line 466
zip_uint8_t *_zip_buffer_get(zip_buffer_t *buffer , zip_uint64_t length ) ;
#line 467
zip_uint16_t _zip_buffer_get_16(zip_buffer_t *buffer ) ;
#line 468
zip_uint32_t _zip_buffer_get_32(zip_buffer_t *buffer ) ;
#line 469
zip_uint64_t _zip_buffer_get_64(zip_buffer_t *buffer ) ;
#line 470
zip_uint8_t _zip_buffer_get_8(zip_buffer_t *buffer ) ;
#line 471
zip_uint64_t _zip_buffer_left(zip_buffer_t *buffer ) ;
#line 472
zip_buffer_t *_zip_buffer_new(zip_uint8_t *data , zip_uint64_t size ) ;
#line 473
zip_buffer_t *_zip_buffer_new_from_source(zip_source_t *src , zip_uint64_t size ,
                                          zip_uint8_t *buf , zip_error_t *error ) ;
#line 474
zip_uint64_t _zip_buffer_offset(zip_buffer_t *buffer ) ;
#line 475
int _zip_buffer_ok(zip_buffer_t *buffer ) ;
#line 476
int _zip_buffer_put(zip_buffer_t *buffer , void const   *src , size_t length ) ;
#line 477
int _zip_buffer_put_16(zip_buffer_t *buffer , zip_uint16_t i ) ;
#line 478
int _zip_buffer_put_32(zip_buffer_t *buffer , zip_uint32_t i ) ;
#line 479
int _zip_buffer_put_64(zip_buffer_t *buffer , zip_uint64_t i ) ;
#line 480
int _zip_buffer_put_8(zip_buffer_t *buffer , zip_uint8_t i ) ;
#line 481
int _zip_buffer_skip(zip_buffer_t *buffer , zip_uint64_t length ) ;
#line 482
int _zip_buffer_set_offset(zip_buffer_t *buffer , zip_uint64_t offset ) ;
#line 483
zip_uint64_t _zip_buffer_size(zip_buffer_t *buffer ) ;
#line 486
void _zip_cdir_free(zip_cdir_t *cd ) ;
#line 487
zip_cdir_t *_zip_cdir_new(zip_uint64_t nentry , zip_error_t *error ) ;
#line 488
zip_int64_t _zip_cdir_write(zip_t *za___0 , zip_filelist_t *filelist , zip_uint64_t survivors ) ;
#line 489
void _zip_deregister_source(zip_t *za___0 , zip_source_t *src ) ;
#line 491
zip_dirent_t *_zip_dirent_clone(zip_dirent_t *sde ) ;
#line 492
void _zip_dirent_free(zip_dirent_t *zde ) ;
#line 493
void _zip_dirent_finalize(zip_dirent_t *zde ) ;
#line 494
void _zip_dirent_init(zip_dirent_t *de ) ;
#line 495
int _zip_dirent_needs_zip64(zip_dirent_t *de , zip_flags_t flags ) ;
#line 496
zip_dirent_t *_zip_dirent_new(void) ;
#line 497
zip_int64_t _zip_dirent_read(zip_dirent_t *zde , zip_source_t *src , zip_buffer_t *buffer ,
                             int local , zip_error_t *error ) ;
#line 498
zip_int32_t _zip_dirent_size(zip_source_t *src , zip_uint16_t flags , zip_error_t *error ) ;
#line 499
int _zip_dirent_write(zip_t *za___0 , zip_dirent_t *de , zip_flags_t flags ) ;
#line 501
zip_extra_field_t *_zip_ef_clone(zip_extra_field_t *ef , zip_error_t *error ) ;
#line 502
zip_extra_field_t *_zip_ef_delete_by_id(zip_extra_field_t *ef , zip_uint16_t id ,
                                        zip_uint16_t id_idx , zip_flags_t flags ) ;
#line 503
void _zip_ef_free(zip_extra_field_t *ef ) ;
#line 504
zip_uint8_t *_zip_ef_get_by_id(zip_extra_field_t *ef , zip_uint16_t *lenp , zip_uint16_t id ,
                               zip_uint16_t id_idx , zip_flags_t flags , zip_error_t *error ) ;
#line 505
zip_extra_field_t *_zip_ef_merge(zip_extra_field_t *to , zip_extra_field_t *from ) ;
#line 506
zip_extra_field_t *_zip_ef_new(zip_uint16_t id , zip_uint16_t size , zip_uint8_t *data ,
                               zip_flags_t flags ) ;
#line 507
int _zip_ef_parse(zip_uint8_t *data , zip_uint16_t len , zip_flags_t flags , zip_extra_field_t **ef_head_p ,
                  zip_error_t *error ) ;
#line 508
zip_extra_field_t *_zip_ef_remove_internal(zip_extra_field_t *ef ) ;
#line 509
zip_uint16_t _zip_ef_size(zip_extra_field_t *ef , zip_flags_t flags ) ;
#line 510
int _zip_ef_write(zip_t *za___0 , zip_extra_field_t *ef , zip_flags_t flags ) ;
#line 512
void _zip_entry_finalize(zip_entry_t *e ) ;
#line 513
void _zip_entry_init(zip_entry_t *e ) ;
#line 515
void _zip_error_clear(zip_error_t *err ) ;
#line 516
void _zip_error_get(zip_error_t *err , int *zep , int *sep ) ;
#line 518
void _zip_error_copy(zip_error_t *dst , zip_error_t *src ) ;
#line 519
void _zip_error_set_from_source(zip_error_t *err , zip_source_t *src ) ;
#line 523
int _zip_file_extra_field_prepare_for_change(zip_t *za___0 , zip_uint64_t idx ) ;
#line 525
zip_uint64_t _zip_file_get_offset(zip_t *za___0 , zip_uint64_t idx , zip_error_t *error ) ;
#line 527
int _zip_filerange_crc(zip_source_t *src , zip_uint64_t start , zip_uint64_t len ,
                       uLong *crcp , zip_error_t *error ) ;
#line 529
zip_dirent_t *_zip_get_dirent(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                              zip_error_t *error ) ;
#line 531
enum zip_encoding_type _zip_guess_encoding(zip_string_t *str , zip_encoding_type_t expected_encoding ) ;
#line 532
zip_uint8_t *_zip_cp437_to_utf8(zip_uint8_t *_cp437buf , zip_uint32_t len , zip_uint32_t *utf8_lenp ,
                                zip_error_t *error ) ;
#line 534
int _zip_hash_add(zip_hash_t *hash , zip_uint8_t *name , zip_uint64_t index___0 ,
                  zip_flags_t flags , zip_error_t *error ) ;
#line 535
int _zip_hash_delete(zip_hash_t *hash , zip_uint8_t *name , zip_error_t *error ) ;
#line 536
void _zip_hash_free(zip_hash_t *hash ) ;
#line 537
zip_int64_t _zip_hash_lookup(zip_hash_t *hash , zip_uint8_t *name , zip_flags_t flags ,
                             zip_error_t *error ) ;
#line 538
zip_hash_t *_zip_hash_new(zip_uint16_t table_size , zip_error_t *error ) ;
#line 539
void _zip_hash_revert(zip_hash_t *hash ) ;
#line 541
zip_t *_zip_open(zip_source_t *src , unsigned int flags , zip_error_t *error ) ;
#line 543
int _zip_read(zip_source_t *src , zip_uint8_t *b , zip_uint64_t length , zip_error_t *error ) ;
#line 545
zip_uint8_t *_zip_read_data(zip_buffer_t *buffer , zip_source_t *src , size_t length ,
                            int nulp , zip_error_t *error ) ;
#line 546
int _zip_read_local_ef(zip_t *za___0 , zip_uint64_t idx ) ;
#line 547
zip_string_t *_zip_read_string(zip_buffer_t *buffer , zip_source_t *src , zip_uint16_t len ,
                               int nulp , zip_error_t *error ) ;
#line 548
int _zip_register_source(zip_t *za___0 , zip_source_t *src ) ;
#line 550
void _zip_set_open_error(int *zep , zip_error_t *err , int ze ) ;
#line 552
zip_int64_t _zip_source_call(zip_source_t *src , void *data , zip_uint64_t length ,
                             zip_source_cmd_t command ) ;
#line 553
zip_source_t *_zip_source_file_or_p(char const   *fname , FILE *file , zip_uint64_t start ,
                                    zip_int64_t len , zip_stat_t *st , zip_error_t *error ) ;
#line 554
void _zip_source_invalidate(zip_source_t *src ) ;
#line 555
zip_source_t *_zip_source_new(zip_error_t *error ) ;
#line 556
int _zip_source_set_source_archive(zip_source_t *src , zip_t *za___0 ) ;
#line 557
zip_source_t *_zip_source_window_new(zip_source_t *src , zip_uint64_t start , zip_uint64_t length ,
                                     zip_stat_t *st , zip_error_t *error ) ;
#line 558
zip_source_t *_zip_source_zip_new(zip_t *za___0 , zip_t *srcza , zip_uint64_t srcidx ,
                                  zip_flags_t flags , zip_uint64_t start , zip_uint64_t len ,
                                  char const   *password ) ;
#line 560
int _zip_stat_merge(zip_stat_t *dst , zip_stat_t *src , zip_error_t *error ) ;
#line 561
int _zip_string_equal(zip_string_t *a , zip_string_t *b ) ;
#line 562
void _zip_string_free(zip_string_t *s ) ;
#line 563
zip_uint32_t _zip_string_crc32(zip_string_t *s ) ;
#line 564
zip_uint8_t *_zip_string_get(zip_string_t *string , zip_uint32_t *lenp , zip_flags_t flags ,
                             zip_error_t *error ) ;
#line 565
zip_uint16_t _zip_string_length(zip_string_t *s ) ;
#line 566
zip_string_t *_zip_string_new(zip_uint8_t *raw , zip_uint16_t length , zip_flags_t flags ,
                              zip_error_t *error ) ;
#line 567
int _zip_string_write(zip_t *za___0 , zip_string_t *s ) ;
#line 569
int _zip_changed(zip_t *za___0 , zip_uint64_t *survivorsp ) ;
#line 570
char const   *_zip_get_name(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                            zip_error_t *error ) ;
#line 572
void *_zip_memdup(void const   *mem , size_t len , zip_error_t *error ) ;
#line 573
zip_int64_t _zip_name_locate(zip_t *za___0 , char const   *fname , zip_flags_t flags ,
                             zip_error_t *error ) ;
#line 574
zip_t *_zip_new(zip_error_t *error ) ;
#line 576
zip_int64_t _zip_file_replace(zip_t *za___0 , zip_uint64_t idx , char const   *name ,
                              zip_source_t *source , zip_flags_t flags ) ;
#line 577
int _zip_set_name(zip_t *za___0 , zip_uint64_t idx , char const   *name , zip_flags_t flags ) ;
#line 578
void _zip_u2d_time(time_t intime , zip_uint16_t *dtime , zip_uint16_t *ddate ) ;
#line 579
int _zip_unchange(zip_t *za___0 , zip_uint64_t idx , int allow_duplicates ) ;
#line 580
void _zip_unchange_data(zip_entry_t *ze ) ;
#line 581
int _zip_write(zip_t *za___0 , void const   *data , zip_uint64_t length ) ;
#line 144 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) ;
#line 147
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) ;
#line 150
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) ;
#line 157
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) ;
#line 164
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 183
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 209
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 214
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 278
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) ;
#line 278 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 280
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 280
  return ((int )__cil_tmp2);
}
}
#line 283
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) ;
#line 283 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 285
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 285
  return (__cil_tmp2);
}
}
#line 292
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) ;
#line 292 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 294
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 294
  return (__cil_tmp2);
}
}
#line 466
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 468
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 480
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 619
extern int mkstemp(char *__template ) ;
#line 733
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 754
__inline extern void *( __attribute__((__gnu_inline__)) bsearch)(void const   *__key ,
                                                                 void const   *__base ,
                                                                 size_t __nmemb ,
                                                                 size_t __size , int (*__compar)(void const   * ,
                                                                                                 void const   * ) ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *( __attribute__((__gnu_inline__)) bsearch)(void const   *__key ,
                                                                 void const   *__base ,
                                                                 size_t __nmemb ,
                                                                 size_t __size , int (*__compar)(void const   * ,
                                                                                                 void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;

#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 42
  return ((void *)0);
}
}
#line 869 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctomb)(char *__s ,
                                                                                            wchar_t __wchar ) ;
#line 873
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                                 char const   *__src ,
                                                                                                 size_t __len ) ;
#line 876
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst ,
                                                                                                 wchar_t *__src ,
                                                                                                 size_t __len ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 28
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 28
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd , char *__buf ,
                                                                 size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 68
    __cil_tmp5 = 0;
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctomb)(char *__s ,
                                                                                            wchar_t __wchar ) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) wctomb)(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 92
  __cil_tmp3 = __builtin_object_size((void *)__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size((void *)__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                                 char const   *__src ,
                                                                                                 size_t __len ) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                   char const   *__src ,
                                                                   size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size((void *)__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    __cil_tmp5 = 0;
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size((void *)__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size((void *)__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size((void *)__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst ,
                                                                                                 wchar_t *__src ,
                                                                                                 size_t __len ) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst , wchar_t *__src ,
                                                                   size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size((void *)__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 149
    __cil_tmp5 = 0;
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size((void *)__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size((void *)__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size((void *)__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 40 "/root/libzip/lib/zip_utf-8.c"
static zip_uint16_t _cp437_to_unicode[256]  = 
#line 40 "/root/libzip/lib/zip_utf-8.c"
  {      (zip_uint16_t )8199,      (zip_uint16_t )9786,      (zip_uint16_t )9787,      (zip_uint16_t )9829, 
        (zip_uint16_t )9830,      (zip_uint16_t )9827,      (zip_uint16_t )9824,      (zip_uint16_t )8226, 
        (zip_uint16_t )9688,      (zip_uint16_t )9675,      (zip_uint16_t )9689,      (zip_uint16_t )9794, 
        (zip_uint16_t )9792,      (zip_uint16_t )9834,      (zip_uint16_t )9835,      (zip_uint16_t )9788, 
        (zip_uint16_t )9658,      (zip_uint16_t )9668,      (zip_uint16_t )8597,      (zip_uint16_t )8252, 
        (zip_uint16_t )182,      (zip_uint16_t )167,      (zip_uint16_t )9644,      (zip_uint16_t )8616, 
        (zip_uint16_t )8593,      (zip_uint16_t )8595,      (zip_uint16_t )8594,      (zip_uint16_t )8592, 
        (zip_uint16_t )8735,      (zip_uint16_t )8596,      (zip_uint16_t )9650,      (zip_uint16_t )9660, 
        (zip_uint16_t )32,      (zip_uint16_t )33,      (zip_uint16_t )34,      (zip_uint16_t )35, 
        (zip_uint16_t )36,      (zip_uint16_t )37,      (zip_uint16_t )38,      (zip_uint16_t )39, 
        (zip_uint16_t )40,      (zip_uint16_t )41,      (zip_uint16_t )42,      (zip_uint16_t )43, 
        (zip_uint16_t )44,      (zip_uint16_t )45,      (zip_uint16_t )46,      (zip_uint16_t )47, 
        (zip_uint16_t )48,      (zip_uint16_t )49,      (zip_uint16_t )50,      (zip_uint16_t )51, 
        (zip_uint16_t )52,      (zip_uint16_t )53,      (zip_uint16_t )54,      (zip_uint16_t )55, 
        (zip_uint16_t )56,      (zip_uint16_t )57,      (zip_uint16_t )58,      (zip_uint16_t )59, 
        (zip_uint16_t )60,      (zip_uint16_t )61,      (zip_uint16_t )62,      (zip_uint16_t )63, 
        (zip_uint16_t )64,      (zip_uint16_t )65,      (zip_uint16_t )66,      (zip_uint16_t )67, 
        (zip_uint16_t )68,      (zip_uint16_t )69,      (zip_uint16_t )70,      (zip_uint16_t )71, 
        (zip_uint16_t )72,      (zip_uint16_t )73,      (zip_uint16_t )74,      (zip_uint16_t )75, 
        (zip_uint16_t )76,      (zip_uint16_t )77,      (zip_uint16_t )78,      (zip_uint16_t )79, 
        (zip_uint16_t )80,      (zip_uint16_t )81,      (zip_uint16_t )82,      (zip_uint16_t )83, 
        (zip_uint16_t )84,      (zip_uint16_t )85,      (zip_uint16_t )86,      (zip_uint16_t )87, 
        (zip_uint16_t )88,      (zip_uint16_t )89,      (zip_uint16_t )90,      (zip_uint16_t )91, 
        (zip_uint16_t )92,      (zip_uint16_t )93,      (zip_uint16_t )94,      (zip_uint16_t )95, 
        (zip_uint16_t )96,      (zip_uint16_t )97,      (zip_uint16_t )98,      (zip_uint16_t )99, 
        (zip_uint16_t )100,      (zip_uint16_t )101,      (zip_uint16_t )102,      (zip_uint16_t )103, 
        (zip_uint16_t )104,      (zip_uint16_t )105,      (zip_uint16_t )106,      (zip_uint16_t )107, 
        (zip_uint16_t )108,      (zip_uint16_t )109,      (zip_uint16_t )110,      (zip_uint16_t )111, 
        (zip_uint16_t )112,      (zip_uint16_t )113,      (zip_uint16_t )114,      (zip_uint16_t )115, 
        (zip_uint16_t )116,      (zip_uint16_t )117,      (zip_uint16_t )118,      (zip_uint16_t )119, 
        (zip_uint16_t )120,      (zip_uint16_t )121,      (zip_uint16_t )122,      (zip_uint16_t )123, 
        (zip_uint16_t )124,      (zip_uint16_t )125,      (zip_uint16_t )126,      (zip_uint16_t )8962, 
        (zip_uint16_t )199,      (zip_uint16_t )252,      (zip_uint16_t )233,      (zip_uint16_t )226, 
        (zip_uint16_t )228,      (zip_uint16_t )224,      (zip_uint16_t )229,      (zip_uint16_t )231, 
        (zip_uint16_t )234,      (zip_uint16_t )235,      (zip_uint16_t )232,      (zip_uint16_t )239, 
        (zip_uint16_t )238,      (zip_uint16_t )236,      (zip_uint16_t )196,      (zip_uint16_t )197, 
        (zip_uint16_t )201,      (zip_uint16_t )230,      (zip_uint16_t )198,      (zip_uint16_t )244, 
        (zip_uint16_t )246,      (zip_uint16_t )242,      (zip_uint16_t )251,      (zip_uint16_t )249, 
        (zip_uint16_t )255,      (zip_uint16_t )214,      (zip_uint16_t )220,      (zip_uint16_t )162, 
        (zip_uint16_t )163,      (zip_uint16_t )165,      (zip_uint16_t )8359,      (zip_uint16_t )402, 
        (zip_uint16_t )225,      (zip_uint16_t )237,      (zip_uint16_t )243,      (zip_uint16_t )250, 
        (zip_uint16_t )241,      (zip_uint16_t )209,      (zip_uint16_t )170,      (zip_uint16_t )186, 
        (zip_uint16_t )191,      (zip_uint16_t )8976,      (zip_uint16_t )172,      (zip_uint16_t )189, 
        (zip_uint16_t )188,      (zip_uint16_t )161,      (zip_uint16_t )171,      (zip_uint16_t )187, 
        (zip_uint16_t )9617,      (zip_uint16_t )9618,      (zip_uint16_t )9619,      (zip_uint16_t )9474, 
        (zip_uint16_t )9508,      (zip_uint16_t )9569,      (zip_uint16_t )9570,      (zip_uint16_t )9558, 
        (zip_uint16_t )9557,      (zip_uint16_t )9571,      (zip_uint16_t )9553,      (zip_uint16_t )9559, 
        (zip_uint16_t )9565,      (zip_uint16_t )9564,      (zip_uint16_t )9563,      (zip_uint16_t )9488, 
        (zip_uint16_t )9492,      (zip_uint16_t )9524,      (zip_uint16_t )9516,      (zip_uint16_t )9500, 
        (zip_uint16_t )9472,      (zip_uint16_t )9532,      (zip_uint16_t )9566,      (zip_uint16_t )9567, 
        (zip_uint16_t )9562,      (zip_uint16_t )9556,      (zip_uint16_t )9577,      (zip_uint16_t )9574, 
        (zip_uint16_t )9568,      (zip_uint16_t )9552,      (zip_uint16_t )9580,      (zip_uint16_t )9575, 
        (zip_uint16_t )9576,      (zip_uint16_t )9572,      (zip_uint16_t )9573,      (zip_uint16_t )9561, 
        (zip_uint16_t )9560,      (zip_uint16_t )9554,      (zip_uint16_t )9555,      (zip_uint16_t )9579, 
        (zip_uint16_t )9578,      (zip_uint16_t )9496,      (zip_uint16_t )9484,      (zip_uint16_t )9608, 
        (zip_uint16_t )9604,      (zip_uint16_t )9612,      (zip_uint16_t )9616,      (zip_uint16_t )9600, 
        (zip_uint16_t )945,      (zip_uint16_t )223,      (zip_uint16_t )915,      (zip_uint16_t )960, 
        (zip_uint16_t )931,      (zip_uint16_t )963,      (zip_uint16_t )181,      (zip_uint16_t )964, 
        (zip_uint16_t )934,      (zip_uint16_t )920,      (zip_uint16_t )937,      (zip_uint16_t )948, 
        (zip_uint16_t )8734,      (zip_uint16_t )966,      (zip_uint16_t )949,      (zip_uint16_t )8745, 
        (zip_uint16_t )8801,      (zip_uint16_t )177,      (zip_uint16_t )8805,      (zip_uint16_t )8804, 
        (zip_uint16_t )8992,      (zip_uint16_t )8993,      (zip_uint16_t )247,      (zip_uint16_t )8776, 
        (zip_uint16_t )176,      (zip_uint16_t )8729,      (zip_uint16_t )183,      (zip_uint16_t )8730, 
        (zip_uint16_t )8319,      (zip_uint16_t )178,      (zip_uint16_t )9632,      (zip_uint16_t )160};
#line 117 "/root/libzip/lib/zip_utf-8.c"
enum zip_encoding_type _zip_guess_encoding(zip_string_t *str , zip_encoding_type_t expected_encoding ) 
{ 
  zip_encoding_type_t enc ;
  zip_uint8_t *name ;
  zip_uint32_t i ;
  zip_uint32_t j ;
  zip_uint32_t ulen ;

  {
#line 123
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 124
    return ((enum zip_encoding_type )1);
  }
#line 126
  name = str->raw;
#line 128
  if ((unsigned int )str->encoding != 0U) {
#line 129
    enc = str->encoding;
  } else {
#line 131
    enc = (zip_encoding_type_t )1;
#line 132
    i = (zip_uint32_t )0;
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: ;
#line 132
      if (! (i < (unsigned int )str->length)) {
#line 132
        goto while_break;
      }
#line 133
      if ((int )*(name + i) > 31) {
#line 133
        if ((int )*(name + i) < 128) {
#line 134
          goto while_continue;
        } else {
#line 133
          goto _L;
        }
      } else
      _L: 
#line 133
      if ((int )*(name + i) == 13) {
#line 134
        goto while_continue;
      } else
#line 133
      if ((int )*(name + i) == 10) {
#line 134
        goto while_continue;
      } else
#line 133
      if ((int )*(name + i) == 9) {
#line 134
        goto while_continue;
      }
#line 136
      enc = (zip_encoding_type_t )3;
#line 137
      if (((int )*(name + i) & 224) == 192) {
#line 138
        ulen = (zip_uint32_t )1;
      } else
#line 139
      if (((int )*(name + i) & 240) == 224) {
#line 140
        ulen = (zip_uint32_t )2;
      } else
#line 141
      if (((int )*(name + i) & 248) == 240) {
#line 142
        ulen = (zip_uint32_t )3;
      } else {
#line 144
        enc = (zip_encoding_type_t )4;
#line 145
        goto while_break;
      }
#line 148
      if (i + ulen >= (unsigned int )str->length) {
#line 149
        enc = (zip_encoding_type_t )4;
#line 150
        goto while_break;
      }
#line 153
      j = (zip_uint32_t )1;
      {
#line 153
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 153
        if (! (j <= ulen)) {
#line 153
          goto while_break___0;
        }
#line 154
        if (((int )*(name + (i + j)) & 192) != 128) {
#line 155
          enc = (zip_encoding_type_t )4;
#line 156
          goto done;
        }
#line 153
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 159
      i += ulen;
#line 132
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
  done: 
#line 164
  str->encoding = enc;
#line 166
  if ((unsigned int )expected_encoding != 0U) {
#line 167
    if ((unsigned int )expected_encoding == 2U) {
#line 167
      if ((unsigned int )enc == 3U) {
#line 168
        enc = (zip_encoding_type_t )2;
#line 168
        str->encoding = enc;
      }
    }
#line 170
    if ((unsigned int )expected_encoding != (unsigned int )enc) {
#line 170
      if ((unsigned int )enc != 1U) {
#line 171
        return ((enum zip_encoding_type )5);
      }
    }
  }
#line 174
  return (enc);
}
}
#line 179 "/root/libzip/lib/zip_utf-8.c"
static zip_uint32_t _zip_unicode_to_utf8_len(zip_uint32_t codepoint ) 
{ 


  {
#line 181
  if (codepoint < 128U) {
#line 182
    return ((zip_uint32_t )1);
  }
#line 183
  if (codepoint < 2048U) {
#line 184
    return ((zip_uint32_t )2);
  }
#line 185
  if (codepoint < 65536U) {
#line 186
    return ((zip_uint32_t )3);
  }
#line 187
  return ((zip_uint32_t )4);
}
}
#line 192 "/root/libzip/lib/zip_utf-8.c"
static zip_uint32_t _zip_unicode_to_utf8(zip_uint32_t codepoint , zip_uint8_t *buf ) 
{ 


  {
#line 194
  if (codepoint < 128U) {
#line 195
    *(buf + 0) = (zip_uint8_t )(codepoint & 255U);
#line 196
    return ((zip_uint32_t )1);
  }
#line 198
  if (codepoint < 2048U) {
#line 199
    *(buf + 0) = (zip_uint8_t )(192U | ((codepoint >> 6) & 31U));
#line 200
    *(buf + 1) = (zip_uint8_t )(128U | (codepoint & 63U));
#line 201
    return ((zip_uint32_t )2);
  }
#line 203
  if (codepoint < 65536U) {
#line 204
    *(buf + 0) = (zip_uint8_t )(224U | ((codepoint >> 12) & 15U));
#line 205
    *(buf + 1) = (zip_uint8_t )(128U | ((codepoint >> 6) & 63U));
#line 206
    *(buf + 2) = (zip_uint8_t )(128U | (codepoint & 63U));
#line 207
    return ((zip_uint32_t )3);
  }
#line 209
  *(buf + 0) = (zip_uint8_t )(240U | ((codepoint >> 18) & 7U));
#line 210
  *(buf + 1) = (zip_uint8_t )(128U | ((codepoint >> 12) & 63U));
#line 211
  *(buf + 2) = (zip_uint8_t )(128U | ((codepoint >> 6) & 63U));
#line 212
  *(buf + 3) = (zip_uint8_t )(128U | (codepoint & 63U));
#line 213
  return ((zip_uint32_t )4);
}
}
#line 218 "/root/libzip/lib/zip_utf-8.c"
zip_uint8_t *_zip_cp437_to_utf8(zip_uint8_t *_cp437buf , zip_uint32_t len , zip_uint32_t *utf8_lenp ,
                                zip_error_t *error ) 
{ 
  zip_uint8_t *cp437buf ;
  zip_uint8_t *utf8buf ;
  zip_uint32_t buflen ;
  zip_uint32_t i ;
  zip_uint32_t offset ;
  zip_uint32_t __cil_tmp10 ;
  void *__cil_tmp12 ;
  zip_uint32_t __cil_tmp13 ;

  {
#line 221
  cp437buf = _cp437buf;
#line 225
  if (len == 0U) {
#line 226
    if (utf8_lenp) {
#line 227
      *utf8_lenp = (zip_uint32_t )0;
    }
#line 228
    return ((zip_uint8_t *)((void *)0));
  }
#line 231
  buflen = (zip_uint32_t )1;
#line 232
  i = (zip_uint32_t )0;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;

#line 232
    if (! (i < len)) {
#line 232
      goto while_break;
    }
    {
#line 233
    __cil_tmp10 = _zip_unicode_to_utf8_len((zip_uint32_t )_cp437_to_unicode[*(cp437buf + i)]);
#line 233
    buflen += __cil_tmp10;
#line 232
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 235
  __cil_tmp12 = malloc((unsigned long )buflen);
#line 235
  utf8buf = (zip_uint8_t *)__cil_tmp12;
  }
#line 235
  if ((unsigned long )utf8buf == (unsigned long )((void *)0)) {
    {
#line 236
    zip_error_set(error, 14, 0);
    }
#line 237
    return ((zip_uint8_t *)((void *)0));
  }
#line 240
  offset = (zip_uint32_t )0;
#line 241
  i = (zip_uint32_t )0;
  {
#line 241
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 241
    if (! (i < len)) {
#line 241
      goto while_break___0;
    }
    {
#line 242
    __cil_tmp13 = _zip_unicode_to_utf8((zip_uint32_t )_cp437_to_unicode[*(cp437buf + i)],
                                       utf8buf + offset);
#line 242
    offset += __cil_tmp13;
#line 241
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
#line 245
  *(utf8buf + (buflen - 1U)) = (zip_uint8_t )0;
#line 246
  if (utf8_lenp) {
#line 247
    *utf8_lenp = buflen - 1U;
  }
#line 248
  return (utf8buf);
}
}
#line 38 "/root/libzip/lib/zip_unchange_data.c"
void _zip_unchange_data(zip_entry_t *ze ) 
{ 


  {
#line 40
  if (ze->source) {
    {
#line 41
    zip_source_free(ze->source);
#line 42
    ze->source = (zip_source_t *)((void *)0);
    }
  }
#line 45
  if ((unsigned long )ze->changes != (unsigned long )((void *)0)) {
#line 45
    if ((ze->changes)->changed & 1U) {
#line 45
      if ((ze->changes)->comp_method == -2) {
#line 46
        (ze->changes)->changed &= 4294967294U;
#line 47
        if ((ze->changes)->changed == 0U) {
          {
#line 48
          _zip_dirent_free(ze->changes);
#line 49
          ze->changes = (zip_dirent_t *)((void *)0);
          }
        }
      }
    }
  }
#line 53
  ze->deleted = 0;
#line 54
  return;
}
}
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                  char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size((void *)__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 45
    __cil_tmp4 = __builtin_object_size((void *)__resolved, 1);
#line 45
    __cil_tmp5 = __realpath_chk(__name, __resolved, __cil_tmp4);
    }
#line 45
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 41 "/root/libzip/lib/zip_unchange_archive.c"
int zip_unchange_archive(zip_t *za___0 ) 
{ 


  {
#line 43
  if (za___0->comment_changed) {
    {
#line 44
    _zip_string_free(za___0->comment_changes);
#line 45
    za___0->comment_changes = (zip_string_t *)((void *)0);
#line 46
    za___0->comment_changed = 0;
    }
  }
#line 49
  za___0->ch_flags = za___0->flags;
#line 51
  return (0);
}
}
#line 41 "/root/libzip/lib/zip_unchange_all.c"
int zip_unchange_all(zip_t *za___0 ) 
{ 
  int ret ;
  zip_uint64_t i ;
  int __cil_tmp4 ;
  int __cil_tmp6 ;

  {
  {
#line 46
  _zip_hash_revert(za___0->names);
#line 48
  ret = 0;
#line 49
  i = (zip_uint64_t )0;
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;

#line 49
    if (! (i < za___0->nentry)) {
#line 49
      goto while_break;
    }
    {
#line 50
    __cil_tmp4 = _zip_unchange(za___0, i, 1);
#line 50
    ret |= __cil_tmp4;
#line 49
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 52
  __cil_tmp6 = zip_unchange_archive(za___0);
#line 52
  ret |= __cil_tmp6;
  }
#line 54
  return (ret);
}
}
#line 41 "/root/libzip/lib/zip_unchange.c"
int zip_unchange(zip_t *za___0 , zip_uint64_t idx ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 43
  __cil_tmp3 = _zip_unchange(za___0, idx, 0);
  }
#line 43
  return (__cil_tmp3);
}
}
#line 48 "/root/libzip/lib/zip_unchange.c"
int _zip_unchange(zip_t *za___0 , zip_uint64_t idx , int allow_duplicates ) 
{ 
  zip_int64_t i ;
  char const   *orig_name ;
  char const   *changed_name ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 53
  if (idx >= za___0->nentry) {
    {
#line 54
    zip_error_set(& za___0->error, 18, 0);
    }
#line 55
    return (-1);
  }
#line 58
  if ((za___0->entry + idx)->changes) {
#line 58
    if (! allow_duplicates) {
#line 58
      if (((za___0->entry + idx)->changes)->changed & 2U) {
#line 59
        if ((unsigned long )(za___0->entry + idx)->orig != (unsigned long )((void *)0)) {
          {
#line 60
          orig_name = _zip_get_name(za___0, idx, 8U, & za___0->error);
          }
#line 60
          if ((unsigned long )orig_name == (unsigned long )((void *)0)) {
#line 61
            return (-1);
          }
          {
#line 64
          i = _zip_name_locate(za___0, orig_name, (zip_flags_t )0, (zip_error_t *)((void *)0));
          }
#line 65
          if (i >= 0L) {
#line 65
            if ((zip_uint64_t )i != idx) {
              {
#line 66
              zip_error_set(& za___0->error, 10, 0);
              }
#line 67
              return (-1);
            }
          }
        } else {
#line 71
          orig_name = (char const   *)((void *)0);
        }
        {
#line 74
        changed_name = _zip_get_name(za___0, idx, (zip_flags_t )0, & za___0->error);
        }
#line 74
        if ((unsigned long )changed_name == (unsigned long )((void *)0)) {
#line 75
          return (-1);
        }
#line 78
        if (orig_name) {
          {
#line 79
          __cil_tmp10 = _zip_hash_add(za___0->names, (zip_uint8_t *)orig_name, idx,
                                      (zip_flags_t )0, & za___0->error);
          }
#line 79
          if (__cil_tmp10 == 0) {
#line 80
            return (-1);
          }
        }
        {
#line 83
        __cil_tmp11 = _zip_hash_delete(za___0->names, (zip_uint8_t *)changed_name,
                                       & za___0->error);
        }
#line 83
        if (__cil_tmp11 == 0) {
          {
#line 84
          _zip_hash_delete(za___0->names, (zip_uint8_t *)orig_name, (zip_error_t *)((void *)0));
          }
#line 85
          return (-1);
        }
      }
    }
  }
  {
#line 89
  _zip_dirent_free((za___0->entry + idx)->changes);
#line 90
  (za___0->entry + idx)->changes = (zip_dirent_t *)((void *)0);
#line 92
  _zip_unchange_data(za___0->entry + idx);
  }
#line 94
  return (0);
}
}
#line 42 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest ,
                                                                                              void const   *__src ,
                                                                                              size_t __len ) ;
#line 46
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memmove)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 62
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memset)(void *__dest ,
                                                                                              int __ch ,
                                                                                              size_t __len ) ;
#line 65
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 92
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 128
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcat)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 136
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncat)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 140
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 258
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 394
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 408
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 450
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                                                            void *__dest ,
                                                                                            size_t __len ) ;
#line 454
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bzero)(void *__dest ,
                                                                                            size_t __len ) ;
#line 529
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 572
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __n ) ;
#line 393 "/usr/include/x86_64-linux-gnu/bits/string2.h"
extern void *__rawmemchr(void const   *__s , int __c ) ;
#line 945
__inline extern size_t ( __attribute__((__gnu_inline__)) __strcspn_c1)(char const   *__s ,
                                                                       int __reject ) ;
#line 947 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) __strcspn_c1)(char const   *__s ,
                                                                       int __reject ) 
{ 
  size_t __result ;

  {
#line 949
  __result = (size_t )0;
  {
#line 950
  while (1) {
    while_continue: /* CIL Label */ ;

#line 950
    if ((int )*(__s + __result) != 0) {
#line 950
      if (! ((int )*(__s + __result) != __reject)) {
#line 950
        goto while_break;
      }
    } else {
#line 950
      goto while_break;
    }
#line 951
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 952
  return (__result);
}
}
#line 955
__inline extern size_t ( __attribute__((__gnu_inline__)) __strcspn_c2)(char const   *__s ,
                                                                       int __reject1 ,
                                                                       int __reject2 ) ;
#line 958 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) __strcspn_c2)(char const   *__s ,
                                                                       int __reject1 ,
                                                                       int __reject2 ) 
{ 
  size_t __result ;

  {
#line 960
  __result = (size_t )0;
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;

#line 961
    if ((int )*(__s + __result) != 0) {
#line 961
      if ((int )*(__s + __result) != __reject1) {
#line 961
        if (! ((int )*(__s + __result) != __reject2)) {
#line 961
          goto while_break;
        }
      } else {
#line 961
        goto while_break;
      }
    } else {
#line 961
      goto while_break;
    }
#line 963
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 964
  return (__result);
}
}
#line 967
__inline extern size_t ( __attribute__((__gnu_inline__)) __strcspn_c3)(char const   *__s ,
                                                                       int __reject1 ,
                                                                       int __reject2 ,
                                                                       int __reject3 ) ;
#line 970 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) __strcspn_c3)(char const   *__s ,
                                                                       int __reject1 ,
                                                                       int __reject2 ,
                                                                       int __reject3 ) 
{ 
  size_t __result ;

  {
#line 973
  __result = (size_t )0;
  {
#line 974
  while (1) {
    while_continue: /* CIL Label */ ;

#line 974
    if ((int )*(__s + __result) != 0) {
#line 974
      if ((int )*(__s + __result) != __reject1) {
#line 974
        if ((int )*(__s + __result) != __reject2) {
#line 974
          if (! ((int )*(__s + __result) != __reject3)) {
#line 974
            goto while_break;
          }
        } else {
#line 974
          goto while_break;
        }
      } else {
#line 974
        goto while_break;
      }
    } else {
#line 974
      goto while_break;
    }
#line 976
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 977
  return (__result);
}
}
#line 1021
__inline extern size_t ( __attribute__((__gnu_inline__)) __strspn_c1)(char const   *__s ,
                                                                      int __accept ) ;
#line 1023 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) __strspn_c1)(char const   *__s ,
                                                                      int __accept ) 
{ 
  size_t __result ;

  {
#line 1025
  __result = (size_t )0;
  {
#line 1027
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1027
    if (! ((int )*(__s + __result) == __accept)) {
#line 1027
      goto while_break;
    }
#line 1028
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1029
  return (__result);
}
}
#line 1032
__inline extern size_t ( __attribute__((__gnu_inline__)) __strspn_c2)(char const   *__s ,
                                                                      int __accept1 ,
                                                                      int __accept2 ) ;
#line 1035 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) __strspn_c2)(char const   *__s ,
                                                                      int __accept1 ,
                                                                      int __accept2 ) 
{ 
  size_t __result ;

  {
#line 1037
  __result = (size_t )0;
  {
#line 1039
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1039
    if (! ((int )*(__s + __result) == __accept1)) {
#line 1039
      if (! ((int )*(__s + __result) == __accept2)) {
#line 1039
        goto while_break;
      }
    }
#line 1040
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1041
  return (__result);
}
}
#line 1044
__inline extern size_t ( __attribute__((__gnu_inline__)) __strspn_c3)(char const   *__s ,
                                                                      int __accept1 ,
                                                                      int __accept2 ,
                                                                      int __accept3 ) ;
#line 1047 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) __strspn_c3)(char const   *__s ,
                                                                      int __accept1 ,
                                                                      int __accept2 ,
                                                                      int __accept3 ) 
{ 
  size_t __result ;

  {
#line 1049
  __result = (size_t )0;
  {
#line 1051
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1051
    if (! ((int )*(__s + __result) == __accept1)) {
#line 1051
      if (! ((int )*(__s + __result) == __accept2)) {
#line 1051
        if (! ((int )*(__s + __result) == __accept3)) {
#line 1051
          goto while_break;
        }
      }
    }
#line 1053
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1054
  return (__result);
}
}
#line 1097
__inline extern char *( __attribute__((__gnu_inline__)) __strpbrk_c2)(char const   *__s ,
                                                                      int __accept1 ,
                                                                      int __accept2 ) ;
#line 1100 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *( __attribute__((__gnu_inline__)) __strpbrk_c2)(char const   *__s ,
                                                                      int __accept1 ,
                                                                      int __accept2 ) 
{ 
  char *tmp ;

  {
  {
#line 1103
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1103
    if ((int )*__s != 0) {
#line 1103
      if ((int )*__s != __accept1) {
#line 1103
        if (! ((int )*__s != __accept2)) {
#line 1103
          goto while_break;
        }
      } else {
#line 1103
        goto while_break;
      }
    } else {
#line 1103
      goto while_break;
    }
#line 1104
    __s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1105
  if ((int )*__s == 0) {
#line 1105
    tmp = (char *)((void *)0);
  } else {
#line 1105
    tmp = (char *)((size_t )__s);
  }
#line 1105
  return (tmp);
}
}
#line 1108
__inline extern char *( __attribute__((__gnu_inline__)) __strpbrk_c3)(char const   *__s ,
                                                                      int __accept1 ,
                                                                      int __accept2 ,
                                                                      int __accept3 ) ;
#line 1111 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *( __attribute__((__gnu_inline__)) __strpbrk_c3)(char const   *__s ,
                                                                      int __accept1 ,
                                                                      int __accept2 ,
                                                                      int __accept3 ) 
{ 
  char *tmp ;

  {
  {
#line 1114
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1114
    if ((int )*__s != 0) {
#line 1114
      if ((int )*__s != __accept1) {
#line 1114
        if ((int )*__s != __accept2) {
#line 1114
          if (! ((int )*__s != __accept3)) {
#line 1114
            goto while_break;
          }
        } else {
#line 1114
          goto while_break;
        }
      } else {
#line 1114
        goto while_break;
      }
    } else {
#line 1114
      goto while_break;
    }
#line 1116
    __s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1117
  if ((int )*__s == 0) {
#line 1117
    tmp = (char *)((void *)0);
  } else {
#line 1117
    tmp = (char *)((size_t )__s);
  }
#line 1117
  return (tmp);
}
}
#line 1147
__inline extern char *( __attribute__((__gnu_inline__)) __strtok_r_1c)(char *__s ,
                                                                       char __sep ,
                                                                       char **__nextp ) ;
#line 1149 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *( __attribute__((__gnu_inline__)) __strtok_r_1c)(char *__s ,
                                                                       char __sep ,
                                                                       char **__nextp ) 
{ 
  char *__result ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1152
  if ((unsigned long )__s == (unsigned long )((void *)0)) {
#line 1153
    __s = *__nextp;
  }
  {
#line 1154
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1154
    if (! ((int )*__s == (int )__sep)) {
#line 1154
      goto while_break;
    }
#line 1155
    __s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 1156
  __result = (char *)((void *)0);
#line 1157
  if ((int )*__s != 0) {
#line 1159
    __cil_tmp5 = __s;
#line 1159
    __s ++;
#line 1159
    __result = __cil_tmp5;
    {
#line 1160
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1160
      if (! ((int )*__s != 0)) {
#line 1160
        goto while_break___0;
      }
#line 1161
      __cil_tmp6 = __s;
#line 1161
      __s ++;
#line 1161
      if ((int )*__cil_tmp6 == (int )__sep) {
#line 1163
        *(__s + -1) = (char )'\000';
#line 1164
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 1167
  *__nextp = __s;
#line 1168
  return (__result);
}
}
#line 1197
__inline extern char *( __attribute__((__gnu_inline__)) __strsep_1c)(char **__s ,
                                                                     char __reject ) ;
#line 1199 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *( __attribute__((__gnu_inline__)) __strsep_1c)(char **__s ,
                                                                     char __reject ) 
{ 
  char *__retval ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *tmp ;
  char *__cil_tmp9 ;

  {
#line 1201
  __retval = *__s;
#line 1202
  __cil_tmp5 = 0;
#line 1202
  __cil_tmp4 = 0;
#line 1202
  if (__cil_tmp4) {
#line 1202
    if (! __cil_tmp5) {
#line 1202
      if ((int )__reject == 0) {
        {
#line 1202
        __cil_tmp6 = __rawmemchr((void const   *)__retval, (int )__reject);
#line 1202
        tmp = (char *)__cil_tmp6;
        }
      } else {
        {
#line 1202
        __cil_tmp7 = __builtin_strchr((char *)((char const   *)__retval), (int )__reject);
#line 1202
        tmp = __cil_tmp7;
        }
      }
    } else {
      {
#line 1202
      __cil_tmp7 = __builtin_strchr((char *)((char const   *)__retval), (int )__reject);
#line 1202
      tmp = __cil_tmp7;
      }
    }
  } else {
    {
#line 1202
    __cil_tmp7 = __builtin_strchr((char *)((char const   *)__retval), (int )__reject);
#line 1202
    tmp = __cil_tmp7;
    }
  }
#line 1202
  *__s = tmp;
#line 1202
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1202
    if ((unsigned long )*__s != (unsigned long )((void *)0)) {
#line 1203
      __cil_tmp9 = *__s;
#line 1203
      (*__s) ++;
#line 1203
      *__cil_tmp9 = (char )'\000';
    }
  }
#line 1204
  return (__retval);
}
}
#line 1207
__inline extern char *( __attribute__((__gnu_inline__)) __strsep_2c)(char **__s ,
                                                                     char __reject1 ,
                                                                     char __reject2 ) ;
#line 1209 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *( __attribute__((__gnu_inline__)) __strsep_2c)(char **__s ,
                                                                     char __reject1 ,
                                                                     char __reject2 ) 
{ 
  char *__retval ;
  char *__cp ;
  char *__cil_tmp6 ;

  {
#line 1211
  __retval = *__s;
#line 1212
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1214
    __cp = __retval;
    {
#line 1215
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1217
      if ((int )*__cp == 0) {
#line 1219
        __cp = (char *)((void *)0);
#line 1220
        goto while_break;
      }
#line 1222
      if ((int )*__cp == (int )__reject1) {
#line 1224
        __cil_tmp6 = __cp;
#line 1224
        __cp ++;
#line 1224
        *__cil_tmp6 = (char )'\000';
#line 1225
        goto while_break;
      } else
#line 1222
      if ((int )*__cp == (int )__reject2) {
#line 1224
        __cil_tmp6 = __cp;
#line 1224
        __cp ++;
#line 1224
        *__cil_tmp6 = (char )'\000';
#line 1225
        goto while_break;
      }
#line 1227
      __cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 1229
    *__s = __cp;
  }
#line 1231
  return (__retval);
}
}
#line 1234
__inline extern char *( __attribute__((__gnu_inline__)) __strsep_3c)(char **__s ,
                                                                     char __reject1 ,
                                                                     char __reject2 ,
                                                                     char __reject3 ) ;
#line 1237 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *( __attribute__((__gnu_inline__)) __strsep_3c)(char **__s ,
                                                                     char __reject1 ,
                                                                     char __reject2 ,
                                                                     char __reject3 ) 
{ 
  char *__retval ;
  char *__cp ;
  char *__cil_tmp7 ;

  {
#line 1239
  __retval = *__s;
#line 1240
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1242
    __cp = __retval;
    {
#line 1243
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1245
      if ((int )*__cp == 0) {
#line 1247
        __cp = (char *)((void *)0);
#line 1248
        goto while_break;
      }
#line 1250
      if ((int )*__cp == (int )__reject1) {
#line 1252
        __cil_tmp7 = __cp;
#line 1252
        __cp ++;
#line 1252
        *__cil_tmp7 = (char )'\000';
#line 1253
        goto while_break;
      } else
#line 1250
      if ((int )*__cp == (int )__reject2) {
#line 1252
        __cil_tmp7 = __cp;
#line 1252
        __cp ++;
#line 1252
        *__cil_tmp7 = (char )'\000';
#line 1253
        goto while_break;
      } else
#line 1250
      if ((int )*__cp == (int )__reject3) {
#line 1252
        __cil_tmp7 = __cp;
#line 1252
        __cp ++;
#line 1252
        *__cil_tmp7 = (char )'\000';
#line 1253
        goto while_break;
      }
#line 1255
      __cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 1257
    *__s = __cp;
  }
#line 1259
  return (__retval);
}
}
#line 1278
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest ,
                                                                                              void const   *__src ,
                                                                                              size_t __len ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest , void const   *__src ,
                                                                size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 53
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 53
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 53
  return (__cil_tmp5);
}
}
#line 57
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memmove)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__gnu_inline__)) memmove)(void *__dest , void const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 59
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 59
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 59
  return (__cil_tmp5);
}
}
#line 78
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memset)(void *__dest ,
                                                                                              int __ch ,
                                                                                              size_t __len ) ;
#line 78 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__gnu_inline__)) memset)(void *__dest , int __ch ,
                                                                size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 90
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 90
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 90
  return (__cil_tmp5);
}
}
#line 95
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                                                            void *__dest ,
                                                                                            size_t __len ) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                              void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 97
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 97
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 99
  return;
}
}
#line 101
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bzero)(void *__dest ,
                                                                                            size_t __len ) ;
#line 101 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void ( __attribute__((__gnu_inline__)) bzero)(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 103
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 103
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
#line 105
  return;
}
}
#line 108
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 110
  __cil_tmp3 = __builtin_object_size((void *)__dest, 1);
#line 110
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 110
  return (__cil_tmp4);
}
}
#line 123
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 123 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest , char const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 126
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
#line 126
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 126
  return (__cil_tmp5);
}
}
#line 130
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 132
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 136
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __n ) ;
#line 136 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest , char const   *__src ,
                                                                 size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 138
  __cil_tmp6 = __builtin_object_size((void *)__dest, 1);
#line 138
  __cil_tmp5 = 0;
#line 138
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
  }
#line 138
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 138
    if (! __cil_tmp5) {
      {
#line 140
      __cil_tmp7 = __builtin_object_size((void *)__dest, 1);
#line 140
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
#line 140
      return (__cil_tmp8);
    } else
#line 138
    if (__n > __cil_tmp6) {
      {
#line 140
      __cil_tmp7 = __builtin_object_size((void *)__dest, 1);
#line 140
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
#line 140
      return (__cil_tmp8);
    }
  }
  {
#line 141
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 141
  return (__cil_tmp9);
}
}
#line 146
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcat)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 146 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__gnu_inline__)) strcat)(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 148
  __cil_tmp3 = __builtin_object_size((void *)__dest, 1);
#line 148
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 148
  return (__cil_tmp4);
}
}
#line 153
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncat)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__gnu_inline__)) strncat)(char *__dest , char const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 156
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
#line 156
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 156
  return (__cil_tmp5);
}
}
#line 42 "/root/libzip/lib/zip_string.c"
zip_uint32_t _zip_string_crc32(zip_string_t *s ) 
{ 
  zip_uint32_t crc ;
  uLong __cil_tmp3 ;
  uLong __cil_tmp4 ;

  {
  {
#line 46
  __cil_tmp3 = crc32((uLong )0L, (Bytef *)0, (uInt )0);
#line 46
  crc = (zip_uint32_t )__cil_tmp3;
  }
#line 48
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 49
    __cil_tmp4 = crc32((uLong )crc, s->raw, (uInt )s->length);
#line 49
    crc = (zip_uint32_t )__cil_tmp4;
    }
  }
#line 51
  return (crc);
}
}
#line 56 "/root/libzip/lib/zip_string.c"
int _zip_string_equal(zip_string_t *a , zip_string_t *b ) 
{ 
  int __cil_tmp3 ;

  {
#line 58
  if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 59
    return ((unsigned long )a == (unsigned long )b);
  } else
#line 58
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 59
    return ((unsigned long )a == (unsigned long )b);
  }
#line 61
  if ((int )a->length != (int )b->length) {
#line 62
    return (0);
  }
  {
#line 66
  __cil_tmp3 = memcmp((void const   *)a->raw, (void const   *)b->raw, (unsigned long )a->length);
  }
#line 66
  return (__cil_tmp3 == 0);
}
}
#line 71 "/root/libzip/lib/zip_string.c"
void _zip_string_free(zip_string_t *s ) 
{ 


  {
#line 73
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 74
    return;
  }
  {
#line 76
  free((void *)s->raw);
#line 77
  free((void *)s->converted);
#line 78
  free((void *)s);
  }
#line 80
  return;
}
}
#line 86 "/root/libzip/lib/zip_string.c"
static zip_uint8_t empty[1]  ;
#line 83 "/root/libzip/lib/zip_string.c"
zip_uint8_t *_zip_string_get(zip_string_t *string , zip_uint32_t *lenp , zip_flags_t flags ,
                             zip_error_t *error ) 
{ 


  {
  {
#line 85
  strcpy((char *)(empty), "\f\201\001");
  }
#line 87
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 88
    if (lenp) {
#line 89
      *lenp = (zip_uint32_t )0;
    }
#line 90
    return (empty);
  }
#line 93
  if ((flags & 64U) == 0U) {
#line 95
    if ((unsigned int )string->encoding == 0U) {
      {
#line 96
      _zip_guess_encoding(string, (enum zip_encoding_type )0);
      }
    }
#line 98
    if (flags & 128U) {
#line 98
      if ((unsigned int )string->encoding != 1U) {
#line 98
        if ((unsigned int )string->encoding != 2U) {
          _L: 
#line 101
          if ((unsigned long )string->converted == (unsigned long )((void *)0)) {
            {
#line 102
            string->converted = _zip_cp437_to_utf8(string->raw, (zip_uint32_t )string->length,
                                                   & string->converted_length, error);
            }
#line 102
            if ((unsigned long )string->converted == (unsigned long )((void *)0)) {
#line 104
              return ((zip_uint8_t *)((void *)0));
            }
          }
#line 106
          if (lenp) {
#line 107
            *lenp = string->converted_length;
          }
#line 108
          return (string->converted);
        } else {
#line 98
          goto _L___0;
        }
      } else {
#line 98
        goto _L___0;
      }
    } else
    _L___0: 
#line 98
    if ((unsigned int )string->encoding == 4U) {
#line 98
      goto _L;
    }
  }
#line 112
  if (lenp) {
#line 113
    *lenp = (zip_uint32_t )string->length;
  }
#line 114
  return (string->raw);
}
}
#line 119 "/root/libzip/lib/zip_string.c"
zip_uint16_t _zip_string_length(zip_string_t *s ) 
{ 


  {
#line 121
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 122
    return ((zip_uint16_t )0);
  }
#line 124
  return (s->length);
}
}
#line 129 "/root/libzip/lib/zip_string.c"
zip_string_t *_zip_string_new(zip_uint8_t *raw , zip_uint16_t length , zip_flags_t flags ,
                              zip_error_t *error ) 
{ 
  zip_string_t *s ;
  zip_encoding_type_t expected_encoding ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  enum zip_encoding_type __cil_tmp9 ;

  {
#line 134
  if ((int )length == 0) {
#line 135
    return ((zip_string_t *)((void *)0));
  }
#line 138
  if ((flags & 6144U) == 0U) {
#line 138
    goto case_0;
  }
#line 141
  if ((flags & 6144U) == 2048U) {
#line 141
    goto case_2048;
  }
#line 144
  if ((flags & 6144U) == 4096U) {
#line 144
    goto case_4096;
  }
#line 147
  goto switch_default;
  case_0: 
#line 139
  expected_encoding = (zip_encoding_type_t )0;
#line 140
  goto switch_break;
  case_2048: 
#line 142
  expected_encoding = (zip_encoding_type_t )2;
#line 143
  goto switch_break;
  case_4096: 
#line 145
  expected_encoding = (zip_encoding_type_t )4;
#line 146
  goto switch_break;
  switch_default: 
  {
#line 148
  zip_error_set(error, 18, 0);
  }
#line 149
  return ((zip_string_t *)((void *)0));
  switch_break: 
  {
#line 152
  __cil_tmp7 = malloc(sizeof(*s));
#line 152
  s = (zip_string_t *)__cil_tmp7;
  }
#line 152
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 153
    zip_error_set(error, 14, 0);
    }
#line 154
    return ((zip_string_t *)((void *)0));
  }
  {
#line 157
  __cil_tmp8 = malloc((size_t )((int )length + 1));
#line 157
  s->raw = (zip_uint8_t *)__cil_tmp8;
  }
#line 157
  if ((unsigned long )s->raw == (unsigned long )((void *)0)) {
    {
#line 158
    free((void *)s);
    }
#line 159
    return ((zip_string_t *)((void *)0));
  }
  {
#line 162
  memcpy((void *)s->raw, (void const   *)raw, (unsigned long )length);
#line 163
  *(s->raw + (int )length) = (zip_uint8_t )'\000';
#line 164
  s->length = length;
#line 165
  s->encoding = (enum zip_encoding_type )0;
#line 166
  s->converted = (zip_uint8_t *)((void *)0);
#line 167
  s->converted_length = (zip_uint32_t )0;
  }
#line 169
  if ((unsigned int )expected_encoding != 0U) {
    {
#line 170
    __cil_tmp9 = _zip_guess_encoding(s, expected_encoding);
    }
#line 170
    if ((unsigned int )__cil_tmp9 == 5U) {
      {
#line 171
      _zip_string_free(s);
#line 172
      zip_error_set(error, 18, 0);
      }
#line 173
      return ((zip_string_t *)((void *)0));
    }
  }
#line 177
  return (s);
}
}
#line 182 "/root/libzip/lib/zip_string.c"
int _zip_string_write(zip_t *za___0 , zip_string_t *s ) 
{ 
  int __cil_tmp3 ;

  {
#line 184
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 185
    return (0);
  }
  {
#line 187
  __cil_tmp3 = _zip_write(za___0, (void const   *)s->raw, (zip_uint64_t )s->length);
  }
#line 187
  return (__cil_tmp3);
}
}
#line 39 "/root/libzip/lib/zip_strerror.c"
char const   *zip_strerror(zip_t *za___0 ) 
{ 
  char const   *__cil_tmp2 ;

  {
  {
#line 41
  __cil_tmp2 = zip_error_strerror(& za___0->error);
  }
#line 41
  return (__cil_tmp2);
}
}
#line 40 "/root/libzip/lib/zip_stat_init.c"
void zip_stat_init(zip_stat_t *st ) 
{ 


  {
#line 42
  st->valid = (zip_uint64_t )0;
#line 43
  st->name = (char const   *)((void *)0);
#line 44
  st->index = 0xffffffffffffffffUL;
#line 45
  st->crc = (zip_uint32_t )0;
#line 46
  st->mtime = (time_t )-1;
#line 47
  st->size = (zip_uint64_t )0;
#line 48
  st->comp_size = (zip_uint64_t )0;
#line 49
  st->comp_method = (zip_uint16_t )0;
#line 50
  st->encryption_method = (zip_uint16_t )0;
#line 51
  return;
}
}
#line 55 "/root/libzip/lib/zip_stat_init.c"
int _zip_stat_merge(zip_stat_t *dst , zip_stat_t *src , zip_error_t *error ) 
{ 


  {
#line 58
  if (src->valid & 2UL) {
#line 59
    dst->index = src->index;
  }
#line 61
  if (src->valid & 4UL) {
#line 62
    dst->size = src->size;
  }
#line 64
  if (src->valid & 8UL) {
#line 65
    dst->comp_size = src->comp_size;
  }
#line 67
  if (src->valid & 16UL) {
#line 68
    dst->mtime = src->mtime;
  }
#line 70
  if (src->valid & 32UL) {
#line 71
    dst->crc = src->crc;
  }
#line 73
  if (src->valid & 64UL) {
#line 74
    dst->comp_method = src->comp_method;
  }
#line 76
  if (src->valid & 128UL) {
#line 77
    dst->encryption_method = src->encryption_method;
  }
#line 79
  if (src->valid & 256UL) {
#line 80
    dst->flags = src->flags;
  }
#line 82
  dst->valid |= src->valid;
#line 84
  return (0);
}
}
#line 39 "/root/libzip/lib/zip_stat_index.c"
int zip_stat_index(zip_t *za___0 , zip_uint64_t index___0 , zip_flags_t flags , zip_stat_t *st ) 
{ 
  char const   *name ;
  zip_dirent_t *de ;
  int __cil_tmp9 ;

  {
  {
#line 45
  de = _zip_get_dirent(za___0, index___0, flags, (zip_error_t *)((void *)0));
  }
#line 45
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 46
    return (-1);
  }
  {
#line 48
  name = zip_get_name(za___0, index___0, flags);
  }
#line 48
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 49
    return (-1);
  }
#line 52
  if ((unsigned long )(za___0->entry + index___0)->source != (unsigned long )((void *)0)) {
#line 52
    if ((flags & 8U) == 0U) {
      {
#line 54
      __cil_tmp9 = zip_source_stat((za___0->entry + index___0)->source, st);
      }
#line 54
      if (__cil_tmp9 < 0) {
        {
#line 55
        zip_error_set(& za___0->error, 15, 0);
        }
#line 56
        return (-1);
      }
    } else {
#line 52
      goto _L;
    }
  } else {
    _L: 
    {
#line 60
    zip_stat_init(st);
#line 62
    st->crc = de->crc;
#line 63
    st->size = de->uncomp_size;
#line 64
    st->mtime = de->last_mod;
#line 65
    st->comp_size = de->comp_size;
#line 66
    st->comp_method = (zip_uint16_t )de->comp_method;
    }
#line 67
    if ((int )de->bitflags & 1) {
#line 68
      if ((int )de->bitflags & 64) {
#line 70
        st->encryption_method = (zip_uint16_t )65535;
      } else {
#line 73
        st->encryption_method = (zip_uint16_t )1;
      }
    } else {
#line 76
      st->encryption_method = (zip_uint16_t )0;
    }
#line 77
    st->valid = (zip_uint64_t )252U;
  }
#line 81
  st->index = index___0;
#line 82
  st->name = name;
#line 83
  st->valid |= 3UL;
#line 85
  return (0);
}
}
#line 39 "/root/libzip/lib/zip_stat.c"
int zip_stat(zip_t *za___0 , char const   *fname , zip_flags_t flags , zip_stat_t *st ) 
{ 
  zip_int64_t idx ;
  int __cil_tmp7 ;

  {
  {
#line 43
  idx = zip_name_locate(za___0, fname, flags);
  }
#line 43
  if (idx < 0L) {
#line 44
    return (-1);
  }
  {
#line 46
  __cil_tmp7 = zip_stat_index(za___0, (zip_uint64_t )idx, flags, st);
  }
#line 46
  return (__cil_tmp7);
}
}
#line 41 "/root/libzip/lib/zip_source_zip_new.c"
zip_source_t *_zip_source_zip_new(zip_t *za___0 , zip_t *srcza , zip_uint64_t srcidx ,
                                  zip_flags_t flags , zip_uint64_t start , zip_uint64_t len ,
                                  char const   *password ) 
{ 
  zip_source_t *(*comp_impl)(zip_t * , zip_source_t * , zip_int32_t  , int  ) ;
  zip_source_t *(*enc_impl)(zip_t * , zip_source_t * , zip_uint16_t  , int  , char const   * ) ;
  zip_source_t *src ;
  zip_source_t *s2 ;
  zip_uint64_t offset ;
  struct zip_stat st ;
  int __cil_tmp14 ;
  zip_source_t *__cil_tmp18 ;
  struct zip_stat st2 ;
  zip_uint64_t tmp ;
  int __cil_tmp23 ;
  zip_uint64_t tmp___0 ;
  zip_source_t *__cil_tmp28 ;

  {
#line 49
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 50
    return ((zip_source_t *)((void *)0));
  }
#line 52
  if ((unsigned long )srcza == (unsigned long )((void *)0)) {
    {
#line 53
    zip_error_set(& za___0->error, 18, 0);
    }
#line 54
    return ((zip_source_t *)((void *)0));
  } else
#line 52
  if (srcidx >= srcza->nentry) {
    {
#line 53
    zip_error_set(& za___0->error, 18, 0);
    }
#line 54
    return ((zip_source_t *)((void *)0));
  }
#line 57
  if ((unsigned long )(srcza->entry + srcidx)->source != (unsigned long )((void *)0)) {
    _L: 
#line 57
    if ((flags & 8U) == 0U) {
      {
#line 59
      zip_error_set(& za___0->error, 15, 0);
      }
#line 60
      return ((zip_source_t *)((void *)0));
    }
  } else
#line 57
  if ((srcza->entry + srcidx)->deleted) {
#line 57
    goto _L;
  }
  {
#line 63
  __cil_tmp14 = zip_stat_index(srcza, srcidx, flags | 8U, & st);
  }
#line 63
  if (__cil_tmp14 < 0) {
    {
#line 64
    zip_error_set(& za___0->error, 20, 0);
    }
#line 65
    return ((zip_source_t *)((void *)0));
  }
#line 68
  if (flags & 32U) {
#line 69
    flags |= 4U;
  }
#line 71
  if (start > 0UL) {
    _L___2: 
#line 71
    if (flags & 4U) {
      {
#line 72
      zip_error_set(& za___0->error, 18, 0);
      }
#line 73
      return ((zip_source_t *)((void *)0));
    }
  } else
#line 71
  if (len > 0UL) {
#line 71
    goto _L___2;
  }
#line 77
  if (start > 0UL) {
    _L___3: 
#line 77
    if (start + len < start) {
      {
#line 78
      zip_error_set(& za___0->error, 18, 0);
      }
#line 79
      return ((zip_source_t *)((void *)0));
    } else
#line 77
    if (start + len > st.size) {
      {
#line 78
      zip_error_set(& za___0->error, 18, 0);
      }
#line 79
      return ((zip_source_t *)((void *)0));
    }
  } else
#line 77
  if (len > 0UL) {
#line 77
    goto _L___3;
  }
#line 82
  enc_impl = (zip_source_t *(*)(zip_t * , zip_source_t * , zip_uint16_t  , int  ,
                                char const   * ))((void *)0);
#line 83
  if ((flags & 32U) == 0U) {
#line 83
    if ((int )st.encryption_method != 0) {
#line 84
      if ((unsigned long )password == (unsigned long )((void *)0)) {
        {
#line 85
        zip_error_set(& za___0->error, 26, 0);
        }
#line 86
        return ((zip_source_t *)((void *)0));
      }
      {
#line 88
      enc_impl = _zip_get_encryption_implementation(st.encryption_method);
      }
#line 88
      if ((unsigned long )enc_impl == (unsigned long )((void *)0)) {
        {
#line 89
        zip_error_set(& za___0->error, 24, 0);
        }
#line 90
        return ((zip_source_t *)((void *)0));
      }
    }
  }
#line 94
  comp_impl = (zip_source_t *(*)(zip_t * , zip_source_t * , zip_int32_t  , int  ))((void *)0);
#line 95
  if ((flags & 4U) == 0U) {
#line 96
    if ((int )st.comp_method != 0) {
      {
#line 97
      comp_impl = _zip_get_compression_implementation((zip_int32_t )st.comp_method);
      }
#line 97
      if ((unsigned long )comp_impl == (unsigned long )((void *)0)) {
        {
#line 98
        zip_error_set(& za___0->error, 16, 0);
        }
#line 99
        return ((zip_source_t *)((void *)0));
      }
    }
  }
  {
#line 104
  offset = _zip_file_get_offset(srcza, srcidx, & za___0->error);
  }
#line 104
  if (offset == 0UL) {
#line 105
    return ((zip_source_t *)((void *)0));
  }
#line 107
  if (st.comp_size == 0UL) {
    {
#line 108
    __cil_tmp18 = zip_source_buffer(za___0, (void const   *)((void *)0), (zip_uint64_t )0,
                                    0);
    }
#line 108
    return (__cil_tmp18);
  }
#line 111
  if ((unsigned long )enc_impl == (unsigned long )((void *)0)) {
#line 111
    if (start + len > 0UL) {
#line 111
      if ((unsigned long )comp_impl == (unsigned long )((void *)0)) {
#line 114
        if (len) {
#line 114
          tmp = len;
        } else {
#line 114
          tmp = st.size - start;
        }
        {
#line 114
        st2.size = tmp;
#line 115
        st2.comp_size = st2.size;
#line 116
        st2.comp_method = (zip_uint16_t )0;
#line 117
        st2.mtime = st.mtime;
#line 118
        st2.valid = (zip_uint64_t )92U;
#line 120
        src = _zip_source_window_new(srcza->src, offset + start, st2.size, & st2,
                                     & za___0->error);
        }
#line 120
        if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 121
          return ((zip_source_t *)((void *)0));
        }
      } else {
#line 111
        goto _L___4;
      }
    } else {
#line 111
      goto _L___4;
    }
  } else {
    _L___4: 
    {
#line 125
    src = _zip_source_window_new(srcza->src, offset, st.comp_size, & st, & za___0->error);
    }
#line 125
    if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 126
      return ((zip_source_t *)((void *)0));
    }
  }
  {
#line 130
  __cil_tmp23 = _zip_source_set_source_archive(src, srcza);
  }
#line 130
  if (__cil_tmp23 < 0) {
    {
#line 131
    zip_source_free(src);
    }
#line 132
    return ((zip_source_t *)((void *)0));
  }
#line 137
  if (enc_impl) {
    {
#line 138
    s2 = (*enc_impl)(za___0, src, st.encryption_method, 0, password);
#line 139
    zip_source_free(src);
    }
#line 140
    if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 141
      return ((zip_source_t *)((void *)0));
    }
#line 143
    src = s2;
  }
#line 145
  if (comp_impl) {
    {
#line 146
    s2 = (*comp_impl)(za___0, src, (zip_int32_t )st.comp_method, 0);
#line 147
    zip_source_free(src);
    }
#line 148
    if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 149
      return ((zip_source_t *)((void *)0));
    }
#line 151
    src = s2;
  }
#line 153
  if ((flags & 4U) == 0U) {
    _L___7: 
#line 153
    if (len == 0UL) {
      _L___6: 
      {
#line 155
      s2 = zip_source_crc(za___0, src, 1);
#line 156
      zip_source_free(src);
      }
#line 157
      if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 158
        return ((zip_source_t *)((void *)0));
      }
#line 160
      src = s2;
    } else
#line 153
    if (len == st.comp_size) {
#line 153
      goto _L___6;
    }
  } else
#line 153
  if ((int )st.comp_method == 0) {
#line 153
    goto _L___7;
  }
#line 163
  if (comp_impl) {
    _L___8: 
#line 163
    if (start + len > 0UL) {
#line 164
      if (len) {
#line 164
        tmp___0 = len;
      } else {
#line 164
        tmp___0 = st.size - start;
      }
      {
#line 164
      __cil_tmp28 = zip_source_window(za___0, src, start, tmp___0);
#line 164
      s2 = __cil_tmp28;
#line 165
      zip_source_free(src);
      }
#line 166
      if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 167
        return ((zip_source_t *)((void *)0));
      }
#line 169
      src = s2;
    }
  } else
#line 163
  if (enc_impl) {
#line 163
    goto _L___8;
  }
#line 172
  return (src);
}
}
#line 42 "/root/libzip/lib/zip_source_zip.c"
zip_source_t *zip_source_zip(zip_t *za___0 , zip_t *srcza , zip_uint64_t srcidx ,
                             zip_flags_t flags , zip_uint64_t start , zip_int64_t len ) 
{ 
  zip_source_t *__cil_tmp7 ;

  {
#line 45
  if (len < -1L) {
    {
#line 46
    zip_error_set(& za___0->error, 18, 0);
    }
#line 47
    return ((zip_source_t *)((void *)0));
  }
#line 50
  if (len == -1L) {
#line 51
    len = (zip_int64_t )0;
  }
#line 53
  if (start == 0UL) {
#line 53
    if (len == 0L) {
#line 54
      flags |= 4U;
    } else {
#line 56
      flags &= 4294967291U;
    }
  } else {
#line 56
    flags &= 4294967291U;
  }
  {
#line 58
  __cil_tmp7 = _zip_source_zip_new(za___0, srcza, srcidx, flags, start, (zip_uint64_t )len,
                                   (char const   *)((void *)0));
  }
#line 58
  return (__cil_tmp7);
}
}
#line 39 "/root/libzip/lib/zip_source_write.c"
zip_int64_t zip_source_write(zip_source_t *src , void const   *data , zip_uint64_t length ) 
{ 
  zip_int64_t __cil_tmp4 ;

  {
#line 41
  if (! ((unsigned int )src->write_state == 1U)) {
    {
#line 42
    zip_error_set(& src->error, 18, 0);
    }
#line 43
    return ((zip_int64_t )-1);
  } else
#line 41
  if (length > 0xffffffffffffffffUL) {
    {
#line 42
    zip_error_set(& src->error, 18, 0);
    }
#line 43
    return ((zip_int64_t )-1);
  }
  {
#line 46
  __cil_tmp4 = _zip_source_call(src, (void *)data, length, (zip_source_cmd_t )11);
  }
#line 46
  return (__cil_tmp4);
}
}
#line 50 "/root/libzip/lib/zip_source_window.c"
static zip_int64_t window_read(zip_source_t *src , void *_ctx , void *data , zip_uint64_t len ,
                               zip_source_cmd_t cmd ) ;
#line 54 "/root/libzip/lib/zip_source_window.c"
zip_source_t *zip_source_window(zip_t *za___0 , zip_source_t *src , zip_uint64_t start ,
                                zip_uint64_t len ) 
{ 
  zip_source_t *__cil_tmp5 ;

  {
  {
#line 56
  __cil_tmp5 = _zip_source_window_new(src, start, len, (zip_stat_t *)((void *)0),
                                      & za___0->error);
  }
#line 56
  return (__cil_tmp5);
}
}
#line 61 "/root/libzip/lib/zip_source_window.c"
zip_source_t *_zip_source_window_new(zip_source_t *src , zip_uint64_t start , zip_uint64_t length ,
                                     zip_stat_t *st , zip_error_t *error ) 
{ 
  struct window *ctx ;
  void *__cil_tmp7 ;
  zip_int64_t __cil_tmp8 ;
  zip_int64_t __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  zip_source_t *__cil_tmp12 ;

  {
#line 65
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 66
    zip_error_set(error, 18, 0);
    }
#line 67
    return ((zip_source_t *)((void *)0));
  } else
#line 65
  if (start + length < start) {
    {
#line 66
    zip_error_set(error, 18, 0);
    }
#line 67
    return ((zip_source_t *)((void *)0));
  }
  {
#line 70
  __cil_tmp7 = malloc(sizeof(*ctx));
#line 70
  ctx = (struct window *)__cil_tmp7;
  }
#line 70
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 71
    zip_error_set(error, 14, 0);
    }
#line 72
    return ((zip_source_t *)((void *)0));
  }
  {
#line 75
  ctx->start = start;
#line 76
  ctx->end = start + length;
#line 77
  zip_stat_init(& ctx->stat);
#line 78
  zip_error_init(& ctx->error);
#line 79
  __cil_tmp9 = zip_source_make_command_bitmap((zip_source_cmd_t )14, 7, -1);
#line 79
  __cil_tmp8 = zip_source_supports(src);
#line 79
  ctx->supports = (__cil_tmp8 & (long )((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 6)) | (1 << 7)) | (1 << 14))) | __cil_tmp9;
  }
#line 80
  if (ctx->supports & (long )(1 << 6)) {
#line 80
    tmp = 1;
  } else {
#line 80
    tmp = 0;
  }
#line 80
  ctx->needs_seek = tmp;
#line 82
  if (st) {
    {
#line 83
    __cil_tmp11 = _zip_stat_merge(& ctx->stat, st, error);
    }
#line 83
    if (__cil_tmp11 < 0) {
      {
#line 84
      free((void *)ctx);
      }
#line 85
      return ((zip_source_t *)((void *)0));
    }
  }
  {
#line 89
  __cil_tmp12 = zip_source_layered_create(src, & window_read, (void *)ctx, error);
  }
#line 89
  return (__cil_tmp12);
}
}
#line 94 "/root/libzip/lib/zip_source_window.c"
int _zip_source_set_source_archive(zip_source_t *src , zip_t *za___0 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 96
  src->source_archive = za___0;
#line 97
  __cil_tmp3 = _zip_register_source(za___0, src);
  }
#line 97
  return (__cil_tmp3);
}
}
#line 103 "/root/libzip/lib/zip_source_window.c"
void _zip_source_invalidate(zip_source_t *src ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 105
  src->source_closed = 1;
#line 107
  __cil_tmp2 = zip_error_code_zip(& src->error);
  }
#line 107
  if (__cil_tmp2 == 0) {
    {
#line 108
    zip_error_set(& src->error, 8, 0);
    }
  }
#line 111
  return;
}
}
#line 114 "/root/libzip/lib/zip_source_window.c"
static zip_int64_t window_read(zip_source_t *src , void *_ctx , void *data , zip_uint64_t len ,
                               zip_source_cmd_t cmd ) 
{ 
  struct window *ctx ;
  zip_int64_t ret ;
  zip_uint64_t n ;
  zip_uint64_t i ;
  char b[8192] ;
  zip_int64_t __cil_tmp11 ;
  unsigned long tmp ;
  int __cil_tmp14 ;
  zip_int64_t new_offset ;
  zip_int64_t __cil_tmp17 ;
  zip_stat_t *st ;
  int __cil_tmp19 ;

  {
#line 121
  ctx = (struct window *)_ctx;
#line 124
  if ((unsigned int )cmd == 2U) {
#line 124
    goto case_2;
  }
#line 127
  if ((unsigned int )cmd == 4U) {
#line 127
    goto case_4;
  }
#line 130
  if ((unsigned int )cmd == 5U) {
#line 130
    goto case_5;
  }
#line 134
  if ((unsigned int )cmd == 0U) {
#line 134
    goto case_0;
  }
#line 152
  if ((unsigned int )cmd == 1U) {
#line 152
    goto case_1;
  }
#line 181
  if ((unsigned int )cmd == 6U) {
#line 181
    goto case_6;
  }
#line 193
  if ((unsigned int )cmd == 3U) {
#line 193
    goto case_3;
  }
#line 205
  if ((unsigned int )cmd == 14U) {
#line 205
    goto case_14;
  }
#line 208
  if ((unsigned int )cmd == 7U) {
#line 208
    goto case_7;
  }
#line 211
  goto switch_default;
  case_2: 
#line 125
  return ((zip_int64_t )0);
  case_4: 
  {
#line 128
  __cil_tmp11 = zip_error_to_data(& ctx->error, data, len);
  }
#line 128
  return (__cil_tmp11);
  case_5: 
  {
#line 131
  free((void *)ctx);
  }
#line 132
  return ((zip_int64_t )0);
  case_0: 
#line 135
  if (! ctx->needs_seek) {
#line 136
    n = (zip_uint64_t )0;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;

#line 136
      if (! (n < ctx->start)) {
#line 136
        goto while_break;
      }
#line 137
      if (ctx->start - n > sizeof(b)) {
#line 137
        tmp = sizeof(b);
      } else {
#line 137
        tmp = ctx->start - n;
      }
      {
#line 137
      i = tmp;
#line 138
      ret = zip_source_read(src, (void *)(b), i);
      }
#line 138
      if (ret < 0L) {
        {
#line 139
        _zip_error_set_from_source(& ctx->error, src);
        }
#line 140
        return ((zip_int64_t )-1);
      }
#line 142
      if (ret == 0L) {
        {
#line 143
        zip_error_set(& ctx->error, 17, 0);
        }
#line 144
        return ((zip_int64_t )-1);
      }
#line 136
      n += (zip_uint64_t )ret;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 149
  ctx->offset = ctx->start;
#line 150
  return ((zip_int64_t )0);
  case_1: 
#line 153
  if (len > ctx->end - ctx->offset) {
#line 154
    len = ctx->end - ctx->offset;
  }
#line 156
  if (len == 0UL) {
#line 157
    return ((zip_int64_t )0);
  }
#line 159
  if (ctx->needs_seek) {
    {
#line 160
    __cil_tmp14 = zip_source_seek(src, (zip_int64_t )ctx->offset, 0);
    }
#line 160
    if (__cil_tmp14 < 0) {
      {
#line 161
      _zip_error_set_from_source(& ctx->error, src);
      }
#line 162
      return ((zip_int64_t )-1);
    }
  }
  {
#line 166
  ret = zip_source_read(src, data, len);
  }
#line 166
  if (ret < 0L) {
    {
#line 167
    zip_error_set(& ctx->error, 17, 0);
    }
#line 168
    return ((zip_int64_t )-1);
  }
#line 171
  ctx->offset += (zip_uint64_t )ret;
#line 173
  if (ret == 0L) {
#line 174
    if (ctx->offset < ctx->end) {
      {
#line 175
      zip_error_set(& ctx->error, 17, 0);
      }
#line 176
      return ((zip_int64_t )-1);
    }
  }
#line 179
  return (ret);
  case_6: 
  {
#line 183
  __cil_tmp17 = zip_source_seek_compute_offset(ctx->offset - ctx->start, ctx->end - ctx->start,
                                               data, len, & ctx->error);
#line 183
  new_offset = __cil_tmp17;
  }
#line 185
  if (new_offset < 0L) {
#line 186
    return ((zip_int64_t )-1);
  }
#line 189
  ctx->offset = (zip_uint64_t )new_offset + ctx->start;
#line 190
  return ((zip_int64_t )0);
  case_3: 
  {
#line 197
  st = (zip_stat_t *)data;
#line 199
  __cil_tmp19 = _zip_stat_merge(st, & ctx->stat, & ctx->error);
  }
#line 199
  if (__cil_tmp19 < 0) {
#line 200
    return ((zip_int64_t )-1);
  }
#line 202
  return ((zip_int64_t )0);
  case_14: 
#line 206
  return (ctx->supports);
  case_7: 
#line 209
  return ((zip_int64_t )(ctx->offset - ctx->start));
  switch_default: 
  {
#line 212
  zip_error_set(& ctx->error, 28, 0);
  }
#line 213
  return ((zip_int64_t )-1);

#line 217
  return (0L);
}
}
#line 219 "/root/libzip/lib/zip_source_window.c"
void _zip_deregister_source(zip_t *za___0 , zip_source_t *src ) 
{ 
  unsigned int i ;
  unsigned int __cil_tmp4 ;

  {
#line 223
  i = 0U;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;

#line 223
    if (! (i < za___0->nopen_source)) {
#line 223
      goto while_break;
    }
#line 224
    if ((unsigned long )*(za___0->open_source + i) == (unsigned long )src) {
#line 225
      *(za___0->open_source + i) = *(za___0->open_source + (za___0->nopen_source - 1U));
#line 226
      __cil_tmp4 = za___0->nopen_source;
#line 226
      (za___0->nopen_source) --;
#line 227
      goto while_break;
    }
#line 223
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 227
  return;
}
}
#line 234 "/root/libzip/lib/zip_source_window.c"
int _zip_register_source(zip_t *za___0 , zip_source_t *src ) 
{ 
  zip_source_t **open_source ;
  unsigned int n ;
  void *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;

  {
#line 238
  if (za___0->nopen_source + 1U >= za___0->nopen_source_alloc) {
    {
#line 240
    n = za___0->nopen_source_alloc + 10U;
#line 241
    __cil_tmp5 = realloc((void *)za___0->open_source, (unsigned long )n * sizeof(zip_source_t *));
#line 241
    open_source = (zip_source_t **)__cil_tmp5;
    }
#line 242
    if ((unsigned long )open_source == (unsigned long )((void *)0)) {
      {
#line 243
      zip_error_set(& za___0->error, 14, 0);
      }
#line 244
      return (-1);
    }
#line 246
    za___0->nopen_source_alloc = n;
#line 247
    za___0->open_source = open_source;
  }
#line 250
  __cil_tmp6 = za___0->nopen_source;
#line 250
  (za___0->nopen_source) ++;
#line 250
  *(za___0->open_source + __cil_tmp6) = src;
#line 252
  return (0);
}
}
#line 39 "/root/libzip/lib/zip_source_tell_write.c"
zip_int64_t zip_source_tell_write(zip_source_t *src ) 
{ 
  zip_int64_t __cil_tmp2 ;

  {
#line 41
  if (! ((unsigned int )src->write_state == 1U)) {
    {
#line 42
    zip_error_set(& src->error, 18, 0);
    }
#line 43
    return ((zip_int64_t )-1);
  }
  {
#line 46
  __cil_tmp2 = _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )13);
  }
#line 46
  return (__cil_tmp2);
}
}
#line 39 "/root/libzip/lib/zip_source_tell.c"
zip_int64_t zip_source_tell(zip_source_t *src ) 
{ 
  zip_int64_t __cil_tmp2 ;

  {
#line 41
  if (src->source_closed) {
#line 42
    return ((zip_int64_t )-1);
  }
#line 44
  if (! (src->open_count > 0U)) {
    {
#line 45
    zip_error_set(& src->error, 18, 0);
    }
#line 46
    return ((zip_int64_t )-1);
  }
  {
#line 49
  __cil_tmp2 = _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )7);
  }
#line 49
  return (__cil_tmp2);
}
}
#line 41 "/root/libzip/lib/zip_source_supports.c"
zip_int64_t zip_source_supports(zip_source_t *src ) 
{ 


  {
#line 43
  return (src->supports);
}
}
#line 48 "/root/libzip/lib/zip_source_supports.c"
zip_int64_t zip_source_make_command_bitmap(zip_source_cmd_t cmd0  , ...) 
{ 
  zip_int64_t bitmap ;
  va_list ap ;
  int cmd ;

  {
  {
#line 53
  bitmap = (zip_int64_t )(1 << (unsigned int )cmd0);
#line 57
  __builtin_va_start((__builtin_va_list )((void *)ap), cmd0);
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    cmd = 0;
#line 60
    if (cmd < 0) {
#line 61
      goto while_break;
    }
#line 63
    bitmap |= (long )(1 << cmd);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 65
  __builtin_va_end((__builtin_va_list )((void *)ap));
  }
#line 67
  return (bitmap);
}
}
#line 39 "/root/libzip/lib/zip_source_stat.c"
int zip_source_stat(zip_source_t *src , zip_stat_t *st ) 
{ 
  int __cil_tmp3 ;
  zip_int64_t __cil_tmp4 ;

  {
#line 41
  if (src->source_closed) {
#line 42
    return (-1);
  }
#line 44
  if ((unsigned long )st == (unsigned long )((void *)0)) {
    {
#line 45
    zip_error_set(& src->error, 18, 0);
    }
#line 46
    return (-1);
  }
  {
#line 49
  zip_stat_init(st);
  }
#line 51
  if ((unsigned long )src->src != (unsigned long )((void *)0)) {
    {
#line 52
    __cil_tmp3 = zip_source_stat(src->src, st);
    }
#line 52
    if (__cil_tmp3 < 0) {
      {
#line 53
      _zip_error_set_from_source(& src->error, src->src);
      }
#line 54
      return (-1);
    }
  }
  {
#line 58
  __cil_tmp4 = _zip_source_call(src, (void *)st, sizeof(*st), (zip_source_cmd_t )3);
  }
#line 58
  if (__cil_tmp4 < 0L) {
#line 59
    return (-1);
  }
#line 62
  return (0);
}
}
#line 39 "/root/libzip/lib/zip_source_seek_write.c"
int zip_source_seek_write(zip_source_t *src , zip_int64_t offset , int whence ) 
{ 
  zip_source_args_seek_t args ;
  zip_int64_t __cil_tmp5 ;
  int tmp ;

  {
#line 43
  if (! ((unsigned int )src->write_state == 1U)) {
    {
#line 44
    zip_error_set(& src->error, 18, 0);
    }
#line 45
    return (-1);
  } else
#line 43
  if (whence != 0) {
#line 43
    if (whence != 1) {
#line 43
      if (whence != 2) {
        {
#line 44
        zip_error_set(& src->error, 18, 0);
        }
#line 45
        return (-1);
      }
    }
  }
  {
#line 48
  args.offset = offset;
#line 49
  args.whence = whence;
#line 51
  __cil_tmp5 = _zip_source_call(src, (void *)(& args), sizeof(args), (zip_source_cmd_t )12);
  }
#line 51
  if (__cil_tmp5 < 0L) {
#line 51
    tmp = -1;
  } else {
#line 51
    tmp = 0;
  }
#line 51
  return (tmp);
}
}
#line 39 "/root/libzip/lib/zip_source_seek.c"
int zip_source_seek(zip_source_t *src , zip_int64_t offset , int whence ) 
{ 
  zip_source_args_seek_t args ;
  zip_int64_t __cil_tmp5 ;
  int tmp ;

  {
#line 43
  if (src->source_closed) {
#line 44
    return (-1);
  }
#line 46
  if (! (src->open_count > 0U)) {
    {
#line 47
    zip_error_set(& src->error, 18, 0);
    }
#line 48
    return (-1);
  } else
#line 46
  if (whence != 0) {
#line 46
    if (whence != 1) {
#line 46
      if (whence != 2) {
        {
#line 47
        zip_error_set(& src->error, 18, 0);
        }
#line 48
        return (-1);
      }
    }
  }
  {
#line 51
  args.offset = offset;
#line 52
  args.whence = whence;
#line 54
  __cil_tmp5 = _zip_source_call(src, (void *)(& args), sizeof(args), (zip_source_cmd_t )6);
  }
#line 54
  if (__cil_tmp5 < 0L) {
#line 54
    tmp = -1;
  } else {
#line 54
    tmp = 0;
  }
#line 54
  return (tmp);
}
}
#line 59 "/root/libzip/lib/zip_source_seek.c"
zip_int64_t zip_source_seek_compute_offset(zip_uint64_t offset , zip_uint64_t length ,
                                           void *data , zip_uint64_t data_length ,
                                           zip_error_t *error ) 
{ 
  zip_int64_t new_offset ;
  zip_source_args_seek_t *args ;
  zip_source_args_seek_t *tmp ;

  {
#line 62
  if (data_length < sizeof(zip_source_args_seek_t )) {
    {
#line 62
    zip_error_set(error, 18, 0);
#line 62
    tmp = (zip_source_args_seek_t *)((void *)0);
    }
  } else {
#line 62
    tmp = (zip_source_args_seek_t *)data;
  }
#line 62
  args = tmp;
#line 64
  if ((unsigned long )args == (unsigned long )((void *)0)) {
#line 65
    return ((zip_int64_t )-1);
  }
#line 69
  if (args->whence == 1) {
#line 69
    goto case_1;
  }
#line 73
  if (args->whence == 2) {
#line 73
    goto case_2;
  }
#line 77
  if (args->whence == 0) {
#line 77
    goto case_0;
  }
#line 81
  goto switch_default;
  case_1: 
#line 70
  new_offset = (zip_int64_t )offset + args->offset;
#line 71
  goto switch_break;
  case_2: 
#line 74
  new_offset = (zip_int64_t )length + args->offset;
#line 75
  goto switch_break;
  case_0: 
#line 78
  new_offset = args->offset;
#line 79
  goto switch_break;
  switch_default: 
  {
#line 82
  zip_error_set(error, 18, 0);
  }
#line 83
  return ((zip_int64_t )-1);
  switch_break: ;
#line 86
  if (new_offset < 0L) {
    {
#line 87
    zip_error_set(error, 18, 0);
    }
#line 88
    return ((zip_int64_t )-1);
  } else
#line 86
  if ((zip_uint64_t )new_offset > length) {
    {
#line 87
    zip_error_set(error, 18, 0);
    }
#line 88
    return ((zip_int64_t )-1);
  }
#line 91
  return (new_offset);
}
}
#line 39 "/root/libzip/lib/zip_source_rollback_write.c"
void zip_source_rollback_write(zip_source_t *src ) 
{ 


  {
#line 41
  if ((unsigned int )src->write_state != 1U) {
#line 41
    if ((unsigned int )src->write_state != 2U) {
#line 42
      return;
    }
  }
  {
#line 45
  _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )10);
#line 46
  src->write_state = (zip_source_write_state_t )0;
  }
#line 48
  return;
}
}
#line 39 "/root/libzip/lib/zip_source_remove.c"
int zip_source_remove(zip_source_t *src ) 
{ 
  int __cil_tmp2 ;
  zip_int64_t __cil_tmp3 ;

  {
#line 41
  if ((unsigned int )src->write_state == 3U) {
#line 42
    return (0);
  }
#line 45
  if (src->open_count > 0U) {
    {
#line 46
    __cil_tmp2 = zip_source_close(src);
    }
#line 46
    if (__cil_tmp2 < 0) {
#line 47
      return (-1);
    }
  }
#line 50
  if ((unsigned int )src->write_state != 0U) {
    {
#line 51
    zip_source_rollback_write(src);
    }
  }
  {
#line 54
  __cil_tmp3 = _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )15);
  }
#line 54
  if (__cil_tmp3 < 0L) {
#line 55
    return (-1);
  }
#line 58
  src->write_state = (zip_source_write_state_t )3;
#line 60
  return (0);
}
}
#line 39 "/root/libzip/lib/zip_source_read.c"
zip_int64_t zip_source_read(zip_source_t *src , void *data , zip_uint64_t len ) 
{ 
  zip_int64_t __cil_tmp4 ;

  {
#line 41
  if (src->source_closed) {
#line 42
    return ((zip_int64_t )-1);
  }
#line 44
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 44
    if (len > 0UL) {
      {
#line 45
      zip_error_set(& src->error, 18, 0);
      }
#line 46
      return ((zip_int64_t )-1);
    } else {
#line 44
      goto _L;
    }
  } else
  _L: 
#line 44
  if (! (src->open_count > 0U)) {
    {
#line 45
    zip_error_set(& src->error, 18, 0);
    }
#line 46
    return ((zip_int64_t )-1);
  } else
#line 44
  if (len > 0xffffffffffffffffUL) {
    {
#line 45
    zip_error_set(& src->error, 18, 0);
    }
#line 46
    return ((zip_int64_t )-1);
  }
  {
#line 49
  __cil_tmp4 = _zip_source_call(src, data, len, (zip_source_cmd_t )1);
  }
#line 49
  return (__cil_tmp4);
}
}
#line 51 "/root/libzip/lib/zip_source_pkware.c"
static void decrypt(struct trad_pkware *ctx , zip_uint8_t *out , zip_uint8_t *in ,
                    zip_uint64_t len , int update_only ) ;
#line 53
static int decrypt_header(zip_source_t *src , struct trad_pkware *ctx ) ;
#line 54
static zip_int64_t pkware_decrypt(zip_source_t *src , void *ud , void *data , zip_uint64_t len ,
                                  zip_source_cmd_t cmd ) ;
#line 56
static void pkware_free(struct trad_pkware *ctx ) ;
#line 60 "/root/libzip/lib/zip_source_pkware.c"
zip_source_t *zip_source_pkware(zip_t *za___0 , zip_source_t *src , zip_uint16_t em ,
                                int flags , char const   *password ) 
{ 
  struct trad_pkware *ctx ;
  zip_source_t *s2 ;
  void *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;

  {
#line 66
  if ((unsigned long )password == (unsigned long )((void *)0)) {
    {
#line 67
    zip_error_set(& za___0->error, 18, 0);
    }
#line 68
    return ((zip_source_t *)((void *)0));
  } else
#line 66
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 67
    zip_error_set(& za___0->error, 18, 0);
    }
#line 68
    return ((zip_source_t *)((void *)0));
  } else
#line 66
  if ((int )em != 1) {
    {
#line 67
    zip_error_set(& za___0->error, 18, 0);
    }
#line 68
    return ((zip_source_t *)((void *)0));
  }
#line 70
  if (flags & 1) {
    {
#line 71
    zip_error_set(& za___0->error, 24, 0);
    }
#line 72
    return ((zip_source_t *)((void *)0));
  }
  {
#line 75
  __cil_tmp8 = malloc(sizeof(*ctx));
#line 75
  ctx = (struct trad_pkware *)__cil_tmp8;
  }
#line 75
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 76
    zip_error_set(& za___0->error, 14, 0);
    }
#line 77
    return ((zip_source_t *)((void *)0));
  }
  {
#line 80
  zip_error_init(& ctx->error);
#line 82
  ctx->key[0] = (zip_uint32_t )305419896;
#line 83
  ctx->key[1] = (zip_uint32_t )591751049;
#line 84
  ctx->key[2] = (zip_uint32_t )878082192;
#line 85
  __cil_tmp9 = strlen(password);
#line 85
  decrypt(ctx, (zip_uint8_t *)((void *)0), (zip_uint8_t *)password, __cil_tmp9, 1);
#line 87
  s2 = zip_source_layered(za___0, src, & pkware_decrypt, (void *)ctx);
  }
#line 87
  if ((unsigned long )s2 == (unsigned long )((void *)0)) {
    {
#line 88
    pkware_free(ctx);
    }
#line 89
    return ((zip_source_t *)((void *)0));
  }
#line 92
  return (s2);
}
}
#line 97 "/root/libzip/lib/zip_source_pkware.c"
static void decrypt(struct trad_pkware *ctx , zip_uint8_t *out , zip_uint8_t *in ,
                    zip_uint64_t len , int update_only ) 
{ 
  zip_uint16_t tmp ;
  zip_uint64_t i ;
  Bytef b ;
  uLong __cil_tmp9 ;
  uLong __cil_tmp10 ;

  {
#line 104
  i = (zip_uint64_t )0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;

#line 104
    if (! (i < len)) {
#line 104
      goto while_break;
    }
#line 105
    b = *(in + i);
#line 107
    if (! update_only) {
#line 109
      tmp = (zip_uint16_t )(ctx->key[2] | 2U);
#line 110
      tmp = (zip_uint16_t )((zip_uint32_t )tmp * (unsigned int )((int )tmp ^ 1) >> 8);
#line 111
      b = (Bytef )((int )b ^ (int )((Bytef )tmp));
    }
#line 115
    if (out) {
#line 116
      *(out + i) = b;
    }
    {
#line 119
    __cil_tmp9 = crc32((unsigned long )ctx->key[0] ^ 4294967295UL, & b, (uInt )1);
#line 119
    ctx->key[0] = (zip_uint32_t )((unsigned long )((zip_uint32_t )__cil_tmp9) ^ 4294967295UL);
#line 120
    ctx->key[1] = (ctx->key[1] + (ctx->key[0] & 255U)) * 134775813U + 1U;
#line 121
    b = (Bytef )(ctx->key[1] >> 24);
#line 122
    __cil_tmp10 = crc32((unsigned long )ctx->key[2] ^ 4294967295UL, & b, (uInt )1);
#line 122
    ctx->key[2] = (zip_uint32_t )((unsigned long )((zip_uint32_t )__cil_tmp10) ^ 4294967295UL);
#line 104
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 108
  return;
}
}
#line 128 "/root/libzip/lib/zip_source_pkware.c"
static int decrypt_header(zip_source_t *src , struct trad_pkware *ctx ) 
{ 
  zip_uint8_t header[12] ;
  struct zip_stat st ;
  zip_int64_t n ;
  unsigned short dostime ;
  unsigned short dosdate ;
  int __cil_tmp9 ;

  {
  {
#line 135
  n = zip_source_read(src, (void *)(header), (zip_uint64_t )12);
  }
#line 135
  if (n < 0L) {
    {
#line 136
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 137
    return (-1);
  }
#line 140
  if (n != 12L) {
    {
#line 141
    zip_error_set(& ctx->error, 17, 0);
    }
#line 142
    return (-1);
  }
  {
#line 145
  decrypt(ctx, header, header, (zip_uint64_t )12, 0);
#line 147
  __cil_tmp9 = zip_source_stat(src, & st);
  }
#line 147
  if (__cil_tmp9 < 0) {
#line 149
    return (0);
  }
  {
#line 152
  _zip_u2d_time(st.mtime, & dostime, & dosdate);
  }
#line 154
  if ((unsigned int )header[11] != st.crc >> 24) {
#line 154
    if ((int )header[11] != (int )dostime >> 8) {
      {
#line 155
      zip_error_set(& ctx->error, 27, 0);
      }
#line 156
      return (-1);
    }
  }
#line 159
  return (0);
}
}
#line 164 "/root/libzip/lib/zip_source_pkware.c"
static zip_int64_t pkware_decrypt(zip_source_t *src , void *ud , void *data , zip_uint64_t len ,
                                  zip_source_cmd_t cmd ) 
{ 
  struct trad_pkware *ctx ;
  zip_int64_t n ;
  int __cil_tmp8 ;
  zip_stat_t *st ;
  zip_int64_t __cil_tmp11 ;
  zip_int64_t __cil_tmp12 ;

  {
#line 170
  ctx = (struct trad_pkware *)ud;
#line 173
  if ((unsigned int )cmd == 0U) {
#line 173
    goto case_0;
  }
#line 178
  if ((unsigned int )cmd == 1U) {
#line 178
    goto case_1;
  }
#line 187
  if ((unsigned int )cmd == 2U) {
#line 187
    goto case_2;
  }
#line 190
  if ((unsigned int )cmd == 3U) {
#line 190
    goto case_3;
  }
#line 205
  if ((unsigned int )cmd == 14U) {
#line 205
    goto case_14;
  }
#line 208
  if ((unsigned int )cmd == 4U) {
#line 208
    goto case_4;
  }
#line 211
  if ((unsigned int )cmd == 5U) {
#line 211
    goto case_5;
  }
#line 215
  goto switch_default;
  case_0: 
  {
#line 174
  __cil_tmp8 = decrypt_header(src, ctx);
  }
#line 174
  if (__cil_tmp8 < 0) {
#line 175
    return ((zip_int64_t )-1);
  }
#line 176
  return ((zip_int64_t )0);
  case_1: 
  {
#line 179
  n = zip_source_read(src, data, len);
  }
#line 179
  if (n < 0L) {
    {
#line 180
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 181
    return ((zip_int64_t )-1);
  }
  {
#line 184
  decrypt((struct trad_pkware *)ud, (zip_uint8_t *)data, (zip_uint8_t *)data, (zip_uint64_t )n,
          0);
  }
#line 185
  return (n);
  case_2: 
#line 188
  return ((zip_int64_t )0);
  case_3: 
#line 194
  st = (zip_stat_t *)data;
#line 196
  st->encryption_method = (zip_uint16_t )0;
#line 197
  st->valid |= 128UL;
#line 199
  if (st->valid & 8UL) {
#line 200
    st->comp_size -= 12UL;
  }
#line 202
  return ((zip_int64_t )0);
  case_14: 
  {
#line 206
  __cil_tmp11 = zip_source_make_command_bitmap((zip_source_cmd_t )0, 1, 2, 3, 4, 5,
                                               -1);
  }
#line 206
  return (__cil_tmp11);
  case_4: 
  {
#line 209
  __cil_tmp12 = zip_error_to_data(& ctx->error, data, len);
  }
#line 209
  return (__cil_tmp12);
  case_5: 
  {
#line 212
  pkware_free(ctx);
  }
#line 213
  return ((zip_int64_t )0);
  switch_default: 
  {
#line 216
  zip_error_set(& ctx->error, 18, 0);
  }
#line 217
  return ((zip_int64_t )-1);

#line 221
  return (0L);
}
}
#line 223 "/root/libzip/lib/zip_source_pkware.c"
static void pkware_free(struct trad_pkware *ctx ) 
{ 


  {
  {
#line 225
  free((void *)ctx);
  }
#line 227
  return;
}
}
#line 38 "/root/libzip/lib/zip_source_open.c"
int zip_source_open(zip_source_t *src ) 
{ 
  zip_int64_t __cil_tmp2 ;
  int __cil_tmp3 ;
  zip_int64_t __cil_tmp4 ;

  {
#line 40
  if (src->source_closed) {
#line 41
    return (-1);
  }
#line 43
  if ((unsigned int )src->write_state == 3U) {
    {
#line 44
    zip_error_set(& src->error, 23, 0);
    }
#line 45
    return (-1);
  }
#line 48
  if (src->open_count > 0U) {
    {
#line 49
    __cil_tmp2 = zip_source_supports(src);
    }
#line 49
    if ((__cil_tmp2 & (long )(1 << 6)) == 0L) {
      {
#line 50
      zip_error_set(& src->error, 29, 0);
      }
#line 51
      return (-1);
    }
  } else {
#line 55
    if ((unsigned long )src->src != (unsigned long )((void *)0)) {
      {
#line 56
      __cil_tmp3 = zip_source_open(src->src);
      }
#line 56
      if (__cil_tmp3 < 0) {
        {
#line 57
        _zip_error_set_from_source(& src->error, src->src);
        }
#line 58
        return (-1);
      }
    }
    {
#line 62
    __cil_tmp4 = _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )0);
    }
#line 62
    if (__cil_tmp4 < 0L) {
#line 63
      if ((unsigned long )src->src != (unsigned long )((void *)0)) {
        {
#line 64
        zip_source_close(src->src);
        }
      }
#line 66
      return (-1);
    }
  }
#line 70
  (src->open_count) ++;
#line 72
  return (0);
}
}
#line 41 "/root/libzip/lib/zip_source_layered.c"
zip_source_t *zip_source_layered(zip_t *za___0 , zip_source_t *src , zip_int64_t (*cb)(zip_source_t * ,
                                                                                       void * ,
                                                                                       void * ,
                                                                                       zip_uint64_t  ,
                                                                                       enum zip_source_cmd  ) ,
                                 void *ud ) 
{ 
  zip_source_t *__cil_tmp5 ;

  {
#line 43
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 44
    return ((zip_source_t *)((void *)0));
  }
  {
#line 46
  __cil_tmp5 = zip_source_layered_create(src, cb, ud, & za___0->error);
  }
#line 46
  return (__cil_tmp5);
}
}
#line 51 "/root/libzip/lib/zip_source_layered.c"
zip_source_t *zip_source_layered_create(zip_source_t *src , zip_int64_t (*cb)(zip_source_t * ,
                                                                              void * ,
                                                                              void * ,
                                                                              zip_uint64_t  ,
                                                                              enum zip_source_cmd  ) ,
                                        void *ud , zip_error_t *error ) 
{ 
  zip_source_t *zs ;

  {
  {
#line 55
  zs = _zip_source_new(error);
  }
#line 55
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
#line 56
    return ((zip_source_t *)((void *)0));
  }
  {
#line 58
  zip_source_keep(src);
#line 59
  zs->src = src;
#line 60
  zs->cb.l = cb;
#line 61
  zs->ud = ud;
#line 63
  zs->supports = (*cb)(src, ud, (void *)0, (zip_uint64_t )0, (enum zip_source_cmd )14);
  }
#line 64
  if (zs->supports < 0L) {
#line 65
    zs->supports = (zip_int64_t )(((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5));
  }
#line 68
  return (zs);
}
}
#line 39 "/root/libzip/lib/zip_source_is_deleted.c"
int zip_source_is_deleted(zip_source_t *src ) 
{ 


  {
#line 41
  return ((unsigned int )src->write_state == 3U);
}
}
#line 41 "/root/libzip/lib/zip_source_function.c"
zip_source_t *zip_source_function(zip_t *za___0 , zip_int64_t (*zcb)(void * , void * ,
                                                                     zip_uint64_t  ,
                                                                     zip_source_cmd_t  ) ,
                                  void *ud ) 
{ 
  zip_source_t *__cil_tmp4 ;

  {
#line 43
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 44
    return ((zip_source_t *)((void *)0));
  }
  {
#line 47
  __cil_tmp4 = zip_source_function_create(zcb, ud, & za___0->error);
  }
#line 47
  return (__cil_tmp4);
}
}
#line 52 "/root/libzip/lib/zip_source_function.c"
zip_source_t *zip_source_function_create(zip_int64_t (*zcb)(void * , void * , zip_uint64_t  ,
                                                            zip_source_cmd_t  ) ,
                                         void *ud , zip_error_t *error ) 
{ 
  zip_source_t *zs ;

  {
  {
#line 56
  zs = _zip_source_new(error);
  }
#line 56
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
#line 57
    return ((zip_source_t *)((void *)0));
  }
  {
#line 59
  zs->cb.f = zcb;
#line 60
  zs->ud = ud;
#line 62
  zs->supports = (*zcb)(ud, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )14);
  }
#line 63
  if (zs->supports < 0L) {
#line 64
    zs->supports = (zip_int64_t )(((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5));
  }
#line 67
  return (zs);
}
}
#line 72 "/root/libzip/lib/zip_source_function.c"
void zip_source_keep(zip_source_t *src ) 
{ 


  {
#line 74
  (src->refcount) ++;
#line 75
  return;
}
}
#line 79 "/root/libzip/lib/zip_source_function.c"
zip_source_t *_zip_source_new(zip_error_t *error ) 
{ 
  zip_source_t *src ;
  void *__cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = malloc(sizeof(*src));
#line 83
  src = (zip_source_t *)__cil_tmp3;
  }
#line 83
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 84
    zip_error_set(error, 14, 0);
    }
#line 85
    return ((zip_source_t *)((void *)0));
  }
  {
#line 88
  src->src = (zip_source_t *)((void *)0);
#line 89
  src->cb.f = (zip_int64_t (*)(void * , void * , zip_uint64_t  , zip_source_cmd_t  ))((void *)0);
#line 90
  src->ud = (void *)0;
#line 91
  src->open_count = 0U;
#line 92
  src->write_state = (zip_source_write_state_t )0;
#line 93
  src->source_closed = 0;
#line 94
  src->source_archive = (zip_t *)((void *)0);
#line 95
  src->refcount = 1U;
#line 96
  zip_error_init(& src->error);
  }
#line 98
  return (src);
}
}
#line 41 "/root/libzip/lib/zip_source_free.c"
void zip_source_free(zip_source_t *src ) 
{ 
  unsigned int __cil_tmp2 ;

  {
#line 43
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 44
    return;
  }
#line 46
  if (src->refcount > 0U) {
#line 47
    __cil_tmp2 = src->refcount;
#line 47
    (src->refcount) --;
  }
#line 49
  if (src->refcount > 0U) {
#line 50
    return;
  }
#line 53
  if (src->open_count > 0U) {
    {
#line 54
    src->open_count = 1U;
#line 55
    zip_source_close(src);
    }
  }
#line 57
  if ((unsigned int )src->write_state == 1U) {
    {
#line 58
    zip_source_rollback_write(src);
    }
  }
#line 61
  if (src->source_archive) {
#line 61
    if (! src->source_closed) {
      {
#line 62
      _zip_deregister_source(src->source_archive, src);
      }
    }
  }
  {
#line 65
  _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )5);
  }
#line 67
  if (src->src) {
    {
#line 68
    zip_source_free(src->src);
    }
  }
  {
#line 71
  free((void *)src);
  }
#line 73
  return;
}
}
#line 208 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) stat)(char const   *__path ,
                                                                                          struct stat *__statbuf ) ;
#line 213
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
#line 237
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstatat)(int __fd ,
                                                                                             char const   *__filename ,
                                                                                             struct stat *__statbuf ,
                                                                                             int __flag ) ;
#line 262
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) lstat)(char const   *__path ,
                                                                                           struct stat *__statbuf ) ;
#line 283
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode ) ;
#line 311
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 335
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
#line 342
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknodat)(int __fd ,
                                                                                             char const   *__path ,
                                                                                             __mode_t __mode ,
                                                                                             __dev_t __dev ) ;
#line 398
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
#line 400
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf ) ;
#line 402
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf ) ;
#line 404
extern  __attribute__((__nothrow__)) int __fxstatat(int __ver , int __fildes , char const   *__filename ,
                                                    struct stat *__stat_buf , int __flag ) ;
#line 441
extern  __attribute__((__nothrow__)) int __xmknod(int __ver , char const   *__path ,
                                                  __mode_t __mode , __dev_t *__dev ) ;
#line 444
extern  __attribute__((__nothrow__)) int __xmknodat(int __ver , int __fd , char const   *__path ,
                                                    __mode_t __mode , __dev_t *__dev ) ;
#line 452
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) stat)(char const   *__path ,
                                                                                          struct stat *__statbuf ) ;
#line 452 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) stat)(char const   *__path ,
                                                            struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 454
  __cil_tmp3 = __xstat(1, __path, __statbuf);
  }
#line 454
  return (__cil_tmp3);
}
}
#line 459
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) lstat)(char const   *__path ,
                                                                                           struct stat *__statbuf ) ;
#line 459 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) lstat)(char const   *__path ,
                                                             struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 461
  __cil_tmp3 = __lxstat(1, __path, __statbuf);
  }
#line 461
  return (__cil_tmp3);
}
}
#line 466
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
#line 466 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 468
  __cil_tmp3 = __fxstat(1, __fd, __statbuf);
  }
#line 468
  return (__cil_tmp3);
}
}
#line 473
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstatat)(int __fd ,
                                                                                             char const   *__filename ,
                                                                                             struct stat *__statbuf ,
                                                                                             int __flag ) ;
#line 473 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) fstatat)(int __fd , char const   *__filename ,
                                                               struct stat *__statbuf ,
                                                               int __flag ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 476
  __cil_tmp5 = __fxstatat(1, __fd, __filename, __statbuf, __flag);
  }
#line 476
  return (__cil_tmp5);
}
}
#line 482
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
#line 482 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) mknod)(char const   *__path ,
                                                             __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 484
  __cil_tmp4 = __xmknod(0, __path, __mode, & __dev);
  }
#line 484
  return (__cil_tmp4);
}
}
#line 490
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknodat)(int __fd ,
                                                                                             char const   *__path ,
                                                                                             __mode_t __mode ,
                                                                                             __dev_t __dev ) ;
#line 490 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) mknodat)(int __fd , char const   *__path ,
                                                               __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 493
  __cil_tmp5 = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
#line 493
  return (__cil_tmp5);
}
}
#line 84 "/root/libzip/lib/zip_source_filep.c"
static zip_int64_t read_file(void *state , void *data , zip_uint64_t len , zip_source_cmd_t cmd ) ;
#line 85
static int create_temp_output(struct read_file *ctx ) ;
#line 86
static int _zip_fseek_u(FILE *f , zip_uint64_t offset , int whence , zip_error_t *error ) ;
#line 87
static int _zip_fseek(FILE *f , zip_int64_t offset , int whence , zip_error_t *error ) ;
#line 91 "/root/libzip/lib/zip_source_filep.c"
zip_source_t *zip_source_filep(zip_t *za___0 , FILE *file , zip_uint64_t start , zip_int64_t len ) 
{ 
  zip_source_t *__cil_tmp5 ;

  {
#line 93
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 94
    return ((zip_source_t *)((void *)0));
  }
  {
#line 96
  __cil_tmp5 = zip_source_filep_create(file, start, len, & za___0->error);
  }
#line 96
  return (__cil_tmp5);
}
}
#line 101 "/root/libzip/lib/zip_source_filep.c"
zip_source_t *zip_source_filep_create(FILE *file , zip_uint64_t start , zip_int64_t length ,
                                      zip_error_t *error ) 
{ 
  zip_source_t *__cil_tmp5 ;

  {
#line 103
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 104
    zip_error_set(error, 18, 0);
    }
#line 105
    return ((zip_source_t *)((void *)0));
  } else
#line 103
  if (length < -1L) {
    {
#line 104
    zip_error_set(error, 18, 0);
    }
#line 105
    return ((zip_source_t *)((void *)0));
  }
  {
#line 108
  __cil_tmp5 = _zip_source_file_or_p((char const   *)((void *)0), file, start, length,
                                     (zip_stat_t *)((void *)0), error);
  }
#line 108
  return (__cil_tmp5);
}
}
#line 113 "/root/libzip/lib/zip_source_filep.c"
zip_source_t *_zip_source_file_or_p(char const   *fname , FILE *file , zip_uint64_t start ,
                                    zip_int64_t len , zip_stat_t *st , zip_error_t *error ) 
{ 
  struct read_file *ctx ;
  zip_source_t *zs ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;
  char *tmp ;
  char *__cil_tmp13 ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  zip_int64_t __cil_tmp16 ;
  struct stat sb ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 118
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 118
    if ((unsigned long )fname == (unsigned long )((void *)0)) {
      {
#line 119
      zip_error_set(error, 18, 0);
      }
#line 120
      return ((zip_source_t *)((void *)0));
    }
  }
  {
#line 123
  __cil_tmp9 = malloc(sizeof(struct read_file ));
#line 123
  ctx = (struct read_file *)__cil_tmp9;
  }
#line 123
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 124
    zip_error_set(error, 14, 0);
    }
#line 125
    return ((zip_source_t *)((void *)0));
  }
#line 128
  ctx->fname = (char *)((void *)0);
#line 129
  if (fname) {
#line 130
    __cil_tmp10 = 0;
#line 130
    if (__cil_tmp10) {
#line 130
      if ((size_t )((void const   *)(fname + 1)) - (size_t )((void const   *)fname) == 1UL) {
#line 130
        if ((int )*(fname + 0) == 0) {
          {
#line 130
          __cil_tmp11 = calloc((size_t )1, (size_t )1);
#line 130
          tmp = (char *)__cil_tmp11;
          }
        } else {
#line 130
          tmp = (char *)0;
        }
#line 130
        tmp___0 = (int )tmp;
      } else {
        {
#line 130
        __cil_tmp13 = __strdup(fname);
#line 130
        tmp___0 = (int )__cil_tmp13;
        }
      }
    } else {
      {
#line 130
      __cil_tmp13 = __strdup(fname);
#line 130
      tmp___0 = (int )__cil_tmp13;
      }
    }
#line 130
    ctx->fname = (char *)tmp___0;
#line 130
    if ((unsigned long )ctx->fname == (unsigned long )((void *)0)) {
      {
#line 131
      zip_error_set(error, 14, 0);
#line 132
      free((void *)ctx);
      }
#line 133
      return ((zip_source_t *)((void *)0));
    }
  }
#line 136
  ctx->f = file;
#line 137
  ctx->start = start;
#line 138
  if (len < 0L) {
#line 138
    tmp___1 = 0UL;
  } else {
#line 138
    tmp___1 = start + (zip_uint64_t )len;
  }
#line 138
  ctx->end = tmp___1;
#line 139
  if (st) {
    {
#line 140
    memcpy((void *)(& ctx->st), (void const   *)st, sizeof(ctx->st));
#line 141
    ctx->st.name = (char const   *)((void *)0);
#line 142
    ctx->st.valid &= 4294967294UL;
    }
  } else {
    {
#line 145
    zip_stat_init(& ctx->st);
    }
  }
  {
#line 148
  ctx->tmpname = (char *)((void *)0);
#line 149
  ctx->fout = (FILE *)((void *)0);
#line 151
  zip_error_init(& ctx->error);
#line 153
  __cil_tmp16 = zip_source_make_command_bitmap((zip_source_cmd_t )14, 7, -1);
#line 153
  ctx->supports = (long )(((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | __cil_tmp16;
  }
#line 154
  if (ctx->fname) {
    {
#line 157
    __cil_tmp18 = stat((char const   *)ctx->fname, & sb);
    }
#line 157
    if (__cil_tmp18 < 0) {
#line 158
      ctx->supports = (zip_int64_t )(((((((((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 6)) | (1 << 7)) | (1 << 14)) | (1 << 8)) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12)) | (1 << 13)) | (1 << 15));
    } else
#line 157
    if ((sb.st_mode & 61440U) == 32768U) {
#line 158
      ctx->supports = (zip_int64_t )(((((((((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 6)) | (1 << 7)) | (1 << 14)) | (1 << 8)) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12)) | (1 << 13)) | (1 << 15));
    }
  } else {
    {
#line 161
    __cil_tmp19 = fseeko(ctx->f, (__off_t )0, 1);
    }
#line 161
    if (__cil_tmp19 == 0) {
#line 162
      ctx->supports = (zip_int64_t )((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 6)) | (1 << 7)) | (1 << 14));
    }
  }
  {
#line 165
  zs = zip_source_function_create(& read_file, (void *)ctx, error);
  }
#line 165
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
    {
#line 166
    free((void *)ctx->fname);
#line 167
    free((void *)ctx);
    }
#line 168
    return ((zip_source_t *)((void *)0));
  }
#line 171
  return (zs);
}
}
#line 176 "/root/libzip/lib/zip_source_filep.c"
static int create_temp_output(struct read_file *ctx ) 
{ 
  char *temp ;
  int tfd ;
  mode_t mask ;
  FILE *tfp ;
  unsigned long __cil_tmp6 ;
  void *__cil_tmp7 ;
  int *__cil_tmp10 ;
  int *__cil_tmp12 ;

  {
  {
#line 183
  __cil_tmp6 = strlen((char const   *)ctx->fname);
#line 183
  __cil_tmp7 = malloc(__cil_tmp6 + 8UL);
#line 183
  temp = (char *)__cil_tmp7;
  }
#line 183
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 184
    zip_error_set(& ctx->error, 14, 0);
    }
#line 185
    return (-1);
  }
  {
#line 187
  sprintf(temp, "%s.XXXXXX", ctx->fname);
#line 189
  mask = umask((__mode_t )((64 | (448 >> 3)) | ((448 >> 3) >> 3)));
#line 190
  tfd = mkstemp(temp);
  }
#line 190
  if (tfd == -1) {
    {
#line 191
    __cil_tmp10 = __errno_location();
#line 191
    zip_error_set(& ctx->error, 12, *__cil_tmp10);
#line 192
    umask(mask);
#line 193
    free((void *)temp);
    }
#line 194
    return (-1);
  }
  {
#line 196
  umask(mask);
#line 198
  tfp = fdopen(tfd, "r+bJ8V");
  }
#line 198
  if ((unsigned long )tfp == (unsigned long )((void *)0)) {
    {
#line 199
    __cil_tmp12 = __errno_location();
#line 199
    zip_error_set(& ctx->error, 12, *__cil_tmp12);
#line 200
    close(tfd);
#line 201
    remove((char const   *)temp);
#line 202
    free((void *)temp);
    }
#line 203
    return (-1);
  }
#line 214
  ctx->fout = tfp;
#line 215
  ctx->tmpname = temp;
#line 217
  return (0);
}
}
#line 222 "/root/libzip/lib/zip_source_filep.c"
static zip_int64_t read_file(void *state , void *data , zip_uint64_t len , zip_source_cmd_t cmd ) 
{ 
  struct read_file *ctx ;
  char *buf ;
  zip_uint64_t n ;
  size_t i ;
  int __cil_tmp9 ;
  mode_t mask ;
  int __cil_tmp11 ;
  int *__cil_tmp12 ;
  int __cil_tmp13 ;
  int *__cil_tmp14 ;
  zip_int64_t __cil_tmp16 ;
  int *__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp21 ;
  int *__cil_tmp22 ;
  int __cil_tmp23 ;
  int *__cil_tmp24 ;
  zip_int64_t new_current ;
  int need_seek ;
  zip_source_args_seek_t *args ;
  zip_source_args_seek_t *tmp ;
  int __cil_tmp29 ;
  int *__cil_tmp31 ;
  int __cil_tmp32 ;
  zip_source_args_seek_t *args___0 ;
  zip_source_args_seek_t *tmp___0 ;
  int __cil_tmp35 ;
  zip_stat_t *st ;
  struct stat fst ;
  int err ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int *__cil_tmp42 ;
  off_t ret ;
  __off_t __cil_tmp44 ;
  int *__cil_tmp45 ;
  size_t ret___0 ;
  int __cil_tmp48 ;
  int *__cil_tmp49 ;

  {
#line 229
  ctx = (struct read_file *)state;
#line 230
  buf = (char *)data;
#line 233
  if ((unsigned int )cmd == 8U) {
#line 233
    goto case_8;
  }
#line 240
  if ((unsigned int )cmd == 9U) {
#line 240
    goto case_9;
  }
#line 261
  if ((unsigned int )cmd == 2U) {
#line 261
    goto case_2;
  }
#line 268
  if ((unsigned int )cmd == 4U) {
#line 268
    goto case_4;
  }
#line 271
  if ((unsigned int )cmd == 5U) {
#line 271
    goto case_5;
  }
#line 279
  if ((unsigned int )cmd == 0U) {
#line 279
    goto case_0;
  }
#line 295
  if ((unsigned int )cmd == 1U) {
#line 295
    goto case_1;
  }
#line 319
  if ((unsigned int )cmd == 15U) {
#line 319
    goto case_15;
  }
#line 326
  if ((unsigned int )cmd == 10U) {
#line 326
    goto case_10;
  }
#line 336
  if ((unsigned int )cmd == 6U) {
#line 336
    goto case_6;
  }
#line 347
  if ((unsigned int )cmd == 0U) {
#line 347
    goto case_0___0;
  }
#line 351
  if ((unsigned int )cmd == 2U) {
#line 351
    goto case_2___0;
  }
#line 366
  if ((unsigned int )cmd == 1U) {
#line 366
    goto case_1___0;
  }
#line 390
  if ((unsigned int )cmd == 12U) {
#line 390
    goto case_12;
  }
#line 404
  if ((unsigned int )cmd == 3U) {
#line 404
    goto case_3;
  }
#line 442
  if ((unsigned int )cmd == 14U) {
#line 442
    goto case_14;
  }
#line 445
  if ((unsigned int )cmd == 7U) {
#line 445
    goto case_7;
  }
#line 448
  if ((unsigned int )cmd == 13U) {
#line 448
    goto case_13;
  }
#line 459
  if ((unsigned int )cmd == 11U) {
#line 459
    goto case_11;
  }
#line 473
  goto switch_default___0;
  case_8: 
#line 234
  if ((unsigned long )ctx->fname == (unsigned long )((void *)0)) {
    {
#line 235
    zip_error_set(& ctx->error, 28, 0);
    }
#line 236
    return ((zip_int64_t )-1);
  }
  {
#line 238
  __cil_tmp9 = create_temp_output(ctx);
  }
#line 238
  return ((zip_int64_t )__cil_tmp9);
  case_9: 
  {
#line 243
  __cil_tmp11 = fclose(ctx->fout);
  }
#line 243
  if (__cil_tmp11 < 0) {
    {
#line 244
    ctx->fout = (FILE *)((void *)0);
#line 245
    __cil_tmp12 = __errno_location();
#line 245
    zip_error_set(& ctx->error, 6, *__cil_tmp12);
    }
  }
  {
#line 247
  ctx->fout = (FILE *)((void *)0);
#line 248
  __cil_tmp13 = rename((char const   *)ctx->tmpname, (char const   *)ctx->fname);
  }
#line 248
  if (__cil_tmp13 < 0) {
    {
#line 249
    __cil_tmp14 = __errno_location();
#line 249
    zip_error_set(& ctx->error, 2, *__cil_tmp14);
    }
#line 250
    return ((zip_int64_t )-1);
  }
  {
#line 252
  mask = umask((__mode_t )18);
#line 253
  umask(mask);
#line 255
  chmod((char const   *)ctx->fname, 438U & ~ mask);
#line 256
  free((void *)ctx->tmpname);
#line 257
  ctx->tmpname = (char *)((void *)0);
  }
#line 258
  return ((zip_int64_t )0);
  case_2: 
#line 262
  if (ctx->fname) {
    {
#line 263
    fclose(ctx->f);
#line 264
    ctx->f = (FILE *)((void *)0);
    }
  }
#line 266
  return ((zip_int64_t )0);
  case_4: 
  {
#line 269
  __cil_tmp16 = zip_error_to_data(& ctx->error, data, len);
  }
#line 269
  return (__cil_tmp16);
  case_5: 
  {
#line 272
  free((void *)ctx->fname);
#line 273
  free((void *)ctx->tmpname);
  }
#line 274
  if (ctx->f) {
    {
#line 275
    fclose(ctx->f);
    }
  }
  {
#line 276
  free((void *)ctx);
  }
#line 277
  return ((zip_int64_t )0);
  case_0: 
#line 280
  if (ctx->fname) {
    {
#line 281
    ctx->f = fopen((char const   *)ctx->fname, "rb\211J8V");
    }
#line 281
    if ((unsigned long )ctx->f == (unsigned long )((void *)0)) {
      {
#line 282
      __cil_tmp18 = __errno_location();
#line 282
      zip_error_set(& ctx->error, 11, *__cil_tmp18);
      }
#line 283
      return ((zip_int64_t )-1);
    }
  }
#line 287
  if (ctx->start > 0UL) {
    {
#line 288
    __cil_tmp19 = _zip_fseek_u(ctx->f, ctx->start, 0, & ctx->error);
    }
#line 288
    if (__cil_tmp19 < 0) {
#line 289
      return ((zip_int64_t )-1);
    }
  }
#line 292
  ctx->current = ctx->start;
#line 293
  return ((zip_int64_t )0);
  case_1: 
#line 296
  if (ctx->end > 0UL) {
#line 297
    n = ctx->end - ctx->current;
#line 298
    if (n > len) {
#line 299
      n = len;
    }
  } else {
#line 303
    n = len;
  }
#line 306
  if (n > 0xffffffffffffffffUL) {
#line 307
    n = 0xffffffffffffffffUL;
  }
  {
#line 309
  i = fread((void *)buf, 1UL, n, ctx->f);
  }
#line 309
  if (i == 0UL) {
    {
#line 310
    __cil_tmp21 = ferror(ctx->f);
    }
#line 310
    if (__cil_tmp21) {
      {
#line 311
      __cil_tmp22 = __errno_location();
#line 311
      zip_error_set(& ctx->error, 5, *__cil_tmp22);
      }
#line 312
      return ((zip_int64_t )-1);
    }
  }
#line 315
  ctx->current += i;
#line 317
  return ((zip_int64_t )i);
  case_15: 
  {
#line 320
  __cil_tmp23 = remove((char const   *)ctx->fname);
  }
#line 320
  if (__cil_tmp23 < 0) {
    {
#line 321
    __cil_tmp24 = __errno_location();
#line 321
    zip_error_set(& ctx->error, 22, *__cil_tmp24);
    }
#line 322
    return ((zip_int64_t )-1);
  }
#line 324
  return ((zip_int64_t )0);
  case_10: 
#line 327
  if (ctx->fout) {
    {
#line 328
    fclose(ctx->fout);
#line 329
    ctx->fout = (FILE *)((void *)0);
    }
  }
  {
#line 331
  remove((char const   *)ctx->tmpname);
#line 332
  free((void *)ctx->tmpname);
#line 333
  ctx->tmpname = (char *)((void *)0);
  }
#line 334
  return ((zip_int64_t )0);
  case_6: 
#line 339
  if (len < sizeof(zip_source_args_seek_t )) {
    {
#line 339
    zip_error_set(& ctx->error, 18, 0);
#line 339
    tmp = (zip_source_args_seek_t *)((void *)0);
    }
  } else {
#line 339
    tmp = (zip_source_args_seek_t *)data;
  }
#line 339
  args = tmp;
#line 341
  if ((unsigned long )args == (unsigned long )((void *)0)) {
#line 342
    return ((zip_int64_t )-1);
  }
#line 344
  need_seek = 1;
#line 347
  if (args->whence == 0) {
#line 347
    goto case_0___0;
  }
#line 351
  if (args->whence == 2) {
#line 351
    goto case_2___0;
  }
#line 366
  if (args->whence == 1) {
#line 366
    goto case_1___0;
  }
#line 370
  goto switch_default;
  case_0___0: 
#line 348
  new_current = args->offset;
#line 349
  goto switch_break___0;
  case_2___0: 
#line 352
  if (ctx->end == 0UL) {
    {
#line 353
    __cil_tmp29 = _zip_fseek(ctx->f, args->offset, 2, & ctx->error);
    }
#line 353
    if (__cil_tmp29 < 0) {
#line 354
      return ((zip_int64_t )-1);
    }
    {
#line 356
    new_current = ftello(ctx->f);
    }
#line 356
    if (new_current < 0L) {
      {
#line 357
      __cil_tmp31 = __errno_location();
#line 357
      zip_error_set(& ctx->error, 4, *__cil_tmp31);
      }
#line 358
      return ((zip_int64_t )-1);
    }
#line 360
    need_seek = 0;
  } else {
#line 363
    new_current = (zip_int64_t )ctx->end + args->offset;
  }
#line 365
  goto switch_break___0;
  case_1___0: 
#line 367
  new_current = (zip_int64_t )ctx->current + args->offset;
#line 368
  goto switch_break___0;
  switch_default: 
  {
#line 371
  zip_error_set(& ctx->error, 18, 0);
  }
#line 372
  return ((zip_int64_t )-1);
  switch_break___0: ;
#line 375
  if (new_current < 0L) {
    {
#line 376
    zip_error_set(& ctx->error, 18, 0);
    }
#line 377
    return ((zip_int64_t )-1);
  } else
#line 375
  if ((zip_uint64_t )new_current < ctx->start) {
    {
#line 376
    zip_error_set(& ctx->error, 18, 0);
    }
#line 377
    return ((zip_int64_t )-1);
  } else
#line 375
  if (ctx->end != 0UL) {
#line 375
    if ((zip_uint64_t )new_current > ctx->end) {
      {
#line 376
      zip_error_set(& ctx->error, 18, 0);
      }
#line 377
      return ((zip_int64_t )-1);
    }
  }
#line 380
  ctx->current = (zip_uint64_t )new_current;
#line 382
  if (need_seek) {
    {
#line 383
    __cil_tmp32 = _zip_fseek_u(ctx->f, ctx->current, 0, & ctx->error);
    }
#line 383
    if (__cil_tmp32 < 0) {
#line 384
      return ((zip_int64_t )-1);
    }
  }
#line 387
  return ((zip_int64_t )0);
  case_12: 
#line 393
  if (len < sizeof(zip_source_args_seek_t )) {
    {
#line 393
    zip_error_set(& ctx->error, 18, 0);
#line 393
    tmp___0 = (zip_source_args_seek_t *)((void *)0);
    }
  } else {
#line 393
    tmp___0 = (zip_source_args_seek_t *)data;
  }
#line 393
  args___0 = tmp___0;
#line 394
  if ((unsigned long )args___0 == (unsigned long )((void *)0)) {
#line 395
    return ((zip_int64_t )-1);
  }
  {
#line 398
  __cil_tmp35 = _zip_fseek(ctx->fout, args___0->offset, args___0->whence, & ctx->error);
  }
#line 398
  if (__cil_tmp35 < 0) {
#line 399
    return ((zip_int64_t )-1);
  }
#line 401
  return ((zip_int64_t )0);
  case_3: 
#line 405
  if (len < sizeof(ctx->st)) {
#line 406
    return ((zip_int64_t )-1);
  }
#line 408
  if (ctx->st.valid != 0UL) {
    {
#line 409
    memcpy(data, (void const   *)(& ctx->st), sizeof(ctx->st));
    }
  } else {
#line 415
    if (ctx->f) {
      {
#line 416
      __cil_tmp39 = fileno(ctx->f);
#line 416
      __cil_tmp40 = fstat(__cil_tmp39, & fst);
#line 416
      err = __cil_tmp40;
      }
    } else {
      {
#line 418
      err = stat((char const   *)ctx->fname, & fst);
      }
    }
#line 420
    if (err != 0) {
      {
#line 421
      __cil_tmp42 = __errno_location();
#line 421
      zip_error_set(& ctx->error, 5, *__cil_tmp42);
      }
#line 422
      return ((zip_int64_t )-1);
    }
    {
#line 425
    st = (zip_stat_t *)data;
#line 427
    zip_stat_init(st);
#line 428
    st->mtime = fst.st_mtim.tv_sec;
#line 429
    st->valid |= 16UL;
    }
#line 430
    if (ctx->end != 0UL) {
#line 431
      st->size = ctx->end - ctx->start;
#line 432
      st->valid |= 4UL;
    } else
#line 434
    if ((fst.st_mode & 61440U) == 32768U) {
#line 435
      st->size = (zip_uint64_t )fst.st_size;
#line 436
      st->valid |= 4UL;
    }
  }
#line 439
  return ((zip_int64_t )sizeof(ctx->st));
  case_14: 
#line 443
  return (ctx->supports);
  case_7: 
#line 446
  return ((zip_int64_t )ctx->current);
  case_13: 
  {
#line 450
  __cil_tmp44 = ftello(ctx->fout);
#line 450
  ret = __cil_tmp44;
  }
#line 452
  if (ret < 0L) {
    {
#line 453
    __cil_tmp45 = __errno_location();
#line 453
    zip_error_set(& ctx->error, 30, *__cil_tmp45);
    }
#line 454
    return ((zip_int64_t )-1);
  }
#line 456
  return (ret);
  case_11: 
  {
#line 463
  clearerr(ctx->fout);
#line 464
  ret___0 = fwrite((void const   *)data, 1UL, len, ctx->fout);
#line 465
  __cil_tmp48 = ferror(ctx->fout);
  }
#line 465
  if (ret___0 != len) {
    {
#line 466
    __cil_tmp49 = __errno_location();
#line 466
    zip_error_set(& ctx->error, 6, *__cil_tmp49);
    }
#line 467
    return ((zip_int64_t )-1);
  } else
#line 465
  if (__cil_tmp48) {
    {
#line 466
    __cil_tmp49 = __errno_location();
#line 466
    zip_error_set(& ctx->error, 6, *__cil_tmp49);
    }
#line 467
    return ((zip_int64_t )-1);
  }
#line 470
  return ((zip_int64_t )ret___0);
  switch_default___0: 
  {
#line 474
  zip_error_set(& ctx->error, 28, 0);
  }
#line 475
  return ((zip_int64_t )-1);

#line 479
  return (0L);
}
}
#line 481 "/root/libzip/lib/zip_source_filep.c"
static int _zip_fseek_u(FILE *f , zip_uint64_t offset , int whence , zip_error_t *error ) 
{ 
  int __cil_tmp5 ;

  {
#line 483
  if (offset > 0xffffffffffffffffUL) {
    {
#line 484
    zip_error_set(error, 4, 75);
    }
#line 485
    return (-1);
  }
  {
#line 487
  __cil_tmp5 = _zip_fseek(f, (zip_int64_t )offset, whence, error);
  }
#line 487
  return (__cil_tmp5);
}
}
#line 492 "/root/libzip/lib/zip_source_filep.c"
static int _zip_fseek(FILE *f , zip_int64_t offset , int whence , zip_error_t *error ) 
{ 
  int __cil_tmp5 ;
  int *__cil_tmp6 ;

  {
#line 494
  if (offset > -1L) {
    {
#line 495
    zip_error_set(error, 4, 75);
    }
#line 496
    return (-1);
  } else
#line 494
  if (offset < 0L) {
    {
#line 495
    zip_error_set(error, 4, 75);
    }
#line 496
    return (-1);
  }
  {
#line 498
  __cil_tmp5 = fseeko(f, offset, whence);
  }
#line 498
  if (__cil_tmp5 < 0) {
    {
#line 499
    __cil_tmp6 = __errno_location();
#line 499
    zip_error_set(error, 4, *__cil_tmp6);
    }
#line 500
    return (-1);
  }
#line 502
  return (0);
}
}
#line 41 "/root/libzip/lib/zip_source_file.c"
zip_source_t *zip_source_file(zip_t *za___0 , char const   *fname , zip_uint64_t start ,
                              zip_int64_t len ) 
{ 
  zip_source_t *__cil_tmp5 ;

  {
#line 43
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 44
    return ((zip_source_t *)((void *)0));
  }
  {
#line 46
  __cil_tmp5 = zip_source_file_create(fname, start, len, & za___0->error);
  }
#line 46
  return (__cil_tmp5);
}
}
#line 51 "/root/libzip/lib/zip_source_file.c"
zip_source_t *zip_source_file_create(char const   *fname , zip_uint64_t start , zip_int64_t length ,
                                     zip_error_t *error ) 
{ 
  zip_source_t *__cil_tmp5 ;

  {
#line 53
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    {
#line 54
    zip_error_set(error, 18, 0);
    }
#line 55
    return ((zip_source_t *)((void *)0));
  } else
#line 53
  if (length < -1L) {
    {
#line 54
    zip_error_set(error, 18, 0);
    }
#line 55
    return ((zip_source_t *)((void *)0));
  }
  {
#line 58
  __cil_tmp5 = _zip_source_file_or_p(fname, (FILE *)((void *)0), start, length, (zip_stat_t *)((void *)0),
                                     error);
  }
#line 58
  return (__cil_tmp5);
}
}
#line 39 "/root/libzip/lib/zip_source_error.c"
zip_error_t *zip_source_error(zip_source_t *src ) 
{ 


  {
#line 41
  return (& src->error);
}
}
#line 52 "/root/libzip/lib/zip_source_deflate.c"
static zip_int64_t compress_read(zip_source_t *src , struct deflate *ctx , void *data ,
                                 zip_uint64_t len ) ;
#line 53
static zip_int64_t decompress_read(zip_source_t *src , struct deflate *ctx , void *data ,
                                   zip_uint64_t len ) ;
#line 54
static zip_int64_t deflate_compress(zip_source_t *src , void *ud , void *data , zip_uint64_t len ,
                                    zip_source_cmd_t cmd ) ;
#line 55
static zip_int64_t deflate_decompress(zip_source_t *src , void *ud , void *data ,
                                      zip_uint64_t len , zip_source_cmd_t cmd ) ;
#line 56
static void deflate_free(struct deflate *ctx ) ;
#line 60 "/root/libzip/lib/zip_source_deflate.c"
zip_source_t *zip_source_deflate(zip_t *za___0 , zip_source_t *src , zip_int32_t cm ,
                                 int flags ) 
{ 
  struct deflate *ctx ;
  zip_source_t *s2 ;
  void *__cil_tmp7 ;
  zip_int64_t (*tmp)(zip_source_t * , void * , void * , zip_uint64_t  , zip_source_cmd_t  ) ;
  zip_source_t *__cil_tmp9 ;
  int tmp___0 ;

  {
#line 65
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 66
    zip_error_set(& za___0->error, 18, 0);
    }
#line 67
    return ((zip_source_t *)((void *)0));
  } else
#line 65
  if (cm != 8) {
#line 65
    if (! (cm == -1)) {
#line 65
      if (! (cm == -2)) {
        {
#line 66
        zip_error_set(& za___0->error, 18, 0);
        }
#line 67
        return ((zip_source_t *)((void *)0));
      }
    }
  }
  {
#line 70
  __cil_tmp7 = malloc(sizeof(*ctx));
#line 70
  ctx = (struct deflate *)__cil_tmp7;
  }
#line 70
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 71
    zip_error_set(& za___0->error, 14, 0);
    }
#line 72
    return ((zip_source_t *)((void *)0));
  }
  {
#line 75
  zip_error_init(& ctx->error);
#line 76
  ctx->eof = 0;
#line 77
  ctx->is_stored = 0;
  }
#line 78
  if (cm == -1) {
#line 78
    tmp___0 = 1;
  } else
#line 78
  if (cm == -2) {
#line 78
    tmp___0 = 1;
  } else {
#line 78
    tmp___0 = 0;
  }
#line 78
  ctx->can_store = tmp___0;
#line 79
  if (flags & 1) {
#line 80
    ctx->mem_level = 9;
  }
#line 83
  if (flags & 1) {
#line 83
    tmp = & deflate_compress;
  } else {
#line 83
    tmp = & deflate_decompress;
  }
  {
#line 83
  __cil_tmp9 = zip_source_layered(za___0, src, tmp, (void *)ctx);
#line 83
  s2 = __cil_tmp9;
  }
#line 83
  if ((unsigned long )s2 == (unsigned long )((void *)0)) {
    {
#line 87
    deflate_free(ctx);
    }
#line 88
    return ((zip_source_t *)((void *)0));
  }
#line 91
  return (s2);
}
}
#line 96 "/root/libzip/lib/zip_source_deflate.c"
static zip_int64_t compress_read(zip_source_t *src , struct deflate *ctx , void *data ,
                                 zip_uint64_t len ) 
{ 
  int end ;
  int ret ;
  zip_int64_t n ;
  zip_uint64_t out_offset ;
  uInt out_len ;
  int __cil_tmp10 ;
  unsigned long tmp ;
  int tmp___0 ;
  int __cil_tmp13 ;
  unsigned long tmp___1 ;
  int __cil_tmp16 ;
  int tmp___2 ;

  {
  {
#line 103
  __cil_tmp10 = zip_error_code_zip(& ctx->error);
  }
#line 103
  if (__cil_tmp10 != 0) {
#line 104
    return ((zip_int64_t )-1);
  }
#line 106
  if (len == 0UL) {
#line 107
    return ((zip_int64_t )0);
  } else
#line 106
  if (ctx->is_stored) {
#line 107
    return ((zip_int64_t )0);
  }
#line 110
  out_offset = (zip_uint64_t )0;
#line 111
  if (4294967295UL < len) {
#line 111
    tmp = 4294967295UL;
  } else {
#line 111
    tmp = len;
  }
#line 111
  out_len = (uInt )tmp;
#line 112
  ctx->zstr.next_out = (Bytef *)data;
#line 113
  ctx->zstr.avail_out = out_len;
#line 115
  end = 0;
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 116
    if (! (! end)) {
#line 116
      goto while_break;
    }
#line 117
    if (ctx->eof) {
#line 117
      tmp___0 = 4;
    } else {
#line 117
      tmp___0 = 0;
    }
    {
#line 117
    __cil_tmp13 = deflate(& ctx->zstr, tmp___0);
#line 117
    ret = __cil_tmp13;
    }
#line 120
    if (ret == 1) {
#line 120
      goto case_1;
    }
#line 128
    if (ret == 0) {
#line 128
      goto case_0;
    }
#line 147
    if (ret == -5) {
#line 147
      goto case_exp;
    }
#line 178
    if (ret == -4) {
#line 178
      goto case_exp___0;
    }
#line 178
    if (ret == -2) {
#line 178
      goto case_exp___0;
    }
#line 178
    if (ret == -3) {
#line 178
      goto case_exp___0;
    }
#line 178
    if (ret == 2) {
#line 178
      goto case_exp___0;
    }
#line 119
    goto switch_break;
    case_1: 
#line 121
    if (ctx->can_store) {
#line 121
      if (ctx->zstr.total_in <= ctx->zstr.total_out) {
        {
#line 122
        ctx->is_stored = 1;
#line 123
        ctx->size = ctx->zstr.total_in;
#line 124
        memcpy(data, (void const   *)(ctx->buffer), ctx->size);
        }
#line 125
        return ((zip_int64_t )ctx->size);
      }
    }
    case_0: 
#line 131
    if (ctx->zstr.avail_out == 0U) {
#line 132
      out_offset += (unsigned long )out_len;
#line 133
      if (out_offset < len) {
#line 134
        if (4294967295UL < len - out_offset) {
#line 134
          tmp___1 = 4294967295UL;
        } else {
#line 134
          tmp___1 = len - out_offset;
        }
#line 134
        out_len = (uInt )tmp___1;
#line 135
        ctx->zstr.next_out = (Bytef *)data + out_offset;
#line 136
        ctx->zstr.avail_out = out_len;
      } else {
#line 139
        ctx->can_store = 0;
#line 140
        end = 1;
      }
    } else
#line 143
    if (ctx->eof) {
#line 143
      if (ctx->zstr.avail_in == 0U) {
#line 144
        end = 1;
      }
    }
#line 145
    goto switch_break;
    case_exp: 
#line 148
    if (ctx->zstr.avail_in == 0U) {
#line 149
      if (ctx->eof) {
#line 150
        end = 1;
#line 151
        goto switch_break;
      }
      {
#line 154
      n = zip_source_read(src, (void *)(ctx->buffer), sizeof(ctx->buffer));
      }
#line 154
      if (n < 0L) {
        {
#line 155
        _zip_error_set_from_source(& ctx->error, src);
#line 156
        end = 1;
        }
#line 157
        goto switch_break;
      } else
#line 159
      if (n == 0L) {
#line 160
        ctx->eof = 1;
#line 162
        ctx->size = ctx->zstr.total_in;
      } else {
#line 165
        if (ctx->zstr.total_in > 0UL) {
#line 167
          ctx->can_store = 0;
        }
#line 169
        ctx->zstr.next_in = ctx->buffer;
#line 170
        ctx->zstr.avail_in = (uInt )n;
      }
#line 172
      goto while_continue;
    }
    case_exp___0: 
    {
#line 179
    zip_error_set(& ctx->error, 13, ret);
#line 181
    end = 1;
    }
#line 182
    goto switch_break;
    switch_break: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 186
  if ((unsigned long )ctx->zstr.avail_out < len) {
#line 187
    ctx->can_store = 0;
#line 188
    return ((zip_int64_t )(len - (unsigned long )ctx->zstr.avail_out));
  }
  {
#line 191
  __cil_tmp16 = zip_error_code_zip(& ctx->error);
  }
#line 191
  if (__cil_tmp16 == 0) {
#line 191
    tmp___2 = 0;
  } else {
#line 191
    tmp___2 = -1;
  }
#line 191
  return ((zip_int64_t )tmp___2);
}
}
#line 196 "/root/libzip/lib/zip_source_deflate.c"
static zip_int64_t decompress_read(zip_source_t *src , struct deflate *ctx , void *data ,
                                   zip_uint64_t len ) 
{ 
  int end ;
  int ret ;
  zip_int64_t n ;
  zip_uint64_t out_offset ;
  uInt out_len ;
  int __cil_tmp10 ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int __cil_tmp15 ;
  int tmp___1 ;

  {
  {
#line 203
  __cil_tmp10 = zip_error_code_zip(& ctx->error);
  }
#line 203
  if (__cil_tmp10 != 0) {
#line 204
    return ((zip_int64_t )-1);
  }
#line 206
  if (len == 0UL) {
#line 207
    return ((zip_int64_t )0);
  }
#line 209
  out_offset = (zip_uint64_t )0;
#line 210
  if (4294967295UL < len) {
#line 210
    tmp = 4294967295UL;
  } else {
#line 210
    tmp = len;
  }
#line 210
  out_len = (uInt )tmp;
#line 211
  ctx->zstr.next_out = (Bytef *)data;
#line 212
  ctx->zstr.avail_out = out_len;
#line 214
  end = 0;
  {
#line 215
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 215
    if (! (! end)) {
#line 215
      goto while_break;
    }
    {
#line 216
    ret = inflate(& ctx->zstr, 2);
    }
#line 219
    if (ret == 0) {
#line 219
      goto case_0;
    }
#line 233
    if (ret == 1) {
#line 233
      goto case_1;
    }
#line 238
    if (ret == -5) {
#line 238
      goto case_exp;
    }
#line 263
    if (ret == -4) {
#line 263
      goto case_exp___0;
    }
#line 263
    if (ret == -2) {
#line 263
      goto case_exp___0;
    }
#line 263
    if (ret == -3) {
#line 263
      goto case_exp___0;
    }
#line 263
    if (ret == 2) {
#line 263
      goto case_exp___0;
    }
#line 218
    goto switch_break;
    case_0: 
#line 220
    if (ctx->zstr.avail_out == 0U) {
#line 221
      out_offset += (unsigned long )out_len;
#line 222
      if (out_offset < len) {
#line 223
        if (4294967295UL < len - out_offset) {
#line 223
          tmp___0 = 4294967295UL;
        } else {
#line 223
          tmp___0 = len - out_offset;
        }
#line 223
        out_len = (uInt )tmp___0;
#line 224
        ctx->zstr.next_out = (Bytef *)data + out_offset;
#line 225
        ctx->zstr.avail_out = out_len;
      } else {
#line 228
        end = 1;
      }
    }
#line 231
    goto switch_break;
    case_1: 
#line 234
    ctx->eof = 1;
#line 235
    end = 1;
#line 236
    goto switch_break;
    case_exp: 
#line 239
    if (ctx->zstr.avail_in == 0U) {
#line 240
      if (ctx->eof) {
#line 241
        end = 1;
#line 242
        goto switch_break;
      }
      {
#line 245
      n = zip_source_read(src, (void *)(ctx->buffer), sizeof(ctx->buffer));
      }
#line 245
      if (n < 0L) {
        {
#line 246
        _zip_error_set_from_source(& ctx->error, src);
#line 247
        end = 1;
        }
#line 248
        goto switch_break;
      } else
#line 250
      if (n == 0L) {
#line 251
        ctx->eof = 1;
      } else {
#line 254
        ctx->zstr.next_in = ctx->buffer;
#line 255
        ctx->zstr.avail_in = (uInt )n;
      }
#line 257
      goto while_continue;
    }
    case_exp___0: 
    {
#line 264
    zip_error_set(& ctx->error, 13, ret);
#line 265
    end = 1;
    }
#line 266
    goto switch_break;
    switch_break: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 270
  if ((unsigned long )ctx->zstr.avail_out < len) {
#line 271
    return ((zip_int64_t )(len - (unsigned long )ctx->zstr.avail_out));
  }
  {
#line 273
  __cil_tmp15 = zip_error_code_zip(& ctx->error);
  }
#line 273
  if (__cil_tmp15 == 0) {
#line 273
    tmp___1 = 0;
  } else {
#line 273
    tmp___1 = -1;
  }
#line 273
  return ((zip_int64_t )tmp___1);
}
}
#line 278 "/root/libzip/lib/zip_source_deflate.c"
static zip_int64_t deflate_compress(zip_source_t *src , void *ud , void *data , zip_uint64_t len ,
                                    zip_source_cmd_t cmd ) 
{ 
  struct deflate *ctx ;
  int ret ;
  zip_int64_t __cil_tmp9 ;
  zip_stat_t *st ;
  int tmp ;
  zip_int64_t __cil_tmp12 ;

  {
#line 283
  ctx = (struct deflate *)ud;
#line 286
  if ((unsigned int )cmd == 0U) {
#line 286
    goto case_0;
  }
#line 303
  if ((unsigned int )cmd == 1U) {
#line 303
    goto case_1;
  }
#line 306
  if ((unsigned int )cmd == 2U) {
#line 306
    goto case_2;
  }
#line 310
  if ((unsigned int )cmd == 3U) {
#line 310
    goto case_3;
  }
#line 327
  if ((unsigned int )cmd == 4U) {
#line 327
    goto case_4;
  }
#line 330
  if ((unsigned int )cmd == 5U) {
#line 330
    goto case_5;
  }
#line 334
  if ((unsigned int )cmd == 14U) {
#line 334
    goto case_14;
  }
#line 337
  goto switch_default;
  case_0: 
  {
#line 287
  ctx->zstr.zalloc = (voidpf (*)(voidpf  , uInt  , uInt  ))0;
#line 288
  ctx->zstr.zfree = (void (*)(voidpf  , voidpf  ))0;
#line 289
  ctx->zstr.opaque = (void *)0;
#line 290
  ctx->zstr.avail_in = (uInt )0;
#line 291
  ctx->zstr.next_in = (Bytef *)((void *)0);
#line 292
  ctx->zstr.avail_out = (uInt )0;
#line 293
  ctx->zstr.next_out = (Bytef *)((void *)0);
#line 296
  ret = deflateInit2_(& ctx->zstr, 9, 8, -15, ctx->mem_level, 0, "1.2.8", (int )sizeof(z_stream ));
  }
#line 296
  if (ret != 0) {
    {
#line 297
    zip_error_set(& ctx->error, 13, ret);
    }
#line 298
    return ((zip_int64_t )-1);
  }
#line 301
  return ((zip_int64_t )0);
  case_1: 
  {
#line 304
  __cil_tmp9 = compress_read(src, ctx, data, len);
  }
#line 304
  return (__cil_tmp9);
  case_2: 
  {
#line 307
  deflateEnd(& ctx->zstr);
  }
#line 308
  return ((zip_int64_t )0);
  case_3: 
#line 314
  st = (zip_stat_t *)data;
#line 316
  if (ctx->is_stored) {
#line 316
    tmp = 0;
  } else {
#line 316
    tmp = 8;
  }
#line 316
  st->comp_method = (zip_uint16_t )tmp;
#line 317
  st->valid |= 64UL;
#line 318
  if (ctx->eof) {
#line 319
    st->comp_size = ctx->size;
#line 320
    st->valid |= 8UL;
  } else {
#line 323
    st->valid &= 4294967287UL;
  }
#line 325
  return ((zip_int64_t )0);
  case_4: 
  {
#line 328
  __cil_tmp12 = zip_error_to_data(& ctx->error, data, len);
  }
#line 328
  return (__cil_tmp12);
  case_5: 
  {
#line 331
  deflate_free(ctx);
  }
#line 332
  return ((zip_int64_t )0);
  case_14: 
#line 335
  return ((zip_int64_t )(((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)));
  switch_default: 
  {
#line 338
  zip_error_set(& ctx->error, 20, 0);
  }
#line 339
  return ((zip_int64_t )-1);

#line 343
  return (0L);
}
}
#line 345 "/root/libzip/lib/zip_source_deflate.c"
static zip_int64_t deflate_decompress(zip_source_t *src , void *ud , void *data ,
                                      zip_uint64_t len , zip_source_cmd_t cmd ) 
{ 
  struct deflate *ctx ;
  zip_int64_t n ;
  int ret ;
  zip_int64_t __cil_tmp11 ;
  zip_stat_t *st ;
  zip_int64_t __cil_tmp13 ;
  zip_int64_t __cil_tmp14 ;

  {
#line 352
  ctx = (struct deflate *)ud;
#line 355
  if ((unsigned int )cmd == 0U) {
#line 355
    goto case_0;
  }
#line 374
  if ((unsigned int )cmd == 1U) {
#line 374
    goto case_1;
  }
#line 377
  if ((unsigned int )cmd == 2U) {
#line 377
    goto case_2;
  }
#line 381
  if ((unsigned int )cmd == 3U) {
#line 381
    goto case_3;
  }
#line 394
  if ((unsigned int )cmd == 4U) {
#line 394
    goto case_4;
  }
#line 397
  if ((unsigned int )cmd == 5U) {
#line 397
    goto case_5;
  }
#line 401
  if ((unsigned int )cmd == 14U) {
#line 401
    goto case_14;
  }
#line 404
  goto switch_default;
  case_0: 
  {
#line 356
  n = zip_source_read(src, (void *)(ctx->buffer), sizeof(ctx->buffer));
  }
#line 356
  if (n < 0L) {
    {
#line 357
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 358
    return ((zip_int64_t )-1);
  }
  {
#line 361
  ctx->zstr.zalloc = (voidpf (*)(voidpf  , uInt  , uInt  ))0;
#line 362
  ctx->zstr.zfree = (void (*)(voidpf  , voidpf  ))0;
#line 363
  ctx->zstr.opaque = (void *)0;
#line 364
  ctx->zstr.next_in = ctx->buffer;
#line 365
  ctx->zstr.avail_in = (uInt )n;
#line 368
  ret = inflateInit2_(& ctx->zstr, -15, "1.2.8V", (int )sizeof(z_stream ));
  }
#line 368
  if (ret != 0) {
    {
#line 369
    zip_error_set(& ctx->error, 13, ret);
    }
#line 370
    return ((zip_int64_t )-1);
  }
#line 372
  return ((zip_int64_t )0);
  case_1: 
  {
#line 375
  __cil_tmp11 = decompress_read(src, ctx, data, len);
  }
#line 375
  return (__cil_tmp11);
  case_2: 
  {
#line 378
  inflateEnd(& ctx->zstr);
  }
#line 379
  return ((zip_int64_t )0);
  case_3: 
#line 385
  st = (zip_stat_t *)data;
#line 387
  st->comp_method = (zip_uint16_t )0;
#line 388
  if (st->comp_size > 0UL) {
#line 388
    if (st->size > 0UL) {
#line 389
      st->comp_size = st->size;
    }
  }
#line 391
  return ((zip_int64_t )0);
  case_4: 
  {
#line 395
  __cil_tmp13 = zip_error_to_data(& ctx->error, data, len);
  }
#line 395
  return (__cil_tmp13);
  case_5: 
  {
#line 398
  free((void *)ctx);
  }
#line 399
  return ((zip_int64_t )0);
  case_14: 
  {
#line 402
  __cil_tmp14 = zip_source_make_command_bitmap((zip_source_cmd_t )0, 1, 2, 3, 4, 5,
                                               -1);
  }
#line 402
  return (__cil_tmp14);
  switch_default: 
  {
#line 405
  zip_error_set(& ctx->error, 28, 0);
  }
#line 406
  return ((zip_int64_t )-1);

#line 410
  return (0L);
}
}
#line 412 "/root/libzip/lib/zip_source_deflate.c"
static void deflate_free(struct deflate *ctx ) 
{ 


  {
  {
#line 414
  free((void *)ctx);
  }
#line 416
  return;
}
}
#line 51 "/root/libzip/lib/zip_source_crc.c"
static zip_int64_t crc_read(zip_source_t *src , void *_ctx , void *data , zip_uint64_t len ,
                            zip_source_cmd_t cmd ) ;
#line 55 "/root/libzip/lib/zip_source_crc.c"
zip_source_t *zip_source_crc(zip_t *za___0 , zip_source_t *src , int validate ) 
{ 
  struct crc_context *ctx ;
  void *__cil_tmp5 ;
  uLong __cil_tmp6 ;
  zip_source_t *__cil_tmp7 ;

  {
#line 59
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 60
    zip_error_set(& za___0->error, 18, 0);
    }
#line 61
    return ((zip_source_t *)((void *)0));
  }
  {
#line 64
  __cil_tmp5 = malloc(sizeof(*ctx));
#line 64
  ctx = (struct crc_context *)__cil_tmp5;
  }
#line 64
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 65
    zip_error_set(& za___0->error, 14, 0);
    }
#line 66
    return ((zip_source_t *)((void *)0));
  }
  {
#line 69
  zip_error_init(& ctx->error);
#line 70
  ctx->validate = validate;
#line 71
  ctx->crc_complete = 0;
#line 72
  ctx->crc_position = (zip_uint64_t )0;
#line 73
  __cil_tmp6 = crc32((uLong )0, (Bytef *)((void *)0), (uInt )0);
#line 73
  ctx->crc = (zip_uint32_t )__cil_tmp6;
#line 74
  ctx->size = (zip_uint64_t )0;
#line 76
  __cil_tmp7 = zip_source_layered(za___0, src, & crc_read, (void *)ctx);
  }
#line 76
  return (__cil_tmp7);
}
}
#line 81 "/root/libzip/lib/zip_source_crc.c"
static zip_int64_t crc_read(zip_source_t *src , void *_ctx , void *data , zip_uint64_t len ,
                            zip_source_cmd_t cmd ) 
{ 
  struct crc_context *ctx ;
  zip_int64_t n ;
  struct zip_stat st ;
  int __cil_tmp10 ;
  zip_uint64_t i ;
  zip_uint64_t nn ;
  unsigned long tmp ;
  uLong __cil_tmp14 ;
  zip_stat_t *st___0 ;
  zip_int64_t __cil_tmp16 ;
  zip_int64_t mask ;
  zip_int64_t __cil_tmp18 ;
  zip_int64_t __cil_tmp19 ;
  zip_int64_t new_position ;
  zip_source_args_seek_t *args ;
  zip_source_args_seek_t *tmp___0 ;
  int __cil_tmp23 ;

  {
#line 86
  ctx = (struct crc_context *)_ctx;
#line 89
  if ((unsigned int )cmd == 0U) {
#line 89
    goto case_0;
  }
#line 93
  if ((unsigned int )cmd == 1U) {
#line 93
    goto case_1;
  }
#line 136
  if ((unsigned int )cmd == 2U) {
#line 136
    goto case_2;
  }
#line 139
  if ((unsigned int )cmd == 3U) {
#line 139
    goto case_3;
  }
#line 158
  if ((unsigned int )cmd == 4U) {
#line 158
    goto case_4;
  }
#line 161
  if ((unsigned int )cmd == 5U) {
#line 161
    goto case_5;
  }
#line 165
  if ((unsigned int )cmd == 14U) {
#line 165
    goto case_14;
  }
#line 177
  if ((unsigned int )cmd == 6U) {
#line 177
    goto case_6;
  }
#line 195
  if ((unsigned int )cmd == 7U) {
#line 195
    goto case_7;
  }
#line 198
  goto switch_default;
  case_0: 
#line 90
  ctx->position = (zip_uint64_t )0;
#line 91
  return ((zip_int64_t )0);
  case_1: 
  {
#line 94
  n = zip_source_read(src, data, len);
  }
#line 94
  if (n < 0L) {
    {
#line 95
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 96
    return ((zip_int64_t )-1);
  }
#line 99
  if (n == 0L) {
#line 100
    if (ctx->crc_position == ctx->position) {
#line 101
      ctx->crc_complete = 1;
#line 102
      ctx->size = ctx->position;
#line 104
      if (ctx->validate) {
        {
#line 107
        __cil_tmp10 = zip_source_stat(src, & st);
        }
#line 107
        if (__cil_tmp10 < 0) {
          {
#line 108
          _zip_error_set_from_source(& ctx->error, src);
          }
#line 109
          return ((zip_int64_t )-1);
        }
#line 112
        if (st.valid & 32UL) {
#line 112
          if (st.crc != ctx->crc) {
            {
#line 113
            zip_error_set(& ctx->error, 7, 0);
            }
#line 114
            return ((zip_int64_t )-1);
          }
        }
#line 116
        if (st.valid & 4UL) {
#line 116
          if (st.size != ctx->size) {
            {
#line 117
            zip_error_set(& ctx->error, 21, 0);
            }
#line 118
            return ((zip_int64_t )-1);
          }
        }
      }
    }
  } else
#line 123
  if (! ctx->crc_complete) {
#line 123
    if (ctx->position <= ctx->crc_position) {
#line 126
      i = ctx->crc_position - ctx->position;
      {
#line 126
      while (1) {
        while_continue: /* CIL Label */ ;

#line 126
        if (! (i < (zip_uint64_t )n)) {
#line 126
          goto while_break;
        }
#line 127
        if (4294967295UL < (zip_uint64_t )n - i) {
#line 127
          tmp = 4294967295UL;
        } else {
#line 127
          tmp = (zip_uint64_t )n - i;
        }
        {
#line 127
        nn = tmp;
#line 129
        __cil_tmp14 = crc32((uLong )ctx->crc, (Bytef *)data + i, (uInt )nn);
#line 129
        ctx->crc = (zip_uint32_t )__cil_tmp14;
#line 130
        ctx->crc_position += nn;
#line 126
        i += nn;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: ;
    }
  }
#line 133
  ctx->position += (zip_uint64_t )n;
#line 134
  return (n);
  case_2: 
#line 137
  return ((zip_int64_t )0);
  case_3: 
#line 143
  st___0 = (zip_stat_t *)data;
#line 145
  if (ctx->crc_complete) {
#line 148
    st___0->size = ctx->size;
#line 149
    st___0->crc = ctx->crc;
#line 150
    st___0->comp_size = ctx->size;
#line 151
    st___0->comp_method = (zip_uint16_t )0;
#line 152
    st___0->encryption_method = (zip_uint16_t )0;
#line 153
    st___0->valid |= 236UL;
  }
#line 155
  return ((zip_int64_t )0);
  case_4: 
  {
#line 159
  __cil_tmp16 = zip_error_to_data(& ctx->error, data, len);
  }
#line 159
  return (__cil_tmp16);
  case_5: 
  {
#line 162
  free((void *)ctx);
  }
#line 163
  return ((zip_int64_t )0);
  case_14: 
  {
#line 167
  __cil_tmp18 = zip_source_supports(src);
#line 167
  mask = __cil_tmp18;
  }
#line 169
  if (mask < 0L) {
    {
#line 170
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 171
    return ((zip_int64_t )-1);
  }
  {
#line 174
  __cil_tmp19 = zip_source_make_command_bitmap((zip_source_cmd_t )8, 9, 10, 12, 13,
                                               15, -1);
  }
#line 174
  return (mask & ~ __cil_tmp19);
  case_6: 
#line 180
  if (len < sizeof(zip_source_args_seek_t )) {
    {
#line 180
    zip_error_set(& ctx->error, 18, 0);
#line 180
    tmp___0 = (zip_source_args_seek_t *)((void *)0);
    }
  } else {
#line 180
    tmp___0 = (zip_source_args_seek_t *)data;
  }
#line 180
  args = tmp___0;
#line 182
  if ((unsigned long )args == (unsigned long )((void *)0)) {
#line 183
    return ((zip_int64_t )-1);
  }
  {
#line 185
  new_position = zip_source_tell(src);
#line 185
  __cil_tmp23 = zip_source_seek(src, args->offset, args->whence);
  }
#line 185
  if (__cil_tmp23 < 0) {
    {
#line 186
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 187
    return ((zip_int64_t )-1);
  } else
#line 185
  if (new_position < 0L) {
    {
#line 186
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 187
    return ((zip_int64_t )-1);
  }
#line 190
  ctx->position = (zip_uint64_t )new_position;
#line 192
  return ((zip_int64_t )0);
  case_7: 
#line 196
  return ((zip_int64_t )ctx->position);
  switch_default: 
  {
#line 199
  zip_error_set(& ctx->error, 28, 0);
  }
#line 200
  return ((zip_int64_t )-1);

#line 204
  return (0L);
}
}
#line 39 "/root/libzip/lib/zip_source_commit_write.c"
int zip_source_commit_write(zip_source_t *src ) 
{ 
  int __cil_tmp2 ;
  zip_int64_t __cil_tmp3 ;

  {
#line 41
  if (! ((unsigned int )src->write_state == 1U)) {
    {
#line 42
    zip_error_set(& src->error, 18, 0);
    }
#line 43
    return (-1);
  }
#line 46
  if (src->open_count > 1U) {
    {
#line 47
    zip_error_set(& src->error, 29, 0);
    }
#line 48
    return (-1);
  } else
#line 50
  if (src->open_count > 0U) {
    {
#line 51
    __cil_tmp2 = zip_source_close(src);
    }
#line 51
    if (__cil_tmp2 < 0) {
#line 52
      return (-1);
    }
  }
  {
#line 56
  __cil_tmp3 = _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )9);
  }
#line 56
  if (__cil_tmp3 < 0L) {
#line 57
    src->write_state = (zip_source_write_state_t )2;
#line 58
    return (-1);
  }
#line 61
  src->write_state = (zip_source_write_state_t )0;
#line 63
  return (0);
}
}
#line 39 "/root/libzip/lib/zip_source_close.c"
int zip_source_close(zip_source_t *src ) 
{ 
  unsigned int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 41
  if (! (src->open_count > 0U)) {
    {
#line 42
    zip_error_set(& src->error, 18, 0);
    }
#line 43
    return (-1);
  }
#line 46
  __cil_tmp2 = src->open_count;
#line 46
  (src->open_count) --;
#line 47
  if (src->open_count == 0U) {
    {
#line 48
    _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )2);
    }
#line 50
    if ((unsigned long )src->src != (unsigned long )((void *)0)) {
      {
#line 51
      __cil_tmp3 = zip_source_close(src->src);
      }
#line 51
      if (__cil_tmp3 < 0) {
        {
#line 52
        zip_error_set(& src->error, 20, 0);
        }
      }
    }
  }
#line 57
  return (0);
}
}
#line 39 "/root/libzip/lib/zip_source_call.c"
zip_int64_t _zip_source_call(zip_source_t *src , void *data , zip_uint64_t length ,
                             zip_source_cmd_t command ) 
{ 
  zip_int64_t ret ;
  int e[2] ;
  zip_int64_t __cil_tmp9 ;

  {
#line 43
  if ((src->supports & (long )(1 << (unsigned int )command)) == 0L) {
    {
#line 44
    zip_error_set(& src->error, 28, 0);
    }
#line 45
    return ((zip_int64_t )-1);
  }
#line 48
  if ((unsigned long )src->src == (unsigned long )((void *)0)) {
    {
#line 49
    ret = (*(src->cb.f))(src->ud, data, length, command);
    }
  } else {
    {
#line 52
    ret = (*(src->cb.l))(src->src, src->ud, data, length, command);
    }
  }
#line 55
  if (ret < 0L) {
#line 56
    if ((unsigned int )command != 4U) {
#line 56
      if ((unsigned int )command != 14U) {
        {
#line 59
        __cil_tmp9 = _zip_source_call(src, (void *)(e), sizeof(e), (zip_source_cmd_t )4);
        }
#line 59
        if (__cil_tmp9 < 0L) {
          {
#line 60
          zip_error_set(& src->error, 20, 0);
          }
        } else {
          {
#line 63
          zip_error_set(& src->error, e[0], e[1]);
          }
        }
      }
    }
  }
#line 68
  return (ret);
}
}
#line 63 "/root/libzip/lib/zip_source_buffer.c"
static void buffer_free(buffer_t *buffer ) ;
#line 64
static buffer_t *buffer_new(zip_uint64_t fragment_size ) ;
#line 65
static buffer_t *buffer_new_read(void const   *data , zip_uint64_t length , int free_data ) ;
#line 66
static buffer_t *buffer_new_write(zip_uint64_t fragment_size ) ;
#line 67
static zip_int64_t buffer_read(buffer_t *buffer , zip_uint8_t *data , zip_uint64_t length ) ;
#line 68
static int buffer_seek(buffer_t *buffer , void *data , zip_uint64_t len , zip_error_t *error ) ;
#line 69
static zip_int64_t buffer_write(buffer_t *buffer , zip_uint8_t *data , zip_uint64_t length ,
                                zip_error_t *error ) ;
#line 71
static zip_int64_t read_data(void *state , void *data , zip_uint64_t len , zip_source_cmd_t cmd ) ;
#line 75 "/root/libzip/lib/zip_source_buffer.c"
zip_source_t *zip_source_buffer(zip_t *za___0 , void const   *data , zip_uint64_t len ,
                                int freep ) 
{ 
  zip_source_t *__cil_tmp5 ;

  {
#line 77
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 78
    return ((zip_source_t *)((void *)0));
  }
  {
#line 80
  __cil_tmp5 = zip_source_buffer_create(data, len, freep, & za___0->error);
  }
#line 80
  return (__cil_tmp5);
}
}
#line 85 "/root/libzip/lib/zip_source_buffer.c"
zip_source_t *zip_source_buffer_create(void const   *data , zip_uint64_t len , int freep ,
                                       zip_error_t *error ) 
{ 
  struct read_data *ctx ;
  zip_source_t *zs ;
  void *__cil_tmp7 ;

  {
#line 90
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 90
    if (len > 0UL) {
      {
#line 91
      zip_error_set(error, 18, 0);
      }
#line 92
      return ((zip_source_t *)((void *)0));
    }
  }
  {
#line 95
  __cil_tmp7 = malloc(sizeof(*ctx));
#line 95
  ctx = (struct read_data *)__cil_tmp7;
  }
#line 95
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 96
    zip_error_set(error, 14, 0);
    }
#line 97
    return ((zip_source_t *)((void *)0));
  }
  {
#line 100
  ctx->in = buffer_new_read(data, len, freep);
  }
#line 100
  if ((unsigned long )ctx->in == (unsigned long )((void *)0)) {
    {
#line 101
    zip_error_set(error, 14, 0);
#line 102
    free((void *)ctx);
    }
#line 103
    return ((zip_source_t *)((void *)0));
  }
  {
#line 106
  ctx->out = (buffer_t *)((void *)0);
#line 107
  ctx->mtime = time((time_t *)((void *)0));
#line 108
  zip_error_init(& ctx->error);
#line 110
  zs = zip_source_function_create(& read_data, (void *)ctx, error);
  }
#line 110
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
    {
#line 111
    buffer_free(ctx->in);
#line 112
    free((void *)ctx);
    }
#line 113
    return ((zip_source_t *)((void *)0));
  }
#line 116
  return (zs);
}
}
#line 121 "/root/libzip/lib/zip_source_buffer.c"
static zip_int64_t read_data(void *state , void *data , zip_uint64_t len , zip_source_cmd_t cmd ) 
{ 
  struct read_data *ctx ;
  zip_int64_t __cil_tmp7 ;
  zip_int64_t __cil_tmp8 ;
  buffer_t *empty___0 ;
  buffer_t *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  zip_stat_t *st ;
  zip_int64_t __cil_tmp14 ;
  zip_int64_t __cil_tmp15 ;

  {
#line 123
  ctx = (struct read_data *)state;
#line 126
  if ((unsigned int )cmd == 8U) {
#line 126
    goto case_8;
  }
#line 133
  if ((unsigned int )cmd == 2U) {
#line 133
    goto case_2;
  }
#line 136
  if ((unsigned int )cmd == 9U) {
#line 136
    goto case_9;
  }
#line 142
  if ((unsigned int )cmd == 4U) {
#line 142
    goto case_4;
  }
#line 145
  if ((unsigned int )cmd == 5U) {
#line 145
    goto case_5;
  }
#line 151
  if ((unsigned int )cmd == 0U) {
#line 151
    goto case_0;
  }
#line 155
  if ((unsigned int )cmd == 1U) {
#line 155
    goto case_1;
  }
#line 162
  if ((unsigned int )cmd == 15U) {
#line 162
    goto case_15;
  }
#line 175
  if ((unsigned int )cmd == 10U) {
#line 175
    goto case_10;
  }
#line 180
  if ((unsigned int )cmd == 6U) {
#line 180
    goto case_6;
  }
#line 183
  if ((unsigned int )cmd == 12U) {
#line 183
    goto case_12;
  }
#line 186
  if ((unsigned int )cmd == 3U) {
#line 186
    goto case_3;
  }
#line 208
  if ((unsigned int )cmd == 14U) {
#line 208
    goto case_14;
  }
#line 211
  if ((unsigned int )cmd == 7U) {
#line 211
    goto case_7;
  }
#line 219
  if ((unsigned int )cmd == 13U) {
#line 219
    goto case_13;
  }
#line 226
  if ((unsigned int )cmd == 11U) {
#line 226
    goto case_11;
  }
#line 233
  goto switch_default;
  case_8: 
  {
#line 127
  ctx->out = buffer_new_write((zip_uint64_t )65536);
  }
#line 127
  if ((unsigned long )ctx->out == (unsigned long )((void *)0)) {
    {
#line 128
    zip_error_set(& ctx->error, 14, 0);
    }
#line 129
    return ((zip_int64_t )-1);
  }
#line 131
  return ((zip_int64_t )0);
  case_2: 
#line 134
  return ((zip_int64_t )0);
  case_9: 
  {
#line 137
  buffer_free(ctx->in);
#line 138
  ctx->in = ctx->out;
#line 139
  ctx->out = (buffer_t *)((void *)0);
  }
#line 140
  return ((zip_int64_t )0);
  case_4: 
  {
#line 143
  __cil_tmp7 = zip_error_to_data(& ctx->error, data, len);
  }
#line 143
  return (__cil_tmp7);
  case_5: 
  {
#line 146
  buffer_free(ctx->in);
#line 147
  buffer_free(ctx->out);
#line 148
  free((void *)ctx);
  }
#line 149
  return ((zip_int64_t )0);
  case_0: 
#line 152
  (ctx->in)->offset = (zip_uint64_t )0;
#line 153
  return ((zip_int64_t )0);
  case_1: 
#line 156
  if (len > 0xffffffffffffffffUL) {
    {
#line 157
    zip_error_set(& ctx->error, 18, 0);
    }
#line 158
    return ((zip_int64_t )-1);
  }
  {
#line 160
  __cil_tmp8 = buffer_read(ctx->in, (zip_uint8_t *)data, len);
  }
#line 160
  return (__cil_tmp8);
  case_15: 
  {
#line 164
  __cil_tmp10 = buffer_new_read((void const   *)((void *)0), (zip_uint64_t )0, 0);
#line 164
  empty___0 = __cil_tmp10;
  }
#line 165
  if ((unsigned long )empty___0 == (unsigned long )((buffer_t *)0)) {
    {
#line 166
    zip_error_set(& ctx->error, 14, 0);
    }
#line 167
    return ((zip_int64_t )-1);
  }
  {
#line 170
  buffer_free(ctx->in);
#line 171
  ctx->in = empty___0;
  }
#line 172
  return ((zip_int64_t )0);
  case_10: 
  {
#line 176
  buffer_free(ctx->out);
#line 177
  ctx->out = (buffer_t *)((void *)0);
  }
#line 178
  return ((zip_int64_t )0);
  case_6: 
  {
#line 181
  __cil_tmp11 = buffer_seek(ctx->in, data, len, & ctx->error);
  }
#line 181
  return ((zip_int64_t )__cil_tmp11);
  case_12: 
  {
#line 184
  __cil_tmp12 = buffer_seek(ctx->out, data, len, & ctx->error);
  }
#line 184
  return ((zip_int64_t )__cil_tmp12);
  case_3: 
#line 190
  if (len < sizeof(*st)) {
    {
#line 191
    zip_error_set(& ctx->error, 18, 0);
    }
#line 192
    return ((zip_int64_t )-1);
  }
  {
#line 195
  st = (zip_stat_t *)data;
#line 197
  zip_stat_init(st);
#line 198
  st->mtime = ctx->mtime;
#line 199
  st->size = (ctx->in)->size;
#line 200
  st->comp_size = st->size;
#line 201
  st->comp_method = (zip_uint16_t )0;
#line 202
  st->encryption_method = (zip_uint16_t )0;
#line 203
  st->valid = (zip_uint64_t )220U;
  }
#line 205
  return ((zip_int64_t )sizeof(*st));
  case_14: 
  {
#line 209
  __cil_tmp14 = zip_source_make_command_bitmap((zip_source_cmd_t )0, 1, 2, 3, 4, 5,
                                               6, 7, 8, 9, 15, 10, 12, 13, 11, -1);
  }
#line 209
  return (__cil_tmp14);
  case_7: 
#line 212
  if ((ctx->in)->offset > 0xffffffffffffffffUL) {
    {
#line 213
    zip_error_set(& ctx->error, 30, 75);
    }
#line 214
    return ((zip_int64_t )-1);
  }
#line 216
  return ((zip_int64_t )(ctx->in)->offset);
  case_13: 
#line 220
  if ((ctx->out)->offset > 0xffffffffffffffffUL) {
    {
#line 221
    zip_error_set(& ctx->error, 30, 75);
    }
#line 222
    return ((zip_int64_t )-1);
  }
#line 224
  return ((zip_int64_t )(ctx->out)->offset);
  case_11: 
#line 227
  if (len > 0xffffffffffffffffUL) {
    {
#line 228
    zip_error_set(& ctx->error, 18, 0);
    }
#line 229
    return ((zip_int64_t )-1);
  }
  {
#line 231
  __cil_tmp15 = buffer_write(ctx->out, (zip_uint8_t *)data, len, & ctx->error);
  }
#line 231
  return (__cil_tmp15);
  switch_default: 
  {
#line 234
  zip_error_set(& ctx->error, 28, 0);
  }
#line 235
  return ((zip_int64_t )-1);

#line 239
  return (0L);
}
}
#line 241 "/root/libzip/lib/zip_source_buffer.c"
static void buffer_free(buffer_t *buffer ) 
{ 
  zip_uint64_t i ;

  {
#line 243
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 244
    return;
  }
#line 247
  if (buffer->free_data) {
#line 250
    i = (zip_uint64_t )0;
    {
#line 250
    while (1) {
      while_continue: /* CIL Label */ ;

#line 250
      if (! (i < buffer->nfragments)) {
#line 250
        goto while_break;
      }
      {
#line 251
      free((void *)*(buffer->fragments + i));
#line 250
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 254
  free((void *)buffer->fragments);
#line 255
  free((void *)buffer);
  }
#line 257
  return;
}
}
#line 260 "/root/libzip/lib/zip_source_buffer.c"
static buffer_t *buffer_new(zip_uint64_t fragment_size ) 
{ 
  buffer_t *buffer ;
  void *tmp ;

  {
  {
#line 264
  tmp = malloc(sizeof(*buffer));
#line 264
  buffer = (buffer_t *)tmp;
  }
#line 264
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 265
    return ((buffer_t *)((void *)0));
  }
#line 268
  buffer->fragment_size = fragment_size;
#line 269
  buffer->offset = (zip_uint64_t )0;
#line 270
  buffer->free_data = 0;
#line 271
  buffer->nfragments = (zip_uint64_t )0;
#line 272
  buffer->fragments_capacity = (zip_uint64_t )0;
#line 273
  buffer->fragments = (zip_uint8_t **)((void *)0);
#line 274
  buffer->size = (zip_uint64_t )0;
#line 276
  return (buffer);
}
}
#line 281 "/root/libzip/lib/zip_source_buffer.c"
static buffer_t *buffer_new_read(void const   *data , zip_uint64_t length , int free_data ) 
{ 
  buffer_t *buffer ;
  void *tmp ;

  {
  {
#line 285
  buffer = buffer_new(length);
  }
#line 285
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 286
    return ((buffer_t *)((void *)0));
  }
#line 289
  buffer->size = length;
#line 291
  if (length > 0UL) {
    {
#line 292
    tmp = malloc(sizeof(*(buffer->fragments)));
#line 292
    buffer->fragments = (zip_uint8_t **)tmp;
    }
#line 292
    if ((unsigned long )buffer->fragments == (unsigned long )((void *)0)) {
      {
#line 293
      buffer_free(buffer);
      }
#line 294
      return ((buffer_t *)((void *)0));
    }
#line 296
    buffer->fragments_capacity = (zip_uint64_t )1;
#line 298
    buffer->nfragments = (zip_uint64_t )1;
#line 299
    *(buffer->fragments + 0) = (zip_uint8_t *)data;
#line 300
    buffer->free_data = free_data;
  }
#line 303
  return (buffer);
}
}
#line 308 "/root/libzip/lib/zip_source_buffer.c"
static buffer_t *buffer_new_write(zip_uint64_t fragment_size ) 
{ 
  buffer_t *buffer ;
  void *tmp ;

  {
  {
#line 312
  buffer = buffer_new(fragment_size);
  }
#line 312
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 313
    return ((buffer_t *)((void *)0));
  }
  {
#line 316
  tmp = malloc(sizeof(*(buffer->fragments)));
#line 316
  buffer->fragments = (zip_uint8_t **)tmp;
  }
#line 316
  if ((unsigned long )buffer->fragments == (unsigned long )((void *)0)) {
    {
#line 317
    buffer_free(buffer);
    }
#line 318
    return ((buffer_t *)((void *)0));
  }
#line 320
  buffer->fragments_capacity = (zip_uint64_t )1;
#line 321
  buffer->nfragments = (zip_uint64_t )0;
#line 322
  buffer->free_data = 1;
#line 324
  return (buffer);
}
}
#line 329 "/root/libzip/lib/zip_source_buffer.c"
static zip_int64_t buffer_read(buffer_t *buffer , zip_uint8_t *data , zip_uint64_t length ) 
{ 
  zip_uint64_t n ;
  zip_uint64_t i ;
  zip_uint64_t fragment_offset ;
  zip_uint64_t tmp ;
  zip_uint64_t left ;
  zip_uint64_t tmp___0 ;

  {
#line 333
  if (length < buffer->size - buffer->offset) {
#line 333
    tmp = length;
  } else {
#line 333
    tmp = buffer->size - buffer->offset;
  }
#line 333
  length = tmp;
#line 335
  if (length == 0UL) {
#line 336
    return ((zip_int64_t )0);
  }
#line 338
  if (length > 0xffffffffffffffffUL) {
#line 339
    return ((zip_int64_t )-1);
  }
#line 342
  i = buffer->offset / buffer->fragment_size;
#line 343
  fragment_offset = buffer->offset % buffer->fragment_size;
#line 344
  n = (zip_uint64_t )0;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;

#line 345
    if (! (n < length)) {
#line 345
      goto while_break;
    }
#line 346
    if (length - n < buffer->fragment_size - fragment_offset) {
#line 346
      tmp___0 = length - n;
    } else {
#line 346
      tmp___0 = buffer->fragment_size - fragment_offset;
    }
    {
#line 346
    left = tmp___0;
#line 348
    memcpy((void *)(data + n), (void const   *)(*(buffer->fragments + i) + fragment_offset),
           left);
#line 350
    n += left;
#line 351
    i ++;
#line 352
    fragment_offset = (zip_uint64_t )0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 355
  buffer->offset += n;
#line 356
  return ((zip_int64_t )n);
}
}
#line 361 "/root/libzip/lib/zip_source_buffer.c"
static int buffer_seek(buffer_t *buffer , void *data , zip_uint64_t len , zip_error_t *error ) 
{ 
  zip_int64_t new_offset ;
  zip_int64_t __cil_tmp6 ;

  {
  {
#line 363
  __cil_tmp6 = zip_source_seek_compute_offset(buffer->offset, buffer->size, data,
                                              len, error);
#line 363
  new_offset = __cil_tmp6;
  }
#line 365
  if (new_offset < 0L) {
#line 366
    return (-1);
  }
#line 369
  buffer->offset = (zip_uint64_t )new_offset;
#line 370
  return (0);
}
}
#line 375 "/root/libzip/lib/zip_source_buffer.c"
static zip_int64_t buffer_write(buffer_t *buffer , zip_uint8_t *data , zip_uint64_t length ,
                                zip_error_t *error ) 
{ 
  zip_uint64_t n ;
  zip_uint64_t i ;
  zip_uint64_t fragment_offset ;
  zip_uint8_t **fragments ;
  zip_uint64_t needed_fragments ;
  zip_uint64_t new_capacity ;
  zip_uint64_t left ;
  zip_uint64_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 380
  if (((buffer->offset + length) + buffer->fragment_size) - 1UL < length) {
    {
#line 381
    zip_error_set(error, 18, 0);
    }
#line 382
    return ((zip_int64_t )-1);
  }
#line 386
  if (buffer->offset + length > buffer->nfragments * buffer->fragment_size) {
#line 387
    needed_fragments = (((buffer->offset + length) + buffer->fragment_size) - 1UL) / buffer->fragment_size;
#line 389
    if (needed_fragments > buffer->fragments_capacity) {
#line 390
      new_capacity = buffer->fragments_capacity;
      {
#line 392
      while (1) {
        while_continue: /* CIL Label */ ;

#line 392
        if (! (new_capacity < needed_fragments)) {
#line 392
          goto while_break;
        }
#line 393
        new_capacity *= 2UL;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: 
      {
#line 396
      tmp___0 = realloc((void *)buffer->fragments, new_capacity * sizeof(*fragments));
#line 396
      fragments = (zip_uint8_t **)tmp___0;
      }
#line 398
      if ((unsigned long )fragments == (unsigned long )((void *)0)) {
        {
#line 399
        zip_error_set(error, 14, 0);
        }
#line 400
        return ((zip_int64_t )-1);
      }
#line 403
      buffer->fragments = fragments;
#line 404
      buffer->fragments_capacity = new_capacity;
    }
    {
#line 407
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 407
      if (! (buffer->nfragments < needed_fragments)) {
#line 407
        goto while_break___0;
      }
      {
#line 408
      tmp___1 = malloc(buffer->fragment_size);
#line 408
      *(buffer->fragments + buffer->nfragments) = (zip_uint8_t *)tmp___1;
      }
#line 408
      if ((unsigned long )*(buffer->fragments + buffer->nfragments) == (unsigned long )((void *)0)) {
        {
#line 409
        zip_error_set(error, 14, 0);
        }
#line 410
        return ((zip_int64_t )-1);
      }
#line 412
      (buffer->nfragments) ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 416
  i = buffer->offset / buffer->fragment_size;
#line 417
  fragment_offset = buffer->offset % buffer->fragment_size;
#line 418
  n = (zip_uint64_t )0;
  {
#line 419
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 419
    if (! (n < length)) {
#line 419
      goto while_break___1;
    }
#line 420
    if (length - n < buffer->fragment_size - fragment_offset) {
#line 420
      tmp = length - n;
    } else {
#line 420
      tmp = buffer->fragment_size - fragment_offset;
    }
    {
#line 420
    left = tmp;
#line 422
    memcpy((void *)(*(buffer->fragments + i) + fragment_offset), (void const   *)(data + n),
           left);
#line 424
    n += left;
#line 425
    i ++;
#line 426
    fragment_offset = (zip_uint64_t )0;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
#line 429
  buffer->offset += n;
#line 430
  if (buffer->offset > buffer->size) {
#line 431
    buffer->size = buffer->offset;
  }
#line 434
  return ((zip_int64_t )n);
}
}
#line 39 "/root/libzip/lib/zip_source_begin_write.c"
int zip_source_begin_write(zip_source_t *src ) 
{ 
  zip_int64_t __cil_tmp2 ;

  {
#line 41
  if ((unsigned int )src->write_state == 1U) {
    {
#line 42
    zip_error_set(& src->error, 18, 0);
    }
#line 43
    return (-1);
  }
  {
#line 46
  __cil_tmp2 = _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )8);
  }
#line 46
  if (__cil_tmp2 < 0L) {
#line 47
    return (-1);
  }
#line 50
  src->write_state = (zip_source_write_state_t )1;
#line 52
  return (0);
}
}
#line 42 "/root/libzip/lib/zip_set_name.c"
int _zip_set_name(zip_t *za___0 , zip_uint64_t idx , char const   *name , zip_flags_t flags ) 
{ 
  zip_entry_t *e ;
  zip_string_t *str ;
  int same_as_orig ;
  zip_int64_t i ;
  zip_uint8_t *old_name ;
  zip_uint8_t *new_name ;
  zip_string_t *old_str ;
  unsigned long __cil_tmp12 ;
  zip_string_t *__cil_tmp13 ;
  enum zip_encoding_type __cil_tmp14 ;
  zip_string_t *tmp ;
  zip_uint8_t *__cil_tmp19 ;
  int __cil_tmp21 ;

  {
#line 51
  if (idx >= za___0->nentry) {
    {
#line 52
    zip_error_set(& za___0->error, 18, 0);
    }
#line 53
    return (-1);
  }
#line 56
  if (za___0->ch_flags & 2U) {
    {
#line 57
    zip_error_set(& za___0->error, 25, 0);
    }
#line 58
    return (-1);
  }
#line 61
  if (name) {
#line 61
    if ((int )*(name + 0) != 0) {
      {
#line 63
      __cil_tmp12 = strlen(name);
#line 63
      __cil_tmp13 = _zip_string_new((zip_uint8_t *)name, (zip_uint16_t )__cil_tmp12,
                                    flags, & za___0->error);
#line 63
      str = __cil_tmp13;
      }
#line 63
      if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 64
        return (-1);
      }
      {
#line 65
      __cil_tmp14 = _zip_guess_encoding(str, (enum zip_encoding_type )0);
      }
#line 65
      if ((flags & 6144U) == 0U) {
#line 65
        if ((unsigned int )__cil_tmp14 == 3U) {
#line 66
          str->encoding = (enum zip_encoding_type )2;
        }
      }
    } else {
#line 69
      str = (zip_string_t *)((void *)0);
    }
  } else {
#line 69
    str = (zip_string_t *)((void *)0);
  }
  {
#line 72
  i = _zip_name_locate(za___0, name, (zip_flags_t )0, (zip_error_t *)((void *)0));
  }
#line 72
  if (i >= 0L) {
#line 72
    if ((zip_uint64_t )i != idx) {
      {
#line 73
      _zip_string_free(str);
#line 74
      zip_error_set(& za___0->error, 10, 0);
      }
#line 75
      return (-1);
    }
  }
#line 79
  if (i >= 0L) {
#line 79
    if ((zip_uint64_t )i == idx) {
      {
#line 80
      _zip_string_free(str);
      }
#line 81
      return (0);
    }
  }
#line 84
  e = za___0->entry + idx;
#line 86
  if (e->orig) {
    {
#line 87
    same_as_orig = _zip_string_equal((e->orig)->filename, str);
    }
  } else {
#line 89
    same_as_orig = 0;
  }
#line 91
  if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
#line 91
    if (! same_as_orig) {
      {
#line 92
      e->changes = _zip_dirent_clone(e->orig);
      }
#line 92
      if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
        {
#line 93
        zip_error_set(& za___0->error, 14, 0);
#line 94
        _zip_string_free(str);
        }
#line 95
        return (-1);
      }
    }
  }
#line 99
  if (same_as_orig) {
#line 99
    tmp = (e->orig)->filename;
  } else {
#line 99
    tmp = str;
  }
  {
#line 99
  __cil_tmp19 = _zip_string_get(tmp, (zip_uint32_t *)((void *)0), (zip_flags_t )0,
                                & za___0->error);
#line 99
  new_name = __cil_tmp19;
  }
#line 99
  if ((unsigned long )new_name == (unsigned long )((void *)0)) {
    {
#line 100
    _zip_string_free(str);
    }
#line 101
    return (-1);
  }
#line 104
  if (e->changes) {
#line 105
    old_str = (e->changes)->filename;
  } else
#line 107
  if (e->orig) {
#line 108
    old_str = (e->orig)->filename;
  } else {
#line 111
    old_str = (zip_string_t *)((void *)0);
  }
#line 114
  if (old_str) {
    {
#line 115
    old_name = _zip_string_get(old_str, (zip_uint32_t *)((void *)0), (zip_flags_t )0,
                               & za___0->error);
    }
#line 115
    if ((unsigned long )old_name == (unsigned long )((void *)0)) {
      {
#line 116
      _zip_string_free(str);
      }
#line 117
      return (-1);
    }
  } else {
#line 121
    old_name = (zip_uint8_t *)((void *)0);
  }
  {
#line 124
  __cil_tmp21 = _zip_hash_add(za___0->names, new_name, idx, (zip_flags_t )0, & za___0->error);
  }
#line 124
  if (__cil_tmp21 == 0) {
    {
#line 125
    _zip_string_free(str);
    }
#line 126
    return (-1);
  }
#line 128
  if (old_name) {
    {
#line 129
    _zip_hash_delete(za___0->names, old_name, (zip_error_t *)((void *)0));
    }
  }
#line 132
  if (same_as_orig) {
#line 133
    if (e->changes) {
#line 134
      if ((e->changes)->changed & 2U) {
        {
#line 135
        _zip_string_free((e->changes)->filename);
#line 136
        (e->changes)->changed &= 4294967293U;
        }
#line 137
        if ((e->changes)->changed == 0U) {
          {
#line 138
          _zip_dirent_free(e->changes);
#line 139
          e->changes = (zip_dirent_t *)((void *)0);
          }
        } else {
#line 143
          (e->changes)->filename = (e->orig)->filename;
        }
      }
    }
    {
#line 147
    _zip_string_free(str);
    }
  } else {
#line 150
    if ((e->changes)->changed & 2U) {
      {
#line 151
      _zip_string_free((e->changes)->filename);
      }
    }
#line 153
    (e->changes)->changed |= 2U;
#line 154
    (e->changes)->filename = str;
  }
#line 157
  return (0);
}
}
#line 39 "/root/libzip/lib/zip_set_file_compression.c"
int zip_set_file_compression(zip_t *za___0 , zip_uint64_t idx , zip_int32_t method ,
                             zip_uint32_t flags ) 
{ 
  zip_entry_t *e ;
  zip_int32_t old_method ;
  int tmp ;

  {
#line 44
  if (idx >= za___0->nentry) {
    {
#line 45
    zip_error_set(& za___0->error, 18, 0);
    }
#line 46
    return (-1);
  }
#line 49
  if (za___0->ch_flags & 2U) {
    {
#line 50
    zip_error_set(& za___0->error, 25, 0);
    }
#line 51
    return (-1);
  }
#line 54
  if (method != -1) {
#line 54
    if (method != 0) {
#line 54
      if (method != 8) {
        {
#line 55
        zip_error_set(& za___0->error, 16, 0);
        }
#line 56
        return (-1);
      }
    }
  }
#line 59
  e = za___0->entry + idx;
#line 61
  if ((unsigned long )e->orig == (unsigned long )((void *)0)) {
#line 61
    tmp = -1;
  } else {
#line 61
    tmp = (e->orig)->comp_method;
  }
#line 61
  old_method = tmp;
#line 65
  if (method == old_method) {
#line 66
    if (e->changes) {
#line 67
      (e->changes)->changed &= 4294967294U;
#line 68
      if ((e->changes)->changed == 0U) {
        {
#line 69
        _zip_dirent_free(e->changes);
#line 70
        e->changes = (zip_dirent_t *)((void *)0);
        }
      }
    }
  } else {
#line 75
    if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
      {
#line 76
      e->changes = _zip_dirent_clone(e->orig);
      }
#line 76
      if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
        {
#line 77
        zip_error_set(& za___0->error, 14, 0);
        }
#line 78
        return (-1);
      }
    }
#line 82
    (e->changes)->comp_method = method;
#line 83
    (e->changes)->changed |= 1U;
  }
#line 86
  return (0);
}
}
#line 308 "/root/libzip/lib/zip.h"
zip_int64_t zip_add(zip_t *za___0 , char const   *name , zip_source_t *source ) ;
#line 309
zip_int64_t zip_add_dir(zip_t *za___0 , char const   *name ) ;
#line 310
char const   *zip_get_file_comment(zip_t *za___0 , zip_uint64_t idx , int *lenp ,
                                   int flags ) ;
#line 311
int zip_get_num_files(zip_t *za___0 ) ;
#line 312
int zip_rename(zip_t *za___0 , zip_uint64_t idx , char const   *name ) ;
#line 313
int zip_replace(zip_t *za___0 , zip_uint64_t idx , zip_source_t *source ) ;
#line 314
int zip_set_file_comment(zip_t *za___0 , zip_uint64_t idx , char const   *comment ,
                         int len ) ;
#line 315
int zip_error_get_sys_type(int ze ) ;
#line 316
void zip_error_get(zip_t *za___0 , int *zep , int *sep ) ;
#line 317
int zip_error_to_str(char *buf , zip_uint64_t len , int ze , int se ) ;
#line 318
void zip_file_error_get(zip_file_t *zf , int *zep , int *sep ) ;
#line 42 "/root/libzip/lib/zip_set_file_comment.c"
int zip_set_file_comment(zip_t *za___0 , zip_uint64_t idx , char const   *comment ,
                         int len ) 
{ 
  int __cil_tmp5 ;

  {
#line 44
  if (len < 0) {
    {
#line 45
    zip_error_set(& za___0->error, 18, 0);
    }
#line 46
    return (-1);
  } else
#line 44
  if (len > 65535) {
    {
#line 45
    zip_error_set(& za___0->error, 18, 0);
    }
#line 46
    return (-1);
  }
  {
#line 48
  __cil_tmp5 = zip_file_set_comment(za___0, idx, comment, (zip_uint16_t )len, (zip_flags_t )0);
  }
#line 48
  return (__cil_tmp5);
}
}
#line 42 "/root/libzip/lib/zip_set_default_password.c"
int zip_set_default_password(zip_t *za___0 , char const   *passwd ) 
{ 
  int __cil_tmp3 ;
  void *__cil_tmp4 ;
  char *tmp ;
  char *__cil_tmp6 ;
  int tmp___0 ;

  {
#line 44
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 45
    return (-1);
  }
  {
#line 47
  free((void *)za___0->default_password);
  }
#line 49
  if (passwd) {
#line 50
    __cil_tmp3 = 0;
#line 50
    if (__cil_tmp3) {
#line 50
      if ((size_t )((void const   *)(passwd + 1)) - (size_t )((void const   *)passwd) == 1UL) {
#line 50
        if ((int )*(passwd + 0) == 0) {
          {
#line 50
          __cil_tmp4 = calloc((size_t )1, (size_t )1);
#line 50
          tmp = (char *)__cil_tmp4;
          }
        } else {
#line 50
          tmp = (char *)0;
        }
#line 50
        tmp___0 = (int )tmp;
      } else {
        {
#line 50
        __cil_tmp6 = __strdup(passwd);
#line 50
        tmp___0 = (int )__cil_tmp6;
        }
      }
    } else {
      {
#line 50
      __cil_tmp6 = __strdup(passwd);
#line 50
      tmp___0 = (int )__cil_tmp6;
      }
    }
#line 50
    za___0->default_password = (char *)tmp___0;
#line 50
    if ((unsigned long )za___0->default_password == (unsigned long )((void *)0)) {
      {
#line 51
      zip_error_set(& za___0->error, 14, 0);
      }
#line 52
      return (-1);
    }
  } else {
#line 56
    za___0->default_password = (char *)((void *)0);
  }
#line 58
  return (0);
}
}
#line 39 "/root/libzip/lib/zip_set_archive_flag.c"
int zip_set_archive_flag(zip_t *za___0 , zip_flags_t flag , int value ) 
{ 
  unsigned int new_flags ;
  int __cil_tmp5 ;

  {
#line 43
  if (value) {
#line 44
    new_flags = za___0->ch_flags | flag;
  } else {
#line 46
    new_flags = za___0->ch_flags & ~ flag;
  }
#line 48
  if (new_flags == za___0->ch_flags) {
#line 49
    return (0);
  }
#line 51
  if (za___0->ch_flags & 2U) {
    {
#line 52
    zip_error_set(& za___0->error, 25, 0);
    }
#line 53
    return (-1);
  }
#line 56
  if (flag & 2U) {
#line 56
    if (value) {
#line 56
      if ((za___0->ch_flags & 2U) == 0U) {
        {
#line 58
        __cil_tmp5 = _zip_changed(za___0, (zip_uint64_t *)((void *)0));
        }
#line 58
        if (__cil_tmp5) {
          {
#line 59
          zip_error_set(& za___0->error, 15, 0);
          }
#line 60
          return (-1);
        }
      }
    }
  }
#line 64
  za___0->ch_flags = new_flags;
#line 66
  return (0);
}
}
#line 41 "/root/libzip/lib/zip_set_archive_comment.c"
int zip_set_archive_comment(zip_t *za___0 , char const   *comment , zip_uint16_t len ) 
{ 
  zip_string_t *cstr ;
  enum zip_encoding_type __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 45
  if (za___0->ch_flags & 2U) {
    {
#line 46
    zip_error_set(& za___0->error, 25, 0);
    }
#line 47
    return (-1);
  }
#line 50
  if ((unsigned long )comment == (unsigned long )((void *)0)) {
#line 50
    if ((int )len > 0) {
      {
#line 51
      zip_error_set(& za___0->error, 18, 0);
      }
#line 52
      return (-1);
    }
  }
#line 55
  if ((int )len > 0) {
    {
#line 56
    cstr = _zip_string_new((zip_uint8_t *)comment, len, 0U, & za___0->error);
    }
#line 56
    if ((unsigned long )cstr == (unsigned long )((void *)0)) {
#line 57
      return (-1);
    }
    {
#line 59
    __cil_tmp6 = _zip_guess_encoding(cstr, (enum zip_encoding_type )0);
    }
#line 59
    if ((unsigned int )__cil_tmp6 == 4U) {
      {
#line 60
      _zip_string_free(cstr);
#line 61
      zip_error_set(& za___0->error, 18, 0);
      }
#line 62
      return (-1);
    }
  } else {
#line 66
    cstr = (zip_string_t *)((void *)0);
  }
  {
#line 68
  _zip_string_free(za___0->comment_changes);
#line 69
  za___0->comment_changes = (zip_string_t *)((void *)0);
#line 71
  __cil_tmp7 = _zip_string_equal(za___0->comment_orig, cstr);
  }
#line 71
  if (za___0->comment_orig) {
#line 71
    if (__cil_tmp7) {
      {
#line 73
      _zip_string_free(cstr);
#line 74
      za___0->comment_changed = 0;
      }
    } else {
#line 71
      goto _L;
    }
  } else
  _L: 
#line 71
  if ((unsigned long )za___0->comment_orig == (unsigned long )((void *)0)) {
#line 71
    if ((unsigned long )cstr == (unsigned long )((void *)0)) {
      {
#line 73
      _zip_string_free(cstr);
#line 74
      za___0->comment_changed = 0;
      }
    } else {
#line 77
      za___0->comment_changes = cstr;
#line 78
      za___0->comment_changed = 1;
    }
  } else {
#line 77
    za___0->comment_changes = cstr;
#line 78
    za___0->comment_changed = 1;
  }
#line 81
  return (0);
}
}
#line 40 "/root/libzip/lib/zip_replace.c"
int zip_replace(zip_t *za___0 , zip_uint64_t idx , zip_source_t *source ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 42
  __cil_tmp4 = zip_file_replace(za___0, idx, source, (zip_flags_t )0);
  }
#line 42
  return (__cil_tmp4);
}
}
#line 42 "/root/libzip/lib/zip_rename.c"
int zip_rename(zip_t *za___0 , zip_uint64_t idx , char const   *name ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 44
  __cil_tmp4 = zip_file_rename(za___0, idx, name, (zip_flags_t )0);
  }
#line 44
  return (__cil_tmp4);
}
}
#line 49 "/root/libzip/lib/zip_open.c"
static zip_t *_zip_allocate_new(zip_source_t *src , unsigned int flags , zip_error_t *error ) ;
#line 50
static zip_int64_t _zip_checkcons(zip_t *za___0 , zip_cdir_t *cd , zip_error_t *error ) ;
#line 51
static zip_cdir_t *_zip_find_central_dir(zip_t *za___0 , zip_uint64_t len ) ;
#line 52
static exists_t _zip_file_exists(zip_source_t *src , zip_error_t *error ) ;
#line 53
static int _zip_headercomp(zip_dirent_t *central , zip_dirent_t *local ) ;
#line 54
static unsigned char *_zip_memmem(unsigned char const   *big , size_t biglen , unsigned char const   *little ,
                                  size_t littlelen ) ;
#line 55
static zip_cdir_t *_zip_read_cdir(zip_t *za___0 , zip_buffer_t *buffer , zip_uint64_t buf_offset ,
                                  zip_error_t *error ) ;
#line 56
static zip_cdir_t *_zip_read_eocd(zip_buffer_t *buffer , zip_uint64_t buf_offset ,
                                  unsigned int flags , zip_error_t *error ) ;
#line 57
static zip_cdir_t *_zip_read_eocd64(zip_source_t *src , zip_buffer_t *buffer , zip_uint64_t buf_offset ,
                                    unsigned int flags , zip_error_t *error ) ;
#line 61 "/root/libzip/lib/zip_open.c"
zip_t *zip_open(char const   *fn , int _flags , int *zep ) 
{ 
  zip_t *za___0 ;
  zip_source_t *src ;
  struct zip_error error ;

  {
  {
#line 67
  zip_error_init(& error);
#line 68
  src = zip_source_file_create(fn, (zip_uint64_t )0, (zip_int64_t )-1, & error);
  }
#line 68
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 69
    _zip_set_open_error(zep, & error, 0);
#line 70
    zip_error_fini(& error);
    }
#line 71
    return ((zip_t *)((void *)0));
  }
  {
#line 74
  za___0 = zip_open_from_source(src, _flags, & error);
  }
#line 74
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
    {
#line 75
    zip_source_free(src);
#line 76
    _zip_set_open_error(zep, & error, 0);
#line 77
    zip_error_fini(& error);
    }
#line 78
    return ((zip_t *)((void *)0));
  }
  {
#line 81
  zip_error_fini(& error);
  }
#line 82
  return (za___0);
}
}
#line 89 "/root/libzip/lib/zip_open.c"
static zip_int64_t needed_support_read  ;
#line 90 "/root/libzip/lib/zip_open.c"
static zip_int64_t needed_support_write  ;
#line 87 "/root/libzip/lib/zip_open.c"
zip_t *zip_open_from_source(zip_source_t *src , int _flags , zip_error_t *error ) 
{ 
  unsigned int flags ;
  zip_int64_t supported ;
  exists_t exists ;
  zip_t *__cil_tmp13 ;
  zip_t *za___0 ;
  int __cil_tmp15 ;

  {
#line 89
  needed_support_read = (zip_int64_t )-1;
#line 90
  needed_support_write = (zip_int64_t )-1;
#line 96
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 97
    zip_error_set(error, 18, 0);
    }
#line 98
    return ((zip_t *)((void *)0));
  } else
#line 96
  if (_flags < 0) {
    {
#line 97
    zip_error_set(error, 18, 0);
    }
#line 98
    return ((zip_t *)((void *)0));
  }
  {
#line 100
  flags = (unsigned int )_flags;
#line 102
  supported = zip_source_supports(src);
  }
#line 103
  if (needed_support_read == -1L) {
    {
#line 104
    needed_support_read = zip_source_make_command_bitmap((zip_source_cmd_t )0, 1,
                                                         2, 6, 7, 3, -1);
#line 105
    needed_support_write = zip_source_make_command_bitmap((zip_source_cmd_t )8, 9,
                                                          10, 12, 13, 15, -1);
    }
  }
#line 107
  if ((supported & needed_support_read) != needed_support_read) {
    {
#line 108
    zip_error_set(error, 28, 0);
    }
#line 109
    return ((zip_t *)((void *)0));
  }
#line 111
  if ((supported & needed_support_write) != needed_support_write) {
#line 112
    flags |= 16U;
  }
#line 115
  if ((flags & 24U) == 24U) {
    {
#line 116
    zip_error_set(error, 25, 0);
    }
#line 117
    return ((zip_t *)((void *)0));
  }
  {
#line 120
  exists = _zip_file_exists(src, error);
  }
#line 122
  if ((int )exists == -1) {
#line 122
    goto case_neg_1;
  }
#line 125
  if ((int )exists == 0) {
#line 125
    goto case_0;
  }
#line 132
  goto switch_default;
  case_neg_1: 
#line 123
  return ((zip_t *)((void *)0));
  case_0: 
#line 126
  if ((flags & 1U) == 0U) {
    {
#line 127
    zip_error_set(error, 9, 0);
    }
#line 128
    return ((zip_t *)((void *)0));
  }
  {
#line 130
  __cil_tmp13 = _zip_allocate_new(src, flags, error);
  }
#line 130
  return (__cil_tmp13);
  switch_default: 
#line 134
  if (flags & 2U) {
    {
#line 135
    zip_error_set(error, 10, 0);
    }
#line 136
    return ((zip_t *)((void *)0));
  }
  {
#line 138
  __cil_tmp15 = zip_source_open(src);
  }
#line 138
  if (__cil_tmp15 < 0) {
    {
#line 139
    _zip_error_set_from_source(error, src);
    }
#line 140
    return ((zip_t *)((void *)0));
  }
#line 143
  if (flags & 8U) {
    {
#line 144
    za___0 = _zip_allocate_new(src, flags, error);
    }
  } else {
    {
#line 148
    za___0 = _zip_open(src, flags, error);
    }
  }
#line 151
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
    {
#line 152
    zip_source_close(src);
    }
#line 153
    return ((zip_t *)((void *)0));
  }
#line 155
  return (za___0);

#line 159
  return ((zip_t *)0);
}
}
#line 161 "/root/libzip/lib/zip_open.c"
int zip_archive_set_tempdir(zip_t *za___0 , char const   *tempdir ) 
{ 
  char *new_tempdir ;
  int __cil_tmp4 ;
  void *__cil_tmp5 ;
  char *tmp ;
  char *__cil_tmp7 ;
  int tmp___0 ;
  int *__cil_tmp9 ;

  {
#line 165
  if (tempdir) {
#line 166
    __cil_tmp4 = 0;
#line 166
    if (__cil_tmp4) {
#line 166
      if ((size_t )((void const   *)(tempdir + 1)) - (size_t )((void const   *)tempdir) == 1UL) {
#line 166
        if ((int )*(tempdir + 0) == 0) {
          {
#line 166
          __cil_tmp5 = calloc((size_t )1, (size_t )1);
#line 166
          tmp = (char *)__cil_tmp5;
          }
        } else {
#line 166
          tmp = (char *)0;
        }
#line 166
        tmp___0 = (int )tmp;
      } else {
        {
#line 166
        __cil_tmp7 = __strdup(tempdir);
#line 166
        tmp___0 = (int )__cil_tmp7;
        }
      }
    } else {
      {
#line 166
      __cil_tmp7 = __strdup(tempdir);
#line 166
      tmp___0 = (int )__cil_tmp7;
      }
    }
#line 166
    new_tempdir = (char *)tmp___0;
#line 166
    if ((unsigned long )new_tempdir == (unsigned long )((void *)0)) {
      {
#line 167
      __cil_tmp9 = __errno_location();
#line 167
      zip_error_set(& za___0->error, 14, *__cil_tmp9);
      }
#line 168
      return (-1);
    }
  } else {
#line 172
    new_tempdir = (char *)((void *)0);
  }
  {
#line 174
  free((void *)za___0->tempdir);
#line 175
  za___0->tempdir = new_tempdir;
  }
#line 177
  return (0);
}
}
#line 181 "/root/libzip/lib/zip_open.c"
zip_t *_zip_open(zip_source_t *src , unsigned int flags , zip_error_t *error ) 
{ 
  zip_t *za___0 ;
  zip_cdir_t *cdir ;
  struct zip_stat st ;
  zip_uint64_t len ;
  zip_uint64_t idx ;
  int __cil_tmp9 ;
  zip_uint8_t *name ;
  zip_uint8_t *__cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 188
  zip_stat_init(& st);
#line 189
  __cil_tmp9 = zip_source_stat(src, & st);
  }
#line 189
  if (__cil_tmp9 < 0) {
    {
#line 190
    _zip_error_set_from_source(error, src);
    }
#line 191
    return ((zip_t *)((void *)0));
  }
#line 193
  if ((st.valid & 4UL) == 0UL) {
    {
#line 194
    zip_error_set(error, 4, 95);
    }
#line 195
    return ((zip_t *)((void *)0));
  }
#line 197
  len = st.size;
#line 200
  if (len == 0UL) {
    {
#line 201
    za___0 = _zip_allocate_new(src, flags, error);
    }
#line 201
    if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
      {
#line 202
      zip_source_free(src);
      }
#line 203
      return ((zip_t *)((void *)0));
    }
#line 206
    return (za___0);
  }
  {
#line 209
  za___0 = _zip_allocate_new(src, flags, error);
  }
#line 209
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 210
    return ((zip_t *)((void *)0));
  }
  {
#line 213
  cdir = _zip_find_central_dir(za___0, len);
  }
#line 213
  if ((unsigned long )cdir == (unsigned long )((void *)0)) {
    {
#line 214
    _zip_error_copy(error, & za___0->error);
#line 216
    zip_source_keep(src);
#line 217
    zip_discard(za___0);
    }
#line 218
    return ((zip_t *)((void *)0));
  }
  {
#line 221
  za___0->entry = cdir->entry;
#line 222
  za___0->nentry = cdir->nentry;
#line 223
  za___0->nentry_alloc = cdir->nentry_alloc;
#line 224
  za___0->comment_orig = cdir->comment;
#line 226
  free((void *)cdir);
#line 228
  idx = (zip_uint64_t )0;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;

#line 228
    if (! (idx < za___0->nentry)) {
#line 228
      goto while_break;
    }
    {
#line 229
    __cil_tmp14 = _zip_string_get(((za___0->entry + idx)->orig)->filename, (zip_uint32_t *)((void *)0),
                                  (zip_flags_t )0, error);
#line 229
    name = __cil_tmp14;
    }
#line 230
    if ((unsigned long )name == (unsigned long )((void *)0)) {
      {
#line 232
      zip_source_keep(src);
#line 233
      zip_discard(za___0);
      }
#line 234
      return ((zip_t *)((void *)0));
    }
    {
#line 237
    __cil_tmp15 = _zip_hash_add(za___0->names, name, idx, 8U, & za___0->error);
    }
#line 237
    if (__cil_tmp15 == 0) {
#line 238
      if (za___0->error.zip_err != 10) {
        {
#line 239
        _zip_error_copy(error, & za___0->error);
#line 241
        zip_source_keep(src);
#line 242
        zip_discard(za___0);
        }
#line 243
        return ((zip_t *)((void *)0));
      } else
#line 238
      if (flags & 4U) {
        {
#line 239
        _zip_error_copy(error, & za___0->error);
#line 241
        zip_source_keep(src);
#line 242
        zip_discard(za___0);
        }
#line 243
        return ((zip_t *)((void *)0));
      }
    }
#line 228
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 248
  za___0->ch_flags = za___0->flags;
#line 250
  return (za___0);
}
}
#line 255 "/root/libzip/lib/zip_open.c"
void _zip_set_open_error(int *zep , zip_error_t *err , int ze ) 
{ 
  int __cil_tmp5 ;
  int *__cil_tmp6 ;

  {
#line 257
  if (err) {
    {
#line 258
    ze = zip_error_code_zip(err);
#line 259
    __cil_tmp5 = zip_error_system_type(err);
    }
#line 259
    if (__cil_tmp5 == 1) {
      {
#line 260
      __cil_tmp6 = __errno_location();
#line 260
      *__cil_tmp6 = zip_error_code_system(err);
      }
    }
  }
#line 264
  if (zep) {
#line 265
    *zep = ze;
  }
#line 267
  return;
}
}
#line 276 "/root/libzip/lib/zip_open.c"
static zip_cdir_t *_zip_read_cdir(zip_t *za___0 , zip_buffer_t *buffer , zip_uint64_t buf_offset ,
                                  zip_error_t *error ) 
{ 
  zip_cdir_t *cd ;
  zip_uint16_t comment_len ;
  zip_uint64_t i ;
  zip_uint64_t left ;
  zip_uint64_t eocd_offset ;
  zip_uint64_t __cil_tmp10 ;
  zip_buffer_t *cd_buffer ;
  zip_uint64_t __cil_tmp12 ;
  zip_uint8_t *__cil_tmp13 ;
  int __cil_tmp14 ;
  zip_uint8_t *__cil_tmp15 ;
  int __cil_tmp16 ;
  zip_uint64_t tail_len ;
  zip_uint8_t *__cil_tmp22 ;
  zip_string_t *__cil_tmp23 ;
  zip_uint8_t *data ;
  int __cil_tmp27 ;
  zip_int64_t __cil_tmp28 ;
  zip_int64_t entry_size ;
  int ok ;
  zip_int64_t offset ;
  zip_int64_t __cil_tmp36 ;

  {
  {
#line 281
  __cil_tmp10 = _zip_buffer_offset(buffer);
#line 281
  eocd_offset = __cil_tmp10;
#line 284
  __cil_tmp12 = _zip_buffer_left(buffer);
  }
#line 284
  if (__cil_tmp12 < 22UL) {
    {
#line 286
    zip_error_set(error, 19, 0);
    }
#line 287
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 291
  __cil_tmp13 = _zip_buffer_get(buffer, (zip_uint64_t )4);
#line 291
  __cil_tmp14 = memcmp((void const   *)__cil_tmp13, (void const   *)"PK\005\006",
                       4UL);
  }
#line 291
  if (__cil_tmp14 != 0) {
    {
#line 292
    zip_error_set(error, 19, 0);
    }
#line 293
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 296
  __cil_tmp15 = _zip_buffer_data(buffer);
#line 296
  __cil_tmp16 = memcmp((void const   *)((__cil_tmp15 + eocd_offset) - 20), (void const   *)"PK\006\a",
                       4UL);
  }
#line 296
  if (eocd_offset >= 20UL) {
#line 296
    if (__cil_tmp16 == 0) {
      {
#line 297
      _zip_buffer_set_offset(buffer, eocd_offset - 20UL);
#line 298
      cd = _zip_read_eocd64(za___0->src, buffer, buf_offset, za___0->flags, error);
      }
    } else {
      {
#line 301
      _zip_buffer_set_offset(buffer, eocd_offset);
#line 302
      cd = _zip_read_eocd(buffer, buf_offset, za___0->flags, error);
      }
    }
  } else {
    {
#line 301
    _zip_buffer_set_offset(buffer, eocd_offset);
#line 302
    cd = _zip_read_eocd(buffer, buf_offset, za___0->flags, error);
    }
  }
#line 305
  if ((unsigned long )cd == (unsigned long )((void *)0)) {
#line 306
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 308
  _zip_buffer_set_offset(buffer, eocd_offset + 20UL);
#line 309
  comment_len = _zip_buffer_get_16(buffer);
  }
#line 311
  if (cd->offset + cd->size > buf_offset + eocd_offset) {
    {
#line 313
    zip_error_set(error, 21, 0);
#line 314
    _zip_cdir_free(cd);
    }
#line 315
    return ((zip_cdir_t *)((void *)0));
  }
#line 318
  if ((int )comment_len) {
    _L: 
    {
#line 321
    _zip_buffer_set_offset(buffer, eocd_offset + 22UL);
#line 322
    tail_len = _zip_buffer_left(buffer);
    }
#line 324
    if (tail_len < (unsigned long )comment_len) {
      {
#line 325
      zip_error_set(error, 21, 0);
#line 326
      _zip_cdir_free(cd);
      }
#line 327
      return ((zip_cdir_t *)((void *)0));
    } else
#line 324
    if (za___0->open_flags & 4U) {
#line 324
      if (tail_len != (unsigned long )comment_len) {
        {
#line 325
        zip_error_set(error, 21, 0);
#line 326
        _zip_cdir_free(cd);
        }
#line 327
        return ((zip_cdir_t *)((void *)0));
      }
    }
#line 330
    if (comment_len) {
      {
#line 331
      __cil_tmp22 = _zip_buffer_get(buffer, (zip_uint64_t )comment_len);
#line 331
      __cil_tmp23 = _zip_string_new(__cil_tmp22, comment_len, 0U, error);
#line 331
      cd->comment = __cil_tmp23;
      }
#line 331
      if ((unsigned long )cd->comment == (unsigned long )((void *)0)) {
        {
#line 332
        _zip_cdir_free(cd);
        }
#line 333
        return ((zip_cdir_t *)((void *)0));
      }
    }
  } else
#line 318
  if (za___0->open_flags & 4U) {
#line 318
    goto _L;
  }
#line 338
  if (cd->offset >= buf_offset) {
    {
#line 341
    _zip_buffer_set_offset(buffer, cd->offset - buf_offset);
#line 343
    data = _zip_buffer_get(buffer, cd->size);
    }
#line 343
    if ((unsigned long )data == (unsigned long )((void *)0)) {
      {
#line 344
      zip_error_set(error, 21, 0);
#line 345
      _zip_cdir_free(cd);
      }
#line 346
      return ((zip_cdir_t *)((void *)0));
    }
    {
#line 348
    cd_buffer = _zip_buffer_new(data, cd->size);
    }
#line 348
    if ((unsigned long )cd_buffer == (unsigned long )((void *)0)) {
      {
#line 349
      zip_error_set(error, 14, 0);
#line 350
      _zip_cdir_free(cd);
      }
#line 351
      return ((zip_cdir_t *)((void *)0));
    }
  } else {
    {
#line 355
    cd_buffer = (zip_buffer_t *)((void *)0);
#line 357
    __cil_tmp27 = zip_source_seek(za___0->src, (zip_int64_t )cd->offset, 0);
    }
#line 357
    if (__cil_tmp27 < 0) {
      {
#line 358
      _zip_error_set_from_source(error, za___0->src);
#line 359
      _zip_cdir_free(cd);
      }
#line 360
      return ((zip_cdir_t *)((void *)0));
    }
    {
#line 364
    __cil_tmp28 = zip_source_tell(za___0->src);
    }
#line 364
    if (__cil_tmp28 != (zip_int64_t )cd->offset) {
      {
#line 365
      zip_error_set(error, 19, 0);
#line 366
      _zip_cdir_free(cd);
      }
#line 367
      return ((zip_cdir_t *)((void *)0));
    }
  }
#line 371
  left = cd->size;
#line 372
  i = (zip_uint64_t )0;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;

#line 373
    if (i < cd->nentry) {
#line 373
      if (! (left > 0UL)) {
#line 373
        goto while_break;
      }
    } else {
#line 373
      goto while_break;
    }
    {
#line 375
    entry_size = _zip_dirent_read((cd->entry + i)->orig, za___0->src, cd_buffer, 0,
                                  error);
#line 375
    (cd->entry + i)->orig = _zip_dirent_new();
    }
#line 375
    if ((unsigned long )(cd->entry + i)->orig == (unsigned long )((void *)0)) {
      {
#line 376
      _zip_cdir_free(cd);
#line 377
      _zip_buffer_free(cd_buffer);
      }
#line 378
      return ((zip_cdir_t *)((void *)0));
    } else
#line 375
    if (entry_size < 0L) {
      {
#line 376
      _zip_cdir_free(cd);
#line 377
      _zip_buffer_free(cd_buffer);
      }
#line 378
      return ((zip_cdir_t *)((void *)0));
    }
#line 380
    i ++;
#line 381
    left -= (zip_uint64_t )entry_size;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 384
  if (i != cd->nentry) {
    {
#line 385
    zip_error_set(error, 21, 0);
#line 386
    _zip_buffer_free(cd_buffer);
#line 387
    _zip_cdir_free(cd);
    }
#line 388
    return ((zip_cdir_t *)((void *)0));
  }
#line 391
  if (za___0->open_flags & 4U) {
#line 394
    if (cd_buffer) {
      {
#line 395
      ok = _zip_buffer_eof(cd_buffer);
      }
    } else {
      {
#line 398
      __cil_tmp36 = zip_source_tell(za___0->src);
#line 398
      offset = __cil_tmp36;
      }
#line 400
      if (offset < 0L) {
        {
#line 401
        _zip_error_set_from_source(error, za___0->src);
#line 402
        _zip_buffer_free(cd_buffer);
#line 403
        _zip_cdir_free(cd);
        }
#line 404
        return ((zip_cdir_t *)((void *)0));
      }
#line 406
      ok = (zip_uint64_t )offset == cd->offset + cd->size;
    }
#line 409
    if (! ok) {
      {
#line 410
      zip_error_set(error, 21, 0);
#line 411
      _zip_buffer_free(cd_buffer);
#line 412
      _zip_cdir_free(cd);
      }
#line 413
      return ((zip_cdir_t *)((void *)0));
    }
  }
  {
#line 417
  _zip_buffer_free(cd_buffer);
  }
#line 418
  return (cd);
}
}
#line 429 "/root/libzip/lib/zip_open.c"
static zip_int64_t _zip_checkcons(zip_t *za___0 , zip_cdir_t *cd , zip_error_t *error ) 
{ 
  zip_uint64_t i ;
  zip_uint64_t min ;
  zip_uint64_t max ;
  zip_uint64_t j ;
  struct zip_dirent temp ;
  zip_uint16_t __cil_tmp9 ;
  int __cil_tmp10 ;
  zip_int64_t __cil_tmp11 ;
  int __cil_tmp12 ;
  zip_int64_t tmp ;

  {
  {
#line 435
  _zip_dirent_init(& temp);
  }
#line 436
  if (cd->nentry) {
#line 437
    max = ((cd->entry + 0)->orig)->offset;
#line 438
    min = ((cd->entry + 0)->orig)->offset;
  } else {
#line 441
    max = (zip_uint64_t )0;
#line 441
    min = max;
  }
#line 443
  i = (zip_uint64_t )0;
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;

#line 443
    if (! (i < cd->nentry)) {
#line 443
      goto while_break;
    }
#line 444
    if (((cd->entry + i)->orig)->offset < min) {
#line 445
      min = ((cd->entry + i)->orig)->offset;
    }
#line 446
    if (min > cd->offset) {
      {
#line 447
      zip_error_set(error, 19, 0);
      }
#line 448
      return ((zip_int64_t )-1);
    }
    {
#line 451
    __cil_tmp9 = _zip_string_length(((cd->entry + i)->orig)->filename);
#line 451
    j = ((((cd->entry + i)->orig)->offset + ((cd->entry + i)->orig)->comp_size) + (unsigned long )__cil_tmp9) + 30UL;
    }
#line 453
    if (j > max) {
#line 454
      max = j;
    }
#line 455
    if (max > cd->offset) {
      {
#line 456
      zip_error_set(error, 19, 0);
      }
#line 457
      return ((zip_int64_t )-1);
    }
    {
#line 460
    __cil_tmp10 = zip_source_seek(za___0->src, (zip_int64_t )((cd->entry + i)->orig)->offset,
                                  0);
    }
#line 460
    if (__cil_tmp10 < 0) {
      {
#line 461
      _zip_error_set_from_source(error, za___0->src);
      }
#line 462
      return ((zip_int64_t )-1);
    }
    {
#line 465
    __cil_tmp11 = _zip_dirent_read(& temp, za___0->src, (zip_buffer_t *)((void *)0),
                                   1, error);
    }
#line 465
    if (__cil_tmp11 == -1L) {
      {
#line 466
      _zip_dirent_finalize(& temp);
      }
#line 467
      return ((zip_int64_t )-1);
    }
    {
#line 470
    __cil_tmp12 = _zip_headercomp((cd->entry + i)->orig, & temp);
    }
#line 470
    if (__cil_tmp12 != 0) {
      {
#line 471
      zip_error_set(error, 21, 0);
#line 472
      _zip_dirent_finalize(& temp);
      }
#line 473
      return ((zip_int64_t )-1);
    }
    {
#line 476
    ((cd->entry + i)->orig)->extra_fields = _zip_ef_merge(((cd->entry + i)->orig)->extra_fields,
                                                          temp.extra_fields);
#line 477
    ((cd->entry + i)->orig)->local_extra_fields_read = 1;
#line 478
    temp.extra_fields = (zip_extra_field_t *)((void *)0);
#line 480
    _zip_dirent_finalize(& temp);
#line 443
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 483
  if (max - min < 0xffffffffffffffffUL) {
#line 483
    tmp = (zip_int64_t )(max - min);
  } else {
#line 483
    tmp = -1L;
  }
#line 483
  return (tmp);
}
}
#line 492 "/root/libzip/lib/zip_open.c"
static int _zip_headercomp(zip_dirent_t *central , zip_dirent_t *local ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 494
  __cil_tmp3 = _zip_string_equal(central->filename, local->filename);
  }
#line 494
  if ((int )central->version_needed != (int )local->version_needed) {
#line 503
    return (-1);
  } else
#line 494
  if (central->comp_method != local->comp_method) {
#line 503
    return (-1);
  } else
#line 494
  if (central->last_mod != local->last_mod) {
#line 503
    return (-1);
  } else
#line 494
  if (! __cil_tmp3) {
#line 503
    return (-1);
  }
#line 505
  if (central->crc != local->crc) {
    _L: 
#line 509
    if (((int )local->bitflags & 8) == 0) {
#line 511
      return (-1);
    } else
#line 509
    if (local->crc != 0U) {
#line 511
      return (-1);
    } else
#line 509
    if (local->comp_size != 0UL) {
#line 511
      return (-1);
    } else
#line 509
    if (local->uncomp_size != 0UL) {
#line 511
      return (-1);
    }
  } else
#line 505
  if (central->comp_size != local->comp_size) {
#line 505
    goto _L;
  } else
#line 505
  if (central->uncomp_size != local->uncomp_size) {
#line 505
    goto _L;
  }
#line 514
  return (0);
}
}
#line 519 "/root/libzip/lib/zip_open.c"
static zip_t *_zip_allocate_new(zip_source_t *src , unsigned int flags , zip_error_t *error ) 
{ 
  zip_t *za___0 ;

  {
  {
#line 523
  za___0 = _zip_new(error);
  }
#line 523
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 524
    return ((zip_t *)((void *)0));
  }
#line 527
  za___0->src = src;
#line 528
  za___0->open_flags = flags;
#line 529
  if (flags & 16U) {
#line 530
    za___0->flags |= 2U;
#line 531
    za___0->ch_flags |= 2U;
  }
#line 533
  return (za___0);
}
}
#line 541 "/root/libzip/lib/zip_open.c"
static exists_t _zip_file_exists(zip_source_t *src , zip_error_t *error ) 
{ 
  struct zip_stat st ;
  int __cil_tmp4 ;
  zip_error_t *src_error ;
  zip_error_t *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int tmp ;

  {
  {
#line 545
  zip_stat_init(& st);
#line 546
  __cil_tmp4 = zip_source_stat(src, & st);
  }
#line 546
  if (__cil_tmp4 != 0) {
    {
#line 547
    __cil_tmp6 = zip_source_error(src);
#line 547
    src_error = __cil_tmp6;
#line 548
    __cil_tmp8 = zip_error_code_system(src_error);
#line 548
    __cil_tmp7 = zip_error_code_zip(src_error);
    }
#line 548
    if (__cil_tmp7 == 5) {
#line 548
      if (__cil_tmp8 == 2) {
#line 549
        return ((exists_t )0);
      }
    }
    {
#line 551
    _zip_error_copy(error, src_error);
    }
#line 552
    return ((exists_t )-1);
  }
#line 555
  if (st.valid & 4UL) {
#line 555
    if (st.size == 0UL) {
#line 555
      tmp = 1;
    } else {
#line 555
      tmp = 2;
    }
  } else {
#line 555
    tmp = 2;
  }
#line 555
  return ((exists_t )tmp);
}
}
#line 560 "/root/libzip/lib/zip_open.c"
static zip_cdir_t *_zip_find_central_dir(zip_t *za___0 , zip_uint64_t len ) 
{ 
  zip_cdir_t *cdir ;
  zip_cdir_t *cdirnew ;
  zip_uint8_t *match ;
  zip_int64_t buf_offset ;
  zip_uint64_t buflen ;
  zip_int64_t a ;
  zip_int64_t best ;
  zip_error_t error ;
  zip_buffer_t *buffer ;
  zip_uint64_t tmp ;
  int __cil_tmp13 ;
  zip_error_t *src_error ;
  zip_error_t *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  zip_uint64_t __cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  zip_uint8_t *__cil_tmp23 ;
  zip_uint8_t *__cil_tmp29 ;

  {
#line 571
  if (len < 22UL) {
    {
#line 572
    zip_error_set(& za___0->error, 19, 0);
    }
#line 573
    return ((zip_cdir_t *)((void *)0));
  }
#line 576
  if (len < 65578UL) {
#line 576
    tmp = len;
  } else {
#line 576
    tmp = 65578UL;
  }
  {
#line 576
  buflen = tmp;
#line 577
  __cil_tmp13 = zip_source_seek(za___0->src, - ((zip_int64_t )buflen), 2);
  }
#line 577
  if (__cil_tmp13 < 0) {
    {
#line 578
    __cil_tmp15 = zip_source_error(za___0->src);
#line 578
    src_error = __cil_tmp15;
#line 579
    __cil_tmp17 = zip_error_code_system(src_error);
#line 579
    __cil_tmp16 = zip_error_code_zip(src_error);
    }
#line 579
    if (__cil_tmp16 != 4) {
      {
#line 581
      _zip_error_copy(& za___0->error, src_error);
      }
#line 582
      return ((zip_cdir_t *)((void *)0));
    } else
#line 579
    if (__cil_tmp17 != 27) {
      {
#line 581
      _zip_error_copy(& za___0->error, src_error);
      }
#line 582
      return ((zip_cdir_t *)((void *)0));
    }
  }
  {
#line 585
  buf_offset = zip_source_tell(za___0->src);
  }
#line 585
  if (buf_offset < 0L) {
    {
#line 586
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 587
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 590
  buffer = _zip_buffer_new_from_source(za___0->src, buflen, (zip_uint8_t *)((void *)0),
                                       & za___0->error);
  }
#line 590
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 591
    return ((zip_cdir_t *)((void *)0));
  }
#line 594
  best = (zip_int64_t )-1;
#line 595
  cdir = (zip_cdir_t *)((void *)0);
#line 596
  if (buflen >= 65578UL) {
    {
#line 598
    _zip_buffer_set_offset(buffer, (zip_uint64_t )20);
    }
  }
  {
#line 600
  zip_error_set(& error, 19, 0);
#line 602
  match = _zip_buffer_get(buffer, (zip_uint64_t )0);
  }
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 603
    __cil_tmp21 = _zip_buffer_left(buffer);
#line 603
    __cil_tmp22 = _zip_memmem((unsigned char const   *)match, __cil_tmp21 - 18UL,
                              (unsigned char const   *)"PK\005\006", (size_t )4);
#line 603
    match = __cil_tmp22;
    }
#line 603
    if (! ((unsigned long )match != (unsigned long )((void *)0))) {
#line 603
      goto while_break;
    }
    {
#line 604
    __cil_tmp23 = _zip_buffer_data(buffer);
#line 604
    _zip_buffer_set_offset(buffer, (zip_uint64_t )(match - __cil_tmp23));
#line 605
    cdirnew = _zip_read_cdir(za___0, buffer, (zip_uint64_t )buf_offset, & error);
    }
#line 605
    if ((unsigned long )cdirnew != (unsigned long )((void *)0)) {
#line 606
      if (cdir) {
#line 607
        if (best <= 0L) {
          {
#line 608
          best = _zip_checkcons(za___0, cdir, & error);
          }
        }
        {
#line 611
        a = _zip_checkcons(za___0, cdirnew, & error);
        }
#line 612
        if (best < a) {
          {
#line 613
          _zip_cdir_free(cdir);
#line 614
          cdir = cdirnew;
#line 615
          best = a;
          }
        } else {
          {
#line 618
          _zip_cdir_free(cdirnew);
          }
        }
      } else {
#line 622
        cdir = cdirnew;
#line 623
        if (za___0->open_flags & 4U) {
          {
#line 624
          best = _zip_checkcons(za___0, cdir, & error);
          }
        } else {
#line 626
          best = (zip_int64_t )0;
        }
      }
#line 629
      cdirnew = (zip_cdir_t *)((void *)0);
    }
    {
#line 632
    match ++;
#line 633
    __cil_tmp29 = _zip_buffer_data(buffer);
#line 633
    _zip_buffer_set_offset(buffer, (zip_uint64_t )(match - __cil_tmp29));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 636
  _zip_buffer_free(buffer);
  }
#line 638
  if (best < 0L) {
    {
#line 639
    _zip_error_copy(& za___0->error, & error);
#line 640
    _zip_cdir_free(cdir);
    }
#line 641
    return ((zip_cdir_t *)((void *)0));
  }
#line 644
  return (cdir);
}
}
#line 649 "/root/libzip/lib/zip_open.c"
static unsigned char *_zip_memmem(unsigned char const   *big , size_t biglen , unsigned char const   *little ,
                                  size_t littlelen ) 
{ 
  unsigned char const   *p ;
  void *__cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 653
  if (biglen < littlelen) {
#line 654
    return ((unsigned char *)((void *)0));
  } else
#line 653
  if (littlelen == 0UL) {
#line 654
    return ((unsigned char *)((void *)0));
  }
#line 655
  p = big - 1;
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 656
    __cil_tmp6 = memchr((void const   *)(p + 1), (int )*(little + 0), ((size_t )(big - (p + 1)) + (biglen - littlelen)) + 1UL);
#line 656
    p = (unsigned char const   *)__cil_tmp6;
    }
#line 656
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 656
      goto while_break;
    }
    {
#line 658
    __cil_tmp7 = memcmp((void const   *)(p + 1), (void const   *)(little + 1), littlelen - 1UL);
    }
#line 658
    if (__cil_tmp7 == 0) {
#line 659
      return ((unsigned char *)p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 662
  return ((unsigned char *)((void *)0));
}
}
#line 667 "/root/libzip/lib/zip_open.c"
static zip_cdir_t *_zip_read_eocd(zip_buffer_t *buffer , zip_uint64_t buf_offset ,
                                  unsigned int flags , zip_error_t *error ) 
{ 
  zip_cdir_t *cd ;
  zip_uint64_t i ;
  zip_uint64_t nentry ;
  zip_uint64_t size ;
  zip_uint64_t offset ;
  zip_uint64_t eocd_offset ;
  zip_uint64_t __cil_tmp11 ;
  zip_uint32_t __cil_tmp13 ;
  zip_uint16_t __cil_tmp14 ;
  zip_uint16_t __cil_tmp15 ;
  zip_uint32_t __cil_tmp16 ;
  zip_uint32_t __cil_tmp17 ;

  {
  {
#line 672
  __cil_tmp11 = _zip_buffer_left(buffer);
  }
#line 672
  if (__cil_tmp11 < 22UL) {
    {
#line 673
    zip_error_set(error, 21, 0);
    }
#line 674
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 677
  eocd_offset = _zip_buffer_offset(buffer);
#line 679
  _zip_buffer_get(buffer, (zip_uint64_t )4);
#line 681
  __cil_tmp13 = _zip_buffer_get_32(buffer);
  }
#line 681
  if (__cil_tmp13 != 0U) {
    {
#line 682
    zip_error_set(error, 1, 0);
    }
#line 683
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 687
  __cil_tmp14 = _zip_buffer_get_16(buffer);
#line 687
  i = (zip_uint64_t )__cil_tmp14;
#line 689
  __cil_tmp15 = _zip_buffer_get_16(buffer);
#line 689
  nentry = (zip_uint64_t )__cil_tmp15;
  }
#line 691
  if (nentry != i) {
    {
#line 692
    zip_error_set(error, 19, 0);
    }
#line 693
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 696
  __cil_tmp16 = _zip_buffer_get_32(buffer);
#line 696
  size = (zip_uint64_t )__cil_tmp16;
#line 697
  __cil_tmp17 = _zip_buffer_get_32(buffer);
#line 697
  offset = (zip_uint64_t )__cil_tmp17;
  }
#line 699
  if (offset + size < offset) {
    {
#line 700
    zip_error_set(error, 4, 27);
    }
#line 701
    return ((zip_cdir_t *)((void *)0));
  }
#line 704
  if (offset + size > buf_offset + eocd_offset) {
    {
#line 706
    zip_error_set(error, 21, 0);
    }
#line 707
    return ((zip_cdir_t *)((void *)0));
  }
#line 710
  if (flags & 4U) {
#line 710
    if (offset + size != buf_offset + eocd_offset) {
      {
#line 711
      zip_error_set(error, 21, 0);
      }
#line 712
      return ((zip_cdir_t *)((void *)0));
    }
  }
  {
#line 715
  cd = _zip_cdir_new(nentry, error);
  }
#line 715
  if ((unsigned long )cd == (unsigned long )((void *)0)) {
#line 716
    return ((zip_cdir_t *)((void *)0));
  }
#line 718
  cd->size = size;
#line 719
  cd->offset = offset;
#line 721
  return (cd);
}
}
#line 726 "/root/libzip/lib/zip_open.c"
static zip_cdir_t *_zip_read_eocd64(zip_source_t *src , zip_buffer_t *buffer , zip_uint64_t buf_offset ,
                                    unsigned int flags , zip_error_t *error ) 
{ 
  zip_cdir_t *cd ;
  zip_uint64_t offset ;
  zip_uint8_t eocd[56] ;
  zip_uint64_t eocd_offset ;
  zip_uint64_t size ;
  zip_uint64_t nentry ;
  zip_uint64_t i ;
  zip_uint64_t eocdloc_offset ;
  int free_buffer ;
  zip_uint32_t num_disks ;
  zip_uint32_t num_disks64 ;
  zip_uint32_t eocd_disk ;
  zip_uint32_t eocd_disk64 ;
  zip_uint16_t __cil_tmp20 ;
  zip_uint16_t __cil_tmp21 ;
  zip_uint64_t __cil_tmp23 ;
  int __cil_tmp24 ;
  zip_uint8_t *__cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp35 ;

  {
  {
#line 736
  eocdloc_offset = _zip_buffer_offset(buffer);
#line 738
  _zip_buffer_get(buffer, (zip_uint64_t )4);
#line 740
  __cil_tmp20 = _zip_buffer_get_16(buffer);
#line 740
  num_disks = (zip_uint32_t )__cil_tmp20;
#line 741
  __cil_tmp21 = _zip_buffer_get_16(buffer);
#line 741
  eocd_disk = (zip_uint32_t )__cil_tmp21;
#line 742
  eocd_offset = _zip_buffer_get_64(buffer);
  }
#line 744
  if (eocd_offset > 0xffffffffffffffffUL) {
    {
#line 745
    zip_error_set(error, 4, 27);
    }
#line 746
    return ((zip_cdir_t *)((void *)0));
  } else
#line 744
  if (eocd_offset + 56UL < eocd_offset) {
    {
#line 745
    zip_error_set(error, 4, 27);
    }
#line 746
    return ((zip_cdir_t *)((void *)0));
  }
#line 749
  if (eocd_offset + 56UL > eocdloc_offset + buf_offset) {
    {
#line 750
    zip_error_set(error, 21, 0);
    }
#line 751
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 754
  __cil_tmp23 = _zip_buffer_size(buffer);
  }
#line 754
  if (eocd_offset >= buf_offset) {
#line 754
    if (eocd_offset + 56UL <= buf_offset + __cil_tmp23) {
      {
#line 755
      _zip_buffer_set_offset(buffer, eocd_offset - buf_offset);
#line 756
      free_buffer = 0;
      }
    } else {
#line 754
      goto _L;
    }
  } else {
    _L: 
    {
#line 759
    __cil_tmp24 = zip_source_seek(src, (zip_int64_t )eocd_offset, 0);
    }
#line 759
    if (__cil_tmp24 < 0) {
      {
#line 760
      _zip_error_set_from_source(error, src);
      }
#line 761
      return ((zip_cdir_t *)((void *)0));
    }
    {
#line 763
    buffer = _zip_buffer_new_from_source(src, (zip_uint64_t )56, eocd, error);
    }
#line 763
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 764
      return ((zip_cdir_t *)((void *)0));
    }
#line 766
    free_buffer = 1;
  }
  {
#line 769
  __cil_tmp26 = _zip_buffer_get(buffer, (zip_uint64_t )4);
#line 769
  __cil_tmp27 = memcmp((void const   *)__cil_tmp26, (void const   *)"PK\006\006",
                       4UL);
  }
#line 769
  if (__cil_tmp27 != 0) {
    {
#line 770
    zip_error_set(error, 21, 0);
    }
#line 771
    if (free_buffer) {
      {
#line 772
      _zip_buffer_free(buffer);
      }
    }
#line 774
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 777
  size = _zip_buffer_get_64(buffer);
  }
#line 779
  if (flags & 4U) {
#line 779
    if ((size + eocd_offset) + 12UL != buf_offset + eocdloc_offset) {
      {
#line 780
      zip_error_set(error, 21, 0);
      }
#line 781
      if (free_buffer) {
        {
#line 782
        _zip_buffer_free(buffer);
        }
      }
#line 784
      return ((zip_cdir_t *)((void *)0));
    }
  }
  {
#line 787
  _zip_buffer_get(buffer, (zip_uint64_t )4);
#line 789
  num_disks64 = _zip_buffer_get_32(buffer);
#line 790
  eocd_disk64 = _zip_buffer_get_32(buffer);
  }
#line 795
  if (num_disks == 65535U) {
#line 796
    num_disks = num_disks64;
  }
#line 798
  if (eocd_disk == 65535U) {
#line 799
    eocd_disk = eocd_disk64;
  }
#line 801
  if (flags & 4U) {
#line 801
    if (eocd_disk != eocd_disk64) {
      {
#line 802
      zip_error_set(error, 21, 0);
      }
#line 803
      return ((zip_cdir_t *)((void *)0));
    } else
#line 801
    if (num_disks != num_disks64) {
      {
#line 802
      zip_error_set(error, 21, 0);
      }
#line 803
      return ((zip_cdir_t *)((void *)0));
    }
  }
#line 805
  if (num_disks != 0U) {
    {
#line 806
    zip_error_set(error, 1, 0);
    }
#line 807
    return ((zip_cdir_t *)((void *)0));
  } else
#line 805
  if (eocd_disk != 0U) {
    {
#line 806
    zip_error_set(error, 1, 0);
    }
#line 807
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 810
  nentry = _zip_buffer_get_64(buffer);
#line 811
  i = _zip_buffer_get_64(buffer);
  }
#line 813
  if (nentry != i) {
    {
#line 814
    zip_error_set(error, 1, 0);
    }
#line 815
    if (free_buffer) {
      {
#line 816
      _zip_buffer_free(buffer);
      }
    }
#line 818
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 821
  size = _zip_buffer_get_64(buffer);
#line 822
  offset = _zip_buffer_get_64(buffer);
#line 824
  __cil_tmp35 = _zip_buffer_ok(buffer);
  }
#line 824
  if (! __cil_tmp35) {
    {
#line 825
    zip_error_set(error, 20, 0);
    }
#line 826
    if (free_buffer) {
      {
#line 827
      _zip_buffer_free(buffer);
      }
    }
#line 829
    return ((zip_cdir_t *)((void *)0));
  }
#line 832
  if (free_buffer) {
    {
#line 833
    _zip_buffer_free(buffer);
    }
  }
#line 836
  if (offset > 0xffffffffffffffffUL) {
    {
#line 837
    zip_error_set(error, 4, 27);
    }
#line 838
    return ((zip_cdir_t *)((void *)0));
  } else
#line 836
  if (offset + size < offset) {
    {
#line 837
    zip_error_set(error, 4, 27);
    }
#line 838
    return ((zip_cdir_t *)((void *)0));
  }
#line 840
  if (flags & 4U) {
#line 840
    if (offset + size != eocd_offset) {
      {
#line 841
      zip_error_set(error, 21, 0);
      }
#line 842
      return ((zip_cdir_t *)((void *)0));
    }
  }
  {
#line 845
  cd = _zip_cdir_new(nentry, error);
  }
#line 845
  if ((unsigned long )cd == (unsigned long )((void *)0)) {
#line 846
    return ((zip_cdir_t *)((void *)0));
  }
#line 849
  cd->size = size;
#line 850
  cd->offset = offset;
#line 852
  return (cd);
}
}
#line 45 "/root/libzip/lib/zip_new.c"
zip_t *_zip_new(zip_error_t *error ) 
{ 
  zip_t *za___0 ;
  void *__cil_tmp3 ;

  {
  {
#line 49
  __cil_tmp3 = malloc(sizeof(struct zip ));
#line 49
  za___0 = (zip_t *)__cil_tmp3;
  }
#line 50
  if (! za___0) {
    {
#line 51
    zip_error_set(error, 14, 0);
    }
#line 52
    return ((zip_t *)((void *)0));
  }
  {
#line 55
  za___0->names = _zip_hash_new((zip_uint16_t )8192, error);
  }
#line 55
  if ((unsigned long )za___0->names == (unsigned long )((void *)0)) {
    {
#line 56
    free((void *)za___0);
    }
#line 57
    return ((zip_t *)((void *)0));
  }
  {
#line 60
  za___0->src = (zip_source_t *)((void *)0);
#line 61
  za___0->open_flags = 0U;
#line 62
  zip_error_init(& za___0->error);
#line 63
  za___0->ch_flags = 0U;
#line 63
  za___0->flags = za___0->ch_flags;
#line 64
  za___0->default_password = (char *)((void *)0);
#line 65
  za___0->comment_changes = (zip_string_t *)((void *)0);
#line 65
  za___0->comment_orig = za___0->comment_changes;
#line 66
  za___0->comment_changed = 0;
#line 67
  za___0->nentry_alloc = (zip_uint64_t )0;
#line 67
  za___0->nentry = za___0->nentry_alloc;
#line 68
  za___0->entry = (zip_entry_t *)((void *)0);
#line 69
  za___0->nopen_source_alloc = 0U;
#line 69
  za___0->nopen_source = za___0->nopen_source_alloc;
#line 70
  za___0->open_source = (zip_source_t **)((void *)0);
#line 71
  za___0->tempdir = (char *)((void *)0);
  }
#line 73
  return (za___0);
}
}
#line 44 "/root/libzip/lib/zip_name_locate.c"
zip_int64_t zip_name_locate(zip_t *za___0 , char const   *fname , zip_flags_t flags ) 
{ 
  zip_int64_t __cil_tmp4 ;

  {
  {
#line 46
  __cil_tmp4 = _zip_name_locate(za___0, fname, flags, & za___0->error);
  }
#line 46
  return (__cil_tmp4);
}
}
#line 51 "/root/libzip/lib/zip_name_locate.c"
zip_int64_t _zip_name_locate(zip_t *za___0 , char const   *fname , zip_flags_t flags ,
                             zip_error_t *error ) 
{ 
  int (*cmp)(char const   * , char const   * ) ;
  char const   *fn ;
  char const   *p ;
  zip_uint64_t i ;
  int (*tmp)(char const   *__s1 , char const   *__s2 ) ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  zip_int64_t __cil_tmp14 ;

  {
#line 57
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 58
    return ((zip_int64_t )-1);
  }
#line 60
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    {
#line 61
    zip_error_set(error, 18, 0);
    }
#line 62
    return ((zip_int64_t )-1);
  }
#line 65
  if (flags & 4099U) {
#line 67
    if (flags & 1U) {
#line 67
      tmp = & strcasecmp;
    } else {
#line 67
      tmp = & strcmp;
    }
#line 67
    cmp = tmp;
#line 69
    i = (zip_uint64_t )0;
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: ;
#line 69
      if (! (i < za___0->nentry)) {
#line 69
        goto while_break;
      }
      {
#line 70
      fn = _zip_get_name(za___0, i, flags, error);
      }
#line 73
      if ((unsigned long )fn == (unsigned long )((void *)0)) {
#line 74
        goto while_continue;
      }
#line 76
      if (flags & 2U) {
        {
#line 77
        __cil_tmp11 = strrchr(fn, '/');
#line 77
        p = (char const   *)__cil_tmp11;
        }
#line 78
        if (p) {
#line 79
          fn = p + 1;
        }
      }
      {
#line 82
      __cil_tmp12 = (*cmp)(fname, fn);
      }
#line 82
      if (__cil_tmp12 == 0) {
        {
#line 83
        _zip_error_clear(error);
        }
#line 84
        return ((zip_int64_t )i);
      }
#line 69
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 88
    zip_error_set(error, 9, 0);
    }
#line 89
    return ((zip_int64_t )-1);
  } else {
    {
#line 92
    __cil_tmp14 = _zip_hash_lookup(za___0->names, (zip_uint8_t *)fname, flags, error);
    }
#line 92
    return (__cil_tmp14);
  }
}
}
#line 41 "/root/libzip/lib/zip_memdup.c"
void *_zip_memdup(void const   *mem , size_t len , zip_error_t *error ) 
{ 
  void *ret ;

  {
#line 45
  if (len == 0UL) {
#line 46
    return ((void *)0);
  }
  {
#line 48
  ret = malloc(len);
  }
#line 49
  if (! ret) {
    {
#line 50
    zip_error_set(error, 14, 0);
    }
#line 51
    return ((void *)0);
  }
  {
#line 54
  memcpy(ret, mem, len);
  }
#line 56
  return (ret);
}
}
#line 40 "/root/libzip/lib/zip_io_util.c"
int _zip_read(zip_source_t *src , zip_uint8_t *b , zip_uint64_t length , zip_error_t *error ) 
{ 
  zip_int64_t n ;

  {
#line 44
  if (length > 0xffffffffffffffffUL) {
    {
#line 45
    zip_error_set(error, 20, 0);
    }
#line 46
    return (-1);
  }
  {
#line 49
  n = zip_source_read(src, (void *)b, length);
  }
#line 49
  if (n < 0L) {
    {
#line 50
    _zip_error_set_from_source(error, src);
    }
#line 51
    return (-1);
  }
#line 54
  if (n < (zip_int64_t )length) {
    {
#line 55
    zip_error_set(error, 17, 0);
    }
#line 56
    return (-1);
  }
#line 59
  return (0);
}
}
#line 64 "/root/libzip/lib/zip_io_util.c"
zip_uint8_t *_zip_read_data(zip_buffer_t *buffer , zip_source_t *src , size_t length ,
                            int nulp , zip_error_t *error ) 
{ 
  zip_uint8_t *r ;
  int tmp ;
  void *__cil_tmp8 ;
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp10 ;
  int __cil_tmp11 ;
  zip_uint8_t *o ;

  {
#line 68
  if (length == 0UL) {
#line 68
    if (! nulp) {
#line 69
      return ((zip_uint8_t *)((void *)0));
    }
  }
#line 72
  if (nulp) {
#line 72
    tmp = 1;
  } else {
#line 72
    tmp = 0;
  }
  {
#line 72
  __cil_tmp8 = malloc(length + (unsigned long )tmp);
#line 72
  r = (zip_uint8_t *)__cil_tmp8;
  }
#line 73
  if (! r) {
    {
#line 74
    zip_error_set(error, 14, 0);
    }
#line 75
    return ((zip_uint8_t *)((void *)0));
  }
#line 78
  if (buffer) {
    {
#line 79
    __cil_tmp10 = _zip_buffer_get(buffer, length);
#line 79
    data = __cil_tmp10;
    }
#line 81
    if ((unsigned long )data == (unsigned long )((void *)0)) {
      {
#line 82
      zip_error_set(error, 14, 0);
#line 83
      free((void *)r);
      }
#line 84
      return ((zip_uint8_t *)((void *)0));
    }
    {
#line 86
    memcpy((void *)r, (void const   *)data, length);
    }
  } else {
    {
#line 89
    __cil_tmp11 = _zip_read(src, r, length, error);
    }
#line 89
    if (__cil_tmp11 < 0) {
      {
#line 90
      free((void *)r);
      }
#line 91
      return ((zip_uint8_t *)((void *)0));
    }
  }
#line 95
  if (nulp) {
#line 98
    *(r + length) = (zip_uint8_t )0;
#line 99
    o = r;
    {
#line 99
    while (1) {
      while_continue: /* CIL Label */ ;

#line 99
      if (! ((unsigned long )o < (unsigned long )(r + length))) {
#line 99
        goto while_break;
      }
#line 100
      if ((int )*o == 0) {
#line 101
        *o = (zip_uint8_t )' ';
      }
#line 99
      o ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 104
  return (r);
}
}
#line 109 "/root/libzip/lib/zip_io_util.c"
zip_string_t *_zip_read_string(zip_buffer_t *buffer , zip_source_t *src , zip_uint16_t len ,
                               int nulp , zip_error_t *error ) 
{ 
  zip_uint8_t *raw ;
  zip_string_t *s ;

  {
  {
#line 114
  raw = _zip_read_data(buffer, src, (size_t )len, nulp, error);
  }
#line 114
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
#line 115
    return ((zip_string_t *)((void *)0));
  }
  {
#line 117
  s = _zip_string_new(raw, len, 0U, error);
#line 118
  free((void *)raw);
  }
#line 119
  return (s);
}
}
#line 124 "/root/libzip/lib/zip_io_util.c"
int _zip_write(zip_t *za___0 , void const   *data , zip_uint64_t length ) 
{ 
  zip_int64_t n ;

  {
  {
#line 128
  n = zip_source_write(za___0->src, data, length);
  }
#line 128
  if (n < 0L) {
    {
#line 129
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 130
    return (-1);
  }
#line 132
  if ((zip_uint64_t )n != length) {
    {
#line 133
    zip_error_set(& za___0->error, 6, 4);
    }
#line 134
    return (-1);
  }
#line 137
  return (0);
}
}
#line 52 "/root/libzip/lib/zip_hash.c"
zip_hash_t *_zip_hash_new(zip_uint16_t table_size , zip_error_t *error ) 
{ 
  zip_hash_t *hash ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
#line 56
  if ((int )table_size == 0) {
    {
#line 57
    zip_error_set(error, 20, 0);
    }
#line 58
    return ((zip_hash_t *)((void *)0));
  }
  {
#line 61
  __cil_tmp4 = malloc(sizeof(zip_hash_t ));
#line 61
  hash = (zip_hash_t *)__cil_tmp4;
  }
#line 61
  if ((unsigned long )hash == (unsigned long )((void *)0)) {
    {
#line 62
    zip_error_set(error, 14, 0);
    }
#line 63
    return ((zip_hash_t *)((void *)0));
  }
  {
#line 65
  hash->table_size = table_size;
#line 66
  __cil_tmp5 = calloc((unsigned long )table_size, sizeof(zip_hash_entry_t *));
#line 66
  hash->table = (zip_hash_entry_t **)__cil_tmp5;
  }
#line 66
  if ((unsigned long )hash->table == (unsigned long )((void *)0)) {
    {
#line 67
    free((void *)hash);
#line 68
    zip_error_set(error, 14, 0);
    }
#line 69
    return ((zip_hash_t *)((void *)0));
  }
#line 72
  return (hash);
}
}
#line 76 "/root/libzip/lib/zip_hash.c"
static void _free_list(zip_hash_entry_t *entry ) 
{ 
  zip_hash_entry_t *next ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    next = entry->next;
#line 81
    free((void *)entry);
#line 82
    entry = next;
    }
#line 79
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 79
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 84
  return;
}
}
#line 87 "/root/libzip/lib/zip_hash.c"
void _zip_hash_free(zip_hash_t *hash ) 
{ 
  zip_uint16_t i ;

  {
#line 91
  if ((unsigned long )hash == (unsigned long )((void *)0)) {
#line 92
    return;
  }
#line 95
  i = (zip_uint16_t )0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;

#line 95
    if (! ((int )i < (int )hash->table_size)) {
#line 95
      goto while_break;
    }
#line 96
    if ((unsigned long )*(hash->table + (int )i) != (unsigned long )((void *)0)) {
      {
#line 97
      _free_list(*(hash->table + (int )i));
      }
    }
#line 95
    i = (zip_uint16_t )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 100
  free((void *)hash->table);
#line 101
  free((void *)hash);
  }
#line 103
  return;
}
}
#line 105 "/root/libzip/lib/zip_hash.c"
static zip_uint16_t _hash_string(zip_uint8_t *name , zip_uint16_t size ) 
{ 
  zip_uint16_t value ;

  {
#line 108
  value = (zip_uint16_t )5381;
#line 110
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 111
    return ((zip_uint16_t )0);
  }
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;

#line 113
    if (! ((int )*name != 0)) {
#line 113
      goto while_break;
    }
#line 114
    value = (zip_uint16_t )(((int )value * 33 + (int )*name) % (int )size);
#line 115
    name ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 118
  return (value);
}
}
#line 123 "/root/libzip/lib/zip_hash.c"
int _zip_hash_add(zip_hash_t *hash , zip_uint8_t *name , zip_uint64_t index___0 ,
                  zip_flags_t flags , zip_error_t *error ) 
{ 
  zip_uint16_t hash_value ;
  zip_hash_entry_t *entry ;
  void *__cil_tmp9 ;

  {
#line 128
  if ((unsigned long )hash == (unsigned long )((void *)0)) {
    {
#line 129
    zip_error_set(error, 18, 0);
    }
#line 130
    return (0);
  } else
#line 128
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 129
    zip_error_set(error, 18, 0);
    }
#line 130
    return (0);
  } else
#line 128
  if (index___0 > 0xffffffffffffffffUL) {
    {
#line 129
    zip_error_set(error, 18, 0);
    }
#line 130
    return (0);
  }
  {
#line 133
  hash_value = _hash_string(name, hash->table_size);
#line 134
  entry = *(hash->table + (int )hash_value);
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;

#line 134
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 134
      goto while_break;
    }
#line 136
    if (flags & 8U) {
#line 136
      if (entry->orig_index != -1L) {
        {
#line 137
        zip_error_set(error, 10, 0);
        }
#line 138
        return (0);
      } else {
#line 136
        goto _L;
      }
    } else
    _L: 
#line 136
    if (entry->current_index != -1L) {
      {
#line 137
      zip_error_set(error, 10, 0);
      }
#line 138
      return (0);
    } else {
#line 141
      goto while_break;
    }
#line 134
    entry = entry->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 146
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    {
#line 147
    __cil_tmp9 = malloc(sizeof(zip_hash_entry_t ));
#line 147
    entry = (zip_hash_entry_t *)__cil_tmp9;
    }
#line 147
    if ((unsigned long )entry == (unsigned long )((void *)0)) {
      {
#line 148
      zip_error_set(error, 14, 0);
      }
#line 149
      return (0);
    }
#line 151
    entry->name = name;
#line 152
    entry->next = *(hash->table + (int )hash_value);
#line 153
    *(hash->table + (int )hash_value) = entry;
#line 154
    entry->orig_index = (zip_int64_t )-1;
  }
#line 157
  if (flags & 8U) {
#line 158
    entry->orig_index = (zip_int64_t )index___0;
  }
#line 160
  entry->current_index = (zip_int64_t )index___0;
#line 162
  return (1);
}
}
#line 167 "/root/libzip/lib/zip_hash.c"
int _zip_hash_delete(zip_hash_t *hash , zip_uint8_t *name , zip_error_t *error ) 
{ 
  zip_uint16_t hash_value ;
  zip_hash_entry_t *entry ;
  zip_hash_entry_t *previous ;

  {
#line 172
  if ((unsigned long )hash == (unsigned long )((void *)0)) {
    {
#line 173
    zip_error_set(error, 18, 0);
    }
#line 174
    return (0);
  } else
#line 172
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 173
    zip_error_set(error, 18, 0);
    }
#line 174
    return (0);
  }
  {
#line 177
  hash_value = _hash_string(name, hash->table_size);
#line 178
  previous = (zip_hash_entry_t *)((void *)0);
#line 179
  entry = *(hash->table + (int )hash_value);
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;

#line 180
    if (! entry) {
#line 180
      goto while_break;
    }
#line 182
    if (entry->orig_index == -1L) {
#line 183
      if (previous) {
#line 184
        previous->next = entry->next;
      } else {
#line 187
        *(hash->table + (int )hash_value) = entry->next;
      }
      {
#line 189
      free((void *)entry);
      }
    } else {
#line 192
      entry->current_index = (zip_int64_t )-1;
    }
#line 194
    return (1);
#line 196
    previous = entry;
#line 197
    entry = entry->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 200
  zip_error_set(error, 9, 0);
  }
#line 201
  return (0);
}
}
#line 206 "/root/libzip/lib/zip_hash.c"
zip_int64_t _zip_hash_lookup(zip_hash_t *hash , zip_uint8_t *name , zip_flags_t flags ,
                             zip_error_t *error ) 
{ 
  zip_uint16_t hash_value ;
  zip_hash_entry_t *entry ;

  {
#line 211
  if ((unsigned long )hash == (unsigned long )((void *)0)) {
    {
#line 212
    zip_error_set(error, 18, 0);
    }
#line 213
    return ((zip_int64_t )-1);
  } else
#line 211
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 212
    zip_error_set(error, 18, 0);
    }
#line 213
    return ((zip_int64_t )-1);
  }
  {
#line 216
  hash_value = _hash_string(name, hash->table_size);
#line 217
  entry = *(hash->table + (int )hash_value);
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;

#line 217
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 217
      goto while_break;
    }
#line 219
    if (flags & 8U) {
#line 220
      if (entry->orig_index != -1L) {
#line 221
        return (entry->orig_index);
      }
    } else
#line 225
    if (entry->current_index != -1L) {
#line 226
      return (entry->current_index);
    }
#line 229
    goto while_break;
#line 217
    entry = entry->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 233
  zip_error_set(error, 9, 0);
  }
#line 234
  return ((zip_int64_t )-1);
}
}
#line 238 "/root/libzip/lib/zip_hash.c"
void _zip_hash_revert(zip_hash_t *hash ) 
{ 
  zip_uint16_t i ;
  zip_hash_entry_t *entry ;
  zip_hash_entry_t *previous ;
  zip_hash_entry_t *p ;

  {
#line 243
  i = (zip_uint16_t )0;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;

#line 243
    if (! ((int )i < (int )hash->table_size)) {
#line 243
      goto while_break;
    }
#line 244
    previous = (zip_hash_entry_t *)((void *)0);
#line 245
    entry = *(hash->table + (int )i);
    {
#line 246
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 246
      if (! entry) {
#line 246
        goto while_break___0;
      }
#line 247
      if (entry->orig_index == -1L) {
#line 249
        if (previous) {
#line 250
          previous->next = entry->next;
        } else {
#line 253
          *(hash->table + (int )i) = entry->next;
        }
        {
#line 255
        p = entry;
#line 256
        entry = entry->next;
#line 258
        free((void *)p);
        }
      } else {
#line 261
        entry->current_index = entry->orig_index;
#line 262
        previous = entry;
#line 263
        entry = entry->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 243
    i = (zip_uint16_t )((int )i + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 247
  return;
}
}
#line 41 "/root/libzip/lib/zip_get_name.c"
char const   *zip_get_name(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ) 
{ 
  char const   *__cil_tmp4 ;

  {
  {
#line 43
  __cil_tmp4 = _zip_get_name(za___0, idx, flags, & za___0->error);
  }
#line 43
  return (__cil_tmp4);
}
}
#line 48 "/root/libzip/lib/zip_get_name.c"
char const   *_zip_get_name(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                            zip_error_t *error ) 
{ 
  zip_dirent_t *de ;
  zip_uint8_t *str ;

  {
  {
#line 53
  de = _zip_get_dirent(za___0, idx, flags, error);
  }
#line 53
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 54
    return ((char const   *)((void *)0));
  }
  {
#line 56
  str = _zip_string_get(de->filename, (zip_uint32_t *)((void *)0), flags, error);
  }
#line 56
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 57
    return ((char const   *)((void *)0));
  }
#line 59
  return ((char const   *)str);
}
}
#line 41 "/root/libzip/lib/zip_get_num_files.c"
int zip_get_num_files(zip_t *za___0 ) 
{ 


  {
#line 43
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 44
    return (-1);
  }
#line 46
  if (za___0->nentry > 2147483647UL) {
    {
#line 47
    zip_error_set(& za___0->error, 28, 0);
    }
#line 48
    return (-1);
  }
#line 51
  return ((int )za___0->nentry);
}
}
#line 39 "/root/libzip/lib/zip_get_num_entries.c"
zip_int64_t zip_get_num_entries(zip_t *za___0 , zip_flags_t flags ) 
{ 
  zip_uint64_t n ;

  {
#line 43
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 44
    return ((zip_int64_t )-1);
  }
#line 46
  if (flags & 8U) {
#line 47
    n = za___0->nentry;
    {
#line 48
    while (1) {
      while_continue: /* CIL Label */ ;

#line 48
      if ((unsigned long )(za___0->entry + (n - 1UL))->orig == (unsigned long )((void *)0)) {
#line 48
        if (! (n > 0UL)) {
#line 48
          goto while_break;
        }
      } else {
#line 48
        goto while_break;
      }
#line 49
      n --;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
#line 50
    return ((zip_int64_t )n);
  }
#line 52
  return ((zip_int64_t )za___0->nentry);
}
}
#line 40 "/root/libzip/lib/zip_get_file_comment.c"
char const   *zip_get_file_comment(zip_t *za___0 , zip_uint64_t idx , int *lenp ,
                                   int flags ) 
{ 
  zip_uint32_t len ;
  char const   *s ;

  {
  {
#line 45
  s = zip_file_get_comment(za___0, idx, & len, (zip_flags_t )flags);
  }
#line 45
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 46
    if (lenp) {
#line 47
      *lenp = (int )len;
    }
  }
#line 50
  return (s);
}
}
#line 39 "/root/libzip/lib/zip_get_encryption_implementation.c"
zip_encryption_implementation _zip_get_encryption_implementation(zip_uint16_t em ) 
{ 


  {
#line 41
  if ((int )em == 1) {
#line 42
    return (& zip_source_pkware);
  }
#line 43
  return ((zip_source_t *(*)(zip_t * , zip_source_t * , zip_uint16_t  , int  , char const   * ))((void *)0));
}
}
#line 39 "/root/libzip/lib/zip_get_compression_implementation.c"
zip_compression_implementation _zip_get_compression_implementation(zip_int32_t cm ) 
{ 


  {
#line 41
  if (cm == 8) {
#line 42
    return (& zip_source_deflate);
  } else
#line 41
  if (cm == -1) {
#line 42
    return (& zip_source_deflate);
  } else
#line 41
  if (cm == -2) {
#line 42
    return (& zip_source_deflate);
  }
#line 43
  return ((zip_source_t *(*)(zip_t * , zip_source_t * , zip_int32_t  , int  ))((void *)0));
}
}
#line 39 "/root/libzip/lib/zip_get_archive_flag.c"
int zip_get_archive_flag(zip_t *za___0 , zip_flags_t flag , zip_flags_t flags ) 
{ 
  unsigned int fl ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 43
  if (flags & 8U) {
#line 43
    tmp = za___0->flags;
  } else {
#line 43
    tmp = za___0->ch_flags;
  }
#line 43
  fl = tmp;
#line 45
  if (fl & flag) {
#line 45
    tmp___0 = 1;
  } else {
#line 45
    tmp___0 = 0;
  }
#line 45
  return (tmp___0);
}
}
#line 41 "/root/libzip/lib/zip_get_archive_comment.c"
char const   *zip_get_archive_comment(zip_t *za___0 , int *lenp , zip_flags_t flags ) 
{ 
  zip_string_t *comment ;
  zip_uint32_t len ;
  zip_uint8_t *str ;

  {
#line 47
  if ((unsigned long )za___0->comment_changes == (unsigned long )((void *)0)) {
#line 48
    comment = za___0->comment_orig;
  } else
#line 47
  if (flags & 8U) {
#line 48
    comment = za___0->comment_orig;
  } else {
#line 50
    comment = za___0->comment_changes;
  }
  {
#line 52
  str = _zip_string_get(comment, & len, flags, & za___0->error);
  }
#line 52
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 53
    return ((char const   *)((void *)0));
  }
#line 55
  if (lenp) {
#line 56
    *lenp = (int )len;
  }
#line 58
  return ((char const   *)str);
}
}
#line 39 "/root/libzip/lib/zip_fread.c"
zip_int64_t zip_fread(zip_file_t *zf , void *outbuf , zip_uint64_t toread ) 
{ 
  zip_int64_t n ;

  {
#line 43
  if (! zf) {
#line 44
    return ((zip_int64_t )-1);
  }
#line 46
  if (zf->error.zip_err != 0) {
#line 47
    return ((zip_int64_t )-1);
  }
#line 49
  if (toread > 0xffffffffffffffffUL) {
    {
#line 50
    zip_error_set(& zf->error, 18, 0);
    }
#line 51
    return ((zip_int64_t )-1);
  }
#line 54
  if (zf->eof) {
#line 55
    return ((zip_int64_t )0);
  } else
#line 54
  if (toread == 0UL) {
#line 55
    return ((zip_int64_t )0);
  }
  {
#line 57
  n = zip_source_read(zf->src, outbuf, toread);
  }
#line 57
  if (n < 0L) {
    {
#line 58
    _zip_error_set_from_source(& zf->error, zf->src);
    }
#line 59
    return ((zip_int64_t )-1);
  }
#line 62
  return (n);
}
}
#line 40 "/root/libzip/lib/zip_fopen_index_encrypted.c"
static zip_file_t *_zip_file_new(zip_t *za___0 ) ;
#line 44 "/root/libzip/lib/zip_fopen_index_encrypted.c"
zip_file_t *zip_fopen_index_encrypted(zip_t *za___0 , zip_uint64_t index___0 , zip_flags_t flags ,
                                      char const   *password ) 
{ 
  zip_file_t *zf ;
  zip_source_t *src ;
  int __cil_tmp8 ;

  {
  {
#line 50
  src = _zip_source_zip_new(za___0, za___0, index___0, flags, (zip_uint64_t )0, (zip_uint64_t )0,
                            password);
  }
#line 50
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 51
    return ((zip_file_t *)((void *)0));
  }
  {
#line 53
  __cil_tmp8 = zip_source_open(src);
  }
#line 53
  if (__cil_tmp8 < 0) {
    {
#line 54
    _zip_error_set_from_source(& za___0->error, src);
#line 55
    zip_source_free(src);
    }
#line 56
    return ((zip_file_t *)((void *)0));
  }
  {
#line 59
  zf = _zip_file_new(za___0);
  }
#line 59
  if ((unsigned long )zf == (unsigned long )((void *)0)) {
    {
#line 60
    zip_source_free(src);
    }
#line 61
    return ((zip_file_t *)((void *)0));
  }
#line 64
  zf->src = src;
#line 66
  return (zf);
}
}
#line 71 "/root/libzip/lib/zip_fopen_index_encrypted.c"
static zip_file_t *_zip_file_new(zip_t *za___0 ) 
{ 
  zip_file_t *zf ;
  void *__cil_tmp3 ;

  {
  {
#line 75
  __cil_tmp3 = malloc(sizeof(struct zip_file ));
#line 75
  zf = (zip_file_t *)__cil_tmp3;
  }
#line 75
  if ((unsigned long )zf == (unsigned long )((void *)0)) {
    {
#line 76
    zip_error_set(& za___0->error, 14, 0);
    }
#line 77
    return ((zip_file_t *)((void *)0));
  }
  {
#line 80
  zf->za = za___0;
#line 81
  zip_error_init(& zf->error);
#line 82
  zf->eof = 0;
#line 83
  zf->src = (zip_source_t *)((void *)0);
  }
#line 85
  return (zf);
}
}
#line 42 "/root/libzip/lib/zip_fopen_index.c"
zip_file_t *zip_fopen_index(zip_t *za___0 , zip_uint64_t index___0 , zip_flags_t flags ) 
{ 
  zip_file_t *__cil_tmp4 ;

  {
  {
#line 44
  __cil_tmp4 = zip_fopen_index_encrypted(za___0, index___0, flags, (char const   *)za___0->default_password);
  }
#line 44
  return (__cil_tmp4);
}
}
#line 39 "/root/libzip/lib/zip_fopen_encrypted.c"
zip_file_t *zip_fopen_encrypted(zip_t *za___0 , char const   *fname , zip_flags_t flags ,
                                char const   *password ) 
{ 
  zip_int64_t idx ;
  zip_file_t *__cil_tmp7 ;

  {
  {
#line 43
  idx = zip_name_locate(za___0, fname, flags);
  }
#line 43
  if (idx < 0L) {
#line 44
    return ((zip_file_t *)((void *)0));
  }
  {
#line 46
  __cil_tmp7 = zip_fopen_index_encrypted(za___0, (zip_uint64_t )idx, flags, password);
  }
#line 46
  return (__cil_tmp7);
}
}
#line 39 "/root/libzip/lib/zip_fopen.c"
zip_file_t *zip_fopen(zip_t *za___0 , char const   *fname , zip_flags_t flags ) 
{ 
  zip_int64_t idx ;
  zip_file_t *__cil_tmp6 ;

  {
  {
#line 43
  idx = zip_name_locate(za___0, fname, flags);
  }
#line 43
  if (idx < 0L) {
#line 44
    return ((zip_file_t *)((void *)0));
  }
  {
#line 46
  __cil_tmp6 = zip_fopen_index_encrypted(za___0, (zip_uint64_t )idx, flags, (char const   *)za___0->default_password);
  }
#line 46
  return (__cil_tmp6);
}
}
#line 42 "/root/libzip/lib/zip_filerange_crc.c"
int _zip_filerange_crc(zip_source_t *src , zip_uint64_t start , zip_uint64_t len ,
                       uLong *crcp , zip_error_t *error ) 
{ 
  Bytef buf[8192] ;
  zip_int64_t n ;
  int __cil_tmp9 ;
  unsigned long tmp ;

  {
  {
#line 47
  *crcp = crc32((uLong )0L, (Bytef *)0, (uInt )0);
  }
#line 49
  if (start > 0xffffffffffffffffUL) {
    {
#line 50
    zip_error_set(error, 4, 27);
    }
#line 51
    return (-1);
  }
  {
#line 54
  __cil_tmp9 = zip_source_seek(src, (zip_int64_t )start, 0);
  }
#line 54
  if (__cil_tmp9 != 0) {
    {
#line 55
    _zip_error_set_from_source(error, src);
    }
#line 56
    return (-1);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;

#line 59
    if (! (len > 0UL)) {
#line 59
      goto while_break;
    }
#line 60
    if (len > 8192UL) {
#line 60
      tmp = 8192UL;
    } else {
#line 60
      tmp = len;
    }
    {
#line 60
    n = (zip_int64_t )tmp;
#line 61
    n = zip_source_read(src, (void *)(buf), (zip_uint64_t )n);
    }
#line 61
    if (n < 0L) {
      {
#line 62
      _zip_error_set_from_source(error, src);
      }
#line 63
      return (-1);
    }
#line 65
    if (n == 0L) {
      {
#line 66
      zip_error_set(error, 17, 0);
      }
#line 67
      return (-1);
    }
    {
#line 70
    *crcp = crc32(*crcp, buf, (uInt )n);
#line 72
    len -= (zip_uint64_t )n;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 75
  return (0);
}
}
#line 39 "/root/libzip/lib/zip_file_strerror.c"
char const   *zip_file_strerror(zip_file_t *zf ) 
{ 
  char const   *__cil_tmp2 ;

  {
  {
#line 41
  __cil_tmp2 = zip_error_strerror(& zf->error);
  }
#line 41
  return (__cil_tmp2);
}
}
#line 36 "/root/libzip/lib/zip_file_set_mtime.c"
int zip_file_set_mtime(zip_t *za___0 , zip_uint64_t idx , time_t mtime , zip_flags_t flags ) 
{ 
  zip_entry_t *e ;
  int changed ;
  zip_dirent_t *__cil_tmp7 ;
  int tmp ;

  {
  {
#line 41
  __cil_tmp7 = _zip_get_dirent(za___0, idx, (zip_flags_t )0, (zip_error_t *)((void *)0));
  }
#line 41
  if ((unsigned long )__cil_tmp7 == (unsigned long )((void *)0)) {
#line 42
    return (-1);
  }
#line 44
  if (za___0->ch_flags & 2U) {
    {
#line 45
    zip_error_set(& za___0->error, 25, 0);
    }
#line 46
    return (-1);
  }
#line 49
  e = za___0->entry + idx;
#line 51
  if ((unsigned long )e->orig == (unsigned long )((void *)0)) {
#line 51
    tmp = 1;
  } else
#line 51
  if (mtime != (e->orig)->last_mod) {
#line 51
    tmp = 1;
  } else {
#line 51
    tmp = 0;
  }
#line 51
  changed = tmp;
#line 53
  if (changed) {
#line 54
    if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
      {
#line 55
      e->changes = _zip_dirent_clone(e->orig);
      }
#line 55
      if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
        {
#line 56
        zip_error_set(& za___0->error, 14, 0);
        }
#line 57
        return (-1);
      }
    }
#line 60
    (e->changes)->last_mod = mtime;
#line 61
    (e->changes)->changed |= 32U;
  } else
#line 64
  if (e->changes) {
#line 65
    (e->changes)->changed &= 4294967263U;
#line 66
    if ((e->changes)->changed == 0U) {
      {
#line 67
      _zip_dirent_free(e->changes);
#line 68
      e->changes = (zip_dirent_t *)((void *)0);
      }
    }
  }
#line 73
  return (0);
}
}
#line 37 "/root/libzip/lib/zip_file_set_external_attributes.c"
int zip_file_set_external_attributes(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                                     zip_uint8_t opsys , zip_uint32_t attributes ) 
{ 
  zip_entry_t *e ;
  int changed ;
  zip_uint8_t unchanged_opsys ;
  zip_uint32_t unchanged_attributes ;
  zip_dirent_t *__cil_tmp10 ;
  int tmp ;
  zip_uint32_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 44
  __cil_tmp10 = _zip_get_dirent(za___0, idx, (zip_flags_t )0, (zip_error_t *)((void *)0));
  }
#line 44
  if ((unsigned long )__cil_tmp10 == (unsigned long )((void *)0)) {
#line 45
    return (-1);
  }
#line 47
  if (za___0->ch_flags & 2U) {
    {
#line 48
    zip_error_set(& za___0->error, 25, 0);
    }
#line 49
    return (-1);
  }
#line 52
  e = za___0->entry + idx;
#line 54
  if (e->orig) {
#line 54
    tmp = (int )((zip_uint8_t )((int )(e->orig)->version_madeby >> 8));
  } else {
#line 54
    tmp = (int )((zip_uint8_t )3U);
  }
#line 54
  unchanged_opsys = (zip_uint8_t )tmp;
#line 55
  if (e->orig) {
#line 55
    tmp___0 = (e->orig)->ext_attrib;
  } else {
#line 55
    tmp___0 = 33206U << 16;
  }
#line 55
  unchanged_attributes = tmp___0;
#line 57
  if ((int )opsys != (int )unchanged_opsys) {
#line 57
    tmp___1 = 1;
  } else
#line 57
  if (attributes != unchanged_attributes) {
#line 57
    tmp___1 = 1;
  } else {
#line 57
    tmp___1 = 0;
  }
#line 57
  changed = tmp___1;
#line 59
  if (changed) {
#line 60
    if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
      {
#line 61
      e->changes = _zip_dirent_clone(e->orig);
      }
#line 61
      if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
        {
#line 62
        zip_error_set(& za___0->error, 14, 0);
        }
#line 63
        return (-1);
      }
    }
#line 66
    (e->changes)->version_madeby = (zip_uint16_t )(((int )opsys << 8) | ((int )(e->changes)->version_madeby & 255));
#line 67
    (e->changes)->ext_attrib = attributes;
#line 68
    (e->changes)->changed |= 16U;
  } else
#line 70
  if (e->changes) {
#line 71
    (e->changes)->changed &= 4294967279U;
#line 72
    if ((e->changes)->changed == 0U) {
      {
#line 73
      _zip_dirent_free(e->changes);
#line 74
      e->changes = (zip_dirent_t *)((void *)0);
      }
    } else {
#line 77
      (e->changes)->version_madeby = (zip_uint16_t )(((int )unchanged_opsys << 8) | ((int )(e->changes)->version_madeby & 255));
#line 78
      (e->changes)->ext_attrib = unchanged_attributes;
    }
  }
#line 82
  return (0);
}
}
#line 41 "/root/libzip/lib/zip_file_set_comment.c"
int zip_file_set_comment(zip_t *za___0 , zip_uint64_t idx , char const   *comment ,
                         zip_uint16_t len , zip_flags_t flags ) 
{ 
  zip_entry_t *e ;
  zip_string_t *cstr ;
  int changed ;
  zip_dirent_t *__cil_tmp9 ;
  enum zip_encoding_type __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 48
  __cil_tmp9 = _zip_get_dirent(za___0, idx, (zip_flags_t )0, (zip_error_t *)((void *)0));
  }
#line 48
  if ((unsigned long )__cil_tmp9 == (unsigned long )((void *)0)) {
#line 49
    return (-1);
  }
#line 51
  if (za___0->ch_flags & 2U) {
    {
#line 52
    zip_error_set(& za___0->error, 25, 0);
    }
#line 53
    return (-1);
  }
#line 56
  if ((unsigned long )comment == (unsigned long )((void *)0)) {
#line 56
    if ((int )len > 0) {
      {
#line 57
      zip_error_set(& za___0->error, 18, 0);
      }
#line 58
      return (-1);
    }
  }
#line 61
  if ((int )len > 0) {
    {
#line 62
    cstr = _zip_string_new((zip_uint8_t *)comment, len, flags, & za___0->error);
    }
#line 62
    if ((unsigned long )cstr == (unsigned long )((void *)0)) {
#line 63
      return (-1);
    }
    {
#line 64
    __cil_tmp11 = _zip_guess_encoding(cstr, (enum zip_encoding_type )0);
    }
#line 64
    if ((flags & 6144U) == 0U) {
#line 64
      if ((unsigned int )__cil_tmp11 == 3U) {
#line 65
        cstr->encoding = (enum zip_encoding_type )2;
      }
    }
  } else {
#line 68
    cstr = (zip_string_t *)((void *)0);
  }
#line 70
  e = za___0->entry + idx;
#line 72
  if (e->changes) {
    {
#line 73
    _zip_string_free((e->changes)->comment);
#line 74
    (e->changes)->comment = (zip_string_t *)((void *)0);
#line 75
    (e->changes)->changed &= 4294967291U;
    }
  }
#line 78
  if (e->orig) {
#line 78
    if ((e->orig)->comment) {
      {
#line 79
      __cil_tmp12 = _zip_string_equal((e->orig)->comment, cstr);
#line 79
      changed = ! __cil_tmp12;
      }
    } else {
#line 81
      changed = (unsigned long )cstr != (unsigned long )((void *)0);
    }
  } else {
#line 81
    changed = (unsigned long )cstr != (unsigned long )((void *)0);
  }
#line 83
  if (changed) {
#line 84
    if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
      {
#line 85
      e->changes = _zip_dirent_clone(e->orig);
      }
#line 85
      if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
        {
#line 86
        zip_error_set(& za___0->error, 14, 0);
#line 87
        _zip_string_free(cstr);
        }
#line 88
        return (-1);
      }
    }
#line 91
    (e->changes)->comment = cstr;
#line 92
    (e->changes)->changed |= 4U;
  } else {
    {
#line 95
    _zip_string_free(cstr);
    }
#line 96
    if (e->changes) {
#line 96
      if ((e->changes)->changed == 0U) {
        {
#line 97
        _zip_dirent_free(e->changes);
#line 98
        e->changes = (zip_dirent_t *)((void *)0);
        }
      }
    }
  }
#line 102
  return (0);
}
}
#line 39 "/root/libzip/lib/zip_file_replace.c"
int zip_file_replace(zip_t *za___0 , zip_uint64_t idx , zip_source_t *source , zip_flags_t flags ) 
{ 
  zip_int64_t __cil_tmp5 ;

  {
#line 41
  if ((unsigned long )source == (unsigned long )((void *)0)) {
    {
#line 42
    zip_error_set(& za___0->error, 18, 0);
    }
#line 43
    return (-1);
  } else
#line 41
  if (idx >= za___0->nentry) {
    {
#line 42
    zip_error_set(& za___0->error, 18, 0);
    }
#line 43
    return (-1);
  }
  {
#line 46
  __cil_tmp5 = _zip_file_replace(za___0, idx, (char const   *)((void *)0), source,
                                 flags);
  }
#line 46
  if (__cil_tmp5 == -1L) {
#line 47
    return (-1);
  }
#line 49
  return (0);
}
}
#line 57 "/root/libzip/lib/zip_file_replace.c"
zip_int64_t _zip_file_replace(zip_t *za___0 , zip_uint64_t idx , char const   *name ,
                              zip_source_t *source , zip_flags_t flags ) 
{ 
  zip_uint64_t za_nentry_prev ;
  zip_int64_t i ;
  int __cil_tmp10 ;

  {
#line 61
  if (za___0->ch_flags & 2U) {
    {
#line 62
    zip_error_set(& za___0->error, 25, 0);
    }
#line 63
    return ((zip_int64_t )-1);
  }
#line 66
  za_nentry_prev = za___0->nentry;
#line 67
  if (idx == 0xffffffffffffffffUL) {
#line 68
    i = (zip_int64_t )-1;
#line 70
    if (flags & 8192U) {
      {
#line 71
      i = _zip_name_locate(za___0, name, flags, (zip_error_t *)((void *)0));
      }
    }
#line 73
    if (i == -1L) {
      {
#line 75
      i = _zip_add_entry(za___0);
      }
#line 75
      if (i < 0L) {
#line 76
        return ((zip_int64_t )-1);
      }
    }
#line 78
    idx = (zip_uint64_t )i;
  }
  {
#line 81
  __cil_tmp10 = _zip_set_name(za___0, idx, name, flags);
  }
#line 81
  if (name) {
#line 81
    if (__cil_tmp10 != 0) {
#line 82
      if (za___0->nentry != za_nentry_prev) {
        {
#line 83
        _zip_entry_finalize(za___0->entry + idx);
#line 84
        za___0->nentry = za_nentry_prev;
        }
      }
#line 86
      return ((zip_int64_t )-1);
    }
  }
  {
#line 91
  _zip_unchange_data(za___0->entry + idx);
  }
#line 93
  if ((unsigned long )(za___0->entry + idx)->orig != (unsigned long )((void *)0)) {
#line 93
    if ((unsigned long )(za___0->entry + idx)->changes == (unsigned long )((void *)0)) {
      _L: 
#line 94
      if ((unsigned long )(za___0->entry + idx)->changes == (unsigned long )((void *)0)) {
        {
#line 95
        (za___0->entry + idx)->changes = _zip_dirent_clone((za___0->entry + idx)->orig);
        }
#line 95
        if ((unsigned long )(za___0->entry + idx)->changes == (unsigned long )((void *)0)) {
          {
#line 96
          zip_error_set(& za___0->error, 14, 0);
          }
#line 97
          return ((zip_int64_t )-1);
        }
      }
#line 101
      ((za___0->entry + idx)->changes)->comp_method = -2;
#line 102
      ((za___0->entry + idx)->changes)->changed |= 1U;
    } else
#line 93
    if ((((za___0->entry + idx)->changes)->changed & 1U) == 0U) {
#line 93
      goto _L;
    }
  }
#line 105
  (za___0->entry + idx)->source = source;
#line 107
  return ((zip_int64_t )idx);
}
}
#line 41 "/root/libzip/lib/zip_file_rename.c"
int zip_file_rename(zip_t *za___0 , zip_uint64_t idx , char const   *name , zip_flags_t flags ) 
{ 
  char const   *old_name ;
  int old_is_dir ;
  int new_is_dir ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  int tmp ;

  {
  {
#line 46
  __cil_tmp8 = strlen(name);
  }
#line 46
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 46
    if (__cil_tmp8 > 65535UL) {
      {
#line 47
      zip_error_set(& za___0->error, 18, 0);
      }
#line 48
      return (-1);
    } else {
#line 46
      goto _L;
    }
  } else
  _L: 
#line 46
  if (idx >= za___0->nentry) {
    {
#line 47
    zip_error_set(& za___0->error, 18, 0);
    }
#line 48
    return (-1);
  }
#line 51
  if (za___0->ch_flags & 2U) {
    {
#line 52
    zip_error_set(& za___0->error, 25, 0);
    }
#line 53
    return (-1);
  }
  {
#line 56
  old_name = zip_get_name(za___0, idx, (zip_flags_t )0);
  }
#line 56
  if ((unsigned long )old_name == (unsigned long )((void *)0)) {
#line 57
    return (-1);
  }
  {
#line 59
  __cil_tmp10 = strlen(name);
  }
#line 59
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 59
    if ((int )*(name + (__cil_tmp10 - 1UL)) == 47) {
#line 59
      tmp = 1;
    } else {
#line 59
      tmp = 0;
    }
  } else {
#line 59
    tmp = 0;
  }
  {
#line 59
  new_is_dir = tmp;
#line 60
  __cil_tmp11 = strlen(old_name);
#line 60
  old_is_dir = (int )*(old_name + (__cil_tmp11 - 1UL)) == 47;
  }
#line 62
  if (new_is_dir != old_is_dir) {
    {
#line 63
    zip_error_set(& za___0->error, 18, 0);
    }
#line 64
    return (-1);
  }
  {
#line 67
  __cil_tmp12 = _zip_set_name(za___0, idx, name, flags);
  }
#line 67
  return (__cil_tmp12);
}
}
#line 51 "/root/libzip/lib/zip_file_get_offset.c"
zip_uint64_t _zip_file_get_offset(zip_t *za___0 , zip_uint64_t idx , zip_error_t *error ) 
{ 
  zip_uint64_t offset ;
  zip_int32_t size ;
  int __cil_tmp6 ;

  {
  {
#line 56
  offset = ((za___0->entry + idx)->orig)->offset;
#line 58
  __cil_tmp6 = zip_source_seek(za___0->src, (zip_int64_t )offset, 0);
  }
#line 58
  if (__cil_tmp6 < 0) {
    {
#line 59
    _zip_error_set_from_source(error, za___0->src);
    }
#line 60
    return ((zip_uint64_t )0);
  }
  {
#line 64
  size = _zip_dirent_size(za___0->src, (zip_uint16_t )256U, error);
  }
#line 64
  if (size < 0) {
#line 65
    return ((zip_uint64_t )0);
  }
#line 67
  if (offset + (unsigned long )((zip_uint32_t )size) > 0xffffffffffffffffUL) {
    {
#line 68
    zip_error_set(error, 4, 27);
    }
#line 69
    return ((zip_uint64_t )0);
  }
#line 72
  return (offset + (unsigned long )((zip_uint32_t )size));
}
}
#line 37 "/root/libzip/lib/zip_file_get_external_attributes.c"
int zip_file_get_external_attributes(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                                     zip_uint8_t *opsys , zip_uint32_t *attributes ) 
{ 
  zip_dirent_t *de ;

  {
  {
#line 41
  de = _zip_get_dirent(za___0, idx, flags, (zip_error_t *)((void *)0));
  }
#line 41
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 42
    return (-1);
  }
#line 44
  if (opsys) {
#line 45
    *opsys = (zip_uint8_t )(((int )de->version_madeby >> 8) & 255);
  }
#line 47
  if (attributes) {
#line 48
    *attributes = de->ext_attrib;
  }
#line 50
  return (0);
}
}
#line 40 "/root/libzip/lib/zip_file_get_comment.c"
char const   *zip_file_get_comment(zip_t *za___0 , zip_uint64_t idx , zip_uint32_t *lenp ,
                                   zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  zip_uint32_t len ;
  zip_uint8_t *str ;

  {
  {
#line 46
  de = _zip_get_dirent(za___0, idx, flags, (zip_error_t *)((void *)0));
  }
#line 46
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 47
    return ((char const   *)((void *)0));
  }
  {
#line 49
  str = _zip_string_get(de->comment, & len, flags, & za___0->error);
  }
#line 49
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 50
    return ((char const   *)((void *)0));
  }
#line 52
  if (lenp) {
#line 53
    *lenp = len;
  }
#line 55
  return ((char const   *)str);
}
}
#line 39 "/root/libzip/lib/zip_file_error_get.c"
void zip_file_error_get(zip_file_t *zf , int *zep , int *sep ) 
{ 


  {
  {
#line 41
  _zip_error_get(& zf->error, zep, sep);
  }
#line 43
  return;
}
}
#line 39 "/root/libzip/lib/zip_file_error_clear.c"
void zip_file_error_clear(zip_file_t *zf ) 
{ 


  {
#line 41
  if ((unsigned long )zf == (unsigned long )((void *)0)) {
#line 42
    return;
  }
  {
#line 44
  _zip_error_clear(& zf->error);
  }
#line 46
  return;
}
}
#line 45 "/root/libzip/lib/zip_file_add.c"
zip_int64_t zip_file_add(zip_t *za___0 , char const   *name , zip_source_t *source ,
                         zip_flags_t flags ) 
{ 
  zip_int64_t __cil_tmp5 ;

  {
#line 47
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 48
    zip_error_set(& za___0->error, 18, 0);
    }
#line 49
    return ((zip_int64_t )-1);
  } else
#line 47
  if ((unsigned long )source == (unsigned long )((void *)0)) {
    {
#line 48
    zip_error_set(& za___0->error, 18, 0);
    }
#line 49
    return ((zip_int64_t )-1);
  }
  {
#line 52
  __cil_tmp5 = _zip_file_replace(za___0, 0xffffffffffffffffUL, name, source, flags);
  }
#line 52
  return (__cil_tmp5);
}
}
#line 42 "/root/libzip/lib/zip_fdopen.c"
zip_t *zip_fdopen(int fd_orig , int _flags , int *zep ) 
{ 
  int fd ;
  FILE *fp ;
  zip_t *za___0 ;
  zip_source_t *src ;
  struct zip_error error ;

  {
#line 50
  if (_flags < 0) {
    {
#line 51
    _zip_set_open_error(zep, (zip_error_t *)((void *)0), 18);
    }
#line 52
    return ((zip_t *)((void *)0));
  } else
#line 50
  if (_flags & 8) {
    {
#line 51
    _zip_set_open_error(zep, (zip_error_t *)((void *)0), 18);
    }
#line 52
    return ((zip_t *)((void *)0));
  }
  {
#line 58
  fd = dup(fd_orig);
  }
#line 58
  if (fd < 0) {
    {
#line 59
    _zip_set_open_error(zep, (zip_error_t *)((void *)0), 11);
    }
#line 60
    return ((zip_t *)((void *)0));
  }
  {
#line 63
  fp = fdopen(fd, "rb");
  }
#line 63
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 64
    close(fd);
#line 65
    _zip_set_open_error(zep, (zip_error_t *)((void *)0), 11);
    }
#line 66
    return ((zip_t *)((void *)0));
  }
  {
#line 69
  zip_error_init(& error);
#line 70
  src = zip_source_filep_create(fp, (zip_uint64_t )0, (zip_int64_t )-1, & error);
  }
#line 70
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 71
    _zip_set_open_error(zep, & error, 0);
#line 72
    zip_error_fini(& error);
    }
#line 73
    return ((zip_t *)((void *)0));
  }
  {
#line 76
  za___0 = zip_open_from_source(src, _flags, & error);
  }
#line 76
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
    {
#line 77
    _zip_set_open_error(zep, & error, 0);
#line 78
    zip_error_fini(& error);
    }
#line 79
    return ((zip_t *)((void *)0));
  }
  {
#line 82
  zip_error_fini(& error);
#line 83
  close(fd_orig);
  }
#line 84
  return (za___0);
}
}
#line 41 "/root/libzip/lib/zip_fclose.c"
int zip_fclose(zip_file_t *zf ) 
{ 
  int ret ;

  {
#line 45
  if (zf->src) {
    {
#line 46
    zip_source_free(zf->src);
    }
  }
#line 48
  ret = 0;
#line 49
  if (zf->error.zip_err) {
#line 50
    ret = zf->error.zip_err;
  }
  {
#line 52
  zip_error_fini(& zf->error);
#line 53
  free((void *)zf);
  }
#line 54
  return (ret);
}
}
#line 39 "/root/libzip/lib/zip_extra_field_api.c"
int zip_file_extra_field_delete(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_idx ,
                                zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  zip_dirent_t *__cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 43
  if ((flags & 768U) == 0U) {
    {
#line 44
    zip_error_set(& za___0->error, 18, 0);
    }
#line 45
    return (-1);
  }
#line 48
  if ((flags & 768U) == 768U) {
#line 48
    if ((int )ef_idx != 65535) {
      {
#line 49
      zip_error_set(& za___0->error, 18, 0);
      }
#line 50
      return (-1);
    }
  }
  {
#line 53
  __cil_tmp6 = _zip_get_dirent(za___0, idx, (zip_flags_t )0, (zip_error_t *)((void *)0));
  }
#line 53
  if ((unsigned long )__cil_tmp6 == (unsigned long )((void *)0)) {
#line 54
    return (-1);
  }
#line 56
  if (za___0->ch_flags & 2U) {
    {
#line 57
    zip_error_set(& za___0->error, 25, 0);
    }
#line 58
    return (-1);
  }
  {
#line 61
  __cil_tmp7 = _zip_file_extra_field_prepare_for_change(za___0, idx);
  }
#line 61
  if (__cil_tmp7 < 0) {
#line 62
    return (-1);
  }
  {
#line 64
  de = (za___0->entry + idx)->changes;
#line 66
  de->extra_fields = _zip_ef_delete_by_id(de->extra_fields, (zip_uint16_t )65535,
                                          ef_idx, flags);
  }
#line 67
  return (0);
}
}
#line 72 "/root/libzip/lib/zip_extra_field_api.c"
int zip_file_extra_field_delete_by_id(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                                      zip_uint16_t ef_idx , zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  zip_dirent_t *__cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 76
  if ((flags & 768U) == 0U) {
    {
#line 77
    zip_error_set(& za___0->error, 18, 0);
    }
#line 78
    return (-1);
  }
#line 81
  if ((flags & 768U) == 768U) {
#line 81
    if ((int )ef_idx != 65535) {
      {
#line 82
      zip_error_set(& za___0->error, 18, 0);
      }
#line 83
      return (-1);
    }
  }
  {
#line 86
  __cil_tmp7 = _zip_get_dirent(za___0, idx, (zip_flags_t )0, (zip_error_t *)((void *)0));
  }
#line 86
  if ((unsigned long )__cil_tmp7 == (unsigned long )((void *)0)) {
#line 87
    return (-1);
  }
#line 89
  if (za___0->ch_flags & 2U) {
    {
#line 90
    zip_error_set(& za___0->error, 25, 0);
    }
#line 91
    return (-1);
  }
  {
#line 94
  __cil_tmp8 = _zip_file_extra_field_prepare_for_change(za___0, idx);
  }
#line 94
  if (__cil_tmp8 < 0) {
#line 95
    return (-1);
  }
  {
#line 97
  de = (za___0->entry + idx)->changes;
#line 99
  de->extra_fields = _zip_ef_delete_by_id(de->extra_fields, ef_id, ef_idx, flags);
  }
#line 100
  return (0);
}
}
#line 108 "/root/libzip/lib/zip_extra_field_api.c"
static zip_uint8_t empty___0[1]  ;
#line 105 "/root/libzip/lib/zip_extra_field_api.c"
zip_uint8_t *zip_file_extra_field_get(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_idx ,
                                      zip_uint16_t *idp , zip_uint16_t *lenp , zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  zip_extra_field_t *ef ;
  int i ;
  int __cil_tmp12 ;

  {
#line 107
  empty___0[0] = (zip_uint8_t )'\000';
#line 113
  if ((flags & 768U) == 0U) {
    {
#line 114
    zip_error_set(& za___0->error, 18, 0);
    }
#line 115
    return ((zip_uint8_t *)((void *)0));
  }
  {
#line 118
  de = _zip_get_dirent(za___0, idx, flags, & za___0->error);
  }
#line 118
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 119
    return ((zip_uint8_t *)((void *)0));
  }
#line 121
  if (flags & 256U) {
    {
#line 122
    __cil_tmp12 = _zip_read_local_ef(za___0, idx);
    }
#line 122
    if (__cil_tmp12 < 0) {
#line 123
      return ((zip_uint8_t *)((void *)0));
    }
  }
#line 125
  i = 0;
#line 126
  ef = de->extra_fields;
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 126
    if (! ef) {
#line 126
      goto while_break;
    }
#line 127
    if ((ef->flags & flags) & 768U) {
#line 128
      if (i < (int )ef_idx) {
#line 129
        i ++;
#line 130
        goto while_continue;
      }
#line 133
      if (idp) {
#line 134
        *idp = ef->id;
      }
#line 135
      if (lenp) {
#line 136
        *lenp = ef->size;
      }
#line 137
      if ((int )ef->size > 0) {
#line 138
        return (ef->data);
      } else {
#line 140
        return (empty___0);
      }
    }
#line 126
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 144
  zip_error_set(& za___0->error, 9, 0);
  }
#line 145
  return ((zip_uint8_t *)((void *)0));
}
}
#line 151 "/root/libzip/lib/zip_extra_field_api.c"
zip_uint8_t *zip_file_extra_field_get_by_id(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                                            zip_uint16_t ef_idx , zip_uint16_t *lenp ,
                                            zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  int __cil_tmp9 ;
  zip_uint8_t *__cil_tmp10 ;

  {
#line 155
  if ((flags & 768U) == 0U) {
    {
#line 156
    zip_error_set(& za___0->error, 18, 0);
    }
#line 157
    return ((zip_uint8_t *)((void *)0));
  }
  {
#line 160
  de = _zip_get_dirent(za___0, idx, flags, & za___0->error);
  }
#line 160
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 161
    return ((zip_uint8_t *)((void *)0));
  }
#line 163
  if (flags & 256U) {
    {
#line 164
    __cil_tmp9 = _zip_read_local_ef(za___0, idx);
    }
#line 164
    if (__cil_tmp9 < 0) {
#line 165
      return ((zip_uint8_t *)((void *)0));
    }
  }
  {
#line 167
  __cil_tmp10 = _zip_ef_get_by_id(de->extra_fields, lenp, ef_id, ef_idx, flags, & za___0->error);
  }
#line 167
  return (__cil_tmp10);
}
}
#line 172 "/root/libzip/lib/zip_extra_field_api.c"
zip_int16_t zip_file_extra_fields_count(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  zip_extra_field_t *ef ;
  zip_uint16_t n ;
  int __cil_tmp8 ;

  {
#line 178
  if ((flags & 768U) == 0U) {
    {
#line 179
    zip_error_set(& za___0->error, 18, 0);
    }
#line 180
    return ((zip_int16_t )-1);
  }
  {
#line 183
  de = _zip_get_dirent(za___0, idx, flags, & za___0->error);
  }
#line 183
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 184
    return ((zip_int16_t )-1);
  }
#line 186
  if (flags & 256U) {
    {
#line 187
    __cil_tmp8 = _zip_read_local_ef(za___0, idx);
    }
#line 187
    if (__cil_tmp8 < 0) {
#line 188
      return ((zip_int16_t )-1);
    }
  }
#line 190
  n = (zip_uint16_t )0;
#line 191
  ef = de->extra_fields;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;

#line 191
    if (! ef) {
#line 191
      goto while_break;
    }
#line 192
    if ((ef->flags & flags) & 768U) {
#line 193
      n = (zip_uint16_t )((int )n + 1);
    }
#line 191
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 195
  return ((zip_int16_t )n);
}
}
#line 200 "/root/libzip/lib/zip_extra_field_api.c"
zip_int16_t zip_file_extra_fields_count_by_id(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                                              zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  zip_extra_field_t *ef ;
  zip_uint16_t n ;
  int __cil_tmp9 ;

  {
#line 206
  if ((flags & 768U) == 0U) {
    {
#line 207
    zip_error_set(& za___0->error, 18, 0);
    }
#line 208
    return ((zip_int16_t )-1);
  }
  {
#line 211
  de = _zip_get_dirent(za___0, idx, flags, & za___0->error);
  }
#line 211
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 212
    return ((zip_int16_t )-1);
  }
#line 214
  if (flags & 256U) {
    {
#line 215
    __cil_tmp9 = _zip_read_local_ef(za___0, idx);
    }
#line 215
    if (__cil_tmp9 < 0) {
#line 216
      return ((zip_int16_t )-1);
    }
  }
#line 218
  n = (zip_uint16_t )0;
#line 219
  ef = de->extra_fields;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;

#line 219
    if (! ef) {
#line 219
      goto while_break;
    }
#line 220
    if ((int )ef->id == (int )ef_id) {
#line 220
      if ((ef->flags & flags) & 768U) {
#line 221
        n = (zip_uint16_t )((int )n + 1);
      }
    }
#line 219
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 223
  return ((zip_int16_t )n);
}
}
#line 228 "/root/libzip/lib/zip_extra_field_api.c"
int zip_file_extra_field_set(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                             zip_uint16_t ef_idx , zip_uint8_t *data , zip_uint16_t len ,
                             zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  zip_uint16_t ls ;
  zip_uint16_t cs ;
  zip_extra_field_t *ef ;
  zip_extra_field_t *ef_prev ;
  zip_extra_field_t *ef_new ;
  int i ;
  int found ;
  int new_len ;
  zip_dirent_t *__cil_tmp17 ;
  int __cil_tmp18 ;
  int tmp ;

  {
#line 235
  if ((flags & 768U) == 0U) {
    {
#line 236
    zip_error_set(& za___0->error, 18, 0);
    }
#line 237
    return (-1);
  }
  {
#line 240
  __cil_tmp17 = _zip_get_dirent(za___0, idx, (zip_flags_t )0, (zip_error_t *)((void *)0));
  }
#line 240
  if ((unsigned long )__cil_tmp17 == (unsigned long )((void *)0)) {
#line 241
    return (-1);
  }
#line 243
  if (za___0->ch_flags & 2U) {
    {
#line 244
    zip_error_set(& za___0->error, 25, 0);
    }
#line 245
    return (-1);
  }
#line 248
  if ((int )ef_id == 25461) {
    {
#line 249
    zip_error_set(& za___0->error, 18, 0);
    }
#line 250
    return (-1);
  } else
#line 248
  if ((int )ef_id == 28789) {
    {
#line 249
    zip_error_set(& za___0->error, 18, 0);
    }
#line 250
    return (-1);
  } else
#line 248
  if ((int )ef_id == 1) {
    {
#line 249
    zip_error_set(& za___0->error, 18, 0);
    }
#line 250
    return (-1);
  }
  {
#line 253
  __cil_tmp18 = _zip_file_extra_field_prepare_for_change(za___0, idx);
  }
#line 253
  if (__cil_tmp18 < 0) {
#line 254
    return (-1);
  }
#line 256
  de = (za___0->entry + idx)->changes;
#line 258
  ef = de->extra_fields;
#line 259
  ef_prev = (zip_extra_field_t *)((void *)0);
#line 260
  i = 0;
#line 261
  found = 0;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;

#line 263
    if (! ef) {
#line 263
      goto while_break;
    }
#line 264
    if ((int )ef->id == (int )ef_id) {
#line 264
      if ((ef->flags & flags) & 768U) {
#line 265
        if (i == (int )ef_idx) {
#line 266
          found = 1;
#line 267
          goto while_break;
        }
#line 269
        i ++;
      }
    }
#line 271
    ef_prev = ef;
#line 263
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 274
  if (i < (int )ef_idx) {
#line 274
    if ((int )ef_idx != 65535) {
      {
#line 275
      zip_error_set(& za___0->error, 18, 0);
      }
#line 276
      return (-1);
    }
  }
#line 279
  if (flags & 256U) {
    {
#line 280
    ls = _zip_ef_size(de->extra_fields, 256U);
    }
  } else {
#line 282
    ls = (zip_uint16_t )0;
  }
#line 283
  if (flags & 512U) {
    {
#line 284
    cs = _zip_ef_size(de->extra_fields, 512U);
    }
  } else {
#line 286
    cs = (zip_uint16_t )0;
  }
#line 288
  if ((int )ls > (int )cs) {
#line 288
    tmp = (int )ls;
  } else {
#line 288
    tmp = (int )cs;
  }
#line 288
  new_len = tmp;
#line 289
  if (found) {
#line 290
    new_len -= (int )ef->size + 4;
  }
#line 291
  new_len += (int )len + 4;
#line 293
  if (new_len > 65535) {
    {
#line 294
    zip_error_set(& za___0->error, 18, 0);
    }
#line 295
    return (-1);
  }
  {
#line 298
  ef_new = _zip_ef_new(ef_id, len, data, flags);
  }
#line 298
  if ((unsigned long )ef_new == (unsigned long )((void *)0)) {
    {
#line 299
    zip_error_set(& za___0->error, 14, 0);
    }
#line 300
    return (-1);
  }
#line 303
  if (found) {
#line 304
    if ((ef->flags & 768U) == (flags & 768U)) {
      {
#line 305
      ef_new->next = ef->next;
#line 306
      ef->next = (zip_extra_field_t *)((void *)0);
#line 307
      _zip_ef_free(ef);
      }
#line 308
      if (ef_prev) {
#line 309
        ef_prev->next = ef_new;
      } else {
#line 311
        de->extra_fields = ef_new;
      }
    } else {
#line 314
      ef->flags &= ~ (flags & 768U);
#line 315
      ef_new->next = ef->next;
#line 316
      ef->next = ef_new;
    }
  } else
#line 319
  if (ef_prev) {
#line 320
    ef_new->next = ef_prev->next;
#line 321
    ef_prev->next = ef_new;
  } else {
#line 324
    de->extra_fields = ef_new;
  }
#line 326
  return (0);
}
}
#line 332 "/root/libzip/lib/zip_extra_field_api.c"
int _zip_file_extra_field_prepare_for_change(zip_t *za___0 , zip_uint64_t idx ) 
{ 
  zip_entry_t *e ;
  int __cil_tmp4 ;

  {
#line 336
  if (idx >= za___0->nentry) {
    {
#line 337
    zip_error_set(& za___0->error, 18, 0);
    }
#line 338
    return (-1);
  }
#line 341
  e = za___0->entry + idx;
#line 343
  if (e->changes) {
#line 343
    if ((e->changes)->changed & 8U) {
#line 344
      return (0);
    }
  }
#line 346
  if (e->orig) {
    {
#line 347
    __cil_tmp4 = _zip_read_local_ef(za___0, idx);
    }
#line 347
    if (__cil_tmp4 < 0) {
#line 348
      return (-1);
    }
  }
#line 351
  if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
    {
#line 352
    e->changes = _zip_dirent_clone(e->orig);
    }
#line 352
    if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
      {
#line 353
      zip_error_set(& za___0->error, 14, 0);
      }
#line 354
      return (-1);
    }
  }
#line 358
  if (e->orig) {
#line 358
    if ((e->orig)->extra_fields) {
      {
#line 359
      (e->changes)->extra_fields = _zip_ef_clone((e->orig)->extra_fields, & za___0->error);
      }
#line 359
      if ((unsigned long )(e->changes)->extra_fields == (unsigned long )((void *)0)) {
#line 360
        return (-1);
      }
    }
  }
#line 362
  (e->changes)->changed |= 8U;
#line 364
  return (0);
}
}
#line 41 "/root/libzip/lib/zip_extra_field.c"
zip_extra_field_t *_zip_ef_clone(zip_extra_field_t *ef , zip_error_t *error ) 
{ 
  zip_extra_field_t *head ;
  zip_extra_field_t *prev ;
  zip_extra_field_t *def ;

  {
#line 45
  prev = (zip_extra_field_t *)((void *)0);
#line 45
  head = prev;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;

#line 47
    if (! ef) {
#line 47
      goto while_break;
    }
    {
#line 48
    def = _zip_ef_new(ef->id, ef->size, ef->data, ef->flags);
    }
#line 48
    if ((unsigned long )def == (unsigned long )((void *)0)) {
      {
#line 49
      zip_error_set(error, 14, 0);
#line 50
      _zip_ef_free(head);
      }
#line 51
      return ((zip_extra_field_t *)((void *)0));
    }
#line 54
    if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 55
      head = def;
    }
#line 56
    if (prev) {
#line 57
      prev->next = def;
    }
#line 58
    prev = def;
#line 60
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 63
  return (head);
}
}
#line 68 "/root/libzip/lib/zip_extra_field.c"
zip_extra_field_t *_zip_ef_delete_by_id(zip_extra_field_t *ef , zip_uint16_t id ,
                                        zip_uint16_t id_idx , zip_flags_t flags ) 
{ 
  zip_extra_field_t *head ;
  zip_extra_field_t *prev ;
  int i ;
  zip_extra_field_t *tmp ;

  {
#line 73
  i = 0;
#line 74
  head = ef;
#line 75
  prev = (zip_extra_field_t *)((void *)0);
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 76
    if (! ef) {
#line 76
      goto while_break;
    }
#line 77
    if ((ef->flags & flags) & 768U) {
#line 77
      if ((int )ef->id == (int )id) {
        _L___10: 
#line 78
        if ((int )id_idx == 65535) {
          _L: 
#line 79
          ef->flags &= ~ (flags & 768U);
#line 80
          if ((ef->flags & 768U) == 0U) {
#line 81
            if (prev) {
#line 82
              prev->next = ef->next;
            } else {
#line 84
              head = ef->next;
            }
            {
#line 85
            ef->next = (zip_extra_field_t *)((void *)0);
#line 86
            _zip_ef_free(ef);
            }
#line 88
            if ((int )id_idx == 65535) {
#line 89
              goto while_continue;
            }
          }
        } else
#line 78
        if (i == (int )id_idx) {
#line 78
          goto _L;
        }
#line 93
        i ++;
#line 94
        if (i > (int )id_idx) {
#line 95
          goto while_break;
        }
      } else
#line 77
      if ((int )id == 65535) {
#line 77
        goto _L___10;
      }
    }
#line 97
    prev = ef;
#line 76
    if (prev) {
#line 76
      tmp = prev->next;
    } else {
#line 76
      tmp = head;
    }
#line 76
    ef = tmp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 100
  return (head);
}
}
#line 106 "/root/libzip/lib/zip_extra_field.c"
void _zip_ef_free(zip_extra_field_t *ef ) 
{ 
  zip_extra_field_t *ef2 ;

  {
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;

#line 110
    if (! ef) {
#line 110
      goto while_break;
    }
    {
#line 111
    ef2 = ef->next;
#line 112
    free((void *)ef->data);
#line 113
    free((void *)ef);
#line 114
    ef = ef2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 119
  return;
}
}
#line 123 "/root/libzip/lib/zip_extra_field.c"
static zip_uint8_t empty___1[1]  ;
#line 120 "/root/libzip/lib/zip_extra_field.c"
zip_uint8_t *_zip_ef_get_by_id(zip_extra_field_t *ef , zip_uint16_t *lenp , zip_uint16_t id ,
                               zip_uint16_t id_idx , zip_flags_t flags , zip_error_t *error ) 
{ 
  int i ;

  {
#line 122
  empty___1[0] = (zip_uint8_t )'\000';
#line 126
  i = 0;
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 127
    if (! ef) {
#line 127
      goto while_break;
    }
#line 128
    if ((int )ef->id == (int )id) {
#line 128
      if ((ef->flags & flags) & 768U) {
#line 129
        if (i < (int )id_idx) {
#line 130
          i ++;
#line 131
          goto while_continue;
        }
#line 134
        if (lenp) {
#line 135
          *lenp = ef->size;
        }
#line 136
        if ((int )ef->size > 0) {
#line 137
          return (ef->data);
        } else {
#line 139
          return (empty___1);
        }
      }
    }
#line 127
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 143
  zip_error_set(error, 9, 0);
  }
#line 144
  return ((zip_uint8_t *)((void *)0));
}
}
#line 149 "/root/libzip/lib/zip_extra_field.c"
zip_extra_field_t *_zip_ef_merge(zip_extra_field_t *to , zip_extra_field_t *from ) 
{ 
  zip_extra_field_t *ef2 ;
  zip_extra_field_t *tt ;
  zip_extra_field_t *tail ;
  int duplicate ;
  int __cil_tmp7 ;

  {
#line 154
  if ((unsigned long )to == (unsigned long )((void *)0)) {
#line 155
    return (from);
  }
#line 157
  tail = to;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;

#line 157
    if (! tail->next) {
#line 157
      goto while_break;
    }
#line 157
    tail = tail->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 160
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 160
    if (! from) {
#line 160
      goto while_break___0;
    }
#line 161
    ef2 = from->next;
#line 163
    duplicate = 0;
#line 164
    tt = to;
    {
#line 164
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 164
      if (! tt) {
#line 164
        goto while_break___1;
      }
      {
#line 165
      __cil_tmp7 = memcmp((void const   *)tt->data, (void const   *)from->data, (unsigned long )tt->size);
      }
#line 165
      if ((int )tt->id == (int )from->id) {
#line 165
        if ((int )tt->size == (int )from->size) {
#line 165
          if (__cil_tmp7 == 0) {
#line 166
            tt->flags |= from->flags & 768U;
#line 167
            duplicate = 1;
#line 168
            goto while_break___1;
          }
        }
      }
#line 164
      tt = tt->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 172
    from->next = (zip_extra_field_t *)((void *)0);
#line 173
    if (duplicate) {
      {
#line 174
      _zip_ef_free(from);
      }
    } else {
#line 176
      tail->next = from;
#line 176
      tail = tail->next;
    }
#line 160
    from = ef2;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 179
  return (to);
}
}
#line 184 "/root/libzip/lib/zip_extra_field.c"
zip_extra_field_t *_zip_ef_new(zip_uint16_t id , zip_uint16_t size , zip_uint8_t *data ,
                               zip_flags_t flags ) 
{ 
  zip_extra_field_t *ef ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 188
  __cil_tmp6 = malloc(sizeof(*ef));
#line 188
  ef = (zip_extra_field_t *)__cil_tmp6;
  }
#line 188
  if ((unsigned long )ef == (unsigned long )((void *)0)) {
#line 189
    return ((zip_extra_field_t *)((void *)0));
  }
#line 191
  ef->next = (zip_extra_field_t *)((void *)0);
#line 192
  ef->flags = flags;
#line 193
  ef->id = id;
#line 194
  ef->size = size;
#line 195
  if ((int )size > 0) {
    {
#line 196
    __cil_tmp7 = _zip_memdup((void const   *)data, (size_t )size, (zip_error_t *)((void *)0));
#line 196
    ef->data = (zip_uint8_t *)__cil_tmp7;
    }
#line 196
    if ((unsigned long )ef->data == (unsigned long )((void *)0)) {
      {
#line 197
      free((void *)ef);
      }
#line 198
      return ((zip_extra_field_t *)((void *)0));
    }
  } else {
#line 202
    ef->data = (zip_uint8_t *)((void *)0);
  }
#line 204
  return (ef);
}
}
#line 209 "/root/libzip/lib/zip_extra_field.c"
int _zip_ef_parse(zip_uint8_t *data , zip_uint16_t len , zip_flags_t flags , zip_extra_field_t **ef_head_p ,
                  zip_error_t *error ) 
{ 
  zip_buffer_t *buffer ;
  zip_extra_field_t *ef ;
  zip_extra_field_t *ef2 ;
  zip_extra_field_t *ef_head ;
  int __cil_tmp11 ;
  zip_uint64_t __cil_tmp12 ;
  zip_uint16_t fid ;
  zip_uint16_t flen ;
  zip_uint8_t *ef_data ;
  int __cil_tmp20 ;
  size_t glen ;
  zip_uint64_t __cil_tmp22 ;
  zip_uint8_t *garbage ;
  int __cil_tmp25 ;

  {
  {
#line 214
  buffer = _zip_buffer_new(data, (zip_uint64_t )len);
  }
#line 214
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 215
    zip_error_set(error, 14, 0);
    }
#line 216
    return (0);
  }
#line 219
  ef = (zip_extra_field_t *)((void *)0);
#line 219
  ef_head = ef;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 221
    __cil_tmp12 = _zip_buffer_left(buffer);
#line 221
    __cil_tmp11 = _zip_buffer_ok(buffer);
    }
#line 221
    if (__cil_tmp11) {
#line 221
      if (! (__cil_tmp12 >= 4UL)) {
#line 221
        goto while_break;
      }
    } else {
#line 221
      goto while_break;
    }
    {
#line 225
    fid = _zip_buffer_get_16(buffer);
#line 226
    flen = _zip_buffer_get_16(buffer);
#line 227
    ef_data = _zip_buffer_get(buffer, (zip_uint64_t )flen);
    }
#line 229
    if ((unsigned long )ef_data == (unsigned long )((void *)0)) {
      {
#line 230
      zip_error_set(error, 21, 0);
#line 231
      _zip_buffer_free(buffer);
#line 232
      _zip_ef_free(ef_head);
      }
#line 233
      return (0);
    }
    {
#line 236
    ef2 = _zip_ef_new(fid, flen, ef_data, flags);
    }
#line 236
    if ((unsigned long )ef2 == (unsigned long )((void *)0)) {
      {
#line 237
      zip_error_set(error, 14, 0);
#line 238
      _zip_buffer_free(buffer);
#line 239
      _zip_ef_free(ef_head);
      }
#line 240
      return (0);
    }
#line 243
    if (ef_head) {
#line 244
      ef->next = ef2;
#line 245
      ef = ef2;
    } else {
#line 248
      ef = ef2;
#line 248
      ef_head = ef;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 251
  __cil_tmp20 = _zip_buffer_eof(buffer);
  }
#line 251
  if (! __cil_tmp20) {
    {
#line 254
    __cil_tmp22 = _zip_buffer_left(buffer);
#line 254
    glen = __cil_tmp22;
#line 256
    garbage = _zip_buffer_get(buffer, glen);
#line 257
    __cil_tmp25 = memcmp((void const   *)garbage, (void const   *)"", glen);
    }
#line 257
    if ((unsigned long )garbage == (unsigned long )((void *)0)) {
      {
#line 258
      zip_error_set(error, 21, 0);
#line 259
      _zip_buffer_free(buffer);
#line 260
      _zip_ef_free(ef_head);
      }
#line 261
      return (0);
    } else
#line 257
    if (glen >= 4UL) {
      {
#line 258
      zip_error_set(error, 21, 0);
#line 259
      _zip_buffer_free(buffer);
#line 260
      _zip_ef_free(ef_head);
      }
#line 261
      return (0);
    } else
#line 257
    if (__cil_tmp25 != 0) {
      {
#line 258
      zip_error_set(error, 21, 0);
#line 259
      _zip_buffer_free(buffer);
#line 260
      _zip_ef_free(ef_head);
      }
#line 261
      return (0);
    }
  }
  {
#line 265
  _zip_buffer_free(buffer);
  }
#line 267
  if (ef_head_p) {
#line 268
    *ef_head_p = ef_head;
  } else {
    {
#line 271
    _zip_ef_free(ef_head);
    }
  }
#line 274
  return (1);
}
}
#line 279 "/root/libzip/lib/zip_extra_field.c"
zip_extra_field_t *_zip_ef_remove_internal(zip_extra_field_t *ef ) 
{ 
  zip_extra_field_t *ef_head ;
  zip_extra_field_t *prev ;
  zip_extra_field_t *next ;

  {
#line 284
  ef_head = ef;
#line 285
  prev = (zip_extra_field_t *)((void *)0);
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;

#line 287
    if (! ef) {
#line 287
      goto while_break;
    }
#line 288
    if ((int )ef->id == 25461) {
      _L: 
#line 289
      next = ef->next;
#line 290
      if ((unsigned long )ef_head == (unsigned long )ef) {
#line 291
        ef_head = next;
      }
      {
#line 292
      ef->next = (zip_extra_field_t *)((void *)0);
#line 293
      _zip_ef_free(ef);
      }
#line 294
      if (prev) {
#line 295
        prev->next = next;
      }
#line 296
      ef = next;
    } else
#line 288
    if ((int )ef->id == 28789) {
#line 288
      goto _L;
    } else
#line 288
    if ((int )ef->id == 1) {
#line 288
      goto _L;
    } else {
#line 299
      prev = ef;
#line 300
      ef = ef->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 304
  return (ef_head);
}
}
#line 309 "/root/libzip/lib/zip_extra_field.c"
zip_uint16_t _zip_ef_size(zip_extra_field_t *ef , zip_flags_t flags ) 
{ 
  zip_uint16_t size ;

  {
#line 313
  size = (zip_uint16_t )0;
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;

#line 314
    if (! ef) {
#line 314
      goto while_break;
    }
#line 315
    if ((ef->flags & flags) & 768U) {
#line 316
      size = (zip_uint16_t )(((int )size + 4) + (int )ef->size);
    }
#line 314
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 319
  return (size);
}
}
#line 324 "/root/libzip/lib/zip_extra_field.c"
int _zip_ef_write(zip_t *za___0 , zip_extra_field_t *ef , zip_flags_t flags ) 
{ 
  zip_uint8_t b[4] ;
  zip_buffer_t *buffer ;
  zip_buffer_t *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 327
  __cil_tmp6 = _zip_buffer_new(b, sizeof(b));
#line 327
  buffer = __cil_tmp6;
  }
#line 329
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 330
    return (-1);
  }
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;

#line 333
    if (! ef) {
#line 333
      goto while_break;
    }
#line 334
    if ((ef->flags & flags) & 768U) {
      {
#line 335
      _zip_buffer_set_offset(buffer, (zip_uint64_t )0);
#line 336
      _zip_buffer_put_16(buffer, ef->id);
#line 337
      _zip_buffer_put_16(buffer, ef->size);
#line 338
      __cil_tmp7 = _zip_buffer_ok(buffer);
      }
#line 338
      if (! __cil_tmp7) {
        {
#line 339
        zip_error_set(& za___0->error, 20, 0);
#line 340
        _zip_buffer_free(buffer);
        }
#line 341
        return (-1);
      }
      {
#line 343
      __cil_tmp8 = _zip_write(za___0, (void const   *)(b), (zip_uint64_t )4);
      }
#line 343
      if (__cil_tmp8 < 0) {
        {
#line 344
        _zip_buffer_free(buffer);
        }
#line 345
        return (-1);
      }
#line 347
      if ((int )ef->size > 0) {
        {
#line 348
        __cil_tmp9 = _zip_write(za___0, (void const   *)ef->data, (zip_uint64_t )ef->size);
        }
#line 348
        if (__cil_tmp9 < 0) {
          {
#line 349
          _zip_buffer_free(buffer);
          }
#line 350
          return (-1);
        }
      }
    }
#line 333
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 356
  _zip_buffer_free(buffer);
  }
#line 357
  return (0);
}
}
#line 362 "/root/libzip/lib/zip_extra_field.c"
int _zip_read_local_ef(zip_t *za___0 , zip_uint64_t idx ) 
{ 
  zip_entry_t *e ;
  unsigned char b[4] ;
  zip_buffer_t *buffer ;
  zip_uint16_t fname_len ;
  zip_uint16_t ef_len ;
  int __cil_tmp8 ;
  int __cil_tmp12 ;
  zip_extra_field_t *ef ;
  zip_uint8_t *ef_raw ;
  int __cil_tmp15 ;
  int *__cil_tmp16 ;
  int __cil_tmp18 ;

  {
#line 369
  if (idx >= za___0->nentry) {
    {
#line 370
    zip_error_set(& za___0->error, 18, 0);
    }
#line 371
    return (-1);
  }
#line 374
  e = za___0->entry + idx;
#line 376
  if ((unsigned long )e->orig == (unsigned long )((void *)0)) {
#line 377
    return (0);
  } else
#line 376
  if ((e->orig)->local_extra_fields_read) {
#line 377
    return (0);
  }
#line 379
  if ((e->orig)->offset + 26UL > 0xffffffffffffffffUL) {
    {
#line 380
    zip_error_set(& za___0->error, 4, 27);
    }
#line 381
    return (-1);
  }
  {
#line 384
  __cil_tmp8 = zip_source_seek(za___0->src, (zip_int64_t )((e->orig)->offset + 26UL),
                               0);
  }
#line 384
  if (__cil_tmp8 < 0) {
    {
#line 385
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 386
    return (-1);
  }
  {
#line 389
  buffer = _zip_buffer_new_from_source(za___0->src, sizeof(b), b, & za___0->error);
  }
#line 389
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 390
    return (-1);
  }
  {
#line 393
  fname_len = _zip_buffer_get_16(buffer);
#line 394
  ef_len = _zip_buffer_get_16(buffer);
#line 396
  __cil_tmp12 = _zip_buffer_eof(buffer);
  }
#line 396
  if (! __cil_tmp12) {
    {
#line 397
    _zip_buffer_free(buffer);
#line 398
    zip_error_set(& za___0->error, 20, 0);
    }
#line 399
    return (-1);
  }
  {
#line 402
  _zip_buffer_free(buffer);
  }
#line 404
  if ((int )ef_len > 0) {
    {
#line 408
    __cil_tmp15 = zip_source_seek(za___0->src, (zip_int64_t )fname_len, 1);
    }
#line 408
    if (__cil_tmp15 < 0) {
      {
#line 409
      __cil_tmp16 = __errno_location();
#line 409
      zip_error_set(& za___0->error, 4, *__cil_tmp16);
      }
#line 410
      return (-1);
    }
    {
#line 413
    ef_raw = _zip_read_data((zip_buffer_t *)((void *)0), za___0->src, (size_t )ef_len,
                            0, & za___0->error);
    }
#line 415
    if ((unsigned long )ef_raw == (unsigned long )((void *)0)) {
#line 416
      return (-1);
    }
    {
#line 418
    __cil_tmp18 = _zip_ef_parse(ef_raw, ef_len, 256U, & ef, & za___0->error);
    }
#line 418
    if (! __cil_tmp18) {
      {
#line 419
      free((void *)ef_raw);
      }
#line 420
      return (-1);
    }
    {
#line 422
    free((void *)ef_raw);
    }
#line 424
    if (ef) {
      {
#line 425
      ef = _zip_ef_remove_internal(ef);
#line 426
      (e->orig)->extra_fields = _zip_ef_merge((e->orig)->extra_fields, ef);
      }
    }
  }
#line 430
  (e->orig)->local_extra_fields_read = 1;
#line 432
  if (e->changes) {
#line 432
    if ((e->changes)->local_extra_fields_read == 0) {
#line 433
      (e->changes)->extra_fields = (e->orig)->extra_fields;
#line 434
      (e->changes)->local_extra_fields_read = 1;
    }
  }
#line 437
  return (0);
}
}
#line 44 "/root/libzip/lib/zip_error_to_str.c"
int zip_error_to_str(char *buf , zip_uint64_t len , int ze , int se ) 
{ 
  char const   *zs ;
  char const   *ss ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int __cil_tmp12 ;

  {
#line 48
  if (ze < 0) {
    {
#line 49
    __cil_tmp7 = snprintf(buf, len, "Unknown error %d\230\001", ze);
    }
#line 49
    return (__cil_tmp7);
  } else
#line 48
  if (ze >= (int )_zip_nerr_str) {
    {
#line 49
    __cil_tmp7 = snprintf(buf, len, "Unknown error %d\230\001", ze);
    }
#line 49
    return (__cil_tmp7);
  }
#line 51
  zs = (char const   *)_zip_err_str[ze];
#line 54
  if (_zip_err_type[ze] == 1) {
#line 54
    goto case_1;
  }
#line 58
  if (_zip_err_type[ze] == 2) {
#line 58
    goto case_2;
  }
#line 62
  goto switch_default;
  case_1: 
  {
#line 55
  __cil_tmp8 = strerror(se);
#line 55
  ss = (char const   *)__cil_tmp8;
  }
#line 56
  goto switch_break;
  case_2: 
  {
#line 59
  ss = zError(se);
  }
#line 60
  goto switch_break;
  switch_default: 
#line 63
  ss = (char const   *)((void *)0);
  switch_break: ;
#line 66
  if (ss) {
#line 66
    tmp = ": ";
  } else {
#line 66
    tmp = "\220";
  }
#line 66
  if (ss) {
#line 66
    tmp___0 = ss;
  } else {
#line 66
    tmp___0 = "\220";
  }
  {
#line 66
  __cil_tmp12 = snprintf(buf, len, "%s%s%s", zs, tmp, tmp___0);
  }
#line 66
  return (__cil_tmp12);
}
}
#line 43 "/root/libzip/lib/zip_error_strerror.c"
char const   *zip_error_strerror(zip_error_t *err ) 
{ 
  char const   *zs ;
  char const   *ss ;
  char buf[128] ;
  char *s ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long tmp ;
  void *__cil_tmp11 ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 48
  zip_error_fini(err);
  }
#line 50
  if (err->zip_err < 0) {
    {
#line 51
    sprintf(buf, "Unknown error %d\230\001", err->zip_err);
#line 52
    zs = (char const   *)((void *)0);
#line 53
    ss = (char const   *)(buf);
    }
  } else
#line 50
  if (err->zip_err >= (int )_zip_nerr_str) {
    {
#line 51
    sprintf(buf, "Unknown error %d\230\001", err->zip_err);
#line 52
    zs = (char const   *)((void *)0);
#line 53
    ss = (char const   *)(buf);
    }
  } else {
#line 56
    zs = (char const   *)_zip_err_str[err->zip_err];
#line 59
    if (_zip_err_type[err->zip_err] == 1) {
#line 59
      goto case_1;
    }
#line 63
    if (_zip_err_type[err->zip_err] == 2) {
#line 63
      goto case_2;
    }
#line 67
    goto switch_default;
    case_1: 
    {
#line 60
    __cil_tmp6 = strerror(err->sys_err);
#line 60
    ss = (char const   *)__cil_tmp6;
    }
#line 61
    goto switch_break;
    case_2: 
    {
#line 64
    ss = zError(err->sys_err);
    }
#line 65
    goto switch_break;
    switch_default: 
#line 68
    ss = (char const   *)((void *)0);
    switch_break: ;
  }
#line 72
  if ((unsigned long )ss == (unsigned long )((void *)0)) {
#line 73
    return (zs);
  } else {
#line 75
    if (zs) {
      {
#line 75
      __cil_tmp9 = strlen(zs);
#line 75
      tmp = __cil_tmp9 + 2UL;
      }
    } else {
#line 75
      tmp = 0UL;
    }
    {
#line 75
    __cil_tmp8 = strlen(ss);
#line 75
    __cil_tmp11 = malloc((__cil_tmp8 + tmp) + 1UL);
#line 75
    s = (char *)__cil_tmp11;
    }
#line 75
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 77
      return ((char const   *)_zip_err_str[14]);
    }
#line 79
    if (zs) {
#line 79
      tmp___0 = zs;
    } else {
#line 79
      tmp___0 = "\220";
    }
#line 79
    if (zs) {
#line 79
      tmp___1 = ": ";
    } else {
#line 79
      tmp___1 = "\220";
    }
    {
#line 79
    sprintf(s, "%s%s%s", tmp___0, tmp___1, ss);
#line 83
    err->str = s;
    }
#line 85
    return ((char const   *)s);
  }
}
}
#line 39 "/root/libzip/lib/zip_error_get_sys_type.c"
int zip_error_get_sys_type(int ze ) 
{ 


  {
#line 41
  if (ze < 0) {
#line 42
    return (0);
  } else
#line 41
  if (ze >= (int )_zip_nerr_str) {
#line 42
    return (0);
  }
#line 44
  return ((int )_zip_err_type[ze]);
}
}
#line 40 "/root/libzip/lib/zip_error_get.c"
void zip_error_get(zip_t *za___0 , int *zep , int *sep ) 
{ 


  {
  {
#line 42
  _zip_error_get(& za___0->error, zep, sep);
  }
#line 44
  return;
}
}
#line 47 "/root/libzip/lib/zip_error_get.c"
zip_error_t *zip_get_error(zip_t *za___0 ) 
{ 


  {
#line 49
  return (& za___0->error);
}
}
#line 54 "/root/libzip/lib/zip_error_get.c"
zip_error_t *zip_file_get_error(zip_file_t *f ) 
{ 


  {
#line 56
  return (& f->error);
}
}
#line 39 "/root/libzip/lib/zip_error_clear.c"
void zip_error_clear(zip_t *za___0 ) 
{ 


  {
#line 41
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 42
    return;
  }
  {
#line 44
  _zip_error_clear(& za___0->error);
  }
#line 46
  return;
}
}
#line 40 "/root/libzip/lib/zip_error.c"
int zip_error_code_system(zip_error_t *error ) 
{ 


  {
#line 41
  return (error->sys_err);
}
}
#line 46 "/root/libzip/lib/zip_error.c"
int zip_error_code_zip(zip_error_t *error ) 
{ 


  {
#line 47
  return (error->zip_err);
}
}
#line 52 "/root/libzip/lib/zip_error.c"
void zip_error_fini(zip_error_t *err ) 
{ 


  {
  {
#line 54
  free((void *)err->str);
#line 55
  err->str = (char *)((void *)0);
  }
#line 57
  return;
}
}
#line 60 "/root/libzip/lib/zip_error.c"
void zip_error_init(zip_error_t *err ) 
{ 


  {
#line 62
  err->zip_err = 0;
#line 63
  err->sys_err = 0;
#line 64
  err->str = (char *)((void *)0);
#line 65
  return;
}
}
#line 68 "/root/libzip/lib/zip_error.c"
void zip_error_init_with_code(zip_error_t *error , int ze ) 
{ 
  int __cil_tmp3 ;
  int *tmp ;

  {
  {
#line 70
  zip_error_init(error);
#line 71
  error->zip_err = ze;
#line 72
  __cil_tmp3 = zip_error_system_type(error);
  }
#line 73
  if (__cil_tmp3 == 1) {
#line 73
    goto case_1;
  }
#line 77
  goto switch_default;
  case_1: 
  {
#line 74
  tmp = __errno_location();
#line 74
  error->sys_err = (int )tmp;
  }
#line 75
  goto switch_break;
  switch_default: 
#line 78
  error->sys_err = 0;
#line 79
  goto switch_break;
  switch_break: ;
#line 82
  return;
}
}
#line 85 "/root/libzip/lib/zip_error.c"
int zip_error_system_type(zip_error_t *error ) 
{ 


  {
#line 86
  if (error->zip_err < 0) {
#line 87
    return (0);
  } else
#line 86
  if (error->zip_err >= (int )_zip_nerr_str) {
#line 87
    return (0);
  }
#line 89
  return ((int )_zip_err_type[error->zip_err]);
}
}
#line 94 "/root/libzip/lib/zip_error.c"
void _zip_error_clear(zip_error_t *err ) 
{ 


  {
#line 96
  if ((unsigned long )err == (unsigned long )((void *)0)) {
#line 97
    return;
  }
#line 99
  err->zip_err = 0;
#line 100
  err->sys_err = 0;
#line 101
  return;
}
}
#line 105 "/root/libzip/lib/zip_error.c"
void _zip_error_copy(zip_error_t *dst , zip_error_t *src ) 
{ 


  {
#line 107
  dst->zip_err = src->zip_err;
#line 108
  dst->sys_err = src->sys_err;
#line 109
  return;
}
}
#line 113 "/root/libzip/lib/zip_error.c"
void _zip_error_get(zip_error_t *err , int *zep , int *sep ) 
{ 
  int __cil_tmp4 ;

  {
#line 115
  if (zep) {
#line 116
    *zep = err->zip_err;
  }
#line 117
  if (sep) {
    {
#line 118
    __cil_tmp4 = zip_error_system_type(err);
    }
#line 118
    if (__cil_tmp4 != 0) {
#line 119
      *sep = err->sys_err;
    } else {
#line 121
      *sep = 0;
    }
  }
#line 124
  return;
}
}
#line 127 "/root/libzip/lib/zip_error.c"
void zip_error_set(zip_error_t *err , int ze , int se ) 
{ 


  {
#line 129
  if (err) {
#line 130
    err->zip_err = ze;
#line 131
    err->sys_err = se;
  }
#line 133
  return;
}
}
#line 137 "/root/libzip/lib/zip_error.c"
void _zip_error_set_from_source(zip_error_t *err , zip_source_t *src ) 
{ 
  zip_error_t *__cil_tmp3 ;

  {
  {
#line 139
  __cil_tmp3 = zip_source_error(src);
#line 139
  _zip_error_copy(err, __cil_tmp3);
  }
#line 141
  return;
}
}
#line 144 "/root/libzip/lib/zip_error.c"
zip_int64_t zip_error_to_data(zip_error_t *error , void *data , zip_uint64_t length ) 
{ 
  int *e ;

  {
#line 146
  e = (int *)data;
#line 148
  if (length < sizeof(int ) * 2UL) {
#line 149
    return ((zip_int64_t )-1);
  }
  {
#line 152
  *(e + 0) = zip_error_code_zip(error);
#line 153
  *(e + 1) = zip_error_code_system(error);
  }
#line 154
  return ((zip_int64_t )(sizeof(int ) * 2UL));
}
}
#line 8 "/root/libzip/lib/zip_err_str.c"
char const   * const  _zip_err_str[31]  = 
#line 8 "/root/libzip/lib/zip_err_str.c"
  {      (char const   */* const  */)"No error",      (char const   */* const  */)"Multi-disk zip archives not supported",      (char const   */* const  */)"Renaming temporary file failed",      (char const   */* const  */)"Closing zip archive failed", 
        (char const   */* const  */)"Seek error",      (char const   */* const  */)"Read error",      (char const   */* const  */)"Write error",      (char const   */* const  */)"CRC error", 
        (char const   */* const  */)"Containing zip archive was closed",      (char const   */* const  */)"No such file",      (char const   */* const  */)"File already exists",      (char const   */* const  */)"Can\'t open file", 
        (char const   */* const  */)"Failure to create temporary file\323\001 ",      (char const   */* const  */)"Zlib error",      (char const   */* const  */)"Malloc failure",      (char const   */* const  */)"Entry has been changed", 
        (char const   */* const  */)"Compression method not supported\360\246\204P8V",      (char const   */* const  */)"Premature end of file",      (char const   */* const  */)"Invalid argument\323\001 ",      (char const   */* const  */)"Not a zip archive", 
        (char const   */* const  */)"Internal error",      (char const   */* const  */)"Zip archive inconsistent\323\001 ",      (char const   */* const  */)"Can\'t remove file",      (char const   */* const  */)"Entry has been deleted", 
        (char const   */* const  */)"Encryption method not supported",      (char const   */* const  */)"Read-only archive",      (char const   */* const  */)"No password provided",      (char const   */* const  */)"Wrong password provided", 
        (char const   */* const  */)"Operation not supported",      (char const   */* const  */)"Resource still in use",      (char const   */* const  */)"Tell error"};
#line 42 "/root/libzip/lib/zip_err_str.c"
int const   _zip_nerr_str  =    (int const   )((int )(sizeof(_zip_err_str) / sizeof(_zip_err_str[0])));
#line 48 "/root/libzip/lib/zip_err_str.c"
int const   _zip_err_type[31]  = 
#line 48
  {      (int const   )0,      (int const   )0,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )1,      (int const   )2,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1};
#line 38 "/root/libzip/lib/zip_entry.c"
void _zip_entry_finalize(zip_entry_t *e ) 
{ 


  {
  {
#line 40
  _zip_unchange_data(e);
#line 41
  _zip_dirent_free(e->orig);
#line 42
  _zip_dirent_free(e->changes);
  }
#line 44
  return;
}
}
#line 47 "/root/libzip/lib/zip_entry.c"
void _zip_entry_init(zip_entry_t *e ) 
{ 


  {
#line 49
  e->orig = (zip_dirent_t *)((void *)0);
#line 50
  e->changes = (zip_dirent_t *)((void *)0);
#line 51
  e->source = (zip_source_t *)((void *)0);
#line 52
  e->deleted = 0;
#line 53
  return;
}
}
#line 45 "/root/libzip/lib/zip_discard.c"
void zip_discard(zip_t *za___0 ) 
{ 
  zip_uint64_t i ;

  {
#line 49
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 50
    return;
  }
#line 52
  if (za___0->src) {
    {
#line 53
    zip_source_close(za___0->src);
#line 54
    zip_source_free(za___0->src);
    }
  }
  {
#line 57
  free((void *)za___0->default_password);
#line 58
  _zip_string_free(za___0->comment_orig);
#line 59
  _zip_string_free(za___0->comment_changes);
#line 61
  _zip_hash_free(za___0->names);
  }
#line 63
  if (za___0->entry) {
#line 64
    i = (zip_uint64_t )0;
    {
#line 64
    while (1) {
      while_continue: /* CIL Label */ ;

#line 64
      if (! (i < za___0->nentry)) {
#line 64
        goto while_break;
      }
      {
#line 65
      _zip_entry_finalize(za___0->entry + i);
#line 64
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 66
    free((void *)za___0->entry);
    }
  }
#line 69
  i = (zip_uint64_t )0;
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 69
    if (! (i < (unsigned long )za___0->nopen_source)) {
#line 69
      goto while_break___0;
    }
    {
#line 70
    _zip_source_invalidate(*(za___0->open_source + i));
#line 69
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 72
  free((void *)za___0->open_source);
#line 74
  zip_error_fini(& za___0->error);
#line 76
  free((void *)za___0);
  }
#line 78
  return;
}
}
#line 43 "/root/libzip/lib/zip_dirent.c"
static time_t _zip_d2u_time(zip_uint16_t dtime , zip_uint16_t ddate ) ;
#line 44
static zip_string_t *_zip_dirent_process_ef_utf_8(zip_dirent_t *de , zip_uint16_t id ,
                                                  zip_string_t *str ) ;
#line 45
static zip_extra_field_t *_zip_ef_utf8(zip_uint16_t id , zip_string_t *str , zip_error_t *error ) ;
#line 49 "/root/libzip/lib/zip_dirent.c"
void _zip_cdir_free(zip_cdir_t *cd ) 
{ 
  zip_uint64_t i ;

  {
#line 53
  if (! cd) {
#line 54
    return;
  }
#line 56
  i = (zip_uint64_t )0;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;

#line 56
    if (! (i < cd->nentry)) {
#line 56
      goto while_break;
    }
    {
#line 57
    _zip_entry_finalize(cd->entry + i);
#line 56
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 58
  free((void *)cd->entry);
#line 59
  _zip_string_free(cd->comment);
#line 60
  free((void *)cd);
  }
#line 62
  return;
}
}
#line 65 "/root/libzip/lib/zip_dirent.c"
zip_cdir_t *_zip_cdir_new(zip_uint64_t nentry , zip_error_t *error ) 
{ 
  zip_cdir_t *cd ;
  zip_uint64_t i ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 70
  __cil_tmp5 = malloc(sizeof(*cd));
#line 70
  cd = (zip_cdir_t *)__cil_tmp5;
  }
#line 70
  if ((unsigned long )cd == (unsigned long )((void *)0)) {
    {
#line 71
    zip_error_set(error, 14, 0);
    }
#line 72
    return ((zip_cdir_t *)((void *)0));
  }
#line 75
  if (nentry == 0UL) {
#line 76
    cd->entry = (zip_entry_t *)((void *)0);
  } else {
    {
#line 77
    __cil_tmp6 = malloc(sizeof(*(cd->entry)) * nentry);
#line 77
    cd->entry = (zip_entry_t *)__cil_tmp6;
    }
#line 77
    if ((unsigned long )cd->entry == (unsigned long )((void *)0)) {
      {
#line 78
      zip_error_set(error, 14, 0);
#line 79
      free((void *)cd);
      }
#line 80
      return ((zip_cdir_t *)((void *)0));
    } else
#line 77
    if (nentry > 0xffffffffffffffffUL / sizeof(*(cd->entry))) {
      {
#line 78
      zip_error_set(error, 14, 0);
#line 79
      free((void *)cd);
      }
#line 80
      return ((zip_cdir_t *)((void *)0));
    }
  }
#line 83
  i = (zip_uint64_t )0;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;

#line 83
    if (! (i < nentry)) {
#line 83
      goto while_break;
    }
    {
#line 84
    _zip_entry_init(cd->entry + i);
#line 83
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 86
  cd->nentry_alloc = nentry;
#line 86
  cd->nentry = cd->nentry_alloc;
#line 87
  cd->offset = (zip_uint64_t )0;
#line 87
  cd->size = cd->offset;
#line 88
  cd->comment = (zip_string_t *)((void *)0);
#line 90
  return (cd);
}
}
#line 95 "/root/libzip/lib/zip_dirent.c"
zip_int64_t _zip_cdir_write(zip_t *za___0 , zip_filelist_t *filelist , zip_uint64_t survivors ) 
{ 
  zip_uint64_t offset ;
  zip_uint64_t size ;
  zip_string_t *comment ;
  zip_uint8_t buf[98] ;
  zip_buffer_t *buffer ;
  zip_int64_t off ;
  zip_uint64_t i ;
  int is_zip64 ;
  int ret ;
  zip_entry_t *entry ;
  zip_dirent_t *tmp ;
  int __cil_tmp16 ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  zip_string_t *tmp___4 ;
  int tmp___5 ;
  int __cil_tmp26 ;
  zip_uint8_t *__cil_tmp27 ;
  zip_uint64_t __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;

  {
  {
#line 106
  off = zip_source_tell_write(za___0->src);
  }
#line 106
  if (off < 0L) {
    {
#line 107
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 108
    return ((zip_int64_t )-1);
  }
#line 110
  offset = (zip_uint64_t )off;
#line 112
  is_zip64 = 0;
#line 114
  i = (zip_uint64_t )0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;

#line 114
    if (! (i < survivors)) {
#line 114
      goto while_break;
    }
#line 115
    entry = za___0->entry + (filelist + i)->idx;
#line 117
    if (entry->changes) {
#line 117
      tmp = entry->changes;
    } else {
#line 117
      tmp = entry->orig;
    }
    {
#line 117
    __cil_tmp16 = _zip_dirent_write(za___0, tmp, 512U);
#line 117
    ret = __cil_tmp16;
    }
#line 117
    if (ret < 0) {
#line 118
      return ((zip_int64_t )-1);
    }
#line 119
    if (ret) {
#line 120
      is_zip64 = 1;
    }
#line 114
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 123
  off = zip_source_tell_write(za___0->src);
  }
#line 123
  if (off < 0L) {
    {
#line 124
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 125
    return ((zip_int64_t )-1);
  }
#line 127
  size = (zip_uint64_t )off - offset;
#line 129
  if (offset > 4294967295UL) {
#line 130
    is_zip64 = 1;
  } else
#line 129
  if (survivors > 65535UL) {
#line 130
    is_zip64 = 1;
  }
  {
#line 133
  buffer = _zip_buffer_new(buf, sizeof(buf));
  }
#line 133
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 134
    zip_error_set(& za___0->error, 14, 0);
    }
#line 135
    return ((zip_int64_t )-1);
  }
#line 138
  if (is_zip64) {
    {
#line 139
    _zip_buffer_put(buffer, (void const   *)"PK\006\006", (size_t )4);
#line 140
    _zip_buffer_put_64(buffer, (zip_uint64_t )44);
#line 141
    _zip_buffer_put_16(buffer, (zip_uint16_t )45);
#line 142
    _zip_buffer_put_16(buffer, (zip_uint16_t )45);
#line 143
    _zip_buffer_put_32(buffer, (zip_uint32_t )0);
#line 144
    _zip_buffer_put_32(buffer, (zip_uint32_t )0);
#line 145
    _zip_buffer_put_64(buffer, survivors);
#line 146
    _zip_buffer_put_64(buffer, survivors);
#line 147
    _zip_buffer_put_64(buffer, size);
#line 148
    _zip_buffer_put_64(buffer, offset);
#line 149
    _zip_buffer_put(buffer, (void const   *)"PK\006\a", (size_t )4);
#line 150
    _zip_buffer_put_32(buffer, (zip_uint32_t )0);
#line 151
    _zip_buffer_put_64(buffer, offset + size);
#line 152
    _zip_buffer_put_32(buffer, (zip_uint32_t )1);
    }
  }
  {
#line 155
  _zip_buffer_put(buffer, (void const   *)"PK\005\006", (size_t )4);
#line 156
  _zip_buffer_put_32(buffer, (zip_uint32_t )0);
  }
#line 157
  if (survivors >= 65535UL) {
#line 157
    tmp___0 = 65535UL;
  } else {
#line 157
    tmp___0 = survivors;
  }
  {
#line 157
  _zip_buffer_put_16(buffer, (zip_uint16_t )tmp___0);
  }
#line 158
  if (survivors >= 65535UL) {
#line 158
    tmp___1 = 65535UL;
  } else {
#line 158
    tmp___1 = survivors;
  }
  {
#line 158
  _zip_buffer_put_16(buffer, (zip_uint16_t )tmp___1);
  }
#line 159
  if (size >= 4294967295UL) {
#line 159
    tmp___2 = 4294967295U;
  } else {
#line 159
    tmp___2 = (zip_uint32_t )size;
  }
  {
#line 159
  _zip_buffer_put_32(buffer, tmp___2);
  }
#line 160
  if (offset >= 4294967295UL) {
#line 160
    tmp___3 = 4294967295U;
  } else {
#line 160
    tmp___3 = (zip_uint32_t )offset;
  }
  {
#line 160
  _zip_buffer_put_32(buffer, tmp___3);
  }
#line 162
  if (za___0->comment_changed) {
#line 162
    tmp___4 = za___0->comment_changes;
  } else {
#line 162
    tmp___4 = za___0->comment_orig;
  }
#line 162
  comment = tmp___4;
#line 164
  if (comment) {
#line 164
    tmp___5 = (int )comment->length;
  } else {
#line 164
    tmp___5 = 0;
  }
  {
#line 164
  _zip_buffer_put_16(buffer, (zip_uint16_t )tmp___5);
#line 166
  __cil_tmp26 = _zip_buffer_ok(buffer);
  }
#line 166
  if (! __cil_tmp26) {
    {
#line 167
    zip_error_set(& za___0->error, 20, 0);
#line 168
    _zip_buffer_free(buffer);
    }
#line 169
    return ((zip_int64_t )-1);
  }
  {
#line 172
  __cil_tmp27 = _zip_buffer_data(buffer);
#line 172
  __cil_tmp28 = _zip_buffer_offset(buffer);
#line 172
  __cil_tmp29 = _zip_write(za___0, (void const   *)__cil_tmp27, __cil_tmp28);
  }
#line 172
  if (__cil_tmp29 < 0) {
    {
#line 173
    _zip_buffer_free(buffer);
    }
#line 174
    return ((zip_int64_t )-1);
  }
  {
#line 177
  _zip_buffer_free(buffer);
  }
#line 179
  if (comment) {
    {
#line 180
    __cil_tmp30 = _zip_write(za___0, (void const   *)comment->raw, (zip_uint64_t )comment->length);
    }
#line 180
    if (__cil_tmp30 < 0) {
#line 181
      return ((zip_int64_t )-1);
    }
  }
#line 185
  return ((zip_int64_t )size);
}
}
#line 190 "/root/libzip/lib/zip_dirent.c"
zip_dirent_t *_zip_dirent_clone(zip_dirent_t *sde ) 
{ 
  zip_dirent_t *tde ;
  void *__cil_tmp3 ;

  {
  {
#line 194
  __cil_tmp3 = malloc(sizeof(*tde));
#line 194
  tde = (zip_dirent_t *)__cil_tmp3;
  }
#line 194
  if ((unsigned long )tde == (unsigned long )((void *)0)) {
#line 195
    return ((zip_dirent_t *)((void *)0));
  }
#line 197
  if (sde) {
    {
#line 198
    memcpy((void *)tde, (void const   *)sde, sizeof(*sde));
    }
  } else {
    {
#line 200
    _zip_dirent_init(tde);
    }
  }
#line 202
  tde->changed = (zip_uint32_t )0;
#line 203
  tde->cloned = 1;
#line 205
  return (tde);
}
}
#line 210 "/root/libzip/lib/zip_dirent.c"
void _zip_dirent_finalize(zip_dirent_t *zde ) 
{ 


  {
#line 212
  if (! zde->cloned) {
    {
#line 213
    _zip_string_free(zde->filename);
#line 214
    zde->filename = (zip_string_t *)((void *)0);
    }
  } else
#line 212
  if (zde->changed & 2U) {
    {
#line 213
    _zip_string_free(zde->filename);
#line 214
    zde->filename = (zip_string_t *)((void *)0);
    }
  }
#line 216
  if (! zde->cloned) {
    {
#line 217
    _zip_ef_free(zde->extra_fields);
#line 218
    zde->extra_fields = (zip_extra_field_t *)((void *)0);
    }
  } else
#line 216
  if (zde->changed & 8U) {
    {
#line 217
    _zip_ef_free(zde->extra_fields);
#line 218
    zde->extra_fields = (zip_extra_field_t *)((void *)0);
    }
  }
#line 220
  if (! zde->cloned) {
    {
#line 221
    _zip_string_free(zde->comment);
#line 222
    zde->comment = (zip_string_t *)((void *)0);
    }
  } else
#line 220
  if (zde->changed & 4U) {
    {
#line 221
    _zip_string_free(zde->comment);
#line 222
    zde->comment = (zip_string_t *)((void *)0);
    }
  }
#line 225
  return;
}
}
#line 228 "/root/libzip/lib/zip_dirent.c"
void _zip_dirent_free(zip_dirent_t *zde ) 
{ 


  {
#line 230
  if ((unsigned long )zde == (unsigned long )((void *)0)) {
#line 231
    return;
  }
  {
#line 233
  _zip_dirent_finalize(zde);
#line 234
  free((void *)zde);
  }
#line 236
  return;
}
}
#line 239 "/root/libzip/lib/zip_dirent.c"
void _zip_dirent_init(zip_dirent_t *de ) 
{ 


  {
#line 241
  de->changed = (zip_uint32_t )0;
#line 242
  de->local_extra_fields_read = 0;
#line 243
  de->cloned = 0;
#line 245
  de->version_madeby = (zip_uint16_t )(20U | (3U << 8));
#line 246
  de->version_needed = (zip_uint16_t )20;
#line 247
  de->bitflags = (zip_uint16_t )0;
#line 248
  de->comp_method = -1;
#line 249
  de->last_mod = (time_t )0;
#line 250
  de->crc = (zip_uint32_t )0;
#line 251
  de->comp_size = (zip_uint64_t )0;
#line 252
  de->uncomp_size = (zip_uint64_t )0;
#line 253
  de->filename = (zip_string_t *)((void *)0);
#line 254
  de->extra_fields = (zip_extra_field_t *)((void *)0);
#line 255
  de->comment = (zip_string_t *)((void *)0);
#line 256
  de->disk_number = (zip_uint32_t )0;
#line 257
  de->int_attrib = (zip_uint16_t )0;
#line 258
  de->ext_attrib = 33206U << 16;
#line 259
  de->offset = (zip_uint64_t )0;
#line 260
  return;
}
}
#line 264 "/root/libzip/lib/zip_dirent.c"
int _zip_dirent_needs_zip64(zip_dirent_t *de , zip_flags_t flags ) 
{ 


  {
#line 266
  if (de->uncomp_size >= 4294967295UL) {
#line 268
    return (1);
  } else
#line 266
  if (de->comp_size >= 4294967295UL) {
#line 268
    return (1);
  } else
#line 266
  if (flags & 512U) {
#line 266
    if (de->offset >= 4294967295UL) {
#line 268
      return (1);
    }
  }
#line 270
  return (0);
}
}
#line 275 "/root/libzip/lib/zip_dirent.c"
zip_dirent_t *_zip_dirent_new(void) 
{ 
  zip_dirent_t *de ;
  void *__cil_tmp2 ;

  {
  {
#line 279
  __cil_tmp2 = malloc(sizeof(*de));
#line 279
  de = (zip_dirent_t *)__cil_tmp2;
  }
#line 279
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 280
    return ((zip_dirent_t *)((void *)0));
  }
  {
#line 282
  _zip_dirent_init(de);
  }
#line 283
  return (de);
}
}
#line 298 "/root/libzip/lib/zip_dirent.c"
zip_int64_t _zip_dirent_read(zip_dirent_t *zde , zip_source_t *src , zip_buffer_t *buffer ,
                             int local , zip_error_t *error ) 
{ 
  zip_uint8_t buf[46] ;
  zip_uint16_t dostime ;
  zip_uint16_t dosdate ;
  zip_uint32_t size ;
  zip_uint32_t variable_size ;
  zip_uint16_t filename_len ;
  zip_uint16_t comment_len ;
  zip_uint16_t ef_len ;
  int from_buffer ;
  unsigned int tmp ;
  zip_uint64_t __cil_tmp16 ;
  zip_uint8_t *__cil_tmp18 ;
  char const   *tmp___0 ;
  int __cil_tmp20 ;
  zip_uint16_t __cil_tmp24 ;
  zip_uint32_t __cil_tmp29 ;
  zip_uint32_t __cil_tmp30 ;
  zip_uint16_t __cil_tmp34 ;
  zip_uint32_t __cil_tmp37 ;
  int __cil_tmp38 ;
  zip_uint64_t __cil_tmp39 ;
  int __cil_tmp42 ;
  enum zip_encoding_type __cil_tmp43 ;
  zip_uint8_t *ef ;
  zip_uint8_t *__cil_tmp45 ;
  unsigned int tmp___1 ;
  int __cil_tmp47 ;
  enum zip_encoding_type __cil_tmp49 ;
  zip_uint16_t got_len ;
  zip_buffer_t *ef_buffer ;
  zip_uint8_t *ef___0 ;
  unsigned int tmp___2 ;
  zip_uint8_t *__cil_tmp56 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;

  {
#line 305
  from_buffer = (unsigned long )buffer != (unsigned long )((void *)0);
#line 307
  if (local) {
#line 307
    tmp = 30U;
  } else {
#line 307
    tmp = 46U;
  }
#line 307
  size = tmp;
#line 309
  if (buffer) {
    {
#line 310
    __cil_tmp16 = _zip_buffer_left(buffer);
    }
#line 310
    if (__cil_tmp16 < (unsigned long )size) {
      {
#line 311
      zip_error_set(error, 19, 0);
      }
#line 312
      return ((zip_int64_t )-1);
    }
  } else {
    {
#line 316
    buffer = _zip_buffer_new_from_source(src, (zip_uint64_t )size, buf, error);
    }
#line 316
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 317
      return ((zip_int64_t )-1);
    }
  }
  {
#line 321
  __cil_tmp18 = _zip_buffer_get(buffer, (zip_uint64_t )4);
  }
#line 321
  if (local) {
#line 321
    tmp___0 = "PK\003\0048V";
  } else {
#line 321
    tmp___0 = "PK\001\0028V";
  }
  {
#line 321
  __cil_tmp20 = memcmp((void const   *)__cil_tmp18, (void const   *)tmp___0, 4UL);
  }
#line 321
  if (__cil_tmp20 != 0) {
    {
#line 322
    zip_error_set(error, 19, 0);
    }
#line 323
    if (! from_buffer) {
      {
#line 324
      _zip_buffer_free(buffer);
      }
    }
#line 326
    return ((zip_int64_t )-1);
  }
  {
#line 331
  _zip_dirent_init(zde);
  }
#line 332
  if (! local) {
    {
#line 333
    zde->version_madeby = _zip_buffer_get_16(buffer);
    }
  } else {
#line 335
    zde->version_madeby = (zip_uint16_t )0;
  }
  {
#line 336
  zde->version_needed = _zip_buffer_get_16(buffer);
#line 337
  zde->bitflags = _zip_buffer_get_16(buffer);
#line 338
  __cil_tmp24 = _zip_buffer_get_16(buffer);
#line 338
  zde->comp_method = (zip_int32_t )__cil_tmp24;
#line 341
  dostime = _zip_buffer_get_16(buffer);
#line 342
  dosdate = _zip_buffer_get_16(buffer);
#line 343
  zde->last_mod = _zip_d2u_time(dostime, dosdate);
#line 345
  zde->crc = _zip_buffer_get_32(buffer);
#line 346
  __cil_tmp29 = _zip_buffer_get_32(buffer);
#line 346
  zde->comp_size = (zip_uint64_t )__cil_tmp29;
#line 347
  __cil_tmp30 = _zip_buffer_get_32(buffer);
#line 347
  zde->uncomp_size = (zip_uint64_t )__cil_tmp30;
#line 349
  filename_len = _zip_buffer_get_16(buffer);
#line 350
  ef_len = _zip_buffer_get_16(buffer);
  }
#line 352
  if (local) {
#line 353
    comment_len = (zip_uint16_t )0;
#line 354
    zde->disk_number = (zip_uint32_t )0;
#line 355
    zde->int_attrib = (zip_uint16_t )0;
#line 356
    zde->ext_attrib = (zip_uint32_t )0;
#line 357
    zde->offset = (zip_uint64_t )0;
  } else {
    {
#line 359
    comment_len = _zip_buffer_get_16(buffer);
#line 360
    __cil_tmp34 = _zip_buffer_get_16(buffer);
#line 360
    zde->disk_number = (zip_uint32_t )__cil_tmp34;
#line 361
    zde->int_attrib = _zip_buffer_get_16(buffer);
#line 362
    zde->ext_attrib = _zip_buffer_get_32(buffer);
#line 363
    __cil_tmp37 = _zip_buffer_get_32(buffer);
#line 363
    zde->offset = (zip_uint64_t )__cil_tmp37;
    }
  }
  {
#line 366
  __cil_tmp38 = _zip_buffer_ok(buffer);
  }
#line 366
  if (! __cil_tmp38) {
    {
#line 367
    zip_error_set(error, 20, 0);
    }
#line 368
    if (! from_buffer) {
      {
#line 369
      _zip_buffer_free(buffer);
      }
    }
#line 371
    return ((zip_int64_t )-1);
  }
#line 374
  zde->filename = (zip_string_t *)((void *)0);
#line 375
  zde->extra_fields = (zip_extra_field_t *)((void *)0);
#line 376
  zde->comment = (zip_string_t *)((void *)0);
#line 378
  variable_size = ((zip_uint32_t )filename_len + (zip_uint32_t )ef_len) + (zip_uint32_t )comment_len;
#line 380
  if (from_buffer) {
    {
#line 381
    __cil_tmp39 = _zip_buffer_left(buffer);
    }
#line 381
    if (__cil_tmp39 < (unsigned long )variable_size) {
      {
#line 382
      zip_error_set(error, 21, 0);
      }
#line 383
      return ((zip_int64_t )-1);
    }
  } else {
    {
#line 387
    _zip_buffer_free(buffer);
#line 389
    buffer = _zip_buffer_new_from_source(src, (zip_uint64_t )variable_size, (zip_uint8_t *)((void *)0),
                                         error);
    }
#line 389
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 390
      return ((zip_int64_t )-1);
    }
  }
#line 394
  if (filename_len) {
    {
#line 395
    zde->filename = _zip_read_string(buffer, src, filename_len, 1, error);
    }
#line 396
    if (! zde->filename) {
      {
#line 397
      __cil_tmp42 = zip_error_code_zip(error);
      }
#line 397
      if (__cil_tmp42 == 17) {
        {
#line 398
        zip_error_set(error, 21, 0);
        }
      }
#line 400
      if (! from_buffer) {
        {
#line 401
        _zip_buffer_free(buffer);
        }
      }
#line 403
      return ((zip_int64_t )-1);
    }
#line 406
    if ((int )zde->bitflags & 2048) {
      {
#line 407
      __cil_tmp43 = _zip_guess_encoding(zde->filename, (enum zip_encoding_type )2);
      }
#line 407
      if ((unsigned int )__cil_tmp43 == 5U) {
        {
#line 408
        zip_error_set(error, 21, 0);
        }
#line 409
        if (! from_buffer) {
          {
#line 410
          _zip_buffer_free(buffer);
          }
        }
#line 412
        return ((zip_int64_t )-1);
      }
    }
  }
#line 417
  if (ef_len) {
    {
#line 418
    __cil_tmp45 = _zip_read_data(buffer, src, (size_t )ef_len, 0, error);
#line 418
    ef = __cil_tmp45;
    }
#line 420
    if ((unsigned long )ef == (unsigned long )((void *)0)) {
#line 421
      if (! from_buffer) {
        {
#line 422
        _zip_buffer_free(buffer);
        }
      }
#line 424
      return ((zip_int64_t )-1);
    }
#line 426
    if (local) {
#line 426
      tmp___1 = 256U;
    } else {
#line 426
      tmp___1 = 512U;
    }
    {
#line 426
    __cil_tmp47 = _zip_ef_parse(ef, ef_len, tmp___1, & zde->extra_fields, error);
    }
#line 426
    if (! __cil_tmp47) {
      {
#line 427
      free((void *)ef);
      }
#line 428
      if (! from_buffer) {
        {
#line 429
        _zip_buffer_free(buffer);
        }
      }
#line 431
      return ((zip_int64_t )-1);
    }
    {
#line 433
    free((void *)ef);
    }
#line 434
    if (local) {
#line 435
      zde->local_extra_fields_read = 1;
    }
  }
#line 438
  if (comment_len) {
    {
#line 439
    zde->comment = _zip_read_string(buffer, src, comment_len, 0, error);
    }
#line 440
    if (! zde->comment) {
#line 441
      if (! from_buffer) {
        {
#line 442
        _zip_buffer_free(buffer);
        }
      }
#line 444
      return ((zip_int64_t )-1);
    }
#line 446
    if ((int )zde->bitflags & 2048) {
      {
#line 447
      __cil_tmp49 = _zip_guess_encoding(zde->comment, (enum zip_encoding_type )2);
      }
#line 447
      if ((unsigned int )__cil_tmp49 == 5U) {
        {
#line 448
        zip_error_set(error, 21, 0);
        }
#line 449
        if (! from_buffer) {
          {
#line 450
          _zip_buffer_free(buffer);
          }
        }
#line 452
        return ((zip_int64_t )-1);
      }
    }
  }
  {
#line 457
  zde->filename = _zip_dirent_process_ef_utf_8(zde, (zip_uint16_t )28789, zde->filename);
#line 458
  zde->comment = _zip_dirent_process_ef_utf_8(zde, (zip_uint16_t )25461, zde->comment);
  }
#line 462
  if (zde->uncomp_size == 4294967295UL) {
    _L: 
#line 465
    if (local) {
#line 465
      tmp___2 = 256U;
    } else {
#line 465
      tmp___2 = 512U;
    }
    {
#line 465
    __cil_tmp56 = _zip_ef_get_by_id(zde->extra_fields, & got_len, (zip_uint16_t )1,
                                    (zip_uint16_t )0, tmp___2, error);
#line 465
    ef___0 = __cil_tmp56;
    }
#line 467
    if ((unsigned long )ef___0 == (unsigned long )((void *)0)) {
#line 468
      if (! from_buffer) {
        {
#line 469
        _zip_buffer_free(buffer);
        }
      }
#line 471
      return ((zip_int64_t )-1);
    }
    {
#line 474
    ef_buffer = _zip_buffer_new(ef___0, (zip_uint64_t )got_len);
    }
#line 474
    if ((unsigned long )ef_buffer == (unsigned long )((void *)0)) {
      {
#line 475
      zip_error_set(error, 14, 0);
      }
#line 476
      if (! from_buffer) {
        {
#line 477
        _zip_buffer_free(buffer);
        }
      }
#line 479
      return ((zip_int64_t )-1);
    }
#line 482
    if (zde->uncomp_size == 4294967295UL) {
      {
#line 483
      zde->uncomp_size = _zip_buffer_get_64(ef_buffer);
      }
    } else
#line 484
    if (local) {
      {
#line 487
      _zip_buffer_skip(ef_buffer, (zip_uint64_t )8);
      }
    }
#line 489
    if (zde->comp_size == 4294967295UL) {
      {
#line 490
      zde->comp_size = _zip_buffer_get_64(ef_buffer);
      }
    }
#line 491
    if (! local) {
#line 492
      if (zde->offset == 4294967295UL) {
        {
#line 493
        zde->offset = _zip_buffer_get_64(ef_buffer);
        }
      }
#line 494
      if (zde->disk_number == 65535U) {
        {
#line 495
        zde->disk_number = _zip_buffer_get_32(buffer);
        }
      }
    }
    {
#line 498
    __cil_tmp62 = _zip_buffer_eof(ef_buffer);
    }
#line 498
    if (! __cil_tmp62) {
      {
#line 499
      zip_error_set(error, 21, 0);
#line 500
      _zip_buffer_free(ef_buffer);
      }
#line 501
      if (! from_buffer) {
        {
#line 502
        _zip_buffer_free(buffer);
        }
      }
#line 504
      return ((zip_int64_t )-1);
    }
    {
#line 506
    _zip_buffer_free(ef_buffer);
    }
  } else
#line 462
  if (zde->comp_size == 4294967295UL) {
#line 462
    goto _L;
  } else
#line 462
  if (zde->offset == 4294967295UL) {
#line 462
    goto _L;
  }
  {
#line 509
  __cil_tmp63 = _zip_buffer_ok(buffer);
  }
#line 509
  if (! __cil_tmp63) {
    {
#line 510
    zip_error_set(error, 20, 0);
    }
#line 511
    if (! from_buffer) {
      {
#line 512
      _zip_buffer_free(buffer);
      }
    }
#line 514
    return ((zip_int64_t )-1);
  }
#line 516
  if (! from_buffer) {
    {
#line 517
    _zip_buffer_free(buffer);
    }
  }
#line 521
  if (zde->offset > 0xffffffffffffffffUL) {
    {
#line 522
    zip_error_set(error, 4, 27);
    }
#line 523
    return ((zip_int64_t )-1);
  }
  {
#line 526
  zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);
  }
#line 528
  return ((zip_int64_t )(size + variable_size));
}
}
#line 533 "/root/libzip/lib/zip_dirent.c"
static zip_string_t *_zip_dirent_process_ef_utf_8(zip_dirent_t *de , zip_uint16_t id ,
                                                  zip_string_t *str ) 
{ 
  zip_uint16_t ef_len ;
  zip_uint32_t ef_crc ;
  zip_buffer_t *buffer ;
  zip_uint8_t *ef ;
  zip_uint8_t *__cil_tmp8 ;
  zip_uint32_t __cil_tmp11 ;
  zip_uint16_t len ;
  zip_uint64_t __cil_tmp13 ;
  zip_string_t *ef_str ;
  zip_uint8_t *__cil_tmp15 ;
  zip_string_t *__cil_tmp16 ;

  {
  {
#line 539
  __cil_tmp8 = _zip_ef_get_by_id(de->extra_fields, & ef_len, id, (zip_uint16_t )0,
                                 768U, (zip_error_t *)((void *)0));
#line 539
  ef = __cil_tmp8;
  }
#line 541
  if ((unsigned long )ef == (unsigned long )((void *)0)) {
#line 542
    return (str);
  } else
#line 541
  if ((int )ef_len < 5) {
#line 542
    return (str);
  } else
#line 541
  if ((int )*(ef + 0) != 1) {
#line 542
    return (str);
  }
  {
#line 545
  buffer = _zip_buffer_new(ef, (zip_uint64_t )ef_len);
  }
#line 545
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 546
    return (str);
  }
  {
#line 549
  _zip_buffer_get_8(buffer);
#line 550
  ef_crc = _zip_buffer_get_32(buffer);
#line 552
  __cil_tmp11 = _zip_string_crc32(str);
  }
#line 552
  if (__cil_tmp11 == ef_crc) {
    {
#line 553
    __cil_tmp13 = _zip_buffer_left(buffer);
#line 553
    len = (zip_uint16_t )__cil_tmp13;
#line 554
    __cil_tmp15 = _zip_buffer_get(buffer, (zip_uint64_t )len);
#line 554
    __cil_tmp16 = _zip_string_new(__cil_tmp15, len, 2048U, (zip_error_t *)((void *)0));
#line 554
    ef_str = __cil_tmp16;
    }
#line 556
    if ((unsigned long )ef_str != (unsigned long )((void *)0)) {
      {
#line 557
      _zip_string_free(str);
#line 558
      str = ef_str;
      }
    }
  }
  {
#line 562
  _zip_buffer_free(buffer);
  }
#line 564
  return (str);
}
}
#line 569 "/root/libzip/lib/zip_dirent.c"
zip_int32_t _zip_dirent_size(zip_source_t *src , zip_uint16_t flags , zip_error_t *error ) 
{ 
  zip_int32_t size ;
  int local ;
  int i ;
  zip_uint8_t b[6] ;
  zip_buffer_t *buffer ;
  unsigned int tmp ;
  int tmp___0 ;
  int __cil_tmp11 ;
  int tmp___1 ;
  zip_buffer_t *__cil_tmp13 ;
  int tmp___2 ;
  zip_uint16_t __cil_tmp15 ;
  int __cil_tmp17 ;

  {
#line 572
  local = ((unsigned int )flags & 256U) != 0U;
#line 577
  if (local) {
#line 577
    tmp = 30U;
  } else {
#line 577
    tmp = 46U;
  }
#line 577
  size = (zip_int32_t )tmp;
#line 579
  if (local) {
#line 579
    tmp___0 = 26;
  } else {
#line 579
    tmp___0 = 28;
  }
  {
#line 579
  __cil_tmp11 = zip_source_seek(src, (zip_int64_t )tmp___0, 1);
  }
#line 579
  if (__cil_tmp11 < 0) {
    {
#line 580
    _zip_error_set_from_source(error, src);
    }
#line 581
    return (-1);
  }
#line 584
  if (local) {
#line 584
    tmp___1 = 4;
  } else {
#line 584
    tmp___1 = 6;
  }
  {
#line 584
  __cil_tmp13 = _zip_buffer_new_from_source(src, (zip_uint64_t )tmp___1, b, error);
#line 584
  buffer = __cil_tmp13;
  }
#line 584
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 585
    return (-1);
  }
#line 588
  i = 0;
  {
#line 588
  while (1) {
    while_continue: /* CIL Label */ ;

#line 588
    if (! (i < tmp___2)) {
#line 588
      goto while_break;
    }
    {
#line 589
    __cil_tmp15 = _zip_buffer_get_16(buffer);
#line 589
    size += (int )__cil_tmp15;
#line 588
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 592
  __cil_tmp17 = _zip_buffer_eof(buffer);
  }
#line 592
  if (! __cil_tmp17) {
    {
#line 593
    zip_error_set(error, 20, 0);
#line 594
    _zip_buffer_free(buffer);
    }
#line 595
    return (-1);
  }
  {
#line 598
  _zip_buffer_free(buffer);
  }
#line 599
  return (size);
}
}
#line 614 "/root/libzip/lib/zip_dirent.c"
int _zip_dirent_write(zip_t *za___0 , zip_dirent_t *de , zip_flags_t flags ) 
{ 
  zip_uint16_t dostime ;
  zip_uint16_t dosdate ;
  zip_encoding_type_t com_enc ;
  zip_encoding_type_t name_enc ;
  zip_extra_field_t *ef ;
  zip_extra_field_t *ef64 ;
  zip_uint32_t ef_total_size ;
  int is_zip64 ;
  int is_really_zip64 ;
  zip_uint8_t buf[46] ;
  zip_buffer_t *buffer ;
  zip_extra_field_t *ef2 ;
  zip_extra_field_t *__cil_tmp19 ;
  zip_uint8_t ef_zip64[28] ;
  zip_buffer_t *ef_buffer ;
  zip_buffer_t *__cil_tmp23 ;
  int __cil_tmp24 ;
  zip_uint64_t __cil_tmp25 ;
  zip_extra_field_t *__cil_tmp26 ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  zip_uint16_t __cil_tmp31 ;
  zip_uint16_t __cil_tmp32 ;
  zip_uint16_t __cil_tmp33 ;
  zip_uint16_t __cil_tmp34 ;
  int __cil_tmp35 ;
  zip_uint64_t __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int tmp___2 ;

  {
  {
#line 626
  ef = (zip_extra_field_t *)((void *)0);
#line 628
  name_enc = _zip_guess_encoding(de->filename, (enum zip_encoding_type )0);
#line 629
  com_enc = _zip_guess_encoding(de->comment, (enum zip_encoding_type )0);
  }
#line 631
  if ((unsigned int )name_enc == 2U) {
#line 631
    if ((unsigned int )com_enc == 1U) {
#line 634
      de->bitflags = (zip_uint16_t )((int )de->bitflags | 2048);
    } else {
#line 631
      goto _L___14;
    }
  } else
  _L___14: 
#line 631
  if ((unsigned int )name_enc == 1U) {
#line 631
    if ((unsigned int )com_enc == 2U) {
#line 634
      de->bitflags = (zip_uint16_t )((int )de->bitflags | 2048);
    } else {
#line 631
      goto _L___13;
    }
  } else
  _L___13: 
#line 631
  if ((unsigned int )name_enc == 2U) {
#line 631
    if ((unsigned int )com_enc == 2U) {
#line 634
      de->bitflags = (zip_uint16_t )((int )de->bitflags | 2048);
    } else {
#line 631
      goto _L;
    }
  } else {
    _L: 
#line 636
    de->bitflags = (zip_uint16_t )((int )de->bitflags & 63487);
#line 637
    if ((unsigned int )name_enc == 2U) {
      {
#line 638
      ef = _zip_ef_utf8((zip_uint16_t )28789, de->filename, & za___0->error);
      }
#line 639
      if ((unsigned long )ef == (unsigned long )((void *)0)) {
#line 640
        return (-1);
      }
    }
#line 642
    if ((flags & 256U) == 0U) {
#line 642
      if ((unsigned int )com_enc == 2U) {
        {
#line 643
        __cil_tmp19 = _zip_ef_utf8((zip_uint16_t )25461, de->comment, & za___0->error);
#line 643
        ef2 = __cil_tmp19;
        }
#line 644
        if ((unsigned long )ef2 == (unsigned long )((void *)0)) {
          {
#line 645
          _zip_ef_free(ef);
          }
#line 646
          return (-1);
        }
#line 648
        ef2->next = ef;
#line 649
        ef = ef2;
      }
    }
  }
  {
#line 653
  is_really_zip64 = _zip_dirent_needs_zip64(de, flags);
  }
#line 654
  if ((flags & 1280U) == 1280U) {
#line 654
    tmp___2 = 1;
  } else
#line 654
  if (is_really_zip64) {
#line 654
    tmp___2 = 1;
  } else {
#line 654
    tmp___2 = 0;
  }
#line 654
  is_zip64 = tmp___2;
#line 656
  if (is_zip64) {
    {
#line 658
    __cil_tmp23 = _zip_buffer_new(ef_zip64, sizeof(ef_zip64));
#line 658
    ef_buffer = __cil_tmp23;
    }
#line 659
    if ((unsigned long )ef_buffer == (unsigned long )((void *)0)) {
      {
#line 660
      zip_error_set(& za___0->error, 14, 0);
#line 661
      _zip_ef_free(ef);
      }
#line 662
      return (-1);
    }
#line 665
    if (flags & 256U) {
#line 666
      if (flags & 1024U) {
        {
#line 667
        _zip_buffer_put_64(ef_buffer, de->uncomp_size);
#line 668
        _zip_buffer_put_64(ef_buffer, de->comp_size);
        }
      } else
#line 666
      if (de->comp_size > 4294967295UL) {
        {
#line 667
        _zip_buffer_put_64(ef_buffer, de->uncomp_size);
#line 668
        _zip_buffer_put_64(ef_buffer, de->comp_size);
        }
      } else
#line 666
      if (de->uncomp_size > 4294967295UL) {
        {
#line 667
        _zip_buffer_put_64(ef_buffer, de->uncomp_size);
#line 668
        _zip_buffer_put_64(ef_buffer, de->comp_size);
        }
      }
    } else
#line 672
    if (flags & 1024U) {
      _L___15: 
#line 673
      if (de->uncomp_size >= 4294967295UL) {
        {
#line 674
        _zip_buffer_put_64(ef_buffer, de->uncomp_size);
        }
      }
#line 676
      if (de->comp_size >= 4294967295UL) {
        {
#line 677
        _zip_buffer_put_64(ef_buffer, de->comp_size);
        }
      }
#line 679
      if (de->offset >= 4294967295UL) {
        {
#line 680
        _zip_buffer_put_64(ef_buffer, de->offset);
        }
      }
    } else
#line 672
    if (de->comp_size > 4294967295UL) {
#line 672
      goto _L___15;
    } else
#line 672
    if (de->uncomp_size > 4294967295UL) {
#line 672
      goto _L___15;
    } else
#line 672
    if (de->offset > 4294967295UL) {
#line 672
      goto _L___15;
    }
    {
#line 685
    __cil_tmp24 = _zip_buffer_ok(ef_buffer);
    }
#line 685
    if (! __cil_tmp24) {
      {
#line 686
      zip_error_set(& za___0->error, 20, 0);
#line 687
      _zip_buffer_free(ef_buffer);
#line 688
      _zip_ef_free(ef);
      }
#line 689
      return (-1);
    }
    {
#line 692
    __cil_tmp25 = _zip_buffer_offset(ef_buffer);
#line 692
    __cil_tmp26 = _zip_ef_new((zip_uint16_t )1, (zip_uint16_t )__cil_tmp25, ef_zip64,
                              768U);
#line 692
    ef64 = __cil_tmp26;
#line 693
    _zip_buffer_free(ef_buffer);
#line 694
    ef64->next = ef;
#line 695
    ef = ef64;
    }
  }
  {
#line 698
  buffer = _zip_buffer_new(buf, sizeof(buf));
  }
#line 698
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 699
    zip_error_set(& za___0->error, 14, 0);
#line 700
    _zip_ef_free(ef);
    }
#line 701
    return (-1);
  }
#line 704
  if (flags & 256U) {
#line 704
    tmp = "PK\003\004";
  } else {
#line 704
    tmp = "PK\001\0028V";
  }
  {
#line 704
  _zip_buffer_put(buffer, (void const   *)tmp, (size_t )4);
  }
#line 706
  if ((flags & 256U) == 0U) {
#line 707
    if (is_really_zip64) {
#line 707
      tmp___0 = 45;
    } else {
#line 707
      tmp___0 = (int )de->version_madeby;
    }
    {
#line 707
    _zip_buffer_put_16(buffer, (zip_uint16_t )tmp___0);
    }
  }
#line 709
  if (is_really_zip64) {
#line 709
    tmp___1 = 45;
  } else {
#line 709
    tmp___1 = (int )de->version_needed;
  }
  {
#line 709
  _zip_buffer_put_16(buffer, (zip_uint16_t )tmp___1);
#line 710
  _zip_buffer_put_16(buffer, (zip_uint16_t )((int )de->bitflags & 65529));
#line 711
  _zip_buffer_put_16(buffer, (zip_uint16_t )de->comp_method);
#line 713
  _zip_u2d_time(de->last_mod, & dostime, & dosdate);
#line 714
  _zip_buffer_put_16(buffer, dostime);
#line 715
  _zip_buffer_put_16(buffer, dosdate);
#line 717
  _zip_buffer_put_32(buffer, de->crc);
  }
#line 719
  if ((flags & 256U) == 256U) {
#line 719
    if (de->comp_size >= 4294967295UL) {
      {
#line 725
      _zip_buffer_put_32(buffer, 4294967295U);
#line 726
      _zip_buffer_put_32(buffer, 4294967295U);
      }
    } else
#line 719
    if (de->uncomp_size >= 4294967295UL) {
      {
#line 725
      _zip_buffer_put_32(buffer, 4294967295U);
#line 726
      _zip_buffer_put_32(buffer, 4294967295U);
      }
    } else {
#line 719
      goto _L___18;
    }
  } else {
    _L___18: 
#line 729
    if (de->comp_size < 4294967295UL) {
      {
#line 730
      _zip_buffer_put_32(buffer, (zip_uint32_t )de->comp_size);
      }
    } else {
      {
#line 733
      _zip_buffer_put_32(buffer, 4294967295U);
      }
    }
#line 735
    if (de->uncomp_size < 4294967295UL) {
      {
#line 736
      _zip_buffer_put_32(buffer, (zip_uint32_t )de->uncomp_size);
      }
    } else {
      {
#line 739
      _zip_buffer_put_32(buffer, 4294967295U);
      }
    }
  }
  {
#line 743
  __cil_tmp31 = _zip_string_length(de->filename);
#line 743
  _zip_buffer_put_16(buffer, __cil_tmp31);
#line 745
  __cil_tmp33 = _zip_ef_size(ef, 768U);
#line 745
  __cil_tmp32 = _zip_ef_size(de->extra_fields, flags);
#line 745
  ef_total_size = (zip_uint32_t )__cil_tmp32 + (zip_uint32_t )__cil_tmp33;
#line 746
  _zip_buffer_put_16(buffer, (zip_uint16_t )ef_total_size);
  }
#line 748
  if ((flags & 256U) == 0U) {
    {
#line 749
    __cil_tmp34 = _zip_string_length(de->comment);
#line 749
    _zip_buffer_put_16(buffer, __cil_tmp34);
#line 750
    _zip_buffer_put_16(buffer, (zip_uint16_t )de->disk_number);
#line 751
    _zip_buffer_put_16(buffer, de->int_attrib);
#line 752
    _zip_buffer_put_32(buffer, de->ext_attrib);
    }
#line 753
    if (de->offset < 4294967295UL) {
      {
#line 754
      _zip_buffer_put_32(buffer, (zip_uint32_t )de->offset);
      }
    } else {
      {
#line 756
      _zip_buffer_put_32(buffer, 4294967295U);
      }
    }
  }
  {
#line 759
  __cil_tmp35 = _zip_buffer_ok(buffer);
  }
#line 759
  if (! __cil_tmp35) {
    {
#line 760
    zip_error_set(& za___0->error, 20, 0);
#line 761
    _zip_buffer_free(buffer);
#line 762
    _zip_ef_free(ef);
    }
#line 763
    return (-1);
  }
  {
#line 766
  __cil_tmp36 = _zip_buffer_offset(buffer);
#line 766
  __cil_tmp37 = _zip_write(za___0, (void const   *)(buf), __cil_tmp36);
  }
#line 766
  if (__cil_tmp37 < 0) {
    {
#line 767
    _zip_buffer_free(buffer);
#line 768
    _zip_ef_free(ef);
    }
#line 769
    return (-1);
  }
  {
#line 772
  _zip_buffer_free(buffer);
  }
#line 774
  if (de->filename) {
    {
#line 775
    __cil_tmp38 = _zip_string_write(za___0, de->filename);
    }
#line 775
    if (__cil_tmp38 < 0) {
      {
#line 776
      _zip_ef_free(ef);
      }
#line 777
      return (-1);
    }
  }
#line 781
  if (ef) {
    {
#line 782
    __cil_tmp39 = _zip_ef_write(za___0, ef, 768U);
    }
#line 782
    if (__cil_tmp39 < 0) {
      {
#line 783
      _zip_ef_free(ef);
      }
#line 784
      return (-1);
    }
  }
  {
#line 787
  _zip_ef_free(ef);
  }
#line 788
  if (de->extra_fields) {
    {
#line 789
    __cil_tmp40 = _zip_ef_write(za___0, de->extra_fields, flags);
    }
#line 789
    if (__cil_tmp40 < 0) {
#line 790
      return (-1);
    }
  }
#line 794
  if ((flags & 256U) == 0U) {
#line 795
    if (de->comment) {
      {
#line 796
      __cil_tmp41 = _zip_string_write(za___0, de->comment);
      }
#line 796
      if (__cil_tmp41 < 0) {
#line 797
        return (-1);
      }
    }
  }
#line 803
  return (is_zip64);
}
}
#line 808 "/root/libzip/lib/zip_dirent.c"
static time_t _zip_d2u_time(zip_uint16_t dtime , zip_uint16_t ddate ) 
{ 
  struct tm tm ;
  time_t __cil_tmp4 ;

  {
  {
#line 812
  memset((void *)(& tm), 0, sizeof(tm));
#line 815
  tm.tm_isdst = -1;
#line 817
  tm.tm_year = ((((int )ddate >> 9) & 127) + 1980) - 1900;
#line 818
  tm.tm_mon = (((int )ddate >> 5) & 15) - 1;
#line 819
  tm.tm_mday = (int )ddate & 31;
#line 821
  tm.tm_hour = ((int )dtime >> 11) & 31;
#line 822
  tm.tm_min = ((int )dtime >> 5) & 63;
#line 823
  tm.tm_sec = ((int )dtime << 1) & 62;
#line 825
  __cil_tmp4 = mktime(& tm);
  }
#line 825
  return (__cil_tmp4);
}
}
#line 830 "/root/libzip/lib/zip_dirent.c"
static zip_extra_field_t *_zip_ef_utf8(zip_uint16_t id , zip_string_t *str , zip_error_t *error ) 
{ 
  zip_uint8_t *raw ;
  zip_uint32_t len ;
  zip_buffer_t *buffer ;
  zip_extra_field_t *ef ;
  zip_uint32_t __cil_tmp10 ;
  int __cil_tmp11 ;
  zip_uint64_t __cil_tmp12 ;
  zip_uint8_t *__cil_tmp13 ;
  zip_extra_field_t *__cil_tmp14 ;

  {
  {
#line 837
  raw = _zip_string_get(str, & len, 64U, (zip_error_t *)((void *)0));
  }
#line 837
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
#line 839
    return ((zip_extra_field_t *)((void *)0));
  }
#line 842
  if (len + 5U > 65535U) {
    {
#line 843
    zip_error_set(error, 18, 0);
    }
#line 844
    return ((zip_extra_field_t *)((void *)0));
  }
  {
#line 847
  buffer = _zip_buffer_new((zip_uint8_t *)((void *)0), (zip_uint64_t )(len + 5U));
  }
#line 847
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 848
    zip_error_set(error, 14, 0);
    }
#line 849
    return ((zip_extra_field_t *)((void *)0));
  }
  {
#line 852
  _zip_buffer_put_8(buffer, (zip_uint8_t )1);
#line 853
  __cil_tmp10 = _zip_string_crc32(str);
#line 853
  _zip_buffer_put_32(buffer, __cil_tmp10);
#line 854
  _zip_buffer_put(buffer, (void const   *)raw, (size_t )len);
#line 856
  __cil_tmp11 = _zip_buffer_ok(buffer);
  }
#line 856
  if (! __cil_tmp11) {
    {
#line 857
    zip_error_set(error, 20, 0);
#line 858
    _zip_buffer_free(buffer);
    }
#line 859
    return ((zip_extra_field_t *)((void *)0));
  }
  {
#line 862
  __cil_tmp12 = _zip_buffer_offset(buffer);
#line 862
  __cil_tmp13 = _zip_buffer_data(buffer);
#line 862
  __cil_tmp14 = _zip_ef_new(id, (zip_uint16_t )__cil_tmp12, __cil_tmp13, 768U);
#line 862
  ef = __cil_tmp14;
#line 863
  _zip_buffer_free(buffer);
  }
#line 865
  return (ef);
}
}
#line 870 "/root/libzip/lib/zip_dirent.c"
zip_dirent_t *_zip_get_dirent(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                              zip_error_t *error ) 
{ 


  {
#line 872
  if ((unsigned long )error == (unsigned long )((void *)0)) {
#line 873
    error = & za___0->error;
  }
#line 875
  if (idx >= za___0->nentry) {
    {
#line 876
    zip_error_set(error, 18, 0);
    }
#line 877
    return ((zip_dirent_t *)((void *)0));
  }
#line 880
  if ((unsigned long )(za___0->entry + idx)->changes == (unsigned long )((void *)0)) {
    _L: 
#line 881
    if ((unsigned long )(za___0->entry + idx)->orig == (unsigned long )((void *)0)) {
      {
#line 882
      zip_error_set(error, 18, 0);
      }
#line 883
      return ((zip_dirent_t *)((void *)0));
    }
#line 885
    if ((za___0->entry + idx)->deleted) {
#line 885
      if ((flags & 8U) == 0U) {
        {
#line 886
        zip_error_set(error, 23, 0);
        }
#line 887
        return ((zip_dirent_t *)((void *)0));
      }
    }
#line 889
    return ((za___0->entry + idx)->orig);
  } else
#line 880
  if (flags & 8U) {
#line 880
    goto _L;
  } else {
#line 892
    return ((za___0->entry + idx)->changes);
  }
}
}
#line 899 "/root/libzip/lib/zip_dirent.c"
void _zip_u2d_time(time_t intime , zip_uint16_t *dtime , zip_uint16_t *ddate ) 
{ 
  struct tm *tm ;

  {
  {
#line 903
  tm = localtime(& intime);
  }
#line 904
  if (tm->tm_year < 80) {
#line 905
    tm->tm_year = 80;
  }
#line 908
  *ddate = (zip_uint16_t )(((((tm->tm_year + 1900) - 1980) << 9) + ((tm->tm_mon + 1) << 5)) + tm->tm_mday);
#line 909
  *dtime = (zip_uint16_t )(((tm->tm_hour << 11) + (tm->tm_min << 5)) + (tm->tm_sec >> 1));
#line 911
  return;
}
}
#line 44 "/root/libzip/lib/zip_dir_add.c"
zip_int64_t zip_dir_add(zip_t *za___0 , char const   *name , zip_flags_t flags ) 
{ 
  size_t len ;
  zip_int64_t idx ;
  char *s ;
  zip_source_t *source ;
  void *__cil_tmp9 ;
  char *tmp ;
  zip_int64_t __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 51
  if (za___0->ch_flags & 2U) {
    {
#line 52
    zip_error_set(& za___0->error, 25, 0);
    }
#line 53
    return ((zip_int64_t )-1);
  }
#line 56
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 57
    zip_error_set(& za___0->error, 18, 0);
    }
#line 58
    return ((zip_int64_t )-1);
  }
  {
#line 61
  s = (char *)((void *)0);
#line 62
  len = strlen(name);
  }
#line 64
  if ((int )*(name + (len - 1UL)) != 47) {
    {
#line 65
    __cil_tmp9 = malloc(len + 2UL);
#line 65
    s = (char *)__cil_tmp9;
    }
#line 65
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      {
#line 66
      zip_error_set(& za___0->error, 14, 0);
      }
#line 67
      return ((zip_int64_t )-1);
    }
    {
#line 69
    strcpy(s, name);
#line 70
    *(s + len) = (char )'/';
#line 71
    *(s + (len + 1UL)) = (char )'\000';
    }
  }
  {
#line 74
  source = zip_source_buffer(za___0, (void const   *)((void *)0), (zip_uint64_t )0,
                             0);
  }
#line 74
  if ((unsigned long )source == (unsigned long )((void *)0)) {
    {
#line 75
    free((void *)s);
    }
#line 76
    return ((zip_int64_t )-1);
  }
#line 79
  if (s) {
#line 79
    tmp = s;
  } else {
#line 79
    tmp = (char *)name;
  }
  {
#line 79
  __cil_tmp12 = _zip_file_replace(za___0, 0xffffffffffffffffUL, (char const   *)((int )tmp),
                                  source, flags);
#line 79
  idx = __cil_tmp12;
#line 81
  free((void *)s);
  }
#line 83
  if (idx < 0L) {
    {
#line 84
    zip_source_free(source);
    }
  } else {
    {
#line 86
    __cil_tmp13 = zip_file_set_external_attributes(za___0, (zip_uint64_t )idx, (zip_flags_t )0,
                                                   (zip_uint8_t )3U, 16895U << 16);
    }
#line 86
    if (__cil_tmp13 < 0) {
      {
#line 87
      zip_delete(za___0, (zip_uint64_t )idx);
      }
#line 88
      return ((zip_int64_t )-1);
    }
  }
#line 92
  return (idx);
}
}
#line 39 "/root/libzip/lib/zip_delete.c"
int zip_delete(zip_t *za___0 , zip_uint64_t idx ) 
{ 
  char const   *name ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 43
  if (idx >= za___0->nentry) {
    {
#line 44
    zip_error_set(& za___0->error, 18, 0);
    }
#line 45
    return (-1);
  }
#line 48
  if (za___0->ch_flags & 2U) {
    {
#line 49
    zip_error_set(& za___0->error, 25, 0);
    }
#line 50
    return (-1);
  }
  {
#line 53
  name = _zip_get_name(za___0, idx, (zip_flags_t )0, & za___0->error);
  }
#line 53
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 54
    return (-1);
  }
  {
#line 57
  __cil_tmp5 = _zip_hash_delete(za___0->names, (zip_uint8_t *)name, & za___0->error);
  }
#line 57
  if (! __cil_tmp5) {
#line 58
    return (-1);
  }
  {
#line 63
  __cil_tmp6 = _zip_unchange(za___0, idx, 1);
  }
#line 63
  if (__cil_tmp6 != 0) {
#line 64
    return (-1);
  }
#line 66
  (za___0->entry + idx)->deleted = 1;
#line 68
  return (0);
}
}
#line 57 "/root/libzip/lib/zip_close.c"
static int add_data(zip_t *za___0 , zip_source_t *src , zip_dirent_t *de ) ;
#line 58
static int copy_data(zip_t *za___0 , zip_uint64_t len ) ;
#line 59
static int copy_source(zip_t *za___0 , zip_source_t *src ) ;
#line 60
static int write_cdir(zip_t *za___0 , zip_filelist_t *filelist , zip_uint64_t survivors ) ;
#line 64 "/root/libzip/lib/zip_close.c"
int zip_close(zip_t *za___0 ) 
{ 
  zip_uint64_t i ;
  zip_uint64_t j ;
  zip_uint64_t survivors ;
  zip_int64_t off ;
  int error ;
  zip_filelist_t *filelist ;
  int changed ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;
  int __cil_tmp14 ;
  int new_data ;
  zip_entry_t *entry ;
  zip_dirent_t *de ;
  int __cil_tmp19 ;
  zip_source_t *zs ;
  zip_source_t *tmp ;
  int __cil_tmp24 ;
  zip_uint64_t offset ;
  int __cil_tmp26 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int tmp___0 ;

  {
#line 72
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 73
    return (-1);
  }
  {
#line 75
  changed = _zip_changed(za___0, & survivors);
  }
#line 78
  if (survivors == 0UL) {
#line 79
    if (za___0->open_flags & 8U) {
      _L: 
      {
#line 80
      __cil_tmp10 = zip_source_remove(za___0->src);
      }
#line 80
      if (__cil_tmp10 < 0) {
        {
#line 81
        _zip_error_set_from_source(& za___0->error, za___0->src);
        }
#line 82
        return (-1);
      }
    } else
#line 79
    if (changed) {
#line 79
      goto _L;
    }
    {
#line 85
    zip_discard(za___0);
    }
#line 86
    return (0);
  }
#line 89
  if (! changed) {
    {
#line 90
    zip_discard(za___0);
    }
#line 91
    return (0);
  }
#line 94
  if (survivors > za___0->nentry) {
    {
#line 95
    zip_error_set(& za___0->error, 20, 0);
    }
#line 96
    return (-1);
  }
  {
#line 99
  __cil_tmp11 = malloc(sizeof(*(filelist + 0)) * survivors);
#line 99
  filelist = (zip_filelist_t *)__cil_tmp11;
  }
#line 99
  if ((unsigned long )filelist == (unsigned long )((void *)0)) {
#line 100
    return (-1);
  }
#line 103
  j = (zip_uint64_t )0;
#line 103
  i = j;
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 103
    if (! (i < za___0->nentry)) {
#line 103
      goto while_break;
    }
#line 104
    if ((za___0->entry + i)->deleted) {
#line 105
      goto while_continue;
    }
#line 107
    if (j >= survivors) {
      {
#line 108
      free((void *)filelist);
#line 109
      zip_error_set(& za___0->error, 20, 0);
      }
#line 110
      return (-1);
    }
#line 113
    (filelist + j)->idx = i;
#line 114
    j ++;
#line 103
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 116
  if (j < survivors) {
    {
#line 117
    free((void *)filelist);
#line 118
    zip_error_set(& za___0->error, 20, 0);
    }
#line 119
    return (-1);
  }
  {
#line 122
  __cil_tmp14 = zip_source_begin_write(za___0->src);
  }
#line 122
  if (__cil_tmp14 < 0) {
    {
#line 123
    _zip_error_set_from_source(& za___0->error, za___0->src);
#line 124
    free((void *)filelist);
    }
#line 125
    return (-1);
  }
#line 128
  error = 0;
#line 129
  j = (zip_uint64_t )0;
  {
#line 129
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 129
    if (! (j < survivors)) {
#line 129
      goto while_break___0;
    }
#line 134
    i = (filelist + j)->idx;
#line 135
    entry = za___0->entry + i;
#line 137
    if ((unsigned long )entry->source != (unsigned long )((void *)0)) {
#line 137
      tmp___0 = 1;
    } else
#line 137
    if (entry->changes) {
#line 137
      if ((entry->changes)->changed & 1U) {
#line 137
        tmp___0 = 1;
      } else {
#line 137
        tmp___0 = 0;
      }
    } else {
#line 137
      tmp___0 = 0;
    }
#line 137
    new_data = tmp___0;
#line 140
    if ((unsigned long )entry->changes == (unsigned long )((void *)0)) {
      {
#line 141
      entry->changes = _zip_dirent_clone(entry->orig);
      }
#line 141
      if ((unsigned long )entry->changes == (unsigned long )((void *)0)) {
        {
#line 142
        zip_error_set(& za___0->error, 14, 0);
#line 143
        error = 1;
        }
#line 144
        goto while_break___0;
      }
    }
    {
#line 147
    de = entry->changes;
#line 149
    __cil_tmp19 = _zip_read_local_ef(za___0, i);
    }
#line 149
    if (__cil_tmp19 < 0) {
#line 150
      error = 1;
#line 151
      goto while_break___0;
    }
    {
#line 154
    off = zip_source_tell_write(za___0->src);
    }
#line 154
    if (off < 0L) {
#line 155
      error = 1;
#line 156
      goto while_break___0;
    }
#line 158
    de->offset = (zip_uint64_t )off;
#line 160
    if (new_data) {
#line 163
      zs = (zip_source_t *)((void *)0);
#line 164
      if (! ((unsigned long )entry->source != (unsigned long )((void *)0))) {
        {
#line 165
        zs = _zip_source_zip_new(za___0, za___0, i, 8U, (zip_uint64_t )0, (zip_uint64_t )0,
                                 (char const   *)((void *)0));
        }
#line 165
        if ((unsigned long )zs == (unsigned long )((void *)0)) {
#line 166
          error = 1;
#line 167
          goto while_break___0;
        }
      }
#line 172
      if (zs) {
#line 172
        tmp = zs;
      } else {
#line 172
        tmp = entry->source;
      }
      {
#line 172
      __cil_tmp24 = add_data(za___0, tmp, de);
      }
#line 172
      if (__cil_tmp24 < 0) {
#line 173
        error = 1;
#line 174
        if (zs) {
          {
#line 175
          zip_source_free(zs);
          }
        }
#line 176
        goto while_break___0;
      }
#line 178
      if (zs) {
        {
#line 179
        zip_source_free(zs);
        }
      }
    } else {
      {
#line 185
      de->bitflags = (zip_uint16_t )((int )de->bitflags & 65527);
#line 186
      __cil_tmp26 = _zip_dirent_write(za___0, de, 256U);
      }
#line 186
      if (__cil_tmp26 < 0) {
#line 187
        error = 1;
#line 188
        goto while_break___0;
      }
      {
#line 190
      offset = _zip_file_get_offset(za___0, i, & za___0->error);
      }
#line 190
      if (offset == 0UL) {
#line 191
        error = 1;
#line 192
        goto while_break___0;
      }
      {
#line 194
      __cil_tmp28 = zip_source_seek(za___0->src, (zip_int64_t )offset, 0);
      }
#line 194
      if (__cil_tmp28 < 0) {
        {
#line 195
        _zip_error_set_from_source(& za___0->error, za___0->src);
#line 196
        error = 1;
        }
#line 197
        goto while_break___0;
      }
      {
#line 199
      __cil_tmp29 = copy_data(za___0, de->comp_size);
      }
#line 199
      if (__cil_tmp29 < 0) {
#line 200
        error = 1;
#line 201
        goto while_break___0;
      }
    }
#line 129
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 206
  if (! error) {
    {
#line 207
    __cil_tmp31 = write_cdir(za___0, filelist, survivors);
    }
#line 207
    if (__cil_tmp31 < 0) {
#line 208
      error = 1;
    }
  }
  {
#line 211
  free((void *)filelist);
  }
#line 213
  if (! error) {
    {
#line 214
    __cil_tmp32 = zip_source_commit_write(za___0->src);
    }
#line 214
    if (__cil_tmp32 != 0) {
      {
#line 215
      _zip_error_set_from_source(& za___0->error, za___0->src);
#line 216
      error = 1;
      }
    }
  }
#line 220
  if (error) {
    {
#line 221
    zip_source_rollback_write(za___0->src);
    }
#line 222
    return (-1);
  }
  {
#line 225
  zip_discard(za___0);
  }
#line 227
  return (0);
}
}
#line 232 "/root/libzip/lib/zip_close.c"
static int add_data(zip_t *za___0 , zip_source_t *src , zip_dirent_t *de ) 
{ 
  zip_int64_t offstart ;
  zip_int64_t offdata ;
  zip_int64_t offend ;
  struct zip_stat st ;
  zip_source_t *s2 ;
  int ret ;
  int is_zip64 ;
  zip_flags_t flags ;
  int __cil_tmp12 ;
  zip_source_t *s_store ;
  zip_source_t *s_crc ;
  zip_source_t *(*comp_impl)(zip_t * , zip_source_t * , zip_int32_t  , int  ) ;
  int __cil_tmp25 ;
  int __cil_tmp27 ;
  int __cil_tmp29 ;

  {
  {
#line 241
  __cil_tmp12 = zip_source_stat(src, & st);
  }
#line 241
  if (__cil_tmp12 < 0) {
    {
#line 242
    _zip_error_set_from_source(& za___0->error, src);
    }
#line 243
    return (-1);
  }
#line 246
  if ((st.valid & 64UL) == 0UL) {
#line 247
    st.valid |= 64UL;
#line 248
    st.comp_method = (zip_uint16_t )0;
  }
#line 251
  if (de->comp_method == -1) {
    _L___19: 
#line 251
    if ((int )st.comp_method != 0) {
#line 252
      de->comp_method = (zip_int32_t )st.comp_method;
    } else {
#line 251
      goto _L;
    }
  } else
#line 251
  if (de->comp_method == -2) {
#line 251
    goto _L___19;
  } else
  _L: 
#line 253
  if (de->comp_method == 0) {
#line 253
    if (st.valid & 4UL) {
#line 254
      st.valid |= 8UL;
#line 255
      st.comp_size = st.size;
    } else {
#line 259
      st.valid &= 4294967287UL;
    }
  } else {
#line 259
    st.valid &= 4294967287UL;
  }
#line 263
  flags = 256U;
#line 265
  if ((st.valid & 4UL) == 0UL) {
#line 266
    flags |= 1024U;
  } else {
#line 268
    de->uncomp_size = st.size;
#line 270
    if ((st.valid & 8UL) == 0UL) {
#line 271
      if (de->comp_method == 8) {
        _L___21: 
#line 271
        if (st.size > 4293656963UL) {
#line 273
          flags |= 1024U;
        } else {
#line 271
          goto _L___20;
        }
      } else
#line 271
      if (de->comp_method == -1) {
#line 271
        goto _L___21;
      } else
#line 271
      if (de->comp_method == -2) {
#line 271
        goto _L___21;
      } else
      _L___20: 
#line 271
      if (de->comp_method != 0) {
#line 271
        if (de->comp_method != 8) {
#line 271
          if (! (de->comp_method == -1)) {
#line 271
            if (! (de->comp_method == -2)) {
#line 273
              flags |= 1024U;
            }
          }
        }
      }
    } else {
#line 276
      de->comp_size = st.comp_size;
    }
  }
  {
#line 279
  offstart = zip_source_tell_write(za___0->src);
  }
#line 279
  if (offstart < 0L) {
#line 280
    return (-1);
  }
  {
#line 284
  de->bitflags = (zip_uint16_t )((int )de->bitflags & 65527);
#line 285
  is_zip64 = _zip_dirent_write(za___0, de, flags);
  }
#line 285
  if (is_zip64 < 0) {
#line 286
    return (-1);
  }
#line 289
  if ((int )st.comp_method == 0) {
    _L___23: 
#line 293
    if ((int )st.comp_method != 0) {
      {
#line 294
      comp_impl = _zip_get_compression_implementation((zip_int32_t )st.comp_method);
      }
#line 294
      if ((unsigned long )comp_impl == (unsigned long )((void *)0)) {
        {
#line 295
        zip_error_set(& za___0->error, 16, 0);
        }
#line 296
        return (-1);
      }
      {
#line 298
      s_store = (*comp_impl)(za___0, src, (zip_int32_t )st.comp_method, 0);
      }
#line 298
      if ((unsigned long )s_store == (unsigned long )((void *)0)) {
#line 300
        return (-1);
      }
    } else {
      {
#line 305
      zip_source_keep(src);
#line 306
      s_store = src;
      }
    }
    {
#line 309
    s_crc = zip_source_crc(za___0, s_store, 0);
#line 310
    zip_source_free(s_store);
    }
#line 311
    if ((unsigned long )s_crc == (unsigned long )((void *)0)) {
#line 312
      return (-1);
    }
#line 315
    if (de->comp_method != 0) {
#line 315
      if ((st.valid & 4UL) == 0UL) {
        _L___22: 
        {
#line 316
        comp_impl = _zip_get_compression_implementation(de->comp_method);
        }
#line 316
        if ((unsigned long )comp_impl == (unsigned long )((void *)0)) {
          {
#line 317
          zip_error_set(& za___0->error, 16, 0);
#line 318
          zip_source_free(s_crc);
          }
#line 319
          return (-1);
        }
        {
#line 321
        s2 = (*comp_impl)(za___0, s_crc, de->comp_method, 1);
#line 322
        zip_source_free(s_crc);
        }
#line 323
        if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 324
          return (-1);
        }
      } else
#line 315
      if (st.size != 0UL) {
#line 315
        goto _L___22;
      } else {
#line 328
        s2 = s_crc;
      }
    } else {
#line 328
      s2 = s_crc;
    }
  } else
#line 289
  if (de->comp_method == -1) {
    _L___24: 
#line 289
    if ((int )st.comp_method != de->comp_method) {
#line 289
      goto _L___23;
    } else {
      {
#line 332
      zip_source_keep(src);
#line 333
      s2 = src;
      }
    }
  } else
#line 289
  if (de->comp_method == -2) {
#line 289
    goto _L___24;
  } else {
    {
#line 332
    zip_source_keep(src);
#line 333
    s2 = src;
    }
  }
  {
#line 336
  offdata = zip_source_tell_write(za___0->src);
  }
#line 336
  if (offdata < 0L) {
#line 337
    return (-1);
  }
  {
#line 340
  ret = copy_source(za___0, s2);
#line 342
  __cil_tmp25 = zip_source_stat(s2, & st);
  }
#line 342
  if (__cil_tmp25 < 0) {
#line 343
    ret = -1;
  }
  {
#line 345
  zip_source_free(s2);
  }
#line 347
  if (ret < 0) {
#line 348
    return (-1);
  }
  {
#line 350
  offend = zip_source_tell_write(za___0->src);
  }
#line 350
  if (offend < 0L) {
#line 351
    return (-1);
  }
  {
#line 354
  __cil_tmp27 = zip_source_seek_write(za___0->src, offstart, 0);
  }
#line 354
  if (__cil_tmp27 < 0) {
    {
#line 355
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 356
    return (-1);
  }
#line 359
  if ((st.valid & 100UL) != 100UL) {
    {
#line 360
    zip_error_set(& za___0->error, 20, 0);
    }
#line 361
    return (-1);
  }
#line 364
  if ((de->changed & 32U) == 0U) {
#line 365
    if (st.valid & 16UL) {
#line 366
      de->last_mod = st.mtime;
    } else {
      {
#line 368
      time(& de->last_mod);
      }
    }
  }
  {
#line 370
  de->comp_method = (zip_int32_t )st.comp_method;
#line 371
  de->crc = st.crc;
#line 372
  de->uncomp_size = st.size;
#line 373
  de->comp_size = (zip_uint64_t )(offend - offdata);
#line 375
  ret = _zip_dirent_write(za___0, de, flags);
  }
#line 375
  if (ret < 0) {
#line 376
    return (-1);
  }
#line 378
  if (is_zip64 != ret) {
    {
#line 380
    zip_error_set(& za___0->error, 20, 0);
    }
#line 381
    return (-1);
  }
  {
#line 385
  __cil_tmp29 = zip_source_seek_write(za___0->src, offend, 0);
  }
#line 385
  if (__cil_tmp29 < 0) {
    {
#line 386
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 387
    return (-1);
  }
#line 390
  return (0);
}
}
#line 395 "/root/libzip/lib/zip_close.c"
static int copy_data(zip_t *za___0 , zip_uint64_t len ) 
{ 
  zip_uint8_t buf[8192] ;
  size_t n ;
  unsigned long tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;

#line 400
    if (! (len > 0UL)) {
#line 400
      goto while_break;
    }
#line 401
    if (len > sizeof(buf)) {
#line 401
      tmp = sizeof(buf);
    } else {
#line 401
      tmp = len;
    }
    {
#line 401
    n = tmp;
#line 402
    __cil_tmp6 = _zip_read(za___0->src, buf, n, & za___0->error);
    }
#line 402
    if (__cil_tmp6 < 0) {
#line 403
      return (-1);
    }
    {
#line 406
    __cil_tmp7 = _zip_write(za___0, (void const   *)(buf), n);
    }
#line 406
    if (__cil_tmp7 < 0) {
#line 407
      return (-1);
    }
#line 410
    len -= n;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 413
  return (0);
}
}
#line 418 "/root/libzip/lib/zip_close.c"
static int copy_source(zip_t *za___0 , zip_source_t *src ) 
{ 
  zip_uint8_t buf[8192] ;
  zip_int64_t n ;
  int ret ;
  int __cil_tmp6 ;
  int __cil_tmp8 ;

  {
  {
#line 424
  __cil_tmp6 = zip_source_open(src);
  }
#line 424
  if (__cil_tmp6 < 0) {
    {
#line 425
    _zip_error_set_from_source(& za___0->error, src);
    }
#line 426
    return (-1);
  }
#line 429
  ret = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 430
    n = zip_source_read(src, (void *)(buf), sizeof(buf));
    }
#line 430
    if (! (n > 0L)) {
#line 430
      goto while_break;
    }
    {
#line 431
    __cil_tmp8 = _zip_write(za___0, (void const   *)(buf), (zip_uint64_t )n);
    }
#line 431
    if (__cil_tmp8 < 0) {
#line 432
      ret = -1;
#line 433
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 437
  if (n < 0L) {
    {
#line 438
    _zip_error_set_from_source(& za___0->error, src);
#line 439
    ret = -1;
    }
  }
  {
#line 442
  zip_source_close(src);
  }
#line 444
  return (ret);
}
}
#line 449 "/root/libzip/lib/zip_close.c"
static int write_cdir(zip_t *za___0 , zip_filelist_t *filelist , zip_uint64_t survivors ) 
{ 
  zip_int64_t cd_start ;
  zip_int64_t end ;
  zip_int64_t size ;

  {
  {
#line 453
  cd_start = zip_source_tell_write(za___0->src);
  }
#line 453
  if (cd_start < 0L) {
#line 454
    return (-1);
  }
  {
#line 457
  size = _zip_cdir_write(za___0, filelist, survivors);
  }
#line 457
  if (size < 0L) {
#line 458
    return (-1);
  }
  {
#line 461
  end = zip_source_tell_write(za___0->src);
  }
#line 461
  if (end < 0L) {
#line 462
    return (-1);
  }
#line 465
  return (0);
}
}
#line 470 "/root/libzip/lib/zip_close.c"
int _zip_changed(zip_t *za___0 , zip_uint64_t *survivorsp ) 
{ 
  int changed ;
  zip_uint64_t i ;
  zip_uint64_t survivors ;

  {
#line 475
  changed = 0;
#line 476
  survivors = (zip_uint64_t )0;
#line 478
  if (za___0->comment_changed) {
#line 479
    changed = 1;
  } else
#line 478
  if (za___0->ch_flags != za___0->flags) {
#line 479
    changed = 1;
  }
#line 481
  i = (zip_uint64_t )0;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;

#line 481
    if (! (i < za___0->nentry)) {
#line 481
      goto while_break;
    }
#line 482
    if ((za___0->entry + i)->source) {
#line 483
      changed = 1;
    } else
#line 482
    if ((za___0->entry + i)->deleted) {
#line 483
      changed = 1;
    } else
#line 482
    if ((za___0->entry + i)->changes) {
#line 482
      if (((za___0->entry + i)->changes)->changed != 0U) {
#line 483
        changed = 1;
      }
    }
#line 484
    if (! (za___0->entry + i)->deleted) {
#line 485
      survivors ++;
    }
#line 481
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 488
  if (survivorsp) {
#line 489
    *survivorsp = survivors;
  }
#line 491
  return (changed);
}
}
#line 40 "/root/libzip/lib/zip_buffer.c"
zip_uint8_t *_zip_buffer_data(zip_buffer_t *buffer ) 
{ 


  {
#line 42
  return (buffer->data);
}
}
#line 47 "/root/libzip/lib/zip_buffer.c"
void _zip_buffer_free(zip_buffer_t *buffer ) 
{ 


  {
#line 49
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 50
    return;
  }
#line 53
  if (buffer->free_data) {
    {
#line 54
    free((void *)buffer->data);
    }
  }
  {
#line 57
  free((void *)buffer);
  }
#line 59
  return;
}
}
#line 62 "/root/libzip/lib/zip_buffer.c"
int _zip_buffer_eof(zip_buffer_t *buffer ) 
{ 
  int tmp ;

  {
#line 64
  if (buffer->ok) {
#line 64
    if (buffer->offset == buffer->size) {
#line 64
      tmp = 1;
    } else {
#line 64
      tmp = 0;
    }
  } else {
#line 64
    tmp = 0;
  }
#line 64
  return (tmp);
}
}
#line 69 "/root/libzip/lib/zip_buffer.c"
zip_uint8_t *_zip_buffer_get(zip_buffer_t *buffer , zip_uint64_t length ) 
{ 
  zip_uint8_t *data ;

  {
#line 73
  if (! buffer->ok) {
#line 74
    buffer->ok = 0;
#line 75
    return ((zip_uint8_t *)((void *)0));
  } else
#line 73
  if (buffer->offset + length < length) {
#line 74
    buffer->ok = 0;
#line 75
    return ((zip_uint8_t *)((void *)0));
  } else
#line 73
  if (buffer->offset + length > buffer->size) {
#line 74
    buffer->ok = 0;
#line 75
    return ((zip_uint8_t *)((void *)0));
  }
#line 78
  data = buffer->data + buffer->offset;
#line 79
  buffer->offset += length;
#line 80
  return (data);
}
}
#line 85 "/root/libzip/lib/zip_buffer.c"
zip_uint16_t _zip_buffer_get_16(zip_buffer_t *buffer ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp3 ;

  {
  {
#line 87
  __cil_tmp3 = _zip_buffer_get(buffer, (zip_uint64_t )2);
#line 87
  data = __cil_tmp3;
  }
#line 89
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 90
    return ((zip_uint16_t )0);
  }
#line 93
  return ((zip_uint16_t )((int )*(data + 0) + ((int )*(data + 1) << 8)));
}
}
#line 98 "/root/libzip/lib/zip_buffer.c"
zip_uint32_t _zip_buffer_get_32(zip_buffer_t *buffer ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp3 ;

  {
  {
#line 100
  __cil_tmp3 = _zip_buffer_get(buffer, (zip_uint64_t )4);
#line 100
  data = __cil_tmp3;
  }
#line 102
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 103
    return ((zip_uint32_t )0);
  }
#line 106
  return (((((((zip_uint32_t )*(data + 3) << 8) + (unsigned int )*(data + 2)) << 8) + (unsigned int )*(data + 1)) << 8) + (unsigned int )*(data + 0));
}
}
#line 111 "/root/libzip/lib/zip_buffer.c"
zip_uint64_t _zip_buffer_get_64(zip_buffer_t *buffer ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp3 ;

  {
  {
#line 113
  __cil_tmp3 = _zip_buffer_get(buffer, (zip_uint64_t )8);
#line 113
  data = __cil_tmp3;
  }
#line 115
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 116
    return ((zip_uint64_t )0);
  }
#line 119
  return (((((((((zip_uint64_t )*(data + 7) << 56) + ((zip_uint64_t )*(data + 6) << 48)) + ((zip_uint64_t )*(data + 5) << 40)) + ((zip_uint64_t )*(data + 4) << 32)) + ((zip_uint64_t )*(data + 3) << 24)) + ((zip_uint64_t )*(data + 2) << 16)) + ((zip_uint64_t )*(data + 1) << 8)) + (zip_uint64_t )*(data + 0));
}
}
#line 125 "/root/libzip/lib/zip_buffer.c"
zip_uint8_t _zip_buffer_get_8(zip_buffer_t *buffer ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp3 ;

  {
  {
#line 127
  __cil_tmp3 = _zip_buffer_get(buffer, (zip_uint64_t )1);
#line 127
  data = __cil_tmp3;
  }
#line 129
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 130
    return ((zip_uint8_t )0);
  }
#line 133
  return (*(data + 0));
}
}
#line 138 "/root/libzip/lib/zip_buffer.c"
zip_uint64_t _zip_buffer_left(zip_buffer_t *buffer ) 
{ 
  zip_uint64_t tmp ;

  {
#line 140
  if (buffer->ok) {
#line 140
    tmp = buffer->size - buffer->offset;
  } else {
#line 140
    tmp = 0UL;
  }
#line 140
  return (tmp);
}
}
#line 145 "/root/libzip/lib/zip_buffer.c"
zip_buffer_t *_zip_buffer_new(zip_uint8_t *data , zip_uint64_t size ) 
{ 
  int free_data ;
  zip_buffer_t *buffer ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
#line 147
  free_data = (unsigned long )data == (unsigned long )((void *)0);
#line 150
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 151
    __cil_tmp5 = malloc(size);
#line 151
    data = (zip_uint8_t *)__cil_tmp5;
    }
#line 151
    if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 152
      return ((zip_buffer_t *)((void *)0));
    }
  }
  {
#line 156
  __cil_tmp6 = malloc(sizeof(*buffer));
#line 156
  buffer = (zip_buffer_t *)__cil_tmp6;
  }
#line 156
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 157
    if (free_data) {
      {
#line 158
      free((void *)data);
      }
    }
#line 160
    return ((zip_buffer_t *)((void *)0));
  }
#line 163
  buffer->ok = 1;
#line 164
  buffer->data = data;
#line 165
  buffer->size = size;
#line 166
  buffer->offset = (zip_uint64_t )0;
#line 167
  buffer->free_data = free_data;
#line 169
  return (buffer);
}
}
#line 174 "/root/libzip/lib/zip_buffer.c"
zip_buffer_t *_zip_buffer_new_from_source(zip_source_t *src , zip_uint64_t size ,
                                          zip_uint8_t *buf , zip_error_t *error ) 
{ 
  zip_buffer_t *buffer ;
  int __cil_tmp7 ;

  {
  {
#line 178
  buffer = _zip_buffer_new(buf, size);
  }
#line 178
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 179
    zip_error_set(error, 14, 0);
    }
#line 180
    return ((zip_buffer_t *)((void *)0));
  }
  {
#line 183
  __cil_tmp7 = _zip_read(src, buffer->data, size, error);
  }
#line 183
  if (__cil_tmp7 < 0) {
    {
#line 184
    _zip_buffer_free(buffer);
    }
#line 185
    return ((zip_buffer_t *)((void *)0));
  }
#line 188
  return (buffer);
}
}
#line 193 "/root/libzip/lib/zip_buffer.c"
zip_uint64_t _zip_buffer_offset(zip_buffer_t *buffer ) 
{ 
  zip_uint64_t tmp ;

  {
#line 195
  if (buffer->ok) {
#line 195
    tmp = buffer->offset;
  } else {
#line 195
    tmp = 0UL;
  }
#line 195
  return (tmp);
}
}
#line 200 "/root/libzip/lib/zip_buffer.c"
int _zip_buffer_ok(zip_buffer_t *buffer ) 
{ 


  {
#line 202
  return (buffer->ok);
}
}
#line 207 "/root/libzip/lib/zip_buffer.c"
int _zip_buffer_put(zip_buffer_t *buffer , void const   *src , size_t length ) 
{ 
  zip_uint8_t *dst ;
  zip_uint8_t *__cil_tmp5 ;

  {
  {
#line 209
  __cil_tmp5 = _zip_buffer_get(buffer, length);
#line 209
  dst = __cil_tmp5;
  }
#line 211
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 212
    return (-1);
  }
  {
#line 215
  memcpy((void *)dst, src, length);
  }
#line 216
  return (0);
}
}
#line 221 "/root/libzip/lib/zip_buffer.c"
int _zip_buffer_put_16(zip_buffer_t *buffer , zip_uint16_t i ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp4 ;

  {
  {
#line 223
  __cil_tmp4 = _zip_buffer_get(buffer, (zip_uint64_t )2);
#line 223
  data = __cil_tmp4;
  }
#line 225
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 226
    return (-1);
  }
#line 229
  *(data + 0) = (zip_uint8_t )((int )i & 255);
#line 230
  *(data + 1) = (zip_uint8_t )(((int )i >> 8) & 255);
#line 232
  return (0);
}
}
#line 237 "/root/libzip/lib/zip_buffer.c"
int _zip_buffer_put_32(zip_buffer_t *buffer , zip_uint32_t i ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp4 ;

  {
  {
#line 239
  __cil_tmp4 = _zip_buffer_get(buffer, (zip_uint64_t )4);
#line 239
  data = __cil_tmp4;
  }
#line 241
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 242
    return (-1);
  }
#line 245
  *(data + 0) = (zip_uint8_t )(i & 255U);
#line 246
  *(data + 1) = (zip_uint8_t )((i >> 8) & 255U);
#line 247
  *(data + 2) = (zip_uint8_t )((i >> 16) & 255U);
#line 248
  *(data + 3) = (zip_uint8_t )((i >> 24) & 255U);
#line 250
  return (0);
}
}
#line 255 "/root/libzip/lib/zip_buffer.c"
int _zip_buffer_put_64(zip_buffer_t *buffer , zip_uint64_t i ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp4 ;

  {
  {
#line 257
  __cil_tmp4 = _zip_buffer_get(buffer, (zip_uint64_t )8);
#line 257
  data = __cil_tmp4;
  }
#line 259
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 260
    return (-1);
  }
#line 263
  *(data + 0) = (zip_uint8_t )(i & 255UL);
#line 264
  *(data + 1) = (zip_uint8_t )((i >> 8) & 255UL);
#line 265
  *(data + 2) = (zip_uint8_t )((i >> 16) & 255UL);
#line 266
  *(data + 3) = (zip_uint8_t )((i >> 24) & 255UL);
#line 267
  *(data + 4) = (zip_uint8_t )((i >> 32) & 255UL);
#line 268
  *(data + 5) = (zip_uint8_t )((i >> 40) & 255UL);
#line 269
  *(data + 6) = (zip_uint8_t )((i >> 48) & 255UL);
#line 270
  *(data + 7) = (zip_uint8_t )((i >> 56) & 255UL);
#line 272
  return (0);
}
}
#line 277 "/root/libzip/lib/zip_buffer.c"
int _zip_buffer_put_8(zip_buffer_t *buffer , zip_uint8_t i ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp4 ;

  {
  {
#line 279
  __cil_tmp4 = _zip_buffer_get(buffer, (zip_uint64_t )1);
#line 279
  data = __cil_tmp4;
  }
#line 281
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 282
    return (-1);
  }
#line 285
  *(data + 0) = i;
#line 287
  return (0);
}
}
#line 292 "/root/libzip/lib/zip_buffer.c"
int _zip_buffer_set_offset(zip_buffer_t *buffer , zip_uint64_t offset ) 
{ 


  {
#line 294
  if (offset > buffer->size) {
#line 295
    buffer->ok = 0;
#line 296
    return (-1);
  }
#line 299
  buffer->ok = 1;
#line 300
  buffer->offset = offset;
#line 302
  return (0);
}
}
#line 307 "/root/libzip/lib/zip_buffer.c"
int _zip_buffer_skip(zip_buffer_t *buffer , zip_uint64_t length ) 
{ 
  zip_uint64_t offset ;
  int __cil_tmp4 ;

  {
#line 308
  offset = buffer->offset + length;
#line 310
  if (offset < buffer->offset) {
#line 311
    buffer->ok = 0;
#line 312
    return (-1);
  }
  {
#line 314
  __cil_tmp4 = _zip_buffer_set_offset(buffer, offset);
  }
#line 314
  return (__cil_tmp4);
}
}
#line 318 "/root/libzip/lib/zip_buffer.c"
zip_uint64_t _zip_buffer_size(zip_buffer_t *buffer ) 
{ 


  {
#line 320
  return (buffer->size);
}
}
#line 43 "/root/libzip/lib/zip_add_entry.c"
zip_int64_t _zip_add_entry(zip_t *za___0 ) 
{ 
  zip_uint64_t idx ;
  zip_entry_t *rentries ;
  zip_uint64_t nalloc ;
  zip_uint64_t additional_entries ;
  zip_uint64_t realloc_size ;
  void *__cil_tmp7 ;
  zip_uint64_t __cil_tmp8 ;

  {
#line 47
  if (za___0->nentry + 1UL >= za___0->nentry_alloc) {
#line 49
    nalloc = za___0->nentry_alloc;
#line 50
    additional_entries = 2UL * nalloc;
#line 53
    if (additional_entries < 16UL) {
#line 54
      additional_entries = (zip_uint64_t )16;
    } else
#line 56
    if (additional_entries > 1024UL) {
#line 57
      additional_entries = (zip_uint64_t )1024;
    }
#line 60
    nalloc += additional_entries;
#line 61
    realloc_size = sizeof(struct zip_entry ) * nalloc;
#line 63
    if (sizeof(struct zip_entry ) * za___0->nentry_alloc > realloc_size) {
      {
#line 64
      zip_error_set(& za___0->error, 14, 0);
      }
#line 65
      return ((zip_int64_t )-1);
    }
    {
#line 67
    __cil_tmp7 = realloc((void *)za___0->entry, sizeof(struct zip_entry ) * nalloc);
#line 67
    rentries = (zip_entry_t *)__cil_tmp7;
    }
#line 68
    if (! rentries) {
      {
#line 69
      zip_error_set(& za___0->error, 14, 0);
      }
#line 70
      return ((zip_int64_t )-1);
    }
#line 72
    za___0->entry = rentries;
#line 73
    za___0->nentry_alloc = nalloc;
  }
  {
#line 76
  __cil_tmp8 = za___0->nentry;
#line 76
  (za___0->nentry) ++;
#line 76
  idx = __cil_tmp8;
#line 78
  _zip_entry_init(za___0->entry + idx);
  }
#line 80
  return ((zip_int64_t )idx);
}
}
#line 42 "/root/libzip/lib/zip_add_dir.c"
zip_int64_t zip_add_dir(zip_t *za___0 , char const   *name ) 
{ 
  zip_int64_t __cil_tmp3 ;

  {
  {
#line 44
  __cil_tmp3 = zip_dir_add(za___0, name, (zip_flags_t )0);
  }
#line 44
  return (__cil_tmp3);
}
}
#line 47 "/root/libzip/lib/zip_add.c"
zip_int64_t zip_add(zip_t *za___0 , char const   *name , zip_source_t *source ) 
{ 
  zip_int64_t __cil_tmp4 ;

  {
  {
#line 49
  __cil_tmp4 = zip_file_add(za___0, name, source, (zip_flags_t )0);
  }
#line 49
  return (__cil_tmp4);
}
}
#line 56 "/root/libzip/src/ziptool.c"
zip_source_t *source_hole_create(char const   *fname , int flags , zip_error_t *error ) ;
#line 72
static zip_flags_t get_flags(char const   *arg ) ;
#line 73
static zip_int32_t get_compression_method(char const   *arg ) ;
#line 74
static void hexdump(zip_uint8_t *data , zip_uint16_t len ) ;
#line 75
static zip_t *read_to_memory(char const   *archive , int flags , int *err , zip_source_t **srcp ) ;
#line 76
static zip_source_t *source_nul(zip_t *zs , zip_uint64_t length ) ;
#line 78 "/root/libzip/src/ziptool.c"
zip_t *za  ;
#line 78 "/root/libzip/src/ziptool.c"
zip_t *z_in[16]  ;
#line 79 "/root/libzip/src/ziptool.c"
unsigned int z_in_count  ;
#line 80 "/root/libzip/src/ziptool.c"
zip_flags_t stat_flags  ;
#line 83 "/root/libzip/src/ziptool.c"
static int add(int argc , char **argv ) 
{ 
  zip_source_t *zs ;
  unsigned long __cil_tmp4 ;
  zip_source_t *__cil_tmp5 ;
  char const   *__cil_tmp6 ;
  zip_int64_t __cil_tmp7 ;
  char const   *__cil_tmp8 ;

  {
  {
#line 86
  __cil_tmp4 = strlen((char const   *)*(argv + 1));
#line 86
  __cil_tmp5 = zip_source_buffer(za, (void const   *)*(argv + 1), __cil_tmp4, 0);
#line 86
  zs = __cil_tmp5;
  }
#line 86
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
    {
#line 87
    __cil_tmp6 = zip_strerror(za);
#line 87
    fprintf(stderr, "can\'t create zip_source from buffer: %s\n\230", __cil_tmp6);
    }
#line 88
    return (-1);
  }
  {
#line 91
  __cil_tmp7 = zip_add(za, (char const   *)*(argv + 0), zs);
  }
#line 91
  if (__cil_tmp7 == -1L) {
    {
#line 92
    zip_source_free(zs);
#line 93
    __cil_tmp8 = zip_strerror(za);
#line 93
    fprintf(stderr, "can\'t add file \'%s\': %s\n\230\001", *(argv + 0), __cil_tmp8);
    }
#line 94
    return (-1);
  }
#line 96
  return (0);
}
}
#line 100 "/root/libzip/src/ziptool.c"
static int add_dir(int argc , char **argv ) 
{ 
  zip_int64_t __cil_tmp3 ;
  char const   *__cil_tmp4 ;

  {
  {
#line 102
  __cil_tmp3 = zip_add_dir(za, (char const   *)*(argv + 0));
  }
#line 102
  if (__cil_tmp3 < 0L) {
    {
#line 103
    __cil_tmp4 = zip_strerror(za);
#line 103
    fprintf(stderr, "can\'t add directory \'%s\': %s\n", *(argv + 0), __cil_tmp4);
    }
#line 104
    return (-1);
  }
#line 106
  return (0);
}
}
#line 110 "/root/libzip/src/ziptool.c"
static int add_file(int argc , char **argv ) 
{ 
  zip_source_t *zs ;
  zip_uint64_t start ;
  unsigned long long __cil_tmp5 ;
  zip_int64_t len ;
  long long __cil_tmp7 ;
  char const   *__cil_tmp9 ;
  zip_int64_t __cil_tmp12 ;
  char const   *__cil_tmp13 ;

  {
  {
#line 112
  __cil_tmp5 = strtoull((char const   *)*(argv + 2), (char **)((void *)0), 10);
#line 112
  start = (zip_uint64_t )__cil_tmp5;
#line 113
  __cil_tmp7 = strtoll((char const   *)*(argv + 3), (char **)((void *)0), 10);
#line 113
  len = (zip_int64_t )__cil_tmp7;
#line 116
  zs = zip_source_filep(za, stdin, start, len);
  }
#line 116
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
    {
#line 117
    __cil_tmp9 = zip_strerror(za);
#line 117
    fprintf(stderr, "can\'t create zip_source from stdin: %s\n", __cil_tmp9);
    }
#line 118
    return (-1);
  }
  {
#line 127
  __cil_tmp12 = zip_add(za, (char const   *)*(argv + 0), zs);
  }
#line 127
  if (__cil_tmp12 == -1L) {
    {
#line 128
    zip_source_free(zs);
#line 129
    __cil_tmp13 = zip_strerror(za);
#line 129
    fprintf(stderr, "can\'t add file \'%s\': %s\n\230\001", *(argv + 0), __cil_tmp13);
    }
#line 130
    return (-1);
  }
#line 132
  return (0);
}
}
#line 136 "/root/libzip/src/ziptool.c"
static int add_from_zip(int argc , char **argv ) 
{ 
  zip_uint64_t idx ;
  zip_uint64_t start ;
  zip_int64_t len ;
  int err ;
  zip_source_t *zs ;
  unsigned long long __cil_tmp8 ;
  unsigned long long __cil_tmp9 ;
  long long __cil_tmp10 ;
  zip_error_t error ;
  char const   *__cil_tmp13 ;
  char const   *__cil_tmp15 ;
  zip_int64_t __cil_tmp16 ;
  char const   *__cil_tmp17 ;

  {
  {
#line 142
  __cil_tmp8 = strtoull((char const   *)*(argv + 2), (char **)((void *)0), 10);
#line 142
  idx = (zip_uint64_t )__cil_tmp8;
#line 143
  __cil_tmp9 = strtoull((char const   *)*(argv + 3), (char **)((void *)0), 10);
#line 143
  start = (zip_uint64_t )__cil_tmp9;
#line 144
  __cil_tmp10 = strtoll((char const   *)*(argv + 4), (char **)((void *)0), 10);
#line 144
  len = (zip_int64_t )__cil_tmp10;
#line 145
  z_in[z_in_count] = zip_open((char const   *)*(argv + 1), 4, & err);
  }
#line 145
  if ((unsigned long )z_in[z_in_count] == (unsigned long )((void *)0)) {
    {
#line 147
    zip_error_init_with_code(& error, err);
#line 148
    __cil_tmp13 = zip_error_strerror(& error);
#line 148
    fprintf(stderr, "can\'t open zip archive \'%s\': %s\n\230\001", *(argv + 1), __cil_tmp13);
#line 149
    zip_error_fini(& error);
    }
#line 150
    return (-1);
  }
  {
#line 152
  zs = zip_source_zip(za, z_in[z_in_count], idx, (zip_flags_t )0, start, len);
  }
#line 152
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
    {
#line 153
    __cil_tmp15 = zip_strerror(za);
#line 153
    fprintf(stderr, "error creating file source from \'%s\' index \'%lu\': %s\n",
            *(argv + 1), idx, __cil_tmp15);
#line 154
    zip_close(z_in[z_in_count]);
    }
#line 155
    return (-1);
  }
  {
#line 157
  __cil_tmp16 = zip_add(za, (char const   *)*(argv + 0), zs);
  }
#line 157
  if (__cil_tmp16 == -1L) {
    {
#line 158
    __cil_tmp17 = zip_strerror(za);
#line 158
    fprintf(stderr, "can\'t add file \'%s\': %s\n\230\001", *(argv + 0), __cil_tmp17);
#line 159
    zip_source_free(zs);
#line 160
    zip_close(z_in[z_in_count]);
    }
#line 161
    return (-1);
  }
#line 163
  z_in_count ++;
#line 164
  return (0);
}
}
#line 168 "/root/libzip/src/ziptool.c"
static int add_nul(int argc , char **argv ) 
{ 
  zip_source_t *zs ;
  zip_uint64_t length ;
  unsigned long long __cil_tmp5 ;
  char const   *__cil_tmp7 ;
  zip_int64_t __cil_tmp8 ;
  char const   *__cil_tmp9 ;

  {
  {
#line 170
  __cil_tmp5 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 170
  length = (zip_uint64_t )__cil_tmp5;
#line 172
  zs = source_nul(za, length);
  }
#line 172
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
    {
#line 173
    __cil_tmp7 = zip_strerror(za);
#line 173
    fprintf(stderr, "can\'t create zip_source for length: %s\n", __cil_tmp7);
    }
#line 174
    return (-1);
  }
  {
#line 177
  __cil_tmp8 = zip_add(za, (char const   *)*(argv + 0), zs);
  }
#line 177
  if (__cil_tmp8 == -1L) {
    {
#line 178
    zip_source_free(zs);
#line 179
    __cil_tmp9 = zip_strerror(za);
#line 179
    fprintf(stderr, "can\'t add file \'%s\': %s\n\230\001", *(argv + 0), __cil_tmp9);
    }
#line 180
    return (-1);
  }
#line 182
  return (0);
}
}
#line 186 "/root/libzip/src/ziptool.c"
static int cat(int argc , char **argv ) 
{ 
  zip_uint64_t idx ;
  zip_int64_t n ;
  zip_file_t *zf ;
  char buf[8192] ;
  int err ;
  unsigned long long __cil_tmp8 ;
  char const   *__cil_tmp10 ;
  unsigned long __cil_tmp12 ;
  int *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char const   *__cil_tmp15 ;
  zip_error_t error ;
  char const   *__cil_tmp18 ;

  {
  {
#line 193
  __cil_tmp8 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 193
  idx = (zip_uint64_t )__cil_tmp8;
#line 199
  zf = zip_fopen_index(za, idx, (zip_flags_t )0);
  }
#line 199
  if ((unsigned long )zf == (unsigned long )((void *)0)) {
    {
#line 200
    __cil_tmp10 = zip_strerror(za);
#line 200
    fprintf(stderr, "can\'t open file at index \'%lu\': %s\n", idx, __cil_tmp10);
    }
#line 201
    return (-1);
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 203
    n = zip_fread(zf, (void *)(buf), sizeof(buf));
    }
#line 203
    if (! (n > 0L)) {
#line 203
      goto while_break;
    }
    {
#line 204
    __cil_tmp12 = fwrite((void const   *)(buf), (size_t )n, 1UL, stdout);
    }
#line 204
    if (__cil_tmp12 != 1UL) {
      {
#line 205
      zip_fclose(zf);
#line 206
      __cil_tmp13 = __errno_location();
#line 206
      __cil_tmp14 = strerror(*__cil_tmp13);
#line 206
      fprintf(stderr, "can\'t write file contents to stdout: %s\n\230", __cil_tmp14);
      }
#line 207
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 210
  if (n == -1L) {
    {
#line 211
    zip_fclose(zf);
#line 212
    __cil_tmp15 = zip_file_strerror(zf);
#line 212
    fprintf(stderr, "can\'t read file at index \'%lu\': %s\n", idx, __cil_tmp15);
    }
#line 213
    return (-1);
  }
  {
#line 215
  err = zip_fclose(zf);
  }
#line 215
  if (err != 0) {
    {
#line 218
    zip_error_init_with_code(& error, err);
#line 219
    __cil_tmp18 = zip_error_strerror(& error);
#line 219
    fprintf(stderr, "can\'t close file at index \'%lu\': %s\n\230\001", idx, __cil_tmp18);
    }
#line 220
    return (-1);
  }
#line 223
  return (0);
}
}
#line 227 "/root/libzip/src/ziptool.c"
static int count_extra(int argc , char **argv ) 
{ 
  zip_int16_t count ;
  zip_uint64_t idx ;
  zip_flags_t ceflags ;
  unsigned long long __cil_tmp6 ;
  char const   *__cil_tmp9 ;

  {
  {
#line 230
  ceflags = (zip_flags_t )0;
#line 231
  __cil_tmp6 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 231
  idx = (zip_uint64_t )__cil_tmp6;
#line 232
  ceflags = get_flags((char const   *)*(argv + 1));
#line 233
  count = zip_file_extra_fields_count(za, idx, ceflags);
  }
#line 233
  if ((int )count < 0) {
    {
#line 234
    __cil_tmp9 = zip_strerror(za);
#line 234
    fprintf(stderr, "can\'t get extra field count for file at index \'%lu\': %s\n8V",
            idx, __cil_tmp9);
    }
#line 235
    return (-1);
  } else {
    {
#line 237
    printf("Extra field count: %d\n", (int )count);
    }
  }
#line 239
  return (0);
}
}
#line 243 "/root/libzip/src/ziptool.c"
static int count_extra_by_id(int argc , char **argv ) 
{ 
  zip_int16_t count ;
  zip_uint16_t eid ;
  zip_flags_t ceflags ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp7 ;
  unsigned long long __cil_tmp8 ;
  char const   *__cil_tmp11 ;

  {
  {
#line 246
  ceflags = (zip_flags_t )0;
#line 248
  __cil_tmp7 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 248
  idx = (zip_uint64_t )__cil_tmp7;
#line 249
  __cil_tmp8 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 249
  eid = (zip_uint16_t )__cil_tmp8;
#line 250
  ceflags = get_flags((char const   *)*(argv + 2));
#line 251
  count = zip_file_extra_fields_count_by_id(za, idx, eid, ceflags);
  }
#line 251
  if ((int )count < 0) {
    {
#line 252
    __cil_tmp11 = zip_strerror(za);
#line 252
    fprintf(stderr, "can\'t get extra field count for file at index \'%lu\' and for id `%d\': %s\n",
            idx, (int )eid, __cil_tmp11);
    }
#line 253
    return (-1);
  } else {
    {
#line 255
    printf("Extra field count: %d\n", (int )count);
    }
  }
#line 257
  return (0);
}
}
#line 261 "/root/libzip/src/ziptool.c"
static int delete(int argc , char **argv ) 
{ 
  zip_uint64_t idx ;
  unsigned long long __cil_tmp4 ;
  int __cil_tmp5 ;
  char const   *__cil_tmp6 ;

  {
  {
#line 263
  __cil_tmp4 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 263
  idx = (zip_uint64_t )__cil_tmp4;
#line 264
  __cil_tmp5 = zip_delete(za, idx);
  }
#line 264
  if (__cil_tmp5 < 0) {
    {
#line 265
    __cil_tmp6 = zip_strerror(za);
#line 265
    fprintf(stderr, "can\'t delete file at index \'%lu\': %s\n\r\270Q8V", idx, __cil_tmp6);
    }
#line 266
    return (-1);
  }
#line 268
  return (0);
}
}
#line 272 "/root/libzip/src/ziptool.c"
static int delete_extra(int argc , char **argv ) 
{ 
  zip_flags_t geflags ;
  zip_uint16_t eid ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp6 ;
  unsigned long long __cil_tmp7 ;
  int __cil_tmp9 ;
  char const   *__cil_tmp10 ;

  {
  {
#line 276
  __cil_tmp6 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 276
  idx = (zip_uint64_t )__cil_tmp6;
#line 277
  __cil_tmp7 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 277
  eid = (zip_uint16_t )__cil_tmp7;
#line 278
  geflags = get_flags((char const   *)*(argv + 2));
#line 279
  __cil_tmp9 = zip_file_extra_field_delete(za, idx, eid, geflags);
  }
#line 279
  if (__cil_tmp9 < 0) {
    {
#line 280
    __cil_tmp10 = zip_strerror(za);
#line 280
    fprintf(stderr, "can\'t delete extra field data for file at index \'%lu\', extra field id `%d\': %s\n",
            idx, (int )eid, __cil_tmp10);
    }
#line 281
    return (-1);
  }
#line 283
  return (0);
}
}
#line 287 "/root/libzip/src/ziptool.c"
static int delete_extra_by_id(int argc , char **argv ) 
{ 
  zip_flags_t geflags ;
  zip_uint16_t eid ;
  zip_uint16_t eidx ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp7 ;
  unsigned long long __cil_tmp8 ;
  unsigned long long __cil_tmp9 ;
  int __cil_tmp11 ;
  char const   *__cil_tmp12 ;

  {
  {
#line 291
  __cil_tmp7 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 291
  idx = (zip_uint64_t )__cil_tmp7;
#line 292
  __cil_tmp8 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 292
  eid = (zip_uint16_t )__cil_tmp8;
#line 293
  __cil_tmp9 = strtoull((char const   *)*(argv + 2), (char **)((void *)0), 10);
#line 293
  eidx = (zip_uint16_t )__cil_tmp9;
#line 294
  geflags = get_flags((char const   *)*(argv + 3));
#line 295
  __cil_tmp11 = zip_file_extra_field_delete_by_id(za, idx, eid, eidx, geflags);
  }
#line 295
  if (__cil_tmp11 < 0) {
    {
#line 296
    __cil_tmp12 = zip_strerror(za);
#line 296
    fprintf(stderr, "can\'t delete extra field data for file at index \'%lu\', extra field id `%d\', extra field idx `%d\': %s\n",
            idx, (int )eid, (int )eidx, __cil_tmp12);
    }
#line 297
    return (-1);
  }
#line 299
  return (0);
}
}
#line 303 "/root/libzip/src/ziptool.c"
static int get_archive_comment(int argc , char **argv ) 
{ 
  char const   *comment ;
  int len ;

  {
  {
#line 307
  comment = zip_get_archive_comment(za, & len, (zip_flags_t )0);
  }
#line 307
  if ((unsigned long )comment == (unsigned long )((void *)0)) {
    {
#line 308
    printf("No archive comment\n");
    }
  } else {
    {
#line 310
    printf("Archive comment: %.*s\n", len, comment);
    }
  }
#line 311
  return (0);
}
}
#line 315 "/root/libzip/src/ziptool.c"
static int get_extra(int argc , char **argv ) 
{ 
  zip_flags_t geflags ;
  zip_uint16_t id ;
  zip_uint16_t eidx ;
  zip_uint16_t eflen ;
  zip_uint8_t *efdata ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp9 ;
  unsigned long long __cil_tmp10 ;
  char const   *__cil_tmp13 ;

  {
  {
#line 321
  __cil_tmp9 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 321
  idx = (zip_uint64_t )__cil_tmp9;
#line 322
  __cil_tmp10 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 322
  eidx = (zip_uint16_t )__cil_tmp10;
#line 323
  geflags = get_flags((char const   *)*(argv + 2));
#line 324
  efdata = zip_file_extra_field_get(za, idx, eidx, & id, & eflen, geflags);
  }
#line 324
  if ((unsigned long )efdata == (unsigned long )((void *)0)) {
    {
#line 325
    __cil_tmp13 = zip_strerror(za);
#line 325
    fprintf(stderr, "can\'t get extra field data for file at index %lu, extra field %d, flags %u: %s\n",
            idx, (int )eidx, geflags, __cil_tmp13);
    }
#line 326
    return (-1);
  }
  {
#line 328
  printf("Extra field 0x%04x: len %d", (int )id, (int )eflen);
  }
#line 329
  if ((int )eflen > 0) {
    {
#line 330
    printf(", data ");
#line 331
    hexdump(efdata, eflen);
    }
  }
  {
#line 333
  printf("\n");
  }
#line 334
  return (0);
}
}
#line 338 "/root/libzip/src/ziptool.c"
static int get_extra_by_id(int argc , char **argv ) 
{ 
  zip_flags_t geflags ;
  zip_uint16_t eid ;
  zip_uint16_t eidx ;
  zip_uint16_t eflen ;
  zip_uint8_t *efdata ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp9 ;
  unsigned long long __cil_tmp10 ;
  unsigned long long __cil_tmp11 ;
  char const   *__cil_tmp14 ;

  {
  {
#line 343
  __cil_tmp9 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 343
  idx = (zip_uint64_t )__cil_tmp9;
#line 344
  __cil_tmp10 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 344
  eid = (zip_uint16_t )__cil_tmp10;
#line 345
  __cil_tmp11 = strtoull((char const   *)*(argv + 2), (char **)((void *)0), 10);
#line 345
  eidx = (zip_uint16_t )__cil_tmp11;
#line 346
  geflags = get_flags((char const   *)*(argv + 3));
#line 347
  efdata = zip_file_extra_field_get_by_id(za, idx, eid, eidx, & eflen, geflags);
  }
#line 347
  if ((unsigned long )efdata == (unsigned long )((void *)0)) {
    {
#line 348
    __cil_tmp14 = zip_strerror(za);
#line 348
    fprintf(stderr, "can\'t get extra field data for file at index %lu, extra field id %d, ef index %d, flags %u: %s\n",
            idx, (int )eid, (int )eidx, geflags, __cil_tmp14);
    }
#line 349
    return (-1);
  }
  {
#line 351
  printf("Extra field 0x%04x: len %d", (int )eid, (int )eflen);
  }
#line 352
  if ((int )eflen > 0) {
    {
#line 353
    printf(", data ");
#line 354
    hexdump(efdata, eflen);
    }
  }
  {
#line 356
  printf("\n");
  }
#line 357
  return (0);
}
}
#line 361 "/root/libzip/src/ziptool.c"
static int get_file_comment(int argc , char **argv ) 
{ 
  char const   *comment ;
  int len ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp6 ;
  char const   *__cil_tmp8 ;
  char const   *__cil_tmp9 ;
  char const   *__cil_tmp10 ;
  char const   *__cil_tmp11 ;

  {
  {
#line 366
  __cil_tmp6 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 366
  idx = (zip_uint64_t )__cil_tmp6;
#line 367
  comment = zip_get_file_comment(za, idx, & len, 0);
  }
#line 367
  if ((unsigned long )comment == (unsigned long )((void *)0)) {
    {
#line 368
    __cil_tmp8 = zip_get_name(za, idx, (zip_flags_t )0);
#line 368
    __cil_tmp9 = zip_strerror(za);
#line 368
    fprintf(stderr, "can\'t get comment for \'%s\': %s\n", __cil_tmp8, __cil_tmp9);
    }
#line 369
    return (-1);
  } else
#line 370
  if (len == 0) {
    {
#line 371
    __cil_tmp10 = zip_get_name(za, idx, (zip_flags_t )0);
#line 371
    printf("No comment for \'%s\'\n", __cil_tmp10);
    }
  } else {
    {
#line 373
    __cil_tmp11 = zip_get_name(za, idx, (zip_flags_t )0);
#line 373
    printf("File comment for \'%s\': %.*s\n", __cil_tmp11, len, comment);
    }
  }
#line 374
  return (0);
}
}
#line 378 "/root/libzip/src/ziptool.c"
static int get_num_entries(int argc , char **argv ) 
{ 
  zip_int64_t count ;
  zip_flags_t flags ;
  char const   *tmp ;

  {
  {
#line 382
  flags = get_flags((char const   *)*(argv + 0));
#line 383
  count = zip_get_num_entries(za, flags);
  }
#line 384
  if (count == 1L) {
#line 384
    tmp = "y";
  } else {
#line 384
    tmp = "ies";
  }
  {
#line 384
  printf("%ld entr%s in archive\n", count, tmp);
  }
#line 385
  return (0);
}
}
#line 389 "/root/libzip/src/ziptool.c"
static int name_locate(int argc , char **argv ) 
{ 
  zip_flags_t flags ;
  zip_int64_t idx ;

  {
  {
#line 392
  flags = get_flags((char const   *)*(argv + 1));
#line 394
  idx = zip_name_locate(za, (char const   *)*(argv + 0), flags);
  }
#line 394
  if (idx < 0L) {
    {
#line 395
    fprintf(stderr, "can\'t find entry with name \'%s\' using flags \'%s\'\nw\270Q8V",
            *(argv + 0), *(argv + 1));
    }
  } else {
    {
#line 397
    printf("name \'%s\' using flags \'%s\' found at index %ld\n", *(argv + 0), *(argv + 1),
           idx);
    }
  }
#line 400
  return (0);
}
}
#line 404 "/root/libzip/src/ziptool.c"
static int zrename(int argc , char **argv ) 
{ 
  zip_uint64_t idx ;
  unsigned long long __cil_tmp4 ;
  int __cil_tmp5 ;
  char const   *__cil_tmp6 ;

  {
  {
#line 406
  __cil_tmp4 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 406
  idx = (zip_uint64_t )__cil_tmp4;
#line 407
  __cil_tmp5 = zip_rename(za, idx, (char const   *)*(argv + 1));
  }
#line 407
  if (__cil_tmp5 < 0) {
    {
#line 408
    __cil_tmp6 = zip_strerror(za);
#line 408
    fprintf(stderr, "can\'t rename file at index \'%lu\' to `%s\': %s\n", idx, *(argv + 1),
            __cil_tmp6);
    }
#line 409
    return (-1);
  }
#line 411
  return (0);
}
}
#line 415 "/root/libzip/src/ziptool.c"
static int replace_file_contents(int argc , char **argv ) 
{ 
  char const   *content ;
  zip_source_t *s ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  zip_source_t *__cil_tmp8 ;
  int __cil_tmp9 ;
  char const   *__cil_tmp10 ;

  {
  {
#line 420
  __cil_tmp6 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 420
  idx = (zip_uint64_t )__cil_tmp6;
#line 421
  content = (char const   *)*(argv + 1);
#line 422
  __cil_tmp9 = zip_file_replace(za, idx, s, (zip_flags_t )0);
#line 422
  __cil_tmp7 = strlen(content);
#line 422
  __cil_tmp8 = zip_source_buffer(za, (void const   *)content, __cil_tmp7, 0);
#line 422
  s = __cil_tmp8;
  }
#line 422
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 424
    zip_source_free(s);
#line 425
    __cil_tmp10 = zip_strerror(za);
#line 425
    fprintf(stderr, "error replacing file data: %s\n", __cil_tmp10);
    }
#line 426
    return (-1);
  } else
#line 422
  if (__cil_tmp9 < 0) {
    {
#line 424
    zip_source_free(s);
#line 425
    __cil_tmp10 = zip_strerror(za);
#line 425
    fprintf(stderr, "error replacing file data: %s\n", __cil_tmp10);
    }
#line 426
    return (-1);
  }
#line 428
  return (0);
}
}
#line 432 "/root/libzip/src/ziptool.c"
static int set_extra(int argc , char **argv ) 
{ 
  zip_flags_t geflags ;
  zip_uint16_t eid ;
  zip_uint16_t eidx ;
  zip_uint8_t *efdata ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp8 ;
  unsigned long long __cil_tmp9 ;
  unsigned long long __cil_tmp10 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  char const   *__cil_tmp14 ;

  {
  {
#line 437
  __cil_tmp8 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 437
  idx = (zip_uint64_t )__cil_tmp8;
#line 438
  __cil_tmp9 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 438
  eid = (zip_uint16_t )__cil_tmp9;
#line 439
  __cil_tmp10 = strtoull((char const   *)*(argv + 2), (char **)((void *)0), 10);
#line 439
  eidx = (zip_uint16_t )__cil_tmp10;
#line 440
  geflags = get_flags((char const   *)*(argv + 3));
#line 441
  efdata = (zip_uint8_t *)*(argv + 4);
#line 442
  __cil_tmp12 = strlen((char const   *)efdata);
#line 442
  __cil_tmp13 = zip_file_extra_field_set(za, idx, eid, eidx, efdata, (zip_uint16_t )__cil_tmp12,
                                         geflags);
  }
#line 442
  if (__cil_tmp13 < 0) {
    {
#line 443
    __cil_tmp14 = zip_strerror(za);
#line 443
    fprintf(stderr, "can\'t set extra field data for file at index \'%lu\', extra field id `%d\', index `%d\': %s\n",
            idx, (int )eid, (int )eidx, __cil_tmp14);
    }
#line 444
    return (-1);
  }
#line 446
  return (0);
}
}
#line 450 "/root/libzip/src/ziptool.c"
static int set_archive_comment(int argc , char **argv ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  char const   *__cil_tmp5 ;

  {
  {
#line 451
  __cil_tmp3 = strlen((char const   *)*(argv + 0));
#line 451
  __cil_tmp4 = zip_set_archive_comment(za, (char const   *)*(argv + 0), (zip_uint16_t )__cil_tmp3);
  }
#line 451
  if (__cil_tmp4 < 0) {
    {
#line 452
    __cil_tmp5 = zip_strerror(za);
#line 452
    fprintf(stderr, "can\'t set archive comment to `%s\': %s\n", *(argv + 0), __cil_tmp5);
    }
#line 453
    return (-1);
  }
#line 455
  return (0);
}
}
#line 459 "/root/libzip/src/ziptool.c"
static int set_file_comment(int argc , char **argv ) 
{ 
  zip_uint64_t idx ;
  unsigned long long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  char const   *__cil_tmp7 ;

  {
  {
#line 461
  __cil_tmp4 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 461
  idx = (zip_uint64_t )__cil_tmp4;
#line 462
  __cil_tmp5 = strlen((char const   *)*(argv + 1));
#line 462
  __cil_tmp6 = zip_file_set_comment(za, idx, (char const   *)*(argv + 1), (zip_uint16_t )__cil_tmp5,
                                    (zip_flags_t )0);
  }
#line 462
  if (__cil_tmp6 < 0) {
    {
#line 463
    __cil_tmp7 = zip_strerror(za);
#line 463
    fprintf(stderr, "can\'t set file comment at index \'%lu\' to `%s\': %s\n", idx,
            *(argv + 1), __cil_tmp7);
    }
#line 464
    return (-1);
  }
#line 466
  return (0);
}
}
#line 470 "/root/libzip/src/ziptool.c"
static int set_file_compression(int argc , char **argv ) 
{ 
  zip_int32_t method ;
  zip_uint32_t flags ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp6 ;
  unsigned long long __cil_tmp8 ;
  int __cil_tmp9 ;
  char const   *__cil_tmp10 ;

  {
  {
#line 474
  __cil_tmp6 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 474
  idx = (zip_uint64_t )__cil_tmp6;
#line 475
  method = get_compression_method((char const   *)*(argv + 1));
#line 476
  __cil_tmp8 = strtoull((char const   *)*(argv + 2), (char **)((void *)0), 10);
#line 476
  flags = (zip_uint32_t )__cil_tmp8;
#line 477
  __cil_tmp9 = zip_set_file_compression(za, idx, method, flags);
  }
#line 477
  if (__cil_tmp9 < 0) {
    {
#line 478
    __cil_tmp10 = zip_strerror(za);
#line 478
    fprintf(stderr, "can\'t set file compression method at index \'%lu\' to `%s\', flags `%d\': %s\n",
            idx, *(argv + 1), flags, __cil_tmp10);
    }
#line 479
    return (-1);
  }
#line 481
  return (0);
}
}
#line 485 "/root/libzip/src/ziptool.c"
static int set_file_mtime(int argc , char **argv ) 
{ 
  time_t mtime ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp5 ;
  unsigned long long __cil_tmp6 ;
  int __cil_tmp7 ;
  char const   *__cil_tmp8 ;

  {
  {
#line 489
  __cil_tmp5 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 489
  idx = (zip_uint64_t )__cil_tmp5;
#line 490
  __cil_tmp6 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 490
  mtime = (time_t )__cil_tmp6;
#line 491
  __cil_tmp7 = zip_file_set_mtime(za, idx, mtime, (zip_flags_t )0);
  }
#line 491
  if (__cil_tmp7 < 0) {
    {
#line 492
    __cil_tmp8 = zip_strerror(za);
#line 492
    fprintf(stderr, "can\'t set file mtime at index \'%lu\' to `%ld\': %s\n", idx,
            mtime, __cil_tmp8);
    }
#line 493
    return (-1);
  }
#line 495
  return (0);
}
}
#line 499 "/root/libzip/src/ziptool.c"
static int set_file_mtime_all(int argc , char **argv ) 
{ 
  time_t mtime ;
  zip_int64_t num_entries ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp6 ;
  char const   *__cil_tmp8 ;
  int __cil_tmp9 ;
  char const   *__cil_tmp10 ;

  {
  {
#line 504
  __cil_tmp6 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 504
  mtime = (time_t )__cil_tmp6;
#line 506
  num_entries = zip_get_num_entries(za, (zip_flags_t )0);
  }
#line 506
  if (num_entries < 0L) {
    {
#line 507
    __cil_tmp8 = zip_strerror(za);
#line 507
    fprintf(stderr, "can\'t get number of entries: %s\n\230", __cil_tmp8);
    }
#line 508
    return (-1);
  }
#line 510
  idx = (zip_uint64_t )0;
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;

#line 510
    if (! (idx < (zip_uint64_t )num_entries)) {
#line 510
      goto while_break;
    }
    {
#line 511
    __cil_tmp9 = zip_file_set_mtime(za, idx, mtime, (zip_flags_t )0);
    }
#line 511
    if (__cil_tmp9 < 0) {
      {
#line 512
      __cil_tmp10 = zip_strerror(za);
#line 512
      fprintf(stderr, "can\'t set file mtime at index \'%lu\' to `%ld\': %s\n", idx,
              mtime, __cil_tmp10);
      }
#line 513
      return (-1);
    }
#line 510
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 516
  return (0);
}
}
#line 520 "/root/libzip/src/ziptool.c"
static int set_password(int argc , char **argv ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 522
  __cil_tmp3 = zip_set_default_password(za, (char const   *)*(argv + 0));
  }
#line 522
  if (__cil_tmp3 < 0) {
    {
#line 523
    fprintf(stderr, "can\'t set default password to `%s\'", *(argv + 0));
    }
#line 524
    return (-1);
  }
#line 526
  return (0);
}
}
#line 530 "/root/libzip/src/ziptool.c"
static int zstat(int argc , char **argv ) 
{ 
  zip_uint64_t idx ;
  char buf[100] ;
  struct zip_stat sb ;
  unsigned long long __cil_tmp6 ;
  int __cil_tmp7 ;
  char const   *__cil_tmp8 ;
  struct tm *tpm ;

  {
  {
#line 534
  __cil_tmp6 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 534
  idx = (zip_uint64_t )__cil_tmp6;
#line 536
  __cil_tmp7 = zip_stat_index(za, idx, stat_flags, & sb);
  }
#line 536
  if (__cil_tmp7 < 0) {
    {
#line 537
    __cil_tmp8 = zip_strerror(za);
#line 537
    fprintf(stderr, "zip_stat_index failed on \'%lu\' failed: %s\n", idx, __cil_tmp8);
    }
#line 538
    return (-1);
  }
#line 541
  if (sb.valid & 1UL) {
    {
#line 542
    printf("name: \'%s\'\n", sb.name);
    }
  }
#line 543
  if (sb.valid & 2UL) {
    {
#line 544
    printf("index: \'%lu\'\n", sb.index);
    }
  }
#line 545
  if (sb.valid & 4UL) {
    {
#line 546
    printf("size: \'%lu\'\n\230\001", sb.size);
    }
  }
#line 547
  if (sb.valid & 8UL) {
    {
#line 548
    printf("compressed size: \'%lu\'\n", sb.comp_size);
    }
  }
#line 549
  if (sb.valid & 16UL) {
    {
#line 551
    tpm = localtime(& sb.mtime);
#line 552
    strftime(buf, sizeof(buf), "%a %b %d %Y %H:%M:%S", tpm);
#line 553
    printf("mtime: \'%s\'\n8V", buf);
    }
  }
#line 555
  if (sb.valid & 32UL) {
    {
#line 556
    printf("crc: \'%0x\'\n", sb.crc);
    }
  }
#line 557
  if (sb.valid & 64UL) {
    {
#line 558
    printf("compression method: \'%d\'\n", (int )sb.comp_method);
    }
  }
#line 559
  if (sb.valid & 128UL) {
    {
#line 560
    printf("encryption method: \'%d\'\n\230\001", (int )sb.encryption_method);
    }
  }
#line 561
  if (sb.valid & 256UL) {
    {
#line 562
    printf("flags: \'%ld\'\n", (long )sb.flags);
    }
  }
  {
#line 563
  printf("\n");
  }
#line 565
  return (0);
}
}
#line 569 "/root/libzip/src/ziptool.c"
static int unchange_all(int argc , char **argv ) 
{ 
  int __cil_tmp3 ;
  char const   *__cil_tmp4 ;

  {
  {
#line 570
  __cil_tmp3 = zip_unchange_all(za);
  }
#line 570
  if (__cil_tmp3 < 0) {
    {
#line 571
    __cil_tmp4 = zip_strerror(za);
#line 571
    fprintf(stderr, "can\'t revert changes to archive: %s\n", __cil_tmp4);
    }
#line 572
    return (-1);
  }
#line 574
  return (0);
}
}
#line 578 "/root/libzip/src/ziptool.c"
static int zin_close(int argc , char **argv ) 
{ 
  zip_uint64_t idx ;
  unsigned long long __cil_tmp4 ;
  int __cil_tmp5 ;
  char const   *__cil_tmp6 ;
  unsigned int __cil_tmp7 ;

  {
  {
#line 581
  __cil_tmp4 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 581
  idx = (zip_uint64_t )__cil_tmp4;
  }
#line 582
  if (idx >= (unsigned long )z_in_count) {
    {
#line 583
    fprintf(stderr, "invalid argument \'%lu\', only %d zip sources open\n", idx, z_in_count);
    }
#line 584
    return (-1);
  }
  {
#line 586
  __cil_tmp5 = zip_close(z_in[idx]);
  }
#line 586
  if (__cil_tmp5 < 0) {
    {
#line 587
    __cil_tmp6 = zip_strerror(z_in[idx]);
#line 587
    fprintf(stderr, "can\'t close source archive: %s\n", __cil_tmp6);
    }
#line 588
    return (-1);
  }
#line 590
  z_in[idx] = z_in[z_in_count];
#line 591
  __cil_tmp7 = z_in_count;
#line 591
  z_in_count --;
#line 593
  return (0);
}
}
#line 597 "/root/libzip/src/ziptool.c"
static zip_flags_t get_flags(char const   *arg ) 
{ 
  zip_flags_t flags ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp6 ;
  char *tmp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  char *__cil_tmp11 ;
  char *tmp___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  char *__cil_tmp16 ;
  char *tmp___1 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  char *__cil_tmp21 ;
  char *tmp___2 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  char *__cil_tmp26 ;
  char *tmp___3 ;

  {
  {
#line 599
  flags = (zip_flags_t )0;
#line 600
  __cil_tmp4 = 0;
#line 600
  __cil_tmp3 = 1;
#line 600
  __cil_tmp6 = __builtin_strchr((char *)arg, 'C');
#line 600
  tmp = __cil_tmp6;
  }
#line 600
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 601
    flags |= 1U;
  }
  {
#line 602
  __cil_tmp9 = 0;
#line 602
  __cil_tmp8 = 1;
#line 602
  __cil_tmp11 = __builtin_strchr((char *)arg, 'c');
#line 602
  tmp___0 = __cil_tmp11;
  }
#line 602
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 603
    flags |= 512U;
  }
  {
#line 604
  __cil_tmp14 = 0;
#line 604
  __cil_tmp13 = 1;
#line 604
  __cil_tmp16 = __builtin_strchr((char *)arg, 'd');
#line 604
  tmp___1 = __cil_tmp16;
  }
#line 604
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 605
    flags |= 2U;
  }
  {
#line 606
  __cil_tmp19 = 0;
#line 606
  __cil_tmp18 = 1;
#line 606
  __cil_tmp21 = __builtin_strchr((char *)arg, 'l');
#line 606
  tmp___2 = __cil_tmp21;
  }
#line 606
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 607
    flags |= 256U;
  }
  {
#line 608
  __cil_tmp24 = 0;
#line 608
  __cil_tmp23 = 1;
#line 608
  __cil_tmp26 = __builtin_strchr((char *)arg, 'u');
#line 608
  tmp___3 = __cil_tmp26;
  }
#line 608
  if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 609
    flags |= 8U;
  }
#line 610
  return (flags);
}
}
#line 614 "/root/libzip/src/ziptool.c"
static zip_int32_t get_compression_method(char const   *arg ) 
{ 


  {
#line 617
  return (-1);
#line 624
  return (0);
}
}
#line 628 "/root/libzip/src/ziptool.c"
static void hexdump(zip_uint8_t *data , zip_uint16_t len ) 
{ 
  zip_uint16_t i ;

  {
#line 632
  if ((int )len <= 0) {
#line 633
    return;
  }
  {
#line 635
  printf("0x");
#line 637
  i = (zip_uint16_t )0;
  }
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;

#line 637
    if (! ((int )i < (int )len)) {
#line 637
      goto while_break;
    }
    {
#line 638
    printf("%02x", (int )*(data + (int )i));
#line 637
    i = (zip_uint16_t )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 640
  return;
}
}
#line 645 "/root/libzip/src/ziptool.c"
static zip_t *read_hole(char const   *archive , int flags , int *err ) 
{ 
  zip_error_t error ;
  zip_source_t *src ;
  zip_t *zs ;
  int *__cil_tmp10 ;

  {
  {
#line 648
  src = (zip_source_t *)((void *)0);
#line 649
  zs = (zip_t *)((void *)0);
#line 651
  zip_error_init(& error);
#line 653
  zs = zip_open_from_source(src, flags, & error);
#line 653
  src = source_hole_create(archive, flags, & error);
  }
#line 653
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 655
    zip_source_free(src);
#line 656
    *err = zip_error_code_zip(& error);
#line 657
    __cil_tmp10 = __errno_location();
#line 657
    *__cil_tmp10 = zip_error_code_system(& error);
    }
  } else
#line 653
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
    {
#line 655
    zip_source_free(src);
#line 656
    *err = zip_error_code_zip(& error);
#line 657
    __cil_tmp10 = __errno_location();
#line 657
    *__cil_tmp10 = zip_error_code_system(& error);
    }
  }
#line 660
  return (zs);
}
}
#line 665 "/root/libzip/src/ziptool.c"
static zip_t *read_to_memory(char const   *archive , int flags , int *err , zip_source_t **srcp ) 
{ 
  struct stat st ;
  zip_source_t *src ;
  zip_t *zb ;
  zip_error_t error ;
  int __cil_tmp9 ;
  int *__cil_tmp10 ;
  char *buf ;
  FILE *fp ;
  unsigned long __cil_tmp16 ;
  int *__cil_tmp19 ;
  int *__cil_tmp23 ;
  void *tmp ;

  {
  {
#line 672
  __cil_tmp9 = stat(archive, & st);
  }
#line 672
  if (__cil_tmp9 < 0) {
    {
#line 673
    __cil_tmp10 = __errno_location();
    }
#line 673
    if (*__cil_tmp10 == 2) {
      {
#line 674
      src = zip_source_buffer_create((void const   *)((void *)0), (zip_uint64_t )0,
                                     0, & error);
      }
    } else {
#line 677
      *err = 11;
#line 678
      return ((zip_t *)((void *)0));
    }
  } else {
    {
#line 684
    tmp = malloc((size_t )st.st_size);
#line 684
    buf = (char *)tmp;
    }
#line 684
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 685
      *err = 14;
#line 686
      return ((zip_t *)((void *)0));
    }
    {
#line 688
    fp = fopen(archive, "r");
    }
#line 688
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 689
      free((void *)buf);
#line 690
      *err = 5;
      }
#line 691
      return ((zip_t *)((void *)0));
    }
    {
#line 693
    __cil_tmp16 = fread((void *)buf, (size_t )st.st_size, 1UL, fp);
    }
#line 693
    if (__cil_tmp16 < 1UL) {
      {
#line 694
      free((void *)buf);
#line 695
      fclose(fp);
#line 696
      *err = 5;
      }
#line 697
      return ((zip_t *)((void *)0));
    }
    {
#line 699
    fclose(fp);
#line 700
    src = zip_source_buffer_create((void const   *)buf, (zip_uint64_t )st.st_size,
                                   1, & error);
    }
#line 701
    if ((unsigned long )src == (unsigned long )((void *)0)) {
      {
#line 702
      free((void *)buf);
      }
    }
  }
#line 705
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 706
    *err = zip_error_code_zip(& error);
#line 707
    __cil_tmp19 = __errno_location();
#line 707
    *__cil_tmp19 = zip_error_code_system(& error);
    }
#line 708
    return ((zip_t *)((void *)0));
  }
  {
#line 710
  zb = zip_open_from_source(src, flags, & error);
  }
#line 711
  if ((unsigned long )zb == (unsigned long )((void *)0)) {
    {
#line 712
    *err = zip_error_code_zip(& error);
#line 713
    __cil_tmp23 = __errno_location();
#line 713
    *__cil_tmp23 = zip_error_code_system(& error);
#line 714
    zip_source_free(src);
    }
#line 715
    return ((zip_t *)((void *)0));
  }
  {
#line 717
  zip_source_keep(src);
#line 718
  *srcp = src;
  }
#line 719
  return (zb);
}
}
#line 730 "/root/libzip/src/ziptool.c"
static zip_int64_t source_nul_cb(void *ud , void *data , zip_uint64_t length , zip_source_cmd_t command ) 
{ 
  source_nul_t *ctx ;
  zip_int64_t __cil_tmp6 ;
  zip_stat_t *st ;
  zip_stat_t *tmp ;
  zip_int64_t __cil_tmp9 ;

  {
#line 732
  ctx = (source_nul_t *)ud;
#line 735
  if ((unsigned int )command == 2U) {
#line 735
    goto case_2;
  }
#line 738
  if ((unsigned int )command == 4U) {
#line 738
    goto case_4;
  }
#line 741
  if ((unsigned int )command == 5U) {
#line 741
    goto case_5;
  }
#line 745
  if ((unsigned int )command == 0U) {
#line 745
    goto case_0;
  }
#line 749
  if ((unsigned int )command == 1U) {
#line 749
    goto case_1;
  }
#line 763
  if ((unsigned int )command == 3U) {
#line 763
    goto case_3;
  }
#line 776
  if ((unsigned int )command == 14U) {
#line 776
    goto case_14;
  }
#line 779
  goto switch_default;
  case_2: 
#line 736
  return ((zip_int64_t )0);
  case_4: 
  {
#line 739
  __cil_tmp6 = zip_error_to_data(& ctx->error, data, length);
  }
#line 739
  return (__cil_tmp6);
  case_5: 
  {
#line 742
  free((void *)ctx);
  }
#line 743
  return ((zip_int64_t )0);
  case_0: 
#line 746
  ctx->offset = (zip_uint64_t )0;
#line 747
  return ((zip_int64_t )0);
  case_1: 
#line 750
  if (length > 0xffffffffffffffffUL) {
    {
#line 751
    zip_error_set(& ctx->error, 18, 0);
    }
#line 752
    return ((zip_int64_t )-1);
  }
#line 755
  if (length > ctx->length - ctx->offset) {
#line 756
    length = ctx->length - ctx->offset;
  }
  {
#line 759
  memset(data, 0, length);
#line 760
  ctx->offset += length;
  }
#line 761
  return ((zip_int64_t )length);
  case_3: 
#line 764
  if (length < sizeof(zip_stat_t )) {
    {
#line 764
    zip_error_set(& ctx->error, 18, 0);
#line 764
    tmp = (zip_stat_t *)((void *)0);
    }
  } else {
#line 764
    tmp = (zip_stat_t *)data;
  }
#line 764
  st = tmp;
#line 766
  if ((unsigned long )st == (unsigned long )((void *)0)) {
#line 767
    return ((zip_int64_t )-1);
  }
#line 770
  st->valid |= 4UL;
#line 771
  st->size = ctx->length;
#line 773
  return ((zip_int64_t )0);
  case_14: 
  {
#line 777
  __cil_tmp9 = zip_source_make_command_bitmap((zip_source_cmd_t )2, 4, 5, 0, 1, 3,
                                              -1);
  }
#line 777
  return (__cil_tmp9);
  switch_default: 
  {
#line 780
  zip_error_set(& ctx->error, 28, 0);
  }
#line 781
  return ((zip_int64_t )-1);

#line 785
  return (0L);
}
}
#line 786 "/root/libzip/src/ziptool.c"
static zip_source_t *source_nul(zip_t *zs , zip_uint64_t length ) 
{ 
  source_nul_t *ctx ;
  zip_source_t *src ;
  void *__cil_tmp5 ;
  zip_error_t *__cil_tmp6 ;

  {
  {
#line 791
  __cil_tmp5 = malloc(sizeof(*ctx));
#line 791
  ctx = (source_nul_t *)__cil_tmp5;
  }
#line 791
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 792
    __cil_tmp6 = zip_get_error(zs);
#line 792
    zip_error_set(__cil_tmp6, 14, 0);
    }
#line 793
    return ((zip_source_t *)((void *)0));
  }
  {
#line 796
  zip_error_init(& ctx->error);
#line 797
  ctx->length = length;
#line 798
  ctx->offset = (zip_uint64_t )0;
#line 800
  src = zip_source_function(zs, & source_nul_cb, (void *)ctx);
  }
#line 800
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 801
    free((void *)ctx);
    }
#line 802
    return ((zip_source_t *)((void *)0));
  }
#line 805
  return (src);
}
}
#line 810 "/root/libzip/src/ziptool.c"
static int write_memory_src_to_file(char const   *archive , zip_source_t *src ) 
{ 
  zip_stat_t zst ;
  char *buf ;
  FILE *fp ;
  int __cil_tmp6 ;
  zip_error_t *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  int __cil_tmp9 ;
  zip_error_t *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int *__cil_tmp13 ;
  int *__cil_tmp14 ;
  char *__cil_tmp15 ;
  zip_error_t *__cil_tmp16 ;
  char const   *__cil_tmp17 ;
  int *__cil_tmp19 ;
  char *__cil_tmp20 ;
  zip_int64_t __cil_tmp21 ;
  zip_error_t *__cil_tmp22 ;
  char const   *__cil_tmp23 ;
  int *__cil_tmp25 ;
  char *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int *__cil_tmp28 ;
  char *__cil_tmp29 ;
  int __cil_tmp30 ;
  int *__cil_tmp31 ;
  char *__cil_tmp32 ;
  void *tmp ;

  {
  {
#line 816
  __cil_tmp6 = zip_source_stat(src, & zst);
  }
#line 816
  if (__cil_tmp6 < 0) {
    {
#line 817
    __cil_tmp7 = zip_source_error(src);
#line 817
    __cil_tmp8 = zip_error_strerror(__cil_tmp7);
#line 817
    fprintf(stderr, "zip_source_stat on buffer failed: %s\nV", __cil_tmp8);
    }
#line 818
    return (-1);
  }
  {
#line 820
  __cil_tmp9 = zip_source_open(src);
  }
#line 820
  if (__cil_tmp9 < 0) {
    {
#line 821
    __cil_tmp10 = zip_source_error(src);
#line 821
    __cil_tmp11 = zip_error_code_zip(__cil_tmp10);
    }
#line 821
    if (__cil_tmp11 == 23) {
      {
#line 822
      __cil_tmp13 = __errno_location();
#line 822
      __cil_tmp12 = unlink(archive);
      }
#line 822
      if (__cil_tmp12 < 0) {
#line 822
        if (*__cil_tmp13 != 2) {
          {
#line 823
          __cil_tmp14 = __errno_location();
#line 823
          __cil_tmp15 = strerror(*__cil_tmp14);
#line 823
          fprintf(stderr, "unlink failed: %s\n", __cil_tmp15);
          }
#line 824
          return (-1);
        }
      }
#line 826
      return (0);
    }
    {
#line 828
    __cil_tmp16 = zip_source_error(src);
#line 828
    __cil_tmp17 = zip_error_strerror(__cil_tmp16);
#line 828
    fprintf(stderr, "zip_source_open on buffer failed: %s\nV", __cil_tmp17);
    }
#line 829
    return (-1);
  }
  {
#line 831
  tmp = malloc(zst.size);
#line 831
  buf = (char *)tmp;
  }
#line 831
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 832
    __cil_tmp19 = __errno_location();
#line 832
    __cil_tmp20 = strerror(*__cil_tmp19);
#line 832
    fprintf(stderr, "malloc failed: %s\n", __cil_tmp20);
#line 833
    zip_source_close(src);
    }
#line 834
    return (-1);
  }
  {
#line 836
  __cil_tmp21 = zip_source_read(src, (void *)buf, zst.size);
  }
#line 836
  if (__cil_tmp21 < (zip_int64_t )zst.size) {
    {
#line 837
    __cil_tmp22 = zip_source_error(src);
#line 837
    __cil_tmp23 = zip_error_strerror(__cil_tmp22);
#line 837
    fprintf(stderr, "zip_source_read on buffer failed: %s\nV", __cil_tmp23);
#line 838
    zip_source_close(src);
#line 839
    free((void *)buf);
    }
#line 840
    return (-1);
  }
  {
#line 842
  zip_source_close(src);
#line 843
  fp = fopen(archive, "wb\273Q8V");
  }
#line 843
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 844
    __cil_tmp25 = __errno_location();
#line 844
    __cil_tmp26 = strerror(*__cil_tmp25);
#line 844
    fprintf(stderr, "fopen failed: %s\n\260\273Q8V", __cil_tmp26);
#line 845
    free((void *)buf);
    }
#line 846
    return (-1);
  }
  {
#line 848
  __cil_tmp27 = fwrite((void const   *)buf, zst.size, 1UL, fp);
  }
#line 848
  if (__cil_tmp27 < 1UL) {
    {
#line 849
    __cil_tmp28 = __errno_location();
#line 849
    __cil_tmp29 = strerror(*__cil_tmp28);
#line 849
    fprintf(stderr, "fwrite failed: %s\n\273Q8V", __cil_tmp29);
#line 850
    free((void *)buf);
#line 851
    fclose(fp);
    }
#line 852
    return (-1);
  }
  {
#line 854
  free((void *)buf);
#line 855
  __cil_tmp30 = fclose(fp);
  }
#line 855
  if (__cil_tmp30 != 0) {
    {
#line 856
    __cil_tmp31 = __errno_location();
#line 856
    __cil_tmp32 = strerror(*__cil_tmp31);
#line 856
    fprintf(stderr, "fclose failed: %s\n\273Q8V", __cil_tmp32);
    }
#line 857
    return (-1);
  }
#line 859
  return (0);
}
}
#line 862 "/root/libzip/src/ziptool.c"
dispatch_table_t dispatch_table[29]  = 
#line 862
  {      {"addQ8V", 2, "name content8V", "add file called name using content\273Q8V",
      & add}, 
        {"add_dir", 1, "name8V", "add directoryV", & add_dir}, 
        {"add_file\251", 4, "name file_to_add offset lenQ8V", "add file to archive, len bytes starting from offsetQ8V",
      & add_file}, 
        {"add_from_zip8V", 5, "name archivename index offset lenJ\274Q8V", "add file from another archive, len bytes starting from offsetV",
      & add_from_zip}, 
        {"add_nul", 2, "name length", "add NUL bytesV", & add_nul}, 
        {"catQ8V", 1, "indexV", "output file contents to stdout", & cat}, 
        {"count_extraQ8V", 2, "index flags", "show number of extra fields for archive entryV",
      & count_extra}, 
        {"count_extra_by_id", 3, "index extra_id flags", "show number of extra fields of type extra_id for archive entry",
      & count_extra_by_id}, 
        {"delete", 1, "index", "remove entry8V", & delete}, 
        {"delete_extra8V", 3, "index extra_idx flagsV", "remove extra field\272Q8V",
      & delete_extra}, 
        {"delete_extra_by_id", 4, "index extra_id extra_index flags\001", "remove extra field of type extra_idQ8V",
      & delete_extra_by_id}, 
        {"get_archive_commentQ8V", 0, "\323\001 P\001", "show archive comment", & get_archive_comment}, 
        {"get_extra\302\273Q8V",
      3, "index extra_index flags", "show extra field\230", & get_extra}, 
        {"get_extra_by_id", 4, "index extra_id extra_index flags\323\001 ", "show extra field of type extra_id\301\273Q8V",
      & get_extra_by_id}, 
        {"get_file_comment\251", 1, "indexV", "get file comment\230", & get_file_comment}, 
        {"get_num_entries",
      1, "flags", "get number of entries in archive\230", & get_num_entries}, 
        {"name_locateQ8V", 2, "name flags\273Q8V", "find entry in archiveV", & name_locate}, 
        {"rename",
      2, "index name\273Q8V", "rename entry", & zrename}, 
        {"replace_file_contentsV", 2, "index data", "replace entry with data", & replace_file_contents}, 
        {"set_archive_commentQ8V",
      1, "comment", "set archive commentQ8V", & set_archive_comment}, 
        {"set_extra\274\273Q8V", 5, "index extra_id extra_index flags value", "set extra field",
      & set_extra}, 
        {"set_file_comment\251", 2, "index commentV", "set file comment\230", & set_file_comment}, 
        {"set_file_compression",
      3, "index method compression_flags", "set file compression methodQ8V", & set_file_compression}, 
        {"set_file_mtime",
      2, "index timestamp", "set file modification time", & set_file_mtime}, 
        {"set_file_mtime_all", 1, "timestamp\271\273Q8V", "set file modification time for all files\230",
      & set_file_mtime_all}, 
        {"set_password8V", 1, "password\323\001 P\001", "set default password for encryption",
      & set_password}, 
        {"stat", 1, "index", "print information about entryV", & zstat}, 
        {"unchange_all8V", 0, "\323\001 P\001", "revert all changes", & unchange_all}, 
        {"zin_close",
      1, "index", "close input zip_source (for internal tests)Q8V", & zin_close}};
#line 895 "/root/libzip/src/ziptool.c"
static int dispatch(int argc , char **argv ) 
{ 
  unsigned int i ;
  int __cil_tmp4 ;
  int __cil_tmp6 ;

  {
#line 898
  i = 0U;
  {
#line 898
  while (1) {
    while_continue: /* CIL Label */ ;

#line 898
    if (! ((unsigned long )i < sizeof(dispatch_table) / sizeof(dispatch_table_t ))) {
#line 898
      goto while_break;
    }
#line 900
    __cil_tmp4 = argc;
#line 900
    argc --;
#line 901
    argv ++;
#line 903
    if (argc < dispatch_table[i].argument_count) {
      {
#line 904
      fprintf(stderr, "not enough arguments for command \'%s\': %d available, %d needed\n",
              dispatch_table[i].cmdline_name, argc, dispatch_table[i].argument_count);
      }
#line 905
      return (-1);
    }
    {
#line 907
    __cil_tmp6 = (*(dispatch_table[i].function))(argc, argv);
    }
#line 907
    if (__cil_tmp6 == 0) {
#line 908
      return (1 + dispatch_table[i].argument_count);
    }
#line 909
    return (-1);
#line 898
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 913
  fprintf(stderr, "unknown command \'%s\'\nV", *(argv + 0));
  }
#line 914
  return (-1);
}
}
#line 919 "/root/libzip/src/ziptool.c"
static void usage(char const   *progname , char const   *reason ) 
{ 
  unsigned int i ;
  FILE *out ;

  {
#line 923
  if ((unsigned long )reason == (unsigned long )((void *)0)) {
#line 924
    out = stdout;
  } else {
#line 926
    out = stderr;
  }
  {
#line 927
  fprintf(out, "usage: %s [-cegHhmnrst] archive command1 [args] [command2 [args] ...]\n",
          progname);
  }
#line 928
  if ((unsigned long )reason != (unsigned long )((void *)0)) {
    {
#line 929
    fprintf(out, "%s\nQ8V", reason);
#line 930
    exit(1);
    }
  }
  {
#line 933
  fprintf(out, "\nSupported options are:\n\t-c\tcheck consistency\n\t-e\terror if archive already exists (only useful with -n)\n\t-g\tguess file name encoding (for stat)\n\t-H\twrite files with holes compactly\n\t-h\tdisplay this usage\n\t-m\tread archive into memory, and modify there; write out at end\n\t-n\tcreate archive if it doesn\'t exist\n\t-r\tprint raw file name encoding without translation (for stat)\n\t-s\tfollow file name convention strictly (for stat)\n\t-t\tdisregard current archive contents, if any\n");
#line 944
  fprintf(out, "\nSupported commands and arguments are:\n");
#line 945
  i = 0U;
  }
  {
#line 945
  while (1) {
    while_continue: /* CIL Label */ ;

#line 945
    if (! ((unsigned long )i < sizeof(dispatch_table) / sizeof(dispatch_table_t ))) {
#line 945
      goto while_break;
    }
    {
#line 946
    fprintf(out, "\t%s %s\n\t    %s\n\n\230\001", dispatch_table[i].cmdline_name,
            dispatch_table[i].arg_names, dispatch_table[i].description);
#line 945
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 948
  fprintf(out, "\nSupported flags are:\n\tC\tZIP_FL_NOCASE\n\tc\tZIP_FL_CENTRAL\n\td\tZIP_FL_NODIR\n\tl\tZIP_FL_LOCAL\n\tu\tZIP_FL_UNCHANGED\n\231\274Q8V");
#line 954
  fprintf(out, "\nSupported compression methods are:\n\tdefault\n\tdeflate\n\tstore\n");
#line 958
  fprintf(out, "\nThe index is zero-based.\n\274Q8V");
#line 959
  exit(0);
  }
}
}
#line 963 "/root/libzip/src/ziptool.c"
int main(int argc , char **argv ) 
{ 
  char const   *archive ;
  zip_source_t *memory_src ;
  unsigned int i ;
  int c ;
  int arg ;
  int err ;
  int flags ;
  char const   *prg ;
  source_type_t source_type ;
  char reason[128] ;
  int __cil_tmp14 ;
  zip_error_t error ;
  char const   *__cil_tmp19 ;
  int ret ;
  int __cil_tmp22 ;
  char const   *__cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;

  {
#line 970
  source_type = (source_type_t )0;
#line 972
  flags = 0;
#line 973
  prg = (char const   *)*(argv + 0);
#line 975
  if (argc < 2) {
    {
#line 976
    usage(prg, "too few argumentsq\274Q8V");
    }
  }
  {
#line 978
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 978
    c = getopt(argc, (char * const  *)argv, "cegHhmnrst");
    }
#line 978
    if (! (c != -1)) {
#line 978
      goto while_break;
    }
#line 980
    if (c == 99) {
#line 980
      goto case_99;
    }
#line 983
    if (c == 101) {
#line 983
      goto case_101;
    }
#line 986
    if (c == 103) {
#line 986
      goto case_103;
    }
#line 989
    if (c == 72) {
#line 989
      goto case_72;
    }
#line 992
    if (c == 104) {
#line 992
      goto case_104;
    }
#line 995
    if (c == 109) {
#line 995
      goto case_109;
    }
#line 998
    if (c == 110) {
#line 998
      goto case_110;
    }
#line 1001
    if (c == 114) {
#line 1001
      goto case_114;
    }
#line 1004
    if (c == 115) {
#line 1004
      goto case_115;
    }
#line 1007
    if (c == 116) {
#line 1007
      goto case_116;
    }
#line 1011
    goto switch_default;
    case_99: 
#line 981
    flags |= 4;
#line 982
    goto switch_break;
    case_101: 
#line 984
    flags |= 2;
#line 985
    goto switch_break;
    case_103: 
#line 987
    stat_flags = 0U;
#line 988
    goto switch_break;
    case_72: 
#line 990
    source_type = (source_type_t )2;
#line 991
    goto switch_break;
    case_104: 
    {
#line 993
    usage(prg, (char const   *)((void *)0));
    }
#line 994
    goto switch_break;
    case_109: 
#line 996
    source_type = (source_type_t )1;
#line 997
    goto switch_break;
    case_110: 
#line 999
    flags |= 1;
#line 1000
    goto switch_break;
    case_114: 
#line 1002
    stat_flags = 64U;
#line 1003
    goto switch_break;
    case_115: 
#line 1005
    stat_flags = 128U;
#line 1006
    goto switch_break;
    case_116: 
#line 1008
    flags |= 8;
#line 1009
    goto switch_break;
    switch_default: 
    {
#line 1014
    snprintf(reason, sizeof(reason), "invalid option -%c\274Q8V", optopt);
#line 1015
    usage(prg, (char const   *)(reason));
    }
    switch_break: ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 1020
  arg = optind;
#line 1022
  __cil_tmp14 = arg;
#line 1022
  arg ++;
#line 1022
  archive = (char const   *)*(argv + __cil_tmp14);
#line 1024
  if (flags == 0) {
#line 1025
    flags = 1;
  }
#line 1028
  if ((unsigned int )source_type == 0U) {
#line 1028
    goto case_0;
  }
#line 1032
  if ((unsigned int )source_type == 1U) {
#line 1032
    goto case_1;
  }
#line 1036
  if ((unsigned int )source_type == 2U) {
#line 1036
    goto case_2;
  }
#line 1027
  goto switch_break___0;
  case_0: 
  {
#line 1029
  za = zip_open(archive, flags, & err);
  }
#line 1030
  goto switch_break___0;
  case_1: 
  {
#line 1033
  za = read_to_memory(archive, flags, & err, & memory_src);
  }
#line 1034
  goto switch_break___0;
  case_2: 
  {
#line 1037
  za = read_hole(archive, flags, & err);
  }
#line 1038
  goto switch_break___0;
  switch_break___0: ;
#line 1041
  if ((unsigned long )za == (unsigned long )((void *)0)) {
    {
#line 1043
    zip_error_init_with_code(& error, err);
#line 1044
    __cil_tmp19 = zip_error_strerror(& error);
#line 1044
    fprintf(stderr, "can\'t open zip archive \'%s\': %s\n\230\001", archive, __cil_tmp19);
#line 1045
    zip_error_fini(& error);
    }
#line 1046
    return (1);
  }
#line 1049
  err = 0;
  {
#line 1050
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1050
    if (! (arg < argc)) {
#line 1050
      goto while_break___0;
    }
    {
#line 1052
    ret = dispatch(argc - arg, argv + arg);
    }
#line 1053
    if (ret > 0) {
#line 1054
      arg += ret;
    } else {
#line 1056
      err = 1;
#line 1057
      goto while_break___0;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 1061
  __cil_tmp22 = zip_close(za);
  }
#line 1061
  if (__cil_tmp22 == -1) {
    {
#line 1062
    __cil_tmp23 = zip_strerror(za);
#line 1062
    fprintf(stderr, "can\'t close zip archive \'%s\': %s\n", archive, __cil_tmp23);
    }
#line 1063
    return (1);
  }
#line 1065
  if ((unsigned int )source_type == 1U) {
    {
#line 1066
    __cil_tmp24 = write_memory_src_to_file(archive, memory_src);
    }
#line 1066
    if (__cil_tmp24 < 0) {
#line 1067
      err = 1;
    }
    {
#line 1069
    zip_source_free(memory_src);
    }
  }
#line 1072
  i = 0U;
  {
#line 1072
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 1072
    if (! (i < z_in_count)) {
#line 1072
      goto while_break___1;
    }
    {
#line 1073
    __cil_tmp25 = zip_close(z_in[i]);
    }
#line 1073
    if (__cil_tmp25 < 0) {
#line 1074
      err = 1;
    }
#line 1072
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: ;
#line 1078
  return (err);
}
}
#line 69 "/root/libzip/src/source_hole.c"
static void buffer_free___0(buffer_t___0 *buffer ) ;
#line 70
static buffer_t___0 *buffer_from_file(char const   *fname , int flags , zip_error_t *error ) ;
#line 71
static buffer_t___0 *buffer_new___0(void) ;
#line 72
static zip_int64_t buffer_read___0(buffer_t___0 *buffer , zip_uint8_t *data , zip_uint64_t length ,
                                   zip_error_t *error ) ;
#line 73
static int buffer_read_file(buffer_t___0 *buffer , FILE *f , zip_error_t *error ) ;
#line 74
static zip_int64_t buffer_seek___0(buffer_t___0 *buffer , void *data , zip_uint64_t length ,
                                   zip_error_t *error ) ;
#line 75
static int buffer_to_file(buffer_t___0 *buffer , char const   *fname , zip_error_t *error ) ;
#line 76
static zip_int64_t buffer_write___0(buffer_t___0 *buffer , zip_uint8_t *data , zip_uint64_t length ,
                                    zip_error_t *error ) ;
#line 77
static zip_uint64_t get_u64(zip_uint8_t *b ) ;
#line 78
static int only_nul(zip_uint8_t *data , zip_uint64_t length ) ;
#line 79
static int write_nuls(zip_uint64_t n , FILE *f ) ;
#line 80
static int write_u64(zip_uint64_t u64 , FILE *f ) ;
#line 90
static hole_t *hole_new(char const   *fname , int flags , zip_error_t *error ) ;
#line 91
static zip_int64_t source_hole_cb(void *ud , void *data , zip_uint64_t length , zip_source_cmd_t command ) ;
#line 94 "/root/libzip/src/source_hole.c"
zip_source_t *source_hole_create(char const   *fname , int flags , zip_error_t *error ) 
{ 
  hole_t *ud ;
  hole_t *__cil_tmp5 ;
  zip_source_t *__cil_tmp6 ;

  {
  {
#line 96
  __cil_tmp5 = hole_new(fname, flags, error);
#line 96
  ud = __cil_tmp5;
  }
#line 98
  if ((unsigned long )ud == (unsigned long )((void *)0)) {
#line 99
    return ((zip_source_t *)((void *)0));
  }
  {
#line 101
  __cil_tmp6 = zip_source_function_create(& source_hole_cb, (void *)ud, error);
  }
#line 101
  return (__cil_tmp6);
}
}
#line 106 "/root/libzip/src/source_hole.c"
static void buffer_free___0(buffer_t___0 *buffer ) 
{ 
  zip_uint64_t i ;

  {
#line 110
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 111
    return;
  }
#line 114
  if (buffer->fragment) {
#line 115
    i = (zip_uint64_t )0;
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;

#line 115
      if (! (i < buffer->nfragments)) {
#line 115
        goto while_break;
      }
      {
#line 116
      free((void *)*(buffer->fragment + i));
#line 115
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 118
    free((void *)buffer->fragment);
    }
  }
  {
#line 120
  free((void *)buffer);
  }
#line 122
  return;
}
}
#line 125 "/root/libzip/src/source_hole.c"
static buffer_t___0 *buffer_from_file(char const   *fname , int flags , zip_error_t *error ) 
{ 
  buffer_t___0 *buffer ;
  FILE *f ;
  int *__cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 130
  buffer = buffer_new___0();
  }
#line 130
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 131
    zip_error_set(error, 14, 0);
    }
#line 132
    return ((buffer_t___0 *)((void *)0));
  }
#line 136
  if ((flags & 8) == 0) {
    {
#line 137
    f = fopen(fname, "rb");
    }
#line 137
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 138
      __cil_tmp8 = __errno_location();
      }
#line 138
      if (*__cil_tmp8 == 2) {
#line 138
        if (! (flags & 1)) {
          {
#line 139
          buffer_free___0(buffer);
          }
#line 140
          return ((buffer_t___0 *)((void *)0));
        }
      } else {
        {
#line 139
        buffer_free___0(buffer);
        }
#line 140
        return ((buffer_t___0 *)((void *)0));
      }
    } else {
      {
#line 144
      __cil_tmp9 = buffer_read_file(buffer, f, error);
      }
#line 144
      if (__cil_tmp9 < 0) {
        {
#line 145
        buffer_free___0(buffer);
#line 146
        fclose(f);
        }
#line 147
        return ((buffer_t___0 *)((void *)0));
      }
      {
#line 149
      fclose(f);
      }
    }
  }
#line 153
  return (buffer);
}
}
#line 158 "/root/libzip/src/source_hole.c"
static buffer_t___0 *buffer_new___0(void) 
{ 
  buffer_t___0 *buffer ;
  void *__cil_tmp2 ;

  {
  {
#line 162
  __cil_tmp2 = malloc(sizeof(*buffer));
#line 162
  buffer = (buffer_t___0 *)__cil_tmp2;
  }
#line 162
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 163
    return ((buffer_t___0 *)((void *)0));
  }
#line 166
  buffer->fragment = (zip_uint8_t **)((void *)0);
#line 167
  buffer->nfragments = (zip_uint64_t )0;
#line 168
  buffer->fragment_size = (zip_uint64_t )8192;
#line 169
  buffer->size = (zip_uint64_t )0;
#line 170
  buffer->offset = (zip_uint64_t )0;
#line 172
  return (buffer);
}
}
#line 177 "/root/libzip/src/source_hole.c"
static zip_int64_t buffer_read___0(buffer_t___0 *buffer , zip_uint8_t *data , zip_uint64_t length ,
                                   zip_error_t *error ) 
{ 
  zip_uint64_t n ;
  zip_uint64_t i ;
  zip_uint64_t fragment_offset ;
  zip_uint64_t tmp ;
  zip_uint64_t left ;
  zip_uint64_t tmp___0 ;

  {
#line 181
  if (length < buffer->size - buffer->offset) {
#line 181
    tmp = length;
  } else {
#line 181
    tmp = buffer->size - buffer->offset;
  }
#line 181
  length = tmp;
#line 183
  if (length == 0UL) {
#line 184
    return ((zip_int64_t )0);
  }
#line 186
  if (length > 0xffffffffffffffffUL) {
#line 187
    return ((zip_int64_t )-1);
  }
#line 190
  i = buffer->offset / buffer->fragment_size;
#line 191
  fragment_offset = buffer->offset % buffer->fragment_size;
#line 192
  n = (zip_uint64_t )0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;

#line 193
    if (! (n < length)) {
#line 193
      goto while_break;
    }
#line 194
    if (length - n < buffer->fragment_size - fragment_offset) {
#line 194
      tmp___0 = length - n;
    } else {
#line 194
      tmp___0 = buffer->fragment_size - fragment_offset;
    }
#line 194
    left = tmp___0;
#line 196
    if (*(buffer->fragment + i)) {
      {
#line 197
      memcpy((void *)(data + n), (void const   *)(*(buffer->fragment + i) + fragment_offset),
             left);
      }
    } else {
      {
#line 200
      memset((void *)(data + n), 0, left);
      }
    }
#line 203
    n += left;
#line 204
    i ++;
#line 205
    fragment_offset = (zip_uint64_t )0;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 208
  buffer->offset += n;
#line 209
  return ((zip_int64_t )n);
}
}
#line 214 "/root/libzip/src/source_hole.c"
static int buffer_read_file(buffer_t___0 *buffer , FILE *f , zip_error_t *error ) 
{ 
  zip_uint8_t b[20] ;
  zip_uint64_t i ;
  unsigned long __cil_tmp6 ;
  int *__cil_tmp7 ;
  int __cil_tmp8 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp13 ;
  int *__cil_tmp14 ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int *__cil_tmp18 ;
  int __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  int *__cil_tmp22 ;
  zip_uint64_t __cil_tmp23 ;

  {
  {
#line 219
  __cil_tmp6 = fread((void *)(b), 20UL, 1UL, f);
  }
#line 219
  if (__cil_tmp6 != 1UL) {
    {
#line 220
    __cil_tmp7 = __errno_location();
#line 220
    zip_error_set(error, 5, *__cil_tmp7);
    }
#line 221
    return (-1);
  }
  {
#line 224
  __cil_tmp8 = memcmp((void const   *)(b), (void const   *)"NiH08V", 4UL);
  }
#line 224
  if (__cil_tmp8 != 0) {
    {
#line 225
    zip_error_set(error, 5, 22);
    }
#line 226
    return (-1);
  }
  {
#line 229
  buffer->fragment_size = get_u64(b + 4);
#line 230
  buffer->size = get_u64(b + 12);
  }
#line 232
  if (buffer->size + buffer->fragment_size < buffer->size) {
    {
#line 233
    zip_error_set(error, 14, 0);
    }
#line 234
    return (-1);
  }
  {
#line 236
  buffer->nfragments = ((buffer->size + buffer->fragment_size) - 1UL) / buffer->fragment_size;
#line 237
  __cil_tmp11 = malloc(sizeof(*(buffer->fragment + 0)) * buffer->nfragments);
#line 237
  buffer->fragment = (zip_uint8_t **)__cil_tmp11;
  }
#line 237
  if ((unsigned long )buffer->fragment == (unsigned long )((void *)0)) {
    {
#line 239
    zip_error_set(error, 14, 0);
    }
#line 240
    return (-1);
  } else
#line 237
  if (buffer->nfragments > 0xffffffffffffffffUL / sizeof(*(buffer->fragment + 0))) {
    {
#line 239
    zip_error_set(error, 14, 0);
    }
#line 240
    return (-1);
  }
#line 243
  i = (zip_uint64_t )0;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;

#line 243
    if (! (i < buffer->nfragments)) {
#line 243
      goto while_break;
    }
#line 244
    *(buffer->fragment + i) = (zip_uint8_t *)((void *)0);
#line 243
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 247
  i = (zip_uint64_t )0;
  {
#line 248
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 248
    if (! (i < buffer->nfragments)) {
#line 248
      goto while_break___0;
    }
    {
#line 249
    __cil_tmp13 = fread((void *)(b), 4UL, 1UL, f);
    }
#line 249
    if (__cil_tmp13 != 1UL) {
      {
#line 250
      __cil_tmp14 = __errno_location();
#line 250
      zip_error_set(error, 5, *__cil_tmp14);
      }
#line 251
      return (-1);
    }
    {
#line 254
    __cil_tmp15 = memcmp((void const   *)(b), (void const   *)"NiH1", 4UL);
    }
#line 254
    if (__cil_tmp15 == 0) {
#line 255
      if (buffer->fragment_size > 0xffffffffffffffffUL) {
        {
#line 256
        zip_error_set(error, 14, 0);
        }
#line 257
        return (-1);
      }
      {
#line 259
      __cil_tmp16 = malloc(buffer->fragment_size);
#line 259
      *(buffer->fragment + i) = (zip_uint8_t *)__cil_tmp16;
      }
#line 259
      if ((unsigned long )*(buffer->fragment + i) == (unsigned long )((void *)0)) {
        {
#line 260
        zip_error_set(error, 14, 0);
        }
#line 261
        return (-1);
      }
      {
#line 263
      __cil_tmp17 = fread((void *)*(buffer->fragment + i), buffer->fragment_size,
                          1UL, f);
      }
#line 263
      if (__cil_tmp17 != 1UL) {
        {
#line 264
        __cil_tmp18 = __errno_location();
#line 264
        zip_error_set(error, 5, *__cil_tmp18);
        }
#line 265
        return (-1);
      }
#line 267
      i ++;
    } else {
      {
#line 269
      __cil_tmp20 = memcmp((void const   *)(b), (void const   *)"NiH2", 4UL);
      }
#line 269
      if (__cil_tmp20 == 0) {
        {
#line 270
        __cil_tmp21 = fread((void *)(b), 8UL, 1UL, f);
        }
#line 270
        if (__cil_tmp21 != 1UL) {
          {
#line 271
          __cil_tmp22 = __errno_location();
#line 271
          zip_error_set(error, 5, *__cil_tmp22);
          }
#line 272
          return (-1);
        }
        {
#line 274
        __cil_tmp23 = get_u64(b);
#line 274
        i += __cil_tmp23;
        }
      } else {
        {
#line 277
        zip_error_set(error, 5, 22);
        }
#line 278
        return (-1);
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 282
  return (0);
}
}
#line 286 "/root/libzip/src/source_hole.c"
static zip_int64_t buffer_seek___0(buffer_t___0 *buffer , void *data , zip_uint64_t length ,
                                   zip_error_t *error ) 
{ 
  zip_int64_t new_offset ;
  zip_int64_t __cil_tmp6 ;

  {
  {
#line 288
  __cil_tmp6 = zip_source_seek_compute_offset(buffer->offset, buffer->size, data,
                                              length, error);
#line 288
  new_offset = __cil_tmp6;
  }
#line 290
  if (new_offset < 0L) {
#line 291
    return ((zip_int64_t )-1);
  }
#line 294
  buffer->offset = (zip_uint64_t )new_offset;
#line 295
  return ((zip_int64_t )0);
}
}
#line 300 "/root/libzip/src/source_hole.c"
static int buffer_to_file(buffer_t___0 *buffer , char const   *fname , zip_error_t *error ) 
{ 
  FILE *f ;
  FILE *__cil_tmp5 ;
  zip_uint64_t i ;
  zip_uint64_t nul_run ;
  int *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp12 ;
  int *__cil_tmp13 ;

  {
  {
#line 302
  __cil_tmp5 = fopen(fname, "wb\324Q8V");
#line 302
  f = __cil_tmp5;
  }
#line 306
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 307
    __cil_tmp8 = __errno_location();
#line 307
    zip_error_set(error, 11, *__cil_tmp8);
    }
#line 308
    return (-1);
  }
  {
#line 311
  fwrite((void const   *)"NiH08V", 4UL, 1UL, f);
#line 312
  write_u64(buffer->fragment_size, f);
#line 313
  write_u64(buffer->size, f);
#line 315
  nul_run = (zip_uint64_t )0;
#line 316
  i = (zip_uint64_t )0;
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;

#line 316
    if (! (i * buffer->fragment_size < buffer->size)) {
#line 316
      goto while_break;
    }
    {
#line 317
    __cil_tmp9 = only_nul(*(buffer->fragment + i), buffer->fragment_size);
    }
#line 317
    if ((unsigned long )*(buffer->fragment + i) == (unsigned long )((void *)0)) {
#line 318
      nul_run ++;
    } else
#line 317
    if (__cil_tmp9) {
#line 318
      nul_run ++;
    } else {
#line 321
      if (nul_run > 0UL) {
        {
#line 322
        write_nuls(nul_run, f);
#line 323
        nul_run = (zip_uint64_t )0;
        }
      }
      {
#line 325
      fwrite((void const   *)"NiH1", 4UL, 1UL, f);
#line 327
      fwrite((void const   *)*(buffer->fragment + i), 1UL, buffer->fragment_size,
             f);
      }
    }
#line 316
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 331
  if (nul_run > 0UL) {
    {
#line 332
    write_nuls(nul_run, f);
    }
  }
  {
#line 335
  __cil_tmp12 = fclose(f);
  }
#line 335
  if (__cil_tmp12 != 0) {
    {
#line 336
    __cil_tmp13 = __errno_location();
#line 336
    zip_error_set(error, 6, *__cil_tmp13);
    }
#line 337
    return (-1);
  }
#line 340
  return (0);
}
}
#line 345 "/root/libzip/src/source_hole.c"
static zip_int64_t buffer_write___0(buffer_t___0 *buffer , zip_uint8_t *data , zip_uint64_t length ,
                                    zip_error_t *error ) 
{ 
  zip_uint8_t **fragment ;
  zip_uint64_t needed_fragments ;
  zip_uint64_t new_capacity ;
  zip_uint64_t i ;
  int __cil_tmp11 ;
  zip_uint64_t idx ;
  zip_uint64_t n ;
  zip_uint64_t fragment_offset ;
  zip_uint64_t left ;
  zip_uint64_t tmp ;
  void *__cil_tmp17 ;
  void *tmp___0 ;

  {
#line 348
  if (buffer->offset + length > buffer->nfragments * buffer->fragment_size) {
#line 349
    needed_fragments = (((buffer->offset + length) + buffer->fragment_size) - 1UL) / buffer->fragment_size;
#line 350
    new_capacity = buffer->nfragments;
#line 353
    if (new_capacity == 0UL) {
#line 354
      new_capacity = (zip_uint64_t )4;
    }
    {
#line 356
    while (1) {
      while_continue: /* CIL Label */ ;

#line 356
      if (! (new_capacity < needed_fragments)) {
#line 356
        goto while_break;
      }
#line 357
      new_capacity *= 2UL;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: 
    {
#line 360
    tmp___0 = realloc((void *)buffer->fragment, new_capacity * sizeof(*fragment));
#line 360
    fragment = (zip_uint8_t **)tmp___0;
    }
#line 362
    if ((unsigned long )fragment == (unsigned long )((void *)0)) {
      {
#line 363
      zip_error_set(error, 14, 0);
      }
#line 364
      return ((zip_int64_t )-1);
    }
#line 367
    i = buffer->nfragments;
    {
#line 367
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 367
      if (! (i < new_capacity)) {
#line 367
        goto while_break___0;
      }
#line 368
      *(fragment + i) = (zip_uint8_t *)((void *)0);
#line 367
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 371
    buffer->fragment = fragment;
#line 372
    buffer->nfragments = new_capacity;
  }
  {
#line 375
  __cil_tmp11 = only_nul(data, length);
  }
#line 375
  if (! __cil_tmp11) {
#line 378
    idx = buffer->offset / buffer->fragment_size;
#line 379
    fragment_offset = buffer->offset % buffer->fragment_size;
#line 380
    n = (zip_uint64_t )0;
    {
#line 382
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 382
      if (! (n < length)) {
#line 382
        goto while_break___1;
      }
#line 383
      if (length - n < buffer->fragment_size - fragment_offset) {
#line 383
        tmp = length - n;
      } else {
#line 383
        tmp = buffer->fragment_size - fragment_offset;
      }
#line 383
      left = tmp;
#line 385
      if ((unsigned long )*(buffer->fragment + idx) == (unsigned long )((void *)0)) {
        {
#line 386
        __cil_tmp17 = malloc(buffer->fragment_size);
#line 386
        *(buffer->fragment + idx) = (zip_uint8_t *)__cil_tmp17;
        }
#line 386
        if ((unsigned long )*(buffer->fragment + idx) == (unsigned long )((void *)0)) {
          {
#line 387
          zip_error_set(error, 14, 0);
          }
#line 388
          return ((zip_int64_t )-1);
        }
        {
#line 390
        memset((void *)*(buffer->fragment + idx), 0, buffer->fragment_size);
        }
      }
      {
#line 392
      memcpy((void *)(*(buffer->fragment + idx) + fragment_offset), (void const   *)(data + n),
             left);
#line 394
      n += left;
#line 395
      idx ++;
#line 396
      fragment_offset = (zip_uint64_t )0;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 400
  buffer->offset += length;
#line 401
  if (buffer->offset > buffer->size) {
#line 402
    buffer->size = buffer->offset;
  }
#line 405
  return ((zip_int64_t )length);
}
}
#line 410 "/root/libzip/src/source_hole.c"
static zip_uint64_t get_u64(zip_uint8_t *b ) 
{ 
  zip_uint64_t i ;

  {
#line 414
  i = ((((((((zip_uint64_t )*(b + 0) << 56) | ((zip_uint64_t )*(b + 1) << 48)) | ((zip_uint64_t )*(b + 2) << 40)) | ((zip_uint64_t )*(b + 3) << 32)) | ((zip_uint64_t )*(b + 4) << 24)) | ((zip_uint64_t )*(b + 5) << 16)) | ((zip_uint64_t )*(b + 6) << 8)) | (zip_uint64_t )*(b + 7);
#line 416
  return (i);
}
}
#line 421 "/root/libzip/src/source_hole.c"
static int only_nul(zip_uint8_t *data , zip_uint64_t length ) 
{ 
  zip_uint64_t i ;

  {
#line 425
  i = (zip_uint64_t )0;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;

#line 425
    if (! (i < length)) {
#line 425
      goto while_break;
    }
#line 426
    if ((int )*(data + i) != 0) {
#line 427
      return (0);
    }
#line 425
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 431
  return (1);
}
}
#line 436 "/root/libzip/src/source_hole.c"
static int write_nuls(zip_uint64_t n , FILE *f ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 438
  __cil_tmp3 = fwrite((void const   *)"NiH28V", 4UL, 1UL, f);
  }
#line 438
  if (__cil_tmp3 != 1UL) {
#line 439
    return (-1);
  }
  {
#line 441
  __cil_tmp4 = write_u64(n, f);
  }
#line 441
  return (__cil_tmp4);
}
}
#line 446 "/root/libzip/src/source_hole.c"
static int write_u64(zip_uint64_t u64 , FILE *f ) 
{ 
  zip_uint8_t b[8] ;
  unsigned long __cil_tmp4 ;
  int tmp ;

  {
  {
#line 450
  b[0] = (zip_uint8_t )((u64 >> 56) & 255UL);
#line 451
  b[1] = (zip_uint8_t )((u64 >> 48) & 255UL);
#line 452
  b[2] = (zip_uint8_t )((u64 >> 40) & 255UL);
#line 453
  b[3] = (zip_uint8_t )((u64 >> 32) & 255UL);
#line 454
  b[4] = (zip_uint8_t )((u64 >> 24) & 255UL);
#line 455
  b[5] = (zip_uint8_t )((u64 >> 16) & 255UL);
#line 456
  b[6] = (zip_uint8_t )((u64 >> 8) & 255UL);
#line 457
  b[7] = (zip_uint8_t )(u64 & 255UL);
#line 459
  __cil_tmp4 = fwrite((void const   *)(b), 8UL, 1UL, f);
  }
#line 459
  if (__cil_tmp4 == 1UL) {
#line 459
    tmp = 0;
  } else {
#line 459
    tmp = -1;
  }
#line 459
  return (tmp);
}
}
#line 464 "/root/libzip/src/source_hole.c"
static void hole_free(hole_t *hole ) 
{ 


  {
#line 465
  if ((unsigned long )hole == (unsigned long )((void *)0)) {
#line 466
    return;
  }
  {
#line 468
  zip_error_fini(& hole->error);
#line 469
  buffer_free___0(hole->in);
#line 470
  buffer_free___0(hole->out);
#line 471
  free((void *)hole->fname);
#line 472
  free((void *)hole);
  }
#line 474
  return;
}
}
#line 477 "/root/libzip/src/source_hole.c"
static hole_t *hole_new(char const   *fname , int flags , zip_error_t *error ) 
{ 
  hole_t *ctx ;
  void *__cil_tmp5 ;
  int __cil_tmp6 ;
  void *__cil_tmp7 ;
  char *tmp ;
  char *__cil_tmp9 ;
  int tmp___0 ;

  {
  {
#line 479
  __cil_tmp5 = malloc(sizeof(*ctx));
#line 479
  ctx = (hole_t *)__cil_tmp5;
  }
#line 481
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 482
    zip_error_set(error, 14, 0);
    }
#line 483
    return ((hole_t *)((void *)0));
  }
#line 486
  __cil_tmp6 = 0;
#line 486
  if (__cil_tmp6) {
#line 486
    if ((size_t )((void const   *)(fname + 1)) - (size_t )((void const   *)fname) == 1UL) {
#line 486
      if ((int )*(fname + 0) == 0) {
        {
#line 486
        __cil_tmp7 = calloc((size_t )1, (size_t )1);
#line 486
        tmp = (char *)__cil_tmp7;
        }
      } else {
#line 486
        tmp = (char *)0;
      }
#line 486
      tmp___0 = (int )tmp;
    } else {
      {
#line 486
      __cil_tmp9 = __strdup(fname);
#line 486
      tmp___0 = (int )__cil_tmp9;
      }
    }
  } else {
    {
#line 486
    __cil_tmp9 = __strdup(fname);
#line 486
    tmp___0 = (int )__cil_tmp9;
    }
  }
#line 486
  ctx->fname = (char *)tmp___0;
#line 486
  if ((unsigned long )ctx->fname == (unsigned long )((void *)0)) {
    {
#line 487
    free((void *)ctx);
#line 488
    zip_error_set(error, 14, 0);
    }
#line 489
    return ((hole_t *)((void *)0));
  }
  {
#line 492
  ctx->in = buffer_from_file(fname, flags, error);
  }
#line 492
  if ((unsigned long )ctx->in == (unsigned long )((void *)0)) {
    {
#line 493
    free((void *)ctx);
    }
#line 494
    return ((hole_t *)((void *)0));
  }
  {
#line 497
  zip_error_init(& ctx->error);
#line 498
  ctx->out = (buffer_t___0 *)((void *)0);
  }
#line 500
  return (ctx);
}
}
#line 505 "/root/libzip/src/source_hole.c"
static zip_int64_t source_hole_cb(void *ud , void *data , zip_uint64_t length , zip_source_cmd_t command ) 
{ 
  hole_t *ctx ;
  int __cil_tmp7 ;
  zip_int64_t __cil_tmp8 ;
  zip_int64_t __cil_tmp9 ;
  zip_int64_t __cil_tmp11 ;
  zip_int64_t __cil_tmp12 ;
  zip_stat_t *st ;
  zip_stat_t *tmp ;
  zip_int64_t __cil_tmp15 ;
  zip_int64_t __cil_tmp16 ;

  {
#line 507
  ctx = (hole_t *)ud;
#line 510
  if ((unsigned int )command == 8U) {
#line 510
    goto case_8;
  }
#line 514
  if ((unsigned int )command == 2U) {
#line 514
    goto case_2;
  }
#line 517
  if ((unsigned int )command == 9U) {
#line 517
    goto case_9;
  }
#line 526
  if ((unsigned int )command == 4U) {
#line 526
    goto case_4;
  }
#line 529
  if ((unsigned int )command == 5U) {
#line 529
    goto case_5;
  }
#line 533
  if ((unsigned int )command == 0U) {
#line 533
    goto case_0;
  }
#line 537
  if ((unsigned int )command == 1U) {
#line 537
    goto case_1;
  }
#line 540
  if ((unsigned int )command == 15U) {
#line 540
    goto case_15;
  }
#line 548
  if ((unsigned int )command == 10U) {
#line 548
    goto case_10;
  }
#line 553
  if ((unsigned int )command == 6U) {
#line 553
    goto case_6;
  }
#line 556
  if ((unsigned int )command == 12U) {
#line 556
    goto case_12;
  }
#line 559
  if ((unsigned int )command == 3U) {
#line 559
    goto case_3;
  }
#line 573
  if ((unsigned int )command == 7U) {
#line 573
    goto case_7;
  }
#line 576
  if ((unsigned int )command == 13U) {
#line 576
    goto case_13;
  }
#line 579
  if ((unsigned int )command == 11U) {
#line 579
    goto case_11;
  }
#line 582
  if ((unsigned int )command == 14U) {
#line 582
    goto case_14;
  }
#line 585
  goto switch_default;
  case_8: 
  {
#line 511
  ctx->out = buffer_new___0();
  }
#line 512
  return ((zip_int64_t )0);
  case_2: 
#line 515
  return ((zip_int64_t )0);
  case_9: 
  {
#line 518
  __cil_tmp7 = buffer_to_file(ctx->out, (char const   *)ctx->fname, & ctx->error);
  }
#line 518
  if (__cil_tmp7 < 0) {
#line 519
    return ((zip_int64_t )-1);
  }
  {
#line 521
  buffer_free___0(ctx->in);
#line 522
  ctx->in = ctx->out;
#line 523
  ctx->out = (buffer_t___0 *)((void *)0);
  }
#line 524
  return ((zip_int64_t )0);
  case_4: 
  {
#line 527
  __cil_tmp8 = zip_error_to_data(& ctx->error, data, length);
  }
#line 527
  return (__cil_tmp8);
  case_5: 
  {
#line 530
  hole_free(ctx);
  }
#line 531
  return ((zip_int64_t )0);
  case_0: 
#line 534
  (ctx->in)->offset = (zip_uint64_t )0;
#line 535
  return ((zip_int64_t )0);
  case_1: 
  {
#line 538
  __cil_tmp9 = buffer_read___0(ctx->in, (zip_uint8_t *)data, length, & ctx->error);
  }
#line 538
  return (__cil_tmp9);
  case_15: 
  {
#line 541
  buffer_free___0(ctx->in);
#line 542
  ctx->in = buffer_new___0();
#line 543
  buffer_free___0(ctx->out);
#line 544
  ctx->out = (buffer_t___0 *)((void *)0);
#line 545
  remove((char const   *)ctx->fname);
  }
#line 546
  return ((zip_int64_t )0);
  case_10: 
  {
#line 549
  buffer_free___0(ctx->out);
#line 550
  ctx->out = (buffer_t___0 *)((void *)0);
  }
#line 551
  return ((zip_int64_t )0);
  case_6: 
  {
#line 554
  __cil_tmp11 = buffer_seek___0(ctx->in, data, length, & ctx->error);
  }
#line 554
  return (__cil_tmp11);
  case_12: 
  {
#line 557
  __cil_tmp12 = buffer_seek___0(ctx->out, data, length, & ctx->error);
  }
#line 557
  return (__cil_tmp12);
  case_3: 
#line 560
  if (length < sizeof(zip_stat_t )) {
    {
#line 560
    zip_error_set(& ctx->error, 18, 0);
#line 560
    tmp = (zip_stat_t *)((void *)0);
    }
  } else {
#line 560
    tmp = (zip_stat_t *)data;
  }
#line 560
  st = tmp;
#line 562
  if ((unsigned long )st == (unsigned long )((void *)0)) {
#line 563
    return ((zip_int64_t )-1);
  }
#line 568
  st->valid |= 4UL;
#line 569
  st->size = (ctx->in)->size;
#line 570
  return ((zip_int64_t )0);
  case_7: 
#line 574
  return ((zip_int64_t )(ctx->in)->offset);
  case_13: 
#line 577
  return ((zip_int64_t )(ctx->out)->offset);
  case_11: 
  {
#line 580
  __cil_tmp15 = buffer_write___0(ctx->out, (zip_uint8_t *)data, length, & ctx->error);
  }
#line 580
  return (__cil_tmp15);
  case_14: 
  {
#line 583
  __cil_tmp16 = zip_source_make_command_bitmap((zip_source_cmd_t )8, 9, 2, 4, 5, 0,
                                               1, 15, 10, 6, 12, 3, 7, 13, 11, -1);
  }
#line 583
  return (__cil_tmp16);
  switch_default: 
  {
#line 586
  zip_error_set(& ctx->error, 28, 0);
  }
#line 587
  return ((zip_int64_t )-1);

#line 591
  return (0L);
}
}
