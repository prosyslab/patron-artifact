/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 216 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef unsigned long size_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 63 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef int opj_bool;
#line 99
enum RSIZ_CAPABILITIES {
    STD_RSIZ = 0,
    CINEMA2K = 3,
    CINEMA4K = 4
} ;
#line 103 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef enum RSIZ_CAPABILITIES OPJ_RSIZ_CAPABILITIES;
#line 108
enum CINEMA_MODE {
    OFF = 0,
    CINEMA2K_24 = 1,
    CINEMA2K_48 = 2,
    CINEMA4K_24 = 3
} ;
#line 113 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef enum CINEMA_MODE OPJ_CINEMA_MODE;
#line 118
enum PROG_ORDER {
    PROG_UNKNOWN = -1,
    LRCP = 0,
    RLCP = 1,
    RPCL = 2,
    PCRL = 3,
    CPRL = 4
} ;
#line 125 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef enum PROG_ORDER OPJ_PROG_ORDER;
#line 130
enum COLOR_SPACE {
    CLRSPC_UNKNOWN = -1,
    CLRSPC_UNSPECIFIED = 0,
    CLRSPC_SRGB = 1,
    CLRSPC_GRAY = 2,
    CLRSPC_SYCC = 3
} ;
#line 136 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef enum COLOR_SPACE OPJ_COLOR_SPACE;
#line 145
enum CODEC_FORMAT {
    CODEC_UNKNOWN = -1,
    CODEC_J2K = 0,
    CODEC_JPT = 1,
    CODEC_JP2 = 2
} ;
#line 150 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef enum CODEC_FORMAT OPJ_CODEC_FORMAT;
#line 155
enum LIMIT_DECODING {
    NO_LIMITATION = 0,
    LIMIT_TO_MAIN_HEADER = 1,
    DECODE_ALL_BUT_PACKETS = 2
} ;
#line 159 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef enum LIMIT_DECODING OPJ_LIMIT_DECODING;
#line 183 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_event_mgr {
   void (*error_handler)(char const   * , void * ) ;
   void (*warning_handler)(char const   * , void * ) ;
   void (*info_handler)(char const   * , void * ) ;
};
#line 190 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_event_mgr opj_event_mgr_t;
#line 202 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_poc {
   int resno0 ;
   int compno0 ;
   int layno1 ;
   int resno1 ;
   int compno1 ;
   int layno0 ;
   int precno0 ;
   int precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   char progorder[5] ;
   int tile ;
   int tx0 ;
   int tx1 ;
   int ty0 ;
   int ty1 ;
   int layS ;
   int resS ;
   int compS ;
   int prcS ;
   int layE ;
   int resE ;
   int compE ;
   int prcE ;
   int txS ;
   int txE ;
   int tyS ;
   int tyE ;
   int dx ;
   int dy ;
   int lay_t ;
   int res_t ;
   int comp_t ;
   int prc_t ;
   int tx0_t ;
   int ty0_t ;
};
#line 225 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_poc opj_poc_t;
#line 230 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_cparameters {
   opj_bool tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t POC[32] ;
   int numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   opj_bool jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
   opj_bool jpip_on ;
};
#line 356 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_cparameters opj_cparameters_t;
#line 363 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_dparameters {
   int cp_reduce ;
   int cp_layer ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   opj_bool jpwl_correct ;
   int jpwl_exp_comps ;
   int jpwl_max_tiles ;
   OPJ_LIMIT_DECODING cp_limit_decoding ;
   unsigned int flags ;
};
#line 413 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_dparameters opj_dparameters_t;
#line 430 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_common_struct {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 436 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_common_struct opj_common_struct_t;
#line 438 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef opj_common_struct_t *opj_common_ptr;
#line 443 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_cinfo {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 447 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_cinfo opj_cinfo_t;
#line 452 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_dinfo {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 456 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_dinfo opj_dinfo_t;
#line 475 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_cio {
   opj_common_ptr cinfo ;
   int openmode ;
   unsigned char *buffer ;
   int length ;
   unsigned char *start ;
   unsigned char *end ;
   unsigned char *bp ;
};
#line 492 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_cio opj_cio_t;
#line 503 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_image_comp {
   int dx ;
   int dy ;
   int w ;
   int h ;
   int x0 ;
   int y0 ;
   int prec ;
   int bpp ;
   int sgnd ;
   int resno_decoded ;
   int factor ;
   int *data ;
};
#line 528 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_image_comp opj_image_comp_t;
#line 533 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_image {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numcomps ;
   OPJ_COLOR_SPACE color_space ;
   opj_image_comp_t *comps ;
   unsigned char *icc_profile_buf ;
   int icc_profile_len ;
};
#line 552 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_image opj_image_t;
#line 557 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_image_comptparm {
   int dx ;
   int dy ;
   int w ;
   int h ;
   int x0 ;
   int y0 ;
   int prec ;
   int bpp ;
   int sgnd ;
};
#line 576 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_image_comptparm opj_image_cmptparm_t;
#line 587 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_packet_info {
   int start_pos ;
   int end_ph_pos ;
   int end_pos ;
   double disto ;
};
#line 596 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_packet_info opj_packet_info_t;
#line 603 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_marker_info_t {
   unsigned short type ;
   int pos ;
   int len ;
};
#line 610 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_marker_info_t opj_marker_info_t;
#line 616 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_tp_info {
   int tp_start_pos ;
   int tp_end_header ;
   int tp_end_pos ;
   int tp_start_pack ;
   int tp_numpacks ;
};
#line 627 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_tp_info opj_tp_info_t;
#line 632 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_tile_info {
   double *thresh ;
   int tileno ;
   int start_pos ;
   int end_header ;
   int end_pos ;
   int pw[33] ;
   int ph[33] ;
   int pdx[33] ;
   int pdy[33] ;
   opj_packet_info_t *packet ;
   int numpix ;
   double distotile ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int num_tps ;
   opj_tp_info_t *tp ;
};
#line 667 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_tile_info opj_tile_info_t;
#line 672 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
struct opj_codestream_info {
   double D_max ;
   int packno ;
   int index_write ;
   int image_w ;
   int image_h ;
   OPJ_PROG_ORDER prog ;
   int tile_x ;
   int tile_y ;
   int tile_Ox ;
   int tile_Oy ;
   int tw ;
   int th ;
   int numcomps ;
   int numlayers ;
   int *numdecompos ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int main_head_start ;
   int main_head_end ;
   int codestream_size ;
   opj_tile_info_t *tile ;
};
#line 719 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
typedef struct opj_codestream_info opj_codestream_info_t;
#line 47 "/root/patchweave_new/2/libopenjpeg/bio.h"
struct opj_bio {
   unsigned char *start ;
   unsigned char *end ;
   unsigned char *bp ;
   unsigned int buf ;
   int ct ;
};
#line 58 "/root/patchweave_new/2/libopenjpeg/bio.h"
typedef struct opj_bio opj_bio_t;
#line 116 "/root/patchweave_new/2/libopenjpeg/j2k.h"
enum T2_MODE {
    THRESH_CALC = 0,
    FINAL_PASS = 1
} ;
#line 119 "/root/patchweave_new/2/libopenjpeg/j2k.h"
typedef enum T2_MODE J2K_T2_MODE;
#line 124 "/root/patchweave_new/2/libopenjpeg/j2k.h"
struct opj_stepsize {
   int expn ;
   int mant ;
};
#line 129 "/root/patchweave_new/2/libopenjpeg/j2k.h"
typedef struct opj_stepsize opj_stepsize_t;
#line 134 "/root/patchweave_new/2/libopenjpeg/j2k.h"
struct opj_tccp {
   int csty ;
   int numresolutions ;
   int cblkw ;
   int cblkh ;
   int cblksty ;
   int qmfbid ;
   int qntsty ;
   opj_stepsize_t stepsizes[97] ;
   int numgbits ;
   int roishift ;
   int prcw[33] ;
   int prch[33] ;
};
#line 159 "/root/patchweave_new/2/libopenjpeg/j2k.h"
typedef struct opj_tccp opj_tccp_t;
#line 166 "/root/patchweave_new/2/libopenjpeg/j2k.h"
struct opj_tcp {
   int first ;
   int csty ;
   OPJ_PROG_ORDER prg ;
   int numlayers ;
   int mct ;
   float rates[100] ;
   int numpocs ;
   int POC ;
   opj_poc_t pocs[32] ;
   unsigned char *ppt_data ;
   unsigned char *ppt_data_first ;
   int ppt ;
   int ppt_store ;
   int ppt_len ;
   float distoratio[100] ;
   opj_tccp_t *tccps ;
};
#line 199 "/root/patchweave_new/2/libopenjpeg/j2k.h"
typedef struct opj_tcp opj_tcp_t;
#line 204 "/root/patchweave_new/2/libopenjpeg/j2k.h"
struct opj_cp {
   OPJ_CINEMA_MODE cinema ;
   int max_comp_size ;
   int img_size ;
   OPJ_RSIZ_CAPABILITIES rsiz ;
   char tp_on ;
   char tp_flag ;
   int tp_pos ;
   int disto_alloc ;
   int fixed_alloc ;
   int fixed_quality ;
   int reduce ;
   int layer ;
   OPJ_LIMIT_DECODING limit_decoding ;
   int tx0 ;
   int ty0 ;
   int tdx ;
   int tdy ;
   char *comment ;
   int tw ;
   int th ;
   int *tileno ;
   int tileno_size ;
   unsigned char *ppm_data ;
   unsigned char *ppm_data_first ;
   int ppm ;
   int ppm_store ;
   int ppm_previous ;
   int ppm_len ;
   opj_tcp_t *tcps ;
   int *matrice ;
};
#line 309 "/root/patchweave_new/2/libopenjpeg/j2k.h"
typedef struct opj_cp opj_cp_t;
#line 314 "/root/patchweave_new/2/libopenjpeg/j2k.h"
struct opj_j2k {
   opj_common_ptr cinfo ;
   int state ;
   int curtileno ;
   int tp_num ;
   int cur_tp_num ;
   int *cur_totnum_tp ;
   int tlm_start ;
   int totnum_tp ;
   unsigned char *eot ;
   int sot_start ;
   int sod_start ;
   int pos_correction ;
   unsigned char **tile_data ;
   int *tile_len ;
   opj_tcp_t *default_tcp ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_codestream_info_t *cstr_info ;
   opj_cio_t *cio ;
};
#line 369 "/root/patchweave_new/2/libopenjpeg/j2k.h"
typedef struct opj_j2k opj_j2k_t;
#line 60 "/root/patchweave_new/2/libopenjpeg/jp2.h"
struct opj_jp2_cdef_info {
   unsigned short cn ;
   unsigned short typ ;
   unsigned short asoc ;
};
#line 63 "/root/patchweave_new/2/libopenjpeg/jp2.h"
typedef struct opj_jp2_cdef_info opj_jp2_cdef_info_t;
#line 68 "/root/patchweave_new/2/libopenjpeg/jp2.h"
struct opj_jp2_cdef {
   opj_jp2_cdef_info_t *info ;
   unsigned short n ;
};
#line 72 "/root/patchweave_new/2/libopenjpeg/jp2.h"
typedef struct opj_jp2_cdef opj_jp2_cdef_t;
#line 77 "/root/patchweave_new/2/libopenjpeg/jp2.h"
struct opj_jp2_cmap_comp {
   unsigned short cmp ;
   unsigned char mtyp ;
   unsigned char pcol ;
};
#line 81 "/root/patchweave_new/2/libopenjpeg/jp2.h"
typedef struct opj_jp2_cmap_comp opj_jp2_cmap_comp_t;
#line 86 "/root/patchweave_new/2/libopenjpeg/jp2.h"
struct opj_jp2_pclr {
   unsigned int *entries ;
   unsigned char *channel_sign ;
   unsigned char *channel_size ;
   opj_jp2_cmap_comp_t *cmap ;
   unsigned short nr_entries ;
   unsigned short nr_channels ;
};
#line 93 "/root/patchweave_new/2/libopenjpeg/jp2.h"
typedef struct opj_jp2_pclr opj_jp2_pclr_t;
#line 98 "/root/patchweave_new/2/libopenjpeg/jp2.h"
struct opj_jp2_color {
   unsigned char *icc_profile_buf ;
   int icc_profile_len ;
   opj_jp2_cdef_t *jp2_cdef ;
   opj_jp2_pclr_t *jp2_pclr ;
   unsigned char jp2_has_colr ;
};
#line 106 "/root/patchweave_new/2/libopenjpeg/jp2.h"
typedef struct opj_jp2_color opj_jp2_color_t;
#line 111 "/root/patchweave_new/2/libopenjpeg/jp2.h"
struct opj_jp2_comps {
   int depth ;
   int sgnd ;
   int bpcc ;
};
#line 115 "/root/patchweave_new/2/libopenjpeg/jp2.h"
typedef struct opj_jp2_comps opj_jp2_comps_t;
#line 120 "/root/patchweave_new/2/libopenjpeg/jp2.h"
struct opj_jp2 {
   opj_common_ptr cinfo ;
   opj_j2k_t *j2k ;
   unsigned int w ;
   unsigned int h ;
   unsigned int numcomps ;
   unsigned int bpc ;
   unsigned int C ;
   unsigned int UnkC ;
   unsigned int IPR ;
   unsigned int meth ;
   unsigned int approx ;
   unsigned int enumcs ;
   unsigned int precedence ;
   unsigned int brand ;
   unsigned int minversion ;
   unsigned int numcl ;
   unsigned int *cl ;
   opj_jp2_comps_t *comps ;
   unsigned int j2k_codestream_offset ;
   unsigned int j2k_codestream_length ;
   opj_bool jpip_on ;
   opj_bool ignore_pclr_cmap_cdef ;
};
#line 145 "/root/patchweave_new/2/libopenjpeg/jp2.h"
typedef struct opj_jp2 opj_jp2_t;
#line 150 "/root/patchweave_new/2/libopenjpeg/jp2.h"
struct opj_jp2_box {
   int length ;
   int type ;
   int init_pos ;
};
#line 154 "/root/patchweave_new/2/libopenjpeg/jp2.h"
typedef struct opj_jp2_box opj_jp2_box_t;
#line 42 "/root/patchweave_new/2/libopenjpeg/jpt.h"
struct opj_jpt_msg_header {
   unsigned int Id ;
   unsigned int last_byte ;
   unsigned int Class_Id ;
   unsigned int CSn_Id ;
   unsigned int Msg_offset ;
   unsigned int Msg_length ;
   unsigned int Layer_nb ;
};
#line 57 "/root/patchweave_new/2/libopenjpeg/jpt.h"
typedef struct opj_jpt_msg_header opj_jpt_msg_header_t;
#line 48 "/root/patchweave_new/2/libopenjpeg/mqc.h"
struct opj_mqc_state {
   unsigned int qeval ;
   int mps ;
   struct opj_mqc_state *nmps ;
   struct opj_mqc_state *nlps ;
};
#line 57 "/root/patchweave_new/2/libopenjpeg/mqc.h"
typedef struct opj_mqc_state opj_mqc_state_t;
#line 64 "/root/patchweave_new/2/libopenjpeg/mqc.h"
struct opj_mqc {
   unsigned int c ;
   unsigned int a ;
   unsigned int ct ;
   unsigned char *bp ;
   unsigned char *start ;
   unsigned char *end ;
   opj_mqc_state_t *ctxs[19] ;
   opj_mqc_state_t **curctx ;
};
#line 76 "/root/patchweave_new/2/libopenjpeg/mqc.h"
typedef struct opj_mqc opj_mqc_t;
#line 46 "/root/patchweave_new/2/libopenjpeg/raw.h"
struct opj_raw {
   unsigned char c ;
   unsigned int ct ;
   unsigned int lenmax ;
   unsigned int len ;
   unsigned char *bp ;
   unsigned char *start ;
   unsigned char *end ;
};
#line 61 "/root/patchweave_new/2/libopenjpeg/raw.h"
typedef struct opj_raw opj_raw_t;
#line 48 "/root/patchweave_new/2/libopenjpeg/tgt.h"
struct opj_tgt_node {
   struct opj_tgt_node *parent ;
   int value ;
   int low ;
   int known ;
};
#line 53 "/root/patchweave_new/2/libopenjpeg/tgt.h"
typedef struct opj_tgt_node opj_tgt_node_t;
#line 58 "/root/patchweave_new/2/libopenjpeg/tgt.h"
struct opj_tgt_tree {
   int numleafsh ;
   int numleafsv ;
   int numnodes ;
   opj_tgt_node_t *nodes ;
};
#line 63 "/root/patchweave_new/2/libopenjpeg/tgt.h"
typedef struct opj_tgt_tree opj_tgt_tree_t;
#line 49 "/root/patchweave_new/2/libopenjpeg/pi.h"
struct opj_pi_resolution {
   int pdx ;
   int pdy ;
   int pw ;
   int ph ;
};
#line 52 "/root/patchweave_new/2/libopenjpeg/pi.h"
typedef struct opj_pi_resolution opj_pi_resolution_t;
#line 57 "/root/patchweave_new/2/libopenjpeg/pi.h"
struct opj_pi_comp {
   int dx ;
   int dy ;
   int numresolutions ;
   opj_pi_resolution_t *resolutions ;
};
#line 62 "/root/patchweave_new/2/libopenjpeg/pi.h"
typedef struct opj_pi_comp opj_pi_comp_t;
#line 67 "/root/patchweave_new/2/libopenjpeg/pi.h"
struct opj_pi_iterator {
   char tp_on ;
   short *include ;
   int step_l ;
   int step_r ;
   int step_c ;
   int step_p ;
   int compno ;
   int resno ;
   int precno ;
   int layno ;
   int first ;
   opj_poc_t poc ;
   int numcomps ;
   opj_pi_comp_t *comps ;
   int tx0 ;
   int ty0 ;
   int tx1 ;
   int ty1 ;
   int x ;
   int y ;
   int dx ;
   int dy ;
};
#line 98 "/root/patchweave_new/2/libopenjpeg/pi.h"
typedef struct opj_pi_iterator opj_pi_iterator_t;
#line 47 "/root/patchweave_new/2/libopenjpeg/tcd.h"
struct opj_tcd_seg {
   unsigned char **data ;
   int dataindex ;
   int numpasses ;
   int len ;
   int maxpasses ;
   int numnewpasses ;
   int newlen ;
};
#line 55 "/root/patchweave_new/2/libopenjpeg/tcd.h"
typedef struct opj_tcd_seg opj_tcd_seg_t;
#line 60 "/root/patchweave_new/2/libopenjpeg/tcd.h"
struct opj_tcd_pass {
   int rate ;
   double distortiondec ;
   int term ;
   int len ;
};
#line 64 "/root/patchweave_new/2/libopenjpeg/tcd.h"
typedef struct opj_tcd_pass opj_tcd_pass_t;
#line 69 "/root/patchweave_new/2/libopenjpeg/tcd.h"
struct opj_tcd_layer {
   int numpasses ;
   int len ;
   double disto ;
   unsigned char *data ;
};
#line 74 "/root/patchweave_new/2/libopenjpeg/tcd.h"
typedef struct opj_tcd_layer opj_tcd_layer_t;
#line 79 "/root/patchweave_new/2/libopenjpeg/tcd.h"
struct opj_tcd_cblk_enc {
   unsigned char *data ;
   opj_tcd_layer_t *layers ;
   opj_tcd_pass_t *passes ;
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numbps ;
   int numlenbits ;
   int numpasses ;
   int numpassesinlayers ;
   int totalpasses ;
};
#line 89 "/root/patchweave_new/2/libopenjpeg/tcd.h"
typedef struct opj_tcd_cblk_enc opj_tcd_cblk_enc_t;
#line 91 "/root/patchweave_new/2/libopenjpeg/tcd.h"
struct opj_tcd_cblk_dec {
   unsigned char *data ;
   opj_tcd_seg_t *segs ;
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numbps ;
   int numlenbits ;
   int len ;
   int numnewpasses ;
   int numsegs ;
};
#line 100 "/root/patchweave_new/2/libopenjpeg/tcd.h"
typedef struct opj_tcd_cblk_dec opj_tcd_cblk_dec_t;
#line 108 "/root/patchweave_new/2/libopenjpeg/tcd.h"
union __anonunion_23 {
   opj_tcd_cblk_enc_t *enc ;
   opj_tcd_cblk_dec_t *dec ;
};
#line 105 "/root/patchweave_new/2/libopenjpeg/tcd.h"
struct opj_tcd_precinct {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int cw ;
   int ch ;
   union __anonunion_23 cblks ;
   opj_tgt_tree_t *incltree ;
   opj_tgt_tree_t *imsbtree ;
};
#line 114 "/root/patchweave_new/2/libopenjpeg/tcd.h"
typedef struct opj_tcd_precinct opj_tcd_precinct_t;
#line 119 "/root/patchweave_new/2/libopenjpeg/tcd.h"
struct opj_tcd_band {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int bandno ;
   opj_tcd_precinct_t *precincts ;
   int numbps ;
   float stepsize ;
};
#line 125 "/root/patchweave_new/2/libopenjpeg/tcd.h"
typedef struct opj_tcd_band opj_tcd_band_t;
#line 130 "/root/patchweave_new/2/libopenjpeg/tcd.h"
struct opj_tcd_resolution {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int pw ;
   int ph ;
   int numbands ;
   opj_tcd_band_t bands[3] ;
};
#line 135 "/root/patchweave_new/2/libopenjpeg/tcd.h"
typedef struct opj_tcd_resolution opj_tcd_resolution_t;
#line 140 "/root/patchweave_new/2/libopenjpeg/tcd.h"
struct opj_tcd_tilecomp {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numresolutions ;
   opj_tcd_resolution_t *resolutions ;
   int *data ;
   int numpix ;
};
#line 146 "/root/patchweave_new/2/libopenjpeg/tcd.h"
typedef struct opj_tcd_tilecomp opj_tcd_tilecomp_t;
#line 151 "/root/patchweave_new/2/libopenjpeg/tcd.h"
struct opj_tcd_tile {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numcomps ;
   opj_tcd_tilecomp_t *comps ;
   int numpix ;
   double distotile ;
   double distolayer[100] ;
   int packno ;
};
#line 160 "/root/patchweave_new/2/libopenjpeg/tcd.h"
typedef struct opj_tcd_tile opj_tcd_tile_t;
#line 165 "/root/patchweave_new/2/libopenjpeg/tcd.h"
struct opj_tcd_image {
   int tw ;
   int th ;
   opj_tcd_tile_t *tiles ;
};
#line 168 "/root/patchweave_new/2/libopenjpeg/tcd.h"
typedef struct opj_tcd_image opj_tcd_image_t;
#line 173 "/root/patchweave_new/2/libopenjpeg/tcd.h"
struct opj_tcd {
   int tp_pos ;
   int tp_num ;
   int cur_tp_num ;
   int cur_totnum_tp ;
   int cur_pino ;
   opj_common_ptr cinfo ;
   opj_tcd_image_t *tcd_image ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_tcd_tile_t *tcd_tile ;
   opj_tcp_t *tcp ;
   int tcd_tileno ;
   double encoding_time ;
};
#line 201 "/root/patchweave_new/2/libopenjpeg/tcd.h"
typedef struct opj_tcd opj_tcd_t;
#line 88 "/root/patchweave_new/2/libopenjpeg/t1.h"
typedef short flag_t;
#line 93 "/root/patchweave_new/2/libopenjpeg/t1.h"
struct opj_t1 {
   opj_common_ptr cinfo ;
   opj_mqc_t *mqc ;
   opj_raw_t *raw ;
   int *data ;
   flag_t *flags ;
   int w ;
   int h ;
   int datasize ;
   int flagssize ;
   int flags_stride ;
};
#line 109 "/root/patchweave_new/2/libopenjpeg/t1.h"
typedef struct opj_t1 opj_t1_t;
#line 45 "/root/patchweave_new/2/libopenjpeg/t2.h"
struct opj_t2 {
   opj_common_ptr cinfo ;
   opj_image_t *image ;
   opj_cp_t *cp ;
};
#line 53 "/root/patchweave_new/2/libopenjpeg/t2.h"
typedef struct opj_t2 opj_t2_t;
#line 42 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __m64;
#line 48 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v2si;
#line 49 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v4hi;
#line 50 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v8qi;
#line 69 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
typedef int __m128;
#line 72 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
typedef int __m128_u;
#line 75 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
typedef int __v4sf;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v2df;
#line 41 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v2di;
#line 42 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v2du;
#line 43 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v4si;
#line 44 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v4su;
#line 45 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v8hi;
#line 46 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v8hu;
#line 47 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v16qi;
#line 49 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v16qu;
#line 53 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128i;
#line 54 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128d;
#line 57 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128i_u;
#line 58 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128d_u;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_131 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 47 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_132 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_133 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 59 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_134 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_135 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_136 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 78 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_137 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 85 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_138 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_139 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_140 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_141 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 109 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_142 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 117 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_143 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_144 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion_131 __annonCompField3 ;
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
   union __anonunion_132 __annonCompField4 ;
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
   union __anonunion_133 __annonCompField5 ;
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
   union __anonunion_134 __annonCompField6 ;
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
   union __anonunion_135 __annonCompField7 ;
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
   union __anonunion_136 __annonCompField8 ;
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
   union __anonunion_137 __annonCompField9 ;
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
   union __anonunion_138 __annonCompField10 ;
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
   union __anonunion_139 __annonCompField11 ;
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
   union __anonunion_140 __annonCompField12 ;
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
   union __anonunion_141 __annonCompField13 ;
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
   union __anonunion_142 __annonCompField14 ;
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
   union __anonunion_143 __annonCompField15 ;
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
   union __anonunion_144 __annonCompField16 ;
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 255 "/root/patchweave_new/2/libopenjpeg/j2k.c"
struct j2k_prog_order {
   OPJ_PROG_ORDER enum_prog ;
   char str_prog[5] ;
};
#line 258 "/root/patchweave_new/2/libopenjpeg/j2k.c"
typedef struct j2k_prog_order j2k_prog_order_t;
#line 1663 "/root/patchweave_new/2/libopenjpeg/j2k.c"
struct opj_dec_mstabent {
   int id ;
   int states ;
   void (*handler)(opj_j2k_t * ) ;
};
#line 1670 "/root/patchweave_new/2/libopenjpeg/j2k.c"
typedef struct opj_dec_mstabent opj_dec_mstabent_t;
#line 49 "/root/patchweave_new/2/libopenjpeg/dwt.c"
struct dwt_local {
   int *mem ;
   int dn ;
   int sn ;
   int cas ;
};
#line 54 "/root/patchweave_new/2/libopenjpeg/dwt.c"
typedef struct dwt_local dwt_t;
#line 56 "/root/patchweave_new/2/libopenjpeg/dwt.c"
union __anonunion_166 {
   float f[4] ;
};
#line 58 "/root/patchweave_new/2/libopenjpeg/dwt.c"
typedef union __anonunion_166 v4;
#line 60 "/root/patchweave_new/2/libopenjpeg/dwt.c"
struct v4dwt_local {
   v4 *wavelet ;
   int dn ;
   int sn ;
   int cas ;
};
#line 65 "/root/patchweave_new/2/libopenjpeg/dwt.c"
typedef struct v4dwt_local v4dwt_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 6 "/root/patchweave_new/2/applications/common/opj_getopt.h"
struct opj_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 12 "/root/patchweave_new/2/applications/common/opj_getopt.h"
typedef struct opj_option opj_option_t;
#line 68 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
struct dircnt {
   char *filename_buf ;
   char **filename ;
};
#line 73 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
typedef struct dircnt dircnt_t;
#line 76 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
struct img_folder {
   char *imgdirpath ;
   char const   *out_format ;
   char set_imgdir ;
   char set_out_format ;
};
#line 86 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
typedef struct img_folder img_fol_t;
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 140 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                  size_t __n ) ;
#line 61
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n ) ;
#line 122
extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src ) ;
#line 125
extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                   size_t __n ) ;
#line 130
extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src ) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 120 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 138 "/usr/include/stdio.h"
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 326
extern int fprintf(FILE *__stream , char const   *__format  , ...) ;
#line 332
extern int printf(char const   *__format  , ...) ;
#line 334
extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__format 
                                                 , ...) ;
#line 358
extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __maxlen , char const   *__format ,
                                                   __gnuc_va_list __arg ) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 646
extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 732 "/root/patchweave_new/2/libopenjpeg/openjpeg.h"
char const   *opj_version(void) ;
#line 747
opj_image_t *opj_image_create(int numcmpts , opj_image_cmptparm_t *cmptparms , OPJ_COLOR_SPACE clrspc ) ;
#line 753
void opj_image_destroy(opj_image_t *image ) ;
#line 772
opj_cio_t *opj_cio_open(opj_common_ptr cinfo , unsigned char *buffer , int length ) ;
#line 778
void opj_cio_close(opj_cio_t *cio ) ;
#line 785
int cio_tell(opj_cio_t *cio ) ;
#line 791
void cio_seek(opj_cio_t *cio , int pos ) ;
#line 799
opj_event_mgr_t *opj_set_event_mgr(opj_common_ptr cinfo , opj_event_mgr_t *event_mgr ,
                                   void *context ) ;
#line 811
opj_dinfo_t *opj_create_decompress(OPJ_CODEC_FORMAT format ) ;
#line 816
void opj_destroy_decompress(opj_dinfo_t *dinfo ) ;
#line 821
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) ;
#line 828
void opj_setup_decoder(opj_dinfo_t *dinfo , opj_dparameters_t *parameters ) ;
#line 835
opj_image_t *opj_decode(opj_dinfo_t *dinfo , opj_cio_t *cio ) ;
#line 844
opj_image_t *opj_decode_with_info(opj_dinfo_t *dinfo , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 850
opj_cinfo_t *opj_create_compress(OPJ_CODEC_FORMAT format ) ;
#line 855
void opj_destroy_compress(opj_cinfo_t *cinfo ) ;
#line 877
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) ;
#line 884
void opj_setup_encoder(opj_cinfo_t *cinfo , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 893
opj_bool opj_encode(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image , char *index___0 ) ;
#line 902
opj_bool opj_encode_with_info(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image ,
                              opj_codestream_info_t *cstr_info ) ;
#line 907
void opj_destroy_cstr_info(opj_codestream_info_t *cstr_info ) ;
#line 46 "/root/patchweave_new/2/libopenjpeg/j2k_lib.h"
double opj_clock(void) ;
#line 52 "/root/patchweave_new/2/libopenjpeg/event.h"
opj_bool opj_event_msg(opj_common_ptr cinfo , int event_type , char const   *fmt 
                       , ...) ;
#line 67 "/root/patchweave_new/2/libopenjpeg/bio.h"
opj_bio_t *bio_create(void) ;
#line 72
void bio_destroy(opj_bio_t *bio ) ;
#line 78
int bio_numbytes(opj_bio_t *bio ) ;
#line 85
void bio_init_enc(opj_bio_t *bio , unsigned char *bp , int len ) ;
#line 92
void bio_init_dec(opj_bio_t *bio , unsigned char *bp , int len ) ;
#line 99
void bio_write(opj_bio_t *bio , int v , int n ) ;
#line 106
int bio_read(opj_bio_t *bio , int n ) ;
#line 112
int bio_flush(opj_bio_t *bio ) ;
#line 118
int bio_inalign(opj_bio_t *bio ) ;
#line 59 "/root/patchweave_new/2/libopenjpeg/cio.h"
int cio_numbytesleft(opj_cio_t *cio ) ;
#line 65
unsigned char *cio_getbp(opj_cio_t *cio ) ;
#line 73
unsigned int cio_write(opj_cio_t *cio , unsigned long long v , int n ) ;
#line 80
unsigned int cio_read(opj_cio_t *cio , int n ) ;
#line 86
void cio_skip(opj_cio_t *cio , int n ) ;
#line 43 "/root/patchweave_new/2/libopenjpeg/image.h"
opj_image_t *opj_image_create0(void) ;
#line 379 "/root/patchweave_new/2/libopenjpeg/j2k.h"
opj_j2k_t *j2k_create_decompress(opj_common_ptr cinfo ) ;
#line 384
void j2k_destroy_decompress(opj_j2k_t *j2k ) ;
#line 391
void j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) ;
#line 399
opj_image_t *j2k_decode(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 407
opj_image_t *j2k_decode_jpt_stream(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 413
opj_j2k_t *j2k_create_compress(opj_common_ptr cinfo ) ;
#line 418
void j2k_destroy_compress(opj_j2k_t *j2k ) ;
#line 426
void j2k_setup_encoder(opj_j2k_t *j2k , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 430
char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) ;
#line 439
opj_bool j2k_encode(opj_j2k_t *j2k , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 164 "/root/patchweave_new/2/libopenjpeg/jp2.h"
void jp2_write_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 172
opj_bool jp2_read_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) ;
#line 178
opj_jp2_t *jp2_create_decompress(opj_common_ptr cinfo ) ;
#line 183
void jp2_destroy_decompress(opj_jp2_t *jp2 ) ;
#line 190
void jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) ;
#line 198
opj_image_t *opj_jp2_decode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 204
opj_jp2_t *jp2_create_compress(opj_common_ptr cinfo ) ;
#line 209
void jp2_destroy_compress(opj_jp2_t *jp2 ) ;
#line 217
void jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 226
opj_bool opj_jp2_encode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 65 "/root/patchweave_new/2/libopenjpeg/jpt.h"
void jpt_init_msg_header(opj_jpt_msg_header_t *header ) ;
#line 73
void jpt_read_msg_header(opj_common_ptr cinfo , opj_cio_t *cio , opj_jpt_msg_header_t *header ) ;
#line 85 "/root/patchweave_new/2/libopenjpeg/mqc.h"
opj_mqc_t *mqc_create(void) ;
#line 90
void mqc_destroy(opj_mqc_t *mqc ) ;
#line 96
int mqc_numbytes(opj_mqc_t *mqc ) ;
#line 102
void mqc_resetstates(opj_mqc_t *mqc ) ;
#line 110
void mqc_setstate(opj_mqc_t *mqc , int ctxno , int msb , int prob ) ;
#line 116
void mqc_init_enc(opj_mqc_t *mqc , unsigned char *bp ) ;
#line 128
void mqc_encode(opj_mqc_t *mqc , int d ) ;
#line 133
void mqc_flush(opj_mqc_t *mqc ) ;
#line 140
void mqc_bypass_init_enc(opj_mqc_t *mqc ) ;
#line 148
void mqc_bypass_enc(opj_mqc_t *mqc , int d ) ;
#line 155
int mqc_bypass_flush_enc(opj_mqc_t *mqc ) ;
#line 160
void mqc_reset_enc(opj_mqc_t *mqc ) ;
#line 166
int mqc_restart_enc(opj_mqc_t *mqc ) ;
#line 171
void mqc_restart_init_enc(opj_mqc_t *mqc ) ;
#line 176
void mqc_erterm_enc(opj_mqc_t *mqc ) ;
#line 181
void mqc_segmark_enc(opj_mqc_t *mqc ) ;
#line 188
void mqc_init_dec(opj_mqc_t *mqc , unsigned char *bp , int len ) ;
#line 194
int mqc_decode(opj_mqc_t *mqc ) ;
#line 70 "/root/patchweave_new/2/libopenjpeg/raw.h"
opj_raw_t *raw_create(void) ;
#line 75
void raw_destroy(opj_raw_t *raw ) ;
#line 81
int raw_numbytes(opj_raw_t *raw ) ;
#line 88
void raw_init_dec(opj_raw_t *raw , unsigned char *bp , int len ) ;
#line 94
int raw_decode(opj_raw_t *raw ) ;
#line 74 "/root/patchweave_new/2/libopenjpeg/tgt.h"
opj_tgt_tree_t *tgt_create(int numleafsh , int numleafsv ) ;
#line 79
void tgt_destroy(opj_tgt_tree_t *tree ) ;
#line 84
void tgt_reset(opj_tgt_tree_t *tree ) ;
#line 91
void tgt_setvalue(opj_tgt_tree_t *tree , int leafno , int value ) ;
#line 99
void tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) ;
#line 108
int tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) ;
#line 112 "/root/patchweave_new/2/libopenjpeg/pi.h"
opj_pi_iterator_t *pi_initialise_encode(opj_image_t *image , opj_cp_t *cp , int tileno ,
                                        J2K_T2_MODE t2_mode ) ;
#line 125
opj_bool pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno , int pino ,
                          int tpnum , int tppos , J2K_T2_MODE t2_mode , int cur_totnum_tp ) ;
#line 134
opj_pi_iterator_t *pi_create_decode(opj_image_t *image , opj_cp_t *cp , int tileno ) ;
#line 143
void pi_destroy(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno ) ;
#line 150
opj_bool pi_next(opj_pi_iterator_t *pi ) ;
#line 210 "/root/patchweave_new/2/libopenjpeg/tcd.h"
void tcd_dump(FILE *fd , opj_tcd_t *tcd , opj_tcd_image_t *img ) ;
#line 216
opj_tcd_t *tcd_create(opj_common_ptr cinfo ) ;
#line 221
void tcd_destroy(opj_tcd_t *tcd ) ;
#line 229
void tcd_malloc_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) ;
#line 234
void tcd_free_encode(opj_tcd_t *tcd ) ;
#line 242
void tcd_init_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) ;
#line 249
void tcd_malloc_decode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp ) ;
#line 250
void tcd_malloc_decode_tile(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int tileno ,
                            opj_codestream_info_t *cstr_info ) ;
#line 251
void tcd_makelayer_fixed(opj_tcd_t *tcd , int layno , int final ) ;
#line 252
void tcd_rateallocate_fixed(opj_tcd_t *tcd ) ;
#line 253
void tcd_makelayer(opj_tcd_t *tcd , int layno , double thresh , int final ) ;
#line 254
opj_bool tcd_rateallocate(opj_tcd_t *tcd , unsigned char *dest , int len , opj_codestream_info_t *cstr_info ) ;
#line 264
int tcd_encode_tile(opj_tcd_t *tcd , int tileno , unsigned char *dest , int len ,
                    opj_codestream_info_t *cstr_info ) ;
#line 273
opj_bool tcd_decode_tile(opj_tcd_t *tcd , unsigned char *src , int len , int tileno ,
                         opj_codestream_info_t *cstr_info ) ;
#line 278
void tcd_free_decode(opj_tcd_t *tcd ) ;
#line 279
void tcd_free_decode_tile(opj_tcd_t *tcd , int tileno ) ;
#line 122 "/root/patchweave_new/2/libopenjpeg/t1.h"
opj_t1_t *t1_create(opj_common_ptr cinfo ) ;
#line 127
void t1_destroy(opj_t1_t *t1 ) ;
#line 134
void t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ) ;
#line 141
void t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) ;
#line 55 "/root/patchweave_new/2/libopenjpeg/dwt.h"
void dwt_encode(opj_tcd_tilecomp_t *tilec ) ;
#line 62
void dwt_decode(opj_tcd_tilecomp_t *tilec , int numres ) ;
#line 68
int dwt_getgain(int orient ) ;
#line 75
double dwt_getnorm(int level , int orient ) ;
#line 81
void dwt_encode_real(opj_tcd_tilecomp_t *tilec ) ;
#line 88
void dwt_decode_real(opj_tcd_tilecomp_t *tilec , int numres ) ;
#line 94
int dwt_getgain_real(int orient ) ;
#line 101
double dwt_getnorm_real(int level , int orient ) ;
#line 107
void dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , int prec ) ;
#line 74 "/root/patchweave_new/2/libopenjpeg/t2.h"
int t2_encode_packets(opj_t2_t *t2 , int tileno , opj_tcd_tile_t *tile , int maxlayers ,
                      unsigned char *dest , int len , opj_codestream_info_t *cstr_info ,
                      int tpnum , int tppos , int pino , J2K_T2_MODE t2_mode , int cur_totnum_tp ) ;
#line 84
int t2_decode_packets(opj_t2_t *t2 , unsigned char *src , int len , int tileno , opj_tcd_tile_t *tile ,
                      opj_codestream_info_t *cstr_info ) ;
#line 93
opj_t2_t *t2_create(opj_common_ptr cinfo , opj_image_t *image , opj_cp_t *cp ) ;
#line 98
void t2_destroy(opj_t2_t *t2 ) ;
#line 55 "/root/patchweave_new/2/libopenjpeg/mct.h"
void mct_encode(int *c0 , int *c1 , int *c2 , int n ) ;
#line 63
void mct_decode(int *c0 , int *c1 , int *c2 , int n ) ;
#line 69
double mct_getnorm(int compno ) ;
#line 78
void mct_encode_real(int *c0 , int *c1 , int *c2 , int n ) ;
#line 86
void mct_decode_real(float *c0 , float *c1 , float *c2 , int n ) ;
#line 92
double mct_getnorm_real(int compno ) ;
#line 50 "/root/patchweave_new/2/libopenjpeg/int.h"
__inline static int int_min(int a , int b ) 
{ 
  int tmp ;

  {
#line 51
  if (a < b) {
#line 51
    tmp = a;
  } else {
#line 51
    tmp = b;
  }
#line 51
  return (tmp);
}
}
#line 57 "/root/patchweave_new/2/libopenjpeg/int.h"
__inline static int int_max(int a , int b ) 
{ 
  int tmp ;

  {
#line 58
  if (a > b) {
#line 58
    tmp = a;
  } else {
#line 58
    tmp = b;
  }
#line 58
  return (tmp);
}
}
#line 69 "/root/patchweave_new/2/libopenjpeg/int.h"
__inline static int int_clamp(int a , int min , int max ) 
{ 


  {
#line 70
  if (a < min) {
#line 71
    return (min);
  }
#line 72
  if (a > max) {
#line 73
    return (max);
  }
#line 74
  return (a);
}
}
#line 79 "/root/patchweave_new/2/libopenjpeg/int.h"
__inline static int int_abs(int a ) 
{ 
  int tmp ;

  {
#line 80
  if (a < 0) {
#line 80
    tmp = - a;
  } else {
#line 80
    tmp = a;
  }
#line 80
  return (tmp);
}
}
#line 86 "/root/patchweave_new/2/libopenjpeg/int.h"
__inline static int int_ceildiv(int a , int b ) 
{ 


  {
#line 87
  return (((a + b) - 1) / b);
}
}
#line 93 "/root/patchweave_new/2/libopenjpeg/int.h"
__inline static int int_ceildivpow2(int a , int b ) 
{ 


  {
#line 94
  return (((a + (1 << b)) - 1) >> b);
}
}
#line 100 "/root/patchweave_new/2/libopenjpeg/int.h"
__inline static int int_floordivpow2(int a , int b ) 
{ 


  {
#line 101
  return (a >> b);
}
}
#line 107 "/root/patchweave_new/2/libopenjpeg/int.h"
__inline static int int_floorlog2(int a ) 
{ 
  int l ;

  {
#line 109
  l = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;

#line 109
    if (! (a > 1)) {
#line 109
      goto while_break;
    }
#line 110
    a >>= 1;
#line 109
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 112
  return (l);
}
}
#line 56 "/root/patchweave_new/2/libopenjpeg/fix.h"
__inline static int fix_mul(int a , int b ) 
{ 
  long long temp ;

  {
#line 57
  temp = (long long )a * (long long )b;
#line 58
  temp += temp & 4096LL;
#line 59
  return ((int )(temp >> 13));
}
}
#line 53 "/root/patchweave_new/2/libopenjpeg/cidx_manager.h"
int write_cidx(int offset , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t cstr_info ,
               int j2klen ) ;
#line 68 "/root/patchweave_new/2/libopenjpeg/indexbox_manager.h"
int write_tpix(int coff , opj_codestream_info_t cstr_info , int j2klen , opj_cio_t *cio ) ;
#line 79
int write_thix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) ;
#line 92
int write_ppix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) ;
#line 105
int write_phix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) ;
#line 115
void write_manf(int second , int v , opj_jp2_box_t *box , opj_cio_t *cio ) ;
#line 52 "/root/patchweave_new/2/libopenjpeg/tpix_manager.c"
int write_tpixfaix(int coff , int compno , opj_codestream_info_t cstr_info , int j2klen ,
                   opj_cio_t *cio ) ;
#line 55 "/root/patchweave_new/2/libopenjpeg/tpix_manager.c"
int write_tpix(int coff , opj_codestream_info_t cstr_info , int j2klen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp8 ;

  {
  {
#line 58
  lenp = cio_tell(cio);
#line 59
  cio_skip(cio, 4);
#line 60
  cio_write(cio, 1953524088ULL, 4);
#line 62
  write_tpixfaix(coff, 0, cstr_info, j2klen, cio);
#line 64
  __cil_tmp8 = cio_tell(cio);
#line 64
  len = __cil_tmp8 - lenp;
#line 65
  cio_seek(cio, lenp);
#line 66
  cio_write(cio, (unsigned long long )len, 4);
#line 67
  cio_seek(cio, lenp + len);
  }
#line 69
  return (len);
}
}
#line 79
int get_num_max_tile_parts(opj_codestream_info_t cstr_info ) ;
#line 81 "/root/patchweave_new/2/libopenjpeg/tpix_manager.c"
int write_tpixfaix(int coff , int compno , opj_codestream_info_t cstr_info , int j2klen ,
                   opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int i ;
  int j ;
  int Aux ;
  int num_max_tile_parts ;
  int size_of_coding ;
  opj_tp_info_t tp ;
  int version ;
  double __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp23 ;

  {
  {
#line 91
  num_max_tile_parts = get_num_max_tile_parts(cstr_info);
#line 93
  __cil_tmp16 = pow((double )2, (double )32);
  }
#line 93
  if ((double )j2klen > __cil_tmp16) {
#line 94
    size_of_coding = 8;
#line 95
    if (num_max_tile_parts == 1) {
#line 95
      tmp = 1;
    } else {
#line 95
      tmp = 3;
    }
#line 95
    version = tmp;
  } else {
#line 98
    size_of_coding = 4;
#line 99
    if (num_max_tile_parts == 1) {
#line 99
      tmp___0 = 0;
    } else {
#line 99
      tmp___0 = 2;
    }
#line 99
    version = tmp___0;
  }
  {
#line 102
  lenp = cio_tell(cio);
#line 103
  cio_skip(cio, 4);
#line 104
  cio_write(cio, 1717660024ULL, 4);
#line 105
  cio_write(cio, (unsigned long long )version, 1);
#line 107
  cio_write(cio, (unsigned long long )num_max_tile_parts, size_of_coding);
#line 108
  cio_write(cio, (unsigned long long )(cstr_info.tw * cstr_info.th), size_of_coding);
#line 109
  i = 0;
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;

#line 109
    if (! (i < cstr_info.tw * cstr_info.th)) {
#line 109
      goto while_break;
    }
#line 110
    j = 0;
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 110
      if (! (j < (cstr_info.tile + i)->num_tps)) {
#line 110
        goto while_break___0;
      }
      {
#line 111
      tp = *((cstr_info.tile + i)->tp + j);
#line 112
      cio_write(cio, (unsigned long long )(tp.tp_start_pos - coff), size_of_coding);
#line 113
      cio_write(cio, (unsigned long long )((tp.tp_end_pos - tp.tp_start_pos) + 1),
                size_of_coding);
      }
#line 114
      if (version & 2) {
#line 115
        if ((cstr_info.tile + i)->num_tps == 1) {
#line 115
          if (*(cstr_info.numdecompos + compno) > 1) {
#line 116
            Aux = *(cstr_info.numdecompos + compno) + 1;
          } else {
#line 118
            Aux = j + 1;
          }
        } else {
#line 118
          Aux = j + 1;
        }
        {
#line 120
        cio_write(cio, (unsigned long long )Aux, 4);
        }
      }
#line 110
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
    {
#line 127
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 127
      if (! (j < num_max_tile_parts)) {
#line 127
        goto while_break___1;
      }
      {
#line 128
      cio_write(cio, 0ULL, size_of_coding);
#line 129
      cio_write(cio, 0ULL, size_of_coding);
      }
#line 130
      if (version & 2) {
        {
#line 131
        cio_write(cio, 0ULL, 4);
        }
      }
#line 132
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 109
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 136
  __cil_tmp23 = cio_tell(cio);
#line 136
  len = __cil_tmp23 - lenp;
#line 137
  cio_seek(cio, lenp);
#line 138
  cio_write(cio, (unsigned long long )len, 4);
#line 139
  cio_seek(cio, lenp + len);
  }
#line 141
  return (len);
}
}
#line 145 "/root/patchweave_new/2/libopenjpeg/tpix_manager.c"
int get_num_max_tile_parts(opj_codestream_info_t cstr_info ) 
{ 
  int num_max_tp ;
  int i ;
  int tmp ;

  {
#line 147
  num_max_tp = 0;
#line 149
  i = 0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;

#line 149
    if (! (i < cstr_info.tw * cstr_info.th)) {
#line 149
      goto while_break;
    }
#line 150
    if ((cstr_info.tile + i)->num_tps > num_max_tp) {
#line 150
      tmp = (cstr_info.tile + i)->num_tps;
    } else {
#line 150
      tmp = num_max_tp;
    }
#line 150
    num_max_tp = tmp;
#line 149
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 152
  return (num_max_tp);
}
}
#line 50 "/root/patchweave_new/2/libopenjpeg/thix_manager.c"
int write_tilemhix(int coff , opj_codestream_info_t cstr_info , int tileno , opj_cio_t *cio ) ;
#line 52 "/root/patchweave_new/2/libopenjpeg/thix_manager.c"
int write_thix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int i ;
  int tileno ;
  opj_jp2_box_t *box ;
  void *__cil_tmp9 ;
  int __cil_tmp13 ;

  {
  {
#line 58
  lenp = 0;
#line 59
  __cil_tmp9 = calloc((unsigned long )(cstr_info.tw * cstr_info.th), sizeof(opj_jp2_box_t ));
#line 59
  box = (opj_jp2_box_t *)__cil_tmp9;
#line 61
  i = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;

#line 61
    if (! (i < 2)) {
#line 61
      goto while_break;
    }
#line 62
    if (i) {
      {
#line 63
      cio_seek(cio, lenp);
      }
    }
    {
#line 65
    lenp = cio_tell(cio);
#line 66
    cio_skip(cio, 4);
#line 67
    cio_write(cio, 1952999800ULL, 4);
#line 68
    write_manf(i, cstr_info.tw * cstr_info.th, box, cio);
#line 70
    tileno = 0;
    }
    {
#line 70
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 70
      if (! (tileno < cstr_info.tw * cstr_info.th)) {
#line 70
        goto while_break___0;
      }
      {
#line 71
      (box + tileno)->length = write_tilemhix(coff, cstr_info, tileno, cio);
#line 72
      (box + tileno)->type = 1835559288;
#line 70
      tileno ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 75
    __cil_tmp13 = cio_tell(cio);
#line 75
    len = __cil_tmp13 - lenp;
#line 76
    cio_seek(cio, lenp);
#line 77
    cio_write(cio, (unsigned long long )len, 4);
#line 78
    cio_seek(cio, lenp + len);
#line 61
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 81
  free((void *)box);
  }
#line 83
  return (len);
}
}
#line 86 "/root/patchweave_new/2/libopenjpeg/thix_manager.c"
int write_tilemhix(int coff , opj_codestream_info_t cstr_info , int tileno , opj_cio_t *cio ) 
{ 
  int i ;
  opj_tile_info_t tile ;
  opj_tp_info_t tp ;
  int len ;
  int lenp ;
  opj_marker_info_t *marker ;
  int __cil_tmp13 ;

  {
  {
#line 94
  lenp = cio_tell(cio);
#line 95
  cio_skip(cio, 4);
#line 96
  cio_write(cio, 1835559288ULL, 4);
#line 98
  tile = *(cstr_info.tile + tileno);
#line 99
  tp = *(tile.tp + 0);
#line 101
  cio_write(cio, (unsigned long long )((tp.tp_end_header - tp.tp_start_pos) + 1),
            8);
#line 103
  marker = (cstr_info.tile + tileno)->marker;
#line 105
  i = 0;
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;

#line 105
    if (! (i < (cstr_info.tile + tileno)->marknum)) {
#line 105
      goto while_break;
    }
    {
#line 106
    cio_write(cio, (unsigned long long )(marker + i)->type, 2);
#line 107
    cio_write(cio, 0ULL, 2);
#line 108
    cio_write(cio, (unsigned long long )((marker + i)->pos - coff), 8);
#line 109
    cio_write(cio, (unsigned long long )(marker + i)->len, 2);
#line 105
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 114
  __cil_tmp13 = cio_tell(cio);
#line 114
  len = __cil_tmp13 - lenp;
#line 115
  cio_seek(cio, lenp);
#line 116
  cio_write(cio, (unsigned long long )len, 4);
#line 117
  cio_seek(cio, lenp + len);
  }
#line 119
  return (len);
}
}
#line 40 "/root/patchweave_new/2/libopenjpeg/tgt.c"
opj_tgt_tree_t *tgt_create(int numleafsh , int numleafsv ) 
{ 
  int nplh[32] ;
  int nplv[32] ;
  opj_tgt_node_t *node ;
  opj_tgt_node_t *parentnode ;
  opj_tgt_node_t *parentnode0 ;
  opj_tgt_tree_t *tree ;
  int i ;
  int j ;
  int k ;
  int numlvls ;
  int n ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  {
#line 43
  node = (opj_tgt_node_t *)((void *)0);
#line 44
  parentnode = (opj_tgt_node_t *)((void *)0);
#line 45
  parentnode0 = (opj_tgt_node_t *)((void *)0);
#line 46
  tree = (opj_tgt_tree_t *)((void *)0);
#line 51
  __cil_tmp14 = malloc(sizeof(opj_tgt_tree_t ));
#line 51
  tree = (opj_tgt_tree_t *)__cil_tmp14;
  }
#line 52
  if (! tree) {
#line 52
    return ((opj_tgt_tree_t *)((void *)0));
  }
#line 53
  tree->numleafsh = numleafsh;
#line 54
  tree->numleafsv = numleafsv;
#line 56
  numlvls = 0;
#line 57
  nplh[0] = numleafsh;
#line 58
  nplv[0] = numleafsv;
#line 59
  tree->numnodes = 0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    n = nplh[numlvls] * nplv[numlvls];
#line 62
    nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;
#line 63
    nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;
#line 64
    tree->numnodes += n;
#line 65
    numlvls ++;
#line 60
    if (! (n > 1)) {
#line 60
      goto while_break;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 69
  if (tree->numnodes == 0) {
    {
#line 70
    free((void *)tree);
    }
#line 71
    return ((opj_tgt_tree_t *)((void *)0));
  }
  {
#line 74
  __cil_tmp15 = calloc((unsigned long )tree->numnodes, sizeof(opj_tgt_node_t ));
#line 74
  tree->nodes = (opj_tgt_node_t *)__cil_tmp15;
  }
#line 75
  if (! tree->nodes) {
    {
#line 76
    free((void *)tree);
    }
#line 77
    return ((opj_tgt_tree_t *)((void *)0));
  }
#line 80
  node = tree->nodes;
#line 81
  parentnode = tree->nodes + tree->numleafsh * tree->numleafsv;
#line 82
  parentnode0 = parentnode;
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 84
    if (! (i < numlvls - 1)) {
#line 84
      goto while_break___0;
    }
#line 85
    j = 0;
    {
#line 85
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 85
      if (! (j < nplv[i])) {
#line 85
        goto while_break___1;
      }
#line 86
      k = nplh[i];
      {
#line 87
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 87
        k --;
#line 87
        if (! (k >= 0)) {
#line 87
          goto while_break___2;
        }
#line 88
        node->parent = parentnode;
#line 89
        node ++;
#line 90
        k --;
#line 90
        if (k >= 0) {
#line 91
          node->parent = parentnode;
#line 92
          node ++;
        }
#line 94
        parentnode ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: ;
#line 96
      if (j & 1) {
#line 97
        parentnode0 = parentnode;
      } else
#line 96
      if (j == nplv[i] - 1) {
#line 97
        parentnode0 = parentnode;
      } else {
#line 99
        parentnode = parentnode0;
#line 100
        parentnode0 += nplh[i];
      }
#line 85
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 84
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 104
  node->parent = (struct opj_tgt_node *)0;
#line 106
  tgt_reset(tree);
  }
#line 108
  return (tree);
}
}
#line 111 "/root/patchweave_new/2/libopenjpeg/tgt.c"
void tgt_destroy(opj_tgt_tree_t *tree ) 
{ 


  {
  {
#line 112
  free((void *)tree->nodes);
#line 113
  free((void *)tree);
  }
#line 115
  return;
}
}
#line 116 "/root/patchweave_new/2/libopenjpeg/tgt.c"
void tgt_reset(opj_tgt_tree_t *tree ) 
{ 
  int i ;

  {
#line 119
  if ((unsigned long )((void *)0) == (unsigned long )tree) {
#line 120
    return;
  }
#line 122
  i = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;

#line 122
    if (! (i < tree->numnodes)) {
#line 122
      goto while_break;
    }
#line 123
    (tree->nodes + i)->value = 999;
#line 124
    (tree->nodes + i)->low = 0;
#line 125
    (tree->nodes + i)->known = 0;
#line 122
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 126
  return;
}
}
#line 129 "/root/patchweave_new/2/libopenjpeg/tgt.c"
void tgt_setvalue(opj_tgt_tree_t *tree , int leafno , int value ) 
{ 
  opj_tgt_node_t *node ;

  {
#line 131
  node = tree->nodes + leafno;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;

#line 132
    if (node) {
#line 132
      if (! (node->value > value)) {
#line 132
        goto while_break;
      }
    } else {
#line 132
      goto while_break;
    }
#line 133
    node->value = value;
#line 134
    node = node->parent;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 138
  return;
}
}
#line 138 "/root/patchweave_new/2/libopenjpeg/tgt.c"
void tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  int low ;
  opj_tgt_node_t **__cil_tmp9 ;

  {
#line 144
  stkptr = stk;
#line 145
  node = tree->nodes + leafno;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;

#line 146
    if (! node->parent) {
#line 146
      goto while_break;
    }
#line 147
    __cil_tmp9 = stkptr;
#line 147
    stkptr ++;
#line 147
    *__cil_tmp9 = node;
#line 148
    node = node->parent;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 151
  low = 0;
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 153
    if (low > node->low) {
#line 154
      node->low = low;
    } else {
#line 156
      low = node->low;
    }
    {
#line 159
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 159
      if (! (low < threshold)) {
#line 159
        goto while_break___1;
      }
#line 160
      if (low >= node->value) {
#line 161
        if (! node->known) {
          {
#line 162
          bio_write(bio, 1, 1);
#line 163
          node->known = 1;
          }
        }
#line 165
        goto while_break___1;
      }
      {
#line 167
      bio_write(bio, 0, 1);
#line 168
      low ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 171
    node->low = low;
#line 172
    if ((unsigned long )stkptr == (unsigned long )(stk)) {
#line 173
      goto while_break___0;
    }
#line 174
    stkptr --;
#line 174
    node = *stkptr;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 178
  return;
}
}
#line 178 "/root/patchweave_new/2/libopenjpeg/tgt.c"
int tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  int low ;
  opj_tgt_node_t **__cil_tmp9 ;
  int __cil_tmp10 ;
  int tmp ;

  {
#line 184
  stkptr = stk;
#line 185
  node = tree->nodes + leafno;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;

#line 186
    if (! node->parent) {
#line 186
      goto while_break;
    }
#line 187
    __cil_tmp9 = stkptr;
#line 187
    stkptr ++;
#line 187
    *__cil_tmp9 = node;
#line 188
    node = node->parent;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 191
  low = 0;
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 193
    if (low > node->low) {
#line 194
      node->low = low;
    } else {
#line 196
      low = node->low;
    }
    {
#line 198
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 198
      if (low < threshold) {
#line 198
        if (! (low < node->value)) {
#line 198
          goto while_break___1;
        }
      } else {
#line 198
        goto while_break___1;
      }
      {
#line 199
      __cil_tmp10 = bio_read(bio, 1);
      }
#line 199
      if (__cil_tmp10) {
#line 200
        node->value = low;
      } else {
#line 202
        low ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 205
    node->low = low;
#line 206
    if ((unsigned long )stkptr == (unsigned long )(stk)) {
#line 207
      goto while_break___0;
    }
#line 209
    stkptr --;
#line 209
    node = *stkptr;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 212
  if (node->value < threshold) {
#line 212
    tmp = 1;
  } else {
#line 212
    tmp = 0;
  }
#line 212
  return (tmp);
}
}
#line 36 "/root/patchweave_new/2/libopenjpeg/tcd.c"
void tcd_dump(FILE *fd , opj_tcd_t *tcd , opj_tcd_image_t *img ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prec ;

  {
  {
#line 39
  fprintf(fd, "image {\n\220");
#line 40
  fprintf(fd, "  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\n", img->tw, img->th, (tcd->image)->x0,
          (tcd->image)->x1, (tcd->image)->y0, (tcd->image)->y1);
#line 43
  tileno = 0;
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;

#line 43
    if (! (tileno < img->th * img->tw)) {
#line 43
      goto while_break;
    }
    {
#line 44
    tile = (tcd->tcd_image)->tiles + tileno;
#line 45
    fprintf(fd, "  tile {\n");
#line 46
    fprintf(fd, "    x0=%d, y0=%d, x1=%d, y1=%d, numcomps=%d\n", tile->x0, tile->y0,
            tile->x1, tile->y1, tile->numcomps);
#line 48
    compno = 0;
    }
    {
#line 48
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 48
      if (! (compno < tile->numcomps)) {
#line 48
        goto while_break___0;
      }
      {
#line 49
      tilec = tile->comps + compno;
#line 50
      fprintf(fd, "    tilec {\n");
#line 51
      fprintf(fd, "      x0=%d, y0=%d, x1=%d, y1=%d, numresolutions=%d\n", tilec->x0,
              tilec->y0, tilec->x1, tilec->y1, tilec->numresolutions);
#line 54
      resno = 0;
      }
      {
#line 54
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 54
        if (! (resno < tilec->numresolutions)) {
#line 54
          goto while_break___1;
        }
        {
#line 55
        res = tilec->resolutions + resno;
#line 56
        fprintf(fd, "\n   res {\n");
#line 57
        fprintf(fd, "          x0=%d, y0=%d, x1=%d, y1=%d, pw=%d, ph=%d, numbands=%d\n\230\001",
                res->x0, res->y0, res->x1, res->y1, res->pw, res->ph, res->numbands);
#line 60
        bandno = 0;
        }
        {
#line 60
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 60
          if (! (bandno < res->numbands)) {
#line 60
            goto while_break___2;
          }
          {
#line 61
          band = & res->bands[bandno];
#line 62
          fprintf(fd, "        band {\n");
#line 63
          fprintf(fd, "          x0=%d, y0=%d, x1=%d, y1=%d, stepsize=%f, numbps=%d\n",
                  band->x0, band->y0, band->x1, band->y1, (double )band->stepsize,
                  band->numbps);
#line 66
          precno = 0;
          }
          {
#line 66
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 66
            if (! (precno < res->pw * res->ph)) {
#line 66
              goto while_break___3;
            }
            {
#line 67
            prec = band->precincts + precno;
#line 68
            fprintf(fd, "          prec {\n");
#line 69
            fprintf(fd, "            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\n",
                    prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);
#line 82
            fprintf(fd, "          }\n");
#line 66
            precno ++;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___3: 
          {
#line 84
          fprintf(fd, "        }\n");
#line 60
          bandno ++;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: 
        {
#line 86
        fprintf(fd, "      }\n\220");
#line 54
        resno ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 88
      fprintf(fd, "    }\n");
#line 48
      compno ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 90
    fprintf(fd, "  }\n");
#line 43
    tileno ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 92
  fprintf(fd, "}\n");
  }
#line 94
  return;
}
}
#line 100 "/root/patchweave_new/2/libopenjpeg/tcd.c"
opj_tcd_t *tcd_create(opj_common_ptr cinfo ) 
{ 
  opj_tcd_t *tcd ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 102
  __cil_tmp3 = malloc(sizeof(opj_tcd_t ));
#line 102
  tcd = (opj_tcd_t *)__cil_tmp3;
  }
#line 103
  if (! tcd) {
#line 103
    return ((opj_tcd_t *)((void *)0));
  }
  {
#line 104
  tcd->cinfo = cinfo;
#line 105
  __cil_tmp4 = malloc(sizeof(opj_tcd_image_t ));
#line 105
  tcd->tcd_image = (opj_tcd_image_t *)__cil_tmp4;
  }
#line 106
  if (! tcd->tcd_image) {
    {
#line 107
    free((void *)tcd);
    }
#line 108
    return ((opj_tcd_t *)((void *)0));
  }
#line 111
  return (tcd);
}
}
#line 117 "/root/patchweave_new/2/libopenjpeg/tcd.c"
void tcd_destroy(opj_tcd_t *tcd ) 
{ 


  {
#line 118
  if (tcd) {
    {
#line 119
    free((void *)tcd->tcd_image);
#line 120
    free((void *)tcd);
    }
  }
#line 123
  return;
}
}
#line 126 "/root/patchweave_new/2/libopenjpeg/tcd.c"
void tcd_malloc_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  void *__cil_tmp11 ;
  opj_tcp_t *tcp ;
  int j ;
  int p ;
  int q ;
  opj_tcd_tile_t *tile ;
  float tmp ;
  float tmp___0 ;
  void *__cil_tmp24 ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int tmp___1 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int x0b ;
  int y0b ;
  int i ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int tmp___6 ;
  double __cil_tmp86 ;
  void *__cil_tmp87 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  void *__cil_tmp106 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_enc_t *cblk ;
  void *__cil_tmp118 ;
  void *__cil_tmp119 ;
  void *__cil_tmp120 ;

  {
  {
#line 129
  tcd->image = image;
#line 130
  tcd->cp = cp;
#line 131
  (tcd->tcd_image)->tw = cp->tw;
#line 132
  (tcd->tcd_image)->th = cp->th;
#line 133
  __cil_tmp11 = malloc(sizeof(opj_tcd_tile_t ));
#line 133
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp11;
#line 135
  tileno = 0;
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;

#line 135
    if (! (tileno < 1)) {
#line 135
      goto while_break;
    }
    {
#line 136
    tcp = cp->tcps + curtileno;
#line 140
    p = curtileno % cp->tw;
#line 141
    q = curtileno / cp->tw;
#line 144
    tile = (tcd->tcd_image)->tiles;
#line 147
    tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 148
    tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 149
    tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 150
    tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 151
    tile->numcomps = image->numcomps;
#line 155
    j = 0;
    }
    {
#line 155
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 155
      if (! (j < tcp->numlayers)) {
#line 155
        goto while_break___0;
      }
#line 156
      if (tcp->rates[j]) {
#line 156
        if ((int )cp->tp_on) {
#line 156
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy) - (float )(((tcd->cur_totnum_tp - 1) * 14) / tcp->numlayers);
        } else {
#line 156
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
        }
#line 156
        tmp___0 = tmp;
      } else {
#line 156
        tmp___0 = (float )0;
      }
#line 156
      tcp->rates[j] = tmp___0;
#line 171
      if (tcp->rates[j]) {
#line 172
        if (j) {
#line 172
          if (tcp->rates[j] < tcp->rates[j - 1] + (float )10) {
#line 173
            tcp->rates[j] = tcp->rates[j - 1] + (float )20;
          } else {
#line 172
            goto _L;
          }
        } else
        _L: 
#line 175
        if (! j) {
#line 175
          if (tcp->rates[j] < (float )30) {
#line 176
            tcp->rates[j] = (float )30;
          }
        }
#line 179
        if (j == tcp->numlayers - 1) {
#line 180
          tcp->rates[j] -= (float )2;
        }
      }
#line 155
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 186
    __cil_tmp24 = malloc((unsigned long )image->numcomps * sizeof(opj_tcd_tilecomp_t ));
#line 186
    tile->comps = (opj_tcd_tilecomp_t *)__cil_tmp24;
#line 187
    compno = 0;
    }
    {
#line 187
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 187
      if (! (compno < tile->numcomps)) {
#line 187
        goto while_break___1;
      }
      {
#line 188
      tccp = tcp->tccps + compno;
#line 190
      tilec = tile->comps + compno;
#line 193
      tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 194
      tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 195
      tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 196
      tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 198
      __cil_tmp31 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)) * sizeof(int ));
#line 198
      tilec->data = (int *)__cil_tmp31;
#line 199
      tilec->numresolutions = tccp->numresolutions;
#line 201
      __cil_tmp32 = malloc((unsigned long )tilec->numresolutions * sizeof(opj_tcd_resolution_t ));
#line 201
      tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp32;
#line 203
      resno = 0;
      }
      {
#line 203
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 203
        if (! (resno < tilec->numresolutions)) {
#line 203
          goto while_break___2;
        }
        {
#line 205
        levelno = (tilec->numresolutions - 1) - resno;
#line 211
        res = tilec->resolutions + resno;
#line 214
        res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 215
        res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 216
        res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 217
        res->y1 = int_ceildivpow2(tilec->y1, levelno);
        }
#line 219
        if (resno == 0) {
#line 219
          tmp___1 = 1;
        } else {
#line 219
          tmp___1 = 3;
        }
#line 219
        res->numbands = tmp___1;
#line 221
        if (tccp->csty & 1) {
#line 222
          pdx = tccp->prcw[resno];
#line 223
          pdy = tccp->prch[resno];
        } else {
#line 225
          pdx = 15;
#line 226
          pdy = 15;
        }
        {
#line 229
        __cil_tmp54 = int_floordivpow2(res->x0, pdx);
#line 229
        tlprcxstart = __cil_tmp54 << pdx;
#line 230
        __cil_tmp55 = int_floordivpow2(res->y0, pdy);
#line 230
        tlprcystart = __cil_tmp55 << pdy;
#line 232
        __cil_tmp56 = int_ceildivpow2(res->x1, pdx);
#line 232
        brprcxend = __cil_tmp56 << pdx;
#line 233
        __cil_tmp57 = int_ceildivpow2(res->y1, pdy);
#line 233
        brprcyend = __cil_tmp57 << pdy;
#line 235
        res->pw = (brprcxend - tlprcxstart) >> pdx;
#line 236
        res->ph = (brprcyend - tlprcystart) >> pdy;
        }
#line 238
        if (resno == 0) {
#line 239
          tlcbgxstart = tlprcxstart;
#line 240
          tlcbgystart = tlprcystart;
#line 241
          brcbgxend = brprcxend;
#line 242
          brcbgyend = brprcyend;
#line 243
          cbgwidthexpn = pdx;
#line 244
          cbgheightexpn = pdy;
        } else {
          {
#line 246
          tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 247
          tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 248
          brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 249
          brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 250
          cbgwidthexpn = pdx - 1;
#line 251
          cbgheightexpn = pdy - 1;
          }
        }
        {
#line 254
        cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 255
        cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 257
        bandno = 0;
        }
        {
#line 257
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 257
          if (! (bandno < res->numbands)) {
#line 257
            goto while_break___3;
          }
#line 260
          ss = (opj_stepsize_t *)((void *)0);
#line 262
          band = & res->bands[bandno];
#line 264
          if (resno == 0) {
#line 264
            tmp___2 = 0;
          } else {
#line 264
            tmp___2 = bandno + 1;
          }
#line 264
          band->bandno = tmp___2;
#line 265
          if (band->bandno == 1) {
#line 265
            tmp___3 = 1;
          } else
#line 265
          if (band->bandno == 3) {
#line 265
            tmp___3 = 1;
          } else {
#line 265
            tmp___3 = 0;
          }
#line 265
          x0b = tmp___3;
#line 266
          if (band->bandno == 2) {
#line 266
            tmp___4 = 1;
          } else
#line 266
          if (band->bandno == 3) {
#line 266
            tmp___4 = 1;
          } else {
#line 266
            tmp___4 = 0;
          }
#line 266
          y0b = tmp___4;
#line 268
          if (band->bandno == 0) {
            {
#line 270
            band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 271
            band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 272
            band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 273
            band->y1 = int_ceildivpow2(tilec->y1, levelno);
            }
          } else {
            {
#line 276
            band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 277
            band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 278
            band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 279
            band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
            }
          }
#line 282
          if (resno == 0) {
#line 282
            tmp___5 = 0;
          } else {
#line 282
            tmp___5 = (3 * (resno - 1) + bandno) + 1;
          }
#line 282
          ss = & tccp->stepsizes[tmp___5];
#line 283
          if (tccp->qmfbid == 0) {
            {
#line 283
            __cil_tmp83 = dwt_getgain_real(band->bandno);
#line 283
            tmp___6 = __cil_tmp83;
            }
          } else {
            {
#line 283
            __cil_tmp84 = dwt_getgain(band->bandno);
#line 283
            tmp___6 = __cil_tmp84;
            }
          }
          {
#line 283
          gain = tmp___6;
#line 284
          numbps = (image->comps + compno)->prec + gain;
#line 286
          __cil_tmp86 = pow(2., (double )(numbps - ss->expn));
#line 286
          band->stepsize = (float )((1. + (double )ss->mant / 2048.) * __cil_tmp86);
#line 287
          band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 289
          __cil_tmp87 = malloc((unsigned long )((3 * res->pw) * res->ph) * sizeof(opj_tcd_precinct_t ));
#line 289
          band->precincts = (opj_tcd_precinct_t *)__cil_tmp87;
#line 291
          i = 0;
          }
          {
#line 291
          while (1) {
            while_continue___4: /* CIL Label */ ;

#line 291
            if (! (i < (res->pw * res->ph) * 3)) {
#line 291
              goto while_break___4;
            }
#line 292
            (band->precincts + i)->imsbtree = (opj_tgt_tree_t *)((void *)0);
#line 293
            (band->precincts + i)->incltree = (opj_tgt_tree_t *)((void *)0);
#line 294
            (band->precincts + i)->cblks.enc = (opj_tcd_cblk_enc_t *)((void *)0);
#line 291
            i ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___4: 
#line 297
          precno = 0;
          {
#line 297
          while (1) {
            while_continue___5: /* CIL Label */ ;

#line 297
            if (! (precno < res->pw * res->ph)) {
#line 297
              goto while_break___5;
            }
            {
#line 300
            cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 301
            cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 302
            cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 303
            cbgyend = cbgystart + (1 << cbgheightexpn);
#line 305
            prc = band->precincts + precno;
#line 308
            prc->x0 = int_max(cbgxstart, band->x0);
#line 309
            prc->y0 = int_max(cbgystart, band->y0);
#line 310
            prc->x1 = int_min(cbgxend, band->x1);
#line 311
            prc->y1 = int_min(cbgyend, band->y1);
#line 313
            __cil_tmp102 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 313
            tlcblkxstart = __cil_tmp102 << cblkwidthexpn;
#line 314
            __cil_tmp103 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 314
            tlcblkystart = __cil_tmp103 << cblkheightexpn;
#line 315
            __cil_tmp104 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 315
            brcblkxend = __cil_tmp104 << cblkwidthexpn;
#line 316
            __cil_tmp105 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 316
            brcblkyend = __cil_tmp105 << cblkheightexpn;
#line 317
            prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 318
            prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 320
            __cil_tmp106 = calloc((unsigned long )(prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t ));
#line 320
            prc->cblks.enc = (opj_tcd_cblk_enc_t *)__cil_tmp106;
#line 321
            prc->incltree = tgt_create(prc->cw, prc->ch);
#line 322
            prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 324
            cblkno = 0;
            }
            {
#line 324
            while (1) {
              while_continue___6: /* CIL Label */ ;

#line 324
              if (! (cblkno < prc->cw * prc->ch)) {
#line 324
                goto while_break___6;
              }
              {
#line 325
              cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 326
              cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 327
              cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 328
              cblkyend = cblkystart + (1 << cblkheightexpn);
#line 330
              cblk = prc->cblks.enc + cblkno;
#line 333
              cblk->x0 = int_max(cblkxstart, prc->x0);
#line 334
              cblk->y0 = int_max(cblkystart, prc->y0);
#line 335
              cblk->x1 = int_min(cblkxend, prc->x1);
#line 336
              cblk->y1 = int_min(cblkyend, prc->y1);
#line 337
              __cil_tmp118 = calloc(9730UL, sizeof(unsigned char ));
#line 337
              cblk->data = (unsigned char *)__cil_tmp118;
#line 339
              *(cblk->data + 0) = (unsigned char)0;
#line 340
              *(cblk->data + 1) = (unsigned char)0;
#line 341
              cblk->data += 2;
#line 342
              __cil_tmp119 = calloc(100UL, sizeof(opj_tcd_layer_t ));
#line 342
              cblk->layers = (opj_tcd_layer_t *)__cil_tmp119;
#line 343
              __cil_tmp120 = calloc(100UL, sizeof(opj_tcd_pass_t ));
#line 343
              cblk->passes = (opj_tcd_pass_t *)__cil_tmp120;
#line 324
              cblkno ++;
              }
            }
            while_break___14: /* CIL Label */ ;
            }
            while_break___6: 
#line 297
            precno ++;
          }
          while_break___13: /* CIL Label */ ;
          }
          while_break___5: 
#line 257
          bandno ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___3: 
#line 203
        resno ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___2: 
#line 187
      compno ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___1: 
#line 135
    tileno ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 139
  return;
}
}
#line 354 "/root/patchweave_new/2/libopenjpeg/tcd.c"
void tcd_free_encode(opj_tcd_t *tcd ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;

  {
#line 357
  tileno = 0;
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;

#line 357
    if (! (tileno < 1)) {
#line 357
      goto while_break;
    }
#line 358
    tile = (tcd->tcd_image)->tiles;
#line 360
    compno = 0;
    {
#line 360
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 360
      if (! (compno < tile->numcomps)) {
#line 360
        goto while_break___0;
      }
#line 361
      tilec = tile->comps + compno;
#line 363
      resno = 0;
      {
#line 363
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 363
        if (! (resno < tilec->numresolutions)) {
#line 363
          goto while_break___1;
        }
#line 364
        res = tilec->resolutions + resno;
#line 366
        bandno = 0;
        {
#line 366
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 366
          if (! (bandno < res->numbands)) {
#line 366
            goto while_break___2;
          }
#line 367
          band = & res->bands[bandno];
#line 369
          precno = 0;
          {
#line 369
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 369
            if (! (precno < res->pw * res->ph)) {
#line 369
              goto while_break___3;
            }
#line 370
            prc = band->precincts + precno;
#line 372
            if ((unsigned long )prc->incltree != (unsigned long )((void *)0)) {
              {
#line 373
              tgt_destroy(prc->incltree);
#line 374
              prc->incltree = (opj_tgt_tree_t *)((void *)0);
              }
            }
#line 376
            if ((unsigned long )prc->imsbtree != (unsigned long )((void *)0)) {
              {
#line 377
              tgt_destroy(prc->imsbtree);
#line 378
              prc->imsbtree = (opj_tgt_tree_t *)((void *)0);
              }
            }
#line 380
            cblkno = 0;
            {
#line 380
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 380
              if (! (cblkno < prc->cw * prc->ch)) {
#line 380
                goto while_break___4;
              }
              {
#line 381
              free((void *)((prc->cblks.enc + cblkno)->data - 2));
#line 382
              free((void *)(prc->cblks.enc + cblkno)->layers);
#line 383
              free((void *)(prc->cblks.enc + cblkno)->passes);
#line 380
              cblkno ++;
              }
            }
            while_break___10: /* CIL Label */ ;
            }
            while_break___4: 
            {
#line 385
            free((void *)prc->cblks.enc);
#line 369
            precno ++;
            }
          }
          while_break___9: /* CIL Label */ ;
          }
          while_break___3: 
          {
#line 387
          free((void *)band->precincts);
#line 388
          band->precincts = (opj_tcd_precinct_t *)((void *)0);
#line 366
          bandno ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: 
#line 363
        resno ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 391
      free((void *)tilec->resolutions);
#line 392
      tilec->resolutions = (opj_tcd_resolution_t *)((void *)0);
#line 360
      compno ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 394
    free((void *)tile->comps);
#line 395
    tile->comps = (opj_tcd_tilecomp_t *)((void *)0);
#line 357
    tileno ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
  {
#line 397
  free((void *)(tcd->tcd_image)->tiles);
#line 398
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)((void *)0);
  }
#line 400
  return;
}
}
#line 401 "/root/patchweave_new/2/libopenjpeg/tcd.c"
void tcd_init_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcp_t *tcp ;
  int j ;
  int p ;
  int q ;
  opj_tcd_tile_t *tile ;
  float tmp ;
  float tmp___0 ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  void *__cil_tmp29 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int tmp___1 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int x0b ;
  int y0b ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int tmp___6 ;
  double __cil_tmp82 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  void *__cil_tmp100 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_enc_t *cblk ;
  void *__cil_tmp112 ;
  void *__cil_tmp113 ;
  void *__cil_tmp114 ;

  {
#line 404
  tileno = 0;
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;

#line 404
    if (! (tileno < 1)) {
#line 404
      goto while_break;
    }
    {
#line 405
    tcp = cp->tcps + curtileno;
#line 408
    p = curtileno % cp->tw;
#line 409
    q = curtileno / cp->tw;
#line 411
    tile = (tcd->tcd_image)->tiles;
#line 414
    tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 415
    tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 416
    tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 417
    tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 419
    tile->numcomps = image->numcomps;
#line 423
    j = 0;
    }
    {
#line 423
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 423
      if (! (j < tcp->numlayers)) {
#line 423
        goto while_break___0;
      }
#line 424
      if (tcp->rates[j]) {
#line 424
        if ((int )cp->tp_on) {
#line 424
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy) - (float )(((tcd->cur_totnum_tp - 1) * 14) / tcp->numlayers);
        } else {
#line 424
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
        }
#line 424
        tmp___0 = tmp;
      } else {
#line 424
        tmp___0 = (float )0;
      }
#line 424
      tcp->rates[j] = tmp___0;
#line 439
      if (tcp->rates[j]) {
#line 440
        if (j) {
#line 440
          if (tcp->rates[j] < tcp->rates[j - 1] + (float )10) {
#line 441
            tcp->rates[j] = tcp->rates[j - 1] + (float )20;
          } else {
#line 440
            goto _L;
          }
        } else
        _L: 
#line 443
        if (! j) {
#line 443
          if (tcp->rates[j] < (float )30) {
#line 444
            tcp->rates[j] = (float )30;
          }
        }
      }
#line 423
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___0: 
#line 451
    compno = 0;
    {
#line 451
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 451
      if (! (compno < tile->numcomps)) {
#line 451
        goto while_break___1;
      }
      {
#line 452
      tccp = tcp->tccps + compno;
#line 454
      tilec = tile->comps + compno;
#line 457
      tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 458
      tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 459
      tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 460
      tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 462
      __cil_tmp29 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)) * sizeof(int ));
#line 462
      tilec->data = (int *)__cil_tmp29;
#line 463
      tilec->numresolutions = tccp->numresolutions;
#line 465
      resno = 0;
      }
      {
#line 465
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 465
        if (! (resno < tilec->numresolutions)) {
#line 465
          goto while_break___2;
        }
        {
#line 468
        levelno = (tilec->numresolutions - 1) - resno;
#line 474
        res = tilec->resolutions + resno;
#line 477
        res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 478
        res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 479
        res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 480
        res->y1 = int_ceildivpow2(tilec->y1, levelno);
        }
#line 481
        if (resno == 0) {
#line 481
          tmp___1 = 1;
        } else {
#line 481
          tmp___1 = 3;
        }
#line 481
        res->numbands = tmp___1;
#line 484
        if (tccp->csty & 1) {
#line 485
          pdx = tccp->prcw[resno];
#line 486
          pdy = tccp->prch[resno];
        } else {
#line 488
          pdx = 15;
#line 489
          pdy = 15;
        }
        {
#line 492
        __cil_tmp51 = int_floordivpow2(res->x0, pdx);
#line 492
        tlprcxstart = __cil_tmp51 << pdx;
#line 493
        __cil_tmp52 = int_floordivpow2(res->y0, pdy);
#line 493
        tlprcystart = __cil_tmp52 << pdy;
#line 494
        __cil_tmp53 = int_ceildivpow2(res->x1, pdx);
#line 494
        brprcxend = __cil_tmp53 << pdx;
#line 495
        __cil_tmp54 = int_ceildivpow2(res->y1, pdy);
#line 495
        brprcyend = __cil_tmp54 << pdy;
#line 497
        res->pw = (brprcxend - tlprcxstart) >> pdx;
#line 498
        res->ph = (brprcyend - tlprcystart) >> pdy;
        }
#line 500
        if (resno == 0) {
#line 501
          tlcbgxstart = tlprcxstart;
#line 502
          tlcbgystart = tlprcystart;
#line 503
          brcbgxend = brprcxend;
#line 504
          brcbgyend = brprcyend;
#line 505
          cbgwidthexpn = pdx;
#line 506
          cbgheightexpn = pdy;
        } else {
          {
#line 508
          tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 509
          tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 510
          brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 511
          brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 512
          cbgwidthexpn = pdx - 1;
#line 513
          cbgheightexpn = pdy - 1;
          }
        }
        {
#line 516
        cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 517
        cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 519
        bandno = 0;
        }
        {
#line 519
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 519
          if (! (bandno < res->numbands)) {
#line 519
            goto while_break___3;
          }
#line 522
          ss = (opj_stepsize_t *)((void *)0);
#line 524
          band = & res->bands[bandno];
#line 526
          if (resno == 0) {
#line 526
            tmp___2 = 0;
          } else {
#line 526
            tmp___2 = bandno + 1;
          }
#line 526
          band->bandno = tmp___2;
#line 527
          if (band->bandno == 1) {
#line 527
            tmp___3 = 1;
          } else
#line 527
          if (band->bandno == 3) {
#line 527
            tmp___3 = 1;
          } else {
#line 527
            tmp___3 = 0;
          }
#line 527
          x0b = tmp___3;
#line 528
          if (band->bandno == 2) {
#line 528
            tmp___4 = 1;
          } else
#line 528
          if (band->bandno == 3) {
#line 528
            tmp___4 = 1;
          } else {
#line 528
            tmp___4 = 0;
          }
#line 528
          y0b = tmp___4;
#line 530
          if (band->bandno == 0) {
            {
#line 532
            band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 533
            band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 534
            band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 535
            band->y1 = int_ceildivpow2(tilec->y1, levelno);
            }
          } else {
            {
#line 537
            band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 538
            band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 539
            band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 540
            band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
            }
          }
#line 543
          if (resno == 0) {
#line 543
            tmp___5 = 0;
          } else {
#line 543
            tmp___5 = (3 * (resno - 1) + bandno) + 1;
          }
#line 543
          ss = & tccp->stepsizes[tmp___5];
#line 544
          if (tccp->qmfbid == 0) {
            {
#line 544
            __cil_tmp79 = dwt_getgain_real(band->bandno);
#line 544
            tmp___6 = __cil_tmp79;
            }
          } else {
            {
#line 544
            __cil_tmp80 = dwt_getgain(band->bandno);
#line 544
            tmp___6 = __cil_tmp80;
            }
          }
          {
#line 544
          gain = tmp___6;
#line 545
          numbps = (image->comps + compno)->prec + gain;
#line 546
          __cil_tmp82 = pow(2., (double )(numbps - ss->expn));
#line 546
          band->stepsize = (float )((1. + (double )ss->mant / 2048.) * __cil_tmp82);
#line 547
          band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 549
          precno = 0;
          }
          {
#line 549
          while (1) {
            while_continue___4: /* CIL Label */ ;

#line 549
            if (! (precno < res->pw * res->ph)) {
#line 549
              goto while_break___4;
            }
            {
#line 552
            cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 553
            cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 554
            cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 555
            cbgyend = cbgystart + (1 << cbgheightexpn);
#line 557
            prc = band->precincts + precno;
#line 560
            prc->x0 = int_max(cbgxstart, band->x0);
#line 561
            prc->y0 = int_max(cbgystart, band->y0);
#line 562
            prc->x1 = int_min(cbgxend, band->x1);
#line 563
            prc->y1 = int_min(cbgyend, band->y1);
#line 565
            __cil_tmp96 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 565
            tlcblkxstart = __cil_tmp96 << cblkwidthexpn;
#line 566
            __cil_tmp97 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 566
            tlcblkystart = __cil_tmp97 << cblkheightexpn;
#line 567
            __cil_tmp98 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 567
            brcblkxend = __cil_tmp98 << cblkwidthexpn;
#line 568
            __cil_tmp99 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 568
            brcblkyend = __cil_tmp99 << cblkheightexpn;
#line 569
            prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 570
            prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 572
            free((void *)prc->cblks.enc);
#line 573
            __cil_tmp100 = calloc((unsigned long )(prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t ));
#line 573
            prc->cblks.enc = (opj_tcd_cblk_enc_t *)__cil_tmp100;
            }
#line 575
            if ((unsigned long )prc->incltree != (unsigned long )((void *)0)) {
              {
#line 576
              tgt_destroy(prc->incltree);
              }
            }
#line 578
            if ((unsigned long )prc->imsbtree != (unsigned long )((void *)0)) {
              {
#line 579
              tgt_destroy(prc->imsbtree);
              }
            }
            {
#line 582
            prc->incltree = tgt_create(prc->cw, prc->ch);
#line 583
            prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 585
            cblkno = 0;
            }
            {
#line 585
            while (1) {
              while_continue___5: /* CIL Label */ ;

#line 585
              if (! (cblkno < prc->cw * prc->ch)) {
#line 585
                goto while_break___5;
              }
              {
#line 586
              cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 587
              cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 588
              cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 589
              cblkyend = cblkystart + (1 << cblkheightexpn);
#line 591
              cblk = prc->cblks.enc + cblkno;
#line 594
              cblk->x0 = int_max(cblkxstart, prc->x0);
#line 595
              cblk->y0 = int_max(cblkystart, prc->y0);
#line 596
              cblk->x1 = int_min(cblkxend, prc->x1);
#line 597
              cblk->y1 = int_min(cblkyend, prc->y1);
#line 598
              __cil_tmp112 = calloc(8194UL, sizeof(unsigned char ));
#line 598
              cblk->data = (unsigned char *)__cil_tmp112;
#line 600
              *(cblk->data + 0) = (unsigned char)0;
#line 601
              *(cblk->data + 1) = (unsigned char)0;
#line 602
              cblk->data += 2;
#line 603
              __cil_tmp113 = calloc(100UL, sizeof(opj_tcd_layer_t ));
#line 603
              cblk->layers = (opj_tcd_layer_t *)__cil_tmp113;
#line 604
              __cil_tmp114 = calloc(100UL, sizeof(opj_tcd_pass_t ));
#line 604
              cblk->passes = (opj_tcd_pass_t *)__cil_tmp114;
#line 585
              cblkno ++;
              }
            }
            while_break___12: /* CIL Label */ ;
            }
            while_break___5: 
#line 549
            precno ++;
          }
          while_break___11: /* CIL Label */ ;
          }
          while_break___4: 
#line 519
          bandno ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___3: 
#line 465
        resno ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___2: 
#line 451
      compno ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___1: 
#line 404
    tileno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: ;
#line 408
  return;
}
}
#line 615 "/root/patchweave_new/2/libopenjpeg/tcd.c"
void tcd_malloc_decode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp ) 
{ 
  int i ;
  int j ;
  int tileno ;
  int p ;
  int q ;
  unsigned int x0 ;
  unsigned int y0___0 ;
  unsigned int x1 ;
  unsigned int y1___0 ;
  unsigned int w ;
  unsigned int h ;
  void *__cil_tmp15 ;
  opj_tcd_tile_t *tile ;
  void *__cil_tmp17 ;
  opj_tcd_tile_t *tile___0 ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp29 ;
  int tmp ;
  int __cil_tmp31 ;
  int tmp___0 ;
  int __cil_tmp33 ;
  int tmp___1 ;
  int __cil_tmp35 ;
  int tmp___2 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;

  {
  {
#line 617
  x0 = 0U;
#line 617
  y0___0 = 0U;
#line 617
  x1 = 0U;
#line 617
  y1___0 = 0U;
#line 619
  tcd->image = image;
#line 620
  (tcd->tcd_image)->tw = cp->tw;
#line 621
  (tcd->tcd_image)->th = cp->th;
#line 622
  __cil_tmp15 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcd_tile_t ));
#line 622
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp15;
#line 629
  j = 0;
  }
  {
#line 629
  while (1) {
    while_continue: /* CIL Label */ ;

#line 629
    if (! (j < cp->tileno_size)) {
#line 629
      goto while_break;
    }
    {
#line 632
    tileno = *(cp->tileno + j);
#line 633
    tile = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 634
    tile->numcomps = image->numcomps;
#line 635
    __cil_tmp17 = calloc((unsigned long )image->numcomps, sizeof(opj_tcd_tilecomp_t ));
#line 635
    tile->comps = (opj_tcd_tilecomp_t *)__cil_tmp17;
#line 629
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 638
  i = 0;
  {
#line 638
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 638
    if (! (i < image->numcomps)) {
#line 638
      goto while_break___0;
    }
#line 639
    j = 0;
    {
#line 639
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 639
      if (! (j < cp->tileno_size)) {
#line 639
        goto while_break___1;
      }
      {
#line 645
      tileno = *(cp->tileno + j);
#line 647
      tile___0 = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 648
      tilec = tile___0->comps + i;
#line 650
      p = tileno % cp->tw;
#line 651
      q = tileno / cp->tw;
#line 654
      tile___0->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 655
      tile___0->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 656
      tile___0->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 657
      tile___0->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 659
      tilec->x0 = int_ceildiv(tile___0->x0, (image->comps + i)->dx);
#line 660
      tilec->y0 = int_ceildiv(tile___0->y0, (image->comps + i)->dy);
#line 661
      tilec->x1 = int_ceildiv(tile___0->x1, (image->comps + i)->dx);
#line 662
      tilec->y1 = int_ceildiv(tile___0->y1, (image->comps + i)->dy);
      }
#line 664
      if (j == 0) {
#line 664
        tmp = tilec->x0;
      } else {
        {
#line 664
        __cil_tmp29 = int_min((int )x0, (int )((unsigned int )tilec->x0));
#line 664
        tmp = __cil_tmp29;
        }
      }
#line 664
      x0 = (unsigned int )tmp;
#line 665
      if (j == 0) {
#line 665
        tmp___0 = tilec->y0;
      } else {
        {
#line 665
        __cil_tmp31 = int_min((int )y0___0, (int )((unsigned int )tilec->y0));
#line 665
        tmp___0 = __cil_tmp31;
        }
      }
#line 665
      y0___0 = (unsigned int )tmp___0;
#line 666
      if (j == 0) {
#line 666
        tmp___1 = tilec->x1;
      } else {
        {
#line 666
        __cil_tmp33 = int_max((int )x1, (int )((unsigned int )tilec->x1));
#line 666
        tmp___1 = __cil_tmp33;
        }
      }
#line 666
      x1 = (unsigned int )tmp___1;
#line 667
      if (j == 0) {
#line 667
        tmp___2 = tilec->y1;
      } else {
        {
#line 667
        __cil_tmp35 = int_max((int )y1___0, (int )((unsigned int )tilec->y1));
#line 667
        tmp___2 = __cil_tmp35;
        }
      }
#line 667
      y1___0 = (unsigned int )tmp___2;
#line 639
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 670
    __cil_tmp38 = int_ceildivpow2((int )(x1 - x0), (image->comps + i)->factor);
#line 670
    w = (unsigned int )__cil_tmp38;
#line 671
    __cil_tmp39 = int_ceildivpow2((int )(y1___0 - y0___0), (image->comps + i)->factor);
#line 671
    h = (unsigned int )__cil_tmp39;
#line 673
    (image->comps + i)->w = (int )w;
#line 674
    (image->comps + i)->h = (int )h;
#line 675
    (image->comps + i)->x0 = (int )x0;
#line 676
    (image->comps + i)->y0 = (int )y0___0;
#line 638
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 642
  return;
}
}
#line 680 "/root/patchweave_new/2/libopenjpeg/tcd.c"
void tcd_malloc_decode_tile(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int tileno ,
                            opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcp_t *tcp ;
  opj_tcd_tile_t *tile ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  void *__cil_tmp19 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int tmp ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int tmp___0 ;
  int tmp___1 ;
  int x0b ;
  int y0b ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int tmp___6 ;
  double __cil_tmp74 ;
  void *__cil_tmp75 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  void *__cil_tmp93 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_dec_t *cblk ;

  {
#line 687
  tcd->cp = cp;
#line 689
  tcp = cp->tcps + *(cp->tileno + tileno);
#line 690
  tile = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 692
  tileno = *(cp->tileno + tileno);
#line 694
  compno = 0;
  {
#line 694
  while (1) {
    while_continue: /* CIL Label */ ;

#line 694
    if (! (compno < tile->numcomps)) {
#line 694
      goto while_break;
    }
#line 695
    tccp = tcp->tccps + compno;
#line 696
    tilec = tile->comps + compno;
#line 698
    if (tccp->numresolutions <= 0) {
#line 700
      *(cp->tileno + tileno) = -1;
#line 701
      return;
    }
    {
#line 705
    tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 706
    tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 707
    tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 708
    tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 710
    tilec->numresolutions = tccp->numresolutions;
#line 711
    __cil_tmp19 = malloc((unsigned long )tilec->numresolutions * sizeof(opj_tcd_resolution_t ));
#line 711
    tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp19;
#line 713
    resno = 0;
    }
    {
#line 713
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 713
      if (! (resno < tilec->numresolutions)) {
#line 713
        goto while_break___0;
      }
      {
#line 715
      levelno = (tilec->numresolutions - 1) - resno;
#line 721
      res = tilec->resolutions + resno;
#line 724
      res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 725
      res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 726
      res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 727
      res->y1 = int_ceildivpow2(tilec->y1, levelno);
      }
#line 728
      if (resno == 0) {
#line 728
        tmp = 1;
      } else {
#line 728
        tmp = 3;
      }
#line 728
      res->numbands = tmp;
#line 731
      if (tccp->csty & 1) {
#line 732
        pdx = tccp->prcw[resno];
#line 733
        pdy = tccp->prch[resno];
      } else {
#line 735
        pdx = 15;
#line 736
        pdy = 15;
      }
      {
#line 740
      __cil_tmp41 = int_floordivpow2(res->x0, pdx);
#line 740
      tlprcxstart = __cil_tmp41 << pdx;
#line 741
      __cil_tmp42 = int_floordivpow2(res->y0, pdy);
#line 741
      tlprcystart = __cil_tmp42 << pdy;
#line 742
      __cil_tmp43 = int_ceildivpow2(res->x1, pdx);
#line 742
      brprcxend = __cil_tmp43 << pdx;
#line 743
      __cil_tmp44 = int_ceildivpow2(res->y1, pdy);
#line 743
      brprcyend = __cil_tmp44 << pdy;
      }
#line 745
      if (res->x0 == res->x1) {
#line 745
        tmp___0 = 0;
      } else {
#line 745
        tmp___0 = (brprcxend - tlprcxstart) >> pdx;
      }
#line 745
      res->pw = tmp___0;
#line 746
      if (res->y0 == res->y1) {
#line 746
        tmp___1 = 0;
      } else {
#line 746
        tmp___1 = (brprcyend - tlprcystart) >> pdy;
      }
#line 746
      res->ph = tmp___1;
#line 748
      if (resno == 0) {
#line 749
        tlcbgxstart = tlprcxstart;
#line 750
        tlcbgystart = tlprcystart;
#line 751
        brcbgxend = brprcxend;
#line 752
        brcbgyend = brprcyend;
#line 753
        cbgwidthexpn = pdx;
#line 754
        cbgheightexpn = pdy;
      } else {
        {
#line 756
        tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 757
        tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 758
        brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 759
        brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 760
        cbgwidthexpn = pdx - 1;
#line 761
        cbgheightexpn = pdy - 1;
        }
      }
      {
#line 764
      cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 765
      cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 767
      bandno = 0;
      }
      {
#line 767
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 767
        if (! (bandno < res->numbands)) {
#line 767
          goto while_break___1;
        }
#line 770
        ss = (opj_stepsize_t *)((void *)0);
#line 772
        band = & res->bands[bandno];
#line 773
        if (resno == 0) {
#line 773
          tmp___2 = 0;
        } else {
#line 773
          tmp___2 = bandno + 1;
        }
#line 773
        band->bandno = tmp___2;
#line 774
        if (band->bandno == 1) {
#line 774
          tmp___3 = 1;
        } else
#line 774
        if (band->bandno == 3) {
#line 774
          tmp___3 = 1;
        } else {
#line 774
          tmp___3 = 0;
        }
#line 774
        x0b = tmp___3;
#line 775
        if (band->bandno == 2) {
#line 775
          tmp___4 = 1;
        } else
#line 775
        if (band->bandno == 3) {
#line 775
          tmp___4 = 1;
        } else {
#line 775
          tmp___4 = 0;
        }
#line 775
        y0b = tmp___4;
#line 777
        if (band->bandno == 0) {
          {
#line 779
          band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 780
          band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 781
          band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 782
          band->y1 = int_ceildivpow2(tilec->y1, levelno);
          }
        } else {
          {
#line 785
          band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 786
          band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 787
          band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 788
          band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
          }
        }
#line 791
        if (resno == 0) {
#line 791
          tmp___5 = 0;
        } else {
#line 791
          tmp___5 = (3 * (resno - 1) + bandno) + 1;
        }
#line 791
        ss = & tccp->stepsizes[tmp___5];
#line 792
        if (tccp->qmfbid == 0) {
          {
#line 792
          __cil_tmp71 = dwt_getgain_real(band->bandno);
#line 792
          tmp___6 = __cil_tmp71;
          }
        } else {
          {
#line 792
          __cil_tmp72 = dwt_getgain(band->bandno);
#line 792
          tmp___6 = __cil_tmp72;
          }
        }
        {
#line 792
        gain = tmp___6;
#line 793
        numbps = (image->comps + compno)->prec + gain;
#line 794
        __cil_tmp74 = pow(2., (double )(numbps - ss->expn));
#line 794
        band->stepsize = (float )(((1. + (double )ss->mant / 2048.) * __cil_tmp74) * 0.5);
#line 795
        band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 797
        __cil_tmp75 = malloc((unsigned long )(res->pw * res->ph) * sizeof(opj_tcd_precinct_t ));
#line 797
        band->precincts = (opj_tcd_precinct_t *)__cil_tmp75;
#line 799
        precno = 0;
        }
        {
#line 799
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 799
          if (! (precno < res->pw * res->ph)) {
#line 799
            goto while_break___2;
          }
          {
#line 801
          cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 802
          cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 803
          cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 804
          cbgyend = cbgystart + (1 << cbgheightexpn);
#line 806
          prc = band->precincts + precno;
#line 808
          prc->x0 = int_max(cbgxstart, band->x0);
#line 809
          prc->y0 = int_max(cbgystart, band->y0);
#line 810
          prc->x1 = int_min(cbgxend, band->x1);
#line 811
          prc->y1 = int_min(cbgyend, band->y1);
#line 813
          __cil_tmp89 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 813
          tlcblkxstart = __cil_tmp89 << cblkwidthexpn;
#line 814
          __cil_tmp90 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 814
          tlcblkystart = __cil_tmp90 << cblkheightexpn;
#line 815
          __cil_tmp91 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 815
          brcblkxend = __cil_tmp91 << cblkwidthexpn;
#line 816
          __cil_tmp92 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 816
          brcblkyend = __cil_tmp92 << cblkheightexpn;
#line 817
          prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 818
          prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 820
          __cil_tmp93 = malloc((unsigned long )(prc->cw * prc->ch) * sizeof(opj_tcd_cblk_dec_t ));
#line 820
          prc->cblks.dec = (opj_tcd_cblk_dec_t *)__cil_tmp93;
#line 822
          prc->incltree = tgt_create(prc->cw, prc->ch);
#line 823
          prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 825
          cblkno = 0;
          }
          {
#line 825
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 825
            if (! (cblkno < prc->cw * prc->ch)) {
#line 825
              goto while_break___3;
            }
            {
#line 826
            cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 827
            cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 828
            cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 829
            cblkyend = cblkystart + (1 << cblkheightexpn);
#line 831
            cblk = prc->cblks.dec + cblkno;
#line 832
            cblk->data = (unsigned char *)((void *)0);
#line 833
            cblk->segs = (opj_tcd_seg_t *)((void *)0);
#line 835
            cblk->x0 = int_max(cblkxstart, prc->x0);
#line 836
            cblk->y0 = int_max(cblkystart, prc->y0);
#line 837
            cblk->x1 = int_min(cblkxend, prc->x1);
#line 838
            cblk->y1 = int_min(cblkyend, prc->y1);
#line 839
            cblk->numsegs = 0;
#line 825
            cblkno ++;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___3: 
#line 799
          precno ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: 
#line 767
        bandno ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
#line 713
      resno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 694
    compno ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 698
  return;
}
}
#line 848 "/root/patchweave_new/2/libopenjpeg/tcd.c"
void tcd_makelayer_fixed(opj_tcd_t *tcd , int layno , int final ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int value ;
  int matrice[10][10][3] ;
  int i ;
  int j ;
  int k ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  int n ;
  int imsb ;

  {
#line 854
  cp = tcd->cp;
#line 855
  tcd_tile = tcd->tcd_tile;
#line 856
  tcd_tcp = tcd->tcp;
#line 860
  compno = 0;
  {
#line 860
  while (1) {
    while_continue: /* CIL Label */ ;

#line 860
    if (! (compno < tcd_tile->numcomps)) {
#line 860
      goto while_break;
    }
#line 861
    tilec = tcd_tile->comps + compno;
#line 862
    i = 0;
    {
#line 862
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 862
      if (! (i < tcd_tcp->numlayers)) {
#line 862
        goto while_break___0;
      }
#line 863
      j = 0;
      {
#line 863
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 863
        if (! (j < tilec->numresolutions)) {
#line 863
          goto while_break___1;
        }
#line 864
        k = 0;
        {
#line 864
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 864
          if (! (k < 3)) {
#line 864
            goto while_break___2;
          }
#line 865
          matrice[i][j][k] = (int )((float )*(cp->matrice + (((i * tilec->numresolutions) * 3 + j * 3) + k)) * (float )((double )((tcd->image)->comps + compno)->prec / 16.));
#line 864
          k ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: 
#line 863
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 862
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 872
    resno = 0;
    {
#line 872
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 872
      if (! (resno < tilec->numresolutions)) {
#line 872
        goto while_break___3;
      }
#line 873
      res = tilec->resolutions + resno;
#line 874
      bandno = 0;
      {
#line 874
      while (1) {
        while_continue___11: /* CIL Label */ ;

#line 874
        if (! (bandno < res->numbands)) {
#line 874
          goto while_break___4;
        }
#line 875
        band = & res->bands[bandno];
#line 876
        precno = 0;
        {
#line 876
        while (1) {
          while_continue___12: /* CIL Label */ ;

#line 876
          if (! (precno < res->pw * res->ph)) {
#line 876
            goto while_break___5;
          }
#line 877
          prc = band->precincts + precno;
#line 878
          cblkno = 0;
          {
#line 878
          while (1) {
            while_continue___13: /* CIL Label */ ;
            while_continue___6: ;
#line 878
            if (! (cblkno < prc->cw * prc->ch)) {
#line 878
              goto while_break___6;
            }
#line 879
            cblk = prc->cblks.enc + cblkno;
#line 880
            layer = cblk->layers + layno;
#line 882
            imsb = ((tcd->image)->comps + compno)->prec - cblk->numbps;
#line 884
            if (layno == 0) {
#line 885
              value = matrice[layno][resno][bandno];
#line 886
              if (imsb >= value) {
#line 887
                value = 0;
              } else {
#line 889
                value -= imsb;
              }
            } else {
#line 892
              value = matrice[layno][resno][bandno] - matrice[layno - 1][resno][bandno];
#line 893
              if (imsb >= matrice[layno - 1][resno][bandno]) {
#line 894
                value -= imsb - matrice[layno - 1][resno][bandno];
#line 895
                if (value < 0) {
#line 896
                  value = 0;
                }
              }
            }
#line 901
            if (layno == 0) {
#line 902
              cblk->numpassesinlayers = 0;
            }
#line 905
            n = cblk->numpassesinlayers;
#line 906
            if (cblk->numpassesinlayers == 0) {
#line 907
              if (value != 0) {
#line 908
                n = (3 * value - 2) + cblk->numpassesinlayers;
              } else {
#line 910
                n = cblk->numpassesinlayers;
              }
            } else {
#line 913
              n = 3 * value + cblk->numpassesinlayers;
            }
#line 916
            layer->numpasses = n - cblk->numpassesinlayers;
#line 918
            if (! layer->numpasses) {
#line 919
              goto while_continue___6;
            }
#line 921
            if (cblk->numpassesinlayers == 0) {
#line 922
              layer->len = (cblk->passes + (n - 1))->rate;
#line 923
              layer->data = cblk->data;
            } else {
#line 925
              layer->len = (cblk->passes + (n - 1))->rate - (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 926
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
            }
#line 928
            if (final) {
#line 929
              cblk->numpassesinlayers = n;
            }
#line 878
            cblkno ++;
          }
          while_break___14: /* CIL Label */ ;
          }
          while_break___6: 
#line 876
          precno ++;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: 
#line 874
        bandno ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___4: 
#line 872
      resno ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___3: 
#line 860
    compno ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 864
  return;
}
}
#line 937 "/root/patchweave_new/2/libopenjpeg/tcd.c"
void tcd_rateallocate_fixed(opj_tcd_t *tcd ) 
{ 
  int layno ;

  {
#line 939
  layno = 0;
  {
#line 939
  while (1) {
    while_continue: /* CIL Label */ ;

#line 939
    if (! (layno < (tcd->tcp)->numlayers)) {
#line 939
      goto while_break;
    }
    {
#line 940
    tcd_makelayer_fixed(tcd, layno, 1);
#line 939
    layno ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 943
  return;
}
}
#line 944 "/root/patchweave_new/2/libopenjpeg/tcd.c"
void tcd_makelayer(opj_tcd_t *tcd , int layno , double thresh , int final ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int passno ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  int n ;
  int dr ;
  double dd ;
  opj_tcd_pass_t *pass ;

  {
#line 947
  tcd_tile = tcd->tcd_tile;
#line 949
  tcd_tile->distolayer[layno] = (double )0;
#line 951
  compno = 0;
  {
#line 951
  while (1) {
    while_continue: /* CIL Label */ ;

#line 951
    if (! (compno < tcd_tile->numcomps)) {
#line 951
      goto while_break;
    }
#line 952
    tilec = tcd_tile->comps + compno;
#line 953
    resno = 0;
    {
#line 953
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 953
      if (! (resno < tilec->numresolutions)) {
#line 953
        goto while_break___0;
      }
#line 954
      res = tilec->resolutions + resno;
#line 955
      bandno = 0;
      {
#line 955
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 955
        if (! (bandno < res->numbands)) {
#line 955
          goto while_break___1;
        }
#line 956
        band = & res->bands[bandno];
#line 957
        precno = 0;
        {
#line 957
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 957
          if (! (precno < res->pw * res->ph)) {
#line 957
            goto while_break___2;
          }
#line 958
          prc = band->precincts + precno;
#line 959
          cblkno = 0;
          {
#line 959
          while (1) {
            while_continue___8: /* CIL Label */ ;
            while_continue___3: ;
#line 959
            if (! (cblkno < prc->cw * prc->ch)) {
#line 959
              goto while_break___3;
            }
#line 960
            cblk = prc->cblks.enc + cblkno;
#line 961
            layer = cblk->layers + layno;
#line 964
            if (layno == 0) {
#line 965
              cblk->numpassesinlayers = 0;
            }
#line 967
            n = cblk->numpassesinlayers;
#line 968
            passno = cblk->numpassesinlayers;
            {
#line 968
            while (1) {
              while_continue___9: /* CIL Label */ ;
              while_continue___4: ;
#line 968
              if (! (passno < cblk->totalpasses)) {
#line 968
                goto while_break___4;
              }
#line 971
              pass = cblk->passes + passno;
#line 972
              if (n == 0) {
#line 973
                dr = pass->rate;
#line 974
                dd = pass->distortiondec;
              } else {
#line 976
                dr = pass->rate - (cblk->passes + (n - 1))->rate;
#line 977
                dd = pass->distortiondec - (cblk->passes + (n - 1))->distortiondec;
              }
#line 979
              if (! dr) {
#line 980
                if (dd != (double )0) {
#line 981
                  n = passno + 1;
                }
#line 982
                goto while_continue___4;
              }
#line 984
              if (dd / (double )dr >= thresh) {
#line 985
                n = passno + 1;
              }
#line 968
              passno ++;
            }
            while_break___10: /* CIL Label */ ;
            }
            while_break___4: 
#line 987
            layer->numpasses = n - cblk->numpassesinlayers;
#line 989
            if (! layer->numpasses) {
#line 990
              layer->disto = (double )0;
#line 991
              goto while_continue___3;
            }
#line 993
            if (cblk->numpassesinlayers == 0) {
#line 994
              layer->len = (cblk->passes + (n - 1))->rate;
#line 995
              layer->data = cblk->data;
#line 996
              layer->disto = (cblk->passes + (n - 1))->distortiondec;
            } else {
#line 998
              layer->len = (cblk->passes + (n - 1))->rate - (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 999
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 1000
              layer->disto = (cblk->passes + (n - 1))->distortiondec - (cblk->passes + (cblk->numpassesinlayers - 1))->distortiondec;
            }
#line 1003
            tcd_tile->distolayer[layno] += layer->disto;
#line 1005
            if (final) {
#line 1006
              cblk->numpassesinlayers = n;
            }
#line 959
            cblkno ++;
          }
          while_break___9: /* CIL Label */ ;
          }
          while_break___3: 
#line 957
          precno ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: 
#line 955
        bandno ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: 
#line 953
      resno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: 
#line 951
    compno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 955
  return;
}
}
#line 1014 "/root/patchweave_new/2/libopenjpeg/tcd.c"
opj_bool tcd_rateallocate(opj_tcd_t *tcd , unsigned char *dest , int len , opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int passno ;
  int layno ;
  double min ;
  double max ;
  double cumdisto[100] ;
  double K___0 ;
  double maxSE ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  int dr ;
  double dd ;
  double rdslope ;
  opj_tile_info_t *tile_info ;
  void *__cil_tmp36 ;
  double lo ;
  double hi ;
  int success ;
  int maxlen ;
  double __cil_tmp41 ;
  int __cil_tmp42 ;
  int tmp ;
  double goodthresh ;
  double stable_thresh ;
  int i ;
  double distotarget ;
  double __cil_tmp48 ;
  opj_t2_t *t2 ;
  opj_t2_t *__cil_tmp50 ;
  double thresh ;
  int l ;
  double distoachieved ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
#line 1018
  K___0 = (double )1;
#line 1019
  maxSE = (double )0;
#line 1021
  cp = tcd->cp;
#line 1022
  tcd_tile = tcd->tcd_tile;
#line 1023
  tcd_tcp = tcd->tcp;
#line 1025
  min = (double )1.79769313487e+308L;
#line 1026
  max = (double )0;
#line 1028
  tcd_tile->numpix = 0;
#line 1030
  compno = 0;
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1030
    if (! (compno < tcd_tile->numcomps)) {
#line 1030
      goto while_break;
    }
#line 1031
    tilec = tcd_tile->comps + compno;
#line 1032
    tilec->numpix = 0;
#line 1034
    resno = 0;
    {
#line 1034
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 1034
      if (! (resno < tilec->numresolutions)) {
#line 1034
        goto while_break___0;
      }
#line 1035
      res = tilec->resolutions + resno;
#line 1037
      bandno = 0;
      {
#line 1037
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 1037
        if (! (bandno < res->numbands)) {
#line 1037
          goto while_break___1;
        }
#line 1038
        band = & res->bands[bandno];
#line 1040
        precno = 0;
        {
#line 1040
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 1040
          if (! (precno < res->pw * res->ph)) {
#line 1040
            goto while_break___2;
          }
#line 1041
          prc = band->precincts + precno;
#line 1043
          cblkno = 0;
          {
#line 1043
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 1043
            if (! (cblkno < prc->cw * prc->ch)) {
#line 1043
              goto while_break___3;
            }
#line 1044
            cblk = prc->cblks.enc + cblkno;
#line 1046
            passno = 0;
            {
#line 1046
            while (1) {
              while_continue___11: /* CIL Label */ ;
              while_continue___4: ;
#line 1046
              if (! (passno < cblk->totalpasses)) {
#line 1046
                goto while_break___4;
              }
#line 1047
              pass = cblk->passes + passno;
#line 1050
              if (passno == 0) {
#line 1051
                dr = pass->rate;
#line 1052
                dd = pass->distortiondec;
              } else {
#line 1054
                dr = pass->rate - (cblk->passes + (passno - 1))->rate;
#line 1055
                dd = pass->distortiondec - (cblk->passes + (passno - 1))->distortiondec;
              }
#line 1057
              if (dr == 0) {
#line 1058
                goto while_continue___4;
              }
#line 1060
              rdslope = dd / (double )dr;
#line 1061
              if (rdslope < min) {
#line 1062
                min = rdslope;
              }
#line 1064
              if (rdslope > max) {
#line 1065
                max = rdslope;
              }
#line 1046
              passno ++;
            }
            while_break___12: /* CIL Label */ ;
            }
            while_break___4: 
#line 1070
            tcd_tile->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 1071
            tilec->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 1043
            cblkno ++;
          }
          while_break___11: /* CIL Label */ ;
          }
          while_break___3: 
#line 1040
          precno ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: 
#line 1037
        bandno ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 1034
      resno ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 1077
    maxSE += (((double )(1 << ((tcd->image)->comps + compno)->prec) - 1.) * ((double )(1 << ((tcd->image)->comps + compno)->prec) - 1.)) * (double )tilec->numpix;
#line 1030
    compno ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 1083
  if (cstr_info) {
    {
#line 1084
    tile_info = cstr_info->tile + tcd->tcd_tileno;
#line 1085
    tile_info->numpix = tcd_tile->numpix;
#line 1086
    tile_info->distotile = tcd_tile->distotile;
#line 1087
    __cil_tmp36 = malloc((unsigned long )tcd_tcp->numlayers * sizeof(double ));
#line 1087
    tile_info->thresh = (double *)__cil_tmp36;
    }
  }
#line 1090
  layno = 0;
  {
#line 1090
  while (1) {
    while_continue___12: /* CIL Label */ ;

#line 1090
    if (! (layno < tcd_tcp->numlayers)) {
#line 1090
      goto while_break___5;
    }
#line 1091
    lo = min;
#line 1092
    hi = max;
#line 1093
    success = 0;
#line 1094
    if (tcd_tcp->rates[layno]) {
      {
#line 1094
      __cil_tmp41 = ceil((double )tcd_tcp->rates[layno]);
#line 1094
      __cil_tmp42 = int_min((int )__cil_tmp41, len);
#line 1094
      tmp = __cil_tmp42;
      }
    } else {
#line 1094
      tmp = len;
    }
    {
#line 1094
    maxlen = tmp;
#line 1095
    goodthresh = (double )0;
#line 1096
    stable_thresh = (double )0;
#line 1101
    __cil_tmp48 = pow((double )((float )10), (double )(tcd_tcp->distoratio[layno] / (float )10));
#line 1101
    distotarget = tcd_tile->distotile - (K___0 * maxSE) / __cil_tmp48;
    }
#line 1107
    if (cp->disto_alloc == 1) {
#line 1107
      if (tcd_tcp->rates[layno] > (float )0) {
        _L: 
        {
#line 1108
        __cil_tmp50 = t2_create(tcd->cinfo, tcd->image, cp);
#line 1108
        t2 = __cil_tmp50;
#line 1109
        thresh = (double )0;
#line 1111
        i = 0;
        }
        {
#line 1111
        while (1) {
          while_continue___13: /* CIL Label */ ;
          while_continue___6: ;
#line 1111
          if (! (i < 128)) {
#line 1111
            goto while_break___6;
          }
          {
#line 1112
          l = 0;
#line 1113
          distoachieved = (double )0;
#line 1114
          thresh = (lo + hi) / (double )2;
#line 1116
          tcd_makelayer(tcd, layno, thresh, 0);
          }
#line 1118
          if (cp->fixed_quality) {
#line 1119
            if (cp->cinema) {
              {
#line 1120
              l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,
                                    maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos,
                                    tcd->cur_pino, (J2K_T2_MODE )0, tcd->cur_totnum_tp);
              }
#line 1121
              if (l == -999) {
#line 1122
                lo = thresh;
#line 1123
                goto while_continue___6;
              } else {
#line 1125
                if (layno == 0) {
#line 1125
                  tmp___0 = tcd_tile->distolayer[0];
                } else {
#line 1125
                  tmp___0 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
                }
#line 1125
                distoachieved = tmp___0;
#line 1127
                if (distoachieved < distotarget) {
#line 1128
                  hi = thresh;
#line 1129
                  stable_thresh = thresh;
#line 1130
                  goto while_continue___6;
                } else {
#line 1132
                  lo = thresh;
                }
              }
            } else {
#line 1136
              if (layno == 0) {
#line 1136
                tmp___1 = tcd_tile->distolayer[0];
              } else {
#line 1136
                tmp___1 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
              }
#line 1136
              distoachieved = tmp___1;
#line 1138
              if (distoachieved < distotarget) {
#line 1139
                hi = thresh;
#line 1140
                stable_thresh = thresh;
#line 1141
                goto while_continue___6;
              }
#line 1143
              lo = thresh;
            }
          } else {
            {
#line 1146
            l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,
                                  maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos,
                                  tcd->cur_pino, (J2K_T2_MODE )0, tcd->cur_totnum_tp);
            }
#line 1149
            if (l == -999) {
#line 1150
              lo = thresh;
#line 1151
              goto while_continue___6;
            }
#line 1153
            hi = thresh;
#line 1154
            stable_thresh = thresh;
          }
#line 1111
          i ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: 
#line 1157
        success = 1;
#line 1158
        if (stable_thresh == (double )0) {
#line 1158
          tmp___2 = thresh;
        } else {
#line 1158
          tmp___2 = stable_thresh;
        }
        {
#line 1158
        goodthresh = tmp___2;
#line 1159
        t2_destroy(t2);
        }
      } else {
#line 1107
        goto _L___0;
      }
    } else
    _L___0: 
#line 1107
    if (cp->fixed_quality == 1) {
#line 1107
      if (tcd_tcp->distoratio[layno] > (float )0) {
#line 1107
        goto _L;
      } else {
#line 1161
        success = 1;
#line 1162
        goodthresh = min;
      }
    } else {
#line 1161
      success = 1;
#line 1162
      goodthresh = min;
    }
#line 1165
    if (! success) {
#line 1166
      return (0);
    }
#line 1169
    if (cstr_info) {
#line 1170
      *((cstr_info->tile + tcd->tcd_tileno)->thresh + layno) = goodthresh;
    }
    {
#line 1172
    tcd_makelayer(tcd, layno, goodthresh, 1);
    }
#line 1175
    if (layno == 0) {
#line 1175
      tmp___3 = tcd_tile->distolayer[0];
    } else {
#line 1175
      tmp___3 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
    }
#line 1175
    cumdisto[layno] = tmp___3;
#line 1090
    layno ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___5: ;
#line 1178
  return (1);
}
}
#line 1181 "/root/patchweave_new/2/libopenjpeg/tcd.c"
int tcd_encode_tile(opj_tcd_t *tcd , int tileno , unsigned char *dest , int len ,
                    opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int l ;
  int i ;
  int numpacks ;
  opj_tcd_tile_t *tile ;
  opj_tcp_t *tcd_tcp ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_image_t *image ;
  opj_t1_t *t1 ;
  opj_t2_t *t2 ;
  opj_tcd_tilecomp_t *tilec_idx ;
  opj_tcd_resolution_t *res_idx ;
  void *__cil_tmp22 ;
  int x ;
  int y ;
  int adjust ;
  int tmp ;
  int offset_x ;
  int __cil_tmp28 ;
  int offset_y ;
  int __cil_tmp30 ;
  opj_tcd_tilecomp_t *tilec ;
  int tw ;
  int w ;
  int __cil_tmp34 ;
  int *data ;
  int *tile_data ;
  int *__cil_tmp37 ;
  int *__cil_tmp38 ;
  int *data___0 ;
  int *tile_data___0 ;
  int *__cil_tmp43 ;
  int *__cil_tmp44 ;
  int samples ;
  opj_tcd_tilecomp_t *tilec___0 ;
  double __cil_tmp54 ;
  opj_tcd_tilecomp_t *tilec___1 ;

  {
#line 1183
  numpacks = 0;
#line 1184
  tile = (opj_tcd_tile_t *)((void *)0);
#line 1185
  tcd_tcp = (opj_tcp_t *)((void *)0);
#line 1186
  cp = (opj_cp_t *)((void *)0);
#line 1188
  tcp = (tcd->cp)->tcps + 0;
#line 1189
  tccp = tcp->tccps + 0;
#line 1190
  image = tcd->image;
#line 1192
  t1 = (opj_t1_t *)((void *)0);
#line 1193
  t2 = (opj_t2_t *)((void *)0);
#line 1195
  tcd->tcd_tileno = tileno;
#line 1196
  tcd->tcd_tile = (tcd->tcd_image)->tiles;
#line 1197
  tcd->tcp = (tcd->cp)->tcps + tileno;
#line 1199
  tile = tcd->tcd_tile;
#line 1200
  tcd_tcp = tcd->tcp;
#line 1201
  cp = tcd->cp;
#line 1203
  if (tcd->cur_tp_num == 0) {
    {
#line 1204
    tcd->encoding_time = opj_clock();
    }
#line 1206
    if (cstr_info) {
#line 1207
      tilec_idx = tile->comps + 0;
#line 1208
      i = 0;
      {
#line 1208
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1208
        if (! (i < tilec_idx->numresolutions)) {
#line 1208
          goto while_break;
        }
#line 1209
        res_idx = tilec_idx->resolutions + i;
#line 1211
        (cstr_info->tile + tileno)->pw[i] = res_idx->pw;
#line 1212
        (cstr_info->tile + tileno)->ph[i] = res_idx->ph;
#line 1214
        numpacks += res_idx->pw * res_idx->ph;
#line 1216
        (cstr_info->tile + tileno)->pdx[i] = tccp->prcw[i];
#line 1217
        (cstr_info->tile + tileno)->pdy[i] = tccp->prch[i];
#line 1208
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break: 
      {
#line 1219
      __cil_tmp22 = calloc((unsigned long )((cstr_info->numcomps * cstr_info->numlayers) * numpacks),
                           sizeof(opj_packet_info_t ));
#line 1219
      (cstr_info->tile + tileno)->packet = (opj_packet_info_t *)__cil_tmp22;
      }
    }
#line 1225
    compno = 0;
    {
#line 1225
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1225
      if (! (compno < tile->numcomps)) {
#line 1225
        goto while_break___0;
      }
#line 1228
      if ((image->comps + compno)->sgnd) {
#line 1228
        tmp = 0;
      } else {
#line 1228
        tmp = 1 << ((image->comps + compno)->prec - 1);
      }
      {
#line 1228
      adjust = tmp;
#line 1229
      __cil_tmp28 = int_ceildiv(image->x0, (image->comps + compno)->dx);
#line 1229
      offset_x = __cil_tmp28;
#line 1230
      __cil_tmp30 = int_ceildiv(image->y0, (image->comps + compno)->dy);
#line 1230
      offset_y = __cil_tmp30;
#line 1232
      tilec = tile->comps + compno;
#line 1233
      tw = tilec->x1 - tilec->x0;
#line 1234
      __cil_tmp34 = int_ceildiv(image->x1 - image->x0, (image->comps + compno)->dx);
#line 1234
      w = __cil_tmp34;
      }
#line 1238
      if ((tcd_tcp->tccps + compno)->qmfbid == 1) {
#line 1239
        y = tilec->y0;
        {
#line 1239
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1239
          if (! (y < tilec->y1)) {
#line 1239
            goto while_break___1;
          }
#line 1241
          data = (image->comps + compno)->data + ((tilec->x0 - offset_x) + (y - offset_y) * w);
#line 1243
          tile_data = tilec->data + (y - tilec->y0) * tw;
#line 1244
          x = tilec->x0;
          {
#line 1244
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 1244
            if (! (x < tilec->x1)) {
#line 1244
              goto while_break___2;
            }
#line 1245
            __cil_tmp38 = data;
#line 1245
            data ++;
#line 1245
            __cil_tmp37 = tile_data;
#line 1245
            tile_data ++;
#line 1245
            *__cil_tmp37 = *__cil_tmp38 - adjust;
#line 1244
            x ++;
          }
          while_break___10: /* CIL Label */ ;
          }
          while_break___2: 
#line 1239
          y ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___1: ;
      } else
#line 1248
      if ((tcd_tcp->tccps + compno)->qmfbid == 0) {
#line 1249
        y = tilec->y0;
        {
#line 1249
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1249
          if (! (y < tilec->y1)) {
#line 1249
            goto while_break___3;
          }
#line 1251
          data___0 = (image->comps + compno)->data + ((tilec->x0 - offset_x) + (y - offset_y) * w);
#line 1253
          tile_data___0 = tilec->data + (y - tilec->y0) * tw;
#line 1254
          x = tilec->x0;
          {
#line 1254
          while (1) {
            while_continue___4: /* CIL Label */ ;

#line 1254
            if (! (x < tilec->x1)) {
#line 1254
              goto while_break___4;
            }
#line 1255
            __cil_tmp44 = data___0;
#line 1255
            data___0 ++;
#line 1255
            __cil_tmp43 = tile_data___0;
#line 1255
            tile_data___0 ++;
#line 1255
            *__cil_tmp43 = (*__cil_tmp44 - adjust) << 11;
#line 1254
            x ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___4: 
#line 1249
          y ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___3: ;
      }
#line 1225
      compno ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: ;
#line 1263
    if (tcd_tcp->mct) {
#line 1264
      samples = ((tile->comps + 0)->x1 - (tile->comps + 0)->x0) * ((tile->comps + 0)->y1 - (tile->comps + 0)->y0);
#line 1265
      if ((tcd_tcp->tccps + 0)->qmfbid == 0) {
        {
#line 1266
        mct_encode_real((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                        samples);
        }
      } else {
        {
#line 1268
        mct_encode((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                   samples);
        }
      }
    }
#line 1274
    compno = 0;
    {
#line 1274
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 1274
      if (! (compno < tile->numcomps)) {
#line 1274
        goto while_break___5;
      }
#line 1275
      tilec___0 = tile->comps + compno;
#line 1276
      if ((tcd_tcp->tccps + compno)->qmfbid == 1) {
        {
#line 1277
        dwt_encode(tilec___0);
        }
      } else
#line 1278
      if ((tcd_tcp->tccps + compno)->qmfbid == 0) {
        {
#line 1279
        dwt_encode_real(tilec___0);
        }
      }
#line 1274
      compno ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___5: 
    {
#line 1284
    t1 = t1_create(tcd->cinfo);
#line 1285
    t1_encode_cblks(t1, tile, tcd_tcp);
#line 1286
    t1_destroy(t1);
    }
#line 1291
    if (cstr_info) {
#line 1292
      cstr_info->index_write = 0;
    }
#line 1294
    if (cp->disto_alloc) {
      {
#line 1296
      tcd_rateallocate(tcd, dest, len, cstr_info);
      }
    } else
#line 1294
    if (cp->fixed_quality) {
      {
#line 1296
      tcd_rateallocate(tcd, dest, len, cstr_info);
      }
    } else {
      {
#line 1299
      tcd_rateallocate_fixed(tcd);
      }
    }
  }
#line 1305
  if (cstr_info) {
#line 1306
    cstr_info->index_write = 1;
  }
  {
#line 1309
  t2 = t2_create(tcd->cinfo, image, cp);
#line 1310
  l = t2_encode_packets(t2, tileno, tile, tcd_tcp->numlayers, dest, len, cstr_info,
                        tcd->tp_num, tcd->tp_pos, tcd->cur_pino, (J2K_T2_MODE )1,
                        tcd->cur_totnum_tp);
#line 1311
  t2_destroy(t2);
  }
#line 1316
  if (tcd->cur_tp_num == tcd->cur_totnum_tp - 1) {
    {
#line 1317
    __cil_tmp54 = opj_clock();
#line 1317
    tcd->encoding_time = __cil_tmp54 - tcd->encoding_time;
#line 1318
    opj_event_msg(tcd->cinfo, 4, "- tile encoded in %f s\n", tcd->encoding_time);
#line 1321
    compno = 0;
    }
    {
#line 1321
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 1321
      if (! (compno < tile->numcomps)) {
#line 1321
        goto while_break___6;
      }
      {
#line 1322
      tilec___1 = tile->comps + compno;
#line 1323
      free((void *)tilec___1->data);
#line 1321
      compno ++;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___6: ;
  }
#line 1327
  return (l);
}
}
#line 1330 "/root/patchweave_new/2/libopenjpeg/tcd.c"
opj_bool tcd_decode_tile(opj_tcd_t *tcd , unsigned char *src , int len , int tileno ,
                         opj_codestream_info_t *cstr_info ) 
{ 
  int l ;
  int compno ;
  int eof ;
  double tile_time ;
  double t1_time ;
  double dwt_time ;
  opj_tcd_tile_t *tile ;
  opj_t1_t *t1 ;
  opj_t2_t *t2 ;
  int resno ;
  int compno___1 ;
  int numprec ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec_idx ;
  opj_tcd_resolution_t *res_idx ;
  void *__cil_tmp25 ;
  opj_tcd_tilecomp_t *tilec ;
  void *__cil_tmp31 ;
  double __cil_tmp32 ;
  opj_tcd_tilecomp_t *tilec___0 ;
  int numres2decode ;
  double __cil_tmp37 ;
  int n ;
  opj_tcd_tilecomp_t *tilec___1 ;
  opj_image_comp_t *imagec ;
  opj_tcd_resolution_t *res ;
  int adjust ;
  int tmp ;
  int min ;
  int tmp___0 ;
  int max ;
  int tmp___1 ;
  int tw ;
  int w ;
  int offset_x ;
  int __cil_tmp51 ;
  int offset_y ;
  int __cil_tmp53 ;
  int i ;
  int j ;
  void *__cil_tmp56 ;
  int v ;
  float tmp___2 ;
  int v___0 ;
  long __cil_tmp61 ;
  double __cil_tmp63 ;

  {
  {
#line 1333
  eof = 0;
#line 1335
  tile = (opj_tcd_tile_t *)((void *)0);
#line 1337
  t1 = (opj_t1_t *)((void *)0);
#line 1338
  t2 = (opj_t2_t *)((void *)0);
#line 1340
  tcd->tcd_tileno = tileno;
#line 1341
  tcd->tcd_tile = (tcd->tcd_image)->tiles + tileno;
#line 1342
  tcd->tcp = (tcd->cp)->tcps + tileno;
#line 1343
  tile = tcd->tcd_tile;
#line 1345
  tile_time = opj_clock();
#line 1346
  opj_event_msg(tcd->cinfo, 4, "tile %d of %d\n", tileno + 1, (tcd->cp)->tw * (tcd->cp)->th);
  }
#line 1349
  if (cstr_info) {
#line 1350
    numprec = 0;
#line 1351
    compno___1 = 0;
    {
#line 1351
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1351
      if (! (compno___1 < cstr_info->numcomps)) {
#line 1351
        goto while_break;
      }
#line 1352
      tcp = (tcd->cp)->tcps + 0;
#line 1353
      tccp = tcp->tccps + compno___1;
#line 1354
      tilec_idx = tile->comps + compno___1;
#line 1355
      resno = 0;
      {
#line 1355
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1355
        if (! (resno < tilec_idx->numresolutions)) {
#line 1355
          goto while_break___0;
        }
#line 1356
        res_idx = tilec_idx->resolutions + resno;
#line 1357
        (cstr_info->tile + tileno)->pw[resno] = res_idx->pw;
#line 1358
        (cstr_info->tile + tileno)->ph[resno] = res_idx->ph;
#line 1359
        numprec += res_idx->pw * res_idx->ph;
#line 1360
        if (tccp->csty & 1) {
#line 1361
          (cstr_info->tile + tileno)->pdx[resno] = tccp->prcw[resno];
#line 1362
          (cstr_info->tile + tileno)->pdy[resno] = tccp->prch[resno];
        } else {
#line 1365
          (cstr_info->tile + tileno)->pdx[resno] = 15;
#line 1366
          (cstr_info->tile + tileno)->pdy[resno] = 15;
        }
#line 1355
        resno ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___0: 
#line 1351
      compno___1 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break: 
    {
#line 1370
    __cil_tmp25 = malloc((unsigned long )(cstr_info->numlayers * numprec) * sizeof(opj_packet_info_t ));
#line 1370
    (cstr_info->tile + tileno)->packet = (opj_packet_info_t *)__cil_tmp25;
#line 1371
    cstr_info->packno = 0;
    }
  }
  {
#line 1377
  t2 = t2_create(tcd->cinfo, tcd->image, tcd->cp);
#line 1378
  l = t2_decode_packets(t2, src, len, tileno, tile, cstr_info);
#line 1379
  t2_destroy(t2);
  }
#line 1381
  if (l == -999) {
    {
#line 1382
    eof = 1;
#line 1383
    opj_event_msg(tcd->cinfo, 1, "tcd_decode: incomplete bistream\n\220");
    }
  }
  {
#line 1388
  t1_time = opj_clock();
#line 1389
  t1 = t1_create(tcd->cinfo);
  }
#line 1390
  if ((unsigned long )t1 == (unsigned long )((void *)0)) {
    {
#line 1392
    opj_event_msg(tcd->cinfo, 1, "Out of memory\n");
#line 1393
    t1_destroy(t1);
    }
#line 1394
    return (0);
  }
#line 1397
  compno = 0;
  {
#line 1397
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 1397
    if (! (compno < tile->numcomps)) {
#line 1397
      goto while_break___1;
    }
    {
#line 1398
    tilec = tile->comps + compno;
#line 1400
    __cil_tmp31 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) + 3) * sizeof(int ));
#line 1400
    tilec->data = (int *)__cil_tmp31;
    }
#line 1401
    if ((unsigned long )tilec->data == (unsigned long )((void *)0)) {
      {
#line 1403
      opj_event_msg(tcd->cinfo, 1, "Out of memory\n");
      }
#line 1404
      return (0);
    }
    {
#line 1407
    t1_decode_cblks(t1, tilec, (tcd->tcp)->tccps + compno);
#line 1397
    compno ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 1409
  t1_destroy(t1);
#line 1410
  __cil_tmp32 = opj_clock();
#line 1410
  t1_time = __cil_tmp32 - t1_time;
#line 1411
  opj_event_msg(tcd->cinfo, 4, "- tiers-1 took %f s\n", t1_time);
#line 1415
  dwt_time = opj_clock();
#line 1416
  compno = 0;
  }
  {
#line 1416
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1416
    if (! (compno < tile->numcomps)) {
#line 1416
      goto while_break___2;
    }
#line 1417
    tilec___0 = tile->comps + compno;
#line 1420
    if ((tcd->cp)->reduce != 0) {
#line 1421
      if ((tile->comps + compno)->numresolutions < (tcd->cp)->reduce - 1) {
        {
#line 1422
        opj_event_msg(tcd->cinfo, 1, "Error decoding tile. The number of resolutions to remove [%d+1] is higher than the number  of resolutions in the original codestream [%d]\nModify the cp_reduce parameter.\n",
                      (tcd->cp)->reduce, (tile->comps + compno)->numresolutions);
        }
#line 1424
        return (0);
      } else {
#line 1427
        ((tcd->image)->comps + compno)->resno_decoded = ((tile->comps + compno)->numresolutions - (tcd->cp)->reduce) - 1;
      }
    }
#line 1432
    numres2decode = ((tcd->image)->comps + compno)->resno_decoded + 1;
#line 1433
    if (numres2decode > 0) {
#line 1434
      if (((tcd->tcp)->tccps + compno)->qmfbid == 1) {
        {
#line 1435
        dwt_decode(tilec___0, numres2decode);
        }
      } else {
        {
#line 1437
        dwt_decode_real(tilec___0, numres2decode);
        }
      }
    }
#line 1416
    compno ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 1441
  __cil_tmp37 = opj_clock();
#line 1441
  dwt_time = __cil_tmp37 - dwt_time;
#line 1442
  opj_event_msg(tcd->cinfo, 4, "- dwt took %f s\n\230\001", dwt_time);
  }
#line 1446
  if ((tcd->tcp)->mct) {
#line 1447
    n = ((tile->comps + 0)->x1 - (tile->comps + 0)->x0) * ((tile->comps + 0)->y1 - (tile->comps + 0)->y0);
#line 1449
    if (tile->numcomps >= 3) {
#line 1450
      if (((tcd->tcp)->tccps + 0)->qmfbid == 1) {
        {
#line 1451
        mct_decode((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                   n);
        }
      } else {
        {
#line 1457
        mct_decode_real((float *)(tile->comps + 0)->data, (float *)(tile->comps + 1)->data,
                        (float *)(tile->comps + 2)->data, n);
        }
      }
    } else {
      {
#line 1464
      opj_event_msg(tcd->cinfo, 2, "Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\n\245\375\266\312U",
                    tile->numcomps);
      }
    }
  }
#line 1470
  compno = 0;
  {
#line 1470
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 1470
    if (! (compno < tile->numcomps)) {
#line 1470
      goto while_break___3;
    }
#line 1471
    tilec___1 = tile->comps + compno;
#line 1472
    imagec = (tcd->image)->comps + compno;
#line 1473
    res = tilec___1->resolutions + imagec->resno_decoded;
#line 1474
    if (imagec->sgnd) {
#line 1474
      tmp = 0;
    } else {
#line 1474
      tmp = 1 << (imagec->prec - 1);
    }
#line 1474
    adjust = tmp;
#line 1475
    if (imagec->sgnd) {
#line 1475
      tmp___0 = - (1 << (imagec->prec - 1));
    } else {
#line 1475
      tmp___0 = 0;
    }
#line 1475
    min = tmp___0;
#line 1476
    if (imagec->sgnd) {
#line 1476
      tmp___1 = (1 << (imagec->prec - 1)) - 1;
    } else {
#line 1476
      tmp___1 = (1 << imagec->prec) - 1;
    }
    {
#line 1476
    max = tmp___1;
#line 1478
    tw = tilec___1->x1 - tilec___1->x0;
#line 1479
    w = imagec->w;
#line 1481
    __cil_tmp51 = int_ceildivpow2(imagec->x0, imagec->factor);
#line 1481
    offset_x = __cil_tmp51;
#line 1482
    __cil_tmp53 = int_ceildivpow2(imagec->y0, imagec->factor);
#line 1482
    offset_y = __cil_tmp53;
    }
#line 1485
    if (! imagec->data) {
      {
#line 1486
      __cil_tmp56 = malloc((unsigned long )(imagec->w * imagec->h) * sizeof(int ));
#line 1486
      imagec->data = (int *)__cil_tmp56;
      }
    }
#line 1488
    if (! imagec->data) {
      {
#line 1490
      opj_event_msg(tcd->cinfo, 1, "Out of memory\n");
      }
#line 1491
      return (0);
    }
#line 1493
    if (((tcd->tcp)->tccps + compno)->qmfbid == 1) {
#line 1494
      j = res->y0;
      {
#line 1494
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1494
        if (! (j < res->y1)) {
#line 1494
          goto while_break___4;
        }
#line 1495
        i = res->x0;
        {
#line 1495
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 1495
          if (! (i < res->x1)) {
#line 1495
            goto while_break___5;
          }
          {
#line 1496
          v = *(tilec___1->data + ((i - res->x0) + (j - res->y0) * tw));
#line 1497
          v += adjust;
#line 1498
          *(imagec->data + ((i - offset_x) + (j - offset_y) * w)) = int_clamp(v, min,
                                                                              max);
#line 1495
          i ++;
          }
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___5: 
#line 1494
        j ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___4: ;
    } else {
#line 1502
      j = res->y0;
      {
#line 1502
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 1502
        if (! (j < res->y1)) {
#line 1502
          goto while_break___6;
        }
#line 1503
        i = res->x0;
        {
#line 1503
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 1503
          if (! (i < res->x1)) {
#line 1503
            goto while_break___7;
          }
          {
#line 1504
          tmp___2 = *((float *)tilec___1->data + ((i - res->x0) + (j - res->y0) * tw));
#line 1505
          __cil_tmp61 = lrintf(tmp___2);
#line 1505
          v___0 = (int )__cil_tmp61;
#line 1506
          v___0 += adjust;
#line 1507
          *(imagec->data + ((i - offset_x) + (j - offset_y) * w)) = int_clamp(v___0,
                                                                              min,
                                                                              max);
#line 1503
          i ++;
          }
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___7: 
#line 1502
        j ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___6: ;
    }
    {
#line 1511
    free((void *)tilec___1->data);
#line 1470
    compno ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___3: 
  {
#line 1514
  __cil_tmp63 = opj_clock();
#line 1514
  tile_time = __cil_tmp63 - tile_time;
#line 1515
  opj_event_msg(tcd->cinfo, 4, "- tile decoded in %f s\n", tile_time);
  }
#line 1517
  if (eof) {
#line 1518
    return (0);
  }
#line 1521
  return (1);
}
}
#line 1524 "/root/patchweave_new/2/libopenjpeg/tcd.c"
void tcd_free_decode(opj_tcd_t *tcd ) 
{ 
  opj_tcd_image_t *tcd_image ;
  int i ;

  {
#line 1525
  tcd_image = tcd->tcd_image;
#line 1526
  i = 0;
#line 1527
  i = 0;
  {
#line 1527
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1527
    if (! (i < tcd_image->tw * tcd_image->th)) {
#line 1527
      goto while_break;
    }
    {
#line 1529
    tcd_free_decode_tile(tcd, i);
#line 1527
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1532
  free((void *)tcd_image->tiles);
  }
#line 1534
  return;
}
}
#line 1535 "/root/patchweave_new/2/libopenjpeg/tcd.c"
void tcd_free_decode_tile(opj_tcd_t *tcd , int tileno ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_image_t *tcd_image ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prec ;
  opj_tcd_cblk_dec_t *cblk ;

  {
#line 1538
  tcd_image = tcd->tcd_image;
#line 1540
  tile = tcd_image->tiles + tileno;
#line 1541
  if ((unsigned long )tile->comps != (unsigned long )((void *)0)) {
#line 1542
    compno = 0;
    {
#line 1542
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1542
      if (! (compno < tile->numcomps)) {
#line 1542
        goto while_break;
      }
#line 1543
      tilec = tile->comps + compno;
#line 1544
      resno = 0;
      {
#line 1544
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1544
        if (! (resno < tilec->numresolutions)) {
#line 1544
          goto while_break___0;
        }
#line 1545
        res = tilec->resolutions + resno;
#line 1546
        bandno = 0;
        {
#line 1546
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1546
          if (! (bandno < res->numbands)) {
#line 1546
            goto while_break___1;
          }
#line 1547
          band = & res->bands[bandno];
#line 1548
          precno = 0;
          {
#line 1548
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 1548
            if (! (precno < res->ph * res->pw)) {
#line 1548
              goto while_break___2;
            }
#line 1549
            prec = band->precincts + precno;
#line 1550
            if ((unsigned long )prec->cblks.dec != (unsigned long )((void *)0)) {
#line 1551
              cblkno = 0;
              {
#line 1551
              while (1) {
                while_continue___3: /* CIL Label */ ;

#line 1551
                if (! (cblkno < prec->cw * prec->ch)) {
#line 1551
                  goto while_break___3;
                }
                {
#line 1552
                cblk = prec->cblks.dec + cblkno;
#line 1553
                free((void *)cblk->data);
#line 1554
                free((void *)cblk->segs);
#line 1551
                cblkno ++;
                }
              }
              while_break___8: /* CIL Label */ ;
              }
              while_break___3: 
              {
#line 1556
              free((void *)prec->cblks.dec);
              }
            }
#line 1558
            if ((unsigned long )prec->imsbtree != (unsigned long )((void *)0)) {
              {
#line 1558
              tgt_destroy(prec->imsbtree);
              }
            }
#line 1559
            if ((unsigned long )prec->incltree != (unsigned long )((void *)0)) {
              {
#line 1559
              tgt_destroy(prec->incltree);
              }
            }
#line 1548
            precno ++;
          }
          while_break___7: /* CIL Label */ ;
          }
          while_break___2: 
          {
#line 1563
          free((void *)band->precincts);
#line 1546
          bandno ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: 
#line 1544
        resno ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: 
      {
#line 1566
      free((void *)tilec->resolutions);
#line 1542
      compno ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: 
    {
#line 1568
    free((void *)tile->comps);
#line 1569
    tile->comps = (opj_tcd_tilecomp_t *)((void *)0);
    }
  }
#line 1572
  return;
}
}
#line 40 "/root/patchweave_new/2/libopenjpeg/t2.c"
static void t2_putcommacode(opj_bio_t *bio , int n ) ;
#line 41
static int t2_getcommacode(opj_bio_t *bio ) ;
#line 47
static void t2_putnumpasses(opj_bio_t *bio , int n ) ;
#line 48
static int t2_getnumpasses(opj_bio_t *bio ) ;
#line 60
static int t2_encode_packet(opj_tcd_tile_t *tile , opj_tcp_t *tcp , opj_pi_iterator_t *pi ,
                            unsigned char *dest , int length , opj_codestream_info_t *cstr_info ,
                            int tileno ) ;
#line 67
static opj_bool t2_init_seg(opj_tcd_cblk_dec_t *cblk , int index___0 , int cblksty ,
                            int first ) ;
#line 79
static int t2_decode_packet(opj_t2_t *t2 , unsigned char *src , int len , opj_tcd_tile_t *tile ,
                            opj_tcp_t *tcp , opj_pi_iterator_t *pi , opj_packet_info_t *pack_info ) ;
#line 90 "/root/patchweave_new/2/libopenjpeg/t2.c"
static void t2_putcommacode(opj_bio_t *bio , int n ) 
{ 


  {
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    n --;
#line 91
    if (! (n >= 0)) {
#line 91
      goto while_break;
    }
    {
#line 92
    bio_write(bio, 1, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 94
  bio_write(bio, 0, 1);
  }
#line 96
  return;
}
}
#line 97 "/root/patchweave_new/2/libopenjpeg/t2.c"
static int t2_getcommacode(opj_bio_t *bio ) 
{ 
  int n ;
  int __cil_tmp3 ;

  {
#line 99
  n = 0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;

#line 99
    if (! __cil_tmp3) {
#line 99
      goto while_break;
    }
#line 99
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 102
  return (n);
}
}
#line 105 "/root/patchweave_new/2/libopenjpeg/t2.c"
static void t2_putnumpasses(opj_bio_t *bio , int n ) 
{ 


  {
#line 106
  if (n == 1) {
    {
#line 107
    bio_write(bio, 0, 1);
    }
  } else
#line 108
  if (n == 2) {
    {
#line 109
    bio_write(bio, 2, 2);
    }
  } else
#line 110
  if (n <= 5) {
    {
#line 111
    bio_write(bio, 12 | (n - 3), 4);
    }
  } else
#line 112
  if (n <= 36) {
    {
#line 113
    bio_write(bio, 480 | (n - 6), 9);
    }
  } else
#line 114
  if (n <= 164) {
    {
#line 115
    bio_write(bio, 65408 | (n - 37), 16);
    }
  }
#line 118
  return;
}
}
#line 119 "/root/patchweave_new/2/libopenjpeg/t2.c"
static int t2_getnumpasses(opj_bio_t *bio ) 
{ 
  int n ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp7 ;

  {
  {
#line 121
  __cil_tmp3 = bio_read(bio, 1);
  }
#line 121
  if (! __cil_tmp3) {
#line 122
    return (1);
  }
  {
#line 123
  __cil_tmp4 = bio_read(bio, 1);
  }
#line 123
  if (! __cil_tmp4) {
#line 124
    return (2);
  }
  {
#line 125
  n = bio_read(bio, 2);
  }
#line 125
  if (n != 3) {
#line 126
    return (3 + n);
  }
  {
#line 127
  n = bio_read(bio, 5);
  }
#line 127
  if (n != 31) {
#line 128
    return (6 + n);
  }
  {
#line 129
  __cil_tmp7 = bio_read(bio, 7);
  }
#line 129
  return (37 + __cil_tmp7);
}
}
#line 132 "/root/patchweave_new/2/libopenjpeg/t2.c"
static int t2_encode_packet(opj_tcd_tile_t *tile , opj_tcp_t *tcp , opj_pi_iterator_t *pi ,
                            unsigned char *dest , int length , opj_codestream_info_t *cstr_info ,
                            int tileno ) 
{ 
  int bandno ;
  int cblkno ;
  unsigned char *c ;
  int compno ;
  int resno ;
  int precno ;
  int layno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_bio_t *bio ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_band_t *band___0 ;
  opj_tcd_precinct_t *prc___0 ;
  opj_tcd_cblk_enc_t *cblk___0 ;
  opj_tcd_layer_t *layer ;
  opj_tcd_cblk_enc_t *cblk___1 ;
  opj_tcd_layer_t *layer___0 ;
  int increment ;
  int nump ;
  int len ;
  int passno ;
  opj_tcd_pass_t *pass ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  opj_tcd_pass_t *pass___0 ;
  int __cil_tmp43 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  opj_packet_info_t *info_PK ;
  opj_tcd_band_t *band___1 ;
  opj_tcd_precinct_t *prc___1 ;
  opj_tcd_cblk_enc_t *cblk___2 ;
  opj_tcd_layer_t *layer___1 ;
  opj_packet_info_t *info_PK___0 ;

  {
#line 134
  c = dest;
#line 136
  compno = pi->compno;
#line 137
  resno = pi->resno;
#line 138
  precno = pi->precno;
#line 139
  layno = pi->layno;
#line 141
  tilec = tile->comps + compno;
#line 142
  res = tilec->resolutions + resno;
#line 144
  bio = (opj_bio_t *)((void *)0);
#line 147
  if (tcp->csty & 2) {
#line 148
    *(c + 0) = (unsigned char)255;
#line 149
    *(c + 1) = (unsigned char)145;
#line 150
    *(c + 2) = (unsigned char)0;
#line 151
    *(c + 3) = (unsigned char)4;
#line 152
    *(c + 4) = (unsigned char )((tile->packno % 65536) / 256);
#line 153
    *(c + 5) = (unsigned char )((tile->packno % 65536) % 256);
#line 154
    c += 6;
  }
#line 158
  if (! layno) {
#line 159
    bandno = 0;
    {
#line 159
    while (1) {
      while_continue: /* CIL Label */ ;

#line 159
      if (! (bandno < res->numbands)) {
#line 159
        goto while_break;
      }
      {
#line 160
      band = & res->bands[bandno];
#line 161
      prc = band->precincts + precno;
#line 162
      tgt_reset(prc->incltree);
#line 163
      tgt_reset(prc->imsbtree);
#line 164
      cblkno = 0;
      }
      {
#line 164
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 164
        if (! (cblkno < prc->cw * prc->ch)) {
#line 164
          goto while_break___0;
        }
        {
#line 165
        cblk = prc->cblks.enc + cblkno;
#line 166
        cblk->numpasses = 0;
#line 167
        tgt_setvalue(prc->imsbtree, cblkno, band->numbps - cblk->numbps);
#line 164
        cblkno ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___0: 
#line 159
      bandno ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 172
  bio = bio_create();
#line 173
  bio_init_enc(bio, c, length);
#line 174
  bio_write(bio, 1, 1);
#line 177
  bandno = 0;
  }
  {
#line 177
  while (1) {
    while_continue___9: /* CIL Label */ ;

#line 177
    if (! (bandno < res->numbands)) {
#line 177
      goto while_break___1;
    }
#line 178
    band___0 = & res->bands[bandno];
#line 179
    prc___0 = band___0->precincts + precno;
#line 180
    cblkno = 0;
    {
#line 180
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 180
      if (! (cblkno < prc___0->cw * prc___0->ch)) {
#line 180
        goto while_break___2;
      }
#line 181
      cblk___0 = prc___0->cblks.enc + cblkno;
#line 182
      layer = cblk___0->layers + layno;
#line 183
      if (! cblk___0->numpasses) {
#line 183
        if (layer->numpasses) {
          {
#line 184
          tgt_setvalue(prc___0->incltree, cblkno, layno);
          }
        }
      }
#line 180
      cblkno ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___2: 
#line 187
    cblkno = 0;
    {
#line 187
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___3: ;
#line 187
      if (! (cblkno < prc___0->cw * prc___0->ch)) {
#line 187
        goto while_break___3;
      }
#line 188
      cblk___1 = prc___0->cblks.enc + cblkno;
#line 189
      layer___0 = cblk___1->layers + layno;
#line 190
      increment = 0;
#line 191
      nump = 0;
#line 192
      len = 0;
#line 194
      if (! cblk___1->numpasses) {
        {
#line 195
        tgt_encode(bio, prc___0->incltree, cblkno, layno + 1);
        }
      } else {
        {
#line 197
        bio_write(bio, layer___0->numpasses != 0, 1);
        }
      }
#line 200
      if (! layer___0->numpasses) {
#line 201
        goto while_continue___3;
      }
#line 204
      if (! cblk___1->numpasses) {
        {
#line 205
        cblk___1->numlenbits = 3;
#line 206
        tgt_encode(bio, prc___0->imsbtree, cblkno, 999);
        }
      }
      {
#line 209
      t2_putnumpasses(bio, layer___0->numpasses);
#line 212
      passno = cblk___1->numpasses;
      }
      {
#line 212
      while (1) {
        while_continue___12: /* CIL Label */ ;

#line 212
        if (! (passno < cblk___1->numpasses + layer___0->numpasses)) {
#line 212
          goto while_break___4;
        }
#line 213
        pass = cblk___1->passes + passno;
#line 214
        nump ++;
#line 215
        len += pass->len;
#line 216
        if (pass->term) {
          _L: 
          {
#line 217
          __cil_tmp38 = int_floorlog2(nump);
#line 217
          __cil_tmp37 = int_floorlog2(len);
#line 217
          __cil_tmp39 = int_max(increment, (__cil_tmp37 + 1) - (cblk___1->numlenbits + __cil_tmp38));
#line 217
          increment = __cil_tmp39;
#line 218
          len = 0;
#line 219
          nump = 0;
          }
        } else
#line 216
        if (passno == (cblk___1->numpasses + layer___0->numpasses) - 1) {
#line 216
          goto _L;
        }
#line 212
        passno ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___4: 
      {
#line 222
      t2_putcommacode(bio, increment);
#line 225
      cblk___1->numlenbits += increment;
#line 228
      passno = cblk___1->numpasses;
      }
      {
#line 228
      while (1) {
        while_continue___13: /* CIL Label */ ;

#line 228
        if (! (passno < cblk___1->numpasses + layer___0->numpasses)) {
#line 228
          goto while_break___5;
        }
#line 229
        pass___0 = cblk___1->passes + passno;
#line 230
        nump ++;
#line 231
        len += pass___0->len;
#line 232
        if (pass___0->term) {
          {
#line 233
          __cil_tmp43 = int_floorlog2(nump);
#line 233
          bio_write(bio, len, cblk___1->numlenbits + __cil_tmp43);
#line 234
          len = 0;
#line 235
          nump = 0;
          }
        } else
#line 232
        if (passno == (cblk___1->numpasses + layer___0->numpasses) - 1) {
          {
#line 233
          __cil_tmp43 = int_floorlog2(nump);
#line 233
          bio_write(bio, len, cblk___1->numlenbits + __cil_tmp43);
#line 234
          len = 0;
#line 235
          nump = 0;
          }
        }
#line 228
        passno ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___5: 
#line 187
      cblkno ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___3: 
#line 177
    bandno ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 241
  __cil_tmp47 = bio_flush(bio);
  }
#line 241
  if (__cil_tmp47) {
    {
#line 242
    bio_destroy(bio);
    }
#line 243
    return (-999);
  }
  {
#line 246
  __cil_tmp48 = bio_numbytes(bio);
#line 246
  c += __cil_tmp48;
#line 247
  bio_destroy(bio);
  }
#line 250
  if (tcp->csty & 4) {
#line 251
    *(c + 0) = (unsigned char)255;
#line 252
    *(c + 1) = (unsigned char)146;
#line 253
    c += 2;
  }
#line 260
  if (cstr_info) {
#line 260
    if (cstr_info->index_write) {
#line 261
      info_PK = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 262
      info_PK->end_ph_pos = (int )(c - dest);
    }
  }
#line 268
  bandno = 0;
  {
#line 268
  while (1) {
    while_continue___14: /* CIL Label */ ;

#line 268
    if (! (bandno < res->numbands)) {
#line 268
      goto while_break___6;
    }
#line 269
    band___1 = & res->bands[bandno];
#line 270
    prc___1 = band___1->precincts + precno;
#line 271
    cblkno = 0;
    {
#line 271
    while (1) {
      while_continue___15: /* CIL Label */ ;
      while_continue___7: ;
#line 271
      if (! (cblkno < prc___1->cw * prc___1->ch)) {
#line 271
        goto while_break___7;
      }
#line 272
      cblk___2 = prc___1->cblks.enc + cblkno;
#line 273
      layer___1 = cblk___2->layers + layno;
#line 274
      if (! layer___1->numpasses) {
#line 275
        goto while_continue___7;
      }
#line 277
      if ((unsigned long )(c + layer___1->len) > (unsigned long )(dest + length)) {
#line 278
        return (-999);
      }
      {
#line 281
      memcpy((void *)c, (void const   *)layer___1->data, (unsigned long )layer___1->len);
#line 282
      cblk___2->numpasses += layer___1->numpasses;
#line 283
      c += layer___1->len;
      }
#line 285
      if (cstr_info) {
#line 285
        if (cstr_info->index_write) {
#line 286
          info_PK___0 = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 287
          info_PK___0->disto += layer___1->disto;
#line 288
          if (cstr_info->D_max < info_PK___0->disto) {
#line 289
            cstr_info->D_max = info_PK___0->disto;
          }
        }
      }
#line 271
      cblkno ++;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___7: 
#line 268
    bandno ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___6: ;
#line 296
  return ((int )(c - dest));
}
}
#line 299 "/root/patchweave_new/2/libopenjpeg/t2.c"
static opj_bool t2_init_seg(opj_tcd_cblk_dec_t *cblk , int index___0 , int cblksty ,
                            int first ) 
{ 
  opj_tcd_seg_t *seg ;
  opj_tcd_seg_t *segs ;
  void *__cil_tmp7 ;
  int tmp ;

  {
  {
#line 302
  __cil_tmp7 = realloc((void *)cblk->segs, (unsigned long )(index___0 + 1) * sizeof(opj_tcd_seg_t ));
#line 302
  segs = (opj_tcd_seg_t *)__cil_tmp7;
  }
#line 304
  if ((unsigned long )segs == (unsigned long )((void *)0)) {
#line 306
    return (0);
  }
#line 308
  cblk->segs = segs;
#line 310
  seg = cblk->segs + index___0;
#line 311
  seg->data = (unsigned char **)((void *)0);
#line 312
  seg->dataindex = 0;
#line 313
  seg->numpasses = 0;
#line 314
  seg->len = 0;
#line 315
  if (cblksty & 4) {
#line 316
    seg->maxpasses = 1;
  } else
#line 318
  if (cblksty & 1) {
#line 319
    if (first) {
#line 320
      seg->maxpasses = 10;
    } else {
#line 322
      if ((seg - 1)->maxpasses == 1) {
#line 322
        tmp = 2;
      } else
#line 322
      if ((seg - 1)->maxpasses == 10) {
#line 322
        tmp = 2;
      } else {
#line 322
        tmp = 1;
      }
#line 322
      seg->maxpasses = tmp;
    }
  } else {
#line 325
    seg->maxpasses = 109;
  }
#line 328
  return (1);
}
}
#line 331 "/root/patchweave_new/2/libopenjpeg/t2.c"
static int t2_decode_packet(opj_t2_t *t2 , unsigned char *src , int len , opj_tcd_tile_t *tile ,
                            opj_tcp_t *tcp , opj_pi_iterator_t *pi , opj_packet_info_t *pack_info ) 
{ 
  int bandno ;
  int cblkno ;
  unsigned char *c ;
  opj_cp_t *cp ;
  int compno ;
  int resno ;
  int precno ;
  int layno ;
  opj_tcd_resolution_t *res ;
  unsigned char *hd ;
  int present ;
  opj_bio_t *bio ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_dec_t *cblk ;
  int __cil_tmp27 ;
  opj_tcd_band_t *band___0 ;
  opj_tcd_precinct_t *prc___0 ;
  int included ;
  int increment ;
  int n ;
  int segno ;
  opj_tcd_cblk_dec_t *cblk___0 ;
  int i ;
  int numimsbs ;
  int __cil_tmp39 ;
  opj_bool __cil_tmp43 ;
  opj_bool __cil_tmp44 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  opj_bool __cil_tmp48 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  opj_tcd_band_t *band___1 ;
  opj_tcd_precinct_t *prc___1 ;
  opj_tcd_cblk_dec_t *cblk___1 ;
  opj_tcd_seg_t *seg ;
  void *__cil_tmp60 ;

  {
#line 334
  c = src;
#line 336
  cp = t2->cp;
#line 338
  compno = pi->compno;
#line 339
  resno = pi->resno;
#line 340
  precno = pi->precno;
#line 341
  layno = pi->layno;
#line 343
  res = (tile->comps + compno)->resolutions + resno;
#line 345
  hd = (unsigned char *)((void *)0);
#line 348
  bio = (opj_bio_t *)((void *)0);
#line 350
  if (layno == 0) {
#line 351
    bandno = 0;
    {
#line 351
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue: ;
#line 351
      if (! (bandno < res->numbands)) {
#line 351
        goto while_break;
      }
#line 352
      band = & res->bands[bandno];
#line 353
      prc = band->precincts + precno;
#line 355
      if (band->x1 - band->x0 == 0) {
#line 355
        goto while_continue;
      } else
#line 355
      if (band->y1 - band->y0 == 0) {
#line 355
        goto while_continue;
      }
      {
#line 357
      tgt_reset(prc->incltree);
#line 358
      tgt_reset(prc->imsbtree);
#line 359
      cblkno = 0;
      }
      {
#line 359
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 359
        if (! (cblkno < prc->cw * prc->ch)) {
#line 359
          goto while_break___0;
        }
#line 360
        cblk = prc->cblks.dec + cblkno;
#line 361
        cblk->numsegs = 0;
#line 359
        cblkno ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___0: 
#line 351
      bandno ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 368
  if (tcp->csty & 2) {
#line 369
    if ((int )*c != 255) {
      {
#line 370
      opj_event_msg(t2->cinfo, 2, "Expected SOP marker\n\312U");
      }
    } else
#line 369
    if ((int )*(c + 1) != 145) {
      {
#line 370
      opj_event_msg(t2->cinfo, 2, "Expected SOP marker\n\312U");
      }
    } else {
#line 372
      c += 6;
    }
  }
  {
#line 385
  bio = bio_create();
  }
#line 387
  if (cp->ppm == 1) {
    {
#line 388
    hd = cp->ppm_data;
#line 389
    bio_init_dec(bio, hd, cp->ppm_len);
    }
  } else
#line 390
  if (tcp->ppt == 1) {
    {
#line 391
    hd = tcp->ppt_data;
#line 392
    bio_init_dec(bio, hd, tcp->ppt_len);
    }
  } else {
    {
#line 394
    hd = c;
#line 395
    bio_init_dec(bio, hd, (int )((src + len) - hd));
    }
  }
  {
#line 398
  present = bio_read(bio, 1);
  }
#line 400
  if (! present) {
    {
#line 401
    bio_inalign(bio);
#line 402
    __cil_tmp27 = bio_numbytes(bio);
#line 402
    hd += __cil_tmp27;
#line 403
    bio_destroy(bio);
    }
#line 407
    if (tcp->csty & 4) {
#line 408
      if ((int )*hd != 255) {
        {
#line 409
        printf("Error : expected EPH marker\n\312U");
        }
      } else
#line 408
      if ((int )*(hd + 1) != 146) {
        {
#line 409
        printf("Error : expected EPH marker\n\312U");
        }
      } else {
#line 411
        hd += 2;
      }
    }
#line 418
    if (pack_info) {
#line 419
      pack_info->end_ph_pos = (int )(c - src);
    }
#line 423
    if (cp->ppm == 1) {
#line 424
      cp->ppm_len = (int )((long )cp->ppm_len + (cp->ppm_data - hd));
#line 425
      cp->ppm_data = hd;
#line 426
      return ((int )(c - src));
    }
#line 428
    if (tcp->ppt == 1) {
#line 429
      tcp->ppt_len = (int )((long )tcp->ppt_len + (tcp->ppt_data - hd));
#line 430
      tcp->ppt_data = hd;
#line 431
      return ((int )(c - src));
    }
#line 434
    return ((int )(hd - src));
  }
#line 437
  bandno = 0;
  {
#line 437
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___1: ;
#line 437
    if (! (bandno < res->numbands)) {
#line 437
      goto while_break___1;
    }
#line 438
    band___0 = & res->bands[bandno];
#line 439
    prc___0 = band___0->precincts + precno;
#line 441
    if (band___0->x1 - band___0->x0 == 0) {
#line 441
      goto while_continue___1;
    } else
#line 441
    if (band___0->y1 - band___0->y0 == 0) {
#line 441
      goto while_continue___1;
    }
#line 443
    cblkno = 0;
    {
#line 443
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___2: ;
#line 443
      if (! (cblkno < prc___0->cw * prc___0->ch)) {
#line 443
        goto while_break___2;
      }
#line 445
      cblk___0 = prc___0->cblks.dec + cblkno;
#line 447
      if (! cblk___0->numsegs) {
        {
#line 448
        included = tgt_decode(bio, prc___0->incltree, cblkno, layno + 1);
        }
      } else {
        {
#line 451
        included = bio_read(bio, 1);
        }
      }
#line 454
      if (! included) {
#line 455
        cblk___0->numnewpasses = 0;
#line 456
        goto while_continue___2;
      }
#line 459
      if (! cblk___0->numsegs) {
#line 461
        i = 0;
        {
#line 461
        while (1) {
          while_continue___11: /* CIL Label */ ;

#line 461
          if (! (! __cil_tmp39)) {
#line 461
            goto while_break___3;
          }
#line 461
          i ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___3: 
#line 464
        numimsbs = i - 1;
#line 465
        cblk___0->numbps = band___0->numbps - numimsbs;
#line 466
        cblk___0->numlenbits = 3;
      }
      {
#line 469
      cblk___0->numnewpasses = t2_getnumpasses(bio);
#line 470
      increment = t2_getcommacode(bio);
#line 472
      cblk___0->numlenbits += increment;
#line 473
      segno = 0;
      }
#line 474
      if (! cblk___0->numsegs) {
        {
#line 475
        __cil_tmp43 = t2_init_seg(cblk___0, segno, (tcp->tccps + compno)->cblksty,
                                  1);
        }
#line 475
        if (! __cil_tmp43) {
          {
#line 477
          opj_event_msg(t2->cinfo, 1, "Out of memory\n");
#line 478
          bio_destroy(bio);
          }
#line 479
          return (-999);
        }
      } else {
#line 482
        segno = cblk___0->numsegs - 1;
#line 483
        if ((cblk___0->segs + segno)->numpasses == (cblk___0->segs + segno)->maxpasses) {
          {
#line 484
          segno ++;
#line 485
          __cil_tmp44 = t2_init_seg(cblk___0, segno, (tcp->tccps + compno)->cblksty,
                                    0);
          }
#line 485
          if (! __cil_tmp44) {
            {
#line 487
            opj_event_msg(t2->cinfo, 1, "Out of memory\n");
#line 488
            bio_destroy(bio);
            }
#line 489
            return (-999);
          }
        }
      }
#line 493
      n = cblk___0->numnewpasses;
      {
#line 495
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 496
        (cblk___0->segs + segno)->numnewpasses = int_min((cblk___0->segs + segno)->maxpasses - (cblk___0->segs + segno)->numpasses,
                                                         n);
#line 497
        __cil_tmp46 = int_floorlog2((cblk___0->segs + segno)->numnewpasses);
#line 497
        __cil_tmp47 = bio_read(bio, cblk___0->numlenbits + __cil_tmp46);
#line 497
        (cblk___0->segs + segno)->newlen = __cil_tmp47;
#line 498
        n -= (cblk___0->segs + segno)->numnewpasses;
        }
#line 499
        if (n > 0) {
          {
#line 500
          segno ++;
#line 501
          __cil_tmp48 = t2_init_seg(cblk___0, segno, (tcp->tccps + compno)->cblksty,
                                    0);
          }
#line 501
          if (! __cil_tmp48) {
            {
#line 503
            opj_event_msg(t2->cinfo, 1, "Out of memory\n");
#line 504
            bio_destroy(bio);
            }
#line 505
            return (-999);
          }
        }
#line 495
        if (! (n > 0)) {
#line 495
          goto while_break___4;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___4: 
#line 443
      cblkno ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___2: 
#line 437
    bandno ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 512
  __cil_tmp51 = bio_inalign(bio);
  }
#line 512
  if (__cil_tmp51) {
    {
#line 513
    bio_destroy(bio);
    }
#line 514
    return (-999);
  }
  {
#line 517
  __cil_tmp52 = bio_numbytes(bio);
#line 517
  hd += __cil_tmp52;
#line 518
  bio_destroy(bio);
  }
#line 521
  if (tcp->csty & 4) {
#line 522
    if ((int )*hd != 255) {
      {
#line 523
      opj_event_msg(t2->cinfo, 1, "Expected EPH marker\n");
      }
#line 524
      return (-999);
    } else
#line 522
    if ((int )*(hd + 1) != 146) {
      {
#line 523
      opj_event_msg(t2->cinfo, 1, "Expected EPH marker\n");
      }
#line 524
      return (-999);
    } else {
#line 526
      hd += 2;
    }
  }
#line 533
  if (pack_info) {
#line 534
    pack_info->end_ph_pos = (int )(hd - src);
  }
#line 538
  if (cp->ppm == 1) {
#line 539
    cp->ppm_len = (int )((long )cp->ppm_len + (cp->ppm_data - hd));
#line 540
    cp->ppm_data = hd;
  } else
#line 541
  if (tcp->ppt == 1) {
#line 542
    tcp->ppt_len = (int )((long )tcp->ppt_len + (tcp->ppt_data - hd));
#line 543
    tcp->ppt_data = hd;
  } else {
#line 545
    c = hd;
  }
#line 548
  bandno = 0;
  {
#line 548
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue___5: ;
#line 548
    if (! (bandno < res->numbands)) {
#line 548
      goto while_break___5;
    }
#line 549
    band___1 = & res->bands[bandno];
#line 550
    prc___1 = band___1->precincts + precno;
#line 552
    if (band___1->x1 - band___1->x0 == 0) {
#line 552
      goto while_continue___5;
    } else
#line 552
    if (band___1->y1 - band___1->y0 == 0) {
#line 552
      goto while_continue___5;
    }
#line 554
    cblkno = 0;
    {
#line 554
    while (1) {
      while_continue___14: /* CIL Label */ ;
      while_continue___6: ;
#line 554
      if (! (cblkno < prc___1->cw * prc___1->ch)) {
#line 554
        goto while_break___6;
      }
#line 555
      cblk___1 = prc___1->cblks.dec + cblkno;
#line 556
      seg = (opj_tcd_seg_t *)((void *)0);
#line 557
      if (! cblk___1->numnewpasses) {
#line 558
        goto while_continue___6;
      }
#line 559
      if (! cblk___1->numsegs) {
#line 560
        seg = cblk___1->segs + 0;
#line 561
        (cblk___1->numsegs) ++;
#line 562
        cblk___1->len = 0;
      } else {
#line 564
        seg = cblk___1->segs + (cblk___1->numsegs - 1);
#line 565
        if (seg->numpasses == seg->maxpasses) {
#line 566
          seg ++;
#line 567
          (cblk___1->numsegs) ++;
        }
      }
      {
#line 571
      while (1) {
        while_continue___15: /* CIL Label */ ;

#line 572
        if ((unsigned long )(c + seg->newlen) > (unsigned long )(src + len)) {
#line 573
          return (-999);
        }
        {
#line 596
        __cil_tmp60 = realloc((void *)cblk___1->data, (unsigned long )(cblk___1->len + seg->newlen) * sizeof(unsigned char ));
#line 596
        cblk___1->data = (unsigned char *)__cil_tmp60;
#line 597
        memcpy((void *)(cblk___1->data + cblk___1->len), (void const   *)c, (unsigned long )seg->newlen);
        }
#line 598
        if (seg->numpasses == 0) {
#line 599
          seg->data = & cblk___1->data;
#line 600
          seg->dataindex = cblk___1->len;
        }
#line 602
        c += seg->newlen;
#line 603
        cblk___1->len += seg->newlen;
#line 604
        seg->len += seg->newlen;
#line 605
        seg->numpasses += seg->numnewpasses;
#line 606
        cblk___1->numnewpasses -= seg->numnewpasses;
#line 607
        if (cblk___1->numnewpasses > 0) {
#line 608
          seg ++;
#line 609
          (cblk___1->numsegs) ++;
        }
#line 571
        if (! (cblk___1->numnewpasses > 0)) {
#line 571
          goto while_break___7;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___7: 
#line 554
      cblkno ++;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___6: 
#line 548
    bandno ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___5: ;
#line 615
  return ((int )(c - src));
}
}
#line 620 "/root/patchweave_new/2/libopenjpeg/t2.c"
int t2_encode_packets(opj_t2_t *t2 , int tileno , opj_tcd_tile_t *tile , int maxlayers ,
                      unsigned char *dest , int len , opj_codestream_info_t *cstr_info ,
                      int tpnum , int tppos , int pino , J2K_T2_MODE t2_mode , int cur_totnum_tp ) 
{ 
  unsigned char *c ;
  int e ;
  int compno ;
  opj_pi_iterator_t *pi ;
  int poc ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  int pocno ;
  int tmp ;
  int maxcomp ;
  int tmp___0 ;
  int comp_len ;
  int tpnum___2 ;
  opj_bool __cil_tmp28 ;
  opj_bool __cil_tmp29 ;
  opj_bool __cil_tmp33 ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  int tmp___1 ;

  {
#line 621
  c = dest;
#line 622
  e = 0;
#line 624
  pi = (opj_pi_iterator_t *)((void *)0);
#line 626
  image = t2->image;
#line 627
  cp = t2->cp;
#line 628
  tcp = cp->tcps + tileno;
#line 629
  if ((unsigned int )cp->cinema == 3U) {
#line 629
    tmp = 2;
  } else {
#line 629
    tmp = 1;
  }
#line 629
  pocno = tmp;
#line 630
  if (cp->max_comp_size > 0) {
#line 630
    tmp___0 = image->numcomps;
  } else {
#line 630
    tmp___0 = 1;
  }
  {
#line 630
  maxcomp = tmp___0;
#line 632
  pi = pi_initialise_encode(image, cp, tileno, t2_mode);
  }
#line 633
  if (! pi) {
#line 635
    return (-999);
  }
#line 638
  if ((unsigned int )t2_mode == 0U) {
#line 639
    compno = 0;
    {
#line 639
    while (1) {
      while_continue: /* CIL Label */ ;

#line 639
      if (! (compno < maxcomp)) {
#line 639
        goto while_break;
      }
#line 640
      poc = 0;
      {
#line 640
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 640
        if (! (poc < pocno)) {
#line 640
          goto while_break___0;
        }
        {
#line 641
        comp_len = 0;
#line 642
        tpnum___2 = compno;
#line 643
        __cil_tmp28 = pi_create_encode(pi, cp, tileno, poc, tpnum___2, tppos, t2_mode,
                                       cur_totnum_tp);
        }
#line 643
        if (__cil_tmp28) {
          {
#line 644
          opj_event_msg(t2->cinfo, 1, "Error initializing Packet Iterator\n");
#line 645
          pi_destroy(pi, cp, tileno);
          }
#line 646
          return (-999);
        }
        {
#line 648
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 648
          __cil_tmp29 = pi_next(pi + poc);
          }
#line 648
          if (! __cil_tmp29) {
#line 648
            goto while_break___1;
          }
#line 649
          if ((pi + poc)->layno < maxlayers) {
            {
#line 650
            e = t2_encode_packet(tile, cp->tcps + tileno, pi + poc, c, (int )((dest + len) - c),
                                 cstr_info, tileno);
#line 651
            comp_len += e;
            }
#line 652
            if (e == -999) {
#line 653
              goto while_break___1;
            } else {
#line 655
              c += e;
            }
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: ;
#line 659
        if (e == -999) {
#line 659
          goto while_break___0;
        }
#line 660
        if (cp->max_comp_size) {
#line 661
          if (comp_len > cp->max_comp_size) {
#line 662
            e = -999;
#line 663
            goto while_break___0;
          }
        }
#line 640
        poc ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: ;
#line 667
      if (e == -999) {
#line 667
        goto while_break;
      }
#line 639
      compno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 670
    pi_create_encode(pi, cp, tileno, pino, tpnum, tppos, t2_mode, cur_totnum_tp);
    }
    {
#line 671
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 671
      __cil_tmp33 = pi_next(pi + pino);
      }
#line 671
      if (! __cil_tmp33) {
#line 671
        goto while_break___2;
      }
#line 672
      if ((pi + pino)->layno < maxlayers) {
        {
#line 673
        e = t2_encode_packet(tile, cp->tcps + tileno, pi + pino, c, (int )((dest + len) - c),
                             cstr_info, tileno);
        }
#line 674
        if (e == -999) {
#line 675
          goto while_break___2;
        } else {
#line 677
          c += e;
        }
#line 680
        if (cstr_info) {
#line 681
          if (cstr_info->index_write) {
#line 682
            info_TL = cstr_info->tile + tileno;
#line 683
            info_PK = info_TL->packet + cstr_info->packno;
#line 684
            if (! cstr_info->packno) {
#line 685
              info_PK->start_pos = info_TL->end_header + 1;
            } else {
#line 687
              if ((int )cp->tp_on | tcp->POC) {
#line 687
                if (info_PK->start_pos) {
#line 687
                  tmp___1 = info_PK->start_pos;
                } else {
#line 687
                  tmp___1 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1;
                }
              } else {
#line 687
                tmp___1 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1;
              }
#line 687
              info_PK->start_pos = tmp___1;
            }
#line 689
            info_PK->end_pos = (info_PK->start_pos + e) - 1;
#line 690
            info_PK->end_ph_pos += info_PK->start_pos - 1;
          }
#line 694
          (cstr_info->packno) ++;
        }
#line 697
        (tile->packno) ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
  {
#line 702
  pi_destroy(pi, cp, tileno);
  }
#line 704
  if (e == -999) {
#line 705
    return (e);
  }
#line 708
  return ((int )(c - dest));
}
}
#line 711 "/root/patchweave_new/2/libopenjpeg/t2.c"
int t2_decode_packets(opj_t2_t *t2 , unsigned char *src , int len , int tileno , opj_tcd_tile_t *tile ,
                      opj_codestream_info_t *cstr_info ) 
{ 
  unsigned char *c ;
  opj_pi_iterator_t *pi ;
  int pino ;
  int e ;
  int n ;
  int curtp ;
  int tp_start_packno ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  opj_bool __cil_tmp17 ;
  opj_packet_info_t *pack_info ;
  int __cil_tmp20 ;
  int tmp ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  int tmp___0 ;

  {
  {
#line 712
  c = src;
#line 714
  e = 0;
#line 715
  n = 0;
#line 715
  curtp = 0;
#line 718
  image = t2->image;
#line 719
  cp = t2->cp;
#line 722
  pi = pi_create_decode(image, cp, tileno);
  }
#line 723
  if (! pi) {
#line 725
    return (-999);
  }
#line 728
  tp_start_packno = 0;
#line 730
  pino = 0;
  {
#line 730
  while (1) {
    while_continue: /* CIL Label */ ;

#line 730
    if (! (pino <= (cp->tcps + tileno)->numpocs)) {
#line 730
      goto while_break;
    }
    {
#line 731
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 731
      __cil_tmp17 = pi_next(pi + pino);
      }
#line 731
      if (! __cil_tmp17) {
#line 731
        goto while_break___0;
      }
#line 732
      if (cp->layer == 0) {
        _L: 
#line 734
        if (cstr_info) {
#line 735
          pack_info = (cstr_info->tile + tileno)->packet + cstr_info->packno;
        } else {
#line 737
          pack_info = (opj_packet_info_t *)((void *)0);
        }
        {
#line 738
        e = t2_decode_packet(t2, c, (int )((src + len) - c), tile, cp->tcps + tileno,
                             pi + pino, pack_info);
        }
      } else
#line 732
      if (cp->layer >= (pi + pino)->layno + 1) {
#line 732
        goto _L;
      } else {
#line 740
        e = 0;
      }
#line 742
      if (e == -999) {
        {
#line 744
        pi_destroy(pi, cp, tileno);
        }
#line 745
        return (-999);
      }
#line 748
      if (e > 0) {
        {
#line 748
        __cil_tmp20 = int_max((pi + pino)->resno, (image->comps + (pi + pino)->compno)->resno_decoded);
#line 748
        tmp = __cil_tmp20;
        }
      } else {
#line 748
        tmp = (image->comps + (pi + pino)->compno)->resno_decoded;
      }
#line 748
      (image->comps + (pi + pino)->compno)->resno_decoded = tmp;
#line 752
      n ++;
#line 755
      if (cstr_info) {
#line 756
        info_TL = cstr_info->tile + tileno;
#line 757
        info_PK = info_TL->packet + cstr_info->packno;
#line 758
        if (! cstr_info->packno) {
#line 759
          info_PK->start_pos = info_TL->end_header + 1;
        } else
#line 760
        if ((info_TL->packet + (cstr_info->packno - 1))->end_pos >= ((cstr_info->tile + tileno)->tp + curtp)->tp_end_pos) {
#line 761
          (info_TL->tp + curtp)->tp_numpacks = cstr_info->packno - tp_start_packno;
#line 762
          (info_TL->tp + curtp)->tp_start_pack = tp_start_packno;
#line 763
          tp_start_packno = cstr_info->packno;
#line 764
          curtp ++;
#line 765
          info_PK->start_pos = ((cstr_info->tile + tileno)->tp + curtp)->tp_end_header + 1;
        } else {
#line 767
          if ((int )cp->tp_on) {
#line 767
            if (info_PK->start_pos) {
#line 767
              tmp___0 = info_PK->start_pos;
            } else {
#line 767
              tmp___0 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1;
            }
          } else {
#line 767
            tmp___0 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1;
          }
#line 767
          info_PK->start_pos = tmp___0;
        }
#line 769
        info_PK->end_pos = (info_PK->start_pos + e) - 1;
#line 770
        info_PK->end_ph_pos += info_PK->start_pos - 1;
#line 772
        (cstr_info->packno) ++;
      }
#line 776
      if (e == -999) {
#line 777
        goto while_break___0;
      } else {
#line 779
        c += e;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 730
    pino ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 784
  if (cstr_info) {
#line 785
    ((cstr_info->tile + tileno)->tp + curtp)->tp_numpacks = cstr_info->packno - tp_start_packno;
#line 786
    ((cstr_info->tile + tileno)->tp + curtp)->tp_start_pack = tp_start_packno;
  }
  {
#line 791
  pi_destroy(pi, cp, tileno);
  }
#line 793
  if (e == -999) {
#line 794
    return (e);
  }
#line 797
  return ((int )(c - src));
}
}
#line 802 "/root/patchweave_new/2/libopenjpeg/t2.c"
opj_t2_t *t2_create(opj_common_ptr cinfo , opj_image_t *image , opj_cp_t *cp ) 
{ 
  opj_t2_t *t2 ;
  void *__cil_tmp5 ;

  {
  {
#line 804
  __cil_tmp5 = malloc(sizeof(opj_t2_t ));
#line 804
  t2 = (opj_t2_t *)__cil_tmp5;
  }
#line 805
  if (! t2) {
#line 805
    return ((opj_t2_t *)((void *)0));
  }
#line 806
  t2->cinfo = cinfo;
#line 807
  t2->image = image;
#line 808
  t2->cp = cp;
#line 810
  return (t2);
}
}
#line 813 "/root/patchweave_new/2/libopenjpeg/t2.c"
void t2_destroy(opj_t2_t *t2 ) 
{ 


  {
#line 814
  if (t2) {
    {
#line 815
    free((void *)t2);
    }
  }
#line 818
  return;
}
}
#line 3 "/root/patchweave_new/2/libopenjpeg/t1_luts.h"
static char lut_ctxno_zc[1024]  = 
#line 3 "/root/patchweave_new/2/libopenjpeg/t1_luts.h"
  {      (char)0,      (char)1,      (char)1,      (char)2, 
        (char)1,      (char)2,      (char)2,      (char)2, 
        (char)1,      (char)2,      (char)2,      (char)2, 
        (char)2,      (char)2,      (char)2,      (char)2, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)5,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)4,      (char)4,      (char)4,      (char)4, 
        (char)4,      (char)4,      (char)4,      (char)4, 
        (char)4,      (char)4,      (char)4,      (char)4, 
        (char)4,      (char)4,      (char)4,      (char)4, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)5,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)0,      (char)1,      (char)1,      (char)2, 
        (char)1,      (char)2,      (char)2,      (char)2, 
        (char)1,      (char)2,      (char)2,      (char)2, 
        (char)2,      (char)2,      (char)2,      (char)2, 
        (char)5,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)5,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)4,      (char)4,      (char)4,      (char)4, 
        (char)4,      (char)4,      (char)4,      (char)4, 
        (char)4,      (char)4,      (char)4,      (char)4, 
        (char)4,      (char)4,      (char)4,      (char)4, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)0,      (char)1,      (char)1,      (char)2, 
        (char)1,      (char)2,      (char)2,      (char)2, 
        (char)1,      (char)2,      (char)2,      (char)2, 
        (char)2,      (char)2,      (char)2,      (char)2, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)5,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)4,      (char)4,      (char)4,      (char)4, 
        (char)4,      (char)4,      (char)4,      (char)4, 
        (char)4,      (char)4,      (char)4,      (char)4, 
        (char)4,      (char)4,      (char)4,      (char)4, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)5,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)6,      (char)6,      (char)6,      (char)6, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)7,      (char)7,      (char)7,      (char)7, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)8,      (char)8,      (char)8,      (char)8, 
        (char)0,      (char)3,      (char)3,      (char)6, 
        (char)3,      (char)6,      (char)6,      (char)8, 
        (char)3,      (char)6,      (char)6,      (char)8, 
        (char)6,      (char)8,      (char)8,      (char)8, 
        (char)1,      (char)4,      (char)4,      (char)7, 
        (char)4,      (char)7,      (char)7,      (char)8, 
        (char)4,      (char)7,      (char)7,      (char)8, 
        (char)7,      (char)8,      (char)8,      (char)8, 
        (char)1,      (char)4,      (char)4,      (char)7, 
        (char)4,      (char)7,      (char)7,      (char)8, 
        (char)4,      (char)7,      (char)7,      (char)8, 
        (char)7,      (char)8,      (char)8,      (char)8, 
        (char)2,      (char)5,      (char)5,      (char)7, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)7,      (char)8,      (char)8,      (char)8, 
        (char)1,      (char)4,      (char)4,      (char)7, 
        (char)4,      (char)7,      (char)7,      (char)8, 
        (char)4,      (char)7,      (char)7,      (char)8, 
        (char)7,      (char)8,      (char)8,      (char)8, 
        (char)2,      (char)5,      (char)5,      (char)7, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)7,      (char)8,      (char)8,      (char)8, 
        (char)2,      (char)5,      (char)5,      (char)7, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)7,      (char)8,      (char)8,      (char)8, 
        (char)2,      (char)5,      (char)5,      (char)7, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)7,      (char)8,      (char)8,      (char)8, 
        (char)1,      (char)4,      (char)4,      (char)7, 
        (char)4,      (char)7,      (char)7,      (char)8, 
        (char)4,      (char)7,      (char)7,      (char)8, 
        (char)7,      (char)8,      (char)8,      (char)8, 
        (char)2,      (char)5,      (char)5,      (char)7, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)7,      (char)8,      (char)8,      (char)8, 
        (char)2,      (char)5,      (char)5,      (char)7, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)7,      (char)8,      (char)8,      (char)8, 
        (char)2,      (char)5,      (char)5,      (char)7, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)7,      (char)8,      (char)8,      (char)8, 
        (char)2,      (char)5,      (char)5,      (char)7, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)7,      (char)8,      (char)8,      (char)8, 
        (char)2,      (char)5,      (char)5,      (char)7, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)7,      (char)8,      (char)8,      (char)8, 
        (char)2,      (char)5,      (char)5,      (char)7, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)7,      (char)8,      (char)8,      (char)8, 
        (char)2,      (char)5,      (char)5,      (char)7, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)5,      (char)7,      (char)7,      (char)8, 
        (char)7,      (char)8,      (char)8,      (char)8};
#line 38 "/root/patchweave_new/2/libopenjpeg/t1_luts.h"
static char lut_ctxno_sc[256]  = 
#line 38
  {      (char)9,      (char)10,      (char)12,      (char)13, 
        (char)10,      (char)10,      (char)13,      (char)13, 
        (char)12,      (char)13,      (char)12,      (char)13, 
        (char)13,      (char)13,      (char)13,      (char)13, 
        (char)9,      (char)10,      (char)12,      (char)11, 
        (char)10,      (char)9,      (char)13,      (char)12, 
        (char)12,      (char)11,      (char)12,      (char)11, 
        (char)13,      (char)12,      (char)13,      (char)12, 
        (char)9,      (char)10,      (char)12,      (char)11, 
        (char)10,      (char)10,      (char)11,      (char)11, 
        (char)12,      (char)13,      (char)9,      (char)10, 
        (char)13,      (char)13,      (char)10,      (char)10, 
        (char)9,      (char)10,      (char)12,      (char)13, 
        (char)10,      (char)9,      (char)11,      (char)12, 
        (char)12,      (char)11,      (char)9,      (char)10, 
        (char)13,      (char)12,      (char)10,      (char)9, 
        (char)9,      (char)10,      (char)12,      (char)13, 
        (char)10,      (char)9,      (char)11,      (char)12, 
        (char)12,      (char)13,      (char)12,      (char)13, 
        (char)11,      (char)12,      (char)11,      (char)12, 
        (char)9,      (char)10,      (char)12,      (char)11, 
        (char)10,      (char)10,      (char)11,      (char)11, 
        (char)12,      (char)11,      (char)12,      (char)11, 
        (char)11,      (char)11,      (char)11,      (char)11, 
        (char)9,      (char)10,      (char)12,      (char)11, 
        (char)10,      (char)9,      (char)13,      (char)12, 
        (char)12,      (char)13,      (char)9,      (char)10, 
        (char)11,      (char)12,      (char)10,      (char)9, 
        (char)9,      (char)10,      (char)12,      (char)13, 
        (char)10,      (char)10,      (char)13,      (char)13, 
        (char)12,      (char)11,      (char)9,      (char)10, 
        (char)11,      (char)11,      (char)10,      (char)10, 
        (char)9,      (char)10,      (char)12,      (char)13, 
        (char)10,      (char)10,      (char)13,      (char)13, 
        (char)12,      (char)11,      (char)9,      (char)10, 
        (char)11,      (char)11,      (char)10,      (char)10, 
        (char)9,      (char)10,      (char)12,      (char)11, 
        (char)10,      (char)9,      (char)13,      (char)12, 
        (char)12,      (char)13,      (char)9,      (char)10, 
        (char)11,      (char)12,      (char)10,      (char)9, 
        (char)9,      (char)10,      (char)12,      (char)11, 
        (char)10,      (char)10,      (char)11,      (char)11, 
        (char)12,      (char)11,      (char)12,      (char)11, 
        (char)11,      (char)11,      (char)11,      (char)11, 
        (char)9,      (char)10,      (char)12,      (char)13, 
        (char)10,      (char)9,      (char)11,      (char)12, 
        (char)12,      (char)13,      (char)12,      (char)13, 
        (char)11,      (char)12,      (char)11,      (char)12, 
        (char)9,      (char)10,      (char)12,      (char)13, 
        (char)10,      (char)9,      (char)11,      (char)12, 
        (char)12,      (char)11,      (char)9,      (char)10, 
        (char)13,      (char)12,      (char)10,      (char)9, 
        (char)9,      (char)10,      (char)12,      (char)11, 
        (char)10,      (char)10,      (char)11,      (char)11, 
        (char)12,      (char)13,      (char)9,      (char)10, 
        (char)13,      (char)13,      (char)10,      (char)10, 
        (char)9,      (char)10,      (char)12,      (char)11, 
        (char)10,      (char)9,      (char)13,      (char)12, 
        (char)12,      (char)11,      (char)12,      (char)11, 
        (char)13,      (char)12,      (char)13,      (char)12, 
        (char)9,      (char)10,      (char)12,      (char)13, 
        (char)10,      (char)10,      (char)13,      (char)13, 
        (char)12,      (char)13,      (char)12,      (char)13, 
        (char)13,      (char)13,      (char)13,      (char)13};
#line 57 "/root/patchweave_new/2/libopenjpeg/t1_luts.h"
static char lut_spb[256]  = 
#line 57
  {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)1,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)1,      (char)1, 
        (char)0,      (char)0,      (char)1,      (char)1, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)1,      (char)1,      (char)1, 
        (char)0,      (char)0,      (char)1,      (char)1, 
        (char)0,      (char)0,      (char)0,      (char)1, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)1,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)1,      (char)0,      (char)0, 
        (char)1,      (char)1,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)1,      (char)1, 
        (char)1,      (char)0,      (char)1,      (char)1, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)1,      (char)0, 
        (char)0,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)0,      (char)0,      (char)0,      (char)1, 
        (char)0,      (char)0,      (char)1,      (char)1, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)1,      (char)1,      (char)0,      (char)0, 
        (char)1,      (char)1,      (char)0,      (char)0, 
        (char)0,      (char)1,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)1,      (char)1,      (char)0,      (char)1, 
        (char)1,      (char)1,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)1,      (char)1, 
        (char)0,      (char)0,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)0,      (char)1,      (char)1,      (char)1, 
        (char)0,      (char)0,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)1,      (char)0,      (char)0,      (char)0, 
        (char)1,      (char)1,      (char)0,      (char)0, 
        (char)1,      (char)1,      (char)1,      (char)0, 
        (char)0,      (char)1,      (char)0,      (char)0, 
        (char)1,      (char)1,      (char)0,      (char)0, 
        (char)1,      (char)1,      (char)0,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)0,      (char)0,      (char)1,      (char)1, 
        (char)1,      (char)0,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)0,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1};
#line 68 "/root/patchweave_new/2/libopenjpeg/t1_luts.h"
static short lut_nmsedec_sig[128]  = 
#line 68
  {      (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)384,      (short)768,      (short)1152, 
        (short)1536,      (short)1920,      (short)2304,      (short)2688, 
        (short)3072,      (short)3456,      (short)3840,      (short)4224, 
        (short)4608,      (short)4992,      (short)5376,      (short)5760, 
        (short)6144,      (short)6528,      (short)6912,      (short)7296, 
        (short)7680,      (short)8064,      (short)8448,      (short)8832, 
        (short)9216,      (short)9600,      (short)9984,      (short)10368, 
        (short)10752,      (short)11136,      (short)11520,      (short)11904, 
        (short)12288,      (short)12672,      (short)13056,      (short)13440, 
        (short)13824,      (short)14208,      (short)14592,      (short)14976, 
        (short)15360,      (short)15744,      (short)16128,      (short)16512, 
        (short)16896,      (short)17280,      (short)17664,      (short)18048, 
        (short)18432,      (short)18816,      (short)19200,      (short)19584, 
        (short)19968,      (short)20352,      (short)20736,      (short)21120, 
        (short)21504,      (short)21888,      (short)22272,      (short)22656, 
        (short)23040,      (short)23424,      (short)23808,      (short)24192, 
        (short)24576,      (short)24960,      (short)25344,      (short)25728, 
        (short)26112,      (short)26496,      (short)26880,      (short)27264, 
        (short)27648,      (short)28032,      (short)28416,      (short)28800, 
        (short)29184,      (short)29568,      (short)29952,      (short)30336};
#line 87 "/root/patchweave_new/2/libopenjpeg/t1_luts.h"
static short lut_nmsedec_sig0[128]  = 
#line 87
  {      (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)128,      (short)128, 
        (short)128,      (short)128,      (short)256,      (short)256, 
        (short)256,      (short)384,      (short)384,      (short)512, 
        (short)512,      (short)640,      (short)640,      (short)768, 
        (short)768,      (short)896,      (short)1024,      (short)1024, 
        (short)1152,      (short)1280,      (short)1408,      (short)1408, 
        (short)1536,      (short)1664,      (short)1792,      (short)1920, 
        (short)2048,      (short)2176,      (short)2304,      (short)2432, 
        (short)2560,      (short)2688,      (short)2944,      (short)3072, 
        (short)3200,      (short)3328,      (short)3584,      (short)3712, 
        (short)3840,      (short)4096,      (short)4224,      (short)4480, 
        (short)4608,      (short)4864,      (short)4992,      (short)5248, 
        (short)5376,      (short)5632,      (short)5888,      (short)6016, 
        (short)6272,      (short)6528,      (short)6784,      (short)6912, 
        (short)7168,      (short)7424,      (short)7680,      (short)7936, 
        (short)8192,      (short)8448,      (short)8704,      (short)8960, 
        (short)9216,      (short)9472,      (short)9856,      (short)10112, 
        (short)10368,      (short)10624,      (short)11008,      (short)11264, 
        (short)11520,      (short)11904,      (short)12160,      (short)12544, 
        (short)12800,      (short)13184,      (short)13440,      (short)13824, 
        (short)14080,      (short)14464,      (short)14848,      (short)15104, 
        (short)15488,      (short)15872,      (short)16256,      (short)16512, 
        (short)16896,      (short)17280,      (short)17664,      (short)18048, 
        (short)18432,      (short)18816,      (short)19200,      (short)19584, 
        (short)19968,      (short)20352,      (short)20864,      (short)21248, 
        (short)21632,      (short)22016,      (short)22528,      (short)22912, 
        (short)23296,      (short)23808,      (short)24192,      (short)24704, 
        (short)25088,      (short)25600,      (short)25984,      (short)26496, 
        (short)26880,      (short)27392,      (short)27904,      (short)28288, 
        (short)28800,      (short)29312,      (short)29824,      (short)30208, 
        (short)30720,      (short)31232,      (short)31744,      (short)32256};
#line 106 "/root/patchweave_new/2/libopenjpeg/t1_luts.h"
static short lut_nmsedec_ref[128]  = 
#line 106
  {      (short)6144,      (short)6016,      (short)5888,      (short)5760, 
        (short)5632,      (short)5504,      (short)5376,      (short)5248, 
        (short)5120,      (short)4992,      (short)4864,      (short)4736, 
        (short)4608,      (short)4480,      (short)4352,      (short)4224, 
        (short)4096,      (short)3968,      (short)3840,      (short)3712, 
        (short)3584,      (short)3456,      (short)3328,      (short)3200, 
        (short)3072,      (short)2944,      (short)2816,      (short)2688, 
        (short)2560,      (short)2432,      (short)2304,      (short)2176, 
        (short)2048,      (short)1920,      (short)1792,      (short)1664, 
        (short)1536,      (short)1408,      (short)1280,      (short)1152, 
        (short)1024,      (short)896,      (short)768,      (short)640, 
        (short)512,      (short)384,      (short)256,      (short)128, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)128,      (short)256,      (short)384, 
        (short)512,      (short)640,      (short)768,      (short)896, 
        (short)1024,      (short)1152,      (short)1280,      (short)1408, 
        (short)1536,      (short)1664,      (short)1792,      (short)1920, 
        (short)2048,      (short)2176,      (short)2304,      (short)2432, 
        (short)2560,      (short)2688,      (short)2816,      (short)2944, 
        (short)3072,      (short)3200,      (short)3328,      (short)3456, 
        (short)3584,      (short)3712,      (short)3840,      (short)3968, 
        (short)4096,      (short)4224,      (short)4352,      (short)4480, 
        (short)4608,      (short)4736,      (short)4864,      (short)4992, 
        (short)5120,      (short)5248,      (short)5376,      (short)5504, 
        (short)5632,      (short)5760,      (short)5888,      (short)6016};
#line 125 "/root/patchweave_new/2/libopenjpeg/t1_luts.h"
static short lut_nmsedec_ref0[128]  = 
#line 125
  {      (short)8192,      (short)7936,      (short)7680,      (short)7424, 
        (short)7168,      (short)6912,      (short)6784,      (short)6528, 
        (short)6272,      (short)6016,      (short)5888,      (short)5632, 
        (short)5376,      (short)5248,      (short)4992,      (short)4864, 
        (short)4608,      (short)4480,      (short)4224,      (short)4096, 
        (short)3840,      (short)3712,      (short)3584,      (short)3328, 
        (short)3200,      (short)3072,      (short)2944,      (short)2688, 
        (short)2560,      (short)2432,      (short)2304,      (short)2176, 
        (short)2048,      (short)1920,      (short)1792,      (short)1664, 
        (short)1536,      (short)1408,      (short)1408,      (short)1280, 
        (short)1152,      (short)1024,      (short)1024,      (short)896, 
        (short)768,      (short)768,      (short)640,      (short)640, 
        (short)512,      (short)512,      (short)384,      (short)384, 
        (short)256,      (short)256,      (short)256,      (short)128, 
        (short)128,      (short)128,      (short)128,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)128,      (short)128, 
        (short)128,      (short)128,      (short)256,      (short)256, 
        (short)256,      (short)384,      (short)384,      (short)512, 
        (short)512,      (short)640,      (short)640,      (short)768, 
        (short)768,      (short)896,      (short)1024,      (short)1024, 
        (short)1152,      (short)1280,      (short)1408,      (short)1408, 
        (short)1536,      (short)1664,      (short)1792,      (short)1920, 
        (short)2048,      (short)2176,      (short)2304,      (short)2432, 
        (short)2560,      (short)2688,      (short)2944,      (short)3072, 
        (short)3200,      (short)3328,      (short)3584,      (short)3712, 
        (short)3840,      (short)4096,      (short)4224,      (short)4480, 
        (short)4608,      (short)4864,      (short)4992,      (short)5248, 
        (short)5376,      (short)5632,      (short)5888,      (short)6016, 
        (short)6272,      (short)6528,      (short)6784,      (short)6912, 
        (short)7168,      (short)7424,      (short)7680,      (short)7936};
#line 42 "/root/patchweave_new/2/libopenjpeg/t1.c"
static char t1_getctxno_zc(int f , int orient ) ;
#line 43
static char t1_getctxno_sc(int f ) ;
#line 44
static int t1_getctxno_mag(int f ) ;
#line 45
static char t1_getspb(int f ) ;
#line 46
static short t1_getnmsedec_sig(int x , int bitpos ) ;
#line 47
static short t1_getnmsedec_ref(int x , int bitpos ) ;
#line 48
static void t1_updateflags(flag_t *flagsp , int s , int stride ) ;
#line 52
static void t1_enc_sigpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , char type , int vsc ) ;
#line 65
__inline static void t1_dec_sigpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf , int vsc ) ;
#line 72
__inline static void t1_dec_sigpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf ) ;
#line 78
__inline static void t1_dec_sigpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int orient , int oneplushalf , int vsc ) ;
#line 88
static void t1_enc_sigpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , char type ,
                           int cblksty ) ;
#line 98
static void t1_dec_sigpass_raw(opj_t1_t *t1 , int bpno , int orient , int cblksty ) ;
#line 103
static void t1_dec_sigpass_mqc(opj_t1_t *t1 , int bpno , int orient ) ;
#line 107
static void t1_dec_sigpass_mqc_vsc(opj_t1_t *t1 , int bpno , int orient ) ;
#line 114
static void t1_enc_refpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int bpno ,
                                int one , int *nmsedec , char type , int vsc ) ;
#line 126
__inline static void t1_dec_refpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf , int vsc ) ;
#line 133
__inline static void t1_dec_refpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf ) ;
#line 139
__inline static void t1_dec_refpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int poshalf , int neghalf , int vsc ) ;
#line 150
static void t1_enc_refpass(opj_t1_t *t1 , int bpno , int *nmsedec , char type , int cblksty ) ;
#line 159
static void t1_dec_refpass_raw(opj_t1_t *t1 , int bpno , int cblksty ) ;
#line 163
static void t1_dec_refpass_mqc(opj_t1_t *t1 , int bpno ) ;
#line 166
static void t1_dec_refpass_mqc_vsc(opj_t1_t *t1 , int bpno ) ;
#line 172
static void t1_enc_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , int partial ,
                                int vsc ) ;
#line 185
static void t1_dec_clnpass_step_partial(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                        int orient , int oneplushalf ) ;
#line 191
static void t1_dec_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int oneplushalf ) ;
#line 197
static void t1_dec_clnpass_step_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                    int oneplushalf , int partial , int vsc ) ;
#line 208
static void t1_enc_clnpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , int cblksty ) ;
#line 217
static void t1_dec_clnpass(opj_t1_t *t1 , int bpno , int orient , int cblksty ) ;
#line 222
static double t1_getwmsedec(int nmsedec , int compno , int level , int orient , int bpno ,
                            int qmfbid , double stepsize , int numcomps , int mct ) ;
#line 246
static void t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , int orient ,
                           int compno , int level , int qmfbid , double stepsize ,
                           int cblksty , int numcomps , int mct , opj_tcd_tile_t *tile ) ;
#line 266
static void t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , int orient ,
                           int roishift , int cblksty ) ;
#line 279 "/root/patchweave_new/2/libopenjpeg/t1.c"
static char t1_getctxno_zc(int f , int orient ) 
{ 


  {
#line 280
  return (lut_ctxno_zc[(orient << 8) | (f & 255)]);
}
}
#line 283 "/root/patchweave_new/2/libopenjpeg/t1.c"
static char t1_getctxno_sc(int f ) 
{ 


  {
#line 284
  return (lut_ctxno_sc[(f & 4080) >> 4]);
}
}
#line 287 "/root/patchweave_new/2/libopenjpeg/t1.c"
static int t1_getctxno_mag(int f ) 
{ 
  int tmp1 ;
  int tmp ;
  int tmp2 ;
  int tmp___0 ;

  {
#line 288
  if (f & 255) {
#line 288
    tmp = 15;
  } else {
#line 288
    tmp = 14;
  }
#line 288
  tmp1 = tmp;
#line 289
  if (f & 8192) {
#line 289
    tmp___0 = 16;
  } else {
#line 289
    tmp___0 = tmp1;
  }
#line 289
  tmp2 = tmp___0;
#line 290
  return (tmp2);
}
}
#line 293 "/root/patchweave_new/2/libopenjpeg/t1.c"
static char t1_getspb(int f ) 
{ 


  {
#line 294
  return (lut_spb[(f & 4080) >> 4]);
}
}
#line 297 "/root/patchweave_new/2/libopenjpeg/t1.c"
static short t1_getnmsedec_sig(int x , int bitpos ) 
{ 


  {
#line 298
  if (bitpos > 6) {
#line 299
    return (lut_nmsedec_sig[(x >> (bitpos - 6)) & ((1 << 7) - 1)]);
  }
#line 302
  return (lut_nmsedec_sig0[x & ((1 << 7) - 1)]);
}
}
#line 305 "/root/patchweave_new/2/libopenjpeg/t1.c"
static short t1_getnmsedec_ref(int x , int bitpos ) 
{ 


  {
#line 306
  if (bitpos > 6) {
#line 307
    return (lut_nmsedec_ref[(x >> (bitpos - 6)) & ((1 << 7) - 1)]);
  }
#line 310
  return (lut_nmsedec_ref0[x & ((1 << 7) - 1)]);
}
}
#line 317 "/root/patchweave_new/2/libopenjpeg/t1.c"
static flag_t mod[8]  ;
#line 313 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_updateflags(flag_t *flagsp , int s , int stride ) 
{ 
  flag_t *np ;
  flag_t *sp ;

  {
#line 314
  np = flagsp - stride;
#line 315
  sp = flagsp + stride;
#line 317
  mod[0] = (flag_t )64;
#line 317
  mod[1] = (flag_t )1088;
#line 317
  mod[2] = (flag_t )32;
#line 317
  mod[3] = (flag_t )544;
#line 317
  mod[4] = (flag_t )128;
#line 317
  mod[5] = (flag_t )2176;
#line 317
  mod[6] = (flag_t )16;
#line 317
  mod[7] = (flag_t )272;
#line 324
  *(np + -1) = (flag_t )((int )*(np + -1) | 2);
#line 325
  *(np + 0) = (flag_t )((int )*(np + 0) | (int )mod[s]);
#line 326
  *(np + 1) = (flag_t )((int )*(np + 1) | 4);
#line 328
  *(flagsp + -1) = (flag_t )((int )*(flagsp + -1) | (int )mod[s + 2]);
#line 329
  *(flagsp + 0) = (flag_t )((int )*(flagsp + 0) | 4096);
#line 330
  *(flagsp + 1) = (flag_t )((int )*(flagsp + 1) | (int )mod[s + 4]);
#line 332
  *(sp + -1) = (flag_t )((int )*(sp + -1) | 1);
#line 333
  *(sp + 0) = (flag_t )((int )*(sp + 0) | (int )mod[s + 6]);
#line 334
  *(sp + 1) = (flag_t )((int )*(sp + 1) | 8);
#line 335
  return;
}
}
#line 337 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_enc_sigpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , char type , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  int __cil_tmp14 ;
  int tmp___0 ;
  char __cil_tmp16 ;
  int tmp___1 ;
  int __cil_tmp18 ;
  short __cil_tmp19 ;
  char __cil_tmp20 ;
  char __cil_tmp21 ;

  {
#line 350
  mqc = t1->mqc;
#line 352
  if (vsc) {
#line 352
    tmp = (int )*flagsp & -1095;
  } else {
#line 352
    tmp = (int )*flagsp;
  }
#line 352
  flag = tmp;
#line 353
  if (flag & 255) {
#line 353
    if (! (flag & 20480)) {
      {
#line 354
      __cil_tmp14 = int_abs(*datap);
      }
#line 354
      if (__cil_tmp14 & one) {
#line 354
        tmp___0 = 1;
      } else {
#line 354
        tmp___0 = 0;
      }
      {
#line 354
      v = tmp___0;
#line 355
      __cil_tmp16 = t1_getctxno_zc(flag, orient);
#line 355
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp16];
      }
#line 356
      if ((int )type == 1) {
        {
#line 357
        mqc_bypass_enc(mqc, v);
        }
      } else {
        {
#line 359
        mqc_encode(mqc, v);
        }
      }
#line 361
      if (v) {
#line 362
        if (*datap < 0) {
#line 362
          tmp___1 = 1;
        } else {
#line 362
          tmp___1 = 0;
        }
        {
#line 362
        v = tmp___1;
#line 363
        __cil_tmp18 = int_abs(*datap);
#line 363
        __cil_tmp19 = t1_getnmsedec_sig(__cil_tmp18, bpno + 6);
#line 363
        *nmsedec += (int )__cil_tmp19;
#line 364
        __cil_tmp20 = t1_getctxno_sc(flag);
#line 364
        mqc->curctx = & mqc->ctxs[(int )__cil_tmp20];
        }
#line 365
        if ((int )type == 1) {
          {
#line 366
          mqc_bypass_enc(mqc, v);
          }
        } else {
          {
#line 368
          __cil_tmp21 = t1_getspb(flag);
#line 368
          mqc_encode(mqc, v ^ (int )__cil_tmp21);
          }
        }
        {
#line 370
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 372
      *flagsp = (flag_t )((int )*flagsp | 16384);
    }
  }
#line 375
  return;
}
}
#line 376 "/root/patchweave_new/2/libopenjpeg/t1.c"
__inline static void t1_dec_sigpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_raw_t *raw ;
  int tmp ;
  int __cil_tmp11 ;
  int tmp___0 ;

  {
#line 385
  raw = t1->raw;
#line 389
  if (vsc) {
#line 389
    tmp = (int )*flagsp & -1095;
  } else {
#line 389
    tmp = (int )*flagsp;
  }
#line 389
  flag = tmp;
#line 390
  if (flag & 255) {
#line 390
    if (! (flag & 20480)) {
      {
#line 391
      __cil_tmp11 = raw_decode(raw);
      }
#line 391
      if (__cil_tmp11) {
        {
#line 392
        v = raw_decode(raw);
        }
#line 393
        if (v) {
#line 393
          tmp___0 = - oneplushalf;
        } else {
#line 393
          tmp___0 = oneplushalf;
        }
        {
#line 393
        *datap = tmp___0;
#line 394
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 396
      *flagsp = (flag_t )((int )*flagsp | 16384);
    }
  }
#line 399
  return;
}
}
#line 400 "/root/patchweave_new/2/libopenjpeg/t1.c"
__inline static void t1_dec_sigpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  char __cil_tmp9 ;
  int __cil_tmp10 ;
  char __cil_tmp11 ;
  int __cil_tmp12 ;
  char __cil_tmp13 ;
  int tmp ;

  {
#line 409
  mqc = t1->mqc;
#line 411
  flag = (int )*flagsp;
#line 412
  if (flag & 255) {
#line 412
    if (! (flag & 20480)) {
      {
#line 413
      __cil_tmp9 = t1_getctxno_zc(flag, orient);
#line 413
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp9];
#line 414
      __cil_tmp10 = mqc_decode(mqc);
      }
#line 414
      if (__cil_tmp10) {
        {
#line 415
        __cil_tmp11 = t1_getctxno_sc(flag);
#line 415
        mqc->curctx = & mqc->ctxs[(int )__cil_tmp11];
#line 416
        __cil_tmp13 = t1_getspb(flag);
#line 416
        __cil_tmp12 = mqc_decode(mqc);
#line 416
        v = __cil_tmp12 ^ (int )__cil_tmp13;
        }
#line 417
        if (v) {
#line 417
          tmp = - oneplushalf;
        } else {
#line 417
          tmp = oneplushalf;
        }
        {
#line 417
        *datap = tmp;
#line 418
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 420
      *flagsp = (flag_t )((int )*flagsp | 16384);
    }
  }
#line 423
  return;
}
}
#line 424 "/root/patchweave_new/2/libopenjpeg/t1.c"
__inline static void t1_dec_sigpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int orient , int oneplushalf , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  char __cil_tmp11 ;
  int __cil_tmp12 ;
  char __cil_tmp13 ;
  int __cil_tmp14 ;
  char __cil_tmp15 ;
  int tmp___0 ;

  {
#line 434
  mqc = t1->mqc;
#line 436
  if (vsc) {
#line 436
    tmp = (int )*flagsp & -1095;
  } else {
#line 436
    tmp = (int )*flagsp;
  }
#line 436
  flag = tmp;
#line 437
  if (flag & 255) {
#line 437
    if (! (flag & 20480)) {
      {
#line 438
      __cil_tmp11 = t1_getctxno_zc(flag, orient);
#line 438
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp11];
#line 439
      __cil_tmp12 = mqc_decode(mqc);
      }
#line 439
      if (__cil_tmp12) {
        {
#line 440
        __cil_tmp13 = t1_getctxno_sc(flag);
#line 440
        mqc->curctx = & mqc->ctxs[(int )__cil_tmp13];
#line 441
        __cil_tmp15 = t1_getspb(flag);
#line 441
        __cil_tmp14 = mqc_decode(mqc);
#line 441
        v = __cil_tmp14 ^ (int )__cil_tmp15;
        }
#line 442
        if (v) {
#line 442
          tmp___0 = - oneplushalf;
        } else {
#line 442
          tmp___0 = oneplushalf;
        }
        {
#line 442
        *datap = tmp___0;
#line 443
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 445
      *flagsp = (flag_t )((int )*flagsp | 16384);
    }
  }
#line 448
  return;
}
}
#line 449 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_enc_sigpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , char type ,
                           int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int vsc ;
  int tmp ;

  {
#line 458
  *nmsedec = 0;
#line 459
  one = 1 << (bpno + 6);
#line 460
  k = 0;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;

#line 460
    if (! (k < t1->h)) {
#line 460
      goto while_break;
    }
#line 461
    i = 0;
    {
#line 461
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 461
      if (! (i < t1->w)) {
#line 461
        goto while_break___0;
      }
#line 462
      j = k;
      {
#line 462
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 462
        if (j < k + 4) {
#line 462
          if (! (j < t1->h)) {
#line 462
            goto while_break___1;
          }
        } else {
#line 462
          goto while_break___1;
        }
#line 463
        if (cblksty & 8) {
#line 463
          if (j == k + 3) {
#line 463
            tmp = 1;
          } else
#line 463
          if (j == t1->h - 1) {
#line 463
            tmp = 1;
          } else {
#line 463
            tmp = 0;
          }
        } else {
#line 463
          tmp = 0;
        }
        {
#line 463
        vsc = tmp;
#line 464
        t1_enc_sigpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), orient, bpno, one, nmsedec,
                            type, vsc);
#line 462
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 461
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 460
    k += 4;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 464
  return;
}
}
#line 479 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_dec_sigpass_raw(opj_t1_t *t1 , int bpno , int orient , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int vsc ;
  int tmp ;

  {
#line 486
  one = 1 << bpno;
#line 487
  half = one >> 1;
#line 488
  oneplushalf = one | half;
#line 489
  k = 0;
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;

#line 489
    if (! (k < t1->h)) {
#line 489
      goto while_break;
    }
#line 490
    i = 0;
    {
#line 490
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 490
      if (! (i < t1->w)) {
#line 490
        goto while_break___0;
      }
#line 491
      j = k;
      {
#line 491
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 491
        if (j < k + 4) {
#line 491
          if (! (j < t1->h)) {
#line 491
            goto while_break___1;
          }
        } else {
#line 491
          goto while_break___1;
        }
#line 492
        if (cblksty & 8) {
#line 492
          if (j == k + 3) {
#line 492
            tmp = 1;
          } else
#line 492
          if (j == t1->h - 1) {
#line 492
            tmp = 1;
          } else {
#line 492
            tmp = 0;
          }
        } else {
#line 492
          tmp = 0;
        }
        {
#line 492
        vsc = tmp;
#line 493
        t1_dec_sigpass_step_raw(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                t1->data + (j * t1->w + i), orient, oneplushalf, vsc);
#line 491
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 490
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 489
    k += 4;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 493
  return;
}
}
#line 505 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_dec_sigpass_mqc(opj_t1_t *t1 , int bpno , int orient ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int *data1 ;
  flag_t *flags1 ;
  int *data2 ;
  flag_t *flags2 ;
  int *data2___0 ;
  flag_t *flags2___0 ;

  {
#line 511
  data1 = t1->data;
#line 512
  flags1 = t1->flags + 1;
#line 513
  one = 1 << bpno;
#line 514
  half = one >> 1;
#line 515
  oneplushalf = one | half;
#line 516
  k = 0;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;

#line 516
    if (! (k < (t1->h & -4))) {
#line 516
      goto while_break;
    }
#line 517
    i = 0;
    {
#line 517
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 517
      if (! (i < t1->w)) {
#line 517
        goto while_break___0;
      }
      {
#line 518
      data2 = data1 + i;
#line 519
      flags2 = flags1 + i;
#line 520
      flags2 += t1->flags_stride;
#line 521
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 522
      data2 += t1->w;
#line 523
      flags2 += t1->flags_stride;
#line 524
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 525
      data2 += t1->w;
#line 526
      flags2 += t1->flags_stride;
#line 527
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 528
      data2 += t1->w;
#line 529
      flags2 += t1->flags_stride;
#line 530
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 531
      data2 += t1->w;
#line 517
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 533
    data1 += t1->w << 2;
#line 534
    flags1 += t1->flags_stride << 2;
#line 516
    k += 4;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 536
  i = 0;
  {
#line 536
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 536
    if (! (i < t1->w)) {
#line 536
      goto while_break___1;
    }
#line 537
    data2___0 = data1 + i;
#line 538
    flags2___0 = flags1 + i;
#line 539
    j = k;
    {
#line 539
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 539
      if (! (j < t1->h)) {
#line 539
        goto while_break___2;
      }
      {
#line 540
      flags2___0 += t1->flags_stride;
#line 541
      t1_dec_sigpass_step_mqc(t1, flags2___0, data2___0, orient, oneplushalf);
#line 542
      data2___0 += t1->w;
#line 539
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 536
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 540
  return;
}
}
#line 547 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_dec_sigpass_mqc_vsc(opj_t1_t *t1 , int bpno , int orient ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int vsc ;
  int tmp ;

  {
#line 553
  one = 1 << bpno;
#line 554
  half = one >> 1;
#line 555
  oneplushalf = one | half;
#line 556
  k = 0;
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;

#line 556
    if (! (k < t1->h)) {
#line 556
      goto while_break;
    }
#line 557
    i = 0;
    {
#line 557
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 557
      if (! (i < t1->w)) {
#line 557
        goto while_break___0;
      }
#line 558
      j = k;
      {
#line 558
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 558
        if (j < k + 4) {
#line 558
          if (! (j < t1->h)) {
#line 558
            goto while_break___1;
          }
        } else {
#line 558
          goto while_break___1;
        }
#line 559
        if (j == k + 3) {
#line 559
          tmp = 1;
        } else
#line 559
        if (j == t1->h - 1) {
#line 559
          tmp = 1;
        } else {
#line 559
          tmp = 0;
        }
        {
#line 559
        vsc = tmp;
#line 560
        t1_dec_sigpass_step_mqc_vsc(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                    t1->data + (j * t1->w + i), orient, oneplushalf,
                                    vsc);
#line 558
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 557
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 556
    k += 4;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 560
  return;
}
}
#line 572 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_enc_refpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int bpno ,
                                int one , int *nmsedec , char type , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  int __cil_tmp13 ;
  short __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp___0 ;
  int __cil_tmp17 ;

  {
#line 584
  mqc = t1->mqc;
#line 586
  if (vsc) {
#line 586
    tmp = (int )*flagsp & -1095;
  } else {
#line 586
    tmp = (int )*flagsp;
  }
#line 586
  flag = tmp;
#line 587
  if ((flag & 20480) == 4096) {
    {
#line 588
    __cil_tmp13 = int_abs(*datap);
#line 588
    __cil_tmp14 = t1_getnmsedec_ref(__cil_tmp13, bpno + 6);
#line 588
    *nmsedec += (int )__cil_tmp14;
#line 589
    __cil_tmp15 = int_abs(*datap);
    }
#line 589
    if (__cil_tmp15 & one) {
#line 589
      tmp___0 = 1;
    } else {
#line 589
      tmp___0 = 0;
    }
    {
#line 589
    v = tmp___0;
#line 590
    __cil_tmp17 = t1_getctxno_mag(flag);
#line 590
    mqc->curctx = & mqc->ctxs[__cil_tmp17];
    }
#line 591
    if ((int )type == 1) {
      {
#line 592
      mqc_bypass_enc(mqc, v);
      }
    } else {
      {
#line 594
      mqc_encode(mqc, v);
      }
    }
#line 596
    *flagsp = (flag_t )((int )*flagsp | 8192);
  }
#line 598
  return;
}
}
#line 600 "/root/patchweave_new/2/libopenjpeg/t1.c"
__inline static void t1_dec_refpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf , int vsc ) 
{ 
  int v ;
  int t ;
  int flag ;
  opj_raw_t *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 610
  raw = t1->raw;
#line 612
  if (vsc) {
#line 612
    tmp = (int )*flagsp & -1095;
  } else {
#line 612
    tmp = (int )*flagsp;
  }
#line 612
  flag = tmp;
#line 613
  if ((flag & 20480) == 4096) {
    {
#line 614
    v = raw_decode(raw);
    }
#line 615
    if (v) {
#line 615
      tmp___0 = poshalf;
    } else {
#line 615
      tmp___0 = neghalf;
    }
#line 615
    t = tmp___0;
#line 616
    if (*datap < 0) {
#line 616
      tmp___1 = - t;
    } else {
#line 616
      tmp___1 = t;
    }
#line 616
    *datap += tmp___1;
#line 617
    *flagsp = (flag_t )((int )*flagsp | 8192);
  }
#line 619
  return;
}
}
#line 621 "/root/patchweave_new/2/libopenjpeg/t1.c"
__inline static void t1_dec_refpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf ) 
{ 
  int v ;
  int t ;
  int flag ;
  opj_mqc_t *mqc ;
  int __cil_tmp10 ;
  int tmp ;
  int tmp___0 ;

  {
#line 630
  mqc = t1->mqc;
#line 632
  flag = (int )*flagsp;
#line 633
  if ((flag & 20480) == 4096) {
    {
#line 634
    __cil_tmp10 = t1_getctxno_mag(flag);
#line 634
    mqc->curctx = & mqc->ctxs[__cil_tmp10];
#line 635
    v = mqc_decode(mqc);
    }
#line 636
    if (v) {
#line 636
      tmp = poshalf;
    } else {
#line 636
      tmp = neghalf;
    }
#line 636
    t = tmp;
#line 637
    if (*datap < 0) {
#line 637
      tmp___0 = - t;
    } else {
#line 637
      tmp___0 = t;
    }
#line 637
    *datap += tmp___0;
#line 638
    *flagsp = (flag_t )((int )*flagsp | 8192);
  }
#line 640
  return;
}
}
#line 642 "/root/patchweave_new/2/libopenjpeg/t1.c"
__inline static void t1_dec_refpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int poshalf , int neghalf , int vsc ) 
{ 
  int v ;
  int t ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  int __cil_tmp12 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 652
  mqc = t1->mqc;
#line 654
  if (vsc) {
#line 654
    tmp = (int )*flagsp & -1095;
  } else {
#line 654
    tmp = (int )*flagsp;
  }
#line 654
  flag = tmp;
#line 655
  if ((flag & 20480) == 4096) {
    {
#line 656
    __cil_tmp12 = t1_getctxno_mag(flag);
#line 656
    mqc->curctx = & mqc->ctxs[__cil_tmp12];
#line 657
    v = mqc_decode(mqc);
    }
#line 658
    if (v) {
#line 658
      tmp___0 = poshalf;
    } else {
#line 658
      tmp___0 = neghalf;
    }
#line 658
    t = tmp___0;
#line 659
    if (*datap < 0) {
#line 659
      tmp___1 = - t;
    } else {
#line 659
      tmp___1 = t;
    }
#line 659
    *datap += tmp___1;
#line 660
    *flagsp = (flag_t )((int )*flagsp | 8192);
  }
#line 662
  return;
}
}
#line 664 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_enc_refpass(opj_t1_t *t1 , int bpno , int *nmsedec , char type , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int vsc ;
  int tmp ;

  {
#line 672
  *nmsedec = 0;
#line 673
  one = 1 << (bpno + 6);
#line 674
  k = 0;
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;

#line 674
    if (! (k < t1->h)) {
#line 674
      goto while_break;
    }
#line 675
    i = 0;
    {
#line 675
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 675
      if (! (i < t1->w)) {
#line 675
        goto while_break___0;
      }
#line 676
      j = k;
      {
#line 676
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 676
        if (j < k + 4) {
#line 676
          if (! (j < t1->h)) {
#line 676
            goto while_break___1;
          }
        } else {
#line 676
          goto while_break___1;
        }
#line 677
        if (cblksty & 8) {
#line 677
          if (j == k + 3) {
#line 677
            tmp = 1;
          } else
#line 677
          if (j == t1->h - 1) {
#line 677
            tmp = 1;
          } else {
#line 677
            tmp = 0;
          }
        } else {
#line 677
          tmp = 0;
        }
        {
#line 677
        vsc = tmp;
#line 678
        t1_enc_refpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), bpno, one, nmsedec, type,
                            vsc);
#line 676
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 675
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 674
    k += 4;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 678
  return;
}
}
#line 692 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_dec_refpass_raw(opj_t1_t *t1 , int bpno , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int poshalf ;
  int neghalf ;
  int vsc ;
  int tmp ;
  int tmp___0 ;

  {
#line 699
  one = 1 << bpno;
#line 700
  poshalf = one >> 1;
#line 701
  if (bpno > 0) {
#line 701
    tmp = - poshalf;
  } else {
#line 701
    tmp = -1;
  }
#line 701
  neghalf = tmp;
#line 702
  k = 0;
  {
#line 702
  while (1) {
    while_continue: /* CIL Label */ ;

#line 702
    if (! (k < t1->h)) {
#line 702
      goto while_break;
    }
#line 703
    i = 0;
    {
#line 703
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 703
      if (! (i < t1->w)) {
#line 703
        goto while_break___0;
      }
#line 704
      j = k;
      {
#line 704
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 704
        if (j < k + 4) {
#line 704
          if (! (j < t1->h)) {
#line 704
            goto while_break___1;
          }
        } else {
#line 704
          goto while_break___1;
        }
#line 705
        if (cblksty & 8) {
#line 705
          if (j == k + 3) {
#line 705
            tmp___0 = 1;
          } else
#line 705
          if (j == t1->h - 1) {
#line 705
            tmp___0 = 1;
          } else {
#line 705
            tmp___0 = 0;
          }
        } else {
#line 705
          tmp___0 = 0;
        }
        {
#line 705
        vsc = tmp___0;
#line 706
        t1_dec_refpass_step_raw(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                t1->data + (j * t1->w + i), poshalf, neghalf, vsc);
#line 704
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 703
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 702
    k += 4;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 706
  return;
}
}
#line 718 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_dec_refpass_mqc(opj_t1_t *t1 , int bpno ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int poshalf ;
  int neghalf ;
  int *data1 ;
  flag_t *flags1 ;
  int tmp ;
  int *data2 ;
  flag_t *flags2 ;
  int *data2___0 ;
  flag_t *flags2___0 ;

  {
#line 723
  data1 = t1->data;
#line 724
  flags1 = t1->flags + 1;
#line 725
  one = 1 << bpno;
#line 726
  poshalf = one >> 1;
#line 727
  if (bpno > 0) {
#line 727
    tmp = - poshalf;
  } else {
#line 727
    tmp = -1;
  }
#line 727
  neghalf = tmp;
#line 728
  k = 0;
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;

#line 728
    if (! (k < (t1->h & -4))) {
#line 728
      goto while_break;
    }
#line 729
    i = 0;
    {
#line 729
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 729
      if (! (i < t1->w)) {
#line 729
        goto while_break___0;
      }
      {
#line 730
      data2 = data1 + i;
#line 731
      flags2 = flags1 + i;
#line 732
      flags2 += t1->flags_stride;
#line 733
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 734
      data2 += t1->w;
#line 735
      flags2 += t1->flags_stride;
#line 736
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 737
      data2 += t1->w;
#line 738
      flags2 += t1->flags_stride;
#line 739
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 740
      data2 += t1->w;
#line 741
      flags2 += t1->flags_stride;
#line 742
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 743
      data2 += t1->w;
#line 729
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 745
    data1 += t1->w << 2;
#line 746
    flags1 += t1->flags_stride << 2;
#line 728
    k += 4;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 748
  i = 0;
  {
#line 748
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 748
    if (! (i < t1->w)) {
#line 748
      goto while_break___1;
    }
#line 749
    data2___0 = data1 + i;
#line 750
    flags2___0 = flags1 + i;
#line 751
    j = k;
    {
#line 751
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 751
      if (! (j < t1->h)) {
#line 751
        goto while_break___2;
      }
      {
#line 752
      flags2___0 += t1->flags_stride;
#line 753
      t1_dec_refpass_step_mqc(t1, flags2___0, data2___0, poshalf, neghalf);
#line 754
      data2___0 += t1->w;
#line 751
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 748
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 752
  return;
}
}
#line 759 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_dec_refpass_mqc_vsc(opj_t1_t *t1 , int bpno ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int poshalf ;
  int neghalf ;
  int vsc ;
  int tmp ;
  int tmp___0 ;

  {
#line 765
  one = 1 << bpno;
#line 766
  poshalf = one >> 1;
#line 767
  if (bpno > 0) {
#line 767
    tmp = - poshalf;
  } else {
#line 767
    tmp = -1;
  }
#line 767
  neghalf = tmp;
#line 768
  k = 0;
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;

#line 768
    if (! (k < t1->h)) {
#line 768
      goto while_break;
    }
#line 769
    i = 0;
    {
#line 769
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 769
      if (! (i < t1->w)) {
#line 769
        goto while_break___0;
      }
#line 770
      j = k;
      {
#line 770
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 770
        if (j < k + 4) {
#line 770
          if (! (j < t1->h)) {
#line 770
            goto while_break___1;
          }
        } else {
#line 770
          goto while_break___1;
        }
#line 771
        if (j == k + 3) {
#line 771
          tmp___0 = 1;
        } else
#line 771
        if (j == t1->h - 1) {
#line 771
          tmp___0 = 1;
        } else {
#line 771
          tmp___0 = 0;
        }
        {
#line 771
        vsc = tmp___0;
#line 772
        t1_dec_refpass_step_mqc_vsc(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                    t1->data + (j * t1->w + i), poshalf, neghalf,
                                    vsc);
#line 770
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 769
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 768
    k += 4;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 772
  return;
}
}
#line 784 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_enc_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , int partial ,
                                int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  char __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp___0 ;
  int __cil_tmp17 ;
  short __cil_tmp18 ;
  char __cil_tmp19 ;
  int tmp___1 ;
  char __cil_tmp21 ;

  {
#line 797
  mqc = t1->mqc;
#line 799
  if (vsc) {
#line 799
    tmp = (int )*flagsp & -1095;
  } else {
#line 799
    tmp = (int )*flagsp;
  }
#line 799
  flag = tmp;
#line 800
  if (partial) {
#line 801
    goto LABEL_PARTIAL;
  }
#line 803
  if (! ((int )*flagsp & 20480)) {
    {
#line 804
    __cil_tmp14 = t1_getctxno_zc(flag, orient);
#line 804
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp14];
#line 805
    __cil_tmp15 = int_abs(*datap);
    }
#line 805
    if (__cil_tmp15 & one) {
#line 805
      tmp___0 = 1;
    } else {
#line 805
      tmp___0 = 0;
    }
    {
#line 805
    v = tmp___0;
#line 806
    mqc_encode(mqc, v);
    }
#line 807
    if (v) {
      LABEL_PARTIAL: 
      {
#line 809
      __cil_tmp17 = int_abs(*datap);
#line 809
      __cil_tmp18 = t1_getnmsedec_sig(__cil_tmp17, bpno + 6);
#line 809
      *nmsedec += (int )__cil_tmp18;
#line 810
      __cil_tmp19 = t1_getctxno_sc(flag);
#line 810
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp19];
      }
#line 811
      if (*datap < 0) {
#line 811
        tmp___1 = 1;
      } else {
#line 811
        tmp___1 = 0;
      }
      {
#line 811
      v = tmp___1;
#line 812
      __cil_tmp21 = t1_getspb(flag);
#line 812
      mqc_encode(mqc, v ^ (int )__cil_tmp21);
#line 813
      t1_updateflags(flagsp, v, t1->flags_stride);
      }
    }
  }
#line 816
  *flagsp = (flag_t )((int )*flagsp & -16385);
#line 817
  return;
}
}
#line 819 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_dec_clnpass_step_partial(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                        int orient , int oneplushalf ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  char __cil_tmp9 ;
  int __cil_tmp10 ;
  char __cil_tmp11 ;
  int tmp ;

  {
  {
#line 827
  mqc = t1->mqc;
#line 831
  flag = (int )*flagsp;
#line 832
  __cil_tmp9 = t1_getctxno_sc(flag);
#line 832
  mqc->curctx = & mqc->ctxs[(int )__cil_tmp9];
#line 833
  __cil_tmp11 = t1_getspb(flag);
#line 833
  __cil_tmp10 = mqc_decode(mqc);
#line 833
  v = __cil_tmp10 ^ (int )__cil_tmp11;
  }
#line 834
  if (v) {
#line 834
    tmp = - oneplushalf;
  } else {
#line 834
    tmp = oneplushalf;
  }
  {
#line 834
  *datap = tmp;
#line 835
  t1_updateflags(flagsp, v, t1->flags_stride);
#line 836
  *flagsp = (flag_t )((int )*flagsp & -16385);
  }
#line 838
  return;
}
}
#line 839 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_dec_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int oneplushalf ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  char __cil_tmp9 ;
  int __cil_tmp10 ;
  char __cil_tmp11 ;
  int __cil_tmp12 ;
  char __cil_tmp13 ;
  int tmp ;

  {
#line 848
  mqc = t1->mqc;
#line 850
  flag = (int )*flagsp;
#line 851
  if (! (flag & 20480)) {
    {
#line 852
    __cil_tmp9 = t1_getctxno_zc(flag, orient);
#line 852
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp9];
#line 853
    __cil_tmp10 = mqc_decode(mqc);
    }
#line 853
    if (__cil_tmp10) {
      {
#line 854
      __cil_tmp11 = t1_getctxno_sc(flag);
#line 854
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp11];
#line 855
      __cil_tmp13 = t1_getspb(flag);
#line 855
      __cil_tmp12 = mqc_decode(mqc);
#line 855
      v = __cil_tmp12 ^ (int )__cil_tmp13;
      }
#line 856
      if (v) {
#line 856
        tmp = - oneplushalf;
      } else {
#line 856
        tmp = oneplushalf;
      }
      {
#line 856
      *datap = tmp;
#line 857
      t1_updateflags(flagsp, v, t1->flags_stride);
      }
    }
  }
#line 860
  *flagsp = (flag_t )((int )*flagsp & -16385);
#line 861
  return;
}
}
#line 863 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_dec_clnpass_step_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                    int oneplushalf , int partial , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  char __cil_tmp12 ;
  int __cil_tmp13 ;
  char __cil_tmp14 ;
  int __cil_tmp15 ;
  char __cil_tmp16 ;
  int tmp___0 ;

  {
#line 874
  mqc = t1->mqc;
#line 876
  if (vsc) {
#line 876
    tmp = (int )*flagsp & -1095;
  } else {
#line 876
    tmp = (int )*flagsp;
  }
#line 876
  flag = tmp;
#line 877
  if (partial) {
#line 878
    goto LABEL_PARTIAL;
  }
#line 880
  if (! (flag & 20480)) {
    {
#line 881
    __cil_tmp12 = t1_getctxno_zc(flag, orient);
#line 881
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp12];
#line 882
    __cil_tmp13 = mqc_decode(mqc);
    }
#line 882
    if (__cil_tmp13) {
      LABEL_PARTIAL: 
      {
#line 884
      __cil_tmp14 = t1_getctxno_sc(flag);
#line 884
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp14];
#line 885
      __cil_tmp16 = t1_getspb(flag);
#line 885
      __cil_tmp15 = mqc_decode(mqc);
#line 885
      v = __cil_tmp15 ^ (int )__cil_tmp16;
      }
#line 886
      if (v) {
#line 886
        tmp___0 = - oneplushalf;
      } else {
#line 886
        tmp___0 = oneplushalf;
      }
      {
#line 886
      *datap = tmp___0;
#line 887
      t1_updateflags(flagsp, v, t1->flags_stride);
      }
    }
  }
#line 890
  *flagsp = (flag_t )((int )*flagsp & -16385);
#line 891
  return;
}
}
#line 893 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_enc_clnpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int agg ;
  int runlen ;
  int vsc ;
  opj_mqc_t *mqc ;
  int __cil_tmp14 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 902
  mqc = t1->mqc;
#line 904
  *nmsedec = 0;
#line 905
  one = 1 << (bpno + 6);
#line 906
  k = 0;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;

#line 906
    if (! (k < t1->h)) {
#line 906
      goto while_break;
    }
#line 907
    i = 0;
    {
#line 907
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue___0: ;
#line 907
      if (! (i < t1->w)) {
#line 907
        goto while_break___0;
      }
#line 908
      if (k + 3 < t1->h) {
#line 909
        if (cblksty & 8) {
#line 910
          if ((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735) {
#line 910
            tmp___0 = 0;
          } else
#line 910
          if ((int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) {
#line 910
            tmp___0 = 0;
          } else
#line 910
          if ((int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) {
#line 910
            tmp___0 = 0;
          } else
#line 910
          if (((int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & -1095) & 20735) {
#line 910
            tmp___0 = 0;
          } else {
#line 910
            tmp___0 = 1;
          }
#line 910
          agg = tmp___0;
        } else {
#line 916
          if ((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735) {
#line 916
            tmp___1 = 0;
          } else
#line 916
          if ((int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) {
#line 916
            tmp___1 = 0;
          } else
#line 916
          if ((int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) {
#line 916
            tmp___1 = 0;
          } else
#line 916
          if ((int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & 20735) {
#line 916
            tmp___1 = 0;
          } else {
#line 916
            tmp___1 = 1;
          }
#line 916
          agg = tmp___1;
        }
      } else {
#line 922
        agg = 0;
      }
#line 924
      if (agg) {
#line 925
        runlen = 0;
        {
#line 925
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 925
          if (! (runlen < 4)) {
#line 925
            goto while_break___1;
          }
          {
#line 926
          __cil_tmp14 = int_abs(*(t1->data + ((k + runlen) * t1->w + i)));
          }
#line 926
          if (__cil_tmp14 & one) {
#line 927
            goto while_break___1;
          }
#line 925
          runlen ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: 
        {
#line 929
        mqc->curctx = & mqc->ctxs[17];
#line 930
        mqc_encode(mqc, runlen != 4);
        }
#line 931
        if (runlen == 4) {
#line 932
          goto while_continue___0;
        }
        {
#line 934
        mqc->curctx = & mqc->ctxs[18];
#line 935
        mqc_encode(mqc, runlen >> 1);
#line 936
        mqc_encode(mqc, runlen & 1);
        }
      } else {
#line 938
        runlen = 0;
      }
#line 940
      j = k + runlen;
      {
#line 940
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 940
        if (j < k + 4) {
#line 940
          if (! (j < t1->h)) {
#line 940
            goto while_break___2;
          }
        } else {
#line 940
          goto while_break___2;
        }
#line 941
        if (cblksty & 8) {
#line 941
          if (j == k + 3) {
#line 941
            tmp = 1;
          } else
#line 941
          if (j == t1->h - 1) {
#line 941
            tmp = 1;
          } else {
#line 941
            tmp = 0;
          }
        } else {
#line 941
          tmp = 0;
        }
#line 941
        vsc = tmp;
#line 942
        if (agg) {
#line 942
          if (j == k + runlen) {
#line 942
            tmp___2 = 1;
          } else {
#line 942
            tmp___2 = 0;
          }
        } else {
#line 942
          tmp___2 = 0;
        }
        {
#line 942
        t1_enc_clnpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), orient, bpno, one, nmsedec,
                            tmp___2, vsc);
#line 940
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 907
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 906
    k += 4;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 910
  return;
}
}
#line 957 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_dec_clnpass(opj_t1_t *t1 , int bpno , int orient , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int agg ;
  int runlen ;
  int vsc ;
  int segsym ;
  opj_mqc_t *mqc ;
  int __cil_tmp16 ;
  int __cil_tmp18 ;
  int tmp ;
  int *data1 ;
  flag_t *flags1 ;
  int *data2 ;
  flag_t *flags2 ;
  int __cil_tmp24 ;
  int __cil_tmp26 ;
  int *data2___0 ;
  flag_t *flags2___0 ;
  int v ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 964
  segsym = cblksty & 32;
#line 966
  mqc = t1->mqc;
#line 968
  one = 1 << bpno;
#line 969
  half = one >> 1;
#line 970
  oneplushalf = one | half;
#line 971
  if (cblksty & 8) {
#line 972
    k = 0;
    {
#line 972
    while (1) {
      while_continue: /* CIL Label */ ;

#line 972
      if (! (k < t1->h)) {
#line 972
        goto while_break;
      }
#line 973
      i = 0;
      {
#line 973
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: ;
#line 973
        if (! (i < t1->w)) {
#line 973
          goto while_break___0;
        }
#line 974
        if (k + 3 < t1->h) {
#line 975
          if ((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735) {
#line 975
            tmp___0 = 0;
          } else
#line 975
          if ((int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) {
#line 975
            tmp___0 = 0;
          } else
#line 975
          if ((int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) {
#line 975
            tmp___0 = 0;
          } else
#line 975
          if (((int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & -1095) & 20735) {
#line 975
            tmp___0 = 0;
          } else {
#line 975
            tmp___0 = 1;
          }
#line 975
          agg = tmp___0;
        } else {
#line 981
          agg = 0;
        }
#line 983
        if (agg) {
          {
#line 984
          mqc->curctx = & mqc->ctxs[17];
#line 985
          __cil_tmp16 = mqc_decode(mqc);
          }
#line 985
          if (! __cil_tmp16) {
#line 986
            goto while_continue___0;
          }
          {
#line 988
          mqc->curctx = & mqc->ctxs[18];
#line 989
          runlen = mqc_decode(mqc);
#line 990
          __cil_tmp18 = mqc_decode(mqc);
#line 990
          runlen = (runlen << 1) | __cil_tmp18;
          }
        } else {
#line 992
          runlen = 0;
        }
#line 994
        j = k + runlen;
        {
#line 994
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 994
          if (j < k + 4) {
#line 994
            if (! (j < t1->h)) {
#line 994
              goto while_break___1;
            }
          } else {
#line 994
            goto while_break___1;
          }
#line 995
          if (j == k + 3) {
#line 995
            tmp = 1;
          } else
#line 995
          if (j == t1->h - 1) {
#line 995
            tmp = 1;
          } else {
#line 995
            tmp = 0;
          }
#line 995
          vsc = tmp;
#line 996
          if (agg) {
#line 996
            if (j == k + runlen) {
#line 996
              tmp___1 = 1;
            } else {
#line 996
              tmp___1 = 0;
            }
          } else {
#line 996
            tmp___1 = 0;
          }
          {
#line 996
          t1_dec_clnpass_step_vsc(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                  t1->data + (j * t1->w + i), orient, oneplushalf,
                                  tmp___1, vsc);
#line 994
          j ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___1: 
#line 973
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___0: 
#line 972
      k += 4;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 1008
    data1 = t1->data;
#line 1009
    flags1 = t1->flags + 1;
#line 1010
    k = 0;
    {
#line 1010
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 1010
      if (! (k < (t1->h & -4))) {
#line 1010
        goto while_break___2;
      }
#line 1011
      i = 0;
      {
#line 1011
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___3: ;
#line 1011
        if (! (i < t1->w)) {
#line 1011
          goto while_break___3;
        }
#line 1012
        data2 = data1 + i;
#line 1013
        flags2 = flags1 + i;
#line 1014
        if ((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735) {
#line 1014
          tmp___2 = 0;
        } else
#line 1014
        if ((int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) {
#line 1014
          tmp___2 = 0;
        } else
#line 1014
        if ((int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) {
#line 1014
          tmp___2 = 0;
        } else
#line 1014
        if ((int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & 20735) {
#line 1014
          tmp___2 = 0;
        } else {
#line 1014
          tmp___2 = 1;
        }
#line 1014
        agg = tmp___2;
#line 1018
        if (agg) {
          {
#line 1019
          mqc->curctx = & mqc->ctxs[17];
#line 1020
          __cil_tmp24 = mqc_decode(mqc);
          }
#line 1020
          if (! __cil_tmp24) {
#line 1021
            goto while_continue___3;
          }
          {
#line 1023
          mqc->curctx = & mqc->ctxs[18];
#line 1024
          runlen = mqc_decode(mqc);
#line 1025
          __cil_tmp26 = mqc_decode(mqc);
#line 1025
          runlen = (runlen << 1) | __cil_tmp26;
#line 1026
          flags2 += runlen * t1->flags_stride;
#line 1027
          data2 += runlen * t1->w;
#line 1028
          j = k + runlen;
          }
          {
#line 1028
          while (1) {
            while_continue___8: /* CIL Label */ ;

#line 1028
            if (j < k + 4) {
#line 1028
              if (! (j < t1->h)) {
#line 1028
                goto while_break___4;
              }
            } else {
#line 1028
              goto while_break___4;
            }
#line 1029
            flags2 += t1->flags_stride;
#line 1030
            if (agg) {
#line 1030
              if (j == k + runlen) {
                {
#line 1031
                t1_dec_clnpass_step_partial(t1, flags2, data2, orient, oneplushalf);
                }
              } else {
                {
#line 1033
                t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
                }
              }
            } else {
              {
#line 1033
              t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
              }
            }
#line 1035
            data2 += t1->w;
#line 1028
            j ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___4: ;
        } else {
          {
#line 1038
          flags2 += t1->flags_stride;
#line 1039
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1040
          data2 += t1->w;
#line 1041
          flags2 += t1->flags_stride;
#line 1042
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1043
          data2 += t1->w;
#line 1044
          flags2 += t1->flags_stride;
#line 1045
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1046
          data2 += t1->w;
#line 1047
          flags2 += t1->flags_stride;
#line 1048
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1049
          data2 += t1->w;
          }
        }
#line 1011
        i ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___3: 
#line 1052
      data1 += t1->w << 2;
#line 1053
      flags1 += t1->flags_stride << 2;
#line 1010
      k += 4;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___2: 
#line 1055
    i = 0;
    {
#line 1055
    while (1) {
      while_continue___9: /* CIL Label */ ;

#line 1055
      if (! (i < t1->w)) {
#line 1055
        goto while_break___5;
      }
#line 1056
      data2___0 = data1 + i;
#line 1057
      flags2___0 = flags1 + i;
#line 1058
      j = k;
      {
#line 1058
      while (1) {
        while_continue___10: /* CIL Label */ ;

#line 1058
        if (! (j < t1->h)) {
#line 1058
          goto while_break___6;
        }
        {
#line 1059
        flags2___0 += t1->flags_stride;
#line 1060
        t1_dec_clnpass_step(t1, flags2___0, data2___0, orient, oneplushalf);
#line 1061
        data2___0 += t1->w;
#line 1058
        j ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___6: 
#line 1055
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___5: ;
  }
#line 1066
  if (segsym) {
    {
#line 1067
    v = 0;
#line 1068
    mqc->curctx = & mqc->ctxs[18];
#line 1069
    v = mqc_decode(mqc);
#line 1070
    __cil_tmp31 = mqc_decode(mqc);
#line 1070
    v = (v << 1) | __cil_tmp31;
#line 1071
    __cil_tmp32 = mqc_decode(mqc);
#line 1071
    v = (v << 1) | __cil_tmp32;
#line 1072
    __cil_tmp33 = mqc_decode(mqc);
#line 1072
    v = (v << 1) | __cil_tmp33;
    }
  }
#line 1075
  return;
}
}
#line 1083 "/root/patchweave_new/2/libopenjpeg/t1.c"
static double t1_getwmsedec(int nmsedec , int compno , int level , int orient , int bpno ,
                            int qmfbid , double stepsize , int numcomps , int mct ) 
{ 
  double w1 ;
  double w2 ;
  double wmsedec ;
  double __cil_tmp13 ;
  double tmp ;
  double __cil_tmp16 ;
  double tmp___0 ;

  {
#line 1095
  if (qmfbid == 1) {
#line 1096
    if (mct) {
#line 1096
      if (numcomps == 3) {
        {
#line 1096
        __cil_tmp13 = mct_getnorm(compno);
#line 1096
        tmp = __cil_tmp13;
        }
      } else {
#line 1096
        tmp = 1.;
      }
    } else {
#line 1096
      tmp = 1.;
    }
    {
#line 1096
    w1 = tmp;
#line 1097
    w2 = dwt_getnorm(level, orient);
    }
  } else {
#line 1099
    if (mct) {
#line 1099
      if (numcomps == 3) {
        {
#line 1099
        __cil_tmp16 = mct_getnorm_real(compno);
#line 1099
        tmp___0 = __cil_tmp16;
        }
      } else {
#line 1099
        tmp___0 = 1.;
      }
    } else {
#line 1099
      tmp___0 = 1.;
    }
    {
#line 1099
    w1 = tmp___0;
#line 1100
    w2 = dwt_getnorm_real(level, orient);
    }
  }
#line 1102
  wmsedec = ((w1 * w2) * stepsize) * (double )(1 << bpno);
#line 1103
  wmsedec *= (wmsedec * (double )nmsedec) / 8192.;
#line 1105
  return (wmsedec);
}
}
#line 1108 "/root/patchweave_new/2/libopenjpeg/t1.c"
static opj_bool allocate_buffers(opj_t1_t *t1 , int w , int h ) 
{ 
  int datasize ;
  int flagssize ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 1113
  datasize = w * h;
#line 1116
  if (datasize > t1->datasize) {
    {
#line 1117
    free((void *)t1->data);
#line 1118
    __cil_tmp6 = malloc((unsigned long )datasize * sizeof(int ));
#line 1118
    t1->data = (int *)__cil_tmp6;
    }
#line 1119
    if (! t1->data) {
#line 1120
      return (0);
    }
#line 1122
    t1->datasize = datasize;
  }
  {
#line 1124
  memset((void *)t1->data, 0, (unsigned long )datasize * sizeof(int ));
#line 1126
  t1->flags_stride = w + 2;
#line 1127
  flagssize = t1->flags_stride * (h + 2);
  }
#line 1129
  if (flagssize > t1->flagssize) {
    {
#line 1130
    free((void *)t1->flags);
#line 1131
    __cil_tmp7 = malloc((unsigned long )flagssize * sizeof(flag_t ));
#line 1131
    t1->flags = (flag_t *)__cil_tmp7;
    }
#line 1132
    if (! t1->flags) {
#line 1133
      return (0);
    }
#line 1135
    t1->flagssize = flagssize;
  }
  {
#line 1137
  memset((void *)t1->flags, 0, (unsigned long )flagssize * sizeof(flag_t ));
#line 1139
  t1->w = w;
#line 1140
  t1->h = h;
  }
#line 1142
  return (1);
}
}
#line 1146 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , int orient ,
                           int compno , int level , int qmfbid , double stepsize ,
                           int cblksty , int numcomps , int mct , opj_tcd_tile_t *tile ) 
{ 
  double cumwmsedec ;
  opj_mqc_t *mqc ;
  int passno ;
  int bpno ;
  int passtype ;
  int nmsedec ;
  int i ;
  int max ;
  char type ;
  double tempwmsedec ;
  int tmp ;
  int __cil_tmp23 ;
  int __cil_tmp25 ;
  int tmp___0 ;
  opj_tcd_pass_t *pass ;
  int correction ;
  int tmp___1 ;
  int __cil_tmp31 ;
  int tmp___2 ;
  int __cil_tmp33 ;
  opj_tcd_pass_t *pass___0 ;
  int __cil_tmp35 ;
  int __cil_tmp37 ;
  int tmp___3 ;

  {
#line 1159
  cumwmsedec = 0.;
#line 1161
  mqc = t1->mqc;
#line 1164
  nmsedec = 0;
#line 1166
  type = (char)0;
#line 1169
  max = 0;
#line 1170
  i = 0;
  {
#line 1170
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1170
    if (! (i < t1->w * t1->h)) {
#line 1170
      goto while_break;
    }
    {
#line 1171
    __cil_tmp23 = abs(*(t1->data + i));
#line 1171
    tmp = __cil_tmp23;
#line 1172
    max = int_max(max, tmp);
#line 1170
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 1175
  if (max) {
    {
#line 1175
    __cil_tmp25 = int_floorlog2(max);
#line 1175
    tmp___0 = (__cil_tmp25 + 1) - 6;
    }
  } else {
#line 1175
    tmp___0 = 0;
  }
  {
#line 1175
  cblk->numbps = tmp___0;
#line 1177
  bpno = cblk->numbps - 1;
#line 1178
  passtype = 2;
#line 1180
  mqc_resetstates(mqc);
#line 1181
  mqc_setstate(mqc, 18, 0, 46);
#line 1182
  mqc_setstate(mqc, 17, 0, 3);
#line 1183
  mqc_setstate(mqc, 0, 0, 4);
#line 1184
  mqc_init_enc(mqc, cblk->data);
#line 1186
  passno = 0;
  }
  {
#line 1186
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1186
    if (! (bpno >= 0)) {
#line 1186
      goto while_break___0;
    }
#line 1187
    pass = cblk->passes + passno;
#line 1188
    correction = 3;
#line 1189
    if (bpno < cblk->numbps - 4) {
#line 1189
      if (passtype < 2) {
#line 1189
        if (cblksty & 1) {
#line 1189
          tmp___1 = 1;
        } else {
#line 1189
          tmp___1 = 0;
        }
      } else {
#line 1189
        tmp___1 = 0;
      }
    } else {
#line 1189
      tmp___1 = 0;
    }
#line 1189
    type = (char )tmp___1;
#line 1192
    if (passtype == 0) {
#line 1192
      goto case_0;
    }
#line 1195
    if (passtype == 1) {
#line 1195
      goto case_1;
    }
#line 1198
    if (passtype == 2) {
#line 1198
      goto case_2;
    }
#line 1191
    goto switch_break;
    case_0: 
    {
#line 1193
    t1_enc_sigpass(t1, bpno, orient, & nmsedec, type, cblksty);
    }
#line 1194
    goto switch_break;
    case_1: 
    {
#line 1196
    t1_enc_refpass(t1, bpno, & nmsedec, type, cblksty);
    }
#line 1197
    goto switch_break;
    case_2: 
    {
#line 1199
    t1_enc_clnpass(t1, bpno, orient, & nmsedec, cblksty);
    }
#line 1201
    if (cblksty & 32) {
      {
#line 1202
      mqc_segmark_enc(mqc);
      }
    }
#line 1203
    goto switch_break;
    switch_break: 
    {
#line 1207
    tempwmsedec = t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize,
                                numcomps, mct);
#line 1208
    cumwmsedec += tempwmsedec;
#line 1209
    tile->distotile += tempwmsedec;
    }
#line 1212
    if (cblksty & 4) {
#line 1212
      if (passtype == 2) {
#line 1212
        if (bpno - 1 < 0) {
#line 1212
          goto _L___4;
        } else {
#line 1212
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
#line 1213
        if ((int )type == 1) {
          {
#line 1214
          mqc_flush(mqc);
#line 1215
          correction = 1;
          }
        } else {
          {
#line 1218
          mqc_flush(mqc);
#line 1219
          correction = 1;
          }
        }
#line 1221
        pass->term = 1;
      }
    } else
    _L___4: 
#line 1223
    if (bpno < cblk->numbps - 4) {
#line 1223
      if (passtype > 0) {
        _L: 
#line 1223
        if (cblksty & 1) {
#line 1225
          if ((int )type == 1) {
            {
#line 1226
            mqc_flush(mqc);
#line 1227
            correction = 1;
            }
          } else {
            {
#line 1230
            mqc_flush(mqc);
#line 1231
            correction = 1;
            }
          }
#line 1233
          pass->term = 1;
        } else {
#line 1235
          pass->term = 0;
        }
      } else {
#line 1223
        goto _L___3;
      }
    } else
    _L___3: 
#line 1223
    if (bpno == cblk->numbps - 4) {
#line 1223
      if (passtype == 2) {
#line 1223
        goto _L;
      } else {
#line 1235
        pass->term = 0;
      }
    } else {
#line 1235
      pass->term = 0;
    }
#line 1239
    passtype ++;
#line 1239
    if (passtype == 3) {
#line 1240
      passtype = 0;
#line 1241
      __cil_tmp31 = bpno;
#line 1241
      bpno --;
    }
#line 1244
    if (pass->term) {
#line 1244
      if (bpno > 0) {
#line 1245
        if (bpno < cblk->numbps - 4) {
#line 1245
          if (passtype < 2) {
#line 1245
            if (cblksty & 1) {
#line 1245
              tmp___2 = 1;
            } else {
#line 1245
              tmp___2 = 0;
            }
          } else {
#line 1245
            tmp___2 = 0;
          }
        } else {
#line 1245
          tmp___2 = 0;
        }
#line 1245
        type = (char )tmp___2;
#line 1246
        if ((int )type == 1) {
          {
#line 1247
          mqc_bypass_init_enc(mqc);
          }
        } else {
          {
#line 1249
          mqc_restart_init_enc(mqc);
          }
        }
      }
    }
    {
#line 1252
    pass->distortiondec = cumwmsedec;
#line 1253
    __cil_tmp33 = mqc_numbytes(mqc);
#line 1253
    pass->rate = __cil_tmp33 + correction;
    }
#line 1256
    if (cblksty & 2) {
      {
#line 1257
      mqc_reset_enc(mqc);
      }
    }
#line 1186
    passno ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 1261
  if (cblksty & 16) {
    {
#line 1262
    mqc_erterm_enc(mqc);
    }
  } else
#line 1263
  if (! (cblksty & 1)) {
    {
#line 1264
    mqc_flush(mqc);
    }
  }
#line 1266
  cblk->totalpasses = passno;
#line 1268
  passno = 0;
  {
#line 1268
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 1268
    if (! (passno < cblk->totalpasses)) {
#line 1268
      goto while_break___1;
    }
    {
#line 1269
    pass___0 = cblk->passes + passno;
#line 1270
    __cil_tmp35 = mqc_numbytes(mqc);
    }
#line 1270
    if (pass___0->rate > __cil_tmp35) {
      {
#line 1271
      pass___0->rate = mqc_numbytes(mqc);
      }
    }
#line 1273
    if (pass___0->rate > 1) {
#line 1273
      if ((int )*(cblk->data + (pass___0->rate - 1)) == 255) {
#line 1274
        __cil_tmp37 = pass___0->rate;
#line 1274
        (pass___0->rate) --;
      }
    }
#line 1276
    if (passno == 0) {
#line 1276
      tmp___3 = 0;
    } else {
#line 1276
      tmp___3 = (cblk->passes + (passno - 1))->rate;
    }
#line 1276
    pass___0->len = pass___0->rate - tmp___3;
#line 1268
    passno ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: ;
#line 1272
  return;
}
}
#line 1280 "/root/patchweave_new/2/libopenjpeg/t1.c"
static void t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , int orient ,
                           int roishift , int cblksty ) 
{ 
  opj_raw_t *raw ;
  opj_mqc_t *mqc ;
  int bpno ;
  int passtype ;
  int segno ;
  int passno ;
  char type ;
  opj_bool __cil_tmp13 ;
  opj_tcd_seg_t *seg ;
  int tmp ;
  int __cil_tmp16 ;

  {
  {
#line 1287
  raw = t1->raw;
#line 1288
  mqc = t1->mqc;
#line 1292
  type = (char)0;
#line 1294
  __cil_tmp13 = allocate_buffers(t1, cblk->x1 - cblk->x0, cblk->y1 - cblk->y0);
  }
#line 1294
  if (! __cil_tmp13) {
#line 1299
    return;
  }
  {
#line 1302
  bpno = (roishift + cblk->numbps) - 1;
#line 1303
  passtype = 2;
#line 1305
  mqc_resetstates(mqc);
#line 1306
  mqc_setstate(mqc, 18, 0, 46);
#line 1307
  mqc_setstate(mqc, 17, 0, 3);
#line 1308
  mqc_setstate(mqc, 0, 0, 4);
#line 1310
  segno = 0;
  }
  {
#line 1310
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1310
    if (! (segno < cblk->numsegs)) {
#line 1310
      goto while_break;
    }
#line 1311
    seg = cblk->segs + segno;
#line 1314
    if (bpno <= (cblk->numbps - 1) - 4) {
#line 1314
      if (passtype < 2) {
#line 1314
        if (cblksty & 1) {
#line 1314
          tmp = 1;
        } else {
#line 1314
          tmp = 0;
        }
      } else {
#line 1314
        tmp = 0;
      }
    } else {
#line 1314
      tmp = 0;
    }
#line 1314
    type = (char )tmp;
#line 1316
    if ((unsigned long )seg->data == (unsigned long )((void *)0)) {
#line 1317
      goto while_continue;
    }
#line 1319
    if ((int )type == 1) {
      {
#line 1320
      raw_init_dec(raw, *(seg->data) + seg->dataindex, seg->len);
      }
    } else {
      {
#line 1322
      mqc_init_dec(mqc, *(seg->data) + seg->dataindex, seg->len);
      }
    }
#line 1325
    passno = 0;
    {
#line 1325
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1325
      if (! (passno < seg->numpasses)) {
#line 1325
        goto while_break___0;
      }
#line 1327
      if (passtype == 0) {
#line 1327
        goto case_0;
      }
#line 1338
      if (passtype == 1) {
#line 1338
        goto case_1;
      }
#line 1349
      if (passtype == 2) {
#line 1349
        goto case_2;
      }
#line 1326
      goto switch_break;
      case_0: 
#line 1328
      if ((int )type == 1) {
        {
#line 1329
        t1_dec_sigpass_raw(t1, bpno + 1, orient, cblksty);
        }
      } else
#line 1331
      if (cblksty & 8) {
        {
#line 1332
        t1_dec_sigpass_mqc_vsc(t1, bpno + 1, orient);
        }
      } else {
        {
#line 1334
        t1_dec_sigpass_mqc(t1, bpno + 1, orient);
        }
      }
#line 1337
      goto switch_break;
      case_1: 
#line 1339
      if ((int )type == 1) {
        {
#line 1340
        t1_dec_refpass_raw(t1, bpno + 1, cblksty);
        }
      } else
#line 1342
      if (cblksty & 8) {
        {
#line 1343
        t1_dec_refpass_mqc_vsc(t1, bpno + 1);
        }
      } else {
        {
#line 1345
        t1_dec_refpass_mqc(t1, bpno + 1);
        }
      }
#line 1348
      goto switch_break;
      case_2: 
      {
#line 1350
      t1_dec_clnpass(t1, bpno + 1, orient, cblksty);
      }
#line 1351
      goto switch_break;
      switch_break: ;
#line 1354
      if (cblksty & 2) {
#line 1354
        if ((int )type == 0) {
          {
#line 1355
          mqc_resetstates(mqc);
#line 1356
          mqc_setstate(mqc, 18, 0, 46);
#line 1357
          mqc_setstate(mqc, 17, 0, 3);
#line 1358
          mqc_setstate(mqc, 0, 0, 4);
          }
        }
      }
#line 1360
      passtype ++;
#line 1360
      if (passtype == 3) {
#line 1361
        passtype = 0;
#line 1362
        __cil_tmp16 = bpno;
#line 1362
        bpno --;
      }
#line 1325
      passno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 1310
    segno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1314
  return;
}
}
#line 1370 "/root/patchweave_new/2/libopenjpeg/t1.c"
opj_t1_t *t1_create(opj_common_ptr cinfo ) 
{ 
  opj_t1_t *t1 ;
  void *__cil_tmp3 ;

  {
  {
#line 1371
  __cil_tmp3 = malloc(sizeof(opj_t1_t ));
#line 1371
  t1 = (opj_t1_t *)__cil_tmp3;
  }
#line 1372
  if (! t1) {
#line 1373
    return ((opj_t1_t *)((void *)0));
  }
  {
#line 1375
  t1->cinfo = cinfo;
#line 1377
  t1->mqc = mqc_create();
#line 1378
  t1->raw = raw_create();
#line 1380
  t1->data = (int *)((void *)0);
#line 1381
  t1->flags = (flag_t *)((void *)0);
#line 1382
  t1->datasize = 0;
#line 1383
  t1->flagssize = 0;
  }
#line 1385
  return (t1);
}
}
#line 1388 "/root/patchweave_new/2/libopenjpeg/t1.c"
void t1_destroy(opj_t1_t *t1 ) 
{ 


  {
#line 1389
  if (t1) {
    {
#line 1391
    mqc_destroy(t1->mqc);
#line 1392
    raw_destroy(t1->raw);
#line 1393
    free((void *)t1->data);
#line 1394
    free((void *)t1->flags);
#line 1395
    free((void *)t1);
    }
  }
#line 1398
  return;
}
}
#line 1399 "/root/patchweave_new/2/libopenjpeg/t1.c"
void t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tccp_t *tccp ;
  int tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  int bandconst ;
  double __cil_tmp15 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  int *datap ;
  int *tiledp ;
  int cblk_w ;
  int cblk_h ;
  int i ;
  int j ;
  int x ;
  int y ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  opj_bool __cil_tmp28 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp31 ;

  {
#line 1406
  tile->distotile = (double )0;
#line 1408
  compno = 0;
  {
#line 1408
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1408
    if (! (compno < tile->numcomps)) {
#line 1408
      goto while_break;
    }
#line 1409
    tilec = tile->comps + compno;
#line 1410
    tccp = tcp->tccps + compno;
#line 1411
    tile_w = tilec->x1 - tilec->x0;
#line 1413
    resno = 0;
    {
#line 1413
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1413
      if (! (resno < tilec->numresolutions)) {
#line 1413
        goto while_break___0;
      }
#line 1414
      res = tilec->resolutions + resno;
#line 1416
      bandno = 0;
      {
#line 1416
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1416
        if (! (bandno < res->numbands)) {
#line 1416
          goto while_break___1;
        }
        {
#line 1417
        band = & res->bands[bandno];
#line 1418
        __cil_tmp15 = floor((double )(band->stepsize * (float )8192));
#line 1418
        bandconst = 67108864 / (int )__cil_tmp15;
#line 1420
        precno = 0;
        }
        {
#line 1420
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1420
          if (! (precno < res->pw * res->ph)) {
#line 1420
            goto while_break___2;
          }
#line 1421
          prc = band->precincts + precno;
#line 1423
          cblkno = 0;
          {
#line 1423
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 1423
            if (! (cblkno < prc->cw * prc->ch)) {
#line 1423
              goto while_break___3;
            }
#line 1424
            cblk = prc->cblks.enc + cblkno;
#line 1431
            x = cblk->x0 - band->x0;
#line 1432
            y = cblk->y0 - band->y0;
#line 1433
            if (band->bandno & 1) {
#line 1434
              pres = tilec->resolutions + (resno - 1);
#line 1435
              x += pres->x1 - pres->x0;
            }
#line 1437
            if (band->bandno & 2) {
#line 1438
              pres___0 = tilec->resolutions + (resno - 1);
#line 1439
              y += pres___0->y1 - pres___0->y0;
            }
            {
#line 1442
            __cil_tmp28 = allocate_buffers(t1, cblk->x1 - cblk->x0, cblk->y1 - cblk->y0);
            }
#line 1442
            if (! __cil_tmp28) {
#line 1447
              return;
            }
#line 1450
            datap = t1->data;
#line 1451
            cblk_w = t1->w;
#line 1452
            cblk_h = t1->h;
#line 1454
            tiledp = tilec->data + (y * tile_w + x);
#line 1455
            if (tccp->qmfbid == 1) {
#line 1456
              j = 0;
              {
#line 1456
              while (1) {
                while_continue___4: /* CIL Label */ ;

#line 1456
                if (! (j < cblk_h)) {
#line 1456
                  goto while_break___4;
                }
#line 1457
                i = 0;
                {
#line 1457
                while (1) {
                  while_continue___5: /* CIL Label */ ;

#line 1457
                  if (! (i < cblk_w)) {
#line 1457
                    goto while_break___5;
                  }
#line 1458
                  tmp = *(tiledp + (j * tile_w + i));
#line 1459
                  *(datap + (j * cblk_w + i)) = tmp << 6;
#line 1457
                  i ++;
                }
                while_break___14: /* CIL Label */ ;
                }
                while_break___5: 
#line 1456
                j ++;
              }
              while_break___13: /* CIL Label */ ;
              }
              while_break___4: ;
            } else {
#line 1463
              j = 0;
              {
#line 1463
              while (1) {
                while_continue___6: /* CIL Label */ ;

#line 1463
                if (! (j < cblk_h)) {
#line 1463
                  goto while_break___6;
                }
#line 1464
                i = 0;
                {
#line 1464
                while (1) {
                  while_continue___7: /* CIL Label */ ;

#line 1464
                  if (! (i < cblk_w)) {
#line 1464
                    goto while_break___7;
                  }
                  {
#line 1465
                  tmp___0 = *(tiledp + (j * tile_w + i));
#line 1466
                  __cil_tmp31 = fix_mul(tmp___0, bandconst);
#line 1466
                  *(datap + (j * cblk_w + i)) = __cil_tmp31 >> 5;
#line 1464
                  i ++;
                  }
                }
                while_break___16: /* CIL Label */ ;
                }
                while_break___7: 
#line 1463
                j ++;
              }
              while_break___15: /* CIL Label */ ;
              }
              while_break___6: ;
            }
            {
#line 1474
            t1_encode_cblk(t1, cblk, band->bandno, compno, (tilec->numresolutions - 1) - resno,
                           tccp->qmfbid, (double )band->stepsize, tccp->cblksty, tile->numcomps,
                           tcp->mct, tile);
#line 1423
            cblkno ++;
            }
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___3: 
#line 1420
          precno ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___2: 
#line 1416
        bandno ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___1: 
#line 1413
      resno ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___0: 
#line 1408
    compno ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: ;
#line 1412
  return;
}
}
#line 1494 "/root/patchweave_new/2/libopenjpeg/t1.c"
void t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) 
{ 
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *precinct ;
  opj_tcd_cblk_dec_t *cblk ;
  int *datap ;
  int cblk_w ;
  int cblk_h ;
  int x ;
  int y ;
  int i ;
  int j ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  int thresh ;
  int val ;
  int mag ;
  int __cil_tmp25 ;
  int tmp ;
  int *tiledp ;
  int tmp___0 ;
  float *tiledp___0 ;
  float *tiledp2 ;
  float tmp___1 ;

  {
#line 1501
  tile_w = tilec->x1 - tilec->x0;
#line 1503
  resno = 0;
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1503
    if (! (resno < tilec->numresolutions)) {
#line 1503
      goto while_break;
    }
#line 1504
    res = tilec->resolutions + resno;
#line 1506
    bandno = 0;
    {
#line 1506
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1506
      if (! (bandno < res->numbands)) {
#line 1506
        goto while_break___0;
      }
#line 1507
      band = & res->bands[bandno];
#line 1509
      precno = 0;
      {
#line 1509
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1509
        if (! (precno < res->pw * res->ph)) {
#line 1509
          goto while_break___1;
        }
#line 1510
        precinct = band->precincts + precno;
#line 1512
        cblkno = 0;
        {
#line 1512
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1512
          if (! (cblkno < precinct->cw * precinct->ch)) {
#line 1512
            goto while_break___2;
          }
          {
#line 1513
          cblk = precinct->cblks.dec + cblkno;
#line 1519
          t1_decode_cblk(t1, cblk, band->bandno, tccp->roishift, tccp->cblksty);
#line 1526
          x = cblk->x0 - band->x0;
#line 1527
          y = cblk->y0 - band->y0;
          }
#line 1528
          if (band->bandno & 1) {
#line 1529
            pres = tilec->resolutions + (resno - 1);
#line 1530
            x += pres->x1 - pres->x0;
          }
#line 1532
          if (band->bandno & 2) {
#line 1533
            pres___0 = tilec->resolutions + (resno - 1);
#line 1534
            y += pres___0->y1 - pres___0->y0;
          }
#line 1537
          datap = t1->data;
#line 1538
          cblk_w = t1->w;
#line 1539
          cblk_h = t1->h;
#line 1541
          if (tccp->roishift) {
#line 1542
            thresh = 1 << tccp->roishift;
#line 1543
            j = 0;
            {
#line 1543
            while (1) {
              while_continue___3: /* CIL Label */ ;

#line 1543
              if (! (j < cblk_h)) {
#line 1543
                goto while_break___3;
              }
#line 1544
              i = 0;
              {
#line 1544
              while (1) {
                while_continue___4: /* CIL Label */ ;

#line 1544
                if (! (i < cblk_w)) {
#line 1544
                  goto while_break___4;
                }
                {
#line 1545
                val = *(datap + (j * cblk_w + i));
#line 1546
                __cil_tmp25 = abs(val);
#line 1546
                mag = __cil_tmp25;
                }
#line 1547
                if (mag >= thresh) {
#line 1548
                  mag >>= tccp->roishift;
#line 1549
                  if (val < 0) {
#line 1549
                    tmp = - mag;
                  } else {
#line 1549
                    tmp = mag;
                  }
#line 1549
                  *(datap + (j * cblk_w + i)) = tmp;
                }
#line 1544
                i ++;
              }
              while_break___14: /* CIL Label */ ;
              }
              while_break___4: 
#line 1543
              j ++;
            }
            while_break___13: /* CIL Label */ ;
            }
            while_break___3: ;
          }
#line 1555
          if (tccp->qmfbid == 1) {
#line 1556
            tiledp = tilec->data + (y * tile_w + x);
#line 1557
            j = 0;
            {
#line 1557
            while (1) {
              while_continue___5: /* CIL Label */ ;

#line 1557
              if (! (j < cblk_h)) {
#line 1557
                goto while_break___5;
              }
#line 1558
              i = 0;
              {
#line 1558
              while (1) {
                while_continue___6: /* CIL Label */ ;

#line 1558
                if (! (i < cblk_w)) {
#line 1558
                  goto while_break___6;
                }
#line 1559
                tmp___0 = *(datap + (j * cblk_w + i));
#line 1560
                *(tiledp + (j * tile_w + i)) = tmp___0 / 2;
#line 1558
                i ++;
              }
              while_break___16: /* CIL Label */ ;
              }
              while_break___6: 
#line 1557
              j ++;
            }
            while_break___15: /* CIL Label */ ;
            }
            while_break___5: ;
          } else {
#line 1564
            tiledp___0 = (float *)(tilec->data + (y * tile_w + x));
#line 1565
            j = 0;
            {
#line 1565
            while (1) {
              while_continue___7: /* CIL Label */ ;

#line 1565
              if (! (j < cblk_h)) {
#line 1565
                goto while_break___7;
              }
#line 1566
              tiledp2 = tiledp___0;
#line 1567
              i = 0;
              {
#line 1567
              while (1) {
                while_continue___8: /* CIL Label */ ;

#line 1567
                if (! (i < cblk_w)) {
#line 1567
                  goto while_break___8;
                }
#line 1568
                tmp___1 = (float )*datap * band->stepsize;
#line 1569
                *tiledp2 = tmp___1;
#line 1570
                datap ++;
#line 1571
                tiledp2 ++;
#line 1567
                i ++;
              }
              while_break___18: /* CIL Label */ ;
              }
              while_break___8: 
#line 1573
              tiledp___0 += tile_w;
#line 1565
              j ++;
            }
            while_break___17: /* CIL Label */ ;
            }
            while_break___7: ;
          }
          {
#line 1576
          free((void *)cblk->data);
#line 1577
          free((void *)cblk->segs);
#line 1512
          cblkno ++;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___2: 
        {
#line 1579
        free((void *)precinct->cblks.dec);
#line 1580
        precinct->cblks.dec = (opj_tcd_cblk_dec_t *)((void *)0);
#line 1509
        precno ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___1: 
#line 1506
      bandno ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___0: 
#line 1503
    resno ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break: ;
#line 1507
  return;
}
}
#line 45 "/root/patchweave_new/2/libopenjpeg/raw.c"
opj_raw_t *raw_create(void) 
{ 
  opj_raw_t *raw ;
  void *__cil_tmp2 ;

  {
  {
#line 46
  __cil_tmp2 = malloc(sizeof(opj_raw_t ));
#line 46
  raw = (opj_raw_t *)__cil_tmp2;
  }
#line 47
  return (raw);
}
}
#line 50 "/root/patchweave_new/2/libopenjpeg/raw.c"
void raw_destroy(opj_raw_t *raw ) 
{ 


  {
#line 51
  if (raw) {
    {
#line 52
    free((void *)raw);
    }
  }
#line 55
  return;
}
}
#line 56 "/root/patchweave_new/2/libopenjpeg/raw.c"
int raw_numbytes(opj_raw_t *raw ) 
{ 


  {
#line 57
  return ((int )(raw->bp - raw->start));
}
}
#line 60 "/root/patchweave_new/2/libopenjpeg/raw.c"
void raw_init_dec(opj_raw_t *raw , unsigned char *bp , int len ) 
{ 


  {
#line 61
  raw->start = bp;
#line 62
  raw->lenmax = (unsigned int )len;
#line 63
  raw->len = 0U;
#line 64
  raw->c = (unsigned char)0;
#line 65
  raw->ct = 0U;
#line 66
  return;
}
}
#line 68 "/root/patchweave_new/2/libopenjpeg/raw.c"
int raw_decode(opj_raw_t *raw ) 
{ 
  int d ;
  unsigned int __cil_tmp4 ;

  {
#line 70
  if (raw->ct == 0U) {
#line 71
    raw->ct = 8U;
#line 72
    if (raw->len == raw->lenmax) {
#line 73
      raw->c = (unsigned char)255;
    } else {
#line 75
      if ((int )raw->c == 255) {
#line 76
        raw->ct = 7U;
      }
#line 78
      raw->c = *(raw->start + raw->len);
#line 79
      (raw->len) ++;
    }
  }
#line 82
  __cil_tmp4 = raw->ct;
#line 82
  (raw->ct) --;
#line 83
  d = ((int )raw->c >> raw->ct) & 1;
#line 85
  return (d);
}
}
#line 52 "/root/patchweave_new/2/libopenjpeg/ppix_manager.c"
int write_ppixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) ;
#line 54 "/root/patchweave_new/2/libopenjpeg/ppix_manager.c"
int write_ppix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int compno ;
  int i ;
  opj_jp2_box_t *box ;
  void *__cil_tmp11 ;
  int __cil_tmp15 ;

  {
  {
#line 61
  lenp = -1;
#line 62
  __cil_tmp11 = calloc((unsigned long )cstr_info.numcomps, sizeof(opj_jp2_box_t ));
#line 62
  box = (opj_jp2_box_t *)__cil_tmp11;
#line 64
  i = 0;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;

#line 64
    if (! (i < 2)) {
#line 64
      goto while_break;
    }
#line 65
    if (i) {
      {
#line 65
      cio_seek(cio, lenp);
      }
    }
    {
#line 67
    lenp = cio_tell(cio);
#line 68
    cio_skip(cio, 4);
#line 69
    cio_write(cio, 1886415224ULL, 4);
#line 71
    write_manf(i, cstr_info.numcomps, box, cio);
#line 73
    compno = 0;
    }
    {
#line 73
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 73
      if (! (compno < cstr_info.numcomps)) {
#line 73
        goto while_break___0;
      }
      {
#line 74
      (box + compno)->length = write_ppixfaix(coff, compno, cstr_info, EPHused, j2klen,
                                              cio);
#line 75
      (box + compno)->type = 1717660024;
#line 73
      compno ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 78
    __cil_tmp15 = cio_tell(cio);
#line 78
    len = __cil_tmp15 - lenp;
#line 79
    cio_seek(cio, lenp);
#line 80
    cio_write(cio, (unsigned long long )len, 4);
#line 81
    cio_seek(cio, lenp + len);
#line 64
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 84
  free((void *)box);
  }
#line 86
  return (len);
}
}
#line 89 "/root/patchweave_new/2/libopenjpeg/ppix_manager.c"
int write_ppixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int tileno ;
  int version ;
  int i ;
  int nmax ;
  int size_of_coding ;
  opj_tile_info_t *tile_Idx ;
  opj_packet_info_t packet ;
  int resno ;
  int precno ;
  int layno ;
  int num_packet ;
  int numOfres ;
  int numOfprec ;
  int numOflayers ;
  double __cil_tmp23 ;
  int __cil_tmp32 ;

  {
  {
#line 96
  packet.start_pos = -1;
#line 96
  packet.end_ph_pos = packet.start_pos;
#line 96
  packet.end_pos = packet.end_ph_pos;
#line 99
  __cil_tmp23 = pow((double )2, (double )32);
  }
#line 99
  if ((double )j2klen > __cil_tmp23) {
#line 100
    size_of_coding = 8;
#line 101
    version = 1;
  } else {
#line 104
    size_of_coding = 4;
#line 105
    version = 0;
  }
  {
#line 108
  lenp = cio_tell(cio);
#line 109
  cio_skip(cio, 4);
#line 110
  cio_write(cio, 1717660024ULL, 4);
#line 111
  cio_write(cio, (unsigned long long )version, 1);
#line 113
  nmax = 0;
#line 114
  i = 0;
  }
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;

#line 114
    if (! (i <= *(cstr_info.numdecompos + compno))) {
#line 114
      goto while_break;
    }
#line 115
    nmax += ((cstr_info.tile + 0)->ph[i] * (cstr_info.tile + 0)->pw[i]) * cstr_info.numlayers;
#line 114
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
  {
#line 117
  cio_write(cio, (unsigned long long )nmax, size_of_coding);
#line 118
  cio_write(cio, (unsigned long long )(cstr_info.tw * cstr_info.th), size_of_coding);
#line 120
  tileno = 0;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 120
    if (! (tileno < cstr_info.tw * cstr_info.th)) {
#line 120
      goto while_break___0;
    }
#line 121
    tile_Idx = cstr_info.tile + tileno;
#line 123
    num_packet = 0;
#line 124
    numOfres = *(cstr_info.numdecompos + compno) + 1;
#line 126
    resno = 0;
    {
#line 126
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 126
      if (! (resno < numOfres)) {
#line 126
        goto while_break___1;
      }
#line 127
      numOfprec = tile_Idx->pw[resno] * tile_Idx->ph[resno];
#line 128
      precno = 0;
      {
#line 128
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 128
        if (! (precno < numOfprec)) {
#line 128
          goto while_break___2;
        }
#line 129
        numOflayers = cstr_info.numlayers;
#line 130
        layno = 0;
        {
#line 130
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 130
          if (! (layno < numOflayers)) {
#line 130
            goto while_break___3;
          }
#line 133
          if ((int )cstr_info.prog == 0) {
#line 133
            goto case_0;
          }
#line 136
          if ((int )cstr_info.prog == 1) {
#line 136
            goto case_1;
          }
#line 139
          if ((int )cstr_info.prog == 2) {
#line 139
            goto case_2;
          }
#line 142
          if ((int )cstr_info.prog == 3) {
#line 142
            goto case_3;
          }
#line 145
          if ((int )cstr_info.prog == 4) {
#line 145
            goto case_4;
          }
#line 148
          goto switch_default;
          case_0: 
#line 134
          packet = *(tile_Idx->packet + (((layno * numOfres + resno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 135
          goto switch_break;
          case_1: 
#line 137
          packet = *(tile_Idx->packet + (((resno * numOflayers + layno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 138
          goto switch_break;
          case_2: 
#line 140
          packet = *(tile_Idx->packet + (((resno * numOfprec + precno) * cstr_info.numcomps + compno) * numOflayers + layno));
#line 141
          goto switch_break;
          case_3: 
#line 143
          packet = *(tile_Idx->packet + (((precno * cstr_info.numcomps + compno) * numOfres + resno) * numOflayers + layno));
#line 144
          goto switch_break;
          case_4: 
#line 146
          packet = *(tile_Idx->packet + (((compno * numOfprec + precno) * numOfres + resno) * numOflayers + layno));
#line 147
          goto switch_break;
          switch_default: 
          {
#line 149
          fprintf(stderr, "failed to ppix indexing\n\220");
          }
          switch_break: 
          {
#line 152
          cio_write(cio, (unsigned long long )(packet.start_pos - coff), size_of_coding);
#line 153
          cio_write(cio, (unsigned long long )((packet.end_pos - packet.start_pos) + 1),
                    size_of_coding);
#line 155
          num_packet ++;
#line 130
          layno ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: 
#line 128
        precno ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: 
#line 126
      resno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: ;
    {
#line 160
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 160
      if (! (num_packet < nmax)) {
#line 160
        goto while_break___4;
      }
      {
#line 161
      cio_write(cio, 0ULL, size_of_coding);
#line 162
      cio_write(cio, 0ULL, size_of_coding);
#line 163
      num_packet ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: 
#line 120
    tileno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 167
  __cil_tmp32 = cio_tell(cio);
#line 167
  len = __cil_tmp32 - lenp;
#line 168
  cio_seek(cio, lenp);
#line 169
  cio_write(cio, (unsigned long long )len, 4);
#line 170
  cio_seek(cio, lenp + len);
  }
#line 172
  return (len);
}
}
#line 46 "/root/patchweave_new/2/libopenjpeg/pi.c"
static opj_bool pi_next_lrcp(opj_pi_iterator_t *pi ) ;
#line 52
static opj_bool pi_next_rlcp(opj_pi_iterator_t *pi ) ;
#line 58
static opj_bool pi_next_rpcl(opj_pi_iterator_t *pi ) ;
#line 64
static opj_bool pi_next_pcrl(opj_pi_iterator_t *pi ) ;
#line 70
static opj_bool pi_next_cprl(opj_pi_iterator_t *pi ) ;
#line 82 "/root/patchweave_new/2/libopenjpeg/pi.c"
static opj_bool pi_next_lrcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___5 ;

  {
#line 83
  comp = (opj_pi_comp_t *)((void *)0);
#line 84
  res = (opj_pi_resolution_t *)((void *)0);
#line 85
  index___5 = 0L;
#line 87
  if (! pi->first) {
#line 88
    comp = pi->comps + pi->compno;
#line 89
    res = comp->resolutions + pi->resno;
#line 90
    goto LABEL_SKIP;
  } else {
#line 92
    pi->first = 0;
  }
#line 95
  pi->layno = pi->poc.layno0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;

#line 95
    if (! (pi->layno < pi->poc.layno1)) {
#line 95
      goto while_break;
    }
#line 96
    pi->resno = pi->poc.resno0;
    {
#line 96
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 96
      if (! (pi->resno < pi->poc.resno1)) {
#line 96
        goto while_break___0;
      }
#line 98
      pi->compno = pi->poc.compno0;
      {
#line 98
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___1: ;
#line 98
        if (! (pi->compno < pi->poc.compno1)) {
#line 98
          goto while_break___1;
        }
#line 99
        comp = pi->comps + pi->compno;
#line 100
        if (pi->resno >= comp->numresolutions) {
#line 101
          goto while_continue___1;
        }
#line 103
        res = comp->resolutions + pi->resno;
#line 104
        if (! pi->tp_on) {
#line 105
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 107
        pi->precno = pi->poc.precno0;
        {
#line 107
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 107
          if (! (pi->precno < pi->poc.precno1)) {
#line 107
            goto while_break___2;
          }
#line 108
          index___5 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 109
          if (! *(pi->include + index___5)) {
#line 110
            *(pi->include + index___5) = (short)1;
#line 111
            return (1);
          }
          LABEL_SKIP: 
#line 107
          (pi->precno) ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 98
        (pi->compno) ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 97
      (pi->resno) ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 95
    (pi->layno) ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 119
  return (0);
}
}
#line 122 "/root/patchweave_new/2/libopenjpeg/pi.c"
static opj_bool pi_next_rlcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___6 ;

  {
#line 123
  comp = (opj_pi_comp_t *)((void *)0);
#line 124
  res = (opj_pi_resolution_t *)((void *)0);
#line 125
  index___6 = 0L;
#line 127
  if (! pi->first) {
#line 128
    comp = pi->comps + pi->compno;
#line 129
    res = comp->resolutions + pi->resno;
#line 130
    goto LABEL_SKIP;
  } else {
#line 132
    pi->first = 0;
  }
#line 135
  pi->resno = pi->poc.resno0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;

#line 135
    if (! (pi->resno < pi->poc.resno1)) {
#line 135
      goto while_break;
    }
#line 136
    pi->layno = pi->poc.layno0;
    {
#line 136
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 136
      if (! (pi->layno < pi->poc.layno1)) {
#line 136
        goto while_break___0;
      }
#line 137
      pi->compno = pi->poc.compno0;
      {
#line 137
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___1: ;
#line 137
        if (! (pi->compno < pi->poc.compno1)) {
#line 137
          goto while_break___1;
        }
#line 138
        comp = pi->comps + pi->compno;
#line 139
        if (pi->resno >= comp->numresolutions) {
#line 140
          goto while_continue___1;
        }
#line 142
        res = comp->resolutions + pi->resno;
#line 143
        if (! pi->tp_on) {
#line 144
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 146
        pi->precno = pi->poc.precno0;
        {
#line 146
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 146
          if (! (pi->precno < pi->poc.precno1)) {
#line 146
            goto while_break___2;
          }
#line 147
          index___6 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 148
          if (! *(pi->include + index___6)) {
#line 149
            *(pi->include + index___6) = (short)1;
#line 150
            return (1);
          }
          LABEL_SKIP: 
#line 146
          (pi->precno) ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 137
        (pi->compno) ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 136
      (pi->layno) ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 135
    (pi->resno) ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 158
  return (0);
}
}
#line 161 "/root/patchweave_new/2/libopenjpeg/pi.c"
static opj_bool pi_next_rpcl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___7 ;
  int compno ;
  int resno ;
  int dx ;
  int dy ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int levelno ;
  int trx0 ;
  int try0 ;
  int trx1 ;
  int try1 ;
  int rpx ;
  int rpy ;
  int prci ;
  int prcj ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;

  {
#line 162
  comp = (opj_pi_comp_t *)((void *)0);
#line 163
  res = (opj_pi_resolution_t *)((void *)0);
#line 164
  index___7 = 0L;
#line 166
  if (! pi->first) {
#line 167
    goto LABEL_SKIP;
  } else {
#line 170
    pi->first = 0;
#line 171
    pi->dx = 0;
#line 172
    pi->dy = 0;
#line 173
    compno = 0;
    {
#line 173
    while (1) {
      while_continue: /* CIL Label */ ;

#line 173
      if (! (compno < pi->numcomps)) {
#line 173
        goto while_break;
      }
#line 174
      comp = pi->comps + compno;
#line 175
      resno = 0;
      {
#line 175
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 175
        if (! (resno < comp->numresolutions)) {
#line 175
          goto while_break___0;
        }
#line 177
        res = comp->resolutions + resno;
#line 178
        dx = comp->dx * (1 << (((res->pdx + comp->numresolutions) - 1) - resno));
#line 179
        dy = comp->dy * (1 << (((res->pdy + comp->numresolutions) - 1) - resno));
#line 180
        if (! pi->dx) {
#line 180
          tmp = dx;
        } else {
          {
#line 180
          __cil_tmp9 = int_min(pi->dx, dx);
#line 180
          tmp = __cil_tmp9;
          }
        }
#line 180
        pi->dx = tmp;
#line 181
        if (! pi->dy) {
#line 181
          tmp___0 = dy;
        } else {
          {
#line 181
          __cil_tmp11 = int_min(pi->dy, dy);
#line 181
          tmp___0 = __cil_tmp11;
          }
        }
#line 181
        pi->dy = tmp___0;
#line 175
        resno ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___0: 
#line 173
      compno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 185
  if (! pi->tp_on) {
#line 186
    pi->poc.ty0 = pi->ty0;
#line 187
    pi->poc.tx0 = pi->tx0;
#line 188
    pi->poc.ty1 = pi->ty1;
#line 189
    pi->poc.tx1 = pi->tx1;
  }
#line 191
  pi->resno = pi->poc.resno0;
  {
#line 191
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 191
    if (! (pi->resno < pi->poc.resno1)) {
#line 191
      goto while_break___1;
    }
#line 192
    pi->y = pi->poc.ty0;
    {
#line 192
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 192
      if (! (pi->y < pi->poc.ty1)) {
#line 192
        goto while_break___2;
      }
#line 193
      pi->x = pi->poc.tx0;
      {
#line 193
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 193
        if (! (pi->x < pi->poc.tx1)) {
#line 193
          goto while_break___3;
        }
#line 194
        pi->compno = pi->poc.compno0;
        {
#line 194
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___4: ;
#line 194
          if (! (pi->compno < pi->poc.compno1)) {
#line 194
            goto while_break___4;
          }
#line 200
          comp = pi->comps + pi->compno;
#line 201
          if (pi->resno >= comp->numresolutions) {
#line 202
            goto while_continue___4;
          }
          {
#line 204
          res = comp->resolutions + pi->resno;
#line 205
          levelno = (comp->numresolutions - 1) - pi->resno;
#line 206
          trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
#line 207
          try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
#line 208
          trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
#line 209
          try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
#line 210
          rpx = res->pdx + levelno;
#line 211
          rpy = res->pdy + levelno;
          }
#line 212
          if (! (pi->y % (comp->dy << rpy) == 0)) {
#line 212
            if (pi->y == pi->ty0) {
#line 212
              if (! ((try0 << levelno) % (1 << rpy))) {
#line 213
                goto while_continue___4;
              }
            } else {
#line 213
              goto while_continue___4;
            }
          }
#line 215
          if (! (pi->x % (comp->dx << rpx) == 0)) {
#line 215
            if (pi->x == pi->tx0) {
#line 215
              if (! ((trx0 << levelno) % (1 << rpx))) {
#line 216
                goto while_continue___4;
              }
            } else {
#line 216
              goto while_continue___4;
            }
          }
#line 219
          if (res->pw == 0) {
#line 219
            goto while_continue___4;
          } else
#line 219
          if (res->ph == 0) {
#line 219
            goto while_continue___4;
          }
#line 221
          if (trx0 == trx1) {
#line 221
            goto while_continue___4;
          } else
#line 221
          if (try0 == try1) {
#line 221
            goto while_continue___4;
          }
          {
#line 223
          __cil_tmp30 = int_floordivpow2(trx0, res->pdx);
#line 223
          __cil_tmp28 = int_ceildiv(pi->x, comp->dx << levelno);
#line 223
          __cil_tmp29 = int_floordivpow2(__cil_tmp28, res->pdx);
#line 223
          prci = __cil_tmp29 - __cil_tmp30;
#line 225
          __cil_tmp33 = int_floordivpow2(try0, res->pdy);
#line 225
          __cil_tmp31 = int_ceildiv(pi->y, comp->dy << levelno);
#line 225
          __cil_tmp32 = int_floordivpow2(__cil_tmp31, res->pdy);
#line 225
          prcj = __cil_tmp32 - __cil_tmp33;
#line 227
          pi->precno = prci + prcj * res->pw;
#line 228
          pi->layno = pi->poc.layno0;
          }
          {
#line 228
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 228
            if (! (pi->layno < pi->poc.layno1)) {
#line 228
              goto while_break___5;
            }
#line 229
            index___7 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 230
            if (! *(pi->include + index___7)) {
#line 231
              *(pi->include + index___7) = (short)1;
#line 232
              return (1);
            }
            LABEL_SKIP: 
#line 228
            (pi->layno) ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___5: 
#line 194
          (pi->compno) ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___4: 
#line 193
        pi->x += pi->dx - pi->x % pi->dx;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: 
#line 192
      pi->y += pi->dy - pi->y % pi->dy;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: 
#line 191
    (pi->resno) ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: ;
#line 241
  return (0);
}
}
#line 244 "/root/patchweave_new/2/libopenjpeg/pi.c"
static opj_bool pi_next_pcrl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___8 ;
  int compno ;
  int resno ;
  int dx ;
  int dy ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp15 ;
  int levelno ;
  int trx0 ;
  int try0 ;
  int trx1 ;
  int try1 ;
  int rpx ;
  int rpy ;
  int prci ;
  int prcj ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;

  {
#line 245
  comp = (opj_pi_comp_t *)((void *)0);
#line 246
  res = (opj_pi_resolution_t *)((void *)0);
#line 247
  index___8 = 0L;
#line 249
  if (! pi->first) {
#line 250
    comp = pi->comps + pi->compno;
#line 251
    goto LABEL_SKIP;
  } else {
#line 254
    pi->first = 0;
#line 255
    pi->dx = 0;
#line 256
    pi->dy = 0;
#line 257
    compno = 0;
    {
#line 257
    while (1) {
      while_continue: /* CIL Label */ ;

#line 257
      if (! (compno < pi->numcomps)) {
#line 257
        goto while_break;
      }
#line 258
      comp = pi->comps + compno;
#line 259
      resno = 0;
      {
#line 259
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 259
        if (! (resno < comp->numresolutions)) {
#line 259
          goto while_break___0;
        }
#line 261
        res = comp->resolutions + resno;
#line 262
        dx = comp->dx * (1 << (((res->pdx + comp->numresolutions) - 1) - resno));
#line 263
        dy = comp->dy * (1 << (((res->pdy + comp->numresolutions) - 1) - resno));
#line 264
        if (! pi->dx) {
#line 264
          tmp = dx;
        } else {
          {
#line 264
          __cil_tmp9 = int_min(pi->dx, dx);
#line 264
          tmp = __cil_tmp9;
          }
        }
#line 264
        pi->dx = tmp;
#line 265
        if (! pi->dy) {
#line 265
          tmp___0 = dy;
        } else {
          {
#line 265
          __cil_tmp11 = int_min(pi->dy, dy);
#line 265
          tmp___0 = __cil_tmp11;
          }
        }
#line 265
        pi->dy = tmp___0;
#line 259
        resno ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___0: 
#line 257
      compno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 269
  if (! pi->tp_on) {
#line 270
    pi->poc.ty0 = pi->ty0;
#line 271
    pi->poc.tx0 = pi->tx0;
#line 272
    pi->poc.ty1 = pi->ty1;
#line 273
    pi->poc.tx1 = pi->tx1;
  }
#line 275
  pi->y = pi->poc.ty0;
  {
#line 275
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 275
    if (! (pi->y < pi->poc.ty1)) {
#line 275
      goto while_break___1;
    }
#line 276
    pi->x = pi->poc.tx0;
    {
#line 276
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 276
      if (! (pi->x < pi->poc.tx1)) {
#line 276
        goto while_break___2;
      }
#line 277
      pi->compno = pi->poc.compno0;
      {
#line 277
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 277
        if (! (pi->compno < pi->poc.compno1)) {
#line 277
          goto while_break___3;
        }
#line 278
        comp = pi->comps + pi->compno;
#line 279
        pi->resno = pi->poc.resno0;
        {
#line 279
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___4: ;
#line 279
          if (! (pi->resno < __cil_tmp15)) {
#line 279
            goto while_break___4;
          }
          {
#line 285
          res = comp->resolutions + pi->resno;
#line 286
          levelno = (comp->numresolutions - 1) - pi->resno;
#line 287
          trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
#line 288
          try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
#line 289
          trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
#line 290
          try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
#line 291
          rpx = res->pdx + levelno;
#line 292
          rpy = res->pdy + levelno;
          }
#line 293
          if (! (pi->y % (comp->dy << rpy) == 0)) {
#line 293
            if (pi->y == pi->ty0) {
#line 293
              if (! ((try0 << levelno) % (1 << rpy))) {
#line 294
                goto while_continue___4;
              }
            } else {
#line 294
              goto while_continue___4;
            }
          }
#line 296
          if (! (pi->x % (comp->dx << rpx) == 0)) {
#line 296
            if (pi->x == pi->tx0) {
#line 296
              if (! ((trx0 << levelno) % (1 << rpx))) {
#line 297
                goto while_continue___4;
              }
            } else {
#line 297
              goto while_continue___4;
            }
          }
#line 300
          if (res->pw == 0) {
#line 300
            goto while_continue___4;
          } else
#line 300
          if (res->ph == 0) {
#line 300
            goto while_continue___4;
          }
#line 302
          if (trx0 == trx1) {
#line 302
            goto while_continue___4;
          } else
#line 302
          if (try0 == try1) {
#line 302
            goto while_continue___4;
          }
          {
#line 304
          __cil_tmp31 = int_floordivpow2(trx0, res->pdx);
#line 304
          __cil_tmp29 = int_ceildiv(pi->x, comp->dx << levelno);
#line 304
          __cil_tmp30 = int_floordivpow2(__cil_tmp29, res->pdx);
#line 304
          prci = __cil_tmp30 - __cil_tmp31;
#line 306
          __cil_tmp34 = int_floordivpow2(try0, res->pdy);
#line 306
          __cil_tmp32 = int_ceildiv(pi->y, comp->dy << levelno);
#line 306
          __cil_tmp33 = int_floordivpow2(__cil_tmp32, res->pdy);
#line 306
          prcj = __cil_tmp33 - __cil_tmp34;
#line 308
          pi->precno = prci + prcj * res->pw;
#line 309
          pi->layno = pi->poc.layno0;
          }
          {
#line 309
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 309
            if (! (pi->layno < pi->poc.layno1)) {
#line 309
              goto while_break___5;
            }
#line 310
            index___8 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 311
            if (! *(pi->include + index___8)) {
#line 312
              *(pi->include + index___8) = (short)1;
#line 313
              return (1);
            }
            LABEL_SKIP: 
#line 309
            (pi->layno) ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___5: 
#line 279
          (pi->resno) ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___4: 
#line 277
        (pi->compno) ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: 
#line 276
      pi->x += pi->dx - pi->x % pi->dx;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: 
#line 275
    pi->y += pi->dy - pi->y % pi->dy;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: ;
#line 322
  return (0);
}
}
#line 325 "/root/patchweave_new/2/libopenjpeg/pi.c"
static opj_bool pi_next_cprl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___9 ;
  int resno ;
  int dx ;
  int dy ;
  int __cil_tmp8 ;
  int tmp ;
  int __cil_tmp10 ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int levelno ;
  int trx0 ;
  int try0 ;
  int trx1 ;
  int try1 ;
  int rpx ;
  int rpy ;
  int prci ;
  int prcj ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 326
  comp = (opj_pi_comp_t *)((void *)0);
#line 327
  res = (opj_pi_resolution_t *)((void *)0);
#line 328
  index___9 = 0L;
#line 330
  if (! pi->first) {
#line 331
    comp = pi->comps + pi->compno;
#line 332
    goto LABEL_SKIP;
  } else {
#line 334
    pi->first = 0;
  }
#line 337
  pi->compno = pi->poc.compno0;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;

#line 337
    if (! (pi->compno < pi->poc.compno1)) {
#line 337
      goto while_break;
    }
#line 339
    comp = pi->comps + pi->compno;
#line 340
    pi->dx = 0;
#line 341
    pi->dy = 0;
#line 342
    resno = 0;
    {
#line 342
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 342
      if (! (resno < comp->numresolutions)) {
#line 342
        goto while_break___0;
      }
#line 344
      res = comp->resolutions + resno;
#line 345
      dx = comp->dx * (1 << (((res->pdx + comp->numresolutions) - 1) - resno));
#line 346
      dy = comp->dy * (1 << (((res->pdy + comp->numresolutions) - 1) - resno));
#line 347
      if (! pi->dx) {
#line 347
        tmp = dx;
      } else {
        {
#line 347
        __cil_tmp8 = int_min(pi->dx, dx);
#line 347
        tmp = __cil_tmp8;
        }
      }
#line 347
      pi->dx = tmp;
#line 348
      if (! pi->dy) {
#line 348
        tmp___0 = dy;
      } else {
        {
#line 348
        __cil_tmp10 = int_min(pi->dy, dy);
#line 348
        tmp___0 = __cil_tmp10;
        }
      }
#line 348
      pi->dy = tmp___0;
#line 342
      resno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: ;
#line 350
    if (! pi->tp_on) {
#line 351
      pi->poc.ty0 = pi->ty0;
#line 352
      pi->poc.tx0 = pi->tx0;
#line 353
      pi->poc.ty1 = pi->ty1;
#line 354
      pi->poc.tx1 = pi->tx1;
    }
#line 356
    pi->y = pi->poc.ty0;
    {
#line 356
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 356
      if (! (pi->y < pi->poc.ty1)) {
#line 356
        goto while_break___1;
      }
#line 357
      pi->x = pi->poc.tx0;
      {
#line 357
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 357
        if (! (pi->x < pi->poc.tx1)) {
#line 357
          goto while_break___2;
        }
#line 358
        pi->resno = pi->poc.resno0;
        {
#line 358
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___3: ;
#line 358
          if (! (pi->resno < __cil_tmp13)) {
#line 358
            goto while_break___3;
          }
          {
#line 364
          res = comp->resolutions + pi->resno;
#line 365
          levelno = (comp->numresolutions - 1) - pi->resno;
#line 366
          trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
#line 367
          try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
#line 368
          trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
#line 369
          try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
#line 370
          rpx = res->pdx + levelno;
#line 371
          rpy = res->pdy + levelno;
          }
#line 372
          if (! (pi->y % (comp->dy << rpy) == 0)) {
#line 372
            if (pi->y == pi->ty0) {
#line 372
              if (! ((try0 << levelno) % (1 << rpy))) {
#line 373
                goto while_continue___3;
              }
            } else {
#line 373
              goto while_continue___3;
            }
          }
#line 375
          if (! (pi->x % (comp->dx << rpx) == 0)) {
#line 375
            if (pi->x == pi->tx0) {
#line 375
              if (! ((trx0 << levelno) % (1 << rpx))) {
#line 376
                goto while_continue___3;
              }
            } else {
#line 376
              goto while_continue___3;
            }
          }
#line 379
          if (res->pw == 0) {
#line 379
            goto while_continue___3;
          } else
#line 379
          if (res->ph == 0) {
#line 379
            goto while_continue___3;
          }
#line 381
          if (trx0 == trx1) {
#line 381
            goto while_continue___3;
          } else
#line 381
          if (try0 == try1) {
#line 381
            goto while_continue___3;
          }
          {
#line 383
          __cil_tmp29 = int_floordivpow2(trx0, res->pdx);
#line 383
          __cil_tmp27 = int_ceildiv(pi->x, comp->dx << levelno);
#line 383
          __cil_tmp28 = int_floordivpow2(__cil_tmp27, res->pdx);
#line 383
          prci = __cil_tmp28 - __cil_tmp29;
#line 385
          __cil_tmp32 = int_floordivpow2(try0, res->pdy);
#line 385
          __cil_tmp30 = int_ceildiv(pi->y, comp->dy << levelno);
#line 385
          __cil_tmp31 = int_floordivpow2(__cil_tmp30, res->pdy);
#line 385
          prcj = __cil_tmp31 - __cil_tmp32;
#line 387
          pi->precno = prci + prcj * res->pw;
#line 388
          pi->layno = pi->poc.layno0;
          }
          {
#line 388
          while (1) {
            while_continue___8: /* CIL Label */ ;

#line 388
            if (! (pi->layno < pi->poc.layno1)) {
#line 388
              goto while_break___4;
            }
#line 389
            index___9 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 390
            if (! *(pi->include + index___9)) {
#line 391
              *(pi->include + index___9) = (short)1;
#line 392
              return (1);
            }
            LABEL_SKIP: 
#line 388
            (pi->layno) ++;
          }
          while_break___10: /* CIL Label */ ;
          }
          while_break___4: 
#line 358
          (pi->resno) ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: 
#line 357
        pi->x += pi->dx - pi->x % pi->dx;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: 
#line 356
      pi->y += pi->dy - pi->y % pi->dy;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
#line 337
    (pi->compno) ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 401
  return (0);
}
}
#line 410 "/root/patchweave_new/2/libopenjpeg/pi.c"
opj_pi_iterator_t *pi_create_decode(opj_image_t *image , opj_cp_t *cp , int tileno ) 
{ 
  int p ;
  int q ;
  int compno ;
  int resno ;
  int pino ;
  opj_pi_iterator_t *pi ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  void *__cil_tmp12 ;
  int maxres ;
  int maxprec ;
  void *__cil_tmp19 ;
  int tcx0 ;
  int tcy0 ;
  int tcx1 ;
  int tcy1 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp25 ;
  int levelno ;
  int rx0 ;
  int ry0 ;
  int rx1 ;
  int ry1 ;
  int px0 ;
  int py0 ;
  int px1 ;
  int py1 ;
  opj_pi_resolution_t *res ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp52 ;

  {
  {
#line 413
  pi = (opj_pi_iterator_t *)((void *)0);
#line 414
  tcp = (opj_tcp_t *)((void *)0);
#line 415
  tccp = (opj_tccp_t *)((void *)0);
#line 417
  tcp = cp->tcps + tileno;
#line 419
  __cil_tmp12 = calloc((unsigned long )(tcp->numpocs + 1), sizeof(opj_pi_iterator_t ));
#line 419
  pi = (opj_pi_iterator_t *)__cil_tmp12;
  }
#line 420
  if (! pi) {
#line 422
    return ((opj_pi_iterator_t *)((void *)0));
  }
#line 425
  pino = 0;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;

#line 425
    if (! (pino < tcp->numpocs + 1)) {
#line 425
      goto while_break;
    }
    {
#line 426
    maxres = 0;
#line 427
    maxprec = 0;
#line 428
    p = tileno % cp->tw;
#line 429
    q = tileno / cp->tw;
#line 431
    (pi + pino)->tx0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 432
    (pi + pino)->ty0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 433
    (pi + pino)->tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 434
    (pi + pino)->ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 435
    (pi + pino)->numcomps = image->numcomps;
#line 437
    __cil_tmp19 = calloc((unsigned long )image->numcomps, sizeof(opj_pi_comp_t ));
#line 437
    (pi + pino)->comps = (opj_pi_comp_t *)__cil_tmp19;
    }
#line 438
    if (! (pi + pino)->comps) {
      {
#line 440
      pi_destroy(pi, cp, tileno);
      }
#line 441
      return ((opj_pi_iterator_t *)((void *)0));
    }
#line 444
    compno = 0;
    {
#line 444
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 444
      if (! (compno < pi->numcomps)) {
#line 444
        goto while_break___0;
      }
      {
#line 446
      comp = (pi + pino)->comps + compno;
#line 447
      tccp = tcp->tccps + compno;
#line 448
      comp->dx = (image->comps + compno)->dx;
#line 449
      comp->dy = (image->comps + compno)->dy;
#line 450
      comp->numresolutions = tccp->numresolutions;
#line 452
      __cil_tmp25 = calloc((unsigned long )comp->numresolutions, sizeof(opj_pi_resolution_t ));
#line 452
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp25;
      }
#line 453
      if (! comp->resolutions) {
        {
#line 455
        pi_destroy(pi, cp, tileno);
        }
#line 456
        return ((opj_pi_iterator_t *)((void *)0));
      }
      {
#line 459
      tcx0 = int_ceildiv(pi->tx0, comp->dx);
#line 460
      tcy0 = int_ceildiv(pi->ty0, comp->dy);
#line 461
      tcx1 = int_ceildiv(pi->tx1, comp->dx);
#line 462
      tcy1 = int_ceildiv(pi->ty1, comp->dy);
      }
#line 463
      if (comp->numresolutions > maxres) {
#line 464
        maxres = comp->numresolutions;
      }
#line 467
      resno = 0;
      {
#line 467
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 467
        if (! (resno < comp->numresolutions)) {
#line 467
          goto while_break___1;
        }
#line 471
        res = comp->resolutions + resno;
#line 472
        if (tccp->csty & 1) {
#line 473
          res->pdx = tccp->prcw[resno];
#line 474
          res->pdy = tccp->prch[resno];
        } else {
#line 476
          res->pdx = 15;
#line 477
          res->pdy = 15;
        }
        {
#line 479
        levelno = (comp->numresolutions - 1) - resno;
#line 480
        rx0 = int_ceildivpow2(tcx0, levelno);
#line 481
        ry0 = int_ceildivpow2(tcy0, levelno);
#line 482
        rx1 = int_ceildivpow2(tcx1, levelno);
#line 483
        ry1 = int_ceildivpow2(tcy1, levelno);
#line 484
        __cil_tmp44 = int_floordivpow2(rx0, res->pdx);
#line 484
        px0 = __cil_tmp44 << res->pdx;
#line 485
        __cil_tmp45 = int_floordivpow2(ry0, res->pdy);
#line 485
        py0 = __cil_tmp45 << res->pdy;
#line 486
        __cil_tmp46 = int_ceildivpow2(rx1, res->pdx);
#line 486
        px1 = __cil_tmp46 << res->pdx;
#line 487
        __cil_tmp47 = int_ceildivpow2(ry1, res->pdy);
#line 487
        py1 = __cil_tmp47 << res->pdy;
        }
#line 488
        if (rx0 == rx1) {
#line 488
          tmp = 0;
        } else {
#line 488
          tmp = (px1 - px0) >> res->pdx;
        }
#line 488
        res->pw = tmp;
#line 489
        if (ry0 == ry1) {
#line 489
          tmp___0 = 0;
        } else {
#line 489
          tmp___0 = (py1 - py0) >> res->pdy;
        }
#line 489
        res->ph = tmp___0;
#line 491
        if (res->pw * res->ph > maxprec) {
#line 492
          maxprec = res->pw * res->ph;
        }
#line 467
        resno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 444
      compno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 498
    tccp = tcp->tccps + 0;
#line 499
    (pi + pino)->step_p = 1;
#line 500
    (pi + pino)->step_c = maxprec * (pi + pino)->step_p;
#line 501
    (pi + pino)->step_r = image->numcomps * (pi + pino)->step_c;
#line 502
    (pi + pino)->step_l = maxres * (pi + pino)->step_r;
#line 504
    if (pino == 0) {
      {
#line 505
      __cil_tmp52 = calloc((unsigned long )(((image->numcomps * maxres) * tcp->numlayers) * maxprec),
                           sizeof(short ));
#line 505
      (pi + pino)->include = (short *)__cil_tmp52;
      }
#line 506
      if (! (pi + pino)->include) {
        {
#line 508
        pi_destroy(pi, cp, tileno);
        }
#line 509
        return ((opj_pi_iterator_t *)((void *)0));
      }
    } else {
#line 513
      (pi + pino)->include = (pi + (pino - 1))->include;
    }
#line 516
    if (tcp->POC == 0) {
#line 517
      (pi + pino)->first = 1;
#line 518
      (pi + pino)->poc.resno0 = 0;
#line 519
      (pi + pino)->poc.compno0 = 0;
#line 520
      (pi + pino)->poc.layno1 = tcp->numlayers;
#line 521
      (pi + pino)->poc.resno1 = maxres;
#line 522
      (pi + pino)->poc.compno1 = image->numcomps;
#line 523
      (pi + pino)->poc.prg = tcp->prg;
    } else {
#line 525
      (pi + pino)->first = 1;
#line 526
      (pi + pino)->poc.resno0 = tcp->pocs[pino].resno0;
#line 527
      (pi + pino)->poc.compno0 = tcp->pocs[pino].compno0;
#line 528
      (pi + pino)->poc.layno1 = tcp->pocs[pino].layno1;
#line 529
      (pi + pino)->poc.resno1 = tcp->pocs[pino].resno1;
#line 530
      (pi + pino)->poc.compno1 = tcp->pocs[pino].compno1;
#line 531
      (pi + pino)->poc.prg = tcp->pocs[pino].prg;
    }
#line 533
    (pi + pino)->poc.layno0 = 0;
#line 534
    (pi + pino)->poc.precno0 = 0;
#line 535
    (pi + pino)->poc.precno1 = maxprec;
#line 425
    pino ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 539
  return (pi);
}
}
#line 543 "/root/patchweave_new/2/libopenjpeg/pi.c"
opj_pi_iterator_t *pi_initialise_encode(opj_image_t *image , opj_cp_t *cp , int tileno ,
                                        J2K_T2_MODE t2_mode ) 
{ 
  int p ;
  int q ;
  int pino ;
  int compno ;
  int resno ;
  int maxres ;
  int maxprec ;
  opj_pi_iterator_t *pi ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  void *__cil_tmp15 ;
  void *__cil_tmp20 ;
  int tcx0 ;
  int tcy0 ;
  int tcx1 ;
  int tcy1 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp26 ;
  int levelno ;
  int rx0 ;
  int ry0 ;
  int rx1 ;
  int ry1 ;
  int px0 ;
  int py0 ;
  int px1 ;
  int py1 ;
  opj_pi_resolution_t *res ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int tmp ;
  int tmp___0 ;
  opj_pi_comp_t *comp___0 ;
  int dx ;
  int dy ;
  opj_pi_resolution_t *res___0 ;
  int __cil_tmp57 ;
  int tmp___1 ;
  int __cil_tmp59 ;
  int tmp___2 ;
  void *__cil_tmp63 ;
  int tmp___3 ;

  {
  {
#line 546
  maxres = 0;
#line 547
  maxprec = 0;
#line 548
  pi = (opj_pi_iterator_t *)((void *)0);
#line 549
  tcp = (opj_tcp_t *)((void *)0);
#line 550
  tccp = (opj_tccp_t *)((void *)0);
#line 552
  tcp = cp->tcps + tileno;
#line 554
  __cil_tmp15 = calloc((unsigned long )(tcp->numpocs + 1), sizeof(opj_pi_iterator_t ));
#line 554
  pi = (opj_pi_iterator_t *)__cil_tmp15;
  }
#line 555
  if (! pi) {
#line 555
    return ((opj_pi_iterator_t *)((void *)0));
  }
#line 556
  pi->tp_on = cp->tp_on;
#line 558
  pino = 0;
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;

#line 558
    if (! (pino < tcp->numpocs + 1)) {
#line 558
      goto while_break;
    }
    {
#line 559
    p = tileno % cp->tw;
#line 560
    q = tileno / cp->tw;
#line 562
    (pi + pino)->tx0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 563
    (pi + pino)->ty0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 564
    (pi + pino)->tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 565
    (pi + pino)->ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 566
    (pi + pino)->numcomps = image->numcomps;
#line 568
    __cil_tmp20 = calloc((unsigned long )image->numcomps, sizeof(opj_pi_comp_t ));
#line 568
    (pi + pino)->comps = (opj_pi_comp_t *)__cil_tmp20;
    }
#line 569
    if (! (pi + pino)->comps) {
      {
#line 570
      pi_destroy(pi, cp, tileno);
      }
#line 571
      return ((opj_pi_iterator_t *)((void *)0));
    }
#line 574
    compno = 0;
    {
#line 574
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 574
      if (! (compno < (pi + pino)->numcomps)) {
#line 574
        goto while_break___0;
      }
      {
#line 576
      comp = (pi + pino)->comps + compno;
#line 577
      tccp = tcp->tccps + compno;
#line 578
      comp->dx = (image->comps + compno)->dx;
#line 579
      comp->dy = (image->comps + compno)->dy;
#line 580
      comp->numresolutions = tccp->numresolutions;
#line 582
      __cil_tmp26 = malloc((unsigned long )comp->numresolutions * sizeof(opj_pi_resolution_t ));
#line 582
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp26;
      }
#line 583
      if (! comp->resolutions) {
        {
#line 584
        pi_destroy(pi, cp, tileno);
        }
#line 585
        return ((opj_pi_iterator_t *)((void *)0));
      }
      {
#line 588
      tcx0 = int_ceildiv((pi + pino)->tx0, comp->dx);
#line 589
      tcy0 = int_ceildiv((pi + pino)->ty0, comp->dy);
#line 590
      tcx1 = int_ceildiv((pi + pino)->tx1, comp->dx);
#line 591
      tcy1 = int_ceildiv((pi + pino)->ty1, comp->dy);
      }
#line 592
      if (comp->numresolutions > maxres) {
#line 593
        maxres = comp->numresolutions;
      }
#line 596
      resno = 0;
      {
#line 596
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 596
        if (! (resno < comp->numresolutions)) {
#line 596
          goto while_break___1;
        }
#line 600
        res = comp->resolutions + resno;
#line 601
        if (tccp->csty & 1) {
#line 602
          res->pdx = tccp->prcw[resno];
#line 603
          res->pdy = tccp->prch[resno];
        } else {
#line 605
          res->pdx = 15;
#line 606
          res->pdy = 15;
        }
        {
#line 608
        levelno = (comp->numresolutions - 1) - resno;
#line 609
        rx0 = int_ceildivpow2(tcx0, levelno);
#line 610
        ry0 = int_ceildivpow2(tcy0, levelno);
#line 611
        rx1 = int_ceildivpow2(tcx1, levelno);
#line 612
        ry1 = int_ceildivpow2(tcy1, levelno);
#line 613
        __cil_tmp45 = int_floordivpow2(rx0, res->pdx);
#line 613
        px0 = __cil_tmp45 << res->pdx;
#line 614
        __cil_tmp46 = int_floordivpow2(ry0, res->pdy);
#line 614
        py0 = __cil_tmp46 << res->pdy;
#line 615
        __cil_tmp47 = int_ceildivpow2(rx1, res->pdx);
#line 615
        px1 = __cil_tmp47 << res->pdx;
#line 616
        __cil_tmp48 = int_ceildivpow2(ry1, res->pdy);
#line 616
        py1 = __cil_tmp48 << res->pdy;
        }
#line 617
        if (rx0 == rx1) {
#line 617
          tmp = 0;
        } else {
#line 617
          tmp = (px1 - px0) >> res->pdx;
        }
#line 617
        res->pw = tmp;
#line 618
        if (ry0 == ry1) {
#line 618
          tmp___0 = 0;
        } else {
#line 618
          tmp___0 = (py1 - py0) >> res->pdy;
        }
#line 618
        res->ph = tmp___0;
#line 620
        if (res->pw * res->ph > maxprec) {
#line 621
          maxprec = res->pw * res->ph;
        }
#line 596
        resno ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
#line 574
      compno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 626
    tccp = tcp->tccps + 0;
#line 627
    (pi + pino)->step_p = 1;
#line 628
    (pi + pino)->step_c = maxprec * (pi + pino)->step_p;
#line 629
    (pi + pino)->step_r = image->numcomps * (pi + pino)->step_c;
#line 630
    (pi + pino)->step_l = maxres * (pi + pino)->step_r;
#line 632
    compno = 0;
    {
#line 632
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 632
      if (! (compno < pi->numcomps)) {
#line 632
        goto while_break___2;
      }
#line 633
      comp___0 = pi->comps + compno;
#line 634
      resno = 0;
      {
#line 634
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 634
        if (! (resno < comp___0->numresolutions)) {
#line 634
          goto while_break___3;
        }
#line 636
        res___0 = comp___0->resolutions + resno;
#line 637
        dx = comp___0->dx * (1 << (((res___0->pdx + comp___0->numresolutions) - 1) - resno));
#line 638
        dy = comp___0->dy * (1 << (((res___0->pdy + comp___0->numresolutions) - 1) - resno));
#line 639
        if (! pi->dx) {
#line 639
          tmp___1 = dx;
        } else {
          {
#line 639
          __cil_tmp57 = int_min(pi->dx, dx);
#line 639
          tmp___1 = __cil_tmp57;
          }
        }
#line 639
        (pi + pino)->dx = tmp___1;
#line 640
        if (! pi->dy) {
#line 640
          tmp___2 = dy;
        } else {
          {
#line 640
          __cil_tmp59 = int_min(pi->dy, dy);
#line 640
          tmp___2 = __cil_tmp59;
          }
        }
#line 640
        (pi + pino)->dy = tmp___2;
#line 634
        resno ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 632
      compno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: ;
#line 644
    if (pino == 0) {
      {
#line 645
      __cil_tmp63 = calloc((unsigned long )(tcp->numlayers * (pi + pino)->step_l),
                           sizeof(short ));
#line 645
      (pi + pino)->include = (short *)__cil_tmp63;
      }
#line 646
      if (! (pi + pino)->include) {
        {
#line 647
        pi_destroy(pi, cp, tileno);
        }
#line 648
        return ((opj_pi_iterator_t *)((void *)0));
      }
    } else {
#line 652
      (pi + pino)->include = (pi + (pino - 1))->include;
    }
#line 656
    if (tcp->POC) {
#line 656
      if ((unsigned int )cp->cinema) {
        _L___10: 
#line 657
        tcp->pocs[pino].compS = tcp->pocs[pino].compno0;
#line 658
        tcp->pocs[pino].compE = tcp->pocs[pino].compno1;
#line 659
        tcp->pocs[pino].resS = tcp->pocs[pino].resno0;
#line 660
        tcp->pocs[pino].resE = tcp->pocs[pino].resno1;
#line 661
        tcp->pocs[pino].layE = tcp->pocs[pino].layno1;
#line 662
        tcp->pocs[pino].prg = tcp->pocs[pino].prg1;
#line 663
        if (pino > 0) {
#line 664
          if (tcp->pocs[pino].layE > tcp->pocs[pino - 1].layE) {
#line 664
            tmp___3 = tcp->pocs[pino - 1].layE;
          } else {
#line 664
            tmp___3 = 0;
          }
#line 664
          tcp->pocs[pino].layS = tmp___3;
        }
      } else
#line 656
      if (! cp->cinema) {
#line 656
        if ((unsigned int )t2_mode == 1U) {
#line 656
          goto _L___10;
        } else {
#line 656
          goto _L;
        }
      } else {
#line 656
        goto _L;
      }
    } else {
      _L: 
#line 666
      tcp->pocs[pino].compS = 0;
#line 667
      tcp->pocs[pino].compE = image->numcomps;
#line 668
      tcp->pocs[pino].resS = 0;
#line 669
      tcp->pocs[pino].resE = maxres;
#line 670
      tcp->pocs[pino].layS = 0;
#line 671
      tcp->pocs[pino].layE = tcp->numlayers;
#line 672
      tcp->pocs[pino].prg = tcp->prg;
    }
#line 674
    tcp->pocs[pino].prcS = 0;
#line 675
    tcp->pocs[pino].prcE = maxprec;
#line 676
    tcp->pocs[pino].txS = (pi + pino)->tx0;
#line 677
    tcp->pocs[pino].txE = (pi + pino)->tx1;
#line 678
    tcp->pocs[pino].tyS = (pi + pino)->ty0;
#line 679
    tcp->pocs[pino].tyE = (pi + pino)->ty1;
#line 680
    tcp->pocs[pino].dx = (pi + pino)->dx;
#line 681
    tcp->pocs[pino].dy = (pi + pino)->dy;
#line 558
    pino ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 683
  return (pi);
}
}
#line 688 "/root/patchweave_new/2/libopenjpeg/pi.c"
void pi_destroy(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno ) 
{ 
  int compno ;
  int pino ;
  opj_tcp_t *tcp ;
  opj_pi_comp_t *comp ;

  {
#line 690
  tcp = cp->tcps + tileno;
#line 691
  if (pi) {
#line 692
    pino = 0;
    {
#line 692
    while (1) {
      while_continue: /* CIL Label */ ;

#line 692
      if (! (pino < tcp->numpocs + 1)) {
#line 692
        goto while_break;
      }
#line 693
      if ((pi + pino)->comps) {
#line 694
        compno = 0;
        {
#line 694
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 694
          if (! (compno < pi->numcomps)) {
#line 694
            goto while_break___0;
          }
#line 695
          comp = (pi + pino)->comps + compno;
#line 696
          if (comp->resolutions) {
            {
#line 697
            free((void *)comp->resolutions);
            }
          }
#line 694
          compno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: 
        {
#line 700
        free((void *)(pi + pino)->comps);
        }
      }
#line 692
      pino ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
#line 703
    if (pi->include) {
      {
#line 704
      free((void *)pi->include);
      }
    }
    {
#line 706
    free((void *)pi);
    }
  }
#line 709
  return;
}
}
#line 710 "/root/patchweave_new/2/libopenjpeg/pi.c"
opj_bool pi_next(opj_pi_iterator_t *pi ) 
{ 
  opj_bool __cil_tmp2 ;
  opj_bool __cil_tmp3 ;
  opj_bool __cil_tmp4 ;
  opj_bool __cil_tmp5 ;
  opj_bool __cil_tmp6 ;

  {
#line 712
  if ((int )pi->poc.prg == 0) {
#line 712
    goto case_0;
  }
#line 714
  if ((int )pi->poc.prg == 1) {
#line 714
    goto case_1;
  }
#line 716
  if ((int )pi->poc.prg == 2) {
#line 716
    goto case_2;
  }
#line 718
  if ((int )pi->poc.prg == 3) {
#line 718
    goto case_3;
  }
#line 720
  if ((int )pi->poc.prg == 4) {
#line 720
    goto case_4;
  }
#line 722
  if ((int )pi->poc.prg == -1) {
#line 722
    goto case_neg_1;
  }
#line 711
  goto switch_break;
  case_0: 
  {
#line 713
  __cil_tmp2 = pi_next_lrcp(pi);
  }
#line 713
  return (__cil_tmp2);
  case_1: 
  {
#line 715
  __cil_tmp3 = pi_next_rlcp(pi);
  }
#line 715
  return (__cil_tmp3);
  case_2: 
  {
#line 717
  __cil_tmp4 = pi_next_rpcl(pi);
  }
#line 717
  return (__cil_tmp4);
  case_3: 
  {
#line 719
  __cil_tmp5 = pi_next_pcrl(pi);
  }
#line 719
  return (__cil_tmp5);
  case_4: 
  {
#line 721
  __cil_tmp6 = pi_next_cprl(pi);
  }
#line 721
  return (__cil_tmp6);
  case_neg_1: 
#line 723
  return (0);
  switch_break: ;
#line 726
  return (0);
}
}
#line 729 "/root/patchweave_new/2/libopenjpeg/pi.c"
opj_bool pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno , int pino ,
                          int tpnum , int tppos , J2K_T2_MODE t2_mode , int cur_totnum_tp ) 
{ 
  char prog[4] ;
  int i ;
  int incr_top ;
  int resetX ;
  opj_tcp_t *tcps ;
  opj_poc_t *tcp ;
  int __cil_tmp15 ;

  {
#line 732
  incr_top = 1;
#line 732
  resetX = 0;
#line 733
  tcps = cp->tcps + tileno;
#line 734
  tcp = & tcps->pocs[pino];
#line 736
  (pi + pino)->first = 1;
#line 737
  (pi + pino)->poc.prg = tcp->prg;
#line 740
  if ((int )tcp->prg == 4) {
#line 740
    goto case_4;
  }
#line 742
  if ((int )tcp->prg == 0) {
#line 742
    goto case_0;
  }
#line 744
  if ((int )tcp->prg == 3) {
#line 744
    goto case_3;
  }
#line 746
  if ((int )tcp->prg == 1) {
#line 746
    goto case_1;
  }
#line 748
  if ((int )tcp->prg == 2) {
#line 748
    goto case_2;
  }
#line 750
  if ((int )tcp->prg == -1) {
#line 750
    goto case_neg_1;
  }
#line 739
  goto switch_break;
  case_4: 
  {
#line 740
  strncpy(prog, "CPRL\312U", 4UL);
  }
#line 741
  goto switch_break;
  case_0: 
  {
#line 742
  strncpy(prog, "LRCP", 4UL);
  }
#line 743
  goto switch_break;
  case_3: 
  {
#line 744
  strncpy(prog, "PCRL", 4UL);
  }
#line 745
  goto switch_break;
  case_1: 
  {
#line 746
  strncpy(prog, "RLCP\312U", 4UL);
  }
#line 747
  goto switch_break;
  case_2: 
  {
#line 748
  strncpy(prog, "RPCL", 4UL);
  }
#line 749
  goto switch_break;
  case_neg_1: 
#line 751
  return (1);
  switch_break: ;
#line 754
  if ((int )cp->tp_on) {
#line 754
    if (! cp->cinema) {
#line 754
      if ((unsigned int )t2_mode == 1U) {
#line 754
        goto _L___12;
      } else {
#line 754
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
#line 754
    if ((unsigned int )cp->cinema) {
      _L___12: /* CIL Label */ 
#line 768
      if (tpnum < cur_totnum_tp) {
#line 769
        i = 3;
        {
#line 769
        while (1) {
          while_continue: /* CIL Label */ ;

#line 769
          if (! (i >= 0)) {
#line 769
            goto while_break;
          }
#line 771
          if ((int )prog[i] == 67) {
#line 771
            goto case_67;
          }
#line 803
          if ((int )prog[i] == 82) {
#line 803
            goto case_82;
          }
#line 835
          if ((int )prog[i] == 76) {
#line 835
            goto case_76;
          }
#line 867
          if ((int )prog[i] == 80) {
#line 867
            goto case_80;
          }
#line 870
          if ((int )prog[i] == 1) {
#line 870
            goto case_1___0;
          }
#line 870
          if ((int )prog[i] == 0) {
#line 870
            goto case_1___0;
          }
#line 901
          goto switch_default;
          case_67: 
#line 772
          if (i > tppos) {
#line 773
            (pi + pino)->poc.compno0 = tcp->compS;
#line 774
            (pi + pino)->poc.compno1 = tcp->compE;
          } else
#line 776
          if (tpnum == 0) {
#line 777
            tcp->comp_t = tcp->compS;
#line 778
            (pi + pino)->poc.compno0 = tcp->comp_t;
#line 779
            (pi + pino)->poc.compno1 = tcp->comp_t + 1;
#line 780
            (tcp->comp_t) ++;
          } else
#line 782
          if (incr_top == 1) {
#line 783
            if (tcp->comp_t == tcp->compE) {
#line 784
              tcp->comp_t = tcp->compS;
#line 785
              (pi + pino)->poc.compno0 = tcp->comp_t;
#line 786
              (pi + pino)->poc.compno1 = tcp->comp_t + 1;
#line 787
              (tcp->comp_t) ++;
#line 788
              incr_top = 1;
            } else {
#line 790
              (pi + pino)->poc.compno0 = tcp->comp_t;
#line 791
              (pi + pino)->poc.compno1 = tcp->comp_t + 1;
#line 792
              (tcp->comp_t) ++;
#line 793
              incr_top = 0;
            }
          } else {
#line 796
            (pi + pino)->poc.compno0 = tcp->comp_t - 1;
#line 797
            (pi + pino)->poc.compno1 = tcp->comp_t;
          }
#line 801
          goto switch_break___0;
          case_82: 
#line 804
          if (i > tppos) {
#line 805
            (pi + pino)->poc.resno0 = tcp->resS;
#line 806
            (pi + pino)->poc.resno1 = tcp->resE;
          } else
#line 808
          if (tpnum == 0) {
#line 809
            tcp->res_t = tcp->resS;
#line 810
            (pi + pino)->poc.resno0 = tcp->res_t;
#line 811
            (pi + pino)->poc.resno1 = tcp->res_t + 1;
#line 812
            (tcp->res_t) ++;
          } else
#line 814
          if (incr_top == 1) {
#line 815
            if (tcp->res_t == tcp->resE) {
#line 816
              tcp->res_t = tcp->resS;
#line 817
              (pi + pino)->poc.resno0 = tcp->res_t;
#line 818
              (pi + pino)->poc.resno1 = tcp->res_t + 1;
#line 819
              (tcp->res_t) ++;
#line 820
              incr_top = 1;
            } else {
#line 822
              (pi + pino)->poc.resno0 = tcp->res_t;
#line 823
              (pi + pino)->poc.resno1 = tcp->res_t + 1;
#line 824
              (tcp->res_t) ++;
#line 825
              incr_top = 0;
            }
          } else {
#line 828
            (pi + pino)->poc.resno0 = tcp->res_t - 1;
#line 829
            (pi + pino)->poc.resno1 = tcp->res_t;
          }
#line 833
          goto switch_break___0;
          case_76: 
#line 836
          if (i > tppos) {
#line 837
            (pi + pino)->poc.layno0 = tcp->layS;
#line 838
            (pi + pino)->poc.layno1 = tcp->layE;
          } else
#line 840
          if (tpnum == 0) {
#line 841
            tcp->lay_t = tcp->layS;
#line 842
            (pi + pino)->poc.layno0 = tcp->lay_t;
#line 843
            (pi + pino)->poc.layno1 = tcp->lay_t + 1;
#line 844
            (tcp->lay_t) ++;
          } else
#line 846
          if (incr_top == 1) {
#line 847
            if (tcp->lay_t == tcp->layE) {
#line 848
              tcp->lay_t = tcp->layS;
#line 849
              (pi + pino)->poc.layno0 = tcp->lay_t;
#line 850
              (pi + pino)->poc.layno1 = tcp->lay_t + 1;
#line 851
              (tcp->lay_t) ++;
#line 852
              incr_top = 1;
            } else {
#line 854
              (pi + pino)->poc.layno0 = tcp->lay_t;
#line 855
              (pi + pino)->poc.layno1 = tcp->lay_t + 1;
#line 856
              (tcp->lay_t) ++;
#line 857
              incr_top = 0;
            }
          } else {
#line 860
            (pi + pino)->poc.layno0 = tcp->lay_t - 1;
#line 861
            (pi + pino)->poc.layno1 = tcp->lay_t;
          }
#line 865
          goto switch_break___0;
          case_80: 
#line 870
          if ((int )tcp->prg == 1) {
#line 870
            goto case_1___0;
          }
#line 870
          if ((int )tcp->prg == 0) {
#line 870
            goto case_1___0;
          }
#line 901
          goto switch_default;
          case_1___0: 
#line 871
          if (i > tppos) {
#line 872
            (pi + pino)->poc.precno0 = tcp->prcS;
#line 873
            (pi + pino)->poc.precno1 = tcp->prcE;
          } else
#line 875
          if (tpnum == 0) {
#line 876
            tcp->prc_t = tcp->prcS;
#line 877
            (pi + pino)->poc.precno0 = tcp->prc_t;
#line 878
            (pi + pino)->poc.precno1 = tcp->prc_t + 1;
#line 879
            (tcp->prc_t) ++;
          } else
#line 881
          if (incr_top == 1) {
#line 882
            if (tcp->prc_t == tcp->prcE) {
#line 883
              tcp->prc_t = tcp->prcS;
#line 884
              (pi + pino)->poc.precno0 = tcp->prc_t;
#line 885
              (pi + pino)->poc.precno1 = tcp->prc_t + 1;
#line 886
              (tcp->prc_t) ++;
#line 887
              incr_top = 1;
            } else {
#line 889
              (pi + pino)->poc.precno0 = tcp->prc_t;
#line 890
              (pi + pino)->poc.precno1 = tcp->prc_t + 1;
#line 891
              (tcp->prc_t) ++;
#line 892
              incr_top = 0;
            }
          } else {
#line 895
            (pi + pino)->poc.precno0 = tcp->prc_t - 1;
#line 896
            (pi + pino)->poc.precno1 = tcp->prc_t;
          }
#line 900
          goto switch_break___1;
          switch_default: 
#line 902
          if (i > tppos) {
#line 903
            (pi + pino)->poc.tx0 = tcp->txS;
#line 904
            (pi + pino)->poc.ty0 = tcp->tyS;
#line 905
            (pi + pino)->poc.tx1 = tcp->txE;
#line 906
            (pi + pino)->poc.ty1 = tcp->tyE;
          } else
#line 908
          if (tpnum == 0) {
#line 909
            tcp->tx0_t = tcp->txS;
#line 910
            tcp->ty0_t = tcp->tyS;
#line 911
            (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 912
            (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 913
            (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 914
            (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 915
            tcp->tx0_t = (pi + pino)->poc.tx1;
#line 916
            tcp->ty0_t = (pi + pino)->poc.ty1;
          } else
#line 918
          if (incr_top == 1) {
#line 919
            if (tcp->tx0_t >= tcp->txE) {
#line 920
              if (tcp->ty0_t >= tcp->tyE) {
#line 921
                tcp->ty0_t = tcp->tyS;
#line 922
                (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 923
                (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 924
                tcp->ty0_t = (pi + pino)->poc.ty1;
#line 925
                incr_top = 1;
#line 925
                resetX = 1;
              } else {
#line 927
                (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 928
                (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 929
                tcp->ty0_t = (pi + pino)->poc.ty1;
#line 930
                incr_top = 0;
#line 930
                resetX = 1;
              }
#line 932
              if (resetX == 1) {
#line 933
                tcp->tx0_t = tcp->txS;
#line 934
                (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 935
                (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 936
                tcp->tx0_t = (pi + pino)->poc.tx1;
              }
            } else {
#line 939
              (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 940
              (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 941
              tcp->tx0_t = (pi + pino)->poc.tx1;
#line 942
              (pi + pino)->poc.ty0 = (tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy;
#line 943
              (pi + pino)->poc.ty1 = tcp->ty0_t;
#line 944
              incr_top = 0;
            }
          } else {
#line 947
            (pi + pino)->poc.tx0 = (tcp->tx0_t - tcp->dx) - tcp->tx0_t % tcp->dx;
#line 948
            (pi + pino)->poc.tx1 = tcp->tx0_t;
#line 949
            (pi + pino)->poc.ty0 = (tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy;
#line 950
            (pi + pino)->poc.ty1 = tcp->ty0_t;
          }
#line 954
          goto switch_break___1;
          switch_break___1: ;
#line 956
          goto switch_break___0;
          switch_break___0: 
#line 769
          __cil_tmp15 = i;
#line 769
          i --;
        }
        while_break___0: /* CIL Label */ ;
        }
        while_break: ;
      }
    } else {
#line 754
      goto _L___11;
    }
  } else {
    _L___11: /* CIL Label */ 
#line 755
    (pi + pino)->poc.resno0 = tcp->resS;
#line 756
    (pi + pino)->poc.resno1 = tcp->resE;
#line 757
    (pi + pino)->poc.compno0 = tcp->compS;
#line 758
    (pi + pino)->poc.compno1 = tcp->compE;
#line 759
    (pi + pino)->poc.layno0 = tcp->layS;
#line 760
    (pi + pino)->poc.layno1 = tcp->layE;
#line 761
    (pi + pino)->poc.precno0 = tcp->prcS;
#line 762
    (pi + pino)->poc.precno1 = tcp->prcE;
#line 763
    (pi + pino)->poc.tx0 = tcp->txS;
#line 764
    (pi + pino)->poc.ty0 = tcp->tyS;
#line 765
    (pi + pino)->poc.tx1 = tcp->txE;
#line 766
    (pi + pino)->poc.ty1 = tcp->tyE;
  }
#line 961
  return (0);
}
}
#line 51 "/root/patchweave_new/2/libopenjpeg/phix_manager.c"
int write_phixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) ;
#line 53 "/root/patchweave_new/2/libopenjpeg/phix_manager.c"
int write_phix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int compno ;
  int i ;
  opj_jp2_box_t *box ;
  void *__cil_tmp11 ;
  int __cil_tmp15 ;

  {
  {
#line 55
  lenp = 0;
#line 58
  __cil_tmp11 = calloc((unsigned long )cstr_info.numcomps, sizeof(opj_jp2_box_t ));
#line 58
  box = (opj_jp2_box_t *)__cil_tmp11;
#line 60
  i = 0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;

#line 60
    if (! (i < 2)) {
#line 60
      goto while_break;
    }
#line 61
    if (i) {
      {
#line 61
      cio_seek(cio, lenp);
      }
    }
    {
#line 63
    lenp = cio_tell(cio);
#line 64
    cio_skip(cio, 4);
#line 65
    cio_write(cio, 1885890936ULL, 4);
#line 67
    write_manf(i, cstr_info.numcomps, box, cio);
#line 69
    compno = 0;
    }
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 69
      if (! (compno < cstr_info.numcomps)) {
#line 69
        goto while_break___0;
      }
      {
#line 70
      (box + compno)->length = write_phixfaix(coff, compno, cstr_info, EPHused, j2klen,
                                              cio);
#line 71
      (box + compno)->type = 1717660024;
#line 69
      compno ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 74
    __cil_tmp15 = cio_tell(cio);
#line 74
    len = __cil_tmp15 - lenp;
#line 75
    cio_seek(cio, lenp);
#line 76
    cio_write(cio, (unsigned long long )len, 4);
#line 77
    cio_seek(cio, lenp + len);
#line 60
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 80
  free((void *)box);
  }
#line 82
  return (len);
}
}
#line 85 "/root/patchweave_new/2/libopenjpeg/phix_manager.c"
int write_phixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int tileno ;
  int version ;
  int i ;
  int nmax ;
  int size_of_coding ;
  opj_tile_info_t *tile_Idx ;
  opj_packet_info_t packet ;
  int resno ;
  int precno ;
  int layno ;
  int num_packet ;
  int numOfres ;
  int numOfprec ;
  int numOflayers ;
  double __cil_tmp23 ;
  int __cil_tmp32 ;

  {
  {
#line 92
  packet.start_pos = -1;
#line 92
  packet.end_ph_pos = packet.start_pos;
#line 95
  __cil_tmp23 = pow((double )2, (double )32);
  }
#line 95
  if ((double )j2klen > __cil_tmp23) {
#line 96
    size_of_coding = 8;
#line 97
    version = 1;
  } else {
#line 100
    size_of_coding = 4;
#line 101
    version = 0;
  }
  {
#line 104
  lenp = cio_tell(cio);
#line 105
  cio_skip(cio, 4);
#line 106
  cio_write(cio, 1717660024ULL, 4);
#line 107
  cio_write(cio, (unsigned long long )version, 1);
#line 109
  nmax = 0;
#line 110
  i = 0;
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;

#line 110
    if (! (i <= *(cstr_info.numdecompos + compno))) {
#line 110
      goto while_break;
    }
#line 111
    nmax += ((cstr_info.tile + 0)->ph[i] * (cstr_info.tile + 0)->pw[i]) * cstr_info.numlayers;
#line 110
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
  {
#line 113
  cio_write(cio, (unsigned long long )nmax, size_of_coding);
#line 114
  cio_write(cio, (unsigned long long )(cstr_info.tw * cstr_info.th), size_of_coding);
#line 116
  tileno = 0;
  }
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 116
    if (! (tileno < cstr_info.tw * cstr_info.th)) {
#line 116
      goto while_break___0;
    }
#line 117
    tile_Idx = cstr_info.tile + tileno;
#line 119
    num_packet = 0;
#line 120
    numOfres = *(cstr_info.numdecompos + compno) + 1;
#line 122
    resno = 0;
    {
#line 122
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 122
      if (! (resno < numOfres)) {
#line 122
        goto while_break___1;
      }
#line 123
      numOfprec = tile_Idx->pw[resno] * tile_Idx->ph[resno];
#line 124
      precno = 0;
      {
#line 124
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 124
        if (! (precno < numOfprec)) {
#line 124
          goto while_break___2;
        }
#line 125
        numOflayers = cstr_info.numlayers;
#line 126
        layno = 0;
        {
#line 126
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 126
          if (! (layno < numOflayers)) {
#line 126
            goto while_break___3;
          }
#line 129
          if ((int )cstr_info.prog == 0) {
#line 129
            goto case_0;
          }
#line 132
          if ((int )cstr_info.prog == 1) {
#line 132
            goto case_1;
          }
#line 135
          if ((int )cstr_info.prog == 2) {
#line 135
            goto case_2;
          }
#line 138
          if ((int )cstr_info.prog == 3) {
#line 138
            goto case_3;
          }
#line 141
          if ((int )cstr_info.prog == 4) {
#line 141
            goto case_4;
          }
#line 144
          goto switch_default;
          case_0: 
#line 130
          packet = *(tile_Idx->packet + (((layno * numOfres + resno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 131
          goto switch_break;
          case_1: 
#line 133
          packet = *(tile_Idx->packet + (((resno * numOflayers + layno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 134
          goto switch_break;
          case_2: 
#line 136
          packet = *(tile_Idx->packet + (((resno * numOfprec + precno) * cstr_info.numcomps + compno) * numOflayers + layno));
#line 137
          goto switch_break;
          case_3: 
#line 139
          packet = *(tile_Idx->packet + (((precno * cstr_info.numcomps + compno) * numOfres + resno) * numOflayers + layno));
#line 140
          goto switch_break;
          case_4: 
#line 142
          packet = *(tile_Idx->packet + (((compno * numOfprec + precno) * numOfres + resno) * numOflayers + layno));
#line 143
          goto switch_break;
          switch_default: 
          {
#line 145
          fprintf(stderr, "failed to ppix indexing\n\220");
          }
          switch_break: 
          {
#line 148
          cio_write(cio, (unsigned long long )(packet.start_pos - coff), size_of_coding);
#line 149
          cio_write(cio, (unsigned long long )((packet.end_ph_pos - packet.start_pos) + 1),
                    size_of_coding);
#line 151
          num_packet ++;
#line 126
          layno ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: 
#line 124
        precno ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: 
#line 122
      resno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: ;
    {
#line 157
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 157
      if (! (num_packet < nmax)) {
#line 157
        goto while_break___4;
      }
      {
#line 158
      cio_write(cio, 0ULL, size_of_coding);
#line 159
      cio_write(cio, 0ULL, size_of_coding);
#line 160
      num_packet ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: 
#line 116
    tileno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 164
  __cil_tmp32 = cio_tell(cio);
#line 164
  len = __cil_tmp32 - lenp;
#line 165
  cio_seek(cio, lenp);
#line 166
  cio_write(cio, (unsigned long long )len, 4);
#line 167
  cio_seek(cio, lenp + len);
  }
#line 169
  return (len);
}
}
#line 61 "/root/patchweave_new/2/libopenjpeg/openjpeg.c"
char const   *opj_version(void) 
{ 


  {
#line 62
  return ("1.5.2");
}
}
#line 65 "/root/patchweave_new/2/libopenjpeg/openjpeg.c"
opj_dinfo_t *opj_create_decompress(OPJ_CODEC_FORMAT format ) 
{ 
  opj_dinfo_t *dinfo ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_jp2_t *__cil_tmp5 ;

  {
  {
#line 66
  __cil_tmp3 = calloc(1UL, sizeof(opj_dinfo_t ));
#line 66
  dinfo = (opj_dinfo_t *)__cil_tmp3;
  }
#line 67
  if (! dinfo) {
#line 67
    return ((opj_dinfo_t *)((void *)0));
  }
#line 68
  dinfo->is_decompressor = 1;
#line 71
  if ((int )format == 1) {
#line 71
    goto case_1;
  }
#line 71
  if ((int )format == 0) {
#line 71
    goto case_1;
  }
#line 79
  if ((int )format == 2) {
#line 79
    goto case_2;
  }
#line 88
  goto switch_default;
  case_1: 
  {
#line 73
  __cil_tmp4 = j2k_create_decompress((opj_common_ptr )dinfo);
#line 73
  dinfo->j2k_handle = (void *)__cil_tmp4;
  }
#line 74
  if (! dinfo->j2k_handle) {
    {
#line 75
    free((void *)dinfo);
    }
#line 76
    return ((opj_dinfo_t *)((void *)0));
  }
#line 78
  goto switch_break;
  case_2: 
  {
#line 81
  __cil_tmp5 = jp2_create_decompress((opj_common_ptr )dinfo);
#line 81
  dinfo->jp2_handle = (void *)__cil_tmp5;
  }
#line 82
  if (! dinfo->jp2_handle) {
    {
#line 83
    free((void *)dinfo);
    }
#line 84
    return ((opj_dinfo_t *)((void *)0));
  }
#line 86
  goto switch_break;
  switch_default: 
  {
#line 89
  free((void *)dinfo);
  }
#line 90
  return ((opj_dinfo_t *)((void *)0));
  switch_break: 
#line 93
  dinfo->codec_format = format;
#line 95
  return (dinfo);
}
}
#line 98 "/root/patchweave_new/2/libopenjpeg/openjpeg.c"
void opj_destroy_decompress(opj_dinfo_t *dinfo ) 
{ 


  {
#line 99
  if (dinfo) {
#line 103
    if ((int )dinfo->codec_format == 1) {
#line 103
      goto case_1;
    }
#line 103
    if ((int )dinfo->codec_format == 0) {
#line 103
      goto case_1;
    }
#line 106
    if ((int )dinfo->codec_format == 2) {
#line 106
      goto case_2;
    }
#line 110
    goto switch_default;
    case_1: 
    {
#line 104
    j2k_destroy_decompress((opj_j2k_t *)dinfo->j2k_handle);
    }
#line 105
    goto switch_break;
    case_2: 
    {
#line 107
    jp2_destroy_decompress((opj_jp2_t *)dinfo->jp2_handle);
    }
#line 108
    goto switch_break;
    switch_default: 
#line 111
    goto switch_break;
    switch_break: 
    {
#line 114
    free((void *)dinfo);
    }
  }
#line 117
  return;
}
}
#line 118 "/root/patchweave_new/2/libopenjpeg/openjpeg.c"
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) 
{ 


  {
#line 119
  if (parameters) {
    {
#line 120
    memset((void *)parameters, 0, sizeof(opj_dparameters_t ));
#line 122
    parameters->cp_layer = 0;
#line 123
    parameters->cp_reduce = 0;
#line 124
    parameters->cp_limit_decoding = (OPJ_LIMIT_DECODING )0;
#line 126
    parameters->decod_format = -1;
#line 127
    parameters->cod_format = -1;
#line 128
    parameters->flags = 0U;
    }
  }
#line 131
  return;
}
}
#line 139 "/root/patchweave_new/2/libopenjpeg/openjpeg.c"
void opj_setup_decoder(opj_dinfo_t *dinfo , opj_dparameters_t *parameters ) 
{ 


  {
#line 140
  if (dinfo) {
#line 140
    if (parameters) {
#line 143
      if ((int )dinfo->codec_format == 1) {
#line 143
        goto case_1;
      }
#line 143
      if ((int )dinfo->codec_format == 0) {
#line 143
        goto case_1;
      }
#line 146
      if ((int )dinfo->codec_format == 2) {
#line 146
        goto case_2;
      }
#line 150
      goto switch_default;
      case_1: 
      {
#line 144
      j2k_setup_decoder((opj_j2k_t *)dinfo->j2k_handle, parameters);
      }
#line 145
      goto switch_break;
      case_2: 
      {
#line 147
      jp2_setup_decoder((opj_jp2_t *)dinfo->jp2_handle, parameters);
      }
#line 148
      goto switch_break;
      switch_default: 
#line 151
      goto switch_break;
      switch_break: ;
    }
  }
#line 156
  return;
}
}
#line 156 "/root/patchweave_new/2/libopenjpeg/openjpeg.c"
opj_image_t *opj_decode(opj_dinfo_t *dinfo , opj_cio_t *cio ) 
{ 
  opj_image_t *__cil_tmp3 ;

  {
  {
#line 157
  __cil_tmp3 = opj_decode_with_info(dinfo, cio, (opj_codestream_info_t *)((void *)0));
  }
#line 157
  return (__cil_tmp3);
}
}
#line 160 "/root/patchweave_new/2/libopenjpeg/openjpeg.c"
opj_image_t *opj_decode_with_info(opj_dinfo_t *dinfo , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *__cil_tmp4 ;
  opj_image_t *__cil_tmp5 ;
  opj_image_t *__cil_tmp6 ;

  {
#line 161
  if (dinfo) {
#line 161
    if (cio) {
#line 163
      if ((int )dinfo->codec_format == 0) {
#line 163
        goto case_0;
      }
#line 165
      if ((int )dinfo->codec_format == 1) {
#line 165
        goto case_1;
      }
#line 167
      if ((int )dinfo->codec_format == 2) {
#line 167
        goto case_2;
      }
#line 170
      goto switch_default;
      case_0: 
      {
#line 164
      __cil_tmp4 = j2k_decode((opj_j2k_t *)dinfo->j2k_handle, cio, cstr_info);
      }
#line 164
      return (__cil_tmp4);
      case_1: 
      {
#line 166
      __cil_tmp5 = j2k_decode_jpt_stream((opj_j2k_t *)dinfo->j2k_handle, cio, cstr_info);
      }
#line 166
      return (__cil_tmp5);
      case_2: 
      {
#line 168
      __cil_tmp6 = opj_jp2_decode((opj_jp2_t *)dinfo->jp2_handle, cio, cstr_info);
      }
#line 168
      return (__cil_tmp6);
      switch_default: 
#line 171
      goto switch_break;
      switch_break: ;
    }
  }
#line 174
  return ((opj_image_t *)((void *)0));
}
}
#line 177 "/root/patchweave_new/2/libopenjpeg/openjpeg.c"
opj_cinfo_t *opj_create_compress(OPJ_CODEC_FORMAT format ) 
{ 
  opj_cinfo_t *cinfo ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_jp2_t *__cil_tmp5 ;

  {
  {
#line 178
  __cil_tmp3 = calloc(1UL, sizeof(opj_cinfo_t ));
#line 178
  cinfo = (opj_cinfo_t *)__cil_tmp3;
  }
#line 179
  if (! cinfo) {
#line 179
    return ((opj_cinfo_t *)((void *)0));
  }
#line 180
  cinfo->is_decompressor = 0;
#line 182
  if ((int )format == 0) {
#line 182
    goto case_0;
  }
#line 190
  if ((int )format == 2) {
#line 190
    goto case_2;
  }
#line 200
  goto switch_default;
  case_0: 
  {
#line 184
  __cil_tmp4 = j2k_create_compress((opj_common_ptr )cinfo);
#line 184
  cinfo->j2k_handle = (void *)__cil_tmp4;
  }
#line 185
  if (! cinfo->j2k_handle) {
    {
#line 186
    free((void *)cinfo);
    }
#line 187
    return ((opj_cinfo_t *)((void *)0));
  }
#line 189
  goto switch_break;
  case_2: 
  {
#line 192
  __cil_tmp5 = jp2_create_compress((opj_common_ptr )cinfo);
#line 192
  cinfo->jp2_handle = (void *)__cil_tmp5;
  }
#line 193
  if (! cinfo->jp2_handle) {
    {
#line 194
    free((void *)cinfo);
    }
#line 195
    return ((opj_cinfo_t *)((void *)0));
  }
#line 197
  goto switch_break;
  switch_default: 
  {
#line 201
  free((void *)cinfo);
  }
#line 202
  return ((opj_cinfo_t *)((void *)0));
  switch_break: 
#line 205
  cinfo->codec_format = format;
#line 207
  return (cinfo);
}
}
#line 210 "/root/patchweave_new/2/libopenjpeg/openjpeg.c"
void opj_destroy_compress(opj_cinfo_t *cinfo ) 
{ 


  {
#line 211
  if (cinfo) {
#line 214
    if ((int )cinfo->codec_format == 0) {
#line 214
      goto case_0;
    }
#line 217
    if ((int )cinfo->codec_format == 2) {
#line 217
      goto case_2;
    }
#line 222
    goto switch_default;
    case_0: 
    {
#line 215
    j2k_destroy_compress((opj_j2k_t *)cinfo->j2k_handle);
    }
#line 216
    goto switch_break;
    case_2: 
    {
#line 218
    jp2_destroy_compress((opj_jp2_t *)cinfo->jp2_handle);
    }
#line 219
    goto switch_break;
    switch_default: 
#line 223
    goto switch_break;
    switch_break: 
    {
#line 226
    free((void *)cinfo);
    }
  }
#line 229
  return;
}
}
#line 230 "/root/patchweave_new/2/libopenjpeg/openjpeg.c"
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) 
{ 


  {
#line 231
  if (parameters) {
    {
#line 232
    memset((void *)parameters, 0, sizeof(opj_cparameters_t ));
#line 234
    parameters->cp_cinema = (OPJ_CINEMA_MODE )0;
#line 235
    parameters->max_comp_size = 0;
#line 236
    parameters->numresolution = 6;
#line 237
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
#line 238
    parameters->cblockw_init = 64;
#line 239
    parameters->cblockh_init = 64;
#line 240
    parameters->prog_order = (OPJ_PROG_ORDER )0;
#line 241
    parameters->roi_compno = -1;
#line 242
    parameters->subsampling_dx = 1;
#line 243
    parameters->subsampling_dy = 1;
#line 244
    parameters->tp_on = (char)0;
#line 245
    parameters->decod_format = -1;
#line 246
    parameters->cod_format = -1;
#line 247
    parameters->tcp_rates[0] = (float )0;
#line 248
    parameters->tcp_numlayers = 0;
#line 249
    parameters->cp_disto_alloc = 0;
#line 250
    parameters->cp_fixed_alloc = 0;
#line 251
    parameters->cp_fixed_quality = 0;
#line 252
    parameters->jpip_on = 0;
    }
  }
#line 255
  return;
}
}
#line 288 "/root/patchweave_new/2/libopenjpeg/openjpeg.c"
void opj_setup_encoder(opj_cinfo_t *cinfo , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 


  {
#line 289
  if (cinfo) {
#line 289
    if (parameters) {
#line 289
      if (image) {
#line 291
        if ((int )cinfo->codec_format == 0) {
#line 291
          goto case_0;
        }
#line 294
        if ((int )cinfo->codec_format == 2) {
#line 294
          goto case_2;
        }
#line 299
        goto switch_default;
        case_0: 
        {
#line 292
        j2k_setup_encoder((opj_j2k_t *)cinfo->j2k_handle, parameters, image);
        }
#line 293
        goto switch_break;
        case_2: 
        {
#line 295
        jp2_setup_encoder((opj_jp2_t *)cinfo->jp2_handle, parameters, image);
        }
#line 296
        goto switch_break;
        switch_default: 
#line 300
        goto switch_break;
        switch_break: ;
      }
    }
  }
#line 306
  return;
}
}
#line 305 "/root/patchweave_new/2/libopenjpeg/openjpeg.c"
opj_bool opj_encode(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image , char *index___0 ) 
{ 
  opj_bool __cil_tmp5 ;

  {
#line 306
  if ((unsigned long )index___0 != (unsigned long )((void *)0)) {
    {
#line 307
    opj_event_msg((opj_common_ptr )cinfo, 2, "Set index to NULL when calling the opj_encode function.\nTo extract the index, use the opj_encode_with_info() function.\nNo index will be generated during this encoding\n");
    }
  }
  {
#line 310
  __cil_tmp5 = opj_encode_with_info(cinfo, cio, image, (opj_codestream_info_t *)((void *)0));
  }
#line 310
  return (__cil_tmp5);
}
}
#line 313 "/root/patchweave_new/2/libopenjpeg/openjpeg.c"
opj_bool opj_encode_with_info(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image ,
                              opj_codestream_info_t *cstr_info ) 
{ 
  opj_bool __cil_tmp5 ;
  opj_bool __cil_tmp6 ;

  {
#line 314
  if (cinfo) {
#line 314
    if (cio) {
#line 314
      if (image) {
#line 316
        if ((int )cinfo->codec_format == 0) {
#line 316
          goto case_0;
        }
#line 318
        if ((int )cinfo->codec_format == 2) {
#line 318
          goto case_2;
        }
#line 322
        goto switch_default;
        case_0: 
        {
#line 317
        __cil_tmp5 = j2k_encode((opj_j2k_t *)cinfo->j2k_handle, cio, image, cstr_info);
        }
#line 317
        return (__cil_tmp5);
        case_2: 
        {
#line 319
        __cil_tmp6 = opj_jp2_encode((opj_jp2_t *)cinfo->jp2_handle, cio, image, cstr_info);
        }
#line 319
        return (__cil_tmp6);
        switch_default: 
#line 323
        goto switch_break;
        switch_break: ;
      }
    }
  }
#line 326
  return (0);
}
}
#line 329 "/root/patchweave_new/2/libopenjpeg/openjpeg.c"
void opj_destroy_cstr_info(opj_codestream_info_t *cstr_info ) 
{ 
  int tileno ;
  opj_tile_info_t *tile_info ;

  {
#line 330
  if (cstr_info) {
#line 332
    tileno = 0;
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;

#line 332
      if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 332
        goto while_break;
      }
      {
#line 333
      tile_info = cstr_info->tile + tileno;
#line 334
      free((void *)tile_info->thresh);
#line 335
      free((void *)tile_info->packet);
#line 336
      free((void *)tile_info->tp);
#line 337
      free((void *)tile_info->marker);
#line 332
      tileno ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 339
    free((void *)cstr_info->tile);
#line 340
    free((void *)cstr_info->marker);
#line 341
    free((void *)cstr_info->numdecompos);
    }
  }
#line 344
  return;
}
}
#line 45 "/root/patchweave_new/2/libopenjpeg/mqc.c"
static void mqc_byteout(opj_mqc_t *mqc ) ;
#line 50
static void mqc_renorme(opj_mqc_t *mqc ) ;
#line 55
static void mqc_codemps(opj_mqc_t *mqc ) ;
#line 60
static void mqc_codelps(opj_mqc_t *mqc ) ;
#line 65
static void mqc_setbits(opj_mqc_t *mqc ) ;
#line 71
__inline static int mqc_mpsexchange(opj_mqc_t *mqc ) ;
#line 77
__inline static int mqc_lpsexchange(opj_mqc_t *mqc ) ;
#line 82
static void mqc_bytein(opj_mqc_t *mqc ) ;
#line 87
__inline static void mqc_renormd(opj_mqc_t *mqc ) ;
#line 95 "/root/patchweave_new/2/libopenjpeg/mqc.c"
static opj_mqc_state_t mqc_states[94]  = 
#line 95
  {      {22017U, 0, & mqc_states[2], & mqc_states[3]}, 
        {22017U, 1, & mqc_states[3], & mqc_states[2]}, 
        {13313U, 0, & mqc_states[4], & mqc_states[12]}, 
        {13313U, 1, & mqc_states[5], & mqc_states[13]}, 
        {6145U, 0, & mqc_states[6], & mqc_states[18]}, 
        {6145U, 1, & mqc_states[7], & mqc_states[19]}, 
        {2753U, 0, & mqc_states[8], & mqc_states[24]}, 
        {2753U, 1, & mqc_states[9], & mqc_states[25]}, 
        {1313U, 0, & mqc_states[10], & mqc_states[58]}, 
        {1313U, 1, & mqc_states[11], & mqc_states[59]}, 
        {545U, 0, & mqc_states[76], & mqc_states[66]}, 
        {545U, 1, & mqc_states[77], & mqc_states[67]}, 
        {22017U, 0, & mqc_states[14], & mqc_states[13]}, 
        {22017U, 1, & mqc_states[15], & mqc_states[12]}, 
        {21505U, 0, & mqc_states[16], & mqc_states[28]}, 
        {21505U, 1, & mqc_states[17], & mqc_states[29]}, 
        {18433U, 0, & mqc_states[18], & mqc_states[28]}, 
        {18433U, 1, & mqc_states[19], & mqc_states[29]}, 
        {14337U, 0, & mqc_states[20], & mqc_states[28]}, 
        {14337U, 1, & mqc_states[21], & mqc_states[29]}, 
        {12289U, 0, & mqc_states[22], & mqc_states[34]}, 
        {12289U, 1, & mqc_states[23], & mqc_states[35]}, 
        {9217U, 0, & mqc_states[24], & mqc_states[36]}, 
        {9217U, 1, & mqc_states[25], & mqc_states[37]}, 
        {7169U, 0, & mqc_states[26], & mqc_states[40]}, 
        {7169U, 1, & mqc_states[27], & mqc_states[41]}, 
        {5633U, 0, & mqc_states[58], & mqc_states[42]}, 
        {5633U, 1, & mqc_states[59], & mqc_states[43]}, 
        {22017U, 0, & mqc_states[30], & mqc_states[29]}, 
        {22017U, 1, & mqc_states[31], & mqc_states[28]}, 
        {21505U, 0, & mqc_states[32], & mqc_states[28]}, 
        {21505U, 1, & mqc_states[33], & mqc_states[29]}, 
        {20737U, 0, & mqc_states[34], & mqc_states[30]}, 
        {20737U, 1, & mqc_states[35], & mqc_states[31]}, 
        {18433U, 0, & mqc_states[36], & mqc_states[32]}, 
        {18433U, 1, & mqc_states[37], & mqc_states[33]}, 
        {14337U, 0, & mqc_states[38], & mqc_states[34]}, 
        {14337U, 1, & mqc_states[39], & mqc_states[35]}, 
        {13313U, 0, & mqc_states[40], & mqc_states[36]}, 
        {13313U, 1, & mqc_states[41], & mqc_states[37]}, 
        {12289U, 0, & mqc_states[42], & mqc_states[38]}, 
        {12289U, 1, & mqc_states[43], & mqc_states[39]}, 
        {10241U, 0, & mqc_states[44], & mqc_states[38]}, 
        {10241U, 1, & mqc_states[45], & mqc_states[39]}, 
        {9217U, 0, & mqc_states[46], & mqc_states[40]}, 
        {9217U, 1, & mqc_states[47], & mqc_states[41]}, 
        {8705U, 0, & mqc_states[48], & mqc_states[42]}, 
        {8705U, 1, & mqc_states[49], & mqc_states[43]}, 
        {7169U, 0, & mqc_states[50], & mqc_states[44]}, 
        {7169U, 1, & mqc_states[51], & mqc_states[45]}, 
        {6145U, 0, & mqc_states[52], & mqc_states[46]}, 
        {6145U, 1, & mqc_states[53], & mqc_states[47]}, 
        {5633U, 0, & mqc_states[54], & mqc_states[48]}, 
        {5633U, 1, & mqc_states[55], & mqc_states[49]}, 
        {5121U, 0, & mqc_states[56], & mqc_states[50]}, 
        {5121U, 1, & mqc_states[57], & mqc_states[51]}, 
        {4609U, 0, & mqc_states[58], & mqc_states[52]}, 
        {4609U, 1, & mqc_states[59], & mqc_states[53]}, 
        {4353U, 0, & mqc_states[60], & mqc_states[54]}, 
        {4353U, 1, & mqc_states[61], & mqc_states[55]}, 
        {2753U, 0, & mqc_states[62], & mqc_states[56]}, 
        {2753U, 1, & mqc_states[63], & mqc_states[57]}, 
        {2497U, 0, & mqc_states[64], & mqc_states[58]}, 
        {2497U, 1, & mqc_states[65], & mqc_states[59]}, 
        {2209U, 0, & mqc_states[66], & mqc_states[60]}, 
        {2209U, 1, & mqc_states[67], & mqc_states[61]}, 
        {1313U, 0, & mqc_states[68], & mqc_states[62]}, 
        {1313U, 1, & mqc_states[69], & mqc_states[63]}, 
        {1089U, 0, & mqc_states[70], & mqc_states[64]}, 
        {1089U, 1, & mqc_states[71], & mqc_states[65]}, 
        {673U, 0, & mqc_states[72], & mqc_states[66]}, 
        {673U, 1, & mqc_states[73], & mqc_states[67]}, 
        {545U, 0, & mqc_states[74], & mqc_states[68]}, 
        {545U, 1, & mqc_states[75], & mqc_states[69]}, 
        {321U, 0, & mqc_states[76], & mqc_states[70]}, 
        {321U, 1, & mqc_states[77], & mqc_states[71]}, 
        {273U, 0, & mqc_states[78], & mqc_states[72]}, 
        {273U, 1, & mqc_states[79], & mqc_states[73]}, 
        {133U, 0, & mqc_states[80], & mqc_states[74]}, 
        {133U, 1, & mqc_states[81], & mqc_states[75]}, 
        {73U, 0, & mqc_states[82], & mqc_states[76]}, 
        {73U, 1, & mqc_states[83], & mqc_states[77]}, 
        {37U, 0, & mqc_states[84], & mqc_states[78]}, 
        {37U, 1, & mqc_states[85], & mqc_states[79]}, 
        {21U, 0, & mqc_states[86], & mqc_states[80]}, 
        {21U, 1, & mqc_states[87], & mqc_states[81]}, 
        {9U, 0, & mqc_states[88], & mqc_states[82]}, 
        {9U, 1, & mqc_states[89], & mqc_states[83]}, 
        {5U, 0, & mqc_states[90], & mqc_states[84]}, 
        {5U, 1, & mqc_states[91], & mqc_states[85]}, 
        {1U, 0, & mqc_states[90], & mqc_states[86]}, 
        {1U, 1, & mqc_states[91], & mqc_states[87]}, 
        {22017U, 0, & mqc_states[92], & mqc_states[92]}, 
        {22017U, 1, & mqc_states[93], & mqc_states[93]}};
#line 198 "/root/patchweave_new/2/libopenjpeg/mqc.c"
static void mqc_byteout(opj_mqc_t *mqc ) 
{ 


  {
#line 199
  if ((int )*(mqc->bp) == 255) {
#line 200
    (mqc->bp) ++;
#line 201
    *(mqc->bp) = (unsigned char )(mqc->c >> 20);
#line 202
    mqc->c &= 1048575U;
#line 203
    mqc->ct = 7U;
  } else
#line 205
  if ((mqc->c & 134217728U) == 0U) {
#line 206
    (mqc->bp) ++;
#line 207
    *(mqc->bp) = (unsigned char )(mqc->c >> 19);
#line 208
    mqc->c &= 524287U;
#line 209
    mqc->ct = 8U;
  } else {
#line 211
    *(mqc->bp) = (unsigned char )((int )*(mqc->bp) + 1);
#line 212
    if ((int )*(mqc->bp) == 255) {
#line 213
      mqc->c &= 134217727U;
#line 214
      (mqc->bp) ++;
#line 215
      *(mqc->bp) = (unsigned char )(mqc->c >> 20);
#line 216
      mqc->c &= 1048575U;
#line 217
      mqc->ct = 7U;
    } else {
#line 219
      (mqc->bp) ++;
#line 220
      *(mqc->bp) = (unsigned char )(mqc->c >> 19);
#line 221
      mqc->c &= 524287U;
#line 222
      mqc->ct = 8U;
    }
  }
#line 225
  return;
}
}
#line 228 "/root/patchweave_new/2/libopenjpeg/mqc.c"
static void mqc_renorme(opj_mqc_t *mqc ) 
{ 
  unsigned int __cil_tmp2 ;

  {
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    mqc->a <<= 1;
#line 231
    mqc->c <<= 1;
#line 232
    __cil_tmp2 = mqc->ct;
#line 232
    (mqc->ct) --;
#line 233
    if (mqc->ct == 0U) {
      {
#line 234
      mqc_byteout(mqc);
      }
    }
#line 229
    if (! ((mqc->a & 32768U) == 0U)) {
#line 229
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 234
  return;
}
}
#line 239 "/root/patchweave_new/2/libopenjpeg/mqc.c"
static void mqc_codemps(opj_mqc_t *mqc ) 
{ 


  {
#line 240
  mqc->a -= (*(mqc->curctx))->qeval;
#line 241
  if ((mqc->a & 32768U) == 0U) {
#line 242
    if (mqc->a < (*(mqc->curctx))->qeval) {
#line 243
      mqc->a = (*(mqc->curctx))->qeval;
    } else {
#line 245
      mqc->c += (*(mqc->curctx))->qeval;
    }
    {
#line 247
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
#line 248
    mqc_renorme(mqc);
    }
  } else {
#line 250
    mqc->c += (*(mqc->curctx))->qeval;
  }
#line 252
  return;
}
}
#line 254 "/root/patchweave_new/2/libopenjpeg/mqc.c"
static void mqc_codelps(opj_mqc_t *mqc ) 
{ 


  {
#line 255
  mqc->a -= (*(mqc->curctx))->qeval;
#line 256
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 257
    mqc->c += (*(mqc->curctx))->qeval;
  } else {
#line 259
    mqc->a = (*(mqc->curctx))->qeval;
  }
  {
#line 261
  *(mqc->curctx) = (*(mqc->curctx))->nlps;
#line 262
  mqc_renorme(mqc);
  }
#line 264
  return;
}
}
#line 265 "/root/patchweave_new/2/libopenjpeg/mqc.c"
static void mqc_setbits(opj_mqc_t *mqc ) 
{ 
  unsigned int tempc ;

  {
#line 266
  tempc = mqc->c + mqc->a;
#line 267
  mqc->c |= 65535U;
#line 268
  if (mqc->c >= tempc) {
#line 269
    mqc->c -= 32768U;
  }
#line 271
  return;
}
}
#line 273 "/root/patchweave_new/2/libopenjpeg/mqc.c"
__inline static int mqc_mpsexchange(opj_mqc_t *mqc ) 
{ 
  int d ;

  {
#line 275
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 276
    d = 1 - (*(mqc->curctx))->mps;
#line 277
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  } else {
#line 279
    d = (*(mqc->curctx))->mps;
#line 280
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  }
#line 283
  return (d);
}
}
#line 286 "/root/patchweave_new/2/libopenjpeg/mqc.c"
__inline static int mqc_lpsexchange(opj_mqc_t *mqc ) 
{ 
  int d ;

  {
#line 288
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 289
    mqc->a = (*(mqc->curctx))->qeval;
#line 290
    d = (*(mqc->curctx))->mps;
#line 291
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  } else {
#line 293
    mqc->a = (*(mqc->curctx))->qeval;
#line 294
    d = 1 - (*(mqc->curctx))->mps;
#line 295
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  }
#line 298
  return (d);
}
}
#line 309 "/root/patchweave_new/2/libopenjpeg/mqc.c"
static void mqc_bytein(opj_mqc_t *mqc ) 
{ 
  unsigned int c ;

  {
#line 310
  if ((unsigned long )mqc->bp != (unsigned long )mqc->end) {
#line 312
    if ((unsigned long )(mqc->bp + 1) != (unsigned long )mqc->end) {
#line 313
      c = (unsigned int )*(mqc->bp + 1);
    } else {
#line 315
      c = 255U;
    }
#line 317
    if ((int )*(mqc->bp) == 255) {
#line 318
      if (c > 143U) {
#line 319
        mqc->c += 65280U;
#line 320
        mqc->ct = 8U;
      } else {
#line 322
        (mqc->bp) ++;
#line 323
        mqc->c += c << 9;
#line 324
        mqc->ct = 7U;
      }
    } else {
#line 327
      (mqc->bp) ++;
#line 328
      mqc->c += c << 8;
#line 329
      mqc->ct = 8U;
    }
  } else {
#line 332
    mqc->c += 65280U;
#line 333
    mqc->ct = 8U;
  }
#line 335
  return;
}
}
#line 338 "/root/patchweave_new/2/libopenjpeg/mqc.c"
__inline static void mqc_renormd(opj_mqc_t *mqc ) 
{ 
  unsigned int __cil_tmp2 ;

  {
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;

#line 340
    if (mqc->ct == 0U) {
      {
#line 341
      mqc_bytein(mqc);
      }
    }
#line 343
    mqc->a <<= 1;
#line 344
    mqc->c <<= 1;
#line 345
    __cil_tmp2 = mqc->ct;
#line 345
    (mqc->ct) --;
#line 339
    if (! (mqc->a < 32768U)) {
#line 339
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 344
  return;
}
}
#line 355 "/root/patchweave_new/2/libopenjpeg/mqc.c"
opj_mqc_t *mqc_create(void) 
{ 
  opj_mqc_t *mqc ;
  void *__cil_tmp2 ;

  {
  {
#line 356
  __cil_tmp2 = malloc(sizeof(opj_mqc_t ));
#line 356
  mqc = (opj_mqc_t *)__cil_tmp2;
  }
#line 360
  return (mqc);
}
}
#line 363 "/root/patchweave_new/2/libopenjpeg/mqc.c"
void mqc_destroy(opj_mqc_t *mqc ) 
{ 


  {
#line 364
  if (mqc) {
    {
#line 370
    free((void *)mqc);
    }
  }
#line 373
  return;
}
}
#line 374 "/root/patchweave_new/2/libopenjpeg/mqc.c"
int mqc_numbytes(opj_mqc_t *mqc ) 
{ 


  {
#line 375
  return ((int )(mqc->bp - mqc->start));
}
}
#line 378 "/root/patchweave_new/2/libopenjpeg/mqc.c"
void mqc_init_enc(opj_mqc_t *mqc , unsigned char *bp ) 
{ 


  {
#line 379
  mqc->curctx = & mqc->ctxs[0];
#line 380
  mqc->a = 32768U;
#line 381
  mqc->c = 0U;
#line 382
  mqc->bp = bp - 1;
#line 383
  mqc->ct = 12U;
#line 384
  if ((int )*(mqc->bp) == 255) {
#line 385
    mqc->ct = 13U;
  }
#line 387
  mqc->start = bp;
#line 388
  return;
}
}
#line 390 "/root/patchweave_new/2/libopenjpeg/mqc.c"
void mqc_encode(opj_mqc_t *mqc , int d ) 
{ 


  {
#line 391
  if ((*(mqc->curctx))->mps == d) {
    {
#line 392
    mqc_codemps(mqc);
    }
  } else {
    {
#line 394
    mqc_codelps(mqc);
    }
  }
#line 397
  return;
}
}
#line 398 "/root/patchweave_new/2/libopenjpeg/mqc.c"
void mqc_flush(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 399
  mqc_setbits(mqc);
#line 400
  mqc->c <<= mqc->ct;
#line 401
  mqc_byteout(mqc);
#line 402
  mqc->c <<= mqc->ct;
#line 403
  mqc_byteout(mqc);
  }
#line 405
  if ((int )*(mqc->bp) != 255) {
#line 406
    (mqc->bp) ++;
  }
#line 408
  return;
}
}
#line 410 "/root/patchweave_new/2/libopenjpeg/mqc.c"
void mqc_bypass_init_enc(opj_mqc_t *mqc ) 
{ 


  {
#line 411
  mqc->c = 0U;
#line 412
  mqc->ct = 8U;
#line 413
  return;
}
}
#line 418 "/root/patchweave_new/2/libopenjpeg/mqc.c"
void mqc_bypass_enc(opj_mqc_t *mqc , int d ) 
{ 
  unsigned int __cil_tmp3 ;

  {
#line 419
  __cil_tmp3 = mqc->ct;
#line 419
  (mqc->ct) --;
#line 420
  mqc->c += (unsigned int )(d << mqc->ct);
#line 421
  if (mqc->ct == 0U) {
#line 422
    (mqc->bp) ++;
#line 423
    *(mqc->bp) = (unsigned char )mqc->c;
#line 424
    mqc->ct = 8U;
#line 425
    if ((int )*(mqc->bp) == 255) {
#line 426
      mqc->ct = 7U;
    }
#line 428
    mqc->c = 0U;
  }
#line 430
  return;
}
}
#line 432 "/root/patchweave_new/2/libopenjpeg/mqc.c"
int mqc_bypass_flush_enc(opj_mqc_t *mqc ) 
{ 
  unsigned char bit_padding ;
  unsigned int __cil_tmp3 ;

  {
#line 435
  bit_padding = (unsigned char)0;
#line 437
  if (mqc->ct != 0U) {
    {
#line 438
    while (1) {
      while_continue: /* CIL Label */ ;

#line 438
      if (! (mqc->ct > 0U)) {
#line 438
        goto while_break;
      }
#line 439
      __cil_tmp3 = mqc->ct;
#line 439
      (mqc->ct) --;
#line 440
      mqc->c += (unsigned int )((int )bit_padding << mqc->ct);
#line 441
      bit_padding = (unsigned char )(((int )bit_padding + 1) & 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 443
    (mqc->bp) ++;
#line 444
    *(mqc->bp) = (unsigned char )mqc->c;
#line 445
    mqc->ct = 8U;
#line 446
    mqc->c = 0U;
  }
#line 449
  return (1);
}
}
#line 452 "/root/patchweave_new/2/libopenjpeg/mqc.c"
void mqc_reset_enc(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 453
  mqc_resetstates(mqc);
#line 454
  mqc_setstate(mqc, 18, 0, 46);
#line 455
  mqc_setstate(mqc, 17, 0, 3);
#line 456
  mqc_setstate(mqc, 0, 0, 4);
  }
#line 458
  return;
}
}
#line 459 "/root/patchweave_new/2/libopenjpeg/mqc.c"
int mqc_restart_enc(opj_mqc_t *mqc ) 
{ 
  int correction ;
  int n ;

  {
#line 460
  correction = 1;
#line 463
  n = (int )(12U - mqc->ct);
#line 464
  mqc->c <<= mqc->ct;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;

#line 465
    if (! (n > 0)) {
#line 465
      goto while_break;
    }
    {
#line 466
    mqc_byteout(mqc);
#line 467
    n = (int )((unsigned int )n - mqc->ct);
#line 468
    mqc->c <<= mqc->ct;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 470
  mqc_byteout(mqc);
  }
#line 472
  return (correction);
}
}
#line 475 "/root/patchweave_new/2/libopenjpeg/mqc.c"
void mqc_restart_init_enc(opj_mqc_t *mqc ) 
{ 
  unsigned char *__cil_tmp2 ;

  {
#line 477
  mqc->curctx = & mqc->ctxs[0];
#line 478
  mqc->a = 32768U;
#line 479
  mqc->c = 0U;
#line 480
  mqc->ct = 12U;
#line 481
  __cil_tmp2 = mqc->bp;
#line 481
  (mqc->bp) --;
#line 482
  if ((int )*(mqc->bp) == 255) {
#line 483
    mqc->ct = 13U;
  }
#line 485
  return;
}
}
#line 487 "/root/patchweave_new/2/libopenjpeg/mqc.c"
void mqc_erterm_enc(opj_mqc_t *mqc ) 
{ 
  int k ;

  {
#line 488
  k = (int )((11U - mqc->ct) + 1U);
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;

#line 490
    if (! (k > 0)) {
#line 490
      goto while_break;
    }
    {
#line 491
    mqc->c <<= mqc->ct;
#line 492
    mqc->ct = 0U;
#line 493
    mqc_byteout(mqc);
#line 494
    k = (int )((unsigned int )k - mqc->ct);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 497
  if ((int )*(mqc->bp) != 255) {
    {
#line 498
    mqc_byteout(mqc);
    }
  }
#line 501
  return;
}
}
#line 502 "/root/patchweave_new/2/libopenjpeg/mqc.c"
void mqc_segmark_enc(opj_mqc_t *mqc ) 
{ 
  int i ;

  {
#line 504
  mqc->curctx = & mqc->ctxs[18];
#line 506
  i = 1;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;

#line 506
    if (! (i < 5)) {
#line 506
      goto while_break;
    }
    {
#line 507
    mqc_encode(mqc, i % 2);
#line 506
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 510
  return;
}
}
#line 511 "/root/patchweave_new/2/libopenjpeg/mqc.c"
void mqc_init_dec(opj_mqc_t *mqc , unsigned char *bp , int len ) 
{ 


  {
#line 512
  mqc->curctx = & mqc->ctxs[0];
#line 513
  mqc->start = bp;
#line 514
  mqc->end = bp + len;
#line 515
  mqc->bp = bp;
#line 516
  if (len == 0) {
#line 516
    mqc->c = (unsigned int )(255 << 16);
  } else {
#line 517
    mqc->c = (unsigned int )((int )*(mqc->bp) << 16);
  }
  {
#line 556
  mqc_bytein(mqc);
#line 557
  mqc->c <<= 7;
#line 558
  mqc->ct -= 7U;
#line 559
  mqc->a = 32768U;
  }
#line 561
  return;
}
}
#line 562 "/root/patchweave_new/2/libopenjpeg/mqc.c"
int mqc_decode(opj_mqc_t *mqc ) 
{ 
  int d ;

  {
#line 564
  mqc->a -= (*(mqc->curctx))->qeval;
#line 565
  if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
    {
#line 566
    d = mqc_lpsexchange(mqc);
#line 567
    mqc_renormd(mqc);
    }
  } else {
#line 569
    mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 570
    if ((mqc->a & 32768U) == 0U) {
      {
#line 571
      d = mqc_mpsexchange(mqc);
#line 572
      mqc_renormd(mqc);
      }
    } else {
#line 574
      d = (*(mqc->curctx))->mps;
    }
  }
#line 578
  return (d);
}
}
#line 581 "/root/patchweave_new/2/libopenjpeg/mqc.c"
void mqc_resetstates(opj_mqc_t *mqc ) 
{ 
  int i ;

  {
#line 583
  i = 0;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;

#line 583
    if (! (i < 19)) {
#line 583
      goto while_break;
    }
#line 584
    mqc->ctxs[i] = mqc_states;
#line 583
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 587
  return;
}
}
#line 588 "/root/patchweave_new/2/libopenjpeg/mqc.c"
void mqc_setstate(opj_mqc_t *mqc , int ctxno , int msb , int prob ) 
{ 


  {
#line 589
  mqc->ctxs[ctxno] = & mqc_states[msb + (prob << 1)];
#line 590
  return;
}
}
#line 56 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_empty)(void) ;
#line 58
extern int ( /* missing proto */  __builtin_ia32_emms)() ;
#line 56 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_empty)(void) 
{ 


  {
  {
#line 58
  __builtin_ia32_emms();
  }
#line 60
  return;
}
}
#line 62
__inline extern void ( __attribute__((__gnu_inline__)) _m_empty)(void) ;
#line 62 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _m_empty)(void) 
{ 


  {
  {
#line 64
  _mm_empty();
  }
#line 66
  return;
}
}
#line 69
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si64)(int __i ) ;
#line 71
extern int ( /* missing proto */  __builtin_ia32_vec_init_v2si)() ;
#line 69 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si64)(int __i ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 71
  __cil_tmp2 = __builtin_ia32_vec_init_v2si(__i, 0);
  }
#line 71
  return (__cil_tmp2);
}
}
#line 75
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int)(int __i ) ;
#line 75 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int)(int __i ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 77
  __cil_tmp2 = _mm_cvtsi32_si64(__i);
  }
#line 77
  return (__cil_tmp2);
}
}
#line 85
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int64)(long long __i ) ;
#line 85 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int64)(long long __i ) 
{ 


  {
#line 87
  return ((__m64 )__i);
}
}
#line 112
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si32)(__m64 __i ) ;
#line 114
extern int ( /* missing proto */  __builtin_ia32_vec_ext_v2si)() ;
#line 112 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si32)(__m64 __i ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 114
  __cil_tmp2 = __builtin_ia32_vec_ext_v2si(__i, 0);
  }
#line 114
  return (__cil_tmp2);
}
}
#line 118
__inline extern int ( __attribute__((__gnu_inline__)) _m_to_int)(__m64 __i ) ;
#line 118 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _m_to_int)(__m64 __i ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 120
  __cil_tmp2 = _mm_cvtsi64_si32(__i);
  }
#line 120
  return (__cil_tmp2);
}
}
#line 128
__inline extern long long ( __attribute__((__gnu_inline__)) _m_to_int64)(__m64 __i ) ;
#line 128 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _m_to_int64)(__m64 __i ) 
{ 


  {
#line 130
  return ((long long )__i);
}
}
#line 151
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 153
extern int ( /* missing proto */  __builtin_ia32_packsswb)() ;
#line 151 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 153
  __cil_tmp3 = __builtin_ia32_packsswb(__m1, __m2);
  }
#line 153
  return (__cil_tmp3);
}
}
#line 157
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packsswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 157 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packsswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 159
  __cil_tmp3 = _mm_packs_pi16(__m1, __m2);
  }
#line 159
  return (__cil_tmp3);
}
}
#line 166
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 168
extern int ( /* missing proto */  __builtin_ia32_packssdw)() ;
#line 166 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 168
  __cil_tmp3 = __builtin_ia32_packssdw(__m1, __m2);
  }
#line 168
  return (__cil_tmp3);
}
}
#line 172
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packssdw)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 172 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packssdw)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 174
  __cil_tmp3 = _mm_packs_pi32(__m1, __m2);
  }
#line 174
  return (__cil_tmp3);
}
}
#line 181
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pu16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 183
extern int ( /* missing proto */  __builtin_ia32_packuswb)() ;
#line 181 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pu16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 183
  __cil_tmp3 = __builtin_ia32_packuswb(__m1, __m2);
  }
#line 183
  return (__cil_tmp3);
}
}
#line 187
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packuswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 187 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packuswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 189
  __cil_tmp3 = _mm_packs_pu16(__m1, __m2);
  }
#line 189
  return (__cil_tmp3);
}
}
#line 195
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) ;
#line 197
extern int ( /* missing proto */  __builtin_ia32_punpckhbw)() ;
#line 195 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 197
  __cil_tmp3 = __builtin_ia32_punpckhbw(__m1, __m2);
  }
#line 197
  return (__cil_tmp3);
}
}
#line 201
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 201 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 203
  __cil_tmp3 = _mm_unpackhi_pi8(__m1, __m2);
  }
#line 203
  return (__cil_tmp3);
}
}
#line 209
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 211
extern int ( /* missing proto */  __builtin_ia32_punpckhwd)() ;
#line 209 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 211
  __cil_tmp3 = __builtin_ia32_punpckhwd(__m1, __m2);
  }
#line 211
  return (__cil_tmp3);
}
}
#line 215
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 215 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 217
  __cil_tmp3 = _mm_unpackhi_pi16(__m1, __m2);
  }
#line 217
  return (__cil_tmp3);
}
}
#line 223
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 225
extern int ( /* missing proto */  __builtin_ia32_punpckhdq)() ;
#line 223 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 225
  __cil_tmp3 = __builtin_ia32_punpckhdq(__m1, __m2);
  }
#line 225
  return (__cil_tmp3);
}
}
#line 229
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhdq)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 229 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhdq)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 231
  __cil_tmp3 = _mm_unpackhi_pi32(__m1, __m2);
  }
#line 231
  return (__cil_tmp3);
}
}
#line 237
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) ;
#line 239
extern int ( /* missing proto */  __builtin_ia32_punpcklbw)() ;
#line 237 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 239
  __cil_tmp3 = __builtin_ia32_punpcklbw(__m1, __m2);
  }
#line 239
  return (__cil_tmp3);
}
}
#line 243
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 243 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 245
  __cil_tmp3 = _mm_unpacklo_pi8(__m1, __m2);
  }
#line 245
  return (__cil_tmp3);
}
}
#line 251
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 253
extern int ( /* missing proto */  __builtin_ia32_punpcklwd)() ;
#line 251 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 253
  __cil_tmp3 = __builtin_ia32_punpcklwd(__m1, __m2);
  }
#line 253
  return (__cil_tmp3);
}
}
#line 257
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 257 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 259
  __cil_tmp3 = _mm_unpacklo_pi16(__m1, __m2);
  }
#line 259
  return (__cil_tmp3);
}
}
#line 265
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 267
extern int ( /* missing proto */  __builtin_ia32_punpckldq)() ;
#line 265 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 267
  __cil_tmp3 = __builtin_ia32_punpckldq(__m1, __m2);
  }
#line 267
  return (__cil_tmp3);
}
}
#line 271
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckldq)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 271 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckldq)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 273
  __cil_tmp3 = _mm_unpacklo_pi32(__m1, __m2);
  }
#line 273
  return (__cil_tmp3);
}
}
#line 278
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 280
extern int ( /* missing proto */  __builtin_ia32_paddb)() ;
#line 278 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 280
  __cil_tmp3 = __builtin_ia32_paddb(__m1, __m2);
  }
#line 280
  return (__cil_tmp3);
}
}
#line 284
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddb)(__m64 __m1 , __m64 __m2 ) ;
#line 284 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 286
  __cil_tmp3 = _mm_add_pi8(__m1, __m2);
  }
#line 286
  return (__cil_tmp3);
}
}
#line 291
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 293
extern int ( /* missing proto */  __builtin_ia32_paddw)() ;
#line 291 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 293
  __cil_tmp3 = __builtin_ia32_paddw(__m1, __m2);
  }
#line 293
  return (__cil_tmp3);
}
}
#line 297
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddw)(__m64 __m1 , __m64 __m2 ) ;
#line 297 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 299
  __cil_tmp3 = _mm_add_pi16(__m1, __m2);
  }
#line 299
  return (__cil_tmp3);
}
}
#line 304
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 306
extern int ( /* missing proto */  __builtin_ia32_paddd)() ;
#line 304 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 306
  __cil_tmp3 = __builtin_ia32_paddd(__m1, __m2);
  }
#line 306
  return (__cil_tmp3);
}
}
#line 310
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddd)(__m64 __m1 , __m64 __m2 ) ;
#line 310 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 312
  __cil_tmp3 = _mm_add_pi32(__m1, __m2);
  }
#line 312
  return (__cil_tmp3);
}
}
#line 323
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 325
extern int ( /* missing proto */  __builtin_ia32_paddq)() ;
#line 323 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 325
  __cil_tmp3 = __builtin_ia32_paddq(__m1, __m2);
  }
#line 325
  return (__cil_tmp3);
}
}
#line 335
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 337
extern int ( /* missing proto */  __builtin_ia32_paddsb)() ;
#line 335 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 337
  __cil_tmp3 = __builtin_ia32_paddsb(__m1, __m2);
  }
#line 337
  return (__cil_tmp3);
}
}
#line 341
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsb)(__m64 __m1 , __m64 __m2 ) ;
#line 341 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 343
  __cil_tmp3 = _mm_adds_pi8(__m1, __m2);
  }
#line 343
  return (__cil_tmp3);
}
}
#line 349
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 351
extern int ( /* missing proto */  __builtin_ia32_paddsw)() ;
#line 349 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 351
  __cil_tmp3 = __builtin_ia32_paddsw(__m1, __m2);
  }
#line 351
  return (__cil_tmp3);
}
}
#line 355
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsw)(__m64 __m1 , __m64 __m2 ) ;
#line 355 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 357
  __cil_tmp3 = _mm_adds_pi16(__m1, __m2);
  }
#line 357
  return (__cil_tmp3);
}
}
#line 363
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 365
extern int ( /* missing proto */  __builtin_ia32_paddusb)() ;
#line 363 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 365
  __cil_tmp3 = __builtin_ia32_paddusb(__m1, __m2);
  }
#line 365
  return (__cil_tmp3);
}
}
#line 369
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusb)(__m64 __m1 , __m64 __m2 ) ;
#line 369 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 371
  __cil_tmp3 = _mm_adds_pu8(__m1, __m2);
  }
#line 371
  return (__cil_tmp3);
}
}
#line 377
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 379
extern int ( /* missing proto */  __builtin_ia32_paddusw)() ;
#line 377 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 379
  __cil_tmp3 = __builtin_ia32_paddusw(__m1, __m2);
  }
#line 379
  return (__cil_tmp3);
}
}
#line 383
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusw)(__m64 __m1 , __m64 __m2 ) ;
#line 383 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 385
  __cil_tmp3 = _mm_adds_pu16(__m1, __m2);
  }
#line 385
  return (__cil_tmp3);
}
}
#line 390
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 392
extern int ( /* missing proto */  __builtin_ia32_psubb)() ;
#line 390 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 392
  __cil_tmp3 = __builtin_ia32_psubb(__m1, __m2);
  }
#line 392
  return (__cil_tmp3);
}
}
#line 396
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubb)(__m64 __m1 , __m64 __m2 ) ;
#line 396 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 398
  __cil_tmp3 = _mm_sub_pi8(__m1, __m2);
  }
#line 398
  return (__cil_tmp3);
}
}
#line 403
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 405
extern int ( /* missing proto */  __builtin_ia32_psubw)() ;
#line 403 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 405
  __cil_tmp3 = __builtin_ia32_psubw(__m1, __m2);
  }
#line 405
  return (__cil_tmp3);
}
}
#line 409
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubw)(__m64 __m1 , __m64 __m2 ) ;
#line 409 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 411
  __cil_tmp3 = _mm_sub_pi16(__m1, __m2);
  }
#line 411
  return (__cil_tmp3);
}
}
#line 416
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 418
extern int ( /* missing proto */  __builtin_ia32_psubd)() ;
#line 416 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 418
  __cil_tmp3 = __builtin_ia32_psubd(__m1, __m2);
  }
#line 418
  return (__cil_tmp3);
}
}
#line 422
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubd)(__m64 __m1 , __m64 __m2 ) ;
#line 422 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 424
  __cil_tmp3 = _mm_sub_pi32(__m1, __m2);
  }
#line 424
  return (__cil_tmp3);
}
}
#line 435
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 437
extern int ( /* missing proto */  __builtin_ia32_psubq)() ;
#line 435 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 437
  __cil_tmp3 = __builtin_ia32_psubq(__m1, __m2);
  }
#line 437
  return (__cil_tmp3);
}
}
#line 447
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 449
extern int ( /* missing proto */  __builtin_ia32_psubsb)() ;
#line 447 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 449
  __cil_tmp3 = __builtin_ia32_psubsb(__m1, __m2);
  }
#line 449
  return (__cil_tmp3);
}
}
#line 453
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsb)(__m64 __m1 , __m64 __m2 ) ;
#line 453 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = _mm_subs_pi8(__m1, __m2);
  }
#line 455
  return (__cil_tmp3);
}
}
#line 461
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 463
extern int ( /* missing proto */  __builtin_ia32_psubsw)() ;
#line 461 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 463
  __cil_tmp3 = __builtin_ia32_psubsw(__m1, __m2);
  }
#line 463
  return (__cil_tmp3);
}
}
#line 467
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsw)(__m64 __m1 , __m64 __m2 ) ;
#line 467 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 469
  __cil_tmp3 = _mm_subs_pi16(__m1, __m2);
  }
#line 469
  return (__cil_tmp3);
}
}
#line 475
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 477
extern int ( /* missing proto */  __builtin_ia32_psubusb)() ;
#line 475 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 477
  __cil_tmp3 = __builtin_ia32_psubusb(__m1, __m2);
  }
#line 477
  return (__cil_tmp3);
}
}
#line 481
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusb)(__m64 __m1 , __m64 __m2 ) ;
#line 481 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 483
  __cil_tmp3 = _mm_subs_pu8(__m1, __m2);
  }
#line 483
  return (__cil_tmp3);
}
}
#line 489
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 491
extern int ( /* missing proto */  __builtin_ia32_psubusw)() ;
#line 489 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 491
  __cil_tmp3 = __builtin_ia32_psubusw(__m1, __m2);
  }
#line 491
  return (__cil_tmp3);
}
}
#line 495
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusw)(__m64 __m1 , __m64 __m2 ) ;
#line 495 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 497
  __cil_tmp3 = _mm_subs_pu16(__m1, __m2);
  }
#line 497
  return (__cil_tmp3);
}
}
#line 504
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_madd_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 506
extern int ( /* missing proto */  __builtin_ia32_pmaddwd)() ;
#line 504 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_madd_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 506
  __cil_tmp3 = __builtin_ia32_pmaddwd(__m1, __m2);
  }
#line 506
  return (__cil_tmp3);
}
}
#line 510
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaddwd)(__m64 __m1 , __m64 __m2 ) ;
#line 510 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaddwd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 512
  __cil_tmp3 = _mm_madd_pi16(__m1, __m2);
  }
#line 512
  return (__cil_tmp3);
}
}
#line 518
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 520
extern int ( /* missing proto */  __builtin_ia32_pmulhw)() ;
#line 518 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 520
  __cil_tmp3 = __builtin_ia32_pmulhw(__m1, __m2);
  }
#line 520
  return (__cil_tmp3);
}
}
#line 524
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhw)(__m64 __m1 , __m64 __m2 ) ;
#line 524 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 526
  __cil_tmp3 = _mm_mulhi_pi16(__m1, __m2);
  }
#line 526
  return (__cil_tmp3);
}
}
#line 532
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mullo_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 534
extern int ( /* missing proto */  __builtin_ia32_pmullw)() ;
#line 532 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mullo_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 534
  __cil_tmp3 = __builtin_ia32_pmullw(__m1, __m2);
  }
#line 534
  return (__cil_tmp3);
}
}
#line 538
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmullw)(__m64 __m1 , __m64 __m2 ) ;
#line 538 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmullw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 540
  __cil_tmp3 = _mm_mullo_pi16(__m1, __m2);
  }
#line 540
  return (__cil_tmp3);
}
}
#line 545
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi16)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 547
extern int ( /* missing proto */  __builtin_ia32_psllw)() ;
#line 545 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi16)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 547
  __cil_tmp3 = __builtin_ia32_psllw(__m, __count);
  }
#line 547
  return (__cil_tmp3);
}
}
#line 551
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllw)(__m64 __m , __m64 __count ) ;
#line 551 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllw)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 553
  __cil_tmp3 = _mm_sll_pi16(__m, __count);
  }
#line 553
  return (__cil_tmp3);
}
}
#line 557
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi16)(__m64 __m ,
                                                                       int __count ) ;
#line 559
extern int ( /* missing proto */  __builtin_ia32_psllwi)() ;
#line 557 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi16)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 559
  __cil_tmp3 = __builtin_ia32_psllwi(__m, __count);
  }
#line 559
  return (__cil_tmp3);
}
}
#line 563
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllwi)(__m64 __m , int __count ) ;
#line 563 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllwi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 565
  __cil_tmp3 = _mm_slli_pi16(__m, __count);
  }
#line 565
  return (__cil_tmp3);
}
}
#line 570
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi32)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 572
extern int ( /* missing proto */  __builtin_ia32_pslld)() ;
#line 570 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi32)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 572
  __cil_tmp3 = __builtin_ia32_pslld(__m, __count);
  }
#line 572
  return (__cil_tmp3);
}
}
#line 576
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslld)(__m64 __m , __m64 __count ) ;
#line 576 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslld)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 578
  __cil_tmp3 = _mm_sll_pi32(__m, __count);
  }
#line 578
  return (__cil_tmp3);
}
}
#line 582
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi32)(__m64 __m ,
                                                                       int __count ) ;
#line 584
extern int ( /* missing proto */  __builtin_ia32_pslldi)() ;
#line 582 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi32)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 584
  __cil_tmp3 = __builtin_ia32_pslldi(__m, __count);
  }
#line 584
  return (__cil_tmp3);
}
}
#line 588
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslldi)(__m64 __m , int __count ) ;
#line 588 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslldi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 590
  __cil_tmp3 = _mm_slli_pi32(__m, __count);
  }
#line 590
  return (__cil_tmp3);
}
}
#line 595
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_si64)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 597
extern int ( /* missing proto */  __builtin_ia32_psllq)() ;
#line 595 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_si64)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 597
  __cil_tmp3 = __builtin_ia32_psllq(__m, __count);
  }
#line 597
  return (__cil_tmp3);
}
}
#line 601
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllq)(__m64 __m , __m64 __count ) ;
#line 601 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllq)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 603
  __cil_tmp3 = _mm_sll_si64(__m, __count);
  }
#line 603
  return (__cil_tmp3);
}
}
#line 607
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_si64)(__m64 __m ,
                                                                       int __count ) ;
#line 609
extern int ( /* missing proto */  __builtin_ia32_psllqi)() ;
#line 607 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_si64)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 609
  __cil_tmp3 = __builtin_ia32_psllqi(__m, __count);
  }
#line 609
  return (__cil_tmp3);
}
}
#line 613
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllqi)(__m64 __m , int __count ) ;
#line 613 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllqi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 615
  __cil_tmp3 = _mm_slli_si64(__m, __count);
  }
#line 615
  return (__cil_tmp3);
}
}
#line 620
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi16)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 622
extern int ( /* missing proto */  __builtin_ia32_psraw)() ;
#line 620 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi16)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 622
  __cil_tmp3 = __builtin_ia32_psraw(__m, __count);
  }
#line 622
  return (__cil_tmp3);
}
}
#line 626
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psraw)(__m64 __m , __m64 __count ) ;
#line 626 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psraw)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 628
  __cil_tmp3 = _mm_sra_pi16(__m, __count);
  }
#line 628
  return (__cil_tmp3);
}
}
#line 632
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi16)(__m64 __m ,
                                                                       int __count ) ;
#line 634
extern int ( /* missing proto */  __builtin_ia32_psrawi)() ;
#line 632 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi16)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 634
  __cil_tmp3 = __builtin_ia32_psrawi(__m, __count);
  }
#line 634
  return (__cil_tmp3);
}
}
#line 638
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrawi)(__m64 __m , int __count ) ;
#line 638 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrawi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 640
  __cil_tmp3 = _mm_srai_pi16(__m, __count);
  }
#line 640
  return (__cil_tmp3);
}
}
#line 645
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi32)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 647
extern int ( /* missing proto */  __builtin_ia32_psrad)() ;
#line 645 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi32)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 647
  __cil_tmp3 = __builtin_ia32_psrad(__m, __count);
  }
#line 647
  return (__cil_tmp3);
}
}
#line 651
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrad)(__m64 __m , __m64 __count ) ;
#line 651 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrad)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 653
  __cil_tmp3 = _mm_sra_pi32(__m, __count);
  }
#line 653
  return (__cil_tmp3);
}
}
#line 657
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi32)(__m64 __m ,
                                                                       int __count ) ;
#line 659
extern int ( /* missing proto */  __builtin_ia32_psradi)() ;
#line 657 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi32)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 659
  __cil_tmp3 = __builtin_ia32_psradi(__m, __count);
  }
#line 659
  return (__cil_tmp3);
}
}
#line 663
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psradi)(__m64 __m , int __count ) ;
#line 663 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psradi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 665
  __cil_tmp3 = _mm_srai_pi32(__m, __count);
  }
#line 665
  return (__cil_tmp3);
}
}
#line 670
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi16)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 672
extern int ( /* missing proto */  __builtin_ia32_psrlw)() ;
#line 670 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi16)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 672
  __cil_tmp3 = __builtin_ia32_psrlw(__m, __count);
  }
#line 672
  return (__cil_tmp3);
}
}
#line 676
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlw)(__m64 __m , __m64 __count ) ;
#line 676 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlw)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 678
  __cil_tmp3 = _mm_srl_pi16(__m, __count);
  }
#line 678
  return (__cil_tmp3);
}
}
#line 682
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi16)(__m64 __m ,
                                                                       int __count ) ;
#line 684
extern int ( /* missing proto */  __builtin_ia32_psrlwi)() ;
#line 682 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi16)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 684
  __cil_tmp3 = __builtin_ia32_psrlwi(__m, __count);
  }
#line 684
  return (__cil_tmp3);
}
}
#line 688
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlwi)(__m64 __m , int __count ) ;
#line 688 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlwi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 690
  __cil_tmp3 = _mm_srli_pi16(__m, __count);
  }
#line 690
  return (__cil_tmp3);
}
}
#line 695
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi32)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 697
extern int ( /* missing proto */  __builtin_ia32_psrld)() ;
#line 695 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi32)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 697
  __cil_tmp3 = __builtin_ia32_psrld(__m, __count);
  }
#line 697
  return (__cil_tmp3);
}
}
#line 701
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrld)(__m64 __m , __m64 __count ) ;
#line 701 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrld)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 703
  __cil_tmp3 = _mm_srl_pi32(__m, __count);
  }
#line 703
  return (__cil_tmp3);
}
}
#line 707
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi32)(__m64 __m ,
                                                                       int __count ) ;
#line 709
extern int ( /* missing proto */  __builtin_ia32_psrldi)() ;
#line 707 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi32)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 709
  __cil_tmp3 = __builtin_ia32_psrldi(__m, __count);
  }
#line 709
  return (__cil_tmp3);
}
}
#line 713
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrldi)(__m64 __m , int __count ) ;
#line 713 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrldi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 715
  __cil_tmp3 = _mm_srli_pi32(__m, __count);
  }
#line 715
  return (__cil_tmp3);
}
}
#line 720
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_si64)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 722
extern int ( /* missing proto */  __builtin_ia32_psrlq)() ;
#line 720 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_si64)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 722
  __cil_tmp3 = __builtin_ia32_psrlq(__m, __count);
  }
#line 722
  return (__cil_tmp3);
}
}
#line 726
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlq)(__m64 __m , __m64 __count ) ;
#line 726 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlq)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 728
  __cil_tmp3 = _mm_srl_si64(__m, __count);
  }
#line 728
  return (__cil_tmp3);
}
}
#line 732
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_si64)(__m64 __m ,
                                                                       int __count ) ;
#line 734
extern int ( /* missing proto */  __builtin_ia32_psrlqi)() ;
#line 732 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_si64)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 734
  __cil_tmp3 = __builtin_ia32_psrlqi(__m, __count);
  }
#line 734
  return (__cil_tmp3);
}
}
#line 738
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlqi)(__m64 __m , int __count ) ;
#line 738 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlqi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 740
  __cil_tmp3 = _mm_srli_si64(__m, __count);
  }
#line 740
  return (__cil_tmp3);
}
}
#line 745
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_and_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 747
extern int ( /* missing proto */  __builtin_ia32_pand)() ;
#line 745 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_and_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 747
  __cil_tmp3 = __builtin_ia32_pand(__m1, __m2);
  }
#line 747
  return (__cil_tmp3);
}
}
#line 751
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pand)(__m64 __m1 , __m64 __m2 ) ;
#line 751 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pand)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 753
  __cil_tmp3 = _mm_and_si64(__m1, __m2);
  }
#line 753
  return (__cil_tmp3);
}
}
#line 759
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_andnot_si64)(__m64 __m1 ,
                                                                         __m64 __m2 ) ;
#line 761
extern int ( /* missing proto */  __builtin_ia32_pandn)() ;
#line 759 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_andnot_si64)(__m64 __m1 ,
                                                                         __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 761
  __cil_tmp3 = __builtin_ia32_pandn(__m1, __m2);
  }
#line 761
  return (__cil_tmp3);
}
}
#line 765
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pandn)(__m64 __m1 , __m64 __m2 ) ;
#line 765 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pandn)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 767
  __cil_tmp3 = _mm_andnot_si64(__m1, __m2);
  }
#line 767
  return (__cil_tmp3);
}
}
#line 772
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_or_si64)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 774
extern int ( /* missing proto */  __builtin_ia32_por)() ;
#line 772 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_or_si64)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 774
  __cil_tmp3 = __builtin_ia32_por(__m1, __m2);
  }
#line 774
  return (__cil_tmp3);
}
}
#line 778
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_por)(__m64 __m1 , __m64 __m2 ) ;
#line 778 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_por)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 780
  __cil_tmp3 = _mm_or_si64(__m1, __m2);
  }
#line 780
  return (__cil_tmp3);
}
}
#line 785
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_xor_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 787
extern int ( /* missing proto */  __builtin_ia32_pxor)() ;
#line 785 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_xor_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 787
  __cil_tmp3 = __builtin_ia32_pxor(__m1, __m2);
  }
#line 787
  return (__cil_tmp3);
}
}
#line 791
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pxor)(__m64 __m1 , __m64 __m2 ) ;
#line 791 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pxor)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 793
  __cil_tmp3 = _mm_xor_si64(__m1, __m2);
  }
#line 793
  return (__cil_tmp3);
}
}
#line 799
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 801
extern int ( /* missing proto */  __builtin_ia32_pcmpeqb)() ;
#line 799 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 801
  __cil_tmp3 = __builtin_ia32_pcmpeqb(__m1, __m2);
  }
#line 801
  return (__cil_tmp3);
}
}
#line 805
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqb)(__m64 __m1 , __m64 __m2 ) ;
#line 805 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 807
  __cil_tmp3 = _mm_cmpeq_pi8(__m1, __m2);
  }
#line 807
  return (__cil_tmp3);
}
}
#line 811
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 813
extern int ( /* missing proto */  __builtin_ia32_pcmpgtb)() ;
#line 811 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 813
  __cil_tmp3 = __builtin_ia32_pcmpgtb(__m1, __m2);
  }
#line 813
  return (__cil_tmp3);
}
}
#line 817
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtb)(__m64 __m1 , __m64 __m2 ) ;
#line 817 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 819
  __cil_tmp3 = _mm_cmpgt_pi8(__m1, __m2);
  }
#line 819
  return (__cil_tmp3);
}
}
#line 825
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 827
extern int ( /* missing proto */  __builtin_ia32_pcmpeqw)() ;
#line 825 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 827
  __cil_tmp3 = __builtin_ia32_pcmpeqw(__m1, __m2);
  }
#line 827
  return (__cil_tmp3);
}
}
#line 831
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqw)(__m64 __m1 , __m64 __m2 ) ;
#line 831 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 833
  __cil_tmp3 = _mm_cmpeq_pi16(__m1, __m2);
  }
#line 833
  return (__cil_tmp3);
}
}
#line 837
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 839
extern int ( /* missing proto */  __builtin_ia32_pcmpgtw)() ;
#line 837 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 839
  __cil_tmp3 = __builtin_ia32_pcmpgtw(__m1, __m2);
  }
#line 839
  return (__cil_tmp3);
}
}
#line 843
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtw)(__m64 __m1 , __m64 __m2 ) ;
#line 843 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 845
  __cil_tmp3 = _mm_cmpgt_pi16(__m1, __m2);
  }
#line 845
  return (__cil_tmp3);
}
}
#line 851
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 853
extern int ( /* missing proto */  __builtin_ia32_pcmpeqd)() ;
#line 851 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 853
  __cil_tmp3 = __builtin_ia32_pcmpeqd(__m1, __m2);
  }
#line 853
  return (__cil_tmp3);
}
}
#line 857
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqd)(__m64 __m1 , __m64 __m2 ) ;
#line 857 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 859
  __cil_tmp3 = _mm_cmpeq_pi32(__m1, __m2);
  }
#line 859
  return (__cil_tmp3);
}
}
#line 863
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 865
extern int ( /* missing proto */  __builtin_ia32_pcmpgtd)() ;
#line 863 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 865
  __cil_tmp3 = __builtin_ia32_pcmpgtd(__m1, __m2);
  }
#line 865
  return (__cil_tmp3);
}
}
#line 869
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtd)(__m64 __m1 , __m64 __m2 ) ;
#line 869 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 871
  __cil_tmp3 = _mm_cmpgt_pi32(__m1, __m2);
  }
#line 871
  return (__cil_tmp3);
}
}
#line 876
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setzero_si64)(void) ;
#line 876 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setzero_si64)(void) 
{ 


  {
#line 878
  return ((__m64 )0LL);
}
}
#line 883
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi32)(int __i1 , int __i0 ) ;
#line 883 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi32)(int __i1 , int __i0 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 885
  __cil_tmp3 = __builtin_ia32_vec_init_v2si(__i0, __i1);
  }
#line 885
  return (__cil_tmp3);
}
}
#line 890
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi16)(short __w3 ,
                                                                      short __w2 ,
                                                                      short __w1 ,
                                                                      short __w0 ) ;
#line 892
extern int ( /* missing proto */  __builtin_ia32_vec_init_v4hi)() ;
#line 890 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi16)(short __w3 ,
                                                                      short __w2 ,
                                                                      short __w1 ,
                                                                      short __w0 ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 892
  __cil_tmp5 = __builtin_ia32_vec_init_v4hi((int )__w0, (int )__w1, (int )__w2, (int )__w3);
  }
#line 892
  return (__cil_tmp5);
}
}
#line 897
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi8)(char __b7 , char __b6 ,
                                                                     char __b5 , char __b4 ,
                                                                     char __b3 , char __b2 ,
                                                                     char __b1 , char __b0 ) ;
#line 900
extern int ( /* missing proto */  __builtin_ia32_vec_init_v8qi)() ;
#line 897 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi8)(char __b7 , char __b6 ,
                                                                     char __b5 , char __b4 ,
                                                                     char __b3 , char __b2 ,
                                                                     char __b1 , char __b0 ) 
{ 
  int __cil_tmp9 ;

  {
  {
#line 900
  __cil_tmp9 = __builtin_ia32_vec_init_v8qi((int )__b0, (int )__b1, (int )__b2, (int )__b3,
                                            (int )__b4, (int )__b5, (int )__b6, (int )__b7);
  }
#line 900
  return (__cil_tmp9);
}
}
#line 906
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi32)(int __i0 ,
                                                                       int __i1 ) ;
#line 906 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi32)(int __i0 ,
                                                                       int __i1 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 908
  __cil_tmp3 = _mm_set_pi32(__i1, __i0);
  }
#line 908
  return (__cil_tmp3);
}
}
#line 912
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi16)(short __w0 ,
                                                                       short __w1 ,
                                                                       short __w2 ,
                                                                       short __w3 ) ;
#line 912 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi16)(short __w0 ,
                                                                       short __w1 ,
                                                                       short __w2 ,
                                                                       short __w3 ) 
{ 
  __m64 __cil_tmp5 ;

  {
  {
#line 914
  __cil_tmp5 = _mm_set_pi16(__w3, __w2, __w1, __w0);
  }
#line 914
  return (__cil_tmp5);
}
}
#line 918
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi8)(char __b0 ,
                                                                      char __b1 ,
                                                                      char __b2 ,
                                                                      char __b3 ,
                                                                      char __b4 ,
                                                                      char __b5 ,
                                                                      char __b6 ,
                                                                      char __b7 ) ;
#line 918 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi8)(char __b0 ,
                                                                      char __b1 ,
                                                                      char __b2 ,
                                                                      char __b3 ,
                                                                      char __b4 ,
                                                                      char __b5 ,
                                                                      char __b6 ,
                                                                      char __b7 ) 
{ 
  __m64 __cil_tmp9 ;

  {
  {
#line 921
  __cil_tmp9 = _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
  }
#line 921
  return (__cil_tmp9);
}
}
#line 926
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi32)(int __i ) ;
#line 926 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi32)(int __i ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 928
  __cil_tmp2 = _mm_set_pi32(__i, __i);
  }
#line 928
  return (__cil_tmp2);
}
}
#line 933
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi16)(short __w ) ;
#line 933 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi16)(short __w ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 935
  __cil_tmp2 = _mm_set_pi16(__w, __w, __w, __w);
  }
#line 935
  return (__cil_tmp2);
}
}
#line 940
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi8)(char __b ) ;
#line 940 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi8)(char __b ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 942
  __cil_tmp2 = _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
  }
#line 942
  return (__cil_tmp2);
}
}
#line 110 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_undefined_ps)(void) ;
#line 110 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_undefined_ps)(void) 
{ 
  __m128 __Y ;

  {
#line 112
  __Y = __Y;
#line 113
  return (__Y);
}
}
#line 118
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_setzero_ps)(void) ;
#line 118 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_setzero_ps)(void) 
{ 
  __m128 tmp ;

  {
#line 120
  return (tmp);
}
}
#line 128
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 128 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 133
  return;
}
}
#line 152
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ss)(__m128 __A ) ;
#line 154
extern int ( /* missing proto */  __builtin_ia32_sqrtss)() ;
#line 152 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ss)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 154
  __cil_tmp2 = __builtin_ia32_sqrtss(__A);
  }
#line 154
  return (__cil_tmp2);
}
}
#line 158
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ss)(__m128 __A ) ;
#line 160
extern int ( /* missing proto */  __builtin_ia32_rcpss)() ;
#line 158 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ss)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 160
  __cil_tmp2 = __builtin_ia32_rcpss(__A);
  }
#line 160
  return (__cil_tmp2);
}
}
#line 164
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ss)(__m128 __A ) ;
#line 166
extern int ( /* missing proto */  __builtin_ia32_rsqrtss)() ;
#line 164 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ss)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 166
  __cil_tmp2 = __builtin_ia32_rsqrtss(__A);
  }
#line 166
  return (__cil_tmp2);
}
}
#line 170
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 172
extern int ( /* missing proto */  __builtin_ia32_minss)() ;
#line 170 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 172
  __cil_tmp3 = __builtin_ia32_minss(__A, __B);
  }
#line 172
  return (__cil_tmp3);
}
}
#line 176
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 178
extern int ( /* missing proto */  __builtin_ia32_maxss)() ;
#line 176 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 178
  __cil_tmp3 = __builtin_ia32_maxss(__A, __B);
  }
#line 178
  return (__cil_tmp3);
}
}
#line 184
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 184 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 186
  return (__A + __B);
}
}
#line 190
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sub_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 190 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sub_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 192
  return (__A - __B);
}
}
#line 196
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_mul_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 196 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_mul_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 198
  return (__A * __B);
}
}
#line 202
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_div_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 202 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_div_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 204
  return (__A / __B);
}
}
#line 208
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ps)(__m128 __A ) ;
#line 210
extern int ( /* missing proto */  __builtin_ia32_sqrtps)() ;
#line 208 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 210
  __cil_tmp2 = __builtin_ia32_sqrtps(__A);
  }
#line 210
  return (__cil_tmp2);
}
}
#line 214
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ps)(__m128 __A ) ;
#line 216
extern int ( /* missing proto */  __builtin_ia32_rcpps)() ;
#line 214 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 216
  __cil_tmp2 = __builtin_ia32_rcpps(__A);
  }
#line 216
  return (__cil_tmp2);
}
}
#line 220
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ps)(__m128 __A ) ;
#line 222
extern int ( /* missing proto */  __builtin_ia32_rsqrtps)() ;
#line 220 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 222
  __cil_tmp2 = __builtin_ia32_rsqrtps(__A);
  }
#line 222
  return (__cil_tmp2);
}
}
#line 226
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 228
extern int ( /* missing proto */  __builtin_ia32_minps)() ;
#line 226 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 228
  __cil_tmp3 = __builtin_ia32_minps(__A, __B);
  }
#line 228
  return (__cil_tmp3);
}
}
#line 232
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 232 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  float __attribute__((__vector_size__(16)))  __cil_tmp3 ;
  float __attribute__((____vector_size____(16)))  tmp ;

  {
  {
#line 234
  tmp = __builtin_ia32_maxps((float __attribute__((____vector_size____(16)))  )__A,
                             (float __attribute__((____vector_size____(16)))  )__B);
#line 234
  __cil_tmp3 = (float __attribute__((__vector_size__(16)))  )tmp;
  }
#line 234
  return ((__m128 )__cil_tmp3);
}
}
#line 268
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 270
extern int ( /* missing proto */  __builtin_ia32_cmpeqss)() ;
#line 268 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 270
  __cil_tmp3 = __builtin_ia32_cmpeqss(__A, __B);
  }
#line 270
  return (__cil_tmp3);
}
}
#line 274
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 276
extern int ( /* missing proto */  __builtin_ia32_cmpltss)() ;
#line 274 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 276
  __cil_tmp3 = __builtin_ia32_cmpltss(__A, __B);
  }
#line 276
  return (__cil_tmp3);
}
}
#line 280
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 282
extern int ( /* missing proto */  __builtin_ia32_cmpless)() ;
#line 280 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 282
  __cil_tmp3 = __builtin_ia32_cmpless(__A, __B);
  }
#line 282
  return (__cil_tmp3);
}
}
#line 306
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 308
extern int ( /* missing proto */  __builtin_ia32_cmpneqss)() ;
#line 306 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 308
  __cil_tmp3 = __builtin_ia32_cmpneqss(__A, __B);
  }
#line 308
  return (__cil_tmp3);
}
}
#line 312
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 314
extern int ( /* missing proto */  __builtin_ia32_cmpnltss)() ;
#line 312 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 314
  __cil_tmp3 = __builtin_ia32_cmpnltss(__A, __B);
  }
#line 314
  return (__cil_tmp3);
}
}
#line 318
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 320
extern int ( /* missing proto */  __builtin_ia32_cmpnless)() ;
#line 318 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 320
  __cil_tmp3 = __builtin_ia32_cmpnless(__A, __B);
  }
#line 320
  return (__cil_tmp3);
}
}
#line 344
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 346
extern int ( /* missing proto */  __builtin_ia32_cmpordss)() ;
#line 344 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 346
  __cil_tmp3 = __builtin_ia32_cmpordss(__A, __B);
  }
#line 346
  return (__cil_tmp3);
}
}
#line 350
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ss)(__m128 __A ,
                                                                          __m128 __B ) ;
#line 352
extern int ( /* missing proto */  __builtin_ia32_cmpunordss)() ;
#line 350 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ss)(__m128 __A ,
                                                                          __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 352
  __cil_tmp3 = __builtin_ia32_cmpunordss(__A, __B);
  }
#line 352
  return (__cil_tmp3);
}
}
#line 360
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ps)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 362
extern int ( /* missing proto */  __builtin_ia32_cmpeqps)() ;
#line 360 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ps)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 362
  __cil_tmp3 = __builtin_ia32_cmpeqps(__A, __B);
  }
#line 362
  return (__cil_tmp3);
}
}
#line 366
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ps)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 368
extern int ( /* missing proto */  __builtin_ia32_cmpltps)() ;
#line 366 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ps)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 368
  __cil_tmp3 = __builtin_ia32_cmpltps(__A, __B);
  }
#line 368
  return (__cil_tmp3);
}
}
#line 372
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ps)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 374
extern int ( /* missing proto */  __builtin_ia32_cmpleps)() ;
#line 372 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ps)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 374
  __cil_tmp3 = __builtin_ia32_cmpleps(__A, __B);
  }
#line 374
  return (__cil_tmp3);
}
}
#line 390
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 392
extern int ( /* missing proto */  __builtin_ia32_cmpneqps)() ;
#line 390 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 392
  __cil_tmp3 = __builtin_ia32_cmpneqps(__A, __B);
  }
#line 392
  return (__cil_tmp3);
}
}
#line 396
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 398
extern int ( /* missing proto */  __builtin_ia32_cmpnltps)() ;
#line 396 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 398
  __cil_tmp3 = __builtin_ia32_cmpnltps(__A, __B);
  }
#line 398
  return (__cil_tmp3);
}
}
#line 402
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 404
extern int ( /* missing proto */  __builtin_ia32_cmpnleps)() ;
#line 402 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 404
  __cil_tmp3 = __builtin_ia32_cmpnleps(__A, __B);
  }
#line 404
  return (__cil_tmp3);
}
}
#line 420
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 422
extern int ( /* missing proto */  __builtin_ia32_cmpordps)() ;
#line 420 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 422
  __cil_tmp3 = __builtin_ia32_cmpordps(__A, __B);
  }
#line 422
  return (__cil_tmp3);
}
}
#line 426
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ps)(__m128 __A ,
                                                                          __m128 __B ) ;
#line 428
extern int ( /* missing proto */  __builtin_ia32_cmpunordps)() ;
#line 426 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ps)(__m128 __A ,
                                                                          __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 428
  __cil_tmp3 = __builtin_ia32_cmpunordps(__A, __B);
  }
#line 428
  return (__cil_tmp3);
}
}
#line 435
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 437
extern int ( /* missing proto */  __builtin_ia32_comieq)() ;
#line 435 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 437
  __cil_tmp3 = __builtin_ia32_comieq(__A, __B);
  }
#line 437
  return (__cil_tmp3);
}
}
#line 441
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 443
extern int ( /* missing proto */  __builtin_ia32_comilt)() ;
#line 441 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 443
  __cil_tmp3 = __builtin_ia32_comilt(__A, __B);
  }
#line 443
  return (__cil_tmp3);
}
}
#line 447
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 449
extern int ( /* missing proto */  __builtin_ia32_comile)() ;
#line 447 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 449
  __cil_tmp3 = __builtin_ia32_comile(__A, __B);
  }
#line 449
  return (__cil_tmp3);
}
}
#line 453
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 455
extern int ( /* missing proto */  __builtin_ia32_comigt)() ;
#line 453 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = __builtin_ia32_comigt(__A, __B);
  }
#line 455
  return (__cil_tmp3);
}
}
#line 459
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 461
extern int ( /* missing proto */  __builtin_ia32_comige)() ;
#line 459 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 461
  __cil_tmp3 = __builtin_ia32_comige(__A, __B);
  }
#line 461
  return (__cil_tmp3);
}
}
#line 465
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 467
extern int ( /* missing proto */  __builtin_ia32_comineq)() ;
#line 465 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 467
  __cil_tmp3 = __builtin_ia32_comineq(__A, __B);
  }
#line 467
  return (__cil_tmp3);
}
}
#line 471
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 473
extern int ( /* missing proto */  __builtin_ia32_ucomieq)() ;
#line 471 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 473
  __cil_tmp3 = __builtin_ia32_ucomieq(__A, __B);
  }
#line 473
  return (__cil_tmp3);
}
}
#line 477
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 479
extern int ( /* missing proto */  __builtin_ia32_ucomilt)() ;
#line 477 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 479
  __cil_tmp3 = __builtin_ia32_ucomilt(__A, __B);
  }
#line 479
  return (__cil_tmp3);
}
}
#line 483
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 485
extern int ( /* missing proto */  __builtin_ia32_ucomile)() ;
#line 483 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 485
  __cil_tmp3 = __builtin_ia32_ucomile(__A, __B);
  }
#line 485
  return (__cil_tmp3);
}
}
#line 489
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 491
extern int ( /* missing proto */  __builtin_ia32_ucomigt)() ;
#line 489 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 491
  __cil_tmp3 = __builtin_ia32_ucomigt(__A, __B);
  }
#line 491
  return (__cil_tmp3);
}
}
#line 495
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 497
extern int ( /* missing proto */  __builtin_ia32_ucomige)() ;
#line 495 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 497
  __cil_tmp3 = __builtin_ia32_ucomige(__A, __B);
  }
#line 497
  return (__cil_tmp3);
}
}
#line 501
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 503
extern int ( /* missing proto */  __builtin_ia32_ucomineq)() ;
#line 501 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 503
  __cil_tmp3 = __builtin_ia32_ucomineq(__A, __B);
  }
#line 503
  return (__cil_tmp3);
}
}
#line 509
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtss_si32)(__m128 __A ) ;
#line 511
extern int ( /* missing proto */  __builtin_ia32_cvtss2si)() ;
#line 509 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtss_si32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 511
  __cil_tmp2 = __builtin_ia32_cvtss2si(__A);
  }
#line 511
  return (__cil_tmp2);
}
}
#line 515
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvt_ss2si)(__m128 __A ) ;
#line 515 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvt_ss2si)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 517
  __cil_tmp2 = _mm_cvtss_si32(__A);
  }
#line 517
  return (__cil_tmp2);
}
}
#line 526
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtss_si64)(__m128 __A ) ;
#line 528
extern int ( /* missing proto */  __builtin_ia32_cvtss2si64)() ;
#line 526 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtss_si64)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 528
  __cil_tmp2 = __builtin_ia32_cvtss2si64(__A);
  }
#line 528
  return ((long long )__cil_tmp2);
}
}
#line 542
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi32)(__m128 __A ) ;
#line 544
extern int ( /* missing proto */  __builtin_ia32_cvtps2pi)() ;
#line 542 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 544
  __cil_tmp2 = __builtin_ia32_cvtps2pi(__A);
  }
#line 544
  return (__cil_tmp2);
}
}
#line 548
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvt_ps2pi)(__m128 __A ) ;
#line 548 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvt_ps2pi)(__m128 __A ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 550
  __cil_tmp2 = _mm_cvtps_pi32(__A);
  }
#line 550
  return (__cil_tmp2);
}
}
#line 555
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttss_si32)(__m128 __A ) ;
#line 557
extern int ( /* missing proto */  __builtin_ia32_cvttss2si)() ;
#line 555 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttss_si32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 557
  __cil_tmp2 = __builtin_ia32_cvttss2si(__A);
  }
#line 557
  return (__cil_tmp2);
}
}
#line 561
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtt_ss2si)(__m128 __A ) ;
#line 561 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtt_ss2si)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 563
  __cil_tmp2 = _mm_cvttss_si32(__A);
  }
#line 563
  return (__cil_tmp2);
}
}
#line 571
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttss_si64)(__m128 __A ) ;
#line 573
extern int ( /* missing proto */  __builtin_ia32_cvttss2si64)() ;
#line 571 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttss_si64)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 573
  __cil_tmp2 = __builtin_ia32_cvttss2si64(__A);
  }
#line 573
  return ((long long )__cil_tmp2);
}
}
#line 587
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttps_pi32)(__m128 __A ) ;
#line 589
extern int ( /* missing proto */  __builtin_ia32_cvttps2pi)() ;
#line 587 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttps_pi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 589
  __cil_tmp2 = __builtin_ia32_cvttps2pi(__A);
  }
#line 589
  return (__cil_tmp2);
}
}
#line 593
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtt_ps2pi)(__m128 __A ) ;
#line 593 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtt_ps2pi)(__m128 __A ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 595
  __cil_tmp2 = _mm_cvttps_pi32(__A);
  }
#line 595
  return (__cil_tmp2);
}
}
#line 600
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_ss)(__m128 __A ,
                                                                         int __B ) ;
#line 600 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_ss)(__m128 __A ,
                                                                         int __B ) 
{ 


  {
#line 605
  return;
}
}
#line 606
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_si2ss)(__m128 __A ,
                                                                        int __B ) ;
#line 606 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_si2ss)(__m128 __A ,
                                                                        int __B ) 
{ 
  __m128 __cil_tmp3 ;

  {
  {
#line 608
  __cil_tmp3 = _mm_cvtsi32_ss(__A, __B);
  }
#line 608
  return (__cil_tmp3);
}
}
#line 616
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi64_ss)(__m128 __A ,
                                                                         long long __B ) ;
#line 616 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi64_ss)(__m128 __A ,
                                                                         long long __B ) 
{ 


  {
#line 621
  return;
}
}
#line 632
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32_ps)(__m128 __A ,
                                                                         __m64 __B ) ;
#line 634
extern int ( /* missing proto */  __builtin_ia32_cvtpi2ps)() ;
#line 632 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32_ps)(__m128 __A ,
                                                                         __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 634
  __cil_tmp3 = __builtin_ia32_cvtpi2ps(__A, __B);
  }
#line 634
  return (__cil_tmp3);
}
}
#line 638
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_pi2ps)(__m128 __A ,
                                                                        __m64 __B ) ;
#line 638 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_pi2ps)(__m128 __A ,
                                                                        __m64 __B ) 
{ 
  __m128 __cil_tmp3 ;

  {
  {
#line 640
  __cil_tmp3 = _mm_cvtpi32_ps(__A, __B);
  }
#line 640
  return (__cil_tmp3);
}
}
#line 645
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi16_ps)(__m64 __A ) ;
#line 645 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi16_ps)(__m64 __A ) 
{ 
  __v4hi __sign ;
  __v2si __hisi ;
  __v2si __losi ;
  __v4sf __zero ;
  __v4sf __ra ;
  __v4sf __rb ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  __m128 __cil_tmp11 ;

  {
  {
#line 654
  __sign = __builtin_ia32_pcmpgtw((__v4hi )0LL, __A);
#line 657
  __cil_tmp9 = __builtin_ia32_punpcklwd(__A, __sign);
#line 657
  __losi = __cil_tmp9;
#line 658
  __cil_tmp10 = __builtin_ia32_punpckhwd(__A, __sign);
#line 658
  __hisi = __cil_tmp10;
#line 661
  __cil_tmp11 = _mm_setzero_ps();
#line 661
  __zero = __cil_tmp11;
#line 662
  __ra = __builtin_ia32_cvtpi2ps(__zero, __losi);
#line 663
  __rb = __builtin_ia32_cvtpi2ps(__ra, __hisi);
  }
#line 665
  return;
}
}
#line 670
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu16_ps)(__m64 __A ) ;
#line 670 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu16_ps)(__m64 __A ) 
{ 
  __v2si __hisi ;
  __v2si __losi ;
  __v4sf __zero ;
  __v4sf __ra ;
  __v4sf __rb ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  __m128 __cil_tmp9 ;

  {
  {
#line 676
  __cil_tmp7 = __builtin_ia32_punpcklwd(__A, (__v4hi )0LL);
#line 676
  __losi = __cil_tmp7;
#line 677
  __cil_tmp8 = __builtin_ia32_punpckhwd(__A, (__v4hi )0LL);
#line 677
  __hisi = __cil_tmp8;
#line 680
  __cil_tmp9 = _mm_setzero_ps();
#line 680
  __zero = __cil_tmp9;
#line 681
  __ra = __builtin_ia32_cvtpi2ps(__zero, __losi);
#line 682
  __rb = __builtin_ia32_cvtpi2ps(__ra, __hisi);
  }
#line 684
  return;
}
}
#line 689
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi8_ps)(__m64 __A ) ;
#line 689 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi8_ps)(__m64 __A ) 
{ 
  __v8qi __sign ;
  int __cil_tmp4 ;
  __m128 __cil_tmp5 ;

  {
  {
#line 696
  __sign = __builtin_ia32_pcmpgtb((__v8qi )0LL, __A);
#line 699
  __cil_tmp4 = __builtin_ia32_punpcklbw(__A, __sign);
#line 699
  __A = __cil_tmp4;
#line 701
  __cil_tmp5 = _mm_cvtpi16_ps(__A);
  }
#line 701
  return (__cil_tmp5);
}
}
#line 706
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu8_ps)(__m64 __A ) ;
#line 706 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu8_ps)(__m64 __A ) 
{ 
  int __cil_tmp2 ;
  __m128 __cil_tmp3 ;

  {
  {
#line 708
  __cil_tmp2 = __builtin_ia32_punpcklbw(__A, (__v8qi )0LL);
#line 708
  __A = __cil_tmp2;
#line 709
  __cil_tmp3 = _mm_cvtpu16_ps(__A);
  }
#line 709
  return (__cil_tmp3);
}
}
#line 714
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32x2_ps)(__m64 __A ,
                                                                           __m64 __B ) ;
#line 714 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32x2_ps)(__m64 __A ,
                                                                           __m64 __B ) 
{ 
  __v4sf __zero ;
  __m128 __cil_tmp4 ;
  __v4sf __sfa ;
  int __cil_tmp6 ;
  __v4sf __sfb ;
  int __cil_tmp8 ;

  {
  {
#line 716
  __cil_tmp4 = _mm_setzero_ps();
#line 716
  __zero = __cil_tmp4;
#line 717
  __cil_tmp6 = __builtin_ia32_cvtpi2ps(__zero, __A);
#line 717
  __sfa = __cil_tmp6;
#line 718
  __cil_tmp8 = __builtin_ia32_cvtpi2ps(__sfa, __B);
#line 718
  __sfb = __cil_tmp8;
  }
#line 720
  return;
}
}
#line 724
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi16)(__m128 __A ) ;
#line 724 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi16)(__m128 __A ) 
{ 
  __v4sf __hisf ;
  __v4sf __losf ;
  __v2si __hisi ;
  int __cil_tmp5 ;
  __v2si __losi ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 726
  __hisf = __A;
#line 727
  __losf = 0;
#line 728
  __cil_tmp5 = __builtin_ia32_cvtps2pi(__hisf);
#line 728
  __hisi = __cil_tmp5;
#line 729
  __cil_tmp7 = __builtin_ia32_cvtps2pi(__losf);
#line 729
  __losi = __cil_tmp7;
#line 730
  __cil_tmp8 = __builtin_ia32_packssdw(__hisi, __losi);
  }
#line 730
  return (__cil_tmp8);
}
}
#line 735
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi8)(__m128 __A ) ;
#line 735 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi8)(__m128 __A ) 
{ 
  __v4hi __tmp ;
  __m64 __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 737
  __cil_tmp3 = _mm_cvtps_pi16(__A);
#line 737
  __tmp = __cil_tmp3;
#line 738
  __cil_tmp4 = __builtin_ia32_packsswb(__tmp, (__v4hi )0LL);
  }
#line 738
  return (__cil_tmp4);
}
}
#line 771
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadh_pi)(__m128 __A ,
                                                                       __m64 *__P ) ;
#line 771 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadh_pi)(__m128 __A ,
                                                                       __m64 *__P ) 
{ 


  {
#line 776
  return;
}
}
#line 778
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeh_pi)(__m64 *__P ,
                                                                      __m128 __A ) ;
#line 780
extern int ( /* missing proto */  __builtin_ia32_storehps)() ;
#line 778 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeh_pi)(__m64 *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 780
  __builtin_ia32_storehps(__P, __A);
  }
#line 782
  return;
}
}
#line 807
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pi)(__m64 *__P ,
                                                                      __m128 __A ) ;
#line 809
extern int ( /* missing proto */  __builtin_ia32_storelps)() ;
#line 807 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pi)(__m64 *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 809
  __builtin_ia32_storelps(__P, __A);
  }
#line 811
  return;
}
}
#line 814
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_ps)(__m128 __A ) ;
#line 816
extern int ( /* missing proto */  __builtin_ia32_movmskps)() ;
#line 814 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 816
  __cil_tmp2 = __builtin_ia32_movmskps(__A);
  }
#line 816
  return (__cil_tmp2);
}
}
#line 821
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) _mm_getcsr)(void) ;
#line 823
extern int ( /* missing proto */  __builtin_ia32_stmxcsr)() ;
#line 821
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) _mm_getcsr)(void) ;
#line 821 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) _mm_getcsr)(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 823
  __cil_tmp1 = __builtin_ia32_stmxcsr();
  }
#line 823
  return ((unsigned int )__cil_tmp1);
}
}
#line 828
__inline extern unsigned int ( __attribute__((__gnu_inline__)) _MM_GET_EXCEPTION_STATE)(void) ;
#line 828 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) _MM_GET_EXCEPTION_STATE)(void) 
{ 


  {
#line 833
  return (0U);
}
}
#line 853
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_setcsr)(unsigned int __I ) ;
#line 855
extern int ( /* missing proto */  __builtin_ia32_ldmxcsr)() ;
#line 853
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_setcsr)(unsigned int __I ) ;
#line 853 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_setcsr)(unsigned int __I ) 
{ 


  {
  {
#line 855
  __builtin_ia32_ldmxcsr(__I);
  }
#line 857
  return;
}
}
#line 860
__inline extern void ( __attribute__((__gnu_inline__)) _MM_SET_EXCEPTION_STATE)(unsigned int __mask ) ;
#line 860 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _MM_SET_EXCEPTION_STATE)(unsigned int __mask ) 
{ 


  {
#line 865
  return;
}
}
#line 885
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ss)(float __F ) ;
#line 885 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ss)(float __F ) 
{ 
  __v4sf tmp ;

  {
#line 887
  return (tmp);
}
}
#line 898
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps1)(float __F ) ;
#line 898 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps1)(float __F ) 
{ 
  __m128 __cil_tmp2 ;

  {
  {
#line 900
  __cil_tmp2 = _mm_set_ss(__F);
  }
#line 900
  return (__cil_tmp2);
}
}
#line 905
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ss)(float const   *__P ) ;
#line 905 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ss)(float const   *__P ) 
{ 
  __m128 __cil_tmp2 ;

  {
  {
#line 907
  __cil_tmp2 = _mm_set_ss((float )*__P);
  }
#line 907
  return (__cil_tmp2);
}
}
#line 918
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps1)(float const   *__P ) ;
#line 918 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps1)(float const   *__P ) 
{ 
  __m128 __cil_tmp2 ;

  {
  {
#line 920
  __cil_tmp2 = _mm_load_ss(__P);
  }
#line 920
  return (__cil_tmp2);
}
}
#line 925
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps)(float const   *__P ) ;
#line 925 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps)(float const   *__P ) 
{ 


  {
#line 927
  return (*((__m128 *)__P));
}
}
#line 932
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadu_ps)(float const   *__P ) ;
#line 932 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadu_ps)(float const   *__P ) 
{ 


  {
#line 934
  return (*((__m128_u *)__P));
}
}
#line 939
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadr_ps)(float const   *__P ) ;
#line 942
extern int ( /* missing proto */  __builtin_ia32_shufps)() ;
#line 939 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadr_ps)(float const   *__P ) 
{ 
  __v4sf __tmp ;
  int __cil_tmp3 ;

  {
  {
#line 941
  __tmp = *((__v4sf *)__P);
#line 942
  __cil_tmp3 = __builtin_ia32_shufps(__tmp, __tmp, ((1 << 4) | (2 << 2)) | 3);
  }
#line 942
  return (__cil_tmp3);
}
}
#line 947
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps)(float __Z , float __Y ,
                                                                     float __X , float __W ) ;
#line 947 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps)(float __Z , float __Y ,
                                                                     float __X , float __W ) 
{ 
  __v4sf tmp ;

  {
#line 949
  return (tmp);
}
}
#line 961
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ss)(float *__P ,
                                                                     __m128 __A ) ;
#line 961 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ss)(float *__P ,
                                                                     __m128 __A ) 
{ 
  int __cil_tmp3 ;

  {
#line 963
  *__P = (float )__cil_tmp3;
#line 964
  return;
}
}
#line 967
__inline extern float ( __attribute__((__gnu_inline__)) _mm_cvtss_f32)(__m128 __A ) ;
#line 967 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern float ( __attribute__((__gnu_inline__)) _mm_cvtss_f32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
#line 969
  return ((float )__cil_tmp2);
}
}
#line 974
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps)(float *__P ,
                                                                     __m128 __A ) ;
#line 974 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps)(float *__P ,
                                                                     __m128 __A ) 
{ 


  {
#line 976
  *((__m128 *)__P) = __A;
#line 977
  return;
}
}
#line 981
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 981 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 


  {
#line 983
  *((__m128_u *)__P) = __A;
#line 984
  return;
}
}
#line 988
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 988 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 
  __v4sf __va ;
  __v4sf __tmp ;
  int __cil_tmp5 ;

  {
  {
#line 990
  __va = __A;
#line 991
  __cil_tmp5 = __builtin_ia32_shufps(__va, __va, 0);
#line 991
  __tmp = __cil_tmp5;
#line 992
  _mm_storeu_ps(__P, __tmp);
  }
#line 994
  return;
}
}
#line 996
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps1)(float *__P ,
                                                                      __m128 __A ) ;
#line 996 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps1)(float *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 998
  _mm_store1_ps(__P, __A);
  }
#line 1000
  return;
}
}
#line 1003
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 1003 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 
  __v4sf __va ;
  __v4sf __tmp ;
  int __cil_tmp5 ;

  {
  {
#line 1005
  __va = __A;
#line 1006
  __cil_tmp5 = __builtin_ia32_shufps(__va, __va, ((1 << 4) | (2 << 2)) | 3);
#line 1006
  __tmp = __cil_tmp5;
#line 1007
  _mm_store_ps(__P, __tmp);
  }
#line 1009
  return;
}
}
#line 1061
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pi16)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1063
extern int ( /* missing proto */  __builtin_ia32_pmaxsw)() ;
#line 1061 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pi16)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1063
  __cil_tmp3 = __builtin_ia32_pmaxsw(__A, __B);
  }
#line 1063
  return (__cil_tmp3);
}
}
#line 1067
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxsw)(__m64 __A , __m64 __B ) ;
#line 1067 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxsw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1069
  __cil_tmp3 = _mm_max_pi16(__A, __B);
  }
#line 1069
  return (__cil_tmp3);
}
}
#line 1074
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pu8)(__m64 __A , __m64 __B ) ;
#line 1076
extern int ( /* missing proto */  __builtin_ia32_pmaxub)() ;
#line 1074 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1076
  __cil_tmp3 = __builtin_ia32_pmaxub(__A, __B);
  }
#line 1076
  return (__cil_tmp3);
}
}
#line 1080
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxub)(__m64 __A , __m64 __B ) ;
#line 1080 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxub)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1082
  __cil_tmp3 = _mm_max_pu8(__A, __B);
  }
#line 1082
  return (__cil_tmp3);
}
}
#line 1087
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pi16)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1089
extern int ( /* missing proto */  __builtin_ia32_pminsw)() ;
#line 1087 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pi16)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1089
  __cil_tmp3 = __builtin_ia32_pminsw(__A, __B);
  }
#line 1089
  return (__cil_tmp3);
}
}
#line 1093
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminsw)(__m64 __A , __m64 __B ) ;
#line 1093 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminsw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1095
  __cil_tmp3 = _mm_min_pi16(__A, __B);
  }
#line 1095
  return (__cil_tmp3);
}
}
#line 1100
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pu8)(__m64 __A , __m64 __B ) ;
#line 1102
extern int ( /* missing proto */  __builtin_ia32_pminub)() ;
#line 1100 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1102
  __cil_tmp3 = __builtin_ia32_pminub(__A, __B);
  }
#line 1102
  return (__cil_tmp3);
}
}
#line 1106
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminub)(__m64 __A , __m64 __B ) ;
#line 1106 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminub)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1108
  __cil_tmp3 = _mm_min_pu8(__A, __B);
  }
#line 1108
  return (__cil_tmp3);
}
}
#line 1113
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pi8)(__m64 __A ) ;
#line 1115
extern int ( /* missing proto */  __builtin_ia32_pmovmskb)() ;
#line 1113 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pi8)(__m64 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1115
  __cil_tmp2 = __builtin_ia32_pmovmskb(__A);
  }
#line 1115
  return (__cil_tmp2);
}
}
#line 1119
__inline extern int ( __attribute__((__gnu_inline__)) _m_pmovmskb)(__m64 __A ) ;
#line 1119 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _m_pmovmskb)(__m64 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1121
  __cil_tmp2 = _mm_movemask_pi8(__A);
  }
#line 1121
  return (__cil_tmp2);
}
}
#line 1127
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pu16)(__m64 __A ,
                                                                        __m64 __B ) ;
#line 1129
extern int ( /* missing proto */  __builtin_ia32_pmulhuw)() ;
#line 1127 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pu16)(__m64 __A ,
                                                                        __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1129
  __cil_tmp3 = __builtin_ia32_pmulhuw(__A, __B);
  }
#line 1129
  return (__cil_tmp3);
}
}
#line 1133
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhuw)(__m64 __A , __m64 __B ) ;
#line 1133 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhuw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1135
  __cil_tmp3 = _mm_mulhi_pu16(__A, __B);
  }
#line 1135
  return (__cil_tmp3);
}
}
#line 1163
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmove_si64)(__m64 __A ,
                                                                          __m64 __N ,
                                                                          char *__P ) ;
#line 1165
extern int ( /* missing proto */  __builtin_ia32_maskmovq)() ;
#line 1163 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmove_si64)(__m64 __A ,
                                                                          __m64 __N ,
                                                                          char *__P ) 
{ 


  {
  {
#line 1165
  __builtin_ia32_maskmovq(__A, __N, __P);
  }
#line 1167
  return;
}
}
#line 1169
__inline extern void ( __attribute__((__gnu_inline__)) _m_maskmovq)(__m64 __A , __m64 __N ,
                                                                    char *__P ) ;
#line 1169 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _m_maskmovq)(__m64 __A , __m64 __N ,
                                                                    char *__P ) 
{ 


  {
  {
#line 1171
  _mm_maskmove_si64(__A, __N, __P);
  }
#line 1173
  return;
}
}
#line 1176
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu8)(__m64 __A , __m64 __B ) ;
#line 1178
extern int ( /* missing proto */  __builtin_ia32_pavgb)() ;
#line 1176 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1178
  __cil_tmp3 = __builtin_ia32_pavgb(__A, __B);
  }
#line 1178
  return (__cil_tmp3);
}
}
#line 1182
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgb)(__m64 __A , __m64 __B ) ;
#line 1182 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgb)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1184
  __cil_tmp3 = _mm_avg_pu8(__A, __B);
  }
#line 1184
  return (__cil_tmp3);
}
}
#line 1189
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu16)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1191
extern int ( /* missing proto */  __builtin_ia32_pavgw)() ;
#line 1189 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu16)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1191
  __cil_tmp3 = __builtin_ia32_pavgw(__A, __B);
  }
#line 1191
  return (__cil_tmp3);
}
}
#line 1195
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgw)(__m64 __A , __m64 __B ) ;
#line 1195 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1197
  __cil_tmp3 = _mm_avg_pu16(__A, __B);
  }
#line 1197
  return (__cil_tmp3);
}
}
#line 1204
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sad_pu8)(__m64 __A , __m64 __B ) ;
#line 1206
extern int ( /* missing proto */  __builtin_ia32_psadbw)() ;
#line 1204 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sad_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1206
  __cil_tmp3 = __builtin_ia32_psadbw(__A, __B);
  }
#line 1206
  return (__cil_tmp3);
}
}
#line 1210
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psadbw)(__m64 __A , __m64 __B ) ;
#line 1210 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psadbw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1212
  __cil_tmp3 = _mm_sad_pu8(__A, __B);
  }
#line 1212
  return (__cil_tmp3);
}
}
#line 1217
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pi)(__m64 *__P ,
                                                                      __m64 __A ) ;
#line 1217 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pi)(__m64 *__P ,
                                                                      __m64 __A ) 
{ 


  {
#line 1222
  return;
}
}
#line 1224
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 1226
extern int ( /* missing proto */  __builtin_ia32_movntps)() ;
#line 1224 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 1226
  __builtin_ia32_movntps(__P, __A);
  }
#line 1228
  return;
}
}
#line 1232
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_sfence)(void) ;
#line 1234
extern int ( /* missing proto */  __builtin_ia32_sfence)() ;
#line 1232
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_sfence)(void) ;
#line 1232 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_sfence)(void) 
{ 


  {
  {
#line 1234
  __builtin_ia32_sfence();
  }
#line 1236
  return;
}
}
#line 66 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_sd)(double __F ) ;
#line 66 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_sd)(double __F ) 
{ 
  __m128d tmp ;

  {
#line 68
  return (tmp);
}
}
#line 79
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd1)(double __F ) ;
#line 79 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd1)(double __F ) 
{ 
  __m128d __cil_tmp2 ;

  {
  {
#line 81
  __cil_tmp2 = _mm_set_sd(__F);
  }
#line 81
  return (__cil_tmp2);
}
}
#line 86
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd)(double __W ,
                                                                      double __X ) ;
#line 86 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd)(double __W ,
                                                                      double __X ) 
{ 
  __m128d tmp ;

  {
#line 88
  return (tmp);
}
}
#line 100
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_undefined_pd)(void) ;
#line 100 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_undefined_pd)(void) 
{ 
  __m128d __Y ;

  {
#line 102
  __Y = __Y;
#line 103
  return (__Y);
}
}
#line 108
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_setzero_pd)(void) ;
#line 108 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_setzero_pd)(void) 
{ 
  __m128d tmp ;

  {
#line 110
  return (tmp);
}
}
#line 115
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_move_sd)(__m128d __A ,
                                                                       __m128d __B ) ;
#line 115 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_move_sd)(__m128d __A ,
                                                                       __m128d __B ) 
{ 


  {
#line 120
  return;
}
}
#line 122
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd)(double const   *__P ) ;
#line 122 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd)(double const   *__P ) 
{ 


  {
#line 124
  return (*((__m128d *)__P));
}
}
#line 129
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadu_pd)(double const   *__P ) ;
#line 129 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadu_pd)(double const   *__P ) 
{ 


  {
#line 131
  return (*((__m128d_u *)__P));
}
}
#line 136
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load1_pd)(double const   *__P ) ;
#line 136 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load1_pd)(double const   *__P ) 
{ 
  __m128d __cil_tmp2 ;

  {
  {
#line 138
  __cil_tmp2 = _mm_set_sd((double )*__P);
  }
#line 138
  return (__cil_tmp2);
}
}
#line 149
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd1)(double const   *__P ) ;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd1)(double const   *__P ) 
{ 
  __m128d __cil_tmp2 ;

  {
  {
#line 151
  __cil_tmp2 = _mm_load1_pd(__P);
  }
#line 151
  return (__cil_tmp2);
}
}
#line 156
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadr_pd)(double const   *__P ) ;
#line 159
extern int ( /* missing proto */  __builtin_ia32_shufpd)() ;
#line 156 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadr_pd)(double const   *__P ) 
{ 
  __m128d __tmp ;
  __m128d __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 158
  __cil_tmp3 = _mm_load_pd(__P);
#line 158
  __tmp = __cil_tmp3;
#line 159
  __cil_tmp4 = __builtin_ia32_shufpd(__tmp, __tmp, 1);
  }
#line 159
  return (__cil_tmp4);
}
}
#line 164
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd)(double *__P ,
                                                                     __m128d __A ) ;
#line 164 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd)(double *__P ,
                                                                     __m128d __A ) 
{ 


  {
#line 166
  *((__m128d *)__P) = __A;
#line 167
  return;
}
}
#line 171
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 171 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 


  {
#line 173
  *((__m128d_u *)__P) = __A;
#line 174
  return;
}
}
#line 178
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_sd)(double *__P ,
                                                                     __m128d __A ) ;
#line 178 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_sd)(double *__P ,
                                                                     __m128d __A ) 
{ 
  int __cil_tmp3 ;

  {
#line 180
  *__P = (double )__cil_tmp3;
#line 181
  return;
}
}
#line 184
__inline extern double ( __attribute__((__gnu_inline__)) _mm_cvtsd_f64)(__m128d __A ) ;
#line 184 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern double ( __attribute__((__gnu_inline__)) _mm_cvtsd_f64)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
#line 186
  return ((double )__cil_tmp2);
}
}
#line 190
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 190 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 


  {
  {
#line 192
  _mm_store_sd(__P, __A);
  }
#line 194
  return;
}
}
#line 205
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 205 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 207
  __cil_tmp3 = __builtin_ia32_shufpd(__A, __A, 0);
#line 207
  _mm_store_pd(__P, __cil_tmp3);
  }
#line 209
  return;
}
}
#line 211
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd1)(double *__P ,
                                                                      __m128d __A ) ;
#line 211 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd1)(double *__P ,
                                                                      __m128d __A ) 
{ 


  {
  {
#line 213
  _mm_store1_pd(__P, __A);
  }
#line 215
  return;
}
}
#line 218
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 218 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 220
  __cil_tmp3 = __builtin_ia32_shufpd(__A, __A, 1);
#line 220
  _mm_store_pd(__P, __cil_tmp3);
  }
#line 222
  return;
}
}
#line 224
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si32)(__m128i __A ) ;
#line 226
extern int ( /* missing proto */  __builtin_ia32_vec_ext_v4si)() ;
#line 224 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si32)(__m128i __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 226
  __cil_tmp2 = __builtin_ia32_vec_ext_v4si(__A, 0);
  }
#line 226
  return (__cil_tmp2);
}
}
#line 232
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si64)(__m128i __A ) ;
#line 232 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si64)(__m128i __A ) 
{ 
  int __cil_tmp2 ;

  {
#line 234
  return ((long long )__cil_tmp2);
}
}
#line 246
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_add_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 246 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_add_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 248
  return (__A + __B);
}
}
#line 258
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sub_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 258 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sub_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 260
  return (__A - __B);
}
}
#line 270
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_mul_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 270 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_mul_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 272
  return (__A * __B);
}
}
#line 282
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_div_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 282 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_div_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 284
  return (__A / __B);
}
}
#line 294
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_pd)(__m128d __A ) ;
#line 296
extern int ( /* missing proto */  __builtin_ia32_sqrtpd)() ;
#line 294 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_pd)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 296
  __cil_tmp2 = __builtin_ia32_sqrtpd(__A);
  }
#line 296
  return (__cil_tmp2);
}
}
#line 301
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_sd)(__m128d __A ,
                                                                       __m128d __B ) ;
#line 304
extern int ( /* missing proto */  __builtin_ia32_sqrtsd)() ;
#line 301 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_sd)(__m128d __A ,
                                                                       __m128d __B ) 
{ 
  __v2df __tmp ;
  int __cil_tmp4 ;

  {
  {
#line 303
  __tmp = 0;
#line 304
  __cil_tmp4 = __builtin_ia32_sqrtsd(__tmp);
  }
#line 304
  return (__cil_tmp4);
}
}
#line 308
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 310
extern int ( /* missing proto */  __builtin_ia32_minpd)() ;
#line 308 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 310
  __cil_tmp3 = __builtin_ia32_minpd(__A, __B);
  }
#line 310
  return (__cil_tmp3);
}
}
#line 314
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 316
extern int ( /* missing proto */  __builtin_ia32_minsd)() ;
#line 314 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 316
  __cil_tmp3 = __builtin_ia32_minsd(__A, __B);
  }
#line 316
  return (__cil_tmp3);
}
}
#line 320
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 322
extern int ( /* missing proto */  __builtin_ia32_maxpd)() ;
#line 320 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 322
  __cil_tmp3 = __builtin_ia32_maxpd(__A, __B);
  }
#line 322
  return (__cil_tmp3);
}
}
#line 326
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 328
extern int ( /* missing proto */  __builtin_ia32_maxsd)() ;
#line 326 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 328
  __cil_tmp3 = __builtin_ia32_maxsd(__A, __B);
  }
#line 328
  return (__cil_tmp3);
}
}
#line 356
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_pd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 358
extern int ( /* missing proto */  __builtin_ia32_cmpeqpd)() ;
#line 356 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_pd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 358
  __cil_tmp3 = __builtin_ia32_cmpeqpd(__A, __B);
  }
#line 358
  return (__cil_tmp3);
}
}
#line 362
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_pd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 364
extern int ( /* missing proto */  __builtin_ia32_cmpltpd)() ;
#line 362 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_pd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 364
  __cil_tmp3 = __builtin_ia32_cmpltpd(__A, __B);
  }
#line 364
  return (__cil_tmp3);
}
}
#line 368
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_pd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 370
extern int ( /* missing proto */  __builtin_ia32_cmplepd)() ;
#line 368 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_pd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 370
  __cil_tmp3 = __builtin_ia32_cmplepd(__A, __B);
  }
#line 370
  return (__cil_tmp3);
}
}
#line 386
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 388
extern int ( /* missing proto */  __builtin_ia32_cmpneqpd)() ;
#line 386 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 388
  __cil_tmp3 = __builtin_ia32_cmpneqpd(__A, __B);
  }
#line 388
  return (__cil_tmp3);
}
}
#line 392
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 394
extern int ( /* missing proto */  __builtin_ia32_cmpnltpd)() ;
#line 392 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 394
  __cil_tmp3 = __builtin_ia32_cmpnltpd(__A, __B);
  }
#line 394
  return (__cil_tmp3);
}
}
#line 398
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 400
extern int ( /* missing proto */  __builtin_ia32_cmpnlepd)() ;
#line 398 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 400
  __cil_tmp3 = __builtin_ia32_cmpnlepd(__A, __B);
  }
#line 400
  return (__cil_tmp3);
}
}
#line 416
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 418
extern int ( /* missing proto */  __builtin_ia32_cmpordpd)() ;
#line 416 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 418
  __cil_tmp3 = __builtin_ia32_cmpordpd(__A, __B);
  }
#line 418
  return (__cil_tmp3);
}
}
#line 422
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_pd)(__m128d __A ,
                                                                           __m128d __B ) ;
#line 424
extern int ( /* missing proto */  __builtin_ia32_cmpunordpd)() ;
#line 422 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_pd)(__m128d __A ,
                                                                           __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 424
  __cil_tmp3 = __builtin_ia32_cmpunordpd(__A, __B);
  }
#line 424
  return (__cil_tmp3);
}
}
#line 428
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_sd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 430
extern int ( /* missing proto */  __builtin_ia32_cmpeqsd)() ;
#line 428 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_sd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 430
  __cil_tmp3 = __builtin_ia32_cmpeqsd(__A, __B);
  }
#line 430
  return (__cil_tmp3);
}
}
#line 434
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_sd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 436
extern int ( /* missing proto */  __builtin_ia32_cmpltsd)() ;
#line 434 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_sd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 436
  __cil_tmp3 = __builtin_ia32_cmpltsd(__A, __B);
  }
#line 436
  return (__cil_tmp3);
}
}
#line 440
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_sd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 442
extern int ( /* missing proto */  __builtin_ia32_cmplesd)() ;
#line 440 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_sd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 442
  __cil_tmp3 = __builtin_ia32_cmplesd(__A, __B);
  }
#line 442
  return (__cil_tmp3);
}
}
#line 466
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 468
extern int ( /* missing proto */  __builtin_ia32_cmpneqsd)() ;
#line 466 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 468
  __cil_tmp3 = __builtin_ia32_cmpneqsd(__A, __B);
  }
#line 468
  return (__cil_tmp3);
}
}
#line 472
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 474
extern int ( /* missing proto */  __builtin_ia32_cmpnltsd)() ;
#line 472 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 474
  __cil_tmp3 = __builtin_ia32_cmpnltsd(__A, __B);
  }
#line 474
  return (__cil_tmp3);
}
}
#line 478
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 480
extern int ( /* missing proto */  __builtin_ia32_cmpnlesd)() ;
#line 478 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 480
  __cil_tmp3 = __builtin_ia32_cmpnlesd(__A, __B);
  }
#line 480
  return (__cil_tmp3);
}
}
#line 504
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 506
extern int ( /* missing proto */  __builtin_ia32_cmpordsd)() ;
#line 504 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 506
  __cil_tmp3 = __builtin_ia32_cmpordsd(__A, __B);
  }
#line 506
  return (__cil_tmp3);
}
}
#line 510
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_sd)(__m128d __A ,
                                                                           __m128d __B ) ;
#line 512
extern int ( /* missing proto */  __builtin_ia32_cmpunordsd)() ;
#line 510 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_sd)(__m128d __A ,
                                                                           __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 512
  __cil_tmp3 = __builtin_ia32_cmpunordsd(__A, __B);
  }
#line 512
  return (__cil_tmp3);
}
}
#line 516
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 518
extern int ( /* missing proto */  __builtin_ia32_comisdeq)() ;
#line 516 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 518
  __cil_tmp3 = __builtin_ia32_comisdeq(__A, __B);
  }
#line 518
  return (__cil_tmp3);
}
}
#line 522
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 524
extern int ( /* missing proto */  __builtin_ia32_comisdlt)() ;
#line 522 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 524
  __cil_tmp3 = __builtin_ia32_comisdlt(__A, __B);
  }
#line 524
  return (__cil_tmp3);
}
}
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 530
extern int ( /* missing proto */  __builtin_ia32_comisdle)() ;
#line 528 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 530
  __cil_tmp3 = __builtin_ia32_comisdle(__A, __B);
  }
#line 530
  return (__cil_tmp3);
}
}
#line 534
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 536
extern int ( /* missing proto */  __builtin_ia32_comisdgt)() ;
#line 534 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 536
  __cil_tmp3 = __builtin_ia32_comisdgt(__A, __B);
  }
#line 536
  return (__cil_tmp3);
}
}
#line 540
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 542
extern int ( /* missing proto */  __builtin_ia32_comisdge)() ;
#line 540 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 542
  __cil_tmp3 = __builtin_ia32_comisdge(__A, __B);
  }
#line 542
  return (__cil_tmp3);
}
}
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 548
extern int ( /* missing proto */  __builtin_ia32_comisdneq)() ;
#line 546 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 548
  __cil_tmp3 = __builtin_ia32_comisdneq(__A, __B);
  }
#line 548
  return (__cil_tmp3);
}
}
#line 552
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 554
extern int ( /* missing proto */  __builtin_ia32_ucomisdeq)() ;
#line 552 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 554
  __cil_tmp3 = __builtin_ia32_ucomisdeq(__A, __B);
  }
#line 554
  return (__cil_tmp3);
}
}
#line 558
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 560
extern int ( /* missing proto */  __builtin_ia32_ucomisdlt)() ;
#line 558 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 560
  __cil_tmp3 = __builtin_ia32_ucomisdlt(__A, __B);
  }
#line 560
  return (__cil_tmp3);
}
}
#line 564
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 566
extern int ( /* missing proto */  __builtin_ia32_ucomisdle)() ;
#line 564 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 566
  __cil_tmp3 = __builtin_ia32_ucomisdle(__A, __B);
  }
#line 566
  return (__cil_tmp3);
}
}
#line 570
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 572
extern int ( /* missing proto */  __builtin_ia32_ucomisdgt)() ;
#line 570 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 572
  __cil_tmp3 = __builtin_ia32_ucomisdgt(__A, __B);
  }
#line 572
  return (__cil_tmp3);
}
}
#line 576
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 578
extern int ( /* missing proto */  __builtin_ia32_ucomisdge)() ;
#line 576 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 578
  __cil_tmp3 = __builtin_ia32_ucomisdge(__A, __B);
  }
#line 578
  return (__cil_tmp3);
}
}
#line 582
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_sd)(__m128d __A ,
                                                                       __m128d __B ) ;
#line 584
extern int ( /* missing proto */  __builtin_ia32_ucomisdneq)() ;
#line 582 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_sd)(__m128d __A ,
                                                                       __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 584
  __cil_tmp3 = __builtin_ia32_ucomisdneq(__A, __B);
  }
#line 584
  return (__cil_tmp3);
}
}
#line 590
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64x)(long long __q1 ,
                                                                          long long __q0 ) ;
#line 590 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64x)(long long __q1 ,
                                                                          long long __q0 ) 
{ 
  __v2di tmp ;

  {
#line 592
  return (tmp);
}
}
#line 596
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64)(__m64 __q1 ,
                                                                         __m64 __q0 ) ;
#line 596 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64)(__m64 __q1 ,
                                                                         __m64 __q0 ) 
{ 
  __m128i __cil_tmp3 ;

  {
  {
#line 598
  __cil_tmp3 = _mm_set_epi64x((long long )__q1, (long long )__q0);
  }
#line 598
  return (__cil_tmp3);
}
}
#line 602
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi32)(int __q3 ,
                                                                         int __q2 ,
                                                                         int __q1 ,
                                                                         int __q0 ) ;
#line 602 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi32)(int __q3 ,
                                                                         int __q2 ,
                                                                         int __q1 ,
                                                                         int __q0 ) 
{ 
  __v4si tmp ;

  {
#line 604
  return (tmp);
}
}
#line 608
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi16)(short __q7 ,
                                                                         short __q6 ,
                                                                         short __q5 ,
                                                                         short __q4 ,
                                                                         short __q3 ,
                                                                         short __q2 ,
                                                                         short __q1 ,
                                                                         short __q0 ) ;
#line 608 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi16)(short __q7 ,
                                                                         short __q6 ,
                                                                         short __q5 ,
                                                                         short __q4 ,
                                                                         short __q3 ,
                                                                         short __q2 ,
                                                                         short __q1 ,
                                                                         short __q0 ) 
{ 
  __v8hi tmp ;

  {
#line 611
  return (tmp);
}
}
#line 616
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi8)(char __q15 ,
                                                                        char __q14 ,
                                                                        char __q13 ,
                                                                        char __q12 ,
                                                                        char __q11 ,
                                                                        char __q10 ,
                                                                        char __q09 ,
                                                                        char __q08 ,
                                                                        char __q07 ,
                                                                        char __q06 ,
                                                                        char __q05 ,
                                                                        char __q04 ,
                                                                        char __q03 ,
                                                                        char __q02 ,
                                                                        char __q01 ,
                                                                        char __q00 ) ;
#line 616 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi8)(char __q15 ,
                                                                        char __q14 ,
                                                                        char __q13 ,
                                                                        char __q12 ,
                                                                        char __q11 ,
                                                                        char __q10 ,
                                                                        char __q09 ,
                                                                        char __q08 ,
                                                                        char __q07 ,
                                                                        char __q06 ,
                                                                        char __q05 ,
                                                                        char __q04 ,
                                                                        char __q03 ,
                                                                        char __q02 ,
                                                                        char __q01 ,
                                                                        char __q00 ) 
{ 
  __v16qi tmp ;

  {
#line 621
  return (tmp);
}
}
#line 630
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64x)(long long __A ) ;
#line 630 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64x)(long long __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 632
  __cil_tmp2 = _mm_set_epi64x(__A, __A);
  }
#line 632
  return (__cil_tmp2);
}
}
#line 636
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64)(__m64 __A ) ;
#line 636 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64)(__m64 __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 638
  __cil_tmp2 = _mm_set_epi64(__A, __A);
  }
#line 638
  return (__cil_tmp2);
}
}
#line 642
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi32)(int __A ) ;
#line 642 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi32)(int __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 644
  __cil_tmp2 = _mm_set_epi32(__A, __A, __A, __A);
  }
#line 644
  return (__cil_tmp2);
}
}
#line 648
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi16)(short __A ) ;
#line 648 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi16)(short __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 650
  __cil_tmp2 = _mm_set_epi16(__A, __A, __A, __A, __A, __A, __A, __A);
  }
#line 650
  return (__cil_tmp2);
}
}
#line 654
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi8)(char __A ) ;
#line 654 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi8)(char __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 656
  __cil_tmp2 = _mm_set_epi8(__A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A,
                            __A, __A, __A, __A, __A);
  }
#line 656
  return (__cil_tmp2);
}
}
#line 664
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi64)(__m64 __q0 ,
                                                                          __m64 __q1 ) ;
#line 664 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi64)(__m64 __q0 ,
                                                                          __m64 __q1 ) 
{ 
  __m128i __cil_tmp3 ;

  {
  {
#line 666
  __cil_tmp3 = _mm_set_epi64(__q1, __q0);
  }
#line 666
  return (__cil_tmp3);
}
}
#line 670
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi32)(int __q0 ,
                                                                          int __q1 ,
                                                                          int __q2 ,
                                                                          int __q3 ) ;
#line 670 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi32)(int __q0 ,
                                                                          int __q1 ,
                                                                          int __q2 ,
                                                                          int __q3 ) 
{ 
  __m128i __cil_tmp5 ;

  {
  {
#line 672
  __cil_tmp5 = _mm_set_epi32(__q3, __q2, __q1, __q0);
  }
#line 672
  return (__cil_tmp5);
}
}
#line 676
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi16)(short __q0 ,
                                                                          short __q1 ,
                                                                          short __q2 ,
                                                                          short __q3 ,
                                                                          short __q4 ,
                                                                          short __q5 ,
                                                                          short __q6 ,
                                                                          short __q7 ) ;
#line 676 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi16)(short __q0 ,
                                                                          short __q1 ,
                                                                          short __q2 ,
                                                                          short __q3 ,
                                                                          short __q4 ,
                                                                          short __q5 ,
                                                                          short __q6 ,
                                                                          short __q7 ) 
{ 
  __m128i __cil_tmp9 ;

  {
  {
#line 679
  __cil_tmp9 = _mm_set_epi16(__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);
  }
#line 679
  return (__cil_tmp9);
}
}
#line 683
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi8)(char __q00 ,
                                                                         char __q01 ,
                                                                         char __q02 ,
                                                                         char __q03 ,
                                                                         char __q04 ,
                                                                         char __q05 ,
                                                                         char __q06 ,
                                                                         char __q07 ,
                                                                         char __q08 ,
                                                                         char __q09 ,
                                                                         char __q10 ,
                                                                         char __q11 ,
                                                                         char __q12 ,
                                                                         char __q13 ,
                                                                         char __q14 ,
                                                                         char __q15 ) ;
#line 683 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi8)(char __q00 ,
                                                                         char __q01 ,
                                                                         char __q02 ,
                                                                         char __q03 ,
                                                                         char __q04 ,
                                                                         char __q05 ,
                                                                         char __q06 ,
                                                                         char __q07 ,
                                                                         char __q08 ,
                                                                         char __q09 ,
                                                                         char __q10 ,
                                                                         char __q11 ,
                                                                         char __q12 ,
                                                                         char __q13 ,
                                                                         char __q14 ,
                                                                         char __q15 ) 
{ 
  __m128i __cil_tmp17 ;

  {
  {
#line 688
  __cil_tmp17 = _mm_set_epi8(__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08,
                             __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);
  }
#line 688
  return (__cil_tmp17);
}
}
#line 695
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_load_si128)(__m128i *__P ) ;
#line 695 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_load_si128)(__m128i *__P ) 
{ 


  {
#line 697
  return (*__P);
}
}
#line 701
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadu_si128)(__m128i_u *__P ) ;
#line 701 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadu_si128)(__m128i_u *__P ) 
{ 


  {
#line 703
  return (*__P);
}
}
#line 707
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadl_epi64)(__m128i_u *__P ) ;
#line 707 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadl_epi64)(__m128i_u *__P ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 709
  __cil_tmp2 = _mm_set_epi64((__m64 )0LL, *__P);
  }
#line 709
  return (__cil_tmp2);
}
}
#line 713
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_si128)(__m128i *__P ,
                                                                        __m128i __B ) ;
#line 713 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_si128)(__m128i *__P ,
                                                                        __m128i __B ) 
{ 


  {
#line 715
  *__P = __B;
#line 716
  return;
}
}
#line 719
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_si128)(__m128i_u *__P ,
                                                                         __m128i __B ) ;
#line 719 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_si128)(__m128i_u *__P ,
                                                                         __m128i __B ) 
{ 


  {
#line 721
  *__P = __B;
#line 722
  return;
}
}
#line 725
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_epi64)(__m128i_u *__P ,
                                                                         __m128i __B ) ;
#line 725 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_epi64)(__m128i_u *__P ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
#line 727
  *__P = __cil_tmp3;
#line 728
  return;
}
}
#line 731
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_movepi64_pi64)(__m128i __B ) ;
#line 731 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_movepi64_pi64)(__m128i __B ) 
{ 
  int __cil_tmp2 ;

  {
#line 733
  return (__cil_tmp2);
}
}
#line 737
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_movpi64_epi64)(__m64 __A ) ;
#line 737 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_movpi64_epi64)(__m64 __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 739
  __cil_tmp2 = _mm_set_epi64((__m64 )0LL, __A);
  }
#line 739
  return (__cil_tmp2);
}
}
#line 743
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_move_epi64)(__m128i __A ) ;
#line 743 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_move_epi64)(__m128i __A ) 
{ 


  {
#line 748
  return;
}
}
#line 750
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_undefined_si128)(void) ;
#line 750 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_undefined_si128)(void) 
{ 
  __m128i __Y ;

  {
#line 752
  __Y = __Y;
#line 753
  return (__Y);
}
}
#line 758
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setzero_si128)(void) ;
#line 758 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setzero_si128)(void) 
{ 
  __v4si tmp ;

  {
#line 760
  return (tmp);
}
}
#line 764
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtepi32_pd)(__m128i __A ) ;
#line 764 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtepi32_pd)(__m128i __A ) 
{ 


  {
#line 769
  return;
}
}
#line 770
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtepi32_ps)(__m128i __A ) ;
#line 770 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtepi32_ps)(__m128i __A ) 
{ 


  {
#line 775
  return;
}
}
#line 776
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtpd_epi32)(__m128d __A ) ;
#line 778
extern int ( /* missing proto */  __builtin_ia32_cvtpd2dq)() ;
#line 776 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtpd_epi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 778
  __cil_tmp2 = __builtin_ia32_cvtpd2dq(__A);
  }
#line 778
  return (__cil_tmp2);
}
}
#line 782
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtpd_pi32)(__m128d __A ) ;
#line 784
extern int ( /* missing proto */  __builtin_ia32_cvtpd2pi)() ;
#line 782 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtpd_pi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 784
  __cil_tmp2 = __builtin_ia32_cvtpd2pi(__A);
  }
#line 784
  return (__cil_tmp2);
}
}
#line 788
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpd_ps)(__m128d __A ) ;
#line 790
extern int ( /* missing proto */  __builtin_ia32_cvtpd2ps)() ;
#line 788 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpd_ps)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 790
  __cil_tmp2 = __builtin_ia32_cvtpd2ps(__A);
  }
#line 790
  return (__cil_tmp2);
}
}
#line 794
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttpd_epi32)(__m128d __A ) ;
#line 796
extern int ( /* missing proto */  __builtin_ia32_cvttpd2dq)() ;
#line 794 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttpd_epi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 796
  __cil_tmp2 = __builtin_ia32_cvttpd2dq(__A);
  }
#line 796
  return (__cil_tmp2);
}
}
#line 800
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttpd_pi32)(__m128d __A ) ;
#line 802
extern int ( /* missing proto */  __builtin_ia32_cvttpd2pi)() ;
#line 800 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttpd_pi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 802
  __cil_tmp2 = __builtin_ia32_cvttpd2pi(__A);
  }
#line 802
  return (__cil_tmp2);
}
}
#line 806
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtpi32_pd)(__m64 __A ) ;
#line 808
extern int ( /* missing proto */  __builtin_ia32_cvtpi2pd)() ;
#line 806 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtpi32_pd)(__m64 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 808
  __cil_tmp2 = __builtin_ia32_cvtpi2pd(__A);
  }
#line 808
  return (__cil_tmp2);
}
}
#line 812
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtps_epi32)(__m128 __A ) ;
#line 814
extern int ( /* missing proto */  __builtin_ia32_cvtps2dq)() ;
#line 812 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtps_epi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 814
  __cil_tmp2 = __builtin_ia32_cvtps2dq(__A);
  }
#line 814
  return (__cil_tmp2);
}
}
#line 818
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttps_epi32)(__m128 __A ) ;
#line 820
extern int ( /* missing proto */  __builtin_ia32_cvttps2dq)() ;
#line 818 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttps_epi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 820
  __cil_tmp2 = __builtin_ia32_cvttps2dq(__A);
  }
#line 820
  return (__cil_tmp2);
}
}
#line 824
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtps_pd)(__m128 __A ) ;
#line 824 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtps_pd)(__m128 __A ) 
{ 


  {
#line 829
  return;
}
}
#line 830
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsd_si32)(__m128d __A ) ;
#line 832
extern int ( /* missing proto */  __builtin_ia32_cvtsd2si)() ;
#line 830 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsd_si32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 832
  __cil_tmp2 = __builtin_ia32_cvtsd2si(__A);
  }
#line 832
  return (__cil_tmp2);
}
}
#line 838
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsd_si64)(__m128d __A ) ;
#line 840
extern int ( /* missing proto */  __builtin_ia32_cvtsd2si64)() ;
#line 838 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsd_si64)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 840
  __cil_tmp2 = __builtin_ia32_cvtsd2si64(__A);
  }
#line 840
  return ((long long )__cil_tmp2);
}
}
#line 852
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttsd_si32)(__m128d __A ) ;
#line 854
extern int ( /* missing proto */  __builtin_ia32_cvttsd2si)() ;
#line 852 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttsd_si32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 854
  __cil_tmp2 = __builtin_ia32_cvttsd2si(__A);
  }
#line 854
  return (__cil_tmp2);
}
}
#line 860
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttsd_si64)(__m128d __A ) ;
#line 862
extern int ( /* missing proto */  __builtin_ia32_cvttsd2si64)() ;
#line 860 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttsd_si64)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 862
  __cil_tmp2 = __builtin_ia32_cvttsd2si64(__A);
  }
#line 862
  return ((long long )__cil_tmp2);
}
}
#line 874
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsd_ss)(__m128 __A ,
                                                                       __m128d __B ) ;
#line 876
extern int ( /* missing proto */  __builtin_ia32_cvtsd2ss)() ;
#line 874 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsd_ss)(__m128 __A ,
                                                                       __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 876
  __cil_tmp3 = __builtin_ia32_cvtsd2ss(__A, __B);
  }
#line 876
  return (__cil_tmp3);
}
}
#line 880
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi32_sd)(__m128d __A ,
                                                                          int __B ) ;
#line 880 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi32_sd)(__m128d __A ,
                                                                          int __B ) 
{ 


  {
#line 885
  return;
}
}
#line 888
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi64_sd)(__m128d __A ,
                                                                          long long __B ) ;
#line 888 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi64_sd)(__m128d __A ,
                                                                          long long __B ) 
{ 


  {
#line 893
  return;
}
}
#line 902
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtss_sd)(__m128d __A ,
                                                                        __m128 __B ) ;
#line 902 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtss_sd)(__m128d __A ,
                                                                        __m128 __B ) 
{ 


  {
#line 907
  return;
}
}
#line 932
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadh_pd)(__m128d __A ,
                                                                        double const   *__B ) ;
#line 932 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadh_pd)(__m128d __A ,
                                                                        double const   *__B ) 
{ 


  {
#line 937
  return;
}
}
#line 944
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pd)(__m128d __A ) ;
#line 946
extern int ( /* missing proto */  __builtin_ia32_movmskpd)() ;
#line 944 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pd)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 946
  __cil_tmp2 = __builtin_ia32_movmskpd(__A);
  }
#line 946
  return (__cil_tmp2);
}
}
#line 950
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 952
extern int ( /* missing proto */  __builtin_ia32_packsswb128)() ;
#line 950 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 952
  __cil_tmp3 = __builtin_ia32_packsswb128(__A, __B);
  }
#line 952
  return (__cil_tmp3);
}
}
#line 956
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 958
extern int ( /* missing proto */  __builtin_ia32_packssdw128)() ;
#line 956 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 958
  __cil_tmp3 = __builtin_ia32_packssdw128(__A, __B);
  }
#line 958
  return (__cil_tmp3);
}
}
#line 962
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packus_epi16)(__m128i __A ,
                                                                            __m128i __B ) ;
#line 964
extern int ( /* missing proto */  __builtin_ia32_packuswb128)() ;
#line 962 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packus_epi16)(__m128i __A ,
                                                                            __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 964
  __cil_tmp3 = __builtin_ia32_packuswb128(__A, __B);
  }
#line 964
  return (__cil_tmp3);
}
}
#line 968
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_unpackhi_epi8)(__m128i __A ,
                                                                             __m128i __B ) ;
#line 968 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_unpackhi_epi8)(__m128i __A ,
                                                                             __m128i __B ) 
{ 


  {
#line 973
  return;
}
}
#line 1016
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1016 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 


  {
#line 1018
  return (__A + __B);
}
}
#line 1022
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1022 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1024
  return (__A + __B);
}
}
#line 1028
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1028 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1030
  return (__A + __B);
}
}
#line 1034
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1034 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1036
  return (__A + __B);
}
}
#line 1040
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1042
extern int ( /* missing proto */  __builtin_ia32_paddsb128)() ;
#line 1040 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1042
  __cil_tmp3 = __builtin_ia32_paddsb128(__A, __B);
  }
#line 1042
  return (__cil_tmp3);
}
}
#line 1046
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1048
extern int ( /* missing proto */  __builtin_ia32_paddsw128)() ;
#line 1046 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1048
  __cil_tmp3 = __builtin_ia32_paddsw128(__A, __B);
  }
#line 1048
  return (__cil_tmp3);
}
}
#line 1052
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1054
extern int ( /* missing proto */  __builtin_ia32_paddusb128)() ;
#line 1052 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1054
  __cil_tmp3 = __builtin_ia32_paddusb128(__A, __B);
  }
#line 1054
  return (__cil_tmp3);
}
}
#line 1058
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1060
extern int ( /* missing proto */  __builtin_ia32_paddusw128)() ;
#line 1058 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1060
  __cil_tmp3 = __builtin_ia32_paddusw128(__A, __B);
  }
#line 1060
  return (__cil_tmp3);
}
}
#line 1064
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1064 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 


  {
#line 1066
  return (__A - __B);
}
}
#line 1070
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1070 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1072
  return (__A - __B);
}
}
#line 1076
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1076 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1078
  return (__A - __B);
}
}
#line 1082
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1082 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1084
  return (__A - __B);
}
}
#line 1088
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1090
extern int ( /* missing proto */  __builtin_ia32_psubsb128)() ;
#line 1088 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1090
  __cil_tmp3 = __builtin_ia32_psubsb128(__A, __B);
  }
#line 1090
  return (__cil_tmp3);
}
}
#line 1094
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1096
extern int ( /* missing proto */  __builtin_ia32_psubsw128)() ;
#line 1094 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1096
  __cil_tmp3 = __builtin_ia32_psubsw128(__A, __B);
  }
#line 1096
  return (__cil_tmp3);
}
}
#line 1100
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1102
extern int ( /* missing proto */  __builtin_ia32_psubusb128)() ;
#line 1100 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1102
  __cil_tmp3 = __builtin_ia32_psubusb128(__A, __B);
  }
#line 1102
  return (__cil_tmp3);
}
}
#line 1106
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1108
extern int ( /* missing proto */  __builtin_ia32_psubusw128)() ;
#line 1106 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1108
  __cil_tmp3 = __builtin_ia32_psubusw128(__A, __B);
  }
#line 1108
  return (__cil_tmp3);
}
}
#line 1112
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_madd_epi16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1114
extern int ( /* missing proto */  __builtin_ia32_pmaddwd128)() ;
#line 1112 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_madd_epi16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1114
  __cil_tmp3 = __builtin_ia32_pmaddwd128(__A, __B);
  }
#line 1114
  return (__cil_tmp3);
}
}
#line 1118
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1120
extern int ( /* missing proto */  __builtin_ia32_pmulhw128)() ;
#line 1118 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1120
  __cil_tmp3 = __builtin_ia32_pmulhw128(__A, __B);
  }
#line 1120
  return (__cil_tmp3);
}
}
#line 1124
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mullo_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1124 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mullo_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1126
  return (__A * __B);
}
}
#line 1130
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mul_su32)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1132
extern int ( /* missing proto */  __builtin_ia32_pmuludq)() ;
#line 1130 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mul_su32)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1132
  __cil_tmp3 = __builtin_ia32_pmuludq(__A, __B);
  }
#line 1132
  return (__cil_tmp3);
}
}
#line 1136
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mul_epu32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1138
extern int ( /* missing proto */  __builtin_ia32_pmuludq128)() ;
#line 1136 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mul_epu32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1138
  __cil_tmp3 = __builtin_ia32_pmuludq128(__A, __B);
  }
#line 1138
  return (__cil_tmp3);
}
}
#line 1142
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi16)(__m128i __A ,
                                                                          int __B ) ;
#line 1144
extern int ( /* missing proto */  __builtin_ia32_psllwi128)() ;
#line 1142 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi16)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1144
  __cil_tmp3 = __builtin_ia32_psllwi128(__A, __B);
  }
#line 1144
  return (__cil_tmp3);
}
}
#line 1148
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi32)(__m128i __A ,
                                                                          int __B ) ;
#line 1150
extern int ( /* missing proto */  __builtin_ia32_pslldi128)() ;
#line 1148 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi32)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1150
  __cil_tmp3 = __builtin_ia32_pslldi128(__A, __B);
  }
#line 1150
  return (__cil_tmp3);
}
}
#line 1154
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi64)(__m128i __A ,
                                                                          int __B ) ;
#line 1156
extern int ( /* missing proto */  __builtin_ia32_psllqi128)() ;
#line 1154 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi64)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1156
  __cil_tmp3 = __builtin_ia32_psllqi128(__A, __B);
  }
#line 1156
  return (__cil_tmp3);
}
}
#line 1160
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi16)(__m128i __A ,
                                                                          int __B ) ;
#line 1162
extern int ( /* missing proto */  __builtin_ia32_psrawi128)() ;
#line 1160 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi16)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1162
  __cil_tmp3 = __builtin_ia32_psrawi128(__A, __B);
  }
#line 1162
  return (__cil_tmp3);
}
}
#line 1166
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi32)(__m128i __A ,
                                                                          int __B ) ;
#line 1168
extern int ( /* missing proto */  __builtin_ia32_psradi128)() ;
#line 1166 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi32)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1168
  __cil_tmp3 = __builtin_ia32_psradi128(__A, __B);
  }
#line 1168
  return (__cil_tmp3);
}
}
#line 1207
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi16)(__m128i __A ,
                                                                          int __B ) ;
#line 1209
extern int ( /* missing proto */  __builtin_ia32_psrlwi128)() ;
#line 1207 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi16)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1209
  __cil_tmp3 = __builtin_ia32_psrlwi128(__A, __B);
  }
#line 1209
  return (__cil_tmp3);
}
}
#line 1213
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi32)(__m128i __A ,
                                                                          int __B ) ;
#line 1215
extern int ( /* missing proto */  __builtin_ia32_psrldi128)() ;
#line 1213 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi32)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1215
  __cil_tmp3 = __builtin_ia32_psrldi128(__A, __B);
  }
#line 1215
  return (__cil_tmp3);
}
}
#line 1219
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi64)(__m128i __A ,
                                                                          int __B ) ;
#line 1221
extern int ( /* missing proto */  __builtin_ia32_psrlqi128)() ;
#line 1219 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi64)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1221
  __cil_tmp3 = __builtin_ia32_psrlqi128(__A, __B);
  }
#line 1221
  return (__cil_tmp3);
}
}
#line 1225
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1227
extern int ( /* missing proto */  __builtin_ia32_psllw128)() ;
#line 1225 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1227
  __cil_tmp3 = __builtin_ia32_psllw128(__A, __B);
  }
#line 1227
  return (__cil_tmp3);
}
}
#line 1231
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1233
extern int ( /* missing proto */  __builtin_ia32_pslld128)() ;
#line 1231 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1233
  __cil_tmp3 = __builtin_ia32_pslld128(__A, __B);
  }
#line 1233
  return (__cil_tmp3);
}
}
#line 1237
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1239
extern int ( /* missing proto */  __builtin_ia32_psllq128)() ;
#line 1237 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1239
  __cil_tmp3 = __builtin_ia32_psllq128(__A, __B);
  }
#line 1239
  return (__cil_tmp3);
}
}
#line 1243
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1245
extern int ( /* missing proto */  __builtin_ia32_psraw128)() ;
#line 1243 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1245
  __cil_tmp3 = __builtin_ia32_psraw128(__A, __B);
  }
#line 1245
  return (__cil_tmp3);
}
}
#line 1249
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1251
extern int ( /* missing proto */  __builtin_ia32_psrad128)() ;
#line 1249 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1251
  __cil_tmp3 = __builtin_ia32_psrad128(__A, __B);
  }
#line 1251
  return (__cil_tmp3);
}
}
#line 1255
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1257
extern int ( /* missing proto */  __builtin_ia32_psrlw128)() ;
#line 1255 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1257
  __cil_tmp3 = __builtin_ia32_psrlw128(__A, __B);
  }
#line 1257
  return (__cil_tmp3);
}
}
#line 1261
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1263
extern int ( /* missing proto */  __builtin_ia32_psrld128)() ;
#line 1261 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1263
  __cil_tmp3 = __builtin_ia32_psrld128(__A, __B);
  }
#line 1263
  return (__cil_tmp3);
}
}
#line 1267
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1269
extern int ( /* missing proto */  __builtin_ia32_psrlq128)() ;
#line 1267 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1269
  __cil_tmp3 = __builtin_ia32_psrlq128(__A, __B);
  }
#line 1269
  return (__cil_tmp3);
}
}
#line 1273
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_and_si128)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1273 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_and_si128)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1275
  return (__A & __B);
}
}
#line 1285
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_or_si128)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1285 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_or_si128)(__m128i __A ,
                                                                        __m128i __B ) 
{ 


  {
#line 1287
  return (__A | __B);
}
}
#line 1291
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_xor_si128)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1291 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_xor_si128)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1293
  return (__A ^ __B);
}
}
#line 1297
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi8)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1297 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi8)(__m128i __A ,
                                                                          __m128i __B ) 
{ 


  {
#line 1299
  return (__A == __B);
}
}
#line 1303
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1303 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1305
  return (__A == __B);
}
}
#line 1309
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1309 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1311
  return (__A == __B);
}
}
#line 1315
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi8)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1315 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi8)(__m128i __A ,
                                                                          __m128i __B ) 
{ 


  {
#line 1317
  return (__A < __B);
}
}
#line 1321
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1321 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1323
  return (__A < __B);
}
}
#line 1327
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1327 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1329
  return (__A < __B);
}
}
#line 1333
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi8)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1333 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi8)(__m128i __A ,
                                                                          __m128i __B ) 
{ 


  {
#line 1335
  return (__A > __B);
}
}
#line 1339
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1339 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1341
  return (__A > __B);
}
}
#line 1345
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1345 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1347
  return (__A > __B);
}
}
#line 1371
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1373
extern int ( /* missing proto */  __builtin_ia32_pmaxsw128)() ;
#line 1371 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1373
  __cil_tmp3 = __builtin_ia32_pmaxsw128(__A, __B);
  }
#line 1373
  return (__cil_tmp3);
}
}
#line 1377
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1379
extern int ( /* missing proto */  __builtin_ia32_pmaxub128)() ;
#line 1377 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1379
  __cil_tmp3 = __builtin_ia32_pmaxub128(__A, __B);
  }
#line 1379
  return (__cil_tmp3);
}
}
#line 1383
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1385
extern int ( /* missing proto */  __builtin_ia32_pminsw128)() ;
#line 1383 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1385
  __cil_tmp3 = __builtin_ia32_pminsw128(__A, __B);
  }
#line 1385
  return (__cil_tmp3);
}
}
#line 1389
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1391
extern int ( /* missing proto */  __builtin_ia32_pminub128)() ;
#line 1389 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1391
  __cil_tmp3 = __builtin_ia32_pminub128(__A, __B);
  }
#line 1391
  return (__cil_tmp3);
}
}
#line 1395
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_epi8)(__m128i __A ) ;
#line 1397
extern int ( /* missing proto */  __builtin_ia32_pmovmskb128)() ;
#line 1395 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_epi8)(__m128i __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1397
  __cil_tmp2 = __builtin_ia32_pmovmskb128(__A);
  }
#line 1397
  return (__cil_tmp2);
}
}
#line 1401
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epu16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1403
extern int ( /* missing proto */  __builtin_ia32_pmulhuw128)() ;
#line 1401 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epu16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1403
  __cil_tmp3 = __builtin_ia32_pmulhuw128(__A, __B);
  }
#line 1403
  return (__cil_tmp3);
}
}
#line 1434
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmoveu_si128)(__m128i __A ,
                                                                            __m128i __B ,
                                                                            char *__C ) ;
#line 1436
extern int ( /* missing proto */  __builtin_ia32_maskmovdqu)() ;
#line 1434 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmoveu_si128)(__m128i __A ,
                                                                            __m128i __B ,
                                                                            char *__C ) 
{ 


  {
  {
#line 1436
  __builtin_ia32_maskmovdqu(__A, __B, __C);
  }
#line 1438
  return;
}
}
#line 1440
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1442
extern int ( /* missing proto */  __builtin_ia32_pavgb128)() ;
#line 1440 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1442
  __cil_tmp3 = __builtin_ia32_pavgb128(__A, __B);
  }
#line 1442
  return (__cil_tmp3);
}
}
#line 1446
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1448
extern int ( /* missing proto */  __builtin_ia32_pavgw128)() ;
#line 1446 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1448
  __cil_tmp3 = __builtin_ia32_pavgw128(__A, __B);
  }
#line 1448
  return (__cil_tmp3);
}
}
#line 1452
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sad_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1454
extern int ( /* missing proto */  __builtin_ia32_psadbw128)() ;
#line 1452 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sad_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1454
  __cil_tmp3 = __builtin_ia32_psadbw128(__A, __B);
  }
#line 1454
  return (__cil_tmp3);
}
}
#line 1458
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si32)(int *__A ,
                                                                        int __B ) ;
#line 1460
extern int ( /* missing proto */  __builtin_ia32_movnti)() ;
#line 1458 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si32)(int *__A ,
                                                                        int __B ) 
{ 


  {
  {
#line 1460
  __builtin_ia32_movnti(__A, __B);
  }
#line 1462
  return;
}
}
#line 1465
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si64)(long long *__A ,
                                                                        long long __B ) ;
#line 1467
extern int ( /* missing proto */  __builtin_ia32_movnti64)() ;
#line 1465 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si64)(long long *__A ,
                                                                        long long __B ) 
{ 


  {
  {
#line 1467
  __builtin_ia32_movnti64(__A, __B);
  }
#line 1469
  return;
}
}
#line 1472
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si128)(__m128i *__A ,
                                                                         __m128i __B ) ;
#line 1474
extern int ( /* missing proto */  __builtin_ia32_movntdq)() ;
#line 1472 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si128)(__m128i *__A ,
                                                                         __m128i __B ) 
{ 


  {
  {
#line 1474
  __builtin_ia32_movntdq(__A, __B);
  }
#line 1476
  return;
}
}
#line 1478
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pd)(double *__A ,
                                                                      __m128d __B ) ;
#line 1480
extern int ( /* missing proto */  __builtin_ia32_movntpd)() ;
#line 1478 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pd)(double *__A ,
                                                                      __m128d __B ) 
{ 


  {
  {
#line 1480
  __builtin_ia32_movntpd(__A, __B);
  }
#line 1482
  return;
}
}
#line 1484
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_clflush)(void const   *__A ) ;
#line 1486
extern int ( /* missing proto */  __builtin_ia32_clflush)() ;
#line 1484
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_clflush)(void const   *__A ) ;
#line 1484 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_clflush)(void const   *__A ) 
{ 


  {
  {
#line 1486
  __builtin_ia32_clflush(__A);
  }
#line 1488
  return;
}
}
#line 1490
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_lfence)(void) ;
#line 1492
extern int ( /* missing proto */  __builtin_ia32_lfence)() ;
#line 1490
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_lfence)(void) ;
#line 1490 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_lfence)(void) 
{ 


  {
  {
#line 1492
  __builtin_ia32_lfence();
  }
#line 1494
  return;
}
}
#line 1496
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_mfence)(void) ;
#line 1498
extern int ( /* missing proto */  __builtin_ia32_mfence)() ;
#line 1496
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_mfence)(void) ;
#line 1496 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_mfence)(void) 
{ 


  {
  {
#line 1498
  __builtin_ia32_mfence();
  }
#line 1500
  return;
}
}
#line 1502
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si128)(int __A ) ;
#line 1502 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si128)(int __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 1504
  __cil_tmp2 = _mm_set_epi32(0, 0, 0, __A);
  }
#line 1504
  return (__cil_tmp2);
}
}
#line 1510
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si128)(long long __A ) ;
#line 1510 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si128)(long long __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 1512
  __cil_tmp2 = _mm_set_epi64x(0LL, __A);
  }
#line 1512
  return (__cil_tmp2);
}
}
#line 1526
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castpd_ps)(__m128d __A ) ;
#line 1526 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castpd_ps)(__m128d __A ) 
{ 


  {
#line 1528
  return (__A);
}
}
#line 1532
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castpd_si128)(__m128d __A ) ;
#line 1532 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castpd_si128)(__m128d __A ) 
{ 


  {
#line 1534
  return (__A);
}
}
#line 1538
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castps_pd)(__m128 __A ) ;
#line 1538 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castps_pd)(__m128 __A ) 
{ 


  {
#line 1540
  return (__A);
}
}
#line 1544
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castps_si128)(__m128 __A ) ;
#line 1544 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castps_si128)(__m128 __A ) 
{ 


  {
#line 1546
  return (__A);
}
}
#line 1550
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castsi128_ps)(__m128i __A ) ;
#line 1550 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castsi128_ps)(__m128i __A ) 
{ 


  {
#line 1552
  return (__A);
}
}
#line 1556
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castsi128_pd)(__m128i __A ) ;
#line 1556 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castsi128_pd)(__m128i __A ) 
{ 


  {
#line 1558
  return (__A);
}
}
#line 1265 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_pause)(void) ;
#line 1267
extern int ( /* missing proto */  __builtin_ia32_pause)() ;
#line 1265
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_pause)(void) ;
#line 1265 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_pause)(void) 
{ 


  {
  {
#line 1267
  __builtin_ia32_pause();
  }
#line 1269
  return;
}
}
#line 41 "/root/patchweave_new/2/libopenjpeg/mct.c"
static double const   mct_norms[3]  = {      (double const   )1.732,      (double const   )0.829200000001,      (double const   )0.829200000001};
#line 46 "/root/patchweave_new/2/libopenjpeg/mct.c"
static double const   mct_norms_real[3]  = {      (double const   )1.732,      (double const   )1.805,      (double const   )1.573};
#line 51 "/root/patchweave_new/2/libopenjpeg/mct.c"
void mct_encode(int *c0 , int *c1 , int *c2 , int n ) 
{ 
  int i ;
  int r ;
  int g ;
  int b ;
  int y ;
  int u ;
  int v ;

  {
#line 58
  i = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;

#line 58
    if (! (i < n)) {
#line 58
      goto while_break;
    }
#line 59
    r = *(c0 + i);
#line 60
    g = *(c1 + i);
#line 61
    b = *(c2 + i);
#line 62
    y = ((r + g * 2) + b) >> 2;
#line 63
    u = b - g;
#line 64
    v = r - g;
#line 65
    *(c0 + i) = y;
#line 66
    *(c1 + i) = u;
#line 67
    *(c2 + i) = v;
#line 58
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 62
  return;
}
}
#line 74 "/root/patchweave_new/2/libopenjpeg/mct.c"
void mct_decode(int *c0 , int *c1 , int *c2 , int n ) 
{ 
  int i ;
  int y ;
  int u ;
  int v ;
  int g ;
  int r ;
  int b ;

  {
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;

#line 81
    if (! (i < n)) {
#line 81
      goto while_break;
    }
#line 82
    y = *(c0 + i);
#line 83
    u = *(c1 + i);
#line 84
    v = *(c2 + i);
#line 85
    g = y - ((u + v) >> 2);
#line 86
    r = v + g;
#line 87
    b = u + g;
#line 88
    *(c0 + i) = r;
#line 89
    *(c1 + i) = g;
#line 90
    *(c2 + i) = b;
#line 81
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 85
  return;
}
}
#line 97 "/root/patchweave_new/2/libopenjpeg/mct.c"
double mct_getnorm(int compno ) 
{ 


  {
#line 98
  return ((double )mct_norms[compno]);
}
}
#line 104 "/root/patchweave_new/2/libopenjpeg/mct.c"
void mct_encode_real(int *c0 , int *c1 , int *c2 , int n ) 
{ 
  int i ;
  int r ;
  int g ;
  int b ;
  int y ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int u ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int v ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;

#line 111
    if (! (i < n)) {
#line 111
      goto while_break;
    }
    {
#line 112
    r = *(c0 + i);
#line 113
    g = *(c1 + i);
#line 114
    b = *(c2 + i);
#line 115
    __cil_tmp12 = fix_mul(b, 934);
#line 115
    __cil_tmp11 = fix_mul(g, 4809);
#line 115
    __cil_tmp10 = fix_mul(r, 2449);
#line 115
    y = (__cil_tmp10 + __cil_tmp11) + __cil_tmp12;
#line 116
    __cil_tmp16 = fix_mul(b, 4096);
#line 116
    __cil_tmp15 = fix_mul(g, 2714);
#line 116
    __cil_tmp14 = fix_mul(r, 1382);
#line 116
    u = (- __cil_tmp14 - __cil_tmp15) + __cil_tmp16;
#line 117
    __cil_tmp20 = fix_mul(b, 666);
#line 117
    __cil_tmp19 = fix_mul(g, 3430);
#line 117
    __cil_tmp18 = fix_mul(r, 4096);
#line 117
    v = (__cil_tmp18 - __cil_tmp19) - __cil_tmp20;
#line 118
    *(c0 + i) = y;
#line 119
    *(c1 + i) = u;
#line 120
    *(c2 + i) = v;
#line 111
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 115
  return;
}
}
#line 127 "/root/patchweave_new/2/libopenjpeg/mct.c"
void mct_decode_real(float *c0 , float *c1 , float *c2 , int n ) 
{ 
  int i ;
  __m128 vrv ;
  __m128 vgu ;
  __m128 vgv ;
  __m128 vbu ;
  __m128 vy ;
  __m128 vu ;
  __m128 vv ;
  __m128 vr ;
  __m128 vg ;
  __m128 vb ;
  __m128 __cil_tmp23 ;
  __m128 __cil_tmp24 ;
  __m128 __cil_tmp25 ;
  __m128 __cil_tmp26 ;
  __m128 __cil_tmp27 ;
  __m128 __cil_tmp28 ;
  __m128 __cil_tmp29 ;
  __m128 __cil_tmp30 ;
  __m128 __cil_tmp34 ;
  __m128 __cil_tmp35 ;
  __m128 __cil_tmp36 ;
  __m128 __cil_tmp37 ;
  __m128 __cil_tmp38 ;
  __m128 __cil_tmp39 ;
  __m128 __cil_tmp40 ;
  __m128 __cil_tmp41 ;
  float y ;
  float u ;
  float v ;
  float r ;
  float g ;
  float b ;

  {
  {
#line 136
  vrv = _mm_set_ss(1.40199995041f);
#line 137
  vgu = _mm_set_ss(0.344130009413f);
#line 138
  vgv = _mm_set_ss(0.71413999796f);
#line 139
  vbu = _mm_set_ss(1.77199995518f);
#line 140
  i = 0;
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;

#line 140
    if (! (i < n >> 3)) {
#line 140
      goto while_break;
    }
    {
#line 144
    vy = _mm_load_ps((float const   *)c0);
#line 145
    vu = _mm_load_ps((float const   *)c1);
#line 146
    vv = _mm_load_ps((float const   *)c2);
#line 147
    __cil_tmp23 = _mm_mul_ps(vv, vrv);
#line 147
    __cil_tmp24 = _mm_add_ps(vy, __cil_tmp23);
#line 147
    vr = __cil_tmp24;
#line 148
    __cil_tmp25 = _mm_mul_ps(vu, vgu);
#line 148
    __cil_tmp26 = _mm_sub_ps(vy, __cil_tmp25);
#line 148
    __cil_tmp27 = _mm_mul_ps(vv, vgv);
#line 148
    __cil_tmp28 = _mm_sub_ps(__cil_tmp26, __cil_tmp27);
#line 148
    vg = __cil_tmp28;
#line 149
    __cil_tmp29 = _mm_mul_ps(vu, vbu);
#line 149
    __cil_tmp30 = _mm_add_ps(vy, __cil_tmp29);
#line 149
    vb = __cil_tmp30;
#line 150
    _mm_store_ps(c0, vr);
#line 151
    _mm_store_ps(c1, vg);
#line 152
    _mm_store_ps(c2, vb);
#line 153
    c0 += 4;
#line 154
    c1 += 4;
#line 155
    c2 += 4;
#line 157
    vy = _mm_load_ps((float const   *)c0);
#line 158
    vu = _mm_load_ps((float const   *)c1);
#line 159
    vv = _mm_load_ps((float const   *)c2);
#line 160
    __cil_tmp34 = _mm_mul_ps(vv, vrv);
#line 160
    __cil_tmp35 = _mm_add_ps(vy, __cil_tmp34);
#line 160
    vr = __cil_tmp35;
#line 161
    __cil_tmp36 = _mm_mul_ps(vu, vgu);
#line 161
    __cil_tmp37 = _mm_sub_ps(vy, __cil_tmp36);
#line 161
    __cil_tmp38 = _mm_mul_ps(vv, vgv);
#line 161
    __cil_tmp39 = _mm_sub_ps(__cil_tmp37, __cil_tmp38);
#line 161
    vg = __cil_tmp39;
#line 162
    __cil_tmp40 = _mm_mul_ps(vu, vbu);
#line 162
    __cil_tmp41 = _mm_add_ps(vy, __cil_tmp40);
#line 162
    vb = __cil_tmp41;
#line 163
    _mm_store_ps(c0, vr);
#line 164
    _mm_store_ps(c1, vg);
#line 165
    _mm_store_ps(c2, vb);
#line 166
    c0 += 4;
#line 167
    c1 += 4;
#line 168
    c2 += 4;
#line 140
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 170
  n &= 7;
#line 172
  i = 0;
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 172
    if (! (i < n)) {
#line 172
      goto while_break___0;
    }
#line 173
    y = *(c0 + i);
#line 174
    u = *(c1 + i);
#line 175
    v = *(c2 + i);
#line 176
    r = y + v * 1.40199995041f;
#line 177
    g = (y - u * 0.344130009413f) - v * 0.71413999796f;
#line 178
    b = y + u * 1.77199995518f;
#line 179
    *(c0 + i) = r;
#line 180
    *(c1 + i) = g;
#line 181
    *(c2 + i) = b;
#line 172
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 176
  return;
}
}
#line 188 "/root/patchweave_new/2/libopenjpeg/mct.c"
double mct_getnorm_real(int compno ) 
{ 


  {
#line 189
  return ((double )mct_norms_real[compno]);
}
}
#line 37 "/root/patchweave_new/2/libopenjpeg/jpt.c"
unsigned int jpt_read_VBAS_info(opj_cio_t *cio , unsigned int value ) 
{ 
  unsigned char elmt ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = cio_read(cio, 1);
#line 40
  elmt = (unsigned char )__cil_tmp4;
  }
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;

#line 41
    if (! ((int )elmt >> 7 == 1)) {
#line 41
      goto while_break;
    }
    {
#line 42
    value <<= 7;
#line 43
    value |= (unsigned int )((int )elmt & 127);
#line 44
    __cil_tmp5 = cio_read(cio, 1);
#line 44
    elmt = (unsigned char )__cil_tmp5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 46
  value <<= 7;
#line 47
  value |= (unsigned int )((int )elmt & 127);
#line 49
  return (value);
}
}
#line 56 "/root/patchweave_new/2/libopenjpeg/jpt.c"
void jpt_init_msg_header(opj_jpt_msg_header_t *header ) 
{ 


  {
#line 57
  header->Id = 0U;
#line 58
  header->last_byte = 0U;
#line 59
  header->Class_Id = 0U;
#line 60
  header->CSn_Id = 0U;
#line 61
  header->Msg_offset = 0U;
#line 62
  header->Msg_length = 0U;
#line 63
  header->Layer_nb = 0U;
#line 64
  return;
}
}
#line 72 "/root/patchweave_new/2/libopenjpeg/jpt.c"
void jpt_reinit_msg_header(opj_jpt_msg_header_t *header ) 
{ 


  {
#line 73
  header->Id = 0U;
#line 74
  header->last_byte = 0U;
#line 75
  header->Msg_offset = 0U;
#line 76
  header->Msg_length = 0U;
#line 77
  return;
}
}
#line 83 "/root/patchweave_new/2/libopenjpeg/jpt.c"
void jpt_read_msg_header(opj_common_ptr cinfo , opj_cio_t *cio , opj_jpt_msg_header_t *header ) 
{ 
  unsigned char elmt ;
  unsigned char Class ;
  unsigned char CSn ;
  unsigned int __cil_tmp7 ;

  {
  {
#line 84
  Class = (unsigned char)0;
#line 84
  CSn = (unsigned char)0;
#line 85
  jpt_reinit_msg_header(header);
#line 90
  __cil_tmp7 = cio_read(cio, 1);
#line 90
  elmt = (unsigned char )__cil_tmp7;
  }
#line 94
  if ((((int )elmt >> 5) & 3) == 0) {
#line 94
    goto case_0;
  }
#line 97
  if ((((int )elmt >> 5) & 3) == 1) {
#line 97
    goto case_1;
  }
#line 101
  if ((((int )elmt >> 5) & 3) == 2) {
#line 101
    goto case_2;
  }
#line 105
  if ((((int )elmt >> 5) & 3) == 3) {
#line 105
    goto case_3;
  }
#line 109
  goto switch_default;
  case_0: 
  {
#line 95
  opj_event_msg(cinfo, 1, "Forbidden value encounter in message header !!\n");
  }
#line 96
  goto switch_break;
  case_1: 
#line 98
  Class = (unsigned char)0;
#line 99
  CSn = (unsigned char)0;
#line 100
  goto switch_break;
  case_2: 
#line 102
  Class = (unsigned char)1;
#line 103
  CSn = (unsigned char)0;
#line 104
  goto switch_break;
  case_3: 
#line 106
  Class = (unsigned char)1;
#line 107
  CSn = (unsigned char)1;
#line 108
  goto switch_break;
  switch_default: 
#line 110
  goto switch_break;
  switch_break: ;
#line 114
  if ((((int )elmt >> 4) & 1) == 1) {
#line 115
    header->last_byte = 1U;
  }
#line 118
  header->Id |= (unsigned int )((int )elmt & 15);
#line 119
  if ((int )elmt >> 7 == 1) {
    {
#line 120
    header->Id = jpt_read_VBAS_info(cio, header->Id);
    }
  }
#line 125
  if ((int )Class == 1) {
    {
#line 126
    header->Class_Id = 0U;
#line 127
    header->Class_Id = jpt_read_VBAS_info(cio, header->Class_Id);
    }
  }
#line 133
  if ((int )CSn == 1) {
    {
#line 134
    header->CSn_Id = 0U;
#line 135
    header->CSn_Id = jpt_read_VBAS_info(cio, header->CSn_Id);
    }
  }
  {
#line 141
  header->Msg_offset = jpt_read_VBAS_info(cio, header->Msg_offset);
#line 146
  header->Msg_length = jpt_read_VBAS_info(cio, header->Msg_length);
  }
#line 151
  if ((header->Class_Id & 1U) == 1U) {
    {
#line 152
    header->Layer_nb = 0U;
#line 153
    header->Layer_nb = jpt_read_VBAS_info(cio, header->Layer_nb);
    }
  }
#line 156
  return;
}
}
#line 47 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static opj_bool jp2_read_boxhdr(opj_common_ptr cinfo , opj_cio_t *cio , opj_jp2_box_t *box ) ;
#line 55
static opj_bool jp2_read_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 56
static void jp2_write_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 57
static void jp2_write_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 58
static opj_bool jp2_read_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 59
static void jp2_write_colr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 65
static void jp2_write_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 72
static opj_bool jp2_read_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 73
static int jp2_write_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 74
static opj_bool jp2_read_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , unsigned int *j2k_codestream_length ,
                              unsigned int *j2k_codestream_offset ) ;
#line 75
static void jp2_write_jp(opj_cio_t *cio ) ;
#line 82
static opj_bool jp2_read_jp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 90
static opj_bool jp2_read_struct(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) ;
#line 97
static void jp2_apply_pclr(opj_jp2_color_t *color , opj_image_t *image , opj_common_ptr cinfo ) ;
#line 106
static opj_bool jp2_read_pclr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) ;
#line 116
static opj_bool jp2_read_cmap(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) ;
#line 126
static opj_bool jp2_read_colr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) ;
#line 137
static int write_fidx(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                      opj_cio_t *cio ) ;
#line 144
static void write_iptr(int offset , int length , opj_cio_t *cio ) ;
#line 153
static void write_prxy(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                       opj_cio_t *cio ) ;
#line 160 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static opj_bool jp2_read_boxhdr(opj_common_ptr cinfo , opj_cio_t *cio , opj_jp2_box_t *box ) 
{ 
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 161
  box->init_pos = cio_tell(cio);
#line 162
  __cil_tmp5 = cio_read(cio, 4);
#line 162
  box->length = (int )__cil_tmp5;
#line 163
  __cil_tmp6 = cio_read(cio, 4);
#line 163
  box->type = (int )__cil_tmp6;
  }
#line 164
  if (box->length == 1) {
    {
#line 165
    __cil_tmp7 = cio_read(cio, 4);
    }
#line 165
    if (__cil_tmp7 != 0U) {
      {
#line 166
      opj_event_msg(cinfo, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 167
      return (0);
    }
    {
#line 169
    __cil_tmp8 = cio_read(cio, 4);
#line 169
    box->length = (int )__cil_tmp8;
    }
#line 170
    if (box->length == 0) {
      {
#line 171
      __cil_tmp9 = cio_numbytesleft(cio);
#line 171
      box->length = __cil_tmp9 + 12;
      }
    }
  } else
#line 173
  if (box->length == 0) {
    {
#line 174
    __cil_tmp10 = cio_numbytesleft(cio);
#line 174
    box->length = __cil_tmp10 + 8;
    }
  }
#line 176
  if (box->length < 0) {
    {
#line 177
    opj_event_msg(cinfo, 1, "Integer overflow in box->length\n\220");
    }
#line 178
    return (0);
  }
#line 181
  return (1);
}
}
#line 208 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static opj_bool jp2_read_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp5 ;
  void *__cil_tmp9 ;
  int __cil_tmp14 ;

  {
  {
#line 211
  cinfo = jp2->cinfo;
#line 213
  __cil_tmp5 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 213
  if (__cil_tmp5 == 0) {
    {
#line 214
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 215
    return (0);
  }
#line 217
  if (1768449138 != box.type) {
    {
#line 218
    opj_event_msg(cinfo, 1, "Expected IHDR Marker\n");
    }
#line 219
    return (0);
  }
  {
#line 222
  jp2->h = cio_read(cio, 4);
#line 223
  jp2->w = cio_read(cio, 4);
#line 224
  jp2->numcomps = cio_read(cio, 2);
#line 225
  __cil_tmp9 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 225
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp9;
#line 227
  jp2->bpc = cio_read(cio, 1);
#line 229
  jp2->C = cio_read(cio, 1);
#line 230
  jp2->UnkC = cio_read(cio, 1);
#line 231
  jp2->IPR = cio_read(cio, 1);
#line 233
  __cil_tmp14 = cio_tell(cio);
  }
#line 233
  if (__cil_tmp14 - box.init_pos != box.length) {
    {
#line 234
    opj_event_msg(cinfo, 1, "Error with IHDR Box\n\312U");
    }
#line 235
    return (0);
  }
#line 238
  return (1);
}
}
#line 241 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static void jp2_write_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp5 ;

  {
  {
#line 244
  box.init_pos = cio_tell(cio);
#line 245
  cio_skip(cio, 4);
#line 246
  cio_write(cio, 1768449138ULL, 4);
#line 248
  cio_write(cio, (unsigned long long )jp2->h, 4);
#line 249
  cio_write(cio, (unsigned long long )jp2->w, 4);
#line 250
  cio_write(cio, (unsigned long long )jp2->numcomps, 2);
#line 252
  cio_write(cio, (unsigned long long )jp2->bpc, 1);
#line 254
  cio_write(cio, (unsigned long long )jp2->C, 1);
#line 255
  cio_write(cio, (unsigned long long )jp2->UnkC, 1);
#line 256
  cio_write(cio, (unsigned long long )jp2->IPR, 1);
#line 258
  __cil_tmp5 = cio_tell(cio);
#line 258
  box.length = __cil_tmp5 - box.init_pos;
#line 259
  cio_seek(cio, box.init_pos);
#line 260
  cio_write(cio, (unsigned long long )box.length, 4);
#line 261
  cio_seek(cio, box.init_pos + box.length);
  }
#line 263
  return;
}
}
#line 264 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static void jp2_write_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  int __cil_tmp7 ;

  {
  {
#line 268
  box.init_pos = cio_tell(cio);
#line 269
  cio_skip(cio, 4);
#line 270
  cio_write(cio, 1651532643ULL, 4);
#line 272
  i = 0U;
  }
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;

#line 272
    if (! (i < jp2->numcomps)) {
#line 272
      goto while_break;
    }
    {
#line 273
    cio_write(cio, (unsigned long long )(jp2->comps + i)->bpcc, 1);
#line 272
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 276
  __cil_tmp7 = cio_tell(cio);
#line 276
  box.length = __cil_tmp7 - box.init_pos;
#line 277
  cio_seek(cio, box.init_pos);
#line 278
  cio_write(cio, (unsigned long long )box.length, 4);
#line 279
  cio_seek(cio, box.init_pos + box.length);
  }
#line 281
  return;
}
}
#line 283 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static opj_bool jp2_read_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  int __cil_tmp9 ;

  {
  {
#line 287
  cinfo = jp2->cinfo;
#line 289
  __cil_tmp6 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 289
  if (__cil_tmp6 == 0) {
    {
#line 290
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 291
    return (0);
  }
#line 293
  if (1651532643 != box.type) {
    {
#line 294
    opj_event_msg(cinfo, 1, "Expected BPCC Marker\n");
    }
#line 295
    return (0);
  }
#line 298
  i = 0U;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;

#line 298
    if (! (i < jp2->numcomps)) {
#line 298
      goto while_break;
    }
    {
#line 299
    __cil_tmp7 = cio_read(cio, 1);
#line 299
    (jp2->comps + i)->bpcc = (int )__cil_tmp7;
#line 298
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 302
  __cil_tmp9 = cio_tell(cio);
  }
#line 302
  if (__cil_tmp9 - box.init_pos != box.length) {
    {
#line 303
    opj_event_msg(cinfo, 1, "Error with BPCC Box\n");
    }
#line 304
    return (0);
  }
#line 307
  return (1);
}
}
#line 310 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static void jp2_write_colr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp5 ;

  {
  {
#line 313
  box.init_pos = cio_tell(cio);
#line 314
  cio_skip(cio, 4);
#line 315
  cio_write(cio, 1668246642ULL, 4);
#line 317
  cio_write(cio, (unsigned long long )jp2->meth, 1);
#line 318
  cio_write(cio, (unsigned long long )jp2->precedence, 1);
#line 319
  cio_write(cio, (unsigned long long )jp2->approx, 1);
  }
#line 321
  if (jp2->meth == 2U) {
#line 322
    jp2->enumcs = 0U;
  }
  {
#line 324
  cio_write(cio, (unsigned long long )jp2->enumcs, 4);
#line 326
  __cil_tmp5 = cio_tell(cio);
#line 326
  box.length = __cil_tmp5 - box.init_pos;
#line 327
  cio_seek(cio, box.init_pos);
#line 328
  cio_write(cio, (unsigned long long )box.length, 4);
#line 329
  cio_seek(cio, box.init_pos + box.length);
  }
#line 331
  return;
}
}
#line 332 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static void jp2_free_pclr(opj_jp2_color_t *color ) 
{ 


  {
  {
#line 334
  free((void *)(color->jp2_pclr)->channel_sign);
#line 335
  free((void *)(color->jp2_pclr)->channel_size);
#line 336
  free((void *)(color->jp2_pclr)->entries);
  }
#line 338
  if ((color->jp2_pclr)->cmap) {
    {
#line 338
    free((void *)(color->jp2_pclr)->cmap);
    }
  }
  {
#line 340
  free((void *)color->jp2_pclr);
#line 340
  color->jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
  }
#line 342
  return;
}
}
#line 343 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static void free_color_data(opj_jp2_color_t *color ) 
{ 


  {
#line 345
  if (color->jp2_pclr) {
    {
#line 347
    jp2_free_pclr(color);
    }
  }
#line 349
  if (color->jp2_cdef) {
#line 351
    if ((color->jp2_cdef)->info) {
      {
#line 351
      free((void *)(color->jp2_cdef)->info);
      }
    }
    {
#line 352
    free((void *)color->jp2_cdef);
    }
  }
#line 354
  if (color->icc_profile_buf) {
    {
#line 354
    free((void *)color->icc_profile_buf);
    }
  }
#line 357
  return;
}
}
#line 357 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static void jp2_apply_pclr(opj_jp2_color_t *color , opj_image_t *image , opj_common_ptr cinfo ) 
{ 
  opj_image_comp_t *old_comps ;
  opj_image_comp_t *new_comps ;
  unsigned char *channel_size ;
  unsigned char *channel_sign ;
  unsigned int *entries ;
  opj_jp2_cmap_comp_t *cmap ;
  int *src ;
  int *dst ;
  unsigned int j ;
  unsigned int max ;
  unsigned short i ;
  unsigned short nr_channels ;
  unsigned short cmp ;
  unsigned short pcol ;
  int k ;
  int top_k ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;

  {
  {
#line 368
  channel_size = (color->jp2_pclr)->channel_size;
#line 369
  channel_sign = (color->jp2_pclr)->channel_sign;
#line 370
  entries = (color->jp2_pclr)->entries;
#line 371
  cmap = (color->jp2_pclr)->cmap;
#line 372
  nr_channels = (color->jp2_pclr)->nr_channels;
#line 374
  old_comps = image->comps;
#line 375
  __cil_tmp20 = malloc((unsigned long )nr_channels * sizeof(opj_image_comp_t ));
#line 375
  new_comps = (opj_image_comp_t *)__cil_tmp20;
#line 378
  i = (unsigned short)0;
  }
  {
#line 378
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: ;
#line 378
    if (! ((int )i < (int )nr_channels)) {
#line 378
      goto while_break;
    }
#line 380
    pcol = (unsigned short )(cmap + (int )i)->pcol;
#line 380
    cmp = (cmap + (int )i)->cmp;
#line 382
    if ((int )pcol < (int )nr_channels) {
#line 383
      *(new_comps + (int )pcol) = *(old_comps + (int )cmp);
    } else {
      {
#line 386
      opj_event_msg(cinfo, 1, "Error with pcol value %d (max: %d). skipping\n", (int )pcol,
                    (int )nr_channels);
      }
#line 387
      goto while_continue;
    }
#line 390
    if ((int )(cmap + (int )i)->mtyp == 0) {
#line 392
      (old_comps + (int )cmp)->data = (int *)((void *)0);
#line 392
      goto while_continue;
    }
    {
#line 395
    __cil_tmp21 = malloc((unsigned long )((old_comps + (int )cmp)->w * (old_comps + (int )cmp)->h) * sizeof(int ));
#line 395
    (new_comps + (int )pcol)->data = (int *)__cil_tmp21;
#line 397
    (new_comps + (int )pcol)->prec = (int )*(channel_size + (int )i);
#line 398
    (new_comps + (int )pcol)->sgnd = (int )*(channel_sign + (int )i);
#line 378
    i = (unsigned short )((int )i + 1);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 400
  top_k = (int )(color->jp2_pclr)->nr_entries - 1;
#line 402
  i = (unsigned short)0;
  {
#line 402
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: ;
#line 402
    if (! ((int )i < (int )nr_channels)) {
#line 402
      goto while_break___0;
    }
#line 405
    if ((int )(cmap + (int )i)->mtyp == 0) {
#line 405
      goto while_continue___0;
    }
#line 408
    cmp = (cmap + (int )i)->cmp;
#line 408
    pcol = (unsigned short )(cmap + (int )i)->pcol;
#line 409
    src = (old_comps + (int )cmp)->data;
#line 410
    dst = (new_comps + (int )pcol)->data;
#line 411
    max = (unsigned int )((new_comps + (int )pcol)->w * (new_comps + (int )pcol)->h);
#line 413
    j = 0U;
    {
#line 413
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 413
      if (! (j < max)) {
#line 413
        goto while_break___1;
      }
#line 416
      k = *(src + j);
#line 416
      if (k < 0) {
#line 416
        k = 0;
      } else
#line 416
      if (k > top_k) {
#line 416
        k = top_k;
      }
#line 418
      *(dst + j) = (int )*(entries + (k * (int )nr_channels + (int )pcol));
#line 413
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 402
    i = (unsigned short )((int )i + 1);
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
#line 421
  max = (unsigned int )image->numcomps;
#line 422
  i = (unsigned short)0;
  {
#line 422
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 422
    if (! ((unsigned int )i < max)) {
#line 422
      goto while_break___2;
    }
#line 424
    if ((old_comps + (int )i)->data) {
      {
#line 424
      free((void *)(old_comps + (int )i)->data);
      }
    }
#line 422
    i = (unsigned short )((int )i + 1);
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 426
  free((void *)old_comps);
#line 427
  image->comps = new_comps;
#line 428
  image->numcomps = (int )nr_channels;
#line 430
  jp2_free_pclr(color);
  }
#line 432
  return;
}
}
#line 434 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static opj_bool jp2_read_pclr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  opj_jp2_pclr_t *jp2_pclr ;
  unsigned char *channel_size ;
  unsigned char *channel_sign ;
  unsigned int *entries ;
  unsigned short nr_entries ;
  unsigned short nr_channels ;
  unsigned short i ;
  unsigned short j ;
  unsigned char uc ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  int tmp ;
  unsigned int *__cil_tmp22 ;

  {
#line 450
  if (color->jp2_pclr) {
#line 450
    return (0);
  }
  {
#line 452
  __cil_tmp14 = cio_read(cio, 2);
#line 452
  nr_entries = (unsigned short )__cil_tmp14;
#line 453
  __cil_tmp15 = cio_read(cio, 1);
#line 453
  nr_channels = (unsigned short )__cil_tmp15;
#line 455
  __cil_tmp16 = malloc((unsigned long )((int )nr_channels * (int )nr_entries) * sizeof(unsigned int ));
#line 455
  entries = (unsigned int *)__cil_tmp16;
#line 457
  __cil_tmp17 = malloc((unsigned long )nr_channels);
#line 457
  channel_size = (unsigned char *)__cil_tmp17;
#line 458
  __cil_tmp18 = malloc((unsigned long )nr_channels);
#line 458
  channel_sign = (unsigned char *)__cil_tmp18;
#line 460
  __cil_tmp19 = malloc(sizeof(opj_jp2_pclr_t ));
#line 460
  jp2_pclr = (opj_jp2_pclr_t *)__cil_tmp19;
#line 461
  jp2_pclr->channel_sign = channel_sign;
#line 462
  jp2_pclr->channel_size = channel_size;
#line 463
  jp2_pclr->entries = entries;
#line 464
  jp2_pclr->nr_entries = nr_entries;
#line 465
  jp2_pclr->nr_channels = nr_channels;
#line 466
  jp2_pclr->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
#line 468
  color->jp2_pclr = jp2_pclr;
#line 470
  i = (unsigned short)0;
  }
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;

#line 470
    if (! ((int )i < (int )nr_channels)) {
#line 470
      goto while_break;
    }
    {
#line 472
    __cil_tmp20 = cio_read(cio, 1);
#line 472
    uc = (unsigned char )__cil_tmp20;
#line 473
    *(channel_size + (int )i) = (unsigned char )(((int )uc & 127) + 1);
    }
#line 474
    if ((int )uc & 128) {
#line 474
      tmp = 1;
    } else {
#line 474
      tmp = 0;
    }
#line 474
    *(channel_sign + (int )i) = (unsigned char )tmp;
#line 470
    i = (unsigned short )((int )i + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 477
  j = (unsigned short)0;
  {
#line 477
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 477
    if (! ((int )j < (int )nr_entries)) {
#line 477
      goto while_break___0;
    }
#line 479
    i = (unsigned short)0;
    {
#line 479
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 479
      if (! ((int )i < (int )nr_channels)) {
#line 479
        goto while_break___1;
      }
      {
#line 482
      __cil_tmp22 = entries;
#line 482
      entries ++;
#line 482
      *__cil_tmp22 = cio_read(cio, ((int )*(channel_size + (int )i) + 7) >> 3);
#line 479
      i = (unsigned short )((int )i + 1);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 477
    j = (unsigned short )((int )j + 1);
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 486
  return (1);
}
}
#line 489 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static opj_bool jp2_read_cmap(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  opj_jp2_cmap_comp_t *cmap ;
  unsigned short i ;
  unsigned short nr_channels ;
  void *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;

  {
#line 499
  if ((unsigned long )color->jp2_pclr == (unsigned long )((void *)0)) {
#line 499
    return (0);
  }
#line 504
  if ((color->jp2_pclr)->cmap) {
#line 504
    return (0);
  }
  {
#line 506
  nr_channels = (color->jp2_pclr)->nr_channels;
#line 507
  __cil_tmp8 = malloc((unsigned long )nr_channels * sizeof(opj_jp2_cmap_comp_t ));
#line 507
  cmap = (opj_jp2_cmap_comp_t *)__cil_tmp8;
#line 510
  i = (unsigned short)0;
  }
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;

#line 510
    if (! ((int )i < (int )nr_channels)) {
#line 510
      goto while_break;
    }
    {
#line 512
    __cil_tmp9 = cio_read(cio, 2);
#line 512
    (cmap + (int )i)->cmp = (unsigned short )__cil_tmp9;
#line 513
    __cil_tmp10 = cio_read(cio, 1);
#line 513
    (cmap + (int )i)->mtyp = (unsigned char )__cil_tmp10;
#line 514
    __cil_tmp11 = cio_read(cio, 1);
#line 514
    (cmap + (int )i)->pcol = (unsigned char )__cil_tmp11;
#line 510
    i = (unsigned short )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 517
  (color->jp2_pclr)->cmap = cmap;
#line 519
  return (1);
}
}
#line 522 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static void jp2_apply_cdef(opj_image_t *image , opj_jp2_color_t *color ) 
{ 
  opj_jp2_cdef_info_t *info ;
  int color_space ;
  unsigned short i ;
  unsigned short n ;
  unsigned short cn ;
  unsigned short typ ;
  unsigned short asoc ;
  unsigned short acn ;
  opj_image_comp_t saved ;

  {
#line 528
  color_space = (int )image->color_space;
#line 529
  info = (color->jp2_cdef)->info;
#line 530
  n = (color->jp2_cdef)->n;
#line 532
  i = (unsigned short)0;
  {
#line 532
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 532
    if (! ((int )i < (int )n)) {
#line 532
      goto while_break;
    }
#line 535
    asoc = (info + (int )i)->asoc;
#line 535
    if ((int )asoc == 0) {
#line 535
      goto while_continue;
    }
#line 537
    cn = (info + (int )i)->cn;
#line 537
    typ = (info + (int )i)->typ;
#line 537
    acn = (unsigned short )((int )asoc - 1);
#line 539
    if ((int )cn != (int )acn) {
      {
#line 543
      memcpy((void *)(& saved), (void const   *)(image->comps + (int )cn), sizeof(opj_image_comp_t ));
#line 544
      memcpy((void *)(image->comps + (int )cn), (void const   *)(image->comps + (int )acn),
             sizeof(opj_image_comp_t ));
#line 545
      memcpy((void *)(image->comps + (int )acn), (void const   *)(& saved), sizeof(opj_image_comp_t ));
#line 547
      (info + (int )i)->asoc = (unsigned short )((int )cn + 1);
#line 548
      (info + (int )acn)->asoc = (unsigned short )((int )(info + (int )acn)->cn + 1);
      }
    }
#line 532
    i = (unsigned short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 551
  if ((color->jp2_cdef)->info) {
    {
#line 551
    free((void *)(color->jp2_cdef)->info);
    }
  }
  {
#line 553
  free((void *)color->jp2_cdef);
#line 553
  color->jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
  }
#line 555
  return;
}
}
#line 557 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static opj_bool jp2_read_cdef(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  opj_jp2_cdef_info_t *info ;
  unsigned short i ;
  unsigned short n ;
  unsigned int __cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;

  {
#line 569
  if (color->jp2_cdef) {
#line 569
    return (0);
  }
  {
#line 571
  __cil_tmp8 = cio_read(cio, 2);
#line 571
  n = (unsigned short )__cil_tmp8;
  }
#line 571
  if ((int )n == 0) {
#line 571
    return (0);
  }
  {
#line 573
  __cil_tmp9 = malloc((unsigned long )n * sizeof(opj_jp2_cdef_info_t ));
#line 573
  info = (opj_jp2_cdef_info_t *)__cil_tmp9;
#line 576
  __cil_tmp10 = malloc(sizeof(opj_jp2_cdef_t ));
#line 576
  color->jp2_cdef = (opj_jp2_cdef_t *)__cil_tmp10;
#line 577
  (color->jp2_cdef)->info = info;
#line 578
  (color->jp2_cdef)->n = n;
#line 580
  i = (unsigned short)0;
  }
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;

#line 580
    if (! ((int )i < (int )n)) {
#line 580
      goto while_break;
    }
    {
#line 582
    __cil_tmp11 = cio_read(cio, 2);
#line 582
    (info + (int )i)->cn = (unsigned short )__cil_tmp11;
#line 583
    __cil_tmp12 = cio_read(cio, 2);
#line 583
    (info + (int )i)->typ = (unsigned short )__cil_tmp12;
#line 584
    __cil_tmp13 = cio_read(cio, 2);
#line 584
    (info + (int )i)->asoc = (unsigned short )__cil_tmp13;
#line 580
    i = (unsigned short )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 587
  return (1);
}
}
#line 590 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static opj_bool jp2_read_colr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  int skip_len ;
  opj_common_ptr cinfo ;
  int __cil_tmp11 ;
  unsigned char *start ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 599
  if (color->jp2_has_colr) {
#line 599
    return (0);
  }
  {
#line 601
  cinfo = jp2->cinfo;
#line 603
  jp2->meth = cio_read(cio, 1);
#line 604
  jp2->precedence = cio_read(cio, 1);
#line 605
  jp2->approx = cio_read(cio, 1);
  }
#line 607
  if (jp2->meth == 1U) {
    {
#line 609
    jp2->enumcs = cio_read(cio, 4);
    }
  } else
#line 612
  if (jp2->meth == 2U) {
    {
#line 615
    __cil_tmp11 = cio_tell(cio);
#line 615
    skip_len = (box->init_pos + box->length) - __cil_tmp11;
    }
#line 616
    if (skip_len < 0) {
      {
#line 618
      opj_event_msg(cinfo, 1, "Error with COLR box size\n");
      }
#line 619
      return (0);
    }
#line 621
    if (skip_len > 0) {
      {
#line 625
      start = cio_getbp(cio);
#line 626
      __cil_tmp14 = malloc((unsigned long )skip_len);
#line 626
      color->icc_profile_buf = (unsigned char *)__cil_tmp14;
#line 627
      color->icc_profile_len = skip_len;
#line 629
      __cil_tmp15 = cio_tell(cio);
#line 629
      cio_skip(cio, (box->init_pos + box->length) - __cil_tmp15);
#line 631
      memcpy((void *)color->icc_profile_buf, (void const   *)start, (unsigned long )skip_len);
      }
    }
  }
  {
#line 635
  __cil_tmp16 = cio_tell(cio);
  }
#line 635
  if (__cil_tmp16 - box->init_pos != box->length) {
    {
#line 637
    opj_event_msg(cinfo, 1, "Error with COLR Box\n");
    }
#line 638
    return (0);
  }
#line 640
  color->jp2_has_colr = (unsigned char)1;
#line 642
  return (1);
}
}
#line 645 "/root/patchweave_new/2/libopenjpeg/jp2.c"
opj_bool jp2_read_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) 
{ 
  opj_jp2_box_t box ;
  int jp2h_end ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp7 ;
  opj_bool __cil_tmp8 ;
  opj_bool __cil_tmp9 ;
  opj_bool __cil_tmp10 ;
  opj_bool __cil_tmp11 ;
  int __cil_tmp12 ;
  opj_bool __cil_tmp13 ;
  opj_bool __cil_tmp14 ;
  opj_bool __cil_tmp15 ;
  opj_bool __cil_tmp16 ;
  opj_bool __cil_tmp17 ;
  opj_bool __cil_tmp18 ;
  opj_bool __cil_tmp19 ;
  opj_bool __cil_tmp20 ;
  opj_bool __cil_tmp21 ;

  {
  {
#line 650
  cinfo = jp2->cinfo;
#line 652
  __cil_tmp7 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 652
  if (__cil_tmp7 == 0) {
#line 652
    return (0);
  }
  {
#line 653
  while (1) {
    while_continue: /* CIL Label */ ;

#line 654
    if (1785737832 != box.type) {
#line 656
      if (box.type == 1785737827) {
        {
#line 658
        opj_event_msg(cinfo, 1, "Expected JP2H Marker\n");
        }
#line 659
        return (0);
      }
#line 661
      if (box.length <= 8) {
#line 661
        return (0);
      }
      {
#line 662
      cio_skip(cio, box.length - 8);
      }
#line 664
      if ((unsigned long )cio->bp >= (unsigned long )cio->end) {
#line 664
        return (0);
      }
      {
#line 666
      __cil_tmp8 = jp2_read_boxhdr(cinfo, cio, & box);
      }
#line 666
      if (__cil_tmp8 == 0) {
#line 666
        return (0);
      }
    }
#line 653
    if (! (1785737832 != box.type)) {
#line 653
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 670
  __cil_tmp9 = jp2_read_ihdr(jp2, cio);
  }
#line 670
  if (! __cil_tmp9) {
#line 671
    return (0);
  }
#line 672
  jp2h_end = box.init_pos + box.length;
#line 674
  if (jp2->bpc == 255U) {
    {
#line 676
    __cil_tmp10 = jp2_read_bpcc(jp2, cio);
    }
#line 676
    if (! __cil_tmp10) {
#line 677
      return (0);
    }
  }
  {
#line 679
  __cil_tmp11 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 679
  if (__cil_tmp11 == 0) {
#line 679
    return (0);
  }
  {
#line 681
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue___0: 
    {
#line 681
    __cil_tmp12 = cio_tell(cio);
    }
#line 681
    if (! (__cil_tmp12 < jp2h_end)) {
#line 681
      goto while_break___0;
    }
#line 683
    if (box.type == 1668246642) {
      {
#line 685
      __cil_tmp13 = jp2_read_colr(jp2, cio, & box, color);
      }
#line 685
      if (! __cil_tmp13) {
#line 687
        if (box.length <= 8) {
#line 687
          return (0);
        }
        {
#line 688
        cio_seek(cio, box.init_pos + 8);
#line 689
        cio_skip(cio, box.length - 8);
        }
      }
      {
#line 691
      __cil_tmp14 = jp2_read_boxhdr(cinfo, cio, & box);
      }
#line 691
      if (__cil_tmp14 == 0) {
#line 691
        return (0);
      }
#line 692
      goto while_continue___0;
    }
#line 694
    if (box.type == 1667523942) {
#line 694
      if (! jp2->ignore_pclr_cmap_cdef) {
        {
#line 696
        __cil_tmp15 = jp2_read_cdef(jp2, cio, & box, color);
        }
#line 696
        if (! __cil_tmp15) {
#line 698
          if (box.length <= 8) {
#line 698
            return (0);
          }
          {
#line 699
          cio_seek(cio, box.init_pos + 8);
#line 700
          cio_skip(cio, box.length - 8);
          }
        }
        {
#line 702
        __cil_tmp16 = jp2_read_boxhdr(cinfo, cio, & box);
        }
#line 702
        if (__cil_tmp16 == 0) {
#line 702
          return (0);
        }
#line 703
        goto while_continue___0;
      }
    }
#line 705
    if (box.type == 1885564018) {
#line 705
      if (! jp2->ignore_pclr_cmap_cdef) {
        {
#line 707
        __cil_tmp17 = jp2_read_pclr(jp2, cio, & box, color);
        }
#line 707
        if (! __cil_tmp17) {
#line 709
          if (box.length <= 8) {
#line 709
            return (0);
          }
          {
#line 710
          cio_seek(cio, box.init_pos + 8);
#line 711
          cio_skip(cio, box.length - 8);
          }
        }
        {
#line 713
        __cil_tmp18 = jp2_read_boxhdr(cinfo, cio, & box);
        }
#line 713
        if (__cil_tmp18 == 0) {
#line 713
          return (0);
        }
#line 714
        goto while_continue___0;
      }
    }
#line 716
    if (box.type == 1668112752) {
#line 716
      if (! jp2->ignore_pclr_cmap_cdef) {
        {
#line 718
        __cil_tmp19 = jp2_read_cmap(jp2, cio, & box, color);
        }
#line 718
        if (! __cil_tmp19) {
#line 720
          if (box.length <= 8) {
#line 720
            return (0);
          }
          {
#line 721
          cio_seek(cio, box.init_pos + 8);
#line 722
          cio_skip(cio, box.length - 8);
          }
        }
        {
#line 724
        __cil_tmp20 = jp2_read_boxhdr(cinfo, cio, & box);
        }
#line 724
        if (__cil_tmp20 == 0) {
#line 724
          return (0);
        }
#line 725
        goto while_continue___0;
      }
    }
#line 727
    if (box.length <= 8) {
#line 727
      return (0);
    }
    {
#line 728
    cio_seek(cio, box.init_pos + 8);
#line 729
    cio_skip(cio, box.length - 8);
#line 730
    __cil_tmp21 = jp2_read_boxhdr(cinfo, cio, & box);
    }
#line 730
    if (__cil_tmp21 == 0) {
#line 730
      return (0);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 734
  cio_seek(cio, jp2h_end);
  }
#line 737
  return ((int )color->jp2_has_colr == 1);
}
}
#line 741 "/root/patchweave_new/2/libopenjpeg/jp2.c"
opj_image_t *opj_jp2_decode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_common_ptr cinfo ;
  opj_image_t *image ;
  opj_jp2_color_t color ;
  opj_bool __cil_tmp7 ;

  {
#line 745
  image = (opj_image_t *)((void *)0);
#line 748
  if (! jp2) {
#line 750
    return ((opj_image_t *)((void *)0));
  } else
#line 748
  if (! cio) {
#line 750
    return ((opj_image_t *)((void *)0));
  }
  {
#line 752
  memset((void *)(& color), 0, sizeof(opj_jp2_color_t ));
#line 753
  cinfo = jp2->cinfo;
#line 756
  __cil_tmp7 = jp2_read_struct(jp2, cio, & color);
  }
#line 756
  if (! __cil_tmp7) {
    {
#line 758
    free_color_data(& color);
#line 759
    opj_event_msg(cinfo, 1, "Failed to decode jp2 structure\n");
    }
#line 760
    return ((opj_image_t *)((void *)0));
  }
  {
#line 764
  image = j2k_decode(jp2->j2k, cio, cstr_info);
  }
#line 766
  if (! image) {
    {
#line 768
    free_color_data(& color);
#line 769
    opj_event_msg(cinfo, 1, "Failed to decode J2K image\n");
    }
#line 770
    return ((opj_image_t *)((void *)0));
  }
#line 773
  if (! jp2->ignore_pclr_cmap_cdef) {
#line 776
    if (jp2->enumcs == 16U) {
#line 777
      image->color_space = (OPJ_COLOR_SPACE )1;
    } else
#line 778
    if (jp2->enumcs == 17U) {
#line 779
      image->color_space = (OPJ_COLOR_SPACE )2;
    } else
#line 780
    if (jp2->enumcs == 18U) {
#line 781
      image->color_space = (OPJ_COLOR_SPACE )3;
    } else {
#line 783
      image->color_space = (OPJ_COLOR_SPACE )-1;
    }
#line 785
    if (color.jp2_cdef) {
      {
#line 787
      jp2_apply_cdef(image, & color);
      }
    }
#line 789
    if (color.jp2_pclr) {
#line 792
      if (! (color.jp2_pclr)->cmap) {
        {
#line 793
        jp2_free_pclr(& color);
        }
      } else {
        {
#line 795
        jp2_apply_pclr(& color, image, cinfo);
        }
      }
    }
#line 797
    if (color.icc_profile_buf) {
#line 799
      image->icc_profile_buf = color.icc_profile_buf;
#line 800
      color.icc_profile_buf = (unsigned char *)((void *)0);
#line 801
      image->icc_profile_len = color.icc_profile_len;
    }
  }
#line 805
  return (image);
}
}
#line 810 "/root/patchweave_new/2/libopenjpeg/jp2.c"
void jp2_write_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp5 ;

  {
  {
#line 813
  box.init_pos = cio_tell(cio);
#line 814
  cio_skip(cio, 4);
#line 815
  cio_write(cio, 1785737832ULL, 4);
#line 817
  jp2_write_ihdr(jp2, cio);
  }
#line 819
  if (jp2->bpc == 255U) {
    {
#line 820
    jp2_write_bpcc(jp2, cio);
    }
  }
  {
#line 822
  jp2_write_colr(jp2, cio);
#line 824
  __cil_tmp5 = cio_tell(cio);
#line 824
  box.length = __cil_tmp5 - box.init_pos;
#line 825
  cio_seek(cio, box.init_pos);
#line 826
  cio_write(cio, (unsigned long long )box.length, 4);
#line 827
  cio_seek(cio, box.init_pos + box.length);
  }
#line 829
  return;
}
}
#line 830 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static void jp2_write_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  int __cil_tmp7 ;

  {
  {
#line 834
  box.init_pos = cio_tell(cio);
#line 835
  cio_skip(cio, 4);
#line 836
  cio_write(cio, 1718909296ULL, 4);
#line 838
  cio_write(cio, (unsigned long long )jp2->brand, 4);
#line 839
  cio_write(cio, (unsigned long long )jp2->minversion, 4);
#line 841
  i = 0U;
  }
  {
#line 841
  while (1) {
    while_continue: /* CIL Label */ ;

#line 841
    if (! (i < jp2->numcl)) {
#line 841
      goto while_break;
    }
    {
#line 842
    cio_write(cio, (unsigned long long )*(jp2->cl + i), 4);
#line 841
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 845
  __cil_tmp7 = cio_tell(cio);
#line 845
  box.length = __cil_tmp7 - box.init_pos;
#line 846
  cio_seek(cio, box.init_pos);
#line 847
  cio_write(cio, (unsigned long long )box.length, 4);
#line 848
  cio_seek(cio, box.init_pos + box.length);
  }
#line 850
  return;
}
}
#line 851 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static opj_bool jp2_read_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  int i ;
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp6 ;
  void *__cil_tmp9 ;
  int __cil_tmp12 ;

  {
  {
#line 855
  cinfo = jp2->cinfo;
#line 857
  __cil_tmp6 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 857
  if (__cil_tmp6 == 0) {
    {
#line 858
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 859
    return (0);
  }
#line 861
  if (1718909296 != box.type) {
    {
#line 862
    opj_event_msg(cinfo, 1, "Expected FTYP Marker\n");
    }
#line 863
    return (0);
  }
  {
#line 866
  jp2->brand = cio_read(cio, 4);
#line 867
  jp2->minversion = cio_read(cio, 4);
#line 868
  jp2->numcl = (unsigned int )((box.length - 16) / 4);
#line 869
  __cil_tmp9 = malloc((unsigned long )jp2->numcl * sizeof(unsigned int ));
#line 869
  jp2->cl = (unsigned int *)__cil_tmp9;
#line 871
  i = 0;
  }
  {
#line 871
  while (1) {
    while_continue: /* CIL Label */ ;

#line 871
    if (! (i < (int )jp2->numcl)) {
#line 871
      goto while_break;
    }
    {
#line 872
    *(jp2->cl + i) = cio_read(cio, 4);
#line 871
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 875
  __cil_tmp12 = cio_tell(cio);
  }
#line 875
  if (__cil_tmp12 - box.init_pos != box.length) {
    {
#line 876
    opj_event_msg(cinfo, 1, "Error with FTYP Box\n\312U");
    }
#line 877
    return (0);
  }
#line 880
  return (1);
}
}
#line 883 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static int jp2_write_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  unsigned int j2k_codestream_offset ;
  unsigned int j2k_codestream_length ;
  opj_jp2_box_t box ;
  opj_j2k_t *j2k ;
  int __cil_tmp10 ;
  opj_bool __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 887
  j2k = jp2->j2k;
#line 889
  box.init_pos = cio_tell(cio);
#line 890
  cio_skip(cio, 4);
#line 891
  cio_write(cio, 1785737827ULL, 4);
#line 894
  __cil_tmp10 = cio_tell(cio);
#line 894
  j2k_codestream_offset = (unsigned int )__cil_tmp10;
#line 895
  __cil_tmp11 = j2k_encode(j2k, cio, image, cstr_info);
  }
#line 895
  if (! __cil_tmp11) {
    {
#line 896
    opj_event_msg(j2k->cinfo, 1, "Failed to encode image\n");
    }
#line 897
    return (0);
  }
  {
#line 899
  __cil_tmp12 = cio_tell(cio);
#line 899
  j2k_codestream_length = (unsigned int )__cil_tmp12 - j2k_codestream_offset;
#line 901
  jp2->j2k_codestream_offset = j2k_codestream_offset;
#line 902
  jp2->j2k_codestream_length = j2k_codestream_length;
#line 904
  box.length = (int )(8U + jp2->j2k_codestream_length);
#line 905
  cio_seek(cio, box.init_pos);
#line 906
  cio_write(cio, (unsigned long long )box.length, 4);
#line 907
  cio_seek(cio, box.init_pos + box.length);
  }
#line 909
  return (box.length);
}
}
#line 912 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static opj_bool jp2_read_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , unsigned int *j2k_codestream_length ,
                              unsigned int *j2k_codestream_offset ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp7 ;
  opj_bool __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 915
  cinfo = jp2->cinfo;
#line 917
  __cil_tmp7 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 917
  if (__cil_tmp7 == 0) {
    {
#line 918
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 919
    return (0);
  }
  {
#line 921
  while (1) {
    while_continue: /* CIL Label */ ;

#line 922
    if (1785737827 != box.type) {
#line 923
      if (box.length <= 8) {
#line 923
        return (0);
      }
      {
#line 924
      cio_skip(cio, box.length - 8);
#line 925
      __cil_tmp8 = jp2_read_boxhdr(cinfo, cio, & box);
      }
#line 925
      if (__cil_tmp8 == 0) {
#line 925
        return (0);
      }
    }
#line 921
    if (! (1785737827 != box.type)) {
#line 921
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 929
  __cil_tmp9 = cio_tell(cio);
#line 929
  *j2k_codestream_offset = (unsigned int )__cil_tmp9;
  }
#line 930
  if (box.length <= 8) {
#line 930
    return (0);
  }
#line 931
  *j2k_codestream_length = (unsigned int )(box.length - 8);
#line 933
  return (1);
}
}
#line 936 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static void jp2_write_jp(opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;

  {
  {
#line 939
  box.init_pos = cio_tell(cio);
#line 940
  cio_skip(cio, 4);
#line 941
  cio_write(cio, 1783636000ULL, 4);
#line 942
  cio_write(cio, 218793738ULL, 4);
#line 944
  __cil_tmp4 = cio_tell(cio);
#line 944
  box.length = __cil_tmp4 - box.init_pos;
#line 945
  cio_seek(cio, box.init_pos);
#line 946
  cio_write(cio, (unsigned long long )box.length, 4);
#line 947
  cio_seek(cio, box.init_pos + box.length);
  }
#line 949
  return;
}
}
#line 950 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static opj_bool jp2_read_jp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 953
  cinfo = jp2->cinfo;
#line 955
  __cil_tmp5 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 955
  if (__cil_tmp5 == 0) {
    {
#line 956
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 957
    return (0);
  }
#line 959
  if (1783636000 != box.type) {
    {
#line 960
    opj_event_msg(cinfo, 1, "Expected JP Marker\n");
    }
#line 961
    return (0);
  }
  {
#line 963
  __cil_tmp6 = cio_read(cio, 4);
  }
#line 963
  if (218793738U != __cil_tmp6) {
    {
#line 964
    opj_event_msg(cinfo, 1, "Error with JP Marker\n");
    }
#line 965
    return (0);
  }
  {
#line 967
  __cil_tmp7 = cio_tell(cio);
  }
#line 967
  if (__cil_tmp7 - box.init_pos != box.length) {
    {
#line 968
    opj_event_msg(cinfo, 1, "Error with JP Box size\n");
    }
#line 969
    return (0);
  }
#line 972
  return (1);
}
}
#line 976 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static opj_bool jp2_read_struct(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) 
{ 
  opj_bool __cil_tmp4 ;
  opj_bool __cil_tmp5 ;
  opj_bool __cil_tmp6 ;
  opj_bool __cil_tmp7 ;

  {
  {
#line 978
  __cil_tmp4 = jp2_read_jp(jp2, cio);
  }
#line 978
  if (! __cil_tmp4) {
#line 979
    return (0);
  }
  {
#line 980
  __cil_tmp5 = jp2_read_ftyp(jp2, cio);
  }
#line 980
  if (! __cil_tmp5) {
#line 981
    return (0);
  }
  {
#line 982
  __cil_tmp6 = jp2_read_jp2h(jp2, cio, color);
  }
#line 982
  if (! __cil_tmp6) {
#line 983
    return (0);
  }
  {
#line 984
  __cil_tmp7 = jp2_read_jp2c(jp2, cio, & jp2->j2k_codestream_length, & jp2->j2k_codestream_offset);
  }
#line 984
  if (! __cil_tmp7) {
#line 985
    return (0);
  }
#line 987
  return (1);
}
}
#line 991 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static int write_fidx(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                      opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp9 ;

  {
  {
#line 995
  lenp = cio_tell(cio);
#line 996
  cio_skip(cio, 4);
#line 997
  cio_write(cio, 1718183032ULL, 4);
#line 999
  write_prxy(offset_jp2c, length_jp2c, offset_idx, length_idx, cio);
#line 1001
  __cil_tmp9 = cio_tell(cio);
#line 1001
  len = __cil_tmp9 - lenp;
#line 1002
  cio_seek(cio, lenp);
#line 1003
  cio_write(cio, (unsigned long long )len, 4);
#line 1004
  cio_seek(cio, lenp + len);
  }
#line 1006
  return (len);
}
}
#line 1009 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static void write_prxy(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                       opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp9 ;

  {
  {
#line 1013
  lenp = cio_tell(cio);
#line 1014
  cio_skip(cio, 4);
#line 1015
  cio_write(cio, 1886550137ULL, 4);
#line 1017
  cio_write(cio, (unsigned long long )offset_jp2c, 8);
#line 1018
  cio_write(cio, (unsigned long long )length_jp2c, 4);
#line 1019
  cio_write(cio, 1785737827ULL, 4);
#line 1021
  cio_write(cio, 1ULL, 1);
#line 1023
  cio_write(cio, (unsigned long long )offset_idx, 8);
#line 1024
  cio_write(cio, (unsigned long long )length_idx, 4);
#line 1025
  cio_write(cio, 1667851384ULL, 4);
#line 1027
  __cil_tmp9 = cio_tell(cio);
#line 1027
  len = __cil_tmp9 - lenp;
#line 1028
  cio_seek(cio, lenp);
#line 1029
  cio_write(cio, (unsigned long long )len, 4);
#line 1030
  cio_seek(cio, lenp + len);
  }
#line 1032
  return;
}
}
#line 1033 "/root/patchweave_new/2/libopenjpeg/jp2.c"
static void write_iptr(int offset , int length , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp7 ;

  {
  {
#line 1037
  lenp = cio_tell(cio);
#line 1038
  cio_skip(cio, 4);
#line 1039
  cio_write(cio, 1768977522ULL, 4);
#line 1041
  cio_write(cio, (unsigned long long )offset, 8);
#line 1042
  cio_write(cio, (unsigned long long )length, 8);
#line 1044
  __cil_tmp7 = cio_tell(cio);
#line 1044
  len = __cil_tmp7 - lenp;
#line 1045
  cio_seek(cio, lenp);
#line 1046
  cio_write(cio, (unsigned long long )len, 4);
#line 1047
  cio_seek(cio, lenp + len);
  }
#line 1049
  return;
}
}
#line 1055 "/root/patchweave_new/2/libopenjpeg/jp2.c"
opj_jp2_t *jp2_create_decompress(opj_common_ptr cinfo ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 1056
  __cil_tmp3 = calloc(1UL, sizeof(opj_jp2_t ));
#line 1056
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 1057
  if (jp2) {
    {
#line 1058
    jp2->cinfo = cinfo;
#line 1060
    jp2->j2k = j2k_create_decompress(cinfo);
    }
#line 1061
    if ((unsigned long )jp2->j2k == (unsigned long )((void *)0)) {
      {
#line 1062
      jp2_destroy_decompress(jp2);
      }
#line 1063
      return ((opj_jp2_t *)((void *)0));
    }
  }
#line 1066
  return (jp2);
}
}
#line 1069 "/root/patchweave_new/2/libopenjpeg/jp2.c"
void jp2_destroy_decompress(opj_jp2_t *jp2 ) 
{ 


  {
#line 1070
  if (jp2) {
    {
#line 1072
    j2k_destroy_decompress(jp2->j2k);
    }
#line 1074
    if (jp2->comps) {
      {
#line 1075
      free((void *)jp2->comps);
      }
    }
#line 1077
    if (jp2->cl) {
      {
#line 1078
      free((void *)jp2->cl);
      }
    }
    {
#line 1080
    free((void *)jp2);
    }
  }
#line 1083
  return;
}
}
#line 1084 "/root/patchweave_new/2/libopenjpeg/jp2.c"
void jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) 
{ 


  {
  {
#line 1086
  j2k_setup_decoder(jp2->j2k, parameters);
#line 1088
  jp2->ignore_pclr_cmap_cdef = (opj_bool )(parameters->flags & 1U);
  }
#line 1090
  return;
}
}
#line 1095 "/root/patchweave_new/2/libopenjpeg/jp2.c"
opj_jp2_t *jp2_create_compress(opj_common_ptr cinfo ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 1096
  __cil_tmp3 = malloc(sizeof(opj_jp2_t ));
#line 1096
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 1097
  if (jp2) {
    {
#line 1098
    jp2->cinfo = cinfo;
#line 1100
    jp2->j2k = j2k_create_compress(cinfo);
    }
#line 1101
    if ((unsigned long )jp2->j2k == (unsigned long )((void *)0)) {
      {
#line 1102
      jp2_destroy_compress(jp2);
      }
#line 1103
      return ((opj_jp2_t *)((void *)0));
    }
  }
#line 1106
  return (jp2);
}
}
#line 1109 "/root/patchweave_new/2/libopenjpeg/jp2.c"
void jp2_destroy_compress(opj_jp2_t *jp2 ) 
{ 


  {
#line 1110
  if (jp2) {
    {
#line 1112
    j2k_destroy_compress(jp2->j2k);
    }
#line 1114
    if (jp2->comps) {
      {
#line 1115
      free((void *)jp2->comps);
      }
    }
#line 1117
    if (jp2->cl) {
      {
#line 1118
      free((void *)jp2->cl);
      }
    }
    {
#line 1120
    free((void *)jp2);
    }
  }
#line 1123
  return;
}
}
#line 1124 "/root/patchweave_new/2/libopenjpeg/jp2.c"
void jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 
  int i ;
  int depth_0 ;
  int sign ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  int depth ;

  {
#line 1128
  if (! jp2) {
#line 1129
    return;
  } else
#line 1128
  if (! parameters) {
#line 1129
    return;
  } else
#line 1128
  if (! image) {
#line 1129
    return;
  }
#line 1135
  if (image->numcomps < 1) {
    {
#line 1136
    opj_event_msg(jp2->cinfo, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
#line 1137
    return;
  } else
#line 1135
  if (image->numcomps > 16384) {
    {
#line 1136
    opj_event_msg(jp2->cinfo, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
#line 1137
    return;
  }
  {
#line 1140
  j2k_setup_encoder(jp2->j2k, parameters, image);
#line 1147
  jp2->brand = 1785737760U;
#line 1148
  jp2->minversion = 0U;
#line 1149
  jp2->numcl = 1U;
#line 1150
  __cil_tmp7 = malloc((unsigned long )jp2->numcl * sizeof(unsigned int ));
#line 1150
  jp2->cl = (unsigned int *)__cil_tmp7;
#line 1151
  *(jp2->cl + 0) = 1785737760U;
#line 1155
  jp2->numcomps = (unsigned int )image->numcomps;
#line 1156
  __cil_tmp8 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 1156
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp8;
#line 1157
  jp2->h = (unsigned int )(image->y1 - image->y0);
#line 1158
  jp2->w = (unsigned int )(image->x1 - image->x0);
#line 1160
  depth_0 = (image->comps + 0)->prec - 1;
#line 1161
  sign = (image->comps + 0)->sgnd;
#line 1162
  jp2->bpc = (unsigned int )(depth_0 + (sign << 7));
#line 1163
  i = 1;
  }
  {
#line 1163
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1163
    if (! (i < image->numcomps)) {
#line 1163
      goto while_break;
    }
#line 1164
    depth = (image->comps + i)->prec - 1;
#line 1165
    sign = (image->comps + i)->sgnd;
#line 1166
    if (depth_0 != depth) {
#line 1167
      jp2->bpc = 255U;
    }
#line 1163
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 1169
  jp2->C = 7U;
#line 1170
  jp2->UnkC = 0U;
#line 1171
  jp2->IPR = 0U;
#line 1175
  i = 0;
  {
#line 1175
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1175
    if (! (i < image->numcomps)) {
#line 1175
      goto while_break___0;
    }
#line 1176
    (jp2->comps + i)->bpcc = ((image->comps + i)->prec - 1) + ((image->comps + i)->sgnd << 7);
#line 1175
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
#line 1178
  jp2->meth = 1U;
#line 1179
  if ((int )image->color_space == 1) {
#line 1180
    jp2->enumcs = 16U;
  } else
#line 1181
  if ((int )image->color_space == 2) {
#line 1182
    jp2->enumcs = 17U;
  } else
#line 1183
  if ((int )image->color_space == 3) {
#line 1184
    jp2->enumcs = 18U;
  }
#line 1185
  jp2->precedence = 0U;
#line 1186
  jp2->approx = 0U;
#line 1188
  jp2->jpip_on = parameters->jpip_on;
#line 1189
  return;
}
}
#line 1191 "/root/patchweave_new/2/libopenjpeg/jp2.c"
opj_bool opj_jp2_encode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  int pos_iptr ;
  int pos_cidx ;
  int pos_jp2c ;
  int len_jp2c ;
  int len_cidx ;
  int end_pos ;
  int pos_fidx ;
  int len_fidx ;

  {
  {
#line 1194
  pos_iptr = -1;
#line 1194
  pos_jp2c = pos_iptr;
#line 1199
  jp2_write_jp(cio);
#line 1201
  jp2_write_ftyp(jp2, cio);
#line 1203
  jp2_write_jp2h(jp2, cio);
  }
#line 1205
  if (jp2->jpip_on) {
    {
#line 1206
    pos_iptr = cio_tell(cio);
#line 1207
    cio_skip(cio, 24);
#line 1209
    pos_jp2c = cio_tell(cio);
    }
  }
  {
#line 1213
  len_jp2c = jp2_write_jp2c(jp2, cio, image, cstr_info);
  }
#line 1213
  if (! len_jp2c) {
    {
#line 1214
    opj_event_msg(jp2->cinfo, 1, "Failed to encode image\n");
    }
#line 1215
    return (0);
  }
#line 1218
  if (jp2->jpip_on) {
    {
#line 1219
    pos_cidx = cio_tell(cio);
#line 1221
    len_cidx = write_cidx(pos_jp2c + 8, cio, image, *cstr_info, len_jp2c - 8);
#line 1223
    pos_fidx = cio_tell(cio);
#line 1224
    len_fidx = write_fidx(pos_jp2c, len_jp2c, pos_cidx, len_cidx, cio);
#line 1226
    end_pos = cio_tell(cio);
#line 1228
    cio_seek(cio, pos_iptr);
#line 1229
    write_iptr(pos_fidx, len_fidx, cio);
#line 1231
    cio_seek(cio, end_pos);
    }
  }
#line 1234
  return (1);
}
}
#line 87 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 36 "/root/patchweave_new/2/libopenjpeg/j2k_lib.c"
double opj_clock(void) 
{ 
  struct rusage t ;
  double procTime ;

  {
  {
#line 51
  getrusage(0, & t);
#line 54
  procTime = (double )(t.ru_utime.tv_sec + t.ru_stime.tv_sec);
  }
#line 56
  return (procTime + (double )(t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-06);
}
}
#line 46 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_soc(opj_j2k_t *j2k ) ;
#line 51
static void j2k_read_soc(opj_j2k_t *j2k ) ;
#line 56
static void j2k_write_siz(opj_j2k_t *j2k ) ;
#line 61
static void j2k_read_siz(opj_j2k_t *j2k ) ;
#line 66
static void j2k_write_com(opj_j2k_t *j2k ) ;
#line 71
static void j2k_read_com(opj_j2k_t *j2k ) ;
#line 77
static void j2k_write_cox(opj_j2k_t *j2k , int compno ) ;
#line 83
static void j2k_read_cox(opj_j2k_t *j2k , int compno ) ;
#line 88
static void j2k_write_cod(opj_j2k_t *j2k ) ;
#line 93
static void j2k_read_cod(opj_j2k_t *j2k ) ;
#line 99
static void j2k_write_coc(opj_j2k_t *j2k , int compno ) ;
#line 104
static void j2k_read_coc(opj_j2k_t *j2k ) ;
#line 110
static void j2k_write_qcx(opj_j2k_t *j2k , int compno ) ;
#line 117
static void j2k_read_qcx(opj_j2k_t *j2k , int compno , int len ) ;
#line 122
static void j2k_write_qcd(opj_j2k_t *j2k ) ;
#line 127
static void j2k_read_qcd(opj_j2k_t *j2k ) ;
#line 133
static void j2k_write_qcc(opj_j2k_t *j2k , int compno ) ;
#line 138
static void j2k_read_qcc(opj_j2k_t *j2k ) ;
#line 143
static void j2k_write_poc(opj_j2k_t *j2k ) ;
#line 148
static void j2k_read_poc(opj_j2k_t *j2k ) ;
#line 153
static void j2k_read_crg(opj_j2k_t *j2k ) ;
#line 158
static void j2k_read_tlm(opj_j2k_t *j2k ) ;
#line 163
static void j2k_read_plm(opj_j2k_t *j2k ) ;
#line 168
static void j2k_read_plt(opj_j2k_t *j2k ) ;
#line 173
static void j2k_read_ppm(opj_j2k_t *j2k ) ;
#line 178
static void j2k_read_ppt(opj_j2k_t *j2k ) ;
#line 183
static void j2k_write_tlm(opj_j2k_t *j2k ) ;
#line 188
static void j2k_write_sot(opj_j2k_t *j2k ) ;
#line 193
static void j2k_read_sot(opj_j2k_t *j2k ) ;
#line 199
static void j2k_write_sod(opj_j2k_t *j2k , void *tile_coder ) ;
#line 204
static void j2k_read_sod(opj_j2k_t *j2k ) ;
#line 211
static void j2k_write_rgn(opj_j2k_t *j2k , int compno , int tileno ) ;
#line 216
static void j2k_read_rgn(opj_j2k_t *j2k ) ;
#line 221
static void j2k_write_eoc(opj_j2k_t *j2k ) ;
#line 226
static void j2k_read_eoc(opj_j2k_t *j2k ) ;
#line 231
static void j2k_read_unk(opj_j2k_t *j2k ) ;
#line 239
static void j2k_add_mhmarker(opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) ;
#line 248
static void j2k_add_tlmarker(int tileno , opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) ;
#line 260 "/root/patchweave_new/2/libopenjpeg/j2k.c"
j2k_prog_order_t j2k_prog_order_list[6]  = {      {(OPJ_PROG_ORDER )4, {(char )"CPRL", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )0, {(char )"LRCP", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )3, {(char )"PCRL", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )1, {(char )"RLCP", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )2, {(char )"RPCL", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )-1, {(char )"\250", (char)0, (char)0, (char)0, (char)0}}};
#line 269 "/root/patchweave_new/2/libopenjpeg/j2k.c"
char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) 
{ 
  j2k_prog_order_t *po ;

  {
#line 271
  po = j2k_prog_order_list;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;

#line 271
    if (! ((int )po->enum_prog != -1)) {
#line 271
      goto while_break;
    }
#line 272
    if ((int )po->enum_prog == (int )prg_order) {
#line 273
      goto while_break;
    }
#line 271
    po ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 276
  return (po->str_prog);
}
}
#line 280 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static int j2k_get_num_tp(opj_cp_t *cp , int pino , int tileno ) 
{ 
  char *prog ;
  int i ;
  int tpnum ;
  int tpend ;
  opj_tcp_t *tcp ;

  {
  {
#line 283
  tpnum = 1;
#line 283
  tpend = 0;
#line 284
  tcp = cp->tcps + tileno;
#line 285
  prog = j2k_convert_progression_order(tcp->prg);
  }
#line 287
  if ((int )cp->tp_on == 1) {
#line 288
    i = 0;
    {
#line 288
    while (1) {
      while_continue: /* CIL Label */ ;

#line 288
      if (! (i < 4)) {
#line 288
        goto while_break;
      }
#line 289
      if (tpend != 1) {
#line 290
        if ((int )cp->tp_flag == (int )*(prog + i)) {
#line 291
          tpend = 1;
#line 291
          cp->tp_pos = i;
        }
#line 294
        if ((int )*(prog + i) == 67) {
#line 294
          goto case_67;
        }
#line 297
        if ((int )*(prog + i) == 82) {
#line 297
          goto case_82;
        }
#line 300
        if ((int )*(prog + i) == 80) {
#line 300
          goto case_80;
        }
#line 303
        if ((int )*(prog + i) == 76) {
#line 303
          goto case_76;
        }
#line 293
        goto switch_break;
        case_67: 
#line 295
        tpnum *= tcp->pocs[pino].compE;
#line 296
        goto switch_break;
        case_82: 
#line 298
        tpnum *= tcp->pocs[pino].resE;
#line 299
        goto switch_break;
        case_80: 
#line 301
        tpnum *= tcp->pocs[pino].prcE;
#line 302
        goto switch_break;
        case_76: 
#line 304
        tpnum *= tcp->pocs[pino].layE;
#line 305
        goto switch_break;
        switch_break: ;
      }
#line 288
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 310
    tpnum = 1;
  }
#line 312
  return (tpnum);
}
}
#line 316 "/root/patchweave_new/2/libopenjpeg/j2k.c"
int j2k_calculate_tp(opj_cp_t *cp , int img_numcomp , opj_image_t *image , opj_j2k_t *j2k ) 
{ 
  int pino ;
  int tileno ;
  int totnum_tp ;
  void *__cil_tmp8 ;
  int cur_totnum_tp ;
  opj_tcp_t *tcp ;
  int tp_num ;
  opj_pi_iterator_t *pi ;
  opj_pi_iterator_t *__cil_tmp13 ;
  void *__cil_tmp16 ;

  {
  {
#line 317
  totnum_tp = 0;
#line 321
  __cil_tmp8 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(int ));
#line 321
  j2k->cur_totnum_tp = (int *)__cil_tmp8;
#line 322
  tileno = 0;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;

#line 322
    if (! (tileno < cp->tw * cp->th)) {
#line 322
      goto while_break;
    }
#line 323
    cur_totnum_tp = 0;
#line 324
    tcp = cp->tcps + tileno;
#line 325
    pino = 0;
    {
#line 325
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 325
      if (! (pino <= tcp->numpocs)) {
#line 325
        goto while_break___0;
      }
      {
#line 326
      tp_num = 0;
#line 327
      __cil_tmp13 = pi_initialise_encode(image, cp, tileno, (J2K_T2_MODE )1);
#line 327
      pi = __cil_tmp13;
      }
#line 328
      if (! pi) {
#line 328
        return (-1);
      }
      {
#line 329
      tp_num = j2k_get_num_tp(cp, pino, tileno);
#line 330
      totnum_tp += tp_num;
#line 331
      cur_totnum_tp += tp_num;
#line 332
      pi_destroy(pi, cp, tileno);
#line 325
      pino ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 334
    *(j2k->cur_totnum_tp + tileno) = cur_totnum_tp;
#line 336
    if (j2k->cstr_info) {
      {
#line 337
      ((j2k->cstr_info)->tile + tileno)->num_tps = cur_totnum_tp;
#line 338
      __cil_tmp16 = malloc((unsigned long )cur_totnum_tp * sizeof(opj_tp_info_t ));
#line 338
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp16;
      }
    }
#line 322
    tileno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 342
  return (totnum_tp);
}
}
#line 345 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_soc(opj_j2k_t *j2k ) 
{ 
  opj_cio_t *cio ;
  int __cil_tmp3 ;

  {
  {
#line 346
  cio = j2k->cio;
#line 347
  cio_write(cio, 65359ULL, 2);
  }
#line 349
  if (j2k->cstr_info) {
    {
#line 350
    __cil_tmp3 = cio_tell(cio);
#line 350
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short)65359, __cil_tmp3, 0);
    }
  }
#line 353
  return;
}
}
#line 361 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_soc(opj_j2k_t *j2k ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 362
  j2k->state = 2;
#line 364
  if (j2k->cstr_info) {
    {
#line 365
    __cil_tmp2 = cio_tell(j2k->cio);
#line 365
    (j2k->cstr_info)->main_head_start = __cil_tmp2 - 2;
#line 366
    __cil_tmp3 = cio_numbytesleft(j2k->cio);
#line 366
    (j2k->cstr_info)->codestream_size = (__cil_tmp3 + 2) - (j2k->cstr_info)->main_head_start;
    }
  }
#line 369
  return;
}
}
#line 370 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_siz(opj_j2k_t *j2k ) 
{ 
  int i ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  int __cil_tmp10 ;

  {
  {
#line 374
  cio = j2k->cio;
#line 375
  image = j2k->image;
#line 376
  cp = j2k->cp;
#line 378
  cio_write(cio, 65361ULL, 2);
#line 379
  lenp = cio_tell(cio);
#line 380
  cio_skip(cio, 2);
#line 381
  cio_write(cio, (unsigned long long )cp->rsiz, 2);
#line 382
  cio_write(cio, (unsigned long long )image->x1, 4);
#line 383
  cio_write(cio, (unsigned long long )image->y1, 4);
#line 384
  cio_write(cio, (unsigned long long )image->x0, 4);
#line 385
  cio_write(cio, (unsigned long long )image->y0, 4);
#line 386
  cio_write(cio, (unsigned long long )cp->tdx, 4);
#line 387
  cio_write(cio, (unsigned long long )cp->tdy, 4);
#line 388
  cio_write(cio, (unsigned long long )cp->tx0, 4);
#line 389
  cio_write(cio, (unsigned long long )cp->ty0, 4);
#line 390
  cio_write(cio, (unsigned long long )image->numcomps, 2);
#line 391
  i = 0;
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;

#line 391
    if (! (i < image->numcomps)) {
#line 391
      goto while_break;
    }
    {
#line 392
    cio_write(cio, (unsigned long long )(((image->comps + i)->prec - 1) + ((image->comps + i)->sgnd << 7)),
              1);
#line 393
    cio_write(cio, (unsigned long long )(image->comps + i)->dx, 1);
#line 394
    cio_write(cio, (unsigned long long )(image->comps + i)->dy, 1);
#line 391
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 396
  __cil_tmp10 = cio_tell(cio);
#line 396
  len = __cil_tmp10 - lenp;
#line 397
  cio_seek(cio, lenp);
#line 398
  cio_write(cio, (unsigned long long )len, 2);
#line 399
  cio_seek(cio, lenp + len);
  }
#line 401
  if (j2k->cstr_info) {
    {
#line 402
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short)65361, lenp, len);
    }
  }
#line 405
  return;
}
}
#line 405 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_siz(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  void *__cil_tmp17 ;
  int tmp ;
  int w ;
  int h ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  opj_codestream_info_t *cstr_info ;
  void *__cil_tmp38 ;

  {
  {
#line 408
  cio = j2k->cio;
#line 409
  image = j2k->image;
#line 410
  cp = j2k->cp;
#line 412
  __cil_tmp7 = cio_read(cio, 2);
#line 412
  len = (int )__cil_tmp7;
#line 413
  cio_read(cio, 2);
#line 414
  __cil_tmp8 = cio_read(cio, 4);
#line 414
  image->x1 = (int )__cil_tmp8;
#line 415
  __cil_tmp9 = cio_read(cio, 4);
#line 415
  image->y1 = (int )__cil_tmp9;
#line 416
  __cil_tmp10 = cio_read(cio, 4);
#line 416
  image->x0 = (int )__cil_tmp10;
#line 417
  __cil_tmp11 = cio_read(cio, 4);
#line 417
  image->y0 = (int )__cil_tmp11;
#line 418
  __cil_tmp12 = cio_read(cio, 4);
#line 418
  cp->tdx = (int )__cil_tmp12;
#line 419
  __cil_tmp13 = cio_read(cio, 4);
#line 419
  cp->tdy = (int )__cil_tmp13;
#line 420
  __cil_tmp14 = cio_read(cio, 4);
#line 420
  cp->tx0 = (int )__cil_tmp14;
#line 421
  __cil_tmp15 = cio_read(cio, 4);
#line 421
  cp->ty0 = (int )__cil_tmp15;
  }
#line 423
  if (image->x0 < 0) {
    {
#line 424
    opj_event_msg(j2k->cinfo, 1, "%s: invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n",
                  image->x0, image->x1, image->y0, image->y1);
    }
#line 427
    return;
  } else
#line 423
  if (image->x1 < 0) {
    {
#line 424
    opj_event_msg(j2k->cinfo, 1, "%s: invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n",
                  image->x0, image->x1, image->y0, image->y1);
    }
#line 427
    return;
  } else
#line 423
  if (image->y0 < 0) {
    {
#line 424
    opj_event_msg(j2k->cinfo, 1, "%s: invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n",
                  image->x0, image->x1, image->y0, image->y1);
    }
#line 427
    return;
  } else
#line 423
  if (image->y1 < 0) {
    {
#line 424
    opj_event_msg(j2k->cinfo, 1, "%s: invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n",
                  image->x0, image->x1, image->y0, image->y1);
    }
#line 427
    return;
  }
  {
#line 430
  __cil_tmp16 = cio_read(cio, 2);
#line 430
  image->numcomps = (int )__cil_tmp16;
#line 477
  __cil_tmp17 = calloc((unsigned long )image->numcomps, sizeof(opj_image_comp_t ));
#line 477
  image->comps = (opj_image_comp_t *)__cil_tmp17;
#line 478
  i = 0;
  }
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;

#line 478
    if (! (i < image->numcomps)) {
#line 478
      goto while_break;
    }
    {
#line 480
    __cil_tmp21 = cio_read(cio, 1);
#line 480
    tmp = (int )__cil_tmp21;
#line 481
    (image->comps + i)->prec = (tmp & 127) + 1;
#line 482
    (image->comps + i)->sgnd = tmp >> 7;
#line 483
    __cil_tmp22 = cio_read(cio, 1);
#line 483
    (image->comps + i)->dx = (int )__cil_tmp22;
#line 484
    __cil_tmp23 = cio_read(cio, 1);
#line 484
    (image->comps + i)->dy = (int )__cil_tmp23;
#line 522
    w = (((image->x1 - image->x0) + (image->comps + i)->dx) - 1) / (image->comps + i)->dx;
#line 523
    h = (((image->y1 - image->y0) + (image->comps + i)->dy) - 1) / (image->comps + i)->dy;
#line 525
    (image->comps + i)->resno_decoded = 0;
#line 526
    (image->comps + i)->factor = cp->reduce;
#line 478
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 529
  cp->tw = (((image->x1 - cp->tx0) + cp->tdx) - 1) / cp->tdx;
#line 530
  cp->th = (((image->y1 - cp->ty0) + cp->tdy) - 1) / cp->tdy;
#line 572
  __cil_tmp29 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 572
  cp->tcps = (opj_tcp_t *)__cil_tmp29;
  }
#line 573
  if ((unsigned long )cp->tcps == (unsigned long )((void *)0)) {
    {
#line 575
    opj_event_msg(j2k->cinfo, 1, "Out of memory\n");
    }
#line 576
    return;
  }
  {
#line 578
  __cil_tmp30 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(int ));
#line 578
  cp->tileno = (int *)__cil_tmp30;
  }
#line 579
  if ((unsigned long )cp->tileno == (unsigned long )((void *)0)) {
    {
#line 581
    opj_event_msg(j2k->cinfo, 1, "Out of memory\n");
    }
#line 582
    return;
  }
#line 584
  cp->tileno_size = 0;
#line 599
  i = 0;
  {
#line 599
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 599
    if (! (i < cp->tw * cp->th)) {
#line 599
      goto while_break___0;
    }
#line 600
    (cp->tcps + i)->POC = 0;
#line 601
    (cp->tcps + i)->numpocs = 0;
#line 602
    (cp->tcps + i)->first = 1;
#line 599
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 606
  cp->ppm = 0;
#line 607
  cp->ppm_data = (unsigned char *)((void *)0);
#line 608
  cp->ppm_data_first = (unsigned char *)((void *)0);
#line 609
  cp->ppm_previous = 0;
#line 610
  cp->ppm_store = 0;
#line 612
  __cil_tmp32 = calloc((unsigned long )image->numcomps, sizeof(opj_tccp_t ));
#line 612
  (j2k->default_tcp)->tccps = (opj_tccp_t *)__cil_tmp32;
#line 613
  i = 0;
  }
  {
#line 613
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 613
    if (! (i < cp->tw * cp->th)) {
#line 613
      goto while_break___1;
    }
    {
#line 614
    __cil_tmp33 = malloc((unsigned long )image->numcomps * sizeof(opj_tccp_t ));
#line 614
    (cp->tcps + i)->tccps = (opj_tccp_t *)__cil_tmp33;
#line 613
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 616
  __cil_tmp35 = calloc((unsigned long )(cp->tw * cp->th), sizeof(unsigned char *));
#line 616
  j2k->tile_data = (unsigned char **)__cil_tmp35;
#line 617
  __cil_tmp36 = calloc((unsigned long )(cp->tw * cp->th), sizeof(int ));
#line 617
  j2k->tile_len = (int *)__cil_tmp36;
#line 618
  j2k->state = 4;
  }
#line 621
  if (j2k->cstr_info) {
    {
#line 622
    cstr_info = j2k->cstr_info;
#line 623
    cstr_info->image_w = image->x1 - image->x0;
#line 624
    cstr_info->image_h = image->y1 - image->y0;
#line 625
    cstr_info->numcomps = image->numcomps;
#line 626
    cstr_info->tw = cp->tw;
#line 627
    cstr_info->th = cp->th;
#line 628
    cstr_info->tile_x = cp->tdx;
#line 629
    cstr_info->tile_y = cp->tdy;
#line 630
    cstr_info->tile_Ox = cp->tx0;
#line 631
    cstr_info->tile_Oy = cp->ty0;
#line 632
    __cil_tmp38 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tile_info_t ));
#line 632
    cstr_info->tile = (opj_tile_info_t *)__cil_tmp38;
    }
  }
#line 635
  return;
}
}
#line 636 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_com(opj_j2k_t *j2k ) 
{ 
  unsigned int i ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  char *comment ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp10 ;

  {
#line 640
  if ((j2k->cp)->comment) {
    {
#line 641
    cio = j2k->cio;
#line 642
    comment = (j2k->cp)->comment;
#line 644
    cio_write(cio, 65380ULL, 2);
#line 645
    lenp = cio_tell(cio);
#line 646
    cio_skip(cio, 2);
#line 647
    cio_write(cio, 1ULL, 2);
#line 648
    i = 0U;
    }
    {
#line 648
    while (1) {
      while_continue: /* CIL Label */ ;

#line 648
      if (! ((unsigned long )i < __cil_tmp8)) {
#line 648
        goto while_break;
      }
      {
#line 649
      cio_write(cio, (unsigned long long )*(comment + i), 1);
#line 648
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 651
    __cil_tmp10 = cio_tell(cio);
#line 651
    len = __cil_tmp10 - lenp;
#line 652
    cio_seek(cio, lenp);
#line 653
    cio_write(cio, (unsigned long long )len, 2);
#line 654
    cio_seek(cio, lenp + len);
    }
#line 657
    if (j2k->cstr_info) {
      {
#line 658
      j2k_add_mhmarker(j2k->cstr_info, (unsigned short)65380, lenp, len);
      }
    }
  }
#line 662
  return;
}
}
#line 663 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_com(opj_j2k_t *j2k ) 
{ 
  int len ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp4 ;

  {
  {
#line 666
  cio = j2k->cio;
#line 668
  __cil_tmp4 = cio_read(cio, 2);
#line 668
  len = (int )__cil_tmp4;
#line 669
  cio_skip(cio, len - 2);
  }
#line 671
  return;
}
}
#line 672 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_cox(opj_j2k_t *j2k , int compno ) 
{ 
  int i ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;

  {
  {
#line 675
  cp = j2k->cp;
#line 676
  tcp = cp->tcps + j2k->curtileno;
#line 677
  tccp = tcp->tccps + compno;
#line 678
  cio = j2k->cio;
#line 680
  cio_write(cio, (unsigned long long )(tccp->numresolutions - 1), 1);
#line 681
  cio_write(cio, (unsigned long long )(tccp->cblkw - 2), 1);
#line 682
  cio_write(cio, (unsigned long long )(tccp->cblkh - 2), 1);
#line 683
  cio_write(cio, (unsigned long long )tccp->cblksty, 1);
#line 684
  cio_write(cio, (unsigned long long )tccp->qmfbid, 1);
  }
#line 686
  if (tccp->csty & 1) {
#line 687
    i = 0;
    {
#line 687
    while (1) {
      while_continue: /* CIL Label */ ;

#line 687
      if (! (i < tccp->numresolutions)) {
#line 687
        goto while_break;
      }
      {
#line 688
      cio_write(cio, (unsigned long long )(tccp->prcw[i] + (tccp->prch[i] << 4)),
                1);
#line 687
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 692
  return;
}
}
#line 693 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_cox(opj_j2k_t *j2k , int compno ) 
{ 
  int i ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int tmp___0 ;
  unsigned int __cil_tmp15 ;

  {
#line 696
  cp = j2k->cp;
#line 697
  if (j2k->state == 16) {
#line 697
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 697
    tmp = j2k->default_tcp;
  }
  {
#line 697
  tcp = tmp;
#line 698
  tccp = tcp->tccps + compno;
#line 699
  cio = j2k->cio;
#line 701
  __cil_tmp9 = cio_read(cio, 1);
#line 701
  tccp->numresolutions = (int )(__cil_tmp9 + 1U);
  }
#line 704
  if (cp->reduce >= tccp->numresolutions) {
    {
#line 705
    opj_event_msg(j2k->cinfo, 1, "Error decoding component %d.\nThe number of resolutions to remove is higher than the number of resolutions of this component\nModify the cp_reduce parameter.\n\n",
                  compno);
#line 707
    j2k->state |= 128;
    }
  }
#line 709
  if (tccp->numresolutions > 33) {
    {
#line 710
    opj_event_msg(j2k->cinfo, 1, "Error decoding component %d.\nThe number of resolutions is too big: %d vs max= %d. Truncating.\n\n",
                  compno, tccp->numresolutions, 33);
#line 712
    j2k->state |= 128;
#line 713
    tccp->numresolutions = 33;
    }
  }
  {
#line 716
  __cil_tmp10 = cio_read(cio, 1);
#line 716
  tccp->cblkw = (int )(__cil_tmp10 + 2U);
#line 717
  __cil_tmp11 = cio_read(cio, 1);
#line 717
  tccp->cblkh = (int )(__cil_tmp11 + 2U);
#line 718
  __cil_tmp12 = cio_read(cio, 1);
#line 718
  tccp->cblksty = (int )__cil_tmp12;
#line 719
  __cil_tmp13 = cio_read(cio, 1);
#line 719
  tccp->qmfbid = (int )__cil_tmp13;
  }
#line 720
  if (tccp->csty & 1) {
#line 721
    i = 0;
    {
#line 721
    while (1) {
      while_continue: /* CIL Label */ ;

#line 721
      if (! (i < tccp->numresolutions)) {
#line 721
        goto while_break;
      }
      {
#line 722
      __cil_tmp15 = cio_read(cio, 1);
#line 722
      tmp___0 = (int )__cil_tmp15;
#line 723
      tccp->prcw[i] = tmp___0 & 15;
#line 724
      tccp->prch[i] = tmp___0 >> 4;
#line 721
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 729
  if (j2k->cstr_info) {
#line 729
    if (compno == 0) {
#line 730
      i = 0;
      {
#line 730
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 730
        if (! (i < tccp->numresolutions)) {
#line 730
          goto while_break___0;
        }
#line 731
        if (tccp->csty & 1) {
#line 732
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = tccp->prcw[i];
#line 733
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdy[i] = tccp->prch[i];
        } else {
#line 736
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = 15;
#line 737
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = 15;
        }
#line 730
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
    }
  }
#line 736
  return;
}
}
#line 744 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_cod(opj_j2k_t *j2k ) 
{ 
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp8 ;

  {
  {
#line 745
  cp = (opj_cp_t *)((void *)0);
#line 746
  tcp = (opj_tcp_t *)((void *)0);
#line 749
  cio = j2k->cio;
#line 751
  cio_write(cio, 65362ULL, 2);
#line 753
  lenp = cio_tell(cio);
#line 754
  cio_skip(cio, 2);
#line 756
  cp = j2k->cp;
#line 757
  tcp = cp->tcps + j2k->curtileno;
#line 759
  cio_write(cio, (unsigned long long )tcp->csty, 1);
#line 760
  cio_write(cio, (unsigned long long )tcp->prg, 1);
#line 761
  cio_write(cio, (unsigned long long )tcp->numlayers, 2);
#line 762
  cio_write(cio, (unsigned long long )tcp->mct, 1);
#line 764
  j2k_write_cox(j2k, 0);
#line 765
  __cil_tmp8 = cio_tell(cio);
#line 765
  len = __cil_tmp8 - lenp;
#line 766
  cio_seek(cio, lenp);
#line 767
  cio_write(cio, (unsigned long long )len, 2);
#line 768
  cio_seek(cio, lenp + len);
  }
#line 770
  if (j2k->cstr_info) {
    {
#line 771
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short)65362, lenp, len);
    }
  }
#line 774
  return;
}
}
#line 775 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_cod(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int pos ;
  opj_cio_t *cio ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_image_t *image ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  opj_codestream_info_t *cstr_info ;
  void *__cil_tmp18 ;

  {
#line 778
  cio = j2k->cio;
#line 779
  cp = j2k->cp;
#line 780
  if (j2k->state == 16) {
#line 780
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 780
    tmp = j2k->default_tcp;
  }
  {
#line 780
  tcp = tmp;
#line 781
  image = j2k->image;
#line 783
  __cil_tmp10 = cio_read(cio, 2);
#line 783
  len = (int )__cil_tmp10;
#line 784
  __cil_tmp11 = cio_read(cio, 1);
#line 784
  tcp->csty = (int )__cil_tmp11;
#line 785
  __cil_tmp12 = cio_read(cio, 1);
#line 785
  tcp->prg = (OPJ_PROG_ORDER )__cil_tmp12;
#line 786
  __cil_tmp13 = cio_read(cio, 2);
#line 786
  tcp->numlayers = (int )__cil_tmp13;
#line 787
  __cil_tmp14 = cio_read(cio, 1);
#line 787
  tcp->mct = (int )__cil_tmp14;
#line 789
  pos = cio_tell(cio);
#line 790
  i = 0;
  }
  {
#line 790
  while (1) {
    while_continue: /* CIL Label */ ;

#line 790
    if (! (i < image->numcomps)) {
#line 790
      goto while_break;
    }
    {
#line 791
    (tcp->tccps + i)->csty = tcp->csty & 1;
#line 792
    cio_seek(cio, pos);
#line 793
    j2k_read_cox(j2k, i);
#line 790
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 797
  if (j2k->cstr_info) {
    {
#line 798
    cstr_info = j2k->cstr_info;
#line 799
    cstr_info->prog = tcp->prg;
#line 800
    cstr_info->numlayers = tcp->numlayers;
#line 801
    __cil_tmp18 = malloc((unsigned long )image->numcomps * sizeof(int ));
#line 801
    cstr_info->numdecompos = (int *)__cil_tmp18;
#line 802
    i = 0;
    }
    {
#line 802
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 802
      if (! (i < image->numcomps)) {
#line 802
        goto while_break___0;
      }
#line 803
      *(cstr_info->numdecompos + i) = (tcp->tccps + i)->numresolutions - 1;
#line 802
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 807
  return;
}
}
#line 808 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_coc(opj_j2k_t *j2k , int compno ) 
{ 
  int lenp ;
  int len ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_image_t *image ;
  opj_cio_t *cio ;
  int tmp ;
  int __cil_tmp11 ;

  {
  {
#line 811
  cp = j2k->cp;
#line 812
  tcp = cp->tcps + j2k->curtileno;
#line 813
  image = j2k->image;
#line 814
  cio = j2k->cio;
#line 816
  cio_write(cio, 65363ULL, 2);
#line 817
  lenp = cio_tell(cio);
#line 818
  cio_skip(cio, 2);
  }
#line 819
  if (image->numcomps <= 256) {
#line 819
    tmp = 1;
  } else {
#line 819
    tmp = 2;
  }
  {
#line 819
  cio_write(cio, (unsigned long long )compno, tmp);
#line 820
  cio_write(cio, (unsigned long long )(tcp->tccps + compno)->csty, 1);
#line 821
  j2k_write_cox(j2k, compno);
#line 822
  __cil_tmp11 = cio_tell(cio);
#line 822
  len = __cil_tmp11 - lenp;
#line 823
  cio_seek(cio, lenp);
#line 824
  cio_write(cio, (unsigned long long )len, 2);
#line 825
  cio_seek(cio, lenp + len);
  }
#line 827
  return;
}
}
#line 828 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_coc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_image_t *image ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  int tmp___0 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;

  {
#line 831
  cp = j2k->cp;
#line 832
  if (j2k->state == 16) {
#line 832
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 832
    tmp = j2k->default_tcp;
  }
  {
#line 832
  tcp = tmp;
#line 833
  image = j2k->image;
#line 834
  cio = j2k->cio;
#line 836
  __cil_tmp9 = cio_read(cio, 2);
#line 836
  len = (int )__cil_tmp9;
  }
#line 837
  if (image->numcomps <= 256) {
#line 837
    tmp___0 = 1;
  } else {
#line 837
    tmp___0 = 2;
  }
  {
#line 837
  __cil_tmp11 = cio_read(cio, tmp___0);
#line 837
  compno = (int )__cil_tmp11;
#line 838
  __cil_tmp12 = cio_read(cio, 1);
#line 838
  (tcp->tccps + compno)->csty = (int )__cil_tmp12;
#line 839
  j2k_read_cox(j2k, compno);
  }
#line 841
  return;
}
}
#line 842 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_qcx(opj_j2k_t *j2k , int compno ) 
{ 
  int bandno ;
  int numbands ;
  int expn ;
  int mant ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int tmp ;

  {
  {
#line 846
  cp = j2k->cp;
#line 847
  tcp = cp->tcps + j2k->curtileno;
#line 848
  tccp = tcp->tccps + compno;
#line 849
  cio = j2k->cio;
#line 851
  cio_write(cio, (unsigned long long )(tccp->qntsty + (tccp->numgbits << 5)), 1);
  }
#line 852
  if (tccp->qntsty == 1) {
#line 852
    tmp = 1;
  } else {
#line 852
    tmp = tccp->numresolutions * 3 - 2;
  }
#line 852
  numbands = tmp;
#line 854
  bandno = 0;
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;

#line 854
    if (! (bandno < numbands)) {
#line 854
      goto while_break;
    }
#line 855
    expn = tccp->stepsizes[bandno].expn;
#line 856
    mant = tccp->stepsizes[bandno].mant;
#line 858
    if (tccp->qntsty == 0) {
      {
#line 859
      cio_write(cio, (unsigned long long )(expn << 3), 1);
      }
    } else {
      {
#line 861
      cio_write(cio, (unsigned long long )((expn << 11) + mant), 2);
      }
    }
#line 854
    bandno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 858
  return;
}
}
#line 866 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_qcx(opj_j2k_t *j2k , int compno , int len ) 
{ 
  int tmp ;
  int bandno ;
  int numbands ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp___11 ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  int tmp___12 ;
  int tmp___13 ;
  int expn ;
  int mant ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int tmp___14 ;

  {
#line 870
  cp = j2k->cp;
#line 871
  if (j2k->state == 16) {
#line 871
    tmp___11 = cp->tcps + j2k->curtileno;
  } else {
#line 871
    tmp___11 = j2k->default_tcp;
  }
  {
#line 871
  tcp = tmp___11;
#line 872
  tccp = tcp->tccps + compno;
#line 873
  cio = j2k->cio;
#line 875
  __cil_tmp12 = cio_read(cio, 1);
#line 875
  tmp = (int )__cil_tmp12;
#line 876
  tccp->qntsty = tmp & 31;
#line 877
  tccp->numgbits = tmp >> 5;
  }
#line 878
  if (tccp->qntsty == 1) {
#line 878
    tmp___13 = 1;
  } else {
#line 878
    if (tccp->qntsty == 0) {
#line 878
      tmp___12 = len - 1;
    } else {
#line 878
      tmp___12 = (len - 1) / 2;
    }
#line 878
    tmp___13 = tmp___12;
  }
#line 878
  numbands = tmp___13;
#line 904
  if (numbands < 0) {
    {
#line 905
    opj_event_msg(j2k->cinfo, 2, "bad number of subbands in Sqcx (%d) regarding to J2K_MAXBANDS (%d) \n- limiting number of bands to J2K_MAXBANDS and try to move to the next markers\n",
                  numbands, 97);
    }
  } else
#line 904
  if (numbands >= 97) {
    {
#line 905
    opj_event_msg(j2k->cinfo, 2, "bad number of subbands in Sqcx (%d) regarding to J2K_MAXBANDS (%d) \n- limiting number of bands to J2K_MAXBANDS and try to move to the next markers\n",
                  numbands, 97);
    }
  }
#line 912
  bandno = 0;
  {
#line 912
  while (1) {
    while_continue: /* CIL Label */ ;

#line 912
    if (! (bandno < numbands)) {
#line 912
      goto while_break;
    }
#line 914
    if (tccp->qntsty == 0) {
      {
#line 915
      __cil_tmp17 = cio_read(cio, 1);
#line 915
      expn = (int )(__cil_tmp17 >> 3);
#line 916
      mant = 0;
      }
    } else {
      {
#line 918
      __cil_tmp18 = cio_read(cio, 2);
#line 918
      tmp = (int )__cil_tmp18;
#line 919
      expn = tmp >> 11;
#line 920
      mant = tmp & 2047;
      }
    }
#line 922
    if (bandno < 97) {
#line 923
      tccp->stepsizes[bandno].expn = expn;
#line 924
      tccp->stepsizes[bandno].mant = mant;
    }
#line 912
    bandno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 929
  if (tccp->qntsty == 1) {
#line 930
    bandno = 1;
    {
#line 930
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 930
      if (! (bandno < 97)) {
#line 930
        goto while_break___0;
      }
#line 931
      if (tccp->stepsizes[0].expn - (bandno - 1) / 3 > 0) {
#line 931
        tmp___14 = tccp->stepsizes[0].expn - (bandno - 1) / 3;
      } else {
#line 931
        tmp___14 = 0;
      }
#line 931
      tccp->stepsizes[bandno].expn = tmp___14;
#line 934
      tccp->stepsizes[bandno].mant = tccp->stepsizes[0].mant;
#line 930
      bandno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 935
  return;
}
}
#line 940 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_qcd(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp6 ;

  {
  {
#line 943
  cio = j2k->cio;
#line 945
  cio_write(cio, 65372ULL, 2);
#line 946
  lenp = cio_tell(cio);
#line 947
  cio_skip(cio, 2);
#line 948
  j2k_write_qcx(j2k, 0);
#line 949
  __cil_tmp6 = cio_tell(cio);
#line 949
  len = __cil_tmp6 - lenp;
#line 950
  cio_seek(cio, lenp);
#line 951
  cio_write(cio, (unsigned long long )len, 2);
#line 952
  cio_seek(cio, lenp + len);
  }
#line 954
  if (j2k->cstr_info) {
    {
#line 955
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short)65372, lenp, len);
    }
  }
#line 958
  return;
}
}
#line 958 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_qcd(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int pos ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  unsigned int __cil_tmp7 ;

  {
  {
#line 961
  cio = j2k->cio;
#line 962
  image = j2k->image;
#line 964
  __cil_tmp7 = cio_read(cio, 2);
#line 964
  len = (int )__cil_tmp7;
#line 965
  pos = cio_tell(cio);
#line 966
  i = 0;
  }
  {
#line 966
  while (1) {
    while_continue: /* CIL Label */ ;

#line 966
    if (! (i < image->numcomps)) {
#line 966
      goto while_break;
    }
    {
#line 967
    cio_seek(cio, pos);
#line 968
    j2k_read_qcx(j2k, i, len - 2);
#line 966
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 970
  return;
}
}
#line 972 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_qcc(opj_j2k_t *j2k , int compno ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int tmp ;
  int __cil_tmp8 ;

  {
  {
#line 975
  cio = j2k->cio;
#line 977
  cio_write(cio, 65373ULL, 2);
#line 978
  lenp = cio_tell(cio);
#line 979
  cio_skip(cio, 2);
  }
#line 980
  if ((j2k->image)->numcomps <= 256) {
#line 980
    tmp = 1;
  } else {
#line 980
    tmp = 2;
  }
  {
#line 980
  cio_write(cio, (unsigned long long )compno, tmp);
#line 981
  j2k_write_qcx(j2k, compno);
#line 982
  __cil_tmp8 = cio_tell(cio);
#line 982
  len = __cil_tmp8 - lenp;
#line 983
  cio_seek(cio, lenp);
#line 984
  cio_write(cio, (unsigned long long )len, 2);
#line 985
  cio_seek(cio, lenp + len);
  }
#line 987
  return;
}
}
#line 988 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_qcc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  int numcomp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp6 ;
  int tmp ;
  unsigned int __cil_tmp8 ;
  int tmp___0 ;

  {
  {
#line 990
  numcomp = (j2k->image)->numcomps;
#line 991
  cio = j2k->cio;
#line 993
  __cil_tmp6 = cio_read(cio, 2);
#line 993
  len = (int )__cil_tmp6;
  }
#line 994
  if (numcomp <= 256) {
#line 994
    tmp = 1;
  } else {
#line 994
    tmp = 2;
  }
  {
#line 994
  __cil_tmp8 = cio_read(cio, tmp);
#line 994
  compno = (int )__cil_tmp8;
  }
#line 1022
  if (numcomp <= 256) {
#line 1022
    tmp___0 = 1;
  } else {
#line 1022
    tmp___0 = 2;
  }
  {
#line 1022
  j2k_read_qcx(j2k, compno, (len - 2) - tmp___0);
  }
#line 1024
  return;
}
}
#line 1025 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_poc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int numpchgs ;
  int i ;
  int numcomps ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int tmp ;
  opj_poc_t *poc ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1028
  numcomps = (j2k->image)->numcomps;
#line 1030
  cp = j2k->cp;
#line 1031
  tcp = cp->tcps + j2k->curtileno;
#line 1032
  tccp = tcp->tccps + 0;
#line 1033
  cio = j2k->cio;
#line 1035
  numpchgs = 1 + tcp->numpocs;
#line 1036
  cio_write(cio, 65375ULL, 2);
  }
#line 1037
  if (numcomps <= 256) {
#line 1037
    tmp = 1;
  } else {
#line 1037
    tmp = 2;
  }
  {
#line 1037
  len = 2 + (5 + 2 * tmp) * numpchgs;
#line 1038
  cio_write(cio, (unsigned long long )len, 2);
#line 1039
  i = 0;
  }
  {
#line 1039
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1039
    if (! (i < numpchgs)) {
#line 1039
      goto while_break;
    }
    {
#line 1040
    poc = & tcp->pocs[i];
#line 1041
    cio_write(cio, (unsigned long long )poc->resno0, 1);
    }
#line 1042
    if (numcomps <= 256) {
#line 1042
      tmp___0 = 1;
    } else {
#line 1042
      tmp___0 = 2;
    }
    {
#line 1042
    cio_write(cio, (unsigned long long )poc->compno0, tmp___0);
#line 1043
    cio_write(cio, (unsigned long long )poc->layno1, 2);
#line 1044
    poc->layno1 = int_min(poc->layno1, tcp->numlayers);
#line 1045
    cio_write(cio, (unsigned long long )poc->resno1, 1);
#line 1046
    poc->resno1 = int_min(poc->resno1, tccp->numresolutions);
    }
#line 1047
    if (numcomps <= 256) {
#line 1047
      tmp___1 = 1;
    } else {
#line 1047
      tmp___1 = 2;
    }
    {
#line 1047
    cio_write(cio, (unsigned long long )poc->compno1, tmp___1);
#line 1048
    poc->compno1 = int_min(poc->compno1, numcomps);
#line 1049
    cio_write(cio, (unsigned long long )poc->prg, 1);
#line 1039
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1043
  return;
}
}
#line 1053 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_poc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int numpchgs ;
  int i ;
  int old_poc ;
  int numcomps ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_cio_t *cio ;
  int tmp___0 ;
  unsigned int __cil_tmp12 ;
  int tmp___1 ;
  opj_poc_t *poc ;
  unsigned int __cil_tmp15 ;
  int tmp___2 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  int tmp___3 ;
  unsigned int __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;

  {
#line 1056
  numcomps = (j2k->image)->numcomps;
#line 1058
  cp = j2k->cp;
#line 1059
  if (j2k->state == 16) {
#line 1059
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 1059
    tmp = j2k->default_tcp;
  }
#line 1059
  tcp = tmp;
#line 1060
  cio = j2k->cio;
#line 1062
  if (tcp->POC) {
#line 1062
    tmp___0 = tcp->numpocs + 1;
  } else {
#line 1062
    tmp___0 = 0;
  }
  {
#line 1062
  old_poc = tmp___0;
#line 1063
  tcp->POC = 1;
#line 1064
  __cil_tmp12 = cio_read(cio, 2);
#line 1064
  len = (int )__cil_tmp12;
  }
#line 1065
  if (numcomps <= 256) {
#line 1065
    tmp___1 = 1;
  } else {
#line 1065
    tmp___1 = 2;
  }
#line 1065
  numpchgs = (len - 2) / (5 + 2 * tmp___1);
#line 1067
  i = old_poc;
  {
#line 1067
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1067
    if (! (i < numpchgs + old_poc)) {
#line 1067
      goto while_break;
    }
    {
#line 1069
    poc = & tcp->pocs[i];
#line 1070
    __cil_tmp15 = cio_read(cio, 1);
#line 1070
    poc->resno0 = (int )__cil_tmp15;
    }
#line 1071
    if (numcomps <= 256) {
#line 1071
      tmp___2 = 1;
    } else {
#line 1071
      tmp___2 = 2;
    }
    {
#line 1071
    __cil_tmp17 = cio_read(cio, tmp___2);
#line 1071
    poc->compno0 = (int )__cil_tmp17;
#line 1072
    __cil_tmp18 = cio_read(cio, 2);
#line 1072
    poc->layno1 = (int )__cil_tmp18;
#line 1073
    __cil_tmp19 = cio_read(cio, 1);
#line 1073
    poc->resno1 = (int )__cil_tmp19;
    }
#line 1074
    if (numcomps <= 256) {
#line 1074
      tmp___3 = 1;
    } else {
#line 1074
      tmp___3 = 2;
    }
    {
#line 1074
    __cil_tmp21 = cio_read(cio, tmp___3);
#line 1074
    __cil_tmp22 = int_min((int )__cil_tmp21, (int )((unsigned int )numcomps));
#line 1074
    poc->compno1 = __cil_tmp22;
#line 1076
    __cil_tmp23 = cio_read(cio, 1);
#line 1076
    poc->prg = (OPJ_PROG_ORDER )__cil_tmp23;
#line 1067
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1079
  tcp->numpocs = (numpchgs + old_poc) - 1;
#line 1080
  return;
}
}
#line 1082 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_crg(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Xcrg_i ;
  int Ycrg_i ;
  opj_cio_t *cio ;
  int numcomps ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;

  {
  {
#line 1085
  cio = j2k->cio;
#line 1086
  numcomps = (j2k->image)->numcomps;
#line 1088
  __cil_tmp8 = cio_read(cio, 2);
#line 1088
  len = (int )__cil_tmp8;
#line 1089
  i = 0;
  }
  {
#line 1089
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1089
    if (! (i < numcomps)) {
#line 1089
      goto while_break;
    }
    {
#line 1090
    __cil_tmp9 = cio_read(cio, 2);
#line 1090
    Xcrg_i = (int )__cil_tmp9;
#line 1091
    __cil_tmp10 = cio_read(cio, 2);
#line 1091
    Ycrg_i = (int )__cil_tmp10;
#line 1089
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1093
  return;
}
}
#line 1095 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_tlm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Ztlm ;
  int Stlm ;
  int ST ;
  int SP ;
  int tile_tlm ;
  int i ;
  long Ttlm_i ;
  long Ptlm_i ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int tmp ;
  unsigned int __cil_tmp17 ;

  {
  {
#line 1099
  cio = j2k->cio;
#line 1101
  __cil_tmp12 = cio_read(cio, 2);
#line 1101
  len = (int )__cil_tmp12;
#line 1102
  __cil_tmp13 = cio_read(cio, 1);
#line 1102
  Ztlm = (int )__cil_tmp13;
#line 1103
  __cil_tmp14 = cio_read(cio, 1);
#line 1103
  Stlm = (int )__cil_tmp14;
#line 1104
  ST = ((Stlm >> 4) & 1) + ((Stlm >> 4) & 2);
#line 1105
  SP = (Stlm >> 6) & 1;
#line 1106
  tile_tlm = (len - 4) / ((SP + 1) * 2 + ST);
#line 1107
  i = 0;
  }
  {
#line 1107
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1107
    if (! (i < tile_tlm)) {
#line 1107
      goto while_break;
    }
    {
#line 1108
    __cil_tmp15 = cio_read(cio, ST);
#line 1108
    Ttlm_i = (long )__cil_tmp15;
    }
#line 1109
    if (SP) {
#line 1109
      tmp = 4;
    } else {
#line 1109
      tmp = 2;
    }
    {
#line 1109
    __cil_tmp17 = cio_read(cio, tmp);
#line 1109
    Ptlm_i = (long )__cil_tmp17;
#line 1107
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1111
  return;
}
}
#line 1113 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_plm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Zplm ;
  int Nplm ;
  int add ;
  int packet_len ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 1114
  packet_len = 0;
#line 1116
  cio = j2k->cio;
#line 1118
  __cil_tmp9 = cio_read(cio, 2);
#line 1118
  len = (int )__cil_tmp9;
#line 1119
  __cil_tmp10 = cio_read(cio, 1);
#line 1119
  Zplm = (int )__cil_tmp10;
#line 1120
  len -= 3;
  }
  {
#line 1121
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1121
    if (! (len > 0)) {
#line 1121
      goto while_break;
    }
    {
#line 1122
    __cil_tmp11 = cio_read(cio, 4);
#line 1122
    Nplm = (int )__cil_tmp11;
#line 1123
    len -= 4;
#line 1124
    i = Nplm;
    }
    {
#line 1124
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1124
      if (! (i > 0)) {
#line 1124
        goto while_break___0;
      }
      {
#line 1125
      __cil_tmp12 = cio_read(cio, 1);
#line 1125
      add = (int )__cil_tmp12;
#line 1126
      __cil_tmp13 = len;
#line 1126
      len --;
#line 1127
      packet_len = (packet_len << 7) + add;
      }
#line 1128
      if ((add & 128) == 0) {
#line 1130
        packet_len = 0;
      }
#line 1132
      if (len <= 0) {
#line 1133
        goto while_break___0;
      }
#line 1124
      __cil_tmp14 = i;
#line 1124
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1131
  return;
}
}
#line 1138 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_plt(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Zplt ;
  int packet_len ;
  int add ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1139
  packet_len = 0;
#line 1141
  cio = j2k->cio;
#line 1143
  __cil_tmp8 = cio_read(cio, 2);
#line 1143
  len = (int )__cil_tmp8;
#line 1144
  __cil_tmp9 = cio_read(cio, 1);
#line 1144
  Zplt = (int )__cil_tmp9;
#line 1145
  i = len - 3;
  }
  {
#line 1145
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1145
    if (! (i > 0)) {
#line 1145
      goto while_break;
    }
    {
#line 1146
    __cil_tmp10 = cio_read(cio, 1);
#line 1146
    add = (int )__cil_tmp10;
#line 1147
    packet_len = (packet_len << 7) + add;
    }
#line 1148
    if ((add & 128) == 0) {
#line 1150
      packet_len = 0;
    }
#line 1145
    __cil_tmp11 = i;
#line 1145
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1149
  return;
}
}
#line 1155 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_ppm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Z_ppm ;
  int i ;
  int j ;
  int N_ppm ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 1159
  cp = j2k->cp;
#line 1160
  cio = j2k->cio;
#line 1162
  __cil_tmp9 = cio_read(cio, 2);
#line 1162
  len = (int )__cil_tmp9;
#line 1163
  cp->ppm = 1;
#line 1165
  __cil_tmp10 = cio_read(cio, 1);
#line 1165
  Z_ppm = (int )__cil_tmp10;
#line 1166
  len -= 3;
  }
  {
#line 1167
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1167
    if (! (len > 0)) {
#line 1167
      goto while_break;
    }
#line 1168
    if (cp->ppm_previous == 0) {
      {
#line 1169
      __cil_tmp11 = cio_read(cio, 4);
#line 1169
      N_ppm = (int )__cil_tmp11;
#line 1170
      len -= 4;
      }
    } else {
#line 1172
      N_ppm = cp->ppm_previous;
    }
#line 1174
    j = cp->ppm_store;
#line 1175
    if (Z_ppm == 0) {
      {
#line 1176
      __cil_tmp12 = malloc((unsigned long )N_ppm * sizeof(unsigned char ));
#line 1176
      cp->ppm_data = (unsigned char *)__cil_tmp12;
#line 1177
      cp->ppm_data_first = cp->ppm_data;
#line 1178
      cp->ppm_len = N_ppm;
      }
    } else {
      {
#line 1180
      __cil_tmp13 = realloc((void *)cp->ppm_data, (unsigned long )(N_ppm + cp->ppm_store) * sizeof(unsigned char ));
#line 1180
      cp->ppm_data = (unsigned char *)__cil_tmp13;
#line 1198
      cp->ppm_data_first = cp->ppm_data;
#line 1199
      cp->ppm_len = N_ppm + cp->ppm_store;
      }
    }
#line 1201
    i = N_ppm;
    {
#line 1201
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1201
      if (! (i > 0)) {
#line 1201
        goto while_break___0;
      }
      {
#line 1202
      __cil_tmp14 = cio_read(cio, 1);
#line 1202
      *(cp->ppm_data + j) = (unsigned char )__cil_tmp14;
#line 1203
      j ++;
#line 1204
      __cil_tmp16 = len;
#line 1204
      len --;
      }
#line 1205
      if (len == 0) {
#line 1206
        goto while_break___0;
      }
#line 1201
      __cil_tmp17 = i;
#line 1201
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 1208
    cp->ppm_previous = i - 1;
#line 1209
    cp->ppm_store = j;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1213
  return;
}
}
#line 1213 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_ppt(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Z_ppt ;
  int i ;
  int j ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp15 ;

  {
  {
#line 1214
  j = 0;
#line 1216
  cp = j2k->cp;
#line 1217
  tcp = cp->tcps + j2k->curtileno;
#line 1218
  cio = j2k->cio;
#line 1220
  __cil_tmp9 = cio_read(cio, 2);
#line 1220
  len = (int )__cil_tmp9;
#line 1221
  __cil_tmp10 = cio_read(cio, 1);
#line 1221
  Z_ppt = (int )__cil_tmp10;
#line 1222
  tcp->ppt = 1;
  }
#line 1223
  if (Z_ppt == 0) {
    {
#line 1224
    __cil_tmp11 = malloc((unsigned long )(len - 3) * sizeof(unsigned char ));
#line 1224
    tcp->ppt_data = (unsigned char *)__cil_tmp11;
#line 1225
    tcp->ppt_data_first = tcp->ppt_data;
#line 1226
    tcp->ppt_store = 0;
#line 1227
    tcp->ppt_len = len - 3;
    }
  } else {
    {
#line 1229
    __cil_tmp12 = realloc((void *)tcp->ppt_data, (unsigned long )((len - 3) + tcp->ppt_store) * sizeof(unsigned char ));
#line 1229
    tcp->ppt_data = (unsigned char *)__cil_tmp12;
#line 1230
    tcp->ppt_data_first = tcp->ppt_data;
#line 1231
    tcp->ppt_len = (len - 3) + tcp->ppt_store;
    }
  }
#line 1233
  j = tcp->ppt_store;
#line 1234
  i = len - 3;
  {
#line 1234
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1234
    if (! (i > 0)) {
#line 1234
      goto while_break;
    }
    {
#line 1235
    __cil_tmp13 = cio_read(cio, 1);
#line 1235
    *(tcp->ppt_data + j) = (unsigned char )__cil_tmp13;
#line 1236
    j ++;
#line 1234
    __cil_tmp15 = i;
#line 1234
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1238
  tcp->ppt_store = j;
#line 1239
  return;
}
}
#line 1241 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_tlm(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  opj_cio_t *cio ;

  {
  {
#line 1243
  cio = j2k->cio;
#line 1244
  j2k->tlm_start = cio_tell(cio);
#line 1245
  cio_write(cio, 65365ULL, 2);
#line 1246
  lenp = 4 + 5 * j2k->totnum_tp;
#line 1247
  cio_write(cio, (unsigned long long )lenp, 2);
#line 1248
  cio_write(cio, 0ULL, 1);
#line 1249
  cio_write(cio, 80ULL, 1);
#line 1250
  cio_skip(cio, 5 * j2k->totnum_tp);
  }
#line 1252
  return;
}
}
#line 1253 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_sot(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp7 ;

  {
  {
#line 1256
  cio = j2k->cio;
#line 1258
  j2k->sot_start = cio_tell(cio);
#line 1259
  cio_write(cio, 65424ULL, 2);
#line 1260
  lenp = cio_tell(cio);
#line 1261
  cio_skip(cio, 2);
#line 1262
  cio_write(cio, (unsigned long long )j2k->curtileno, 2);
#line 1263
  cio_skip(cio, 4);
#line 1264
  cio_write(cio, (unsigned long long )j2k->cur_tp_num, 1);
#line 1265
  cio_write(cio, (unsigned long long )*(j2k->cur_totnum_tp + j2k->curtileno), 1);
#line 1266
  __cil_tmp7 = cio_tell(cio);
#line 1266
  len = __cil_tmp7 - lenp;
#line 1267
  cio_seek(cio, lenp);
#line 1268
  cio_write(cio, (unsigned long long )len, 2);
#line 1269
  cio_seek(cio, lenp + len);
  }
#line 1278
  if (j2k->cstr_info) {
#line 1278
    if (j2k->cur_tp_num == 0) {
      {
#line 1279
      j2k_add_tlmarker(j2k->curtileno, j2k->cstr_info, (unsigned short)65424, lenp,
                       len);
      }
    }
  }
#line 1284
  return;
}
}
#line 1283 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_sot(opj_j2k_t *j2k ) 
{ 
  int len ;
  int tileno ;
  int totlen ;
  int partno ;
  int numparts ;
  int i ;
  opj_tcp_t *tcp ;
  char status ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int tmp ;
  unsigned int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  int __cil_tmp29 ;
  opj_tccp_t *tmp___0 ;

  {
  {
#line 1285
  tcp = (opj_tcp_t *)((void *)0);
#line 1286
  status = (char)0;
#line 1288
  cp = j2k->cp;
#line 1289
  cio = j2k->cio;
#line 1291
  __cil_tmp12 = cio_read(cio, 2);
#line 1291
  len = (int )__cil_tmp12;
#line 1292
  __cil_tmp13 = cio_read(cio, 2);
#line 1292
  tileno = (int )__cil_tmp13;
  }
#line 1322
  if (tileno < 0) {
    {
#line 1323
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile number (%d out of a maximum of %d)\n",
                  tileno, cp->tw * cp->th);
    }
#line 1326
    return;
  } else
#line 1322
  if (tileno >= cp->tw * cp->th) {
    {
#line 1323
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile number (%d out of a maximum of %d)\n",
                  tileno, cp->tw * cp->th);
    }
#line 1326
    return;
  }
#line 1330
  if (cp->tileno_size == 0) {
#line 1331
    *(cp->tileno + cp->tileno_size) = tileno;
#line 1332
    (cp->tileno_size) ++;
  } else {
#line 1334
    i = 0;
    {
#line 1335
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1335
      if (i < cp->tileno_size) {
#line 1335
        if (! ((int )status == 0)) {
#line 1335
          goto while_break;
        }
      } else {
#line 1335
        goto while_break;
      }
#line 1336
      if (*(cp->tileno + i) == tileno) {
#line 1336
        tmp = 1;
      } else {
#line 1336
        tmp = 0;
      }
#line 1336
      status = (char )tmp;
#line 1337
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
#line 1339
    if ((int )status == 0) {
#line 1340
      *(cp->tileno + cp->tileno_size) = tileno;
#line 1341
      (cp->tileno_size) ++;
    }
  }
  {
#line 1345
  __cil_tmp18 = cio_read(cio, 4);
#line 1345
  totlen = (int )__cil_tmp18;
#line 1371
  __cil_tmp19 = cio_numbytesleft(cio);
  }
#line 1371
  if (totlen < 0) {
    {
#line 1372
    __cil_tmp20 = cio_numbytesleft(cio);
#line 1372
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile byte size (%d bytes against %d bytes left)\n",
                  totlen, __cil_tmp20 + 8);
    }
#line 1375
    return;
  } else
#line 1371
  if (totlen > __cil_tmp19 + 8) {
    {
#line 1372
    __cil_tmp20 = cio_numbytesleft(cio);
#line 1372
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile byte size (%d bytes against %d bytes left)\n",
                  totlen, __cil_tmp20 + 8);
    }
#line 1375
    return;
  }
#line 1379
  if (! totlen) {
    {
#line 1380
    __cil_tmp21 = cio_numbytesleft(cio);
#line 1380
    totlen = __cil_tmp21 + 8;
    }
  }
  {
#line 1382
  __cil_tmp22 = cio_read(cio, 1);
#line 1382
  partno = (int )__cil_tmp22;
#line 1383
  __cil_tmp23 = cio_read(cio, 1);
#line 1383
  numparts = (int )__cil_tmp23;
  }
#line 1385
  if (partno >= numparts) {
    {
#line 1386
    opj_event_msg(j2k->cinfo, 2, "SOT marker inconsistency in tile %d: tile-part index greater (%d) than number of tile-parts (%d)\n",
                  tileno, partno, numparts);
#line 1387
    numparts = partno + 1;
    }
  }
  {
#line 1390
  j2k->curtileno = tileno;
#line 1391
  j2k->cur_tp_num = partno;
#line 1392
  __cil_tmp24 = cio_getbp(cio);
#line 1392
  j2k->eot = (__cil_tmp24 - 12) + totlen;
#line 1393
  j2k->state = 16;
#line 1394
  tcp = cp->tcps + j2k->curtileno;
  }
#line 1397
  if (j2k->cstr_info) {
#line 1398
    if (tcp->first) {
#line 1399
      if (tileno == 0) {
        {
#line 1400
        __cil_tmp25 = cio_tell(cio);
#line 1400
        (j2k->cstr_info)->main_head_end = __cil_tmp25 - 13;
        }
      }
      {
#line 1401
      ((j2k->cstr_info)->tile + tileno)->tileno = tileno;
#line 1402
      __cil_tmp26 = cio_tell(cio);
#line 1402
      ((j2k->cstr_info)->tile + tileno)->start_pos = __cil_tmp26 - 12;
#line 1403
      ((j2k->cstr_info)->tile + tileno)->end_pos = (((j2k->cstr_info)->tile + tileno)->start_pos + totlen) - 1;
      }
    } else {
#line 1405
      ((j2k->cstr_info)->tile + tileno)->end_pos += totlen;
    }
#line 1407
    ((j2k->cstr_info)->tile + tileno)->num_tps = numparts;
#line 1408
    if (numparts) {
      {
#line 1409
      __cil_tmp27 = realloc((void *)((j2k->cstr_info)->tile + tileno)->tp, (unsigned long )numparts * sizeof(opj_tp_info_t ));
#line 1409
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp27;
      }
    } else {
      {
#line 1411
      __cil_tmp28 = realloc((void *)((j2k->cstr_info)->tile + tileno)->tp, 10UL * sizeof(opj_tp_info_t ));
#line 1411
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp28;
      }
    }
    {
#line 1412
    __cil_tmp29 = cio_tell(cio);
#line 1412
    (((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_start_pos = __cil_tmp29 - 12;
#line 1413
    (((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_end_pos = ((((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_start_pos + totlen) - 1;
    }
  }
#line 1417
  if (tcp->first == 1) {
    {
#line 1419
    tmp___0 = tcp->tccps;
#line 1420
    memcpy((void *)tcp, (void const   *)j2k->default_tcp, sizeof(opj_tcp_t ));
#line 1421
    tcp->ppt = 0;
#line 1422
    tcp->ppt_data = (unsigned char *)((void *)0);
#line 1423
    tcp->ppt_data_first = (unsigned char *)((void *)0);
#line 1424
    tcp->tccps = tmp___0;
#line 1426
    i = 0;
    }
    {
#line 1426
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1426
      if (! (i < (j2k->image)->numcomps)) {
#line 1426
        goto while_break___0;
      }
#line 1427
      *(tcp->tccps + i) = *((j2k->default_tcp)->tccps + i);
#line 1426
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 1429
    (cp->tcps + j2k->curtileno)->first = 0;
  }
#line 1431
  return;
}
}
#line 1433 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_sod(opj_j2k_t *j2k , void *tile_coder ) 
{ 
  int l ;
  int layno ;
  int totlen ;
  opj_tcp_t *tcp ;
  opj_codestream_info_t *cstr_info ;
  opj_tcd_t *tcd ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 1436
  tcp = (opj_tcp_t *)((void *)0);
#line 1437
  cstr_info = (opj_codestream_info_t *)((void *)0);
#line 1439
  tcd = (opj_tcd_t *)tile_coder;
#line 1440
  cp = j2k->cp;
#line 1441
  cio = j2k->cio;
#line 1443
  tcd->tp_num = j2k->tp_num;
#line 1444
  tcd->cur_tp_num = j2k->cur_tp_num;
#line 1446
  cio_write(cio, 65427ULL, 2);
  }
#line 1448
  if (j2k->cstr_info) {
#line 1448
    if (j2k->cur_tp_num == 0) {
      {
#line 1449
      __cil_tmp11 = cio_tell(cio);
#line 1449
      j2k_add_tlmarker(j2k->curtileno, j2k->cstr_info, (unsigned short)65427, __cil_tmp11,
                       0);
      }
    }
  }
#line 1452
  if (j2k->curtileno == 0) {
    {
#line 1453
    __cil_tmp12 = cio_tell(cio);
#line 1453
    j2k->sod_start = __cil_tmp12 + j2k->pos_correction;
    }
  }
#line 1457
  cstr_info = j2k->cstr_info;
#line 1458
  if (cstr_info) {
#line 1459
    if (! j2k->cur_tp_num) {
      {
#line 1460
      __cil_tmp13 = cio_tell(cio);
#line 1460
      (cstr_info->tile + j2k->curtileno)->end_header = (__cil_tmp13 + j2k->pos_correction) - 1;
#line 1461
      ((j2k->cstr_info)->tile + j2k->curtileno)->tileno = j2k->curtileno;
      }
    } else {
      {
#line 1464
      __cil_tmp14 = cio_tell(cio);
      }
#line 1464
      if (((cstr_info->tile + j2k->curtileno)->packet + (cstr_info->packno - 1))->end_pos < __cil_tmp14) {
        {
#line 1465
        ((cstr_info->tile + j2k->curtileno)->packet + cstr_info->packno)->start_pos = cio_tell(cio);
        }
      }
    }
  }
#line 1476
  tcp = cp->tcps + j2k->curtileno;
#line 1477
  layno = 0;
  {
#line 1477
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1477
    if (! (layno < tcp->numlayers)) {
#line 1477
      goto while_break;
    }
#line 1478
    if (tcp->rates[layno] > (float )(j2k->sod_start / (cp->th * cp->tw))) {
#line 1479
      tcp->rates[layno] -= (float )(j2k->sod_start / (cp->th * cp->tw));
    } else
#line 1480
    if (tcp->rates[layno]) {
#line 1481
      tcp->rates[layno] = (float )1;
    }
#line 1477
    layno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1484
  if (j2k->cur_tp_num == 0) {
#line 1485
    ((tcd->tcd_image)->tiles)->packno = 0;
#line 1486
    if (cstr_info) {
#line 1487
      cstr_info->packno = 0;
    }
  }
  {
#line 1490
  __cil_tmp17 = cio_getbp(cio);
#line 1490
  __cil_tmp18 = cio_numbytesleft(cio);
#line 1490
  __cil_tmp19 = tcd_encode_tile(tcd, j2k->curtileno, __cil_tmp17, __cil_tmp18 - 2,
                                cstr_info);
#line 1490
  l = __cil_tmp19;
#line 1493
  __cil_tmp20 = cio_tell(cio);
#line 1493
  totlen = (__cil_tmp20 + l) - j2k->sot_start;
#line 1494
  cio_seek(cio, j2k->sot_start + 6);
#line 1495
  cio_write(cio, (unsigned long long )totlen, 4);
#line 1496
  cio_seek(cio, j2k->sot_start + totlen);
  }
#line 1498
  if (cp->cinema) {
    {
#line 1499
    cio_seek(cio, (j2k->tlm_start + 6) + 5 * j2k->cur_tp_num);
#line 1500
    cio_write(cio, (unsigned long long )j2k->curtileno, 1);
#line 1501
    cio_write(cio, (unsigned long long )totlen, 4);
    }
  }
  {
#line 1503
  cio_seek(cio, j2k->sot_start + totlen);
  }
#line 1505
  return;
}
}
#line 1506 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_sod(opj_j2k_t *j2k ) 
{ 
  int len ;
  int truncate ;
  int i ;
  unsigned char *data ;
  unsigned char *data_ptr ;
  opj_cio_t *cio ;
  int curtileno ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *s ;
  unsigned char *e ;
  void *__cil_tmp18 ;
  unsigned int __cil_tmp19 ;

  {
#line 1507
  truncate = 0;
#line 1508
  data = (unsigned char *)((void *)0);
#line 1508
  data_ptr = (unsigned char *)((void *)0);
#line 1510
  cio = j2k->cio;
#line 1511
  curtileno = j2k->curtileno;
#line 1514
  if (j2k->cstr_info) {
    {
#line 1515
    __cil_tmp9 = cio_tell(cio);
#line 1515
    (((j2k->cstr_info)->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_header = (__cil_tmp9 + j2k->pos_correction) - 1;
    }
#line 1517
    if (j2k->cur_tp_num == 0) {
      {
#line 1518
      __cil_tmp10 = cio_tell(cio);
#line 1518
      ((j2k->cstr_info)->tile + j2k->curtileno)->end_header = (__cil_tmp10 + j2k->pos_correction) - 1;
      }
    }
#line 1519
    (j2k->cstr_info)->packno = 0;
  }
  {
#line 1522
  __cil_tmp11 = cio_getbp(cio);
#line 1522
  __cil_tmp12 = cio_numbytesleft(cio);
#line 1522
  __cil_tmp13 = int_min((int )(j2k->eot - __cil_tmp11), __cil_tmp12 + 1);
#line 1522
  len = __cil_tmp13;
#line 1524
  __cil_tmp14 = cio_numbytesleft(cio);
  }
#line 1524
  if (len == __cil_tmp14 + 1) {
#line 1525
    truncate = 1;
  }
  {
#line 1531
  s = cio_getbp(cio);
#line 1532
  e = s + len;
  }
#line 1534
  if (len > 8) {
#line 1534
    s = e - 8;
  }
#line 1536
  if ((int )*(e + -2) == 0) {
#line 1536
    if ((int )*(e + -1) == 0) {
      {
#line 1538
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1538
        if (! ((unsigned long )e > (unsigned long )s)) {
#line 1538
          goto while_break;
        }
#line 1540
        if ((int )*(e + -2) == 255) {
#line 1540
          if ((int )*(e + -1) == 217) {
#line 1540
            goto while_break;
          }
        }
#line 1541
        len --;
#line 1541
        e --;
#line 1541
        truncate = 1;
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: ;
    }
  }
  {
#line 1546
  data = *(j2k->tile_data + curtileno);
#line 1547
  __cil_tmp18 = realloc((void *)data, (unsigned long )(*(j2k->tile_len + curtileno) + len) * sizeof(unsigned char ));
#line 1547
  data = (unsigned char *)__cil_tmp18;
#line 1549
  data_ptr = data + *(j2k->tile_len + curtileno);
#line 1550
  i = 0;
  }
  {
#line 1550
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1550
    if (! (i < len)) {
#line 1550
      goto while_break___0;
    }
    {
#line 1551
    __cil_tmp19 = cio_read(cio, 1);
#line 1551
    *(data_ptr + i) = (unsigned char )__cil_tmp19;
#line 1550
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
#line 1554
  *(j2k->tile_len + curtileno) += len;
#line 1555
  *(j2k->tile_data + curtileno) = data;
#line 1557
  if (! truncate) {
#line 1558
    j2k->state = 8;
  } else {
#line 1560
    j2k->state = 64;
  }
#line 1562
  (j2k->cur_tp_num) ++;
#line 1563
  return;
}
}
#line 1565 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_rgn(opj_j2k_t *j2k , int compno , int tileno ) 
{ 
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_cio_t *cio ;
  int numcomps ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1566
  cp = j2k->cp;
#line 1567
  tcp = cp->tcps + tileno;
#line 1568
  cio = j2k->cio;
#line 1569
  numcomps = (j2k->image)->numcomps;
#line 1571
  cio_write(cio, 65374ULL, 2);
  }
#line 1572
  if (numcomps <= 256) {
#line 1572
    tmp = 5;
  } else {
#line 1572
    tmp = 6;
  }
  {
#line 1572
  cio_write(cio, (unsigned long long )tmp, 2);
  }
#line 1573
  if (numcomps <= 256) {
#line 1573
    tmp___0 = 1;
  } else {
#line 1573
    tmp___0 = 2;
  }
  {
#line 1573
  cio_write(cio, (unsigned long long )compno, tmp___0);
#line 1574
  cio_write(cio, 0ULL, 1);
#line 1575
  cio_write(cio, (unsigned long long )(tcp->tccps + compno)->roishift, 1);
  }
#line 1577
  return;
}
}
#line 1578 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_rgn(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  int roisty ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_cio_t *cio ;
  int numcomps ;
  unsigned int __cil_tmp10 ;
  int tmp___0 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;

  {
#line 1581
  cp = j2k->cp;
#line 1582
  if (j2k->state == 16) {
#line 1582
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 1582
    tmp = j2k->default_tcp;
  }
  {
#line 1582
  tcp = tmp;
#line 1583
  cio = j2k->cio;
#line 1584
  numcomps = (j2k->image)->numcomps;
#line 1586
  __cil_tmp10 = cio_read(cio, 2);
#line 1586
  len = (int )__cil_tmp10;
  }
#line 1587
  if (numcomps <= 256) {
#line 1587
    tmp___0 = 1;
  } else {
#line 1587
    tmp___0 = 2;
  }
  {
#line 1587
  __cil_tmp12 = cio_read(cio, tmp___0);
#line 1587
  compno = (int )__cil_tmp12;
#line 1588
  __cil_tmp13 = cio_read(cio, 1);
#line 1588
  roisty = (int )__cil_tmp13;
#line 1605
  __cil_tmp14 = cio_read(cio, 1);
#line 1605
  (tcp->tccps + compno)->roishift = (int )__cil_tmp14;
  }
#line 1607
  return;
}
}
#line 1608 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_write_eoc(opj_j2k_t *j2k ) 
{ 
  opj_cio_t *cio ;

  {
  {
#line 1609
  cio = j2k->cio;
#line 1611
  cio_write(cio, 65497ULL, 2);
  }
#line 1613
  return;
}
}
#line 1621 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_eoc(opj_j2k_t *j2k ) 
{ 
  int i ;
  int tileno ;
  opj_bool success ;
  opj_tcd_t *tcd ;
  opj_tcd_t *__cil_tmp6 ;

  {
#line 1623
  success = 0;
#line 1626
  if ((unsigned int )(j2k->cp)->limit_decoding != 2U) {
    {
#line 1627
    __cil_tmp6 = tcd_create(j2k->cinfo);
#line 1627
    tcd = __cil_tmp6;
#line 1628
    tcd_malloc_decode(tcd, j2k->image, j2k->cp);
#line 1629
    i = 0;
    }
    {
#line 1629
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1629
      if (! (i < (j2k->cp)->tileno_size)) {
#line 1629
        goto while_break;
      }
      {
#line 1630
      tcd_malloc_decode_tile(tcd, j2k->image, j2k->cp, i, j2k->cstr_info);
      }
#line 1631
      if (*((j2k->cp)->tileno + i) != -1) {
        {
#line 1633
        tileno = *((j2k->cp)->tileno + i);
#line 1634
        success = tcd_decode_tile(tcd, *(j2k->tile_data + tileno), *(j2k->tile_len + tileno),
                                  tileno, j2k->cstr_info);
#line 1635
        free((void *)*(j2k->tile_data + tileno));
#line 1636
        *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
#line 1637
        tcd_free_decode_tile(tcd, i);
        }
      } else {
#line 1640
        success = 0;
      }
#line 1641
      if (success == 0) {
#line 1642
        j2k->state |= 128;
#line 1643
        goto while_break;
      }
#line 1629
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 1646
    tcd_free_decode(tcd);
#line 1647
    tcd_destroy(tcd);
    }
  } else {
#line 1651
    i = 0;
    {
#line 1651
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1651
      if (! (i < (j2k->cp)->tileno_size)) {
#line 1651
        goto while_break___0;
      }
      {
#line 1652
      tileno = *((j2k->cp)->tileno + i);
#line 1653
      free((void *)*(j2k->tile_data + tileno));
#line 1654
      *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
#line 1651
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 1657
  if (j2k->state & 128) {
#line 1658
    j2k->state = 160;
  } else {
#line 1660
    j2k->state = 32;
  }
#line 1662
  return;
}
}
#line 1672 "/root/patchweave_new/2/libopenjpeg/j2k.c"
opj_dec_mstabent_t j2k_dec_mstab[20]  = 
#line 1672
  {      {65359, 1, & j2k_read_soc}, 
        {65424, 12, & j2k_read_sot}, 
        {65427, 16, & j2k_read_sod}, 
        {65497, 8, & j2k_read_eoc}, 
        {65361, 2, & j2k_read_siz}, 
        {65362, 20, & j2k_read_cod}, 
        {65363, 20, & j2k_read_coc}, 
        {65374, 20, & j2k_read_rgn}, 
        {65372, 20, & j2k_read_qcd}, 
        {65373, 20, & j2k_read_qcc}, 
        {65375, 20, & j2k_read_poc}, 
        {65365, 4, & j2k_read_tlm}, 
        {65367, 4, & j2k_read_plm}, 
        {65368, 16, & j2k_read_plt}, 
        {65376, 4, & j2k_read_ppm}, 
        {65377, 16, & j2k_read_ppt}, 
        {65425, 0, (void (*)(opj_j2k_t * ))0}, 
        {65379, 4, & j2k_read_crg}, 
        {65380, 20, & j2k_read_com}, 
        {0, 20, & j2k_read_unk}};
#line 1707 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_read_unk(opj_j2k_t *j2k ) 
{ 


  {
  {
#line 1708
  opj_event_msg(j2k->cinfo, 2, "Unknown marker\n");
  }
#line 1710
  return;
}
}
#line 1773 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static opj_dec_mstabent_t *j2k_dec_mstab_lookup(int id ) 
{ 
  opj_dec_mstabent_t *e ;

  {
#line 1775
  e = j2k_dec_mstab;
  {
#line 1775
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1775
    if (! (e->id != 0)) {
#line 1775
      goto while_break;
    }
#line 1776
    if (e->id == id) {
#line 1777
      goto while_break;
    }
#line 1775
    e ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1780
  return (e);
}
}
#line 1787 "/root/patchweave_new/2/libopenjpeg/j2k.c"
opj_j2k_t *j2k_create_decompress(opj_common_ptr cinfo ) 
{ 
  opj_j2k_t *j2k ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 1788
  __cil_tmp3 = calloc(1UL, sizeof(opj_j2k_t ));
#line 1788
  j2k = (opj_j2k_t *)__cil_tmp3;
  }
#line 1789
  if (! j2k) {
#line 1790
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 1792
  __cil_tmp4 = calloc(1UL, sizeof(opj_tcp_t ));
#line 1792
  j2k->default_tcp = (opj_tcp_t *)__cil_tmp4;
  }
#line 1793
  if (! j2k->default_tcp) {
    {
#line 1794
    free((void *)j2k);
    }
#line 1795
    return ((opj_j2k_t *)((void *)0));
  }
#line 1798
  j2k->cinfo = cinfo;
#line 1799
  j2k->tile_data = (unsigned char **)((void *)0);
#line 1801
  return (j2k);
}
}
#line 1804 "/root/patchweave_new/2/libopenjpeg/j2k.c"
void j2k_destroy_decompress(opj_j2k_t *j2k ) 
{ 
  int i ;
  int tileno ;
  opj_tcp_t *default_tcp ;
  opj_cp_t *cp ;

  {
#line 1805
  i = 0;
#line 1807
  if ((unsigned long )j2k->tile_len != (unsigned long )((void *)0)) {
    {
#line 1808
    free((void *)j2k->tile_len);
    }
  }
#line 1810
  if ((unsigned long )j2k->tile_data != (unsigned long )((void *)0)) {
#line 1811
    if ((unsigned long )j2k->cp != (unsigned long )((void *)0)) {
#line 1812
      i = 0;
      {
#line 1812
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1812
        if (! (i < (j2k->cp)->tileno_size)) {
#line 1812
          goto while_break;
        }
        {
#line 1813
        tileno = *((j2k->cp)->tileno + i);
#line 1814
        free((void *)*(j2k->tile_data + tileno));
#line 1815
        *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
#line 1812
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: ;
    }
    {
#line 1819
    free((void *)j2k->tile_data);
    }
  }
#line 1821
  if ((unsigned long )j2k->default_tcp != (unsigned long )((void *)0)) {
#line 1822
    default_tcp = j2k->default_tcp;
#line 1823
    if ((unsigned long )default_tcp->ppt_data_first != (unsigned long )((void *)0)) {
      {
#line 1824
      free((void *)default_tcp->ppt_data_first);
      }
    }
#line 1826
    if ((unsigned long )(j2k->default_tcp)->tccps != (unsigned long )((void *)0)) {
      {
#line 1827
      free((void *)(j2k->default_tcp)->tccps);
      }
    }
    {
#line 1829
    free((void *)j2k->default_tcp);
    }
  }
#line 1831
  if ((unsigned long )j2k->cp != (unsigned long )((void *)0)) {
#line 1832
    cp = j2k->cp;
#line 1833
    if ((unsigned long )cp->tcps != (unsigned long )((void *)0)) {
#line 1834
      i = 0;
      {
#line 1834
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1834
        if (! (i < cp->tw * cp->th)) {
#line 1834
          goto while_break___0;
        }
#line 1835
        if ((unsigned long )(cp->tcps + i)->ppt_data_first != (unsigned long )((void *)0)) {
          {
#line 1836
          free((void *)(cp->tcps + i)->ppt_data_first);
          }
        }
#line 1838
        if ((unsigned long )(cp->tcps + i)->tccps != (unsigned long )((void *)0)) {
          {
#line 1839
          free((void *)(cp->tcps + i)->tccps);
          }
        }
#line 1834
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
      {
#line 1842
      free((void *)cp->tcps);
      }
    }
#line 1844
    if ((unsigned long )cp->ppm_data_first != (unsigned long )((void *)0)) {
      {
#line 1845
      free((void *)cp->ppm_data_first);
      }
    }
#line 1847
    if ((unsigned long )cp->tileno != (unsigned long )((void *)0)) {
      {
#line 1848
      free((void *)cp->tileno);
      }
    }
#line 1850
    if ((unsigned long )cp->comment != (unsigned long )((void *)0)) {
      {
#line 1851
      free((void *)cp->comment);
      }
    }
    {
#line 1854
    free((void *)cp);
    }
  }
  {
#line 1856
  free((void *)j2k);
  }
#line 1858
  return;
}
}
#line 1859 "/root/patchweave_new/2/libopenjpeg/j2k.c"
void j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) 
{ 
  opj_cp_t *cp ;
  void *__cil_tmp4 ;

  {
#line 1860
  if (j2k) {
#line 1860
    if (parameters) {
      {
#line 1862
      __cil_tmp4 = calloc(1UL, sizeof(opj_cp_t ));
#line 1862
      cp = (opj_cp_t *)__cil_tmp4;
#line 1863
      cp->reduce = parameters->cp_reduce;
#line 1864
      cp->layer = parameters->cp_layer;
#line 1865
      cp->limit_decoding = parameters->cp_limit_decoding;
#line 1875
      j2k->cp = cp;
      }
    }
  }
#line 1879
  return;
}
}
#line 1879 "/root/patchweave_new/2/libopenjpeg/j2k.c"
opj_image_t *j2k_decode(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *image ;
  opj_common_ptr cinfo ;
  opj_dec_mstabent_t *e ;
  int id ;
  unsigned int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp14 ;

  {
#line 1880
  image = (opj_image_t *)((void *)0);
#line 1882
  cinfo = j2k->cinfo;
#line 1884
  j2k->cio = cio;
#line 1885
  j2k->cstr_info = cstr_info;
#line 1886
  if (cstr_info) {
    {
#line 1887
    memset((void *)cstr_info, 0, sizeof(opj_codestream_info_t ));
    }
  }
  {
#line 1890
  image = opj_image_create0();
#line 1891
  j2k->image = image;
#line 1893
  j2k->state = 1;
  }
  {
#line 1895
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1897
    __cil_tmp9 = cio_read(cio, 2);
#line 1897
    id = (int )__cil_tmp9;
    }
#line 1937
    if (id >> 8 != 255) {
      {
#line 1938
      __cil_tmp10 = cio_numbytesleft(cio);
      }
#line 1938
      if (__cil_tmp10 != 0) {
        {
#line 1940
        __cil_tmp11 = cio_tell(cio);
#line 1940
        opj_event_msg(cinfo, 1, "%.8x: expected a marker instead of %x\n", __cil_tmp11 - 2,
                      id);
#line 1941
        opj_image_destroy(image);
        }
#line 1942
        return ((opj_image_t *)0);
      }
      {
#line 1944
      __cil_tmp12 = cio_tell(cio);
#line 1944
      opj_event_msg(cinfo, 2, "%.8x: expected a marker instead of %x\n", __cil_tmp12 - 2,
                    id);
#line 1945
      j2k->state = 64;
      }
#line 1946
      goto while_break;
    }
    {
#line 1948
    e = j2k_dec_mstab_lookup(id);
    }
#line 1950
    if (! (j2k->state & e->states)) {
      {
#line 1951
      opj_image_destroy(image);
#line 1952
      __cil_tmp14 = cio_tell(cio);
#line 1952
      opj_event_msg(cinfo, 1, "%.8x: unexpected marker %x\n", __cil_tmp14 - 2, id);
      }
#line 1953
      return ((opj_image_t *)0);
    }
#line 1956
    if (e->id == 65424) {
#line 1956
      if ((unsigned int )(j2k->cp)->limit_decoding == 1U) {
        {
#line 1957
        opj_event_msg(cinfo, 4, "Main Header decoded.\n");
        }
#line 1958
        return (image);
      }
    }
#line 1961
    if (e->handler) {
      {
#line 1962
      (*(e->handler))(j2k);
      }
    }
#line 1964
    if (j2k->state & 128) {
      {
#line 1966
      opj_image_destroy(image);
      }
#line 1967
      return ((opj_image_t *)((void *)0));
    }
#line 1970
    if (j2k->state == 32) {
#line 1971
      goto while_break;
    }
#line 1973
    if (j2k->state == 64) {
#line 1974
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1977
  if (j2k->state == 64) {
    {
#line 1978
    j2k_read_eoc(j2k);
    }
  }
#line 1981
  if (j2k->state != 32) {
    {
#line 1982
    opj_event_msg(cinfo, 2, "Incomplete bitstream\n");
    }
  }
#line 1984
  return (image);
}
}
#line 1991 "/root/patchweave_new/2/libopenjpeg/j2k.c"
opj_image_t *j2k_decode_jpt_stream(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *image ;
  opj_jpt_msg_header_t header ;
  int position ;
  opj_common_ptr cinfo ;
  opj_dec_mstabent_t *e ;
  int id ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp20 ;

  {
  {
#line 1992
  image = (opj_image_t *)((void *)0);
#line 1995
  cinfo = j2k->cinfo;
#line 1999
  j2k->cio = cio;
#line 2002
  image = opj_image_create0();
#line 2003
  j2k->image = image;
#line 2005
  j2k->state = 1;
#line 2008
  jpt_init_msg_header(& header);
#line 2010
  jpt_read_msg_header(cinfo, cio, & header);
#line 2012
  position = cio_tell(cio);
  }
#line 2013
  if (header.Class_Id != 6U) {
    {
#line 2014
    opj_image_destroy(image);
#line 2015
    opj_event_msg(cinfo, 1, "[JPT-stream] : Expecting Main header first [class_Id %d] !\n",
                  header.Class_Id);
    }
#line 2016
    return ((opj_image_t *)0);
  }
  {
#line 2019
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2020
    e = (opj_dec_mstabent_t *)((void *)0);
#line 2023
    __cil_tmp12 = cio_numbytesleft(cio);
    }
#line 2023
    if (! __cil_tmp12) {
      {
#line 2024
      j2k_read_eoc(j2k);
      }
#line 2025
      return (image);
    }
    {
#line 2028
    __cil_tmp13 = cio_tell(cio);
    }
#line 2028
    if ((unsigned int )(__cil_tmp13 - position) == header.Msg_length) {
      {
#line 2029
      jpt_read_msg_header(cinfo, cio, & header);
#line 2030
      position = cio_tell(cio);
      }
#line 2031
      if (header.Class_Id != 4U) {
        {
#line 2032
        opj_image_destroy(image);
#line 2033
        opj_event_msg(cinfo, 1, "[JPT-stream] : Expecting Tile info !\n");
        }
#line 2034
        return ((opj_image_t *)0);
      }
    }
    {
#line 2038
    __cil_tmp15 = cio_read(cio, 2);
#line 2038
    id = (int )__cil_tmp15;
    }
#line 2039
    if (id >> 8 != 255) {
      {
#line 2040
      __cil_tmp16 = cio_numbytesleft(cio);
      }
#line 2040
      if (__cil_tmp16 != 0) {
        {
#line 2042
        __cil_tmp17 = cio_tell(cio);
#line 2042
        opj_event_msg(cinfo, 1, "%.8x: expected a marker instead of %x\n", __cil_tmp17 - 2,
                      id);
#line 2043
        opj_image_destroy(image);
        }
#line 2044
        return ((opj_image_t *)0);
      }
      {
#line 2046
      __cil_tmp18 = cio_tell(cio);
#line 2046
      opj_event_msg(cinfo, 2, "%.8x: expected a marker instead of %x\n", __cil_tmp18 - 2,
                    id);
#line 2047
      j2k->state = 64;
      }
#line 2048
      goto while_break;
    }
    {
#line 2050
    e = j2k_dec_mstab_lookup(id);
    }
#line 2051
    if (! (j2k->state & e->states)) {
      {
#line 2052
      opj_image_destroy(image);
#line 2053
      __cil_tmp20 = cio_tell(cio);
#line 2053
      opj_event_msg(cinfo, 1, "%.8x: unexpected marker %x\n\270\312U", __cil_tmp20 - 2,
                    id);
      }
#line 2054
      return ((opj_image_t *)0);
    }
#line 2056
    if (e->handler) {
      {
#line 2057
      (*(e->handler))(j2k);
      }
    }
#line 2059
    if (j2k->state == 32) {
#line 2060
      goto while_break;
    }
#line 2062
    if (j2k->state == 64) {
#line 2063
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2066
  if (j2k->state == 64) {
    {
#line 2067
    j2k_read_eoc(j2k);
    }
  }
#line 2070
  if (j2k->state != 32) {
    {
#line 2071
    opj_event_msg(cinfo, 2, "Incomplete bitstream\n");
    }
  }
#line 2074
  return (image);
}
}
#line 2081 "/root/patchweave_new/2/libopenjpeg/j2k.c"
opj_j2k_t *j2k_create_compress(opj_common_ptr cinfo ) 
{ 
  opj_j2k_t *j2k ;
  void *__cil_tmp3 ;

  {
  {
#line 2082
  __cil_tmp3 = calloc(1UL, sizeof(opj_j2k_t ));
#line 2082
  j2k = (opj_j2k_t *)__cil_tmp3;
  }
#line 2083
  if (j2k) {
#line 2084
    j2k->cinfo = cinfo;
  }
#line 2086
  return (j2k);
}
}
#line 2089 "/root/patchweave_new/2/libopenjpeg/j2k.c"
void j2k_destroy_compress(opj_j2k_t *j2k ) 
{ 
  int tileno ;
  opj_cp_t *cp ;

  {
#line 2092
  if (! j2k) {
#line 2092
    return;
  }
#line 2093
  if ((unsigned long )j2k->cp != (unsigned long )((void *)0)) {
#line 2094
    cp = j2k->cp;
#line 2096
    if (cp->comment) {
      {
#line 2097
      free((void *)cp->comment);
      }
    }
#line 2099
    if (cp->matrice) {
      {
#line 2100
      free((void *)cp->matrice);
      }
    }
#line 2102
    tileno = 0;
    {
#line 2102
    while (1) {
      while_continue: /* CIL Label */ ;

#line 2102
      if (! (tileno < cp->tw * cp->th)) {
#line 2102
        goto while_break;
      }
      {
#line 2103
      free((void *)(cp->tcps + tileno)->tccps);
#line 2102
      tileno ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 2105
    free((void *)cp->tcps);
#line 2106
    free((void *)cp);
    }
  }
  {
#line 2109
  free((void *)j2k);
  }
#line 2111
  return;
}
}
#line 2112 "/root/patchweave_new/2/libopenjpeg/j2k.c"
void j2k_setup_encoder(opj_j2k_t *j2k , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 
  int i ;
  int j ;
  int tileno ;
  int numpocs_tile ;
  opj_cp_t *cp ;
  void *__cil_tmp9 ;
  size_t array_size ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp17 ;
  opj_tcp_t *tcp ;
  opj_poc_t *tcp_poc ;
  void *__cil_tmp23 ;
  opj_tccp_t *tccp ;
  int tmp ;
  int tmp___0 ;
  int p ;
  int res_spec ;
  int size_prcw ;
  int size_prch ;
  int __cil_tmp39 ;

  {
#line 2114
  cp = (opj_cp_t *)((void *)0);
#line 2116
  if (! j2k) {
#line 2117
    return;
  } else
#line 2116
  if (! parameters) {
#line 2117
    return;
  } else
#line 2116
  if (! image) {
#line 2117
    return;
  }
  {
#line 2121
  __cil_tmp9 = calloc(1UL, sizeof(opj_cp_t ));
#line 2121
  cp = (opj_cp_t *)__cil_tmp9;
#line 2124
  j2k->cp = cp;
#line 2127
  cp->tw = 1;
#line 2128
  cp->th = 1;
#line 2133
  cp->cinema = parameters->cp_cinema;
#line 2134
  cp->max_comp_size = parameters->max_comp_size;
#line 2135
  cp->rsiz = parameters->cp_rsiz;
#line 2136
  cp->disto_alloc = parameters->cp_disto_alloc;
#line 2137
  cp->fixed_alloc = parameters->cp_fixed_alloc;
#line 2138
  cp->fixed_quality = parameters->cp_fixed_quality;
  }
#line 2141
  if (parameters->cp_matrice) {
    {
#line 2142
    array_size = (unsigned long )((parameters->tcp_numlayers * parameters->numresolution) * 3) * sizeof(int );
#line 2143
    __cil_tmp11 = malloc(array_size);
#line 2143
    cp->matrice = (int *)__cil_tmp11;
#line 2144
    memcpy((void *)cp->matrice, (void const   *)parameters->cp_matrice, array_size);
    }
  }
#line 2148
  cp->tdx = parameters->cp_tdx;
#line 2149
  cp->tdy = parameters->cp_tdy;
#line 2152
  cp->tx0 = parameters->cp_tx0;
#line 2153
  cp->ty0 = parameters->cp_ty0;
#line 2156
  if (parameters->cp_comment) {
    {
#line 2157
    __cil_tmp12 = strlen((char const   *)parameters->cp_comment);
#line 2157
    __cil_tmp13 = malloc(__cil_tmp12 + 1UL);
#line 2157
    cp->comment = (char *)__cil_tmp13;
    }
#line 2158
    if (cp->comment) {
      {
#line 2159
      strcpy(cp->comment, (char const   *)parameters->cp_comment);
      }
    }
  }
#line 2167
  if (parameters->tile_size_on) {
    {
#line 2168
    cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
#line 2169
    cp->th = int_ceildiv(image->y1 - cp->ty0, cp->tdy);
    }
  } else {
#line 2171
    cp->tdx = image->x1 - cp->tx0;
#line 2172
    cp->tdy = image->y1 - cp->ty0;
  }
#line 2175
  if (parameters->tp_on) {
#line 2176
    cp->tp_flag = parameters->tp_flag;
#line 2177
    cp->tp_on = (char)1;
  }
#line 2180
  cp->img_size = 0;
#line 2181
  i = 0;
  {
#line 2181
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2181
    if (! (i < image->numcomps)) {
#line 2181
      goto while_break;
    }
#line 2182
    cp->img_size += ((image->comps + i)->w * (image->comps + i)->h) * (image->comps + i)->prec;
#line 2181
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2245
  __cil_tmp17 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 2245
  cp->tcps = (opj_tcp_t *)__cil_tmp17;
#line 2247
  tileno = 0;
  }
  {
#line 2247
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 2247
    if (! (tileno < cp->tw * cp->th)) {
#line 2247
      goto while_break___0;
    }
#line 2248
    tcp = cp->tcps + tileno;
#line 2249
    tcp->numlayers = parameters->tcp_numlayers;
#line 2250
    j = 0;
    {
#line 2250
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 2250
      if (! (j < tcp->numlayers)) {
#line 2250
        goto while_break___1;
      }
#line 2251
      if (cp->cinema) {
#line 2252
        if (cp->fixed_quality) {
#line 2253
          tcp->distoratio[j] = parameters->tcp_distoratio[j];
        }
#line 2255
        tcp->rates[j] = parameters->tcp_rates[j];
      } else
#line 2257
      if (cp->fixed_quality) {
#line 2258
        tcp->distoratio[j] = parameters->tcp_distoratio[j];
      } else {
#line 2260
        tcp->rates[j] = parameters->tcp_rates[j];
      }
#line 2250
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___1: 
#line 2264
    tcp->csty = parameters->csty;
#line 2265
    tcp->prg = parameters->prog_order;
#line 2266
    tcp->mct = (int )parameters->tcp_mct;
#line 2268
    numpocs_tile = 0;
#line 2269
    tcp->POC = 0;
#line 2270
    if (parameters->numpocs) {
#line 2272
      tcp->POC = 1;
#line 2273
      i = 0;
      {
#line 2273
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 2273
        if (! (i < parameters->numpocs)) {
#line 2273
          goto while_break___2;
        }
#line 2274
        if (tileno == parameters->POC[i].tile - 1) {
          _L: 
#line 2275
          tcp_poc = & tcp->pocs[numpocs_tile];
#line 2276
          tcp_poc->resno0 = parameters->POC[numpocs_tile].resno0;
#line 2277
          tcp_poc->compno0 = parameters->POC[numpocs_tile].compno0;
#line 2278
          tcp_poc->layno1 = parameters->POC[numpocs_tile].layno1;
#line 2279
          tcp_poc->resno1 = parameters->POC[numpocs_tile].resno1;
#line 2280
          tcp_poc->compno1 = parameters->POC[numpocs_tile].compno1;
#line 2281
          tcp_poc->prg1 = parameters->POC[numpocs_tile].prg1;
#line 2282
          tcp_poc->tile = parameters->POC[numpocs_tile].tile;
#line 2283
          numpocs_tile ++;
        } else
#line 2274
        if (parameters->POC[i].tile == -1) {
#line 2274
          goto _L;
        }
#line 2273
        i ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___2: 
#line 2286
      tcp->numpocs = numpocs_tile - 1;
    } else {
#line 2288
      tcp->numpocs = 0;
    }
    {
#line 2291
    __cil_tmp23 = calloc((unsigned long )image->numcomps, sizeof(opj_tccp_t ));
#line 2291
    tcp->tccps = (opj_tccp_t *)__cil_tmp23;
#line 2293
    i = 0;
    }
    {
#line 2293
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 2293
      if (! (i < image->numcomps)) {
#line 2293
        goto while_break___3;
      }
      {
#line 2294
      tccp = tcp->tccps + i;
#line 2295
      tccp->csty = parameters->csty & 1;
#line 2296
      tccp->numresolutions = parameters->numresolution;
#line 2297
      tccp->cblkw = int_floorlog2(parameters->cblockw_init);
#line 2298
      tccp->cblkh = int_floorlog2(parameters->cblockh_init);
#line 2299
      tccp->cblksty = parameters->mode;
      }
#line 2300
      if (parameters->irreversible) {
#line 2300
        tmp = 0;
      } else {
#line 2300
        tmp = 1;
      }
#line 2300
      tccp->qmfbid = tmp;
#line 2301
      if (parameters->irreversible) {
#line 2301
        tmp___0 = 2;
      } else {
#line 2301
        tmp___0 = 0;
      }
#line 2301
      tccp->qntsty = tmp___0;
#line 2302
      tccp->numgbits = 2;
#line 2303
      if (i == parameters->roi_compno) {
#line 2304
        tccp->roishift = parameters->roi_shift;
      } else {
#line 2306
        tccp->roishift = 0;
      }
#line 2309
      if (parameters->cp_cinema) {
#line 2312
        tccp->prcw[0] = 7;
#line 2313
        tccp->prch[0] = 7;
#line 2315
        j = 1;
        {
#line 2315
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 2315
          if (! (j < tccp->numresolutions)) {
#line 2315
            goto while_break___4;
          }
#line 2316
          tccp->prcw[j] = 8;
#line 2317
          tccp->prch[j] = 8;
#line 2315
          j ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___4: ;
      } else
#line 2320
      if (parameters->csty & 1) {
#line 2321
        p = 0;
#line 2322
        j = tccp->numresolutions - 1;
        {
#line 2322
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 2322
          if (! (j >= 0)) {
#line 2322
            goto while_break___5;
          }
#line 2323
          if (p < parameters->res_spec) {
#line 2325
            if (parameters->prcw_init[p] < 1) {
#line 2326
              tccp->prcw[j] = 1;
            } else {
              {
#line 2328
              tccp->prcw[j] = int_floorlog2(parameters->prcw_init[p]);
              }
            }
#line 2331
            if (parameters->prch_init[p] < 1) {
#line 2332
              tccp->prch[j] = 1;
            } else {
              {
#line 2334
              tccp->prch[j] = int_floorlog2(parameters->prch_init[p]);
              }
            }
          } else {
#line 2338
            res_spec = parameters->res_spec;
#line 2339
            size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
#line 2340
            size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));
#line 2342
            if (size_prcw < 1) {
#line 2343
              tccp->prcw[j] = 1;
            } else {
              {
#line 2345
              tccp->prcw[j] = int_floorlog2(size_prcw);
              }
            }
#line 2348
            if (size_prch < 1) {
#line 2349
              tccp->prch[j] = 1;
            } else {
              {
#line 2351
              tccp->prch[j] = int_floorlog2(size_prch);
              }
            }
          }
#line 2354
          p ++;
#line 2322
          __cil_tmp39 = j;
#line 2322
          j --;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: ;
      } else {
#line 2358
        j = 0;
        {
#line 2358
        while (1) {
          while_continue___6: /* CIL Label */ ;

#line 2358
          if (! (j < tccp->numresolutions)) {
#line 2358
            goto while_break___6;
          }
#line 2359
          tccp->prcw[j] = 15;
#line 2360
          tccp->prch[j] = 15;
#line 2358
          j ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: ;
      }
      {
#line 2365
      dwt_calc_explicit_stepsizes(tccp, (image->comps + i)->prec);
#line 2293
      i ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___3: 
#line 2247
    tileno ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___0: ;
#line 2251
  return;
}
}
#line 2370 "/root/patchweave_new/2/libopenjpeg/j2k.c"
opj_bool j2k_encode(opj_j2k_t *j2k , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  int tileno ;
  int compno ;
  opj_cp_t *cp ;
  opj_tcd_t *tcd ;
  int compno___15 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp14 ;
  opj_tcp_t *tcp ;
  int __cil_tmp19 ;
  int pino ;
  int tilepartno ;
  int acc_pack_num ;
  opj_tcp_t *tcp___0 ;
  int __cil_tmp25 ;
  void *__cil_tmp26 ;
  int tot_num_tp ;
  int __cil_tmp29 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp36 ;
  int __cil_tmp38 ;

  {
#line 2372
  cp = (opj_cp_t *)((void *)0);
#line 2374
  tcd = (opj_tcd_t *)((void *)0);
#line 2376
  j2k->cio = cio;
#line 2377
  j2k->image = image;
#line 2379
  cp = j2k->cp;
#line 2382
  j2k->cstr_info = cstr_info;
#line 2383
  if (cstr_info) {
    {
#line 2385
    __cil_tmp10 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(opj_tile_info_t ));
#line 2385
    cstr_info->tile = (opj_tile_info_t *)__cil_tmp10;
#line 2386
    cstr_info->image_w = image->x1 - image->x0;
#line 2387
    cstr_info->image_h = image->y1 - image->y0;
#line 2388
    cstr_info->prog = (cp->tcps + 0)->prg;
#line 2389
    cstr_info->tw = cp->tw;
#line 2390
    cstr_info->th = cp->th;
#line 2391
    cstr_info->tile_x = cp->tdx;
#line 2392
    cstr_info->tile_y = cp->tdy;
#line 2393
    cstr_info->tile_Ox = cp->tx0;
#line 2394
    cstr_info->tile_Oy = cp->ty0;
#line 2395
    cstr_info->numcomps = image->numcomps;
#line 2396
    cstr_info->numlayers = (cp->tcps + 0)->numlayers;
#line 2397
    __cil_tmp11 = malloc((unsigned long )image->numcomps * sizeof(int ));
#line 2397
    cstr_info->numdecompos = (int *)__cil_tmp11;
#line 2398
    compno___15 = 0;
    }
    {
#line 2398
    while (1) {
      while_continue: /* CIL Label */ ;

#line 2398
      if (! (compno___15 < image->numcomps)) {
#line 2398
        goto while_break;
      }
#line 2399
      *(cstr_info->numdecompos + compno___15) = ((cp->tcps + 0)->tccps)->numresolutions - 1;
#line 2398
      compno___15 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break: 
    {
#line 2401
    cstr_info->D_max = 0.;
#line 2402
    cstr_info->main_head_start = cio_tell(cio);
#line 2403
    cstr_info->maxmarknum = 100;
#line 2404
    __cil_tmp14 = malloc((unsigned long )cstr_info->maxmarknum * sizeof(opj_marker_info_t ));
#line 2404
    cstr_info->marker = (opj_marker_info_t *)__cil_tmp14;
#line 2405
    cstr_info->marknum = 0;
    }
  }
  {
#line 2409
  j2k_write_soc(j2k);
#line 2410
  j2k_write_siz(j2k);
#line 2411
  j2k_write_cod(j2k);
#line 2412
  j2k_write_qcd(j2k);
  }
#line 2414
  if (cp->cinema) {
#line 2415
    compno = 1;
    {
#line 2415
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 2415
      if (! (compno < image->numcomps)) {
#line 2415
        goto while_break___0;
      }
      {
#line 2416
      j2k_write_coc(j2k, compno);
#line 2417
      j2k_write_qcc(j2k, compno);
#line 2415
      compno ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 2421
  compno = 0;
  {
#line 2421
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 2421
    if (! (compno < image->numcomps)) {
#line 2421
      goto while_break___1;
    }
#line 2422
    tcp = cp->tcps + 0;
#line 2423
    if ((tcp->tccps + compno)->roishift) {
      {
#line 2424
      j2k_write_rgn(j2k, compno, 0);
      }
    }
#line 2421
    compno ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: ;
#line 2426
  if ((unsigned long )cp->comment != (unsigned long )((void *)0)) {
    {
#line 2427
    j2k_write_com(j2k);
    }
  }
  {
#line 2430
  j2k->totnum_tp = j2k_calculate_tp(cp, image->numcomps, image, j2k);
  }
#line 2432
  if (cp->cinema) {
    {
#line 2433
    j2k_write_tlm(j2k);
    }
#line 2434
    if ((unsigned int )cp->cinema == 3U) {
      {
#line 2435
      j2k_write_poc(j2k);
      }
    }
  }
#line 2443
  if (cstr_info) {
    {
#line 2444
    __cil_tmp19 = cio_tell(cio);
#line 2444
    cstr_info->main_head_end = __cil_tmp19 - 1;
    }
  }
  {
#line 2450
  tcd = tcd_create(j2k->cinfo);
#line 2453
  tileno = 0;
  }
  {
#line 2453
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 2453
    if (! (tileno < cp->tw * cp->th)) {
#line 2453
      goto while_break___2;
    }
    {
#line 2455
    tilepartno = 0;
#line 2457
    acc_pack_num = 0;
#line 2461
    tcp___0 = cp->tcps + tileno;
#line 2462
    opj_event_msg(j2k->cinfo, 4, "tile number %d / %d\n", tileno + 1, cp->tw * cp->th);
#line 2464
    j2k->curtileno = tileno;
#line 2465
    j2k->cur_tp_num = 0;
#line 2466
    tcd->cur_totnum_tp = *(j2k->cur_totnum_tp + j2k->curtileno);
    }
#line 2468
    if (tileno == 0) {
      {
#line 2469
      tcd_malloc_encode(tcd, image, cp, j2k->curtileno);
      }
    } else {
      {
#line 2471
      tcd_init_encode(tcd, image, cp, j2k->curtileno);
      }
    }
#line 2475
    if (cstr_info) {
      {
#line 2476
      __cil_tmp25 = cio_tell(cio);
#line 2476
      (cstr_info->tile + j2k->curtileno)->start_pos = __cil_tmp25 + j2k->pos_correction;
#line 2477
      (cstr_info->tile + j2k->curtileno)->maxmarknum = 10;
#line 2478
      __cil_tmp26 = malloc((unsigned long )(cstr_info->tile + j2k->curtileno)->maxmarknum * sizeof(opj_marker_info_t ));
#line 2478
      (cstr_info->tile + j2k->curtileno)->marker = (opj_marker_info_t *)__cil_tmp26;
#line 2479
      (cstr_info->tile + j2k->curtileno)->marknum = 0;
      }
    }
#line 2483
    pino = 0;
    {
#line 2483
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 2483
      if (! (pino <= tcp___0->numpocs)) {
#line 2483
        goto while_break___3;
      }
      {
#line 2485
      tcd->cur_pino = pino;
#line 2488
      tot_num_tp = j2k_get_num_tp(cp, pino, tileno);
#line 2489
      tcd->tp_pos = cp->tp_pos;
#line 2491
      tilepartno = 0;
      }
      {
#line 2491
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 2491
        if (! (tilepartno < tot_num_tp)) {
#line 2491
          goto while_break___4;
        }
#line 2492
        j2k->tp_num = tilepartno;
#line 2494
        if (cstr_info) {
          {
#line 2495
          __cil_tmp29 = cio_tell(cio);
#line 2495
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_start_pos = __cil_tmp29 + j2k->pos_correction;
          }
        }
        {
#line 2498
        j2k_write_sot(j2k);
        }
#line 2500
        if (j2k->cur_tp_num == 0) {
#line 2500
          if ((unsigned int )cp->cinema == 0U) {
#line 2501
            compno = 1;
            {
#line 2501
            while (1) {
              while_continue___5: /* CIL Label */ ;

#line 2501
              if (! (compno < image->numcomps)) {
#line 2501
                goto while_break___5;
              }
              {
#line 2502
              j2k_write_coc(j2k, compno);
#line 2503
              j2k_write_qcc(j2k, compno);
#line 2501
              compno ++;
              }
            }
            while_break___12: /* CIL Label */ ;
            }
            while_break___5: ;
#line 2505
            if ((cp->tcps + tileno)->numpocs) {
              {
#line 2506
              j2k_write_poc(j2k);
              }
            }
          }
        }
#line 2511
        if (cstr_info) {
          {
#line 2512
          __cil_tmp31 = cio_tell(cio);
#line 2512
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_header = (__cil_tmp31 + j2k->pos_correction) + 1;
          }
        }
        {
#line 2516
        j2k_write_sod(j2k, (void *)tcd);
        }
#line 2519
        if (cstr_info) {
          {
#line 2520
          __cil_tmp32 = cio_tell(cio);
#line 2520
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_pos = (__cil_tmp32 + j2k->pos_correction) - 1;
#line 2522
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_start_pack = acc_pack_num;
#line 2524
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_numpacks = cstr_info->packno - acc_pack_num;
#line 2526
          acc_pack_num = cstr_info->packno;
          }
        }
#line 2530
        (j2k->cur_tp_num) ++;
#line 2491
        tilepartno ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: 
#line 2483
      pino ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___3: ;
#line 2533
    if (cstr_info) {
      {
#line 2534
      __cil_tmp36 = cio_tell(cio);
#line 2534
      (cstr_info->tile + j2k->curtileno)->end_pos = (__cil_tmp36 + j2k->pos_correction) - 1;
      }
    }
#line 2453
    tileno ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 2557
  tcd_free_encode(tcd);
#line 2558
  tcd_destroy(tcd);
#line 2560
  free((void *)j2k->cur_totnum_tp);
#line 2562
  j2k_write_eoc(j2k);
  }
#line 2564
  if (cstr_info) {
    {
#line 2565
    __cil_tmp38 = cio_tell(cio);
#line 2565
    cstr_info->codestream_size = __cil_tmp38 + j2k->pos_correction;
#line 2570
    cstr_info->codestream_size -= cstr_info->main_head_start;
    }
  }
#line 2586
  return (1);
}
}
#line 2589 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_add_mhmarker(opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) 
{ 
  void *__cil_tmp5 ;

  {
#line 2591
  if (! cstr_info) {
#line 2592
    return;
  }
#line 2595
  if (cstr_info->marknum + 1 > cstr_info->maxmarknum) {
    {
#line 2596
    cstr_info->maxmarknum = 100 + (int )((float )cstr_info->maxmarknum * 1.f);
#line 2597
    __cil_tmp5 = realloc((void *)cstr_info->marker, (unsigned long )cstr_info->maxmarknum);
#line 2597
    cstr_info->marker = (opj_marker_info_t *)__cil_tmp5;
    }
  }
#line 2601
  (cstr_info->marker + cstr_info->marknum)->type = type;
#line 2602
  (cstr_info->marker + cstr_info->marknum)->pos = pos;
#line 2603
  (cstr_info->marker + cstr_info->marknum)->len = len;
#line 2604
  (cstr_info->marknum) ++;
#line 2605
  return;
}
}
#line 2608 "/root/patchweave_new/2/libopenjpeg/j2k.c"
static void j2k_add_tlmarker(int tileno , opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) 
{ 
  opj_marker_info_t *marker ;
  void *__cil_tmp7 ;

  {
#line 2612
  if (! cstr_info) {
#line 2613
    return;
  }
#line 2616
  if ((cstr_info->tile + tileno)->marknum + 1 > (cstr_info->tile + tileno)->maxmarknum) {
    {
#line 2617
    (cstr_info->tile + tileno)->maxmarknum = 100 + (int )((float )(cstr_info->tile + tileno)->maxmarknum * 1.f);
#line 2618
    __cil_tmp7 = realloc((void *)(cstr_info->tile + tileno)->marker, (unsigned long )cstr_info->maxmarknum);
#line 2618
    (cstr_info->tile + tileno)->marker = (opj_marker_info_t *)__cil_tmp7;
    }
  }
#line 2621
  marker = (cstr_info->tile + tileno)->marker + (cstr_info->tile + tileno)->marknum;
#line 2624
  marker->type = type;
#line 2625
  marker->pos = pos;
#line 2626
  marker->len = len;
#line 2627
  ((cstr_info->tile + tileno)->marknum) ++;
#line 2628
  return;
}
}
#line 29 "/root/patchweave_new/2/libopenjpeg/image.c"
opj_image_t *opj_image_create0(void) 
{ 
  opj_image_t *image ;
  void *__cil_tmp2 ;

  {
  {
#line 30
  __cil_tmp2 = calloc(1UL, sizeof(opj_image_t ));
#line 30
  image = (opj_image_t *)__cil_tmp2;
  }
#line 31
  return (image);
}
}
#line 34 "/root/patchweave_new/2/libopenjpeg/image.c"
opj_image_t *opj_image_create(int numcmpts , opj_image_cmptparm_t *cmptparms , OPJ_COLOR_SPACE clrspc ) 
{ 
  int compno ;
  opj_image_t *image ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_image_comp_t *comp ;
  void *__cil_tmp9 ;

  {
  {
#line 36
  image = (opj_image_t *)((void *)0);
#line 38
  __cil_tmp6 = calloc(1UL, sizeof(opj_image_t ));
#line 38
  image = (opj_image_t *)__cil_tmp6;
  }
#line 39
  if (image) {
    {
#line 40
    image->color_space = clrspc;
#line 41
    image->numcomps = numcmpts;
#line 43
    __cil_tmp7 = malloc((unsigned long )image->numcomps * sizeof(opj_image_comp_t ));
#line 43
    image->comps = (opj_image_comp_t *)__cil_tmp7;
    }
#line 44
    if (! image->comps) {
      {
#line 45
      fprintf(stderr, "Unable to allocate memory for image.\n");
#line 46
      opj_image_destroy(image);
      }
#line 47
      return ((opj_image_t *)((void *)0));
    }
#line 50
    compno = 0;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;

#line 50
      if (! (compno < numcmpts)) {
#line 50
        goto while_break;
      }
      {
#line 51
      comp = image->comps + compno;
#line 52
      comp->dx = (cmptparms + compno)->dx;
#line 53
      comp->dy = (cmptparms + compno)->dy;
#line 54
      comp->w = (cmptparms + compno)->w;
#line 55
      comp->h = (cmptparms + compno)->h;
#line 56
      comp->x0 = (cmptparms + compno)->x0;
#line 57
      comp->y0 = (cmptparms + compno)->y0;
#line 58
      comp->prec = (cmptparms + compno)->prec;
#line 59
      comp->bpp = (cmptparms + compno)->bpp;
#line 60
      comp->sgnd = (cmptparms + compno)->sgnd;
#line 61
      __cil_tmp9 = calloc((unsigned long )(comp->w * comp->h), sizeof(int ));
#line 61
      comp->data = (int *)__cil_tmp9;
      }
#line 62
      if (! comp->data) {
        {
#line 63
        fprintf(stderr, "Unable to allocate memory for image.\n");
#line 64
        opj_image_destroy(image);
        }
#line 65
        return ((opj_image_t *)((void *)0));
      }
#line 50
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 70
  return (image);
}
}
#line 73 "/root/patchweave_new/2/libopenjpeg/image.c"
void opj_image_destroy(opj_image_t *image ) 
{ 
  int i ;
  opj_image_comp_t *image_comp ;

  {
#line 75
  if (image) {
#line 76
    if (image->comps) {
#line 78
      i = 0;
      {
#line 78
      while (1) {
        while_continue: /* CIL Label */ ;

#line 78
        if (! (i < image->numcomps)) {
#line 78
          goto while_break;
        }
#line 79
        image_comp = image->comps + i;
#line 80
        if (image_comp->data) {
          {
#line 81
          free((void *)image_comp->data);
          }
        }
#line 78
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 84
      free((void *)image->comps);
      }
    }
    {
#line 86
    free((void *)image);
    }
  }
#line 89
  return;
}
}
#line 65 "/root/patchweave_new/2/libopenjpeg/event.c"
opj_event_mgr_t *opj_set_event_mgr(opj_common_ptr cinfo , opj_event_mgr_t *event_mgr ,
                                   void *context ) 
{ 
  opj_event_mgr_t *previous ;

  {
#line 66
  if (cinfo) {
#line 67
    previous = cinfo->event_mgr;
#line 68
    cinfo->event_mgr = event_mgr;
#line 69
    cinfo->client_data = context;
#line 70
    return (previous);
  }
#line 73
  return ((opj_event_mgr_t *)((void *)0));
}
}
#line 76 "/root/patchweave_new/2/libopenjpeg/event.c"
opj_bool opj_event_msg(opj_common_ptr cinfo , int event_type , char const   *fmt 
                       , ...) 
{ 
  void (*msg_handler)(char const   * , void * ) ;
  opj_event_mgr_t *event_mgr ;
  va_list arg ;
  int str_length ;
  char message[512] ;

  {
#line 78
  msg_handler = (void (*)(char const   * , void * ))((void *)0);
#line 80
  event_mgr = cinfo->event_mgr;
#line 81
  if ((unsigned long )event_mgr != (unsigned long )((void *)0)) {
#line 83
    if (event_type == 1) {
#line 83
      goto case_1;
    }
#line 86
    if (event_type == 2) {
#line 86
      goto case_2;
    }
#line 89
    if (event_type == 4) {
#line 89
      goto case_4;
    }
#line 92
    goto switch_default;
    case_1: 
#line 84
    msg_handler = event_mgr->error_handler;
#line 85
    goto switch_break;
    case_2: 
#line 87
    msg_handler = event_mgr->warning_handler;
#line 88
    goto switch_break;
    case_4: 
#line 90
    msg_handler = event_mgr->info_handler;
#line 91
    goto switch_break;
    switch_default: 
#line 93
    goto switch_break;
    switch_break: ;
#line 95
    if ((unsigned long )msg_handler == (unsigned long )((void *)0)) {
#line 96
      return (0);
    }
  } else {
#line 99
    return (0);
  }
#line 102
  if ((unsigned long )fmt != (unsigned long )((void *)0)) {
#line 102
    if ((unsigned long )event_mgr != (unsigned long )((void *)0)) {
      {
#line 107
      __builtin_va_start((__builtin_va_list )((void *)arg), fmt);
#line 109
      str_length = vsnprintf(message, 512UL, fmt, (__gnuc_va_list )((void *)arg));
#line 111
      __builtin_va_end((__builtin_va_list )((void *)arg));
      }
#line 114
      if (str_length > -1) {
#line 114
        if (str_length < 512) {
          {
#line 115
          (*msg_handler)((char const   *)(message), cinfo->client_data);
          }
        } else {
#line 116
          return (0);
        }
      } else {
#line 116
        return (0);
      }
    }
  }
#line 119
  return (1);
}
}
#line 67 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static float const   dwt_alpha  =    (float const   )1.58613431454f;
#line 68 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static float const   dwt_beta  =    (float const   )0.0529801174999f;
#line 69 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static float const   dwt_gamma  =    (float const   )(- 0.882911086083f);
#line 70 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static float const   dwt_delta  =    (float const   )(- 0.443506866694f);
#line 72 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static float const   K  =    (float const   )1.23017406464f;
#line 74 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static float const   c13318  =    (float const   )1.62573242188f;
#line 89
static void dwt_deinterleave_h(int *a , int *b , int dn , int sn , int cas ) ;
#line 93
static void dwt_deinterleave_v(int *a , int *b , int dn , int sn , int x , int cas ) ;
#line 97
static void dwt_interleave_h(dwt_t *h , int *a ) ;
#line 101
static void dwt_interleave_v(dwt_t *v , int *a , int x ) ;
#line 105
static void dwt_encode_1(int *a , int dn , int sn , int cas ) ;
#line 109
static void dwt_decode_1(dwt_t *v ) ;
#line 113
static void dwt_encode_1_real(int *a , int dn , int sn , int cas ) ;
#line 117
static void dwt_encode_stepsize(int stepsize , int numbps , opj_stepsize_t *bandno_stepsize ) ;
#line 121
static void dwt_decode_tile(opj_tcd_tilecomp_t *tilec , int numres , void (*dwt_1D)(dwt_t * ) ) ;
#line 138 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static double const   dwt_norms[4][10]  = { {        (double const   )1.,        (double const   )1.5,        (double const   )2.75,        (double const   )5.375, 
            (double const   )10.68,        (double const   )21.34,        (double const   )42.6700000001,        (double const   )85.33, 
            (double const   )170.7,        (double const   )341.300000001}, 
   {        (double const   )1.03800000001,        (double const   )1.59200000001,        (double const   )2.91900000001,        (double const   )5.70300000001, 
            (double const   )11.3300000001,        (double const   )22.6400000001,        (double const   )45.25,        (double const   )90.4800000001, 
            (double const   )180.900000001}, 
   {        (double const   )1.03800000001,        (double const   )1.59200000001,        (double const   )2.91900000001,        (double const   )5.70300000001, 
            (double const   )11.3300000001,        (double const   )22.6400000001,        (double const   )45.25,        (double const   )90.4800000001, 
            (double const   )180.900000001}, 
   {        (double const   )0.718600000001,        (double const   )0.9218,        (double const   )1.58600000001,        (double const   )3.04300000001, 
            (double const   )6.01900000001,        (double const   )12.01,        (double const   )24.,        (double const   )47.97, 
            (double const   )95.9300000001}};
#line 148 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static double const   dwt_norms_real[4][10]  = { {        (double const   )1.,        (double const   )1.96500000001,        (double const   )4.177,        (double const   )8.40300000001, 
            (double const   )16.9,        (double const   )33.8400000001,        (double const   )67.69,        (double const   )135.300000001, 
            (double const   )270.600000001,        (double const   )540.9}, 
   {        (double const   )2.022,        (double const   )3.989,        (double const   )8.35500000001,        (double const   )17.04, 
            (double const   )34.2700000001,        (double const   )68.63,        (double const   )137.300000001,        (double const   )274.600000001, 
            (double const   )549.}, 
   {        (double const   )2.022,        (double const   )3.989,        (double const   )8.35500000001,        (double const   )17.04, 
            (double const   )34.2700000001,        (double const   )68.63,        (double const   )137.300000001,        (double const   )274.600000001, 
            (double const   )549.}, 
   {        (double const   )2.08000000001,        (double const   )3.86500000001,        (double const   )8.30700000001,        (double const   )17.18, 
            (double const   )34.7100000001,        (double const   )69.5900000001,        (double const   )139.300000001,        (double const   )278.600000001, 
            (double const   )557.200000001}};
#line 164 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static void dwt_deinterleave_h(int *a , int *b , int dn , int sn , int cas ) 
{ 
  int i ;

  {
#line 166
  i = 0;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;

#line 166
    if (! (i < sn)) {
#line 166
      goto while_break;
    }
#line 166
    *(b + i) = *(a + (2 * i + cas));
#line 166
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 167
  i = 0;
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 167
    if (! (i < dn)) {
#line 167
      goto while_break___0;
    }
#line 167
    *(b + (sn + i)) = *(a + ((2 * i + 1) - cas));
#line 167
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 171
  return;
}
}
#line 173 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static void dwt_deinterleave_v(int *a , int *b , int dn , int sn , int x , int cas ) 
{ 
  int i ;

  {
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;

#line 175
    if (! (i < sn)) {
#line 175
      goto while_break;
    }
#line 175
    *(b + i * x) = *(a + (2 * i + cas));
#line 175
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 176
  i = 0;
  {
#line 176
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 176
    if (! (i < dn)) {
#line 176
      goto while_break___0;
    }
#line 176
    *(b + (sn + i) * x) = *(a + ((2 * i + 1) - cas));
#line 176
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 180
  return;
}
}
#line 182 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static void dwt_interleave_h(dwt_t *h , int *a ) 
{ 
  int *ai ;
  int *bi ;
  int i ;
  int __cil_tmp6 ;
  int *__cil_tmp7 ;
  int __cil_tmp8 ;
  int *__cil_tmp9 ;

  {
#line 183
  ai = a;
#line 184
  bi = h->mem + h->cas;
#line 185
  i = h->sn;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    __cil_tmp6 = i;
#line 186
    i --;
#line 186
    if (! __cil_tmp6) {
#line 186
      goto while_break;
    }
#line 187
    __cil_tmp7 = ai;
#line 187
    ai ++;
#line 187
    *bi = *__cil_tmp7;
#line 188
    bi += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 190
  ai = a + h->sn;
#line 191
  bi = (h->mem + 1) - h->cas;
#line 192
  i = h->dn;
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 193
    __cil_tmp8 = i;
#line 193
    i --;
#line 193
    if (! __cil_tmp8) {
#line 193
      goto while_break___0;
    }
#line 194
    __cil_tmp9 = ai;
#line 194
    ai ++;
#line 194
    *bi = *__cil_tmp9;
#line 195
    bi += 2;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 199
  return;
}
}
#line 202 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static void dwt_interleave_v(dwt_t *v , int *a , int x ) 
{ 
  int *ai ;
  int *bi ;
  int i ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 203
  ai = a;
#line 204
  bi = v->mem + v->cas;
#line 205
  i = v->sn;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    __cil_tmp7 = i;
#line 206
    i --;
#line 206
    if (! __cil_tmp7) {
#line 206
      goto while_break;
    }
#line 207
    *bi = *ai;
#line 208
    bi += 2;
#line 209
    ai += x;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 211
  ai = a + v->sn * x;
#line 212
  bi = (v->mem + 1) - v->cas;
#line 213
  i = v->dn;
  {
#line 214
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 214
    __cil_tmp8 = i;
#line 214
    i --;
#line 214
    if (! __cil_tmp8) {
#line 214
      goto while_break___0;
    }
#line 215
    *bi = *ai;
#line 216
    bi += 2;
#line 217
    ai += x;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 221
  return;
}
}
#line 225 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static void dwt_encode_1(int *a , int dn , int sn , int cas ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 228
  if (! cas) {
#line 229
    if (dn > 0) {
      _L: 
#line 230
      i = 0;
      {
#line 230
      while (1) {
        while_continue: /* CIL Label */ ;

#line 230
        if (! (i < dn)) {
#line 230
          goto while_break;
        }
#line 230
        if (i + 1 < 0) {
#line 230
          tmp___2 = *(a + 0);
        } else {
#line 230
          if (i + 1 >= sn) {
#line 230
            tmp___1 = *(a + (sn - 1) * 2);
          } else {
#line 230
            tmp___1 = *(a + (i + 1) * 2);
          }
#line 230
          tmp___2 = tmp___1;
        }
#line 230
        if (i < 0) {
#line 230
          tmp___0 = *(a + 0);
        } else {
#line 230
          if (i >= sn) {
#line 230
            tmp = *(a + (sn - 1) * 2);
          } else {
#line 230
            tmp = *(a + i * 2);
          }
#line 230
          tmp___0 = tmp;
        }
#line 230
        *(a + (1 + i * 2)) -= (tmp___0 + tmp___2) >> 1;
#line 230
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break: 
#line 231
      i = 0;
      {
#line 231
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 231
        if (! (i < sn)) {
#line 231
          goto while_break___0;
        }
#line 231
        if (i < 0) {
#line 231
          tmp___6 = *(a + 1);
        } else {
#line 231
          if (i >= dn) {
#line 231
            tmp___5 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 231
            tmp___5 = *(a + (1 + i * 2));
          }
#line 231
          tmp___6 = tmp___5;
        }
#line 231
        if (i - 1 < 0) {
#line 231
          tmp___4 = *(a + 1);
        } else {
#line 231
          if (i - 1 >= dn) {
#line 231
            tmp___3 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 231
            tmp___3 = *(a + (1 + (i - 1) * 2));
          }
#line 231
          tmp___4 = tmp___3;
        }
#line 231
        *(a + i * 2) += ((tmp___4 + tmp___6) + 2) >> 2;
#line 231
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: ;
    } else
#line 229
    if (sn > 1) {
#line 229
      goto _L;
    }
  } else
#line 234
  if (! sn) {
#line 234
    if (dn == 1) {
#line 235
      *(a + 0) *= 2;
    } else {
#line 234
      goto _L___16;
    }
  } else {
    _L___16: 
#line 237
    i = 0;
    {
#line 237
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 237
      if (! (i < dn)) {
#line 237
        goto while_break___1;
      }
#line 237
      if (i - 1 < 0) {
#line 237
        tmp___10 = *(a + 1);
      } else {
#line 237
        if (i - 1 >= sn) {
#line 237
          tmp___9 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 237
          tmp___9 = *(a + (1 + (i - 1) * 2));
        }
#line 237
        tmp___10 = tmp___9;
      }
#line 237
      if (i < 0) {
#line 237
        tmp___8 = *(a + 1);
      } else {
#line 237
        if (i >= sn) {
#line 237
          tmp___7 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 237
          tmp___7 = *(a + (1 + i * 2));
        }
#line 237
        tmp___8 = tmp___7;
      }
#line 237
      *(a + i * 2) -= (tmp___8 + tmp___10) >> 1;
#line 237
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 238
    i = 0;
    {
#line 238
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 238
      if (! (i < sn)) {
#line 238
        goto while_break___2;
      }
#line 238
      if (i + 1 < 0) {
#line 238
        tmp___14 = *(a + 0);
      } else {
#line 238
        if (i + 1 >= dn) {
#line 238
          tmp___13 = *(a + (dn - 1) * 2);
        } else {
#line 238
          tmp___13 = *(a + (i + 1) * 2);
        }
#line 238
        tmp___14 = tmp___13;
      }
#line 238
      if (i < 0) {
#line 238
        tmp___12 = *(a + 0);
      } else {
#line 238
        if (i >= dn) {
#line 238
          tmp___11 = *(a + (dn - 1) * 2);
        } else {
#line 238
          tmp___11 = *(a + i * 2);
        }
#line 238
        tmp___12 = tmp___11;
      }
#line 238
      *(a + (1 + i * 2)) += ((tmp___12 + tmp___14) + 2) >> 2;
#line 238
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 243
  return;
}
}
#line 246 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static void dwt_decode_1_(int *a , int dn , int sn , int cas ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 249
  if (! cas) {
#line 250
    if (dn > 0) {
      _L: 
#line 251
      i = 0;
      {
#line 251
      while (1) {
        while_continue: /* CIL Label */ ;

#line 251
        if (! (i < sn)) {
#line 251
          goto while_break;
        }
#line 251
        if (i < 0) {
#line 251
          tmp___2 = *(a + 1);
        } else {
#line 251
          if (i >= dn) {
#line 251
            tmp___1 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 251
            tmp___1 = *(a + (1 + i * 2));
          }
#line 251
          tmp___2 = tmp___1;
        }
#line 251
        if (i - 1 < 0) {
#line 251
          tmp___0 = *(a + 1);
        } else {
#line 251
          if (i - 1 >= dn) {
#line 251
            tmp = *(a + (1 + (dn - 1) * 2));
          } else {
#line 251
            tmp = *(a + (1 + (i - 1) * 2));
          }
#line 251
          tmp___0 = tmp;
        }
#line 251
        *(a + i * 2) -= ((tmp___0 + tmp___2) + 2) >> 2;
#line 251
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break: 
#line 252
      i = 0;
      {
#line 252
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 252
        if (! (i < dn)) {
#line 252
          goto while_break___0;
        }
#line 252
        if (i + 1 < 0) {
#line 252
          tmp___6 = *(a + 0);
        } else {
#line 252
          if (i + 1 >= sn) {
#line 252
            tmp___5 = *(a + (sn - 1) * 2);
          } else {
#line 252
            tmp___5 = *(a + (i + 1) * 2);
          }
#line 252
          tmp___6 = tmp___5;
        }
#line 252
        if (i < 0) {
#line 252
          tmp___4 = *(a + 0);
        } else {
#line 252
          if (i >= sn) {
#line 252
            tmp___3 = *(a + (sn - 1) * 2);
          } else {
#line 252
            tmp___3 = *(a + i * 2);
          }
#line 252
          tmp___4 = tmp___3;
        }
#line 252
        *(a + (1 + i * 2)) += (tmp___4 + tmp___6) >> 1;
#line 252
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: ;
    } else
#line 250
    if (sn > 1) {
#line 250
      goto _L;
    }
  } else
#line 255
  if (! sn) {
#line 255
    if (dn == 1) {
#line 256
      *(a + 0) /= 2;
    } else {
#line 255
      goto _L___17;
    }
  } else {
    _L___17: 
#line 258
    i = 0;
    {
#line 258
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 258
      if (! (i < sn)) {
#line 258
        goto while_break___1;
      }
#line 258
      if (i + 1 < 0) {
#line 258
        tmp___10 = *(a + 0);
      } else {
#line 258
        if (i + 1 >= dn) {
#line 258
          tmp___9 = *(a + (dn - 1) * 2);
        } else {
#line 258
          tmp___9 = *(a + (i + 1) * 2);
        }
#line 258
        tmp___10 = tmp___9;
      }
#line 258
      if (i < 0) {
#line 258
        tmp___8 = *(a + 0);
      } else {
#line 258
        if (i >= dn) {
#line 258
          tmp___7 = *(a + (dn - 1) * 2);
        } else {
#line 258
          tmp___7 = *(a + i * 2);
        }
#line 258
        tmp___8 = tmp___7;
      }
#line 258
      *(a + (1 + i * 2)) -= ((tmp___8 + tmp___10) + 2) >> 2;
#line 258
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 259
    i = 0;
    {
#line 259
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 259
      if (! (i < dn)) {
#line 259
        goto while_break___2;
      }
#line 259
      if (i - 1 < 0) {
#line 259
        tmp___14 = *(a + 1);
      } else {
#line 259
        if (i - 1 >= sn) {
#line 259
          tmp___13 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 259
          tmp___13 = *(a + (1 + (i - 1) * 2));
        }
#line 259
        tmp___14 = tmp___13;
      }
#line 259
      if (i < 0) {
#line 259
        tmp___12 = *(a + 1);
      } else {
#line 259
        if (i >= sn) {
#line 259
          tmp___11 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 259
          tmp___11 = *(a + (1 + i * 2));
        }
#line 259
        tmp___12 = tmp___11;
      }
#line 259
      *(a + i * 2) += (tmp___12 + tmp___14) >> 1;
#line 259
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 264
  return;
}
}
#line 267 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static void dwt_decode_1(dwt_t *v ) 
{ 


  {
  {
#line 268
  dwt_decode_1_(v->mem, v->dn, v->sn, v->cas);
  }
#line 270
  return;
}
}
#line 274 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static void dwt_encode_1_real(int *a , int dn , int sn , int cas ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __cil_tmp10 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int __cil_tmp16 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int __cil_tmp22 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int __cil_tmp28 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int __cil_tmp38 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int __cil_tmp44 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int __cil_tmp50 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int __cil_tmp56 ;

  {
#line 276
  if (! cas) {
#line 277
    if (dn > 0) {
      _L: 
#line 278
      i = 0;
      {
#line 278
      while (1) {
        while_continue: /* CIL Label */ ;

#line 278
        if (! (i < dn)) {
#line 278
          goto while_break;
        }
#line 279
        if (i + 1 < 0) {
#line 279
          tmp___2 = *(a + 0);
        } else {
#line 279
          if (i + 1 >= sn) {
#line 279
            tmp___1 = *(a + (sn - 1) * 2);
          } else {
#line 279
            tmp___1 = *(a + (i + 1) * 2);
          }
#line 279
          tmp___2 = tmp___1;
        }
#line 279
        if (i < 0) {
#line 279
          tmp___0 = *(a + 0);
        } else {
#line 279
          if (i >= sn) {
#line 279
            tmp = *(a + (sn - 1) * 2);
          } else {
#line 279
            tmp = *(a + i * 2);
          }
#line 279
          tmp___0 = tmp;
        }
        {
#line 279
        __cil_tmp10 = fix_mul(tmp___0 + tmp___2, 12993);
#line 279
        *(a + (1 + i * 2)) -= __cil_tmp10;
#line 278
        i ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break: 
#line 280
      i = 0;
      {
#line 280
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 280
        if (! (i < sn)) {
#line 280
          goto while_break___0;
        }
#line 281
        if (i < 0) {
#line 281
          tmp___6 = *(a + 1);
        } else {
#line 281
          if (i >= dn) {
#line 281
            tmp___5 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 281
            tmp___5 = *(a + (1 + i * 2));
          }
#line 281
          tmp___6 = tmp___5;
        }
#line 281
        if (i - 1 < 0) {
#line 281
          tmp___4 = *(a + 1);
        } else {
#line 281
          if (i - 1 >= dn) {
#line 281
            tmp___3 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 281
            tmp___3 = *(a + (1 + (i - 1) * 2));
          }
#line 281
          tmp___4 = tmp___3;
        }
        {
#line 281
        __cil_tmp16 = fix_mul(tmp___4 + tmp___6, 434);
#line 281
        *(a + i * 2) -= __cil_tmp16;
#line 280
        i ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___0: 
#line 282
      i = 0;
      {
#line 282
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 282
        if (! (i < dn)) {
#line 282
          goto while_break___1;
        }
#line 283
        if (i + 1 < 0) {
#line 283
          tmp___10 = *(a + 0);
        } else {
#line 283
          if (i + 1 >= sn) {
#line 283
            tmp___9 = *(a + (sn - 1) * 2);
          } else {
#line 283
            tmp___9 = *(a + (i + 1) * 2);
          }
#line 283
          tmp___10 = tmp___9;
        }
#line 283
        if (i < 0) {
#line 283
          tmp___8 = *(a + 0);
        } else {
#line 283
          if (i >= sn) {
#line 283
            tmp___7 = *(a + (sn - 1) * 2);
          } else {
#line 283
            tmp___7 = *(a + i * 2);
          }
#line 283
          tmp___8 = tmp___7;
        }
        {
#line 283
        __cil_tmp22 = fix_mul(tmp___8 + tmp___10, 7233);
#line 283
        *(a + (1 + i * 2)) += __cil_tmp22;
#line 282
        i ++;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___1: 
#line 284
      i = 0;
      {
#line 284
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 284
        if (! (i < sn)) {
#line 284
          goto while_break___2;
        }
#line 285
        if (i < 0) {
#line 285
          tmp___14 = *(a + 1);
        } else {
#line 285
          if (i >= dn) {
#line 285
            tmp___13 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 285
            tmp___13 = *(a + (1 + i * 2));
          }
#line 285
          tmp___14 = tmp___13;
        }
#line 285
        if (i - 1 < 0) {
#line 285
          tmp___12 = *(a + 1);
        } else {
#line 285
          if (i - 1 >= dn) {
#line 285
            tmp___11 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 285
            tmp___11 = *(a + (1 + (i - 1) * 2));
          }
#line 285
          tmp___12 = tmp___11;
        }
        {
#line 285
        __cil_tmp28 = fix_mul(tmp___12 + tmp___14, 3633);
#line 285
        *(a + i * 2) += __cil_tmp28;
#line 284
        i ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___2: 
#line 286
      i = 0;
      {
#line 286
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 286
        if (! (i < dn)) {
#line 286
          goto while_break___3;
        }
        {
#line 287
        *(a + (1 + i * 2)) = fix_mul(*(a + (1 + i * 2)), 5038);
#line 286
        i ++;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___3: 
#line 288
      i = 0;
      {
#line 288
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 288
        if (! (i < sn)) {
#line 288
          goto while_break___4;
        }
        {
#line 289
        *(a + i * 2) = fix_mul(*(a + i * 2), 6659);
#line 288
        i ++;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___4: ;
    } else
#line 277
    if (sn > 1) {
#line 277
      goto _L;
    }
  } else
#line 292
  if (sn > 0) {
    _L___18: 
#line 293
    i = 0;
    {
#line 293
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 293
      if (! (i < dn)) {
#line 293
        goto while_break___5;
      }
#line 294
      if (i - 1 < 0) {
#line 294
        tmp___18 = *(a + 1);
      } else {
#line 294
        if (i - 1 >= sn) {
#line 294
          tmp___17 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 294
          tmp___17 = *(a + (1 + (i - 1) * 2));
        }
#line 294
        tmp___18 = tmp___17;
      }
#line 294
      if (i < 0) {
#line 294
        tmp___16 = *(a + 1);
      } else {
#line 294
        if (i >= sn) {
#line 294
          tmp___15 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 294
          tmp___15 = *(a + (1 + i * 2));
        }
#line 294
        tmp___16 = tmp___15;
      }
      {
#line 294
      __cil_tmp38 = fix_mul(tmp___16 + tmp___18, 12993);
#line 294
      *(a + i * 2) -= __cil_tmp38;
#line 293
      i ++;
      }
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___5: 
#line 295
    i = 0;
    {
#line 295
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 295
      if (! (i < sn)) {
#line 295
        goto while_break___6;
      }
#line 296
      if (i + 1 < 0) {
#line 296
        tmp___22 = *(a + 0);
      } else {
#line 296
        if (i + 1 >= dn) {
#line 296
          tmp___21 = *(a + (dn - 1) * 2);
        } else {
#line 296
          tmp___21 = *(a + (i + 1) * 2);
        }
#line 296
        tmp___22 = tmp___21;
      }
#line 296
      if (i < 0) {
#line 296
        tmp___20 = *(a + 0);
      } else {
#line 296
        if (i >= dn) {
#line 296
          tmp___19 = *(a + (dn - 1) * 2);
        } else {
#line 296
          tmp___19 = *(a + i * 2);
        }
#line 296
        tmp___20 = tmp___19;
      }
      {
#line 296
      __cil_tmp44 = fix_mul(tmp___20 + tmp___22, 434);
#line 296
      *(a + (1 + i * 2)) -= __cil_tmp44;
#line 295
      i ++;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___6: 
#line 297
    i = 0;
    {
#line 297
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 297
      if (! (i < dn)) {
#line 297
        goto while_break___7;
      }
#line 298
      if (i - 1 < 0) {
#line 298
        tmp___26 = *(a + 1);
      } else {
#line 298
        if (i - 1 >= sn) {
#line 298
          tmp___25 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 298
          tmp___25 = *(a + (1 + (i - 1) * 2));
        }
#line 298
        tmp___26 = tmp___25;
      }
#line 298
      if (i < 0) {
#line 298
        tmp___24 = *(a + 1);
      } else {
#line 298
        if (i >= sn) {
#line 298
          tmp___23 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 298
          tmp___23 = *(a + (1 + i * 2));
        }
#line 298
        tmp___24 = tmp___23;
      }
      {
#line 298
      __cil_tmp50 = fix_mul(tmp___24 + tmp___26, 7233);
#line 298
      *(a + i * 2) += __cil_tmp50;
#line 297
      i ++;
      }
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___7: 
#line 299
    i = 0;
    {
#line 299
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 299
      if (! (i < sn)) {
#line 299
        goto while_break___8;
      }
#line 300
      if (i + 1 < 0) {
#line 300
        tmp___30 = *(a + 0);
      } else {
#line 300
        if (i + 1 >= dn) {
#line 300
          tmp___29 = *(a + (dn - 1) * 2);
        } else {
#line 300
          tmp___29 = *(a + (i + 1) * 2);
        }
#line 300
        tmp___30 = tmp___29;
      }
#line 300
      if (i < 0) {
#line 300
        tmp___28 = *(a + 0);
      } else {
#line 300
        if (i >= dn) {
#line 300
          tmp___27 = *(a + (dn - 1) * 2);
        } else {
#line 300
          tmp___27 = *(a + i * 2);
        }
#line 300
        tmp___28 = tmp___27;
      }
      {
#line 300
      __cil_tmp56 = fix_mul(tmp___28 + tmp___30, 3633);
#line 300
      *(a + (1 + i * 2)) += __cil_tmp56;
#line 299
      i ++;
      }
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___8: 
#line 301
    i = 0;
    {
#line 301
    while (1) {
      while_continue___9: /* CIL Label */ ;

#line 301
      if (! (i < dn)) {
#line 301
        goto while_break___9;
      }
      {
#line 302
      *(a + i * 2) = fix_mul(*(a + i * 2), 5038);
#line 301
      i ++;
      }
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___9: 
#line 303
    i = 0;
    {
#line 303
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 303
      if (! (i < sn)) {
#line 303
        goto while_break___10;
      }
      {
#line 304
      *(a + (1 + i * 2)) = fix_mul(*(a + (1 + i * 2)), 6659);
#line 303
      i ++;
      }
    }
    while_break___22: /* CIL Label */ ;
    }
    while_break___10: ;
  } else
#line 292
  if (dn > 1) {
#line 292
    goto _L___18;
  }
#line 294
  return;
}
}
#line 309 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static void dwt_encode_stepsize(int stepsize , int numbps , opj_stepsize_t *bandno_stepsize ) 
{ 
  int p ;
  int n ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp ;

  {
  {
#line 311
  __cil_tmp6 = int_floorlog2(stepsize);
#line 311
  p = __cil_tmp6 - 13;
#line 312
  __cil_tmp7 = int_floorlog2(stepsize);
#line 312
  n = 11 - __cil_tmp7;
  }
#line 313
  if (n < 0) {
#line 313
    tmp = stepsize >> - n;
  } else {
#line 313
    tmp = stepsize << n;
  }
#line 313
  bandno_stepsize->mant = tmp & 2047;
#line 314
  bandno_stepsize->expn = numbps - p;
#line 315
  return;
}
}
#line 326 "/root/patchweave_new/2/libopenjpeg/dwt.c"
void dwt_encode(opj_tcd_tilecomp_t *tilec ) 
{ 
  int i ;
  int j ;
  int k ;
  int *a ;
  int *aj ;
  int *bj ;
  int w ;
  int l ;
  int rw ;
  int rh ;
  int rw1 ;
  int rh1 ;
  int cas_col ;
  int cas_row ;
  int dn ;
  int sn ;
  void *__cil_tmp18 ;
  void *__cil_tmp21 ;

  {
#line 328
  a = (int *)((void *)0);
#line 329
  aj = (int *)((void *)0);
#line 330
  bj = (int *)((void *)0);
#line 333
  w = tilec->x1 - tilec->x0;
#line 334
  l = tilec->numresolutions - 1;
#line 335
  a = tilec->data;
#line 337
  i = 0;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;

#line 337
    if (! (i < l)) {
#line 337
      goto while_break;
    }
    {
#line 346
    rw = (tilec->resolutions + (l - i))->x1 - (tilec->resolutions + (l - i))->x0;
#line 347
    rh = (tilec->resolutions + (l - i))->y1 - (tilec->resolutions + (l - i))->y0;
#line 348
    rw1 = (tilec->resolutions + ((l - i) - 1))->x1 - (tilec->resolutions + ((l - i) - 1))->x0;
#line 349
    rh1 = (tilec->resolutions + ((l - i) - 1))->y1 - (tilec->resolutions + ((l - i) - 1))->y0;
#line 351
    cas_row = (tilec->resolutions + (l - i))->x0 % 2;
#line 352
    cas_col = (tilec->resolutions + (l - i))->y0 % 2;
#line 354
    sn = rh1;
#line 355
    dn = rh - rh1;
#line 356
    __cil_tmp18 = malloc((unsigned long )rh * sizeof(int ));
#line 356
    bj = (int *)__cil_tmp18;
#line 357
    j = 0;
    }
    {
#line 357
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 357
      if (! (j < rw)) {
#line 357
        goto while_break___0;
      }
#line 358
      aj = a + j;
#line 359
      k = 0;
      {
#line 359
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 359
        if (! (k < rh)) {
#line 359
          goto while_break___1;
        }
#line 359
        *(bj + k) = *(aj + k * w);
#line 359
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 360
      dwt_encode_1(bj, dn, sn, cas_col);
#line 361
      dwt_deinterleave_v(bj, aj, dn, sn, w, cas_col);
#line 357
      j ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 363
    free((void *)bj);
#line 365
    sn = rw1;
#line 366
    dn = rw - rw1;
#line 367
    __cil_tmp21 = malloc((unsigned long )rw * sizeof(int ));
#line 367
    bj = (int *)__cil_tmp21;
#line 368
    j = 0;
    }
    {
#line 368
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 368
      if (! (j < rh)) {
#line 368
        goto while_break___2;
      }
#line 369
      aj = a + j * w;
#line 370
      k = 0;
      {
#line 370
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 370
        if (! (k < rw)) {
#line 370
          goto while_break___3;
        }
#line 370
        *(bj + k) = *(aj + k);
#line 370
        k ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
      {
#line 371
      dwt_encode_1(bj, dn, sn, cas_row);
#line 372
      dwt_deinterleave_h(bj, aj, dn, sn, cas_row);
#line 368
      j ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 374
    free((void *)bj);
#line 337
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 341
  return;
}
}
#line 382 "/root/patchweave_new/2/libopenjpeg/dwt.c"
void dwt_decode(opj_tcd_tilecomp_t *tilec , int numres ) 
{ 


  {
  {
#line 383
  dwt_decode_tile(tilec, numres, & dwt_decode_1);
  }
#line 385
  return;
}
}
#line 390 "/root/patchweave_new/2/libopenjpeg/dwt.c"
int dwt_getgain(int orient ) 
{ 


  {
#line 391
  if (orient == 0) {
#line 392
    return (0);
  }
#line 393
  if (orient == 1) {
#line 394
    return (1);
  } else
#line 393
  if (orient == 2) {
#line 394
    return (1);
  }
#line 395
  return (2);
}
}
#line 401 "/root/patchweave_new/2/libopenjpeg/dwt.c"
double dwt_getnorm(int level , int orient ) 
{ 


  {
#line 402
  return ((double )dwt_norms[orient][level]);
}
}
#line 409 "/root/patchweave_new/2/libopenjpeg/dwt.c"
void dwt_encode_real(opj_tcd_tilecomp_t *tilec ) 
{ 
  int i ;
  int j ;
  int k ;
  int *a ;
  int *aj ;
  int *bj ;
  int w ;
  int l ;
  int rw ;
  int rh ;
  int rw1 ;
  int rh1 ;
  int cas_col ;
  int cas_row ;
  int dn ;
  int sn ;
  void *__cil_tmp18 ;
  void *__cil_tmp21 ;

  {
#line 411
  a = (int *)((void *)0);
#line 412
  aj = (int *)((void *)0);
#line 413
  bj = (int *)((void *)0);
#line 416
  w = tilec->x1 - tilec->x0;
#line 417
  l = tilec->numresolutions - 1;
#line 418
  a = tilec->data;
#line 420
  i = 0;
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;

#line 420
    if (! (i < l)) {
#line 420
      goto while_break;
    }
    {
#line 429
    rw = (tilec->resolutions + (l - i))->x1 - (tilec->resolutions + (l - i))->x0;
#line 430
    rh = (tilec->resolutions + (l - i))->y1 - (tilec->resolutions + (l - i))->y0;
#line 431
    rw1 = (tilec->resolutions + ((l - i) - 1))->x1 - (tilec->resolutions + ((l - i) - 1))->x0;
#line 432
    rh1 = (tilec->resolutions + ((l - i) - 1))->y1 - (tilec->resolutions + ((l - i) - 1))->y0;
#line 434
    cas_row = (tilec->resolutions + (l - i))->x0 % 2;
#line 435
    cas_col = (tilec->resolutions + (l - i))->y0 % 2;
#line 437
    sn = rh1;
#line 438
    dn = rh - rh1;
#line 439
    __cil_tmp18 = malloc((unsigned long )rh * sizeof(int ));
#line 439
    bj = (int *)__cil_tmp18;
#line 440
    j = 0;
    }
    {
#line 440
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 440
      if (! (j < rw)) {
#line 440
        goto while_break___0;
      }
#line 441
      aj = a + j;
#line 442
      k = 0;
      {
#line 442
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 442
        if (! (k < rh)) {
#line 442
          goto while_break___1;
        }
#line 442
        *(bj + k) = *(aj + k * w);
#line 442
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 443
      dwt_encode_1_real(bj, dn, sn, cas_col);
#line 444
      dwt_deinterleave_v(bj, aj, dn, sn, w, cas_col);
#line 440
      j ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 446
    free((void *)bj);
#line 448
    sn = rw1;
#line 449
    dn = rw - rw1;
#line 450
    __cil_tmp21 = malloc((unsigned long )rw * sizeof(int ));
#line 450
    bj = (int *)__cil_tmp21;
#line 451
    j = 0;
    }
    {
#line 451
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 451
      if (! (j < rh)) {
#line 451
        goto while_break___2;
      }
#line 452
      aj = a + j * w;
#line 453
      k = 0;
      {
#line 453
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 453
        if (! (k < rw)) {
#line 453
          goto while_break___3;
        }
#line 453
        *(bj + k) = *(aj + k);
#line 453
        k ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
      {
#line 454
      dwt_encode_1_real(bj, dn, sn, cas_row);
#line 455
      dwt_deinterleave_h(bj, aj, dn, sn, cas_row);
#line 451
      j ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 457
    free((void *)bj);
#line 420
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 424
  return;
}
}
#line 465 "/root/patchweave_new/2/libopenjpeg/dwt.c"
int dwt_getgain_real(int orient ) 
{ 


  {
#line 467
  return (0);
}
}
#line 473 "/root/patchweave_new/2/libopenjpeg/dwt.c"
double dwt_getnorm_real(int level , int orient ) 
{ 


  {
#line 474
  return ((double )dwt_norms_real[orient][level]);
}
}
#line 477 "/root/patchweave_new/2/libopenjpeg/dwt.c"
void dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , int prec ) 
{ 
  int numbands ;
  int bandno ;
  double stepsize ;
  int resno ;
  int level ;
  int orient ;
  int gain ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  double norm ;
  double __cil_tmp16 ;

  {
#line 479
  numbands = 3 * tccp->numresolutions - 2;
#line 480
  bandno = 0;
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;

#line 480
    if (! (bandno < numbands)) {
#line 480
      goto while_break;
    }
#line 484
    if (bandno == 0) {
#line 484
      tmp = 0;
    } else {
#line 484
      tmp = (bandno - 1) / 3 + 1;
    }
#line 484
    resno = tmp;
#line 485
    if (bandno == 0) {
#line 485
      tmp___0 = 0;
    } else {
#line 485
      tmp___0 = (bandno - 1) % 3 + 1;
    }
#line 485
    orient = tmp___0;
#line 486
    level = (tccp->numresolutions - 1) - resno;
#line 487
    if (tccp->qmfbid == 0) {
#line 487
      tmp___3 = 0;
    } else {
#line 487
      if (orient == 0) {
#line 487
        tmp___2 = 0;
      } else {
#line 487
        if (orient == 1) {
#line 487
          tmp___1 = 1;
        } else
#line 487
        if (orient == 2) {
#line 487
          tmp___1 = 1;
        } else {
#line 487
          tmp___1 = 2;
        }
#line 487
        tmp___2 = tmp___1;
      }
#line 487
      tmp___3 = tmp___2;
    }
#line 487
    gain = tmp___3;
#line 488
    if (tccp->qntsty == 0) {
#line 489
      stepsize = 1.;
    } else {
#line 491
      norm = (double )dwt_norms_real[orient][level];
#line 492
      stepsize = (double )(1 << gain) / norm;
    }
    {
#line 494
    __cil_tmp16 = floor(stepsize * 8192.);
#line 494
    dwt_encode_stepsize((int )__cil_tmp16, prec + gain, & tccp->stepsizes[bandno]);
#line 480
    bandno ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 484
  return;
}
}
#line 502 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static int dwt_decode_max_resolution(opj_tcd_resolution_t *r , int i ) 
{ 
  int mr ;
  int w ;

  {
#line 503
  mr = 1;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    i --;
#line 505
    if (! i) {
#line 505
      goto while_break;
    }
#line 506
    r ++;
#line 507
    w = r->x1 - r->x0;
#line 507
    if (mr < w) {
#line 508
      mr = w;
    }
#line 509
    w = r->y1 - r->y0;
#line 509
    if (mr < w) {
#line 510
      mr = w;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 512
  return (mr);
}
}
#line 519 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static void dwt_decode_tile(opj_tcd_tilecomp_t *tilec , int numres , void (*dwt_1D)(dwt_t * ) ) 
{ 
  dwt_t h ;
  dwt_t v ;
  opj_tcd_resolution_t *tr ;
  int rw ;
  int rh ;
  int w ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;
  int *tiledp ;
  int j ;
  int k ;

  {
  {
#line 523
  tr = tilec->resolutions;
#line 525
  rw = tr->x1 - tr->x0;
#line 526
  rh = tr->y1 - tr->y0;
#line 528
  w = tilec->x1 - tilec->x0;
#line 530
  __cil_tmp10 = dwt_decode_max_resolution(tr, numres);
#line 530
  __cil_tmp11 = malloc((unsigned long )__cil_tmp10 * sizeof(int ));
#line 530
  h.mem = (int *)__cil_tmp11;
#line 531
  v.mem = h.mem;
  }
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    numres --;
#line 533
    if (! numres) {
#line 533
      goto while_break;
    }
#line 534
    tiledp = tilec->data;
#line 537
    tr ++;
#line 538
    h.sn = rw;
#line 539
    v.sn = rh;
#line 541
    rw = tr->x1 - tr->x0;
#line 542
    rh = tr->y1 - tr->y0;
#line 544
    h.dn = rw - h.sn;
#line 545
    h.cas = tr->x0 % 2;
#line 547
    j = 0;
    {
#line 547
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 547
      if (! (j < rh)) {
#line 547
        goto while_break___0;
      }
      {
#line 548
      dwt_interleave_h(& h, tiledp + j * w);
#line 549
      (*dwt_1D)(& h);
#line 550
      memcpy((void *)(tiledp + j * w), (void const   *)h.mem, (unsigned long )rw * sizeof(int ));
#line 547
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 553
    v.dn = rh - v.sn;
#line 554
    v.cas = tr->y0 % 2;
#line 556
    j = 0;
    {
#line 556
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 556
      if (! (j < rw)) {
#line 556
        goto while_break___1;
      }
      {
#line 558
      dwt_interleave_v(& v, tiledp + j, w);
#line 559
      (*dwt_1D)(& v);
#line 560
      k = 0;
      }
      {
#line 560
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 560
        if (! (k < rh)) {
#line 560
          goto while_break___2;
        }
#line 561
        *(tiledp + (k * w + j)) = *(v.mem + k);
#line 560
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 556
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 565
  free((void *)h.mem);
  }
#line 567
  return;
}
}
#line 568 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static void v4dwt_interleave_h(v4dwt_t *w , float *a , int x , int size ) 
{ 
  float *bi ;
  int count ;
  int i ;
  int k ;
  int j ;
  int j___0 ;

  {
#line 569
  bi = (float *)(w->wavelet + w->cas);
#line 570
  count = w->sn;
#line 572
  k = 0;
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;

#line 572
    if (! (k < 2)) {
#line 572
      goto while_break;
    }
#line 573
    if (count + 3 * x < size) {
#line 573
      if (((size_t )a & 15UL) == 0UL) {
#line 573
        if (((size_t )bi & 15UL) == 0UL) {
#line 573
          if ((x & 15) == 0) {
#line 575
            i = 0;
            {
#line 575
            while (1) {
              while_continue___2: /* CIL Label */ ;

#line 575
              if (! (i < count)) {
#line 575
                goto while_break___0;
              }
#line 576
              j = i;
#line 577
              *(bi + i * 8) = *(a + j);
#line 578
              j += x;
#line 579
              *(bi + (i * 8 + 1)) = *(a + j);
#line 580
              j += x;
#line 581
              *(bi + (i * 8 + 2)) = *(a + j);
#line 582
              j += x;
#line 583
              *(bi + (i * 8 + 3)) = *(a + j);
#line 575
              i ++;
            }
            while_break___3: /* CIL Label */ ;
            }
            while_break___0: ;
          } else {
#line 573
            goto _L;
          }
        } else {
#line 573
          goto _L;
        }
      } else {
#line 573
        goto _L;
      }
    } else {
      _L: 
#line 587
      i = 0;
      {
#line 587
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___1: ;
#line 587
        if (! (i < count)) {
#line 587
          goto while_break___1;
        }
#line 588
        j___0 = i;
#line 589
        *(bi + i * 8) = *(a + j___0);
#line 590
        j___0 += x;
#line 591
        if (j___0 > size) {
#line 591
          goto while_continue___1;
        }
#line 592
        *(bi + (i * 8 + 1)) = *(a + j___0);
#line 593
        j___0 += x;
#line 594
        if (j___0 > size) {
#line 594
          goto while_continue___1;
        }
#line 595
        *(bi + (i * 8 + 2)) = *(a + j___0);
#line 596
        j___0 += x;
#line 597
        if (j___0 > size) {
#line 597
          goto while_continue___1;
        }
#line 598
        *(bi + (i * 8 + 3)) = *(a + j___0);
#line 587
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
    }
#line 601
    bi = (float *)((w->wavelet + 1) - w->cas);
#line 602
    a += w->sn;
#line 603
    size -= w->sn;
#line 604
    count = w->dn;
#line 572
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 576
  return;
}
}
#line 608 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static void v4dwt_interleave_v(v4dwt_t *v , float *a , int x ) 
{ 
  v4 *bi ;
  int i ;

  {
#line 609
  bi = v->wavelet + v->cas;
#line 611
  i = 0;
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;

#line 611
    if (! (i < v->sn)) {
#line 611
      goto while_break;
    }
    {
#line 612
    memcpy((void *)(bi + i * 2), (void const   *)(a + i * x), 4UL * sizeof(float ));
#line 611
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 614
  a += v->sn * x;
#line 615
  bi = (v->wavelet + 1) - v->cas;
#line 616
  i = 0;
  {
#line 616
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 616
    if (! (i < v->dn)) {
#line 616
      goto while_break___0;
    }
    {
#line 617
    memcpy((void *)(bi + i * 2), (void const   *)(a + i * x), 4UL * sizeof(float ));
#line 616
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 620
  return;
}
}
#line 623 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static void v4dwt_decode_step1_sse(v4 *w , int count , __m128 c ) 
{ 
  __m128 *vw ;
  int i ;

  {
#line 624
  vw = (__m128 *)w;
#line 627
  i = 0;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;

#line 627
    if (! (i < count >> 2)) {
#line 627
      goto while_break;
    }
    {
#line 628
    *vw = _mm_mul_ps(*vw, c);
#line 629
    vw += 2;
#line 630
    *vw = _mm_mul_ps(*vw, c);
#line 631
    vw += 2;
#line 632
    *vw = _mm_mul_ps(*vw, c);
#line 633
    vw += 2;
#line 634
    *vw = _mm_mul_ps(*vw, c);
#line 635
    vw += 2;
#line 627
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 637
  count &= 3;
#line 638
  i = 0;
  {
#line 638
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 638
    if (! (i < count)) {
#line 638
      goto while_break___0;
    }
    {
#line 639
    *vw = _mm_mul_ps(*vw, c);
#line 640
    vw += 2;
#line 638
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 642
  return;
}
}
#line 644 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static void v4dwt_decode_step2_sse(v4 *l , v4 *w , int k , int m , __m128 c ) 
{ 
  __m128 *vl ;
  __m128 *vw ;
  int i ;
  __m128 tmp1 ;
  __m128 tmp2 ;
  __m128 tmp3 ;
  __m128 __cil_tmp12 ;
  __m128 __cil_tmp13 ;
  __m128 __cil_tmp14 ;
  __m128 tmp ;

  {
#line 645
  vl = (__m128 *)l;
#line 646
  vw = (__m128 *)w;
#line 649
  tmp1 = *(vl + 0);
#line 650
  i = 0;
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;

#line 650
    if (! (i < m)) {
#line 650
      goto while_break;
    }
    {
#line 651
    tmp2 = *(vw + -1);
#line 652
    tmp3 = *(vw + 0);
#line 653
    __cil_tmp12 = _mm_add_ps(tmp1, tmp3);
#line 653
    __cil_tmp13 = _mm_mul_ps(__cil_tmp12, c);
#line 653
    __cil_tmp14 = _mm_add_ps(tmp2, __cil_tmp13);
#line 653
    *(vw + -1) = __cil_tmp14;
#line 654
    tmp1 = tmp3;
#line 655
    vw += 2;
#line 650
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 657
  vl = vw - 2;
#line 658
  if (m >= k) {
#line 659
    return;
  }
  {
#line 661
  c = _mm_add_ps(c, c);
#line 662
  c = _mm_mul_ps(c, *(vl + 0));
  }
  {
#line 663
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 663
    if (! (m < k)) {
#line 663
      goto while_break___0;
    }
    {
#line 664
    tmp = *(vw + -1);
#line 665
    *(vw + -1) = _mm_add_ps(tmp, c);
#line 666
    vw += 2;
#line 663
    m ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 667
  return;
}
}
#line 740 "/root/patchweave_new/2/libopenjpeg/dwt.c"
static void v4dwt_decode(v4dwt_t *dwt ) 
{ 
  int a ;
  int b ;
  __m128 __cil_tmp4 ;
  __m128 __cil_tmp5 ;
  int __cil_tmp6 ;
  __m128 __cil_tmp7 ;
  int __cil_tmp8 ;
  __m128 __cil_tmp9 ;
  int __cil_tmp10 ;
  __m128 __cil_tmp11 ;
  int __cil_tmp12 ;
  __m128 __cil_tmp13 ;

  {
#line 742
  if (dwt->cas == 0) {
#line 743
    if (! (dwt->dn > 0)) {
#line 743
      if (! (dwt->sn > 1)) {
#line 744
        return;
      }
    }
#line 746
    a = 0;
#line 747
    b = 1;
  } else {
#line 749
    if (! (dwt->sn > 0)) {
#line 749
      if (! (dwt->dn > 1)) {
#line 750
        return;
      }
    }
#line 752
    a = 1;
#line 753
    b = 0;
  }
  {
#line 756
  __cil_tmp4 = _mm_set_ss((float )K);
#line 756
  v4dwt_decode_step1_sse(dwt->wavelet + a, dwt->sn, __cil_tmp4);
#line 757
  __cil_tmp5 = _mm_set_ss((float )c13318);
#line 757
  v4dwt_decode_step1_sse(dwt->wavelet + b, dwt->dn, __cil_tmp5);
#line 758
  __cil_tmp6 = int_min(dwt->sn, dwt->dn - a);
#line 758
  __cil_tmp7 = _mm_set_ss((float )dwt_delta);
#line 758
  v4dwt_decode_step2_sse(dwt->wavelet + b, (dwt->wavelet + a) + 1, dwt->sn, __cil_tmp6,
                         __cil_tmp7);
#line 759
  __cil_tmp8 = int_min(dwt->dn, dwt->sn - b);
#line 759
  __cil_tmp9 = _mm_set_ss((float )dwt_gamma);
#line 759
  v4dwt_decode_step2_sse(dwt->wavelet + a, (dwt->wavelet + b) + 1, dwt->dn, __cil_tmp8,
                         __cil_tmp9);
#line 760
  __cil_tmp10 = int_min(dwt->sn, dwt->dn - a);
#line 760
  __cil_tmp11 = _mm_set_ss((float )dwt_beta);
#line 760
  v4dwt_decode_step2_sse(dwt->wavelet + b, (dwt->wavelet + a) + 1, dwt->sn, __cil_tmp10,
                         __cil_tmp11);
#line 761
  __cil_tmp12 = int_min(dwt->dn, dwt->sn - b);
#line 761
  __cil_tmp13 = _mm_set_ss((float )dwt_alpha);
#line 761
  v4dwt_decode_step2_sse(dwt->wavelet + a, (dwt->wavelet + b) + 1, dwt->dn, __cil_tmp12,
                         __cil_tmp13);
  }
#line 764
  return;
}
}
#line 775 "/root/patchweave_new/2/libopenjpeg/dwt.c"
void dwt_decode_real(opj_tcd_tilecomp_t *tilec , int numres ) 
{ 
  v4dwt_t h ;
  v4dwt_t v ;
  opj_tcd_resolution_t *res ;
  int rw ;
  int rh ;
  int w ;
  int __cil_tmp9 ;
  void *__cil_tmp10 ;
  float *aj ;
  int bufsize ;
  int j ;
  int k ;
  int k___0 ;
  int k___1 ;
  int k___2 ;

  {
  {
#line 779
  res = tilec->resolutions;
#line 781
  rw = res->x1 - res->x0;
#line 782
  rh = res->y1 - res->y0;
#line 784
  w = tilec->x1 - tilec->x0;
#line 786
  __cil_tmp9 = dwt_decode_max_resolution(res, numres);
#line 786
  __cil_tmp10 = malloc((unsigned long )(__cil_tmp9 + 5) * sizeof(v4 ));
#line 786
  h.wavelet = (v4 *)__cil_tmp10;
#line 787
  v.wavelet = h.wavelet;
  }
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 789
    numres --;
#line 789
    if (! numres) {
#line 789
      goto while_break;
    }
#line 790
    aj = (float *)tilec->data;
#line 791
    bufsize = (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0);
#line 794
    h.sn = rw;
#line 795
    v.sn = rh;
#line 797
    res ++;
#line 799
    rw = res->x1 - res->x0;
#line 800
    rh = res->y1 - res->y0;
#line 802
    h.dn = rw - h.sn;
#line 803
    h.cas = res->x0 % 2;
#line 805
    j = rh;
    {
#line 805
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 805
      if (! (j > 3)) {
#line 805
        goto while_break___0;
      }
      {
#line 807
      v4dwt_interleave_h(& h, aj, w, bufsize);
#line 808
      v4dwt_decode(& h);
#line 809
      k = rw;
      }
      {
#line 809
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 809
        if (! (k >= 0)) {
#line 809
          goto while_break___1;
        }
#line 810
        *(aj + k) = (h.wavelet + k)->f[0];
#line 811
        *(aj + (k + w)) = (h.wavelet + k)->f[1];
#line 812
        *(aj + (k + w * 2)) = (h.wavelet + k)->f[2];
#line 813
        *(aj + (k + w * 3)) = (h.wavelet + k)->f[3];
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___1: 
#line 815
      aj += w * 4;
#line 816
      bufsize -= w * 4;
#line 805
      j -= 4;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___0: ;
#line 818
    if (rh & 3) {
      {
#line 820
      j = rh & 3;
#line 821
      v4dwt_interleave_h(& h, aj, w, bufsize);
#line 822
      v4dwt_decode(& h);
#line 823
      k___0 = rw;
      }
      {
#line 823
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 823
        if (! (k___0 >= 0)) {
#line 823
          goto while_break___2;
        }
#line 825
        if (j == 3) {
#line 825
          goto case_3;
        }
#line 826
        if (j == 2) {
#line 826
          goto case_2;
        }
#line 827
        if (j == 1) {
#line 827
          goto case_1;
        }
#line 824
        goto switch_break;
        case_3: 
#line 825
        *(aj + (k___0 + w * 2)) = (h.wavelet + k___0)->f[2];
        case_2: 
#line 826
        *(aj + (k___0 + w)) = (h.wavelet + k___0)->f[1];
        case_1: 
#line 827
        *(aj + k___0) = (h.wavelet + k___0)->f[0];
        switch_break: ;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___2: ;
    }
#line 832
    v.dn = rh - v.sn;
#line 833
    v.cas = res->y0 % 2;
#line 835
    aj = (float *)tilec->data;
#line 836
    j = rw;
    {
#line 836
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 836
      if (! (j > 3)) {
#line 836
        goto while_break___3;
      }
      {
#line 838
      v4dwt_interleave_v(& v, aj, w);
#line 839
      v4dwt_decode(& v);
#line 840
      k___1 = 0;
      }
      {
#line 840
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 840
        if (! (k___1 < rh)) {
#line 840
          goto while_break___4;
        }
        {
#line 841
        memcpy((void *)(aj + k___1 * w), (void const   *)(v.wavelet + k___1), 4UL * sizeof(float ));
#line 840
        k___1 ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: 
#line 843
      aj += 4;
#line 836
      j -= 4;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___3: ;
#line 845
    if (rw & 3) {
      {
#line 847
      j = rw & 3;
#line 848
      v4dwt_interleave_v(& v, aj, w);
#line 849
      v4dwt_decode(& v);
#line 850
      k___2 = 0;
      }
      {
#line 850
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 850
        if (! (k___2 < rh)) {
#line 850
          goto while_break___5;
        }
        {
#line 851
        memcpy((void *)(aj + k___2 * w), (void const   *)(v.wavelet + k___2), (unsigned long )j * sizeof(float ));
#line 850
        k___2 ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___5: ;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: 
  {
#line 856
  free((void *)h.wavelet);
  }
#line 858
  return;
}
}
#line 36 "/root/patchweave_new/2/libopenjpeg/cio.c"
opj_cio_t *opj_cio_open(opj_common_ptr cinfo , unsigned char *buffer , int length ) 
{ 
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 37
  cp = (opj_cp_t *)((void *)0);
#line 38
  __cil_tmp6 = malloc(sizeof(opj_cio_t ));
#line 38
  cio = (opj_cio_t *)__cil_tmp6;
  }
#line 39
  if (! cio) {
#line 39
    return ((opj_cio_t *)((void *)0));
  }
#line 40
  cio->cinfo = cinfo;
#line 41
  if (buffer) {
#line 41
    if (length) {
#line 43
      cio->openmode = 1;
#line 44
      cio->buffer = buffer;
#line 45
      cio->length = length;
    } else {
#line 41
      goto _L;
    }
  } else
  _L: 
#line 47
  if (! buffer) {
#line 47
    if (! length) {
#line 47
      if (cinfo) {
#line 49
        cio->openmode = 2;
#line 51
        if ((int )cinfo->codec_format == 0) {
#line 51
          goto case_0;
        }
#line 54
        if ((int )cinfo->codec_format == 2) {
#line 54
          goto case_2;
        }
#line 57
        goto switch_default;
        case_0: 
#line 52
        cp = ((opj_j2k_t *)cinfo->j2k_handle)->cp;
#line 53
        goto switch_break;
        case_2: 
#line 55
        cp = (((opj_jp2_t *)cinfo->jp2_handle)->j2k)->cp;
#line 56
        goto switch_break;
        switch_default: 
        {
#line 58
        free((void *)cio);
        }
#line 59
        return ((opj_cio_t *)((void *)0));
        switch_break: 
        {
#line 61
        cio->length = (int )((unsigned int )(0.162500000001 * (double )cp->img_size + (double )2000));
#line 62
        __cil_tmp7 = malloc((unsigned long )cio->length);
#line 62
        cio->buffer = (unsigned char *)__cil_tmp7;
        }
#line 63
        if (! cio->buffer) {
          {
#line 64
          opj_event_msg(cio->cinfo, 1, "Error allocating memory for compressed bitstream\n");
#line 65
          free((void *)cio);
          }
#line 66
          return ((opj_cio_t *)((void *)0));
        }
      } else {
        {
#line 70
        free((void *)cio);
        }
#line 71
        return ((opj_cio_t *)((void *)0));
      }
    } else {
      {
#line 70
      free((void *)cio);
      }
#line 71
      return ((opj_cio_t *)((void *)0));
    }
  } else {
    {
#line 70
    free((void *)cio);
    }
#line 71
    return ((opj_cio_t *)((void *)0));
  }
#line 75
  cio->start = cio->buffer;
#line 76
  cio->end = cio->buffer + cio->length;
#line 77
  cio->bp = cio->buffer;
#line 79
  return (cio);
}
}
#line 82 "/root/patchweave_new/2/libopenjpeg/cio.c"
void opj_cio_close(opj_cio_t *cio ) 
{ 


  {
#line 83
  if (cio) {
#line 84
    if (cio->openmode == 2) {
      {
#line 86
      free((void *)cio->buffer);
      }
    }
    {
#line 89
    free((void *)cio);
    }
  }
#line 92
  return;
}
}
#line 99 "/root/patchweave_new/2/libopenjpeg/cio.c"
int cio_tell(opj_cio_t *cio ) 
{ 


  {
#line 100
  return ((int )(cio->bp - cio->start));
}
}
#line 108 "/root/patchweave_new/2/libopenjpeg/cio.c"
void cio_seek(opj_cio_t *cio , int pos ) 
{ 


  {
#line 109
  cio->bp = cio->start + pos;
#line 110
  return;
}
}
#line 115 "/root/patchweave_new/2/libopenjpeg/cio.c"
int cio_numbytesleft(opj_cio_t *cio ) 
{ 


  {
#line 116
  return ((int )(cio->end - cio->bp));
}
}
#line 122 "/root/patchweave_new/2/libopenjpeg/cio.c"
unsigned char *cio_getbp(opj_cio_t *cio ) 
{ 


  {
#line 123
  return (cio->bp);
}
}
#line 129 "/root/patchweave_new/2/libopenjpeg/cio.c"
opj_bool cio_byteout(opj_cio_t *cio , unsigned char v ) 
{ 
  unsigned char *__cil_tmp3 ;

  {
#line 130
  if ((unsigned long )cio->bp >= (unsigned long )cio->end) {
    {
#line 131
    opj_event_msg(cio->cinfo, 1, "write error\n\312U");
    }
#line 132
    return (0);
  }
#line 134
  __cil_tmp3 = cio->bp;
#line 134
  (cio->bp) ++;
#line 134
  *__cil_tmp3 = v;
#line 135
  return (1);
}
}
#line 141 "/root/patchweave_new/2/libopenjpeg/cio.c"
unsigned char cio_bytein(opj_cio_t *cio ) 
{ 
  unsigned char *__cil_tmp2 ;

  {
#line 142
  if ((unsigned long )cio->bp >= (unsigned long )cio->end) {
    {
#line 143
    opj_event_msg(cio->cinfo, 1, "read error: passed the end of the codestream (start = %d, current = %d, end = %d\n",
                  cio->start, cio->bp, cio->end);
    }
#line 144
    return ((unsigned char)0);
  }
#line 146
  __cil_tmp2 = cio->bp;
#line 146
  (cio->bp) ++;
#line 146
  return (*__cil_tmp2);
}
}
#line 155 "/root/patchweave_new/2/libopenjpeg/cio.c"
unsigned int cio_write(opj_cio_t *cio , unsigned long long v , int n ) 
{ 
  int i ;
  opj_bool __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 157
  i = n - 1;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;

#line 157
    if (! (i >= 0)) {
#line 157
      goto while_break;
    }
    {
#line 158
    __cil_tmp5 = cio_byteout(cio, (unsigned char )((v >> (i << 3)) & 255ULL));
    }
#line 158
    if (! __cil_tmp5) {
#line 159
      return (0U);
    }
#line 157
    __cil_tmp6 = i;
#line 157
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 161
  return ((unsigned int )n);
}
}
#line 171 "/root/patchweave_new/2/libopenjpeg/cio.c"
unsigned int cio_read(opj_cio_t *cio , int n ) 
{ 
  int i ;
  unsigned int v ;
  unsigned char __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 174
  v = 0U;
#line 175
  i = n - 1;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;

#line 175
    if (! (i >= 0)) {
#line 175
      goto while_break;
    }
    {
#line 176
    __cil_tmp5 = cio_bytein(cio);
#line 176
    v += (unsigned int )((int )__cil_tmp5 << (i << 3));
#line 175
    __cil_tmp6 = i;
#line 175
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 178
  return (v);
}
}
#line 186 "/root/patchweave_new/2/libopenjpeg/cio.c"
void cio_skip(opj_cio_t *cio , int n ) 
{ 


  {
#line 187
  cio->bp += n;
#line 188
  return;
}
}
#line 42 "/root/patchweave_new/2/libopenjpeg/cidx_manager.c"
void write_cptr(int coff , int clen , opj_cio_t *cio ) ;
#line 53
int write_mainmhix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) ;
#line 65
opj_bool check_EPHuse(int coff , opj_marker_info_t *markers , int marknum , opj_cio_t *cio ) ;
#line 68 "/root/patchweave_new/2/libopenjpeg/cidx_manager.c"
int write_cidx(int offset , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t cstr_info ,
               int j2klen ) 
{ 
  int len ;
  int i ;
  int lenp ;
  opj_jp2_box_t *box ;
  int num_box ;
  opj_bool EPHused ;
  void *__cil_tmp12 ;
  int __cil_tmp25 ;

  {
  {
#line 72
  num_box = 0;
#line 76
  lenp = -1;
#line 77
  __cil_tmp12 = calloc(32UL, sizeof(opj_jp2_box_t ));
#line 77
  box = (opj_jp2_box_t *)__cil_tmp12;
#line 79
  i = 0;
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;

#line 79
    if (! (i < 2)) {
#line 79
      goto while_break;
    }
#line 81
    if (i) {
      {
#line 82
      cio_seek(cio, lenp);
      }
    }
    {
#line 84
    lenp = cio_tell(cio);
#line 86
    cio_skip(cio, 4);
#line 87
    cio_write(cio, 1667851384ULL, 4);
#line 88
    write_cptr(offset, cstr_info.codestream_size, cio);
#line 90
    write_manf(i, num_box, box, cio);
#line 92
    num_box = 0;
#line 93
    (box + num_box)->length = write_mainmhix(offset, cstr_info, cio);
#line 94
    (box + num_box)->type = 1835559288;
#line 95
    num_box ++;
#line 97
    (box + num_box)->length = write_tpix(offset, cstr_info, j2klen, cio);
#line 98
    (box + num_box)->type = 1953524088;
#line 99
    num_box ++;
#line 101
    (box + num_box)->length = write_thix(offset, cstr_info, cio);
#line 102
    (box + num_box)->type = 1952999800;
#line 103
    num_box ++;
#line 105
    EPHused = check_EPHuse(offset, cstr_info.marker, cstr_info.marknum, cio);
#line 107
    (box + num_box)->length = write_ppix(offset, cstr_info, EPHused, j2klen, cio);
#line 108
    (box + num_box)->type = 1886415224;
#line 109
    num_box ++;
#line 111
    (box + num_box)->length = write_phix(offset, cstr_info, EPHused, j2klen, cio);
#line 112
    (box + num_box)->type = 1885890936;
#line 113
    num_box ++;
#line 115
    __cil_tmp25 = cio_tell(cio);
#line 115
    len = __cil_tmp25 - lenp;
#line 116
    cio_seek(cio, lenp);
#line 117
    cio_write(cio, (unsigned long long )len, 4);
#line 118
    cio_seek(cio, lenp + len);
#line 79
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 121
  free((void *)box);
  }
#line 123
  return (len);
}
}
#line 126 "/root/patchweave_new/2/libopenjpeg/cidx_manager.c"
void write_cptr(int coff , int clen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp7 ;

  {
  {
#line 130
  lenp = cio_tell(cio);
#line 131
  cio_skip(cio, 4);
#line 132
  cio_write(cio, 1668314226ULL, 4);
#line 133
  cio_write(cio, 0ULL, 2);
#line 134
  cio_write(cio, 0ULL, 2);
#line 135
  cio_write(cio, (unsigned long long )coff, 8);
#line 136
  cio_write(cio, (unsigned long long )clen, 8);
#line 137
  __cil_tmp7 = cio_tell(cio);
#line 137
  len = __cil_tmp7 - lenp;
#line 138
  cio_seek(cio, lenp);
#line 139
  cio_write(cio, (unsigned long long )len, 4);
#line 140
  cio_seek(cio, lenp + len);
  }
#line 142
  return;
}
}
#line 143 "/root/patchweave_new/2/libopenjpeg/cidx_manager.c"
void write_manf(int second , int v , opj_jp2_box_t *box , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int i ;
  int __cil_tmp10 ;

  {
  {
#line 147
  lenp = cio_tell(cio);
#line 148
  cio_skip(cio, 4);
#line 149
  cio_write(cio, 1835101798ULL, 4);
  }
#line 151
  if (second) {
#line 152
    i = 0;
    {
#line 152
    while (1) {
      while_continue: /* CIL Label */ ;

#line 152
      if (! (i < v)) {
#line 152
        goto while_break;
      }
      {
#line 153
      cio_write(cio, (unsigned long long )(box + i)->length, 4);
#line 154
      cio_write(cio, (unsigned long long )(box + i)->type, 4);
#line 152
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 158
  __cil_tmp10 = cio_tell(cio);
#line 158
  len = __cil_tmp10 - lenp;
#line 159
  cio_seek(cio, lenp);
#line 160
  cio_write(cio, (unsigned long long )len, 4);
#line 161
  cio_seek(cio, lenp + len);
  }
#line 163
  return;
}
}
#line 164 "/root/patchweave_new/2/libopenjpeg/cidx_manager.c"
int write_mainmhix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) 
{ 
  int i ;
  int len ;
  int lenp ;
  int __cil_tmp9 ;

  {
  {
#line 169
  lenp = cio_tell(cio);
#line 170
  cio_skip(cio, 4);
#line 171
  cio_write(cio, 1835559288ULL, 4);
#line 173
  cio_write(cio, (unsigned long long )((cstr_info.main_head_end - cstr_info.main_head_start) + 1),
            8);
#line 175
  i = 1;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;

#line 175
    if (! (i < cstr_info.marknum)) {
#line 175
      goto while_break;
    }
    {
#line 176
    cio_write(cio, (unsigned long long )(cstr_info.marker + i)->type, 2);
#line 177
    cio_write(cio, 0ULL, 2);
#line 178
    cio_write(cio, (unsigned long long )((cstr_info.marker + i)->pos - coff), 8);
#line 179
    cio_write(cio, (unsigned long long )(cstr_info.marker + i)->len, 2);
#line 175
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 182
  __cil_tmp9 = cio_tell(cio);
#line 182
  len = __cil_tmp9 - lenp;
#line 183
  cio_seek(cio, lenp);
#line 184
  cio_write(cio, (unsigned long long )len, 4);
#line 185
  cio_seek(cio, lenp + len);
  }
#line 187
  return (len);
}
}
#line 190 "/root/patchweave_new/2/libopenjpeg/cidx_manager.c"
opj_bool check_EPHuse(int coff , opj_marker_info_t *markers , int marknum , opj_cio_t *cio ) 
{ 
  opj_bool EPHused ;
  int i ;
  int org_pos ;
  unsigned int Scod ;

  {
#line 192
  EPHused = 0;
#line 193
  i = 0;
#line 197
  i = 0;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;

#line 197
    if (! (i < marknum)) {
#line 197
      goto while_break;
    }
#line 198
    if ((int )(markers + i)->type == 65362) {
      {
#line 199
      org_pos = cio_tell(cio);
#line 200
      cio_seek(cio, (coff + (markers + i)->pos) + 2);
#line 202
      Scod = cio_read(cio, 1);
      }
#line 203
      if ((Scod >> 2) & 1U) {
#line 204
        EPHused = 1;
      }
      {
#line 205
      cio_seek(cio, org_pos);
      }
#line 207
      goto while_break;
    }
#line 197
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 210
  return (EPHused);
}
}
#line 45 "/root/patchweave_new/2/libopenjpeg/bio.c"
static void bio_putbit(opj_bio_t *bio , int b ) ;
#line 51
static int bio_getbit(opj_bio_t *bio ) ;
#line 57
static int bio_byteout(opj_bio_t *bio ) ;
#line 63
static int bio_bytein(opj_bio_t *bio ) ;
#line 75 "/root/patchweave_new/2/libopenjpeg/bio.c"
static int bio_byteout(opj_bio_t *bio ) 
{ 
  int tmp ;
  unsigned char *__cil_tmp3 ;

  {
#line 76
  bio->buf = (bio->buf << 8) & 65535U;
#line 77
  if (bio->buf == 65280U) {
#line 77
    tmp = 7;
  } else {
#line 77
    tmp = 8;
  }
#line 77
  bio->ct = tmp;
#line 78
  if ((unsigned long )bio->bp >= (unsigned long )bio->end) {
#line 79
    return (1);
  }
#line 81
  __cil_tmp3 = bio->bp;
#line 81
  (bio->bp) ++;
#line 81
  *__cil_tmp3 = (unsigned char )(bio->buf >> 8);
#line 82
  return (0);
}
}
#line 85 "/root/patchweave_new/2/libopenjpeg/bio.c"
static int bio_bytein(opj_bio_t *bio ) 
{ 
  int tmp ;
  unsigned char *__cil_tmp3 ;

  {
#line 86
  bio->buf = (bio->buf << 8) & 65535U;
#line 87
  if (bio->buf == 65280U) {
#line 87
    tmp = 7;
  } else {
#line 87
    tmp = 8;
  }
#line 87
  bio->ct = tmp;
#line 88
  if ((unsigned long )bio->bp >= (unsigned long )bio->end) {
#line 89
    return (1);
  }
#line 91
  __cil_tmp3 = bio->bp;
#line 91
  (bio->bp) ++;
#line 91
  bio->buf |= (unsigned int )*__cil_tmp3;
#line 92
  return (0);
}
}
#line 95 "/root/patchweave_new/2/libopenjpeg/bio.c"
static void bio_putbit(opj_bio_t *bio , int b ) 
{ 
  int __cil_tmp3 ;

  {
#line 96
  if (bio->ct == 0) {
    {
#line 97
    bio_byteout(bio);
    }
  }
#line 99
  __cil_tmp3 = bio->ct;
#line 99
  (bio->ct) --;
#line 100
  bio->buf |= (unsigned int )(b << bio->ct);
#line 101
  return;
}
}
#line 103 "/root/patchweave_new/2/libopenjpeg/bio.c"
static int bio_getbit(opj_bio_t *bio ) 
{ 
  int __cil_tmp2 ;

  {
#line 104
  if (bio->ct == 0) {
    {
#line 105
    bio_bytein(bio);
    }
  }
#line 107
  __cil_tmp2 = bio->ct;
#line 107
  (bio->ct) --;
#line 108
  return ((int )((bio->buf >> bio->ct) & 1U));
}
}
#line 117 "/root/patchweave_new/2/libopenjpeg/bio.c"
opj_bio_t *bio_create(void) 
{ 
  opj_bio_t *bio ;
  void *__cil_tmp2 ;

  {
  {
#line 118
  __cil_tmp2 = malloc(sizeof(opj_bio_t ));
#line 118
  bio = (opj_bio_t *)__cil_tmp2;
  }
#line 119
  return (bio);
}
}
#line 122 "/root/patchweave_new/2/libopenjpeg/bio.c"
void bio_destroy(opj_bio_t *bio ) 
{ 


  {
#line 123
  if (bio) {
    {
#line 124
    free((void *)bio);
    }
  }
#line 127
  return;
}
}
#line 128 "/root/patchweave_new/2/libopenjpeg/bio.c"
int bio_numbytes(opj_bio_t *bio ) 
{ 


  {
#line 129
  return ((int )(bio->bp - bio->start));
}
}
#line 132 "/root/patchweave_new/2/libopenjpeg/bio.c"
void bio_init_enc(opj_bio_t *bio , unsigned char *bp , int len ) 
{ 


  {
#line 133
  bio->start = bp;
#line 134
  bio->end = bp + len;
#line 135
  bio->bp = bp;
#line 136
  bio->buf = 0U;
#line 137
  bio->ct = 8;
#line 138
  return;
}
}
#line 140 "/root/patchweave_new/2/libopenjpeg/bio.c"
void bio_init_dec(opj_bio_t *bio , unsigned char *bp , int len ) 
{ 


  {
#line 141
  bio->start = bp;
#line 142
  bio->end = bp + len;
#line 143
  bio->bp = bp;
#line 144
  bio->buf = 0U;
#line 145
  bio->ct = 0;
#line 146
  return;
}
}
#line 148 "/root/patchweave_new/2/libopenjpeg/bio.c"
void bio_write(opj_bio_t *bio , int v , int n ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 150
  i = n - 1;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;

#line 150
    if (! (i >= 0)) {
#line 150
      goto while_break;
    }
    {
#line 151
    bio_putbit(bio, (v >> i) & 1);
#line 150
    __cil_tmp5 = i;
#line 150
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 154
  return;
}
}
#line 155 "/root/patchweave_new/2/libopenjpeg/bio.c"
int bio_read(opj_bio_t *bio , int n ) 
{ 
  int i ;
  int v ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 157
  v = 0;
#line 158
  i = n - 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;

#line 158
    if (! (i >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    __cil_tmp5 = bio_getbit(bio);
#line 159
    v += __cil_tmp5 << i;
#line 158
    __cil_tmp6 = i;
#line 158
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 161
  return (v);
}
}
#line 164 "/root/patchweave_new/2/libopenjpeg/bio.c"
int bio_flush(opj_bio_t *bio ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 165
  bio->ct = 0;
#line 166
  __cil_tmp2 = bio_byteout(bio);
  }
#line 166
  if (__cil_tmp2) {
#line 167
    return (1);
  }
#line 169
  if (bio->ct == 7) {
    {
#line 170
    bio->ct = 0;
#line 171
    __cil_tmp3 = bio_byteout(bio);
    }
#line 171
    if (__cil_tmp3) {
#line 172
      return (1);
    }
  }
#line 175
  return (0);
}
}
#line 178 "/root/patchweave_new/2/libopenjpeg/bio.c"
int bio_inalign(opj_bio_t *bio ) 
{ 
  int __cil_tmp2 ;

  {
#line 179
  bio->ct = 0;
#line 180
  if ((bio->buf & 255U) == 255U) {
    {
#line 181
    __cil_tmp2 = bio_bytein(bio);
    }
#line 181
    if (__cil_tmp2) {
#line 182
      return (1);
    }
#line 184
    bio->ct = 0;
  }
#line 186
  return (0);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 22 "/root/patchweave_new/2/applications/common/opj_getopt.h"
extern char *opj_optarg ;
#line 25
extern int opj_getopt_long(int argc , char * const  *argv , char const   *optstring ,
                           opj_option_t *longopts , int totlen ) ;
#line 52 "/root/patchweave_new/2/applications/codec/convert.h"
extern int imagetotga(opj_image_t *image , char const   *outfile ) ;
#line 56
extern int imagetobmp(opj_image_t *image , char const   *outfile ) ;
#line 60
extern int imagetotif(opj_image_t *image , char const   *outfile ) ;
#line 68
extern int imagetopgx(opj_image_t *image , char const   *outfile ) ;
#line 71
extern int imagetopnm(opj_image_t *image , char const   *outfile ) ;
#line 74
extern int imagetoraw(opj_image_t *image , char const   *outfile ) ;
#line 78
extern int imagetopng(opj_image_t *image , char const   *write_idf ) ;
#line 42 "/root/patchweave_new/2/applications/codec/index.h"
extern int write_index_file(opj_codestream_info_t *cstr_info , char *index ) ;
#line 35 "/root/patchweave_new/2/applications/common/color.h"
extern void color_sycc_to_rgb(opj_image_t *img ) ;
#line 88 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
void decode_help_display(void) 
{ 


  {
  {
#line 89
  fprintf(stdout, "HELP for j2k_to_image\n----\n\n");
#line 90
  fprintf(stdout, "- the -h option displays this help information on screen\n\n");
#line 93
  fprintf(stdout, "List of parameters for the JPEG 2000 decoder:\n");
#line 99
  fprintf(stdout, "\n");
#line 100
  fprintf(stdout, "\n");
#line 101
  fprintf(stdout, "  -ImgDir \n");
#line 102
  fprintf(stdout, "\tImage file Directory path \n");
#line 103
  fprintf(stdout, "  -OutFor \n");
#line 104
  fprintf(stdout, "    REQUIRED only if -ImgDir is used\n");
#line 105
  fprintf(stdout, "\t  Need to specify only format without filename <BMP>  \n\220");
#line 106
  fprintf(stdout, "    Currently accepts PGM, PPM, PNM, PGX, PNG, BMP, TIF, RAW and TGA formats\n");
#line 107
  fprintf(stdout, "  -i <compressed file>\n");
#line 108
  fprintf(stdout, "    REQUIRED only if an Input image directory not specified\n");
#line 109
  fprintf(stdout, "    Currently accepts J2K-files, JP2-files and JPT-files. The file type\n\220");
#line 110
  fprintf(stdout, "    is identified based on its suffix.\n");
#line 111
  fprintf(stdout, "  -o <decompressed file>\n");
#line 112
  fprintf(stdout, "    REQUIRED\n");
#line 113
  fprintf(stdout, "    Currently accepts PGM, PPM, PNM, PGX, PNG, BMP, TIF, RAW and TGA files\n");
#line 114
  fprintf(stdout, "    Binary data is written to the file (not ascii). If a PGX\n");
#line 115
  fprintf(stdout, "    filename is given, there will be as many output files as there are\n");
#line 116
  fprintf(stdout, "    components: an indice starting from 0 will then be appended to the\n");
#line 117
  fprintf(stdout, "    output filename, just before the \"pgx\" extension. If a PGM filename\n\220");
#line 118
  fprintf(stdout, "    is given and there are more than one component, only the first component\n");
#line 119
  fprintf(stdout, "    will be written to the file.\n");
#line 120
  fprintf(stdout, "  -r <reduce factor>\n");
#line 121
  fprintf(stdout, "    Set the number of highest resolution levels to be discarded. The\n");
#line 122
  fprintf(stdout, "    image resolution is effectively divided by 2 to the power of the\n");
#line 123
  fprintf(stdout, "    number of discarded levels. The reduce factor is limited by the\n");
#line 124
  fprintf(stdout, "    smallest total number of decomposition levels among tiles.\n");
#line 125
  fprintf(stdout, "  -l <number of quality layers to decode>\n");
#line 126
  fprintf(stdout, "    Set the maximum number of quality layers to decode. If there are\n");
#line 127
  fprintf(stdout, "    less quality layers than the specified number, all the quality layers\n");
#line 128
  fprintf(stdout, "    are decoded.\n");
#line 129
  fprintf(stdout, "  -x  \n");
#line 130
  fprintf(stdout, "    Create an index file *.Idx (-x index_name.Idx) \n");
#line 131
  fprintf(stdout, "\n");
#line 142
  fprintf(stdout, "\n");
  }
#line 144
  return;
}
}
#line 147 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
int get_num_images(char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int num_images ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 150
  num_images = 0;
#line 154
  dir = opendir((char const   *)imgdirpath);
  }
#line 155
  if (! dir) {
    {
#line 156
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 157
    return (0);
  }
  {
#line 160
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 160
    content = readdir(dir);
    }
#line 160
    if (! ((unsigned long )content != (unsigned long )((void *)0))) {
#line 160
      goto while_break;
    }
    {
#line 161
    __cil_tmp8 = strcmp("..", (char const   *)(content->d_name));
#line 161
    __cil_tmp7 = strcmp(".", (char const   *)(content->d_name));
    }
#line 161
    if (__cil_tmp7 == 0) {
#line 162
      goto while_continue;
    } else
#line 161
    if (__cil_tmp8 == 0) {
#line 162
      goto while_continue;
    }
#line 163
    num_images ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 165
  return (num_images);
}
}
#line 168 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
int load_images(dircnt_t *dirptr , char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int i ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 171
  i = 0;
#line 175
  dir = opendir((char const   *)imgdirpath);
  }
#line 176
  if (! dir) {
    {
#line 177
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 178
    return (1);
  } else {
    {
#line 180
    fprintf(stderr, "Folder opened successfully\n");
    }
  }
  {
#line 183
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 183
    content = readdir(dir);
    }
#line 183
    if (! ((unsigned long )content != (unsigned long )((void *)0))) {
#line 183
      goto while_break;
    }
    {
#line 184
    __cil_tmp9 = strcmp("..", (char const   *)(content->d_name));
#line 184
    __cil_tmp8 = strcmp(".", (char const   *)(content->d_name));
    }
#line 184
    if (__cil_tmp8 == 0) {
#line 185
      goto while_continue;
    } else
#line 184
    if (__cil_tmp9 == 0) {
#line 185
      goto while_continue;
    }
    {
#line 187
    strcpy(*(dirptr->filename + i), (char const   *)(content->d_name));
#line 188
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 190
  return (0);
}
}
#line 196 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
static char const   *extension[14]  ;
#line 197 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
static int const   format[14]  ;
#line 193 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
int get_file_format(char *filename ) 
{ 
  unsigned int i ;
  char *ext ;
  char *__cil_tmp6 ;
  int __cil_tmp8 ;

  {
  {
#line 195
  strcpy((char *)extension[0], "pgx");
#line 195
  strcpy((char *)extension[1], "pnm");
#line 195
  strcpy((char *)extension[2], "pgm");
#line 195
  strcpy((char *)extension[3], "ppm");
#line 195
  strcpy((char *)extension[4], "bmp");
#line 195
  strcpy((char *)extension[5], "tif");
#line 195
  strcpy((char *)extension[6], "raw");
#line 195
  strcpy((char *)extension[7], "tga");
#line 195
  strcpy((char *)extension[8], "png");
#line 195
  strcpy((char *)extension[9], "j2k");
#line 195
  strcpy((char *)extension[10], "jp2");
#line 195
  strcpy((char *)extension[11], "jpt");
#line 195
  strcpy((char *)extension[12], "j2c");
#line 195
  strcpy((char *)extension[13], "jpc");
#line 196
  format[0] = (int const   )11;
#line 196
  format[1] = (int const   )10;
#line 196
  format[2] = (int const   )10;
#line 196
  format[3] = (int const   )10;
#line 196
  format[4] = (int const   )12;
#line 196
  format[5] = (int const   )14;
#line 196
  format[6] = (int const   )15;
#line 196
  format[7] = (int const   )16;
#line 196
  format[8] = (int const   )17;
#line 196
  format[9] = (int const   )0;
#line 196
  format[10] = (int const   )1;
#line 196
  format[11] = (int const   )2;
#line 196
  format[12] = (int const   )0;
#line 196
  format[13] = (int const   )0;
#line 197
  __cil_tmp6 = strrchr((char const   *)filename, '.');
#line 197
  ext = __cil_tmp6;
  }
#line 198
  if ((unsigned long )ext == (unsigned long )((void *)0)) {
#line 199
    return (-1);
  }
#line 200
  ext ++;
#line 201
  if (ext) {
#line 202
    i = 0U;
    {
#line 202
    while (1) {
      while_continue: /* CIL Label */ ;

#line 202
      if (! ((unsigned long )i < sizeof(format) / sizeof(format[0]))) {
#line 202
        goto while_break;
      }
      {
#line 203
      __cil_tmp8 = strncasecmp((char const   *)ext, extension[i], 3UL);
      }
#line 203
      if (__cil_tmp8 == 0) {
#line 204
        return ((int )format[i]);
      }
#line 202
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 209
  return (-1);
}
}
#line 212 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
char get_next_file(int imageno , dircnt_t *dirptr , img_fol_t *img_fol , opj_dparameters_t *parameters ) 
{ 
  char image_filename[4096] ;
  char infilename[4096] ;
  char outfilename[4096] ;
  char temp_ofname[4096] ;
  char *temp_p ;
  char temp1[4096] ;
  char *__cil_tmp12 ;

  {
  {
#line 214
  strcpy(temp1, "\002");
#line 216
  strcpy(image_filename, (char const   *)*(dirptr->filename + imageno));
#line 217
  fprintf(stderr, "File Number %d \"%s\"\n", imageno, image_filename);
#line 218
  parameters->decod_format = get_file_format(image_filename);
  }
#line 219
  if (parameters->decod_format == -1) {
#line 220
    return ((char)1);
  }
  {
#line 221
  sprintf(infilename, "%s/%sU", img_fol->imgdirpath, image_filename);
#line 222
  strncpy(parameters->infile, (char const   *)(infilename), sizeof(infilename));
#line 225
  __cil_tmp12 = strtok(image_filename, ".\0337\271\312U");
#line 225
  strcpy(temp_ofname, (char const   *)__cil_tmp12);
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    temp_p = strtok((char *)((void *)0), ".");
    }
#line 226
    if (! ((unsigned long )temp_p != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
    {
#line 227
    strcat(temp_ofname, (char const   *)(temp1));
#line 228
    sprintf(temp1, ".%s\271\312U", temp_p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 230
  if ((int )img_fol->set_out_format == 1) {
    {
#line 231
    sprintf(outfilename, "%s/%s.%s\230\001", img_fol->imgdirpath, temp_ofname, img_fol->out_format);
#line 232
    strncpy(parameters->outfile, (char const   *)(outfilename), sizeof(outfilename));
    }
  }
#line 234
  return ((char)0);
}
}
#line 238 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
int parse_cmdline_decoder(int argc , char **argv , opj_dparameters_t *parameters ,
                          img_fol_t *img_fol , char *indexfilename ) 
{ 
  int totlen ;
  int c ;
  opj_option_t long_option[2] ;
  char optlist[12] ;
  char *infile ;
  char *outfile ;
  char outformat[50] ;
  char *of ;
  unsigned long __cil_tmp18 ;
  void *__cil_tmp19 ;
  char *index___21 ;

  {
  {
#line 241
  strcpy((char *)long_option[0].name, "ImgDir");
#line 241
  long_option[0].has_arg = 1;
#line 241
  long_option[0].flag = (int *)((void *)0);
#line 241
  long_option[0].val = 'y';
#line 241
  strcpy((char *)long_option[1].name, "OutFor");
#line 241
  long_option[1].has_arg = 1;
#line 241
  long_option[1].flag = (int *)((void *)0);
#line 241
  long_option[1].val = 'O';
#line 246
  strcpy(optlist, "i:o:r:l:x:h");
#line 254
  totlen = (int )sizeof(long_option);
#line 255
  img_fol->set_out_format = (char)0;
  }
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 257
    c = opj_getopt_long(argc, argv, (char const   *)(optlist), long_option, totlen);
    }
#line 258
    if (c == -1) {
#line 259
      goto while_break;
    }
#line 261
    if (c == 105) {
#line 261
      goto case_105;
    }
#line 268
    if (c == 2) {
#line 268
      goto case_2;
    }
#line 268
    if (c == 1) {
#line 268
      goto case_2;
    }
#line 268
    if (c == 0) {
#line 268
      goto case_2;
    }
#line 282
    if (c == 111) {
#line 282
      goto case_111;
    }
#line 293
    if (c == 17) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 16) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 15) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 14) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 12) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 10) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 11) {
#line 293
      goto case_17;
    }
#line 305
    if (c == 79) {
#line 305
      goto case_79;
    }
#line 313
    if (c == 11) {
#line 313
      goto case_11___0;
    }
#line 316
    if (c == 10) {
#line 316
      goto case_10___0;
    }
#line 319
    if (c == 12) {
#line 319
      goto case_12___0;
    }
#line 322
    if (c == 14) {
#line 322
      goto case_14___0;
    }
#line 325
    if (c == 15) {
#line 325
      goto case_15___0;
    }
#line 328
    if (c == 16) {
#line 328
      goto case_16___0;
    }
#line 331
    if (c == 17) {
#line 331
      goto case_17___0;
    }
#line 345
    if (c == 114) {
#line 345
      goto case_114;
    }
#line 354
    if (c == 108) {
#line 354
      goto case_108;
    }
#line 362
    if (c == 104) {
#line 362
      goto case_104;
    }
#line 368
    if (c == 121) {
#line 368
      goto case_121;
    }
#line 376
    if (c == 120) {
#line 376
      goto case_120;
    }
#line 456
    goto switch_default___2;
    case_105: 
    {
#line 263
    infile = opj_optarg;
#line 264
    parameters->decod_format = get_file_format(infile);
    }
#line 268
    if (parameters->decod_format == 2) {
#line 268
      goto case_2;
    }
#line 268
    if (parameters->decod_format == 1) {
#line 268
      goto case_2;
    }
#line 268
    if (parameters->decod_format == 0) {
#line 268
      goto case_2;
    }
#line 270
    goto switch_default;
    case_2: 
#line 269
    goto switch_break___0;
    switch_default: 
    {
#line 271
    fprintf(stderr, "!! Unrecognized format for infile : %s [accept only *.j2k, *.jp2, *.jpc or *.jpt] !!\n\n",
            infile);
    }
#line 274
    return (1);
    switch_break___0: 
    {
#line 276
    strncpy(parameters->infile, (char const   *)infile, sizeof(parameters->infile) - 1UL);
    }
#line 278
    goto switch_break;
    case_111: 
    {
#line 284
    outfile = opj_optarg;
#line 285
    parameters->cod_format = get_file_format(outfile);
    }
#line 293
    if (parameters->cod_format == 17) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 16) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 15) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 14) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 12) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 10) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 11) {
#line 293
      goto case_17;
    }
#line 295
    goto switch_default___0;
    case_17: 
#line 294
    goto switch_break___1;
    switch_default___0: 
    {
#line 296
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n",
            outfile);
    }
#line 297
    return (1);
    switch_break___1: 
    {
#line 299
    strncpy(parameters->outfile, (char const   *)outfile, sizeof(parameters->outfile) - 1UL);
    }
#line 301
    goto switch_break;
    case_79: 
    {
#line 308
    of = opj_optarg;
#line 309
    sprintf(outformat, ".%s\271\312U", of);
#line 310
    img_fol->set_out_format = (char)1;
#line 311
    parameters->cod_format = get_file_format(outformat);
    }
#line 313
    if (parameters->cod_format == 11) {
#line 313
      goto case_11___0;
    }
#line 316
    if (parameters->cod_format == 10) {
#line 316
      goto case_10___0;
    }
#line 319
    if (parameters->cod_format == 12) {
#line 319
      goto case_12___0;
    }
#line 322
    if (parameters->cod_format == 14) {
#line 322
      goto case_14___0;
    }
#line 325
    if (parameters->cod_format == 15) {
#line 325
      goto case_15___0;
    }
#line 328
    if (parameters->cod_format == 16) {
#line 328
      goto case_16___0;
    }
#line 331
    if (parameters->cod_format == 17) {
#line 331
      goto case_17___0;
    }
#line 334
    goto switch_default___1;
    case_11___0: 
    {
#line 314
    strcpy((char *)img_fol->out_format, "pgx");
    }
#line 315
    goto switch_break___2;
    case_10___0: 
    {
#line 317
    strcpy((char *)img_fol->out_format, "ppm");
    }
#line 318
    goto switch_break___2;
    case_12___0: 
    {
#line 320
    strcpy((char *)img_fol->out_format, "bmp");
    }
#line 321
    goto switch_break___2;
    case_14___0: 
    {
#line 323
    strcpy((char *)img_fol->out_format, "tif");
    }
#line 324
    goto switch_break___2;
    case_15___0: 
    {
#line 326
    strcpy((char *)img_fol->out_format, "raw\271\312U");
    }
#line 327
    goto switch_break___2;
    case_16___0: 
    {
#line 329
    strcpy((char *)img_fol->out_format, "raw");
    }
#line 330
    goto switch_break___2;
    case_17___0: 
    {
#line 332
    strcpy((char *)img_fol->out_format, "png");
    }
#line 333
    goto switch_break___2;
    switch_default___1: 
    {
#line 335
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n",
            outformat);
    }
#line 336
    return (1);
#line 337
    goto switch_break___2;
    switch_break___2: ;
#line 340
    goto switch_break;
    case_114: 
    {
#line 347
    sscanf((char const   *)opj_optarg, "%d", & parameters->cp_reduce);
    }
#line 349
    goto switch_break;
    case_108: 
    {
#line 356
    sscanf((char const   *)opj_optarg, "%d", & parameters->cp_layer);
    }
#line 358
    goto switch_break;
    case_104: 
    {
#line 363
    decode_help_display();
    }
#line 364
    return (1);
    case_121: 
    {
#line 370
    __cil_tmp18 = strlen((char const   *)opj_optarg);
#line 370
    __cil_tmp19 = malloc(__cil_tmp18 + 1UL);
#line 370
    img_fol->imgdirpath = (char *)__cil_tmp19;
#line 371
    strcpy(img_fol->imgdirpath, (char const   *)opj_optarg);
#line 372
    img_fol->set_imgdir = (char)1;
    }
#line 374
    goto switch_break;
    case_120: 
    {
#line 378
    index___21 = opj_optarg;
#line 379
    strncpy(indexfilename, (char const   *)index___21, 4096UL);
    }
#line 381
    goto switch_break;
    switch_default___2: 
    {
#line 457
    fprintf(stderr, "WARNING -> this option is not valid \"-%c %s\"\n", c, opj_optarg);
    }
#line 458
    goto switch_break;
    switch_break: ;
#line 256
    if (! (c != -1)) {
#line 256
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 463
  if ((int )img_fol->set_imgdir == 1) {
#line 464
    if (! ((int )parameters->infile[0] == 0)) {
      {
#line 465
      fprintf(stderr, "Error: options -ImgDir and -i cannot be used together !!\n");
      }
#line 466
      return (1);
    }
#line 468
    if ((int )img_fol->set_out_format == 0) {
      {
#line 469
      fprintf(stderr, "Error: When -ImgDir is used, -OutFor <FORMAT> must be used !!\n");
#line 470
      fprintf(stderr, "Only one format allowed! Valid format PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA!!\n");
      }
#line 471
      return (1);
    }
#line 473
    if (! ((int )parameters->outfile[0] == 0)) {
      {
#line 474
      fprintf(stderr, "Error: options -ImgDir and -o cannot be used together !!\n");
      }
#line 475
      return (1);
    }
  } else
#line 478
  if ((int )parameters->infile[0] == 0) {
    {
#line 479
    fprintf(stderr, "Example: %s -i image.j2k -o image.pgm\n", *(argv + 0));
#line 480
    fprintf(stderr, "    Try: %s -h\n", *(argv + 0));
    }
#line 481
    return (1);
  } else
#line 478
  if ((int )parameters->outfile[0] == 0) {
    {
#line 479
    fprintf(stderr, "Example: %s -i image.j2k -o image.pgm\n", *(argv + 0));
#line 480
    fprintf(stderr, "    Try: %s -h\n", *(argv + 0));
    }
#line 481
    return (1);
  }
#line 485
  return (0);
}
}
#line 493 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
void error_callback(char const   *msg , void *client_data ) 
{ 
  FILE *stream ;

  {
  {
#line 494
  stream = (FILE *)client_data;
#line 495
  fprintf(stream, "[ERROR] %s", msg);
  }
#line 497
  return;
}
}
#line 500 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
void warning_callback(char const   *msg , void *client_data ) 
{ 
  FILE *stream ;

  {
  {
#line 501
  stream = (FILE *)client_data;
#line 502
  fprintf(stream, "[WARNING] %s", msg);
  }
#line 504
  return;
}
}
#line 507 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
void info_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 509
  fprintf(stdout, "[INFO] %s", msg);
  }
#line 511
  return;
}
}
#line 514 "/root/patchweave_new/2/applications/codec/j2k_to_image.c"
int main(int argc , char **argv ) 
{ 
  opj_dparameters_t parameters ;
  img_fol_t img_fol ;
  opj_event_mgr_t event_mgr ;
  opj_image_t *image ;
  FILE *fsrc ;
  unsigned char *src ;
  int file_length ;
  int num_images ;
  int i ;
  int imageno ;
  dircnt_t *dirptr ;
  opj_dinfo_t *dinfo ;
  opj_cio_t *cio ;
  opj_codestream_info_t cstr_info ;
  char indexfilename[4096] ;
  int __cil_tmp18 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  int __cil_tmp24 ;
  char __cil_tmp25 ;
  long __cil_tmp27 ;
  void *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  opj_bool bSuccess ;
  opj_bool bSuccess___0 ;
  opj_bool bSuccess___1 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;

  {
  {
#line 518
  image = (opj_image_t *)((void *)0);
#line 519
  fsrc = (FILE *)((void *)0);
#line 520
  src = (unsigned char *)((void *)0);
#line 524
  dirptr = (dircnt_t *)((void *)0);
#line 525
  dinfo = (opj_dinfo_t *)((void *)0);
#line 526
  cio = (opj_cio_t *)((void *)0);
#line 531
  memset((void *)(& event_mgr), 0, sizeof(opj_event_mgr_t ));
#line 532
  event_mgr.error_handler = & error_callback;
#line 533
  event_mgr.warning_handler = & warning_callback;
#line 534
  event_mgr.info_handler = & info_callback;
#line 537
  opj_set_default_decoder_parameters(& parameters);
#line 540
  indexfilename[0] = (char)0;
#line 541
  memset((void *)(& img_fol), 0, sizeof(img_fol_t ));
#line 544
  __cil_tmp18 = parse_cmdline_decoder(argc, argv, & parameters, & img_fol, indexfilename);
  }
#line 544
  if (__cil_tmp18 == 1) {
#line 545
    return (1);
  }
#line 549
  if ((int )img_fol.set_imgdir == 1) {
    {
#line 550
    num_images = get_num_images(img_fol.imgdirpath);
#line 552
    __cil_tmp20 = malloc(sizeof(dircnt_t ));
#line 552
    dirptr = (dircnt_t *)__cil_tmp20;
    }
#line 553
    if (dirptr) {
      {
#line 554
      __cil_tmp21 = malloc((unsigned long )(num_images * 4096) * sizeof(char ));
#line 554
      dirptr->filename_buf = (char *)__cil_tmp21;
#line 555
      __cil_tmp22 = malloc((unsigned long )num_images * sizeof(char *));
#line 555
      dirptr->filename = (char **)__cil_tmp22;
      }
#line 557
      if (! dirptr->filename_buf) {
#line 558
        return (1);
      }
#line 560
      i = 0;
      {
#line 560
      while (1) {
        while_continue: /* CIL Label */ ;

#line 560
        if (! (i < num_images)) {
#line 560
          goto while_break;
        }
#line 561
        *(dirptr->filename + i) = dirptr->filename_buf + i * 4096;
#line 560
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: ;
    }
    {
#line 564
    __cil_tmp24 = load_images(dirptr, img_fol.imgdirpath);
    }
#line 564
    if (__cil_tmp24 == 1) {
#line 565
      return (1);
    }
#line 567
    if (num_images == 0) {
      {
#line 568
      fprintf(stdout, "Folder is empty\n\220");
      }
#line 569
      return (1);
    }
  } else {
#line 572
    num_images = 1;
  }
#line 576
  imageno = 0;
  {
#line 576
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue___0: ;
#line 576
    if (! (imageno < num_images)) {
#line 576
      goto while_break___0;
    }
    {
#line 577
    image = (opj_image_t *)((void *)0);
#line 578
    fprintf(stderr, "\n");
    }
#line 580
    if ((int )img_fol.set_imgdir == 1) {
      {
#line 581
      __cil_tmp25 = get_next_file(imageno, dirptr, & img_fol, & parameters);
      }
#line 581
      if (__cil_tmp25) {
        {
#line 582
        fprintf(stderr, "skipping file...\nf7\271\312U");
        }
#line 583
        goto while_continue___0;
      }
    }
    {
#line 589
    fsrc = fopen((char const   *)(parameters.infile), "rb");
    }
#line 590
    if (! fsrc) {
      {
#line 591
      fprintf(stderr, "ERROR -> failed to open %s for reading\n", parameters.infile);
      }
#line 592
      return (1);
    }
    {
#line 594
    fseek(fsrc, 0L, 2);
#line 595
    __cil_tmp27 = ftell(fsrc);
#line 595
    file_length = (int )__cil_tmp27;
#line 596
    fseek(fsrc, 0L, 0);
#line 597
    __cil_tmp28 = malloc((unsigned long )file_length);
#line 597
    src = (unsigned char *)__cil_tmp28;
#line 598
    __cil_tmp29 = fread((void *)src, 1UL, (unsigned long )file_length, fsrc);
    }
#line 598
    if (__cil_tmp29 != (size_t )file_length) {
      {
#line 600
      free((void *)src);
#line 601
      fclose(fsrc);
#line 602
      fprintf(stderr, "\nERROR: fread return a number of element different from the expected.\n");
      }
#line 603
      return (1);
    }
    {
#line 605
    fclose(fsrc);
    }
#line 611
    if (parameters.decod_format == 0) {
#line 611
      goto case_0;
    }
#line 654
    if (parameters.decod_format == 1) {
#line 654
      goto case_1;
    }
#line 697
    if (parameters.decod_format == 2) {
#line 697
      goto case_2;
    }
#line 740
    goto switch_default;
    case_0: 
    {
#line 616
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )0);
#line 619
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, (void *)stderr);
#line 622
    opj_setup_decoder(dinfo, & parameters);
#line 625
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 628
    if (indexfilename[0]) {
      {
#line 629
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 631
      image = opj_decode(dinfo, cio);
      }
    }
#line 632
    if (! image) {
      {
#line 633
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 634
      opj_destroy_decompress(dinfo);
#line 635
      opj_cio_close(cio);
#line 636
      free((void *)src);
      }
#line 637
      return (1);
    }
    {
#line 641
    opj_cio_close(cio);
    }
#line 644
    if (indexfilename[0]) {
      {
#line 646
      bSuccess = write_index_file(& cstr_info, indexfilename);
      }
#line 647
      if (bSuccess) {
        {
#line 648
        fprintf(stderr, "Failed to output index file\n\312U");
        }
      }
    }
#line 652
    goto switch_break;
    case_1: 
    {
#line 659
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )2);
#line 662
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, (void *)stderr);
#line 665
    opj_setup_decoder(dinfo, & parameters);
#line 668
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 671
    if (indexfilename[0]) {
      {
#line 672
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 674
      image = opj_decode(dinfo, cio);
      }
    }
#line 675
    if (! image) {
      {
#line 676
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 677
      opj_destroy_decompress(dinfo);
#line 678
      opj_cio_close(cio);
#line 679
      free((void *)src);
      }
#line 680
      return (1);
    }
    {
#line 684
    opj_cio_close(cio);
    }
#line 687
    if (indexfilename[0]) {
      {
#line 689
      bSuccess___0 = write_index_file(& cstr_info, indexfilename);
      }
#line 690
      if (bSuccess___0) {
        {
#line 691
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 695
    goto switch_break;
    case_2: 
    {
#line 702
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )1);
#line 705
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, (void *)stderr);
#line 708
    opj_setup_decoder(dinfo, & parameters);
#line 711
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 714
    if (indexfilename[0]) {
      {
#line 715
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 717
      image = opj_decode(dinfo, cio);
      }
    }
#line 718
    if (! image) {
      {
#line 719
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 720
      opj_destroy_decompress(dinfo);
#line 721
      opj_cio_close(cio);
#line 722
      free((void *)src);
      }
#line 723
      return (1);
    }
    {
#line 727
    opj_cio_close(cio);
    }
#line 730
    if (indexfilename[0]) {
      {
#line 732
      bSuccess___1 = write_index_file(& cstr_info, indexfilename);
      }
#line 733
      if (bSuccess___1) {
        {
#line 734
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 738
    goto switch_break;
    switch_default: 
    {
#line 741
    fprintf(stderr, "skipping file..\n\220");
    }
#line 742
    goto while_continue___0;
    switch_break: 
    {
#line 746
    free((void *)src);
#line 747
    src = (unsigned char *)((void *)0);
    }
#line 749
    if ((int )image->color_space == 3) {
      {
#line 751
      color_sycc_to_rgb(image);
      }
    }
#line 754
    if (image->icc_profile_buf) {
      {
#line 760
      free((void *)image->icc_profile_buf);
#line 761
      image->icc_profile_buf = (unsigned char *)((void *)0);
#line 761
      image->icc_profile_len = 0;
      }
    }
#line 767
    if (parameters.cod_format == 10) {
#line 767
      goto case_10;
    }
#line 776
    if (parameters.cod_format == 11) {
#line 776
      goto case_11;
    }
#line 785
    if (parameters.cod_format == 12) {
#line 785
      goto case_12;
    }
#line 794
    if (parameters.cod_format == 14) {
#line 794
      goto case_14;
    }
#line 803
    if (parameters.cod_format == 15) {
#line 803
      goto case_15;
    }
#line 812
    if (parameters.cod_format == 16) {
#line 812
      goto case_16;
    }
#line 821
    if (parameters.cod_format == 17) {
#line 821
      goto case_17;
    }
#line 833
    goto switch_default___0;
    case_10: 
    {
#line 768
    __cil_tmp48 = imagetopnm(image, (char const   *)(parameters.outfile));
    }
#line 768
    if (__cil_tmp48) {
      {
#line 769
      fprintf(stdout, "Outfile %s not generated\n", parameters.outfile);
      }
    } else {
      {
#line 772
      fprintf(stdout, "Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 774
    goto switch_break___0;
    case_11: 
    {
#line 777
    __cil_tmp49 = imagetopgx(image, (char const   *)(parameters.outfile));
    }
#line 777
    if (__cil_tmp49) {
      {
#line 778
      fprintf(stdout, "Outfile %s not generated\n", parameters.outfile);
      }
    } else {
      {
#line 781
      fprintf(stdout, "Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 783
    goto switch_break___0;
    case_12: 
    {
#line 786
    __cil_tmp50 = imagetobmp(image, (char const   *)(parameters.outfile));
    }
#line 786
    if (__cil_tmp50) {
      {
#line 787
      fprintf(stdout, "Outfile %s not generated\n", parameters.outfile);
      }
    } else {
      {
#line 790
      fprintf(stdout, "Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 792
    goto switch_break___0;
    case_14: 
    {
#line 795
    __cil_tmp51 = imagetotif(image, (char const   *)(parameters.outfile));
    }
#line 795
    if (__cil_tmp51) {
      {
#line 796
      fprintf(stdout, "Outfile %s not generated\n", parameters.outfile);
      }
    } else {
      {
#line 799
      fprintf(stdout, "Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 801
    goto switch_break___0;
    case_15: 
    {
#line 804
    __cil_tmp52 = imagetoraw(image, (char const   *)(parameters.outfile));
    }
#line 804
    if (__cil_tmp52) {
      {
#line 805
      fprintf(stdout, "Error generating raw file. Outfile %s not generated\n", parameters.outfile);
      }
    } else {
      {
#line 808
      fprintf(stdout, "Successfully generated Outfile %s\n", parameters.outfile);
      }
    }
#line 810
    goto switch_break___0;
    case_16: 
    {
#line 813
    __cil_tmp53 = imagetotga(image, (char const   *)(parameters.outfile));
    }
#line 813
    if (__cil_tmp53) {
      {
#line 814
      fprintf(stdout, "Error generating tga file. Outfile %s not generated\n", parameters.outfile);
      }
    } else {
      {
#line 817
      fprintf(stdout, "Successfully generated Outfile %s\n", parameters.outfile);
      }
    }
#line 819
    goto switch_break___0;
    case_17: 
    {
#line 822
    __cil_tmp54 = imagetopng(image, (char const   *)(parameters.outfile));
    }
#line 822
    if (__cil_tmp54) {
      {
#line 823
      fprintf(stdout, "Error generating png file. Outfile %s not generated\n", parameters.outfile);
      }
    } else {
      {
#line 826
      fprintf(stdout, "Successfully generated Outfile %s\n", parameters.outfile);
      }
    }
#line 828
    goto switch_break___0;
    switch_default___0: 
    {
#line 834
    fprintf(stderr, "Outfile %s not generated\n", parameters.outfile);
    }
    switch_break___0: ;
#line 838
    if (dinfo) {
      {
#line 839
      opj_destroy_decompress(dinfo);
      }
    }
#line 842
    if (indexfilename[0]) {
      {
#line 843
      opj_destroy_cstr_info(& cstr_info);
      }
    }
    {
#line 845
    opj_image_destroy(image);
#line 576
    imageno ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 848
  return (0);
}
}
