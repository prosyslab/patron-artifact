/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 77 "/usr/include/stdio.h"
typedef __ssize_t intptr_t;
#line 823
struct obstack ;
#line 328 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef int wchar_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 327 "/root/patchweave_new/23/src/sndfile.h"
struct SNDFILE_tag ;
#line 327 "/root/patchweave_new/23/src/sndfile.h"
typedef struct SNDFILE_tag SNDFILE;
#line 340 "/root/patchweave_new/23/src/sndfile.h"
typedef int64_t sf_count_t;
#line 350 "/root/patchweave_new/23/src/sndfile.h"
struct SF_INFO {
   sf_count_t frames ;
   int samplerate ;
   int channels ;
   int format ;
   int sections ;
   int seekable ;
};
#line 359 "/root/patchweave_new/23/src/sndfile.h"
typedef struct SF_INFO SF_INFO;
#line 372 "/root/patchweave_new/23/src/sndfile.h"
struct __anonstruct_29 {
   int format ;
   char const   *name ;
   char const   *extension ;
};
#line 376 "/root/patchweave_new/23/src/sndfile.h"
typedef struct __anonstruct_29 SF_FORMAT_INFO;
#line 393 "/root/patchweave_new/23/src/sndfile.h"
struct __anonstruct_31 {
   int type ;
   double level ;
   char const   *name ;
};
#line 397 "/root/patchweave_new/23/src/sndfile.h"
typedef struct __anonstruct_31 SF_DITHER_INFO;
#line 403 "/root/patchweave_new/23/src/sndfile.h"
struct __anonstruct_32 {
   sf_count_t offset ;
   sf_count_t length ;
};
#line 406 "/root/patchweave_new/23/src/sndfile.h"
typedef struct __anonstruct_32 SF_EMBED_FILE_INFO;
#line 412 "/root/patchweave_new/23/src/sndfile.h"
struct __anonstruct_33 {
   int32_t indx ;
   uint32_t position ;
   int32_t fcc_chunk ;
   int32_t chunk_start ;
   int32_t block_start ;
   uint32_t sample_offset ;
   char name[256] ;
};
#line 420 "/root/patchweave_new/23/src/sndfile.h"
typedef struct __anonstruct_33 SF_CUE_POINT;
#line 428 "/root/patchweave_new/23/src/sndfile.h"
struct __anonstruct_34 {
   uint32_t cue_count ;
   SF_CUE_POINT cue_points[100] ;
};
#line 428 "/root/patchweave_new/23/src/sndfile.h"
typedef struct __anonstruct_34 SF_CUES;
#line 451 "/root/patchweave_new/23/src/sndfile.h"
struct __anonstruct_37 {
   int mode ;
   uint32_t start ;
   uint32_t end ;
   uint32_t count ;
};
#line 444 "/root/patchweave_new/23/src/sndfile.h"
struct __anonstruct_36 {
   int gain ;
   char basenote ;
   char detune ;
   char velocity_lo ;
   char velocity_hi ;
   char key_lo ;
   char key_hi ;
   int loop_count ;
   struct __anonstruct_37 loops[16] ;
};
#line 457 "/root/patchweave_new/23/src/sndfile.h"
typedef struct __anonstruct_36 SF_INSTRUMENT;
#line 462 "/root/patchweave_new/23/src/sndfile.h"
struct __anonstruct_38 {
   short time_sig_num ;
   short time_sig_den ;
   int loop_mode ;
   int num_beats ;
   float bpm ;
   int root_key ;
   int future[6] ;
};
#line 478 "/root/patchweave_new/23/src/sndfile.h"
typedef struct __anonstruct_38 SF_LOOP_INFO;
#line 501 "/root/patchweave_new/23/src/sndfile.h"
struct __anonstruct_39 {
   char description[256] ;
   char originator[32] ;
   char originator_reference[32] ;
   char origination_date[10] ;
   char origination_time[8] ;
   uint32_t time_reference_low ;
   uint32_t time_reference_high ;
   short version ;
   char umid[64] ;
   char reserved[190] ;
   uint32_t coding_history_size ;
   char coding_history[256] ;
};
#line 501 "/root/patchweave_new/23/src/sndfile.h"
typedef struct __anonstruct_39 SF_BROADCAST_INFO;
#line 503 "/root/patchweave_new/23/src/sndfile.h"
struct SF_CART_TIMER {
   char usage[4] ;
   int32_t value ;
};
#line 508 "/root/patchweave_new/23/src/sndfile.h"
typedef struct SF_CART_TIMER SF_CART_TIMER;
#line 535 "/root/patchweave_new/23/src/sndfile.h"
struct __anonstruct_40 {
   char version[4] ;
   char title[64] ;
   char artist[64] ;
   char cut_id[64] ;
   char client_id[64] ;
   char category[64] ;
   char classification[64] ;
   char out_cue[64] ;
   char start_date[10] ;
   char start_time[8] ;
   char end_date[10] ;
   char end_time[8] ;
   char producer_app_id[64] ;
   char producer_app_version[64] ;
   char user_def[64] ;
   int32_t level_reference ;
   SF_CART_TIMER post_timers[8] ;
   char reserved[276] ;
   char url[1024] ;
   uint32_t tag_text_size ;
   char tag_text[256] ;
};
#line 535 "/root/patchweave_new/23/src/sndfile.h"
typedef struct __anonstruct_40 SF_CART_INFO;
#line 545 "/root/patchweave_new/23/src/sndfile.h"
struct SF_VIRTUAL_IO {
   sf_count_t (*get_filelen)(void * ) ;
   sf_count_t (*seek)(sf_count_t  , int  , void * ) ;
   sf_count_t (*read)(void * , sf_count_t  , void * ) ;
   sf_count_t (*write)(void const   * , sf_count_t  , void * ) ;
   sf_count_t (*tell)(void * ) ;
};
#line 553 "/root/patchweave_new/23/src/sndfile.h"
typedef struct SF_VIRTUAL_IO SF_VIRTUAL_IO;
#line 768 "/root/patchweave_new/23/src/sndfile.h"
struct SF_CHUNK_INFO {
   char id[64] ;
   unsigned int id_size ;
   unsigned int datalen ;
   void *data ;
};
#line 775 "/root/patchweave_new/23/src/sndfile.h"
typedef struct SF_CHUNK_INFO SF_CHUNK_INFO;
#line 787
struct SF_CHUNK_ITERATOR ;
#line 787 "/root/patchweave_new/23/src/sndfile.h"
typedef struct SF_CHUNK_ITERATOR SF_CHUNK_ITERATOR;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 195 "/root/patchweave_new/23/src/common.h"
struct __anonstruct_45 {
   unsigned int kuki_offset ;
   unsigned int pakt_offset ;
   unsigned int bits_per_sample ;
   unsigned int frames_per_packet ;
   int64_t packets ;
   int64_t valid_frames ;
   int32_t priming_frames ;
   int32_t remainder_frames ;
};
#line 206 "/root/patchweave_new/23/src/common.h"
typedef struct __anonstruct_45 ALAC_DECODER_INFO;
#line 213 "/root/patchweave_new/23/src/common.h"
struct __anonstruct_46 {
   double value ;
   sf_count_t position ;
};
#line 216 "/root/patchweave_new/23/src/common.h"
typedef struct __anonstruct_46 PEAK_POS;
#line 218 "/root/patchweave_new/23/src/common.h"
struct __anonstruct_47 {
   int peak_loc ;
   unsigned int version ;
   unsigned int timestamp ;
   unsigned int edit_number ;
   PEAK_POS peaks[] ;
};
#line 231 "/root/patchweave_new/23/src/common.h"
typedef struct __anonstruct_47 PEAK_INFO;
#line 238 "/root/patchweave_new/23/src/common.h"
struct __anonstruct_48 {
   int type ;
   int flags ;
   size_t offset ;
};
#line 242 "/root/patchweave_new/23/src/common.h"
typedef struct __anonstruct_48 STR_DATA;
#line 244 "/root/patchweave_new/23/src/common.h"
struct __anonstruct_49 {
   uint64_t hash ;
   char id[64] ;
   unsigned int id_size ;
   uint32_t mark32 ;
   sf_count_t offset ;
   uint32_t len ;
};
#line 251 "/root/patchweave_new/23/src/common.h"
typedef struct __anonstruct_49 READ_CHUNK;
#line 253 "/root/patchweave_new/23/src/common.h"
struct __anonstruct_50 {
   uint64_t hash ;
   uint32_t mark32 ;
   uint32_t len ;
   void *data ;
};
#line 258 "/root/patchweave_new/23/src/common.h"
typedef struct __anonstruct_50 WRITE_CHUNK;
#line 260 "/root/patchweave_new/23/src/common.h"
struct __anonstruct_51 {
   uint32_t count ;
   uint32_t used ;
   READ_CHUNK *chunks ;
};
#line 264 "/root/patchweave_new/23/src/common.h"
typedef struct __anonstruct_51 READ_CHUNKS;
#line 265 "/root/patchweave_new/23/src/common.h"
struct __anonstruct_52 {
   uint32_t count ;
   uint32_t used ;
   WRITE_CHUNK *chunks ;
};
#line 269 "/root/patchweave_new/23/src/common.h"
typedef struct __anonstruct_52 WRITE_CHUNKS;
#line 271 "/root/patchweave_new/23/src/common.h"
struct SF_CHUNK_ITERATOR {
   uint32_t current ;
   int64_t hash ;
   char id[64] ;
   unsigned int id_size ;
   SNDFILE *sndfile ;
};
#line 289 "/root/patchweave_new/23/src/common.h"
struct __anonstruct_53 {
   char description[256] ;
   char originator[32] ;
   char originator_reference[32] ;
   char origination_date[10] ;
   char origination_time[8] ;
   uint32_t time_reference_low ;
   uint32_t time_reference_high ;
   short version ;
   char umid[64] ;
   char reserved[190] ;
   uint32_t coding_history_size ;
   char coding_history[16384] ;
};
#line 289 "/root/patchweave_new/23/src/common.h"
typedef struct __anonstruct_53 SF_BROADCAST_INFO_16K;
#line 291 "/root/patchweave_new/23/src/common.h"
struct __anonstruct_54 {
   char version[4] ;
   char title[64] ;
   char artist[64] ;
   char cut_id[64] ;
   char client_id[64] ;
   char category[64] ;
   char classification[64] ;
   char out_cue[64] ;
   char start_date[10] ;
   char start_time[8] ;
   char end_date[10] ;
   char end_time[8] ;
   char producer_app_id[64] ;
   char producer_app_version[64] ;
   char user_def[64] ;
   int32_t level_reference ;
   SF_CART_TIMER post_timers[8] ;
   char reserved[276] ;
   char url[1024] ;
   uint32_t tag_text_size ;
   char tag_text[16384] ;
};
#line 291 "/root/patchweave_new/23/src/common.h"
typedef struct __anonstruct_54 SF_CART_INFO_16K;
#line 296 "/root/patchweave_new/23/src/common.h"
typedef int16_t sfwchar_t;
#line 323 "/root/patchweave_new/23/src/common.h"
union __anonunion_56 {
   char c[1024] ;
   sfwchar_t wc[1024] ;
};
#line 328 "/root/patchweave_new/23/src/common.h"
union __anonunion_57 {
   char c[1024] ;
   sfwchar_t wc[1024] ;
};
#line 333 "/root/patchweave_new/23/src/common.h"
union __anonunion_58 {
   char c[256] ;
   sfwchar_t wc[256] ;
};
#line 321 "/root/patchweave_new/23/src/common.h"
struct __anonstruct_55 {
   union __anonunion_56 path ;
   union __anonunion_57 dir ;
   union __anonunion_58 name ;
   int filedes ;
   int savedes ;
   int do_not_close_descriptor ;
   int mode ;
};
#line 353 "/root/patchweave_new/23/src/common.h"
typedef struct __anonstruct_55 PSF_FILE;
#line 357 "/root/patchweave_new/23/src/common.h"
union __anonunion_59 {
   double dbuf[1024] ;
   int64_t lbuf[1024] ;
   float fbuf[2048] ;
   int ibuf[2048] ;
   short sbuf[4096] ;
   char cbuf[8192] ;
   signed char scbuf[8192] ;
   unsigned char ucbuf[8192] ;
};
#line 370 "/root/patchweave_new/23/src/common.h"
typedef union __anonunion_59 BUF_UNION;
#line 377 "/root/patchweave_new/23/src/common.h"
union __anonunion_60 {
   double d[2] ;
   char c[16] ;
};
#line 390 "/root/patchweave_new/23/src/common.h"
struct __anonstruct_61 {
   char buf[2048] ;
   int indx ;
};
#line 396 "/root/patchweave_new/23/src/common.h"
struct __anonstruct_62 {
   unsigned char *ptr ;
   sf_count_t indx ;
   sf_count_t end ;
   sf_count_t len ;
};
#line 406 "/root/patchweave_new/23/src/common.h"
struct __anonstruct_63 {
   STR_DATA data[32] ;
   char *storage ;
   size_t storage_len ;
   size_t storage_used ;
   uint32_t flags ;
};
#line 374 "/root/patchweave_new/23/src/common.h"
struct sf_private_tag {
   union __anonunion_60 canary ;
   PSF_FILE file ;
   PSF_FILE rsrc ;
   char syserr[256] ;
   struct __anonstruct_61 parselog ;
   struct __anonstruct_62 header ;
   int rwf_endian ;
   struct __anonstruct_63 strings ;
   int Magick ;
   unsigned int unique_id ;
   int error ;
   int endian ;
   int data_endswap ;
   int float_int_mult ;
   float float_max ;
   int scale_int_float ;
   int is_pipe ;
   sf_count_t pipeoffset ;
   int add_clipping ;
   SF_INFO sf ;
   int have_written ;
   PEAK_INFO *peak_info ;
   SF_CUES *cues ;
   SF_LOOP_INFO *loop_info ;
   SF_INSTRUMENT *instrument ;
   SF_BROADCAST_INFO_16K *broadcast_16k ;
   SF_CART_INFO_16K *cart_16k ;
   int *channel_map ;
   sf_count_t filelength ;
   sf_count_t fileoffset ;
   sf_count_t rsrclength ;
   sf_count_t dataoffset ;
   sf_count_t datalength ;
   sf_count_t dataend ;
   int blockwidth ;
   int bytewidth ;
   void *dither ;
   void *interleave ;
   int last_op ;
   sf_count_t read_current ;
   sf_count_t write_current ;
   void *container_data ;
   void *codec_data ;
   SF_DITHER_INFO write_dither ;
   SF_DITHER_INFO read_dither ;
   int norm_double ;
   int norm_float ;
   int auto_header ;
   int ieee_replace ;
   sf_count_t (*read_short)(struct sf_private_tag * , short * , sf_count_t  ) ;
   sf_count_t (*read_int)(struct sf_private_tag * , int * , sf_count_t  ) ;
   sf_count_t (*read_float)(struct sf_private_tag * , float * , sf_count_t  ) ;
   sf_count_t (*read_double)(struct sf_private_tag * , double * , sf_count_t  ) ;
   sf_count_t (*write_short)(struct sf_private_tag * , short const   * , sf_count_t  ) ;
   sf_count_t (*write_int)(struct sf_private_tag * , int const   * , sf_count_t  ) ;
   sf_count_t (*write_float)(struct sf_private_tag * , float const   * , sf_count_t  ) ;
   sf_count_t (*write_double)(struct sf_private_tag * , double const   * , sf_count_t  ) ;
   sf_count_t (*seek)(struct sf_private_tag * , int  , sf_count_t  ) ;
   int (*write_header)(struct sf_private_tag * , int  ) ;
   int (*command)(struct sf_private_tag * , int  , void * , int  ) ;
   int (*byterate)(struct sf_private_tag * ) ;
   int (*codec_close)(struct sf_private_tag * ) ;
   int (*container_close)(struct sf_private_tag * ) ;
   char *format_desc ;
   int virtual_io ;
   SF_VIRTUAL_IO vio ;
   void *vio_user_data ;
   SF_CHUNK_ITERATOR *iterator ;
   READ_CHUNKS rchunks ;
   WRITE_CHUNKS wchunks ;
   int (*set_chunk)(struct sf_private_tag * , SF_CHUNK_INFO * ) ;
   SF_CHUNK_ITERATOR *(*next_chunk_iterator)(struct sf_private_tag * , SF_CHUNK_ITERATOR * ) ;
   int (*get_chunk_size)(struct sf_private_tag * , SF_CHUNK_ITERATOR * , SF_CHUNK_INFO * ) ;
   int (*get_chunk_data)(struct sf_private_tag * , SF_CHUNK_ITERATOR * , SF_CHUNK_INFO * ) ;
};
#line 538 "/root/patchweave_new/23/src/common.h"
typedef struct sf_private_tag SF_PRIVATE;
#line 1012 "/root/patchweave_new/23/src/common.h"
struct __anonstruct_65 {
   int channels ;
   int endianness ;
};
#line 1015 "/root/patchweave_new/23/src/common.h"
typedef struct __anonstruct_65 AUDIO_DETECT;
#line 26 "/root/patchweave_new/23/src/ima_oki_adpcm.h"
struct __anonstruct_67 {
   int mask ;
   int last_output ;
   int step_index ;
   int max_step_index ;
   int const   *steps ;
   int errors ;
   int code_count ;
   int pcm_count ;
   unsigned char codes[256] ;
   short pcm[512] ;
};
#line 41 "/root/patchweave_new/23/src/ima_oki_adpcm.h"
typedef struct __anonstruct_67 IMA_OKI_ADPCM;
#line 43
enum __anonenum__68 {
    IMA_OKI_ADPCM_TYPE_IMA = 0,
    IMA_OKI_ADPCM_TYPE_OKI = 1
} ;
#line 46 "/root/patchweave_new/23/src/ima_oki_adpcm.h"
typedef enum __anonenum__68 IMA_OKI_ADPCM_TYPE;
#line 31 "/root/patchweave_new/23/src/pcm.c"
typedef void tribyte;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 23 "/usr/include/ogg/config_types.h"
typedef int64_t ogg_int64_t;
#line 31 "/usr/include/ogg/ogg.h"
struct __anonstruct_292 {
   long endbyte ;
   int endbit ;
   unsigned char *buffer ;
   unsigned char *ptr ;
   long storage ;
};
#line 38 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_292 oggpack_buffer;
#line 42 "/usr/include/ogg/ogg.h"
struct __anonstruct_293 {
   unsigned char *header ;
   long header_len ;
   unsigned char *body ;
   long body_len ;
};
#line 47 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_293 ogg_page;
#line 52 "/usr/include/ogg/ogg.h"
struct __anonstruct_294 {
   unsigned char *body_data ;
   long body_storage ;
   long body_fill ;
   long body_returned ;
   int *lacing_vals ;
   ogg_int64_t *granule_vals ;
   long lacing_storage ;
   long lacing_fill ;
   long lacing_packet ;
   long lacing_returned ;
   unsigned char header[282] ;
   int header_fill ;
   int e_o_s ;
   int b_o_s ;
   long serialno ;
   long pageno ;
   ogg_int64_t packetno ;
   ogg_int64_t granulepos ;
};
#line 84 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_294 ogg_stream_state;
#line 89 "/usr/include/ogg/ogg.h"
struct __anonstruct_295 {
   unsigned char *packet ;
   long bytes ;
   long b_o_s ;
   long e_o_s ;
   ogg_int64_t granulepos ;
   ogg_int64_t packetno ;
};
#line 102 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_295 ogg_packet;
#line 104 "/usr/include/ogg/ogg.h"
struct __anonstruct_296 {
   unsigned char *data ;
   int storage ;
   int fill ;
   int returned ;
   int unsynced ;
   int headerbytes ;
   int bodybytes ;
};
#line 113 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_296 ogg_sync_state;
#line 31 "/root/patchweave_new/23/src/ogg.h"
struct __anonstruct_298 {
   ogg_sync_state osync ;
   ogg_stream_state ostream ;
   ogg_page opage ;
   ogg_packet opacket ;
   int eos ;
   int codec ;
};
#line 42 "/root/patchweave_new/23/src/ogg.h"
typedef struct __anonstruct_298 OGG_PRIVATE;
#line 203 "/root/patchweave_new/23/src/ogg.c"
struct __anonstruct_299 {
   char const   *str ;
   char const   *name ;
   int len ;
   int codec ;
};
#line 196 "/root/patchweave_new/23/src/wavlike.h"
struct __anonstruct_300 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
};
#line 203 "/root/patchweave_new/23/src/wavlike.h"
typedef struct __anonstruct_300 MIN_WAV_FMT;
#line 205 "/root/patchweave_new/23/src/wavlike.h"
struct __anonstruct_301 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short dummy ;
};
#line 214 "/root/patchweave_new/23/src/wavlike.h"
typedef struct __anonstruct_301 WAV_FMT_SIZE20;
#line 226 "/root/patchweave_new/23/src/wavlike.h"
struct __anonstruct_303 {
   short coeff1 ;
   short coeff2 ;
};
#line 216 "/root/patchweave_new/23/src/wavlike.h"
struct __anonstruct_302 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short samplesperblock ;
   unsigned short numcoeffs ;
   struct __anonstruct_303 coeffs[7] ;
};
#line 230 "/root/patchweave_new/23/src/wavlike.h"
typedef struct __anonstruct_302 MS_ADPCM_WAV_FMT;
#line 232 "/root/patchweave_new/23/src/wavlike.h"
struct __anonstruct_304 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short samplesperblock ;
};
#line 241 "/root/patchweave_new/23/src/wavlike.h"
typedef struct __anonstruct_304 IMA_ADPCM_WAV_FMT;
#line 243 "/root/patchweave_new/23/src/wavlike.h"
struct __anonstruct_305 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short auxblocksize ;
};
#line 252 "/root/patchweave_new/23/src/wavlike.h"
typedef struct __anonstruct_305 G72x_ADPCM_WAV_FMT;
#line 255 "/root/patchweave_new/23/src/wavlike.h"
struct __anonstruct_306 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short samplesperblock ;
};
#line 264 "/root/patchweave_new/23/src/wavlike.h"
typedef struct __anonstruct_306 GSM610_WAV_FMT;
#line 266 "/root/patchweave_new/23/src/wavlike.h"
struct __anonstruct_307 {
   unsigned int esf_field1 ;
   unsigned short esf_field2 ;
   unsigned short esf_field3 ;
   char esf_field4[8] ;
};
#line 271 "/root/patchweave_new/23/src/wavlike.h"
typedef struct __anonstruct_307 EXT_SUBFORMAT;
#line 273 "/root/patchweave_new/23/src/wavlike.h"
struct __anonstruct_308 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short validbits ;
   unsigned int channelmask ;
   EXT_SUBFORMAT esf ;
};
#line 284 "/root/patchweave_new/23/src/wavlike.h"
typedef struct __anonstruct_308 EXTENSIBLE_WAV_FMT;
#line 286 "/root/patchweave_new/23/src/wavlike.h"
union __anonunion_309 {
   unsigned short format ;
   MIN_WAV_FMT min ;
   IMA_ADPCM_WAV_FMT ima ;
   MS_ADPCM_WAV_FMT msadpcm ;
   G72x_ADPCM_WAV_FMT g72x ;
   EXTENSIBLE_WAV_FMT ext ;
   GSM610_WAV_FMT gsm610 ;
   WAV_FMT_SIZE20 size20 ;
   char padding[512] ;
};
#line 296 "/root/patchweave_new/23/src/wavlike.h"
typedef union __anonunion_309 WAV_FMT;
#line 298 "/root/patchweave_new/23/src/wavlike.h"
struct __anonstruct_310 {
   int frames ;
};
#line 300 "/root/patchweave_new/23/src/wavlike.h"
typedef struct __anonstruct_310 FACT_CHUNK;
#line 302 "/root/patchweave_new/23/src/wavlike.h"
struct __anonstruct_311 {
   int wavex_ambisonic ;
   unsigned int wavex_channelmask ;
   int fmt_is_broken ;
   WAV_FMT wav_fmt ;
   int rf64_downgrade ;
};
#line 316 "/root/patchweave_new/23/src/wavlike.h"
typedef struct __anonstruct_311 WAVLIKE_PRIVATE;
#line 32 "/root/patchweave_new/23/src/ms_adpcm.c"
struct __anonstruct_312 {
   int channels ;
   int blocksize ;
   int samplesperblock ;
   int blocks ;
   int dataremaining ;
   int blockcount ;
   int sync_error ;
   sf_count_t samplecount ;
   short *samples ;
   unsigned char *block ;
   short dummydata[] ;
};
#line 40 "/root/patchweave_new/23/src/ms_adpcm.c"
typedef struct __anonstruct_312 MSADPCM_PRIVATE;
#line 28 "/root/patchweave_new/23/src/interleave.c"
struct __anonstruct_377 {
   double buffer[1024] ;
   sf_count_t channel_len ;
   sf_count_t (*read_short)(SF_PRIVATE * , short * , sf_count_t  ) ;
   sf_count_t (*read_int)(SF_PRIVATE * , int * , sf_count_t  ) ;
   sf_count_t (*read_float)(SF_PRIVATE * , float * , sf_count_t  ) ;
   sf_count_t (*read_double)(SF_PRIVATE * , double * , sf_count_t  ) ;
};
#line 38 "/root/patchweave_new/23/src/interleave.c"
typedef struct __anonstruct_377 INTERLEAVE_DATA;
#line 30 "/root/patchweave_new/23/src/ima_adpcm.c"
struct IMA_ADPCM_PRIVATE_tag {
   int (*decode_block)(SF_PRIVATE * , struct IMA_ADPCM_PRIVATE_tag * ) ;
   int (*encode_block)(SF_PRIVATE * , struct IMA_ADPCM_PRIVATE_tag * ) ;
   int channels ;
   int blocksize ;
   int samplesperblock ;
   int blocks ;
   int blockcount ;
   int samplecount ;
   int previous[2] ;
   int stepindx[2] ;
   unsigned char *block ;
   short *samples ;
   short data[] ;
};
#line 41 "/root/patchweave_new/23/src/ima_adpcm.c"
typedef struct IMA_ADPCM_PRIVATE_tag IMA_ADPCM_PRIVATE;
#line 16 "/root/patchweave_new/23/src/GSM610/gsm.h"
struct gsm_state ;
#line 16 "/root/patchweave_new/23/src/GSM610/gsm.h"
typedef struct gsm_state *gsm;
#line 17 "/root/patchweave_new/23/src/GSM610/gsm.h"
typedef short gsm_signal;
#line 18 "/root/patchweave_new/23/src/GSM610/gsm.h"
typedef unsigned char gsm_byte;
#line 35 "/root/patchweave_new/23/src/gsm610.c"
struct gsm610_tag {
   int blocks ;
   int blockcount ;
   int samplecount ;
   int samplesperblock ;
   int blocksize ;
   int (*decode_block)(SF_PRIVATE * , struct gsm610_tag * ) ;
   int (*encode_block)(SF_PRIVATE * , struct gsm610_tag * ) ;
   short samples[320] ;
   unsigned char block[65] ;
   gsm gsm_data ;
};
#line 48 "/root/patchweave_new/23/src/gsm610.c"
typedef struct gsm610_tag GSM610_PRIVATE;
#line 410 "/root/patchweave_new/23/src/float32.c"
union __anonunion_506 {
   float f ;
   int i ;
   unsigned char c[4] ;
};
#line 44 "/root/patchweave_new/23/src/dwvw.c"
struct __anonstruct_555 {
   int index ;
   int end ;
   unsigned char buffer[256] ;
};
#line 40 "/root/patchweave_new/23/src/dwvw.c"
struct __anonstruct_67___0 {
   int bit_width ;
   int dwm_maxsize ;
   int max_delta ;
   int span ;
   int samplecount ;
   int bit_count ;
   int bits ;
   int last_delta_width ;
   int last_sample ;
   struct __anonstruct_555 b ;
};
#line 48 "/root/patchweave_new/23/src/dwvw.c"
typedef struct __anonstruct_67___0 DWVW_PRIVATE;
#line 459 "/root/patchweave_new/23/src/double64.c"
union __anonunion_556 {
   double d ;
   unsigned char c[8] ;
};
#line 59 "/root/patchweave_new/23/src/dither.c"
struct __anonstruct_622 {
   int read_short_dither_bits ;
   int read_int_dither_bits ;
   int write_short_dither_bits ;
   int write_int_dither_bits ;
   double read_float_dither_scale ;
   double read_double_dither_bits ;
   double write_float_dither_scale ;
   double write_double_dither_bits ;
   sf_count_t (*read_short)(SF_PRIVATE * , short * , sf_count_t  ) ;
   sf_count_t (*read_int)(SF_PRIVATE * , int * , sf_count_t  ) ;
   sf_count_t (*read_float)(SF_PRIVATE * , float * , sf_count_t  ) ;
   sf_count_t (*read_double)(SF_PRIVATE * , double * , sf_count_t  ) ;
   sf_count_t (*write_short)(SF_PRIVATE * , short const   * , sf_count_t  ) ;
   sf_count_t (*write_int)(SF_PRIVATE * , int const   * , sf_count_t  ) ;
   sf_count_t (*write_float)(SF_PRIVATE * , float const   * , sf_count_t  ) ;
   sf_count_t (*write_double)(SF_PRIVATE * , double const   * , sf_count_t  ) ;
   double buffer[1024] ;
};
#line 76 "/root/patchweave_new/23/src/dither.c"
typedef struct __anonstruct_622 DITHER_DATA;
#line 1241 "/root/patchweave_new/23/src/common.c"
struct __anonstruct_693 {
   uint32_t cue_count ;
   SF_CUE_POINT cue_points[0] ;
};
#line 1241 "/root/patchweave_new/23/src/common.c"
typedef struct __anonstruct_693 SF_CUES_0;
#line 158 "/root/patchweave_new/23/src/chunk.c"
union __anonunion_740 {
   uint32_t marker ;
   char str[5] ;
};
#line 195 "/root/patchweave_new/23/src/chunk.c"
union __anonunion_741 {
   uint32_t marker ;
   char str[5] ;
};
#line 219 "/root/patchweave_new/23/src/chunk.c"
union __anonunion_742 {
   uint32_t marker ;
   char str[5] ;
};
#line 19 "/root/patchweave_new/23/src/chanmap.h"
struct __anonstruct_786 {
   int channel_layout_tag ;
   int const   *channel_map ;
   char const   *name ;
};
#line 27 "/root/patchweave_new/23/src/chanmap.h"
typedef struct __anonstruct_786 AIFF_CAF_CHANNEL_MAP;
#line 208 "/root/patchweave_new/23/src/chanmap.c"
struct __anonstruct_787 {
   AIFF_CAF_CHANNEL_MAP *map ;
   int len ;
};
#line 211 "/root/patchweave_new/23/src/chanmap.c"
typedef struct __anonstruct_787 MAP_MAP;
#line 34 "/root/patchweave_new/23/src/audio_detect.c"
struct __anonstruct_848 {
   int le_float ;
   int be_float ;
   int le_int_24_32 ;
   int be_int_24_32 ;
};
#line 39 "/root/patchweave_new/23/src/audio_detect.c"
typedef struct __anonstruct_848 VOTE;
#line 88 "/root/patchweave_new/23/src/ALAC/ALACAudioTypes.h"
typedef uint32_t ALACChannelLayoutTag;
#line 109 "/root/patchweave_new/23/src/ALAC/ALACAudioTypes.h"
typedef double alac_float64_t;
#line 138 "/root/patchweave_new/23/src/ALAC/ALACAudioTypes.h"
struct ALACAudioChannelLayout {
   ALACChannelLayoutTag mChannelLayoutTag ;
   uint32_t mChannelBitmap ;
   uint32_t mNumberChannelDescriptions ;
};
#line 143 "/root/patchweave_new/23/src/ALAC/ALACAudioTypes.h"
typedef struct ALACAudioChannelLayout ALACAudioChannelLayout;
#line 145 "/root/patchweave_new/23/src/ALAC/ALACAudioTypes.h"
struct AudioFormatDescription {
   alac_float64_t mSampleRate ;
   uint32_t mFormatID ;
   uint32_t mFormatFlags ;
   uint32_t mBytesPerPacket ;
   uint32_t mFramesPerPacket ;
   uint32_t mBytesPerFrame ;
   uint32_t mChannelsPerFrame ;
   uint32_t mBitsPerChannel ;
   uint32_t mReserved ;
};
#line 157 "/root/patchweave_new/23/src/ALAC/ALACAudioTypes.h"
typedef struct AudioFormatDescription AudioFormatDescription;
#line 171 "/root/patchweave_new/23/src/ALAC/ALACAudioTypes.h"
struct ALACSpecificConfig {
   uint32_t frameLength ;
   uint8_t compatibleVersion ;
   uint8_t bitDepth ;
   uint8_t pb ;
   uint8_t mb ;
   uint8_t kb ;
   uint8_t numChannels ;
   uint16_t maxRun ;
   uint32_t maxFrameBytes ;
   uint32_t avgBitRate ;
   uint32_t sampleRate ;
};
#line 185 "/root/patchweave_new/23/src/ALAC/ALACAudioTypes.h"
typedef struct ALACSpecificConfig ALACSpecificConfig;
#line 35 "/root/patchweave_new/23/src/ALAC/alac_codec.h"
struct BitBuffer ;
#line 47 "/root/patchweave_new/23/src/ALAC/alac_codec.h"
union __anonunion_899 {
   int32_t mPredictor[4096] ;
   uint16_t mShiftBuffer[4096] ;
};
#line 37 "/root/patchweave_new/23/src/ALAC/alac_codec.h"
struct alac_decoder_s {
   ALACSpecificConfig mConfig ;
   uint16_t mActiveElements ;
   int32_t mMixBufferU[4096] ;
   int32_t mMixBufferV[4096] ;
   union __anonunion_899 __annonCompField3 ;
   int32_t mPredictor[4096] ;
   uint16_t mShiftBuffer[4096] ;
   uint32_t mNumChannels ;
};
#line 53 "/root/patchweave_new/23/src/ALAC/alac_codec.h"
typedef struct alac_decoder_s ALAC_DECODER;
#line 55 "/root/patchweave_new/23/src/ALAC/alac_codec.h"
struct alac_encoder_s {
   int16_t mBitDepth ;
   int16_t mLastMixRes[8] ;
   int32_t mFastMode ;
   int32_t mMixBufferU[4096] ;
   int32_t mMixBufferV[4096] ;
   int32_t mPredictorU[4096] ;
   int32_t mPredictorV[4096] ;
   uint16_t mShiftBufferUV[8192] ;
   uint8_t mWorkBuffer[16384] ;
   int16_t mCoefsU[8][16][16] ;
   int16_t mCoefsV[8][16][16] ;
   uint32_t mTotalBytesGenerated ;
   uint32_t mAvgBitRate ;
   uint32_t mMaxFrameBytes ;
   uint32_t mFrameSize ;
   uint32_t mMaxOutputBytes ;
   uint32_t mNumChannels ;
   uint32_t mOutputSampleRate ;
};
#line 85 "/root/patchweave_new/23/src/ALAC/alac_codec.h"
typedef struct alac_encoder_s ALAC_ENCODER;
#line 61 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.h"
struct BitBuffer {
   uint8_t *cur ;
   uint8_t *end ;
   uint32_t bitIndex ;
   uint32_t byteSize ;
};
#line 68 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.h"
typedef struct BitBuffer BitBuffer;
#line 37 "/root/patchweave_new/23/src/alac.c"
struct __anonstruct_902 {
   uint32_t current ;
   uint32_t count ;
   uint32_t allocated ;
   uint32_t packet_size[] ;
};
#line 40 "/root/patchweave_new/23/src/alac.c"
typedef struct __anonstruct_902 PAKT_INFO;
#line 56 "/root/patchweave_new/23/src/alac.c"
union __anonunion_904 {
   ALAC_DECODER decoder ;
   ALAC_ENCODER encoder ;
};
#line 42 "/root/patchweave_new/23/src/alac.c"
struct __anonstruct_903 {
   sf_count_t input_data_pos ;
   PAKT_INFO *pakt_info ;
   int channels ;
   int final_write_block ;
   uint32_t frames_this_block ;
   uint32_t partial_block_frames ;
   uint32_t frames_per_block ;
   uint32_t bits_per_sample ;
   uint32_t kuki_size ;
   union __anonunion_904 __annonCompField4 ;
   ALAC_DECODER decoder ;
   ALAC_ENCODER encoder ;
   char enctmpname[512] ;
   FILE *enctmp ;
   uint8_t byte_buffer[1048576] ;
   int buffer[] ;
};
#line 68 "/root/patchweave_new/23/src/alac.c"
typedef struct __anonstruct_903 ALAC_PRIVATE;
#line 241 "/root/patchweave_new/23/src/alac.c"
union __anonunion_905 {
   uint8_t kuki[512] ;
   uint32_t alignment ;
};
#line 57 "/root/patchweave_new/23/src/ALAC/aglib.h"
struct AGParamRec {
   uint32_t mb ;
   uint32_t mb0 ;
   uint32_t pb ;
   uint32_t kb ;
   uint32_t wb ;
   uint32_t qb ;
   uint32_t fw ;
   uint32_t sw ;
   uint32_t maxrun ;
};
#line 66 "/root/patchweave_new/23/src/ALAC/aglib.h"
typedef struct AGParamRec AGParamRec;
#line 66 "/root/patchweave_new/23/src/ALAC/aglib.h"
typedef struct AGParamRec *AGParamRecPtr;
#line 47 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
enum __anonenum__946 {
    false = 0,
    true = 1
} ;
#line 51 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
typedef enum __anonenum__946 bool;
#line 64 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
typedef int16_t (*SearchCoefs)[16];
#line 64 "/root/patchweave_new/23/src/G72x/g72x.h"
struct g72x_state ;
#line 44 "/root/patchweave_new/23/src/G72x/g72x_priv.h"
struct g72x_state {
   long yl ;
   short yu ;
   short dms ;
   short dml ;
   short ap ;
   short a[2] ;
   short b[6] ;
   short pk[2] ;
   short dq[6] ;
   short sr[2] ;
   char td ;
   int (*encoder)(int  , struct g72x_state * ) ;
   int (*decoder)(int  , struct g72x_state * ) ;
   int codec_bits ;
   int blocksize ;
   int samplesperblock ;
};
#line 81 "/root/patchweave_new/23/src/G72x/g72x_priv.h"
typedef struct g72x_state G72x_STATE;
#line 28 "/root/patchweave_new/23/src/GSM610/gsm610_priv.h"
struct gsm_state {
   int16_t dp0[280] ;
   int16_t z1 ;
   int32_t L_z2 ;
   int mp ;
   int16_t u[8] ;
   int16_t LARpp[2][8] ;
   int16_t j ;
   int16_t ltp_cut ;
   int16_t nrp ;
   int16_t v[9] ;
   int16_t msr ;
   char verbose ;
   char fast ;
   char wav_fmt ;
   unsigned char frame_index ;
   unsigned char frame_chain ;
   int16_t e[50] ;
};
#line 27 "/usr/include/vorbis/codec.h"
struct vorbis_info {
   int version ;
   int channels ;
   long rate ;
   long bitrate_upper ;
   long bitrate_nominal ;
   long bitrate_lower ;
   long bitrate_window ;
   void *codec_setup ;
};
#line 53 "/usr/include/vorbis/codec.h"
typedef struct vorbis_info vorbis_info;
#line 58 "/usr/include/vorbis/codec.h"
struct vorbis_dsp_state {
   int analysisp ;
   vorbis_info *vi ;
   float **pcm ;
   float **pcmret ;
   int pcm_storage ;
   int pcm_current ;
   int pcm_returned ;
   int preextrapolate ;
   int eofflag ;
   long lW ;
   long W ;
   long nW ;
   long centerW ;
   ogg_int64_t granulepos ;
   ogg_int64_t sequence ;
   ogg_int64_t glue_bits ;
   ogg_int64_t time_bits ;
   ogg_int64_t floor_bits ;
   ogg_int64_t res_bits ;
   void *backend_state ;
};
#line 85 "/usr/include/vorbis/codec.h"
typedef struct vorbis_dsp_state vorbis_dsp_state;
#line 109
struct alloc_chain ;
#line 87 "/usr/include/vorbis/codec.h"
struct vorbis_block {
   float **pcm ;
   oggpack_buffer opb ;
   long lW ;
   long W ;
   long nW ;
   int pcmend ;
   int mode ;
   int eofflag ;
   ogg_int64_t granulepos ;
   ogg_int64_t sequence ;
   vorbis_dsp_state *vd ;
   void *localstore ;
   long localtop ;
   long localalloc ;
   long totaluse ;
   struct alloc_chain *reap ;
   long glue_bits ;
   long time_bits ;
   long floor_bits ;
   long res_bits ;
   void *internal ;
};
#line 119 "/usr/include/vorbis/codec.h"
typedef struct vorbis_block vorbis_block;
#line 126 "/usr/include/vorbis/codec.h"
struct alloc_chain {
   void *ptr ;
   struct alloc_chain *next ;
};
#line 139 "/usr/include/vorbis/codec.h"
struct vorbis_comment {
   char **user_comments ;
   int *comment_lengths ;
   int comments ;
   char *vendor ;
};
#line 147 "/usr/include/vorbis/codec.h"
typedef struct vorbis_comment vorbis_comment;
#line 79 "/root/patchweave_new/23/src/ogg_vorbis.c"
typedef int convert_func(SF_PRIVATE * , int  , void * , int  , int  , float ** );
#line 98 "/root/patchweave_new/23/src/ogg_vorbis.c"
struct __anonstruct_1053 {
   int id ;
   char const   *name ;
};
#line 101 "/root/patchweave_new/23/src/ogg_vorbis.c"
typedef struct __anonstruct_1053 STR_PAIRS;
#line 116 "/root/patchweave_new/23/src/ogg_vorbis.c"
struct __anonstruct_1054 {
   sf_count_t loc ;
   vorbis_info vinfo ;
   vorbis_comment vcomment ;
   vorbis_dsp_state vdsp ;
   vorbis_block vblock ;
   double quality ;
};
#line 130 "/root/patchweave_new/23/src/ogg_vorbis.c"
typedef struct __anonstruct_1054 VORBIS_PRIVATE;
#line 921 "/root/patchweave_new/23/src/ogg_vorbis.c"
struct __anonstruct_1055 {
   int isillegal ;
   int shownillegal ;
   int isnew ;
   int end ;
   uint32_t serial ;
   ogg_stream_state ostream ;
   vorbis_info vinfo ;
   vorbis_comment vcomment ;
   sf_count_t lastgranulepos ;
   int doneheaders ;
};
#line 935 "/root/patchweave_new/23/src/ogg_vorbis.c"
typedef struct __anonstruct_1055 stream_processor;
#line 937 "/root/patchweave_new/23/src/ogg_vorbis.c"
struct __anonstruct_1056 {
   stream_processor *streams ;
   int allocated ;
   int used ;
   int in_headers ;
};
#line 943 "/root/patchweave_new/23/src/ogg_vorbis.c"
typedef struct __anonstruct_1056 stream_set;
#line 38 "/root/patchweave_new/23/src/xi.c"
struct __anonstruct_1118 {
   char filename[22] ;
   char software[20] ;
   char sample_name[22] ;
   int loop_begin ;
   int loop_end ;
   int sample_flags ;
   short last_16 ;
};
#line 49 "/root/patchweave_new/23/src/xi.c"
typedef struct __anonstruct_1118 XI_PRIVATE;
#line 87 "/root/patchweave_new/23/src/wavlike.c"
struct chanmap_s {
   int id ;
   char const   *name ;
};
#line 549 "/root/patchweave_new/23/src/wavlike.c"
struct __anonstruct_1239 {
   int ID ;
   char const   *name ;
};
#line 552 "/root/patchweave_new/23/src/wavlike.c"
typedef struct __anonstruct_1239 WAV_FORMAT_DESC;
#line 57 "/root/patchweave_new/23/src/voc.c"
struct __anonstruct_1251 {
   int samples ;
   int offset ;
};
#line 60 "/root/patchweave_new/23/src/voc.c"
typedef struct __anonstruct_1251 SND_DATA_BLOCKS;
#line 62 "/root/patchweave_new/23/src/voc.c"
struct __anonstruct_1252 {
   unsigned int sections ;
   unsigned int section_types ;
   int samplerate ;
   int channels ;
   int bitwidth ;
   SND_DATA_BLOCKS blocks[200] ;
};
#line 66 "/root/patchweave_new/23/src/voc.c"
typedef struct __anonstruct_1252 VOC_DATA;
#line 54 "/root/patchweave_new/23/src/svx.c"
struct __anonstruct_1315 {
   unsigned int oneShotHiSamples ;
   unsigned int repeatHiSamples ;
   unsigned int samplesPerHiCycle ;
   unsigned short samplesPerSec ;
   unsigned char octave ;
   unsigned char compression ;
   unsigned int volume ;
};
#line 59 "/root/patchweave_new/23/src/svx.c"
typedef struct __anonstruct_1315 VHDR_CHUNK;
#line 47 "/root/patchweave_new/23/src/sds.c"
struct tag_SDS_PRIVATE {
   int bitwidth ;
   int frames ;
   int samplesperblock ;
   int total_blocks ;
   int (*reader)(SF_PRIVATE * , struct tag_SDS_PRIVATE * ) ;
   int (*writer)(SF_PRIVATE * , struct tag_SDS_PRIVATE * ) ;
   int read_block ;
   int read_count ;
   unsigned char read_data[127] ;
   int read_samples[63] ;
   int write_block ;
   int write_count ;
   int total_written ;
   unsigned char write_data[127] ;
   int write_samples[63] ;
};
#line 62 "/root/patchweave_new/23/src/sds.c"
typedef struct tag_SDS_PRIVATE SDS_PRIVATE;
#line 58 "/root/patchweave_new/23/src/sd2.c"
struct __anonstruct_1359 {
   unsigned char *rsrc_data ;
   int rsrc_len ;
   int need_to_free_rsrc_data ;
   int data_offset ;
   int data_length ;
   int map_offset ;
   int map_length ;
   int type_count ;
   int type_offset ;
   int item_offset ;
   int str_index ;
   int str_count ;
   int string_offset ;
   int sample_size ;
   int sample_rate ;
   int channels ;
};
#line 75 "/root/patchweave_new/23/src/sd2.c"
typedef struct __anonstruct_1359 SD2_RSRC;
#line 77 "/root/patchweave_new/23/src/sd2.c"
struct __anonstruct_1360 {
   int type ;
   int id ;
   char name[32] ;
   char value[32] ;
   int value_len ;
};
#line 83 "/root/patchweave_new/23/src/sd2.c"
typedef struct __anonstruct_1360 STR_RSRC;
#line 52 "/root/patchweave_new/23/src/paf.c"
struct __anonstruct_1118___0 {
   int version ;
   int endianness ;
   int samplerate ;
   int format ;
   int channels ;
   int source ;
};
#line 59 "/root/patchweave_new/23/src/paf.c"
typedef struct __anonstruct_1118___0 PAF_FMT;
#line 61 "/root/patchweave_new/23/src/paf.c"
struct __anonstruct_1420 {
   int max_blocks ;
   int channels ;
   int blocksize ;
   int read_block ;
   int write_block ;
   int read_count ;
   int write_count ;
   sf_count_t sample_count ;
   int *samples ;
   int *block ;
   int data[] ;
};
#line 68 "/root/patchweave_new/23/src/paf.c"
typedef struct __anonstruct_1420 PAF24_PRIVATE;
#line 35 "/root/patchweave_new/23/src/g72x.c"
struct __anonstruct_1536 {
   struct g72x_state *private ;
   int blocksize ;
   int samplesperblock ;
   int bytesperblock ;
   int blocks_total ;
   int block_curr ;
   int sample_curr ;
   unsigned char block[120] ;
   short samples[120] ;
};
#line 46 "/root/patchweave_new/23/src/g72x.c"
typedef struct __anonstruct_1536 G72x_PRIVATE;
#line 58 "/usr/include/FLAC/ordinals.h"
typedef uint8_t FLAC__uint8;
#line 61 "/usr/include/FLAC/ordinals.h"
typedef int32_t FLAC__int32;
#line 63 "/usr/include/FLAC/ordinals.h"
typedef uint16_t FLAC__uint16;
#line 64 "/usr/include/FLAC/ordinals.h"
typedef uint32_t FLAC__uint32;
#line 65 "/usr/include/FLAC/ordinals.h"
typedef uint64_t FLAC__uint64;
#line 69 "/usr/include/FLAC/ordinals.h"
typedef int FLAC__bool;
#line 71 "/usr/include/FLAC/ordinals.h"
typedef FLAC__uint8 FLAC__byte;
#line 194 "/usr/include/FLAC/format.h"
enum __anonenum__1559 {
    FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE = 0,
    FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2 = 1
} ;
#line 202 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1559 FLAC__EntropyCodingMethodType;
#line 214 "/usr/include/FLAC/format.h"
struct __anonstruct_1560 {
   uint32_t *parameters ;
   uint32_t *raw_bits ;
   uint32_t capacity_by_order ;
};
#line 229 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1560 FLAC__EntropyCodingMethod_PartitionedRiceContents;
#line 233 "/usr/include/FLAC/format.h"
struct __anonstruct_1561 {
   uint32_t order ;
   FLAC__EntropyCodingMethod_PartitionedRiceContents *contents ;
};
#line 241 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1561 FLAC__EntropyCodingMethod_PartitionedRice;
#line 257 "/usr/include/FLAC/format.h"
union __anonunion_1563 {
   FLAC__EntropyCodingMethod_PartitionedRice partitioned_rice ;
};
#line 255 "/usr/include/FLAC/format.h"
struct __anonstruct_1562 {
   FLAC__EntropyCodingMethodType type ;
   union __anonunion_1563 data ;
};
#line 260 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1562 FLAC__EntropyCodingMethod;
#line 267
enum __anonenum__1564 {
    FLAC__SUBFRAME_TYPE_CONSTANT = 0,
    FLAC__SUBFRAME_TYPE_VERBATIM = 1,
    FLAC__SUBFRAME_TYPE_FIXED = 2,
    FLAC__SUBFRAME_TYPE_LPC = 3
} ;
#line 272 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1564 FLAC__SubframeType;
#line 284 "/usr/include/FLAC/format.h"
struct __anonstruct_1565 {
   FLAC__int32 value ;
};
#line 286 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1565 FLAC__Subframe_Constant;
#line 291 "/usr/include/FLAC/format.h"
struct __anonstruct_1566 {
   FLAC__int32 *data ;
};
#line 293 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1566 FLAC__Subframe_Verbatim;
#line 298 "/usr/include/FLAC/format.h"
struct __anonstruct_1567 {
   FLAC__EntropyCodingMethod entropy_coding_method ;
   uint32_t order ;
   FLAC__int32 warmup[4] ;
   FLAC__int32 *residual ;
};
#line 310 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1567 FLAC__Subframe_Fixed;
#line 315 "/usr/include/FLAC/format.h"
struct __anonstruct_1568 {
   FLAC__EntropyCodingMethod entropy_coding_method ;
   uint32_t order ;
   uint32_t qlp_coeff_precision ;
   int quantization_level ;
   FLAC__int32 qlp_coeff[32] ;
   FLAC__int32 warmup[32] ;
   FLAC__int32 *residual ;
};
#line 336 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1568 FLAC__Subframe_LPC;
#line 346 "/usr/include/FLAC/format.h"
union __anonunion_1570 {
   FLAC__Subframe_Constant constant ;
   FLAC__Subframe_Fixed fixed ;
   FLAC__Subframe_LPC lpc ;
   FLAC__Subframe_Verbatim verbatim ;
};
#line 344 "/usr/include/FLAC/format.h"
struct __anonstruct_1569 {
   FLAC__SubframeType type ;
   union __anonunion_1570 data ;
   uint32_t wasted_bits ;
};
#line 353 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1569 FLAC__Subframe;
#line 381
enum __anonenum__1571 {
    FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT = 0,
    FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE = 1,
    FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE = 2,
    FLAC__CHANNEL_ASSIGNMENT_MID_SIDE = 3
} ;
#line 386 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1571 FLAC__ChannelAssignment;
#line 396
enum __anonenum__1572 {
    FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER = 0,
    FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER = 1
} ;
#line 399 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1572 FLAC__FrameNumberType;
#line 432 "/usr/include/FLAC/format.h"
union __anonunion_1574 {
   FLAC__uint32 frame_number ;
   FLAC__uint64 sample_number ;
};
#line 411 "/usr/include/FLAC/format.h"
struct __anonstruct_1573 {
   uint32_t blocksize ;
   uint32_t sample_rate ;
   uint32_t channels ;
   FLAC__ChannelAssignment channel_assignment ;
   uint32_t bits_per_sample ;
   FLAC__FrameNumberType number_type ;
   union __anonunion_1574 number ;
   FLAC__uint8 crc ;
};
#line 444 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1573 FLAC__FrameHeader;
#line 460 "/usr/include/FLAC/format.h"
struct __anonstruct_1575 {
   FLAC__uint16 crc ;
};
#line 466 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1575 FLAC__FrameFooter;
#line 473 "/usr/include/FLAC/format.h"
struct __anonstruct_1576 {
   FLAC__FrameHeader header ;
   FLAC__Subframe subframes[8] ;
   FLAC__FrameFooter footer ;
};
#line 477 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1576 FLAC__Frame;
#line 489
enum __anonenum__1577 {
    FLAC__METADATA_TYPE_STREAMINFO = 0,
    FLAC__METADATA_TYPE_PADDING = 1,
    FLAC__METADATA_TYPE_APPLICATION = 2,
    FLAC__METADATA_TYPE_SEEKTABLE = 3,
    FLAC__METADATA_TYPE_VORBIS_COMMENT = 4,
    FLAC__METADATA_TYPE_CUESHEET = 5,
    FLAC__METADATA_TYPE_PICTURE = 6,
    FLAC__METADATA_TYPE_UNDEFINED = 7,
    FLAC__MAX_METADATA_TYPE = 126
} ;
#line 517 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1577 FLAC__MetadataType;
#line 529 "/usr/include/FLAC/format.h"
struct __anonstruct_1578 {
   uint32_t min_blocksize ;
   uint32_t max_blocksize ;
   uint32_t min_framesize ;
   uint32_t max_framesize ;
   uint32_t sample_rate ;
   uint32_t channels ;
   uint32_t bits_per_sample ;
   FLAC__uint64 total_samples ;
   FLAC__byte md5sum[16] ;
};
#line 537 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1578 FLAC__StreamMetadata_StreamInfo;
#line 554 "/usr/include/FLAC/format.h"
struct __anonstruct_1579 {
   int dummy ;
};
#line 560 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1579 FLAC__StreamMetadata_Padding;
#line 565 "/usr/include/FLAC/format.h"
struct __anonstruct_1580 {
   FLAC__byte id[4] ;
   FLAC__byte *data ;
};
#line 568 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1580 FLAC__StreamMetadata_Application;
#line 574 "/usr/include/FLAC/format.h"
struct __anonstruct_1581 {
   FLAC__uint64 sample_number ;
   FLAC__uint64 stream_offset ;
   uint32_t frame_samples ;
};
#line 584 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1581 FLAC__StreamMetadata_SeekPoint;
#line 612 "/usr/include/FLAC/format.h"
struct __anonstruct_1582 {
   uint32_t num_points ;
   FLAC__StreamMetadata_SeekPoint *points ;
};
#line 615 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1582 FLAC__StreamMetadata_SeekTable;
#line 624 "/usr/include/FLAC/format.h"
struct __anonstruct_1583 {
   FLAC__uint32 length ;
   FLAC__byte *entry ;
};
#line 627 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1583 FLAC__StreamMetadata_VorbisComment_Entry;
#line 634 "/usr/include/FLAC/format.h"
struct __anonstruct_1584 {
   FLAC__StreamMetadata_VorbisComment_Entry vendor_string ;
   FLAC__uint32 num_comments ;
   FLAC__StreamMetadata_VorbisComment_Entry *comments ;
};
#line 638 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1584 FLAC__StreamMetadata_VorbisComment;
#line 647 "/usr/include/FLAC/format.h"
struct __anonstruct_1585 {
   FLAC__uint64 offset ;
   FLAC__byte number ;
};
#line 655 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1585 FLAC__StreamMetadata_CueSheet_Index;
#line 666 "/usr/include/FLAC/format.h"
struct __anonstruct_1586 {
   FLAC__uint64 offset ;
   FLAC__byte number ;
   char isrc[13] ;
   uint32_t type ;
   uint32_t pre_emphasis ;
   FLAC__byte num_indices ;
   FLAC__StreamMetadata_CueSheet_Index *indices ;
};
#line 688 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1586 FLAC__StreamMetadata_CueSheet_Track;
#line 703 "/usr/include/FLAC/format.h"
struct __anonstruct_1587 {
   char media_catalog_number[129] ;
   FLAC__uint64 lead_in ;
   FLAC__bool is_cd ;
   uint32_t num_tracks ;
   FLAC__StreamMetadata_CueSheet_Track *tracks ;
};
#line 722 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1587 FLAC__StreamMetadata_CueSheet;
#line 732
enum __anonenum__1588 {
    FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER = 0,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD = 1,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON = 2,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER = 3,
    FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER = 4,
    FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE = 5,
    FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA = 6,
    FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST = 7,
    FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST = 8,
    FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR = 9,
    FLAC__STREAM_METADATA_PICTURE_TYPE_BAND = 10,
    FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER = 11,
    FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST = 12,
    FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION = 13,
    FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING = 14,
    FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE = 15,
    FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE = 16,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FISH = 17,
    FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION = 18,
    FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE = 19,
    FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE = 20,
    FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED = 21
} ;
#line 755 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1588 FLAC__StreamMetadata_Picture_Type;
#line 769 "/usr/include/FLAC/format.h"
struct __anonstruct_1589 {
   FLAC__StreamMetadata_Picture_Type type ;
   char *mime_type ;
   FLAC__byte *description ;
   FLAC__uint32 width ;
   FLAC__uint32 height ;
   FLAC__uint32 depth ;
   FLAC__uint32 colors ;
   FLAC__uint32 data_length ;
   FLAC__byte *data ;
};
#line 811 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1589 FLAC__StreamMetadata_Picture;
#line 827 "/usr/include/FLAC/format.h"
struct __anonstruct_1590 {
   FLAC__byte *data ;
};
#line 829 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1590 FLAC__StreamMetadata_Unknown;
#line 846 "/usr/include/FLAC/format.h"
union __anonunion_1592 {
   FLAC__StreamMetadata_StreamInfo stream_info ;
   FLAC__StreamMetadata_Padding padding ;
   FLAC__StreamMetadata_Application application ;
   FLAC__StreamMetadata_SeekTable seek_table ;
   FLAC__StreamMetadata_VorbisComment vorbis_comment ;
   FLAC__StreamMetadata_CueSheet cue_sheet ;
   FLAC__StreamMetadata_Picture picture ;
   FLAC__StreamMetadata_Unknown unknown ;
};
#line 834 "/usr/include/FLAC/format.h"
struct __anonstruct_1591 {
   FLAC__MetadataType type ;
   FLAC__bool is_last ;
   uint32_t length ;
   union __anonunion_1592 data ;
};
#line 858 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1591 FLAC__StreamMetadata;
#line 202 "/usr/include/FLAC/stream_decoder.h"
enum __anonenum__1593 {
    FLAC__STREAM_DECODER_SEARCH_FOR_METADATA = 0,
    FLAC__STREAM_DECODER_READ_METADATA = 1,
    FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC = 2,
    FLAC__STREAM_DECODER_READ_FRAME = 3,
    FLAC__STREAM_DECODER_END_OF_STREAM = 4,
    FLAC__STREAM_DECODER_OGG_ERROR = 5,
    FLAC__STREAM_DECODER_SEEK_ERROR = 6,
    FLAC__STREAM_DECODER_ABORTED = 7,
    FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR = 8,
    FLAC__STREAM_DECODER_UNINITIALIZED = 9
} ;
#line 244 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1593 FLAC__StreamDecoderState;
#line 256
enum __anonenum__1594 {
    FLAC__STREAM_DECODER_INIT_STATUS_OK = 0,
    FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER = 1,
    FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS = 2,
    FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR = 3,
    FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE = 4,
    FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED = 5
} ;
#line 282 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1594 FLAC__StreamDecoderInitStatus;
#line 294
enum __anonenum__1595 {
    FLAC__STREAM_DECODER_READ_STATUS_CONTINUE = 0,
    FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM = 1,
    FLAC__STREAM_DECODER_READ_STATUS_ABORT = 2
} ;
#line 313 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1595 FLAC__StreamDecoderReadStatus;
#line 325
enum __anonenum__1596 {
    FLAC__STREAM_DECODER_SEEK_STATUS_OK = 0,
    FLAC__STREAM_DECODER_SEEK_STATUS_ERROR = 1,
    FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED = 2
} ;
#line 336 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1596 FLAC__StreamDecoderSeekStatus;
#line 348
enum __anonenum__1597 {
    FLAC__STREAM_DECODER_TELL_STATUS_OK = 0,
    FLAC__STREAM_DECODER_TELL_STATUS_ERROR = 1,
    FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED = 2
} ;
#line 359 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1597 FLAC__StreamDecoderTellStatus;
#line 371
enum __anonenum__1598 {
    FLAC__STREAM_DECODER_LENGTH_STATUS_OK = 0,
    FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR = 1,
    FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED = 2
} ;
#line 382 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1598 FLAC__StreamDecoderLengthStatus;
#line 394
enum __anonenum__1599 {
    FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE = 0,
    FLAC__STREAM_DECODER_WRITE_STATUS_ABORT = 1
} ;
#line 402 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1599 FLAC__StreamDecoderWriteStatus;
#line 427
enum __anonenum__1600 {
    FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC = 0,
    FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER = 1,
    FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH = 2,
    FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM = 3
} ;
#line 441 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1600 FLAC__StreamDecoderErrorStatus;
#line 457
struct FLAC__StreamDecoderProtected ;
#line 458
struct FLAC__StreamDecoderPrivate ;
#line 463 "/usr/include/FLAC/stream_decoder.h"
struct __anonstruct_1601 {
   struct FLAC__StreamDecoderProtected *protected_ ;
   struct FLAC__StreamDecoderPrivate *private_ ;
};
#line 466 "/usr/include/FLAC/stream_decoder.h"
typedef struct __anonstruct_1601 FLAC__StreamDecoder;
#line 293 "/usr/include/FLAC/stream_encoder.h"
enum __anonenum__1603 {
    FLAC__STREAM_ENCODER_INIT_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR = 1,
    FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER = 2,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS = 3,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS = 4,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE = 5,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE = 6,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE = 7,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER = 8,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION = 9,
    FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER = 10,
    FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE = 11,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA = 12,
    FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED = 13
} ;
#line 351 "/usr/include/FLAC/stream_encoder.h"
typedef enum __anonenum__1603 FLAC__StreamEncoderInitStatus;
#line 389
enum __anonenum__1605 {
    FLAC__STREAM_ENCODER_WRITE_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR = 1
} ;
#line 397 "/usr/include/FLAC/stream_encoder.h"
typedef enum __anonenum__1605 FLAC__StreamEncoderWriteStatus;
#line 409
enum __anonenum__1606 {
    FLAC__STREAM_ENCODER_SEEK_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR = 1,
    FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED = 2
} ;
#line 420 "/usr/include/FLAC/stream_encoder.h"
typedef enum __anonenum__1606 FLAC__StreamEncoderSeekStatus;
#line 432
enum __anonenum__1607 {
    FLAC__STREAM_ENCODER_TELL_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_TELL_STATUS_ERROR = 1,
    FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED = 2
} ;
#line 443 "/usr/include/FLAC/stream_encoder.h"
typedef enum __anonenum__1607 FLAC__StreamEncoderTellStatus;
#line 459
struct FLAC__StreamEncoderProtected ;
#line 460
struct FLAC__StreamEncoderPrivate ;
#line 465 "/usr/include/FLAC/stream_encoder.h"
struct __anonstruct_1608 {
   struct FLAC__StreamEncoderProtected *protected_ ;
   struct FLAC__StreamEncoderPrivate *private_ ;
};
#line 468 "/usr/include/FLAC/stream_encoder.h"
typedef struct __anonstruct_1608 FLAC__StreamEncoder;
#line 46 "/root/patchweave_new/23/src/flac.c"
enum __anonenum__1612 {
    PFLAC_PCM_SHORT = 50,
    PFLAC_PCM_INT = 51,
    PFLAC_PCM_FLOAT = 52,
    PFLAC_PCM_DOUBLE = 53
} ;
#line 51 "/root/patchweave_new/23/src/flac.c"
typedef enum __anonenum__1612 PFLAC_PCM;
#line 53 "/root/patchweave_new/23/src/flac.c"
struct __anonstruct_1613 {
   FLAC__StreamDecoder *fsd ;
   FLAC__StreamEncoder *fse ;
   PFLAC_PCM pcmtype ;
   void *ptr ;
   unsigned int pos ;
   unsigned int len ;
   unsigned int remain ;
   FLAC__StreamMetadata *metadata ;
   int32_t * const  *wbuffer ;
   int32_t *rbuffer[8] ;
   int32_t *encbuffer ;
   unsigned int bufferpos ;
   FLAC__Frame *frame ;
   unsigned int compression ;
};
#line 74 "/root/patchweave_new/23/src/flac.c"
typedef struct __anonstruct_1613 FLAC_PRIVATE;
#line 76 "/root/patchweave_new/23/src/flac.c"
struct __anonstruct_1614 {
   char const   *tag ;
   int type ;
};
#line 79 "/root/patchweave_new/23/src/flac.c"
typedef struct __anonstruct_1614 FLAC_TAG;
#line 77 "/root/patchweave_new/23/src/caf.c"
struct __anonstruct_1662 {
   uint8_t srate[8] ;
   uint32_t fmt_id ;
   uint32_t fmt_flags ;
   uint32_t pkt_bytes ;
   uint32_t frames_per_packet ;
   uint32_t channels_per_frame ;
   uint32_t bits_per_chan ;
};
#line 85 "/root/patchweave_new/23/src/caf.c"
typedef struct __anonstruct_1662 DESC_CHUNK;
#line 87 "/root/patchweave_new/23/src/caf.c"
struct __anonstruct_1663 {
   int chanmap_tag ;
   ALAC_DECODER_INFO alac ;
};
#line 91 "/root/patchweave_new/23/src/caf.c"
typedef struct __anonstruct_1663 CAF_PRIVATE;
#line 906 "/root/patchweave_new/23/src/caf.c"
struct put_buffer {
   uint32_t index ;
   char s[16384] ;
};
#line 42 "/root/patchweave_new/23/src/avr.c"
struct __anonstruct_622___0 {
   int marker ;
   char name[8] ;
   short mono ;
   short rez ;
   short sign ;
   short loop ;
   short midi ;
   int srate ;
   int frames ;
   int lbeg ;
   int lend ;
   short res1 ;
   short res2 ;
   short res3 ;
   char ext[20] ;
   char user[64] ;
};
#line 64 "/root/patchweave_new/23/src/avr.c"
typedef struct __anonstruct_622___0 AVR_HEADER;
#line 80 "/root/patchweave_new/23/src/au.c"
struct __anonstruct_1724 {
   int dataoffset ;
   int datasize ;
   int encoding ;
   int samplerate ;
   int channels ;
};
#line 86 "/root/patchweave_new/23/src/au.c"
typedef struct __anonstruct_1724 AU_FMT;
#line 125 "/root/patchweave_new/23/src/aiff.c"
struct __anonstruct_1728 {
   uint32_t size ;
   int16_t numChannels ;
   uint32_t numSampleFrames ;
   int16_t sampleSize ;
   uint8_t sampleRate[10] ;
   uint32_t encoding ;
   char zero_bytes[2] ;
};
#line 133 "/root/patchweave_new/23/src/aiff.c"
typedef struct __anonstruct_1728 COMM_CHUNK;
#line 135 "/root/patchweave_new/23/src/aiff.c"
struct __anonstruct_1729 {
   uint32_t offset ;
   uint32_t blocksize ;
};
#line 138 "/root/patchweave_new/23/src/aiff.c"
typedef struct __anonstruct_1729 SSND_CHUNK;
#line 172 "/root/patchweave_new/23/src/aiff.c"
struct __anonstruct_1734 {
   uint32_t version ;
   uint32_t numBeats ;
   uint16_t rootNote ;
   uint16_t scaleType ;
   uint16_t sigNumerator ;
   uint16_t sigDenominator ;
   uint16_t loopType ;
};
#line 180 "/root/patchweave_new/23/src/aiff.c"
typedef struct __anonstruct_1734 basc_CHUNK;
#line 182 "/root/patchweave_new/23/src/aiff.c"
struct __anonstruct_1735 {
   uint16_t markerID ;
   uint32_t position ;
};
#line 185 "/root/patchweave_new/23/src/aiff.c"
typedef struct __anonstruct_1735 MARK_ID_POS;
#line 187 "/root/patchweave_new/23/src/aiff.c"
struct __anonstruct_1736 {
   sf_count_t comm_offset ;
   sf_count_t ssnd_offset ;
   int32_t chanmap_tag ;
   MARK_ID_POS *markstr ;
};
#line 194 "/root/patchweave_new/23/src/aiff.c"
typedef struct __anonstruct_1736 AIFF_PRIVATE;
#line 51 "/root/patchweave_new/23/src/sndfile.c"
struct __anonstruct_1784 {
   int error ;
   char const   *str ;
};
#line 54 "/root/patchweave_new/23/src/sndfile.c"
typedef struct __anonstruct_1784 ErrorStruct;
#line 37 "/root/patchweave_new/23/programs/common.h"
struct __anonstruct_1803 {
   char const   *title ;
   char const   *copyright ;
   char const   *artist ;
   char const   *comment ;
   char const   *date ;
   char const   *album ;
   char const   *license ;
   int has_bext_fields ;
   int coding_hist_append ;
   char const   *description ;
   char const   *originator ;
   char const   *originator_reference ;
   char const   *origination_date ;
   char const   *origination_time ;
   char const   *umid ;
   char const   *coding_history ;
   char const   *time_ref ;
};
#line 59 "/root/patchweave_new/23/programs/common.h"
typedef struct __anonstruct_1803 METADATA_INFO;
#line 61 "/root/patchweave_new/23/programs/common.h"
struct __anonstruct_1804 {
   char description[256] ;
   char originator[32] ;
   char originator_reference[32] ;
   char origination_date[10] ;
   char origination_time[8] ;
   uint32_t time_reference_low ;
   uint32_t time_reference_high ;
   short version ;
   char umid[64] ;
   char reserved[190] ;
   uint32_t coding_history_size ;
   char coding_history[2048] ;
};
#line 61 "/root/patchweave_new/23/programs/common.h"
typedef struct __anonstruct_1804 SF_BROADCAST_INFO_2K;
#line 279 "/root/patchweave_new/23/programs/common.c"
struct __anonstruct_1805 {
   char const   *ext ;
   int len ;
   int format ;
};
#line 283 "/root/patchweave_new/23/programs/common.c"
typedef struct __anonstruct_1805 OUTPUT_FORMAT_MAP;
#line 50 "/root/patchweave_new/23/src/chunk.c"
union __anonunion_739 ;
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 326
__inline extern int ( __attribute__((__gnu_inline__)) fprintf)(FILE *__stream , char const   *__fmt 
                                                               , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__)) printf)(char const   *__fmt 
                                                              , ...) ;
#line 334
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) sprintf)(char *__s ,
                                                                                             char const   *__fmt 
                                                                                             , ...) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__)) vfprintf)(FILE *__stream , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   *__fmt ,
                                                               __gnuc_va_list __ap ) ;
#line 349
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s ,
                                                                                              char const   *__fmt ,
                                                                                              __gnuc_va_list __ap ) ;
#line 354
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) snprintf)(char *__s ,
                                                                                              size_t __n ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s ,
                                                                                               size_t __n ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 366
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vasprintf)(char **__ptr ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 372
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) asprintf)(char **__ptr ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 379
__inline extern int ( __attribute__((__gnu_inline__)) vdprintf)(int __fd , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) ;
#line 382
__inline extern int ( __attribute__((__gnu_inline__)) dprintf)(int __fd , char const   *__fmt 
                                                               , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 499
extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
#line 500
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 510
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 537
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__gnu_inline__)) fgets)(char *__s , int __n ,
                                                               FILE *__stream ) ;
#line 587
__inline extern char *( __attribute__((__gnu_inline__)) fgets_unlocked)(char *__s ,
                                                                        int __n ,
                                                                        FILE *__stream ) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char **__lineptr ,
                                                                     size_t *__n ,
                                                                     FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 646
__inline extern unsigned long ( __attribute__((__gnu_inline__)) fread)(void *__ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE *__stream ) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 673
__inline extern size_t ( __attribute__((__gnu_inline__)) fread_unlocked)(void *__ptr ,
                                                                         size_t __size ,
                                                                         size_t __n ,
                                                                         FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 826
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) obstack_printf)(struct obstack *__obstack ,
                                                                                                    char const   *__fmt 
                                                                                                    , ...) ;
#line 829
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) obstack_vprintf)(struct obstack *__obstack ,
                                                                                                     char const   *__fmt ,
                                                                                                     __gnuc_va_list __ap ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                                0L);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                                0L);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                                0L);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                                0L);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 118 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char **__lineptr ,
                                                                     size_t *__n ,
                                                                     FILE *__stream ) 
{ 
  __ssize_t __cil_tmp4 ;

  {
  {
#line 120
  __cil_tmp4 = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 120
  return (__cil_tmp4);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) sprintf)(char *__s ,
                                                                                             char const   *__fmt 
                                                                                             , ...) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) sprintf)(char *__s , char const   *__fmt 
                                                               , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp3 = __builtin_object_size((void *)__s, 1);
#line 36
  __cil_tmp4 = (int )__builtin_va_arg_pack();
#line 36
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 46
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s ,
                                                                                              char const   *__fmt ,
                                                                                              __gnuc_va_list __ap ) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 49
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 49
  return (__cil_tmp5);
}
}
#line 64
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) snprintf)(char *__s ,
                                                                                              size_t __n ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) snprintf)(char *__s , size_t __n ,
                                                                char const   *__fmt 
                                                                , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 67
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 67
  __cil_tmp5 = (int )__builtin_va_arg_pack();
#line 67
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 67
  return (__cil_tmp6);
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s ,
                                                                                               size_t __n ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s , size_t __n ,
                                                                 char const   *__fmt ,
                                                                 __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 80
  __cil_tmp5 = __builtin_object_size((void *)__s, 1);
#line 80
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 80
  return (__cil_tmp6);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) fprintf)(FILE *__stream , char const   *__fmt 
                                                               , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 100
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 100
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 100
  return (__cil_tmp4);
}
}
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) printf)(char const   *__fmt 
                                                              , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp2 = (int )__builtin_va_arg_pack();
#line 107
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   *__fmt ,
                                                               __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 120
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 120
  return (__cil_tmp3);
}
}
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vfprintf)(FILE *__stream , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 134
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 136
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) dprintf)(int __fd , char const   *__fmt 
                                                               , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 144
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 144
  return (__cil_tmp4);
}
}
#line 153 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vdprintf)(int __fd , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 155
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 155
  return (__cil_tmp4);
}
}
#line 161
extern  __attribute__((__nothrow__)) int __asprintf_chk(char **__ptr , int __flag ,
                                                        char const   *__fmt  , ...) ;
#line 164
extern  __attribute__((__nothrow__)) int __vasprintf_chk(char **__ptr , int __flag ,
                                                         char const   *__fmt , __gnuc_va_list __arg ) ;
#line 167
extern  __attribute__((__nothrow__)) int __obstack_printf_chk(struct obstack *__obstack ,
                                                              int __flag , char const   *__format 
                                                              , ...) ;
#line 171
extern  __attribute__((__nothrow__)) int __obstack_vprintf_chk(struct obstack *__obstack ,
                                                               int __flag , char const   *__format ,
                                                               __gnuc_va_list __args ) ;
#line 179
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) asprintf)(char **__ptr ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 179 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) asprintf)(char **__ptr , char const   *__fmt 
                                                                , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 181
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 181
  __cil_tmp4 = __asprintf_chk(__ptr, 1, __fmt, __cil_tmp3);
  }
#line 181
  return (__cil_tmp4);
}
}
#line 194
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) obstack_printf)(struct obstack *__obstack ,
                                                                                                    char const   *__fmt 
                                                                                                    , ...) ;
#line 194 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) obstack_printf)(struct obstack *__obstack ,
                                                                      char const   *__fmt 
                                                                      , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 197
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 197
  __cil_tmp4 = __obstack_printf_chk(__obstack, 1, __fmt, __cil_tmp3);
  }
#line 197
  return (__cil_tmp4);
}
}
#line 210
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vasprintf)(char **__ptr ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 210 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vasprintf)(char **__ptr , char const   *__fmt ,
                                                                 __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 213
  __cil_tmp4 = __vasprintf_chk(__ptr, 1, __fmt, __ap);
  }
#line 213
  return (__cil_tmp4);
}
}
#line 217
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) obstack_vprintf)(struct obstack *__obstack ,
                                                                                                     char const   *__fmt ,
                                                                                                     __gnuc_va_list __ap ) ;
#line 217 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) obstack_vprintf)(struct obstack *__obstack ,
                                                                       char const   *__fmt ,
                                                                       __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 220
  __cil_tmp4 = __obstack_vprintf_chk(__obstack, 1, __fmt, __ap);
  }
#line 220
  return (__cil_tmp4);
}
}
#line 243
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 248
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 255 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__gnu_inline__)) fgets)(char *__s , int __n ,
                                                               FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 257
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
  }
#line 257
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 259
    __cil_tmp5 = 0;
#line 259
    if (! __cil_tmp5) {
      {
#line 260
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 260
      return (__cil_tmp7);
    } else
#line 259
    if (__n <= 0) {
      {
#line 260
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 260
      return (__cil_tmp7);
    }
    {
#line 262
    __cil_tmp8 = __builtin_object_size((void *)__s, 1);
    }
#line 262
    if ((size_t )__n > __cil_tmp8) {
      {
#line 263
      __cil_tmp9 = __builtin_object_size((void *)__s, 1);
#line 263
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 263
      return (__cil_tmp10);
    }
  }
  {
#line 265
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 265
  return (__cil_tmp11);
}
}
#line 268
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 271
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 275
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 284 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long ( __attribute__((__gnu_inline__)) fread)(void *__ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 287
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 287
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 289
    __cil_tmp7 = 0;
#line 289
    __cil_tmp6 = 0;
#line 289
    if (! __cil_tmp6) {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if (! __cil_tmp7) {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp9);
    }
    {
#line 294
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 294
    if (__size * __n > __cil_tmp10) {
      {
#line 295
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 297
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 297
  return (__cil_tmp13);
}
}
#line 301
extern char *__fgets_unlocked_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 303
extern char *__fgets_unlocked_alias(char *__s , int __n , FILE *__stream ) ;
#line 306
extern char *__fgets_unlocked_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 313 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__gnu_inline__)) fgets_unlocked)(char *__s ,
                                                                        int __n ,
                                                                        FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 315
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
  }
#line 315
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 317
    __cil_tmp5 = 0;
#line 317
    if (! __cil_tmp5) {
      {
#line 318
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 318
      __cil_tmp7 = __fgets_unlocked_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 318
      return (__cil_tmp7);
    } else
#line 317
    if (__n <= 0) {
      {
#line 318
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 318
      __cil_tmp7 = __fgets_unlocked_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 318
      return (__cil_tmp7);
    }
    {
#line 320
    __cil_tmp8 = __builtin_object_size((void *)__s, 1);
    }
#line 320
    if ((size_t )__n > __cil_tmp8) {
      {
#line 321
      __cil_tmp9 = __builtin_object_size((void *)__s, 1);
#line 321
      __cil_tmp10 = __fgets_unlocked_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 321
      return (__cil_tmp10);
    }
  }
  {
#line 323
  __cil_tmp11 = __fgets_unlocked_alias(__s, __n, __stream);
  }
#line 323
  return (__cil_tmp11);
}
}
#line 329
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 332
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 336
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) fread_unlocked)(void *__ptr ,
                                                                         size_t __size ,
                                                                         size_t __n ,
                                                                         FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 350
    __cil_tmp7 = 0;
#line 350
    __cil_tmp6 = 0;
#line 350
    if (! __cil_tmp6) {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
#line 362
  __cil_tmp14 = 0;
#line 362
  __cil_tmp13 = 0;
#line 362
  if (__cil_tmp13) {
#line 362
    if (__cil_tmp14) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;

#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
            {
#line 374
            __cil_tmp18 = getc_unlocked(__stream);
#line 374
            __c = __cil_tmp18;
            }
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            __cil_tmp19 = __cptr;
#line 377
            __cptr ++;
#line 377
            *__cil_tmp19 = (char )__c;
#line 372
            __cnt --;
          }
          while_break___0: /* CIL Label */ ;
          }
          while_break: ;
#line 379
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 382
  __cil_tmp20 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp20);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 800
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 820
__inline extern void *( __attribute__((__gnu_inline__)) bsearch)(void const   *__key ,
                                                                 void const   *__base ,
                                                                 size_t __nmemb ,
                                                                 size_t __size , int (*__compar)(void const   * ,
                                                                                                 void const   * ) ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *( __attribute__((__gnu_inline__)) bsearch)(void const   *__key ,
                                                                 void const   *__base ,
                                                                 size_t __nmemb ,
                                                                 size_t __size , int (*__compar)(void const   * ,
                                                                                                 void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;

#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 42
  return ((void *)0);
}
}
#line 840 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 929
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctomb)(char *__s ,
                                                                                            wchar_t __wchar ) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                                 char const   *__src ,
                                                                                                 size_t __len ) ;
#line 936
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst ,
                                                                                                 wchar_t *__src ,
                                                                                                 size_t __len ) ;
#line 992
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                  char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size((void *)__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 45
    __cil_tmp4 = __builtin_object_size((void *)__resolved, 1);
#line 45
    __cil_tmp5 = __realpath_chk(__name, __resolved, __cil_tmp4);
    }
#line 45
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd , char *__buf ,
                                                                 size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 68
    __cil_tmp5 = 0;
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctomb)(char *__s ,
                                                                                            wchar_t __wchar ) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) wctomb)(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 92
  __cil_tmp3 = __builtin_object_size((void *)__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size((void *)__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                                 char const   *__src ,
                                                                                                 size_t __len ) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                   char const   *__src ,
                                                                   size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size((void *)__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    __cil_tmp5 = 0;
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size((void *)__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size((void *)__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size((void *)__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst ,
                                                                                                 wchar_t *__src ,
                                                                                                 size_t __len ) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst , wchar_t *__src ,
                                                                   size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size((void *)__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 149
    __cil_tmp5 = 0;
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size((void *)__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size((void *)__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size((void *)__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest ,
                                                                                              void const   *__src ,
                                                                                              size_t __len ) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memmove)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memset)(void *__dest ,
                                                                                              int __ch ,
                                                                                              size_t __len ) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 130
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcat)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncat)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 378
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) mempcpy)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 38 "/usr/include/strings.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                                                            void *__dest ,
                                                                                            size_t __len ) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bzero)(void *__dest ,
                                                                                            size_t __len ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                                                            void *__dest ,
                                                                                            size_t __len ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                              void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 27
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bzero)(void *__dest ,
                                                                                            size_t __len ) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__gnu_inline__)) bzero)(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
#line 33
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) explicit_bzero)(void *__dest ,
                                                                                                     size_t __len ) ;
#line 452
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 460
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __n ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest ,
                                                                                              void const   *__src ,
                                                                                              size_t __len ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest , void const   *__src ,
                                                                size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memmove)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) memmove)(void *__dest , void const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 45
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) mempcpy)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 45 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) mempcpy)(void *__dest , void const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 48
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 48
  __cil_tmp5 = __builtin___mempcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 48
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memset)(void *__dest ,
                                                                                              int __ch ,
                                                                                              size_t __len ) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) memset)(void *__dest , int __ch ,
                                                                size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 77
extern  __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                               size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) explicit_bzero)(void *__dest ,
                                                                                                     size_t __len ) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void ( __attribute__((__gnu_inline__)) explicit_bzero)(void *__dest ,
                                                                       size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
#line 85
  return;
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size((void *)__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 95
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) stpcpy)(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 97
  __cil_tmp3 = __builtin_object_size((void *)__dest, 1);
#line 97
  __cil_tmp4 = __builtin___stpcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 97
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest , char const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __n ) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest , char const   *__src ,
                                                                 size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size((void *)__dest, 1);
#line 118
  __cil_tmp5 = 0;
#line 118
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
#line 120
      __cil_tmp7 = __builtin_object_size((void *)__dest, 1);
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
#line 120
      __cil_tmp7 = __builtin_object_size((void *)__dest, 1);
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcat)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strcat)(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size((void *)__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncat)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strncat)(char *__dest , char const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 98 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 562 "/root/patchweave_new/23/src/sndfile.h"
SNDFILE *sf_open(char const   *path , int mode , SF_INFO *sfinfo ) ;
#line 577
SNDFILE *sf_open_fd(int fd , int mode , SF_INFO *sfinfo , int close_desc ) ;
#line 579
SNDFILE *sf_open_virtual(SF_VIRTUAL_IO *sfvirtual , int mode , SF_INFO *sfinfo , void *user_data ) ;
#line 586
int sf_error(SNDFILE *sndfile ) ;
#line 593
char const   *sf_strerror(SNDFILE *sndfile ) ;
#line 601
char const   *sf_error_number(int errnum ) ;
#line 609
int sf_perror(SNDFILE *sndfile ) ;
#line 610
int sf_error_str(SNDFILE *sndfile , char *str___0 , size_t maxlen ) ;
#line 615
int sf_command(SNDFILE *sndfile , int command , void *data , int datasize ) ;
#line 620
int sf_format_check(SF_INFO *info ) ;
#line 641
sf_count_t sf_seek(SNDFILE *sndfile , sf_count_t offset , int whence ) ;
#line 652
int sf_set_string(SNDFILE *sndfile , int str_type , char const   *str___0 ) ;
#line 654
char const   *sf_get_string(SNDFILE *sndfile , int str_type ) ;
#line 659
char const   *sf_version_string(void) ;
#line 672
int sf_current_byterate(SNDFILE *sndfile ) ;
#line 677
sf_count_t sf_read_raw(SNDFILE *sndfile , void *ptr , sf_count_t bytes ) ;
#line 678
sf_count_t sf_write_raw(SNDFILE *sndfile , void const   *ptr , sf_count_t len ) ;
#line 691
sf_count_t sf_readf_short(SNDFILE *sndfile , short *ptr , sf_count_t frames ) ;
#line 692
sf_count_t sf_writef_short(SNDFILE *sndfile , short const   *ptr , sf_count_t frames ) ;
#line 694
sf_count_t sf_readf_int(SNDFILE *sndfile , int *ptr , sf_count_t frames ) ;
#line 695
sf_count_t sf_writef_int(SNDFILE *sndfile , int const   *ptr , sf_count_t frames ) ;
#line 697
sf_count_t sf_readf_float(SNDFILE *sndfile , float *ptr , sf_count_t frames ) ;
#line 698
sf_count_t sf_writef_float(SNDFILE *sndfile , float const   *ptr , sf_count_t frames ) ;
#line 700
sf_count_t sf_readf_double(SNDFILE *sndfile , double *ptr , sf_count_t frames ) ;
#line 701
sf_count_t sf_writef_double(SNDFILE *sndfile , double const   *ptr , sf_count_t frames ) ;
#line 709
sf_count_t sf_read_short(SNDFILE *sndfile , short *ptr , sf_count_t len ) ;
#line 710
sf_count_t sf_write_short(SNDFILE *sndfile , short const   *ptr , sf_count_t len ) ;
#line 712
sf_count_t sf_read_int(SNDFILE *sndfile , int *ptr , sf_count_t len ) ;
#line 713
sf_count_t sf_write_int(SNDFILE *sndfile , int const   *ptr , sf_count_t len ) ;
#line 715
sf_count_t sf_read_float(SNDFILE *sndfile , float *ptr , sf_count_t len ) ;
#line 716
sf_count_t sf_write_float(SNDFILE *sndfile , float const   *ptr , sf_count_t len ) ;
#line 718
sf_count_t sf_read_double(SNDFILE *sndfile , double *ptr , sf_count_t len ) ;
#line 719
sf_count_t sf_write_double(SNDFILE *sndfile , double const   *ptr , sf_count_t len ) ;
#line 727
int sf_close(SNDFILE *sndfile ) ;
#line 735
void sf_write_sync(SNDFILE *sndfile ) ;
#line 782
int sf_set_chunk(SNDFILE *sndfile , SF_CHUNK_INFO *chunk_info ) ;
#line 806
SF_CHUNK_ITERATOR *sf_get_chunk_iterator(SNDFILE *sndfile , SF_CHUNK_INFO *chunk_info ) ;
#line 820
SF_CHUNK_ITERATOR *sf_next_chunk_iterator(SF_CHUNK_ITERATOR *iterator ) ;
#line 835
int sf_get_chunk_size(SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 849
int sf_get_chunk_data(SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 297 "/usr/include/inttypes.h"
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                                                    char **endptr ,
                                                                                                    int base ) ;
#line 301
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                                                     char **endptr ,
                                                                                                     int base ) ;
#line 305
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                                                    __gwchar_t **endptr ,
                                                                                                    int base ) ;
#line 310
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                                                     __gwchar_t **endptr ,
                                                                                                     int base ) ;
#line 318
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   *__nptr ,
                                                            char **__endptr , int __base ,
                                                            int __group ) ;
#line 324
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                                                    char **endptr ,
                                                                                                    int base ) ;
#line 324 "/usr/include/inttypes.h"
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                      char **endptr ,
                                                                      int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 327
  __cil_tmp4 = __strtol_internal(nptr, endptr, base, 0);
  }
#line 327
  return (__cil_tmp4);
}
}
#line 330
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 336
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                                                     char **endptr ,
                                                                                                     int base ) ;
#line 336 "/usr/include/inttypes.h"
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                       char **endptr ,
                                                                       int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 339
  __cil_tmp4 = __strtoul_internal(nptr, endptr, base, 0);
  }
#line 339
  return (__cil_tmp4);
}
}
#line 342
extern  __attribute__((__nothrow__)) long __wcstol_internal(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                            int __base , int __group ) ;
#line 348
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                                                    __gwchar_t **endptr ,
                                                                                                    int base ) ;
#line 348 "/usr/include/inttypes.h"
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                      __gwchar_t **endptr ,
                                                                      int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 351
  __cil_tmp4 = __wcstol_internal(nptr, endptr, base, 0);
  }
#line 351
  return (__cil_tmp4);
}
}
#line 354
extern  __attribute__((__nothrow__)) unsigned long __wcstoul_internal(__gwchar_t *__nptr ,
                                                                      __gwchar_t **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                                                     __gwchar_t **endptr ,
                                                                                                     int base ) ;
#line 362 "/usr/include/inttypes.h"
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                       __gwchar_t **endptr ,
                                                                       int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 365
  __cil_tmp4 = __wcstoul_internal(nptr, endptr, base, 0);
  }
#line 365
  return (__cil_tmp4);
}
}
#line 31 "/root/patchweave_new/23/src/sfendian.h"
__inline static int16_t ENDSWAP_16(int16_t x ) 
{ 
  int16_t y ;

  {
#line 36
  __asm__  ("asm":);
#line 34
  return (y);
}
}
#line 38 "/root/patchweave_new/23/src/sfendian.h"
__inline static int32_t ENDSWAP_32(int32_t x ) 
{ 
  int32_t y ;

  {
#line 43
  __asm__  ("asm":);
#line 41
  return (y);
}
}
#line 47 "/root/patchweave_new/23/src/sfendian.h"
__inline static int64_t ENDSWAP_64X(int64_t x ) 
{ 
  int64_t y ;

  {
#line 52
  __asm__  ("asm":);
#line 50
  return (y);
}
}
#line 149 "/root/patchweave_new/23/src/sfendian.h"
__inline static void psf_put_be64(uint8_t *ptr , int offset , int64_t value ) 
{ 


  {
#line 151
  *(ptr + offset) = (uint8_t )(value >> 56);
#line 152
  *(ptr + (offset + 1)) = (uint8_t )(value >> 48);
#line 153
  *(ptr + (offset + 2)) = (uint8_t )(value >> 40);
#line 154
  *(ptr + (offset + 3)) = (uint8_t )(value >> 32);
#line 155
  *(ptr + (offset + 4)) = (uint8_t )(value >> 24);
#line 156
  *(ptr + (offset + 5)) = (uint8_t )(value >> 16);
#line 157
  *(ptr + (offset + 6)) = (uint8_t )(value >> 8);
#line 158
  *(ptr + (offset + 7)) = (uint8_t )value;
#line 159
  return;
}
}
#line 162 "/root/patchweave_new/23/src/sfendian.h"
__inline static void psf_put_be32(uint8_t *ptr , int offset , int32_t value ) 
{ 


  {
#line 164
  *(ptr + offset) = (uint8_t )(value >> 24);
#line 165
  *(ptr + (offset + 1)) = (uint8_t )(value >> 16);
#line 166
  *(ptr + (offset + 2)) = (uint8_t )(value >> 8);
#line 167
  *(ptr + (offset + 3)) = (uint8_t )value;
#line 168
  return;
}
}
#line 178 "/root/patchweave_new/23/src/sfendian.h"
__inline static int64_t psf_get_be64(uint8_t *ptr , int offset ) 
{ 
  int64_t value ;

  {
#line 181
  value = (int64_t )((uint32_t )*(ptr + offset) << 24);
#line 182
  value += (long )((int )*(ptr + (offset + 1)) << 16);
#line 183
  value += (long )((int )*(ptr + (offset + 2)) << 8);
#line 184
  value += (long )*(ptr + (offset + 3));
#line 186
  value = (int64_t )((uint64_t )value << 32);
#line 188
  value += (long )((uint32_t )*(ptr + (offset + 4)) << 24);
#line 189
  value += (long )((int )*(ptr + (offset + 5)) << 16);
#line 190
  value += (long )((int )*(ptr + (offset + 6)) << 8);
#line 191
  value += (long )*(ptr + (offset + 7));
#line 192
  return (value);
}
}
#line 196 "/root/patchweave_new/23/src/sfendian.h"
__inline static int64_t psf_get_le64(uint8_t *ptr , int offset ) 
{ 
  int64_t value ;

  {
#line 199
  value = (int64_t )((uint32_t )*(ptr + (offset + 7)) << 24);
#line 200
  value += (long )((int )*(ptr + (offset + 6)) << 16);
#line 201
  value += (long )((int )*(ptr + (offset + 5)) << 8);
#line 202
  value += (long )*(ptr + (offset + 4));
#line 204
  value = (int64_t )((uint64_t )value << 32);
#line 206
  value += (long )((uint32_t )*(ptr + (offset + 3)) << 24);
#line 207
  value += (long )((int )*(ptr + (offset + 2)) << 16);
#line 208
  value += (long )((int )*(ptr + (offset + 1)) << 8);
#line 209
  value += (long )*(ptr + offset);
#line 210
  return (value);
}
}
#line 214 "/root/patchweave_new/23/src/sfendian.h"
__inline static int32_t psf_get_be32(uint8_t *ptr , int offset ) 
{ 
  int32_t value ;

  {
#line 217
  value = (int32_t )((uint32_t )*(ptr + offset) << 24);
#line 218
  value += (int )*(ptr + (offset + 1)) << 16;
#line 219
  value += (int )*(ptr + (offset + 2)) << 8;
#line 220
  value += (int )*(ptr + (offset + 3));
#line 221
  return (value);
}
}
#line 225 "/root/patchweave_new/23/src/sfendian.h"
__inline static int32_t psf_get_le32(uint8_t *ptr , int offset ) 
{ 
  int32_t value ;

  {
#line 228
  value = (int32_t )((uint32_t )*(ptr + (offset + 3)) << 24);
#line 229
  value += (int )*(ptr + (offset + 2)) << 16;
#line 230
  value += (int )*(ptr + (offset + 1)) << 8;
#line 231
  value += (int )*(ptr + offset);
#line 232
  return (value);
}
}
#line 236 "/root/patchweave_new/23/src/sfendian.h"
__inline static int32_t psf_get_be24(uint8_t *ptr , int offset ) 
{ 
  int32_t value ;

  {
#line 239
  value = (int32_t )((uint32_t )*(ptr + offset) << 24);
#line 240
  value += (int )*(ptr + (offset + 1)) << 16;
#line 241
  value += (int )*(ptr + (offset + 2)) << 8;
#line 242
  return (value);
}
}
#line 246 "/root/patchweave_new/23/src/sfendian.h"
__inline static int32_t psf_get_le24(uint8_t *ptr , int offset ) 
{ 
  int32_t value ;

  {
#line 249
  value = (int32_t )((uint32_t )*(ptr + (offset + 2)) << 24);
#line 250
  value += (int )*(ptr + (offset + 1)) << 16;
#line 251
  value += (int )*(ptr + offset) << 8;
#line 252
  return (value);
}
}
#line 256 "/root/patchweave_new/23/src/sfendian.h"
__inline static int16_t psf_get_be16(uint8_t *ptr , int offset ) 
{ 


  {
#line 257
  return ((int16_t )(((int )*(ptr + offset) << 8) + (int )*(ptr + (offset + 1))));
}
}
#line 265 "/root/patchweave_new/23/src/sfendian.h"
__inline static void endswap_short_array(short *ptr , int len ) 
{ 
  short temp ;

  {
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    len --;
#line 268
    if (! (len >= 0)) {
#line 268
      goto while_break;
    }
    {
#line 269
    temp = *(ptr + len);
#line 270
    *(ptr + len) = ENDSWAP_16(temp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 276
  return;
}
}
#line 275 "/root/patchweave_new/23/src/sfendian.h"
__inline static void endswap_short_copy(short *dest , short const   *src , int len ) 
{ 


  {
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    len --;
#line 277
    if (! (len >= 0)) {
#line 277
      goto while_break;
    }
    {
#line 278
    *(dest + len) = ENDSWAP_16((int16_t )*(src + len));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 284
  return;
}
}
#line 283 "/root/patchweave_new/23/src/sfendian.h"
__inline static void endswap_int_array(int *ptr , int len ) 
{ 
  int temp ;

  {
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    len --;
#line 286
    if (! (len >= 0)) {
#line 286
      goto while_break;
    }
    {
#line 287
    temp = *(ptr + len);
#line 288
    *(ptr + len) = ENDSWAP_32(temp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 294
  return;
}
}
#line 293 "/root/patchweave_new/23/src/sfendian.h"
__inline static void endswap_int_copy(int *dest , int const   *src , int len ) 
{ 


  {
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    len --;
#line 295
    if (! (len >= 0)) {
#line 295
      goto while_break;
    }
    {
#line 296
    *(dest + len) = ENDSWAP_32((int32_t )*(src + len));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 302
  return;
}
}
#line 304 "/root/patchweave_new/23/src/sfendian.h"
__inline static void endswap_int64_t_array(int64_t *ptr , int len ) 
{ 
  int64_t value ;

  {
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    len --;
#line 307
    if (! (len >= 0)) {
#line 307
      goto while_break;
    }
    {
#line 308
    value = *(ptr + len);
#line 309
    *(ptr + len) = ENDSWAP_64X(value);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 315
  return;
}
}
#line 314 "/root/patchweave_new/23/src/sfendian.h"
__inline static void endswap_int64_t_copy(int64_t *dest , int64_t *src , int len ) 
{ 
  int64_t value ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    len --;
#line 317
    if (! (len >= 0)) {
#line 317
      goto while_break;
    }
    {
#line 318
    value = *(src + len);
#line 319
    *(dest + len) = ENDSWAP_64X(value);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 325
  return;
}
}
#line 331 "/root/patchweave_new/23/src/sfendian.h"
__inline static void endswap_double_array(double *ptr , int len ) 
{ 


  {
  {
#line 332
  endswap_int64_t_array((int64_t *)ptr, len);
  }
#line 334
  return;
}
}
#line 341 "/root/patchweave_new/23/src/sfendian.h"
__inline static void endswap_double_copy(double *dest , double const   *src , int len ) 
{ 


  {
  {
#line 342
  endswap_int64_t_copy((int64_t *)dest, (int64_t *)src, len);
  }
#line 344
  return;
}
}
#line 234 "/root/patchweave_new/23/src/common.h"
__inline static PEAK_INFO *peak_info_calloc(int channels ) 
{ 
  void *__cil_tmp2 ;

  {
  {
#line 235
  __cil_tmp2 = calloc(1UL, sizeof(PEAK_INFO ) + (unsigned long )channels * sizeof(PEAK_POS ));
  }
#line 235
  return ((PEAK_INFO *)__cil_tmp2);
}
}
#line 280 "/root/patchweave_new/23/src/common.h"
__inline static size_t make_size_t(int x ) 
{ 


  {
#line 281
  return ((size_t )x);
}
}
#line 285 "/root/patchweave_new/23/src/common.h"
__inline static uint64_t make_size_8(int x ) 
{ 


  {
#line 286
  return ((uint64_t )x);
}
}
#line 301 "/root/patchweave_new/23/src/common.h"
__inline static void *psf_memdup(void const   *src , size_t n ) 
{ 
  void *mem ;
  size_t tmp ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
#line 302
  if (n & 3UL) {
#line 302
    tmp = (n + 4UL) - (n & 3UL);
  } else {
#line 302
    tmp = n;
  }
  {
#line 302
  __cil_tmp5 = calloc(1UL, tmp);
#line 302
  mem = __cil_tmp5;
#line 303
  __cil_tmp6 = memcpy(mem, src, n);
  }
#line 303
  return (__cil_tmp6);
}
}
#line 311 "/root/patchweave_new/23/src/common.h"
__inline static int psf_isprint(int ch ) 
{ 
  int tmp ;

  {
#line 312
  if (ch >= 32) {
#line 312
    if (ch <= 126) {
#line 312
      tmp = 1;
    } else {
#line 312
      tmp = 0;
    }
  } else {
#line 312
    tmp = 0;
  }
#line 312
  return (tmp);
}
}
#line 753
SF_PRIVATE *psf_allocate(void) ;
#line 755
int subformat_to_bytewidth(int format ) ;
#line 756
int s_bitwidth_to_subformat(int bits ) ;
#line 757
int u_bitwidth_to_subformat(int bits ) ;
#line 762
float float32_be_read(unsigned char const   *cptr ) ;
#line 763
float float32_le_read(unsigned char const   *cptr ) ;
#line 764
void float32_be_write(float in , unsigned char *out ) ;
#line 765
void float32_le_write(float in , unsigned char *out ) ;
#line 767
double double64_be_read(unsigned char const   *cptr ) ;
#line 768
double double64_le_read(unsigned char const   *cptr ) ;
#line 769
void double64_be_write(double in , unsigned char *out ) ;
#line 770
void double64_le_write(double in , unsigned char *out ) ;
#line 774
void psf_log_printf(SF_PRIVATE *psf , char const   *format  , ...) ;
#line 775
void psf_log_SF_INFO(SF_PRIVATE *psf ) ;
#line 777
int32_t psf_rand_int32(void) ;
#line 779
void append_snprintf(char *dest , size_t maxlen , char const   *fmt  , ...) ;
#line 780
void psf_strlcpy_crlf(char *dest , char const   *src , size_t destmax , size_t srcmax ) ;
#line 782
sf_count_t psf_decode_frame_count(SF_PRIVATE *psf ) ;
#line 786
int psf_binheader_writef(SF_PRIVATE *psf , char const   *format  , ...) ;
#line 787
void psf_asciiheader_printf(SF_PRIVATE *psf , char const   *format  , ...) ;
#line 791
int psf_binheader_readf(SF_PRIVATE *psf , char const   *format  , ...) ;
#line 801
int psf_get_format_simple_count(void) ;
#line 802
int psf_get_format_simple(SF_FORMAT_INFO *data ) ;
#line 804
int psf_get_format_info(SF_FORMAT_INFO *data ) ;
#line 806
int psf_get_format_major_count(void) ;
#line 807
int psf_get_format_major(SF_FORMAT_INFO *data ) ;
#line 809
int psf_get_format_subtype_count(void) ;
#line 810
int psf_get_format_subtype(SF_FORMAT_INFO *data ) ;
#line 814
double psf_calc_signal_max(SF_PRIVATE *psf , int normalize ) ;
#line 815
int psf_calc_max_all_channels(SF_PRIVATE *psf , double *peaks , int normalize ) ;
#line 817
int psf_get_signal_max(SF_PRIVATE *psf , double *peak ) ;
#line 818
int psf_get_max_all_channels(SF_PRIVATE *psf , double *peaks ) ;
#line 822
char const   *psf_get_string(SF_PRIVATE *psf , int str_type ) ;
#line 823
int psf_set_string(SF_PRIVATE *psf , int str_type , char const   *str ) ;
#line 824
int psf_store_string(SF_PRIVATE *psf , int str_type , char const   *str ) ;
#line 825
int psf_location_string_count(SF_PRIVATE *psf , int location ) ;
#line 828
sf_count_t psf_default_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t samples_from_start ) ;
#line 830
int macos_guess_file_type(SF_PRIVATE *psf , char const   *filename___0 ) ;
#line 837
int psf_fopen(SF_PRIVATE *psf ) ;
#line 838
int psf_set_stdio(SF_PRIVATE *psf ) ;
#line 839
int psf_file_valid(SF_PRIVATE *psf ) ;
#line 840
void psf_set_file(SF_PRIVATE *psf , int fd ) ;
#line 841
void psf_init_files(SF_PRIVATE *psf ) ;
#line 842
void psf_use_rsrc(SF_PRIVATE *psf , int on_off ) ;
#line 844
SNDFILE *psf_open_file(SF_PRIVATE *psf , SF_INFO *sfinfo ) ;
#line 846
sf_count_t psf_fseek(SF_PRIVATE *psf , sf_count_t offset , int whence ) ;
#line 847
sf_count_t psf_fread(void *ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE *psf ) ;
#line 848
sf_count_t psf_fwrite(void const   *ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE *psf ) ;
#line 849
sf_count_t psf_fgets(char *buffer , sf_count_t bufsize , SF_PRIVATE *psf ) ;
#line 850
sf_count_t psf_ftell(SF_PRIVATE *psf ) ;
#line 851
sf_count_t psf_get_filelen(SF_PRIVATE *psf ) ;
#line 853
void psf_fsync(SF_PRIVATE *psf ) ;
#line 855
int psf_is_pipe(SF_PRIVATE *psf ) ;
#line 857
int psf_ftruncate(SF_PRIVATE *psf , sf_count_t len ) ;
#line 858
int psf_fclose(SF_PRIVATE *psf ) ;
#line 861
int psf_open_rsrc(SF_PRIVATE *psf ) ;
#line 862
int psf_close_rsrc(SF_PRIVATE *psf ) ;
#line 873
int aiff_open(SF_PRIVATE *psf ) ;
#line 874
int au_open(SF_PRIVATE *psf ) ;
#line 875
int avr_open(SF_PRIVATE *psf ) ;
#line 876
int htk_open(SF_PRIVATE *psf ) ;
#line 877
int ircam_open(SF_PRIVATE *psf ) ;
#line 878
int mat4_open(SF_PRIVATE *psf ) ;
#line 879
int mat5_open(SF_PRIVATE *psf ) ;
#line 880
int nist_open(SF_PRIVATE *psf ) ;
#line 881
int paf_open(SF_PRIVATE *psf ) ;
#line 882
int pvf_open(SF_PRIVATE *psf ) ;
#line 883
int raw_open(SF_PRIVATE *psf ) ;
#line 884
int sd2_open(SF_PRIVATE *psf ) ;
#line 885
int sds_open(SF_PRIVATE *psf ) ;
#line 886
int svx_open(SF_PRIVATE *psf ) ;
#line 887
int voc_open(SF_PRIVATE *psf ) ;
#line 888
int w64_open(SF_PRIVATE *psf ) ;
#line 889
int wav_open(SF_PRIVATE *psf ) ;
#line 890
int xi_open(SF_PRIVATE *psf ) ;
#line 891
int flac_open(SF_PRIVATE *psf ) ;
#line 892
int caf_open(SF_PRIVATE *psf ) ;
#line 893
int mpc2k_open(SF_PRIVATE *psf ) ;
#line 894
int rf64_open(SF_PRIVATE *psf ) ;
#line 896
int ogg_vorbis_open(SF_PRIVATE *psf ) ;
#line 897
int ogg_speex_open(SF_PRIVATE *psf ) ;
#line 898
int ogg_pcm_open(SF_PRIVATE *psf ) ;
#line 899
int ogg_opus_open(SF_PRIVATE *psf ) ;
#line 900
int ogg_open(SF_PRIVATE *psf ) ;
#line 906
int rx2_open(SF_PRIVATE *psf ) ;
#line 907
int txw_open(SF_PRIVATE *psf ) ;
#line 908
int wve_open(SF_PRIVATE *psf ) ;
#line 909
int dwd_open(SF_PRIVATE *psf ) ;
#line 915
int pcm_init(SF_PRIVATE *psf ) ;
#line 916
int ulaw_init(SF_PRIVATE *psf ) ;
#line 917
int alaw_init(SF_PRIVATE *psf ) ;
#line 918
int float32_init(SF_PRIVATE *psf ) ;
#line 919
int double64_init(SF_PRIVATE *psf ) ;
#line 920
int dwvw_init(SF_PRIVATE *psf , int bitwidth ) ;
#line 921
int gsm610_init(SF_PRIVATE *psf ) ;
#line 922
int vox_adpcm_init(SF_PRIVATE *psf ) ;
#line 923
int flac_init(SF_PRIVATE *psf ) ;
#line 924
int g72x_init(SF_PRIVATE *psf ) ;
#line 925
int alac_init(SF_PRIVATE *psf , ALAC_DECODER_INFO *info ) ;
#line 927
int dither_init(SF_PRIVATE *psf , int mode ) ;
#line 929
int wavlike_ima_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) ;
#line 930
int wavlike_msadpcm_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) ;
#line 932
int aiff_ima_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) ;
#line 934
int interleave_init(SF_PRIVATE *psf ) ;
#line 940
SF_CHUNK_ITERATOR *psf_get_chunk_iterator(SF_PRIVATE *psf , char const   *marker_str ) ;
#line 941
SF_CHUNK_ITERATOR *psf_next_chunk_iterator(READ_CHUNKS *pchk , SF_CHUNK_ITERATOR *iterator ) ;
#line 942
int psf_store_read_chunk_u32(READ_CHUNKS *pchk , uint32_t marker , sf_count_t offset ,
                             uint32_t len ) ;
#line 943
int psf_store_read_chunk_str(READ_CHUNKS *pchk , char const   *marker_str , sf_count_t offset ,
                             uint32_t len ) ;
#line 944
int psf_save_write_chunk(WRITE_CHUNKS *pchk , SF_CHUNK_INFO *chunk_info ) ;
#line 945
int psf_find_read_chunk_str(READ_CHUNKS *pchk , char const   *marker_str ) ;
#line 946
int psf_find_read_chunk_m32(READ_CHUNKS *pchk , uint32_t marker ) ;
#line 947
int psf_find_read_chunk_iterator(READ_CHUNKS *pchk , SF_CHUNK_ITERATOR *marker ) ;
#line 975 "/root/patchweave_new/23/src/common.h"
__inline static void psf_strlcat(char *dest , size_t n , char const   *src ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 976
  __cil_tmp4 = strlen((char const   *)dest);
#line 976
  strncat(dest, src, (n - __cil_tmp4) - 1UL);
#line 977
  *(dest + (n - 1UL)) = (char)0;
  }
#line 979
  return;
}
}
#line 981 "/root/patchweave_new/23/src/common.h"
__inline static void psf_strlcpy(char *dest , size_t n , char const   *src ) 
{ 


  {
  {
#line 982
  strncpy(dest, src, n - 1UL);
#line 983
  *(dest + (n - 1UL)) = (char)0;
  }
#line 985
  return;
}
}
#line 990
void *psf_memset(void *s , int c , sf_count_t len ) ;
#line 992
SF_CUES *psf_cues_dup(void const   *ptr ) ;
#line 993
SF_CUES *psf_cues_alloc(uint32_t cue_count ) ;
#line 994
void psf_get_cues(SF_PRIVATE *psf , void *data , size_t datasize ) ;
#line 996
SF_INSTRUMENT *psf_instrument_alloc(void) ;
#line 998
void psf_sanitize_string(char *cptr , int len ) ;
#line 1001
void psf_get_date_str(char *str , int maxlen ) ;
#line 1003
SF_BROADCAST_INFO_16K *broadcast_var_alloc(void) ;
#line 1004
int broadcast_var_set(SF_PRIVATE *psf , SF_BROADCAST_INFO *info , size_t datasize ) ;
#line 1005
int broadcast_var_get(SF_PRIVATE *psf , SF_BROADCAST_INFO *data , size_t datasize ) ;
#line 1008
SF_CART_INFO_16K *cart_var_alloc(void) ;
#line 1009
int cart_var_set(SF_PRIVATE *psf , SF_CART_INFO *info , size_t datasize ) ;
#line 1010
int cart_var_get(SF_PRIVATE *psf , SF_CART_INFO *data , size_t datasize ) ;
#line 1017
int audio_detect(SF_PRIVATE *psf , AUDIO_DETECT *ad , unsigned char const   *data ,
                 int datalen ) ;
#line 1018
int id3_skip(SF_PRIVATE *psf ) ;
#line 1020
void alac_get_desc_chunk_items(int subformat , uint32_t *fmt_flags , uint32_t *frames_per_packet ) ;
#line 1022
FILE *psf_open_tmpfile(char *fname , size_t fnamelen ) ;
#line 1028
void psf_hexdump(void const   *ptr , int len ) ;
#line 1030
char const   *str_of_major_format(int format ) ;
#line 1031
char const   *str_of_minor_format(int format ) ;
#line 1032
char const   *str_of_open_mode(int mode ) ;
#line 1033
char const   *str_of_endianness(int end ) ;
#line 1062
void psf_f2s_array(float const   *src , short *dest , int count___0 , int normalize ) ;
#line 1063
void psf_f2s_clip_array(float const   *src , short *dest , int count___0 , int normalize ) ;
#line 1065
void psf_d2s_array(double const   *src , short *dest , int count___0 , int normalize ) ;
#line 1066
void psf_d2s_clip_array(double const   *src , short *dest , int count___0 , int normalize ) ;
#line 1068
void psf_f2i_array(float const   *src , int *dest , int count___0 , int normalize ) ;
#line 1069
void psf_f2i_clip_array(float const   *src , int *dest , int count___0 , int normalize ) ;
#line 1071
void psf_d2i_array(double const   *src , int *dest , int count___0 , int normalize ) ;
#line 1072
void psf_d2i_clip_array(double const   *src , int *dest , int count___0 , int normalize ) ;
#line 1088 "/root/patchweave_new/23/src/common.h"
__inline static int32_t arith_shift_left(int32_t x , int shift ) 
{ 


  {
#line 1089
  return ((int32_t )((uint32_t )x << shift));
}
}
#line 48 "/root/patchweave_new/23/src/ima_oki_adpcm.h"
void ima_oki_adpcm_init(IMA_OKI_ADPCM *state , IMA_OKI_ADPCM_TYPE type ) ;
#line 50
int adpcm_decode(IMA_OKI_ADPCM *state , int code ) ;
#line 51
int adpcm_encode(IMA_OKI_ADPCM *state , int sample ) ;
#line 53
void ima_oki_adpcm_decode_block(IMA_OKI_ADPCM *state ) ;
#line 54
void ima_oki_adpcm_encode_block(IMA_OKI_ADPCM *state ) ;
#line 45 "/root/patchweave_new/23/src/vox_adpcm.c"
static sf_count_t vox_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 46
static sf_count_t vox_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 47
static sf_count_t vox_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 48
static sf_count_t vox_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 50
static sf_count_t vox_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 51
static sf_count_t vox_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 52
static sf_count_t vox_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 53
static sf_count_t vox_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 55
static int vox_read_block(SF_PRIVATE *psf , IMA_OKI_ADPCM *pvox , short *ptr , int len ) ;
#line 61 "/root/patchweave_new/23/src/vox_adpcm.c"
static int codec_close(SF_PRIVATE *psf ) 
{ 
  IMA_OKI_ADPCM *p ;

  {
#line 63
  p = (IMA_OKI_ADPCM *)psf->codec_data;
#line 65
  if (p->errors) {
    {
#line 66
    psf_log_printf(psf, "*** Warning : ADPCM state errors: %d\n", p->errors);
    }
  }
#line 67
  return (p->errors);
}
}
#line 71 "/root/patchweave_new/23/src/vox_adpcm.c"
int vox_adpcm_init(SF_PRIVATE *psf ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  sf_count_t __cil_tmp4 ;
  void *tmp ;

  {
#line 72
  pvox = (IMA_OKI_ADPCM *)((void *)0);
#line 74
  if (psf->file.mode == 48) {
#line 75
    return (24);
  }
#line 77
  if (psf->file.mode == 32) {
#line 77
    if (psf->sf.channels != 1) {
#line 78
      return (34);
    }
  }
  {
#line 80
  tmp = malloc(sizeof(IMA_OKI_ADPCM ));
#line 80
  pvox = (IMA_OKI_ADPCM *)tmp;
  }
#line 80
  if ((unsigned long )pvox == (unsigned long )((void *)0)) {
#line 81
    return (17);
  }
  {
#line 83
  psf->codec_data = (void *)pvox;
#line 84
  memset((void *)pvox, 0, sizeof(IMA_OKI_ADPCM ));
  }
#line 86
  if (psf->file.mode == 32) {
#line 87
    psf->write_short = & vox_write_s;
#line 88
    psf->write_int = & vox_write_i;
#line 89
    psf->write_float = & vox_write_f;
#line 90
    psf->write_double = & vox_write_d;
  } else {
    {
#line 93
    psf_log_printf(psf, "Header-less OKI Dialogic ADPCM encoded file.\n");
#line 94
    psf_log_printf(psf, "Setting up for 8kHz, mono, Vox ADPCM.\n");
#line 96
    psf->read_short = & vox_read_s;
#line 97
    psf->read_int = & vox_read_i;
#line 98
    psf->read_float = & vox_read_f;
#line 99
    psf->read_double = & vox_read_d;
    }
  }
#line 103
  if (psf->sf.samplerate < 1) {
#line 104
    psf->sf.samplerate = 8000;
  }
  {
#line 105
  psf->sf.channels = 1;
#line 107
  psf->sf.frames = psf->filelength * 2L;
#line 109
  psf->sf.seekable = 0;
#line 110
  psf->codec_close = & codec_close;
#line 113
  __cil_tmp4 = psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 113
  if (__cil_tmp4 == -1L) {
#line 114
    return (40);
  }
  {
#line 116
  ima_oki_adpcm_init(pvox, (IMA_OKI_ADPCM_TYPE )1);
  }
#line 118
  return (0);
}
}
#line 125 "/root/patchweave_new/23/src/vox_adpcm.c"
static int vox_read_block(SF_PRIVATE *psf , IMA_OKI_ADPCM *pvox , short *ptr , int len ) 
{ 
  int indx ;
  int k ;
  int tmp ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 126
  indx = 0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;

#line 128
    if (! (indx < len)) {
#line 128
      goto while_break;
    }
#line 129
    if (len - indx > 512) {
#line 129
      tmp = 256;
    } else {
#line 129
      tmp = ((len - indx) + 1) / 2;
    }
    {
#line 129
    pvox->code_count = tmp;
#line 131
    __cil_tmp8 = psf_fread((void *)(pvox->codes), (sf_count_t )1, (sf_count_t )pvox->code_count,
                           psf);
#line 131
    k = (int )__cil_tmp8;
    }
#line 131
    if (k != pvox->code_count) {
      {
#line 132
      __cil_tmp9 = psf_ftell(psf);
      }
#line 132
      if (__cil_tmp9 != psf->filelength) {
        {
#line 133
        psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, pvox->code_count);
        }
      }
#line 134
      if (k == 0) {
#line 135
        goto while_break;
      }
    }
    {
#line 138
    pvox->code_count = k;
#line 140
    ima_oki_adpcm_decode_block(pvox);
#line 142
    memcpy((void *)(ptr + indx), (void const   *)(pvox->pcm), (unsigned long )pvox->pcm_count * sizeof(short ));
#line 143
    indx += pvox->pcm_count;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 146
  return (indx);
}
}
#line 151 "/root/patchweave_new/23/src/vox_adpcm.c"
static sf_count_t vox_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  int readcount ;
  int count ;
  sf_count_t total ;
  int tmp ;

  {
#line 154
  total = (sf_count_t )0;
#line 156
  if (! psf->codec_data) {
#line 157
    return ((sf_count_t )0);
  }
#line 158
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;

#line 160
    if (! (len > 0L)) {
#line 160
      goto while_break;
    }
#line 161
    if (len > 268435456L) {
#line 161
      tmp = 268435456;
    } else {
#line 161
      tmp = (int )len;
    }
    {
#line 161
    readcount = tmp;
#line 163
    count = vox_read_block(psf, pvox, ptr, readcount);
#line 165
    total += (long )count;
#line 166
    len -= (long )count;
    }
#line 167
    if (count != readcount) {
#line 168
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 171
  return (total);
}
}
#line 175 "/root/patchweave_new/23/src/vox_adpcm.c"
static sf_count_t vox_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  int tmp ;

  {
#line 180
  total = (sf_count_t )0;
#line 182
  if (! psf->codec_data) {
#line 183
    return ((sf_count_t )0);
  }
#line 184
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 186
  sptr = ubuf.sbuf;
#line 187
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;

#line 188
    if (! (len > 0L)) {
#line 188
      goto while_break;
    }
#line 189
    if (len >= (long )bufferlen) {
#line 189
      tmp = bufferlen;
    } else {
#line 189
      tmp = (int )len;
    }
    {
#line 189
    readcount = tmp;
#line 190
    count = vox_read_block(psf, pvox, sptr, readcount);
#line 191
    k = 0;
    }
    {
#line 191
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 191
      if (! (k < readcount)) {
#line 191
        goto while_break___0;
      }
      {
#line 192
      *(ptr + (total + (long )k)) = arith_shift_left((int32_t )*(sptr + k), 16);
#line 191
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 193
    total += (long )count;
#line 194
    len -= (long )readcount;
#line 195
    if (count != readcount) {
#line 196
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 199
  return (total);
}
}
#line 203 "/root/patchweave_new/23/src/vox_adpcm.c"
static sf_count_t vox_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  int tmp___0 ;

  {
#line 208
  total = (sf_count_t )0;
#line 211
  if (! psf->codec_data) {
#line 212
    return ((sf_count_t )0);
  }
#line 213
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 215
  if (psf->norm_float == 1) {
#line 215
    tmp = 1. / (double )((float )32768);
  } else {
#line 215
    tmp = 1.;
  }
#line 215
  normfact = (float )tmp;
#line 217
  sptr = ubuf.sbuf;
#line 218
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;

#line 219
    if (! (len > 0L)) {
#line 219
      goto while_break;
    }
#line 220
    if (len >= (long )bufferlen) {
#line 220
      tmp___0 = bufferlen;
    } else {
#line 220
      tmp___0 = (int )len;
    }
    {
#line 220
    readcount = tmp___0;
#line 221
    count = vox_read_block(psf, pvox, sptr, readcount);
#line 222
    k = 0;
    }
    {
#line 222
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 222
      if (! (k < readcount)) {
#line 222
        goto while_break___0;
      }
#line 223
      *(ptr + (total + (long )k)) = normfact * (float )*(sptr + k);
#line 222
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 224
    total += (long )count;
#line 225
    len -= (long )readcount;
#line 226
    if (count != readcount) {
#line 227
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 230
  return (total);
}
}
#line 234 "/root/patchweave_new/23/src/vox_adpcm.c"
static sf_count_t vox_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  int tmp___0 ;

  {
#line 239
  total = (sf_count_t )0;
#line 242
  if (! psf->codec_data) {
#line 243
    return ((sf_count_t )0);
  }
#line 244
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 246
  if (psf->norm_double == 1) {
#line 246
    tmp = 1. / (double )32768;
  } else {
#line 246
    tmp = 1.;
  }
#line 246
  normfact = tmp;
#line 248
  sptr = ubuf.sbuf;
#line 249
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;

#line 250
    if (! (len > 0L)) {
#line 250
      goto while_break;
    }
#line 251
    if (len >= (long )bufferlen) {
#line 251
      tmp___0 = bufferlen;
    } else {
#line 251
      tmp___0 = (int )len;
    }
    {
#line 251
    readcount = tmp___0;
#line 252
    count = vox_read_block(psf, pvox, sptr, readcount);
#line 253
    k = 0;
    }
    {
#line 253
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 253
      if (! (k < readcount)) {
#line 253
        goto while_break___0;
      }
#line 254
      *(ptr + (total + (long )k)) = normfact * (double )*(sptr + k);
#line 253
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 255
    total += (long )count;
#line 256
    len -= (long )readcount;
#line 257
    if (count != readcount) {
#line 258
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 261
  return (total);
}
}
#line 268 "/root/patchweave_new/23/src/vox_adpcm.c"
static int vox_write_block(SF_PRIVATE *psf , IMA_OKI_ADPCM *pvox , short const   *ptr ,
                           int len ) 
{ 
  int indx ;
  int k ;
  int tmp ;
  sf_count_t __cil_tmp8 ;

  {
#line 269
  indx = 0;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;

#line 271
    if (! (indx < len)) {
#line 271
      goto while_break;
    }
#line 272
    if (len - indx > 512) {
#line 272
      tmp = 512;
    } else {
#line 272
      tmp = len - indx;
    }
    {
#line 272
    pvox->pcm_count = tmp;
#line 274
    memcpy((void *)(pvox->pcm), (void const   *)(ptr + indx), (unsigned long )pvox->pcm_count * sizeof(short ));
#line 276
    ima_oki_adpcm_encode_block(pvox);
#line 278
    __cil_tmp8 = psf_fwrite((void const   *)(pvox->codes), (sf_count_t )1, (sf_count_t )pvox->code_count,
                            psf);
#line 278
    k = (int )__cil_tmp8;
    }
#line 278
    if (k != pvox->code_count) {
      {
#line 279
      psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, pvox->code_count);
      }
    }
#line 281
    indx += pvox->pcm_count;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 284
  return (indx);
}
}
#line 288 "/root/patchweave_new/23/src/vox_adpcm.c"
static sf_count_t vox_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  int writecount ;
  int count ;
  sf_count_t total ;
  int tmp ;

  {
#line 291
  total = (sf_count_t )0;
#line 293
  if (! psf->codec_data) {
#line 294
    return ((sf_count_t )0);
  }
#line 295
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;

#line 297
    if (! len) {
#line 297
      goto while_break;
    }
#line 298
    if (len > 268435456L) {
#line 298
      tmp = 268435456;
    } else {
#line 298
      tmp = (int )len;
    }
    {
#line 298
    writecount = tmp;
#line 300
    count = vox_write_block(psf, pvox, ptr, writecount);
#line 302
    total += (long )count;
#line 303
    len -= (long )count;
    }
#line 304
    if (count != writecount) {
#line 305
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 308
  return (total);
}
}
#line 312 "/root/patchweave_new/23/src/vox_adpcm.c"
static sf_count_t vox_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  int tmp ;

  {
#line 317
  total = (sf_count_t )0;
#line 319
  if (! psf->codec_data) {
#line 320
    return ((sf_count_t )0);
  }
#line 321
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 323
  sptr = ubuf.sbuf;
#line 324
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;

#line 325
    if (! (len > 0L)) {
#line 325
      goto while_break;
    }
#line 326
    if (len >= (long )bufferlen) {
#line 326
      tmp = bufferlen;
    } else {
#line 326
      tmp = (int )len;
    }
#line 326
    writecount = tmp;
#line 327
    k = 0;
    {
#line 327
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 327
      if (! (k < writecount)) {
#line 327
        goto while_break___0;
      }
#line 328
      *(sptr + k) = (short )(*(ptr + (total + (long )k)) >> 16);
#line 327
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 329
    count = vox_write_block(psf, pvox, (short const   *)sptr, writecount);
#line 330
    total += (long )count;
#line 331
    len -= (long )writecount;
    }
#line 332
    if (count != writecount) {
#line 333
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 336
  return (total);
}
}
#line 340 "/root/patchweave_new/23/src/vox_adpcm.c"
static sf_count_t vox_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  int tmp___0 ;
  long __cil_tmp15 ;

  {
#line 345
  total = (sf_count_t )0;
#line 348
  if (! psf->codec_data) {
#line 349
    return ((sf_count_t )0);
  }
#line 350
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 352
  if (psf->norm_float == 1) {
#line 352
    tmp = 1. * (double )32767;
  } else {
#line 352
    tmp = 1.;
  }
#line 352
  normfact = (float )tmp;
#line 354
  sptr = ubuf.sbuf;
#line 355
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;

#line 356
    if (! (len > 0L)) {
#line 356
      goto while_break;
    }
#line 357
    if (len >= (long )bufferlen) {
#line 357
      tmp___0 = bufferlen;
    } else {
#line 357
      tmp___0 = (int )len;
    }
#line 357
    writecount = tmp___0;
#line 358
    k = 0;
    {
#line 358
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 358
      if (! (k < writecount)) {
#line 358
        goto while_break___0;
      }
      {
#line 359
      __cil_tmp15 = lrintf(normfact * (float )*(ptr + (total + (long )k)));
#line 359
      *(sptr + k) = (short )__cil_tmp15;
#line 358
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 360
    count = vox_write_block(psf, pvox, (short const   *)sptr, writecount);
#line 361
    total += (long )count;
#line 362
    len -= (long )writecount;
    }
#line 363
    if (count != writecount) {
#line 364
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 367
  return (total);
}
}
#line 371 "/root/patchweave_new/23/src/vox_adpcm.c"
static sf_count_t vox_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  int tmp___0 ;
  long __cil_tmp15 ;

  {
#line 376
  total = (sf_count_t )0;
#line 379
  if (! psf->codec_data) {
#line 380
    return ((sf_count_t )0);
  }
#line 381
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 383
  if (psf->norm_double == 1) {
#line 383
    tmp = 1. * (double )32767;
  } else {
#line 383
    tmp = 1.;
  }
#line 383
  normfact = tmp;
#line 385
  sptr = ubuf.sbuf;
#line 386
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;

#line 387
    if (! (len > 0L)) {
#line 387
      goto while_break;
    }
#line 388
    if (len >= (long )bufferlen) {
#line 388
      tmp___0 = bufferlen;
    } else {
#line 388
      tmp___0 = (int )len;
    }
#line 388
    writecount = tmp___0;
#line 389
    k = 0;
    {
#line 389
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 389
      if (! (k < writecount)) {
#line 389
        goto while_break___0;
      }
      {
#line 390
      __cil_tmp15 = lrint(normfact * (double )*(ptr + (total + (long )k)));
#line 390
      *(sptr + k) = (short )__cil_tmp15;
#line 389
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 391
    count = vox_write_block(psf, pvox, (short const   *)sptr, writecount);
#line 392
    total += (long )count;
#line 393
    len -= (long )writecount;
    }
#line 394
    if (count != writecount) {
#line 395
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 398
  return (total);
}
}
#line 26 "/root/patchweave_new/23/src/ulaw.c"
static sf_count_t ulaw_read_ulaw2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 27
static sf_count_t ulaw_read_ulaw2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 28
static sf_count_t ulaw_read_ulaw2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 29
static sf_count_t ulaw_read_ulaw2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 31
static sf_count_t ulaw_write_s2ulaw(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 32
static sf_count_t ulaw_write_i2ulaw(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 33
static sf_count_t ulaw_write_f2ulaw(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 34
static sf_count_t ulaw_write_d2ulaw(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 37 "/root/patchweave_new/23/src/ulaw.c"
int ulaw_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t tmp ;
  sf_count_t tmp___0 ;

  {
#line 39
  if (psf->file.mode == 16) {
#line 40
    psf->read_short = & ulaw_read_ulaw2s;
#line 41
    psf->read_int = & ulaw_read_ulaw2i;
#line 42
    psf->read_float = & ulaw_read_ulaw2f;
#line 43
    psf->read_double = & ulaw_read_ulaw2d;
  } else
#line 39
  if (psf->file.mode == 48) {
#line 40
    psf->read_short = & ulaw_read_ulaw2s;
#line 41
    psf->read_int = & ulaw_read_ulaw2i;
#line 42
    psf->read_float = & ulaw_read_ulaw2f;
#line 43
    psf->read_double = & ulaw_read_ulaw2d;
  }
#line 46
  if (psf->file.mode == 32) {
#line 47
    psf->write_short = & ulaw_write_s2ulaw;
#line 48
    psf->write_int = & ulaw_write_i2ulaw;
#line 49
    psf->write_float = & ulaw_write_f2ulaw;
#line 50
    psf->write_double = & ulaw_write_d2ulaw;
  } else
#line 46
  if (psf->file.mode == 48) {
#line 47
    psf->write_short = & ulaw_write_s2ulaw;
#line 48
    psf->write_int = & ulaw_write_i2ulaw;
#line 49
    psf->write_float = & ulaw_write_f2ulaw;
#line 50
    psf->write_double = & ulaw_write_d2ulaw;
  }
#line 53
  psf->bytewidth = 1;
#line 54
  psf->blockwidth = psf->sf.channels;
#line 56
  if (psf->filelength > psf->dataoffset) {
#line 57
    if (psf->dataend) {
#line 57
      tmp = psf->dataend - psf->dataoffset;
    } else {
#line 57
      tmp = psf->filelength - psf->dataoffset;
    }
#line 57
    psf->datalength = tmp;
  } else {
#line 60
    psf->datalength = (sf_count_t )0;
  }
#line 62
  if (psf->blockwidth > 0) {
#line 62
    tmp___0 = psf->datalength / (long )psf->blockwidth;
  } else {
#line 62
    tmp___0 = 0L;
  }
#line 62
  psf->sf.frames = tmp___0;
#line 64
  return (0);
}
}
#line 70 "/root/patchweave_new/23/src/ulaw.c"
static short ulaw_decode[256]  = 
#line 70
  {      (short)-32124,      (short)-31100,      (short)-30076,      (short)-29052, 
        (short)-28028,      (short)-27004,      (short)-25980,      (short)-24956, 
        (short)-23932,      (short)-22908,      (short)-21884,      (short)-20860, 
        (short)-19836,      (short)-18812,      (short)-17788,      (short)-16764, 
        (short)-15996,      (short)-15484,      (short)-14972,      (short)-14460, 
        (short)-13948,      (short)-13436,      (short)-12924,      (short)-12412, 
        (short)-11900,      (short)-11388,      (short)-10876,      (short)-10364, 
        (short)-9852,      (short)-9340,      (short)-8828,      (short)-8316, 
        (short)-7932,      (short)-7676,      (short)-7420,      (short)-7164, 
        (short)-6908,      (short)-6652,      (short)-6396,      (short)-6140, 
        (short)-5884,      (short)-5628,      (short)-5372,      (short)-5116, 
        (short)-4860,      (short)-4604,      (short)-4348,      (short)-4092, 
        (short)-3900,      (short)-3772,      (short)-3644,      (short)-3516, 
        (short)-3388,      (short)-3260,      (short)-3132,      (short)-3004, 
        (short)-2876,      (short)-2748,      (short)-2620,      (short)-2492, 
        (short)-2364,      (short)-2236,      (short)-2108,      (short)-1980, 
        (short)-1884,      (short)-1820,      (short)-1756,      (short)-1692, 
        (short)-1628,      (short)-1564,      (short)-1500,      (short)-1436, 
        (short)-1372,      (short)-1308,      (short)-1244,      (short)-1180, 
        (short)-1116,      (short)-1052,      (short)-988,      (short)-924, 
        (short)-876,      (short)-844,      (short)-812,      (short)-780, 
        (short)-748,      (short)-716,      (short)-684,      (short)-652, 
        (short)-620,      (short)-588,      (short)-556,      (short)-524, 
        (short)-492,      (short)-460,      (short)-428,      (short)-396, 
        (short)-372,      (short)-356,      (short)-340,      (short)-324, 
        (short)-308,      (short)-292,      (short)-276,      (short)-260, 
        (short)-244,      (short)-228,      (short)-212,      (short)-196, 
        (short)-180,      (short)-164,      (short)-148,      (short)-132, 
        (short)-120,      (short)-112,      (short)-104,      (short)-96, 
        (short)-88,      (short)-80,      (short)-72,      (short)-64, 
        (short)-56,      (short)-48,      (short)-40,      (short)-32, 
        (short)-24,      (short)-16,      (short)-8,      (short)0, 
        (short)32124,      (short)31100,      (short)30076,      (short)29052, 
        (short)28028,      (short)27004,      (short)25980,      (short)24956, 
        (short)23932,      (short)22908,      (short)21884,      (short)20860, 
        (short)19836,      (short)18812,      (short)17788,      (short)16764, 
        (short)15996,      (short)15484,      (short)14972,      (short)14460, 
        (short)13948,      (short)13436,      (short)12924,      (short)12412, 
        (short)11900,      (short)11388,      (short)10876,      (short)10364, 
        (short)9852,      (short)9340,      (short)8828,      (short)8316, 
        (short)7932,      (short)7676,      (short)7420,      (short)7164, 
        (short)6908,      (short)6652,      (short)6396,      (short)6140, 
        (short)5884,      (short)5628,      (short)5372,      (short)5116, 
        (short)4860,      (short)4604,      (short)4348,      (short)4092, 
        (short)3900,      (short)3772,      (short)3644,      (short)3516, 
        (short)3388,      (short)3260,      (short)3132,      (short)3004, 
        (short)2876,      (short)2748,      (short)2620,      (short)2492, 
        (short)2364,      (short)2236,      (short)2108,      (short)1980, 
        (short)1884,      (short)1820,      (short)1756,      (short)1692, 
        (short)1628,      (short)1564,      (short)1500,      (short)1436, 
        (short)1372,      (short)1308,      (short)1244,      (short)1180, 
        (short)1116,      (short)1052,      (short)988,      (short)924, 
        (short)876,      (short)844,      (short)812,      (short)780, 
        (short)748,      (short)716,      (short)684,      (short)652, 
        (short)620,      (short)588,      (short)556,      (short)524, 
        (short)492,      (short)460,      (short)428,      (short)396, 
        (short)372,      (short)356,      (short)340,      (short)324, 
        (short)308,      (short)292,      (short)276,      (short)260, 
        (short)244,      (short)228,      (short)212,      (short)196, 
        (short)180,      (short)164,      (short)148,      (short)132, 
        (short)120,      (short)112,      (short)104,      (short)96, 
        (short)88,      (short)80,      (short)72,      (short)64, 
        (short)56,      (short)48,      (short)40,      (short)32, 
        (short)24,      (short)16,      (short)8,      (short)0};
#line 107 "/root/patchweave_new/23/src/ulaw.c"
static unsigned char ulaw_encode[8193]  = 
#line 107
  {      (unsigned char)255,      (unsigned char)254,      (unsigned char)254,      (unsigned char)253, 
        (unsigned char)253,      (unsigned char)252,      (unsigned char)252,      (unsigned char)251, 
        (unsigned char)251,      (unsigned char)250,      (unsigned char)250,      (unsigned char)249, 
        (unsigned char)249,      (unsigned char)248,      (unsigned char)248,      (unsigned char)247, 
        (unsigned char)247,      (unsigned char)246,      (unsigned char)246,      (unsigned char)245, 
        (unsigned char)245,      (unsigned char)244,      (unsigned char)244,      (unsigned char)243, 
        (unsigned char)243,      (unsigned char)242,      (unsigned char)242,      (unsigned char)241, 
        (unsigned char)241,      (unsigned char)240,      (unsigned char)240,      (unsigned char)239, 
        (unsigned char)239,      (unsigned char)239,      (unsigned char)239,      (unsigned char)238, 
        (unsigned char)238,      (unsigned char)238,      (unsigned char)238,      (unsigned char)237, 
        (unsigned char)237,      (unsigned char)237,      (unsigned char)237,      (unsigned char)236, 
        (unsigned char)236,      (unsigned char)236,      (unsigned char)236,      (unsigned char)235, 
        (unsigned char)235,      (unsigned char)235,      (unsigned char)235,      (unsigned char)234, 
        (unsigned char)234,      (unsigned char)234,      (unsigned char)234,      (unsigned char)233, 
        (unsigned char)233,      (unsigned char)233,      (unsigned char)233,      (unsigned char)232, 
        (unsigned char)232,      (unsigned char)232,      (unsigned char)232,      (unsigned char)231, 
        (unsigned char)231,      (unsigned char)231,      (unsigned char)231,      (unsigned char)230, 
        (unsigned char)230,      (unsigned char)230,      (unsigned char)230,      (unsigned char)229, 
        (unsigned char)229,      (unsigned char)229,      (unsigned char)229,      (unsigned char)228, 
        (unsigned char)228,      (unsigned char)228,      (unsigned char)228,      (unsigned char)227, 
        (unsigned char)227,      (unsigned char)227,      (unsigned char)227,      (unsigned char)226, 
        (unsigned char)226,      (unsigned char)226,      (unsigned char)226,      (unsigned char)225, 
        (unsigned char)225,      (unsigned char)225,      (unsigned char)225,      (unsigned char)224, 
        (unsigned char)224,      (unsigned char)224,      (unsigned char)224,      (unsigned char)223, 
        (unsigned char)223,      (unsigned char)223,      (unsigned char)223,      (unsigned char)223, 
        (unsigned char)223,      (unsigned char)223,      (unsigned char)223,      (unsigned char)222, 
        (unsigned char)222,      (unsigned char)222,      (unsigned char)222,      (unsigned char)222, 
        (unsigned char)222,      (unsigned char)222,      (unsigned char)222,      (unsigned char)221, 
        (unsigned char)221,      (unsigned char)221,      (unsigned char)221,      (unsigned char)221, 
        (unsigned char)221,      (unsigned char)221,      (unsigned char)221,      (unsigned char)220, 
        (unsigned char)220,      (unsigned char)220,      (unsigned char)220,      (unsigned char)220, 
        (unsigned char)220,      (unsigned char)220,      (unsigned char)220,      (unsigned char)219, 
        (unsigned char)219,      (unsigned char)219,      (unsigned char)219,      (unsigned char)219, 
        (unsigned char)219,      (unsigned char)219,      (unsigned char)219,      (unsigned char)218, 
        (unsigned char)218,      (unsigned char)218,      (unsigned char)218,      (unsigned char)218, 
        (unsigned char)218,      (unsigned char)218,      (unsigned char)218,      (unsigned char)217, 
        (unsigned char)217,      (unsigned char)217,      (unsigned char)217,      (unsigned char)217, 
        (unsigned char)217,      (unsigned char)217,      (unsigned char)217,      (unsigned char)216, 
        (unsigned char)216,      (unsigned char)216,      (unsigned char)216,      (unsigned char)216, 
        (unsigned char)216,      (unsigned char)216,      (unsigned char)216,      (unsigned char)215, 
        (unsigned char)215,      (unsigned char)215,      (unsigned char)215,      (unsigned char)215, 
        (unsigned char)215,      (unsigned char)215,      (unsigned char)215,      (unsigned char)214, 
        (unsigned char)214,      (unsigned char)214,      (unsigned char)214,      (unsigned char)214, 
        (unsigned char)214,      (unsigned char)214,      (unsigned char)214,      (unsigned char)213, 
        (unsigned char)213,      (unsigned char)213,      (unsigned char)213,      (unsigned char)213, 
        (unsigned char)213,      (unsigned char)213,      (unsigned char)213,      (unsigned char)212, 
        (unsigned char)212,      (unsigned char)212,      (unsigned char)212,      (unsigned char)212, 
        (unsigned char)212,      (unsigned char)212,      (unsigned char)212,      (unsigned char)211, 
        (unsigned char)211,      (unsigned char)211,      (unsigned char)211,      (unsigned char)211, 
        (unsigned char)211,      (unsigned char)211,      (unsigned char)211,      (unsigned char)210, 
        (unsigned char)210,      (unsigned char)210,      (unsigned char)210,      (unsigned char)210, 
        (unsigned char)210,      (unsigned char)210,      (unsigned char)210,      (unsigned char)209, 
        (unsigned char)209,      (unsigned char)209,      (unsigned char)209,      (unsigned char)209, 
        (unsigned char)209,      (unsigned char)209,      (unsigned char)209,      (unsigned char)208, 
        (unsigned char)208,      (unsigned char)208,      (unsigned char)208,      (unsigned char)208, 
        (unsigned char)208,      (unsigned char)208,      (unsigned char)208,      (unsigned char)207, 
        (unsigned char)207,      (unsigned char)207,      (unsigned char)207,      (unsigned char)207, 
        (unsigned char)207,      (unsigned char)207,      (unsigned char)207,      (unsigned char)207, 
        (unsigned char)207,      (unsigned char)207,      (unsigned char)207,      (unsigned char)207, 
        (unsigned char)207,      (unsigned char)207,      (unsigned char)207,      (unsigned char)206, 
        (unsigned char)206,      (unsigned char)206,      (unsigned char)206,      (unsigned char)206, 
        (unsigned char)206,      (unsigned char)206,      (unsigned char)206,      (unsigned char)206, 
        (unsigned char)206,      (unsigned char)206,      (unsigned char)206,      (unsigned char)206, 
        (unsigned char)206,      (unsigned char)206,      (unsigned char)206,      (unsigned char)205, 
        (unsigned char)205,      (unsigned char)205,      (unsigned char)205,      (unsigned char)205, 
        (unsigned char)205,      (unsigned char)205,      (unsigned char)205,      (unsigned char)205, 
        (unsigned char)205,      (unsigned char)205,      (unsigned char)205,      (unsigned char)205, 
        (unsigned char)205,      (unsigned char)205,      (unsigned char)205,      (unsigned char)204, 
        (unsigned char)204,      (unsigned char)204,      (unsigned char)204,      (unsigned char)204, 
        (unsigned char)204,      (unsigned char)204,      (unsigned char)204,      (unsigned char)204, 
        (unsigned char)204,      (unsigned char)204,      (unsigned char)204,      (unsigned char)204, 
        (unsigned char)204,      (unsigned char)204,      (unsigned char)204,      (unsigned char)203, 
        (unsigned char)203,      (unsigned char)203,      (unsigned char)203,      (unsigned char)203, 
        (unsigned char)203,      (unsigned char)203,      (unsigned char)203,      (unsigned char)203, 
        (unsigned char)203,      (unsigned char)203,      (unsigned char)203,      (unsigned char)203, 
        (unsigned char)203,      (unsigned char)203,      (unsigned char)203,      (unsigned char)202, 
        (unsigned char)202,      (unsigned char)202,      (unsigned char)202,      (unsigned char)202, 
        (unsigned char)202,      (unsigned char)202,      (unsigned char)202,      (unsigned char)202, 
        (unsigned char)202,      (unsigned char)202,      (unsigned char)202,      (unsigned char)202, 
        (unsigned char)202,      (unsigned char)202,      (unsigned char)202,      (unsigned char)201, 
        (unsigned char)201,      (unsigned char)201,      (unsigned char)201,      (unsigned char)201, 
        (unsigned char)201,      (unsigned char)201,      (unsigned char)201,      (unsigned char)201, 
        (unsigned char)201,      (unsigned char)201,      (unsigned char)201,      (unsigned char)201, 
        (unsigned char)201,      (unsigned char)201,      (unsigned char)201,      (unsigned char)200, 
        (unsigned char)200,      (unsigned char)200,      (unsigned char)200,      (unsigned char)200, 
        (unsigned char)200,      (unsigned char)200,      (unsigned char)200,      (unsigned char)200, 
        (unsigned char)200,      (unsigned char)200,      (unsigned char)200,      (unsigned char)200, 
        (unsigned char)200,      (unsigned char)200,      (unsigned char)200,      (unsigned char)199, 
        (unsigned char)199,      (unsigned char)199,      (unsigned char)199,      (unsigned char)199, 
        (unsigned char)199,      (unsigned char)199,      (unsigned char)199,      (unsigned char)199, 
        (unsigned char)199,      (unsigned char)199,      (unsigned char)199,      (unsigned char)199, 
        (unsigned char)199,      (unsigned char)199,      (unsigned char)199,      (unsigned char)198, 
        (unsigned char)198,      (unsigned char)198,      (unsigned char)198,      (unsigned char)198, 
        (unsigned char)198,      (unsigned char)198,      (unsigned char)198,      (unsigned char)198, 
        (unsigned char)198,      (unsigned char)198,      (unsigned char)198,      (unsigned char)198, 
        (unsigned char)198,      (unsigned char)198,      (unsigned char)198,      (unsigned char)197, 
        (unsigned char)197,      (unsigned char)197,      (unsigned char)197,      (unsigned char)197, 
        (unsigned char)197,      (unsigned char)197,      (unsigned char)197,      (unsigned char)197, 
        (unsigned char)197,      (unsigned char)197,      (unsigned char)197,      (unsigned char)197, 
        (unsigned char)197,      (unsigned char)197,      (unsigned char)197,      (unsigned char)196, 
        (unsigned char)196,      (unsigned char)196,      (unsigned char)196,      (unsigned char)196, 
        (unsigned char)196,      (unsigned char)196,      (unsigned char)196,      (unsigned char)196, 
        (unsigned char)196,      (unsigned char)196,      (unsigned char)196,      (unsigned char)196, 
        (unsigned char)196,      (unsigned char)196,      (unsigned char)196,      (unsigned char)195, 
        (unsigned char)195,      (unsigned char)195,      (unsigned char)195,      (unsigned char)195, 
        (unsigned char)195,      (unsigned char)195,      (unsigned char)195,      (unsigned char)195, 
        (unsigned char)195,      (unsigned char)195,      (unsigned char)195,      (unsigned char)195, 
        (unsigned char)195,      (unsigned char)195,      (unsigned char)195,      (unsigned char)194, 
        (unsigned char)194,      (unsigned char)194,      (unsigned char)194,      (unsigned char)194, 
        (unsigned char)194,      (unsigned char)194,      (unsigned char)194,      (unsigned char)194, 
        (unsigned char)194,      (unsigned char)194,      (unsigned char)194,      (unsigned char)194, 
        (unsigned char)194,      (unsigned char)194,      (unsigned char)194,      (unsigned char)193, 
        (unsigned char)193,      (unsigned char)193,      (unsigned char)193,      (unsigned char)193, 
        (unsigned char)193,      (unsigned char)193,      (unsigned char)193,      (unsigned char)193, 
        (unsigned char)193,      (unsigned char)193,      (unsigned char)193,      (unsigned char)193, 
        (unsigned char)193,      (unsigned char)193,      (unsigned char)193,      (unsigned char)192, 
        (unsigned char)192,      (unsigned char)192,      (unsigned char)192,      (unsigned char)192, 
        (unsigned char)192,      (unsigned char)192,      (unsigned char)192,      (unsigned char)192, 
        (unsigned char)192,      (unsigned char)192,      (unsigned char)192,      (unsigned char)192, 
        (unsigned char)192,      (unsigned char)192,      (unsigned char)192,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128};
#line 794 "/root/patchweave_new/23/src/ulaw.c"
__inline static void ulaw2s_array(unsigned char *buffer , int count , short *ptr ) 
{ 


  {
  {
#line 795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 795
    count --;
#line 795
    if (! (count >= 0)) {
#line 795
      goto while_break;
    }
#line 796
    *(ptr + count) = ulaw_decode[(int )*(buffer + count)];
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 800
  return;
}
}
#line 800 "/root/patchweave_new/23/src/ulaw.c"
__inline static void ulaw2i_array(unsigned char *buffer , int count , int *ptr ) 
{ 


  {
  {
#line 801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 801
    count --;
#line 801
    if (! (count >= 0)) {
#line 801
      goto while_break;
    }
#line 802
    *(ptr + count) = (int )((uint32_t )ulaw_decode[*(buffer + count)] << 16);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 806
  return;
}
}
#line 806 "/root/patchweave_new/23/src/ulaw.c"
__inline static void ulaw2f_array(unsigned char *buffer , int count , float *ptr ,
                                  float normfact ) 
{ 


  {
  {
#line 807
  while (1) {
    while_continue: /* CIL Label */ ;
#line 807
    count --;
#line 807
    if (! (count >= 0)) {
#line 807
      goto while_break;
    }
#line 808
    *(ptr + count) = normfact * (float )((int )ulaw_decode[(int )*(buffer + count)]);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 812
  return;
}
}
#line 812 "/root/patchweave_new/23/src/ulaw.c"
__inline static void ulaw2d_array(unsigned char const   *buffer , int count , double *ptr ,
                                  double normfact ) 
{ 


  {
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    count --;
#line 813
    if (! (count >= 0)) {
#line 813
      goto while_break;
    }
#line 814
    *(ptr + count) = normfact * (double )((int )ulaw_decode[(int )*(buffer + count)]);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 818
  return;
}
}
#line 818 "/root/patchweave_new/23/src/ulaw.c"
__inline static void s2ulaw_array(short const   *ptr , int count , unsigned char *buffer ) 
{ 


  {
  {
#line 819
  while (1) {
    while_continue: /* CIL Label */ ;
#line 819
    count --;
#line 819
    if (! (count >= 0)) {
#line 819
      goto while_break;
    }
#line 820
    if ((int )*(ptr + count) >= 0) {
#line 821
      *(buffer + count) = ulaw_encode[(int )*(ptr + count) / 4];
    } else {
#line 823
      *(buffer + count) = (unsigned char )(127 & (int )ulaw_encode[(int )*(ptr + count) / -4]);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 829
  return;
}
}
#line 828 "/root/patchweave_new/23/src/ulaw.c"
__inline static void i2ulaw_array(int const   *ptr , int count , unsigned char *buffer ) 
{ 


  {
  {
#line 829
  while (1) {
    while_continue: /* CIL Label */ ;
#line 829
    count --;
#line 829
    if (! (count >= 0)) {
#line 829
      goto while_break;
    }
#line 830
    if (*(ptr + count) >= 0) {
#line 831
      *(buffer + count) = ulaw_encode[*(ptr + count) >> 18];
    } else {
#line 833
      *(buffer + count) = (unsigned char )(127 & (int )ulaw_encode[- *(ptr + count) >> 18]);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 839
  return;
}
}
#line 838 "/root/patchweave_new/23/src/ulaw.c"
__inline static void f2ulaw_array(float const   *ptr , int count , unsigned char *buffer ,
                                  float normfact ) 
{ 
  long __cil_tmp6 ;
  long tmp ;

  {
  {
#line 839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 839
    count --;
#line 839
    if (! (count >= 0)) {
#line 839
      goto while_break;
    }
#line 840
    if (*(ptr + count) >= (float const   )((float )0)) {
      {
#line 841
      tmp = lrintf(normfact * (float )*(ptr + count));
#line 841
      *(buffer + count) = (unsigned char )tmp;
      }
    } else {
      {
#line 843
      __cil_tmp6 = lrintf(normfact * (float )*(ptr + count));
#line 843
      *(buffer + count) = (unsigned char )(127 & (int )ulaw_encode[- __cil_tmp6]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 850
  return;
}
}
#line 848 "/root/patchweave_new/23/src/ulaw.c"
__inline static void d2ulaw_array(double const   *ptr , int count , unsigned char *buffer ,
                                  double normfact ) 
{ 
  long __cil_tmp6 ;
  long tmp ;

  {
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 849
    count --;
#line 849
    if (! (count >= 0)) {
#line 849
      goto while_break;
    }
#line 850
    if (*(ptr + count) >= (double const   )((double )0)) {
      {
#line 851
      tmp = lrint(normfact * (double )*(ptr + count));
#line 851
      *(buffer + count) = (unsigned char )tmp;
      }
    } else {
      {
#line 853
      __cil_tmp6 = lrint(normfact * (double )*(ptr + count));
#line 853
      *(buffer + count) = (unsigned char )(127 & (int )ulaw_encode[- __cil_tmp6]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 860
  return;
}
}
#line 861 "/root/patchweave_new/23/src/ulaw.c"
static sf_count_t ulaw_read_ulaw2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 864
  total = (sf_count_t )0;
#line 866
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 868
  while (1) {
    while_continue: /* CIL Label */ ;

#line 868
    if (! (len > 0L)) {
#line 868
      goto while_break;
    }
#line 869
    if (len < (long )bufferlen) {
#line 870
      bufferlen = (int )len;
    }
    {
#line 871
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 871
    readcount = (int )__cil_tmp8;
#line 872
    ulaw2s_array(ubuf.ucbuf, readcount, ptr + total);
#line 873
    total += (long )readcount;
    }
#line 874
    if (readcount < bufferlen) {
#line 875
      goto while_break;
    }
#line 876
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 879
  return (total);
}
}
#line 883 "/root/patchweave_new/23/src/ulaw.c"
static sf_count_t ulaw_read_ulaw2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 886
  total = (sf_count_t )0;
#line 888
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 890
  while (1) {
    while_continue: /* CIL Label */ ;

#line 890
    if (! (len > 0L)) {
#line 890
      goto while_break;
    }
#line 891
    if (len < (long )bufferlen) {
#line 892
      bufferlen = (int )len;
    }
    {
#line 893
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 893
    readcount = (int )__cil_tmp8;
#line 894
    ulaw2i_array(ubuf.ucbuf, readcount, ptr + total);
#line 895
    total += (long )readcount;
    }
#line 896
    if (readcount < bufferlen) {
#line 897
      goto while_break;
    }
#line 898
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 901
  return (total);
}
}
#line 905 "/root/patchweave_new/23/src/ulaw.c"
static sf_count_t ulaw_read_ulaw2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 908
  total = (sf_count_t )0;
#line 911
  if (psf->norm_float == 1) {
#line 911
    tmp = 1. / (double )((float )32768);
  } else {
#line 911
    tmp = 1.;
  }
#line 911
  normfact = (float )tmp;
#line 913
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 915
  while (1) {
    while_continue: /* CIL Label */ ;

#line 915
    if (! (len > 0L)) {
#line 915
      goto while_break;
    }
#line 916
    if (len < (long )bufferlen) {
#line 917
      bufferlen = (int )len;
    }
    {
#line 918
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 918
    readcount = (int )__cil_tmp10;
#line 919
    ulaw2f_array(ubuf.ucbuf, readcount, ptr + total, normfact);
#line 920
    total += (long )readcount;
    }
#line 921
    if (readcount < bufferlen) {
#line 922
      goto while_break;
    }
#line 923
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 926
  return (total);
}
}
#line 930 "/root/patchweave_new/23/src/ulaw.c"
static sf_count_t ulaw_read_ulaw2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 933
  total = (sf_count_t )0;
#line 936
  if (psf->norm_double) {
#line 936
    tmp = 1. / (double )32768;
  } else {
#line 936
    tmp = 1.;
  }
#line 936
  normfact = tmp;
#line 937
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 939
  while (1) {
    while_continue: /* CIL Label */ ;

#line 939
    if (! (len > 0L)) {
#line 939
      goto while_break;
    }
#line 940
    if (len < (long )bufferlen) {
#line 941
      bufferlen = (int )len;
    }
    {
#line 942
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 942
    readcount = (int )__cil_tmp10;
#line 943
    ulaw2d_array((unsigned char const   *)(ubuf.ucbuf), readcount, ptr + total, normfact);
#line 944
    total += (long )readcount;
    }
#line 945
    if (readcount < bufferlen) {
#line 946
      goto while_break;
    }
#line 947
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 950
  return (total);
}
}
#line 957 "/root/patchweave_new/23/src/ulaw.c"
static sf_count_t ulaw_write_s2ulaw(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 960
  total = (sf_count_t )0;
#line 962
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 964
  while (1) {
    while_continue: /* CIL Label */ ;

#line 964
    if (! (len > 0L)) {
#line 964
      goto while_break;
    }
#line 965
    if (len < (long )bufferlen) {
#line 966
      bufferlen = (int )len;
    }
    {
#line 967
    s2ulaw_array(ptr + total, bufferlen, ubuf.ucbuf);
#line 968
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 968
    writecount = (int )__cil_tmp8;
#line 969
    total += (long )writecount;
    }
#line 970
    if (writecount < bufferlen) {
#line 971
      goto while_break;
    }
#line 972
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 975
  return (total);
}
}
#line 979 "/root/patchweave_new/23/src/ulaw.c"
static sf_count_t ulaw_write_i2ulaw(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 982
  total = (sf_count_t )0;
#line 984
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 986
  while (1) {
    while_continue: /* CIL Label */ ;

#line 986
    if (! (len > 0L)) {
#line 986
      goto while_break;
    }
#line 987
    if (len < (long )bufferlen) {
#line 988
      bufferlen = (int )len;
    }
    {
#line 989
    i2ulaw_array(ptr + total, bufferlen, ubuf.ucbuf);
#line 990
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 990
    writecount = (int )__cil_tmp8;
#line 991
    total += (long )writecount;
    }
#line 992
    if (writecount < bufferlen) {
#line 993
      goto while_break;
    }
#line 994
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 997
  return (total);
}
}
#line 1001 "/root/patchweave_new/23/src/ulaw.c"
static sf_count_t ulaw_write_f2ulaw(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1004
  total = (sf_count_t )0;
#line 1008
  if (psf->norm_float == 1) {
#line 1008
    tmp = 0.25 * (double )32767;
  } else {
#line 1008
    tmp = 0.25;
  }
#line 1008
  normfact = (float )tmp;
#line 1010
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 1012
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1012
    if (! (len > 0L)) {
#line 1012
      goto while_break;
    }
#line 1013
    if (len < (long )bufferlen) {
#line 1014
      bufferlen = (int )len;
    }
    {
#line 1015
    f2ulaw_array(ptr + total, bufferlen, ubuf.ucbuf, normfact);
#line 1016
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                             psf);
#line 1016
    writecount = (int )__cil_tmp10;
#line 1017
    total += (long )writecount;
    }
#line 1018
    if (writecount < bufferlen) {
#line 1019
      goto while_break;
    }
#line 1020
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1023
  return (total);
}
}
#line 1027 "/root/patchweave_new/23/src/ulaw.c"
static sf_count_t ulaw_write_d2ulaw(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1030
  total = (sf_count_t )0;
#line 1034
  if (psf->norm_double) {
#line 1034
    tmp = 0.25 * (double )32767;
  } else {
#line 1034
    tmp = 0.25;
  }
#line 1034
  normfact = tmp;
#line 1036
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 1038
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1038
    if (! (len > 0L)) {
#line 1038
      goto while_break;
    }
#line 1039
    if (len < (long )bufferlen) {
#line 1040
      bufferlen = (int )len;
    }
    {
#line 1041
    d2ulaw_array(ptr + total, bufferlen, ubuf.ucbuf, normfact);
#line 1042
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                             psf);
#line 1042
    writecount = (int )__cil_tmp10;
#line 1043
    total += (long )writecount;
    }
#line 1044
    if (writecount < bufferlen) {
#line 1045
      goto while_break;
    }
#line 1046
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1049
  return (total);
}
}
#line 31 "/root/patchweave_new/23/src/strings.c"
int psf_store_string(SF_PRIVATE *psf , int str_type , char const   *str ) 
{ 
  char new_str[128] ;
  size_t str_len ;
  int k ;
  int str_flags ;
  char *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  char *temp ;
  size_t newlen ;
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 36
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 37
    return (60);
  }
  {
#line 39
  str_len = strlen(str);
  }
#line 42
  if (psf->file.mode == 32) {
    _L: 
#line 43
    if ((psf->strings.flags & 256U) == 0U) {
#line 44
      return (54);
    }
#line 45
    if (psf->have_written) {
#line 45
      if ((psf->strings.flags & 512U) == 0U) {
#line 46
        return (54);
      }
    }
#line 48
    if (str_type != 3) {
#line 48
      if (str_len == 0UL) {
#line 49
        return (60);
      }
    }
  } else
#line 42
  if (psf->file.mode == 48) {
#line 42
    goto _L;
  }
#line 53
  k = 0;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;

#line 53
    if (! (k < 32)) {
#line 53
      goto while_break;
    }
#line 55
    if (psf->strings.data[k].type == str_type) {
#line 56
      psf->strings.data[k].type = -1;
    }
#line 58
    if (psf->strings.data[k].type == 0) {
#line 59
      goto while_break;
    }
#line 53
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 63
  str_flags = 1024;
#line 64
  if (psf->file.mode == 48) {
    _L___0: 
#line 65
    if ((psf->strings.flags & 512U) == 0U) {
#line 66
      return (59);
    }
#line 67
    str_flags = 2048;
  } else
#line 64
  if (psf->have_written) {
#line 64
    goto _L___0;
  }
#line 71
  if (k >= 32) {
#line 72
    return (57);
  }
#line 74
  if (k == 0) {
#line 74
    if (psf->strings.storage_used != 0UL) {
      {
#line 75
      psf_log_printf(psf, "SFE_STR_WEIRD : k == 0 && psf->strings.storage_used != 0\n");
      }
#line 76
      return (61);
    }
  }
#line 79
  if (k != 0) {
#line 79
    if (psf->strings.storage_used == 0UL) {
      {
#line 80
      psf_log_printf(psf, "SFE_STR_WEIRD : k != 0 && psf->strings.storage_used == 0\n");
      }
#line 81
      return (61);
    }
  }
#line 85
  if (k == 0) {
#line 86
    psf->strings.storage_used = (size_t )0;
  }
#line 89
  if (str_type == 3) {
#line 89
    goto case_3;
  }
#line 117
  if (str_type == 16) {
#line 117
    goto case_16;
  }
#line 117
  if (str_type == 9) {
#line 117
    goto case_16;
  }
#line 117
  if (str_type == 8) {
#line 117
    goto case_16;
  }
#line 117
  if (str_type == 7) {
#line 117
    goto case_16;
  }
#line 117
  if (str_type == 6) {
#line 117
    goto case_16;
  }
#line 117
  if (str_type == 5) {
#line 117
    goto case_16;
  }
#line 117
  if (str_type == 4) {
#line 117
    goto case_16;
  }
#line 117
  if (str_type == 2) {
#line 117
    goto case_16;
  }
#line 117
  if (str_type == 1) {
#line 117
    goto case_16;
  }
#line 120
  goto switch_default;
  case_3: 
#line 91
  if (psf->file.mode == 32) {
    _L___1: 
    {
#line 92
    __cil_tmp10 = strstr(str, "libsndfile");
    }
#line 92
    if ((unsigned long )__cil_tmp10 == (unsigned long )((void *)0)) {
      {
#line 97
      __cil_tmp11 = strlen(str);
      }
#line 97
      if (__cil_tmp11 == 0UL) {
        {
#line 98
        snprintf(new_str, sizeof(new_str), "%s-%s", "libsndfile", "1.0.29pre1");
        }
      } else {
        {
#line 100
        snprintf(new_str, sizeof(new_str), "%s (%s-%s)", str, "libsndfile", "1.0.29pre1");
        }
      }
    } else {
      {
#line 103
      snprintf(new_str, sizeof(new_str), "%s", str);
      }
    }
#line 105
    str = (char const   *)(new_str);
  } else
#line 91
  if (psf->file.mode == 48) {
#line 91
    goto _L___1;
  }
#line 107
  goto switch_break;
  case_16: 
#line 118
  goto switch_break;
  switch_default: 
  {
#line 121
  psf_log_printf(psf, "%s : SFE_STR_BAD_TYPE\n", "psf_store_string\312\001@");
  }
#line 122
  return (58);
  switch_break: 
  {
#line 126
  __cil_tmp12 = strlen(str);
#line 126
  str_len = __cil_tmp12 + 1UL;
  }
#line 128
  if ((psf->strings.storage_used + str_len) + 1UL > psf->strings.storage_len) {
#line 129
    temp = psf->strings.storage;
#line 130
    newlen = (2UL * psf->strings.storage_len + str_len) + 1UL;
#line 132
    if (newlen < 256UL) {
#line 132
      tmp = 256UL;
    } else {
#line 132
      tmp = newlen;
    }
    {
#line 132
    newlen = tmp;
#line 134
    tmp___0 = realloc((void *)temp, newlen);
#line 134
    psf->strings.storage = (char *)tmp___0;
    }
#line 134
    if ((unsigned long )psf->strings.storage == (unsigned long )((void *)0)) {
#line 135
      psf->strings.storage = temp;
#line 136
      return (17);
    }
#line 139
    psf->strings.storage_len = newlen;
  }
  {
#line 142
  psf->strings.data[k].type = str_type;
#line 143
  psf->strings.data[k].offset = psf->strings.storage_used;
#line 144
  psf->strings.data[k].flags = str_flags;
#line 146
  memcpy((void *)(psf->strings.storage + psf->strings.storage_used), (void const   *)str,
         str_len);
#line 147
  psf->strings.storage_used += str_len;
#line 149
  psf->strings.flags |= (unsigned int )str_flags;
  }
#line 156
  return (0);
}
}
#line 160 "/root/patchweave_new/23/src/strings.c"
int psf_set_string(SF_PRIVATE *psf , int str_type , char const   *str ) 
{ 
  int __cil_tmp4 ;

  {
#line 161
  if (psf->file.mode == 16) {
#line 162
    return (55);
  }
  {
#line 164
  __cil_tmp4 = psf_store_string(psf, str_type, str);
  }
#line 164
  return (__cil_tmp4);
}
}
#line 168 "/root/patchweave_new/23/src/strings.c"
char const   *psf_get_string(SF_PRIVATE *psf , int str_type ) 
{ 
  int k ;

  {
#line 171
  k = 0;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;

#line 171
    if (! (k < 32)) {
#line 171
      goto while_break;
    }
#line 172
    if (str_type == psf->strings.data[k].type) {
#line 173
      return ((char const   *)(psf->strings.storage + psf->strings.data[k].offset));
    }
#line 171
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 175
  return ((char const   *)((void *)0));
}
}
#line 179 "/root/patchweave_new/23/src/strings.c"
int psf_location_string_count(SF_PRIVATE *psf , int location ) 
{ 
  int k ;
  int count ;

  {
#line 180
  count = 0;
#line 182
  k = 0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;

#line 182
    if (! (k < 32)) {
#line 182
      goto while_break;
    }
#line 183
    if (psf->strings.data[k].type > 0) {
#line 183
      if (psf->strings.data[k].flags & location) {
#line 184
        count ++;
      }
    }
#line 182
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 186
  return (count);
}
}
#line 35 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_sc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 36
static sf_count_t pcm_read_uc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 37
static sf_count_t pcm_read_bes2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 38
static sf_count_t pcm_read_les2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 39
static sf_count_t pcm_read_bet2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 40
static sf_count_t pcm_read_let2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 41
static sf_count_t pcm_read_bei2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 42
static sf_count_t pcm_read_lei2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 44
static sf_count_t pcm_read_sc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 45
static sf_count_t pcm_read_uc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 46
static sf_count_t pcm_read_bes2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 47
static sf_count_t pcm_read_les2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 48
static sf_count_t pcm_read_bet2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 49
static sf_count_t pcm_read_let2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 50
static sf_count_t pcm_read_bei2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 51
static sf_count_t pcm_read_lei2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 53
static sf_count_t pcm_read_sc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 54
static sf_count_t pcm_read_uc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 55
static sf_count_t pcm_read_bes2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 56
static sf_count_t pcm_read_les2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 57
static sf_count_t pcm_read_bet2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 58
static sf_count_t pcm_read_let2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 59
static sf_count_t pcm_read_bei2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 60
static sf_count_t pcm_read_lei2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 62
static sf_count_t pcm_read_sc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 63
static sf_count_t pcm_read_uc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 64
static sf_count_t pcm_read_bes2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 65
static sf_count_t pcm_read_les2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 66
static sf_count_t pcm_read_bet2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 67
static sf_count_t pcm_read_let2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 68
static sf_count_t pcm_read_bei2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 69
static sf_count_t pcm_read_lei2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 71
static sf_count_t pcm_write_s2sc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 72
static sf_count_t pcm_write_s2uc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 73
static sf_count_t pcm_write_s2bes(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 74
static sf_count_t pcm_write_s2les(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 75
static sf_count_t pcm_write_s2bet(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 76
static sf_count_t pcm_write_s2let(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 77
static sf_count_t pcm_write_s2bei(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 78
static sf_count_t pcm_write_s2lei(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 80
static sf_count_t pcm_write_i2sc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 81
static sf_count_t pcm_write_i2uc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 82
static sf_count_t pcm_write_i2bes(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 83
static sf_count_t pcm_write_i2les(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 84
static sf_count_t pcm_write_i2bet(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 85
static sf_count_t pcm_write_i2let(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 86
static sf_count_t pcm_write_i2bei(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 87
static sf_count_t pcm_write_i2lei(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 89
static sf_count_t pcm_write_f2sc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 90
static sf_count_t pcm_write_f2uc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 91
static sf_count_t pcm_write_f2bes(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 92
static sf_count_t pcm_write_f2les(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 93
static sf_count_t pcm_write_f2bet(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 94
static sf_count_t pcm_write_f2let(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 95
static sf_count_t pcm_write_f2bei(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 96
static sf_count_t pcm_write_f2lei(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 98
static sf_count_t pcm_write_d2sc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 99
static sf_count_t pcm_write_d2uc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 100
static sf_count_t pcm_write_d2bes(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 101
static sf_count_t pcm_write_d2les(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 102
static sf_count_t pcm_write_d2bet(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 103
static sf_count_t pcm_write_d2let(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 104
static sf_count_t pcm_write_d2bei(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 105
static sf_count_t pcm_write_d2lei(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 120 "/root/patchweave_new/23/src/pcm.c"
int pcm_init(SF_PRIVATE *psf ) 
{ 
  int chars ;
  int tmp___0 ;
  sf_count_t tmp___1 ;
  sf_count_t tmp___2 ;

  {
#line 121
  chars = 0;
#line 123
  if (psf->bytewidth == 0) {
    {
#line 124
    psf_log_printf(psf, "pcm_init : internal error : bytewitdh = %d, channels = %d\n",
                   psf->bytewidth, psf->sf.channels);
    }
#line 125
    return (30);
  } else
#line 123
  if (psf->sf.channels == 0) {
    {
#line 124
    psf_log_printf(psf, "pcm_init : internal error : bytewitdh = %d, channels = %d\n",
                   psf->bytewidth, psf->sf.channels);
    }
#line 125
    return (30);
  }
#line 128
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 130
  if ((psf->sf.format & 65535) == 1) {
#line 131
    chars = 200;
  } else
#line 132
  if ((psf->sf.format & 65535) == 5) {
#line 133
    chars = 201;
  }
#line 138
  if (psf->endian == 268435456) {
#line 138
    tmp___0 = 0;
  } else {
#line 138
    tmp___0 = 1;
  }
#line 138
  psf->data_endswap = tmp___0;
#line 140
  if (psf->file.mode == 16) {
    _L: 
#line 143
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268501192) {
#line 143
      goto case_268501192;
    }
#line 143
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 536936648) {
#line 143
      goto case_268501192;
    }
#line 150
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268501193) {
#line 150
      goto case_268501193;
    }
#line 150
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 536936649) {
#line 150
      goto case_268501193;
    }
#line 157
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537001984) {
#line 157
      goto case_537001984;
    }
#line 163
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537067520) {
#line 163
      goto case_537067520;
    }
#line 169
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537133056) {
#line 169
      goto case_537133056;
    }
#line 177
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268566528) {
#line 177
      goto case_268566528;
    }
#line 183
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268632064) {
#line 183
      goto case_268632064;
    }
#line 189
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268697600) {
#line 189
      goto case_268697600;
    }
#line 195
    goto switch_default;
    case_268501192: 
#line 144
    psf->read_short = & pcm_read_sc2s;
#line 145
    psf->read_int = & pcm_read_sc2i;
#line 146
    psf->read_float = & pcm_read_sc2f;
#line 147
    psf->read_double = & pcm_read_sc2d;
#line 148
    goto switch_break;
    case_268501193: 
#line 151
    psf->read_short = & pcm_read_uc2s;
#line 152
    psf->read_int = & pcm_read_uc2i;
#line 153
    psf->read_float = & pcm_read_uc2f;
#line 154
    psf->read_double = & pcm_read_uc2d;
#line 155
    goto switch_break;
    case_537001984: 
#line 158
    psf->read_short = & pcm_read_bes2s;
#line 159
    psf->read_int = & pcm_read_bes2i;
#line 160
    psf->read_float = & pcm_read_bes2f;
#line 161
    psf->read_double = & pcm_read_bes2d;
#line 162
    goto switch_break;
    case_537067520: 
#line 164
    psf->read_short = & pcm_read_bet2s;
#line 165
    psf->read_int = & pcm_read_bet2i;
#line 166
    psf->read_float = & pcm_read_bet2f;
#line 167
    psf->read_double = & pcm_read_bet2d;
#line 168
    goto switch_break;
    case_537133056: 
#line 171
    psf->read_short = & pcm_read_bei2s;
#line 172
    psf->read_int = & pcm_read_bei2i;
#line 173
    psf->read_float = & pcm_read_bei2f;
#line 174
    psf->read_double = & pcm_read_bei2d;
#line 175
    goto switch_break;
    case_268566528: 
#line 178
    psf->read_short = & pcm_read_les2s;
#line 179
    psf->read_int = & pcm_read_les2i;
#line 180
    psf->read_float = & pcm_read_les2f;
#line 181
    psf->read_double = & pcm_read_les2d;
#line 182
    goto switch_break;
    case_268632064: 
#line 184
    psf->read_short = & pcm_read_let2s;
#line 185
    psf->read_int = & pcm_read_let2i;
#line 186
    psf->read_float = & pcm_read_let2f;
#line 187
    psf->read_double = & pcm_read_let2d;
#line 188
    goto switch_break;
    case_268697600: 
#line 190
    psf->read_short = & pcm_read_lei2s;
#line 191
    psf->read_int = & pcm_read_lei2i;
#line 192
    psf->read_float = & pcm_read_lei2f;
#line 193
    psf->read_double = & pcm_read_lei2d;
#line 194
    goto switch_break;
    switch_default: 
    {
#line 196
    psf_log_printf(psf, "pcm.c returning SFE_UNIMPLEMENTED\nbytewidth %d    endian %d\n",
                   psf->bytewidth, psf->endian);
    }
#line 197
    return (18);
    switch_break: ;
  } else
#line 140
  if (psf->file.mode == 48) {
#line 140
    goto _L;
  }
#line 201
  if (psf->file.mode == 32) {
    _L___2: 
#line 204
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268501192) {
#line 204
      goto case_268501192___0;
    }
#line 204
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 536936648) {
#line 204
      goto case_268501192___0;
    }
#line 211
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268501193) {
#line 211
      goto case_268501193___0;
    }
#line 211
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 536936649) {
#line 211
      goto case_268501193___0;
    }
#line 218
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537001984) {
#line 218
      goto case_537001984___0;
    }
#line 225
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537067520) {
#line 225
      goto case_537067520___0;
    }
#line 232
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537133056) {
#line 232
      goto case_537133056___0;
    }
#line 239
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268566528) {
#line 239
      goto case_268566528___0;
    }
#line 246
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268632064) {
#line 246
      goto case_268632064___0;
    }
#line 253
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268697600) {
#line 253
      goto case_268697600___0;
    }
#line 260
    goto switch_default___0;
    case_268501192___0: 
#line 205
    psf->write_short = & pcm_write_s2sc;
#line 206
    psf->write_int = & pcm_write_i2sc;
#line 207
    psf->write_float = & pcm_write_f2sc;
#line 208
    psf->write_double = & pcm_write_d2sc;
#line 209
    goto switch_break___0;
    case_268501193___0: 
#line 212
    psf->write_short = & pcm_write_s2uc;
#line 213
    psf->write_int = & pcm_write_i2uc;
#line 214
    psf->write_float = & pcm_write_f2uc;
#line 215
    psf->write_double = & pcm_write_d2uc;
#line 216
    goto switch_break___0;
    case_537001984___0: 
#line 219
    psf->write_short = & pcm_write_s2bes;
#line 220
    psf->write_int = & pcm_write_i2bes;
#line 221
    psf->write_float = & pcm_write_f2bes;
#line 222
    psf->write_double = & pcm_write_d2bes;
#line 223
    goto switch_break___0;
    case_537067520___0: 
#line 226
    psf->write_short = & pcm_write_s2bet;
#line 227
    psf->write_int = & pcm_write_i2bet;
#line 228
    psf->write_float = & pcm_write_f2bet;
#line 229
    psf->write_double = & pcm_write_d2bet;
#line 230
    goto switch_break___0;
    case_537133056___0: 
#line 233
    psf->write_short = & pcm_write_s2bei;
#line 234
    psf->write_int = & pcm_write_i2bei;
#line 235
    psf->write_float = & pcm_write_f2bei;
#line 236
    psf->write_double = & pcm_write_d2bei;
#line 237
    goto switch_break___0;
    case_268566528___0: 
#line 240
    psf->write_short = & pcm_write_s2les;
#line 241
    psf->write_int = & pcm_write_i2les;
#line 242
    psf->write_float = & pcm_write_f2les;
#line 243
    psf->write_double = & pcm_write_d2les;
#line 244
    goto switch_break___0;
    case_268632064___0: 
#line 247
    psf->write_short = & pcm_write_s2let;
#line 248
    psf->write_int = & pcm_write_i2let;
#line 249
    psf->write_float = & pcm_write_f2let;
#line 250
    psf->write_double = & pcm_write_d2let;
#line 251
    goto switch_break___0;
    case_268697600___0: 
#line 254
    psf->write_short = & pcm_write_s2lei;
#line 255
    psf->write_int = & pcm_write_i2lei;
#line 256
    psf->write_float = & pcm_write_f2lei;
#line 257
    psf->write_double = & pcm_write_d2lei;
#line 258
    goto switch_break___0;
    switch_default___0: 
    {
#line 261
    psf_log_printf(psf, "pcm.c returning SFE_UNIMPLEMENTED\nbytewidth %d    endian %d\n",
                   psf->bytewidth, psf->endian);
    }
#line 262
    return (18);
    switch_break___0: ;
  } else
#line 201
  if (psf->file.mode == 48) {
#line 201
    goto _L___2;
  }
#line 267
  if (psf->filelength > psf->dataoffset) {
#line 268
    if (psf->dataend > 0L) {
#line 268
      tmp___1 = psf->dataend - psf->dataoffset;
    } else {
#line 268
      tmp___1 = psf->filelength - psf->dataoffset;
    }
#line 268
    psf->datalength = tmp___1;
  } else {
#line 272
    psf->datalength = (sf_count_t )0;
  }
#line 274
  if (psf->blockwidth > 0) {
#line 274
    tmp___2 = psf->datalength / (long )psf->blockwidth;
  } else {
#line 274
    tmp___2 = 0L;
  }
#line 274
  psf->sf.frames = tmp___2;
#line 276
  return (0);
}
}
#line 283 "/root/patchweave_new/23/src/pcm.c"
__inline static void sc2s_array(signed char *src , int count , short *dest ) 
{ 


  {
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    count --;
#line 284
    if (! (count >= 0)) {
#line 284
      goto while_break;
    }
#line 285
    *(dest + count) = (short )((int )((uint16_t )*(src + count)) << 8);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 290
  return;
}
}
#line 290 "/root/patchweave_new/23/src/pcm.c"
__inline static void uc2s_array(unsigned char *src , int count , short *dest ) 
{ 


  {
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    count --;
#line 291
    if (! (count >= 0)) {
#line 291
      goto while_break;
    }
#line 292
    *(dest + count) = (short )(((uint32_t )*(src + count) - 128U) << 8);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 297
  return;
}
}
#line 297 "/root/patchweave_new/23/src/pcm.c"
__inline static void let2s_array(tribyte *src , int count , short *dest ) 
{ 
  unsigned char *ucptr ;

  {
#line 300
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    count --;
#line 301
    if (! (count >= 0)) {
#line 301
      goto while_break;
    }
#line 302
    ucptr -= 3;
#line 303
    *(dest + count) = (short )((int )*(ucptr + 1) + ((int )*(ucptr + 2) << 8));
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 308
  return;
}
}
#line 308 "/root/patchweave_new/23/src/pcm.c"
__inline static void bet2s_array(tribyte *src , int count , short *dest ) 
{ 
  unsigned char *ucptr ;

  {
#line 311
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    count --;
#line 312
    if (! (count >= 0)) {
#line 312
      goto while_break;
    }
#line 313
    ucptr -= 3;
#line 314
    *(dest + count) = (short )(((int )*(ucptr + 0) << 8) + (int )*(ucptr + 1));
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 319
  return;
}
}
#line 319 "/root/patchweave_new/23/src/pcm.c"
__inline static void lei2s_array(int *src , int count , short *dest ) 
{ 
  int value ;

  {
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    count --;
#line 322
    if (! (count >= 0)) {
#line 322
      goto while_break;
    }
#line 323
    value = *(src + count);
#line 324
    *(dest + count) = (short )(value >> 16);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 329
  return;
}
}
#line 329 "/root/patchweave_new/23/src/pcm.c"
__inline static void bei2s_array(int *src , int count , short *dest ) 
{ 
  int value ;

  {
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    count --;
#line 332
    if (! (count >= 0)) {
#line 332
      goto while_break;
    }
    {
#line 333
    value = ENDSWAP_32(*(src + count));
#line 334
    *(dest + count) = (short )(value >> 16);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 340
  return;
}
}
#line 342 "/root/patchweave_new/23/src/pcm.c"
__inline static void sc2i_array(signed char *src , int count , int *dest ) 
{ 


  {
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    count --;
#line 343
    if (! (count >= 0)) {
#line 343
      goto while_break;
    }
    {
#line 344
    *(dest + count) = arith_shift_left((int )*(src + count), 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 350
  return;
}
}
#line 349 "/root/patchweave_new/23/src/pcm.c"
__inline static void uc2i_array(unsigned char *src , int count , int *dest ) 
{ 


  {
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    count --;
#line 350
    if (! (count >= 0)) {
#line 350
      goto while_break;
    }
    {
#line 351
    *(dest + count) = arith_shift_left((int )*(src + count) - 128, 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 357
  return;
}
}
#line 356 "/root/patchweave_new/23/src/pcm.c"
__inline static void bes2i_array(short *src , int count , int *dest ) 
{ 
  short value ;

  {
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    count --;
#line 359
    if (! (count >= 0)) {
#line 359
      goto while_break;
    }
    {
#line 360
    value = ENDSWAP_16(*(src + count));
#line 361
    *(dest + count) = arith_shift_left((int32_t )value, 16);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 367
  return;
}
}
#line 366 "/root/patchweave_new/23/src/pcm.c"
__inline static void les2i_array(short *src , int count , int *dest ) 
{ 
  short value ;

  {
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    count --;
#line 369
    if (! (count >= 0)) {
#line 369
      goto while_break;
    }
    {
#line 370
    value = *(src + count);
#line 371
    *(dest + count) = arith_shift_left((int32_t )value, 16);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 377
  return;
}
}
#line 376 "/root/patchweave_new/23/src/pcm.c"
__inline static void bet2i_array(tribyte *src , int count , int *dest ) 
{ 
  unsigned char *ucptr ;

  {
#line 379
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    count --;
#line 380
    if (! (count >= 0)) {
#line 380
      goto while_break;
    }
    {
#line 381
    ucptr -= 3;
#line 382
    *(dest + count) = psf_get_be24(ucptr, 0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 388
  return;
}
}
#line 387 "/root/patchweave_new/23/src/pcm.c"
__inline static void let2i_array(tribyte *src , int count , int *dest ) 
{ 
  unsigned char *ucptr ;

  {
#line 390
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    count --;
#line 391
    if (! (count >= 0)) {
#line 391
      goto while_break;
    }
    {
#line 392
    ucptr -= 3;
#line 393
    *(dest + count) = psf_get_le24(ucptr, 0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 399
  return;
}
}
#line 401 "/root/patchweave_new/23/src/pcm.c"
__inline static void sc2f_array(signed char *src , int count , float *dest , float normfact ) 
{ 


  {
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    count --;
#line 402
    if (! (count >= 0)) {
#line 402
      goto while_break;
    }
#line 403
    *(dest + count) = (float )*(src + count) * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 407
  return;
}
}
#line 407 "/root/patchweave_new/23/src/pcm.c"
__inline static void uc2f_array(unsigned char *src , int count , float *dest , float normfact ) 
{ 


  {
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    count --;
#line 408
    if (! (count >= 0)) {
#line 408
      goto while_break;
    }
#line 409
    *(dest + count) = (float )((int )*(src + count) - 128) * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 413
  return;
}
}
#line 413 "/root/patchweave_new/23/src/pcm.c"
__inline static void les2f_array(short *src , int count , float *dest , float normfact ) 
{ 
  short value ;

  {
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    count --;
#line 416
    if (! (count >= 0)) {
#line 416
      goto while_break;
    }
#line 417
    value = *(src + count);
#line 418
    value = value;
#line 419
    *(dest + count) = (float )value * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 424
  return;
}
}
#line 424 "/root/patchweave_new/23/src/pcm.c"
__inline static void bes2f_array(short *src , int count , float *dest , float normfact ) 
{ 
  short value ;

  {
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    count --;
#line 427
    if (! (count >= 0)) {
#line 427
      goto while_break;
    }
    {
#line 428
    value = *(src + count);
#line 429
    value = ENDSWAP_16(value);
#line 430
    *(dest + count) = (float )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 436
  return;
}
}
#line 435 "/root/patchweave_new/23/src/pcm.c"
__inline static void let2f_array(tribyte *src , int count , float *dest , float normfact ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 439
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    count --;
#line 440
    if (! (count >= 0)) {
#line 440
      goto while_break;
    }
    {
#line 441
    ucptr -= 3;
#line 442
    value = psf_get_le24(ucptr, 0);
#line 443
    *(dest + count) = (float )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 449
  return;
}
}
#line 448 "/root/patchweave_new/23/src/pcm.c"
__inline static void bet2f_array(tribyte *src , int count , float *dest , float normfact ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 452
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    count --;
#line 453
    if (! (count >= 0)) {
#line 453
      goto while_break;
    }
    {
#line 454
    ucptr -= 3;
#line 455
    value = psf_get_be24(ucptr, 0);
#line 456
    *(dest + count) = (float )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 462
  return;
}
}
#line 461 "/root/patchweave_new/23/src/pcm.c"
__inline static void lei2f_array(int *src , int count , float *dest , float normfact ) 
{ 
  int value ;

  {
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    count --;
#line 464
    if (! (count >= 0)) {
#line 464
      goto while_break;
    }
#line 465
    value = *(src + count);
#line 466
    value = value;
#line 467
    *(dest + count) = (float )value * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 472
  return;
}
}
#line 472 "/root/patchweave_new/23/src/pcm.c"
__inline static void bei2f_array(int *src , int count , float *dest , float normfact ) 
{ 
  int value ;

  {
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    count --;
#line 475
    if (! (count >= 0)) {
#line 475
      goto while_break;
    }
    {
#line 476
    value = *(src + count);
#line 477
    value = ENDSWAP_32(value);
#line 478
    *(dest + count) = (float )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 484
  return;
}
}
#line 486 "/root/patchweave_new/23/src/pcm.c"
__inline static void sc2d_array(signed char *src , int count , double *dest , double normfact ) 
{ 


  {
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    count --;
#line 487
    if (! (count >= 0)) {
#line 487
      goto while_break;
    }
#line 488
    *(dest + count) = (double )*(src + count) * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 492
  return;
}
}
#line 492 "/root/patchweave_new/23/src/pcm.c"
__inline static void uc2d_array(unsigned char *src , int count , double *dest , double normfact ) 
{ 


  {
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    count --;
#line 493
    if (! (count >= 0)) {
#line 493
      goto while_break;
    }
#line 494
    *(dest + count) = (double )((int )*(src + count) - 128) * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 498
  return;
}
}
#line 498 "/root/patchweave_new/23/src/pcm.c"
__inline static void les2d_array(short *src , int count , double *dest , double normfact ) 
{ 
  short value ;

  {
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    count --;
#line 501
    if (! (count >= 0)) {
#line 501
      goto while_break;
    }
#line 502
    value = *(src + count);
#line 503
    value = value;
#line 504
    *(dest + count) = (double )value * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 509
  return;
}
}
#line 509 "/root/patchweave_new/23/src/pcm.c"
__inline static void bes2d_array(short *src , int count , double *dest , double normfact ) 
{ 
  short value ;

  {
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    count --;
#line 512
    if (! (count >= 0)) {
#line 512
      goto while_break;
    }
    {
#line 513
    value = *(src + count);
#line 514
    value = ENDSWAP_16(value);
#line 515
    *(dest + count) = (double )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 521
  return;
}
}
#line 520 "/root/patchweave_new/23/src/pcm.c"
__inline static void let2d_array(tribyte *src , int count , double *dest , double normfact ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 524
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    count --;
#line 525
    if (! (count >= 0)) {
#line 525
      goto while_break;
    }
    {
#line 526
    ucptr -= 3;
#line 527
    value = psf_get_le24(ucptr, 0);
#line 528
    *(dest + count) = (double )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 534
  return;
}
}
#line 533 "/root/patchweave_new/23/src/pcm.c"
__inline static void bet2d_array(tribyte *src , int count , double *dest , double normfact ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 537
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    count --;
#line 538
    if (! (count >= 0)) {
#line 538
      goto while_break;
    }
    {
#line 539
    ucptr -= 3;
#line 540
    value = psf_get_be24(ucptr, 0);
#line 541
    *(dest + count) = (double )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 547
  return;
}
}
#line 546 "/root/patchweave_new/23/src/pcm.c"
__inline static void lei2d_array(int *src , int count , double *dest , double normfact ) 
{ 
  int value ;

  {
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;
#line 549
    count --;
#line 549
    if (! (count >= 0)) {
#line 549
      goto while_break;
    }
#line 550
    value = *(src + count);
#line 551
    value = value;
#line 552
    *(dest + count) = (double )value * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 557
  return;
}
}
#line 557 "/root/patchweave_new/23/src/pcm.c"
__inline static void bei2d_array(int *src , int count , double *dest , double normfact ) 
{ 
  int value ;

  {
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    count --;
#line 560
    if (! (count >= 0)) {
#line 560
      goto while_break;
    }
    {
#line 561
    value = *(src + count);
#line 562
    value = ENDSWAP_32(value);
#line 563
    *(dest + count) = (double )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 569
  return;
}
}
#line 571 "/root/patchweave_new/23/src/pcm.c"
__inline static void s2sc_array(short const   *src , signed char *dest , int count ) 
{ 


  {
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 572
    count --;
#line 572
    if (! (count >= 0)) {
#line 572
      goto while_break;
    }
#line 573
    *(dest + count) = (signed char )((int )*(src + count) >> 8);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 577
  return;
}
}
#line 577 "/root/patchweave_new/23/src/pcm.c"
__inline static void s2uc_array(short const   *src , unsigned char *dest , int count ) 
{ 


  {
  {
#line 578
  while (1) {
    while_continue: /* CIL Label */ ;
#line 578
    count --;
#line 578
    if (! (count >= 0)) {
#line 578
      goto while_break;
    }
#line 579
    *(dest + count) = (unsigned char )(((int )*(src + count) >> 8) + 128);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 583
  return;
}
}
#line 583 "/root/patchweave_new/23/src/pcm.c"
__inline static void s2let_array(short const   *src , tribyte *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 586
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 587
    count --;
#line 587
    if (! (count >= 0)) {
#line 587
      goto while_break;
    }
#line 588
    ucptr -= 3;
#line 589
    *(ucptr + 0) = (unsigned char)0;
#line 590
    *(ucptr + 1) = (unsigned char )*(src + count);
#line 591
    *(ucptr + 2) = (unsigned char )((int )*(src + count) >> 8);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 596
  return;
}
}
#line 596 "/root/patchweave_new/23/src/pcm.c"
__inline static void s2bet_array(short const   *src , tribyte *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 599
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 600
    count --;
#line 600
    if (! (count >= 0)) {
#line 600
      goto while_break;
    }
#line 601
    ucptr -= 3;
#line 602
    *(ucptr + 2) = (unsigned char)0;
#line 603
    *(ucptr + 1) = (unsigned char )*(src + count);
#line 604
    *(ucptr + 0) = (unsigned char )((int )*(src + count) >> 8);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 609
  return;
}
}
#line 609 "/root/patchweave_new/23/src/pcm.c"
__inline static void s2lei_array(short const   *src , int *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 612
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    count --;
#line 613
    if (! (count >= 0)) {
#line 613
      goto while_break;
    }
#line 614
    ucptr -= 4;
#line 615
    *(ucptr + 0) = (unsigned char)0;
#line 616
    *(ucptr + 1) = (unsigned char)0;
#line 617
    *(ucptr + 2) = (unsigned char )*(src + count);
#line 618
    *(ucptr + 3) = (unsigned char )((int )*(src + count) >> 8);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 623
  return;
}
}
#line 623 "/root/patchweave_new/23/src/pcm.c"
__inline static void s2bei_array(short const   *src , int *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 626
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    count --;
#line 627
    if (! (count >= 0)) {
#line 627
      goto while_break;
    }
#line 628
    ucptr -= 4;
#line 629
    *(ucptr + 0) = (unsigned char )((int )*(src + count) >> 8);
#line 630
    *(ucptr + 1) = (unsigned char )*(src + count);
#line 631
    *(ucptr + 2) = (unsigned char)0;
#line 632
    *(ucptr + 3) = (unsigned char)0;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 637
  return;
}
}
#line 640 "/root/patchweave_new/23/src/pcm.c"
__inline static void i2sc_array(int const   *src , signed char *dest , int count ) 
{ 


  {
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 641
    count --;
#line 641
    if (! (count >= 0)) {
#line 641
      goto while_break;
    }
#line 642
    *(dest + count) = (signed char )(*(src + count) >> 24);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 646
  return;
}
}
#line 646 "/root/patchweave_new/23/src/pcm.c"
__inline static void i2uc_array(int const   *src , unsigned char *dest , int count ) 
{ 


  {
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 647
    count --;
#line 647
    if (! (count >= 0)) {
#line 647
      goto while_break;
    }
#line 648
    *(dest + count) = (unsigned char )((*(src + count) >> 24) + 128);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 652
  return;
}
}
#line 652 "/root/patchweave_new/23/src/pcm.c"
__inline static void i2bes_array(int const   *src , short *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 655
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    count --;
#line 656
    if (! (count >= 0)) {
#line 656
      goto while_break;
    }
#line 657
    ucptr -= 2;
#line 658
    *(ucptr + 0) = (unsigned char )(*(src + count) >> 24);
#line 659
    *(ucptr + 1) = (unsigned char )(*(src + count) >> 16);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 664
  return;
}
}
#line 664 "/root/patchweave_new/23/src/pcm.c"
__inline static void i2les_array(int const   *src , short *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 667
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 668
    count --;
#line 668
    if (! (count >= 0)) {
#line 668
      goto while_break;
    }
#line 669
    ucptr -= 2;
#line 670
    *(ucptr + 0) = (unsigned char )(*(src + count) >> 16);
#line 671
    *(ucptr + 1) = (unsigned char )(*(src + count) >> 24);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 676
  return;
}
}
#line 676 "/root/patchweave_new/23/src/pcm.c"
__inline static void i2let_array(int const   *src , tribyte *dest , int count ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 680
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 681
    count --;
#line 681
    if (! (count >= 0)) {
#line 681
      goto while_break;
    }
#line 682
    ucptr -= 3;
#line 683
    value = (int )(*(src + count) >> 8);
#line 684
    *(ucptr + 0) = (unsigned char )value;
#line 685
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 686
    *(ucptr + 2) = (unsigned char )(value >> 16);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 691
  return;
}
}
#line 691 "/root/patchweave_new/23/src/pcm.c"
__inline static void i2bet_array(int const   *src , tribyte *dest , int count ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 695
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 696
    count --;
#line 696
    if (! (count >= 0)) {
#line 696
      goto while_break;
    }
#line 697
    ucptr -= 3;
#line 698
    value = (int )(*(src + count) >> 8);
#line 699
    *(ucptr + 2) = (unsigned char )value;
#line 700
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 701
    *(ucptr + 0) = (unsigned char )(value >> 16);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 706
  return;
}
}
#line 709 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_sc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 712
  total = (sf_count_t )0;
#line 714
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;

#line 716
    if (! (len > 0L)) {
#line 716
      goto while_break;
    }
#line 717
    if (len < (long )bufferlen) {
#line 718
      bufferlen = (int )len;
    }
    {
#line 719
    __cil_tmp8 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                           (sf_count_t )bufferlen, psf);
#line 719
    readcount = (int )__cil_tmp8;
#line 720
    sc2s_array(ubuf.scbuf, readcount, ptr + total);
#line 721
    total += (long )readcount;
    }
#line 722
    if (readcount < bufferlen) {
#line 723
      goto while_break;
    }
#line 724
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 727
  return (total);
}
}
#line 731 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_uc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 734
  total = (sf_count_t )0;
#line 736
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 738
  while (1) {
    while_continue: /* CIL Label */ ;

#line 738
    if (! (len > 0L)) {
#line 738
      goto while_break;
    }
#line 739
    if (len < (long )bufferlen) {
#line 740
      bufferlen = (int )len;
    }
    {
#line 741
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )sizeof(unsigned char ),
                           (sf_count_t )bufferlen, psf);
#line 741
    readcount = (int )__cil_tmp8;
#line 742
    uc2s_array(ubuf.ucbuf, readcount, ptr + total);
#line 743
    total += (long )readcount;
    }
#line 744
    if (readcount < bufferlen) {
#line 745
      goto while_break;
    }
#line 746
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 749
  return (total);
}
}
#line 753 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_bes2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int total ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 756
  __cil_tmp5 = psf_fread((void *)ptr, (sf_count_t )sizeof(short ), len, psf);
#line 756
  total = (int )__cil_tmp5;
#line 758
  endswap_short_array(ptr, (int )len);
  }
#line 760
  return ((sf_count_t )total);
}
}
#line 764 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_les2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int total ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 767
  __cil_tmp5 = psf_fread((void *)ptr, (sf_count_t )sizeof(short ), len, psf);
#line 767
  total = (int )__cil_tmp5;
  }
#line 771
  return ((sf_count_t )total);
}
}
#line 775 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_bet2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 778
  total = (sf_count_t )0;
#line 780
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;

#line 782
    if (! (len > 0L)) {
#line 782
      goto while_break;
    }
#line 783
    if (len < (long )bufferlen) {
#line 784
      bufferlen = (int )len;
    }
    {
#line 785
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 785
    readcount = (int )__cil_tmp8;
#line 786
    bet2s_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total);
#line 787
    total += (long )readcount;
    }
#line 788
    if (readcount < bufferlen) {
#line 789
      goto while_break;
    }
#line 790
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 793
  return (total);
}
}
#line 797 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_let2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 800
  total = (sf_count_t )0;
#line 802
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 804
  while (1) {
    while_continue: /* CIL Label */ ;

#line 804
    if (! (len > 0L)) {
#line 804
      goto while_break;
    }
#line 805
    if (len < (long )bufferlen) {
#line 806
      bufferlen = (int )len;
    }
    {
#line 807
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 807
    readcount = (int )__cil_tmp8;
#line 808
    let2s_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total);
#line 809
    total += (long )readcount;
    }
#line 810
    if (readcount < bufferlen) {
#line 811
      goto while_break;
    }
#line 812
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 815
  return (total);
}
}
#line 819 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_bei2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 822
  total = (sf_count_t )0;
#line 824
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;

#line 826
    if (! (len > 0L)) {
#line 826
      goto while_break;
    }
#line 827
    if (len < (long )bufferlen) {
#line 828
      bufferlen = (int )len;
    }
    {
#line 829
    __cil_tmp8 = psf_fread((void *)(ubuf.ibuf), (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                           psf);
#line 829
    readcount = (int )__cil_tmp8;
#line 830
    bei2s_array(ubuf.ibuf, readcount, ptr + total);
#line 831
    total += (long )readcount;
    }
#line 832
    if (readcount < bufferlen) {
#line 833
      goto while_break;
    }
#line 834
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 837
  return (total);
}
}
#line 841 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_lei2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 844
  total = (sf_count_t )0;
#line 846
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 848
  while (1) {
    while_continue: /* CIL Label */ ;

#line 848
    if (! (len > 0L)) {
#line 848
      goto while_break;
    }
#line 849
    if (len < (long )bufferlen) {
#line 850
      bufferlen = (int )len;
    }
    {
#line 851
    __cil_tmp8 = psf_fread((void *)(ubuf.ibuf), (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                           psf);
#line 851
    readcount = (int )__cil_tmp8;
#line 852
    lei2s_array(ubuf.ibuf, readcount, ptr + total);
#line 853
    total += (long )readcount;
    }
#line 854
    if (readcount < bufferlen) {
#line 855
      goto while_break;
    }
#line 856
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 859
  return (total);
}
}
#line 866 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_sc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 869
  total = (sf_count_t )0;
#line 871
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;

#line 873
    if (! (len > 0L)) {
#line 873
      goto while_break;
    }
#line 874
    if (len < (long )bufferlen) {
#line 875
      bufferlen = (int )len;
    }
    {
#line 876
    __cil_tmp8 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                           (sf_count_t )bufferlen, psf);
#line 876
    readcount = (int )__cil_tmp8;
#line 877
    sc2i_array(ubuf.scbuf, readcount, ptr + total);
#line 878
    total += (long )readcount;
    }
#line 879
    if (readcount < bufferlen) {
#line 880
      goto while_break;
    }
#line 881
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 884
  return (total);
}
}
#line 888 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_uc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 891
  total = (sf_count_t )0;
#line 893
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 895
  while (1) {
    while_continue: /* CIL Label */ ;

#line 895
    if (! (len > 0L)) {
#line 895
      goto while_break;
    }
#line 896
    if (len < (long )bufferlen) {
#line 897
      bufferlen = (int )len;
    }
    {
#line 898
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )sizeof(unsigned char ),
                           (sf_count_t )bufferlen, psf);
#line 898
    readcount = (int )__cil_tmp8;
#line 899
    uc2i_array(ubuf.ucbuf, readcount, ptr + total);
#line 900
    total += (long )readcount;
    }
#line 901
    if (readcount < bufferlen) {
#line 902
      goto while_break;
    }
#line 903
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 906
  return (total);
}
}
#line 910 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_bes2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 913
  total = (sf_count_t )0;
#line 915
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 917
  while (1) {
    while_continue: /* CIL Label */ ;

#line 917
    if (! (len > 0L)) {
#line 917
      goto while_break;
    }
#line 918
    if (len < (long )bufferlen) {
#line 919
      bufferlen = (int )len;
    }
    {
#line 920
    __cil_tmp8 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 920
    readcount = (int )__cil_tmp8;
#line 921
    bes2i_array(ubuf.sbuf, readcount, ptr + total);
#line 922
    total += (long )readcount;
    }
#line 923
    if (readcount < bufferlen) {
#line 924
      goto while_break;
    }
#line 925
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 928
  return (total);
}
}
#line 932 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_les2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 935
  total = (sf_count_t )0;
#line 937
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 939
  while (1) {
    while_continue: /* CIL Label */ ;

#line 939
    if (! (len > 0L)) {
#line 939
      goto while_break;
    }
#line 940
    if (len < (long )bufferlen) {
#line 941
      bufferlen = (int )len;
    }
    {
#line 942
    __cil_tmp8 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 942
    readcount = (int )__cil_tmp8;
#line 943
    les2i_array(ubuf.sbuf, readcount, ptr + total);
#line 944
    total += (long )readcount;
    }
#line 945
    if (readcount < bufferlen) {
#line 946
      goto while_break;
    }
#line 947
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 950
  return (total);
}
}
#line 954 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_bet2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 957
  total = (sf_count_t )0;
#line 959
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;

#line 961
    if (! (len > 0L)) {
#line 961
      goto while_break;
    }
#line 962
    if (len < (long )bufferlen) {
#line 963
      bufferlen = (int )len;
    }
    {
#line 964
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 964
    readcount = (int )__cil_tmp8;
#line 965
    bet2i_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total);
#line 966
    total += (long )readcount;
    }
#line 967
    if (readcount < bufferlen) {
#line 968
      goto while_break;
    }
#line 969
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 972
  return (total);
}
}
#line 976 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_let2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 979
  total = (sf_count_t )0;
#line 981
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 983
  while (1) {
    while_continue: /* CIL Label */ ;

#line 983
    if (! (len > 0L)) {
#line 983
      goto while_break;
    }
#line 984
    if (len < (long )bufferlen) {
#line 985
      bufferlen = (int )len;
    }
    {
#line 986
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 986
    readcount = (int )__cil_tmp8;
#line 987
    let2i_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total);
#line 988
    total += (long )readcount;
    }
#line 989
    if (readcount < bufferlen) {
#line 990
      goto while_break;
    }
#line 991
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 994
  return (total);
}
}
#line 998 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_bei2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int total ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 1001
  __cil_tmp5 = psf_fread((void *)ptr, (sf_count_t )sizeof(int ), len, psf);
#line 1001
  total = (int )__cil_tmp5;
#line 1003
  endswap_int_array(ptr, (int )len);
  }
#line 1005
  return ((sf_count_t )total);
}
}
#line 1009 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_lei2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int total ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 1012
  __cil_tmp5 = psf_fread((void *)ptr, (sf_count_t )sizeof(int ), len, psf);
#line 1012
  total = (int )__cil_tmp5;
  }
#line 1016
  return ((sf_count_t )total);
}
}
#line 1023 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_sc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1026
  total = (sf_count_t )0;
#line 1029
  if (psf->norm_float == 1) {
#line 1029
    tmp = 1. / (double )((float )128);
  } else {
#line 1029
    tmp = 1.;
  }
#line 1029
  normfact = (float )tmp;
#line 1031
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 1033
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1033
    if (! (len > 0L)) {
#line 1033
      goto while_break;
    }
#line 1034
    if (len < (long )bufferlen) {
#line 1035
      bufferlen = (int )len;
    }
    {
#line 1036
    __cil_tmp10 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 1036
    readcount = (int )__cil_tmp10;
#line 1037
    sc2f_array(ubuf.scbuf, readcount, ptr + total, normfact);
#line 1038
    total += (long )readcount;
    }
#line 1039
    if (readcount < bufferlen) {
#line 1040
      goto while_break;
    }
#line 1041
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1044
  return (total);
}
}
#line 1048 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_uc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1051
  total = (sf_count_t )0;
#line 1054
  if (psf->norm_float == 1) {
#line 1054
    tmp = 1. / (double )((float )128);
  } else {
#line 1054
    tmp = 1.;
  }
#line 1054
  normfact = (float )tmp;
#line 1056
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 1058
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1058
    if (! (len > 0L)) {
#line 1058
      goto while_break;
    }
#line 1059
    if (len < (long )bufferlen) {
#line 1060
      bufferlen = (int )len;
    }
    {
#line 1061
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )sizeof(unsigned char ),
                            (sf_count_t )bufferlen, psf);
#line 1061
    readcount = (int )__cil_tmp10;
#line 1062
    uc2f_array(ubuf.ucbuf, readcount, ptr + total, normfact);
#line 1063
    total += (long )readcount;
    }
#line 1064
    if (readcount < bufferlen) {
#line 1065
      goto while_break;
    }
#line 1066
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1069
  return (total);
}
}
#line 1073 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_bes2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1076
  total = (sf_count_t )0;
#line 1079
  if (psf->norm_float == 1) {
#line 1079
    tmp = 1. / (double )((float )32768);
  } else {
#line 1079
    tmp = 1.;
  }
#line 1079
  normfact = (float )tmp;
#line 1081
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1083
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1083
    if (! (len > 0L)) {
#line 1083
      goto while_break;
    }
#line 1084
    if (len < (long )bufferlen) {
#line 1085
      bufferlen = (int )len;
    }
    {
#line 1086
    __cil_tmp10 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 1086
    readcount = (int )__cil_tmp10;
#line 1087
    bes2f_array(ubuf.sbuf, readcount, ptr + total, normfact);
#line 1088
    total += (long )readcount;
    }
#line 1089
    if (readcount < bufferlen) {
#line 1090
      goto while_break;
    }
#line 1091
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1094
  return (total);
}
}
#line 1098 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_les2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1101
  total = (sf_count_t )0;
#line 1104
  if (psf->norm_float == 1) {
#line 1104
    tmp = 1. / (double )((float )32768);
  } else {
#line 1104
    tmp = 1.;
  }
#line 1104
  normfact = (float )tmp;
#line 1106
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1108
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1108
    if (! (len > 0L)) {
#line 1108
      goto while_break;
    }
#line 1109
    if (len < (long )bufferlen) {
#line 1110
      bufferlen = (int )len;
    }
    {
#line 1111
    __cil_tmp10 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 1111
    readcount = (int )__cil_tmp10;
#line 1112
    les2f_array(ubuf.sbuf, readcount, ptr + total, normfact);
#line 1113
    total += (long )readcount;
    }
#line 1114
    if (readcount < bufferlen) {
#line 1115
      goto while_break;
    }
#line 1116
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1119
  return (total);
}
}
#line 1123 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_bet2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1126
  total = (sf_count_t )0;
#line 1130
  if (psf->norm_float == 1) {
#line 1130
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 1130
    tmp = 1. / 256.;
  }
#line 1130
  normfact = (float )tmp;
#line 1132
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1134
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1134
    if (! (len > 0L)) {
#line 1134
      goto while_break;
    }
#line 1135
    if (len < (long )bufferlen) {
#line 1136
      bufferlen = (int )len;
    }
    {
#line 1137
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1137
    readcount = (int )__cil_tmp10;
#line 1138
    bet2f_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total, normfact);
#line 1139
    total += (long )readcount;
    }
#line 1140
    if (readcount < bufferlen) {
#line 1141
      goto while_break;
    }
#line 1142
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1145
  return (total);
}
}
#line 1149 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_let2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1152
  total = (sf_count_t )0;
#line 1156
  if (psf->norm_float == 1) {
#line 1156
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 1156
    tmp = 1. / 256.;
  }
#line 1156
  normfact = (float )tmp;
#line 1158
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1160
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1160
    if (! (len > 0L)) {
#line 1160
      goto while_break;
    }
#line 1161
    if (len < (long )bufferlen) {
#line 1162
      bufferlen = (int )len;
    }
    {
#line 1163
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1163
    readcount = (int )__cil_tmp10;
#line 1164
    let2f_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total, normfact);
#line 1165
    total += (long )readcount;
    }
#line 1166
    if (readcount < bufferlen) {
#line 1167
      goto while_break;
    }
#line 1168
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1171
  return (total);
}
}
#line 1175 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_bei2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1178
  total = (sf_count_t )0;
#line 1181
  if (psf->norm_float == 1) {
#line 1181
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 1181
    tmp = 1.;
  }
#line 1181
  normfact = (float )tmp;
#line 1183
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1185
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1185
    if (! (len > 0L)) {
#line 1185
      goto while_break;
    }
#line 1186
    if (len < (long )bufferlen) {
#line 1187
      bufferlen = (int )len;
    }
    {
#line 1188
    __cil_tmp10 = psf_fread((void *)(ubuf.ibuf), (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 1188
    readcount = (int )__cil_tmp10;
#line 1189
    bei2f_array(ubuf.ibuf, readcount, ptr + total, normfact);
#line 1190
    total += (long )readcount;
    }
#line 1191
    if (readcount < bufferlen) {
#line 1192
      goto while_break;
    }
#line 1193
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1196
  return (total);
}
}
#line 1200 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_lei2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1203
  total = (sf_count_t )0;
#line 1206
  if (psf->norm_float == 1) {
#line 1206
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 1206
    tmp = 1.;
  }
#line 1206
  normfact = (float )tmp;
#line 1208
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1210
    if (! (len > 0L)) {
#line 1210
      goto while_break;
    }
#line 1211
    if (len < (long )bufferlen) {
#line 1212
      bufferlen = (int )len;
    }
    {
#line 1213
    __cil_tmp10 = psf_fread((void *)(ubuf.ibuf), (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 1213
    readcount = (int )__cil_tmp10;
#line 1214
    lei2f_array(ubuf.ibuf, readcount, ptr + total, normfact);
#line 1215
    total += (long )readcount;
    }
#line 1216
    if (readcount < bufferlen) {
#line 1217
      goto while_break;
    }
#line 1218
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1221
  return (total);
}
}
#line 1228 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_sc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1231
  total = (sf_count_t )0;
#line 1234
  if (psf->norm_double == 1) {
#line 1234
    tmp = 1. / (double )128;
  } else {
#line 1234
    tmp = 1.;
  }
#line 1234
  normfact = tmp;
#line 1236
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 1238
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1238
    if (! (len > 0L)) {
#line 1238
      goto while_break;
    }
#line 1239
    if (len < (long )bufferlen) {
#line 1240
      bufferlen = (int )len;
    }
    {
#line 1241
    __cil_tmp10 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 1241
    readcount = (int )__cil_tmp10;
#line 1242
    sc2d_array(ubuf.scbuf, readcount, ptr + total, normfact);
#line 1243
    total += (long )readcount;
    }
#line 1244
    if (readcount < bufferlen) {
#line 1245
      goto while_break;
    }
#line 1246
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1249
  return (total);
}
}
#line 1253 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_uc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1256
  total = (sf_count_t )0;
#line 1259
  if (psf->norm_double == 1) {
#line 1259
    tmp = 1. / (double )128;
  } else {
#line 1259
    tmp = 1.;
  }
#line 1259
  normfact = tmp;
#line 1261
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 1263
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1263
    if (! (len > 0L)) {
#line 1263
      goto while_break;
    }
#line 1264
    if (len < (long )bufferlen) {
#line 1265
      bufferlen = (int )len;
    }
    {
#line 1266
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )sizeof(unsigned char ),
                            (sf_count_t )bufferlen, psf);
#line 1266
    readcount = (int )__cil_tmp10;
#line 1267
    uc2d_array(ubuf.ucbuf, readcount, ptr + total, normfact);
#line 1268
    total += (long )readcount;
    }
#line 1269
    if (readcount < bufferlen) {
#line 1270
      goto while_break;
    }
#line 1271
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1274
  return (total);
}
}
#line 1278 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_bes2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1281
  total = (sf_count_t )0;
#line 1284
  if (psf->norm_double == 1) {
#line 1284
    tmp = 1. / (double )32768;
  } else {
#line 1284
    tmp = 1.;
  }
#line 1284
  normfact = tmp;
#line 1286
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1288
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1288
    if (! (len > 0L)) {
#line 1288
      goto while_break;
    }
#line 1289
    if (len < (long )bufferlen) {
#line 1290
      bufferlen = (int )len;
    }
    {
#line 1291
    __cil_tmp10 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 1291
    readcount = (int )__cil_tmp10;
#line 1292
    bes2d_array(ubuf.sbuf, readcount, ptr + total, normfact);
#line 1293
    total += (long )readcount;
    }
#line 1294
    if (readcount < bufferlen) {
#line 1295
      goto while_break;
    }
#line 1296
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1299
  return (total);
}
}
#line 1303 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_les2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1306
  total = (sf_count_t )0;
#line 1309
  if (psf->norm_double == 1) {
#line 1309
    tmp = 1. / (double )32768;
  } else {
#line 1309
    tmp = 1.;
  }
#line 1309
  normfact = tmp;
#line 1311
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1313
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1313
    if (! (len > 0L)) {
#line 1313
      goto while_break;
    }
#line 1314
    if (len < (long )bufferlen) {
#line 1315
      bufferlen = (int )len;
    }
    {
#line 1316
    __cil_tmp10 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 1316
    readcount = (int )__cil_tmp10;
#line 1317
    les2d_array(ubuf.sbuf, readcount, ptr + total, normfact);
#line 1318
    total += (long )readcount;
    }
#line 1319
    if (readcount < bufferlen) {
#line 1320
      goto while_break;
    }
#line 1321
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1324
  return (total);
}
}
#line 1328 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_bet2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1331
  total = (sf_count_t )0;
#line 1334
  if (psf->norm_double == 1) {
#line 1334
    tmp = 1. / (double )2147483648U;
  } else {
#line 1334
    tmp = 1. / 256.;
  }
#line 1334
  normfact = tmp;
#line 1336
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1338
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1338
    if (! (len > 0L)) {
#line 1338
      goto while_break;
    }
#line 1339
    if (len < (long )bufferlen) {
#line 1340
      bufferlen = (int )len;
    }
    {
#line 1341
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1341
    readcount = (int )__cil_tmp10;
#line 1342
    bet2d_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total, normfact);
#line 1343
    total += (long )readcount;
    }
#line 1344
    if (readcount < bufferlen) {
#line 1345
      goto while_break;
    }
#line 1346
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1349
  return (total);
}
}
#line 1353 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_let2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1356
  total = (sf_count_t )0;
#line 1360
  if (psf->norm_double == 1) {
#line 1360
    tmp = 1. / (double )2147483648U;
  } else {
#line 1360
    tmp = 1. / 256.;
  }
#line 1360
  normfact = tmp;
#line 1362
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1364
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1364
    if (! (len > 0L)) {
#line 1364
      goto while_break;
    }
#line 1365
    if (len < (long )bufferlen) {
#line 1366
      bufferlen = (int )len;
    }
    {
#line 1367
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1367
    readcount = (int )__cil_tmp10;
#line 1368
    let2d_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total, normfact);
#line 1369
    total += (long )readcount;
    }
#line 1370
    if (readcount < bufferlen) {
#line 1371
      goto while_break;
    }
#line 1372
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1375
  return (total);
}
}
#line 1379 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_bei2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1382
  total = (sf_count_t )0;
#line 1385
  if (psf->norm_double == 1) {
#line 1385
    tmp = 1. / (double )2147483648U;
  } else {
#line 1385
    tmp = 1.;
  }
#line 1385
  normfact = tmp;
#line 1387
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1389
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1389
    if (! (len > 0L)) {
#line 1389
      goto while_break;
    }
#line 1390
    if (len < (long )bufferlen) {
#line 1391
      bufferlen = (int )len;
    }
    {
#line 1392
    __cil_tmp10 = psf_fread((void *)(ubuf.ibuf), (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 1392
    readcount = (int )__cil_tmp10;
#line 1393
    bei2d_array(ubuf.ibuf, readcount, ptr + total, normfact);
#line 1394
    total += (long )readcount;
    }
#line 1395
    if (readcount < bufferlen) {
#line 1396
      goto while_break;
    }
#line 1397
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1400
  return (total);
}
}
#line 1404 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_read_lei2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1407
  total = (sf_count_t )0;
#line 1410
  if (psf->norm_double == 1) {
#line 1410
    tmp = 1. / (double )2147483648U;
  } else {
#line 1410
    tmp = 1.;
  }
#line 1410
  normfact = tmp;
#line 1412
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1414
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1414
    if (! (len > 0L)) {
#line 1414
      goto while_break;
    }
#line 1415
    if (len < (long )bufferlen) {
#line 1416
      bufferlen = (int )len;
    }
    {
#line 1417
    __cil_tmp10 = psf_fread((void *)(ubuf.ibuf), (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 1417
    readcount = (int )__cil_tmp10;
#line 1418
    lei2d_array(ubuf.ibuf, readcount, ptr + total, normfact);
#line 1419
    total += (long )readcount;
    }
#line 1420
    if (readcount < bufferlen) {
#line 1421
      goto while_break;
    }
#line 1422
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1425
  return (total);
}
}
#line 1434 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_s2sc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1437
  total = (sf_count_t )0;
#line 1439
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 1441
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1441
    if (! (len > 0L)) {
#line 1441
      goto while_break;
    }
#line 1442
    if (len < (long )bufferlen) {
#line 1443
      bufferlen = (int )len;
    }
    {
#line 1444
    s2sc_array(ptr + total, ubuf.scbuf, bufferlen);
#line 1445
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 1445
    writecount = (int )__cil_tmp8;
#line 1446
    total += (long )writecount;
    }
#line 1447
    if (writecount < bufferlen) {
#line 1448
      goto while_break;
    }
#line 1449
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1452
  return (total);
}
}
#line 1456 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_s2uc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1459
  total = (sf_count_t )0;
#line 1461
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 1463
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1463
    if (! (len > 0L)) {
#line 1463
      goto while_break;
    }
#line 1464
    if (len < (long )bufferlen) {
#line 1465
      bufferlen = (int )len;
    }
    {
#line 1466
    s2uc_array(ptr + total, ubuf.ucbuf, bufferlen);
#line 1467
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )sizeof(unsigned char ),
                            (sf_count_t )bufferlen, psf);
#line 1467
    writecount = (int )__cil_tmp8;
#line 1468
    total += (long )writecount;
    }
#line 1469
    if (writecount < bufferlen) {
#line 1470
      goto while_break;
    }
#line 1471
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1474
  return (total);
}
}
#line 1478 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_s2bes(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 1481
  total = (sf_count_t )0;
#line 1487
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1489
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1489
    if (! (len > 0L)) {
#line 1489
      goto while_break;
    }
#line 1490
    if (len < (long )bufferlen) {
#line 1491
      bufferlen = (int )len;
    }
    {
#line 1492
    endswap_short_copy(ubuf.sbuf, ptr + total, bufferlen);
#line 1493
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                            (sf_count_t )bufferlen, psf);
#line 1493
    writecount = (int )__cil_tmp9;
#line 1494
    total += (long )writecount;
    }
#line 1495
    if (writecount < bufferlen) {
#line 1496
      goto while_break;
    }
#line 1497
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1500
  return (total);
}
}
#line 1504 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_s2les(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
  {
#line 1507
  total = (sf_count_t )0;
#line 1510
  __cil_tmp8 = psf_fwrite((void const   *)ptr, (sf_count_t )sizeof(short ), len, psf);
  }
#line 1510
  return (__cil_tmp8);
#line 1512
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1514
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1514
    if (! (len > 0L)) {
#line 1514
      goto while_break;
    }
#line 1515
    if (len < (long )bufferlen) {
#line 1516
      bufferlen = (int )len;
    }
    {
#line 1517
    endswap_short_copy(ubuf.sbuf, ptr + total, bufferlen);
#line 1518
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                            (sf_count_t )bufferlen, psf);
#line 1518
    writecount = (int )__cil_tmp9;
#line 1519
    total += (long )writecount;
    }
#line 1520
    if (writecount < bufferlen) {
#line 1521
      goto while_break;
    }
#line 1522
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1525
  return (total);
}
}
#line 1529 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_s2bet(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1532
  total = (sf_count_t )0;
#line 1534
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1536
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1536
    if (! (len > 0L)) {
#line 1536
      goto while_break;
    }
#line 1537
    if (len < (long )bufferlen) {
#line 1538
      bufferlen = (int )len;
    }
    {
#line 1539
    s2bet_array(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen);
#line 1540
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1540
    writecount = (int )__cil_tmp8;
#line 1541
    total += (long )writecount;
    }
#line 1542
    if (writecount < bufferlen) {
#line 1543
      goto while_break;
    }
#line 1544
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1547
  return (total);
}
}
#line 1551 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_s2let(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1554
  total = (sf_count_t )0;
#line 1556
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1558
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1558
    if (! (len > 0L)) {
#line 1558
      goto while_break;
    }
#line 1559
    if (len < (long )bufferlen) {
#line 1560
      bufferlen = (int )len;
    }
    {
#line 1561
    s2let_array(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen);
#line 1562
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1562
    writecount = (int )__cil_tmp8;
#line 1563
    total += (long )writecount;
    }
#line 1564
    if (writecount < bufferlen) {
#line 1565
      goto while_break;
    }
#line 1566
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1569
  return (total);
}
}
#line 1573 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_s2bei(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1576
  total = (sf_count_t )0;
#line 1578
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1580
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1580
    if (! (len > 0L)) {
#line 1580
      goto while_break;
    }
#line 1581
    if (len < (long )bufferlen) {
#line 1582
      bufferlen = (int )len;
    }
    {
#line 1583
    s2bei_array(ptr + total, ubuf.ibuf, bufferlen);
#line 1584
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                            (sf_count_t )bufferlen, psf);
#line 1584
    writecount = (int )__cil_tmp8;
#line 1585
    total += (long )writecount;
    }
#line 1586
    if (writecount < bufferlen) {
#line 1587
      goto while_break;
    }
#line 1588
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1591
  return (total);
}
}
#line 1595 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_s2lei(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1598
  total = (sf_count_t )0;
#line 1600
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1602
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1602
    if (! (len > 0L)) {
#line 1602
      goto while_break;
    }
#line 1603
    if (len < (long )bufferlen) {
#line 1604
      bufferlen = (int )len;
    }
    {
#line 1605
    s2lei_array(ptr + total, ubuf.ibuf, bufferlen);
#line 1606
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                            (sf_count_t )bufferlen, psf);
#line 1606
    writecount = (int )__cil_tmp8;
#line 1607
    total += (long )writecount;
    }
#line 1608
    if (writecount < bufferlen) {
#line 1609
      goto while_break;
    }
#line 1610
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1613
  return (total);
}
}
#line 1620 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_i2sc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1623
  total = (sf_count_t )0;
#line 1625
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 1627
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1627
    if (! (len > 0L)) {
#line 1627
      goto while_break;
    }
#line 1628
    if (len < (long )bufferlen) {
#line 1629
      bufferlen = (int )len;
    }
    {
#line 1630
    i2sc_array(ptr + total, ubuf.scbuf, bufferlen);
#line 1631
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 1631
    writecount = (int )__cil_tmp8;
#line 1632
    total += (long )writecount;
    }
#line 1633
    if (writecount < bufferlen) {
#line 1634
      goto while_break;
    }
#line 1635
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1638
  return (total);
}
}
#line 1642 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_i2uc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1645
  total = (sf_count_t )0;
#line 1647
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 1649
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1649
    if (! (len > 0L)) {
#line 1649
      goto while_break;
    }
#line 1650
    if (len < (long )bufferlen) {
#line 1651
      bufferlen = (int )len;
    }
    {
#line 1652
    i2uc_array(ptr + total, ubuf.ucbuf, bufferlen);
#line 1653
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 1653
    writecount = (int )__cil_tmp8;
#line 1654
    total += (long )writecount;
    }
#line 1655
    if (writecount < bufferlen) {
#line 1656
      goto while_break;
    }
#line 1657
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1660
  return (total);
}
}
#line 1664 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_i2bes(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1667
  total = (sf_count_t )0;
#line 1669
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1671
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1671
    if (! (len > 0L)) {
#line 1671
      goto while_break;
    }
#line 1672
    if (len < (long )bufferlen) {
#line 1673
      bufferlen = (int )len;
    }
    {
#line 1674
    i2bes_array(ptr + total, ubuf.sbuf, bufferlen);
#line 1675
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                            (sf_count_t )bufferlen, psf);
#line 1675
    writecount = (int )__cil_tmp8;
#line 1676
    total += (long )writecount;
    }
#line 1677
    if (writecount < bufferlen) {
#line 1678
      goto while_break;
    }
#line 1679
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1682
  return (total);
}
}
#line 1686 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_i2les(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1689
  total = (sf_count_t )0;
#line 1691
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1693
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1693
    if (! (len > 0L)) {
#line 1693
      goto while_break;
    }
#line 1694
    if (len < (long )bufferlen) {
#line 1695
      bufferlen = (int )len;
    }
    {
#line 1696
    i2les_array(ptr + total, ubuf.sbuf, bufferlen);
#line 1697
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                            (sf_count_t )bufferlen, psf);
#line 1697
    writecount = (int )__cil_tmp8;
#line 1698
    total += (long )writecount;
    }
#line 1699
    if (writecount < bufferlen) {
#line 1700
      goto while_break;
    }
#line 1701
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1704
  return (total);
}
}
#line 1708 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_i2bet(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1711
  total = (sf_count_t )0;
#line 1713
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1715
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1715
    if (! (len > 0L)) {
#line 1715
      goto while_break;
    }
#line 1716
    if (len < (long )bufferlen) {
#line 1717
      bufferlen = (int )len;
    }
    {
#line 1718
    i2bet_array(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen);
#line 1719
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1719
    writecount = (int )__cil_tmp8;
#line 1720
    total += (long )writecount;
    }
#line 1721
    if (writecount < bufferlen) {
#line 1722
      goto while_break;
    }
#line 1723
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1726
  return (total);
}
}
#line 1730 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_i2let(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1733
  total = (sf_count_t )0;
#line 1735
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1737
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1737
    if (! (len > 0L)) {
#line 1737
      goto while_break;
    }
#line 1738
    if (len < (long )bufferlen) {
#line 1739
      bufferlen = (int )len;
    }
    {
#line 1740
    i2let_array(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen);
#line 1741
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1741
    writecount = (int )__cil_tmp8;
#line 1742
    total += (long )writecount;
    }
#line 1743
    if (writecount < bufferlen) {
#line 1744
      goto while_break;
    }
#line 1745
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1748
  return (total);
}
}
#line 1752 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_i2bei(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 1755
  total = (sf_count_t )0;
#line 1760
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1762
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1762
    if (! (len > 0L)) {
#line 1762
      goto while_break;
    }
#line 1763
    if (len < (long )bufferlen) {
#line 1764
      bufferlen = (int )len;
    }
    {
#line 1765
    endswap_int_copy(ubuf.ibuf, ptr + total, bufferlen);
#line 1766
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                            (sf_count_t )bufferlen, psf);
#line 1766
    writecount = (int )__cil_tmp9;
#line 1767
    total += (long )writecount;
    }
#line 1768
    if (writecount < bufferlen) {
#line 1769
      goto while_break;
    }
#line 1770
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1773
  return (total);
}
}
#line 1777 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_i2lei(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
  {
#line 1780
  total = (sf_count_t )0;
#line 1783
  __cil_tmp8 = psf_fwrite((void const   *)ptr, (sf_count_t )sizeof(int ), len, psf);
  }
#line 1783
  return (__cil_tmp8);
#line 1785
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1787
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1787
    if (! (len > 0L)) {
#line 1787
      goto while_break;
    }
#line 1788
    if (len < (long )bufferlen) {
#line 1789
      bufferlen = (int )len;
    }
    {
#line 1790
    endswap_int_copy(ubuf.ibuf, ptr + total, bufferlen);
#line 1791
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                            (sf_count_t )bufferlen, psf);
#line 1791
    writecount = (int )__cil_tmp9;
#line 1792
    total += (long )writecount;
    }
#line 1793
    if (writecount < bufferlen) {
#line 1794
      goto while_break;
    }
#line 1795
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1798
  return (total);
}
}
#line 1807 "/root/patchweave_new/23/src/pcm.c"
static void f2sc_array(float const   *src , signed char *dest , int count , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1810
  if (normalize) {
#line 1810
    tmp = 1. * (double )127;
  } else {
#line 1810
    tmp = 1.;
  }
#line 1810
  normfact = (float )tmp;
  {
#line 1812
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1812
    count --;
#line 1812
    if (! (count >= 0)) {
#line 1812
      goto while_break;
    }
    {
#line 1813
    __cil_tmp7 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 1813
    *(dest + count) = (signed char )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1819
  return;
}
}
#line 1818 "/root/patchweave_new/23/src/pcm.c"
static void f2sc_clip_array(float const   *src , signed char *dest , int count , int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1821
  if (normalize) {
#line 1821
    tmp = 8. * (double )268435456;
  } else {
#line 1821
    tmp = 1. * (double )16777216;
  }
#line 1821
  normfact = (float )tmp;
  {
#line 1823
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1823
    count --;
#line 1823
    if (! (count >= 0)) {
#line 1823
      goto while_break;
    }
#line 1824
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 1825
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 1826
      *(dest + count) = (signed char)127;
#line 1827
      goto while_continue;
    }
#line 1829
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 1830
      *(dest + count) = (signed char)-128;
#line 1831
      goto while_continue;
    }
    {
#line 1834
    __cil_tmp8 = lrintf(scaled_value);
#line 1834
    *(dest + count) = (signed char )(__cil_tmp8 >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1840
  return;
}
}
#line 1839 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_f2sc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , signed char * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , signed char *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 1843
  total = (sf_count_t )0;
#line 1845
  if (psf->add_clipping) {
#line 1845
    tmp = & f2sc_clip_array;
  } else {
#line 1845
    tmp = & f2sc_array;
  }
#line 1845
  convert = tmp;
#line 1846
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 1848
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1848
    if (! (len > 0L)) {
#line 1848
      goto while_break;
    }
#line 1849
    if (len < (long )bufferlen) {
#line 1850
      bufferlen = (int )len;
    }
    {
#line 1851
    (*convert)(ptr + total, ubuf.scbuf, bufferlen, psf->norm_float);
#line 1852
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                             (sf_count_t )bufferlen, psf);
#line 1852
    writecount = (int )__cil_tmp10;
#line 1853
    total += (long )writecount;
    }
#line 1854
    if (writecount < bufferlen) {
#line 1855
      goto while_break;
    }
#line 1856
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1859
  return (total);
}
}
#line 1866 "/root/patchweave_new/23/src/pcm.c"
static void f2uc_array(float const   *src , unsigned char *dest , int count , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1869
  if (normalize) {
#line 1869
    tmp = 1. * (double )127;
  } else {
#line 1869
    tmp = 1.;
  }
#line 1869
  normfact = (float )tmp;
  {
#line 1871
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1871
    count --;
#line 1871
    if (! (count >= 0)) {
#line 1871
      goto while_break;
    }
    {
#line 1872
    __cil_tmp7 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 1872
    *(dest + count) = (unsigned char )(__cil_tmp7 + 128L);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1878
  return;
}
}
#line 1877 "/root/patchweave_new/23/src/pcm.c"
static void f2uc_clip_array(float const   *src , unsigned char *dest , int count ,
                            int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1880
  if (normalize) {
#line 1880
    tmp = 8. * (double )268435456;
  } else {
#line 1880
    tmp = 1. * (double )16777216;
  }
#line 1880
  normfact = (float )tmp;
  {
#line 1882
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1882
    count --;
#line 1882
    if (! (count >= 0)) {
#line 1882
      goto while_break;
    }
#line 1883
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 1884
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 1885
      *(dest + count) = (unsigned char)255;
#line 1886
      goto while_continue;
    }
#line 1888
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 1889
      *(dest + count) = (unsigned char)0;
#line 1890
      goto while_continue;
    }
    {
#line 1893
    __cil_tmp8 = lrintf(scaled_value);
#line 1893
    *(dest + count) = (unsigned char )((__cil_tmp8 >> 24) + 128L);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1899
  return;
}
}
#line 1898 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_f2uc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , unsigned char * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , unsigned char *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 1902
  total = (sf_count_t )0;
#line 1904
  if (psf->add_clipping) {
#line 1904
    tmp = & f2uc_clip_array;
  } else {
#line 1904
    tmp = & f2uc_array;
  }
#line 1904
  convert = tmp;
#line 1905
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 1907
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1907
    if (! (len > 0L)) {
#line 1907
      goto while_break;
    }
#line 1908
    if (len < (long )bufferlen) {
#line 1909
      bufferlen = (int )len;
    }
    {
#line 1910
    (*convert)(ptr + total, ubuf.ucbuf, bufferlen, psf->norm_float);
#line 1911
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )sizeof(unsigned char ),
                             (sf_count_t )bufferlen, psf);
#line 1911
    writecount = (int )__cil_tmp10;
#line 1912
    total += (long )writecount;
    }
#line 1913
    if (writecount < bufferlen) {
#line 1914
      goto while_break;
    }
#line 1915
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1918
  return (total);
}
}
#line 1925 "/root/patchweave_new/23/src/pcm.c"
static void f2bes_array(float const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  short value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 1930
  if (normalize) {
#line 1930
    tmp = 1. * (double )32767;
  } else {
#line 1930
    tmp = 1.;
  }
#line 1930
  normfact = (float )tmp;
#line 1931
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 1933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1933
    count --;
#line 1933
    if (! (count >= 0)) {
#line 1933
      goto while_break;
    }
    {
#line 1934
    ucptr -= 2;
#line 1935
    __cil_tmp9 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 1935
    value = (short )__cil_tmp9;
#line 1936
    *(ucptr + 1) = (unsigned char )value;
#line 1937
    *(ucptr + 0) = (unsigned char )((int )value >> 8);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1943
  return;
}
}
#line 1942 "/root/patchweave_new/23/src/pcm.c"
static void f2bes_clip_array(float const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 1947
  if (normalize) {
#line 1947
    tmp = 8. * (double )268435456;
  } else {
#line 1947
    tmp = 1. * (double )65536;
  }
#line 1947
  normfact = (float )tmp;
#line 1948
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 1950
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1950
    count --;
#line 1950
    if (! (count >= 0)) {
#line 1950
      goto while_break;
    }
#line 1951
    ucptr -= 2;
#line 1952
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 1953
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 1954
      *(ucptr + 1) = (unsigned char)255;
#line 1955
      *(ucptr + 0) = (unsigned char)127;
#line 1956
      goto while_continue;
    }
#line 1958
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 1959
      *(ucptr + 1) = (unsigned char)0;
#line 1960
      *(ucptr + 0) = (unsigned char)128;
#line 1961
      goto while_continue;
    }
    {
#line 1964
    __cil_tmp10 = lrintf(scaled_value);
#line 1964
    value = (int )__cil_tmp10;
#line 1965
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 1966
    *(ucptr + 0) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1972
  return;
}
}
#line 1971 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_f2bes(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , short * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , short *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 1975
  total = (sf_count_t )0;
#line 1977
  if (psf->add_clipping) {
#line 1977
    tmp = & f2bes_clip_array;
  } else {
#line 1977
    tmp = & f2bes_array;
  }
#line 1977
  convert = tmp;
#line 1978
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1980
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1980
    if (! (len > 0L)) {
#line 1980
      goto while_break;
    }
#line 1981
    if (len < (long )bufferlen) {
#line 1982
      bufferlen = (int )len;
    }
    {
#line 1983
    (*convert)(ptr + total, ubuf.sbuf, bufferlen, psf->norm_float);
#line 1984
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                             (sf_count_t )bufferlen, psf);
#line 1984
    writecount = (int )__cil_tmp10;
#line 1985
    total += (long )writecount;
    }
#line 1986
    if (writecount < bufferlen) {
#line 1987
      goto while_break;
    }
#line 1988
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1991
  return (total);
}
}
#line 1998 "/root/patchweave_new/23/src/pcm.c"
static void f2les_array(float const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  int value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2003
  if (normalize) {
#line 2003
    tmp = 1. * (double )32767;
  } else {
#line 2003
    tmp = 1.;
  }
#line 2003
  normfact = (float )tmp;
#line 2004
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2006
    count --;
#line 2006
    if (! (count >= 0)) {
#line 2006
      goto while_break;
    }
    {
#line 2007
    ucptr -= 2;
#line 2008
    __cil_tmp9 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 2008
    value = (int )__cil_tmp9;
#line 2009
    *(ucptr + 0) = (unsigned char )value;
#line 2010
    *(ucptr + 1) = (unsigned char )(value >> 8);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2016
  return;
}
}
#line 2015 "/root/patchweave_new/23/src/pcm.c"
static void f2les_clip_array(float const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2020
  if (normalize) {
#line 2020
    tmp = 8. * (double )268435456;
  } else {
#line 2020
    tmp = 1. * (double )65536;
  }
#line 2020
  normfact = (float )tmp;
#line 2021
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2023
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2023
    count --;
#line 2023
    if (! (count >= 0)) {
#line 2023
      goto while_break;
    }
#line 2024
    ucptr -= 2;
#line 2025
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 2026
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 2027
      *(ucptr + 0) = (unsigned char)255;
#line 2028
      *(ucptr + 1) = (unsigned char)127;
#line 2029
      goto while_continue;
    }
#line 2031
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 2032
      *(ucptr + 0) = (unsigned char)0;
#line 2033
      *(ucptr + 1) = (unsigned char)128;
#line 2034
      goto while_continue;
    }
    {
#line 2037
    __cil_tmp10 = lrintf(scaled_value);
#line 2037
    value = (int )__cil_tmp10;
#line 2038
    *(ucptr + 0) = (unsigned char )(value >> 16);
#line 2039
    *(ucptr + 1) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2045
  return;
}
}
#line 2044 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_f2les(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , short * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , short *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2048
  total = (sf_count_t )0;
#line 2050
  if (psf->add_clipping) {
#line 2050
    tmp = & f2les_clip_array;
  } else {
#line 2050
    tmp = & f2les_array;
  }
#line 2050
  convert = tmp;
#line 2051
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 2053
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2053
    if (! (len > 0L)) {
#line 2053
      goto while_break;
    }
#line 2054
    if (len < (long )bufferlen) {
#line 2055
      bufferlen = (int )len;
    }
    {
#line 2056
    (*convert)(ptr + total, ubuf.sbuf, bufferlen, psf->norm_float);
#line 2057
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                             (sf_count_t )bufferlen, psf);
#line 2057
    writecount = (int )__cil_tmp10;
#line 2058
    total += (long )writecount;
    }
#line 2059
    if (writecount < bufferlen) {
#line 2060
      goto while_break;
    }
#line 2061
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2064
  return (total);
}
}
#line 2071 "/root/patchweave_new/23/src/pcm.c"
static void f2let_array(float const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  int value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2076
  if (normalize) {
#line 2076
    tmp = 1. * (double )8388607;
  } else {
#line 2076
    tmp = 1.;
  }
#line 2076
  normfact = (float )tmp;
#line 2077
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2079
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2079
    count --;
#line 2079
    if (! (count >= 0)) {
#line 2079
      goto while_break;
    }
    {
#line 2080
    ucptr -= 3;
#line 2081
    __cil_tmp9 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 2081
    value = (int )__cil_tmp9;
#line 2082
    *(ucptr + 0) = (unsigned char )value;
#line 2083
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2084
    *(ucptr + 2) = (unsigned char )(value >> 16);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2090
  return;
}
}
#line 2089 "/root/patchweave_new/23/src/pcm.c"
static void f2let_clip_array(float const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2094
  if (normalize) {
#line 2094
    tmp = 8. * (double )268435456;
  } else {
#line 2094
    tmp = 1. * (double )256;
  }
#line 2094
  normfact = (float )tmp;
#line 2095
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2097
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2097
    count --;
#line 2097
    if (! (count >= 0)) {
#line 2097
      goto while_break;
    }
#line 2098
    ucptr -= 3;
#line 2099
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 2100
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 2101
      *(ucptr + 0) = (unsigned char)255;
#line 2102
      *(ucptr + 1) = (unsigned char)255;
#line 2103
      *(ucptr + 2) = (unsigned char)127;
#line 2104
      goto while_continue;
    }
#line 2106
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 2107
      *(ucptr + 0) = (unsigned char)0;
#line 2108
      *(ucptr + 1) = (unsigned char)0;
#line 2109
      *(ucptr + 2) = (unsigned char)128;
#line 2110
      goto while_continue;
    }
    {
#line 2113
    __cil_tmp10 = lrintf(scaled_value);
#line 2113
    value = (int )__cil_tmp10;
#line 2114
    *(ucptr + 0) = (unsigned char )(value >> 8);
#line 2115
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2116
    *(ucptr + 2) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2122
  return;
}
}
#line 2121 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_f2let(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , tribyte * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , tribyte *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2125
  total = (sf_count_t )0;
#line 2127
  if (psf->add_clipping) {
#line 2127
    tmp = & f2let_clip_array;
  } else {
#line 2127
    tmp = & f2let_array;
  }
#line 2127
  convert = tmp;
#line 2128
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 2130
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2130
    if (! (len > 0L)) {
#line 2130
      goto while_break;
    }
#line 2131
    if (len < (long )bufferlen) {
#line 2132
      bufferlen = (int )len;
    }
    {
#line 2133
    (*convert)(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen, psf->norm_float);
#line 2134
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                             psf);
#line 2134
    writecount = (int )__cil_tmp10;
#line 2135
    total += (long )writecount;
    }
#line 2136
    if (writecount < bufferlen) {
#line 2137
      goto while_break;
    }
#line 2138
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2141
  return (total);
}
}
#line 2148 "/root/patchweave_new/23/src/pcm.c"
static void f2bet_array(float const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  int value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2153
  if (normalize) {
#line 2153
    tmp = 1. * (double )8388607;
  } else {
#line 2153
    tmp = 1.;
  }
#line 2153
  normfact = (float )tmp;
#line 2154
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2156
    count --;
#line 2156
    if (! (count >= 0)) {
#line 2156
      goto while_break;
    }
    {
#line 2157
    ucptr -= 3;
#line 2158
    __cil_tmp9 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 2158
    value = (int )__cil_tmp9;
#line 2159
    *(ucptr + 0) = (unsigned char )(value >> 16);
#line 2160
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2161
    *(ucptr + 2) = (unsigned char )value;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2167
  return;
}
}
#line 2166 "/root/patchweave_new/23/src/pcm.c"
static void f2bet_clip_array(float const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2171
  if (normalize) {
#line 2171
    tmp = 8. * (double )268435456;
  } else {
#line 2171
    tmp = 1. * (double )256;
  }
#line 2171
  normfact = (float )tmp;
#line 2172
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2174
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2174
    count --;
#line 2174
    if (! (count >= 0)) {
#line 2174
      goto while_break;
    }
#line 2175
    ucptr -= 3;
#line 2176
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 2177
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 2178
      *(ucptr + 0) = (unsigned char)127;
#line 2179
      *(ucptr + 1) = (unsigned char)255;
#line 2180
      *(ucptr + 2) = (unsigned char)255;
#line 2181
      goto while_continue;
    }
#line 2183
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 2184
      *(ucptr + 0) = (unsigned char)128;
#line 2185
      *(ucptr + 1) = (unsigned char)0;
#line 2186
      *(ucptr + 2) = (unsigned char)0;
#line 2187
      goto while_continue;
    }
    {
#line 2190
    __cil_tmp10 = lrint((double )scaled_value);
#line 2190
    value = (int )__cil_tmp10;
#line 2191
    *(ucptr + 0) = (unsigned char )(value >> 24);
#line 2192
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2193
    *(ucptr + 2) = (unsigned char )(value >> 8);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2199
  return;
}
}
#line 2198 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_f2bet(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , tribyte * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , tribyte *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2202
  total = (sf_count_t )0;
#line 2204
  if (psf->add_clipping) {
#line 2204
    tmp = & f2bet_clip_array;
  } else {
#line 2204
    tmp = & f2bet_array;
  }
#line 2204
  convert = tmp;
#line 2205
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 2207
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2207
    if (! (len > 0L)) {
#line 2207
      goto while_break;
    }
#line 2208
    if (len < (long )bufferlen) {
#line 2209
      bufferlen = (int )len;
    }
    {
#line 2210
    (*convert)(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen, psf->norm_float);
#line 2211
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                             psf);
#line 2211
    writecount = (int )__cil_tmp10;
#line 2212
    total += (long )writecount;
    }
#line 2213
    if (writecount < bufferlen) {
#line 2214
      goto while_break;
    }
#line 2215
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2218
  return (total);
}
}
#line 2225 "/root/patchweave_new/23/src/pcm.c"
static void f2bei_array(float const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  int value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2230
  if (normalize) {
#line 2230
    tmp = 1. * (double )2147483647;
  } else {
#line 2230
    tmp = 1.;
  }
#line 2230
  normfact = (float )tmp;
#line 2231
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2232
    count --;
#line 2232
    if (! (count >= 0)) {
#line 2232
      goto while_break;
    }
    {
#line 2233
    ucptr -= 4;
#line 2234
    __cil_tmp9 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 2234
    value = (int )__cil_tmp9;
#line 2235
    *(ucptr + 0) = (unsigned char )(value >> 24);
#line 2236
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2237
    *(ucptr + 2) = (unsigned char )(value >> 8);
#line 2238
    *(ucptr + 3) = (unsigned char )value;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2244
  return;
}
}
#line 2243 "/root/patchweave_new/23/src/pcm.c"
static void f2bei_clip_array(float const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2248
  if (normalize) {
#line 2248
    tmp = 8. * (double )268435456;
  } else {
#line 2248
    tmp = 1.;
  }
#line 2248
  normfact = (float )tmp;
#line 2249
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2251
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2251
    count --;
#line 2251
    if (! (count >= 0)) {
#line 2251
      goto while_break;
    }
#line 2252
    ucptr -= 4;
#line 2253
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 2254
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 2255
      *(ucptr + 0) = (unsigned char)127;
#line 2256
      *(ucptr + 1) = (unsigned char)255;
#line 2257
      *(ucptr + 2) = (unsigned char)255;
#line 2258
      *(ucptr + 3) = (unsigned char)255;
#line 2259
      goto while_continue;
    }
#line 2261
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 2262
      *(ucptr + 0) = (unsigned char)128;
#line 2263
      *(ucptr + 1) = (unsigned char)0;
#line 2264
      *(ucptr + 2) = (unsigned char)0;
#line 2265
      *(ucptr + 3) = (unsigned char)0;
#line 2266
      goto while_continue;
    }
    {
#line 2269
    __cil_tmp10 = lrintf(scaled_value);
#line 2269
    value = (int )__cil_tmp10;
#line 2270
    *(ucptr + 0) = (unsigned char )(value >> 24);
#line 2271
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2272
    *(ucptr + 2) = (unsigned char )(value >> 8);
#line 2273
    *(ucptr + 3) = (unsigned char )value;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2279
  return;
}
}
#line 2278 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_f2bei(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , int * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , int *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2282
  total = (sf_count_t )0;
#line 2284
  if (psf->add_clipping) {
#line 2284
    tmp = & f2bei_clip_array;
  } else {
#line 2284
    tmp = & f2bei_array;
  }
#line 2284
  convert = tmp;
#line 2285
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 2287
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2287
    if (! (len > 0L)) {
#line 2287
      goto while_break;
    }
#line 2288
    if (len < (long )bufferlen) {
#line 2289
      bufferlen = (int )len;
    }
    {
#line 2290
    (*convert)(ptr + total, ubuf.ibuf, bufferlen, psf->norm_float);
#line 2291
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                             (sf_count_t )bufferlen, psf);
#line 2291
    writecount = (int )__cil_tmp10;
#line 2292
    total += (long )writecount;
    }
#line 2293
    if (writecount < bufferlen) {
#line 2294
      goto while_break;
    }
#line 2295
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2298
  return (total);
}
}
#line 2305 "/root/patchweave_new/23/src/pcm.c"
static void f2lei_array(float const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  int value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2310
  if (normalize) {
#line 2310
    tmp = 1. * (double )2147483647;
  } else {
#line 2310
    tmp = 1.;
  }
#line 2310
  normfact = (float )tmp;
#line 2311
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2313
    count --;
#line 2313
    if (! (count >= 0)) {
#line 2313
      goto while_break;
    }
    {
#line 2314
    ucptr -= 4;
#line 2315
    __cil_tmp9 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 2315
    value = (int )__cil_tmp9;
#line 2316
    *(ucptr + 0) = (unsigned char )value;
#line 2317
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2318
    *(ucptr + 2) = (unsigned char )(value >> 16);
#line 2319
    *(ucptr + 3) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2325
  return;
}
}
#line 2324 "/root/patchweave_new/23/src/pcm.c"
static void f2lei_clip_array(float const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2329
  if (normalize) {
#line 2329
    tmp = 8. * (double )268435456;
  } else {
#line 2329
    tmp = 1.;
  }
#line 2329
  normfact = (float )tmp;
#line 2330
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2332
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2332
    count --;
#line 2332
    if (! (count >= 0)) {
#line 2332
      goto while_break;
    }
#line 2333
    ucptr -= 4;
#line 2334
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 2335
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 2336
      *(ucptr + 0) = (unsigned char)255;
#line 2337
      *(ucptr + 1) = (unsigned char)255;
#line 2338
      *(ucptr + 2) = (unsigned char)255;
#line 2339
      *(ucptr + 3) = (unsigned char)127;
#line 2340
      goto while_continue;
    }
#line 2342
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 2343
      *(ucptr + 0) = (unsigned char)0;
#line 2344
      *(ucptr + 1) = (unsigned char)0;
#line 2345
      *(ucptr + 2) = (unsigned char)0;
#line 2346
      *(ucptr + 3) = (unsigned char)128;
#line 2347
      goto while_continue;
    }
    {
#line 2350
    __cil_tmp10 = lrintf(scaled_value);
#line 2350
    value = (int )__cil_tmp10;
#line 2351
    *(ucptr + 0) = (unsigned char )value;
#line 2352
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2353
    *(ucptr + 2) = (unsigned char )(value >> 16);
#line 2354
    *(ucptr + 3) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2360
  return;
}
}
#line 2359 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_f2lei(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , int * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , int *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2363
  total = (sf_count_t )0;
#line 2365
  if (psf->add_clipping) {
#line 2365
    tmp = & f2lei_clip_array;
  } else {
#line 2365
    tmp = & f2lei_array;
  }
#line 2365
  convert = tmp;
#line 2366
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 2368
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2368
    if (! (len > 0L)) {
#line 2368
      goto while_break;
    }
#line 2369
    if (len < (long )bufferlen) {
#line 2370
      bufferlen = (int )len;
    }
    {
#line 2371
    (*convert)(ptr + total, ubuf.ibuf, bufferlen, psf->norm_float);
#line 2372
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                             (sf_count_t )bufferlen, psf);
#line 2372
    writecount = (int )__cil_tmp10;
#line 2373
    total += (long )writecount;
    }
#line 2374
    if (writecount < bufferlen) {
#line 2375
      goto while_break;
    }
#line 2376
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2379
  return (total);
}
}
#line 2386 "/root/patchweave_new/23/src/pcm.c"
static void d2sc_array(double const   *src , signed char *dest , int count , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 2389
  if (normalize) {
#line 2389
    tmp = 1. * (double )127;
  } else {
#line 2389
    tmp = 1.;
  }
#line 2389
  normfact = tmp;
  {
#line 2391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2391
    count --;
#line 2391
    if (! (count >= 0)) {
#line 2391
      goto while_break;
    }
    {
#line 2392
    __cil_tmp7 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2392
    *(dest + count) = (signed char )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2398
  return;
}
}
#line 2397 "/root/patchweave_new/23/src/pcm.c"
static void d2sc_clip_array(double const   *src , signed char *dest , int count ,
                            int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 2400
  if (normalize) {
#line 2400
    tmp = 8. * (double )268435456;
  } else {
#line 2400
    tmp = 1. * (double )16777216;
  }
#line 2400
  normfact = tmp;
  {
#line 2402
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2402
    count --;
#line 2402
    if (! (count >= 0)) {
#line 2402
      goto while_break;
    }
#line 2403
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2404
    if (scaled_value >= 1. * (double )2147483647) {
#line 2405
      *(dest + count) = (signed char)127;
#line 2406
      goto while_continue;
    }
#line 2408
    if (scaled_value <= - 8. * (double )268435456) {
#line 2409
      *(dest + count) = (signed char)-128;
#line 2410
      goto while_continue;
    }
    {
#line 2413
    __cil_tmp8 = lrintf((float )scaled_value);
#line 2413
    *(dest + count) = (signed char )(__cil_tmp8 >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2419
  return;
}
}
#line 2418 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_d2sc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , signed char * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , signed char *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2422
  total = (sf_count_t )0;
#line 2424
  if (psf->add_clipping) {
#line 2424
    tmp = & d2sc_clip_array;
  } else {
#line 2424
    tmp = & d2sc_array;
  }
#line 2424
  convert = tmp;
#line 2425
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 2427
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2427
    if (! (len > 0L)) {
#line 2427
      goto while_break;
    }
#line 2428
    if (len < (long )bufferlen) {
#line 2429
      bufferlen = (int )len;
    }
    {
#line 2430
    (*convert)(ptr + total, ubuf.scbuf, bufferlen, psf->norm_double);
#line 2431
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                             (sf_count_t )bufferlen, psf);
#line 2431
    writecount = (int )__cil_tmp10;
#line 2432
    total += (long )writecount;
    }
#line 2433
    if (writecount < bufferlen) {
#line 2434
      goto while_break;
    }
#line 2435
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2438
  return (total);
}
}
#line 2445 "/root/patchweave_new/23/src/pcm.c"
static void d2uc_array(double const   *src , unsigned char *dest , int count , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 2448
  if (normalize) {
#line 2448
    tmp = 1. * (double )127;
  } else {
#line 2448
    tmp = 1.;
  }
#line 2448
  normfact = tmp;
  {
#line 2450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2450
    count --;
#line 2450
    if (! (count >= 0)) {
#line 2450
      goto while_break;
    }
    {
#line 2451
    __cil_tmp7 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2451
    *(dest + count) = (unsigned char )(__cil_tmp7 + 128L);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2457
  return;
}
}
#line 2456 "/root/patchweave_new/23/src/pcm.c"
static void d2uc_clip_array(double const   *src , unsigned char *dest , int count ,
                            int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 2459
  if (normalize) {
#line 2459
    tmp = 8. * (double )268435456;
  } else {
#line 2459
    tmp = 1. * (double )16777216;
  }
#line 2459
  normfact = tmp;
  {
#line 2461
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2461
    count --;
#line 2461
    if (! (count >= 0)) {
#line 2461
      goto while_break;
    }
#line 2462
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2463
    if (scaled_value >= 1. * (double )2147483647) {
#line 2464
      *(dest + count) = (unsigned char)255;
#line 2465
      goto while_continue;
    }
#line 2467
    if (scaled_value <= - 8. * (double )268435456) {
#line 2468
      *(dest + count) = (unsigned char)0;
#line 2469
      goto while_continue;
    }
    {
#line 2472
    __cil_tmp8 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2472
    *(dest + count) = (unsigned char )((__cil_tmp8 >> 24) + 128L);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2478
  return;
}
}
#line 2477 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_d2uc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , unsigned char * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , unsigned char *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2481
  total = (sf_count_t )0;
#line 2483
  if (psf->add_clipping) {
#line 2483
    tmp = & d2uc_clip_array;
  } else {
#line 2483
    tmp = & d2uc_array;
  }
#line 2483
  convert = tmp;
#line 2484
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 2486
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2486
    if (! (len > 0L)) {
#line 2486
      goto while_break;
    }
#line 2487
    if (len < (long )bufferlen) {
#line 2488
      bufferlen = (int )len;
    }
    {
#line 2489
    (*convert)(ptr + total, ubuf.ucbuf, bufferlen, psf->norm_double);
#line 2490
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )sizeof(unsigned char ),
                             (sf_count_t )bufferlen, psf);
#line 2490
    writecount = (int )__cil_tmp10;
#line 2491
    total += (long )writecount;
    }
#line 2492
    if (writecount < bufferlen) {
#line 2493
      goto while_break;
    }
#line 2494
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2497
  return (total);
}
}
#line 2504 "/root/patchweave_new/23/src/pcm.c"
static void d2bes_array(double const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  short value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2509
  if (normalize) {
#line 2509
    tmp = 1. * (double )32767;
  } else {
#line 2509
    tmp = 1.;
  }
#line 2509
  normfact = tmp;
#line 2510
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2512
    count --;
#line 2512
    if (! (count >= 0)) {
#line 2512
      goto while_break;
    }
    {
#line 2513
    ucptr -= 2;
#line 2514
    __cil_tmp9 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2514
    value = (short )__cil_tmp9;
#line 2515
    *(ucptr + 1) = (unsigned char )value;
#line 2516
    *(ucptr + 0) = (unsigned char )((int )value >> 8);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2522
  return;
}
}
#line 2521 "/root/patchweave_new/23/src/pcm.c"
static void d2bes_clip_array(double const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  double normfact ;
  double scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2526
  if (normalize) {
#line 2526
    tmp = 8. * (double )268435456;
  } else {
#line 2526
    tmp = 1. * (double )65536;
  }
#line 2526
  normfact = tmp;
#line 2527
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2529
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2529
    count --;
#line 2529
    if (! (count >= 0)) {
#line 2529
      goto while_break;
    }
#line 2530
    ucptr -= 2;
#line 2531
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2532
    if (scaled_value >= 1. * (double )2147483647) {
#line 2533
      *(ucptr + 1) = (unsigned char)255;
#line 2534
      *(ucptr + 0) = (unsigned char)127;
#line 2535
      goto while_continue;
    }
#line 2537
    if (scaled_value <= - 8. * (double )268435456) {
#line 2538
      *(ucptr + 1) = (unsigned char)0;
#line 2539
      *(ucptr + 0) = (unsigned char)128;
#line 2540
      goto while_continue;
    }
    {
#line 2543
    __cil_tmp10 = lrint(scaled_value);
#line 2543
    value = (int )__cil_tmp10;
#line 2544
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2545
    *(ucptr + 0) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2551
  return;
}
}
#line 2550 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_d2bes(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , short * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , short *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2554
  total = (sf_count_t )0;
#line 2556
  if (psf->add_clipping) {
#line 2556
    tmp = & d2bes_clip_array;
  } else {
#line 2556
    tmp = & d2bes_array;
  }
#line 2556
  convert = tmp;
#line 2557
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 2559
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2559
    if (! (len > 0L)) {
#line 2559
      goto while_break;
    }
#line 2560
    if (len < (long )bufferlen) {
#line 2561
      bufferlen = (int )len;
    }
    {
#line 2562
    (*convert)(ptr + total, ubuf.sbuf, bufferlen, psf->norm_double);
#line 2563
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                             (sf_count_t )bufferlen, psf);
#line 2563
    writecount = (int )__cil_tmp10;
#line 2564
    total += (long )writecount;
    }
#line 2565
    if (writecount < bufferlen) {
#line 2566
      goto while_break;
    }
#line 2567
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2570
  return (total);
}
}
#line 2577 "/root/patchweave_new/23/src/pcm.c"
static void d2les_array(double const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  short value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2582
  if (normalize) {
#line 2582
    tmp = 1. * (double )32767;
  } else {
#line 2582
    tmp = 1.;
  }
#line 2582
  normfact = tmp;
#line 2583
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2585
    count --;
#line 2585
    if (! (count >= 0)) {
#line 2585
      goto while_break;
    }
    {
#line 2586
    ucptr -= 2;
#line 2587
    __cil_tmp9 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2587
    value = (short )__cil_tmp9;
#line 2588
    *(ucptr + 0) = (unsigned char )value;
#line 2589
    *(ucptr + 1) = (unsigned char )((int )value >> 8);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2595
  return;
}
}
#line 2594 "/root/patchweave_new/23/src/pcm.c"
static void d2les_clip_array(double const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2599
  if (normalize) {
#line 2599
    tmp = 8. * (double )268435456;
  } else {
#line 2599
    tmp = 1. * (double )65536;
  }
#line 2599
  normfact = tmp;
#line 2600
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2602
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2602
    count --;
#line 2602
    if (! (count >= 0)) {
#line 2602
      goto while_break;
    }
#line 2603
    ucptr -= 2;
#line 2604
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2605
    if (scaled_value >= 1. * (double )2147483647) {
#line 2606
      *(ucptr + 0) = (unsigned char)255;
#line 2607
      *(ucptr + 1) = (unsigned char)127;
#line 2608
      goto while_continue;
    }
#line 2610
    if (scaled_value <= - 8. * (double )268435456) {
#line 2611
      *(ucptr + 0) = (unsigned char)0;
#line 2612
      *(ucptr + 1) = (unsigned char)128;
#line 2613
      goto while_continue;
    }
    {
#line 2616
    __cil_tmp10 = lrint(scaled_value);
#line 2616
    value = (int )__cil_tmp10;
#line 2617
    *(ucptr + 0) = (unsigned char )(value >> 16);
#line 2618
    *(ucptr + 1) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2624
  return;
}
}
#line 2623 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_d2les(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , short * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , short *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2627
  total = (sf_count_t )0;
#line 2629
  if (psf->add_clipping) {
#line 2629
    tmp = & d2les_clip_array;
  } else {
#line 2629
    tmp = & d2les_array;
  }
#line 2629
  convert = tmp;
#line 2630
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 2632
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2632
    if (! (len > 0L)) {
#line 2632
      goto while_break;
    }
#line 2633
    if (len < (long )bufferlen) {
#line 2634
      bufferlen = (int )len;
    }
    {
#line 2635
    (*convert)(ptr + total, ubuf.sbuf, bufferlen, psf->norm_double);
#line 2636
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                             (sf_count_t )bufferlen, psf);
#line 2636
    writecount = (int )__cil_tmp10;
#line 2637
    total += (long )writecount;
    }
#line 2638
    if (writecount < bufferlen) {
#line 2639
      goto while_break;
    }
#line 2640
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2643
  return (total);
}
}
#line 2650 "/root/patchweave_new/23/src/pcm.c"
static void d2let_array(double const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2655
  if (normalize) {
#line 2655
    tmp = 1. * (double )8388607;
  } else {
#line 2655
    tmp = 1.;
  }
#line 2655
  normfact = tmp;
#line 2656
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2658
    count --;
#line 2658
    if (! (count >= 0)) {
#line 2658
      goto while_break;
    }
    {
#line 2659
    ucptr -= 3;
#line 2660
    __cil_tmp9 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2660
    value = (int )__cil_tmp9;
#line 2661
    *(ucptr + 0) = (unsigned char )value;
#line 2662
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2663
    *(ucptr + 2) = (unsigned char )(value >> 16);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2669
  return;
}
}
#line 2668 "/root/patchweave_new/23/src/pcm.c"
static void d2let_clip_array(double const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2673
  if (normalize) {
#line 2673
    tmp = 8. * (double )268435456;
  } else {
#line 2673
    tmp = 1. * (double )256;
  }
#line 2673
  normfact = tmp;
#line 2674
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2676
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2676
    count --;
#line 2676
    if (! (count >= 0)) {
#line 2676
      goto while_break;
    }
#line 2677
    ucptr -= 3;
#line 2678
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2679
    if (scaled_value >= 1. * (double )2147483647) {
#line 2680
      *(ucptr + 0) = (unsigned char)255;
#line 2681
      *(ucptr + 1) = (unsigned char)255;
#line 2682
      *(ucptr + 2) = (unsigned char)127;
#line 2683
      goto while_continue;
    }
#line 2685
    if (scaled_value <= - 8. * (double )268435456) {
#line 2686
      *(ucptr + 0) = (unsigned char)0;
#line 2687
      *(ucptr + 1) = (unsigned char)0;
#line 2688
      *(ucptr + 2) = (unsigned char)128;
#line 2689
      goto while_continue;
    }
    {
#line 2692
    __cil_tmp10 = lrint(scaled_value);
#line 2692
    value = (int )__cil_tmp10;
#line 2693
    *(ucptr + 0) = (unsigned char )(value >> 8);
#line 2694
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2695
    *(ucptr + 2) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2701
  return;
}
}
#line 2700 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_d2let(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , tribyte * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , tribyte *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2704
  total = (sf_count_t )0;
#line 2706
  if (psf->add_clipping) {
#line 2706
    tmp = & d2let_clip_array;
  } else {
#line 2706
    tmp = & d2let_array;
  }
#line 2706
  convert = tmp;
#line 2707
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 2709
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2709
    if (! (len > 0L)) {
#line 2709
      goto while_break;
    }
#line 2710
    if (len < (long )bufferlen) {
#line 2711
      bufferlen = (int )len;
    }
    {
#line 2712
    (*convert)(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen, psf->norm_double);
#line 2713
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                             psf);
#line 2713
    writecount = (int )__cil_tmp10;
#line 2714
    total += (long )writecount;
    }
#line 2715
    if (writecount < bufferlen) {
#line 2716
      goto while_break;
    }
#line 2717
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2720
  return (total);
}
}
#line 2727 "/root/patchweave_new/23/src/pcm.c"
static void d2bet_array(double const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2732
  if (normalize) {
#line 2732
    tmp = 1. * (double )8388607;
  } else {
#line 2732
    tmp = 1.;
  }
#line 2732
  normfact = tmp;
#line 2733
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2735
    count --;
#line 2735
    if (! (count >= 0)) {
#line 2735
      goto while_break;
    }
    {
#line 2736
    ucptr -= 3;
#line 2737
    __cil_tmp9 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2737
    value = (int )__cil_tmp9;
#line 2738
    *(ucptr + 2) = (unsigned char )value;
#line 2739
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2740
    *(ucptr + 0) = (unsigned char )(value >> 16);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2746
  return;
}
}
#line 2745 "/root/patchweave_new/23/src/pcm.c"
static void d2bet_clip_array(double const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2750
  if (normalize) {
#line 2750
    tmp = 8. * (double )268435456;
  } else {
#line 2750
    tmp = 1. * (double )256;
  }
#line 2750
  normfact = tmp;
#line 2751
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2753
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2753
    count --;
#line 2753
    if (! (count >= 0)) {
#line 2753
      goto while_break;
    }
#line 2754
    ucptr -= 3;
#line 2755
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2756
    if (scaled_value >= 1. * (double )2147483647) {
#line 2757
      *(ucptr + 2) = (unsigned char)255;
#line 2758
      *(ucptr + 1) = (unsigned char)255;
#line 2759
      *(ucptr + 0) = (unsigned char)127;
#line 2760
      goto while_continue;
    }
#line 2762
    if (scaled_value <= - 8. * (double )268435456) {
#line 2763
      *(ucptr + 2) = (unsigned char)0;
#line 2764
      *(ucptr + 1) = (unsigned char)0;
#line 2765
      *(ucptr + 0) = (unsigned char)128;
#line 2766
      goto while_continue;
    }
    {
#line 2769
    __cil_tmp10 = lrint(scaled_value);
#line 2769
    value = (int )__cil_tmp10;
#line 2770
    *(ucptr + 2) = (unsigned char )(value >> 8);
#line 2771
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2772
    *(ucptr + 0) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2778
  return;
}
}
#line 2777 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_d2bet(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , tribyte * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , tribyte *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2781
  total = (sf_count_t )0;
#line 2783
  if (psf->add_clipping) {
#line 2783
    tmp = & d2bet_clip_array;
  } else {
#line 2783
    tmp = & d2bet_array;
  }
#line 2783
  convert = tmp;
#line 2784
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 2786
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2786
    if (! (len > 0L)) {
#line 2786
      goto while_break;
    }
#line 2787
    if (len < (long )bufferlen) {
#line 2788
      bufferlen = (int )len;
    }
    {
#line 2789
    (*convert)(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen, psf->norm_double);
#line 2790
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                             psf);
#line 2790
    writecount = (int )__cil_tmp10;
#line 2791
    total += (long )writecount;
    }
#line 2792
    if (writecount < bufferlen) {
#line 2793
      goto while_break;
    }
#line 2794
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2797
  return (total);
}
}
#line 2804 "/root/patchweave_new/23/src/pcm.c"
static void d2bei_array(double const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2809
  if (normalize) {
#line 2809
    tmp = 1. * (double )2147483647;
  } else {
#line 2809
    tmp = 1.;
  }
#line 2809
  normfact = tmp;
#line 2810
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2812
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2812
    count --;
#line 2812
    if (! (count >= 0)) {
#line 2812
      goto while_break;
    }
    {
#line 2813
    ucptr -= 4;
#line 2814
    __cil_tmp9 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2814
    value = (int )__cil_tmp9;
#line 2815
    *(ucptr + 0) = (unsigned char )(value >> 24);
#line 2816
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2817
    *(ucptr + 2) = (unsigned char )(value >> 8);
#line 2818
    *(ucptr + 3) = (unsigned char )value;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2824
  return;
}
}
#line 2823 "/root/patchweave_new/23/src/pcm.c"
static void d2bei_clip_array(double const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2828
  if (normalize) {
#line 2828
    tmp = 8. * (double )268435456;
  } else {
#line 2828
    tmp = 1.;
  }
#line 2828
  normfact = tmp;
#line 2829
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2831
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2831
    count --;
#line 2831
    if (! (count >= 0)) {
#line 2831
      goto while_break;
    }
#line 2832
    ucptr -= 4;
#line 2833
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2834
    if (scaled_value >= 1. * (double )2147483647) {
#line 2835
      *(ucptr + 3) = (unsigned char)255;
#line 2836
      *(ucptr + 2) = (unsigned char)255;
#line 2837
      *(ucptr + 1) = (unsigned char)255;
#line 2838
      *(ucptr + 0) = (unsigned char)127;
#line 2839
      goto while_continue;
    }
#line 2841
    if (scaled_value <= - 8. * (double )268435456) {
#line 2842
      *(ucptr + 3) = (unsigned char)0;
#line 2843
      *(ucptr + 2) = (unsigned char)0;
#line 2844
      *(ucptr + 1) = (unsigned char)0;
#line 2845
      *(ucptr + 0) = (unsigned char)128;
#line 2846
      goto while_continue;
    }
    {
#line 2849
    __cil_tmp10 = lrint(scaled_value);
#line 2849
    value = (int )__cil_tmp10;
#line 2850
    *(ucptr + 0) = (unsigned char )(value >> 24);
#line 2851
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2852
    *(ucptr + 2) = (unsigned char )(value >> 8);
#line 2853
    *(ucptr + 3) = (unsigned char )value;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2859
  return;
}
}
#line 2858 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_d2bei(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , int * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , int *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2862
  total = (sf_count_t )0;
#line 2864
  if (psf->add_clipping) {
#line 2864
    tmp = & d2bei_clip_array;
  } else {
#line 2864
    tmp = & d2bei_array;
  }
#line 2864
  convert = tmp;
#line 2865
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 2867
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2867
    if (! (len > 0L)) {
#line 2867
      goto while_break;
    }
#line 2868
    if (len < (long )bufferlen) {
#line 2869
      bufferlen = (int )len;
    }
    {
#line 2870
    (*convert)(ptr + total, ubuf.ibuf, bufferlen, psf->norm_double);
#line 2871
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                             (sf_count_t )bufferlen, psf);
#line 2871
    writecount = (int )__cil_tmp10;
#line 2872
    total += (long )writecount;
    }
#line 2873
    if (writecount < bufferlen) {
#line 2874
      goto while_break;
    }
#line 2875
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2878
  return (total);
}
}
#line 2885 "/root/patchweave_new/23/src/pcm.c"
static void d2lei_array(double const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2890
  if (normalize) {
#line 2890
    tmp = 1. * (double )2147483647;
  } else {
#line 2890
    tmp = 1.;
  }
#line 2890
  normfact = tmp;
#line 2891
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2893
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2893
    count --;
#line 2893
    if (! (count >= 0)) {
#line 2893
      goto while_break;
    }
    {
#line 2894
    ucptr -= 4;
#line 2895
    __cil_tmp9 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2895
    value = (int )__cil_tmp9;
#line 2896
    *(ucptr + 0) = (unsigned char )value;
#line 2897
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2898
    *(ucptr + 2) = (unsigned char )(value >> 16);
#line 2899
    *(ucptr + 3) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2905
  return;
}
}
#line 2904 "/root/patchweave_new/23/src/pcm.c"
static void d2lei_clip_array(double const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2909
  if (normalize) {
#line 2909
    tmp = 8. * (double )268435456;
  } else {
#line 2909
    tmp = 1.;
  }
#line 2909
  normfact = tmp;
#line 2910
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2912
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2912
    count --;
#line 2912
    if (! (count >= 0)) {
#line 2912
      goto while_break;
    }
#line 2913
    ucptr -= 4;
#line 2914
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2915
    if (scaled_value >= 1. * (double )2147483647) {
#line 2916
      *(ucptr + 0) = (unsigned char)255;
#line 2917
      *(ucptr + 1) = (unsigned char)255;
#line 2918
      *(ucptr + 2) = (unsigned char)255;
#line 2919
      *(ucptr + 3) = (unsigned char)127;
#line 2920
      goto while_continue;
    }
#line 2922
    if (scaled_value <= - 8. * (double )268435456) {
#line 2923
      *(ucptr + 0) = (unsigned char)0;
#line 2924
      *(ucptr + 1) = (unsigned char)0;
#line 2925
      *(ucptr + 2) = (unsigned char)0;
#line 2926
      *(ucptr + 3) = (unsigned char)128;
#line 2927
      goto while_continue;
    }
    {
#line 2930
    __cil_tmp10 = lrint(scaled_value);
#line 2930
    value = (int )__cil_tmp10;
#line 2931
    *(ucptr + 0) = (unsigned char )value;
#line 2932
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2933
    *(ucptr + 2) = (unsigned char )(value >> 16);
#line 2934
    *(ucptr + 3) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2940
  return;
}
}
#line 2939 "/root/patchweave_new/23/src/pcm.c"
static sf_count_t pcm_write_d2lei(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , int * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , int *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2943
  total = (sf_count_t )0;
#line 2945
  if (psf->add_clipping) {
#line 2945
    tmp = & d2lei_clip_array;
  } else {
#line 2945
    tmp = & d2lei_array;
  }
#line 2945
  convert = tmp;
#line 2946
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 2948
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2948
    if (! (len > 0L)) {
#line 2948
      goto while_break;
    }
#line 2949
    if (len < (long )bufferlen) {
#line 2950
      bufferlen = (int )len;
    }
    {
#line 2951
    (*convert)(ptr + total, ubuf.ibuf, bufferlen, psf->norm_double);
#line 2952
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                             (sf_count_t )bufferlen, psf);
#line 2952
    writecount = (int )__cil_tmp10;
#line 2953
    total += (long )writecount;
    }
#line 2954
    if (writecount < bufferlen) {
#line 2955
      goto while_break;
    }
#line 2956
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2959
  return (total);
}
}
#line 168 "/usr/include/fcntl.h"
__inline extern int ( __attribute__((__gnu_inline__)) open)(char const   *__path ,
                                                            int __oflag  , ...) ;
#line 178
__inline extern int ( __attribute__((__gnu_inline__)) open64)(char const   *__path ,
                                                              int __oflag  , ...) ;
#line 192
__inline extern int ( __attribute__((__gnu_inline__)) openat)(int __fd , char const   *__path ,
                                                              int __oflag  , ...) ;
#line 203
__inline extern int ( __attribute__((__gnu_inline__)) openat64)(int __fd , char const   *__path ,
                                                                int __oflag  , ...) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int __open_2(char const   *__path , int __oflag ) ;
#line 27
extern int __open_alias(char const   *__path , int __oflag  , ...) ;
#line 35
extern void __open_too_many_args(void) ;
#line 37
extern void __open_missing_mode(void) ;
#line 41 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__gnu_inline__)) open)(char const   *__path ,
                                                            int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 43
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 43
  if (__cil_tmp3 > 1) {
    {
#line 44
    __open_too_many_args();
    }
  }
#line 46
  __cil_tmp4 = 0;
#line 46
  if (__cil_tmp4) {
    {
#line 48
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 48
    if ((__oflag & 64) != 0) {
      _L: 
#line 48
      if (__cil_tmp5 < 1) {
        {
#line 50
        __open_missing_mode();
#line 51
        __cil_tmp6 = __open_2(__path, __oflag);
        }
#line 51
        return (__cil_tmp6);
      }
    } else
#line 48
    if ((__oflag & 4259840) == 4259840) {
#line 48
      goto _L;
    }
    {
#line 53
    __cil_tmp7 = (int )__builtin_va_arg_pack();
#line 53
    __cil_tmp8 = __open_alias(__path, __oflag, __cil_tmp7);
    }
#line 53
    return (__cil_tmp8);
  }
  {
#line 56
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 56
  if (__cil_tmp9 < 1) {
    {
#line 57
    __cil_tmp10 = __open_2(__path, __oflag);
    }
#line 57
    return (__cil_tmp10);
  }
  {
#line 59
  __cil_tmp11 = (int )__builtin_va_arg_pack();
#line 59
  __cil_tmp12 = __open_alias(__path, __oflag, __cil_tmp11);
  }
#line 59
  return (__cil_tmp12);
}
}
#line 64
extern int __open64_2(char const   *__path , int __oflag ) ;
#line 65
extern int __open64_alias(char const   *__path , int __oflag  , ...) ;
#line 67
extern void __open64_too_many_args(void) ;
#line 69
extern void __open64_missing_mode(void) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__gnu_inline__)) open64)(char const   *__path ,
                                                              int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 75
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 75
  if (__cil_tmp3 > 1) {
    {
#line 76
    __open64_too_many_args();
    }
  }
#line 78
  __cil_tmp4 = 0;
#line 78
  if (__cil_tmp4) {
    {
#line 80
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 80
    if ((__oflag & 64) != 0) {
      _L: 
#line 80
      if (__cil_tmp5 < 1) {
        {
#line 82
        __open64_missing_mode();
#line 83
        __cil_tmp6 = __open64_2(__path, __oflag);
        }
#line 83
        return (__cil_tmp6);
      }
    } else
#line 80
    if ((__oflag & 4259840) == 4259840) {
#line 80
      goto _L;
    }
    {
#line 85
    __cil_tmp7 = (int )__builtin_va_arg_pack();
#line 85
    __cil_tmp8 = __open64_alias(__path, __oflag, __cil_tmp7);
    }
#line 85
    return (__cil_tmp8);
  }
  {
#line 88
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 88
  if (__cil_tmp9 < 1) {
    {
#line 89
    __cil_tmp10 = __open64_2(__path, __oflag);
    }
#line 89
    return (__cil_tmp10);
  }
  {
#line 91
  __cil_tmp11 = (int )__builtin_va_arg_pack();
#line 91
  __cil_tmp12 = __open64_alias(__path, __oflag, __cil_tmp11);
  }
#line 91
  return (__cil_tmp12);
}
}
#line 98
extern int __openat_2(int __fd , char const   *__path , int __oflag ) ;
#line 100
extern int __openat_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 111
extern void __openat_too_many_args(void) ;
#line 113
extern void __openat_missing_mode(void) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__gnu_inline__)) openat)(int __fd , char const   *__path ,
                                                              int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 119
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 119
  if (__cil_tmp4 > 1) {
    {
#line 120
    __openat_too_many_args();
    }
  }
#line 122
  __cil_tmp5 = 0;
#line 122
  if (__cil_tmp5) {
    {
#line 124
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 124
    if ((__oflag & 64) != 0) {
      _L: 
#line 124
      if (__cil_tmp6 < 1) {
        {
#line 126
        __openat_missing_mode();
#line 127
        __cil_tmp7 = __openat_2(__fd, __path, __oflag);
        }
#line 127
        return (__cil_tmp7);
      }
    } else
#line 124
    if ((__oflag & 4259840) == 4259840) {
#line 124
      goto _L;
    }
    {
#line 129
    __cil_tmp8 = (int )__builtin_va_arg_pack();
#line 129
    __cil_tmp9 = __openat_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 129
    return (__cil_tmp9);
  }
  {
#line 132
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 132
  if (__cil_tmp10 < 1) {
    {
#line 133
    __cil_tmp11 = __openat_2(__fd, __path, __oflag);
    }
#line 133
    return (__cil_tmp11);
  }
  {
#line 135
  __cil_tmp12 = (int )__builtin_va_arg_pack();
#line 135
  __cil_tmp13 = __openat_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 135
  return (__cil_tmp13);
}
}
#line 140
extern int __openat64_2(int __fd , char const   *__path , int __oflag ) ;
#line 142
extern int __openat64_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 145
extern void __openat64_too_many_args(void) ;
#line 147
extern void __openat64_missing_mode(void) ;
#line 151 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__gnu_inline__)) openat64)(int __fd , char const   *__path ,
                                                                int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 153
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 153
  if (__cil_tmp4 > 1) {
    {
#line 154
    __openat64_too_many_args();
    }
  }
#line 156
  __cil_tmp5 = 0;
#line 156
  if (__cil_tmp5) {
    {
#line 158
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 158
    if ((__oflag & 64) != 0) {
      _L: 
#line 158
      if (__cil_tmp6 < 1) {
        {
#line 160
        __openat64_missing_mode();
#line 161
        __cil_tmp7 = __openat64_2(__fd, __path, __oflag);
        }
#line 161
        return (__cil_tmp7);
      }
    } else
#line 158
    if ((__oflag & 4259840) == 4259840) {
#line 158
      goto _L;
    }
    {
#line 163
    __cil_tmp8 = (int )__builtin_va_arg_pack();
#line 163
    __cil_tmp9 = __openat64_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 163
    return (__cil_tmp9);
  }
  {
#line 166
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 166
  if (__cil_tmp10 < 1) {
    {
#line 167
    __cil_tmp11 = __openat64_2(__fd, __path, __oflag);
    }
#line 167
    return (__cil_tmp11);
  }
  {
#line 169
  __cil_tmp12 = (int )__builtin_va_arg_pack();
#line 169
  __cil_tmp13 = __openat64_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 169
  return (__cil_tmp13);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
#line 207 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128) {
#line 209
    if (__c < 256) {
      {
#line 209
      __cil_tmp2 = __ctype_tolower_loc();
#line 209
      tmp = *(*__cil_tmp2 + __c);
      }
    } else {
#line 209
      tmp = __c;
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
#line 213 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128) {
#line 215
    if (__c < 256) {
      {
#line 215
      __cil_tmp2 = __ctype_toupper_loc();
#line 215
      tmp = *(*__cil_tmp2 + __c);
      }
    } else {
#line 215
      tmp = __c;
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 75 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 128
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type ) ;
#line 334
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
__inline extern intptr_t ( __attribute__((__gnu_inline__)) read)(int __fd , void *__buf ,
                                                                 size_t __nbytes ) ;
#line 366
extern intptr_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 376
__inline extern intptr_t ( __attribute__((__gnu_inline__)) pread)(int __fd , void *__buf ,
                                                                  size_t __nbytes ,
                                                                  __off_t __offset ) ;
#line 404
__inline extern intptr_t ( __attribute__((__gnu_inline__)) pread64)(int __fd , void *__buf ,
                                                                    size_t __nbytes ,
                                                                    __off64_t __offset ) ;
#line 511
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getcwd)(char *__buf ,
                                                                                              size_t __size ) ;
#line 525
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getwd)(char *__buf ) ;
#line 623
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) confstr)(int __name ,
                                                                                                char *__buf ,
                                                                                                size_t __len ) ;
#line 689
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getgroups)(int __size ,
                                                                                               __gid_t *__list ) ;
#line 774
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ttyname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 808
__inline extern  __attribute__((__nothrow__)) intptr_t ( __attribute__((__gnu_inline__)) readlink)(char const   *__path ,
                                                                                                   char *__buf ,
                                                                                                   size_t __len ) ;
#line 819
__inline extern  __attribute__((__nothrow__)) intptr_t ( __attribute__((__gnu_inline__)) readlinkat)(int __fd ,
                                                                                                     char const   *__path ,
                                                                                                     char *__buf ,
                                                                                                     size_t __len ) ;
#line 856
__inline extern int ( __attribute__((__gnu_inline__)) getlogin_r)(char *__buf , size_t __buflen ) ;
#line 877
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) gethostname)(char *__buf ,
                                                                                                 size_t __buflen ) ;
#line 895
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getdomainname)(char *__buf ,
                                                                                                   size_t __buflen ) ;
#line 954
extern int fsync(int __fd ) ;
#line 1014
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern intptr_t __read_chk(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 25
extern intptr_t __read_alias(int __fd , void *__buf , size_t __nbytes ) ;
#line 27
extern intptr_t __read_chk_warn(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern intptr_t ( __attribute__((__gnu_inline__)) read)(int __fd , void *__buf ,
                                                                 size_t __nbytes ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  intptr_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  intptr_t __cil_tmp10 ;
  intptr_t __cil_tmp11 ;

  {
  {
#line 36
  __cil_tmp4 = __builtin_object_size(__buf, 0);
  }
#line 36
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 38
    __cil_tmp5 = 0;
#line 38
    if (! __cil_tmp5) {
      {
#line 39
      __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 39
      __cil_tmp7 = __read_chk(__fd, __buf, __nbytes, __cil_tmp6);
      }
#line 39
      return (__cil_tmp7);
    }
    {
#line 41
    __cil_tmp8 = __builtin_object_size(__buf, 0);
    }
#line 41
    if (__nbytes > __cil_tmp8) {
      {
#line 42
      __cil_tmp9 = __builtin_object_size(__buf, 0);
#line 42
      __cil_tmp10 = __read_chk_warn(__fd, __buf, __nbytes, __cil_tmp9);
      }
#line 42
      return (__cil_tmp10);
    }
  }
  {
#line 44
  __cil_tmp11 = __read_alias(__fd, __buf, __nbytes);
  }
#line 44
  return (__cil_tmp11);
}
}
#line 48
extern intptr_t __pread_chk(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                            size_t __bufsize ) ;
#line 50
extern intptr_t __pread64_chk(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                              size_t __bufsize ) ;
#line 52
extern intptr_t __pread_alias(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 55
extern intptr_t __pread64_alias(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) ;
#line 58
extern intptr_t __pread_chk_warn(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                                 size_t __bufsize ) ;
#line 63
extern intptr_t __pread64_chk_warn(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                                   size_t __bufsize ) ;
#line 72 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern intptr_t ( __attribute__((__gnu_inline__)) pread)(int __fd , void *__buf ,
                                                                  size_t __nbytes ,
                                                                  __off_t __offset ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  intptr_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  intptr_t __cil_tmp11 ;
  intptr_t __cil_tmp12 ;

  {
  {
#line 74
  __cil_tmp5 = __builtin_object_size(__buf, 0);
  }
#line 74
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 76
    __cil_tmp6 = 0;
#line 76
    if (! __cil_tmp6) {
      {
#line 77
      __cil_tmp7 = __builtin_object_size(__buf, 0);
#line 77
      __cil_tmp8 = __pread_chk(__fd, __buf, __nbytes, __offset, __cil_tmp7);
      }
#line 77
      return (__cil_tmp8);
    }
    {
#line 79
    __cil_tmp9 = __builtin_object_size(__buf, 0);
    }
#line 79
    if (__nbytes > __cil_tmp9) {
      {
#line 80
      __cil_tmp10 = __builtin_object_size(__buf, 0);
#line 80
      __cil_tmp11 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp10);
      }
#line 80
      return (__cil_tmp11);
    }
  }
  {
#line 83
  __cil_tmp12 = __pread_alias(__fd, __buf, __nbytes, __offset);
  }
#line 83
  return (__cil_tmp12);
}
}
#line 105 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern intptr_t ( __attribute__((__gnu_inline__)) pread64)(int __fd , void *__buf ,
                                                                    size_t __nbytes ,
                                                                    __off64_t __offset ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  intptr_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  intptr_t __cil_tmp11 ;
  intptr_t __cil_tmp12 ;

  {
  {
#line 107
  __cil_tmp5 = __builtin_object_size(__buf, 0);
  }
#line 107
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 109
    __cil_tmp6 = 0;
#line 109
    if (! __cil_tmp6) {
      {
#line 110
      __cil_tmp7 = __builtin_object_size(__buf, 0);
#line 110
      __cil_tmp8 = __pread64_chk(__fd, __buf, __nbytes, __offset, __cil_tmp7);
      }
#line 110
      return (__cil_tmp8);
    }
    {
#line 112
    __cil_tmp9 = __builtin_object_size(__buf, 0);
    }
#line 112
    if (__nbytes > __cil_tmp9) {
      {
#line 113
      __cil_tmp10 = __builtin_object_size(__buf, 0);
#line 113
      __cil_tmp11 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp10);
      }
#line 113
      return (__cil_tmp11);
    }
  }
  {
#line 117
  __cil_tmp12 = __pread64_alias(__fd, __buf, __nbytes, __offset);
  }
#line 117
  return (__cil_tmp12);
}
}
#line 123
extern  __attribute__((__nothrow__)) intptr_t __readlink_chk(char const   *__path ,
                                                             char *__buf , size_t __len ,
                                                             size_t __buflen ) ;
#line 127
extern  __attribute__((__nothrow__)) intptr_t __readlink_alias(char const   *__path ,
                                                               char *__buf , size_t __len ) ;
#line 131
extern  __attribute__((__nothrow__)) intptr_t __readlink_chk_warn(char const   *__path ,
                                                                  char *__buf , size_t __len ,
                                                                  size_t __buflen ) ;
#line 139
__inline extern  __attribute__((__nothrow__)) intptr_t ( __attribute__((__gnu_inline__)) readlink)(char const   *__path ,
                                                                                                   char *__buf ,
                                                                                                   size_t __len ) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern intptr_t ( __attribute__((__gnu_inline__)) readlink)(char const   *__path ,
                                                                     char *__buf ,
                                                                     size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  intptr_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  intptr_t __cil_tmp10 ;
  intptr_t __cil_tmp11 ;

  {
  {
#line 142
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 142
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 144
    __cil_tmp5 = 0;
#line 144
    if (! __cil_tmp5) {
      {
#line 145
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 145
      __cil_tmp7 = __readlink_chk(__path, __buf, __len, __cil_tmp6);
      }
#line 145
      return (__cil_tmp7);
    }
    {
#line 147
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 147
    if (__len > __cil_tmp8) {
      {
#line 148
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 148
      __cil_tmp10 = __readlink_chk_warn(__path, __buf, __len, __cil_tmp9);
      }
#line 148
      return (__cil_tmp10);
    }
  }
  {
#line 150
  __cil_tmp11 = __readlink_alias(__path, __buf, __len);
  }
#line 150
  return (__cil_tmp11);
}
}
#line 155
extern  __attribute__((__nothrow__)) intptr_t __readlinkat_chk(int __fd , char const   *__path ,
                                                               char *__buf , size_t __len ,
                                                               size_t __buflen ) ;
#line 159
extern  __attribute__((__nothrow__)) intptr_t __readlinkat_alias(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len ) ;
#line 164
extern  __attribute__((__nothrow__)) intptr_t __readlinkat_chk_warn(int __fd , char const   *__path ,
                                                                    char *__buf ,
                                                                    size_t __len ,
                                                                    size_t __buflen ) ;
#line 173
__inline extern  __attribute__((__nothrow__)) intptr_t ( __attribute__((__gnu_inline__)) readlinkat)(int __fd ,
                                                                                                     char const   *__path ,
                                                                                                     char *__buf ,
                                                                                                     size_t __len ) ;
#line 173 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern intptr_t ( __attribute__((__gnu_inline__)) readlinkat)(int __fd ,
                                                                       char const   *__path ,
                                                                       char *__buf ,
                                                                       size_t __len ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  intptr_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  intptr_t __cil_tmp11 ;
  intptr_t __cil_tmp12 ;

  {
  {
#line 176
  __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
  }
#line 176
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 178
    __cil_tmp6 = 0;
#line 178
    if (! __cil_tmp6) {
      {
#line 179
      __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
#line 179
      __cil_tmp8 = __readlinkat_chk(__fd, __path, __buf, __len, __cil_tmp7);
      }
#line 179
      return (__cil_tmp8);
    }
    {
#line 181
    __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
    }
#line 181
    if (__len > __cil_tmp9) {
      {
#line 182
      __cil_tmp10 = __builtin_object_size((void *)__buf, 1);
#line 182
      __cil_tmp11 = __readlinkat_chk_warn(__fd, __path, __buf, __len, __cil_tmp10);
      }
#line 182
      return (__cil_tmp11);
    }
  }
  {
#line 185
  __cil_tmp12 = __readlinkat_alias(__fd, __path, __buf, __len);
  }
#line 185
  return (__cil_tmp12);
}
}
#line 189
extern  __attribute__((__nothrow__)) char *__getcwd_chk(char *__buf , size_t __size ,
                                                        size_t __buflen ) ;
#line 191
extern  __attribute__((__nothrow__)) char *__getcwd_alias(char *__buf , size_t __size ) ;
#line 193
extern  __attribute__((__nothrow__)) char *__getcwd_chk_warn(char *__buf , size_t __size ,
                                                             size_t __buflen ) ;
#line 200
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getcwd)(char *__buf ,
                                                                                              size_t __size ) ;
#line 200 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *( __attribute__((__gnu_inline__)) getcwd)(char *__buf , size_t __size ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 202
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 202
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 204
    __cil_tmp4 = 0;
#line 204
    if (! __cil_tmp4) {
      {
#line 205
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 205
      __cil_tmp6 = __getcwd_chk(__buf, __size, __cil_tmp5);
      }
#line 205
      return (__cil_tmp6);
    }
    {
#line 207
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 207
    if (__size > __cil_tmp7) {
      {
#line 208
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 208
      __cil_tmp9 = __getcwd_chk_warn(__buf, __size, __cil_tmp8);
      }
#line 208
      return (__cil_tmp9);
    }
  }
  {
#line 210
  __cil_tmp10 = __getcwd_alias(__buf, __size);
  }
#line 210
  return (__cil_tmp10);
}
}
#line 214
extern  __attribute__((__nothrow__)) char *__getwd_chk(char *__buf , size_t buflen ) ;
#line 216
extern  __attribute__((__nothrow__)) char *__getwd_warn(char *__buf ) ;
#line 221
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getwd)(char *__buf ) ;
#line 221 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *( __attribute__((__gnu_inline__)) getwd)(char *__buf ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 223
  __cil_tmp2 = __builtin_object_size((void *)__buf, 1);
  }
#line 223
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 224
    __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
#line 224
    __cil_tmp4 = __getwd_chk(__buf, __cil_tmp3);
    }
#line 224
    return (__cil_tmp4);
  }
  {
#line 225
  __cil_tmp5 = __getwd_warn(__buf);
  }
#line 225
  return (__cil_tmp5);
}
}
#line 229
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
#line 231
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen ) ;
#line 240
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) confstr)(int __name ,
                                                                                                char *__buf ,
                                                                                                size_t __len ) ;
#line 240 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) confstr)(int __name , char *__buf ,
                                                                  size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 242
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 242
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 244
    __cil_tmp5 = 0;
#line 244
    if (! __cil_tmp5) {
      {
#line 245
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 245
      __cil_tmp7 = __confstr_chk(__name, __buf, __len, __cil_tmp6);
      }
#line 245
      return (__cil_tmp7);
    }
    {
#line 247
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 247
    if (__cil_tmp8 < __len) {
      {
#line 248
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 248
      __cil_tmp10 = __confstr_chk_warn(__name, __buf, __len, __cil_tmp9);
      }
#line 248
      return (__cil_tmp10);
    }
  }
  {
#line 250
  __cil_tmp11 = __confstr_alias(__name, __buf, __len);
  }
#line 250
  return (__cil_tmp11);
}
}
#line 254
extern  __attribute__((__nothrow__)) int __getgroups_chk(int __size , __gid_t *__list ,
                                                         size_t __listlen ) ;
#line 256
extern  __attribute__((__nothrow__)) int __getgroups_alias(int __size , __gid_t *__list ) ;
#line 258
extern  __attribute__((__nothrow__)) int __getgroups_chk_warn(int __size , __gid_t *__list ,
                                                              size_t __listlen ) ;
#line 265
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getgroups)(int __size ,
                                                                                               __gid_t *__list ) ;
#line 265 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) getgroups)(int __size , __gid_t *__list ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 267
  __cil_tmp3 = __builtin_object_size((void *)__list, 1);
  }
#line 267
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 269
    __cil_tmp4 = 0;
#line 269
    if (! __cil_tmp4) {
      {
#line 270
      __cil_tmp5 = __builtin_object_size((void *)__list, 1);
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
#line 270
      return (__cil_tmp6);
    } else
#line 269
    if (__size < 0) {
      {
#line 270
      __cil_tmp5 = __builtin_object_size((void *)__list, 1);
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
#line 270
      return (__cil_tmp6);
    }
    {
#line 272
    __cil_tmp7 = __builtin_object_size((void *)__list, 1);
    }
#line 272
    if ((unsigned long )__size * sizeof(__gid_t ) > __cil_tmp7) {
      {
#line 273
      __cil_tmp8 = __builtin_object_size((void *)__list, 1);
#line 273
      __cil_tmp9 = __getgroups_chk_warn(__size, __list, __cil_tmp8);
      }
#line 273
      return (__cil_tmp9);
    }
  }
  {
#line 275
  __cil_tmp10 = __getgroups_alias(__size, __list);
  }
#line 275
  return (__cil_tmp10);
}
}
#line 279
extern  __attribute__((__nothrow__)) int __ttyname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 281
extern  __attribute__((__nothrow__)) int __ttyname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 284
extern  __attribute__((__nothrow__)) int __ttyname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 291
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ttyname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 291 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                                 size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 293
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 293
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 295
    __cil_tmp5 = 0;
#line 295
    if (! __cil_tmp5) {
      {
#line 296
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 296
      __cil_tmp7 = __ttyname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 296
      return (__cil_tmp7);
    }
    {
#line 298
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 298
    if (__buflen > __cil_tmp8) {
      {
#line 299
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 299
      __cil_tmp10 = __ttyname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 299
      return (__cil_tmp10);
    }
  }
  {
#line 301
  __cil_tmp11 = __ttyname_r_alias(__fd, __buf, __buflen);
  }
#line 301
  return (__cil_tmp11);
}
}
#line 306
extern int __getlogin_r_chk(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 308
extern int __getlogin_r_alias(char *__buf , size_t __buflen ) ;
#line 310
extern int __getlogin_r_chk_warn(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 317 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) getlogin_r)(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 319
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 319
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 321
    __cil_tmp4 = 0;
#line 321
    if (! __cil_tmp4) {
      {
#line 322
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 322
      __cil_tmp6 = __getlogin_r_chk(__buf, __buflen, __cil_tmp5);
      }
#line 322
      return (__cil_tmp6);
    }
    {
#line 324
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 324
    if (__buflen > __cil_tmp7) {
      {
#line 325
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 325
      __cil_tmp9 = __getlogin_r_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 325
      return (__cil_tmp9);
    }
  }
  {
#line 327
  __cil_tmp10 = __getlogin_r_alias(__buf, __buflen);
  }
#line 327
  return (__cil_tmp10);
}
}
#line 333
extern  __attribute__((__nothrow__)) int __gethostname_chk(char *__buf , size_t __buflen ,
                                                           size_t __nreal ) ;
#line 335
extern  __attribute__((__nothrow__)) int __gethostname_alias(char *__buf , size_t __buflen ) ;
#line 337
extern  __attribute__((__nothrow__)) int __gethostname_chk_warn(char *__buf , size_t __buflen ,
                                                                size_t __nreal ) ;
#line 344
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) gethostname)(char *__buf ,
                                                                                                 size_t __buflen ) ;
#line 344 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) gethostname)(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 346
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 346
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 348
    __cil_tmp4 = 0;
#line 348
    if (! __cil_tmp4) {
      {
#line 349
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 349
      __cil_tmp6 = __gethostname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 349
      return (__cil_tmp6);
    }
    {
#line 351
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 351
    if (__buflen > __cil_tmp7) {
      {
#line 352
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 352
      __cil_tmp9 = __gethostname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 352
      return (__cil_tmp9);
    }
  }
  {
#line 354
  __cil_tmp10 = __gethostname_alias(__buf, __buflen);
  }
#line 354
  return (__cil_tmp10);
}
}
#line 360
extern  __attribute__((__nothrow__)) int __getdomainname_chk(char *__buf , size_t __buflen ,
                                                             size_t __nreal ) ;
#line 362
extern  __attribute__((__nothrow__)) int __getdomainname_alias(char *__buf , size_t __buflen ) ;
#line 365
extern  __attribute__((__nothrow__)) int __getdomainname_chk_warn(char *__buf , size_t __buflen ,
                                                                  size_t __nreal ) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getdomainname)(char *__buf ,
                                                                                                   size_t __buflen ) ;
#line 373 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) getdomainname)(char *__buf ,
                                                                     size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 375
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 375
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 377
    __cil_tmp4 = 0;
#line 377
    if (! __cil_tmp4) {
      {
#line 378
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 378
      __cil_tmp6 = __getdomainname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 378
      return (__cil_tmp6);
    }
    {
#line 380
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 380
    if (__buflen > __cil_tmp7) {
      {
#line 381
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 381
      __cil_tmp9 = __getdomainname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 381
      return (__cil_tmp9);
    }
  }
  {
#line 383
  __cil_tmp10 = __getdomainname_alias(__buf, __buflen);
  }
#line 383
  return (__cil_tmp10);
}
}
#line 157 "/usr/include/ogg/ogg.h"
extern int ogg_stream_packetin(ogg_stream_state *os , ogg_packet *op ) ;
#line 160
extern int ogg_stream_pageout(ogg_stream_state *os , ogg_page *og ) ;
#line 162
extern int ogg_stream_flush(ogg_stream_state *os , ogg_page *og ) ;
#line 167
extern int ogg_sync_init(ogg_sync_state *oy ) ;
#line 168
extern int ogg_sync_clear(ogg_sync_state *oy ) ;
#line 169
extern int ogg_sync_reset(ogg_sync_state *oy ) ;
#line 173
extern char *ogg_sync_buffer(ogg_sync_state *oy , long size ) ;
#line 174
extern int ogg_sync_wrote(ogg_sync_state *oy , long bytes ) ;
#line 176
extern int ogg_sync_pageout(ogg_sync_state *oy , ogg_page *og ) ;
#line 177
extern int ogg_stream_pagein(ogg_stream_state *os , ogg_page *og ) ;
#line 178
extern int ogg_stream_packetout(ogg_stream_state *os , ogg_packet *op ) ;
#line 183
extern int ogg_stream_init(ogg_stream_state *os , int serialno ) ;
#line 184
extern int ogg_stream_clear(ogg_stream_state *os ) ;
#line 185
extern int ogg_stream_reset(ogg_stream_state *os ) ;
#line 196
extern int ogg_page_eos(ogg_page *og ) ;
#line 197
extern ogg_int64_t ogg_page_granulepos(ogg_page *og ) ;
#line 198
extern int ogg_page_serialno(ogg_page *og ) ;
#line 43 "/root/patchweave_new/23/src/ogg.c"
static int ogg_close(SF_PRIVATE *psf ) ;
#line 44
static int ogg_stream_classify(SF_PRIVATE *psf , OGG_PRIVATE *odata ) ;
#line 45
static int ogg_page_classify(SF_PRIVATE *psf , ogg_page *og ) ;
#line 48 "/root/patchweave_new/23/src/ogg.c"
int ogg_open(SF_PRIVATE *psf ) 
{ 
  OGG_PRIVATE *odata ;
  void *__cil_tmp3 ;
  sf_count_t pos ;
  sf_count_t __cil_tmp5 ;
  int error ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 49
  __cil_tmp3 = calloc(1UL, sizeof(OGG_PRIVATE ));
#line 49
  odata = (OGG_PRIVATE *)__cil_tmp3;
#line 50
  __cil_tmp5 = psf_ftell(psf);
#line 50
  pos = __cil_tmp5;
#line 51
  error = 0;
#line 53
  psf->container_data = (void *)odata;
#line 54
  psf->container_close = & ogg_close;
  }
#line 56
  if (psf->file.mode == 48) {
#line 57
    return (24);
  }
#line 59
  if (psf->file.mode == 16) {
    {
#line 60
    error = ogg_stream_classify(psf, odata);
    }
#line 60
    if (error != 0) {
#line 61
      return (error);
    }
  }
  {
#line 64
  ogg_sync_clear(& odata->osync);
#line 65
  ogg_stream_clear(& odata->ostream);
#line 66
  psf_fseek(psf, pos, 0);
  }
#line 68
  if ((psf->sf.format & 805306368) != 0) {
#line 69
    return (32);
  }
#line 72
  if (psf->sf.format == 2097248) {
#line 72
    goto case_2097248;
  }
#line 75
  if (psf->sf.format == 83886081) {
#line 75
    goto case_83886081;
  }
#line 90
  goto switch_default;
  case_2097248: 
  {
#line 73
  __cil_tmp8 = ogg_vorbis_open(psf);
  }
#line 73
  return (__cil_tmp8);
  case_83886081: 
  {
#line 76
  free(psf->container_data);
#line 77
  psf->container_data = (void *)0;
#line 78
  psf->container_close = (int (*)(struct sf_private_tag * ))((void *)0);
#line 79
  __cil_tmp9 = flac_open(psf);
  }
#line 79
  return (__cil_tmp9);
  switch_default: 
#line 91
  goto switch_break;
  switch_break: 
  {
#line 94
  psf_log_printf(psf, "%s : bad psf->sf.format 0x%x.\n", "ogg_open\312\001@", psf->sf.format);
  }
#line 95
  return (30);
}
}
#line 100 "/root/patchweave_new/23/src/ogg.c"
static int ogg_close(SF_PRIVATE *psf ) 
{ 
  OGG_PRIVATE *odata ;

  {
  {
#line 101
  odata = (OGG_PRIVATE *)psf->container_data;
#line 103
  ogg_sync_clear(& odata->osync);
#line 104
  ogg_stream_clear(& odata->ostream);
  }
#line 106
  return (0);
}
}
#line 110 "/root/patchweave_new/23/src/ogg.c"
static int ogg_stream_classify(SF_PRIVATE *psf , OGG_PRIVATE *odata ) 
{ 
  char *buffer ;
  int bytes ;
  int nn ;
  sf_count_t __cil_tmp7 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 115
  ogg_sync_init(& odata->osync);
#line 117
  odata->eos = 0;
#line 120
  ogg_stream_reset(& odata->ostream);
#line 121
  ogg_sync_reset(& odata->osync);
#line 131
  buffer = ogg_sync_buffer(& odata->osync, 4096L);
#line 134
  memcpy((void *)buffer, (void const   *)psf->header.ptr, (unsigned long )psf->header.indx);
#line 135
  bytes = (int )psf->header.indx;
#line 138
  __cil_tmp7 = psf_fread((void *)(buffer + psf->header.indx), (sf_count_t )1, 4096L - psf->header.indx,
                         psf);
#line 138
  bytes = (int )((sf_count_t )bytes + __cil_tmp7);
#line 139
  ogg_sync_wrote(& odata->osync, (long )bytes);
#line 142
  nn = ogg_sync_pageout(& odata->osync, & odata->opage);
  }
#line 142
  if (nn != 1) {
#line 145
    if (bytes < 4096) {
#line 146
      return (0);
    }
    {
#line 149
    psf_log_printf(psf, "Input does not appear to be an Ogg bitstream.\n");
    }
#line 150
    return (3);
  }
  {
#line 157
  ogg_stream_clear(& odata->ostream);
#line 158
  __cil_tmp9 = ogg_page_serialno(& odata->opage);
#line 158
  ogg_stream_init(& odata->ostream, __cil_tmp9);
#line 160
  __cil_tmp10 = ogg_stream_pagein(& odata->ostream, & odata->opage);
  }
#line 160
  if (__cil_tmp10 < 0) {
    {
#line 162
    psf_log_printf(psf, "Error reading first page of Ogg bitstream data\n");
    }
#line 163
    return (3);
  }
  {
#line 166
  __cil_tmp11 = ogg_stream_packetout(& odata->ostream, & odata->opacket);
  }
#line 166
  if (__cil_tmp11 != 1) {
    {
#line 168
    psf_log_printf(psf, "Error reading initial header packet.\n");
    }
#line 169
    return (3);
  }
  {
#line 172
  odata->codec = ogg_page_classify(psf, & odata->opage);
  }
#line 175
  if (odata->codec == 306) {
#line 175
    goto case_306;
  }
#line 180
  if (odata->codec == 303) {
#line 180
    goto case_303;
  }
#line 180
  if (odata->codec == 302) {
#line 180
    goto case_303;
  }
#line 184
  if (odata->codec == 305) {
#line 184
    goto case_305;
  }
#line 188
  if (odata->codec == 304) {
#line 188
    goto case_304;
  }
#line 192
  goto switch_default;
  case_306: 
#line 176
  psf->sf.format = 2097248;
#line 177
  return (0);
  case_303: 
#line 181
  psf->sf.format = 83886081;
#line 182
  return (0);
  case_305: 
#line 185
  psf->sf.format = 85983232;
#line 186
  return (0);
  case_304: 
  {
#line 189
  psf_log_printf(psf, "Detected Ogg/PCM data. This is not supported yet.\n\223?\270U");
  }
#line 190
  return (18);
  switch_default: 
#line 193
  goto switch_break;
  switch_break: 
  {
#line 196
  psf_log_printf(psf, "This Ogg bitstream contains some uknown data type.\n");
  }
#line 197
  return (18);
}
}
#line 206 "/root/patchweave_new/23/src/ogg.c"
static struct __anonstruct_299 codec_lookup[7]  = {      {"Annodex", "Annodex", 8, 300}, 
        {"AnxData", "AnxData", 7, 301}, 
        {"\177FLACU", "Flac1U", 5, 302}, 
        {"fLaC\270U", "Flac0U", 4, 303}, 
        {"PCM     \323\001 ", "PCM?\270U", 8, 304}, 
        {"Speex", "Speex", 5, 305}, 
        {"\001vorbis", "Vorbis", 7, 306}};
#line 217 "/root/patchweave_new/23/src/ogg.c"
static int ogg_page_classify(SF_PRIVATE *psf , ogg_page *og ) 
{ 
  int k ;
  int len ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  long tmp ;
  unsigned short const   **__cil_tmp9 ;
  int tmp___0 ;

  {
#line 220
  k = 0;
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 220
    if (! (k < (int )(sizeof(codec_lookup) / sizeof(codec_lookup[0])))) {
#line 220
      goto while_break;
    }
#line 221
    if ((long )codec_lookup[k].len > og->body_len) {
#line 222
      goto while_continue;
    }
    {
#line 224
    __cil_tmp5 = memcmp((void const   *)og->body, (void const   *)codec_lookup[k].str,
                        (unsigned long )codec_lookup[k].len);
    }
#line 224
    if (__cil_tmp5 == 0) {
      {
#line 225
      psf_log_printf(psf, "Ogg stream data : %s\n", codec_lookup[k].name);
#line 226
      __cil_tmp6 = ogg_page_serialno(og);
#line 226
      psf_log_printf(psf, "Stream serialno : %u\n", (uint32_t )__cil_tmp6);
      }
#line 227
      return (codec_lookup[k].codec);
    }
#line 220
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 231
  if (og->body_len < 8L) {
#line 231
    tmp = og->body_len;
  } else {
#line 231
    tmp = 8L;
  }
  {
#line 231
  len = (int )tmp;
#line 233
  psf_log_printf(psf, "Ogg_stream data : \'");
#line 234
  k = 0;
  }
  {
#line 234
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 234
    if (! (k < len)) {
#line 234
      goto while_break___0;
    }
    {
#line 235
    __cil_tmp9 = __ctype_b_loc();
    }
#line 235
    if ((int )*(*__cil_tmp9 + (int )*(og->body + k)) & 16384) {
#line 235
      tmp___0 = (int )*(og->body + k);
    } else {
#line 235
      tmp___0 = '.';
    }
    {
#line 235
    psf_log_printf(psf, "%c", tmp___0);
#line 234
    k ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 236
  psf_log_printf(psf, "\'     ");
#line 237
  k = 0;
  }
  {
#line 237
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 237
    if (! (k < len)) {
#line 237
      goto while_break___1;
    }
    {
#line 238
    psf_log_printf(psf, " %02x", (int )*(og->body + k) & 255);
#line 237
    k ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 239
  psf_log_printf(psf, "\n\270\224?\270U");
  }
#line 241
  return (0);
}
}
#line 329 "/root/patchweave_new/23/src/wavlike.h"
void wavlike_msadpcm_write_adapt_coeffs(SF_PRIVATE *psf ) ;
#line 335
char const   *wavlike_format_str(int k ) ;
#line 337
int wavlike_srate2blocksize(int srate_chan_product ) ;
#line 338
int wavlike_read_fmt_chunk(SF_PRIVATE *psf , int fmtsize ) ;
#line 339
void wavlike_write_guid(SF_PRIVATE *psf , EXT_SUBFORMAT *subformat ) ;
#line 340
void wavlike_analyze(SF_PRIVATE *psf ) ;
#line 341
int wavlike_gen_channel_mask(int const   *chan_map , int channels ) ;
#line 343
int wavlike_read_bext_chunk(SF_PRIVATE *psf , uint32_t chunksize ) ;
#line 344
int wavlike_write_bext_chunk(SF_PRIVATE *psf ) ;
#line 346
int wavlike_read_cart_chunk(SF_PRIVATE *psf , uint32_t chunksize ) ;
#line 347
int wavlike_write_cart_chunk(SF_PRIVATE *psf ) ;
#line 349
int wavlike_subchunk_parse(SF_PRIVATE *psf , int chunk , uint32_t chunk_length ) ;
#line 350
void wavlike_write_strings(SF_PRIVATE *psf , int location ) ;
#line 352
int wavlike_read_peak_chunk(SF_PRIVATE *psf , size_t chunk_size ) ;
#line 353
void wavlike_write_peak_chunk(SF_PRIVATE *psf ) ;
#line 355
void wavlike_write_custom_chunks(SF_PRIVATE *psf ) ;
#line 46 "/root/patchweave_new/23/src/ms_adpcm.c"
static int AdaptationTable[16]  = 
#line 46 "/root/patchweave_new/23/src/ms_adpcm.c"
  {      230,      230,      230,      230, 
        307,      409,      512,      614, 
        768,      614,      512,      409, 
        307,      230,      230,      230};
#line 55 "/root/patchweave_new/23/src/ms_adpcm.c"
static int AdaptCoeff1[7]  = {      256,      512,      0,      192, 
        240,      460,      392};
#line 59 "/root/patchweave_new/23/src/ms_adpcm.c"
static int AdaptCoeff2[7]  = {      0,      -256,      0,      64, 
        0,      -208,      -232};
#line 92
static int msadpcm_decode_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms ) ;
#line 93
static sf_count_t msadpcm_read_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms , short *ptr ,
                                     int len ) ;
#line 95
static int msadpcm_encode_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms ) ;
#line 96
static sf_count_t msadpcm_write_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms , short const   *ptr ,
                                      int len ) ;
#line 98
static sf_count_t msadpcm_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 99
static sf_count_t msadpcm_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 100
static sf_count_t msadpcm_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 101
static sf_count_t msadpcm_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 103
static sf_count_t msadpcm_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 104
static sf_count_t msadpcm_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 105
static sf_count_t msadpcm_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 106
static sf_count_t msadpcm_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 108
static sf_count_t msadpcm_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 109
static int msadpcm_close(SF_PRIVATE *psf ) ;
#line 111
static void choose_predictor(unsigned int channels , short *data , int *block_pred ,
                             int *idelta ) ;
#line 118 "/root/patchweave_new/23/src/ms_adpcm.c"
int wavlike_msadpcm_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) 
{ 
  MSADPCM_PRIVATE *pms ;
  unsigned int pmssize ;
  int count ;

  {
#line 123
  if ((unsigned long )psf->codec_data != (unsigned long )((void *)0)) {
    {
#line 124
    psf_log_printf(psf, "*** psf->codec_data is not NULL.\n\311\230?\270U");
    }
#line 125
    return (30);
  }
#line 128
  if (psf->file.mode == 32) {
#line 129
    samplesperblock = 2 + (2 * (blockalign - 7 * psf->sf.channels)) / psf->sf.channels;
  }
#line 131
  if (blockalign < 7 * psf->sf.channels) {
    {
#line 132
    psf_log_printf(psf, "*** Error blockalign (%d) should be > %d.\n", blockalign,
                   7 * psf->sf.channels);
    }
#line 133
    return (30);
  }
  {
#line 136
  pmssize = (unsigned int )((sizeof(MSADPCM_PRIVATE ) + (unsigned long )blockalign) + (unsigned long )((3 * psf->sf.channels) * samplesperblock));
#line 138
  psf->codec_data = calloc(1UL, (unsigned long )pmssize);
  }
#line 138
  if (! psf->codec_data) {
#line 139
    return (17);
  }
#line 140
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 142
  pms->sync_error = 0;
#line 143
  pms->samples = pms->dummydata;
#line 144
  pms->block = (unsigned char *)(pms->dummydata + psf->sf.channels * samplesperblock);
#line 146
  pms->channels = psf->sf.channels;
#line 147
  pms->blocksize = blockalign;
#line 148
  pms->samplesperblock = samplesperblock;
#line 150
  if (pms->blocksize <= 0) {
    {
#line 151
    psf_log_printf(psf, "*** Error : pms->blocksize should be > 0.\n");
    }
#line 152
    return (30);
  }
#line 155
  if (psf->file.mode == 16) {
#line 156
    pms->dataremaining = (int )psf->datalength;
#line 158
    if (psf->datalength % (long )pms->blocksize) {
#line 159
      pms->blocks = (int )(psf->datalength / (long )pms->blocksize + 1L);
    } else {
#line 161
      pms->blocks = (int )(psf->datalength / (long )pms->blocksize);
    }
#line 163
    count = (2 * (pms->blocksize - 6 * pms->channels)) / pms->channels;
#line 164
    if (pms->samplesperblock != count) {
      {
#line 165
      psf_log_printf(psf, "*** Error : samplesperblock should be %d.\n", count);
      }
#line 166
      return (30);
    }
    {
#line 169
    psf->sf.frames = (psf->datalength / (long )pms->blocksize) * (long )pms->samplesperblock;
#line 171
    msadpcm_decode_block(psf, pms);
#line 173
    psf->read_short = & msadpcm_read_s;
#line 174
    psf->read_int = & msadpcm_read_i;
#line 175
    psf->read_float = & msadpcm_read_f;
#line 176
    psf->read_double = & msadpcm_read_d;
    }
  }
#line 179
  if (psf->file.mode == 32) {
#line 180
    pms->samples = pms->dummydata;
#line 182
    pms->samplecount = (sf_count_t )0;
#line 184
    psf->write_short = & msadpcm_write_s;
#line 185
    psf->write_int = & msadpcm_write_i;
#line 186
    psf->write_float = & msadpcm_write_f;
#line 187
    psf->write_double = & msadpcm_write_d;
  }
#line 190
  psf->codec_close = & msadpcm_close;
#line 191
  psf->seek = & msadpcm_seek;
#line 193
  return (0);
}
}
#line 198 "/root/patchweave_new/23/src/ms_adpcm.c"
__inline static short msadpcm_get_bpred(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms , unsigned char value ) 
{ 


  {
#line 199
  if ((int )value >= 7) {
#line 200
    if (pms->sync_error == 0) {
      {
#line 201
      pms->sync_error = 1;
#line 202
      psf_log_printf(psf, "MS ADPCM synchronisation error (%u should be < %u).\n",
                     (int )value, 7);
      }
    }
#line 204
    return ((short)0);
  }
#line 206
  return ((short )value);
}
}
#line 211 "/root/patchweave_new/23/src/ms_adpcm.c"
static int msadpcm_decode_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms ) 
{ 
  int chan ;
  int k ;
  int blockindx ;
  int sampleindx ;
  short bytecode ;
  short bpred[2] ;
  short chan_idelta[2] ;
  int predict ;
  int current ;
  int idelta ;
  sf_count_t __cil_tmp14 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp ;

  {
#line 219
  (pms->blockcount) ++;
#line 220
  pms->samplecount = (sf_count_t )0;
#line 222
  if (pms->blockcount > pms->blocks) {
    {
#line 223
    memset((void *)pms->samples, 0, (unsigned long )(pms->samplesperblock * pms->channels));
    }
#line 224
    return (1);
  }
  {
#line 227
  __cil_tmp14 = psf_fread((void *)pms->block, (sf_count_t )1, (sf_count_t )pms->blocksize,
                          psf);
#line 227
  k = (int )__cil_tmp14;
  }
#line 227
  if (k != pms->blocksize) {
    {
#line 228
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\nU", k, pms->blocksize);
    }
#line 229
    if (k <= 0) {
#line 230
      return (1);
    }
  }
#line 235
  if (pms->channels == 1) {
    {
#line 236
    bpred[0] = msadpcm_get_bpred(psf, pms, *(pms->block + 0));
#line 238
    chan_idelta[0] = (short )((int )*(pms->block + 1) | ((int )*(pms->block + 2) << 8));
#line 239
    chan_idelta[1] = (short)0;
#line 241
    *(pms->samples + 1) = (short )((int )*(pms->block + 3) | ((int )*(pms->block + 4) << 8));
#line 242
    *(pms->samples + 0) = (short )((int )*(pms->block + 5) | ((int )*(pms->block + 6) << 8));
#line 243
    blockindx = 7;
    }
  } else {
    {
#line 246
    bpred[0] = msadpcm_get_bpred(psf, pms, *(pms->block + 0));
#line 247
    bpred[1] = msadpcm_get_bpred(psf, pms, *(pms->block + 1));
#line 249
    chan_idelta[0] = (short )((int )*(pms->block + 2) | ((int )*(pms->block + 3) << 8));
#line 250
    chan_idelta[1] = (short )((int )*(pms->block + 4) | ((int )*(pms->block + 5) << 8));
#line 252
    *(pms->samples + 2) = (short )((int )*(pms->block + 6) | ((int )*(pms->block + 7) << 8));
#line 253
    *(pms->samples + 3) = (short )((int )*(pms->block + 8) | ((int )*(pms->block + 9) << 8));
#line 255
    *(pms->samples + 0) = (short )((int )*(pms->block + 10) | ((int )*(pms->block + 11) << 8));
#line 256
    *(pms->samples + 1) = (short )((int )*(pms->block + 12) | ((int )*(pms->block + 13) << 8));
#line 258
    blockindx = 14;
    }
  }
#line 276
  sampleindx = 2 * pms->channels;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;

#line 277
    if (! (blockindx < pms->blocksize)) {
#line 277
      goto while_break;
    }
#line 278
    __cil_tmp18 = blockindx;
#line 278
    blockindx ++;
#line 278
    bytecode = (short )*(pms->block + __cil_tmp18);
#line 279
    __cil_tmp19 = sampleindx;
#line 279
    sampleindx ++;
#line 279
    *(pms->samples + __cil_tmp19) = (short )(((int )bytecode >> 4) & 15);
#line 280
    __cil_tmp20 = sampleindx;
#line 280
    sampleindx ++;
#line 280
    *(pms->samples + __cil_tmp20) = (short )((int )bytecode & 15);
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 285
  k = 2 * pms->channels;
  {
#line 285
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 285
    if (! (k < pms->samplesperblock * pms->channels)) {
#line 285
      goto while_break___0;
    }
#line 286
    if (pms->channels > 1) {
#line 286
      tmp = k % 2;
    } else {
#line 286
      tmp = 0;
    }
#line 286
    chan = tmp;
#line 288
    bytecode = (short )((int )*(pms->samples + k) & 15);
#line 291
    idelta = (int )chan_idelta[chan];
#line 292
    chan_idelta[chan] = (short )(AdaptationTable[bytecode] * idelta >> 8);
#line 293
    if ((int )chan_idelta[chan] < 16) {
#line 294
      chan_idelta[chan] = (short)16;
    }
#line 295
    if ((int )bytecode & 8) {
#line 296
      bytecode = (short )((int )bytecode - 16);
    }
#line 298
    predict = ((int )*(pms->samples + (k - pms->channels)) * AdaptCoeff1[bpred[chan]] + (int )*(pms->samples + (k - 2 * pms->channels)) * AdaptCoeff2[bpred[chan]]) >> 8;
#line 300
    current = (int )bytecode * idelta + predict;
#line 302
    if (current > 32767) {
#line 303
      current = 32767;
    } else
#line 304
    if (current < -32768) {
#line 305
      current = -32768;
    }
#line 307
    *(pms->samples + k) = (short )current;
#line 285
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 310
  return (0);
}
}
#line 314 "/root/patchweave_new/23/src/ms_adpcm.c"
static sf_count_t msadpcm_read_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms , short *ptr ,
                                     int len ) 
{ 
  int count ;
  int total ;
  int indx ;
  int __cil_tmp8 ;
  int tmp ;

  {
#line 315
  total = 0;
#line 315
  indx = 0;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;

#line 317
    if (! (indx < len)) {
#line 317
      goto while_break;
    }
#line 318
    if (pms->blockcount >= pms->blocks) {
#line 318
      if (pms->samplecount >= (long )pms->samplesperblock) {
        {
#line 319
        memset((void *)(ptr + indx), 0, (unsigned long )(len - indx) * sizeof(short ));
        }
#line 320
        return ((sf_count_t )total);
      }
    }
#line 323
    if (pms->samplecount >= (long )pms->samplesperblock) {
      {
#line 324
      __cil_tmp8 = msadpcm_decode_block(psf, pms);
      }
#line 324
      if (__cil_tmp8 != 0) {
#line 325
        return ((sf_count_t )total);
      }
    }
#line 327
    count = (int )(((long )pms->samplesperblock - pms->samplecount) * (long )pms->channels);
#line 328
    if (len - indx > count) {
#line 328
      tmp = count;
    } else {
#line 328
      tmp = len - indx;
    }
    {
#line 328
    count = tmp;
#line 330
    memcpy((void *)(ptr + indx), (void const   *)(pms->samples + pms->samplecount * (long )pms->channels),
           (unsigned long )count * sizeof(short ));
#line 331
    indx += count;
#line 332
    pms->samplecount += (long )(count / pms->channels);
#line 333
    total = indx;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 336
  return ((sf_count_t )total);
}
}
#line 340 "/root/patchweave_new/23/src/ms_adpcm.c"
static sf_count_t msadpcm_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  int readcount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 343
  total = (sf_count_t )0;
#line 345
  if (! psf->codec_data) {
#line 346
    return ((sf_count_t )0);
  }
#line 347
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;

#line 349
    if (! (len > 0L)) {
#line 349
      goto while_break;
    }
#line 350
    if (len > 268435456L) {
#line 350
      tmp = 268435456;
    } else {
#line 350
      tmp = (int )len;
    }
    {
#line 350
    readcount = tmp;
#line 352
    __cil_tmp9 = msadpcm_read_block(psf, pms, ptr, readcount);
#line 352
    count = (int )__cil_tmp9;
    }
#line 352
    if (count <= 0) {
#line 353
      return ((sf_count_t )-1);
    }
#line 355
    total += (long )count;
#line 356
    len -= (long )count;
#line 357
    if (count != readcount) {
#line 358
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 361
  return (total);
}
}
#line 365 "/root/patchweave_new/23/src/ms_adpcm.c"
static sf_count_t msadpcm_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  sf_count_t __cil_tmp13 ;

  {
#line 369
  readcount = 0;
#line 370
  total = (sf_count_t )0;
#line 372
  if (! psf->codec_data) {
#line 373
    return ((sf_count_t )0);
  }
#line 374
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 376
  sptr = ubuf.sbuf;
#line 377
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;

#line 378
    if (! (len > 0L)) {
#line 378
      goto while_break;
    }
#line 379
    if (len >= (long )bufferlen) {
#line 379
      tmp = (long )bufferlen;
    } else {
#line 379
      tmp = len;
    }
    {
#line 379
    readcount = (int )tmp;
#line 381
    __cil_tmp13 = msadpcm_read_block(psf, pms, sptr, readcount);
#line 381
    count = (int )__cil_tmp13;
    }
#line 381
    if (count <= 0) {
#line 382
      return ((sf_count_t )-1);
    }
#line 384
    k = 0;
    {
#line 384
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 384
      if (! (k < readcount)) {
#line 384
        goto while_break___0;
      }
      {
#line 385
      *(ptr + (total + (long )k)) = arith_shift_left((int32_t )*(sptr + k), 16);
#line 384
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 386
    total += (long )count;
#line 387
    len -= (long )readcount;
#line 388
    if (count != readcount) {
#line 389
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 391
  return (total);
}
}
#line 395 "/root/patchweave_new/23/src/ms_adpcm.c"
static sf_count_t msadpcm_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  sf_count_t __cil_tmp15 ;

  {
#line 399
  readcount = 0;
#line 400
  total = (sf_count_t )0;
#line 403
  if (! psf->codec_data) {
#line 404
    return ((sf_count_t )0);
  }
#line 405
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 407
  if (psf->norm_float == 1) {
#line 407
    tmp = 1. / (double )((float )32768);
  } else {
#line 407
    tmp = 1.;
  }
#line 407
  normfact = (float )tmp;
#line 408
  sptr = ubuf.sbuf;
#line 409
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;

#line 410
    if (! (len > 0L)) {
#line 410
      goto while_break;
    }
#line 411
    if (len >= (long )bufferlen) {
#line 411
      tmp___0 = (long )bufferlen;
    } else {
#line 411
      tmp___0 = len;
    }
    {
#line 411
    readcount = (int )tmp___0;
#line 413
    __cil_tmp15 = msadpcm_read_block(psf, pms, sptr, readcount);
#line 413
    count = (int )__cil_tmp15;
    }
#line 413
    if (count <= 0) {
#line 414
      return ((sf_count_t )-1);
    }
#line 416
    k = 0;
    {
#line 416
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 416
      if (! (k < readcount)) {
#line 416
        goto while_break___0;
      }
#line 417
      *(ptr + (total + (long )k)) = normfact * (float )*(sptr + k);
#line 416
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 418
    total += (long )count;
#line 419
    len -= (long )readcount;
#line 420
    if (count != readcount) {
#line 421
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 423
  return (total);
}
}
#line 427 "/root/patchweave_new/23/src/ms_adpcm.c"
static sf_count_t msadpcm_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  sf_count_t __cil_tmp15 ;

  {
#line 431
  readcount = 0;
#line 432
  total = (sf_count_t )0;
#line 435
  if (! psf->codec_data) {
#line 436
    return ((sf_count_t )0);
  }
#line 437
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 439
  if (psf->norm_double == 1) {
#line 439
    tmp = 1. / (double )32768;
  } else {
#line 439
    tmp = 1.;
  }
#line 439
  normfact = tmp;
#line 440
  sptr = ubuf.sbuf;
#line 441
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;

#line 442
    if (! (len > 0L)) {
#line 442
      goto while_break;
    }
#line 443
    if (len >= (long )bufferlen) {
#line 443
      tmp___0 = (long )bufferlen;
    } else {
#line 443
      tmp___0 = len;
    }
    {
#line 443
    readcount = (int )tmp___0;
#line 445
    __cil_tmp15 = msadpcm_read_block(psf, pms, sptr, readcount);
#line 445
    count = (int )__cil_tmp15;
    }
#line 445
    if (count <= 0) {
#line 446
      return ((sf_count_t )-1);
    }
#line 448
    k = 0;
    {
#line 448
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 448
      if (! (k < readcount)) {
#line 448
        goto while_break___0;
      }
#line 449
      *(ptr + (total + (long )k)) = normfact * (double )*(sptr + k);
#line 448
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 450
    total += (long )count;
#line 451
    len -= (long )readcount;
#line 452
    if (count != readcount) {
#line 453
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 456
  return (total);
}
}
#line 460 "/root/patchweave_new/23/src/ms_adpcm.c"
static sf_count_t msadpcm_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  MSADPCM_PRIVATE *pms ;
  int newblock ;
  int newsample ;

  {
#line 464
  if (! psf->codec_data) {
#line 465
    return ((sf_count_t )0);
  }
#line 466
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 468
  if (psf->datalength < 0L) {
#line 469
    psf->error = 40;
#line 470
    return ((sf_count_t )-1);
  } else
#line 468
  if (psf->dataoffset < 0L) {
#line 469
    psf->error = 40;
#line 470
    return ((sf_count_t )-1);
  }
#line 473
  if (offset == 0L) {
    {
#line 474
    psf_fseek(psf, psf->dataoffset, 0);
#line 475
    pms->blockcount = 0;
#line 476
    msadpcm_decode_block(psf, pms);
#line 477
    pms->samplecount = (sf_count_t )0;
    }
#line 478
    return ((sf_count_t )0);
  }
#line 481
  if (offset < 0L) {
#line 482
    psf->error = 40;
#line 483
    return ((sf_count_t )-1);
  } else
#line 481
  if (offset > (long )(pms->blocks * pms->samplesperblock)) {
#line 482
    psf->error = 40;
#line 483
    return ((sf_count_t )-1);
  }
#line 486
  newblock = (int )(offset / (long )pms->samplesperblock);
#line 487
  newsample = (int )(offset % (long )pms->samplesperblock);
#line 489
  if (mode == 16) {
    {
#line 490
    psf_fseek(psf, psf->dataoffset + (long )(newblock * pms->blocksize), 0);
#line 491
    pms->blockcount = newblock;
#line 492
    msadpcm_decode_block(psf, pms);
#line 493
    pms->samplecount = (sf_count_t )newsample;
    }
  } else {
#line 497
    psf->error = 40;
#line 498
    return ((sf_count_t )-1);
  }
#line 501
  return ((sf_count_t )(newblock * pms->samplesperblock + newsample));
}
}
#line 509 "/root/patchweave_new/23/src/ms_adpcm.c"
void wavlike_msadpcm_write_adapt_coeffs(SF_PRIVATE *psf ) 
{ 
  int k ;

  {
#line 512
  k = 0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;

#line 512
    if (! (k < 7)) {
#line 512
      goto while_break;
    }
    {
#line 513
    psf_binheader_writef(psf, "22", AdaptCoeff1[k], AdaptCoeff2[k]);
#line 512
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 516
  return;
}
}
#line 520 "/root/patchweave_new/23/src/ms_adpcm.c"
static int msadpcm_encode_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms ) 
{ 
  unsigned int blockindx ;
  unsigned char byte ;
  int chan ;
  int k ;
  int predict ;
  int bpred[2] ;
  int idelta[2] ;
  int errordelta ;
  int newsamp ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp14 ;
  sf_count_t __cil_tmp16 ;

  {
  {
#line 525
  choose_predictor((unsigned int )pms->channels, pms->samples, bpred, idelta);
  }
#line 529
  if (pms->channels == 1) {
#line 530
    *(pms->block + 0) = (unsigned char )bpred[0];
#line 531
    *(pms->block + 1) = (unsigned char )(idelta[0] & 255);
#line 532
    *(pms->block + 2) = (unsigned char )(idelta[0] >> 8);
#line 533
    *(pms->block + 3) = (unsigned char )((int )*(pms->samples + 1) & 255);
#line 534
    *(pms->block + 4) = (unsigned char )((int )*(pms->samples + 1) >> 8);
#line 535
    *(pms->block + 5) = (unsigned char )((int )*(pms->samples + 0) & 255);
#line 536
    *(pms->block + 6) = (unsigned char )((int )*(pms->samples + 0) >> 8);
#line 538
    blockindx = 7U;
#line 539
    byte = (unsigned char)0;
#line 543
    k = 2;
    {
#line 543
    while (1) {
      while_continue: /* CIL Label */ ;

#line 543
      if (! (k < pms->samplesperblock)) {
#line 543
        goto while_break;
      }
#line 544
      predict = ((int )*(pms->samples + (k - 1)) * AdaptCoeff1[bpred[0]] + (int )*(pms->samples + (k - 2)) * AdaptCoeff2[bpred[0]]) >> 8;
#line 545
      errordelta = ((int )*(pms->samples + k) - predict) / idelta[0];
#line 546
      if (errordelta < -8) {
#line 547
        errordelta = -8;
      } else
#line 548
      if (errordelta > 7) {
#line 549
        errordelta = 7;
      }
#line 550
      newsamp = predict + idelta[0] * errordelta;
#line 551
      if (newsamp > 32767) {
#line 552
        newsamp = 32767;
      } else
#line 553
      if (newsamp < -32768) {
#line 554
        newsamp = -32768;
      }
#line 555
      if (errordelta < 0) {
#line 556
        errordelta += 16;
      }
#line 558
      byte = (unsigned char )(((int )byte << 4) | (errordelta & 15));
#line 559
      if (k % 2) {
#line 560
        __cil_tmp12 = blockindx;
#line 560
        blockindx ++;
#line 560
        *(pms->block + __cil_tmp12) = byte;
#line 561
        byte = (unsigned char)0;
      }
#line 564
      idelta[0] = idelta[0] * AdaptationTable[errordelta] >> 8;
#line 565
      if (idelta[0] < 16) {
#line 566
        idelta[0] = 16;
      }
#line 567
      *(pms->samples + k) = (short )newsamp;
#line 543
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 572
    *(pms->block + 0) = (unsigned char )bpred[0];
#line 573
    *(pms->block + 1) = (unsigned char )bpred[1];
#line 575
    *(pms->block + 2) = (unsigned char )(idelta[0] & 255);
#line 576
    *(pms->block + 3) = (unsigned char )(idelta[0] >> 8);
#line 577
    *(pms->block + 4) = (unsigned char )(idelta[1] & 255);
#line 578
    *(pms->block + 5) = (unsigned char )(idelta[1] >> 8);
#line 580
    *(pms->block + 6) = (unsigned char )((int )*(pms->samples + 2) & 255);
#line 581
    *(pms->block + 7) = (unsigned char )((int )*(pms->samples + 2) >> 8);
#line 582
    *(pms->block + 8) = (unsigned char )((int )*(pms->samples + 3) & 255);
#line 583
    *(pms->block + 9) = (unsigned char )((int )*(pms->samples + 3) >> 8);
#line 585
    *(pms->block + 10) = (unsigned char )((int )*(pms->samples + 0) & 255);
#line 586
    *(pms->block + 11) = (unsigned char )((int )*(pms->samples + 0) >> 8);
#line 587
    *(pms->block + 12) = (unsigned char )((int )*(pms->samples + 1) & 255);
#line 588
    *(pms->block + 13) = (unsigned char )((int )*(pms->samples + 1) >> 8);
#line 590
    blockindx = 14U;
#line 591
    byte = (unsigned char)0;
#line 592
    chan = 1;
#line 594
    k = 4;
    {
#line 594
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 594
      if (! (k < 2 * pms->samplesperblock)) {
#line 594
        goto while_break___0;
      }
#line 595
      chan = k & 1;
#line 597
      predict = ((int )*(pms->samples + (k - 2)) * AdaptCoeff1[bpred[chan]] + (int )*(pms->samples + (k - 4)) * AdaptCoeff2[bpred[chan]]) >> 8;
#line 598
      errordelta = ((int )*(pms->samples + k) - predict) / idelta[chan];
#line 601
      if (errordelta < -8) {
#line 602
        errordelta = -8;
      } else
#line 603
      if (errordelta > 7) {
#line 604
        errordelta = 7;
      }
#line 605
      newsamp = predict + idelta[chan] * errordelta;
#line 606
      if (newsamp > 32767) {
#line 607
        newsamp = 32767;
      } else
#line 608
      if (newsamp < -32768) {
#line 609
        newsamp = -32768;
      }
#line 610
      if (errordelta < 0) {
#line 611
        errordelta += 16;
      }
#line 613
      byte = (unsigned char )(((int )byte << 4) | (errordelta & 15));
#line 615
      if (chan) {
#line 616
        __cil_tmp14 = blockindx;
#line 616
        blockindx ++;
#line 616
        *(pms->block + __cil_tmp14) = byte;
#line 617
        byte = (unsigned char)0;
      }
#line 620
      idelta[chan] = idelta[chan] * AdaptationTable[errordelta] >> 8;
#line 621
      if (idelta[chan] < 16) {
#line 622
        idelta[chan] = 16;
      }
#line 623
      *(pms->samples + k) = (short )newsamp;
#line 594
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  {
#line 629
  __cil_tmp16 = psf_fwrite((void const   *)pms->block, (sf_count_t )1, (sf_count_t )pms->blocksize,
                           psf);
#line 629
  k = (int )__cil_tmp16;
  }
#line 629
  if (k != pms->blocksize) {
    {
#line 630
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, pms->blocksize);
    }
  }
  {
#line 632
  memset((void *)pms->samples, 0, (unsigned long )pms->samplesperblock * sizeof(short ));
#line 634
  (pms->blockcount) ++;
#line 635
  pms->samplecount = (sf_count_t )0;
  }
#line 637
  return (1);
}
}
#line 641 "/root/patchweave_new/23/src/ms_adpcm.c"
static sf_count_t msadpcm_write_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms , short const   *ptr ,
                                      int len ) 
{ 
  int count ;
  int total ;
  int indx ;

  {
#line 642
  total = 0;
#line 642
  indx = 0;
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;

#line 644
    if (! (indx < len)) {
#line 644
      goto while_break;
    }
#line 645
    count = (int )(((long )pms->samplesperblock - pms->samplecount) * (long )pms->channels);
#line 647
    if (count > len - indx) {
#line 648
      count = len - indx;
    }
    {
#line 650
    memcpy((void *)(pms->samples + pms->samplecount * (long )pms->channels), (void const   *)(ptr + total),
           (unsigned long )count * sizeof(short ));
#line 651
    indx += count;
#line 652
    pms->samplecount += (long )(count / pms->channels);
#line 653
    total = indx;
    }
#line 655
    if (pms->samplecount >= (long )pms->samplesperblock) {
      {
#line 656
      msadpcm_encode_block(psf, pms);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 659
  return ((sf_count_t )total);
}
}
#line 663 "/root/patchweave_new/23/src/ms_adpcm.c"
static sf_count_t msadpcm_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  int writecount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 666
  total = (sf_count_t )0;
#line 668
  if (! psf->codec_data) {
#line 669
    return ((sf_count_t )0);
  }
#line 670
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;

#line 672
    if (! (len > 0L)) {
#line 672
      goto while_break;
    }
#line 673
    if (len > 268435456L) {
#line 673
      tmp = 268435456;
    } else {
#line 673
      tmp = (int )len;
    }
    {
#line 673
    writecount = tmp;
#line 675
    __cil_tmp9 = msadpcm_write_block(psf, pms, ptr, writecount);
#line 675
    count = (int )__cil_tmp9;
#line 677
    total += (long )count;
#line 678
    len -= (long )count;
    }
#line 679
    if (count != writecount) {
#line 680
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 683
  return (total);
}
}
#line 687 "/root/patchweave_new/23/src/ms_adpcm.c"
static sf_count_t msadpcm_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  sf_count_t __cil_tmp14 ;

  {
#line 692
  total = (sf_count_t )0;
#line 694
  if (! psf->codec_data) {
#line 695
    return ((sf_count_t )0);
  }
#line 696
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 698
  sptr = ubuf.sbuf;
#line 699
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 700
  while (1) {
    while_continue: /* CIL Label */ ;

#line 700
    if (! (len > 0L)) {
#line 700
      goto while_break;
    }
#line 701
    if (len >= (long )bufferlen) {
#line 701
      tmp = (long )bufferlen;
    } else {
#line 701
      tmp = len;
    }
#line 701
    writecount = (int )tmp;
#line 702
    k = 0;
    {
#line 702
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 702
      if (! (k < writecount)) {
#line 702
        goto while_break___0;
      }
#line 703
      *(sptr + k) = (short )(*(ptr + (total + (long )k)) >> 16);
#line 702
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 704
    __cil_tmp14 = msadpcm_write_block(psf, pms, (short const   *)sptr, writecount);
#line 704
    count = (int )__cil_tmp14;
#line 705
    total += (long )count;
#line 706
    len -= (long )writecount;
    }
#line 707
    if (count != writecount) {
#line 708
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 710
  return (total);
}
}
#line 714 "/root/patchweave_new/23/src/ms_adpcm.c"
static sf_count_t msadpcm_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;
  sf_count_t __cil_tmp17 ;

  {
#line 719
  total = (sf_count_t )0;
#line 722
  if (! psf->codec_data) {
#line 723
    return ((sf_count_t )0);
  }
#line 724
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 726
  if (psf->norm_float == 1) {
#line 726
    tmp = 1. * (double )32767;
  } else {
#line 726
    tmp = 1.;
  }
#line 726
  normfact = (float )tmp;
#line 728
  sptr = ubuf.sbuf;
#line 729
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 730
  while (1) {
    while_continue: /* CIL Label */ ;

#line 730
    if (! (len > 0L)) {
#line 730
      goto while_break;
    }
#line 731
    if (len >= (long )bufferlen) {
#line 731
      tmp___0 = (long )bufferlen;
    } else {
#line 731
      tmp___0 = len;
    }
#line 731
    writecount = (int )tmp___0;
#line 732
    k = 0;
    {
#line 732
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 732
      if (! (k < writecount)) {
#line 732
        goto while_break___0;
      }
      {
#line 733
      __cil_tmp15 = lrintf(normfact * (float )*(ptr + (total + (long )k)));
#line 733
      *(sptr + k) = (short )__cil_tmp15;
#line 732
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 734
    __cil_tmp17 = msadpcm_write_block(psf, pms, (short const   *)sptr, writecount);
#line 734
    count = (int )__cil_tmp17;
#line 735
    total += (long )count;
#line 736
    len -= (long )writecount;
    }
#line 737
    if (count != writecount) {
#line 738
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 740
  return (total);
}
}
#line 744 "/root/patchweave_new/23/src/ms_adpcm.c"
static sf_count_t msadpcm_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;
  sf_count_t __cil_tmp17 ;

  {
#line 749
  total = (sf_count_t )0;
#line 752
  if (psf->norm_double == 1) {
#line 752
    tmp = 1. * (double )32767;
  } else {
#line 752
    tmp = 1.;
  }
#line 752
  normfact = tmp;
#line 754
  if (! psf->codec_data) {
#line 755
    return ((sf_count_t )0);
  }
#line 756
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 758
  sptr = ubuf.sbuf;
#line 759
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;

#line 760
    if (! (len > 0L)) {
#line 760
      goto while_break;
    }
#line 761
    if (len >= (long )bufferlen) {
#line 761
      tmp___0 = (long )bufferlen;
    } else {
#line 761
      tmp___0 = len;
    }
#line 761
    writecount = (int )tmp___0;
#line 762
    k = 0;
    {
#line 762
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 762
      if (! (k < writecount)) {
#line 762
        goto while_break___0;
      }
      {
#line 763
      __cil_tmp15 = lrint(normfact * (double )*(ptr + (total + (long )k)));
#line 763
      *(sptr + k) = (short )__cil_tmp15;
#line 762
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 764
    __cil_tmp17 = msadpcm_write_block(psf, pms, (short const   *)sptr, writecount);
#line 764
    count = (int )__cil_tmp17;
#line 765
    total += (long )count;
#line 766
    len -= (long )writecount;
    }
#line 767
    if (count != writecount) {
#line 768
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 770
  return (total);
}
}
#line 777 "/root/patchweave_new/23/src/ms_adpcm.c"
static int msadpcm_close(SF_PRIVATE *psf ) 
{ 
  MSADPCM_PRIVATE *pms ;

  {
#line 780
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 782
  if (psf->file.mode == 32) {
#line 787
    if (pms->samplecount) {
#line 787
      if (pms->samplecount < (long )pms->samplesperblock) {
        {
#line 788
        msadpcm_encode_block(psf, pms);
        }
      }
    }
  }
#line 791
  return (0);
}
}
#line 817 "/root/patchweave_new/23/src/ms_adpcm.c"
static void choose_predictor(unsigned int channels , short *data , int *block_pred ,
                             int *idelta ) 
{ 
  unsigned int chan ;
  unsigned int k ;
  unsigned int bpred ;
  unsigned int idelta_sum ;
  unsigned int best_bpred ;
  unsigned int best_idelta ;
  int __cil_tmp11 ;

  {
#line 820
  chan = 0U;
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;

#line 820
    if (! (chan < channels)) {
#line 820
      goto while_break;
    }
#line 821
    best_idelta = 0U;
#line 821
    best_bpred = best_idelta;
#line 823
    bpred = 0U;
    {
#line 823
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 823
      if (! (bpred < 7U)) {
#line 823
        goto while_break___0;
      }
#line 824
      idelta_sum = 0U;
#line 825
      k = 2U;
      {
#line 825
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 825
        if (! (k < 5U)) {
#line 825
          goto while_break___1;
        }
        {
#line 826
        __cil_tmp11 = abs((int )*(data + k * channels) - (((int )*(data + (k - 1U) * channels) * AdaptCoeff1[bpred] + (int )*(data + (k - 2U) * channels) * AdaptCoeff2[bpred]) >> 8));
#line 826
        idelta_sum += (unsigned int )__cil_tmp11;
#line 825
        k ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 827
      idelta_sum /= 12U;
#line 829
      if (bpred == 0U) {
#line 830
        best_bpred = bpred;
#line 831
        best_idelta = idelta_sum;
      } else
#line 829
      if (idelta_sum < best_idelta) {
#line 830
        best_bpred = bpred;
#line 831
        best_idelta = idelta_sum;
      }
#line 834
      if (! idelta_sum) {
#line 835
        best_bpred = bpred;
#line 836
        best_idelta = 16U;
#line 837
        goto while_break___0;
      }
#line 823
      bpred ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
#line 841
    if (best_idelta < 16U) {
#line 842
      best_idelta = 16U;
    }
#line 844
    *(block_pred + chan) = (int )best_bpred;
#line 845
    *(idelta + chan) = (int )best_idelta;
#line 820
    chan ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 848
  return;
}
}
#line 42 "/root/patchweave_new/23/src/interleave.c"
static sf_count_t interleave_read_short(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 43
static sf_count_t interleave_read_int(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 44
static sf_count_t interleave_read_float(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 45
static sf_count_t interleave_read_double(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 47
static sf_count_t interleave_seek(SF_PRIVATE *UNUSED_psf , int UNUSED_mode , sf_count_t samples_from_start ) ;
#line 53 "/root/patchweave_new/23/src/interleave.c"
int interleave_init(SF_PRIVATE *psf ) 
{ 
  INTERLEAVE_DATA *pdata ;
  void *tmp ;

  {
#line 56
  if (psf->file.mode != 16) {
#line 57
    return (37);
  }
#line 59
  if (psf->interleave) {
    {
#line 60
    psf_log_printf(psf, "*** Weird, already have interleave.\n");
    }
#line 61
    return (666);
  }
  {
#line 65
  tmp = malloc(sizeof(INTERLEAVE_DATA ));
#line 65
  pdata = (INTERLEAVE_DATA *)tmp;
  }
#line 65
  if (! pdata) {
#line 66
    return (17);
  }
  {
#line 68
  puts("interleave_init");
#line 70
  psf->interleave = (void *)pdata;
#line 73
  pdata->read_short = psf->read_short;
#line 74
  pdata->read_int = psf->read_int;
#line 75
  pdata->read_float = psf->read_float;
#line 76
  pdata->read_double = psf->read_double;
#line 78
  pdata->channel_len = psf->sf.frames * (long )psf->bytewidth;
#line 81
  psf->read_short = & interleave_read_short;
#line 82
  psf->read_int = & interleave_read_int;
#line 83
  psf->read_float = & interleave_read_float;
#line 84
  psf->read_double = & interleave_read_double;
#line 86
  psf->seek = & interleave_seek;
  }
#line 88
  return (0);
}
}
#line 95 "/root/patchweave_new/23/src/interleave.c"
static sf_count_t interleave_read_short(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  INTERLEAVE_DATA *pdata ;
  sf_count_t offset ;
  sf_count_t templen ;
  int chan ;
  int count ;
  int k ;
  short *inptr ;
  short *outptr ;
  sf_count_t __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;

  {
#line 101
  pdata = (INTERLEAVE_DATA *)psf->interleave;
#line 101
  if (! pdata) {
#line 102
    return ((sf_count_t )0);
  }
#line 104
  inptr = (short *)(pdata->buffer);
#line 106
  chan = 0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;

#line 106
    if (! (chan < psf->sf.channels)) {
#line 106
      goto while_break;
    }
    {
#line 107
    outptr = ptr + chan;
#line 109
    offset = psf->dataoffset + (long )(chan * psf->bytewidth) * psf->read_current;
#line 111
    __cil_tmp12 = psf_fseek(psf, offset, 0);
    }
#line 111
    if (__cil_tmp12 != offset) {
#line 112
      psf->error = 38;
#line 113
      return ((sf_count_t )0);
    }
#line 116
    templen = len / (long )psf->sf.channels;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 118
      if (! (templen > 0L)) {
#line 118
        goto while_break___0;
      }
#line 119
      if (templen > (long )((int )sizeof(pdata->buffer) / (int )sizeof(short ))) {
#line 120
        count = (int )sizeof(pdata->buffer) / (int )sizeof(short );
      } else {
#line 122
        count = (int )templen;
      }
      {
#line 124
      __cil_tmp13 = (*(pdata->read_short))(psf, inptr, (sf_count_t )count);
      }
#line 124
      if (__cil_tmp13 != (long )count) {
#line 125
        psf->error = 39;
#line 126
        return ((sf_count_t )0);
      }
#line 129
      k = 0;
      {
#line 129
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 129
        if (! (k < count)) {
#line 129
          goto while_break___1;
        }
#line 130
        *outptr = *(inptr + k);
#line 131
        outptr += psf->sf.channels;
#line 129
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 134
      templen -= (long )count;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 106
    chan ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 138
  return (len);
}
}
#line 142 "/root/patchweave_new/23/src/interleave.c"
static sf_count_t interleave_read_int(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  INTERLEAVE_DATA *pdata ;
  sf_count_t offset ;
  sf_count_t templen ;
  int chan ;
  int count ;
  int k ;
  int *inptr ;
  int *outptr ;
  sf_count_t __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;

  {
#line 148
  pdata = (INTERLEAVE_DATA *)psf->interleave;
#line 148
  if (! pdata) {
#line 149
    return ((sf_count_t )0);
  }
#line 151
  inptr = (int *)(pdata->buffer);
#line 153
  chan = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;

#line 153
    if (! (chan < psf->sf.channels)) {
#line 153
      goto while_break;
    }
    {
#line 154
    outptr = ptr + chan;
#line 156
    offset = psf->dataoffset + (long )(chan * psf->bytewidth) * psf->read_current;
#line 158
    __cil_tmp12 = psf_fseek(psf, offset, 0);
    }
#line 158
    if (__cil_tmp12 != offset) {
#line 159
      psf->error = 38;
#line 160
      return ((sf_count_t )0);
    }
#line 163
    templen = len / (long )psf->sf.channels;
    {
#line 165
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 165
      if (! (templen > 0L)) {
#line 165
        goto while_break___0;
      }
#line 166
      if (templen > (long )((int )sizeof(pdata->buffer) / (int )sizeof(int ))) {
#line 167
        count = (int )sizeof(pdata->buffer) / (int )sizeof(int );
      } else {
#line 169
        count = (int )templen;
      }
      {
#line 171
      __cil_tmp13 = (*(pdata->read_int))(psf, inptr, (sf_count_t )count);
      }
#line 171
      if (__cil_tmp13 != (long )count) {
#line 172
        psf->error = 39;
#line 173
        return ((sf_count_t )0);
      }
#line 176
      k = 0;
      {
#line 176
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 176
        if (! (k < count)) {
#line 176
          goto while_break___1;
        }
#line 177
        *outptr = *(inptr + k);
#line 178
        outptr += psf->sf.channels;
#line 176
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 181
      templen -= (long )count;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 153
    chan ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 185
  return (len);
}
}
#line 189 "/root/patchweave_new/23/src/interleave.c"
static sf_count_t interleave_read_float(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  INTERLEAVE_DATA *pdata ;
  sf_count_t offset ;
  sf_count_t templen ;
  int chan ;
  int count ;
  int k ;
  float *inptr ;
  float *outptr ;
  sf_count_t __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;

  {
#line 195
  pdata = (INTERLEAVE_DATA *)psf->interleave;
#line 195
  if (! pdata) {
#line 196
    return ((sf_count_t )0);
  }
#line 198
  inptr = (float *)(pdata->buffer);
#line 200
  chan = 0;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;

#line 200
    if (! (chan < psf->sf.channels)) {
#line 200
      goto while_break;
    }
    {
#line 201
    outptr = ptr + chan;
#line 203
    offset = (psf->dataoffset + pdata->channel_len * (long )chan) + psf->read_current * (long )psf->bytewidth;
#line 207
    __cil_tmp12 = psf_fseek(psf, offset, 0);
    }
#line 207
    if (__cil_tmp12 != offset) {
#line 208
      psf->error = 38;
#line 210
      return ((sf_count_t )0);
    }
#line 213
    templen = len / (long )psf->sf.channels;
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 215
      if (! (templen > 0L)) {
#line 215
        goto while_break___0;
      }
#line 216
      if (templen > (long )((int )sizeof(pdata->buffer) / (int )sizeof(float ))) {
#line 217
        count = (int )sizeof(pdata->buffer) / (int )sizeof(float );
      } else {
#line 219
        count = (int )templen;
      }
      {
#line 221
      __cil_tmp13 = (*(pdata->read_float))(psf, inptr, (sf_count_t )count);
      }
#line 221
      if (__cil_tmp13 != (long )count) {
#line 222
        psf->error = 39;
#line 224
        return ((sf_count_t )0);
      }
#line 227
      k = 0;
      {
#line 227
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 227
        if (! (k < count)) {
#line 227
          goto while_break___1;
        }
#line 228
        *outptr = *(inptr + k);
#line 229
        outptr += psf->sf.channels;
#line 227
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 232
      templen -= (long )count;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 200
    chan ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 236
  return (len);
}
}
#line 240 "/root/patchweave_new/23/src/interleave.c"
static sf_count_t interleave_read_double(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  INTERLEAVE_DATA *pdata ;
  sf_count_t offset ;
  sf_count_t templen ;
  int chan ;
  int count ;
  int k ;
  double *inptr ;
  double *outptr ;
  sf_count_t __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;

  {
#line 246
  pdata = (INTERLEAVE_DATA *)psf->interleave;
#line 246
  if (! pdata) {
#line 247
    return ((sf_count_t )0);
  }
#line 249
  inptr = pdata->buffer;
#line 251
  chan = 0;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;

#line 251
    if (! (chan < psf->sf.channels)) {
#line 251
      goto while_break;
    }
    {
#line 252
    outptr = ptr + chan;
#line 254
    offset = psf->dataoffset + (long )(chan * psf->bytewidth) * psf->read_current;
#line 256
    __cil_tmp12 = psf_fseek(psf, offset, 0);
    }
#line 256
    if (__cil_tmp12 != offset) {
#line 257
      psf->error = 38;
#line 258
      return ((sf_count_t )0);
    }
#line 261
    templen = len / (long )psf->sf.channels;
    {
#line 263
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 263
      if (! (templen > 0L)) {
#line 263
        goto while_break___0;
      }
#line 264
      if (templen > (long )((int )sizeof(pdata->buffer) / (int )sizeof(double ))) {
#line 265
        count = (int )sizeof(pdata->buffer) / (int )sizeof(double );
      } else {
#line 267
        count = (int )templen;
      }
      {
#line 269
      __cil_tmp13 = (*(pdata->read_double))(psf, inptr, (sf_count_t )count);
      }
#line 269
      if (__cil_tmp13 != (long )count) {
#line 270
        psf->error = 39;
#line 271
        return ((sf_count_t )0);
      }
#line 274
      k = 0;
      {
#line 274
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 274
        if (! (k < count)) {
#line 274
          goto while_break___1;
        }
#line 275
        *outptr = *(inptr + k);
#line 276
        outptr += psf->sf.channels;
#line 274
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 279
      templen -= (long )count;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 251
    chan ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 283
  return (len);
}
}
#line 290 "/root/patchweave_new/23/src/interleave.c"
static sf_count_t interleave_seek(SF_PRIVATE *UNUSED_psf , int UNUSED_mode , sf_count_t samples_from_start ) 
{ 


  {
#line 297
  return (samples_from_start);
}
}
#line 34 "/root/patchweave_new/23/src/ima_oki_adpcm.c"
static int const   ima_steps[89]  = 
#line 34 "/root/patchweave_new/23/src/ima_oki_adpcm.c"
  {      (int const   )7,      (int const   )8,      (int const   )9,      (int const   )10, 
        (int const   )11,      (int const   )12,      (int const   )13,      (int const   )14, 
        (int const   )16,      (int const   )17,      (int const   )19,      (int const   )21, 
        (int const   )23,      (int const   )25,      (int const   )28,      (int const   )31, 
        (int const   )34,      (int const   )37,      (int const   )41,      (int const   )45, 
        (int const   )50,      (int const   )55,      (int const   )60,      (int const   )66, 
        (int const   )73,      (int const   )80,      (int const   )88,      (int const   )97, 
        (int const   )107,      (int const   )118,      (int const   )130,      (int const   )143, 
        (int const   )157,      (int const   )173,      (int const   )190,      (int const   )209, 
        (int const   )230,      (int const   )253,      (int const   )279,      (int const   )307, 
        (int const   )337,      (int const   )371,      (int const   )408,      (int const   )449, 
        (int const   )494,      (int const   )544,      (int const   )598,      (int const   )658, 
        (int const   )724,      (int const   )796,      (int const   )876,      (int const   )963, 
        (int const   )1060,      (int const   )1166,      (int const   )1282,      (int const   )1411, 
        (int const   )1552,      (int const   )1707,      (int const   )1878,      (int const   )2066, 
        (int const   )2272,      (int const   )2499,      (int const   )2749,      (int const   )3024, 
        (int const   )3327,      (int const   )3660,      (int const   )4026,      (int const   )4428, 
        (int const   )4871,      (int const   )5358,      (int const   )5894,      (int const   )6484, 
        (int const   )7132,      (int const   )7845,      (int const   )8630,      (int const   )9493, 
        (int const   )10442,      (int const   )11487,      (int const   )12635,      (int const   )13899, 
        (int const   )15289,      (int const   )16818,      (int const   )18500,      (int const   )20350, 
        (int const   )22385,      (int const   )24623,      (int const   )27086,      (int const   )29794, 
        (int const   )32767};
#line 44 "/root/patchweave_new/23/src/ima_oki_adpcm.c"
static int const   oki_steps[49]  = 
#line 44
  {      (int const   )256,      (int const   )272,      (int const   )304,      (int const   )336, 
        (int const   )368,      (int const   )400,      (int const   )448,      (int const   )496, 
        (int const   )544,      (int const   )592,      (int const   )656,      (int const   )720, 
        (int const   )800,      (int const   )880,      (int const   )960,      (int const   )1056, 
        (int const   )1168,      (int const   )1280,      (int const   )1408,      (int const   )1552, 
        (int const   )1712,      (int const   )1888,      (int const   )2080,      (int const   )2288, 
        (int const   )2512,      (int const   )2768,      (int const   )3040,      (int const   )3344, 
        (int const   )3680,      (int const   )4048,      (int const   )4464,      (int const   )4912, 
        (int const   )5392,      (int const   )5936,      (int const   )6528,      (int const   )7184, 
        (int const   )7904,      (int const   )8704,      (int const   )9568,      (int const   )10528, 
        (int const   )11584,      (int const   )12736,      (int const   )14016,      (int const   )15408, 
        (int const   )16960,      (int const   )18656,      (int const   )20512,      (int const   )22576, 
        (int const   )24832};
#line 51 "/root/patchweave_new/23/src/ima_oki_adpcm.c"
static int const   step_changes[8]  = 
#line 51
  {      (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )2,      (int const   )4,      (int const   )6,      (int const   )8};
#line 54 "/root/patchweave_new/23/src/ima_oki_adpcm.c"
void ima_oki_adpcm_init(IMA_OKI_ADPCM *state , IMA_OKI_ADPCM_TYPE type ) 
{ 


  {
  {
#line 56
  memset((void *)state, 0, sizeof(*state));
  }
#line 58
  if ((unsigned int )type == 0U) {
#line 59
    state->max_step_index = (int )(sizeof(ima_steps) / sizeof(ima_steps[0])) - 1;
#line 60
    state->steps = ima_steps;
#line 61
    state->mask = ~ 0;
  } else {
    {
#line 64
    state->max_step_index = (int )(sizeof(oki_steps) / sizeof(oki_steps[0])) - 1;
#line 65
    state->steps = oki_steps;
#line 66
    state->mask = arith_shift_left(~ 0, 4);
    }
  }
#line 70
  return;
}
}
#line 73 "/root/patchweave_new/23/src/ima_oki_adpcm.c"
int adpcm_decode(IMA_OKI_ADPCM *state , int code ) 
{ 
  int s ;
  int grace ;
  int tmp ;

  {
#line 76
  s = ((code & 7) << 1) | 1;
#line 77
  s = (int )((*(state->steps + state->step_index) * (int const   )s >> 3) & (int const   )state->mask);
#line 79
  if (code & 8) {
#line 80
    s = - s;
  }
#line 81
  s += state->last_output;
#line 83
  if (s < -32768) {
    _L: 
#line 86
    grace = (int )((*(state->steps + state->step_index) >> 3) & (int const   )state->mask);
#line 88
    if (s < -32768 - grace) {
#line 89
      (state->errors) ++;
    } else
#line 88
    if (s > 32767 + grace) {
#line 89
      (state->errors) ++;
    }
#line 91
    if (s < -32768) {
#line 91
      tmp = -32768;
    } else {
#line 91
      tmp = 32767;
    }
#line 91
    s = tmp;
  } else
#line 83
  if (s > 32767) {
#line 83
    goto _L;
  }
#line 94
  state->step_index += (int )step_changes[code & 7];
#line 95
  state->step_index = 0;
#line 96
  state->last_output = s;
#line 98
  return (s);
}
}
#line 102 "/root/patchweave_new/23/src/ima_oki_adpcm.c"
int adpcm_encode(IMA_OKI_ADPCM *state , int sample ) 
{ 
  int delta ;
  int sign ;
  int code ;

  {
#line 103
  sign = 0;
#line 105
  delta = sample - state->last_output;
#line 107
  if (delta < 0) {
#line 108
    sign = 8;
#line 109
    delta = - delta;
  }
  {
#line 112
  code = (4 * delta) / (int )*(state->steps + state->step_index);
#line 113
  code = sign;
#line 114
  adpcm_decode(state, code);
  }
#line 116
  return (code);
}
}
#line 121 "/root/patchweave_new/23/src/ima_oki_adpcm.c"
void ima_oki_adpcm_decode_block(IMA_OKI_ADPCM *state ) 
{ 
  unsigned char code ;
  int k ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 125
  k = 0;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;

#line 125
    if (! (k < state->code_count)) {
#line 125
      goto while_break;
    }
    {
#line 126
    code = state->codes[k];
#line 127
    __cil_tmp4 = adpcm_decode(state, (int )code >> 4);
#line 127
    state->pcm[2 * k] = (short )__cil_tmp4;
#line 128
    __cil_tmp5 = adpcm_decode(state, (int )code);
#line 128
    state->pcm[2 * k + 1] = (short )__cil_tmp5;
#line 125
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 131
  state->pcm_count = 2 * k;
#line 132
  return;
}
}
#line 136 "/root/patchweave_new/23/src/ima_oki_adpcm.c"
void ima_oki_adpcm_encode_block(IMA_OKI_ADPCM *state ) 
{ 
  unsigned char code ;
  int k ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 146
  if (state->pcm_count % 2 == 1) {
#line 147
    __cil_tmp4 = state->pcm_count;
#line 147
    (state->pcm_count) ++;
#line 147
    state->pcm[__cil_tmp4] = (short)0;
  }
#line 149
  k = 0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;

#line 149
    if (! (k < state->pcm_count / 2)) {
#line 149
      goto while_break;
    }
    {
#line 150
    __cil_tmp5 = adpcm_encode(state, (int )state->pcm[2 * k]);
#line 150
    code = (unsigned char )(__cil_tmp5 << 4);
#line 151
    __cil_tmp6 = adpcm_encode(state, (int )state->pcm[2 * k + 1]);
#line 151
    code = (unsigned char )((int )code | __cil_tmp6);
#line 152
    state->codes[k] = code;
#line 149
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 155
  state->code_count = k;
#line 156
  return;
}
}
#line 47 "/root/patchweave_new/23/src/ima_adpcm.c"
static int ima_indx_adjust[16]  = 
#line 47 "/root/patchweave_new/23/src/ima_adpcm.c"
  {      -1,      -1,      -1,      -1, 
        2,      4,      6,      8, 
        -1,      -1,      -1,      -1, 
        2,      4,      6,      8};
#line 54 "/root/patchweave_new/23/src/ima_adpcm.c"
static int ima_step_size[89]  = 
#line 54
  {      7,      8,      9,      10, 
        11,      12,      13,      14, 
        16,      17,      19,      21, 
        23,      25,      28,      31, 
        34,      37,      41,      45, 
        50,      55,      60,      66, 
        73,      80,      88,      97, 
        107,      118,      130,      143, 
        157,      173,      190,      209, 
        230,      253,      279,      307, 
        337,      371,      408,      449, 
        494,      544,      598,      658, 
        724,      796,      876,      963, 
        1060,      1166,      1282,      1411, 
        1552,      1707,      1878,      2066, 
        2272,      2499,      2749,      3024, 
        3327,      3660,      4026,      4428, 
        4871,      5358,      5894,      6484, 
        7132,      7845,      8630,      9493, 
        10442,      11487,      12635,      13899, 
        15289,      16818,      18500,      20350, 
        22385,      24623,      27086,      29794, 
        32767};
#line 64
static int ima_reader_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) ;
#line 65
static int ima_writer_init(SF_PRIVATE *psf , int blockalign ) ;
#line 67
static int ima_read_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima , short *ptr ,
                          int len ) ;
#line 68
static int ima_write_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima , short const   *ptr ,
                           int len ) ;
#line 70
static sf_count_t ima_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 71
static sf_count_t ima_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 72
static sf_count_t ima_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 73
static sf_count_t ima_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 75
static sf_count_t ima_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 76
static sf_count_t ima_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 77
static sf_count_t ima_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 78
static sf_count_t ima_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 80
static sf_count_t aiff_ima_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 81
static sf_count_t wavlike_ima_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 83
static int ima_close(SF_PRIVATE *psf ) ;
#line 85
static int wavlike_ima_decode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) ;
#line 86
static int wavlike_ima_encode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) ;
#line 89
static int aiff_ima_decode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) ;
#line 90
static int aiff_ima_encode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) ;
#line 94 "/root/patchweave_new/23/src/ima_adpcm.c"
__inline static int clamp_ima_step_index(int indx ) 
{ 


  {
#line 95
  if (indx < 0) {
#line 96
    return (0);
  }
#line 97
  if (indx >= (int )(sizeof(ima_step_size) / sizeof(ima_step_size[0]))) {
#line 98
    return ((int )(sizeof(ima_step_size) / sizeof(ima_step_size[0])) - 1);
  }
#line 100
  return (indx);
}
}
#line 108 "/root/patchweave_new/23/src/ima_adpcm.c"
int wavlike_ima_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) 
{ 
  int error ;

  {
#line 111
  if ((unsigned long )psf->codec_data != (unsigned long )((void *)0)) {
    {
#line 112
    psf_log_printf(psf, "*** psf->codec_data is not NULL.\n\243\365?\270U");
    }
#line 113
    return (30);
  }
#line 116
  if (psf->file.mode == 48) {
#line 117
    return (24);
  }
#line 119
  if (psf->file.mode == 16) {
    {
#line 120
    error = ima_reader_init(psf, blockalign, samplesperblock);
    }
#line 120
    if (error) {
#line 121
      return (error);
    }
  }
#line 123
  if (psf->file.mode == 32) {
    {
#line 124
    error = ima_writer_init(psf, blockalign);
    }
#line 124
    if (error) {
#line 125
      return (error);
    }
  }
#line 127
  psf->codec_close = & ima_close;
#line 128
  psf->seek = & wavlike_ima_seek;
#line 130
  return (0);
}
}
#line 134 "/root/patchweave_new/23/src/ima_adpcm.c"
int aiff_ima_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) 
{ 
  int error ;

  {
#line 137
  if (psf->file.mode == 48) {
#line 138
    return (24);
  }
#line 140
  if (psf->file.mode == 16) {
    {
#line 141
    error = ima_reader_init(psf, blockalign, samplesperblock);
    }
#line 141
    if (error) {
#line 142
      return (error);
    }
  }
#line 144
  if (psf->file.mode == 32) {
    {
#line 145
    error = ima_writer_init(psf, blockalign);
    }
#line 145
    if (error) {
#line 146
      return (error);
    }
  }
#line 148
  psf->codec_close = & ima_close;
#line 149
  psf->seek = & aiff_ima_seek;
#line 151
  return (0);
}
}
#line 155 "/root/patchweave_new/23/src/ima_adpcm.c"
static int ima_close(SF_PRIVATE *psf ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;

  {
#line 158
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 160
  if (psf->file.mode == 32) {
#line 164
    if (pima->samplecount) {
#line 164
      if (pima->samplecount < pima->samplesperblock) {
        {
#line 165
        (*(pima->encode_block))(psf, pima);
        }
      }
    }
#line 167
    psf->sf.frames = (sf_count_t )((pima->samplesperblock * pima->blockcount) / psf->sf.channels);
  }
#line 170
  return (0);
}
}
#line 178 "/root/patchweave_new/23/src/ima_adpcm.c"
static int ima_reader_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int pimasize ;
  int count ;
  sf_count_t tmp ;
  void *tmp___0 ;

  {
#line 182
  if (psf->file.mode != 16) {
#line 183
    return (24);
  }
  {
#line 185
  pimasize = (int )((sizeof(IMA_ADPCM_PRIVATE ) + (unsigned long )(blockalign * psf->sf.channels)) + (unsigned long )((3 * psf->sf.channels) * samplesperblock));
#line 187
  tmp___0 = calloc(1UL, (unsigned long )pimasize);
#line 187
  pima = (IMA_ADPCM_PRIVATE *)tmp___0;
  }
#line 187
  if (! pima) {
#line 188
    return (17);
  }
  {
#line 190
  psf->codec_data = (void *)pima;
#line 192
  pima->samples = pima->data;
#line 193
  pima->block = (unsigned char *)(pima->data + samplesperblock * psf->sf.channels);
#line 195
  pima->channels = psf->sf.channels;
#line 196
  pima->blocksize = blockalign;
#line 197
  pima->samplesperblock = samplesperblock;
#line 199
  psf->filelength = psf_get_filelen(psf);
  }
#line 200
  if (psf->dataend) {
#line 200
    tmp = psf->dataend - psf->dataoffset;
  } else {
#line 200
    tmp = psf->filelength - psf->dataoffset;
  }
#line 200
  psf->datalength = tmp;
#line 203
  if (pima->blocksize <= 0) {
    {
#line 204
    psf_log_printf(psf, "*** Error : pima->blocksize should be > 0.\n@\270U");
    }
#line 205
    return (30);
  }
#line 208
  if (pima->samplesperblock <= 0) {
    {
#line 209
    psf_log_printf(psf, "*** Error : pima->samplesperblock should be > 0.\n\322\031@\270U");
    }
#line 210
    return (30);
  }
#line 213
  if (psf->datalength % (long )pima->blocksize) {
#line 214
    pima->blocks = (int )(psf->datalength / (long )pima->blocksize + 1L);
  } else {
#line 216
    pima->blocks = (int )(psf->datalength / (long )pima->blocksize);
  }
#line 220
  if ((psf->sf.format & 268369920) == 720896) {
#line 220
    goto case_720896;
  }
#line 220
  if ((psf->sf.format & 268369920) == 65536) {
#line 220
    goto case_720896;
  }
#line 233
  if ((psf->sf.format & 268369920) == 131072) {
#line 233
    goto case_131072;
  }
#line 239
  goto switch_default;
  case_720896: 
#line 221
  count = (2 * (pima->blocksize - 4 * pima->channels)) / pima->channels + 1;
#line 223
  if (pima->samplesperblock != count) {
    {
#line 224
    psf_log_printf(psf, "*** Error : samplesperblock should be %d.\n", count);
    }
#line 225
    return (30);
  }
#line 228
  pima->decode_block = & wavlike_ima_decode_block;
#line 230
  psf->sf.frames = (sf_count_t )(pima->samplesperblock * pima->blocks);
#line 231
  goto switch_break;
  case_131072: 
  {
#line 234
  psf_log_printf(psf, "still need to check block count\n\220");
#line 235
  pima->decode_block = & aiff_ima_decode_block;
#line 236
  psf->sf.frames = (sf_count_t )((pima->samplesperblock * pima->blocks) / pima->channels);
  }
#line 237
  goto switch_break;
  switch_default: 
  {
#line 240
  psf_log_printf(psf, "ima_reader_init: bad psf->sf.format\n");
  }
#line 241
  return (30);
  switch_break: 
  {
#line 244
  (*(pima->decode_block))(psf, pima);
#line 246
  psf->read_short = & ima_read_s;
#line 247
  psf->read_int = & ima_read_i;
#line 248
  psf->read_float = & ima_read_f;
#line 249
  psf->read_double = & ima_read_d;
  }
#line 251
  return (0);
}
}
#line 266 "/root/patchweave_new/23/src/ima_adpcm.c"
static int count  ;
#line 255 "/root/patchweave_new/23/src/ima_adpcm.c"
static int aiff_ima_decode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) 
{ 
  unsigned char *blockdata ;
  int chan ;
  int k ;
  int diff ;
  int bytecode ;
  int predictor ;
  short step ;
  short stepindx ;
  short *sampledata ;
  sf_count_t __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp17 ;

  {
#line 260
  count = 0;
#line 261
  count ++;
#line 263
  pima->blockcount += pima->channels;
#line 264
  pima->samplecount = 0;
#line 266
  if (pima->blockcount > pima->blocks) {
    {
#line 267
    memset((void *)pima->samples, 0, (unsigned long )(pima->samplesperblock * pima->channels) * sizeof(short ));
    }
#line 268
    return (1);
  }
  {
#line 271
  __cil_tmp14 = psf_fread((void *)pima->block, (sf_count_t )1, (sf_count_t )(pima->blocksize * pima->channels),
                          psf);
#line 271
  k = (int )__cil_tmp14;
  }
#line 271
  if (k != pima->blocksize * pima->channels) {
    {
#line 272
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, pima->blocksize);
    }
  }
#line 275
  chan = 0;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;

#line 275
    if (! (chan < pima->channels)) {
#line 275
      goto while_break;
    }
    {
#line 276
    blockdata = pima->block + chan * 34;
#line 277
    sampledata = pima->samples + chan;
#line 280
    predictor = (int )((short )(((int )*(blockdata + 0) << 8) | ((int )*(blockdata + 1) & 128)));
#line 282
    stepindx = (short )((int )*(blockdata + 1) & 127);
#line 283
    __cil_tmp15 = clamp_ima_step_index((int )stepindx);
#line 283
    stepindx = (short )__cil_tmp15;
#line 289
    k = 0;
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 289
      if (! (k < pima->blocksize - 2)) {
#line 289
        goto while_break___0;
      }
#line 290
      bytecode = (int )*(blockdata + (k + 2));
#line 291
      *(sampledata + pima->channels * (2 * k)) = (short )(bytecode & 15);
#line 292
      *(sampledata + pima->channels * (2 * k + 1)) = (short )((bytecode >> 4) & 15);
#line 289
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 296
    k = 0;
    {
#line 296
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 296
      if (! (k < pima->samplesperblock)) {
#line 296
        goto while_break___1;
      }
      {
#line 297
      step = (short )ima_step_size[stepindx];
#line 299
      bytecode = (int )*(pima->samples + (pima->channels * k + chan));
#line 301
      stepindx = (short )((int )stepindx + ima_indx_adjust[bytecode]);
#line 302
      __cil_tmp17 = clamp_ima_step_index((int )stepindx);
#line 302
      stepindx = (short )__cil_tmp17;
#line 304
      diff = (int )step >> 3;
      }
#line 305
      if (bytecode & 1) {
#line 305
        diff += (int )step >> 2;
      }
#line 306
      if (bytecode & 2) {
#line 306
        diff += (int )step >> 1;
      }
#line 307
      if (bytecode & 4) {
#line 307
        diff += (int )step;
      }
#line 308
      if (bytecode & 8) {
#line 308
        diff = - diff;
      }
#line 310
      predictor += diff;
#line 311
      if (predictor < -32768) {
#line 312
        predictor = -32768;
      } else
#line 313
      if (predictor > 32767) {
#line 314
        predictor = 32767;
      }
#line 316
      *(pima->samples + (pima->channels * k + chan)) = (short )predictor;
#line 296
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 275
    chan ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 320
  return (1);
}
}
#line 324 "/root/patchweave_new/23/src/ima_adpcm.c"
static int aiff_ima_encode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) 
{ 
  int chan ;
  int k ;
  int step ;
  int diff ;
  int vpdiff ;
  int blockindx ;
  int indx ;
  short bytecode ;
  short mask ;
  int tmp ;
  sf_count_t __cil_tmp17 ;

  {
#line 329
  chan = 0;
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;

#line 329
    if (! (chan < pima->channels)) {
#line 329
      goto while_break;
    }
#line 330
    blockindx = chan * pima->blocksize;
#line 332
    *(pima->block + blockindx) = (unsigned char )(((int )*(pima->samples + chan) >> 8) & 255);
#line 333
    *(pima->block + (blockindx + 1)) = (unsigned char )(((int )*(pima->samples + chan) & 128) + (pima->stepindx[chan] & 127));
#line 335
    pima->previous[chan] = (int )*(pima->samples + chan);
#line 329
    chan ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 339
  k = pima->channels;
  {
#line 339
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 339
    if (! (k < pima->samplesperblock * pima->channels)) {
#line 339
      goto while_break___0;
    }
#line 340
    if (pima->channels > 1) {
#line 340
      tmp = k % 2;
    } else {
#line 340
      tmp = 0;
    }
#line 340
    chan = tmp;
#line 342
    diff = (int )*(pima->samples + k) - pima->previous[chan];
#line 344
    bytecode = (short)0;
#line 345
    step = ima_step_size[pima->stepindx[chan]];
#line 346
    vpdiff = step >> 3;
#line 347
    if (diff < 0) {
#line 348
      bytecode = (short)8;
#line 349
      diff = - diff;
    }
#line 351
    mask = (short)4;
    {
#line 352
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 352
      if (! mask) {
#line 352
        goto while_break___1;
      }
#line 353
      if (diff >= step) {
#line 354
        bytecode = (short )((int )bytecode | (int )mask);
#line 355
        diff -= step;
#line 356
        vpdiff += step;
      }
#line 358
      step >>= 1;
#line 359
      mask = (short )((int )mask >> 1);
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: ;
#line 362
    if ((int )bytecode & 8) {
#line 363
      pima->previous[chan] -= vpdiff;
    } else {
#line 365
      pima->previous[chan] += vpdiff;
    }
#line 367
    if (pima->previous[chan] > 32767) {
#line 368
      pima->previous[chan] = 32767;
    } else
#line 369
    if (pima->previous[chan] < -32768) {
#line 370
      pima->previous[chan] = -32768;
    }
    {
#line 372
    pima->stepindx[chan] += ima_indx_adjust[bytecode];
#line 374
    pima->stepindx[chan] = clamp_ima_step_index(pima->stepindx[chan]);
#line 375
    *(pima->samples + k) = bytecode;
#line 339
    k ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
#line 380
  chan = 0;
  {
#line 380
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 380
    if (! (chan < pima->channels)) {
#line 380
      goto while_break___2;
    }
#line 381
    indx = pima->channels;
    {
#line 381
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 381
      if (! (indx < pima->channels * pima->samplesperblock)) {
#line 381
        goto while_break___3;
      }
#line 382
      blockindx = (chan * pima->blocksize + 2) + indx / 2;
#line 384
      *(pima->block + blockindx) = (unsigned char )((int )*(pima->samples + indx) & 15);
#line 385
      *(pima->block + blockindx) = (unsigned char )((int )*(pima->block + blockindx) | (((int )*(pima->samples + (indx + chan)) << 4) & 240));
#line 381
      indx += 2 * pima->channels;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: 
#line 380
    chan ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 391
  __cil_tmp17 = psf_fwrite((void const   *)pima->block, (sf_count_t )1, (sf_count_t )(pima->channels * pima->blocksize),
                           psf);
#line 391
  k = (int )__cil_tmp17;
  }
#line 391
  if (k != pima->channels * pima->blocksize) {
    {
#line 392
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, pima->channels * pima->blocksize);
    }
  }
  {
#line 394
  memset((void *)pima->samples, 0, (unsigned long )(pima->channels * pima->samplesperblock) * sizeof(short ));
#line 395
  pima->samplecount = 0;
#line 396
  (pima->blockcount) ++;
  }
#line 398
  return (1);
}
}
#line 402 "/root/patchweave_new/23/src/ima_adpcm.c"
static int wavlike_ima_decode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) 
{ 
  int chan ;
  int k ;
  int predictor ;
  int blockindx ;
  int indx ;
  int indxstart ;
  int diff ;
  short step ;
  short bytecode ;
  short stepindx[2] ;
  sf_count_t __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp17 ;
  int tmp ;
  int __cil_tmp21 ;

  {
#line 406
  (pima->blockcount) ++;
#line 407
  pima->samplecount = 0;
#line 409
  if (pima->blockcount > pima->blocks) {
    {
#line 410
    memset((void *)pima->samples, 0, (unsigned long )(pima->samplesperblock * pima->channels) * sizeof(short ));
    }
#line 411
    return (1);
  }
  {
#line 414
  __cil_tmp14 = psf_fread((void *)pima->block, (sf_count_t )1, (sf_count_t )pima->blocksize,
                          psf);
#line 414
  k = (int )__cil_tmp14;
  }
#line 414
  if (k != pima->blocksize) {
    {
#line 415
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, pima->blocksize);
    }
  }
#line 419
  chan = 0;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;

#line 419
    if (! (chan < pima->channels)) {
#line 419
      goto while_break;
    }
#line 420
    predictor = (int )*(pima->block + chan * 4) | ((int )*(pima->block + (chan * 4 + 1)) << 8);
#line 421
    if (predictor & 32768) {
#line 422
      predictor -= 65536;
    }
    {
#line 424
    stepindx[chan] = (short )*(pima->block + (chan * 4 + 2));
#line 425
    __cil_tmp15 = clamp_ima_step_index((int )stepindx[chan]);
#line 425
    stepindx[chan] = (short )__cil_tmp15;
    }
#line 428
    if ((int )*(pima->block + (chan * 4 + 3)) != 0) {
      {
#line 429
      psf_log_printf(psf, "IMA ADPCM synchronisation error.\n\266\032@\270U");
      }
    }
#line 431
    *(pima->samples + chan) = (short )predictor;
#line 419
    chan ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 439
  blockindx = 4 * pima->channels;
#line 441
  indxstart = pima->channels;
  {
#line 442
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 442
    if (! (blockindx < pima->blocksize)) {
#line 442
      goto while_break___0;
    }
#line 443
    chan = 0;
    {
#line 443
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 443
      if (! (chan < pima->channels)) {
#line 443
        goto while_break___1;
      }
#line 444
      indx = indxstart + chan;
#line 445
      k = 0;
      {
#line 445
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 445
        if (! (k < 4)) {
#line 445
          goto while_break___2;
        }
#line 446
        __cil_tmp17 = blockindx;
#line 446
        blockindx ++;
#line 446
        bytecode = (short )*(pima->block + __cil_tmp17);
#line 447
        *(pima->samples + indx) = (short )((int )bytecode & 15);
#line 448
        indx += pima->channels;
#line 449
        *(pima->samples + indx) = (short )(((int )bytecode >> 4) & 15);
#line 450
        indx += pima->channels;
#line 445
        k ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: 
#line 443
      chan ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: 
#line 453
    indxstart += 8 * pima->channels;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
#line 458
  k = pima->channels;
  {
#line 458
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 458
    if (! (k < pima->samplesperblock * pima->channels)) {
#line 458
      goto while_break___3;
    }
#line 459
    if (pima->channels > 1) {
#line 459
      tmp = k % 2;
    } else {
#line 459
      tmp = 0;
    }
#line 459
    chan = tmp;
#line 461
    bytecode = (short )((int )*(pima->samples + k) & 15);
#line 463
    step = (short )ima_step_size[stepindx[chan]];
#line 464
    predictor = (int )*(pima->samples + (k - pima->channels));
#line 466
    diff = (int )step >> 3;
#line 467
    if ((int )bytecode & 1) {
#line 468
      diff += (int )step >> 2;
    }
#line 469
    if ((int )bytecode & 2) {
#line 470
      diff += (int )step >> 1;
    }
#line 471
    if ((int )bytecode & 4) {
#line 472
      diff += (int )step;
    }
#line 473
    if ((int )bytecode & 8) {
#line 474
      diff = - diff;
    }
#line 476
    predictor += diff;
#line 478
    if (predictor > 32767) {
#line 479
      predictor = 32767;
    } else
#line 480
    if (predictor < -32768) {
#line 481
      predictor = -32768;
    }
    {
#line 483
    stepindx[chan] = (short )((int )stepindx[chan] + ima_indx_adjust[bytecode]);
#line 484
    __cil_tmp21 = clamp_ima_step_index((int )stepindx[chan]);
#line 484
    stepindx[chan] = (short )__cil_tmp21;
#line 486
    *(pima->samples + k) = (short )predictor;
#line 458
    k ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: ;
#line 489
  return (1);
}
}
#line 493 "/root/patchweave_new/23/src/ima_adpcm.c"
static int wavlike_ima_encode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) 
{ 
  int chan ;
  int k ;
  int step ;
  int diff ;
  int vpdiff ;
  int blockindx ;
  int indx ;
  int indxstart ;
  short bytecode ;
  short mask ;
  int tmp ;
  sf_count_t __cil_tmp20 ;

  {
#line 498
  chan = 0;
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;

#line 498
    if (! (chan < pima->channels)) {
#line 498
      goto while_break;
    }
#line 499
    *(pima->block + chan * 4) = (unsigned char )((int )*(pima->samples + chan) & 255);
#line 500
    *(pima->block + (chan * 4 + 1)) = (unsigned char )(((int )*(pima->samples + chan) >> 8) & 255);
#line 502
    *(pima->block + (chan * 4 + 2)) = (unsigned char )pima->stepindx[chan];
#line 503
    *(pima->block + (chan * 4 + 3)) = (unsigned char)0;
#line 505
    pima->previous[chan] = (int )*(pima->samples + chan);
#line 498
    chan ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
#line 510
  k = pima->channels;
  {
#line 510
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 510
    if (! (k < pima->samplesperblock * pima->channels)) {
#line 510
      goto while_break___0;
    }
#line 511
    if (pima->channels > 1) {
#line 511
      tmp = k % 2;
    } else {
#line 511
      tmp = 0;
    }
#line 511
    chan = tmp;
#line 513
    diff = (int )*(pima->samples + k) - pima->previous[chan];
#line 515
    bytecode = (short)0;
#line 516
    step = ima_step_size[pima->stepindx[chan]];
#line 517
    vpdiff = step >> 3;
#line 518
    if (diff < 0) {
#line 519
      bytecode = (short)8;
#line 520
      diff = - diff;
    }
#line 522
    mask = (short)4;
    {
#line 523
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 523
      if (! mask) {
#line 523
        goto while_break___1;
      }
#line 524
      if (diff >= step) {
#line 525
        bytecode = (short )((int )bytecode | (int )mask);
#line 526
        diff -= step;
#line 527
        vpdiff += step;
      }
#line 529
      step >>= 1;
#line 530
      mask = (short )((int )mask >> 1);
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: ;
#line 533
    if ((int )bytecode & 8) {
#line 534
      pima->previous[chan] -= vpdiff;
    } else {
#line 536
      pima->previous[chan] += vpdiff;
    }
#line 538
    if (pima->previous[chan] > 32767) {
#line 539
      pima->previous[chan] = 32767;
    } else
#line 540
    if (pima->previous[chan] < -32768) {
#line 541
      pima->previous[chan] = -32768;
    }
    {
#line 543
    pima->stepindx[chan] += ima_indx_adjust[bytecode];
#line 544
    pima->stepindx[chan] = clamp_ima_step_index(pima->stepindx[chan]);
#line 546
    *(pima->samples + k) = bytecode;
#line 510
    k ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 551
  blockindx = 4 * pima->channels;
#line 553
  indxstart = pima->channels;
  {
#line 554
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 554
    if (! (blockindx < pima->blocksize)) {
#line 554
      goto while_break___2;
    }
#line 555
    chan = 0;
    {
#line 555
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 555
      if (! (chan < pima->channels)) {
#line 555
        goto while_break___3;
      }
#line 556
      indx = indxstart + chan;
#line 557
      k = 0;
      {
#line 557
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 557
        if (! (k < 4)) {
#line 557
          goto while_break___4;
        }
#line 558
        *(pima->block + blockindx) = (unsigned char )((int )*(pima->samples + indx) & 15);
#line 559
        indx += pima->channels;
#line 560
        *(pima->block + blockindx) = (unsigned char )((int )*(pima->block + blockindx) | (((int )*(pima->samples + indx) << 4) & 240));
#line 561
        indx += pima->channels;
#line 562
        blockindx ++;
#line 557
        k ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: 
#line 555
      chan ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: 
#line 565
    indxstart += 8 * pima->channels;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 570
  __cil_tmp20 = psf_fwrite((void const   *)pima->block, (sf_count_t )1, (sf_count_t )pima->blocksize,
                           psf);
#line 570
  k = (int )__cil_tmp20;
  }
#line 570
  if (k != pima->blocksize) {
    {
#line 571
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, pima->blocksize);
    }
  }
  {
#line 573
  memset((void *)pima->samples, 0, (unsigned long )pima->samplesperblock * sizeof(short ));
#line 574
  pima->samplecount = 0;
#line 575
  (pima->blockcount) ++;
  }
#line 577
  return (1);
}
}
#line 581 "/root/patchweave_new/23/src/ima_adpcm.c"
static int ima_read_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima , short *ptr ,
                          int len ) 
{ 
  int count___0 ;
  int total ;
  int indx ;
  int tmp ;

  {
#line 582
  total = 0;
#line 582
  indx = 0;
  {
#line 584
  while (1) {
    while_continue: /* CIL Label */ ;

#line 584
    if (! (indx < len)) {
#line 584
      goto while_break;
    }
#line 585
    if (pima->blockcount >= pima->blocks) {
#line 585
      if (pima->samplecount >= pima->samplesperblock) {
        {
#line 586
        memset((void *)(ptr + indx), 0, (unsigned long )(len - indx) * sizeof(short ));
        }
#line 587
        return (total);
      }
    }
#line 590
    if (pima->samplecount >= pima->samplesperblock) {
      {
#line 591
      (*(pima->decode_block))(psf, pima);
      }
    }
#line 593
    count___0 = (pima->samplesperblock - pima->samplecount) * pima->channels;
#line 594
    if (len - indx > count___0) {
#line 594
      tmp = count___0;
    } else {
#line 594
      tmp = len - indx;
    }
    {
#line 594
    count___0 = tmp;
#line 596
    memcpy((void *)(ptr + indx), (void const   *)(pima->samples + pima->samplecount * pima->channels),
           (unsigned long )count___0 * sizeof(short ));
#line 597
    indx += count___0;
#line 598
    pima->samplecount += count___0 / pima->channels;
#line 599
    total = indx;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 602
  return (total);
}
}
#line 606 "/root/patchweave_new/23/src/ima_adpcm.c"
static sf_count_t ima_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 609
  total = (sf_count_t )0;
#line 611
  if (! psf->codec_data) {
#line 612
    return ((sf_count_t )0);
  }
#line 613
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;

#line 615
    if (! (len > 0L)) {
#line 615
      goto while_break;
    }
#line 616
    if (len > 268435456L) {
#line 616
      tmp = 268435456;
    } else {
#line 616
      tmp = (int )len;
    }
    {
#line 616
    readcount = tmp;
#line 618
    count___0 = ima_read_block(psf, pima, ptr, readcount);
#line 620
    total += (long )count___0;
#line 621
    len -= (long )count___0;
    }
#line 622
    if (count___0 != readcount) {
#line 623
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 626
  return (total);
}
}
#line 630 "/root/patchweave_new/23/src/ima_adpcm.c"
static sf_count_t ima_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 635
  total = (sf_count_t )0;
#line 637
  if (! psf->codec_data) {
#line 638
    return ((sf_count_t )0);
  }
#line 639
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 641
  sptr = ubuf.sbuf;
#line 642
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;

#line 643
    if (! (len > 0L)) {
#line 643
      goto while_break;
    }
#line 644
    if (len >= (long )bufferlen) {
#line 644
      tmp = bufferlen;
    } else {
#line 644
      tmp = (int )len;
    }
    {
#line 644
    readcount = tmp;
#line 645
    count___0 = ima_read_block(psf, pima, sptr, readcount);
#line 646
    k = 0;
    }
    {
#line 646
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 646
      if (! (k < readcount)) {
#line 646
        goto while_break___0;
      }
      {
#line 647
      *(ptr + (total + (long )k)) = arith_shift_left((int32_t )*(sptr + k), 16);
#line 646
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 648
    total += (long )count___0;
#line 649
    len -= (long )readcount;
#line 650
    if (count___0 != readcount) {
#line 651
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 654
  return (total);
}
}
#line 658 "/root/patchweave_new/23/src/ima_adpcm.c"
static sf_count_t ima_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  int tmp___0 ;

  {
#line 663
  total = (sf_count_t )0;
#line 666
  if (! psf->codec_data) {
#line 667
    return ((sf_count_t )0);
  }
#line 668
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 670
  if (psf->norm_float == 1) {
#line 670
    tmp = 1. / (double )((float )32768);
  } else {
#line 670
    tmp = 1.;
  }
#line 670
  normfact = (float )tmp;
#line 672
  sptr = ubuf.sbuf;
#line 673
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;

#line 674
    if (! (len > 0L)) {
#line 674
      goto while_break;
    }
#line 675
    if (len >= (long )bufferlen) {
#line 675
      tmp___0 = bufferlen;
    } else {
#line 675
      tmp___0 = (int )len;
    }
    {
#line 675
    readcount = tmp___0;
#line 676
    count___0 = ima_read_block(psf, pima, sptr, readcount);
#line 677
    k = 0;
    }
    {
#line 677
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 677
      if (! (k < readcount)) {
#line 677
        goto while_break___0;
      }
#line 678
      *(ptr + (total + (long )k)) = normfact * (float )*(sptr + k);
#line 677
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 679
    total += (long )count___0;
#line 680
    len -= (long )readcount;
#line 681
    if (count___0 != readcount) {
#line 682
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 685
  return (total);
}
}
#line 689 "/root/patchweave_new/23/src/ima_adpcm.c"
static sf_count_t ima_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  int tmp___0 ;

  {
#line 694
  total = (sf_count_t )0;
#line 697
  if (! psf->codec_data) {
#line 698
    return ((sf_count_t )0);
  }
#line 699
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 701
  if (psf->norm_double == 1) {
#line 701
    tmp = 1. / (double )32768;
  } else {
#line 701
    tmp = 1.;
  }
#line 701
  normfact = tmp;
#line 703
  sptr = ubuf.sbuf;
#line 704
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 705
  while (1) {
    while_continue: /* CIL Label */ ;

#line 705
    if (! (len > 0L)) {
#line 705
      goto while_break;
    }
#line 706
    if (len >= (long )bufferlen) {
#line 706
      tmp___0 = bufferlen;
    } else {
#line 706
      tmp___0 = (int )len;
    }
    {
#line 706
    readcount = tmp___0;
#line 707
    count___0 = ima_read_block(psf, pima, sptr, readcount);
#line 708
    k = 0;
    }
    {
#line 708
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 708
      if (! (k < readcount)) {
#line 708
        goto while_break___0;
      }
#line 709
      *(ptr + (total + (long )k)) = normfact * (double )*(sptr + k);
#line 708
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 710
    total += (long )count___0;
#line 711
    len -= (long )readcount;
#line 712
    if (count___0 != readcount) {
#line 713
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 716
  return (total);
}
}
#line 720 "/root/patchweave_new/23/src/ima_adpcm.c"
static sf_count_t aiff_ima_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int newblock ;
  int newsample ;
  int newblockaiff ;

  {
#line 724
  if (! psf->codec_data) {
#line 725
    return ((sf_count_t )0);
  }
#line 726
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 728
  if (psf->datalength < 0L) {
#line 729
    psf->error = 40;
#line 730
    return ((sf_count_t )-1);
  } else
#line 728
  if (psf->dataoffset < 0L) {
#line 729
    psf->error = 40;
#line 730
    return ((sf_count_t )-1);
  }
#line 733
  if (offset == 0L) {
    {
#line 734
    psf_fseek(psf, psf->dataoffset, 0);
#line 735
    pima->blockcount = 0;
#line 736
    (*(pima->decode_block))(psf, pima);
#line 737
    pima->samplecount = 0;
    }
#line 738
    return ((sf_count_t )0);
  }
#line 741
  if (offset < 0L) {
#line 742
    psf->error = 40;
#line 743
    return ((sf_count_t )-1);
  } else
#line 741
  if (offset > (long )(pima->blocks * pima->samplesperblock)) {
#line 742
    psf->error = 40;
#line 743
    return ((sf_count_t )-1);
  }
#line 746
  newblock = (int )(offset / (long )pima->samplesperblock);
#line 747
  newsample = (int )(offset % (long )pima->samplesperblock);
#line 748
  newblockaiff = newblock * psf->sf.channels;
#line 750
  if (mode == 16) {
    {
#line 751
    psf_fseek(psf, psf->dataoffset + (long )(newblockaiff * pima->blocksize), 0);
#line 752
    pima->blockcount = newblockaiff;
#line 753
    (*(pima->decode_block))(psf, pima);
#line 754
    pima->samplecount = newsample;
    }
  } else {
#line 758
    psf->error = 40;
#line 759
    return ((sf_count_t )-1);
  }
#line 762
  return ((sf_count_t )(newblock * pima->samplesperblock + newsample));
}
}
#line 766 "/root/patchweave_new/23/src/ima_adpcm.c"
static sf_count_t wavlike_ima_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int newblock ;
  int newsample ;

  {
#line 770
  if (! psf->codec_data) {
#line 771
    return ((sf_count_t )0);
  }
#line 772
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 774
  if (psf->datalength < 0L) {
#line 775
    psf->error = 40;
#line 776
    return ((sf_count_t )-1);
  } else
#line 774
  if (psf->dataoffset < 0L) {
#line 775
    psf->error = 40;
#line 776
    return ((sf_count_t )-1);
  }
#line 779
  if (offset == 0L) {
    {
#line 780
    psf_fseek(psf, psf->dataoffset, 0);
#line 781
    pima->blockcount = 0;
#line 782
    (*(pima->decode_block))(psf, pima);
#line 783
    pima->samplecount = 0;
    }
#line 784
    return ((sf_count_t )0);
  }
#line 787
  if (offset < 0L) {
#line 788
    psf->error = 40;
#line 789
    return ((sf_count_t )-1);
  } else
#line 787
  if (offset > (long )(pima->blocks * pima->samplesperblock)) {
#line 788
    psf->error = 40;
#line 789
    return ((sf_count_t )-1);
  }
#line 792
  newblock = (int )(offset / (long )pima->samplesperblock);
#line 793
  newsample = (int )(offset % (long )pima->samplesperblock);
#line 795
  if (mode == 16) {
    {
#line 796
    psf_fseek(psf, psf->dataoffset + (long )(newblock * pima->blocksize), 0);
#line 797
    pima->blockcount = newblock;
#line 798
    (*(pima->decode_block))(psf, pima);
#line 799
    pima->samplecount = newsample;
    }
  } else {
#line 803
    psf->error = 40;
#line 804
    return ((sf_count_t )-1);
  }
#line 807
  return ((sf_count_t )(newblock * pima->samplesperblock + newsample));
}
}
#line 815 "/root/patchweave_new/23/src/ima_adpcm.c"
static int ima_writer_init(SF_PRIVATE *psf , int blockalign ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int samplesperblock ;
  unsigned int pimasize ;
  void *tmp ;

  {
#line 820
  if (psf->file.mode != 32) {
#line 821
    return (24);
  }
  {
#line 823
  samplesperblock = (2 * (blockalign - 4 * psf->sf.channels)) / psf->sf.channels + 1;
#line 825
  pimasize = (unsigned int )((sizeof(IMA_ADPCM_PRIVATE ) + (unsigned long )blockalign) + (unsigned long )((3 * psf->sf.channels) * samplesperblock));
#line 827
  tmp = calloc(1UL, (unsigned long )pimasize);
#line 827
  pima = (IMA_ADPCM_PRIVATE *)tmp;
  }
#line 827
  if ((unsigned long )pima == (unsigned long )((void *)0)) {
#line 828
    return (17);
  }
#line 830
  psf->codec_data = (void *)pima;
#line 832
  pima->channels = psf->sf.channels;
#line 833
  pima->blocksize = blockalign;
#line 834
  pima->samplesperblock = samplesperblock;
#line 836
  pima->block = (unsigned char *)(pima->data);
#line 837
  pima->samples = pima->data + blockalign;
#line 839
  pima->samplecount = 0;
#line 843
  if ((psf->sf.format & 268369920) == 720896) {
#line 843
    goto case_720896;
  }
#line 843
  if ((psf->sf.format & 268369920) == 65536) {
#line 843
    goto case_720896;
  }
#line 847
  if ((psf->sf.format & 268369920) == 131072) {
#line 847
    goto case_131072;
  }
#line 851
  goto switch_default;
  case_720896: 
#line 844
  pima->encode_block = & wavlike_ima_encode_block;
#line 845
  goto switch_break;
  case_131072: 
#line 848
  pima->encode_block = & aiff_ima_encode_block;
#line 849
  goto switch_break;
  switch_default: 
  {
#line 852
  psf_log_printf(psf, "ima_reader_init: bad psf->sf.format\n");
  }
#line 853
  return (30);
  switch_break: 
#line 856
  psf->write_short = & ima_write_s;
#line 857
  psf->write_int = & ima_write_i;
#line 858
  psf->write_float = & ima_write_f;
#line 859
  psf->write_double = & ima_write_d;
#line 861
  return (0);
}
}
#line 868 "/root/patchweave_new/23/src/ima_adpcm.c"
static int ima_write_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima , short const   *ptr ,
                           int len ) 
{ 
  int count___0 ;
  int total ;
  int indx ;

  {
#line 869
  total = 0;
#line 869
  indx = 0;
  {
#line 871
  while (1) {
    while_continue: /* CIL Label */ ;

#line 871
    if (! (indx < len)) {
#line 871
      goto while_break;
    }
#line 872
    count___0 = (pima->samplesperblock - pima->samplecount) * pima->channels;
#line 874
    if (count___0 > len - indx) {
#line 875
      count___0 = len - indx;
    }
    {
#line 877
    memcpy((void *)(pima->samples + pima->samplecount * pima->channels), (void const   *)(ptr + total),
           (unsigned long )count___0 * sizeof(short ));
#line 878
    indx += count___0;
#line 879
    pima->samplecount += count___0 / pima->channels;
#line 880
    total = indx;
    }
#line 882
    if (pima->samplecount >= pima->samplesperblock) {
      {
#line 883
      (*(pima->encode_block))(psf, pima);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 886
  return (total);
}
}
#line 890 "/root/patchweave_new/23/src/ima_adpcm.c"
static sf_count_t ima_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 893
  total = (sf_count_t )0;
#line 895
  if (! psf->codec_data) {
#line 896
    return ((sf_count_t )0);
  }
#line 897
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
  {
#line 899
  while (1) {
    while_continue: /* CIL Label */ ;

#line 899
    if (! len) {
#line 899
      goto while_break;
    }
#line 900
    if (len > 268435456L) {
#line 900
      tmp = 268435456;
    } else {
#line 900
      tmp = (int )len;
    }
    {
#line 900
    writecount = tmp;
#line 902
    count___0 = ima_write_block(psf, pima, ptr, writecount);
#line 904
    total += (long )count___0;
#line 905
    len -= (long )count___0;
    }
#line 906
    if (count___0 != writecount) {
#line 907
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 910
  return (total);
}
}
#line 914 "/root/patchweave_new/23/src/ima_adpcm.c"
static sf_count_t ima_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 919
  total = (sf_count_t )0;
#line 921
  if (! psf->codec_data) {
#line 922
    return ((sf_count_t )0);
  }
#line 923
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 925
  sptr = ubuf.sbuf;
#line 926
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 927
  while (1) {
    while_continue: /* CIL Label */ ;

#line 927
    if (! (len > 0L)) {
#line 927
      goto while_break;
    }
#line 928
    if (len >= (long )bufferlen) {
#line 928
      tmp = bufferlen;
    } else {
#line 928
      tmp = (int )len;
    }
#line 928
    writecount = tmp;
#line 929
    k = 0;
    {
#line 929
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 929
      if (! (k < writecount)) {
#line 929
        goto while_break___0;
      }
#line 930
      *(sptr + k) = (short )(*(ptr + (total + (long )k)) >> 16);
#line 929
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 931
    count___0 = ima_write_block(psf, pima, (short const   *)sptr, writecount);
#line 932
    total += (long )count___0;
#line 933
    len -= (long )writecount;
    }
#line 934
    if (count___0 != writecount) {
#line 935
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 938
  return (total);
}
}
#line 942 "/root/patchweave_new/23/src/ima_adpcm.c"
static sf_count_t ima_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  int tmp___0 ;
  long __cil_tmp15 ;

  {
#line 947
  total = (sf_count_t )0;
#line 950
  if (! psf->codec_data) {
#line 951
    return ((sf_count_t )0);
  }
#line 952
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 954
  if (psf->norm_float == 1) {
#line 954
    tmp = 1. * (double )32767;
  } else {
#line 954
    tmp = 1.;
  }
#line 954
  normfact = (float )tmp;
#line 956
  sptr = ubuf.sbuf;
#line 957
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 958
  while (1) {
    while_continue: /* CIL Label */ ;

#line 958
    if (! (len > 0L)) {
#line 958
      goto while_break;
    }
#line 959
    if (len >= (long )bufferlen) {
#line 959
      tmp___0 = bufferlen;
    } else {
#line 959
      tmp___0 = (int )len;
    }
#line 959
    writecount = tmp___0;
#line 960
    k = 0;
    {
#line 960
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 960
      if (! (k < writecount)) {
#line 960
        goto while_break___0;
      }
      {
#line 961
      __cil_tmp15 = lrintf(normfact * (float )*(ptr + (total + (long )k)));
#line 961
      *(sptr + k) = (short )__cil_tmp15;
#line 960
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 962
    count___0 = ima_write_block(psf, pima, (short const   *)sptr, writecount);
#line 963
    total += (long )count___0;
#line 964
    len -= (long )writecount;
    }
#line 965
    if (count___0 != writecount) {
#line 966
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 969
  return (total);
}
}
#line 973 "/root/patchweave_new/23/src/ima_adpcm.c"
static sf_count_t ima_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  int tmp___0 ;
  long __cil_tmp15 ;

  {
#line 978
  total = (sf_count_t )0;
#line 981
  if (! psf->codec_data) {
#line 982
    return ((sf_count_t )0);
  }
#line 983
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 985
  if (psf->norm_double == 1) {
#line 985
    tmp = 1. * (double )32767;
  } else {
#line 985
    tmp = 1.;
  }
#line 985
  normfact = tmp;
#line 987
  sptr = ubuf.sbuf;
#line 988
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 989
  while (1) {
    while_continue: /* CIL Label */ ;

#line 989
    if (! (len > 0L)) {
#line 989
      goto while_break;
    }
#line 990
    if (len >= (long )bufferlen) {
#line 990
      tmp___0 = bufferlen;
    } else {
#line 990
      tmp___0 = (int )len;
    }
#line 990
    writecount = tmp___0;
#line 991
    k = 0;
    {
#line 991
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 991
      if (! (k < writecount)) {
#line 991
        goto while_break___0;
      }
      {
#line 992
      __cil_tmp15 = lrint(normfact * (double )*(ptr + (total + (long )k)));
#line 992
      *(sptr + k) = (short )__cil_tmp15;
#line 991
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 993
    count___0 = ima_write_block(psf, pima, (short const   *)sptr, writecount);
#line 994
    total += (long )count___0;
#line 995
    len -= (long )writecount;
    }
#line 996
    if (count___0 != writecount) {
#line 997
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1000
  return (total);
}
}
#line 31 "/root/patchweave_new/23/src/id3.c"
int id3_skip(SF_PRIVATE *psf ) 
{ 
  unsigned char buf[10] ;
  int offset ;

  {
  {
#line 34
  memset((void *)(buf), 0, sizeof(buf));
#line 35
  psf_binheader_readf(psf, "pb\001", 0, buf, 10);
  }
#line 37
  if ((int )buf[0] == 73) {
#line 37
    if ((int )buf[1] == 68) {
#line 37
      if ((int )buf[2] == 51) {
        {
#line 38
        offset = (int )buf[6] & 127;
#line 39
        offset = (offset << 7) | ((int )buf[7] & 127);
#line 40
        offset = (offset << 7) | ((int )buf[8] & 127);
#line 41
        offset = (offset << 7) | ((int )buf[9] & 127);
#line 43
        psf_log_printf(psf, "ID3 length : %d\n--------------------\n", offset);
        }
#line 46
        if (offset < 0) {
#line 47
          return (0);
        }
#line 50
        psf->fileoffset += (long )(offset + 10);
#line 52
        if (psf->fileoffset < psf->filelength) {
          {
#line 53
          psf_binheader_readf(psf, "p", psf->fileoffset);
          }
#line 54
          return (1);
        }
      }
    }
  }
#line 58
  return (0);
}
}
#line 34 "/root/patchweave_new/23/src/GSM610/gsm.h"
gsm gsm_create(void) ;
#line 37
void gsm_init(gsm state ) ;
#line 39
void gsm_destroy(gsm S ) ;
#line 42
int gsm_option(gsm r , int opt , int *val ) ;
#line 44
void gsm_encode(gsm s , gsm_signal *source , gsm_byte *c ) ;
#line 45
int gsm_decode(gsm s , gsm_byte *c , gsm_signal *target ) ;
#line 50 "/root/patchweave_new/23/src/gsm610.c"
static sf_count_t gsm610_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 51
static sf_count_t gsm610_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 52
static sf_count_t gsm610_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 53
static sf_count_t gsm610_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 55
static sf_count_t gsm610_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 56
static sf_count_t gsm610_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 57
static sf_count_t gsm610_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 58
static sf_count_t gsm610_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 60
static int gsm610_read_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 , short *ptr ,
                             int len ) ;
#line 61
static int gsm610_write_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 , short const   *ptr ,
                              int len ) ;
#line 63
static int gsm610_decode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) ;
#line 64
static int gsm610_encode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) ;
#line 66
static int gsm610_wav_decode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) ;
#line 67
static int gsm610_wav_encode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) ;
#line 69
static sf_count_t gsm610_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) ;
#line 71
static int gsm610_close(SF_PRIVATE *psf ) ;
#line 78 "/root/patchweave_new/23/src/gsm610.c"
int gsm610_init(SF_PRIVATE *psf ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  int true_flag ;
  void *tmp ;

  {
#line 80
  true_flag = 1;
#line 82
  if ((unsigned long )psf->codec_data != (unsigned long )((void *)0)) {
    {
#line 83
    psf_log_printf(psf, "*** psf->codec_data is not NULL.\n");
    }
#line 84
    return (30);
  }
#line 87
  if (psf->file.mode == 48) {
#line 88
    return (24);
  }
  {
#line 90
  psf->sf.seekable = 0;
#line 92
  tmp = calloc(1UL, sizeof(GSM610_PRIVATE ));
#line 92
  pgsm610 = (GSM610_PRIVATE *)tmp;
  }
#line 92
  if ((unsigned long )pgsm610 == (unsigned long )((void *)0)) {
#line 93
    return (17);
  }
  {
#line 95
  psf->codec_data = (void *)pgsm610;
#line 97
  memset((void *)pgsm610, 0, sizeof(GSM610_PRIVATE ));
#line 105
  pgsm610->gsm_data = gsm_create();
  }
#line 105
  if ((unsigned long )pgsm610->gsm_data == (unsigned long )((void *)0)) {
#line 106
    return (17);
  }
#line 111
  if ((psf->sf.format & 268369920) == 720896) {
#line 111
    goto case_720896;
  }
#line 111
  if ((psf->sf.format & 268369920) == 1245184) {
#line 111
    goto case_720896;
  }
#line 111
  if ((psf->sf.format & 268369920) == 65536) {
#line 111
    goto case_720896;
  }
#line 122
  if ((psf->sf.format & 268369920) == 262144) {
#line 122
    goto case_262144;
  }
#line 122
  if ((psf->sf.format & 268369920) == 131072) {
#line 122
    goto case_262144;
  }
#line 130
  goto switch_default;
  case_720896: 
  {
#line 112
  gsm_option(pgsm610->gsm_data, 4, & true_flag);
#line 114
  pgsm610->encode_block = & gsm610_wav_encode_block;
#line 115
  pgsm610->decode_block = & gsm610_wav_decode_block;
#line 117
  pgsm610->samplesperblock = 320;
#line 118
  pgsm610->blocksize = 65;
  }
#line 119
  goto switch_break;
  case_262144: 
#line 123
  pgsm610->encode_block = & gsm610_encode_block;
#line 124
  pgsm610->decode_block = & gsm610_decode_block;
#line 126
  pgsm610->samplesperblock = 160;
#line 127
  pgsm610->blocksize = 33;
#line 128
  goto switch_break;
  switch_default: 
#line 131
  return (30);
#line 132
  goto switch_break;
  switch_break: ;
#line 135
  if (psf->file.mode == 16) {
#line 136
    if (psf->datalength % (long )pgsm610->blocksize == 0L) {
#line 137
      pgsm610->blocks = (int )(psf->datalength / (long )pgsm610->blocksize);
    } else
#line 138
    if (psf->datalength % (long )pgsm610->blocksize == 1L) {
#line 138
      if (pgsm610->blocksize == 33) {
#line 146
        pgsm610->blocks = (int )(psf->datalength / (long )pgsm610->blocksize);
      } else {
        {
#line 149
        psf_log_printf(psf, "*** Warning : data chunk seems to be truncated.\n\220");
#line 150
        pgsm610->blocks = (int )(psf->datalength / (long )pgsm610->blocksize + 1L);
        }
      }
    } else {
      {
#line 149
      psf_log_printf(psf, "*** Warning : data chunk seems to be truncated.\n\220");
#line 150
      pgsm610->blocks = (int )(psf->datalength / (long )pgsm610->blocksize + 1L);
      }
    }
    {
#line 153
    psf->sf.frames = (sf_count_t )(pgsm610->samplesperblock * pgsm610->blocks);
#line 155
    psf_fseek(psf, psf->dataoffset, 0);
#line 157
    (*(pgsm610->decode_block))(psf, pgsm610);
#line 159
    psf->read_short = & gsm610_read_s;
#line 160
    psf->read_int = & gsm610_read_i;
#line 161
    psf->read_float = & gsm610_read_f;
#line 162
    psf->read_double = & gsm610_read_d;
    }
  }
#line 165
  if (psf->file.mode == 32) {
#line 166
    pgsm610->blockcount = 0;
#line 167
    pgsm610->samplecount = 0;
#line 169
    psf->write_short = & gsm610_write_s;
#line 170
    psf->write_int = & gsm610_write_i;
#line 171
    psf->write_float = & gsm610_write_f;
#line 172
    psf->write_double = & gsm610_write_d;
  }
  {
#line 175
  psf->codec_close = & gsm610_close;
#line 177
  psf->seek = & gsm610_seek;
#line 179
  psf->filelength = psf_get_filelen(psf);
#line 180
  psf->datalength = psf->filelength - psf->dataoffset;
  }
#line 182
  return (0);
}
}
#line 190 "/root/patchweave_new/23/src/gsm610.c"
static int gsm610_wav_decode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) 
{ 
  int k ;
  sf_count_t __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 193
  (pgsm610->blockcount) ++;
#line 194
  pgsm610->samplecount = 0;
#line 196
  if (pgsm610->blockcount > pgsm610->blocks) {
    {
#line 197
    memset((void *)(pgsm610->samples), 0, sizeof(pgsm610->samples));
    }
#line 198
    return (1);
  }
  {
#line 201
  __cil_tmp5 = psf_fread((void *)(pgsm610->block), (sf_count_t )1, (sf_count_t )65,
                         psf);
#line 201
  k = (int )__cil_tmp5;
  }
#line 201
  if (k != 65) {
    {
#line 202
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, 65);
    }
  }
  {
#line 204
  __cil_tmp6 = gsm_decode(pgsm610->gsm_data, pgsm610->block, pgsm610->samples);
  }
#line 204
  if (__cil_tmp6 < 0) {
    {
#line 205
    psf_log_printf(psf, "Error from WAV gsm_decode() on frame : %d\n", pgsm610->blockcount);
    }
#line 206
    return (0);
  }
  {
#line 209
  __cil_tmp7 = gsm_decode(pgsm610->gsm_data, pgsm610->block + 33, pgsm610->samples + 160);
  }
#line 209
  if (__cil_tmp7 < 0) {
    {
#line 210
    psf_log_printf(psf, "Error from WAV gsm_decode() on frame : %d.5\n", pgsm610->blockcount);
    }
#line 211
    return (0);
  }
#line 214
  return (1);
}
}
#line 218 "/root/patchweave_new/23/src/gsm610.c"
static int gsm610_decode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) 
{ 
  int k ;
  sf_count_t __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 221
  (pgsm610->blockcount) ++;
#line 222
  pgsm610->samplecount = 0;
#line 224
  if (pgsm610->blockcount > pgsm610->blocks) {
    {
#line 225
    memset((void *)(pgsm610->samples), 0, sizeof(pgsm610->samples));
    }
#line 226
    return (1);
  }
  {
#line 229
  __cil_tmp5 = psf_fread((void *)(pgsm610->block), (sf_count_t )1, (sf_count_t )33,
                         psf);
#line 229
  k = (int )__cil_tmp5;
  }
#line 229
  if (k != 33) {
    {
#line 230
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, 33);
    }
  }
  {
#line 232
  __cil_tmp6 = gsm_decode(pgsm610->gsm_data, pgsm610->block, pgsm610->samples);
  }
#line 232
  if (__cil_tmp6 < 0) {
    {
#line 233
    psf_log_printf(psf, "Error from standard gsm_decode() on frame : %d\n", pgsm610->blockcount);
    }
#line 234
    return (0);
  }
#line 237
  return (1);
}
}
#line 241 "/root/patchweave_new/23/src/gsm610.c"
static int gsm610_read_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 , short *ptr ,
                             int len ) 
{ 
  int count___0 ;
  int total ;
  int indx ;
  int tmp ;

  {
#line 242
  total = 0;
#line 242
  indx = 0;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;

#line 244
    if (! (indx < len)) {
#line 244
      goto while_break;
    }
#line 245
    if (pgsm610->blockcount >= pgsm610->blocks) {
#line 245
      if (pgsm610->samplecount >= pgsm610->samplesperblock) {
        {
#line 246
        memset((void *)(ptr + indx), 0, (unsigned long )(len - indx) * sizeof(short ));
        }
#line 247
        return (total);
      }
    }
#line 250
    if (pgsm610->samplecount >= pgsm610->samplesperblock) {
      {
#line 251
      (*(pgsm610->decode_block))(psf, pgsm610);
      }
    }
#line 253
    count___0 = pgsm610->samplesperblock - pgsm610->samplecount;
#line 254
    if (len - indx > count___0) {
#line 254
      tmp = count___0;
    } else {
#line 254
      tmp = len - indx;
    }
    {
#line 254
    count___0 = tmp;
#line 256
    memcpy((void *)(ptr + indx), (void const   *)(& pgsm610->samples[pgsm610->samplecount]),
           (unsigned long )count___0 * sizeof(short ));
#line 257
    indx += count___0;
#line 258
    pgsm610->samplecount += count___0;
#line 259
    total = indx;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 262
  return (total);
}
}
#line 266 "/root/patchweave_new/23/src/gsm610.c"
static sf_count_t gsm610_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 269
  total = (sf_count_t )0;
#line 271
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 272
    return ((sf_count_t )0);
  }
#line 273
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;

#line 275
    if (! (len > 0L)) {
#line 275
      goto while_break;
    }
#line 276
    if (len > 268435456L) {
#line 276
      tmp = 16777216;
    } else {
#line 276
      tmp = (int )len;
    }
    {
#line 276
    readcount = tmp;
#line 278
    count___0 = gsm610_read_block(psf, pgsm610, ptr, readcount);
#line 280
    total += (long )count___0;
#line 281
    len -= (long )count___0;
    }
#line 283
    if (count___0 != readcount) {
#line 284
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 287
  return (total);
}
}
#line 291 "/root/patchweave_new/23/src/gsm610.c"
static sf_count_t gsm610_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 295
  readcount = 0;
#line 296
  total = (sf_count_t )0;
#line 298
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 299
    return ((sf_count_t )0);
  }
#line 300
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 302
  sptr = ubuf.sbuf;
#line 303
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;

#line 304
    if (! (len > 0L)) {
#line 304
      goto while_break;
    }
#line 305
    if (len >= (long )bufferlen) {
#line 305
      tmp = (long )bufferlen;
    } else {
#line 305
      tmp = len;
    }
    {
#line 305
    readcount = (int )tmp;
#line 306
    count___0 = gsm610_read_block(psf, pgsm610, sptr, readcount);
#line 307
    k = 0;
    }
    {
#line 307
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 307
      if (! (k < readcount)) {
#line 307
        goto while_break___0;
      }
      {
#line 308
      *(ptr + (total + (long )k)) = arith_shift_left((int32_t )*(sptr + k), 16);
#line 307
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 310
    total += (long )count___0;
#line 311
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 313
  return (total);
}
}
#line 317 "/root/patchweave_new/23/src/gsm610.c"
static sf_count_t gsm610_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 321
  readcount = 0;
#line 322
  total = (sf_count_t )0;
#line 325
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 326
    return ((sf_count_t )0);
  }
#line 327
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 329
  if (psf->norm_float == 1) {
#line 329
    tmp = 1. / (double )((float )32768);
  } else {
#line 329
    tmp = 1.;
  }
#line 329
  normfact = (float )tmp;
#line 331
  sptr = ubuf.sbuf;
#line 332
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;

#line 333
    if (! (len > 0L)) {
#line 333
      goto while_break;
    }
#line 334
    if (len >= (long )bufferlen) {
#line 334
      tmp___0 = (long )bufferlen;
    } else {
#line 334
      tmp___0 = len;
    }
    {
#line 334
    readcount = (int )tmp___0;
#line 335
    count___0 = gsm610_read_block(psf, pgsm610, sptr, readcount);
#line 336
    k = 0;
    }
    {
#line 336
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 336
      if (! (k < readcount)) {
#line 336
        goto while_break___0;
      }
#line 337
      *(ptr + (total + (long )k)) = normfact * (float )((int )*(sptr + k));
#line 336
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 339
    total += (long )count___0;
#line 340
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 342
  return (total);
}
}
#line 346 "/root/patchweave_new/23/src/gsm610.c"
static sf_count_t gsm610_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 350
  readcount = 0;
#line 351
  total = (sf_count_t )0;
#line 354
  if (psf->norm_double == 1) {
#line 354
    tmp = 1. / (double )32768;
  } else {
#line 354
    tmp = 1.;
  }
#line 354
  normfact = tmp;
#line 356
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 357
    return ((sf_count_t )0);
  }
#line 358
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 360
  sptr = ubuf.sbuf;
#line 361
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;

#line 362
    if (! (len > 0L)) {
#line 362
      goto while_break;
    }
#line 363
    if (len >= (long )bufferlen) {
#line 363
      tmp___0 = (long )bufferlen;
    } else {
#line 363
      tmp___0 = len;
    }
    {
#line 363
    readcount = (int )tmp___0;
#line 364
    count___0 = gsm610_read_block(psf, pgsm610, sptr, readcount);
#line 365
    k = 0;
    }
    {
#line 365
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 365
      if (! (k < readcount)) {
#line 365
        goto while_break___0;
      }
#line 366
      *(ptr + (total + (long )k)) = normfact * (double )((int )*(sptr + k));
#line 365
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 368
    total += (long )count___0;
#line 369
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 371
  return (total);
}
}
#line 375 "/root/patchweave_new/23/src/gsm610.c"
static sf_count_t gsm610_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  int newblock ;
  int newsample ;
  int true_flag ;

  {
#line 379
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 380
    return ((sf_count_t )0);
  }
#line 381
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 383
  if (psf->dataoffset < 0L) {
#line 384
    psf->error = 40;
#line 385
    return ((sf_count_t )-1);
  }
#line 388
  if (offset == 0L) {
    {
#line 389
    true_flag = 1;
#line 391
    psf_fseek(psf, psf->dataoffset, 0);
#line 392
    pgsm610->blockcount = 0;
#line 394
    gsm_init(pgsm610->gsm_data);
    }
#line 395
    if ((psf->sf.format & 268369920) == 65536) {
      {
#line 397
      gsm_option(pgsm610->gsm_data, 4, & true_flag);
      }
    } else
#line 395
    if ((psf->sf.format & 268369920) == 720896) {
      {
#line 397
      gsm_option(pgsm610->gsm_data, 4, & true_flag);
      }
    }
    {
#line 399
    (*(pgsm610->decode_block))(psf, pgsm610);
#line 400
    pgsm610->samplecount = 0;
    }
#line 401
    return ((sf_count_t )0);
  }
#line 404
  if (offset < 0L) {
#line 405
    psf->error = 40;
#line 406
    return ((sf_count_t )-1);
  } else
#line 404
  if (offset > (long )(pgsm610->blocks * pgsm610->samplesperblock)) {
#line 405
    psf->error = 40;
#line 406
    return ((sf_count_t )-1);
  }
#line 409
  newblock = (int )(offset / (long )pgsm610->samplesperblock);
#line 410
  newsample = (int )(offset % (long )pgsm610->samplesperblock);
#line 412
  if (psf->file.mode == 16) {
#line 413
    if (psf->read_current != (long )(newblock * pgsm610->samplesperblock + newsample)) {
      {
#line 414
      psf_fseek(psf, psf->dataoffset + (long )(newblock * pgsm610->samplesperblock),
                0);
#line 415
      pgsm610->blockcount = newblock;
#line 416
      (*(pgsm610->decode_block))(psf, pgsm610);
#line 417
      pgsm610->samplecount = newsample;
      }
    }
#line 420
    return ((sf_count_t )(newblock * pgsm610->samplesperblock + newsample));
  }
#line 424
  psf->error = 40;
#line 425
  return ((sf_count_t )-1);
}
}
#line 433 "/root/patchweave_new/23/src/gsm610.c"
static int gsm610_encode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) 
{ 
  int k ;
  sf_count_t __cil_tmp4 ;

  {
  {
#line 437
  gsm_encode(pgsm610->gsm_data, pgsm610->samples, pgsm610->block);
#line 440
  __cil_tmp4 = psf_fwrite((void const   *)(pgsm610->block), (sf_count_t )1, (sf_count_t )33,
                          psf);
#line 440
  k = (int )__cil_tmp4;
  }
#line 440
  if (k != 33) {
    {
#line 441
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, 33);
    }
  }
  {
#line 443
  pgsm610->samplecount = 0;
#line 444
  (pgsm610->blockcount) ++;
#line 447
  memset((void *)(pgsm610->samples), 0, sizeof(pgsm610->samples));
  }
#line 449
  return (1);
}
}
#line 453 "/root/patchweave_new/23/src/gsm610.c"
static int gsm610_wav_encode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) 
{ 
  int k ;
  sf_count_t __cil_tmp4 ;

  {
  {
#line 457
  gsm_encode(pgsm610->gsm_data, pgsm610->samples, pgsm610->block);
#line 458
  gsm_encode(pgsm610->gsm_data, pgsm610->samples + 160, pgsm610->block + 32);
#line 461
  __cil_tmp4 = psf_fwrite((void const   *)(pgsm610->block), (sf_count_t )1, (sf_count_t )65,
                          psf);
#line 461
  k = (int )__cil_tmp4;
  }
#line 461
  if (k != 65) {
    {
#line 462
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, 65);
    }
  }
  {
#line 464
  pgsm610->samplecount = 0;
#line 465
  (pgsm610->blockcount) ++;
#line 468
  memset((void *)(pgsm610->samples), 0, sizeof(pgsm610->samples));
  }
#line 470
  return (1);
}
}
#line 474 "/root/patchweave_new/23/src/gsm610.c"
static int gsm610_write_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 , short const   *ptr ,
                              int len ) 
{ 
  int count___0 ;
  int total ;
  int indx ;

  {
#line 475
  total = 0;
#line 475
  indx = 0;
  {
#line 477
  while (1) {
    while_continue: /* CIL Label */ ;

#line 477
    if (! (indx < len)) {
#line 477
      goto while_break;
    }
#line 478
    count___0 = pgsm610->samplesperblock - pgsm610->samplecount;
#line 480
    if (count___0 > len - indx) {
#line 481
      count___0 = len - indx;
    }
    {
#line 483
    memcpy((void *)(& pgsm610->samples[pgsm610->samplecount]), (void const   *)(ptr + indx),
           (unsigned long )count___0 * sizeof(short ));
#line 484
    indx += count___0;
#line 485
    pgsm610->samplecount += count___0;
#line 486
    total = indx;
    }
#line 488
    if (pgsm610->samplecount >= pgsm610->samplesperblock) {
      {
#line 489
      (*(pgsm610->encode_block))(psf, pgsm610);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 492
  return (total);
}
}
#line 496 "/root/patchweave_new/23/src/gsm610.c"
static sf_count_t gsm610_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 499
  total = (sf_count_t )0;
#line 501
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 502
    return ((sf_count_t )0);
  }
#line 503
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;

#line 505
    if (! (len > 0L)) {
#line 505
      goto while_break;
    }
#line 506
    if (len > 268435456L) {
#line 506
      tmp = 268435456;
    } else {
#line 506
      tmp = (int )len;
    }
    {
#line 506
    writecount = tmp;
#line 508
    count___0 = gsm610_write_block(psf, pgsm610, ptr, writecount);
#line 510
    total += (long )count___0;
#line 511
    len -= (long )count___0;
    }
#line 513
    if (count___0 != writecount) {
#line 514
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 517
  return (total);
}
}
#line 521 "/root/patchweave_new/23/src/gsm610.c"
static sf_count_t gsm610_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 525
  writecount = 0;
#line 526
  total = (sf_count_t )0;
#line 528
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 529
    return ((sf_count_t )0);
  }
#line 530
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 532
  sptr = ubuf.sbuf;
#line 533
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;

#line 534
    if (! (len > 0L)) {
#line 534
      goto while_break;
    }
#line 535
    if (len >= (long )bufferlen) {
#line 535
      tmp = (long )bufferlen;
    } else {
#line 535
      tmp = len;
    }
#line 535
    writecount = (int )tmp;
#line 536
    k = 0;
    {
#line 536
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 536
      if (! (k < writecount)) {
#line 536
        goto while_break___0;
      }
#line 537
      *(sptr + k) = (short )(*(ptr + (total + (long )k)) >> 16);
#line 536
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 538
    count___0 = gsm610_write_block(psf, pgsm610, (short const   *)sptr, writecount);
#line 540
    total += (long )count___0;
#line 541
    len -= (long )writecount;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 543
  return (total);
}
}
#line 547 "/root/patchweave_new/23/src/gsm610.c"
static sf_count_t gsm610_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 551
  writecount = 0;
#line 552
  total = (sf_count_t )0;
#line 555
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 556
    return ((sf_count_t )0);
  }
#line 557
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 559
  if (psf->norm_float == 1) {
#line 559
    tmp = 1. * (double )32767;
  } else {
#line 559
    tmp = 1.;
  }
#line 559
  normfact = (float )tmp;
#line 561
  sptr = ubuf.sbuf;
#line 562
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;

#line 563
    if (! (len > 0L)) {
#line 563
      goto while_break;
    }
#line 564
    if (len >= (long )bufferlen) {
#line 564
      tmp___0 = (long )bufferlen;
    } else {
#line 564
      tmp___0 = len;
    }
#line 564
    writecount = (int )tmp___0;
#line 565
    k = 0;
    {
#line 565
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 565
      if (! (k < writecount)) {
#line 565
        goto while_break___0;
      }
      {
#line 566
      __cil_tmp15 = lrintf(normfact * (float )*(ptr + (total + (long )k)));
#line 566
      *(sptr + k) = (short )__cil_tmp15;
#line 565
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 567
    count___0 = gsm610_write_block(psf, pgsm610, (short const   *)sptr, writecount);
#line 569
    total += (long )count___0;
#line 570
    len -= (long )writecount;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 572
  return (total);
}
}
#line 576 "/root/patchweave_new/23/src/gsm610.c"
static sf_count_t gsm610_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 580
  writecount = 0;
#line 581
  total = (sf_count_t )0;
#line 584
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 585
    return ((sf_count_t )0);
  }
#line 586
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 588
  if (psf->norm_double == 1) {
#line 588
    tmp = 1. * (double )32767;
  } else {
#line 588
    tmp = 1.;
  }
#line 588
  normfact = tmp;
#line 590
  sptr = ubuf.sbuf;
#line 591
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;

#line 592
    if (! (len > 0L)) {
#line 592
      goto while_break;
    }
#line 593
    if (len >= (long )bufferlen) {
#line 593
      tmp___0 = (long )bufferlen;
    } else {
#line 593
      tmp___0 = len;
    }
#line 593
    writecount = (int )tmp___0;
#line 594
    k = 0;
    {
#line 594
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 594
      if (! (k < writecount)) {
#line 594
        goto while_break___0;
      }
      {
#line 595
      __cil_tmp15 = lrint(normfact * (double )*(ptr + (total + (long )k)));
#line 595
      *(sptr + k) = (short )__cil_tmp15;
#line 594
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 596
    count___0 = gsm610_write_block(psf, pgsm610, (short const   *)sptr, writecount);
#line 598
    total += (long )count___0;
#line 599
    len -= (long )writecount;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 601
  return (total);
}
}
#line 605 "/root/patchweave_new/23/src/gsm610.c"
static int gsm610_close(SF_PRIVATE *psf ) 
{ 
  GSM610_PRIVATE *pgsm610 ;

  {
#line 608
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 609
    return (0);
  }
#line 611
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 613
  if (psf->file.mode == 32) {
#line 618
    if (pgsm610->samplecount) {
#line 618
      if (pgsm610->samplecount < pgsm610->samplesperblock) {
        {
#line 619
        (*(pgsm610->encode_block))(psf, pgsm610);
        }
      }
    }
  }
#line 622
  if (pgsm610->gsm_data) {
    {
#line 623
    gsm_destroy(pgsm610->gsm_data);
    }
  }
#line 625
  return (0);
}
}
#line 56 "/root/patchweave_new/23/src/float32.c"
static sf_count_t host_read_f2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 57
static sf_count_t host_read_f2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 58
static sf_count_t host_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 59
static sf_count_t host_read_f2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 61
static sf_count_t host_write_s2f(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 62
static sf_count_t host_write_i2f(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 63
static sf_count_t host_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 64
static sf_count_t host_write_d2f(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 66
static void float32_peak_update(SF_PRIVATE *psf , float const   *buffer , int count___0 ,
                                sf_count_t indx ) ;
#line 68
static sf_count_t replace_read_f2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 69
static sf_count_t replace_read_f2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 70
static sf_count_t replace_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 71
static sf_count_t replace_read_f2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 73
static sf_count_t replace_write_s2f(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 74
static sf_count_t replace_write_i2f(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 75
static sf_count_t replace_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 76
static sf_count_t replace_write_d2f(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 78
static void bf2f_array(float *buffer , int count___0 ) ;
#line 79
static void f2bf_array(float *buffer , int count___0 ) ;
#line 81
static int float32_get_capability(SF_PRIVATE *psf ) ;
#line 90 "/root/patchweave_new/23/src/float32.c"
static int float_caps  ;
#line 88 "/root/patchweave_new/23/src/float32.c"
int float32_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t tmp ;
  sf_count_t tmp___0 ;

  {
#line 91
  if (psf->sf.channels < 1) {
    {
#line 92
    psf_log_printf(psf, "float32_init : internal error : channels = %d\n", psf->sf.channels);
    }
#line 93
    return (30);
  }
  {
#line 96
  float_caps = float32_get_capability(psf);
#line 98
  psf->blockwidth = (int )(sizeof(float ) * (unsigned long )psf->sf.channels);
  }
#line 100
  if (psf->file.mode == 16) {
    _L: 
#line 102
    if (psf->endian + float_caps == 536870947) {
#line 102
      goto case_536870947;
    }
#line 110
    if (psf->endian + float_caps == 268435474) {
#line 110
      goto case_268435474;
    }
#line 118
    if (psf->endian + float_caps == 536870930) {
#line 118
      goto case_536870930;
    }
#line 126
    if (psf->endian + float_caps == 268435491) {
#line 126
      goto case_268435491;
    }
#line 135
    if (psf->endian + float_caps == 536870964) {
#line 135
      goto case_536870964;
    }
#line 143
    if (psf->endian + float_caps == 268435508) {
#line 143
      goto case_268435508;
    }
#line 151
    if (psf->endian + float_caps == 536870981) {
#line 151
      goto case_536870981;
    }
#line 159
    if (psf->endian + float_caps == 268435525) {
#line 159
      goto case_268435525;
    }
#line 167
    goto switch_default;
    case_536870947: 
#line 103
    psf->data_endswap = 0;
#line 104
    psf->read_short = & host_read_f2s;
#line 105
    psf->read_int = & host_read_f2i;
#line 106
    psf->read_float = & host_read_f;
#line 107
    psf->read_double = & host_read_f2d;
#line 108
    goto switch_break;
    case_268435474: 
#line 111
    psf->data_endswap = 0;
#line 112
    psf->read_short = & host_read_f2s;
#line 113
    psf->read_int = & host_read_f2i;
#line 114
    psf->read_float = & host_read_f;
#line 115
    psf->read_double = & host_read_f2d;
#line 116
    goto switch_break;
    case_536870930: 
#line 119
    psf->data_endswap = 1;
#line 120
    psf->read_short = & host_read_f2s;
#line 121
    psf->read_int = & host_read_f2i;
#line 122
    psf->read_float = & host_read_f;
#line 123
    psf->read_double = & host_read_f2d;
#line 124
    goto switch_break;
    case_268435491: 
#line 127
    psf->data_endswap = 1;
#line 128
    psf->read_short = & host_read_f2s;
#line 129
    psf->read_int = & host_read_f2i;
#line 130
    psf->read_float = & host_read_f;
#line 131
    psf->read_double = & host_read_f2d;
#line 132
    goto switch_break;
    case_536870964: 
#line 136
    psf->data_endswap = 1;
#line 137
    psf->read_short = & replace_read_f2s;
#line 138
    psf->read_int = & replace_read_f2i;
#line 139
    psf->read_float = & replace_read_f;
#line 140
    psf->read_double = & replace_read_f2d;
#line 141
    goto switch_break;
    case_268435508: 
#line 144
    psf->data_endswap = 0;
#line 145
    psf->read_short = & replace_read_f2s;
#line 146
    psf->read_int = & replace_read_f2i;
#line 147
    psf->read_float = & replace_read_f;
#line 148
    psf->read_double = & replace_read_f2d;
#line 149
    goto switch_break;
    case_536870981: 
#line 152
    psf->data_endswap = 0;
#line 153
    psf->read_short = & replace_read_f2s;
#line 154
    psf->read_int = & replace_read_f2i;
#line 155
    psf->read_float = & replace_read_f;
#line 156
    psf->read_double = & replace_read_f2d;
#line 157
    goto switch_break;
    case_268435525: 
#line 160
    psf->data_endswap = 1;
#line 161
    psf->read_short = & replace_read_f2s;
#line 162
    psf->read_int = & replace_read_f2i;
#line 163
    psf->read_float = & replace_read_f;
#line 164
    psf->read_double = & replace_read_f2d;
#line 165
    goto switch_break;
    switch_default: 
#line 167
    goto switch_break;
    switch_break: ;
  } else
#line 100
  if (psf->file.mode == 48) {
#line 100
    goto _L;
  }
#line 171
  if (psf->file.mode == 32) {
    _L___3: 
#line 173
    if (psf->endian + float_caps == 268435474) {
#line 173
      goto case_268435474___0;
    }
#line 181
    if (psf->endian + float_caps == 536870947) {
#line 181
      goto case_536870947___0;
    }
#line 189
    if (psf->endian + float_caps == 536870930) {
#line 189
      goto case_536870930___0;
    }
#line 197
    if (psf->endian + float_caps == 268435491) {
#line 197
      goto case_268435491___0;
    }
#line 206
    if (psf->endian + float_caps == 536870964) {
#line 206
      goto case_536870964___0;
    }
#line 214
    if (psf->endian + float_caps == 268435508) {
#line 214
      goto case_268435508___0;
    }
#line 222
    if (psf->endian + float_caps == 536870981) {
#line 222
      goto case_536870981___0;
    }
#line 230
    if (psf->endian + float_caps == 268435525) {
#line 230
      goto case_268435525___0;
    }
#line 238
    goto switch_default___0;
    case_268435474___0: 
#line 174
    psf->data_endswap = 0;
#line 175
    psf->write_short = & host_write_s2f;
#line 176
    psf->write_int = & host_write_i2f;
#line 177
    psf->write_float = & host_write_f;
#line 178
    psf->write_double = & host_write_d2f;
#line 179
    goto switch_break___0;
    case_536870947___0: 
#line 182
    psf->data_endswap = 0;
#line 183
    psf->write_short = & host_write_s2f;
#line 184
    psf->write_int = & host_write_i2f;
#line 185
    psf->write_float = & host_write_f;
#line 186
    psf->write_double = & host_write_d2f;
#line 187
    goto switch_break___0;
    case_536870930___0: 
#line 190
    psf->data_endswap = 1;
#line 191
    psf->write_short = & host_write_s2f;
#line 192
    psf->write_int = & host_write_i2f;
#line 193
    psf->write_float = & host_write_f;
#line 194
    psf->write_double = & host_write_d2f;
#line 195
    goto switch_break___0;
    case_268435491___0: 
#line 198
    psf->data_endswap = 1;
#line 199
    psf->write_short = & host_write_s2f;
#line 200
    psf->write_int = & host_write_i2f;
#line 201
    psf->write_float = & host_write_f;
#line 202
    psf->write_double = & host_write_d2f;
#line 203
    goto switch_break___0;
    case_536870964___0: 
#line 207
    psf->data_endswap = 1;
#line 208
    psf->write_short = & replace_write_s2f;
#line 209
    psf->write_int = & replace_write_i2f;
#line 210
    psf->write_float = & replace_write_f;
#line 211
    psf->write_double = & replace_write_d2f;
#line 212
    goto switch_break___0;
    case_268435508___0: 
#line 215
    psf->data_endswap = 0;
#line 216
    psf->write_short = & replace_write_s2f;
#line 217
    psf->write_int = & replace_write_i2f;
#line 218
    psf->write_float = & replace_write_f;
#line 219
    psf->write_double = & replace_write_d2f;
#line 220
    goto switch_break___0;
    case_536870981___0: 
#line 223
    psf->data_endswap = 0;
#line 224
    psf->write_short = & replace_write_s2f;
#line 225
    psf->write_int = & replace_write_i2f;
#line 226
    psf->write_float = & replace_write_f;
#line 227
    psf->write_double = & replace_write_d2f;
#line 228
    goto switch_break___0;
    case_268435525___0: 
#line 231
    psf->data_endswap = 1;
#line 232
    psf->write_short = & replace_write_s2f;
#line 233
    psf->write_int = & replace_write_i2f;
#line 234
    psf->write_float = & replace_write_f;
#line 235
    psf->write_double = & replace_write_d2f;
#line 236
    goto switch_break___0;
    switch_default___0: 
#line 238
    goto switch_break___0;
    switch_break___0: ;
  } else
#line 171
  if (psf->file.mode == 48) {
#line 171
    goto _L___3;
  }
#line 242
  if (psf->filelength > psf->dataoffset) {
#line 243
    if (psf->dataend > 0L) {
#line 243
      tmp = psf->dataend - psf->dataoffset;
    } else {
#line 243
      tmp = psf->filelength - psf->dataoffset;
    }
#line 243
    psf->datalength = tmp;
  } else {
#line 247
    psf->datalength = (sf_count_t )0;
  }
#line 249
  if (psf->blockwidth > 0) {
#line 249
    tmp___0 = psf->datalength / (long )psf->blockwidth;
  } else {
#line 249
    tmp___0 = 0L;
  }
#line 249
  psf->sf.frames = tmp___0;
#line 251
  return (0);
}
}
#line 255 "/root/patchweave_new/23/src/float32.c"
float float32_be_read(unsigned char const   *cptr ) 
{ 
  int exponent ;
  int mantissa ;
  int negative ;
  float fvalue ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double __cil_tmp9 ;
  int __cil_tmp10 ;
  double __cil_tmp11 ;

  {
#line 259
  negative = (int )*(cptr + 0) & 128;
#line 260
  if ((int )*(cptr + 1) & 128) {
#line 260
    tmp = 1;
  } else {
#line 260
    tmp = 0;
  }
#line 260
  exponent = (((int )*(cptr + 0) & 127) << 1) | tmp;
#line 261
  mantissa = ((((int )*(cptr + 1) & 127) << 16) | ((int )*(cptr + 2) << 8)) | (int )*(cptr + 3);
#line 263
  if (! exponent) {
#line 263
    if (! mantissa) {
#line 264
      return ((float )0.);
    }
  }
#line 266
  mantissa |= 8388608;
#line 267
  if (exponent) {
#line 267
    tmp___0 = exponent - 127;
  } else {
#line 267
    tmp___0 = 0;
  }
#line 267
  exponent = tmp___0;
#line 269
  if (mantissa) {
#line 269
    tmp___1 = (double )((float )mantissa / (float )8388608);
  } else {
#line 269
    tmp___1 = 0.;
  }
#line 269
  fvalue = (float )tmp___1;
#line 271
  if (negative) {
#line 272
    fvalue *= (float )-1;
  }
#line 274
  if (exponent > 0) {
    {
#line 275
    __cil_tmp9 = pow(2., (double )exponent);
#line 275
    fvalue = (float )((double )fvalue * __cil_tmp9);
    }
  } else
#line 276
  if (exponent < 0) {
    {
#line 277
    __cil_tmp10 = abs(exponent);
#line 277
    __cil_tmp11 = pow(2., (double )__cil_tmp10);
#line 277
    fvalue = (float )((double )fvalue / __cil_tmp11);
    }
  }
#line 279
  return (fvalue);
}
}
#line 283 "/root/patchweave_new/23/src/float32.c"
float float32_le_read(unsigned char const   *cptr ) 
{ 
  int exponent ;
  int mantissa ;
  int negative ;
  float fvalue ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double __cil_tmp9 ;
  int __cil_tmp10 ;
  double __cil_tmp11 ;

  {
#line 287
  negative = (int )*(cptr + 3) & 128;
#line 288
  if ((int )*(cptr + 2) & 128) {
#line 288
    tmp = 1;
  } else {
#line 288
    tmp = 0;
  }
#line 288
  exponent = (((int )*(cptr + 3) & 127) << 1) | tmp;
#line 289
  mantissa = ((((int )*(cptr + 2) & 127) << 16) | ((int )*(cptr + 1) << 8)) | (int )*(cptr + 0);
#line 291
  if (! exponent) {
#line 291
    if (! mantissa) {
#line 292
      return ((float )0.);
    }
  }
#line 294
  mantissa |= 8388608;
#line 295
  if (exponent) {
#line 295
    tmp___0 = exponent - 127;
  } else {
#line 295
    tmp___0 = 0;
  }
#line 295
  exponent = tmp___0;
#line 297
  if (mantissa) {
#line 297
    tmp___1 = (double )((float )mantissa / (float )8388608);
  } else {
#line 297
    tmp___1 = 0.;
  }
#line 297
  fvalue = (float )tmp___1;
#line 299
  if (negative) {
#line 300
    fvalue *= (float )-1;
  }
#line 302
  if (exponent > 0) {
    {
#line 303
    __cil_tmp9 = pow(2., (double )exponent);
#line 303
    fvalue = (float )((double )fvalue * __cil_tmp9);
    }
  } else
#line 304
  if (exponent < 0) {
    {
#line 305
    __cil_tmp10 = abs(exponent);
#line 305
    __cil_tmp11 = pow(2., (double )__cil_tmp10);
#line 305
    fvalue = (float )((double )fvalue / __cil_tmp11);
    }
  }
#line 307
  return (fvalue);
}
}
#line 311 "/root/patchweave_new/23/src/float32.c"
void float32_le_write(float in , unsigned char *out ) 
{ 
  int exponent ;
  int mantissa ;
  int negative ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;

  {
  {
#line 312
  negative = 0;
#line 314
  memset((void *)out, 0, sizeof(int ));
#line 316
  __cil_tmp6 = fabs((double )in);
  }
#line 316
  if (__cil_tmp6 < 1.00000000001e-30) {
#line 317
    return;
  }
#line 319
  if ((double )in < 0.) {
#line 320
    in = (float )((double )in * - 1.);
#line 321
    negative = 1;
  }
  {
#line 324
  __cil_tmp7 = frexp((double )in, & exponent);
#line 324
  in = (float )__cil_tmp7;
#line 326
  exponent += 126;
#line 328
  in *= (float )16777216;
#line 329
  mantissa = (int )in & 8388607;
  }
#line 331
  if (negative) {
#line 332
    *(out + 3) = (unsigned char )((int )*(out + 3) | 128);
  }
#line 334
  if (exponent & 1) {
#line 335
    *(out + 2) = (unsigned char )((int )*(out + 2) | 128);
  }
#line 337
  *(out + 0) = (unsigned char )(mantissa & 255);
#line 338
  *(out + 1) = (unsigned char )((mantissa >> 8) & 255);
#line 339
  *(out + 2) = (unsigned char )((int )*(out + 2) | ((mantissa >> 16) & 127));
#line 340
  *(out + 3) = (unsigned char )((int )*(out + 3) | ((exponent >> 1) & 127));
#line 342
  return;
}
}
#line 346 "/root/patchweave_new/23/src/float32.c"
void float32_be_write(float in , unsigned char *out ) 
{ 
  int exponent ;
  int mantissa ;
  int negative ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;

  {
  {
#line 347
  negative = 0;
#line 349
  memset((void *)out, 0, sizeof(int ));
#line 351
  __cil_tmp6 = fabs((double )in);
  }
#line 351
  if (__cil_tmp6 < 1.00000000001e-30) {
#line 352
    return;
  }
#line 354
  if ((double )in < 0.) {
#line 355
    in = (float )((double )in * - 1.);
#line 356
    negative = 1;
  }
  {
#line 359
  __cil_tmp7 = frexp((double )in, & exponent);
#line 359
  in = (float )__cil_tmp7;
#line 361
  exponent += 126;
#line 363
  in *= (float )16777216;
#line 364
  mantissa = (int )in & 8388607;
  }
#line 366
  if (negative) {
#line 367
    *(out + 0) = (unsigned char )((int )*(out + 0) | 128);
  }
#line 369
  if (exponent & 1) {
#line 370
    *(out + 1) = (unsigned char )((int )*(out + 1) | 128);
  }
#line 372
  *(out + 3) = (unsigned char )(mantissa & 255);
#line 373
  *(out + 2) = (unsigned char )((mantissa >> 8) & 255);
#line 374
  *(out + 1) = (unsigned char )((int )*(out + 1) | ((mantissa >> 16) & 127));
#line 375
  *(out + 0) = (unsigned char )((int )*(out + 0) | ((exponent >> 1) & 127));
#line 377
  return;
}
}
#line 385 "/root/patchweave_new/23/src/float32.c"
static void float32_peak_update(SF_PRIVATE *psf , float const   *buffer , int count___0 ,
                                sf_count_t indx ) 
{ 
  int chan ;
  int k ;
  int position ;
  float fmaxval ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;
  double __cil_tmp11 ;

  {
#line 390
  chan = 0;
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;

#line 390
    if (! (chan < psf->sf.channels)) {
#line 390
      goto while_break;
    }
    {
#line 391
    __cil_tmp9 = fabs((double )*(buffer + chan));
#line 391
    fmaxval = (float )__cil_tmp9;
#line 392
    position = 0;
#line 393
    k = chan;
    }
    {
#line 393
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 393
      if (! (k < count___0)) {
#line 393
        goto while_break___0;
      }
      {
#line 394
      __cil_tmp10 = fabs((double )*(buffer + k));
      }
#line 394
      if ((double )fmaxval < __cil_tmp10) {
        {
#line 395
        __cil_tmp11 = fabs((double )*(buffer + k));
#line 395
        fmaxval = (float )__cil_tmp11;
#line 396
        position = k;
        }
      }
#line 393
      k += psf->sf.channels;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 399
    if ((double )fmaxval > (psf->peak_info)->peaks[chan].value) {
#line 400
      (psf->peak_info)->peaks[chan].value = (double )fmaxval;
#line 401
      (psf->peak_info)->peaks[chan].position = (psf->write_current + indx) + (long )(position / psf->sf.channels);
    }
#line 390
    chan ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 405
  return;
}
}
#line 409 "/root/patchweave_new/23/src/float32.c"
static int float32_get_capability(SF_PRIVATE *psf ) 
{ 
  union __anonunion_506 data ;
  int tmp ;

  {
#line 416
  data.f = (float )1.23456789;
#line 418
  if (! psf->ieee_replace) {
#line 420
    if ((int )data.c[0] == 82) {
#line 420
      if ((int )data.c[1] == 6) {
#line 420
        if ((int )data.c[2] == 158) {
#line 420
          if ((int )data.c[3] == 63) {
#line 421
            return (18);
          }
        }
      }
    }
#line 424
    if ((int )data.c[3] == 82) {
#line 424
      if ((int )data.c[2] == 6) {
#line 424
        if ((int )data.c[1] == 158) {
#line 424
          if ((int )data.c[0] == 63) {
#line 425
            return (35);
          }
        }
      }
    }
  }
  {
#line 429
  psf_log_printf(psf, "Using IEEE replacement code for float.\n");
#line 431
  tmp = 52;
  }
#line 431
  return (tmp);
}
}
#line 438 "/root/patchweave_new/23/src/float32.c"
static void f2s_array(float const   *src , int count___0 , short *dest , float scale ) 
{ 
  long __cil_tmp5 ;

  {
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    count___0 --;
#line 440
    if (! (count___0 >= 0)) {
#line 440
      goto while_break;
    }
    {
#line 441
    __cil_tmp5 = lrintf(scale * (float )*(src + count___0));
#line 441
    *(dest + count___0) = (short )__cil_tmp5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 447
  return;
}
}
#line 446 "/root/patchweave_new/23/src/float32.c"
static void f2s_clip_array(float const   *src , int count___0 , short *dest , float scale ) 
{ 
  float tmp ;
  long __cil_tmp6 ;

  {
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    count___0 --;
#line 447
    if (! (count___0 >= 0)) {
#line 447
      goto while_break;
    }
#line 448
    tmp = scale * (float )*(src + count___0);
#line 450
    if ((double )tmp > 32767.) {
#line 451
      *(dest + count___0) = (short)32767;
    } else
#line 452
    if ((double )tmp < - 32768.) {
#line 453
      *(dest + count___0) = (short)-32768;
    } else {
      {
#line 455
      __cil_tmp6 = lrintf(tmp);
#line 455
      *(dest + count___0) = (short )__cil_tmp6;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 462
  return;
}
}
#line 460 "/root/patchweave_new/23/src/float32.c"
__inline static void f2i_array(float const   *src , int count___0 , int *dest , float scale ) 
{ 
  long __cil_tmp5 ;

  {
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    count___0 --;
#line 461
    if (! (count___0 >= 0)) {
#line 461
      goto while_break;
    }
    {
#line 462
    __cil_tmp5 = lrintf(scale * (float )*(src + count___0));
#line 462
    *(dest + count___0) = (int )__cil_tmp5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 468
  return;
}
}
#line 467 "/root/patchweave_new/23/src/float32.c"
__inline static void f2i_clip_array(float const   *src , int count___0 , int *dest ,
                                    float scale ) 
{ 
  float tmp ;
  long __cil_tmp6 ;

  {
  {
#line 468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 468
    count___0 --;
#line 468
    if (! (count___0 >= 0)) {
#line 468
      goto while_break;
    }
#line 469
    tmp = scale * (float )*(src + count___0);
#line 471
    if ((double )tmp > 1. * (double )2147483647) {
#line 472
      *(dest + count___0) = 2147483647;
    } else
#line 473
    if ((double )tmp < - 1. * (double )2147483647) {
#line 474
      *(dest + count___0) = (-0x7FFFFFFF-1);
    } else {
      {
#line 476
      __cil_tmp6 = lrintf(tmp);
#line 476
      *(dest + count___0) = (int )__cil_tmp6;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 483
  return;
}
}
#line 481 "/root/patchweave_new/23/src/float32.c"
__inline static void f2d_array(float const   *src , int count___0 , double *dest ) 
{ 


  {
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 482
    count___0 --;
#line 482
    if (! (count___0 >= 0)) {
#line 482
      goto while_break;
    }
#line 483
    *(dest + count___0) = (double )*(src + count___0);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 488
  return;
}
}
#line 488 "/root/patchweave_new/23/src/float32.c"
__inline static void s2f_array(short const   *src , float *dest , int count___0 ,
                               float scale ) 
{ 


  {
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    count___0 --;
#line 489
    if (! (count___0 >= 0)) {
#line 489
      goto while_break;
    }
#line 490
    *(dest + count___0) = scale * (float )((int )*(src + count___0));
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 495
  return;
}
}
#line 495 "/root/patchweave_new/23/src/float32.c"
__inline static void i2f_array(int const   *src , float *dest , int count___0 , float scale ) 
{ 


  {
  {
#line 496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 496
    count___0 --;
#line 496
    if (! (count___0 >= 0)) {
#line 496
      goto while_break;
    }
#line 497
    *(dest + count___0) = scale * (float )*(src + count___0);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 502
  return;
}
}
#line 502 "/root/patchweave_new/23/src/float32.c"
__inline static void d2f_array(double const   *src , float *dest , int count___0 ) 
{ 


  {
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    count___0 --;
#line 503
    if (! (count___0 >= 0)) {
#line 503
      goto while_break;
    }
#line 504
    *(dest + count___0) = (float )*(src + count___0);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 509
  return;
}
}
#line 512 "/root/patchweave_new/23/src/float32.c"
static sf_count_t host_read_f2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , int  , short * , float  ) ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float scale ;
  void (*tmp)(float const   *src , int count , short *dest , float scale ) ;
  double tmp___0 ;
  sf_count_t __cil_tmp12 ;

  {
#line 516
  total = (sf_count_t )0;
#line 519
  if (psf->add_clipping) {
#line 519
    tmp = & f2s_clip_array;
  } else {
#line 519
    tmp = & f2s_array;
  }
#line 519
  convert = tmp;
#line 520
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
#line 521
  if (psf->float_int_mult == 0) {
#line 521
    tmp___0 = 1.;
  } else {
#line 521
    tmp___0 = (double )((float )32767 / psf->float_max);
  }
#line 521
  scale = (float )tmp___0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;

#line 523
    if (! (len > 0L)) {
#line 523
      goto while_break;
    }
#line 524
    if (len < (long )bufferlen) {
#line 525
      bufferlen = (int )len;
    }
    {
#line 526
    __cil_tmp12 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 526
    readcount = (int )__cil_tmp12;
    }
#line 529
    if (psf->data_endswap == 1) {
      {
#line 530
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 532
    (*convert)((float const   *)(ubuf.fbuf), readcount, ptr + total, scale);
#line 533
    total += (long )readcount;
    }
#line 534
    if (readcount < bufferlen) {
#line 535
      goto while_break;
    }
#line 536
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 539
  return (total);
}
}
#line 543 "/root/patchweave_new/23/src/float32.c"
static sf_count_t host_read_f2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , int  , int * , float  ) ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float scale ;
  void (*tmp)(float const   *src , int count , int *dest , float scale ) ;
  double tmp___0 ;
  sf_count_t __cil_tmp12 ;

  {
#line 547
  total = (sf_count_t )0;
#line 550
  if (psf->add_clipping) {
#line 550
    tmp = & f2i_clip_array;
  } else {
#line 550
    tmp = & f2i_array;
  }
#line 550
  convert = tmp;
#line 551
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
#line 552
  if (psf->float_int_mult == 0) {
#line 552
    tmp___0 = 1.;
  } else {
#line 552
    tmp___0 = (double )((float )2147483647 / psf->float_max);
  }
#line 552
  scale = (float )tmp___0;
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;

#line 554
    if (! (len > 0L)) {
#line 554
      goto while_break;
    }
#line 555
    if (len < (long )bufferlen) {
#line 556
      bufferlen = (int )len;
    }
    {
#line 557
    __cil_tmp12 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 557
    readcount = (int )__cil_tmp12;
    }
#line 559
    if (psf->data_endswap == 1) {
      {
#line 560
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 562
    (*convert)((float const   *)(ubuf.fbuf), readcount, ptr + total, scale);
#line 563
    total += (long )readcount;
    }
#line 564
    if (readcount < bufferlen) {
#line 565
      goto while_break;
    }
#line 566
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 569
  return (total);
}
}
#line 573 "/root/patchweave_new/23/src/float32.c"
static sf_count_t host_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 576
  total = (sf_count_t )0;
#line 578
  if (psf->data_endswap != 1) {
    {
#line 579
    __cil_tmp8 = psf_fread((void *)ptr, (sf_count_t )sizeof(float ), len, psf);
    }
#line 579
    return (__cil_tmp8);
  }
#line 581
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;

#line 583
    if (! (len > 0L)) {
#line 583
      goto while_break;
    }
#line 584
    if (len < (long )bufferlen) {
#line 585
      bufferlen = (int )len;
    }
    {
#line 586
    __cil_tmp9 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                           psf);
#line 586
    readcount = (int )__cil_tmp9;
#line 588
    endswap_int_copy((int *)(ptr + total), (int const   *)(ubuf.ibuf), readcount);
#line 590
    total += (long )readcount;
    }
#line 591
    if (readcount < bufferlen) {
#line 592
      goto while_break;
    }
#line 593
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 596
  return (total);
}
}
#line 600 "/root/patchweave_new/23/src/float32.c"
static sf_count_t host_read_f2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 603
  total = (sf_count_t )0;
#line 605
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;

#line 607
    if (! (len > 0L)) {
#line 607
      goto while_break;
    }
#line 608
    if (len < (long )bufferlen) {
#line 609
      bufferlen = (int )len;
    }
    {
#line 610
    __cil_tmp8 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                           psf);
#line 610
    readcount = (int )__cil_tmp8;
    }
#line 612
    if (psf->data_endswap == 1) {
      {
#line 613
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 616
    f2d_array((float const   *)(ubuf.fbuf), readcount, ptr + total);
#line 617
    total += (long )readcount;
    }
#line 618
    if (readcount < bufferlen) {
#line 619
      goto while_break;
    }
#line 620
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 623
  return (total);
}
}
#line 627 "/root/patchweave_new/23/src/float32.c"
static sf_count_t host_write_s2f(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 630
  total = (sf_count_t )0;
#line 634
  if (psf->scale_int_float == 0) {
#line 634
    tmp = 1.;
  } else {
#line 634
    tmp = 1. / (double )32768;
  }
#line 634
  scale = (float )tmp;
#line 635
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;

#line 637
    if (! (len > 0L)) {
#line 637
      goto while_break;
    }
#line 638
    if (len < (long )bufferlen) {
#line 639
      bufferlen = (int )len;
    }
    {
#line 640
    s2f_array(ptr + total, ubuf.fbuf, bufferlen, scale);
    }
#line 642
    if (psf->peak_info) {
      {
#line 643
      float32_peak_update(psf, (float const   *)(ubuf.fbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
#line 645
    if (psf->data_endswap == 1) {
      {
#line 646
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 648
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                             (sf_count_t )bufferlen, psf);
#line 648
    writecount = (int )__cil_tmp10;
#line 649
    total += (long )writecount;
    }
#line 650
    if (writecount < bufferlen) {
#line 651
      goto while_break;
    }
#line 652
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 655
  return (total);
}
}
#line 659 "/root/patchweave_new/23/src/float32.c"
static sf_count_t host_write_i2f(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 662
  total = (sf_count_t )0;
#line 665
  if (psf->scale_int_float == 0) {
#line 665
    tmp = 1.;
  } else {
#line 665
    tmp = 1. / (8. * (double )268435456);
  }
#line 665
  scale = (float )tmp;
#line 666
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 668
  while (1) {
    while_continue: /* CIL Label */ ;

#line 668
    if (! (len > 0L)) {
#line 668
      goto while_break;
    }
#line 669
    if (len < (long )bufferlen) {
#line 670
      bufferlen = (int )len;
    }
    {
#line 671
    i2f_array(ptr + total, ubuf.fbuf, bufferlen, scale);
    }
#line 673
    if (psf->peak_info) {
      {
#line 674
      float32_peak_update(psf, (float const   *)(ubuf.fbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
#line 676
    if (psf->data_endswap == 1) {
      {
#line 677
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 679
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                             (sf_count_t )bufferlen, psf);
#line 679
    writecount = (int )__cil_tmp10;
#line 680
    total += (long )writecount;
    }
#line 681
    if (writecount < bufferlen) {
#line 682
      goto while_break;
    }
#line 683
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 686
  return (total);
}
}
#line 690 "/root/patchweave_new/23/src/float32.c"
static sf_count_t host_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 693
  total = (sf_count_t )0;
#line 695
  if (psf->peak_info) {
    {
#line 696
    float32_peak_update(psf, ptr, (int )len, (sf_count_t )0);
    }
  }
#line 698
  if (psf->data_endswap != 1) {
    {
#line 699
    __cil_tmp8 = psf_fwrite((void const   *)ptr, (sf_count_t )sizeof(float ), len,
                            psf);
    }
#line 699
    return (__cil_tmp8);
  }
#line 701
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;

#line 703
    if (! (len > 0L)) {
#line 703
      goto while_break;
    }
#line 704
    if (len < (long )bufferlen) {
#line 705
      bufferlen = (int )len;
    }
    {
#line 707
    endswap_int_copy(ubuf.ibuf, (int const   *)(ptr + total), bufferlen);
#line 709
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                            (sf_count_t )bufferlen, psf);
#line 709
    writecount = (int )__cil_tmp9;
#line 710
    total += (long )writecount;
    }
#line 711
    if (writecount < bufferlen) {
#line 712
      goto while_break;
    }
#line 713
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 716
  return (total);
}
}
#line 720 "/root/patchweave_new/23/src/float32.c"
static sf_count_t host_write_d2f(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 723
  total = (sf_count_t )0;
#line 725
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 727
  while (1) {
    while_continue: /* CIL Label */ ;

#line 727
    if (! (len > 0L)) {
#line 727
      goto while_break;
    }
#line 728
    if (len < (long )bufferlen) {
#line 729
      bufferlen = (int )len;
    }
    {
#line 731
    d2f_array(ptr + total, ubuf.fbuf, bufferlen);
    }
#line 733
    if (psf->peak_info) {
      {
#line 734
      float32_peak_update(psf, (float const   *)(ubuf.fbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
#line 736
    if (psf->data_endswap == 1) {
      {
#line 737
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 739
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                            (sf_count_t )bufferlen, psf);
#line 739
    writecount = (int )__cil_tmp8;
#line 740
    total += (long )writecount;
    }
#line 741
    if (writecount < bufferlen) {
#line 742
      goto while_break;
    }
#line 743
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 746
  return (total);
}
}
#line 753 "/root/patchweave_new/23/src/float32.c"
static sf_count_t replace_read_f2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 756
  total = (sf_count_t )0;
#line 759
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
#line 760
  if (psf->float_int_mult == 0) {
#line 760
    tmp = 1.;
  } else {
#line 760
    tmp = (double )((float )32767 / psf->float_max);
  }
#line 760
  scale = (float )tmp;
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;

#line 762
    if (! (len > 0L)) {
#line 762
      goto while_break;
    }
#line 763
    if (len < (long )bufferlen) {
#line 764
      bufferlen = (int )len;
    }
    {
#line 765
    __cil_tmp10 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 765
    readcount = (int )__cil_tmp10;
    }
#line 767
    if (psf->data_endswap == 1) {
      {
#line 768
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 770
    bf2f_array(ubuf.fbuf, bufferlen);
#line 772
    f2s_array((float const   *)(ubuf.fbuf), readcount, ptr + total, scale);
#line 773
    total += (long )readcount;
    }
#line 774
    if (readcount < bufferlen) {
#line 775
      goto while_break;
    }
#line 776
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 779
  return (total);
}
}
#line 783 "/root/patchweave_new/23/src/float32.c"
static sf_count_t replace_read_f2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 786
  total = (sf_count_t )0;
#line 789
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
#line 790
  if (psf->float_int_mult == 0) {
#line 790
    tmp = 1.;
  } else {
#line 790
    tmp = (double )((float )32767 / psf->float_max);
  }
#line 790
  scale = (float )tmp;
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;

#line 792
    if (! (len > 0L)) {
#line 792
      goto while_break;
    }
#line 793
    if (len < (long )bufferlen) {
#line 794
      bufferlen = (int )len;
    }
    {
#line 795
    __cil_tmp10 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 795
    readcount = (int )__cil_tmp10;
    }
#line 797
    if (psf->data_endswap == 1) {
      {
#line 798
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 800
    bf2f_array(ubuf.fbuf, bufferlen);
#line 802
    f2i_array((float const   *)(ubuf.fbuf), readcount, ptr + total, scale);
#line 803
    total += (long )readcount;
    }
#line 804
    if (readcount < bufferlen) {
#line 805
      goto while_break;
    }
#line 806
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 809
  return (total);
}
}
#line 813 "/root/patchweave_new/23/src/float32.c"
static sf_count_t replace_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 816
  total = (sf_count_t )0;
#line 820
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 822
  while (1) {
    while_continue: /* CIL Label */ ;

#line 822
    if (! (len > 0L)) {
#line 822
      goto while_break;
    }
#line 823
    if (len < (long )bufferlen) {
#line 824
      bufferlen = (int )len;
    }
    {
#line 825
    __cil_tmp8 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                           psf);
#line 825
    readcount = (int )__cil_tmp8;
    }
#line 827
    if (psf->data_endswap == 1) {
      {
#line 828
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 830
    bf2f_array(ubuf.fbuf, bufferlen);
#line 832
    memcpy((void *)(ptr + total), (void const   *)(ubuf.fbuf), (unsigned long )bufferlen * sizeof(float ));
#line 834
    total += (long )readcount;
    }
#line 835
    if (readcount < bufferlen) {
#line 836
      goto while_break;
    }
#line 837
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 840
  return (total);
}
}
#line 844 "/root/patchweave_new/23/src/float32.c"
static sf_count_t replace_read_f2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 847
  total = (sf_count_t )0;
#line 849
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;

#line 851
    if (! (len > 0L)) {
#line 851
      goto while_break;
    }
#line 852
    if (len < (long )bufferlen) {
#line 853
      bufferlen = (int )len;
    }
    {
#line 854
    __cil_tmp8 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                           psf);
#line 854
    readcount = (int )__cil_tmp8;
    }
#line 856
    if (psf->data_endswap == 1) {
      {
#line 857
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 859
    bf2f_array(ubuf.fbuf, bufferlen);
#line 861
    f2d_array((float const   *)(ubuf.fbuf), readcount, ptr + total);
#line 862
    total += (long )readcount;
    }
#line 863
    if (readcount < bufferlen) {
#line 864
      goto while_break;
    }
#line 865
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 868
  return (total);
}
}
#line 872 "/root/patchweave_new/23/src/float32.c"
static sf_count_t replace_write_s2f(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 875
  total = (sf_count_t )0;
#line 878
  if (psf->scale_int_float == 0) {
#line 878
    tmp = 1.;
  } else {
#line 878
    tmp = 1. / (double )32768;
  }
#line 878
  scale = (float )tmp;
#line 879
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 881
  while (1) {
    while_continue: /* CIL Label */ ;

#line 881
    if (! (len > 0L)) {
#line 881
      goto while_break;
    }
#line 882
    if (len < (long )bufferlen) {
#line 883
      bufferlen = (int )len;
    }
    {
#line 884
    s2f_array(ptr + total, ubuf.fbuf, bufferlen, scale);
    }
#line 886
    if (psf->peak_info) {
      {
#line 887
      float32_peak_update(psf, (float const   *)(ubuf.fbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
    {
#line 889
    f2bf_array(ubuf.fbuf, bufferlen);
    }
#line 891
    if (psf->data_endswap == 1) {
      {
#line 892
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 894
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                             (sf_count_t )bufferlen, psf);
#line 894
    writecount = (int )__cil_tmp10;
#line 895
    total += (long )writecount;
    }
#line 896
    if (writecount < bufferlen) {
#line 897
      goto while_break;
    }
#line 898
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 901
  return (total);
}
}
#line 905 "/root/patchweave_new/23/src/float32.c"
static sf_count_t replace_write_i2f(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 908
  total = (sf_count_t )0;
#line 911
  if (psf->scale_int_float == 0) {
#line 911
    tmp = 1.;
  } else {
#line 911
    tmp = 1. / (8. * (double )268435456);
  }
#line 911
  scale = (float )tmp;
#line 912
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 914
  while (1) {
    while_continue: /* CIL Label */ ;

#line 914
    if (! (len > 0L)) {
#line 914
      goto while_break;
    }
#line 915
    if (len < (long )bufferlen) {
#line 916
      bufferlen = (int )len;
    }
    {
#line 917
    i2f_array(ptr + total, ubuf.fbuf, bufferlen, scale);
    }
#line 919
    if (psf->peak_info) {
      {
#line 920
      float32_peak_update(psf, (float const   *)(ubuf.fbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
    {
#line 922
    f2bf_array(ubuf.fbuf, bufferlen);
    }
#line 924
    if (psf->data_endswap == 1) {
      {
#line 925
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 927
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                             (sf_count_t )bufferlen, psf);
#line 927
    writecount = (int )__cil_tmp10;
#line 928
    total += (long )writecount;
    }
#line 929
    if (writecount < bufferlen) {
#line 930
      goto while_break;
    }
#line 931
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 934
  return (total);
}
}
#line 938 "/root/patchweave_new/23/src/float32.c"
static sf_count_t replace_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 941
  total = (sf_count_t )0;
#line 944
  if (psf->peak_info) {
    {
#line 945
    float32_peak_update(psf, ptr, (int )len, (sf_count_t )0);
    }
  }
#line 947
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 949
  while (1) {
    while_continue: /* CIL Label */ ;

#line 949
    if (! (len > 0L)) {
#line 949
      goto while_break;
    }
#line 950
    if (len < (long )bufferlen) {
#line 951
      bufferlen = (int )len;
    }
    {
#line 953
    memcpy((void *)(ubuf.fbuf), (void const   *)(ptr + total), (unsigned long )bufferlen * sizeof(float ));
#line 955
    f2bf_array(ubuf.fbuf, bufferlen);
    }
#line 957
    if (psf->data_endswap == 1) {
      {
#line 958
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 960
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                            (sf_count_t )bufferlen, psf);
#line 960
    writecount = (int )__cil_tmp8;
#line 961
    total += (long )writecount;
    }
#line 962
    if (writecount < bufferlen) {
#line 963
      goto while_break;
    }
#line 964
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 967
  return (total);
}
}
#line 971 "/root/patchweave_new/23/src/float32.c"
static sf_count_t replace_write_d2f(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 974
  total = (sf_count_t )0;
#line 976
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 978
  while (1) {
    while_continue: /* CIL Label */ ;

#line 978
    if (! (len > 0L)) {
#line 978
      goto while_break;
    }
#line 979
    if (len < (long )bufferlen) {
#line 980
      bufferlen = (int )len;
    }
    {
#line 981
    d2f_array(ptr + total, ubuf.fbuf, bufferlen);
    }
#line 983
    if (psf->peak_info) {
      {
#line 984
      float32_peak_update(psf, (float const   *)(ubuf.fbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
    {
#line 986
    f2bf_array(ubuf.fbuf, bufferlen);
    }
#line 988
    if (psf->data_endswap == 1) {
      {
#line 989
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 991
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                            (sf_count_t )bufferlen, psf);
#line 991
    writecount = (int )__cil_tmp8;
#line 992
    total += (long )writecount;
    }
#line 993
    if (writecount < bufferlen) {
#line 994
      goto while_break;
    }
#line 995
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 998
  return (total);
}
}
#line 1005 "/root/patchweave_new/23/src/float32.c"
static void bf2f_array(float *buffer , int count___0 ) 
{ 


  {
  {
#line 1006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1006
    count___0 --;
#line 1006
    if (! (count___0 >= 0)) {
#line 1006
      goto while_break;
    }
    {
#line 1007
    *(buffer + count___0) = float32_le_read((unsigned char const   *)((unsigned char *)(buffer + count___0)));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1013
  return;
}
}
#line 1012 "/root/patchweave_new/23/src/float32.c"
static void f2bf_array(float *buffer , int count___0 ) 
{ 


  {
  {
#line 1013
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1013
    count___0 --;
#line 1013
    if (! (count___0 >= 0)) {
#line 1013
      goto while_break;
    }
    {
#line 1014
    float32_le_write(*(buffer + count___0), (unsigned char *)(buffer + count___0));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1020
  return;
}
}
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) stat)(char const   *__path ,
                                                                                          struct stat *__statbuf ) ;
#line 210
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
#line 224
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) stat64)(char const   *__path ,
                                                                                            struct stat64 *__statbuf ) ;
#line 226
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstat64)(int __fd ,
                                                                                             struct stat64 *__statbuf ) ;
#line 234
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstatat)(int __fd ,
                                                                                             char const   *__filename ,
                                                                                             struct stat *__statbuf ,
                                                                                             int __flag ) ;
#line 249
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstatat64)(int __fd ,
                                                                                               char const   *__filename ,
                                                                                               struct stat64 *__statbuf ,
                                                                                               int __flag ) ;
#line 259
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) lstat)(char const   *__path ,
                                                                                           struct stat *__statbuf ) ;
#line 272
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) lstat64)(char const   *__path ,
                                                                                             struct stat64 *__statbuf ) ;
#line 332
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
#line 339
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknodat)(int __fd ,
                                                                                             char const   *__path ,
                                                                                             __mode_t __mode ,
                                                                                             __dev_t __dev ) ;
#line 395
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
#line 397
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf ) ;
#line 399
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf ) ;
#line 401
extern  __attribute__((__nothrow__)) int __fxstatat(int __ver , int __fildes , char const   *__filename ,
                                                    struct stat *__stat_buf , int __flag ) ;
#line 428
extern  __attribute__((__nothrow__)) int __fxstat64(int __ver , int __fildes , struct stat64 *__stat_buf ) ;
#line 430
extern  __attribute__((__nothrow__)) int __xstat64(int __ver , char const   *__filename ,
                                                   struct stat64 *__stat_buf ) ;
#line 432
extern  __attribute__((__nothrow__)) int __lxstat64(int __ver , char const   *__filename ,
                                                    struct stat64 *__stat_buf ) ;
#line 434
extern  __attribute__((__nothrow__)) int __fxstatat64(int __ver , int __fildes , char const   *__filename ,
                                                      struct stat64 *__stat_buf ,
                                                      int __flag ) ;
#line 438
extern  __attribute__((__nothrow__)) int __xmknod(int __ver , char const   *__path ,
                                                  __mode_t __mode , __dev_t *__dev ) ;
#line 441
extern  __attribute__((__nothrow__)) int __xmknodat(int __ver , int __fd , char const   *__path ,
                                                    __mode_t __mode , __dev_t *__dev ) ;
#line 453
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) stat)(char const   *__path ,
                                                                                          struct stat *__statbuf ) ;
#line 453 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) stat)(char const   *__path ,
                                                            struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = __xstat(1, __path, __statbuf);
  }
#line 455
  return (__cil_tmp3);
}
}
#line 460
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) lstat)(char const   *__path ,
                                                                                           struct stat *__statbuf ) ;
#line 460 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) lstat)(char const   *__path ,
                                                             struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 462
  __cil_tmp3 = __lxstat(1, __path, __statbuf);
  }
#line 462
  return (__cil_tmp3);
}
}
#line 467
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
#line 467 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 469
  __cil_tmp3 = __fxstat(1, __fd, __statbuf);
  }
#line 469
  return (__cil_tmp3);
}
}
#line 474
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstatat)(int __fd ,
                                                                                             char const   *__filename ,
                                                                                             struct stat *__statbuf ,
                                                                                             int __flag ) ;
#line 474 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) fstatat)(int __fd , char const   *__filename ,
                                                               struct stat *__statbuf ,
                                                               int __flag ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 477
  __cil_tmp5 = __fxstatat(1, __fd, __filename, __statbuf, __flag);
  }
#line 477
  return (__cil_tmp5);
}
}
#line 483
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
#line 483 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) mknod)(char const   *__path ,
                                                             __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 485
  __cil_tmp4 = __xmknod(0, __path, __mode, & __dev);
  }
#line 485
  return (__cil_tmp4);
}
}
#line 491
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknodat)(int __fd ,
                                                                                             char const   *__path ,
                                                                                             __mode_t __mode ,
                                                                                             __dev_t __dev ) ;
#line 491 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) mknodat)(int __fd , char const   *__path ,
                                                               __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 494
  __cil_tmp5 = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
#line 494
  return (__cil_tmp5);
}
}
#line 502
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) stat64)(char const   *__path ,
                                                                                            struct stat64 *__statbuf ) ;
#line 502 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) stat64)(char const   *__path ,
                                                              struct stat64 *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 504
  __cil_tmp3 = __xstat64(1, __path, __statbuf);
  }
#line 504
  return (__cil_tmp3);
}
}
#line 509
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) lstat64)(char const   *__path ,
                                                                                             struct stat64 *__statbuf ) ;
#line 509 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) lstat64)(char const   *__path ,
                                                               struct stat64 *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 511
  __cil_tmp3 = __lxstat64(1, __path, __statbuf);
  }
#line 511
  return (__cil_tmp3);
}
}
#line 516
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstat64)(int __fd ,
                                                                                             struct stat64 *__statbuf ) ;
#line 516 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 518
  __cil_tmp3 = __fxstat64(1, __fd, __statbuf);
  }
#line 518
  return (__cil_tmp3);
}
}
#line 523
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstatat64)(int __fd ,
                                                                                               char const   *__filename ,
                                                                                               struct stat64 *__statbuf ,
                                                                                               int __flag ) ;
#line 523 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) fstatat64)(int __fd , char const   *__filename ,
                                                                 struct stat64 *__statbuf ,
                                                                 int __flag ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 526
  __cil_tmp5 = __fxstatat64(1, __fd, __filename, __statbuf, __flag);
  }
#line 526
  return (__cil_tmp5);
}
}
#line 67 "/root/patchweave_new/23/src/file_io.c"
static void psf_log_syserr(SF_PRIVATE *psf , int error ) ;
#line 75
static int psf_close_fd(int fd ) ;
#line 76
static int psf_open_fd(PSF_FILE *pfile ) ;
#line 77
static sf_count_t psf_get_filelen_fd(int fd ) ;
#line 80 "/root/patchweave_new/23/src/file_io.c"
int psf_fopen(SF_PRIVATE *psf ) 
{ 
  int *__cil_tmp3 ;

  {
  {
#line 82
  psf->error = 0;
#line 83
  psf->file.filedes = psf_open_fd(& psf->file);
  }
#line 85
  if (psf->file.filedes == -45) {
#line 86
    psf->error = 45;
#line 87
    psf->file.filedes = -1;
#line 88
    return (psf->error);
  }
#line 91
  if (psf->file.filedes == -1) {
    {
#line 92
    __cil_tmp3 = __errno_location();
#line 92
    psf_log_syserr(psf, *__cil_tmp3);
    }
  }
#line 94
  return (psf->error);
}
}
#line 98 "/root/patchweave_new/23/src/file_io.c"
int psf_fclose(SF_PRIVATE *psf ) 
{ 
  int retval ;
  int *__cil_tmp4 ;

  {
#line 101
  if (psf->virtual_io) {
#line 102
    return (0);
  }
#line 104
  if (psf->file.do_not_close_descriptor) {
#line 105
    psf->file.filedes = -1;
#line 106
    return (0);
  }
  {
#line 109
  retval = psf_close_fd(psf->file.filedes);
  }
#line 109
  if (retval == -1) {
    {
#line 110
    __cil_tmp4 = __errno_location();
#line 110
    psf_log_syserr(psf, *__cil_tmp4);
    }
  }
#line 112
  psf->file.filedes = -1;
#line 114
  return (retval);
}
}
#line 118 "/root/patchweave_new/23/src/file_io.c"
int psf_open_rsrc(SF_PRIVATE *psf ) 
{ 
  int *__cil_tmp8 ;

  {
#line 120
  if (psf->rsrc.filedes > 0) {
#line 121
    return (0);
  }
  {
#line 124
  snprintf(psf->rsrc.path.c, sizeof(psf->rsrc.path.c), "%s/..namedfork/rsrc", psf->file.path.c);
#line 125
  psf->error = 0;
#line 126
  psf->rsrc.filedes = psf_open_fd(& psf->rsrc);
  }
#line 126
  if (psf->rsrc.filedes >= 0) {
    {
#line 127
    psf->rsrclength = psf_get_filelen_fd(psf->rsrc.filedes);
    }
#line 128
    if (psf->rsrclength > 0L) {
#line 129
      return (0);
    } else
#line 128
    if (psf->rsrc.mode & 32) {
#line 129
      return (0);
    }
    {
#line 130
    psf_close_fd(psf->rsrc.filedes);
#line 131
    psf->rsrc.filedes = -1;
    }
  }
#line 134
  if (psf->rsrc.filedes == -45) {
#line 135
    psf->error = 45;
#line 136
    return (psf->error);
  }
  {
#line 143
  snprintf(psf->rsrc.path.c, sizeof(psf->rsrc.path.c), "%s._%s", psf->file.dir.c,
           psf->file.name.c);
#line 144
  psf->error = 0;
#line 145
  psf->rsrc.filedes = psf_open_fd(& psf->rsrc);
  }
#line 145
  if (psf->rsrc.filedes >= 0) {
    {
#line 146
    psf->rsrclength = psf_get_filelen_fd(psf->rsrc.filedes);
    }
#line 147
    return (0);
  }
  {
#line 154
  snprintf(psf->rsrc.path.c, sizeof(psf->rsrc.path.c), "%s.AppleDouble/%s", psf->file.dir.c,
           psf->file.name.c);
#line 155
  psf->error = 0;
#line 156
  psf->rsrc.filedes = psf_open_fd(& psf->rsrc);
  }
#line 156
  if (psf->rsrc.filedes >= 0) {
    {
#line 157
    psf->rsrclength = psf_get_filelen_fd(psf->rsrc.filedes);
    }
#line 158
    return (0);
  }
#line 162
  if (psf->rsrc.filedes == -1) {
    {
#line 163
    __cil_tmp8 = __errno_location();
#line 163
    psf_log_syserr(psf, *__cil_tmp8);
    }
  }
#line 165
  psf->rsrc.filedes = -1;
#line 167
  return (psf->error);
}
}
#line 171 "/root/patchweave_new/23/src/file_io.c"
sf_count_t psf_get_filelen(SF_PRIVATE *psf ) 
{ 
  sf_count_t filelen ;
  sf_count_t __cil_tmp3 ;
  int *__cil_tmp5 ;

  {
#line 174
  if (psf->virtual_io) {
    {
#line 175
    __cil_tmp3 = (*(psf->vio.get_filelen))(psf->vio_user_data);
    }
#line 175
    return (__cil_tmp3);
  }
  {
#line 177
  filelen = psf_get_filelen_fd(psf->file.filedes);
  }
#line 179
  if (filelen == -1L) {
    {
#line 180
    __cil_tmp5 = __errno_location();
#line 180
    psf_log_syserr(psf, *__cil_tmp5);
    }
#line 181
    return ((sf_count_t )-1);
  }
#line 184
  if (filelen == -15L) {
#line 185
    psf->error = 15;
#line 186
    return ((sf_count_t )-1);
  }
#line 190
  if (psf->file.mode == 32) {
#line 190
    goto case_32;
  }
#line 194
  if (psf->file.mode == 16) {
#line 194
    goto case_16;
  }
#line 199
  if (psf->file.mode == 48) {
#line 199
    goto case_48;
  }
#line 207
  goto switch_default;
  case_32: 
#line 191
  filelen -= psf->fileoffset;
#line 192
  goto switch_break;
  case_16: 
#line 195
  if (psf->fileoffset > 0L) {
#line 195
    if (psf->filelength > 0L) {
#line 196
      filelen = psf->filelength;
    }
  }
#line 197
  goto switch_break;
  case_48: 
#line 205
  goto switch_break;
  switch_default: 
#line 209
  filelen = (sf_count_t )-1;
  switch_break: ;
#line 212
  return (filelen);
}
}
#line 216 "/root/patchweave_new/23/src/file_io.c"
int psf_close_rsrc(SF_PRIVATE *psf ) 
{ 


  {
  {
#line 217
  psf_close_fd(psf->rsrc.filedes);
#line 218
  psf->rsrc.filedes = -1;
  }
#line 219
  return (0);
}
}
#line 223 "/root/patchweave_new/23/src/file_io.c"
int psf_set_stdio(SF_PRIVATE *psf ) 
{ 
  int error ;

  {
#line 224
  error = 0;
#line 227
  if (psf->file.mode == 48) {
#line 227
    goto case_48;
  }
#line 231
  if (psf->file.mode == 16) {
#line 231
    goto case_16;
  }
#line 235
  if (psf->file.mode == 32) {
#line 235
    goto case_32;
  }
#line 239
  goto switch_default;
  case_48: 
#line 228
  error = 46;
#line 229
  goto switch_break;
  case_16: 
#line 232
  psf->file.filedes = 0;
#line 233
  goto switch_break;
  case_32: 
#line 236
  psf->file.filedes = 1;
#line 237
  goto switch_break;
  switch_default: 
#line 240
  error = 45;
#line 241
  goto switch_break;
  switch_break: 
#line 243
  psf->filelength = (sf_count_t )0;
#line 245
  return (error);
}
}
#line 249 "/root/patchweave_new/23/src/file_io.c"
void psf_set_file(SF_PRIVATE *psf , int fd ) 
{ 


  {
#line 250
  psf->file.filedes = fd;
#line 251
  return;
}
}
#line 254 "/root/patchweave_new/23/src/file_io.c"
int psf_file_valid(SF_PRIVATE *psf ) 
{ 
  int tmp ;

  {
#line 255
  if (psf->file.filedes >= 0) {
#line 255
    tmp = 1;
  } else {
#line 255
    tmp = 0;
  }
#line 255
  return (tmp);
}
}
#line 259 "/root/patchweave_new/23/src/file_io.c"
sf_count_t psf_fseek(SF_PRIVATE *psf , sf_count_t offset , int whence ) 
{ 
  sf_count_t current_pos ;
  sf_count_t new_position ;
  sf_count_t __cil_tmp6 ;
  int *__cil_tmp9 ;
  __off_t __cil_tmp10 ;
  int *__cil_tmp12 ;

  {
#line 262
  if (psf->virtual_io) {
    {
#line 263
    __cil_tmp6 = (*(psf->vio.seek))(offset, whence, psf->vio_user_data);
    }
#line 263
    return (__cil_tmp6);
  }
  {
#line 265
  current_pos = psf_ftell(psf);
  }
#line 268
  if (whence == 0) {
#line 268
    goto case_0;
  }
#line 272
  if (whence == 2) {
#line 272
    goto case_2;
  }
#line 290
  if (whence == 1) {
#line 290
    goto case_1;
  }
#line 296
  goto switch_default;
  case_0: 
#line 269
  offset += psf->fileoffset;
#line 270
  goto switch_break;
  case_2: 
#line 273
  if (psf->file.mode == 32) {
    {
#line 274
    new_position = lseek(psf->file.filedes, offset, whence);
    }
#line 276
    if (new_position < 0L) {
      {
#line 277
      __cil_tmp9 = __errno_location();
#line 277
      psf_log_syserr(psf, *__cil_tmp9);
      }
    }
#line 279
    return (new_position - psf->fileoffset);
  }
  {
#line 286
  whence = 0;
#line 287
  __cil_tmp10 = lseek(psf->file.filedes, (__off_t )0, 2);
#line 287
  offset = __cil_tmp10 + offset;
  }
#line 288
  goto switch_break;
  case_1: 
#line 292
  offset += current_pos;
#line 293
  whence = 0;
#line 294
  goto switch_break;
  switch_default: 
  {
#line 298
  psf_log_printf(psf, "psf_fseek : whence is %d *****.\n\230\001", whence);
  }
#line 299
  return ((sf_count_t )0);
  switch_break: ;
#line 302
  if (current_pos != offset) {
    {
#line 303
    new_position = lseek(psf->file.filedes, offset, whence);
    }
  } else {
#line 305
    new_position = offset;
  }
#line 307
  if (new_position < 0L) {
    {
#line 308
    __cil_tmp12 = __errno_location();
#line 308
    psf_log_syserr(psf, *__cil_tmp12);
    }
  }
#line 310
  new_position -= psf->fileoffset;
#line 312
  return (new_position);
}
}
#line 316 "/root/patchweave_new/23/src/file_io.c"
sf_count_t psf_fread(void *ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE *psf ) 
{ 
  sf_count_t total ;
  intptr_t count___0 ;
  sf_count_t __cil_tmp7 ;
  long tmp ;
  int *__cil_tmp10 ;
  int *__cil_tmp11 ;

  {
#line 317
  total = (sf_count_t )0;
#line 320
  if (psf->virtual_io) {
    {
#line 321
    __cil_tmp7 = (*(psf->vio.read))(ptr, bytes * items, psf->vio_user_data);
    }
#line 321
    return (__cil_tmp7 / bytes);
  }
#line 323
  items *= bytes;
#line 326
  if (items <= 0L) {
#line 327
    return ((sf_count_t )0);
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 329
    if (! (items > 0L)) {
#line 329
      goto while_break;
    }
#line 331
    if (items > 1073741824L) {
#line 331
      tmp = 1073741824L;
    } else {
#line 331
      tmp = items;
    }
    {
#line 331
    count___0 = tmp;
#line 333
    count___0 = read(psf->file.filedes, (void *)((char *)ptr + total), (size_t )count___0);
    }
#line 335
    if (count___0 == -1L) {
      {
#line 336
      __cil_tmp10 = __errno_location();
      }
#line 336
      if (*__cil_tmp10 == 4) {
#line 337
        goto while_continue;
      }
      {
#line 339
      __cil_tmp11 = __errno_location();
#line 339
      psf_log_syserr(psf, *__cil_tmp11);
      }
#line 340
      goto while_break;
    }
#line 343
    if (count___0 == 0L) {
#line 344
      goto while_break;
    }
#line 346
    total += count___0;
#line 347
    items -= count___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 350
  if (psf->is_pipe) {
#line 351
    psf->pipeoffset += total;
  }
#line 353
  return (total / bytes);
}
}
#line 357 "/root/patchweave_new/23/src/file_io.c"
sf_count_t psf_fwrite(void const   *ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE *psf ) 
{ 
  sf_count_t total ;
  intptr_t count___0 ;
  sf_count_t __cil_tmp7 ;
  long tmp ;
  int *__cil_tmp10 ;
  int *__cil_tmp11 ;

  {
#line 358
  total = (sf_count_t )0;
#line 361
  if (bytes == 0L) {
#line 362
    return ((sf_count_t )0);
  } else
#line 361
  if (items == 0L) {
#line 362
    return ((sf_count_t )0);
  }
#line 364
  if (psf->virtual_io) {
    {
#line 365
    __cil_tmp7 = (*(psf->vio.write))(ptr, bytes * items, psf->vio_user_data);
    }
#line 365
    return (__cil_tmp7 / bytes);
  }
#line 367
  items *= bytes;
#line 370
  if (items <= 0L) {
#line 371
    return ((sf_count_t )0);
  }
  {
#line 373
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 373
    if (! (items > 0L)) {
#line 373
      goto while_break;
    }
#line 375
    if (items > 1073741824L) {
#line 375
      tmp = 1073741824L;
    } else {
#line 375
      tmp = items;
    }
    {
#line 375
    count___0 = tmp;
#line 377
    count___0 = write(psf->file.filedes, (void const   *)((char const   *)ptr + total),
                      (size_t )count___0);
    }
#line 379
    if (count___0 == -1L) {
      {
#line 380
      __cil_tmp10 = __errno_location();
      }
#line 380
      if (*__cil_tmp10 == 4) {
#line 381
        goto while_continue;
      }
      {
#line 383
      __cil_tmp11 = __errno_location();
#line 383
      psf_log_syserr(psf, *__cil_tmp11);
      }
#line 384
      goto while_break;
    }
#line 387
    if (count___0 == 0L) {
#line 388
      goto while_break;
    }
#line 390
    total += count___0;
#line 391
    items -= count___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 394
  if (psf->is_pipe) {
#line 395
    psf->pipeoffset += total;
  }
#line 397
  return (total / bytes);
}
}
#line 401 "/root/patchweave_new/23/src/file_io.c"
sf_count_t psf_ftell(SF_PRIVATE *psf ) 
{ 
  sf_count_t pos ;
  sf_count_t __cil_tmp3 ;
  int *__cil_tmp5 ;

  {
#line 404
  if (psf->virtual_io) {
    {
#line 405
    __cil_tmp3 = (*(psf->vio.tell))(psf->vio_user_data);
    }
#line 405
    return (__cil_tmp3);
  }
#line 407
  if (psf->is_pipe) {
#line 408
    return (psf->pipeoffset);
  }
  {
#line 410
  pos = lseek(psf->file.filedes, (__off_t )0, 1);
  }
#line 412
  if (pos == -1L) {
    {
#line 413
    __cil_tmp5 = __errno_location();
#line 413
    psf_log_syserr(psf, *__cil_tmp5);
    }
#line 414
    return ((sf_count_t )-1);
  }
#line 417
  return (pos - psf->fileoffset);
}
}
#line 421 "/root/patchweave_new/23/src/file_io.c"
static int psf_close_fd(int fd ) 
{ 
  int retval ;
  int *__cil_tmp4 ;

  {
#line 424
  if (fd < 0) {
#line 425
    return (0);
  }
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 427
    __cil_tmp4 = __errno_location();
#line 427
    retval = close(fd);
    }
#line 427
    if (retval == -1) {
#line 427
      if (! (*__cil_tmp4 == 4)) {
#line 427
        goto while_break;
      }
    } else {
#line 427
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 430
  return (retval);
}
}
#line 434 "/root/patchweave_new/23/src/file_io.c"
sf_count_t psf_fgets(char *buffer , sf_count_t bufsize , SF_PRIVATE *psf ) 
{ 
  sf_count_t k ;
  sf_count_t count___0 ;
  int *__cil_tmp7 ;
  int *__cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 435
  k = (sf_count_t )0;
  {
#line 438
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 438
    if (! (k < bufsize - 1L)) {
#line 438
      goto while_break;
    }
    {
#line 439
    count___0 = read(psf->file.filedes, (void *)(buffer + k), (size_t )1);
    }
#line 441
    if (count___0 == -1L) {
      {
#line 442
      __cil_tmp7 = __errno_location();
      }
#line 442
      if (*__cil_tmp7 == 4) {
#line 443
        goto while_continue;
      }
      {
#line 445
      __cil_tmp8 = __errno_location();
#line 445
      psf_log_syserr(psf, *__cil_tmp8);
      }
#line 446
      goto while_break;
    }
#line 449
    __cil_tmp9 = k;
#line 449
    k ++;
#line 449
    if (count___0 == 0L) {
#line 450
      goto while_break;
    } else
#line 449
    if ((int )*(buffer + __cil_tmp9) == 10) {
#line 450
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 453
  *(buffer + k) = (char)0;
#line 455
  return (k);
}
}
#line 459 "/root/patchweave_new/23/src/file_io.c"
int psf_is_pipe(SF_PRIVATE *psf ) 
{ 
  struct stat statbuf ;
  int __cil_tmp3 ;
  int *__cil_tmp4 ;

  {
#line 462
  if (psf->virtual_io) {
#line 463
    return (0);
  }
  {
#line 465
  __cil_tmp3 = fstat(psf->file.filedes, & statbuf);
  }
#line 465
  if (__cil_tmp3 == -1) {
    {
#line 466
    __cil_tmp4 = __errno_location();
#line 466
    psf_log_syserr(psf, *__cil_tmp4);
    }
#line 468
    return (1);
  }
#line 471
  if ((statbuf.st_mode & 61440U) == 4096U) {
#line 472
    return (1);
  } else
#line 471
  if ((statbuf.st_mode & 61440U) == 49152U) {
#line 472
    return (1);
  }
#line 474
  return (0);
}
}
#line 478 "/root/patchweave_new/23/src/file_io.c"
static sf_count_t psf_get_filelen_fd(int fd ) 
{ 
  struct stat statbuf ;
  int __cil_tmp3 ;

  {
  {
#line 490
  __cil_tmp3 = fstat(fd, & statbuf);
  }
#line 490
  if (__cil_tmp3 == -1) {
#line 491
    return ((sf_count_t )-1);
  }
#line 493
  return (statbuf.st_size);
}
}
#line 498 "/root/patchweave_new/23/src/file_io.c"
int psf_ftruncate(SF_PRIVATE *psf , sf_count_t len ) 
{ 
  int retval ;
  int *__cil_tmp5 ;

  {
#line 502
  if (len < 0L) {
#line 503
    return (-1);
  }
#line 505
  if (sizeof(__off_t ) < sizeof(sf_count_t )) {
#line 505
    if (len > 2147483647L) {
#line 506
      return (-1);
    }
  }
  {
#line 508
  retval = ftruncate(psf->file.filedes, len);
  }
#line 510
  if (retval == -1) {
    {
#line 511
    __cil_tmp5 = __errno_location();
#line 511
    psf_log_syserr(psf, *__cil_tmp5);
    }
  }
#line 513
  return (retval);
}
}
#line 517 "/root/patchweave_new/23/src/file_io.c"
void psf_init_files(SF_PRIVATE *psf ) 
{ 


  {
#line 518
  psf->file.filedes = -1;
#line 519
  psf->rsrc.filedes = -1;
#line 520
  psf->file.savedes = -1;
#line 521
  return;
}
}
#line 524 "/root/patchweave_new/23/src/file_io.c"
void psf_use_rsrc(SF_PRIVATE *psf , int on_off ) 
{ 


  {
#line 526
  if (on_off) {
#line 527
    if (psf->file.filedes != psf->rsrc.filedes) {
#line 528
      psf->file.savedes = psf->file.filedes;
#line 529
      psf->file.filedes = psf->rsrc.filedes;
    }
  } else
#line 532
  if (psf->file.filedes == psf->rsrc.filedes) {
#line 533
    psf->file.filedes = psf->file.savedes;
  }
#line 535
  return;
}
}
#line 539 "/root/patchweave_new/23/src/file_io.c"
static int psf_open_fd(PSF_FILE *pfile ) 
{ 
  int fd ;
  int oflag ;
  int mode ;

  {
#line 547
  if (sizeof(sf_count_t ) != 8UL) {
    {
#line 548
    puts("\n\n*** Fatal error : sizeof (sf_count_t) != 8\270U");
#line 549
    puts("*** This means that libsndfile was not configured correctly.\n");
#line 550
    exit(1);
    }
  }
#line 554
  if (pfile->mode == 16) {
#line 554
    goto case_16;
  }
#line 559
  if (pfile->mode == 32) {
#line 559
    goto case_32;
  }
#line 564
  if (pfile->mode == 48) {
#line 564
    goto case_48;
  }
#line 569
  goto switch_default;
  case_16: 
#line 555
  oflag = 0;
#line 556
  mode = 0;
#line 557
  goto switch_break;
  case_32: 
#line 560
  oflag = 577;
#line 561
  mode = (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3);
#line 562
  goto switch_break;
  case_48: 
#line 565
  oflag = 66;
#line 566
  mode = (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3);
#line 567
  goto switch_break;
  switch_default: 
#line 570
  return (-45);
#line 571
  goto switch_break;
  switch_break: ;
#line 574
  if (mode == 0) {
    {
#line 575
    fd = open((char const   *)(pfile->path.c), oflag);
    }
  } else {
    {
#line 577
    fd = open((char const   *)(pfile->path.c), oflag, mode);
    }
  }
#line 579
  return (fd);
}
}
#line 583 "/root/patchweave_new/23/src/file_io.c"
static void psf_log_syserr(SF_PRIVATE *psf , int error ) 
{ 
  char *__cil_tmp3 ;

  {
#line 586
  if (psf->error == 0) {
    {
#line 587
    psf->error = 2;
#line 588
    __cil_tmp3 = strerror(error);
#line 588
    snprintf(psf->syserr, sizeof(psf->syserr), "System error : %s.\254@\270U", __cil_tmp3);
    }
  }
#line 591
  return;
}
}
#line 595 "/root/patchweave_new/23/src/file_io.c"
void psf_fsync(SF_PRIVATE *psf ) 
{ 


  {
#line 598
  if (psf->file.mode == 32) {
    {
#line 599
    fsync(psf->file.filedes);
    }
  } else
#line 598
  if (psf->file.mode == 48) {
    {
#line 599
    fsync(psf->file.filedes);
    }
  }
#line 603
  return;
}
}
#line 53 "/root/patchweave_new/23/src/dwvw.c"
static sf_count_t dwvw_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 54
static sf_count_t dwvw_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 55
static sf_count_t dwvw_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 56
static sf_count_t dwvw_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 58
static sf_count_t dwvw_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 59
static sf_count_t dwvw_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 60
static sf_count_t dwvw_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 61
static sf_count_t dwvw_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 63
static sf_count_t dwvw_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) ;
#line 64
static int dwvw_close(SF_PRIVATE *psf ) ;
#line 65
static int dwvw_byterate(SF_PRIVATE *psf ) ;
#line 67
static int dwvw_decode_data(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int *ptr , int len ) ;
#line 68
static int dwvw_decode_load_bits(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int bit_count ) ;
#line 70
static int dwvw_encode_data(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int const   *ptr ,
                            int len ) ;
#line 71
static void dwvw_encode_store_bits(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int data ,
                                   int new_bits ) ;
#line 72
static void dwvw_read_reset(DWVW_PRIVATE *pdwvw ) ;
#line 79 "/root/patchweave_new/23/src/dwvw.c"
int dwvw_init(SF_PRIVATE *psf , int bitwidth ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  void *tmp ;

  {
#line 82
  if ((unsigned long )psf->codec_data != (unsigned long )((void *)0)) {
    {
#line 83
    psf_log_printf(psf, "*** psf->codec_data is not NULL.\n\210\261@\270U");
    }
#line 84
    return (30);
  }
#line 87
  if (bitwidth > 24) {
#line 88
    return (139);
  }
#line 90
  if (psf->file.mode == 48) {
#line 91
    return (24);
  }
  {
#line 93
  tmp = calloc(1UL, sizeof(DWVW_PRIVATE ));
#line 93
  pdwvw = (DWVW_PRIVATE *)tmp;
  }
#line 93
  if ((unsigned long )pdwvw == (unsigned long )((void *)0)) {
#line 94
    return (17);
  }
  {
#line 96
  psf->codec_data = (void *)pdwvw;
#line 97
  pdwvw->bit_width = bitwidth;
#line 98
  dwvw_read_reset(pdwvw);
  }
#line 100
  if (psf->file.mode == 16) {
#line 101
    psf->read_short = & dwvw_read_s;
#line 102
    psf->read_int = & dwvw_read_i;
#line 103
    psf->read_float = & dwvw_read_f;
#line 104
    psf->read_double = & dwvw_read_d;
  }
#line 107
  if (psf->file.mode == 32) {
#line 108
    psf->write_short = & dwvw_write_s;
#line 109
    psf->write_int = & dwvw_write_i;
#line 110
    psf->write_float = & dwvw_write_f;
#line 111
    psf->write_double = & dwvw_write_d;
  }
#line 114
  psf->codec_close = & dwvw_close;
#line 115
  psf->seek = & dwvw_seek;
#line 116
  psf->byterate = & dwvw_byterate;
#line 118
  if (psf->file.mode == 16) {
    {
#line 119
    psf->sf.frames = psf_decode_frame_count(psf);
#line 120
    dwvw_read_reset(pdwvw);
    }
  }
#line 123
  return (0);
}
}
#line 133 "/root/patchweave_new/23/src/dwvw.c"
static int last_values[12]  ;
#line 130 "/root/patchweave_new/23/src/dwvw.c"
static int dwvw_close(SF_PRIVATE *psf ) 
{ 
  DWVW_PRIVATE *pdwvw ;

  {
#line 133
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 134
    return (0);
  }
#line 135
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 137
  if (psf->file.mode == 32) {
    {
#line 138
    last_values[0] = 0;
#line 138
    last_values[1] = 0;
#line 138
    last_values[2] = 0;
#line 138
    last_values[3] = 0;
#line 138
    last_values[4] = 0;
#line 138
    last_values[5] = 0;
#line 138
    last_values[6] = 0;
#line 138
    last_values[7] = 0;
#line 138
    last_values[8] = 0;
#line 138
    last_values[9] = 0;
#line 138
    last_values[10] = 0;
#line 138
    last_values[11] = 0;
#line 141
    dwvw_encode_data(psf, pdwvw, (int const   *)(last_values), 12);
#line 144
    psf_fwrite((void const   *)(pdwvw->b.buffer), (sf_count_t )1, (sf_count_t )pdwvw->b.index,
               psf);
    }
#line 146
    if (psf->write_header) {
      {
#line 147
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 150
  return (0);
}
}
#line 154 "/root/patchweave_new/23/src/dwvw.c"
static sf_count_t dwvw_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) 
{ 
  DWVW_PRIVATE *pdwvw ;

  {
#line 157
  if (! psf->codec_data) {
#line 158
    psf->error = 30;
#line 159
    return ((sf_count_t )-1);
  }
#line 162
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 164
  if (offset == 0L) {
    {
#line 165
    psf_fseek(psf, psf->dataoffset, 0);
#line 166
    dwvw_read_reset(pdwvw);
    }
#line 167
    return ((sf_count_t )0);
  }
#line 170
  psf->error = 40;
#line 171
  return ((sf_count_t )-1);
}
}
#line 175 "/root/patchweave_new/23/src/dwvw.c"
static int dwvw_byterate(SF_PRIVATE *psf ) 
{ 


  {
#line 177
  if (psf->file.mode == 16) {
#line 178
    return ((int )((psf->datalength * (long )psf->sf.samplerate) / psf->sf.frames));
  }
#line 180
  return (-1);
}
}
#line 187 "/root/patchweave_new/23/src/dwvw.c"
static sf_count_t dwvw_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  BUF_UNION ubuf ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 191
  readcount = 0;
#line 192
  total = (sf_count_t )0;
#line 194
  if (! psf->codec_data) {
#line 195
    return ((sf_count_t )0);
  }
#line 196
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 198
  iptr = ubuf.ibuf;
#line 199
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;

#line 200
    if (! (len > 0L)) {
#line 200
      goto while_break;
    }
#line 201
    if (len >= (long )bufferlen) {
#line 201
      tmp = (long )bufferlen;
    } else {
#line 201
      tmp = len;
    }
    {
#line 201
    readcount = (int )tmp;
#line 202
    count___0 = dwvw_decode_data(psf, pdwvw, iptr, readcount);
#line 203
    k = 0;
    }
    {
#line 203
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 203
      if (! (k < readcount)) {
#line 203
        goto while_break___0;
      }
#line 204
      *(ptr + (total + (long )k)) = (short )(*(iptr + k) >> 16);
#line 203
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 206
    total += (long )count___0;
#line 207
    len -= (long )readcount;
#line 208
    if (count___0 != readcount) {
#line 209
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 212
  return (total);
}
}
#line 216 "/root/patchweave_new/23/src/dwvw.c"
static sf_count_t dwvw_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 219
  total = (sf_count_t )0;
#line 221
  if (! psf->codec_data) {
#line 222
    return ((sf_count_t )0);
  }
#line 223
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;

#line 225
    if (! (len > 0L)) {
#line 225
      goto while_break;
    }
#line 226
    if (len > 268435456L) {
#line 226
      tmp = 268435456;
    } else {
#line 226
      tmp = (int )len;
    }
    {
#line 226
    readcount = tmp;
#line 228
    count___0 = dwvw_decode_data(psf, pdwvw, ptr, readcount);
#line 230
    total += (long )count___0;
#line 231
    len -= (long )count___0;
    }
#line 233
    if (count___0 != readcount) {
#line 234
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 237
  return (total);
}
}
#line 241 "/root/patchweave_new/23/src/dwvw.c"
static sf_count_t dwvw_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  BUF_UNION ubuf ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 245
  readcount = 0;
#line 246
  total = (sf_count_t )0;
#line 249
  if (! psf->codec_data) {
#line 250
    return ((sf_count_t )0);
  }
#line 251
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 253
  if (psf->norm_float == 1) {
#line 253
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 253
    tmp = 1.;
  }
#line 253
  normfact = (float )tmp;
#line 255
  iptr = ubuf.ibuf;
#line 256
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;

#line 257
    if (! (len > 0L)) {
#line 257
      goto while_break;
    }
#line 258
    if (len >= (long )bufferlen) {
#line 258
      tmp___0 = (long )bufferlen;
    } else {
#line 258
      tmp___0 = len;
    }
    {
#line 258
    readcount = (int )tmp___0;
#line 259
    count___0 = dwvw_decode_data(psf, pdwvw, iptr, readcount);
#line 260
    k = 0;
    }
    {
#line 260
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 260
      if (! (k < readcount)) {
#line 260
        goto while_break___0;
      }
#line 261
      *(ptr + (total + (long )k)) = normfact * (float )*(iptr + k);
#line 260
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 263
    total += (long )count___0;
#line 264
    len -= (long )readcount;
#line 265
    if (count___0 != readcount) {
#line 266
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 269
  return (total);
}
}
#line 273 "/root/patchweave_new/23/src/dwvw.c"
static sf_count_t dwvw_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  BUF_UNION ubuf ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 277
  readcount = 0;
#line 278
  total = (sf_count_t )0;
#line 281
  if (! psf->codec_data) {
#line 282
    return ((sf_count_t )0);
  }
#line 283
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 285
  if (psf->norm_double == 1) {
#line 285
    tmp = 1. / (double )2147483648U;
  } else {
#line 285
    tmp = 1.;
  }
#line 285
  normfact = tmp;
#line 287
  iptr = ubuf.ibuf;
#line 288
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;

#line 289
    if (! (len > 0L)) {
#line 289
      goto while_break;
    }
#line 290
    if (len >= (long )bufferlen) {
#line 290
      tmp___0 = (long )bufferlen;
    } else {
#line 290
      tmp___0 = len;
    }
    {
#line 290
    readcount = (int )tmp___0;
#line 291
    count___0 = dwvw_decode_data(psf, pdwvw, iptr, readcount);
#line 292
    k = 0;
    }
    {
#line 292
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 292
      if (! (k < readcount)) {
#line 292
        goto while_break___0;
      }
#line 293
      *(ptr + (total + (long )k)) = normfact * (double )*(iptr + k);
#line 292
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 295
    total += (long )count___0;
#line 296
    len -= (long )readcount;
#line 297
    if (count___0 != readcount) {
#line 298
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 301
  return (total);
}
}
#line 305 "/root/patchweave_new/23/src/dwvw.c"
static int dwvw_decode_data(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int *ptr , int len ) 
{ 
  int count___0 ;
  int delta_width_modifier ;
  int delta_width ;
  int delta_negative ;
  int delta ;
  int sample ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp15 ;

  {
#line 310
  delta_width = pdwvw->last_delta_width;
#line 311
  sample = pdwvw->last_sample;
#line 313
  count___0 = 0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;

#line 313
    if (! (count___0 < len)) {
#line 313
      goto while_break;
    }
    {
#line 315
    delta_width_modifier = dwvw_decode_load_bits(psf, pdwvw, -1);
    }
#line 318
    if (delta_width_modifier < 0) {
#line 319
      goto while_break;
    } else
#line 318
    if (pdwvw->b.end == 0) {
#line 318
      if (count___0 == 0) {
#line 319
        goto while_break;
      }
    }
    {
#line 321
    __cil_tmp12 = dwvw_decode_load_bits(psf, pdwvw, 1);
    }
#line 321
    if (delta_width_modifier) {
#line 321
      if (__cil_tmp12) {
#line 322
        delta_width_modifier = - delta_width_modifier;
      }
    }
#line 325
    delta_width = ((delta_width + delta_width_modifier) + pdwvw->bit_width) % pdwvw->bit_width;
#line 328
    delta = 0;
#line 329
    if (delta_width) {
      {
#line 330
      __cil_tmp13 = dwvw_decode_load_bits(psf, pdwvw, delta_width - 1);
#line 330
      delta = __cil_tmp13 | (1 << (delta_width - 1));
#line 331
      delta_negative = dwvw_decode_load_bits(psf, pdwvw, 1);
      }
#line 332
      if (delta == pdwvw->max_delta - 1) {
        {
#line 333
        __cil_tmp15 = dwvw_decode_load_bits(psf, pdwvw, 1);
#line 333
        delta += __cil_tmp15;
        }
      }
#line 334
      if (delta_negative) {
#line 335
        delta = - delta;
      }
    }
#line 339
    sample += delta;
#line 341
    if (sample >= pdwvw->max_delta) {
#line 342
      sample -= pdwvw->span;
    } else
#line 343
    if (sample < - pdwvw->max_delta) {
#line 344
      sample += pdwvw->span;
    }
    {
#line 347
    *(ptr + count___0) = arith_shift_left(sample, 32 - pdwvw->bit_width);
    }
#line 349
    if (pdwvw->b.end == 0) {
#line 349
      if (pdwvw->bit_count == 0) {
#line 350
        goto while_break;
      }
    }
#line 313
    count___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 353
  pdwvw->last_delta_width = delta_width;
#line 354
  pdwvw->last_sample = sample;
#line 356
  pdwvw->samplecount += count___0;
#line 358
  return (count___0);
}
}
#line 362 "/root/patchweave_new/23/src/dwvw.c"
static int dwvw_decode_load_bits(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int bit_count ) 
{ 
  int output ;
  int get_dwm ;
  sf_count_t __cil_tmp6 ;

  {
#line 363
  output = 0;
#line 363
  get_dwm = 0;
#line 371
  if (bit_count < 0) {
#line 372
    get_dwm = 1;
#line 374
    bit_count = pdwvw->dwm_maxsize;
  }
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;

#line 378
    if (! (pdwvw->bit_count < bit_count)) {
#line 378
      goto while_break;
    }
#line 379
    if (pdwvw->b.index >= pdwvw->b.end) {
      {
#line 380
      __cil_tmp6 = psf_fread((void *)(pdwvw->b.buffer), (sf_count_t )1, (sf_count_t )sizeof(pdwvw->b.buffer),
                             psf);
#line 380
      pdwvw->b.end = (int )__cil_tmp6;
#line 381
      pdwvw->b.index = 0;
      }
    }
#line 385
    if (bit_count < 8) {
#line 385
      if (pdwvw->b.end == 0) {
#line 386
        return (-1);
      }
    }
    {
#line 388
    pdwvw->bits = arith_shift_left(pdwvw->bits, 8);
    }
#line 390
    if (pdwvw->b.index < pdwvw->b.end) {
#line 391
      pdwvw->bits |= (int )pdwvw->b.buffer[pdwvw->b.index];
#line 392
      (pdwvw->b.index) ++;
    }
#line 394
    pdwvw->bit_count += 8;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 398
  if (! get_dwm) {
#line 399
    output = (pdwvw->bits >> (pdwvw->bit_count - bit_count)) & ((1 << bit_count) - 1);
#line 400
    pdwvw->bit_count -= bit_count;
#line 401
    return (output);
  }
  {
#line 405
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 405
    if (! (output < pdwvw->dwm_maxsize)) {
#line 405
      goto while_break___0;
    }
#line 406
    (pdwvw->bit_count) --;
#line 407
    if (pdwvw->bits & (1 << pdwvw->bit_count)) {
#line 408
      goto while_break___0;
    }
#line 409
    output ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 412
  return (output);
}
}
#line 416 "/root/patchweave_new/23/src/dwvw.c"
static void dwvw_read_reset(DWVW_PRIVATE *pdwvw ) 
{ 
  int bitwidth ;

  {
  {
#line 417
  bitwidth = pdwvw->bit_width;
#line 419
  memset((void *)pdwvw, 0, sizeof(DWVW_PRIVATE ));
#line 421
  pdwvw->bit_width = bitwidth;
#line 422
  pdwvw->dwm_maxsize = bitwidth / 2;
#line 423
  pdwvw->max_delta = 1 << (bitwidth - 1);
#line 424
  pdwvw->span = 1 << bitwidth;
  }
#line 426
  return;
}
}
#line 428 "/root/patchweave_new/23/src/dwvw.c"
static void dwvw_encode_store_bits(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int data ,
                                   int new_bits ) 
{ 
  int byte ;
  int32_t __cil_tmp6 ;
  int32_t __cil_tmp7 ;

  {
  {
#line 432
  __cil_tmp7 = arith_shift_left(1, new_bits);
#line 432
  __cil_tmp6 = arith_shift_left(pdwvw->bits, new_bits);
#line 432
  pdwvw->bits = __cil_tmp6 | (data & (__cil_tmp7 - 1));
#line 433
  pdwvw->bit_count += new_bits;
  }
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;

#line 436
    if (! (pdwvw->bit_count >= 8)) {
#line 436
      goto while_break;
    }
#line 437
    byte = pdwvw->bits >> (pdwvw->bit_count - 8);
#line 438
    pdwvw->bit_count -= 8;
#line 439
    pdwvw->b.buffer[pdwvw->b.index] = (unsigned char )(byte & 255);
#line 440
    (pdwvw->b.index) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 443
  if (pdwvw->b.index > (int )sizeof(pdwvw->b.buffer) - 4) {
    {
#line 444
    psf_fwrite((void const   *)(pdwvw->b.buffer), (sf_count_t )1, (sf_count_t )pdwvw->b.index,
               psf);
#line 445
    pdwvw->b.index = 0;
    }
  }
#line 448
  return;
}
}
#line 483 "/root/patchweave_new/23/src/dwvw.c"
static int dwvw_encode_data(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int const   *ptr ,
                            int len ) 
{ 
  int count___0 ;
  int delta_width_modifier ;
  int delta ;
  int delta_negative ;
  int delta_width ;
  int extra_bit ;
  int y ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp ;

  {
#line 487
  count___0 = 0;
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;

#line 487
    if (! (count___0 < len)) {
#line 487
      goto while_break;
    }
#line 488
    delta = (int )((*(ptr + count___0) >> (32 - pdwvw->bit_width)) - (int const   )pdwvw->last_sample);
#line 491
    extra_bit = -1;
#line 492
    delta_negative = 0;
#line 493
    if (delta < - pdwvw->max_delta) {
#line 494
      delta = pdwvw->max_delta + delta % pdwvw->max_delta;
    } else
#line 495
    if (delta == - pdwvw->max_delta) {
#line 496
      extra_bit = 1;
#line 497
      delta_negative = 1;
#line 498
      delta = pdwvw->max_delta - 1;
    } else
#line 500
    if (delta > pdwvw->max_delta) {
      {
#line 501
      delta_negative = 1;
#line 502
      delta = pdwvw->span - delta;
#line 503
      delta = abs(delta);
      }
    } else
#line 505
    if (delta == pdwvw->max_delta) {
#line 506
      extra_bit = 1;
#line 507
      delta = pdwvw->max_delta - 1;
    } else
#line 509
    if (delta < 0) {
      {
#line 510
      delta_negative = 1;
#line 511
      delta = abs(delta);
      }
    }
#line 514
    if (delta == pdwvw->max_delta - 1) {
#line 514
      if (extra_bit == -1) {
#line 515
        extra_bit = 0;
      }
    }
#line 518
    y = delta;
#line 518
    delta_width = 0;
    {
#line 518
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 518
      if (! y) {
#line 518
        goto while_break___0;
      }
#line 518
      delta_width ++;
#line 518
      y >>= 1;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 521
    delta_width_modifier = (delta_width - pdwvw->last_delta_width) % pdwvw->bit_width;
#line 522
    if (delta_width_modifier > pdwvw->dwm_maxsize) {
#line 523
      delta_width_modifier -= pdwvw->bit_width;
    }
#line 524
    if (delta_width_modifier < - pdwvw->dwm_maxsize) {
#line 525
      delta_width_modifier += pdwvw->bit_width;
    }
    {
#line 528
    __cil_tmp15 = abs(delta_width_modifier);
#line 528
    dwvw_encode_store_bits(psf, pdwvw, 0, __cil_tmp15);
#line 529
    __cil_tmp16 = abs(delta_width_modifier);
    }
#line 529
    if (__cil_tmp16 != pdwvw->dwm_maxsize) {
      {
#line 530
      dwvw_encode_store_bits(psf, pdwvw, 1, 1);
      }
    }
#line 533
    if (delta_width_modifier < 0) {
      {
#line 534
      dwvw_encode_store_bits(psf, pdwvw, 1, 1);
      }
    }
#line 535
    if (delta_width_modifier > 0) {
      {
#line 536
      dwvw_encode_store_bits(psf, pdwvw, 0, 1);
      }
    }
#line 539
    if (delta_width) {
      {
#line 540
      __cil_tmp17 = abs(delta_width);
#line 540
      dwvw_encode_store_bits(psf, pdwvw, delta, __cil_tmp17 - 1);
      }
#line 541
      if (delta_negative) {
#line 541
        tmp = 1;
      } else {
#line 541
        tmp = 0;
      }
      {
#line 541
      dwvw_encode_store_bits(psf, pdwvw, tmp, 1);
      }
    }
#line 545
    if (extra_bit >= 0) {
      {
#line 546
      dwvw_encode_store_bits(psf, pdwvw, extra_bit, 1);
      }
    }
#line 548
    pdwvw->last_sample = (int )(*(ptr + count___0) >> (32 - pdwvw->bit_width));
#line 549
    pdwvw->last_delta_width = delta_width;
#line 487
    count___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 552
  pdwvw->samplecount += count___0;
#line 554
  return (count___0);
}
}
#line 558 "/root/patchweave_new/23/src/dwvw.c"
static sf_count_t dwvw_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  BUF_UNION ubuf ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 562
  writecount = 0;
#line 563
  total = (sf_count_t )0;
#line 565
  if (! psf->codec_data) {
#line 566
    return ((sf_count_t )0);
  }
#line 567
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 569
  iptr = ubuf.ibuf;
#line 570
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;

#line 571
    if (! (len > 0L)) {
#line 571
      goto while_break;
    }
#line 572
    if (len >= (long )bufferlen) {
#line 572
      tmp = (long )bufferlen;
    } else {
#line 572
      tmp = len;
    }
#line 572
    writecount = (int )tmp;
#line 573
    k = 0;
    {
#line 573
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 573
      if (! (k < writecount)) {
#line 573
        goto while_break___0;
      }
      {
#line 574
      *(iptr + k) = arith_shift_left((int32_t )*(ptr + (total + (long )k)), 16);
#line 573
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 575
    count___0 = dwvw_encode_data(psf, pdwvw, (int const   *)iptr, writecount);
#line 577
    total += (long )count___0;
#line 578
    len -= (long )writecount;
    }
#line 579
    if (count___0 != writecount) {
#line 580
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 583
  return (total);
}
}
#line 587 "/root/patchweave_new/23/src/dwvw.c"
static sf_count_t dwvw_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 590
  total = (sf_count_t )0;
#line 592
  if (! psf->codec_data) {
#line 593
    return ((sf_count_t )0);
  }
#line 594
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;

#line 596
    if (! (len > 0L)) {
#line 596
      goto while_break;
    }
#line 597
    if (len > 268435456L) {
#line 597
      tmp = 268435456;
    } else {
#line 597
      tmp = (int )len;
    }
    {
#line 597
    writecount = tmp;
#line 599
    count___0 = dwvw_encode_data(psf, pdwvw, ptr, writecount);
#line 601
    total += (long )count___0;
#line 602
    len -= (long )count___0;
    }
#line 604
    if (count___0 != writecount) {
#line 605
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 608
  return (total);
}
}
#line 612 "/root/patchweave_new/23/src/dwvw.c"
static sf_count_t dwvw_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  BUF_UNION ubuf ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 616
  writecount = 0;
#line 617
  total = (sf_count_t )0;
#line 620
  if (! psf->codec_data) {
#line 621
    return ((sf_count_t )0);
  }
#line 622
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 624
  if (psf->norm_float == 1) {
#line 624
    tmp = 1. * (double )2147483647;
  } else {
#line 624
    tmp = 1.;
  }
#line 624
  normfact = (float )tmp;
#line 626
  iptr = ubuf.ibuf;
#line 627
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 628
  while (1) {
    while_continue: /* CIL Label */ ;

#line 628
    if (! (len > 0L)) {
#line 628
      goto while_break;
    }
#line 629
    if (len >= (long )bufferlen) {
#line 629
      tmp___0 = (long )bufferlen;
    } else {
#line 629
      tmp___0 = len;
    }
#line 629
    writecount = (int )tmp___0;
#line 630
    k = 0;
    {
#line 630
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 630
      if (! (k < writecount)) {
#line 630
        goto while_break___0;
      }
      {
#line 631
      __cil_tmp15 = lrintf(normfact * (float )*(ptr + (total + (long )k)));
#line 631
      *(iptr + k) = (int )__cil_tmp15;
#line 630
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 632
    count___0 = dwvw_encode_data(psf, pdwvw, (int const   *)iptr, writecount);
#line 634
    total += (long )count___0;
#line 635
    len -= (long )writecount;
    }
#line 636
    if (count___0 != writecount) {
#line 637
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 640
  return (total);
}
}
#line 644 "/root/patchweave_new/23/src/dwvw.c"
static sf_count_t dwvw_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  BUF_UNION ubuf ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 648
  writecount = 0;
#line 649
  total = (sf_count_t )0;
#line 652
  if (! psf->codec_data) {
#line 653
    return ((sf_count_t )0);
  }
#line 654
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 656
  if (psf->norm_double == 1) {
#line 656
    tmp = 1. * (double )2147483647;
  } else {
#line 656
    tmp = 1.;
  }
#line 656
  normfact = tmp;
#line 658
  iptr = ubuf.ibuf;
#line 659
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 660
  while (1) {
    while_continue: /* CIL Label */ ;

#line 660
    if (! (len > 0L)) {
#line 660
      goto while_break;
    }
#line 661
    if (len >= (long )bufferlen) {
#line 661
      tmp___0 = (long )bufferlen;
    } else {
#line 661
      tmp___0 = len;
    }
#line 661
    writecount = (int )tmp___0;
#line 662
    k = 0;
    {
#line 662
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 662
      if (! (k < writecount)) {
#line 662
        goto while_break___0;
      }
      {
#line 663
      __cil_tmp15 = lrint(normfact * (double )*(ptr + (total + (long )k)));
#line 663
      *(iptr + k) = (int )__cil_tmp15;
#line 662
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 664
    count___0 = dwvw_encode_data(psf, pdwvw, (int const   *)iptr, writecount);
#line 666
    total += (long )count___0;
#line 667
    len -= (long )writecount;
    }
#line 668
    if (count___0 != writecount) {
#line 669
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 672
  return (total);
}
}
#line 59 "/root/patchweave_new/23/src/double64.c"
static sf_count_t host_read_d2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 60
static sf_count_t host_read_d2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 61
static sf_count_t host_read_d2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 62
static sf_count_t host_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 64
static sf_count_t host_write_s2d(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 65
static sf_count_t host_write_i2d(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 66
static sf_count_t host_write_f2d(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 67
static sf_count_t host_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 69
static void double64_peak_update(SF_PRIVATE *psf , double const   *buffer , int count___0 ,
                                 sf_count_t indx ) ;
#line 71
static int double64_get_capability(SF_PRIVATE *psf ) ;
#line 73
static sf_count_t replace_read_d2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 74
static sf_count_t replace_read_d2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 75
static sf_count_t replace_read_d2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 76
static sf_count_t replace_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 78
static sf_count_t replace_write_s2d(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 79
static sf_count_t replace_write_i2d(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 80
static sf_count_t replace_write_f2d(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 81
static sf_count_t replace_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 83
static void d2bd_read(double *buffer , int count___0 ) ;
#line 84
static void bd2d_write(double *buffer , int count___0 ) ;
#line 93 "/root/patchweave_new/23/src/double64.c"
static int double64_caps  ;
#line 91 "/root/patchweave_new/23/src/double64.c"
int double64_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t tmp ;

  {
#line 94
  if (psf->sf.channels < 1) {
    {
#line 95
    psf_log_printf(psf, "double64_init : internal error : channels = %d\n", psf->sf.channels);
    }
#line 96
    return (30);
  }
  {
#line 99
  double64_caps = double64_get_capability(psf);
#line 101
  psf->blockwidth = (int )(sizeof(double ) * (unsigned long )psf->sf.channels);
  }
#line 103
  if (psf->file.mode == 16) {
    _L: 
#line 105
    if (psf->endian + double64_caps == 536870964) {
#line 105
      goto case_536870964;
    }
#line 113
    if (psf->endian + double64_caps == 268435491) {
#line 113
      goto case_268435491;
    }
#line 121
    if (psf->endian + double64_caps == 536870947) {
#line 121
      goto case_536870947;
    }
#line 129
    if (psf->endian + double64_caps == 268435508) {
#line 129
      goto case_268435508;
    }
#line 138
    if (psf->endian + double64_caps == 536870998) {
#line 138
      goto case_536870998;
    }
#line 146
    if (psf->endian + double64_caps == 268435525) {
#line 146
      goto case_268435525;
    }
#line 154
    if (psf->endian + double64_caps == 536870981) {
#line 154
      goto case_536870981;
    }
#line 162
    if (psf->endian + double64_caps == 268435542) {
#line 162
      goto case_268435542;
    }
#line 170
    goto switch_default;
    case_536870964: 
#line 106
    psf->data_endswap = 0;
#line 107
    psf->read_short = & host_read_d2s;
#line 108
    psf->read_int = & host_read_d2i;
#line 109
    psf->read_float = & host_read_d2f;
#line 110
    psf->read_double = & host_read_d;
#line 111
    goto switch_break;
    case_268435491: 
#line 114
    psf->data_endswap = 0;
#line 115
    psf->read_short = & host_read_d2s;
#line 116
    psf->read_int = & host_read_d2i;
#line 117
    psf->read_float = & host_read_d2f;
#line 118
    psf->read_double = & host_read_d;
#line 119
    goto switch_break;
    case_536870947: 
#line 122
    psf->data_endswap = 1;
#line 123
    psf->read_short = & host_read_d2s;
#line 124
    psf->read_int = & host_read_d2i;
#line 125
    psf->read_float = & host_read_d2f;
#line 126
    psf->read_double = & host_read_d;
#line 127
    goto switch_break;
    case_268435508: 
#line 130
    psf->data_endswap = 1;
#line 131
    psf->read_short = & host_read_d2s;
#line 132
    psf->read_int = & host_read_d2i;
#line 133
    psf->read_float = & host_read_d2f;
#line 134
    psf->read_double = & host_read_d;
#line 135
    goto switch_break;
    case_536870998: 
#line 139
    psf->data_endswap = 0;
#line 140
    psf->read_short = & replace_read_d2s;
#line 141
    psf->read_int = & replace_read_d2i;
#line 142
    psf->read_float = & replace_read_d2f;
#line 143
    psf->read_double = & replace_read_d;
#line 144
    goto switch_break;
    case_268435525: 
#line 147
    psf->data_endswap = 0;
#line 148
    psf->read_short = & replace_read_d2s;
#line 149
    psf->read_int = & replace_read_d2i;
#line 150
    psf->read_float = & replace_read_d2f;
#line 151
    psf->read_double = & replace_read_d;
#line 152
    goto switch_break;
    case_536870981: 
#line 155
    psf->data_endswap = 1;
#line 156
    psf->read_short = & replace_read_d2s;
#line 157
    psf->read_int = & replace_read_d2i;
#line 158
    psf->read_float = & replace_read_d2f;
#line 159
    psf->read_double = & replace_read_d;
#line 160
    goto switch_break;
    case_268435542: 
#line 163
    psf->data_endswap = 1;
#line 164
    psf->read_short = & replace_read_d2s;
#line 165
    psf->read_int = & replace_read_d2i;
#line 166
    psf->read_float = & replace_read_d2f;
#line 167
    psf->read_double = & replace_read_d;
#line 168
    goto switch_break;
    switch_default: 
#line 170
    goto switch_break;
    switch_break: ;
  } else
#line 103
  if (psf->file.mode == 48) {
#line 103
    goto _L;
  }
#line 174
  if (psf->file.mode == 32) {
    _L___4: 
#line 176
    if (psf->endian + double64_caps == 268435491) {
#line 176
      goto case_268435491___0;
    }
#line 184
    if (psf->endian + double64_caps == 536870964) {
#line 184
      goto case_536870964___0;
    }
#line 192
    if (psf->endian + double64_caps == 536870947) {
#line 192
      goto case_536870947___0;
    }
#line 200
    if (psf->endian + double64_caps == 268435508) {
#line 200
      goto case_268435508___0;
    }
#line 209
    if (psf->endian + double64_caps == 268435525) {
#line 209
      goto case_268435525___0;
    }
#line 217
    if (psf->endian + double64_caps == 536870998) {
#line 217
      goto case_536870998___0;
    }
#line 225
    if (psf->endian + double64_caps == 536870981) {
#line 225
      goto case_536870981___0;
    }
#line 233
    if (psf->endian + double64_caps == 268435542) {
#line 233
      goto case_268435542___0;
    }
#line 241
    goto switch_default___0;
    case_268435491___0: 
#line 177
    psf->data_endswap = 0;
#line 178
    psf->write_short = & host_write_s2d;
#line 179
    psf->write_int = & host_write_i2d;
#line 180
    psf->write_float = & host_write_f2d;
#line 181
    psf->write_double = & host_write_d;
#line 182
    goto switch_break___0;
    case_536870964___0: 
#line 185
    psf->data_endswap = 0;
#line 186
    psf->write_short = & host_write_s2d;
#line 187
    psf->write_int = & host_write_i2d;
#line 188
    psf->write_float = & host_write_f2d;
#line 189
    psf->write_double = & host_write_d;
#line 190
    goto switch_break___0;
    case_536870947___0: 
#line 193
    psf->data_endswap = 1;
#line 194
    psf->write_short = & host_write_s2d;
#line 195
    psf->write_int = & host_write_i2d;
#line 196
    psf->write_float = & host_write_f2d;
#line 197
    psf->write_double = & host_write_d;
#line 198
    goto switch_break___0;
    case_268435508___0: 
#line 201
    psf->data_endswap = 1;
#line 202
    psf->write_short = & host_write_s2d;
#line 203
    psf->write_int = & host_write_i2d;
#line 204
    psf->write_float = & host_write_f2d;
#line 205
    psf->write_double = & host_write_d;
#line 206
    goto switch_break___0;
    case_268435525___0: 
#line 210
    psf->data_endswap = 0;
#line 211
    psf->write_short = & replace_write_s2d;
#line 212
    psf->write_int = & replace_write_i2d;
#line 213
    psf->write_float = & replace_write_f2d;
#line 214
    psf->write_double = & replace_write_d;
#line 215
    goto switch_break___0;
    case_536870998___0: 
#line 218
    psf->data_endswap = 0;
#line 219
    psf->write_short = & replace_write_s2d;
#line 220
    psf->write_int = & replace_write_i2d;
#line 221
    psf->write_float = & replace_write_f2d;
#line 222
    psf->write_double = & replace_write_d;
#line 223
    goto switch_break___0;
    case_536870981___0: 
#line 226
    psf->data_endswap = 1;
#line 227
    psf->write_short = & replace_write_s2d;
#line 228
    psf->write_int = & replace_write_i2d;
#line 229
    psf->write_float = & replace_write_f2d;
#line 230
    psf->write_double = & replace_write_d;
#line 231
    goto switch_break___0;
    case_268435542___0: 
#line 234
    psf->data_endswap = 1;
#line 235
    psf->write_short = & replace_write_s2d;
#line 236
    psf->write_int = & replace_write_i2d;
#line 237
    psf->write_float = & replace_write_f2d;
#line 238
    psf->write_double = & replace_write_d;
#line 239
    goto switch_break___0;
    switch_default___0: 
#line 241
    goto switch_break___0;
    switch_break___0: ;
  } else
#line 174
  if (psf->file.mode == 48) {
#line 174
    goto _L___4;
  }
#line 245
  if (psf->filelength > psf->dataoffset) {
#line 246
    if (psf->dataend > 0L) {
#line 246
      tmp = psf->dataend - psf->dataoffset;
    } else {
#line 246
      tmp = psf->filelength - psf->dataoffset;
    }
#line 246
    psf->datalength = tmp;
  } else {
#line 250
    psf->datalength = (sf_count_t )0;
  }
#line 252
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
#line 254
  return (0);
}
}
#line 284 "/root/patchweave_new/23/src/double64.c"
double double64_be_read(unsigned char const   *cptr ) 
{ 
  int exponent ;
  int negative ;
  int upper ;
  int lower ;
  double dvalue ;
  int tmp ;
  double __cil_tmp8 ;
  int __cil_tmp9 ;
  double __cil_tmp10 ;

  {
#line 288
  if ((int )*(cptr + 0) & 128) {
#line 288
    tmp = 1;
  } else {
#line 288
    tmp = 0;
  }
#line 288
  negative = tmp;
#line 289
  exponent = (((int )*(cptr + 0) & 127) << 4) | (((int )*(cptr + 1) >> 4) & 15);
#line 292
  upper = (((((int )*(cptr + 1) & 15) << 24) | ((int )*(cptr + 2) << 16)) | ((int )*(cptr + 3) << 8)) | (int )*(cptr + 4);
#line 293
  lower = (((int )*(cptr + 5) << 16) | ((int )*(cptr + 6) << 8)) | (int )*(cptr + 7);
#line 295
  if (exponent == 0) {
#line 295
    if (upper == 0) {
#line 295
      if (lower == 0) {
#line 296
        return (0.);
      }
    }
  }
#line 298
  dvalue = (double )upper + (double )lower / (double )16777216;
#line 299
  dvalue += (double )268435456;
#line 301
  exponent -= 1023;
#line 303
  dvalue /= (double )268435456;
#line 305
  if (negative) {
#line 306
    dvalue *= (double )-1;
  }
#line 308
  if (exponent > 0) {
    {
#line 309
    __cil_tmp8 = pow(2., (double )exponent);
#line 309
    dvalue *= __cil_tmp8;
    }
  } else
#line 310
  if (exponent < 0) {
    {
#line 311
    __cil_tmp9 = abs(exponent);
#line 311
    __cil_tmp10 = pow(2., (double )__cil_tmp9);
#line 311
    dvalue /= __cil_tmp10;
    }
  }
#line 313
  return (dvalue);
}
}
#line 317 "/root/patchweave_new/23/src/double64.c"
double double64_le_read(unsigned char const   *cptr ) 
{ 
  int exponent ;
  int negative ;
  int upper ;
  int lower ;
  double dvalue ;
  int tmp ;
  double __cil_tmp8 ;
  int __cil_tmp9 ;
  double __cil_tmp10 ;

  {
#line 321
  if ((int )*(cptr + 7) & 128) {
#line 321
    tmp = 1;
  } else {
#line 321
    tmp = 0;
  }
#line 321
  negative = tmp;
#line 322
  exponent = (((int )*(cptr + 7) & 127) << 4) | (((int )*(cptr + 6) >> 4) & 15);
#line 325
  upper = (((((int )*(cptr + 6) & 15) << 24) | ((int )*(cptr + 5) << 16)) | ((int )*(cptr + 4) << 8)) | (int )*(cptr + 3);
#line 326
  lower = (((int )*(cptr + 2) << 16) | ((int )*(cptr + 1) << 8)) | (int )*(cptr + 0);
#line 328
  if (exponent == 0) {
#line 328
    if (upper == 0) {
#line 328
      if (lower == 0) {
#line 329
        return (0.);
      }
    }
  }
#line 331
  dvalue = (double )upper + (double )lower / (double )16777216;
#line 332
  dvalue += (double )268435456;
#line 334
  exponent -= 1023;
#line 336
  dvalue /= (double )268435456;
#line 338
  if (negative) {
#line 339
    dvalue *= (double )-1;
  }
#line 341
  if (exponent > 0) {
    {
#line 342
    __cil_tmp8 = pow(2., (double )exponent);
#line 342
    dvalue *= __cil_tmp8;
    }
  } else
#line 343
  if (exponent < 0) {
    {
#line 344
    __cil_tmp9 = abs(exponent);
#line 344
    __cil_tmp10 = pow(2., (double )__cil_tmp9);
#line 344
    dvalue /= __cil_tmp10;
    }
  }
#line 346
  return (dvalue);
}
}
#line 350 "/root/patchweave_new/23/src/double64.c"
void double64_be_write(double in , unsigned char *out ) 
{ 
  int exponent ;
  int mantissa ;
  double __cil_tmp5 ;
  double __cil_tmp7 ;
  long __cil_tmp8 ;
  double __cil_tmp10 ;
  long __cil_tmp11 ;

  {
  {
#line 353
  memset((void *)out, 0, sizeof(double ));
#line 355
  __cil_tmp5 = fabs(in);
  }
#line 355
  if (__cil_tmp5 < 1.00000000001e-30) {
#line 356
    return;
  }
#line 358
  if (in < 0.) {
#line 359
    in *= - 1.;
#line 360
    *(out + 0) = (unsigned char )((int )*(out + 0) | 128);
  }
  {
#line 363
  in = frexp(in, & exponent);
#line 365
  exponent += 1022;
#line 367
  *(out + 0) = (unsigned char )((int )*(out + 0) | ((exponent >> 4) & 127));
#line 368
  *(out + 1) = (unsigned char )((int )*(out + 1) | ((exponent << 4) & 240));
#line 370
  in *= (double )536870912;
#line 371
  __cil_tmp7 = floor(in);
#line 371
  __cil_tmp8 = lrint(__cil_tmp7);
#line 371
  mantissa = (int )__cil_tmp8;
#line 373
  *(out + 1) = (unsigned char )((int )*(out + 1) | ((mantissa >> 24) & 15));
#line 374
  *(out + 2) = (unsigned char )((mantissa >> 16) & 255);
#line 375
  *(out + 3) = (unsigned char )((mantissa >> 8) & 255);
#line 376
  *(out + 4) = (unsigned char )(mantissa & 255);
#line 378
  in = fmod(in, 1.);
#line 379
  in *= (double )16777216;
#line 380
  __cil_tmp10 = floor(in);
#line 380
  __cil_tmp11 = lrint(__cil_tmp10);
#line 380
  mantissa = (int )__cil_tmp11;
#line 382
  *(out + 5) = (unsigned char )((mantissa >> 16) & 255);
#line 383
  *(out + 6) = (unsigned char )((mantissa >> 8) & 255);
#line 384
  *(out + 7) = (unsigned char )(mantissa & 255);
  }
#line 386
  return;
}
}
#line 390 "/root/patchweave_new/23/src/double64.c"
void double64_le_write(double in , unsigned char *out ) 
{ 
  int exponent ;
  int mantissa ;
  double __cil_tmp5 ;
  double __cil_tmp7 ;
  long __cil_tmp8 ;
  double __cil_tmp10 ;
  long __cil_tmp11 ;

  {
  {
#line 393
  memset((void *)out, 0, sizeof(double ));
#line 395
  __cil_tmp5 = fabs(in);
  }
#line 395
  if (__cil_tmp5 < 1.00000000001e-30) {
#line 396
    return;
  }
#line 398
  if (in < 0.) {
#line 399
    in *= - 1.;
#line 400
    *(out + 7) = (unsigned char )((int )*(out + 7) | 128);
  }
  {
#line 403
  in = frexp(in, & exponent);
#line 405
  exponent += 1022;
#line 407
  *(out + 7) = (unsigned char )((int )*(out + 7) | ((exponent >> 4) & 127));
#line 408
  *(out + 6) = (unsigned char )((int )*(out + 6) | ((exponent << 4) & 240));
#line 410
  in *= (double )536870912;
#line 411
  __cil_tmp7 = floor(in);
#line 411
  __cil_tmp8 = lrint(__cil_tmp7);
#line 411
  mantissa = (int )__cil_tmp8;
#line 413
  *(out + 6) = (unsigned char )((int )*(out + 6) | ((mantissa >> 24) & 15));
#line 414
  *(out + 5) = (unsigned char )((mantissa >> 16) & 255);
#line 415
  *(out + 4) = (unsigned char )((mantissa >> 8) & 255);
#line 416
  *(out + 3) = (unsigned char )(mantissa & 255);
#line 418
  in = fmod(in, 1.);
#line 419
  in *= (double )16777216;
#line 420
  __cil_tmp10 = floor(in);
#line 420
  __cil_tmp11 = lrint(__cil_tmp10);
#line 420
  mantissa = (int )__cil_tmp11;
#line 422
  *(out + 2) = (unsigned char )((mantissa >> 16) & 255);
#line 423
  *(out + 1) = (unsigned char )((mantissa >> 8) & 255);
#line 424
  *(out + 0) = (unsigned char )(mantissa & 255);
  }
#line 426
  return;
}
}
#line 434 "/root/patchweave_new/23/src/double64.c"
static void double64_peak_update(SF_PRIVATE *psf , double const   *buffer , int count___0 ,
                                 sf_count_t indx ) 
{ 
  int chan ;
  int k ;
  int position ;
  float fmaxval ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;
  double __cil_tmp11 ;

  {
#line 439
  chan = 0;
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;

#line 439
    if (! (chan < psf->sf.channels)) {
#line 439
      goto while_break;
    }
    {
#line 440
    __cil_tmp9 = fabs((double )*(buffer + chan));
#line 440
    fmaxval = (float )__cil_tmp9;
#line 441
    position = 0;
#line 442
    k = chan;
    }
    {
#line 442
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 442
      if (! (k < count___0)) {
#line 442
        goto while_break___0;
      }
      {
#line 443
      __cil_tmp10 = fabs((double )*(buffer + k));
      }
#line 443
      if ((double )fmaxval < __cil_tmp10) {
        {
#line 444
        __cil_tmp11 = fabs((double )*(buffer + k));
#line 444
        fmaxval = (float )__cil_tmp11;
#line 445
        position = k;
        }
      }
#line 442
      k += psf->sf.channels;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 448
    if ((double )fmaxval > (psf->peak_info)->peaks[chan].value) {
#line 449
      (psf->peak_info)->peaks[chan].value = (double )fmaxval;
#line 450
      (psf->peak_info)->peaks[chan].position = (psf->write_current + indx) + (long )(position / psf->sf.channels);
    }
#line 439
    chan ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 454
  return;
}
}
#line 458 "/root/patchweave_new/23/src/double64.c"
static int double64_get_capability(SF_PRIVATE *psf ) 
{ 
  union __anonunion_556 data ;
  int tmp ;

  {
#line 464
  data.d = 1.23456789013;
#line 466
  if (! psf->ieee_replace) {
#line 468
    if ((int )data.c[0] == 251) {
#line 468
      if ((int )data.c[1] == 89) {
#line 468
        if ((int )data.c[2] == 140) {
#line 468
          if ((int )data.c[3] == 66) {
#line 468
            if ((int )data.c[4] == 202) {
#line 468
              if ((int )data.c[5] == 192) {
#line 468
                if ((int )data.c[6] == 243) {
#line 468
                  if ((int )data.c[7] == 63) {
#line 470
                    return (35);
                  }
                }
              }
            }
          }
        }
      }
    }
#line 473
    if ((int )data.c[0] == 63) {
#line 473
      if ((int )data.c[1] == 243) {
#line 473
        if ((int )data.c[2] == 192) {
#line 473
          if ((int )data.c[3] == 202) {
#line 473
            if ((int )data.c[4] == 66) {
#line 473
              if ((int )data.c[5] == 140) {
#line 473
                if ((int )data.c[6] == 89) {
#line 473
                  if ((int )data.c[7] == 251) {
#line 475
                    return (52);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 479
  psf_log_printf(psf, "Using IEEE replacement code for double.\n\220");
#line 481
  tmp = 69;
  }
#line 481
  return (tmp);
}
}
#line 488 "/root/patchweave_new/23/src/double64.c"
static void d2s_array(double const   *src , int count___0 , short *dest , double scale ) 
{ 
  long __cil_tmp5 ;

  {
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    count___0 --;
#line 489
    if (! (count___0 >= 0)) {
#line 489
      goto while_break;
    }
    {
#line 490
    __cil_tmp5 = lrint(scale * (double )*(src + count___0));
#line 490
    *(dest + count___0) = (short )__cil_tmp5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 496
  return;
}
}
#line 495 "/root/patchweave_new/23/src/double64.c"
static void d2s_clip_array(double const   *src , int count___0 , short *dest , double scale ) 
{ 
  double tmp ;
  long __cil_tmp6 ;

  {
  {
#line 496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 496
    count___0 --;
#line 496
    if (! (count___0 >= 0)) {
#line 496
      goto while_break;
    }
#line 497
    tmp = scale * (double )*(src + count___0);
#line 499
    if (tmp > 32767.) {
#line 500
      *(dest + count___0) = (short)32767;
    } else
#line 501
    if (tmp < - 32768.) {
#line 502
      *(dest + count___0) = (short)-32768;
    } else {
      {
#line 504
      __cil_tmp6 = lrint(tmp);
#line 504
      *(dest + count___0) = (short )__cil_tmp6;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 511
  return;
}
}
#line 509 "/root/patchweave_new/23/src/double64.c"
static void d2i_array(double const   *src , int count___0 , int *dest , double scale ) 
{ 
  long __cil_tmp5 ;

  {
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    count___0 --;
#line 510
    if (! (count___0 >= 0)) {
#line 510
      goto while_break;
    }
    {
#line 511
    __cil_tmp5 = lrint(scale * (double )*(src + count___0));
#line 511
    *(dest + count___0) = (int )__cil_tmp5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 517
  return;
}
}
#line 516 "/root/patchweave_new/23/src/double64.c"
static void d2i_clip_array(double const   *src , int count___0 , int *dest , double scale ) 
{ 
  float tmp ;
  long __cil_tmp6 ;

  {
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    count___0 --;
#line 517
    if (! (count___0 >= 0)) {
#line 517
      goto while_break;
    }
#line 518
    tmp = (float )(scale * (double )*(src + count___0));
#line 520
    if ((double )tmp > 1. * (double )2147483647) {
#line 521
      *(dest + count___0) = 2147483647;
    } else
#line 522
    if ((double )tmp < - 1. * (double )2147483647) {
#line 523
      *(dest + count___0) = (-0x7FFFFFFF-1);
    } else {
      {
#line 525
      __cil_tmp6 = lrint((double )tmp);
#line 525
      *(dest + count___0) = (int )__cil_tmp6;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 532
  return;
}
}
#line 530 "/root/patchweave_new/23/src/double64.c"
__inline static void d2f_array___0(double const   *src , int count___0 , float *dest ) 
{ 


  {
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    count___0 --;
#line 531
    if (! (count___0 >= 0)) {
#line 531
      goto while_break;
    }
#line 532
    *(dest + count___0) = (float )*(src + count___0);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 537
  return;
}
}
#line 537 "/root/patchweave_new/23/src/double64.c"
__inline static void s2d_array(short const   *src , double *dest , int count___0 ,
                               double scale ) 
{ 


  {
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    count___0 --;
#line 538
    if (! (count___0 >= 0)) {
#line 538
      goto while_break;
    }
#line 539
    *(dest + count___0) = scale * (double )((int )*(src + count___0));
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 544
  return;
}
}
#line 544 "/root/patchweave_new/23/src/double64.c"
__inline static void i2d_array(int const   *src , double *dest , int count___0 , double scale ) 
{ 


  {
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    count___0 --;
#line 545
    if (! (count___0 >= 0)) {
#line 545
      goto while_break;
    }
#line 546
    *(dest + count___0) = scale * (double )*(src + count___0);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 551
  return;
}
}
#line 551 "/root/patchweave_new/23/src/double64.c"
__inline static void f2d_array___0(float const   *src , double *dest , int count___0 ) 
{ 


  {
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 552
    count___0 --;
#line 552
    if (! (count___0 >= 0)) {
#line 552
      goto while_break;
    }
#line 553
    *(dest + count___0) = (double )*(src + count___0);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 558
  return;
}
}
#line 561 "/root/patchweave_new/23/src/double64.c"
static sf_count_t host_read_d2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , int  , short * , double  ) ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double scale ;
  void (*tmp)(double const   *src , int count , short *dest , double scale ) ;
  double tmp___0 ;
  sf_count_t __cil_tmp12 ;

  {
#line 565
  total = (sf_count_t )0;
#line 568
  if (psf->add_clipping) {
#line 568
    tmp = & d2s_clip_array;
  } else {
#line 568
    tmp = & d2s_array;
  }
#line 568
  convert = tmp;
#line 569
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
#line 570
  if (psf->float_int_mult == 0) {
#line 570
    tmp___0 = 1.;
  } else {
#line 570
    tmp___0 = (double )((float )32767 / psf->float_max);
  }
#line 570
  scale = tmp___0;
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;

#line 572
    if (! (len > 0L)) {
#line 572
      goto while_break;
    }
#line 573
    if (len < (long )bufferlen) {
#line 574
      bufferlen = (int )len;
    }
    {
#line 575
    __cil_tmp12 = psf_fread((void *)(ubuf.dbuf), (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 575
    readcount = (int )__cil_tmp12;
    }
#line 577
    if (psf->data_endswap == 1) {
      {
#line 578
      endswap_double_array(ubuf.dbuf, readcount);
      }
    }
    {
#line 580
    (*convert)((double const   *)(ubuf.dbuf), readcount, ptr + total, scale);
#line 581
    total += (long )readcount;
#line 582
    len -= (long )readcount;
    }
#line 583
    if (readcount < bufferlen) {
#line 584
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 587
  return (total);
}
}
#line 591 "/root/patchweave_new/23/src/double64.c"
static sf_count_t host_read_d2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , int  , int * , double  ) ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double scale ;
  void (*tmp)(double const   *src , int count , int *dest , double scale ) ;
  double tmp___0 ;
  sf_count_t __cil_tmp12 ;

  {
#line 595
  total = (sf_count_t )0;
#line 598
  if (psf->add_clipping) {
#line 598
    tmp = & d2i_clip_array;
  } else {
#line 598
    tmp = & d2i_array;
  }
#line 598
  convert = tmp;
#line 599
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
#line 600
  if (psf->float_int_mult == 0) {
#line 600
    tmp___0 = 1.;
  } else {
#line 600
    tmp___0 = (double )((float )2147483647 / psf->float_max);
  }
#line 600
  scale = tmp___0;
  {
#line 602
  while (1) {
    while_continue: /* CIL Label */ ;

#line 602
    if (! (len > 0L)) {
#line 602
      goto while_break;
    }
#line 603
    if (len < (long )bufferlen) {
#line 604
      bufferlen = (int )len;
    }
    {
#line 605
    __cil_tmp12 = psf_fread((void *)(ubuf.dbuf), (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 605
    readcount = (int )__cil_tmp12;
    }
#line 607
    if (psf->data_endswap == 1) {
      {
#line 608
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 610
    (*convert)((double const   *)(ubuf.dbuf), readcount, ptr + total, scale);
#line 611
    total += (long )readcount;
#line 612
    len -= (long )readcount;
    }
#line 613
    if (readcount < bufferlen) {
#line 614
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 617
  return (total);
}
}
#line 621 "/root/patchweave_new/23/src/double64.c"
static sf_count_t host_read_d2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 624
  total = (sf_count_t )0;
#line 626
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 628
  while (1) {
    while_continue: /* CIL Label */ ;

#line 628
    if (! (len > 0L)) {
#line 628
      goto while_break;
    }
#line 629
    if (len < (long )bufferlen) {
#line 630
      bufferlen = (int )len;
    }
    {
#line 631
    __cil_tmp8 = psf_fread((void *)(ubuf.dbuf), (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                           psf);
#line 631
    readcount = (int )__cil_tmp8;
    }
#line 633
    if (psf->data_endswap == 1) {
      {
#line 634
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 636
    d2f_array___0((double const   *)(ubuf.dbuf), readcount, ptr + total);
#line 637
    total += (long )readcount;
#line 638
    len -= (long )readcount;
    }
#line 639
    if (readcount < bufferlen) {
#line 640
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 643
  return (total);
}
}
#line 647 "/root/patchweave_new/23/src/double64.c"
static sf_count_t host_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  sf_count_t readcount ;
  sf_count_t total ;

  {
  {
#line 649
  total = (sf_count_t )0;
#line 651
  readcount = psf_fread((void *)ptr, (sf_count_t )sizeof(double ), len, psf);
  }
#line 653
  if (psf->data_endswap != 1) {
#line 654
    return (readcount);
  }
#line 657
  if (readcount < 134217728L) {
    {
#line 658
    endswap_double_array(ptr, (int )readcount);
    }
#line 659
    return (readcount);
  }
#line 662
  bufferlen = 134217728;
  {
#line 663
  while (1) {
    while_continue: /* CIL Label */ ;

#line 663
    if (! (len > 0L)) {
#line 663
      goto while_break;
    }
#line 664
    if (len < (long )bufferlen) {
#line 665
      bufferlen = (int )len;
    }
    {
#line 667
    endswap_double_array(ptr + total, bufferlen);
#line 669
    total += (long )bufferlen;
#line 670
    len -= (long )bufferlen;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 673
  return (total);
}
}
#line 677 "/root/patchweave_new/23/src/double64.c"
static sf_count_t host_write_s2d(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 680
  total = (sf_count_t )0;
#line 683
  if (psf->scale_int_float == 0) {
#line 683
    tmp = 1.;
  } else {
#line 683
    tmp = 1. / (double )32768;
  }
#line 683
  scale = tmp;
#line 684
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;

#line 686
    if (! (len > 0L)) {
#line 686
      goto while_break;
    }
#line 687
    if (len < (long )bufferlen) {
#line 688
      bufferlen = (int )len;
    }
    {
#line 690
    s2d_array(ptr + total, ubuf.dbuf, bufferlen, scale);
    }
#line 692
    if (psf->peak_info) {
      {
#line 693
      double64_peak_update(psf, (double const   *)(ubuf.dbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
#line 695
    if (psf->data_endswap == 1) {
      {
#line 696
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 698
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                             (sf_count_t )bufferlen, psf);
#line 698
    writecount = (int )__cil_tmp10;
#line 699
    total += (long )writecount;
    }
#line 700
    if (writecount < bufferlen) {
#line 701
      goto while_break;
    }
#line 702
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 705
  return (total);
}
}
#line 709 "/root/patchweave_new/23/src/double64.c"
static sf_count_t host_write_i2d(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 712
  total = (sf_count_t )0;
#line 715
  if (psf->scale_int_float == 0) {
#line 715
    tmp = 1.;
  } else {
#line 715
    tmp = 1. / (8. * (double )268435456);
  }
#line 715
  scale = tmp;
#line 716
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 718
  while (1) {
    while_continue: /* CIL Label */ ;

#line 718
    if (! (len > 0L)) {
#line 718
      goto while_break;
    }
#line 719
    if (len < (long )bufferlen) {
#line 720
      bufferlen = (int )len;
    }
    {
#line 721
    i2d_array(ptr + total, ubuf.dbuf, bufferlen, scale);
    }
#line 723
    if (psf->peak_info) {
      {
#line 724
      double64_peak_update(psf, (double const   *)(ubuf.dbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
#line 726
    if (psf->data_endswap == 1) {
      {
#line 727
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 729
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                             (sf_count_t )bufferlen, psf);
#line 729
    writecount = (int )__cil_tmp10;
#line 730
    total += (long )writecount;
    }
#line 731
    if (writecount < bufferlen) {
#line 732
      goto while_break;
    }
#line 733
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 736
  return (total);
}
}
#line 740 "/root/patchweave_new/23/src/double64.c"
static sf_count_t host_write_f2d(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 743
  total = (sf_count_t )0;
#line 745
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 747
  while (1) {
    while_continue: /* CIL Label */ ;

#line 747
    if (! (len > 0L)) {
#line 747
      goto while_break;
    }
#line 748
    if (len < (long )bufferlen) {
#line 749
      bufferlen = (int )len;
    }
    {
#line 750
    f2d_array___0(ptr + total, ubuf.dbuf, bufferlen);
    }
#line 752
    if (psf->peak_info) {
      {
#line 753
      double64_peak_update(psf, (double const   *)(ubuf.dbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
#line 755
    if (psf->data_endswap == 1) {
      {
#line 756
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 758
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                            (sf_count_t )bufferlen, psf);
#line 758
    writecount = (int )__cil_tmp8;
#line 759
    total += (long )writecount;
    }
#line 760
    if (writecount < bufferlen) {
#line 761
      goto while_break;
    }
#line 762
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 765
  return (total);
}
}
#line 769 "/root/patchweave_new/23/src/double64.c"
static sf_count_t host_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 772
  total = (sf_count_t )0;
#line 774
  if (psf->peak_info) {
    {
#line 775
    double64_peak_update(psf, ptr, (int )len, (sf_count_t )0);
    }
  }
#line 777
  if (psf->data_endswap != 1) {
    {
#line 778
    __cil_tmp8 = psf_fwrite((void const   *)ptr, (sf_count_t )sizeof(double ), len,
                            psf);
    }
#line 778
    return (__cil_tmp8);
  }
#line 780
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;

#line 782
    if (! (len > 0L)) {
#line 782
      goto while_break;
    }
#line 783
    if (len < (long )bufferlen) {
#line 784
      bufferlen = (int )len;
    }
    {
#line 786
    endswap_double_copy(ubuf.dbuf, ptr + total, bufferlen);
#line 788
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                            (sf_count_t )bufferlen, psf);
#line 788
    writecount = (int )__cil_tmp9;
#line 789
    total += (long )writecount;
    }
#line 790
    if (writecount < bufferlen) {
#line 791
      goto while_break;
    }
#line 792
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 795
  return (total);
}
}
#line 802 "/root/patchweave_new/23/src/double64.c"
static sf_count_t replace_read_d2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 805
  total = (sf_count_t )0;
#line 808
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
#line 809
  if (psf->float_int_mult == 0) {
#line 809
    tmp = 1.;
  } else {
#line 809
    tmp = (double )((float )32767 / psf->float_max);
  }
#line 809
  scale = tmp;
  {
#line 811
  while (1) {
    while_continue: /* CIL Label */ ;

#line 811
    if (! (len > 0L)) {
#line 811
      goto while_break;
    }
#line 812
    if (len < (long )bufferlen) {
#line 813
      bufferlen = (int )len;
    }
    {
#line 814
    __cil_tmp10 = psf_fread((void *)(ubuf.dbuf), (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 814
    readcount = (int )__cil_tmp10;
    }
#line 816
    if (psf->data_endswap == 1) {
      {
#line 817
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 819
    d2bd_read(ubuf.dbuf, bufferlen);
#line 821
    d2s_array((double const   *)(ubuf.dbuf), readcount, ptr + total, scale);
#line 822
    total += (long )readcount;
    }
#line 823
    if (readcount < bufferlen) {
#line 824
      goto while_break;
    }
#line 825
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 828
  return (total);
}
}
#line 832 "/root/patchweave_new/23/src/double64.c"
static sf_count_t replace_read_d2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 835
  total = (sf_count_t )0;
#line 838
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
#line 839
  if (psf->float_int_mult == 0) {
#line 839
    tmp = 1.;
  } else {
#line 839
    tmp = (double )((float )2147483647 / psf->float_max);
  }
#line 839
  scale = tmp;
  {
#line 841
  while (1) {
    while_continue: /* CIL Label */ ;

#line 841
    if (! (len > 0L)) {
#line 841
      goto while_break;
    }
#line 842
    if (len < (long )bufferlen) {
#line 843
      bufferlen = (int )len;
    }
    {
#line 844
    __cil_tmp10 = psf_fread((void *)(ubuf.dbuf), (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 844
    readcount = (int )__cil_tmp10;
    }
#line 846
    if (psf->data_endswap == 1) {
      {
#line 847
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 849
    d2bd_read(ubuf.dbuf, bufferlen);
#line 851
    d2i_array((double const   *)(ubuf.dbuf), readcount, ptr + total, scale);
#line 852
    total += (long )readcount;
    }
#line 853
    if (readcount < bufferlen) {
#line 854
      goto while_break;
    }
#line 855
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 858
  return (total);
}
}
#line 862 "/root/patchweave_new/23/src/double64.c"
static sf_count_t replace_read_d2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 865
  total = (sf_count_t )0;
#line 867
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;

#line 869
    if (! (len > 0L)) {
#line 869
      goto while_break;
    }
#line 870
    if (len < (long )bufferlen) {
#line 871
      bufferlen = (int )len;
    }
    {
#line 872
    __cil_tmp8 = psf_fread((void *)(ubuf.dbuf), (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                           psf);
#line 872
    readcount = (int )__cil_tmp8;
    }
#line 874
    if (psf->data_endswap == 1) {
      {
#line 875
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 877
    d2bd_read(ubuf.dbuf, bufferlen);
#line 879
    memcpy((void *)(ptr + total), (void const   *)(ubuf.dbuf), (unsigned long )bufferlen * sizeof(double ));
#line 881
    total += (long )readcount;
    }
#line 882
    if (readcount < bufferlen) {
#line 883
      goto while_break;
    }
#line 884
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 887
  return (total);
}
}
#line 891 "/root/patchweave_new/23/src/double64.c"
static sf_count_t replace_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 894
  total = (sf_count_t )0;
#line 897
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 899
  while (1) {
    while_continue: /* CIL Label */ ;

#line 899
    if (! (len > 0L)) {
#line 899
      goto while_break;
    }
#line 900
    if (len < (long )bufferlen) {
#line 901
      bufferlen = (int )len;
    }
    {
#line 902
    __cil_tmp8 = psf_fread((void *)(ubuf.dbuf), (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                           psf);
#line 902
    readcount = (int )__cil_tmp8;
    }
#line 904
    if (psf->data_endswap == 1) {
      {
#line 905
      endswap_double_array(ubuf.dbuf, readcount);
      }
    }
    {
#line 907
    d2bd_read(ubuf.dbuf, readcount);
#line 909
    memcpy((void *)(ptr + total), (void const   *)(ubuf.dbuf), (unsigned long )readcount * sizeof(double ));
#line 911
    total += (long )readcount;
    }
#line 912
    if (readcount < bufferlen) {
#line 913
      goto while_break;
    }
#line 914
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 917
  return (total);
}
}
#line 921 "/root/patchweave_new/23/src/double64.c"
static sf_count_t replace_write_s2d(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 924
  total = (sf_count_t )0;
#line 927
  if (psf->scale_int_float == 0) {
#line 927
    tmp = 1.;
  } else {
#line 927
    tmp = 1. / (double )32768;
  }
#line 927
  scale = tmp;
#line 928
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 930
  while (1) {
    while_continue: /* CIL Label */ ;

#line 930
    if (! (len > 0L)) {
#line 930
      goto while_break;
    }
#line 931
    if (len < (long )bufferlen) {
#line 932
      bufferlen = (int )len;
    }
    {
#line 933
    s2d_array(ptr + total, ubuf.dbuf, bufferlen, scale);
    }
#line 935
    if (psf->peak_info) {
      {
#line 936
      double64_peak_update(psf, (double const   *)(ubuf.dbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
    {
#line 938
    bd2d_write(ubuf.dbuf, bufferlen);
    }
#line 940
    if (psf->data_endswap == 1) {
      {
#line 941
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 943
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                             (sf_count_t )bufferlen, psf);
#line 943
    writecount = (int )__cil_tmp10;
#line 944
    total += (long )writecount;
    }
#line 945
    if (writecount < bufferlen) {
#line 946
      goto while_break;
    }
#line 947
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 950
  return (total);
}
}
#line 954 "/root/patchweave_new/23/src/double64.c"
static sf_count_t replace_write_i2d(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 957
  total = (sf_count_t )0;
#line 960
  if (psf->scale_int_float == 0) {
#line 960
    tmp = 1.;
  } else {
#line 960
    tmp = 1. / (8. * (double )268435456);
  }
#line 960
  scale = tmp;
#line 961
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 963
  while (1) {
    while_continue: /* CIL Label */ ;

#line 963
    if (! (len > 0L)) {
#line 963
      goto while_break;
    }
#line 964
    if (len < (long )bufferlen) {
#line 965
      bufferlen = (int )len;
    }
    {
#line 966
    i2d_array(ptr + total, ubuf.dbuf, bufferlen, scale);
    }
#line 968
    if (psf->peak_info) {
      {
#line 969
      double64_peak_update(psf, (double const   *)(ubuf.dbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
    {
#line 971
    bd2d_write(ubuf.dbuf, bufferlen);
    }
#line 973
    if (psf->data_endswap == 1) {
      {
#line 974
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 976
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                             (sf_count_t )bufferlen, psf);
#line 976
    writecount = (int )__cil_tmp10;
#line 977
    total += (long )writecount;
    }
#line 978
    if (writecount < bufferlen) {
#line 979
      goto while_break;
    }
#line 980
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 983
  return (total);
}
}
#line 987 "/root/patchweave_new/23/src/double64.c"
static sf_count_t replace_write_f2d(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 990
  total = (sf_count_t )0;
#line 992
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;

#line 994
    if (! (len > 0L)) {
#line 994
      goto while_break;
    }
#line 995
    if (len < (long )bufferlen) {
#line 996
      bufferlen = (int )len;
    }
    {
#line 997
    f2d_array___0(ptr + total, ubuf.dbuf, bufferlen);
#line 999
    bd2d_write(ubuf.dbuf, bufferlen);
    }
#line 1001
    if (psf->data_endswap == 1) {
      {
#line 1002
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 1004
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                            (sf_count_t )bufferlen, psf);
#line 1004
    writecount = (int )__cil_tmp8;
#line 1005
    total += (long )writecount;
    }
#line 1006
    if (writecount < bufferlen) {
#line 1007
      goto while_break;
    }
#line 1008
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1011
  return (total);
}
}
#line 1015 "/root/patchweave_new/23/src/double64.c"
static sf_count_t replace_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1018
  total = (sf_count_t )0;
#line 1021
  if (psf->peak_info) {
    {
#line 1022
    double64_peak_update(psf, ptr, (int )len, (sf_count_t )0);
    }
  }
#line 1024
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 1026
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1026
    if (! (len > 0L)) {
#line 1026
      goto while_break;
    }
#line 1027
    if (len < (long )bufferlen) {
#line 1028
      bufferlen = (int )len;
    }
    {
#line 1030
    memcpy((void *)(ubuf.dbuf), (void const   *)(ptr + total), (unsigned long )bufferlen * sizeof(double ));
#line 1032
    bd2d_write(ubuf.dbuf, bufferlen);
    }
#line 1034
    if (psf->data_endswap == 1) {
      {
#line 1035
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 1037
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                            (sf_count_t )bufferlen, psf);
#line 1037
    writecount = (int )__cil_tmp8;
#line 1038
    total += (long )writecount;
    }
#line 1039
    if (writecount < bufferlen) {
#line 1040
      goto while_break;
    }
#line 1041
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1044
  return (total);
}
}
#line 1051 "/root/patchweave_new/23/src/double64.c"
static void d2bd_read(double *buffer , int count___0 ) 
{ 


  {
  {
#line 1052
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1052
    count___0 --;
#line 1052
    if (! (count___0 >= 0)) {
#line 1052
      goto while_break;
    }
    {
#line 1053
    *(buffer + count___0) = double64_le_read((unsigned char const   *)((unsigned char *)(buffer + count___0)));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1059
  return;
}
}
#line 1058 "/root/patchweave_new/23/src/double64.c"
static void bd2d_write(double *buffer , int count___0 ) 
{ 


  {
  {
#line 1059
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1059
    count___0 --;
#line 1059
    if (! (count___0 >= 0)) {
#line 1059
      goto while_break;
    }
    {
#line 1060
    double64_le_write(*(buffer + count___0), (unsigned char *)(buffer + count___0));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1066
  return;
}
}
#line 78 "/root/patchweave_new/23/src/dither.c"
static sf_count_t dither_read_short(SF_PRIVATE *UNUSED_psf , short *UNUSED_ptr , sf_count_t len ) ;
#line 79
static sf_count_t dither_read_int(SF_PRIVATE *UNUSED_psf , int *UNUSED_ptr , sf_count_t len ) ;
#line 81
static sf_count_t dither_write_short(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 82
static sf_count_t dither_write_int(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 83
static sf_count_t dither_write_float(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 84
static sf_count_t dither_write_double(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 87 "/root/patchweave_new/23/src/dither.c"
int dither_init(SF_PRIVATE *psf , int mode ) 
{ 
  DITHER_DATA *pdither ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 90
  pdither = (DITHER_DATA *)psf->dither;
#line 93
  if (mode == 16) {
#line 93
    if (psf->read_dither.type == 500) {
#line 94
      if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 95
        return (0);
      }
#line 97
      if (pdither->read_short) {
#line 98
        psf->read_short = pdither->read_short;
      }
#line 99
      if (pdither->read_int) {
#line 100
        psf->read_int = pdither->read_int;
      }
#line 101
      if (pdither->read_float) {
#line 102
        psf->read_float = pdither->read_float;
      }
#line 103
      if (pdither->read_double) {
#line 104
        psf->read_double = pdither->read_double;
      }
#line 105
      return (0);
    }
  }
#line 109
  if (mode == 32) {
#line 109
    if (psf->write_dither.type == 500) {
#line 110
      if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 111
        return (0);
      }
#line 113
      if (pdither->write_short) {
#line 114
        psf->write_short = pdither->write_short;
      }
#line 115
      if (pdither->write_int) {
#line 116
        psf->write_int = pdither->write_int;
      }
#line 117
      if (pdither->write_float) {
#line 118
        psf->write_float = pdither->write_float;
      }
#line 119
      if (pdither->write_double) {
#line 120
        psf->write_double = pdither->write_double;
      }
#line 121
      return (0);
    }
  }
#line 125
  if (mode == 16) {
#line 125
    if (psf->read_dither.type != 0) {
#line 126
      if ((unsigned long )pdither == (unsigned long )((void *)0)) {
        {
#line 127
        tmp = calloc(1UL, sizeof(DITHER_DATA ));
#line 127
        pdither = (DITHER_DATA *)tmp;
        }
      }
#line 128
      if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 129
        return (17);
      }
#line 133
      if ((psf->sf.format & 65535) == 6) {
#line 133
        goto case_6;
      }
#line 133
      if ((psf->sf.format & 65535) == 7) {
#line 133
        goto case_6;
      }
#line 142
      if ((psf->sf.format & 65535) == 5) {
#line 142
        goto case_5;
      }
#line 142
      if ((psf->sf.format & 65535) == 1) {
#line 142
        goto case_5;
      }
#line 142
      if ((psf->sf.format & 65535) == 2) {
#line 142
        goto case_5;
      }
#line 142
      if ((psf->sf.format & 65535) == 3) {
#line 142
        goto case_5;
      }
#line 142
      if ((psf->sf.format & 65535) == 4) {
#line 142
        goto case_5;
      }
#line 147
      goto switch_default;
      case_6: 
#line 134
      pdither->read_int = psf->read_int;
#line 135
      psf->read_int = & dither_read_int;
#line 136
      goto switch_break;
      case_5: 
#line 143
      pdither->read_short = psf->read_short;
#line 144
      psf->read_short = & dither_read_short;
#line 145
      goto switch_break;
      switch_default: 
#line 147
      goto switch_break;
      switch_break: ;
    }
  }
#line 152
  if (mode == 32) {
#line 152
    if (psf->write_dither.type != 0) {
#line 153
      if ((unsigned long )pdither == (unsigned long )((void *)0)) {
        {
#line 154
        tmp___0 = calloc(1UL, sizeof(DITHER_DATA ));
#line 154
        pdither = (DITHER_DATA *)tmp___0;
        }
      }
#line 155
      if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 156
        return (17);
      }
#line 160
      if ((psf->sf.format & 65535) == 6) {
#line 160
        goto case_6___0;
      }
#line 160
      if ((psf->sf.format & 65535) == 7) {
#line 160
        goto case_6___0;
      }
#line 169
      if ((psf->sf.format & 65535) == 5) {
#line 169
        goto case_5___0;
      }
#line 169
      if ((psf->sf.format & 65535) == 1) {
#line 169
        goto case_5___0;
      }
#line 169
      if ((psf->sf.format & 65535) == 2) {
#line 169
        goto case_5___0;
      }
#line 169
      if ((psf->sf.format & 65535) == 3) {
#line 169
        goto case_5___0;
      }
#line 169
      if ((psf->sf.format & 65535) == 4) {
#line 169
        goto case_5___0;
      }
#line 172
      goto switch_default___0;
      case_6___0: 
#line 161
      pdither->write_int = psf->write_int;
#line 162
      psf->write_int = & dither_write_int;
#line 163
      goto switch_break___0;
      case_5___0: 
#line 170
      goto switch_break___0;
      switch_default___0: 
#line 172
      goto switch_break___0;
      switch_break___0: 
#line 175
      pdither->write_short = psf->write_short;
#line 176
      psf->write_short = & dither_write_short;
#line 178
      pdither->write_int = psf->write_int;
#line 179
      psf->write_int = & dither_write_int;
#line 181
      pdither->write_float = psf->write_float;
#line 182
      psf->write_float = & dither_write_float;
#line 184
      pdither->write_double = psf->write_double;
#line 185
      psf->write_double = & dither_write_double;
    }
  }
#line 188
  return (0);
}
}
#line 194
static void dither_short(short const   *in , short *out , int frames , int channels ) ;
#line 195
static void dither_int(int const   *in , int *out , int frames , int channels ) ;
#line 197
static void dither_float(float const   *in , float *out , int frames , int channels ) ;
#line 198
static void dither_double(double const   *in , double *out , int frames , int channels ) ;
#line 201 "/root/patchweave_new/23/src/dither.c"
static sf_count_t dither_read_short(SF_PRIVATE *UNUSED_psf , short *UNUSED_ptr , sf_count_t len ) 
{ 


  {
#line 203
  return (len);
}
}
#line 207 "/root/patchweave_new/23/src/dither.c"
static sf_count_t dither_read_int(SF_PRIVATE *UNUSED_psf , int *UNUSED_ptr , sf_count_t len ) 
{ 


  {
#line 209
  return (len);
}
}
#line 216 "/root/patchweave_new/23/src/dither.c"
static sf_count_t dither_write_short(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  DITHER_DATA *pdither ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;
  int tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 219
  total = (sf_count_t )0;
#line 221
  pdither = (DITHER_DATA *)psf->dither;
#line 221
  if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 222
    psf->error = 666;
#line 223
    return ((sf_count_t )0);
  }
#line 229
  if ((psf->sf.format & 65535) == 80) {
#line 229
    goto case_80;
  }
#line 229
  if ((psf->sf.format & 65535) == 5) {
#line 229
    goto case_80;
  }
#line 229
  if ((psf->sf.format & 65535) == 1) {
#line 229
    goto case_80;
  }
#line 232
  goto switch_default;
  case_80: 
#line 230
  goto switch_break;
  switch_default: 
  {
#line 233
  __cil_tmp9 = (*(pdither->write_short))(psf, ptr, len);
  }
#line 233
  return (__cil_tmp9);
  switch_break: 
#line 236
  bufferlen = (int )(sizeof(pdither->buffer) / sizeof(short ));
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;

#line 238
    if (! (len > 0L)) {
#line 238
      goto while_break;
    }
#line 239
    if (len >= (long )bufferlen) {
#line 239
      tmp = bufferlen;
    } else {
#line 239
      tmp = (int )len;
    }
    {
#line 239
    writecount = tmp;
#line 240
    writecount /= psf->sf.channels;
#line 241
    writecount *= psf->sf.channels;
#line 243
    dither_short(ptr, (short *)(pdither->buffer), writecount / psf->sf.channels, psf->sf.channels);
#line 245
    __cil_tmp11 = (*(pdither->write_short))(psf, (short const   *)((short *)(pdither->buffer)),
                                            (sf_count_t )writecount);
#line 245
    thiswrite = (int )__cil_tmp11;
#line 246
    total += (long )thiswrite;
#line 247
    len -= (long )thiswrite;
    }
#line 248
    if (thiswrite < writecount) {
#line 249
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 252
  return (total);
}
}
#line 256 "/root/patchweave_new/23/src/dither.c"
static sf_count_t dither_write_int(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  DITHER_DATA *pdither ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;
  int tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 259
  total = (sf_count_t )0;
#line 261
  pdither = (DITHER_DATA *)psf->dither;
#line 261
  if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 262
    psf->error = 666;
#line 263
    return ((sf_count_t )0);
  }
#line 270
  if ((psf->sf.format & 65535) == 3) {
#line 270
    goto case_3;
  }
#line 270
  if ((psf->sf.format & 65535) == 2) {
#line 270
    goto case_3;
  }
#line 270
  if ((psf->sf.format & 65535) == 5) {
#line 270
    goto case_3;
  }
#line 270
  if ((psf->sf.format & 65535) == 1) {
#line 270
    goto case_3;
  }
#line 274
  if ((psf->sf.format & 65535) == 81) {
#line 274
    goto case_81;
  }
#line 274
  if ((psf->sf.format & 65535) == 80) {
#line 274
    goto case_81;
  }
#line 277
  goto switch_default;
  case_3: 
#line 271
  goto switch_break;
  case_81: 
#line 275
  goto switch_break;
  switch_default: 
  {
#line 278
  __cil_tmp9 = (*(pdither->write_int))(psf, ptr, len);
  }
#line 278
  return (__cil_tmp9);
  switch_break: 
#line 282
  bufferlen = (int )(sizeof(pdither->buffer) / sizeof(int ));
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;

#line 284
    if (! (len > 0L)) {
#line 284
      goto while_break;
    }
#line 285
    if (len >= (long )bufferlen) {
#line 285
      tmp = bufferlen;
    } else {
#line 285
      tmp = (int )len;
    }
    {
#line 285
    writecount = tmp;
#line 286
    writecount /= psf->sf.channels;
#line 287
    writecount *= psf->sf.channels;
#line 289
    dither_int(ptr, (int *)(pdither->buffer), writecount / psf->sf.channels, psf->sf.channels);
#line 291
    __cil_tmp11 = (*(pdither->write_int))(psf, (int const   *)((int *)(pdither->buffer)),
                                          (sf_count_t )writecount);
#line 291
    thiswrite = (int )__cil_tmp11;
#line 292
    total += (long )thiswrite;
#line 293
    len -= (long )thiswrite;
    }
#line 294
    if (thiswrite < writecount) {
#line 295
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 298
  return (total);
}
}
#line 302 "/root/patchweave_new/23/src/dither.c"
static sf_count_t dither_write_float(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  DITHER_DATA *pdither ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;
  float tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 305
  total = (sf_count_t )0;
#line 307
  pdither = (DITHER_DATA *)psf->dither;
#line 307
  if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 308
    psf->error = 666;
#line 309
    return ((sf_count_t )0);
  }
#line 316
  if ((psf->sf.format & 65535) == 3) {
#line 316
    goto case_3;
  }
#line 316
  if ((psf->sf.format & 65535) == 2) {
#line 316
    goto case_3;
  }
#line 316
  if ((psf->sf.format & 65535) == 5) {
#line 316
    goto case_3;
  }
#line 316
  if ((psf->sf.format & 65535) == 1) {
#line 316
    goto case_3;
  }
#line 320
  if ((psf->sf.format & 65535) == 81) {
#line 320
    goto case_81;
  }
#line 320
  if ((psf->sf.format & 65535) == 80) {
#line 320
    goto case_81;
  }
#line 323
  goto switch_default;
  case_3: 
#line 317
  goto switch_break;
  case_81: 
#line 321
  goto switch_break;
  switch_default: 
  {
#line 324
  __cil_tmp9 = (*(pdither->write_float))(psf, ptr, len);
  }
#line 324
  return (__cil_tmp9);
  switch_break: 
#line 327
  bufferlen = (int )(sizeof(pdither->buffer) / sizeof(float ));
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;

#line 329
    if (! (len > 0L)) {
#line 329
      goto while_break;
    }
#line 330
    if (len >= (long )bufferlen) {
#line 330
      tmp = (float )bufferlen;
    } else {
#line 330
      tmp = (float )len;
    }
    {
#line 330
    writecount = (int )tmp;
#line 331
    writecount /= psf->sf.channels;
#line 332
    writecount *= psf->sf.channels;
#line 334
    dither_float(ptr, (float *)(pdither->buffer), writecount / psf->sf.channels, psf->sf.channels);
#line 336
    __cil_tmp11 = (*(pdither->write_float))(psf, (float const   *)((float *)(pdither->buffer)),
                                            (sf_count_t )writecount);
#line 336
    thiswrite = (int )__cil_tmp11;
#line 337
    total += (long )thiswrite;
#line 338
    len -= (long )thiswrite;
    }
#line 339
    if (thiswrite < writecount) {
#line 340
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 343
  return (total);
}
}
#line 347 "/root/patchweave_new/23/src/dither.c"
static sf_count_t dither_write_double(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  DITHER_DATA *pdither ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 350
  total = (sf_count_t )0;
#line 352
  pdither = (DITHER_DATA *)psf->dither;
#line 352
  if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 353
    psf->error = 666;
#line 354
    return ((sf_count_t )0);
  }
#line 361
  if ((psf->sf.format & 65535) == 3) {
#line 361
    goto case_3;
  }
#line 361
  if ((psf->sf.format & 65535) == 2) {
#line 361
    goto case_3;
  }
#line 361
  if ((psf->sf.format & 65535) == 5) {
#line 361
    goto case_3;
  }
#line 361
  if ((psf->sf.format & 65535) == 1) {
#line 361
    goto case_3;
  }
#line 365
  if ((psf->sf.format & 65535) == 81) {
#line 365
    goto case_81;
  }
#line 365
  if ((psf->sf.format & 65535) == 80) {
#line 365
    goto case_81;
  }
#line 368
  goto switch_default;
  case_3: 
#line 362
  goto switch_break;
  case_81: 
#line 366
  goto switch_break;
  switch_default: 
  {
#line 369
  __cil_tmp9 = (*(pdither->write_double))(psf, ptr, len);
  }
#line 369
  return (__cil_tmp9);
  switch_break: 
#line 373
  bufferlen = (int )(sizeof(pdither->buffer) / sizeof(double ));
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;

#line 375
    if (! (len > 0L)) {
#line 375
      goto while_break;
    }
#line 376
    if (len >= (long )bufferlen) {
#line 376
      tmp = (double )bufferlen;
    } else {
#line 376
      tmp = (double )len;
    }
    {
#line 376
    writecount = (int )tmp;
#line 377
    writecount /= psf->sf.channels;
#line 378
    writecount *= psf->sf.channels;
#line 380
    dither_double(ptr, pdither->buffer, writecount / psf->sf.channels, psf->sf.channels);
#line 382
    __cil_tmp11 = (*(pdither->write_double))(psf, (double const   *)(pdither->buffer),
                                             (sf_count_t )writecount);
#line 382
    thiswrite = (int )__cil_tmp11;
#line 383
    total += (long )thiswrite;
#line 384
    len -= (long )thiswrite;
    }
#line 385
    if (thiswrite < writecount) {
#line 386
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 389
  return (total);
}
}
#line 396 "/root/patchweave_new/23/src/dither.c"
static void dither_short(short const   *in , short *out , int frames , int channels ) 
{ 
  int ch ;
  int k ;

  {
#line 399
  ch = 0;
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;

#line 399
    if (! (ch < channels)) {
#line 399
      goto while_break;
    }
#line 400
    k = ch;
    {
#line 400
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 400
      if (! (k < channels * frames)) {
#line 400
        goto while_break___0;
      }
#line 401
      *(out + k) = (short )*(in + k);
#line 400
      k += channels;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 399
    ch ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 403
  return;
}
}
#line 406 "/root/patchweave_new/23/src/dither.c"
static void dither_int(int const   *in , int *out , int frames , int channels ) 
{ 
  int ch ;
  int k ;

  {
#line 409
  ch = 0;
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;

#line 409
    if (! (ch < channels)) {
#line 409
      goto while_break;
    }
#line 410
    k = ch;
    {
#line 410
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 410
      if (! (k < channels * frames)) {
#line 410
        goto while_break___0;
      }
#line 411
      *(out + k) = (int )*(in + k);
#line 410
      k += channels;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 409
    ch ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 413
  return;
}
}
#line 416 "/root/patchweave_new/23/src/dither.c"
static void dither_float(float const   *in , float *out , int frames , int channels ) 
{ 
  int ch ;
  int k ;

  {
#line 419
  ch = 0;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;

#line 419
    if (! (ch < channels)) {
#line 419
      goto while_break;
    }
#line 420
    k = ch;
    {
#line 420
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 420
      if (! (k < channels * frames)) {
#line 420
        goto while_break___0;
      }
#line 421
      *(out + k) = (float )*(in + k);
#line 420
      k += channels;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 419
    ch ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 423
  return;
}
}
#line 426 "/root/patchweave_new/23/src/dither.c"
static void dither_double(double const   *in , double *out , int frames , int channels ) 
{ 
  int ch ;
  int k ;

  {
#line 429
  ch = 0;
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;

#line 429
    if (! (ch < channels)) {
#line 429
      goto while_break;
    }
#line 430
    k = ch;
    {
#line 430
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 430
      if (! (k < channels * frames)) {
#line 430
        goto while_break___0;
      }
#line 431
      *(out + k) = (double )*(in + k);
#line 430
      k += channels;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 429
    ch ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 433
  return;
}
}
#line 66 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 42 "/root/patchweave_new/23/src/common.c"
SF_PRIVATE *psf_allocate(void) 
{ 
  SF_PRIVATE *psf ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 45
  tmp = calloc(1UL, sizeof(SF_PRIVATE ));
#line 45
  psf = (SF_PRIVATE *)tmp;
  }
#line 45
  if ((unsigned long )psf == (unsigned long )((void *)0)) {
#line 46
    return ((SF_PRIVATE *)((void *)0));
  }
  {
#line 48
  tmp___0 = calloc(1UL, 256UL);
#line 48
  psf->header.ptr = (unsigned char *)tmp___0;
  }
#line 48
  if ((unsigned long )psf->header.ptr == (unsigned long )((void *)0)) {
    {
#line 49
    free((void *)psf);
    }
#line 50
    return ((SF_PRIVATE *)((void *)0));
  }
#line 52
  psf->header.len = (sf_count_t )256;
#line 54
  return (psf);
}
}
#line 58 "/root/patchweave_new/23/src/common.c"
static int psf_bump_header_allocation(SF_PRIVATE *psf , sf_count_t needed ) 
{ 
  sf_count_t newlen ;
  sf_count_t smallest ;
  void *ptr ;
  long tmp ;

  {
#line 60
  smallest = (sf_count_t )256;
#line 63
  if (needed > psf->header.len) {
#line 63
    tmp = 0L;
  } else {
#line 63
    tmp = 2L * psf->header.len;
  }
#line 63
  newlen = tmp;
#line 65
  if (newlen > 102400L) {
    {
#line 66
    psf_log_printf(psf, "Request for header allocation of %D denined.\n", newlen);
    }
#line 67
    return (1);
  }
  {
#line 70
  ptr = realloc((void *)psf->header.ptr, (unsigned long )newlen);
  }
#line 70
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 71
    psf_log_printf(psf, "realloc (%p, %D) failed\n\230\001", psf->header.ptr, newlen);
#line 72
    psf->error = 17;
    }
#line 73
    return (1);
  }
#line 76
  psf->header.ptr = (unsigned char *)ptr;
#line 77
  psf->header.len = newlen;
#line 78
  return (0);
}
}
#line 91 "/root/patchweave_new/23/src/common.c"
__inline static void log_putchar(SF_PRIVATE *psf , char ch ) 
{ 
  int __cil_tmp3 ;

  {
#line 92
  if (psf->parselog.indx < (int )sizeof(psf->parselog.buf) - 1) {
#line 93
    __cil_tmp3 = psf->parselog.indx;
#line 93
    (psf->parselog.indx) ++;
#line 93
    psf->parselog.buf[__cil_tmp3] = ch;
#line 94
    psf->parselog.buf[psf->parselog.indx] = (char)0;
  }
#line 96
  return;
}
}
#line 100 "/root/patchweave_new/23/src/common.c"
void psf_log_printf(SF_PRIVATE *psf , char const   *format  , ...) 
{ 
  va_list ap ;
  uint32_t u ;
  int d ;
  int tens ;
  int shift ;
  int width ;
  int width_specifier ;
  int left_align ;
  int slen ;
  char c ;
  char *strptr ;
  char istr[5] ;
  char lead_char ;
  char sign_char ;
  char const   *__cil_tmp17 ;
  char const   *__cil_tmp21 ;
  unsigned short const   **__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int tmp ;
  int __cil_tmp25 ;
  char *__cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  sf_count_t D ;
  sf_count_t Tens ;
  int __cil_tmp39 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int tmp___0 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int tmp___1 ;
  char *__cil_tmp51 ;

  {
  {
#line 106
  __builtin_va_start((__builtin_va_list )((void *)ap), format);
  }
  {
#line 108
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: 
#line 108
    __cil_tmp17 = format;
#line 108
    format ++;
#line 108
    c = (char )*__cil_tmp17;
#line 108
    if (! c) {
#line 108
      goto while_break;
    }
#line 109
    if ((int )c != 37) {
      {
#line 110
      log_putchar(psf, c);
      }
#line 111
      goto while_continue;
    }
#line 114
    if ((int )*(format + 0) == 37) {
      {
#line 115
      log_putchar(psf, (char )'%');
#line 116
      format ++;
      }
#line 117
      goto while_continue;
    }
#line 120
    sign_char = (char)0;
#line 121
    left_align = 0;
    {
#line 122
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: ;
#line 125
      if ((int )*(format + 0) == 43) {
#line 125
        goto case_43;
      }
#line 125
      if ((int )*(format + 0) == 32) {
#line 125
        goto case_43;
      }
#line 130
      if ((int )*(format + 0) == 45) {
#line 130
        goto case_45;
      }
#line 135
      goto switch_default;
      case_43: 
#line 126
      sign_char = (char )*(format + 0);
#line 127
      format ++;
#line 128
      goto while_continue___0;
      case_45: 
#line 131
      left_align = 1;
#line 132
      format ++;
#line 133
      goto while_continue___0;
      switch_default: 
#line 135
      goto switch_break;
      switch_break: ;
#line 138
      goto while_break___0;
    }
    while_break___25: /* CIL Label */ ;
    }
    while_break___0: ;
#line 141
    if ((int )*(format + 0) == 0) {
#line 142
      goto while_break;
    }
#line 144
    lead_char = (char )' ';
#line 145
    if ((int )*(format + 0) == 48) {
#line 146
      lead_char = (char )'0';
    }
#line 148
    width_specifier = 0;
    {
#line 149
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 149
      __cil_tmp22 = __ctype_b_loc();
#line 149
      __cil_tmp21 = format;
#line 149
      format ++;
#line 149
      c = (char )*__cil_tmp21;
      }
#line 149
      if ((int )c) {
#line 149
        if (! ((int )*(*__cil_tmp22 + (int )c) & 2048)) {
#line 149
          goto while_break___1;
        }
      } else {
#line 149
        goto while_break___1;
      }
#line 150
      width_specifier = width_specifier * 10 + ((int )c - 48);
    }
    while_break___26: /* CIL Label */ ;
    }
    while_break___1: ;
#line 153
    if ((int )c == 0) {
#line 153
      goto case_0;
    }
#line 157
    if ((int )c == 115) {
#line 157
      goto case_115;
    }
#line 172
    if ((int )c == 100) {
#line 172
      goto case_100;
    }
#line 223
    if ((int )c == 68) {
#line 223
      goto case_68;
    }
#line 258
    if ((int )c == 117) {
#line 258
      goto case_117;
    }
#line 302
    if ((int )c == 99) {
#line 302
      goto case_99;
    }
#line 308
    if ((int )c == 88) {
#line 308
      goto case_88;
    }
#line 308
    if ((int )c == 120) {
#line 308
      goto case_88;
    }
#line 336
    if ((int )c == 77) {
#line 336
      goto case_77;
    }
#line 358
    goto switch_default___0;
    case_0: 
    {
#line 154
    __builtin_va_end((__builtin_va_list )((void *)ap));
    }
#line 155
    return;
    case_115: 
#line 158
    strptr = (char *)0;
#line 159
    if ((unsigned long )strptr == (unsigned long )((void *)0)) {
#line 160
      goto switch_break___0;
    }
    {
#line 161
    __cil_tmp23 = strlen((char const   *)strptr);
#line 161
    slen = (int )__cil_tmp23;
    }
#line 162
    if (width_specifier >= slen) {
#line 162
      tmp = width_specifier - slen;
    } else {
#line 162
      tmp = 0;
    }
#line 162
    width_specifier = tmp;
#line 163
    if (left_align == 0) {
      {
#line 164
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 164
        __cil_tmp25 = width_specifier;
#line 164
        width_specifier --;
#line 164
        if (! (__cil_tmp25 > 0)) {
#line 164
          goto while_break___2;
        }
        {
#line 165
        log_putchar(psf, (char )' ');
        }
      }
      while_break___27: /* CIL Label */ ;
      }
      while_break___2: ;
    }
    {
#line 166
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 166
      if (! *strptr) {
#line 166
        goto while_break___3;
      }
      {
#line 167
      __cil_tmp26 = strptr;
#line 167
      strptr ++;
#line 167
      log_putchar(psf, *__cil_tmp26);
      }
    }
    while_break___28: /* CIL Label */ ;
    }
    while_break___3: ;
    {
#line 168
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 168
      __cil_tmp27 = width_specifier;
#line 168
      width_specifier --;
#line 168
      if (! (__cil_tmp27 > 0)) {
#line 168
        goto while_break___4;
      }
      {
#line 169
      log_putchar(psf, (char )' ');
      }
    }
    while_break___29: /* CIL Label */ ;
    }
    while_break___4: ;
#line 170
    goto switch_break___0;
    case_100: 
#line 173
    d = 0;
#line 175
    if (d < 0) {
#line 176
      d = - d;
#line 177
      sign_char = (char )'-';
#line 178
      if ((int )lead_char != 48) {
#line 178
        if (left_align == 0) {
#line 179
          __cil_tmp28 = width_specifier;
#line 179
          width_specifier --;
        }
      }
    }
#line 182
    tens = 1;
#line 183
    width = 1;
    {
#line 184
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 184
      if (! (d / tens >= 10)) {
#line 184
        goto while_break___5;
      }
#line 185
      tens *= 10;
#line 186
      width ++;
    }
    while_break___30: /* CIL Label */ ;
    }
    while_break___5: 
#line 189
    width_specifier -= width;
#line 191
    if ((int )sign_char == 32) {
      {
#line 192
      log_putchar(psf, (char )' ');
#line 193
      __cil_tmp30 = width_specifier;
#line 193
      width_specifier --;
      }
    }
#line 196
    if (left_align == 0) {
#line 196
      if ((int )lead_char != 48) {
#line 197
        if ((int )sign_char == 43) {
#line 198
          __cil_tmp31 = width_specifier;
#line 198
          width_specifier --;
        }
        {
#line 200
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 200
          __cil_tmp32 = width_specifier;
#line 200
          width_specifier --;
#line 200
          if (! (__cil_tmp32 > 0)) {
#line 200
            goto while_break___6;
          }
          {
#line 201
          log_putchar(psf, lead_char);
          }
        }
        while_break___31: /* CIL Label */ ;
        }
        while_break___6: ;
      }
    }
#line 204
    if ((int )sign_char == 43) {
      {
#line 205
      log_putchar(psf, sign_char);
#line 206
      __cil_tmp33 = width_specifier;
#line 206
      width_specifier --;
      }
    } else
#line 204
    if ((int )sign_char == 45) {
      {
#line 205
      log_putchar(psf, sign_char);
#line 206
      __cil_tmp33 = width_specifier;
#line 206
      width_specifier --;
      }
    }
#line 209
    if (left_align == 0) {
      {
#line 210
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 210
        __cil_tmp34 = width_specifier;
#line 210
        width_specifier --;
#line 210
        if (! (__cil_tmp34 > 0)) {
#line 210
          goto while_break___7;
        }
        {
#line 211
        log_putchar(psf, lead_char);
        }
      }
      while_break___32: /* CIL Label */ ;
      }
      while_break___7: ;
    }
    {
#line 213
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 213
      if (! (tens > 0)) {
#line 213
        goto while_break___8;
      }
      {
#line 214
      log_putchar(psf, (char )(48 + d / tens));
#line 215
      d %= tens;
#line 216
      tens /= 10;
      }
    }
    while_break___33: /* CIL Label */ ;
    }
    while_break___8: ;
    {
#line 219
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 219
      __cil_tmp35 = width_specifier;
#line 219
      width_specifier --;
#line 219
      if (! (__cil_tmp35 > 0)) {
#line 219
        goto while_break___9;
      }
      {
#line 220
      log_putchar(psf, lead_char);
      }
    }
    while_break___34: /* CIL Label */ ;
    }
    while_break___9: ;
#line 221
    goto switch_break___0;
    case_68: 
#line 226
    D = (sf_count_t )0;
#line 228
    if (D == 0L) {
      {
#line 229
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 229
        width_specifier --;
#line 229
        if (! (width_specifier > 0)) {
#line 229
          goto while_break___10;
        }
        {
#line 230
        log_putchar(psf, lead_char);
        }
      }
      while_break___35: /* CIL Label */ ;
      }
      while_break___10: 
      {
#line 231
      log_putchar(psf, (char )'0');
      }
#line 232
      goto switch_break___0;
    }
#line 234
    if (D < 0L) {
      {
#line 235
      log_putchar(psf, (char )'-');
#line 236
      D = - D;
      }
    }
#line 238
    Tens = (sf_count_t )1;
#line 239
    width = 1;
    {
#line 240
    while (1) {
      while_continue___13: /* CIL Label */ ;

#line 240
      if (! (D / Tens >= 10L)) {
#line 240
        goto while_break___11;
      }
#line 241
      Tens *= 10L;
#line 242
      width ++;
    }
    while_break___36: /* CIL Label */ ;
    }
    while_break___11: ;
    {
#line 245
    while (1) {
      while_continue___14: /* CIL Label */ ;

#line 245
      if (! (width_specifier > width)) {
#line 245
        goto while_break___12;
      }
      {
#line 246
      log_putchar(psf, lead_char);
#line 247
      __cil_tmp39 = width_specifier;
#line 247
      width_specifier --;
      }
    }
    while_break___37: /* CIL Label */ ;
    }
    while_break___12: ;
    {
#line 250
    while (1) {
      while_continue___15: /* CIL Label */ ;

#line 250
      if (! (Tens > 0L)) {
#line 250
        goto while_break___13;
      }
      {
#line 251
      log_putchar(psf, (char )(48L + D / Tens));
#line 252
      D %= Tens;
#line 253
      Tens /= 10L;
      }
    }
    while_break___38: /* CIL Label */ ;
    }
    while_break___13: ;
#line 256
    goto switch_break___0;
    case_117: 
#line 259
    u = (uint32_t )0;
#line 261
    tens = 1;
#line 262
    width = 1;
    {
#line 263
    while (1) {
      while_continue___16: /* CIL Label */ ;

#line 263
      if (! (u / (unsigned int )tens >= 10U)) {
#line 263
        goto while_break___14;
      }
#line 264
      tens *= 10;
#line 265
      width ++;
    }
    while_break___39: /* CIL Label */ ;
    }
    while_break___14: 
#line 268
    width_specifier -= width;
#line 270
    if ((int )sign_char == 32) {
      {
#line 271
      log_putchar(psf, (char )' ');
#line 272
      __cil_tmp41 = width_specifier;
#line 272
      width_specifier --;
      }
    }
#line 275
    if (left_align == 0) {
#line 275
      if ((int )lead_char != 48) {
#line 276
        if ((int )sign_char == 43) {
#line 277
          __cil_tmp42 = width_specifier;
#line 277
          width_specifier --;
        }
        {
#line 279
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 279
          __cil_tmp43 = width_specifier;
#line 279
          width_specifier --;
#line 279
          if (! (__cil_tmp43 > 0)) {
#line 279
            goto while_break___15;
          }
          {
#line 280
          log_putchar(psf, lead_char);
          }
        }
        while_break___40: /* CIL Label */ ;
        }
        while_break___15: ;
      }
    }
#line 283
    if ((int )sign_char == 43) {
      {
#line 284
      log_putchar(psf, sign_char);
#line 285
      __cil_tmp44 = width_specifier;
#line 285
      width_specifier --;
      }
    } else
#line 283
    if ((int )sign_char == 45) {
      {
#line 284
      log_putchar(psf, sign_char);
#line 285
      __cil_tmp44 = width_specifier;
#line 285
      width_specifier --;
      }
    }
#line 288
    if (left_align == 0) {
      {
#line 289
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 289
        __cil_tmp45 = width_specifier;
#line 289
        width_specifier --;
#line 289
        if (! (__cil_tmp45 > 0)) {
#line 289
          goto while_break___16;
        }
        {
#line 290
        log_putchar(psf, lead_char);
        }
      }
      while_break___41: /* CIL Label */ ;
      }
      while_break___16: ;
    }
    {
#line 292
    while (1) {
      while_continue___19: /* CIL Label */ ;

#line 292
      if (! (tens > 0)) {
#line 292
        goto while_break___17;
      }
      {
#line 293
      log_putchar(psf, (char )(48U + u / (unsigned int )tens));
#line 294
      u %= (unsigned int )tens;
#line 295
      tens /= 10;
      }
    }
    while_break___42: /* CIL Label */ ;
    }
    while_break___17: ;
    {
#line 298
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 298
      __cil_tmp46 = width_specifier;
#line 298
      width_specifier --;
#line 298
      if (! (__cil_tmp46 > 0)) {
#line 298
        goto while_break___18;
      }
      {
#line 299
      log_putchar(psf, lead_char);
      }
    }
    while_break___43: /* CIL Label */ ;
    }
    while_break___18: ;
#line 300
    goto switch_break___0;
    case_99: 
    {
#line 303
    c = (char)0;
#line 304
    log_putchar(psf, c);
    }
#line 305
    goto switch_break___0;
    case_88: 
#line 309
    d = 0;
#line 311
    if (d == 0) {
      {
#line 312
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 312
        width_specifier --;
#line 312
        if (! (width_specifier > 0)) {
#line 312
          goto while_break___19;
        }
        {
#line 313
        log_putchar(psf, lead_char);
        }
      }
      while_break___44: /* CIL Label */ ;
      }
      while_break___19: 
      {
#line 314
      log_putchar(psf, (char )'0');
      }
#line 315
      goto switch_break___0;
    }
#line 317
    shift = 28;
#line 318
    if (width_specifier < 8) {
#line 318
      tmp___0 = 8;
    } else {
#line 318
      tmp___0 = width_specifier;
    }
#line 318
    width = tmp___0;
    {
#line 319
    while (1) {
      while_continue___22: /* CIL Label */ ;

#line 319
      if (! (! ((15U << shift) & (unsigned int )d))) {
#line 319
        goto while_break___20;
      }
#line 320
      shift -= 4;
#line 321
      __cil_tmp48 = width;
#line 321
      width --;
    }
    while_break___45: /* CIL Label */ ;
    }
    while_break___20: ;
    {
#line 324
    while (1) {
      while_continue___23: /* CIL Label */ ;

#line 324
      if (width > 0) {
#line 324
        if (! (width_specifier > width)) {
#line 324
          goto while_break___21;
        }
      } else {
#line 324
        goto while_break___21;
      }
      {
#line 325
      log_putchar(psf, lead_char);
#line 326
      __cil_tmp49 = width_specifier;
#line 326
      width_specifier --;
      }
    }
    while_break___46: /* CIL Label */ ;
    }
    while_break___21: ;
    {
#line 329
    while (1) {
      while_continue___24: /* CIL Label */ ;

#line 329
      if (! (shift >= 0)) {
#line 329
        goto while_break___22;
      }
#line 330
      c = (char )((d >> shift) & 15);
#line 331
      if ((int )c > 9) {
#line 331
        tmp___1 = ((int )c + 65) - 10;
      } else {
#line 331
        tmp___1 = (int )c + 48;
      }
      {
#line 331
      log_putchar(psf, (char )tmp___1);
#line 332
      shift -= 4;
      }
    }
    while_break___47: /* CIL Label */ ;
    }
    while_break___22: ;
#line 334
    goto switch_break___0;
    case_77: 
#line 337
    d = 0;
#line 339
    istr[0] = (char )(d & 255);
#line 340
    istr[1] = (char )((d >> 8) & 255);
#line 341
    istr[2] = (char )((d >> 16) & 255);
#line 342
    istr[3] = (char )((d >> 24) & 255);
#line 350
    istr[4] = (char)0;
#line 351
    strptr = istr;
    {
#line 352
    while (1) {
      while_continue___25: /* CIL Label */ ;

#line 352
      if (! *strptr) {
#line 352
        goto while_break___23;
      }
      {
#line 353
      __cil_tmp51 = strptr;
#line 353
      strptr ++;
#line 353
      c = *__cil_tmp51;
#line 354
      log_putchar(psf, c);
      }
    }
    while_break___48: /* CIL Label */ ;
    }
    while_break___23: ;
#line 356
    goto switch_break___0;
    switch_default___0: 
    {
#line 359
    log_putchar(psf, (char )'*');
#line 360
    log_putchar(psf, c);
#line 361
    log_putchar(psf, (char )'*');
    }
#line 362
    goto switch_break___0;
    switch_break___0: ;
  }
  while_break___24: /* CIL Label */ ;
  }
  while_break: 
  {
#line 366
  __builtin_va_end((__builtin_va_list )((void *)ap));
  }
#line 367
  return;
}
}
#line 379 "/root/patchweave_new/23/src/common.c"
void psf_asciiheader_printf(SF_PRIVATE *psf , char const   *format  , ...) 
{ 
  va_list argptr ;
  int maxlen ;
  char *start ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
  {
#line 384
  __cil_tmp6 = strlen((char const   *)((char *)psf->header.ptr));
#line 384
  maxlen = (int )__cil_tmp6;
#line 385
  start = (char *)psf->header.ptr + maxlen;
#line 386
  maxlen = (int )(psf->header.len - (long )maxlen);
#line 388
  __builtin_va_start((__builtin_va_list )((void *)argptr), format);
#line 389
  vsnprintf(start, (unsigned long )maxlen, format, (__gnuc_va_list )((void *)argptr));
#line 390
  __builtin_va_end((__builtin_va_list )((void *)argptr));
#line 393
  *(start + (maxlen - 1)) = (char)0;
#line 395
  __cil_tmp7 = strlen((char const   *)((char *)psf->header.ptr));
#line 395
  psf->header.indx = (sf_count_t )__cil_tmp7;
  }
#line 397
  return;
}
}
#line 447 "/root/patchweave_new/23/src/common.c"
__inline static void header_put_byte(SF_PRIVATE *psf , char x ) 
{ 
  sf_count_t __cil_tmp3 ;

  {
#line 448
  __cil_tmp3 = psf->header.indx;
#line 448
  (psf->header.indx) ++;
#line 448
  *(psf->header.ptr + __cil_tmp3) = (unsigned char )x;
#line 449
  return;
}
}
#line 462 "/root/patchweave_new/23/src/common.c"
__inline static void header_put_marker(SF_PRIVATE *psf , int x ) 
{ 
  sf_count_t __cil_tmp3 ;
  sf_count_t __cil_tmp4 ;
  sf_count_t __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;

  {
#line 463
  __cil_tmp3 = psf->header.indx;
#line 463
  (psf->header.indx) ++;
#line 463
  *(psf->header.ptr + __cil_tmp3) = (unsigned char )x;
#line 464
  __cil_tmp4 = psf->header.indx;
#line 464
  (psf->header.indx) ++;
#line 464
  *(psf->header.ptr + __cil_tmp4) = (unsigned char )(x >> 8);
#line 465
  __cil_tmp5 = psf->header.indx;
#line 465
  (psf->header.indx) ++;
#line 465
  *(psf->header.ptr + __cil_tmp5) = (unsigned char )(x >> 16);
#line 466
  __cil_tmp6 = psf->header.indx;
#line 466
  (psf->header.indx) ++;
#line 466
  *(psf->header.ptr + __cil_tmp6) = (unsigned char )(x >> 24);
#line 467
  return;
}
}
#line 475 "/root/patchweave_new/23/src/common.c"
__inline static void header_put_be_short(SF_PRIVATE *psf , int x ) 
{ 
  sf_count_t __cil_tmp3 ;
  sf_count_t __cil_tmp4 ;

  {
#line 476
  __cil_tmp3 = psf->header.indx;
#line 476
  (psf->header.indx) ++;
#line 476
  *(psf->header.ptr + __cil_tmp3) = (unsigned char )(x >> 8);
#line 477
  __cil_tmp4 = psf->header.indx;
#line 477
  (psf->header.indx) ++;
#line 477
  *(psf->header.ptr + __cil_tmp4) = (unsigned char )x;
#line 478
  return;
}
}
#line 481 "/root/patchweave_new/23/src/common.c"
__inline static void header_put_le_short(SF_PRIVATE *psf , int x ) 
{ 
  sf_count_t __cil_tmp3 ;
  sf_count_t __cil_tmp4 ;

  {
#line 482
  __cil_tmp3 = psf->header.indx;
#line 482
  (psf->header.indx) ++;
#line 482
  *(psf->header.ptr + __cil_tmp3) = (unsigned char )x;
#line 483
  __cil_tmp4 = psf->header.indx;
#line 483
  (psf->header.indx) ++;
#line 483
  *(psf->header.ptr + __cil_tmp4) = (unsigned char )(x >> 8);
#line 484
  return;
}
}
#line 487 "/root/patchweave_new/23/src/common.c"
__inline static void header_put_be_3byte(SF_PRIVATE *psf , int x ) 
{ 
  sf_count_t __cil_tmp3 ;
  sf_count_t __cil_tmp4 ;
  sf_count_t __cil_tmp5 ;

  {
#line 488
  __cil_tmp3 = psf->header.indx;
#line 488
  (psf->header.indx) ++;
#line 488
  *(psf->header.ptr + __cil_tmp3) = (unsigned char )(x >> 16);
#line 489
  __cil_tmp4 = psf->header.indx;
#line 489
  (psf->header.indx) ++;
#line 489
  *(psf->header.ptr + __cil_tmp4) = (unsigned char )(x >> 8);
#line 490
  __cil_tmp5 = psf->header.indx;
#line 490
  (psf->header.indx) ++;
#line 490
  *(psf->header.ptr + __cil_tmp5) = (unsigned char )x;
#line 491
  return;
}
}
#line 494 "/root/patchweave_new/23/src/common.c"
__inline static void header_put_le_3byte(SF_PRIVATE *psf , int x ) 
{ 
  sf_count_t __cil_tmp3 ;
  sf_count_t __cil_tmp4 ;
  sf_count_t __cil_tmp5 ;

  {
#line 495
  __cil_tmp3 = psf->header.indx;
#line 495
  (psf->header.indx) ++;
#line 495
  *(psf->header.ptr + __cil_tmp3) = (unsigned char )x;
#line 496
  __cil_tmp4 = psf->header.indx;
#line 496
  (psf->header.indx) ++;
#line 496
  *(psf->header.ptr + __cil_tmp4) = (unsigned char )(x >> 8);
#line 497
  __cil_tmp5 = psf->header.indx;
#line 497
  (psf->header.indx) ++;
#line 497
  *(psf->header.ptr + __cil_tmp5) = (unsigned char )(x >> 16);
#line 498
  return;
}
}
#line 501 "/root/patchweave_new/23/src/common.c"
__inline static void header_put_be_int(SF_PRIVATE *psf , int x ) 
{ 
  sf_count_t __cil_tmp3 ;
  sf_count_t __cil_tmp4 ;
  sf_count_t __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;

  {
#line 502
  __cil_tmp3 = psf->header.indx;
#line 502
  (psf->header.indx) ++;
#line 502
  *(psf->header.ptr + __cil_tmp3) = (unsigned char )(x >> 24);
#line 503
  __cil_tmp4 = psf->header.indx;
#line 503
  (psf->header.indx) ++;
#line 503
  *(psf->header.ptr + __cil_tmp4) = (unsigned char )(x >> 16);
#line 504
  __cil_tmp5 = psf->header.indx;
#line 504
  (psf->header.indx) ++;
#line 504
  *(psf->header.ptr + __cil_tmp5) = (unsigned char )(x >> 8);
#line 505
  __cil_tmp6 = psf->header.indx;
#line 505
  (psf->header.indx) ++;
#line 505
  *(psf->header.ptr + __cil_tmp6) = (unsigned char )x;
#line 506
  return;
}
}
#line 519 "/root/patchweave_new/23/src/common.c"
__inline static void header_put_be_8byte(SF_PRIVATE *psf , sf_count_t x ) 
{ 
  sf_count_t __cil_tmp3 ;
  sf_count_t __cil_tmp4 ;
  sf_count_t __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;
  sf_count_t __cil_tmp10 ;

  {
#line 520
  __cil_tmp3 = psf->header.indx;
#line 520
  (psf->header.indx) ++;
#line 520
  *(psf->header.ptr + __cil_tmp3) = (unsigned char )(x >> 56);
#line 521
  __cil_tmp4 = psf->header.indx;
#line 521
  (psf->header.indx) ++;
#line 521
  *(psf->header.ptr + __cil_tmp4) = (unsigned char )(x >> 48);
#line 522
  __cil_tmp5 = psf->header.indx;
#line 522
  (psf->header.indx) ++;
#line 522
  *(psf->header.ptr + __cil_tmp5) = (unsigned char )(x >> 40);
#line 523
  __cil_tmp6 = psf->header.indx;
#line 523
  (psf->header.indx) ++;
#line 523
  *(psf->header.ptr + __cil_tmp6) = (unsigned char )(x >> 32);
#line 524
  __cil_tmp7 = psf->header.indx;
#line 524
  (psf->header.indx) ++;
#line 524
  *(psf->header.ptr + __cil_tmp7) = (unsigned char )(x >> 24);
#line 525
  __cil_tmp8 = psf->header.indx;
#line 525
  (psf->header.indx) ++;
#line 525
  *(psf->header.ptr + __cil_tmp8) = (unsigned char )(x >> 16);
#line 526
  __cil_tmp9 = psf->header.indx;
#line 526
  (psf->header.indx) ++;
#line 526
  *(psf->header.ptr + __cil_tmp9) = (unsigned char )(x >> 8);
#line 527
  __cil_tmp10 = psf->header.indx;
#line 527
  (psf->header.indx) ++;
#line 527
  *(psf->header.ptr + __cil_tmp10) = (unsigned char )x;
#line 528
  return;
}
}
#line 531 "/root/patchweave_new/23/src/common.c"
__inline static void header_put_le_8byte(SF_PRIVATE *psf , sf_count_t x ) 
{ 
  sf_count_t __cil_tmp3 ;
  sf_count_t __cil_tmp4 ;
  sf_count_t __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;
  sf_count_t __cil_tmp10 ;

  {
#line 532
  __cil_tmp3 = psf->header.indx;
#line 532
  (psf->header.indx) ++;
#line 532
  *(psf->header.ptr + __cil_tmp3) = (unsigned char )x;
#line 533
  __cil_tmp4 = psf->header.indx;
#line 533
  (psf->header.indx) ++;
#line 533
  *(psf->header.ptr + __cil_tmp4) = (unsigned char )(x >> 8);
#line 534
  __cil_tmp5 = psf->header.indx;
#line 534
  (psf->header.indx) ++;
#line 534
  *(psf->header.ptr + __cil_tmp5) = (unsigned char )(x >> 16);
#line 535
  __cil_tmp6 = psf->header.indx;
#line 535
  (psf->header.indx) ++;
#line 535
  *(psf->header.ptr + __cil_tmp6) = (unsigned char )(x >> 24);
#line 536
  __cil_tmp7 = psf->header.indx;
#line 536
  (psf->header.indx) ++;
#line 536
  *(psf->header.ptr + __cil_tmp7) = (unsigned char )(x >> 32);
#line 537
  __cil_tmp8 = psf->header.indx;
#line 537
  (psf->header.indx) ++;
#line 537
  *(psf->header.ptr + __cil_tmp8) = (unsigned char )(x >> 40);
#line 538
  __cil_tmp9 = psf->header.indx;
#line 538
  (psf->header.indx) ++;
#line 538
  *(psf->header.ptr + __cil_tmp9) = (unsigned char )(x >> 48);
#line 539
  __cil_tmp10 = psf->header.indx;
#line 539
  (psf->header.indx) ++;
#line 539
  *(psf->header.ptr + __cil_tmp10) = (unsigned char )(x >> 56);
#line 540
  return;
}
}
#line 547 "/root/patchweave_new/23/src/common.c"
int psf_binheader_writef(SF_PRIVATE *psf , char const   *format  , ...) 
{ 
  va_list argptr ;
  sf_count_t countdata ;
  unsigned long longdata ;
  unsigned int data ;
  float floatdata ;
  double doubledata ;
  void *bindata ;
  size_t size ;
  char c ;
  char *strptr ;
  int count___0 ;
  int trunc_8to4 ;
  char const   *__cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp20 ;
  size_t tmp ;
  unsigned long tmp___0 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  size_t __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;

  {
  {
#line 557
  count___0 = 0;
#line 559
  trunc_8to4 = 0;
#line 561
  __builtin_va_start((__builtin_va_list )((void *)argptr), format);
  }
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    __cil_tmp15 = format;
#line 563
    format ++;
#line 563
    c = (char )*__cil_tmp15;
#line 563
    if (! c) {
#line 563
      goto while_break;
    }
    {
#line 565
    __cil_tmp16 = psf_bump_header_allocation(psf, (sf_count_t )16);
    }
#line 565
    if (psf->header.indx + 16L >= psf->header.len) {
#line 565
      if (__cil_tmp16) {
#line 566
        return (count___0);
      }
    }
#line 569
    if ((int )c == 32) {
#line 569
      goto case_32;
    }
#line 572
    if ((int )c == 101) {
#line 572
      goto case_101;
    }
#line 576
    if ((int )c == 69) {
#line 576
      goto case_69;
    }
#line 580
    if ((int )c == 116) {
#line 580
      goto case_116;
    }
#line 584
    if ((int )c == 84) {
#line 584
      goto case_84;
    }
#line 588
    if ((int )c == 109) {
#line 588
      goto case_109;
    }
#line 594
    if ((int )c == 49) {
#line 594
      goto case_49;
    }
#line 600
    if ((int )c == 50) {
#line 600
      goto case_50;
    }
#line 611
    if ((int )c == 51) {
#line 611
      goto case_51;
    }
#line 622
    if ((int )c == 52) {
#line 622
      goto case_52;
    }
#line 633
    if ((int )c == 56) {
#line 633
      goto case_56;
    }
#line 655
    if ((int )c == 102) {
#line 655
      goto case_102;
    }
#line 666
    if ((int )c == 100) {
#line 666
      goto case_100;
    }
#line 676
    if ((int )c == 115) {
#line 676
      goto case_115;
    }
#line 695
    if ((int )c == 83) {
#line 695
      goto case_83;
    }
#line 715
    if ((int )c == 112) {
#line 715
      goto case_112;
    }
#line 732
    if ((int )c == 98) {
#line 732
      goto case_98;
    }
#line 744
    if ((int )c == 122) {
#line 744
      goto case_122;
    }
#line 758
    if ((int )c == 104) {
#line 758
      goto case_104;
    }
#line 765
    if ((int )c == 106) {
#line 765
      goto case_106;
    }
#line 775
    if ((int )c == 111) {
#line 775
      goto case_111;
    }
#line 784
    goto switch_default;
    case_32: 
#line 570
    goto switch_break;
    case_101: 
#line 573
    psf->rwf_endian = 268435456;
#line 574
    goto switch_break;
    case_69: 
#line 577
    psf->rwf_endian = 536870912;
#line 578
    goto switch_break;
    case_116: 
#line 581
    trunc_8to4 = 1;
#line 582
    goto switch_break;
    case_84: 
#line 585
    trunc_8to4 = 0;
#line 586
    goto switch_break;
    case_109: 
    {
#line 589
    data = 0U;
#line 590
    header_put_marker(psf, (int )data);
#line 591
    count___0 += 4;
    }
#line 592
    goto switch_break;
    case_49: 
    {
#line 595
    data = 0U;
#line 596
    header_put_byte(psf, (char )data);
#line 597
    count___0 ++;
    }
#line 598
    goto switch_break;
    case_50: 
#line 601
    data = 0U;
#line 602
    if (psf->rwf_endian == 536870912) {
      {
#line 603
      header_put_be_short(psf, (int )data);
      }
    } else {
      {
#line 606
      header_put_le_short(psf, (int )data);
      }
    }
#line 608
    count___0 += 2;
#line 609
    goto switch_break;
    case_51: 
#line 612
    data = 0U;
#line 613
    if (psf->rwf_endian == 536870912) {
      {
#line 614
      header_put_be_3byte(psf, (int )data);
      }
    } else {
      {
#line 617
      header_put_le_3byte(psf, (int )data);
      }
    }
#line 619
    count___0 += 3;
#line 620
    goto switch_break;
    case_52: 
#line 623
    data = 0U;
#line 624
    if (psf->rwf_endian == 536870912) {
      {
#line 625
      header_put_be_int(psf, (int )data);
      }
    } else {
      {
#line 628
      header_put_marker(psf, (int )data);
      }
    }
#line 630
    count___0 += 4;
#line 631
    goto switch_break;
    case_56: 
#line 634
    countdata = (sf_count_t )0;
#line 635
    if (psf->rwf_endian == 536870912) {
#line 635
      if (trunc_8to4 == 0) {
        {
#line 636
        header_put_be_8byte(psf, countdata);
#line 637
        count___0 += 8;
        }
      } else {
#line 635
        goto _L___6;
      }
    } else
    _L___6: 
#line 639
    if (psf->rwf_endian == 268435456) {
#line 639
      if (trunc_8to4 == 0) {
        {
#line 640
        header_put_le_8byte(psf, countdata);
#line 641
        count___0 += 8;
        }
      } else {
#line 639
        goto _L___5;
      }
    } else
    _L___5: 
#line 643
    if (psf->rwf_endian == 536870912) {
#line 643
      if (trunc_8to4 == 1) {
        {
#line 644
        longdata = (unsigned long )(countdata & 4294967295L);
#line 645
        header_put_be_int(psf, (int )longdata);
#line 646
        count___0 += 4;
        }
      } else {
#line 643
        goto _L;
      }
    } else
    _L: 
#line 648
    if (psf->rwf_endian == 268435456) {
#line 648
      if (trunc_8to4 == 1) {
        {
#line 649
        longdata = (unsigned long )(countdata & 4294967295L);
#line 650
        header_put_marker(psf, (int )longdata);
#line 651
        count___0 += 4;
        }
      }
    }
#line 653
    goto switch_break;
    case_102: 
#line 657
    floatdata = (float )0;
#line 658
    if (psf->rwf_endian == 536870912) {
      {
#line 659
      float32_be_write(floatdata, psf->header.ptr + psf->header.indx);
      }
    } else {
      {
#line 661
      float32_le_write(floatdata, psf->header.ptr + psf->header.indx);
      }
    }
#line 662
    psf->header.indx += 4L;
#line 663
    count___0 += 4;
#line 664
    goto switch_break;
    case_100: 
#line 667
    doubledata = (double )0;
#line 668
    if (psf->rwf_endian == 536870912) {
      {
#line 669
      double64_be_write(doubledata, psf->header.ptr + psf->header.indx);
      }
    } else {
      {
#line 671
      double64_le_write(doubledata, psf->header.ptr + psf->header.indx);
      }
    }
#line 672
    psf->header.indx += 8L;
#line 673
    count___0 += 8;
#line 674
    goto switch_break;
    case_115: 
    {
#line 678
    strptr = (char *)0;
#line 679
    __cil_tmp17 = strlen((char const   *)strptr);
#line 679
    size = __cil_tmp17 + 1UL;
#line 680
    size += size & 1UL;
#line 682
    __cil_tmp18 = psf_bump_header_allocation(psf, (sf_count_t )16);
    }
#line 682
    if (psf->header.indx + (sf_count_t )size >= psf->header.len) {
#line 682
      if (__cil_tmp18) {
#line 683
        return (count___0);
      }
    }
#line 685
    if (psf->rwf_endian == 536870912) {
      {
#line 686
      header_put_be_int(psf, (int )size);
      }
    } else {
      {
#line 688
      header_put_marker(psf, (int )size);
      }
    }
    {
#line 689
    memcpy((void *)(psf->header.ptr + psf->header.indx), (void const   *)strptr, size);
#line 690
    psf->header.indx = (sf_count_t )((size_t )psf->header.indx + size);
#line 691
    *(psf->header.ptr + (psf->header.indx - 1L)) = (unsigned char)0;
#line 692
    count___0 = (int )((unsigned long )count___0 + (4UL + size));
    }
#line 693
    goto switch_break;
    case_83: 
    {
#line 700
    strptr = (char *)0;
#line 701
    size = strlen((char const   *)strptr);
#line 702
    __cil_tmp20 = psf_bump_header_allocation(psf, (sf_count_t )size);
    }
#line 702
    if (psf->header.indx + (sf_count_t )size > psf->header.len) {
#line 702
      if (__cil_tmp20) {
#line 703
        return (count___0);
      }
    }
#line 704
    if (psf->rwf_endian == 536870912) {
      {
#line 705
      header_put_be_int(psf, (int )size);
      }
    } else {
      {
#line 707
      header_put_marker(psf, (int )size);
      }
    }
    {
#line 708
    memcpy((void *)(psf->header.ptr + psf->header.indx), (void const   *)strptr, size + 1UL);
#line 709
    size += size & 1UL;
#line 710
    psf->header.indx = (sf_count_t )((size_t )psf->header.indx + size);
#line 711
    *(psf->header.ptr + psf->header.indx) = (unsigned char)0;
#line 712
    count___0 = (int )((unsigned long )count___0 + (4UL + size));
    }
#line 713
    goto switch_break;
    case_112: 
    {
#line 718
    strptr = (char *)0;
#line 719
    size = strlen((char const   *)strptr);
    }
#line 720
    if (size & 1UL) {
#line 720
      tmp = size;
    } else {
#line 720
      tmp = size + 1UL;
    }
#line 720
    size = tmp;
#line 721
    if (size > 254UL) {
#line 721
      tmp___0 = 254UL;
    } else {
#line 721
      tmp___0 = size;
    }
    {
#line 721
    size = tmp___0;
#line 723
    __cil_tmp24 = psf_bump_header_allocation(psf, (sf_count_t )size);
    }
#line 723
    if (psf->header.indx + (sf_count_t )size > psf->header.len) {
#line 723
      if (__cil_tmp24) {
#line 724
        return (count___0);
      }
    }
    {
#line 726
    header_put_byte(psf, (char )size);
#line 727
    memcpy((void *)(psf->header.ptr + psf->header.indx), (void const   *)strptr, size);
#line 728
    psf->header.indx = (sf_count_t )((size_t )psf->header.indx + size);
#line 729
    count___0 = (int )((unsigned long )count___0 + (1UL + size));
    }
#line 730
    goto switch_break;
    case_98: 
    {
#line 733
    bindata = (void *)0;
#line 734
    size = (size_t )0;
#line 736
    __cil_tmp25 = psf_bump_header_allocation(psf, (sf_count_t )size);
    }
#line 736
    if (psf->header.indx + (sf_count_t )size > psf->header.len) {
#line 736
      if (__cil_tmp25) {
#line 737
        return (count___0);
      }
    }
    {
#line 739
    memcpy((void *)(psf->header.ptr + psf->header.indx), (void const   *)bindata,
           size);
#line 740
    psf->header.indx = (sf_count_t )((size_t )psf->header.indx + size);
#line 741
    count___0 = (int )((size_t )count___0 + size);
    }
#line 742
    goto switch_break;
    case_122: 
    {
#line 745
    size = (size_t )0;
#line 747
    __cil_tmp26 = psf_bump_header_allocation(psf, (sf_count_t )size);
    }
#line 747
    if (psf->header.indx + (sf_count_t )size > psf->header.len) {
#line 747
      if (__cil_tmp26) {
#line 748
        return (count___0);
      }
    }
#line 750
    count___0 = (int )((size_t )count___0 + size);
    {
#line 751
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 751
      if (! size) {
#line 751
        goto while_break___0;
      }
#line 752
      *(psf->header.ptr + psf->header.indx) = (unsigned char)0;
#line 753
      (psf->header.indx) ++;
#line 754
      __cil_tmp28 = size;
#line 754
      size --;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 756
    goto switch_break;
    case_104: 
    {
#line 759
    bindata = (void *)0;
#line 760
    memcpy((void *)(psf->header.ptr + psf->header.indx), (void const   *)bindata,
           16UL);
#line 761
    psf->header.indx += 16L;
#line 762
    count___0 += 16;
    }
#line 763
    goto switch_break;
    case_106: 
    {
#line 766
    size = (size_t )0;
#line 768
    __cil_tmp29 = psf_bump_header_allocation(psf, (sf_count_t )size);
    }
#line 768
    if (psf->header.indx + (sf_count_t )size > psf->header.len) {
#line 768
      if (__cil_tmp29) {
#line 769
        return (count___0);
      }
    }
#line 771
    psf->header.indx = (sf_count_t )((size_t )psf->header.indx + size);
#line 772
    count___0 = (int )((size_t )count___0 + size);
#line 773
    goto switch_break;
    case_111: 
    {
#line 776
    size = (size_t )0;
#line 778
    __cil_tmp30 = psf_bump_header_allocation(psf, (sf_count_t )size);
    }
#line 778
    if ((sf_count_t )size >= psf->header.len) {
#line 778
      if (__cil_tmp30) {
#line 779
        return (count___0);
      }
    }
#line 781
    psf->header.indx = (sf_count_t )size;
#line 782
    goto switch_break;
    switch_default: 
    {
#line 785
    psf_log_printf(psf, "*** Invalid format specifier `%c\'\n", (int )c);
#line 786
    psf->error = 30;
    }
#line 787
    goto switch_break;
    switch_break: ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 791
  __builtin_va_end((__builtin_va_list )((void *)argptr));
  }
#line 792
  return (count___0);
}
}
#line 843 "/root/patchweave_new/23/src/common.c"
static int header_read(SF_PRIVATE *psf , void *ptr , int bytes ) 
{ 
  int count___0 ;
  int __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;

  {
  {
#line 844
  count___0 = 0;
#line 846
  __cil_tmp5 = psf_bump_header_allocation(psf, (sf_count_t )bytes);
  }
#line 846
  if (psf->header.indx + (long )bytes >= psf->header.len) {
#line 846
    if (__cil_tmp5) {
#line 847
      return (count___0);
    }
  }
#line 849
  if (psf->header.indx + (long )bytes > psf->header.end) {
    {
#line 850
    __cil_tmp6 = psf_fread((void *)(psf->header.ptr + psf->header.end), (sf_count_t )1,
                           (long )bytes - (psf->header.end - psf->header.indx), psf);
#line 850
    count___0 = (int )__cil_tmp6;
    }
#line 851
    if (count___0 != bytes - (int )(psf->header.end - psf->header.indx)) {
      {
#line 852
      psf_log_printf(psf, "Error : psf_fread returned short count.\n\220");
      }
#line 853
      return (count___0);
    }
#line 855
    psf->header.end += (long )count___0;
  }
  {
#line 858
  memcpy(ptr, (void const   *)(psf->header.ptr + psf->header.indx), (unsigned long )bytes);
#line 859
  psf->header.indx += (long )bytes;
  }
#line 861
  return (bytes);
}
}
#line 865 "/root/patchweave_new/23/src/common.c"
static void header_seek(SF_PRIVATE *psf , sf_count_t position , int whence ) 
{ 
  sf_count_t __cil_tmp4 ;
  sf_count_t __cil_tmp5 ;

  {
#line 868
  if (whence == 0) {
#line 868
    goto case_0;
  }
#line 881
  if (whence == 1) {
#line 881
    goto case_1;
  }
#line 910
  goto switch_default;
  case_0: 
#line 869
  if (psf->header.indx + position >= psf->header.len) {
    {
#line 870
    psf_bump_header_allocation(psf, position);
    }
  }
#line 871
  if (position > psf->header.len) {
    {
#line 873
    psf_fseek(psf, position, whence);
    }
#line 874
    return;
  }
#line 876
  if (position > psf->header.end) {
    {
#line 877
    __cil_tmp4 = psf_fread((void *)(psf->header.ptr + psf->header.end), (sf_count_t )1,
                           position - psf->header.end, psf);
#line 877
    psf->header.end += __cil_tmp4;
    }
  }
#line 878
  psf->header.indx = position;
#line 879
  goto switch_break;
  case_1: 
#line 882
  if (psf->header.indx + position >= psf->header.len) {
    {
#line 883
    psf_bump_header_allocation(psf, position);
    }
  }
#line 885
  if (psf->header.indx + position < 0L) {
#line 886
    goto switch_break;
  }
#line 888
  if (psf->header.indx >= psf->header.len) {
    {
#line 889
    psf_fseek(psf, position, whence);
    }
#line 890
    return;
  }
#line 893
  if (psf->header.indx + position <= psf->header.end) {
#line 894
    psf->header.indx += position;
#line 895
    goto switch_break;
  }
#line 898
  if (psf->header.indx + position > psf->header.len) {
    {
#line 900
    psf->header.indx = psf->header.end;
#line 901
    psf_fseek(psf, position, 1);
    }
#line 902
    goto switch_break;
  }
  {
#line 905
  __cil_tmp5 = psf_fread((void *)(psf->header.ptr + psf->header.end), (sf_count_t )1,
                         position - (psf->header.end - psf->header.indx), psf);
#line 905
  psf->header.end += __cil_tmp5;
#line 906
  psf->header.indx = psf->header.end;
  }
#line 907
  goto switch_break;
  switch_default: 
  {
#line 911
  psf_log_printf(psf, "Bad whence param in header_seek().\n");
  }
#line 912
  goto switch_break;
  switch_break: ;
#line 915
  return;
}
}
#line 919 "/root/patchweave_new/23/src/common.c"
static int header_gets(SF_PRIVATE *psf , char *ptr , int bufsize ) 
{ 
  int k ;
  int __cil_tmp5 ;
  sf_count_t __cil_tmp7 ;

  {
  {
#line 922
  __cil_tmp5 = psf_bump_header_allocation(psf, (sf_count_t )bufsize);
  }
#line 922
  if (psf->header.indx + (long )bufsize >= psf->header.len) {
#line 922
    if (__cil_tmp5) {
#line 923
      return (0);
    }
  }
#line 925
  k = 0;
  {
#line 925
  while (1) {
    while_continue: /* CIL Label */ ;

#line 925
    if (! (k < bufsize - 1)) {
#line 925
      goto while_break;
    }
#line 926
    if (psf->header.indx < psf->header.end) {
#line 927
      *(ptr + k) = (char )*(psf->header.ptr + psf->header.indx);
#line 928
      (psf->header.indx) ++;
    } else {
      {
#line 931
      __cil_tmp7 = psf_fread((void *)(psf->header.ptr + psf->header.end), (sf_count_t )1,
                             (sf_count_t )1, psf);
#line 931
      psf->header.end += __cil_tmp7;
#line 932
      *(ptr + k) = (char )*(psf->header.ptr + psf->header.indx);
#line 933
      psf->header.indx = psf->header.end;
      }
    }
#line 936
    if ((int )*(ptr + k) == 10) {
#line 937
      goto while_break;
    }
#line 925
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 940
  *(ptr + k) = (char)0;
#line 942
  return (k);
}
}
#line 946 "/root/patchweave_new/23/src/common.c"
int psf_binheader_readf(SF_PRIVATE *psf , char const   *format  , ...) 
{ 
  va_list argptr ;
  sf_count_t *countptr ;
  sf_count_t countdata ;
  unsigned char *ucptr ;
  unsigned char sixteen_bytes[16] ;
  unsigned int *intptr ;
  unsigned int intdata ;
  unsigned short *shortptr ;
  char *charptr ;
  float *floatptr ;
  double *doubleptr ;
  char c ;
  int byte_count ;
  int count___0 ;
  sf_count_t __cil_tmp17 ;
  char const   *__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int k ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int32_t __cil_tmp28 ;
  int32_t __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp33 ;
  int __cil_tmp36 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;

  {
#line 956
  byte_count = 0;
#line 956
  count___0 = 0;
#line 958
  if (! format) {
    {
#line 959
    __cil_tmp17 = psf_ftell(psf);
    }
#line 959
    return ((int )__cil_tmp17);
  }
  {
#line 961
  __builtin_va_start((__builtin_va_list )((void *)argptr), format);
  }
  {
#line 963
  while (1) {
    while_continue: /* CIL Label */ ;
#line 963
    __cil_tmp18 = format;
#line 963
    format ++;
#line 963
    c = (char )*__cil_tmp18;
#line 963
    if (! c) {
#line 963
      goto while_break;
    }
    {
#line 965
    __cil_tmp19 = psf_bump_header_allocation(psf, (sf_count_t )16);
    }
#line 965
    if (psf->header.indx + 16L >= psf->header.len) {
#line 965
      if (__cil_tmp19) {
#line 966
        return (count___0);
      }
    }
#line 969
    if ((int )c == 101) {
#line 969
      goto case_101;
    }
#line 973
    if ((int )c == 69) {
#line 973
      goto case_69;
    }
#line 977
    if ((int )c == 109) {
#line 977
      goto case_109;
    }
#line 985
    if ((int )c == 104) {
#line 985
      goto case_104;
    }
#line 998
    if ((int )c == 49) {
#line 998
      goto case_49;
    }
#line 1004
    if ((int )c == 50) {
#line 1004
      goto case_50;
    }
#line 1015
    if ((int )c == 51) {
#line 1015
      goto case_51;
    }
#line 1025
    if ((int )c == 52) {
#line 1025
      goto case_52;
    }
#line 1036
    if ((int )c == 56) {
#line 1036
      goto case_56;
    }
#line 1047
    if ((int )c == 102) {
#line 1047
      goto case_102;
    }
#line 1057
    if ((int )c == 100) {
#line 1057
      goto case_100;
    }
#line 1067
    if ((int )c == 115) {
#line 1067
      goto case_115;
    }
#line 1080
    if ((int )c == 98) {
#line 1080
      goto case_98;
    }
#line 1087
    if ((int )c == 71) {
#line 1087
      goto case_71;
    }
#line 1098
    if ((int )c == 122) {
#line 1098
      goto case_122;
    }
#line 1110
    if ((int )c == 112) {
#line 1110
      goto case_112;
    }
#line 1116
    if ((int )c == 106) {
#line 1116
      goto case_106;
    }
#line 1122
    goto switch_default;
    case_101: 
#line 970
    psf->rwf_endian = 268435456;
#line 971
    goto switch_break;
    case_69: 
#line 974
    psf->rwf_endian = 536870912;
#line 975
    goto switch_break;
    case_109: 
    {
#line 978
    intptr = (unsigned int *)0;
#line 979
    *intptr = 0U;
#line 980
    ucptr = (unsigned char *)intptr;
#line 981
    __cil_tmp20 = header_read(psf, (void *)ucptr, (int )sizeof(int ));
#line 981
    byte_count += __cil_tmp20;
#line 982
    *intptr = (unsigned int )(((int )*(ucptr + 0) | ((int )*(ucptr + 1) << 8)) | ((int )*(ucptr + 2) << 16)) | ((uint32_t )*(ucptr + 3) << 24);
    }
#line 983
    goto switch_break;
    case_104: 
    {
#line 986
    intptr = (unsigned int *)0;
#line 987
    *intptr = 0U;
#line 988
    ucptr = (unsigned char *)intptr;
#line 989
    __cil_tmp21 = header_read(psf, (void *)(sixteen_bytes), (int )sizeof(sixteen_bytes));
#line 989
    byte_count += __cil_tmp21;
#line 991
    intdata = 0U;
#line 992
    k = 0;
    }
    {
#line 992
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 992
      if (! (k < 16)) {
#line 992
        goto while_break___0;
      }
#line 993
      intdata ^= (unsigned int )((int )sixteen_bytes[k] << k);
#line 992
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 995
    *intptr = intdata;
#line 996
    goto switch_break;
    case_49: 
    {
#line 999
    charptr = (char *)0;
#line 1000
    *charptr = (char)0;
#line 1001
    __cil_tmp24 = header_read(psf, (void *)charptr, (int )sizeof(char ));
#line 1001
    byte_count += __cil_tmp24;
    }
#line 1002
    goto switch_break;
    case_50: 
    {
#line 1005
    shortptr = (unsigned short *)0;
#line 1006
    *shortptr = (unsigned short)0;
#line 1007
    ucptr = (unsigned char *)shortptr;
#line 1008
    __cil_tmp25 = header_read(psf, (void *)ucptr, (int )sizeof(short ));
#line 1008
    byte_count += __cil_tmp25;
    }
#line 1009
    if (psf->rwf_endian == 536870912) {
#line 1010
      *shortptr = (unsigned short )(((int )*(ucptr + 0) << 8) | (int )*(ucptr + 1));
    } else {
#line 1012
      *shortptr = (unsigned short )(((int )*(ucptr + 1) << 8) | (int )*(ucptr + 0));
    }
#line 1013
    goto switch_break;
    case_51: 
    {
#line 1016
    intptr = (unsigned int *)0;
#line 1017
    *intptr = 0U;
#line 1018
    __cil_tmp26 = header_read(psf, (void *)(sixteen_bytes), 3);
#line 1018
    byte_count += __cil_tmp26;
    }
#line 1019
    if (psf->rwf_endian == 536870912) {
#line 1020
      *intptr = (unsigned int )((((int )sixteen_bytes[0] << 16) | ((int )sixteen_bytes[1] << 8)) | (int )sixteen_bytes[2]);
    } else {
#line 1022
      *intptr = (unsigned int )((((int )sixteen_bytes[2] << 16) | ((int )sixteen_bytes[1] << 8)) | (int )sixteen_bytes[0]);
    }
#line 1023
    goto switch_break;
    case_52: 
    {
#line 1026
    intptr = (unsigned int *)0;
#line 1027
    *intptr = 0U;
#line 1028
    ucptr = (unsigned char *)intptr;
#line 1029
    __cil_tmp27 = header_read(psf, (void *)ucptr, (int )sizeof(int ));
#line 1029
    byte_count += __cil_tmp27;
    }
#line 1030
    if (psf->rwf_endian == 536870912) {
      {
#line 1031
      __cil_tmp28 = psf_get_be32(ucptr, 0);
#line 1031
      *intptr = (unsigned int )__cil_tmp28;
      }
    } else {
      {
#line 1033
      __cil_tmp29 = psf_get_le32(ucptr, 0);
#line 1033
      *intptr = (unsigned int )__cil_tmp29;
      }
    }
#line 1034
    goto switch_break;
    case_56: 
    {
#line 1037
    countptr = (sf_count_t *)0;
#line 1038
    *countptr = (sf_count_t )0;
#line 1039
    __cil_tmp30 = header_read(psf, (void *)(sixteen_bytes), 8);
#line 1039
    byte_count += __cil_tmp30;
    }
#line 1040
    if (psf->rwf_endian == 536870912) {
      {
#line 1041
      countdata = psf_get_be64(sixteen_bytes, 0);
      }
    } else {
      {
#line 1043
      countdata = psf_get_le64(sixteen_bytes, 0);
      }
    }
#line 1044
    *countptr = countdata;
#line 1045
    goto switch_break;
    case_102: 
    {
#line 1048
    floatptr = (float *)0;
#line 1049
    *floatptr = (float )0.;
#line 1050
    __cil_tmp33 = header_read(psf, (void *)floatptr, (int )sizeof(float ));
#line 1050
    byte_count += __cil_tmp33;
    }
#line 1051
    if (psf->rwf_endian == 536870912) {
      {
#line 1052
      *floatptr = float32_be_read((unsigned char const   *)((unsigned char *)floatptr));
      }
    } else {
      {
#line 1054
      *floatptr = float32_le_read((unsigned char const   *)((unsigned char *)floatptr));
      }
    }
#line 1055
    goto switch_break;
    case_100: 
    {
#line 1058
    doubleptr = (double *)0;
#line 1059
    *doubleptr = 0.;
#line 1060
    __cil_tmp36 = header_read(psf, (void *)doubleptr, (int )sizeof(double ));
#line 1060
    byte_count += __cil_tmp36;
    }
#line 1061
    if (psf->rwf_endian == 536870912) {
      {
#line 1062
      *doubleptr = double64_be_read((unsigned char const   *)((unsigned char *)doubleptr));
      }
    } else {
      {
#line 1064
      *doubleptr = double64_le_read((unsigned char const   *)((unsigned char *)doubleptr));
      }
    }
#line 1065
    goto switch_break;
    case_115: 
    {
#line 1068
    psf_log_printf(psf, "Format conversion \'s\' not implemented yet.\n");
    }
#line 1078
    goto switch_break;
    case_98: 
    {
#line 1081
    charptr = (char *)0;
#line 1082
    count___0 = 0;
#line 1083
    memset((void *)charptr, 0, (unsigned long )count___0);
#line 1084
    __cil_tmp39 = header_read(psf, (void *)charptr, count___0);
#line 1084
    byte_count += __cil_tmp39;
    }
#line 1085
    goto switch_break;
    case_71: 
    {
#line 1088
    charptr = (char *)0;
#line 1089
    count___0 = 0;
#line 1090
    memset((void *)charptr, 0, (unsigned long )count___0);
#line 1092
    __cil_tmp40 = psf_bump_header_allocation(psf, (sf_count_t )count___0);
    }
#line 1092
    if (psf->header.indx + (long )count___0 >= psf->header.len) {
#line 1092
      if (__cil_tmp40) {
#line 1093
        return (0);
      }
    }
    {
#line 1095
    __cil_tmp41 = header_gets(psf, charptr, count___0);
#line 1095
    byte_count += __cil_tmp41;
    }
#line 1096
    goto switch_break;
    case_122: 
    {
#line 1099
    psf_log_printf(psf, "Format conversion \'z\' not implemented yet.\n");
    }
#line 1108
    goto switch_break;
    case_112: 
    {
#line 1111
    count___0 = 0;
#line 1112
    header_seek(psf, (sf_count_t )count___0, 0);
#line 1113
    byte_count = count___0;
    }
#line 1114
    goto switch_break;
    case_106: 
    {
#line 1117
    count___0 = 0;
#line 1118
    header_seek(psf, (sf_count_t )count___0, 1);
#line 1119
    byte_count += count___0;
    }
#line 1120
    goto switch_break;
    switch_default: 
    {
#line 1123
    psf_log_printf(psf, "*** Invalid format specifier `%c\'\nLA\270U", (int )c);
#line 1124
    psf->error = 30;
    }
#line 1125
    goto switch_break;
    switch_break: ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1129
  __builtin_va_end((__builtin_va_list )((void *)argptr));
  }
#line 1131
  return (byte_count);
}
}
#line 1138 "/root/patchweave_new/23/src/common.c"
sf_count_t psf_default_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t samples_from_start ) 
{ 
  sf_count_t position ;
  sf_count_t retval ;

  {
#line 1141
  if (psf->blockwidth) {
#line 1141
    if (! (psf->dataoffset >= 0L)) {
#line 1142
      psf->error = 40;
#line 1143
      return ((sf_count_t )-1);
    }
  } else {
#line 1142
    psf->error = 40;
#line 1143
    return ((sf_count_t )-1);
  }
#line 1146
  if (! psf->sf.seekable) {
#line 1147
    psf->error = 41;
#line 1148
    return ((sf_count_t )-1);
  }
  {
#line 1151
  position = psf->dataoffset + (long )psf->blockwidth * samples_from_start;
#line 1153
  retval = psf_fseek(psf, position, 0);
  }
#line 1153
  if (retval != position) {
#line 1154
    psf->error = 44;
#line 1155
    return ((sf_count_t )-1);
  }
#line 1158
  return (samples_from_start);
}
}
#line 1165 "/root/patchweave_new/23/src/common.c"
void psf_hexdump(void const   *ptr , int len ) 
{ 
  char const   *data ;
  char ascii[17] ;
  int k ;
  int m ;
  char const   *tmp ;
  int __cil_tmp8 ;
  int tmp___0 ;

  {
#line 1170
  data = (char const   *)ptr;
#line 1170
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1171
    return;
  }
#line 1172
  if (len <= 0) {
#line 1173
    return;
  }
  {
#line 1175
  puts("\001");
#line 1176
  k = 0;
  }
  {
#line 1176
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1176
    if (! (k < len)) {
#line 1176
      goto while_break;
    }
    {
#line 1177
    memset((void *)(ascii), ' ', sizeof(ascii));
#line 1179
    printf("%08X: ", k);
#line 1180
    m = 0;
    }
    {
#line 1180
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1180
      if (m < 16) {
#line 1180
        if (! (k + m < len)) {
#line 1180
          goto while_break___0;
        }
      } else {
#line 1180
        goto while_break___0;
      }
#line 1181
      if (m == 8) {
#line 1181
        tmp = " %02X ";
      } else {
#line 1181
        tmp = "%02X U";
      }
      {
#line 1181
      printf(tmp, (int )*(data + (k + m)) & 255);
#line 1182
      __cil_tmp8 = psf_isprint((int )*(data + (k + m)));
      }
#line 1182
      if (__cil_tmp8) {
#line 1182
        tmp___0 = (int )*(data + (k + m));
      } else {
#line 1182
        tmp___0 = '.';
      }
#line 1182
      ascii[m] = (char )tmp___0;
#line 1180
      m ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
#line 1185
    if (m <= 8) {
      {
#line 1185
      printf(" ");
      }
    }
    {
#line 1186
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1186
      if (! (m < 16)) {
#line 1186
        goto while_break___1;
      }
      {
#line 1186
      printf("   A\270U");
#line 1186
      m ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 1188
    ascii[16] = (char)0;
#line 1189
    printf(" %s\n\270U", ascii);
#line 1176
    k += 16;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1192
  puts("\220");
  }
#line 1194
  return;
}
}
#line 1196 "/root/patchweave_new/23/src/common.c"
void psf_log_SF_INFO(SF_PRIVATE *psf ) 
{ 
  char const   *tmp ;

  {
  {
#line 1197
  psf_log_printf(psf, "---------------------------------\nMA\270U");
#line 1199
  psf_log_printf(psf, " Sample rate :   %d\n\270U", psf->sf.samplerate);
  }
#line 1200
  if ((long long )psf->sf.frames == -1LL) {
    {
#line 1201
    psf_log_printf(psf, " Frames      :   unknown\n[MA\270U");
    }
  } else {
    {
#line 1203
    psf_log_printf(psf, " Frames      :   %D\n\270U", psf->sf.frames);
    }
  }
  {
#line 1204
  psf_log_printf(psf, " Channels    :   %d\n", psf->sf.channels);
#line 1206
  psf_log_printf(psf, " Format      :   0x%X\n", psf->sf.format);
#line 1207
  psf_log_printf(psf, " Sections    :   %d\n\270U", psf->sf.sections);
  }
#line 1208
  if (psf->sf.seekable) {
#line 1208
    tmp = "TRUE\270U";
  } else {
#line 1208
    tmp = "FALSEU";
  }
  {
#line 1208
  psf_log_printf(psf, " Seekable    :   %s\n", tmp);
#line 1210
  psf_log_printf(psf, "---------------------------------\n");
  }
#line 1212
  return;
}
}
#line 1217 "/root/patchweave_new/23/src/common.c"
void *psf_memset(void *s , int c , sf_count_t len ) 
{ 
  char *ptr ;
  int setcount ;
  int tmp ;

  {
#line 1221
  ptr = (char *)s;
  {
#line 1223
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1223
    if (! (len > 0L)) {
#line 1223
      goto while_break;
    }
#line 1224
    if (len > 268435456L) {
#line 1224
      tmp = 268435456;
    } else {
#line 1224
      tmp = (int )len;
    }
    {
#line 1224
    setcount = tmp;
#line 1226
    memset((void *)ptr, c, (unsigned long )setcount);
#line 1228
    ptr += setcount;
#line 1229
    len -= (long )setcount;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1232
  return (s);
}
}
#line 1246 "/root/patchweave_new/23/src/common.c"
SF_CUES *psf_cues_alloc(uint32_t cue_count ) 
{ 
  SF_CUES *pcues ;
  void *__cil_tmp3 ;

  {
  {
#line 1247
  __cil_tmp3 = calloc(1UL, sizeof(SF_CUES_0 ) + (unsigned long )cue_count * sizeof(SF_CUE_POINT ));
#line 1247
  pcues = (SF_CUES *)__cil_tmp3;
#line 1249
  pcues->cue_count = cue_count;
  }
#line 1250
  return (pcues);
}
}
#line 1254 "/root/patchweave_new/23/src/common.c"
SF_CUES *psf_cues_dup(void const   *ptr ) 
{ 
  SF_CUES *pcues ;
  SF_CUES *pnew ;
  SF_CUES *__cil_tmp4 ;

  {
  {
#line 1255
  pcues = (SF_CUES *)ptr;
#line 1256
  __cil_tmp4 = psf_cues_alloc(pcues->cue_count);
#line 1256
  pnew = __cil_tmp4;
#line 1258
  memcpy((void *)pnew, (void const   *)pcues, sizeof(SF_CUES_0 ) + (unsigned long )pcues->cue_count * sizeof(SF_CUE_POINT ));
  }
#line 1259
  return (pnew);
}
}
#line 1263 "/root/patchweave_new/23/src/common.c"
void psf_get_cues(SF_PRIVATE *psf , void *data , size_t datasize ) 
{ 
  uint32_t cue_count ;

  {
#line 1265
  if (psf->cues) {
    {
#line 1266
    cue_count = (uint32_t )((datasize - sizeof(uint32_t )) / sizeof(SF_CUE_POINT ));
#line 1268
    cue_count = (uint32_t )0;
#line 1269
    memcpy(data, (void const   *)psf->cues, sizeof(SF_CUES_0 ) + (unsigned long )cue_count * sizeof(SF_CUE_POINT ));
#line 1270
    ((SF_CUES *)data)->cue_count = cue_count;
    }
  }
#line 1273
  return;
}
}
#line 1278 "/root/patchweave_new/23/src/common.c"
SF_INSTRUMENT *psf_instrument_alloc(void) 
{ 
  SF_INSTRUMENT *instr ;
  void *tmp ;

  {
  {
#line 1281
  tmp = calloc(1UL, sizeof(SF_INSTRUMENT ));
#line 1281
  instr = (SF_INSTRUMENT *)tmp;
  }
#line 1283
  if ((unsigned long )instr == (unsigned long )((void *)0)) {
#line 1284
    return ((SF_INSTRUMENT *)((void *)0));
  }
#line 1287
  instr->basenote = (char)-1;
#line 1288
  instr->velocity_lo = (char)-1;
#line 1289
  instr->velocity_hi = (char)-1;
#line 1290
  instr->key_lo = (char)-1;
#line 1291
  instr->key_hi = (char)-1;
#line 1293
  return (instr);
}
}
#line 1297 "/root/patchweave_new/23/src/common.c"
void psf_sanitize_string(char *cptr , int len ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int tmp ;

  {
  {
#line 1299
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1301
    __cil_tmp3 = len;
#line 1301
    len --;
#line 1302
    __cil_tmp4 = psf_isprint((int )*(cptr + len));
    }
#line 1302
    if (__cil_tmp4) {
#line 1302
      tmp = (int )*(cptr + len);
    } else {
#line 1302
      tmp = '.';
    }
#line 1302
    *(cptr + len) = (char )tmp;
#line 1299
    if (! (len > 0)) {
#line 1299
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1304
  return;
}
}
#line 1308 "/root/patchweave_new/23/src/common.c"
void psf_get_date_str(char *str , int maxlen ) 
{ 
  time_t current ;
  struct tm timedata ;
  struct tm *tmptr ;

  {
  {
#line 1312
  time(& current);
#line 1316
  tmptr = gmtime_r(& current, & timedata);
  }
#line 1325
  if (tmptr) {
    {
#line 1326
    snprintf(str, (unsigned long )maxlen, "%4d-%02d-%02d %02d:%02d:%02d UTC\251",
             1900 + timedata.tm_year, timedata.tm_mon, timedata.tm_mday, timedata.tm_hour,
             timedata.tm_min, timedata.tm_sec);
    }
  } else {
    {
#line 1330
    snprintf(str, (unsigned long )maxlen, "Unknown date");
    }
  }
#line 1332
  return;
}
}
#line 1336 "/root/patchweave_new/23/src/common.c"
int subformat_to_bytewidth(int format ) 
{ 


  {
#line 1340
  if (format == 1) {
#line 1340
    goto case_1;
  }
#line 1340
  if (format == 5) {
#line 1340
    goto case_1;
  }
#line 1342
  if (format == 2) {
#line 1342
    goto case_2;
  }
#line 1344
  if (format == 3) {
#line 1344
    goto case_3;
  }
#line 1347
  if (format == 6) {
#line 1347
    goto case_6;
  }
#line 1347
  if (format == 4) {
#line 1347
    goto case_6;
  }
#line 1349
  if (format == 7) {
#line 1349
    goto case_7;
  }
#line 1338
  goto switch_break;
  case_1: 
#line 1341
  return (1);
  case_2: 
#line 1343
  return (2);
  case_3: 
#line 1345
  return (3);
  case_6: 
#line 1348
  return (4);
  case_7: 
#line 1350
  return (8);
  switch_break: ;
#line 1353
  return (0);
}
}
#line 1359 "/root/patchweave_new/23/src/common.c"
static int array[4]  ;
#line 1357 "/root/patchweave_new/23/src/common.c"
int s_bitwidth_to_subformat(int bits ) 
{ 


  {
#line 1358
  array[0] = 1;
#line 1358
  array[1] = 2;
#line 1358
  array[2] = 3;
#line 1358
  array[3] = 4;
#line 1362
  if (bits < 8) {
#line 1363
    return (0);
  } else
#line 1362
  if (bits > 32) {
#line 1363
    return (0);
  }
#line 1365
  return (array[(bits + 7) / 8 - 1]);
}
}
#line 1371 "/root/patchweave_new/23/src/common.c"
static int array___0[4]  ;
#line 1369 "/root/patchweave_new/23/src/common.c"
int u_bitwidth_to_subformat(int bits ) 
{ 


  {
#line 1370
  array___0[0] = 5;
#line 1370
  array___0[1] = 2;
#line 1370
  array___0[2] = 3;
#line 1370
  array___0[3] = 4;
#line 1374
  if (bits < 8) {
#line 1375
    return (0);
  } else
#line 1374
  if (bits > 32) {
#line 1375
    return (0);
  }
#line 1377
  return (array___0[(bits + 7) / 8 - 1]);
}
}
#line 1389 "/root/patchweave_new/23/src/common.c"
static uint64_t value  ;
#line 1387 "/root/patchweave_new/23/src/common.c"
int32_t psf_rand_int32(void) 
{ 
  int k ;
  int count___0 ;
  struct timeval tv ;

  {
#line 1388
  value = (uint64_t )0;
#line 1391
  if (value == 0UL) {
    {
#line 1395
    gettimeofday(& tv, (void *)0);
#line 1396
    value = (uint64_t )(tv.tv_sec + tv.tv_usec);
    }
  }
#line 1402
  count___0 = (int )(4UL + (value & 7UL));
#line 1403
  k = 0;
  {
#line 1403
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1403
    if (! (k < count___0)) {
#line 1403
      goto while_break;
    }
#line 1404
    value = (11117UL * value + 211231UL) & 2147483647UL;
#line 1403
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1406
  return ((int32_t )value);
}
}
#line 1410 "/root/patchweave_new/23/src/common.c"
void append_snprintf(char *dest , size_t maxlen , char const   *fmt  , ...) 
{ 
  size_t len ;
  unsigned long __cil_tmp5 ;
  va_list ap ;

  {
  {
#line 1411
  __cil_tmp5 = strlen((char const   *)dest);
#line 1411
  len = __cil_tmp5;
  }
#line 1413
  if (len < maxlen) {
    {
#line 1416
    __builtin_va_start((__builtin_va_list )((void *)ap), fmt);
#line 1417
    vsnprintf(dest + len, maxlen - len, fmt, (__gnuc_va_list )((void *)ap));
#line 1418
    __builtin_va_end((__builtin_va_list )((void *)ap));
    }
  }
#line 1421
  return;
}
}
#line 1426 "/root/patchweave_new/23/src/common.c"
void psf_strlcpy_crlf(char *dest , char const   *src , size_t destmax , size_t srcmax ) 
{ 
  char *destend ;
  char const   *srcend ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char const   *__cil_tmp14 ;

  {
#line 1428
  destend = (dest + destmax) - 2;
#line 1429
  srcend = src + srcmax;
  {
#line 1431
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1431
    if ((unsigned long )dest < (unsigned long )destend) {
#line 1431
      if (! ((unsigned long )src < (unsigned long )srcend)) {
#line 1431
        goto while_break;
      }
    } else {
#line 1431
      goto while_break;
    }
#line 1432
    if ((int )*(src + 0) == 13) {
#line 1432
      if ((int )*(src + 1) == 10) {
        _L: 
#line 1433
        __cil_tmp7 = dest;
#line 1433
        dest ++;
#line 1433
        *__cil_tmp7 = (char )'\r';
#line 1434
        __cil_tmp8 = dest;
#line 1434
        dest ++;
#line 1434
        *__cil_tmp8 = (char )'\n';
#line 1435
        src += 2;
#line 1436
        goto while_continue;
      } else {
#line 1432
        goto _L___7;
      }
    } else
    _L___7: 
#line 1432
    if ((int )*(src + 0) == 10) {
#line 1432
      if ((int )*(src + 1) == 13) {
#line 1432
        goto _L;
      }
    }
#line 1439
    if ((int )*(src + 0) == 13) {
#line 1440
      __cil_tmp9 = dest;
#line 1440
      dest ++;
#line 1440
      *__cil_tmp9 = (char )'\r';
#line 1441
      __cil_tmp10 = dest;
#line 1441
      dest ++;
#line 1441
      *__cil_tmp10 = (char )'\n';
#line 1442
      src ++;
#line 1443
      goto while_continue;
    }
#line 1446
    if ((int )*(src + 0) == 10) {
#line 1447
      __cil_tmp11 = dest;
#line 1447
      dest ++;
#line 1447
      *__cil_tmp11 = (char )'\r';
#line 1448
      __cil_tmp12 = dest;
#line 1448
      dest ++;
#line 1448
      *__cil_tmp12 = (char )'\n';
#line 1449
      src ++;
#line 1450
      goto while_continue;
    }
#line 1453
    __cil_tmp14 = src;
#line 1453
    src ++;
#line 1453
    __cil_tmp13 = dest;
#line 1453
    dest ++;
#line 1453
    *__cil_tmp13 = (char )*__cil_tmp14;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1457
  *dest = (char)0;
#line 1458
  return;
}
}
#line 1461 "/root/patchweave_new/23/src/common.c"
sf_count_t psf_decode_frame_count(SF_PRIVATE *psf ) 
{ 
  sf_count_t count___0 ;
  sf_count_t readlen ;
  sf_count_t total ;
  BUF_UNION ubuf ;
  int __cil_tmp6 ;

  {
  {
#line 1462
  total = (sf_count_t )0;
#line 1466
  __cil_tmp6 = psf_is_pipe(psf);
  }
#line 1466
  if (__cil_tmp6) {
#line 1467
    return ((sf_count_t )-1LL);
  } else
#line 1466
  if (psf->datalength > 16777216L) {
#line 1467
    return ((sf_count_t )-1LL);
  }
  {
#line 1469
  psf_fseek(psf, psf->dataoffset, 0);
#line 1471
  readlen = (sf_count_t )((int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0])) / psf->sf.channels);
#line 1472
  readlen *= (long )psf->sf.channels;
  }
  {
#line 1474
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1474
    count___0 = (*(psf->read_int))(psf, ubuf.ibuf, readlen);
    }
#line 1474
    if (! (count___0 > 0L)) {
#line 1474
      goto while_break;
    }
#line 1475
    total += count___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1477
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 1479
  return (total / (long )psf->sf.channels);
}
}
#line 1488 "/root/patchweave_new/23/src/common.c"
char const   *str_of_major_format(int format ) 
{ 


  {
#line 1490
  if ((format & 268369920) == 65536) {
#line 1490
    goto case_65536;
  }
#line 1491
  if ((format & 268369920) == 131072) {
#line 1491
    goto case_131072;
  }
#line 1492
  if ((format & 268369920) == 196608) {
#line 1492
    goto case_196608;
  }
#line 1493
  if ((format & 268369920) == 262144) {
#line 1493
    goto case_262144;
  }
#line 1494
  if ((format & 268369920) == 327680) {
#line 1494
    goto case_327680;
  }
#line 1495
  if ((format & 268369920) == 393216) {
#line 1495
    goto case_393216;
  }
#line 1496
  if ((format & 268369920) == 458752) {
#line 1496
    goto case_458752;
  }
#line 1497
  if ((format & 268369920) == 524288) {
#line 1497
    goto case_524288;
  }
#line 1498
  if ((format & 268369920) == 655360) {
#line 1498
    goto case_655360;
  }
#line 1499
  if ((format & 268369920) == 720896) {
#line 1499
    goto case_720896;
  }
#line 1500
  if ((format & 268369920) == 786432) {
#line 1500
    goto case_786432;
  }
#line 1501
  if ((format & 268369920) == 851968) {
#line 1501
    goto case_851968;
  }
#line 1502
  if ((format & 268369920) == 917504) {
#line 1502
    goto case_917504;
  }
#line 1503
  if ((format & 268369920) == 983040) {
#line 1503
    goto case_983040;
  }
#line 1504
  if ((format & 268369920) == 1048576) {
#line 1504
    goto case_1048576;
  }
#line 1505
  if ((format & 268369920) == 1114112) {
#line 1505
    goto case_1114112;
  }
#line 1506
  if ((format & 268369920) == 1179648) {
#line 1506
    goto case_1179648;
  }
#line 1507
  if ((format & 268369920) == 1245184) {
#line 1507
    goto case_1245184;
  }
#line 1508
  if ((format & 268369920) == 1441792) {
#line 1508
    goto case_1441792;
  }
#line 1509
  if ((format & 268369920) == 1507328) {
#line 1509
    goto case_1507328;
  }
#line 1510
  if ((format & 268369920) == 1572864) {
#line 1510
    goto case_1572864;
  }
#line 1511
  if ((format & 268369920) == 1638400) {
#line 1511
    goto case_1638400;
  }
#line 1512
  if ((format & 268369920) == 2097152) {
#line 1512
    goto case_2097152;
  }
#line 1513
  goto switch_default;
  case_65536: 
#line 1490
  return ("SF_FORMAT_WAVU");
#line 1490
  goto switch_break;
  case_131072: 
#line 1491
  return ("SF_FORMAT_AIFF");
#line 1491
  goto switch_break;
  case_196608: 
#line 1492
  return ("SF_FORMAT_AU");
#line 1492
  goto switch_break;
  case_262144: 
#line 1493
  return ("SF_FORMAT_RAW");
#line 1493
  goto switch_break;
  case_327680: 
#line 1494
  return ("SF_FORMAT_PAFU");
#line 1494
  goto switch_break;
  case_393216: 
#line 1495
  return ("SF_FORMAT_SVXU");
#line 1495
  goto switch_break;
  case_458752: 
#line 1496
  return ("SF_FORMAT_NIST");
#line 1496
  goto switch_break;
  case_524288: 
#line 1497
  return ("SF_FORMAT_VOC");
#line 1497
  goto switch_break;
  case_655360: 
#line 1498
  return ("SF_FORMAT_IRCAM");
#line 1498
  goto switch_break;
  case_720896: 
#line 1499
  return ("SF_FORMAT_W64");
#line 1499
  goto switch_break;
  case_786432: 
#line 1500
  return ("SF_FORMAT_MAT4");
#line 1500
  goto switch_break;
  case_851968: 
#line 1501
  return ("SF_FORMAT_MAT5");
#line 1501
  goto switch_break;
  case_917504: 
#line 1502
  return ("SF_FORMAT_PVF");
#line 1502
  goto switch_break;
  case_983040: 
#line 1503
  return ("SF_FORMAT_XI\270U");
#line 1503
  goto switch_break;
  case_1048576: 
#line 1504
  return ("SF_FORMAT_HTK");
#line 1504
  goto switch_break;
  case_1114112: 
#line 1505
  return ("SF_FORMAT_SDS");
#line 1505
  goto switch_break;
  case_1179648: 
#line 1506
  return ("SF_FORMAT_AVRU");
#line 1506
  goto switch_break;
  case_1245184: 
#line 1507
  return ("SF_FORMAT_WAVEX");
#line 1507
  goto switch_break;
  case_1441792: 
#line 1508
  return ("SF_FORMAT_SD2");
#line 1508
  goto switch_break;
  case_1507328: 
#line 1509
  return ("SF_FORMAT_FLAC");
#line 1509
  goto switch_break;
  case_1572864: 
#line 1510
  return ("SF_FORMAT_CAF");
#line 1510
  goto switch_break;
  case_1638400: 
#line 1511
  return ("SF_FORMAT_WVE");
#line 1511
  goto switch_break;
  case_2097152: 
#line 1512
  return ("SF_FORMAT_OGG");
#line 1512
  goto switch_break;
  switch_default: 
#line 1514
  goto switch_break;
  switch_break: ;
#line 1517
  return ("BAD_MAJOR_FORMAT\220");
}
}
#line 1521 "/root/patchweave_new/23/src/common.c"
char const   *str_of_minor_format(int format ) 
{ 


  {
#line 1523
  if ((format & 65535) == 1) {
#line 1523
    goto case_1;
  }
#line 1524
  if ((format & 65535) == 2) {
#line 1524
    goto case_2;
  }
#line 1525
  if ((format & 65535) == 3) {
#line 1525
    goto case_3;
  }
#line 1526
  if ((format & 65535) == 4) {
#line 1526
    goto case_4;
  }
#line 1527
  if ((format & 65535) == 5) {
#line 1527
    goto case_5;
  }
#line 1528
  if ((format & 65535) == 6) {
#line 1528
    goto case_6;
  }
#line 1529
  if ((format & 65535) == 7) {
#line 1529
    goto case_7;
  }
#line 1530
  if ((format & 65535) == 16) {
#line 1530
    goto case_16;
  }
#line 1531
  if ((format & 65535) == 17) {
#line 1531
    goto case_17;
  }
#line 1532
  if ((format & 65535) == 18) {
#line 1532
    goto case_18;
  }
#line 1533
  if ((format & 65535) == 19) {
#line 1533
    goto case_19;
  }
#line 1534
  if ((format & 65535) == 32) {
#line 1534
    goto case_32;
  }
#line 1535
  if ((format & 65535) == 33) {
#line 1535
    goto case_33;
  }
#line 1536
  if ((format & 65535) == 48) {
#line 1536
    goto case_48;
  }
#line 1537
  if ((format & 65535) == 49) {
#line 1537
    goto case_49;
  }
#line 1538
  if ((format & 65535) == 50) {
#line 1538
    goto case_50;
  }
#line 1539
  if ((format & 65535) == 64) {
#line 1539
    goto case_64;
  }
#line 1540
  if ((format & 65535) == 65) {
#line 1540
    goto case_65;
  }
#line 1541
  if ((format & 65535) == 66) {
#line 1541
    goto case_66;
  }
#line 1542
  if ((format & 65535) == 67) {
#line 1542
    goto case_67;
  }
#line 1543
  if ((format & 65535) == 80) {
#line 1543
    goto case_80;
  }
#line 1544
  if ((format & 65535) == 81) {
#line 1544
    goto case_81;
  }
#line 1545
  if ((format & 65535) == 96) {
#line 1545
    goto case_96;
  }
#line 1546
  goto switch_default;
  case_1: 
#line 1523
  return ("SF_FORMAT_PCM_S8\220");
#line 1523
  goto switch_break;
  case_2: 
#line 1524
  return ("SF_FORMAT_PCM_16\220");
#line 1524
  goto switch_break;
  case_3: 
#line 1525
  return ("SF_FORMAT_PCM_24\220");
#line 1525
  goto switch_break;
  case_4: 
#line 1526
  return ("SF_FORMAT_PCM_32\220");
#line 1526
  goto switch_break;
  case_5: 
#line 1527
  return ("SF_FORMAT_PCM_U8\220");
#line 1527
  goto switch_break;
  case_6: 
#line 1528
  return ("SF_FORMAT_FLOAT");
#line 1528
  goto switch_break;
  case_7: 
#line 1529
  return ("SF_FORMAT_DOUBLE\220");
#line 1529
  goto switch_break;
  case_16: 
#line 1530
  return ("SF_FORMAT_ULAW");
#line 1530
  goto switch_break;
  case_17: 
#line 1531
  return ("SF_FORMAT_ALAW");
#line 1531
  goto switch_break;
  case_18: 
#line 1532
  return ("SF_FORMAT_IMA_ADPCM");
#line 1532
  goto switch_break;
  case_19: 
#line 1533
  return ("SF_FORMAT_MS_ADPCM");
#line 1533
  goto switch_break;
  case_32: 
#line 1534
  return ("SF_FORMAT_GSM610\220");
#line 1534
  goto switch_break;
  case_33: 
#line 1535
  return ("SF_FORMAT_VOX_ADPCM");
#line 1535
  goto switch_break;
  case_48: 
#line 1536
  return ("SF_FORMAT_G721_32");
#line 1536
  goto switch_break;
  case_49: 
#line 1537
  return ("SF_FORMAT_G723_24");
#line 1537
  goto switch_break;
  case_50: 
#line 1538
  return ("SF_FORMAT_G723_40");
#line 1538
  goto switch_break;
  case_64: 
#line 1539
  return ("SF_FORMAT_DWVW_12");
#line 1539
  goto switch_break;
  case_65: 
#line 1540
  return ("SF_FORMAT_DWVW_16");
#line 1540
  goto switch_break;
  case_66: 
#line 1541
  return ("SF_FORMAT_DWVW_24");
#line 1541
  goto switch_break;
  case_67: 
#line 1542
  return ("SF_FORMAT_DWVW_N\220");
#line 1542
  goto switch_break;
  case_80: 
#line 1543
  return ("SF_FORMAT_DPCM_8\220");
#line 1543
  goto switch_break;
  case_81: 
#line 1544
  return ("SF_FORMAT_DPCM_16");
#line 1544
  goto switch_break;
  case_96: 
#line 1545
  return ("SF_FORMAT_VORBIS\220");
#line 1545
  goto switch_break;
  switch_default: 
#line 1547
  goto switch_break;
  switch_break: ;
#line 1550
  return ("BAD_MINOR_FORMAT\220");
}
}
#line 1554 "/root/patchweave_new/23/src/common.c"
char const   *str_of_open_mode(int mode ) 
{ 


  {
#line 1556
  if (mode == 16) {
#line 1556
    goto case_16;
  }
#line 1557
  if (mode == 32) {
#line 1557
    goto case_32;
  }
#line 1558
  if (mode == 48) {
#line 1558
    goto case_48;
  }
#line 1560
  goto switch_default;
  case_16: 
#line 1556
  return ("SFM_READ\220");
#line 1556
  goto switch_break;
  case_32: 
#line 1557
  return ("SFM_WRITE");
#line 1557
  goto switch_break;
  case_48: 
#line 1558
  return ("SFM_RDWR\220");
#line 1558
  goto switch_break;
  switch_default: 
#line 1561
  goto switch_break;
  switch_break: ;
#line 1564
  return ("BAD_MODE\220");
}
}
#line 1568 "/root/patchweave_new/23/src/common.c"
char const   *str_of_endianness(int end ) 
{ 


  {
#line 1570
  if (end == 536870912) {
#line 1570
    goto case_536870912;
  }
#line 1571
  if (end == 268435456) {
#line 1571
    goto case_268435456;
  }
#line 1572
  if (end == 805306368) {
#line 1572
    goto case_805306368;
  }
#line 1573
  goto switch_default;
  case_536870912: 
#line 1570
  return ("SF_ENDIAN_BIG");
#line 1570
  goto switch_break;
  case_268435456: 
#line 1571
  return ("SF_ENDIAN_LITTLE\220");
#line 1571
  goto switch_break;
  case_805306368: 
#line 1572
  return ("SF_ENDIAN_CPU");
#line 1572
  goto switch_break;
  switch_default: 
#line 1574
  goto switch_break;
  switch_break: ;
#line 1578
  return ("\220");
}
}
#line 1585 "/root/patchweave_new/23/src/common.c"
void psf_f2s_array(float const   *src , short *dest , int count___0 , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1588
  if (normalize) {
#line 1588
    tmp = 1. * (double )32767;
  } else {
#line 1588
    tmp = 1.;
  }
#line 1588
  normfact = (float )tmp;
  {
#line 1589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1589
    count___0 --;
#line 1589
    if (! (count___0 >= 0)) {
#line 1589
      goto while_break;
    }
    {
#line 1590
    __cil_tmp7 = lrintf((float )(*(src + count___0) * (float const   )normfact));
#line 1590
    *(dest + count___0) = (short )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1592
  return;
}
}
#line 1596 "/root/patchweave_new/23/src/common.c"
void psf_f2s_clip_array(float const   *src , short *dest , int count___0 , int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1599
  if (normalize) {
#line 1599
    tmp = 1. * (double )32768;
  } else {
#line 1599
    tmp = 1.;
  }
#line 1599
  normfact = (float )tmp;
  {
#line 1601
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1601
    count___0 --;
#line 1601
    if (! (count___0 >= 0)) {
#line 1601
      goto while_break;
    }
#line 1602
    scaled_value = (float )(*(src + count___0) * (float const   )normfact);
#line 1603
    if ((double )scaled_value >= 1. * (double )32767) {
#line 1604
      *(dest + count___0) = (short)32767;
#line 1605
      goto while_continue;
    }
#line 1607
    if ((double )scaled_value <= - 8. * (double )4096) {
#line 1608
      *(dest + count___0) = (short)-32768;
#line 1609
      goto while_continue;
    }
    {
#line 1612
    __cil_tmp8 = lrintf(scaled_value);
#line 1612
    *(dest + count___0) = (short )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1615
  return;
}
}
#line 1619 "/root/patchweave_new/23/src/common.c"
void psf_d2s_array(double const   *src , short *dest , int count___0 , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1622
  if (normalize) {
#line 1622
    tmp = 1. * (double )32767;
  } else {
#line 1622
    tmp = 1.;
  }
#line 1622
  normfact = tmp;
  {
#line 1623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1623
    count___0 --;
#line 1623
    if (! (count___0 >= 0)) {
#line 1623
      goto while_break;
    }
    {
#line 1624
    __cil_tmp7 = lrint((double )(*(src + count___0) * (double const   )normfact));
#line 1624
    *(dest + count___0) = (short )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1626
  return;
}
}
#line 1630 "/root/patchweave_new/23/src/common.c"
void psf_d2s_clip_array(double const   *src , short *dest , int count___0 , int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1633
  if (normalize) {
#line 1633
    tmp = 1. * (double )32768;
  } else {
#line 1633
    tmp = 1.;
  }
#line 1633
  normfact = tmp;
  {
#line 1635
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1635
    count___0 --;
#line 1635
    if (! (count___0 >= 0)) {
#line 1635
      goto while_break;
    }
#line 1636
    scaled_value = (double )(*(src + count___0) * (double const   )normfact);
#line 1637
    if (scaled_value >= 1. * (double )32767) {
#line 1638
      *(dest + count___0) = (short)32767;
#line 1639
      goto while_continue;
    }
#line 1641
    if (scaled_value <= - 8. * (double )4096) {
#line 1642
      *(dest + count___0) = (short)-32768;
#line 1643
      goto while_continue;
    }
    {
#line 1646
    __cil_tmp8 = lrint(scaled_value);
#line 1646
    *(dest + count___0) = (short )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1649
  return;
}
}
#line 1654 "/root/patchweave_new/23/src/common.c"
void psf_f2i_array(float const   *src , int *dest , int count___0 , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1657
  if (normalize) {
#line 1657
    tmp = 1. * (double )2147483647;
  } else {
#line 1657
    tmp = 1.;
  }
#line 1657
  normfact = (float )tmp;
  {
#line 1658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1658
    count___0 --;
#line 1658
    if (! (count___0 >= 0)) {
#line 1658
      goto while_break;
    }
    {
#line 1659
    __cil_tmp7 = lrintf((float )(*(src + count___0) * (float const   )normfact));
#line 1659
    *(dest + count___0) = (int )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1661
  return;
}
}
#line 1665 "/root/patchweave_new/23/src/common.c"
void psf_f2i_clip_array(float const   *src , int *dest , int count___0 , int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1668
  if (normalize) {
#line 1668
    tmp = 8. * (double )268435456;
  } else {
#line 1668
    tmp = 1.;
  }
#line 1668
  normfact = (float )tmp;
  {
#line 1670
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1670
    count___0 --;
#line 1670
    if (! (count___0 >= 0)) {
#line 1670
      goto while_break;
    }
#line 1671
    scaled_value = (float )(*(src + count___0) * (float const   )normfact);
#line 1672
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 1673
      *(dest + count___0) = 2147483647;
#line 1674
      goto while_continue;
    }
#line 1676
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 1677
      *(dest + count___0) = (-0x7FFFFFFF-1);
#line 1678
      goto while_continue;
    }
    {
#line 1681
    __cil_tmp8 = lrintf(scaled_value);
#line 1681
    *(dest + count___0) = (int )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1684
  return;
}
}
#line 1688 "/root/patchweave_new/23/src/common.c"
void psf_d2i_array(double const   *src , int *dest , int count___0 , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1691
  if (normalize) {
#line 1691
    tmp = 1. * (double )2147483647;
  } else {
#line 1691
    tmp = 1.;
  }
#line 1691
  normfact = tmp;
  {
#line 1692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1692
    count___0 --;
#line 1692
    if (! (count___0 >= 0)) {
#line 1692
      goto while_break;
    }
    {
#line 1693
    __cil_tmp7 = lrint((double )(*(src + count___0) * (double const   )normfact));
#line 1693
    *(dest + count___0) = (int )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1695
  return;
}
}
#line 1699 "/root/patchweave_new/23/src/common.c"
void psf_d2i_clip_array(double const   *src , int *dest , int count___0 , int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1702
  if (normalize) {
#line 1702
    tmp = 8. * (double )268435456;
  } else {
#line 1702
    tmp = 1.;
  }
#line 1702
  normfact = tmp;
  {
#line 1704
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1704
    count___0 --;
#line 1704
    if (! (count___0 >= 0)) {
#line 1704
      goto while_break;
    }
#line 1705
    scaled_value = (double )(*(src + count___0) * (double const   )normfact);
#line 1706
    if (scaled_value >= 1. * (double )2147483647) {
#line 1707
      *(dest + count___0) = 2147483647;
#line 1708
      goto while_continue;
    }
#line 1710
    if (scaled_value <= - 8. * (double )268435456) {
#line 1711
      *(dest + count___0) = (-0x7FFFFFFF-1);
#line 1712
      goto while_continue;
    }
    {
#line 1715
    __cil_tmp8 = lrint(scaled_value);
#line 1715
    *(dest + count___0) = (int )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1718
  return;
}
}
#line 1722 "/root/patchweave_new/23/src/common.c"
FILE *psf_open_tmpfile(char *fname , size_t fnamelen ) 
{ 
  char const   *tmpdir ;
  FILE *file ;
  char *__cil_tmp6 ;
  char const   *tmp ;
  int __cil_tmp8 ;
  int32_t __cil_tmp9 ;
  int32_t __cil_tmp10 ;
  int32_t __cil_tmp12 ;
  int32_t __cil_tmp13 ;

  {
  {
#line 1729
  __cil_tmp6 = getenv("TMPDIR");
#line 1729
  tmpdir = (char const   *)__cil_tmp6;
  }
#line 1730
  if ((unsigned long )tmpdir == (unsigned long )((void *)0)) {
#line 1730
    tmp = "/tmp";
  } else {
#line 1730
    tmp = tmpdir;
  }
  {
#line 1730
  tmpdir = tmp;
#line 1733
  __cil_tmp8 = access(tmpdir, 7);
  }
#line 1733
  if (tmpdir) {
#line 1733
    if (__cil_tmp8 == 0) {
      {
#line 1734
      __cil_tmp9 = psf_rand_int32();
#line 1734
      __cil_tmp10 = psf_rand_int32();
#line 1734
      snprintf(fname, fnamelen, "%s/%x%x-alac.tmp\230\001", tmpdir, __cil_tmp9, __cil_tmp10);
#line 1735
      file = fopen((char const   *)fname, "wb+");
      }
#line 1735
      if ((unsigned long )file != (unsigned long )((void *)0)) {
#line 1736
        return (file);
      }
    }
  }
  {
#line 1739
  __cil_tmp12 = psf_rand_int32();
#line 1739
  __cil_tmp13 = psf_rand_int32();
#line 1739
  snprintf(fname, fnamelen, "%x%x-alac.tmp", __cil_tmp12, __cil_tmp13);
#line 1740
  file = fopen((char const   *)fname, "wb+");
  }
#line 1740
  if ((unsigned long )file != (unsigned long )((void *)0)) {
#line 1741
    return (file);
  }
  {
#line 1743
  memset((void *)fname, 0, fnamelen);
  }
#line 1744
  return ((FILE *)((void *)0));
}
}
#line 28 "/root/patchweave_new/23/src/command.c"
static SF_FORMAT_INFO simple_formats[15]  = 
#line 28 "/root/patchweave_new/23/src/command.c"
  {      {131074, "AIFF (Apple/SGI 16 bit PCM)", "aiff"}, 
        {131078, "AIFF (Apple/SGI 32 bit float)", "aifc"}, 
        {131073, "AIFF (Apple/SGI 8 bit PCM)", "aiff"}, 
        {196610, "AU (Sun/Next 16 bit PCM)", "au"}, 
        {196624, "AU (Sun/Next 8-bit u-law)", "au"}, 
        {1572976, "CAF (Apple 16 bit ALAC)", "caf"}, 
        {1572866, "CAF (Apple 16 bit PCM)", "cafA\270U"}, 
        {1507330, "FLAC 16 bit", "flac"}, 
        {262177, "OKI Dialogic VOX ADPCM", "vox"}, 
        {2097248, "Ogg Vorbis (Xiph Foundation)", "oga"}, 
        {65538, "WAV (Microsoft 16 bit PCM)", "wav"}, 
        {65542, "WAV (Microsoft 32 bit float)", "wav"}, 
        {65554, "WAV (Microsoft 4 bit IMA ADPCM)", "wav"}, 
        {65555, "WAV (Microsoft 4 bit MS ADPCM)", "wav"}, 
        {65541, "WAV (Microsoft 8 bit PCM)", "wav"}};
#line 97 "/root/patchweave_new/23/src/command.c"
int psf_get_format_simple_count(void) 
{ 


  {
#line 98
  return ((int )(sizeof(simple_formats) / sizeof(SF_FORMAT_INFO )));
}
}
#line 102 "/root/patchweave_new/23/src/command.c"
int psf_get_format_simple(SF_FORMAT_INFO *data ) 
{ 
  int indx ;

  {
#line 105
  if (data->format < 0) {
#line 106
    return (31);
  } else
#line 105
  if (data->format >= (int )sizeof(simple_formats) / (int )sizeof(SF_FORMAT_INFO )) {
#line 106
    return (31);
  }
  {
#line 108
  indx = data->format;
#line 109
  memcpy((void *)data, (void const   *)(& simple_formats[indx]), (unsigned long )((int )sizeof(SF_FORMAT_INFO )));
  }
#line 111
  return (0);
}
}
#line 118 "/root/patchweave_new/23/src/command.c"
static SF_FORMAT_INFO major_formats[25]  = 
#line 118
  {      {131072, "AIFF (Apple/SGI)\323\001 ", "aiff"}, 
        {196608, "AU (Sun/NeXT)", "au"}, 
        {1179648, "AVR (Audio Visual Research)", "avr"}, 
        {1572864, "CAF (Apple Core Audio File)", "caf"}, 
        {1507328, "FLAC (Free Lossless Audio Codec)\323\001 ", "flac"}, 
        {1048576, "HTK (HMM Tool Kit)", "htkA\270U"}, 
        {393216, "IFF (Amiga IFF/SVX8/SV16)", "iff"}, 
        {786432, "MAT4 (GNU Octave 2.0 / Matlab 4.2)", "mat"}, 
        {851968, "MAT5 (GNU Octave 2.1 / Matlab 5.0)", "mat"}, 
        {2162688, "MPC (Akai MPC 2k)", "mpc"}, 
        {2097152, "OGG (OGG Container format)", "oga"}, 
        {327680, "PAF (Ensoniq PARIS)", "paf"}, 
        {917504, "PVF (Portable Voice Format)", "pvf"}, 
        {262144, "RAW (header-less)", "raw"}, 
        {2228224, "RF64 (RIFF 64)", "rf64"}, 
        {1441792, "SD2 (Sound Designer II)", "sd2"}, 
        {1114112, "SDS (Midi Sample Dump Standard)", "sds"}, 
        {655360, "SF (Berkeley/IRCAM/CARL)\323\001 ", "sfRA\270U"}, 
        {524288, "VOC (Creative Labs)", "vocA\270U"}, 
        {720896, "W64 (SoundFoundry WAVE 64)", "w64"}, 
        {65536, "WAV (Microsoft)", "wav"}, 
        {458752, "WAV (NIST Sphere)", "wav"}, 
        {1245184, "WAVEX (Microsoft)\245uA\270U", "wavA\270U"}, 
        {1638400, "WVE (Psion Series 3)", "wve"}, 
        {983040, "XI (FastTracker 2)uA\270U", "xiuA\270U"}};
#line 153 "/root/patchweave_new/23/src/command.c"
int psf_get_format_major_count(void) 
{ 


  {
#line 154
  return ((int )(sizeof(major_formats) / sizeof(SF_FORMAT_INFO )));
}
}
#line 158 "/root/patchweave_new/23/src/command.c"
int psf_get_format_major(SF_FORMAT_INFO *data ) 
{ 
  int indx ;

  {
#line 161
  if (data->format < 0) {
#line 162
    return (31);
  } else
#line 161
  if (data->format >= (int )sizeof(major_formats) / (int )sizeof(SF_FORMAT_INFO )) {
#line 162
    return (31);
  }
  {
#line 164
  indx = data->format;
#line 165
  memcpy((void *)data, (void const   *)(& major_formats[indx]), (unsigned long )((int )sizeof(SF_FORMAT_INFO )));
  }
#line 167
  return (0);
}
}
#line 174 "/root/patchweave_new/23/src/command.c"
static SF_FORMAT_INFO subtype_formats[25]  = 
#line 174
  {      {1, "Signed 8 bit PCM\251", (char const   *)((void *)0)}, 
        {2, "Signed 16 bit PCM", (char const   *)((void *)0)}, 
        {3, "Signed 24 bit PCM", (char const   *)((void *)0)}, 
        {4, "Signed 32 bit PCM", (char const   *)((void *)0)}, 
        {5, "Unsigned 8 bit PCMRA\270U", (char const   *)((void *)0)}, 
        {6, "32 bit float", (char const   *)((void *)0)}, 
        {7, "64 bit float", (char const   *)((void *)0)}, 
        {16, "U-Law", (char const   *)((void *)0)}, 
        {17, "A-Law", (char const   *)((void *)0)}, 
        {18, "IMA ADPCM", (char const   *)((void *)0)}, 
        {19, "Microsoft ADPCM", (char const   *)((void *)0)}, 
        {32, "GSM 6.10\251", (char const   *)((void *)0)}, 
        {48, "32kbs G721 ADPCM\251", (char const   *)((void *)0)}, 
        {49, "24kbs G723 ADPCM\251", (char const   *)((void *)0)}, 
        {64, "12 bit DWVW", (char const   *)((void *)0)}, 
        {65, "16 bit DWVW", (char const   *)((void *)0)}, 
        {66, "24 bit DWVW", (char const   *)((void *)0)}, 
        {33, "VOX ADPCM", "vox"}, 
        {81, "16 bit DPCM", (char const   *)((void *)0)}, 
        {80, "8 bit DPCM", (char const   *)((void *)0)}, 
        {96, "Vorbis", (char const   *)((void *)0)}, 
        {112, "16 bit ALAC", (char const   *)((void *)0)}, 
        {113, "20 bit ALAC", (char const   *)((void *)0)}, 
        {114, "24 bit ALAC", (char const   *)((void *)0)}, 
        {115, "32 bit ALAC", (char const   *)((void *)0)}};
#line 215 "/root/patchweave_new/23/src/command.c"
int psf_get_format_subtype_count(void) 
{ 


  {
#line 216
  return ((int )(sizeof(subtype_formats) / sizeof(SF_FORMAT_INFO )));
}
}
#line 220 "/root/patchweave_new/23/src/command.c"
int psf_get_format_subtype(SF_FORMAT_INFO *data ) 
{ 
  int indx ;

  {
#line 223
  if (data->format < 0) {
#line 224
    data->format = 0;
#line 225
    return (31);
  } else
#line 223
  if (data->format >= (int )sizeof(subtype_formats) / (int )sizeof(SF_FORMAT_INFO )) {
#line 224
    data->format = 0;
#line 225
    return (31);
  }
  {
#line 228
  indx = data->format;
#line 229
  memcpy((void *)data, (void const   *)(& subtype_formats[indx]), sizeof(SF_FORMAT_INFO ));
  }
#line 231
  return (0);
}
}
#line 238 "/root/patchweave_new/23/src/command.c"
int psf_get_format_info(SF_FORMAT_INFO *data ) 
{ 
  int k ;
  int format ;

  {
#line 241
  if (data->format & 268369920) {
#line 242
    format = data->format & 268369920;
#line 244
    k = 0;
    {
#line 244
    while (1) {
      while_continue: /* CIL Label */ ;

#line 244
      if (! (k < (int )sizeof(major_formats) / (int )sizeof(SF_FORMAT_INFO ))) {
#line 244
        goto while_break;
      }
#line 245
      if (format == major_formats[k].format) {
        {
#line 246
        memcpy((void *)data, (void const   *)(& major_formats[k]), sizeof(SF_FORMAT_INFO ));
        }
#line 247
        return (0);
      }
#line 244
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else
#line 251
  if (data->format & 65535) {
#line 252
    format = data->format & 65535;
#line 254
    k = 0;
    {
#line 254
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 254
      if (! (k < (int )sizeof(subtype_formats) / (int )sizeof(SF_FORMAT_INFO ))) {
#line 254
        goto while_break___0;
      }
#line 255
      if (format == subtype_formats[k].format) {
        {
#line 256
        memcpy((void *)data, (void const   *)(& subtype_formats[k]), sizeof(SF_FORMAT_INFO ));
        }
#line 257
        return (0);
      }
#line 254
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  {
#line 262
  memset((void *)data, 0, sizeof(SF_FORMAT_INFO ));
  }
#line 264
  return (31);
}
}
#line 271 "/root/patchweave_new/23/src/command.c"
double psf_calc_signal_max(SF_PRIVATE *psf , int normalize ) 
{ 
  BUF_UNION ubuf ;
  sf_count_t position ;
  double max_val ;
  double temp ;
  double *data ;
  int k ;
  int len ;
  int readcount ;
  int save_state ;
  sf_count_t __cil_tmp14 ;
  double tmp ;

  {
#line 278
  if (! psf->sf.seekable) {
#line 279
    psf->error = 41;
#line 280
    return (0.);
  }
#line 283
  if (! psf->read_double) {
#line 284
    psf->error = 18;
#line 285
    return (0.);
  }
  {
#line 288
  save_state = sf_command((SNDFILE *)psf, 4112, (void *)0, 0);
#line 289
  sf_command((SNDFILE *)psf, 4114, (void *)0, normalize);
#line 293
  position = sf_seek((SNDFILE *)psf, (sf_count_t )0, 1);
#line 295
  sf_seek((SNDFILE *)psf, (sf_count_t )0, 0);
#line 297
  data = ubuf.dbuf;
#line 299
  len = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0])) - (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0])) % psf->sf.channels;
#line 301
  max_val = 0.;
#line 301
  readcount = 1;
  }
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;

#line 301
    if (! (readcount > 0)) {
#line 301
      goto while_break;
    }
    {
#line 302
    __cil_tmp14 = sf_read_double((SNDFILE *)psf, data, (sf_count_t )len);
#line 302
    readcount = (int )__cil_tmp14;
#line 303
    k = 0;
    }
    {
#line 303
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 303
      if (! (k < readcount)) {
#line 303
        goto while_break___0;
      }
      {
#line 304
      temp = fabs(*(data + k));
      }
#line 305
      if (temp > max_val) {
#line 305
        tmp = temp;
      } else {
#line 305
        tmp = max_val;
      }
#line 305
      max_val = tmp;
#line 303
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 310
  sf_seek((SNDFILE *)psf, position, 0);
#line 311
  sf_command((SNDFILE *)psf, 4114, (void *)0, save_state);
  }
#line 313
  return (max_val);
}
}
#line 317 "/root/patchweave_new/23/src/command.c"
int psf_calc_max_all_channels(SF_PRIVATE *psf , double *peaks , int normalize ) 
{ 
  BUF_UNION ubuf ;
  sf_count_t position ;
  double temp ;
  double *data ;
  int k ;
  int len ;
  int readcount ;
  int save_state ;
  int chan ;
  sf_count_t __cil_tmp15 ;
  double tmp ;

  {
#line 325
  if (! psf->sf.seekable) {
#line 326
    psf->error = 41;
#line 326
    return (psf->error);
  }
#line 328
  if (! psf->read_double) {
#line 329
    psf->error = 18;
#line 329
    return (psf->error);
  }
  {
#line 331
  save_state = sf_command((SNDFILE *)psf, 4112, (void *)0, 0);
#line 332
  sf_command((SNDFILE *)psf, 4114, (void *)0, normalize);
#line 334
  memset((void *)peaks, 0, sizeof(double ) * (unsigned long )psf->sf.channels);
#line 337
  position = sf_seek((SNDFILE *)psf, (sf_count_t )0, 1);
#line 338
  sf_seek((SNDFILE *)psf, (sf_count_t )0, 0);
#line 340
  len = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0])) - (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0])) % psf->sf.channels;
#line 342
  data = ubuf.dbuf;
#line 344
  chan = 0;
#line 345
  readcount = len;
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;

#line 346
    if (! (readcount > 0)) {
#line 346
      goto while_break;
    }
    {
#line 347
    __cil_tmp15 = sf_read_double((SNDFILE *)psf, data, (sf_count_t )len);
#line 347
    readcount = (int )__cil_tmp15;
#line 348
    k = 0;
    }
    {
#line 348
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 348
      if (! (k < readcount)) {
#line 348
        goto while_break___0;
      }
      {
#line 349
      temp = fabs(*(data + k));
      }
#line 350
      if (temp > *(peaks + chan)) {
#line 350
        tmp = temp;
      } else {
#line 350
        tmp = *(peaks + chan);
      }
#line 350
      *(peaks + chan) = tmp;
#line 351
      chan = (chan + 1) % psf->sf.channels;
#line 348
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 355
  sf_seek((SNDFILE *)psf, position, 0);
#line 357
  sf_command((SNDFILE *)psf, 4114, (void *)0, save_state);
  }
#line 359
  return (0);
}
}
#line 363 "/root/patchweave_new/23/src/command.c"
int psf_get_signal_max(SF_PRIVATE *psf , double *peak ) 
{ 
  int k ;

  {
#line 366
  if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 367
    return (0);
  }
#line 369
  *(peak + 0) = (psf->peak_info)->peaks[0].value;
#line 371
  k = 1;
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;

#line 371
    if (! (k < psf->sf.channels)) {
#line 371
      goto while_break;
    }
#line 372
    *(peak + 0) = (double )0;
#line 371
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 374
  return (1);
}
}
#line 378 "/root/patchweave_new/23/src/command.c"
int psf_get_max_all_channels(SF_PRIVATE *psf , double *peaks ) 
{ 
  int k ;

  {
#line 381
  if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 382
    return (0);
  }
#line 384
  k = 0;
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;

#line 384
    if (! (k < psf->sf.channels)) {
#line 384
      goto while_break;
    }
#line 385
    *(peaks + k) = (psf->peak_info)->peaks[k].value;
#line 384
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 387
  return (1);
}
}
#line 30 "/root/patchweave_new/23/src/chunk.c"
static int64_t hash_of_str(char const   *str ) 
{ 
  int64_t marker ;
  int k ;

  {
#line 31
  marker = (int64_t )0;
#line 34
  k = 0;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;

#line 34
    if (! *(str + k)) {
#line 34
      goto while_break;
    }
#line 35
    marker = marker * 127L + (long )*((uint8_t *)str + k);
#line 34
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 37
  return (marker);
}
}
#line 41 "/root/patchweave_new/23/src/chunk.c"
SF_CHUNK_ITERATOR *psf_get_chunk_iterator(SF_PRIVATE *psf , char const   *marker_str ) 
{ 
  READ_CHUNKS *pchk ;
  int idx ;
  int tmp ;
  int64_t hash ;
  size_t marker_len ;
  int64_t __cil_tmp12 ;
  int64_t tmp___0 ;
  void *tmp___1 ;

  {
#line 42
  pchk = & psf->rchunks;
#line 45
  if (marker_str) {
    {
#line 46
    idx = psf_find_read_chunk_str(pchk, marker_str);
    }
  } else {
#line 48
    if (pchk->used > 0U) {
#line 48
      tmp = 0;
    } else {
#line 48
      tmp = -1;
    }
#line 48
    idx = tmp;
  }
#line 50
  if (idx < 0) {
#line 51
    return ((SF_CHUNK_ITERATOR *)((void *)0));
  }
#line 53
  if ((unsigned long )psf->iterator == (unsigned long )((void *)0)) {
    {
#line 54
    tmp___1 = calloc(1UL, sizeof(SF_CHUNK_ITERATOR ));
#line 54
    psf->iterator = (SF_CHUNK_ITERATOR *)tmp___1;
    }
#line 55
    if ((unsigned long )psf->iterator == (unsigned long )((void *)0)) {
#line 56
      return ((SF_CHUNK_ITERATOR *)((void *)0));
    }
  }
#line 59
  (psf->iterator)->sndfile = (SNDFILE *)psf;
#line 61
  if (marker_str) {
    {
#line 71
    marker_len = strlen(marker_str);
    }
#line 72
    if (marker_len > 64UL) {
#line 73
      marker_len = (size_t )64;
    }
#line 75
    if (marker_len > 4UL) {
      {
#line 75
      __cil_tmp12 = hash_of_str(marker_str);
#line 75
      tmp___0 = __cil_tmp12;
      }
    }
    {
#line 75
    hash = tmp___0;
#line 77
    memcpy((void *)((psf->iterator)->id), (void const   *)marker_str, marker_len);
#line 78
    (psf->iterator)->id_size = (unsigned int )marker_len;
#line 79
    (psf->iterator)->hash = hash;
    }
  }
#line 82
  (psf->iterator)->current = (uint32_t )idx;
#line 84
  return (psf->iterator);
}
}
#line 88 "/root/patchweave_new/23/src/chunk.c"
SF_CHUNK_ITERATOR *psf_next_chunk_iterator(READ_CHUNKS *pchk , SF_CHUNK_ITERATOR *iterator ) 
{ 
  uint64_t hash ;
  uint32_t k ;

  {
#line 89
  hash = (uint64_t )iterator->hash;
#line 92
  (iterator->current) ++;
#line 94
  if (hash) {
#line 95
    k = iterator->current;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;

#line 95
      if (! (k < pchk->used)) {
#line 95
        goto while_break;
      }
#line 96
      if ((pchk->chunks + k)->hash == hash) {
#line 97
        iterator->current = k;
#line 98
        return (iterator);
      }
#line 95
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  } else
#line 101
  if (iterator->current < pchk->used) {
#line 102
    return (iterator);
  }
  {
#line 105
  memset((void *)iterator, 0, sizeof(*iterator));
  }
#line 106
  return ((SF_CHUNK_ITERATOR *)((void *)0));
}
}
#line 110 "/root/patchweave_new/23/src/chunk.c"
static int psf_store_read_chunk(READ_CHUNKS *pchk , READ_CHUNK *rchunk ) 
{ 
  READ_CHUNK *old_ptr ;
  int new_count ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 111
  if (pchk->count == 0U) {
    {
#line 112
    pchk->used = (uint32_t )0;
#line 113
    pchk->count = (uint32_t )20;
#line 114
    tmp = calloc((unsigned long )pchk->count, sizeof(READ_CHUNK ));
#line 114
    pchk->chunks = (READ_CHUNK *)tmp;
    }
  } else
#line 116
  if (pchk->used > pchk->count) {
#line 117
    return (30);
  } else
#line 118
  if (pchk->used == pchk->count) {
    {
#line 119
    old_ptr = pchk->chunks;
#line 120
    new_count = (int )((3U * (pchk->count + 1U)) / 2U);
#line 122
    tmp___0 = realloc((void *)old_ptr, (unsigned long )new_count * sizeof(READ_CHUNK ));
#line 122
    pchk->chunks = (READ_CHUNK *)tmp___0;
    }
#line 123
    if ((unsigned long )pchk->chunks == (unsigned long )((void *)0)) {
#line 124
      pchk->chunks = old_ptr;
#line 125
      return (17);
    }
#line 127
    pchk->count = (uint32_t )new_count;
  }
#line 130
  *(pchk->chunks + pchk->used) = *rchunk;
#line 132
  (pchk->used) ++;
#line 134
  return (0);
}
}
#line 138 "/root/patchweave_new/23/src/chunk.c"
int psf_store_read_chunk_u32(READ_CHUNKS *pchk , uint32_t marker , sf_count_t offset ,
                             uint32_t len ) 
{ 
  READ_CHUNK rchunk ;
  int __cil_tmp6 ;

  {
  {
#line 141
  memset((void *)(& rchunk), 0, sizeof(rchunk));
#line 143
  rchunk.hash = (uint64_t )marker;
#line 144
  rchunk.mark32 = marker;
#line 145
  rchunk.offset = offset;
#line 146
  rchunk.len = len;
#line 148
  rchunk.id_size = 4U;
#line 149
  memcpy((void *)(rchunk.id), (void const   *)(& marker), (unsigned long )rchunk.id_size);
#line 151
  __cil_tmp6 = psf_store_read_chunk(pchk, & rchunk);
  }
#line 151
  return (__cil_tmp6);
}
}
#line 155 "/root/patchweave_new/23/src/chunk.c"
int psf_find_read_chunk_str(READ_CHUNKS *pchk , char const   *marker_str ) 
{ 
  uint64_t hash ;
  uint32_t k ;
  union __anonunion_740 u ;
  unsigned long __cil_tmp6 ;
  int64_t __cil_tmp7 ;
  int64_t tmp ;

  {
  {
#line 163
  snprintf(u.str, sizeof(u.str), "%s\217A\270U", marker_str);
#line 165
  __cil_tmp6 = strlen(marker_str);
  }
#line 165
  if (__cil_tmp6 > 4UL) {
    {
#line 165
    __cil_tmp7 = hash_of_str(marker_str);
#line 165
    tmp = __cil_tmp7;
    }
  } else {
#line 165
    tmp = (long )u.marker;
  }
#line 165
  hash = (uint64_t )tmp;
#line 167
  k = (uint32_t )0;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;

#line 167
    if (! (k < pchk->used)) {
#line 167
      goto while_break;
    }
#line 168
    if ((pchk->chunks + k)->hash == hash) {
#line 169
      return ((int )k);
    }
#line 167
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 171
  return (-1);
}
}
#line 175 "/root/patchweave_new/23/src/chunk.c"
int psf_find_read_chunk_m32(READ_CHUNKS *pchk , uint32_t marker ) 
{ 
  uint32_t k ;

  {
#line 178
  k = (uint32_t )0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;

#line 178
    if (! (k < pchk->used)) {
#line 178
      goto while_break;
    }
#line 179
    if ((pchk->chunks + k)->mark32 == marker) {
#line 180
      return ((int )k);
    }
#line 178
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 182
  return (-1);
}
}
#line 185 "/root/patchweave_new/23/src/chunk.c"
int psf_find_read_chunk_iterator(READ_CHUNKS *pchk , SF_CHUNK_ITERATOR *marker ) 
{ 


  {
#line 186
  if (marker->current < pchk->used) {
#line 187
    return ((int )marker->current);
  }
#line 189
  return (-1);
}
}
#line 193 "/root/patchweave_new/23/src/chunk.c"
int psf_store_read_chunk_str(READ_CHUNKS *pchk , char const   *marker_str , sf_count_t offset ,
                             uint32_t len ) 
{ 
  READ_CHUNK rchunk ;
  union __anonunion_741 u ;
  size_t marker_len ;
  int64_t __cil_tmp9 ;
  int64_t tmp ;
  unsigned long tmp___0 ;
  int __cil_tmp12 ;

  {
  {
#line 201
  memset((void *)(& rchunk), 0, sizeof(rchunk));
#line 202
  snprintf(u.str, sizeof(u.str), "%s\217A\270U", marker_str);
#line 204
  marker_len = strlen(marker_str);
  }
#line 206
  if (marker_len > 4UL) {
    {
#line 206
    __cil_tmp9 = hash_of_str(marker_str);
#line 206
    tmp = __cil_tmp9;
    }
  } else {
#line 206
    tmp = (long )u.marker;
  }
#line 206
  rchunk.hash = (uint64_t )tmp;
#line 207
  rchunk.mark32 = u.marker;
#line 208
  rchunk.offset = offset;
#line 209
  rchunk.len = len;
#line 211
  if (marker_len > 64UL) {
#line 211
    tmp___0 = 64UL;
  } else {
#line 211
    tmp___0 = marker_len;
  }
  {
#line 211
  rchunk.id_size = (unsigned int )tmp___0;
#line 212
  memcpy((void *)(rchunk.id), (void const   *)marker_str, (unsigned long )rchunk.id_size);
#line 214
  __cil_tmp12 = psf_store_read_chunk(pchk, & rchunk);
  }
#line 214
  return (__cil_tmp12);
}
}
#line 218 "/root/patchweave_new/23/src/chunk.c"
int psf_save_write_chunk(WRITE_CHUNKS *pchk , SF_CHUNK_INFO *chunk_info ) 
{ 
  union __anonunion_742 u ;
  uint32_t len ;
  WRITE_CHUNK *old_ptr ;
  int new_count ;
  unsigned long __cil_tmp10 ;
  int64_t __cil_tmp11 ;
  int64_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 225
  if (pchk->count == 0U) {
    {
#line 226
    pchk->used = (uint32_t )0;
#line 227
    pchk->count = (uint32_t )20;
#line 228
    tmp___0 = calloc((unsigned long )pchk->count, sizeof(WRITE_CHUNK ));
#line 228
    pchk->chunks = (WRITE_CHUNK *)tmp___0;
    }
  } else
#line 230
  if (pchk->used >= pchk->count) {
    {
#line 231
    old_ptr = pchk->chunks;
#line 232
    new_count = (int )((3U * (pchk->count + 1U)) / 2U);
#line 234
    tmp___1 = realloc((void *)old_ptr, (unsigned long )new_count * sizeof(WRITE_CHUNK ));
#line 234
    pchk->chunks = (WRITE_CHUNK *)tmp___1;
    }
#line 235
    if ((unsigned long )pchk->chunks == (unsigned long )((void *)0)) {
#line 236
      pchk->chunks = old_ptr;
#line 237
      return (17);
    }
  }
#line 241
  len = chunk_info->datalen;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;

#line 242
    if (! (len & 3U)) {
#line 242
      goto while_break;
    }
#line 242
    len ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 244
  snprintf(u.str, sizeof(u.str), "%s", (char const   *)(chunk_info->id));
#line 246
  __cil_tmp10 = strlen((char const   *)(chunk_info->id));
  }
#line 246
  if (__cil_tmp10 > 4UL) {
    {
#line 246
    __cil_tmp11 = hash_of_str((char const   *)(chunk_info->id));
#line 246
    tmp = __cil_tmp11;
    }
  } else {
#line 246
    tmp = (long )u.marker;
  }
  {
#line 246
  (pchk->chunks + pchk->used)->hash = (uint64_t )tmp;
#line 247
  (pchk->chunks + pchk->used)->mark32 = u.marker;
#line 248
  (pchk->chunks + pchk->used)->len = len;
#line 249
  (pchk->chunks + pchk->used)->data = psf_memdup((void const   *)chunk_info->data,
                                                 (size_t )chunk_info->datalen);
#line 251
  (pchk->used) ++;
  }
#line 253
  return (0);
}
}
#line 30 "/root/patchweave_new/23/src/chanmap.h"
int aiff_caf_find_channel_layout_tag(int const   *chan_map , int channels ) ;
#line 32
AIFF_CAF_CHANNEL_MAP *aiff_caf_of_channel_layout_tag(int tag ) ;
#line 36 "/root/patchweave_new/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP zero_chan[2]  = {      {0, (int const   *)((void *)0), "Use channel descriptions."}, 
        {1 << 16, (int const   *)((void *)0), "Use channel bitmap."}};
#line 42 "/root/patchweave_new/23/src/chanmap.c"
static int const   one_chan_mono[1]  = {      (int const   )1};
#line 44 "/root/patchweave_new/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP one_chan[1]  = {      {(100 << 16) | 1, one_chan_mono, "mono"}};
#line 49 "/root/patchweave_new/23/src/chanmap.c"
static int const   two_channel_stereo[2]  = {      (int const   )2,      (int const   )3};
#line 51 "/root/patchweave_new/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP two_chan[2]  = {      {(101 << 16) | 2, two_channel_stereo, "stereo (L, R)"}, 
        {(102 << 16) | 2, two_channel_stereo, "stereo headphones (L, R)\250"}};
#line 64 "/root/patchweave_new/23/src/chanmap.c"
static int const   three_channel_mpeg_30a[3]  = {      (int const   )2,      (int const   )3,      (int const   )4};
#line 66 "/root/patchweave_new/23/src/chanmap.c"
static int const   three_channel_mpeg_30b[3]  = {      (int const   )4,      (int const   )2,      (int const   )3};
#line 68 "/root/patchweave_new/23/src/chanmap.c"
static int const   three_channel_itu_21[3]  = {      (int const   )2,      (int const   )3,      (int const   )8};
#line 70 "/root/patchweave_new/23/src/chanmap.c"
static int const   three_channel_dvd_4[3]  = {      (int const   )2,      (int const   )3,      (int const   )11};
#line 73 "/root/patchweave_new/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP three_chan[4]  = {      {(113 << 16) | 3, three_channel_mpeg_30a, "MPEG 3 0 A (L, R, C)"}, 
        {(114 << 16) | 3, three_channel_mpeg_30b, "MPEG 3 0 B (C, L, R)"}, 
        {(131 << 16) | 3, three_channel_itu_21, "ITU 2.1 (L, R, Cs)"}, 
        {(133 << 16) | 3, three_channel_dvd_4, "DVD 4 (L, R, LFE)\240^d\375\177"}};
#line 81 "/root/patchweave_new/23/src/chanmap.c"
static int const   four_channel_ambisonc_b[4]  = {      (int const   )23,      (int const   )24,      (int const   )25,      (int const   )26};
#line 83 "/root/patchweave_new/23/src/chanmap.c"
static int const   four_channel_quad[4]  = {      (int const   )2,      (int const   )3,      (int const   )9,      (int const   )10};
#line 85 "/root/patchweave_new/23/src/chanmap.c"
static int const   four_channel_mpeg_40a[4]  = {      (int const   )2,      (int const   )3,      (int const   )4,      (int const   )8};
#line 87 "/root/patchweave_new/23/src/chanmap.c"
static int const   four_channel_mpeg_40b[4]  = {      (int const   )4,      (int const   )2,      (int const   )3,      (int const   )8};
#line 89 "/root/patchweave_new/23/src/chanmap.c"
static int const   four_channel_itu_23[4]  = {      (int const   )2,      (int const   )3,      (int const   )9,      (int const   )10};
#line 91 "/root/patchweave_new/23/src/chanmap.c"
static int const   four_channel_dvd_5[4]  = {      (int const   )2,      (int const   )3,      (int const   )11,      (int const   )8};
#line 93 "/root/patchweave_new/23/src/chanmap.c"
static int const   four_channel_dvd_10[4]  = {      (int const   )2,      (int const   )3,      (int const   )4,      (int const   )11};
#line 96 "/root/patchweave_new/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP four_chan[7]  = {      {(107 << 16) | 4, four_channel_ambisonc_b, "ambisonic B (W,  X, Y, Z)7\247A\270U"}, 
        {(108 << 16) | 4,
      four_channel_quad, "quad (Lfront, Rfront, Lrear, Rrear)"}, 
        {(115 << 16) | 4, four_channel_mpeg_40a, "MPEG 4.0 A (L, R, C, Cs)\250"}, 
        {(116 << 16) | 4, four_channel_mpeg_40b, "MPEG 4.0 B (C, L, R, Cs)\250"}, 
        {(132 << 16) | 4, four_channel_itu_23, "ITU 2.3 (L, R, Ls, Rs)"}, 
        {(134 << 16) | 4, four_channel_dvd_5, "DVD 5 (L, R, LFE, Cs)"}, 
        {(136 << 16) | 4, four_channel_dvd_10, "DVD 10 (L, R, C, LFE)"}};
#line 107 "/root/patchweave_new/23/src/chanmap.c"
static int const   five_channel_pentagonal[5]  = {      (int const   )2,      (int const   )3,      (int const   )9,      (int const   )10, 
        (int const   )4};
#line 109 "/root/patchweave_new/23/src/chanmap.c"
static int const   five_channel_mpeg_50_a[5]  = {      (int const   )2,      (int const   )3,      (int const   )4,      (int const   )9, 
        (int const   )10};
#line 111 "/root/patchweave_new/23/src/chanmap.c"
static int const   five_channel_mpeg_50_b[5]  = {      (int const   )2,      (int const   )3,      (int const   )9,      (int const   )10, 
        (int const   )4};
#line 113 "/root/patchweave_new/23/src/chanmap.c"
static int const   five_channel_mpeg_50_c[5]  = {      (int const   )2,      (int const   )4,      (int const   )3,      (int const   )9, 
        (int const   )10};
#line 115 "/root/patchweave_new/23/src/chanmap.c"
static int const   five_channel_mpeg_50_d[5]  = {      (int const   )4,      (int const   )2,      (int const   )3,      (int const   )9, 
        (int const   )10};
#line 117 "/root/patchweave_new/23/src/chanmap.c"
static int const   five_channel_dvd_6[5]  = {      (int const   )2,      (int const   )3,      (int const   )11,      (int const   )9, 
        (int const   )10};
#line 119 "/root/patchweave_new/23/src/chanmap.c"
static int const   five_channel_dvd_11[5]  = {      (int const   )2,      (int const   )3,      (int const   )4,      (int const   )11, 
        (int const   )8};
#line 121 "/root/patchweave_new/23/src/chanmap.c"
static int const   five_channel_dvd_18[5]  = {      (int const   )2,      (int const   )3,      (int const   )9,      (int const   )10, 
        (int const   )11};
#line 124 "/root/patchweave_new/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP five_chan[8]  = 
#line 124
  {      {(109 << 16) | 5, five_channel_pentagonal, "pentagonal (L,  R, Lrear, Rrear, C)"}, 
        {(117 << 16) | 5,
      five_channel_mpeg_50_a, "MPEG 5.0 A (L, R, C, Ls, Rs)"}, 
        {(118 << 16) | 5, five_channel_mpeg_50_b, "MPEG 5.0 B (L, R, Ls, Rs, C)"}, 
        {(119 << 16) | 5, five_channel_mpeg_50_c, "MPEG 5.0 C (L, C, R, Ls, Rs,)"}, 
        {(120 << 16) | 5, five_channel_mpeg_50_d, "MPEG 5.0 D (C, L, R, Ls, Rs)"}, 
        {(135 << 16) | 5, five_channel_dvd_6, "DVD 6 (L, R, LFE, Ls, Rs)"}, 
        {(137 << 16) | 5, five_channel_dvd_11, "DVD 11 (L, R, C, LFE, Cs)"}, 
        {(138 << 16) | 5, five_channel_dvd_18, "DVD 18 (L, R, Ls, Rs, LFE)"}};
#line 136 "/root/patchweave_new/23/src/chanmap.c"
static int const   six_channel_mpeg_51_a[6]  = {      (int const   )2,      (int const   )3,      (int const   )4,      (int const   )11, 
        (int const   )9,      (int const   )10};
#line 138 "/root/patchweave_new/23/src/chanmap.c"
static int const   six_channel_mpeg_51_b[6]  = {      (int const   )2,      (int const   )3,      (int const   )9,      (int const   )10, 
        (int const   )4,      (int const   )11};
#line 140 "/root/patchweave_new/23/src/chanmap.c"
static int const   six_channel_mpeg_51_c[6]  = {      (int const   )2,      (int const   )4,      (int const   )3,      (int const   )9, 
        (int const   )10,      (int const   )11};
#line 142 "/root/patchweave_new/23/src/chanmap.c"
static int const   six_channel_mpeg_51_d[6]  = {      (int const   )4,      (int const   )2,      (int const   )3,      (int const   )9, 
        (int const   )10,      (int const   )11};
#line 144 "/root/patchweave_new/23/src/chanmap.c"
static int const   six_channel_audio_unit_60[6]  = {      (int const   )2,      (int const   )3,      (int const   )9,      (int const   )10, 
        (int const   )4,      (int const   )8};
#line 146 "/root/patchweave_new/23/src/chanmap.c"
static int const   six_channel_aac_60[6]  = {      (int const   )4,      (int const   )2,      (int const   )3,      (int const   )9, 
        (int const   )10,      (int const   )8};
#line 149 "/root/patchweave_new/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP six_chan[7]  = {      {(110 << 16) | 6, (int const   *)((void *)0), "hexagonal (L, R, Lr, Rr, C, Rear)"}, 
        {(121 << 16) | 6,
      six_channel_mpeg_51_a, "MPEG 5.1 A (L, R, C, LFE, Ls, Rs)"}, 
        {(122 << 16) | 6, six_channel_mpeg_51_b, "MPEG 5.1 B (L, R, Ls, Rs, C, LFE)"}, 
        {(123 << 16) | 6,
      six_channel_mpeg_51_c, "MPEG 5.1 C (L, C, R, Ls, Rs, LFE)"}, 
        {(124 << 16) | 6, six_channel_mpeg_51_d, "MPEG 5.1 D (C, L, R, Ls, Rs, LFE)"}, 
        {(139 << 16) | 6,
      six_channel_audio_unit_60, "AudioUnit 6.0 (L, R, Ls, Rs, C, Cs)"}, 
        {(141 << 16) | 6, six_channel_aac_60, "AAC 6.0 (C, L, R, Ls, Rs, Cs)"}};
#line 160 "/root/patchweave_new/23/src/chanmap.c"
static int const   six_channel_mpeg_61a[7]  = {      (int const   )2,      (int const   )3,      (int const   )4,      (int const   )11, 
        (int const   )9,      (int const   )10,      (int const   )8};
#line 162 "/root/patchweave_new/23/src/chanmap.c"
static int const   six_channel_aac_61[7]  = {      (int const   )4,      (int const   )2,      (int const   )3,      (int const   )9, 
        (int const   )10,      (int const   )8,      (int const   )11};
#line 165 "/root/patchweave_new/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP seven_chan[4]  = {      {(125 << 16) | 7, six_channel_mpeg_61a, "MPEG 6.1 A (L, R, C, LFE, Ls, Rs, Cs)"}, 
        {(140 << 16) | 7,
      (int const   *)((void *)0), "AudioUnit 7.0 (L, R, Ls, Rs, C, Rls, Rrs)"}, 
        {(142 << 16) | 7, six_channel_aac_61, "AAC 6.1 (C, L, R, Ls, Rs, Cs, Lfe)"}, 
        {(143 << 16) | 7, (int const   *)((void *)0), "AAC 7.0 (C, L, R, Ls, Rs, Rls, Rrs,)"}};
#line 173 "/root/patchweave_new/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP eight_chan[8]  = 
#line 173
  {      {(111 << 16) | 8, (int const   *)((void *)0), "octagonal (Lf, Rf, Lr, Rr, Cf, Cr, Ls, Rs)"}, 
        {(112 << 16) | 8,
      (int const   *)((void *)0), "cube (L, R, Lrear, Rrear, Ltop, Rtop, Ltoprear, Rtoprear)"}, 
        {(126 << 16) | 8,
      (int const   *)((void *)0), "MPEG 7.1 A (L, R, C, LFE, Ls, Rs, Lc, Rc)"}, 
        {(127 << 16) | 8, (int const   *)((void *)0), "MPEG 7.1 B (C, Lc, Rc, L, R, Ls, Rs, LFE)"}, 
        {(128 << 16) | 8,
      (int const   *)((void *)0), "MPEG 7.1 C (L, R, C, LFE, Ls, R, Rls, Rrs)"}, 
        {(129 << 16) | 8, (int const   *)((void *)0), "Emagic Default 7.1 (L, R, Ls, Rs, C, LFE, Lc, Rc)"}, 
        {(130 << 16) | 8,
      (int const   *)((void *)0), "SMPTE DTV (L, R, C, LFE, Ls, Rs, Lt, Rt)\250"}, 
        {(144 << 16) | 8,
      (int const   *)((void *)0), "AAC octagonal (C, L, R, Ls, Rs, Rls, Rrs, Cs)"}};
#line 213 "/root/patchweave_new/23/src/chanmap.c"
static MAP_MAP map[9]  = 
#line 213
  {      {zero_chan, (int )(sizeof(zero_chan) / sizeof(zero_chan[0]))}, 
        {one_chan, (int )(sizeof(one_chan) / sizeof(one_chan[0]))}, 
        {two_chan, (int )(sizeof(two_chan) / sizeof(two_chan[0]))}, 
        {three_chan, (int )(sizeof(three_chan) / sizeof(three_chan[0]))}, 
        {four_chan, (int )(sizeof(four_chan) / sizeof(four_chan[0]))}, 
        {five_chan, (int )(sizeof(five_chan) / sizeof(five_chan[0]))}, 
        {six_chan, (int )(sizeof(six_chan) / sizeof(six_chan[0]))}, 
        {seven_chan, (int )(sizeof(seven_chan) / sizeof(seven_chan[0]))}, 
        {eight_chan, (int )(sizeof(eight_chan) / sizeof(eight_chan[0]))}};
#line 227 "/root/patchweave_new/23/src/chanmap.c"
int aiff_caf_find_channel_layout_tag(int const   *chan_map , int channels ) 
{ 
  AIFF_CAF_CHANNEL_MAP *curr_map ;
  unsigned int k ;
  unsigned int len ;
  int __cil_tmp6 ;

  {
#line 231
  if (channels < 1) {
#line 232
    return (0);
  } else
#line 231
  if (channels >= (int )(sizeof(map) / sizeof(map[0]))) {
#line 232
    return (0);
  }
#line 234
  curr_map = map[channels].map;
#line 235
  len = (unsigned int )map[channels].len;
#line 237
  k = 0U;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;

#line 237
    if (! (k < len)) {
#line 237
      goto while_break;
    }
#line 238
    if ((unsigned long )(curr_map + k)->channel_map != (unsigned long )((void *)0)) {
      {
#line 239
      __cil_tmp6 = memcmp((void const   *)chan_map, (void const   *)(curr_map + k)->channel_map,
                          (unsigned long )channels * sizeof(*(chan_map + 0)));
      }
#line 239
      if (__cil_tmp6 == 0) {
#line 240
        return ((curr_map + k)->channel_layout_tag);
      }
    }
#line 237
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 242
  return (0);
}
}
#line 246 "/root/patchweave_new/23/src/chanmap.c"
AIFF_CAF_CHANNEL_MAP *aiff_caf_of_channel_layout_tag(int tag ) 
{ 
  AIFF_CAF_CHANNEL_MAP *curr_map ;
  unsigned int k ;
  unsigned int len ;
  int channels ;

  {
#line 249
  channels = tag & 65535;
#line 251
  if (channels < 0) {
#line 252
    return ((AIFF_CAF_CHANNEL_MAP *)((void *)0));
  } else
#line 251
  if (channels >= (int )(sizeof(map) / sizeof(map[0]))) {
#line 252
    return ((AIFF_CAF_CHANNEL_MAP *)((void *)0));
  }
#line 254
  curr_map = map[channels].map;
#line 255
  len = (unsigned int )map[channels].len;
#line 257
  k = 0U;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;

#line 257
    if (! (k < len)) {
#line 257
      goto while_break;
    }
#line 258
    if ((curr_map + k)->channel_layout_tag == tag) {
#line 259
      return (curr_map + k);
    }
#line 257
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 261
  return ((AIFF_CAF_CHANNEL_MAP *)((void *)0));
}
}
#line 32 "/root/patchweave_new/23/src/cart.c"
__inline static size_t cart_min_size(SF_CART_INFO *info ) 
{ 


  {
#line 33
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 34
    return ((size_t )0);
  }
#line 36
  return ((unsigned long )info->tag_text_size);
}
}
#line 40 "/root/patchweave_new/23/src/cart.c"
SF_CART_INFO_16K *cart_var_alloc(void) 
{ 
  SF_CART_INFO_16K *thing ;
  void *tmp ;

  {
  {
#line 42
  tmp = malloc(sizeof(SF_CART_INFO_16K ));
#line 42
  thing = (SF_CART_INFO_16K *)tmp;
  }
#line 43
  return (thing);
}
}
#line 47 "/root/patchweave_new/23/src/cart.c"
int cart_var_set(SF_PRIVATE *psf , SF_CART_INFO *info , size_t datasize ) 
{ 
  size_t len ;
  size_t __cil_tmp5 ;
  int tmp ;

  {
#line 50
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 51
    return (0);
  }
  {
#line 53
  __cil_tmp5 = cart_min_size(info);
  }
#line 53
  if (__cil_tmp5 > datasize) {
#line 54
    psf->error = 52;
#line 55
    return (0);
  }
#line 58
  if (datasize >= sizeof(SF_CART_INFO_16K )) {
#line 59
    psf->error = 53;
#line 60
    return (0);
  }
#line 63
  if ((unsigned long )psf->cart_16k == (unsigned long )((void *)0)) {
    {
#line 64
    psf->cart_16k = cart_var_alloc();
    }
#line 64
    if ((unsigned long )psf->cart_16k == (unsigned long )((void *)0)) {
#line 65
      psf->error = 17;
#line 66
      return (0);
    }
  }
  {
#line 70
  memcpy((void *)psf->cart_16k, (void const   *)info, (size_t )0);
#line 71
  psf_strlcpy_crlf((psf->cart_16k)->tag_text, (char const   *)(info->tag_text), sizeof((psf->cart_16k)->tag_text),
                   datasize);
#line 73
  len = strlen((char const   *)((psf->cart_16k)->tag_text));
  }
#line 75
  if (len > 0UL) {
#line 75
    if ((int )(psf->cart_16k)->tag_text[len - 1UL] != 10) {
      {
#line 76
      psf_strlcat((psf->cart_16k)->tag_text, sizeof((psf->cart_16k)->tag_text), "\r\n\277A\270U");
      }
    }
  }
  {
#line 79
  len = strlen((char const   *)((psf->cart_16k)->tag_text));
  }
#line 80
  if (len & 1UL) {
#line 80
    tmp = 1;
  } else {
#line 80
    tmp = 2;
  }
#line 80
  len += (unsigned long )tmp;
#line 82
  (psf->cart_16k)->tag_text_size = (uint32_t )len;
#line 84
  return (1);
}
}
#line 89 "/root/patchweave_new/23/src/cart.c"
int cart_var_get(SF_PRIVATE *psf , SF_CART_INFO *data , size_t datasize ) 
{ 
  size_t size ;

  {
#line 91
  if ((unsigned long )psf->cart_16k == (unsigned long )((void *)0)) {
#line 92
    return (0);
  }
  {
#line 94
  size = (size_t )0;
#line 96
  memcpy((void *)data, (void const   *)psf->cart_16k, size);
  }
#line 98
  return (1);
}
}
#line 29 "/root/patchweave_new/23/src/broadcast.c"
static int gen_coding_history(char *added_history , int added_history_max , SF_INFO *psfinfo ) ;
#line 32 "/root/patchweave_new/23/src/broadcast.c"
__inline static size_t bc_min_size(SF_BROADCAST_INFO *info ) 
{ 


  {
#line 33
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 34
    return ((size_t )0);
  }
#line 36
  return ((unsigned long )info->coding_history_size);
}
}
#line 40 "/root/patchweave_new/23/src/broadcast.c"
SF_BROADCAST_INFO_16K *broadcast_var_alloc(void) 
{ 
  void *__cil_tmp1 ;

  {
  {
#line 41
  __cil_tmp1 = calloc(1UL, sizeof(SF_BROADCAST_INFO_16K ));
  }
#line 41
  return ((SF_BROADCAST_INFO_16K *)__cil_tmp1);
}
}
#line 45 "/root/patchweave_new/23/src/broadcast.c"
int broadcast_var_set(SF_PRIVATE *psf , SF_BROADCAST_INFO *info , size_t datasize ) 
{ 
  size_t len ;
  size_t __cil_tmp5 ;
  char added_history[256] ;
  int tmp ;

  {
#line 48
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 49
    return (0);
  }
  {
#line 51
  __cil_tmp5 = bc_min_size(info);
  }
#line 51
  if (__cil_tmp5 > datasize) {
#line 52
    psf->error = 50;
#line 53
    return (0);
  }
#line 56
  if (datasize >= sizeof(SF_BROADCAST_INFO_16K )) {
#line 57
    psf->error = 51;
#line 58
    return (0);
  }
#line 61
  if ((unsigned long )psf->broadcast_16k == (unsigned long )((void *)0)) {
    {
#line 62
    psf->broadcast_16k = broadcast_var_alloc();
    }
#line 62
    if ((unsigned long )psf->broadcast_16k == (unsigned long )((void *)0)) {
#line 63
      psf->error = 17;
#line 64
      return (0);
    }
  }
  {
#line 69
  memcpy((void *)psf->broadcast_16k, (void const   *)info, (size_t )0);
#line 71
  psf_strlcpy_crlf((psf->broadcast_16k)->coding_history, (char const   *)(info->coding_history),
                   sizeof((psf->broadcast_16k)->coding_history), datasize);
#line 72
  len = strlen((char const   *)((psf->broadcast_16k)->coding_history));
  }
#line 74
  if (len > 0UL) {
#line 74
    if ((int )(psf->broadcast_16k)->coding_history[len - 1UL] != 10) {
      {
#line 75
      psf_strlcat((psf->broadcast_16k)->coding_history, sizeof((psf->broadcast_16k)->coding_history),
                  "\r\n");
      }
    }
  }
#line 77
  if (psf->file.mode == 32) {
    {
#line 80
    gen_coding_history(added_history, (int )sizeof(added_history), & psf->sf);
#line 81
    psf_strlcat((psf->broadcast_16k)->coding_history, sizeof((psf->broadcast_16k)->coding_history),
                (char const   *)(added_history));
    }
  }
  {
#line 85
  len = strlen((char const   *)((psf->broadcast_16k)->coding_history));
  }
#line 86
  if (len & 1UL) {
#line 86
    tmp = 1;
  } else {
#line 86
    tmp = 0;
  }
#line 86
  len += (unsigned long )tmp;
#line 87
  (psf->broadcast_16k)->coding_history_size = (uint32_t )len;
#line 90
  (psf->broadcast_16k)->version = (short)1;
#line 92
  return (1);
}
}
#line 97 "/root/patchweave_new/23/src/broadcast.c"
int broadcast_var_get(SF_PRIVATE *psf , SF_BROADCAST_INFO *data , size_t datasize ) 
{ 
  size_t size ;

  {
#line 100
  if ((unsigned long )psf->broadcast_16k == (unsigned long )((void *)0)) {
#line 101
    return (0);
  }
  {
#line 103
  size = (size_t )0;
#line 105
  memcpy((void *)data, (void const   *)psf->broadcast_16k, size);
  }
#line 107
  return (1);
}
}
#line 114 "/root/patchweave_new/23/src/broadcast.c"
static int gen_coding_history(char *added_history , int added_history_max , SF_INFO *psfinfo ) 
{ 
  char chnstr[16] ;
  int count___0 ;
  int width ;

  {
#line 137
  if (psfinfo->channels == 0) {
#line 137
    goto case_0;
  }
#line 140
  if (psfinfo->channels == 1) {
#line 140
    goto case_1;
  }
#line 144
  if (psfinfo->channels == 2) {
#line 144
    goto case_2;
  }
#line 148
  goto switch_default;
  case_0: 
#line 138
  return (0);
  case_1: 
  {
#line 141
  psf_strlcpy(chnstr, sizeof(chnstr), "mono");
  }
#line 142
  goto switch_break;
  case_2: 
  {
#line 145
  psf_strlcpy(chnstr, sizeof(chnstr), "stereo");
  }
#line 146
  goto switch_break;
  switch_default: 
  {
#line 149
  snprintf(chnstr, sizeof(chnstr), "%uchn", psfinfo->channels);
  }
#line 150
  goto switch_break;
  switch_break: ;
#line 155
  if ((psfinfo->format & 65535) == 1) {
#line 155
    goto case_1___0;
  }
#line 155
  if ((psfinfo->format & 65535) == 5) {
#line 155
    goto case_1___0;
  }
#line 158
  if ((psfinfo->format & 65535) == 2) {
#line 158
    goto case_2___0;
  }
#line 161
  if ((psfinfo->format & 65535) == 3) {
#line 161
    goto case_3;
  }
#line 164
  if ((psfinfo->format & 65535) == 4) {
#line 164
    goto case_4;
  }
#line 167
  if ((psfinfo->format & 65535) == 6) {
#line 167
    goto case_6;
  }
#line 170
  if ((psfinfo->format & 65535) == 7) {
#line 170
    goto case_7;
  }
#line 174
  if ((psfinfo->format & 65535) == 17) {
#line 174
    goto case_17;
  }
#line 174
  if ((psfinfo->format & 65535) == 16) {
#line 174
    goto case_17;
  }
#line 177
  goto switch_default___0;
  case_1___0: 
#line 156
  width = 8;
#line 157
  goto switch_break___0;
  case_2___0: 
#line 159
  width = 16;
#line 160
  goto switch_break___0;
  case_3: 
#line 162
  width = 24;
#line 163
  goto switch_break___0;
  case_4: 
#line 165
  width = 32;
#line 166
  goto switch_break___0;
  case_6: 
#line 168
  width = 24;
#line 169
  goto switch_break___0;
  case_7: 
#line 171
  width = 53;
#line 172
  goto switch_break___0;
  case_17: 
#line 175
  width = 12;
#line 176
  goto switch_break___0;
  switch_default___0: 
#line 178
  width = 42;
#line 179
  goto switch_break___0;
  switch_break___0: 
  {
#line 182
  count___0 = snprintf(added_history, (unsigned long )added_history_max, "A=PCM,F=%u,W=%d,M=%s,T=%s-%s\r\n",
                       psfinfo->samplerate, width, chnstr, "libsndfile", "1.0.29pre1");
  }
#line 186
  if (count___0 >= added_history_max) {
#line 187
    return (0);
  }
#line 189
  return (count___0);
}
}
#line 42 "/root/patchweave_new/23/src/audio_detect.c"
static void vote_for_format(VOTE *vote , unsigned char const   *data , int datalen ) ;
#line 45 "/root/patchweave_new/23/src/audio_detect.c"
int audio_detect(SF_PRIVATE *psf , AUDIO_DETECT *ad , unsigned char const   *data ,
                 int datalen ) 
{ 
  VOTE vote ;

  {
#line 48
  if ((unsigned long )psf == (unsigned long )((void *)0)) {
#line 49
    return (0);
  }
#line 51
  if ((unsigned long )ad == (unsigned long )((void *)0)) {
#line 52
    return (0);
  } else
#line 51
  if (datalen < 256) {
#line 52
    return (0);
  }
  {
#line 54
  vote_for_format(& vote, data, datalen);
#line 56
  psf_log_printf(psf, "audio_detect :\n    le_float     : %d\n    be_float     : %d\n    le_int_24_32 : %d\n    be_int_24_32 : %d\n",
                 vote.le_float, vote.be_float, vote.le_int_24_32, vote.be_int_24_32);
  }
#line 65
  if (ad->endianness == 268435456) {
#line 65
    if (vote.le_float > (3 * datalen) / 4) {
#line 67
      return (6);
    }
  }
#line 70
  if (ad->endianness == 268435456) {
#line 70
    if (vote.le_int_24_32 > (3 * datalen) / 4) {
#line 72
      return (4);
    }
  }
#line 75
  return (0);
}
}
#line 79 "/root/patchweave_new/23/src/audio_detect.c"
static void vote_for_format(VOTE *vote , unsigned char const   *data , int datalen ) 
{ 
  int k ;

  {
  {
#line 83
  memset((void *)vote, 0, sizeof(VOTE ));
#line 85
  datalen -= datalen % 4;
#line 87
  k = 0;
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;

#line 87
    if (! (k < datalen)) {
#line 87
      goto while_break;
    }
#line 88
    if (k % 4 == 0) {
#line 89
      if ((int )*(data + k) == 0) {
#line 89
        if ((int )*(data + (k + 1)) != 0) {
#line 90
          vote->le_int_24_32 += 4;
        }
      }
#line 92
      if ((int )*(data + 2) != 0) {
#line 92
        if ((int )*(data + 3) == 0) {
#line 93
          vote->le_int_24_32 += 4;
        }
      }
#line 95
      if ((int )*(data + 0) != 0) {
#line 95
        if ((int )*(data + 3) > 67) {
#line 95
          if ((int )*(data + 3) < 75) {
#line 96
            vote->le_float += 4;
          }
        }
      }
#line 98
      if ((int )*(data + 3) != 0) {
#line 98
        if ((int )*(data + 0) > 67) {
#line 98
          if ((int )*(data + 0) < 75) {
#line 99
            vote->be_float += 4;
          }
        }
      }
    }
#line 87
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 103
  return;
}
}
#line 26 "/root/patchweave_new/23/src/alaw.c"
static sf_count_t alaw_read_alaw2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 27
static sf_count_t alaw_read_alaw2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 28
static sf_count_t alaw_read_alaw2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 29
static sf_count_t alaw_read_alaw2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 31
static sf_count_t alaw_write_s2alaw(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 32
static sf_count_t alaw_write_i2alaw(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 33
static sf_count_t alaw_write_f2alaw(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 34
static sf_count_t alaw_write_d2alaw(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 36
__inline static void alaw2s_array(unsigned char *buffer , int count___0 , short *ptr ) ;
#line 37
__inline static void alaw2i_array(unsigned char *buffer , int count___0 , int *ptr ) ;
#line 38
__inline static void alaw2f_array(unsigned char *buffer , int count___0 , float *ptr ,
                                  float normfact ) ;
#line 39
__inline static void alaw2d_array(unsigned char *buffer , int count___0 , double *ptr ,
                                  double normfact ) ;
#line 41
__inline static void s2alaw_array(short const   *ptr , int count___0 , unsigned char *buffer ) ;
#line 42
__inline static void i2alaw_array(int const   *ptr , int count___0 , unsigned char *buffer ) ;
#line 43
__inline static void f2alaw_array(float const   *ptr , int count___0 , unsigned char *buffer ,
                                  float normfact ) ;
#line 44
__inline static void d2alaw_array(double const   *ptr , int count___0 , unsigned char *buffer ,
                                  double normfact ) ;
#line 48 "/root/patchweave_new/23/src/alaw.c"
int alaw_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t tmp ;
  sf_count_t tmp___0 ;

  {
#line 50
  if (psf->file.mode == 16) {
#line 51
    psf->read_short = & alaw_read_alaw2s;
#line 52
    psf->read_int = & alaw_read_alaw2i;
#line 53
    psf->read_float = & alaw_read_alaw2f;
#line 54
    psf->read_double = & alaw_read_alaw2d;
  } else
#line 50
  if (psf->file.mode == 48) {
#line 51
    psf->read_short = & alaw_read_alaw2s;
#line 52
    psf->read_int = & alaw_read_alaw2i;
#line 53
    psf->read_float = & alaw_read_alaw2f;
#line 54
    psf->read_double = & alaw_read_alaw2d;
  }
#line 57
  if (psf->file.mode == 32) {
#line 58
    psf->write_short = & alaw_write_s2alaw;
#line 59
    psf->write_int = & alaw_write_i2alaw;
#line 60
    psf->write_float = & alaw_write_f2alaw;
#line 61
    psf->write_double = & alaw_write_d2alaw;
  } else
#line 57
  if (psf->file.mode == 48) {
#line 58
    psf->write_short = & alaw_write_s2alaw;
#line 59
    psf->write_int = & alaw_write_i2alaw;
#line 60
    psf->write_float = & alaw_write_f2alaw;
#line 61
    psf->write_double = & alaw_write_d2alaw;
  }
#line 64
  psf->bytewidth = 1;
#line 65
  psf->blockwidth = psf->sf.channels;
#line 67
  if (psf->filelength > psf->dataoffset) {
#line 68
    if (psf->dataend) {
#line 68
      tmp = psf->dataend - psf->dataoffset;
    } else {
#line 68
      tmp = psf->filelength - psf->dataoffset;
    }
#line 68
    psf->datalength = tmp;
  } else {
#line 70
    psf->datalength = (sf_count_t )0;
  }
#line 72
  if (psf->blockwidth > 0) {
#line 72
    tmp___0 = psf->datalength / (long )psf->blockwidth;
  } else {
#line 72
    tmp___0 = 0L;
  }
#line 72
  psf->sf.frames = tmp___0;
#line 74
  return (0);
}
}
#line 82 "/root/patchweave_new/23/src/alaw.c"
static short alaw_decode[256]  = 
#line 82
  {      (short)-5504,      (short)-5248,      (short)-6016,      (short)-5760, 
        (short)-4480,      (short)-4224,      (short)-4992,      (short)-4736, 
        (short)-7552,      (short)-7296,      (short)-8064,      (short)-7808, 
        (short)-6528,      (short)-6272,      (short)-7040,      (short)-6784, 
        (short)-2752,      (short)-2624,      (short)-3008,      (short)-2880, 
        (short)-2240,      (short)-2112,      (short)-2496,      (short)-2368, 
        (short)-3776,      (short)-3648,      (short)-4032,      (short)-3904, 
        (short)-3264,      (short)-3136,      (short)-3520,      (short)-3392, 
        (short)-22016,      (short)-20992,      (short)-24064,      (short)-23040, 
        (short)-17920,      (short)-16896,      (short)-19968,      (short)-18944, 
        (short)-30208,      (short)-29184,      (short)-32256,      (short)-31232, 
        (short)-26112,      (short)-25088,      (short)-28160,      (short)-27136, 
        (short)-11008,      (short)-10496,      (short)-12032,      (short)-11520, 
        (short)-8960,      (short)-8448,      (short)-9984,      (short)-9472, 
        (short)-15104,      (short)-14592,      (short)-16128,      (short)-15616, 
        (short)-13056,      (short)-12544,      (short)-14080,      (short)-13568, 
        (short)-344,      (short)-328,      (short)-376,      (short)-360, 
        (short)-280,      (short)-264,      (short)-312,      (short)-296, 
        (short)-472,      (short)-456,      (short)-504,      (short)-488, 
        (short)-408,      (short)-392,      (short)-440,      (short)-424, 
        (short)-88,      (short)-72,      (short)-120,      (short)-104, 
        (short)-24,      (short)-8,      (short)-56,      (short)-40, 
        (short)-216,      (short)-200,      (short)-248,      (short)-232, 
        (short)-152,      (short)-136,      (short)-184,      (short)-168, 
        (short)-1376,      (short)-1312,      (short)-1504,      (short)-1440, 
        (short)-1120,      (short)-1056,      (short)-1248,      (short)-1184, 
        (short)-1888,      (short)-1824,      (short)-2016,      (short)-1952, 
        (short)-1632,      (short)-1568,      (short)-1760,      (short)-1696, 
        (short)-688,      (short)-656,      (short)-752,      (short)-720, 
        (short)-560,      (short)-528,      (short)-624,      (short)-592, 
        (short)-944,      (short)-912,      (short)-1008,      (short)-976, 
        (short)-816,      (short)-784,      (short)-880,      (short)-848, 
        (short)5504,      (short)5248,      (short)6016,      (short)5760, 
        (short)4480,      (short)4224,      (short)4992,      (short)4736, 
        (short)7552,      (short)7296,      (short)8064,      (short)7808, 
        (short)6528,      (short)6272,      (short)7040,      (short)6784, 
        (short)2752,      (short)2624,      (short)3008,      (short)2880, 
        (short)2240,      (short)2112,      (short)2496,      (short)2368, 
        (short)3776,      (short)3648,      (short)4032,      (short)3904, 
        (short)3264,      (short)3136,      (short)3520,      (short)3392, 
        (short)22016,      (short)20992,      (short)24064,      (short)23040, 
        (short)17920,      (short)16896,      (short)19968,      (short)18944, 
        (short)30208,      (short)29184,      (short)32256,      (short)31232, 
        (short)26112,      (short)25088,      (short)28160,      (short)27136, 
        (short)11008,      (short)10496,      (short)12032,      (short)11520, 
        (short)8960,      (short)8448,      (short)9984,      (short)9472, 
        (short)15104,      (short)14592,      (short)16128,      (short)15616, 
        (short)13056,      (short)12544,      (short)14080,      (short)13568, 
        (short)344,      (short)328,      (short)376,      (short)360, 
        (short)280,      (short)264,      (short)312,      (short)296, 
        (short)472,      (short)456,      (short)504,      (short)488, 
        (short)408,      (short)392,      (short)440,      (short)424, 
        (short)88,      (short)72,      (short)120,      (short)104, 
        (short)24,      (short)8,      (short)56,      (short)40, 
        (short)216,      (short)200,      (short)248,      (short)232, 
        (short)152,      (short)136,      (short)184,      (short)168, 
        (short)1376,      (short)1312,      (short)1504,      (short)1440, 
        (short)1120,      (short)1056,      (short)1248,      (short)1184, 
        (short)1888,      (short)1824,      (short)2016,      (short)1952, 
        (short)1632,      (short)1568,      (short)1760,      (short)1696, 
        (short)688,      (short)656,      (short)752,      (short)720, 
        (short)560,      (short)528,      (short)624,      (short)592, 
        (short)944,      (short)912,      (short)1008,      (short)976, 
        (short)816,      (short)784,      (short)880,      (short)848};
#line 118 "/root/patchweave_new/23/src/alaw.c"
static unsigned char alaw_encode[2049]  = 
#line 118
  {      (unsigned char)213,      (unsigned char)212,      (unsigned char)215,      (unsigned char)214, 
        (unsigned char)209,      (unsigned char)208,      (unsigned char)211,      (unsigned char)210, 
        (unsigned char)221,      (unsigned char)220,      (unsigned char)223,      (unsigned char)222, 
        (unsigned char)217,      (unsigned char)216,      (unsigned char)219,      (unsigned char)218, 
        (unsigned char)197,      (unsigned char)196,      (unsigned char)199,      (unsigned char)198, 
        (unsigned char)193,      (unsigned char)192,      (unsigned char)195,      (unsigned char)194, 
        (unsigned char)205,      (unsigned char)204,      (unsigned char)207,      (unsigned char)206, 
        (unsigned char)201,      (unsigned char)200,      (unsigned char)203,      (unsigned char)202, 
        (unsigned char)245,      (unsigned char)245,      (unsigned char)244,      (unsigned char)244, 
        (unsigned char)247,      (unsigned char)247,      (unsigned char)246,      (unsigned char)246, 
        (unsigned char)241,      (unsigned char)241,      (unsigned char)240,      (unsigned char)240, 
        (unsigned char)243,      (unsigned char)243,      (unsigned char)242,      (unsigned char)242, 
        (unsigned char)253,      (unsigned char)253,      (unsigned char)252,      (unsigned char)252, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)254,      (unsigned char)254, 
        (unsigned char)249,      (unsigned char)249,      (unsigned char)248,      (unsigned char)248, 
        (unsigned char)251,      (unsigned char)251,      (unsigned char)250,      (unsigned char)250, 
        (unsigned char)229,      (unsigned char)229,      (unsigned char)229,      (unsigned char)229, 
        (unsigned char)228,      (unsigned char)228,      (unsigned char)228,      (unsigned char)228, 
        (unsigned char)231,      (unsigned char)231,      (unsigned char)231,      (unsigned char)231, 
        (unsigned char)230,      (unsigned char)230,      (unsigned char)230,      (unsigned char)230, 
        (unsigned char)225,      (unsigned char)225,      (unsigned char)225,      (unsigned char)225, 
        (unsigned char)224,      (unsigned char)224,      (unsigned char)224,      (unsigned char)224, 
        (unsigned char)227,      (unsigned char)227,      (unsigned char)227,      (unsigned char)227, 
        (unsigned char)226,      (unsigned char)226,      (unsigned char)226,      (unsigned char)226, 
        (unsigned char)237,      (unsigned char)237,      (unsigned char)237,      (unsigned char)237, 
        (unsigned char)236,      (unsigned char)236,      (unsigned char)236,      (unsigned char)236, 
        (unsigned char)239,      (unsigned char)239,      (unsigned char)239,      (unsigned char)239, 
        (unsigned char)238,      (unsigned char)238,      (unsigned char)238,      (unsigned char)238, 
        (unsigned char)233,      (unsigned char)233,      (unsigned char)233,      (unsigned char)233, 
        (unsigned char)232,      (unsigned char)232,      (unsigned char)232,      (unsigned char)232, 
        (unsigned char)235,      (unsigned char)235,      (unsigned char)235,      (unsigned char)235, 
        (unsigned char)234,      (unsigned char)234,      (unsigned char)234,      (unsigned char)234, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170};
#line 293 "/root/patchweave_new/23/src/alaw.c"
__inline static void alaw2s_array(unsigned char *buffer , int count___0 , short *ptr ) 
{ 


  {
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    count___0 --;
#line 294
    if (! (count___0 >= 0)) {
#line 294
      goto while_break;
    }
#line 295
    *(ptr + count___0) = alaw_decode[(int )*(buffer + count___0)];
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 299
  return;
}
}
#line 299 "/root/patchweave_new/23/src/alaw.c"
__inline static void alaw2i_array(unsigned char *buffer , int count___0 , int *ptr ) 
{ 


  {
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    count___0 --;
#line 300
    if (! (count___0 >= 0)) {
#line 300
      goto while_break;
    }
#line 301
    *(ptr + count___0) = (int )((uint32_t )alaw_decode[(int )*(buffer + count___0)] << 16);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 305
  return;
}
}
#line 305 "/root/patchweave_new/23/src/alaw.c"
__inline static void alaw2f_array(unsigned char *buffer , int count___0 , float *ptr ,
                                  float normfact ) 
{ 


  {
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    count___0 --;
#line 306
    if (! (count___0 >= 0)) {
#line 306
      goto while_break;
    }
#line 307
    *(ptr + count___0) = normfact * (float )((int )alaw_decode[(int )*(buffer + count___0)]);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 311
  return;
}
}
#line 311 "/root/patchweave_new/23/src/alaw.c"
__inline static void alaw2d_array(unsigned char *buffer , int count___0 , double *ptr ,
                                  double normfact ) 
{ 


  {
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    count___0 --;
#line 312
    if (! (count___0 >= 0)) {
#line 312
      goto while_break;
    }
#line 313
    *(ptr + count___0) = normfact * (double )((int )alaw_decode[(int )*(buffer + count___0)]);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 317
  return;
}
}
#line 317 "/root/patchweave_new/23/src/alaw.c"
__inline static void s2alaw_array(short const   *ptr , int count___0 , unsigned char *buffer ) 
{ 


  {
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    count___0 --;
#line 318
    if (! (count___0 >= 0)) {
#line 318
      goto while_break;
    }
#line 319
    if ((int )*(ptr + count___0) >= 0) {
#line 320
      *(buffer + count___0) = alaw_encode[(int )*(ptr + count___0) / 16];
    } else {
#line 322
      *(buffer + count___0) = (unsigned char )(127 & (int )alaw_encode[(int )*(ptr + count___0) / -16]);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 328
  return;
}
}
#line 327 "/root/patchweave_new/23/src/alaw.c"
__inline static void i2alaw_array(int const   *ptr , int count___0 , unsigned char *buffer ) 
{ 


  {
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    count___0 --;
#line 328
    if (! (count___0 >= 0)) {
#line 328
      goto while_break;
    }
#line 329
    if (*(ptr + count___0) >= 0) {
#line 330
      *(buffer + count___0) = alaw_encode[*(ptr + count___0) >> 20];
    } else {
#line 332
      *(buffer + count___0) = (unsigned char )(127 & (int )alaw_encode[- *(ptr + count___0) >> 20]);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 338
  return;
}
}
#line 337 "/root/patchweave_new/23/src/alaw.c"
__inline static void f2alaw_array(float const   *ptr , int count___0 , unsigned char *buffer ,
                                  float normfact ) 
{ 
  long __cil_tmp6 ;
  long tmp ;

  {
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    count___0 --;
#line 338
    if (! (count___0 >= 0)) {
#line 338
      goto while_break;
    }
#line 339
    if (*(ptr + count___0) >= (float const   )((float )0)) {
      {
#line 340
      tmp = lrintf(normfact * (float )*(ptr + count___0));
#line 340
      *(buffer + count___0) = (unsigned char )tmp;
      }
    } else {
      {
#line 342
      __cil_tmp6 = lrintf(normfact * (float )*(ptr + count___0));
#line 342
      *(buffer + count___0) = (unsigned char )(127 & (int )alaw_encode[- __cil_tmp6]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 349
  return;
}
}
#line 347 "/root/patchweave_new/23/src/alaw.c"
__inline static void d2alaw_array(double const   *ptr , int count___0 , unsigned char *buffer ,
                                  double normfact ) 
{ 
  long __cil_tmp6 ;
  long tmp ;

  {
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    count___0 --;
#line 348
    if (! (count___0 >= 0)) {
#line 348
      goto while_break;
    }
#line 349
    if (*(ptr + count___0) >= (double const   )((double )0)) {
      {
#line 350
      tmp = lrint(normfact * (double )*(ptr + count___0));
#line 350
      *(buffer + count___0) = (unsigned char )tmp;
      }
    } else {
      {
#line 352
      __cil_tmp6 = lrint(normfact * (double )*(ptr + count___0));
#line 352
      *(buffer + count___0) = (unsigned char )(127 & (int )alaw_encode[- __cil_tmp6]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 359
  return;
}
}
#line 360 "/root/patchweave_new/23/src/alaw.c"
static sf_count_t alaw_read_alaw2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 363
  total = (sf_count_t )0;
#line 365
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;

#line 367
    if (! (len > 0L)) {
#line 367
      goto while_break;
    }
#line 368
    if (len < (long )bufferlen) {
#line 369
      bufferlen = (int )len;
    }
    {
#line 370
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 370
    readcount = (int )__cil_tmp8;
#line 371
    alaw2s_array(ubuf.ucbuf, readcount, ptr + total);
#line 372
    total += (long )readcount;
    }
#line 373
    if (readcount < bufferlen) {
#line 374
      goto while_break;
    }
#line 375
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 378
  return (total);
}
}
#line 382 "/root/patchweave_new/23/src/alaw.c"
static sf_count_t alaw_read_alaw2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 385
  total = (sf_count_t )0;
#line 387
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;

#line 389
    if (! (len > 0L)) {
#line 389
      goto while_break;
    }
#line 390
    if (len < (long )bufferlen) {
#line 391
      bufferlen = (int )len;
    }
    {
#line 392
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 392
    readcount = (int )__cil_tmp8;
#line 393
    alaw2i_array(ubuf.ucbuf, readcount, ptr + total);
#line 394
    total += (long )readcount;
    }
#line 395
    if (readcount < bufferlen) {
#line 396
      goto while_break;
    }
#line 397
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 400
  return (total);
}
}
#line 404 "/root/patchweave_new/23/src/alaw.c"
static sf_count_t alaw_read_alaw2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 407
  total = (sf_count_t )0;
#line 410
  if (psf->norm_float == 1) {
#line 410
    tmp = 1. / (double )((float )32768);
  } else {
#line 410
    tmp = 1.;
  }
#line 410
  normfact = (float )tmp;
#line 412
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;

#line 414
    if (! (len > 0L)) {
#line 414
      goto while_break;
    }
#line 415
    if (len < (long )bufferlen) {
#line 416
      bufferlen = (int )len;
    }
    {
#line 417
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 417
    readcount = (int )__cil_tmp10;
#line 418
    alaw2f_array(ubuf.ucbuf, readcount, ptr + total, normfact);
#line 419
    total += (long )readcount;
    }
#line 420
    if (readcount < bufferlen) {
#line 421
      goto while_break;
    }
#line 422
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 425
  return (total);
}
}
#line 429 "/root/patchweave_new/23/src/alaw.c"
static sf_count_t alaw_read_alaw2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 432
  total = (sf_count_t )0;
#line 435
  if (psf->norm_double) {
#line 435
    tmp = 1. / (double )32768;
  } else {
#line 435
    tmp = 1.;
  }
#line 435
  normfact = tmp;
#line 436
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;

#line 438
    if (! (len > 0L)) {
#line 438
      goto while_break;
    }
#line 439
    if (len < (long )bufferlen) {
#line 440
      bufferlen = (int )len;
    }
    {
#line 441
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 441
    readcount = (int )__cil_tmp10;
#line 442
    alaw2d_array(ubuf.ucbuf, readcount, ptr + total, normfact);
#line 443
    total += (long )readcount;
    }
#line 444
    if (readcount < bufferlen) {
#line 445
      goto while_break;
    }
#line 446
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 449
  return (total);
}
}
#line 456 "/root/patchweave_new/23/src/alaw.c"
static sf_count_t alaw_write_s2alaw(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 459
  total = (sf_count_t )0;
#line 461
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;

#line 463
    if (! (len > 0L)) {
#line 463
      goto while_break;
    }
#line 464
    if (len < (long )bufferlen) {
#line 465
      bufferlen = (int )len;
    }
    {
#line 466
    s2alaw_array(ptr + total, bufferlen, ubuf.ucbuf);
#line 467
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 467
    writecount = (int )__cil_tmp8;
#line 468
    total += (long )writecount;
    }
#line 469
    if (writecount < bufferlen) {
#line 470
      goto while_break;
    }
#line 471
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 474
  return (total);
}
}
#line 478 "/root/patchweave_new/23/src/alaw.c"
static sf_count_t alaw_write_i2alaw(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 481
  total = (sf_count_t )0;
#line 483
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;

#line 485
    if (! (len > 0L)) {
#line 485
      goto while_break;
    }
#line 486
    if (len < (long )bufferlen) {
#line 487
      bufferlen = (int )len;
    }
    {
#line 488
    i2alaw_array(ptr + total, bufferlen, ubuf.ucbuf);
#line 489
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 489
    writecount = (int )__cil_tmp8;
#line 490
    total += (long )writecount;
    }
#line 491
    if (writecount < bufferlen) {
#line 492
      goto while_break;
    }
#line 493
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 496
  return (total);
}
}
#line 500 "/root/patchweave_new/23/src/alaw.c"
static sf_count_t alaw_write_f2alaw(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 503
  total = (sf_count_t )0;
#line 506
  if (psf->norm_float == 1) {
#line 506
    tmp = (1. * (double )32767) / 16.;
  } else {
#line 506
    tmp = 1. / (double )16;
  }
#line 506
  normfact = (float )tmp;
#line 508
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;

#line 510
    if (! (len > 0L)) {
#line 510
      goto while_break;
    }
#line 511
    if (len < (long )bufferlen) {
#line 512
      bufferlen = (int )len;
    }
    {
#line 513
    f2alaw_array(ptr + total, bufferlen, ubuf.ucbuf, normfact);
#line 514
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                             psf);
#line 514
    writecount = (int )__cil_tmp10;
#line 515
    total += (long )writecount;
    }
#line 516
    if (writecount < bufferlen) {
#line 517
      goto while_break;
    }
#line 518
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 521
  return (total);
}
}
#line 525 "/root/patchweave_new/23/src/alaw.c"
static sf_count_t alaw_write_d2alaw(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 528
  total = (sf_count_t )0;
#line 531
  if (psf->norm_double) {
#line 531
    tmp = (1. * (double )32767) / 16.;
  } else {
#line 531
    tmp = 1. / 16.;
  }
#line 531
  normfact = tmp;
#line 533
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;

#line 535
    if (! (len > 0L)) {
#line 535
      goto while_break;
    }
#line 536
    if (len < (long )bufferlen) {
#line 537
      bufferlen = (int )len;
    }
    {
#line 538
    d2alaw_array(ptr + total, bufferlen, ubuf.ucbuf, normfact);
#line 539
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                             psf);
#line 539
    writecount = (int )__cil_tmp10;
#line 540
    total += (long )writecount;
    }
#line 541
    if (writecount < bufferlen) {
#line 542
      goto while_break;
    }
#line 543
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 546
  return (total);
}
}
#line 88 "/root/patchweave_new/23/src/ALAC/alac_codec.h"
int32_t alac_decoder_init(ALAC_DECODER *p , void *inMagicCookie , uint32_t inMagicCookieSize ) ;
#line 89
int32_t alac_encoder_init(ALAC_ENCODER *p , uint32_t samplerate , uint32_t channels ,
                          uint32_t format_flags , uint32_t frameSize ) ;
#line 91
int32_t alac_decode(ALAC_DECODER *p , struct BitBuffer *bits , int32_t *sampleBuffer ,
                    uint32_t numSamples , uint32_t *outNumSamples ) ;
#line 94
int32_t alac_encode(ALAC_ENCODER *p , uint32_t numSamples , int32_t *theReadBuffer ,
                    unsigned char *theWriteBuffer , uint32_t *ioNumBytes ) ;
#line 98
void alac_set_fastmode(ALAC_ENCODER *p , int32_t fast ) ;
#line 100
uint32_t alac_get_magic_cookie_size(uint32_t inNumChannels ) ;
#line 101
void alac_get_magic_cookie(ALAC_ENCODER *p , void *outCookie , uint32_t *ioSize ) ;
#line 102
void alac_get_source_format(ALAC_ENCODER *p , AudioFormatDescription *source , AudioFormatDescription *output ) ;
#line 75 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.h"
void BitBufferInit(BitBuffer *bits , uint8_t *buffer , uint32_t byteSize ) ;
#line 76
uint32_t BitBufferRead(BitBuffer *bits , uint8_t numBits ) ;
#line 77
uint8_t BitBufferReadSmall(BitBuffer *bits , uint8_t numBits ) ;
#line 78
uint8_t BitBufferReadOne(BitBuffer *bits ) ;
#line 79
uint32_t BitBufferPeek(BitBuffer *bits , uint8_t numBits ) ;
#line 80
uint32_t BitBufferPeekOne(BitBuffer *bits ) ;
#line 81
uint32_t BitBufferUnpackBERSize(BitBuffer *bits ) ;
#line 82
uint32_t BitBufferGetPosition(BitBuffer *bits ) ;
#line 83
void BitBufferByteAlign(BitBuffer *bits , int32_t addZeros ) ;
#line 84
void BitBufferAdvance(BitBuffer *bits , uint32_t numBits ) ;
#line 85
void BitBufferRewind(BitBuffer *bits , uint32_t numBits ) ;
#line 86
void BitBufferWrite(BitBuffer *bits , uint32_t bitValues , uint32_t numBits ) ;
#line 87
void BitBufferReset(BitBuffer *bits ) ;
#line 73 "/root/patchweave_new/23/src/alac.c"
static int alac_reader_init(SF_PRIVATE *psf , ALAC_DECODER_INFO *info ) ;
#line 74
static int alac_writer_init(SF_PRIVATE *psf ) ;
#line 76
static sf_count_t alac_reader_calc_frames(SF_PRIVATE *psf , ALAC_PRIVATE *plac ) ;
#line 78
static sf_count_t alac_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 79
static sf_count_t alac_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 80
static sf_count_t alac_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 81
static sf_count_t alac_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 83
static sf_count_t alac_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 84
static sf_count_t alac_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 85
static sf_count_t alac_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 86
static sf_count_t alac_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 88
static sf_count_t alac_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 90
static int alac_close(SF_PRIVATE *psf ) ;
#line 91
static int alac_byterate(SF_PRIVATE *psf ) ;
#line 93
static int alac_decode_block(SF_PRIVATE *psf , ALAC_PRIVATE *plac ) ;
#line 94
static int alac_encode_block(ALAC_PRIVATE *plac ) ;
#line 96
static uint32_t alac_kuki_read(SF_PRIVATE *psf , uint32_t kuki_offset , uint8_t *kuki ,
                               size_t kuki_maxlen ) ;
#line 98
static PAKT_INFO *alac_pakt_alloc(uint32_t initial_count ) ;
#line 99
static PAKT_INFO *alac_pakt_read_decode(SF_PRIVATE *psf , uint32_t UNUSED_pakt_offset ) ;
#line 100
static PAKT_INFO *alac_pakt_append(PAKT_INFO *info , uint32_t value___0 ) ;
#line 101
static uint8_t *alac_pakt_encode(SF_PRIVATE *psf , uint32_t *pakt_size_out ) ;
#line 102
static sf_count_t alac_pakt_block_offset(PAKT_INFO *info , uint32_t block ) ;
#line 104
static char const   *alac_error_string(int error ) ;
#line 111 "/root/patchweave_new/23/src/alac.c"
int alac_init(SF_PRIVATE *psf , ALAC_DECODER_INFO *info ) 
{ 
  int error ;

  {
  {
#line 114
  psf->codec_data = calloc(1UL, sizeof(ALAC_PRIVATE ) + ((unsigned long )psf->sf.channels * sizeof(int )) * 8192UL);
  }
#line 114
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 115
    return (17);
  }
#line 117
  psf->codec_close = & alac_close;
#line 120
  if (psf->file.mode == 48) {
#line 120
    goto case_48;
  }
#line 123
  if (psf->file.mode == 16) {
#line 123
    goto case_16;
  }
#line 128
  if (psf->file.mode == 32) {
#line 128
    goto case_32;
  }
#line 133
  goto switch_default;
  case_48: 
#line 121
  return (24);
  case_16: 
  {
#line 124
  error = alac_reader_init(psf, info);
  }
#line 124
  if (error) {
#line 125
    return (error);
  }
#line 126
  goto switch_break;
  case_32: 
  {
#line 129
  error = alac_writer_init(psf);
  }
#line 129
  if (error) {
#line 130
    return (error);
  }
#line 131
  goto switch_break;
  switch_default: 
  {
#line 134
  psf_log_printf(psf, "%s : Bad psf->file.mode.\n", "alac_init");
  }
#line 135
  return (30);
  switch_break: 
#line 138
  psf->byterate = & alac_byterate;
#line 140
  return (0);
}
}
#line 144 "/root/patchweave_new/23/src/alac.c"
void alac_get_desc_chunk_items(int subformat , uint32_t *fmt_flags , uint32_t *frames_per_packet ) 
{ 


  {
#line 146
  if (subformat == 112) {
#line 146
    goto case_112;
  }
#line 149
  if (subformat == 113) {
#line 149
    goto case_113;
  }
#line 152
  if (subformat == 114) {
#line 152
    goto case_114;
  }
#line 155
  if (subformat == 115) {
#line 155
    goto case_115;
  }
#line 158
  goto switch_default;
  case_112: 
#line 147
  *fmt_flags = (uint32_t )1;
#line 148
  goto switch_break;
  case_113: 
#line 150
  *fmt_flags = (uint32_t )2;
#line 151
  goto switch_break;
  case_114: 
#line 153
  *fmt_flags = (uint32_t )3;
#line 154
  goto switch_break;
  case_115: 
#line 156
  *fmt_flags = (uint32_t )4;
#line 157
  goto switch_break;
  switch_default: 
#line 159
  goto switch_break;
  switch_break: 
#line 161
  *frames_per_packet = (uint32_t )4096;
#line 162
  return;
}
}
#line 165 "/root/patchweave_new/23/src/alac.c"
static int alac_close(SF_PRIVATE *psf ) 
{ 
  ALAC_PRIVATE *plac ;
  BUF_UNION ubuf ;
  ALAC_ENCODER *penc ;
  SF_CHUNK_INFO chunk_info ;
  sf_count_t readcount ;
  uint8_t kuki_data[1024] ;
  uint32_t pakt_size ;
  uint32_t saved_partial_block_frames ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp13 ;
  uint8_t *tmp ;

  {
#line 169
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 171
  if (psf->file.mode == 32) {
#line 172
    penc = & plac->__annonCompField4.encoder;
#line 176
    pakt_size = (uint32_t )0;
#line 178
    plac->final_write_block = 1;
#line 179
    saved_partial_block_frames = plac->partial_block_frames;
#line 182
    if (plac->partial_block_frames) {
#line 182
      if (plac->partial_block_frames < plac->frames_per_block) {
        {
#line 183
        alac_encode_block(plac);
        }
      }
    }
    {
#line 185
    plac->partial_block_frames = saved_partial_block_frames;
#line 187
    alac_get_magic_cookie(penc, (void *)(kuki_data), & plac->kuki_size);
#line 189
    memset((void *)(& chunk_info), 0, sizeof(chunk_info));
#line 190
    __cil_tmp10 = snprintf(chunk_info.id, sizeof(chunk_info.id), "kuki");
#line 190
    chunk_info.id_size = (unsigned int )__cil_tmp10;
#line 191
    chunk_info.data = (void *)(kuki_data);
#line 192
    chunk_info.datalen = plac->kuki_size;
#line 193
    psf_save_write_chunk(& psf->wchunks, & chunk_info);
#line 195
    memset((void *)(& chunk_info), 0, sizeof(chunk_info));
#line 196
    __cil_tmp11 = snprintf(chunk_info.id, sizeof(chunk_info.id), "pakt\270U");
#line 196
    chunk_info.id_size = (unsigned int )__cil_tmp11;
#line 197
    tmp = alac_pakt_encode(psf, & pakt_size);
#line 197
    chunk_info.data = (void *)tmp;
#line 198
    chunk_info.datalen = pakt_size;
#line 199
    psf_save_write_chunk(& psf->wchunks, & chunk_info);
#line 201
    free(chunk_info.data);
#line 202
    chunk_info.data = (void *)0;
#line 204
    (*(psf->write_header))(psf, 1);
    }
#line 206
    if ((unsigned long )plac->enctmp != (unsigned long )((void *)0)) {
      {
#line 207
      fseek(plac->enctmp, 0L, 0);
      }
      {
#line 209
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 209
        __cil_tmp13 = fread((void *)(ubuf.ucbuf), 1UL, sizeof(ubuf.ucbuf), plac->enctmp);
#line 209
        readcount = (sf_count_t )__cil_tmp13;
        }
#line 209
        if (! (readcount > 0L)) {
#line 209
          goto while_break;
        }
        {
#line 210
        psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, readcount, psf);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 211
      fclose(plac->enctmp);
#line 212
      remove((char const   *)(plac->enctmpname));
      }
    }
  }
#line 216
  if (plac->pakt_info) {
    {
#line 217
    free((void *)plac->pakt_info);
    }
  }
#line 218
  plac->pakt_info = (PAKT_INFO *)((void *)0);
#line 220
  return (0);
}
}
#line 224 "/root/patchweave_new/23/src/alac.c"
static int alac_byterate(SF_PRIVATE *psf ) 
{ 


  {
#line 226
  if (psf->file.mode == 16) {
#line 227
    return ((int )((psf->datalength * (long )psf->sf.samplerate) / psf->sf.frames));
  }
#line 229
  return (-1);
}
}
#line 237 "/root/patchweave_new/23/src/alac.c"
static int alac_reader_init(SF_PRIVATE *psf , ALAC_DECODER_INFO *info ) 
{ 
  ALAC_PRIVATE *plac ;
  uint32_t kuki_size ;
  int error ;
  union __anonunion_905 u ;
  char const   *__cil_tmp10 ;

  {
#line 243
  if ((unsigned long )info == (unsigned long )((void *)0)) {
    {
#line 244
    psf_log_printf(psf, "%s : ALAC_DECODER_INFO is NULL.\n\240\036TB\270U", "alac_reader_init\312\001@");
    }
#line 245
    return (30);
  }
#line 248
  if (info->frames_per_packet > 4096U) {
    {
#line 249
    psf_log_printf(psf, "*** Error : frames_per_packet (%u) is too big. ***\n", info->frames_per_packet);
    }
#line 250
    return (30);
  }
#line 253
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 255
  plac->channels = psf->sf.channels;
#line 256
  plac->frames_per_block = info->frames_per_packet;
#line 257
  plac->bits_per_sample = info->bits_per_sample;
#line 259
  if ((unsigned long )plac->pakt_info != (unsigned long )((void *)0)) {
    {
#line 260
    free((void *)plac->pakt_info);
    }
  }
  {
#line 261
  plac->pakt_info = alac_pakt_read_decode(psf, info->pakt_offset);
  }
#line 263
  if ((unsigned long )plac->pakt_info == (unsigned long )((void *)0)) {
    {
#line 264
    psf_log_printf(psf, "%s : alac_pkt_read() returns NULL.\n", "alac_reader_init\312\001@");
    }
#line 265
    return (30);
  }
  {
#line 269
  kuki_size = alac_kuki_read(psf, info->kuki_offset, u.kuki, sizeof(u.kuki));
#line 271
  error = alac_decoder_init(& plac->__annonCompField4.decoder, (void *)(u.kuki), kuki_size);
  }
#line 271
  if (error != 0) {
    {
#line 272
    __cil_tmp10 = alac_error_string(error);
#line 272
    psf_log_printf(psf, "*** alac_decoder_init() returned %s. ***\n", __cil_tmp10);
    }
#line 273
    return (30);
  }
#line 277
  if (plac->__annonCompField4.decoder.mNumChannels != (unsigned int )psf->sf.channels) {
    {
#line 278
    psf_log_printf(psf, "*** Initialized decoder has %u channels, but it should be %d. ***\nTB\270U",
                   plac->__annonCompField4.decoder.mNumChannels, psf->sf.channels);
    }
#line 279
    return (30);
  }
#line 286
  if (info->bits_per_sample == 32U) {
#line 286
    goto case_32;
  }
#line 286
  if (info->bits_per_sample == 24U) {
#line 286
    goto case_32;
  }
#line 286
  if (info->bits_per_sample == 20U) {
#line 286
    goto case_32;
  }
#line 286
  if (info->bits_per_sample == 16U) {
#line 286
    goto case_32;
  }
#line 293
  goto switch_default;
  case_32: 
#line 287
  psf->read_short = & alac_read_s;
#line 288
  psf->read_int = & alac_read_i;
#line 289
  psf->read_float = & alac_read_f;
#line 290
  psf->read_double = & alac_read_d;
#line 291
  goto switch_break;
  switch_default: 
  {
#line 294
  printf("%s : info->bits_per_sample %u\n", "alac_reader_init\312\001@", info->bits_per_sample);
  }
#line 295
  return (4);
  switch_break: 
  {
#line 298
  psf->codec_close = & alac_close;
#line 299
  psf->seek = & alac_seek;
#line 301
  psf->sf.frames = alac_reader_calc_frames(psf, plac);
#line 302
  alac_seek(psf, 16, (sf_count_t )0);
  }
#line 304
  return (0);
}
}
#line 308 "/root/patchweave_new/23/src/alac.c"
static int alac_writer_init(SF_PRIVATE *psf ) 
{ 
  ALAC_PRIVATE *plac ;
  uint32_t alac_format_flags ;
  int *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 310
  alac_format_flags = (uint32_t )0;
#line 312
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 314
  if (psf->file.mode != 32) {
#line 315
    return (24);
  }
  {
#line 317
  plac->channels = psf->sf.channels;
#line 318
  plac->kuki_size = alac_get_magic_cookie_size((uint32_t )psf->sf.channels);
#line 320
  psf->write_short = & alac_write_s;
#line 321
  psf->write_int = & alac_write_i;
#line 322
  psf->write_float = & alac_write_f;
#line 323
  psf->write_double = & alac_write_d;
  }
#line 326
  if ((psf->sf.format & 65535) == 112) {
#line 326
    goto case_112;
  }
#line 331
  if ((psf->sf.format & 65535) == 113) {
#line 331
    goto case_113;
  }
#line 336
  if ((psf->sf.format & 65535) == 114) {
#line 336
    goto case_114;
  }
#line 341
  if ((psf->sf.format & 65535) == 115) {
#line 341
    goto case_115;
  }
#line 346
  goto switch_default;
  case_112: 
#line 327
  alac_format_flags = (uint32_t )1;
#line 328
  plac->bits_per_sample = (uint32_t )16;
#line 329
  goto switch_break;
  case_113: 
#line 332
  alac_format_flags = (uint32_t )2;
#line 333
  plac->bits_per_sample = (uint32_t )20;
#line 334
  goto switch_break;
  case_114: 
#line 337
  alac_format_flags = (uint32_t )3;
#line 338
  plac->bits_per_sample = (uint32_t )24;
#line 339
  goto switch_break;
  case_115: 
#line 342
  alac_format_flags = (uint32_t )4;
#line 343
  plac->bits_per_sample = (uint32_t )32;
#line 344
  goto switch_break;
  switch_default: 
  {
#line 347
  psf_log_printf(psf, "%s : Can\'t figure out bits per sample.\n", "alac_writer_init\312\001@");
  }
#line 348
  return (18);
  switch_break: 
  {
#line 351
  plac->frames_per_block = (uint32_t )4096;
#line 353
  plac->pakt_info = alac_pakt_alloc((uint32_t )2000);
#line 355
  plac->enctmp = psf_open_tmpfile(plac->enctmpname, sizeof(plac->enctmpname));
  }
#line 355
  if ((unsigned long )plac->enctmp == (unsigned long )((void *)0)) {
    {
#line 356
    __cil_tmp7 = __errno_location();
#line 356
    __cil_tmp8 = strerror(*__cil_tmp7);
#line 356
    psf_log_printf(psf, "Error : Failed to open temp file \'%s\' : \n", plac->enctmpname,
                   __cil_tmp8);
    }
#line 357
    return (172);
  }
  {
#line 360
  alac_encoder_init(& plac->__annonCompField4.encoder, (uint32_t )psf->sf.samplerate,
                    (uint32_t )psf->sf.channels, alac_format_flags, (uint32_t )4096);
  }
#line 362
  return (0);
}
}
#line 370 "/root/patchweave_new/23/src/alac.c"
__inline static uint32_t alac_reader_next_packet_size(PAKT_INFO *info ) 
{ 
  uint32_t __cil_tmp2 ;

  {
#line 371
  if (info->current >= info->count) {
#line 372
    return ((uint32_t )0);
  }
#line 373
  __cil_tmp2 = info->current;
#line 373
  (info->current) ++;
#line 373
  return (info->packet_size[__cil_tmp2]);
}
}
#line 377 "/root/patchweave_new/23/src/alac.c"
static sf_count_t alac_reader_calc_frames(SF_PRIVATE *psf , ALAC_PRIVATE *plac ) 
{ 
  sf_count_t frames ;
  uint32_t current_pos ;
  uint32_t blocks ;
  uint32_t tmp ;

  {
#line 378
  frames = (sf_count_t )0;
#line 379
  current_pos = (uint32_t )1;
#line 379
  blocks = (uint32_t )0;
#line 381
  (plac->pakt_info)->current = (uint32_t )0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;

#line 383
    if ((long )current_pos < psf->filelength) {
#line 383
      if (! (current_pos > 0U)) {
#line 383
        goto while_break;
      }
    } else {
#line 383
      goto while_break;
    }
    {
#line 384
    current_pos = alac_reader_next_packet_size(plac->pakt_info);
    }
#line 385
    if (current_pos > 0U) {
#line 385
      tmp = blocks + 1U;
    } else {
#line 385
      tmp = blocks;
    }
#line 385
    blocks = tmp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 388
  if (blocks == 0U) {
#line 389
    return ((sf_count_t )0);
  }
  {
#line 392
  frames = (sf_count_t )(plac->frames_per_block * (blocks - 1U));
#line 394
  alac_seek(psf, 16, frames);
#line 395
  alac_decode_block(psf, plac);
#line 396
  frames += (long )plac->frames_this_block;
#line 398
  (plac->pakt_info)->current = (uint32_t )0;
  }
#line 400
  return (frames);
}
}
#line 404 "/root/patchweave_new/23/src/alac.c"
static int alac_decode_block(SF_PRIVATE *psf , ALAC_PRIVATE *plac ) 
{ 
  ALAC_DECODER *pdec ;
  uint32_t packet_size ;
  BitBuffer bit_buffer ;
  sf_count_t __cil_tmp7 ;

  {
  {
#line 405
  pdec = & plac->__annonCompField4.decoder;
#line 409
  packet_size = alac_reader_next_packet_size(plac->pakt_info);
  }
#line 410
  if (packet_size == 0U) {
#line 411
    if ((plac->pakt_info)->current < (plac->pakt_info)->count) {
      {
#line 412
      psf_log_printf(psf, "packet_size is 0 (%d of %d)\n\270U", (plac->pakt_info)->current,
                     (plac->pakt_info)->count);
      }
    }
#line 413
    return (0);
  }
  {
#line 416
  psf_fseek(psf, plac->input_data_pos, 0);
  }
#line 418
  if ((unsigned long )packet_size > sizeof(plac->byte_buffer)) {
    {
#line 419
    psf_log_printf(psf, "%s : bad packet_size (%u)\nTB\270U", "alac_decode_blockQTB\270U",
                   packet_size);
    }
#line 420
    return (0);
  }
  {
#line 423
  __cil_tmp7 = psf_fread((void *)(plac->byte_buffer), (sf_count_t )1, (sf_count_t )packet_size,
                         psf);
  }
#line 423
  if ((long )packet_size != __cil_tmp7) {
#line 424
    return (0);
  }
  {
#line 426
  BitBufferInit(& bit_buffer, plac->byte_buffer, packet_size);
#line 428
  plac->input_data_pos += (long )packet_size;
#line 429
  plac->frames_this_block = (uint32_t )0;
#line 430
  alac_decode(pdec, & bit_buffer, plac->buffer, plac->frames_per_block, & plac->frames_this_block);
#line 432
  plac->partial_block_frames = (uint32_t )0;
  }
#line 434
  return (1);
}
}
#line 439 "/root/patchweave_new/23/src/alac.c"
static int alac_encode_block(ALAC_PRIVATE *plac ) 
{ 
  ALAC_ENCODER *penc ;
  uint32_t num_bytes ;
  unsigned long __cil_tmp4 ;

  {
  {
#line 440
  penc = & plac->__annonCompField4.encoder;
#line 441
  num_bytes = (uint32_t )0;
#line 443
  alac_encode(penc, plac->partial_block_frames, plac->buffer, plac->byte_buffer, & num_bytes);
#line 445
  __cil_tmp4 = fwrite((void const   *)(plac->byte_buffer), 1UL, (unsigned long )num_bytes,
                      plac->enctmp);
  }
#line 445
  if (__cil_tmp4 != (unsigned long )num_bytes) {
#line 446
    return (0);
  }
  {
#line 447
  plac->pakt_info = alac_pakt_append(plac->pakt_info, num_bytes);
  }
#line 447
  if ((unsigned long )plac->pakt_info == (unsigned long )((void *)0)) {
#line 448
    return (0);
  }
#line 450
  plac->partial_block_frames = (uint32_t )0;
#line 452
  return (1);
}
}
#line 460 "/root/patchweave_new/23/src/alac.c"
static sf_count_t alac_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  int *iptr ;
  int k ;
  int readcount ;
  sf_count_t total ;
  int __cil_tmp9 ;
  sf_count_t tmp ;

  {
#line 464
  total = (sf_count_t )0;
#line 466
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 466
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 467
    return ((sf_count_t )0);
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;

#line 469
    if (! (len > 0L)) {
#line 469
      goto while_break;
    }
    {
#line 470
    __cil_tmp9 = alac_decode_block(psf, plac);
    }
#line 470
    if (plac->partial_block_frames >= plac->frames_this_block) {
#line 470
      if (__cil_tmp9 == 0) {
#line 471
        goto while_break;
      }
    }
#line 473
    readcount = (int )((plac->frames_this_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 474
    if ((long )readcount > len) {
#line 474
      tmp = len;
    } else {
#line 474
      tmp = (long )readcount;
    }
#line 474
    readcount = (int )tmp;
#line 476
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 478
    k = 0;
    {
#line 478
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 478
      if (! (k < readcount)) {
#line 478
        goto while_break___0;
      }
#line 479
      *(ptr + (total + (long )k)) = (short )(*(iptr + k) >> 16);
#line 478
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 481
    plac->partial_block_frames += (unsigned int )(readcount / plac->channels);
#line 482
    total += (long )readcount;
#line 483
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 486
  return (total);
}
}
#line 490 "/root/patchweave_new/23/src/alac.c"
static sf_count_t alac_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  int *iptr ;
  int k ;
  int readcount ;
  sf_count_t total ;
  int __cil_tmp9 ;
  sf_count_t tmp ;

  {
#line 494
  total = (sf_count_t )0;
#line 496
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 496
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 497
    return ((sf_count_t )0);
  }
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;

#line 499
    if (! (len > 0L)) {
#line 499
      goto while_break;
    }
    {
#line 500
    __cil_tmp9 = alac_decode_block(psf, plac);
    }
#line 500
    if (plac->partial_block_frames >= plac->frames_this_block) {
#line 500
      if (__cil_tmp9 == 0) {
#line 501
        goto while_break;
      }
    }
#line 503
    readcount = (int )((plac->frames_this_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 504
    if ((long )readcount > len) {
#line 504
      tmp = len;
    } else {
#line 504
      tmp = (long )readcount;
    }
#line 504
    readcount = (int )tmp;
#line 506
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 508
    k = 0;
    {
#line 508
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 508
      if (! (k < readcount)) {
#line 508
        goto while_break___0;
      }
#line 509
      *(ptr + (total + (long )k)) = *(iptr + k);
#line 508
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 511
    plac->partial_block_frames += (unsigned int )(readcount / plac->channels);
#line 512
    total += (long )readcount;
#line 513
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 516
  return (total);
}
}
#line 520 "/root/patchweave_new/23/src/alac.c"
static sf_count_t alac_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  int *iptr ;
  int k ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  int __cil_tmp11 ;
  sf_count_t tmp___0 ;

  {
#line 524
  total = (sf_count_t )0;
#line 527
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 527
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 528
    return ((sf_count_t )0);
  }
#line 530
  if (psf->norm_float == 1) {
#line 530
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 530
    tmp = 1.;
  }
#line 530
  normfact = (float )tmp;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;

#line 532
    if (! (len > 0L)) {
#line 532
      goto while_break;
    }
    {
#line 533
    __cil_tmp11 = alac_decode_block(psf, plac);
    }
#line 533
    if (plac->partial_block_frames >= plac->frames_this_block) {
#line 533
      if (__cil_tmp11 == 0) {
#line 534
        goto while_break;
      }
    }
#line 536
    readcount = (int )((plac->frames_this_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 537
    if ((long )readcount > len) {
#line 537
      tmp___0 = len;
    } else {
#line 537
      tmp___0 = (long )readcount;
    }
#line 537
    readcount = (int )tmp___0;
#line 539
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 541
    k = 0;
    {
#line 541
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 541
      if (! (k < readcount)) {
#line 541
        goto while_break___0;
      }
#line 542
      *(ptr + (total + (long )k)) = normfact * (float )*(iptr + k);
#line 541
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 544
    plac->partial_block_frames += (unsigned int )(readcount / plac->channels);
#line 545
    total += (long )readcount;
#line 546
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 549
  return (total);
}
}
#line 553 "/root/patchweave_new/23/src/alac.c"
static sf_count_t alac_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  int *iptr ;
  int k ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  int __cil_tmp11 ;
  sf_count_t tmp___0 ;

  {
#line 557
  total = (sf_count_t )0;
#line 560
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 560
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 561
    return ((sf_count_t )0);
  }
#line 563
  if (psf->norm_double == 1) {
#line 563
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 563
    tmp = 1.;
  }
#line 563
  normfact = tmp;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;

#line 565
    if (! (len > 0L)) {
#line 565
      goto while_break;
    }
    {
#line 566
    __cil_tmp11 = alac_decode_block(psf, plac);
    }
#line 566
    if (plac->partial_block_frames >= plac->frames_this_block) {
#line 566
      if (__cil_tmp11 == 0) {
#line 567
        goto while_break;
      }
    }
#line 569
    readcount = (int )((plac->frames_this_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 570
    if ((long )readcount > len) {
#line 570
      tmp___0 = len;
    } else {
#line 570
      tmp___0 = (long )readcount;
    }
#line 570
    readcount = (int )tmp___0;
#line 572
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 574
    k = 0;
    {
#line 574
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 574
      if (! (k < readcount)) {
#line 574
        goto while_break___0;
      }
#line 575
      *(ptr + (total + (long )k)) = normfact * (double )*(iptr + k);
#line 574
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 577
    plac->partial_block_frames += (unsigned int )(readcount / plac->channels);
#line 578
    total += (long )readcount;
#line 579
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 582
  return (total);
}
}
#line 589 "/root/patchweave_new/23/src/alac.c"
static sf_count_t alac_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  ALAC_PRIVATE *plac ;
  int newblock ;
  int newsample ;
  sf_count_t __cil_tmp7 ;

  {
#line 593
  if (! psf->codec_data) {
#line 594
    return ((sf_count_t )0);
  }
#line 595
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 597
  if (psf->datalength < 0L) {
#line 598
    psf->error = 40;
#line 599
    return ((sf_count_t )-1);
  } else
#line 597
  if (psf->dataoffset < 0L) {
#line 598
    psf->error = 40;
#line 599
    return ((sf_count_t )-1);
  }
#line 602
  if (offset == 0L) {
    {
#line 603
    psf_fseek(psf, psf->dataoffset, 0);
#line 605
    plac->frames_this_block = (uint32_t )0;
#line 606
    plac->input_data_pos = psf->dataoffset;
#line 607
    (plac->pakt_info)->current = (uint32_t )0;
    }
#line 608
    return ((sf_count_t )0);
  }
#line 611
  if (offset < 0L) {
#line 612
    psf->error = 40;
#line 613
    return ((sf_count_t )-1);
  } else
#line 611
  if (offset > (long )((plac->pakt_info)->count * plac->frames_per_block)) {
#line 612
    psf->error = 40;
#line 613
    return ((sf_count_t )-1);
  }
#line 616
  newblock = (int )(offset / (long )plac->frames_per_block);
#line 617
  newsample = (int )(offset % (long )plac->frames_per_block);
#line 619
  if (mode == 16) {
    {
#line 620
    __cil_tmp7 = alac_pakt_block_offset(plac->pakt_info, (uint32_t )newblock);
#line 620
    plac->input_data_pos = psf->dataoffset + __cil_tmp7;
#line 622
    (plac->pakt_info)->current = (uint32_t )newblock;
#line 623
    alac_decode_block(psf, plac);
#line 624
    plac->partial_block_frames = (uint32_t )newsample;
    }
  } else {
#line 628
    psf->error = 40;
#line 629
    return ((sf_count_t )-1);
  }
#line 632
  return ((sf_count_t )((unsigned int )newblock * plac->frames_per_block + (unsigned int )newsample));
}
}
#line 640 "/root/patchweave_new/23/src/alac.c"
static sf_count_t alac_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  int *iptr ;
  int k ;
  int writecount ;
  sf_count_t total ;
  sf_count_t tmp ;

  {
#line 644
  total = (sf_count_t )0;
#line 646
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 646
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 647
    return ((sf_count_t )0);
  }
  {
#line 649
  while (1) {
    while_continue: /* CIL Label */ ;

#line 649
    if (! (len > 0L)) {
#line 649
      goto while_break;
    }
#line 650
    writecount = (int )((plac->frames_per_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 651
    if (writecount == 0) {
#line 651
      tmp = len;
    } else
#line 651
    if ((long )writecount > len) {
#line 651
      tmp = len;
    } else {
#line 651
      tmp = (long )writecount;
    }
#line 651
    writecount = (int )tmp;
#line 653
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 655
    k = 0;
    {
#line 655
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 655
      if (! (k < writecount)) {
#line 655
        goto while_break___0;
      }
      {
#line 656
      *(iptr + k) = arith_shift_left((int32_t )*(ptr + k), 16);
#line 655
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 658
    plac->partial_block_frames += (unsigned int )(writecount / plac->channels);
#line 659
    total += (long )writecount;
#line 660
    len -= (long )writecount;
#line 661
    ptr += writecount;
#line 663
    if (plac->partial_block_frames >= plac->frames_per_block) {
      {
#line 664
      alac_encode_block(plac);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 667
  return (total);
}
}
#line 671 "/root/patchweave_new/23/src/alac.c"
static sf_count_t alac_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  int *iptr ;
  int k ;
  int writecount ;
  sf_count_t total ;
  sf_count_t tmp ;

  {
#line 675
  total = (sf_count_t )0;
#line 677
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 677
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 678
    return ((sf_count_t )0);
  }
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;

#line 680
    if (! (len > 0L)) {
#line 680
      goto while_break;
    }
#line 681
    writecount = (int )((plac->frames_per_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 682
    if (writecount == 0) {
#line 682
      tmp = len;
    } else
#line 682
    if ((long )writecount > len) {
#line 682
      tmp = len;
    } else {
#line 682
      tmp = (long )writecount;
    }
#line 682
    writecount = (int )tmp;
#line 684
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 686
    k = 0;
    {
#line 686
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 686
      if (! (k < writecount)) {
#line 686
        goto while_break___0;
      }
#line 687
      *(iptr + k) = (int )*(ptr + k);
#line 686
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 689
    plac->partial_block_frames += (unsigned int )(writecount / plac->channels);
#line 690
    total += (long )writecount;
#line 691
    len -= (long )writecount;
#line 692
    ptr += writecount;
#line 694
    if (plac->partial_block_frames >= plac->frames_per_block) {
      {
#line 695
      alac_encode_block(plac);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 698
  return (total);
}
}
#line 702 "/root/patchweave_new/23/src/alac.c"
static sf_count_t alac_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  void (*convert)(float const   * , int * , int  , int  ) ;
  int *iptr ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , int *dest , int count , int normalize ) ;
  sf_count_t tmp___0 ;

  {
#line 707
  total = (sf_count_t )0;
#line 709
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 709
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 710
    return ((sf_count_t )0);
  }
#line 712
  if (psf->add_clipping) {
#line 712
    tmp = & psf_f2i_clip_array;
  } else {
#line 712
    tmp = & psf_f2i_array;
  }
#line 712
  convert = tmp;
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;

#line 714
    if (! (len > 0L)) {
#line 714
      goto while_break;
    }
#line 715
    writecount = (int )((plac->frames_per_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 716
    if (writecount == 0) {
#line 716
      tmp___0 = len;
    } else
#line 716
    if ((long )writecount > len) {
#line 716
      tmp___0 = len;
    } else {
#line 716
      tmp___0 = (long )writecount;
    }
    {
#line 716
    writecount = (int )tmp___0;
#line 718
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 720
    (*convert)(ptr, iptr, writecount, psf->norm_float);
#line 722
    plac->partial_block_frames += (unsigned int )(writecount / plac->channels);
#line 723
    total += (long )writecount;
#line 724
    len -= (long )writecount;
#line 725
    ptr += writecount;
    }
#line 727
    if (plac->partial_block_frames >= plac->frames_per_block) {
      {
#line 728
      alac_encode_block(plac);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 731
  return (total);
}
}
#line 735 "/root/patchweave_new/23/src/alac.c"
static sf_count_t alac_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  void (*convert)(double const   * , int * , int  , int  ) ;
  int *iptr ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , int *dest , int count , int normalize ) ;
  sf_count_t tmp___0 ;

  {
#line 740
  total = (sf_count_t )0;
#line 742
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 742
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 743
    return ((sf_count_t )0);
  }
#line 745
  if (psf->add_clipping) {
#line 745
    tmp = & psf_d2i_clip_array;
  } else {
#line 745
    tmp = & psf_d2i_array;
  }
#line 745
  convert = tmp;
  {
#line 747
  while (1) {
    while_continue: /* CIL Label */ ;

#line 747
    if (! (len > 0L)) {
#line 747
      goto while_break;
    }
#line 748
    writecount = (int )((plac->frames_per_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 749
    if (writecount == 0) {
#line 749
      tmp___0 = len;
    } else
#line 749
    if ((long )writecount > len) {
#line 749
      tmp___0 = len;
    } else {
#line 749
      tmp___0 = (long )writecount;
    }
    {
#line 749
    writecount = (int )tmp___0;
#line 751
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 753
    (*convert)(ptr, iptr, writecount, psf->norm_float);
#line 755
    plac->partial_block_frames += (unsigned int )(writecount / plac->channels);
#line 756
    total += (long )writecount;
#line 757
    len -= (long )writecount;
#line 758
    ptr += writecount;
    }
#line 760
    if (plac->partial_block_frames >= plac->frames_per_block) {
      {
#line 761
      alac_encode_block(plac);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 764
  return (total);
}
}
#line 772 "/root/patchweave_new/23/src/alac.c"
static PAKT_INFO *alac_pakt_alloc(uint32_t initial_count ) 
{ 
  PAKT_INFO *info ;
  void *tmp ;

  {
  {
#line 775
  tmp = calloc(1UL, sizeof(PAKT_INFO ) + (unsigned long )initial_count * sizeof(info->packet_size[0]));
#line 775
  info = (PAKT_INFO *)tmp;
  }
#line 775
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 776
    return ((PAKT_INFO *)((void *)0));
  }
#line 778
  info->allocated = initial_count;
#line 779
  info->current = (uint32_t )0;
#line 780
  info->count = (uint32_t )0;
#line 782
  return (info);
}
}
#line 786 "/root/patchweave_new/23/src/alac.c"
static PAKT_INFO *alac_pakt_append(PAKT_INFO *info , uint32_t value___0 ) 
{ 
  PAKT_INFO *temp ;
  uint32_t newcount ;
  uint32_t __cil_tmp6 ;
  void *tmp ;

  {
#line 788
  if (info->count >= info->allocated) {
    {
#line 790
    newcount = info->allocated + info->allocated / 2U;
#line 792
    tmp = realloc((void *)info, sizeof(PAKT_INFO ) + (unsigned long )newcount * sizeof(info->packet_size[0]));
#line 792
    temp = (PAKT_INFO *)tmp;
    }
#line 792
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 793
      return ((PAKT_INFO *)((void *)0));
    }
#line 795
    info = temp;
#line 796
    info->allocated = newcount;
  }
#line 799
  __cil_tmp6 = info->count;
#line 799
  (info->count) ++;
#line 799
  info->packet_size[__cil_tmp6] = value___0;
#line 800
  return (info);
}
}
#line 804 "/root/patchweave_new/23/src/alac.c"
static PAKT_INFO *alac_pakt_read_decode(SF_PRIVATE *psf , uint32_t UNUSED_pakt_offset ) 
{ 
  SF_CHUNK_INFO chunk_info ;
  PAKT_INFO *info ;
  uint8_t *pakt_data ;
  uint32_t bcount ;
  uint32_t value___0 ;
  uint32_t pakt_size ;
  SF_CHUNK_ITERATOR *chunk_iterator ;
  int __cil_tmp12 ;
  uint8_t byte ;
  int32_t count___0 ;

  {
  {
#line 806
  info = (PAKT_INFO *)((void *)0);
#line 807
  pakt_data = (uint8_t *)((void *)0);
#line 808
  value___0 = (uint32_t )1;
#line 812
  memset((void *)(& chunk_info), 0, sizeof(chunk_info));
#line 813
  snprintf(chunk_info.id, sizeof(chunk_info.id), "pakt");
#line 814
  chunk_info.id_size = 4U;
#line 816
  chunk_iterator = psf_get_chunk_iterator(psf, (char const   *)(chunk_info.id));
  }
#line 816
  if ((unsigned long )chunk_iterator == (unsigned long )((void *)0)) {
    {
#line 817
    psf_log_printf(psf, "%s : no chunk iterator found\n", "alac_pakt_read_decode");
#line 818
    free(chunk_info.data);
#line 819
    chunk_info.data = (void *)0;
    }
#line 820
    return ((PAKT_INFO *)((void *)0));
  }
  {
#line 823
  (*(psf->get_chunk_size))(psf, chunk_iterator, & chunk_info);
#line 825
  pakt_size = chunk_info.datalen;
#line 826
  chunk_info.data = malloc((unsigned long )(pakt_size + 5U));
#line 828
  __cil_tmp12 = (*(psf->get_chunk_data))(psf, chunk_iterator, & chunk_info);
#line 828
  bcount = (uint32_t )__cil_tmp12;
  }
#line 828
  if (bcount != 0U) {
    {
#line 829
    while (1) {
      while_continue: /* CIL Label */ ;

#line 829
      if (! chunk_iterator) {
#line 829
        goto while_break;
      }
      {
#line 830
      chunk_iterator = (*(psf->next_chunk_iterator))(psf, chunk_iterator);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: 
    {
#line 831
    free(chunk_info.data);
#line 832
    chunk_info.data = (void *)0;
    }
#line 833
    return ((PAKT_INFO *)((void *)0));
  }
  {
#line 836
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 836
    if (! chunk_iterator) {
#line 836
      goto while_break___0;
    }
    {
#line 837
    chunk_iterator = (*(psf->next_chunk_iterator))(psf, chunk_iterator);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 839
  info = alac_pakt_alloc(pakt_size / 4U);
#line 842
  bcount = (uint32_t )24;
  }
  {
#line 842
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 842
    if (bcount < pakt_size) {
#line 842
      if (! (value___0 != 0U)) {
#line 842
        goto while_break___1;
      }
    } else {
#line 842
      goto while_break___1;
    }
#line 844
    count___0 = 0;
#line 846
    value___0 = (uint32_t )0;
    {
#line 847
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 848
      byte = *(pakt_data + (bcount + (unsigned int )count___0));
#line 849
      value___0 = (value___0 << 7) + (unsigned int )((int )byte & 127);
#line 851
      count___0 ++;
#line 852
      if (count___0 > 5) {
        {
#line 853
        printf("%s %d : Ooops! count %d    bcount %d\n", "alac_pakt_read_decode",
               853, count___0, bcount);
#line 854
        value___0 = (uint32_t )0;
        }
#line 855
        goto while_break___2;
      } else
#line 852
      if (bcount + (unsigned int )count___0 > pakt_size) {
        {
#line 853
        printf("%s %d : Ooops! count %d    bcount %d\n", "alac_pakt_read_decode",
               853, count___0, bcount);
#line 854
        value___0 = (uint32_t )0;
        }
#line 855
        goto while_break___2;
      }
#line 847
      if (! ((int )byte & 128)) {
#line 847
        goto while_break___2;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 860
    bcount += (unsigned int )count___0;
#line 862
    info = alac_pakt_append(info, value___0);
    }
#line 862
    if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 863
      goto FreeExit;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 866
  free((void *)pakt_data);
  }
#line 868
  return (info);
  FreeExit: 
  {
#line 871
  free((void *)pakt_data);
#line 872
  free((void *)info);
  }
#line 873
  return ((PAKT_INFO *)((void *)0));
}
}
#line 877 "/root/patchweave_new/23/src/alac.c"
static uint8_t *alac_pakt_encode(SF_PRIVATE *psf , uint32_t *pakt_size_out ) 
{ 
  ALAC_PRIVATE *plac ;
  PAKT_INFO *info ;
  uint8_t *data ;
  uint32_t k ;
  uint32_t allocated ;
  uint32_t pakt_size ;
  int32_t value___0 ;
  uint32_t __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  void *tmp ;

  {
  {
#line 883
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 884
  info = plac->pakt_info;
#line 886
  allocated = 100U + 2U * info->count;
#line 887
  tmp = calloc(1UL, (unsigned long )allocated);
#line 887
  data = (uint8_t *)tmp;
  }
#line 887
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 888
    return ((uint8_t *)((void *)0));
  }
  {
#line 890
  psf_put_be64(data, 0, (int64_t )info->count);
#line 891
  psf_put_be64(data, 8, psf->sf.frames);
#line 892
  psf_put_be32(data, 20, (int32_t )(4096U - plac->partial_block_frames));
#line 895
  pakt_size = (uint32_t )24;
#line 897
  k = (uint32_t )0;
  }
  {
#line 897
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 897
    if (! (k < info->count)) {
#line 897
      goto while_break;
    }
#line 898
    value___0 = (int32_t )info->packet_size[k];
#line 900
    if ((value___0 & 127) == value___0) {
#line 901
      __cil_tmp11 = pakt_size;
#line 901
      pakt_size ++;
#line 901
      *(data + __cil_tmp11) = (uint8_t )value___0;
#line 902
      goto while_continue;
    }
#line 905
    if ((value___0 & 16383) == value___0) {
#line 906
      __cil_tmp12 = pakt_size;
#line 906
      pakt_size ++;
#line 906
      *(data + __cil_tmp12) = (uint8_t )((value___0 >> 7) | 128);
#line 907
      __cil_tmp13 = pakt_size;
#line 907
      pakt_size ++;
#line 907
      *(data + __cil_tmp13) = (uint8_t )(value___0 & 127);
#line 908
      goto while_continue;
    }
#line 911
    if ((value___0 & 2097151) == value___0) {
#line 912
      __cil_tmp14 = pakt_size;
#line 912
      pakt_size ++;
#line 912
      *(data + __cil_tmp14) = (uint8_t )((value___0 >> 14) | 128);
#line 913
      __cil_tmp15 = pakt_size;
#line 913
      pakt_size ++;
#line 913
      *(data + __cil_tmp15) = (uint8_t )(((value___0 >> 7) & 127) | 128);
#line 914
      __cil_tmp16 = pakt_size;
#line 914
      pakt_size ++;
#line 914
      *(data + __cil_tmp16) = (uint8_t )(value___0 & 127);
#line 915
      goto while_continue;
    }
#line 918
    if ((value___0 & 268435455) == value___0) {
#line 919
      __cil_tmp17 = pakt_size;
#line 919
      pakt_size ++;
#line 919
      *(data + __cil_tmp17) = (uint8_t )((value___0 >> 21) | 128);
#line 920
      __cil_tmp18 = pakt_size;
#line 920
      pakt_size ++;
#line 920
      *(data + __cil_tmp18) = (uint8_t )(((value___0 >> 14) & 127) | 128);
#line 921
      __cil_tmp19 = pakt_size;
#line 921
      pakt_size ++;
#line 921
      *(data + __cil_tmp19) = (uint8_t )(((value___0 >> 7) & 127) | 128);
#line 922
      __cil_tmp20 = pakt_size;
#line 922
      pakt_size ++;
#line 922
      *(data + __cil_tmp20) = (uint8_t )(value___0 & 127);
#line 923
      goto while_continue;
    }
    {
#line 926
    *pakt_size_out = (uint32_t )0;
#line 927
    free((void *)data);
    }
#line 928
    return ((uint8_t *)((void *)0));
#line 897
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 931
  *pakt_size_out = pakt_size;
#line 932
  return (data);
}
}
#line 936 "/root/patchweave_new/23/src/alac.c"
static sf_count_t alac_pakt_block_offset(PAKT_INFO *info , uint32_t block ) 
{ 
  sf_count_t offset ;
  uint32_t k ;

  {
#line 937
  offset = (sf_count_t )0;
#line 940
  k = (uint32_t )0;
  {
#line 940
  while (1) {
    while_continue: /* CIL Label */ ;

#line 940
    if (! (k < block)) {
#line 940
      goto while_break;
    }
#line 941
    offset += (long )info->packet_size[k];
#line 940
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 943
  return (offset);
}
}
#line 947 "/root/patchweave_new/23/src/alac.c"
static uint32_t alac_kuki_read(SF_PRIVATE *psf , uint32_t kuki_offset , uint8_t *kuki ,
                               size_t kuki_maxlen ) 
{ 
  uint32_t marker ;
  uint64_t kuki_size ;
  sf_count_t __cil_tmp7 ;
  int64_t __cil_tmp8 ;

  {
  {
#line 951
  __cil_tmp7 = psf_fseek(psf, (sf_count_t )kuki_offset, 0);
  }
#line 951
  if (__cil_tmp7 != (long )kuki_offset) {
#line 952
    return ((uint32_t )0);
  }
  {
#line 954
  psf_fread((void *)(& marker), (sf_count_t )1, (sf_count_t )sizeof(marker), psf);
  }
#line 955
  if (marker != ((unsigned int )((107 | (117 << 8)) | (107 << 16)) | (105U << 24))) {
#line 956
    return ((uint32_t )0);
  }
  {
#line 958
  psf_fread((void *)(& kuki_size), (sf_count_t )1, (sf_count_t )sizeof(kuki_size),
            psf);
#line 959
  __cil_tmp8 = ENDSWAP_64X((int64_t )kuki_size);
#line 959
  kuki_size = (uint64_t )__cil_tmp8;
  }
#line 961
  if (kuki_size == 0UL) {
    {
#line 962
    psf_log_printf(psf, "%s : Bad size (%D) of \'kuki\' chunk.\n\270U", "alac_kuki_read",
                   kuki_size);
    }
#line 963
    return ((uint32_t )0);
  } else
#line 961
  if (kuki_size > kuki_maxlen) {
    {
#line 962
    psf_log_printf(psf, "%s : Bad size (%D) of \'kuki\' chunk.\n\270U", "alac_kuki_read",
                   kuki_size);
    }
#line 963
    return ((uint32_t )0);
  }
  {
#line 966
  psf_fread((void *)kuki, (sf_count_t )1, (sf_count_t )kuki_size, psf);
  }
#line 968
  return ((uint32_t )kuki_size);
}
}
#line 976 "/root/patchweave_new/23/src/alac.c"
static char errstr[128]  ;
#line 974 "/root/patchweave_new/23/src/alac.c"
static char const   *alac_error_string(int error ) 
{ 


  {
#line 977
  if (error == -4) {
#line 977
    goto case_neg_4;
  }
#line 978
  if (error == -43) {
#line 978
    goto case_neg_43;
  }
#line 979
  if (error == -50) {
#line 979
    goto case_neg_50;
  }
#line 980
  if (error == -108) {
#line 980
    goto case_neg_108;
  }
#line 981
  if (error == -666) {
#line 981
    goto case_neg_666;
  }
#line 984
  if (error == -1048576) {
#line 984
    goto case_neg_1048576;
  }
#line 985
  if (error == -1048577) {
#line 985
    goto case_neg_1048577;
  }
#line 986
  if (error == -1048578) {
#line 986
    goto case_neg_1048578;
  }
#line 987
  if (error == -1048579) {
#line 987
    goto case_neg_1048579;
  }
#line 988
  if (error == -1048580) {
#line 988
    goto case_neg_1048580;
  }
#line 989
  if (error == -1048581) {
#line 989
    goto case_neg_1048581;
  }
#line 990
  goto switch_default;
  case_neg_4: 
#line 977
  return ("kALAC_UnimplementedError\220");
#line 977
  goto switch_break;
  case_neg_43: 
#line 978
  return ("kALAC_FileNotFoundError");
#line 978
  goto switch_break;
  case_neg_50: 
#line 979
  return ("kALAC_ParamError\220");
#line 979
  goto switch_break;
  case_neg_108: 
#line 980
  return ("kALAC_MemFullError");
#line 980
  goto switch_break;
  case_neg_666: 
#line 981
  return ("fALAC_FrameLengthError");
#line 981
  goto switch_break;
  case_neg_1048576: 
#line 984
  return ("kALAC_BadBitWidth\020");
#line 984
  goto switch_break;
  case_neg_1048577: 
#line 985
  return ("kALAC_IncompatibleVersion");
#line 985
  goto switch_break;
  case_neg_1048578: 
#line 986
  return ("kALAC_BadSpecificConfigSizeB\270U");
#line 986
  goto switch_break;
  case_neg_1048579: 
#line 987
  return ("kALAC_ZeroChannelCount");
#line 987
  goto switch_break;
  case_neg_1048580: 
#line 988
  return ("kALAC_NumSamplesTooBig");
#line 988
  goto switch_break;
  case_neg_1048581: 
#line 989
  return ("kALAC_UnsupportedElement\220");
#line 989
  goto switch_break;
  switch_default: 
#line 991
  goto switch_break;
  switch_break: 
  {
#line 994
  snprintf(errstr, sizeof(errstr), "Unknown error %d\230\001", error);
  }
#line 995
  return ((char const   *)(errstr));
}
}
#line 42 "/root/patchweave_new/23/src/ALAC/matrixlib.h"
void mix16(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres ) ;
#line 43
void unmix16(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres ) ;
#line 46
void mix20(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres ) ;
#line 47
void unmix20(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres ) ;
#line 52
void mix24(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) ;
#line 54
void unmix24(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) ;
#line 61
void mix32(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) ;
#line 63
void unmix32(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) ;
#line 70
void copyPredictorTo24(int32_t *in , int32_t *out , uint32_t stride , int32_t numSamples ) ;
#line 71
void copyPredictorTo24Shift(int32_t *in , uint16_t *shift , int32_t *out , uint32_t stride ,
                            int32_t numSamples , int32_t bytesShifted ) ;
#line 72
void copyPredictorTo20(int32_t *in , int32_t *out , uint32_t stride , int32_t numSamples ) ;
#line 74
void copyPredictorTo32(int32_t *in , int32_t *out , uint32_t stride , int32_t numSamples ) ;
#line 75
void copyPredictorTo32Shift(int32_t *in , uint16_t *shift , int32_t *out , uint32_t stride ,
                            int32_t numSamples , int32_t bytesShifted ) ;
#line 51 "/root/patchweave_new/23/src/ALAC/matrix_enc.c"
void mix16(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres ) 
{ 
  int32_t j ;
  int32_t mod ;
  int32_t m2 ;
  int32_t l ;
  int32_t r ;

  {
#line 55
  if (mixres != 0) {
#line 57
    mod = 1 << mixbits;
#line 61
    m2 = mod - mixres;
#line 62
    j = 0;
    {
#line 62
    while (1) {
      while_continue: /* CIL Label */ ;

#line 62
      if (! (j < numSamples)) {
#line 62
        goto while_break;
      }
#line 66
      l = *(in + 0) >> 16;
#line 67
      r = *(in + 1) >> 16;
#line 68
      in += stride;
#line 69
      *(u + j) = (mixres * l + m2 * r) >> mixbits;
#line 70
      *(v + j) = l - r;
#line 62
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 76
    j = 0;
    {
#line 76
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 76
      if (! (j < numSamples)) {
#line 76
        goto while_break___0;
      }
#line 78
      *(u + j) = *(in + 0) >> 16;
#line 79
      *(v + j) = *(in + 1) >> 16;
#line 80
      in += stride;
#line 76
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 81
  return;
}
}
#line 89 "/root/patchweave_new/23/src/ALAC/matrix_enc.c"
void mix20(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres ) 
{ 
  int32_t l ;
  int32_t r ;
  int32_t j ;
  int32_t mod ;
  int32_t m2 ;

  {
#line 94
  if (mixres != 0) {
#line 97
    mod = 1 << mixbits;
#line 98
    m2 = mod - mixres;
#line 100
    j = 0;
    {
#line 100
    while (1) {
      while_continue: /* CIL Label */ ;

#line 100
      if (! (j < numSamples)) {
#line 100
        goto while_break;
      }
#line 102
      l = *(in + 0) >> 12;
#line 103
      r = *(in + 1) >> 12;
#line 104
      in += stride;
#line 106
      *(u + j) = (mixres * l + m2 * r) >> mixbits;
#line 107
      *(v + j) = l - r;
#line 100
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 113
    j = 0;
    {
#line 113
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 113
      if (! (j < numSamples)) {
#line 113
        goto while_break___0;
      }
#line 115
      *(u + j) = *(in + 0) >> 12;
#line 116
      *(v + j) = *(in + 1) >> 12;
#line 117
      in += stride;
#line 113
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 118
  return;
}
}
#line 126 "/root/patchweave_new/23/src/ALAC/matrix_enc.c"
void mix24(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) 
{ 
  int32_t l ;
  int32_t r ;
  int32_t shift ;
  uint32_t mask ;
  int32_t j ;
  int32_t k ;
  int32_t mod ;
  int32_t m2 ;
  int32_t __cil_tmp18 ;
  int32_t __cil_tmp20 ;

  {
#line 130
  shift = bytesShifted * 8;
#line 131
  mask = (uint32_t )((1UL << shift) - 1UL);
#line 134
  if (mixres != 0) {
#line 137
    mod = 1 << mixbits;
#line 138
    m2 = mod - mixres;
#line 140
    if (bytesShifted != 0) {
#line 142
      k = 0;
#line 142
      j = 0;
      {
#line 142
      while (1) {
        while_continue: /* CIL Label */ ;

#line 142
        if (! (j < numSamples)) {
#line 142
          goto while_break;
        }
#line 144
        l = *(in + 0) >> 8;
#line 145
        r = *(in + 1) >> 8;
#line 146
        in += stride;
#line 148
        *(shiftUV + k) = (uint16_t )((unsigned int )l & mask);
#line 149
        *(shiftUV + (k + 1)) = (uint16_t )((unsigned int )r & mask);
#line 151
        l >>= shift;
#line 152
        r >>= shift;
#line 154
        *(u + j) = (mixres * l + m2 * r) >> mixbits;
#line 155
        *(v + j) = l - r;
#line 142
        k += 2;
#line 142
        __cil_tmp18 = j;
#line 142
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break: ;
    } else {
#line 160
      j = 0;
      {
#line 160
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 160
        if (! (j < numSamples)) {
#line 160
          goto while_break___0;
        }
#line 162
        l = *(in + 0) >> 8;
#line 163
        r = *(in + 1) >> 8;
#line 164
        in += stride;
#line 166
        *(u + j) = (mixres * l + m2 * r) >> mixbits;
#line 167
        *(v + j) = l - r;
#line 160
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: ;
    }
  } else
#line 174
  if (bytesShifted != 0) {
#line 176
    k = 0;
#line 176
    j = 0;
    {
#line 176
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 176
      if (! (j < numSamples)) {
#line 176
        goto while_break___1;
      }
#line 178
      l = *(in + 0) >> 8;
#line 179
      r = *(in + 1) >> 8;
#line 180
      in += stride;
#line 182
      *(shiftUV + k) = (uint16_t )((unsigned int )l & mask);
#line 183
      *(shiftUV + (k + 1)) = (uint16_t )((unsigned int )r & mask);
#line 185
      l >>= shift;
#line 186
      r >>= shift;
#line 188
      *(u + j) = l;
#line 189
      *(v + j) = r;
#line 176
      k += 2;
#line 176
      __cil_tmp20 = j;
#line 176
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  } else {
#line 194
    j = 0;
    {
#line 194
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 194
      if (! (j < numSamples)) {
#line 194
        goto while_break___2;
      }
#line 196
      l = *(in + 0) >> 8;
#line 197
      r = *(in + 1) >> 8;
#line 198
      in += stride;
#line 194
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 199
  return;
}
}
#line 210 "/root/patchweave_new/23/src/ALAC/matrix_enc.c"
void mix32(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) 
{ 
  int32_t shift ;
  uint32_t mask ;
  int32_t l ;
  int32_t r ;
  int32_t j ;
  int32_t k ;
  int32_t mod ;
  int32_t m2 ;
  int32_t __cil_tmp18 ;
  int32_t __cil_tmp20 ;

  {
#line 213
  shift = bytesShifted * 8;
#line 214
  mask = (uint32_t )((1UL << shift) - 1UL);
#line 218
  if (mixres != 0) {
#line 220
    mod = 1 << mixbits;
#line 226
    m2 = mod - mixres;
#line 227
    k = 0;
#line 227
    j = 0;
    {
#line 227
    while (1) {
      while_continue: /* CIL Label */ ;

#line 227
      if (! (j < numSamples)) {
#line 227
        goto while_break;
      }
#line 229
      l = *(in + 0);
#line 230
      r = *(in + 1);
#line 231
      in += stride;
#line 233
      *(shiftUV + k) = (uint16_t )((unsigned int )l & mask);
#line 234
      *(shiftUV + (k + 1)) = (uint16_t )((unsigned int )r & mask);
#line 236
      l >>= shift;
#line 237
      r >>= shift;
#line 239
      *(u + j) = (mixres * l + m2 * r) >> mixbits;
#line 240
      *(v + j) = l - r;
#line 227
      k += 2;
#line 227
      __cil_tmp18 = j;
#line 227
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  } else
#line 245
  if (bytesShifted == 0) {
#line 248
    j = 0;
    {
#line 248
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 248
      if (! (j < numSamples)) {
#line 248
        goto while_break___0;
      }
#line 250
      *(u + j) = *(in + 0);
#line 251
      *(v + j) = *(in + 1);
#line 252
      in += stride;
#line 248
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  } else {
#line 258
    k = 0;
#line 258
    j = 0;
    {
#line 258
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 258
      if (! (j < numSamples)) {
#line 258
        goto while_break___1;
      }
#line 260
      l = *(in + 0);
#line 261
      r = *(in + 1);
#line 262
      in += stride;
#line 264
      *(shiftUV + k) = (uint16_t )((unsigned int )l & mask);
#line 265
      *(shiftUV + (k + 1)) = (uint16_t )((unsigned int )r & mask);
#line 267
      l >>= shift;
#line 268
      r >>= shift;
#line 270
      *(u + j) = l;
#line 271
      *(v + j) = r;
#line 258
      k += 2;
#line 258
      __cil_tmp20 = j;
#line 258
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 263
  return;
}
}
#line 63 "/root/patchweave_new/23/src/ALAC/matrix_dec.c"
void unmix16(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres ) 
{ 
  int32_t j ;
  int32_t l ;
  int32_t r ;

  {
#line 67
  if (mixres != 0) {
#line 70
    j = 0;
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;

#line 70
      if (! (j < numSamples)) {
#line 70
        goto while_break;
      }
      {
#line 74
      l = (*(u + j) + *(v + j)) - (mixres * *(v + j) >> mixbits);
#line 75
      r = l - *(v + j);
#line 77
      *(out + 0) = arith_shift_left(l, 16);
#line 78
      *(out + 1) = arith_shift_left(r, 16);
#line 79
      out += stride;
#line 70
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 85
    j = 0;
    {
#line 85
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 85
      if (! (j < numSamples)) {
#line 85
        goto while_break___0;
      }
#line 87
      *(out + 0) = *(u + j) << 16;
#line 88
      *(out + 1) = *(v + j) << 16;
#line 89
      out += stride;
#line 85
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 90
  return;
}
}
#line 98 "/root/patchweave_new/23/src/ALAC/matrix_dec.c"
void unmix20(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres ) 
{ 
  int32_t j ;
  int32_t l ;
  int32_t r ;

  {
#line 102
  if (mixres != 0) {
#line 105
    j = 0;
    {
#line 105
    while (1) {
      while_continue: /* CIL Label */ ;

#line 105
      if (! (j < numSamples)) {
#line 105
        goto while_break;
      }
      {
#line 109
      l = (*(u + j) + *(v + j)) - (mixres * *(v + j) >> mixbits);
#line 110
      r = l - *(v + j);
#line 112
      *(out + 0) = arith_shift_left(l, 12);
#line 113
      *(out + 1) = arith_shift_left(r, 12);
#line 114
      out += stride;
#line 105
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 120
    j = 0;
    {
#line 120
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 120
      if (! (j < numSamples)) {
#line 120
        goto while_break___0;
      }
      {
#line 122
      *(out + 0) = arith_shift_left(*(u + j), 12);
#line 123
      *(out + 1) = arith_shift_left(*(v + j), 12);
#line 124
      out += stride;
#line 120
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 125
  return;
}
}
#line 133 "/root/patchweave_new/23/src/ALAC/matrix_dec.c"
void unmix24(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) 
{ 
  int32_t shift ;
  int32_t l ;
  int32_t r ;
  int32_t j ;
  int32_t k ;
  int32_t __cil_tmp15 ;
  int32_t __cil_tmp16 ;
  int32_t __cil_tmp19 ;
  int32_t __cil_tmp21 ;

  {
#line 136
  shift = bytesShifted * 8;
#line 140
  if (mixres != 0) {
#line 143
    if (bytesShifted != 0) {
#line 145
      k = 0;
#line 145
      j = 0;
      {
#line 145
      while (1) {
        while_continue: /* CIL Label */ ;

#line 145
        if (! (j < numSamples)) {
#line 145
          goto while_break;
        }
        {
#line 147
        l = (*(u + j) + *(v + j)) - (mixres * *(v + j) >> mixbits);
#line 148
        r = l - *(v + j);
#line 150
        __cil_tmp15 = arith_shift_left(l, shift);
#line 150
        l = (int32_t )((unsigned int )__cil_tmp15 | (uint32_t )*(shiftUV + k));
#line 151
        __cil_tmp16 = arith_shift_left(r, shift);
#line 151
        r = (int32_t )((unsigned int )__cil_tmp16 | (uint32_t )*(shiftUV + (k + 1)));
#line 153
        *(out + 0) = arith_shift_left(l, 8);
#line 154
        *(out + 1) = arith_shift_left(r, 8);
#line 155
        out += stride;
#line 145
        k += 2;
#line 145
        __cil_tmp19 = j;
#line 145
        j ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break: ;
    } else {
#line 160
      j = 0;
      {
#line 160
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 160
        if (! (j < numSamples)) {
#line 160
          goto while_break___0;
        }
#line 162
        l = (*(u + j) + *(v + j)) - (mixres * *(v + j) >> mixbits);
#line 163
        r = l - *(v + j);
#line 165
        *(out + 0) = l << 8;
#line 166
        *(out + 1) = r << 8;
#line 167
        out += stride;
#line 160
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: ;
    }
  } else
#line 174
  if (bytesShifted != 0) {
#line 176
    k = 0;
#line 176
    j = 0;
    {
#line 176
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 176
      if (! (j < numSamples)) {
#line 176
        goto while_break___1;
      }
#line 178
      l = *(u + j);
#line 179
      r = *(v + j);
#line 181
      l = (int32_t )((unsigned int )(l << shift) | (uint32_t )*(shiftUV + k));
#line 182
      r = (int32_t )((unsigned int )(r << shift) | (uint32_t )*(shiftUV + (k + 1)));
#line 184
      *(out + 0) = l << 8;
#line 185
      *(out + 1) = r << 8;
#line 186
      out += stride;
#line 176
      k += 2;
#line 176
      __cil_tmp21 = j;
#line 176
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  } else {
#line 191
    j = 0;
    {
#line 191
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 191
      if (! (j < numSamples)) {
#line 191
        goto while_break___2;
      }
#line 193
      *(out + 0) = *(u + j) << 8;
#line 194
      *(out + 1) = *(v + j) << 8;
#line 195
      out += stride;
#line 191
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 196
  return;
}
}
#line 207 "/root/patchweave_new/23/src/ALAC/matrix_dec.c"
void unmix32(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) 
{ 
  int32_t shift ;
  int32_t l ;
  int32_t r ;
  int32_t j ;
  int32_t k ;
  int32_t lt ;
  int32_t rt ;
  int32_t __cil_tmp17 ;
  int32_t __cil_tmp18 ;
  int32_t __cil_tmp19 ;
  int32_t __cil_tmp21 ;

  {
#line 210
  shift = bytesShifted * 8;
#line 214
  if (mixres != 0) {
#line 219
    k = 0;
#line 219
    j = 0;
    {
#line 219
    while (1) {
      while_continue: /* CIL Label */ ;

#line 219
      if (! (j < numSamples)) {
#line 219
        goto while_break;
      }
      {
#line 223
      lt = *(u + j);
#line 224
      rt = *(v + j);
#line 226
      l = (lt + rt) - (mixres * rt >> mixbits);
#line 227
      r = l - rt;
#line 229
      __cil_tmp17 = arith_shift_left(l, shift);
#line 229
      *(out + 0) = (int32_t )((unsigned int )__cil_tmp17 | (uint32_t )*(shiftUV + k));
#line 230
      __cil_tmp18 = arith_shift_left(r, shift);
#line 230
      *(out + 1) = (int32_t )((unsigned int )__cil_tmp18 | (uint32_t )*(shiftUV + (k + 1)));
#line 231
      out += stride;
#line 219
      k += 2;
#line 219
      __cil_tmp19 = j;
#line 219
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  } else
#line 236
  if (bytesShifted == 0) {
#line 239
    j = 0;
    {
#line 239
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 239
      if (! (j < numSamples)) {
#line 239
        goto while_break___0;
      }
#line 241
      *(out + 0) = *(u + j);
#line 242
      *(out + 1) = *(v + j);
#line 243
      out += stride;
#line 239
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  } else {
#line 249
    k = 0;
#line 249
    j = 0;
    {
#line 249
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 249
      if (! (j < numSamples)) {
#line 249
        goto while_break___1;
      }
#line 251
      *(out + 0) = (int32_t )((unsigned int )(*(u + j) << shift) | (uint32_t )*(shiftUV + k));
#line 252
      *(out + 1) = (int32_t )((unsigned int )(*(v + j) << shift) | (uint32_t )*(shiftUV + (k + 1)));
#line 253
      out += stride;
#line 249
      k += 2;
#line 249
      __cil_tmp21 = j;
#line 249
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 254
  return;
}
}
#line 262 "/root/patchweave_new/23/src/ALAC/matrix_dec.c"
void copyPredictorTo24(int32_t *in , int32_t *out , uint32_t stride , int32_t numSamples ) 
{ 
  int32_t j ;

  {
#line 266
  j = 0;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;

#line 266
    if (! (j < numSamples)) {
#line 266
      goto while_break;
    }
#line 268
    *(out + 0) = *(in + j) << 8;
#line 269
    out += stride;
#line 266
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 270
  return;
}
}
#line 274 "/root/patchweave_new/23/src/ALAC/matrix_dec.c"
void copyPredictorTo24Shift(int32_t *in , uint16_t *shift , int32_t *out , uint32_t stride ,
                            int32_t numSamples , int32_t bytesShifted ) 
{ 
  int32_t shiftVal ;
  int32_t j ;
  int32_t val ;
  int32_t __cil_tmp10 ;

  {
#line 276
  shiftVal = bytesShifted * 8;
#line 281
  j = 0;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;

#line 281
    if (! (j < numSamples)) {
#line 281
      goto while_break;
    }
    {
#line 283
    val = *(in + j);
#line 285
    __cil_tmp10 = arith_shift_left(val, shiftVal);
#line 285
    val = (int32_t )((unsigned int )__cil_tmp10 | (uint32_t )*(shift + j));
#line 286
    *(out + 0) = arith_shift_left(val, 8);
#line 287
    out += stride;
#line 281
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 285
  return;
}
}
#line 292 "/root/patchweave_new/23/src/ALAC/matrix_dec.c"
void copyPredictorTo20(int32_t *in , int32_t *out , uint32_t stride , int32_t numSamples ) 
{ 
  int32_t j ;

  {
#line 298
  j = 0;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;

#line 298
    if (! (j < numSamples)) {
#line 298
      goto while_break;
    }
    {
#line 300
    *(out + 0) = arith_shift_left(*(in + j), 12);
#line 301
    out += stride;
#line 298
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 302
  return;
}
}
#line 306 "/root/patchweave_new/23/src/ALAC/matrix_dec.c"
void copyPredictorTo32(int32_t *in , int32_t *out , uint32_t stride , int32_t numSamples ) 
{ 
  int32_t i ;
  int32_t j ;
  int32_t __cil_tmp8 ;

  {
#line 311
  j = 0;
#line 311
  i = 0;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;

#line 311
    if (! (i < numSamples)) {
#line 311
      goto while_break;
    }
    {
#line 312
    *(out + j) = arith_shift_left(*(in + i), 8);
#line 311
    j = (int32_t )((uint32_t )j + stride);
#line 311
    __cil_tmp8 = i;
#line 311
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 315
  return;
}
}
#line 316 "/root/patchweave_new/23/src/ALAC/matrix_dec.c"
void copyPredictorTo32Shift(int32_t *in , uint16_t *shift , int32_t *out , uint32_t stride ,
                            int32_t numSamples , int32_t bytesShifted ) 
{ 
  int32_t *op ;
  uint32_t shiftVal ;
  int32_t j ;
  int32_t __cil_tmp10 ;

  {
#line 318
  op = out;
#line 319
  shiftVal = (uint32_t )(bytesShifted * 8);
#line 325
  j = 0;
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;

#line 325
    if (! (j < numSamples)) {
#line 325
      goto while_break;
    }
    {
#line 327
    __cil_tmp10 = arith_shift_left(*(in + j), (int )shiftVal);
#line 327
    *(op + 0) = (int32_t )((unsigned int )__cil_tmp10 | (uint32_t )*(shift + j));
#line 328
    op += stride;
#line 325
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 329
  return;
}
}
#line 49 "/root/patchweave_new/23/src/ALAC/dplib.h"
void init_coefs(int16_t *coefs , uint32_t denshift , int32_t numPairs ) ;
#line 50
void copy_coefs(int16_t *srcCoefs , int16_t *dstCoefs , int32_t numPairs ) ;
#line 54
void pc_block(int32_t *in , int32_t *pc1 , int32_t num , int16_t *coefs , int32_t numactive ,
              uint32_t chanbits , uint32_t denshift ) ;
#line 55
void unpc_block(int32_t *pc1 , int32_t *out , int32_t num , int16_t *coefs , int32_t numactive ,
                uint32_t chanbits , uint32_t denshift ) ;
#line 43 "/root/patchweave_new/23/src/ALAC/dp_enc.c"
void init_coefs(int16_t *coefs , uint32_t denshift , int32_t numPairs ) 
{ 
  int32_t k ;
  int32_t den ;

  {
#line 46
  den = 1 << denshift;
#line 48
  *(coefs + 0) = (int16_t )(38 * den >> 4);
#line 49
  *(coefs + 1) = (int16_t )(-29 * den >> 4);
#line 50
  *(coefs + 2) = (int16_t )(-2 * den >> 4);
#line 51
  k = 3;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;

#line 51
    if (! (k < numPairs)) {
#line 51
      goto while_break;
    }
#line 52
    *(coefs + k) = (int16_t )0;
#line 51
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 55
  return;
}
}
#line 56 "/root/patchweave_new/23/src/ALAC/dp_enc.c"
void copy_coefs(int16_t *srcCoefs , int16_t *dstCoefs , int32_t numPairs ) 
{ 
  int32_t k ;

  {
#line 60
  k = 0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;

#line 60
    if (! (k < numPairs)) {
#line 60
      goto while_break;
    }
#line 61
    *(dstCoefs + k) = *(srcCoefs + k);
#line 60
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 64
  return;
}
}
#line 64 "/root/patchweave_new/23/src/ALAC/dp_enc.c"
__inline static int32_t sign_of_int(int32_t i ) 
{ 
  int32_t negishift ;

  {
#line 68
  negishift = (int32_t )((uint32_t )(- i) >> 31);
#line 69
  return (negishift | (i >> 31));
}
}
#line 73 "/root/patchweave_new/23/src/ALAC/dp_enc.c"
void pc_block(int32_t *in , int32_t *pc1 , int32_t num , int16_t *coefs , int32_t numactive ,
              uint32_t chanbits , uint32_t denshift ) 
{ 
  register int16_t a0 ;
  register int16_t a1 ;
  register int16_t a2 ;
  register int16_t a3 ;
  register int32_t b0 ;
  register int32_t b1 ;
  register int32_t b2 ;
  register int32_t b3 ;
  int32_t j ;
  int32_t k ;
  int32_t lim ;
  int32_t *pin ;
  int32_t sum1 ;
  int32_t dd ;
  int32_t sg ;
  int32_t sgn ;
  int32_t top ;
  int32_t del ;
  int32_t del0 ;
  uint32_t chanshift ;
  int32_t denhalf ;
  int32_t __cil_tmp30 ;
  int32_t __cil_tmp32 ;
  int32_t __cil_tmp37 ;
  int32_t __cil_tmp38 ;
  int32_t __cil_tmp39 ;
  int32_t __cil_tmp40 ;
  int32_t __cil_tmp41 ;
  register int16_t a4 ;
  register int16_t a5 ;
  register int16_t a6 ;
  register int16_t a7 ;
  register int32_t b4 ;
  register int32_t b5 ;
  register int32_t b6 ;
  register int32_t b7 ;
  int32_t *__cil_tmp51 ;
  int32_t *__cil_tmp52 ;
  int32_t *__cil_tmp53 ;
  int32_t *__cil_tmp54 ;
  int32_t *__cil_tmp55 ;
  int32_t *__cil_tmp56 ;
  int32_t *__cil_tmp57 ;
  int32_t __cil_tmp58 ;
  int32_t __cil_tmp67 ;
  int32_t __cil_tmp68 ;
  int32_t __cil_tmp69 ;
  int32_t __cil_tmp70 ;
  int32_t __cil_tmp71 ;
  int32_t __cil_tmp72 ;
  int32_t __cil_tmp73 ;
  int32_t __cil_tmp74 ;
  int32_t __cil_tmp75 ;
  int32_t __cil_tmp80 ;
  int32_t __cil_tmp82 ;

  {
#line 83
  chanshift = 32U - chanbits;
#line 84
  denhalf = 1 << (denshift - 1U);
#line 86
  *(pc1 + 0) = *(in + 0);
#line 87
  if (numactive == 0) {
#line 90
    if ((unsigned long )in != (unsigned long )pc1) {
#line 90
      if (num > 1) {
        {
#line 91
        memcpy((void *)(pc1 + 1), (void const   *)(in + 1), (unsigned long )(num - 1) * sizeof(int32_t ));
        }
      }
    }
#line 92
    return;
  }
#line 94
  if (numactive == 31) {
#line 97
    j = 1;
    {
#line 97
    while (1) {
      while_continue: /* CIL Label */ ;

#line 97
      if (! (j < num)) {
#line 97
        goto while_break;
      }
#line 99
      del = *(in + j) - *(in + (j - 1));
#line 100
      *(pc1 + j) = (del << chanshift) >> chanshift;
#line 97
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break: ;
#line 102
    return;
  }
#line 105
  j = 1;
  {
#line 105
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 105
    if (! (j <= numactive)) {
#line 105
      goto while_break___0;
    }
    {
#line 107
    del = *(in + j) - *(in + (j - 1));
#line 108
    __cil_tmp30 = arith_shift_left(del, (int )chanshift);
#line 108
    *(pc1 + j) = __cil_tmp30 >> chanshift;
#line 105
    j ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___0: 
#line 111
  lim = numactive + 1;
#line 113
  if (numactive == 4) {
#line 116
    a0 = *(coefs + 0);
#line 117
    a1 = *(coefs + 1);
#line 118
    a2 = *(coefs + 2);
#line 119
    a3 = *(coefs + 3);
#line 121
    j = lim;
    {
#line 121
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: ;
#line 121
      if (! (j < num)) {
#line 121
        goto while_break___1;
      }
      {
#line 125
      top = *(in + (j - lim));
#line 126
      pin = (in + j) - 1;
#line 128
      b0 = top - *(pin + 0);
#line 129
      b1 = top - *(pin + -1);
#line 130
      b2 = top - *(pin + -2);
#line 131
      b3 = top - *(pin + -3);
#line 133
      sum1 = ((((denhalf - (int )a0 * b0) - (int )a1 * b1) - (int )a2 * b2) - (int )a3 * b3) >> denshift;
#line 135
      del = (*(in + j) - top) - sum1;
#line 136
      __cil_tmp32 = arith_shift_left(del, (int )chanshift);
#line 136
      del = __cil_tmp32 >> chanshift;
#line 137
      *(pc1 + j) = del;
#line 138
      del0 = del;
#line 140
      sg = sign_of_int(del);
      }
#line 141
      if (sg > 0) {
        {
#line 143
        sgn = sign_of_int(b3);
#line 144
        a3 = (int16_t )((int )a3 - sgn);
#line 145
        del0 -= sgn * b3 >> denshift;
        }
#line 146
        if (del0 <= 0) {
#line 147
          goto while_continue___1;
        }
        {
#line 149
        sgn = sign_of_int(b2);
#line 150
        a2 = (int16_t )((int )a2 - sgn);
#line 151
        del0 -= 2 * (sgn * b2 >> denshift);
        }
#line 152
        if (del0 <= 0) {
#line 153
          goto while_continue___1;
        }
        {
#line 155
        sgn = sign_of_int(b1);
#line 156
        a1 = (int16_t )((int )a1 - sgn);
#line 157
        del0 -= 3 * (sgn * b1 >> denshift);
        }
#line 158
        if (del0 <= 0) {
#line 159
          goto while_continue___1;
        }
        {
#line 161
        __cil_tmp37 = sign_of_int(b0);
#line 161
        a0 = (int16_t )((int )a0 - __cil_tmp37);
        }
      } else
#line 163
      if (sg < 0) {
        {
#line 166
        __cil_tmp38 = sign_of_int(b3);
#line 166
        sgn = - __cil_tmp38;
#line 167
        a3 = (int16_t )((int )a3 - sgn);
#line 168
        del0 -= sgn * b3 >> denshift;
        }
#line 169
        if (del0 >= 0) {
#line 170
          goto while_continue___1;
        }
        {
#line 172
        __cil_tmp39 = sign_of_int(b2);
#line 172
        sgn = - __cil_tmp39;
#line 173
        a2 = (int16_t )((int )a2 - sgn);
#line 174
        del0 -= 2 * (sgn * b2 >> denshift);
        }
#line 175
        if (del0 >= 0) {
#line 176
          goto while_continue___1;
        }
        {
#line 178
        __cil_tmp40 = sign_of_int(b1);
#line 178
        sgn = - __cil_tmp40;
#line 179
        a1 = (int16_t )((int )a1 - sgn);
#line 180
        del0 -= 3 * (sgn * b1 >> denshift);
        }
#line 181
        if (del0 >= 0) {
#line 182
          goto while_continue___1;
        }
        {
#line 184
        __cil_tmp41 = sign_of_int(b0);
#line 184
        a0 = (int16_t )((int )a0 + __cil_tmp41);
        }
      }
#line 121
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___1: 
#line 188
    *(coefs + 0) = a0;
#line 189
    *(coefs + 1) = a1;
#line 190
    *(coefs + 2) = a2;
#line 191
    *(coefs + 3) = a3;
  } else
#line 193
  if (numactive == 8) {
#line 199
    a0 = *(coefs + 0);
#line 200
    a1 = *(coefs + 1);
#line 201
    a2 = *(coefs + 2);
#line 202
    a3 = *(coefs + 3);
#line 203
    a4 = *(coefs + 4);
#line 204
    a5 = *(coefs + 5);
#line 205
    a6 = *(coefs + 6);
#line 206
    a7 = *(coefs + 7);
#line 208
    j = lim;
    {
#line 208
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___2: ;
#line 208
      if (! (j < num)) {
#line 208
        goto while_break___2;
      }
      {
#line 212
      top = *(in + (j - lim));
#line 213
      pin = (in + j) - 1;
#line 215
      __cil_tmp51 = pin;
#line 215
      pin --;
#line 215
      b0 = top - *__cil_tmp51;
#line 216
      __cil_tmp52 = pin;
#line 216
      pin --;
#line 216
      b1 = top - *__cil_tmp52;
#line 217
      __cil_tmp53 = pin;
#line 217
      pin --;
#line 217
      b2 = top - *__cil_tmp53;
#line 218
      __cil_tmp54 = pin;
#line 218
      pin --;
#line 218
      b3 = top - *__cil_tmp54;
#line 219
      __cil_tmp55 = pin;
#line 219
      pin --;
#line 219
      b4 = top - *__cil_tmp55;
#line 220
      __cil_tmp56 = pin;
#line 220
      pin --;
#line 220
      b5 = top - *__cil_tmp56;
#line 221
      __cil_tmp57 = pin;
#line 221
      pin --;
#line 221
      b6 = top - *__cil_tmp57;
#line 222
      b7 = top - *pin;
#line 223
      pin += 8;
#line 225
      sum1 = ((((((((denhalf - (int )a0 * b0) - (int )a1 * b1) - (int )a2 * b2) - (int )a3 * b3) - (int )a4 * b4) - (int )a5 * b5) - (int )a6 * b6) - (int )a7 * b7) >> denshift;
#line 228
      del = (*(in + j) - top) - sum1;
#line 229
      __cil_tmp58 = arith_shift_left(del, (int )chanshift);
#line 229
      del = __cil_tmp58 >> chanshift;
#line 230
      *(pc1 + j) = del;
#line 231
      del0 = del;
#line 233
      sg = sign_of_int(del);
      }
#line 234
      if (sg > 0) {
        {
#line 236
        sgn = sign_of_int(b7);
#line 237
        a7 = (int16_t )((int )a7 - sgn);
#line 238
        del0 -= sgn * b7 >> denshift;
        }
#line 239
        if (del0 <= 0) {
#line 240
          goto while_continue___2;
        }
        {
#line 242
        sgn = sign_of_int(b6);
#line 243
        a6 = (int16_t )((int )a6 - sgn);
#line 244
        del0 -= 2 * (sgn * b6 >> denshift);
        }
#line 245
        if (del0 <= 0) {
#line 246
          goto while_continue___2;
        }
        {
#line 248
        sgn = sign_of_int(b5);
#line 249
        a5 = (int16_t )((int )a5 - sgn);
#line 250
        del0 -= 3 * (sgn * b5 >> denshift);
        }
#line 251
        if (del0 <= 0) {
#line 252
          goto while_continue___2;
        }
        {
#line 254
        sgn = sign_of_int(b4);
#line 255
        a4 = (int16_t )((int )a4 - sgn);
#line 256
        del0 -= 4 * (sgn * b4 >> denshift);
        }
#line 257
        if (del0 <= 0) {
#line 258
          goto while_continue___2;
        }
        {
#line 260
        sgn = sign_of_int(b3);
#line 261
        a3 = (int16_t )((int )a3 - sgn);
#line 262
        del0 -= 5 * (sgn * b3 >> denshift);
        }
#line 263
        if (del0 <= 0) {
#line 264
          goto while_continue___2;
        }
        {
#line 266
        sgn = sign_of_int(b2);
#line 267
        a2 = (int16_t )((int )a2 - sgn);
#line 268
        del0 -= 6 * (sgn * b2 >> denshift);
        }
#line 269
        if (del0 <= 0) {
#line 270
          goto while_continue___2;
        }
        {
#line 272
        sgn = sign_of_int(b1);
#line 273
        a1 = (int16_t )((int )a1 - sgn);
#line 274
        del0 -= 7 * (sgn * b1 >> denshift);
        }
#line 275
        if (del0 <= 0) {
#line 276
          goto while_continue___2;
        }
        {
#line 278
        __cil_tmp67 = sign_of_int(b0);
#line 278
        a0 = (int16_t )((int )a0 - __cil_tmp67);
        }
      } else
#line 280
      if (sg < 0) {
        {
#line 283
        __cil_tmp68 = sign_of_int(b7);
#line 283
        sgn = - __cil_tmp68;
#line 284
        a7 = (int16_t )((int )a7 - sgn);
#line 285
        del0 -= sgn * b7 >> denshift;
        }
#line 286
        if (del0 >= 0) {
#line 287
          goto while_continue___2;
        }
        {
#line 289
        __cil_tmp69 = sign_of_int(b6);
#line 289
        sgn = - __cil_tmp69;
#line 290
        a6 = (int16_t )((int )a6 - sgn);
#line 291
        del0 -= 2 * (sgn * b6 >> denshift);
        }
#line 292
        if (del0 >= 0) {
#line 293
          goto while_continue___2;
        }
        {
#line 295
        __cil_tmp70 = sign_of_int(b5);
#line 295
        sgn = - __cil_tmp70;
#line 296
        a5 = (int16_t )((int )a5 - sgn);
#line 297
        del0 -= 3 * (sgn * b5 >> denshift);
        }
#line 298
        if (del0 >= 0) {
#line 299
          goto while_continue___2;
        }
        {
#line 301
        __cil_tmp71 = sign_of_int(b4);
#line 301
        sgn = - __cil_tmp71;
#line 302
        a4 = (int16_t )((int )a4 - sgn);
#line 303
        del0 -= 4 * (sgn * b4 >> denshift);
        }
#line 304
        if (del0 >= 0) {
#line 305
          goto while_continue___2;
        }
        {
#line 307
        __cil_tmp72 = sign_of_int(b3);
#line 307
        sgn = - __cil_tmp72;
#line 308
        a3 = (int16_t )((int )a3 - sgn);
#line 309
        del0 -= 5 * (sgn * b3 >> denshift);
        }
#line 310
        if (del0 >= 0) {
#line 311
          goto while_continue___2;
        }
        {
#line 313
        __cil_tmp73 = sign_of_int(b2);
#line 313
        sgn = - __cil_tmp73;
#line 314
        a2 = (int16_t )((int )a2 - sgn);
#line 315
        del0 -= 6 * (sgn * b2 >> denshift);
        }
#line 316
        if (del0 >= 0) {
#line 317
          goto while_continue___2;
        }
        {
#line 319
        __cil_tmp74 = sign_of_int(b1);
#line 319
        sgn = - __cil_tmp74;
#line 320
        a1 = (int16_t )((int )a1 - sgn);
#line 321
        del0 -= 7 * (sgn * b1 >> denshift);
        }
#line 322
        if (del0 >= 0) {
#line 323
          goto while_continue___2;
        }
        {
#line 325
        __cil_tmp75 = sign_of_int(b0);
#line 325
        a0 = (int16_t )((int )a0 + __cil_tmp75);
        }
      }
#line 208
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___2: 
#line 329
    *(coefs + 0) = a0;
#line 330
    *(coefs + 1) = a1;
#line 331
    *(coefs + 2) = a2;
#line 332
    *(coefs + 3) = a3;
#line 333
    *(coefs + 4) = a4;
#line 334
    *(coefs + 5) = a5;
#line 335
    *(coefs + 6) = a6;
#line 336
    *(coefs + 7) = a7;
  } else {
#line 342
    j = lim;
    {
#line 342
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 342
      if (! (j < num)) {
#line 342
        goto while_break___3;
      }
#line 346
      top = *(in + (j - lim));
#line 347
      pin = (in + j) - 1;
#line 349
      sum1 = 0;
#line 350
      k = 0;
      {
#line 350
      while (1) {
        while_continue___7: /* CIL Label */ ;

#line 350
        if (! (k < numactive)) {
#line 350
          goto while_break___4;
        }
#line 351
        sum1 -= (int )*(coefs + k) * (top - *(pin + - k));
#line 350
        k ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___4: 
      {
#line 353
      del = (*(in + j) - top) - ((sum1 + denhalf) >> denshift);
#line 354
      del = (del << chanshift) >> chanshift;
#line 355
      *(pc1 + j) = del;
#line 356
      del0 = del;
#line 358
      sg = sign_of_int(del);
      }
#line 359
      if (sg > 0) {
#line 361
        k = numactive - 1;
        {
#line 361
        while (1) {
          while_continue___8: /* CIL Label */ ;

#line 361
          if (! (k >= 0)) {
#line 361
            goto while_break___5;
          }
          {
#line 363
          dd = top - *(pin + - k);
#line 364
          sgn = sign_of_int(dd);
#line 365
          *(coefs + k) = (int16_t )((int )*(coefs + k) - sgn);
#line 366
          del0 -= (numactive - k) * (sgn * dd >> denshift);
          }
#line 367
          if (del0 <= 0) {
#line 368
            goto while_break___5;
          }
#line 361
          __cil_tmp80 = k;
#line 361
          k --;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: ;
      } else
#line 371
      if (sg < 0) {
#line 373
        k = numactive - 1;
        {
#line 373
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 373
          if (! (k >= 0)) {
#line 373
            goto while_break___6;
          }
          {
#line 375
          dd = top - *(pin + - k);
#line 376
          sgn = sign_of_int(dd);
#line 377
          *(coefs + k) = (int16_t )((int )*(coefs + k) + sgn);
#line 378
          del0 -= (numactive - k) * (- sgn * dd >> denshift);
          }
#line 379
          if (del0 >= 0) {
#line 380
            goto while_break___6;
          }
#line 373
          __cil_tmp82 = k;
#line 373
          k --;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: ;
      }
#line 342
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___3: ;
  }
#line 347
  return;
}
}
#line 53 "/root/patchweave_new/23/src/ALAC/dp_dec.c"
void unpc_block(int32_t *pc1 , int32_t *out , int32_t num , int16_t *coefs , int32_t numactive ,
                uint32_t chanbits , uint32_t denshift ) 
{ 
  register int16_t a0 ;
  register int16_t a1 ;
  register int16_t a2 ;
  register int16_t a3 ;
  register int32_t b0 ;
  register int32_t b1 ;
  register int32_t b2 ;
  register int32_t b3 ;
  int32_t j ;
  int32_t k ;
  int32_t lim ;
  int32_t sum1 ;
  int32_t sg ;
  int32_t sgn ;
  int32_t top ;
  int32_t dd ;
  int32_t *pout ;
  int32_t del ;
  int32_t del0 ;
  uint32_t chanshift ;
  int32_t denhalf ;
  int32_t prev ;
  int32_t __cil_tmp31 ;
  register int16_t ia0 ;
  register int16_t ia1 ;
  register int16_t ia2 ;
  register int16_t ia3 ;
  register int32_t ib0 ;
  register int32_t ib1 ;
  register int32_t ib2 ;
  register int32_t ib3 ;
  int32_t __cil_tmp42 ;
  int32_t __cil_tmp46 ;
  int32_t __cil_tmp47 ;
  int32_t __cil_tmp48 ;
  int32_t __cil_tmp49 ;
  int32_t __cil_tmp50 ;
  register int16_t a4 ;
  register int16_t a5 ;
  register int16_t a6 ;
  register int16_t a7 ;
  register int32_t b4 ;
  register int32_t b5 ;
  register int32_t b6 ;
  register int32_t b7 ;
  int32_t *__cil_tmp60 ;
  int32_t *__cil_tmp61 ;
  int32_t *__cil_tmp62 ;
  int32_t *__cil_tmp63 ;
  int32_t *__cil_tmp64 ;
  int32_t *__cil_tmp65 ;
  int32_t *__cil_tmp66 ;
  int32_t __cil_tmp68 ;
  int32_t __cil_tmp76 ;
  int32_t __cil_tmp77 ;
  int32_t __cil_tmp78 ;
  int32_t __cil_tmp79 ;
  int32_t __cil_tmp80 ;
  int32_t __cil_tmp81 ;
  int32_t __cil_tmp82 ;
  int32_t __cil_tmp83 ;
  int32_t __cil_tmp84 ;
  int32_t __cil_tmp89 ;
  int32_t __cil_tmp91 ;

  {
#line 61
  chanshift = 32U - chanbits;
#line 62
  denhalf = 1 << (denshift - 1U);
#line 64
  *(out + 0) = *(pc1 + 0);
#line 65
  if (numactive == 0) {
#line 68
    if ((unsigned long )pc1 != (unsigned long )out) {
#line 68
      if (num > 1) {
        {
#line 69
        memcpy((void *)(out + 1), (void const   *)(pc1 + 1), (unsigned long )(num - 1) * sizeof(int32_t ));
        }
      }
    }
#line 70
    return;
  }
#line 72
  if (numactive == 31) {
#line 85
    prev = *(out + 0);
#line 86
    j = 1;
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;

#line 86
      if (! (j < num)) {
#line 86
        goto while_break;
      }
#line 88
      del = *(pc1 + j) + prev;
#line 89
      prev = (del << chanshift) >> chanshift;
#line 90
      *(out + j) = prev;
#line 86
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break: ;
#line 92
    return;
  }
#line 95
  j = 1;
  {
#line 95
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 95
    if (! (j <= numactive)) {
#line 95
      goto while_break___0;
    }
    {
#line 97
    del = *(pc1 + j) + *(out + (j - 1));
#line 98
    __cil_tmp31 = arith_shift_left(del, (int )chanshift);
#line 98
    *(out + j) = __cil_tmp31 >> chanshift;
#line 95
    j ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___0: 
#line 101
  lim = numactive + 1;
#line 103
  if (numactive == 4) {
#line 109
    ia0 = *(coefs + 0);
#line 110
    ia1 = *(coefs + 1);
#line 111
    ia2 = *(coefs + 2);
#line 112
    ia3 = *(coefs + 3);
#line 114
    j = lim;
    {
#line 114
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: ;
#line 114
      if (! (j < num)) {
#line 114
        goto while_break___1;
      }
      {
#line 118
      top = *(out + (j - lim));
#line 119
      pout = (out + j) - 1;
#line 121
      ib0 = top - *(pout + 0);
#line 122
      ib1 = top - *(pout + -1);
#line 123
      ib2 = top - *(pout + -2);
#line 124
      ib3 = top - *(pout + -3);
#line 126
      sum1 = ((((denhalf - (int )ia0 * ib0) - (int )ia1 * ib1) - (int )ia2 * ib2) - (int )ia3 * ib3) >> denshift;
#line 128
      del = *(pc1 + j);
#line 129
      del0 = del;
#line 130
      sg = sign_of_int(del);
#line 131
      del += top + sum1;
#line 133
      __cil_tmp42 = arith_shift_left(del, (int )chanshift);
#line 133
      *(out + j) = __cil_tmp42 >> chanshift;
      }
#line 135
      if (sg > 0) {
        {
#line 137
        sgn = sign_of_int(ib3);
#line 138
        ia3 = (int16_t )((int )ia3 - sgn);
#line 139
        del0 -= sgn * ib3 >> denshift;
        }
#line 140
        if (del0 <= 0) {
#line 141
          goto while_continue___1;
        }
        {
#line 143
        sgn = sign_of_int(ib2);
#line 144
        ia2 = (int16_t )((int )ia2 - sgn);
#line 145
        del0 -= 2 * (sgn * ib2 >> denshift);
        }
#line 146
        if (del0 <= 0) {
#line 147
          goto while_continue___1;
        }
        {
#line 149
        sgn = sign_of_int(ib1);
#line 150
        ia1 = (int16_t )((int )ia1 - sgn);
#line 151
        del0 -= 3 * (sgn * ib1 >> denshift);
        }
#line 152
        if (del0 <= 0) {
#line 153
          goto while_continue___1;
        }
        {
#line 155
        __cil_tmp46 = sign_of_int(ib0);
#line 155
        ia0 = (int16_t )((int )ia0 - __cil_tmp46);
        }
      } else
#line 157
      if (sg < 0) {
        {
#line 160
        __cil_tmp47 = sign_of_int(ib3);
#line 160
        sgn = - __cil_tmp47;
#line 161
        ia3 = (int16_t )((int )ia3 - sgn);
#line 162
        del0 -= sgn * ib3 >> denshift;
        }
#line 163
        if (del0 >= 0) {
#line 164
          goto while_continue___1;
        }
        {
#line 166
        __cil_tmp48 = sign_of_int(ib2);
#line 166
        sgn = - __cil_tmp48;
#line 167
        ia2 = (int16_t )((int )ia2 - sgn);
#line 168
        del0 -= 2 * (sgn * ib2 >> denshift);
        }
#line 169
        if (del0 >= 0) {
#line 170
          goto while_continue___1;
        }
        {
#line 172
        __cil_tmp49 = sign_of_int(ib1);
#line 172
        sgn = - __cil_tmp49;
#line 173
        ia1 = (int16_t )((int )ia1 - sgn);
#line 174
        del0 -= 3 * (sgn * ib1 >> denshift);
        }
#line 175
        if (del0 >= 0) {
#line 176
          goto while_continue___1;
        }
        {
#line 178
        __cil_tmp50 = sign_of_int(ib0);
#line 178
        ia0 = (int16_t )((int )ia0 + __cil_tmp50);
        }
      }
#line 114
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___1: 
#line 182
    *(coefs + 0) = ia0;
#line 183
    *(coefs + 1) = ia1;
#line 184
    *(coefs + 2) = ia2;
#line 185
    *(coefs + 3) = ia3;
  } else
#line 187
  if (numactive == 8) {
#line 193
    a0 = *(coefs + 0);
#line 194
    a1 = *(coefs + 1);
#line 195
    a2 = *(coefs + 2);
#line 196
    a3 = *(coefs + 3);
#line 197
    a4 = *(coefs + 4);
#line 198
    a5 = *(coefs + 5);
#line 199
    a6 = *(coefs + 6);
#line 200
    a7 = *(coefs + 7);
#line 202
    j = lim;
    {
#line 202
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___2: ;
#line 202
      if (! (j < num)) {
#line 202
        goto while_break___2;
      }
      {
#line 206
      top = *(out + (j - lim));
#line 207
      pout = (out + j) - 1;
#line 209
      __cil_tmp60 = pout;
#line 209
      pout --;
#line 209
      b0 = top - *__cil_tmp60;
#line 210
      __cil_tmp61 = pout;
#line 210
      pout --;
#line 210
      b1 = top - *__cil_tmp61;
#line 211
      __cil_tmp62 = pout;
#line 211
      pout --;
#line 211
      b2 = top - *__cil_tmp62;
#line 212
      __cil_tmp63 = pout;
#line 212
      pout --;
#line 212
      b3 = top - *__cil_tmp63;
#line 213
      __cil_tmp64 = pout;
#line 213
      pout --;
#line 213
      b4 = top - *__cil_tmp64;
#line 214
      __cil_tmp65 = pout;
#line 214
      pout --;
#line 214
      b5 = top - *__cil_tmp65;
#line 215
      __cil_tmp66 = pout;
#line 215
      pout --;
#line 215
      b6 = top - *__cil_tmp66;
#line 216
      b7 = top - *pout;
#line 217
      pout += 8;
#line 219
      sum1 = ((((((((denhalf - (int )a0 * b0) - (int )a1 * b1) - (int )a2 * b2) - (int )a3 * b3) - (int )a4 * b4) - (int )a5 * b5) - (int )a6 * b6) - (int )a7 * b7) >> denshift;
#line 222
      del = *(pc1 + j);
#line 223
      del0 = del;
#line 224
      sg = sign_of_int(del);
#line 225
      del += top + sum1;
#line 227
      __cil_tmp68 = arith_shift_left(del, (int )chanshift);
#line 227
      *(out + j) = __cil_tmp68 >> chanshift;
      }
#line 229
      if (sg > 0) {
        {
#line 231
        sgn = sign_of_int(b7);
#line 232
        a7 = (int16_t )((int )a7 - sgn);
#line 233
        del0 -= sgn * b7 >> denshift;
        }
#line 234
        if (del0 <= 0) {
#line 235
          goto while_continue___2;
        }
        {
#line 237
        sgn = sign_of_int(b6);
#line 238
        a6 = (int16_t )((int )a6 - sgn);
#line 239
        del0 -= 2 * (sgn * b6 >> denshift);
        }
#line 240
        if (del0 <= 0) {
#line 241
          goto while_continue___2;
        }
        {
#line 243
        sgn = sign_of_int(b5);
#line 244
        a5 = (int16_t )((int )a5 - sgn);
#line 245
        del0 -= 3 * (sgn * b5 >> denshift);
        }
#line 246
        if (del0 <= 0) {
#line 247
          goto while_continue___2;
        }
        {
#line 249
        sgn = sign_of_int(b4);
#line 250
        a4 = (int16_t )((int )a4 - sgn);
#line 251
        del0 -= 4 * (sgn * b4 >> denshift);
        }
#line 252
        if (del0 <= 0) {
#line 253
          goto while_continue___2;
        }
        {
#line 255
        sgn = sign_of_int(b3);
#line 256
        a3 = (int16_t )((int )a3 - sgn);
#line 257
        del0 -= 5 * (sgn * b3 >> denshift);
        }
#line 258
        if (del0 <= 0) {
#line 259
          goto while_continue___2;
        }
        {
#line 261
        sgn = sign_of_int(b2);
#line 262
        a2 = (int16_t )((int )a2 - sgn);
#line 263
        del0 -= 6 * (sgn * b2 >> denshift);
        }
#line 264
        if (del0 <= 0) {
#line 265
          goto while_continue___2;
        }
        {
#line 267
        sgn = sign_of_int(b1);
#line 268
        a1 = (int16_t )((int )a1 - sgn);
#line 269
        del0 -= 7 * (sgn * b1 >> denshift);
        }
#line 270
        if (del0 <= 0) {
#line 271
          goto while_continue___2;
        }
        {
#line 273
        __cil_tmp76 = sign_of_int(b0);
#line 273
        a0 = (int16_t )((int )a0 - __cil_tmp76);
        }
      } else
#line 275
      if (sg < 0) {
        {
#line 278
        __cil_tmp77 = sign_of_int(b7);
#line 278
        sgn = - __cil_tmp77;
#line 279
        a7 = (int16_t )((int )a7 - sgn);
#line 280
        del0 -= sgn * b7 >> denshift;
        }
#line 281
        if (del0 >= 0) {
#line 282
          goto while_continue___2;
        }
        {
#line 284
        __cil_tmp78 = sign_of_int(b6);
#line 284
        sgn = - __cil_tmp78;
#line 285
        a6 = (int16_t )((int )a6 - sgn);
#line 286
        del0 -= 2 * (sgn * b6 >> denshift);
        }
#line 287
        if (del0 >= 0) {
#line 288
          goto while_continue___2;
        }
        {
#line 290
        __cil_tmp79 = sign_of_int(b5);
#line 290
        sgn = - __cil_tmp79;
#line 291
        a5 = (int16_t )((int )a5 - sgn);
#line 292
        del0 -= 3 * (sgn * b5 >> denshift);
        }
#line 293
        if (del0 >= 0) {
#line 294
          goto while_continue___2;
        }
        {
#line 296
        __cil_tmp80 = sign_of_int(b4);
#line 296
        sgn = - __cil_tmp80;
#line 297
        a4 = (int16_t )((int )a4 - sgn);
#line 298
        del0 -= 4 * (sgn * b4 >> denshift);
        }
#line 299
        if (del0 >= 0) {
#line 300
          goto while_continue___2;
        }
        {
#line 302
        __cil_tmp81 = sign_of_int(b3);
#line 302
        sgn = - __cil_tmp81;
#line 303
        a3 = (int16_t )((int )a3 - sgn);
#line 304
        del0 -= 5 * (sgn * b3 >> denshift);
        }
#line 305
        if (del0 >= 0) {
#line 306
          goto while_continue___2;
        }
        {
#line 308
        __cil_tmp82 = sign_of_int(b2);
#line 308
        sgn = - __cil_tmp82;
#line 309
        a2 = (int16_t )((int )a2 - sgn);
#line 310
        del0 -= 6 * (sgn * b2 >> denshift);
        }
#line 311
        if (del0 >= 0) {
#line 312
          goto while_continue___2;
        }
        {
#line 314
        __cil_tmp83 = sign_of_int(b1);
#line 314
        sgn = - __cil_tmp83;
#line 315
        a1 = (int16_t )((int )a1 - sgn);
#line 316
        del0 -= 7 * (sgn * b1 >> denshift);
        }
#line 317
        if (del0 >= 0) {
#line 318
          goto while_continue___2;
        }
        {
#line 320
        __cil_tmp84 = sign_of_int(b0);
#line 320
        a0 = (int16_t )((int )a0 + __cil_tmp84);
        }
      }
#line 202
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___2: 
#line 324
    *(coefs + 0) = a0;
#line 325
    *(coefs + 1) = a1;
#line 326
    *(coefs + 2) = a2;
#line 327
    *(coefs + 3) = a3;
#line 328
    *(coefs + 4) = a4;
#line 329
    *(coefs + 5) = a5;
#line 330
    *(coefs + 6) = a6;
#line 331
    *(coefs + 7) = a7;
  } else {
#line 336
    j = lim;
    {
#line 336
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 336
      if (! (j < num)) {
#line 336
        goto while_break___3;
      }
#line 340
      sum1 = 0;
#line 341
      pout = (out + j) - 1;
#line 342
      top = *(out + (j - lim));
#line 344
      k = 0;
      {
#line 344
      while (1) {
        while_continue___7: /* CIL Label */ ;

#line 344
        if (! (k < numactive)) {
#line 344
          goto while_break___4;
        }
#line 345
        sum1 += (int )*(coefs + k) * (*(pout + - k) - top);
#line 344
        k ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___4: 
      {
#line 347
      del = *(pc1 + j);
#line 348
      del0 = del;
#line 349
      sg = sign_of_int(del);
#line 350
      del += top + ((sum1 + denhalf) >> denshift);
#line 351
      *(out + j) = (del << chanshift) >> chanshift;
      }
#line 353
      if (sg > 0) {
#line 355
        k = numactive - 1;
        {
#line 355
        while (1) {
          while_continue___8: /* CIL Label */ ;

#line 355
          if (! (k >= 0)) {
#line 355
            goto while_break___5;
          }
          {
#line 357
          dd = top - *(pout + - k);
#line 358
          sgn = sign_of_int(dd);
#line 359
          *(coefs + k) = (int16_t )((int )*(coefs + k) - sgn);
#line 360
          del0 -= (numactive - k) * (sgn * dd >> denshift);
          }
#line 361
          if (del0 <= 0) {
#line 362
            goto while_break___5;
          }
#line 355
          __cil_tmp89 = k;
#line 355
          k --;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: ;
      } else
#line 365
      if (sg < 0) {
#line 367
        k = numactive - 1;
        {
#line 367
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 367
          if (! (k >= 0)) {
#line 367
            goto while_break___6;
          }
          {
#line 369
          dd = top - *(pout + - k);
#line 370
          sgn = sign_of_int(dd);
#line 371
          *(coefs + k) = (int16_t )((int )*(coefs + k) + sgn);
#line 372
          del0 -= (numactive - k) * (- sgn * dd >> denshift);
          }
#line 373
          if (del0 >= 0) {
#line 374
            goto while_break___6;
          }
#line 367
          __cil_tmp91 = k;
#line 367
          k --;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: ;
      }
#line 336
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___3: ;
  }
#line 341
  return;
}
}
#line 577 "/usr/include/stdio.h"
__inline extern char *( __attribute__((__gnu_inline__)) gets)(char *__str ) ;
#line 229 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern char *__gets_chk(char *__str , size_t  ) ;
#line 230
extern char *__gets_warn(char *__str ) ;
#line 235 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__gnu_inline__)) gets)(char *__str ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 237
  __cil_tmp2 = __builtin_object_size((void *)__str, 1);
  }
#line 237
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 238
    __cil_tmp3 = __builtin_object_size((void *)__str, 1);
#line 238
    __cil_tmp4 = __gets_chk(__str, __cil_tmp3);
    }
#line 238
    return (__cil_tmp4);
  }
  {
#line 239
  __cil_tmp5 = __gets_warn(__str);
  }
#line 239
  return (__cil_tmp5);
}
}
#line 125 "/root/patchweave_new/23/src/ALAC/ALACAudioTypes.h"
static ALACChannelLayoutTag ALACChannelLayoutTags___2[8]  = 
#line 125 "/root/patchweave_new/23/src/ALAC/ALACAudioTypes.h"
  {      (ALACChannelLayoutTag )6553601,      (ALACChannelLayoutTag )6619138,      (ALACChannelLayoutTag )7405571,      (ALACChannelLayoutTag )7602180, 
        (ALACChannelLayoutTag )7864325,      (ALACChannelLayoutTag )8126470,      (ALACChannelLayoutTag )9306119,      (ALACChannelLayoutTag )8323080};
#line 70 "/root/patchweave_new/23/src/ALAC/aglib.h"
void set_standard_ag_params(AGParamRecPtr params , uint32_t fullwidth , uint32_t sectorwidth ) ;
#line 71
void set_ag_params(AGParamRecPtr params , uint32_t m , uint32_t p , uint32_t k , uint32_t f ,
                   uint32_t s , uint32_t maxrun ) ;
#line 73
int32_t dyn_comp(AGParamRecPtr params , int32_t *pc , BitBuffer *bitstream , int32_t numSamples ,
                 int32_t bitSize , uint32_t *outNumBits ) ;
#line 74
int32_t dyn_decomp(AGParamRecPtr params , BitBuffer *bitstream , int32_t *pc , int32_t numSamples ,
                   int32_t maxSize , uint32_t *outNumBits ) ;
#line 53 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
void GetConfig(ALAC_ENCODER *p , ALACSpecificConfig *config ) ;
#line 55
static int32_t EncodeStereo(ALAC_ENCODER *p , struct BitBuffer *bitstream , int32_t *inputBuffer ,
                            uint32_t stride , uint32_t channelIndex , uint32_t numSamples ) ;
#line 56
static int32_t EncodeStereoFast(ALAC_ENCODER *p , struct BitBuffer *bitstream , int32_t *inputBuffer ,
                                uint32_t stride , uint32_t channelIndex , uint32_t numSamples ) ;
#line 57
static int32_t EncodeStereoEscape(ALAC_ENCODER *p , struct BitBuffer *bitstream ,
                                  int32_t *inputBuffer , uint32_t stride , uint32_t numSamples ) ;
#line 58
static int32_t EncodeMono(ALAC_ENCODER *p , struct BitBuffer *bitstream , int32_t *inputBuffer ,
                          uint32_t stride , uint32_t channelIndex , uint32_t numSamples ) ;
#line 67 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
uint32_t kALACEncoderMagic  =    (unsigned int )((100 | (112 << 8)) | (103 << 16)) | (101U << 24);
#line 68 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
uint32_t kMaxSampleSize  =    (uint32_t )32;
#line 69 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
uint32_t kDefaultMixBits  =    (uint32_t )2;
#line 70 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
uint32_t kDefaultMixRes  =    (uint32_t )0;
#line 71 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
uint32_t kMaxRes  =    (uint32_t )4;
#line 72 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
uint32_t kDefaultNumUV  =    (uint32_t )8;
#line 73 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
uint32_t kMinUV  =    (uint32_t )4;
#line 74 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
uint32_t kMaxUV  =    (uint32_t )8;
#line 101 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
static uint32_t sChannelMaps[8]  = 
#line 101
  {      (uint32_t )0,      (uint32_t )1,      (uint32_t )(1 << 3),      (uint32_t )(1 << 3), 
        (uint32_t )((1 << 9) | (1 << 3)),      (uint32_t )((1 << 9) | (1 << 3)),      (uint32_t )((1 << 9) | (1 << 3)),      (uint32_t )(((1 << 15) | (1 << 9)) | (1 << 3))};
#line 118 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
void alac_set_fastmode(ALAC_ENCODER *p , int32_t fast ) 
{ 


  {
#line 120
  p->mFastMode = fast;
#line 121
  return;
}
}
#line 222 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
static int32_t EncodeStereo(ALAC_ENCODER *p , struct BitBuffer *bitstream , int32_t *inputBuffer ,
                            uint32_t stride , uint32_t channelIndex , uint32_t numSamples ) 
{ 
  BitBuffer workBits ;
  BitBuffer startBits ;
  AGParamRec agParams ;
  uint32_t bits1 ;
  uint32_t bits2 ;
  uint32_t dilate ;
  int32_t mixBits ;
  int32_t mixRes ;
  int32_t maxRes ;
  uint32_t minBits ;
  uint32_t minBits1 ;
  uint32_t minBits2 ;
  uint32_t numU ;
  uint32_t numV ;
  uint32_t mode ;
  uint32_t pbFactor ;
  uint32_t chanBits ;
  uint8_t bytesShifted ;
  SearchCoefs coefsU ;
  SearchCoefs coefsV ;
  uint32_t indx ;
  uint8_t partialFrame ;
  uint32_t escapeBits ;
  bool doEscape ;
  int32_t status ;
  int32_t bestRes ;
  int tmp ;
  uint32_t numUV ;
  uint32_t converge ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint32_t bitShift ;
  uint32_t shiftedVal ;
  uint32_t __cil_tmp51 ;
  uint32_t __cil_tmp52 ;

  {
#line 225
  startBits = *bitstream;
#line 242
  status = 0;
#line 246
  if (! ((int )p->mBitDepth == 16)) {
#line 246
    if (! ((int )p->mBitDepth == 20)) {
#line 246
      if (! ((int )p->mBitDepth == 24)) {
#line 246
        if (! ((int )p->mBitDepth == 32)) {
#line 246
          return (-50);
        }
      }
    }
  }
#line 253
  coefsU = p->mCoefsU[channelIndex];
#line 254
  coefsV = p->mCoefsV[channelIndex];
#line 259
  if ((int )p->mBitDepth == 32) {
#line 260
    bytesShifted = (uint8_t )2;
  } else
#line 261
  if ((int )p->mBitDepth >= 24) {
#line 262
    bytesShifted = (uint8_t )1;
  } else {
#line 264
    bytesShifted = (uint8_t )0;
  }
#line 266
  chanBits = (uint32_t )(((int )p->mBitDepth - (int )bytesShifted * 8) + 1);
#line 269
  if (numSamples == p->mFrameSize) {
#line 269
    tmp = 0;
  } else {
#line 269
    tmp = 1;
  }
#line 269
  partialFrame = (uint8_t )tmp;
#line 273
  mixBits = (int32_t )kDefaultMixBits;
#line 274
  maxRes = (int32_t )kMaxRes;
#line 275
  numV = kDefaultNumUV;
#line 275
  numU = numV;
#line 276
  mode = (uint32_t )0;
#line 277
  pbFactor = (uint32_t )4;
#line 278
  dilate = (uint32_t )8;
#line 280
  minBits2 = (uint32_t )(1UL << 31);
#line 280
  minBits1 = minBits2;
#line 280
  minBits = minBits1;
#line 282
  bestRes = (int32_t )p->mLastMixRes[channelIndex];
#line 284
  mixRes = 0;
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;

#line 284
    if (! (mixRes <= maxRes)) {
#line 284
      goto while_break;
    }
#line 289
    if ((int )p->mBitDepth == 16) {
#line 289
      goto case_16;
    }
#line 292
    if ((int )p->mBitDepth == 20) {
#line 292
      goto case_20;
    }
#line 295
    if ((int )p->mBitDepth == 24) {
#line 295
      goto case_24;
    }
#line 300
    if ((int )p->mBitDepth == 32) {
#line 300
      goto case_32;
    }
#line 287
    goto switch_break;
    case_16: 
    {
#line 290
    mix16(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )(numSamples / dilate),
          mixBits, mixRes);
    }
#line 291
    goto switch_break;
    case_20: 
    {
#line 293
    mix20(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )(numSamples / dilate),
          mixBits, mixRes);
    }
#line 294
    goto switch_break;
    case_24: 
    {
#line 297
    mix24(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )(numSamples / dilate),
          mixBits, mixRes, p->mShiftBufferUV, (int32_t )bytesShifted);
    }
#line 299
    goto switch_break;
    case_32: 
    {
#line 302
    mix32(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )(numSamples / dilate),
          mixBits, mixRes, p->mShiftBufferUV, (int32_t )bytesShifted);
    }
#line 304
    goto switch_break;
    switch_break: 
    {
#line 307
    BitBufferInit(& workBits, p->mWorkBuffer, p->mMaxOutputBytes);
#line 310
    pc_block(p->mMixBufferU, p->mPredictorU, (int32_t )(numSamples / dilate), *(coefsU + (numU - 1U)),
             (int32_t )numU, chanBits, (uint32_t )9);
#line 311
    pc_block(p->mMixBufferV, p->mPredictorV, (int32_t )(numSamples / dilate), *(coefsV + (numV - 1U)),
             (int32_t )numV, chanBits, (uint32_t )9);
#line 314
    set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14,
                  numSamples / dilate, numSamples / dilate, (uint32_t )255);
#line 315
    status = dyn_comp(& agParams, p->mPredictorU, & workBits, (int32_t )(numSamples / dilate),
                      (int32_t )chanBits, & bits1);
    }
#line 316
    if (status) {
#line 316
      goto Exit;
    }
    {
#line 318
    set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14,
                  numSamples / dilate, numSamples / dilate, (uint32_t )255);
#line 319
    status = dyn_comp(& agParams, p->mPredictorV, & workBits, (int32_t )(numSamples / dilate),
                      (int32_t )chanBits, & bits2);
    }
#line 320
    if (status) {
#line 320
      goto Exit;
    }
#line 323
    if (bits1 + bits2 < minBits1) {
#line 325
      minBits1 = bits1 + bits2;
#line 326
      bestRes = mixRes;
    }
#line 284
    mixRes ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
#line 330
  p->mLastMixRes[channelIndex] = (int16_t )bestRes;
#line 333
  mixRes = (int32_t )p->mLastMixRes[channelIndex];
#line 336
  if ((int )p->mBitDepth == 16) {
#line 336
    goto case_16___0;
  }
#line 339
  if ((int )p->mBitDepth == 20) {
#line 339
    goto case_20___0;
  }
#line 342
  if ((int )p->mBitDepth == 24) {
#line 342
    goto case_24___0;
  }
#line 347
  if ((int )p->mBitDepth == 32) {
#line 347
    goto case_32___0;
  }
#line 334
  goto switch_break___0;
  case_16___0: 
  {
#line 337
  mix16(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes);
  }
#line 338
  goto switch_break___0;
  case_20___0: 
  {
#line 340
  mix20(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes);
  }
#line 341
  goto switch_break___0;
  case_24___0: 
  {
#line 344
  mix24(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes, p->mShiftBufferUV, (int32_t )bytesShifted);
  }
#line 346
  goto switch_break___0;
  case_32___0: 
  {
#line 349
  mix32(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes, p->mShiftBufferUV, (int32_t )bytesShifted);
  }
#line 351
  goto switch_break___0;
  switch_break___0: 
#line 355
  numV = kMinUV;
#line 355
  numU = numV;
#line 356
  minBits2 = (uint32_t )(1UL << 31);
#line 356
  minBits1 = minBits2;
#line 358
  numUV = kMinUV;
  {
#line 358
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 358
    if (! (numUV <= kMaxUV)) {
#line 358
      goto while_break___0;
    }
    {
#line 360
    BitBufferInit(& workBits, p->mWorkBuffer, p->mMaxOutputBytes);
#line 362
    dilate = (uint32_t )32;
#line 365
    converge = (uint32_t )0;
    }
    {
#line 365
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 365
      if (! (converge < 8U)) {
#line 365
        goto while_break___1;
      }
      {
#line 367
      pc_block(p->mMixBufferU, p->mPredictorU, (int32_t )(numSamples / dilate), *(coefsU + (numUV - 1U)),
               (int32_t )numUV, chanBits, (uint32_t )9);
#line 368
      pc_block(p->mMixBufferV, p->mPredictorV, (int32_t )(numSamples / dilate), *(coefsV + (numUV - 1U)),
               (int32_t )numUV, chanBits, (uint32_t )9);
#line 365
      converge ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 371
    dilate = (uint32_t )8;
#line 373
    set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14,
                  numSamples / dilate, numSamples / dilate, (uint32_t )255);
#line 374
    status = dyn_comp(& agParams, p->mPredictorU, & workBits, (int32_t )(numSamples / dilate),
                      (int32_t )chanBits, & bits1);
    }
#line 376
    if (bits1 * dilate + 16U * numUV < minBits1) {
#line 378
      minBits1 = bits1 * dilate + 16U * numUV;
#line 379
      numU = numUV;
    }
    {
#line 382
    set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14,
                  numSamples / dilate, numSamples / dilate, (uint32_t )255);
#line 383
    status = dyn_comp(& agParams, p->mPredictorV, & workBits, (int32_t )(numSamples / dilate),
                      (int32_t )chanBits, & bits2);
    }
#line 385
    if (bits2 * dilate + 16U * numUV < minBits2) {
#line 387
      minBits2 = bits2 * dilate + 16U * numUV;
#line 388
      numV = numUV;
    }
#line 358
    numUV += 4U;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: ;
#line 393
  if ((int )partialFrame == 1) {
#line 393
    tmp___0 = 32;
  } else {
#line 393
    tmp___0 = 0;
  }
#line 393
  minBits = ((minBits1 + minBits2) + 64U) + (unsigned int )tmp___0;
#line 394
  if ((int )bytesShifted != 0) {
#line 395
    minBits += (numSamples * (unsigned int )((int )bytesShifted * 8)) * 2U;
  }
#line 397
  if ((int )partialFrame == 1) {
#line 397
    tmp___1 = 32;
  } else {
#line 397
    tmp___1 = 0;
  }
#line 397
  escapeBits = ((numSamples * (unsigned int )p->mBitDepth) * 2U + (unsigned int )tmp___1) + 16U;
#line 399
  if (minBits >= escapeBits) {
#line 399
    tmp___2 = 1;
  } else {
#line 399
    tmp___2 = 0;
  }
#line 399
  doEscape = (bool )tmp___2;
#line 401
  if ((unsigned int )doEscape == 0U) {
    {
#line 404
    BitBufferWrite(bitstream, (uint32_t )0, (uint32_t )12);
#line 405
    BitBufferWrite(bitstream, (uint32_t )(((int )partialFrame << 3) | ((int )bytesShifted << 1)),
                   (uint32_t )4);
    }
#line 406
    if (partialFrame) {
      {
#line 407
      BitBufferWrite(bitstream, numSamples, (uint32_t )32);
      }
    }
    {
#line 408
    BitBufferWrite(bitstream, (uint32_t )mixBits, (uint32_t )8);
#line 409
    BitBufferWrite(bitstream, (uint32_t )mixRes, (uint32_t )8);
#line 415
    BitBufferWrite(bitstream, (mode << 4) | 9U, (uint32_t )8);
#line 416
    BitBufferWrite(bitstream, (pbFactor << 5) | numU, (uint32_t )8);
#line 417
    indx = (uint32_t )0;
    }
    {
#line 417
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 417
      if (! (indx < numU)) {
#line 417
        goto while_break___2;
      }
      {
#line 418
      BitBufferWrite(bitstream, (uint32_t )(*(coefsU + (numU - 1U)))[indx], (uint32_t )16);
#line 417
      indx ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 420
    BitBufferWrite(bitstream, (mode << 4) | 9U, (uint32_t )8);
#line 421
    BitBufferWrite(bitstream, (pbFactor << 5) | numV, (uint32_t )8);
#line 422
    indx = (uint32_t )0;
    }
    {
#line 422
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 422
      if (! (indx < numV)) {
#line 422
        goto while_break___3;
      }
      {
#line 423
      BitBufferWrite(bitstream, (uint32_t )(*(coefsV + (numV - 1U)))[indx], (uint32_t )16);
#line 422
      indx ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: ;
#line 426
    if ((int )bytesShifted != 0) {
#line 428
      bitShift = (uint32_t )((int )bytesShifted * 8);
#line 432
      indx = (uint32_t )0;
      {
#line 432
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 432
        if (! (indx < numSamples * 2U)) {
#line 432
          goto while_break___4;
        }
        {
#line 436
        shiftedVal = ((uint32_t )p->mShiftBufferUV[indx] << bitShift) | (uint32_t )p->mShiftBufferUV[indx + 1U];
#line 437
        BitBufferWrite(bitstream, shiftedVal, bitShift * 2U);
#line 432
        indx += 2U;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: ;
    }
#line 444
    if (mode == 0U) {
      {
#line 446
      pc_block(p->mMixBufferU, p->mPredictorU, (int32_t )numSamples, *(coefsU + (numU - 1U)),
               (int32_t )numU, chanBits, (uint32_t )9);
      }
    } else {
      {
#line 450
      pc_block(p->mMixBufferU, p->mPredictorV, (int32_t )numSamples, *(coefsU + (numU - 1U)),
               (int32_t )numU, chanBits, (uint32_t )9);
#line 451
      pc_block(p->mPredictorV, p->mPredictorU, (int32_t )numSamples, (int16_t *)((void *)0),
               31, chanBits, (uint32_t )0);
      }
    }
    {
#line 454
    set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14,
                  numSamples, numSamples, (uint32_t )255);
#line 455
    status = dyn_comp(& agParams, p->mPredictorU, bitstream, (int32_t )numSamples,
                      (int32_t )chanBits, & bits1);
    }
#line 456
    if (status) {
#line 456
      goto Exit;
    }
#line 459
    if (mode == 0U) {
      {
#line 461
      pc_block(p->mMixBufferV, p->mPredictorV, (int32_t )numSamples, *(coefsV + (numV - 1U)),
               (int32_t )numV, chanBits, (uint32_t )9);
      }
    } else {
      {
#line 465
      pc_block(p->mMixBufferV, p->mPredictorU, (int32_t )numSamples, *(coefsV + (numV - 1U)),
               (int32_t )numV, chanBits, (uint32_t )9);
#line 466
      pc_block(p->mPredictorU, p->mPredictorV, (int32_t )numSamples, (int16_t *)((void *)0),
               31, chanBits, (uint32_t )0);
      }
    }
    {
#line 469
    set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14,
                  numSamples, numSamples, (uint32_t )255);
#line 470
    status = dyn_comp(& agParams, p->mPredictorV, bitstream, (int32_t )numSamples,
                      (int32_t )chanBits, & bits2);
    }
#line 471
    if (status) {
#line 471
      goto Exit;
    }
    {
#line 476
    __cil_tmp52 = BitBufferGetPosition(& startBits);
#line 476
    __cil_tmp51 = BitBufferGetPosition(bitstream);
#line 476
    minBits = __cil_tmp51 - __cil_tmp52;
    }
#line 477
    if (minBits >= escapeBits) {
      {
#line 479
      *bitstream = startBits;
#line 480
      doEscape = (bool )1;
#line 481
      printf("compressed frame too big: %u vs. %u \n", minBits, escapeBits);
      }
    }
  }
#line 485
  if ((unsigned int )doEscape == 1U) {
    {
#line 488
    status = EncodeStereoEscape(p, bitstream, inputBuffer, stride, numSamples);
    }
  }
  Exit: 
#line 496
  return (status);
}
}
#line 504 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
static int32_t EncodeStereoFast(ALAC_ENCODER *p , struct BitBuffer *bitstream , int32_t *inputBuffer ,
                                uint32_t stride , uint32_t channelIndex , uint32_t numSamples ) 
{ 
  BitBuffer startBits ;
  AGParamRec agParams ;
  uint32_t bits1 ;
  uint32_t bits2 ;
  int32_t mixBits ;
  int32_t mixRes ;
  uint32_t minBits ;
  uint32_t minBits1 ;
  uint32_t minBits2 ;
  uint32_t numU ;
  uint32_t numV ;
  uint32_t mode ;
  uint32_t pbFactor ;
  uint32_t chanBits ;
  uint8_t bytesShifted ;
  SearchCoefs coefsU ;
  SearchCoefs coefsV ;
  uint32_t indx ;
  uint8_t partialFrame ;
  uint32_t escapeBits ;
  bool doEscape ;
  int32_t status ;
  int tmp ;
  uint32_t bitShift ;
  uint32_t shiftedVal ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint32_t __cil_tmp39 ;
  uint32_t __cil_tmp40 ;

  {
#line 506
  startBits = *bitstream;
#line 525
  if (! ((int )p->mBitDepth == 16)) {
#line 525
    if (! ((int )p->mBitDepth == 20)) {
#line 525
      if (! ((int )p->mBitDepth == 24)) {
#line 525
        if (! ((int )p->mBitDepth == 32)) {
#line 525
          return (-50);
        }
      }
    }
  }
#line 532
  coefsU = p->mCoefsU[channelIndex];
#line 533
  coefsV = p->mCoefsV[channelIndex];
#line 538
  if ((int )p->mBitDepth == 32) {
#line 539
    bytesShifted = (uint8_t )2;
  } else
#line 540
  if ((int )p->mBitDepth >= 24) {
#line 541
    bytesShifted = (uint8_t )1;
  } else {
#line 543
    bytesShifted = (uint8_t )0;
  }
#line 545
  chanBits = (uint32_t )(((int )p->mBitDepth - (int )bytesShifted * 8) + 1);
#line 548
  if (numSamples == p->mFrameSize) {
#line 548
    tmp = 0;
  } else {
#line 548
    tmp = 1;
  }
#line 548
  partialFrame = (uint8_t )tmp;
#line 551
  mixBits = (int32_t )kDefaultMixBits;
#line 552
  mixRes = (int32_t )kDefaultMixRes;
#line 553
  numV = kDefaultNumUV;
#line 553
  numU = numV;
#line 554
  mode = (uint32_t )0;
#line 555
  pbFactor = (uint32_t )4;
#line 557
  minBits2 = (uint32_t )(1UL << 31);
#line 557
  minBits1 = minBits2;
#line 557
  minBits = minBits1;
#line 562
  if ((int )p->mBitDepth == 16) {
#line 562
    goto case_16;
  }
#line 565
  if ((int )p->mBitDepth == 20) {
#line 565
    goto case_20;
  }
#line 568
  if ((int )p->mBitDepth == 24) {
#line 568
    goto case_24;
  }
#line 573
  if ((int )p->mBitDepth == 32) {
#line 573
    goto case_32;
  }
#line 560
  goto switch_break;
  case_16: 
  {
#line 563
  mix16(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes);
  }
#line 564
  goto switch_break;
  case_20: 
  {
#line 566
  mix20(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes);
  }
#line 567
  goto switch_break;
  case_24: 
  {
#line 570
  mix24(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes, p->mShiftBufferUV, (int32_t )bytesShifted);
  }
#line 572
  goto switch_break;
  case_32: 
  {
#line 575
  mix32(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes, p->mShiftBufferUV, (int32_t )bytesShifted);
  }
#line 577
  goto switch_break;
  switch_break: 
  {
#line 583
  BitBufferWrite(bitstream, (uint32_t )0, (uint32_t )12);
#line 584
  BitBufferWrite(bitstream, (uint32_t )(((int )partialFrame << 3) | ((int )bytesShifted << 1)),
                 (uint32_t )4);
  }
#line 585
  if (partialFrame) {
    {
#line 586
    BitBufferWrite(bitstream, numSamples, (uint32_t )32);
    }
  }
  {
#line 587
  BitBufferWrite(bitstream, (uint32_t )mixBits, (uint32_t )8);
#line 588
  BitBufferWrite(bitstream, (uint32_t )mixRes, (uint32_t )8);
#line 594
  BitBufferWrite(bitstream, (mode << 4) | 9U, (uint32_t )8);
#line 595
  BitBufferWrite(bitstream, (pbFactor << 5) | numU, (uint32_t )8);
#line 596
  indx = (uint32_t )0;
  }
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;

#line 596
    if (! (indx < numU)) {
#line 596
      goto while_break;
    }
    {
#line 597
    BitBufferWrite(bitstream, (uint32_t )(*(coefsU + (numU - 1U)))[indx], (uint32_t )16);
#line 596
    indx ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 599
  BitBufferWrite(bitstream, (mode << 4) | 9U, (uint32_t )8);
#line 600
  BitBufferWrite(bitstream, (pbFactor << 5) | numV, (uint32_t )8);
#line 601
  indx = (uint32_t )0;
  }
  {
#line 601
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 601
    if (! (indx < numV)) {
#line 601
      goto while_break___0;
    }
    {
#line 602
    BitBufferWrite(bitstream, (uint32_t )(*(coefsV + (numV - 1U)))[indx], (uint32_t )16);
#line 601
    indx ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 605
  if ((int )bytesShifted != 0) {
#line 607
    bitShift = (uint32_t )((int )bytesShifted * 8);
#line 611
    indx = (uint32_t )0;
    {
#line 611
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 611
      if (! (indx < numSamples * 2U)) {
#line 611
        goto while_break___1;
      }
      {
#line 615
      shiftedVal = ((uint32_t )p->mShiftBufferUV[indx] << bitShift) | (uint32_t )p->mShiftBufferUV[indx + 1U];
#line 616
      BitBufferWrite(bitstream, shiftedVal, bitShift * 2U);
#line 611
      indx += 2U;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
  {
#line 622
  pc_block(p->mMixBufferU, p->mPredictorU, (int32_t )numSamples, *(coefsU + (numU - 1U)),
           (int32_t )numU, chanBits, (uint32_t )9);
#line 624
  set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14, numSamples,
                numSamples, (uint32_t )255);
#line 625
  status = dyn_comp(& agParams, p->mPredictorU, bitstream, (int32_t )numSamples, (int32_t )chanBits,
                    & bits1);
  }
#line 626
  if (status) {
#line 626
    goto Exit;
  }
  {
#line 629
  pc_block(p->mMixBufferV, p->mPredictorV, (int32_t )numSamples, *(coefsV + (numV - 1U)),
           (int32_t )numV, chanBits, (uint32_t )9);
#line 631
  set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14, numSamples,
                numSamples, (uint32_t )255);
#line 632
  status = dyn_comp(& agParams, p->mPredictorV, bitstream, (int32_t )numSamples, (int32_t )chanBits,
                    & bits2);
  }
#line 633
  if (status) {
#line 633
    goto Exit;
  }
#line 636
  minBits1 = (uint32_t )((unsigned long )bits1 + ((unsigned long )numU * sizeof(int16_t )) * 8UL);
#line 637
  minBits2 = (uint32_t )((unsigned long )bits2 + ((unsigned long )numV * sizeof(int16_t )) * 8UL);
#line 640
  if ((int )partialFrame == 1) {
#line 640
    tmp___0 = 32;
  } else {
#line 640
    tmp___0 = 0;
  }
#line 640
  minBits = ((minBits1 + minBits2) + 64U) + (unsigned int )tmp___0;
#line 641
  if ((int )bytesShifted != 0) {
#line 642
    minBits += (numSamples * (unsigned int )((int )bytesShifted * 8)) * 2U;
  }
#line 644
  if ((int )partialFrame == 1) {
#line 644
    tmp___1 = 32;
  } else {
#line 644
    tmp___1 = 0;
  }
#line 644
  escapeBits = ((numSamples * (unsigned int )p->mBitDepth) * 2U + (unsigned int )tmp___1) + 16U;
#line 646
  if (minBits >= escapeBits) {
#line 646
    tmp___2 = 1;
  } else {
#line 646
    tmp___2 = 0;
  }
#line 646
  doEscape = (bool )tmp___2;
#line 648
  if ((unsigned int )doEscape == 0U) {
    {
#line 653
    __cil_tmp40 = BitBufferGetPosition(& startBits);
#line 653
    __cil_tmp39 = BitBufferGetPosition(bitstream);
#line 653
    minBits = __cil_tmp39 - __cil_tmp40;
    }
#line 654
    if (minBits >= escapeBits) {
      {
#line 656
      doEscape = (bool )1;
#line 657
      printf("compressed frame too big: %u vs. %u\n\270U", minBits, escapeBits);
      }
    }
  }
#line 662
  if ((unsigned int )doEscape == 1U) {
    {
#line 667
    *bitstream = startBits;
#line 670
    status = EncodeStereoEscape(p, bitstream, inputBuffer, stride, numSamples);
    }
  }
  Exit: 
#line 678
  return (status);
}
}
#line 686 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
static int32_t EncodeStereoEscape(ALAC_ENCODER *p , struct BitBuffer *bitstream ,
                                  int32_t *inputBuffer , uint32_t stride , uint32_t numSamples ) 
{ 
  uint8_t partialFrame ;
  uint32_t indx ;
  int tmp ;

  {
#line 692
  if (numSamples == p->mFrameSize) {
#line 692
    tmp = 0;
  } else {
#line 692
    tmp = 1;
  }
  {
#line 692
  partialFrame = (uint8_t )tmp;
#line 695
  BitBufferWrite(bitstream, (uint32_t )0, (uint32_t )12);
#line 696
  BitBufferWrite(bitstream, (uint32_t )(((int )partialFrame << 3) | 1), (uint32_t )4);
  }
#line 697
  if (partialFrame) {
    {
#line 698
    BitBufferWrite(bitstream, numSamples, (uint32_t )32);
    }
  }
#line 703
  if ((int )p->mBitDepth == 16) {
#line 703
    goto case_16;
  }
#line 710
  if ((int )p->mBitDepth == 20) {
#line 710
    goto case_20;
  }
#line 717
  if ((int )p->mBitDepth == 24) {
#line 717
    goto case_24;
  }
#line 726
  if ((int )p->mBitDepth == 32) {
#line 726
    goto case_32;
  }
#line 701
  goto switch_break;
  case_16: 
#line 704
  indx = (uint32_t )0;
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;

#line 704
    if (! (indx < numSamples * stride)) {
#line 704
      goto while_break;
    }
    {
#line 706
    BitBufferWrite(bitstream, (uint32_t )(*(inputBuffer + indx) >> 16), (uint32_t )16);
#line 707
    BitBufferWrite(bitstream, (uint32_t )(*(inputBuffer + (indx + 1U)) >> 16), (uint32_t )16);
#line 704
    indx += stride;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 709
  goto switch_break;
  case_20: 
#line 711
  indx = (uint32_t )0;
  {
#line 711
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 711
    if (! (indx < numSamples * stride)) {
#line 711
      goto while_break___0;
    }
    {
#line 713
    BitBufferWrite(bitstream, (uint32_t )(*(inputBuffer + indx) >> 12), (uint32_t )16);
#line 714
    BitBufferWrite(bitstream, (uint32_t )(*(inputBuffer + (indx + 1U)) >> 12), (uint32_t )16);
#line 711
    indx += stride;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: ;
#line 716
  goto switch_break;
  case_24: 
  {
#line 719
  mix24(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        0, 0, p->mShiftBufferUV, 0);
#line 720
  indx = (uint32_t )0;
  }
  {
#line 720
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 720
    if (! (indx < numSamples)) {
#line 720
      goto while_break___1;
    }
    {
#line 722
    BitBufferWrite(bitstream, (uint32_t )(p->mMixBufferU[indx] >> 8), (uint32_t )24);
#line 723
    BitBufferWrite(bitstream, (uint32_t )(p->mMixBufferV[indx] >> 8), (uint32_t )24);
#line 720
    indx ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 725
  goto switch_break;
  case_32: 
#line 727
  indx = (uint32_t )0;
  {
#line 727
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 727
    if (! (indx < numSamples * stride)) {
#line 727
      goto while_break___2;
    }
    {
#line 729
    BitBufferWrite(bitstream, (uint32_t )*(inputBuffer + indx), (uint32_t )32);
#line 730
    BitBufferWrite(bitstream, (uint32_t )*(inputBuffer + (indx + 1U)), (uint32_t )32);
#line 727
    indx += stride;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 732
  goto switch_break;
  switch_break: ;
#line 735
  return (0);
}
}
#line 743 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
static int32_t EncodeMono(ALAC_ENCODER *p , struct BitBuffer *bitstream , int32_t *inputBuffer ,
                          uint32_t stride , uint32_t channelIndex , uint32_t numSamples ) 
{ 
  BitBuffer startBits ;
  AGParamRec agParams ;
  uint32_t bits1 ;
  uint32_t numU ;
  SearchCoefs coefsU ;
  uint32_t dilate ;
  uint32_t minBits ;
  uint32_t bestU ;
  uint32_t minU ;
  uint32_t maxU ;
  uint32_t indx ;
  uint32_t indx2 ;
  uint8_t bytesShifted ;
  uint32_t shift ;
  uint32_t mask ;
  uint32_t chanBits ;
  uint8_t pbFactor ;
  uint8_t partialFrame ;
  uint32_t escapeBits ;
  bool doEscape ;
  int32_t status ;
  int tmp ;
  uint32_t __cil_tmp29 ;
  uint32_t __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  BitBuffer workBits ;
  uint32_t numBits ;
  uint32_t converge ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint32_t __cil_tmp44 ;
  uint32_t __cil_tmp45 ;
  uint32_t __cil_tmp46 ;

  {
#line 745
  startBits = *bitstream;
#line 762
  status = 0;
#line 766
  if (! ((int )p->mBitDepth == 16)) {
#line 766
    if (! ((int )p->mBitDepth == 20)) {
#line 766
      if (! ((int )p->mBitDepth == 24)) {
#line 766
        if (! ((int )p->mBitDepth == 32)) {
#line 766
          return (-50);
        }
      }
    }
  }
#line 769
  coefsU = p->mCoefsU[channelIndex];
#line 773
  if ((int )p->mBitDepth == 32) {
#line 774
    bytesShifted = (uint8_t )2;
  } else
#line 775
  if ((int )p->mBitDepth >= 24) {
#line 776
    bytesShifted = (uint8_t )1;
  } else {
#line 778
    bytesShifted = (uint8_t )0;
  }
#line 780
  shift = (uint32_t )((int )bytesShifted * 8);
#line 781
  mask = (uint32_t )((1UL << shift) - 1UL);
#line 782
  chanBits = (uint32_t )((int )p->mBitDepth - (int )bytesShifted * 8);
#line 785
  if (numSamples == p->mFrameSize) {
#line 785
    tmp = 0;
  } else {
#line 785
    tmp = 1;
  }
#line 785
  partialFrame = (uint8_t )tmp;
#line 790
  if ((int )p->mBitDepth == 16) {
#line 790
    goto case_16;
  }
#line 796
  if ((int )p->mBitDepth == 20) {
#line 796
    goto case_20;
  }
#line 801
  if ((int )p->mBitDepth == 24) {
#line 801
    goto case_24;
  }
#line 811
  if ((int )p->mBitDepth == 32) {
#line 811
    goto case_32;
  }
#line 788
  goto switch_break;
  case_16: 
#line 792
  indx2 = (uint32_t )0;
#line 792
  indx = (uint32_t )0;
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;

#line 792
    if (! (indx < numSamples)) {
#line 792
      goto while_break;
    }
#line 793
    p->mMixBufferU[indx] = *(inputBuffer + indx2) >> 16;
#line 792
    indx2 += stride;
#line 792
    __cil_tmp29 = indx;
#line 792
    indx ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break: ;
#line 794
  goto switch_break;
  case_20: 
#line 798
  indx2 = (uint32_t )0;
#line 798
  indx = (uint32_t )0;
  {
#line 798
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 798
    if (! (indx < numSamples)) {
#line 798
      goto while_break___0;
    }
#line 799
    p->mMixBufferU[indx] = *(inputBuffer + indx2) >> 12;
#line 798
    indx2 += stride;
#line 798
    __cil_tmp30 = indx;
#line 798
    indx ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___0: ;
#line 800
  goto switch_break;
  case_24: 
#line 803
  indx2 = (uint32_t )0;
#line 803
  indx = (uint32_t )0;
  {
#line 803
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 803
    if (! (indx < numSamples)) {
#line 803
      goto while_break___1;
    }
#line 805
    p->mMixBufferU[indx] = *(inputBuffer + indx2) >> 8;
#line 806
    p->mShiftBufferUV[indx] = (uint16_t )((unsigned int )p->mMixBufferU[indx] & mask);
#line 807
    p->mMixBufferU[indx] >>= shift;
#line 803
    indx2 += stride;
#line 803
    __cil_tmp31 = indx;
#line 803
    indx ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___1: ;
#line 810
  goto switch_break;
  case_32: 
#line 813
  indx2 = (uint32_t )0;
#line 813
  indx = (uint32_t )0;
  {
#line 813
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 813
    if (! (indx < numSamples)) {
#line 813
      goto while_break___2;
    }
#line 815
    p->mShiftBufferUV[indx] = (uint16_t )((unsigned int )*(inputBuffer + indx2) & mask);
#line 816
    p->mMixBufferU[indx] = *(inputBuffer + indx2) >> shift;
#line 813
    indx2 += stride;
#line 813
    __cil_tmp32 = indx;
#line 813
    indx ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___2: ;
#line 818
  goto switch_break;
  switch_break: 
#line 823
  minU = (uint32_t )4;
#line 824
  maxU = (uint32_t )8;
#line 825
  minBits = (uint32_t )(1UL << 31);
#line 826
  pbFactor = (uint8_t )4;
#line 828
  bestU = minU;
#line 830
  numU = minU;
  {
#line 830
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 830
    if (! (numU <= maxU)) {
#line 830
      goto while_break___3;
    }
    {
#line 835
    BitBufferInit(& workBits, p->mWorkBuffer, p->mMaxOutputBytes);
#line 837
    dilate = (uint32_t )32;
#line 838
    converge = (uint32_t )0;
    }
    {
#line 838
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 838
      if (! (converge < 7U)) {
#line 838
        goto while_break___4;
      }
      {
#line 839
      pc_block(p->mMixBufferU, p->mPredictorU, (int32_t )(numSamples / dilate), *(coefsU + (numU - 1U)),
               (int32_t )numU, chanBits, (uint32_t )9);
#line 838
      converge ++;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___4: 
    {
#line 841
    dilate = (uint32_t )8;
#line 842
    pc_block(p->mMixBufferU, p->mPredictorU, (int32_t )(numSamples / dilate), *(coefsU + (numU - 1U)),
             (int32_t )numU, chanBits, (uint32_t )9);
#line 844
    set_ag_params(& agParams, (uint32_t )10, (uint32_t )(((int )pbFactor * 40) / 4),
                  (uint32_t )14, numSamples / dilate, numSamples / dilate, (uint32_t )255);
#line 845
    status = dyn_comp(& agParams, p->mPredictorU, & workBits, (int32_t )(numSamples / dilate),
                      (int32_t )chanBits, & bits1);
    }
#line 846
    if (status) {
#line 846
      goto Exit;
    }
#line 848
    numBits = dilate * bits1 + 16U * numU;
#line 849
    if (numBits < minBits) {
#line 851
      bestU = numU;
#line 852
      minBits = numBits;
    }
#line 830
    numU += 4U;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___3: ;
#line 858
  if ((int )partialFrame == 1) {
#line 858
    tmp___0 = 32;
  } else {
#line 858
    tmp___0 = 0;
  }
#line 858
  minBits += (unsigned int )(32 + tmp___0);
#line 859
  if ((int )bytesShifted != 0) {
#line 860
    minBits += numSamples * (unsigned int )((int )bytesShifted * 8);
  }
#line 862
  if ((int )partialFrame == 1) {
#line 862
    tmp___1 = 32;
  } else {
#line 862
    tmp___1 = 0;
  }
#line 862
  escapeBits = (numSamples * (unsigned int )p->mBitDepth + (unsigned int )tmp___1) + 16U;
#line 864
  if (minBits >= escapeBits) {
#line 864
    tmp___2 = 1;
  } else {
#line 864
    tmp___2 = 0;
  }
#line 864
  doEscape = (bool )tmp___2;
#line 866
  if ((unsigned int )doEscape == 0U) {
    {
#line 869
    BitBufferWrite(bitstream, (uint32_t )0, (uint32_t )12);
#line 870
    BitBufferWrite(bitstream, (uint32_t )(((int )partialFrame << 3) | ((int )bytesShifted << 1)),
                   (uint32_t )4);
    }
#line 871
    if (partialFrame) {
      {
#line 872
      BitBufferWrite(bitstream, numSamples, (uint32_t )32);
      }
    }
    {
#line 873
    BitBufferWrite(bitstream, (uint32_t )0, (uint32_t )16);
#line 876
    numU = bestU;
#line 877
    BitBufferWrite(bitstream, (uint32_t )9, (uint32_t )8);
#line 878
    BitBufferWrite(bitstream, (unsigned int )((int )pbFactor << 5) | numU, (uint32_t )8);
#line 879
    indx = (uint32_t )0;
    }
    {
#line 879
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 879
      if (! (indx < numU)) {
#line 879
        goto while_break___5;
      }
      {
#line 880
      BitBufferWrite(bitstream, (uint32_t )(*(coefsU + (numU - 1U)))[indx], (uint32_t )16);
#line 879
      indx ++;
      }
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___5: ;
#line 883
    if ((int )bytesShifted != 0) {
#line 885
      indx = (uint32_t )0;
      {
#line 885
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 885
        if (! (indx < numSamples)) {
#line 885
          goto while_break___6;
        }
        {
#line 886
        BitBufferWrite(bitstream, (uint32_t )p->mShiftBufferUV[indx], shift);
#line 885
        indx ++;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
      while_break___6: ;
    }
    {
#line 890
    pc_block(p->mMixBufferU, p->mPredictorU, (int32_t )numSamples, *(coefsU + (numU - 1U)),
             (int32_t )numU, chanBits, (uint32_t )9);
#line 893
    set_standard_ag_params(& agParams, numSamples, numSamples);
#line 894
    status = dyn_comp(& agParams, p->mPredictorU, bitstream, (int32_t )numSamples,
                      (int32_t )chanBits, & bits1);
#line 901
    __cil_tmp45 = BitBufferGetPosition(& startBits);
#line 901
    __cil_tmp44 = BitBufferGetPosition(bitstream);
#line 901
    minBits = __cil_tmp44 - __cil_tmp45;
    }
#line 902
    if (minBits >= escapeBits) {
      {
#line 904
      *bitstream = startBits;
#line 905
      doEscape = (bool )1;
#line 906
      printf("compressed frame too big: %u vs. %u\n", minBits, escapeBits);
      }
    }
  }
#line 910
  if ((unsigned int )doEscape == 1U) {
    {
#line 913
    BitBufferWrite(bitstream, (uint32_t )0, (uint32_t )12);
#line 914
    BitBufferWrite(bitstream, (uint32_t )(((int )partialFrame << 3) | 1), (uint32_t )4);
    }
#line 915
    if (partialFrame) {
      {
#line 916
      BitBufferWrite(bitstream, numSamples, (uint32_t )32);
      }
    }
#line 921
    if ((int )p->mBitDepth == 16) {
#line 921
      goto case_16___0;
    }
#line 925
    if ((int )p->mBitDepth == 20) {
#line 925
      goto case_20___0;
    }
#line 930
    if ((int )p->mBitDepth == 24) {
#line 930
      goto case_24___0;
    }
#line 938
    if ((int )p->mBitDepth == 32) {
#line 938
      goto case_32___0;
    }
#line 919
    goto switch_break___0;
    case_16___0: 
#line 922
    indx = (uint32_t )0;
    {
#line 922
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 922
      if (! (indx < numSamples * stride)) {
#line 922
        goto while_break___7;
      }
      {
#line 923
      BitBufferWrite(bitstream, (uint32_t )(*(inputBuffer + indx) >> 16), (uint32_t )16);
#line 922
      indx += stride;
      }
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___7: ;
#line 924
    goto switch_break___0;
    case_20___0: 
#line 927
    indx = (uint32_t )0;
    {
#line 927
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 927
      if (! (indx < numSamples * stride)) {
#line 927
        goto while_break___8;
      }
      {
#line 928
      BitBufferWrite(bitstream, (uint32_t )(*(inputBuffer + indx) >> 12), (uint32_t )20);
#line 927
      indx += stride;
      }
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___8: ;
#line 929
    goto switch_break___0;
    case_24___0: 
#line 932
    indx2 = (uint32_t )0;
#line 932
    indx = (uint32_t )0;
    {
#line 932
    while (1) {
      while_continue___9: /* CIL Label */ ;

#line 932
      if (! (indx < numSamples)) {
#line 932
        goto while_break___9;
      }
      {
#line 934
      p->mMixBufferU[indx] = *(inputBuffer + indx2) >> 8;
#line 935
      BitBufferWrite(bitstream, (uint32_t )p->mMixBufferU[indx], (uint32_t )24);
#line 932
      indx2 += stride;
#line 932
      __cil_tmp46 = indx;
#line 932
      indx ++;
      }
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___9: ;
#line 937
    goto switch_break___0;
    case_32___0: 
#line 939
    indx = (uint32_t )0;
    {
#line 939
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 939
      if (! (indx < numSamples * stride)) {
#line 939
        goto while_break___10;
      }
      {
#line 940
      BitBufferWrite(bitstream, (uint32_t )*(inputBuffer + indx), (uint32_t )32);
#line 939
      indx += stride;
      }
    }
    while_break___22: /* CIL Label */ ;
    }
    while_break___10: ;
#line 941
    goto switch_break___0;
    switch_break___0: ;
  }
  Exit: 
#line 949
  return (status);
}
}
#line 961 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
int32_t alac_encode(ALAC_ENCODER *p , uint32_t numSamples , int32_t *theReadBuffer ,
                    unsigned char *theWriteBuffer , uint32_t *ioNumBytes ) 
{ 
  uint32_t outputSize ;
  BitBuffer bitstream ;
  int32_t status ;
  uint32_t numChannels ;
  int32_t *inputBuffer ;
  uint32_t tag ;
  uint32_t channelIndex ;
  uint8_t stereoElementTag ;
  uint8_t monoElementTag ;
  uint8_t lfeElementTag ;
  uint32_t __cil_tmp27 ;
  uint32_t tmp ;

  {
#line 967
  numChannels = p->mNumChannels;
#line 970
  if (! ((int )p->mBitDepth == 16)) {
#line 970
    if (! ((int )p->mBitDepth == 20)) {
#line 970
      if (! ((int )p->mBitDepth == 24)) {
#line 970
        if (! ((int )p->mBitDepth == 32)) {
#line 970
          return (-50);
        }
      }
    }
  }
  {
#line 973
  BitBufferInit(& bitstream, theWriteBuffer, p->mMaxOutputBytes);
  }
#line 975
  if (numChannels == 2U) {
    {
#line 978
    BitBufferWrite(& bitstream, (uint32_t )1, (uint32_t )3);
#line 979
    BitBufferWrite(& bitstream, (uint32_t )0, (uint32_t )4);
    }
#line 982
    if (p->mFastMode == 0) {
      {
#line 983
      status = EncodeStereo(p, & bitstream, theReadBuffer, (uint32_t )2, (uint32_t )0,
                            numSamples);
      }
    } else {
      {
#line 985
      status = EncodeStereoFast(p, & bitstream, theReadBuffer, (uint32_t )2, (uint32_t )0,
                                numSamples);
      }
    }
#line 986
    if (status) {
#line 986
      goto Exit;
    }
  } else
#line 988
  if (numChannels == 1U) {
    {
#line 991
    BitBufferWrite(& bitstream, (uint32_t )0, (uint32_t )3);
#line 992
    BitBufferWrite(& bitstream, (uint32_t )0, (uint32_t )4);
#line 995
    status = EncodeMono(p, & bitstream, theReadBuffer, (uint32_t )1, (uint32_t )0,
                        numSamples);
    }
#line 996
    if (status) {
#line 996
      goto Exit;
    }
  } else {
#line 1007
    inputBuffer = theReadBuffer;
#line 1009
    stereoElementTag = (uint8_t )0;
#line 1010
    monoElementTag = (uint8_t )0;
#line 1011
    lfeElementTag = (uint8_t )0;
#line 1013
    channelIndex = (uint32_t )0;
    {
#line 1013
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1013
      if (! (channelIndex < numChannels)) {
#line 1013
        goto while_break;
      }
      {
#line 1015
      tag = (uint32_t )(((unsigned long )sChannelMaps[numChannels - 1U] & (7UL << channelIndex * 3U)) >> channelIndex * 3U);
#line 1017
      BitBufferWrite(& bitstream, tag, (uint32_t )3);
      }
#line 1020
      if (tag == 0U) {
#line 1020
        goto case_0;
      }
#line 1031
      if (tag == 1U) {
#line 1031
        goto case_1;
      }
#line 1042
      if (tag == 3U) {
#line 1042
        goto case_3;
      }
#line 1053
      goto switch_default;
      case_0: 
      {
#line 1022
      BitBufferWrite(& bitstream, (uint32_t )monoElementTag, (uint32_t )4);
#line 1024
      status = EncodeMono(p, & bitstream, inputBuffer, numChannels, channelIndex,
                          numSamples);
#line 1026
      inputBuffer ++;
#line 1027
      channelIndex ++;
#line 1028
      monoElementTag = (uint8_t )((int )monoElementTag + 1);
      }
#line 1029
      goto switch_break;
      case_1: 
      {
#line 1033
      BitBufferWrite(& bitstream, (uint32_t )stereoElementTag, (uint32_t )4);
#line 1035
      status = EncodeStereo(p, & bitstream, inputBuffer, numChannels, channelIndex,
                            numSamples);
#line 1037
      inputBuffer += 2;
#line 1038
      channelIndex += 2U;
#line 1039
      stereoElementTag = (uint8_t )((int )stereoElementTag + 1);
      }
#line 1040
      goto switch_break;
      case_3: 
      {
#line 1044
      BitBufferWrite(& bitstream, (uint32_t )lfeElementTag, (uint32_t )4);
#line 1046
      status = EncodeMono(p, & bitstream, inputBuffer, numChannels, channelIndex,
                          numSamples);
#line 1048
      inputBuffer ++;
#line 1049
      channelIndex ++;
#line 1050
      lfeElementTag = (uint8_t )((int )lfeElementTag + 1);
      }
#line 1051
      goto switch_break;
      switch_default: 
      {
#line 1054
      printf("That ain\'t right! (%u)\n", tag);
#line 1055
      status = -50;
      }
#line 1056
      goto Exit;
      switch_break: ;
#line 1059
      if (status) {
#line 1059
        goto Exit;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 1078
  BitBufferWrite(& bitstream, (uint32_t )7, (uint32_t )3);
#line 1081
  BitBufferByteAlign(& bitstream, 1);
#line 1083
  __cil_tmp27 = BitBufferGetPosition(& bitstream);
#line 1083
  outputSize = __cil_tmp27 / 8U;
#line 1088
  *ioNumBytes = outputSize;
#line 1092
  p->mTotalBytesGenerated += outputSize;
  }
#line 1093
  if (p->mMaxFrameBytes > outputSize) {
#line 1093
    tmp = p->mMaxFrameBytes;
  } else {
#line 1093
    tmp = outputSize;
  }
#line 1093
  p->mMaxFrameBytes = tmp;
#line 1095
  status = 0;
  Exit: 
#line 1098
  return (status);
}
}
#line 1110 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
void GetConfig(ALAC_ENCODER *p , ALACSpecificConfig *config ) 
{ 
  int32_t __cil_tmp3 ;
  int16_t __cil_tmp4 ;
  int32_t __cil_tmp5 ;
  int32_t __cil_tmp6 ;
  int32_t __cil_tmp7 ;

  {
  {
#line 1112
  __cil_tmp3 = ENDSWAP_32((int32_t )p->mFrameSize);
#line 1112
  config->frameLength = (uint32_t )__cil_tmp3;
#line 1113
  config->compatibleVersion = (uint8_t )0;
#line 1114
  config->bitDepth = (uint8_t )p->mBitDepth;
#line 1115
  config->pb = (uint8_t )40;
#line 1116
  config->kb = (uint8_t )14;
#line 1117
  config->mb = (uint8_t )10;
#line 1118
  config->numChannels = (uint8_t )p->mNumChannels;
#line 1119
  __cil_tmp4 = ENDSWAP_16((int16_t )((uint16_t )255));
#line 1119
  config->maxRun = (uint16_t )__cil_tmp4;
#line 1120
  __cil_tmp5 = ENDSWAP_32((int32_t )p->mMaxFrameBytes);
#line 1120
  config->maxFrameBytes = (uint32_t )__cil_tmp5;
#line 1121
  __cil_tmp6 = ENDSWAP_32((int32_t )p->mAvgBitRate);
#line 1121
  config->avgBitRate = (uint32_t )__cil_tmp6;
#line 1122
  __cil_tmp7 = ENDSWAP_32((int32_t )p->mOutputSampleRate);
#line 1122
  config->sampleRate = (uint32_t )__cil_tmp7;
  }
#line 1124
  return;
}
}
#line 1126 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
uint32_t alac_get_magic_cookie_size(uint32_t inNumChannels ) 
{ 


  {
#line 1128
  if (inNumChannels > 2U) {
#line 1130
    return ((uint32_t )((sizeof(ALACSpecificConfig ) + 12UL) + sizeof(ALACAudioChannelLayout )));
  } else {
#line 1134
    return ((uint32_t )sizeof(ALACSpecificConfig ));
  }
}
}
#line 1139 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
void alac_get_magic_cookie(ALAC_ENCODER *p , void *outCookie , uint32_t *ioSize ) 
{ 
  ALACSpecificConfig theConfig ;
  ALACAudioChannelLayout theChannelLayout ;
  uint8_t theChannelAtom[12] ;
  uint32_t theCookieSize ;
  uint8_t *theCookiePointer ;
  int32_t __cil_tmp9 ;

  {
  {
#line 1141
  theConfig.frameLength = (uint32_t )0;
#line 1141
  theConfig.compatibleVersion = (uint8_t )0;
#line 1141
  theConfig.bitDepth = (uint8_t )0;
#line 1141
  theConfig.pb = (uint8_t )0;
#line 1141
  theConfig.mb = (uint8_t )0;
#line 1141
  theConfig.kb = (uint8_t )0;
#line 1141
  theConfig.numChannels = (uint8_t )0;
#line 1141
  theConfig.maxRun = (uint16_t )0;
#line 1141
  theConfig.maxFrameBytes = (uint32_t )0;
#line 1141
  theConfig.avgBitRate = (uint32_t )0;
#line 1141
  theConfig.sampleRate = (uint32_t )0;
#line 1142
  theChannelLayout.mChannelLayoutTag = (ALACChannelLayoutTag )0;
#line 1142
  theChannelLayout.mChannelBitmap = (uint32_t )0;
#line 1142
  theChannelLayout.mNumberChannelDescriptions = (uint32_t )0;
#line 1143
  theChannelAtom[0] = (uint8_t )0;
#line 1143
  theChannelAtom[1] = (uint8_t )0;
#line 1143
  theChannelAtom[2] = (uint8_t )0;
#line 1143
  theChannelAtom[3] = (uint8_t )0;
#line 1143
  theChannelAtom[4] = (uint8_t )'c';
#line 1143
  theChannelAtom[5] = (uint8_t )'h';
#line 1143
  theChannelAtom[6] = (uint8_t )'a';
#line 1143
  theChannelAtom[7] = (uint8_t )'n';
#line 1143
  theChannelAtom[8] = (uint8_t )0;
#line 1143
  theChannelAtom[9] = (uint8_t )0;
#line 1143
  theChannelAtom[10] = (uint8_t )0;
#line 1143
  theChannelAtom[11] = (uint8_t )0;
#line 1144
  theCookieSize = (uint32_t )sizeof(ALACSpecificConfig );
#line 1145
  theCookiePointer = (uint8_t *)outCookie;
#line 1147
  GetConfig(p, & theConfig);
  }
#line 1148
  if ((int )theConfig.numChannels > 2) {
    {
#line 1150
    __cil_tmp9 = ENDSWAP_32((int32_t )ALACChannelLayoutTags___2[(int )theConfig.numChannels - 1]);
#line 1150
    theChannelLayout.mChannelLayoutTag = (ALACChannelLayoutTag )__cil_tmp9;
#line 1151
    theCookieSize = (uint32_t )((unsigned long )theCookieSize + (sizeof(ALACAudioChannelLayout ) + 12UL));
    }
  }
#line 1153
  if (*ioSize >= theCookieSize) {
    {
#line 1155
    memcpy((void *)theCookiePointer, (void const   *)(& theConfig), sizeof(ALACSpecificConfig ));
#line 1156
    theChannelAtom[3] = (uint8_t )(sizeof(ALACAudioChannelLayout ) + 12UL);
    }
#line 1157
    if ((int )theConfig.numChannels > 2) {
      {
#line 1159
      theCookiePointer += sizeof(ALACSpecificConfig );
#line 1160
      memcpy((void *)theCookiePointer, (void const   *)(theChannelAtom), 12UL);
#line 1161
      theCookiePointer += 12;
#line 1162
      memcpy((void *)theCookiePointer, (void const   *)(& theChannelLayout), sizeof(ALACAudioChannelLayout ));
      }
    }
#line 1164
    *ioSize = theCookieSize;
  } else {
#line 1168
    *ioSize = (uint32_t )0;
  }
#line 1170
  return;
}
}
#line 1177 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
int32_t alac_encoder_init(ALAC_ENCODER *p , uint32_t samplerate , uint32_t channels ,
                          uint32_t format_flags , uint32_t frameSize ) 
{ 
  int32_t status ;
  uint32_t tmp ;
  uint32_t indx ;
  int32_t channel ;
  int32_t search ;

  {
#line 1181
  if (frameSize > 0U) {
#line 1181
    if (frameSize <= 4096U) {
#line 1181
      tmp = frameSize;
    } else {
#line 1181
      tmp = 4096U;
    }
  } else {
#line 1181
    tmp = 4096U;
  }
#line 1181
  p->mFrameSize = tmp;
#line 1183
  p->mOutputSampleRate = samplerate;
#line 1184
  p->mNumChannels = channels;
#line 1187
  if (format_flags == 1U) {
#line 1187
    goto case_1;
  }
#line 1190
  if (format_flags == 2U) {
#line 1190
    goto case_2;
  }
#line 1193
  if (format_flags == 3U) {
#line 1193
    goto case_3;
  }
#line 1196
  if (format_flags == 4U) {
#line 1196
    goto case_4;
  }
#line 1199
  goto switch_default;
  case_1: 
#line 1188
  p->mBitDepth = (int16_t )16;
#line 1189
  goto switch_break;
  case_2: 
#line 1191
  p->mBitDepth = (int16_t )20;
#line 1192
  goto switch_break;
  case_3: 
#line 1194
  p->mBitDepth = (int16_t )24;
#line 1195
  goto switch_break;
  case_4: 
#line 1197
  p->mBitDepth = (int16_t )32;
#line 1198
  goto switch_break;
  switch_default: 
#line 1200
  goto switch_break;
  switch_break: 
#line 1205
  indx = (uint32_t )0;
  {
#line 1205
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1205
    if (! (indx < 8U)) {
#line 1205
      goto while_break;
    }
#line 1206
    p->mLastMixRes[indx] = (int16_t )kDefaultMixRes;
#line 1205
    indx ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 1211
  p->mMaxOutputBytes = (p->mFrameSize * p->mNumChannels) * ((10U + kMaxSampleSize) / 8U) + 1U;
#line 1213
  status = 0;
#line 1216
  channel = 0;
  {
#line 1216
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1216
    if (! (channel < (int32_t )p->mNumChannels)) {
#line 1216
      goto while_break___0;
    }
#line 1218
    search = 0;
    {
#line 1218
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1218
      if (! (search < 16)) {
#line 1218
        goto while_break___1;
      }
      {
#line 1220
      init_coefs(p->mCoefsU[channel][search], (uint32_t )9, 16);
#line 1221
      init_coefs(p->mCoefsV[channel][search], (uint32_t )9, 16);
#line 1218
      search ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 1216
    channel ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 1225
  return (status);
}
}
#line 1233 "/root/patchweave_new/23/src/ALAC/alac_encoder.c"
void alac_get_source_format(ALAC_ENCODER *p , AudioFormatDescription *source , AudioFormatDescription *output ) 
{ 


  {
#line 1240
  if (source->mFormatID != 1835233388U) {
#line 1241
    p->mBitDepth = (int16_t )16;
  } else
#line 1240
  if ((source->mFormatFlags & 1U) != 0U) {
#line 1241
    p->mBitDepth = (int16_t )16;
  } else
#line 1240
  if (source->mBitsPerChannel <= 16U) {
#line 1241
    p->mBitDepth = (int16_t )16;
  } else
#line 1242
  if (source->mBitsPerChannel <= 20U) {
#line 1243
    p->mBitDepth = (int16_t )20;
  } else
#line 1244
  if (source->mBitsPerChannel <= 24U) {
#line 1245
    p->mBitDepth = (int16_t )24;
  } else {
#line 1247
    p->mBitDepth = (int16_t )32;
  }
#line 1249
  return;
}
}
#line 47 "/root/patchweave_new/23/src/ALAC/alac_decoder.c"
uint32_t kMaxBitDepth  =    (uint32_t )32;
#line 51
static int32_t alac_fill_element(struct BitBuffer *bits ) ;
#line 52
static int32_t alac_data_stream_element(struct BitBuffer *bits ) ;
#line 54
static void Zero32(int32_t *buffer , uint32_t numItems , uint32_t stride ) ;
#line 62 "/root/patchweave_new/23/src/ALAC/alac_decoder.c"
int32_t alac_decoder_init(ALAC_DECODER *p , void *inMagicCookie , uint32_t inMagicCookieSize ) 
{ 
  int32_t status ;
  ALACSpecificConfig theConfig ;
  uint8_t *theActualCookie ;
  uint32_t theCookieBytesRemaining ;
  int32_t __cil_tmp8 ;
  int16_t __cil_tmp9 ;
  int32_t __cil_tmp10 ;
  int32_t __cil_tmp11 ;
  int32_t __cil_tmp12 ;

  {
#line 64
  status = 0;
#line 66
  theActualCookie = (uint8_t *)inMagicCookie;
#line 67
  theCookieBytesRemaining = inMagicCookieSize;
#line 76
  if ((int )*(theActualCookie + 4) == 102) {
#line 76
    if ((int )*(theActualCookie + 5) == 114) {
#line 76
      if ((int )*(theActualCookie + 6) == 109) {
#line 76
        if ((int )*(theActualCookie + 7) == 97) {
#line 78
          theActualCookie += 12;
#line 79
          theCookieBytesRemaining -= 12U;
        }
      }
    }
  }
#line 83
  if ((int )*(theActualCookie + 4) == 97) {
#line 83
    if ((int )*(theActualCookie + 5) == 108) {
#line 83
      if ((int )*(theActualCookie + 6) == 97) {
#line 83
        if ((int )*(theActualCookie + 7) == 99) {
#line 85
          theActualCookie += 12;
#line 86
          theCookieBytesRemaining -= 12U;
        }
      }
    }
  }
#line 90
  if ((unsigned long )theCookieBytesRemaining >= sizeof(ALACSpecificConfig )) {
    {
#line 92
    __cil_tmp8 = psf_get_be32(theActualCookie, 0);
#line 92
    theConfig.frameLength = (uint32_t )__cil_tmp8;
    }
#line 94
    if (theConfig.frameLength > 4096U) {
#line 95
      return (-666);
    }
    {
#line 97
    theConfig.compatibleVersion = *(theActualCookie + 0);
#line 98
    theConfig.bitDepth = *(theActualCookie + 0);
#line 99
    theConfig.pb = *(theActualCookie + 0);
#line 100
    theConfig.mb = *(theActualCookie + 0);
#line 101
    theConfig.kb = *(theActualCookie + 0);
#line 102
    theConfig.numChannels = *(theActualCookie + 0);
#line 103
    __cil_tmp9 = psf_get_be16(theActualCookie, 0);
#line 103
    theConfig.maxRun = (uint16_t )__cil_tmp9;
#line 104
    __cil_tmp10 = psf_get_be32(theActualCookie, 0);
#line 104
    theConfig.maxFrameBytes = (uint32_t )__cil_tmp10;
#line 105
    __cil_tmp11 = psf_get_be32(theActualCookie, 0);
#line 105
    theConfig.avgBitRate = (uint32_t )__cil_tmp11;
#line 106
    __cil_tmp12 = psf_get_be32(theActualCookie, 0);
#line 106
    theConfig.sampleRate = (uint32_t )__cil_tmp12;
#line 108
    p->mConfig = theConfig;
#line 109
    p->mNumChannels = (uint32_t )theConfig.numChannels;
    }
#line 111
    if (! ((int )p->mConfig.compatibleVersion <= 0)) {
#line 111
      return (-1048577);
    }
#line 112
    if ((int )p->mConfig.bitDepth >= 8) {
#line 112
      if (! ((int )p->mConfig.bitDepth <= 32)) {
#line 112
        return (-1048576);
      }
    } else {
#line 112
      return (-1048576);
    }
#line 113
    if ((unsigned long )(p->mMixBufferU) != (unsigned long )((void *)0)) {
#line 113
      if ((unsigned long )(p->mMixBufferV) != (unsigned long )((void *)0)) {
#line 113
        if (! ((unsigned long )(p->__annonCompField3.mPredictor) != (unsigned long )((void *)0))) {
#line 113
          status = -108;
#line 113
          goto Exit;
        }
      } else {
#line 113
        status = -108;
#line 113
        goto Exit;
      }
    } else {
#line 113
      status = -108;
#line 113
      goto Exit;
    }
  } else {
#line 118
    status = -1048578;
  }
  Exit: 
#line 128
  return (status);
}
}
#line 137 "/root/patchweave_new/23/src/ALAC/alac_decoder.c"
int32_t alac_decode(ALAC_DECODER *p , struct BitBuffer *bits , int32_t *sampleBuffer ,
                    uint32_t numSamples , uint32_t *outNumSamples ) 
{ 
  BitBuffer shiftBits ;
  uint32_t bits1 ;
  uint32_t bits2 ;
  uint8_t tag ;
  uint8_t elementInstanceTag ;
  AGParamRec agParams ;
  uint32_t channelIndex ;
  int16_t coefsU[32] ;
  int16_t coefsV[32] ;
  uint8_t numU ;
  uint8_t numV ;
  uint8_t mixBits ;
  int8_t mixRes ;
  uint16_t unusedHeader ;
  uint8_t escapeFlag ;
  uint32_t chanBits ;
  uint8_t bytesShifted ;
  uint32_t shift ;
  uint8_t modeU ;
  uint8_t modeV ;
  uint32_t denShiftU ;
  uint32_t denShiftV ;
  uint16_t pbFactorU ;
  uint16_t pbFactorV ;
  uint16_t pb ;
  int32_t *out32 ;
  uint8_t headerByte ;
  uint8_t partialFrame ;
  uint32_t extraBits ;
  int32_t val ;
  uint32_t i ;
  uint32_t j ;
  int32_t status ;
  uint32_t numChannels ;
  uint32_t __cil_tmp42 ;
  uint32_t __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  uint32_t __cil_tmp45 ;
  uint32_t __cil_tmp46 ;
  uint32_t __cil_tmp47 ;
  uint32_t __cil_tmp48 ;
  uint32_t __cil_tmp49 ;
  uint32_t __cil_tmp50 ;
  uint32_t __cil_tmp53 ;
  uint32_t __cil_tmp55 ;
  int32_t __cil_tmp56 ;
  uint32_t __cil_tmp57 ;
  uint32_t __cil_tmp59 ;
  uint32_t __cil_tmp62 ;
  uint32_t __cil_tmp64 ;
  uint32_t __cil_tmp65 ;
  uint32_t __cil_tmp66 ;
  uint32_t __cil_tmp67 ;
  uint32_t __cil_tmp68 ;
  uint32_t __cil_tmp69 ;
  uint32_t __cil_tmp70 ;
  uint32_t __cil_tmp71 ;
  uint32_t __cil_tmp72 ;
  uint32_t __cil_tmp74 ;
  uint32_t __cil_tmp75 ;
  uint32_t __cil_tmp76 ;
  uint32_t __cil_tmp80 ;
  uint32_t __cil_tmp81 ;
  uint32_t __cil_tmp83 ;
  uint32_t __cil_tmp84 ;
  uint32_t __cil_tmp85 ;
  uint32_t __cil_tmp86 ;
  uint32_t __cil_tmp88 ;
  uint32_t __cil_tmp89 ;
  int32_t *fill32 ;

  {
#line 166
  numChannels = p->mNumChannels;
#line 168
  if ((unsigned long )bits != (unsigned long )((void *)0)) {
#line 168
    if ((unsigned long )sampleBuffer != (unsigned long )((void *)0)) {
#line 168
      if (! ((unsigned long )outNumSamples != (unsigned long )((void *)0))) {
#line 168
        return (-50);
      }
    } else {
#line 168
      return (-50);
    }
  } else {
#line 168
    return (-50);
  }
#line 169
  if (! (p->mNumChannels > 0U)) {
#line 169
    return (-1048579);
  }
#line 171
  p->mActiveElements = (uint16_t )0;
#line 172
  channelIndex = (uint32_t )0;
#line 174
  status = 0;
#line 175
  *outNumSamples = numSamples;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;

#line 177
    if (! (status == 0)) {
#line 177
      goto while_break;
    }
#line 180
    if (! ((unsigned long )bits->cur < (unsigned long )bits->end)) {
#line 180
      status = -50;
#line 180
      goto Exit;
    }
    {
#line 183
    pb = (uint16_t )p->mConfig.pb;
#line 186
    tag = BitBufferReadSmall(bits, (uint8_t )3);
    }
#line 190
    if ((int )tag == 3) {
#line 190
      goto case_3;
    }
#line 190
    if ((int )tag == 0) {
#line 190
      goto case_3;
    }
#line 309
    if ((int )tag == 16) {
#line 309
      goto case_16;
    }
#line 314
    if ((int )tag == 20) {
#line 314
      goto case_20;
    }
#line 318
    if ((int )tag == 24) {
#line 318
      goto case_24;
    }
#line 325
    if ((int )tag == 32) {
#line 325
      goto case_32;
    }
#line 339
    if ((int )tag == 1) {
#line 339
      goto case_1;
    }
#line 500
    if ((int )tag == 16) {
#line 500
      goto case_16___0;
    }
#line 504
    if ((int )tag == 20) {
#line 504
      goto case_20___0;
    }
#line 508
    if ((int )tag == 24) {
#line 508
      goto case_24___0;
    }
#line 513
    if ((int )tag == 32) {
#line 513
      goto case_32___0;
    }
#line 526
    if ((int )tag == 5) {
#line 526
      goto case_5;
    }
#line 526
    if ((int )tag == 2) {
#line 526
      goto case_5;
    }
#line 534
    if ((int )tag == 4) {
#line 534
      goto case_4;
    }
#line 541
    if ((int )tag == 6) {
#line 541
      goto case_6;
    }
#line 548
    if ((int )tag == 7) {
#line 548
      goto case_7;
    }
#line 187
    goto switch_break;
    case_3: 
    {
#line 193
    elementInstanceTag = BitBufferReadSmall(bits, (uint8_t )4);
#line 194
    p->mActiveElements = (uint16_t )((unsigned int )p->mActiveElements | (1U << (int )elementInstanceTag));
#line 197
    __cil_tmp42 = BitBufferRead(bits, (uint8_t )12);
#line 197
    unusedHeader = (uint16_t )__cil_tmp42;
    }
#line 198
    if (! ((int )unusedHeader == 0)) {
#line 198
      status = -50;
#line 198
      goto Exit;
    }
    {
#line 201
    __cil_tmp43 = BitBufferRead(bits, (uint8_t )4);
#line 201
    headerByte = (uint8_t )__cil_tmp43;
#line 203
    partialFrame = (uint8_t )((int )headerByte >> 3);
#line 205
    bytesShifted = (uint8_t )((unsigned int )((int )headerByte >> 1) & 3U);
    }
#line 206
    if (! ((int )bytesShifted != 3)) {
#line 206
      status = -50;
#line 206
      goto Exit;
    }
#line 208
    shift = (uint32_t )((int )bytesShifted * 8);
#line 210
    escapeFlag = (uint8_t )((int )headerByte & 1);
#line 212
    chanBits = (uint32_t )((int )p->mConfig.bitDepth - (int )bytesShifted * 8);
#line 215
    if ((int )partialFrame != 0) {
      {
#line 217
      __cil_tmp44 = BitBufferRead(bits, (uint8_t )16);
#line 217
      numSamples = __cil_tmp44 << 16;
#line 218
      __cil_tmp45 = BitBufferRead(bits, (uint8_t )16);
#line 218
      numSamples |= __cil_tmp45;
      }
#line 220
      if (! (numSamples < 4096U)) {
#line 220
        return (-1048580);
      }
    }
#line 223
    if ((int )escapeFlag == 0) {
      {
#line 226
      __cil_tmp46 = BitBufferRead(bits, (uint8_t )8);
#line 226
      mixBits = (uint8_t )__cil_tmp46;
#line 227
      __cil_tmp47 = BitBufferRead(bits, (uint8_t )8);
#line 227
      mixRes = (int8_t )__cil_tmp47;
#line 230
      __cil_tmp48 = BitBufferRead(bits, (uint8_t )8);
#line 230
      headerByte = (uint8_t )__cil_tmp48;
#line 231
      modeU = (uint8_t )((int )headerByte >> 4);
#line 232
      denShiftU = (unsigned int )headerByte & 15U;
#line 234
      __cil_tmp49 = BitBufferRead(bits, (uint8_t )8);
#line 234
      headerByte = (uint8_t )__cil_tmp49;
#line 235
      pbFactorU = (uint16_t )((int )headerByte >> 5);
#line 236
      numU = (uint8_t )((unsigned int )headerByte & 31U);
#line 238
      i = (uint32_t )0;
      }
      {
#line 238
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 238
        if (! (i < (unsigned int )numU)) {
#line 238
          goto while_break___0;
        }
        {
#line 239
        __cil_tmp50 = BitBufferRead(bits, (uint8_t )16);
#line 239
        coefsU[i] = (int16_t )__cil_tmp50;
#line 238
        i ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___0: ;
#line 242
      if ((int )bytesShifted != 0) {
        {
#line 244
        shiftBits = *bits;
#line 245
        BitBufferAdvance(bits, (unsigned int )((int )bytesShifted * 8) * numSamples);
        }
      }
      {
#line 249
      set_ag_params(& agParams, (uint32_t )p->mConfig.mb, (uint32_t )(((int )pb * (int )pbFactorU) / 4),
                    (uint32_t )p->mConfig.kb, numSamples, numSamples, (uint32_t )p->mConfig.maxRun);
#line 250
      status = dyn_decomp(& agParams, bits, p->__annonCompField3.mPredictor, (int32_t )numSamples,
                          (int32_t )chanBits, & bits1);
      }
#line 251
      if (status) {
#line 251
        goto Exit;
      }
#line 253
      if ((int )modeU == 0) {
        {
#line 255
        unpc_block(p->__annonCompField3.mPredictor, p->mMixBufferU, (int32_t )numSamples,
                   & coefsU[0], (int32_t )numU, chanBits, denShiftU);
        }
      } else {
        {
#line 260
        unpc_block(p->__annonCompField3.mPredictor, p->__annonCompField3.mPredictor,
                   (int32_t )numSamples, (int16_t *)((void *)0), 31, chanBits, (uint32_t )0);
#line 261
        unpc_block(p->__annonCompField3.mPredictor, p->mMixBufferU, (int32_t )numSamples,
                   & coefsU[0], (int32_t )numU, chanBits, denShiftU);
        }
      }
    } else {
#line 269
      shift = 32U - chanBits;
#line 270
      if (chanBits <= 16U) {
#line 272
        i = (uint32_t )0;
        {
#line 272
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 272
          if (! (i < numSamples)) {
#line 272
            goto while_break___1;
          }
          {
#line 274
          __cil_tmp53 = BitBufferRead(bits, (uint8_t )chanBits);
#line 274
          val = (int32_t )__cil_tmp53;
#line 275
          val = (val << shift) >> shift;
#line 276
          p->mMixBufferU[i] = val;
#line 272
          i ++;
          }
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___1: ;
      } else {
#line 282
        extraBits = chanBits - 16U;
#line 283
        i = (uint32_t )0;
        {
#line 283
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 283
          if (! (i < numSamples)) {
#line 283
            goto while_break___2;
          }
          {
#line 285
          __cil_tmp55 = BitBufferRead(bits, (uint8_t )16);
#line 285
          val = (int32_t )__cil_tmp55;
#line 286
          __cil_tmp56 = arith_shift_left(val, 16);
#line 286
          val = __cil_tmp56 >> shift;
#line 287
          __cil_tmp57 = BitBufferRead(bits, (uint8_t )extraBits);
#line 287
          p->mMixBufferU[i] = (int32_t )((unsigned int )val | __cil_tmp57);
#line 283
          i ++;
          }
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___2: ;
      }
#line 291
      mixRes = (int8_t )0;
#line 291
      mixBits = (uint8_t )mixRes;
#line 292
      bits1 = chanBits * numSamples;
#line 293
      bytesShifted = (uint8_t )0;
    }
#line 297
    if ((int )bytesShifted != 0) {
#line 299
      shift = (uint32_t )((int )bytesShifted * 8);
#line 302
      i = (uint32_t )0;
      {
#line 302
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 302
        if (! (i < numSamples)) {
#line 302
          goto while_break___3;
        }
        {
#line 303
        __cil_tmp59 = BitBufferRead(& shiftBits, (uint8_t )shift);
#line 303
        p->__annonCompField3.mShiftBuffer[i] = (uint16_t )__cil_tmp59;
#line 302
        i ++;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___3: ;
    }
#line 309
    if ((int )p->mConfig.bitDepth == 16) {
#line 309
      goto case_16;
    }
#line 314
    if ((int )p->mConfig.bitDepth == 20) {
#line 314
      goto case_20;
    }
#line 318
    if ((int )p->mConfig.bitDepth == 24) {
#line 318
      goto case_24;
    }
#line 325
    if ((int )p->mConfig.bitDepth == 32) {
#line 325
      goto case_32;
    }
#line 307
    goto switch_break___0;
    case_16: 
#line 310
    out32 = sampleBuffer + channelIndex;
#line 311
    j = (uint32_t )0;
#line 311
    i = (uint32_t )0;
    {
#line 311
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 311
      if (! (i < numSamples)) {
#line 311
        goto while_break___4;
      }
      {
#line 312
      *(out32 + j) = arith_shift_left(p->mMixBufferU[i], 16);
#line 311
      j += numChannels;
#line 311
      __cil_tmp62 = i;
#line 311
      i ++;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___4: ;
#line 313
    goto switch_break___0;
    case_20: 
    {
#line 315
    out32 = sampleBuffer + channelIndex;
#line 316
    copyPredictorTo20(p->mMixBufferU, out32, numChannels, (int32_t )numSamples);
    }
#line 317
    goto switch_break___0;
    case_24: 
#line 319
    out32 = sampleBuffer + channelIndex;
#line 320
    if ((int )bytesShifted != 0) {
      {
#line 321
      copyPredictorTo24Shift(p->mMixBufferU, p->__annonCompField3.mShiftBuffer, out32,
                             numChannels, (int32_t )numSamples, (int32_t )bytesShifted);
      }
    } else {
      {
#line 323
      copyPredictorTo24(p->mMixBufferU, out32, numChannels, (int32_t )numSamples);
      }
    }
#line 324
    goto switch_break___0;
    case_32: 
#line 326
    out32 = sampleBuffer + channelIndex;
#line 327
    if ((int )bytesShifted != 0) {
      {
#line 328
      copyPredictorTo32Shift(p->mMixBufferU, p->__annonCompField3.mShiftBuffer, out32,
                             numChannels, (int32_t )numSamples, (int32_t )bytesShifted);
      }
    } else {
      {
#line 330
      copyPredictorTo32(p->mMixBufferU, out32, numChannels, (int32_t )numSamples);
      }
    }
#line 331
    goto switch_break___0;
    switch_break___0: 
#line 334
    channelIndex ++;
#line 335
    *outNumSamples = numSamples;
#line 336
    goto switch_break;
    case_1: 
#line 342
    if (channelIndex + 2U > numChannels) {
#line 343
      goto NoMoreChannels;
    }
    {
#line 346
    elementInstanceTag = BitBufferReadSmall(bits, (uint8_t )4);
#line 347
    p->mActiveElements = (uint16_t )((unsigned int )p->mActiveElements | (1U << (int )elementInstanceTag));
#line 350
    __cil_tmp64 = BitBufferRead(bits, (uint8_t )12);
#line 350
    unusedHeader = (uint16_t )__cil_tmp64;
    }
#line 351
    if (! ((int )unusedHeader == 0)) {
#line 351
      status = -50;
#line 351
      goto Exit;
    }
    {
#line 354
    __cil_tmp65 = BitBufferRead(bits, (uint8_t )4);
#line 354
    headerByte = (uint8_t )__cil_tmp65;
#line 356
    partialFrame = (uint8_t )((int )headerByte >> 3);
#line 358
    bytesShifted = (uint8_t )((unsigned int )((int )headerByte >> 1) & 3U);
    }
#line 359
    if (! ((int )bytesShifted != 3)) {
#line 359
      status = -50;
#line 359
      goto Exit;
    }
#line 361
    shift = (uint32_t )((int )bytesShifted * 8);
#line 363
    escapeFlag = (uint8_t )((int )headerByte & 1);
#line 365
    chanBits = (uint32_t )(((int )p->mConfig.bitDepth - (int )bytesShifted * 8) + 1);
#line 368
    if ((int )partialFrame != 0) {
      {
#line 370
      __cil_tmp66 = BitBufferRead(bits, (uint8_t )16);
#line 370
      numSamples = __cil_tmp66 << 16;
#line 371
      __cil_tmp67 = BitBufferRead(bits, (uint8_t )16);
#line 371
      numSamples |= __cil_tmp67;
      }
#line 373
      if (! (numSamples < 4096U)) {
#line 373
        return (-1048580);
      }
    }
#line 376
    if ((int )escapeFlag == 0) {
      {
#line 379
      __cil_tmp68 = BitBufferRead(bits, (uint8_t )8);
#line 379
      mixBits = (uint8_t )__cil_tmp68;
#line 380
      __cil_tmp69 = BitBufferRead(bits, (uint8_t )8);
#line 380
      mixRes = (int8_t )__cil_tmp69;
#line 382
      __cil_tmp70 = BitBufferRead(bits, (uint8_t )8);
#line 382
      headerByte = (uint8_t )__cil_tmp70;
#line 383
      modeU = (uint8_t )((int )headerByte >> 4);
#line 384
      denShiftU = (unsigned int )headerByte & 15U;
#line 386
      __cil_tmp71 = BitBufferRead(bits, (uint8_t )8);
#line 386
      headerByte = (uint8_t )__cil_tmp71;
#line 387
      pbFactorU = (uint16_t )((int )headerByte >> 5);
#line 388
      numU = (uint8_t )((unsigned int )headerByte & 31U);
#line 389
      i = (uint32_t )0;
      }
      {
#line 389
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 389
        if (! (i < (unsigned int )numU)) {
#line 389
          goto while_break___5;
        }
        {
#line 390
        __cil_tmp72 = BitBufferRead(bits, (uint8_t )16);
#line 390
        coefsU[i] = (int16_t )__cil_tmp72;
#line 389
        i ++;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___5: 
      {
#line 392
      __cil_tmp74 = BitBufferRead(bits, (uint8_t )8);
#line 392
      headerByte = (uint8_t )__cil_tmp74;
#line 393
      modeV = (uint8_t )((int )headerByte >> 4);
#line 394
      denShiftV = (unsigned int )headerByte & 15U;
#line 396
      __cil_tmp75 = BitBufferRead(bits, (uint8_t )8);
#line 396
      headerByte = (uint8_t )__cil_tmp75;
#line 397
      pbFactorV = (uint16_t )((int )headerByte >> 5);
#line 398
      numV = (uint8_t )((unsigned int )headerByte & 31U);
#line 399
      i = (uint32_t )0;
      }
      {
#line 399
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 399
        if (! (i < (unsigned int )numV)) {
#line 399
          goto while_break___6;
        }
        {
#line 400
        __cil_tmp76 = BitBufferRead(bits, (uint8_t )16);
#line 400
        coefsV[i] = (int16_t )__cil_tmp76;
#line 399
        i ++;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
      while_break___6: ;
#line 403
      if ((int )bytesShifted != 0) {
        {
#line 405
        shiftBits = *bits;
#line 406
        BitBufferAdvance(bits, (unsigned int )(((int )bytesShifted * 8) * 2) * numSamples);
        }
      }
      {
#line 410
      set_ag_params(& agParams, (uint32_t )p->mConfig.mb, (uint32_t )(((int )pb * (int )pbFactorU) / 4),
                    (uint32_t )p->mConfig.kb, numSamples, numSamples, (uint32_t )p->mConfig.maxRun);
#line 411
      status = dyn_decomp(& agParams, bits, p->__annonCompField3.mPredictor, (int32_t )numSamples,
                          (int32_t )chanBits, & bits1);
      }
#line 412
      if (status) {
#line 412
        goto Exit;
      }
#line 414
      if ((int )modeU == 0) {
        {
#line 416
        unpc_block(p->__annonCompField3.mPredictor, p->mMixBufferU, (int32_t )numSamples,
                   & coefsU[0], (int32_t )numU, chanBits, denShiftU);
        }
      } else {
        {
#line 421
        unpc_block(p->__annonCompField3.mPredictor, p->__annonCompField3.mPredictor,
                   (int32_t )numSamples, (int16_t *)((void *)0), 31, chanBits, (uint32_t )0);
#line 422
        unpc_block(p->__annonCompField3.mPredictor, p->mMixBufferU, (int32_t )numSamples,
                   & coefsU[0], (int32_t )numU, chanBits, denShiftU);
        }
      }
      {
#line 426
      set_ag_params(& agParams, (uint32_t )p->mConfig.mb, (uint32_t )(((int )pb * (int )pbFactorV) / 4),
                    (uint32_t )p->mConfig.kb, numSamples, numSamples, (uint32_t )p->mConfig.maxRun);
#line 427
      status = dyn_decomp(& agParams, bits, p->__annonCompField3.mPredictor, (int32_t )numSamples,
                          (int32_t )chanBits, & bits2);
      }
#line 428
      if (status) {
#line 428
        goto Exit;
      }
#line 430
      if ((int )modeV == 0) {
        {
#line 432
        unpc_block(p->__annonCompField3.mPredictor, p->mMixBufferV, (int32_t )numSamples,
                   & coefsV[0], (int32_t )numV, chanBits, denShiftV);
        }
      } else {
        {
#line 437
        unpc_block(p->__annonCompField3.mPredictor, p->__annonCompField3.mPredictor,
                   (int32_t )numSamples, (int16_t *)((void *)0), 31, chanBits, (uint32_t )0);
#line 438
        unpc_block(p->__annonCompField3.mPredictor, p->mMixBufferV, (int32_t )numSamples,
                   & coefsV[0], (int32_t )numV, chanBits, denShiftV);
        }
      }
    } else {
#line 446
      chanBits = (uint32_t )p->mConfig.bitDepth;
#line 447
      shift = 32U - chanBits;
#line 448
      if (chanBits <= 16U) {
#line 450
        i = (uint32_t )0;
        {
#line 450
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 450
          if (! (i < numSamples)) {
#line 450
            goto while_break___7;
          }
          {
#line 452
          __cil_tmp80 = BitBufferRead(bits, (uint8_t )chanBits);
#line 452
          val = (int32_t )__cil_tmp80;
#line 453
          val = (val << shift) >> shift;
#line 454
          p->mMixBufferU[i] = val;
#line 456
          __cil_tmp81 = BitBufferRead(bits, (uint8_t )chanBits);
#line 456
          val = (int32_t )__cil_tmp81;
#line 457
          val = (val << shift) >> shift;
#line 458
          p->mMixBufferV[i] = val;
#line 450
          i ++;
          }
        }
        while_break___19: /* CIL Label */ ;
        }
        while_break___7: ;
      } else {
#line 464
        extraBits = chanBits - 16U;
#line 465
        i = (uint32_t )0;
        {
#line 465
        while (1) {
          while_continue___8: /* CIL Label */ ;

#line 465
          if (! (i < numSamples)) {
#line 465
            goto while_break___8;
          }
          {
#line 467
          __cil_tmp83 = BitBufferRead(bits, (uint8_t )16);
#line 467
          val = (int32_t )__cil_tmp83;
#line 468
          val = (int32_t )(((uint32_t )val << 16) >> shift);
#line 469
          __cil_tmp84 = BitBufferRead(bits, (uint8_t )extraBits);
#line 469
          p->mMixBufferU[i] = (int32_t )((unsigned int )val | __cil_tmp84);
#line 471
          __cil_tmp85 = BitBufferRead(bits, (uint8_t )16);
#line 471
          val = (int32_t )__cil_tmp85;
#line 472
          val = (int32_t )((uint32_t )val >> shift);
#line 473
          __cil_tmp86 = BitBufferRead(bits, (uint8_t )extraBits);
#line 473
          p->mMixBufferV[i] = (int32_t )((unsigned int )val | __cil_tmp86);
#line 465
          i ++;
          }
        }
        while_break___20: /* CIL Label */ ;
        }
        while_break___8: ;
      }
#line 477
      bits1 = chanBits * numSamples;
#line 478
      bits2 = chanBits * numSamples;
#line 479
      mixRes = (int8_t )0;
#line 479
      mixBits = (uint8_t )mixRes;
#line 480
      bytesShifted = (uint8_t )0;
    }
#line 484
    if ((int )bytesShifted != 0) {
#line 486
      shift = (uint32_t )((int )bytesShifted * 8);
#line 489
      i = (uint32_t )0;
      {
#line 489
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 489
        if (! (i < numSamples * 2U)) {
#line 489
          goto while_break___9;
        }
        {
#line 491
        __cil_tmp88 = BitBufferRead(& shiftBits, (uint8_t )shift);
#line 491
        p->__annonCompField3.mShiftBuffer[i] = (uint16_t )__cil_tmp88;
#line 492
        __cil_tmp89 = BitBufferRead(& shiftBits, (uint8_t )shift);
#line 492
        p->__annonCompField3.mShiftBuffer[i + 1U] = (uint16_t )__cil_tmp89;
#line 489
        i += 2U;
        }
      }
      while_break___21: /* CIL Label */ ;
      }
      while_break___9: ;
    }
#line 500
    if ((int )p->mConfig.bitDepth == 16) {
#line 500
      goto case_16___0;
    }
#line 504
    if ((int )p->mConfig.bitDepth == 20) {
#line 504
      goto case_20___0;
    }
#line 508
    if ((int )p->mConfig.bitDepth == 24) {
#line 508
      goto case_24___0;
    }
#line 513
    if ((int )p->mConfig.bitDepth == 32) {
#line 513
      goto case_32___0;
    }
#line 498
    goto switch_break___1;
    case_16___0: 
    {
#line 501
    out32 = sampleBuffer + channelIndex;
#line 502
    unmix16(p->mMixBufferU, p->mMixBufferV, out32, numChannels, (int32_t )numSamples,
            (int32_t )mixBits, (int32_t )mixRes);
    }
#line 503
    goto switch_break___1;
    case_20___0: 
    {
#line 505
    out32 = sampleBuffer + channelIndex;
#line 506
    unmix20(p->mMixBufferU, p->mMixBufferV, out32, numChannels, (int32_t )numSamples,
            (int32_t )mixBits, (int32_t )mixRes);
    }
#line 507
    goto switch_break___1;
    case_24___0: 
    {
#line 509
    out32 = sampleBuffer + channelIndex;
#line 510
    unmix24(p->mMixBufferU, p->mMixBufferV, out32, numChannels, (int32_t )numSamples,
            (int32_t )mixBits, (int32_t )mixRes, p->__annonCompField3.mShiftBuffer,
            (int32_t )bytesShifted);
    }
#line 512
    goto switch_break___1;
    case_32___0: 
    {
#line 514
    out32 = sampleBuffer + channelIndex;
#line 515
    unmix32(p->mMixBufferU, p->mMixBufferV, out32, numChannels, (int32_t )numSamples,
            (int32_t )mixBits, (int32_t )mixRes, p->__annonCompField3.mShiftBuffer,
            (int32_t )bytesShifted);
    }
#line 517
    goto switch_break___1;
    switch_break___1: 
#line 520
    channelIndex += 2U;
#line 521
    *outNumSamples = numSamples;
#line 522
    goto switch_break;
    case_5: 
#line 530
    status = -1048581;
#line 531
    goto switch_break;
    case_4: 
    {
#line 537
    status = alac_data_stream_element(bits);
    }
#line 538
    goto switch_break;
    case_6: 
    {
#line 544
    status = alac_fill_element(bits);
    }
#line 545
    goto switch_break;
    case_7: 
    {
#line 551
    BitBufferByteAlign(bits, 0);
    }
#line 553
    goto Exit;
    switch_break: ;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break: ;
  NoMoreChannels: 
  {
#line 568
  while (1) {
    while_continue___10: /* CIL Label */ ;

#line 568
    if (! (channelIndex < numChannels)) {
#line 568
      goto while_break___10;
    }
    {
#line 570
    fill32 = sampleBuffer + channelIndex;
#line 571
    Zero32(fill32, numSamples, numChannels);
#line 568
    channelIndex ++;
    }
  }
  while_break___22: /* CIL Label */ ;
  }
  while_break___10: ;
  Exit: 
#line 575
  return (status);
}
}
#line 587 "/root/patchweave_new/23/src/ALAC/alac_decoder.c"
static int32_t alac_fill_element(struct BitBuffer *bits ) 
{ 
  int16_t count___0 ;
  uint8_t __cil_tmp3 ;
  uint8_t __cil_tmp4 ;

  {
  {
#line 593
  __cil_tmp3 = BitBufferReadSmall(bits, (uint8_t )4);
#line 593
  count___0 = (int16_t )__cil_tmp3;
  }
#line 594
  if ((int )count___0 == 15) {
    {
#line 595
    __cil_tmp4 = BitBufferReadSmall(bits, (uint8_t )8);
#line 595
    count___0 = (int16_t )((int )count___0 + ((int )((int16_t )__cil_tmp4) - 1));
    }
  }
  {
#line 597
  BitBufferAdvance(bits, (uint32_t )((int )count___0 * 8));
  }
#line 599
  if (! ((unsigned long )bits->cur <= (unsigned long )bits->end)) {
#line 599
    return (-50);
  }
#line 601
  return (0);
}
}
#line 609 "/root/patchweave_new/23/src/ALAC/alac_decoder.c"
static int32_t alac_data_stream_element(struct BitBuffer *bits ) 
{ 
  int32_t data_byte_align_flag ;
  uint16_t count___0 ;
  uint8_t __cil_tmp4 ;
  uint8_t __cil_tmp5 ;
  uint8_t __cil_tmp6 ;

  {
  {
#line 616
  BitBufferReadSmall(bits, (uint8_t )4);
#line 618
  __cil_tmp4 = BitBufferReadOne(bits);
#line 618
  data_byte_align_flag = (int32_t )__cil_tmp4;
#line 621
  __cil_tmp5 = BitBufferReadSmall(bits, (uint8_t )8);
#line 621
  count___0 = (uint16_t )__cil_tmp5;
  }
#line 622
  if ((int )count___0 == 255) {
    {
#line 623
    __cil_tmp6 = BitBufferReadSmall(bits, (uint8_t )8);
#line 623
    count___0 = (uint16_t )((int )count___0 + (int )__cil_tmp6);
    }
  }
#line 626
  if (data_byte_align_flag) {
    {
#line 627
    BitBufferByteAlign(bits, 0);
    }
  }
  {
#line 630
  BitBufferAdvance(bits, (uint32_t )((int )count___0 * 8));
  }
#line 632
  if (! ((unsigned long )bits->cur <= (unsigned long )bits->end)) {
#line 632
    return (-50);
  }
#line 634
  return (0);
}
}
#line 641 "/root/patchweave_new/23/src/ALAC/alac_decoder.c"
static void Zero32(int32_t *buffer , uint32_t numItems , uint32_t stride ) 
{ 
  uint32_t indx ;

  {
#line 643
  if (stride == 1U) {
    {
#line 645
    memset((void *)buffer, 0, (unsigned long )numItems * sizeof(int32_t ));
    }
  } else {
#line 649
    indx = (uint32_t )0;
    {
#line 649
    while (1) {
      while_continue: /* CIL Label */ ;

#line 649
      if (! (indx < numItems * stride)) {
#line 649
        goto while_break;
      }
#line 650
      *(buffer + indx) = 0;
#line 649
      indx += stride;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 654
  return;
}
}
#line 59 "/root/patchweave_new/23/src/ALAC/ag_enc.c"
__inline static int32_t lead(int32_t m ) 
{ 
  long j ;
  unsigned long c ;

  {
#line 62
  c = 1UL << 31;
#line 64
  j = 0L;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;

#line 64
    if (! (j < 32L)) {
#line 64
      goto while_break;
    }
#line 66
    if ((c & (unsigned long )m) != 0UL) {
#line 67
      goto while_break;
    }
#line 68
    c >>= 1;
#line 64
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 70
  return ((int32_t )j);
}
}
#line 75 "/root/patchweave_new/23/src/ALAC/ag_enc.c"
__inline static int32_t lg3a(int32_t x ) 
{ 
  int32_t result ;

  {
  {
#line 79
  x += 3;
#line 80
  result = lead(x);
  }
#line 82
  return (31 - result);
}
}
#line 85 "/root/patchweave_new/23/src/ALAC/ag_enc.c"
__inline static int32_t abs_func(int32_t a ) 
{ 
  int32_t isneg ;
  int32_t xorval ;
  int32_t result ;

  {
#line 88
  isneg = a >> 31;
#line 89
  xorval = a ^ isneg;
#line 90
  result = xorval - isneg;
#line 92
  return (result);
}
}
#line 99 "/root/patchweave_new/23/src/ALAC/ag_enc.c"
__inline static int32_t dyn_code(int32_t m , int32_t k , int32_t n , uint32_t *outNumBits ) 
{ 
  uint32_t divx ;
  uint32_t mod ;
  uint32_t de ;
  uint32_t numBits ;
  uint32_t value___0 ;

  {
#line 107
  divx = (uint32_t )(n / m);
#line 109
  if (divx >= 9U) {
#line 111
    numBits = (uint32_t )25;
#line 112
    value___0 = (uint32_t )((((1 << 9) - 1) << 16) + n);
  } else {
#line 116
    mod = (uint32_t )(n % m);
#line 117
    de = (uint32_t )(mod == 0U);
#line 118
    numBits = ((divx + (unsigned int )k) + 1U) - de;
#line 119
    value___0 = (((unsigned int )(((1 << divx) - 1) << (numBits - divx)) + mod) + 1U) - de;
#line 122
    if (numBits > 25U) {
#line 124
      numBits = (uint32_t )25;
#line 125
      value___0 = (uint32_t )((((1 << 9) - 1) << 16) + n);
    }
  }
#line 129
  *outNumBits = numBits;
#line 131
  return ((int32_t )value___0);
}
}
#line 135 "/root/patchweave_new/23/src/ALAC/ag_enc.c"
__inline static int32_t dyn_code_32bit(int32_t maxbits , uint32_t m , uint32_t k ,
                                       uint32_t n , uint32_t *outNumBits , uint32_t *outValue ,
                                       uint32_t *overflow , uint32_t *overflowbits ) 
{ 
  uint32_t divx ;
  uint32_t mod ;
  uint32_t de ;
  uint32_t numBits ;
  uint32_t value___0 ;
  int32_t didOverflow ;

  {
#line 140
  didOverflow = 0;
#line 142
  divx = n / m;
#line 144
  if (divx < 9U) {
#line 146
    mod = n - m * divx;
#line 148
    de = (uint32_t )(mod == 0U);
#line 149
    numBits = ((divx + k) + 1U) - de;
#line 150
    value___0 = (((unsigned int )(((1 << divx) - 1) << (numBits - divx)) + mod) + 1U) - de;
#line 151
    if (numBits > 25U) {
#line 152
      goto codeasescape;
    }
  } else {
    codeasescape: 
#line 157
    numBits = (uint32_t )9;
#line 158
    value___0 = (uint32_t )((1 << 9) - 1);
#line 159
    *overflow = n;
#line 160
    *overflowbits = (uint32_t )maxbits;
#line 161
    didOverflow = 1;
  }
#line 164
  *outNumBits = numBits;
#line 165
  *outValue = value___0;
#line 167
  return (didOverflow);
}
}
#line 171 "/root/patchweave_new/23/src/ALAC/ag_enc.c"
__inline static void dyn_jam_noDeref(unsigned char *out , uint32_t bitPos , uint32_t numBits ,
                                     uint32_t value___0 ) 
{ 
  uint32_t mask ;
  uint32_t curr ;
  uint32_t shift ;
  int32_t __cil_tmp8 ;

  {
  {
#line 179
  __cil_tmp8 = psf_get_be32(out, (int )(bitPos >> 3));
#line 179
  curr = (uint32_t )__cil_tmp8;
#line 181
  shift = (32U - (bitPos & 7U)) - numBits;
#line 183
  mask = 4294967295U >> (32U - numBits);
#line 184
  mask <<= shift;
#line 186
  value___0 = (value___0 << shift) & mask;
#line 187
  value___0 |= curr & ~ mask;
#line 189
  psf_put_be32(out, (int )(bitPos >> 3), (int32_t )value___0);
  }
#line 191
  return;
}
}
#line 193 "/root/patchweave_new/23/src/ALAC/ag_enc.c"
__inline static void dyn_jam_noDeref_large(unsigned char *out , uint32_t bitPos ,
                                           uint32_t numBits , uint32_t value___0 ) 
{ 
  uint32_t w ;
  uint32_t curr ;
  uint32_t mask ;
  int32_t shiftvalue ;
  int32_t __cil_tmp9 ;
  uint8_t tailbyte ;
  uint8_t *tailptr ;

  {
  {
#line 198
  shiftvalue = (int32_t )((32U - (bitPos & 7U)) - numBits);
#line 202
  __cil_tmp9 = psf_get_be32(out, (int )(bitPos >> 3));
#line 202
  curr = (uint32_t )__cil_tmp9;
  }
#line 204
  if (shiftvalue < 0) {
#line 209
    w = value___0 >> - shiftvalue;
#line 210
    mask = 4294967295U >> - shiftvalue;
#line 211
    w |= curr & ~ mask;
#line 213
    tailptr = (out + (bitPos >> 3)) + 4;
#line 214
    tailbyte = (uint8_t )((value___0 << (8 + shiftvalue)) & 255U);
#line 215
    *tailptr = tailbyte;
  } else {
#line 219
    mask = 4294967295U >> (32U - numBits);
#line 220
    mask <<= shiftvalue;
#line 222
    w = (value___0 << shiftvalue) & mask;
#line 223
    w |= curr & ~ mask;
  }
  {
#line 226
  psf_put_be32(out, (int )(bitPos >> 3), (int32_t )w);
  }
#line 228
  return;
}
}
#line 230 "/root/patchweave_new/23/src/ALAC/ag_enc.c"
int32_t dyn_comp(AGParamRecPtr params , int32_t *pc , BitBuffer *bitstream , int32_t numSamples ,
                 int32_t bitSize , uint32_t *outNumBits ) 
{ 
  unsigned char *out ;
  uint32_t bitPos ;
  uint32_t startPos ;
  uint32_t m ;
  uint32_t k ;
  uint32_t n ;
  uint32_t c ;
  uint32_t mz ;
  uint32_t nz ;
  uint32_t numBits ;
  uint32_t value___0 ;
  int32_t del ;
  int32_t zmode ;
  uint32_t overflow ;
  uint32_t overflowbits ;
  int32_t status ;
  uint32_t mb ;
  uint32_t pb ;
  uint32_t kb ;
  uint32_t wb ;
  int32_t rowPos ;
  int32_t rowSize ;
  int32_t rowJump ;
  int32_t *inPtr ;
  int32_t __cil_tmp31 ;
  int32_t *__cil_tmp32 ;
  int32_t __cil_tmp34 ;
  int32_t __cil_tmp35 ;
  int32_t __cil_tmp37 ;
  int32_t __cil_tmp38 ;

  {
#line 243
  rowPos = 0;
#line 244
  rowSize = (int32_t )params->sw;
#line 245
  rowJump = (int32_t )(params->fw - (unsigned int )rowSize);
#line 246
  inPtr = pc;
#line 248
  *outNumBits = (uint32_t )0;
#line 249
  if (bitSize >= 1) {
#line 249
    if (! (bitSize <= 32)) {
#line 249
      return (-50);
    }
  } else {
#line 249
    return (-50);
  }
#line 251
  out = bitstream->cur;
#line 252
  startPos = bitstream->bitIndex;
#line 253
  bitPos = startPos;
#line 255
  params->mb = params->mb0;
#line 255
  mb = params->mb;
#line 256
  pb = params->pb;
#line 257
  kb = params->kb;
#line 258
  wb = params->wb;
#line 259
  zmode = 0;
#line 261
  c = (uint32_t )0;
#line 262
  status = 0;
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;

#line 264
    if (! (c < (uint32_t )numSamples)) {
#line 264
      goto while_break;
    }
    {
#line 266
    m = mb >> 9;
#line 267
    __cil_tmp31 = lg3a((int32_t )m);
#line 267
    k = (uint32_t )__cil_tmp31;
    }
#line 268
    if (k > kb) {
#line 270
      k = kb;
    }
    {
#line 272
    m = (uint32_t )((1 << k) - 1);
#line 274
    __cil_tmp32 = inPtr;
#line 274
    inPtr ++;
#line 274
    del = *__cil_tmp32;
#line 275
    rowPos ++;
#line 277
    __cil_tmp34 = abs_func(del);
#line 277
    n = (uint32_t )(((__cil_tmp34 << 1) - ((del >> 31) & 1)) - zmode);
#line 280
    __cil_tmp35 = dyn_code_32bit(bitSize, m, k, n, & numBits, & value___0, & overflow,
                                 & overflowbits);
    }
#line 280
    if (__cil_tmp35) {
      {
#line 282
      dyn_jam_noDeref(out, bitPos, numBits, value___0);
#line 283
      bitPos += numBits;
#line 284
      dyn_jam_noDeref_large(out, bitPos, overflowbits, overflow);
#line 285
      bitPos += overflowbits;
      }
    } else {
      {
#line 289
      dyn_jam_noDeref(out, bitPos, numBits, value___0);
#line 290
      bitPos += numBits;
      }
    }
#line 293
    c ++;
#line 294
    if (rowPos >= rowSize) {
#line 296
      rowPos = 0;
#line 297
      inPtr += rowJump;
    }
#line 300
    mb = (pb * (n + (unsigned int )zmode) + mb) - (pb * mb >> 9);
#line 303
    if (n > 65535U) {
#line 304
      mb = (uint32_t )65535;
    }
#line 306
    zmode = 0;
#line 308
    if (! (c <= (uint32_t )numSamples)) {
#line 308
      status = -50;
#line 308
      goto Exit;
    }
#line 310
    if (mb << 2 < (unsigned int )(1 << 9)) {
#line 310
      if (c < (uint32_t )numSamples) {
#line 312
        zmode = 1;
#line 313
        nz = (uint32_t )0;
        {
#line 315
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 315
          if (c < (uint32_t )numSamples) {
#line 315
            if (! (*inPtr == 0)) {
#line 315
              goto while_break___0;
            }
          } else {
#line 315
            goto while_break___0;
          }
#line 318
          inPtr ++;
#line 319
          nz ++;
#line 320
          c ++;
#line 321
          rowPos ++;
#line 321
          if (rowPos >= rowSize) {
#line 323
            rowPos = 0;
#line 324
            inPtr += rowJump;
          }
#line 327
          if (nz >= 65535U) {
#line 329
            zmode = 0;
#line 330
            goto while_break___0;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: 
        {
#line 334
        __cil_tmp37 = lead((int32_t )mb);
#line 334
        k = (unsigned int )(__cil_tmp37 - 24) + ((mb + (unsigned int )(1 << 4)) >> 6);
#line 335
        mz = (unsigned int )((1 << k) - 1) & wb;
#line 337
        __cil_tmp38 = dyn_code((int32_t )mz, (int32_t )k, (int32_t )nz, & numBits);
#line 337
        value___0 = (uint32_t )__cil_tmp38;
#line 338
        dyn_jam_noDeref(out, bitPos, numBits, value___0);
#line 339
        bitPos += numBits;
#line 341
        mb = (uint32_t )0;
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 345
  *outNumBits = bitPos - startPos;
#line 346
  BitBufferAdvance(bitstream, *outNumBits);
  }
  Exit: 
#line 349
  return (status);
}
}
#line 55 "/root/patchweave_new/23/src/ALAC/ag_dec.c"
void set_standard_ag_params(AGParamRecPtr params , uint32_t fullwidth , uint32_t sectorwidth ) 
{ 


  {
  {
#line 63
  set_ag_params(params, (uint32_t )10, (uint32_t )40, (uint32_t )14, fullwidth, sectorwidth,
                (uint32_t )255);
  }
#line 66
  return;
}
}
#line 66 "/root/patchweave_new/23/src/ALAC/ag_dec.c"
void set_ag_params(AGParamRecPtr params , uint32_t m , uint32_t p , uint32_t k , uint32_t f ,
                   uint32_t s , uint32_t maxrun ) 
{ 


  {
#line 68
  params->mb0 = m;
#line 68
  params->mb = params->mb0;
#line 69
  params->pb = p;
#line 70
  params->kb = k;
#line 71
  params->wb = (1U << params->kb) - 1U;
#line 72
  params->qb = (unsigned int )(1 << 9) - params->pb;
#line 73
  params->fw = f;
#line 74
  params->sw = s;
#line 75
  params->maxrun = maxrun;
#line 76
  return;
}
}
#line 110 "/root/patchweave_new/23/src/ALAC/ag_dec.c"
__inline static uint32_t read32bit(uint8_t *buffer ) 
{ 
  uint32_t value___0 ;

  {
#line 115
  value___0 = ((((uint32_t )*(buffer + 0) << 24) | ((uint32_t )*(buffer + 1) << 16)) | ((uint32_t )*(buffer + 2) << 8)) | (uint32_t )*(buffer + 3);
#line 117
  return (value___0);
}
}
#line 129 "/root/patchweave_new/23/src/ALAC/ag_dec.c"
__inline static uint32_t getstreambits(uint8_t *in , int32_t bitoffset , int32_t numbits ) 
{ 
  uint32_t load1 ;
  uint32_t load2 ;
  uint32_t byteoffset ;
  uint32_t result ;
  int32_t load2shift ;

  {
  {
#line 132
  byteoffset = (uint32_t )(bitoffset / 8);
#line 137
  load1 = read32bit(in + byteoffset);
  }
#line 139
  if (numbits + (bitoffset & 7) > 32) {
#line 143
    result = load1 << (bitoffset & 7);
#line 144
    load2 = (uint32_t )*(in + (byteoffset + 4U));
#line 145
    load2shift = 8 - ((numbits + (bitoffset & 7)) - 32);
#line 146
    load2 >>= load2shift;
#line 147
    result >>= 32 - numbits;
#line 148
    result |= load2;
  } else {
#line 152
    result = load1 >> ((32 - numbits) - (bitoffset & 7));
  }
#line 157
  if ((unsigned long )numbits != sizeof(result) * 8UL) {
#line 158
    result = (uint32_t )((unsigned long )result & ~ (4294967295UL << numbits));
  }
#line 160
  return (result);
}
}
#line 164 "/root/patchweave_new/23/src/ALAC/ag_dec.c"
__inline static int32_t dyn_get(unsigned char *in , uint32_t *bitPos , uint32_t m ,
                                uint32_t k ) 
{ 
  uint32_t tempbits ;
  uint32_t result ;
  uint32_t pre ;
  uint32_t v ;
  uint32_t streamlong ;
  uint32_t notI ;
  int32_t __cil_tmp12 ;

  {
  {
#line 166
  tempbits = *bitPos;
#line 168
  pre = (uint32_t )0;
#line 171
  streamlong = read32bit(in + (tempbits >> 3));
#line 172
  streamlong <<= tempbits & 7U;
#line 176
  notI = ~ streamlong;
#line 177
  __cil_tmp12 = lead((int32_t )notI);
#line 177
  pre = (uint32_t )__cil_tmp12;
  }
#line 180
  if (pre >= 9U) {
#line 182
    pre = (uint32_t )9;
#line 183
    tempbits += pre;
#line 184
    streamlong <<= pre;
#line 185
    result = streamlong >> 16;
#line 186
    tempbits += 16U;
  } else {
#line 194
    tempbits += pre;
#line 195
    tempbits ++;
#line 196
    streamlong <<= pre + 1U;
#line 197
    v = streamlong >> (32U - k);
#line 198
    tempbits += k;
#line 200
    result = (pre * m + v) - 1U;
#line 202
    if (v < 2U) {
#line 204
      result -= v - 1U;
#line 205
      tempbits --;
    }
  }
#line 209
  *bitPos = tempbits;
#line 210
  return ((int32_t )result);
}
}
#line 214 "/root/patchweave_new/23/src/ALAC/ag_dec.c"
__inline static int32_t dyn_get_32bit(uint8_t *in , uint32_t *bitPos , int32_t m ,
                                      int32_t k , int32_t maxbits ) 
{ 
  uint32_t tempbits ;
  uint32_t v ;
  uint32_t streamlong ;
  uint32_t result ;
  uint32_t notI ;
  int32_t __cil_tmp12 ;

  {
  {
#line 216
  tempbits = *bitPos;
#line 221
  streamlong = read32bit(in + (tempbits >> 3));
#line 222
  streamlong <<= tempbits & 7U;
#line 226
  notI = ~ streamlong;
#line 227
  __cil_tmp12 = lead((int32_t )notI);
#line 227
  result = (uint32_t )__cil_tmp12;
  }
#line 230
  if (result >= 9U) {
    {
#line 232
    result = getstreambits(in, (int32_t )(tempbits + 9U), maxbits);
#line 233
    tempbits += (unsigned int )(9 + maxbits);
    }
  } else {
#line 242
    tempbits += result;
#line 243
    tempbits ++;
#line 245
    if (k != 1) {
#line 247
      streamlong <<= result + 1U;
#line 248
      v = streamlong >> (32 - k);
#line 249
      tempbits += (unsigned int )k;
#line 250
      tempbits --;
#line 251
      result *= (unsigned int )m;
#line 253
      if (v >= 2U) {
#line 255
        result += v - 1U;
#line 256
        tempbits ++;
      }
    }
  }
#line 261
  *bitPos = tempbits;
#line 263
  return ((int32_t )result);
}
}
#line 266 "/root/patchweave_new/23/src/ALAC/ag_dec.c"
int32_t dyn_decomp(AGParamRecPtr params , BitBuffer *bitstream , int32_t *pc , int32_t numSamples ,
                   int32_t maxSize , uint32_t *outNumBits ) 
{ 
  uint8_t *in ;
  int32_t *outPtr ;
  uint32_t bitPos ;
  uint32_t startPos ;
  uint32_t maxPos ;
  uint32_t j ;
  uint32_t m ;
  uint32_t k ;
  uint32_t n ;
  uint32_t c ;
  uint32_t mz ;
  int32_t del ;
  int32_t zmode ;
  uint32_t mb ;
  uint32_t pb_local ;
  uint32_t kb_local ;
  uint32_t wb_local ;
  int32_t status ;
  int32_t __cil_tmp25 ;
  uint32_t tmp ;
  int32_t __cil_tmp27 ;
  uint32_t ndecode ;
  int32_t multiplier ;
  int32_t *__cil_tmp30 ;
  int32_t __cil_tmp32 ;
  int32_t __cil_tmp33 ;
  int32_t *__cil_tmp34 ;

  {
#line 269
  outPtr = pc;
#line 274
  pb_local = params->pb;
#line 275
  kb_local = params->kb;
#line 276
  wb_local = params->wb;
#line 279
  if ((unsigned long )bitstream != (unsigned long )((void *)0)) {
#line 279
    if ((unsigned long )pc != (unsigned long )((void *)0)) {
#line 279
      if (! ((unsigned long )outNumBits != (unsigned long )((void *)0))) {
#line 279
        return (-50);
      }
    } else {
#line 279
      return (-50);
    }
  } else {
#line 279
    return (-50);
  }
#line 280
  *outNumBits = (uint32_t )0;
#line 282
  in = bitstream->cur;
#line 283
  startPos = bitstream->bitIndex;
#line 284
  maxPos = bitstream->byteSize * 8U;
#line 285
  bitPos = startPos;
#line 287
  mb = params->mb0;
#line 288
  zmode = 0;
#line 290
  c = (uint32_t )0;
#line 291
  status = 0;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;

#line 293
    if (! (c < (uint32_t )numSamples)) {
#line 293
      goto while_break;
    }
#line 296
    if (! (bitPos < maxPos)) {
#line 296
      status = -50;
#line 296
      goto Exit;
    }
    {
#line 298
    m = mb >> 9;
#line 299
    __cil_tmp25 = lg3a((int32_t )m);
#line 299
    k = (uint32_t )__cil_tmp25;
    }
#line 301
    if (k < kb_local) {
#line 301
      tmp = k;
    } else {
#line 301
      tmp = kb_local;
    }
    {
#line 301
    k = tmp;
#line 302
    m = (uint32_t )((1 << k) - 1);
#line 304
    __cil_tmp27 = dyn_get_32bit(in, & bitPos, (int32_t )m, (int32_t )k, maxSize);
#line 304
    n = (uint32_t )__cil_tmp27;
#line 308
    ndecode = n + (unsigned int )zmode;
#line 309
    multiplier = - ((int )(ndecode & 1U));
#line 311
    multiplier |= 1;
#line 312
    del = (int32_t )(((ndecode + 1U) >> 1) * (unsigned int )multiplier);
#line 315
    __cil_tmp30 = outPtr;
#line 315
    outPtr ++;
#line 315
    *__cil_tmp30 = del;
#line 317
    c ++;
#line 319
    mb = (pb_local * (n + (unsigned int )zmode) + mb) - (pb_local * mb >> 9);
    }
#line 322
    if (n > 65535U) {
#line 323
      mb = (uint32_t )65535;
    }
#line 325
    zmode = 0;
#line 327
    if (mb << 2 < (unsigned int )(1 << 9)) {
#line 327
      if (c < (uint32_t )numSamples) {
        {
#line 329
        zmode = 1;
#line 330
        __cil_tmp32 = lead((int32_t )mb);
#line 330
        k = (unsigned int )(__cil_tmp32 - 24) + ((mb + (unsigned int )(1 << 4)) >> 6);
#line 331
        mz = (unsigned int )((1 << k) - 1) & wb_local;
#line 333
        __cil_tmp33 = dyn_get(in, & bitPos, mz, k);
#line 333
        n = (uint32_t )__cil_tmp33;
        }
#line 335
        if (! (c + n <= (uint32_t )numSamples)) {
#line 335
          status = -50;
#line 335
          goto Exit;
        }
#line 337
        j = (uint32_t )0;
        {
#line 337
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 337
          if (! (j < n)) {
#line 337
            goto while_break___0;
          }
#line 339
          __cil_tmp34 = outPtr;
#line 339
          outPtr ++;
#line 339
          *__cil_tmp34 = 0;
#line 340
          c ++;
#line 337
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: ;
#line 343
        if (n >= 65535U) {
#line 344
          zmode = 0;
        }
#line 346
        mb = (uint32_t )0;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  Exit: 
  {
#line 351
  *outNumBits = bitPos - startPos;
#line 352
  BitBufferAdvance(bitstream, *outNumBits);
  }
#line 353
  if (! ((unsigned long )bitstream->cur <= (unsigned long )bitstream->end)) {
#line 353
    status = -50;
  }
#line 355
  return (status);
}
}
#line 34 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.c"
void BitBufferInit(BitBuffer *bits , uint8_t *buffer , uint32_t byteSize ) 
{ 


  {
#line 36
  bits->cur = buffer;
#line 37
  bits->end = bits->cur + byteSize;
#line 38
  bits->bitIndex = (uint32_t )0;
#line 39
  bits->byteSize = byteSize;
#line 40
  return;
}
}
#line 44 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.c"
uint32_t BitBufferRead(BitBuffer *bits , uint8_t numBits ) 
{ 
  uint32_t returnBits ;

  {
#line 50
  returnBits = (((uint32_t )*(bits->cur + 0) << 16) | ((uint32_t )*(bits->cur + 1) << 8)) | (uint32_t )*(bits->cur + 2);
#line 51
  returnBits <<= bits->bitIndex;
#line 52
  returnBits &= 16777215U;
#line 54
  bits->bitIndex += (unsigned int )numBits;
#line 56
  returnBits >>= 24 - (int )numBits;
#line 58
  bits->cur += bits->bitIndex >> 3;
#line 59
  bits->bitIndex &= 7U;
#line 63
  return (returnBits);
}
}
#line 69 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.c"
uint8_t BitBufferReadSmall(BitBuffer *bits , uint8_t numBits ) 
{ 
  uint16_t returnBits ;

  {
#line 75
  returnBits = (uint16_t )(((int )*(bits->cur + 0) << 8) | (int )*(bits->cur + 1));
#line 76
  returnBits = (uint16_t )((int )returnBits << bits->bitIndex);
#line 78
  bits->bitIndex += (unsigned int )numBits;
#line 80
  returnBits = (uint16_t )((int )returnBits >> (16 - (int )numBits));
#line 82
  bits->cur += bits->bitIndex >> 3;
#line 83
  bits->bitIndex &= 7U;
#line 87
  return ((uint8_t )returnBits);
}
}
#line 93 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.c"
uint8_t BitBufferReadOne(BitBuffer *bits ) 
{ 
  uint8_t returnBits ;

  {
#line 97
  returnBits = (uint8_t )(((int )*(bits->cur + 0) >> (7U - bits->bitIndex)) & 1);
#line 99
  (bits->bitIndex) ++;
#line 101
  bits->cur += bits->bitIndex >> 3;
#line 102
  bits->bitIndex &= 7U;
#line 106
  return (returnBits);
}
}
#line 111 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.c"
uint32_t BitBufferPeek(BitBuffer *bits , uint8_t numBits ) 
{ 


  {
#line 113
  return (((((((uint32_t )*(bits->cur + 0) << 16) | ((uint32_t )*(bits->cur + 1) << 8)) | (uint32_t )*(bits->cur + 2)) << bits->bitIndex) & 16777215U) >> (24 - (int )numBits));
}
}
#line 119 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.c"
uint32_t BitBufferPeekOne(BitBuffer *bits ) 
{ 


  {
#line 121
  return ((uint32_t )(((int )*(bits->cur + 0) >> (7U - bits->bitIndex)) & 1));
}
}
#line 126 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.c"
uint32_t BitBufferUnpackBERSize(BitBuffer *bits ) 
{ 
  uint32_t size ;
  uint8_t tmp ;
  uint8_t __cil_tmp4 ;

  {
#line 131
  tmp = (uint8_t )128U;
#line 131
  size = (uint32_t )0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;

#line 131
    if (! tmp) {
#line 131
      goto while_break;
    }
    {
#line 132
    __cil_tmp4 = BitBufferReadSmall(bits, (uint8_t )8);
#line 132
    tmp = __cil_tmp4;
#line 131
    size = (size << 7U) | ((unsigned int )tmp & 127U);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 134
  return (size);
}
}
#line 139 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.c"
uint32_t BitBufferGetPosition(BitBuffer *bits ) 
{ 
  uint8_t *begin ;

  {
#line 143
  begin = bits->end - bits->byteSize;
#line 145
  return ((uint32_t )(bits->cur - begin) * 8U + bits->bitIndex);
}
}
#line 150 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.c"
void BitBufferByteAlign(BitBuffer *bits , int32_t addZeros ) 
{ 


  {
#line 153
  if (bits->bitIndex == 0U) {
#line 154
    return;
  }
#line 156
  if (addZeros) {
    {
#line 157
    BitBufferWrite(bits, (uint32_t )0, 8U - bits->bitIndex);
    }
  } else {
    {
#line 159
    BitBufferAdvance(bits, 8U - bits->bitIndex);
    }
  }
#line 162
  return;
}
}
#line 164 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.c"
void BitBufferAdvance(BitBuffer *bits , uint32_t numBits ) 
{ 


  {
#line 166
  if (numBits) {
#line 168
    bits->bitIndex += numBits;
#line 169
    bits->cur += bits->bitIndex >> 3;
#line 170
    bits->bitIndex &= 7U;
  }
#line 172
  return;
}
}
#line 176 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.c"
void BitBufferRewind(BitBuffer *bits , uint32_t numBits ) 
{ 
  uint32_t numBytes ;
  uint8_t *__cil_tmp4 ;

  {
#line 180
  if (numBits == 0U) {
#line 181
    return;
  }
#line 183
  if (bits->bitIndex >= numBits) {
#line 185
    bits->bitIndex -= numBits;
#line 186
    return;
  }
#line 189
  numBits -= bits->bitIndex;
#line 190
  bits->bitIndex = (uint32_t )0;
#line 192
  numBytes = numBits / 8U;
#line 193
  numBits %= 8U;
#line 195
  bits->cur -= numBytes;
#line 197
  if (numBits > 0U) {
#line 199
    bits->bitIndex = 8U - numBits;
#line 200
    __cil_tmp4 = bits->cur;
#line 200
    (bits->cur) --;
  }
#line 203
  if ((unsigned long )bits->cur < (unsigned long )(bits->end - bits->byteSize)) {
#line 207
    bits->cur = bits->end - bits->byteSize;
#line 208
    bits->bitIndex = (uint32_t )0;
  }
#line 210
  return;
}
}
#line 214 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.c"
void BitBufferWrite(BitBuffer *bits , uint32_t bitValues , uint32_t numBits ) 
{ 
  uint32_t invBitIndex ;
  uint32_t tmp ;
  uint8_t shift ;
  uint8_t mask ;
  uint32_t curNum ;
  uint32_t tmp___8 ;

  {
#line 218
  if (! ((unsigned long )bits != (unsigned long )((void *)0))) {
#line 218
    return;
  }
#line 219
  if (! (numBits > 0U)) {
#line 219
    return;
  }
#line 221
  invBitIndex = 8U - bits->bitIndex;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;

#line 223
    if (! (numBits > 0U)) {
#line 223
      goto while_break;
    }
#line 230
    if (invBitIndex < numBits) {
#line 230
      tmp___8 = invBitIndex;
    } else {
#line 230
      tmp___8 = numBits;
    }
#line 230
    curNum = tmp___8;
#line 232
    tmp = bitValues >> (numBits - curNum);
#line 234
    shift = (uint8_t )(invBitIndex - curNum);
#line 235
    mask = (uint8_t )(255U >> (8U - curNum));
#line 236
    mask = (uint8_t )((int )mask << (int )shift);
#line 238
    *(bits->cur + 0) = (uint8_t )(((int )*(bits->cur + 0) & ~ ((int )mask)) | (((int )((uint8_t )tmp) << (int )shift) & (int )mask));
#line 239
    numBits -= curNum;
#line 242
    invBitIndex -= curNum;
#line 243
    if (invBitIndex == 0U) {
#line 245
      invBitIndex = (uint32_t )8;
#line 246
      (bits->cur) ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 250
  bits->bitIndex = 8U - invBitIndex;
#line 251
  return;
}
}
#line 253 "/root/patchweave_new/23/src/ALAC/ALACBitUtilities.c"
void BitBufferReset(BitBuffer *bits ) 
{ 


  {
#line 256
  bits->cur = bits->end - bits->byteSize;
#line 257
  bits->bitIndex = (uint32_t )0;
#line 258
  return;
}
}
#line 68 "/root/patchweave_new/23/src/G72x/g72x.h"
struct g72x_state *g72x_reader_init(int codec , int *blocksize , int *samplesperblock ) ;
#line 69
struct g72x_state *g72x_writer_init(int codec , int *blocksize , int *samplesperblock ) ;
#line 75
int g72x_decode_block(G72x_STATE *pstate , unsigned char const   *block , short *samples ) ;
#line 83
int g72x_encode_block(G72x_STATE *pstate , short *samples , unsigned char *block ) ;
#line 83 "/root/patchweave_new/23/src/G72x/g72x_priv.h"
int predictor_zero(G72x_STATE *state_ptr ) ;
#line 85
int predictor_pole(G72x_STATE *state_ptr ) ;
#line 87
int step_size(G72x_STATE *state_ptr ) ;
#line 89
int quantize(int d , int y , short *table , int size ) ;
#line 91
int reconstruct(int sign , int dqln , int y ) ;
#line 93
void update(int code_size , int y , int wi , int fi , int dq , int sr , int dqsez ,
            G72x_STATE *state_ptr ) ;
#line 95
int g721_encoder(int sl , G72x_STATE *state_ptr ) ;
#line 96
int g721_decoder(int i , G72x_STATE *state_ptr ) ;
#line 98
int g723_16_encoder(int sl , G72x_STATE *state_ptr ) ;
#line 99
int g723_16_decoder(int i , G72x_STATE *state_ptr ) ;
#line 101
int g723_24_encoder(int sl , G72x_STATE *state_ptr ) ;
#line 102
int g723_24_decoder(int i , G72x_STATE *state_ptr ) ;
#line 104
int g723_40_encoder(int sl , G72x_STATE *state_ptr ) ;
#line 105
int g723_40_decoder(int i , G72x_STATE *state_ptr ) ;
#line 107
void private_init_state(G72x_STATE *state_ptr ) ;
#line 116 "/root/patchweave_new/23/src/G72x/g72x_priv.h"
__inline static int arith_shift_left___28(int x , int shift ) 
{ 


  {
#line 117
  return ((int )((unsigned int )x << shift));
}
}
#line 40 "/root/patchweave_new/23/src/G72x/g72x.c"
static G72x_STATE *g72x_state_new(void) ;
#line 41
static int unpack_bytes(int bits , int blocksize , unsigned char const   *block ,
                        short *samples ) ;
#line 42
static int pack_bytes(int bits , short const   *samples , unsigned char *block ) ;
#line 45 "/root/patchweave_new/23/src/G72x/g72x.c"
static short power2[15]  = 
#line 45
  {      (short)1,      (short)2,      (short)4,      (short)8, 
        (short)16,      (short)32,      (short)64,      (short)128, 
        (short)256,      (short)512,      (short)1024,      (short)2048, 
        (short)4096,      (short)8192,      (short)16384};
#line 59 "/root/patchweave_new/23/src/G72x/g72x.c"
static int quan(int val , short *table , int size ) 
{ 
  int i ;
  short *__cil_tmp5 ;

  {
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;

#line 63
    if (! (i < size)) {
#line 63
      goto while_break;
    }
#line 64
    __cil_tmp5 = table;
#line 64
    table ++;
#line 64
    if (val < (int )*__cil_tmp5) {
#line 65
      goto while_break;
    }
#line 63
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 66
  return (i);
}
}
#line 76 "/root/patchweave_new/23/src/G72x/g72x.c"
static int fmult(int an , int srn ) 
{ 
  short anmag ;
  short anexp ;
  short anmant ;
  short wanexp ;
  short wanmant ;
  short retval ;
  int tmp ;
  int __cil_tmp10 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 82
  if (an > 0) {
#line 82
    tmp = an;
  } else {
#line 82
    tmp = - an & 8191;
  }
  {
#line 82
  anmag = (short )tmp;
#line 83
  __cil_tmp10 = quan((int )anmag, power2, 15);
#line 83
  anexp = (short )(__cil_tmp10 - 6);
  }
#line 84
  if ((int )anmag == 0) {
#line 84
    tmp___1 = 32;
  } else {
#line 84
    if ((int )anexp >= 0) {
#line 84
      tmp___0 = (int )anmag >> (int )anexp;
    } else {
#line 84
      tmp___0 = (int )anmag << - ((int )anexp);
    }
#line 84
    tmp___1 = tmp___0;
  }
#line 84
  anmant = (short )tmp___1;
#line 86
  wanexp = (short )(((int )anexp + ((srn >> 6) & 15)) - 13);
#line 95
  wanmant = (short )((int )anmant * (srn & 63) >> 4);
#line 97
  if ((int )wanexp >= 0) {
#line 97
    tmp___2 = ((int )wanmant << (int )wanexp) & 32767;
  } else {
#line 97
    tmp___2 = (int )wanmant >> - ((int )wanexp);
  }
#line 97
  retval = (short )tmp___2;
#line 99
  if ((an ^ srn) < 0) {
#line 99
    tmp___3 = - ((int )retval);
  } else {
#line 99
    tmp___3 = (int )retval;
  }
#line 99
  return (tmp___3);
}
}
#line 102 "/root/patchweave_new/23/src/G72x/g72x.c"
static G72x_STATE *g72x_state_new(void) 
{ 
  void *__cil_tmp1 ;

  {
  {
#line 103
  __cil_tmp1 = calloc(1UL, sizeof(G72x_STATE ));
  }
#line 103
  return ((G72x_STATE *)__cil_tmp1);
}
}
#line 113 "/root/patchweave_new/23/src/G72x/g72x.c"
void private_init_state(G72x_STATE *state_ptr ) 
{ 
  int cnta ;

  {
#line 117
  state_ptr->yl = 34816L;
#line 118
  state_ptr->yu = (short)544;
#line 119
  state_ptr->dms = (short)0;
#line 120
  state_ptr->dml = (short)0;
#line 121
  state_ptr->ap = (short)0;
#line 122
  cnta = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;

#line 122
    if (! (cnta < 2)) {
#line 122
      goto while_break;
    }
#line 123
    state_ptr->a[cnta] = (short)0;
#line 124
    state_ptr->pk[cnta] = (short)0;
#line 125
    state_ptr->sr[cnta] = (short)32;
#line 122
    cnta ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 127
  cnta = 0;
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 127
    if (! (cnta < 6)) {
#line 127
      goto while_break___0;
    }
#line 128
    state_ptr->b[cnta] = (short)0;
#line 129
    state_ptr->dq[cnta] = (short)32;
#line 127
    cnta ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
#line 131
  state_ptr->td = (char)0;
#line 132
  return;
}
}
#line 134 "/root/patchweave_new/23/src/G72x/g72x.c"
struct g72x_state *g72x_reader_init(int codec , int *blocksize , int *samplesperblock ) 
{ 
  G72x_STATE *pstate ;

  {
  {
#line 137
  pstate = g72x_state_new();
  }
#line 137
  if ((unsigned long )pstate == (unsigned long )((void *)0)) {
#line 138
    return ((struct g72x_state *)((void *)0));
  }
  {
#line 140
  private_init_state(pstate);
#line 142
  pstate->encoder = (int (*)(int  , struct g72x_state * ))((void *)0);
  }
#line 145
  if (codec == 2) {
#line 145
    goto case_2;
  }
#line 154
  if (codec == 3) {
#line 154
    goto case_3;
  }
#line 163
  if (codec == 4) {
#line 163
    goto case_4;
  }
#line 172
  if (codec == 5) {
#line 172
    goto case_5;
  }
#line 181
  goto switch_default;
  case_2: 
#line 146
  pstate->decoder = & g723_16_decoder;
#line 147
  *blocksize = 30;
#line 148
  *samplesperblock = 120;
#line 149
  pstate->codec_bits = 2;
#line 150
  pstate->blocksize = 30;
#line 151
  pstate->samplesperblock = 120;
#line 152
  goto switch_break;
  case_3: 
#line 155
  pstate->decoder = & g723_24_decoder;
#line 156
  *blocksize = 45;
#line 157
  *samplesperblock = 120;
#line 158
  pstate->codec_bits = 3;
#line 159
  pstate->blocksize = 45;
#line 160
  pstate->samplesperblock = 120;
#line 161
  goto switch_break;
  case_4: 
#line 164
  pstate->decoder = & g721_decoder;
#line 165
  *blocksize = 60;
#line 166
  *samplesperblock = 120;
#line 167
  pstate->codec_bits = 4;
#line 168
  pstate->blocksize = 60;
#line 169
  pstate->samplesperblock = 120;
#line 170
  goto switch_break;
  case_5: 
#line 173
  pstate->decoder = & g723_40_decoder;
#line 174
  *blocksize = 75;
#line 175
  *samplesperblock = 120;
#line 176
  pstate->codec_bits = 5;
#line 177
  pstate->blocksize = 75;
#line 178
  pstate->samplesperblock = 120;
#line 179
  goto switch_break;
  switch_default: 
  {
#line 182
  free((void *)pstate);
  }
#line 183
  return ((struct g72x_state *)((void *)0));
  switch_break: ;
#line 186
  return (pstate);
}
}
#line 189 "/root/patchweave_new/23/src/G72x/g72x.c"
struct g72x_state *g72x_writer_init(int codec , int *blocksize , int *samplesperblock ) 
{ 
  G72x_STATE *pstate ;

  {
  {
#line 192
  pstate = g72x_state_new();
  }
#line 192
  if ((unsigned long )pstate == (unsigned long )((void *)0)) {
#line 193
    return ((struct g72x_state *)((void *)0));
  }
  {
#line 195
  private_init_state(pstate);
#line 196
  pstate->decoder = (int (*)(int  , struct g72x_state * ))((void *)0);
  }
#line 199
  if (codec == 2) {
#line 199
    goto case_2;
  }
#line 208
  if (codec == 3) {
#line 208
    goto case_3;
  }
#line 217
  if (codec == 4) {
#line 217
    goto case_4;
  }
#line 226
  if (codec == 5) {
#line 226
    goto case_5;
  }
#line 235
  goto switch_default;
  case_2: 
#line 200
  pstate->encoder = & g723_16_encoder;
#line 201
  *blocksize = 30;
#line 202
  *samplesperblock = 120;
#line 203
  pstate->codec_bits = 2;
#line 204
  pstate->blocksize = 30;
#line 205
  pstate->samplesperblock = 120;
#line 206
  goto switch_break;
  case_3: 
#line 209
  pstate->encoder = & g723_24_encoder;
#line 210
  *blocksize = 45;
#line 211
  *samplesperblock = 120;
#line 212
  pstate->codec_bits = 3;
#line 213
  pstate->blocksize = 45;
#line 214
  pstate->samplesperblock = 120;
#line 215
  goto switch_break;
  case_4: 
#line 218
  pstate->encoder = & g721_encoder;
#line 219
  *blocksize = 60;
#line 220
  *samplesperblock = 120;
#line 221
  pstate->codec_bits = 4;
#line 222
  pstate->blocksize = 60;
#line 223
  pstate->samplesperblock = 120;
#line 224
  goto switch_break;
  case_5: 
#line 227
  pstate->encoder = & g723_40_encoder;
#line 228
  *blocksize = 75;
#line 229
  *samplesperblock = 120;
#line 230
  pstate->codec_bits = 5;
#line 231
  pstate->blocksize = 75;
#line 232
  pstate->samplesperblock = 120;
#line 233
  goto switch_break;
  switch_default: 
  {
#line 236
  free((void *)pstate);
  }
#line 237
  return ((struct g72x_state *)((void *)0));
  switch_break: ;
#line 240
  return (pstate);
}
}
#line 243 "/root/patchweave_new/23/src/G72x/g72x.c"
int g72x_decode_block(G72x_STATE *pstate , unsigned char const   *block , short *samples ) 
{ 
  int k ;
  int count___0 ;
  int __cil_tmp7 ;

  {
  {
#line 246
  count___0 = unpack_bytes(pstate->codec_bits, pstate->blocksize, block, samples);
#line 248
  k = 0;
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;

#line 248
    if (! (k < count___0)) {
#line 248
      goto while_break;
    }
    {
#line 249
    __cil_tmp7 = (*(pstate->decoder))((int )*(samples + k), pstate);
#line 249
    *(samples + k) = (short )__cil_tmp7;
#line 248
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 251
  return (0);
}
}
#line 254 "/root/patchweave_new/23/src/G72x/g72x.c"
int g72x_encode_block(G72x_STATE *pstate , short *samples , unsigned char *block ) 
{ 
  int k ;
  int count___0 ;
  int __cil_tmp6 ;

  {
#line 257
  k = 0;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;

#line 257
    if (! (k < pstate->samplesperblock)) {
#line 257
      goto while_break;
    }
    {
#line 258
    __cil_tmp6 = (*(pstate->encoder))((int )*(samples + k), pstate);
#line 258
    *(samples + k) = (short )__cil_tmp6;
#line 257
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 260
  count___0 = pack_bytes(pstate->codec_bits, (short const   *)samples, block);
  }
#line 262
  return (count___0);
}
}
#line 271 "/root/patchweave_new/23/src/G72x/g72x.c"
int predictor_zero(G72x_STATE *state_ptr ) 
{ 
  int i ;
  int sezi ;
  int __cil_tmp5 ;

  {
  {
#line 276
  sezi = fmult((int )state_ptr->b[0] >> 2, (int )state_ptr->dq[0]);
#line 277
  i = 1;
  }
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;

#line 277
    if (! (i < 6)) {
#line 277
      goto while_break;
    }
    {
#line 278
    __cil_tmp5 = fmult((int )state_ptr->b[i] >> 2, (int )state_ptr->dq[i]);
#line 278
    sezi += __cil_tmp5;
#line 277
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 279
  return (sezi);
}
}
#line 287 "/root/patchweave_new/23/src/G72x/g72x.c"
int predictor_pole(G72x_STATE *state_ptr ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 289
  __cil_tmp3 = fmult((int )state_ptr->a[0] >> 2, (int )state_ptr->sr[0]);
#line 289
  __cil_tmp2 = fmult((int )state_ptr->a[1] >> 2, (int )state_ptr->sr[1]);
  }
#line 289
  return (__cil_tmp2 + __cil_tmp3);
}
}
#line 298 "/root/patchweave_new/23/src/G72x/g72x.c"
int step_size(G72x_STATE *state_ptr ) 
{ 
  int y ;
  int dif ;
  int al ;

  {
#line 304
  if ((int )state_ptr->ap >= 256) {
#line 305
    return ((int )state_ptr->yu);
  } else {
#line 307
    y = (int )(state_ptr->yl >> 6);
#line 308
    dif = (int )state_ptr->yu - y;
#line 309
    al = (int )state_ptr->ap >> 2;
#line 310
    if (dif > 0) {
#line 311
      y += dif * al >> 6;
    } else
#line 312
    if (dif < 0) {
#line 313
      y += (dif * al + 63) >> 6;
    }
#line 314
    return (y);
  }
}
}
#line 327 "/root/patchweave_new/23/src/G72x/g72x.c"
int quantize(int d , int y , short *table , int size ) 
{ 
  short dqm ;
  short expon ;
  short mant ;
  short dl ;
  short dln ;
  int i ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 345
  __cil_tmp11 = abs(d);
#line 345
  dqm = (short )__cil_tmp11;
#line 346
  __cil_tmp12 = quan((int )dqm >> 1, power2, 15);
#line 346
  expon = (short )__cil_tmp12;
#line 347
  mant = (short )((((int )dqm << 7) >> (int )expon) & 127);
#line 348
  dl = (short )(((int )expon << 7) + (int )mant);
#line 355
  dln = (short )((int )dl - (y >> 2));
#line 362
  i = quan((int )dln, table, size);
  }
#line 363
  if (d < 0) {
#line 364
    return (((size << 1) + 1) - i);
  } else
#line 365
  if (i == 0) {
#line 366
    return ((size << 1) + 1);
  }
#line 368
  return (i);
}
}
#line 378 "/root/patchweave_new/23/src/G72x/g72x.c"
int reconstruct(int sign , int dqln , int y ) 
{ 
  short dql ;
  short dex ;
  short dqt ;
  short dq ;
  int tmp ;
  int tmp___0 ;

  {
#line 388
  dql = (short )(dqln + (y >> 2));
#line 390
  if ((int )dql < 0) {
#line 391
    if (sign) {
#line 391
      tmp = -32768;
    } else {
#line 391
      tmp = 0;
    }
#line 391
    return (tmp);
  } else {
#line 393
    dex = (short )(((int )dql >> 7) & 15);
#line 394
    dqt = (short )(128 + ((int )dql & 127));
#line 395
    dq = (short )(((int )dqt << 7) >> (14 - (int )dex));
#line 396
    if (sign) {
#line 396
      tmp___0 = (int )dq - 32768;
    } else {
#line 396
      tmp___0 = (int )dq;
    }
#line 396
    return (tmp___0);
  }
}
}
#line 407 "/root/patchweave_new/23/src/G72x/g72x.c"
void update(int code_size , int y , int wi , int fi , int dq , int sr , int dqsez ,
            G72x_STATE *state_ptr ) 
{ 
  int cnt ;
  short mag ;
  short expon ;
  short a2p ;
  short a1ul ;
  short pks1 ;
  short fa1 ;
  char tr ;
  short ylint ;
  short thr2 ;
  short dqthr ;
  short ylfrac ;
  short thr1 ;
  short pk0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp27 ;
  int tmp___2 ;
  int __cil_tmp29 ;
  int tmp___3 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;

  {
#line 419
  a2p = (short)0;
#line 428
  if (dqsez < 0) {
#line 428
    tmp = 1;
  } else {
#line 428
    tmp = 0;
  }
#line 428
  pk0 = (short )tmp;
#line 430
  mag = (short )(dq & 32767);
#line 432
  ylint = (short )(state_ptr->yl >> 15);
#line 433
  ylfrac = (short )((state_ptr->yl >> 10) & 31L);
#line 434
  thr1 = (short )((32 + (int )ylfrac) << (int )ylint);
#line 435
  if ((int )ylint > 9) {
#line 435
    tmp___0 = 31 << 10;
  } else {
#line 435
    tmp___0 = (int )thr1;
  }
#line 435
  thr2 = (short )tmp___0;
#line 436
  dqthr = (short )(((int )thr2 + ((int )thr2 >> 1)) >> 1);
#line 437
  if ((int )state_ptr->td == 0) {
#line 438
    tr = (char)0;
  } else
#line 439
  if ((int )mag <= (int )dqthr) {
#line 440
    tr = (char)0;
  } else {
#line 442
    tr = (char)1;
  }
#line 450
  state_ptr->yu = (short )(y + ((wi - y) >> 5));
#line 453
  if ((int )state_ptr->yu < 544) {
#line 454
    state_ptr->yu = (short)544;
  } else
#line 455
  if ((int )state_ptr->yu > 5120) {
#line 456
    state_ptr->yu = (short)5120;
  }
#line 460
  state_ptr->yl += (long )state_ptr->yu + (- state_ptr->yl >> 6);
#line 465
  if ((int )tr == 1) {
#line 466
    state_ptr->a[0] = (short)0;
#line 467
    state_ptr->a[1] = (short)0;
#line 468
    state_ptr->b[0] = (short)0;
#line 469
    state_ptr->b[1] = (short)0;
#line 470
    state_ptr->b[2] = (short)0;
#line 471
    state_ptr->b[3] = (short)0;
#line 472
    state_ptr->b[4] = (short)0;
#line 473
    state_ptr->b[5] = (short)0;
  } else {
#line 476
    pks1 = (short )((int )pk0 ^ (int )state_ptr->pk[0]);
#line 479
    a2p = (short )((int )state_ptr->a[1] - ((int )state_ptr->a[1] >> 7));
#line 480
    if (dqsez != 0) {
#line 481
      if ((int )pks1) {
#line 481
        tmp___1 = (int )state_ptr->a[0];
      } else {
#line 481
        tmp___1 = - ((int )state_ptr->a[0]);
      }
#line 481
      fa1 = (short )tmp___1;
#line 482
      if ((int )fa1 < -8191) {
#line 483
        a2p = (short )((int )a2p - 256);
      } else
#line 484
      if ((int )fa1 > 8191) {
#line 485
        a2p = (short )((int )a2p + 255);
      } else {
#line 487
        a2p = (short )((int )a2p + ((int )fa1 >> 5));
      }
#line 489
      if ((int )pk0 ^ (int )state_ptr->pk[1]) {
#line 491
        if ((int )a2p <= -12160) {
#line 492
          a2p = (short)-12288;
        } else
#line 493
        if ((int )a2p >= 12416) {
#line 494
          a2p = (short)12288;
        } else {
#line 496
          a2p = (short )((int )a2p - 128);
        }
      } else
#line 498
      if ((int )a2p <= -12416) {
#line 499
        a2p = (short)-12288;
      } else
#line 500
      if ((int )a2p >= 12160) {
#line 501
        a2p = (short)12288;
      } else {
#line 503
        a2p = (short )((int )a2p + 128);
      }
    }
#line 507
    state_ptr->a[1] = a2p;
#line 511
    state_ptr->a[0] = (short )((int )state_ptr->a[0] - ((int )state_ptr->a[0] >> 8));
#line 512
    if (dqsez != 0) {
#line 513
      if ((int )pks1 == 0) {
#line 514
        state_ptr->a[0] = (short )((int )state_ptr->a[0] + 192);
      } else {
#line 516
        state_ptr->a[0] = (short )((int )state_ptr->a[0] - 192);
      }
    }
#line 520
    a1ul = (short )(15360 - (int )a2p);
#line 521
    if ((int )state_ptr->a[0] < - ((int )a1ul)) {
#line 522
      state_ptr->a[0] = (short )(- ((int )a1ul));
    } else
#line 523
    if ((int )state_ptr->a[0] > (int )a1ul) {
#line 524
      state_ptr->a[0] = a1ul;
    }
#line 527
    cnt = 0;
    {
#line 527
    while (1) {
      while_continue: /* CIL Label */ ;

#line 527
      if (! (cnt < 6)) {
#line 527
        goto while_break;
      }
#line 528
      if (code_size == 5) {
#line 529
        state_ptr->b[cnt] = (short )((int )state_ptr->b[cnt] - ((int )state_ptr->b[cnt] >> 9));
      } else {
#line 531
        state_ptr->b[cnt] = (short )((int )state_ptr->b[cnt] - ((int )state_ptr->b[cnt] >> 8));
      }
#line 532
      if (dq & 32767) {
#line 533
        if ((dq ^ (int )state_ptr->dq[cnt]) >= 0) {
#line 534
          state_ptr->b[cnt] = (short )((int )state_ptr->b[cnt] + 128);
        } else {
#line 536
          state_ptr->b[cnt] = (short )((int )state_ptr->b[cnt] - 128);
        }
      }
#line 527
      cnt ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 541
  cnt = 5;
  {
#line 541
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 541
    if (! (cnt > 0)) {
#line 541
      goto while_break___0;
    }
#line 542
    state_ptr->dq[cnt] = state_ptr->dq[cnt - 1];
#line 541
    __cil_tmp27 = cnt;
#line 541
    cnt --;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 544
  if ((int )mag == 0) {
#line 545
    if (dq >= 0) {
#line 545
      tmp___2 = 32;
    } else {
#line 545
      tmp___2 = 64544;
    }
#line 545
    state_ptr->dq[0] = (short )tmp___2;
  } else {
    {
#line 547
    __cil_tmp29 = quan((int )mag, power2, 15);
#line 547
    expon = (short )__cil_tmp29;
    }
#line 548
    if (dq >= 0) {
#line 548
      tmp___3 = ((int )expon << 6) + (((int )mag << 6) >> (int )expon);
    } else {
#line 548
      tmp___3 = (((int )expon << 6) + (((int )mag << 6) >> (int )expon)) - 1024;
    }
#line 548
    state_ptr->dq[0] = (short )tmp___3;
  }
#line 553
  state_ptr->sr[1] = state_ptr->sr[0];
#line 555
  if (sr == 0) {
#line 556
    state_ptr->sr[0] = (short)32;
  } else
#line 557
  if (sr > 0) {
    {
#line 558
    __cil_tmp31 = quan(sr, power2, 15);
#line 558
    expon = (short )__cil_tmp31;
#line 559
    state_ptr->sr[0] = (short )(((int )expon << 6) + ((sr << 6) >> (int )expon));
    }
  } else
#line 561
  if (sr > -32768) {
    {
#line 562
    mag = (short )(- sr);
#line 563
    __cil_tmp32 = quan((int )mag, power2, 15);
#line 563
    expon = (short )__cil_tmp32;
#line 564
    state_ptr->sr[0] = (short )((((int )expon << 6) + (((int )mag << 6) >> (int )expon)) - 1024);
    }
  } else {
#line 567
    state_ptr->sr[0] = (short)-992;
  }
#line 570
  state_ptr->pk[1] = state_ptr->pk[0];
#line 571
  state_ptr->pk[0] = pk0;
#line 574
  if ((int )tr == 1) {
#line 575
    state_ptr->td = (char)0;
  } else
#line 576
  if ((int )a2p < -11776) {
#line 577
    state_ptr->td = (char)1;
  } else {
#line 579
    state_ptr->td = (char)0;
  }
#line 584
  state_ptr->dms = (short )((int )state_ptr->dms + ((fi - (int )state_ptr->dms) >> 5));
#line 585
  state_ptr->dml = (short )((int )state_ptr->dml + (((fi << 2) - (int )state_ptr->dml) >> 7));
#line 587
  if ((int )tr == 1) {
#line 588
    state_ptr->ap = (short)256;
  } else
#line 589
  if (y < 1536) {
#line 590
    state_ptr->ap = (short )((int )state_ptr->ap + ((512 - (int )state_ptr->ap) >> 4));
  } else
#line 591
  if ((int )state_ptr->td == 1) {
#line 592
    state_ptr->ap = (short )((int )state_ptr->ap + ((512 - (int )state_ptr->ap) >> 4));
  } else {
    {
#line 593
    __cil_tmp33 = abs(((int )state_ptr->dms << 2) - (int )state_ptr->dml);
    }
#line 593
    if (__cil_tmp33 >= (int )state_ptr->dml >> 3) {
#line 594
      state_ptr->ap = (short )((int )state_ptr->ap + ((512 - (int )state_ptr->ap) >> 4));
    } else {
#line 596
      state_ptr->ap = (short )((int )state_ptr->ap + (- ((int )state_ptr->ap) >> 4));
    }
  }
#line 598
  return;
}
}
#line 605 "/root/patchweave_new/23/src/G72x/g72x.c"
static int unpack_bytes(int bits , int blocksize , unsigned char const   *block ,
                        short *samples ) 
{ 
  unsigned int in_buffer ;
  unsigned char in_byte ;
  int k ;
  int in_bits ;
  int bindex ;
  int __cil_tmp10 ;

  {
#line 606
  in_buffer = 0U;
#line 608
  in_bits = 0;
#line 608
  bindex = 0;
#line 610
  k = 0;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;

#line 610
    if (bindex <= blocksize) {
#line 610
      if (! (k < 120)) {
#line 610
        goto while_break;
      }
    } else {
#line 610
      goto while_break;
    }
#line 611
    if (in_bits < bits) {
#line 612
      __cil_tmp10 = bindex;
#line 612
      bindex ++;
#line 612
      in_byte = (unsigned char )*(block + __cil_tmp10);
#line 614
      in_buffer |= (unsigned int )((int )in_byte << in_bits);
#line 615
      in_bits += 8;
    }
#line 617
    *(samples + k) = (short )(in_buffer & (unsigned int )((1 << bits) - 1));
#line 618
    in_buffer >>= bits;
#line 619
    in_bits -= bits;
#line 610
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 622
  return (k);
}
}
#line 626 "/root/patchweave_new/23/src/G72x/g72x.c"
static int pack_bytes(int bits , short const   *samples , unsigned char *block ) 
{ 
  unsigned int out_buffer ;
  int k ;
  int bindex ;
  int out_bits ;
  unsigned char out_byte ;
  int __cil_tmp9 ;

  {
#line 628
  out_buffer = 0U;
#line 629
  bindex = 0;
#line 629
  out_bits = 0;
#line 632
  k = 0;
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;

#line 632
    if (! (k < 120)) {
#line 632
      goto while_break;
    }
#line 633
    out_buffer |= (unsigned int )((int )*(samples + k) << out_bits);
#line 634
    out_bits += bits;
#line 635
    if (out_bits >= 8) {
#line 636
      out_byte = (unsigned char )(out_buffer & 255U);
#line 637
      out_bits -= 8;
#line 638
      out_buffer >>= 8;
#line 639
      __cil_tmp9 = bindex;
#line 639
      bindex ++;
#line 639
      *(block + __cil_tmp9) = out_byte;
    }
#line 632
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 643
  return (bindex);
}
}
#line 56 "/root/patchweave_new/23/src/G72x/g723_40.c"
static short _dqlntab[32]  = 
#line 56 "/root/patchweave_new/23/src/G72x/g723_40.c"
  {      (short)-2048,      (short)-66,      (short)28,      (short)104, 
        (short)169,      (short)224,      (short)274,      (short)318, 
        (short)358,      (short)395,      (short)429,      (short)459, 
        (short)488,      (short)514,      (short)539,      (short)566, 
        (short)566,      (short)539,      (short)514,      (short)488, 
        (short)459,      (short)429,      (short)395,      (short)358, 
        (short)318,      (short)274,      (short)224,      (short)169, 
        (short)104,      (short)28,      (short)-66,      (short)-2048};
#line 62 "/root/patchweave_new/23/src/G72x/g723_40.c"
static short _witab[32]  = 
#line 62
  {      (short)448,      (short)448,      (short)768,      (short)1248, 
        (short)1280,      (short)1312,      (short)1856,      (short)3200, 
        (short)4512,      (short)5728,      (short)7008,      (short)8960, 
        (short)11456,      (short)14080,      (short)16928,      (short)22272, 
        (short)22272,      (short)16928,      (short)14080,      (short)11456, 
        (short)8960,      (short)7008,      (short)5728,      (short)4512, 
        (short)3200,      (short)1856,      (short)1312,      (short)1280, 
        (short)1248,      (short)768,      (short)448,      (short)448};
#line 72 "/root/patchweave_new/23/src/G72x/g723_40.c"
static short _fitab[32]  = 
#line 72
  {      (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)512,      (short)512,      (short)512, 
        (short)512,      (short)512,      (short)1024,      (short)1536, 
        (short)2048,      (short)2560,      (short)3072,      (short)3072, 
        (short)3072,      (short)3072,      (short)2560,      (short)2048, 
        (short)1536,      (short)1024,      (short)512,      (short)512, 
        (short)512,      (short)512,      (short)512,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0};
#line 77 "/root/patchweave_new/23/src/G72x/g723_40.c"
static short qtab_723_40[15]  = 
#line 77
  {      (short)-122,      (short)-16,      (short)68,      (short)139, 
        (short)198,      (short)250,      (short)298,      (short)339, 
        (short)378,      (short)413,      (short)445,      (short)475, 
        (short)502,      (short)528,      (short)553};
#line 87 "/root/patchweave_new/23/src/G72x/g723_40.c"
int g723_40_encoder(int sl , G72x_STATE *state_ptr ) 
{ 
  short sei ;
  short sezi ;
  short se ;
  short sez ;
  short d ;
  short y ;
  short sr ;
  short dqsez ;
  short dq ;
  short i ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp ;

  {
  {
#line 97
  sl >>= 2;
#line 99
  __cil_tmp13 = predictor_zero(state_ptr);
#line 99
  sezi = (short )__cil_tmp13;
#line 100
  sez = (short )((int )sezi >> 1);
#line 101
  __cil_tmp14 = predictor_pole(state_ptr);
#line 101
  sei = (short )((int )sezi + __cil_tmp14);
#line 102
  se = (short )((int )sei >> 1);
#line 104
  d = (short )(sl - (int )se);
#line 107
  __cil_tmp15 = step_size(state_ptr);
#line 107
  y = (short )__cil_tmp15;
#line 108
  __cil_tmp16 = quantize((int )d, (int )y, qtab_723_40, 15);
#line 108
  i = (short )__cil_tmp16;
#line 110
  __cil_tmp17 = reconstruct((int )i & 16, (int )_dqlntab[i], (int )y);
#line 110
  dq = (short )__cil_tmp17;
  }
#line 112
  if ((int )dq < 0) {
#line 112
    tmp = (int )se - ((int )dq & 32767);
  } else {
#line 112
    tmp = (int )se + (int )dq;
  }
  {
#line 112
  sr = (short )tmp;
#line 114
  dqsez = (short )(((int )sr + (int )sez) - (int )se);
#line 116
  update(5, (int )y, (int )_witab[i], (int )_fitab[i], (int )dq, (int )sr, (int )dqsez,
         state_ptr);
  }
#line 118
  return ((int )i);
}
}
#line 128 "/root/patchweave_new/23/src/G72x/g723_40.c"
int g723_40_decoder(int i , G72x_STATE *state_ptr ) 
{ 
  short sezi ;
  short sei ;
  short sez ;
  short se ;
  short y ;
  short sr ;
  short dq ;
  short dqsez ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;

  {
  {
#line 136
  i &= 31;
#line 137
  __cil_tmp11 = predictor_zero(state_ptr);
#line 137
  sezi = (short )__cil_tmp11;
#line 138
  sez = (short )((int )sezi >> 1);
#line 139
  __cil_tmp12 = predictor_pole(state_ptr);
#line 139
  sei = (short )((int )sezi + __cil_tmp12);
#line 140
  se = (short )((int )sei >> 1);
#line 142
  __cil_tmp13 = step_size(state_ptr);
#line 142
  y = (short )__cil_tmp13;
#line 143
  __cil_tmp14 = reconstruct(i & 16, (int )_dqlntab[i], (int )y);
#line 143
  dq = (short )__cil_tmp14;
  }
#line 145
  if ((int )dq < 0) {
#line 145
    tmp = (int )se - ((int )dq & 32767);
  } else {
#line 145
    tmp = (int )se + (int )dq;
  }
  {
#line 145
  sr = (short )tmp;
#line 147
  dqsez = (short )(((int )sr - (int )se) + (int )sez);
#line 149
  update(5, (int )y, (int )_witab[i], (int )_fitab[i], (int )dq, (int )sr, (int )dqsez,
         state_ptr);
#line 151
  __cil_tmp16 = arith_shift_left___28((int )sr, 2);
  }
#line 151
  return (__cil_tmp16);
}
}
#line 48 "/root/patchweave_new/23/src/G72x/g723_24.c"
static short _dqlntab___0[8]  = 
#line 48 "/root/patchweave_new/23/src/G72x/g723_24.c"
  {      (short)-2048,      (short)135,      (short)273,      (short)373, 
        (short)373,      (short)273,      (short)135,      (short)-2048};
#line 51 "/root/patchweave_new/23/src/G72x/g723_24.c"
static short _witab___0[8]  = 
#line 51
  {      (short)-128,      (short)960,      (short)4384,      (short)18624, 
        (short)18624,      (short)4384,      (short)960,      (short)-128};
#line 58 "/root/patchweave_new/23/src/G72x/g723_24.c"
static short _fitab___0[8]  = 
#line 58
  {      (short)0,      (short)512,      (short)1024,      (short)3584, 
        (short)3584,      (short)1024,      (short)512,      (short)0};
#line 60 "/root/patchweave_new/23/src/G72x/g723_24.c"
static short qtab_723_24[3]  = {      (short)8,      (short)218,      (short)331};
#line 69 "/root/patchweave_new/23/src/G72x/g723_24.c"
int g723_24_encoder(int sl , G72x_STATE *state_ptr ) 
{ 
  short sei ;
  short sezi ;
  short se ;
  short sez ;
  short d ;
  short y ;
  short sr ;
  short dqsez ;
  short dq ;
  short i ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp ;

  {
  {
#line 81
  sl >>= 2;
#line 83
  __cil_tmp13 = predictor_zero(state_ptr);
#line 83
  sezi = (short )__cil_tmp13;
#line 84
  sez = (short )((int )sezi >> 1);
#line 85
  __cil_tmp14 = predictor_pole(state_ptr);
#line 85
  sei = (short )((int )sezi + __cil_tmp14);
#line 86
  se = (short )((int )sei >> 1);
#line 88
  d = (short )(sl - (int )se);
#line 91
  __cil_tmp15 = step_size(state_ptr);
#line 91
  y = (short )__cil_tmp15;
#line 92
  __cil_tmp16 = quantize((int )d, (int )y, qtab_723_24, 3);
#line 92
  i = (short )__cil_tmp16;
#line 93
  __cil_tmp17 = reconstruct((int )i & 4, (int )_dqlntab___0[i], (int )y);
#line 93
  dq = (short )__cil_tmp17;
  }
#line 95
  if ((int )dq < 0) {
#line 95
    tmp = (int )se - ((int )dq & 16383);
  } else {
#line 95
    tmp = (int )se + (int )dq;
  }
  {
#line 95
  sr = (short )tmp;
#line 97
  dqsez = (short )(((int )sr + (int )sez) - (int )se);
#line 99
  update(3, (int )y, (int )_witab___0[i], (int )_fitab___0[i], (int )dq, (int )sr,
         (int )dqsez, state_ptr);
  }
#line 101
  return ((int )i);
}
}
#line 112 "/root/patchweave_new/23/src/G72x/g723_24.c"
int g723_24_decoder(int i , G72x_STATE *state_ptr ) 
{ 
  short sezi ;
  short sei ;
  short sez ;
  short se ;
  short y ;
  short sr ;
  short dq ;
  short dqsez ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;

  {
  {
#line 122
  i &= 7;
#line 123
  __cil_tmp11 = predictor_zero(state_ptr);
#line 123
  sezi = (short )__cil_tmp11;
#line 124
  sez = (short )((int )sezi >> 1);
#line 125
  __cil_tmp12 = predictor_pole(state_ptr);
#line 125
  sei = (short )((int )sezi + __cil_tmp12);
#line 126
  se = (short )((int )sei >> 1);
#line 128
  __cil_tmp13 = step_size(state_ptr);
#line 128
  y = (short )__cil_tmp13;
#line 129
  __cil_tmp14 = reconstruct(i & 4, (int )_dqlntab___0[i], (int )y);
#line 129
  dq = (short )__cil_tmp14;
  }
#line 131
  if ((int )dq < 0) {
#line 131
    tmp = (int )se - ((int )dq & 16383);
  } else {
#line 131
    tmp = (int )se + (int )dq;
  }
  {
#line 131
  sr = (short )tmp;
#line 133
  dqsez = (short )(((int )sr - (int )se) + (int )sez);
#line 135
  update(3, (int )y, (int )_witab___0[i], (int )_fitab___0[i], (int )dq, (int )sr,
         (int )dqsez, state_ptr);
#line 137
  __cil_tmp16 = arith_shift_left___28((int )sr, 2);
  }
#line 137
  return (__cil_tmp16);
}
}
#line 53 "/root/patchweave_new/23/src/G72x/g723_16.c"
static short _dqlntab___1[4]  = {      (short)116,      (short)365,      (short)365,      (short)116};
#line 60 "/root/patchweave_new/23/src/G72x/g723_16.c"
static short _witab___1[4]  = {      (short)-704,      (short)14048,      (short)14048,      (short)-704};
#line 69 "/root/patchweave_new/23/src/G72x/g723_16.c"
static short _fitab___1[4]  = {      (short)0,      (short)3584,      (short)3584,      (short)0};
#line 73 "/root/patchweave_new/23/src/G72x/g723_16.c"
static short qtab_723_16[1]  = {      (short)261};
#line 83 "/root/patchweave_new/23/src/G72x/g723_16.c"
int g723_16_encoder(int sl , G72x_STATE *state_ptr ) 
{ 
  short sei ;
  short sezi ;
  short se ;
  short sez ;
  short d ;
  short y ;
  short sr ;
  short dqsez ;
  short dq ;
  short i ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp ;

  {
  {
#line 95
  sl >>= 2;
#line 97
  __cil_tmp13 = predictor_zero(state_ptr);
#line 97
  sezi = (short )__cil_tmp13;
#line 98
  sez = (short )((int )sezi >> 1);
#line 99
  __cil_tmp14 = predictor_pole(state_ptr);
#line 99
  sei = (short )((int )sezi + __cil_tmp14);
#line 100
  se = (short )((int )sei >> 1);
#line 102
  d = (short )(sl - (int )se);
#line 105
  __cil_tmp15 = step_size(state_ptr);
#line 105
  y = (short )__cil_tmp15;
#line 106
  __cil_tmp16 = quantize((int )d, (int )y, qtab_723_16, 1);
#line 106
  i = (short )__cil_tmp16;
  }
#line 111
  if ((int )i == 3) {
#line 112
    if (((int )d & 32768) == 0) {
#line 113
      i = (short)0;
    }
  }
  {
#line 115
  __cil_tmp17 = reconstruct((int )i & 2, (int )_dqlntab___1[i], (int )y);
#line 115
  dq = (short )__cil_tmp17;
  }
#line 117
  if ((int )dq < 0) {
#line 117
    tmp = (int )se - ((int )dq & 16383);
  } else {
#line 117
    tmp = (int )se + (int )dq;
  }
  {
#line 117
  sr = (short )tmp;
#line 119
  dqsez = (short )(((int )sr + (int )sez) - (int )se);
#line 121
  update(2, (int )y, (int )_witab___1[i], (int )_fitab___1[i], (int )dq, (int )sr,
         (int )dqsez, state_ptr);
  }
#line 123
  return ((int )i);
}
}
#line 134 "/root/patchweave_new/23/src/G72x/g723_16.c"
int g723_16_decoder(int i , G72x_STATE *state_ptr ) 
{ 
  short sezi ;
  short sei ;
  short sez ;
  short se ;
  short y ;
  short sr ;
  short dq ;
  short dqsez ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;

  {
  {
#line 144
  i &= 3;
#line 145
  __cil_tmp11 = predictor_zero(state_ptr);
#line 145
  sezi = (short )__cil_tmp11;
#line 146
  sez = (short )((int )sezi >> 1);
#line 147
  __cil_tmp12 = predictor_pole(state_ptr);
#line 147
  sei = (short )((int )sezi + __cil_tmp12);
#line 148
  se = (short )((int )sei >> 1);
#line 150
  __cil_tmp13 = step_size(state_ptr);
#line 150
  y = (short )__cil_tmp13;
#line 151
  __cil_tmp14 = reconstruct(i & 2, (int )_dqlntab___1[i], (int )y);
#line 151
  dq = (short )__cil_tmp14;
  }
#line 153
  if ((int )dq < 0) {
#line 153
    tmp = (int )se - ((int )dq & 16383);
  } else {
#line 153
    tmp = (int )se + (int )dq;
  }
  {
#line 153
  sr = (short )tmp;
#line 155
  dqsez = (short )(((int )sr - (int )se) + (int )sez);
#line 157
  update(2, (int )y, (int )_witab___1[i], (int )_fitab___1[i], (int )dq, (int )sr,
         (int )dqsez, state_ptr);
  }
#line 160
  return ((int )sr << 2);
}
}
#line 55 "/root/patchweave_new/23/src/G72x/g721.c"
static short qtab_721[7]  = {      (short)-124,      (short)80,      (short)178,      (short)246, 
        (short)300,      (short)349,      (short)400};
#line 60 "/root/patchweave_new/23/src/G72x/g721.c"
static short _dqlntab___2[16]  = 
#line 60
  {      (short)-2048,      (short)4,      (short)135,      (short)213, 
        (short)273,      (short)323,      (short)373,      (short)425, 
        (short)425,      (short)373,      (short)323,      (short)273, 
        (short)213,      (short)135,      (short)4,      (short)-2048};
#line 64 "/root/patchweave_new/23/src/G72x/g721.c"
static short _witab___2[16]  = 
#line 64
  {      (short)-12,      (short)18,      (short)41,      (short)64, 
        (short)112,      (short)198,      (short)355,      (short)1122, 
        (short)1122,      (short)355,      (short)198,      (short)112, 
        (short)64,      (short)41,      (short)18,      (short)-12};
#line 71 "/root/patchweave_new/23/src/G72x/g721.c"
static short _fitab___2[16]  = 
#line 71
  {      (short)0,      (short)0,      (short)0,      (short)512, 
        (short)512,      (short)512,      (short)1536,      (short)3584, 
        (short)3584,      (short)1536,      (short)512,      (short)512, 
        (short)512,      (short)0,      (short)0,      (short)0};
#line 81 "/root/patchweave_new/23/src/G72x/g721.c"
int g721_encoder(int sl , G72x_STATE *state_ptr ) 
{ 
  short sezi ;
  short se ;
  short sez ;
  short d ;
  short sr ;
  short y ;
  short dqsez ;
  short dq ;
  short i ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int __cil_tmp18 ;

  {
  {
#line 93
  sl >>= 2;
#line 95
  __cil_tmp12 = predictor_zero(state_ptr);
#line 95
  sezi = (short )__cil_tmp12;
#line 96
  sez = (short )((int )sezi >> 1);
#line 97
  __cil_tmp13 = predictor_pole(state_ptr);
#line 97
  se = (short )(((int )sezi + __cil_tmp13) >> 1);
#line 99
  d = (short )(sl - (int )se);
#line 102
  __cil_tmp14 = step_size(state_ptr);
#line 102
  y = (short )__cil_tmp14;
#line 103
  __cil_tmp15 = quantize((int )d, (int )y, qtab_721, 7);
#line 103
  i = (short )__cil_tmp15;
#line 105
  __cil_tmp16 = reconstruct((int )i & 8, (int )_dqlntab___2[i], (int )y);
#line 105
  dq = (short )__cil_tmp16;
  }
#line 107
  if ((int )dq < 0) {
#line 107
    tmp = (int )se - ((int )dq & 16383);
  } else {
#line 107
    tmp = (int )se + (int )dq;
  }
  {
#line 107
  sr = (short )tmp;
#line 109
  dqsez = (short )(((int )sr + (int )sez) - (int )se);
#line 111
  __cil_tmp18 = arith_shift_left___28((int )_witab___2[i], 5);
#line 111
  update(4, (int )y, __cil_tmp18, (int )_fitab___2[i], (int )dq, (int )sr, (int )dqsez,
         state_ptr);
  }
#line 113
  return ((int )i);
}
}
#line 126 "/root/patchweave_new/23/src/G72x/g721.c"
int g721_decoder(int i , G72x_STATE *state_ptr ) 
{ 
  short sezi ;
  short sei ;
  short sez ;
  short se ;
  short y ;
  short sr ;
  short dq ;
  short dqsez ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 136
  i &= 15;
#line 137
  __cil_tmp11 = predictor_zero(state_ptr);
#line 137
  sezi = (short )__cil_tmp11;
#line 138
  sez = (short )((int )sezi >> 1);
#line 139
  __cil_tmp12 = predictor_pole(state_ptr);
#line 139
  sei = (short )((int )sezi + __cil_tmp12);
#line 140
  se = (short )((int )sei >> 1);
#line 142
  __cil_tmp13 = step_size(state_ptr);
#line 142
  y = (short )__cil_tmp13;
#line 144
  __cil_tmp14 = reconstruct(i & 8, (int )_dqlntab___2[i], (int )y);
#line 144
  dq = (short )__cil_tmp14;
  }
#line 146
  if ((int )dq < 0) {
#line 146
    tmp = (int )se - ((int )dq & 16383);
  } else {
#line 146
    tmp = (int )se + (int )dq;
  }
  {
#line 146
  sr = (short )tmp;
#line 148
  dqsez = (short )(((int )sr - (int )se) + (int )sez);
#line 150
  __cil_tmp16 = arith_shift_left___28((int )_witab___2[i], 5);
#line 150
  update(4, (int )y, __cil_tmp16, (int )_fitab___2[i], (int )dq, (int )sr, (int )dqsez,
         state_ptr);
#line 153
  __cil_tmp17 = arith_shift_left___28((int )sr, 2);
  }
#line 153
  return (__cil_tmp17);
}
}
#line 65 "/root/patchweave_new/23/src/GSM610/gsm610_priv.h"
__inline static int16_t SASR_W(int16_t x , int16_t by ) 
{ 


  {
#line 66
  if ((int )x >= 0) {
#line 67
    return ((int16_t )((int )x >> (int )by));
  }
#line 68
  return ((int16_t )(~ (~ ((int )x) >> (int )by)));
}
}
#line 72 "/root/patchweave_new/23/src/GSM610/gsm610_priv.h"
__inline static int32_t SASR_L(int32_t x , int16_t by ) 
{ 


  {
#line 73
  if (x >= 0) {
#line 74
    return (x >> (int )by);
  }
#line 75
  return (~ (~ x >> (int )by));
}
}
#line 80 "/root/patchweave_new/23/src/GSM610/gsm610_priv.h"
__inline static int16_t SASL_W(int16_t x , int16_t by ) 
{ 


  {
#line 81
  if ((int )x >= 0) {
#line 82
    return ((int16_t )((int )x << (int )by));
  }
#line 83
  return ((int16_t )(- (- ((int )x) << (int )by)));
}
}
#line 87 "/root/patchweave_new/23/src/GSM610/gsm610_priv.h"
__inline static int32_t SASL_L(int32_t x , int16_t by ) 
{ 


  {
#line 88
  if (x >= 0) {
#line 89
    return (x << (int )by);
  }
#line 90
  return (- (- x << (int )by));
}
}
#line 96
int16_t gsm_mult(int16_t a , int16_t b ) ;
#line 97
int32_t gsm_L_mult(int16_t a , int16_t b ) ;
#line 98
int16_t gsm_mult_r(int16_t a , int16_t b ) ;
#line 100
int16_t gsm_div(int16_t num , int16_t denum ) ;
#line 102
int16_t gsm_add(int16_t a , int16_t b ) ;
#line 103
int32_t gsm_L_add(int32_t a , int32_t b ) ;
#line 105
int16_t gsm_sub(int16_t a , int16_t b ) ;
#line 106
int32_t gsm_L_sub(int32_t a , int32_t b ) ;
#line 108
int16_t gsm_abs(int16_t a ) ;
#line 110
int16_t gsm_norm(int32_t a ) ;
#line 112
int32_t gsm_L_asl(int32_t a , int n ) ;
#line 113
int16_t gsm_asl(int16_t a , int n ) ;
#line 115
int32_t gsm_L_asr(int32_t a , int n ) ;
#line 116
int16_t gsm_asr(int16_t a , int n ) ;
#line 123 "/root/patchweave_new/23/src/GSM610/gsm610_priv.h"
__inline static int32_t GSM_MULT_R(int16_t a , int16_t b ) 
{ 


  {
#line 124
  return (((int32_t )a * (int32_t )b + 16384) >> 15);
}
}
#line 128 "/root/patchweave_new/23/src/GSM610/gsm610_priv.h"
__inline static int32_t GSM_MULT(int16_t a , int16_t b ) 
{ 


  {
#line 129
  return ((int32_t )a * (int32_t )b >> 15);
}
}
#line 138 "/root/patchweave_new/23/src/GSM610/gsm610_priv.h"
__inline static int32_t GSM_L_ADD(int32_t a , int32_t b ) 
{ 
  uint32_t utmp ;
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 141
  if (a < 0) {
#line 141
    if (b < 0) {
#line 142
      utmp = (uint32_t )(- (a + 1)) + (uint32_t )(- (b + 1));
#line 143
      if (utmp >= 2147483647U) {
#line 143
        tmp = (-0x7FFFFFFF-1);
      } else {
#line 143
        tmp = - ((int32_t )utmp) - 2;
      }
#line 143
      return (tmp);
    }
  }
#line 146
  if (a > 0) {
#line 146
    if (b > 0) {
#line 147
      utmp = (uint32_t )a + (uint32_t )b;
#line 148
      if (utmp >= 2147483647U) {
#line 148
        tmp___0 = 2147483647U;
      } else {
#line 148
        tmp___0 = utmp;
      }
#line 148
      return ((int32_t )tmp___0);
    }
  }
#line 151
  return (a + b);
}
}
#line 155 "/root/patchweave_new/23/src/GSM610/gsm610_priv.h"
__inline static int32_t GSM_ADD(int16_t a , int16_t b ) 
{ 
  int32_t ltmp ;

  {
#line 158
  ltmp = (int32_t )a + (int32_t )b;
#line 160
  if (ltmp >= 32767) {
#line 161
    return (32767);
  }
#line 162
  if (ltmp <= -32768) {
#line 163
    return (-32768);
  }
#line 165
  return (ltmp);
}
}
#line 169 "/root/patchweave_new/23/src/GSM610/gsm610_priv.h"
__inline static int32_t GSM_SUB(int16_t a , int16_t b ) 
{ 
  int32_t ltmp ;

  {
#line 172
  ltmp = (int32_t )a - (int32_t )b;
#line 174
  if (ltmp >= 32767) {
#line 175
    ltmp = 32767;
  } else
#line 176
  if (ltmp <= -32768) {
#line 177
    ltmp = -32768;
  }
#line 179
  return (ltmp);
}
}
#line 183 "/root/patchweave_new/23/src/GSM610/gsm610_priv.h"
__inline static int16_t GSM_ABS(int16_t a ) 
{ 


  {
#line 185
  if ((int )a > 0) {
#line 186
    return (a);
  }
#line 187
  if ((int )a == -32768) {
#line 188
    return ((int16_t )32767);
  }
#line 189
  return ((int16_t )(- ((int )a)));
}
}
#line 196
void Gsm_Coder(struct gsm_state *State , int16_t *s , int16_t *LARc , int16_t *Nc ,
               int16_t *bc , int16_t *Mc , int16_t *xmaxc , int16_t *xMc ) ;
#line 206
void Gsm_Long_Term_Predictor(struct gsm_state *S , int16_t *d , int16_t *dp , int16_t *e ,
                             int16_t *dpp , int16_t *Nc , int16_t *bc ) ;
#line 215
void Gsm_LPC_Analysis(struct gsm_state *S , int16_t *s , int16_t *LARc ) ;
#line 220
void Gsm_Preprocess(struct gsm_state *S , int16_t *s , int16_t *so ) ;
#line 232
void Gsm_Short_Term_Analysis_Filter(struct gsm_state *S , int16_t *LARc , int16_t *s ) ;
#line 237
void Gsm_Decoder(struct gsm_state *S , int16_t *LARcr , int16_t *Ncr , int16_t *bcr ,
                 int16_t *Mcr , int16_t *xmaxcr , int16_t *xMcr , int16_t *s ) ;
#line 254
void Gsm_Long_Term_Synthesis_Filtering(struct gsm_state *S , int16_t Ncr , int16_t bcr ,
                                       int16_t *erp , int16_t *drp ) ;
#line 261
void Gsm_RPE_Decoding(int16_t xmaxcr , int16_t Mcr , int16_t *xMcr , int16_t *erp ) ;
#line 268
void Gsm_RPE_Encoding(int16_t *e , int16_t *xmaxc , int16_t *Mc , int16_t *xMc ) ;
#line 275
void Gsm_Short_Term_Synthesis_Filter(struct gsm_state *S , int16_t *LARcr , int16_t *wt ,
                                     int16_t *s ) ;
#line 22 "/root/patchweave_new/23/src/GSM610/table.c"
int16_t gsm_A[8]  = 
#line 22 "/root/patchweave_new/23/src/GSM610/table.c"
  {      (int16_t )20480,      (int16_t )20480,      (int16_t )20480,      (int16_t )20480, 
        (int16_t )13964,      (int16_t )15360,      (int16_t )8534,      (int16_t )9036};
#line 23 "/root/patchweave_new/23/src/GSM610/table.c"
int16_t gsm_B[8]  = 
#line 23
  {      (int16_t )0,      (int16_t )0,      (int16_t )2048,      (int16_t )-2560, 
        (int16_t )94,      (int16_t )-1792,      (int16_t )-341,      (int16_t )-1144};
#line 24 "/root/patchweave_new/23/src/GSM610/table.c"
int16_t gsm_MIC[8]  = 
#line 24
  {      (int16_t )-32,      (int16_t )-32,      (int16_t )-16,      (int16_t )-16, 
        (int16_t )-8,      (int16_t )-8,      (int16_t )-4,      (int16_t )-4};
#line 25 "/root/patchweave_new/23/src/GSM610/table.c"
int16_t gsm_MAC[8]  = 
#line 25
  {      (int16_t )31,      (int16_t )31,      (int16_t )15,      (int16_t )15, 
        (int16_t )7,      (int16_t )7,      (int16_t )3,      (int16_t )3};
#line 30 "/root/patchweave_new/23/src/GSM610/table.c"
int16_t gsm_INVA[8]  = 
#line 30
  {      (int16_t )13107,      (int16_t )13107,      (int16_t )13107,      (int16_t )13107, 
        (int16_t )19223,      (int16_t )17476,      (int16_t )31454,      (int16_t )29708};
#line 36 "/root/patchweave_new/23/src/GSM610/table.c"
int16_t gsm_DLB[4]  = {      (int16_t )6554,      (int16_t )16384,      (int16_t )26214,      (int16_t )32767};
#line 42 "/root/patchweave_new/23/src/GSM610/table.c"
int16_t gsm_QLB[4]  = {      (int16_t )3277,      (int16_t )11469,      (int16_t )21299,      (int16_t )32767};
#line 48 "/root/patchweave_new/23/src/GSM610/table.c"
int16_t gsm_H[11]  = 
#line 48
  {      (int16_t )-134,      (int16_t )-374,      (int16_t )0,      (int16_t )2054, 
        (int16_t )5741,      (int16_t )8192,      (int16_t )5741,      (int16_t )2054, 
        (int16_t )0,      (int16_t )-374,      (int16_t )-134};
#line 54 "/root/patchweave_new/23/src/GSM610/table.c"
int16_t gsm_NRFAC[8]  = 
#line 54
  {      (int16_t )29128,      (int16_t )26215,      (int16_t )23832,      (int16_t )21846, 
        (int16_t )20165,      (int16_t )18725,      (int16_t )17476,      (int16_t )16384};
#line 60 "/root/patchweave_new/23/src/GSM610/table.c"
int16_t gsm_FAC[8]  = 
#line 60
  {      (int16_t )18431,      (int16_t )20479,      (int16_t )22527,      (int16_t )24575, 
        (int16_t )26623,      (int16_t )28671,      (int16_t )30719,      (int16_t )32767};
#line 18 "/root/patchweave_new/23/src/GSM610/short_term.c"
static void Decoding_of_the_coded_Log_Area_Ratios(int16_t *LARc , int16_t *LARpp ) 
{ 
  register int16_t temp1 ;
  int16_t *__cil_tmp4 ;
  int32_t __cil_tmp5 ;
  int32_t __cil_tmp6 ;
  int32_t __cil_tmp7 ;
  int32_t __cil_tmp8 ;
  int16_t *__cil_tmp9 ;
  int32_t __cil_tmp10 ;
  int16_t *__cil_tmp11 ;
  int32_t __cil_tmp12 ;
  int32_t __cil_tmp13 ;
  int32_t __cil_tmp14 ;
  int32_t __cil_tmp15 ;
  int16_t *__cil_tmp16 ;
  int32_t __cil_tmp17 ;
  int16_t *__cil_tmp18 ;
  int32_t __cil_tmp19 ;
  int32_t __cil_tmp20 ;
  int32_t __cil_tmp21 ;
  int32_t __cil_tmp22 ;
  int16_t *__cil_tmp23 ;
  int32_t __cil_tmp24 ;
  int16_t *__cil_tmp25 ;
  int32_t __cil_tmp26 ;
  int32_t __cil_tmp27 ;
  int32_t __cil_tmp28 ;
  int32_t __cil_tmp29 ;
  int16_t *__cil_tmp30 ;
  int32_t __cil_tmp31 ;
  int16_t *__cil_tmp32 ;
  int32_t __cil_tmp33 ;
  int32_t __cil_tmp34 ;
  int32_t __cil_tmp35 ;
  int32_t __cil_tmp36 ;
  int16_t *__cil_tmp37 ;
  int32_t __cil_tmp38 ;
  int16_t *__cil_tmp39 ;
  int32_t __cil_tmp40 ;
  int32_t __cil_tmp41 ;
  int32_t __cil_tmp42 ;
  int32_t __cil_tmp43 ;
  int16_t *__cil_tmp44 ;
  int32_t __cil_tmp45 ;
  int16_t *__cil_tmp46 ;
  int32_t __cil_tmp47 ;
  int32_t __cil_tmp48 ;
  int32_t __cil_tmp49 ;
  int32_t __cil_tmp50 ;
  int16_t *__cil_tmp51 ;
  int32_t __cil_tmp52 ;
  int16_t *__cil_tmp53 ;
  int32_t __cil_tmp54 ;
  int32_t __cil_tmp55 ;
  int32_t __cil_tmp56 ;
  int32_t __cil_tmp57 ;
  int16_t *__cil_tmp58 ;
  int32_t __cil_tmp59 ;

  {
  {
#line 54
  __cil_tmp4 = LARc;
#line 54
  LARc ++;
#line 54
  __cil_tmp5 = GSM_ADD(*__cil_tmp4, (int16_t )-32);
#line 54
  __cil_tmp6 = arith_shift_left(__cil_tmp5, 10);
#line 54
  temp1 = (int16_t )__cil_tmp6;
#line 54
  __cil_tmp7 = GSM_SUB(temp1, (int16_t )0);
#line 54
  temp1 = (int16_t )__cil_tmp7;
#line 54
  __cil_tmp8 = GSM_MULT_R((int16_t )13107, temp1);
#line 54
  temp1 = (int16_t )__cil_tmp8;
#line 54
  __cil_tmp10 = GSM_ADD(temp1, temp1);
#line 54
  __cil_tmp9 = LARpp;
#line 54
  LARpp ++;
#line 54
  *__cil_tmp9 = (int16_t )__cil_tmp10;
#line 55
  __cil_tmp11 = LARc;
#line 55
  LARc ++;
#line 55
  __cil_tmp12 = GSM_ADD(*__cil_tmp11, (int16_t )-32);
#line 55
  __cil_tmp13 = arith_shift_left(__cil_tmp12, 10);
#line 55
  temp1 = (int16_t )__cil_tmp13;
#line 55
  __cil_tmp14 = GSM_SUB(temp1, (int16_t )0);
#line 55
  temp1 = (int16_t )__cil_tmp14;
#line 55
  __cil_tmp15 = GSM_MULT_R((int16_t )13107, temp1);
#line 55
  temp1 = (int16_t )__cil_tmp15;
#line 55
  __cil_tmp17 = GSM_ADD(temp1, temp1);
#line 55
  __cil_tmp16 = LARpp;
#line 55
  LARpp ++;
#line 55
  *__cil_tmp16 = (int16_t )__cil_tmp17;
#line 56
  __cil_tmp18 = LARc;
#line 56
  LARc ++;
#line 56
  __cil_tmp19 = GSM_ADD(*__cil_tmp18, (int16_t )-16);
#line 56
  __cil_tmp20 = arith_shift_left(__cil_tmp19, 10);
#line 56
  temp1 = (int16_t )__cil_tmp20;
#line 56
  __cil_tmp21 = GSM_SUB(temp1, (int16_t )4096);
#line 56
  temp1 = (int16_t )__cil_tmp21;
#line 56
  __cil_tmp22 = GSM_MULT_R((int16_t )13107, temp1);
#line 56
  temp1 = (int16_t )__cil_tmp22;
#line 56
  __cil_tmp24 = GSM_ADD(temp1, temp1);
#line 56
  __cil_tmp23 = LARpp;
#line 56
  LARpp ++;
#line 56
  *__cil_tmp23 = (int16_t )__cil_tmp24;
#line 57
  __cil_tmp25 = LARc;
#line 57
  LARc ++;
#line 57
  __cil_tmp26 = GSM_ADD(*__cil_tmp25, (int16_t )-16);
#line 57
  __cil_tmp27 = arith_shift_left(__cil_tmp26, 10);
#line 57
  temp1 = (int16_t )__cil_tmp27;
#line 57
  __cil_tmp28 = GSM_SUB(temp1, (int16_t )-5120);
#line 57
  temp1 = (int16_t )__cil_tmp28;
#line 57
  __cil_tmp29 = GSM_MULT_R((int16_t )13107, temp1);
#line 57
  temp1 = (int16_t )__cil_tmp29;
#line 57
  __cil_tmp31 = GSM_ADD(temp1, temp1);
#line 57
  __cil_tmp30 = LARpp;
#line 57
  LARpp ++;
#line 57
  *__cil_tmp30 = (int16_t )__cil_tmp31;
#line 59
  __cil_tmp32 = LARc;
#line 59
  LARc ++;
#line 59
  __cil_tmp33 = GSM_ADD(*__cil_tmp32, (int16_t )-8);
#line 59
  __cil_tmp34 = arith_shift_left(__cil_tmp33, 10);
#line 59
  temp1 = (int16_t )__cil_tmp34;
#line 59
  __cil_tmp35 = GSM_SUB(temp1, (int16_t )188);
#line 59
  temp1 = (int16_t )__cil_tmp35;
#line 59
  __cil_tmp36 = GSM_MULT_R((int16_t )19223, temp1);
#line 59
  temp1 = (int16_t )__cil_tmp36;
#line 59
  __cil_tmp38 = GSM_ADD(temp1, temp1);
#line 59
  __cil_tmp37 = LARpp;
#line 59
  LARpp ++;
#line 59
  *__cil_tmp37 = (int16_t )__cil_tmp38;
#line 60
  __cil_tmp39 = LARc;
#line 60
  LARc ++;
#line 60
  __cil_tmp40 = GSM_ADD(*__cil_tmp39, (int16_t )-8);
#line 60
  __cil_tmp41 = arith_shift_left(__cil_tmp40, 10);
#line 60
  temp1 = (int16_t )__cil_tmp41;
#line 60
  __cil_tmp42 = GSM_SUB(temp1, (int16_t )-3584);
#line 60
  temp1 = (int16_t )__cil_tmp42;
#line 60
  __cil_tmp43 = GSM_MULT_R((int16_t )17476, temp1);
#line 60
  temp1 = (int16_t )__cil_tmp43;
#line 60
  __cil_tmp45 = GSM_ADD(temp1, temp1);
#line 60
  __cil_tmp44 = LARpp;
#line 60
  LARpp ++;
#line 60
  *__cil_tmp44 = (int16_t )__cil_tmp45;
#line 61
  __cil_tmp46 = LARc;
#line 61
  LARc ++;
#line 61
  __cil_tmp47 = GSM_ADD(*__cil_tmp46, (int16_t )-4);
#line 61
  __cil_tmp48 = arith_shift_left(__cil_tmp47, 10);
#line 61
  temp1 = (int16_t )__cil_tmp48;
#line 61
  __cil_tmp49 = GSM_SUB(temp1, (int16_t )-682);
#line 61
  temp1 = (int16_t )__cil_tmp49;
#line 61
  __cil_tmp50 = GSM_MULT_R((int16_t )31454, temp1);
#line 61
  temp1 = (int16_t )__cil_tmp50;
#line 61
  __cil_tmp52 = GSM_ADD(temp1, temp1);
#line 61
  __cil_tmp51 = LARpp;
#line 61
  LARpp ++;
#line 61
  *__cil_tmp51 = (int16_t )__cil_tmp52;
#line 62
  __cil_tmp53 = LARc;
#line 62
  LARc ++;
#line 62
  __cil_tmp54 = GSM_ADD(*__cil_tmp53, (int16_t )-4);
#line 62
  __cil_tmp55 = arith_shift_left(__cil_tmp54, 10);
#line 62
  temp1 = (int16_t )__cil_tmp55;
#line 62
  __cil_tmp56 = GSM_SUB(temp1, (int16_t )-2288);
#line 62
  temp1 = (int16_t )__cil_tmp56;
#line 62
  __cil_tmp57 = GSM_MULT_R((int16_t )29708, temp1);
#line 62
  temp1 = (int16_t )__cil_tmp57;
#line 62
  __cil_tmp59 = GSM_ADD(temp1, temp1);
#line 62
  __cil_tmp58 = LARpp;
#line 62
  LARpp ++;
#line 62
  *__cil_tmp58 = (int16_t )__cil_tmp59;
  }
#line 63
  return;
}
}
#line 85 "/root/patchweave_new/23/src/GSM610/short_term.c"
static void Coefficients_0_12(int16_t *LARpp_j_1 , int16_t *LARpp_j , int16_t *LARp ) 
{ 
  register int i ;
  int16_t __cil_tmp5 ;
  int16_t __cil_tmp6 ;
  int32_t __cil_tmp7 ;
  int16_t __cil_tmp8 ;
  int32_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int16_t *__cil_tmp11 ;
  int16_t *__cil_tmp12 ;
  int16_t *__cil_tmp13 ;

  {
#line 92
  i = 1;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;

#line 92
    if (! (i <= 8)) {
#line 92
      goto while_break;
    }
    {
#line 93
    __cil_tmp5 = SASR_W(*LARpp_j_1, (int16_t )2);
#line 93
    __cil_tmp6 = SASR_W(*LARpp_j, (int16_t )2);
#line 93
    __cil_tmp7 = GSM_ADD(__cil_tmp5, __cil_tmp6);
#line 93
    *LARp = (int16_t )__cil_tmp7;
#line 94
    __cil_tmp8 = SASR_W(*LARpp_j_1, (int16_t )1);
#line 94
    __cil_tmp9 = GSM_ADD(*LARp, __cil_tmp8);
#line 94
    *LARp = (int16_t )__cil_tmp9;
#line 92
    __cil_tmp13 = LARpp_j;
#line 92
    LARpp_j ++;
#line 92
    __cil_tmp12 = LARpp_j_1;
#line 92
    LARpp_j_1 ++;
#line 92
    __cil_tmp11 = LARp;
#line 92
    LARp ++;
#line 92
    __cil_tmp10 = i;
#line 92
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 96
  return;
}
}
#line 98 "/root/patchweave_new/23/src/GSM610/short_term.c"
static void Coefficients_13_26(int16_t *LARpp_j_1 , int16_t *LARpp_j , int16_t *LARp ) 
{ 
  register int i ;
  int16_t __cil_tmp5 ;
  int16_t __cil_tmp6 ;
  int32_t __cil_tmp7 ;
  int __cil_tmp8 ;
  int16_t *__cil_tmp9 ;
  int16_t *__cil_tmp10 ;
  int16_t *__cil_tmp11 ;

  {
#line 104
  i = 1;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;

#line 104
    if (! (i <= 8)) {
#line 104
      goto while_break;
    }
    {
#line 105
    __cil_tmp5 = SASR_W(*LARpp_j_1, (int16_t )1);
#line 105
    __cil_tmp6 = SASR_W(*LARpp_j, (int16_t )1);
#line 105
    __cil_tmp7 = GSM_ADD(__cil_tmp5, __cil_tmp6);
#line 105
    *LARp = (int16_t )__cil_tmp7;
#line 104
    __cil_tmp11 = LARp;
#line 104
    LARp ++;
#line 104
    __cil_tmp10 = LARpp_j;
#line 104
    LARpp_j ++;
#line 104
    __cil_tmp9 = LARpp_j_1;
#line 104
    LARpp_j_1 ++;
#line 104
    __cil_tmp8 = i;
#line 104
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 108
  return;
}
}
#line 108 "/root/patchweave_new/23/src/GSM610/short_term.c"
static void Coefficients_27_39(int16_t *LARpp_j_1 , int16_t *LARpp_j , int16_t *LARp ) 
{ 
  register int i ;
  int16_t __cil_tmp5 ;
  int16_t __cil_tmp6 ;
  int32_t __cil_tmp7 ;
  int16_t __cil_tmp8 ;
  int32_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int16_t *__cil_tmp11 ;
  int16_t *__cil_tmp12 ;
  int16_t *__cil_tmp13 ;

  {
#line 115
  i = 1;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;

#line 115
    if (! (i <= 8)) {
#line 115
      goto while_break;
    }
    {
#line 116
    __cil_tmp5 = SASR_W(*LARpp_j_1, (int16_t )2);
#line 116
    __cil_tmp6 = SASR_W(*LARpp_j, (int16_t )2);
#line 116
    __cil_tmp7 = GSM_ADD(__cil_tmp5, __cil_tmp6);
#line 116
    *LARp = (int16_t )__cil_tmp7;
#line 117
    __cil_tmp8 = SASR_W(*LARpp_j, (int16_t )1);
#line 117
    __cil_tmp9 = GSM_ADD(*LARp, __cil_tmp8);
#line 117
    *LARp = (int16_t )__cil_tmp9;
#line 115
    __cil_tmp13 = LARp;
#line 115
    LARp ++;
#line 115
    __cil_tmp12 = LARpp_j;
#line 115
    LARpp_j ++;
#line 115
    __cil_tmp11 = LARpp_j_1;
#line 115
    LARpp_j_1 ++;
#line 115
    __cil_tmp10 = i;
#line 115
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 119
  return;
}
}
#line 122 "/root/patchweave_new/23/src/GSM610/short_term.c"
static void Coefficients_40_159(int16_t *LARpp_j , int16_t *LARp ) 
{ 
  register int i ;
  int __cil_tmp4 ;
  int16_t *__cil_tmp5 ;
  int16_t *__cil_tmp6 ;

  {
#line 128
  i = 1;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;

#line 128
    if (! (i <= 8)) {
#line 128
      goto while_break;
    }
#line 129
    *LARp = *LARpp_j;
#line 128
    __cil_tmp6 = LARpp_j;
#line 128
    LARpp_j ++;
#line 128
    __cil_tmp5 = LARp;
#line 128
    LARp ++;
#line 128
    __cil_tmp4 = i;
#line 128
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 132
  return;
}
}
#line 134 "/root/patchweave_new/23/src/GSM610/short_term.c"
static void LARp_to_rp(int16_t *LARp ) 
{ 
  register int i ;
  register int16_t temp ;
  int tmp ;
  int32_t __cil_tmp5 ;
  int tmp___0 ;
  int tmp___1 ;
  int32_t __cil_tmp8 ;
  int tmp___2 ;
  int tmp___3 ;
  int __cil_tmp11 ;
  int16_t *__cil_tmp12 ;

  {
#line 145
  i = 1;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;

#line 145
    if (! (i <= 8)) {
#line 145
      goto while_break;
    }
#line 155
    if ((int )*LARp < 0) {
#line 156
      if ((int )*LARp == -32768) {
#line 156
        tmp = 32767;
      } else {
#line 156
        tmp = - ((int )*LARp);
      }
#line 156
      temp = (int16_t )tmp;
#line 157
      if ((int )temp < 11059) {
#line 157
        tmp___1 = (int )temp << 1;
      } else {
#line 157
        if ((int )temp < 20070) {
#line 157
          tmp___0 = (int )temp + 11059;
        } else {
          {
#line 157
          __cil_tmp5 = GSM_ADD((int16_t )((int )temp >> 2), (int16_t )26112);
#line 157
          tmp___0 = __cil_tmp5;
          }
        }
#line 157
        tmp___1 = tmp___0;
      }
#line 157
      *LARp = (int16_t )(- tmp___1);
    } else {
#line 162
      temp = *LARp;
#line 163
      if ((int )temp < 11059) {
#line 163
        tmp___3 = (int )temp << 1;
      } else {
#line 163
        if ((int )temp < 20070) {
#line 163
          tmp___2 = (int )temp + 11059;
        } else {
          {
#line 163
          __cil_tmp8 = GSM_ADD((int16_t )((int )temp >> 2), (int16_t )26112);
#line 163
          tmp___2 = __cil_tmp8;
          }
        }
#line 163
        tmp___3 = tmp___2;
      }
#line 163
      *LARp = (int16_t )tmp___3;
    }
#line 145
    __cil_tmp12 = LARp;
#line 145
    LARp ++;
#line 145
    __cil_tmp11 = i;
#line 145
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 149
  return;
}
}
#line 172 "/root/patchweave_new/23/src/GSM610/short_term.c"
static void Short_term_analysis_filtering(struct gsm_state *S , int16_t *rp , int k_n ,
                                          int16_t *s ) 
{ 
  register int16_t *u ;
  register int i ;
  register int16_t di ;
  register int16_t zzz ;
  register int16_t ui ;
  register int16_t sav ;
  register int16_t rpi ;
  int __cil_tmp12 ;
  int32_t __cil_tmp13 ;
  int32_t __cil_tmp14 ;
  int32_t __cil_tmp15 ;
  int32_t __cil_tmp16 ;

  {
#line 189
  u = S->u;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;

#line 193
    if (! __cil_tmp12) {
#line 193
      goto while_break;
    }
#line 194
    sav = *s;
#line 194
    di = sav;
#line 196
    i = 0;
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 196
      if (! (i < 8)) {
#line 196
        goto while_break___0;
      }
      {
#line 198
      ui = *(u + i);
#line 199
      rpi = *(rp + i);
#line 200
      *(u + i) = sav;
#line 202
      __cil_tmp13 = GSM_MULT_R(rpi, di);
#line 202
      zzz = (int16_t )__cil_tmp13;
#line 203
      __cil_tmp14 = GSM_ADD(ui, zzz);
#line 203
      sav = (int16_t )__cil_tmp14;
#line 205
      __cil_tmp15 = GSM_MULT_R(rpi, ui);
#line 205
      zzz = (int16_t )__cil_tmp15;
#line 206
      __cil_tmp16 = GSM_ADD(di, zzz);
#line 206
      di = (int16_t )__cil_tmp16;
#line 196
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 209
    *s = di;
#line 193
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 197
  return;
}
}
#line 215 "/root/patchweave_new/23/src/GSM610/short_term.c"
static void Fast_Short_term_analysis_filtering(struct gsm_state *S , int16_t *rp ,
                                               int k_n , int16_t *s ) 
{ 
  register int16_t *u ;
  register int i ;
  float uf[8] ;
  float rpf[8] ;
  register float scalef ;
  register float sav ;
  register float di ;
  register float temp ;
  int __cil_tmp13 ;
  register float rpfi ;
  register float ufi ;

  {
#line 222
  u = S->u;
#line 227
  scalef = (float )3.0517578125e-05;
#line 230
  i = 0;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;

#line 230
    if (! (i < 8)) {
#line 230
      goto while_break;
    }
#line 231
    uf[i] = (float )*(u + i);
#line 232
    rpf[i] = (float )((int )*(rp + i)) * scalef;
#line 230
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 234
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 234
    if (! __cil_tmp13) {
#line 234
      goto while_break___0;
    }
#line 235
    di = (float )*s;
#line 235
    sav = di;
#line 236
    i = 0;
    {
#line 236
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 236
      if (! (i < 8)) {
#line 236
        goto while_break___1;
      }
#line 237
      rpfi = rpf[i];
#line 238
      ufi = uf[i];
#line 240
      uf[i] = sav;
#line 241
      temp = rpfi * di + ufi;
#line 242
      di += rpfi * ufi;
#line 243
      sav = temp;
#line 236
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 245
    *s = (int16_t )di;
#line 234
    s ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
#line 247
  i = 0;
  {
#line 247
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 247
    if (! (i < 8)) {
#line 247
      goto while_break___2;
    }
#line 247
    *(u + i) = (int16_t )uf[i];
#line 247
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 251
  return;
}
}
#line 251 "/root/patchweave_new/23/src/GSM610/short_term.c"
static void Short_term_synthesis_filtering(struct gsm_state *S , int16_t *rrp , int k ,
                                           int16_t *wt , int16_t *sr ) 
{ 
  register int16_t *v ;
  register int i ;
  register int16_t sri ;
  register int16_t tmp1 ;
  register int16_t tmp2 ;
  int __cil_tmp11 ;
  int16_t *__cil_tmp12 ;
  int __cil_tmp13 ;
  int tmp ;
  int32_t __cil_tmp15 ;
  int tmp___0 ;
  int32_t __cil_tmp17 ;
  int16_t *__cil_tmp18 ;

  {
#line 259
  v = S->v;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    __cil_tmp11 = k;
#line 263
    k --;
#line 263
    if (! __cil_tmp11) {
#line 263
      goto while_break;
    }
#line 264
    __cil_tmp12 = wt;
#line 264
    wt ++;
#line 264
    sri = *__cil_tmp12;
#line 265
    i = 8;
    {
#line 265
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 265
      if (! __cil_tmp13) {
#line 265
        goto while_break___0;
      }
#line 268
      tmp1 = *(rrp + i);
#line 269
      tmp2 = *(v + i);
#line 270
      if ((int )tmp1 == -32768) {
#line 270
        if ((int )tmp2 == -32768) {
#line 270
          tmp = 32767;
        } else {
#line 270
          tmp = 65535 & (((int32_t )tmp1 * (int32_t )tmp2 + 16384) >> 15);
        }
      } else {
#line 270
        tmp = 65535 & (((int32_t )tmp1 * (int32_t )tmp2 + 16384) >> 15);
      }
      {
#line 270
      tmp2 = (int16_t )tmp;
#line 275
      __cil_tmp15 = GSM_SUB(sri, tmp2);
#line 275
      sri = (int16_t )__cil_tmp15;
      }
#line 279
      if ((int )tmp1 == -32768) {
#line 279
        if ((int )sri == -32768) {
#line 279
          tmp___0 = 32767;
        } else {
#line 279
          tmp___0 = 65535 & (((int32_t )tmp1 * (int32_t )sri + 16384) >> 15);
        }
      } else {
#line 279
        tmp___0 = 65535 & (((int32_t )tmp1 * (int32_t )sri + 16384) >> 15);
      }
      {
#line 279
      tmp1 = (int16_t )tmp___0;
#line 284
      __cil_tmp17 = GSM_ADD(*(v + i), tmp1);
#line 284
      *(v + (i + 1)) = (int16_t )__cil_tmp17;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 286
    *(v + 0) = sri;
#line 286
    __cil_tmp18 = sr;
#line 286
    sr ++;
#line 286
    *__cil_tmp18 = *(v + 0);
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 290
  return;
}
}
#line 293 "/root/patchweave_new/23/src/GSM610/short_term.c"
static void Fast_Short_term_synthesis_filtering(struct gsm_state *S , int16_t *rrp ,
                                                int k , int16_t *wt , int16_t *sr ) 
{ 
  register int16_t *v ;
  register int i ;
  float va[9] ;
  float rrpa[8] ;
  register float scalef ;
  register float temp ;
  int __cil_tmp12 ;
  register float sri ;
  int16_t *__cil_tmp14 ;
  int __cil_tmp15 ;
  int16_t *__cil_tmp16 ;

  {
#line 301
  v = S->v;
#line 305
  scalef = (float )3.0517578125e-05;
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;

#line 307
    if (! (i < 8)) {
#line 307
      goto while_break;
    }
#line 308
    va[i] = (float )*(v + i);
#line 309
    rrpa[i] = (float )*(rrp + i) * scalef;
#line 307
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 311
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 311
    __cil_tmp12 = k;
#line 311
    k --;
#line 311
    if (! __cil_tmp12) {
#line 311
      goto while_break___0;
    }
#line 312
    __cil_tmp14 = wt;
#line 312
    wt ++;
#line 312
    sri = (float )*__cil_tmp14;
#line 313
    i = 8;
    {
#line 313
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 313
      if (! __cil_tmp15) {
#line 313
        goto while_break___1;
      }
#line 314
      sri -= rrpa[i] * va[i];
#line 315
      if ((double )sri < - 32768.) {
#line 315
        sri = (float )(- 32768.);
      } else
#line 316
      if ((double )sri > 32767.) {
#line 316
        sri = (float )32767.;
      }
#line 318
      temp = va[i] + rrpa[i] * sri;
#line 319
      if ((double )temp < - 32768.) {
#line 319
        temp = (float )(- 32768.);
      } else
#line 320
      if ((double )temp > 32767.) {
#line 320
        temp = (float )32767.;
      }
#line 321
      va[i + 1] = temp;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 323
    va[0] = sri;
#line 323
    __cil_tmp16 = sr;
#line 323
    sr ++;
#line 323
    *__cil_tmp16 = (int16_t )va[0];
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
#line 325
  i = 0;
  {
#line 325
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 325
    if (! (i < 9)) {
#line 325
      goto while_break___2;
    }
#line 325
    *(v + i) = (int16_t )va[i];
#line 325
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 329
  return;
}
}
#line 330 "/root/patchweave_new/23/src/GSM610/short_term.c"
void Gsm_Short_Term_Analysis_Filter(struct gsm_state *S , int16_t *LARc , int16_t *s ) 
{ 
  int16_t *LARpp_j ;
  int16_t *LARpp_j_1 ;
  int16_t LARp[8] ;
  void (*tmp)(struct gsm_state *S , int16_t *rp , int k_n , int16_t *s ) ;
  void (*tmp___0)(struct gsm_state *S , int16_t *rp , int k_n , int16_t *s ) ;
  void (*tmp___1)(struct gsm_state *S , int16_t *rp , int k_n , int16_t *s ) ;
  void (*tmp___2)(struct gsm_state *S , int16_t *rp , int k_n , int16_t *s ) ;

  {
  {
#line 337
  LARpp_j = S->LARpp[S->j];
#line 338
  S->j = (int16_t )((int )S->j ^ 1);
#line 338
  LARpp_j_1 = S->LARpp[S->j];
#line 352
  Decoding_of_the_coded_Log_Area_Ratios(LARc, LARpp_j);
#line 354
  Coefficients_0_12(LARpp_j_1, LARpp_j, LARp);
#line 355
  LARp_to_rp(LARp);
  }
#line 356
  if ((int )S->fast) {
#line 356
    tmp = & Fast_Short_term_analysis_filtering;
  } else {
#line 356
    tmp = & Short_term_analysis_filtering;
  }
  {
#line 356
  (*tmp)(S, LARp, 13, s);
#line 358
  Coefficients_13_26(LARpp_j_1, LARpp_j, LARp);
#line 359
  LARp_to_rp(LARp);
  }
#line 360
  if ((int )S->fast) {
#line 360
    tmp___0 = & Fast_Short_term_analysis_filtering;
  } else {
#line 360
    tmp___0 = & Short_term_analysis_filtering;
  }
  {
#line 360
  (*tmp___0)(S, LARp, 14, s + 13);
#line 362
  Coefficients_27_39(LARpp_j_1, LARpp_j, LARp);
#line 363
  LARp_to_rp(LARp);
  }
#line 364
  if ((int )S->fast) {
#line 364
    tmp___1 = & Fast_Short_term_analysis_filtering;
  } else {
#line 364
    tmp___1 = & Short_term_analysis_filtering;
  }
  {
#line 364
  (*tmp___1)(S, LARp, 13, s + 27);
#line 366
  Coefficients_40_159(LARpp_j, LARp);
#line 367
  LARp_to_rp(LARp);
  }
#line 368
  if ((int )S->fast) {
#line 368
    tmp___2 = & Fast_Short_term_analysis_filtering;
  } else {
#line 368
    tmp___2 = & Short_term_analysis_filtering;
  }
  {
#line 368
  (*tmp___2)(S, LARp, 120, s + 40);
  }
#line 370
  return;
}
}
#line 371 "/root/patchweave_new/23/src/GSM610/short_term.c"
void Gsm_Short_Term_Synthesis_Filter(struct gsm_state *S , int16_t *LARcr , int16_t *wt ,
                                     int16_t *s ) 
{ 
  int16_t *LARpp_j ;
  int16_t *LARpp_j_1 ;
  int16_t LARp[8] ;
  void (*tmp)(struct gsm_state *S , int16_t *rrp , int k , int16_t *wt , int16_t *sr ) ;
  void (*tmp___0)(struct gsm_state *S , int16_t *rrp , int k , int16_t *wt , int16_t *sr ) ;
  void (*tmp___1)(struct gsm_state *S , int16_t *rrp , int k , int16_t *wt , int16_t *sr ) ;
  void (*tmp___2)(struct gsm_state *S , int16_t *rrp , int k , int16_t *wt , int16_t *sr ) ;

  {
  {
#line 380
  LARpp_j = S->LARpp[S->j];
#line 381
  S->j = (int16_t )((int )S->j ^ 1);
#line 381
  LARpp_j_1 = S->LARpp[S->j];
#line 395
  Decoding_of_the_coded_Log_Area_Ratios(LARcr, LARpp_j);
#line 397
  Coefficients_0_12(LARpp_j_1, LARpp_j, LARp);
#line 398
  LARp_to_rp(LARp);
  }
#line 399
  if ((int )S->fast) {
#line 399
    tmp = & Fast_Short_term_synthesis_filtering;
  } else {
#line 399
    tmp = & Short_term_synthesis_filtering;
  }
  {
#line 399
  (*tmp)(S, LARp, 13, wt, s);
#line 401
  Coefficients_13_26(LARpp_j_1, LARpp_j, LARp);
#line 402
  LARp_to_rp(LARp);
  }
#line 403
  if ((int )S->fast) {
#line 403
    tmp___0 = & Fast_Short_term_synthesis_filtering;
  } else {
#line 403
    tmp___0 = & Short_term_synthesis_filtering;
  }
  {
#line 403
  (*tmp___0)(S, LARp, 14, wt + 13, s + 13);
#line 405
  Coefficients_27_39(LARpp_j_1, LARpp_j, LARp);
#line 406
  LARp_to_rp(LARp);
  }
#line 407
  if ((int )S->fast) {
#line 407
    tmp___1 = & Fast_Short_term_synthesis_filtering;
  } else {
#line 407
    tmp___1 = & Short_term_synthesis_filtering;
  }
  {
#line 407
  (*tmp___1)(S, LARp, 13, wt + 27, s + 27);
#line 409
  Coefficients_40_159(LARpp_j, LARp);
#line 410
  LARp_to_rp(LARp);
  }
#line 411
  if ((int )S->fast) {
#line 411
    tmp___2 = & Fast_Short_term_synthesis_filtering;
  } else {
#line 411
    tmp___2 = & Short_term_synthesis_filtering;
  }
  {
#line 411
  (*tmp___2)(S, LARp, 120, wt + 40, s + 40);
  }
#line 413
  return;
}
}
#line 17 "/root/patchweave_new/23/src/GSM610/rpe.c"
static void Weighting_filter(int16_t *e , int16_t *x ) 
{ 
  register int32_t L_result ;
  register int k ;
  int tmp ;
  int tmp___0 ;

  {
#line 43
  e -= 5;
#line 47
  k = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;

#line 47
    if (! (k <= 39)) {
#line 47
      goto while_break;
    }
    {
#line 48
    L_result = 8192 >> 1;
#line 77
    L_result += ((((((((int )*(e + k) * -134 + (int )*(e + (k + 1)) * -374) + (int )*(e + (k + 3)) * 2054) + (int )*(e + (k + 4)) * 5741) + (int )*(e + (k + 5)) * 8192) + (int )*(e + (k + 6)) * 5741) + (int )*(e + (k + 7)) * 2054) + (int )*(e + (k + 9)) * -374) + (int )*(e + (k + 10)) * -134;
#line 100
    L_result = SASR_L(L_result, (int16_t )13);
    }
#line 101
    if (L_result < -32768) {
#line 101
      tmp___0 = -32768;
    } else {
#line 101
      if (L_result > 32767) {
#line 101
        tmp = 32767;
      } else {
#line 101
        tmp = L_result;
      }
#line 101
      tmp___0 = tmp;
    }
#line 101
    *(x + k) = (int16_t )tmp___0;
#line 47
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 51
  return;
}
}
#line 108 "/root/patchweave_new/23/src/GSM610/rpe.c"
static void RPE_grid_selection(int16_t *x , int16_t *xM , int16_t *Mc_out ) 
{ 
  register int i ;
  register int32_t L_result ;
  register int32_t L_temp ;
  int32_t EM ;
  int16_t Mc ;
  int32_t L_common_0_3 ;
  int16_t __cil_tmp10 ;
  int16_t __cil_tmp11 ;
  int16_t __cil_tmp12 ;
  int16_t __cil_tmp13 ;
  int16_t __cil_tmp14 ;
  int16_t __cil_tmp15 ;
  int16_t __cil_tmp16 ;
  int16_t __cil_tmp17 ;
  int16_t __cil_tmp18 ;
  int16_t __cil_tmp19 ;
  int16_t __cil_tmp20 ;
  int16_t __cil_tmp21 ;
  int16_t __cil_tmp22 ;
  int16_t __cil_tmp23 ;
  int16_t __cil_tmp24 ;
  int16_t __cil_tmp25 ;
  int16_t __cil_tmp26 ;
  int16_t __cil_tmp27 ;
  int16_t __cil_tmp28 ;
  int16_t __cil_tmp29 ;
  int16_t __cil_tmp30 ;
  int16_t __cil_tmp31 ;
  int16_t __cil_tmp32 ;
  int16_t __cil_tmp33 ;
  int16_t __cil_tmp34 ;
  int16_t __cil_tmp35 ;
  int16_t __cil_tmp36 ;
  int16_t __cil_tmp37 ;
  int16_t __cil_tmp38 ;
  int16_t __cil_tmp39 ;
  int16_t __cil_tmp40 ;
  int16_t __cil_tmp41 ;
  int16_t __cil_tmp42 ;
  int16_t __cil_tmp43 ;
  int16_t __cil_tmp44 ;
  int16_t __cil_tmp45 ;
  int16_t __cil_tmp46 ;
  int16_t __cil_tmp47 ;
  int16_t __cil_tmp48 ;
  int16_t __cil_tmp49 ;

  {
  {
#line 125
  EM = 0;
#line 126
  Mc = (int16_t )0;
#line 155
  L_result = 0;
#line 156
  __cil_tmp10 = SASR_W(*(x + 3), (int16_t )2);
#line 156
  L_temp = (int32_t )__cil_tmp10;
#line 156
  L_result += L_temp * L_temp;
#line 156
  __cil_tmp11 = SASR_W(*(x + 6), (int16_t )2);
#line 156
  L_temp = (int32_t )__cil_tmp11;
#line 156
  L_result += L_temp * L_temp;
#line 156
  __cil_tmp12 = SASR_W(*(x + 9), (int16_t )2);
#line 156
  L_temp = (int32_t )__cil_tmp12;
#line 156
  L_result += L_temp * L_temp;
#line 156
  __cil_tmp13 = SASR_W(*(x + 12), (int16_t )2);
#line 156
  L_temp = (int32_t )__cil_tmp13;
#line 156
  L_result += L_temp * L_temp;
#line 157
  __cil_tmp14 = SASR_W(*(x + 15), (int16_t )2);
#line 157
  L_temp = (int32_t )__cil_tmp14;
#line 157
  L_result += L_temp * L_temp;
#line 157
  __cil_tmp15 = SASR_W(*(x + 18), (int16_t )2);
#line 157
  L_temp = (int32_t )__cil_tmp15;
#line 157
  L_result += L_temp * L_temp;
#line 157
  __cil_tmp16 = SASR_W(*(x + 21), (int16_t )2);
#line 157
  L_temp = (int32_t )__cil_tmp16;
#line 157
  L_result += L_temp * L_temp;
#line 157
  __cil_tmp17 = SASR_W(*(x + 24), (int16_t )2);
#line 157
  L_temp = (int32_t )__cil_tmp17;
#line 157
  L_result += L_temp * L_temp;
#line 158
  __cil_tmp18 = SASR_W(*(x + 27), (int16_t )2);
#line 158
  L_temp = (int32_t )__cil_tmp18;
#line 158
  L_result += L_temp * L_temp;
#line 158
  __cil_tmp19 = SASR_W(*(x + 30), (int16_t )2);
#line 158
  L_temp = (int32_t )__cil_tmp19;
#line 158
  L_result += L_temp * L_temp;
#line 158
  __cil_tmp20 = SASR_W(*(x + 33), (int16_t )2);
#line 158
  L_temp = (int32_t )__cil_tmp20;
#line 158
  L_result += L_temp * L_temp;
#line 158
  __cil_tmp21 = SASR_W(*(x + 36), (int16_t )2);
#line 158
  L_temp = (int32_t )__cil_tmp21;
#line 158
  L_result += L_temp * L_temp;
#line 159
  L_common_0_3 = L_result;
#line 163
  __cil_tmp22 = SASR_W(*(x + 0), (int16_t )2);
#line 163
  L_temp = (int32_t )__cil_tmp22;
#line 163
  L_result += L_temp * L_temp;
#line 164
  L_result <<= 1;
#line 165
  EM = L_result;
#line 169
  L_result = 0;
#line 170
  __cil_tmp23 = SASR_W(*(x + 1), (int16_t )2);
#line 170
  L_temp = (int32_t )__cil_tmp23;
#line 170
  L_result += L_temp * L_temp;
#line 171
  __cil_tmp24 = SASR_W(*(x + 4), (int16_t )2);
#line 171
  L_temp = (int32_t )__cil_tmp24;
#line 171
  L_result += L_temp * L_temp;
#line 171
  __cil_tmp25 = SASR_W(*(x + 7), (int16_t )2);
#line 171
  L_temp = (int32_t )__cil_tmp25;
#line 171
  L_result += L_temp * L_temp;
#line 171
  __cil_tmp26 = SASR_W(*(x + 10), (int16_t )2);
#line 171
  L_temp = (int32_t )__cil_tmp26;
#line 171
  L_result += L_temp * L_temp;
#line 171
  __cil_tmp27 = SASR_W(*(x + 13), (int16_t )2);
#line 171
  L_temp = (int32_t )__cil_tmp27;
#line 171
  L_result += L_temp * L_temp;
#line 172
  __cil_tmp28 = SASR_W(*(x + 16), (int16_t )2);
#line 172
  L_temp = (int32_t )__cil_tmp28;
#line 172
  L_result += L_temp * L_temp;
#line 172
  __cil_tmp29 = SASR_W(*(x + 19), (int16_t )2);
#line 172
  L_temp = (int32_t )__cil_tmp29;
#line 172
  L_result += L_temp * L_temp;
#line 172
  __cil_tmp30 = SASR_W(*(x + 22), (int16_t )2);
#line 172
  L_temp = (int32_t )__cil_tmp30;
#line 172
  L_result += L_temp * L_temp;
#line 172
  __cil_tmp31 = SASR_W(*(x + 25), (int16_t )2);
#line 172
  L_temp = (int32_t )__cil_tmp31;
#line 172
  L_result += L_temp * L_temp;
#line 173
  __cil_tmp32 = SASR_W(*(x + 28), (int16_t )2);
#line 173
  L_temp = (int32_t )__cil_tmp32;
#line 173
  L_result += L_temp * L_temp;
#line 173
  __cil_tmp33 = SASR_W(*(x + 31), (int16_t )2);
#line 173
  L_temp = (int32_t )__cil_tmp33;
#line 173
  L_result += L_temp * L_temp;
#line 173
  __cil_tmp34 = SASR_W(*(x + 34), (int16_t )2);
#line 173
  L_temp = (int32_t )__cil_tmp34;
#line 173
  L_result += L_temp * L_temp;
#line 173
  __cil_tmp35 = SASR_W(*(x + 37), (int16_t )2);
#line 173
  L_temp = (int32_t )__cil_tmp35;
#line 173
  L_result += L_temp * L_temp;
#line 174
  L_result <<= 1;
  }
#line 175
  if (L_result > EM) {
#line 176
    Mc = (int16_t )1;
#line 177
    EM = L_result;
  }
  {
#line 182
  L_result = 0;
#line 183
  __cil_tmp36 = SASR_W(*(x + 2), (int16_t )2);
#line 183
  L_temp = (int32_t )__cil_tmp36;
#line 183
  L_result += L_temp * L_temp;
#line 184
  __cil_tmp37 = SASR_W(*(x + 5), (int16_t )2);
#line 184
  L_temp = (int32_t )__cil_tmp37;
#line 184
  L_result += L_temp * L_temp;
#line 184
  __cil_tmp38 = SASR_W(*(x + 8), (int16_t )2);
#line 184
  L_temp = (int32_t )__cil_tmp38;
#line 184
  L_result += L_temp * L_temp;
#line 184
  __cil_tmp39 = SASR_W(*(x + 11), (int16_t )2);
#line 184
  L_temp = (int32_t )__cil_tmp39;
#line 184
  L_result += L_temp * L_temp;
#line 184
  __cil_tmp40 = SASR_W(*(x + 14), (int16_t )2);
#line 184
  L_temp = (int32_t )__cil_tmp40;
#line 184
  L_result += L_temp * L_temp;
#line 185
  __cil_tmp41 = SASR_W(*(x + 17), (int16_t )2);
#line 185
  L_temp = (int32_t )__cil_tmp41;
#line 185
  L_result += L_temp * L_temp;
#line 185
  __cil_tmp42 = SASR_W(*(x + 20), (int16_t )2);
#line 185
  L_temp = (int32_t )__cil_tmp42;
#line 185
  L_result += L_temp * L_temp;
#line 185
  __cil_tmp43 = SASR_W(*(x + 23), (int16_t )2);
#line 185
  L_temp = (int32_t )__cil_tmp43;
#line 185
  L_result += L_temp * L_temp;
#line 185
  __cil_tmp44 = SASR_W(*(x + 26), (int16_t )2);
#line 185
  L_temp = (int32_t )__cil_tmp44;
#line 185
  L_result += L_temp * L_temp;
#line 186
  __cil_tmp45 = SASR_W(*(x + 29), (int16_t )2);
#line 186
  L_temp = (int32_t )__cil_tmp45;
#line 186
  L_result += L_temp * L_temp;
#line 186
  __cil_tmp46 = SASR_W(*(x + 32), (int16_t )2);
#line 186
  L_temp = (int32_t )__cil_tmp46;
#line 186
  L_result += L_temp * L_temp;
#line 186
  __cil_tmp47 = SASR_W(*(x + 35), (int16_t )2);
#line 186
  L_temp = (int32_t )__cil_tmp47;
#line 186
  L_result += L_temp * L_temp;
#line 186
  __cil_tmp48 = SASR_W(*(x + 38), (int16_t )2);
#line 186
  L_temp = (int32_t )__cil_tmp48;
#line 186
  L_result += L_temp * L_temp;
#line 187
  L_result <<= 1;
  }
#line 188
  if (L_result > EM) {
#line 189
    Mc = (int16_t )2;
#line 190
    EM = L_result;
  }
  {
#line 195
  L_result = L_common_0_3;
#line 196
  __cil_tmp49 = SASR_W(*(x + 39), (int16_t )2);
#line 196
  L_temp = (int32_t )__cil_tmp49;
#line 196
  L_result += L_temp * L_temp;
#line 197
  L_result <<= 1;
  }
#line 198
  if (L_result > EM) {
#line 199
    Mc = (int16_t )3;
#line 200
    EM = L_result;
  }
#line 206
  i = 0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;

#line 206
    if (! (i <= 12)) {
#line 206
      goto while_break;
    }
#line 206
    *(xM + i) = *(x + ((int )Mc + 3 * i));
#line 206
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 207
  *Mc_out = Mc;
#line 208
  return;
}
}
#line 212 "/root/patchweave_new/23/src/GSM610/rpe.c"
static void APCM_quantization_xmaxc_to_exp_mant(int16_t xmaxc , int16_t *expon_out ,
                                                int16_t *mant_out ) 
{ 
  int16_t expon ;
  int16_t mant ;
  int16_t __cil_tmp6 ;
  int16_t __cil_tmp7 ;

  {
#line 222
  expon = (int16_t )0;
#line 223
  if ((int )xmaxc > 15) {
    {
#line 223
    __cil_tmp6 = SASR_W(xmaxc, (int16_t )3);
#line 223
    expon = (int16_t )((int )__cil_tmp6 - 1);
    }
  }
#line 224
  mant = (int16_t )((int )xmaxc - ((int )expon << 3));
#line 226
  if ((int )mant == 0) {
#line 227
    expon = (int16_t )-4;
#line 228
    mant = (int16_t )7;
  } else {
    {
#line 231
    while (1) {
      while_continue: /* CIL Label */ ;

#line 231
      if (! ((int )mant <= 7)) {
#line 231
        goto while_break;
      }
#line 232
      mant = (int16_t )(((int )mant << 1) | 1);
#line 233
      __cil_tmp7 = expon;
#line 233
      expon = (int16_t )((int )expon - 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 235
    mant = (int16_t )((int )mant - 8);
  }
#line 241
  *expon_out = expon;
#line 242
  *mant_out = mant;
#line 243
  return;
}
}
#line 245 "/root/patchweave_new/23/src/GSM610/rpe.c"
static void APCM_quantization(int16_t *xM , int16_t *xMc , int16_t *mant_out , int16_t *expon_out ,
                              int16_t *xmaxc_out ) 
{ 
  int i ;
  int itest ;
  int16_t xmax ;
  int16_t xmaxc ;
  int16_t temp ;
  int16_t temp1 ;
  int16_t temp2 ;
  int16_t expon ;
  int16_t mant ;
  int16_t __cil_tmp24 ;
  int16_t __cil_tmp25 ;
  int32_t __cil_tmp29 ;
  int32_t __cil_tmp30 ;

  {
#line 262
  xmax = (int16_t )0;
#line 263
  i = 0;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;

#line 263
    if (! (i <= 12)) {
#line 263
      goto while_break;
    }
    {
#line 264
    temp = *(xM + i);
#line 265
    temp = GSM_ABS(temp);
    }
#line 266
    if ((int )temp > (int )xmax) {
#line 266
      xmax = temp;
    }
#line 263
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 272
  expon = (int16_t )0;
#line 273
  temp = SASR_W(xmax, (int16_t )9);
#line 274
  itest = 0;
#line 276
  i = 0;
  }
  {
#line 276
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 276
    if (! (i <= 5)) {
#line 276
      goto while_break___0;
    }
    {
#line 277
    itest |= (int )temp <= 0;
#line 278
    temp = SASR_W(temp, (int16_t )1);
    }
#line 281
    if (itest == 0) {
#line 281
      expon = (int16_t )((int )expon + 1);
    }
#line 276
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 285
  temp = (int16_t )((int )expon + 5);
#line 288
  __cil_tmp24 = SASR_W(xmax, temp);
#line 288
  __cil_tmp25 = gsm_add(__cil_tmp24, (int16_t )((int )expon << 3));
#line 288
  xmaxc = __cil_tmp25;
#line 294
  APCM_quantization_xmaxc_to_exp_mant(xmaxc, & expon, & mant);
#line 313
  temp1 = (int16_t )(6 - (int )expon);
#line 314
  temp2 = gsm_NRFAC[mant];
#line 316
  i = 0;
  }
  {
#line 316
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 316
    if (! (i <= 12)) {
#line 316
      goto while_break___1;
    }
    {
#line 319
    __cil_tmp29 = arith_shift_left((int32_t )*(xM + i), (int )temp1);
#line 319
    temp = (int16_t )__cil_tmp29;
#line 320
    __cil_tmp30 = GSM_MULT(temp, temp2);
#line 320
    temp = (int16_t )__cil_tmp30;
#line 321
    temp = SASR_W(temp, (int16_t )12);
#line 322
    *(xMc + i) = (int16_t )((int )temp + 4);
#line 316
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
#line 328
  *mant_out = mant;
#line 329
  *expon_out = expon;
#line 330
  *xmaxc_out = xmaxc;
#line 331
  return;
}
}
#line 335 "/root/patchweave_new/23/src/GSM610/rpe.c"
static void APCM_inverse_quantization(int16_t *xMc , int16_t mant , int16_t expon ,
                                      int16_t *xMp ) 
{ 
  int i ;
  int16_t temp ;
  int16_t temp1 ;
  int16_t temp2 ;
  int16_t temp3 ;
  int16_t __cil_tmp12 ;
  int16_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int16_t *__cil_tmp16 ;
  int32_t __cil_tmp18 ;
  int32_t __cil_tmp19 ;
  int32_t __cil_tmp20 ;
  int16_t *__cil_tmp21 ;

  {
  {
#line 351
  temp1 = gsm_FAC[mant];
#line 352
  temp2 = gsm_sub((int16_t )6, expon);
#line 353
  __cil_tmp12 = gsm_sub(temp2, (int16_t )1);
#line 353
  __cil_tmp13 = gsm_asl((int16_t )1, (int )__cil_tmp12);
#line 353
  temp3 = __cil_tmp13;
#line 355
  i = 13;
  }
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;

#line 355
    if (! __cil_tmp14) {
#line 355
      goto while_break;
    }
    {
#line 359
    __cil_tmp16 = xMc;
#line 359
    xMc ++;
#line 359
    temp = (int16_t )(((int )*__cil_tmp16 << 1) - 7);
#line 362
    __cil_tmp18 = arith_shift_left((int32_t )temp, 12);
#line 362
    temp = (int16_t )__cil_tmp18;
#line 363
    __cil_tmp19 = GSM_MULT_R(temp1, temp);
#line 363
    temp = (int16_t )__cil_tmp19;
#line 364
    __cil_tmp20 = GSM_ADD(temp, temp3);
#line 364
    temp = (int16_t )__cil_tmp20;
#line 365
    __cil_tmp21 = xMp;
#line 365
    xMp ++;
#line 365
    *__cil_tmp21 = gsm_asr(temp, (int )temp2);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 370
  return;
}
}
#line 371 "/root/patchweave_new/23/src/GSM610/rpe.c"
static void RPE_grid_positioning(int16_t Mc , int16_t *xMp , int16_t *ep ) 
{ 
  int i ;
  int16_t *__cil_tmp6 ;
  int16_t *__cil_tmp7 ;
  int16_t *__cil_tmp8 ;
  int16_t *__cil_tmp9 ;
  int16_t *__cil_tmp10 ;
  int16_t *__cil_tmp11 ;

  {
#line 384
  i = 13;
#line 389
  if ((int )Mc == 3) {
#line 389
    goto case_3;
  }
#line 390
  if ((int )Mc == 2) {
#line 390
    goto case_2;
  }
#line 392
  if ((int )Mc == 1) {
#line 392
    goto case_1;
  }
#line 393
  if ((int )Mc == 0) {
#line 393
    goto case_0;
  }
#line 388
  goto switch_break;
  case_3: 
#line 389
  __cil_tmp6 = ep;
#line 389
  ep ++;
#line 389
  *__cil_tmp6 = (int16_t )0;
  case_2: 
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    __cil_tmp7 = ep;
#line 391
    ep ++;
#line 391
    *__cil_tmp7 = (int16_t )0;
    case_1: 
#line 392
    __cil_tmp8 = ep;
#line 392
    ep ++;
#line 392
    *__cil_tmp8 = (int16_t )0;
    case_0: 
#line 393
    __cil_tmp10 = xMp;
#line 393
    xMp ++;
#line 393
    __cil_tmp9 = ep;
#line 393
    ep ++;
#line 393
    *__cil_tmp9 = *__cil_tmp10;
#line 390
    if (! i) {
#line 390
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  switch_break: ;
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    Mc = (int16_t )((int )Mc + 1);
#line 396
    if (! ((int )Mc < 4)) {
#line 396
      goto while_break___0;
    }
#line 396
    __cil_tmp11 = ep;
#line 396
    ep ++;
#line 396
    *__cil_tmp11 = (int16_t )0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 400
  return;
}
}
#line 424 "/root/patchweave_new/23/src/GSM610/rpe.c"
void Gsm_RPE_Encoding(int16_t *e , int16_t *xmaxc , int16_t *Mc , int16_t *xMc ) 
{ 
  int16_t x[40] ;
  int16_t xM[13] ;
  int16_t xMp[13] ;
  int16_t mant ;
  int16_t expon ;

  {
  {
#line 434
  Weighting_filter(e, x);
#line 435
  RPE_grid_selection(x, xM, Mc);
#line 437
  APCM_quantization(xM, xMc, & mant, & expon, xmaxc);
#line 438
  APCM_inverse_quantization(xMc, mant, expon, xMp);
#line 440
  RPE_grid_positioning(*Mc, xMp, e);
  }
#line 442
  return;
}
}
#line 444 "/root/patchweave_new/23/src/GSM610/rpe.c"
void Gsm_RPE_Decoding(int16_t xmaxcr , int16_t Mcr , int16_t *xMcr , int16_t *erp ) 
{ 
  int16_t expon ;
  int16_t mant ;
  int16_t xMp[13] ;

  {
  {
#line 454
  APCM_quantization_xmaxc_to_exp_mant(xmaxcr, & expon, & mant);
#line 455
  APCM_inverse_quantization(xMcr, mant, expon, xMp);
#line 456
  RPE_grid_positioning(Mcr, xMp, erp);
  }
#line 458
  return;
}
}
#line 29 "/root/patchweave_new/23/src/GSM610/preprocess.c"
void Gsm_Preprocess(struct gsm_state *S , int16_t *s , int16_t *so ) 
{ 
  int16_t z1 ;
  int32_t L_z2 ;
  int16_t mp ;
  int16_t s1 ;
  int32_t L_s2 ;
  int32_t L_temp ;
  int16_t msp ;
  int16_t lsp ;
  int16_t SO ;
  register int k ;
  int __cil_tmp14 ;
  int16_t __cil_tmp15 ;
  int32_t __cil_tmp16 ;
  int32_t __cil_tmp22 ;
  int32_t __cil_tmp23 ;
  int32_t __cil_tmp24 ;
  int32_t __cil_tmp27 ;
  int32_t __cil_tmp28 ;
  int16_t *__cil_tmp29 ;
  int32_t __cil_tmp30 ;

  {
#line 35
  z1 = S->z1;
#line 36
  L_z2 = S->L_z2;
#line 37
  mp = (int16_t )S->mp;
#line 47
  k = 160;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    __cil_tmp14 = k;
#line 49
    k --;
#line 49
    if (! __cil_tmp14) {
#line 49
      goto while_break;
    }
    {
#line 53
    __cil_tmp15 = SASR_W(*s, (int16_t )3);
#line 53
    __cil_tmp16 = arith_shift_left((int32_t )__cil_tmp15, 2);
#line 53
    SO = (int16_t )__cil_tmp16;
#line 54
    s ++;
#line 70
    s1 = (int16_t )((int )SO - (int )z1);
#line 71
    z1 = SO;
#line 76
    L_s2 = (int32_t )s1;
#line 77
    L_s2 = arith_shift_left(L_s2, 15);
#line 81
    __cil_tmp22 = SASR_L(L_z2, (int16_t )15);
#line 81
    msp = (int16_t )__cil_tmp22;
#line 82
    __cil_tmp23 = arith_shift_left((int32_t )msp, 15);
#line 82
    lsp = (int16_t )(L_z2 - __cil_tmp23);
#line 84
    __cil_tmp24 = GSM_MULT_R(lsp, (int16_t )32735);
#line 84
    L_s2 += __cil_tmp24;
#line 85
    L_temp = (int32_t )msp * 32735;
#line 86
    L_z2 = GSM_L_ADD(L_temp, L_s2);
#line 89
    L_temp = GSM_L_ADD(L_z2, 16384);
#line 93
    __cil_tmp27 = GSM_MULT_R(mp, (int16_t )-28180);
#line 93
    msp = (int16_t )__cil_tmp27;
#line 94
    __cil_tmp28 = SASR_L(L_temp, (int16_t )15);
#line 94
    mp = (int16_t )__cil_tmp28;
#line 95
    __cil_tmp30 = GSM_ADD(mp, msp);
#line 95
    __cil_tmp29 = so;
#line 95
    so ++;
#line 95
    *__cil_tmp29 = (int16_t )__cil_tmp30;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 98
  S->z1 = z1;
#line 99
  S->L_z2 = L_z2;
#line 100
  S->mp = (int )mp;
#line 101
  return;
}
}
#line 20 "/root/patchweave_new/23/src/GSM610/lpc.c"
static void Autocorrelation(int16_t *s , int32_t *L_ACF ) 
{ 
  register int k ;
  register int i ;
  int16_t temp ;
  int16_t smax ;
  int16_t scalauto ;
  float float_s[160] ;
  int16_t __cil_tmp12 ;
  int32_t __cil_tmp13 ;
  int32_t __cil_tmp15 ;
  int32_t __cil_tmp17 ;
  int32_t __cil_tmp19 ;
  register float *sp ;
  register float sl ;
  int __cil_tmp24 ;
  int __cil_tmp26 ;
  int __cil_tmp29 ;

  {
#line 39
  smax = (int16_t )0;
#line 40
  k = 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;

#line 40
    if (! (k <= 159)) {
#line 40
      goto while_break;
    }
    {
#line 41
    temp = GSM_ABS(*(s + k));
    }
#line 42
    if ((int )temp > (int )smax) {
#line 42
      smax = temp;
    }
#line 40
    k ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break: ;
#line 47
  if ((int )smax == 0) {
#line 48
    scalauto = (int16_t )0;
  } else {
    {
#line 51
    __cil_tmp12 = gsm_norm((int32_t )smax << 16);
#line 51
    scalauto = (int16_t )(4 - (int )__cil_tmp12);
    }
  }
#line 57
  if ((int )scalauto > 0) {
#line 74
    if ((int )scalauto == 1) {
#line 74
      goto case_1;
    }
#line 75
    if ((int )scalauto == 2) {
#line 75
      goto case_2;
    }
#line 76
    if ((int )scalauto == 3) {
#line 76
      goto case_3;
    }
#line 77
    if ((int )scalauto == 4) {
#line 77
      goto case_4;
    }
#line 73
    goto switch_break;
    case_1: 
#line 74
    k = 0;
    {
#line 74
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 74
      if (! (k <= 159)) {
#line 74
        goto while_break___0;
      }
      {
#line 74
      __cil_tmp13 = GSM_MULT_R(*(s + k), (int16_t )16384);
#line 74
      *(s + k) = (int16_t )__cil_tmp13;
#line 74
      float_s[k] = (float )*(s + k);
#line 74
      k ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___0: ;
#line 74
    goto switch_break;
    case_2: 
#line 75
    k = 0;
    {
#line 75
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 75
      if (! (k <= 159)) {
#line 75
        goto while_break___1;
      }
      {
#line 75
      __cil_tmp15 = GSM_MULT_R(*(s + k), (int16_t )(16384 >> 1));
#line 75
      *(s + k) = (int16_t )__cil_tmp15;
#line 75
      float_s[k] = (float )*(s + k);
#line 75
      k ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___1: ;
#line 75
    goto switch_break;
    case_3: 
#line 76
    k = 0;
    {
#line 76
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 76
      if (! (k <= 159)) {
#line 76
        goto while_break___2;
      }
      {
#line 76
      __cil_tmp17 = GSM_MULT_R(*(s + k), (int16_t )(16384 >> 2));
#line 76
      *(s + k) = (int16_t )__cil_tmp17;
#line 76
      float_s[k] = (float )*(s + k);
#line 76
      k ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___2: ;
#line 76
    goto switch_break;
    case_4: 
#line 77
    k = 0;
    {
#line 77
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 77
      if (! (k <= 159)) {
#line 77
        goto while_break___3;
      }
      {
#line 77
      __cil_tmp19 = GSM_MULT_R(*(s + k), (int16_t )(16384 >> 3));
#line 77
      *(s + k) = (int16_t )__cil_tmp19;
#line 77
      float_s[k] = (float )*(s + k);
#line 77
      k ++;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___3: ;
#line 77
    goto switch_break;
    switch_break: ;
  } else {
#line 82
    k = 0;
    {
#line 82
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 82
      if (! (k <= 159)) {
#line 82
        goto while_break___4;
      }
#line 82
      float_s[k] = (float )*(s + k);
#line 82
      k ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___4: ;
  }
#line 89
  sp = float_s;
#line 90
  sl = *sp;
#line 103
  k = 9;
  {
#line 103
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 103
    if (! __cil_tmp24) {
#line 103
      goto while_break___5;
    }
#line 103
    *(L_ACF + k) = 0;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___5: 
#line 105
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 106
  sp ++;
#line 106
  sl = *sp;
#line 107
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 107
  *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 108
  sp ++;
#line 108
  sl = *sp;
#line 109
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 109
  *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 109
  *(L_ACF + 2) += (int32_t )(sl * *(sp + -2));
#line 110
  sp ++;
#line 110
  sl = *sp;
#line 111
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 111
  *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 111
  *(L_ACF + 2) += (int32_t )(sl * *(sp + -2));
#line 111
  *(L_ACF + 3) += (int32_t )(sl * *(sp + -3));
#line 112
  sp ++;
#line 112
  sl = *sp;
#line 113
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 113
  *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 113
  *(L_ACF + 2) += (int32_t )(sl * *(sp + -2));
#line 113
  *(L_ACF + 3) += (int32_t )(sl * *(sp + -3));
#line 113
  *(L_ACF + 4) += (int32_t )(sl * *(sp + -4));
#line 114
  sp ++;
#line 114
  sl = *sp;
#line 115
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 115
  *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 115
  *(L_ACF + 2) += (int32_t )(sl * *(sp + -2));
#line 115
  *(L_ACF + 3) += (int32_t )(sl * *(sp + -3));
#line 115
  *(L_ACF + 4) += (int32_t )(sl * *(sp + -4));
#line 115
  *(L_ACF + 5) += (int32_t )(sl * *(sp + -5));
#line 116
  sp ++;
#line 116
  sl = *sp;
#line 117
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 117
  *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 117
  *(L_ACF + 2) += (int32_t )(sl * *(sp + -2));
#line 117
  *(L_ACF + 3) += (int32_t )(sl * *(sp + -3));
#line 117
  *(L_ACF + 4) += (int32_t )(sl * *(sp + -4));
#line 117
  *(L_ACF + 5) += (int32_t )(sl * *(sp + -5));
#line 117
  *(L_ACF + 6) += (int32_t )(sl * *(sp + -6));
#line 118
  sp ++;
#line 118
  sl = *sp;
#line 119
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 119
  *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 119
  *(L_ACF + 2) += (int32_t )(sl * *(sp + -2));
#line 119
  *(L_ACF + 3) += (int32_t )(sl * *(sp + -3));
#line 119
  *(L_ACF + 4) += (int32_t )(sl * *(sp + -4));
#line 119
  *(L_ACF + 5) += (int32_t )(sl * *(sp + -5));
#line 119
  *(L_ACF + 6) += (int32_t )(sl * *(sp + -6));
#line 119
  *(L_ACF + 7) += (int32_t )(sl * *(sp + -7));
#line 121
  i = 8;
  {
#line 121
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 121
    if (! (i <= 159)) {
#line 121
      goto while_break___6;
    }
#line 122
    sp ++;
#line 122
    sl = *sp;
#line 124
    *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 125
    *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 125
    *(L_ACF + 2) += (int32_t )(sl * *(sp + -2));
#line 125
    *(L_ACF + 3) += (int32_t )(sl * *(sp + -3));
#line 125
    *(L_ACF + 4) += (int32_t )(sl * *(sp + -4));
#line 126
    *(L_ACF + 5) += (int32_t )(sl * *(sp + -5));
#line 126
    *(L_ACF + 6) += (int32_t )(sl * *(sp + -6));
#line 126
    *(L_ACF + 7) += (int32_t )(sl * *(sp + -7));
#line 126
    *(L_ACF + 8) += (int32_t )(sl * *(sp + -8));
#line 121
    i ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___6: 
#line 129
  k = 9;
  {
#line 129
  while (1) {
    while_continue___7: /* CIL Label */ ;

#line 129
    if (! __cil_tmp26) {
#line 129
      goto while_break___7;
    }
    {
#line 130
    *(L_ACF + k) = SASL_L(*(L_ACF + k), (int16_t )1);
    }
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___7: ;
#line 135
  if ((int )scalauto > 0) {
#line 137
    k = 160;
    {
#line 137
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 137
      if (! __cil_tmp29) {
#line 137
        goto while_break___8;
      }
      {
#line 138
      *s = SASL_W(*s, scalauto);
#line 137
      s ++;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___8: ;
  }
#line 142
  return;
}
}
#line 144 "/root/patchweave_new/23/src/GSM610/lpc.c"
static void Fast_Autocorrelation(int16_t *s , int32_t *L_ACF ) 
{ 
  register int k ;
  register int i ;
  float f_L_ACF[9] ;
  float scale ;
  float s_f[160] ;
  register float *sf ;
  register float L_temp2 ;
  register float *sfl ;

  {
#line 153
  sf = s_f;
#line 155
  i = 0;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;

#line 155
    if (! (i < 160)) {
#line 155
      goto while_break;
    }
#line 155
    *(sf + i) = (float )*(s + i);
#line 155
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 156
  k = 0;
  {
#line 156
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 156
    if (! (k <= 8)) {
#line 156
      goto while_break___0;
    }
#line 157
    L_temp2 = (float )0;
#line 158
    sfl = sf - k;
#line 159
    i = k;
    {
#line 159
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 159
      if (! (i < 160)) {
#line 159
        goto while_break___1;
      }
#line 159
      L_temp2 += *(sf + i) * *(sfl + i);
#line 159
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 160
    f_L_ACF[k] = L_temp2;
#line 156
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
#line 162
  scale = (float )2147483647 / f_L_ACF[0];
#line 164
  k = 0;
  {
#line 164
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 164
    if (! (k <= 8)) {
#line 164
      goto while_break___2;
    }
#line 165
    *(L_ACF + k) = (int32_t )(f_L_ACF[k] * scale);
#line 164
    k ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 168
  return;
}
}
#line 171 "/root/patchweave_new/23/src/GSM610/lpc.c"
static void Reflection_coefficients(int32_t *L_ACF , int16_t *r ) 
{ 
  register int i ;
  register int m ;
  register int n ;
  register int16_t temp ;
  int16_t ACF[9] ;
  int16_t P[9] ;
  int16_t K[9] ;
  int32_t __cil_tmp13 ;
  int32_t __cil_tmp14 ;
  int16_t *__cil_tmp19 ;
  int32_t __cil_tmp24 ;
  int32_t __cil_tmp25 ;
  int32_t __cil_tmp26 ;
  int32_t __cil_tmp27 ;
  int32_t __cil_tmp28 ;
  int32_t __cil_tmp29 ;
  int __cil_tmp31 ;
  int16_t *__cil_tmp32 ;

  {
#line 185
  if (*(L_ACF + 0) == 0) {
    {
#line 186
    memset((void *)r, 0, 8UL * sizeof(*(r + 0)));
    }
#line 187
    return;
  }
  {
#line 191
  temp = gsm_norm(*(L_ACF + 0));
#line 196
  i = 0;
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;

#line 196
    if (! (i <= 8)) {
#line 196
      goto while_break;
    }
    {
#line 196
    __cil_tmp13 = SASL_L(*(L_ACF + i), temp);
#line 196
    __cil_tmp14 = SASR_L(__cil_tmp13, (int16_t )16);
#line 196
    ACF[i] = (int16_t )__cil_tmp14;
#line 196
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
#line 201
  i = 1;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 201
    if (! (i <= 7)) {
#line 201
      goto while_break___0;
    }
#line 201
    K[i] = ACF[i];
#line 201
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 202
  i = 0;
  {
#line 202
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 202
    if (! (i <= 8)) {
#line 202
      goto while_break___1;
    }
#line 202
    P[i] = ACF[i];
#line 202
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: 
#line 206
  n = 1;
  {
#line 206
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 206
    if (! (n <= 8)) {
#line 206
      goto while_break___2;
    }
    {
#line 207
    temp = P[1];
#line 208
    temp = GSM_ABS(temp);
    }
#line 209
    if ((int )P[0] < (int )temp) {
#line 210
      i = n;
      {
#line 210
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 210
        if (! (i <= 8)) {
#line 210
          goto while_break___3;
        }
#line 210
        __cil_tmp19 = r;
#line 210
        r ++;
#line 210
        *__cil_tmp19 = (int16_t )0;
#line 210
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: ;
#line 211
      return;
    }
    {
#line 214
    *r = gsm_div(temp, P[0]);
    }
#line 217
    if ((int )P[1] > 0) {
#line 217
      *r = (int16_t )(- ((int )*r));
    }
#line 219
    if (n == 8) {
#line 219
      return;
    }
    {
#line 223
    __cil_tmp24 = GSM_MULT_R(P[1], *r);
#line 223
    temp = (int16_t )__cil_tmp24;
#line 224
    __cil_tmp25 = GSM_ADD(P[0], temp);
#line 224
    P[0] = (int16_t )__cil_tmp25;
#line 226
    m = 1;
    }
    {
#line 226
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 226
      if (! (m <= 8 - n)) {
#line 226
        goto while_break___4;
      }
      {
#line 227
      __cil_tmp26 = GSM_MULT_R(K[m], *r);
#line 227
      temp = (int16_t )__cil_tmp26;
#line 228
      __cil_tmp27 = GSM_ADD(P[m + 1], temp);
#line 228
      P[m] = (int16_t )__cil_tmp27;
#line 230
      __cil_tmp28 = GSM_MULT_R(P[m + 1], *r);
#line 230
      temp = (int16_t )__cil_tmp28;
#line 231
      __cil_tmp29 = GSM_ADD(K[m], temp);
#line 231
      K[m] = (int16_t )__cil_tmp29;
#line 226
      m ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: 
#line 206
    __cil_tmp32 = r;
#line 206
    r ++;
#line 206
    __cil_tmp31 = n;
#line 206
    n ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: ;
#line 210
  return;
}
}
#line 238 "/root/patchweave_new/23/src/GSM610/lpc.c"
static void Transformation_to_Log_Area_Ratios(int16_t *r ) 
{ 
  register int16_t temp ;
  register int i ;
  int tmp___2 ;
  int __cil_tmp10 ;
  int16_t *__cil_tmp11 ;

  {
#line 255
  i = 1;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;

#line 255
    if (! (i <= 8)) {
#line 255
      goto while_break;
    }
    {
#line 256
    temp = *r;
#line 257
    temp = GSM_ABS(temp);
    }
#line 260
    if ((int )temp < 22118) {
#line 261
      temp = (int16_t )((int )temp >> 1);
    } else
#line 263
    if ((int )temp < 31130) {
#line 265
      temp = (int16_t )((int )temp - 11059);
    } else {
#line 269
      temp = (int16_t )((int )temp - 26112);
#line 270
      temp = (int16_t )((int )temp << 2);
    }
#line 273
    if ((int )*r < 0) {
#line 273
      tmp___2 = - ((int )temp);
    } else {
#line 273
      tmp___2 = (int )temp;
    }
#line 273
    *r = (int16_t )tmp___2;
#line 255
    __cil_tmp11 = r;
#line 255
    r ++;
#line 255
    __cil_tmp10 = i;
#line 255
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 259
  return;
}
}
#line 280 "/root/patchweave_new/23/src/GSM610/lpc.c"
static void Quantization_and_coding(int16_t *LAR ) 
{ 
  register int16_t temp ;
  int32_t __cil_tmp3 ;
  int32_t __cil_tmp4 ;
  int32_t __cil_tmp5 ;
  int tmp ;
  int tmp___0 ;
  int32_t __cil_tmp10 ;
  int32_t __cil_tmp11 ;
  int32_t __cil_tmp12 ;
  int tmp___1 ;
  int tmp___2 ;
  int32_t __cil_tmp17 ;
  int32_t __cil_tmp18 ;
  int32_t __cil_tmp19 ;
  int tmp___3 ;
  int tmp___4 ;
  int32_t __cil_tmp24 ;
  int32_t __cil_tmp25 ;
  int32_t __cil_tmp26 ;
  int tmp___5 ;
  int tmp___6 ;
  int32_t __cil_tmp31 ;
  int32_t __cil_tmp32 ;
  int32_t __cil_tmp33 ;
  int tmp___7 ;
  int tmp___8 ;
  int32_t __cil_tmp38 ;
  int32_t __cil_tmp39 ;
  int32_t __cil_tmp40 ;
  int tmp___9 ;
  int tmp___10 ;
  int32_t __cil_tmp45 ;
  int32_t __cil_tmp46 ;
  int32_t __cil_tmp47 ;
  int tmp___11 ;
  int tmp___12 ;
  int32_t __cil_tmp52 ;
  int32_t __cil_tmp53 ;
  int32_t __cil_tmp54 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 304
  __cil_tmp3 = GSM_MULT((int16_t )20480, *LAR);
#line 304
  temp = (int16_t )__cil_tmp3;
#line 304
  __cil_tmp4 = GSM_ADD(temp, (int16_t )0);
#line 304
  temp = (int16_t )__cil_tmp4;
#line 304
  __cil_tmp5 = GSM_ADD(temp, (int16_t )256);
#line 304
  temp = (int16_t )__cil_tmp5;
#line 304
  temp = SASR_W(temp, (int16_t )9);
  }
#line 304
  if ((int )temp > 31) {
#line 304
    tmp___0 = 63;
  } else {
#line 304
    if ((int )temp < -32) {
#line 304
      tmp = 0;
    } else {
#line 304
      tmp = (int )temp - -32;
    }
#line 304
    tmp___0 = tmp;
  }
  {
#line 304
  *LAR = (int16_t )tmp___0;
#line 304
  LAR ++;
#line 305
  __cil_tmp10 = GSM_MULT((int16_t )20480, *LAR);
#line 305
  temp = (int16_t )__cil_tmp10;
#line 305
  __cil_tmp11 = GSM_ADD(temp, (int16_t )0);
#line 305
  temp = (int16_t )__cil_tmp11;
#line 305
  __cil_tmp12 = GSM_ADD(temp, (int16_t )256);
#line 305
  temp = (int16_t )__cil_tmp12;
#line 305
  temp = SASR_W(temp, (int16_t )9);
  }
#line 305
  if ((int )temp > 31) {
#line 305
    tmp___2 = 63;
  } else {
#line 305
    if ((int )temp < -32) {
#line 305
      tmp___1 = 0;
    } else {
#line 305
      tmp___1 = (int )temp - -32;
    }
#line 305
    tmp___2 = tmp___1;
  }
  {
#line 305
  *LAR = (int16_t )tmp___2;
#line 305
  LAR ++;
#line 306
  __cil_tmp17 = GSM_MULT((int16_t )20480, *LAR);
#line 306
  temp = (int16_t )__cil_tmp17;
#line 306
  __cil_tmp18 = GSM_ADD(temp, (int16_t )2048);
#line 306
  temp = (int16_t )__cil_tmp18;
#line 306
  __cil_tmp19 = GSM_ADD(temp, (int16_t )256);
#line 306
  temp = (int16_t )__cil_tmp19;
#line 306
  temp = SASR_W(temp, (int16_t )9);
  }
#line 306
  if ((int )temp > 15) {
#line 306
    tmp___4 = 31;
  } else {
#line 306
    if ((int )temp < -16) {
#line 306
      tmp___3 = 0;
    } else {
#line 306
      tmp___3 = (int )temp - -16;
    }
#line 306
    tmp___4 = tmp___3;
  }
  {
#line 306
  *LAR = (int16_t )tmp___4;
#line 306
  LAR ++;
#line 307
  __cil_tmp24 = GSM_MULT((int16_t )20480, *LAR);
#line 307
  temp = (int16_t )__cil_tmp24;
#line 307
  __cil_tmp25 = GSM_ADD(temp, (int16_t )-2560);
#line 307
  temp = (int16_t )__cil_tmp25;
#line 307
  __cil_tmp26 = GSM_ADD(temp, (int16_t )256);
#line 307
  temp = (int16_t )__cil_tmp26;
#line 307
  temp = SASR_W(temp, (int16_t )9);
  }
#line 307
  if ((int )temp > 15) {
#line 307
    tmp___6 = 31;
  } else {
#line 307
    if ((int )temp < -16) {
#line 307
      tmp___5 = 0;
    } else {
#line 307
      tmp___5 = (int )temp - -16;
    }
#line 307
    tmp___6 = tmp___5;
  }
  {
#line 307
  *LAR = (int16_t )tmp___6;
#line 307
  LAR ++;
#line 309
  __cil_tmp31 = GSM_MULT((int16_t )13964, *LAR);
#line 309
  temp = (int16_t )__cil_tmp31;
#line 309
  __cil_tmp32 = GSM_ADD(temp, (int16_t )94);
#line 309
  temp = (int16_t )__cil_tmp32;
#line 309
  __cil_tmp33 = GSM_ADD(temp, (int16_t )256);
#line 309
  temp = (int16_t )__cil_tmp33;
#line 309
  temp = SASR_W(temp, (int16_t )9);
  }
#line 309
  if ((int )temp > 7) {
#line 309
    tmp___8 = 15;
  } else {
#line 309
    if ((int )temp < -8) {
#line 309
      tmp___7 = 0;
    } else {
#line 309
      tmp___7 = (int )temp - -8;
    }
#line 309
    tmp___8 = tmp___7;
  }
  {
#line 309
  *LAR = (int16_t )tmp___8;
#line 309
  LAR ++;
#line 310
  __cil_tmp38 = GSM_MULT((int16_t )15360, *LAR);
#line 310
  temp = (int16_t )__cil_tmp38;
#line 310
  __cil_tmp39 = GSM_ADD(temp, (int16_t )-1792);
#line 310
  temp = (int16_t )__cil_tmp39;
#line 310
  __cil_tmp40 = GSM_ADD(temp, (int16_t )256);
#line 310
  temp = (int16_t )__cil_tmp40;
#line 310
  temp = SASR_W(temp, (int16_t )9);
  }
#line 310
  if ((int )temp > 7) {
#line 310
    tmp___10 = 15;
  } else {
#line 310
    if ((int )temp < -8) {
#line 310
      tmp___9 = 0;
    } else {
#line 310
      tmp___9 = (int )temp - -8;
    }
#line 310
    tmp___10 = tmp___9;
  }
  {
#line 310
  *LAR = (int16_t )tmp___10;
#line 310
  LAR ++;
#line 311
  __cil_tmp45 = GSM_MULT((int16_t )8534, *LAR);
#line 311
  temp = (int16_t )__cil_tmp45;
#line 311
  __cil_tmp46 = GSM_ADD(temp, (int16_t )-341);
#line 311
  temp = (int16_t )__cil_tmp46;
#line 311
  __cil_tmp47 = GSM_ADD(temp, (int16_t )256);
#line 311
  temp = (int16_t )__cil_tmp47;
#line 311
  temp = SASR_W(temp, (int16_t )9);
  }
#line 311
  if ((int )temp > 3) {
#line 311
    tmp___12 = 7;
  } else {
#line 311
    if ((int )temp < -4) {
#line 311
      tmp___11 = 0;
    } else {
#line 311
      tmp___11 = (int )temp - -4;
    }
#line 311
    tmp___12 = tmp___11;
  }
  {
#line 311
  *LAR = (int16_t )tmp___12;
#line 311
  LAR ++;
#line 312
  __cil_tmp52 = GSM_MULT((int16_t )9036, *LAR);
#line 312
  temp = (int16_t )__cil_tmp52;
#line 312
  __cil_tmp53 = GSM_ADD(temp, (int16_t )-1144);
#line 312
  temp = (int16_t )__cil_tmp53;
#line 312
  __cil_tmp54 = GSM_ADD(temp, (int16_t )256);
#line 312
  temp = (int16_t )__cil_tmp54;
#line 312
  temp = SASR_W(temp, (int16_t )9);
  }
#line 312
  if ((int )temp > 3) {
#line 312
    tmp___14 = 7;
  } else {
#line 312
    if ((int )temp < -4) {
#line 312
      tmp___13 = 0;
    } else {
#line 312
      tmp___13 = (int )temp - -4;
    }
#line 312
    tmp___14 = tmp___13;
  }
#line 312
  *LAR = (int16_t )tmp___14;
#line 312
  LAR ++;
#line 313
  return;
}
}
#line 317 "/root/patchweave_new/23/src/GSM610/lpc.c"
void Gsm_LPC_Analysis(struct gsm_state *S , int16_t *s , int16_t *LARc ) 
{ 
  int32_t L_ACF[9] ;

  {
#line 325
  if (S->fast) {
    {
#line 326
    Fast_Autocorrelation(s, L_ACF);
    }
  } else {
    {
#line 329
    Autocorrelation(s, L_ACF);
    }
  }
  {
#line 330
  Reflection_coefficients(L_ACF, LARc);
#line 331
  Transformation_to_Log_Area_Ratios(LARc);
#line 332
  Quantization_and_coding(LARc);
  }
#line 334
  return;
}
}
#line 462 "/root/patchweave_new/23/src/GSM610/long_term.c"
static void Calculation_of_the_LTP_parameters(int16_t *din , int16_t *dp , int16_t *bc_out ,
                                              int16_t *Nc_out ) 
{ 
  register int k ;
  register int lambda ;
  int16_t Nc ;
  int16_t bc ;
  float wt_float[40] ;
  float dp_float_base[120] ;
  float *dp_float ;
  int32_t L_max ;
  int32_t L_power ;
  int16_t R ;
  int16_t S ;
  int16_t dmax ;
  int16_t scal ;
  register int16_t temp ;
  int16_t __cil_tmp24 ;
  register float *lp ;
  register float W ;
  register float a ;
  register float b ;
  register float c ;
  register float d ;
  register float e ;
  register float f ;
  register float g ;
  register float h ;
  register float E ;
  register float S0 ;
  register float S1 ;
  register float S2 ;
  register float S3 ;
  register float S4 ;
  register float S5 ;
  register float S6 ;
  register float S7 ;
  register float S8 ;
  register int32_t L_temp ;
  int16_t __cil_tmp50 ;
  int32_t __cil_tmp53 ;
  int32_t __cil_tmp54 ;
  int16_t __cil_tmp55 ;

  {
#line 472
  dp_float = dp_float_base + 120;
#line 480
  dmax = (int16_t )0;
#line 482
  k = 0;
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;

#line 482
    if (! (k <= 39)) {
#line 482
      goto while_break;
    }
    {
#line 483
    temp = *(din + k);
#line 484
    temp = GSM_ABS(temp);
    }
#line 485
    if ((int )temp > (int )dmax) {
#line 485
      dmax = temp;
    }
#line 482
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
#line 488
  temp = (int16_t )0;
#line 489
  if ((int )dmax == 0) {
#line 489
    scal = (int16_t )0;
  } else {
    {
#line 492
    temp = gsm_norm((int32_t )dmax << 16);
    }
  }
#line 495
  if ((int )temp > 6) {
#line 495
    scal = (int16_t )0;
  } else {
#line 496
    scal = (int16_t )(6 - (int )temp);
  }
#line 502
  k = 0;
  {
#line 502
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 502
    if (! (k < 40)) {
#line 502
      goto while_break___0;
    }
    {
#line 502
    __cil_tmp24 = SASR_W(*(din + k), scal);
#line 502
    wt_float[k] = (float )__cil_tmp24;
#line 502
    k ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 503
  k = -120;
  {
#line 503
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 503
    if (! (k < 0)) {
#line 503
      goto while_break___1;
    }
#line 503
    *(dp_float + k) = (float )*(dp + k);
#line 503
    k ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: 
#line 507
  L_max = 0;
#line 508
  Nc = (int16_t )40;
#line 510
  lambda = 40;
  {
#line 510
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 510
    if (! (lambda <= 120)) {
#line 510
      goto while_break___2;
    }
#line 512
    lp = dp_float - lambda;
#line 515
    a = *(lp + -8);
#line 515
    b = *(lp + -7);
#line 515
    c = *(lp + -6);
#line 515
    d = *(lp + -5);
#line 515
    e = *(lp + -4);
#line 515
    f = *(lp + -3);
#line 515
    g = *(lp + -2);
#line 515
    h = *(lp + -1);
#line 519
    S0 = (float )0;
#line 519
    S1 = (float )0;
#line 519
    S2 = (float )0;
#line 519
    S3 = (float )0;
#line 519
    S4 = (float )0;
#line 519
    S5 = (float )0;
#line 519
    S6 = (float )0;
#line 519
    S7 = (float )0;
#line 519
    S8 = (float )0;
#line 545
    W = wt_float[0];
#line 545
    E = W * a;
#line 545
    S8 += E;
#line 545
    E = W * b;
#line 545
    S7 += E;
#line 545
    E = W * c;
#line 545
    S6 += E;
#line 545
    E = W * d;
#line 545
    S5 += E;
#line 545
    E = W * e;
#line 545
    S4 += E;
#line 545
    E = W * f;
#line 545
    S3 += E;
#line 545
    E = W * g;
#line 545
    S2 += E;
#line 545
    E = W * h;
#line 545
    S1 += E;
#line 545
    a = *(lp + 0);
#line 545
    E = W * a;
#line 545
    S0 += E;
#line 545
    W = wt_float[1];
#line 545
    E = W * b;
#line 545
    S8 += E;
#line 545
    E = W * c;
#line 545
    S7 += E;
#line 545
    E = W * d;
#line 545
    S6 += E;
#line 545
    E = W * e;
#line 545
    S5 += E;
#line 545
    E = W * f;
#line 545
    S4 += E;
#line 545
    E = W * g;
#line 545
    S3 += E;
#line 545
    E = W * h;
#line 545
    S2 += E;
#line 545
    E = W * a;
#line 545
    S1 += E;
#line 545
    b = *(lp + 1);
#line 545
    E = W * b;
#line 545
    S0 += E;
#line 545
    W = wt_float[2];
#line 545
    E = W * c;
#line 545
    S8 += E;
#line 545
    E = W * d;
#line 545
    S7 += E;
#line 545
    E = W * e;
#line 545
    S6 += E;
#line 545
    E = W * f;
#line 545
    S5 += E;
#line 545
    E = W * g;
#line 545
    S4 += E;
#line 545
    E = W * h;
#line 545
    S3 += E;
#line 545
    E = W * a;
#line 545
    S2 += E;
#line 545
    E = W * b;
#line 545
    S1 += E;
#line 545
    c = *(lp + 2);
#line 545
    E = W * c;
#line 545
    S0 += E;
#line 545
    W = wt_float[3];
#line 545
    E = W * d;
#line 545
    S8 += E;
#line 545
    E = W * e;
#line 545
    S7 += E;
#line 545
    E = W * f;
#line 545
    S6 += E;
#line 545
    E = W * g;
#line 545
    S5 += E;
#line 545
    E = W * h;
#line 545
    S4 += E;
#line 545
    E = W * a;
#line 545
    S3 += E;
#line 545
    E = W * b;
#line 545
    S2 += E;
#line 545
    E = W * c;
#line 545
    S1 += E;
#line 545
    d = *(lp + 3);
#line 545
    E = W * d;
#line 545
    S0 += E;
#line 546
    W = wt_float[4];
#line 546
    E = W * e;
#line 546
    S8 += E;
#line 546
    E = W * f;
#line 546
    S7 += E;
#line 546
    E = W * g;
#line 546
    S6 += E;
#line 546
    E = W * h;
#line 546
    S5 += E;
#line 546
    E = W * a;
#line 546
    S4 += E;
#line 546
    E = W * b;
#line 546
    S3 += E;
#line 546
    E = W * c;
#line 546
    S2 += E;
#line 546
    E = W * d;
#line 546
    S1 += E;
#line 546
    e = *(lp + 4);
#line 546
    E = W * e;
#line 546
    S0 += E;
#line 546
    W = wt_float[5];
#line 546
    E = W * f;
#line 546
    S8 += E;
#line 546
    E = W * g;
#line 546
    S7 += E;
#line 546
    E = W * h;
#line 546
    S6 += E;
#line 546
    E = W * a;
#line 546
    S5 += E;
#line 546
    E = W * b;
#line 546
    S4 += E;
#line 546
    E = W * c;
#line 546
    S3 += E;
#line 546
    E = W * d;
#line 546
    S2 += E;
#line 546
    E = W * e;
#line 546
    S1 += E;
#line 546
    f = *(lp + 5);
#line 546
    E = W * f;
#line 546
    S0 += E;
#line 546
    W = wt_float[6];
#line 546
    E = W * g;
#line 546
    S8 += E;
#line 546
    E = W * h;
#line 546
    S7 += E;
#line 546
    E = W * a;
#line 546
    S6 += E;
#line 546
    E = W * b;
#line 546
    S5 += E;
#line 546
    E = W * c;
#line 546
    S4 += E;
#line 546
    E = W * d;
#line 546
    S3 += E;
#line 546
    E = W * e;
#line 546
    S2 += E;
#line 546
    E = W * f;
#line 546
    S1 += E;
#line 546
    g = *(lp + 6);
#line 546
    E = W * g;
#line 546
    S0 += E;
#line 546
    W = wt_float[7];
#line 546
    E = W * h;
#line 546
    S8 += E;
#line 546
    E = W * a;
#line 546
    S7 += E;
#line 546
    E = W * b;
#line 546
    S6 += E;
#line 546
    E = W * c;
#line 546
    S5 += E;
#line 546
    E = W * d;
#line 546
    S4 += E;
#line 546
    E = W * e;
#line 546
    S3 += E;
#line 546
    E = W * f;
#line 546
    S2 += E;
#line 546
    E = W * g;
#line 546
    S1 += E;
#line 546
    h = *(lp + 7);
#line 546
    E = W * h;
#line 546
    S0 += E;
#line 548
    W = wt_float[8];
#line 548
    E = W * a;
#line 548
    S8 += E;
#line 548
    E = W * b;
#line 548
    S7 += E;
#line 548
    E = W * c;
#line 548
    S6 += E;
#line 548
    E = W * d;
#line 548
    S5 += E;
#line 548
    E = W * e;
#line 548
    S4 += E;
#line 548
    E = W * f;
#line 548
    S3 += E;
#line 548
    E = W * g;
#line 548
    S2 += E;
#line 548
    E = W * h;
#line 548
    S1 += E;
#line 548
    a = *(lp + 8);
#line 548
    E = W * a;
#line 548
    S0 += E;
#line 548
    W = wt_float[9];
#line 548
    E = W * b;
#line 548
    S8 += E;
#line 548
    E = W * c;
#line 548
    S7 += E;
#line 548
    E = W * d;
#line 548
    S6 += E;
#line 548
    E = W * e;
#line 548
    S5 += E;
#line 548
    E = W * f;
#line 548
    S4 += E;
#line 548
    E = W * g;
#line 548
    S3 += E;
#line 548
    E = W * h;
#line 548
    S2 += E;
#line 548
    E = W * a;
#line 548
    S1 += E;
#line 548
    b = *(lp + 9);
#line 548
    E = W * b;
#line 548
    S0 += E;
#line 548
    W = wt_float[10];
#line 548
    E = W * c;
#line 548
    S8 += E;
#line 548
    E = W * d;
#line 548
    S7 += E;
#line 548
    E = W * e;
#line 548
    S6 += E;
#line 548
    E = W * f;
#line 548
    S5 += E;
#line 548
    E = W * g;
#line 548
    S4 += E;
#line 548
    E = W * h;
#line 548
    S3 += E;
#line 548
    E = W * a;
#line 548
    S2 += E;
#line 548
    E = W * b;
#line 548
    S1 += E;
#line 548
    c = *(lp + 10);
#line 548
    E = W * c;
#line 548
    S0 += E;
#line 548
    W = wt_float[11];
#line 548
    E = W * d;
#line 548
    S8 += E;
#line 548
    E = W * e;
#line 548
    S7 += E;
#line 548
    E = W * f;
#line 548
    S6 += E;
#line 548
    E = W * g;
#line 548
    S5 += E;
#line 548
    E = W * h;
#line 548
    S4 += E;
#line 548
    E = W * a;
#line 548
    S3 += E;
#line 548
    E = W * b;
#line 548
    S2 += E;
#line 548
    E = W * c;
#line 548
    S1 += E;
#line 548
    d = *(lp + 11);
#line 548
    E = W * d;
#line 548
    S0 += E;
#line 549
    W = wt_float[12];
#line 549
    E = W * e;
#line 549
    S8 += E;
#line 549
    E = W * f;
#line 549
    S7 += E;
#line 549
    E = W * g;
#line 549
    S6 += E;
#line 549
    E = W * h;
#line 549
    S5 += E;
#line 549
    E = W * a;
#line 549
    S4 += E;
#line 549
    E = W * b;
#line 549
    S3 += E;
#line 549
    E = W * c;
#line 549
    S2 += E;
#line 549
    E = W * d;
#line 549
    S1 += E;
#line 549
    e = *(lp + 12);
#line 549
    E = W * e;
#line 549
    S0 += E;
#line 549
    W = wt_float[13];
#line 549
    E = W * f;
#line 549
    S8 += E;
#line 549
    E = W * g;
#line 549
    S7 += E;
#line 549
    E = W * h;
#line 549
    S6 += E;
#line 549
    E = W * a;
#line 549
    S5 += E;
#line 549
    E = W * b;
#line 549
    S4 += E;
#line 549
    E = W * c;
#line 549
    S3 += E;
#line 549
    E = W * d;
#line 549
    S2 += E;
#line 549
    E = W * e;
#line 549
    S1 += E;
#line 549
    f = *(lp + 13);
#line 549
    E = W * f;
#line 549
    S0 += E;
#line 549
    W = wt_float[14];
#line 549
    E = W * g;
#line 549
    S8 += E;
#line 549
    E = W * h;
#line 549
    S7 += E;
#line 549
    E = W * a;
#line 549
    S6 += E;
#line 549
    E = W * b;
#line 549
    S5 += E;
#line 549
    E = W * c;
#line 549
    S4 += E;
#line 549
    E = W * d;
#line 549
    S3 += E;
#line 549
    E = W * e;
#line 549
    S2 += E;
#line 549
    E = W * f;
#line 549
    S1 += E;
#line 549
    g = *(lp + 14);
#line 549
    E = W * g;
#line 549
    S0 += E;
#line 549
    W = wt_float[15];
#line 549
    E = W * h;
#line 549
    S8 += E;
#line 549
    E = W * a;
#line 549
    S7 += E;
#line 549
    E = W * b;
#line 549
    S6 += E;
#line 549
    E = W * c;
#line 549
    S5 += E;
#line 549
    E = W * d;
#line 549
    S4 += E;
#line 549
    E = W * e;
#line 549
    S3 += E;
#line 549
    E = W * f;
#line 549
    S2 += E;
#line 549
    E = W * g;
#line 549
    S1 += E;
#line 549
    h = *(lp + 15);
#line 549
    E = W * h;
#line 549
    S0 += E;
#line 551
    W = wt_float[16];
#line 551
    E = W * a;
#line 551
    S8 += E;
#line 551
    E = W * b;
#line 551
    S7 += E;
#line 551
    E = W * c;
#line 551
    S6 += E;
#line 551
    E = W * d;
#line 551
    S5 += E;
#line 551
    E = W * e;
#line 551
    S4 += E;
#line 551
    E = W * f;
#line 551
    S3 += E;
#line 551
    E = W * g;
#line 551
    S2 += E;
#line 551
    E = W * h;
#line 551
    S1 += E;
#line 551
    a = *(lp + 16);
#line 551
    E = W * a;
#line 551
    S0 += E;
#line 551
    W = wt_float[17];
#line 551
    E = W * b;
#line 551
    S8 += E;
#line 551
    E = W * c;
#line 551
    S7 += E;
#line 551
    E = W * d;
#line 551
    S6 += E;
#line 551
    E = W * e;
#line 551
    S5 += E;
#line 551
    E = W * f;
#line 551
    S4 += E;
#line 551
    E = W * g;
#line 551
    S3 += E;
#line 551
    E = W * h;
#line 551
    S2 += E;
#line 551
    E = W * a;
#line 551
    S1 += E;
#line 551
    b = *(lp + 17);
#line 551
    E = W * b;
#line 551
    S0 += E;
#line 551
    W = wt_float[18];
#line 551
    E = W * c;
#line 551
    S8 += E;
#line 551
    E = W * d;
#line 551
    S7 += E;
#line 551
    E = W * e;
#line 551
    S6 += E;
#line 551
    E = W * f;
#line 551
    S5 += E;
#line 551
    E = W * g;
#line 551
    S4 += E;
#line 551
    E = W * h;
#line 551
    S3 += E;
#line 551
    E = W * a;
#line 551
    S2 += E;
#line 551
    E = W * b;
#line 551
    S1 += E;
#line 551
    c = *(lp + 18);
#line 551
    E = W * c;
#line 551
    S0 += E;
#line 551
    W = wt_float[19];
#line 551
    E = W * d;
#line 551
    S8 += E;
#line 551
    E = W * e;
#line 551
    S7 += E;
#line 551
    E = W * f;
#line 551
    S6 += E;
#line 551
    E = W * g;
#line 551
    S5 += E;
#line 551
    E = W * h;
#line 551
    S4 += E;
#line 551
    E = W * a;
#line 551
    S3 += E;
#line 551
    E = W * b;
#line 551
    S2 += E;
#line 551
    E = W * c;
#line 551
    S1 += E;
#line 551
    d = *(lp + 19);
#line 551
    E = W * d;
#line 551
    S0 += E;
#line 552
    W = wt_float[20];
#line 552
    E = W * e;
#line 552
    S8 += E;
#line 552
    E = W * f;
#line 552
    S7 += E;
#line 552
    E = W * g;
#line 552
    S6 += E;
#line 552
    E = W * h;
#line 552
    S5 += E;
#line 552
    E = W * a;
#line 552
    S4 += E;
#line 552
    E = W * b;
#line 552
    S3 += E;
#line 552
    E = W * c;
#line 552
    S2 += E;
#line 552
    E = W * d;
#line 552
    S1 += E;
#line 552
    e = *(lp + 20);
#line 552
    E = W * e;
#line 552
    S0 += E;
#line 552
    W = wt_float[21];
#line 552
    E = W * f;
#line 552
    S8 += E;
#line 552
    E = W * g;
#line 552
    S7 += E;
#line 552
    E = W * h;
#line 552
    S6 += E;
#line 552
    E = W * a;
#line 552
    S5 += E;
#line 552
    E = W * b;
#line 552
    S4 += E;
#line 552
    E = W * c;
#line 552
    S3 += E;
#line 552
    E = W * d;
#line 552
    S2 += E;
#line 552
    E = W * e;
#line 552
    S1 += E;
#line 552
    f = *(lp + 21);
#line 552
    E = W * f;
#line 552
    S0 += E;
#line 552
    W = wt_float[22];
#line 552
    E = W * g;
#line 552
    S8 += E;
#line 552
    E = W * h;
#line 552
    S7 += E;
#line 552
    E = W * a;
#line 552
    S6 += E;
#line 552
    E = W * b;
#line 552
    S5 += E;
#line 552
    E = W * c;
#line 552
    S4 += E;
#line 552
    E = W * d;
#line 552
    S3 += E;
#line 552
    E = W * e;
#line 552
    S2 += E;
#line 552
    E = W * f;
#line 552
    S1 += E;
#line 552
    g = *(lp + 22);
#line 552
    E = W * g;
#line 552
    S0 += E;
#line 552
    W = wt_float[23];
#line 552
    E = W * h;
#line 552
    S8 += E;
#line 552
    E = W * a;
#line 552
    S7 += E;
#line 552
    E = W * b;
#line 552
    S6 += E;
#line 552
    E = W * c;
#line 552
    S5 += E;
#line 552
    E = W * d;
#line 552
    S4 += E;
#line 552
    E = W * e;
#line 552
    S3 += E;
#line 552
    E = W * f;
#line 552
    S2 += E;
#line 552
    E = W * g;
#line 552
    S1 += E;
#line 552
    h = *(lp + 23);
#line 552
    E = W * h;
#line 552
    S0 += E;
#line 554
    W = wt_float[24];
#line 554
    E = W * a;
#line 554
    S8 += E;
#line 554
    E = W * b;
#line 554
    S7 += E;
#line 554
    E = W * c;
#line 554
    S6 += E;
#line 554
    E = W * d;
#line 554
    S5 += E;
#line 554
    E = W * e;
#line 554
    S4 += E;
#line 554
    E = W * f;
#line 554
    S3 += E;
#line 554
    E = W * g;
#line 554
    S2 += E;
#line 554
    E = W * h;
#line 554
    S1 += E;
#line 554
    a = *(lp + 24);
#line 554
    E = W * a;
#line 554
    S0 += E;
#line 554
    W = wt_float[25];
#line 554
    E = W * b;
#line 554
    S8 += E;
#line 554
    E = W * c;
#line 554
    S7 += E;
#line 554
    E = W * d;
#line 554
    S6 += E;
#line 554
    E = W * e;
#line 554
    S5 += E;
#line 554
    E = W * f;
#line 554
    S4 += E;
#line 554
    E = W * g;
#line 554
    S3 += E;
#line 554
    E = W * h;
#line 554
    S2 += E;
#line 554
    E = W * a;
#line 554
    S1 += E;
#line 554
    b = *(lp + 25);
#line 554
    E = W * b;
#line 554
    S0 += E;
#line 554
    W = wt_float[26];
#line 554
    E = W * c;
#line 554
    S8 += E;
#line 554
    E = W * d;
#line 554
    S7 += E;
#line 554
    E = W * e;
#line 554
    S6 += E;
#line 554
    E = W * f;
#line 554
    S5 += E;
#line 554
    E = W * g;
#line 554
    S4 += E;
#line 554
    E = W * h;
#line 554
    S3 += E;
#line 554
    E = W * a;
#line 554
    S2 += E;
#line 554
    E = W * b;
#line 554
    S1 += E;
#line 554
    c = *(lp + 26);
#line 554
    E = W * c;
#line 554
    S0 += E;
#line 554
    W = wt_float[27];
#line 554
    E = W * d;
#line 554
    S8 += E;
#line 554
    E = W * e;
#line 554
    S7 += E;
#line 554
    E = W * f;
#line 554
    S6 += E;
#line 554
    E = W * g;
#line 554
    S5 += E;
#line 554
    E = W * h;
#line 554
    S4 += E;
#line 554
    E = W * a;
#line 554
    S3 += E;
#line 554
    E = W * b;
#line 554
    S2 += E;
#line 554
    E = W * c;
#line 554
    S1 += E;
#line 554
    d = *(lp + 27);
#line 554
    E = W * d;
#line 554
    S0 += E;
#line 555
    W = wt_float[28];
#line 555
    E = W * e;
#line 555
    S8 += E;
#line 555
    E = W * f;
#line 555
    S7 += E;
#line 555
    E = W * g;
#line 555
    S6 += E;
#line 555
    E = W * h;
#line 555
    S5 += E;
#line 555
    E = W * a;
#line 555
    S4 += E;
#line 555
    E = W * b;
#line 555
    S3 += E;
#line 555
    E = W * c;
#line 555
    S2 += E;
#line 555
    E = W * d;
#line 555
    S1 += E;
#line 555
    e = *(lp + 28);
#line 555
    E = W * e;
#line 555
    S0 += E;
#line 555
    W = wt_float[29];
#line 555
    E = W * f;
#line 555
    S8 += E;
#line 555
    E = W * g;
#line 555
    S7 += E;
#line 555
    E = W * h;
#line 555
    S6 += E;
#line 555
    E = W * a;
#line 555
    S5 += E;
#line 555
    E = W * b;
#line 555
    S4 += E;
#line 555
    E = W * c;
#line 555
    S3 += E;
#line 555
    E = W * d;
#line 555
    S2 += E;
#line 555
    E = W * e;
#line 555
    S1 += E;
#line 555
    f = *(lp + 29);
#line 555
    E = W * f;
#line 555
    S0 += E;
#line 555
    W = wt_float[30];
#line 555
    E = W * g;
#line 555
    S8 += E;
#line 555
    E = W * h;
#line 555
    S7 += E;
#line 555
    E = W * a;
#line 555
    S6 += E;
#line 555
    E = W * b;
#line 555
    S5 += E;
#line 555
    E = W * c;
#line 555
    S4 += E;
#line 555
    E = W * d;
#line 555
    S3 += E;
#line 555
    E = W * e;
#line 555
    S2 += E;
#line 555
    E = W * f;
#line 555
    S1 += E;
#line 555
    g = *(lp + 30);
#line 555
    E = W * g;
#line 555
    S0 += E;
#line 555
    W = wt_float[31];
#line 555
    E = W * h;
#line 555
    S8 += E;
#line 555
    E = W * a;
#line 555
    S7 += E;
#line 555
    E = W * b;
#line 555
    S6 += E;
#line 555
    E = W * c;
#line 555
    S5 += E;
#line 555
    E = W * d;
#line 555
    S4 += E;
#line 555
    E = W * e;
#line 555
    S3 += E;
#line 555
    E = W * f;
#line 555
    S2 += E;
#line 555
    E = W * g;
#line 555
    S1 += E;
#line 555
    h = *(lp + 31);
#line 555
    E = W * h;
#line 555
    S0 += E;
#line 557
    W = wt_float[32];
#line 557
    E = W * a;
#line 557
    S8 += E;
#line 557
    E = W * b;
#line 557
    S7 += E;
#line 557
    E = W * c;
#line 557
    S6 += E;
#line 557
    E = W * d;
#line 557
    S5 += E;
#line 557
    E = W * e;
#line 557
    S4 += E;
#line 557
    E = W * f;
#line 557
    S3 += E;
#line 557
    E = W * g;
#line 557
    S2 += E;
#line 557
    E = W * h;
#line 557
    S1 += E;
#line 557
    a = *(lp + 32);
#line 557
    E = W * a;
#line 557
    S0 += E;
#line 557
    W = wt_float[33];
#line 557
    E = W * b;
#line 557
    S8 += E;
#line 557
    E = W * c;
#line 557
    S7 += E;
#line 557
    E = W * d;
#line 557
    S6 += E;
#line 557
    E = W * e;
#line 557
    S5 += E;
#line 557
    E = W * f;
#line 557
    S4 += E;
#line 557
    E = W * g;
#line 557
    S3 += E;
#line 557
    E = W * h;
#line 557
    S2 += E;
#line 557
    E = W * a;
#line 557
    S1 += E;
#line 557
    b = *(lp + 33);
#line 557
    E = W * b;
#line 557
    S0 += E;
#line 557
    W = wt_float[34];
#line 557
    E = W * c;
#line 557
    S8 += E;
#line 557
    E = W * d;
#line 557
    S7 += E;
#line 557
    E = W * e;
#line 557
    S6 += E;
#line 557
    E = W * f;
#line 557
    S5 += E;
#line 557
    E = W * g;
#line 557
    S4 += E;
#line 557
    E = W * h;
#line 557
    S3 += E;
#line 557
    E = W * a;
#line 557
    S2 += E;
#line 557
    E = W * b;
#line 557
    S1 += E;
#line 557
    c = *(lp + 34);
#line 557
    E = W * c;
#line 557
    S0 += E;
#line 557
    W = wt_float[35];
#line 557
    E = W * d;
#line 557
    S8 += E;
#line 557
    E = W * e;
#line 557
    S7 += E;
#line 557
    E = W * f;
#line 557
    S6 += E;
#line 557
    E = W * g;
#line 557
    S5 += E;
#line 557
    E = W * h;
#line 557
    S4 += E;
#line 557
    E = W * a;
#line 557
    S3 += E;
#line 557
    E = W * b;
#line 557
    S2 += E;
#line 557
    E = W * c;
#line 557
    S1 += E;
#line 557
    d = *(lp + 35);
#line 557
    E = W * d;
#line 557
    S0 += E;
#line 558
    W = wt_float[36];
#line 558
    E = W * e;
#line 558
    S8 += E;
#line 558
    E = W * f;
#line 558
    S7 += E;
#line 558
    E = W * g;
#line 558
    S6 += E;
#line 558
    E = W * h;
#line 558
    S5 += E;
#line 558
    E = W * a;
#line 558
    S4 += E;
#line 558
    E = W * b;
#line 558
    S3 += E;
#line 558
    E = W * c;
#line 558
    S2 += E;
#line 558
    E = W * d;
#line 558
    S1 += E;
#line 558
    e = *(lp + 36);
#line 558
    E = W * e;
#line 558
    S0 += E;
#line 558
    W = wt_float[37];
#line 558
    E = W * f;
#line 558
    S8 += E;
#line 558
    E = W * g;
#line 558
    S7 += E;
#line 558
    E = W * h;
#line 558
    S6 += E;
#line 558
    E = W * a;
#line 558
    S5 += E;
#line 558
    E = W * b;
#line 558
    S4 += E;
#line 558
    E = W * c;
#line 558
    S3 += E;
#line 558
    E = W * d;
#line 558
    S2 += E;
#line 558
    E = W * e;
#line 558
    S1 += E;
#line 558
    f = *(lp + 37);
#line 558
    E = W * f;
#line 558
    S0 += E;
#line 558
    W = wt_float[38];
#line 558
    E = W * g;
#line 558
    S8 += E;
#line 558
    E = W * h;
#line 558
    S7 += E;
#line 558
    E = W * a;
#line 558
    S6 += E;
#line 558
    E = W * b;
#line 558
    S5 += E;
#line 558
    E = W * c;
#line 558
    S4 += E;
#line 558
    E = W * d;
#line 558
    S3 += E;
#line 558
    E = W * e;
#line 558
    S2 += E;
#line 558
    E = W * f;
#line 558
    S1 += E;
#line 558
    g = *(lp + 38);
#line 558
    E = W * g;
#line 558
    S0 += E;
#line 558
    W = wt_float[39];
#line 558
    E = W * h;
#line 558
    S8 += E;
#line 558
    E = W * a;
#line 558
    S7 += E;
#line 558
    E = W * b;
#line 558
    S6 += E;
#line 558
    E = W * c;
#line 558
    S5 += E;
#line 558
    E = W * d;
#line 558
    S4 += E;
#line 558
    E = W * e;
#line 558
    S3 += E;
#line 558
    E = W * f;
#line 558
    S2 += E;
#line 558
    E = W * g;
#line 558
    S1 += E;
#line 558
    h = *(lp + 39);
#line 558
    E = W * h;
#line 558
    S0 += E;
#line 569
    if (S0 > (float )L_max) {
#line 569
      L_max = (int32_t )S0;
#line 569
      Nc = (int16_t )lambda;
    }
#line 570
    if (S1 > (float )L_max) {
#line 570
      L_max = (int32_t )S1;
#line 570
      Nc = (int16_t )(lambda + 1);
    }
#line 571
    if (S2 > (float )L_max) {
#line 571
      L_max = (int32_t )S2;
#line 571
      Nc = (int16_t )(lambda + 2);
    }
#line 572
    if (S3 > (float )L_max) {
#line 572
      L_max = (int32_t )S3;
#line 572
      Nc = (int16_t )(lambda + 3);
    }
#line 573
    if (S4 > (float )L_max) {
#line 573
      L_max = (int32_t )S4;
#line 573
      Nc = (int16_t )(lambda + 4);
    }
#line 574
    if (S5 > (float )L_max) {
#line 574
      L_max = (int32_t )S5;
#line 574
      Nc = (int16_t )(lambda + 5);
    }
#line 575
    if (S6 > (float )L_max) {
#line 575
      L_max = (int32_t )S6;
#line 575
      Nc = (int16_t )(lambda + 6);
    }
#line 576
    if (S7 > (float )L_max) {
#line 576
      L_max = (int32_t )S7;
#line 576
      Nc = (int16_t )(lambda + 7);
    }
#line 577
    if (S8 > (float )L_max) {
#line 577
      L_max = (int32_t )S8;
#line 577
      Nc = (int16_t )(lambda + 8);
    }
#line 510
    lambda += 9;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: 
#line 579
  *Nc_out = Nc;
#line 581
  L_max <<= 1;
#line 586
  L_max >>= 6 - (int )scal;
#line 593
  L_power = 0;
#line 594
  k = 0;
  {
#line 594
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 594
    if (! (k <= 39)) {
#line 594
      goto while_break___3;
    }
    {
#line 597
    __cil_tmp50 = SASR_W(*(dp + (k - (int )Nc)), (int16_t )3);
#line 597
    L_temp = (int32_t )__cil_tmp50;
#line 598
    L_power += L_temp * L_temp;
#line 594
    k ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___3: 
#line 600
  L_power <<= 1;
#line 605
  if (L_max <= 0) {
#line 606
    *bc_out = (int16_t )0;
#line 607
    return;
  }
#line 609
  if (L_max >= L_power) {
#line 610
    *bc_out = (int16_t )3;
#line 611
    return;
  }
  {
#line 614
  temp = gsm_norm(L_power);
#line 616
  __cil_tmp53 = SASR_L(L_max << (int )temp, (int16_t )16);
#line 616
  R = (int16_t )__cil_tmp53;
#line 617
  __cil_tmp54 = SASR_L(L_power << (int )temp, (int16_t )16);
#line 617
  S = (int16_t )__cil_tmp54;
#line 625
  bc = (int16_t )0;
  }
  {
#line 625
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 625
    if (! ((int )bc <= 2)) {
#line 625
      goto while_break___4;
    }
    {
#line 625
    __cil_tmp55 = gsm_mult(S, gsm_DLB[bc]);
    }
#line 625
    if ((int )R <= (int )__cil_tmp55) {
#line 625
      goto while_break___4;
    }
#line 625
    bc = (int16_t )((int )bc + 1);
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___4: 
#line 626
  *bc_out = bc;
#line 627
  return;
}
}
#line 704 "/root/patchweave_new/23/src/GSM610/long_term.c"
static void Fast_Calculation_of_the_LTP_parameters(int16_t *din , int16_t *dp , int16_t *bc_out ,
                                                   int16_t *Nc_out ) 
{ 
  register int k ;
  register int lambda ;
  int16_t Nc ;
  int16_t bc ;
  float wt_float[40] ;
  float dp_float_base[120] ;
  float *dp_float ;
  register float L_max ;
  register float L_power ;
  register float *lp ;
  register float W ;
  register float a ;
  register float b ;
  register float c ;
  register float d ;
  register float e ;
  register float f ;
  register float g ;
  register float h ;
  register float E ;
  register float S0 ;
  register float S1 ;
  register float S2 ;
  register float S3 ;
  register float S4 ;
  register float S5 ;
  register float S6 ;
  register float S7 ;
  register float S8 ;
  register float f___0 ;

  {
#line 714
  dp_float = dp_float_base + 120;
#line 718
  k = 0;
  {
#line 718
  while (1) {
    while_continue: /* CIL Label */ ;

#line 718
    if (! (k < 40)) {
#line 718
      goto while_break;
    }
#line 718
    wt_float[k] = (float )*(din + k);
#line 718
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 719
  k = -120;
  {
#line 719
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 719
    if (! (k < 0)) {
#line 719
      goto while_break___0;
    }
#line 719
    *(dp_float + k) = (float )*(dp + k);
#line 719
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
#line 722
  L_max = (float )0;
#line 723
  Nc = (int16_t )40;
#line 725
  lambda = 40;
  {
#line 725
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 725
    if (! (lambda <= 120)) {
#line 725
      goto while_break___1;
    }
#line 727
    lp = dp_float - lambda;
#line 730
    a = *(lp + -8);
#line 730
    b = *(lp + -7);
#line 730
    c = *(lp + -6);
#line 730
    d = *(lp + -5);
#line 730
    e = *(lp + -4);
#line 730
    f = *(lp + -3);
#line 730
    g = *(lp + -2);
#line 730
    h = *(lp + -1);
#line 734
    S0 = (float )0;
#line 734
    S1 = (float )0;
#line 734
    S2 = (float )0;
#line 734
    S3 = (float )0;
#line 734
    S4 = (float )0;
#line 734
    S5 = (float )0;
#line 734
    S6 = (float )0;
#line 734
    S7 = (float )0;
#line 734
    S8 = (float )0;
#line 760
    W = wt_float[0];
#line 760
    E = W * a;
#line 760
    S8 += E;
#line 760
    E = W * b;
#line 760
    S7 += E;
#line 760
    E = W * c;
#line 760
    S6 += E;
#line 760
    E = W * d;
#line 760
    S5 += E;
#line 760
    E = W * e;
#line 760
    S4 += E;
#line 760
    E = W * f;
#line 760
    S3 += E;
#line 760
    E = W * g;
#line 760
    S2 += E;
#line 760
    E = W * h;
#line 760
    S1 += E;
#line 760
    a = *(lp + 0);
#line 760
    E = W * a;
#line 760
    S0 += E;
#line 760
    W = wt_float[1];
#line 760
    E = W * b;
#line 760
    S8 += E;
#line 760
    E = W * c;
#line 760
    S7 += E;
#line 760
    E = W * d;
#line 760
    S6 += E;
#line 760
    E = W * e;
#line 760
    S5 += E;
#line 760
    E = W * f;
#line 760
    S4 += E;
#line 760
    E = W * g;
#line 760
    S3 += E;
#line 760
    E = W * h;
#line 760
    S2 += E;
#line 760
    E = W * a;
#line 760
    S1 += E;
#line 760
    b = *(lp + 1);
#line 760
    E = W * b;
#line 760
    S0 += E;
#line 760
    W = wt_float[2];
#line 760
    E = W * c;
#line 760
    S8 += E;
#line 760
    E = W * d;
#line 760
    S7 += E;
#line 760
    E = W * e;
#line 760
    S6 += E;
#line 760
    E = W * f;
#line 760
    S5 += E;
#line 760
    E = W * g;
#line 760
    S4 += E;
#line 760
    E = W * h;
#line 760
    S3 += E;
#line 760
    E = W * a;
#line 760
    S2 += E;
#line 760
    E = W * b;
#line 760
    S1 += E;
#line 760
    c = *(lp + 2);
#line 760
    E = W * c;
#line 760
    S0 += E;
#line 760
    W = wt_float[3];
#line 760
    E = W * d;
#line 760
    S8 += E;
#line 760
    E = W * e;
#line 760
    S7 += E;
#line 760
    E = W * f;
#line 760
    S6 += E;
#line 760
    E = W * g;
#line 760
    S5 += E;
#line 760
    E = W * h;
#line 760
    S4 += E;
#line 760
    E = W * a;
#line 760
    S3 += E;
#line 760
    E = W * b;
#line 760
    S2 += E;
#line 760
    E = W * c;
#line 760
    S1 += E;
#line 760
    d = *(lp + 3);
#line 760
    E = W * d;
#line 760
    S0 += E;
#line 761
    W = wt_float[4];
#line 761
    E = W * e;
#line 761
    S8 += E;
#line 761
    E = W * f;
#line 761
    S7 += E;
#line 761
    E = W * g;
#line 761
    S6 += E;
#line 761
    E = W * h;
#line 761
    S5 += E;
#line 761
    E = W * a;
#line 761
    S4 += E;
#line 761
    E = W * b;
#line 761
    S3 += E;
#line 761
    E = W * c;
#line 761
    S2 += E;
#line 761
    E = W * d;
#line 761
    S1 += E;
#line 761
    e = *(lp + 4);
#line 761
    E = W * e;
#line 761
    S0 += E;
#line 761
    W = wt_float[5];
#line 761
    E = W * f;
#line 761
    S8 += E;
#line 761
    E = W * g;
#line 761
    S7 += E;
#line 761
    E = W * h;
#line 761
    S6 += E;
#line 761
    E = W * a;
#line 761
    S5 += E;
#line 761
    E = W * b;
#line 761
    S4 += E;
#line 761
    E = W * c;
#line 761
    S3 += E;
#line 761
    E = W * d;
#line 761
    S2 += E;
#line 761
    E = W * e;
#line 761
    S1 += E;
#line 761
    f = *(lp + 5);
#line 761
    E = W * f;
#line 761
    S0 += E;
#line 761
    W = wt_float[6];
#line 761
    E = W * g;
#line 761
    S8 += E;
#line 761
    E = W * h;
#line 761
    S7 += E;
#line 761
    E = W * a;
#line 761
    S6 += E;
#line 761
    E = W * b;
#line 761
    S5 += E;
#line 761
    E = W * c;
#line 761
    S4 += E;
#line 761
    E = W * d;
#line 761
    S3 += E;
#line 761
    E = W * e;
#line 761
    S2 += E;
#line 761
    E = W * f;
#line 761
    S1 += E;
#line 761
    g = *(lp + 6);
#line 761
    E = W * g;
#line 761
    S0 += E;
#line 761
    W = wt_float[7];
#line 761
    E = W * h;
#line 761
    S8 += E;
#line 761
    E = W * a;
#line 761
    S7 += E;
#line 761
    E = W * b;
#line 761
    S6 += E;
#line 761
    E = W * c;
#line 761
    S5 += E;
#line 761
    E = W * d;
#line 761
    S4 += E;
#line 761
    E = W * e;
#line 761
    S3 += E;
#line 761
    E = W * f;
#line 761
    S2 += E;
#line 761
    E = W * g;
#line 761
    S1 += E;
#line 761
    h = *(lp + 7);
#line 761
    E = W * h;
#line 761
    S0 += E;
#line 763
    W = wt_float[8];
#line 763
    E = W * a;
#line 763
    S8 += E;
#line 763
    E = W * b;
#line 763
    S7 += E;
#line 763
    E = W * c;
#line 763
    S6 += E;
#line 763
    E = W * d;
#line 763
    S5 += E;
#line 763
    E = W * e;
#line 763
    S4 += E;
#line 763
    E = W * f;
#line 763
    S3 += E;
#line 763
    E = W * g;
#line 763
    S2 += E;
#line 763
    E = W * h;
#line 763
    S1 += E;
#line 763
    a = *(lp + 8);
#line 763
    E = W * a;
#line 763
    S0 += E;
#line 763
    W = wt_float[9];
#line 763
    E = W * b;
#line 763
    S8 += E;
#line 763
    E = W * c;
#line 763
    S7 += E;
#line 763
    E = W * d;
#line 763
    S6 += E;
#line 763
    E = W * e;
#line 763
    S5 += E;
#line 763
    E = W * f;
#line 763
    S4 += E;
#line 763
    E = W * g;
#line 763
    S3 += E;
#line 763
    E = W * h;
#line 763
    S2 += E;
#line 763
    E = W * a;
#line 763
    S1 += E;
#line 763
    b = *(lp + 9);
#line 763
    E = W * b;
#line 763
    S0 += E;
#line 763
    W = wt_float[10];
#line 763
    E = W * c;
#line 763
    S8 += E;
#line 763
    E = W * d;
#line 763
    S7 += E;
#line 763
    E = W * e;
#line 763
    S6 += E;
#line 763
    E = W * f;
#line 763
    S5 += E;
#line 763
    E = W * g;
#line 763
    S4 += E;
#line 763
    E = W * h;
#line 763
    S3 += E;
#line 763
    E = W * a;
#line 763
    S2 += E;
#line 763
    E = W * b;
#line 763
    S1 += E;
#line 763
    c = *(lp + 10);
#line 763
    E = W * c;
#line 763
    S0 += E;
#line 763
    W = wt_float[11];
#line 763
    E = W * d;
#line 763
    S8 += E;
#line 763
    E = W * e;
#line 763
    S7 += E;
#line 763
    E = W * f;
#line 763
    S6 += E;
#line 763
    E = W * g;
#line 763
    S5 += E;
#line 763
    E = W * h;
#line 763
    S4 += E;
#line 763
    E = W * a;
#line 763
    S3 += E;
#line 763
    E = W * b;
#line 763
    S2 += E;
#line 763
    E = W * c;
#line 763
    S1 += E;
#line 763
    d = *(lp + 11);
#line 763
    E = W * d;
#line 763
    S0 += E;
#line 764
    W = wt_float[12];
#line 764
    E = W * e;
#line 764
    S8 += E;
#line 764
    E = W * f;
#line 764
    S7 += E;
#line 764
    E = W * g;
#line 764
    S6 += E;
#line 764
    E = W * h;
#line 764
    S5 += E;
#line 764
    E = W * a;
#line 764
    S4 += E;
#line 764
    E = W * b;
#line 764
    S3 += E;
#line 764
    E = W * c;
#line 764
    S2 += E;
#line 764
    E = W * d;
#line 764
    S1 += E;
#line 764
    e = *(lp + 12);
#line 764
    E = W * e;
#line 764
    S0 += E;
#line 764
    W = wt_float[13];
#line 764
    E = W * f;
#line 764
    S8 += E;
#line 764
    E = W * g;
#line 764
    S7 += E;
#line 764
    E = W * h;
#line 764
    S6 += E;
#line 764
    E = W * a;
#line 764
    S5 += E;
#line 764
    E = W * b;
#line 764
    S4 += E;
#line 764
    E = W * c;
#line 764
    S3 += E;
#line 764
    E = W * d;
#line 764
    S2 += E;
#line 764
    E = W * e;
#line 764
    S1 += E;
#line 764
    f = *(lp + 13);
#line 764
    E = W * f;
#line 764
    S0 += E;
#line 764
    W = wt_float[14];
#line 764
    E = W * g;
#line 764
    S8 += E;
#line 764
    E = W * h;
#line 764
    S7 += E;
#line 764
    E = W * a;
#line 764
    S6 += E;
#line 764
    E = W * b;
#line 764
    S5 += E;
#line 764
    E = W * c;
#line 764
    S4 += E;
#line 764
    E = W * d;
#line 764
    S3 += E;
#line 764
    E = W * e;
#line 764
    S2 += E;
#line 764
    E = W * f;
#line 764
    S1 += E;
#line 764
    g = *(lp + 14);
#line 764
    E = W * g;
#line 764
    S0 += E;
#line 764
    W = wt_float[15];
#line 764
    E = W * h;
#line 764
    S8 += E;
#line 764
    E = W * a;
#line 764
    S7 += E;
#line 764
    E = W * b;
#line 764
    S6 += E;
#line 764
    E = W * c;
#line 764
    S5 += E;
#line 764
    E = W * d;
#line 764
    S4 += E;
#line 764
    E = W * e;
#line 764
    S3 += E;
#line 764
    E = W * f;
#line 764
    S2 += E;
#line 764
    E = W * g;
#line 764
    S1 += E;
#line 764
    h = *(lp + 15);
#line 764
    E = W * h;
#line 764
    S0 += E;
#line 766
    W = wt_float[16];
#line 766
    E = W * a;
#line 766
    S8 += E;
#line 766
    E = W * b;
#line 766
    S7 += E;
#line 766
    E = W * c;
#line 766
    S6 += E;
#line 766
    E = W * d;
#line 766
    S5 += E;
#line 766
    E = W * e;
#line 766
    S4 += E;
#line 766
    E = W * f;
#line 766
    S3 += E;
#line 766
    E = W * g;
#line 766
    S2 += E;
#line 766
    E = W * h;
#line 766
    S1 += E;
#line 766
    a = *(lp + 16);
#line 766
    E = W * a;
#line 766
    S0 += E;
#line 766
    W = wt_float[17];
#line 766
    E = W * b;
#line 766
    S8 += E;
#line 766
    E = W * c;
#line 766
    S7 += E;
#line 766
    E = W * d;
#line 766
    S6 += E;
#line 766
    E = W * e;
#line 766
    S5 += E;
#line 766
    E = W * f;
#line 766
    S4 += E;
#line 766
    E = W * g;
#line 766
    S3 += E;
#line 766
    E = W * h;
#line 766
    S2 += E;
#line 766
    E = W * a;
#line 766
    S1 += E;
#line 766
    b = *(lp + 17);
#line 766
    E = W * b;
#line 766
    S0 += E;
#line 766
    W = wt_float[18];
#line 766
    E = W * c;
#line 766
    S8 += E;
#line 766
    E = W * d;
#line 766
    S7 += E;
#line 766
    E = W * e;
#line 766
    S6 += E;
#line 766
    E = W * f;
#line 766
    S5 += E;
#line 766
    E = W * g;
#line 766
    S4 += E;
#line 766
    E = W * h;
#line 766
    S3 += E;
#line 766
    E = W * a;
#line 766
    S2 += E;
#line 766
    E = W * b;
#line 766
    S1 += E;
#line 766
    c = *(lp + 18);
#line 766
    E = W * c;
#line 766
    S0 += E;
#line 766
    W = wt_float[19];
#line 766
    E = W * d;
#line 766
    S8 += E;
#line 766
    E = W * e;
#line 766
    S7 += E;
#line 766
    E = W * f;
#line 766
    S6 += E;
#line 766
    E = W * g;
#line 766
    S5 += E;
#line 766
    E = W * h;
#line 766
    S4 += E;
#line 766
    E = W * a;
#line 766
    S3 += E;
#line 766
    E = W * b;
#line 766
    S2 += E;
#line 766
    E = W * c;
#line 766
    S1 += E;
#line 766
    d = *(lp + 19);
#line 766
    E = W * d;
#line 766
    S0 += E;
#line 767
    W = wt_float[20];
#line 767
    E = W * e;
#line 767
    S8 += E;
#line 767
    E = W * f;
#line 767
    S7 += E;
#line 767
    E = W * g;
#line 767
    S6 += E;
#line 767
    E = W * h;
#line 767
    S5 += E;
#line 767
    E = W * a;
#line 767
    S4 += E;
#line 767
    E = W * b;
#line 767
    S3 += E;
#line 767
    E = W * c;
#line 767
    S2 += E;
#line 767
    E = W * d;
#line 767
    S1 += E;
#line 767
    e = *(lp + 20);
#line 767
    E = W * e;
#line 767
    S0 += E;
#line 767
    W = wt_float[21];
#line 767
    E = W * f;
#line 767
    S8 += E;
#line 767
    E = W * g;
#line 767
    S7 += E;
#line 767
    E = W * h;
#line 767
    S6 += E;
#line 767
    E = W * a;
#line 767
    S5 += E;
#line 767
    E = W * b;
#line 767
    S4 += E;
#line 767
    E = W * c;
#line 767
    S3 += E;
#line 767
    E = W * d;
#line 767
    S2 += E;
#line 767
    E = W * e;
#line 767
    S1 += E;
#line 767
    f = *(lp + 21);
#line 767
    E = W * f;
#line 767
    S0 += E;
#line 767
    W = wt_float[22];
#line 767
    E = W * g;
#line 767
    S8 += E;
#line 767
    E = W * h;
#line 767
    S7 += E;
#line 767
    E = W * a;
#line 767
    S6 += E;
#line 767
    E = W * b;
#line 767
    S5 += E;
#line 767
    E = W * c;
#line 767
    S4 += E;
#line 767
    E = W * d;
#line 767
    S3 += E;
#line 767
    E = W * e;
#line 767
    S2 += E;
#line 767
    E = W * f;
#line 767
    S1 += E;
#line 767
    g = *(lp + 22);
#line 767
    E = W * g;
#line 767
    S0 += E;
#line 767
    W = wt_float[23];
#line 767
    E = W * h;
#line 767
    S8 += E;
#line 767
    E = W * a;
#line 767
    S7 += E;
#line 767
    E = W * b;
#line 767
    S6 += E;
#line 767
    E = W * c;
#line 767
    S5 += E;
#line 767
    E = W * d;
#line 767
    S4 += E;
#line 767
    E = W * e;
#line 767
    S3 += E;
#line 767
    E = W * f;
#line 767
    S2 += E;
#line 767
    E = W * g;
#line 767
    S1 += E;
#line 767
    h = *(lp + 23);
#line 767
    E = W * h;
#line 767
    S0 += E;
#line 769
    W = wt_float[24];
#line 769
    E = W * a;
#line 769
    S8 += E;
#line 769
    E = W * b;
#line 769
    S7 += E;
#line 769
    E = W * c;
#line 769
    S6 += E;
#line 769
    E = W * d;
#line 769
    S5 += E;
#line 769
    E = W * e;
#line 769
    S4 += E;
#line 769
    E = W * f;
#line 769
    S3 += E;
#line 769
    E = W * g;
#line 769
    S2 += E;
#line 769
    E = W * h;
#line 769
    S1 += E;
#line 769
    a = *(lp + 24);
#line 769
    E = W * a;
#line 769
    S0 += E;
#line 769
    W = wt_float[25];
#line 769
    E = W * b;
#line 769
    S8 += E;
#line 769
    E = W * c;
#line 769
    S7 += E;
#line 769
    E = W * d;
#line 769
    S6 += E;
#line 769
    E = W * e;
#line 769
    S5 += E;
#line 769
    E = W * f;
#line 769
    S4 += E;
#line 769
    E = W * g;
#line 769
    S3 += E;
#line 769
    E = W * h;
#line 769
    S2 += E;
#line 769
    E = W * a;
#line 769
    S1 += E;
#line 769
    b = *(lp + 25);
#line 769
    E = W * b;
#line 769
    S0 += E;
#line 769
    W = wt_float[26];
#line 769
    E = W * c;
#line 769
    S8 += E;
#line 769
    E = W * d;
#line 769
    S7 += E;
#line 769
    E = W * e;
#line 769
    S6 += E;
#line 769
    E = W * f;
#line 769
    S5 += E;
#line 769
    E = W * g;
#line 769
    S4 += E;
#line 769
    E = W * h;
#line 769
    S3 += E;
#line 769
    E = W * a;
#line 769
    S2 += E;
#line 769
    E = W * b;
#line 769
    S1 += E;
#line 769
    c = *(lp + 26);
#line 769
    E = W * c;
#line 769
    S0 += E;
#line 769
    W = wt_float[27];
#line 769
    E = W * d;
#line 769
    S8 += E;
#line 769
    E = W * e;
#line 769
    S7 += E;
#line 769
    E = W * f;
#line 769
    S6 += E;
#line 769
    E = W * g;
#line 769
    S5 += E;
#line 769
    E = W * h;
#line 769
    S4 += E;
#line 769
    E = W * a;
#line 769
    S3 += E;
#line 769
    E = W * b;
#line 769
    S2 += E;
#line 769
    E = W * c;
#line 769
    S1 += E;
#line 769
    d = *(lp + 27);
#line 769
    E = W * d;
#line 769
    S0 += E;
#line 770
    W = wt_float[28];
#line 770
    E = W * e;
#line 770
    S8 += E;
#line 770
    E = W * f;
#line 770
    S7 += E;
#line 770
    E = W * g;
#line 770
    S6 += E;
#line 770
    E = W * h;
#line 770
    S5 += E;
#line 770
    E = W * a;
#line 770
    S4 += E;
#line 770
    E = W * b;
#line 770
    S3 += E;
#line 770
    E = W * c;
#line 770
    S2 += E;
#line 770
    E = W * d;
#line 770
    S1 += E;
#line 770
    e = *(lp + 28);
#line 770
    E = W * e;
#line 770
    S0 += E;
#line 770
    W = wt_float[29];
#line 770
    E = W * f;
#line 770
    S8 += E;
#line 770
    E = W * g;
#line 770
    S7 += E;
#line 770
    E = W * h;
#line 770
    S6 += E;
#line 770
    E = W * a;
#line 770
    S5 += E;
#line 770
    E = W * b;
#line 770
    S4 += E;
#line 770
    E = W * c;
#line 770
    S3 += E;
#line 770
    E = W * d;
#line 770
    S2 += E;
#line 770
    E = W * e;
#line 770
    S1 += E;
#line 770
    f = *(lp + 29);
#line 770
    E = W * f;
#line 770
    S0 += E;
#line 770
    W = wt_float[30];
#line 770
    E = W * g;
#line 770
    S8 += E;
#line 770
    E = W * h;
#line 770
    S7 += E;
#line 770
    E = W * a;
#line 770
    S6 += E;
#line 770
    E = W * b;
#line 770
    S5 += E;
#line 770
    E = W * c;
#line 770
    S4 += E;
#line 770
    E = W * d;
#line 770
    S3 += E;
#line 770
    E = W * e;
#line 770
    S2 += E;
#line 770
    E = W * f;
#line 770
    S1 += E;
#line 770
    g = *(lp + 30);
#line 770
    E = W * g;
#line 770
    S0 += E;
#line 770
    W = wt_float[31];
#line 770
    E = W * h;
#line 770
    S8 += E;
#line 770
    E = W * a;
#line 770
    S7 += E;
#line 770
    E = W * b;
#line 770
    S6 += E;
#line 770
    E = W * c;
#line 770
    S5 += E;
#line 770
    E = W * d;
#line 770
    S4 += E;
#line 770
    E = W * e;
#line 770
    S3 += E;
#line 770
    E = W * f;
#line 770
    S2 += E;
#line 770
    E = W * g;
#line 770
    S1 += E;
#line 770
    h = *(lp + 31);
#line 770
    E = W * h;
#line 770
    S0 += E;
#line 772
    W = wt_float[32];
#line 772
    E = W * a;
#line 772
    S8 += E;
#line 772
    E = W * b;
#line 772
    S7 += E;
#line 772
    E = W * c;
#line 772
    S6 += E;
#line 772
    E = W * d;
#line 772
    S5 += E;
#line 772
    E = W * e;
#line 772
    S4 += E;
#line 772
    E = W * f;
#line 772
    S3 += E;
#line 772
    E = W * g;
#line 772
    S2 += E;
#line 772
    E = W * h;
#line 772
    S1 += E;
#line 772
    a = *(lp + 32);
#line 772
    E = W * a;
#line 772
    S0 += E;
#line 772
    W = wt_float[33];
#line 772
    E = W * b;
#line 772
    S8 += E;
#line 772
    E = W * c;
#line 772
    S7 += E;
#line 772
    E = W * d;
#line 772
    S6 += E;
#line 772
    E = W * e;
#line 772
    S5 += E;
#line 772
    E = W * f;
#line 772
    S4 += E;
#line 772
    E = W * g;
#line 772
    S3 += E;
#line 772
    E = W * h;
#line 772
    S2 += E;
#line 772
    E = W * a;
#line 772
    S1 += E;
#line 772
    b = *(lp + 33);
#line 772
    E = W * b;
#line 772
    S0 += E;
#line 772
    W = wt_float[34];
#line 772
    E = W * c;
#line 772
    S8 += E;
#line 772
    E = W * d;
#line 772
    S7 += E;
#line 772
    E = W * e;
#line 772
    S6 += E;
#line 772
    E = W * f;
#line 772
    S5 += E;
#line 772
    E = W * g;
#line 772
    S4 += E;
#line 772
    E = W * h;
#line 772
    S3 += E;
#line 772
    E = W * a;
#line 772
    S2 += E;
#line 772
    E = W * b;
#line 772
    S1 += E;
#line 772
    c = *(lp + 34);
#line 772
    E = W * c;
#line 772
    S0 += E;
#line 772
    W = wt_float[35];
#line 772
    E = W * d;
#line 772
    S8 += E;
#line 772
    E = W * e;
#line 772
    S7 += E;
#line 772
    E = W * f;
#line 772
    S6 += E;
#line 772
    E = W * g;
#line 772
    S5 += E;
#line 772
    E = W * h;
#line 772
    S4 += E;
#line 772
    E = W * a;
#line 772
    S3 += E;
#line 772
    E = W * b;
#line 772
    S2 += E;
#line 772
    E = W * c;
#line 772
    S1 += E;
#line 772
    d = *(lp + 35);
#line 772
    E = W * d;
#line 772
    S0 += E;
#line 773
    W = wt_float[36];
#line 773
    E = W * e;
#line 773
    S8 += E;
#line 773
    E = W * f;
#line 773
    S7 += E;
#line 773
    E = W * g;
#line 773
    S6 += E;
#line 773
    E = W * h;
#line 773
    S5 += E;
#line 773
    E = W * a;
#line 773
    S4 += E;
#line 773
    E = W * b;
#line 773
    S3 += E;
#line 773
    E = W * c;
#line 773
    S2 += E;
#line 773
    E = W * d;
#line 773
    S1 += E;
#line 773
    e = *(lp + 36);
#line 773
    E = W * e;
#line 773
    S0 += E;
#line 773
    W = wt_float[37];
#line 773
    E = W * f;
#line 773
    S8 += E;
#line 773
    E = W * g;
#line 773
    S7 += E;
#line 773
    E = W * h;
#line 773
    S6 += E;
#line 773
    E = W * a;
#line 773
    S5 += E;
#line 773
    E = W * b;
#line 773
    S4 += E;
#line 773
    E = W * c;
#line 773
    S3 += E;
#line 773
    E = W * d;
#line 773
    S2 += E;
#line 773
    E = W * e;
#line 773
    S1 += E;
#line 773
    f = *(lp + 37);
#line 773
    E = W * f;
#line 773
    S0 += E;
#line 773
    W = wt_float[38];
#line 773
    E = W * g;
#line 773
    S8 += E;
#line 773
    E = W * h;
#line 773
    S7 += E;
#line 773
    E = W * a;
#line 773
    S6 += E;
#line 773
    E = W * b;
#line 773
    S5 += E;
#line 773
    E = W * c;
#line 773
    S4 += E;
#line 773
    E = W * d;
#line 773
    S3 += E;
#line 773
    E = W * e;
#line 773
    S2 += E;
#line 773
    E = W * f;
#line 773
    S1 += E;
#line 773
    g = *(lp + 38);
#line 773
    E = W * g;
#line 773
    S0 += E;
#line 773
    W = wt_float[39];
#line 773
    E = W * h;
#line 773
    S8 += E;
#line 773
    E = W * a;
#line 773
    S7 += E;
#line 773
    E = W * b;
#line 773
    S6 += E;
#line 773
    E = W * c;
#line 773
    S5 += E;
#line 773
    E = W * d;
#line 773
    S4 += E;
#line 773
    E = W * e;
#line 773
    S3 += E;
#line 773
    E = W * f;
#line 773
    S2 += E;
#line 773
    E = W * g;
#line 773
    S1 += E;
#line 773
    h = *(lp + 39);
#line 773
    E = W * h;
#line 773
    S0 += E;
#line 775
    if (S0 > L_max) {
#line 775
      L_max = S0;
#line 775
      Nc = (int16_t )lambda;
    }
#line 776
    if (S1 > L_max) {
#line 776
      L_max = S1;
#line 776
      Nc = (int16_t )(lambda + 1);
    }
#line 777
    if (S2 > L_max) {
#line 777
      L_max = S2;
#line 777
      Nc = (int16_t )(lambda + 2);
    }
#line 778
    if (S3 > L_max) {
#line 778
      L_max = S3;
#line 778
      Nc = (int16_t )(lambda + 3);
    }
#line 779
    if (S4 > L_max) {
#line 779
      L_max = S4;
#line 779
      Nc = (int16_t )(lambda + 4);
    }
#line 780
    if (S5 > L_max) {
#line 780
      L_max = S5;
#line 780
      Nc = (int16_t )(lambda + 5);
    }
#line 781
    if (S6 > L_max) {
#line 781
      L_max = S6;
#line 781
      Nc = (int16_t )(lambda + 6);
    }
#line 782
    if (S7 > L_max) {
#line 782
      L_max = S7;
#line 782
      Nc = (int16_t )(lambda + 7);
    }
#line 783
    if (S8 > L_max) {
#line 783
      L_max = S8;
#line 783
      Nc = (int16_t )(lambda + 8);
    }
#line 725
    lambda += 9;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
#line 785
  *Nc_out = Nc;
#line 787
  if ((double )L_max <= 0.) {
#line 788
    *bc_out = (int16_t )0;
#line 789
    return;
  }
#line 795
  dp_float -= (int )Nc;
#line 796
  L_power = (float )0;
#line 797
  k = 0;
  {
#line 797
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 797
    if (! (k < 40)) {
#line 797
      goto while_break___2;
    }
#line 798
    f___0 = *(dp_float + k);
#line 799
    L_power += f___0 * f___0;
#line 797
    k ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: ;
#line 802
  if (L_max >= L_power) {
#line 803
    *bc_out = (int16_t )3;
#line 804
    return;
  }
#line 811
  lambda = (int )((double )(L_max / L_power) * 32768.);
#line 812
  bc = (int16_t )0;
  {
#line 812
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 812
    if (! ((int )bc <= 2)) {
#line 812
      goto while_break___3;
    }
#line 812
    if (lambda <= (int )gsm_DLB[bc]) {
#line 812
      goto while_break___3;
    }
#line 812
    bc = (int16_t )((int )bc + 1);
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: 
#line 813
  *bc_out = bc;
#line 814
  return;
}
}
#line 822 "/root/patchweave_new/23/src/GSM610/long_term.c"
static void Long_term_analysis_filtering(int16_t bc , int16_t Nc , int16_t *dp , int16_t *d ,
                                         int16_t *dpp , int16_t *e ) 
{ 
  register int k ;
  int32_t __cil_tmp8 ;
  int32_t __cil_tmp9 ;
  int32_t __cil_tmp11 ;
  int32_t __cil_tmp12 ;
  int32_t __cil_tmp14 ;
  int32_t __cil_tmp15 ;
  int32_t __cil_tmp17 ;
  int32_t __cil_tmp18 ;

  {
#line 846
  if ((int )bc == 0) {
#line 846
    goto case_0;
  }
#line 847
  if ((int )bc == 1) {
#line 847
    goto case_1;
  }
#line 848
  if ((int )bc == 2) {
#line 848
    goto case_2;
  }
#line 849
  if ((int )bc == 3) {
#line 849
    goto case_3;
  }
#line 845
  goto switch_break;
  case_0: 
#line 846
  k = 0;
  {
#line 846
  while (1) {
    while_continue: /* CIL Label */ ;

#line 846
    if (! (k <= 39)) {
#line 846
      goto while_break;
    }
    {
#line 846
    __cil_tmp8 = GSM_MULT_R((int16_t )3277, *(dp + (k - (int )Nc)));
#line 846
    *(dpp + k) = (int16_t )__cil_tmp8;
#line 846
    __cil_tmp9 = GSM_SUB(*(d + k), *(dpp + k));
#line 846
    *(e + k) = (int16_t )__cil_tmp9;
#line 846
    k ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 846
  goto switch_break;
  case_1: 
#line 847
  k = 0;
  {
#line 847
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 847
    if (! (k <= 39)) {
#line 847
      goto while_break___0;
    }
    {
#line 847
    __cil_tmp11 = GSM_MULT_R((int16_t )11469, *(dp + (k - (int )Nc)));
#line 847
    *(dpp + k) = (int16_t )__cil_tmp11;
#line 847
    __cil_tmp12 = GSM_SUB(*(d + k), *(dpp + k));
#line 847
    *(e + k) = (int16_t )__cil_tmp12;
#line 847
    k ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: ;
#line 847
  goto switch_break;
  case_2: 
#line 848
  k = 0;
  {
#line 848
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 848
    if (! (k <= 39)) {
#line 848
      goto while_break___1;
    }
    {
#line 848
    __cil_tmp14 = GSM_MULT_R((int16_t )21299, *(dp + (k - (int )Nc)));
#line 848
    *(dpp + k) = (int16_t )__cil_tmp14;
#line 848
    __cil_tmp15 = GSM_SUB(*(d + k), *(dpp + k));
#line 848
    *(e + k) = (int16_t )__cil_tmp15;
#line 848
    k ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 848
  goto switch_break;
  case_3: 
#line 849
  k = 0;
  {
#line 849
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 849
    if (! (k <= 39)) {
#line 849
      goto while_break___2;
    }
    {
#line 849
    __cil_tmp17 = GSM_MULT_R((int16_t )32767, *(dp + (k - (int )Nc)));
#line 849
    *(dpp + k) = (int16_t )__cil_tmp17;
#line 849
    __cil_tmp18 = GSM_SUB(*(d + k), *(dpp + k));
#line 849
    *(e + k) = (int16_t )__cil_tmp18;
#line 849
    k ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 849
  goto switch_break;
  switch_break: ;
#line 852
  return;
}
}
#line 853 "/root/patchweave_new/23/src/GSM610/long_term.c"
void Gsm_Long_Term_Predictor(struct gsm_state *S , int16_t *d , int16_t *dp , int16_t *e ,
                             int16_t *dpp , int16_t *Nc , int16_t *bc ) 
{ 


  {
#line 869
  if (S->fast) {
    {
#line 876
    Fast_Calculation_of_the_LTP_parameters(d, dp, bc, Nc);
    }
  } else {
    {
#line 884
    Calculation_of_the_LTP_parameters(d, dp, bc, Nc);
    }
  }
  {
#line 886
  Long_term_analysis_filtering(*bc, *Nc, dp, d, dpp, e);
  }
#line 888
  return;
}
}
#line 890 "/root/patchweave_new/23/src/GSM610/long_term.c"
void Gsm_Long_Term_Synthesis_Filtering(struct gsm_state *S , int16_t Ncr , int16_t bcr ,
                                       int16_t *erp , int16_t *drp ) 
{ 
  register int k ;
  int16_t brp ;
  int16_t drpp ;
  int16_t Nr ;
  int tmp ;
  int32_t __cil_tmp13 ;
  int32_t __cil_tmp14 ;

  {
#line 908
  if ((int )Ncr < 40) {
#line 908
    tmp = (int )S->nrp;
  } else
#line 908
  if ((int )Ncr > 120) {
#line 908
    tmp = (int )S->nrp;
  } else {
#line 908
    tmp = (int )Ncr;
  }
#line 908
  Nr = (int16_t )tmp;
#line 909
  S->nrp = Nr;
#line 914
  brp = gsm_QLB[bcr];
#line 921
  k = 0;
  {
#line 921
  while (1) {
    while_continue: /* CIL Label */ ;

#line 921
    if (! (k <= 39)) {
#line 921
      goto while_break;
    }
    {
#line 922
    __cil_tmp13 = GSM_MULT_R(brp, *(drp + (k - (int )Nr)));
#line 922
    drpp = (int16_t )__cil_tmp13;
#line 923
    __cil_tmp14 = GSM_ADD(*(erp + k), drpp);
#line 923
    *(drp + k) = (int16_t )__cil_tmp14;
#line 921
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 931
  k = 0;
  {
#line 931
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 931
    if (! (k <= 119)) {
#line 931
      goto while_break___0;
    }
#line 931
    *(drp + (-120 + k)) = *(drp + (-80 + k));
#line 931
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 935
  return;
}
}
#line 11 "/root/patchweave_new/23/src/GSM610/gsm_option.c"
int gsm_option(gsm r , int opt , int *val ) 
{ 
  int result ;

  {
#line 13
  result = -1;
#line 16
  if (opt == 3) {
#line 16
    goto case_3;
  }
#line 23
  if (opt == 1) {
#line 23
    goto case_1;
  }
#line 30
  if (opt == 2) {
#line 30
    goto case_2;
  }
#line 38
  if (opt == 6) {
#line 38
    goto case_6;
  }
#line 46
  if (opt == 5) {
#line 46
    goto case_5;
  }
#line 54
  if (opt == 4) {
#line 54
    goto case_4;
  }
#line 62
  goto switch_default;
  case_3: 
#line 21
  goto switch_break;
  case_1: 
#line 25
  result = (int )r->verbose;
#line 26
  if (val) {
#line 26
    r->verbose = (char )*val;
  }
#line 28
  goto switch_break;
  case_2: 
#line 33
  result = (int )r->fast;
#line 34
  if (val) {
#line 34
    r->fast = (char )(! (! *val));
  }
#line 36
  goto switch_break;
  case_6: 
#line 41
  result = (int )r->frame_chain;
#line 42
  if (val) {
#line 42
    r->frame_chain = (unsigned char )*val;
  }
#line 44
  goto switch_break;
  case_5: 
#line 49
  result = (int )r->frame_index;
#line 50
  if (val) {
#line 50
    r->frame_index = (unsigned char )*val;
  }
#line 52
  goto switch_break;
  case_4: 
#line 57
  result = (int )r->wav_fmt;
#line 58
  if (val) {
#line 58
    r->wav_fmt = (char )(! (! *val));
  }
#line 60
  goto switch_break;
  switch_default: 
#line 63
  goto switch_break;
  switch_break: ;
#line 65
  return (result);
}
}
#line 10 "/root/patchweave_new/23/src/GSM610/gsm_encode.c"
void gsm_encode(gsm s , gsm_signal *source , gsm_byte *c ) 
{ 
  int16_t LARc[8] ;
  int16_t Nc[4] ;
  int16_t Mc[4] ;
  int16_t bc[4] ;
  int16_t xmaxc[4] ;
  int16_t xmc[52] ;
  uint16_t sr ;
  gsm_byte *__cil_tmp11 ;
  gsm_byte *__cil_tmp12 ;
  gsm_byte *__cil_tmp13 ;
  gsm_byte *__cil_tmp14 ;
  gsm_byte *__cil_tmp15 ;
  gsm_byte *__cil_tmp16 ;
  gsm_byte *__cil_tmp17 ;
  gsm_byte *__cil_tmp18 ;
  gsm_byte *__cil_tmp19 ;
  gsm_byte *__cil_tmp20 ;
  gsm_byte *__cil_tmp21 ;
  gsm_byte *__cil_tmp22 ;
  gsm_byte *__cil_tmp23 ;
  gsm_byte *__cil_tmp24 ;
  gsm_byte *__cil_tmp25 ;
  gsm_byte *__cil_tmp26 ;
  gsm_byte *__cil_tmp27 ;
  gsm_byte *__cil_tmp28 ;
  gsm_byte *__cil_tmp29 ;
  gsm_byte *__cil_tmp30 ;
  gsm_byte *__cil_tmp31 ;
  gsm_byte *__cil_tmp32 ;
  gsm_byte *__cil_tmp33 ;
  gsm_byte *__cil_tmp34 ;
  gsm_byte *__cil_tmp35 ;
  gsm_byte *__cil_tmp36 ;
  gsm_byte *__cil_tmp37 ;
  gsm_byte *__cil_tmp38 ;
  gsm_byte *__cil_tmp39 ;
  gsm_byte *__cil_tmp40 ;
  gsm_byte *__cil_tmp41 ;
  gsm_byte *__cil_tmp42 ;
  uint16_t sr___0 ;
  gsm_byte *__cil_tmp44 ;
  gsm_byte *__cil_tmp45 ;
  gsm_byte *__cil_tmp46 ;
  gsm_byte *__cil_tmp47 ;
  gsm_byte *__cil_tmp48 ;
  gsm_byte *__cil_tmp49 ;
  gsm_byte *__cil_tmp50 ;
  gsm_byte *__cil_tmp51 ;
  gsm_byte *__cil_tmp52 ;
  gsm_byte *__cil_tmp53 ;
  gsm_byte *__cil_tmp54 ;
  gsm_byte *__cil_tmp55 ;
  gsm_byte *__cil_tmp56 ;
  gsm_byte *__cil_tmp57 ;
  gsm_byte *__cil_tmp58 ;
  gsm_byte *__cil_tmp59 ;
  gsm_byte *__cil_tmp60 ;
  gsm_byte *__cil_tmp61 ;
  gsm_byte *__cil_tmp62 ;
  gsm_byte *__cil_tmp63 ;
  gsm_byte *__cil_tmp64 ;
  gsm_byte *__cil_tmp65 ;
  gsm_byte *__cil_tmp66 ;
  gsm_byte *__cil_tmp67 ;
  gsm_byte *__cil_tmp68 ;
  gsm_byte *__cil_tmp69 ;
  gsm_byte *__cil_tmp70 ;
  gsm_byte *__cil_tmp71 ;
  gsm_byte *__cil_tmp72 ;
  gsm_byte *__cil_tmp73 ;
  gsm_byte *__cil_tmp74 ;
  gsm_byte *__cil_tmp75 ;
  gsm_byte *__cil_tmp76 ;
  gsm_byte *__cil_tmp77 ;
  gsm_byte *__cil_tmp78 ;
  gsm_byte *__cil_tmp79 ;
  gsm_byte *__cil_tmp80 ;
  gsm_byte *__cil_tmp81 ;
  gsm_byte *__cil_tmp82 ;
  gsm_byte *__cil_tmp83 ;
  gsm_byte *__cil_tmp84 ;
  gsm_byte *__cil_tmp85 ;
  gsm_byte *__cil_tmp86 ;
  gsm_byte *__cil_tmp87 ;
  gsm_byte *__cil_tmp88 ;
  gsm_byte *__cil_tmp89 ;
  gsm_byte *__cil_tmp90 ;
  gsm_byte *__cil_tmp91 ;
  gsm_byte *__cil_tmp92 ;
  gsm_byte *__cil_tmp93 ;
  gsm_byte *__cil_tmp94 ;
  gsm_byte *__cil_tmp95 ;
  gsm_byte *__cil_tmp96 ;
  gsm_byte *__cil_tmp97 ;
  gsm_byte *__cil_tmp98 ;
  gsm_byte *__cil_tmp99 ;
  gsm_byte *__cil_tmp100 ;
  gsm_byte *__cil_tmp101 ;
  gsm_byte *__cil_tmp102 ;
  gsm_byte *__cil_tmp103 ;
  gsm_byte *__cil_tmp104 ;
  gsm_byte *__cil_tmp105 ;
  gsm_byte *__cil_tmp106 ;
  gsm_byte *__cil_tmp107 ;
  gsm_byte *__cil_tmp108 ;
  gsm_byte *__cil_tmp109 ;

  {
  {
#line 14
  Gsm_Coder(s, source, LARc, Nc, bc, Mc, xmaxc, xmc);
  }
#line 105
  if (s->wav_fmt) {
#line 106
    s->frame_index = (unsigned char )(! s->frame_index);
#line 107
    if (s->frame_index) {
#line 110
      sr = (uint16_t )0;
#line 111
      sr = (uint16_t )(((int )sr >> 6) | ((int )LARc[0] << 10));
#line 112
      sr = (uint16_t )(((int )sr >> 6) | ((int )LARc[1] << 10));
#line 113
      __cil_tmp11 = c;
#line 113
      c ++;
#line 113
      *__cil_tmp11 = (gsm_byte )((int )sr >> 4);
#line 114
      sr = (uint16_t )(((int )sr >> 5) | ((int )LARc[2] << 11));
#line 115
      __cil_tmp12 = c;
#line 115
      c ++;
#line 115
      *__cil_tmp12 = (gsm_byte )((int )sr >> 7);
#line 116
      sr = (uint16_t )(((int )sr >> 5) | ((int )LARc[3] << 11));
#line 117
      sr = (uint16_t )(((int )sr >> 4) | ((int )LARc[4] << 12));
#line 118
      __cil_tmp13 = c;
#line 118
      c ++;
#line 118
      *__cil_tmp13 = (gsm_byte )((int )sr >> 6);
#line 119
      sr = (uint16_t )(((int )sr >> 4) | ((int )LARc[5] << 12));
#line 120
      sr = (uint16_t )(((int )sr >> 3) | ((int )LARc[6] << 13));
#line 121
      __cil_tmp14 = c;
#line 121
      c ++;
#line 121
      *__cil_tmp14 = (gsm_byte )((int )sr >> 7);
#line 122
      sr = (uint16_t )(((int )sr >> 3) | ((int )LARc[7] << 13));
#line 123
      sr = (uint16_t )(((int )sr >> 7) | ((int )Nc[0] << 9));
#line 124
      __cil_tmp15 = c;
#line 124
      c ++;
#line 124
      *__cil_tmp15 = (gsm_byte )((int )sr >> 5);
#line 125
      sr = (uint16_t )(((int )sr >> 2) | ((int )bc[0] << 14));
#line 126
      sr = (uint16_t )(((int )sr >> 2) | ((int )Mc[0] << 14));
#line 127
      sr = (uint16_t )(((int )sr >> 6) | ((int )xmaxc[0] << 10));
#line 128
      __cil_tmp16 = c;
#line 128
      c ++;
#line 128
      *__cil_tmp16 = (gsm_byte )((int )sr >> 3);
#line 129
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[0] << 13));
#line 130
      __cil_tmp17 = c;
#line 130
      c ++;
#line 130
      *__cil_tmp17 = (gsm_byte )((int )sr >> 8);
#line 131
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[1] << 13));
#line 132
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[2] << 13));
#line 133
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[3] << 13));
#line 134
      __cil_tmp18 = c;
#line 134
      c ++;
#line 134
      *__cil_tmp18 = (gsm_byte )((int )sr >> 7);
#line 135
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[4] << 13));
#line 136
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[5] << 13));
#line 137
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[6] << 13));
#line 138
      __cil_tmp19 = c;
#line 138
      c ++;
#line 138
      *__cil_tmp19 = (gsm_byte )((int )sr >> 6);
#line 139
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[7] << 13));
#line 140
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[8] << 13));
#line 141
      __cil_tmp20 = c;
#line 141
      c ++;
#line 141
      *__cil_tmp20 = (gsm_byte )((int )sr >> 8);
#line 142
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[9] << 13));
#line 143
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[10] << 13));
#line 144
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[11] << 13));
#line 145
      __cil_tmp21 = c;
#line 145
      c ++;
#line 145
      *__cil_tmp21 = (gsm_byte )((int )sr >> 7);
#line 146
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[12] << 13));
#line 147
      sr = (uint16_t )(((int )sr >> 7) | ((int )Nc[1] << 9));
#line 148
      __cil_tmp22 = c;
#line 148
      c ++;
#line 148
      *__cil_tmp22 = (gsm_byte )((int )sr >> 5);
#line 149
      sr = (uint16_t )(((int )sr >> 2) | ((int )bc[1] << 14));
#line 150
      sr = (uint16_t )(((int )sr >> 2) | ((int )Mc[1] << 14));
#line 151
      sr = (uint16_t )(((int )sr >> 6) | ((int )xmaxc[1] << 10));
#line 152
      __cil_tmp23 = c;
#line 152
      c ++;
#line 152
      *__cil_tmp23 = (gsm_byte )((int )sr >> 3);
#line 153
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[13] << 13));
#line 154
      __cil_tmp24 = c;
#line 154
      c ++;
#line 154
      *__cil_tmp24 = (gsm_byte )((int )sr >> 8);
#line 155
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[14] << 13));
#line 156
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[15] << 13));
#line 157
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[16] << 13));
#line 158
      __cil_tmp25 = c;
#line 158
      c ++;
#line 158
      *__cil_tmp25 = (gsm_byte )((int )sr >> 7);
#line 159
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[17] << 13));
#line 160
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[18] << 13));
#line 161
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[19] << 13));
#line 162
      __cil_tmp26 = c;
#line 162
      c ++;
#line 162
      *__cil_tmp26 = (gsm_byte )((int )sr >> 6);
#line 163
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[20] << 13));
#line 164
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[21] << 13));
#line 165
      __cil_tmp27 = c;
#line 165
      c ++;
#line 165
      *__cil_tmp27 = (gsm_byte )((int )sr >> 8);
#line 166
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[22] << 13));
#line 167
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[23] << 13));
#line 168
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[24] << 13));
#line 169
      __cil_tmp28 = c;
#line 169
      c ++;
#line 169
      *__cil_tmp28 = (gsm_byte )((int )sr >> 7);
#line 170
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[25] << 13));
#line 171
      sr = (uint16_t )(((int )sr >> 7) | ((int )Nc[2] << 9));
#line 172
      __cil_tmp29 = c;
#line 172
      c ++;
#line 172
      *__cil_tmp29 = (gsm_byte )((int )sr >> 5);
#line 173
      sr = (uint16_t )(((int )sr >> 2) | ((int )bc[2] << 14));
#line 174
      sr = (uint16_t )(((int )sr >> 2) | ((int )Mc[2] << 14));
#line 175
      sr = (uint16_t )(((int )sr >> 6) | ((int )xmaxc[2] << 10));
#line 176
      __cil_tmp30 = c;
#line 176
      c ++;
#line 176
      *__cil_tmp30 = (gsm_byte )((int )sr >> 3);
#line 177
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[26] << 13));
#line 178
      __cil_tmp31 = c;
#line 178
      c ++;
#line 178
      *__cil_tmp31 = (gsm_byte )((int )sr >> 8);
#line 179
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[27] << 13));
#line 180
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[28] << 13));
#line 181
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[29] << 13));
#line 182
      __cil_tmp32 = c;
#line 182
      c ++;
#line 182
      *__cil_tmp32 = (gsm_byte )((int )sr >> 7);
#line 183
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[30] << 13));
#line 184
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[31] << 13));
#line 185
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[32] << 13));
#line 186
      __cil_tmp33 = c;
#line 186
      c ++;
#line 186
      *__cil_tmp33 = (gsm_byte )((int )sr >> 6);
#line 187
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[33] << 13));
#line 188
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[34] << 13));
#line 189
      __cil_tmp34 = c;
#line 189
      c ++;
#line 189
      *__cil_tmp34 = (gsm_byte )((int )sr >> 8);
#line 190
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[35] << 13));
#line 191
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[36] << 13));
#line 192
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[37] << 13));
#line 193
      __cil_tmp35 = c;
#line 193
      c ++;
#line 193
      *__cil_tmp35 = (gsm_byte )((int )sr >> 7);
#line 194
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[38] << 13));
#line 195
      sr = (uint16_t )(((int )sr >> 7) | ((int )Nc[3] << 9));
#line 196
      __cil_tmp36 = c;
#line 196
      c ++;
#line 196
      *__cil_tmp36 = (gsm_byte )((int )sr >> 5);
#line 197
      sr = (uint16_t )(((int )sr >> 2) | ((int )bc[3] << 14));
#line 198
      sr = (uint16_t )(((int )sr >> 2) | ((int )Mc[3] << 14));
#line 199
      sr = (uint16_t )(((int )sr >> 6) | ((int )xmaxc[3] << 10));
#line 200
      __cil_tmp37 = c;
#line 200
      c ++;
#line 200
      *__cil_tmp37 = (gsm_byte )((int )sr >> 3);
#line 201
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[39] << 13));
#line 202
      __cil_tmp38 = c;
#line 202
      c ++;
#line 202
      *__cil_tmp38 = (gsm_byte )((int )sr >> 8);
#line 203
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[40] << 13));
#line 204
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[41] << 13));
#line 205
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[42] << 13));
#line 206
      __cil_tmp39 = c;
#line 206
      c ++;
#line 206
      *__cil_tmp39 = (gsm_byte )((int )sr >> 7);
#line 207
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[43] << 13));
#line 208
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[44] << 13));
#line 209
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[45] << 13));
#line 210
      __cil_tmp40 = c;
#line 210
      c ++;
#line 210
      *__cil_tmp40 = (gsm_byte )((int )sr >> 6);
#line 211
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[46] << 13));
#line 212
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[47] << 13));
#line 213
      __cil_tmp41 = c;
#line 213
      c ++;
#line 213
      *__cil_tmp41 = (gsm_byte )((int )sr >> 8);
#line 214
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[48] << 13));
#line 215
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[49] << 13));
#line 216
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[50] << 13));
#line 217
      __cil_tmp42 = c;
#line 217
      c ++;
#line 217
      *__cil_tmp42 = (gsm_byte )((int )sr >> 7);
#line 218
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[51] << 13));
#line 219
      sr = (uint16_t )((int )sr >> 4);
#line 220
      *c = (gsm_byte )((int )sr >> 8);
#line 221
      s->frame_chain = *c;
    } else {
#line 226
      sr___0 = (uint16_t )0;
#line 227
      sr___0 = (uint16_t )(((int )sr___0 >> 4) | ((int )s->frame_chain << 12));
#line 228
      sr___0 = (uint16_t )(((int )sr___0 >> 6) | ((int )LARc[0] << 10));
#line 229
      __cil_tmp44 = c;
#line 229
      c ++;
#line 229
      *__cil_tmp44 = (gsm_byte )((int )sr___0 >> 6);
#line 230
      sr___0 = (uint16_t )(((int )sr___0 >> 6) | ((int )LARc[1] << 10));
#line 231
      __cil_tmp45 = c;
#line 231
      c ++;
#line 231
      *__cil_tmp45 = (gsm_byte )((int )sr___0 >> 8);
#line 232
      sr___0 = (uint16_t )(((int )sr___0 >> 5) | ((int )LARc[2] << 11));
#line 233
      sr___0 = (uint16_t )(((int )sr___0 >> 5) | ((int )LARc[3] << 11));
#line 234
      __cil_tmp46 = c;
#line 234
      c ++;
#line 234
      *__cil_tmp46 = (gsm_byte )((int )sr___0 >> 6);
#line 235
      sr___0 = (uint16_t )(((int )sr___0 >> 4) | ((int )LARc[4] << 12));
#line 236
      sr___0 = (uint16_t )(((int )sr___0 >> 4) | ((int )LARc[5] << 12));
#line 237
      __cil_tmp47 = c;
#line 237
      c ++;
#line 237
      *__cil_tmp47 = (gsm_byte )((int )sr___0 >> 6);
#line 238
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )LARc[6] << 13));
#line 239
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )LARc[7] << 13));
#line 240
      __cil_tmp48 = c;
#line 240
      c ++;
#line 240
      *__cil_tmp48 = (gsm_byte )((int )sr___0 >> 8);
#line 241
      sr___0 = (uint16_t )(((int )sr___0 >> 7) | ((int )Nc[0] << 9));
#line 242
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )bc[0] << 14));
#line 243
      __cil_tmp49 = c;
#line 243
      c ++;
#line 243
      *__cil_tmp49 = (gsm_byte )((int )sr___0 >> 7);
#line 244
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )Mc[0] << 14));
#line 245
      sr___0 = (uint16_t )(((int )sr___0 >> 6) | ((int )xmaxc[0] << 10));
#line 246
      __cil_tmp50 = c;
#line 246
      c ++;
#line 246
      *__cil_tmp50 = (gsm_byte )((int )sr___0 >> 7);
#line 247
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[0] << 13));
#line 248
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[1] << 13));
#line 249
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[2] << 13));
#line 250
      __cil_tmp51 = c;
#line 250
      c ++;
#line 250
      *__cil_tmp51 = (gsm_byte )((int )sr___0 >> 6);
#line 251
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[3] << 13));
#line 252
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[4] << 13));
#line 253
      __cil_tmp52 = c;
#line 253
      c ++;
#line 253
      *__cil_tmp52 = (gsm_byte )((int )sr___0 >> 8);
#line 254
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[5] << 13));
#line 255
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[6] << 13));
#line 256
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[7] << 13));
#line 257
      __cil_tmp53 = c;
#line 257
      c ++;
#line 257
      *__cil_tmp53 = (gsm_byte )((int )sr___0 >> 7);
#line 258
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[8] << 13));
#line 259
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[9] << 13));
#line 260
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[10] << 13));
#line 261
      __cil_tmp54 = c;
#line 261
      c ++;
#line 261
      *__cil_tmp54 = (gsm_byte )((int )sr___0 >> 6);
#line 262
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[11] << 13));
#line 263
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[12] << 13));
#line 264
      __cil_tmp55 = c;
#line 264
      c ++;
#line 264
      *__cil_tmp55 = (gsm_byte )((int )sr___0 >> 8);
#line 265
      sr___0 = (uint16_t )(((int )sr___0 >> 7) | ((int )Nc[1] << 9));
#line 266
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )bc[1] << 14));
#line 267
      __cil_tmp56 = c;
#line 267
      c ++;
#line 267
      *__cil_tmp56 = (gsm_byte )((int )sr___0 >> 7);
#line 268
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )Mc[1] << 14));
#line 269
      sr___0 = (uint16_t )(((int )sr___0 >> 6) | ((int )xmaxc[1] << 10));
#line 270
      __cil_tmp57 = c;
#line 270
      c ++;
#line 270
      *__cil_tmp57 = (gsm_byte )((int )sr___0 >> 7);
#line 271
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[13] << 13));
#line 272
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[14] << 13));
#line 273
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[15] << 13));
#line 274
      __cil_tmp58 = c;
#line 274
      c ++;
#line 274
      *__cil_tmp58 = (gsm_byte )((int )sr___0 >> 6);
#line 275
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[16] << 13));
#line 276
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[17] << 13));
#line 277
      __cil_tmp59 = c;
#line 277
      c ++;
#line 277
      *__cil_tmp59 = (gsm_byte )((int )sr___0 >> 8);
#line 278
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[18] << 13));
#line 279
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[19] << 13));
#line 280
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[20] << 13));
#line 281
      __cil_tmp60 = c;
#line 281
      c ++;
#line 281
      *__cil_tmp60 = (gsm_byte )((int )sr___0 >> 7);
#line 282
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[21] << 13));
#line 283
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[22] << 13));
#line 284
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[23] << 13));
#line 285
      __cil_tmp61 = c;
#line 285
      c ++;
#line 285
      *__cil_tmp61 = (gsm_byte )((int )sr___0 >> 6);
#line 286
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[24] << 13));
#line 287
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[25] << 13));
#line 288
      __cil_tmp62 = c;
#line 288
      c ++;
#line 288
      *__cil_tmp62 = (gsm_byte )((int )sr___0 >> 8);
#line 289
      sr___0 = (uint16_t )(((int )sr___0 >> 7) | ((int )Nc[2] << 9));
#line 290
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )bc[2] << 14));
#line 291
      __cil_tmp63 = c;
#line 291
      c ++;
#line 291
      *__cil_tmp63 = (gsm_byte )((int )sr___0 >> 7);
#line 292
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )Mc[2] << 14));
#line 293
      sr___0 = (uint16_t )(((int )sr___0 >> 6) | ((int )xmaxc[2] << 10));
#line 294
      __cil_tmp64 = c;
#line 294
      c ++;
#line 294
      *__cil_tmp64 = (gsm_byte )((int )sr___0 >> 7);
#line 295
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[26] << 13));
#line 296
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[27] << 13));
#line 297
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[28] << 13));
#line 298
      __cil_tmp65 = c;
#line 298
      c ++;
#line 298
      *__cil_tmp65 = (gsm_byte )((int )sr___0 >> 6);
#line 299
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[29] << 13));
#line 300
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[30] << 13));
#line 301
      __cil_tmp66 = c;
#line 301
      c ++;
#line 301
      *__cil_tmp66 = (gsm_byte )((int )sr___0 >> 8);
#line 302
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[31] << 13));
#line 303
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[32] << 13));
#line 304
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[33] << 13));
#line 305
      __cil_tmp67 = c;
#line 305
      c ++;
#line 305
      *__cil_tmp67 = (gsm_byte )((int )sr___0 >> 7);
#line 306
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[34] << 13));
#line 307
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[35] << 13));
#line 308
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[36] << 13));
#line 309
      __cil_tmp68 = c;
#line 309
      c ++;
#line 309
      *__cil_tmp68 = (gsm_byte )((int )sr___0 >> 6);
#line 310
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[37] << 13));
#line 311
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[38] << 13));
#line 312
      __cil_tmp69 = c;
#line 312
      c ++;
#line 312
      *__cil_tmp69 = (gsm_byte )((int )sr___0 >> 8);
#line 313
      sr___0 = (uint16_t )(((int )sr___0 >> 7) | ((int )Nc[3] << 9));
#line 314
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )bc[3] << 14));
#line 315
      __cil_tmp70 = c;
#line 315
      c ++;
#line 315
      *__cil_tmp70 = (gsm_byte )((int )sr___0 >> 7);
#line 316
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )Mc[3] << 14));
#line 317
      sr___0 = (uint16_t )(((int )sr___0 >> 6) | ((int )xmaxc[3] << 10));
#line 318
      __cil_tmp71 = c;
#line 318
      c ++;
#line 318
      *__cil_tmp71 = (gsm_byte )((int )sr___0 >> 7);
#line 319
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[39] << 13));
#line 320
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[40] << 13));
#line 321
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[41] << 13));
#line 322
      __cil_tmp72 = c;
#line 322
      c ++;
#line 322
      *__cil_tmp72 = (gsm_byte )((int )sr___0 >> 6);
#line 323
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[42] << 13));
#line 324
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[43] << 13));
#line 325
      __cil_tmp73 = c;
#line 325
      c ++;
#line 325
      *__cil_tmp73 = (gsm_byte )((int )sr___0 >> 8);
#line 326
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[44] << 13));
#line 327
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[45] << 13));
#line 328
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[46] << 13));
#line 329
      __cil_tmp74 = c;
#line 329
      c ++;
#line 329
      *__cil_tmp74 = (gsm_byte )((int )sr___0 >> 7);
#line 330
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[47] << 13));
#line 331
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[48] << 13));
#line 332
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[49] << 13));
#line 333
      __cil_tmp75 = c;
#line 333
      c ++;
#line 333
      *__cil_tmp75 = (gsm_byte )((int )sr___0 >> 6);
#line 334
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[50] << 13));
#line 335
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[51] << 13));
#line 336
      __cil_tmp76 = c;
#line 336
      c ++;
#line 336
      *__cil_tmp76 = (gsm_byte )((int )sr___0 >> 8);
    }
  } else {
#line 345
    __cil_tmp77 = c;
#line 345
    c ++;
#line 345
    *__cil_tmp77 = (gsm_byte )((13 << 4) | (((int )LARc[0] >> 2) & 15));
#line 347
    __cil_tmp78 = c;
#line 347
    c ++;
#line 347
    *__cil_tmp78 = (gsm_byte )((((int )LARc[0] & 3) << 6) | ((int )LARc[1] & 63));
#line 349
    __cil_tmp79 = c;
#line 349
    c ++;
#line 349
    *__cil_tmp79 = (gsm_byte )((((int )LARc[2] & 31) << 3) | (((int )LARc[3] >> 2) & 7));
#line 351
    __cil_tmp80 = c;
#line 351
    c ++;
#line 351
    *__cil_tmp80 = (gsm_byte )(((((int )LARc[3] & 3) << 6) | (((int )LARc[4] & 15) << 2)) | (((int )LARc[5] >> 2) & 3));
#line 354
    __cil_tmp81 = c;
#line 354
    c ++;
#line 354
    *__cil_tmp81 = (gsm_byte )(((((int )LARc[5] & 3) << 6) | (((int )LARc[6] & 7) << 3)) | ((int )LARc[7] & 7));
#line 357
    __cil_tmp82 = c;
#line 357
    c ++;
#line 357
    *__cil_tmp82 = (gsm_byte )((((int )Nc[0] & 127) << 1) | (((int )bc[0] >> 1) & 1));
#line 359
    __cil_tmp83 = c;
#line 359
    c ++;
#line 359
    *__cil_tmp83 = (gsm_byte )(((((int )bc[0] & 1) << 7) | (((int )Mc[0] & 3) << 5)) | (((int )xmaxc[0] >> 1) & 31));
#line 362
    __cil_tmp84 = c;
#line 362
    c ++;
#line 362
    *__cil_tmp84 = (gsm_byte )((((((int )xmaxc[0] & 1) << 7) | (((int )xmc[0] & 7) << 4)) | (((int )xmc[1] & 7) << 1)) | (((int )xmc[2] >> 2) & 1));
#line 366
    __cil_tmp85 = c;
#line 366
    c ++;
#line 366
    *__cil_tmp85 = (gsm_byte )(((((int )xmc[2] & 3) << 6) | (((int )xmc[3] & 7) << 3)) | ((int )xmc[4] & 7));
#line 369
    __cil_tmp86 = c;
#line 369
    c ++;
#line 369
    *__cil_tmp86 = (gsm_byte )(((((int )xmc[5] & 7) << 5) | (((int )xmc[6] & 7) << 2)) | (((int )xmc[7] >> 1) & 3));
#line 372
    __cil_tmp87 = c;
#line 372
    c ++;
#line 372
    *__cil_tmp87 = (gsm_byte )((((((int )xmc[7] & 1) << 7) | (((int )xmc[8] & 7) << 4)) | (((int )xmc[9] & 7) << 1)) | (((int )xmc[10] >> 2) & 1));
#line 376
    __cil_tmp88 = c;
#line 376
    c ++;
#line 376
    *__cil_tmp88 = (gsm_byte )(((((int )xmc[10] & 3) << 6) | (((int )xmc[11] & 7) << 3)) | ((int )xmc[12] & 7));
#line 379
    __cil_tmp89 = c;
#line 379
    c ++;
#line 379
    *__cil_tmp89 = (gsm_byte )((((int )Nc[1] & 127) << 1) | (((int )bc[1] >> 1) & 1));
#line 381
    __cil_tmp90 = c;
#line 381
    c ++;
#line 381
    *__cil_tmp90 = (gsm_byte )(((((int )bc[1] & 1) << 7) | (((int )Mc[1] & 3) << 5)) | (((int )xmaxc[1] >> 1) & 31));
#line 384
    __cil_tmp91 = c;
#line 384
    c ++;
#line 384
    *__cil_tmp91 = (gsm_byte )((((((int )xmaxc[1] & 1) << 7) | (((int )xmc[13] & 7) << 4)) | (((int )xmc[14] & 7) << 1)) | (((int )xmc[15] >> 2) & 1));
#line 388
    __cil_tmp92 = c;
#line 388
    c ++;
#line 388
    *__cil_tmp92 = (gsm_byte )(((((int )xmc[15] & 3) << 6) | (((int )xmc[16] & 7) << 3)) | ((int )xmc[17] & 7));
#line 391
    __cil_tmp93 = c;
#line 391
    c ++;
#line 391
    *__cil_tmp93 = (gsm_byte )(((((int )xmc[18] & 7) << 5) | (((int )xmc[19] & 7) << 2)) | (((int )xmc[20] >> 1) & 3));
#line 394
    __cil_tmp94 = c;
#line 394
    c ++;
#line 394
    *__cil_tmp94 = (gsm_byte )((((((int )xmc[20] & 1) << 7) | (((int )xmc[21] & 7) << 4)) | (((int )xmc[22] & 7) << 1)) | (((int )xmc[23] >> 2) & 1));
#line 398
    __cil_tmp95 = c;
#line 398
    c ++;
#line 398
    *__cil_tmp95 = (gsm_byte )(((((int )xmc[23] & 3) << 6) | (((int )xmc[24] & 7) << 3)) | ((int )xmc[25] & 7));
#line 401
    __cil_tmp96 = c;
#line 401
    c ++;
#line 401
    *__cil_tmp96 = (gsm_byte )((((int )Nc[2] & 127) << 1) | (((int )bc[2] >> 1) & 1));
#line 403
    __cil_tmp97 = c;
#line 403
    c ++;
#line 403
    *__cil_tmp97 = (gsm_byte )(((((int )bc[2] & 1) << 7) | (((int )Mc[2] & 3) << 5)) | (((int )xmaxc[2] >> 1) & 31));
#line 406
    __cil_tmp98 = c;
#line 406
    c ++;
#line 406
    *__cil_tmp98 = (gsm_byte )((((((int )xmaxc[2] & 1) << 7) | (((int )xmc[26] & 7) << 4)) | (((int )xmc[27] & 7) << 1)) | (((int )xmc[28] >> 2) & 1));
#line 410
    __cil_tmp99 = c;
#line 410
    c ++;
#line 410
    *__cil_tmp99 = (gsm_byte )(((((int )xmc[28] & 3) << 6) | (((int )xmc[29] & 7) << 3)) | ((int )xmc[30] & 7));
#line 413
    __cil_tmp100 = c;
#line 413
    c ++;
#line 413
    *__cil_tmp100 = (gsm_byte )(((((int )xmc[31] & 7) << 5) | (((int )xmc[32] & 7) << 2)) | (((int )xmc[33] >> 1) & 3));
#line 416
    __cil_tmp101 = c;
#line 416
    c ++;
#line 416
    *__cil_tmp101 = (gsm_byte )((((((int )xmc[33] & 1) << 7) | (((int )xmc[34] & 7) << 4)) | (((int )xmc[35] & 7) << 1)) | (((int )xmc[36] >> 2) & 1));
#line 420
    __cil_tmp102 = c;
#line 420
    c ++;
#line 420
    *__cil_tmp102 = (gsm_byte )(((((int )xmc[36] & 3) << 6) | (((int )xmc[37] & 7) << 3)) | ((int )xmc[38] & 7));
#line 423
    __cil_tmp103 = c;
#line 423
    c ++;
#line 423
    *__cil_tmp103 = (gsm_byte )((((int )Nc[3] & 127) << 1) | (((int )bc[3] >> 1) & 1));
#line 425
    __cil_tmp104 = c;
#line 425
    c ++;
#line 425
    *__cil_tmp104 = (gsm_byte )(((((int )bc[3] & 1) << 7) | (((int )Mc[3] & 3) << 5)) | (((int )xmaxc[3] >> 1) & 31));
#line 428
    __cil_tmp105 = c;
#line 428
    c ++;
#line 428
    *__cil_tmp105 = (gsm_byte )((((((int )xmaxc[3] & 1) << 7) | (((int )xmc[39] & 7) << 4)) | (((int )xmc[40] & 7) << 1)) | (((int )xmc[41] >> 2) & 1));
#line 432
    __cil_tmp106 = c;
#line 432
    c ++;
#line 432
    *__cil_tmp106 = (gsm_byte )(((((int )xmc[41] & 3) << 6) | (((int )xmc[42] & 7) << 3)) | ((int )xmc[43] & 7));
#line 435
    __cil_tmp107 = c;
#line 435
    c ++;
#line 435
    *__cil_tmp107 = (gsm_byte )(((((int )xmc[44] & 7) << 5) | (((int )xmc[45] & 7) << 2)) | (((int )xmc[46] >> 1) & 3));
#line 438
    __cil_tmp108 = c;
#line 438
    c ++;
#line 438
    *__cil_tmp108 = (gsm_byte )((((((int )xmc[46] & 1) << 7) | (((int )xmc[47] & 7) << 4)) | (((int )xmc[48] & 7) << 1)) | (((int )xmc[49] >> 2) & 1));
#line 442
    __cil_tmp109 = c;
#line 442
    c ++;
#line 442
    *__cil_tmp109 = (gsm_byte )(((((int )xmc[49] & 3) << 6) | (((int )xmc[50] & 7) << 3)) | ((int )xmc[51] & 7));
  }
#line 444
  return;
}
}
#line 20 "/root/patchweave_new/23/src/GSM610/gsm_destroy.c"
void gsm_destroy(gsm S ) 
{ 


  {
#line 22
  if (S) {
    {
#line 23
    free((void *)((char *)S));
    }
  }
#line 26
  return;
}
}
#line 11 "/root/patchweave_new/23/src/GSM610/gsm_decode.c"
int gsm_decode(gsm s , gsm_byte *c , gsm_signal *target ) 
{ 
  int16_t LARc[8] ;
  int16_t Nc[4] ;
  int16_t Mc[4] ;
  int16_t bc[4] ;
  int16_t xmaxc[4] ;
  int16_t xmc[52] ;
  uint16_t sr ;
  gsm_byte *__cil_tmp11 ;
  gsm_byte *__cil_tmp12 ;
  gsm_byte *__cil_tmp13 ;
  gsm_byte *__cil_tmp14 ;
  gsm_byte *__cil_tmp15 ;
  gsm_byte *__cil_tmp16 ;
  gsm_byte *__cil_tmp17 ;
  gsm_byte *__cil_tmp18 ;
  gsm_byte *__cil_tmp19 ;
  gsm_byte *__cil_tmp20 ;
  gsm_byte *__cil_tmp21 ;
  gsm_byte *__cil_tmp22 ;
  gsm_byte *__cil_tmp23 ;
  gsm_byte *__cil_tmp24 ;
  gsm_byte *__cil_tmp25 ;
  gsm_byte *__cil_tmp26 ;
  gsm_byte *__cil_tmp27 ;
  gsm_byte *__cil_tmp28 ;
  gsm_byte *__cil_tmp29 ;
  gsm_byte *__cil_tmp30 ;
  gsm_byte *__cil_tmp31 ;
  gsm_byte *__cil_tmp32 ;
  gsm_byte *__cil_tmp33 ;
  gsm_byte *__cil_tmp34 ;
  gsm_byte *__cil_tmp35 ;
  gsm_byte *__cil_tmp36 ;
  gsm_byte *__cil_tmp37 ;
  gsm_byte *__cil_tmp38 ;
  gsm_byte *__cil_tmp39 ;
  gsm_byte *__cil_tmp40 ;
  gsm_byte *__cil_tmp41 ;
  gsm_byte *__cil_tmp42 ;
  gsm_byte *__cil_tmp43 ;
  gsm_byte *__cil_tmp44 ;
  gsm_byte *__cil_tmp45 ;
  gsm_byte *__cil_tmp46 ;
  gsm_byte *__cil_tmp47 ;
  gsm_byte *__cil_tmp48 ;
  gsm_byte *__cil_tmp49 ;
  gsm_byte *__cil_tmp50 ;
  gsm_byte *__cil_tmp51 ;
  gsm_byte *__cil_tmp52 ;
  gsm_byte *__cil_tmp53 ;
  gsm_byte *__cil_tmp54 ;
  gsm_byte *__cil_tmp55 ;
  gsm_byte *__cil_tmp56 ;
  gsm_byte *__cil_tmp57 ;
  gsm_byte *__cil_tmp58 ;
  gsm_byte *__cil_tmp59 ;
  gsm_byte *__cil_tmp60 ;
  gsm_byte *__cil_tmp61 ;
  gsm_byte *__cil_tmp62 ;
  gsm_byte *__cil_tmp63 ;
  gsm_byte *__cil_tmp64 ;
  gsm_byte *__cil_tmp65 ;
  gsm_byte *__cil_tmp66 ;
  gsm_byte *__cil_tmp67 ;
  gsm_byte *__cil_tmp68 ;
  gsm_byte *__cil_tmp69 ;
  gsm_byte *__cil_tmp70 ;
  gsm_byte *__cil_tmp71 ;
  gsm_byte *__cil_tmp72 ;
  gsm_byte *__cil_tmp73 ;
  gsm_byte *__cil_tmp74 ;
  gsm_byte *__cil_tmp75 ;
  gsm_byte *__cil_tmp76 ;
  gsm_byte *__cil_tmp77 ;
  gsm_byte *__cil_tmp78 ;
  gsm_byte *__cil_tmp79 ;
  gsm_byte *__cil_tmp80 ;
  gsm_byte *__cil_tmp81 ;
  gsm_byte *__cil_tmp82 ;
  gsm_byte *__cil_tmp83 ;
  gsm_byte *__cil_tmp84 ;
  gsm_byte *__cil_tmp85 ;
  gsm_byte *__cil_tmp86 ;
  gsm_byte *__cil_tmp87 ;
  gsm_byte *__cil_tmp88 ;
  gsm_byte *__cil_tmp89 ;
  gsm_byte *__cil_tmp90 ;
  gsm_byte *__cil_tmp91 ;
  gsm_byte *__cil_tmp92 ;
  gsm_byte *__cil_tmp93 ;
  gsm_byte *__cil_tmp94 ;
  gsm_byte *__cil_tmp95 ;
  gsm_byte *__cil_tmp96 ;
  gsm_byte *__cil_tmp97 ;
  gsm_byte *__cil_tmp98 ;
  gsm_byte *__cil_tmp99 ;
  gsm_byte *__cil_tmp100 ;
  gsm_byte *__cil_tmp101 ;
  gsm_byte *__cil_tmp102 ;
  gsm_byte *__cil_tmp103 ;
  gsm_byte *__cil_tmp104 ;
  gsm_byte *__cil_tmp105 ;
  gsm_byte *__cil_tmp106 ;
  gsm_byte *__cil_tmp107 ;

  {
#line 16
  if (s->wav_fmt) {
#line 17
    sr = (uint16_t )0;
#line 19
    s->frame_index = (unsigned char )(! s->frame_index);
#line 20
    if (s->frame_index) {
#line 21
      __cil_tmp11 = c;
#line 21
      c ++;
#line 21
      sr = (uint16_t )*__cil_tmp11;
#line 22
      LARc[0] = (int16_t )((int )sr & 63);
#line 22
      sr = (uint16_t )((int )sr >> 6);
#line 23
      __cil_tmp12 = c;
#line 23
      c ++;
#line 23
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp12) << 2));
#line 24
      LARc[1] = (int16_t )((int )sr & 63);
#line 24
      sr = (uint16_t )((int )sr >> 6);
#line 25
      __cil_tmp13 = c;
#line 25
      c ++;
#line 25
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp13) << 4));
#line 26
      LARc[2] = (int16_t )((int )sr & 31);
#line 26
      sr = (uint16_t )((int )sr >> 5);
#line 27
      LARc[3] = (int16_t )((int )sr & 31);
#line 27
      sr = (uint16_t )((int )sr >> 5);
#line 28
      __cil_tmp14 = c;
#line 28
      c ++;
#line 28
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp14) << 2));
#line 29
      LARc[4] = (int16_t )((int )sr & 15);
#line 29
      sr = (uint16_t )((int )sr >> 4);
#line 30
      LARc[5] = (int16_t )((int )sr & 15);
#line 30
      sr = (uint16_t )((int )sr >> 4);
#line 31
      __cil_tmp15 = c;
#line 31
      c ++;
#line 31
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp15) << 2));
#line 32
      LARc[6] = (int16_t )((int )sr & 7);
#line 32
      sr = (uint16_t )((int )sr >> 3);
#line 33
      LARc[7] = (int16_t )((int )sr & 7);
#line 33
      sr = (uint16_t )((int )sr >> 3);
#line 34
      __cil_tmp16 = c;
#line 34
      c ++;
#line 34
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp16) << 4));
#line 35
      Nc[0] = (int16_t )((int )sr & 127);
#line 35
      sr = (uint16_t )((int )sr >> 7);
#line 36
      bc[0] = (int16_t )((int )sr & 3);
#line 36
      sr = (uint16_t )((int )sr >> 2);
#line 37
      Mc[0] = (int16_t )((int )sr & 3);
#line 37
      sr = (uint16_t )((int )sr >> 2);
#line 38
      __cil_tmp17 = c;
#line 38
      c ++;
#line 38
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp17) << 1));
#line 39
      xmaxc[0] = (int16_t )((int )sr & 63);
#line 39
      sr = (uint16_t )((int )sr >> 6);
#line 40
      xmc[0] = (int16_t )((int )sr & 7);
#line 40
      sr = (uint16_t )((int )sr >> 3);
#line 41
      __cil_tmp18 = c;
#line 41
      c ++;
#line 41
      sr = (uint16_t )*__cil_tmp18;
#line 42
      xmc[1] = (int16_t )((int )sr & 7);
#line 42
      sr = (uint16_t )((int )sr >> 3);
#line 43
      xmc[2] = (int16_t )((int )sr & 7);
#line 43
      sr = (uint16_t )((int )sr >> 3);
#line 44
      __cil_tmp19 = c;
#line 44
      c ++;
#line 44
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp19) << 2));
#line 45
      xmc[3] = (int16_t )((int )sr & 7);
#line 45
      sr = (uint16_t )((int )sr >> 3);
#line 46
      xmc[4] = (int16_t )((int )sr & 7);
#line 46
      sr = (uint16_t )((int )sr >> 3);
#line 47
      xmc[5] = (int16_t )((int )sr & 7);
#line 47
      sr = (uint16_t )((int )sr >> 3);
#line 48
      __cil_tmp20 = c;
#line 48
      c ++;
#line 48
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp20) << 1));
#line 49
      xmc[6] = (int16_t )((int )sr & 7);
#line 49
      sr = (uint16_t )((int )sr >> 3);
#line 50
      xmc[7] = (int16_t )((int )sr & 7);
#line 50
      sr = (uint16_t )((int )sr >> 3);
#line 51
      xmc[8] = (int16_t )((int )sr & 7);
#line 51
      sr = (uint16_t )((int )sr >> 3);
#line 52
      __cil_tmp21 = c;
#line 52
      c ++;
#line 52
      sr = (uint16_t )*__cil_tmp21;
#line 53
      xmc[9] = (int16_t )((int )sr & 7);
#line 53
      sr = (uint16_t )((int )sr >> 3);
#line 54
      xmc[10] = (int16_t )((int )sr & 7);
#line 54
      sr = (uint16_t )((int )sr >> 3);
#line 55
      __cil_tmp22 = c;
#line 55
      c ++;
#line 55
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp22) << 2));
#line 56
      xmc[11] = (int16_t )((int )sr & 7);
#line 56
      sr = (uint16_t )((int )sr >> 3);
#line 57
      xmc[12] = (int16_t )((int )sr & 7);
#line 57
      sr = (uint16_t )((int )sr >> 3);
#line 58
      __cil_tmp23 = c;
#line 58
      c ++;
#line 58
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp23) << 4));
#line 59
      Nc[1] = (int16_t )((int )sr & 127);
#line 59
      sr = (uint16_t )((int )sr >> 7);
#line 60
      bc[1] = (int16_t )((int )sr & 3);
#line 60
      sr = (uint16_t )((int )sr >> 2);
#line 61
      Mc[1] = (int16_t )((int )sr & 3);
#line 61
      sr = (uint16_t )((int )sr >> 2);
#line 62
      __cil_tmp24 = c;
#line 62
      c ++;
#line 62
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp24) << 1));
#line 63
      xmaxc[1] = (int16_t )((int )sr & 63);
#line 63
      sr = (uint16_t )((int )sr >> 6);
#line 64
      xmc[13] = (int16_t )((int )sr & 7);
#line 64
      sr = (uint16_t )((int )sr >> 3);
#line 65
      __cil_tmp25 = c;
#line 65
      c ++;
#line 65
      sr = (uint16_t )*__cil_tmp25;
#line 66
      xmc[14] = (int16_t )((int )sr & 7);
#line 66
      sr = (uint16_t )((int )sr >> 3);
#line 67
      xmc[15] = (int16_t )((int )sr & 7);
#line 67
      sr = (uint16_t )((int )sr >> 3);
#line 68
      __cil_tmp26 = c;
#line 68
      c ++;
#line 68
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp26) << 2));
#line 69
      xmc[16] = (int16_t )((int )sr & 7);
#line 69
      sr = (uint16_t )((int )sr >> 3);
#line 70
      xmc[17] = (int16_t )((int )sr & 7);
#line 70
      sr = (uint16_t )((int )sr >> 3);
#line 71
      xmc[18] = (int16_t )((int )sr & 7);
#line 71
      sr = (uint16_t )((int )sr >> 3);
#line 72
      __cil_tmp27 = c;
#line 72
      c ++;
#line 72
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp27) << 1));
#line 73
      xmc[19] = (int16_t )((int )sr & 7);
#line 73
      sr = (uint16_t )((int )sr >> 3);
#line 74
      xmc[20] = (int16_t )((int )sr & 7);
#line 74
      sr = (uint16_t )((int )sr >> 3);
#line 75
      xmc[21] = (int16_t )((int )sr & 7);
#line 75
      sr = (uint16_t )((int )sr >> 3);
#line 76
      __cil_tmp28 = c;
#line 76
      c ++;
#line 76
      sr = (uint16_t )*__cil_tmp28;
#line 77
      xmc[22] = (int16_t )((int )sr & 7);
#line 77
      sr = (uint16_t )((int )sr >> 3);
#line 78
      xmc[23] = (int16_t )((int )sr & 7);
#line 78
      sr = (uint16_t )((int )sr >> 3);
#line 79
      __cil_tmp29 = c;
#line 79
      c ++;
#line 79
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp29) << 2));
#line 80
      xmc[24] = (int16_t )((int )sr & 7);
#line 80
      sr = (uint16_t )((int )sr >> 3);
#line 81
      xmc[25] = (int16_t )((int )sr & 7);
#line 81
      sr = (uint16_t )((int )sr >> 3);
#line 82
      __cil_tmp30 = c;
#line 82
      c ++;
#line 82
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp30) << 4));
#line 83
      Nc[2] = (int16_t )((int )sr & 127);
#line 83
      sr = (uint16_t )((int )sr >> 7);
#line 84
      bc[2] = (int16_t )((int )sr & 3);
#line 84
      sr = (uint16_t )((int )sr >> 2);
#line 85
      Mc[2] = (int16_t )((int )sr & 3);
#line 85
      sr = (uint16_t )((int )sr >> 2);
#line 86
      __cil_tmp31 = c;
#line 86
      c ++;
#line 86
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp31) << 1));
#line 87
      xmaxc[2] = (int16_t )((int )sr & 63);
#line 87
      sr = (uint16_t )((int )sr >> 6);
#line 88
      xmc[26] = (int16_t )((int )sr & 7);
#line 88
      sr = (uint16_t )((int )sr >> 3);
#line 89
      __cil_tmp32 = c;
#line 89
      c ++;
#line 89
      sr = (uint16_t )*__cil_tmp32;
#line 90
      xmc[27] = (int16_t )((int )sr & 7);
#line 90
      sr = (uint16_t )((int )sr >> 3);
#line 91
      xmc[28] = (int16_t )((int )sr & 7);
#line 91
      sr = (uint16_t )((int )sr >> 3);
#line 92
      __cil_tmp33 = c;
#line 92
      c ++;
#line 92
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp33) << 2));
#line 93
      xmc[29] = (int16_t )((int )sr & 7);
#line 93
      sr = (uint16_t )((int )sr >> 3);
#line 94
      xmc[30] = (int16_t )((int )sr & 7);
#line 94
      sr = (uint16_t )((int )sr >> 3);
#line 95
      xmc[31] = (int16_t )((int )sr & 7);
#line 95
      sr = (uint16_t )((int )sr >> 3);
#line 96
      __cil_tmp34 = c;
#line 96
      c ++;
#line 96
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp34) << 1));
#line 97
      xmc[32] = (int16_t )((int )sr & 7);
#line 97
      sr = (uint16_t )((int )sr >> 3);
#line 98
      xmc[33] = (int16_t )((int )sr & 7);
#line 98
      sr = (uint16_t )((int )sr >> 3);
#line 99
      xmc[34] = (int16_t )((int )sr & 7);
#line 99
      sr = (uint16_t )((int )sr >> 3);
#line 100
      __cil_tmp35 = c;
#line 100
      c ++;
#line 100
      sr = (uint16_t )*__cil_tmp35;
#line 101
      xmc[35] = (int16_t )((int )sr & 7);
#line 101
      sr = (uint16_t )((int )sr >> 3);
#line 102
      xmc[36] = (int16_t )((int )sr & 7);
#line 102
      sr = (uint16_t )((int )sr >> 3);
#line 103
      __cil_tmp36 = c;
#line 103
      c ++;
#line 103
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp36) << 2));
#line 104
      xmc[37] = (int16_t )((int )sr & 7);
#line 104
      sr = (uint16_t )((int )sr >> 3);
#line 105
      xmc[38] = (int16_t )((int )sr & 7);
#line 105
      sr = (uint16_t )((int )sr >> 3);
#line 106
      __cil_tmp37 = c;
#line 106
      c ++;
#line 106
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp37) << 4));
#line 107
      Nc[3] = (int16_t )((int )sr & 127);
#line 107
      sr = (uint16_t )((int )sr >> 7);
#line 108
      bc[3] = (int16_t )((int )sr & 3);
#line 108
      sr = (uint16_t )((int )sr >> 2);
#line 109
      Mc[3] = (int16_t )((int )sr & 3);
#line 109
      sr = (uint16_t )((int )sr >> 2);
#line 110
      __cil_tmp38 = c;
#line 110
      c ++;
#line 110
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp38) << 1));
#line 111
      xmaxc[3] = (int16_t )((int )sr & 63);
#line 111
      sr = (uint16_t )((int )sr >> 6);
#line 112
      xmc[39] = (int16_t )((int )sr & 7);
#line 112
      sr = (uint16_t )((int )sr >> 3);
#line 113
      __cil_tmp39 = c;
#line 113
      c ++;
#line 113
      sr = (uint16_t )*__cil_tmp39;
#line 114
      xmc[40] = (int16_t )((int )sr & 7);
#line 114
      sr = (uint16_t )((int )sr >> 3);
#line 115
      xmc[41] = (int16_t )((int )sr & 7);
#line 115
      sr = (uint16_t )((int )sr >> 3);
#line 116
      __cil_tmp40 = c;
#line 116
      c ++;
#line 116
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp40) << 2));
#line 117
      xmc[42] = (int16_t )((int )sr & 7);
#line 117
      sr = (uint16_t )((int )sr >> 3);
#line 118
      xmc[43] = (int16_t )((int )sr & 7);
#line 118
      sr = (uint16_t )((int )sr >> 3);
#line 119
      xmc[44] = (int16_t )((int )sr & 7);
#line 119
      sr = (uint16_t )((int )sr >> 3);
#line 120
      __cil_tmp41 = c;
#line 120
      c ++;
#line 120
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp41) << 1));
#line 121
      xmc[45] = (int16_t )((int )sr & 7);
#line 121
      sr = (uint16_t )((int )sr >> 3);
#line 122
      xmc[46] = (int16_t )((int )sr & 7);
#line 122
      sr = (uint16_t )((int )sr >> 3);
#line 123
      xmc[47] = (int16_t )((int )sr & 7);
#line 123
      sr = (uint16_t )((int )sr >> 3);
#line 124
      __cil_tmp42 = c;
#line 124
      c ++;
#line 124
      sr = (uint16_t )*__cil_tmp42;
#line 125
      xmc[48] = (int16_t )((int )sr & 7);
#line 125
      sr = (uint16_t )((int )sr >> 3);
#line 126
      xmc[49] = (int16_t )((int )sr & 7);
#line 126
      sr = (uint16_t )((int )sr >> 3);
#line 127
      __cil_tmp43 = c;
#line 127
      c ++;
#line 127
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp43) << 2));
#line 128
      xmc[50] = (int16_t )((int )sr & 7);
#line 128
      sr = (uint16_t )((int )sr >> 3);
#line 129
      xmc[51] = (int16_t )((int )sr & 7);
#line 129
      sr = (uint16_t )((int )sr >> 3);
#line 131
      s->frame_chain = (unsigned char )((int )sr & 15);
    } else {
#line 134
      sr = (uint16_t )s->frame_chain;
#line 135
      __cil_tmp44 = c;
#line 135
      c ++;
#line 135
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp44) << 4));
#line 136
      LARc[0] = (int16_t )((int )sr & 63);
#line 136
      sr = (uint16_t )((int )sr >> 6);
#line 137
      LARc[1] = (int16_t )((int )sr & 63);
#line 137
      sr = (uint16_t )((int )sr >> 6);
#line 138
      __cil_tmp45 = c;
#line 138
      c ++;
#line 138
      sr = (uint16_t )*__cil_tmp45;
#line 139
      LARc[2] = (int16_t )((int )sr & 31);
#line 139
      sr = (uint16_t )((int )sr >> 5);
#line 140
      __cil_tmp46 = c;
#line 140
      c ++;
#line 140
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp46) << 3));
#line 141
      LARc[3] = (int16_t )((int )sr & 31);
#line 141
      sr = (uint16_t )((int )sr >> 5);
#line 142
      LARc[4] = (int16_t )((int )sr & 15);
#line 142
      sr = (uint16_t )((int )sr >> 4);
#line 143
      __cil_tmp47 = c;
#line 143
      c ++;
#line 143
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp47) << 2));
#line 144
      LARc[5] = (int16_t )((int )sr & 15);
#line 144
      sr = (uint16_t )((int )sr >> 4);
#line 145
      LARc[6] = (int16_t )((int )sr & 7);
#line 145
      sr = (uint16_t )((int )sr >> 3);
#line 146
      LARc[7] = (int16_t )((int )sr & 7);
#line 146
      sr = (uint16_t )((int )sr >> 3);
#line 147
      __cil_tmp48 = c;
#line 147
      c ++;
#line 147
      sr = (uint16_t )*__cil_tmp48;
#line 148
      Nc[0] = (int16_t )((int )sr & 127);
#line 148
      sr = (uint16_t )((int )sr >> 7);
#line 149
      __cil_tmp49 = c;
#line 149
      c ++;
#line 149
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp49) << 1));
#line 150
      bc[0] = (int16_t )((int )sr & 3);
#line 150
      sr = (uint16_t )((int )sr >> 2);
#line 151
      Mc[0] = (int16_t )((int )sr & 3);
#line 151
      sr = (uint16_t )((int )sr >> 2);
#line 152
      __cil_tmp50 = c;
#line 152
      c ++;
#line 152
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp50) << 5));
#line 153
      xmaxc[0] = (int16_t )((int )sr & 63);
#line 153
      sr = (uint16_t )((int )sr >> 6);
#line 154
      xmc[0] = (int16_t )((int )sr & 7);
#line 154
      sr = (uint16_t )((int )sr >> 3);
#line 155
      xmc[1] = (int16_t )((int )sr & 7);
#line 155
      sr = (uint16_t )((int )sr >> 3);
#line 156
      __cil_tmp51 = c;
#line 156
      c ++;
#line 156
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp51) << 1));
#line 157
      xmc[2] = (int16_t )((int )sr & 7);
#line 157
      sr = (uint16_t )((int )sr >> 3);
#line 158
      xmc[3] = (int16_t )((int )sr & 7);
#line 158
      sr = (uint16_t )((int )sr >> 3);
#line 159
      xmc[4] = (int16_t )((int )sr & 7);
#line 159
      sr = (uint16_t )((int )sr >> 3);
#line 160
      __cil_tmp52 = c;
#line 160
      c ++;
#line 160
      sr = (uint16_t )*__cil_tmp52;
#line 161
      xmc[5] = (int16_t )((int )sr & 7);
#line 161
      sr = (uint16_t )((int )sr >> 3);
#line 162
      xmc[6] = (int16_t )((int )sr & 7);
#line 162
      sr = (uint16_t )((int )sr >> 3);
#line 163
      __cil_tmp53 = c;
#line 163
      c ++;
#line 163
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp53) << 2));
#line 164
      xmc[7] = (int16_t )((int )sr & 7);
#line 164
      sr = (uint16_t )((int )sr >> 3);
#line 165
      xmc[8] = (int16_t )((int )sr & 7);
#line 165
      sr = (uint16_t )((int )sr >> 3);
#line 166
      xmc[9] = (int16_t )((int )sr & 7);
#line 166
      sr = (uint16_t )((int )sr >> 3);
#line 167
      __cil_tmp54 = c;
#line 167
      c ++;
#line 167
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp54) << 1));
#line 168
      xmc[10] = (int16_t )((int )sr & 7);
#line 168
      sr = (uint16_t )((int )sr >> 3);
#line 169
      xmc[11] = (int16_t )((int )sr & 7);
#line 169
      sr = (uint16_t )((int )sr >> 3);
#line 170
      xmc[12] = (int16_t )((int )sr & 7);
#line 170
      sr = (uint16_t )((int )sr >> 3);
#line 171
      __cil_tmp55 = c;
#line 171
      c ++;
#line 171
      sr = (uint16_t )*__cil_tmp55;
#line 172
      Nc[1] = (int16_t )((int )sr & 127);
#line 172
      sr = (uint16_t )((int )sr >> 7);
#line 173
      __cil_tmp56 = c;
#line 173
      c ++;
#line 173
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp56) << 1));
#line 174
      bc[1] = (int16_t )((int )sr & 3);
#line 174
      sr = (uint16_t )((int )sr >> 2);
#line 175
      Mc[1] = (int16_t )((int )sr & 3);
#line 175
      sr = (uint16_t )((int )sr >> 2);
#line 176
      __cil_tmp57 = c;
#line 176
      c ++;
#line 176
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp57) << 5));
#line 177
      xmaxc[1] = (int16_t )((int )sr & 63);
#line 177
      sr = (uint16_t )((int )sr >> 6);
#line 178
      xmc[13] = (int16_t )((int )sr & 7);
#line 178
      sr = (uint16_t )((int )sr >> 3);
#line 179
      xmc[14] = (int16_t )((int )sr & 7);
#line 179
      sr = (uint16_t )((int )sr >> 3);
#line 180
      __cil_tmp58 = c;
#line 180
      c ++;
#line 180
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp58) << 1));
#line 181
      xmc[15] = (int16_t )((int )sr & 7);
#line 181
      sr = (uint16_t )((int )sr >> 3);
#line 182
      xmc[16] = (int16_t )((int )sr & 7);
#line 182
      sr = (uint16_t )((int )sr >> 3);
#line 183
      xmc[17] = (int16_t )((int )sr & 7);
#line 183
      sr = (uint16_t )((int )sr >> 3);
#line 184
      __cil_tmp59 = c;
#line 184
      c ++;
#line 184
      sr = (uint16_t )*__cil_tmp59;
#line 185
      xmc[18] = (int16_t )((int )sr & 7);
#line 185
      sr = (uint16_t )((int )sr >> 3);
#line 186
      xmc[19] = (int16_t )((int )sr & 7);
#line 186
      sr = (uint16_t )((int )sr >> 3);
#line 187
      __cil_tmp60 = c;
#line 187
      c ++;
#line 187
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp60) << 2));
#line 188
      xmc[20] = (int16_t )((int )sr & 7);
#line 188
      sr = (uint16_t )((int )sr >> 3);
#line 189
      xmc[21] = (int16_t )((int )sr & 7);
#line 189
      sr = (uint16_t )((int )sr >> 3);
#line 190
      xmc[22] = (int16_t )((int )sr & 7);
#line 190
      sr = (uint16_t )((int )sr >> 3);
#line 191
      __cil_tmp61 = c;
#line 191
      c ++;
#line 191
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp61) << 1));
#line 192
      xmc[23] = (int16_t )((int )sr & 7);
#line 192
      sr = (uint16_t )((int )sr >> 3);
#line 193
      xmc[24] = (int16_t )((int )sr & 7);
#line 193
      sr = (uint16_t )((int )sr >> 3);
#line 194
      xmc[25] = (int16_t )((int )sr & 7);
#line 194
      sr = (uint16_t )((int )sr >> 3);
#line 195
      __cil_tmp62 = c;
#line 195
      c ++;
#line 195
      sr = (uint16_t )*__cil_tmp62;
#line 196
      Nc[2] = (int16_t )((int )sr & 127);
#line 196
      sr = (uint16_t )((int )sr >> 7);
#line 197
      __cil_tmp63 = c;
#line 197
      c ++;
#line 197
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp63) << 1));
#line 198
      bc[2] = (int16_t )((int )sr & 3);
#line 198
      sr = (uint16_t )((int )sr >> 2);
#line 199
      Mc[2] = (int16_t )((int )sr & 3);
#line 199
      sr = (uint16_t )((int )sr >> 2);
#line 200
      __cil_tmp64 = c;
#line 200
      c ++;
#line 200
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp64) << 5));
#line 201
      xmaxc[2] = (int16_t )((int )sr & 63);
#line 201
      sr = (uint16_t )((int )sr >> 6);
#line 202
      xmc[26] = (int16_t )((int )sr & 7);
#line 202
      sr = (uint16_t )((int )sr >> 3);
#line 203
      xmc[27] = (int16_t )((int )sr & 7);
#line 203
      sr = (uint16_t )((int )sr >> 3);
#line 204
      __cil_tmp65 = c;
#line 204
      c ++;
#line 204
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp65) << 1));
#line 205
      xmc[28] = (int16_t )((int )sr & 7);
#line 205
      sr = (uint16_t )((int )sr >> 3);
#line 206
      xmc[29] = (int16_t )((int )sr & 7);
#line 206
      sr = (uint16_t )((int )sr >> 3);
#line 207
      xmc[30] = (int16_t )((int )sr & 7);
#line 207
      sr = (uint16_t )((int )sr >> 3);
#line 208
      __cil_tmp66 = c;
#line 208
      c ++;
#line 208
      sr = (uint16_t )*__cil_tmp66;
#line 209
      xmc[31] = (int16_t )((int )sr & 7);
#line 209
      sr = (uint16_t )((int )sr >> 3);
#line 210
      xmc[32] = (int16_t )((int )sr & 7);
#line 210
      sr = (uint16_t )((int )sr >> 3);
#line 211
      __cil_tmp67 = c;
#line 211
      c ++;
#line 211
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp67) << 2));
#line 212
      xmc[33] = (int16_t )((int )sr & 7);
#line 212
      sr = (uint16_t )((int )sr >> 3);
#line 213
      xmc[34] = (int16_t )((int )sr & 7);
#line 213
      sr = (uint16_t )((int )sr >> 3);
#line 214
      xmc[35] = (int16_t )((int )sr & 7);
#line 214
      sr = (uint16_t )((int )sr >> 3);
#line 215
      __cil_tmp68 = c;
#line 215
      c ++;
#line 215
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp68) << 1));
#line 216
      xmc[36] = (int16_t )((int )sr & 7);
#line 216
      sr = (uint16_t )((int )sr >> 3);
#line 217
      xmc[37] = (int16_t )((int )sr & 7);
#line 217
      sr = (uint16_t )((int )sr >> 3);
#line 218
      xmc[38] = (int16_t )((int )sr & 7);
#line 218
      sr = (uint16_t )((int )sr >> 3);
#line 219
      __cil_tmp69 = c;
#line 219
      c ++;
#line 219
      sr = (uint16_t )*__cil_tmp69;
#line 220
      Nc[3] = (int16_t )((int )sr & 127);
#line 220
      sr = (uint16_t )((int )sr >> 7);
#line 221
      __cil_tmp70 = c;
#line 221
      c ++;
#line 221
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp70) << 1));
#line 222
      bc[3] = (int16_t )((int )sr & 3);
#line 222
      sr = (uint16_t )((int )sr >> 2);
#line 223
      Mc[3] = (int16_t )((int )sr & 3);
#line 223
      sr = (uint16_t )((int )sr >> 2);
#line 224
      __cil_tmp71 = c;
#line 224
      c ++;
#line 224
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp71) << 5));
#line 225
      xmaxc[3] = (int16_t )((int )sr & 63);
#line 225
      sr = (uint16_t )((int )sr >> 6);
#line 226
      xmc[39] = (int16_t )((int )sr & 7);
#line 226
      sr = (uint16_t )((int )sr >> 3);
#line 227
      xmc[40] = (int16_t )((int )sr & 7);
#line 227
      sr = (uint16_t )((int )sr >> 3);
#line 228
      __cil_tmp72 = c;
#line 228
      c ++;
#line 228
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp72) << 1));
#line 229
      xmc[41] = (int16_t )((int )sr & 7);
#line 229
      sr = (uint16_t )((int )sr >> 3);
#line 230
      xmc[42] = (int16_t )((int )sr & 7);
#line 230
      sr = (uint16_t )((int )sr >> 3);
#line 231
      xmc[43] = (int16_t )((int )sr & 7);
#line 231
      sr = (uint16_t )((int )sr >> 3);
#line 232
      __cil_tmp73 = c;
#line 232
      c ++;
#line 232
      sr = (uint16_t )*__cil_tmp73;
#line 233
      xmc[44] = (int16_t )((int )sr & 7);
#line 233
      sr = (uint16_t )((int )sr >> 3);
#line 234
      xmc[45] = (int16_t )((int )sr & 7);
#line 234
      sr = (uint16_t )((int )sr >> 3);
#line 235
      __cil_tmp74 = c;
#line 235
      c ++;
#line 235
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp74) << 2));
#line 236
      xmc[46] = (int16_t )((int )sr & 7);
#line 236
      sr = (uint16_t )((int )sr >> 3);
#line 237
      xmc[47] = (int16_t )((int )sr & 7);
#line 237
      sr = (uint16_t )((int )sr >> 3);
#line 238
      xmc[48] = (int16_t )((int )sr & 7);
#line 238
      sr = (uint16_t )((int )sr >> 3);
#line 239
      __cil_tmp75 = c;
#line 239
      c ++;
#line 239
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp75) << 1));
#line 240
      xmc[49] = (int16_t )((int )sr & 7);
#line 240
      sr = (uint16_t )((int )sr >> 3);
#line 241
      xmc[50] = (int16_t )((int )sr & 7);
#line 241
      sr = (uint16_t )((int )sr >> 3);
#line 242
      xmc[51] = (int16_t )((int )sr & 7);
#line 242
      sr = (uint16_t )((int )sr >> 3);
    }
  } else {
#line 250
    if ((((int )*c >> 4) & 15) != 13) {
#line 250
      return (-1);
    }
#line 252
    __cil_tmp76 = c;
#line 252
    c ++;
#line 252
    LARc[0] = (int16_t )(((int )*__cil_tmp76 & 15) << 2);
#line 253
    LARc[0] = (int16_t )((int )LARc[0] | (((int )*c >> 6) & 3));
#line 254
    __cil_tmp77 = c;
#line 254
    c ++;
#line 254
    LARc[1] = (int16_t )((int )*__cil_tmp77 & 63);
#line 255
    LARc[2] = (int16_t )(((int )*c >> 3) & 31);
#line 256
    __cil_tmp78 = c;
#line 256
    c ++;
#line 256
    LARc[3] = (int16_t )(((int )*__cil_tmp78 & 7) << 2);
#line 257
    LARc[3] = (int16_t )((int )LARc[3] | (((int )*c >> 6) & 3));
#line 258
    LARc[4] = (int16_t )(((int )*c >> 2) & 15);
#line 259
    __cil_tmp79 = c;
#line 259
    c ++;
#line 259
    LARc[5] = (int16_t )(((int )*__cil_tmp79 & 3) << 2);
#line 260
    LARc[5] = (int16_t )((int )LARc[5] | (((int )*c >> 6) & 3));
#line 261
    LARc[6] = (int16_t )(((int )*c >> 3) & 7);
#line 262
    __cil_tmp80 = c;
#line 262
    c ++;
#line 262
    LARc[7] = (int16_t )((int )*__cil_tmp80 & 7);
#line 263
    Nc[0] = (int16_t )(((int )*c >> 1) & 127);
#line 264
    __cil_tmp81 = c;
#line 264
    c ++;
#line 264
    bc[0] = (int16_t )(((int )*__cil_tmp81 & 1) << 1);
#line 265
    bc[0] = (int16_t )((int )bc[0] | (((int )*c >> 7) & 1));
#line 266
    Mc[0] = (int16_t )(((int )*c >> 5) & 3);
#line 267
    __cil_tmp82 = c;
#line 267
    c ++;
#line 267
    xmaxc[0] = (int16_t )(((int )*__cil_tmp82 & 31) << 1);
#line 268
    xmaxc[0] = (int16_t )((int )xmaxc[0] | (((int )*c >> 7) & 1));
#line 269
    xmc[0] = (int16_t )(((int )*c >> 4) & 7);
#line 270
    xmc[1] = (int16_t )(((int )*c >> 1) & 7);
#line 271
    __cil_tmp83 = c;
#line 271
    c ++;
#line 271
    xmc[2] = (int16_t )(((int )*__cil_tmp83 & 1) << 2);
#line 272
    xmc[2] = (int16_t )((int )xmc[2] | (((int )*c >> 6) & 3));
#line 273
    xmc[3] = (int16_t )(((int )*c >> 3) & 7);
#line 274
    __cil_tmp84 = c;
#line 274
    c ++;
#line 274
    xmc[4] = (int16_t )((int )*__cil_tmp84 & 7);
#line 275
    xmc[5] = (int16_t )(((int )*c >> 5) & 7);
#line 276
    xmc[6] = (int16_t )(((int )*c >> 2) & 7);
#line 277
    __cil_tmp85 = c;
#line 277
    c ++;
#line 277
    xmc[7] = (int16_t )(((int )*__cil_tmp85 & 3) << 1);
#line 278
    xmc[7] = (int16_t )((int )xmc[7] | (((int )*c >> 7) & 1));
#line 279
    xmc[8] = (int16_t )(((int )*c >> 4) & 7);
#line 280
    xmc[9] = (int16_t )(((int )*c >> 1) & 7);
#line 281
    __cil_tmp86 = c;
#line 281
    c ++;
#line 281
    xmc[10] = (int16_t )(((int )*__cil_tmp86 & 1) << 2);
#line 282
    xmc[10] = (int16_t )((int )xmc[10] | (((int )*c >> 6) & 3));
#line 283
    xmc[11] = (int16_t )(((int )*c >> 3) & 7);
#line 284
    __cil_tmp87 = c;
#line 284
    c ++;
#line 284
    xmc[12] = (int16_t )((int )*__cil_tmp87 & 7);
#line 285
    Nc[1] = (int16_t )(((int )*c >> 1) & 127);
#line 286
    __cil_tmp88 = c;
#line 286
    c ++;
#line 286
    bc[1] = (int16_t )(((int )*__cil_tmp88 & 1) << 1);
#line 287
    bc[1] = (int16_t )((int )bc[1] | (((int )*c >> 7) & 1));
#line 288
    Mc[1] = (int16_t )(((int )*c >> 5) & 3);
#line 289
    __cil_tmp89 = c;
#line 289
    c ++;
#line 289
    xmaxc[1] = (int16_t )(((int )*__cil_tmp89 & 31) << 1);
#line 290
    xmaxc[1] = (int16_t )((int )xmaxc[1] | (((int )*c >> 7) & 1));
#line 291
    xmc[13] = (int16_t )(((int )*c >> 4) & 7);
#line 292
    xmc[14] = (int16_t )(((int )*c >> 1) & 7);
#line 293
    __cil_tmp90 = c;
#line 293
    c ++;
#line 293
    xmc[15] = (int16_t )(((int )*__cil_tmp90 & 1) << 2);
#line 294
    xmc[15] = (int16_t )((int )xmc[15] | (((int )*c >> 6) & 3));
#line 295
    xmc[16] = (int16_t )(((int )*c >> 3) & 7);
#line 296
    __cil_tmp91 = c;
#line 296
    c ++;
#line 296
    xmc[17] = (int16_t )((int )*__cil_tmp91 & 7);
#line 297
    xmc[18] = (int16_t )(((int )*c >> 5) & 7);
#line 298
    xmc[19] = (int16_t )(((int )*c >> 2) & 7);
#line 299
    __cil_tmp92 = c;
#line 299
    c ++;
#line 299
    xmc[20] = (int16_t )(((int )*__cil_tmp92 & 3) << 1);
#line 300
    xmc[20] = (int16_t )((int )xmc[20] | (((int )*c >> 7) & 1));
#line 301
    xmc[21] = (int16_t )(((int )*c >> 4) & 7);
#line 302
    xmc[22] = (int16_t )(((int )*c >> 1) & 7);
#line 303
    __cil_tmp93 = c;
#line 303
    c ++;
#line 303
    xmc[23] = (int16_t )(((int )*__cil_tmp93 & 1) << 2);
#line 304
    xmc[23] = (int16_t )((int )xmc[23] | (((int )*c >> 6) & 3));
#line 305
    xmc[24] = (int16_t )(((int )*c >> 3) & 7);
#line 306
    __cil_tmp94 = c;
#line 306
    c ++;
#line 306
    xmc[25] = (int16_t )((int )*__cil_tmp94 & 7);
#line 307
    Nc[2] = (int16_t )(((int )*c >> 1) & 127);
#line 308
    __cil_tmp95 = c;
#line 308
    c ++;
#line 308
    bc[2] = (int16_t )(((int )*__cil_tmp95 & 1) << 1);
#line 309
    bc[2] = (int16_t )((int )bc[2] | (((int )*c >> 7) & 1));
#line 310
    Mc[2] = (int16_t )(((int )*c >> 5) & 3);
#line 311
    __cil_tmp96 = c;
#line 311
    c ++;
#line 311
    xmaxc[2] = (int16_t )(((int )*__cil_tmp96 & 31) << 1);
#line 312
    xmaxc[2] = (int16_t )((int )xmaxc[2] | (((int )*c >> 7) & 1));
#line 313
    xmc[26] = (int16_t )(((int )*c >> 4) & 7);
#line 314
    xmc[27] = (int16_t )(((int )*c >> 1) & 7);
#line 315
    __cil_tmp97 = c;
#line 315
    c ++;
#line 315
    xmc[28] = (int16_t )(((int )*__cil_tmp97 & 1) << 2);
#line 316
    xmc[28] = (int16_t )((int )xmc[28] | (((int )*c >> 6) & 3));
#line 317
    xmc[29] = (int16_t )(((int )*c >> 3) & 7);
#line 318
    __cil_tmp98 = c;
#line 318
    c ++;
#line 318
    xmc[30] = (int16_t )((int )*__cil_tmp98 & 7);
#line 319
    xmc[31] = (int16_t )(((int )*c >> 5) & 7);
#line 320
    xmc[32] = (int16_t )(((int )*c >> 2) & 7);
#line 321
    __cil_tmp99 = c;
#line 321
    c ++;
#line 321
    xmc[33] = (int16_t )(((int )*__cil_tmp99 & 3) << 1);
#line 322
    xmc[33] = (int16_t )((int )xmc[33] | (((int )*c >> 7) & 1));
#line 323
    xmc[34] = (int16_t )(((int )*c >> 4) & 7);
#line 324
    xmc[35] = (int16_t )(((int )*c >> 1) & 7);
#line 325
    __cil_tmp100 = c;
#line 325
    c ++;
#line 325
    xmc[36] = (int16_t )(((int )*__cil_tmp100 & 1) << 2);
#line 326
    xmc[36] = (int16_t )((int )xmc[36] | (((int )*c >> 6) & 3));
#line 327
    xmc[37] = (int16_t )(((int )*c >> 3) & 7);
#line 328
    __cil_tmp101 = c;
#line 328
    c ++;
#line 328
    xmc[38] = (int16_t )((int )*__cil_tmp101 & 7);
#line 329
    Nc[3] = (int16_t )(((int )*c >> 1) & 127);
#line 330
    __cil_tmp102 = c;
#line 330
    c ++;
#line 330
    bc[3] = (int16_t )(((int )*__cil_tmp102 & 1) << 1);
#line 331
    bc[3] = (int16_t )((int )bc[3] | (((int )*c >> 7) & 1));
#line 332
    Mc[3] = (int16_t )(((int )*c >> 5) & 3);
#line 333
    __cil_tmp103 = c;
#line 333
    c ++;
#line 333
    xmaxc[3] = (int16_t )(((int )*__cil_tmp103 & 31) << 1);
#line 334
    xmaxc[3] = (int16_t )((int )xmaxc[3] | (((int )*c >> 7) & 1));
#line 335
    xmc[39] = (int16_t )(((int )*c >> 4) & 7);
#line 336
    xmc[40] = (int16_t )(((int )*c >> 1) & 7);
#line 337
    __cil_tmp104 = c;
#line 337
    c ++;
#line 337
    xmc[41] = (int16_t )(((int )*__cil_tmp104 & 1) << 2);
#line 338
    xmc[41] = (int16_t )((int )xmc[41] | (((int )*c >> 6) & 3));
#line 339
    xmc[42] = (int16_t )(((int )*c >> 3) & 7);
#line 340
    __cil_tmp105 = c;
#line 340
    c ++;
#line 340
    xmc[43] = (int16_t )((int )*__cil_tmp105 & 7);
#line 341
    xmc[44] = (int16_t )(((int )*c >> 5) & 7);
#line 342
    xmc[45] = (int16_t )(((int )*c >> 2) & 7);
#line 343
    __cil_tmp106 = c;
#line 343
    c ++;
#line 343
    xmc[46] = (int16_t )(((int )*__cil_tmp106 & 3) << 1);
#line 344
    xmc[46] = (int16_t )((int )xmc[46] | (((int )*c >> 7) & 1));
#line 345
    xmc[47] = (int16_t )(((int )*c >> 4) & 7);
#line 346
    xmc[48] = (int16_t )(((int )*c >> 1) & 7);
#line 347
    __cil_tmp107 = c;
#line 347
    c ++;
#line 347
    xmc[49] = (int16_t )(((int )*__cil_tmp107 & 1) << 2);
#line 348
    xmc[49] = (int16_t )((int )xmc[49] | (((int )*c >> 6) & 3));
#line 349
    xmc[50] = (int16_t )(((int )*c >> 3) & 7);
#line 350
    xmc[51] = (int16_t )((int )*c & 7);
  }
  {
#line 353
  Gsm_Decoder(s, LARc, Nc, bc, Mc, xmaxc, xmc, target);
  }
#line 355
  return (0);
}
}
#line 18 "/root/patchweave_new/23/src/GSM610/gsm_create.c"
gsm gsm_create(void) 
{ 
  gsm r ;
  void *tmp ;

  {
  {
#line 22
  tmp = malloc(sizeof(struct gsm_state ));
#line 22
  r = (gsm )tmp;
  }
#line 23
  if (! r) {
#line 23
    return (r);
  }
  {
#line 25
  memset((void *)((char *)r), 0, sizeof(struct gsm_state ));
#line 26
  r->nrp = (int16_t )40;
  }
#line 28
  return (r);
}
}
#line 32 "/root/patchweave_new/23/src/GSM610/gsm_create.c"
void gsm_init(gsm state ) 
{ 


  {
  {
#line 34
  memset((void *)state, 0, sizeof(struct gsm_state ));
#line 35
  state->nrp = (int16_t )40;
  }
#line 37
  return;
}
}
#line 15 "/root/patchweave_new/23/src/GSM610/decode.c"
static void Postprocessing(struct gsm_state *S , int16_t *s ) 
{ 
  register int k ;
  register int16_t msr ;
  register int16_t tmp ;
  int __cil_tmp6 ;
  int32_t __cil_tmp7 ;
  int32_t __cil_tmp8 ;
  int32_t __cil_tmp9 ;

  {
#line 20
  msr = S->msr;
#line 23
  k = 160;
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;

#line 23
    if (! __cil_tmp6) {
#line 23
      goto while_break;
    }
    {
#line 24
    __cil_tmp7 = GSM_MULT_R(msr, (int16_t )28180);
#line 24
    tmp = (int16_t )__cil_tmp7;
#line 25
    __cil_tmp8 = GSM_ADD(*s, tmp);
#line 25
    msr = (int16_t )__cil_tmp8;
#line 26
    __cil_tmp9 = GSM_ADD(msr, msr);
#line 26
    *s = (int16_t )(__cil_tmp9 & 65528);
#line 23
    s ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 28
  S->msr = msr;
#line 29
  return;
}
}
#line 31 "/root/patchweave_new/23/src/GSM610/decode.c"
void Gsm_Decoder(struct gsm_state *S , int16_t *LARcr , int16_t *Ncr , int16_t *bcr ,
                 int16_t *Mcr , int16_t *xmaxcr , int16_t *xMcr , int16_t *s ) 
{ 
  int j ;
  int k ;
  int16_t erp[40] ;
  int16_t wt[160] ;
  int16_t *drp ;
  int __cil_tmp15 ;
  int16_t *__cil_tmp16 ;
  int16_t *__cil_tmp17 ;
  int16_t *__cil_tmp18 ;
  int16_t *__cil_tmp19 ;

  {
#line 46
  drp = S->dp0 + 120;
#line 48
  j = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;

#line 48
    if (! (j <= 3)) {
#line 48
      goto while_break;
    }
    {
#line 49
    Gsm_RPE_Decoding(*xmaxcr, *Mcr, xMcr, erp);
#line 50
    Gsm_Long_Term_Synthesis_Filtering(S, *Ncr, *bcr, erp, drp);
#line 52
    k = 0;
    }
    {
#line 52
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 52
      if (! (k <= 39)) {
#line 52
        goto while_break___0;
      }
#line 52
      wt[j * 40 + k] = *(drp + k);
#line 52
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 48
    xMcr += 13;
#line 48
    __cil_tmp19 = Mcr;
#line 48
    Mcr ++;
#line 48
    __cil_tmp18 = Ncr;
#line 48
    Ncr ++;
#line 48
    __cil_tmp17 = bcr;
#line 48
    bcr ++;
#line 48
    __cil_tmp16 = xmaxcr;
#line 48
    xmaxcr ++;
#line 48
    __cil_tmp15 = j;
#line 48
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 55
  Gsm_Short_Term_Synthesis_Filter(S, LARcr, wt, s);
#line 56
  Postprocessing(S, s);
  }
#line 58
  return;
}
}
#line 17 "/root/patchweave_new/23/src/GSM610/code.c"
void Gsm_Coder(struct gsm_state *State , int16_t *s , int16_t *LARc , int16_t *Nc ,
               int16_t *bc , int16_t *Mc , int16_t *xmaxc , int16_t *xMc ) 
{ 
  int k ;
  int16_t *dp ;
  int16_t *dpp ;
  int16_t so[160] ;
  int16_t *__cil_tmp13 ;
  int16_t *__cil_tmp14 ;
  int16_t *__cil_tmp15 ;
  int16_t *__cil_tmp16 ;
  register int i ;
  int32_t __cil_tmp18 ;
  int __cil_tmp20 ;

  {
  {
#line 49
  dp = State->dp0 + 120;
#line 50
  dpp = dp;
#line 54
  Gsm_Preprocess(State, s, so);
#line 55
  Gsm_LPC_Analysis(State, so, LARc);
#line 56
  Gsm_Short_Term_Analysis_Filter(State, LARc, so);
#line 58
  k = 0;
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;

#line 58
    if (! (k <= 3)) {
#line 58
      goto while_break;
    }
    {
#line 59
    __cil_tmp13 = Nc;
#line 59
    Nc ++;
#line 59
    __cil_tmp14 = bc;
#line 59
    bc ++;
#line 59
    Gsm_Long_Term_Predictor(State, so + k * 40, dp, State->e + 5, dpp, __cil_tmp13,
                            __cil_tmp14);
#line 67
    __cil_tmp15 = xmaxc;
#line 67
    xmaxc ++;
#line 67
    __cil_tmp16 = Mc;
#line 67
    Mc ++;
#line 67
    Gsm_RPE_Encoding(State->e + 5, __cil_tmp15, __cil_tmp16, xMc);
#line 77
    i = 0;
    }
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 77
      if (! (i <= 39)) {
#line 77
        goto while_break___0;
      }
      {
#line 78
      __cil_tmp18 = GSM_ADD(State->e[5 + i], *(dpp + i));
#line 78
      *(dp + i) = (int16_t )__cil_tmp18;
#line 77
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 80
    dp += 40;
#line 81
    dpp += 40;
#line 58
    xMc += 13;
#line 58
    __cil_tmp20 = k;
#line 58
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 84
  memcpy((void *)((char *)(State->dp0)), (void const   *)((char *)(State->dp0 + 160)),
         120UL * sizeof(State->dp0[0]));
  }
#line 86
  return;
}
}
#line 19 "/root/patchweave_new/23/src/GSM610/add.c"
int16_t gsm_add(int16_t a , int16_t b ) 
{ 
  int32_t sum ;
  int tmp ;
  int tmp___0 ;

  {
#line 21
  sum = (int32_t )a + (int32_t )b;
#line 22
  if (sum < -32768) {
#line 22
    tmp___0 = -32768;
  } else {
#line 22
    if (sum > 32767) {
#line 22
      tmp = 32767;
    } else {
#line 22
      tmp = sum;
    }
#line 22
    tmp___0 = tmp;
  }
#line 22
  return ((int16_t )tmp___0);
}
}
#line 25 "/root/patchweave_new/23/src/GSM610/add.c"
int16_t gsm_sub(int16_t a , int16_t b ) 
{ 
  int32_t diff ;
  int tmp ;
  int tmp___0 ;

  {
#line 27
  diff = (int32_t )a - (int32_t )b;
#line 28
  if (diff < -32768) {
#line 28
    tmp___0 = -32768;
  } else {
#line 28
    if (diff > 32767) {
#line 28
      tmp = 32767;
    } else {
#line 28
      tmp = diff;
    }
#line 28
    tmp___0 = tmp;
  }
#line 28
  return ((int16_t )tmp___0);
}
}
#line 31 "/root/patchweave_new/23/src/GSM610/add.c"
int16_t gsm_mult(int16_t a , int16_t b ) 
{ 
  int32_t __cil_tmp3 ;

  {
#line 33
  if ((int )a == -32768) {
#line 33
    if ((int )b == -32768) {
#line 34
      return ((int16_t )32767);
    }
  }
  {
#line 36
  __cil_tmp3 = SASR_L((int32_t )a * (int32_t )b, (int16_t )15);
  }
#line 36
  return ((int16_t )__cil_tmp3);
}
}
#line 39 "/root/patchweave_new/23/src/GSM610/add.c"
int16_t gsm_mult_r(int16_t a , int16_t b ) 
{ 
  int32_t prod ;

  {
#line 41
  if ((int )b == -32768) {
#line 41
    if ((int )a == -32768) {
#line 42
      return ((int16_t )32767);
    } else {
#line 44
      prod = (int32_t )a * (int32_t )b + 16384;
#line 45
      prod >>= 15;
#line 46
      return ((int16_t )(prod & 65535));
    }
  } else {
#line 44
    prod = (int32_t )a * (int32_t )b + 16384;
#line 45
    prod >>= 15;
#line 46
    return ((int16_t )(prod & 65535));
  }
}
}
#line 50 "/root/patchweave_new/23/src/GSM610/add.c"
int16_t gsm_abs(int16_t a ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 52
  if ((int )a < 0) {
#line 52
    if ((int )a == -32768) {
#line 52
      tmp = 32767;
    } else {
#line 52
      tmp = - ((int )a);
    }
#line 52
    tmp___0 = tmp;
  } else {
#line 52
    tmp___0 = (int )a;
  }
#line 52
  return ((int16_t )tmp___0);
}
}
#line 55 "/root/patchweave_new/23/src/GSM610/add.c"
int32_t gsm_L_mult(int16_t a , int16_t b ) 
{ 


  {
#line 58
  return ((int32_t )a * (int32_t )b << 1);
}
}
#line 61 "/root/patchweave_new/23/src/GSM610/add.c"
int32_t gsm_L_add(int32_t a , int32_t b ) 
{ 
  uint32_t A ;
  int tmp ;
  uint32_t A___0 ;
  unsigned int tmp___0 ;

  {
#line 63
  if (a < 0) {
#line 64
    if (b >= 0) {
#line 65
      return (a + b);
    } else {
#line 67
      A = (uint32_t )(- (a + 1)) + (uint32_t )(- (b + 1));
#line 68
      if (A >= 2147483647U) {
#line 68
        tmp = (-0x7FFFFFFF-1);
      } else {
#line 68
        tmp = - ((int32_t )A) - 2;
      }
#line 68
      return (tmp);
    }
  } else
#line 71
  if (b <= 0) {
#line 72
    return (a + b);
  } else {
#line 74
    A___0 = (uint32_t )a + (uint32_t )b;
#line 75
    if (A___0 > 2147483647U) {
#line 75
      tmp___0 = 2147483647U;
    } else {
#line 75
      tmp___0 = A___0;
    }
#line 75
    return ((int32_t )tmp___0);
  }
}
}
#line 79 "/root/patchweave_new/23/src/GSM610/add.c"
int32_t gsm_L_sub(int32_t a , int32_t b ) 
{ 
  uint32_t A ;
  unsigned int tmp ;
  uint32_t A___0 ;
  int tmp___0 ;

  {
#line 81
  if (a >= 0) {
#line 82
    if (b >= 0) {
#line 83
      return (a - b);
    } else {
#line 86
      A = (uint32_t )a + (unsigned int )(- (b + 1));
#line 87
      if (A >= 2147483647U) {
#line 87
        tmp = 2147483647U;
      } else {
#line 87
        tmp = A + 1U;
      }
#line 87
      return ((int32_t )tmp);
    }
  } else
#line 90
  if (b <= 0) {
#line 91
    return (a - b);
  } else {
#line 94
    A___0 = (uint32_t )(- (a + 1)) + (unsigned int )b;
#line 95
    if (A___0 >= 2147483647U) {
#line 95
      tmp___0 = (-0x7FFFFFFF-1);
    } else {
#line 95
      tmp___0 = - ((int32_t )A___0) - 1;
    }
#line 95
    return (tmp___0);
  }
}
}
#line 99 "/root/patchweave_new/23/src/GSM610/add.c"
static unsigned char const   bitoff[256]  = 
#line 99
  {      (unsigned char const   )(unsigned char)8,      (unsigned char const   )(unsigned char)7,      (unsigned char const   )(unsigned char)6,      (unsigned char const   )(unsigned char)6, 
        (unsigned char const   )(unsigned char)5,      (unsigned char const   )(unsigned char)5,      (unsigned char const   )(unsigned char)5,      (unsigned char const   )(unsigned char)5, 
        (unsigned char const   )(unsigned char)4,      (unsigned char const   )(unsigned char)4,      (unsigned char const   )(unsigned char)4,      (unsigned char const   )(unsigned char)4, 
        (unsigned char const   )(unsigned char)4,      (unsigned char const   )(unsigned char)4,      (unsigned char const   )(unsigned char)4,      (unsigned char const   )(unsigned char)4, 
        (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3, 
        (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3, 
        (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3, 
        (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0};
#line 118 "/root/patchweave_new/23/src/GSM610/add.c"
int16_t gsm_norm(int32_t a ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 140
  if (a < 0) {
#line 141
    if (a <= -1073741824) {
#line 141
      return ((int16_t )0);
    }
#line 142
    a = ~ a;
  }
#line 145
  if ((unsigned int )a & 4294901760U) {
#line 145
    if ((unsigned int )a & 4278190080U) {
#line 145
      tmp___0 = -1 + (int )bitoff[255 & (a >> 24)];
    } else {
#line 145
      tmp___0 = 7 + (int )bitoff[255 & (a >> 16)];
    }
#line 145
    tmp___2 = tmp___0;
  } else {
#line 145
    if (a & 65280) {
#line 145
      tmp___1 = 15 + (int )bitoff[255 & (a >> 8)];
    } else {
#line 145
      tmp___1 = 23 + (int )bitoff[255 & a];
    }
#line 145
    tmp___2 = tmp___1;
  }
#line 145
  return ((int16_t )tmp___2);
}
}
#line 154 "/root/patchweave_new/23/src/GSM610/add.c"
int32_t gsm_L_asl(int32_t a , int n ) 
{ 
  int32_t __cil_tmp3 ;

  {
#line 156
  if (n >= 32) {
#line 156
    return (0);
  }
#line 157
  if (n <= -32) {
#line 157
    return (- (a < 0));
  }
#line 158
  if (n < 0) {
    {
#line 158
    __cil_tmp3 = gsm_L_asr(a, - n);
    }
#line 158
    return (__cil_tmp3);
  }
#line 159
  return (a << n);
}
}
#line 162 "/root/patchweave_new/23/src/GSM610/add.c"
int16_t gsm_asr(int16_t a , int n ) 
{ 
  int16_t __cil_tmp3 ;

  {
#line 164
  if (n >= 16) {
#line 164
    return ((int16_t )(- ((int )a < 0)));
  }
#line 165
  if (n <= -16) {
#line 165
    return ((int16_t )0);
  }
#line 166
  if (n < 0) {
#line 166
    return ((int16_t )((int )a << - n));
  }
  {
#line 168
  __cil_tmp3 = SASR_W(a, (int16_t )n);
  }
#line 168
  return (__cil_tmp3);
}
}
#line 171 "/root/patchweave_new/23/src/GSM610/add.c"
int16_t gsm_asl(int16_t a , int n ) 
{ 
  int16_t __cil_tmp3 ;

  {
#line 173
  if (n >= 16) {
#line 173
    return ((int16_t )0);
  }
#line 174
  if (n <= -16) {
#line 174
    return ((int16_t )(- ((int )a < 0)));
  }
#line 175
  if (n < 0) {
    {
#line 175
    __cil_tmp3 = gsm_asr(a, - n);
    }
#line 175
    return (__cil_tmp3);
  }
#line 176
  return ((int16_t )((int )a << n));
}
}
#line 179 "/root/patchweave_new/23/src/GSM610/add.c"
int32_t gsm_L_asr(int32_t a , int n ) 
{ 
  int32_t __cil_tmp3 ;

  {
#line 181
  if (n >= 32) {
#line 181
    return (- (a < 0));
  }
#line 182
  if (n <= -32) {
#line 182
    return (0);
  }
#line 183
  if (n < 0) {
#line 183
    return (a << - n);
  }
  {
#line 185
  __cil_tmp3 = SASR_L(a, (int16_t )n);
  }
#line 185
  return (__cil_tmp3);
}
}
#line 213 "/root/patchweave_new/23/src/GSM610/add.c"
int16_t gsm_div(int16_t num , int16_t denum ) 
{ 
  int32_t L_num ;
  int32_t L_denum ;
  int16_t div___0 ;
  int k ;
  int __cil_tmp8 ;

  {
#line 215
  L_num = (int32_t )num;
#line 216
  L_denum = (int32_t )denum;
#line 217
  div___0 = (int16_t )0;
#line 218
  k = 15;
#line 228
  if ((int )num == 0) {
#line 229
    return ((int16_t )0);
  }
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    __cil_tmp8 = k;
#line 231
    k --;
#line 231
    if (! __cil_tmp8) {
#line 231
      goto while_break;
    }
#line 232
    div___0 = (int16_t )((int )div___0 << 1);
#line 233
    L_num <<= 1;
#line 235
    if (L_num >= L_denum) {
#line 236
      L_num -= L_denum;
#line 237
      div___0 = (int16_t )((int )div___0 + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 241
  return (div___0);
}
}
#line 143 "/root/patchweave_new/23/src/ogg_opus.c"
int ogg_opus_open(SF_PRIVATE *psf ) 
{ 


  {
  {
#line 145
  psf_log_printf(psf, "This version of libsndfile was compiled without Ogg/Opus support.\n");
  }
#line 146
  return (18);
}
}
#line 158 "/root/patchweave_new/23/src/ogg_pcm.c"
int ogg_pcm_open(SF_PRIVATE *psf ) 
{ 


  {
  {
#line 160
  psf_log_printf(psf, "This version of libsndfile was compiled without Ogg/Speex support.\n");
  }
#line 161
  return (18);
}
}
#line 419 "/root/patchweave_new/23/src/ogg_speex.c"
int ogg_speex_open(SF_PRIVATE *psf ) 
{ 


  {
  {
#line 421
  psf_log_printf(psf, "This version of libsndfile was compiled without Ogg/Speex support.\n");
  }
#line 422
  return (18);
}
}
#line 164 "/usr/include/vorbis/codec.h"
extern void vorbis_info_init(vorbis_info *vi ) ;
#line 165
extern void vorbis_info_clear(vorbis_info *vi ) ;
#line 167
extern void vorbis_comment_init(vorbis_comment *vc ) ;
#line 169
extern void vorbis_comment_add_tag(vorbis_comment *vc , char const   *tag , char const   *contents ) ;
#line 171
extern char *vorbis_comment_query(vorbis_comment *vc , char const   *tag , int count ) ;
#line 173
extern void vorbis_comment_clear(vorbis_comment *vc ) ;
#line 175
extern int vorbis_block_init(vorbis_dsp_state *v , vorbis_block *vb ) ;
#line 176
extern int vorbis_block_clear(vorbis_block *vb ) ;
#line 177
extern void vorbis_dsp_clear(vorbis_dsp_state *v ) ;
#line 181
extern char const   *vorbis_version_string(void) ;
#line 185
extern int vorbis_analysis_init(vorbis_dsp_state *v , vorbis_info *vi ) ;
#line 187
extern int vorbis_analysis_headerout(vorbis_dsp_state *v , vorbis_comment *vc , ogg_packet *op ,
                                     ogg_packet *op_comm , ogg_packet *op_code ) ;
#line 192
extern float **vorbis_analysis_buffer(vorbis_dsp_state *v , int vals ) ;
#line 193
extern int vorbis_analysis_wrote(vorbis_dsp_state *v , int vals ) ;
#line 194
extern int vorbis_analysis_blockout(vorbis_dsp_state *v , vorbis_block *vb ) ;
#line 195
extern int vorbis_analysis(vorbis_block *vb , ogg_packet *op ) ;
#line 197
extern int vorbis_bitrate_addblock(vorbis_block *vb ) ;
#line 198
extern int vorbis_bitrate_flushpacket(vorbis_dsp_state *vd , ogg_packet *op ) ;
#line 203
extern int vorbis_synthesis_headerin(vorbis_info *vi , vorbis_comment *vc , ogg_packet *op ) ;
#line 206
extern int vorbis_synthesis_init(vorbis_dsp_state *v , vorbis_info *vi ) ;
#line 208
extern int vorbis_synthesis(vorbis_block *vb , ogg_packet *op ) ;
#line 210
extern int vorbis_synthesis_blockin(vorbis_dsp_state *v , vorbis_block *vb ) ;
#line 211
extern int vorbis_synthesis_pcmout(vorbis_dsp_state *v , float ***pcm ) ;
#line 213
extern int vorbis_synthesis_read(vorbis_dsp_state *v , int samples ) ;
#line 157 "/usr/include/vorbis/vorbisenc.h"
extern int vorbis_encode_init_vbr(vorbis_info *vi , long channels , long rate , float base_quality ) ;
#line 81 "/root/patchweave_new/23/src/ogg_vorbis.c"
static int vorbis_read_header(SF_PRIVATE *psf , int log_data ) ;
#line 82
static int vorbis_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 83
static int vorbis_close(SF_PRIVATE *psf ) ;
#line 84
static int vorbis_command(SF_PRIVATE *psf , int command , void *data , int datasize ) ;
#line 85
static int vorbis_byterate(SF_PRIVATE *psf ) ;
#line 86
static sf_count_t vorbis_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) ;
#line 87
static sf_count_t vorbis_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t lens ) ;
#line 88
static sf_count_t vorbis_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t lens ) ;
#line 89
static sf_count_t vorbis_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t lens ) ;
#line 90
static sf_count_t vorbis_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t lens ) ;
#line 91
static sf_count_t vorbis_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t lens ) ;
#line 92
static sf_count_t vorbis_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t lens ) ;
#line 93
static sf_count_t vorbis_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t lens ) ;
#line 94
static sf_count_t vorbis_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t lens ) ;
#line 95
static sf_count_t vorbis_read_sample(SF_PRIVATE *psf , void *ptr , sf_count_t lens ,
                                     convert_func *transfn ) ;
#line 96
static sf_count_t vorbis_length(SF_PRIVATE *psf ) ;
#line 103 "/root/patchweave_new/23/src/ogg_vorbis.c"
static STR_PAIRS vorbis_metatypes[10]  = 
#line 103
  {      {1, "Title"}, 
        {2, "Copyright"}, 
        {3, "Software\250"}, 
        {4, "Artist"}, 
        {5, "Comment"}, 
        {6, "Date"}, 
        {7, "Album"}, 
        {8, "License"}, 
        {9, "Tracknumber"}, 
        {16, "Genre"}};
#line 133 "/root/patchweave_new/23/src/ogg_vorbis.c"
static int vorbis_read_header(SF_PRIVATE *psf , int log_data ) 
{ 
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  char *buffer ;
  int bytes ;
  int i ;
  int nn ;
  sf_count_t __cil_tmp10 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int k ;
  char *dd ;
  int result ;
  int __cil_tmp21 ;
  sf_count_t __cil_tmp23 ;
  int printed_metadata_msg ;
  int k___0 ;
  char *dd___0 ;

  {
  {
#line 135
  odata = (OGG_PRIVATE *)psf->container_data;
#line 136
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 141
  odata->eos = 0;
#line 144
  ogg_stream_reset(& odata->ostream);
#line 145
  ogg_sync_reset(& odata->osync);
#line 155
  buffer = ogg_sync_buffer(& odata->osync, 4096L);
#line 158
  memcpy((void *)buffer, (void const   *)psf->header.ptr, (unsigned long )psf->header.indx);
#line 159
  bytes = (int )psf->header.indx;
#line 162
  __cil_tmp10 = psf_fread((void *)(buffer + psf->header.indx), (sf_count_t )1, 4096L - psf->header.indx,
                          psf);
#line 162
  bytes = (int )((sf_count_t )bytes + __cil_tmp10);
#line 163
  ogg_sync_wrote(& odata->osync, (long )bytes);
#line 166
  nn = ogg_sync_pageout(& odata->osync, & odata->opage);
  }
#line 166
  if (nn != 1) {
#line 169
    if (bytes < 4096) {
#line 170
      return (0);
    }
    {
#line 173
    psf_log_printf(psf, "Input does not appear to be an Ogg bitstream.\n");
    }
#line 174
    return (3);
  }
  {
#line 181
  ogg_stream_clear(& odata->ostream);
#line 182
  __cil_tmp12 = ogg_page_serialno(& odata->opage);
#line 182
  ogg_stream_init(& odata->ostream, __cil_tmp12);
#line 184
  __cil_tmp13 = ogg_stream_pagein(& odata->ostream, & odata->opage);
  }
#line 184
  if (__cil_tmp13 < 0) {
    {
#line 186
    psf_log_printf(psf, "Error reading first page of Ogg bitstream data\n");
    }
#line 187
    return (3);
  }
  {
#line 190
  __cil_tmp14 = ogg_stream_packetout(& odata->ostream, & odata->opacket);
  }
#line 190
  if (__cil_tmp14 != 1) {
    {
#line 192
    psf_log_printf(psf, "Error reading initial header packet.\n");
    }
#line 193
    return (3);
  }
  {
#line 201
  vorbis_block_clear(& vdata->vblock);
#line 202
  vorbis_dsp_clear(& vdata->vdsp);
#line 203
  vorbis_comment_clear(& vdata->vcomment);
#line 204
  vorbis_info_clear(& vdata->vinfo);
#line 215
  vorbis_info_init(& vdata->vinfo);
#line 216
  vorbis_comment_init(& vdata->vcomment);
#line 218
  __cil_tmp15 = vorbis_synthesis_headerin(& vdata->vinfo, & vdata->vcomment, & odata->opacket);
  }
#line 218
  if (__cil_tmp15 < 0) {
    {
#line 220
    psf_log_printf(psf, "Found Vorbis in stream header, but vorbis_synthesis_headerin failed.\n");
    }
#line 221
    return (3);
  }
#line 230
  if (log_data) {
#line 233
    k = 0;
    {
#line 233
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: ;
#line 233
      if (! (k < (int )(sizeof(vorbis_metatypes) / sizeof(vorbis_metatypes[0])))) {
#line 233
        goto while_break;
      }
      {
#line 236
      dd = vorbis_comment_query(& vdata->vcomment, vorbis_metatypes[k].name, 0);
      }
#line 237
      if ((unsigned long )dd == (unsigned long )((void *)0)) {
#line 238
        goto while_continue;
      }
      {
#line 239
      psf_store_string(psf, vorbis_metatypes[k].id, (char const   *)dd);
#line 233
      k ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 255
  i = 0;
  {
#line 256
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 256
    if (! (i < 2)) {
#line 256
      goto while_break___0;
    }
    {
#line 257
    __cil_tmp21 = ogg_sync_pageout(& odata->osync, & odata->opage);
#line 257
    result = __cil_tmp21;
    }
#line 258
    if (result == 0) {
      {
#line 260
      buffer = ogg_sync_buffer(& odata->osync, 4096L);
#line 261
      __cil_tmp23 = psf_fread((void *)buffer, (sf_count_t )1, (sf_count_t )4096, psf);
#line 261
      bytes = (int )__cil_tmp23;
      }
#line 263
      if (bytes == 0) {
#line 263
        if (i < 2) {
          {
#line 264
          psf_log_printf(psf, "End of file before finding all Vorbis headers!\n");
          }
#line 265
          return (3);
        }
      }
      {
#line 267
      nn = ogg_sync_wrote(& odata->osync, (long )bytes);
      }
    } else
#line 269
    if (result == 1) {
      {
#line 277
      nn = ogg_stream_pagein(& odata->ostream, & odata->opage);
      }
      {
#line 278
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 278
        if (! (i < 2)) {
#line 278
          goto while_break___1;
        }
        {
#line 279
        result = ogg_stream_packetout(& odata->ostream, & odata->opacket);
        }
#line 280
        if (result == 0) {
#line 281
          goto while_break___1;
        }
#line 282
        if (result < 0) {
          {
#line 285
          psf_log_printf(psf, "Corrupt secondary header.\tExiting.\n");
          }
#line 286
          return (3);
        }
        {
#line 289
        vorbis_synthesis_headerin(& vdata->vinfo, & vdata->vcomment, & odata->opacket);
#line 290
        i ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: ;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: ;
#line 295
  if (log_data) {
    {
#line 296
    printed_metadata_msg = 0;
#line 299
    psf_log_printf(psf, "Bitstream is %d channel, %D Hz\n", vdata->vinfo.channels,
                   vdata->vinfo.rate);
#line 300
    psf_log_printf(psf, "Encoded by : %s\n\230\001", vdata->vcomment.vendor);
#line 303
    k___0 = 0;
    }
    {
#line 303
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: ;
#line 303
      if (! (k___0 < (int )(sizeof(vorbis_metatypes) / sizeof(vorbis_metatypes[0])))) {
#line 303
        goto while_break___2;
      }
      {
#line 306
      dd___0 = vorbis_comment_query(& vdata->vcomment, vorbis_metatypes[k___0].name,
                                    0);
      }
#line 307
      if ((unsigned long )dd___0 == (unsigned long )((void *)0)) {
#line 308
        goto while_continue___2;
      }
#line 310
      if (printed_metadata_msg == 0) {
        {
#line 311
        psf_log_printf(psf, "Metadata :\n");
#line 312
        printed_metadata_msg = 1;
        }
      }
      {
#line 315
      psf_store_string(psf, vorbis_metatypes[k___0].id, (char const   *)dd___0);
#line 316
      psf_log_printf(psf, "  %-10s : %s\n", vorbis_metatypes[k___0].name, dd___0);
#line 303
      k___0 ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 319
    psf_log_printf(psf, "End\n");
    }
  }
  {
#line 322
  psf->sf.samplerate = (int )vdata->vinfo.rate;
#line 323
  psf->sf.channels = vdata->vinfo.channels;
#line 324
  psf->sf.format = 2097248;
#line 329
  vorbis_synthesis_init(& vdata->vdsp, & vdata->vinfo);
#line 334
  vorbis_block_init(& vdata->vdsp, & vdata->vblock);
#line 336
  vdata->loc = (sf_count_t )0;
  }
#line 338
  return (0);
}
}
#line 342 "/root/patchweave_new/23/src/ogg_vorbis.c"
static int vorbis_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int k ;
  int ret ;
  char const   *name ;
  int32_t __cil_tmp10 ;
  ogg_packet header ;
  ogg_packet header_comm ;
  ogg_packet header_code ;
  int result ;

  {
  {
#line 344
  odata = (OGG_PRIVATE *)psf->container_data;
#line 345
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 348
  vorbis_info_init(& vdata->vinfo);
#line 351
  ret = vorbis_encode_init_vbr(& vdata->vinfo, (long )psf->sf.channels, (long )psf->sf.samplerate,
                               (float )vdata->quality);
  }
#line 360
  if (ret) {
#line 361
    return (1);
  }
  {
#line 363
  vdata->loc = (sf_count_t )0;
#line 366
  vorbis_comment_init(& vdata->vcomment);
#line 368
  vorbis_comment_add_tag(& vdata->vcomment, "ENCODER", "libsndfile");
#line 369
  k = 0;
  }
  {
#line 369
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 369
    if (! (k < 32)) {
#line 369
      goto while_break;
    }
#line 372
    if (psf->strings.data[k].type == 0) {
#line 373
      goto while_break;
    }
#line 376
    if (psf->strings.data[k].type == 1) {
#line 376
      goto case_1;
    }
#line 377
    if (psf->strings.data[k].type == 2) {
#line 377
      goto case_2;
    }
#line 378
    if (psf->strings.data[k].type == 3) {
#line 378
      goto case_3;
    }
#line 379
    if (psf->strings.data[k].type == 4) {
#line 379
      goto case_4;
    }
#line 380
    if (psf->strings.data[k].type == 5) {
#line 380
      goto case_5;
    }
#line 381
    if (psf->strings.data[k].type == 6) {
#line 381
      goto case_6;
    }
#line 382
    if (psf->strings.data[k].type == 7) {
#line 382
      goto case_7;
    }
#line 383
    if (psf->strings.data[k].type == 8) {
#line 383
      goto case_8;
    }
#line 384
    if (psf->strings.data[k].type == 9) {
#line 384
      goto case_9;
    }
#line 385
    if (psf->strings.data[k].type == 16) {
#line 385
      goto case_16;
    }
#line 387
    goto switch_default;
    case_1: 
#line 376
    name = "TITLE";
#line 376
    goto switch_break;
    case_2: 
#line 377
    name = "COPYRIGHT\313\377D\270U";
#line 377
    goto switch_break;
    case_3: 
#line 378
    name = "SOFTWARE\220";
#line 378
    goto switch_break;
    case_4: 
#line 379
    name = "ARTIST";
#line 379
    goto switch_break;
    case_5: 
#line 380
    name = "COMMENT";
#line 380
    goto switch_break;
    case_6: 
#line 381
    name = "DATE";
#line 381
    goto switch_break;
    case_7: 
#line 382
    name = "ALBUM";
#line 382
    goto switch_break;
    case_8: 
#line 383
    name = "LICENSE";
#line 383
    goto switch_break;
    case_9: 
#line 384
    name = "TracknumberE\270U";
#line 384
    goto switch_break;
    case_16: 
#line 385
    name = "Genre";
#line 385
    goto switch_break;
    switch_default: 
#line 387
    goto while_continue;
    switch_break: 
    {
#line 390
    vorbis_comment_add_tag(& vdata->vcomment, name, (char const   *)(psf->strings.storage + psf->strings.data[k].offset));
#line 369
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 394
  vorbis_analysis_init(& vdata->vdsp, & vdata->vinfo);
#line 395
  vorbis_block_init(& vdata->vdsp, & vdata->vblock);
#line 403
  __cil_tmp10 = psf_rand_int32();
#line 403
  ogg_stream_init(& odata->ostream, __cil_tmp10);
#line 417
  vorbis_analysis_headerout(& vdata->vdsp, & vdata->vcomment, & header, & header_comm,
                            & header_code);
#line 418
  ogg_stream_packetin(& odata->ostream, & header);
#line 419
  ogg_stream_packetin(& odata->ostream, & header_comm);
#line 420
  ogg_stream_packetin(& odata->ostream, & header_code);
  }
  {
#line 425
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 425
    result = ogg_stream_flush(& odata->ostream, & odata->opage);
    }
#line 425
    if (! (result != 0)) {
#line 425
      goto while_break___0;
    }
    {
#line 426
    psf_fwrite((void const   *)odata->opage.header, (sf_count_t )1, odata->opage.header_len,
               psf);
#line 427
    psf_fwrite((void const   *)odata->opage.body, (sf_count_t )1, odata->opage.body_len,
               psf);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 431
  return (0);
}
}
#line 435 "/root/patchweave_new/23/src/ogg_vorbis.c"
static int vorbis_close(SF_PRIVATE *psf ) 
{ 
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int result ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 436
  odata = (OGG_PRIVATE *)psf->container_data;
#line 437
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 439
  if ((unsigned long )odata == (unsigned long )((void *)0)) {
#line 440
    return (0);
  } else
#line 439
  if ((unsigned long )vdata == (unsigned long )((void *)0)) {
#line 440
    return (0);
  }
#line 445
  if (psf->file.mode == 32) {
#line 447
    if (psf->write_current <= 0L) {
      {
#line 448
      vorbis_write_header(psf, 0);
      }
    }
    {
#line 450
    vorbis_analysis_wrote(& vdata->vdsp, 0);
    }
    {
#line 451
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 451
      __cil_tmp4 = vorbis_analysis_blockout(& vdata->vdsp, & vdata->vblock);
      }
#line 451
      if (! (__cil_tmp4 == 1)) {
#line 451
        goto while_break;
      }
      {
#line 455
      vorbis_analysis(& vdata->vblock, (ogg_packet *)((void *)0));
#line 456
      vorbis_bitrate_addblock(& vdata->vblock);
      }
      {
#line 458
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 458
        __cil_tmp5 = vorbis_bitrate_flushpacket(& vdata->vdsp, & odata->opacket);
        }
#line 458
        if (! __cil_tmp5) {
#line 458
          goto while_break___0;
        }
        {
#line 460
        ogg_stream_packetin(& odata->ostream, & odata->opacket);
        }
        {
#line 463
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 463
          if (! (! odata->eos)) {
#line 463
            goto while_break___1;
          }
          {
#line 464
          __cil_tmp7 = ogg_stream_pageout(& odata->ostream, & odata->opage);
#line 464
          result = __cil_tmp7;
          }
#line 465
          if (result == 0) {
#line 465
            goto while_break___1;
          }
          {
#line 466
          psf_fwrite((void const   *)odata->opage.header, (sf_count_t )1, odata->opage.header_len,
                     psf);
#line 467
          psf_fwrite((void const   *)odata->opage.body, (sf_count_t )1, odata->opage.body_len,
                     psf);
#line 472
          __cil_tmp8 = ogg_page_eos(& odata->opage);
          }
#line 472
          if (__cil_tmp8) {
#line 472
            odata->eos = 1;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: ;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 481
  vorbis_block_clear(& vdata->vblock);
#line 482
  vorbis_dsp_clear(& vdata->vdsp);
#line 483
  vorbis_comment_clear(& vdata->vcomment);
#line 484
  vorbis_info_clear(& vdata->vinfo);
  }
#line 486
  return (0);
}
}
#line 490 "/root/patchweave_new/23/src/ogg_vorbis.c"
int ogg_vorbis_open(SF_PRIVATE *psf ) 
{ 
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int error ;
  char const   *__cil_tmp6 ;
  void *tmp ;

  {
#line 491
  odata = (OGG_PRIVATE *)psf->container_data;
#line 493
  error = 0;
#line 495
  if ((unsigned long )odata == (unsigned long )((void *)0)) {
    {
#line 496
    psf_log_printf(psf, "%s : odata is NULL???\n", "ogg_vorbis_open");
    }
#line 497
    return (30);
  }
  {
#line 500
  tmp = calloc(1UL, sizeof(VORBIS_PRIVATE ));
#line 500
  vdata = (VORBIS_PRIVATE *)tmp;
#line 501
  psf->codec_data = (void *)vdata;
  }
#line 503
  if (psf->file.mode == 48) {
#line 504
    return (24);
  }
  {
#line 506
  __cil_tmp6 = vorbis_version_string();
#line 506
  psf_log_printf(psf, "Vorbis library version : %s\n", __cil_tmp6);
  }
#line 508
  if (psf->file.mode == 16) {
    {
#line 510
    ogg_sync_init(& odata->osync);
#line 512
    error = vorbis_read_header(psf, 1);
    }
#line 512
    if (error) {
#line 513
      return (error);
    }
    {
#line 515
    psf->read_short = & vorbis_read_s;
#line 516
    psf->read_int = & vorbis_read_i;
#line 517
    psf->read_float = & vorbis_read_f;
#line 518
    psf->read_double = & vorbis_read_d;
#line 519
    psf->sf.frames = vorbis_length(psf);
    }
  }
#line 522
  psf->codec_close = & vorbis_close;
#line 523
  if (psf->file.mode == 32) {
#line 526
    vdata->quality = 0.400000000001;
#line 528
    psf->write_header = & vorbis_write_header;
#line 529
    psf->write_short = & vorbis_write_s;
#line 530
    psf->write_int = & vorbis_write_i;
#line 531
    psf->write_float = & vorbis_write_f;
#line 532
    psf->write_double = & vorbis_write_d;
#line 534
    psf->sf.frames = (sf_count_t )-1LL;
#line 535
    psf->strings.flags = (uint32_t )256;
  }
#line 538
  psf->seek = & vorbis_seek;
#line 539
  psf->command = & vorbis_command;
#line 540
  psf->byterate = & vorbis_byterate;
#line 543
  psf->sf.format = 2097248;
#line 544
  psf->sf.sections = 1;
#line 546
  psf->datalength = (sf_count_t )1;
#line 547
  psf->dataoffset = (sf_count_t )0;
#line 550
  return (error);
}
}
#line 554 "/root/patchweave_new/23/src/ogg_vorbis.c"
static int vorbis_command(SF_PRIVATE *psf , int command , void *data , int datasize ) 
{ 
  VORBIS_PRIVATE *vdata ;

  {
#line 555
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 558
  if (command == 4865) {
#line 558
    goto case_4865;
  }
#line 573
  goto switch_default;
  case_4865: 
#line 559
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 560
    return (0);
  } else
#line 559
  if ((unsigned long )datasize != sizeof(double )) {
#line 560
    return (0);
  }
#line 562
  if (psf->have_written) {
#line 563
    return (0);
  }
  {
#line 565
  vdata->quality = 1. - *((double *)data);
#line 568
  vdata->quality = (double )0;
#line 570
  psf_log_printf(psf, "%s : Setting SFC_SET_VBR_ENCODING_QUALITY to %f.\n", "vorbis_command",
                 vdata->quality);
  }
#line 571
  return (1);
  switch_default: 
#line 574
  return (0);

#line 577
  return (0);
}
}
#line 581 "/root/patchweave_new/23/src/ogg_vorbis.c"
static int vorbis_rnull(SF_PRIVATE *UNUSED_psf , int samples , void *UNUSED_vptr ,
                        int UNUSED_off , int channels , float **UNUSED_pcm ) 
{ 


  {
#line 583
  return (samples * channels);
}
}
#line 587 "/root/patchweave_new/23/src/ogg_vorbis.c"
static int vorbis_rshort(SF_PRIVATE *psf , int samples , void *vptr , int off , int channels ,
                         float **pcm ) 
{ 
  short *ptr ;
  int i ;
  int j ;
  int n ;
  float inverse ;
  int __cil_tmp12 ;
  long __cil_tmp13 ;
  int __cil_tmp16 ;
  long __cil_tmp17 ;

  {
#line 589
  ptr = (short *)vptr + off;
#line 590
  i = 0;
#line 591
  if (psf->float_int_mult) {
#line 593
    inverse = (float )(1. / (double )psf->float_max);
#line 594
    j = 0;
    {
#line 594
    while (1) {
      while_continue: /* CIL Label */ ;

#line 594
      if (! (j < samples)) {
#line 594
        goto while_break;
      }
#line 595
      n = 0;
      {
#line 595
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 595
        if (! (n < channels)) {
#line 595
          goto while_break___0;
        }
        {
#line 596
        __cil_tmp13 = lrintf((*(*(pcm + n) + j) * inverse) * 32767.f);
#line 596
        __cil_tmp12 = i;
#line 596
        i ++;
#line 596
        *(ptr + __cil_tmp12) = (short )__cil_tmp13;
#line 595
        n ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: 
#line 594
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 600
    j = 0;
    {
#line 600
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 600
      if (! (j < samples)) {
#line 600
        goto while_break___1;
      }
#line 601
      n = 0;
      {
#line 601
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 601
        if (! (n < channels)) {
#line 601
          goto while_break___2;
        }
        {
#line 602
        __cil_tmp17 = lrintf(*(*(pcm + n) + j) * 32767.f);
#line 602
        __cil_tmp16 = i;
#line 602
        i ++;
#line 602
        *(ptr + __cil_tmp16) = (short )__cil_tmp17;
#line 601
        n ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 600
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 604
  return (i);
}
}
#line 608 "/root/patchweave_new/23/src/ogg_vorbis.c"
static int vorbis_rint(SF_PRIVATE *psf , int samples , void *vptr , int off , int channels ,
                       float **pcm ) 
{ 
  int *ptr ;
  int i ;
  int j ;
  int n ;
  float inverse ;
  int __cil_tmp12 ;
  long __cil_tmp13 ;
  int __cil_tmp16 ;
  long __cil_tmp17 ;

  {
#line 610
  ptr = (int *)vptr + off;
#line 611
  i = 0;
#line 613
  if (psf->float_int_mult) {
#line 615
    inverse = (float )(1. / (double )psf->float_max);
#line 616
    j = 0;
    {
#line 616
    while (1) {
      while_continue: /* CIL Label */ ;

#line 616
      if (! (j < samples)) {
#line 616
        goto while_break;
      }
#line 617
      n = 0;
      {
#line 617
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 617
        if (! (n < channels)) {
#line 617
          goto while_break___0;
        }
        {
#line 618
        __cil_tmp13 = lrintf((*(*(pcm + n) + j) * inverse) * 2147483648.f);
#line 618
        __cil_tmp12 = i;
#line 618
        i ++;
#line 618
        *(ptr + __cil_tmp12) = (int )__cil_tmp13;
#line 617
        n ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: 
#line 616
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 622
    j = 0;
    {
#line 622
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 622
      if (! (j < samples)) {
#line 622
        goto while_break___1;
      }
#line 623
      n = 0;
      {
#line 623
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 623
        if (! (n < channels)) {
#line 623
          goto while_break___2;
        }
        {
#line 624
        __cil_tmp17 = lrintf(*(*(pcm + n) + j) * 2147483648.f);
#line 624
        __cil_tmp16 = i;
#line 624
        i ++;
#line 624
        *(ptr + __cil_tmp16) = (int )__cil_tmp17;
#line 623
        n ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 622
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 626
  return (i);
}
}
#line 630 "/root/patchweave_new/23/src/ogg_vorbis.c"
static int vorbis_rfloat(SF_PRIVATE *UNUSED_psf , int samples , void *vptr , int off ,
                         int channels , float **pcm ) 
{ 
  float *ptr ;
  int i ;
  int j ;
  int n ;
  int __cil_tmp11 ;

  {
#line 632
  ptr = (float *)vptr + off;
#line 633
  i = 0;
#line 634
  j = 0;
  {
#line 634
  while (1) {
    while_continue: /* CIL Label */ ;

#line 634
    if (! (j < samples)) {
#line 634
      goto while_break;
    }
#line 635
    n = 0;
    {
#line 635
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 635
      if (! (n < channels)) {
#line 635
        goto while_break___0;
      }
#line 636
      __cil_tmp11 = i;
#line 636
      i ++;
#line 636
      *(ptr + __cil_tmp11) = *(*(pcm + n) + j);
#line 635
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 634
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 637
  return (i);
}
}
#line 641 "/root/patchweave_new/23/src/ogg_vorbis.c"
static int vorbis_rdouble(SF_PRIVATE *UNUSED_psf , int samples , void *vptr , int off ,
                          int channels , float **pcm ) 
{ 
  double *ptr ;
  int i ;
  int j ;
  int n ;
  int __cil_tmp11 ;

  {
#line 643
  ptr = (double *)vptr + off;
#line 644
  i = 0;
#line 645
  j = 0;
  {
#line 645
  while (1) {
    while_continue: /* CIL Label */ ;

#line 645
    if (! (j < samples)) {
#line 645
      goto while_break;
    }
#line 646
    n = 0;
    {
#line 646
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 646
      if (! (n < channels)) {
#line 646
        goto while_break___0;
      }
#line 647
      __cil_tmp11 = i;
#line 647
      i ++;
#line 647
      *(ptr + __cil_tmp11) = (double )*(*(pcm + n) + j);
#line 646
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 645
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 648
  return (i);
}
}
#line 653 "/root/patchweave_new/23/src/ogg_vorbis.c"
static sf_count_t vorbis_read_sample(SF_PRIVATE *psf , void *ptr , sf_count_t lens ,
                                     convert_func *transfn ) 
{ 
  VORBIS_PRIVATE *vdata ;
  OGG_PRIVATE *odata ;
  int len ;
  int samples ;
  int i ;
  float **pcm ;
  int __cil_tmp12 ;
  int result ;
  int __cil_tmp14 ;
  int __cil_tmp16 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  char *buffer ;
  int bytes ;
  sf_count_t __cil_tmp23 ;

  {
#line 655
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 656
  odata = (OGG_PRIVATE *)psf->container_data;
#line 657
  i = 0;
#line 660
  len = (int )(lens / (long )psf->sf.channels);
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 662
    samples = vorbis_synthesis_pcmout(& vdata->vdsp, & pcm);
    }
#line 662
    if (! (samples > 0)) {
#line 662
      goto while_break;
    }
#line 663
    if (samples > len) {
#line 663
      samples = len;
    }
    {
#line 664
    __cil_tmp12 = (*transfn)(psf, samples, ptr, i, psf->sf.channels, pcm);
#line 664
    i += __cil_tmp12;
#line 665
    len -= samples;
#line 667
    vorbis_synthesis_read(& vdata->vdsp, samples);
#line 668
    vdata->loc += (long )samples;
    }
#line 669
    if (len == 0) {
#line 670
      return ((sf_count_t )i);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 672
  goto start0;
  {
#line 673
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 673
    if (len > 0) {
#line 673
      if (! (! odata->eos)) {
#line 673
        goto while_break___0;
      }
    } else {
#line 673
      goto while_break___0;
    }
    {
#line 675
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 675
      if (len > 0) {
#line 675
        if (! (! odata->eos)) {
#line 675
          goto while_break___1;
        }
      } else {
#line 675
        goto while_break___1;
      }
      {
#line 676
      __cil_tmp14 = ogg_sync_pageout(& odata->osync, & odata->opage);
#line 676
      result = __cil_tmp14;
      }
#line 677
      if (result == 0) {
#line 677
        goto while_break___1;
      }
#line 678
      if (result < 0) {
        {
#line 680
        psf_log_printf(psf, "Corrupt or missing data in bitstream ; continuing...\n");
        }
      } else {
        {
#line 684
        ogg_stream_pagein(& odata->ostream, & odata->opage);
        }
        start0: 
        {
#line 686
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 687
          result = ogg_stream_packetout(& odata->ostream, & odata->opacket);
          }
#line 688
          if (result == 0) {
#line 689
            goto while_break___2;
          }
#line 690
          if (! (result < 0)) {
            {
#line 696
            __cil_tmp16 = vorbis_synthesis(& vdata->vblock, & odata->opacket);
            }
#line 696
            if (__cil_tmp16 == 0) {
              {
#line 697
              vorbis_synthesis_blockin(& vdata->vdsp, & vdata->vblock);
              }
            }
            {
#line 705
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 705
              samples = vorbis_synthesis_pcmout(& vdata->vdsp, & pcm);
              }
#line 705
              if (! (samples > 0)) {
#line 705
                goto while_break___3;
              }
#line 706
              if (samples > len) {
#line 706
                samples = len;
              }
              {
#line 707
              __cil_tmp18 = (*transfn)(psf, samples, ptr, i, psf->sf.channels, pcm);
#line 707
              i += __cil_tmp18;
#line 708
              len -= samples;
#line 710
              vorbis_synthesis_read(& vdata->vdsp, samples);
#line 711
              vdata->loc += (long )samples;
              }
#line 712
              if (len == 0) {
#line 713
                return ((sf_count_t )i);
              }
            }
            while_break___8: /* CIL Label */ ;
            }
            while_break___3: ;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: 
        {
#line 717
        __cil_tmp19 = ogg_page_eos(& odata->opage);
        }
#line 717
        if (__cil_tmp19) {
#line 717
          odata->eos = 1;
        }
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: ;
#line 720
    if (! odata->eos) {
      {
#line 723
      buffer = ogg_sync_buffer(& odata->osync, 4096L);
#line 724
      __cil_tmp23 = psf_fread((void *)buffer, (sf_count_t )1, (sf_count_t )4096, psf);
#line 724
      bytes = (int )__cil_tmp23;
#line 725
      ogg_sync_wrote(& odata->osync, (long )bytes);
      }
#line 726
      if (bytes == 0) {
#line 726
        odata->eos = 1;
      }
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: ;
#line 729
  return ((sf_count_t )i);
}
}
#line 733 "/root/patchweave_new/23/src/ogg_vorbis.c"
static sf_count_t vorbis_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t lens ) 
{ 
  sf_count_t __cil_tmp4 ;

  {
  {
#line 734
  __cil_tmp4 = vorbis_read_sample(psf, (void *)ptr, lens, & vorbis_rshort);
  }
#line 734
  return (__cil_tmp4);
}
}
#line 738 "/root/patchweave_new/23/src/ogg_vorbis.c"
static sf_count_t vorbis_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t lens ) 
{ 
  sf_count_t __cil_tmp4 ;

  {
  {
#line 739
  __cil_tmp4 = vorbis_read_sample(psf, (void *)ptr, lens, & vorbis_rint);
  }
#line 739
  return (__cil_tmp4);
}
}
#line 743 "/root/patchweave_new/23/src/ogg_vorbis.c"
static sf_count_t vorbis_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t lens ) 
{ 
  sf_count_t __cil_tmp4 ;

  {
  {
#line 744
  __cil_tmp4 = vorbis_read_sample(psf, (void *)ptr, lens, & vorbis_rfloat);
  }
#line 744
  return (__cil_tmp4);
}
}
#line 748 "/root/patchweave_new/23/src/ogg_vorbis.c"
static sf_count_t vorbis_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t lens ) 
{ 
  sf_count_t __cil_tmp4 ;

  {
  {
#line 749
  __cil_tmp4 = vorbis_read_sample(psf, (void *)ptr, lens, & vorbis_rdouble);
  }
#line 749
  return (__cil_tmp4);
}
}
#line 756 "/root/patchweave_new/23/src/ogg_vorbis.c"
static void vorbis_write_samples(SF_PRIVATE *psf , OGG_PRIVATE *odata , VORBIS_PRIVATE *vdata ,
                                 int in_frames ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int result ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 758
  vorbis_analysis_wrote(& vdata->vdsp, in_frames);
  }
  {
#line 765
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 765
    __cil_tmp5 = vorbis_analysis_blockout(& vdata->vdsp, & vdata->vblock);
    }
#line 765
    if (! (__cil_tmp5 == 1)) {
#line 765
      goto while_break;
    }
    {
#line 768
    vorbis_analysis(& vdata->vblock, (ogg_packet *)((void *)0));
#line 769
    vorbis_bitrate_addblock(& vdata->vblock);
    }
    {
#line 771
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 771
      __cil_tmp6 = vorbis_bitrate_flushpacket(& vdata->vdsp, & odata->opacket);
      }
#line 771
      if (! __cil_tmp6) {
#line 771
        goto while_break___0;
      }
      {
#line 774
      ogg_stream_packetin(& odata->ostream, & odata->opacket);
      }
      {
#line 777
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 777
        if (! (! odata->eos)) {
#line 777
          goto while_break___1;
        }
        {
#line 778
        __cil_tmp8 = ogg_stream_pageout(& odata->ostream, & odata->opage);
#line 778
        result = __cil_tmp8;
        }
#line 779
        if (result == 0) {
#line 780
          goto while_break___1;
        }
        {
#line 781
        psf_fwrite((void const   *)odata->opage.header, (sf_count_t )1, odata->opage.header_len,
                   psf);
#line 782
        psf_fwrite((void const   *)odata->opage.body, (sf_count_t )1, odata->opage.body_len,
                   psf);
#line 786
        __cil_tmp9 = ogg_page_eos(& odata->opage);
        }
#line 786
        if (__cil_tmp9) {
#line 787
          odata->eos = 1;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 792
  vdata->loc += (long )in_frames;
#line 793
  return;
}
}
#line 797 "/root/patchweave_new/23/src/ogg_vorbis.c"
static sf_count_t vorbis_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t lens ) 
{ 
  int i ;
  int m ;
  int j ;
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int in_frames ;
  float **buffer ;
  float **__cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 799
  j = 0;
#line 800
  odata = (OGG_PRIVATE *)psf->container_data;
#line 801
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 802
  in_frames = (int )(lens / (long )psf->sf.channels);
#line 803
  __cil_tmp11 = vorbis_analysis_buffer(& vdata->vdsp, in_frames);
#line 803
  buffer = __cil_tmp11;
#line 804
  i = 0;
  }
  {
#line 804
  while (1) {
    while_continue: /* CIL Label */ ;

#line 804
    if (! (i < in_frames)) {
#line 804
      goto while_break;
    }
#line 805
    m = 0;
    {
#line 805
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 805
      if (! (m < psf->sf.channels)) {
#line 805
        goto while_break___0;
      }
#line 806
      __cil_tmp12 = j;
#line 806
      j ++;
#line 806
      *(*(buffer + m) + i) = (float )*(ptr + __cil_tmp12) / 32767.f;
#line 805
      m ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 804
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 808
  vorbis_write_samples(psf, odata, vdata, in_frames);
  }
#line 810
  return (lens);
}
}
#line 814 "/root/patchweave_new/23/src/ogg_vorbis.c"
static sf_count_t vorbis_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t lens ) 
{ 
  int i ;
  int m ;
  int j ;
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int in_frames ;
  float **buffer ;
  float **__cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 815
  j = 0;
#line 816
  odata = (OGG_PRIVATE *)psf->container_data;
#line 817
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 818
  in_frames = (int )(lens / (long )psf->sf.channels);
#line 819
  __cil_tmp11 = vorbis_analysis_buffer(& vdata->vdsp, in_frames);
#line 819
  buffer = __cil_tmp11;
#line 820
  i = 0;
  }
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;

#line 820
    if (! (i < in_frames)) {
#line 820
      goto while_break;
    }
#line 821
    m = 0;
    {
#line 821
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 821
      if (! (m < psf->sf.channels)) {
#line 821
        goto while_break___0;
      }
#line 822
      __cil_tmp12 = j;
#line 822
      j ++;
#line 822
      *(*(buffer + m) + i) = (float )*(ptr + __cil_tmp12) / 2147483648.f;
#line 821
      m ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 820
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 824
  vorbis_write_samples(psf, odata, vdata, in_frames);
  }
#line 826
  return (lens);
}
}
#line 830 "/root/patchweave_new/23/src/ogg_vorbis.c"
static sf_count_t vorbis_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t lens ) 
{ 
  int i ;
  int m ;
  int j ;
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int in_frames ;
  float **buffer ;
  float **__cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 831
  j = 0;
#line 832
  odata = (OGG_PRIVATE *)psf->container_data;
#line 833
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 834
  in_frames = (int )(lens / (long )psf->sf.channels);
#line 835
  __cil_tmp11 = vorbis_analysis_buffer(& vdata->vdsp, in_frames);
#line 835
  buffer = __cil_tmp11;
#line 836
  i = 0;
  }
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;

#line 836
    if (! (i < in_frames)) {
#line 836
      goto while_break;
    }
#line 837
    m = 0;
    {
#line 837
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 837
      if (! (m < psf->sf.channels)) {
#line 837
        goto while_break___0;
      }
#line 838
      __cil_tmp12 = j;
#line 838
      j ++;
#line 838
      *(*(buffer + m) + i) = (float )*(ptr + __cil_tmp12);
#line 837
      m ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 836
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 840
  vorbis_write_samples(psf, odata, vdata, in_frames);
  }
#line 842
  return (lens);
}
}
#line 846 "/root/patchweave_new/23/src/ogg_vorbis.c"
static sf_count_t vorbis_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t lens ) 
{ 
  int i ;
  int m ;
  int j ;
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int in_frames ;
  float **buffer ;
  float **__cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 847
  j = 0;
#line 848
  odata = (OGG_PRIVATE *)psf->container_data;
#line 849
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 850
  in_frames = (int )(lens / (long )psf->sf.channels);
#line 851
  __cil_tmp11 = vorbis_analysis_buffer(& vdata->vdsp, in_frames);
#line 851
  buffer = __cil_tmp11;
#line 852
  i = 0;
  }
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;

#line 852
    if (! (i < in_frames)) {
#line 852
      goto while_break;
    }
#line 853
    m = 0;
    {
#line 853
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 853
      if (! (m < psf->sf.channels)) {
#line 853
        goto while_break___0;
      }
#line 854
      __cil_tmp12 = j;
#line 854
      j ++;
#line 854
      *(*(buffer + m) + i) = (float )*(ptr + __cil_tmp12);
#line 853
      m ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 852
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 856
  vorbis_write_samples(psf, odata, vdata, in_frames);
  }
#line 858
  return (lens);
}
}
#line 862 "/root/patchweave_new/23/src/ogg_vorbis.c"
static sf_count_t vorbis_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) 
{ 
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  sf_count_t target ;
  sf_count_t m ;
  long tmp ;

  {
#line 864
  odata = (OGG_PRIVATE *)psf->container_data;
#line 865
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 867
  if ((unsigned long )odata == (unsigned long )((void *)0)) {
#line 868
    return ((sf_count_t )0);
  } else
#line 867
  if ((unsigned long )vdata == (unsigned long )((void *)0)) {
#line 868
    return ((sf_count_t )0);
  }
#line 870
  if (offset < 0L) {
#line 871
    psf->error = 40;
#line 872
    return ((sf_count_t )-1);
  }
#line 875
  if (psf->file.mode == 16) {
#line 876
    target = offset - vdata->loc;
#line 878
    if (target < 0L) {
      {
#line 880
      psf_fseek(psf, (sf_count_t )12, 0);
#line 881
      vorbis_read_header(psf, 0);
#line 882
      target = offset;
      }
    }
    {
#line 885
    while (1) {
      while_continue: /* CIL Label */ ;

#line 885
      if (! (target > 0L)) {
#line 885
        goto while_break;
      }
#line 886
      if (target > 4096L) {
#line 886
        tmp = 4096L;
      } else {
#line 886
        tmp = target;
      }
      {
#line 886
      m = tmp;
#line 893
      vorbis_read_sample(psf, (void *)0, m * (long )psf->sf.channels, & vorbis_rnull);
#line 895
      target -= m;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
#line 898
    return (vdata->loc);
  }
#line 901
  return ((sf_count_t )0);
}
}
#line 906 "/root/patchweave_new/23/src/ogg_vorbis.c"
static int vorbis_byterate(SF_PRIVATE *psf ) 
{ 


  {
#line 908
  if (psf->file.mode == 16) {
#line 909
    return ((int )((psf->datalength * (long )psf->sf.samplerate) / psf->sf.frames));
  }
#line 911
  return (-1);
}
}
#line 946 "/root/patchweave_new/23/src/ogg_vorbis.c"
static stream_set *create_stream_set(void) 
{ 
  stream_set *set ;
  void *__cil_tmp2 ;
  void *tmp ;

  {
  {
#line 947
  __cil_tmp2 = calloc(1UL, sizeof(stream_set ));
#line 947
  set = (stream_set *)__cil_tmp2;
#line 949
  tmp = calloc(5UL, sizeof(stream_processor ));
#line 949
  set->streams = (stream_processor *)tmp;
#line 950
  set->allocated = 5;
#line 951
  set->used = 0;
  }
#line 953
  return (set);
}
}
#line 957 "/root/patchweave_new/23/src/ogg_vorbis.c"
static void vorbis_end(stream_processor *stream , sf_count_t *len ) 
{ 


  {
  {
#line 958
  *len += stream->lastgranulepos;
#line 959
  vorbis_comment_clear(& stream->vcomment);
#line 960
  vorbis_info_clear(& stream->vinfo);
  }
#line 962
  return;
}
}
#line 964 "/root/patchweave_new/23/src/ogg_vorbis.c"
static void free_stream_set(stream_set *set , sf_count_t *len ) 
{ 
  int i ;

  {
#line 967
  i = 0;
  {
#line 967
  while (1) {
    while_continue: /* CIL Label */ ;

#line 967
    if (! (i < set->used)) {
#line 967
      goto while_break;
    }
#line 968
    if (! (set->streams + i)->end) {
      {
#line 969
      vorbis_end(set->streams + i, len);
      }
    }
    {
#line 970
    ogg_stream_clear(& (set->streams + i)->ostream);
#line 967
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 973
  free((void *)set->streams);
#line 974
  free((void *)set);
  }
#line 976
  return;
}
}
#line 978 "/root/patchweave_new/23/src/ogg_vorbis.c"
static int streams_open(stream_set *set ) 
{ 
  int i ;
  int res ;

  {
#line 979
  res = 0;
#line 981
  i = 0;
  {
#line 981
  while (1) {
    while_continue: /* CIL Label */ ;

#line 981
    if (! (i < set->used)) {
#line 981
      goto while_break;
    }
#line 982
    if (! (set->streams + i)->end) {
#line 983
      res ++;
    }
#line 981
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 984
  return (res);
}
}
#line 988 "/root/patchweave_new/23/src/ogg_vorbis.c"
static stream_processor *find_stream_processor(stream_set *set , ogg_page *page ) 
{ 
  uint32_t serial ;
  int __cil_tmp4 ;
  int i ;
  int invalid ;
  stream_processor *stream ;
  int __cil_tmp10 ;
  int res ;
  ogg_packet packet ;
  int __cil_tmp16 ;
  void *tmp ;

  {
  {
#line 989
  __cil_tmp4 = ogg_page_serialno(page);
#line 989
  serial = (uint32_t )__cil_tmp4;
#line 990
  invalid = 0;
#line 994
  i = 0;
  }
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;

#line 994
    if (! (i < set->used)) {
#line 994
      goto while_break;
    }
#line 996
    if (serial == (set->streams + i)->serial) {
#line 998
      stream = set->streams + i;
#line 1000
      set->in_headers = 0;
#line 1002
      if (stream->end) {
#line 1003
        stream->isillegal = 1;
#line 1004
        return (stream);
      }
      {
#line 1007
      stream->isnew = 0;
#line 1008
      stream->end = ogg_page_eos(page);
#line 1009
      stream->serial = serial;
      }
#line 1010
      return (stream);
    }
#line 994
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1019
  __cil_tmp10 = streams_open(set);
  }
#line 1019
  if (__cil_tmp10) {
#line 1019
    if (! set->in_headers) {
#line 1020
      invalid = 1;
    }
  }
#line 1022
  set->in_headers = 1;
#line 1024
  if (set->allocated < set->used) {
#line 1025
    stream = set->streams + set->used;
  } else {
    {
#line 1027
    set->allocated += 5;
#line 1028
    tmp = realloc((void *)set->streams, sizeof(stream_processor ) * (unsigned long )set->allocated);
#line 1028
    set->streams = (stream_processor *)tmp;
#line 1029
    stream = set->streams + set->used;
    }
  }
  {
#line 1032
  (set->used) ++;
#line 1034
  stream->isnew = 1;
#line 1035
  stream->isillegal = invalid;
#line 1042
  ogg_stream_init(& stream->ostream, (int )serial);
#line 1043
  ogg_stream_pagein(& stream->ostream, page);
#line 1044
  res = ogg_stream_packetout(& stream->ostream, & packet);
  }
#line 1045
  if (res <= 0) {
#line 1046
    return ((stream_processor *)((void *)0));
  } else {
    {
#line 1047
    __cil_tmp16 = memcmp((void const   *)packet.packet, (void const   *)"\001vorbis",
                         7UL);
    }
#line 1047
    if (packet.bytes >= 7L) {
#line 1047
      if (__cil_tmp16 == 0) {
        {
#line 1049
        stream->lastgranulepos = (sf_count_t )0;
#line 1050
        vorbis_comment_init(& stream->vcomment);
#line 1051
        vorbis_info_init(& stream->vinfo);
        }
      }
    }
  }
  {
#line 1054
  res = ogg_stream_packetout(& stream->ostream, & packet);
#line 1057
  ogg_stream_clear(& stream->ostream);
#line 1058
  ogg_stream_init(& stream->ostream, (int )serial);
#line 1061
  stream->end = ogg_page_eos(page);
#line 1062
  stream->serial = serial;
  }
#line 1064
  return (stream);
}
}
#line 1070 "/root/patchweave_new/23/src/ogg_vorbis.c"
static int CHUNK_SIZE  ;
#line 1068 "/root/patchweave_new/23/src/ogg_vorbis.c"
static int vorbis_length_get_next_page(SF_PRIVATE *psf , ogg_sync_state *osync , ogg_page *page ) 
{ 
  int __cil_tmp5 ;
  char *buffer ;
  char *__cil_tmp7 ;
  int bytes ;
  sf_count_t __cil_tmp9 ;

  {
#line 1069
  CHUNK_SIZE = 4500;
  {
#line 1071
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1071
    __cil_tmp5 = ogg_sync_pageout(osync, page);
    }
#line 1071
    if (! (__cil_tmp5 <= 0)) {
#line 1071
      goto while_break;
    }
    {
#line 1072
    __cil_tmp7 = ogg_sync_buffer(osync, (long )CHUNK_SIZE);
#line 1072
    buffer = __cil_tmp7;
#line 1073
    __cil_tmp9 = psf_fread((void *)buffer, (sf_count_t )1, (sf_count_t )4096, psf);
#line 1073
    bytes = (int )__cil_tmp9;
    }
#line 1075
    if (bytes <= 0) {
      {
#line 1076
      ogg_sync_wrote(osync, 0L);
      }
#line 1077
      return (0);
    }
    {
#line 1080
    ogg_sync_wrote(osync, (long )bytes);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1083
  return (1);
}
}
#line 1087 "/root/patchweave_new/23/src/ogg_vorbis.c"
static sf_count_t vorbis_length_aux(SF_PRIVATE *psf ) 
{ 
  ogg_sync_state osync ;
  ogg_page page ;
  sf_count_t len ;
  stream_set *processors ;
  int __cil_tmp7 ;
  stream_processor *p ;
  stream_processor *__cil_tmp9 ;
  ogg_packet packet ;
  int header ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  sf_count_t gp ;
  ogg_int64_t __cil_tmp16 ;

  {
  {
#line 1091
  len = (sf_count_t )0;
#line 1094
  processors = create_stream_set();
  }
#line 1095
  if ((unsigned long )processors == (unsigned long )((void *)0)) {
#line 1096
    return ((sf_count_t )0);
  }
  {
#line 1098
  ogg_sync_init(& osync);
  }
  {
#line 1100
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: 
    {
#line 1100
    __cil_tmp7 = vorbis_length_get_next_page(psf, & osync, & page);
    }
#line 1100
    if (! __cil_tmp7) {
#line 1100
      goto while_break;
    }
    {
#line 1102
    __cil_tmp9 = find_stream_processor(processors, & page);
#line 1102
    p = __cil_tmp9;
    }
#line 1104
    if (! p) {
#line 1105
      len = (sf_count_t )0;
#line 1106
      goto while_break;
    }
#line 1109
    if (p->isillegal) {
#line 1109
      if (! p->shownillegal) {
#line 1111
        p->shownillegal = 1;
#line 1115
        if (! p->isnew) {
#line 1115
          goto while_continue;
        }
      }
    }
#line 1118
    if (! p->isillegal) {
      {
#line 1120
      header = 0;
#line 1122
      ogg_stream_pagein(& p->ostream, & page);
      }
#line 1123
      if (p->doneheaders < 3) {
#line 1124
        header = 1;
      }
      {
#line 1126
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: 
        {
#line 1126
        __cil_tmp12 = ogg_stream_packetout(& p->ostream, & packet);
        }
#line 1126
        if (! (__cil_tmp12 > 0)) {
#line 1126
          goto while_break___0;
        }
#line 1128
        if (p->doneheaders < 3) {
          {
#line 1129
          __cil_tmp13 = vorbis_synthesis_headerin(& p->vinfo, & p->vcomment, & packet);
          }
#line 1129
          if (__cil_tmp13 < 0) {
#line 1130
            goto while_continue___0;
          }
#line 1131
          (p->doneheaders) ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
#line 1134
      if (! header) {
        {
#line 1135
        __cil_tmp16 = ogg_page_granulepos(& page);
#line 1135
        gp = __cil_tmp16;
        }
#line 1136
        if (gp > 0L) {
#line 1136
          p->lastgranulepos = gp;
        }
      }
#line 1138
      if (p->end) {
        {
#line 1139
        vorbis_end(p, & len);
#line 1140
        p->isillegal = 1;
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1145
  ogg_sync_clear(& osync);
#line 1146
  free_stream_set(processors, & len);
  }
#line 1148
  return (len);
}
}
#line 1152 "/root/patchweave_new/23/src/ogg_vorbis.c"
static sf_count_t vorbis_length(SF_PRIVATE *psf ) 
{ 
  sf_count_t length ;
  int error ;

  {
#line 1156
  if (psf->sf.seekable == 0) {
#line 1157
    return ((sf_count_t )-1LL);
  }
  {
#line 1159
  psf_fseek(psf, (sf_count_t )0, 0);
#line 1160
  length = vorbis_length_aux(psf);
#line 1162
  psf_fseek(psf, (sf_count_t )12, 0);
#line 1163
  error = vorbis_read_header(psf, 0);
  }
#line 1163
  if (error != 0) {
#line 1164
    psf->error = error;
  }
#line 1166
  return (length);
}
}
#line 70 "/root/patchweave_new/23/src/rf64.c"
static int rf64_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) ;
#line 71
static int rf64_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 72
static int rf64_write_tailer(SF_PRIVATE *psf ) ;
#line 73
static int rf64_close(SF_PRIVATE *psf ) ;
#line 74
static int rf64_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int datasize ) ;
#line 76
static int rf64_set_chunk(SF_PRIVATE *psf , SF_CHUNK_INFO *chunk_info ) ;
#line 77
static SF_CHUNK_ITERATOR *rf64_next_chunk_iterator(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator ) ;
#line 78
static int rf64_get_chunk_size(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 79
static int rf64_get_chunk_data(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 86 "/root/patchweave_new/23/src/rf64.c"
int rf64_open(SF_PRIVATE *psf ) 
{ 
  WAVLIKE_PRIVATE *wpriv ;
  int subformat ;
  int error ;
  int blockalign ;
  int framesperblock ;
  void *tmp ;

  {
  {
#line 88
  error = 0;
#line 91
  tmp = calloc(1UL, sizeof(WAVLIKE_PRIVATE ));
#line 91
  wpriv = (WAVLIKE_PRIVATE *)tmp;
  }
#line 91
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 92
    return (17);
  }
#line 93
  psf->container_data = (void *)wpriv;
#line 94
  wpriv->wavex_ambisonic = 64;
#line 97
  psf->endian = 268435456;
#line 99
  psf->strings.flags = (uint32_t )768;
#line 101
  if (psf->file.mode == 16) {
    _L: 
    {
#line 102
    error = rf64_read_header(psf, & blockalign, & framesperblock);
    }
#line 102
    if (error != 0) {
#line 103
      return (error);
    }
#line 105
    psf->next_chunk_iterator = & rf64_next_chunk_iterator;
#line 106
    psf->get_chunk_size = & rf64_get_chunk_size;
#line 107
    psf->get_chunk_data = & rf64_get_chunk_data;
  } else
#line 101
  if (psf->file.mode == 48) {
#line 101
    if (psf->filelength > 0L) {
#line 101
      goto _L;
    }
  }
#line 110
  if ((psf->sf.format & 268369920) != 2228224) {
#line 111
    return (1);
  }
#line 113
  subformat = psf->sf.format & 65535;
#line 115
  if (psf->file.mode == 32) {
    _L___9: 
#line 116
    if (psf->is_pipe) {
#line 117
      return (29);
    }
    {
#line 119
    psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 121
    error = rf64_write_header(psf, 0);
    }
#line 121
    if (error) {
#line 122
      return (error);
    }
#line 124
    psf->write_header = & rf64_write_header;
#line 125
    psf->set_chunk = & rf64_set_chunk;
  } else
#line 115
  if (psf->file.mode == 48) {
#line 115
    goto _L___9;
  }
#line 128
  psf->container_close = & rf64_close;
#line 129
  psf->command = & rf64_command;
#line 135
  if (subformat == 4) {
#line 135
    goto case_4;
  }
#line 135
  if (subformat == 3) {
#line 135
    goto case_4;
  }
#line 135
  if (subformat == 2) {
#line 135
    goto case_4;
  }
#line 135
  if (subformat == 5) {
#line 135
    goto case_4;
  }
#line 139
  if (subformat == 16) {
#line 139
    goto case_16;
  }
#line 143
  if (subformat == 17) {
#line 143
    goto case_17;
  }
#line 148
  if (subformat == 6) {
#line 148
    goto case_6;
  }
#line 152
  if (subformat == 7) {
#line 152
    goto case_7;
  }
#line 158
  goto switch_default;
  case_4: 
  {
#line 136
  error = pcm_init(psf);
  }
#line 137
  goto switch_break;
  case_16: 
  {
#line 140
  error = ulaw_init(psf);
  }
#line 141
  goto switch_break;
  case_17: 
  {
#line 144
  error = alaw_init(psf);
  }
#line 145
  goto switch_break;
  case_6: 
  {
#line 149
  error = float32_init(psf);
  }
#line 150
  goto switch_break;
  case_7: 
  {
#line 153
  error = double64_init(psf);
  }
#line 154
  goto switch_break;
  switch_default: 
#line 158
  return (18);
  switch_break: ;
#line 161
  return (error);
}
}
#line 179 "/root/patchweave_new/23/src/rf64.c"
static int rf64_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) 
{ 
  WAVLIKE_PRIVATE *wpriv ;
  WAV_FMT *wav_fmt ;
  sf_count_t riff_size ;
  sf_count_t frame_count ;
  sf_count_t ds64_datalength ;
  uint32_t marks[2] ;
  uint32_t marker ;
  uint32_t chunk_size ;
  uint32_t parsestage ;
  int error ;
  int done ;
  int format ;
  sf_count_t pos ;
  sf_count_t __cil_tmp17 ;
  sf_count_t __cil_tmp18 ;
  unsigned int table_len ;
  unsigned int bytesread ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  unsigned int next ;
  int tmp ;
  sf_count_t __cil_tmp32 ;
  sf_count_t __cil_tmp33 ;
  unsigned short const   **__cil_tmp34 ;
  unsigned short const   **__cil_tmp35 ;
  unsigned short const   **__cil_tmp36 ;
  unsigned short const   **__cil_tmp37 ;
  sf_count_t __cil_tmp38 ;
  sf_count_t __cil_tmp39 ;
  sf_count_t __cil_tmp40 ;
  int __cil_tmp41 ;
  int tmp___0 ;

  {
#line 182
  riff_size = (sf_count_t )0;
#line 182
  frame_count = (sf_count_t )0;
#line 182
  ds64_datalength = (sf_count_t )0;
#line 183
  parsestage = (uint32_t )0;
#line 184
  done = 0;
#line 184
  format = 0;
#line 186
  wpriv = (WAVLIKE_PRIVATE *)psf->container_data;
#line 186
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 187
    return (30);
  }
  {
#line 188
  wav_fmt = & wpriv->wav_fmt;
#line 191
  psf_binheader_readf(psf, "pmmm\270U", 0, & marker, marks, marks + 1);
  }
#line 192
  if (marker != ((unsigned int )((82 | (70 << 8)) | (54 << 16)) | (52U << 24))) {
#line 193
    return (164);
  } else
#line 192
  if (marks[1] != ((unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24))) {
#line 193
    return (164);
  }
#line 195
  if (marks[0] == ((unsigned int )((255 | (255 << 8)) | (255 << 16)) | (255U << 24))) {
    {
#line 196
    psf_log_printf(psf, "%M\n  %M\n\221", (unsigned int )((82 | (70 << 8)) | (54 << 16)) | (52U << 24),
                   (unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24));
    }
  } else {
    {
#line 198
    psf_log_printf(psf, "%M : 0x%x (should be 0xFFFFFFFF)\n  %M\n", (unsigned int )((82 | (70 << 8)) | (54 << 16)) | (52U << 24),
                   (unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24));
    }
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;

#line 200
    if (! (! done)) {
#line 200
      goto while_break;
    }
    {
#line 202
    chunk_size = (uint32_t )0;
#line 202
    marker = chunk_size;
#line 203
    psf_binheader_readf(psf, "em4", & marker, & chunk_size);
    }
#line 205
    if (marker == 0U) {
      {
#line 206
      __cil_tmp17 = psf_ftell(psf);
#line 206
      pos = __cil_tmp17;
#line 207
      psf_log_printf(psf, "Have 0 marker at position %D (0x%x).\n", pos, pos);
      }
#line 208
      goto while_break;
    }
    {
#line 211
    __cil_tmp18 = psf_ftell(psf);
#line 211
    psf_store_read_chunk_u32(& psf->rchunks, marker, __cil_tmp18, chunk_size);
    }
#line 214
    if (marker == ((unsigned int )((100 | (115 << 8)) | (54 << 16)) | (52U << 24))) {
#line 214
      goto case_exp;
    }
#line 259
    if (marker == ((unsigned int )((102 | (109 << 8)) | (116 << 16)) | (32U << 24))) {
#line 259
      goto case_exp___0;
    }
#line 267
    if (marker == ((unsigned int )((98 | (101 << 8)) | (120 << 16)) | (116U << 24))) {
#line 267
      goto case_exp___1;
    }
#line 273
    if (marker == ((unsigned int )((99 | (97 << 8)) | (114 << 16)) | (116U << 24))) {
#line 273
      goto case_exp___2;
    }
#line 280
    if (marker == ((unsigned int )((76 | (73 << 8)) | (83 << 16)) | (84U << 24))) {
#line 280
      goto case_exp___3;
    }
#line 280
    if (marker == ((unsigned int )((73 | (78 << 8)) | (70 << 16)) | (79U << 24))) {
#line 280
      goto case_exp___3;
    }
#line 286
    if (marker == ((unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24))) {
#line 286
      goto case_exp___5;
    }
#line 298
    if (marker == ((unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24))) {
#line 298
      goto case_exp___6;
    }
#line 342
    goto switch_default;
    case_exp: 
#line 215
    if (parsestage & 1U) {
      {
#line 216
      psf_log_printf(psf, "*** Second \'ds64\' chunk?\n");
      }
#line 217
      goto switch_break;
    }
    {
#line 223
    __cil_tmp21 = psf_binheader_readf(psf, "888", & riff_size, & ds64_datalength,
                                      & frame_count);
#line 223
    bytesread = (unsigned int )__cil_tmp21;
#line 226
    __cil_tmp22 = psf_binheader_readf(psf, "4", & table_len);
#line 226
    bytesread += (unsigned int )__cil_tmp22;
#line 228
    __cil_tmp23 = psf_binheader_readf(psf, "j", table_len);
#line 228
    bytesread += (unsigned int )__cil_tmp23;
    }
#line 230
    if (chunk_size == bytesread) {
      {
#line 231
      psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
      }
    } else
#line 232
    if (chunk_size >= bytesread + 4U) {
      {
#line 234
      psf_binheader_readf(psf, "m", & next);
      }
#line 235
      if (next == ((unsigned int )((102 | (109 << 8)) | (116 << 16)) | (32U << 24))) {
        {
#line 236
        psf_log_printf(psf, "%M : %u (should be %u)\n", marker, chunk_size, bytesread);
#line 237
        psf_binheader_readf(psf, "j", -4);
        }
      } else {
        {
#line 240
        psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
#line 241
        psf_binheader_readf(psf, "j", (chunk_size - bytesread) - 4U);
        }
      }
    }
#line 245
    if (psf->filelength != riff_size + 8L) {
      {
#line 246
      psf_log_printf(psf, "  Riff size : %D (should be %D)\n\230\001", riff_size,
                     psf->filelength - 8L);
      }
    } else {
      {
#line 248
      psf_log_printf(psf, "  Riff size : %D\n", riff_size);
      }
    }
    {
#line 250
    psf_log_printf(psf, "  Data size : %D\n", ds64_datalength);
#line 252
    psf_log_printf(psf, "  Frames    : %D\n", frame_count);
#line 253
    psf_log_printf(psf, "  Table length : %u\n", table_len);
#line 256
    parsestage |= 1U;
    }
#line 257
    goto switch_break;
    case_exp___0: 
    {
#line 260
    psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
#line 261
    error = wavlike_read_fmt_chunk(psf, (int )chunk_size);
    }
#line 261
    if (error != 0) {
#line 262
      return (error);
    }
#line 263
    format = (int )wav_fmt->format;
#line 264
    parsestage |= 2U;
#line 265
    goto switch_break;
    case_exp___1: 
    {
#line 268
    error = wavlike_read_bext_chunk(psf, chunk_size);
    }
#line 268
    if (error != 0) {
#line 269
      return (error);
    }
#line 270
    parsestage |= 4U;
#line 271
    goto switch_break;
    case_exp___2: 
    {
#line 274
    error = wavlike_read_cart_chunk(psf, chunk_size);
    }
#line 274
    if (error != 0) {
#line 275
      return (error);
    }
#line 276
    parsestage |= 16U;
#line 277
    goto switch_break;
    case_exp___3: 
    {
#line 281
    error = wavlike_subchunk_parse(psf, (int )marker, chunk_size);
    }
#line 281
    if (error != 0) {
#line 282
      return (error);
    }
#line 283
    parsestage |= 64U;
#line 284
    goto switch_break;
    case_exp___5: 
#line 287
    if ((parsestage & 3U) != 3U) {
#line 288
      return (165);
    }
    {
#line 290
    parsestage |= 32U;
#line 292
    psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
#line 293
    error = wavlike_read_peak_chunk(psf, (size_t )chunk_size);
    }
#line 293
    if (error != 0) {
#line 294
      return (error);
    }
#line 295
    if ((parsestage & 8U) == 0U) {
#line 295
      tmp = 42;
    } else {
#line 295
      tmp = 43;
    }
#line 295
    (psf->peak_info)->peak_loc = tmp;
#line 296
    goto switch_break;
    case_exp___6: 
#line 301
    if ((parsestage & 1U) != 0U) {
#line 302
      if (chunk_size == 4294967295U) {
        {
#line 303
        psf_log_printf(psf, "%M : 0x%x\n", marker, chunk_size);
        }
      } else {
        {
#line 305
        psf_log_printf(psf, "%M : 0x%x (should be 0xffffffff\n\230\001", marker, chunk_size);
        }
      }
#line 306
      psf->datalength = ds64_datalength;
    } else
#line 309
    if (chunk_size == 4294967295U) {
      {
#line 310
      psf_log_printf(psf, "%M : 0x%x\n", marker, chunk_size);
#line 311
      psf_log_printf(psf, "  *** Data length not specified no \'ds64\' chunk.\n");
      }
    } else {
      {
#line 314
      psf_log_printf(psf, "%M : 0x%x\n**** Weird, RF64 file without a \'ds64\' chunk and no valid \'data\' size.\n",
                     marker, chunk_size);
#line 315
      psf->datalength = (sf_count_t )chunk_size;
      }
    }
    {
#line 319
    psf->dataoffset = psf_ftell(psf);
    }
#line 321
    if (psf->dataoffset > 0L) {
#line 322
      if (chunk_size == 0U) {
#line 322
        if (riff_size == 8L) {
#line 322
          if (psf->filelength > 44L) {
            {
#line 323
            psf_log_printf(psf, "  *** Looks like a WAV file which wasn\'t closed properly. Fixing it.\n");
#line 324
            psf->datalength = psf->filelength - psf->dataoffset;
            }
          }
        }
      }
#line 328
      if (psf->datalength + psf->dataoffset < psf->filelength) {
#line 329
        psf->dataend = psf->datalength + psf->dataoffset;
      }
#line 331
      if (! psf->sf.seekable) {
#line 332
        goto switch_break;
      } else
#line 331
      if (psf->dataoffset < 0L) {
#line 332
        goto switch_break;
      }
      {
#line 335
      psf_fseek(psf, psf->datalength, 1);
#line 337
      __cil_tmp32 = psf_ftell(psf);
      }
#line 337
      if (__cil_tmp32 != psf->datalength + psf->dataoffset) {
        {
#line 338
        psf_log_printf(psf, "  *** psf_fseek past end error ***\n");
        }
      }
    }
#line 340
    goto switch_break;
    switch_default: 
#line 343
    if (chunk_size >= 4294901760U) {
      {
#line 344
      __cil_tmp33 = psf_ftell(psf);
#line 344
      psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D with length %u. Exiting parser.\n",
                     marker, __cil_tmp33 - 8L, chunk_size);
#line 345
      done = 1;
      }
#line 346
      goto switch_break;
    }
    {
#line 349
    __cil_tmp37 = __ctype_b_loc();
#line 349
    __cil_tmp36 = __ctype_b_loc();
#line 349
    __cil_tmp35 = __ctype_b_loc();
#line 349
    __cil_tmp34 = __ctype_b_loc();
    }
#line 349
    if ((int )*(*__cil_tmp34 + (int )((marker >> 24) & 255U)) & 16384) {
#line 349
      if ((int )*(*__cil_tmp35 + (int )((marker >> 16) & 255U)) & 16384) {
#line 349
        if ((int )*(*__cil_tmp36 + (int )((marker >> 8) & 255U)) & 16384) {
#line 349
          if ((int )*(*__cil_tmp37 + (int )(marker & 255U)) & 16384) {
            {
#line 351
            psf_log_printf(psf, "*** %M : %d (unknown marker)\n", marker, chunk_size);
#line 352
            psf_binheader_readf(psf, "j", chunk_size);
            }
#line 353
            goto switch_break;
          }
        }
      }
    }
    {
#line 355
    __cil_tmp38 = psf_ftell(psf);
    }
#line 355
    if (__cil_tmp38 & 3L) {
      {
#line 356
      psf_log_printf(psf, "  Unknown chunk marker at position 0x%x. Resynching.\n",
                     chunk_size - 4U);
#line 357
      psf_binheader_readf(psf, "j", -3);
      }
#line 358
      goto switch_break;
    }
    {
#line 360
    __cil_tmp39 = psf_ftell(psf);
#line 360
    psf_log_printf(psf, "*** Unknown chunk marker (0x%X) at position 0x%X. Exiting parser.\n",
                   marker, __cil_tmp39 - 4L);
#line 361
    done = 1;
    }
#line 362
    goto switch_break;
    switch_break: ;
#line 368
    if (marker != ((unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24))) {
#line 368
      if ((long )chunk_size >= psf->filelength) {
        {
#line 369
        psf_log_printf(psf, "*** Chunk size %u > file length %D. Exiting parser.\n",
                       chunk_size, psf->filelength);
        }
#line 370
        goto while_break;
      }
    }
    {
#line 373
    __cil_tmp40 = psf_ftell(psf);
    }
#line 373
    if (__cil_tmp40 >= psf->filelength - (long )((int )sizeof(marker))) {
      {
#line 374
      psf_log_printf(psf, "End\n");
      }
#line 375
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 379
  if (psf->dataoffset <= 0L) {
#line 380
    return (166);
  }
#line 382
  if (psf->sf.channels < 1) {
#line 383
    return (33);
  }
#line 385
  if (psf->sf.channels >= 1024) {
#line 386
    return (34);
  }
  {
#line 389
  psf->endian = psf->rwf_endian;
#line 391
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 393
  if (psf->is_pipe == 0) {
    {
#line 398
    psf_binheader_readf(psf, "4", & marker);
    }
#line 399
    if (marker == ((unsigned int )((119 | (118 << 8)) | (112 << 16)) | (107U << 24))) {
#line 400
      return (79);
    } else
#line 399
    if (marker == ((unsigned int )((79 | (103 << 8)) | (103 << 16)) | (83U << 24))) {
#line 400
      return (79);
    }
  }
  {
#line 404
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 406
  if (psf->blockwidth) {
#line 407
    if (psf->filelength - psf->dataoffset < psf->datalength) {
#line 408
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    } else {
#line 410
      psf->sf.frames = psf->datalength / (long )psf->blockwidth;
    }
  }
#line 413
  if (frame_count != psf->sf.frames) {
    {
#line 414
    psf_log_printf(psf, "*** Calculated frame count %d does not match value from \'ds64\' chunk of %d.\n",
                   psf->sf.frames, frame_count);
    }
  }
#line 418
  if (format == 65534) {
#line 418
    goto case_65534;
  }
#line 429
  if (format == 1) {
#line 429
    goto case_1;
  }
#line 434
  if (format == 257) {
#line 434
    goto case_257;
  }
#line 434
  if (format == 7) {
#line 434
    goto case_257;
  }
#line 439
  if (format == 258) {
#line 439
    goto case_258;
  }
#line 439
  if (format == 6) {
#line 439
    goto case_258;
  }
#line 443
  if (format == 2) {
#line 443
    goto case_2;
  }
#line 449
  if (format == 17) {
#line 449
    goto case_17;
  }
#line 455
  if (format == 49) {
#line 455
    goto case_49;
  }
#line 459
  if (format == 3) {
#line 459
    goto case_3;
  }
#line 464
  if (format == 64) {
#line 464
    goto case_64;
  }
#line 468
  goto switch_default___0;
  case_65534: 
#line 421
  psf->sf.format = (psf->sf.format & -268369921) | 2228224;
#line 423
  if (psf->sf.format == 1245203) {
#line 424
    *blockalign = (int )wav_fmt->msadpcm.blockalign;
#line 425
    *framesperblock = (int )wav_fmt->msadpcm.samplesperblock;
  }
#line 427
  goto switch_break___0;
  case_1: 
  {
#line 430
  __cil_tmp41 = u_bitwidth_to_subformat(psf->bytewidth * 8);
#line 430
  psf->sf.format = 2228224 | __cil_tmp41;
  }
#line 431
  goto switch_break___0;
  case_257: 
#line 435
  psf->sf.format = 2228240;
#line 436
  goto switch_break___0;
  case_258: 
#line 440
  psf->sf.format = 2228241;
#line 441
  goto switch_break___0;
  case_2: 
#line 444
  psf->sf.format = 2228243;
#line 445
  *blockalign = (int )wav_fmt->msadpcm.blockalign;
#line 446
  *framesperblock = (int )wav_fmt->msadpcm.samplesperblock;
#line 447
  goto switch_break___0;
  case_17: 
#line 450
  psf->sf.format = 2228242;
#line 451
  *blockalign = (int )wav_fmt->ima.blockalign;
#line 452
  *framesperblock = (int )wav_fmt->ima.samplesperblock;
#line 453
  goto switch_break___0;
  case_49: 
#line 456
  psf->sf.format = 2228256;
#line 457
  goto switch_break___0;
  case_3: 
#line 460
  psf->sf.format = 2228224;
#line 461
  if (psf->bytewidth == 8) {
#line 461
    tmp___0 = 7;
  } else {
#line 461
    tmp___0 = 6;
  }
#line 461
  psf->sf.format |= tmp___0;
#line 462
  goto switch_break___0;
  case_64: 
#line 465
  psf->sf.format = 2228272;
#line 466
  goto switch_break___0;
  switch_default___0: 
#line 468
  return (18);
  switch_break___0: ;
#line 471
  if (wpriv->fmt_is_broken) {
    {
#line 472
    wavlike_analyze(psf);
    }
  }
#line 475
  if (psf->endian == 536870912) {
#line 476
    psf->sf.format |= 536870912;
  }
#line 478
  return (0);
}
}
#line 482 "/root/patchweave_new/23/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_PCM  =    {1U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 492 "/root/patchweave_new/23/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_IEEE_FLOAT  =    {3U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 496 "/root/patchweave_new/23/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_ALAW  =    {6U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 500 "/root/patchweave_new/23/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_MULAW  =    {7U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 508 "/root/patchweave_new/23/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM  =    {1U, (unsigned short)1825, (unsigned short)4563, {(char)-122, (char)68, (char)-56,
                                                     (char)-63, (char)-54, (char)0,
                                                     (char)0, (char)0}};
#line 512 "/root/patchweave_new/23/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT  =    {3U, (unsigned short)1825, (unsigned short)4563, {(char)-122, (char)68, (char)-56,
                                                     (char)-63, (char)-54, (char)0,
                                                     (char)0, (char)0}};
#line 518 "/root/patchweave_new/23/src/rf64.c"
static int rf64_write_fmt_chunk(SF_PRIVATE *psf ) 
{ 
  WAVLIKE_PRIVATE *wpriv ;
  int subformat ;
  int fmt_size ;
  EXT_SUBFORMAT *tmp ;
  EXT_SUBFORMAT *tmp___0 ;

  {
#line 522
  wpriv = (WAVLIKE_PRIVATE *)psf->container_data;
#line 522
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 523
    return (30);
  }
#line 525
  subformat = psf->sf.format & 65535;
#line 536
  if (subformat == 17) {
#line 536
    goto case_17;
  }
#line 536
  if (subformat == 16) {
#line 536
    goto case_17;
  }
#line 536
  if (subformat == 7) {
#line 536
    goto case_17;
  }
#line 536
  if (subformat == 6) {
#line 536
    goto case_17;
  }
#line 536
  if (subformat == 4) {
#line 536
    goto case_17;
  }
#line 536
  if (subformat == 3) {
#line 536
    goto case_17;
  }
#line 536
  if (subformat == 2) {
#line 536
    goto case_17;
  }
#line 536
  if (subformat == 5) {
#line 536
    goto case_17;
  }
#line 566
  if (subformat == 1) {
#line 566
    goto case_1;
  }
#line 570
  if (subformat == 2) {
#line 570
    goto case_2___0;
  }
#line 574
  if (subformat == 4) {
#line 574
    goto case_4___0;
  }
#line 578
  if (subformat == 6) {
#line 578
    goto case_6___0;
  }
#line 582
  if (subformat == 8) {
#line 582
    goto case_8;
  }
#line 594
  goto switch_default___0;
  case_17: 
  {
#line 537
  fmt_size = 40;
#line 540
  psf_binheader_writef(psf, "4224", fmt_size, 65534, psf->sf.channels, psf->sf.samplerate);
#line 542
  psf_binheader_writef(psf, "4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 544
  psf_binheader_writef(psf, "22", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
#line 547
  psf_binheader_writef(psf, "23+E\270U", 22);
#line 550
  psf_binheader_writef(psf, "2", psf->bytewidth * 8);
  }
#line 555
  if (wpriv->wavex_ambisonic != 64) {
    {
#line 556
    psf_binheader_writef(psf, "4", 0);
    }
  } else
#line 557
  if (wpriv->wavex_channelmask != 0U) {
    {
#line 558
    psf_binheader_writef(psf, "4", wpriv->wavex_channelmask);
    }
  } else {
#line 566
    if (psf->sf.channels == 1) {
#line 566
      goto case_1;
    }
#line 570
    if (psf->sf.channels == 2) {
#line 570
      goto case_2___0;
    }
#line 574
    if (psf->sf.channels == 4) {
#line 574
      goto case_4___0;
    }
#line 578
    if (psf->sf.channels == 6) {
#line 578
      goto case_6___0;
    }
#line 582
    if (psf->sf.channels == 8) {
#line 582
      goto case_8;
    }
#line 586
    goto switch_default;
    case_1: 
    {
#line 567
    psf_binheader_writef(psf, "4", 4);
    }
#line 568
    goto switch_break___0;
    case_2___0: 
    {
#line 571
    psf_binheader_writef(psf, "4", 3);
    }
#line 572
    goto switch_break___0;
    case_4___0: 
    {
#line 575
    psf_binheader_writef(psf, "4(+E\270U", 51);
    }
#line 576
    goto switch_break___0;
    case_6___0: 
    {
#line 579
    psf_binheader_writef(psf, "4", 63);
    }
#line 580
    goto switch_break___0;
    case_8: 
    {
#line 583
    psf_binheader_writef(psf, "4$+E\270U", 255);
    }
#line 584
    goto switch_break___0;
    switch_default: 
    {
#line 587
    psf_binheader_writef(psf, "4", 0);
    }
#line 588
    goto switch_break___0;
    switch_break___0: ;
  }
#line 591
  goto switch_break;
  switch_default___0: 
#line 595
  return (18);
  switch_break: ;
#line 604
  if (subformat == 4) {
#line 604
    goto case_4___1;
  }
#line 604
  if (subformat == 3) {
#line 604
    goto case_4___1;
  }
#line 604
  if (subformat == 2) {
#line 604
    goto case_4___1;
  }
#line 604
  if (subformat == 5) {
#line 604
    goto case_4___1;
  }
#line 610
  if (subformat == 7) {
#line 610
    goto case_7___0;
  }
#line 610
  if (subformat == 6) {
#line 610
    goto case_7___0;
  }
#line 615
  if (subformat == 16) {
#line 615
    goto case_16___0;
  }
#line 619
  if (subformat == 17) {
#line 619
    goto case_17___0;
  }
#line 623
  goto switch_default___1;
  case_4___1: 
#line 605
  if (wpriv->wavex_ambisonic == 64) {
#line 605
    tmp = & MSGUID_SUBTYPE_PCM;
  } else {
#line 605
    tmp = & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM;
  }
  {
#line 605
  wavlike_write_guid(psf, tmp);
  }
#line 607
  goto switch_break___1;
  case_7___0: 
#line 611
  if (wpriv->wavex_ambisonic == 64) {
#line 611
    tmp___0 = & MSGUID_SUBTYPE_IEEE_FLOAT;
  } else {
#line 611
    tmp___0 = & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT;
  }
  {
#line 611
  wavlike_write_guid(psf, tmp___0);
  }
#line 613
  goto switch_break___1;
  case_16___0: 
  {
#line 616
  wavlike_write_guid(psf, & MSGUID_SUBTYPE_MULAW);
  }
#line 617
  goto switch_break___1;
  case_17___0: 
  {
#line 620
  wavlike_write_guid(psf, & MSGUID_SUBTYPE_ALAW);
  }
#line 621
  goto switch_break___1;
  switch_default___1: 
#line 623
  return (18);
  switch_break___1: ;
#line 626
  return (0);
}
}
#line 631 "/root/patchweave_new/23/src/rf64.c"
static int rf64_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  sf_count_t pad_size ;
  int error ;
  int has_data ;
  int add_fact_chunk ;
  WAVLIKE_PRIVATE *wpriv ;
  long tmp ;
  size_t __cil_tmp13 ;

  {
#line 633
  error = 0;
#line 633
  has_data = 0;
#line 633
  add_fact_chunk = 0;
#line 636
  wpriv = (WAVLIKE_PRIVATE *)psf->container_data;
#line 636
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 637
    return (30);
  }
  {
#line 639
  current = psf_ftell(psf);
  }
#line 641
  if (psf->dataoffset > 0L) {
#line 641
    if (current > psf->dataoffset) {
#line 642
      has_data = 1;
    }
  }
#line 644
  if (calc_length) {
    {
#line 645
    psf->filelength = psf_get_filelen(psf);
#line 646
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 648
    if (psf->dataend) {
#line 649
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 651
    if (psf->bytewidth > 0) {
#line 652
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
  {
#line 656
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 657
  psf->header.indx = (sf_count_t )0;
#line 658
  psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 660
  if (wpriv->rf64_downgrade) {
#line 660
    if (psf->filelength < 4294967295L) {
#line 661
      if (psf->filelength < 8L) {
#line 661
        tmp = 8L;
      } else {
#line 661
        tmp = psf->filelength - 8L;
      }
      {
#line 661
      psf_binheader_writef(psf, "etm8mU", (unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24),
                           tmp, (unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24));
#line 662
      psf_binheader_writef(psf, "m4884", (unsigned int )((74 | (85 << 8)) | (78 << 16)) | (75U << 24),
                           20, 0, 0, 0, 0);
#line 663
      add_fact_chunk = 1;
      }
    } else {
      {
#line 666
      psf_binheader_writef(psf, "em4m\270U", (unsigned int )((82 | (70 << 8)) | (54 << 16)) | (52U << 24),
                           4294967295U, (unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24));
#line 668
      psf_binheader_writef(psf, "m48884", (unsigned int )((100 | (115 << 8)) | (54 << 16)) | (52U << 24),
                           28, psf->filelength - 8L, psf->datalength, psf->sf.frames,
                           0);
      }
    }
  } else {
    {
#line 666
    psf_binheader_writef(psf, "em4m\270U", (unsigned int )((82 | (70 << 8)) | (54 << 16)) | (52U << 24),
                         4294967295U, (unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24));
#line 668
    psf_binheader_writef(psf, "m48884", (unsigned int )((100 | (115 << 8)) | (54 << 16)) | (52U << 24),
                         28, psf->filelength - 8L, psf->datalength, psf->sf.frames,
                         0);
    }
  }
  {
#line 672
  psf_binheader_writef(psf, "m\327+E\270U", (unsigned int )((102 | (109 << 8)) | (116 << 16)) | (32U << 24));
  }
#line 676
  if ((psf->sf.format & 268369920) == 65536) {
#line 676
    goto case_65536;
  }
#line 682
  if ((psf->sf.format & 268369920) == 2228224) {
#line 682
    goto case_2228224;
  }
#line 682
  if ((psf->sf.format & 268369920) == 1245184) {
#line 682
    goto case_2228224;
  }
#line 689
  goto switch_default;
  case_65536: 
  {
#line 677
  psf_log_printf(psf, "ooops SF_FORMAT_WAV\n\270U");
  }
#line 678
  return (18);
#line 679
  goto switch_break;
  case_2228224: 
  {
#line 683
  error = rf64_write_fmt_chunk(psf);
  }
#line 683
  if (error != 0) {
#line 684
    return (error);
  }
#line 685
  if (add_fact_chunk) {
    {
#line 686
    psf_binheader_writef(psf, "tm48", (unsigned int )((102 | (97 << 8)) | (99 << 16)) | (116U << 24),
                         4, psf->sf.frames);
    }
  }
#line 687
  goto switch_break;
  switch_default: 
#line 690
  return (18);
  switch_break: ;
#line 693
  if ((unsigned long )psf->broadcast_16k != (unsigned long )((void *)0)) {
    {
#line 694
    wavlike_write_bext_chunk(psf);
    }
  }
#line 696
  if ((unsigned long )psf->cart_16k != (unsigned long )((void *)0)) {
    {
#line 697
    wavlike_write_cart_chunk(psf);
    }
  }
#line 700
  if (psf->strings.flags & 1024U) {
    {
#line 701
    wavlike_write_strings(psf, 1024);
    }
  }
#line 703
  if ((unsigned long )psf->peak_info != (unsigned long )((void *)0)) {
#line 703
    if ((psf->peak_info)->peak_loc == 42) {
      {
#line 704
      wavlike_write_peak_chunk(psf);
      }
    }
  }
#line 707
  if (psf->wchunks.used > 0U) {
    {
#line 708
    wavlike_write_custom_chunks(psf);
    }
  }
#line 738
  pad_size = (psf->dataoffset - 16L) - psf->header.indx;
#line 739
  if (pad_size >= 0L) {
    {
#line 740
    __cil_tmp13 = make_size_t((int )pad_size);
#line 740
    psf_binheader_writef(psf, "m4z", (unsigned int )((80 | (65 << 8)) | (68 << 16)) | (32U << 24),
                         pad_size, __cil_tmp13);
    }
  }
#line 742
  if (wpriv->rf64_downgrade) {
#line 742
    if (psf->filelength < 4294967295L) {
      {
#line 743
      psf_binheader_writef(psf, "tm8E\270U", (unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24),
                           psf->datalength);
      }
    } else {
      {
#line 745
      psf_binheader_writef(psf, "m4+E\270U", (unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24),
                           4294967295U);
      }
    }
  } else {
    {
#line 745
    psf_binheader_writef(psf, "m4+E\270U", (unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24),
                         4294967295U);
    }
  }
  {
#line 747
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 748
  if (psf->error) {
#line 749
    return (psf->error);
  }
#line 751
  if (has_data) {
#line 751
    if (psf->dataoffset != psf->header.indx) {
      {
#line 752
      psf_log_printf(psf, "Oooops : has_data && psf->dataoffset != psf->header.indx\n");
#line 753
      psf->error = 30;
      }
#line 753
      return (psf->error);
    }
  }
#line 756
  psf->dataoffset = psf->header.indx;
#line 758
  if (! has_data) {
    {
#line 759
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 760
  if (current > 0L) {
    {
#line 761
    psf_fseek(psf, current, 0);
    }
  }
#line 763
  return (psf->error);
}
}
#line 767 "/root/patchweave_new/23/src/rf64.c"
static int rf64_write_tailer(SF_PRIVATE *psf ) 
{ 


  {
#line 770
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 771
  psf->header.indx = (sf_count_t )0;
#line 773
  if (psf->bytewidth > 0) {
#line 773
    if (psf->sf.seekable == 1) {
#line 774
      psf->datalength = (psf->sf.frames * (long )psf->bytewidth) * (long )psf->sf.channels;
#line 775
      psf->dataend = psf->dataoffset + psf->datalength;
    }
  }
#line 778
  if (psf->dataend > 0L) {
    {
#line 779
    psf_fseek(psf, psf->dataend, 0);
    }
  } else {
    {
#line 781
    psf->dataend = psf_fseek(psf, (sf_count_t )0, 2);
    }
  }
#line 783
  if (psf->dataend & 1L) {
    {
#line 784
    psf_binheader_writef(psf, "z", 1);
    }
  }
#line 786
  if (psf->strings.flags & 2048U) {
    {
#line 787
    wavlike_write_strings(psf, 2048);
    }
  }
#line 790
  if (psf->header.indx > 0L) {
    {
#line 791
    psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1,
               psf);
    }
  }
#line 793
  return (0);
}
}
#line 797 "/root/patchweave_new/23/src/rf64.c"
static int rf64_close(SF_PRIVATE *psf ) 
{ 


  {
#line 799
  if (psf->file.mode == 32) {
    {
#line 800
    rf64_write_tailer(psf);
#line 801
    rf64_write_header(psf, 1);
    }
  } else
#line 799
  if (psf->file.mode == 48) {
    {
#line 800
    rf64_write_tailer(psf);
#line 801
    rf64_write_header(psf, 1);
    }
  }
#line 804
  return (0);
}
}
#line 808 "/root/patchweave_new/23/src/rf64.c"
static int rf64_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int datasize ) 
{ 
  WAVLIKE_PRIVATE *wpriv ;
  int __cil_tmp6 ;
  int tmp ;

  {
#line 811
  wpriv = (WAVLIKE_PRIVATE *)psf->container_data;
#line 811
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 812
    return (30);
  }
#line 815
  if (command == 4608) {
#line 815
    goto case_4608;
  }
#line 826
  if (command == 4609) {
#line 826
    goto case_4609;
  }
#line 829
  if (command == 4353) {
#line 829
    goto case_4353;
  }
#line 833
  if (command == 4624) {
#line 833
    goto case_4624;
  }
#line 838
  goto switch_default;
  case_4608: 
#line 816
  if ((psf->sf.format & 268369920) == 1245184) {
#line 817
    if (datasize == 64) {
#line 818
      wpriv->wavex_ambisonic = 64;
    } else
#line 819
    if (datasize == 65) {
#line 820
      wpriv->wavex_ambisonic = 65;
    } else {
#line 822
      return (0);
    }
  }
#line 824
  return (wpriv->wavex_ambisonic);
  case_4609: 
#line 827
  return (wpriv->wavex_ambisonic);
  case_4353: 
  {
#line 830
  __cil_tmp6 = wavlike_gen_channel_mask((int const   *)psf->channel_map, psf->sf.channels);
#line 830
  wpriv->wavex_channelmask = (unsigned int )__cil_tmp6;
  }
#line 831
  return (wpriv->wavex_channelmask != 0U);
  case_4624: 
#line 834
  if (psf->have_written == 0) {
#line 835
    if (datasize) {
#line 835
      tmp = 1;
    } else {
#line 835
      tmp = 0;
    }
#line 835
    wpriv->rf64_downgrade = tmp;
  }
#line 836
  return (wpriv->rf64_downgrade);
  switch_default: 
#line 839
  goto switch_break;
  switch_break: ;
#line 842
  return (0);
}
}
#line 846 "/root/patchweave_new/23/src/rf64.c"
static int rf64_set_chunk(SF_PRIVATE *psf , SF_CHUNK_INFO *chunk_info ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 847
  __cil_tmp3 = psf_save_write_chunk(& psf->wchunks, chunk_info);
  }
#line 847
  return (__cil_tmp3);
}
}
#line 851 "/root/patchweave_new/23/src/rf64.c"
static SF_CHUNK_ITERATOR *rf64_next_chunk_iterator(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator ) 
{ 
  SF_CHUNK_ITERATOR *__cil_tmp3 ;

  {
  {
#line 852
  __cil_tmp3 = psf_next_chunk_iterator(& psf->rchunks, iterator);
  }
#line 852
  return (__cil_tmp3);
}
}
#line 856 "/root/patchweave_new/23/src/rf64.c"
static int rf64_get_chunk_size(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  int indx ;

  {
  {
#line 859
  indx = psf_find_read_chunk_iterator(& psf->rchunks, iterator);
  }
#line 859
  if (indx < 0) {
#line 860
    return (168);
  }
#line 862
  chunk_info->datalen = (psf->rchunks.chunks + indx)->len;
#line 864
  return (0);
}
}
#line 868 "/root/patchweave_new/23/src/rf64.c"
static int rf64_get_chunk_data(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  int indx ;
  sf_count_t pos ;

  {
  {
#line 872
  indx = psf_find_read_chunk_iterator(& psf->rchunks, iterator);
  }
#line 872
  if (indx < 0) {
#line 873
    return (168);
  }
#line 875
  if ((unsigned long )chunk_info->data == (unsigned long )((void *)0)) {
#line 876
    return (171);
  }
  {
#line 878
  chunk_info->id_size = (psf->rchunks.chunks + indx)->id_size;
#line 879
  memcpy((void *)(chunk_info->id), (void const   *)((psf->rchunks.chunks + indx)->id),
         sizeof(chunk_info->id) / sizeof(chunk_info->id[0]));
#line 881
  pos = psf_ftell(psf);
#line 882
  psf_fseek(psf, (psf->rchunks.chunks + indx)->offset, 0);
#line 883
  psf_fread(chunk_info->data, (sf_count_t )0, (sf_count_t )1, psf);
#line 884
  psf_fseek(psf, pos, 0);
  }
#line 886
  return (0);
}
}
#line 55 "/root/patchweave_new/23/src/mpc2k.c"
static int mpc2k_close(SF_PRIVATE *psf ) ;
#line 57
static int mpc2k_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 58
static int mpc2k_read_header(SF_PRIVATE *psf ) ;
#line 65 "/root/patchweave_new/23/src/mpc2k.c"
int mpc2k_open(SF_PRIVATE *psf ) 
{ 
  int error ;
  int __cil_tmp4 ;

  {
#line 66
  error = 0;
#line 68
  if (psf->file.mode == 16) {
    _L: 
    {
#line 69
    error = mpc2k_read_header(psf);
    }
#line 69
    if (error) {
#line 70
      return (error);
    }
  } else
#line 68
  if (psf->file.mode == 48) {
#line 68
    if (psf->filelength > 0L) {
#line 68
      goto _L;
    }
  }
#line 73
  if ((psf->sf.format & 268369920) != 2162688) {
#line 74
    return (1);
  }
#line 76
  if (psf->file.mode == 32) {
    _L___10: 
    {
#line 77
    __cil_tmp4 = mpc2k_write_header(psf, 0);
    }
#line 77
    if (__cil_tmp4) {
#line 78
      return (psf->error);
    }
#line 80
    psf->write_header = & mpc2k_write_header;
  } else
#line 76
  if (psf->file.mode == 48) {
#line 76
    goto _L___10;
  }
  {
#line 83
  psf->container_close = & mpc2k_close;
#line 85
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 87
  error = pcm_init(psf);
  }
#line 89
  return (error);
}
}
#line 96 "/root/patchweave_new/23/src/mpc2k.c"
static int mpc2k_close(SF_PRIVATE *psf ) 
{ 


  {
#line 98
  if (psf->file.mode == 32) {
    {
#line 99
    mpc2k_write_header(psf, 1);
    }
  } else
#line 98
  if (psf->file.mode == 48) {
    {
#line 99
    mpc2k_write_header(psf, 1);
    }
  }
#line 101
  return (0);
}
}
#line 105 "/root/patchweave_new/23/src/mpc2k.c"
static int mpc2k_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  char sample_name[18] ;
  sf_count_t current ;
  size_t __cil_tmp7 ;

  {
#line 109
  if (psf->pipeoffset > 0L) {
#line 110
    return (0);
  }
  {
#line 112
  current = psf_ftell(psf);
  }
#line 114
  if (calc_length) {
    {
#line 115
    psf->filelength = psf_get_filelen(psf);
#line 117
    psf->dataoffset = (sf_count_t )42;
#line 118
    psf->datalength = psf->filelength - psf->dataoffset;
#line 120
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
#line 124
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 125
  psf->header.indx = (sf_count_t )0;
#line 131
  if (psf->is_pipe == 0) {
    {
#line 132
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
  {
#line 134
  snprintf(sample_name, sizeof(sample_name), "%s                    ", psf->file.name.c);
#line 136
  __cil_tmp7 = make_size_t(17);
#line 136
  psf_binheader_writef(psf, "e11b", 1, 4, sample_name, __cil_tmp7);
#line 137
  psf_binheader_writef(psf, "e111\270U", 100, 0, (psf->sf.channels - 1) & 1);
#line 138
  psf_binheader_writef(psf, "et4888", 0, psf->sf.frames, psf->sf.frames, psf->sf.frames);
#line 139
  psf_binheader_writef(psf, "e112", 0, 1, (int )((uint16_t )psf->sf.samplerate));
#line 142
  psf->bytewidth = 2;
#line 143
  psf->endian = 268435456;
#line 145
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 147
  if (psf->error) {
#line 148
    return (psf->error);
  }
#line 150
  psf->dataoffset = psf->header.indx;
#line 152
  if (current > 0L) {
    {
#line 153
    psf_fseek(psf, current, 0);
    }
  }
#line 155
  return (psf->error);
}
}
#line 159 "/root/patchweave_new/23/src/mpc2k.c"
static int mpc2k_read_header(SF_PRIVATE *psf ) 
{ 
  char sample_name[18] ;
  unsigned char bytes[4] ;
  uint32_t sample_start ;
  uint32_t loop_end ;
  uint32_t sample_frames ;
  uint32_t loop_length ;
  uint16_t sample_rate ;
  size_t __cil_tmp9 ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 165
  __cil_tmp9 = make_size_t(17);
#line 165
  psf_binheader_readf(psf, "pebb", 0, bytes, 2, sample_name, __cil_tmp9);
  }
#line 167
  if ((int )bytes[0] != 1) {
#line 168
    return (666);
  } else
#line 167
  if ((int )bytes[1] != 4) {
#line 168
    return (666);
  }
  {
#line 170
  sample_name[17] = (char)0;
#line 172
  psf_log_printf(psf, "MPC2000\n  Name         : %s\n", sample_name);
#line 174
  psf_binheader_readf(psf, "eb4444", bytes, 3, & sample_start, & loop_end, & sample_frames,
                      & loop_length);
  }
#line 176
  if ((int )bytes[2]) {
#line 176
    tmp = 2;
  } else {
#line 176
    tmp = 1;
  }
#line 176
  psf->sf.channels = tmp;
#line 178
  if ((int )bytes[2]) {
#line 178
    tmp___0 = "Yes";
  } else {
#line 178
    tmp___0 = "No";
  }
  {
#line 178
  psf_log_printf(psf, "  Level        : %d\n  Tune         : %d\n  Stereo       : %s\n",
                 (int )bytes[0], (int )bytes[1], tmp___0);
#line 180
  psf_log_printf(psf, "  Sample start : %d\n  Loop end     : %d\n  Frames       : %d\n  Length       : %d\n\230\001",
                 sample_start, loop_end, sample_frames, loop_length);
#line 182
  psf_binheader_readf(psf, "eb2E\270U", bytes, 2, & sample_rate);
  }
#line 184
  if ((int )bytes[0]) {
#line 184
    tmp___1 = "None";
  } else {
#line 184
    tmp___1 = "Fwd";
  }
  {
#line 184
  psf_log_printf(psf, "  Loop mode    : %s\n  Beats        : %d\n  Sample rate  : %d\nEnd\n\230\001",
                 tmp___1, (int )bytes[1], (int )sample_rate);
#line 186
  psf->sf.samplerate = (int )sample_rate;
#line 188
  psf->sf.format = 2162690;
#line 190
  psf->dataoffset = psf_ftell(psf);
#line 193
  psf->bytewidth = 2;
#line 194
  psf->endian = 268435456;
#line 196
  psf->datalength = psf->filelength - psf->dataoffset;
#line 197
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 198
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
#line 200
  psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
  }
#line 202
  return (0);
}
}
#line 51 "/root/patchweave_new/23/src/xi.c"
static int xi_close(SF_PRIVATE *UNUSED_psf ) ;
#line 52
static int xi_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 53
static int xi_read_header(SF_PRIVATE *psf ) ;
#line 54
static int dpcm_init(SF_PRIVATE *psf ) ;
#line 57
static sf_count_t dpcm_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 64 "/root/patchweave_new/23/src/xi.c"
int xi_open(SF_PRIVATE *psf ) 
{ 
  XI_PRIVATE *pxi ;
  int subformat ;
  int error ;
  int tmp ;
  int __cil_tmp8 ;
  void *tmp___0 ;

  {
#line 66
  error = 0;
#line 68
  if (psf->is_pipe) {
#line 69
    return (143);
  }
#line 71
  if (psf->codec_data) {
#line 72
    pxi = (XI_PRIVATE *)psf->codec_data;
  } else {
    {
#line 73
    tmp___0 = calloc(1UL, sizeof(XI_PRIVATE ));
#line 73
    pxi = (XI_PRIVATE *)tmp___0;
    }
#line 73
    if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 74
      return (17);
    }
  }
#line 76
  psf->codec_data = (void *)pxi;
#line 78
  if (psf->file.mode == 16) {
    _L: 
    {
#line 79
    error = xi_read_header(psf);
    }
#line 79
    if (error) {
#line 80
      return (error);
    }
  } else
#line 78
  if (psf->file.mode == 48) {
#line 78
    if (psf->filelength > 0L) {
#line 78
      goto _L;
    }
  }
#line 83
  subformat = psf->sf.format & 65535;
#line 85
  if (psf->file.mode == 32) {
    _L___11: 
#line 86
    if ((psf->sf.format & 268369920) != 983040) {
#line 87
      return (1);
    }
    {
#line 89
    psf->endian = 268435456;
#line 90
    psf->sf.channels = 1;
#line 91
    psf->sf.samplerate = 44100;
#line 94
    memcpy((void *)(pxi->filename), (void const   *)"Default Name            \230\001\200",
           sizeof(pxi->filename));
#line 95
    memcpy((void *)(pxi->software), (void const   *)"libsndfile-1.0.29pre1               \230\001\200",
           sizeof(pxi->software));
#line 97
    memset((void *)(pxi->sample_name), 0, sizeof(pxi->sample_name));
#line 98
    snprintf(pxi->sample_name, sizeof(pxi->sample_name), "%sxE\270U", "Sample #1QxE\270U");
    }
#line 100
    if (subformat == 81) {
#line 100
      tmp = 16;
    } else {
#line 100
      tmp = 0;
    }
    {
#line 100
    pxi->sample_flags = tmp;
#line 102
    __cil_tmp8 = xi_write_header(psf, 0);
    }
#line 102
    if (__cil_tmp8) {
#line 103
      return (psf->error);
    }
#line 105
    psf->write_header = & xi_write_header;
  } else
#line 85
  if (psf->file.mode == 48) {
#line 85
    goto _L___11;
  }
#line 108
  psf->container_close = & xi_close;
#line 109
  psf->seek = & dpcm_seek;
#line 111
  psf->sf.seekable = 0;
#line 113
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 117
  if (subformat == 81) {
#line 117
    goto case_81;
  }
#line 117
  if (subformat == 80) {
#line 117
    goto case_81;
  }
#line 121
  goto switch_default;
  case_81: 
  {
#line 118
  error = dpcm_init(psf);
  }
#line 119
  goto switch_break;
  switch_default: 
#line 121
  goto switch_break;
  switch_break: ;
#line 124
  return (error);
}
}
#line 131 "/root/patchweave_new/23/src/xi.c"
static int xi_close(SF_PRIVATE *UNUSED_psf ) 
{ 


  {
#line 133
  return (0);
}
}
#line 139
static sf_count_t dpcm_read_dsc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 140
static sf_count_t dpcm_read_dsc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 141
static sf_count_t dpcm_read_dsc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 142
static sf_count_t dpcm_read_dsc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 144
static sf_count_t dpcm_write_s2dsc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 145
static sf_count_t dpcm_write_i2dsc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 146
static sf_count_t dpcm_write_f2dsc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 147
static sf_count_t dpcm_write_d2dsc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 149
static sf_count_t dpcm_read_dles2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 150
static sf_count_t dpcm_read_dles2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 151
static sf_count_t dpcm_read_dles2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 152
static sf_count_t dpcm_read_dles2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 154
static sf_count_t dpcm_write_s2dles(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 155
static sf_count_t dpcm_write_i2dles(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 156
static sf_count_t dpcm_write_f2dles(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 157
static sf_count_t dpcm_write_d2dles(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 160 "/root/patchweave_new/23/src/xi.c"
static int dpcm_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t tmp ;

  {
#line 161
  if (psf->bytewidth == 0) {
#line 162
    return (30);
  } else
#line 161
  if (psf->sf.channels == 0) {
#line 162
    return (30);
  }
#line 164
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 166
  if (psf->file.mode == 16) {
    _L: 
#line 168
    if (psf->bytewidth == 1) {
#line 168
      goto case_1;
    }
#line 174
    if (psf->bytewidth == 2) {
#line 174
      goto case_2;
    }
#line 180
    goto switch_default;
    case_1: 
#line 169
    psf->read_short = & dpcm_read_dsc2s;
#line 170
    psf->read_int = & dpcm_read_dsc2i;
#line 171
    psf->read_float = & dpcm_read_dsc2f;
#line 172
    psf->read_double = & dpcm_read_dsc2d;
#line 173
    goto switch_break;
    case_2: 
#line 175
    psf->read_short = & dpcm_read_dles2s;
#line 176
    psf->read_int = & dpcm_read_dles2i;
#line 177
    psf->read_float = & dpcm_read_dles2f;
#line 178
    psf->read_double = & dpcm_read_dles2d;
#line 179
    goto switch_break;
    switch_default: 
    {
#line 181
    psf_log_printf(psf, "dpcm_init() returning SFE_UNIMPLEMENTED\n\272XxE\270U");
    }
#line 182
    return (18);
    switch_break: ;
  } else
#line 166
  if (psf->file.mode == 48) {
#line 166
    goto _L;
  }
#line 186
  if (psf->file.mode == 32) {
    _L___12: 
#line 188
    if (psf->bytewidth == 1) {
#line 188
      goto case_1___0;
    }
#line 194
    if (psf->bytewidth == 2) {
#line 194
      goto case_2___0;
    }
#line 200
    goto switch_default___0;
    case_1___0: 
#line 189
    psf->write_short = & dpcm_write_s2dsc;
#line 190
    psf->write_int = & dpcm_write_i2dsc;
#line 191
    psf->write_float = & dpcm_write_f2dsc;
#line 192
    psf->write_double = & dpcm_write_d2dsc;
#line 193
    goto switch_break___0;
    case_2___0: 
#line 195
    psf->write_short = & dpcm_write_s2dles;
#line 196
    psf->write_int = & dpcm_write_i2dles;
#line 197
    psf->write_float = & dpcm_write_f2dles;
#line 198
    psf->write_double = & dpcm_write_d2dles;
#line 199
    goto switch_break___0;
    switch_default___0: 
    {
#line 201
    psf_log_printf(psf, "dpcm_init() returning SFE_UNIMPLEMENTED\n\220");
    }
#line 202
    return (18);
    switch_break___0: ;
  } else
#line 186
  if (psf->file.mode == 48) {
#line 186
    goto _L___12;
  }
  {
#line 206
  psf->filelength = psf_get_filelen(psf);
  }
#line 207
  if (psf->dataend) {
#line 207
    tmp = psf->dataend - psf->dataoffset;
  } else {
#line 207
    tmp = psf->filelength - psf->dataoffset;
  }
#line 207
  psf->datalength = tmp;
#line 209
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
#line 211
  return (0);
}
}
#line 218 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int total ;
  int bufferlen ;
  int len ;
  int tmp ;
  sf_count_t __cil_tmp10 ;
  int tmp___0 ;
  sf_count_t __cil_tmp12 ;

  {
#line 223
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 223
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 224
    return ((sf_count_t )30);
  }
#line 226
  if (psf->datalength < 0L) {
#line 227
    psf->error = 40;
#line 228
    return ((sf_count_t )-1);
  } else
#line 226
  if (psf->dataoffset < 0L) {
#line 227
    psf->error = 40;
#line 228
    return ((sf_count_t )-1);
  }
#line 231
  if (offset == 0L) {
    {
#line 232
    psf_fseek(psf, psf->dataoffset, 0);
#line 233
    pxi->last_16 = (short)0;
    }
#line 234
    return ((sf_count_t )0);
  }
#line 237
  if (offset < 0L) {
#line 238
    psf->error = 40;
#line 239
    return ((sf_count_t )-1);
  } else
#line 237
  if (offset > psf->sf.frames) {
#line 238
    psf->error = 40;
#line 239
    return ((sf_count_t )-1);
  }
#line 242
  if (mode != 16) {
#line 244
    psf->error = 40;
#line 245
    return ((sf_count_t )-1);
  }
  {
#line 248
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 250
  if ((psf->sf.format & 65535) == 81) {
#line 251
    total = (int )offset;
#line 252
    bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
    {
#line 253
    while (1) {
      while_continue: /* CIL Label */ ;

#line 253
      if (! (total > 0)) {
#line 253
        goto while_break;
      }
#line 254
      if (total > bufferlen) {
#line 254
        tmp = bufferlen;
      } else {
#line 254
        tmp = total;
      }
      {
#line 254
      len = tmp;
#line 255
      __cil_tmp10 = dpcm_read_dles2s(psf, ubuf.sbuf, (sf_count_t )len);
#line 255
      total = (int )((sf_count_t )total - __cil_tmp10);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 259
    total = (int )offset;
#line 260
    bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
    {
#line 261
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 261
      if (! (total > 0)) {
#line 261
        goto while_break___0;
      }
#line 262
      if (total > bufferlen) {
#line 262
        tmp___0 = bufferlen;
      } else {
#line 262
        tmp___0 = total;
      }
      {
#line 262
      len = tmp___0;
#line 263
      __cil_tmp12 = dpcm_read_dsc2s(psf, ubuf.sbuf, (sf_count_t )len);
#line 263
      total = (int )((sf_count_t )total - __cil_tmp12);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 267
  return (offset);
}
}
#line 272 "/root/patchweave_new/23/src/xi.c"
static int xi_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  XI_PRIVATE *pxi ;
  sf_count_t current ;
  char const   *string ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;

  {
#line 277
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 277
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 278
    return (30);
  }
  {
#line 280
  current = psf_ftell(psf);
#line 283
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 284
  psf->header.indx = (sf_count_t )0;
#line 285
  psf_fseek(psf, (sf_count_t )0, 0);
#line 287
  string = "Extended Instrument: U";
#line 288
  __cil_tmp7 = strlen(string);
#line 288
  psf_binheader_writef(psf, "b\244xE\270U", string, __cil_tmp7);
#line 289
  psf_binheader_writef(psf, "b1xE\270U", pxi->filename, sizeof(pxi->filename), 26);
#line 292
  psf_binheader_writef(psf, "eb2E\270U", pxi->software, sizeof(pxi->software), (1 << 8) + 2);
#line 298
  psf_binheader_writef(psf, "z", (size_t )194);
#line 303
  __cil_tmp8 = make_size_t(22);
#line 303
  psf_binheader_writef(psf, "ez2z2U", (size_t )12, 4660, __cil_tmp8, 1);
#line 305
  pxi->loop_begin = 0;
#line 306
  pxi->loop_end = 0;
#line 308
  psf_binheader_writef(psf, "et844", psf->sf.frames, pxi->loop_begin, pxi->loop_end);
#line 311
  __cil_tmp9 = strlen((char const   *)(pxi->sample_name));
#line 311
  psf_binheader_writef(psf, "111111", 128, 0, pxi->sample_flags, 128, 0, __cil_tmp9);
#line 313
  psf_binheader_writef(psf, "b\224xE\270U", pxi->sample_name, sizeof(pxi->sample_name));
#line 320
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 322
  if (psf->error) {
#line 323
    return (psf->error);
  }
#line 325
  psf->dataoffset = psf->header.indx;
#line 327
  if (current > 0L) {
    {
#line 328
    psf_fseek(psf, current, 0);
    }
  }
#line 330
  return (psf->error);
}
}
#line 334 "/root/patchweave_new/23/src/xi.c"
static int xi_read_header(SF_PRIVATE *psf ) 
{ 
  char buffer[64] ;
  char name[32] ;
  short version ;
  short fade_out ;
  short sample_count ;
  int k ;
  int loop_begin ;
  int loop_end ;
  int sample_sizes[16] ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  char const   *tmp ;
  int tmp___0 ;
  short __cil_tmp18 ;
  sf_count_t __cil_tmp20 ;

  {
  {
#line 340
  psf_binheader_readf(psf, "pb", 0, buffer, 21);
#line 342
  memset((void *)(sample_sizes), 0, sizeof(sample_sizes));
#line 344
  buffer[20] = (char)0;
#line 345
  __cil_tmp11 = strcmp((char const   *)(buffer), "Extended Instrument:");
  }
#line 345
  if (__cil_tmp11 != 0) {
#line 346
    return (141);
  }
  {
#line 348
  memset((void *)(buffer), 0, sizeof(buffer));
#line 349
  psf_binheader_readf(psf, "b", buffer, 23);
  }
#line 351
  if ((int )buffer[22] != 26) {
#line 352
    return (141);
  }
#line 354
  buffer[22] = (char)0;
#line 355
  k = 21;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;

#line 355
    if (k >= 0) {
#line 355
      if (! ((int )buffer[k] == 32)) {
#line 355
        goto while_break;
      }
    } else {
#line 355
      goto while_break;
    }
#line 356
    buffer[k] = (char)0;
#line 355
    __cil_tmp12 = k;
#line 355
    k --;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 358
  psf_log_printf(psf, "Extended Instrument : %s\n\373xE\270U", buffer);
#line 359
  psf_store_string(psf, 1, (char const   *)(buffer));
#line 361
  psf_binheader_readf(psf, "be2", buffer, 20, & version);
#line 362
  buffer[19] = (char)0;
#line 363
  k = 18;
  }
  {
#line 363
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 363
    if (k >= 0) {
#line 363
      if (! ((int )buffer[k] == 32)) {
#line 363
        goto while_break___0;
      }
    } else {
#line 363
      goto while_break___0;
    }
#line 364
    buffer[k] = (char)0;
#line 363
    __cil_tmp13 = k;
#line 363
    k --;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 366
  psf_log_printf(psf, "Software : %s\nVersion  : %d.%02d\n\361xE\270U", buffer, (int )version / 256,
                 (int )version % 256);
#line 367
  psf_store_string(psf, 3, (char const   *)(buffer));
#line 372
  psf_binheader_readf(psf, "j", 194);
#line 374
  psf_binheader_readf(psf, "b\356xE\270U", buffer, 12);
#line 375
  psf_log_printf(psf, "Volume Loop\n  sustain : %u\n  begin   : %u\n  end     : %u\n\352xE\270U",
                 (int )buffer[0], (int )buffer[1], (int )buffer[2]);
#line 377
  psf_log_printf(psf, "Pan Loop\n  sustain : %u\n  begin   : %u\n  end     : %u\n",
                 (int )buffer[3], (int )buffer[4], (int )buffer[5]);
#line 379
  psf_log_printf(psf, "Envelope Flags\n  volume  : 0x%X\n  pan     : 0x%X\n", (int )buffer[6] & 255,
                 (int )buffer[7] & 255);
#line 382
  psf_log_printf(psf, "Vibrato\n  type    : %u\n  sweep   : %u\n  depth   : %u\n  rate    : %u\n\270U",
                 (int )buffer[8], (int )buffer[9], (int )buffer[10], (int )buffer[11]);
#line 389
  psf_binheader_readf(psf, "e2j2\270U", & fade_out, 22, & sample_count);
#line 390
  psf_log_printf(psf, "Fade out  : %d\n", (int )fade_out);
  }
#line 393
  if ((int )sample_count > 16) {
#line 394
    return (142);
  }
  {
#line 396
  psf->instrument = psf_instrument_alloc();
  }
#line 396
  if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 396
    if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 397
      return (17);
    }
  }
#line 399
  (psf->instrument)->basenote = (char)0;
#line 401
  k = 0;
  {
#line 401
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___1: ;
#line 401
    if (! (k < (int )sample_count)) {
#line 401
      goto while_break___1;
    }
    {
#line 402
    psf_binheader_readf(psf, "e444\270U", & sample_sizes[k], & loop_begin, & loop_end);
#line 405
    psf_binheader_readf(psf, "bb", buffer, 6, name, 22);
#line 406
    name[21] = (char)0;
#line 408
    psf_log_printf(psf, "Sample #%d\n  name    : %s\n", k + 1, name);
#line 410
    psf_log_printf(psf, "  size    : %d\n", sample_sizes[k]);
#line 414
    psf_log_printf(psf, "  loop\n    begin : %d\n    end   : %d\n", loop_begin, loop_end);
#line 416
    psf_log_printf(psf, "  volume  : %u\n  f. tune : %d\n  flags   : 0x%02X ", (int )buffer[0] & 255,
                   (int )buffer[1] & 255, (int )buffer[2] & 255);
#line 419
    psf_log_printf(psf, " (");
    }
#line 420
    if ((int )buffer[2] & 1) {
      {
#line 421
      psf_log_printf(psf, " Loop");
      }
    }
#line 422
    if ((int )buffer[2] & 2) {
      {
#line 423
      psf_log_printf(psf, " PingPong");
      }
    }
#line 424
    if ((int )buffer[2] & 16) {
#line 424
      tmp = " 16bit";
    } else {
#line 424
      tmp = " 8bit";
    }
    {
#line 424
    psf_log_printf(psf, tmp);
#line 425
    psf_log_printf(psf, " )\n");
#line 427
    psf_log_printf(psf, "  pan     : %u\n  note    : %d\n  namelen : %d\n", (int )buffer[3] & 255,
                   (int )buffer[4], (int )buffer[5]);
#line 430
    (psf->instrument)->basenote = buffer[4];
    }
#line 431
    if ((int )buffer[2] & 1) {
#line 432
      (psf->instrument)->loop_count = 1;
#line 433
      if ((int )buffer[2] & 2) {
#line 433
        tmp___0 = 803;
      } else {
#line 433
        tmp___0 = 801;
      }
#line 433
      (psf->instrument)->loops[0].mode = tmp___0;
#line 434
      (psf->instrument)->loops[0].start = (uint32_t )loop_begin;
#line 435
      (psf->instrument)->loops[0].end = (uint32_t )loop_end;
    }
#line 438
    if (k != 0) {
#line 439
      goto while_continue___1;
    }
#line 441
    if ((int )buffer[2] & 16) {
#line 442
      psf->sf.format = 983121;
#line 443
      psf->bytewidth = 2;
    } else {
#line 446
      psf->sf.format = 983120;
#line 447
      psf->bytewidth = 1;
    }
#line 401
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
  {
#line 451
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 451
    if ((int )sample_count > 1) {
#line 451
      if (! (sample_sizes[(int )sample_count - 1] == 0)) {
#line 451
        goto while_break___2;
      }
    } else {
#line 451
      goto while_break___2;
    }
#line 452
    __cil_tmp18 = sample_count;
#line 452
    sample_count = (short )((int )sample_count - 1);
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 456
  if ((int )sample_count > 2) {
    {
#line 457
    psf_log_printf(psf, "*** Sample count is less than 16 but more than 1.\n");
#line 458
    psf_log_printf(psf, "  sample count : %d    sample_sizes [%d] : %d\n", (int )sample_count,
                   (int )sample_count - 1, sample_sizes[(int )sample_count - 1]);
    }
#line 460
    return (142);
  }
  {
#line 463
  psf->datalength = (sf_count_t )sample_sizes[0];
#line 465
  psf->dataoffset = psf_ftell(psf);
  }
#line 466
  if (psf->dataoffset < 0L) {
    {
#line 467
    psf_log_printf(psf, "*** Bad Data Offset : %D\n", psf->dataoffset);
    }
#line 468
    return (26);
  }
  {
#line 470
  psf_log_printf(psf, "Data Offset : %D\n", psf->dataoffset);
  }
#line 472
  if (psf->dataoffset + psf->datalength > psf->filelength) {
    {
#line 473
    psf_log_printf(psf, "*** File seems to be truncated. Should be at least %D bytes long.\n",
                   psf->dataoffset + (long )sample_sizes[0]);
#line 475
    psf->datalength = psf->filelength - psf->dataoffset;
    }
  }
  {
#line 478
  __cil_tmp20 = psf_fseek(psf, psf->dataoffset, 0);
  }
#line 478
  if (__cil_tmp20 != psf->dataoffset) {
#line 479
    return (40);
  }
#line 481
  psf->endian = 268435456;
#line 482
  psf->sf.channels = 1;
#line 483
  psf->sf.samplerate = 44100;
#line 485
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 487
  if (! psf->sf.frames) {
#line 487
    if (psf->blockwidth) {
#line 488
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    }
  }
#line 490
  (psf->instrument)->gain = 1;
#line 491
  (psf->instrument)->key_lo = (char)0;
#line 491
  (psf->instrument)->velocity_lo = (psf->instrument)->key_lo;
#line 492
  (psf->instrument)->key_hi = (char)127;
#line 492
  (psf->instrument)->velocity_hi = (psf->instrument)->key_hi;
#line 494
  return (0);
}
}
#line 500
static void dsc2s_array(XI_PRIVATE *pxi , signed char *src , int count___0 , short *dest ) ;
#line 501
static void dsc2i_array(XI_PRIVATE *pxi , signed char *src , int count___0 , int *dest ) ;
#line 502
static void dsc2f_array(XI_PRIVATE *pxi , signed char *src , int count___0 , float *dest ,
                        float normfact ) ;
#line 503
static void dsc2d_array(XI_PRIVATE *pxi , signed char *src , int count___0 , double *dest ,
                        double normfact ) ;
#line 505
static void dles2s_array(XI_PRIVATE *pxi , short *src , int count___0 , short *dest ) ;
#line 506
static void dles2i_array(XI_PRIVATE *pxi , short *src , int count___0 , int *dest ) ;
#line 507
static void dles2f_array(XI_PRIVATE *pxi , short *src , int count___0 , float *dest ,
                         float normfact ) ;
#line 508
static void dles2d_array(XI_PRIVATE *pxi , short *src , int count___0 , double *dest ,
                         double normfact ) ;
#line 511 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_read_dsc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 515
  total = (sf_count_t )0;
#line 517
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 517
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 518
    return ((sf_count_t )0);
  }
#line 520
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 522
  while (1) {
    while_continue: /* CIL Label */ ;

#line 522
    if (! (len > 0L)) {
#line 522
      goto while_break;
    }
#line 523
    if (len < (long )bufferlen) {
#line 524
      bufferlen = (int )len;
    }
    {
#line 525
    __cil_tmp9 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                           (sf_count_t )bufferlen, psf);
#line 525
    readcount = (int )__cil_tmp9;
#line 526
    dsc2s_array(pxi, ubuf.scbuf, readcount, ptr + total);
#line 527
    total += (long )readcount;
    }
#line 528
    if (readcount < bufferlen) {
#line 529
      goto while_break;
    }
#line 530
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 533
  return (total);
}
}
#line 537 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_read_dsc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 541
  total = (sf_count_t )0;
#line 543
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 543
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 544
    return ((sf_count_t )0);
  }
#line 546
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;

#line 548
    if (! (len > 0L)) {
#line 548
      goto while_break;
    }
#line 549
    if (len < (long )bufferlen) {
#line 550
      bufferlen = (int )len;
    }
    {
#line 551
    __cil_tmp9 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                           (sf_count_t )bufferlen, psf);
#line 551
    readcount = (int )__cil_tmp9;
#line 552
    dsc2i_array(pxi, ubuf.scbuf, readcount, ptr + total);
#line 553
    total += (long )readcount;
    }
#line 554
    if (readcount < bufferlen) {
#line 555
      goto while_break;
    }
#line 556
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 559
  return (total);
}
}
#line 563 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_read_dsc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 567
  total = (sf_count_t )0;
#line 570
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 570
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 571
    return ((sf_count_t )0);
  }
#line 573
  if (psf->norm_float == 1) {
#line 573
    tmp = 1. / (double )((float )128);
  } else {
#line 573
    tmp = 1.;
  }
#line 573
  normfact = (float )tmp;
#line 575
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;

#line 577
    if (! (len > 0L)) {
#line 577
      goto while_break;
    }
#line 578
    if (len < (long )bufferlen) {
#line 579
      bufferlen = (int )len;
    }
    {
#line 580
    __cil_tmp11 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 580
    readcount = (int )__cil_tmp11;
#line 581
    dsc2f_array(pxi, ubuf.scbuf, readcount, ptr + total, normfact);
#line 582
    total += (long )readcount;
    }
#line 583
    if (readcount < bufferlen) {
#line 584
      goto while_break;
    }
#line 585
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 588
  return (total);
}
}
#line 592 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_read_dsc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 596
  total = (sf_count_t )0;
#line 599
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 599
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 600
    return ((sf_count_t )0);
  }
#line 602
  if (psf->norm_double == 1) {
#line 602
    tmp = 1. / (double )128;
  } else {
#line 602
    tmp = 1.;
  }
#line 602
  normfact = tmp;
#line 604
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;

#line 606
    if (! (len > 0L)) {
#line 606
      goto while_break;
    }
#line 607
    if (len < (long )bufferlen) {
#line 608
      bufferlen = (int )len;
    }
    {
#line 609
    __cil_tmp11 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 609
    readcount = (int )__cil_tmp11;
#line 610
    dsc2d_array(pxi, ubuf.scbuf, readcount, ptr + total, normfact);
#line 611
    total += (long )readcount;
    }
#line 612
    if (readcount < bufferlen) {
#line 613
      goto while_break;
    }
#line 614
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 617
  return (total);
}
}
#line 624 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_read_dles2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 628
  total = (sf_count_t )0;
#line 630
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 630
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 631
    return ((sf_count_t )0);
  }
#line 633
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;

#line 635
    if (! (len > 0L)) {
#line 635
      goto while_break;
    }
#line 636
    if (len < (long )bufferlen) {
#line 637
      bufferlen = (int )len;
    }
    {
#line 638
    __cil_tmp9 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 638
    readcount = (int )__cil_tmp9;
#line 639
    dles2s_array(pxi, ubuf.sbuf, readcount, ptr + total);
#line 640
    total += (long )readcount;
    }
#line 641
    if (readcount < bufferlen) {
#line 642
      goto while_break;
    }
#line 643
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 646
  return (total);
}
}
#line 650 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_read_dles2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 654
  total = (sf_count_t )0;
#line 656
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 656
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 657
    return ((sf_count_t )0);
  }
#line 659
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;

#line 661
    if (! (len > 0L)) {
#line 661
      goto while_break;
    }
#line 662
    if (len < (long )bufferlen) {
#line 663
      bufferlen = (int )len;
    }
    {
#line 664
    __cil_tmp9 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 664
    readcount = (int )__cil_tmp9;
#line 665
    dles2i_array(pxi, ubuf.sbuf, readcount, ptr + total);
#line 666
    total += (long )readcount;
    }
#line 667
    if (readcount < bufferlen) {
#line 668
      goto while_break;
    }
#line 669
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 672
  return (total);
}
}
#line 676 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_read_dles2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 680
  total = (sf_count_t )0;
#line 683
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 683
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 684
    return ((sf_count_t )0);
  }
#line 686
  if (psf->norm_float == 1) {
#line 686
    tmp = 1. / (double )((float )32768);
  } else {
#line 686
    tmp = 1.;
  }
#line 686
  normfact = (float )tmp;
#line 688
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;

#line 690
    if (! (len > 0L)) {
#line 690
      goto while_break;
    }
#line 691
    if (len < (long )bufferlen) {
#line 692
      bufferlen = (int )len;
    }
    {
#line 693
    __cil_tmp11 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 693
    readcount = (int )__cil_tmp11;
#line 694
    dles2f_array(pxi, ubuf.sbuf, readcount, ptr + total, normfact);
#line 695
    total += (long )readcount;
    }
#line 696
    if (readcount < bufferlen) {
#line 697
      goto while_break;
    }
#line 698
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 701
  return (total);
}
}
#line 705 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_read_dles2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 709
  total = (sf_count_t )0;
#line 712
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 712
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 713
    return ((sf_count_t )0);
  }
#line 715
  if (psf->norm_double == 1) {
#line 715
    tmp = 1. / (double )32768;
  } else {
#line 715
    tmp = 1.;
  }
#line 715
  normfact = tmp;
#line 717
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;

#line 719
    if (! (len > 0L)) {
#line 719
      goto while_break;
    }
#line 720
    if (len < (long )bufferlen) {
#line 721
      bufferlen = (int )len;
    }
    {
#line 722
    __cil_tmp11 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 722
    readcount = (int )__cil_tmp11;
#line 723
    dles2d_array(pxi, ubuf.sbuf, readcount, ptr + total, normfact);
#line 724
    total += (long )readcount;
    }
#line 725
    if (readcount < bufferlen) {
#line 726
      goto while_break;
    }
#line 727
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 730
  return (total);
}
}
#line 736
static void s2dsc_array(XI_PRIVATE *pxi , short const   *src , signed char *dest ,
                        int count___0 ) ;
#line 737
static void i2dsc_array(XI_PRIVATE *pxi , int const   *src , signed char *dest , int count___0 ) ;
#line 738
static void f2dsc_array(XI_PRIVATE *pxi , float const   *src , signed char *dest ,
                        int count___0 , float normfact ) ;
#line 739
static void d2dsc_array(XI_PRIVATE *pxi , double const   *src , signed char *dest ,
                        int count___0 , double normfact ) ;
#line 741
static void s2dles_array(XI_PRIVATE *pxi , short const   *src , short *dest , int count___0 ) ;
#line 742
static void i2dles_array(XI_PRIVATE *pxi , int const   *src , short *dest , int count___0 ) ;
#line 743
static void f2dles_array(XI_PRIVATE *pxi , float const   *src , short *dest , int count___0 ,
                         float normfact ) ;
#line 744
static void d2dles_array(XI_PRIVATE *pxi , double const   *src , short *dest , int count___0 ,
                         double normfact ) ;
#line 748 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_write_s2dsc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 752
  total = (sf_count_t )0;
#line 754
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 754
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 755
    return ((sf_count_t )0);
  }
#line 757
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 759
  while (1) {
    while_continue: /* CIL Label */ ;

#line 759
    if (! (len > 0L)) {
#line 759
      goto while_break;
    }
#line 760
    if (len < (long )bufferlen) {
#line 761
      bufferlen = (int )len;
    }
    {
#line 762
    s2dsc_array(pxi, ptr + total, ubuf.scbuf, bufferlen);
#line 763
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 763
    writecount = (int )__cil_tmp9;
#line 764
    total += (long )writecount;
    }
#line 765
    if (writecount < bufferlen) {
#line 766
      goto while_break;
    }
#line 767
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 770
  return (total);
}
}
#line 774 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_write_i2dsc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 778
  total = (sf_count_t )0;
#line 780
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 780
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 781
    return ((sf_count_t )0);
  }
#line 783
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;

#line 785
    if (! (len > 0L)) {
#line 785
      goto while_break;
    }
#line 786
    if (len < (long )bufferlen) {
#line 787
      bufferlen = (int )len;
    }
    {
#line 788
    i2dsc_array(pxi, ptr + total, ubuf.scbuf, bufferlen);
#line 789
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 789
    writecount = (int )__cil_tmp9;
#line 790
    total += (long )writecount;
    }
#line 791
    if (writecount < bufferlen) {
#line 792
      goto while_break;
    }
#line 793
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 796
  return (total);
}
}
#line 800 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_write_f2dsc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 804
  total = (sf_count_t )0;
#line 807
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 807
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 808
    return ((sf_count_t )0);
  }
#line 810
  if (psf->norm_float == 1) {
#line 810
    tmp = 1. * (double )127;
  } else {
#line 810
    tmp = 1.;
  }
#line 810
  normfact = (float )tmp;
#line 812
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;

#line 814
    if (! (len > 0L)) {
#line 814
      goto while_break;
    }
#line 815
    if (len < (long )bufferlen) {
#line 816
      bufferlen = (int )len;
    }
    {
#line 817
    f2dsc_array(pxi, ptr + total, ubuf.scbuf, bufferlen, normfact);
#line 818
    __cil_tmp11 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                             (sf_count_t )bufferlen, psf);
#line 818
    writecount = (int )__cil_tmp11;
#line 819
    total += (long )writecount;
    }
#line 820
    if (writecount < bufferlen) {
#line 821
      goto while_break;
    }
#line 822
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 825
  return (total);
}
}
#line 829 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_write_d2dsc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 833
  total = (sf_count_t )0;
#line 836
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 836
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 837
    return ((sf_count_t )0);
  }
#line 839
  if (psf->norm_double == 1) {
#line 839
    tmp = 1. * (double )127;
  } else {
#line 839
    tmp = 1.;
  }
#line 839
  normfact = tmp;
#line 841
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 843
  while (1) {
    while_continue: /* CIL Label */ ;

#line 843
    if (! (len > 0L)) {
#line 843
      goto while_break;
    }
#line 844
    if (len < (long )bufferlen) {
#line 845
      bufferlen = (int )len;
    }
    {
#line 846
    d2dsc_array(pxi, ptr + total, ubuf.scbuf, bufferlen, normfact);
#line 847
    __cil_tmp11 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                             (sf_count_t )bufferlen, psf);
#line 847
    writecount = (int )__cil_tmp11;
#line 848
    total += (long )writecount;
    }
#line 849
    if (writecount < bufferlen) {
#line 850
      goto while_break;
    }
#line 851
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 854
  return (total);
}
}
#line 859 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_write_s2dles(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 863
  total = (sf_count_t )0;
#line 865
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 865
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 866
    return ((sf_count_t )0);
  }
#line 868
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;

#line 870
    if (! (len > 0L)) {
#line 870
      goto while_break;
    }
#line 871
    if (len < (long )bufferlen) {
#line 872
      bufferlen = (int )len;
    }
    {
#line 873
    s2dles_array(pxi, ptr + total, ubuf.sbuf, bufferlen);
#line 874
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                            (sf_count_t )bufferlen, psf);
#line 874
    writecount = (int )__cil_tmp9;
#line 875
    total += (long )writecount;
    }
#line 876
    if (writecount < bufferlen) {
#line 877
      goto while_break;
    }
#line 878
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 881
  return (total);
}
}
#line 885 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_write_i2dles(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 889
  total = (sf_count_t )0;
#line 891
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 891
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 892
    return ((sf_count_t )0);
  }
#line 894
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 896
  while (1) {
    while_continue: /* CIL Label */ ;

#line 896
    if (! (len > 0L)) {
#line 896
      goto while_break;
    }
#line 897
    if (len < (long )bufferlen) {
#line 898
      bufferlen = (int )len;
    }
    {
#line 899
    i2dles_array(pxi, ptr + total, ubuf.sbuf, bufferlen);
#line 900
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                            (sf_count_t )bufferlen, psf);
#line 900
    writecount = (int )__cil_tmp9;
#line 901
    total += (long )writecount;
    }
#line 902
    if (writecount < bufferlen) {
#line 903
      goto while_break;
    }
#line 904
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 907
  return (total);
}
}
#line 911 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_write_f2dles(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 915
  total = (sf_count_t )0;
#line 918
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 918
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 919
    return ((sf_count_t )0);
  }
#line 921
  if (psf->norm_float == 1) {
#line 921
    tmp = 1. * (double )32767;
  } else {
#line 921
    tmp = 1.;
  }
#line 921
  normfact = (float )tmp;
#line 923
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 925
  while (1) {
    while_continue: /* CIL Label */ ;

#line 925
    if (! (len > 0L)) {
#line 925
      goto while_break;
    }
#line 926
    if (len < (long )bufferlen) {
#line 927
      bufferlen = (int )len;
    }
    {
#line 928
    f2dles_array(pxi, ptr + total, ubuf.sbuf, bufferlen, normfact);
#line 929
    __cil_tmp11 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                             (sf_count_t )bufferlen, psf);
#line 929
    writecount = (int )__cil_tmp11;
#line 930
    total += (long )writecount;
    }
#line 931
    if (writecount < bufferlen) {
#line 932
      goto while_break;
    }
#line 933
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 936
  return (total);
}
}
#line 940 "/root/patchweave_new/23/src/xi.c"
static sf_count_t dpcm_write_d2dles(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 944
  total = (sf_count_t )0;
#line 947
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 947
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 948
    return ((sf_count_t )0);
  }
#line 950
  if (psf->norm_double == 1) {
#line 950
    tmp = 1. * (double )32767;
  } else {
#line 950
    tmp = 1.;
  }
#line 950
  normfact = tmp;
#line 952
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 954
  while (1) {
    while_continue: /* CIL Label */ ;

#line 954
    if (! (len > 0L)) {
#line 954
      goto while_break;
    }
#line 955
    if (len < (long )bufferlen) {
#line 956
      bufferlen = (int )len;
    }
    {
#line 957
    d2dles_array(pxi, ptr + total, ubuf.sbuf, bufferlen, normfact);
#line 958
    __cil_tmp11 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                             (sf_count_t )bufferlen, psf);
#line 958
    writecount = (int )__cil_tmp11;
#line 959
    total += (long )writecount;
    }
#line 960
    if (writecount < bufferlen) {
#line 961
      goto while_break;
    }
#line 962
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 965
  return (total);
}
}
#line 973 "/root/patchweave_new/23/src/xi.c"
static void dsc2s_array(XI_PRIVATE *pxi , signed char *src , int count___0 , short *dest ) 
{ 
  signed char last_val ;
  int k ;
  int32_t __cil_tmp7 ;
  int32_t __cil_tmp9 ;

  {
#line 977
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 979
  k = 0;
  {
#line 979
  while (1) {
    while_continue: /* CIL Label */ ;

#line 979
    if (! (k < count___0)) {
#line 979
      goto while_break;
    }
    {
#line 980
    last_val = (signed char )((int )last_val + (int )*(src + k));
#line 981
    __cil_tmp7 = arith_shift_left((int32_t )last_val, 8);
#line 981
    *(dest + k) = (short )__cil_tmp7;
#line 979
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 984
  __cil_tmp9 = arith_shift_left((int32_t )last_val, 8);
#line 984
  pxi->last_16 = (short )__cil_tmp9;
  }
#line 986
  return;
}
}
#line 988 "/root/patchweave_new/23/src/xi.c"
static void dsc2i_array(XI_PRIVATE *pxi , signed char *src , int count___0 , int *dest ) 
{ 
  signed char last_val ;
  int k ;
  int32_t __cil_tmp9 ;

  {
#line 992
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 994
  k = 0;
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;

#line 994
    if (! (k < count___0)) {
#line 994
      goto while_break;
    }
    {
#line 995
    last_val = (signed char )((int )last_val + (int )*(src + k));
#line 996
    *(dest + k) = arith_shift_left((int32_t )last_val, 24);
#line 994
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 999
  __cil_tmp9 = arith_shift_left((int32_t )last_val, 8);
#line 999
  pxi->last_16 = (short )__cil_tmp9;
  }
#line 1001
  return;
}
}
#line 1003 "/root/patchweave_new/23/src/xi.c"
static void dsc2f_array(XI_PRIVATE *pxi , signed char *src , int count___0 , float *dest ,
                        float normfact ) 
{ 
  signed char last_val ;
  int k ;
  int32_t __cil_tmp9 ;

  {
#line 1007
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1009
  k = 0;
  {
#line 1009
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1009
    if (! (k < count___0)) {
#line 1009
      goto while_break;
    }
#line 1010
    last_val = (signed char )((int )last_val + (int )*(src + k));
#line 1011
    *(dest + k) = (float )((int )last_val) * normfact;
#line 1009
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1014
  __cil_tmp9 = arith_shift_left((int32_t )last_val, 8);
#line 1014
  pxi->last_16 = (short )__cil_tmp9;
  }
#line 1016
  return;
}
}
#line 1018 "/root/patchweave_new/23/src/xi.c"
static void dsc2d_array(XI_PRIVATE *pxi , signed char *src , int count___0 , double *dest ,
                        double normfact ) 
{ 
  signed char last_val ;
  int k ;
  int32_t __cil_tmp9 ;

  {
#line 1022
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1024
  k = 0;
  {
#line 1024
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1024
    if (! (k < count___0)) {
#line 1024
      goto while_break;
    }
#line 1025
    last_val = (signed char )((int )last_val + (int )*(src + k));
#line 1026
    *(dest + k) = (double )((int )last_val) * normfact;
#line 1024
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1029
  __cil_tmp9 = arith_shift_left((int32_t )last_val, 8);
#line 1029
  pxi->last_16 = (short )__cil_tmp9;
  }
#line 1031
  return;
}
}
#line 1036 "/root/patchweave_new/23/src/xi.c"
static void s2dsc_array(XI_PRIVATE *pxi , short const   *src , signed char *dest ,
                        int count___0 ) 
{ 
  signed char last_val ;
  signed char current ;
  int k ;
  int32_t __cil_tmp9 ;

  {
#line 1040
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1042
  k = 0;
  {
#line 1042
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1042
    if (! (k < count___0)) {
#line 1042
      goto while_break;
    }
#line 1043
    current = (signed char )((int )*(src + k) >> 8);
#line 1044
    *(dest + k) = (signed char )((int )current - (int )last_val);
#line 1045
    last_val = current;
#line 1042
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1048
  __cil_tmp9 = arith_shift_left((int32_t )last_val, 8);
#line 1048
  pxi->last_16 = (short )__cil_tmp9;
  }
#line 1050
  return;
}
}
#line 1052 "/root/patchweave_new/23/src/xi.c"
static void i2dsc_array(XI_PRIVATE *pxi , int const   *src , signed char *dest , int count___0 ) 
{ 
  signed char last_val ;
  signed char current ;
  int k ;
  int32_t __cil_tmp9 ;

  {
#line 1056
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1058
  k = 0;
  {
#line 1058
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1058
    if (! (k < count___0)) {
#line 1058
      goto while_break;
    }
#line 1059
    current = (signed char )(*(src + k) >> 24);
#line 1060
    *(dest + k) = (signed char )((int )current - (int )last_val);
#line 1061
    last_val = current;
#line 1058
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1064
  __cil_tmp9 = arith_shift_left((int32_t )last_val, 8);
#line 1064
  pxi->last_16 = (short )__cil_tmp9;
  }
#line 1066
  return;
}
}
#line 1068 "/root/patchweave_new/23/src/xi.c"
static void f2dsc_array(XI_PRIVATE *pxi , float const   *src , signed char *dest ,
                        int count___0 , float normfact ) 
{ 
  signed char last_val ;
  signed char current ;
  int k ;
  long __cil_tmp9 ;
  int32_t __cil_tmp11 ;

  {
#line 1072
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1074
  k = 0;
  {
#line 1074
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1074
    if (! (k < count___0)) {
#line 1074
      goto while_break;
    }
    {
#line 1075
    __cil_tmp9 = lrintf((float )(*(src + k) * (float const   )normfact));
#line 1075
    current = (signed char )__cil_tmp9;
#line 1076
    *(dest + k) = (signed char )((int )current - (int )last_val);
#line 1077
    last_val = current;
#line 1074
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1080
  __cil_tmp11 = arith_shift_left((int32_t )last_val, 8);
#line 1080
  pxi->last_16 = (short )__cil_tmp11;
  }
#line 1082
  return;
}
}
#line 1084 "/root/patchweave_new/23/src/xi.c"
static void d2dsc_array(XI_PRIVATE *pxi , double const   *src , signed char *dest ,
                        int count___0 , double normfact ) 
{ 
  signed char last_val ;
  signed char current ;
  int k ;
  long __cil_tmp9 ;
  int32_t __cil_tmp11 ;

  {
#line 1088
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1090
  k = 0;
  {
#line 1090
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1090
    if (! (k < count___0)) {
#line 1090
      goto while_break;
    }
    {
#line 1091
    __cil_tmp9 = lrint((double )(*(src + k) * (double const   )normfact));
#line 1091
    current = (signed char )__cil_tmp9;
#line 1092
    *(dest + k) = (signed char )((int )current - (int )last_val);
#line 1093
    last_val = current;
#line 1090
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1096
  __cil_tmp11 = arith_shift_left((int32_t )last_val, 8);
#line 1096
  pxi->last_16 = (short )__cil_tmp11;
  }
#line 1098
  return;
}
}
#line 1103 "/root/patchweave_new/23/src/xi.c"
static void dles2s_array(XI_PRIVATE *pxi , short *src , int count___0 , short *dest ) 
{ 
  short last_val ;
  int k ;

  {
#line 1107
  last_val = pxi->last_16;
#line 1109
  k = 0;
  {
#line 1109
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1109
    if (! (k < count___0)) {
#line 1109
      goto while_break;
    }
#line 1110
    last_val = (short )((int )last_val + (int )*(src + k));
#line 1111
    *(dest + k) = last_val;
#line 1109
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1114
  pxi->last_16 = last_val;
#line 1115
  return;
}
}
#line 1118 "/root/patchweave_new/23/src/xi.c"
static void dles2i_array(XI_PRIVATE *pxi , short *src , int count___0 , int *dest ) 
{ 
  short last_val ;
  int k ;

  {
#line 1122
  last_val = pxi->last_16;
#line 1124
  k = 0;
  {
#line 1124
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1124
    if (! (k < count___0)) {
#line 1124
      goto while_break;
    }
    {
#line 1125
    last_val = (short )((int )last_val + (int )*(src + k));
#line 1126
    *(dest + k) = arith_shift_left((int32_t )last_val, 16);
#line 1124
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1129
  pxi->last_16 = last_val;
#line 1130
  return;
}
}
#line 1133 "/root/patchweave_new/23/src/xi.c"
static void dles2f_array(XI_PRIVATE *pxi , short *src , int count___0 , float *dest ,
                         float normfact ) 
{ 
  short last_val ;
  int k ;

  {
#line 1137
  last_val = pxi->last_16;
#line 1139
  k = 0;
  {
#line 1139
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1139
    if (! (k < count___0)) {
#line 1139
      goto while_break;
    }
#line 1140
    last_val = (short )((int )last_val + (int )*(src + k));
#line 1141
    *(dest + k) = (float )((int )last_val) * normfact;
#line 1139
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1144
  pxi->last_16 = last_val;
#line 1145
  return;
}
}
#line 1148 "/root/patchweave_new/23/src/xi.c"
static void dles2d_array(XI_PRIVATE *pxi , short *src , int count___0 , double *dest ,
                         double normfact ) 
{ 
  short last_val ;
  int k ;

  {
#line 1152
  last_val = pxi->last_16;
#line 1154
  k = 0;
  {
#line 1154
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1154
    if (! (k < count___0)) {
#line 1154
      goto while_break;
    }
#line 1155
    last_val = (short )((int )last_val + (int )*(src + k));
#line 1156
    *(dest + k) = (double )((int )last_val) * normfact;
#line 1154
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1159
  pxi->last_16 = last_val;
#line 1160
  return;
}
}
#line 1166 "/root/patchweave_new/23/src/xi.c"
static void s2dles_array(XI_PRIVATE *pxi , short const   *src , short *dest , int count___0 ) 
{ 
  short diff ;
  short last_val ;
  int k ;

  {
#line 1170
  last_val = pxi->last_16;
#line 1172
  k = 0;
  {
#line 1172
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1172
    if (! (k < count___0)) {
#line 1172
      goto while_break;
    }
#line 1173
    diff = (short )((int )*(src + k) - (int )last_val);
#line 1174
    *(dest + k) = diff;
#line 1175
    last_val = (short )*(src + k);
#line 1172
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1178
  pxi->last_16 = last_val;
#line 1179
  return;
}
}
#line 1182 "/root/patchweave_new/23/src/xi.c"
static void i2dles_array(XI_PRIVATE *pxi , int const   *src , short *dest , int count___0 ) 
{ 
  short diff ;
  short last_val ;
  int k ;

  {
#line 1186
  last_val = pxi->last_16;
#line 1188
  k = 0;
  {
#line 1188
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1188
    if (! (k < count___0)) {
#line 1188
      goto while_break;
    }
#line 1189
    diff = (short )((*(src + k) >> 16) - (int const   )((int )last_val));
#line 1190
    *(dest + k) = diff;
#line 1191
    last_val = (short )(*(src + k) >> 16);
#line 1188
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1194
  pxi->last_16 = last_val;
#line 1195
  return;
}
}
#line 1198 "/root/patchweave_new/23/src/xi.c"
static void f2dles_array(XI_PRIVATE *pxi , float const   *src , short *dest , int count___0 ,
                         float normfact ) 
{ 
  short diff ;
  short last_val ;
  short current ;
  int k ;
  long __cil_tmp10 ;

  {
#line 1202
  last_val = pxi->last_16;
#line 1204
  k = 0;
  {
#line 1204
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1204
    if (! (k < count___0)) {
#line 1204
      goto while_break;
    }
    {
#line 1205
    __cil_tmp10 = lrintf((float )(*(src + k) * (float const   )normfact));
#line 1205
    current = (short )__cil_tmp10;
#line 1206
    diff = (short )((int )current - (int )last_val);
#line 1207
    *(dest + k) = diff;
#line 1208
    last_val = current;
#line 1204
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1211
  pxi->last_16 = last_val;
#line 1212
  return;
}
}
#line 1215 "/root/patchweave_new/23/src/xi.c"
static void d2dles_array(XI_PRIVATE *pxi , double const   *src , short *dest , int count___0 ,
                         double normfact ) 
{ 
  short diff ;
  short last_val ;
  short current ;
  int k ;
  long __cil_tmp10 ;

  {
#line 1219
  last_val = pxi->last_16;
#line 1221
  k = 0;
  {
#line 1221
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1221
    if (! (k < count___0)) {
#line 1221
      goto while_break;
    }
    {
#line 1222
    __cil_tmp10 = lrint((double )(*(src + k) * (double const   )normfact));
#line 1222
    current = (short )__cil_tmp10;
#line 1223
    diff = (short )((int )current - (int )last_val);
#line 1224
    *(dest + k) = diff;
#line 1225
    last_val = current;
#line 1221
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1228
  pxi->last_16 = last_val;
#line 1229
  return;
}
}
#line 92 "/root/patchweave_new/23/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_PCM___0  =    {1U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 102 "/root/patchweave_new/23/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_IEEE_FLOAT___0  =    {3U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 106 "/root/patchweave_new/23/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_ALAW___0  =    {6U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 110 "/root/patchweave_new/23/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_MULAW___0  =    {7U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 118 "/root/patchweave_new/23/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM___0  =    {1U, (unsigned short)1825, (unsigned short)4563, {(char)-122, (char)68, (char)-56,
                                                     (char)-63, (char)-54, (char)0,
                                                     (char)0, (char)0}};
#line 122 "/root/patchweave_new/23/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT___0  =    {3U, (unsigned short)1825, (unsigned short)4563, {(char)-122, (char)68, (char)-56,
                                                     (char)-63, (char)-54, (char)0,
                                                     (char)0, (char)0}};
#line 139
static int wav_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) ;
#line 140
static int wav_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 142
static int wav_write_tailer(SF_PRIVATE *psf ) ;
#line 143
static int wav_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int datasize ) ;
#line 144
static int wav_close(SF_PRIVATE *psf ) ;
#line 146
static int wav_read_smpl_chunk(SF_PRIVATE *psf , uint32_t chunklen ) ;
#line 147
static int wav_read_acid_chunk(SF_PRIVATE *psf , uint32_t chunklen ) ;
#line 149
static int wav_set_chunk(SF_PRIVATE *psf , SF_CHUNK_INFO *chunk_info ) ;
#line 150
static SF_CHUNK_ITERATOR *wav_next_chunk_iterator(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator ) ;
#line 151
static int wav_get_chunk_size(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 152
static int wav_get_chunk_data(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 159 "/root/patchweave_new/23/src/wav.c"
int wav_open(SF_PRIVATE *psf ) 
{ 
  WAVLIKE_PRIVATE *wpriv ;
  int format ;
  int subformat ;
  int error ;
  int blockalign ;
  int framesperblock ;
  int __cil_tmp21 ;
  void *tmp ;

  {
  {
#line 161
  blockalign = 0;
#line 161
  framesperblock = 0;
#line 163
  tmp = calloc(1UL, sizeof(WAVLIKE_PRIVATE ));
#line 163
  wpriv = (WAVLIKE_PRIVATE *)tmp;
  }
#line 163
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 164
    return (17);
  }
#line 165
  psf->container_data = (void *)wpriv;
#line 167
  wpriv->wavex_ambisonic = 64;
#line 168
  psf->strings.flags = (uint32_t )768;
#line 170
  if (psf->file.mode == 16) {
    _L: 
    {
#line 171
    error = wav_read_header(psf, & blockalign, & framesperblock);
    }
#line 171
    if (error) {
#line 172
      return (error);
    }
#line 174
    psf->next_chunk_iterator = & wav_next_chunk_iterator;
#line 175
    psf->get_chunk_size = & wav_get_chunk_size;
#line 176
    psf->get_chunk_data = & wav_get_chunk_data;
  } else
#line 170
  if (psf->file.mode == 48) {
#line 170
    if (psf->filelength > 0L) {
#line 170
      goto _L;
    }
  }
#line 179
  subformat = psf->sf.format & 65535;
#line 181
  if (psf->file.mode == 32) {
    _L___14: 
#line 182
    if (psf->is_pipe) {
#line 183
      return (29);
    }
#line 185
    wpriv->wavex_ambisonic = 64;
#line 187
    format = psf->sf.format & 268369920;
#line 188
    if (format != 65536) {
#line 188
      if (format != 1245184) {
#line 189
        return (1);
      }
    }
#line 191
    psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 194
    psf->endian = psf->sf.format & 805306368;
#line 197
    if (psf->endian != 536870912) {
#line 198
      psf->endian = 268435456;
    }
#line 200
    if (psf->file.mode != 48) {
#line 201
      psf->filelength = (sf_count_t )0;
#line 202
      psf->datalength = (sf_count_t )0;
#line 203
      psf->dataoffset = (sf_count_t )0;
#line 204
      psf->sf.frames = (sf_count_t )0;
    } else
#line 200
    if (psf->filelength < 44L) {
#line 201
      psf->filelength = (sf_count_t )0;
#line 202
      psf->datalength = (sf_count_t )0;
#line 203
      psf->dataoffset = (sf_count_t )0;
#line 204
      psf->sf.frames = (sf_count_t )0;
    }
#line 207
    if (subformat == 18) {
      {
#line 208
      blockalign = wavlike_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 209
      framesperblock = -1;
      }
    } else
#line 207
    if (subformat == 19) {
      {
#line 208
      blockalign = wavlike_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 209
      framesperblock = -1;
      }
    }
#line 215
    if (psf->file.mode == 32) {
#line 215
      if (subformat == 6) {
        _L___13: 
        {
#line 216
        psf->peak_info = peak_info_calloc(psf->sf.channels);
        }
#line 216
        if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 217
          return (17);
        }
#line 218
        (psf->peak_info)->peak_loc = 42;
      } else
#line 215
      if (subformat == 7) {
#line 215
        goto _L___13;
      }
    }
#line 221
    psf->write_header = & wav_write_header;
#line 222
    psf->set_chunk = & wav_set_chunk;
  } else
#line 181
  if (psf->file.mode == 48) {
#line 181
    goto _L___14;
  }
#line 225
  psf->container_close = & wav_close;
#line 226
  psf->command = & wav_command;
#line 232
  if (subformat == 4) {
#line 232
    goto case_4;
  }
#line 232
  if (subformat == 3) {
#line 232
    goto case_4;
  }
#line 232
  if (subformat == 2) {
#line 232
    goto case_4;
  }
#line 232
  if (subformat == 5) {
#line 232
    goto case_4;
  }
#line 236
  if (subformat == 16) {
#line 236
    goto case_16;
  }
#line 240
  if (subformat == 17) {
#line 240
    goto case_17;
  }
#line 245
  if (subformat == 6) {
#line 245
    goto case_6;
  }
#line 249
  if (subformat == 7) {
#line 249
    goto case_7;
  }
#line 253
  if (subformat == 18) {
#line 253
    goto case_18;
  }
#line 257
  if (subformat == 19) {
#line 257
    goto case_19;
  }
#line 261
  if (subformat == 48) {
#line 261
    goto case_48;
  }
#line 266
  if (subformat == 32) {
#line 266
    goto case_32;
  }
#line 270
  goto switch_default;
  case_4: 
  {
#line 233
  error = pcm_init(psf);
  }
#line 234
  goto switch_break;
  case_16: 
  {
#line 237
  error = ulaw_init(psf);
  }
#line 238
  goto switch_break;
  case_17: 
  {
#line 241
  error = alaw_init(psf);
  }
#line 242
  goto switch_break;
  case_6: 
  {
#line 246
  error = float32_init(psf);
  }
#line 247
  goto switch_break;
  case_7: 
  {
#line 250
  error = double64_init(psf);
  }
#line 251
  goto switch_break;
  case_18: 
  {
#line 254
  error = wavlike_ima_init(psf, blockalign, framesperblock);
  }
#line 255
  goto switch_break;
  case_19: 
  {
#line 258
  error = wavlike_msadpcm_init(psf, blockalign, framesperblock);
  }
#line 259
  goto switch_break;
  case_48: 
  {
#line 262
  error = g72x_init(psf);
  }
#line 263
  goto switch_break;
  case_32: 
  {
#line 267
  error = gsm610_init(psf);
  }
#line 268
  goto switch_break;
  switch_default: 
#line 270
  return (18);
  switch_break: ;
#line 273
  if (psf->file.mode == 32) {
    {
#line 274
    __cil_tmp21 = (*(psf->write_header))(psf, 0);
    }
#line 274
    return (__cil_tmp21);
  } else
#line 273
  if (psf->file.mode == 48) {
#line 273
    if (psf->filelength == 0L) {
      {
#line 274
      __cil_tmp21 = (*(psf->write_header))(psf, 0);
      }
#line 274
      return (__cil_tmp21);
    }
  }
#line 276
  return (error);
}
}
#line 284 "/root/patchweave_new/23/src/wav.c"
static int wav_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) 
{ 
  WAVLIKE_PRIVATE *wpriv ;
  WAV_FMT *wav_fmt ;
  FACT_CHUNK fact_chunk ;
  uint32_t marker ;
  uint32_t chunk_size ;
  uint32_t RIFFsize ;
  uint32_t done ;
  int parsestage ;
  int error ;
  int format ;
  int tmp ;
  size_t jump ;
  sf_count_t pos ;
  sf_count_t __cil_tmp17 ;
  sf_count_t __cil_tmp18 ;
  sf_count_t __cil_tmp21 ;
  int tmp___0 ;
  uint32_t thisread ;
  uint32_t bytesread ;
  uint32_t cue_count ;
  uint32_t position ;
  uint32_t offset ;
  int id ;
  int chunk_id ;
  int chunk_start ;
  int block_start ;
  int cue_index ;
  int __cil_tmp34 ;
  unsigned int tmp___1 ;
  int __cil_tmp37 ;
  uint32_t __cil_tmp38 ;
  sf_count_t __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  sf_count_t __cil_tmp50 ;
  sf_count_t __cil_tmp51 ;
  sf_count_t __cil_tmp52 ;
  sf_count_t __cil_tmp53 ;
  int __cil_tmp54 ;
  int tmp___2 ;

  {
#line 288
  chunk_size = (uint32_t )0;
#line 288
  RIFFsize = (uint32_t )0;
#line 288
  done = (uint32_t )0;
#line 289
  parsestage = 0;
#line 289
  format = 0;
#line 291
  if (psf->is_pipe == 0) {
#line 291
    if (psf->filelength > 4294967295L) {
      {
#line 292
      psf_log_printf(psf, "Warning : filelength > 0xffffffff. This is bad!!!!\nE\270U");
      }
    }
  }
#line 294
  wpriv = (WAVLIKE_PRIVATE *)psf->container_data;
#line 294
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 295
    return (30);
  }
  {
#line 296
  wav_fmt = & wpriv->wav_fmt;
#line 299
  psf_binheader_readf(psf, "pmj", 0, & marker, -4);
#line 300
  psf->header.indx = (sf_count_t )0;
  }
#line 306
  if (marker == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
#line 306
    tmp = 268435456;
  } else {
#line 306
    tmp = 536870912;
  }
#line 306
  psf->rwf_endian = tmp;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;

#line 308
    if (! (! done)) {
#line 308
      goto while_break;
    }
    {
#line 309
    jump = (size_t )(chunk_size & 1U);
#line 311
    chunk_size = (uint32_t )0;
#line 311
    marker = chunk_size;
#line 312
    psf_binheader_readf(psf, "jm4E\270U", jump, & marker, & chunk_size);
    }
#line 313
    if (marker == 0U) {
      {
#line 314
      __cil_tmp17 = psf_ftell(psf);
#line 314
      pos = __cil_tmp17;
#line 315
      psf_log_printf(psf, "Have 0 marker at position %D (0x%x).\nU", pos, pos);
      }
#line 316
      goto while_break;
    }
    {
#line 319
    __cil_tmp18 = psf_ftell(psf);
#line 319
    psf_store_read_chunk_u32(& psf->rchunks, marker, __cil_tmp18, chunk_size);
    }
#line 323
    if (marker == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (88U << 24))) {
#line 323
      goto case_exp;
    }
#line 323
    if (marker == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
#line 323
      goto case_exp;
    }
#line 362
    if (marker == ((unsigned int )((102 | (109 << 8)) | (116 << 16)) | (32U << 24))) {
#line 362
      goto case_exp___1;
    }
#line 380
    if (marker == ((unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24))) {
#line 380
      goto case_exp___2;
    }
#line 426
    if (marker == ((unsigned int )((102 | (97 << 8)) | (99 << 16)) | (116U << 24))) {
#line 426
      goto case_exp___3;
    }
#line 448
    if (marker == ((unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24))) {
#line 448
      goto case_exp___4;
    }
#line 460
    if (marker == ((unsigned int )((99 | (117 << 8)) | (101 << 16)) | (32U << 24))) {
#line 460
      goto case_exp___5;
    }
#line 511
    if (marker == ((unsigned int )((115 | (109 << 8)) | (112 << 16)) | (108U << 24))) {
#line 511
      goto case_exp___6;
    }
#line 520
    if (marker == ((unsigned int )((97 | (99 << 8)) | (105 << 16)) | (100U << 24))) {
#line 520
      goto case_exp___7;
    }
#line 530
    if (marker == ((unsigned int )((76 | (73 << 8)) | (83 << 16)) | (84U << 24))) {
#line 530
      goto case_exp___8;
    }
#line 530
    if (marker == ((unsigned int )((73 | (78 << 8)) | (70 << 16)) | (79U << 24))) {
#line 530
      goto case_exp___8;
    }
#line 537
    if (marker == ((unsigned int )((98 | (101 << 8)) | (120 << 16)) | (116U << 24))) {
#line 537
      goto case_exp___10;
    }
#line 546
    if (marker == ((unsigned int )((80 | (65 << 8)) | (68 << 16)) | (32U << 24))) {
#line 546
      goto case_exp___11;
    }
#line 555
    if (marker == ((unsigned int )((99 | (97 << 8)) | (114 << 16)) | (116U << 24))) {
#line 555
      goto case_exp___12;
    }
#line 580
    if (marker == ((unsigned int )((70 | (76 << 8)) | (76 << 16)) | (82U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((77 | (69 << 8)) | (88 << 16)) | (84U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((68 | (73 << 8)) | (83 << 16)) | (80U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((95 | (80 << 8)) | (77 << 16)) | (88U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((74 | (85 << 8)) | (78 << 16)) | (75U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((67 | (114 << 8)) | (56 << 16)) | (114U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((83 | (121 << 8)) | (76 << 16)) | (112U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((117 | (109 << 8)) | (105 << 16)) | (100U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((65 | (70 << 8)) | (65 << 16)) | (110U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((105 | (110 << 8)) | (115 << 16)) | (116U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((111 | (118 << 8)) | (119 << 16)) | (102U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((114 | (101 << 8)) | (103 << 16)) | (110U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((101 | (108 << 8)) | (109 << 16)) | (49U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((109 | (105 << 8)) | (110 << 16)) | (102U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((112 | (108 << 8)) | (115 << 16)) | (116U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((108 | (101 << 8)) | (118 << 16)) | (108U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((101 | (108 << 8)) | (109 << 16)) | (111U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((99 | (108 << 8)) | (109 << 16)) | (32U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((97 | (102 << 8)) | (115 << 16)) | (112U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((115 | (116 << 8)) | (114 << 16)) | (99U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 580
    if (marker == ((unsigned int )((105 | (88 << 8)) | (77 << 16)) | (76U << 24))) {
#line 580
      goto case_exp___13;
    }
#line 585
    goto switch_default;
    case_exp: 
#line 324
    if (parsestage) {
#line 325
      return (62);
    }
#line 327
    parsestage |= 1;
#line 329
    RIFFsize = chunk_size;
#line 331
    if (psf->fileoffset > 0L) {
#line 331
      if (psf->filelength > (long )(RIFFsize + 8U)) {
#line 333
        psf->filelength = (sf_count_t )(RIFFsize + 8U);
#line 334
        if (marker == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
          {
#line 335
          psf_log_printf(psf, "RIFF : %u\n\232E\270U", RIFFsize);
          }
        } else {
          {
#line 337
          psf_log_printf(psf, "RIFX : %u\n\232E\270U", RIFFsize);
          }
        }
      } else {
#line 331
        goto _L;
      }
    } else
    _L: 
#line 339
    if (psf->filelength < (long )(RIFFsize + (unsigned int )(2 * (int )sizeof(marker)))) {
#line 340
      if (marker == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
        {
#line 341
        psf_log_printf(psf, "RIFF : %u (should be %D)\n", RIFFsize, psf->filelength - (long )(2 * (int )sizeof(marker)));
        }
      } else {
        {
#line 343
        psf_log_printf(psf, "RIFX : %u (should be %D)\n\t\232E\270U", RIFFsize, psf->filelength - (long )(2 * (int )sizeof(marker)));
        }
      }
#line 345
      RIFFsize = (uint32_t )(psf->filelength - (long )(2 * (int )sizeof(RIFFsize)));
    } else
#line 348
    if (marker == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
      {
#line 349
      psf_log_printf(psf, "RIFF : %u\n", RIFFsize);
      }
    } else {
      {
#line 351
      psf_log_printf(psf, "RIFX : %u\n\232E\270U", RIFFsize);
      }
    }
    {
#line 354
    psf_binheader_readf(psf, "m", & marker);
    }
#line 355
    if (marker != ((unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24))) {
#line 356
      return (63);
    }
    {
#line 357
    parsestage |= 2;
#line 358
    psf_log_printf(psf, "WAVE\n");
#line 359
    chunk_size = (uint32_t )0;
    }
#line 360
    goto switch_break;
    case_exp___1: 
#line 363
    if ((parsestage & 3) != 3) {
#line 364
      return (64);
    }
#line 367
    if (parsestage & 4) {
#line 368
      goto switch_break;
    }
    {
#line 370
    parsestage |= 4;
#line 372
    psf_log_printf(psf, "fmt  : %d\n", chunk_size);
#line 374
    error = wavlike_read_fmt_chunk(psf, (int )chunk_size);
    }
#line 374
    if (error) {
#line 375
      return (error);
    }
#line 377
    format = (int )wav_fmt->format;
#line 378
    goto switch_break;
    case_exp___2: 
#line 381
    if ((parsestage & 7) != 7) {
#line 382
      return (72);
    }
#line 384
    if (psf->file.mode == 48) {
#line 384
      if (((unsigned int )parsestage & 2147483648U) != 0U) {
#line 385
        return (48);
      }
    }
#line 387
    parsestage |= 32;
#line 389
    psf->datalength = (sf_count_t )chunk_size;
#line 390
    if (psf->datalength & 1L) {
      {
#line 391
      psf_log_printf(psf, "*** \'data\' chunk should be an even number of bytes in length.\n");
      }
    }
    {
#line 393
    psf->dataoffset = psf_ftell(psf);
    }
#line 395
    if (psf->dataoffset > 0L) {
#line 396
      if (chunk_size == 0U) {
#line 396
        if (RIFFsize == 8U) {
#line 396
          if (psf->filelength > 44L) {
            {
#line 397
            psf_log_printf(psf, "*** Looks like a WAV file which wasn\'t closed properly. Fixing it.\n");
#line 398
            psf->datalength = psf->filelength - psf->dataoffset;
            }
          }
        }
      }
#line 401
      if (psf->datalength > psf->filelength - psf->dataoffset) {
        {
#line 402
        psf_log_printf(psf, "data : %D (should be %D)\n", psf->datalength, psf->filelength - psf->dataoffset);
#line 403
        psf->datalength = psf->filelength - psf->dataoffset;
        }
      } else {
        {
#line 406
        psf_log_printf(psf, "data : %D\n", psf->datalength);
        }
      }
#line 409
      if (psf->datalength + psf->dataoffset < psf->filelength) {
#line 410
        psf->dataend = psf->datalength + psf->dataoffset;
      }
#line 412
      psf->datalength += (long )(chunk_size & 1U);
#line 413
      chunk_size = (uint32_t )0;
    }
#line 416
    if (! psf->sf.seekable) {
#line 417
      goto switch_break;
    } else
#line 416
    if (psf->dataoffset < 0L) {
#line 417
      goto switch_break;
    }
    {
#line 420
    psf_fseek(psf, psf->datalength, 1);
#line 422
    __cil_tmp21 = psf_ftell(psf);
    }
#line 422
    if (__cil_tmp21 != psf->datalength + psf->dataoffset) {
      {
#line 423
      psf_log_printf(psf, "*** psf_fseek past end error ***\n");
      }
    }
#line 424
    goto switch_break;
    case_exp___3: 
#line 427
    if ((parsestage & 3) != 3) {
#line 428
      return (67);
    }
#line 430
    parsestage |= 8;
#line 432
    if ((parsestage & 4) != 4) {
      {
#line 433
      psf_log_printf(psf, "*** Should have \'fmt \' chunk before \'fact\'\n");
      }
    }
    {
#line 435
    psf_binheader_readf(psf, "4", & fact_chunk.frames);
    }
#line 437
    if (chunk_size > (unsigned int )((int )sizeof(fact_chunk))) {
      {
#line 438
      psf_binheader_readf(psf, "j", (int )(chunk_size - (unsigned int )((int )sizeof(fact_chunk))));
      }
    }
#line 440
    if (chunk_size) {
      {
#line 441
      psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
      }
    } else {
      {
#line 443
      psf_log_printf(psf, "%M : %u (should not be zero)\n", marker, chunk_size);
      }
    }
    {
#line 445
    psf_log_printf(psf, "  frames  : %d\n", fact_chunk.frames);
    }
#line 446
    goto switch_break;
    case_exp___4: 
#line 449
    if ((parsestage & 7) != 7) {
#line 450
      return (69);
    }
    {
#line 452
    parsestage |= 16;
#line 454
    psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
#line 455
    error = wavlike_read_peak_chunk(psf, (size_t )chunk_size);
    }
#line 455
    if (error != 0) {
#line 456
      return (error);
    }
#line 457
    if ((parsestage & 32) == 0) {
#line 457
      tmp___0 = 42;
    } else {
#line 457
      tmp___0 = 43;
    }
#line 457
    (psf->peak_info)->peak_loc = tmp___0;
#line 458
    goto switch_break;
    case_exp___5: 
    {
#line 461
    parsestage |= (-0x7FFFFFFF-1);
#line 466
    __cil_tmp34 = psf_binheader_readf(psf, "4", & cue_count);
#line 466
    bytesread = (uint32_t )__cil_tmp34;
#line 467
    psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
    }
#line 469
    if (cue_count > 1000U) {
      {
#line 470
      psf_log_printf(psf, "  Count : %u (skipping)\n\230\001", cue_count);
      }
#line 471
      if (cue_count > 20U) {
#line 471
        tmp___1 = 20U;
      } else {
#line 471
        tmp___1 = cue_count;
      }
      {
#line 471
      psf_binheader_readf(psf, "j", tmp___1 * 24U);
      }
#line 472
      goto switch_break;
    }
    {
#line 475
    psf_log_printf(psf, "  Count : %d\n", cue_count);
#line 477
    psf->cues = psf_cues_alloc(cue_count);
    }
#line 477
    if ((unsigned long )psf->cues == (unsigned long )((void *)0)) {
#line 478
      return (17);
    }
#line 480
    cue_index = 0;
    {
#line 482
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 482
      if (! cue_count) {
#line 482
        goto while_break___0;
      }
      {
#line 484
      __cil_tmp37 = psf_binheader_readf(psf, "e44m444", & id, & position, & chunk_id,
                                        & chunk_start, & block_start, & offset);
#line 484
      thisread = (uint32_t )__cil_tmp37;
      }
#line 484
      if (thisread == 0U) {
#line 485
        goto while_break___0;
      }
      {
#line 486
      bytesread += thisread;
#line 488
      psf_log_printf(psf, "   Cue ID : %2d  Pos : %5u  Chunk : %M  Chk Start : %d  Blk Start : %d  Offset : %5d\n",
                     id, position, chunk_id, chunk_start, block_start, offset);
#line 493
      (psf->cues)->cue_points[cue_index].indx = id;
#line 494
      (psf->cues)->cue_points[cue_index].position = position;
#line 495
      (psf->cues)->cue_points[cue_index].fcc_chunk = chunk_id;
#line 496
      (psf->cues)->cue_points[cue_index].chunk_start = chunk_start;
#line 497
      (psf->cues)->cue_points[cue_index].block_start = block_start;
#line 498
      (psf->cues)->cue_points[cue_index].sample_offset = offset;
#line 499
      (psf->cues)->cue_points[cue_index].name[0] = (char )'\000';
#line 500
      __cil_tmp38 = cue_count;
#line 500
      cue_count --;
#line 501
      cue_index ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 504
    if (bytesread != chunk_size) {
      {
#line 505
      psf_log_printf(psf, "**** Chunk size weirdness (%d != %d)\n", chunk_size, bytesread);
#line 506
      psf_binheader_readf(psf, "j", chunk_size - bytesread);
      }
    }
#line 509
    goto switch_break;
    case_exp___6: 
    {
#line 512
    parsestage |= (-0x7FFFFFFF-1);
#line 514
    psf_log_printf(psf, "smpl : %u\n", chunk_size);
#line 516
    error = wav_read_smpl_chunk(psf, chunk_size);
    }
#line 516
    if (error) {
#line 517
      return (error);
    }
#line 518
    goto switch_break;
    case_exp___7: 
    {
#line 521
    parsestage |= (-0x7FFFFFFF-1);
#line 523
    psf_log_printf(psf, "acid : %u\n", chunk_size);
#line 525
    error = wav_read_acid_chunk(psf, chunk_size);
    }
#line 525
    if (error) {
#line 526
      return (error);
    }
#line 527
    goto switch_break;
    case_exp___8: 
    {
#line 531
    parsestage |= (-0x7FFFFFFF-1);
#line 533
    error = wavlike_subchunk_parse(psf, (int )marker, chunk_size);
    }
#line 533
    if (error != 0) {
#line 534
      return (error);
    }
#line 535
    goto switch_break;
    case_exp___10: 
    {
#line 542
    error = wavlike_read_bext_chunk(psf, chunk_size);
    }
#line 542
    if (error) {
#line 543
      return (error);
    }
#line 544
    goto switch_break;
    case_exp___11: 
    {
#line 551
    psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
#line 552
    psf_binheader_readf(psf, "j", chunk_size);
    }
#line 553
    goto switch_break;
    case_exp___12: 
    {
#line 556
    error = wavlike_read_cart_chunk(psf, chunk_size);
    }
#line 556
    if (error) {
#line 557
      return (error);
    }
#line 558
    goto switch_break;
    case_exp___13: 
    {
#line 581
    psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
#line 582
    psf_binheader_readf(psf, "j", chunk_size);
    }
#line 583
    goto switch_break;
    switch_default: 
#line 586
    if (chunk_size >= 4294901760U) {
      {
#line 587
      done = (uint32_t )1;
#line 588
      __cil_tmp45 = psf_ftell(psf);
#line 588
      psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D with length %u. Exiting parser.\n",
                     marker, __cil_tmp45 - 8L, chunk_size);
      }
#line 589
      goto switch_break;
    }
    {
#line 592
    __cil_tmp49 = psf_isprint((int )(marker & 255U));
#line 592
    __cil_tmp48 = psf_isprint((int )((marker >> 8) & 255U));
#line 592
    __cil_tmp47 = psf_isprint((int )((marker >> 16) & 255U));
#line 592
    __cil_tmp46 = psf_isprint((int )((marker >> 24) & 255U));
    }
#line 592
    if (__cil_tmp46) {
#line 592
      if (__cil_tmp47) {
#line 592
        if (__cil_tmp48) {
#line 592
          if (__cil_tmp49) {
            {
#line 594
            psf_log_printf(psf, "*** %M : %u (unknown marker)\n", marker, chunk_size);
#line 595
            psf_binheader_readf(psf, "j", chunk_size);
            }
#line 596
            goto switch_break;
          }
        }
      }
    }
    {
#line 598
    __cil_tmp50 = psf_ftell(psf);
    }
#line 598
    if (__cil_tmp50 & 3L) {
      {
#line 599
      __cil_tmp51 = psf_ftell(psf);
#line 599
      psf_log_printf(psf, "  Unknown chunk marker at position %D. Resynching.\n",
                     __cil_tmp51 - 8L);
#line 600
      psf_binheader_readf(psf, "j", -3);
#line 602
      parsestage |= (-0x7FFFFFFF-1);
      }
#line 603
      goto switch_break;
    }
    {
#line 605
    __cil_tmp52 = psf_ftell(psf);
#line 605
    psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D. Exiting parser.\n",
                   marker, __cil_tmp52 - 8L);
#line 606
    done = (uint32_t )1;
    }
#line 607
    goto switch_break;
    switch_break: ;
#line 610
    if ((long )chunk_size >= psf->filelength) {
      {
#line 611
      psf_log_printf(psf, "*** Chunk size %u > file length %D. Exiting parser.\n",
                     chunk_size, psf->filelength);
      }
#line 612
      goto while_break;
    }
#line 615
    if (! psf->sf.seekable) {
#line 615
      if (parsestage & 32) {
#line 616
        goto while_break;
      }
    }
    {
#line 618
    __cil_tmp53 = psf_ftell(psf);
    }
#line 618
    if (__cil_tmp53 >= psf->filelength - (long )((int )sizeof(chunk_size))) {
      {
#line 619
      psf_log_printf(psf, "End\n");
      }
#line 620
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 624
  if (psf->dataoffset <= 0L) {
#line 625
    return (72);
  }
#line 627
  if (psf->sf.channels < 1) {
#line 628
    return (33);
  }
#line 630
  if (psf->sf.channels >= 1024) {
#line 631
    return (34);
  }
#line 633
  if (format != 1) {
#line 633
    if ((parsestage & 8) == 0) {
      {
#line 634
      psf_log_printf(psf, "**** All non-PCM format files should have a \'fact\' chunk.\n");
      }
    }
  }
  {
#line 637
  psf->endian = psf->rwf_endian;
#line 639
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 641
  if (psf->is_pipe == 0) {
    {
#line 646
    psf_binheader_readf(psf, "4", & marker);
    }
#line 647
    if (marker == ((unsigned int )((119 | (118 << 8)) | (112 << 16)) | (107U << 24))) {
#line 648
      return (79);
    } else
#line 647
    if (marker == ((unsigned int )((79 | (103 << 8)) | (103 << 16)) | (83U << 24))) {
#line 648
      return (79);
    }
  }
  {
#line 652
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 654
  if (psf->blockwidth) {
#line 655
    if (psf->filelength - psf->dataoffset < psf->datalength) {
#line 656
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    } else {
#line 658
      psf->sf.frames = psf->datalength / (long )psf->blockwidth;
    }
  }
#line 662
  if (format == 65534) {
#line 662
    goto case_65534;
  }
#line 669
  if (format == 1) {
#line 669
    goto case_1;
  }
#line 674
  if (format == 257) {
#line 674
    goto case_257;
  }
#line 674
  if (format == 7) {
#line 674
    goto case_257;
  }
#line 679
  if (format == 258) {
#line 679
    goto case_258;
  }
#line 679
  if (format == 6) {
#line 679
    goto case_258;
  }
#line 683
  if (format == 2) {
#line 683
    goto case_2;
  }
#line 689
  if (format == 17) {
#line 689
    goto case_17;
  }
#line 695
  if (format == 49) {
#line 695
    goto case_49;
  }
#line 699
  if (format == 3) {
#line 699
    goto case_3;
  }
#line 704
  if (format == 64) {
#line 704
    goto case_64;
  }
#line 708
  goto switch_default___0;
  case_65534: 
#line 663
  if (psf->sf.format == 1245203) {
#line 664
    *blockalign = (int )wav_fmt->msadpcm.blockalign;
#line 665
    *framesperblock = (int )wav_fmt->msadpcm.samplesperblock;
  }
#line 667
  goto switch_break___0;
  case_1: 
  {
#line 670
  __cil_tmp54 = u_bitwidth_to_subformat(psf->bytewidth * 8);
#line 670
  psf->sf.format = 65536 | __cil_tmp54;
  }
#line 671
  goto switch_break___0;
  case_257: 
#line 675
  psf->sf.format = 65552;
#line 676
  goto switch_break___0;
  case_258: 
#line 680
  psf->sf.format = 65553;
#line 681
  goto switch_break___0;
  case_2: 
#line 684
  psf->sf.format = 65555;
#line 685
  *blockalign = (int )wav_fmt->msadpcm.blockalign;
#line 686
  *framesperblock = (int )wav_fmt->msadpcm.samplesperblock;
#line 687
  goto switch_break___0;
  case_17: 
#line 690
  psf->sf.format = 65554;
#line 691
  *blockalign = (int )wav_fmt->ima.blockalign;
#line 692
  *framesperblock = (int )wav_fmt->ima.samplesperblock;
#line 693
  goto switch_break___0;
  case_49: 
#line 696
  psf->sf.format = 65568;
#line 697
  goto switch_break___0;
  case_3: 
#line 700
  psf->sf.format = 65536;
#line 701
  if (psf->bytewidth == 8) {
#line 701
    tmp___2 = 7;
  } else {
#line 701
    tmp___2 = 6;
  }
#line 701
  psf->sf.format |= tmp___2;
#line 702
  goto switch_break___0;
  case_64: 
#line 705
  psf->sf.format = 65584;
#line 706
  goto switch_break___0;
  switch_default___0: 
#line 708
  return (18);
  switch_break___0: ;
#line 711
  if (wpriv->fmt_is_broken) {
    {
#line 712
    wavlike_analyze(psf);
    }
  }
#line 715
  if (psf->endian == 536870912) {
#line 716
    psf->sf.format |= 536870912;
  }
#line 718
  return (0);
}
}
#line 722 "/root/patchweave_new/23/src/wav.c"
static int wav_write_fmt_chunk(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int fmt_size ;
  int add_fact_chunk ;
  int blockalign ;
  int framesperblock ;
  int bytespersec ;
  int blockalign___0 ;
  int framesperblock___0 ;
  int bytespersec___0 ;
  int extrabytes ;
  int blockalign___1 ;
  int framesperblock___1 ;
  int bytespersec___1 ;

  {
#line 723
  add_fact_chunk = 0;
#line 725
  subformat = psf->sf.format & 65535;
#line 731
  if (subformat == 4) {
#line 731
    goto case_4;
  }
#line 731
  if (subformat == 3) {
#line 731
    goto case_4;
  }
#line 731
  if (subformat == 2) {
#line 731
    goto case_4;
  }
#line 731
  if (subformat == 5) {
#line 731
    goto case_4;
  }
#line 743
  if (subformat == 7) {
#line 743
    goto case_7;
  }
#line 743
  if (subformat == 6) {
#line 743
    goto case_7;
  }
#line 756
  if (subformat == 16) {
#line 756
    goto case_16;
  }
#line 769
  if (subformat == 17) {
#line 769
    goto case_17;
  }
#line 783
  if (subformat == 18) {
#line 783
    goto case_18;
  }
#line 804
  if (subformat == 19) {
#line 804
    goto case_19;
  }
#line 831
  if (subformat == 48) {
#line 831
    goto case_48;
  }
#line 847
  if (subformat == 32) {
#line 847
    goto case_32;
  }
#line 870
  goto switch_default;
  case_4: 
  {
#line 732
  fmt_size = 16;
#line 735
  psf_binheader_writef(psf, "4224", fmt_size, 1, psf->sf.channels, psf->sf.samplerate);
#line 737
  psf_binheader_writef(psf, "4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 739
  psf_binheader_writef(psf, "22", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
  }
#line 740
  goto switch_break;
  case_7: 
  {
#line 744
  fmt_size = 16;
#line 747
  psf_binheader_writef(psf, "4224", fmt_size, 3, psf->sf.channels, psf->sf.samplerate);
#line 749
  psf_binheader_writef(psf, "4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 751
  psf_binheader_writef(psf, "22\233E\270U", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
#line 753
  add_fact_chunk = 1;
  }
#line 754
  goto switch_break;
  case_16: 
  {
#line 757
  fmt_size = 18;
#line 760
  psf_binheader_writef(psf, "4224\270U", fmt_size, 7, psf->sf.channels, psf->sf.samplerate);
#line 762
  psf_binheader_writef(psf, "4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 764
  psf_binheader_writef(psf, "222E\270U", psf->bytewidth * psf->sf.channels, 8, 0);
#line 766
  add_fact_chunk = 1;
  }
#line 767
  goto switch_break;
  case_17: 
  {
#line 770
  fmt_size = 18;
#line 773
  psf_binheader_writef(psf, "4224\270U", fmt_size, 6, psf->sf.channels, psf->sf.samplerate);
#line 775
  psf_binheader_writef(psf, "4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 777
  psf_binheader_writef(psf, "222", psf->bytewidth * psf->sf.channels, 8, 0);
#line 779
  add_fact_chunk = 1;
  }
#line 780
  goto switch_break;
  case_18: 
  {
#line 786
  blockalign = wavlike_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 787
  framesperblock = (2 * (blockalign - 4 * psf->sf.channels)) / psf->sf.channels + 1;
#line 788
  bytespersec = (psf->sf.samplerate * blockalign) / framesperblock;
#line 791
  fmt_size = 20;
#line 794
  psf_binheader_writef(psf, "42244U", fmt_size, 17, psf->sf.channels, psf->sf.samplerate,
                       bytespersec);
#line 798
  psf_binheader_writef(psf, "2222", blockalign, 4, 2, framesperblock);
#line 801
  add_fact_chunk = 1;
  }
#line 802
  goto switch_break;
  case_19: 
  {
#line 807
  blockalign___0 = wavlike_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 808
  framesperblock___0 = 2 + (2 * (blockalign___0 - 7 * psf->sf.channels)) / psf->sf.channels;
#line 809
  bytespersec___0 = (psf->sf.samplerate * blockalign___0) / framesperblock___0;
#line 812
  extrabytes = 32;
#line 813
  fmt_size = 18 + extrabytes;
#line 816
  psf_binheader_writef(psf, "422E\270U", fmt_size, 2, psf->sf.channels);
#line 819
  psf_binheader_writef(psf, "44\233E\270U", psf->sf.samplerate, bytespersec___0);
#line 822
  psf_binheader_writef(psf, "22222", blockalign___0, 4, extrabytes, framesperblock___0,
                       7);
#line 824
  wavlike_msadpcm_write_adapt_coeffs(psf);
#line 827
  add_fact_chunk = 1;
  }
#line 828
  goto switch_break;
  case_48: 
  {
#line 833
  fmt_size = 20;
#line 836
  psf_binheader_writef(psf, "42244U", fmt_size, 64, psf->sf.channels, psf->sf.samplerate,
                       (psf->sf.samplerate * psf->sf.channels) / 2);
#line 840
  psf_binheader_writef(psf, "2222\270U", 64, 4, 2, 0);
#line 842
  add_fact_chunk = 1;
  }
#line 843
  goto switch_break;
  case_32: 
  {
#line 850
  blockalign___1 = 65;
#line 851
  framesperblock___1 = 320;
#line 852
  bytespersec___1 = (psf->sf.samplerate * blockalign___1) / framesperblock___1;
#line 855
  fmt_size = 20;
#line 858
  psf_binheader_writef(psf, "422", fmt_size, 49, psf->sf.channels);
#line 861
  psf_binheader_writef(psf, "44", psf->sf.samplerate, bytespersec___1);
#line 864
  psf_binheader_writef(psf, "2222", blockalign___1, 0, 2, framesperblock___1);
#line 867
  add_fact_chunk = 1;
  }
#line 868
  goto switch_break;
  switch_default: 
#line 870
  return (18);
  switch_break: ;
#line 873
  if (add_fact_chunk) {
    {
#line 874
    psf_binheader_writef(psf, "tm48", (unsigned int )((102 | (97 << 8)) | (99 << 16)) | (116U << 24),
                         4, psf->sf.frames);
    }
  }
#line 876
  return (0);
}
}
#line 880 "/root/patchweave_new/23/src/wav.c"
static int wavex_write_fmt_chunk(SF_PRIVATE *psf ) 
{ 
  WAVLIKE_PRIVATE *wpriv ;
  int subformat ;
  int fmt_size ;
  EXT_SUBFORMAT *tmp ;
  EXT_SUBFORMAT *tmp___0 ;

  {
#line 884
  wpriv = (WAVLIKE_PRIVATE *)psf->container_data;
#line 884
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 885
    return (30);
  }
#line 887
  subformat = psf->sf.format & 65535;
#line 898
  if (subformat == 17) {
#line 898
    goto case_17;
  }
#line 898
  if (subformat == 16) {
#line 898
    goto case_17;
  }
#line 898
  if (subformat == 7) {
#line 898
    goto case_17;
  }
#line 898
  if (subformat == 6) {
#line 898
    goto case_17;
  }
#line 898
  if (subformat == 4) {
#line 898
    goto case_17;
  }
#line 898
  if (subformat == 3) {
#line 898
    goto case_17;
  }
#line 898
  if (subformat == 2) {
#line 898
    goto case_17;
  }
#line 898
  if (subformat == 5) {
#line 898
    goto case_17;
  }
#line 928
  if (subformat == 1) {
#line 928
    goto case_1;
  }
#line 932
  if (subformat == 2) {
#line 932
    goto case_2___0;
  }
#line 936
  if (subformat == 4) {
#line 936
    goto case_4___0;
  }
#line 940
  if (subformat == 6) {
#line 940
    goto case_6___0;
  }
#line 944
  if (subformat == 8) {
#line 944
    goto case_8;
  }
#line 956
  goto switch_default___0;
  case_17: 
  {
#line 899
  fmt_size = 40;
#line 902
  psf_binheader_writef(psf, "4224\270U", fmt_size, 65534, psf->sf.channels, psf->sf.samplerate);
#line 904
  psf_binheader_writef(psf, "4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 906
  psf_binheader_writef(psf, "22", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
#line 909
  psf_binheader_writef(psf, "2", 22);
#line 912
  psf_binheader_writef(psf, "2 \234E\270U", psf->bytewidth * 8);
  }
#line 917
  if (wpriv->wavex_ambisonic != 64) {
    {
#line 918
    psf_binheader_writef(psf, "4\306\234E\270U", 0);
    }
  } else
#line 919
  if (wpriv->wavex_channelmask != 0U) {
    {
#line 920
    psf_binheader_writef(psf, "4g\235E\270U", wpriv->wavex_channelmask);
    }
  } else {
#line 928
    if (psf->sf.channels == 1) {
#line 928
      goto case_1;
    }
#line 932
    if (psf->sf.channels == 2) {
#line 932
      goto case_2___0;
    }
#line 936
    if (psf->sf.channels == 4) {
#line 936
      goto case_4___0;
    }
#line 940
    if (psf->sf.channels == 6) {
#line 940
      goto case_6___0;
    }
#line 944
    if (psf->sf.channels == 8) {
#line 944
      goto case_8;
    }
#line 948
    goto switch_default;
    case_1: 
    {
#line 929
    psf_binheader_writef(psf, "4\276\234E\270U", 4);
    }
#line 930
    goto switch_break___0;
    case_2___0: 
    {
#line 933
    psf_binheader_writef(psf, "4r\234E\270U", 3);
    }
#line 934
    goto switch_break___0;
    case_4___0: 
    {
#line 937
    psf_binheader_writef(psf, "4s\234E\270U", 51);
    }
#line 938
    goto switch_break___0;
    case_6___0: 
    {
#line 941
    psf_binheader_writef(psf, "4+\233E\270U", 63);
    }
#line 942
    goto switch_break___0;
    case_8: 
    {
#line 945
    psf_binheader_writef(psf, "4", 255);
    }
#line 946
    goto switch_break___0;
    switch_default: 
    {
#line 949
    psf_binheader_writef(psf, "4", 0);
    }
#line 950
    goto switch_break___0;
    switch_break___0: ;
  }
#line 953
  goto switch_break;
  switch_default___0: 
#line 957
  return (18);
  switch_break: ;
#line 966
  if (subformat == 4) {
#line 966
    goto case_4___1;
  }
#line 966
  if (subformat == 3) {
#line 966
    goto case_4___1;
  }
#line 966
  if (subformat == 2) {
#line 966
    goto case_4___1;
  }
#line 966
  if (subformat == 5) {
#line 966
    goto case_4___1;
  }
#line 972
  if (subformat == 7) {
#line 972
    goto case_7___0;
  }
#line 972
  if (subformat == 6) {
#line 972
    goto case_7___0;
  }
#line 977
  if (subformat == 16) {
#line 977
    goto case_16___0;
  }
#line 981
  if (subformat == 17) {
#line 981
    goto case_17___0;
  }
#line 993
  goto switch_default___1;
  case_4___1: 
#line 967
  if (wpriv->wavex_ambisonic == 64) {
#line 967
    tmp = & MSGUID_SUBTYPE_PCM___0;
  } else {
#line 967
    tmp = & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM___0;
  }
  {
#line 967
  wavlike_write_guid(psf, tmp);
  }
#line 969
  goto switch_break___1;
  case_7___0: 
#line 973
  if (wpriv->wavex_ambisonic == 64) {
#line 973
    tmp___0 = & MSGUID_SUBTYPE_IEEE_FLOAT___0;
  } else {
#line 973
    tmp___0 = & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT___0;
  }
  {
#line 973
  wavlike_write_guid(psf, tmp___0);
  }
#line 975
  goto switch_break___1;
  case_16___0: 
  {
#line 978
  wavlike_write_guid(psf, & MSGUID_SUBTYPE_MULAW___0);
  }
#line 979
  goto switch_break___1;
  case_17___0: 
  {
#line 982
  wavlike_write_guid(psf, & MSGUID_SUBTYPE_ALAW___0);
  }
#line 983
  goto switch_break___1;
  switch_default___1: 
#line 993
  return (18);
  switch_break___1: 
  {
#line 996
  psf_binheader_writef(psf, "tm48", (unsigned int )((102 | (97 << 8)) | (99 << 16)) | (116U << 24),
                       4, psf->sf.frames);
  }
#line 998
  return (0);
}
}
#line 1003 "/root/patchweave_new/23/src/wav.c"
static int wav_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int error ;
  int has_data ;
  long tmp ;
  long tmp___0 ;
  uint32_t k ;
  int tmp___1 ;
  double dtune ;
  int type ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t k___0 ;

  {
  {
#line 1005
  has_data = 0;
#line 1007
  current = psf_ftell(psf);
  }
#line 1009
  if (current > psf->dataoffset) {
#line 1010
    has_data = 1;
  }
#line 1012
  if (calc_length) {
    {
#line 1013
    psf->filelength = psf_get_filelen(psf);
#line 1015
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 1017
    if (psf->dataend) {
#line 1018
      psf->datalength -= psf->filelength - psf->dataend;
    } else
#line 1019
    if (psf->bytewidth > 0) {
#line 1019
      if (psf->sf.seekable == 1) {
#line 1020
        psf->datalength = (psf->sf.frames * (long )psf->bytewidth) * (long )psf->sf.channels;
      }
    }
  }
  {
#line 1024
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 1025
  psf->header.indx = (sf_count_t )0;
#line 1026
  psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 1036
  if (psf->endian == 268435456) {
#line 1037
    if (psf->filelength < 8L) {
#line 1037
      tmp = 8L;
    } else {
#line 1037
      tmp = psf->filelength - 8L;
    }
    {
#line 1037
    psf_binheader_writef(psf, "etm8", (unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24),
                         tmp);
    }
  } else {
#line 1039
    if (psf->filelength < 8L) {
#line 1039
      tmp___0 = 8L;
    } else {
#line 1039
      tmp___0 = psf->filelength - 8L;
    }
    {
#line 1039
    psf_binheader_writef(psf, "Etm8\270U", (unsigned int )((82 | (73 << 8)) | (70 << 16)) | (88U << 24),
                         tmp___0);
    }
  }
  {
#line 1042
  psf_binheader_writef(psf, "mm", (unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24),
                       (unsigned int )((102 | (109 << 8)) | (116 << 16)) | (32U << 24));
  }
#line 1046
  if ((psf->sf.format & 268369920) == 65536) {
#line 1046
    goto case_65536;
  }
#line 1051
  if ((psf->sf.format & 268369920) == 1245184) {
#line 1051
    goto case_1245184;
  }
#line 1056
  goto switch_default;
  case_65536: 
  {
#line 1047
  error = wav_write_fmt_chunk(psf);
  }
#line 1047
  if (error != 0) {
#line 1048
    return (error);
  }
#line 1049
  goto switch_break;
  case_1245184: 
  {
#line 1052
  error = wavex_write_fmt_chunk(psf);
  }
#line 1052
  if (error != 0) {
#line 1053
    return (error);
  }
#line 1054
  goto switch_break;
  switch_default: 
#line 1057
  return (18);
  switch_break: ;
#line 1061
  if (psf->strings.flags & 1024U) {
    {
#line 1062
    wavlike_write_strings(psf, 1024);
    }
  }
#line 1064
  if ((unsigned long )psf->peak_info != (unsigned long )((void *)0)) {
#line 1064
    if ((psf->peak_info)->peak_loc == 42) {
      {
#line 1065
      wavlike_write_peak_chunk(psf);
      }
    }
  }
#line 1067
  if ((unsigned long )psf->broadcast_16k != (unsigned long )((void *)0)) {
    {
#line 1068
    wavlike_write_bext_chunk(psf);
    }
  }
#line 1070
  if ((unsigned long )psf->cart_16k != (unsigned long )((void *)0)) {
    {
#line 1071
    wavlike_write_cart_chunk(psf);
    }
  }
#line 1073
  if ((unsigned long )psf->cues != (unsigned long )((void *)0)) {
    {
#line 1076
    psf_binheader_writef(psf, "em44", (unsigned int )((99 | (117 << 8)) | (101 << 16)) | (32U << 24),
                         4U + ((psf->cues)->cue_count * 6U) * 4U, (psf->cues)->cue_count);
#line 1078
    k = (uint32_t )0;
    }
    {
#line 1078
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1078
      if (! (k < (psf->cues)->cue_count)) {
#line 1078
        goto while_break;
      }
      {
#line 1079
      psf_binheader_writef(psf, "e44m444", (psf->cues)->cue_points[k].indx, (psf->cues)->cue_points[k].position,
                           (psf->cues)->cue_points[k].fcc_chunk, (psf->cues)->cue_points[k].chunk_start,
                           (psf->cues)->cue_points[k].block_start, (psf->cues)->cue_points[k].sample_offset);
#line 1078
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 1084
  if ((unsigned long )psf->instrument != (unsigned long )((void *)0)) {
    {
#line 1086
    dtune = (double )1073741824 / 25.;
#line 1088
    psf_binheader_writef(psf, "m4", (unsigned int )((115 | (109 << 8)) | (112 << 16)) | (108U << 24),
                         36 + ((psf->instrument)->loop_count * 6) * 4);
#line 1089
    psf_binheader_writef(psf, "44", 0, 0);
#line 1090
    tmp___1 = (int )(1000000000. / (double )psf->sf.samplerate);
#line 1091
    psf_binheader_writef(psf, "44\235E\270U", tmp___1, (int )(psf->instrument)->basenote);
#line 1092
    tmp___1 = (int )((uint32_t )((double )((int )(psf->instrument)->detune) * dtune + 0.5));
#line 1093
    psf_binheader_writef(psf, "4", tmp___1);
#line 1094
    psf_binheader_writef(psf, "44\232E\270U", 0, 0);
#line 1095
    psf_binheader_writef(psf, "44\232E\270U", (psf->instrument)->loop_count, 0);
#line 1097
    tmp___1 = 0;
    }
    {
#line 1097
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1097
      if (! (tmp___1 < (psf->instrument)->loop_count)) {
#line 1097
        goto while_break___0;
      }
#line 1100
      type = (psf->instrument)->loops[tmp___1].mode;
#line 1101
      if (type == 801) {
#line 1101
        tmp___17 = 0;
      } else {
#line 1101
        if (type == 802) {
#line 1101
          tmp___16 = 2;
        } else {
#line 1101
          if (type == 803) {
#line 1101
            tmp___15 = 1;
          } else {
#line 1101
            tmp___15 = 32;
          }
#line 1101
          tmp___16 = tmp___15;
        }
#line 1101
        tmp___17 = tmp___16;
      }
      {
#line 1101
      type = tmp___17;
#line 1103
      psf_binheader_writef(psf, "44", tmp___1, type);
#line 1104
      psf_binheader_writef(psf, "44\232E\270U", (psf->instrument)->loops[tmp___1].start,
                           (psf->instrument)->loops[tmp___1].end - 1U);
#line 1105
      psf_binheader_writef(psf, "44", 0, (psf->instrument)->loops[tmp___1].count);
#line 1097
      tmp___1 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 1110
  if (psf->wchunks.used > 0U) {
    {
#line 1111
    wavlike_write_custom_chunks(psf);
    }
  }
#line 1113
  if (psf->header.indx + 16L < psf->dataoffset) {
    {
#line 1115
    k___0 = (size_t )(psf->dataoffset - (psf->header.indx + 16L));
#line 1116
    psf_binheader_writef(psf, "m4z", (unsigned int )((80 | (65 << 8)) | (68 << 16)) | (32U << 24),
                         k___0, k___0);
    }
  }
  {
#line 1119
  psf_binheader_writef(psf, "tm8E\270U", (unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24),
                       psf->datalength);
#line 1120
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 1121
  if (psf->error) {
#line 1122
    return (psf->error);
  }
#line 1124
  if (has_data) {
#line 1124
    if (psf->dataoffset != psf->header.indx) {
      {
#line 1125
      psf_log_printf(psf, "Oooops : has_data && psf->dataoffset != psf->header.indx\n");
#line 1126
      psf->error = 30;
      }
#line 1126
      return (psf->error);
    }
  }
#line 1129
  psf->dataoffset = psf->header.indx;
#line 1131
  if (! has_data) {
    {
#line 1132
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 1133
  if (current > 0L) {
    {
#line 1134
    psf_fseek(psf, current, 0);
    }
  }
#line 1136
  return (psf->error);
}
}
#line 1141 "/root/patchweave_new/23/src/wav.c"
static int wav_write_tailer(SF_PRIVATE *psf ) 
{ 


  {
#line 1144
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 1145
  psf->header.indx = (sf_count_t )0;
#line 1147
  if (psf->bytewidth > 0) {
#line 1147
    if (psf->sf.seekable == 1) {
#line 1148
      psf->datalength = (psf->sf.frames * (long )psf->bytewidth) * (long )psf->sf.channels;
#line 1149
      psf->dataend = psf->dataoffset + psf->datalength;
    }
  }
#line 1152
  if (psf->dataend > 0L) {
    {
#line 1153
    psf_fseek(psf, psf->dataend, 0);
    }
  } else {
    {
#line 1155
    psf->dataend = psf_fseek(psf, (sf_count_t )0, 2);
    }
  }
#line 1157
  if (psf->dataend & 1L) {
    {
#line 1158
    psf_binheader_writef(psf, "zi\235E\270U", 1);
    }
  }
#line 1161
  if ((unsigned long )psf->peak_info != (unsigned long )((void *)0)) {
#line 1161
    if ((psf->peak_info)->peak_loc == 43) {
      {
#line 1162
      wavlike_write_peak_chunk(psf);
      }
    }
  }
#line 1164
  if (psf->strings.flags & 2048U) {
    {
#line 1165
    wavlike_write_strings(psf, 2048);
    }
  }
#line 1168
  if (psf->header.indx > 0L) {
    {
#line 1169
    psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1,
               psf);
    }
  }
#line 1171
  return (0);
}
}
#line 1175 "/root/patchweave_new/23/src/wav.c"
static int wav_close(SF_PRIVATE *psf ) 
{ 
  sf_count_t current ;
  sf_count_t __cil_tmp3 ;

  {
#line 1177
  if (psf->file.mode == 32) {
    _L: 
    {
#line 1178
    wav_write_tailer(psf);
    }
#line 1180
    if (psf->file.mode == 48) {
      {
#line 1181
      __cil_tmp3 = psf_ftell(psf);
#line 1181
      current = __cil_tmp3;
      }
#line 1188
      if (current < psf->filelength) {
        {
#line 1189
        psf_ftruncate(psf, current);
#line 1190
        psf->filelength = current;
        }
      }
    }
    {
#line 1194
    (*(psf->write_header))(psf, 1);
    }
  } else
#line 1177
  if (psf->file.mode == 48) {
#line 1177
    goto _L;
  }
#line 1197
  return (0);
}
}
#line 1201 "/root/patchweave_new/23/src/wav.c"
static int wav_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int datasize ) 
{ 
  WAVLIKE_PRIVATE *wpriv ;
  int __cil_tmp6 ;

  {
#line 1204
  wpriv = (WAVLIKE_PRIVATE *)psf->container_data;
#line 1204
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 1205
    return (30);
  }
#line 1208
  if (command == 4608) {
#line 1208
    goto case_4608;
  }
#line 1219
  if (command == 4609) {
#line 1219
    goto case_4609;
  }
#line 1222
  if (command == 4353) {
#line 1222
    goto case_4353;
  }
#line 1226
  goto switch_default;
  case_4608: 
#line 1209
  if ((psf->sf.format & 268369920) == 1245184) {
#line 1210
    if (datasize == 64) {
#line 1211
      wpriv->wavex_ambisonic = 64;
    } else
#line 1212
    if (datasize == 65) {
#line 1213
      wpriv->wavex_ambisonic = 65;
    } else {
#line 1215
      return (0);
    }
  }
#line 1217
  return (wpriv->wavex_ambisonic);
  case_4609: 
#line 1220
  return (wpriv->wavex_ambisonic);
  case_4353: 
  {
#line 1223
  __cil_tmp6 = wavlike_gen_channel_mask((int const   *)psf->channel_map, psf->sf.channels);
#line 1223
  wpriv->wavex_channelmask = (unsigned int )__cil_tmp6;
  }
#line 1224
  return (wpriv->wavex_channelmask != 0U);
  switch_default: 
#line 1227
  goto switch_break;
  switch_break: ;
#line 1230
  return (0);
}
}
#line 1234 "/root/patchweave_new/23/src/wav.c"
static int wav_read_smpl_chunk(SF_PRIVATE *psf , uint32_t chunklen ) 
{ 
  char buffer[512] ;
  uint32_t thisread ;
  uint32_t bytesread ;
  uint32_t dword ;
  uint32_t sampler_data ;
  uint32_t loop_count ;
  uint32_t note ;
  uint32_t start ;
  uint32_t end ;
  uint32_t type ;
  uint32_t count___0 ;
  int j ;
  int k ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  char ch ;
  int __cil_tmp35 ;

  {
  {
#line 1236
  bytesread = (uint32_t )0;
#line 1237
  type = (uint32_t )-1;
#line 1240
  chunklen += chunklen & 1U;
#line 1242
  __cil_tmp16 = psf_binheader_readf(psf, "4E\235E\270U", & dword);
#line 1242
  bytesread += (unsigned int )__cil_tmp16;
#line 1243
  psf_log_printf(psf, "  Manufacturer : %X\n", dword);
#line 1245
  __cil_tmp17 = psf_binheader_readf(psf, "4", & dword);
#line 1245
  bytesread += (unsigned int )__cil_tmp17;
#line 1246
  psf_log_printf(psf, "  Product      : %u\n\270U", dword);
#line 1248
  __cil_tmp18 = psf_binheader_readf(psf, "44\235E\270U", & dword);
#line 1248
  bytesread += (unsigned int )__cil_tmp18;
#line 1249
  psf_log_printf(psf, "  Period       : %u nsec\n_\232E\270U", dword);
#line 1251
  __cil_tmp19 = psf_binheader_readf(psf, "4", & note);
#line 1251
  bytesread += (unsigned int )__cil_tmp19;
#line 1252
  psf_log_printf(psf, "  Midi Note    : %u\n\270U", note);
#line 1254
  __cil_tmp20 = psf_binheader_readf(psf, "4.\235E\270U", & dword);
#line 1254
  bytesread += (unsigned int )__cil_tmp20;
  }
#line 1255
  if (dword != 0U) {
    {
#line 1256
    snprintf(buffer, sizeof(buffer), "%f", (1. * (double )2147483648U) / (double )dword);
#line 1258
    psf_log_printf(psf, "  Pitch Fract. : %s\n\270U", buffer);
    }
  } else {
    {
#line 1261
    psf_log_printf(psf, "  Pitch Fract. : 0\n");
    }
  }
  {
#line 1263
  __cil_tmp21 = psf_binheader_readf(psf, "4", & dword);
#line 1263
  bytesread += (unsigned int )__cil_tmp21;
#line 1264
  psf_log_printf(psf, "  SMPTE Format : %u\n", dword);
#line 1266
  __cil_tmp22 = psf_binheader_readf(psf, "4", & dword);
#line 1266
  bytesread += (unsigned int )__cil_tmp22;
#line 1267
  snprintf(buffer, sizeof(buffer), "%02d:%02d:%02d %02dE\270U", (dword >> 24) & 127U,
           (dword >> 16) & 127U, (dword >> 8) & 127U, dword & 127U);
#line 1269
  psf_log_printf(psf, "  SMPTE Offset : %s\n", buffer);
#line 1271
  __cil_tmp23 = psf_binheader_readf(psf, "4\325\235E\270U", & loop_count);
#line 1271
  bytesread += (unsigned int )__cil_tmp23;
#line 1272
  psf_log_printf(psf, "  Loop Count   : %u\n", loop_count);
  }
#line 1274
  if (loop_count == 0U) {
#line 1274
    if (chunklen == bytesread) {
#line 1275
      return (0);
    }
  }
  {
#line 1280
  __cil_tmp24 = psf_binheader_readf(psf, "4", & sampler_data);
#line 1280
  bytesread += (unsigned int )__cil_tmp24;
#line 1282
  psf->instrument = psf_instrument_alloc();
  }
#line 1282
  if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 1283
    return (17);
  }
#line 1285
  (psf->instrument)->loop_count = (int )loop_count;
#line 1287
  j = 0;
  {
#line 1287
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1287
    if (loop_count > 0U) {
#line 1287
      if (! (chunklen - bytesread >= 24U)) {
#line 1287
        goto while_break;
      }
    } else {
#line 1287
      goto while_break;
    }
    {
#line 1288
    __cil_tmp26 = psf_binheader_readf(psf, "4\021\235E\270U", & dword);
#line 1288
    thisread = (uint32_t )__cil_tmp26;
    }
#line 1288
    if (thisread == 0U) {
#line 1289
      goto while_break;
    }
    {
#line 1290
    bytesread += thisread;
#line 1291
    psf_log_printf(psf, "    Cue ID : %2u\230\001", dword);
#line 1293
    __cil_tmp27 = psf_binheader_readf(psf, "4\026\236E\270U", & type);
#line 1293
    bytesread += (unsigned int )__cil_tmp27;
#line 1294
    psf_log_printf(psf, "  Type : %2u", type);
#line 1296
    __cil_tmp28 = psf_binheader_readf(psf, "4\017\235E\270U", & start);
#line 1296
    bytesread += (unsigned int )__cil_tmp28;
#line 1297
    psf_log_printf(psf, "  Start : %5uU", start);
#line 1299
    __cil_tmp29 = psf_binheader_readf(psf, "4", & end);
#line 1299
    bytesread += (unsigned int )__cil_tmp29;
#line 1300
    psf_log_printf(psf, "  End : %5uE\270U", end);
#line 1302
    __cil_tmp30 = psf_binheader_readf(psf, "4\v\235E\270U", & dword);
#line 1302
    bytesread += (unsigned int )__cil_tmp30;
#line 1303
    psf_log_printf(psf, "  Fraction : %5u\230\001", dword);
#line 1305
    __cil_tmp31 = psf_binheader_readf(psf, "4\n\235E\270U", & count___0);
#line 1305
    bytesread += (unsigned int )__cil_tmp31;
#line 1306
    psf_log_printf(psf, "  Count : %5u\n", count___0);
    }
#line 1308
    if (j < (int )(sizeof((psf->instrument)->loops) / sizeof((psf->instrument)->loops[0]))) {
#line 1309
      (psf->instrument)->loops[j].start = start;
#line 1310
      (psf->instrument)->loops[j].end = end + 1U;
#line 1311
      (psf->instrument)->loops[j].count = count___0;
#line 1314
      if (type == 0U) {
#line 1314
        goto case_0;
      }
#line 1317
      if (type == 1U) {
#line 1317
        goto case_1;
      }
#line 1320
      if (type == 2U) {
#line 1320
        goto case_2;
      }
#line 1323
      goto switch_default;
      case_0: 
#line 1315
      (psf->instrument)->loops[j].mode = 801;
#line 1316
      goto switch_break;
      case_1: 
#line 1318
      (psf->instrument)->loops[j].mode = 803;
#line 1319
      goto switch_break;
      case_2: 
#line 1321
      (psf->instrument)->loops[j].mode = 802;
#line 1322
      goto switch_break;
      switch_default: 
#line 1324
      (psf->instrument)->loops[j].mode = 800;
#line 1325
      goto switch_break;
      switch_break: ;
    }
#line 1329
    __cil_tmp32 = loop_count;
#line 1329
    loop_count --;
#line 1287
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1332
  if (chunklen - bytesread == 0U) {
#line 1333
    if (sampler_data != 0U) {
      {
#line 1334
      psf_log_printf(psf, "  Sampler Data : %u (should be 0)\n", sampler_data);
      }
    } else {
      {
#line 1336
      psf_log_printf(psf, "  Sampler Data : %u\n", sampler_data);
      }
    }
  } else {
#line 1339
    if (sampler_data != chunklen - bytesread) {
      {
#line 1340
      psf_log_printf(psf, "  Sampler Data : %u (should have been %u)\n", sampler_data,
                     chunklen - bytesread);
#line 1341
      sampler_data = chunklen - bytesread;
      }
    } else {
      {
#line 1344
      psf_log_printf(psf, "  Sampler Data : %u\n", sampler_data);
      }
    }
    {
#line 1346
    psf_log_printf(psf, "      ");
#line 1347
    k = 0;
    }
    {
#line 1347
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1347
      if (! (k < (int )sampler_data)) {
#line 1347
        goto while_break___0;
      }
#line 1350
      if (k > 0) {
#line 1350
        if (k % 20 == 0) {
          {
#line 1351
          psf_log_printf(psf, "\n      ");
          }
        }
      }
      {
#line 1353
      __cil_tmp35 = psf_binheader_readf(psf, "1", & ch);
#line 1353
      thisread = (uint32_t )__cil_tmp35;
      }
#line 1353
      if (thisread == 0U) {
#line 1354
        goto while_break___0;
      }
      {
#line 1355
      bytesread += thisread;
#line 1356
      psf_log_printf(psf, "%02X ", (int )ch & 255);
#line 1347
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 1359
    psf_log_printf(psf, "\n\027\236E\270U");
    }
  }
#line 1362
  (psf->instrument)->basenote = (char )note;
#line 1363
  (psf->instrument)->gain = 1;
#line 1364
  (psf->instrument)->key_lo = (char)0;
#line 1364
  (psf->instrument)->velocity_lo = (psf->instrument)->key_lo;
#line 1365
  (psf->instrument)->key_hi = (char)127;
#line 1365
  (psf->instrument)->velocity_hi = (psf->instrument)->key_hi;
#line 1367
  return (0);
}
}
#line 1402 "/root/patchweave_new/23/src/wav.c"
static int wav_read_acid_chunk(SF_PRIVATE *psf , uint32_t chunklen ) 
{ 
  char buffer[512] ;
  uint32_t bytesread ;
  int beats ;
  int flags ;
  short rootnote ;
  short q1 ;
  short meter_denom ;
  short meter_numer ;
  float q2 ;
  float tempo ;
  int __cil_tmp13 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int __cil_tmp19 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 1404
  bytesread = (uint32_t )0;
#line 1409
  chunklen += chunklen & 1U;
#line 1411
  __cil_tmp13 = psf_binheader_readf(psf, "422f", & flags, & rootnote, & q1, & q2);
#line 1411
  bytesread += (unsigned int )__cil_tmp13;
#line 1413
  snprintf(buffer, sizeof(buffer), "%f", (double )q2);
  }
#line 1415
  if (flags & 1) {
#line 1415
    tmp = "OneShot";
  } else {
#line 1415
    tmp = "Loop";
  }
#line 1415
  if (flags & 2) {
#line 1415
    tmp___0 = "RootNoteValid";
  } else {
#line 1415
    tmp___0 = "RootNoteInvalid";
  }
#line 1415
  if (flags & 4) {
#line 1415
    tmp___1 = "StretchOn";
  } else {
#line 1415
    tmp___1 = "StretchOff";
  }
#line 1415
  if (flags & 8) {
#line 1415
    tmp___2 = "DiskBased";
  } else {
#line 1415
    tmp___2 = "RAMBased\220";
  }
#line 1415
  if (flags & 16) {
#line 1415
    tmp___3 = "??On";
  } else {
#line 1415
    tmp___3 = "??Off";
  }
  {
#line 1415
  psf_log_printf(psf, "  Flags     : 0x%04x (%s,%s,%s,%s,%s)\n", flags, tmp, tmp___0,
                 tmp___1, tmp___2, tmp___3);
#line 1422
  psf_log_printf(psf, "  Root note : 0x%x\n  ????      : 0x%04x\n  ????      : %s\n",
                 (int )rootnote, (int )q1, buffer);
#line 1425
  __cil_tmp19 = psf_binheader_readf(psf, "422f", & beats, & meter_denom, & meter_numer,
                                    & tempo);
#line 1425
  bytesread += (unsigned int )__cil_tmp19;
#line 1426
  snprintf(buffer, sizeof(buffer), "%f", (double )tempo);
#line 1427
  psf_log_printf(psf, "  Beats     : %d\n  Meter     : %d/%d\n  Tempo     : %s\n",
                 beats, (int )meter_numer, (int )meter_denom, buffer);
#line 1430
  psf_binheader_readf(psf, "j", chunklen - bytesread);
#line 1432
  tmp___6 = calloc(1UL, sizeof(SF_LOOP_INFO ));
#line 1432
  psf->loop_info = (SF_LOOP_INFO *)tmp___6;
  }
#line 1432
  if ((unsigned long )psf->loop_info == (unsigned long )((void *)0)) {
#line 1433
    return (17);
  }
#line 1435
  (psf->loop_info)->time_sig_num = meter_numer;
#line 1436
  (psf->loop_info)->time_sig_den = meter_denom;
#line 1437
  if (flags & 1) {
#line 1437
    tmp___4 = 800;
  } else {
#line 1437
    tmp___4 = 801;
  }
#line 1437
  (psf->loop_info)->loop_mode = tmp___4;
#line 1438
  (psf->loop_info)->num_beats = beats;
#line 1439
  (psf->loop_info)->bpm = tempo;
#line 1440
  if (flags & 2) {
#line 1440
    tmp___5 = (int )rootnote;
  } else {
#line 1440
    tmp___5 = -1;
  }
#line 1440
  (psf->loop_info)->root_key = tmp___5;
#line 1442
  return (0);
}
}
#line 1449 "/root/patchweave_new/23/src/wav.c"
static int wav_set_chunk(SF_PRIVATE *psf , SF_CHUNK_INFO *chunk_info ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1450
  __cil_tmp3 = psf_save_write_chunk(& psf->wchunks, chunk_info);
  }
#line 1450
  return (__cil_tmp3);
}
}
#line 1454 "/root/patchweave_new/23/src/wav.c"
static SF_CHUNK_ITERATOR *wav_next_chunk_iterator(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator ) 
{ 
  SF_CHUNK_ITERATOR *__cil_tmp3 ;

  {
  {
#line 1455
  __cil_tmp3 = psf_next_chunk_iterator(& psf->rchunks, iterator);
  }
#line 1455
  return (__cil_tmp3);
}
}
#line 1459 "/root/patchweave_new/23/src/wav.c"
static int wav_get_chunk_size(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  int indx ;

  {
  {
#line 1462
  indx = psf_find_read_chunk_iterator(& psf->rchunks, iterator);
  }
#line 1462
  if (indx < 0) {
#line 1463
    return (168);
  }
#line 1465
  chunk_info->datalen = (psf->rchunks.chunks + indx)->len;
#line 1467
  return (0);
}
}
#line 1471 "/root/patchweave_new/23/src/wav.c"
static int wav_get_chunk_data(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  int indx ;
  sf_count_t pos ;

  {
  {
#line 1475
  indx = psf_find_read_chunk_iterator(& psf->rchunks, iterator);
  }
#line 1475
  if (indx < 0) {
#line 1476
    return (168);
  }
#line 1478
  if ((unsigned long )chunk_info->data == (unsigned long )((void *)0)) {
#line 1479
    return (171);
  }
  {
#line 1481
  chunk_info->id_size = (psf->rchunks.chunks + indx)->id_size;
#line 1482
  memcpy((void *)(chunk_info->id), (void const   *)((psf->rchunks.chunks + indx)->id),
         sizeof(chunk_info->id) / sizeof(chunk_info->id[0]));
#line 1484
  pos = psf_ftell(psf);
#line 1485
  psf_fseek(psf, (psf->rchunks.chunks + indx)->offset, 0);
#line 1486
  psf_fread(chunk_info->data, (sf_count_t )0, (sf_count_t )1, psf);
#line 1487
  psf_fseek(psf, pos, 0);
  }
#line 1489
  return (0);
}
}
#line 40 "/root/patchweave_new/23/src/wavlike.c"
static int exif_subchunk_parse(SF_PRIVATE *psf , uint32_t length ) ;
#line 44 "/root/patchweave_new/23/src/wavlike.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_PCM___1  =    {1U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 48 "/root/patchweave_new/23/src/wavlike.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_MS_ADPCM  =    {2U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 52 "/root/patchweave_new/23/src/wavlike.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_IEEE_FLOAT___1  =    {3U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 56 "/root/patchweave_new/23/src/wavlike.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_ALAW___1  =    {6U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 60 "/root/patchweave_new/23/src/wavlike.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_MULAW___1  =    {7U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 69 "/root/patchweave_new/23/src/wavlike.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM___1  =    {1U, (unsigned short)1825, (unsigned short)4563, {(char)-122, (char)68, (char)-56,
                                                     (char)-63, (char)-54, (char)0,
                                                     (char)0, (char)0}};
#line 73 "/root/patchweave_new/23/src/wavlike.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT___1  =    {3U, (unsigned short)1825, (unsigned short)4563, {(char)-122, (char)68, (char)-56,
                                                     (char)-63, (char)-54, (char)0,
                                                     (char)0, (char)0}};
#line 90 "/root/patchweave_new/23/src/wavlike.c"
static struct chanmap_s channel_mask_bits[18]  = 
#line 90
  {      {2, "L"}, 
        {3, "R"}, 
        {4, "C"}, 
        {11, "LFE"}, 
        {9, "Ls"}, 
        {10, "Rs"}, 
        {12, "Lc"}, 
        {13, "Rc"}, 
        {8, "Cs"}, 
        {14, "Sl"}, 
        {15, "Sr"}, 
        {16, "Tc"}, 
        {17, "Tfl"}, 
        {19, "Tfc"}, 
        {18, "Tfr"}, 
        {20, "Trl"}, 
        {22, "Trc"}, 
        {21, "Trr"}};
#line 117 "/root/patchweave_new/23/src/wavlike.c"
static int wavex_guid_equal(EXT_SUBFORMAT *first , EXT_SUBFORMAT *second ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 118
  __cil_tmp3 = memcmp((void const   *)first, (void const   *)second, sizeof(EXT_SUBFORMAT ));
  }
#line 118
  return (! __cil_tmp3);
}
}
#line 124 "/root/patchweave_new/23/src/wavlike.c"
int wavlike_read_fmt_chunk(SF_PRIVATE *psf , int fmtsize ) 
{ 
  WAVLIKE_PRIVATE *wpriv ;
  WAV_FMT *wav_fmt ;
  int bytesread ;
  int k ;
  int bytespersec ;
  char const   *__cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  char buffer[128] ;
  int __cil_tmp15 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  char buffer___0[512] ;
  unsigned int bit ;
  int __cil_tmp22 ;
  unsigned long __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int tmp___0 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int tmp___1 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  char const   *tmp___2 ;
  void *tmp___3 ;

  {
#line 127
  bytespersec = 0;
#line 129
  wpriv = (WAVLIKE_PRIVATE *)psf->container_data;
#line 129
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 130
    return (30);
  }
  {
#line 131
  wav_fmt = & wpriv->wav_fmt;
#line 133
  memset((void *)wav_fmt, 0, sizeof(WAV_FMT ));
  }
#line 135
  if (fmtsize < 16) {
#line 136
    return (66);
  }
  {
#line 141
  bytesread = psf_binheader_readf(psf, "224422", & wav_fmt->format, & wav_fmt->min.channels,
                                  & wav_fmt->min.samplerate, & wav_fmt->min.bytespersec,
                                  & wav_fmt->min.blockalign, & wav_fmt->min.bitwidth);
#line 146
  __cil_tmp9 = wavlike_format_str((int )wav_fmt->format);
#line 146
  psf_log_printf(psf, "  Format        : 0x%X => %s\n", (int )wav_fmt->format, __cil_tmp9);
#line 147
  psf_log_printf(psf, "  Channels      : %d\n", (int )wav_fmt->min.channels);
#line 148
  psf_log_printf(psf, "  Sample Rate   : %d\n", wav_fmt->min.samplerate);
  }
#line 150
  if ((int )wav_fmt->format == 1) {
#line 150
    if ((int )wav_fmt->min.blockalign == 0) {
#line 150
      if ((int )wav_fmt->min.bitwidth > 0) {
#line 150
        if ((int )wav_fmt->min.channels > 0) {
#line 152
          if ((int )wav_fmt->min.bitwidth % 8 > 0) {
#line 152
            tmp = 1;
          } else {
#line 152
            tmp = 0;
          }
          {
#line 152
          wav_fmt->min.blockalign = (unsigned short )((int )wav_fmt->min.bitwidth / 8 + tmp);
#line 153
          wav_fmt->min.blockalign = (unsigned short )((int )wav_fmt->min.blockalign * (int )wav_fmt->min.channels);
#line 154
          psf_log_printf(psf, "  Block Align   : 0 (should be %d)\n", (int )wav_fmt->min.blockalign);
          }
        } else {
          {
#line 157
          psf_log_printf(psf, "  Block Align   : %d\n", (int )wav_fmt->min.blockalign);
          }
        }
      } else {
        {
#line 157
        psf_log_printf(psf, "  Block Align   : %d\n", (int )wav_fmt->min.blockalign);
        }
      }
    } else {
      {
#line 157
      psf_log_printf(psf, "  Block Align   : %d\n", (int )wav_fmt->min.blockalign);
      }
    }
  } else {
    {
#line 157
    psf_log_printf(psf, "  Block Align   : %d\n", (int )wav_fmt->min.blockalign);
    }
  }
#line 159
  if ((int )wav_fmt->format == 1) {
#line 159
    if ((int )wav_fmt->min.bitwidth == 24) {
#line 159
      if ((int )wav_fmt->min.blockalign == 4 * (int )wav_fmt->min.channels) {
        {
#line 161
        psf_log_printf(psf, "  Bit Width     : 24\n");
#line 163
        psf_log_printf(psf, "\n  Ambiguous information in \'fmt \' chunk. Possibile file types:\n    0) Invalid IEEE float file generated by Syntrillium\'s Cooledit!\n    1) File generated by ALSA\'s arecord containing 24 bit samples in 32 bit containers.\n    2) 24 bit file with incorrect Block Align value.\n\n");
#line 170
        wpriv->fmt_is_broken = 1;
        }
      } else {
#line 159
        goto _L;
      }
    } else {
#line 159
      goto _L;
    }
  } else
  _L: 
#line 172
  if ((int )wav_fmt->min.bitwidth == 0) {
#line 175
    if ((int )wav_fmt->format == 29232) {
#line 175
      goto case_29232;
    }
#line 175
    if ((int )wav_fmt->format == 49) {
#line 175
      goto case_29232;
    }
#line 178
    goto switch_default;
    case_29232: 
    {
#line 176
    psf_log_printf(psf, "  Bit Width     : %d\n", (int )wav_fmt->min.bitwidth);
    }
#line 177
    goto switch_break;
    switch_default: 
    {
#line 179
    psf_log_printf(psf, "  Bit Width     : %d (should not be 0)\n", (int )wav_fmt->min.bitwidth);
    }
    switch_break: ;
  } else {
#line 185
    if ((int )wav_fmt->format == 29232) {
#line 185
      goto case_29232___0;
    }
#line 185
    if ((int )wav_fmt->format == 49) {
#line 185
      goto case_29232___0;
    }
#line 188
    goto switch_default___0;
    case_29232___0: 
    {
#line 186
    psf_log_printf(psf, "  Bit Width     : %d (should be 0)\nE\270U", (int )wav_fmt->min.bitwidth);
    }
#line 187
    goto switch_break___0;
    switch_default___0: 
    {
#line 189
    psf_log_printf(psf, "  Bit Width     : %d\n", (int )wav_fmt->min.bitwidth);
    }
    switch_break___0: ;
  }
#line 193
  psf->sf.samplerate = (int )wav_fmt->min.samplerate;
#line 194
  psf->sf.frames = (sf_count_t )0;
#line 195
  psf->sf.channels = (int )wav_fmt->min.channels;
#line 199
  if ((int )wav_fmt->format == 3) {
#line 199
    goto case_3;
  }
#line 199
  if ((int )wav_fmt->format == 1) {
#line 199
    goto case_3;
  }
#line 210
  if ((int )wav_fmt->format == 7) {
#line 210
    goto case_7;
  }
#line 210
  if ((int )wav_fmt->format == 6) {
#line 210
    goto case_7;
  }
#line 223
  if ((int )wav_fmt->format == 17) {
#line 223
    goto case_17;
  }
#line 246
  if ((int )wav_fmt->format == 2) {
#line 246
    goto case_2;
  }
#line 289
  if ((int )wav_fmt->format == 49) {
#line 289
    goto case_49___1;
  }
#line 309
  if ((int )wav_fmt->format == 65534) {
#line 309
    goto case_65534;
  }
#line 417
  if ((int )wav_fmt->format == 64) {
#line 417
    goto case_64;
  }
#line 435
  goto switch_default___1;
  case_3: 
#line 200
  bytespersec = (int )(wav_fmt->min.samplerate * (unsigned int )wav_fmt->min.blockalign);
#line 201
  if (wav_fmt->min.bytespersec != (unsigned int )bytespersec) {
    {
#line 202
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->min.bytespersec,
                   bytespersec);
    }
  } else {
    {
#line 204
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->min.bytespersec);
    }
  }
#line 206
  psf->bytewidth = ((int )wav_fmt->min.bitwidth + 7) / 8;
#line 207
  goto switch_break___1;
  case_7: 
#line 211
  if (wav_fmt->min.bytespersec != wav_fmt->min.samplerate * (unsigned int )wav_fmt->min.blockalign) {
    {
#line 212
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->min.bytespersec,
                   wav_fmt->min.samplerate * (unsigned int )wav_fmt->min.blockalign);
    }
  } else {
    {
#line 214
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->min.bytespersec);
    }
  }
#line 216
  psf->bytewidth = 1;
#line 217
  if (fmtsize >= 18) {
    {
#line 218
    __cil_tmp11 = psf_binheader_readf(psf, "2", & wav_fmt->size20.extrabytes);
#line 218
    bytesread += __cil_tmp11;
#line 219
    psf_log_printf(psf, "  Extra Bytes   : %d\n", (int )wav_fmt->size20.extrabytes);
    }
  }
#line 221
  goto switch_break___1;
  case_17: 
#line 224
  if ((int )wav_fmt->min.bitwidth != 4) {
#line 225
    return (74);
  }
#line 226
  if ((int )wav_fmt->min.channels < 1) {
#line 227
    return (75);
  } else
#line 226
  if ((int )wav_fmt->min.channels > 2) {
#line 227
    return (75);
  }
  {
#line 229
  __cil_tmp12 = psf_binheader_readf(psf, "22", & wav_fmt->ima.extrabytes, & wav_fmt->ima.samplesperblock);
#line 229
  bytesread += __cil_tmp12;
#line 230
  psf_log_printf(psf, "  Extra Bytes   : %d\n", (int )wav_fmt->ima.extrabytes);
  }
#line 231
  if ((int )wav_fmt->ima.samplesperblock < 1) {
    {
#line 232
    psf_log_printf(psf, "  Samples/Block : %d (should be > 0)\n", (int )wav_fmt->ima.samplesperblock);
    }
#line 233
    return (76);
  } else {
    {
#line 236
    psf_log_printf(psf, "  Samples/Block : %d\n", (int )wav_fmt->ima.samplesperblock);
    }
  }
#line 238
  bytespersec = (int )((wav_fmt->ima.samplerate * (unsigned int )wav_fmt->ima.blockalign) / (unsigned int )wav_fmt->ima.samplesperblock);
#line 239
  if (wav_fmt->ima.bytespersec != (unsigned int )bytespersec) {
    {
#line 240
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->ima.bytespersec,
                   bytespersec);
    }
  } else {
    {
#line 242
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->ima.bytespersec);
    }
  }
#line 244
  goto switch_break___1;
  case_2: 
#line 247
  if ((int )wav_fmt->msadpcm.bitwidth != 4) {
#line 248
    return (74);
  }
#line 249
  if ((int )wav_fmt->msadpcm.channels < 1) {
#line 250
    return (75);
  } else
#line 249
  if ((int )wav_fmt->msadpcm.channels > 2) {
#line 250
    return (75);
  }
  {
#line 252
  __cil_tmp13 = psf_binheader_readf(psf, "222", & wav_fmt->msadpcm.extrabytes, & wav_fmt->msadpcm.samplesperblock,
                                    & wav_fmt->msadpcm.numcoeffs);
#line 252
  bytesread += __cil_tmp13;
#line 255
  psf_log_printf(psf, "  Extra Bytes   : %d\n", (int )wav_fmt->msadpcm.extrabytes);
  }
#line 256
  if ((int )wav_fmt->ima.samplesperblock < 1) {
    {
#line 257
    psf_log_printf(psf, "  Samples/Block : %d (should be > 0)\n", (int )wav_fmt->ima.samplesperblock);
    }
#line 258
    return (76);
  } else {
    {
#line 261
    psf_log_printf(psf, "  Samples/Block : %d\n", (int )wav_fmt->ima.samplesperblock);
    }
  }
#line 263
  bytespersec = (int )((wav_fmt->min.samplerate * (unsigned int )wav_fmt->min.blockalign) / (unsigned int )wav_fmt->msadpcm.samplesperblock);
#line 264
  if (wav_fmt->min.bytespersec == (unsigned int )bytespersec) {
    {
#line 265
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->min.bytespersec);
    }
  } else
#line 266
  if (wav_fmt->min.bytespersec == (wav_fmt->min.samplerate / (unsigned int )wav_fmt->msadpcm.samplesperblock) * (unsigned int )wav_fmt->min.blockalign) {
    {
#line 267
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d (MS BUG!))\n", wav_fmt->min.bytespersec,
                   bytespersec);
    }
  } else {
    {
#line 269
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->min.bytespersec,
                   bytespersec);
    }
  }
#line 271
  if ((int )wav_fmt->msadpcm.numcoeffs > (int )(sizeof(wav_fmt->msadpcm.coeffs) / sizeof(wav_fmt->msadpcm.coeffs[0]))) {
    {
#line 272
    psf_log_printf(psf, "  No. of Coeffs : %d (should be <= %d)\n", (int )wav_fmt->msadpcm.numcoeffs,
                   (int )(sizeof(wav_fmt->msadpcm.coeffs) / sizeof(wav_fmt->msadpcm.coeffs[0])));
#line 273
    wav_fmt->msadpcm.numcoeffs = (unsigned short )((int )(sizeof(wav_fmt->msadpcm.coeffs) / sizeof(wav_fmt->msadpcm.coeffs[0])));
    }
  } else {
    {
#line 276
    psf_log_printf(psf, "  No. of Coeffs : %d\n", (int )wav_fmt->msadpcm.numcoeffs);
    }
  }
  {
#line 278
  psf_log_printf(psf, "    Index   Coeffs1   Coeffs2\n");
#line 279
  k = 0;
  }
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;

#line 279
    if (! (k < (int )wav_fmt->msadpcm.numcoeffs)) {
#line 279
      goto while_break;
    }
    {
#line 282
    __cil_tmp15 = psf_binheader_readf(psf, "22", & wav_fmt->msadpcm.coeffs[k].coeff1,
                                      & wav_fmt->msadpcm.coeffs[k].coeff2);
#line 282
    bytesread += __cil_tmp15;
#line 284
    snprintf(buffer, sizeof(buffer), "     %2d     %7d   %7d\n", k, (int )wav_fmt->msadpcm.coeffs[k].coeff1,
             (int )wav_fmt->msadpcm.coeffs[k].coeff2);
#line 285
    psf_log_printf(psf, (char const   *)(buffer));
#line 279
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 287
  goto switch_break___1;
  case_49___1: 
#line 290
  if ((int )wav_fmt->gsm610.channels != 1) {
#line 291
    return (77);
  } else
#line 290
  if ((int )wav_fmt->gsm610.blockalign != 65) {
#line 291
    return (77);
  }
  {
#line 293
  __cil_tmp17 = psf_binheader_readf(psf, "22", & wav_fmt->gsm610.extrabytes, & wav_fmt->gsm610.samplesperblock);
#line 293
  bytesread += __cil_tmp17;
  }
#line 296
  if ((int )wav_fmt->gsm610.samplesperblock != 320) {
#line 297
    return (77);
  }
#line 299
  bytespersec = (int )((wav_fmt->gsm610.samplerate * (unsigned int )wav_fmt->gsm610.blockalign) / (unsigned int )wav_fmt->gsm610.samplesperblock);
#line 300
  if (wav_fmt->gsm610.bytespersec != (unsigned int )bytespersec) {
    {
#line 301
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->gsm610.bytespersec,
                   bytespersec);
    }
  } else {
    {
#line 303
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->gsm610.bytespersec);
    }
  }
  {
#line 305
  psf_log_printf(psf, "  Extra Bytes   : %d\n", (int )wav_fmt->gsm610.extrabytes);
#line 306
  psf_log_printf(psf, "  Samples/Block : %d\n", (int )wav_fmt->gsm610.samplesperblock);
  }
#line 307
  goto switch_break___1;
  case_65534: 
#line 310
  if (wav_fmt->ext.bytespersec != wav_fmt->ext.samplerate * (unsigned int )wav_fmt->ext.blockalign) {
    {
#line 311
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->ext.bytespersec,
                   wav_fmt->ext.samplerate * (unsigned int )wav_fmt->ext.blockalign);
    }
  } else {
    {
#line 313
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->ext.bytespersec);
    }
  }
  {
#line 315
  __cil_tmp18 = psf_binheader_readf(psf, "224", & wav_fmt->ext.extrabytes, & wav_fmt->ext.validbits,
                                    & wav_fmt->ext.channelmask);
#line 315
  bytesread += __cil_tmp18;
#line 319
  psf_log_printf(psf, "  Valid Bits    : %d\n", (int )wav_fmt->ext.validbits);
  }
#line 321
  if (wav_fmt->ext.channelmask == 0U) {
    {
#line 322
    psf_log_printf(psf, "  Channel Mask  : 0x0 (should not be zero)\n");
    }
  } else {
    {
#line 327
    wpriv->wavex_channelmask = wav_fmt->ext.channelmask;
#line 330
    free((void *)psf->channel_map);
#line 332
    tmp___3 = calloc((unsigned long )psf->sf.channels, sizeof(*(psf->channel_map + 0)));
#line 332
    psf->channel_map = (int *)tmp___3;
    }
#line 332
    if ((unsigned long )psf->channel_map == (unsigned long )((void *)0)) {
#line 333
      return (17);
    }
#line 336
    buffer___0[0] = (char)0;
#line 338
    k = 0;
#line 338
    bit = (unsigned int )k;
    {
#line 338
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 338
      if (bit < (unsigned int )((int )(sizeof(channel_mask_bits) / sizeof(channel_mask_bits[0])))) {
#line 338
        if (! (k < psf->sf.channels)) {
#line 338
          goto while_break___0;
        }
      } else {
#line 338
        goto while_break___0;
      }
#line 340
      if (wav_fmt->ext.channelmask & (unsigned int )(1 << bit)) {
#line 341
        if (k > psf->sf.channels) {
          {
#line 342
          psf_log_printf(psf, "*** More channel map bits than there are channels.\n");
          }
#line 343
          goto while_break___0;
        }
        {
#line 346
        __cil_tmp22 = k;
#line 346
        k ++;
#line 346
        *(psf->channel_map + __cil_tmp22) = channel_mask_bits[bit].id;
#line 347
        append_snprintf(buffer___0, sizeof(buffer___0), "%s, ", channel_mask_bits[bit].name);
        }
      }
#line 338
      bit ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 352
    __cil_tmp24 = strlen((char const   *)(buffer___0));
#line 352
    bit = (unsigned int )__cil_tmp24;
    }
#line 353
    if (bit >= 2U) {
#line 354
      bit --;
#line 354
      buffer___0[bit] = (char)0;
#line 355
      bit --;
#line 355
      buffer___0[bit] = (char)0;
    }
#line 358
    if (k != psf->sf.channels) {
      {
#line 359
      psf_log_printf(psf, "  Channel Mask  : 0x%X\n", wav_fmt->ext.channelmask);
#line 360
      psf_log_printf(psf, "*** Less channel map bits than there are channels.\n");
      }
    } else {
      {
#line 363
      psf_log_printf(psf, "  Channel Mask  : 0x%X (%s)\n", wav_fmt->ext.channelmask,
                     buffer___0);
      }
    }
  }
  {
#line 366
  __cil_tmp25 = psf_binheader_readf(psf, "422", & wav_fmt->ext.esf.esf_field1, & wav_fmt->ext.esf.esf_field2,
                                    & wav_fmt->ext.esf.esf_field3);
#line 366
  bytesread += __cil_tmp25;
#line 369
  psf_log_printf(psf, "  Subformat\n");
#line 370
  psf_log_printf(psf, "    esf_field1 : 0x%X\n", wav_fmt->ext.esf.esf_field1);
#line 371
  psf_log_printf(psf, "    esf_field2 : 0x%X\n", (int )wav_fmt->ext.esf.esf_field2);
#line 372
  psf_log_printf(psf, "    esf_field3 : 0x%X\n", (int )wav_fmt->ext.esf.esf_field3);
#line 373
  psf_log_printf(psf, "    esf_field4 : ");
#line 374
  k = 0;
  }
  {
#line 374
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 374
    if (! (k < 8)) {
#line 374
      goto while_break___1;
    }
    {
#line 375
    __cil_tmp26 = psf_binheader_readf(psf, "1", & wav_fmt->ext.esf.esf_field4[k]);
#line 375
    bytesread += __cil_tmp26;
#line 376
    psf_log_printf(psf, "0x%X ", (int )wav_fmt->ext.esf.esf_field4[k] & 255);
#line 374
    k ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 378
  psf_log_printf(psf, "\n");
#line 379
  psf->bytewidth = ((int )wav_fmt->ext.bitwidth + 7) / 8;
#line 382
  __cil_tmp28 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_PCM___1);
  }
#line 382
  if (__cil_tmp28) {
    {
#line 383
    __cil_tmp29 = u_bitwidth_to_subformat(psf->bytewidth * 8);
#line 383
    psf->sf.format = 1245184 | __cil_tmp29;
#line 384
    psf_log_printf(psf, "    format : pcm\n");
    }
  } else {
    {
#line 386
    __cil_tmp30 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_MS_ADPCM);
    }
#line 386
    if (__cil_tmp30) {
      {
#line 387
      psf->sf.format = 1245203;
#line 388
      psf_log_printf(psf, "    format : ms adpcm\n");
      }
    } else {
      {
#line 390
      __cil_tmp31 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_IEEE_FLOAT___1);
      }
#line 390
      if (__cil_tmp31) {
#line 391
        if (psf->bytewidth == 8) {
#line 391
          tmp___0 = 7;
        } else {
#line 391
          tmp___0 = 6;
        }
        {
#line 391
        psf->sf.format = 1245184 | tmp___0;
#line 392
        psf_log_printf(psf, "    format : IEEE float\n\220");
        }
      } else {
        {
#line 394
        __cil_tmp33 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_ALAW___1);
        }
#line 394
        if (__cil_tmp33) {
          {
#line 395
          psf->sf.format = 1245201;
#line 396
          psf_log_printf(psf, "    format : A-law\n");
          }
        } else {
          {
#line 398
          __cil_tmp34 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_MULAW___1);
          }
#line 398
          if (__cil_tmp34) {
            {
#line 399
            psf->sf.format = 1245200;
#line 400
            psf_log_printf(psf, "    format : u-law\n");
            }
          } else {
            {
#line 402
            __cil_tmp35 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM___1);
            }
#line 402
            if (__cil_tmp35) {
              {
#line 403
              __cil_tmp36 = u_bitwidth_to_subformat(psf->bytewidth * 8);
#line 403
              psf->sf.format = 1245184 | __cil_tmp36;
#line 404
              psf_log_printf(psf, "    format : pcm (Ambisonic B)\n");
#line 405
              wpriv->wavex_ambisonic = 65;
              }
            } else {
              {
#line 407
              __cil_tmp37 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT___1);
              }
#line 407
              if (__cil_tmp37) {
#line 408
                if (psf->bytewidth == 8) {
#line 408
                  tmp___1 = 7;
                } else {
#line 408
                  tmp___1 = 6;
                }
                {
#line 408
                psf->sf.format = 1245184 | tmp___1;
#line 409
                psf_log_printf(psf, "    format : IEEE float (Ambisonic B)\n");
#line 410
                wpriv->wavex_ambisonic = 65;
                }
              } else {
#line 413
                return (18);
              }
            }
          }
        }
      }
    }
  }
#line 415
  goto switch_break___1;
  case_64: 
  {
#line 418
  psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->g72x.bytespersec);
  }
#line 419
  if (fmtsize >= 20) {
    {
#line 420
    __cil_tmp39 = psf_binheader_readf(psf, "22", & wav_fmt->g72x.extrabytes, & wav_fmt->g72x.auxblocksize);
#line 420
    bytesread += __cil_tmp39;
    }
#line 421
    if ((int )wav_fmt->g72x.extrabytes == 0) {
      {
#line 422
      psf_log_printf(psf, "  Extra Bytes   : %d (should be 2)\n", (int )wav_fmt->g72x.extrabytes);
      }
    } else {
      {
#line 424
      psf_log_printf(psf, "  Extra Bytes   : %d\n", (int )wav_fmt->g72x.extrabytes);
      }
    }
    {
#line 425
    psf_log_printf(psf, "  Aux Blk Size  : %d\n", (int )wav_fmt->g72x.auxblocksize);
    }
  } else
#line 427
  if (fmtsize == 18) {
    {
#line 428
    __cil_tmp40 = psf_binheader_readf(psf, "2", & wav_fmt->g72x.extrabytes);
#line 428
    bytesread += __cil_tmp40;
    }
#line 429
    if ((int )wav_fmt->g72x.extrabytes != 0) {
#line 429
      tmp___2 = " (should be 0)";
    } else {
#line 429
      tmp___2 = "\220";
    }
    {
#line 429
    psf_log_printf(psf, "  Extra Bytes   : %d%s\n", (int )wav_fmt->g72x.extrabytes,
                   tmp___2);
    }
  } else {
    {
#line 432
    psf_log_printf(psf, "*** \'fmt \' chunk should be bigger than this!\n");
    }
  }
#line 433
  goto switch_break___1;
  switch_default___1: 
  {
#line 436
  psf_log_printf(psf, "*** No \'fmt \' chunk dumper for this format!\n");
  }
#line 437
  return (65);
  switch_break___1: ;
#line 440
  if (bytesread > fmtsize) {
    {
#line 441
    psf_log_printf(psf, "*** wavlike_read_fmt_chunk (bytesread > fmtsize)\n");
    }
#line 442
    return (65);
  } else {
    {
#line 445
    psf_binheader_readf(psf, "j", fmtsize - bytesread);
    }
  }
#line 447
  psf->blockwidth = (int )wav_fmt->min.channels * psf->bytewidth;
#line 449
  return (0);
}
}
#line 453 "/root/patchweave_new/23/src/wavlike.c"
void wavlike_write_guid(SF_PRIVATE *psf , EXT_SUBFORMAT *subformat ) 
{ 
  size_t __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = make_size_t(8);
#line 455
  psf_binheader_writef(psf, "422b\270U", subformat->esf_field1, (int )subformat->esf_field2,
                       (int )subformat->esf_field3, (char const   *)(subformat->esf_field4),
                       __cil_tmp3);
  }
#line 459
  return;
}
}
#line 462 "/root/patchweave_new/23/src/wavlike.c"
int wavlike_gen_channel_mask(int const   *chan_map , int channels ) 
{ 
  int chan ;
  int mask ;
  int bit ;
  int last_bit ;
  int k ;

  {
#line 463
  mask = 0;
#line 463
  bit = -1;
#line 463
  last_bit = -1;
#line 465
  if ((unsigned long )chan_map == (unsigned long )((void *)0)) {
#line 466
    return (0);
  }
#line 468
  chan = 0;
  {
#line 468
  while (1) {
    while_continue: /* CIL Label */ ;

#line 468
    if (! (chan < channels)) {
#line 468
      goto while_break;
    }
#line 471
    k = bit + 1;
    {
#line 471
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 471
      if (! (k < (int )(sizeof(channel_mask_bits) / sizeof(channel_mask_bits[0])))) {
#line 471
        goto while_break___0;
      }
#line 472
      if (*(chan_map + chan) == (int const   )channel_mask_bits[k].id) {
#line 473
        bit = k;
#line 474
        goto while_break___0;
      }
#line 471
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 478
    if (bit <= last_bit) {
#line 479
      return (0);
    }
#line 481
    mask += 1 << bit;
#line 482
    last_bit = bit;
#line 468
    chan ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 485
  return (mask);
}
}
#line 489 "/root/patchweave_new/23/src/wavlike.c"
void wavlike_analyze(SF_PRIVATE *psf ) 
{ 
  unsigned char buffer[4096] ;
  AUDIO_DETECT ad ;
  int format ;
  sf_count_t __cil_tmp5 ;

  {
#line 492
  format = 0;
#line 494
  if (psf->is_pipe) {
    {
#line 495
    psf_log_printf(psf, "*** Error : Reading from a pipe. Can\'t analyze data section to figure out real data format.\n\nU");
    }
#line 496
    return;
  }
  {
#line 499
  psf_log_printf(psf, "---------------------------------------------------\nFormat is known to be broken. Using detection code.\n");
#line 503
  ad.endianness = 268435456;
#line 504
  ad.channels = psf->sf.channels;
#line 506
  psf_fseek(psf, (sf_count_t )600, 0);
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 508
    __cil_tmp5 = psf_fread((void *)(buffer), (sf_count_t )1, (sf_count_t )sizeof(buffer),
                           psf);
    }
#line 508
    if (! ((unsigned long )__cil_tmp5 == sizeof(buffer))) {
#line 508
      goto while_break;
    }
    {
#line 509
    format = audio_detect(psf, & ad, (unsigned char const   *)(buffer), (int )sizeof(buffer));
    }
#line 510
    if (format != 0) {
#line 511
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 515
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 517
  if (format == 0) {
    {
#line 518
    psf_log_printf(psf, "wavlike_analyze : detection failed.\n\270U");
    }
#line 519
    return;
  }
#line 524
  if (format == 6) {
#line 524
    goto case_6;
  }
#line 524
  if (format == 4) {
#line 524
    goto case_6;
  }
#line 531
  if (format == 3) {
#line 531
    goto case_3;
  }
#line 538
  goto switch_default;
  case_6: 
  {
#line 525
  psf_log_printf(psf, "wavlike_analyze : found format : 0x%X\n", format);
#line 526
  psf->sf.format = (psf->sf.format & -65536) + format;
#line 527
  psf->bytewidth = 4;
#line 528
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
  }
#line 529
  goto switch_break;
  case_3: 
  {
#line 532
  psf_log_printf(psf, "wavlike_analyze : found format : 0x%X\n", format);
#line 533
  psf->sf.format = (psf->sf.format & -65536) + format;
#line 534
  psf->bytewidth = 3;
#line 535
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
  }
#line 536
  goto switch_break;
  switch_default: 
  {
#line 539
  psf_log_printf(psf, "wavlike_analyze : unhandled format : 0x%X\n\276E\270U", format);
  }
#line 540
  goto switch_break;
  switch_break: ;
#line 543
  return;
}
}
#line 557 "/root/patchweave_new/23/src/wavlike.c"
static WAV_FORMAT_DESC wave_descs[106]  = 
#line 557
  {      {1, "WAVE_FORMAT_PCM"}, 
        {2, "WAVE_FORMAT_MS_ADPCM\270U"}, 
        {3, "WAVE_FORMAT_IEEE_FLOAT"}, 
        {4, "WAVE_FORMAT_VSELP\357\275E\270U"}, 
        {5, "WAVE_FORMAT_IBM_CVSD"}, 
        {6, "WAVE_FORMAT_ALAW\250"}, 
        {7, "WAVE_FORMAT_MULAW\356\275E\270U"}, 
        {16, "WAVE_FORMAT_OKI_ADPCMU"}, 
        {17, "WAVE_FORMAT_IMA_ADPCM"}, 
        {18, "WAVE_FORMAT_MEDIASPACE_ADPCM"}, 
        {19, "WAVE_FORMAT_SIERRA_ADPCM\250"}, 
        {20, "WAVE_FORMAT_G723_ADPCM"}, 
        {21, "WAVE_FORMAT_DIGISTD"}, 
        {22, "WAVE_FORMAT_DIGIFIX"}, 
        {23, "WAVE_FORMAT_DIALOGIC_OKI_ADPCM"}, 
        {24, "WAVE_FORMAT_MEDIAVISION_ADPCM"}, 
        {25, "WAVE_FORMAT_CU_CODEC"}, 
        {32, "WAVE_FORMAT_YAMAHA_ADPCM\250"}, 
        {33, "WAVE_FORMAT_SONARC\275E\270U"}, 
        {34, "WAVE_FORMAT_DSPGROUP_TRUESPEECH"}, 
        {35, "WAVE_FORMAT_ECHOSC1"}, 
        {36, "WAVE_FORMAT_AUDIOFILE_AF36"}, 
        {37, "WAVE_FORMAT_APTX\250"}, 
        {38, "WAVE_FORMAT_AUDIOFILE_AF10"}, 
        {39, "WAVE_FORMAT_PROSODY_1612\250"}, 
        {40, "WAVE_FORMAT_LRC"}, 
        {48, "WAVE_FORMAT_DOLBY_AC2"}, 
        {49, "WAVE_FORMAT_GSM610"}, 
        {50, "WAVE_FORMAT_MSNAUDIO"}, 
        {51, "WAVE_FORMAT_ANTEX_ADPCME\250"}, 
        {52, "WAVE_FORMAT_CONTROL_RES_VQLPC"}, 
        {53, "WAVE_FORMAT_DIGIREAL"}, 
        {54, "WAVE_FORMAT_DIGIADPCM"}, 
        {55, "WAVE_FORMAT_CONTROL_RES_CR10\270U"}, 
        {56, "WAVE_FORMAT_NMS_VBXADPCM\250"}, 
        {57, "WAVE_FORMAT_ROLAND_RDAC"}, 
        {58, "WAVE_FORMAT_ECHOSC3"}, 
        {59, "WAVE_FORMAT_ROCKWELL_ADPCM"}, 
        {60, "WAVE_FORMAT_ROCKWELL_DIGITALK"}, 
        {61, "WAVE_FORMAT_XEBEC"}, 
        {64, "WAVE_FORMAT_G721_ADPCM"}, 
        {65, "WAVE_FORMAT_G728_CELP"}, 
        {66, "WAVE_FORMAT_MSG723"}, 
        {80, "WAVE_FORMAT_MPEG\250"}, 
        {82, "WAVE_FORMAT_RT24\250"}, 
        {83, "WAVE_FORMAT_PAC"}, 
        {85, "WAVE_FORMAT_MPEGLAYER3"}, 
        {89, "WAVE_FORMAT_LUCENT_G723"}, 
        {96, "WAVE_FORMAT_CIRRUS"}, 
        {97, "WAVE_FORMAT_ESPCM"}, 
        {98, "WAVE_FORMAT_VOXWARE"}, 
        {99, "WAVE_FORMAT_CANOPUS_ATRAC"}, 
        {100, "WAVE_FORMAT_G726_ADPCM"}, 
        {101, "WAVE_FORMAT_G722_ADPCM"}, 
        {102, "WAVE_FORMAT_DSAT\250"}, 
        {103, "WAVE_FORMAT_DSAT_DISPLAY\250"}, 
        {105, "WAVE_FORMAT_VOXWARE_BYTE_ALIGNED\250"}, 
        {112, "WAVE_FORMAT_VOXWARE_AC8"}, 
        {113, "WAVE_FORMAT_VOXWARE_AC10\250"}, 
        {114, "WAVE_FORMAT_VOXWARE_AC16\250"}, 
        {115, "WAVE_FORMAT_VOXWARE_AC20\250"}, 
        {116, "WAVE_FORMAT_VOXWARE_RT24\250"}, 
        {117, "WAVE_FORMAT_VOXWARE_RT29\250"}, 
        {118, "WAVE_FORMAT_VOXWARE_RT29HW\276E\270U"}, 
        {119, "WAVE_FORMAT_VOXWARE_VR12\250"}, 
        {120, "WAVE_FORMAT_VOXWARE_VR18\250"}, 
        {121, "WAVE_FORMAT_VOXWARE_TQ40\250"}, 
        {128, "WAVE_FORMAT_SOFTSOUNDU"}, 
        {129, "WAVE_FORMAT_VOXARE_TQ60"}, 
        {130, "WAVE_FORMAT_MSRT24"}, 
        {131, "WAVE_FORMAT_G729A\272\276E\270U"}, 
        {132, "WAVE_FORMAT_MVI_MV12"}, 
        {133, "WAVE_FORMAT_DF_G726"}, 
        {134, "WAVE_FORMAT_DF_GSM610U"}, 
        {137, "WAVE_FORMAT_ONLIVE"}, 
        {145, "WAVE_FORMAT_SBC24"}, 
        {146, "WAVE_FORMAT_DOLBY_AC3_SPDIFE\270U"}, 
        {151, "WAVE_FORMAT_ZYXEL_ADPCM"}, 
        {152, "WAVE_FORMAT_PHILIPS_LPCBB\311\275E\270U"}, 
        {153, "WAVE_FORMAT_PACKED\275E\270U"}, 
        {256, "WAVE_FORMAT_RHETOREX_ADPCM\276E\270U"}, 
        {257, "IBM_FORMAT_MULAW\250"}, 
        {258, "IBM_FORMAT_ALAW"}, 
        {259, "IBM_FORMAT_ADPCM\250"}, 
        {273, "WAVE_FORMAT_VIVO_G723U"}, 
        {274, "WAVE_FORMAT_VIVO_SIREN"}, 
        {291, "WAVE_FORMAT_DIGITAL_G723\250"}, 
        {512, "WAVE_FORMAT_CREATIVE_ADPCM"}, 
        {514, "WAVE_FORMAT_CREATIVE_FASTSPEECH8\250"}, 
        {515, "WAVE_FORMAT_CREATIVE_FASTSPEECH10"}, 
        {544, "WAVE_FORMAT_QUARTERDECK"}, 
        {768, "WAVE_FORMAT_FM_TOWNS_SND\250"}, 
        {1024, "WAVE_FORMAT_BZV_DIGITAL"}, 
        {1664, "WAVE_FORMAT_VME_VMPCM"}, 
        {4096, "WAVE_FORMAT_OLIGSM"}, 
        {4097, "WAVE_FORMAT_OLIADPCM"}, 
        {4098, "WAVE_FORMAT_OLICELPE\270U"}, 
        {4099, "WAVE_FORMAT_OLISBC\275E\270U"}, 
        {4100, "WAVE_FORMAT_OLIOPR\'E\270U"}, 
        {4352, "WAVE_FORMAT_LH_CODEC"}, 
        {5120, "WAVE_FORMAT_NORRIS"}, 
        {5376, "WAVE_FORMAT_SOUNDSPACE_MUSICOMPRESS"}, 
        {8192, "WAVE_FORMAT_DVM"}, 
        {29008, "WAVE_FORMAT_INTERWAV_VSC112E\270U"}, 
        {29232, "WAVE_FORMAT_IPP_ITU_G_723_1"}, 
        {65534, "WAVE_FORMAT_EXTENSIBLE"}};
#line 667 "/root/patchweave_new/23/src/wavlike.c"
char const   *wavlike_format_str(int k ) 
{ 
  int lower ;
  int upper ;
  int mid ;

  {
#line 670
  lower = -1;
#line 671
  upper = (int )(sizeof(wave_descs) / sizeof(WAV_FORMAT_DESC ));
#line 674
  if (wave_descs[0].ID <= k) {
#line 674
    if (k <= wave_descs[upper - 1].ID) {
      {
#line 676
      while (1) {
        while_continue: /* CIL Label */ ;

#line 676
        if (! (lower + 1 < upper)) {
#line 676
          goto while_break;
        }
#line 677
        mid = (upper + lower) / 2;
#line 679
        if (k == wave_descs[mid].ID) {
#line 680
          return (wave_descs[mid].name);
        }
#line 681
        if (k < wave_descs[mid].ID) {
#line 682
          upper = mid;
        } else {
#line 684
          lower = mid;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: ;
    }
  }
#line 688
  return ("Unknown format");
}
}
#line 692 "/root/patchweave_new/23/src/wavlike.c"
int wavlike_srate2blocksize(int srate_chan_product ) 
{ 


  {
#line 693
  if (srate_chan_product < 12000) {
#line 694
    return (256);
  }
#line 695
  if (srate_chan_product < 23000) {
#line 696
    return (512);
  }
#line 697
  if (srate_chan_product < 44000) {
#line 698
    return (1024);
  }
#line 699
  return (2048);
}
}
#line 703 "/root/patchweave_new/23/src/wavlike.c"
int wavlike_read_bext_chunk(SF_PRIVATE *psf , uint32_t chunksize ) 
{ 
  SF_BROADCAST_INFO_16K *b ;
  uint32_t bytes ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 706
  bytes = (uint32_t )0;
#line 708
  if (chunksize < 602U) {
    {
#line 709
    psf_log_printf(psf, "bext : %u (should be >= %d)\n", chunksize, 602);
#line 710
    psf_binheader_readf(psf, "j:\277E\270U", chunksize);
    }
#line 711
    return (0);
  }
#line 714
  if (chunksize > 10240U) {
    {
#line 715
    psf_log_printf(psf, "bext : %u (should be < %d)\n", chunksize, 10240);
#line 716
    psf_binheader_readf(psf, "j", chunksize);
    }
#line 717
    return (0);
  }
#line 720
  if ((unsigned long )chunksize >= sizeof(SF_BROADCAST_INFO_16K )) {
    {
#line 721
    psf_log_printf(psf, "bext : %u too big to be handled\n\230\001", chunksize);
#line 722
    psf_binheader_readf(psf, "j", chunksize);
    }
#line 723
    return (0);
  }
  {
#line 726
  psf_log_printf(psf, "bext : %u\n", chunksize);
#line 728
  psf->broadcast_16k = broadcast_var_alloc();
  }
#line 728
  if ((unsigned long )psf->broadcast_16k == (unsigned long )((void *)0)) {
#line 729
    psf->error = 17;
#line 730
    return (psf->error);
  }
  {
#line 733
  b = psf->broadcast_16k;
#line 735
  __cil_tmp6 = psf_binheader_readf(psf, "bJ\277E\270U", b->description, sizeof(b->description));
#line 735
  bytes += (unsigned int )__cil_tmp6;
#line 736
  __cil_tmp7 = psf_binheader_readf(psf, "b", b->originator, sizeof(b->originator));
#line 736
  bytes += (unsigned int )__cil_tmp7;
#line 737
  __cil_tmp8 = psf_binheader_readf(psf, "b", b->originator_reference, sizeof(b->originator_reference));
#line 737
  bytes += (unsigned int )__cil_tmp8;
#line 738
  __cil_tmp9 = psf_binheader_readf(psf, "b", b->origination_date, sizeof(b->origination_date));
#line 738
  bytes += (unsigned int )__cil_tmp9;
#line 739
  __cil_tmp10 = psf_binheader_readf(psf, "b", b->origination_time, sizeof(b->origination_time));
#line 739
  bytes += (unsigned int )__cil_tmp10;
#line 740
  __cil_tmp11 = psf_binheader_readf(psf, "442", & b->time_reference_low, & b->time_reference_high,
                                    & b->version);
#line 740
  bytes += (unsigned int )__cil_tmp11;
#line 741
  __cil_tmp12 = psf_binheader_readf(psf, "bj\277E\270U", & b->umid, sizeof(b->umid),
                                    190);
#line 741
  bytes += (unsigned int )__cil_tmp12;
  }
#line 743
  if (chunksize > 602U) {
    {
#line 746
    b->coding_history_size = chunksize - 602U;
#line 749
    __cil_tmp13 = psf_binheader_readf(psf, "bC\275E\270U", b->coding_history, b->coding_history_size);
#line 749
    bytes += (unsigned int )__cil_tmp13;
    }
  }
#line 752
  if (bytes < chunksize) {
    {
#line 753
    psf_binheader_readf(psf, "jb\277E\270U", chunksize - bytes);
    }
  }
#line 755
  return (0);
}
}
#line 759 "/root/patchweave_new/23/src/wavlike.c"
int wavlike_write_bext_chunk(SF_PRIVATE *psf ) 
{ 
  SF_BROADCAST_INFO_16K *b ;
  size_t __cil_tmp3 ;
  size_t __cil_tmp4 ;

  {
#line 762
  if ((unsigned long )psf->broadcast_16k == (unsigned long )((void *)0)) {
#line 763
    return (-1);
  }
  {
#line 765
  b = psf->broadcast_16k;
#line 767
  psf_binheader_writef(psf, "m4", (unsigned int )((98 | (101 << 8)) | (120 << 16)) | (116U << 24),
                       602U + b->coding_history_size);
#line 774
  psf_binheader_writef(psf, "bp\277E\270U", b->description, sizeof(b->description));
#line 775
  psf_binheader_writef(psf, "b", b->originator, sizeof(b->originator));
#line 776
  psf_binheader_writef(psf, "bS\277E\270U", b->originator_reference, sizeof(b->originator_reference));
#line 777
  psf_binheader_writef(psf, "b", b->origination_date, sizeof(b->origination_date));
#line 778
  psf_binheader_writef(psf, "bS\277E\270U", b->origination_time, sizeof(b->origination_time));
#line 779
  psf_binheader_writef(psf, "442", b->time_reference_low, b->time_reference_high,
                       (int )b->version);
#line 780
  psf_binheader_writef(psf, "b{\277E\270U", b->umid, sizeof(b->umid));
#line 781
  __cil_tmp3 = make_size_t(190);
#line 781
  psf_binheader_writef(psf, "z", __cil_tmp3);
  }
#line 783
  if (b->coding_history_size > 0U) {
    {
#line 784
    __cil_tmp4 = make_size_t((int )b->coding_history_size);
#line 784
    psf_binheader_writef(psf, "bE\277E\270U", b->coding_history, __cil_tmp4);
    }
  }
#line 786
  return (0);
}
}
#line 790 "/root/patchweave_new/23/src/wavlike.c"
int wavlike_read_cart_chunk(SF_PRIVATE *psf , uint32_t chunksize ) 
{ 
  SF_CART_INFO_16K *c ;
  uint32_t bytes ;
  int k ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  size_t __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  size_t __cil_tmp28 ;
  int __cil_tmp29 ;

  {
#line 792
  bytes = (uint32_t )0;
#line 795
  if (chunksize < 2048U) {
    {
#line 796
    psf_log_printf(psf, "cart : %u (should be >= %d)\n\270U", chunksize, 2048);
#line 797
    psf_binheader_readf(psf, "j{\277E\270U", chunksize);
    }
#line 798
    return (0);
  }
#line 800
  if (chunksize > 4294967295U) {
    {
#line 801
    psf_log_printf(psf, "cart : %u (should be < %d)\n", chunksize, 4294967295U);
#line 802
    psf_binheader_readf(psf, "j\204\277E\270U", chunksize);
    }
#line 803
    return (0);
  }
#line 806
  if ((unsigned long )chunksize >= sizeof(SF_CART_INFO_16K )) {
    {
#line 807
    psf_log_printf(psf, "cart : %u too big to be handled\n\230\001", chunksize);
#line 808
    psf_binheader_readf(psf, "j", chunksize);
    }
#line 809
    return (0);
  }
  {
#line 812
  psf_log_printf(psf, "cart : %u\n\277E\270U", chunksize);
#line 814
  psf->cart_16k = cart_var_alloc();
  }
#line 814
  if ((unsigned long )psf->cart_16k == (unsigned long )((void *)0)) {
#line 815
    psf->error = 17;
#line 816
    return (psf->error);
  }
  {
#line 819
  c = psf->cart_16k;
#line 820
  __cil_tmp7 = psf_binheader_readf(psf, "b", c->version, sizeof(c->version));
#line 820
  bytes += (unsigned int )__cil_tmp7;
#line 821
  __cil_tmp8 = psf_binheader_readf(psf, "bH\'E\270U", c->title, sizeof(c->title));
#line 821
  bytes += (unsigned int )__cil_tmp8;
#line 822
  __cil_tmp9 = psf_binheader_readf(psf, "b", c->artist, sizeof(c->artist));
#line 822
  bytes += (unsigned int )__cil_tmp9;
#line 823
  __cil_tmp10 = psf_binheader_readf(psf, "b", c->cut_id, sizeof(c->cut_id));
#line 823
  bytes += (unsigned int )__cil_tmp10;
#line 824
  __cil_tmp11 = psf_binheader_readf(psf, "b", c->client_id, sizeof(c->client_id));
#line 824
  bytes += (unsigned int )__cil_tmp11;
#line 825
  __cil_tmp12 = psf_binheader_readf(psf, "b\246\277E\270U", c->category, sizeof(c->category));
#line 825
  bytes += (unsigned int )__cil_tmp12;
#line 826
  __cil_tmp13 = psf_binheader_readf(psf, "b\247\277E\270U", c->classification, sizeof(c->classification));
#line 826
  bytes += (unsigned int )__cil_tmp13;
#line 827
  __cil_tmp14 = psf_binheader_readf(psf, "b", c->out_cue, sizeof(c->out_cue));
#line 827
  bytes += (unsigned int )__cil_tmp14;
#line 828
  __cil_tmp15 = psf_binheader_readf(psf, "b", c->start_date, sizeof(c->start_date));
#line 828
  bytes += (unsigned int )__cil_tmp15;
#line 829
  __cil_tmp16 = psf_binheader_readf(psf, "b\b\275E\270U", c->start_time, sizeof(c->start_time));
#line 829
  bytes += (unsigned int )__cil_tmp16;
#line 830
  __cil_tmp17 = psf_binheader_readf(psf, "b", c->end_date, sizeof(c->end_date));
#line 830
  bytes += (unsigned int )__cil_tmp17;
#line 831
  __cil_tmp18 = psf_binheader_readf(psf, "b\004\275E\270U", c->end_time, sizeof(c->end_time));
#line 831
  bytes += (unsigned int )__cil_tmp18;
#line 832
  __cil_tmp19 = psf_binheader_readf(psf, "b\364\274E\270U", c->producer_app_id, sizeof(c->producer_app_id));
#line 832
  bytes += (unsigned int )__cil_tmp19;
#line 833
  __cil_tmp20 = psf_binheader_readf(psf, "b", c->producer_app_version, sizeof(c->producer_app_version));
#line 833
  bytes += (unsigned int )__cil_tmp20;
#line 834
  __cil_tmp21 = psf_binheader_readf(psf, "b\362\274E\270U", c->user_def, sizeof(c->user_def));
#line 834
  bytes += (unsigned int )__cil_tmp21;
#line 835
  __cil_tmp22 = psf_binheader_readf(psf, "e4\277E\270U", & c->level_reference, sizeof(c->level_reference));
#line 835
  bytes += (unsigned int )__cil_tmp22;
#line 837
  k = 0;
  }
  {
#line 837
  while (1) {
    while_continue: /* CIL Label */ ;

#line 837
    if (! (k < (int )(sizeof(c->post_timers) / sizeof(c->post_timers[0])))) {
#line 837
      goto while_break;
    }
    {
#line 838
    __cil_tmp23 = make_size_t(4);
#line 838
    __cil_tmp24 = psf_binheader_readf(psf, "b4", & c->post_timers[k].usage, __cil_tmp23,
                                      & c->post_timers[k].value);
#line 838
    bytes += (unsigned int )__cil_tmp24;
#line 837
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 840
  __cil_tmp26 = psf_binheader_readf(psf, "b", c->reserved, sizeof(c->reserved));
#line 840
  bytes += (unsigned int )__cil_tmp26;
#line 841
  __cil_tmp27 = psf_binheader_readf(psf, "b", c->url, sizeof(c->url));
#line 841
  bytes += (unsigned int )__cil_tmp27;
  }
#line 843
  if (chunksize > 2048U) {
    {
#line 845
    c->tag_text_size = chunksize - 2048U;
#line 846
    __cil_tmp28 = make_size_t((int )c->tag_text_size);
#line 846
    __cil_tmp29 = psf_binheader_readf(psf, "b", c->tag_text, __cil_tmp28);
#line 846
    bytes += (unsigned int )__cil_tmp29;
    }
  }
#line 849
  return (0);
}
}
#line 853 "/root/patchweave_new/23/src/wavlike.c"
int wavlike_write_cart_chunk(SF_PRIVATE *psf ) 
{ 
  SF_CART_INFO_16K *c ;
  int k ;
  size_t __cil_tmp4 ;
  size_t __cil_tmp6 ;

  {
#line 857
  if ((unsigned long )psf->cart_16k == (unsigned long )((void *)0)) {
#line 858
    return (-1);
  }
  {
#line 860
  c = psf->cart_16k;
#line 861
  psf_binheader_writef(psf, "m4", (unsigned int )((99 | (97 << 8)) | (114 << 16)) | (116U << 24),
                       2048U + c->tag_text_size);
#line 866
  psf_binheader_writef(psf, "b", c->version, sizeof(c->version));
#line 867
  psf_binheader_writef(psf, "b\377\377\377", c->title, sizeof(c->title));
#line 868
  psf_binheader_writef(psf, "b", c->artist, sizeof(c->artist));
#line 869
  psf_binheader_writef(psf, "b", c->cut_id, sizeof(c->cut_id));
#line 870
  psf_binheader_writef(psf, "b", c->client_id, sizeof(c->client_id));
#line 871
  psf_binheader_writef(psf, "b", c->category, sizeof(c->category));
#line 872
  psf_binheader_writef(psf, "b", c->classification, sizeof(c->classification));
#line 873
  psf_binheader_writef(psf, "b", c->out_cue, sizeof(c->out_cue));
#line 874
  psf_binheader_writef(psf, "b", c->start_date, sizeof(c->start_date));
#line 875
  psf_binheader_writef(psf, "b\301\277E\270U", c->start_time, sizeof(c->start_time));
#line 876
  psf_binheader_writef(psf, "b", c->end_date, sizeof(c->end_date));
#line 877
  psf_binheader_writef(psf, "b\277\277E\270U", c->end_time, sizeof(c->end_time));
#line 878
  psf_binheader_writef(psf, "b", c->producer_app_id, sizeof(c->producer_app_id));
#line 879
  psf_binheader_writef(psf, "b", c->producer_app_version, sizeof(c->producer_app_version));
#line 880
  psf_binheader_writef(psf, "b", c->user_def, sizeof(c->user_def));
#line 881
  psf_binheader_writef(psf, "4\276\277E\270U", c->level_reference, sizeof(c->level_reference));
#line 883
  k = 0;
  }
  {
#line 883
  while (1) {
    while_continue: /* CIL Label */ ;

#line 883
    if (! (k < (int )(sizeof(c->post_timers) / sizeof(c->post_timers[0])))) {
#line 883
      goto while_break;
    }
    {
#line 884
    __cil_tmp4 = make_size_t(4);
#line 884
    psf_binheader_writef(psf, "b4\277E\270U", c->post_timers[k].usage, __cil_tmp4,
                         c->post_timers[k].value);
#line 883
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 886
  psf_binheader_writef(psf, "z", sizeof(c->reserved));
#line 887
  psf_binheader_writef(psf, "b", c->url, sizeof(c->url));
  }
#line 889
  if (c->tag_text_size > 0U) {
    {
#line 890
    __cil_tmp6 = make_size_t((int )c->tag_text_size);
#line 890
    psf_binheader_writef(psf, "b\022\300E\270U", c->tag_text, __cil_tmp6);
    }
  }
#line 892
  return (0);
}
}
#line 896 "/root/patchweave_new/23/src/wavlike.c"
int wavlike_subchunk_parse(SF_PRIVATE *psf , int chunk , uint32_t chunk_length ) 
{ 
  sf_count_t current_pos ;
  char buffer[2048] ;
  uint32_t chunk_size ;
  uint32_t bytesread ;
  uint32_t thisread ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int mark_id ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;

  {
  {
#line 899
  bytesread = (uint32_t )0;
#line 901
  current_pos = psf_fseek(psf, (sf_count_t )0, 1);
  }
#line 903
  if (chunk_length <= 8U) {
    {
#line 905
    psf_log_printf(psf, "%M : %u (weird length)\n", chunk, chunk_length);
#line 906
    psf_binheader_readf(psf, "mj", & chunk, chunk_length - 4U);
#line 907
    psf_log_printf(psf, "  %M\nU", chunk);
    }
#line 908
    return (0);
  }
#line 911
  if (current_pos + (long )chunk_length > psf->filelength) {
    {
#line 912
    psf_log_printf(psf, "%M : %u (should be %d)\n", chunk, chunk_length, (int )(psf->filelength - current_pos));
#line 913
    chunk_length = (uint32_t )(psf->filelength - current_pos);
    }
  } else {
    {
#line 916
    psf_log_printf(psf, "%M : %u\n\230\001", chunk, chunk_length);
    }
  }
  {
#line 918
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 918
    if (! (bytesread < chunk_length)) {
#line 918
      goto while_break;
    }
    {
#line 921
    __cil_tmp10 = psf_binheader_readf(psf, "m", & chunk);
#line 921
    thisread = (uint32_t )__cil_tmp10;
    }
#line 921
    if (thisread == 0U) {
#line 922
      goto while_break;
    }
#line 923
    bytesread += thisread;
#line 927
    if (chunk == (int )((unsigned int )((73 | (78 << 8)) | (70 << 16)) | (79U << 24))) {
#line 927
      goto case_exp;
    }
#line 927
    if (chunk == (int )((unsigned int )((97 | (100 << 8)) | (116 << 16)) | (108U << 24))) {
#line 927
      goto case_exp;
    }
#line 932
    if (chunk == (int )((unsigned int )((101 | (120 << 8)) | (105 << 16)) | (102U << 24))) {
#line 932
      goto case_exp___1;
    }
#line 938
    if (chunk == (int )((unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24))) {
#line 938
      goto case_exp___2;
    }
#line 944
    if (chunk == 0) {
#line 944
      goto case_0;
    }
#line 955
    goto switch_default;
    case_exp: 
    {
#line 929
    psf_log_printf(psf, "  %M\nU", chunk);
    }
#line 930
    goto while_continue;
    case_exp___1: 
    {
#line 933
    psf_log_printf(psf, "  %M\n", chunk);
    }
#line 934
    if (chunk_length > bytesread) {
      {
#line 935
      __cil_tmp11 = exif_subchunk_parse(psf, chunk_length - bytesread);
#line 935
      bytesread += (unsigned int )__cil_tmp11;
      }
    }
#line 936
    goto while_continue;
    case_exp___2: 
    {
#line 939
    psf_log_printf(psf, "  %M inside a LIST block??? Backing out.\n", chunk);
#line 941
    psf_binheader_readf(psf, "j", -4);
    }
#line 942
    return (0);
    case_0: 
    {
#line 949
    psf_log_printf(psf, "    *** Found weird-ass zero marker. Jumping to end of chunk.\n");
    }
#line 950
    if (bytesread < chunk_length) {
      {
#line 951
      __cil_tmp12 = psf_binheader_readf(psf, "j", (chunk_length - bytesread) + 4U);
#line 951
      bytesread += (unsigned int )__cil_tmp12;
      }
    }
    {
#line 952
    __cil_tmp13 = psf_fseek(psf, (sf_count_t )0, 1);
#line 952
    psf_log_printf(psf, "    *** Offset is now : 0x%X\n", __cil_tmp13);
    }
#line 953
    return (0);
    switch_default: 
#line 956
    goto switch_break;
    switch_break: ;
#line 973
    if (chunk == (int )((unsigned int )((73 | (84 << 8)) | (82 << 16)) | (75U << 24))) {
#line 973
      goto case_exp___3;
    }
#line 973
    if (chunk == (int )((unsigned int )((73 | (65 << 8)) | (85 << 16)) | (84U << 24))) {
#line 973
      goto case_exp___3;
    }
#line 973
    if (chunk == (int )((unsigned int )((73 | (83 << 8)) | (82 << 16)) | (67U << 24))) {
#line 973
      goto case_exp___3;
    }
#line 973
    if (chunk == (int )((unsigned int )((73 | (83 << 8)) | (66 << 16)) | (74U << 24))) {
#line 973
      goto case_exp___3;
    }
#line 973
    if (chunk == (int )((unsigned int )((73 | (80 << 8)) | (82 << 16)) | (68U << 24))) {
#line 973
      goto case_exp___3;
    }
#line 973
    if (chunk == (int )((unsigned int )((73 | (78 << 8)) | (65 << 16)) | (77U << 24))) {
#line 973
      goto case_exp___3;
    }
#line 973
    if (chunk == (int )((unsigned int )((73 | (71 << 8)) | (78 << 16)) | (82U << 24))) {
#line 973
      goto case_exp___3;
    }
#line 973
    if (chunk == (int )((unsigned int )((73 | (69 << 8)) | (78 << 16)) | (71U << 24))) {
#line 973
      goto case_exp___3;
    }
#line 973
    if (chunk == (int )((unsigned int )((73 | (67 << 8)) | (82 << 16)) | (68U << 24))) {
#line 973
      goto case_exp___3;
    }
#line 973
    if (chunk == (int )((unsigned int )((73 | (67 << 8)) | (77 << 16)) | (84U << 24))) {
#line 973
      goto case_exp___3;
    }
#line 973
    if (chunk == (int )((unsigned int )((73 | (65 << 8)) | (82 << 16)) | (84U << 24))) {
#line 973
      goto case_exp___3;
    }
#line 973
    if (chunk == (int )((unsigned int )((73 | (65 << 8)) | (82 << 16)) | (76U << 24))) {
#line 973
      goto case_exp___3;
    }
#line 973
    if (chunk == (int )((unsigned int )((73 | (67 << 8)) | (79 << 16)) | (80U << 24))) {
#line 973
      goto case_exp___3;
    }
#line 973
    if (chunk == (int )((unsigned int )((73 | (83 << 8)) | (70 << 16)) | (84U << 24))) {
#line 973
      goto case_exp___3;
    }
#line 986
    if (chunk == (int )((unsigned int )((108 | (97 << 8)) | (98 << 16)) | (108U << 24))) {
#line 986
      goto case_exp___17;
    }
#line 1006
    if (chunk == (int )((unsigned int )((110 | (111 << 8)) | (116 << 16)) | (101U << 24))) {
#line 1006
      goto case_exp___18;
    }
#line 1006
    if (chunk == (int )((unsigned int )((108 | (116 << 8)) | (120 << 16)) | (116U << 24))) {
#line 1006
      goto case_exp___18;
    }
#line 1006
    if (chunk == (int )((unsigned int )((68 | (73 << 8)) | (83 << 16)) | (80U << 24))) {
#line 1006
      goto case_exp___18;
    }
#line 1017
    goto switch_default___0;
    case_exp___3: 
    {
#line 974
    __cil_tmp14 = psf_binheader_readf(psf, "4", & chunk_size);
#line 974
    bytesread += (unsigned int )__cil_tmp14;
#line 975
    chunk_size += chunk_size & 1U;
    }
#line 976
    if (chunk_size >= (unsigned int )((int )sizeof(buffer))) {
      {
#line 977
      psf_log_printf(psf, "  *** %M : %u (too big)\n\230\001", chunk, chunk_size);
      }
#line 978
      goto cleanup_subchunk_parse;
    } else
#line 976
    if (chunk_size >= chunk_length) {
      {
#line 977
      psf_log_printf(psf, "  *** %M : %u (too big)\n\230\001", chunk, chunk_size);
      }
#line 978
      goto cleanup_subchunk_parse;
    }
    {
#line 981
    __cil_tmp15 = psf_binheader_readf(psf, "b", buffer, chunk_size);
#line 981
    bytesread += (unsigned int )__cil_tmp15;
#line 982
    buffer[chunk_size] = (char)0;
#line 983
    psf_log_printf(psf, "    %M : %s\n", chunk, buffer);
    }
#line 984
    goto switch_break___0;
    case_exp___17: 
    {
#line 989
    __cil_tmp17 = psf_binheader_readf(psf, "44", & chunk_size, & mark_id);
#line 989
    bytesread += (unsigned int )__cil_tmp17;
#line 990
    chunk_size -= 4U;
#line 991
    chunk_size += chunk_size & 1U;
    }
#line 992
    if (chunk_size < 1U) {
      {
#line 993
      psf_log_printf(psf, "  *** %M : %u (too big)\n\230\001", chunk, chunk_size);
      }
#line 994
      goto cleanup_subchunk_parse;
    } else
#line 992
    if (chunk_size >= (unsigned int )((int )sizeof(buffer))) {
      {
#line 993
      psf_log_printf(psf, "  *** %M : %u (too big)\n\230\001", chunk, chunk_size);
      }
#line 994
      goto cleanup_subchunk_parse;
    } else
#line 992
    if (chunk_size >= chunk_length) {
      {
#line 993
      psf_log_printf(psf, "  *** %M : %u (too big)\n\230\001", chunk, chunk_size);
      }
#line 994
      goto cleanup_subchunk_parse;
    }
    {
#line 997
    __cil_tmp18 = psf_binheader_readf(psf, "b", buffer, chunk_size);
#line 997
    bytesread += (unsigned int )__cil_tmp18;
#line 998
    buffer[chunk_size] = (char)0;
#line 999
    psf_log_printf(psf, "    %M : %u : %s\n", chunk, mark_id, buffer);
    }
#line 1001
    goto switch_break___0;
    case_exp___18: 
    {
#line 1007
    __cil_tmp19 = psf_binheader_readf(psf, "4", & chunk_size);
#line 1007
    bytesread += (unsigned int )__cil_tmp19;
#line 1008
    chunk_size += chunk_size & 1U;
    }
#line 1009
    if (chunk_size >= (unsigned int )((int )sizeof(buffer))) {
      {
#line 1010
      psf_log_printf(psf, "  *** %M : %u (too big)\n\230\001", chunk, chunk_size);
      }
#line 1011
      goto cleanup_subchunk_parse;
    } else
#line 1009
    if (chunk_size >= chunk_length) {
      {
#line 1010
      psf_log_printf(psf, "  *** %M : %u (too big)\n\230\001", chunk, chunk_size);
      }
#line 1011
      goto cleanup_subchunk_parse;
    }
    {
#line 1014
    psf_log_printf(psf, "    %M : %u\n", chunk, chunk_size);
    }
#line 1015
    goto cleanup_subchunk_parse;
    switch_default___0: 
    {
#line 1018
    __cil_tmp20 = psf_binheader_readf(psf, "4", & chunk_size);
#line 1018
    bytesread += (unsigned int )__cil_tmp20;
#line 1019
    chunk_size += chunk_size & 1U;
#line 1020
    psf_log_printf(psf, "    *** %M : %u\n\230\001", chunk, chunk_size);
    }
#line 1021
    if (bytesread + chunk_size > chunk_length) {
      {
#line 1022
      __cil_tmp21 = psf_binheader_readf(psf, "j", (chunk_length - bytesread) + 4U);
#line 1022
      bytesread += (unsigned int )__cil_tmp21;
      }
#line 1023
      goto while_continue;
    } else {
      {
#line 1026
      __cil_tmp22 = psf_binheader_readf(psf, "j", chunk_size);
#line 1026
      bytesread += (unsigned int )__cil_tmp22;
      }
    }
#line 1028
    if (chunk_size >= chunk_length) {
#line 1029
      return (0);
    }
#line 1030
    goto switch_break___0;
    switch_break___0: ;
#line 1034
    if (chunk == (int )((unsigned int )((73 | (83 << 8)) | (70 << 16)) | (84U << 24))) {
#line 1034
      goto case_exp___21;
    }
#line 1037
    if (chunk == (int )((unsigned int )((73 | (67 << 8)) | (79 << 16)) | (80U << 24))) {
#line 1037
      goto case_exp___22;
    }
#line 1040
    if (chunk == (int )((unsigned int )((73 | (78 << 8)) | (65 << 16)) | (77U << 24))) {
#line 1040
      goto case_exp___23;
    }
#line 1043
    if (chunk == (int )((unsigned int )((73 | (65 << 8)) | (82 << 16)) | (84U << 24))) {
#line 1043
      goto case_exp___24;
    }
#line 1046
    if (chunk == (int )((unsigned int )((73 | (67 << 8)) | (77 << 16)) | (84U << 24))) {
#line 1046
      goto case_exp___25;
    }
#line 1049
    if (chunk == (int )((unsigned int )((73 | (67 << 8)) | (82 << 16)) | (68U << 24))) {
#line 1049
      goto case_exp___26;
    }
#line 1052
    if (chunk == (int )((unsigned int )((73 | (71 << 8)) | (78 << 16)) | (82U << 24))) {
#line 1052
      goto case_exp___27;
    }
#line 1055
    if (chunk == (int )((unsigned int )((73 | (80 << 8)) | (82 << 16)) | (68U << 24))) {
#line 1055
      goto case_exp___28;
    }
#line 1058
    if (chunk == (int )((unsigned int )((73 | (84 << 8)) | (82 << 16)) | (75U << 24))) {
#line 1058
      goto case_exp___29;
    }
#line 1033
    goto switch_break___1;
    case_exp___21: 
    {
#line 1035
    psf_store_string(psf, 3, (char const   *)(buffer));
    }
#line 1036
    goto switch_break___1;
    case_exp___22: 
    {
#line 1038
    psf_store_string(psf, 2, (char const   *)(buffer));
    }
#line 1039
    goto switch_break___1;
    case_exp___23: 
    {
#line 1041
    psf_store_string(psf, 1, (char const   *)(buffer));
    }
#line 1042
    goto switch_break___1;
    case_exp___24: 
    {
#line 1044
    psf_store_string(psf, 4, (char const   *)(buffer));
    }
#line 1045
    goto switch_break___1;
    case_exp___25: 
    {
#line 1047
    psf_store_string(psf, 5, (char const   *)(buffer));
    }
#line 1048
    goto switch_break___1;
    case_exp___26: 
    {
#line 1050
    psf_store_string(psf, 6, (char const   *)(buffer));
    }
#line 1051
    goto switch_break___1;
    case_exp___27: 
    {
#line 1053
    psf_store_string(psf, 16, (char const   *)(buffer));
    }
#line 1054
    goto switch_break___1;
    case_exp___28: 
    {
#line 1056
    psf_store_string(psf, 7, (char const   *)(buffer));
    }
#line 1057
    goto switch_break___1;
    case_exp___29: 
    {
#line 1059
    psf_store_string(psf, 9, (char const   *)(buffer));
    }
#line 1060
    goto switch_break___1;
    switch_break___1: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
  cleanup_subchunk_parse: 
#line 1066
  if (chunk_length > bytesread) {
    {
#line 1067
    __cil_tmp23 = psf_binheader_readf(psf, "j", chunk_length - bytesread);
#line 1067
    bytesread += (unsigned int )__cil_tmp23;
    }
  }
#line 1069
  return (0);
}
}
#line 1073 "/root/patchweave_new/23/src/wavlike.c"
void wavlike_write_strings(SF_PRIVATE *psf , int location ) 
{ 
  int k ;
  int prev_head_index ;
  int saved_head_index ;
  int __cil_tmp6 ;

  {
  {
#line 1076
  __cil_tmp6 = psf_location_string_count(psf, location);
  }
#line 1076
  if (__cil_tmp6 == 0) {
#line 1077
    return;
  }
  {
#line 1079
  prev_head_index = (int )(psf->header.indx + 4L);
#line 1081
  psf_binheader_writef(psf, "m4mE\270U", (unsigned int )((76 | (73 << 8)) | (83 << 16)) | (84U << 24),
                       12245933, (unsigned int )((73 | (78 << 8)) | (70 << 16)) | (79U << 24));
#line 1083
  k = 0;
  }
  {
#line 1083
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1083
    if (! (k < 32)) {
#line 1083
      goto while_break;
    }
#line 1084
    if (psf->strings.data[k].type == 0) {
#line 1085
      goto while_break;
    }
#line 1086
    if (psf->strings.data[k].type < 0) {
#line 1087
      goto while_continue;
    } else
#line 1086
    if (psf->strings.data[k].flags != location) {
#line 1087
      goto while_continue;
    }
#line 1090
    if (psf->strings.data[k].type == 3) {
#line 1090
      goto case_3;
    }
#line 1094
    if (psf->strings.data[k].type == 1) {
#line 1094
      goto case_1;
    }
#line 1098
    if (psf->strings.data[k].type == 2) {
#line 1098
      goto case_2;
    }
#line 1102
    if (psf->strings.data[k].type == 4) {
#line 1102
      goto case_4;
    }
#line 1106
    if (psf->strings.data[k].type == 5) {
#line 1106
      goto case_5;
    }
#line 1110
    if (psf->strings.data[k].type == 6) {
#line 1110
      goto case_6;
    }
#line 1114
    if (psf->strings.data[k].type == 16) {
#line 1114
      goto case_16;
    }
#line 1118
    if (psf->strings.data[k].type == 7) {
#line 1118
      goto case_7;
    }
#line 1122
    if (psf->strings.data[k].type == 9) {
#line 1122
      goto case_9;
    }
#line 1126
    goto switch_default;
    case_3: 
    {
#line 1091
    psf_binheader_writef(psf, "ms", (unsigned int )((73 | (83 << 8)) | (70 << 16)) | (84U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1092
    goto switch_break;
    case_1: 
    {
#line 1095
    psf_binheader_writef(psf, "ms", (unsigned int )((73 | (78 << 8)) | (65 << 16)) | (77U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1096
    goto switch_break;
    case_2: 
    {
#line 1099
    psf_binheader_writef(psf, "ms\301E\270U", (unsigned int )((73 | (67 << 8)) | (79 << 16)) | (80U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1100
    goto switch_break;
    case_4: 
    {
#line 1103
    psf_binheader_writef(psf, "ms\301E\270U", (unsigned int )((73 | (65 << 8)) | (82 << 16)) | (84U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1104
    goto switch_break;
    case_5: 
    {
#line 1107
    psf_binheader_writef(psf, "ms", (unsigned int )((73 | (67 << 8)) | (77 << 16)) | (84U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1108
    goto switch_break;
    case_6: 
    {
#line 1111
    psf_binheader_writef(psf, "ms\300E\270U", (unsigned int )((73 | (67 << 8)) | (82 << 16)) | (68U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1112
    goto switch_break;
    case_16: 
    {
#line 1115
    psf_binheader_writef(psf, "ms", (unsigned int )((73 | (71 << 8)) | (78 << 16)) | (82U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1116
    goto switch_break;
    case_7: 
    {
#line 1119
    psf_binheader_writef(psf, "ms\300E\270U", (unsigned int )((73 | (80 << 8)) | (82 << 16)) | (68U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1120
    goto switch_break;
    case_9: 
    {
#line 1123
    psf_binheader_writef(psf, "ms", (unsigned int )((73 | (84 << 8)) | (82 << 16)) | (75U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1124
    goto switch_break;
    switch_default: 
#line 1127
    goto switch_break;
    switch_break: 
#line 1083
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1131
  saved_head_index = (int )psf->header.indx;
#line 1132
  psf->header.indx = (sf_count_t )prev_head_index;
#line 1133
  psf_binheader_writef(psf, "4", (saved_head_index - prev_head_index) - 4);
#line 1134
  psf->header.indx = (sf_count_t )saved_head_index;
  }
#line 1136
  return;
}
}
#line 1139 "/root/patchweave_new/23/src/wavlike.c"
int wavlike_read_peak_chunk(SF_PRIVATE *psf , size_t chunk_size ) 
{ 
  char buffer[256] ;
  uint32_t uk ;
  float value___0 ;
  uint32_t position ;

  {
#line 1143
  if (chunk_size != 2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int ))) {
    {
#line 1144
    psf_binheader_readf(psf, "j", chunk_size);
#line 1145
    psf_log_printf(psf, "*** File PEAK chunk size doesn\'t fit with number of channels (%d).\nE\270U",
                   psf->sf.channels);
    }
#line 1146
    return (68);
  }
  {
#line 1149
  psf->peak_info = peak_info_calloc(psf->sf.channels);
  }
#line 1149
  if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 1150
    return (17);
  }
  {
#line 1153
  psf_binheader_readf(psf, "44", & (psf->peak_info)->version, & (psf->peak_info)->timestamp);
  }
#line 1155
  if ((psf->peak_info)->version != 1U) {
    {
#line 1156
    psf_log_printf(psf, "  version    : %d *** (should be version 1)\n", (psf->peak_info)->version);
    }
  } else {
    {
#line 1158
    psf_log_printf(psf, "  version    : %d\n\301E\270U", (psf->peak_info)->version);
    }
  }
  {
#line 1160
  psf_log_printf(psf, "  time stamp : %d\n", (psf->peak_info)->timestamp);
#line 1161
  psf_log_printf(psf, "    Ch   Position       Value\n");
#line 1163
  uk = (uint32_t )0;
  }
  {
#line 1163
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1163
    if (! (uk < (uint32_t )psf->sf.channels)) {
#line 1163
      goto while_break;
    }
    {
#line 1167
    psf_binheader_readf(psf, "f4\301E\270U", & value___0, & position);
#line 1168
    (psf->peak_info)->peaks[uk].value = (double )value___0;
#line 1169
    (psf->peak_info)->peaks[uk].position = (sf_count_t )position;
#line 1171
    snprintf(buffer, sizeof(buffer), "    %2d   %-12ld   %g\n", uk, (psf->peak_info)->peaks[uk].position,
             (psf->peak_info)->peaks[uk].value);
#line 1173
    buffer[sizeof(buffer) - 1UL] = (char)0;
#line 1174
    psf_log_printf(psf, "%s", buffer);
#line 1163
    uk ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1177
  return (0);
}
}
#line 1181 "/root/patchweave_new/23/src/wavlike.c"
void wavlike_write_peak_chunk(SF_PRIVATE *psf ) 
{ 
  int k ;
  time_t __cil_tmp3 ;

  {
#line 1184
  if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 1185
    return;
  }
  {
#line 1187
  psf_binheader_writef(psf, "m4", (unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24),
                       2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int )));
#line 1188
  __cil_tmp3 = time((time_t *)((void *)0));
#line 1188
  psf_binheader_writef(psf, "44\301E\270U", 1, __cil_tmp3);
#line 1189
  k = 0;
  }
  {
#line 1189
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1189
    if (! (k < psf->sf.channels)) {
#line 1189
      goto while_break;
    }
    {
#line 1190
    psf_binheader_writef(psf, "ft8", (double )((float )(psf->peak_info)->peaks[k].value),
                         (psf->peak_info)->peaks[k].position);
#line 1189
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1193
  return;
}
}
#line 1197 "/root/patchweave_new/23/src/wavlike.c"
static int exif_fill_and_sink(SF_PRIVATE *psf , char *buf , size_t bufsz , size_t toread ) 
{ 
  size_t bytesread ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 1199
  bytesread = (size_t )0;
#line 1201
  *(buf + 0) = (char)0;
#line 1202
  bufsz --;
#line 1203
  if (toread < bufsz) {
#line 1204
    bufsz = toread;
  }
  {
#line 1205
  __cil_tmp6 = psf_binheader_readf(psf, "b\301\301E\270U", buf, bufsz);
#line 1205
  bytesread = (size_t )__cil_tmp6;
#line 1206
  *(buf + bufsz) = (char)0;
  }
#line 1208
  if (bytesread == bufsz) {
#line 1208
    if (toread > bufsz) {
      {
#line 1209
      __cil_tmp7 = psf_binheader_readf(psf, "j\277\301E\270U", toread - bufsz);
#line 1209
      bytesread += (unsigned long )__cil_tmp7;
      }
    }
  }
#line 1211
  return ((int )bytesread);
}
}
#line 1219 "/root/patchweave_new/23/src/wavlike.c"
static int exif_subchunk_parse(SF_PRIVATE *psf , uint32_t length ) 
{ 
  uint32_t marker ;
  uint32_t dword ;
  uint32_t vmajor ;
  uint32_t vminor ;
  uint32_t bytesread ;
  char buf[4096] ;
  int thisread ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;

  {
#line 1220
  vmajor = (uint32_t )-1;
#line 1220
  vminor = (uint32_t )-1;
#line 1220
  bytesread = (uint32_t )0;
  {
#line 1224
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1224
    if (! (bytesread < length)) {
#line 1224
      goto while_break;
    }
    {
#line 1226
    thisread = psf_binheader_readf(psf, "m", & marker);
    }
#line 1226
    if (thisread == 0) {
#line 1227
      goto while_break;
    }
#line 1228
    bytesread += (unsigned int )thisread;
#line 1232
    if (marker == 0U) {
#line 1232
      goto case_0;
    }
#line 1235
    if (marker == ((unsigned int )((101 | (118 << 8)) | (101 << 16)) | (114U << 24))) {
#line 1235
      goto case_exp;
    }
#line 1242
    if (marker == ((unsigned int )((111 | (108 << 8)) | (121 << 16)) | (109U << 24))) {
#line 1242
      goto case_exp___0;
    }
#line 1256
    if (marker == ((unsigned int )((101 | (117 << 8)) | (99 << 16)) | (109U << 24))) {
#line 1256
      goto case_exp___1;
    }
#line 1256
    if (marker == ((unsigned int )((101 | (114 << 8)) | (101 << 16)) | (108U << 24))) {
#line 1256
      goto case_exp___1;
    }
#line 1256
    if (marker == ((unsigned int )((101 | (116 << 8)) | (105 << 16)) | (109U << 24))) {
#line 1256
      goto case_exp___1;
    }
#line 1256
    if (marker == ((unsigned int )((101 | (99 << 8)) | (111 << 16)) | (114U << 24))) {
#line 1256
      goto case_exp___1;
    }
#line 1256
    if (marker == ((unsigned int )((101 | (109 << 8)) | (100 << 16)) | (108U << 24))) {
#line 1256
      goto case_exp___1;
    }
#line 1256
    if (marker == ((unsigned int )((101 | (109 << 8)) | (110 << 16)) | (116U << 24))) {
#line 1256
      goto case_exp___1;
    }
#line 1281
    goto switch_default;
    case_0: 
#line 1233
    goto switch_break;
    case_exp: 
    {
#line 1236
    __cil_tmp11 = psf_binheader_readf(psf, "j4", 4, & dword);
#line 1236
    bytesread += (unsigned int )__cil_tmp11;
#line 1237
    vmajor = 10U * (((dword >> 24) & 255U) - 48U) + (((dword >> 16) & 255U) - 48U);
#line 1238
    vminor = 10U * (((dword >> 8) & 255U) - 48U) + ((dword & 255U) - 48U);
#line 1239
    psf_log_printf(psf, "    EXIF Version : %u.%02u\nE\270U", vmajor, vminor);
    }
#line 1240
    goto switch_break;
    case_exp___0: 
    {
#line 1243
    __cil_tmp12 = psf_binheader_readf(psf, "4\341\301E\270U", & dword);
#line 1243
    bytesread += (unsigned int )__cil_tmp12;
#line 1244
    psf_log_printf(psf, "%M : %u\n\230\001", marker, dword);
    }
#line 1245
    if (dword > length) {
#line 1246
      goto switch_break;
    } else
#line 1245
    if (bytesread + dword > length) {
#line 1246
      goto switch_break;
    }
    {
#line 1247
    dword += dword & 1U;
#line 1248
    __cil_tmp13 = psf_binheader_readf(psf, "j", dword);
#line 1248
    bytesread += (unsigned int )__cil_tmp13;
    }
#line 1249
    goto switch_break;
    case_exp___1: 
    {
#line 1257
    __cil_tmp14 = psf_binheader_readf(psf, "4", & dword);
#line 1257
    bytesread += (unsigned int )__cil_tmp14;
#line 1258
    bytesread = (uint32_t )((unsigned long )bytesread + sizeof(dword));
#line 1259
    dword += dword & 1U;
    }
#line 1261
    if ((unsigned long )dword >= sizeof(buf)) {
      {
#line 1262
      psf_log_printf(psf, "*** Marker \'%M\' is too big %u\n\n", marker, dword);
      }
#line 1263
      return ((int )bytesread);
    }
    {
#line 1266
    __cil_tmp15 = exif_fill_and_sink(psf, buf, sizeof(buf), (size_t )dword);
#line 1266
    bytesread += (unsigned int )__cil_tmp15;
#line 1271
    __cil_tmp16 = strlen((char const   *)(buf));
    }
#line 1271
    if (marker == ((unsigned int )((101 | (109 << 8)) | (100 << 16)) | (108U << 24))) {
#line 1271
      if ((unsigned long )dword == __cil_tmp16) {
        {
#line 1272
        psf_log_printf(psf, "    *** field size too small for string (sinking 2 bytes)\n");
#line 1273
        __cil_tmp17 = psf_binheader_readf(psf, "j", 2);
#line 1273
        bytesread += (unsigned int )__cil_tmp17;
        }
      }
    }
    {
#line 1276
    psf_log_printf(psf, "    %M : %u (%s)\n", marker, dword, buf);
    }
#line 1277
    if (dword > length) {
#line 1278
      return ((int )bytesread);
    }
#line 1279
    goto switch_break;
    switch_default: 
    {
#line 1282
    psf_log_printf(psf, "    *** %M (%u): -- ignored --\n", marker, marker);
    }
#line 1283
    goto switch_break;
    switch_break: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1287
  return ((int )bytesread);
}
}
#line 1291 "/root/patchweave_new/23/src/wavlike.c"
void wavlike_write_custom_chunks(SF_PRIVATE *psf ) 
{ 
  uint32_t k ;
  size_t __cil_tmp3 ;

  {
#line 1294
  k = (uint32_t )0;
  {
#line 1294
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1294
    if (! (k < psf->wchunks.used)) {
#line 1294
      goto while_break;
    }
    {
#line 1295
    __cil_tmp3 = make_size_t((int )(psf->wchunks.chunks + k)->len);
#line 1295
    psf_binheader_writef(psf, "m4b", (int )(psf->wchunks.chunks + k)->mark32, (psf->wchunks.chunks + k)->len,
                         (psf->wchunks.chunks + k)->data, __cil_tmp3);
#line 1294
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1298
  return;
}
}
#line 87 "/root/patchweave_new/23/src/w64.c"
static unsigned char riff_MARKER16[16]  = 
#line 87 "/root/patchweave_new/23/src/w64.c"
  {      (unsigned char )'r',      (unsigned char )'i',      (unsigned char )'f',      (unsigned char )'f', 
        (unsigned char)46,      (unsigned char)145,      (unsigned char)207,      (unsigned char)17, 
        (unsigned char)165,      (unsigned char)214,      (unsigned char)40,      (unsigned char)219, 
        (unsigned char)4,      (unsigned char)193,      (unsigned char)0,      (unsigned char)0};
#line 91 "/root/patchweave_new/23/src/w64.c"
static unsigned char wave_MARKER16[16]  = 
#line 91
  {      (unsigned char )'w',      (unsigned char )'a',      (unsigned char )'v',      (unsigned char )'e', 
        (unsigned char)243,      (unsigned char)172,      (unsigned char)211,      (unsigned char)17, 
        (unsigned char)140,      (unsigned char)209,      (unsigned char)0,      (unsigned char)192, 
        (unsigned char)79,      (unsigned char)142,      (unsigned char)219,      (unsigned char)138};
#line 94 "/root/patchweave_new/23/src/w64.c"
static unsigned char fmt_MARKER16[16]  = 
#line 94
  {      (unsigned char )'f',      (unsigned char )'m',      (unsigned char )'t',      (unsigned char )' ', 
        (unsigned char)243,      (unsigned char)172,      (unsigned char)211,      (unsigned char)17, 
        (unsigned char)140,      (unsigned char)209,      (unsigned char)0,      (unsigned char)192, 
        (unsigned char)79,      (unsigned char)142,      (unsigned char)219,      (unsigned char)138};
#line 97 "/root/patchweave_new/23/src/w64.c"
static unsigned char fact_MARKER16[16]  = 
#line 97
  {      (unsigned char )'f',      (unsigned char )'a',      (unsigned char )'c',      (unsigned char )'t', 
        (unsigned char)243,      (unsigned char)172,      (unsigned char)211,      (unsigned char)17, 
        (unsigned char)140,      (unsigned char)209,      (unsigned char)0,      (unsigned char)192, 
        (unsigned char)79,      (unsigned char)142,      (unsigned char)219,      (unsigned char)138};
#line 100 "/root/patchweave_new/23/src/w64.c"
static unsigned char data_MARKER16[16]  = 
#line 100
  {      (unsigned char )'d',      (unsigned char )'a',      (unsigned char )'t',      (unsigned char )'a', 
        (unsigned char)243,      (unsigned char)172,      (unsigned char)211,      (unsigned char)17, 
        (unsigned char)140,      (unsigned char)209,      (unsigned char)0,      (unsigned char)192, 
        (unsigned char)79,      (unsigned char)142,      (unsigned char)219,      (unsigned char)138};
#line 115
static int w64_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) ;
#line 116
static int w64_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 117
static int w64_close(SF_PRIVATE *psf ) ;
#line 124 "/root/patchweave_new/23/src/w64.c"
int w64_open(SF_PRIVATE *psf ) 
{ 
  WAVLIKE_PRIVATE *wpriv ;
  int subformat ;
  int error ;
  int blockalign ;
  int framesperblock ;
  sf_count_t tmp ;
  void *tmp___0 ;

  {
  {
#line 126
  blockalign = 0;
#line 126
  framesperblock = 0;
#line 128
  tmp___0 = calloc(1UL, sizeof(WAVLIKE_PRIVATE ));
#line 128
  wpriv = (WAVLIKE_PRIVATE *)tmp___0;
  }
#line 128
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 129
    return (17);
  }
#line 130
  psf->container_data = (void *)wpriv;
#line 132
  if (psf->file.mode == 16) {
    _L: 
    {
#line 133
    error = w64_read_header(psf, & blockalign, & framesperblock);
    }
#line 133
    if (error) {
#line 134
      return (error);
    }
  } else
#line 132
  if (psf->file.mode == 48) {
#line 132
    if (psf->filelength > 0L) {
#line 132
      goto _L;
    }
  }
#line 137
  if ((psf->sf.format & 268369920) != 720896) {
#line 138
    return (1);
  }
#line 140
  subformat = psf->sf.format & 65535;
#line 142
  if (psf->file.mode == 32) {
    _L___20: 
#line 143
    if (psf->is_pipe) {
#line 144
      return (29);
    }
#line 146
    psf->endian = 268435456;
#line 148
    psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 150
    if (subformat == 18) {
      _L___19: 
      {
#line 151
      blockalign = wavlike_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 152
      framesperblock = -1;
#line 158
      psf->filelength = (sf_count_t )-10001LL;
#line 159
      psf->datalength = psf->filelength;
      }
#line 160
      if (psf->sf.frames <= 0L) {
#line 161
        if (psf->blockwidth) {
#line 161
          tmp = psf->filelength / (long )psf->blockwidth;
        } else {
#line 161
          tmp = psf->filelength;
        }
#line 161
        psf->sf.frames = tmp;
      }
    } else
#line 150
    if (subformat == 19) {
#line 150
      goto _L___19;
    }
    {
#line 164
    error = w64_write_header(psf, 0);
    }
#line 164
    if (error) {
#line 165
      return (error);
    }
#line 167
    psf->write_header = & w64_write_header;
  } else
#line 142
  if (psf->file.mode == 48) {
#line 142
    goto _L___20;
  }
#line 170
  psf->container_close = & w64_close;
#line 173
  if (subformat == 5) {
#line 173
    goto case_5;
  }
#line 179
  if (subformat == 4) {
#line 179
    goto case_4;
  }
#line 179
  if (subformat == 3) {
#line 179
    goto case_4;
  }
#line 179
  if (subformat == 2) {
#line 179
    goto case_4;
  }
#line 183
  if (subformat == 16) {
#line 183
    goto case_16;
  }
#line 187
  if (subformat == 17) {
#line 187
    goto case_17;
  }
#line 192
  if (subformat == 6) {
#line 192
    goto case_6;
  }
#line 196
  if (subformat == 7) {
#line 196
    goto case_7;
  }
#line 200
  if (subformat == 18) {
#line 200
    goto case_18;
  }
#line 204
  if (subformat == 19) {
#line 204
    goto case_19;
  }
#line 209
  if (subformat == 32) {
#line 209
    goto case_32;
  }
#line 213
  goto switch_default;
  case_5: 
  {
#line 174
  error = pcm_init(psf);
  }
#line 175
  goto switch_break;
  case_4: 
  {
#line 180
  error = pcm_init(psf);
  }
#line 181
  goto switch_break;
  case_16: 
  {
#line 184
  error = ulaw_init(psf);
  }
#line 185
  goto switch_break;
  case_17: 
  {
#line 188
  error = alaw_init(psf);
  }
#line 189
  goto switch_break;
  case_6: 
  {
#line 193
  error = float32_init(psf);
  }
#line 194
  goto switch_break;
  case_7: 
  {
#line 197
  error = double64_init(psf);
  }
#line 198
  goto switch_break;
  case_18: 
  {
#line 201
  error = wavlike_ima_init(psf, blockalign, framesperblock);
  }
#line 202
  goto switch_break;
  case_19: 
  {
#line 205
  error = wavlike_msadpcm_init(psf, blockalign, framesperblock);
  }
#line 206
  goto switch_break;
  case_32: 
  {
#line 210
  error = gsm610_init(psf);
  }
#line 211
  goto switch_break;
  switch_default: 
#line 213
  return (18);
  switch_break: ;
#line 216
  return (error);
}
}
#line 224 "/root/patchweave_new/23/src/w64.c"
static int w64_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) 
{ 
  WAVLIKE_PRIVATE *wpriv ;
  WAV_FMT *wav_fmt ;
  int dword ;
  int marker ;
  int format ;
  sf_count_t chunk_size ;
  sf_count_t bytesread ;
  int parsestage ;
  int error ;
  int done ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  sf_count_t frames ;
  sf_count_t __cil_tmp19 ;
  sf_count_t __cil_tmp20 ;
  sf_count_t __cil_tmp21 ;
  int __cil_tmp22 ;
  int tmp ;

  {
#line 227
  dword = 0;
#line 227
  format = 0;
#line 228
  bytesread = (sf_count_t )0;
#line 229
  parsestage = 0;
#line 229
  done = 0;
#line 231
  wpriv = (WAVLIKE_PRIVATE *)psf->container_data;
#line 231
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 232
    return (30);
  }
  {
#line 233
  wav_fmt = & wpriv->wav_fmt;
#line 236
  psf_binheader_readf(psf, "p", 0);
  }
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;

#line 238
    if (! (! done)) {
#line 238
      goto while_break;
    }
#line 240
    if (psf->header.indx & 7L) {
      {
#line 241
      psf_binheader_readf(psf, "j\254\340E\270U", 8L - (psf->header.indx & 7L));
      }
    }
    {
#line 244
    chunk_size = (sf_count_t )0;
#line 244
    marker = (int )chunk_size;
#line 245
    __cil_tmp14 = psf_binheader_readf(psf, "eh8", & marker, & chunk_size);
#line 245
    bytesread = (sf_count_t )__cil_tmp14;
    }
#line 246
    if (bytesread == 0L) {
#line 247
      goto while_break;
    }
#line 249
    if (marker == (((((((((((((114 ^ (105 << 1)) ^ (102 << 2)) ^ (102 << 3)) ^ (46 << 4)) ^ (145 << 5)) ^ (207 << 6)) ^ (17 << 7)) ^ (165 << 8)) ^ (214 << 9)) ^ (40 << 10)) ^ (219 << 11)) ^ (4 << 12)) ^ (193 << 13))) {
#line 249
      goto case_exp;
    }
#line 270
    if (marker == (((((((((((((((109 ^ (7 << 1)) ^ (28 << 2)) ^ (234 << 3)) ^ (163 << 4)) ^ (239 << 5)) ^ (120 << 6)) ^ (76 << 7)) ^ (144 << 8)) ^ (87 << 9)) ^ (127 << 10)) ^ (121 << 11)) ^ (238 << 12)) ^ (37 << 13)) ^ (42 << 14)) ^ (174 << 15))) {
#line 270
      goto case_exp___0;
    }
#line 274
    if (marker == ((((((((((((((102 ^ (109 << 1)) ^ (116 << 2)) ^ (32 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (140 << 8)) ^ (209 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 274
      goto case_exp___1;
    }
#line 294
    if (marker == ((((((((((((((102 ^ (97 << 1)) ^ (99 << 2)) ^ (116 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (140 << 8)) ^ (209 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 294
      goto case_exp___2;
    }
#line 305
    if (marker == ((((((((((((((100 ^ (97 << 1)) ^ (116 << 2)) ^ (97 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (140 << 8)) ^ (209 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 305
      goto case_exp___3;
    }
#line 327
    if (marker == ((((((((((((((108 ^ (101 << 1)) ^ (118 << 2)) ^ (108 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (209 << 8)) ^ (140 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 327
      goto case_exp___4;
    }
#line 332
    if (marker == (((((((((((((108 ^ (105 << 1)) ^ (115 << 2)) ^ (116 << 3)) ^ (47 << 4)) ^ (145 << 5)) ^ (207 << 6)) ^ (17 << 7)) ^ (165 << 8)) ^ (214 << 9)) ^ (40 << 10)) ^ (219 << 11)) ^ (4 << 12)) ^ (193 << 13))) {
#line 332
      goto case_exp___5;
    }
#line 337
    if (marker == ((((((((((((((106 ^ (117 << 1)) ^ (110 << 2)) ^ (107 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (140 << 8)) ^ (209 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 337
      goto case_exp___6;
    }
#line 342
    if (marker == ((((((((((((((98 ^ (101 << 1)) ^ (120 << 2)) ^ (116 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (170 << 7)) ^ (209 << 8)) ^ (140 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 342
      goto case_exp___7;
    }
#line 347
    if (marker == ((((((((((((((86 ^ (98 << 1)) ^ (247 << 2)) ^ (171 << 3)) ^ (45 << 4)) ^ (57 << 5)) ^ (210 << 6)) ^ (17 << 7)) ^ (134 << 8)) ^ (199 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 347
      goto case_exp___8;
    }
#line 352
    if (marker == ((((((((((((((188 ^ (148 << 1)) ^ (95 << 2)) ^ (146 << 3)) ^ (90 << 4)) ^ (82 << 5)) ^ (210 << 6)) ^ (17 << 7)) ^ (134 << 8)) ^ (220 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 352
      goto case_exp___9;
    }
#line 357
    goto switch_default;
    case_exp: 
#line 250
    if (parsestage) {
#line 251
      return (125);
    }
#line 253
    if (psf->filelength != chunk_size) {
      {
#line 254
      psf_log_printf(psf, "riff : %D (should be %D)\n", chunk_size, psf->filelength);
      }
    } else {
      {
#line 256
      psf_log_printf(psf, "riff : %D\n", chunk_size);
      }
    }
    {
#line 258
    parsestage |= 1;
#line 260
    __cil_tmp15 = psf_binheader_readf(psf, "h\305\340E\270U", & marker);
#line 260
    bytesread += (long )__cil_tmp15;
    }
#line 261
    if (marker == ((((((((((((((119 ^ (97 << 1)) ^ (118 << 2)) ^ (101 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (140 << 8)) ^ (209 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 262
      if ((parsestage & 1) != 1) {
#line 263
        return (126);
      }
      {
#line 264
      psf_log_printf(psf, "wave\n");
#line 265
      parsestage |= 2;
      }
    }
#line 267
    chunk_size = (sf_count_t )0;
#line 268
    goto switch_break;
    case_exp___0: 
    {
#line 271
    psf_log_printf(psf, "Looks like an ACID file. Exiting.\n");
    }
#line 272
    return (18);
    case_exp___1: 
#line 275
    if ((parsestage & 3) != 3) {
#line 276
      return (64);
    }
    {
#line 278
    psf_log_printf(psf, " fmt : %D\n", chunk_size);
#line 281
    chunk_size -= 24L;
#line 283
    error = wavlike_read_fmt_chunk(psf, (int )chunk_size);
    }
#line 283
    if (error) {
#line 284
      return (error);
    }
#line 286
    if (chunk_size % 8L) {
      {
#line 287
      psf_binheader_readf(psf, "j", 8L - chunk_size % 8L);
      }
    }
#line 289
    format = (int )wav_fmt->format;
#line 290
    parsestage |= 4;
#line 291
    chunk_size = (sf_count_t )0;
#line 292
    goto switch_break;
    case_exp___2: 
    {
#line 297
    psf_binheader_readf(psf, "e8", & frames);
#line 298
    psf_log_printf(psf, "fact : %D\n  frames : %D\n\230\001", chunk_size, frames);
#line 301
    chunk_size = (sf_count_t )0;
    }
#line 302
    goto switch_break;
    case_exp___3: 
#line 306
    if ((parsestage & 7) != 7) {
#line 307
      return (127);
    }
    {
#line 309
    psf->dataoffset = psf_ftell(psf);
#line 310
    psf->datalength = (sf_count_t )0;
    }
#line 312
    if (chunk_size % 8L) {
#line 313
      chunk_size += 8L - chunk_size % 8L;
    }
    {
#line 315
    psf_log_printf(psf, "data : %D\n", chunk_size);
#line 317
    parsestage |= 32;
    }
#line 319
    if (! psf->sf.seekable) {
#line 320
      goto switch_break;
    }
    {
#line 323
    psf_fseek(psf, chunk_size, 1);
#line 324
    chunk_size = (sf_count_t )0;
    }
#line 325
    goto switch_break;
    case_exp___4: 
    {
#line 328
    psf_log_printf(psf, "levl : %D\n", chunk_size);
#line 329
    chunk_size -= 24L;
    }
#line 330
    goto switch_break;
    case_exp___5: 
    {
#line 333
    psf_log_printf(psf, "list : %D\n", chunk_size);
#line 334
    chunk_size -= 24L;
    }
#line 335
    goto switch_break;
    case_exp___6: 
    {
#line 338
    psf_log_printf(psf, "junk : %D\n", chunk_size);
#line 339
    chunk_size -= 24L;
    }
#line 340
    goto switch_break;
    case_exp___7: 
    {
#line 343
    psf_log_printf(psf, "bext : %D\n", chunk_size);
#line 344
    chunk_size -= 24L;
    }
#line 345
    goto switch_break;
    case_exp___8: 
    {
#line 348
    psf_log_printf(psf, "marker : %D\n", chunk_size);
#line 349
    chunk_size -= 24L;
    }
#line 350
    goto switch_break;
    case_exp___9: 
    {
#line 353
    psf_log_printf(psf, "summary list : %D\n", chunk_size);
#line 354
    chunk_size -= 24L;
    }
#line 355
    goto switch_break;
    switch_default: 
    {
#line 358
    __cil_tmp19 = psf_ftell(psf);
#line 358
    psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D with length %D. Exiting parser.\n",
                   marker, __cil_tmp19 - 8L, chunk_size);
#line 359
    done = 1;
    }
#line 360
    goto switch_break;
    switch_break: ;
#line 363
    if (chunk_size >= psf->filelength) {
      {
#line 364
      psf_log_printf(psf, "*** Chunk size %u > file length %D. Exiting parser.\n",
                     chunk_size, psf->filelength);
      }
#line 365
      goto while_break;
    }
#line 368
    if (psf->sf.seekable == 0) {
#line 368
      if (parsestage & 32) {
#line 369
        goto while_break;
      }
    }
    {
#line 371
    __cil_tmp20 = psf_ftell(psf);
    }
#line 371
    if (__cil_tmp20 >= psf->filelength - (long )(2 * (int )sizeof(dword))) {
#line 372
      goto while_break;
    }
#line 374
    if (chunk_size > 0L) {
#line 374
      if (chunk_size < 4294901760L) {
        {
#line 375
        dword = (int )chunk_size;
#line 376
        psf_binheader_readf(psf, "j", dword - 24);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 380
  if (psf->dataoffset <= 0L) {
#line 381
    return (127);
  }
#line 383
  if (psf->sf.channels < 1) {
#line 384
    return (33);
  }
#line 386
  if (psf->sf.channels >= 1024) {
#line 387
    return (34);
  }
  {
#line 389
  psf->endian = 268435456;
#line 391
  __cil_tmp21 = psf_ftell(psf);
  }
#line 391
  if (__cil_tmp21 != psf->dataoffset) {
    {
#line 392
    psf_fseek(psf, psf->dataoffset, 0);
    }
  }
#line 394
  if (psf->blockwidth) {
#line 395
    if (psf->filelength - psf->dataoffset < psf->datalength) {
#line 396
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    } else {
#line 398
      psf->sf.frames = psf->datalength / (long )psf->blockwidth;
    }
  }
#line 403
  if (format == 65534) {
#line 403
    goto case_65534;
  }
#line 403
  if (format == 1) {
#line 403
    goto case_65534;
  }
#line 408
  if (format == 7) {
#line 408
    goto case_7;
  }
#line 412
  if (format == 6) {
#line 412
    goto case_6;
  }
#line 416
  if (format == 2) {
#line 416
    goto case_2;
  }
#line 422
  if (format == 17) {
#line 422
    goto case_17;
  }
#line 428
  if (format == 49) {
#line 428
    goto case_49;
  }
#line 432
  if (format == 3) {
#line 432
    goto case_3;
  }
#line 437
  goto switch_default___0;
  case_65534: 
  {
#line 405
  __cil_tmp22 = u_bitwidth_to_subformat(psf->bytewidth * 8);
#line 405
  psf->sf.format = 720896 | __cil_tmp22;
  }
#line 406
  goto switch_break___0;
  case_7: 
#line 409
  psf->sf.format = 720912;
#line 410
  goto switch_break___0;
  case_6: 
#line 413
  psf->sf.format = 720913;
#line 414
  goto switch_break___0;
  case_2: 
#line 417
  psf->sf.format = 720915;
#line 418
  *blockalign = (int )wav_fmt->msadpcm.blockalign;
#line 419
  *framesperblock = (int )wav_fmt->msadpcm.samplesperblock;
#line 420
  goto switch_break___0;
  case_17: 
#line 423
  psf->sf.format = 720914;
#line 424
  *blockalign = (int )wav_fmt->ima.blockalign;
#line 425
  *framesperblock = (int )wav_fmt->ima.samplesperblock;
#line 426
  goto switch_break___0;
  case_49: 
#line 429
  psf->sf.format = 720928;
#line 430
  goto switch_break___0;
  case_3: 
#line 433
  psf->sf.format = 720896;
#line 434
  if (psf->bytewidth == 8) {
#line 434
    tmp = 7;
  } else {
#line 434
    tmp = 6;
  }
#line 434
  psf->sf.format |= tmp;
#line 435
  goto switch_break___0;
  switch_default___0: 
#line 437
  return (18);
  switch_break___0: ;
#line 440
  return (0);
}
}
#line 444 "/root/patchweave_new/23/src/w64.c"
static int w64_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t fmt_size ;
  sf_count_t current ;
  size_t fmt_pad ;
  int subformat ;
  int add_fact_chunk ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int blockalign ;
  int framesperblock ;
  int bytespersec ;
  long tmp___3 ;
  int blockalign___0 ;
  int framesperblock___0 ;
  int bytespersec___0 ;
  int extrabytes ;
  long tmp___4 ;
  int bytespersec___1 ;
  long tmp___5 ;

  {
  {
#line 446
  fmt_pad = (size_t )0;
#line 447
  add_fact_chunk = 0;
#line 449
  current = psf_ftell(psf);
  }
#line 451
  if (calc_length) {
    {
#line 452
    psf->filelength = psf_get_filelen(psf);
#line 454
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 455
    if (psf->dataend) {
#line 456
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 458
    if (psf->bytewidth) {
#line 459
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
  {
#line 463
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 464
  psf->header.indx = (sf_count_t )0;
#line 465
  psf_fseek(psf, (sf_count_t )0, 0);
#line 468
  psf_binheader_writef(psf, "eh8hh", riff_MARKER16, psf->filelength, wave_MARKER16,
                       fmt_MARKER16);
#line 470
  subformat = psf->sf.format & 65535;
  }
#line 476
  if (subformat == 4) {
#line 476
    goto case_4;
  }
#line 476
  if (subformat == 3) {
#line 476
    goto case_4;
  }
#line 476
  if (subformat == 2) {
#line 476
    goto case_4;
  }
#line 476
  if (subformat == 5) {
#line 476
    goto case_4;
  }
#line 490
  if (subformat == 7) {
#line 490
    goto case_7;
  }
#line 490
  if (subformat == 6) {
#line 490
    goto case_7;
  }
#line 505
  if (subformat == 16) {
#line 505
    goto case_16;
  }
#line 520
  if (subformat == 17) {
#line 520
    goto case_17;
  }
#line 536
  if (subformat == 18) {
#line 536
    goto case_18;
  }
#line 561
  if (subformat == 19) {
#line 561
    goto case_19;
  }
#line 590
  if (subformat == 32) {
#line 590
    goto case_32;
  }
#line 613
  goto switch_default;
  case_4: 
#line 477
  fmt_size = (sf_count_t )40;
#line 478
  if (fmt_size & 7L) {
#line 478
    tmp = 8L - (fmt_size & 7L);
  } else {
#line 478
    tmp = 0L;
  }
  {
#line 478
  fmt_pad = (size_t )tmp;
#line 479
  fmt_size = (sf_count_t )((size_t )fmt_size + fmt_pad);
#line 482
  psf_binheader_writef(psf, "e8224", fmt_size, 1, psf->sf.channels, psf->sf.samplerate);
#line 484
  psf_binheader_writef(psf, "e4\341E\270U", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 486
  psf_binheader_writef(psf, "e22", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
  }
#line 487
  goto switch_break;
  case_7: 
#line 491
  fmt_size = (sf_count_t )40;
#line 492
  if (fmt_size & 7L) {
#line 492
    tmp___0 = 8L - (fmt_size & 7L);
  } else {
#line 492
    tmp___0 = 0L;
  }
  {
#line 492
  fmt_pad = (size_t )tmp___0;
#line 493
  fmt_size = (sf_count_t )((size_t )fmt_size + fmt_pad);
#line 496
  psf_binheader_writef(psf, "e8224U", fmt_size, 3, psf->sf.channels, psf->sf.samplerate);
#line 498
  psf_binheader_writef(psf, "e4\341E\270U", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 500
  psf_binheader_writef(psf, "e22", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
#line 502
  add_fact_chunk = 1;
  }
#line 503
  goto switch_break;
  case_16: 
#line 506
  fmt_size = (sf_count_t )40;
#line 507
  if (fmt_size & 7L) {
#line 507
    tmp___1 = 8L - (fmt_size & 7L);
  } else {
#line 507
    tmp___1 = 0L;
  }
  {
#line 507
  fmt_pad = (size_t )tmp___1;
#line 508
  fmt_size = (sf_count_t )((size_t )fmt_size + fmt_pad);
#line 511
  psf_binheader_writef(psf, "e8224", fmt_size, 7, psf->sf.channels, psf->sf.samplerate);
#line 513
  psf_binheader_writef(psf, "e4\246E\270U", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 515
  psf_binheader_writef(psf, "e22E\270U", psf->bytewidth * psf->sf.channels, 8);
#line 517
  add_fact_chunk = 1;
  }
#line 518
  goto switch_break;
  case_17: 
#line 521
  fmt_size = (sf_count_t )40;
#line 522
  if (fmt_size & 7L) {
#line 522
    tmp___2 = 8L - (fmt_size & 7L);
  } else {
#line 522
    tmp___2 = 0L;
  }
  {
#line 522
  fmt_pad = (size_t )tmp___2;
#line 523
  fmt_size = (sf_count_t )((size_t )fmt_size + fmt_pad);
#line 526
  psf_binheader_writef(psf, "e8224", fmt_size, 6, psf->sf.channels, psf->sf.samplerate);
#line 528
  psf_binheader_writef(psf, "e4\341E\270U", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 530
  psf_binheader_writef(psf, "e22E\270U", psf->bytewidth * psf->sf.channels, 8);
#line 532
  add_fact_chunk = 1;
  }
#line 533
  goto switch_break;
  case_18: 
  {
#line 539
  blockalign = wavlike_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 540
  framesperblock = (2 * (blockalign - 4 * psf->sf.channels)) / psf->sf.channels + 1;
#line 541
  bytespersec = (psf->sf.samplerate * blockalign) / framesperblock;
#line 544
  fmt_size = (sf_count_t )44;
  }
#line 545
  if (fmt_size & 7L) {
#line 545
    tmp___3 = 8L - (fmt_size & 7L);
  } else {
#line 545
    tmp___3 = 0L;
  }
  {
#line 545
  fmt_pad = (size_t )tmp___3;
#line 546
  fmt_size = (sf_count_t )((size_t )fmt_size + fmt_pad);
#line 549
  psf_binheader_writef(psf, "e822\270U", fmt_size, 17, psf->sf.channels);
#line 552
  psf_binheader_writef(psf, "e44", psf->sf.samplerate, bytespersec);
#line 555
  psf_binheader_writef(psf, "e2222", blockalign, 4, 2, framesperblock);
#line 558
  add_fact_chunk = 1;
  }
#line 559
  goto switch_break;
  case_19: 
  {
#line 564
  blockalign___0 = wavlike_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 565
  framesperblock___0 = 2 + (2 * (blockalign___0 - 7 * psf->sf.channels)) / psf->sf.channels;
#line 566
  bytespersec___0 = (psf->sf.samplerate * blockalign___0) / framesperblock___0;
#line 569
  extrabytes = 32;
#line 570
  fmt_size = (sf_count_t )(42 + extrabytes);
  }
#line 571
  if (fmt_size & 7L) {
#line 571
    tmp___4 = 8L - (fmt_size & 7L);
  } else {
#line 571
    tmp___4 = 0L;
  }
  {
#line 571
  fmt_pad = (size_t )tmp___4;
#line 572
  fmt_size = (sf_count_t )((size_t )fmt_size + fmt_pad);
#line 575
  psf_binheader_writef(psf, "e822", fmt_size, 2, psf->sf.channels);
#line 578
  psf_binheader_writef(psf, "e44", psf->sf.samplerate, bytespersec___0);
#line 581
  psf_binheader_writef(psf, "e22222", blockalign___0, 4, extrabytes, framesperblock___0,
                       7);
#line 583
  wavlike_msadpcm_write_adapt_coeffs(psf);
#line 586
  add_fact_chunk = 1;
  }
#line 587
  goto switch_break;
  case_32: 
#line 593
  bytespersec___1 = (psf->sf.samplerate * 65) / 320;
#line 596
  fmt_size = (sf_count_t )44;
#line 597
  if (fmt_size & 7L) {
#line 597
    tmp___5 = 8L - (fmt_size & 7L);
  } else {
#line 597
    tmp___5 = 0L;
  }
  {
#line 597
  fmt_pad = (size_t )tmp___5;
#line 598
  fmt_size = (sf_count_t )((size_t )fmt_size + fmt_pad);
#line 601
  psf_binheader_writef(psf, "e822", fmt_size, 49, psf->sf.channels);
#line 604
  psf_binheader_writef(psf, "e44", psf->sf.samplerate, bytespersec___1);
#line 607
  psf_binheader_writef(psf, "e2222", 65, 0, 2, 320);
#line 610
  add_fact_chunk = 1;
  }
#line 611
  goto switch_break;
  switch_default: 
#line 613
  return (18);
  switch_break: ;
#line 617
  if (fmt_pad > 0UL) {
    {
#line 618
    psf_binheader_writef(psf, "z\321\340E\270U", fmt_pad);
    }
  }
#line 620
  if (add_fact_chunk) {
    {
#line 621
    psf_binheader_writef(psf, "eh88\270U", fact_MARKER16, (sf_count_t )32, psf->sf.frames);
    }
  }
  {
#line 623
  psf_binheader_writef(psf, "eh8", data_MARKER16, psf->datalength + 24L);
#line 624
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 626
  if (psf->error) {
#line 627
    return (psf->error);
  }
#line 629
  psf->dataoffset = psf->header.indx;
#line 631
  if (current > 0L) {
    {
#line 632
    psf_fseek(psf, current, 0);
    }
  }
#line 634
  return (psf->error);
}
}
#line 638 "/root/patchweave_new/23/src/w64.c"
static int w64_close(SF_PRIVATE *psf ) 
{ 


  {
#line 640
  if (psf->file.mode == 32) {
    {
#line 641
    w64_write_header(psf, 1);
    }
  } else
#line 640
  if (psf->file.mode == 48) {
    {
#line 641
    w64_write_header(psf, 1);
    }
  }
#line 643
  return (0);
}
}
#line 46 "/root/patchweave_new/23/src/wve.c"
static int wve_read_header(SF_PRIVATE *psf ) ;
#line 47
static int wve_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 48
static int wve_close(SF_PRIVATE *psf ) ;
#line 55 "/root/patchweave_new/23/src/wve.c"
int wve_open(SF_PRIVATE *psf ) 
{ 
  int error ;

  {
#line 56
  error = 0;
#line 58
  if (psf->is_pipe) {
#line 59
    return (162);
  }
#line 61
  if (psf->file.mode == 16) {
    _L: 
    {
#line 62
    error = wve_read_header(psf);
    }
#line 62
    if (error) {
#line 63
      return (error);
    }
  } else
#line 61
  if (psf->file.mode == 48) {
#line 61
    if (psf->filelength > 0L) {
#line 61
      goto _L;
    }
  }
#line 66
  if (psf->file.mode == 32) {
    _L___21: 
#line 67
    if ((psf->sf.format & 268369920) != 1638400) {
#line 68
      return (1);
    }
    {
#line 70
    psf->endian = 536870912;
#line 72
    error = wve_write_header(psf, 0);
    }
#line 72
    if (error) {
#line 73
      return (error);
    }
#line 75
    psf->write_header = & wve_write_header;
  } else
#line 66
  if (psf->file.mode == 48) {
#line 66
    goto _L___21;
  }
  {
#line 78
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 80
  psf->container_close = & wve_close;
#line 82
  error = alaw_init(psf);
  }
#line 84
  return (error);
}
}
#line 91 "/root/patchweave_new/23/src/wve.c"
static int wve_read_header(SF_PRIVATE *psf ) 
{ 
  int marker ;
  unsigned short version ;
  unsigned short padding ;
  unsigned short repeats ;
  unsigned short trash ;
  unsigned int datalength ;

  {
  {
#line 97
  psf_binheader_readf(psf, "pm", 0, & marker);
  }
#line 98
  if ((unsigned int )marker != ((unsigned int )((65 | (76 << 8)) | (97 << 16)) | (119U << 24))) {
    {
#line 99
    psf_log_printf(psf, "Could not find \'%M\'\n", (unsigned int )((65 | (76 << 8)) | (97 << 16)) | (119U << 24));
    }
#line 100
    return (161);
  }
  {
#line 103
  psf_binheader_readf(psf, "m", & marker);
  }
#line 104
  if ((unsigned int )marker != ((unsigned int )((83 | (111 << 8)) | (117 << 16)) | (110U << 24))) {
    {
#line 105
    psf_log_printf(psf, "Could not find \'%M\'\n", (unsigned int )((83 | (111 << 8)) | (117 << 16)) | (110U << 24));
    }
#line 106
    return (161);
  }
  {
#line 109
  psf_binheader_readf(psf, "m", & marker);
  }
#line 110
  if ((unsigned int )marker != ((unsigned int )((100 | (70 << 8)) | (105 << 16)) | (108U << 24))) {
    {
#line 111
    psf_log_printf(psf, "Could not find \'%M\'\n", (unsigned int )((100 | (70 << 8)) | (105 << 16)) | (108U << 24));
    }
#line 112
    return (161);
  }
  {
#line 115
  psf_binheader_readf(psf, "m", & marker);
  }
#line 116
  if ((unsigned int )marker != (unsigned int )((101 | (42 << 8)) | (42 << 16))) {
    {
#line 117
    psf_log_printf(psf, "Could not find \'%M\'\n", (unsigned int )((101 | (42 << 8)) | (42 << 16)));
    }
#line 118
    return (161);
  }
  {
#line 121
  psf_binheader_readf(psf, "E2", & version);
#line 123
  psf_log_printf(psf, "Psion Palmtop Alaw (.wve)\n  Sample Rate : 8000\n  Channels    : 1\n  Encoding    : A-law\n");
  }
#line 128
  if ((int )version != 3856) {
    {
#line 129
    psf_log_printf(psf, "Psion version %d should be %d\n", (int )version, 3856);
    }
  }
  {
#line 131
  psf_binheader_readf(psf, "E4", & datalength);
#line 132
  psf->dataoffset = (sf_count_t )32;
  }
#line 133
  if ((long )datalength != psf->filelength - psf->dataoffset) {
    {
#line 134
    psf->datalength = psf->filelength - psf->dataoffset;
#line 135
    psf_log_printf(psf, "Data length %d should be %D\n", datalength, psf->datalength);
    }
  } else {
#line 138
    psf->datalength = (sf_count_t )datalength;
  }
  {
#line 140
  psf_binheader_readf(psf, "E22222", & padding, & repeats, & trash, & trash, & trash);
#line 142
  psf->sf.format = 1638417;
#line 143
  psf->sf.samplerate = 8000;
#line 144
  psf->sf.frames = psf->datalength;
#line 145
  psf->sf.channels = 1;
  }
#line 147
  return (0);
}
}
#line 154 "/root/patchweave_new/23/src/wve.c"
static int wve_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  unsigned int datalen ;

  {
  {
#line 158
  current = psf_ftell(psf);
  }
#line 160
  if (calc_length) {
    {
#line 161
    psf->filelength = psf_get_filelen(psf);
#line 163
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 164
    if (psf->dataend) {
#line 165
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 167
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
  {
#line 171
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 172
  psf->header.indx = (sf_count_t )0;
#line 173
  psf_fseek(psf, (sf_count_t )0, 0);
#line 176
  datalen = (unsigned int )psf->datalength;
#line 177
  psf_binheader_writef(psf, "Emmmm", (unsigned int )((65 | (76 << 8)) | (97 << 16)) | (119U << 24),
                       (unsigned int )((83 | (111 << 8)) | (117 << 16)) | (110U << 24),
                       (unsigned int )((100 | (70 << 8)) | (105 << 16)) | (108U << 24),
                       (unsigned int )((101 | (42 << 8)) | (42 << 16)));
#line 178
  psf_binheader_writef(psf, "E2422222\251", 3856, datalen, 0, 0, 0, 0, 0);
#line 179
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 181
  if (psf->sf.channels != 1) {
#line 182
    return (34);
  }
#line 184
  if (psf->error) {
#line 185
    return (psf->error);
  }
#line 187
  psf->dataoffset = psf->header.indx;
#line 189
  if (current > 0L) {
    {
#line 190
    psf_fseek(psf, current, 0);
    }
  }
#line 192
  return (psf->error);
}
}
#line 199 "/root/patchweave_new/23/src/wve.c"
static int wve_close(SF_PRIVATE *psf ) 
{ 


  {
#line 201
  if (psf->file.mode == 32) {
    {
#line 205
    wve_write_header(psf, 1);
    }
  } else
#line 201
  if (psf->file.mode == 48) {
    {
#line 205
    wve_write_header(psf, 1);
    }
  }
#line 208
  return (0);
}
}
#line 72 "/root/patchweave_new/23/src/voc.c"
static int voc_close(SF_PRIVATE *psf ) ;
#line 73
static int voc_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 74
static int voc_read_header(SF_PRIVATE *psf ) ;
#line 76
static char const   *voc_encoding2str(int encoding ) ;
#line 104 "/root/patchweave_new/23/src/voc.c"
int voc_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;

  {
#line 105
  error = 0;
#line 107
  if (psf->is_pipe) {
#line 108
    return (120);
  }
#line 110
  if (psf->file.mode == 16) {
    _L: 
    {
#line 111
    error = voc_read_header(psf);
    }
#line 111
    if (error) {
#line 112
      return (error);
    }
  } else
#line 110
  if (psf->file.mode == 48) {
#line 110
    if (psf->filelength > 0L) {
#line 110
      goto _L;
    }
  }
#line 115
  subformat = psf->sf.format & 65535;
#line 117
  if (psf->file.mode == 32) {
    _L___22: 
#line 118
    if ((psf->sf.format & 268369920) != 524288) {
#line 119
      return (1);
    }
    {
#line 121
    psf->endian = 268435456;
#line 123
    error = voc_write_header(psf, 0);
    }
#line 123
    if (error) {
#line 124
      return (error);
    }
#line 126
    psf->write_header = & voc_write_header;
  } else
#line 117
  if (psf->file.mode == 48) {
#line 117
    goto _L___22;
  }
#line 129
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 131
  psf->container_close = & voc_close;
#line 135
  if (subformat == 2) {
#line 135
    goto case_2;
  }
#line 135
  if (subformat == 5) {
#line 135
    goto case_2;
  }
#line 139
  if (subformat == 17) {
#line 139
    goto case_17;
  }
#line 143
  if (subformat == 16) {
#line 143
    goto case_16;
  }
#line 147
  goto switch_default;
  case_2: 
  {
#line 136
  error = pcm_init(psf);
  }
#line 137
  goto switch_break;
  case_17: 
  {
#line 140
  error = alaw_init(psf);
  }
#line 141
  goto switch_break;
  case_16: 
  {
#line 144
  error = ulaw_init(psf);
  }
#line 145
  goto switch_break;
  switch_default: 
#line 147
  return (18);
  switch_break: ;
#line 150
  return (error);
}
}
#line 157 "/root/patchweave_new/23/src/voc.c"
static int voc_read_header(SF_PRIVATE *psf ) 
{ 
  VOC_DATA *pvoc ;
  char creative[20] ;
  unsigned char block_type ;
  unsigned char rate_byte ;
  short version ;
  short checksum ;
  short encoding ;
  short dataoffset ;
  int offset ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  char header[256] ;
  unsigned int size ;
  short count___0 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned char compression ;
  int size___0 ;
  int __cil_tmp25 ;
  unsigned char pack ;
  unsigned char stereo ;
  unsigned char compression___0 ;
  unsigned short rate_short ;
  int size___1 ;
  int __cil_tmp31 ;
  char const   *tmp ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  unsigned char bitwidth ;
  unsigned char channels ;
  int size___2 ;
  int fourbytes ;
  int __cil_tmp39 ;
  int temp_size ;
  char const   *__cil_tmp41 ;

  {
  {
#line 165
  offset = psf_binheader_readf(psf, "pb", 0, creative, (int )sizeof(creative));
  }
#line 167
  if ((int )creative[sizeof(creative) - 1UL] != 26) {
#line 168
    return (111);
  }
  {
#line 171
  creative[sizeof(creative) - 1UL] = (char)0;
#line 173
  __cil_tmp12 = strcmp("Creative Voice File", (char const   *)(creative));
  }
#line 173
  if (__cil_tmp12) {
#line 174
    return (111);
  }
  {
#line 176
  psf_log_printf(psf, "%s\n", creative);
#line 178
  __cil_tmp13 = psf_binheader_readf(psf, "e222\270U", & dataoffset, & version, & checksum);
#line 178
  offset += __cil_tmp13;
#line 180
  psf->dataoffset = (sf_count_t )dataoffset;
#line 182
  psf_log_printf(psf, "dataoffset : %d\nversion    : 0x%X\nchecksum   : 0x%X\n", psf->dataoffset,
                 (int )version, (int )checksum);
  }
#line 186
  if ((int )version != 266) {
#line 186
    if ((int )version != 276) {
#line 187
      return (113);
    }
  }
  {
#line 189
  psf->codec_data = malloc(sizeof(VOC_DATA ));
  }
#line 189
  if (! psf->codec_data) {
#line 190
    return (17);
  }
  {
#line 192
  pvoc = (VOC_DATA *)psf->codec_data;
#line 194
  memset((void *)pvoc, 0, sizeof(VOC_DATA ));
#line 197
  psf->sf.format = 524288;
#line 198
  encoding = (short)5;
#line 199
  psf->endian = 268435456;
  }
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 206
    block_type = (unsigned char)0;
#line 207
    __cil_tmp18 = psf_binheader_readf(psf, "1", & block_type);
#line 207
    offset += __cil_tmp18;
    }
#line 210
    if ((int )block_type == 5) {
#line 210
      goto case_5;
    }
#line 225
    if ((int )block_type == 6) {
#line 225
      goto case_6;
    }
#line 232
    if ((int )block_type == 9) {
#line 232
      goto case_9;
    }
#line 232
    if ((int )block_type == 8) {
#line 232
      goto case_9;
    }
#line 232
    if ((int )block_type == 1) {
#line 232
      goto case_9;
    }
#line 235
    goto switch_default;
    case_5: 
    {
#line 211
    __cil_tmp19 = psf_binheader_readf(psf, "e3", & size);
#line 211
    offset += __cil_tmp19;
#line 213
    psf_log_printf(psf, " ASCII : %d\n\270U", size);
    }
#line 215
    if ((unsigned long )size < sizeof(header) - 1UL) {
      {
#line 216
      __cil_tmp20 = psf_binheader_readf(psf, "bM\034F\270U", header, size);
#line 216
      offset += __cil_tmp20;
#line 217
      header[size] = (char)0;
#line 218
      psf_log_printf(psf, "  text : %s\n\270U", header);
      }
#line 219
      goto while_continue;
    }
    {
#line 222
    __cil_tmp21 = psf_binheader_readf(psf, "j", size);
#line 222
    offset += __cil_tmp21;
    }
#line 223
    goto while_continue;
    case_6: 
    {
#line 226
    __cil_tmp22 = psf_binheader_readf(psf, "e32", & size, & count___0);
#line 226
    offset += __cil_tmp22;
#line 227
    psf_log_printf(psf, " Repeat : %d\nU", (int )count___0);
    }
#line 228
    goto while_continue;
    case_9: 
#line 233
    goto switch_break;
    switch_default: 
    {
#line 235
    psf_log_printf(psf, "*** Weird block marker (%d)\n\270U", (int )block_type);
    }
    switch_break: ;
#line 238
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 241
  if ((int )block_type == 1) {
    {
#line 245
    __cil_tmp25 = psf_binheader_readf(psf, "e311\270U", & size___0, & rate_byte, & compression);
#line 245
    offset += __cil_tmp25;
#line 247
    psf->sf.samplerate = 1000000 / (256 - ((int )rate_byte & 255));
#line 249
    psf_log_printf(psf, " Sound Data : %d\n  sr   : %d => %dHz\n  comp : %d\n", size___0,
                   (int )rate_byte, psf->sf.samplerate, (int )compression);
    }
#line 252
    if ((long )((offset + size___0) - 1) > psf->filelength) {
      {
#line 253
      psf_log_printf(psf, "Seems to be a truncated file.\n");
#line 254
      psf_log_printf(psf, "offset: %d    size: %d    sum: %d    filelength: %D\n",
                     offset, size___0, offset + size___0, psf->filelength);
      }
#line 255
      return (115);
    } else
#line 257
    if ((psf->filelength - (long )offset) - (long )size___0 > 4L) {
      {
#line 258
      psf_log_printf(psf, "Seems to be a multi-segment file (#1).\n");
#line 259
      psf_log_printf(psf, "offset: %d    size: %d    sum: %d    filelength: %D\n",
                     offset, size___0, offset + size___0, psf->filelength);
      }
#line 260
      return (115);
    }
#line 263
    psf->dataoffset = (sf_count_t )offset;
#line 264
    psf->dataend = psf->filelength - 1L;
#line 266
    psf->sf.channels = 1;
#line 267
    psf->bytewidth = 1;
#line 269
    psf->sf.format = 524293;
#line 271
    return (0);
  }
#line 274
  if ((int )block_type == 8) {
    {
#line 279
    __cil_tmp31 = psf_binheader_readf(psf, "e3211", & size___1, & rate_short, & pack,
                                      & stereo);
#line 279
    offset += __cil_tmp31;
#line 281
    psf_log_printf(psf, " Extended : %d\n", size___1);
    }
#line 282
    if (size___1 == 4) {
      {
#line 283
      psf_log_printf(psf, "  size   : 4\n");
      }
    } else {
      {
#line 285
      psf_log_printf(psf, "  size   : %d (should be 4)\n", size___1);
      }
    }
#line 287
    if ((int )stereo) {
#line 287
      tmp = "yes";
    } else {
#line 287
      tmp = "no";
    }
    {
#line 287
    psf_log_printf(psf, "  pack   : %d\n  stereo : %s\n\230\001", (int )pack, tmp);
    }
#line 290
    if (stereo) {
#line 291
      psf->sf.channels = 2;
#line 292
      psf->sf.samplerate = 128000000 / (65536 - (int )rate_short);
    } else {
#line 295
      psf->sf.channels = 1;
#line 296
      psf->sf.samplerate = 256000000 / (65536 - (int )rate_short);
    }
    {
#line 299
    psf_log_printf(psf, "  sr     : %d => %dHz\n", (int )rate_short & 65535, psf->sf.samplerate);
#line 301
    __cil_tmp33 = psf_binheader_readf(psf, "1", & block_type);
#line 301
    offset += __cil_tmp33;
    }
#line 303
    if ((int )block_type != 1) {
      {
#line 304
      psf_log_printf(psf, "*** Expecting VOC_SOUND_DATA section.\n");
      }
#line 305
      return (112);
    }
    {
#line 308
    __cil_tmp34 = psf_binheader_readf(psf, "e311", & size___1, & rate_byte, & compression___0);
#line 308
    offset += __cil_tmp34;
#line 310
    psf_log_printf(psf, " Sound Data : %d\n  sr     : %d\n  comp   : %d\n", size___1,
                   (int )rate_byte, (int )compression___0);
    }
#line 315
    if ((long )((offset + size___1) - 1) > psf->filelength) {
      {
#line 316
      psf_log_printf(psf, "Seems to be a truncated file.\n");
#line 317
      psf_log_printf(psf, "offset: %d    size: %d    sum: %d    filelength: %D\n",
                     offset, size___1, offset + size___1, psf->filelength);
      }
#line 318
      return (115);
    } else
#line 320
    if ((long )((offset + size___1) - 1) < psf->filelength) {
      {
#line 321
      psf_log_printf(psf, "Seems to be a multi-segment file (#2).\n");
#line 322
      psf_log_printf(psf, "offset: %d    size: %d    sum: %d    filelength: %D\n",
                     offset, size___1, offset + size___1, psf->filelength);
      }
#line 323
      return (115);
    }
#line 326
    psf->dataoffset = (sf_count_t )offset;
#line 327
    psf->dataend = psf->filelength - 1L;
#line 329
    psf->bytewidth = 1;
#line 331
    psf->sf.format = 524293;
#line 333
    return (0);
  }
#line 336
  if ((int )block_type == 9) {
    {
#line 340
    __cil_tmp39 = psf_binheader_readf(psf, "e341124", & size___2, & psf->sf.samplerate,
                                      & bitwidth, & channels, & encoding, & fourbytes);
#line 340
    offset += __cil_tmp39;
    }
#line 343
    if ((long )(size___2 * 2) == psf->filelength - 39L) {
      {
#line 344
      temp_size = (int )(psf->filelength - 31L);
#line 346
      psf_log_printf(psf, " Extended II : %d (SoX bug: should be %d)\n", size___2,
                     temp_size);
#line 347
      size___2 = temp_size;
      }
    } else {
      {
#line 350
      psf_log_printf(psf, " Extended II : %d\n", size___2);
      }
    }
    {
#line 352
    psf_log_printf(psf, "  sample rate : %d\n  bit width   : %d\n  channels    : %d\n",
                   psf->sf.samplerate, (int )bitwidth, (int )channels);
    }
#line 356
    if ((int )bitwidth == 16) {
#line 356
      if ((int )encoding == 0) {
        {
#line 357
        encoding = (short)4;
#line 358
        psf_log_printf(psf, "  encoding    : 0 (SoX bug: should be 4 for 16 bit signed PCM)\n");
        }
      } else {
        {
#line 361
        __cil_tmp41 = voc_encoding2str((int )encoding);
#line 361
        psf_log_printf(psf, "  encoding    : %d => %s\n", (int )encoding, __cil_tmp41);
        }
      }
    } else {
      {
#line 361
      __cil_tmp41 = voc_encoding2str((int )encoding);
#line 361
      psf_log_printf(psf, "  encoding    : %d => %s\n", (int )encoding, __cil_tmp41);
      }
    }
    {
#line 364
    psf_log_printf(psf, "  fourbytes   : %X\n", fourbytes);
#line 366
    psf->sf.channels = (int )channels;
#line 368
    psf->dataoffset = (sf_count_t )offset;
#line 369
    psf->dataend = psf->filelength - 1L;
    }
#line 371
    if ((long )(size___2 + 31) == psf->filelength + 1L) {
      {
#line 375
      psf_log_printf(psf, "Missing zero byte at end of file.\n");
#line 376
      size___2 = (int )(psf->filelength - 30L);
#line 377
      psf->dataend = (sf_count_t )0;
      }
    } else
#line 379
    if ((long )(size___2 + 31) > psf->filelength) {
      {
#line 380
      psf_log_printf(psf, "Seems to be a truncated file.\n");
#line 381
      size___2 = (int )(psf->filelength - 31L);
      }
    } else
#line 383
    if ((long )(size___2 + 31) < psf->filelength) {
      {
#line 384
      psf_log_printf(psf, "Seems to be a multi-segment file (#3).\n");
      }
    }
#line 387
    if ((int )encoding == 0) {
#line 387
      goto case_0;
    }
#line 392
    if ((int )encoding == 4) {
#line 392
      goto case_4;
    }
#line 397
    if ((int )encoding == 6) {
#line 397
      goto case_6___0;
    }
#line 402
    if ((int )encoding == 7) {
#line 402
      goto case_7;
    }
#line 407
    goto switch_default___0;
    case_0: 
#line 388
    psf->sf.format = 524293;
#line 389
    psf->bytewidth = 1;
#line 390
    goto switch_break___0;
    case_4: 
#line 393
    psf->sf.format = 524290;
#line 394
    psf->bytewidth = 2;
#line 395
    goto switch_break___0;
    case_6___0: 
#line 398
    psf->sf.format = 524305;
#line 399
    psf->bytewidth = 1;
#line 400
    goto switch_break___0;
    case_7: 
#line 403
    psf->sf.format = 524304;
#line 404
    psf->bytewidth = 1;
#line 405
    goto switch_break___0;
    switch_default___0: 
#line 408
    return (21);
#line 409
    goto switch_break___0;
    switch_break___0: ;
  }
#line 414
  return (0);
}
}
#line 421 "/root/patchweave_new/23/src/voc.c"
static int voc_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int rate_const ;
  int subformat ;
  size_t __cil_tmp8 ;
  int length ;

  {
  {
#line 425
  current = psf_ftell(psf);
  }
#line 427
  if (calc_length) {
    {
#line 428
    psf->filelength = psf_get_filelen(psf);
#line 430
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 431
    if (psf->dataend) {
#line 432
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 434
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
  {
#line 437
  subformat = psf->sf.format & 65535;
#line 439
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 440
  psf->header.indx = (sf_count_t )0;
#line 441
  psf_fseek(psf, (sf_count_t )0, 0);
#line 444
  __cil_tmp8 = make_size_t(19);
#line 444
  psf_binheader_writef(psf, "eb1", "Creative Voice FileF\270U", __cil_tmp8, 26);
#line 447
  psf_binheader_writef(psf, "e222\270U", 26, 276, 4383);
  }
#line 455
  if (subformat == 5) {
#line 455
    if (psf->sf.channels == 1) {
      {
#line 457
      rate_const = 256 - 1000000 / psf->sf.samplerate;
#line 460
      psf_binheader_writef(psf, "e1311", 1, (int )(psf->datalength + 1L), rate_const,
                           0);
      }
    } else {
#line 455
      goto _L___23;
    }
  } else
  _L___23: 
#line 462
  if (subformat == 5) {
#line 462
    if (psf->sf.channels == 2) {
      {
#line 464
      rate_const = 65536 - 128000000 / psf->sf.samplerate;
#line 469
      psf_binheader_writef(psf, "e13211", 8, 4, rate_const, 0, 1);
#line 472
      rate_const = 256 - 1000000 / psf->sf.samplerate;
#line 477
      psf_binheader_writef(psf, "e1311", 1, (int )(psf->datalength + 1L), rate_const,
                           0);
      }
    } else {
#line 462
      goto _L;
    }
  } else {
    _L: 
#line 482
    if (psf->sf.channels < 1) {
#line 483
      return (34);
    } else
#line 482
    if (psf->sf.channels > 2) {
#line 483
      return (34);
    }
#line 486
    if (subformat == 5) {
#line 486
      goto case_5;
    }
#line 493
    if (subformat == 2) {
#line 493
      goto case_2;
    }
#line 500
    if (subformat == 17) {
#line 500
      goto case_17;
    }
#line 506
    if (subformat == 16) {
#line 506
      goto case_16;
    }
#line 512
    goto switch_default;
    case_5: 
    {
#line 487
    psf->bytewidth = 1;
#line 488
    length = (int )((psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth + 12L);
#line 490
    psf_binheader_writef(psf, "e1341124\230", 9, length, psf->sf.samplerate, 16, psf->sf.channels,
                         4, 0);
    }
#line 491
    goto switch_break;
    case_2: 
    {
#line 494
    psf->bytewidth = 2;
#line 495
    length = (int )((psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth + 12L);
#line 497
    psf_binheader_writef(psf, "e1341124\230", 9, length, psf->sf.samplerate, 16, psf->sf.channels,
                         4, 0);
    }
#line 498
    goto switch_break;
    case_17: 
    {
#line 501
    psf->bytewidth = 1;
#line 502
    length = (int )((psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth + 12L);
#line 503
    psf_binheader_writef(psf, "e1341124\230", 9, length, psf->sf.samplerate, 8, psf->sf.channels,
                         6, 0);
    }
#line 504
    goto switch_break;
    case_16: 
    {
#line 507
    psf->bytewidth = 1;
#line 508
    length = (int )((psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth + 12L);
#line 509
    psf_binheader_writef(psf, "e1341124\230", 9, length, psf->sf.samplerate, 8, psf->sf.channels,
                         7, 0);
    }
#line 510
    goto switch_break;
    switch_default: 
#line 512
    return (18);
    switch_break: ;
  }
  {
#line 516
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 518
  if (psf->error) {
#line 519
    return (psf->error);
  }
#line 521
  psf->dataoffset = psf->header.indx;
#line 523
  if (current > 0L) {
    {
#line 524
    psf_fseek(psf, current, 0);
    }
  }
#line 526
  return (psf->error);
}
}
#line 530 "/root/patchweave_new/23/src/voc.c"
static int voc_close(SF_PRIVATE *psf ) 
{ 
  unsigned char byte ;

  {
#line 532
  if (psf->file.mode == 32) {
    {
#line 536
    byte = (unsigned char)0;
#line 539
    psf_fseek(psf, (sf_count_t )0, 2);
#line 542
    psf_fwrite((void const   *)(& byte), (sf_count_t )1, (sf_count_t )1, psf);
#line 544
    voc_write_header(psf, 1);
    }
  } else
#line 532
  if (psf->file.mode == 48) {
    {
#line 536
    byte = (unsigned char)0;
#line 539
    psf_fseek(psf, (sf_count_t )0, 2);
#line 542
    psf_fwrite((void const   *)(& byte), (sf_count_t )1, (sf_count_t )1, psf);
#line 544
    voc_write_header(psf, 1);
    }
  }
#line 547
  return (0);
}
}
#line 551 "/root/patchweave_new/23/src/voc.c"
static char const   *voc_encoding2str(int encoding ) 
{ 


  {
#line 554
  if (encoding == 0) {
#line 554
    goto case_0;
  }
#line 555
  if (encoding == 4) {
#line 555
    goto case_4;
  }
#line 556
  if (encoding == 6) {
#line 556
    goto case_6;
  }
#line 557
  if (encoding == 7) {
#line 557
    goto case_7;
  }
#line 558
  goto switch_default;
  case_0: 
#line 554
  return ("8 bit unsigned PCM");
  case_4: 
#line 555
  return ("16 bit signed PCM");
  case_6: 
#line 556
  return ("A-law");
  case_7: 
#line 557
  return ("u-law");
  switch_default: 
#line 558
  goto switch_break;
  switch_break: ;
#line 560
  return ("*** Unknown ***");
}
}
#line 40 "/root/patchweave_new/23/src/txw.c"
int txw_open(SF_PRIVATE *psf ) 
{ 


  {
#line 41
  if (psf) {
#line 42
    return (18);
  }
#line 43
  return (0);
}
}
#line 73 "/root/patchweave_new/23/src/svx.c"
static int svx_close(SF_PRIVATE *psf ) ;
#line 74
static int svx_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 75
static int svx_read_header(SF_PRIVATE *psf ) ;
#line 82 "/root/patchweave_new/23/src/svx.c"
int svx_open(SF_PRIVATE *psf ) 
{ 
  int error ;

  {
#line 85
  if (psf->file.mode == 16) {
    _L: 
    {
#line 86
    error = svx_read_header(psf);
    }
#line 86
    if (error) {
#line 87
      return (error);
    }
#line 89
    psf->endian = 536870912;
#line 91
    psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 92
    if (psf->blockwidth) {
#line 93
      psf->sf.frames = psf->datalength / (long )psf->blockwidth;
    }
    {
#line 95
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 85
  if (psf->file.mode == 48) {
#line 85
    if (psf->filelength > 0L) {
#line 85
      goto _L;
    }
  }
#line 98
  if (psf->file.mode == 32) {
    _L___24: 
#line 99
    if (psf->is_pipe) {
#line 100
      return (29);
    }
#line 102
    if ((psf->sf.format & 268369920) != 393216) {
#line 103
      return (1);
    }
#line 105
    psf->endian = psf->sf.format & 805306368;
#line 107
    if (psf->endian == 268435456) {
#line 108
      return (32);
    } else
#line 107
    if (psf->endian == 805306368) {
#line 108
      return (32);
    }
    {
#line 110
    psf->endian = 536870912;
#line 112
    error = svx_write_header(psf, 0);
    }
#line 113
    if (error) {
#line 114
      return (error);
    }
#line 116
    psf->write_header = & svx_write_header;
  } else
#line 98
  if (psf->file.mode == 48) {
#line 98
    goto _L___24;
  }
  {
#line 119
  psf->container_close = & svx_close;
#line 121
  error = pcm_init(psf);
  }
#line 121
  if (error) {
#line 122
    return (error);
  }
#line 124
  return (0);
}
}
#line 131 "/root/patchweave_new/23/src/svx.c"
static int svx_read_header(SF_PRIVATE *psf ) 
{ 
  VHDR_CHUNK vhdr ;
  uint32_t chunk_size ;
  uint32_t marker ;
  int filetype ;
  int parsestage ;
  int done ;
  int bytecount ;
  int channels ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  sf_count_t __cil_tmp18 ;
  sf_count_t __cil_tmp19 ;
  sf_count_t __cil_tmp20 ;

  {
#line 134
  filetype = 0;
#line 134
  parsestage = 0;
#line 134
  done = 0;
#line 135
  bytecount = 0;
#line 137
  if (psf->filelength > 4294967295L) {
    {
#line 138
    psf_log_printf(psf, "Warning : filelength > 0xffffffff. This is bad!!!!\n");
    }
  }
  {
#line 140
  memset((void *)(& vhdr), 0, sizeof(vhdr));
#line 141
  psf_binheader_readf(psf, "p", 0);
#line 144
  psf->sf.channels = 1;
#line 146
  psf->sf.format = 393216;
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;

#line 148
    if (! (! done)) {
#line 148
      goto while_break;
    }
    {
#line 149
    psf_binheader_readf(psf, "Em4", & marker, & chunk_size);
    }
#line 152
    if (marker == ((unsigned int )((70 | (79 << 8)) | (82 << 16)) | (77U << 24))) {
#line 152
      goto case_exp;
    }
#line 169
    if (marker == ((unsigned int )((86 | (72 << 8)) | (68 << 16)) | (82U << 24))) {
#line 169
      goto case_exp___0;
    }
#line 188
    if (marker == 0U) {
#line 188
      goto case_0;
    }
#line 190
    if (marker == 1U) {
#line 190
      goto case_1;
    }
#line 192
    if (marker == 2U) {
#line 192
      goto case_2;
    }
#line 212
    if (marker == ((unsigned int )((66 | (79 << 8)) | (68 << 16)) | (89U << 24))) {
#line 212
      goto case_exp___1;
    }
#line 237
    if (marker == ((unsigned int )((78 | (65 << 8)) | (77 << 16)) | (69U << 24))) {
#line 237
      goto case_exp___2;
    }
#line 254
    if (marker == ((unsigned int )((65 | (78 << 8)) | (78 << 16)) | (79U << 24))) {
#line 254
      goto case_exp___3;
    }
#line 263
    if (marker == ((unsigned int )((67 | (72 << 8)) | (65 << 16)) | (78U << 24))) {
#line 263
      goto case_exp___4;
    }
#line 285
    if (marker == ((unsigned int )((40 | (99 << 8)) | (41 << 16)) | (32U << 24))) {
#line 285
      goto case_exp___5;
    }
#line 285
    if (marker == ((unsigned int )((65 | (85 << 8)) | (84 << 16)) | (72U << 24))) {
#line 285
      goto case_exp___5;
    }
#line 294
    goto switch_default;
    case_exp: 
#line 153
    if (parsestage) {
#line 154
      return (103);
    }
#line 156
    if ((unsigned long )chunk_size != (unsigned long )psf->filelength - 2UL * sizeof(chunk_size)) {
      {
#line 157
      psf_log_printf(psf, "FORM : %u (should be %u)\n\323VF\270U", chunk_size, (unsigned long )((uint32_t )psf->filelength) - 2UL * sizeof(chunk_size));
      }
    } else {
      {
#line 159
      psf_log_printf(psf, "FORM : %u\n", chunk_size);
      }
    }
    {
#line 160
    parsestage |= 1;
#line 162
    psf_binheader_readf(psf, "m\361VF\270U", & marker);
#line 164
    filetype = (int )marker;
#line 165
    psf_log_printf(psf, " %M\n\270U", marker);
#line 166
    parsestage |= 2;
    }
#line 167
    goto switch_break;
    case_exp___0: 
#line 170
    if (! (parsestage & 3)) {
#line 171
      return (103);
    }
    {
#line 173
    psf_log_printf(psf, " VHDR : %d\n", chunk_size);
#line 175
    psf_binheader_readf(psf, "E4442114\230\001", & vhdr.oneShotHiSamples, & vhdr.repeatHiSamples,
                        & vhdr.samplesPerHiCycle, & vhdr.samplesPerSec, & vhdr.octave,
                        & vhdr.compression, & vhdr.volume);
#line 179
    psf_log_printf(psf, "  OneShotHiSamples  : %d\n", vhdr.oneShotHiSamples);
#line 180
    psf_log_printf(psf, "  RepeatHiSamples   : %d\n", vhdr.repeatHiSamples);
#line 181
    psf_log_printf(psf, "  samplesPerHiCycle : %d\n\377VF\270U", vhdr.samplesPerHiCycle);
#line 182
    psf_log_printf(psf, "  Sample Rate       : %d\n\233VF\270U", (int )vhdr.samplesPerSec);
#line 183
    psf_log_printf(psf, "  Octave            : %d\n", (int )vhdr.octave);
#line 185
    psf_log_printf(psf, "  Compression       : %d => \270U", (int )vhdr.compression);
    }
#line 188
    if ((int )vhdr.compression == 0) {
#line 188
      goto case_0;
    }
#line 190
    if ((int )vhdr.compression == 1) {
#line 190
      goto case_1;
    }
#line 192
    if ((int )vhdr.compression == 2) {
#line 192
      goto case_2;
    }
#line 187
    goto switch_break___0;
    case_0: 
    {
#line 188
    psf_log_printf(psf, "None.\n");
    }
#line 189
    goto switch_break___0;
    case_1: 
    {
#line 190
    psf_log_printf(psf, "Fibonacci delta\n\220");
    }
#line 191
    goto switch_break___0;
    case_2: 
    {
#line 192
    psf_log_printf(psf, "Exponential delta\nWF\270U");
    }
#line 193
    goto switch_break___0;
    switch_break___0: 
    {
#line 196
    psf_log_printf(psf, "  Volume            : %d\n", vhdr.volume);
#line 198
    psf->sf.samplerate = (int )vhdr.samplesPerSec;
    }
#line 200
    if ((unsigned int )filetype == ((unsigned int )((56 | (83 << 8)) | (86 << 16)) | (88U << 24))) {
#line 201
      psf->sf.format |= 1;
#line 202
      psf->bytewidth = 1;
    } else
#line 204
    if ((unsigned int )filetype == ((unsigned int )((49 | (54 << 8)) | (83 << 16)) | (86U << 24))) {
#line 205
      psf->sf.format |= 2;
#line 206
      psf->bytewidth = 2;
    }
#line 209
    parsestage |= 4;
#line 210
    goto switch_break;
    case_exp___1: 
#line 213
    if (! (parsestage & 4)) {
#line 214
      return (104);
    }
    {
#line 216
    psf->datalength = (sf_count_t )chunk_size;
#line 218
    psf->dataoffset = psf_ftell(psf);
    }
#line 219
    if (psf->dataoffset < 0L) {
#line 220
      return (104);
    }
#line 222
    if (psf->datalength > psf->filelength - psf->dataoffset) {
      {
#line 223
      psf_log_printf(psf, " BODY : %D (should be %D)\n", psf->datalength, psf->filelength - psf->dataoffset);
#line 224
      psf->datalength = psf->filelength - psf->dataoffset;
      }
    } else {
      {
#line 227
      psf_log_printf(psf, " BODY : %D\n", psf->datalength);
      }
    }
#line 229
    parsestage |= 8;
#line 231
    if (! psf->sf.seekable) {
#line 232
      goto switch_break;
    }
    {
#line 234
    psf_fseek(psf, psf->datalength, 1);
    }
#line 235
    goto switch_break;
    case_exp___2: 
#line 238
    if (! (parsestage & 2)) {
#line 239
      return (103);
    }
    {
#line 241
    psf_log_printf(psf, " %M : %u\n", marker, chunk_size);
#line 243
    __cil_tmp11 = strlen((char const   *)(psf->file.name.c));
    }
#line 243
    if (__cil_tmp11 != (unsigned long )chunk_size) {
#line 244
      if ((unsigned long )chunk_size > sizeof(psf->file.name.c) - 1UL) {
#line 245
        return (107);
      }
      {
#line 247
      psf_binheader_readf(psf, "b", psf->file.name.c, chunk_size);
#line 248
      psf->file.name.c[chunk_size] = (char)0;
      }
    } else {
      {
#line 251
      psf_binheader_readf(psf, "j", chunk_size);
      }
    }
#line 252
    goto switch_break;
    case_exp___3: 
#line 255
    if (! (parsestage & 2)) {
#line 256
      return (103);
    }
    {
#line 258
    psf_log_printf(psf, " %M : %u\n", marker, chunk_size);
#line 260
    psf_binheader_readf(psf, "j", chunk_size);
    }
#line 261
    goto switch_break;
    case_exp___4: 
#line 264
    if (! (parsestage & 2)) {
#line 265
      return (103);
    }
    {
#line 267
    psf_log_printf(psf, " %M : %u\n", marker, chunk_size);
#line 269
    __cil_tmp12 = psf_binheader_readf(psf, "E4", & channels);
#line 269
    bytecount += __cil_tmp12;
    }
#line 271
    if (channels == 2) {
      {
#line 272
      psf_log_printf(psf, "  Channels : %d => mono\n\230\001", channels);
      }
    } else
#line 271
    if (channels == 4) {
      {
#line 272
      psf_log_printf(psf, "  Channels : %d => mono\n\230\001", channels);
      }
    } else
#line 273
    if (channels == 6) {
      {
#line 274
      psf->sf.channels = 2;
#line 275
      psf_log_printf(psf, "  Channels : %d => stereo\n", channels);
      }
    } else {
      {
#line 278
      psf_log_printf(psf, "  Channels : %d *** assuming mono\n", channels);
      }
    }
    {
#line 280
    psf_binheader_readf(psf, "j", chunk_size - (unsigned int )bytecount);
    }
#line 281
    goto switch_break;
    case_exp___5: 
#line 286
    if (! (parsestage & 2)) {
#line 287
      return (103);
    }
    {
#line 289
    psf_log_printf(psf, " %M : %u\n", marker, chunk_size);
#line 291
    psf_binheader_readf(psf, "j", chunk_size);
    }
#line 292
    goto switch_break;
    switch_default: 
#line 295
    if (chunk_size >= 4294901760U) {
      {
#line 296
      done = 1;
#line 297
      __cil_tmp13 = psf_ftell(psf);
#line 297
      psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D with length %u. Exiting parser.\n",
                     marker, __cil_tmp13 - 8L, chunk_size);
      }
#line 298
      goto switch_break;
    }
    {
#line 301
    __cil_tmp17 = psf_isprint((int )(marker & 255U));
#line 301
    __cil_tmp16 = psf_isprint((int )((marker >> 8) & 255U));
#line 301
    __cil_tmp15 = psf_isprint((int )((marker >> 16) & 255U));
#line 301
    __cil_tmp14 = psf_isprint((int )((marker >> 24) & 255U));
    }
#line 301
    if (__cil_tmp14) {
#line 301
      if (__cil_tmp15) {
#line 301
        if (__cil_tmp16) {
#line 301
          if (__cil_tmp17) {
            {
#line 303
            psf_log_printf(psf, "%M : %u (unknown marker)\n", marker, chunk_size);
#line 304
            psf_binheader_readf(psf, "j", chunk_size);
            }
#line 305
            goto switch_break;
          }
        }
      }
    }
    {
#line 307
    __cil_tmp18 = psf_ftell(psf);
#line 307
    chunk_size = (uint32_t )__cil_tmp18;
    }
#line 307
    if (chunk_size & 3U) {
      {
#line 308
      psf_log_printf(psf, "  Unknown chunk marker at position %d. Resynching.\n",
                     chunk_size - 4U);
#line 310
      psf_binheader_readf(psf, "j", -3);
      }
#line 311
      goto switch_break;
    }
    {
#line 313
    __cil_tmp19 = psf_ftell(psf);
#line 313
    psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D. Exiting parser.\n",
                   marker, __cil_tmp19 - 8L);
#line 314
    done = 1;
    }
    switch_break: ;
#line 317
    if (! psf->sf.seekable) {
#line 317
      if (parsestage & 8) {
#line 318
        goto while_break;
      }
    }
    {
#line 320
    __cil_tmp20 = psf_ftell(psf);
    }
#line 320
    if (__cil_tmp20 >= psf->filelength - (long )((int )sizeof(chunk_size))) {
#line 321
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 324
  if (vhdr.compression) {
#line 325
    return (106);
  }
#line 327
  if (psf->dataoffset <= 0L) {
#line 328
    return (105);
  }
#line 330
  return (0);
}
}
#line 334 "/root/patchweave_new/23/src/svx.c"
static int svx_close(SF_PRIVATE *psf ) 
{ 


  {
#line 336
  if (psf->file.mode == 32) {
    {
#line 337
    svx_write_header(psf, 1);
    }
  } else
#line 336
  if (psf->file.mode == 48) {
    {
#line 337
    svx_write_header(psf, 1);
    }
  }
#line 339
  return (0);
}
}
#line 345 "/root/patchweave_new/23/src/svx.c"
static char annotation[37]  ;
#line 343 "/root/patchweave_new/23/src/svx.c"
static int svx_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  long tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 344
  strcpy(annotation, "libsndfile by Erik de Castro Lopo");
#line 347
  current = psf_ftell(psf);
  }
#line 349
  if (calc_length) {
    {
#line 350
    psf->filelength = psf_get_filelen(psf);
#line 352
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 354
    if (psf->dataend) {
#line 355
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 357
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
  {
#line 360
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 361
  psf->header.indx = (sf_count_t )0;
#line 362
  psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 365
  if (psf->filelength < 8L) {
#line 365
    tmp = 0L;
  } else {
#line 365
    tmp = psf->filelength - 8L;
  }
  {
#line 365
  psf_binheader_writef(psf, "Etm8\270U", (unsigned int )((70 | (79 << 8)) | (82 << 16)) | (77U << 24),
                       tmp);
  }
#line 368
  if (psf->bytewidth == 1) {
#line 368
    tmp___0 = (unsigned int )((56 | (83 << 8)) | (86 << 16)) | (88U << 24);
  } else {
#line 368
    tmp___0 = (unsigned int )((49 | (54 << 8)) | (83 << 16)) | (86U << 24);
  }
  {
#line 368
  psf_binheader_writef(psf, "m", tmp___0);
#line 371
  psf_binheader_writef(psf, "Em4", (unsigned int )((86 | (72 << 8)) | (68 << 16)) | (82U << 24),
                       sizeof(VHDR_CHUNK ));
#line 373
  psf_binheader_writef(psf, "E444\270U", psf->sf.frames, 0, 0);
#line 375
  psf_binheader_writef(psf, "E211\270U", psf->sf.samplerate, 1, 0);
  }
#line 377
  if (psf->bytewidth == 1) {
#line 377
    tmp___1 = 255;
  } else {
#line 377
    tmp___1 = 65535;
  }
  {
#line 377
  psf_binheader_writef(psf, "E4WF\270U", tmp___1);
  }
#line 379
  if (psf->sf.channels == 2) {
    {
#line 380
    psf_binheader_writef(psf, "Em44\270U", (unsigned int )((67 | (72 << 8)) | (65 << 16)) | (78U << 24),
                         4, 6);
    }
  }
  {
#line 383
  psf_binheader_writef(psf, "Emsms", (unsigned int )((78 | (65 << 8)) | (77 << 16)) | (69U << 24),
                       psf->file.name.c, (unsigned int )((65 | (78 << 8)) | (78 << 16)) | (79U << 24),
                       annotation);
  }
#line 386
  if (psf->datalength < 0L) {
#line 386
    tmp___2 = 0L;
  } else {
#line 386
    tmp___2 = psf->datalength;
  }
  {
#line 386
  psf_binheader_writef(psf, "Etm8\270U", (unsigned int )((66 | (79 << 8)) | (68 << 16)) | (89U << 24),
                       tmp___2);
#line 389
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 391
  if (psf->error) {
#line 392
    return (psf->error);
  }
#line 394
  psf->dataoffset = psf->header.indx;
#line 396
  if (current > 0L) {
    {
#line 397
    psf_fseek(psf, current, 0);
    }
  }
#line 399
  return (psf->error);
}
}
#line 68 "/root/patchweave_new/23/src/sds.c"
static int sds_close(SF_PRIVATE *psf ) ;
#line 70
static int sds_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 71
static int sds_read_header(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 73
static int sds_init(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 75
static sf_count_t sds_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 76
static sf_count_t sds_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 77
static sf_count_t sds_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 78
static sf_count_t sds_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 80
static sf_count_t sds_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 81
static sf_count_t sds_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 82
static sf_count_t sds_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 83
static sf_count_t sds_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 85
static sf_count_t sds_seek(SF_PRIVATE *psf , int mode , sf_count_t seek_from_start ) ;
#line 86
static int sds_byterate(SF_PRIVATE *psf ) ;
#line 88
static int sds_2byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 89
static int sds_3byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 90
static int sds_4byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 92
static int sds_read(SF_PRIVATE *psf , SDS_PRIVATE *psds , int *ptr , int len ) ;
#line 94
static int sds_2byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 95
static int sds_3byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 96
static int sds_4byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 98
static int sds_write(SF_PRIVATE *psf , SDS_PRIVATE *psds , int const   *ptr , int len ) ;
#line 105 "/root/patchweave_new/23/src/sds.c"
int sds_open(SF_PRIVATE *psf ) 
{ 
  SDS_PRIVATE *psds ;
  int error ;
  int __cil_tmp6 ;
  void *tmp ;

  {
  {
#line 107
  error = 0;
#line 110
  psf->sf.frames = (sf_count_t )0;
#line 112
  tmp = calloc(1UL, sizeof(SDS_PRIVATE ));
#line 112
  psds = (SDS_PRIVATE *)tmp;
  }
#line 112
  if (! psds) {
#line 113
    return (17);
  }
#line 114
  psf->codec_data = (void *)psds;
#line 116
  if (psf->file.mode == 16) {
    _L: 
    {
#line 117
    error = sds_read_header(psf, psds);
    }
#line 117
    if (error) {
#line 118
      return (error);
    }
  } else
#line 116
  if (psf->file.mode == 48) {
#line 116
    if (psf->filelength > 0L) {
#line 116
      goto _L;
    }
  }
#line 121
  if ((psf->sf.format & 268369920) != 1114112) {
#line 122
    return (1);
  }
#line 124
  if (psf->file.mode == 32) {
    _L___25: 
    {
#line 125
    __cil_tmp6 = sds_write_header(psf, 0);
    }
#line 125
    if (__cil_tmp6) {
#line 126
      return (psf->error);
    }
    {
#line 128
    psf->write_header = & sds_write_header;
#line 130
    psf_fseek(psf, (sf_count_t )21, 0);
    }
  } else
#line 124
  if (psf->file.mode == 48) {
#line 124
    goto _L___25;
  }
  {
#line 133
  error = sds_init(psf, psds);
  }
#line 133
  if (error != 0) {
#line 134
    return (error);
  }
#line 136
  psf->container_close = & sds_close;
#line 137
  psf->seek = & sds_seek;
#line 138
  psf->byterate = & sds_byterate;
#line 140
  psf->blockwidth = 0;
#line 142
  return (error);
}
}
#line 149 "/root/patchweave_new/23/src/sds.c"
static int sds_close(SF_PRIVATE *psf ) 
{ 
  SDS_PRIVATE *psds ;

  {
#line 151
  if (psf->file.mode == 32) {
    _L: 
#line 154
    psds = (SDS_PRIVATE *)psf->codec_data;
#line 154
    if ((unsigned long )psds == (unsigned long )((void *)0)) {
      {
#line 155
      psf_log_printf(psf, "*** Bad psf->codec_data ptr.\n");
      }
#line 156
      return (30);
    }
#line 159
    if (psds->write_count > 0) {
      {
#line 160
      memset((void *)(& psds->write_data[psds->write_count]), 0, (unsigned long )(psds->samplesperblock - psds->write_count) * sizeof(int ));
#line 161
      (*(psds->writer))(psf, psds);
      }
    }
    {
#line 164
    sds_write_header(psf, 1);
    }
  } else
#line 151
  if (psf->file.mode == 48) {
#line 151
    goto _L;
  }
#line 167
  return (0);
}
}
#line 171 "/root/patchweave_new/23/src/sds.c"
static int sds_init(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 


  {
#line 173
  if (psds->bitwidth < 8) {
#line 174
    psf->error = 146;
#line 174
    return (psf->error);
  } else
#line 173
  if (psds->bitwidth > 28) {
#line 174
    psf->error = 146;
#line 174
    return (psf->error);
  }
#line 176
  if (psds->bitwidth < 14) {
#line 177
    psds->reader = & sds_2byte_read;
#line 178
    psds->writer = & sds_2byte_write;
#line 179
    psds->samplesperblock = 60;
  } else
#line 181
  if (psds->bitwidth < 21) {
#line 182
    psds->reader = & sds_3byte_read;
#line 183
    psds->writer = & sds_3byte_write;
#line 184
    psds->samplesperblock = 40;
  } else {
#line 187
    psds->reader = & sds_4byte_read;
#line 188
    psds->writer = & sds_4byte_write;
#line 189
    psds->samplesperblock = 30;
  }
#line 192
  if (psf->file.mode == 16) {
    {
#line 193
    psf->read_short = & sds_read_s;
#line 194
    psf->read_int = & sds_read_i;
#line 195
    psf->read_float = & sds_read_f;
#line 196
    psf->read_double = & sds_read_d;
#line 199
    (*(psds->reader))(psf, psds);
    }
  } else
#line 192
  if (psf->file.mode == 48) {
    {
#line 193
    psf->read_short = & sds_read_s;
#line 194
    psf->read_int = & sds_read_i;
#line 195
    psf->read_float = & sds_read_f;
#line 196
    psf->read_double = & sds_read_d;
#line 199
    (*(psds->reader))(psf, psds);
    }
  }
#line 202
  if (psf->file.mode == 32) {
#line 203
    psf->write_short = & sds_write_s;
#line 204
    psf->write_int = & sds_write_i;
#line 205
    psf->write_float = & sds_write_f;
#line 206
    psf->write_double = & sds_write_d;
  } else
#line 202
  if (psf->file.mode == 48) {
#line 203
    psf->write_short = & sds_write_s;
#line 204
    psf->write_int = & sds_write_i;
#line 205
    psf->write_float = & sds_write_f;
#line 206
    psf->write_double = & sds_write_d;
  }
#line 209
  return (0);
}
}
#line 213 "/root/patchweave_new/23/src/sds.c"
static int sds_read_header(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char channel ;
  unsigned char bitwidth ;
  unsigned char loop_type ;
  unsigned char byte ;
  unsigned short sample_no ;
  unsigned short marker ;
  unsigned int samp_period ;
  unsigned int data_length ;
  unsigned int sustain_loop_start ;
  unsigned int sustain_loop_end ;
  int bytesread ;
  int blockcount ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  sf_count_t __cil_tmp20 ;

  {
  {
#line 220
  bytesread = psf_binheader_readf(psf, "pE211", 0, & marker, & channel, & byte);
  }
#line 222
  if ((int )marker != 61566) {
#line 223
    return (145);
  } else
#line 222
  if ((int )byte != 1) {
#line 223
    return (145);
  }
  {
#line 225
  __cil_tmp16 = psf_binheader_readf(psf, "e2", & sample_no);
#line 225
  bytesread += __cil_tmp16;
#line 226
  sample_no = (unsigned short )((((int )sample_no & 127) | (((int )sample_no & 32512) >> 1)) | (((int )sample_no & 8323072) >> 2));
#line 228
  psf_log_printf(psf, "Midi Sample Dump Standard (.sds)\nF07E\n Midi Channel  : %d\n Sample Number : %d\n",
                 (int )channel, (int )sample_no);
#line 232
  __cil_tmp17 = psf_binheader_readf(psf, "e13", & bitwidth, & samp_period);
#line 232
  bytesread += __cil_tmp17;
#line 234
  samp_period = ((samp_period & 127U) | ((samp_period & 32512U) >> 1)) | ((samp_period & 8323072U) >> 2);
#line 236
  psds->bitwidth = (int )bitwidth;
  }
#line 238
  if (psds->bitwidth > 1) {
    {
#line 239
    psf_log_printf(psf, " Bit Width     : %d\n", psds->bitwidth);
    }
  } else {
    {
#line 241
    psf_log_printf(psf, " Bit Width     : %d (should be > 1)\n", psds->bitwidth);
    }
#line 242
    return (146);
  }
#line 245
  if (samp_period > 0U) {
    {
#line 246
    psf->sf.samplerate = (int )(1000000000U / samp_period);
#line 248
    psf_log_printf(psf, " Sample Period : %d\n Sample Rate   : %d\n", samp_period,
                   psf->sf.samplerate);
    }
  } else {
    {
#line 253
    psf->sf.samplerate = 16000;
#line 255
    psf_log_printf(psf, " Sample Period : %d (should be > 0)\n Sample Rate   : %d (guessed)\n",
                   samp_period, psf->sf.samplerate);
    }
  }
  {
#line 260
  __cil_tmp18 = psf_binheader_readf(psf, "e3331", & data_length, & sustain_loop_start,
                                    & sustain_loop_end, & loop_type);
#line 260
  bytesread += __cil_tmp18;
#line 262
  data_length = ((data_length & 127U) | ((data_length & 32512U) >> 1)) | ((data_length & 8323072U) >> 2);
#line 264
  psds->frames = (int )data_length;
#line 264
  psf->sf.frames = (sf_count_t )psds->frames;
#line 266
  sustain_loop_start = ((sustain_loop_start & 127U) | ((sustain_loop_start & 32512U) >> 1)) | ((sustain_loop_start & 8323072U) >> 2);
#line 267
  sustain_loop_end = ((sustain_loop_end & 127U) | ((sustain_loop_end & 32512U) >> 1)) | ((sustain_loop_end & 8323072U) >> 2);
#line 269
  psf_log_printf(psf, " Sustain Loop\n     Start     : %d\n     End       : %d\n     Loop Type : %d\n",
                 sustain_loop_start, sustain_loop_end, (int )loop_type);
#line 275
  psf->dataoffset = (sf_count_t )21;
#line 276
  psf->datalength = psf->filelength - psf->dataoffset;
#line 278
  __cil_tmp19 = psf_binheader_readf(psf, "1%\206F\270U", & byte);
#line 278
  bytesread += __cil_tmp19;
  }
#line 279
  if ((int )byte != 247) {
    {
#line 280
    psf_log_printf(psf, "bad end : %X\nU", (int )byte & 255);
    }
  }
#line 282
  blockcount = 0;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;

#line 282
    if (! ((long )bytesread < psf->filelength)) {
#line 282
      goto while_break;
    }
    {
#line 284
    __cil_tmp20 = psf_fread((void *)(& marker), (sf_count_t )1, (sf_count_t )2, psf);
#line 284
    bytesread = (int )((sf_count_t )bytesread + __cil_tmp20);
    }
#line 286
    if ((int )marker == 0) {
#line 287
      goto while_break;
    }
    {
#line 289
    psf_fseek(psf, (sf_count_t )125, 1);
#line 290
    bytesread += 125;
#line 282
    blockcount ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 293
  psf_log_printf(psf, "\nBlocks         : %d\n", blockcount);
#line 294
  psds->total_blocks = blockcount;
#line 296
  psds->samplesperblock = 120 / ((psds->bitwidth + 6) / 7);
#line 297
  psf_log_printf(psf, "Samples/Block  : %d\n", psds->samplesperblock);
#line 299
  psf_log_printf(psf, "Frames         : %d\n", blockcount * psds->samplesperblock);
#line 302
  psf->sf.channels = 1;
#line 303
  psf->sf.sections = 1;
  }
#line 310
  if ((psds->bitwidth + 7) / 8 == 1) {
#line 310
    goto case_1;
  }
#line 314
  if ((psds->bitwidth + 7) / 8 == 2) {
#line 314
    goto case_2;
  }
#line 318
  if ((psds->bitwidth + 7) / 8 == 3) {
#line 318
    goto case_3;
  }
#line 322
  if ((psds->bitwidth + 7) / 8 == 4) {
#line 322
    goto case_4;
  }
#line 326
  goto switch_default;
  case_1: 
#line 311
  psf->sf.format = 1114113;
#line 312
  goto switch_break;
  case_2: 
#line 315
  psf->sf.format = 1114114;
#line 316
  goto switch_break;
  case_3: 
#line 319
  psf->sf.format = 1114115;
#line 320
  goto switch_break;
  case_4: 
#line 323
  psf->sf.format = 1114116;
#line 324
  goto switch_break;
  switch_default: 
  {
#line 327
  psf_log_printf(psf, "*** Weird byte width (%d)\n", (psds->bitwidth + 7) / 8);
  }
#line 328
  return (146);
  switch_break: 
  {
#line 331
  psf_fseek(psf, (sf_count_t )21, 0);
  }
#line 333
  return (0);
}
}
#line 337 "/root/patchweave_new/23/src/sds.c"
static int sds_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  SDS_PRIVATE *psds ;
  sf_count_t current ;
  int samp_period ;
  int data_length ;
  int sustain_loop_start ;
  int sustain_loop_end ;
  unsigned char loop_type ;
  int current_count ;
  int current_block ;

  {
#line 341
  loop_type = (unsigned char)0;
#line 343
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 343
  if ((unsigned long )psds == (unsigned long )((void *)0)) {
    {
#line 344
    psf_log_printf(psf, "*** Bad psf->codec_data ptr.\n");
    }
#line 345
    return (30);
  }
#line 348
  if (psf->pipeoffset > 0L) {
#line 349
    return (0);
  }
  {
#line 351
  current = psf_ftell(psf);
  }
#line 353
  if (calc_length) {
#line 354
    psf->sf.frames = (sf_count_t )psds->total_written;
  }
#line 356
  if (psds->write_count > 0) {
    {
#line 357
    current_count = psds->write_count;
#line 358
    current_block = psds->write_block;
#line 360
    (*(psds->writer))(psf, psds);
#line 362
    psf_fseek(psf, (sf_count_t )-127, 1);
#line 364
    psds->write_count = current_count;
#line 365
    psds->write_block = current_block;
    }
  }
#line 369
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 370
  psf->header.indx = (sf_count_t )0;
#line 372
  if (psf->is_pipe == 0) {
    {
#line 373
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
  {
#line 375
  psf_binheader_writef(psf, "E211", 61566, 0, 1);
  }
#line 378
  if ((psf->sf.format & 65535) == 1) {
#line 378
    goto case_1;
  }
#line 381
  if ((psf->sf.format & 65535) == 2) {
#line 381
    goto case_2;
  }
#line 384
  if ((psf->sf.format & 65535) == 3) {
#line 384
    goto case_3;
  }
#line 387
  goto switch_default;
  case_1: 
#line 379
  psds->bitwidth = 8;
#line 380
  goto switch_break;
  case_2: 
#line 382
  psds->bitwidth = 16;
#line 383
  goto switch_break;
  case_3: 
#line 385
  psds->bitwidth = 24;
#line 386
  goto switch_break;
  switch_default: 
#line 388
  return (146);
  switch_break: 
  {
#line 391
  samp_period = ((1000000000 / psf->sf.samplerate & 127) | ((1000000000 / psf->sf.samplerate << 1) & 32512)) | ((1000000000 / psf->sf.samplerate << 2) & 8323072);
#line 393
  psf_binheader_writef(psf, "e213\270U", 0, psds->bitwidth, samp_period);
#line 395
  data_length = ((psds->total_written & 127) | ((psds->total_written << 1) & 32512)) | ((psds->total_written << 2) & 8323072);
#line 396
  sustain_loop_start = 0;
#line 397
  sustain_loop_end = 0;
#line 399
  psf_binheader_writef(psf, "e33311", data_length, sustain_loop_start, sustain_loop_end,
                       (int )loop_type, 247);
#line 402
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 404
  if (psf->error) {
#line 405
    return (psf->error);
  }
#line 407
  psf->dataoffset = psf->header.indx;
#line 408
  psf->datalength = (sf_count_t )(psds->write_block * 127);
#line 410
  if (current > 0L) {
    {
#line 411
    psf_fseek(psf, current, 0);
    }
  }
#line 413
  return (psf->error);
}
}
#line 421 "/root/patchweave_new/23/src/sds.c"
static int sds_2byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  sf_count_t __cil_tmp8 ;
  int32_t __cil_tmp10 ;
  int32_t __cil_tmp11 ;

  {
#line 426
  (psds->read_block) ++;
#line 427
  psds->read_count = 0;
#line 429
  if (psds->read_block * psds->samplesperblock > psds->frames) {
    {
#line 430
    memset((void *)(psds->read_samples), 0, (unsigned long )psds->samplesperblock * sizeof(int ));
    }
#line 431
    return (1);
  }
  {
#line 434
  __cil_tmp8 = psf_fread((void *)(psds->read_data), (sf_count_t )1, (sf_count_t )127,
                         psf);
#line 434
  k = (int )__cil_tmp8;
  }
#line 434
  if (k != 127) {
    {
#line 435
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\nU", k, 127);
    }
  }
#line 437
  if ((int )psds->read_data[0] != 240) {
    {
#line 438
    printf("Error A : %02X\n", (int )psds->read_data[0] & 255);
    }
  }
#line 441
  checksum = psds->read_data[1];
#line 442
  if ((int )checksum != 126) {
    {
#line 443
    printf("Error 1 : %02X\n", (int )checksum & 255);
    }
  }
#line 446
  k = 2;
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;

#line 446
    if (! (k <= 124)) {
#line 446
      goto while_break;
    }
#line 447
    checksum = (unsigned char )((int )checksum ^ (int )psds->read_data[k]);
#line 446
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 449
  checksum = (unsigned char )((int )checksum & 127);
#line 451
  if ((int )checksum != (int )psds->read_data[125]) {
    {
#line 452
    psf_log_printf(psf, "Block %d : checksum is %02X should be %02X\nF\270U", (int )psds->read_data[4],
                   (int )checksum, (int )psds->read_data[125]);
    }
  }
#line 455
  ucptr = psds->read_data + 5;
#line 456
  k = 0;
  {
#line 456
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 456
    if (! (k < 120)) {
#line 456
      goto while_break___0;
    }
    {
#line 457
    __cil_tmp11 = arith_shift_left((int32_t )*(ucptr + (k + 1)), 18);
#line 457
    __cil_tmp10 = arith_shift_left((int32_t )*(ucptr + k), 25);
#line 457
    sample = (unsigned int )(__cil_tmp10 + __cil_tmp11);
#line 458
    psds->read_samples[k / 2] = (int )(sample - 2147483648U);
#line 456
    k += 2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 461
  return (1);
}
}
#line 465 "/root/patchweave_new/23/src/sds.c"
static int sds_3byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  sf_count_t __cil_tmp8 ;

  {
#line 470
  (psds->read_block) ++;
#line 471
  psds->read_count = 0;
#line 473
  if (psds->read_block * psds->samplesperblock > psds->frames) {
    {
#line 474
    memset((void *)(psds->read_samples), 0, (unsigned long )psds->samplesperblock * sizeof(int ));
    }
#line 475
    return (1);
  }
  {
#line 478
  __cil_tmp8 = psf_fread((void *)(psds->read_data), (sf_count_t )1, (sf_count_t )127,
                         psf);
#line 478
  k = (int )__cil_tmp8;
  }
#line 478
  if (k != 127) {
    {
#line 479
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\nU", k, 127);
    }
  }
#line 481
  if ((int )psds->read_data[0] != 240) {
    {
#line 482
    printf("Error A : %02X\n", (int )psds->read_data[0] & 255);
    }
  }
#line 485
  checksum = psds->read_data[1];
#line 486
  if ((int )checksum != 126) {
    {
#line 487
    printf("Error 1 : %02X\n", (int )checksum & 255);
    }
  }
#line 490
  k = 2;
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;

#line 490
    if (! (k <= 124)) {
#line 490
      goto while_break;
    }
#line 491
    checksum = (unsigned char )((int )checksum ^ (int )psds->read_data[k]);
#line 490
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 493
  checksum = (unsigned char )((int )checksum & 127);
#line 495
  if ((int )checksum != (int )psds->read_data[125]) {
    {
#line 496
    psf_log_printf(psf, "Block %d : checksum is %02X should be %02X\n", (int )psds->read_data[4],
                   (int )checksum, (int )psds->read_data[125]);
    }
  }
#line 499
  ucptr = psds->read_data + 5;
#line 500
  k = 0;
  {
#line 500
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 500
    if (! (k < 120)) {
#line 500
      goto while_break___0;
    }
#line 501
    sample = (((uint32_t )*(ucptr + k) << 25) + (unsigned int )((int )*(ucptr + (k + 1)) << 18)) + (unsigned int )((int )*(ucptr + (k + 2)) << 11);
#line 502
    psds->read_samples[k / 3] = (int )(sample - 2147483648U);
#line 500
    k += 3;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 505
  return (1);
}
}
#line 509 "/root/patchweave_new/23/src/sds.c"
static int sds_4byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  uint32_t sample ;
  int k ;
  sf_count_t __cil_tmp8 ;

  {
#line 514
  (psds->read_block) ++;
#line 515
  psds->read_count = 0;
#line 517
  if (psds->read_block * psds->samplesperblock > psds->frames) {
    {
#line 518
    memset((void *)(psds->read_samples), 0, (unsigned long )psds->samplesperblock * sizeof(int ));
    }
#line 519
    return (1);
  }
  {
#line 522
  __cil_tmp8 = psf_fread((void *)(psds->read_data), (sf_count_t )1, (sf_count_t )127,
                         psf);
#line 522
  k = (int )__cil_tmp8;
  }
#line 522
  if (k != 127) {
    {
#line 523
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, 127);
    }
  }
#line 525
  if ((int )psds->read_data[0] != 240) {
    {
#line 526
    printf("Error A : %02X\n", (int )psds->read_data[0] & 255);
    }
  }
#line 529
  checksum = psds->read_data[1];
#line 530
  if ((int )checksum != 126) {
    {
#line 531
    printf("Error 1 : %02X\n", (int )checksum & 255);
    }
  }
#line 534
  k = 2;
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;

#line 534
    if (! (k <= 124)) {
#line 534
      goto while_break;
    }
#line 535
    checksum = (unsigned char )((int )checksum ^ (int )psds->read_data[k]);
#line 534
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 537
  checksum = (unsigned char )((int )checksum & 127);
#line 539
  if ((int )checksum != (int )psds->read_data[125]) {
    {
#line 540
    psf_log_printf(psf, "Block %d : checksum is %02X should be %02X\n", (int )psds->read_data[4],
                   (int )checksum, (int )psds->read_data[125]);
    }
  }
#line 543
  ucptr = psds->read_data + 5;
#line 544
  k = 0;
  {
#line 544
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 544
    if (! (k < 120)) {
#line 544
      goto while_break___0;
    }
#line 545
    sample = ((((uint32_t )*(ucptr + k) << 25) + (unsigned int )((int )*(ucptr + (k + 1)) << 18)) + (unsigned int )((int )*(ucptr + (k + 2)) << 11)) + (unsigned int )((int )*(ucptr + (k + 3)) << 4);
#line 546
    psds->read_samples[k / 4] = (int )(sample - 2147483648U);
#line 544
    k += 4;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 549
  return (1);
}
}
#line 554 "/root/patchweave_new/23/src/sds.c"
static sf_count_t sds_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 559
  total = (sf_count_t )0;
#line 561
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 562
    return ((sf_count_t )0);
  }
#line 563
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 565
  iptr = ubuf.ibuf;
#line 566
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;

#line 567
    if (! (len > 0L)) {
#line 567
      goto while_break;
    }
#line 568
    if (len >= (long )bufferlen) {
#line 568
      tmp = (long )bufferlen;
    } else {
#line 568
      tmp = len;
    }
    {
#line 568
    readcount = (int )tmp;
#line 569
    count___0 = sds_read(psf, psds, iptr, readcount);
#line 570
    k = 0;
    }
    {
#line 570
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 570
      if (! (k < readcount)) {
#line 570
        goto while_break___0;
      }
#line 571
      *(ptr + (total + (long )k)) = (short )(*(iptr + k) >> 16);
#line 570
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 572
    total += (long )count___0;
#line 573
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 576
  return (total);
}
}
#line 580 "/root/patchweave_new/23/src/sds.c"
static sf_count_t sds_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  SDS_PRIVATE *psds ;
  int total ;

  {
#line 584
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 585
    return ((sf_count_t )0);
  }
  {
#line 586
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 588
  total = sds_read(psf, psds, ptr, (int )len);
  }
#line 590
  return ((sf_count_t )total);
}
}
#line 594 "/root/patchweave_new/23/src/sds.c"
static sf_count_t sds_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  long tmp ;

  {
#line 599
  total = (sf_count_t )0;
#line 602
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 603
    return ((sf_count_t )0);
  }
#line 604
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 606
  if (psf->norm_float == 1) {
#line 607
    normfact = (float )(1. / (double )2147483648U);
  } else {
#line 609
    normfact = (float )(1. / (double )(1 << psds->bitwidth));
  }
#line 611
  iptr = ubuf.ibuf;
#line 612
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;

#line 613
    if (! (len > 0L)) {
#line 613
      goto while_break;
    }
#line 614
    if (len >= (long )bufferlen) {
#line 614
      tmp = (long )bufferlen;
    } else {
#line 614
      tmp = len;
    }
    {
#line 614
    readcount = (int )tmp;
#line 615
    count___0 = sds_read(psf, psds, iptr, readcount);
#line 616
    k = 0;
    }
    {
#line 616
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 616
      if (! (k < readcount)) {
#line 616
        goto while_break___0;
      }
#line 617
      *(ptr + (total + (long )k)) = normfact * (float )*(iptr + k);
#line 616
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 618
    total += (long )count___0;
#line 619
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 622
  return (total);
}
}
#line 626 "/root/patchweave_new/23/src/sds.c"
static sf_count_t sds_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  long tmp ;

  {
#line 631
  total = (sf_count_t )0;
#line 634
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 635
    return ((sf_count_t )0);
  }
#line 636
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 638
  if (psf->norm_double == 1) {
#line 639
    normfact = 1. / (double )2147483648U;
  } else {
#line 641
    normfact = 1. / (double )(1 << psds->bitwidth);
  }
#line 643
  iptr = ubuf.ibuf;
#line 644
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 645
  while (1) {
    while_continue: /* CIL Label */ ;

#line 645
    if (! (len > 0L)) {
#line 645
      goto while_break;
    }
#line 646
    if (len >= (long )bufferlen) {
#line 646
      tmp = (long )bufferlen;
    } else {
#line 646
      tmp = len;
    }
    {
#line 646
    readcount = (int )tmp;
#line 647
    count___0 = sds_read(psf, psds, iptr, readcount);
#line 648
    k = 0;
    }
    {
#line 648
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 648
      if (! (k < readcount)) {
#line 648
        goto while_break___0;
      }
#line 649
      *(ptr + (total + (long )k)) = normfact * (double )*(iptr + k);
#line 648
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 650
    total += (long )count___0;
#line 651
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 654
  return (total);
}
}
#line 658 "/root/patchweave_new/23/src/sds.c"
static int sds_read(SF_PRIVATE *psf , SDS_PRIVATE *psds , int *ptr , int len ) 
{ 
  int count___0 ;
  int total ;
  int tmp ;

  {
#line 659
  total = 0;
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;

#line 661
    if (! (total < len)) {
#line 661
      goto while_break;
    }
#line 662
    if (psds->read_block * psds->samplesperblock >= psds->frames) {
      {
#line 663
      memset((void *)(ptr + total), 0, (unsigned long )(len - total) * sizeof(int ));
      }
#line 664
      return (total);
    }
#line 667
    if (psds->read_count >= psds->samplesperblock) {
      {
#line 668
      (*(psds->reader))(psf, psds);
      }
    }
#line 670
    count___0 = psds->samplesperblock - psds->read_count;
#line 671
    if (len - total > count___0) {
#line 671
      tmp = count___0;
    } else {
#line 671
      tmp = len - total;
    }
    {
#line 671
    count___0 = tmp;
#line 673
    memcpy((void *)(ptr + total), (void const   *)(& psds->read_samples[psds->read_count]),
           (unsigned long )count___0 * sizeof(int ));
#line 674
    total += count___0;
#line 675
    psds->read_count += count___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 678
  return (total);
}
}
#line 685 "/root/patchweave_new/23/src/sds.c"
static sf_count_t sds_seek(SF_PRIVATE *psf , int mode , sf_count_t seek_from_start ) 
{ 
  SDS_PRIVATE *psds ;
  sf_count_t file_offset ;
  int newblock ;
  int newsample ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 690
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 690
  if ((unsigned long )psds == (unsigned long )((void *)0)) {
#line 691
    psf->error = 30;
#line 692
    return ((sf_count_t )-1);
  }
#line 695
  if (psf->datalength < 0L) {
#line 696
    psf->error = 40;
#line 697
    return ((sf_count_t )-1);
  } else
#line 695
  if (psf->dataoffset < 0L) {
#line 696
    psf->error = 40;
#line 697
    return ((sf_count_t )-1);
  }
#line 700
  if (seek_from_start < 0L) {
#line 701
    psf->error = 40;
#line 702
    return ((sf_count_t )-1);
  } else
#line 700
  if (seek_from_start > psf->sf.frames) {
#line 701
    psf->error = 40;
#line 702
    return ((sf_count_t )-1);
  }
#line 705
  if (mode == 16) {
#line 705
    if (psds->write_count > 0) {
      {
#line 706
      (*(psds->writer))(psf, psds);
      }
    }
  }
#line 708
  newblock = (int )(seek_from_start / (long )psds->samplesperblock);
#line 709
  newsample = (int )(seek_from_start % (long )psds->samplesperblock);
#line 712
  if (mode == 16) {
#line 712
    goto case_16;
  }
#line 730
  if (mode == 32) {
#line 730
    goto case_32;
  }
#line 748
  goto switch_default;
  case_16: 
#line 713
  if (newblock > psds->total_blocks) {
#line 714
    psf->error = 40;
#line 715
    return ((sf_count_t )-1);
  }
  {
#line 718
  file_offset = psf->dataoffset + (long )(newblock * 127);
#line 720
  __cil_tmp8 = psf_fseek(psf, file_offset, 0);
  }
#line 720
  if (__cil_tmp8 != file_offset) {
#line 721
    psf->error = 44;
#line 722
    return ((sf_count_t )-1);
  }
  {
#line 725
  psds->read_block = newblock;
#line 726
  (*(psds->reader))(psf, psds);
#line 727
  psds->read_count = newsample;
  }
#line 728
  goto switch_break;
  case_32: 
#line 731
  if (newblock > psds->total_blocks) {
#line 732
    psf->error = 40;
#line 733
    return ((sf_count_t )-1);
  }
  {
#line 736
  file_offset = psf->dataoffset + (long )(newblock * 127);
#line 738
  __cil_tmp9 = psf_fseek(psf, file_offset, 0);
  }
#line 738
  if (__cil_tmp9 != file_offset) {
#line 739
    psf->error = 44;
#line 740
    return ((sf_count_t )-1);
  }
  {
#line 743
  psds->write_block = newblock;
#line 744
  (*(psds->reader))(psf, psds);
#line 745
  psds->write_count = newsample;
  }
#line 746
  goto switch_break;
  switch_default: 
#line 749
  psf->error = 40;
#line 750
  return ((sf_count_t )-1);
#line 751
  goto switch_break;
  switch_break: ;
#line 754
  return (seek_from_start);
}
}
#line 758 "/root/patchweave_new/23/src/sds.c"
static int sds_byterate(SF_PRIVATE *psf ) 
{ 


  {
#line 760
  if (psf->file.mode == 16) {
#line 761
    return ((int )((psf->datalength * (long )psf->sf.samplerate) / psf->sf.frames));
  }
#line 763
  return (-1);
}
}
#line 770 "/root/patchweave_new/23/src/sds.c"
static int sds_2byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  sf_count_t __cil_tmp8 ;

  {
#line 775
  psds->write_data[0] = (unsigned char)240;
#line 776
  psds->write_data[1] = (unsigned char)126;
#line 777
  psds->write_data[2] = (unsigned char)0;
#line 778
  psds->write_data[3] = (unsigned char)2;
#line 779
  psds->write_data[4] = (unsigned char )(psds->write_block & 127);
#line 781
  ucptr = psds->write_data + 5;
#line 782
  k = 0;
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;

#line 782
    if (! (k < 120)) {
#line 782
      goto while_break;
    }
#line 783
    sample = (unsigned int )psds->write_samples[k / 2];
#line 784
    sample += 2147483648U;
#line 785
    *(ucptr + k) = (unsigned char )((sample >> 25) & 127U);
#line 786
    *(ucptr + (k + 1)) = (unsigned char )((sample >> 18) & 127U);
#line 782
    k += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 789
  checksum = psds->write_data[1];
#line 790
  k = 2;
  {
#line 790
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 790
    if (! (k <= 124)) {
#line 790
      goto while_break___0;
    }
#line 791
    checksum = (unsigned char )((int )checksum ^ (int )psds->write_data[k]);
#line 790
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 792
  checksum = (unsigned char )((int )checksum & 127);
#line 794
  psds->write_data[125] = checksum;
#line 795
  psds->write_data[126] = (unsigned char)247;
#line 797
  __cil_tmp8 = psf_fwrite((void const   *)(psds->write_data), (sf_count_t )1, (sf_count_t )127,
                          psf);
#line 797
  k = (int )__cil_tmp8;
  }
#line 797
  if (k != 127) {
    {
#line 798
    psf_log_printf(psf, "*** Warning : psf_fwrite (%d != %d).\n", k, 127);
    }
  }
#line 800
  (psds->write_block) ++;
#line 801
  psds->write_count = 0;
#line 803
  if (psds->write_block > psds->total_blocks) {
#line 804
    psds->total_blocks = psds->write_block;
  }
#line 805
  psds->frames = psds->total_blocks * psds->samplesperblock;
#line 807
  return (1);
}
}
#line 811 "/root/patchweave_new/23/src/sds.c"
static int sds_3byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  sf_count_t __cil_tmp8 ;

  {
#line 816
  psds->write_data[0] = (unsigned char)240;
#line 817
  psds->write_data[1] = (unsigned char)126;
#line 818
  psds->write_data[2] = (unsigned char)0;
#line 819
  psds->write_data[3] = (unsigned char)2;
#line 820
  psds->write_data[4] = (unsigned char )(psds->write_block & 127);
#line 822
  ucptr = psds->write_data + 5;
#line 823
  k = 0;
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;

#line 823
    if (! (k < 120)) {
#line 823
      goto while_break;
    }
#line 824
    sample = (unsigned int )psds->write_samples[k / 3];
#line 825
    sample += 2147483648U;
#line 826
    *(ucptr + k) = (unsigned char )((sample >> 25) & 127U);
#line 827
    *(ucptr + (k + 1)) = (unsigned char )((sample >> 18) & 127U);
#line 828
    *(ucptr + (k + 2)) = (unsigned char )((sample >> 11) & 127U);
#line 823
    k += 3;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 831
  checksum = psds->write_data[1];
#line 832
  k = 2;
  {
#line 832
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 832
    if (! (k <= 124)) {
#line 832
      goto while_break___0;
    }
#line 833
    checksum = (unsigned char )((int )checksum ^ (int )psds->write_data[k]);
#line 832
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 834
  checksum = (unsigned char )((int )checksum & 127);
#line 836
  psds->write_data[125] = checksum;
#line 837
  psds->write_data[126] = (unsigned char)247;
#line 839
  __cil_tmp8 = psf_fwrite((void const   *)(psds->write_data), (sf_count_t )1, (sf_count_t )127,
                          psf);
#line 839
  k = (int )__cil_tmp8;
  }
#line 839
  if (k != 127) {
    {
#line 840
    psf_log_printf(psf, "*** Warning : psf_fwrite (%d != %d).\nU", k, 127);
    }
  }
#line 842
  (psds->write_block) ++;
#line 843
  psds->write_count = 0;
#line 845
  if (psds->write_block > psds->total_blocks) {
#line 846
    psds->total_blocks = psds->write_block;
  }
#line 847
  psds->frames = psds->total_blocks * psds->samplesperblock;
#line 849
  return (1);
}
}
#line 853 "/root/patchweave_new/23/src/sds.c"
static int sds_4byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  sf_count_t __cil_tmp8 ;

  {
#line 858
  psds->write_data[0] = (unsigned char)240;
#line 859
  psds->write_data[1] = (unsigned char)126;
#line 860
  psds->write_data[2] = (unsigned char)0;
#line 861
  psds->write_data[3] = (unsigned char)2;
#line 862
  psds->write_data[4] = (unsigned char )(psds->write_block & 127);
#line 864
  ucptr = psds->write_data + 5;
#line 865
  k = 0;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;

#line 865
    if (! (k < 120)) {
#line 865
      goto while_break;
    }
#line 866
    sample = (unsigned int )psds->write_samples[k / 4];
#line 867
    sample += 2147483648U;
#line 868
    *(ucptr + k) = (unsigned char )((sample >> 25) & 127U);
#line 869
    *(ucptr + (k + 1)) = (unsigned char )((sample >> 18) & 127U);
#line 870
    *(ucptr + (k + 2)) = (unsigned char )((sample >> 11) & 127U);
#line 871
    *(ucptr + (k + 3)) = (unsigned char )((sample >> 4) & 127U);
#line 865
    k += 4;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 874
  checksum = psds->write_data[1];
#line 875
  k = 2;
  {
#line 875
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 875
    if (! (k <= 124)) {
#line 875
      goto while_break___0;
    }
#line 876
    checksum = (unsigned char )((int )checksum ^ (int )psds->write_data[k]);
#line 875
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 877
  checksum = (unsigned char )((int )checksum & 127);
#line 879
  psds->write_data[125] = checksum;
#line 880
  psds->write_data[126] = (unsigned char)247;
#line 882
  __cil_tmp8 = psf_fwrite((void const   *)(psds->write_data), (sf_count_t )1, (sf_count_t )127,
                          psf);
#line 882
  k = (int )__cil_tmp8;
  }
#line 882
  if (k != 127) {
    {
#line 883
    psf_log_printf(psf, "*** Warning : psf_fwrite (%d != %d).\nU", k, 127);
    }
  }
#line 885
  (psds->write_block) ++;
#line 886
  psds->write_count = 0;
#line 888
  if (psds->write_block > psds->total_blocks) {
#line 889
    psds->total_blocks = psds->write_block;
  }
#line 890
  psds->frames = psds->total_blocks * psds->samplesperblock;
#line 892
  return (1);
}
}
#line 896 "/root/patchweave_new/23/src/sds.c"
static sf_count_t sds_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 901
  total = (sf_count_t )0;
#line 903
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 904
    return ((sf_count_t )0);
  }
#line 905
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 906
  psds->total_written = (int )((sf_count_t )psds->total_written + len);
#line 908
  iptr = ubuf.ibuf;
#line 909
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 910
  while (1) {
    while_continue: /* CIL Label */ ;

#line 910
    if (! (len > 0L)) {
#line 910
      goto while_break;
    }
#line 911
    if (len >= (long )bufferlen) {
#line 911
      tmp = (long )bufferlen;
    } else {
#line 911
      tmp = len;
    }
#line 911
    writecount = (int )tmp;
#line 912
    k = 0;
    {
#line 912
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 912
      if (! (k < writecount)) {
#line 912
        goto while_break___0;
      }
      {
#line 913
      *(iptr + k) = arith_shift_left((int32_t )*(ptr + (total + (long )k)), 16);
#line 912
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 914
    count___0 = sds_write(psf, psds, (int const   *)iptr, writecount);
#line 915
    total += (long )count___0;
#line 916
    len -= (long )writecount;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 919
  return (total);
}
}
#line 923 "/root/patchweave_new/23/src/sds.c"
static sf_count_t sds_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  SDS_PRIVATE *psds ;
  int total ;

  {
#line 927
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 928
    return ((sf_count_t )0);
  }
  {
#line 929
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 930
  psds->total_written = (int )((sf_count_t )psds->total_written + len);
#line 932
  total = sds_write(psf, psds, ptr, (int )len);
  }
#line 934
  return ((sf_count_t )total);
}
}
#line 938 "/root/patchweave_new/23/src/sds.c"
static sf_count_t sds_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  long tmp ;

  {
#line 943
  total = (sf_count_t )0;
#line 946
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 947
    return ((sf_count_t )0);
  }
#line 948
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 949
  psds->total_written = (int )((sf_count_t )psds->total_written + len);
#line 951
  if (psf->norm_float == 1) {
#line 952
    normfact = (float )(1. * (double )2147483648U);
  } else {
#line 954
    normfact = (float )(1. * (double )(1 << psds->bitwidth));
  }
#line 956
  iptr = ubuf.ibuf;
#line 957
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 958
  while (1) {
    while_continue: /* CIL Label */ ;

#line 958
    if (! (len > 0L)) {
#line 958
      goto while_break;
    }
#line 959
    if (len >= (long )bufferlen) {
#line 959
      tmp = (long )bufferlen;
    } else {
#line 959
      tmp = len;
    }
#line 959
    writecount = (int )tmp;
#line 960
    k = 0;
    {
#line 960
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 960
      if (! (k < writecount)) {
#line 960
        goto while_break___0;
      }
#line 961
      *(iptr + k) = (int )(normfact * (float )*(ptr + (total + (long )k)));
#line 960
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 962
    count___0 = sds_write(psf, psds, (int const   *)iptr, writecount);
#line 963
    total += (long )count___0;
#line 964
    len -= (long )writecount;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 967
  return (total);
}
}
#line 971 "/root/patchweave_new/23/src/sds.c"
static sf_count_t sds_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  long tmp ;

  {
#line 976
  total = (sf_count_t )0;
#line 979
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 980
    return ((sf_count_t )0);
  }
#line 981
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 982
  psds->total_written = (int )((sf_count_t )psds->total_written + len);
#line 984
  if (psf->norm_double == 1) {
#line 985
    normfact = 1. * (double )2147483648U;
  } else {
#line 987
    normfact = 1. * (double )(1 << psds->bitwidth);
  }
#line 989
  iptr = ubuf.ibuf;
#line 990
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 991
  while (1) {
    while_continue: /* CIL Label */ ;

#line 991
    if (! (len > 0L)) {
#line 991
      goto while_break;
    }
#line 992
    if (len >= (long )bufferlen) {
#line 992
      tmp = (long )bufferlen;
    } else {
#line 992
      tmp = len;
    }
#line 992
    writecount = (int )tmp;
#line 993
    k = 0;
    {
#line 993
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 993
      if (! (k < writecount)) {
#line 993
        goto while_break___0;
      }
#line 994
      *(iptr + k) = (int )(normfact * (double )*(ptr + (total + (long )k)));
#line 993
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 995
    count___0 = sds_write(psf, psds, (int const   *)iptr, writecount);
#line 996
    total += (long )count___0;
#line 997
    len -= (long )writecount;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1000
  return (total);
}
}
#line 1004 "/root/patchweave_new/23/src/sds.c"
static int sds_write(SF_PRIVATE *psf , SDS_PRIVATE *psds , int const   *ptr , int len ) 
{ 
  int count___0 ;
  int total ;

  {
#line 1005
  total = 0;
  {
#line 1007
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1007
    if (! (total < len)) {
#line 1007
      goto while_break;
    }
#line 1008
    count___0 = psds->samplesperblock - psds->write_count;
#line 1009
    if (count___0 > len - total) {
#line 1010
      count___0 = len - total;
    }
    {
#line 1012
    memcpy((void *)(& psds->write_samples[psds->write_count]), (void const   *)(ptr + total),
           (unsigned long )count___0 * sizeof(int ));
#line 1013
    total += count___0;
#line 1014
    psds->write_count += count___0;
    }
#line 1016
    if (psds->write_count >= psds->samplesperblock) {
      {
#line 1017
      (*(psds->writer))(psf, psds);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1020
  return (total);
}
}
#line 89 "/root/patchweave_new/23/src/sd2.c"
static int sd2_close(SF_PRIVATE *psf ) ;
#line 91
static int sd2_parse_rsrc_fork(SF_PRIVATE *psf ) ;
#line 92
static int parse_str_rsrc(SF_PRIVATE *psf , SD2_RSRC *rsrc ) ;
#line 94
static int sd2_write_rsrc_fork(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 101 "/root/patchweave_new/23/src/sd2.c"
int sd2_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int valid ;

  {
#line 102
  error = 0;
#line 105
  psf->endian = 536870912;
#line 107
  if (psf->file.mode == 16) {
    _L: 
    {
#line 108
    psf_use_rsrc(psf, 1);
#line 109
    valid = psf_file_valid(psf);
#line 110
    psf_use_rsrc(psf, 0);
    }
#line 111
    if (! valid) {
      {
#line 112
      psf_log_printf(psf, "sd2_open : psf->rsrc.filedes < 0\n");
      }
#line 113
      return (152);
    }
    {
#line 116
    error = sd2_parse_rsrc_fork(psf);
    }
#line 118
    if (error) {
#line 119
      goto error_cleanup;
    }
  } else
#line 107
  if (psf->file.mode == 48) {
#line 107
    if (psf->rsrclength > 0L) {
#line 107
      goto _L;
    }
  }
#line 122
  if ((psf->sf.format & 268369920) != 1441792) {
#line 123
    error = 1;
#line 124
    goto error_cleanup;
  }
#line 127
  subformat = psf->sf.format & 65535;
#line 128
  psf->dataoffset = (sf_count_t )0;
#line 131
  if (psf->file.mode == 32) {
    _L___26: 
    {
#line 132
    psf->rsrc.mode = psf->file.mode;
#line 133
    psf_open_rsrc(psf);
#line 135
    error = sd2_write_rsrc_fork(psf, 0);
    }
#line 137
    if (error) {
#line 138
      goto error_cleanup;
    }
#line 141
    psf->write_header = (int (*)(struct sf_private_tag * , int  ))((void *)0);
  } else
#line 131
  if (psf->file.mode == 48) {
#line 131
    if (psf->rsrclength == 0L) {
#line 131
      goto _L___26;
    }
  }
#line 144
  psf->container_close = & sd2_close;
#line 146
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 152
  if (subformat == 4) {
#line 152
    goto case_4;
  }
#line 152
  if (subformat == 3) {
#line 152
    goto case_4;
  }
#line 152
  if (subformat == 2) {
#line 152
    goto case_4;
  }
#line 152
  if (subformat == 1) {
#line 152
    goto case_4;
  }
#line 156
  goto switch_default;
  case_4: 
  {
#line 153
  error = pcm_init(psf);
  }
#line 154
  goto switch_break;
  switch_default: 
#line 157
  error = 18;
#line 158
  goto switch_break;
  switch_break: 
  {
#line 161
  psf_fseek(psf, psf->dataoffset, 0);
  }
  error_cleanup: 
  {
#line 166
  psf_close_rsrc(psf);
  }
#line 168
  return (error);
}
}
#line 175 "/root/patchweave_new/23/src/sd2.c"
static int sd2_close(SF_PRIVATE *psf ) 
{ 


  {
#line 184
  return (0);
}
}
#line 191 "/root/patchweave_new/23/src/sd2.c"
static int sd2_write_rsrc_fork(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  SD2_RSRC rsrc ;
  STR_RSRC str_rsrc[4] ;
  unsigned int tmp ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  int k ;
  int str_offset ;
  int data_offset ;
  int next_str ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  size_t __cil_tmp17 ;
  size_t __cil_tmp18 ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;
  size_t __cil_tmp21 ;
  size_t __cil_tmp22 ;
  size_t __cil_tmp23 ;
  size_t __cil_tmp24 ;
  size_t __cil_tmp25 ;
  size_t __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  size_t __cil_tmp29 ;
  size_t __cil_tmp30 ;
  size_t __cil_tmp31 ;
  size_t __cil_tmp32 ;
  size_t __cil_tmp34 ;
  size_t __cil_tmp35 ;

  {
#line 193
  str_rsrc[0].type = 111;
#line 193
  str_rsrc[0].id = 1000;
#line 193
  str_rsrc[0].name[0] = (char )"_sample-size\270U";
#line 193
  str_rsrc[0].name[1] = (char )"\251";
#line 193
  str_rsrc[0].name[2] = (char)0;
#line 193
  tmp = 3U;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;

#line 193
    if (tmp >= 32U) {
#line 193
      goto while_break;
    }
#line 193
    str_rsrc[0].name[tmp] = (char)0;
#line 193
    tmp ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: 
#line 193
  str_rsrc[0].value[0] = (char)0;
#line 193
  str_rsrc[0].value[1] = (char)0;
#line 193
  str_rsrc[0].value[2] = (char)0;
#line 193
  str_rsrc[0].value[3] = (char)0;
#line 193
  str_rsrc[0].value[4] = (char)0;
#line 193
  str_rsrc[0].value[5] = (char)0;
#line 193
  str_rsrc[0].value[6] = (char)0;
#line 193
  str_rsrc[0].value[7] = (char)0;
#line 193
  str_rsrc[0].value[8] = (char)0;
#line 193
  str_rsrc[0].value[9] = (char)0;
#line 193
  str_rsrc[0].value[10] = (char)0;
#line 193
  str_rsrc[0].value[11] = (char)0;
#line 193
  str_rsrc[0].value[12] = (char)0;
#line 193
  str_rsrc[0].value[13] = (char)0;
#line 193
  str_rsrc[0].value[14] = (char)0;
#line 193
  str_rsrc[0].value[15] = (char)0;
#line 193
  str_rsrc[0].value[16] = (char)0;
#line 193
  str_rsrc[0].value[17] = (char)0;
#line 193
  str_rsrc[0].value[18] = (char)0;
#line 193
  str_rsrc[0].value[19] = (char)0;
#line 193
  str_rsrc[0].value[20] = (char)0;
#line 193
  str_rsrc[0].value[21] = (char)0;
#line 193
  str_rsrc[0].value[22] = (char)0;
#line 193
  str_rsrc[0].value[23] = (char)0;
#line 193
  str_rsrc[0].value[24] = (char)0;
#line 193
  str_rsrc[0].value[25] = (char)0;
#line 193
  str_rsrc[0].value[26] = (char)0;
#line 193
  str_rsrc[0].value[27] = (char)0;
#line 193
  str_rsrc[0].value[28] = (char)0;
#line 193
  str_rsrc[0].value[29] = (char)0;
#line 193
  str_rsrc[0].value[30] = (char)0;
#line 193
  str_rsrc[0].value[31] = (char)0;
#line 193
  str_rsrc[0].value_len = 0;
#line 193
  str_rsrc[1].type = 111;
#line 193
  str_rsrc[1].id = 1001;
#line 193
  str_rsrc[1].name[0] = (char )"_sample-rate\270U";
#line 193
  str_rsrc[1].name[1] = (char )"\251";
#line 193
  str_rsrc[1].name[2] = (char)0;
#line 193
  tmp___27 = 3U;
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 193
    if (tmp___27 >= 32U) {
#line 193
      goto while_break___0;
    }
#line 193
    str_rsrc[1].name[tmp___27] = (char)0;
#line 193
    tmp___27 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___0: 
#line 193
  str_rsrc[1].value[0] = (char)0;
#line 193
  str_rsrc[1].value[1] = (char)0;
#line 193
  str_rsrc[1].value[2] = (char)0;
#line 193
  str_rsrc[1].value[3] = (char)0;
#line 193
  str_rsrc[1].value[4] = (char)0;
#line 193
  str_rsrc[1].value[5] = (char)0;
#line 193
  str_rsrc[1].value[6] = (char)0;
#line 193
  str_rsrc[1].value[7] = (char)0;
#line 193
  str_rsrc[1].value[8] = (char)0;
#line 193
  str_rsrc[1].value[9] = (char)0;
#line 193
  str_rsrc[1].value[10] = (char)0;
#line 193
  str_rsrc[1].value[11] = (char)0;
#line 193
  str_rsrc[1].value[12] = (char)0;
#line 193
  str_rsrc[1].value[13] = (char)0;
#line 193
  str_rsrc[1].value[14] = (char)0;
#line 193
  str_rsrc[1].value[15] = (char)0;
#line 193
  str_rsrc[1].value[16] = (char)0;
#line 193
  str_rsrc[1].value[17] = (char)0;
#line 193
  str_rsrc[1].value[18] = (char)0;
#line 193
  str_rsrc[1].value[19] = (char)0;
#line 193
  str_rsrc[1].value[20] = (char)0;
#line 193
  str_rsrc[1].value[21] = (char)0;
#line 193
  str_rsrc[1].value[22] = (char)0;
#line 193
  str_rsrc[1].value[23] = (char)0;
#line 193
  str_rsrc[1].value[24] = (char)0;
#line 193
  str_rsrc[1].value[25] = (char)0;
#line 193
  str_rsrc[1].value[26] = (char)0;
#line 193
  str_rsrc[1].value[27] = (char)0;
#line 193
  str_rsrc[1].value[28] = (char)0;
#line 193
  str_rsrc[1].value[29] = (char)0;
#line 193
  str_rsrc[1].value[30] = (char)0;
#line 193
  str_rsrc[1].value[31] = (char)0;
#line 193
  str_rsrc[1].value_len = 0;
#line 193
  str_rsrc[2].type = 111;
#line 193
  str_rsrc[2].id = 1002;
#line 193
  str_rsrc[2].name[0] = (char )"_channels";
#line 193
  str_rsrc[2].name[1] = (char )"\251";
#line 193
  str_rsrc[2].name[2] = (char)0;
#line 193
  tmp___28 = 3U;
  {
#line 193
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 193
    if (tmp___28 >= 32U) {
#line 193
      goto while_break___1;
    }
#line 193
    str_rsrc[2].name[tmp___28] = (char)0;
#line 193
    tmp___28 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: 
#line 193
  str_rsrc[2].value[0] = (char)0;
#line 193
  str_rsrc[2].value[1] = (char)0;
#line 193
  str_rsrc[2].value[2] = (char)0;
#line 193
  str_rsrc[2].value[3] = (char)0;
#line 193
  str_rsrc[2].value[4] = (char)0;
#line 193
  str_rsrc[2].value[5] = (char)0;
#line 193
  str_rsrc[2].value[6] = (char)0;
#line 193
  str_rsrc[2].value[7] = (char)0;
#line 193
  str_rsrc[2].value[8] = (char)0;
#line 193
  str_rsrc[2].value[9] = (char)0;
#line 193
  str_rsrc[2].value[10] = (char)0;
#line 193
  str_rsrc[2].value[11] = (char)0;
#line 193
  str_rsrc[2].value[12] = (char)0;
#line 193
  str_rsrc[2].value[13] = (char)0;
#line 193
  str_rsrc[2].value[14] = (char)0;
#line 193
  str_rsrc[2].value[15] = (char)0;
#line 193
  str_rsrc[2].value[16] = (char)0;
#line 193
  str_rsrc[2].value[17] = (char)0;
#line 193
  str_rsrc[2].value[18] = (char)0;
#line 193
  str_rsrc[2].value[19] = (char)0;
#line 193
  str_rsrc[2].value[20] = (char)0;
#line 193
  str_rsrc[2].value[21] = (char)0;
#line 193
  str_rsrc[2].value[22] = (char)0;
#line 193
  str_rsrc[2].value[23] = (char)0;
#line 193
  str_rsrc[2].value[24] = (char)0;
#line 193
  str_rsrc[2].value[25] = (char)0;
#line 193
  str_rsrc[2].value[26] = (char)0;
#line 193
  str_rsrc[2].value[27] = (char)0;
#line 193
  str_rsrc[2].value[28] = (char)0;
#line 193
  str_rsrc[2].value[29] = (char)0;
#line 193
  str_rsrc[2].value[30] = (char)0;
#line 193
  str_rsrc[2].value[31] = (char)0;
#line 193
  str_rsrc[2].value_len = 0;
#line 193
  str_rsrc[3].type = 112;
#line 193
  str_rsrc[3].id = 1000;
#line 193
  str_rsrc[3].name[0] = (char )"_Markers\323";
#line 193
  str_rsrc[3].name[1] = (char )"\251";
#line 193
  str_rsrc[3].name[2] = (char)8;
#line 193
  tmp___29 = 3U;
  {
#line 193
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 193
    if (tmp___29 >= 32U) {
#line 193
      goto while_break___2;
    }
#line 193
    str_rsrc[3].name[tmp___29] = (char)0;
#line 193
    tmp___29 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 193
  str_rsrc[3].value[0] = (char)0;
#line 193
  str_rsrc[3].value[1] = (char)0;
#line 193
  str_rsrc[3].value[2] = (char)0;
#line 193
  str_rsrc[3].value[3] = (char)0;
#line 193
  str_rsrc[3].value[4] = (char)0;
#line 193
  str_rsrc[3].value[5] = (char)0;
#line 193
  str_rsrc[3].value[6] = (char)0;
#line 193
  str_rsrc[3].value[7] = (char)0;
#line 193
  str_rsrc[3].value[8] = (char)0;
#line 193
  str_rsrc[3].value[9] = (char)0;
#line 193
  str_rsrc[3].value[10] = (char)0;
#line 193
  str_rsrc[3].value[11] = (char)0;
#line 193
  str_rsrc[3].value[12] = (char)0;
#line 193
  str_rsrc[3].value[13] = (char)0;
#line 193
  str_rsrc[3].value[14] = (char)0;
#line 193
  str_rsrc[3].value[15] = (char)0;
#line 193
  str_rsrc[3].value[16] = (char)0;
#line 193
  str_rsrc[3].value[17] = (char)0;
#line 193
  str_rsrc[3].value[18] = (char)0;
#line 193
  str_rsrc[3].value[19] = (char)0;
#line 193
  str_rsrc[3].value[20] = (char)0;
#line 193
  str_rsrc[3].value[21] = (char)0;
#line 193
  str_rsrc[3].value[22] = (char)0;
#line 193
  str_rsrc[3].value[23] = (char)0;
#line 193
  str_rsrc[3].value[24] = (char)0;
#line 193
  str_rsrc[3].value[25] = (char)0;
#line 193
  str_rsrc[3].value[26] = (char)0;
#line 193
  str_rsrc[3].value[27] = (char)0;
#line 193
  str_rsrc[3].value[28] = (char)0;
#line 193
  str_rsrc[3].value[29] = (char)0;
#line 193
  str_rsrc[3].value[30] = (char)0;
#line 193
  str_rsrc[3].value[31] = (char)0;
#line 193
  str_rsrc[3].value_len = 0;
#line 202
  psf_use_rsrc(psf, 1);
#line 204
  memset((void *)(& rsrc), 0, sizeof(rsrc));
#line 206
  rsrc.sample_rate = psf->sf.samplerate;
#line 207
  rsrc.sample_size = psf->bytewidth;
#line 208
  rsrc.channels = psf->sf.channels;
#line 210
  rsrc.rsrc_data = psf->header.ptr;
#line 211
  rsrc.rsrc_len = (int )psf->header.len;
#line 212
  memset((void *)rsrc.rsrc_data, 234, (unsigned long )rsrc.rsrc_len);
#line 214
  snprintf(str_rsrc[0].value, sizeof(str_rsrc[0].value), "_%dF\270U", rsrc.sample_size);
#line 215
  snprintf(str_rsrc[1].value, sizeof(str_rsrc[1].value), "_%d.000000", rsrc.sample_rate);
#line 216
  snprintf(str_rsrc[2].value, sizeof(str_rsrc[2].value), "_%dF\270U", rsrc.channels);
#line 218
  k = 0;
  }
  {
#line 218
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 218
    if (! (k < (int )(sizeof(str_rsrc) / sizeof(str_rsrc[0])))) {
#line 218
      goto while_break___3;
    }
#line 219
    if (str_rsrc[k].value_len == 0) {
      {
#line 220
      __cil_tmp13 = strlen((char const   *)(str_rsrc[k].value));
#line 220
      str_rsrc[k].value_len = (int )__cil_tmp13;
#line 221
      str_rsrc[k].value[0] = (char )(str_rsrc[k].value_len - 1);
      }
    }
    {
#line 225
    __cil_tmp14 = strlen((char const   *)(str_rsrc[k].name));
#line 225
    str_rsrc[k].name[0] = (char )(__cil_tmp14 - 1UL);
#line 218
    k ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___3: 
#line 228
  rsrc.data_offset = 256;
#line 234
  rsrc.data_length = 0;
#line 235
  k = 0;
  {
#line 235
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 235
    if (! (k < (int )(sizeof(str_rsrc) / sizeof(str_rsrc[0])))) {
#line 235
      goto while_break___4;
    }
#line 236
    rsrc.data_length += str_rsrc[k].value_len + 4;
#line 235
    k ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___4: 
  {
#line 238
  rsrc.map_offset = rsrc.data_offset + rsrc.data_length;
#line 241
  psf_binheader_writef(psf, "E444", rsrc.data_offset, rsrc.map_offset, rsrc.data_length);
#line 243
  __cil_tmp17 = make_size_t(48);
#line 243
  psf_binheader_writef(psf, "Eop", __cil_tmp17, psf->file.name.c);
#line 244
  __cil_tmp18 = make_size_t(80);
#line 244
  psf_binheader_writef(psf, "Eo2mm", __cil_tmp18, 0, (unsigned int )((83 | (100 << 8)) | (50 << 16)) | (102U << 24),
                       (unsigned int )((108 | (115 << 8)) | (102 << 16)) | (49U << 24));
#line 247
  __cil_tmp19 = make_size_t(rsrc.map_offset);
#line 247
  psf_binheader_writef(psf, "E444", __cil_tmp19, rsrc.data_offset, rsrc.map_offset,
                       rsrc.data_length);
#line 251
  __cil_tmp20 = make_size_t(rsrc.map_offset + 16);
#line 251
  psf_binheader_writef(psf, "Eo1422", __cil_tmp20, 1, 305419896, 43981, 0);
#line 255
  rsrc.type_offset = rsrc.map_offset + 30;
#line 256
  __cil_tmp21 = make_size_t(rsrc.map_offset + 24);
#line 256
  psf_binheader_writef(psf, "Eo2", __cil_tmp21, (rsrc.type_offset - rsrc.map_offset) - 2);
#line 259
  rsrc.type_count = 2;
#line 260
  __cil_tmp22 = make_size_t(rsrc.map_offset + 28);
#line 260
  psf_binheader_writef(psf, "Eo2", __cil_tmp22, rsrc.type_count - 1);
#line 262
  rsrc.item_offset = rsrc.type_offset + rsrc.type_count * 8;
#line 264
  rsrc.str_count = (int )(sizeof(str_rsrc) / sizeof(str_rsrc[0]));
#line 265
  rsrc.string_offset = (rsrc.item_offset + (rsrc.str_count + 1) * 12) - rsrc.map_offset;
#line 266
  __cil_tmp23 = make_size_t(rsrc.map_offset + 26);
#line 266
  psf_binheader_writef(psf, "Eo2", __cil_tmp23, rsrc.string_offset);
#line 269
  rsrc.str_count = 3;
#line 270
  __cil_tmp24 = make_size_t(rsrc.type_offset);
#line 270
  psf_binheader_writef(psf, "Eom22", __cil_tmp24, (unsigned int )((83 | (84 << 8)) | (82 << 16)) | (32U << 24),
                       rsrc.str_count - 1, 18);
#line 273
  psf_binheader_writef(psf, "Em22", (unsigned int )((115 | (100 << 8)) | (77 << 16)) | (76U << 24),
                       0, 54);
#line 275
  str_offset = rsrc.map_offset + rsrc.string_offset;
#line 276
  next_str = 0;
#line 277
  data_offset = rsrc.data_offset;
#line 278
  k = 0;
  }
  {
#line 278
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 278
    if (! (k < (int )(sizeof(str_rsrc) / sizeof(str_rsrc[0])))) {
#line 278
      goto while_break___5;
    }
    {
#line 279
    __cil_tmp25 = make_size_t(str_offset);
#line 279
    psf_binheader_writef(psf, "Eop", __cil_tmp25, str_rsrc[k].name);
#line 280
    __cil_tmp26 = make_size_t(rsrc.item_offset + k * 12);
#line 280
    psf_binheader_writef(psf, "Eo22", __cil_tmp26, str_rsrc[k].id, next_str);
#line 282
    __cil_tmp27 = strlen((char const   *)(str_rsrc[k].name));
#line 282
    str_offset = (int )((unsigned long )str_offset + __cil_tmp27);
#line 283
    __cil_tmp28 = strlen((char const   *)(str_rsrc[k].name));
#line 283
    next_str = (int )((unsigned long )next_str + __cil_tmp28);
#line 285
    __cil_tmp29 = make_size_t((rsrc.item_offset + k * 12) + 4);
#line 285
    psf_binheader_writef(psf, "Eo4", __cil_tmp29, data_offset - rsrc.data_offset);
#line 286
    __cil_tmp30 = make_size_t(data_offset);
#line 286
    psf_binheader_writef(psf, "Eo4", __cil_tmp30, str_rsrc[k].value_len);
#line 288
    __cil_tmp31 = make_size_t(data_offset + 4);
#line 288
    __cil_tmp32 = make_size_t(str_rsrc[k].value_len);
#line 288
    psf_binheader_writef(psf, "Eob", __cil_tmp31, str_rsrc[k].value, __cil_tmp32);
#line 289
    data_offset += 4 + str_rsrc[k].value_len;
#line 278
    k ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___5: 
  {
#line 293
  rsrc.map_length = str_offset - rsrc.map_offset;
#line 294
  __cil_tmp34 = make_size_t(12);
#line 294
  __cil_tmp35 = make_size_t(rsrc.map_offset + 12);
#line 294
  psf_binheader_writef(psf, "Eo4o4", __cil_tmp34, rsrc.map_length, __cil_tmp35, rsrc.map_length);
#line 297
  psf->header.indx = (sf_count_t )(rsrc.map_offset + rsrc.map_length);
#line 299
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
#line 301
  psf_use_rsrc(psf, 0);
  }
#line 303
  if (psf->error) {
#line 304
    return (psf->error);
  }
#line 306
  return (0);
}
}
#line 313 "/root/patchweave_new/23/src/sd2.c"
__inline static int read_rsrc_char(SD2_RSRC *prsrc , int offset ) 
{ 
  unsigned char const   *data ;

  {
#line 314
  data = (unsigned char const   *)prsrc->rsrc_data;
#line 315
  if (offset < 0) {
#line 316
    return (0);
  } else
#line 315
  if (offset >= prsrc->rsrc_len) {
#line 316
    return (0);
  }
#line 317
  return ((int )*(data + offset));
}
}
#line 321 "/root/patchweave_new/23/src/sd2.c"
__inline static int read_rsrc_short(SD2_RSRC *prsrc , int offset ) 
{ 
  unsigned char const   *data ;

  {
#line 322
  data = (unsigned char const   *)prsrc->rsrc_data;
#line 323
  if (offset < 0) {
#line 324
    return (0);
  } else
#line 323
  if (offset + 1 >= prsrc->rsrc_len) {
#line 324
    return (0);
  }
#line 325
  return (((int )*(data + offset) << 8) + (int )*(data + (offset + 1)));
}
}
#line 329 "/root/patchweave_new/23/src/sd2.c"
__inline static int read_rsrc_int(SD2_RSRC *prsrc , int offset ) 
{ 
  unsigned char const   *data ;

  {
#line 330
  data = (unsigned char const   *)prsrc->rsrc_data;
#line 331
  if (offset < 0) {
#line 332
    return (0);
  } else
#line 331
  if (offset + 3 >= prsrc->rsrc_len) {
#line 332
    return (0);
  }
#line 333
  return ((int )(((((uint32_t )*(data + offset) << 24) + (unsigned int )((int )*(data + (offset + 1)) << 16)) + (unsigned int )((int )*(data + (offset + 2)) << 8)) + (unsigned int )*(data + (offset + 3))));
}
}
#line 337 "/root/patchweave_new/23/src/sd2.c"
__inline static int read_rsrc_marker(SD2_RSRC *prsrc , int offset ) 
{ 
  unsigned char const   *data ;

  {
#line 338
  data = (unsigned char const   *)prsrc->rsrc_data;
#line 340
  if (offset < 0) {
#line 341
    return (0);
  } else
#line 340
  if (offset + 3 >= prsrc->rsrc_len) {
#line 341
    return (0);
  }
#line 346
  return ((int )((unsigned int )(((int )*(data + offset) + ((int )*(data + (offset + 1)) << 8)) + ((int )*(data + (offset + 2)) << 16)) + ((uint32_t )*(data + (offset + 3)) << 24)));
#line 348
  return (0);
}
}
#line 352 "/root/patchweave_new/23/src/sd2.c"
static void read_rsrc_str(SD2_RSRC *prsrc , int offset , char *buffer , int buffer_len ) 
{ 
  unsigned char const   *data ;
  int k ;
  int __cil_tmp7 ;

  {
  {
#line 353
  data = (unsigned char const   *)prsrc->rsrc_data;
#line 356
  memset((void *)buffer, 0, (unsigned long )buffer_len);
  }
#line 358
  if (offset < 0) {
#line 359
    return;
  } else
#line 358
  if (offset + buffer_len >= prsrc->rsrc_len) {
#line 359
    return;
  }
#line 361
  k = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;

#line 361
    if (! (k < buffer_len - 1)) {
#line 361
      goto while_break;
    }
    {
#line 362
    __cil_tmp7 = psf_isprint((int )*(data + (offset + k)));
    }
#line 362
    if (__cil_tmp7 == 0) {
#line 363
      return;
    }
#line 364
    *(buffer + k) = (char )*(data + (offset + k));
#line 361
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 366
  return;
}
}
#line 370 "/root/patchweave_new/23/src/sd2.c"
static int sd2_parse_rsrc_fork(SF_PRIVATE *psf ) 
{ 
  SD2_RSRC rsrc ;
  int k ;
  int marker ;
  int error ;
  sf_count_t __cil_tmp6 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp19 ;
  void *tmp ;

  {
  {
#line 372
  error = 0;
#line 374
  psf_use_rsrc(psf, 1);
#line 376
  memset((void *)(& rsrc), 0, sizeof(rsrc));
#line 378
  __cil_tmp6 = psf_get_filelen(psf);
#line 378
  rsrc.rsrc_len = (int )__cil_tmp6;
#line 379
  psf_log_printf(psf, "Resource length : %d (0x%04X)\n", rsrc.rsrc_len, rsrc.rsrc_len);
  }
#line 381
  if ((long )rsrc.rsrc_len > psf->header.len) {
    {
#line 382
    tmp = calloc(1UL, (unsigned long )rsrc.rsrc_len);
#line 382
    rsrc.rsrc_data = (unsigned char *)tmp;
#line 383
    rsrc.need_to_free_rsrc_data = 1;
    }
  } else {
#line 387
    rsrc.rsrc_data = psf->header.ptr;
#line 389
    rsrc.need_to_free_rsrc_data = 0;
  }
  {
#line 393
  psf_fread((void *)rsrc.rsrc_data, (sf_count_t )rsrc.rsrc_len, (sf_count_t )1, psf);
#line 396
  psf->header.end = (sf_count_t )rsrc.rsrc_len;
#line 396
  psf->header.indx = psf->header.end;
#line 398
  rsrc.data_offset = read_rsrc_int(& rsrc, 0);
#line 399
  rsrc.map_offset = read_rsrc_int(& rsrc, 4);
#line 400
  rsrc.data_length = read_rsrc_int(& rsrc, 8);
#line 401
  rsrc.map_length = read_rsrc_int(& rsrc, 12);
  }
#line 403
  if (rsrc.data_offset == 333319) {
#line 403
    if (rsrc.map_offset == 131072) {
      {
#line 404
      psf_log_printf(psf, "Trying offset of 0x52 bytes.\n");
#line 405
      __cil_tmp12 = read_rsrc_int(& rsrc, 82);
#line 405
      rsrc.data_offset = __cil_tmp12 + 82;
#line 406
      __cil_tmp13 = read_rsrc_int(& rsrc, 86);
#line 406
      rsrc.map_offset = __cil_tmp13 + 82;
#line 407
      rsrc.data_length = read_rsrc_int(& rsrc, 90);
#line 408
      rsrc.map_length = read_rsrc_int(& rsrc, 94);
      }
    }
  }
  {
#line 411
  psf_log_printf(psf, "  data offset : 0x%04X\n  map  offset : 0x%04X\n  data length : 0x%04X\n  map  length : 0x%04X\n\230\001",
                 rsrc.data_offset, rsrc.map_offset, rsrc.data_length, rsrc.map_length);
  }
#line 415
  if (rsrc.data_offset > rsrc.rsrc_len) {
    {
#line 416
    psf_log_printf(psf, "Error : rsrc.data_offset (%d, 0x%x) > len\n", rsrc.data_offset,
                   rsrc.data_offset);
#line 417
    error = 148;
    }
#line 418
    goto parse_rsrc_fork_cleanup;
  }
#line 421
  if (rsrc.map_offset > rsrc.rsrc_len) {
    {
#line 422
    psf_log_printf(psf, "Error : rsrc.map_offset > len\n");
#line 423
    error = 149;
    }
#line 424
    goto parse_rsrc_fork_cleanup;
  }
#line 427
  if (rsrc.data_length > rsrc.rsrc_len) {
    {
#line 428
    psf_log_printf(psf, "Error : rsrc.data_length > len\n");
#line 429
    error = 150;
    }
#line 430
    goto parse_rsrc_fork_cleanup;
  }
#line 433
  if (rsrc.map_length > rsrc.rsrc_len) {
    {
#line 434
    psf_log_printf(psf, "Error : rsrc.map_length > len\n");
#line 435
    error = 151;
    }
#line 436
    goto parse_rsrc_fork_cleanup;
  }
#line 439
  if (rsrc.data_offset + rsrc.data_length != rsrc.map_offset) {
    {
#line 440
    psf_log_printf(psf, "Error : This does not look like a MacOSX resource fork.\n\220");
#line 441
    error = 152;
    }
#line 442
    goto parse_rsrc_fork_cleanup;
  } else
#line 439
  if (rsrc.map_offset + rsrc.map_length != rsrc.rsrc_len) {
    {
#line 440
    psf_log_printf(psf, "Error : This does not look like a MacOSX resource fork.\n\220");
#line 441
    error = 152;
    }
#line 442
    goto parse_rsrc_fork_cleanup;
  }
#line 445
  if (rsrc.map_offset + 28 >= rsrc.rsrc_len) {
    {
#line 446
    psf_log_printf(psf, "Bad map offset (%d + 28 > %d).\n", rsrc.map_offset, rsrc.rsrc_len);
#line 447
    error = 152;
    }
#line 448
    goto parse_rsrc_fork_cleanup;
  }
  {
#line 451
  __cil_tmp16 = read_rsrc_short(& rsrc, rsrc.map_offset + 26);
#line 451
  rsrc.string_offset = rsrc.map_offset + __cil_tmp16;
  }
#line 452
  if (rsrc.string_offset > rsrc.rsrc_len) {
    {
#line 453
    psf_log_printf(psf, "Bad string offset (%d).\n\230\001", rsrc.string_offset);
#line 454
    error = 152;
    }
#line 455
    goto parse_rsrc_fork_cleanup;
  }
#line 458
  rsrc.type_offset = rsrc.map_offset + 30;
#line 460
  if (rsrc.map_offset + 28 > rsrc.rsrc_len) {
    {
#line 461
    psf_log_printf(psf, "Bad map offset.\n\220");
    }
#line 462
    goto parse_rsrc_fork_cleanup;
  }
  {
#line 465
  __cil_tmp17 = read_rsrc_short(& rsrc, rsrc.map_offset + 28);
#line 465
  rsrc.type_count = __cil_tmp17 + 1;
  }
#line 466
  if (rsrc.type_count < 1) {
    {
#line 467
    psf_log_printf(psf, "Bad type count.\n\220");
#line 468
    error = 152;
    }
#line 469
    goto parse_rsrc_fork_cleanup;
  }
#line 472
  rsrc.item_offset = rsrc.type_offset + rsrc.type_count * 8;
#line 473
  if (rsrc.item_offset < 0) {
    {
#line 474
    psf_log_printf(psf, "Bad item offset (%d).\n", rsrc.item_offset);
#line 475
    error = 152;
    }
#line 476
    goto parse_rsrc_fork_cleanup;
  } else
#line 473
  if (rsrc.item_offset > rsrc.rsrc_len) {
    {
#line 474
    psf_log_printf(psf, "Bad item offset (%d).\n", rsrc.item_offset);
#line 475
    error = 152;
    }
#line 476
    goto parse_rsrc_fork_cleanup;
  }
#line 479
  rsrc.str_index = -1;
#line 480
  k = 0;
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;

#line 480
    if (! (k < rsrc.type_count)) {
#line 480
      goto while_break;
    }
#line 481
    if (rsrc.type_offset + k * 8 > rsrc.rsrc_len) {
      {
#line 482
      psf_log_printf(psf, "Bad rsrc marker.\n");
      }
#line 483
      goto parse_rsrc_fork_cleanup;
    }
    {
#line 486
    marker = read_rsrc_marker(& rsrc, rsrc.type_offset + k * 8);
    }
#line 488
    if ((unsigned int )marker == ((unsigned int )((83 | (84 << 8)) | (82 << 16)) | (32U << 24))) {
      {
#line 489
      rsrc.str_index = k;
#line 490
      __cil_tmp19 = read_rsrc_short(& rsrc, (rsrc.type_offset + k * 8) + 4);
#line 490
      rsrc.str_count = __cil_tmp19 + 1;
#line 491
      error = parse_str_rsrc(psf, & rsrc);
      }
#line 492
      goto parse_rsrc_fork_cleanup;
    }
#line 480
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 496
  psf_log_printf(psf, "No \'STR \' resource.\n");
#line 497
  error = 152;
  }
  parse_rsrc_fork_cleanup: 
  {
#line 501
  psf_use_rsrc(psf, 0);
  }
#line 503
  if (rsrc.need_to_free_rsrc_data) {
    {
#line 504
    free((void *)rsrc.rsrc_data);
    }
  }
#line 506
  return (error);
}
}
#line 510 "/root/patchweave_new/23/src/sd2.c"
static int parse_str_rsrc(SF_PRIVATE *psf , SD2_RSRC *rsrc ) 
{ 
  char name[32] ;
  char value___0[32] ;
  int k ;
  int str_offset ;
  int rsrc_id ;
  int data_offset ;
  int data_len ;
  int slen ;
  int __cil_tmp13 ;
  long __cil_tmp16 ;
  long __cil_tmp17 ;
  long __cil_tmp18 ;
  int temp ;

  {
  {
#line 512
  data_offset = 0;
#line 512
  data_len = 0;
#line 514
  psf_log_printf(psf, "Finding parameters :\n");
#line 516
  str_offset = rsrc->string_offset;
#line 517
  psf_log_printf(psf, "  Offset    RsrcId    dlen    slen    Value\n");
#line 519
  k = 0;
  }
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;

#line 519
    if (! (data_offset + data_len < rsrc->rsrc_len)) {
#line 519
      goto while_break;
    }
    {
#line 522
    slen = read_rsrc_char(rsrc, str_offset);
#line 523
    read_rsrc_str(rsrc, str_offset + 1, name, 0);
#line 524
    str_offset += slen + 1;
#line 526
    rsrc_id = read_rsrc_short(rsrc, rsrc->item_offset + k * 12);
#line 528
    __cil_tmp13 = read_rsrc_int(rsrc, (rsrc->item_offset + k * 12) + 4);
#line 528
    data_offset = rsrc->data_offset + __cil_tmp13;
    }
#line 529
    if (data_offset < 0) {
      {
#line 530
      psf_log_printf(psf, "Exiting parser on data offset of %d.\nU", data_offset);
      }
#line 531
      goto while_break;
    } else
#line 529
    if (data_offset > rsrc->rsrc_len) {
      {
#line 530
      psf_log_printf(psf, "Exiting parser on data offset of %d.\nU", data_offset);
      }
#line 531
      goto while_break;
    }
    {
#line 534
    data_len = read_rsrc_int(rsrc, data_offset);
    }
#line 535
    if (data_len < 0) {
      {
#line 536
      psf_log_printf(psf, "Exiting parser on data length of %d.\n", data_len);
      }
#line 537
      goto while_break;
    } else
#line 535
    if (data_len > rsrc->rsrc_len) {
      {
#line 536
      psf_log_printf(psf, "Exiting parser on data length of %d.\n", data_len);
      }
#line 537
      goto while_break;
    }
    {
#line 540
    slen = read_rsrc_char(rsrc, data_offset + 4);
#line 541
    read_rsrc_str(rsrc, data_offset + 5, value___0, 0);
#line 543
    psf_log_printf(psf, "  0x%04x     %4d     %4d     %3d    \'%s\'\n\263\245F\270U",
                   data_offset, rsrc_id, data_len, slen, value___0);
    }
#line 545
    if (rsrc_id == 1000) {
#line 545
      if (rsrc->sample_size == 0) {
        {
#line 546
        __cil_tmp16 = strtol((char const   *)(value___0), (char **)((void *)0), 10);
#line 546
        rsrc->sample_size = (int )__cil_tmp16;
        }
      } else {
#line 545
        goto _L___30;
      }
    } else
    _L___30: 
#line 547
    if (rsrc_id == 1001) {
#line 547
      if (rsrc->sample_rate == 0) {
        {
#line 548
        __cil_tmp17 = strtol((char const   *)(value___0), (char **)((void *)0), 10);
#line 548
        rsrc->sample_rate = (int )__cil_tmp17;
        }
      } else {
#line 547
        goto _L;
      }
    } else
    _L: 
#line 549
    if (rsrc_id == 1002) {
#line 549
      if (rsrc->channels == 0) {
        {
#line 550
        __cil_tmp18 = strtol((char const   *)(value___0), (char **)((void *)0), 10);
#line 550
        rsrc->channels = (int )__cil_tmp18;
        }
      }
    }
#line 519
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 553
  psf_log_printf(psf, "Found Parameters :\nF\270U");
#line 554
  psf_log_printf(psf, "  sample-size : %d\nF\270U", rsrc->sample_size);
#line 555
  psf_log_printf(psf, "  sample-rate : %d\nF\270U", rsrc->sample_rate);
#line 556
  psf_log_printf(psf, "  channels    : %d\nF\270U", rsrc->channels);
  }
#line 558
  if (rsrc->sample_rate <= 4) {
#line 558
    if (rsrc->sample_size > 4) {
      {
#line 561
      psf_log_printf(psf, "Geez!! Looks like sample rate and sample size got switched.\nCorrecting this screw up.\n");
#line 562
      temp = rsrc->sample_rate;
#line 563
      rsrc->sample_rate = rsrc->sample_size;
#line 564
      rsrc->sample_size = temp;
      }
    }
  }
#line 567
  if (rsrc->sample_rate < 0) {
    {
#line 568
    psf_log_printf(psf, "Bad sample rate (%d)\nU", rsrc->sample_rate);
    }
#line 569
    return (152);
  }
#line 572
  if (rsrc->channels < 0) {
    {
#line 573
    psf_log_printf(psf, "Bad channel count (%d)\n", rsrc->channels);
    }
#line 574
    return (152);
  }
#line 577
  psf->sf.samplerate = rsrc->sample_rate;
#line 578
  psf->sf.channels = rsrc->channels;
#line 579
  psf->bytewidth = rsrc->sample_size;
#line 582
  if (rsrc->sample_size == 1) {
#line 582
    goto case_1;
  }
#line 586
  if (rsrc->sample_size == 2) {
#line 586
    goto case_2;
  }
#line 590
  if (rsrc->sample_size == 3) {
#line 590
    goto case_3;
  }
#line 594
  if (rsrc->sample_size == 4) {
#line 594
    goto case_4;
  }
#line 598
  goto switch_default;
  case_1: 
#line 583
  psf->sf.format = 1441793;
#line 584
  goto switch_break;
  case_2: 
#line 587
  psf->sf.format = 1441794;
#line 588
  goto switch_break;
  case_3: 
#line 591
  psf->sf.format = 1441795;
#line 592
  goto switch_break;
  case_4: 
#line 595
  psf->sf.format = 1441796;
#line 596
  goto switch_break;
  switch_default: 
  {
#line 599
  psf_log_printf(psf, "Bad sample size (%d)\n", rsrc->sample_size);
  }
#line 600
  return (153);
  switch_break: 
  {
#line 603
  psf_log_printf(psf, "ok\nF\270U");
  }
#line 605
  return (0);
}
}
#line 33 "/root/patchweave_new/23/src/rx2.c"
int rx2_open(SF_PRIVATE *psf ) 
{ 


  {
#line 34
  if (psf) {
#line 35
    return (18);
  }
#line 36
  return (0);
}
}
#line 31 "/root/patchweave_new/23/src/raw.c"
int raw_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;

  {
#line 32
  error = 0;
#line 34
  subformat = psf->sf.format & 65535;
#line 36
  psf->endian = psf->sf.format & 805306368;
#line 40
  if (psf->endian == 0) {
#line 41
    psf->endian = 268435456;
  } else
#line 40
  if (psf->endian == 805306368) {
#line 41
    psf->endian = 268435456;
  }
#line 43
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 44
  psf->dataoffset = (sf_count_t )0;
#line 45
  psf->datalength = psf->filelength;
#line 48
  if (subformat == 1) {
#line 48
    goto case_1;
  }
#line 52
  if (subformat == 5) {
#line 52
    goto case_5;
  }
#line 58
  if (subformat == 4) {
#line 58
    goto case_4;
  }
#line 58
  if (subformat == 3) {
#line 58
    goto case_4;
  }
#line 58
  if (subformat == 2) {
#line 58
    goto case_4;
  }
#line 62
  if (subformat == 16) {
#line 62
    goto case_16;
  }
#line 66
  if (subformat == 17) {
#line 66
    goto case_17;
  }
#line 70
  if (subformat == 32) {
#line 70
    goto case_32;
  }
#line 75
  if (subformat == 6) {
#line 75
    goto case_6;
  }
#line 79
  if (subformat == 7) {
#line 79
    goto case_7;
  }
#line 83
  if (subformat == 64) {
#line 83
    goto case_64;
  }
#line 87
  if (subformat == 65) {
#line 87
    goto case_65;
  }
#line 91
  if (subformat == 66) {
#line 91
    goto case_66;
  }
#line 95
  if (subformat == 33) {
#line 95
    goto case_33;
  }
#line 100
  goto switch_default;
  case_1: 
  {
#line 49
  error = pcm_init(psf);
  }
#line 50
  goto switch_break;
  case_5: 
  {
#line 53
  error = pcm_init(psf);
  }
#line 54
  goto switch_break;
  case_4: 
  {
#line 59
  error = pcm_init(psf);
  }
#line 60
  goto switch_break;
  case_16: 
  {
#line 63
  error = ulaw_init(psf);
  }
#line 64
  goto switch_break;
  case_17: 
  {
#line 67
  error = alaw_init(psf);
  }
#line 68
  goto switch_break;
  case_32: 
  {
#line 71
  error = gsm610_init(psf);
  }
#line 72
  goto switch_break;
  case_6: 
  {
#line 76
  error = float32_init(psf);
  }
#line 77
  goto switch_break;
  case_7: 
  {
#line 80
  error = double64_init(psf);
  }
#line 81
  goto switch_break;
  case_64: 
  {
#line 84
  error = dwvw_init(psf, 12);
  }
#line 85
  goto switch_break;
  case_65: 
  {
#line 88
  error = dwvw_init(psf, 16);
  }
#line 89
  goto switch_break;
  case_66: 
  {
#line 92
  error = dwvw_init(psf, 24);
  }
#line 93
  goto switch_break;
  case_33: 
  {
#line 96
  error = vox_adpcm_init(psf);
  }
#line 97
  goto switch_break;
  switch_default: 
#line 100
  return (1);
  switch_break: ;
#line 103
  return (error);
}
}
#line 40 "/root/patchweave_new/23/src/pvf.c"
static int pvf_close(SF_PRIVATE *UNUSED_psf ) ;
#line 42
static int pvf_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 43
static int pvf_read_header(SF_PRIVATE *psf ) ;
#line 50 "/root/patchweave_new/23/src/pvf.c"
int pvf_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int __cil_tmp5 ;

  {
#line 52
  error = 0;
#line 54
  if (psf->file.mode == 16) {
    _L: 
    {
#line 55
    error = pvf_read_header(psf);
    }
#line 55
    if (error) {
#line 56
      return (error);
    }
  } else
#line 54
  if (psf->file.mode == 48) {
#line 54
    if (psf->filelength > 0L) {
#line 54
      goto _L;
    }
  }
#line 59
  subformat = psf->sf.format & 65535;
#line 61
  if (psf->file.mode == 32) {
    _L___31: 
#line 62
    if ((psf->sf.format & 268369920) != 917504) {
#line 63
      return (1);
    }
    {
#line 65
    psf->endian = 536870912;
#line 67
    __cil_tmp5 = pvf_write_header(psf, 0);
    }
#line 67
    if (__cil_tmp5) {
#line 68
      return (psf->error);
    }
#line 70
    psf->write_header = & pvf_write_header;
  } else
#line 61
  if (psf->file.mode == 48) {
#line 61
    goto _L___31;
  }
#line 73
  psf->container_close = & pvf_close;
#line 75
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 80
  if (subformat == 4) {
#line 80
    goto case_4;
  }
#line 80
  if (subformat == 2) {
#line 80
    goto case_4;
  }
#line 80
  if (subformat == 1) {
#line 80
    goto case_4;
  }
#line 84
  goto switch_default;
  case_4: 
  {
#line 81
  error = pcm_init(psf);
  }
#line 82
  goto switch_break;
  switch_default: 
#line 84
  goto switch_break;
  switch_break: ;
#line 87
  return (error);
}
}
#line 94 "/root/patchweave_new/23/src/pvf.c"
static int pvf_close(SF_PRIVATE *UNUSED_psf ) 
{ 


  {
#line 96
  return (0);
}
}
#line 100 "/root/patchweave_new/23/src/pvf.c"
static int pvf_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  sf_count_t current ;
  unsigned long __cil_tmp5 ;

  {
#line 103
  if (psf->pipeoffset > 0L) {
#line 104
    return (0);
  }
  {
#line 106
  current = psf_ftell(psf);
#line 109
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 110
  psf->header.indx = (sf_count_t )0;
  }
#line 112
  if (psf->is_pipe == 0) {
    {
#line 113
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
  {
#line 115
  snprintf((char *)psf->header.ptr, (unsigned long )psf->header.len, "PVF1\n%d %d %d\n",
           psf->sf.channels, psf->sf.samplerate, psf->bytewidth * 8);
#line 118
  __cil_tmp5 = strlen((char const   *)((char *)psf->header.ptr));
#line 118
  psf->header.indx = (sf_count_t )__cil_tmp5;
#line 121
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 123
  if (psf->error) {
#line 124
    return (psf->error);
  }
#line 126
  psf->dataoffset = psf->header.indx;
#line 128
  if (current > 0L) {
    {
#line 129
    psf_fseek(psf, current, 0);
    }
  }
#line 131
  return (psf->error);
}
}
#line 135 "/root/patchweave_new/23/src/pvf.c"
static int pvf_read_header(SF_PRIVATE *psf ) 
{ 
  char buffer[32] ;
  int marker ;
  int channels ;
  int samplerate ;
  int bitwidth ;
  int __cil_tmp7 ;

  {
  {
#line 139
  psf_binheader_readf(psf, "pmj", 0, & marker, 1);
#line 140
  psf_log_printf(psf, "%M\n", marker);
  }
#line 142
  if ((unsigned int )marker != ((unsigned int )((80 | (86 << 8)) | (70 << 16)) | (49U << 24))) {
#line 143
    return (136);
  }
  {
#line 146
  psf_binheader_readf(psf, "G", buffer, sizeof(buffer));
#line 148
  __cil_tmp7 = sscanf((char const   *)(buffer), "%d %d %d\230\001", & channels, & samplerate,
                      & bitwidth);
  }
#line 148
  if (__cil_tmp7 != 3) {
#line 149
    return (137);
  }
  {
#line 151
  psf_log_printf(psf, " Channels    : %d\n Sample rate : %d\n Bit width   : %d\n",
                 channels, samplerate, bitwidth);
#line 154
  psf->sf.channels = channels;
#line 155
  psf->sf.samplerate = samplerate;
  }
#line 158
  if (bitwidth == 8) {
#line 158
    goto case_8;
  }
#line 163
  if (bitwidth == 16) {
#line 163
    goto case_16;
  }
#line 167
  if (bitwidth == 32) {
#line 167
    goto case_32;
  }
#line 172
  goto switch_default;
  case_8: 
#line 159
  psf->sf.format = 917505;
#line 160
  psf->bytewidth = 1;
#line 161
  goto switch_break;
  case_16: 
#line 164
  psf->sf.format = 917506;
#line 165
  psf->bytewidth = 2;
#line 166
  goto switch_break;
  case_32: 
#line 168
  psf->sf.format = 917508;
#line 169
  psf->bytewidth = 4;
#line 170
  goto switch_break;
  switch_default: 
#line 173
  return (138);
  switch_break: 
  {
#line 176
  psf->dataoffset = psf_ftell(psf);
#line 177
  psf_log_printf(psf, " Data Offset : %D\n\372F\270U", psf->dataoffset);
#line 179
  psf->endian = 536870912;
#line 181
  psf->datalength = psf->filelength - psf->dataoffset;
#line 182
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
  }
#line 184
  if (! psf->sf.frames) {
#line 184
    if (psf->blockwidth) {
#line 185
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    }
  }
#line 187
  return (0);
}
}
#line 74 "/root/patchweave_new/23/src/paf.c"
static int paf24_init(SF_PRIVATE *psf ) ;
#line 76
static int paf_read_header(SF_PRIVATE *psf ) ;
#line 77
static int paf_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 79
static sf_count_t paf24_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 80
static sf_count_t paf24_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 81
static sf_count_t paf24_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 82
static sf_count_t paf24_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 84
static sf_count_t paf24_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 85
static sf_count_t paf24_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 86
static sf_count_t paf24_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 87
static sf_count_t paf24_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 89
static sf_count_t paf24_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 102 "/root/patchweave_new/23/src/paf.c"
int paf_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int endian ;

  {
#line 105
  psf->dataoffset = (sf_count_t )2048;
#line 107
  if (psf->file.mode == 16) {
    _L: 
    {
#line 108
    error = paf_read_header(psf);
    }
#line 108
    if (error) {
#line 109
      return (error);
    }
  } else
#line 107
  if (psf->file.mode == 48) {
#line 107
    if (psf->filelength > 0L) {
#line 107
      goto _L;
    }
  }
#line 112
  subformat = psf->sf.format & 65535;
#line 114
  if (psf->file.mode == 32) {
    _L___32: 
#line 115
    if ((psf->sf.format & 268369920) != 327680) {
#line 116
      return (1);
    }
#line 118
    endian = psf->sf.format & 805306368;
#line 121
    psf->endian = 536870912;
#line 123
    if (endian == 268435456) {
#line 124
      psf->endian = 268435456;
    } else
#line 123
    if (endian == 805306368) {
#line 124
      psf->endian = 268435456;
    }
    {
#line 126
    error = paf_write_header(psf, 0);
    }
#line 126
    if (error) {
#line 127
      return (error);
    }
#line 129
    psf->write_header = & paf_write_header;
  } else
#line 114
  if (psf->file.mode == 48) {
#line 114
    goto _L___32;
  }
#line 133
  if (subformat == 1) {
#line 133
    goto case_1;
  }
#line 138
  if (subformat == 2) {
#line 138
    goto case_2;
  }
#line 143
  if (subformat == 3) {
#line 143
    goto case_3;
  }
#line 148
  goto switch_default;
  case_1: 
  {
#line 134
  psf->bytewidth = 1;
#line 135
  error = pcm_init(psf);
  }
#line 136
  goto switch_break;
  case_2: 
  {
#line 139
  psf->bytewidth = 2;
#line 140
  error = pcm_init(psf);
  }
#line 141
  goto switch_break;
  case_3: 
  {
#line 145
  error = paf24_init(psf);
  }
#line 146
  goto switch_break;
  switch_default: 
#line 148
  return (100);
  switch_break: ;
#line 151
  return (error);
}
}
#line 158 "/root/patchweave_new/23/src/paf.c"
static int paf_read_header(SF_PRIVATE *psf ) 
{ 
  PAF_FMT paf_fmt ;
  int marker ;
  int tmp ;

  {
#line 162
  if (psf->filelength < 2048L) {
#line 163
    return (101);
  }
  {
#line 165
  memset((void *)(& paf_fmt), 0, sizeof(paf_fmt));
#line 166
  psf_binheader_readf(psf, "pm", 0, & marker);
#line 168
  psf_log_printf(psf, "Signature   : \'%M\'\n", marker);
  }
#line 170
  if ((unsigned int )marker == ((unsigned int )((32 | (112 << 8)) | (97 << 16)) | (102U << 24))) {
    {
#line 171
    psf_binheader_readf(psf, "E444444", & paf_fmt.version, & paf_fmt.endianness, & paf_fmt.samplerate,
                        & paf_fmt.format, & paf_fmt.channels, & paf_fmt.source);
    }
  } else
#line 174
  if ((unsigned int )marker == ((unsigned int )((102 | (97 << 8)) | (112 << 16)) | (32U << 24))) {
    {
#line 175
    psf_binheader_readf(psf, "e444444", & paf_fmt.version, & paf_fmt.endianness, & paf_fmt.samplerate,
                        & paf_fmt.format, & paf_fmt.channels, & paf_fmt.source);
    }
  } else {
#line 179
    return (98);
  }
  {
#line 181
  psf_log_printf(psf, "Version     : %d\n", paf_fmt.version);
  }
#line 183
  if (paf_fmt.version != 0) {
    {
#line 184
    psf_log_printf(psf, "*** Bad version number. should be zero.\n\220");
    }
#line 185
    return (99);
  }
  {
#line 188
  psf_log_printf(psf, "Sample Rate : %d\n", paf_fmt.samplerate);
#line 189
  psf_log_printf(psf, "Channels    : %d\n", paf_fmt.channels);
#line 191
  psf_log_printf(psf, "Endianness  : %d => ", paf_fmt.endianness);
  }
#line 192
  if (paf_fmt.endianness) {
    {
#line 193
    psf_log_printf(psf, "Little\n", paf_fmt.endianness);
#line 194
    psf->endian = 268435456;
    }
  } else {
    {
#line 197
    psf_log_printf(psf, "Big\n\270U", paf_fmt.endianness);
#line 198
    psf->endian = 536870912;
    }
  }
#line 201
  if (paf_fmt.channels < 1) {
#line 202
    return (102);
  } else
#line 201
  if (paf_fmt.channels > 1024) {
#line 202
    return (102);
  }
  {
#line 204
  psf->datalength = psf->filelength - psf->dataoffset;
#line 206
  psf_binheader_readf(psf, "p3(G\270U", (int )psf->dataoffset);
#line 208
  psf->sf.samplerate = paf_fmt.samplerate;
#line 209
  psf->sf.channels = paf_fmt.channels;
#line 212
  psf->sf.format = 327680;
#line 214
  psf_log_printf(psf, "Format      : %d => \270U", paf_fmt.format);
  }
#line 217
  if (paf_fmt.endianness) {
#line 217
    tmp = 268435456;
  } else {
#line 217
    tmp = 536870912;
  }
#line 217
  psf->sf.format |= tmp;
#line 220
  if (paf_fmt.format == 2) {
#line 220
    goto case_2;
  }
#line 230
  if (paf_fmt.format == 0) {
#line 230
    goto case_0;
  }
#line 240
  if (paf_fmt.format == 1) {
#line 240
    goto case_1;
  }
#line 251
  goto switch_default;
  case_2: 
  {
#line 221
  psf_log_printf(psf, "8 bit linear PCM\n-(G\270U");
#line 222
  psf->bytewidth = 1;
#line 224
  psf->sf.format |= 1;
#line 226
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 227
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
  }
#line 228
  goto switch_break;
  case_0: 
  {
#line 231
  psf_log_printf(psf, "16 bit linear PCM\n");
#line 232
  psf->bytewidth = 2;
#line 234
  psf->sf.format |= 2;
#line 236
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 237
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
  }
#line 238
  goto switch_break;
  case_1: 
  {
#line 241
  psf_log_printf(psf, "24 bit linear PCM\n");
#line 242
  psf->bytewidth = 3;
#line 244
  psf->sf.format |= 3;
#line 246
  psf->blockwidth = 0;
#line 247
  psf->sf.frames = (10L * psf->datalength) / (long )(32 * psf->sf.channels);
  }
#line 249
  goto switch_break;
  switch_default: 
  {
#line 251
  psf_log_printf(psf, "Unknown\n\220");
  }
#line 252
  return (100);
#line 253
  goto switch_break;
  switch_break: 
  {
#line 256
  psf_log_printf(psf, "Source      : %d => \270U", paf_fmt.source);
  }
#line 259
  if (paf_fmt.source == 1) {
#line 259
    goto case_1___0;
  }
#line 261
  if (paf_fmt.source == 2) {
#line 261
    goto case_2___0;
  }
#line 263
  if (paf_fmt.source == 3) {
#line 263
    goto case_3;
  }
#line 265
  if (paf_fmt.source == 5) {
#line 265
    goto case_5;
  }
#line 267
  goto switch_default___0;
  case_1___0: 
  {
#line 259
  psf_log_printf(psf, "Analog Recording\n\200(G\270U");
  }
#line 260
  goto switch_break___0;
  case_2___0: 
  {
#line 261
  psf_log_printf(psf, "Digital Transfer\n");
  }
#line 262
  goto switch_break___0;
  case_3: 
  {
#line 263
  psf_log_printf(psf, "Multi-track Mixdown\n");
  }
#line 264
  goto switch_break___0;
  case_5: 
  {
#line 265
  psf_log_printf(psf, "Audio Resulting From DSP Processing\n");
  }
#line 266
  goto switch_break___0;
  switch_default___0: 
  {
#line 267
  psf_log_printf(psf, "Unknown\n\220");
  }
#line 268
  goto switch_break___0;
  switch_break___0: ;
#line 271
  return (0);
}
}
#line 275 "/root/patchweave_new/23/src/paf.c"
static int paf_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  int paf_format ;
  sf_count_t __cil_tmp4 ;

  {
  {
#line 279
  __cil_tmp4 = psf_ftell(psf);
  }
#line 279
  if (__cil_tmp4 >= 2048L) {
#line 280
    return (0);
  }
#line 282
  psf->dataoffset = (sf_count_t )2048;
#line 285
  if ((psf->sf.format & 65535) == 1) {
#line 285
    goto case_1;
  }
#line 289
  if ((psf->sf.format & 65535) == 2) {
#line 289
    goto case_2;
  }
#line 293
  if ((psf->sf.format & 65535) == 3) {
#line 293
    goto case_3;
  }
#line 297
  goto switch_default;
  case_1: 
#line 286
  paf_format = 2;
#line 287
  goto switch_break;
  case_2: 
#line 290
  paf_format = 0;
#line 291
  goto switch_break;
  case_3: 
#line 294
  paf_format = 1;
#line 295
  goto switch_break;
  switch_default: 
#line 297
  return (100);
  switch_break: 
#line 301
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 302
  psf->header.indx = (sf_count_t )0;
#line 304
  if (psf->endian == 536870912) {
    {
#line 306
    psf_binheader_writef(psf, "Em444", (unsigned int )((32 | (112 << 8)) | (97 << 16)) | (102U << 24),
                         0, 0, psf->sf.samplerate);
#line 308
    psf_binheader_writef(psf, "E444", paf_format, psf->sf.channels, 0);
    }
  } else
#line 310
  if (psf->endian == 268435456) {
    {
#line 312
    psf_binheader_writef(psf, "em444", (unsigned int )((102 | (97 << 8)) | (112 << 16)) | (32U << 24),
                         0, 1, psf->sf.samplerate);
#line 314
    psf_binheader_writef(psf, "e444", paf_format, psf->sf.channels, 0);
    }
  }
  {
#line 318
  psf_binheader_writef(psf, "z\252(G\270U", (size_t )(psf->dataoffset - psf->header.indx));
#line 320
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 322
  return (psf->error);
}
}
#line 339
static int paf24_read_block(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 ) ;
#line 340
static int paf24_write_block(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 ) ;
#line 341
static int paf24_close(SF_PRIVATE *psf ) ;
#line 345 "/root/patchweave_new/23/src/paf.c"
static int paf24_init(SF_PRIVATE *psf ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int paf24size ;

  {
  {
#line 349
  paf24size = (int )(sizeof(PAF24_PRIVATE ) + (unsigned long )psf->sf.channels * (32UL + 10UL * sizeof(int )));
#line 356
  psf->last_op = 0;
#line 358
  psf->codec_data = calloc(1UL, (unsigned long )paf24size);
  }
#line 358
  if (! psf->codec_data) {
#line 359
    return (17);
  }
#line 361
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 363
  ppaf24->channels = psf->sf.channels;
#line 364
  ppaf24->samples = ppaf24->data;
#line 365
  ppaf24->block = ppaf24->data + 10 * ppaf24->channels;
#line 367
  ppaf24->blocksize = 32 * ppaf24->channels;
#line 369
  if (psf->file.mode == 16) {
    {
#line 370
    paf24_read_block(psf, ppaf24);
#line 372
    psf->read_short = & paf24_read_s;
#line 373
    psf->read_int = & paf24_read_i;
#line 374
    psf->read_float = & paf24_read_f;
#line 375
    psf->read_double = & paf24_read_d;
    }
  } else
#line 369
  if (psf->file.mode == 48) {
    {
#line 370
    paf24_read_block(psf, ppaf24);
#line 372
    psf->read_short = & paf24_read_s;
#line 373
    psf->read_int = & paf24_read_i;
#line 374
    psf->read_float = & paf24_read_f;
#line 375
    psf->read_double = & paf24_read_d;
    }
  }
#line 378
  if (psf->file.mode == 32) {
#line 379
    psf->write_short = & paf24_write_s;
#line 380
    psf->write_int = & paf24_write_i;
#line 381
    psf->write_float = & paf24_write_f;
#line 382
    psf->write_double = & paf24_write_d;
  } else
#line 378
  if (psf->file.mode == 48) {
#line 379
    psf->write_short = & paf24_write_s;
#line 380
    psf->write_int = & paf24_write_i;
#line 381
    psf->write_float = & paf24_write_f;
#line 382
    psf->write_double = & paf24_write_d;
  }
  {
#line 385
  psf->seek = & paf24_seek;
#line 386
  psf->container_close = & paf24_close;
#line 388
  psf->filelength = psf_get_filelen(psf);
#line 389
  psf->datalength = psf->filelength - psf->dataoffset;
  }
#line 391
  if (psf->datalength % 32L) {
#line 392
    if (psf->file.mode == 16) {
      {
#line 393
      psf_log_printf(psf, "*** Warning : file seems to be truncated.\n");
      }
    }
#line 394
    ppaf24->max_blocks = (int )(psf->datalength / (long )ppaf24->blocksize + 1L);
  } else {
#line 397
    ppaf24->max_blocks = (int )(psf->datalength / (long )ppaf24->blocksize);
  }
#line 399
  ppaf24->read_block = 0;
#line 400
  if (psf->file.mode == 48) {
#line 401
    ppaf24->write_block = ppaf24->max_blocks;
  } else {
#line 403
    ppaf24->write_block = 0;
  }
#line 405
  psf->sf.frames = (sf_count_t )(10 * ppaf24->max_blocks);
#line 406
  ppaf24->sample_count = psf->sf.frames;
#line 408
  return (0);
}
}
#line 412 "/root/patchweave_new/23/src/paf.c"
static sf_count_t paf24_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int newblock ;
  int newsample ;

  {
#line 416
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 417
    psf->error = 30;
#line 418
    return ((sf_count_t )-1);
  }
#line 421
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 423
  if (mode == 16) {
#line 423
    if (ppaf24->write_count > 0) {
      {
#line 424
      paf24_write_block(psf, ppaf24);
      }
    }
  }
#line 426
  newblock = (int )(offset / 10L);
#line 427
  newsample = (int )(offset % 10L);
#line 430
  if (mode == 16) {
#line 430
    goto case_16;
  }
#line 440
  if (mode == 32) {
#line 440
    goto case_32;
  }
#line 455
  goto switch_default;
  case_16: 
#line 431
  if (psf->last_op == 32) {
#line 431
    if (ppaf24->write_count) {
      {
#line 432
      paf24_write_block(psf, ppaf24);
      }
    }
  }
  {
#line 434
  psf_fseek(psf, psf->dataoffset + (long )(newblock * ppaf24->blocksize), 0);
#line 435
  ppaf24->read_block = newblock;
#line 436
  paf24_read_block(psf, ppaf24);
#line 437
  ppaf24->read_count = newsample;
  }
#line 438
  goto switch_break;
  case_32: 
#line 441
  if (offset > ppaf24->sample_count) {
#line 442
    psf->error = 40;
#line 443
    return ((sf_count_t )-1);
  }
#line 446
  if (psf->last_op == 32) {
#line 446
    if (ppaf24->write_count) {
      {
#line 447
      paf24_write_block(psf, ppaf24);
      }
    }
  }
  {
#line 449
  psf_fseek(psf, psf->dataoffset + (long )(newblock * ppaf24->blocksize), 0);
#line 450
  ppaf24->write_block = newblock;
#line 451
  paf24_read_block(psf, ppaf24);
#line 452
  ppaf24->write_count = newsample;
  }
#line 453
  goto switch_break;
  switch_default: 
#line 456
  psf->error = 40;
#line 457
  return ((sf_count_t )-1);
  switch_break: ;
#line 460
  return ((sf_count_t )(newblock * 10 + newsample));
}
}
#line 464 "/root/patchweave_new/23/src/paf.c"
static int paf24_close(SF_PRIVATE *psf ) 
{ 
  PAF24_PRIVATE *ppaf24 ;

  {
#line 467
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 468
    return (0);
  }
#line 470
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 472
  if (psf->file.mode == 32) {
    _L: 
#line 473
    if (ppaf24->write_count > 0) {
      {
#line 474
      paf24_write_block(psf, ppaf24);
      }
    }
  } else
#line 472
  if (psf->file.mode == 48) {
#line 472
    goto _L;
  }
#line 477
  return (0);
}
}
#line 483 "/root/patchweave_new/23/src/paf.c"
static int paf24_read_block(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 ) 
{ 
  int k ;
  int channel ;
  unsigned char *cptr ;
  sf_count_t __cil_tmp7 ;

  {
#line 487
  (ppaf24->read_block) ++;
#line 488
  ppaf24->read_count = 0;
#line 490
  if ((long )(ppaf24->read_block * 10) > ppaf24->sample_count) {
    {
#line 491
    memset((void *)ppaf24->samples, 0, (unsigned long )(10 * ppaf24->channels));
    }
#line 492
    return (1);
  }
  {
#line 496
  __cil_tmp7 = psf_fread((void *)ppaf24->block, (sf_count_t )1, (sf_count_t )ppaf24->blocksize,
                         psf);
#line 496
  k = (int )__cil_tmp7;
  }
#line 496
  if (k != ppaf24->blocksize) {
    {
#line 497
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, ppaf24->blocksize);
    }
  }
#line 500
  if (psf->endian == 536870912) {
    {
#line 501
    endswap_int_array(ppaf24->block, 8 * ppaf24->channels);
    }
  }
#line 504
  k = 0;
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;

#line 504
    if (! (k < 10 * ppaf24->channels)) {
#line 504
      goto while_break;
    }
#line 505
    channel = k % ppaf24->channels;
#line 506
    cptr = ((unsigned char *)ppaf24->block + 32 * channel) + 3 * (k / ppaf24->channels);
#line 507
    *(ppaf24->samples + k) = (int )((unsigned int )(((int )*(cptr + 0) << 8) | ((int )*(cptr + 1) << 16)) | ((unsigned int )*(cptr + 2) << 24));
#line 504
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 510
  return (1);
}
}
#line 514 "/root/patchweave_new/23/src/paf.c"
static int paf24_read(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 , int *ptr , int len ) 
{ 
  int count___0 ;
  int total ;
  int tmp ;

  {
#line 515
  total = 0;
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;

#line 517
    if (! (total < len)) {
#line 517
      goto while_break;
    }
#line 518
    if ((long )(ppaf24->read_block * 10) >= ppaf24->sample_count) {
      {
#line 519
      memset((void *)(ptr + total), 0, (unsigned long )(len - total) * sizeof(int ));
      }
#line 520
      return (total);
    }
#line 523
    if (ppaf24->read_count >= 10) {
      {
#line 524
      paf24_read_block(psf, ppaf24);
      }
    }
#line 526
    count___0 = (10 - ppaf24->read_count) * ppaf24->channels;
#line 527
    if (len - total > count___0) {
#line 527
      tmp = count___0;
    } else {
#line 527
      tmp = len - total;
    }
    {
#line 527
    count___0 = tmp;
#line 529
    memcpy((void *)(ptr + total), (void const   *)(ppaf24->samples + ppaf24->read_count * ppaf24->channels),
           (unsigned long )count___0 * sizeof(int ));
#line 530
    total += count___0;
#line 531
    ppaf24->read_count += count___0 / ppaf24->channels;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 534
  return (total);
}
}
#line 538 "/root/patchweave_new/23/src/paf.c"
static sf_count_t paf24_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 543
  total = (sf_count_t )0;
#line 545
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 546
    return ((sf_count_t )0);
  }
#line 547
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 549
  iptr = ubuf.ibuf;
#line 550
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 551
  while (1) {
    while_continue: /* CIL Label */ ;

#line 551
    if (! (len > 0L)) {
#line 551
      goto while_break;
    }
#line 552
    if (len >= (long )bufferlen) {
#line 552
      tmp = (long )bufferlen;
    } else {
#line 552
      tmp = len;
    }
    {
#line 552
    readcount = (int )tmp;
#line 553
    count___0 = paf24_read(psf, ppaf24, iptr, readcount);
#line 554
    k = 0;
    }
    {
#line 554
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 554
      if (! (k < readcount)) {
#line 554
        goto while_break___0;
      }
#line 555
      *(ptr + (total + (long )k)) = (short )(*(iptr + k) >> 16);
#line 554
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 556
    total += (long )count___0;
#line 557
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 559
  return (total);
}
}
#line 563 "/root/patchweave_new/23/src/paf.c"
static sf_count_t paf24_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int total ;

  {
#line 567
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 568
    return ((sf_count_t )0);
  }
  {
#line 569
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 571
  total = paf24_read(psf, ppaf24, ptr, (int )len);
  }
#line 573
  return ((sf_count_t )total);
}
}
#line 577 "/root/patchweave_new/23/src/paf.c"
static sf_count_t paf24_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 582
  total = (sf_count_t )0;
#line 585
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 586
    return ((sf_count_t )0);
  }
#line 587
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 589
  if (psf->norm_float == 1) {
#line 589
    tmp = 1. / (double )2147483648U;
  } else {
#line 589
    tmp = 1. / (double )256;
  }
#line 589
  normfact = (float )tmp;
#line 591
  iptr = ubuf.ibuf;
#line 592
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 593
  while (1) {
    while_continue: /* CIL Label */ ;

#line 593
    if (! (len > 0L)) {
#line 593
      goto while_break;
    }
#line 594
    if (len >= (long )bufferlen) {
#line 594
      tmp___0 = (long )bufferlen;
    } else {
#line 594
      tmp___0 = len;
    }
    {
#line 594
    readcount = (int )tmp___0;
#line 595
    count___0 = paf24_read(psf, ppaf24, iptr, readcount);
#line 596
    k = 0;
    }
    {
#line 596
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 596
      if (! (k < readcount)) {
#line 596
        goto while_break___0;
      }
#line 597
      *(ptr + (total + (long )k)) = normfact * (float )*(iptr + k);
#line 596
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 598
    total += (long )count___0;
#line 599
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 601
  return (total);
}
}
#line 605 "/root/patchweave_new/23/src/paf.c"
static sf_count_t paf24_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 610
  total = (sf_count_t )0;
#line 613
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 614
    return ((sf_count_t )0);
  }
#line 615
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 617
  if (psf->norm_double == 1) {
#line 617
    tmp = 1. / (double )2147483648U;
  } else {
#line 617
    tmp = 1. / (double )256;
  }
#line 617
  normfact = tmp;
#line 619
  iptr = ubuf.ibuf;
#line 620
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;

#line 621
    if (! (len > 0L)) {
#line 621
      goto while_break;
    }
#line 622
    if (len >= (long )bufferlen) {
#line 622
      tmp___0 = (long )bufferlen;
    } else {
#line 622
      tmp___0 = len;
    }
    {
#line 622
    readcount = (int )tmp___0;
#line 623
    count___0 = paf24_read(psf, ppaf24, iptr, readcount);
#line 624
    k = 0;
    }
    {
#line 624
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 624
      if (! (k < readcount)) {
#line 624
        goto while_break___0;
      }
#line 625
      *(ptr + (total + (long )k)) = normfact * (double )*(iptr + k);
#line 624
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 626
    total += (long )count___0;
#line 627
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 629
  return (total);
}
}
#line 636 "/root/patchweave_new/23/src/paf.c"
static int paf24_write_block(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 ) 
{ 
  int k ;
  int nextsample ;
  int channel ;
  unsigned char *cptr ;
  sf_count_t __cil_tmp9 ;

  {
#line 642
  if (1) {
#line 643
    k = 0;
    {
#line 643
    while (1) {
      while_continue: /* CIL Label */ ;

#line 643
      if (! (k < 10 * ppaf24->channels)) {
#line 643
        goto while_break;
      }
#line 644
      channel = k % ppaf24->channels;
#line 645
      cptr = ((unsigned char *)ppaf24->block + 32 * channel) + 3 * (k / ppaf24->channels);
#line 646
      nextsample = *(ppaf24->samples + k) >> 8;
#line 647
      *(cptr + 0) = (unsigned char )nextsample;
#line 648
      *(cptr + 1) = (unsigned char )(nextsample >> 8);
#line 649
      *(cptr + 2) = (unsigned char )(nextsample >> 16);
#line 643
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
#line 653
    if (psf->endian == 536870912) {
      {
#line 654
      endswap_int_array(ppaf24->block, 8 * ppaf24->channels);
      }
    }
  } else
#line 656
  if (0) {
#line 658
    k = 0;
    {
#line 658
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 658
      if (! (k < 10 * ppaf24->channels)) {
#line 658
        goto while_break___0;
      }
#line 659
      channel = k % ppaf24->channels;
#line 660
      cptr = ((unsigned char *)ppaf24->block + 32 * channel) + 3 * (k / ppaf24->channels);
#line 661
      nextsample = *(ppaf24->samples + k) >> 8;
#line 662
      *(cptr + 0) = (unsigned char )nextsample;
#line 663
      *(cptr + 1) = (unsigned char )(nextsample >> 8);
#line 664
      *(cptr + 2) = (unsigned char )(nextsample >> 16);
#line 658
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 666
    if (psf->endian == 268435456) {
      {
#line 667
      endswap_int_array(ppaf24->block, 8 * ppaf24->channels);
      }
    }
  }
  {
#line 671
  __cil_tmp9 = psf_fwrite((void const   *)ppaf24->block, (sf_count_t )1, (sf_count_t )ppaf24->blocksize,
                          psf);
#line 671
  k = (int )__cil_tmp9;
  }
#line 671
  if (k != ppaf24->blocksize) {
    {
#line 672
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, ppaf24->blocksize);
    }
  }
#line 674
  if (ppaf24->sample_count < (long )(ppaf24->write_block * 10 + ppaf24->write_count)) {
#line 675
    ppaf24->sample_count = (sf_count_t )(ppaf24->write_block * 10 + ppaf24->write_count);
  }
#line 677
  if (ppaf24->write_count == 10) {
#line 678
    (ppaf24->write_block) ++;
#line 679
    ppaf24->write_count = 0;
  }
#line 682
  return (1);
}
}
#line 686 "/root/patchweave_new/23/src/paf.c"
static int paf24_write(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 , int const   *ptr ,
                       int len ) 
{ 
  int count___0 ;
  int total ;

  {
#line 687
  total = 0;
  {
#line 689
  while (1) {
    while_continue: /* CIL Label */ ;

#line 689
    if (! (total < len)) {
#line 689
      goto while_break;
    }
#line 690
    count___0 = (10 - ppaf24->write_count) * ppaf24->channels;
#line 692
    if (count___0 > len - total) {
#line 693
      count___0 = len - total;
    }
    {
#line 695
    memcpy((void *)(ppaf24->samples + ppaf24->write_count * ppaf24->channels), (void const   *)(ptr + total),
           (unsigned long )count___0 * sizeof(int ));
#line 696
    total += count___0;
#line 697
    ppaf24->write_count += count___0 / ppaf24->channels;
    }
#line 699
    if (ppaf24->write_count >= 10) {
      {
#line 700
      paf24_write_block(psf, ppaf24);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 703
  return (total);
}
}
#line 707 "/root/patchweave_new/23/src/paf.c"
static sf_count_t paf24_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 711
  writecount = 0;
#line 712
  total = (sf_count_t )0;
#line 714
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 715
    return ((sf_count_t )0);
  }
#line 716
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 718
  iptr = ubuf.ibuf;
#line 719
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 720
  while (1) {
    while_continue: /* CIL Label */ ;

#line 720
    if (! (len > 0L)) {
#line 720
      goto while_break;
    }
#line 721
    if (len >= (long )bufferlen) {
#line 721
      tmp = (long )bufferlen;
    } else {
#line 721
      tmp = len;
    }
#line 721
    writecount = (int )tmp;
#line 722
    k = 0;
    {
#line 722
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 722
      if (! (k < writecount)) {
#line 722
        goto while_break___0;
      }
#line 723
      *(iptr + k) = (int )*(ptr + (total + (long )k)) << 16;
#line 722
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 724
    count___0 = paf24_write(psf, ppaf24, (int const   *)iptr, writecount);
#line 725
    total += (long )count___0;
#line 726
    len -= (long )writecount;
    }
#line 727
    if (count___0 != writecount) {
#line 728
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 730
  return (total);
}
}
#line 734 "/root/patchweave_new/23/src/paf.c"
static sf_count_t paf24_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 737
  total = (sf_count_t )0;
#line 739
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 740
    return ((sf_count_t )0);
  }
#line 741
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
  {
#line 743
  while (1) {
    while_continue: /* CIL Label */ ;

#line 743
    if (! (len > 0L)) {
#line 743
      goto while_break;
    }
#line 744
    if (len > 268435456L) {
#line 744
      tmp = 268435456;
    } else {
#line 744
      tmp = (int )len;
    }
    {
#line 744
    writecount = tmp;
#line 746
    count___0 = paf24_write(psf, ppaf24, ptr, writecount);
#line 748
    total += (long )count___0;
#line 749
    len -= (long )count___0;
    }
#line 750
    if (count___0 != writecount) {
#line 751
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 754
  return (total);
}
}
#line 758 "/root/patchweave_new/23/src/paf.c"
static sf_count_t paf24_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 762
  writecount = 0;
#line 763
  total = (sf_count_t )0;
#line 766
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 767
    return ((sf_count_t )0);
  }
#line 768
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 770
  if (psf->norm_float == 1) {
#line 770
    tmp = 1. * (double )2147483647;
  } else {
#line 770
    tmp = 1. / (double )256;
  }
#line 770
  normfact = (float )tmp;
#line 772
  iptr = ubuf.ibuf;
#line 773
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 774
  while (1) {
    while_continue: /* CIL Label */ ;

#line 774
    if (! (len > 0L)) {
#line 774
      goto while_break;
    }
#line 775
    if (len >= (long )bufferlen) {
#line 775
      tmp___0 = (long )bufferlen;
    } else {
#line 775
      tmp___0 = len;
    }
#line 775
    writecount = (int )tmp___0;
#line 776
    k = 0;
    {
#line 776
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 776
      if (! (k < writecount)) {
#line 776
        goto while_break___0;
      }
      {
#line 777
      __cil_tmp15 = lrintf(normfact * (float )*(ptr + (total + (long )k)));
#line 777
      *(iptr + k) = (int )__cil_tmp15;
#line 776
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 778
    count___0 = paf24_write(psf, ppaf24, (int const   *)iptr, writecount);
#line 779
    total += (long )count___0;
#line 780
    len -= (long )writecount;
    }
#line 781
    if (count___0 != writecount) {
#line 782
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 785
  return (total);
}
}
#line 789 "/root/patchweave_new/23/src/paf.c"
static sf_count_t paf24_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 793
  writecount = 0;
#line 794
  total = (sf_count_t )0;
#line 797
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 798
    return ((sf_count_t )0);
  }
#line 799
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 801
  if (psf->norm_double == 1) {
#line 801
    tmp = 1. * (double )2147483647;
  } else {
#line 801
    tmp = 1. / (double )256;
  }
#line 801
  normfact = tmp;
#line 803
  iptr = ubuf.ibuf;
#line 804
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 805
  while (1) {
    while_continue: /* CIL Label */ ;

#line 805
    if (! (len > 0L)) {
#line 805
      goto while_break;
    }
#line 806
    if (len >= (long )bufferlen) {
#line 806
      tmp___0 = (long )bufferlen;
    } else {
#line 806
      tmp___0 = len;
    }
#line 806
    writecount = (int )tmp___0;
#line 807
    k = 0;
    {
#line 807
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 807
      if (! (k < writecount)) {
#line 807
        goto while_break___0;
      }
      {
#line 808
      __cil_tmp15 = lrint(normfact * (double )*(ptr + (total + (long )k)));
#line 808
      *(iptr + k) = (int )__cil_tmp15;
#line 807
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 809
    count___0 = paf24_write(psf, ppaf24, (int const   *)iptr, writecount);
#line 810
    total += (long )count___0;
#line 811
    len -= (long )writecount;
    }
#line 812
    if (count___0 != writecount) {
#line 813
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 816
  return (total);
}
}
#line 46 "/root/patchweave_new/23/src/nist.c"
static int nist_close(SF_PRIVATE *psf ) ;
#line 47
static int nist_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 48
static int nist_read_header(SF_PRIVATE *psf ) ;
#line 54 "/root/patchweave_new/23/src/nist.c"
int nist_open(SF_PRIVATE *psf ) 
{ 
  int error ;
  int tmp ;

  {
#line 57
  if (psf->file.mode == 16) {
    _L: 
    {
#line 58
    error = nist_read_header(psf);
    }
#line 58
    if (error) {
#line 59
      return (error);
    }
  } else
#line 57
  if (psf->file.mode == 48) {
#line 57
    if (psf->filelength > 0L) {
#line 57
      goto _L;
    }
  }
#line 62
  if (psf->file.mode == 32) {
    _L___33: 
#line 63
    if (psf->is_pipe) {
#line 64
      return (29);
    }
#line 66
    if ((psf->sf.format & 268369920) != 458752) {
#line 67
      return (1);
    }
#line 69
    psf->endian = psf->sf.format & 805306368;
#line 70
    if (psf->endian == 0) {
#line 71
      tmp = 268435456;
#line 71
      psf->endian = tmp;
    } else
#line 70
    if (psf->endian == 805306368) {
#line 71
      tmp = 268435456;
#line 71
      psf->endian = tmp;
    }
    {
#line 73
    psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 74
    psf->sf.frames = (sf_count_t )0;
#line 76
    error = nist_write_header(psf, 0);
    }
#line 76
    if (error) {
#line 77
      return (error);
    }
#line 79
    psf->write_header = & nist_write_header;
  } else
#line 62
  if (psf->file.mode == 48) {
#line 62
    goto _L___33;
  }
#line 82
  psf->container_close = & nist_close;
#line 85
  if ((psf->sf.format & 65535) == 1) {
#line 85
    goto case_1;
  }
#line 91
  if ((psf->sf.format & 65535) == 4) {
#line 91
    goto case_4;
  }
#line 91
  if ((psf->sf.format & 65535) == 3) {
#line 91
    goto case_4;
  }
#line 91
  if ((psf->sf.format & 65535) == 2) {
#line 91
    goto case_4;
  }
#line 95
  if ((psf->sf.format & 65535) == 16) {
#line 95
    goto case_16;
  }
#line 99
  if ((psf->sf.format & 65535) == 17) {
#line 99
    goto case_17;
  }
#line 103
  goto switch_default;
  case_1: 
  {
#line 86
  error = pcm_init(psf);
  }
#line 87
  goto switch_break;
  case_4: 
  {
#line 92
  error = pcm_init(psf);
  }
#line 93
  goto switch_break;
  case_16: 
  {
#line 96
  error = ulaw_init(psf);
  }
#line 97
  goto switch_break;
  case_17: 
  {
#line 100
  error = alaw_init(psf);
  }
#line 101
  goto switch_break;
  switch_default: 
#line 103
  error = 18;
#line 104
  goto switch_break;
  switch_break: ;
#line 107
  return (error);
}
}
#line 113 "/root/patchweave_new/23/src/nist.c"
static char bad_header[19]  = 
#line 113
  {      (char )'N',      (char )'I',      (char )'S',      (char )'T', 
        (char )'_',      (char )'1',      (char )'A',      (char)13, 
        (char)10,      (char )' ',      (char )' ',      (char )' ', 
        (char )'1',      (char )'0',      (char )'2',      (char )'4', 
        (char)13,      (char)10,      (char)0};
#line 120 "/root/patchweave_new/23/src/nist.c"
static int nist_read_header(SF_PRIVATE *psf ) 
{ 
  char psf_header[1026] ;
  int bitwidth ;
  int count___0 ;
  int encoding ;
  unsigned int bytes ;
  char str[64] ;
  char *cptr ;
  long samples ;
  unsigned long __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp ;
  int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  char *__cil_tmp31 ;

  {
  {
#line 122
  bitwidth = 0;
#line 123
  bytes = 0U;
#line 128
  psf_binheader_readf(psf, "pbGG\270U", 0, psf_header, 1024);
#line 131
  psf_header[1024] = (char)0;
#line 134
  cptr = strstr((char const   *)(psf_header), "end_head\220");
  }
#line 134
  if (cptr) {
    {
#line 135
    __cil_tmp11 = strlen("end_head\220");
#line 135
    cptr += __cil_tmp11 + 1UL;
#line 136
    *(cptr + 0) = (char)0;
    }
  }
  {
#line 139
  __cil_tmp12 = strstr((char const   *)(psf_header), (char const   *)(bad_header));
  }
#line 139
  if ((unsigned long )__cil_tmp12 == (unsigned long )(psf_header)) {
#line 140
    return (109);
  }
  {
#line 143
  __cil_tmp13 = strstr((char const   *)(psf_header), "NIST_1A\n\220");
  }
#line 143
  if ((unsigned long )__cil_tmp13 != (unsigned long )(psf_header)) {
    {
#line 144
    psf_log_printf(psf, "Not a NIST file.\n");
    }
#line 145
    return (108);
  }
  {
#line 148
  __cil_tmp14 = sscanf((char const   *)(psf_header), "NIST_1A\n%d\nG\270U", & count___0);
  }
#line 148
  if (__cil_tmp14 == 1) {
#line 149
    psf->dataoffset = (sf_count_t )count___0;
  } else {
    {
#line 151
    psf_log_printf(psf, "*** Suspicious header length.\n");
#line 152
    psf->dataoffset = (sf_count_t )1024;
    }
  }
  {
#line 156
  encoding = 5;
#line 157
  cptr = strstr((char const   *)(psf_header), "sample_coding -s\220");
  }
#line 157
  if (cptr) {
    {
#line 158
    sscanf((char const   *)cptr, "sample_coding -s%d %63s", & count___0, str);
#line 160
    __cil_tmp16 = strcmp((char const   *)(str), "pcm");
    }
#line 160
    if (__cil_tmp16 == 0) {
#line 162
      encoding = 5;
    } else {
      {
#line 164
      __cil_tmp17 = strcmp((char const   *)(str), "alaw\270U");
      }
#line 164
      if (__cil_tmp17 == 0) {
#line 165
        encoding = 17;
      } else {
        {
#line 166
        __cil_tmp19 = strcmp((char const   *)(str), "mu-law");
#line 166
        __cil_tmp18 = strcmp((char const   *)(str), "ulaw");
        }
#line 166
        if (__cil_tmp18 == 0) {
#line 167
          encoding = 16;
        } else
#line 166
        if (__cil_tmp19 == 0) {
#line 167
          encoding = 16;
        } else {
          {
#line 169
          psf_log_printf(psf, "*** Unknown encoding : %s\n", str);
#line 170
          encoding = 0;
          }
        }
      }
    }
  }
  {
#line 174
  cptr = strstr((char const   *)(psf_header), "channel_count -i ");
  }
#line 174
  if ((unsigned long )cptr != (unsigned long )((void *)0)) {
    {
#line 175
    sscanf((char const   *)cptr, "channel_count -i %d", & psf->sf.channels);
    }
  }
  {
#line 177
  cptr = strstr((char const   *)(psf_header), "sample_rate -i ");
  }
#line 177
  if ((unsigned long )cptr != (unsigned long )((void *)0)) {
    {
#line 178
    sscanf((char const   *)cptr, "sample_rate -i %d", & psf->sf.samplerate);
    }
  }
  {
#line 180
  cptr = strstr((char const   *)(psf_header), "sample_count -i \220");
  }
#line 180
  if ((unsigned long )cptr != (unsigned long )((void *)0)) {
    {
#line 181
    sscanf((char const   *)cptr, "sample_count -i %ld", & samples);
#line 182
    psf->sf.frames = samples;
    }
  }
  {
#line 185
  cptr = strstr((char const   *)(psf_header), "sample_n_bytes -i ");
  }
#line 185
  if ((unsigned long )cptr != (unsigned long )((void *)0)) {
    {
#line 186
    sscanf((char const   *)cptr, "sample_n_bytes -i %d", & psf->bytewidth);
    }
  }
  {
#line 189
  tmp = 268435456;
#line 189
  psf->endian = tmp;
#line 192
  __cil_tmp26 = sscanf((char const   *)cptr, "sample_byte_format -s%u %8s", & bytes,
                       str);
#line 192
  cptr = strstr((char const   *)(psf_header), "sample_byte_format -s");
  }
#line 192
  if (cptr) {
#line 192
    if (__cil_tmp26 == 2) {
      {
#line 195
      __cil_tmp27 = strlen((char const   *)(str));
      }
#line 195
      if ((unsigned long )bytes != __cil_tmp27) {
        {
#line 196
        psf_log_printf(psf, "Weird sample_byte_format : strlen \'%s\' != %d\n", str,
                       bytes);
        }
      }
#line 198
      if (bytes > 1U) {
#line 199
        if (psf->bytewidth == 0) {
#line 200
          psf->bytewidth = (int )bytes;
        } else
#line 201
        if ((unsigned int )psf->bytewidth - bytes != 0U) {
          {
#line 202
          psf_log_printf(psf, "psf->bytewidth (%d) != bytes (%d)\n", psf->bytewidth,
                         bytes);
          }
#line 203
          return (110);
        }
        {
#line 206
        __cil_tmp28 = strcmp((char const   *)(str), "01");
        }
#line 206
        if (__cil_tmp28 == 0) {
#line 207
          psf->endian = 268435456;
        } else {
          {
#line 208
          __cil_tmp29 = strcmp((char const   *)(str), "10");
          }
#line 208
          if (__cil_tmp29 == 0) {
#line 209
            psf->endian = 536870912;
          } else {
            {
#line 211
            psf_log_printf(psf, "Weird endian-ness : %s\n", str);
            }
#line 212
            return (110);
          }
        }
      }
#line 216
      psf->sf.format |= psf->endian;
    }
  }
  {
#line 219
  cptr = strstr((char const   *)(psf_header), "sample_sig_bits -i ");
  }
#line 219
  if (cptr) {
    {
#line 220
    sscanf((char const   *)cptr, "sample_sig_bits -i %d", & bitwidth);
    }
  }
  {
#line 222
  __cil_tmp31 = strstr((char const   *)(psf_header), "channels_interleaved -s5 FALSE");
  }
#line 222
  if (__cil_tmp31) {
    {
#line 223
    psf_log_printf(psf, "Non-interleaved data unsupported.\n", str);
    }
#line 224
    return (110);
  }
  {
#line 227
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 228
  psf->datalength = psf->filelength - psf->dataoffset;
#line 230
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 232
  if (encoding == 5) {
#line 234
    if (psf->bytewidth == 1) {
#line 234
      goto case_1;
    }
#line 238
    if (psf->bytewidth == 2) {
#line 238
      goto case_2;
    }
#line 242
    if (psf->bytewidth == 3) {
#line 242
      goto case_3;
    }
#line 246
    if (psf->bytewidth == 4) {
#line 246
      goto case_4;
    }
#line 250
    goto switch_default;
    case_1: 
#line 235
    psf->sf.format |= 1;
#line 236
    goto switch_break;
    case_2: 
#line 239
    psf->sf.format |= 2;
#line 240
    goto switch_break;
    case_3: 
#line 243
    psf->sf.format |= 3;
#line 244
    goto switch_break;
    case_4: 
#line 247
    psf->sf.format |= 4;
#line 248
    goto switch_break;
    switch_default: 
#line 250
    goto switch_break;
    switch_break: ;
  } else
#line 253
  if (encoding != 0) {
#line 254
    psf->sf.format |= encoding;
  } else {
#line 256
    return (18);
  }
#line 262
  if ((psf->sf.format & 65535) == 5) {
#line 262
    goto case_5;
  }
#line 262
  if ((psf->sf.format & 65535) == 17) {
#line 262
    goto case_5;
  }
#line 262
  if ((psf->sf.format & 65535) == 16) {
#line 262
    goto case_5;
  }
#line 267
  goto switch_default___0;
  case_5: 
#line 264
  psf->sf.format = 458752 | (psf->sf.format & 65535);
#line 265
  goto switch_break___0;
  switch_default___0: 
#line 268
  goto switch_break___0;
  switch_break___0: ;
#line 271
  return (0);
}
}
#line 275 "/root/patchweave_new/23/src/nist.c"
static int nist_close(SF_PRIVATE *psf ) 
{ 


  {
#line 277
  if (psf->file.mode == 32) {
    {
#line 278
    nist_write_header(psf, 1);
    }
  } else
#line 277
  if (psf->file.mode == 48) {
    {
#line 278
    nist_write_header(psf, 1);
    }
  }
#line 280
  return (0);
}
}
#line 287 "/root/patchweave_new/23/src/nist.c"
static int nist_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  char const   *end_str ;
  long samples ;
  sf_count_t current ;

  {
  {
#line 292
  current = psf_ftell(psf);
  }
#line 294
  if (calc_length) {
    {
#line 295
    psf->filelength = psf_get_filelen(psf);
#line 297
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 299
    if (psf->dataend) {
#line 300
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 302
    if (psf->bytewidth > 0) {
#line 303
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
#line 306
  if (psf->endian == 536870912) {
#line 307
    end_str = "10";
  } else
#line 308
  if (psf->endian == 268435456) {
#line 309
    end_str = "01";
  } else {
#line 311
    end_str = "error";
  }
  {
#line 314
  memset((void *)psf->header.ptr, 0, (unsigned long )psf->header.len);
#line 315
  psf->header.indx = (sf_count_t )0;
#line 317
  psf_fseek(psf, (sf_count_t )0, 0);
#line 319
  psf_asciiheader_printf(psf, "NIST_1A\n   1024\n\220");
#line 320
  psf_asciiheader_printf(psf, "channel_count -i %d\n\270U", psf->sf.channels);
#line 321
  psf_asciiheader_printf(psf, "sample_rate -i %d\nGG\270U", psf->sf.samplerate);
  }
#line 324
  if ((psf->sf.format & 65535) == 1) {
#line 324
    goto case_1;
  }
#line 332
  if ((psf->sf.format & 65535) == 4) {
#line 332
    goto case_4;
  }
#line 332
  if ((psf->sf.format & 65535) == 3) {
#line 332
    goto case_4;
  }
#line 332
  if ((psf->sf.format & 65535) == 2) {
#line 332
    goto case_4;
  }
#line 339
  if ((psf->sf.format & 65535) == 17) {
#line 339
    goto case_17;
  }
#line 344
  if ((psf->sf.format & 65535) == 16) {
#line 344
    goto case_16;
  }
#line 349
  goto switch_default;
  case_1: 
  {
#line 325
  psf_asciiheader_printf(psf, "sample_coding -s3 pcm\n");
#line 326
  psf_asciiheader_printf(psf, "sample_n_bytes -i 1\nsample_sig_bits -i 8\n");
  }
#line 328
  goto switch_break;
  case_4: 
  {
#line 333
  psf_asciiheader_printf(psf, "sample_n_bytes -i %d\nU", psf->bytewidth);
#line 334
  psf_asciiheader_printf(psf, "sample_sig_bits -i %d\n", psf->bytewidth * 8);
#line 335
  psf_asciiheader_printf(psf, "sample_coding -s3 pcm\nsample_byte_format -s%d %s\nU",
                         psf->bytewidth, end_str);
  }
#line 337
  goto switch_break;
  case_17: 
  {
#line 340
  psf_asciiheader_printf(psf, "sample_coding -s4 alaw\n");
#line 341
  psf_asciiheader_printf(psf, "sample_n_bytes -s1 1\n");
  }
#line 342
  goto switch_break;
  case_16: 
  {
#line 345
  psf_asciiheader_printf(psf, "sample_coding -s4 ulaw\n");
#line 346
  psf_asciiheader_printf(psf, "sample_n_bytes -s1 1\nU");
  }
#line 347
  goto switch_break;
  switch_default: 
#line 349
  return (18);
  switch_break: 
  {
#line 352
  psf->dataoffset = (sf_count_t )1024;
#line 355
  samples = psf->sf.frames;
#line 356
  psf_asciiheader_printf(psf, "sample_count -i %ld\n", samples);
#line 357
  psf_asciiheader_printf(psf, "end_head\n;HG\270U");
#line 360
  psf_binheader_writef(psf, "z", (size_t )(1024L - psf->header.indx));
#line 362
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 364
  if (psf->error) {
#line 365
    return (psf->error);
  }
#line 367
  if (current > 0L) {
    {
#line 368
    psf_fseek(psf, current, 0);
    }
  }
#line 370
  return (psf->error);
}
}
#line 76 "/root/patchweave_new/23/src/mat5.c"
static int mat5_close(SF_PRIVATE *psf ) ;
#line 78
static int mat5_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 79
static int mat5_read_header(SF_PRIVATE *psf ) ;
#line 86 "/root/patchweave_new/23/src/mat5.c"
int mat5_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;

  {
#line 87
  error = 0;
#line 89
  if (psf->file.mode == 16) {
    _L: 
    {
#line 90
    error = mat5_read_header(psf);
    }
#line 90
    if (error) {
#line 91
      return (error);
    }
  } else
#line 89
  if (psf->file.mode == 48) {
#line 89
    if (psf->filelength > 0L) {
#line 89
      goto _L;
    }
  }
#line 94
  if ((psf->sf.format & 268369920) != 851968) {
#line 95
    return (1);
  }
#line 97
  subformat = psf->sf.format & 65535;
#line 99
  if (psf->file.mode == 32) {
    _L___34: 
#line 100
    if (psf->is_pipe) {
#line 101
      return (29);
    }
#line 103
    psf->endian = psf->sf.format & 805306368;
#line 104
    if (psf->endian == 805306368) {
#line 105
      psf->endian = 268435456;
    } else
#line 104
    if (psf->endian == 0) {
#line 105
      psf->endian = 268435456;
    }
    {
#line 109
    error = mat5_write_header(psf, 0);
    }
#line 109
    if (error) {
#line 110
      return (error);
    }
#line 112
    psf->write_header = & mat5_write_header;
  } else
#line 99
  if (psf->file.mode == 48) {
#line 99
    goto _L___34;
  }
#line 115
  psf->container_close = & mat5_close;
#line 117
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 122
  if (subformat == 4) {
#line 122
    goto case_4;
  }
#line 122
  if (subformat == 2) {
#line 122
    goto case_4;
  }
#line 122
  if (subformat == 5) {
#line 122
    goto case_4;
  }
#line 126
  if (subformat == 6) {
#line 126
    goto case_6;
  }
#line 130
  if (subformat == 7) {
#line 130
    goto case_7;
  }
#line 134
  goto switch_default;
  case_4: 
  {
#line 123
  error = pcm_init(psf);
  }
#line 124
  goto switch_break;
  case_6: 
  {
#line 127
  error = float32_init(psf);
  }
#line 128
  goto switch_break;
  case_7: 
  {
#line 131
  error = double64_init(psf);
  }
#line 132
  goto switch_break;
  switch_default: 
#line 134
  goto switch_break;
  switch_break: ;
#line 137
  return (error);
}
}
#line 144 "/root/patchweave_new/23/src/mat5.c"
static int mat5_close(SF_PRIVATE *psf ) 
{ 


  {
#line 146
  if (psf->file.mode == 32) {
    {
#line 147
    mat5_write_header(psf, 1);
    }
  } else
#line 146
  if (psf->file.mode == 48) {
    {
#line 147
    mat5_write_header(psf, 1);
    }
  }
#line 149
  return (0);
}
}
#line 158 "/root/patchweave_new/23/src/mat5.c"
static char const   *filename  ;
#line 159 "/root/patchweave_new/23/src/mat5.c"
static char const   *sr_name  ;
#line 160 "/root/patchweave_new/23/src/mat5.c"
static char const   *wd_name  ;
#line 156 "/root/patchweave_new/23/src/mat5.c"
static int mat5_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  char buffer[256] ;
  sf_count_t current ;
  sf_count_t datasize ;
  int encoding ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  size_t __cil_tmp15 ;
  size_t __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  size_t __cil_tmp18 ;
  unsigned short samplerate ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;

  {
  {
#line 157
  filename = "MATLAB 5.0 MAT-file, written by libsndfile-1.0.29pre1, ";
#line 158
  sr_name = "samplerate";
#line 159
  wd_name = "wavedata";
#line 164
  current = psf_ftell(psf);
  }
#line 166
  if (calc_length) {
    {
#line 167
    psf_fseek(psf, (sf_count_t )0, 2);
#line 168
    psf->filelength = psf_ftell(psf);
#line 169
    psf_fseek(psf, (sf_count_t )0, 0);
#line 171
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 172
    if (psf->dataend) {
#line 173
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 175
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
#line 179
  if ((psf->sf.format & 65535) == 5) {
#line 179
    goto case_5;
  }
#line 183
  if ((psf->sf.format & 65535) == 2) {
#line 183
    goto case_2;
  }
#line 187
  if ((psf->sf.format & 65535) == 4) {
#line 187
    goto case_4;
  }
#line 191
  if ((psf->sf.format & 65535) == 6) {
#line 191
    goto case_6;
  }
#line 195
  if ((psf->sf.format & 65535) == 7) {
#line 195
    goto case_7;
  }
#line 199
  goto switch_default;
  case_5: 
#line 180
  encoding = 2;
#line 181
  goto switch_break;
  case_2: 
#line 184
  encoding = 3;
#line 185
  goto switch_break;
  case_4: 
#line 188
  encoding = 5;
#line 189
  goto switch_break;
  case_6: 
#line 192
  encoding = 7;
#line 193
  goto switch_break;
  case_7: 
#line 196
  encoding = 9;
#line 197
  goto switch_break;
  switch_default: 
#line 200
  return (1);
  switch_break: 
  {
#line 204
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 205
  psf->header.indx = (sf_count_t )0;
#line 206
  psf_fseek(psf, (sf_count_t )0, 0);
#line 208
  psf_get_date_str(buffer, (int )sizeof(buffer));
#line 209
  __cil_tmp12 = strlen(filename);
#line 209
  __cil_tmp13 = strlen((char const   *)(buffer));
#line 209
  psf_binheader_writef(psf, "bb", filename, __cil_tmp12, buffer, __cil_tmp13 + 1UL);
#line 211
  memset((void *)(buffer), ' ', (unsigned long )(124L - psf->header.indx));
#line 212
  __cil_tmp14 = make_size_t((int )(124L - psf->header.indx));
#line 212
  psf_binheader_writef(psf, "b", buffer, __cil_tmp14);
#line 214
  psf->rwf_endian = psf->endian;
  }
#line 216
  if (psf->rwf_endian == 536870912) {
    {
#line 217
    __cil_tmp15 = make_size_t(2);
#line 217
    psf_binheader_writef(psf, "2b", 256, "MI", __cil_tmp15);
    }
  } else {
    {
#line 219
    __cil_tmp16 = make_size_t(2);
#line 219
    psf_binheader_writef(psf, "2b", 256, "IM", __cil_tmp16);
    }
  }
  {
#line 221
  psf_binheader_writef(psf, "444444", 14, 64, 6, 8, 6, 0);
#line 222
  psf_binheader_writef(psf, "4444", 5, 8, 1, 1);
#line 223
  __cil_tmp17 = strlen(sr_name);
#line 223
  __cil_tmp18 = make_size_t(16);
#line 223
  psf_binheader_writef(psf, "44bG\270U", 1, __cil_tmp17, sr_name, __cil_tmp18);
  }
#line 225
  if (psf->sf.samplerate > 65535) {
    {
#line 226
    psf_binheader_writef(psf, "442G\270U", 262150, psf->sf.samplerate);
    }
  } else {
    {
#line 228
    samplerate = (unsigned short )psf->sf.samplerate;
#line 230
    psf_binheader_writef(psf, "422G\270U", 131076, (int )samplerate, 0);
    }
  }
  {
#line 233
  datasize = (psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth;
#line 235
  psf_binheader_writef(psf, "t484444", 14, datasize + 64L, 6, 8, 6, 0);
#line 236
  psf_binheader_writef(psf, "t4448", 5, 8, psf->sf.channels, psf->sf.frames);
#line 237
  __cil_tmp20 = strlen(wd_name);
#line 237
  __cil_tmp21 = strlen(wd_name);
#line 237
  psf_binheader_writef(psf, "44b", 1, __cil_tmp20, wd_name, __cil_tmp21);
#line 239
  datasize = (psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth;
  }
#line 240
  if (datasize > 2147483647L) {
#line 241
    datasize = (sf_count_t )2147483647;
  }
  {
#line 243
  psf_binheader_writef(psf, "t48G\270U", encoding, datasize);
#line 246
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 248
  if (psf->error) {
#line 249
    return (psf->error);
  }
#line 251
  psf->dataoffset = psf->header.indx;
#line 253
  if (current > 0L) {
    {
#line 254
    psf_fseek(psf, current, 0);
    }
  }
#line 256
  return (psf->error);
}
}
#line 260 "/root/patchweave_new/23/src/mat5.c"
static int mat5_read_header(SF_PRIVATE *psf ) 
{ 
  char buffer[256] ;
  char name[32] ;
  short version ;
  short endian ;
  int type ;
  int flags1 ;
  int flags2 ;
  int rows ;
  int cols ;
  unsigned int size ;
  int have_samplerate ;
  unsigned long __cil_tmp13 ;
  char *__cil_tmp14 ;
  char const   *tmp ;
  double samplerate ;
  long __cil_tmp20 ;
  unsigned short samplerate___0 ;

  {
  {
#line 265
  have_samplerate = 1;
#line 267
  psf_binheader_readf(psf, "pb", 0, buffer, 124);
#line 269
  buffer[125] = (char)0;
#line 271
  __cil_tmp13 = strlen((char const   *)(buffer));
  }
#line 271
  if (__cil_tmp13 >= 124UL) {
#line 272
    return (18);
  }
  {
#line 274
  __cil_tmp14 = strstr((char const   *)(buffer), "MATLAB 5.0 MAT-file");
  }
#line 274
  if ((unsigned long )__cil_tmp14 == (unsigned long )(buffer)) {
    {
#line 275
    psf_log_printf(psf, "%s\n", buffer);
    }
  }
  {
#line 278
  psf_binheader_readf(psf, "E22", & version, & endian);
  }
#line 280
  if ((int )endian == (77 << 8) + 73) {
    {
#line 281
    psf->rwf_endian = 536870912;
#line 281
    psf->endian = psf->rwf_endian;
#line 282
    version = ENDSWAP_16(version);
    }
  } else
#line 284
  if ((int )endian == (73 << 8) + 77) {
#line 285
    psf->rwf_endian = 268435456;
#line 285
    psf->endian = psf->rwf_endian;
  } else {
#line 289
    return (133);
  }
#line 291
  if ((int )endian == (73 << 8) + 77) {
    {
#line 293
    version = ENDSWAP_16(version);
    }
  }
  {
#line 295
  psf_log_printf(psf, "Version : 0x%04X\n", (int )version);
  }
#line 296
  if (psf->endian == 268435456) {
#line 296
    tmp = "Little";
  } else {
#line 296
    tmp = "BigG\270U";
  }
  {
#line 296
  psf_log_printf(psf, "Endian  : 0x%04X => %s\n", (int )endian, tmp);
#line 300
  psf_binheader_readf(psf, "44vG\270U", & type, & size);
#line 301
  psf_log_printf(psf, "Block\n Type : %X    Size : %d\n", type, size);
  }
#line 303
  if (type != 14) {
#line 304
    return (134);
  }
  {
#line 306
  psf_binheader_readf(psf, "44", & type, & size);
#line 307
  psf_log_printf(psf, "    Type : %X    Size : %d\n", type, size);
  }
#line 309
  if (type != 6) {
#line 310
    return (134);
  }
  {
#line 312
  psf_binheader_readf(psf, "44", & flags1, & flags2);
#line 313
  psf_log_printf(psf, "    Flg1 : %X    Flg2 : %d\n", flags1, flags2);
#line 315
  psf_binheader_readf(psf, "44", & type, & size);
#line 316
  psf_log_printf(psf, "    Type : %X    Size : %d\nG\270U", type, size);
  }
#line 318
  if (type != 5) {
#line 319
    return (134);
  }
  {
#line 321
  psf_binheader_readf(psf, "44", & rows, & cols);
#line 322
  psf_log_printf(psf, "    Rows : %d    Cols : %d\nG\270U", rows, cols);
  }
#line 324
  if (rows != 1) {
    _L: 
#line 325
    if (psf->sf.samplerate == 0) {
#line 326
      psf->sf.samplerate = 44100;
    }
#line 327
    have_samplerate = 0;
  } else
#line 324
  if (cols != 1) {
#line 324
    goto _L;
  }
  {
#line 329
  psf_binheader_readf(psf, "4", & type);
  }
#line 331
  if (type == 1) {
    {
#line 332
    psf_binheader_readf(psf, "4:vG\270U", & size);
#line 333
    psf_log_printf(psf, "    Type : %X    Size : %d\n", type, size);
    }
#line 334
    if (size > (unsigned int )((int )sizeof(name) - 1)) {
      {
#line 335
      psf_log_printf(psf, "Error : Bad name length.\n7vG\270U");
      }
#line 336
      return (134);
    }
    {
#line 339
    psf_binheader_readf(psf, "bjvG\270U", name, size, (8U - size % 8U) % 8U);
#line 340
    name[size] = (char)0;
    }
  } else
#line 342
  if ((type & 65535) == 1) {
#line 343
    size = (unsigned int )(type >> 16);
#line 344
    if (size > 4U) {
      {
#line 345
      psf_log_printf(psf, "Error : Bad name length.\n");
      }
#line 346
      return (134);
    }
    {
#line 349
    psf_log_printf(psf, "    Type : %X\n", type);
#line 350
    psf_binheader_readf(psf, "4", & name);
#line 351
    name[size] = (char)0;
    }
  } else {
#line 354
    return (134);
  }
  {
#line 356
  psf_log_printf(psf, "    Name : %s\n", name);
#line 360
  psf_binheader_readf(psf, "44vG\270U", & type, & size);
  }
#line 362
  if (! have_samplerate) {
#line 363
    goto skip_samplerate;
  }
#line 366
  if (type == 9) {
#line 366
    goto case_9;
  }
#line 377
  if (type == 131076) {
#line 377
    goto case_131076;
  }
#line 386
  if (type == 262150) {
#line 386
    goto case_262150;
  }
#line 391
  goto switch_default;
  case_9: 
  {
#line 369
  psf_binheader_readf(psf, "d", & samplerate);
#line 370
  snprintf(name, sizeof(name), "%f\n", samplerate);
#line 371
  psf_log_printf(psf, "    Val  : %s\n", name);
#line 373
  __cil_tmp20 = lrint(samplerate);
#line 373
  psf->sf.samplerate = (int )__cil_tmp20;
  }
#line 375
  goto switch_break;
  case_131076: 
  {
#line 380
  psf_binheader_readf(psf, "j2j", -4, & samplerate___0, 2);
#line 381
  psf_log_printf(psf, "    Val  : %u\n", (int )samplerate___0);
#line 382
  psf->sf.samplerate = (int )samplerate___0;
  }
#line 384
  goto switch_break;
  case_262150: 
  {
#line 387
  psf_log_printf(psf, "    Val  : %u\n", size);
#line 388
  psf->sf.samplerate = (int )size;
  }
#line 389
  goto switch_break;
  switch_default: 
  {
#line 392
  psf_log_printf(psf, "    Type : %X    Size : %d  ***\n\230\001", type, size);
  }
#line 393
  return (135);
  switch_break: 
  {
#line 399
  psf_binheader_readf(psf, "44vG\270U", & type, & size);
#line 400
  psf_log_printf(psf, " Type : %X    Size : %d\n\230\001", type, size);
  }
#line 402
  if (type != 14) {
#line 403
    return (134);
  }
  {
#line 405
  psf_binheader_readf(psf, "44", & type, & size);
#line 406
  psf_log_printf(psf, "    Type : %X    Size : %d\n", type, size);
  }
#line 408
  if (type != 6) {
#line 409
    return (134);
  }
  {
#line 411
  psf_binheader_readf(psf, "44", & flags1, & flags2);
#line 412
  psf_log_printf(psf, "    Flg1 : %X    Flg2 : %d\n", flags1, flags2);
#line 414
  psf_binheader_readf(psf, "44vG\270U", & type, & size);
#line 415
  psf_log_printf(psf, "    Type : %X    Size : %d\nG\270U", type, size);
  }
#line 417
  if (type != 5) {
#line 418
    return (134);
  }
  {
#line 420
  psf_binheader_readf(psf, "44vG\270U", & rows, & cols);
#line 421
  psf_log_printf(psf, "    Rows : %X    Cols : %d\n", rows, cols);
#line 423
  psf_binheader_readf(psf, "4", & type);
  }
#line 425
  if (type == 1) {
    {
#line 426
    psf_binheader_readf(psf, "4", & size);
#line 427
    psf_log_printf(psf, "    Type : %X    Size : %d\n", type, size);
    }
#line 428
    if (size > (unsigned int )((int )sizeof(name) - 1)) {
      {
#line 429
      psf_log_printf(psf, "Error : Bad name length.\n");
      }
#line 430
      return (134);
    }
    {
#line 433
    psf_binheader_readf(psf, "bjvG\270U", name, size, (8U - size % 8U) % 8U);
#line 434
    name[size] = (char)0;
    }
  } else
#line 436
  if ((type & 65535) == 1) {
#line 437
    size = (unsigned int )(type >> 16);
#line 438
    if (size > 4U) {
      {
#line 439
      psf_log_printf(psf, "Error : Bad name length.\n");
      }
#line 440
      return (134);
    }
    {
#line 443
    psf_log_printf(psf, "    Type : %X\n", type);
#line 444
    psf_binheader_readf(psf, "4", & name);
#line 445
    name[size] = (char)0;
    }
  } else {
#line 448
    return (134);
  }
  {
#line 450
  psf_log_printf(psf, "    Name : %s\n", name);
#line 452
  psf_binheader_readf(psf, "44", & type, & size);
#line 453
  psf_log_printf(psf, "    Type : %X    Size : %d\n", type, size);
  }
  skip_samplerate: 
#line 458
  if (rows == 0) {
#line 458
    if (cols == 0) {
      {
#line 459
      psf_log_printf(psf, "*** Error : zero channel count.\n\220");
      }
#line 460
      return (33);
    }
  }
#line 463
  psf->sf.channels = rows;
#line 464
  psf->sf.frames = (sf_count_t )cols;
#line 466
  psf->sf.format = psf->endian | 851968;
#line 469
  if (type == 9) {
#line 469
    goto case_9___0;
  }
#line 475
  if (type == 7) {
#line 475
    goto case_7;
  }
#line 481
  if (type == 5) {
#line 481
    goto case_5;
  }
#line 487
  if (type == 3) {
#line 487
    goto case_3;
  }
#line 493
  if (type == 2) {
#line 493
    goto case_2;
  }
#line 499
  goto switch_default___0;
  case_9___0: 
  {
#line 470
  psf_log_printf(psf, "Data type : double\n");
#line 471
  psf->sf.format |= 7;
#line 472
  psf->bytewidth = 8;
  }
#line 473
  goto switch_break___0;
  case_7: 
  {
#line 476
  psf_log_printf(psf, "Data type : float\n");
#line 477
  psf->sf.format |= 6;
#line 478
  psf->bytewidth = 4;
  }
#line 479
  goto switch_break___0;
  case_5: 
  {
#line 482
  psf_log_printf(psf, "Data type : 32 bit PCM\n");
#line 483
  psf->sf.format |= 4;
#line 484
  psf->bytewidth = 4;
  }
#line 485
  goto switch_break___0;
  case_3: 
  {
#line 488
  psf_log_printf(psf, "Data type : 16 bit PCM\n");
#line 489
  psf->sf.format |= 2;
#line 490
  psf->bytewidth = 2;
  }
#line 491
  goto switch_break___0;
  case_2: 
  {
#line 494
  psf_log_printf(psf, "Data type : unsigned 8 bit PCM\n");
#line 495
  psf->sf.format |= 5;
#line 496
  psf->bytewidth = 1;
  }
#line 497
  goto switch_break___0;
  switch_default___0: 
  {
#line 500
  psf_log_printf(psf, "*** Error : Bad marker %08X\n", type);
  }
#line 501
  return (18);
  switch_break___0: 
  {
#line 504
  psf->dataoffset = psf_ftell(psf);
#line 505
  psf->datalength = psf->filelength - psf->dataoffset;
  }
#line 507
  return (0);
}
}
#line 62 "/root/patchweave_new/23/src/mat4.c"
static int mat4_close(SF_PRIVATE *psf ) ;
#line 64
static int mat4_format_to_encoding(int format , int endian ) ;
#line 66
static int mat4_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 67
static int mat4_read_header(SF_PRIVATE *psf ) ;
#line 69
static char const   *mat4_marker_to_str(int marker ) ;
#line 76 "/root/patchweave_new/23/src/mat4.c"
int mat4_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;

  {
#line 77
  error = 0;
#line 79
  if (psf->file.mode == 16) {
    _L: 
    {
#line 80
    error = mat4_read_header(psf);
    }
#line 80
    if (error) {
#line 81
      return (error);
    }
  } else
#line 79
  if (psf->file.mode == 48) {
#line 79
    if (psf->filelength > 0L) {
#line 79
      goto _L;
    }
  }
#line 84
  if ((psf->sf.format & 268369920) != 786432) {
#line 85
    return (1);
  }
#line 87
  subformat = psf->sf.format & 65535;
#line 89
  if (psf->file.mode == 32) {
    _L___35: 
#line 90
    if (psf->is_pipe) {
#line 91
      return (29);
    }
#line 93
    psf->endian = psf->sf.format & 805306368;
#line 94
    if (psf->endian == 805306368) {
#line 95
      psf->endian = 268435456;
    } else
#line 94
    if (psf->endian == 0) {
#line 95
      psf->endian = 268435456;
    }
    {
#line 99
    error = mat4_write_header(psf, 0);
    }
#line 99
    if (error) {
#line 100
      return (error);
    }
#line 102
    psf->write_header = & mat4_write_header;
  } else
#line 89
  if (psf->file.mode == 48) {
#line 89
    goto _L___35;
  }
#line 105
  psf->container_close = & mat4_close;
#line 107
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 111
  if (subformat == 4) {
#line 111
    goto case_4;
  }
#line 111
  if (subformat == 2) {
#line 111
    goto case_4;
  }
#line 115
  if (subformat == 6) {
#line 115
    goto case_6;
  }
#line 119
  if (subformat == 7) {
#line 119
    goto case_7;
  }
#line 123
  goto switch_default;
  case_4: 
  {
#line 112
  error = pcm_init(psf);
  }
#line 113
  goto switch_break;
  case_6: 
  {
#line 116
  error = float32_init(psf);
  }
#line 117
  goto switch_break;
  case_7: 
  {
#line 120
  error = double64_init(psf);
  }
#line 121
  goto switch_break;
  switch_default: 
#line 123
  goto switch_break;
  switch_break: ;
#line 126
  return (error);
}
}
#line 133 "/root/patchweave_new/23/src/mat4.c"
static int mat4_close(SF_PRIVATE *psf ) 
{ 


  {
#line 135
  if (psf->file.mode == 32) {
    {
#line 136
    mat4_write_header(psf, 1);
    }
  } else
#line 135
  if (psf->file.mode == 48) {
    {
#line 136
    mat4_write_header(psf, 1);
    }
  }
#line 138
  return (0);
}
}
#line 145 "/root/patchweave_new/23/src/mat4.c"
static int mat4_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int encoding ;
  double samplerate ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  size_t __cil_tmp12 ;

  {
  {
#line 150
  current = psf_ftell(psf);
  }
#line 152
  if (calc_length) {
    {
#line 153
    psf->filelength = psf_get_filelen(psf);
#line 155
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 156
    if (psf->dataend) {
#line 157
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 159
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
  {
#line 162
  encoding = mat4_format_to_encoding(psf->sf.format & 65535, psf->endian);
  }
#line 164
  if (encoding == -1) {
#line 165
    return (1);
  }
  {
#line 168
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 169
  psf->header.indx = (sf_count_t )0;
#line 170
  psf_fseek(psf, (sf_count_t )0, 0);
#line 173
  samplerate = (double )psf->sf.samplerate;
  }
#line 175
  if (psf->endian == 536870912) {
    {
#line 176
    psf_binheader_writef(psf, "Em444", (unsigned int )(3 << 16) | (232U << 24), 1,
                         1, 0);
#line 177
    __cil_tmp9 = make_size_t(11);
#line 177
    psf_binheader_writef(psf, "E4bd", 11, "samplerate", __cil_tmp9, samplerate);
#line 178
    psf_binheader_writef(psf, "tEm484", encoding, psf->sf.channels, psf->sf.frames,
                         0);
#line 179
    __cil_tmp10 = make_size_t(9);
#line 179
    psf_binheader_writef(psf, "E4b", 9, "wavedata\230", __cil_tmp10);
    }
  } else
#line 181
  if (psf->endian == 268435456) {
    {
#line 182
    psf_binheader_writef(psf, "em444", 0U, 1, 1, 0);
#line 183
    __cil_tmp11 = make_size_t(11);
#line 183
    psf_binheader_writef(psf, "e4bd", 11, "samplerate", __cil_tmp11, samplerate);
#line 184
    psf_binheader_writef(psf, "tem484", encoding, psf->sf.channels, psf->sf.frames,
                         0);
#line 185
    __cil_tmp12 = make_size_t(9);
#line 185
    psf_binheader_writef(psf, "e4b", 9, "wavedata\230", __cil_tmp12);
    }
  } else {
#line 188
    return (1);
  }
  {
#line 191
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 193
  if (psf->error) {
#line 194
    return (psf->error);
  }
#line 196
  psf->dataoffset = psf->header.indx;
#line 198
  if (current > 0L) {
    {
#line 199
    psf_fseek(psf, current, 0);
    }
  }
#line 201
  return (psf->error);
}
}
#line 205 "/root/patchweave_new/23/src/mat4.c"
static int mat4_read_header(SF_PRIVATE *psf ) 
{ 
  char buffer[256] ;
  uint32_t marker ;
  uint32_t namesize ;
  int rows ;
  int cols ;
  int imag ;
  double value___0 ;
  char const   *marker_str ;
  char name[64] ;
  char const   *tmp ;
  long __cil_tmp12 ;
  char const   *__cil_tmp13 ;
  char const   *tmp___0 ;

  {
  {
#line 213
  psf_binheader_readf(psf, "pm", 0, & marker);
  }
#line 216
  if (marker == ((unsigned int )(3 << 16) | (232U << 24))) {
#line 217
    psf->rwf_endian = 536870912;
#line 217
    psf->endian = psf->rwf_endian;
#line 218
    marker_str = "big endian double\233\244G\270U";
  } else
#line 220
  if (marker == 0U) {
#line 221
    psf->rwf_endian = 268435456;
#line 221
    psf->endian = psf->rwf_endian;
#line 222
    marker_str = "little endian double";
  } else {
#line 225
    return (18);
  }
  {
#line 227
  psf_log_printf(psf, "GNU Octave 2.0 / MATLAB v4.2 format\nMarker : %s\n\230\001",
                 marker_str);
#line 229
  psf_binheader_readf(psf, "444", & rows, & cols, & imag);
  }
#line 231
  if (imag) {
#line 231
    tmp = "True";
  } else {
#line 231
    tmp = "False";
  }
  {
#line 231
  psf_log_printf(psf, " Rows  : %d\n Cols  : %d\n Imag  : %s\n\270U", rows, cols,
                 tmp);
#line 233
  psf_binheader_readf(psf, "4", & namesize);
  }
#line 235
  if (namesize >= (unsigned int )((int )sizeof(name))) {
#line 236
    return (131);
  }
  {
#line 238
  psf_binheader_readf(psf, "b\215\244G\270U", name, namesize);
#line 239
  name[namesize] = (char)0;
#line 241
  psf_log_printf(psf, " Name  : %s\n", name);
#line 243
  psf_binheader_readf(psf, "d9\244G\270U", & value___0);
#line 245
  snprintf(buffer, sizeof(buffer), " Value : %f\n", value___0);
#line 246
  psf_log_printf(psf, (char const   *)(buffer));
  }
#line 248
  if (rows != 1) {
#line 249
    return (132);
  } else
#line 248
  if (cols != 1) {
#line 249
    return (132);
  }
  {
#line 251
  __cil_tmp12 = lrint(value___0);
#line 251
  psf->sf.samplerate = (int )__cil_tmp12;
#line 255
  psf_binheader_readf(psf, "m\270\244G\270U", & marker);
#line 257
  __cil_tmp13 = mat4_marker_to_str((int )marker);
#line 257
  psf_log_printf(psf, "Marker : %s\n\270U", __cil_tmp13);
#line 259
  psf_binheader_readf(psf, "444", & rows, & cols, & imag);
  }
#line 261
  if (imag) {
#line 261
    tmp___0 = "True\270U";
  } else {
#line 261
    tmp___0 = "FalseU";
  }
  {
#line 261
  psf_log_printf(psf, " Rows  : %d\n Cols  : %d\n Imag  : %s\n", rows, cols, tmp___0);
#line 263
  psf_binheader_readf(psf, "4", & namesize);
  }
#line 265
  if (namesize >= (unsigned int )((int )sizeof(name))) {
#line 266
    return (131);
  }
  {
#line 268
  psf_binheader_readf(psf, "b", name, namesize);
#line 269
  name[namesize] = (char)0;
#line 271
  psf_log_printf(psf, " Name  : %s\n", name);
#line 273
  psf->dataoffset = psf_ftell(psf);
  }
#line 275
  if (rows == 0) {
    {
#line 276
    psf_log_printf(psf, "*** Error : zero channel count.\n\220");
    }
#line 277
    return (33);
  } else
#line 279
  if (rows > 1024) {
    {
#line 280
    psf_log_printf(psf, "*** Error : channel count %d > SF_MAX_CHANNELS.\n\230\001",
                   rows);
    }
#line 281
    return (34);
  }
#line 284
  psf->sf.channels = rows;
#line 285
  psf->sf.frames = (sf_count_t )cols;
#line 287
  psf->sf.format = psf->endian | 786432;
#line 290
  if (marker == 0U) {
#line 290
    goto case_0;
  }
#line 290
  if (marker == ((unsigned int )(3 << 16) | (232U << 24))) {
#line 290
    goto case_0;
  }
#line 296
  if (marker == 10U) {
#line 296
    goto case_10;
  }
#line 296
  if (marker == ((unsigned int )(3 << 16) | (242U << 24))) {
#line 296
    goto case_10;
  }
#line 302
  if (marker == 20U) {
#line 302
    goto case_20;
  }
#line 302
  if (marker == ((unsigned int )(3 << 16) | (252U << 24))) {
#line 302
    goto case_20;
  }
#line 308
  if (marker == 30U) {
#line 308
    goto case_30;
  }
#line 308
  if (marker == ((unsigned int )(4 << 16) | (6U << 24))) {
#line 308
    goto case_30;
  }
#line 313
  goto switch_default;
  case_0: 
#line 291
  psf->sf.format |= 7;
#line 292
  psf->bytewidth = 8;
#line 293
  goto switch_break;
  case_10: 
#line 297
  psf->sf.format |= 6;
#line 298
  psf->bytewidth = 4;
#line 299
  goto switch_break;
  case_20: 
#line 303
  psf->sf.format |= 4;
#line 304
  psf->bytewidth = 4;
#line 305
  goto switch_break;
  case_30: 
#line 309
  psf->sf.format |= 2;
#line 310
  psf->bytewidth = 2;
#line 311
  goto switch_break;
  switch_default: 
  {
#line 314
  psf_log_printf(psf, "*** Error : Bad marker %08X\n", marker);
  }
#line 315
  return (18);
  switch_break: ;
#line 318
  if (psf->filelength - psf->dataoffset < ((long )psf->sf.channels * psf->sf.frames) * (long )psf->bytewidth) {
    {
#line 319
    psf_log_printf(psf, "*** File seems to be truncated. %D <--> %D\n", psf->filelength - psf->dataoffset,
                   ((long )psf->sf.channels * psf->sf.frames) * (long )psf->bytewidth);
    }
  } else
#line 322
  if (psf->filelength - psf->dataoffset > ((long )psf->sf.channels * psf->sf.frames) * (long )psf->bytewidth) {
#line 323
    psf->dataend = psf->dataoffset + (long )((rows * cols) * psf->bytewidth);
  }
#line 325
  psf->datalength = (psf->filelength - psf->dataoffset) - psf->dataend;
#line 327
  psf->sf.sections = 1;
#line 329
  return (0);
}
}
#line 333 "/root/patchweave_new/23/src/mat4.c"
static int mat4_format_to_encoding(int format , int endian ) 
{ 


  {
#line 336
  if ((format | endian) == 536870914) {
#line 336
    goto case_536870914;
  }
#line 339
  if ((format | endian) == 268435458) {
#line 339
    goto case_268435458;
  }
#line 342
  if ((format | endian) == 536870916) {
#line 342
    goto case_536870916;
  }
#line 345
  if ((format | endian) == 268435460) {
#line 345
    goto case_268435460;
  }
#line 348
  if ((format | endian) == 536870918) {
#line 348
    goto case_536870918;
  }
#line 351
  if ((format | endian) == 268435462) {
#line 351
    goto case_268435462;
  }
#line 354
  if ((format | endian) == 536870919) {
#line 354
    goto case_536870919;
  }
#line 357
  if ((format | endian) == 268435463) {
#line 357
    goto case_268435463;
  }
#line 360
  goto switch_default;
  case_536870914: 
#line 337
  return ((int )((unsigned int )(4 << 16) | (6U << 24)));
  case_268435458: 
#line 340
  return (30);
  case_536870916: 
#line 343
  return ((int )((unsigned int )(3 << 16) | (252U << 24)));
  case_268435460: 
#line 346
  return (20);
  case_536870918: 
#line 349
  return ((int )((unsigned int )(3 << 16) | (242U << 24)));
  case_268435462: 
#line 352
  return (10);
  case_536870919: 
#line 355
  return ((int )((unsigned int )(3 << 16) | (232U << 24)));
  case_268435463: 
#line 358
  return (0);
  switch_default: 
#line 360
  goto switch_break;
  switch_break: ;
#line 363
  return (-1);
}
}
#line 369 "/root/patchweave_new/23/src/mat4.c"
static char str[32]  ;
#line 367 "/root/patchweave_new/23/src/mat4.c"
static char const   *mat4_marker_to_str(int marker ) 
{ 


  {
#line 372
  if (marker == (int )((unsigned int )(4 << 16) | (6U << 24))) {
#line 372
    goto case_exp;
  }
#line 373
  if (marker == 30) {
#line 373
    goto case_30;
  }
#line 375
  if (marker == (int )((unsigned int )(3 << 16) | (252U << 24))) {
#line 375
    goto case_exp___0;
  }
#line 376
  if (marker == 20) {
#line 376
    goto case_20;
  }
#line 379
  if (marker == (int )((unsigned int )(3 << 16) | (242U << 24))) {
#line 379
    goto case_exp___1;
  }
#line 380
  if (marker == 10) {
#line 380
    goto case_10;
  }
#line 382
  if (marker == (int )((unsigned int )(3 << 16) | (232U << 24))) {
#line 382
    goto case_exp___2;
  }
#line 383
  if (marker == 0) {
#line 383
    goto case_0;
  }
#line 370
  goto switch_break;
  case_exp: 
#line 372
  return ("big endian 16 bit PCMU");
  case_30: 
#line 373
  return ("little endian 16 bit PCM\220");
  case_exp___0: 
#line 375
  return ("big endian 32 bit PCM");
  case_20: 
#line 376
  return ("little endian 32 bit PCM\220");
  case_exp___1: 
#line 379
  return ("big endian float\220");
  case_10: 
#line 380
  return ("big endian float\220");
  case_exp___2: 
#line 382
  return ("big endian double\250\244G\270U");
  case_0: 
#line 383
  return ("little endian double");
  switch_break: 
  {
#line 387
  str[sizeof(str) - 1UL] = (char)0;
#line 388
  snprintf(str, sizeof(str) - 1UL, "%08X", marker);
  }
#line 389
  return ((char const   *)(str));
}
}
#line 34 "/root/patchweave_new/23/src/macos.c"
static char rsrc_name[1024]  ;
#line 32 "/root/patchweave_new/23/src/macos.c"
int macos_guess_file_type(SF_PRIVATE *psf , char const   *filename___0 ) 
{ 
  struct stat statbuf ;
  int __cil_tmp5 ;

  {
  {
#line 36
  snprintf(rsrc_name, sizeof(rsrc_name), "%s/rsrc", filename___0);
#line 39
  __cil_tmp5 = stat((char const   *)(rsrc_name), & statbuf);
  }
#line 39
  if (__cil_tmp5 != 0) {
    {
#line 40
    psf_log_printf(psf, "No resource fork.\n");
    }
#line 41
    return (0);
  }
#line 44
  if (statbuf.st_size == 0L) {
    {
#line 45
    psf_log_printf(psf, "Have zero size resource fork.\n");
    }
#line 46
    return (0);
  }
#line 49
  return (0);
}
}
#line 66 "/root/patchweave_new/23/src/ircam.c"
static int ircam_close(SF_PRIVATE *psf ) ;
#line 67
static int ircam_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 68
static int ircam_read_header(SF_PRIVATE *psf ) ;
#line 70
static int get_encoding(int subformat ) ;
#line 72
static char const   *get_encoding_str(int encoding ) ;
#line 79 "/root/patchweave_new/23/src/ircam.c"
int ircam_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int tmp ;

  {
#line 81
  error = 0;
#line 83
  if (psf->file.mode == 16) {
    _L: 
    {
#line 84
    error = ircam_read_header(psf);
    }
#line 84
    if (error) {
#line 85
      return (error);
    }
  } else
#line 83
  if (psf->file.mode == 48) {
#line 83
    if (psf->filelength > 0L) {
#line 83
      goto _L;
    }
  }
#line 88
  subformat = psf->sf.format & 65535;
#line 90
  if (psf->file.mode == 32) {
    _L___36: 
#line 91
    if ((psf->sf.format & 268369920) != 655360) {
#line 92
      return (1);
    }
#line 94
    psf->endian = psf->sf.format & 805306368;
#line 95
    if (psf->endian == 0) {
#line 96
      tmp = 268435456;
#line 96
      psf->endian = tmp;
    } else
#line 95
    if (psf->endian == 805306368) {
#line 96
      tmp = 268435456;
#line 96
      psf->endian = tmp;
    }
    {
#line 98
    psf->dataoffset = (sf_count_t )1024;
#line 100
    error = ircam_write_header(psf, 0);
    }
#line 100
    if (error) {
#line 101
      return (error);
    }
#line 103
    psf->write_header = & ircam_write_header;
  } else
#line 90
  if (psf->file.mode == 48) {
#line 90
    goto _L___36;
  }
#line 106
  psf->container_close = & ircam_close;
#line 109
  if (subformat == 16) {
#line 109
    goto case_16;
  }
#line 113
  if (subformat == 17) {
#line 113
    goto case_17;
  }
#line 118
  if (subformat == 4) {
#line 118
    goto case_4;
  }
#line 118
  if (subformat == 2) {
#line 118
    goto case_4;
  }
#line 122
  if (subformat == 6) {
#line 122
    goto case_6;
  }
#line 126
  goto switch_default;
  case_16: 
  {
#line 110
  error = ulaw_init(psf);
  }
#line 111
  goto switch_break;
  case_17: 
  {
#line 114
  error = alaw_init(psf);
  }
#line 115
  goto switch_break;
  case_4: 
  {
#line 119
  error = pcm_init(psf);
  }
#line 120
  goto switch_break;
  case_6: 
  {
#line 123
  error = float32_init(psf);
  }
#line 124
  goto switch_break;
  switch_default: 
#line 126
  goto switch_break;
  switch_break: ;
#line 129
  return (error);
}
}
#line 136 "/root/patchweave_new/23/src/ircam.c"
static int ircam_read_header(SF_PRIVATE *psf ) 
{ 
  unsigned int marker ;
  unsigned int encoding ;
  float samplerate ;
  int error ;
  char const   *__cil_tmp6 ;

  {
  {
#line 139
  error = 0;
#line 141
  psf_binheader_readf(psf, "epmf44", 0, & marker, & samplerate, & psf->sf.channels,
                      & encoding);
  }
#line 143
  if ((marker & ((unsigned int )(255 | (255 << 8)) | (255U << 24))) != (unsigned int )(100 | (163 << 8))) {
#line 143
    if ((marker & ((unsigned int )(255 | (255 << 16)) | (255U << 24))) != ((unsigned int )(163 << 16) | (100U << 24))) {
      {
#line 144
      psf_log_printf(psf, "marker: 0x%X\n", marker);
      }
#line 145
      return (121);
    }
  }
#line 148
  psf->endian = 268435456;
#line 150
  if (psf->sf.channels > 1024) {
    {
#line 151
    psf_binheader_readf(psf, "Epmf44", 0, & marker, & samplerate, & psf->sf.channels,
                        & encoding);
    }
#line 154
    if (psf->sf.channels > 1024) {
      {
#line 155
      psf_log_printf(psf, "marker: 0x%X\nU", marker);
      }
#line 156
      return (122);
    }
#line 159
    psf->endian = 536870912;
  }
  {
#line 162
  psf_log_printf(psf, "marker: 0x%X\n", marker);
#line 164
  psf->sf.samplerate = (int )samplerate;
#line 166
  __cil_tmp6 = get_encoding_str((int )encoding);
#line 166
  psf_log_printf(psf, "  Sample Rate : %d\n  Channels    : %d\n  Encoding    : %X => %s\n",
                 psf->sf.samplerate, psf->sf.channels, encoding, __cil_tmp6);
  }
#line 172
  if (encoding == 2U) {
#line 172
    goto case_2;
  }
#line 179
  if (encoding == 262148U) {
#line 179
    goto case_262148;
  }
#line 186
  if (encoding == 4U) {
#line 186
    goto case_4;
  }
#line 193
  if (encoding == 65537U) {
#line 193
    goto case_65537;
  }
#line 200
  if (encoding == 131073U) {
#line 200
    goto case_131073;
  }
#line 207
  goto switch_default;
  case_2: 
#line 173
  psf->bytewidth = 2;
#line 174
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 176
  psf->sf.format = 655362;
#line 177
  goto switch_break;
  case_262148: 
#line 180
  psf->bytewidth = 4;
#line 181
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 183
  psf->sf.format = 655364;
#line 184
  goto switch_break;
  case_4: 
#line 187
  psf->bytewidth = 4;
#line 188
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 190
  psf->sf.format = 655366;
#line 191
  goto switch_break;
  case_65537: 
#line 194
  psf->bytewidth = 1;
#line 195
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 197
  psf->sf.format = 655377;
#line 198
  goto switch_break;
  case_131073: 
#line 201
  psf->bytewidth = 1;
#line 202
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 204
  psf->sf.format = 655376;
#line 205
  goto switch_break;
  switch_default: 
#line 208
  error = 123;
#line 209
  goto switch_break;
  switch_break: ;
#line 212
  if (psf->endian == 536870912) {
#line 213
    psf->sf.format |= 536870912;
  } else {
#line 215
    psf->sf.format |= 268435456;
  }
#line 217
  if (error) {
#line 218
    return (error);
  }
#line 220
  psf->dataoffset = (sf_count_t )1024;
#line 221
  psf->datalength = psf->filelength - psf->dataoffset;
#line 223
  if (psf->sf.frames == 0L) {
#line 223
    if (psf->blockwidth) {
#line 224
      psf->sf.frames = psf->datalength / (long )psf->blockwidth;
    }
  }
  {
#line 226
  psf_log_printf(psf, "  Samples     : %d\n", psf->sf.frames);
#line 228
  psf_binheader_readf(psf, "p", 1024);
  }
#line 230
  return (0);
}
}
#line 234 "/root/patchweave_new/23/src/ircam.c"
static int ircam_close(SF_PRIVATE *psf ) 
{ 


  {
  {
#line 236
  psf_log_printf(psf, "close\n");
  }
#line 238
  return (0);
}
}
#line 242 "/root/patchweave_new/23/src/ircam.c"
static int ircam_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  int encoding ;
  float samplerate ;
  sf_count_t current ;

  {
#line 247
  if (psf->pipeoffset > 0L) {
#line 248
    return (0);
  }
  {
#line 250
  current = psf_ftell(psf);
#line 253
  encoding = get_encoding(psf->sf.format & 65535);
  }
#line 255
  if (encoding == 0) {
#line 256
    return (1);
  }
#line 259
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 260
  psf->header.indx = (sf_count_t )0;
#line 262
  if (psf->is_pipe == 0) {
    {
#line 263
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
#line 265
  samplerate = (float )psf->sf.samplerate;
#line 268
  if (psf->endian == 536870912) {
#line 268
    goto case_536870912;
  }
#line 273
  if (psf->endian == 268435456) {
#line 273
    goto case_268435456;
  }
#line 278
  goto switch_default;
  case_536870912: 
  {
#line 269
  psf_binheader_writef(psf, "Emf", (unsigned int )((100 | (163 << 8)) | (2 << 16)),
                       (double )samplerate);
#line 270
  psf_binheader_writef(psf, "E44", psf->sf.channels, encoding);
  }
#line 271
  goto switch_break;
  case_268435456: 
  {
#line 274
  psf_binheader_writef(psf, "emf", (unsigned int )((100 | (163 << 8)) | (3 << 16)),
                       (double )samplerate);
#line 275
  psf_binheader_writef(psf, "e44G\270U", psf->sf.channels, encoding);
  }
#line 276
  goto switch_break;
  switch_default: 
#line 278
  return (1);
  switch_break: 
  {
#line 281
  psf_binheader_writef(psf, "z\360\337G\270U", (size_t )(1024L - psf->header.indx));
#line 284
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 286
  if (psf->error) {
#line 287
    return (psf->error);
  }
#line 289
  if (current > 0L) {
    {
#line 290
    psf_fseek(psf, current, 0);
    }
  }
#line 292
  return (psf->error);
}
}
#line 296 "/root/patchweave_new/23/src/ircam.c"
static int get_encoding(int subformat ) 
{ 


  {
#line 298
  if (subformat == 2) {
#line 298
    goto case_2;
  }
#line 299
  if (subformat == 4) {
#line 299
    goto case_4;
  }
#line 301
  if (subformat == 6) {
#line 301
    goto case_6;
  }
#line 303
  if (subformat == 16) {
#line 303
    goto case_16;
  }
#line 304
  if (subformat == 17) {
#line 304
    goto case_17;
  }
#line 306
  goto switch_default;
  case_2: 
#line 298
  return (2);
  case_4: 
#line 299
  return (262148);
  case_6: 
#line 301
  return (4);
  case_16: 
#line 303
  return (131073);
  case_17: 
#line 304
  return (65537);
  switch_default: 
#line 306
  goto switch_break;
  switch_break: ;
#line 309
  return (0);
}
}
#line 313 "/root/patchweave_new/23/src/ircam.c"
static char const   *get_encoding_str(int encoding ) 
{ 


  {
#line 315
  if (encoding == 2) {
#line 315
    goto case_2;
  }
#line 316
  if (encoding == 4) {
#line 316
    goto case_4;
  }
#line 317
  if (encoding == 65537) {
#line 317
    goto case_65537;
  }
#line 318
  if (encoding == 131073) {
#line 318
    goto case_131073;
  }
#line 319
  if (encoding == 262148) {
#line 319
    goto case_262148;
  }
#line 314
  goto switch_break;
  case_2: 
#line 315
  return ("16 bit PCM\337G\270U");
  case_4: 
#line 316
  return ("32 bit float");
  case_65537: 
#line 317
  return ("A law");
  case_131073: 
#line 318
  return ("u lawU");
  case_262148: 
#line 319
  return ("32 bit PCM");
  switch_break: ;
#line 321
  return ("Unknown encoding\220");
}
}
#line 41 "/root/patchweave_new/23/src/htk.c"
static int htk_close(SF_PRIVATE *psf ) ;
#line 43
static int htk_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 44
static int htk_read_header(SF_PRIVATE *psf ) ;
#line 51 "/root/patchweave_new/23/src/htk.c"
int htk_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int __cil_tmp5 ;

  {
#line 53
  error = 0;
#line 55
  if (psf->is_pipe) {
#line 56
    return (144);
  }
#line 58
  if (psf->file.mode == 16) {
    _L: 
    {
#line 59
    error = htk_read_header(psf);
    }
#line 59
    if (error) {
#line 60
      return (error);
    }
  } else
#line 58
  if (psf->file.mode == 48) {
#line 58
    if (psf->filelength > 0L) {
#line 58
      goto _L;
    }
  }
#line 63
  subformat = psf->sf.format & 65535;
#line 65
  if (psf->file.mode == 32) {
    _L___37: 
#line 66
    if ((psf->sf.format & 268369920) != 1048576) {
#line 67
      return (1);
    }
    {
#line 69
    psf->endian = 536870912;
#line 71
    __cil_tmp5 = htk_write_header(psf, 0);
    }
#line 71
    if (__cil_tmp5) {
#line 72
      return (psf->error);
    }
#line 74
    psf->write_header = & htk_write_header;
  } else
#line 65
  if (psf->file.mode == 48) {
#line 65
    goto _L___37;
  }
#line 77
  psf->container_close = & htk_close;
#line 79
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 82
  if (subformat == 2) {
#line 82
    goto case_2;
  }
#line 86
  goto switch_default;
  case_2: 
  {
#line 83
  error = pcm_init(psf);
  }
#line 84
  goto switch_break;
  switch_default: 
#line 86
  goto switch_break;
  switch_break: ;
#line 89
  return (error);
}
}
#line 96 "/root/patchweave_new/23/src/htk.c"
static int htk_close(SF_PRIVATE *psf ) 
{ 


  {
#line 98
  if (psf->file.mode == 32) {
    {
#line 99
    htk_write_header(psf, 1);
    }
  } else
#line 98
  if (psf->file.mode == 48) {
    {
#line 99
    htk_write_header(psf, 1);
    }
  }
#line 101
  return (0);
}
}
#line 105 "/root/patchweave_new/23/src/htk.c"
static int htk_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int sample_count ;
  int sample_period ;

  {
  {
#line 109
  current = psf_ftell(psf);
  }
#line 111
  if (calc_length) {
    {
#line 112
    psf->filelength = psf_get_filelen(psf);
    }
  }
  {
#line 115
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 116
  psf->header.indx = (sf_count_t )0;
#line 117
  psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 119
  if (psf->filelength > 12L) {
#line 120
    sample_count = (int )((psf->filelength - 12L) / 2L);
  } else {
#line 122
    sample_count = 0;
  }
  {
#line 124
  sample_period = 10000000 / psf->sf.samplerate;
#line 126
  psf_binheader_writef(psf, "E444", sample_count, sample_period, 131072);
#line 129
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 131
  if (psf->error) {
#line 132
    return (psf->error);
  }
#line 134
  psf->dataoffset = psf->header.indx;
#line 136
  if (current > 0L) {
    {
#line 137
    psf_fseek(psf, current, 0);
    }
  }
#line 139
  return (psf->error);
}
}
#line 186 "/root/patchweave_new/23/src/htk.c"
static int htk_read_header(SF_PRIVATE *psf ) 
{ 
  int sample_count ;
  int sample_period ;
  int marker ;

  {
  {
#line 189
  psf_binheader_readf(psf, "pE444U", 0, & sample_count, & sample_period, & marker);
  }
#line 191
  if ((long )(2 * sample_count + 12) != psf->filelength) {
#line 192
    return (1666);
  }
#line 194
  if (marker != 131072) {
#line 195
    return (1667);
  }
#line 197
  psf->sf.channels = 1;
#line 199
  if (sample_period > 0) {
    {
#line 200
    psf->sf.samplerate = 10000000 / sample_period;
#line 201
    psf_log_printf(psf, "HTK Waveform file\n  Sample Count  : %d\n  Sample Period : %d => %d Hz\n",
                   sample_count, sample_period, psf->sf.samplerate);
    }
  } else {
    {
#line 205
    psf->sf.samplerate = 16000;
#line 206
    psf_log_printf(psf, "HTK Waveform file\n  Sample Count  : %d\n  Sample Period : %d (should be > 0) => Guessed sample rate %d Hz\n",
                   sample_count, sample_period, psf->sf.samplerate);
    }
  }
#line 210
  psf->sf.format = 1048578;
#line 211
  psf->bytewidth = 2;
#line 214
  psf->dataoffset = (sf_count_t )12;
#line 215
  psf->endian = 536870912;
#line 217
  psf->datalength = psf->filelength - psf->dataoffset;
#line 219
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 221
  if (! psf->sf.frames) {
#line 221
    if (psf->blockwidth) {
#line 222
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    }
  }
#line 224
  return (0);
}
}
#line 48 "/root/patchweave_new/23/src/g72x.c"
static int psf_g72x_decode_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x ) ;
#line 49
static int psf_g72x_encode_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x ) ;
#line 51
static sf_count_t g72x_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 52
static sf_count_t g72x_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 53
static sf_count_t g72x_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 54
static sf_count_t g72x_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 56
static sf_count_t g72x_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 57
static sf_count_t g72x_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 58
static sf_count_t g72x_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 59
static sf_count_t g72x_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 61
static sf_count_t g72x_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t UNUSED_offset ) ;
#line 63
static int g72x_close(SF_PRIVATE *psf ) ;
#line 71 "/root/patchweave_new/23/src/g72x.c"
int g72x_init(SF_PRIVATE *psf ) 
{ 
  G72x_PRIVATE *pg72x ;
  int bitspersample ;
  int bytesperblock ;
  int codec ;
  void *tmp ;

  {
#line 75
  if ((unsigned long )psf->codec_data != (unsigned long )((void *)0)) {
    {
#line 76
    psf_log_printf(psf, "*** psf->codec_data is not NULL.\n");
    }
#line 77
    return (30);
  }
#line 80
  psf->sf.seekable = 0;
#line 82
  if (psf->sf.channels != 1) {
#line 83
    return (140);
  }
  {
#line 85
  tmp = calloc(1UL, sizeof(G72x_PRIVATE ));
#line 85
  pg72x = (G72x_PRIVATE *)tmp;
  }
#line 85
  if ((unsigned long )pg72x == (unsigned long )((void *)0)) {
#line 86
    return (17);
  }
#line 88
  psf->codec_data = (void *)pg72x;
#line 90
  pg72x->block_curr = 0;
#line 91
  pg72x->sample_curr = 0;
#line 94
  if ((psf->sf.format & 65535) == 48) {
#line 94
    goto case_48;
  }
#line 100
  if ((psf->sf.format & 65535) == 49) {
#line 100
    goto case_49;
  }
#line 106
  if ((psf->sf.format & 65535) == 50) {
#line 106
    goto case_50;
  }
#line 112
  goto switch_default;
  case_48: 
#line 95
  codec = 4;
#line 96
  bytesperblock = 60;
#line 97
  bitspersample = 4;
#line 98
  goto switch_break;
  case_49: 
#line 101
  codec = 3;
#line 102
  bytesperblock = 45;
#line 103
  bitspersample = 3;
#line 104
  goto switch_break;
  case_50: 
#line 107
  codec = 5;
#line 108
  bytesperblock = 75;
#line 109
  bitspersample = 5;
#line 110
  goto switch_break;
  switch_default: 
#line 112
  return (18);
  switch_break: 
  {
#line 115
  psf->filelength = psf_get_filelen(psf);
  }
#line 116
  if (psf->filelength < psf->dataoffset) {
#line 117
    psf->filelength = psf->dataoffset;
  }
#line 119
  psf->datalength = psf->filelength - psf->dataoffset;
#line 120
  if (psf->dataend > 0L) {
#line 121
    psf->datalength -= psf->filelength - psf->dataend;
  }
#line 123
  if (psf->file.mode == 16) {
    {
#line 124
    pg72x->private = g72x_reader_init(codec, & pg72x->blocksize, & pg72x->samplesperblock);
    }
#line 125
    if ((unsigned long )pg72x->private == (unsigned long )((void *)0)) {
#line 126
      return (17);
    }
#line 128
    pg72x->bytesperblock = bytesperblock;
#line 130
    psf->read_short = & g72x_read_s;
#line 131
    psf->read_int = & g72x_read_i;
#line 132
    psf->read_float = & g72x_read_f;
#line 133
    psf->read_double = & g72x_read_d;
#line 135
    psf->seek = & g72x_seek;
#line 137
    if (psf->datalength % (long )pg72x->blocksize) {
      {
#line 138
      psf_log_printf(psf, "*** Odd psf->datalength (%D) should be a multiple of %d\n\230\001",
                     psf->datalength, pg72x->blocksize);
#line 139
      pg72x->blocks_total = (int )(psf->datalength / (long )pg72x->blocksize + 1L);
      }
    } else {
#line 142
      pg72x->blocks_total = (int )(psf->datalength / (long )pg72x->blocksize);
    }
    {
#line 144
    psf->sf.frames = (sf_count_t )(pg72x->blocks_total * pg72x->samplesperblock);
#line 146
    psf_g72x_decode_block(psf, pg72x);
    }
  } else
#line 148
  if (psf->file.mode == 32) {
    {
#line 149
    pg72x->private = g72x_writer_init(codec, & pg72x->blocksize, & pg72x->samplesperblock);
    }
#line 150
    if ((unsigned long )pg72x->private == (unsigned long )((void *)0)) {
#line 151
      return (17);
    }
#line 153
    pg72x->bytesperblock = bytesperblock;
#line 155
    psf->write_short = & g72x_write_s;
#line 156
    psf->write_int = & g72x_write_i;
#line 157
    psf->write_float = & g72x_write_f;
#line 158
    psf->write_double = & g72x_write_d;
#line 160
    if (psf->datalength % (long )pg72x->blocksize) {
#line 161
      pg72x->blocks_total = (int )(psf->datalength / (long )pg72x->blocksize + 1L);
    } else {
#line 163
      pg72x->blocks_total = (int )(psf->datalength / (long )pg72x->blocksize);
    }
#line 165
    if (psf->datalength > 0L) {
#line 166
      psf->sf.frames = (8L * psf->datalength) / (long )bitspersample;
    }
#line 168
    if ((psf->sf.frames * (long )bitspersample) / 8L != psf->datalength) {
      {
#line 169
      psf_log_printf(psf, "*** Warning : weird psf->datalength.\n");
      }
    }
  }
#line 172
  psf->codec_close = & g72x_close;
#line 174
  return (0);
}
}
#line 182 "/root/patchweave_new/23/src/g72x.c"
static int psf_g72x_decode_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x ) 
{ 
  int k ;
  sf_count_t __cil_tmp5 ;

  {
#line 185
  (pg72x->block_curr) ++;
#line 186
  pg72x->sample_curr = 0;
#line 188
  if (pg72x->block_curr > pg72x->blocks_total) {
    {
#line 189
    memset((void *)(pg72x->samples), 0, 120UL * sizeof(short ));
    }
#line 190
    return (1);
  }
  {
#line 193
  __cil_tmp5 = psf_fread((void *)(pg72x->block), (sf_count_t )1, (sf_count_t )pg72x->bytesperblock,
                         psf);
#line 193
  k = (int )__cil_tmp5;
  }
#line 193
  if (k != pg72x->bytesperblock) {
    {
#line 194
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, pg72x->bytesperblock);
    }
  }
  {
#line 196
  pg72x->blocksize = k;
#line 197
  g72x_decode_block(pg72x->private, (unsigned char const   *)(pg72x->block), pg72x->samples);
  }
#line 199
  return (1);
}
}
#line 203 "/root/patchweave_new/23/src/g72x.c"
static int g72x_read_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x , short *ptr , int len ) 
{ 
  int count___0 ;
  int total ;
  int indx ;
  int tmp ;

  {
#line 204
  total = 0;
#line 204
  indx = 0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;

#line 206
    if (! (indx < len)) {
#line 206
      goto while_break;
    }
#line 207
    if (pg72x->block_curr > pg72x->blocks_total) {
      {
#line 208
      memset((void *)(ptr + indx), 0, (unsigned long )(len - indx) * sizeof(short ));
      }
#line 209
      return (total);
    }
#line 212
    if (pg72x->sample_curr >= pg72x->samplesperblock) {
      {
#line 213
      psf_g72x_decode_block(psf, pg72x);
      }
    }
#line 215
    count___0 = pg72x->samplesperblock - pg72x->sample_curr;
#line 216
    if (len - indx > count___0) {
#line 216
      tmp = count___0;
    } else {
#line 216
      tmp = len - indx;
    }
    {
#line 216
    count___0 = tmp;
#line 218
    memcpy((void *)(ptr + indx), (void const   *)(& pg72x->samples[pg72x->sample_curr]),
           (unsigned long )count___0 * sizeof(short ));
#line 219
    indx += count___0;
#line 220
    pg72x->sample_curr += count___0;
#line 221
    total = indx;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 224
  return (total);
}
}
#line 228 "/root/patchweave_new/23/src/g72x.c"
static sf_count_t g72x_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  G72x_PRIVATE *pg72x ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 231
  total = (sf_count_t )0;
#line 233
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 234
    return ((sf_count_t )0);
  }
#line 235
  pg72x = (G72x_PRIVATE *)psf->codec_data;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;

#line 237
    if (! (len > 0L)) {
#line 237
      goto while_break;
    }
#line 238
    if (len > 268435456L) {
#line 238
      tmp = 268435456;
    } else {
#line 238
      tmp = (int )len;
    }
    {
#line 238
    readcount = tmp;
#line 240
    count___0 = g72x_read_block(psf, pg72x, ptr, readcount);
#line 242
    total += (long )count___0;
#line 243
    len -= (long )count___0;
    }
#line 245
    if (count___0 != readcount) {
#line 246
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 249
  return (total);
}
}
#line 253 "/root/patchweave_new/23/src/g72x.c"
static sf_count_t g72x_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 257
  readcount = 0;
#line 258
  total = (sf_count_t )0;
#line 260
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 261
    return ((sf_count_t )0);
  }
#line 262
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 264
  sptr = ubuf.sbuf;
#line 265
  bufferlen = (int )(8192UL / sizeof(short ));
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;

#line 266
    if (! (len > 0L)) {
#line 266
      goto while_break;
    }
#line 267
    if (len >= (long )bufferlen) {
#line 267
      tmp = (long )bufferlen;
    } else {
#line 267
      tmp = len;
    }
    {
#line 267
    readcount = (int )tmp;
#line 268
    count___0 = g72x_read_block(psf, pg72x, sptr, readcount);
#line 270
    k = 0;
    }
    {
#line 270
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 270
      if (! (k < readcount)) {
#line 270
        goto while_break___0;
      }
      {
#line 271
      *(ptr + (total + (long )k)) = arith_shift_left((int32_t )*(sptr + k), 16);
#line 270
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 273
    total += (long )count___0;
#line 274
    len -= (long )readcount;
#line 275
    if (count___0 != readcount) {
#line 276
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 279
  return (total);
}
}
#line 283 "/root/patchweave_new/23/src/g72x.c"
static sf_count_t g72x_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 287
  readcount = 0;
#line 288
  total = (sf_count_t )0;
#line 291
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 292
    return ((sf_count_t )0);
  }
#line 293
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 295
  if (psf->norm_float == 1) {
#line 295
    tmp = 1. / (double )((float )32768);
  } else {
#line 295
    tmp = 1.;
  }
#line 295
  normfact = (float )tmp;
#line 297
  sptr = ubuf.sbuf;
#line 298
  bufferlen = (int )(8192UL / sizeof(short ));
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;

#line 299
    if (! (len > 0L)) {
#line 299
      goto while_break;
    }
#line 300
    if (len >= (long )bufferlen) {
#line 300
      tmp___0 = (long )bufferlen;
    } else {
#line 300
      tmp___0 = len;
    }
    {
#line 300
    readcount = (int )tmp___0;
#line 301
    count___0 = g72x_read_block(psf, pg72x, sptr, readcount);
#line 302
    k = 0;
    }
    {
#line 302
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 302
      if (! (k < readcount)) {
#line 302
        goto while_break___0;
      }
#line 303
      *(ptr + (total + (long )k)) = normfact * (float )((int )*(sptr + k));
#line 302
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 305
    total += (long )count___0;
#line 306
    len -= (long )readcount;
#line 307
    if (count___0 != readcount) {
#line 308
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 311
  return (total);
}
}
#line 315 "/root/patchweave_new/23/src/g72x.c"
static sf_count_t g72x_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 319
  readcount = 0;
#line 320
  total = (sf_count_t )0;
#line 323
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 324
    return ((sf_count_t )0);
  }
#line 325
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 327
  if (psf->norm_double == 1) {
#line 327
    tmp = 1. / (double )32768;
  } else {
#line 327
    tmp = 1.;
  }
#line 327
  normfact = tmp;
#line 329
  sptr = ubuf.sbuf;
#line 330
  bufferlen = (int )(8192UL / sizeof(short ));
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;

#line 331
    if (! (len > 0L)) {
#line 331
      goto while_break;
    }
#line 332
    if (len >= (long )bufferlen) {
#line 332
      tmp___0 = (long )bufferlen;
    } else {
#line 332
      tmp___0 = len;
    }
    {
#line 332
    readcount = (int )tmp___0;
#line 333
    count___0 = g72x_read_block(psf, pg72x, sptr, readcount);
#line 334
    k = 0;
    }
    {
#line 334
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 334
      if (! (k < readcount)) {
#line 334
        goto while_break___0;
      }
#line 335
      *(ptr + (total + (long )k)) = normfact * (double )*(sptr + k);
#line 334
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 337
    total += (long )count___0;
#line 338
    len -= (long )readcount;
#line 339
    if (count___0 != readcount) {
#line 340
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 343
  return (total);
}
}
#line 347 "/root/patchweave_new/23/src/g72x.c"
static sf_count_t g72x_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t UNUSED_offset ) 
{ 


  {
  {
#line 349
  psf_log_printf(psf, "seek unsupported\n\377\377\377");
  }
#line 355
  return ((sf_count_t )0);
}
}
#line 428 "/root/patchweave_new/23/src/g72x.c"
static int psf_g72x_encode_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x ) 
{ 
  int k ;
  sf_count_t __cil_tmp4 ;

  {
  {
#line 432
  g72x_encode_block(pg72x->private, pg72x->samples, pg72x->block);
#line 435
  __cil_tmp4 = psf_fwrite((void const   *)(pg72x->block), (sf_count_t )1, (sf_count_t )pg72x->blocksize,
                          psf);
#line 435
  k = (int )__cil_tmp4;
  }
#line 435
  if (k != pg72x->blocksize) {
    {
#line 436
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, pg72x->blocksize);
    }
  }
  {
#line 438
  pg72x->sample_curr = 0;
#line 439
  (pg72x->block_curr) ++;
#line 442
  memset((void *)(pg72x->samples), 0, 120UL * sizeof(short ));
  }
#line 444
  return (1);
}
}
#line 448 "/root/patchweave_new/23/src/g72x.c"
static int g72x_write_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x , short const   *ptr ,
                            int len ) 
{ 
  int count___0 ;
  int total ;
  int indx ;

  {
#line 449
  total = 0;
#line 449
  indx = 0;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;

#line 451
    if (! (indx < len)) {
#line 451
      goto while_break;
    }
#line 452
    count___0 = pg72x->samplesperblock - pg72x->sample_curr;
#line 454
    if (count___0 > len - indx) {
#line 455
      count___0 = len - indx;
    }
    {
#line 457
    memcpy((void *)(& pg72x->samples[pg72x->sample_curr]), (void const   *)(ptr + indx),
           (unsigned long )count___0 * sizeof(short ));
#line 458
    indx += count___0;
#line 459
    pg72x->sample_curr += count___0;
#line 460
    total = indx;
    }
#line 462
    if (pg72x->sample_curr >= pg72x->samplesperblock) {
      {
#line 463
      psf_g72x_encode_block(psf, pg72x);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 466
  return (total);
}
}
#line 470 "/root/patchweave_new/23/src/g72x.c"
static sf_count_t g72x_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  G72x_PRIVATE *pg72x ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 473
  total = (sf_count_t )0;
#line 475
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 476
    return ((sf_count_t )0);
  }
#line 477
  pg72x = (G72x_PRIVATE *)psf->codec_data;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;

#line 479
    if (! (len > 0L)) {
#line 479
      goto while_break;
    }
#line 480
    if (len > 268435456L) {
#line 480
      tmp = 268435456;
    } else {
#line 480
      tmp = (int )len;
    }
    {
#line 480
    writecount = tmp;
#line 482
    count___0 = g72x_write_block(psf, pg72x, ptr, writecount);
#line 484
    total += (long )count___0;
#line 485
    len -= (long )count___0;
    }
#line 486
    if (count___0 != writecount) {
#line 487
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 490
  return (total);
}
}
#line 494 "/root/patchweave_new/23/src/g72x.c"
static sf_count_t g72x_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 498
  writecount = 0;
#line 499
  total = (sf_count_t )0;
#line 501
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 502
    return ((sf_count_t )0);
  }
#line 503
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 505
  sptr = ubuf.sbuf;
#line 506
  bufferlen = (int )(8192UL / sizeof(short ));
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;

#line 507
    if (! (len > 0L)) {
#line 507
      goto while_break;
    }
#line 508
    if (len >= (long )bufferlen) {
#line 508
      tmp = (long )bufferlen;
    } else {
#line 508
      tmp = len;
    }
#line 508
    writecount = (int )tmp;
#line 509
    k = 0;
    {
#line 509
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 509
      if (! (k < writecount)) {
#line 509
        goto while_break___0;
      }
#line 510
      *(sptr + k) = (short )(*(ptr + (total + (long )k)) >> 16);
#line 509
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 511
    count___0 = g72x_write_block(psf, pg72x, (short const   *)sptr, writecount);
#line 513
    total += (long )count___0;
#line 514
    len -= (long )writecount;
    }
#line 515
    if (count___0 != writecount) {
#line 516
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 518
  return (total);
}
}
#line 522 "/root/patchweave_new/23/src/g72x.c"
static sf_count_t g72x_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 526
  writecount = 0;
#line 527
  total = (sf_count_t )0;
#line 530
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 531
    return ((sf_count_t )0);
  }
#line 532
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 534
  if (psf->norm_float == 1) {
#line 534
    tmp = 1. * (double )32768;
  } else {
#line 534
    tmp = 1.;
  }
#line 534
  normfact = (float )tmp;
#line 536
  sptr = ubuf.sbuf;
#line 537
  bufferlen = (int )(8192UL / sizeof(short ));
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;

#line 538
    if (! (len > 0L)) {
#line 538
      goto while_break;
    }
#line 539
    if (len >= (long )bufferlen) {
#line 539
      tmp___0 = (long )bufferlen;
    } else {
#line 539
      tmp___0 = len;
    }
#line 539
    writecount = (int )tmp___0;
#line 540
    k = 0;
    {
#line 540
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 540
      if (! (k < writecount)) {
#line 540
        goto while_break___0;
      }
      {
#line 541
      __cil_tmp15 = lrintf(normfact * (float )*(ptr + (total + (long )k)));
#line 541
      *(sptr + k) = (short )__cil_tmp15;
#line 540
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 542
    count___0 = g72x_write_block(psf, pg72x, (short const   *)sptr, writecount);
#line 544
    total += (long )count___0;
#line 545
    len -= (long )writecount;
    }
#line 546
    if (count___0 != writecount) {
#line 547
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 550
  return (total);
}
}
#line 554 "/root/patchweave_new/23/src/g72x.c"
static sf_count_t g72x_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 558
  writecount = 0;
#line 559
  total = (sf_count_t )0;
#line 562
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 563
    return ((sf_count_t )0);
  }
#line 564
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 566
  if (psf->norm_double == 1) {
#line 566
    tmp = 1. * (double )32768;
  } else {
#line 566
    tmp = 1.;
  }
#line 566
  normfact = tmp;
#line 568
  sptr = ubuf.sbuf;
#line 569
  bufferlen = (int )(8192UL / sizeof(short ));
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;

#line 570
    if (! (len > 0L)) {
#line 570
      goto while_break;
    }
#line 571
    if (len >= (long )bufferlen) {
#line 571
      tmp___0 = (long )bufferlen;
    } else {
#line 571
      tmp___0 = len;
    }
#line 571
    writecount = (int )tmp___0;
#line 572
    k = 0;
    {
#line 572
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 572
      if (! (k < writecount)) {
#line 572
        goto while_break___0;
      }
      {
#line 573
      __cil_tmp15 = lrint(normfact * (double )*(ptr + (total + (long )k)));
#line 573
      *(sptr + k) = (short )__cil_tmp15;
#line 572
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 574
    count___0 = g72x_write_block(psf, pg72x, (short const   *)sptr, writecount);
#line 576
    total += (long )count___0;
#line 577
    len -= (long )writecount;
    }
#line 578
    if (count___0 != writecount) {
#line 579
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 582
  return (total);
}
}
#line 586 "/root/patchweave_new/23/src/g72x.c"
static int g72x_close(SF_PRIVATE *psf ) 
{ 
  G72x_PRIVATE *pg72x ;

  {
#line 589
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 591
  if (psf->file.mode == 32) {
#line 596
    if (pg72x->sample_curr) {
#line 596
      if (pg72x->sample_curr < 120) {
        {
#line 597
        psf_g72x_encode_block(psf, pg72x);
        }
      }
    }
#line 599
    if (psf->write_header) {
      {
#line 600
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 604
  free((void *)pg72x->private);
  }
#line 606
  return (0);
}
}
#line 251 "/usr/include/FLAC/stream_decoder.h"
extern char const   * const  FLAC__StreamDecoderStateString[] ;
#line 448
extern char const   * const  FLAC__StreamDecoderErrorStatusString[] ;
#line 743
extern FLAC__StreamDecoder *FLAC__stream_decoder_new(void) ;
#line 751
extern void FLAC__stream_decoder_delete(FLAC__StreamDecoder *decoder ) ;
#line 839
extern FLAC__bool FLAC__stream_decoder_set_metadata_respond_all(FLAC__StreamDecoder *decoder ) ;
#line 890
extern FLAC__StreamDecoderState FLAC__stream_decoder_get_state(FLAC__StreamDecoder *decoder ) ;
#line 1007
extern FLAC__bool FLAC__stream_decoder_get_decode_position(FLAC__StreamDecoder *decoder ,
                                                           FLAC__uint64 *position ) ;
#line 1073
extern FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_stream(FLAC__StreamDecoder *decoder ,
                                                                      FLAC__StreamDecoderReadStatus (*read_callback)(FLAC__StreamDecoder * ,
                                                                                                                     FLAC__byte * ,
                                                                                                                     size_t * ,
                                                                                                                     void * ) ,
                                                                      FLAC__StreamDecoderSeekStatus (*seek_callback)(FLAC__StreamDecoder * ,
                                                                                                                     FLAC__uint64  ,
                                                                                                                     void * ) ,
                                                                      FLAC__StreamDecoderTellStatus (*tell_callback)(FLAC__StreamDecoder * ,
                                                                                                                     FLAC__uint64 * ,
                                                                                                                     void * ) ,
                                                                      FLAC__StreamDecoderLengthStatus (*length_callback)(FLAC__StreamDecoder * ,
                                                                                                                         FLAC__uint64 * ,
                                                                                                                         void * ) ,
                                                                      FLAC__bool (*eof_callback)(FLAC__StreamDecoder * ,
                                                                                                 void * ) ,
                                                                      FLAC__StreamDecoderWriteStatus (*write_callback)(FLAC__StreamDecoder * ,
                                                                                                                       FLAC__Frame * ,
                                                                                                                       FLAC__int32 * const  * ,
                                                                                                                       void * ) ,
                                                                      void (*metadata_callback)(FLAC__StreamDecoder * ,
                                                                                                FLAC__StreamMetadata * ,
                                                                                                void * ) ,
                                                                      void (*error_callback)(FLAC__StreamDecoder * ,
                                                                                             FLAC__StreamDecoderErrorStatus  ,
                                                                                             void * ) ,
                                                                      void *client_data ) ;
#line 1370
extern FLAC__bool FLAC__stream_decoder_finish(FLAC__StreamDecoder *decoder ) ;
#line 1450
extern FLAC__bool FLAC__stream_decoder_process_single(FLAC__StreamDecoder *decoder ) ;
#line 1471
extern FLAC__bool FLAC__stream_decoder_process_until_end_of_metadata(FLAC__StreamDecoder *decoder ) ;
#line 1551
extern FLAC__bool FLAC__stream_decoder_seek_absolute(FLAC__StreamDecoder *decoder ,
                                                     FLAC__uint64 sample ) ;
#line 358 "/usr/include/FLAC/stream_encoder.h"
extern char const   * const  FLAC__StreamEncoderInitStatusString[] ;
#line 694
extern FLAC__StreamEncoder *FLAC__stream_encoder_new(void) ;
#line 702
extern void FLAC__stream_encoder_delete(FLAC__StreamEncoder *encoder ) ;
#line 774
extern FLAC__bool FLAC__stream_encoder_set_channels(FLAC__StreamEncoder *encoder ,
                                                    uint32_t value ) ;
#line 790
extern FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder ,
                                                           uint32_t value ) ;
#line 802
extern FLAC__bool FLAC__stream_encoder_set_sample_rate(FLAC__StreamEncoder *encoder ,
                                                       uint32_t value ) ;
#line 865
extern FLAC__bool FLAC__stream_encoder_set_compression_level(FLAC__StreamEncoder *encoder ,
                                                             uint32_t value ) ;
#line 1203
extern FLAC__bool FLAC__stream_encoder_set_metadata(FLAC__StreamEncoder *encoder ,
                                                    FLAC__StreamMetadata **metadata ,
                                                    uint32_t num_blocks ) ;
#line 1493
extern FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_stream(FLAC__StreamEncoder *encoder ,
                                                                      FLAC__StreamEncoderWriteStatus (*write_callback)(FLAC__StreamEncoder * ,
                                                                                                                       FLAC__byte * ,
                                                                                                                       size_t  ,
                                                                                                                       uint32_t  ,
                                                                                                                       uint32_t  ,
                                                                                                                       void * ) ,
                                                                      FLAC__StreamEncoderSeekStatus (*seek_callback)(FLAC__StreamEncoder * ,
                                                                                                                     FLAC__uint64  ,
                                                                                                                     void * ) ,
                                                                      FLAC__StreamEncoderTellStatus (*tell_callback)(FLAC__StreamEncoder * ,
                                                                                                                     FLAC__uint64 * ,
                                                                                                                     void * ) ,
                                                                      void (*metadata_callback)(FLAC__StreamEncoder * ,
                                                                                                FLAC__StreamMetadata * ,
                                                                                                void * ) ,
                                                                      void *client_data ) ;
#line 1723
extern FLAC__bool FLAC__stream_encoder_finish(FLAC__StreamEncoder *encoder ) ;
#line 1782
extern FLAC__bool FLAC__stream_encoder_process_interleaved(FLAC__StreamEncoder *encoder ,
                                                           FLAC__int32 *buffer , uint32_t samples ) ;
#line 1313 "/usr/include/FLAC/metadata.h"
extern FLAC__StreamMetadata *FLAC__metadata_object_new(FLAC__MetadataType type ) ;
#line 1338
extern void FLAC__metadata_object_delete(FLAC__StreamMetadata *object ) ;
#line 1688
extern FLAC__bool FLAC__metadata_object_vorbiscomment_append_comment(FLAC__StreamMetadata *object ,
                                                                     FLAC__StreamMetadata_VorbisComment_Entry entry ,
                                                                     FLAC__bool copy ) ;
#line 1757
extern FLAC__bool FLAC__metadata_object_vorbiscomment_entry_from_name_value_pair(FLAC__StreamMetadata_VorbisComment_Entry *entry ,
                                                                                 char const   *field_name ,
                                                                                 char const   *field_value ) ;
#line 1811
extern int FLAC__metadata_object_vorbiscomment_find_entry_from(FLAC__StreamMetadata *object ,
                                                               uint32_t offset , char const   *field_name ) ;
#line 81 "/root/patchweave_new/23/src/flac.c"
static sf_count_t flac_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) ;
#line 82
static int flac_byterate(SF_PRIVATE *psf ) ;
#line 83
static int flac_close(SF_PRIVATE *psf ) ;
#line 85
static int flac_enc_init(SF_PRIVATE *psf ) ;
#line 86
static int flac_read_header(SF_PRIVATE *psf ) ;
#line 88
static sf_count_t flac_read_flac2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 89
static sf_count_t flac_read_flac2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 90
static sf_count_t flac_read_flac2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 91
static sf_count_t flac_read_flac2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 93
static sf_count_t flac_write_s2flac(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 94
static sf_count_t flac_write_i2flac(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 95
static sf_count_t flac_write_f2flac(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 96
static sf_count_t flac_write_d2flac(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 98
static void f2flac8_array(float const   *src , int32_t *dest , int count___0 , int normalize ) ;
#line 99
static void f2flac16_array(float const   *src , int32_t *dest , int count___0 , int normalize ) ;
#line 100
static void f2flac24_array(float const   *src , int32_t *dest , int count___0 , int normalize ) ;
#line 101
static void f2flac8_clip_array(float const   *src , int32_t *dest , int count___0 ,
                               int normalize ) ;
#line 102
static void f2flac16_clip_array(float const   *src , int32_t *dest , int count___0 ,
                                int normalize ) ;
#line 103
static void f2flac24_clip_array(float const   *src , int32_t *dest , int count___0 ,
                                int normalize ) ;
#line 104
static void d2flac8_array(double const   *src , int32_t *dest , int count___0 , int normalize ) ;
#line 105
static void d2flac16_array(double const   *src , int32_t *dest , int count___0 , int normalize ) ;
#line 106
static void d2flac24_array(double const   *src , int32_t *dest , int count___0 , int normalize ) ;
#line 107
static void d2flac8_clip_array(double const   *src , int32_t *dest , int count___0 ,
                               int normalize ) ;
#line 108
static void d2flac16_clip_array(double const   *src , int32_t *dest , int count___0 ,
                                int normalize ) ;
#line 109
static void d2flac24_clip_array(double const   *src , int32_t *dest , int count___0 ,
                                int normalize ) ;
#line 111
static int flac_command(SF_PRIVATE *psf , int command , void *data , int datasize ) ;
#line 114
static FLAC__StreamDecoderReadStatus sf_flac_read_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__byte *buffer , size_t *bytes ,
                                                           void *client_data ) ;
#line 115
static FLAC__StreamDecoderSeekStatus sf_flac_seek_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__uint64 absolute_byte_offset ,
                                                           void *client_data ) ;
#line 116
static FLAC__StreamDecoderTellStatus sf_flac_tell_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__uint64 *absolute_byte_offset ,
                                                           void *client_data ) ;
#line 117
static FLAC__StreamDecoderLengthStatus sf_flac_length_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                               FLAC__uint64 *stream_length ,
                                                               void *client_data ) ;
#line 118
static FLAC__bool sf_flac_eof_callback(FLAC__StreamDecoder *UNUSED_decoder , void *client_data ) ;
#line 119
static FLAC__StreamDecoderWriteStatus sf_flac_write_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                             FLAC__Frame *frame ,
                                                             int32_t * const  *buffer ,
                                                             void *client_data ) ;
#line 120
static void sf_flac_meta_callback(FLAC__StreamDecoder *UNUSED_decoder , FLAC__StreamMetadata *metadata ,
                                  void *client_data ) ;
#line 121
static void sf_flac_error_callback(FLAC__StreamDecoder *UNUSED_decoder , FLAC__StreamDecoderErrorStatus status ,
                                   void *client_data ) ;
#line 124
static FLAC__StreamEncoderSeekStatus sf_flac_enc_seek_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                               FLAC__uint64 absolute_byte_offset ,
                                                               void *client_data ) ;
#line 125
static FLAC__StreamEncoderTellStatus sf_flac_enc_tell_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                               FLAC__uint64 *absolute_byte_offset ,
                                                               void *client_data ) ;
#line 126
static FLAC__StreamEncoderWriteStatus sf_flac_enc_write_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                                 FLAC__byte *buffer ,
                                                                 size_t bytes , unsigned int UNUSED_samples ,
                                                                 unsigned int UNUSED_current_frame ,
                                                                 void *client_data ) ;
#line 129 "/root/patchweave_new/23/src/flac.c"
static void s2flac8_array(short const   *src , int32_t *dest , int count___0 ) 
{ 


  {
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    count___0 --;
#line 130
    if (! (count___0 >= 0)) {
#line 130
      goto while_break;
    }
#line 131
    *(dest + count___0) = (int )*(src + count___0) >> 8;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 135
  return;
}
}
#line 135 "/root/patchweave_new/23/src/flac.c"
static void s2flac16_array(short const   *src , int32_t *dest , int count___0 ) 
{ 


  {
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    count___0 --;
#line 136
    if (! (count___0 >= 0)) {
#line 136
      goto while_break;
    }
#line 137
    *(dest + count___0) = (int32_t )*(src + count___0);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 141
  return;
}
}
#line 141 "/root/patchweave_new/23/src/flac.c"
static void s2flac24_array(short const   *src , int32_t *dest , int count___0 ) 
{ 


  {
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    count___0 --;
#line 142
    if (! (count___0 >= 0)) {
#line 142
      goto while_break;
    }
#line 143
    *(dest + count___0) = (int )*(src + count___0) << 8;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 147
  return;
}
}
#line 147 "/root/patchweave_new/23/src/flac.c"
static void i2flac8_array(int const   *src , int32_t *dest , int count___0 ) 
{ 


  {
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    count___0 --;
#line 148
    if (! (count___0 >= 0)) {
#line 148
      goto while_break;
    }
#line 149
    *(dest + count___0) = (int32_t )(*(src + count___0) >> 24);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 153
  return;
}
}
#line 153 "/root/patchweave_new/23/src/flac.c"
static void i2flac16_array(int const   *src , int32_t *dest , int count___0 ) 
{ 


  {
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    count___0 --;
#line 155
    if (! (count___0 >= 0)) {
#line 155
      goto while_break;
    }
#line 156
    *(dest + count___0) = (int32_t )(*(src + count___0) >> 16);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 160
  return;
}
}
#line 160 "/root/patchweave_new/23/src/flac.c"
static void i2flac24_array(int const   *src , int32_t *dest , int count___0 ) 
{ 


  {
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    count___0 --;
#line 161
    if (! (count___0 >= 0)) {
#line 161
      goto while_break;
    }
#line 162
    *(dest + count___0) = (int32_t )(*(src + count___0) >> 8);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 166
  return;
}
}
#line 166 "/root/patchweave_new/23/src/flac.c"
static sf_count_t flac_buffer_copy(SF_PRIVATE *psf ) 
{ 
  FLAC_PRIVATE *pflac ;
  FLAC__Frame *frame ;
  int32_t * const  *buffer ;
  unsigned int i ;
  unsigned int j ;
  unsigned int offset ;
  unsigned int channels ;
  unsigned int len ;
  short *retpcm ;
  int shift ;
  int *retpcm___0 ;
  int shift___0 ;
  float *retpcm___1 ;
  float norm ;
  double tmp ;
  double *retpcm___2 ;
  double norm___0 ;
  double tmp___0 ;
  void *tmp___1 ;

  {
#line 167
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 168
  frame = pflac->frame;
#line 169
  buffer = pflac->wbuffer;
#line 170
  i = 0U;
#line 177
  if (frame->header.blocksize > 65535U) {
    {
#line 178
    psf_log_printf(psf, "Ooops : frame->header.blocksize (%d) > FLAC__MAX_BLOCK_SIZE (%d)\n",
                   "flac_buffer_copy\312\001@", 178, frame->header.blocksize, 65535U);
#line 179
    psf->error = 30;
    }
#line 180
    return ((sf_count_t )0);
  }
#line 183
  if (frame->header.channels > 8U) {
    {
#line 184
    psf_log_printf(psf, "Ooops : frame->header.channels (%d) > FLAC__MAX_BLOCK_SIZE (%d)\n\323\001 ",
                   "flac_buffer_copy\312\001@", 184, frame->header.channels, 8U);
    }
  }
#line 186
  channels = 0U;
#line 188
  if ((unsigned long )pflac->ptr == (unsigned long )((void *)0)) {
#line 193
    i = 0U;
    {
#line 193
    while (1) {
      while_continue: /* CIL Label */ ;

#line 193
      if (! (i < channels)) {
#line 193
        goto while_break;
      }
#line 195
      if ((unsigned long )pflac->rbuffer[i] == (unsigned long )((void *)0)) {
        {
#line 196
        tmp___1 = calloc(65535UL, sizeof(int32_t ));
#line 196
        pflac->rbuffer[i] = (int32_t *)tmp___1;
        }
      }
      {
#line 198
      memcpy((void *)pflac->rbuffer[i], (void const   *)*(buffer + i), (unsigned long )frame->header.blocksize * sizeof(int32_t ));
#line 193
      i ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break: 
#line 200
    pflac->wbuffer = (int32_t * const  *)(pflac->rbuffer);
#line 202
    return ((sf_count_t )0);
  }
#line 206
  len = 0U;
#line 208
  if (pflac->remain % channels != 0U) {
    {
#line 209
    psf_log_printf(psf, "Error: pflac->remain %u    channels %u\n", pflac->remain,
                   channels);
    }
#line 210
    return ((sf_count_t )0);
  }
#line 214
  if ((unsigned int )pflac->pcmtype == 50U) {
#line 214
    goto case_50;
  }
#line 254
  if ((unsigned int )pflac->pcmtype == 51U) {
#line 254
    goto case_51;
  }
#line 274
  if ((unsigned int )pflac->pcmtype == 52U) {
#line 274
    goto case_52;
  }
#line 295
  if ((unsigned int )pflac->pcmtype == 53U) {
#line 295
    goto case_53;
  }
#line 316
  goto switch_default;
  case_50: 
#line 215
  retpcm = (short *)pflac->ptr;
#line 216
  shift = (int )(16U - frame->header.bits_per_sample);
#line 217
  if (shift < 0) {
    {
#line 218
    shift = abs(shift);
#line 219
    i = 0U;
    }
    {
#line 219
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 219
      if (i < len) {
#line 219
        if (! (pflac->remain > 0U)) {
#line 219
          goto while_break___0;
        }
      } else {
#line 219
        goto while_break___0;
      }
#line 220
      offset = pflac->pos + i * channels;
#line 222
      if (pflac->bufferpos >= frame->header.blocksize) {
#line 223
        goto while_break___0;
      }
#line 225
      if (offset + channels > pflac->len) {
#line 226
        goto while_break___0;
      }
#line 228
      j = 0U;
      {
#line 228
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 228
        if (! (j < channels)) {
#line 228
          goto while_break___1;
        }
#line 229
        *(retpcm + (offset + j)) = (short )(*(*(buffer + j) + pflac->bufferpos) >> shift);
#line 228
        j ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___1: 
#line 230
      pflac->remain -= channels;
#line 231
      (pflac->bufferpos) ++;
#line 219
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___0: ;
  } else {
#line 235
    i = 0U;
    {
#line 235
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 235
      if (i < len) {
#line 235
        if (! (pflac->remain > 0U)) {
#line 235
          goto while_break___2;
        }
      } else {
#line 235
        goto while_break___2;
      }
#line 236
      offset = pflac->pos + i * channels;
#line 238
      if (pflac->bufferpos >= frame->header.blocksize) {
#line 239
        goto while_break___2;
      }
#line 241
      if (offset + channels > pflac->len) {
#line 242
        goto while_break___2;
      }
#line 244
      j = 0U;
      {
#line 244
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 244
        if (! (j < channels)) {
#line 244
          goto while_break___3;
        }
#line 245
        *(retpcm + (offset + j)) = (short )((int )((uint16_t )*(*(buffer + j) + pflac->bufferpos)) << shift);
#line 244
        j ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___3: 
#line 247
      pflac->remain -= channels;
#line 248
      (pflac->bufferpos) ++;
#line 235
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 252
  goto switch_break;
  case_51: 
#line 255
  retpcm___0 = (int *)pflac->ptr;
#line 256
  shift___0 = (int )(32U - frame->header.bits_per_sample);
#line 257
  i = 0U;
  {
#line 257
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 257
    if (i < len) {
#line 257
      if (! (pflac->remain > 0U)) {
#line 257
        goto while_break___4;
      }
    } else {
#line 257
      goto while_break___4;
    }
#line 258
    offset = pflac->pos + i * channels;
#line 260
    if (pflac->bufferpos >= frame->header.blocksize) {
#line 261
      goto while_break___4;
    }
#line 263
    if (offset + channels > pflac->len) {
#line 264
      goto while_break___4;
    }
#line 266
    j = 0U;
    {
#line 266
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 266
      if (! (j < channels)) {
#line 266
        goto while_break___5;
      }
#line 267
      *(retpcm___0 + (offset + j)) = (int )((uint32_t )*(*(buffer + j) + pflac->bufferpos) << shift___0);
#line 266
      j ++;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___5: 
#line 268
    pflac->remain -= channels;
#line 269
    (pflac->bufferpos) ++;
#line 257
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___4: ;
#line 272
  goto switch_break;
  case_52: 
#line 275
  retpcm___1 = (float *)pflac->ptr;
#line 276
  if (psf->norm_float == 1) {
#line 276
    tmp = 1. / (double )(1 << (frame->header.bits_per_sample - 1U));
  } else {
#line 276
    tmp = 1.;
  }
#line 276
  norm = (float )tmp;
#line 278
  i = 0U;
  {
#line 278
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 278
    if (i < len) {
#line 278
      if (! (pflac->remain > 0U)) {
#line 278
        goto while_break___6;
      }
    } else {
#line 278
      goto while_break___6;
    }
#line 279
    offset = pflac->pos + i * channels;
#line 281
    if (pflac->bufferpos >= frame->header.blocksize) {
#line 282
      goto while_break___6;
    }
#line 284
    if (offset + channels > pflac->len) {
#line 285
      goto while_break___6;
    }
#line 287
    j = 0U;
    {
#line 287
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 287
      if (! (j < channels)) {
#line 287
        goto while_break___7;
      }
#line 288
      *(retpcm___1 + (offset + j)) = (float )*(*(buffer + j) + pflac->bufferpos) * norm;
#line 287
      j ++;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___7: 
#line 289
    pflac->remain -= channels;
#line 290
    (pflac->bufferpos) ++;
#line 278
    i ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___6: ;
#line 293
  goto switch_break;
  case_53: 
#line 296
  retpcm___2 = (double *)pflac->ptr;
#line 297
  if (psf->norm_double == 1) {
#line 297
    tmp___0 = 1. / (double )(1 << (frame->header.bits_per_sample - 1U));
  } else {
#line 297
    tmp___0 = 1.;
  }
#line 297
  norm___0 = tmp___0;
#line 299
  i = 0U;
  {
#line 299
  while (1) {
    while_continue___8: /* CIL Label */ ;

#line 299
    if (i < len) {
#line 299
      if (! (pflac->remain > 0U)) {
#line 299
        goto while_break___8;
      }
    } else {
#line 299
      goto while_break___8;
    }
#line 300
    offset = pflac->pos + i * channels;
#line 302
    if (pflac->bufferpos >= frame->header.blocksize) {
#line 303
      goto while_break___8;
    }
#line 305
    if (offset + channels > pflac->len) {
#line 306
      goto while_break___8;
    }
#line 308
    j = 0U;
    {
#line 308
    while (1) {
      while_continue___9: /* CIL Label */ ;

#line 308
      if (! (j < channels)) {
#line 308
        goto while_break___9;
      }
#line 309
      *(retpcm___2 + (offset + j)) = (double )*(*(buffer + j) + pflac->bufferpos) * norm___0;
#line 308
      j ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___9: 
#line 310
    pflac->remain -= channels;
#line 311
    (pflac->bufferpos) ++;
#line 299
    i ++;
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break___8: ;
#line 314
  goto switch_break;
  switch_default: 
#line 317
  return ((sf_count_t )0);
  switch_break: 
#line 320
  offset = i * channels;
#line 321
  pflac->pos += i * channels;
#line 323
  return ((sf_count_t )offset);
}
}
#line 328 "/root/patchweave_new/23/src/flac.c"
static FLAC__StreamDecoderReadStatus sf_flac_read_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__byte *buffer , size_t *bytes ,
                                                           void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t __cil_tmp6 ;

  {
  {
#line 329
  psf = (SF_PRIVATE *)client_data;
#line 331
  __cil_tmp6 = psf_fread((void *)buffer, (sf_count_t )1, (sf_count_t )*bytes, psf);
#line 331
  *bytes = (size_t )__cil_tmp6;
  }
#line 332
  if (*bytes > 0UL) {
#line 332
    if (psf->error == 0) {
#line 333
      return ((FLAC__StreamDecoderReadStatus )0);
    }
  }
#line 335
  return ((FLAC__StreamDecoderReadStatus )2);
}
}
#line 339 "/root/patchweave_new/23/src/flac.c"
static FLAC__StreamDecoderSeekStatus sf_flac_seek_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__uint64 absolute_byte_offset ,
                                                           void *client_data ) 
{ 
  SF_PRIVATE *psf ;

  {
  {
#line 340
  psf = (SF_PRIVATE *)client_data;
#line 342
  psf_fseek(psf, (sf_count_t )absolute_byte_offset, 0);
  }
#line 343
  if (psf->error) {
#line 344
    return ((FLAC__StreamDecoderSeekStatus )1);
  }
#line 346
  return ((FLAC__StreamDecoderSeekStatus )0);
}
}
#line 350 "/root/patchweave_new/23/src/flac.c"
static FLAC__StreamDecoderTellStatus sf_flac_tell_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__uint64 *absolute_byte_offset ,
                                                           void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 351
  psf = (SF_PRIVATE *)client_data;
#line 353
  __cil_tmp5 = psf_ftell(psf);
#line 353
  *absolute_byte_offset = (FLAC__uint64 )__cil_tmp5;
  }
#line 354
  if (psf->error) {
#line 355
    return ((FLAC__StreamDecoderTellStatus )1);
  }
#line 357
  return ((FLAC__StreamDecoderTellStatus )0);
}
}
#line 361 "/root/patchweave_new/23/src/flac.c"
static FLAC__StreamDecoderLengthStatus sf_flac_length_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                               FLAC__uint64 *stream_length ,
                                                               void *client_data ) 
{ 
  SF_PRIVATE *psf ;

  {
#line 362
  psf = (SF_PRIVATE *)client_data;
#line 364
  *stream_length = (FLAC__uint64 )psf->filelength;
#line 364
  if (*stream_length == 0UL) {
#line 365
    return ((FLAC__StreamDecoderLengthStatus )1);
  }
#line 367
  return ((FLAC__StreamDecoderLengthStatus )0);
}
}
#line 371 "/root/patchweave_new/23/src/flac.c"
static FLAC__bool sf_flac_eof_callback(FLAC__StreamDecoder *UNUSED_decoder , void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t __cil_tmp4 ;

  {
  {
#line 372
  psf = (SF_PRIVATE *)client_data;
#line 374
  __cil_tmp4 = psf_ftell(psf);
  }
#line 374
  if (__cil_tmp4 == psf->filelength) {
#line 375
    return (1);
  }
#line 377
  return (0);
}
}
#line 381 "/root/patchweave_new/23/src/flac.c"
static FLAC__StreamDecoderWriteStatus sf_flac_write_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                             FLAC__Frame *frame ,
                                                             int32_t * const  *buffer ,
                                                             void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  FLAC_PRIVATE *pflac ;

  {
  {
#line 382
  psf = (SF_PRIVATE *)client_data;
#line 383
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 385
  pflac->frame = frame;
#line 386
  pflac->bufferpos = 0U;
#line 388
  pflac->wbuffer = buffer;
#line 390
  flac_buffer_copy(psf);
  }
#line 392
  return ((FLAC__StreamDecoderWriteStatus )0);
}
}
#line 398 "/root/patchweave_new/23/src/flac.c"
static FLAC_TAG tags[10]  ;
#line 396 "/root/patchweave_new/23/src/flac.c"
static void sf_flac_meta_get_vorbiscomments(SF_PRIVATE *psf , FLAC__StreamMetadata *metadata ) 
{ 
  char const   *value___0 ;
  char const   *cptr ;
  int k ;
  int tag_num ;
  char *__cil_tmp9 ;

  {
#line 397
  tags[0].tag = "title";
#line 397
  tags[0].type = 1;
#line 397
  tags[1].tag = "copyright";
#line 397
  tags[1].type = 2;
#line 397
  tags[2].tag = "software\230";
#line 397
  tags[2].type = 3;
#line 397
  tags[3].tag = "artist";
#line 397
  tags[3].type = 4;
#line 397
  tags[4].tag = "comment";
#line 397
  tags[4].type = 5;
#line 397
  tags[5].tag = "date\270U";
#line 397
  tags[5].type = 6;
#line 397
  tags[6].tag = "album";
#line 397
  tags[6].type = 7;
#line 397
  tags[7].tag = "license";
#line 397
  tags[7].type = 8;
#line 397
  tags[8].tag = "tracknumber";
#line 397
  tags[8].type = 9;
#line 397
  tags[9].tag = "genreU";
#line 397
  tags[9].type = 16;
#line 413
  k = 0;
  {
#line 413
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 413
    if (! (k < (int )(sizeof(tags) / sizeof(tags[0])))) {
#line 413
      goto while_break;
    }
    {
#line 414
    tag_num = FLAC__metadata_object_vorbiscomment_find_entry_from(metadata, (uint32_t )0,
                                                                  tags[k].tag);
    }
#line 416
    if (tag_num < 0) {
#line 417
      goto while_continue;
    }
    {
#line 419
    value___0 = (char const   *)(metadata->data.vorbis_comment.comments + tag_num)->entry;
#line 420
    __cil_tmp9 = strchr(value___0, '=');
#line 420
    cptr = (char const   *)__cil_tmp9;
    }
#line 420
    if ((unsigned long )cptr != (unsigned long )((void *)0)) {
#line 421
      value___0 = cptr + 1;
    }
    {
#line 423
    psf_log_printf(psf, "  %-12s : %s\nU", tags[k].tag, value___0);
#line 424
    psf_store_string(psf, tags[k].type, value___0);
#line 413
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 427
  return;
}
}
#line 431 "/root/patchweave_new/23/src/flac.c"
static void sf_flac_meta_callback(FLAC__StreamDecoder *UNUSED_decoder , FLAC__StreamMetadata *metadata ,
                                  void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  int bitwidth ;

  {
#line 432
  psf = (SF_PRIVATE *)client_data;
#line 433
  bitwidth = 0;
#line 436
  if ((unsigned int )metadata->type == 0U) {
#line 436
    goto case_0;
  }
#line 464
  if ((unsigned int )metadata->type == 8U) {
#line 464
    goto case_8;
  }
#line 468
  if ((unsigned int )metadata->type == 16U) {
#line 468
    goto case_16;
  }
#line 472
  if ((unsigned int )metadata->type == 24U) {
#line 472
    goto case_24;
  }
#line 485
  if ((unsigned int )metadata->type == 4U) {
#line 485
    goto case_4;
  }
#line 490
  if ((unsigned int )metadata->type == 1U) {
#line 490
    goto case_1;
  }
#line 494
  if ((unsigned int )metadata->type == 2U) {
#line 494
    goto case_2;
  }
#line 498
  if ((unsigned int )metadata->type == 3U) {
#line 498
    goto case_3;
  }
#line 502
  if ((unsigned int )metadata->type == 5U) {
#line 502
    goto case_5;
  }
#line 506
  if ((unsigned int )metadata->type == 6U) {
#line 506
    goto case_6;
  }
#line 510
  if ((unsigned int )metadata->type == 7U) {
#line 510
    goto case_7;
  }
#line 514
  goto switch_default___0;
  case_0: 
  {
#line 450
  psf->sf.channels = (int )metadata->data.stream_info.channels;
#line 451
  psf->sf.samplerate = (int )metadata->data.stream_info.sample_rate;
#line 452
  psf->sf.frames = (sf_count_t )metadata->data.stream_info.total_samples;
#line 454
  psf_log_printf(psf, "FLAC Stream Metadata\n  Channels    : %d\n  Sample rate : %d\nH\270U",
                 psf->sf.channels, psf->sf.samplerate);
  }
#line 456
  if (psf->sf.frames == 0L) {
    {
#line 457
    psf_log_printf(psf, "  Frames      : 0 (bumping to SF_COUNT_MAX)\n");
#line 458
    psf->sf.frames = (sf_count_t )-1LL;
    }
  } else {
    {
#line 461
    psf_log_printf(psf, "  Frames      : %D\n", psf->sf.frames);
    }
  }
#line 464
  if (metadata->data.stream_info.bits_per_sample == 8U) {
#line 464
    goto case_8;
  }
#line 468
  if (metadata->data.stream_info.bits_per_sample == 16U) {
#line 468
    goto case_16;
  }
#line 472
  if (metadata->data.stream_info.bits_per_sample == 24U) {
#line 472
    goto case_24;
  }
#line 476
  goto switch_default;
  case_8: 
#line 465
  psf->sf.format |= 1;
#line 466
  bitwidth = 8;
#line 467
  goto switch_break___0;
  case_16: 
#line 469
  psf->sf.format |= 2;
#line 470
  bitwidth = 16;
#line 471
  goto switch_break___0;
  case_24: 
#line 473
  psf->sf.format |= 3;
#line 474
  bitwidth = 24;
#line 475
  goto switch_break___0;
  switch_default: 
  {
#line 477
  psf_log_printf(psf, "sf_flac_meta_callback : bits_per_sample %d not yet implemented.\n\230\001",
                 metadata->data.stream_info.bits_per_sample);
  }
#line 478
  goto switch_break___0;
  switch_break___0: ;
#line 481
  if (bitwidth > 0) {
    {
#line 482
    psf_log_printf(psf, "  Bit width   : %d\n", bitwidth);
    }
  }
#line 483
  goto switch_break;
  case_4: 
  {
#line 486
  psf_log_printf(psf, "Vorbis Comment Metadata\n\220");
#line 487
  sf_flac_meta_get_vorbiscomments(psf, metadata);
  }
#line 488
  goto switch_break;
  case_1: 
  {
#line 491
  psf_log_printf(psf, "Padding Metadata\n");
  }
#line 492
  goto switch_break;
  case_2: 
  {
#line 495
  psf_log_printf(psf, "Application Metadata\nU");
  }
#line 496
  goto switch_break;
  case_3: 
  {
#line 499
  psf_log_printf(psf, "Seektable Metadata\n");
  }
#line 500
  goto switch_break;
  case_5: 
  {
#line 503
  psf_log_printf(psf, "Cuesheet Metadata\n");
  }
#line 504
  goto switch_break;
  case_6: 
  {
#line 507
  psf_log_printf(psf, "Picture Metadata\n\235^H\270U");
  }
#line 508
  goto switch_break;
  case_7: 
  {
#line 511
  psf_log_printf(psf, "Undefined Metadata\nH\270U");
  }
#line 512
  goto switch_break;
  switch_default___0: 
  {
#line 515
  psf_log_printf(psf, "sf_flac_meta_callback : metadata-type %d not yet implemented.\n",
                 (unsigned int )metadata->type);
  }
#line 516
  goto switch_break;
  switch_break: ;
#line 519
  return;
}
}
#line 523 "/root/patchweave_new/23/src/flac.c"
static void sf_flac_error_callback(FLAC__StreamDecoder *UNUSED_decoder , FLAC__StreamDecoderErrorStatus status ,
                                   void *client_data ) 
{ 
  SF_PRIVATE *psf ;

  {
  {
#line 524
  psf = (SF_PRIVATE *)client_data;
#line 526
  psf_log_printf(psf, "ERROR : %s\n", FLAC__StreamDecoderErrorStatusString[status]);
  }
#line 529
  if ((unsigned int )status == 0U) {
#line 529
    goto case_0;
  }
#line 532
  if ((unsigned int )status == 1U) {
#line 532
    goto case_1;
  }
#line 535
  goto switch_default;
  case_0: 
#line 530
  psf->error = 157;
#line 531
  goto switch_break;
  case_1: 
#line 533
  psf->error = 154;
#line 534
  goto switch_break;
  switch_default: 
#line 536
  psf->error = 160;
#line 537
  goto switch_break;
  switch_break: ;
#line 540
  return;
}
}
#line 544 "/root/patchweave_new/23/src/flac.c"
static FLAC__StreamEncoderSeekStatus sf_flac_enc_seek_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                               FLAC__uint64 absolute_byte_offset ,
                                                               void *client_data ) 
{ 
  SF_PRIVATE *psf ;

  {
  {
#line 545
  psf = (SF_PRIVATE *)client_data;
#line 547
  psf_fseek(psf, (sf_count_t )absolute_byte_offset, 0);
  }
#line 548
  if (psf->error) {
#line 549
    return ((FLAC__StreamEncoderSeekStatus )1);
  }
#line 551
  return ((FLAC__StreamEncoderSeekStatus )0);
}
}
#line 555 "/root/patchweave_new/23/src/flac.c"
static FLAC__StreamEncoderTellStatus sf_flac_enc_tell_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                               FLAC__uint64 *absolute_byte_offset ,
                                                               void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 556
  psf = (SF_PRIVATE *)client_data;
#line 558
  __cil_tmp5 = psf_ftell(psf);
#line 558
  *absolute_byte_offset = (FLAC__uint64 )__cil_tmp5;
  }
#line 559
  if (psf->error) {
#line 560
    return ((FLAC__StreamEncoderTellStatus )1);
  }
#line 562
  return ((FLAC__StreamEncoderTellStatus )0);
}
}
#line 566 "/root/patchweave_new/23/src/flac.c"
static FLAC__StreamEncoderWriteStatus sf_flac_enc_write_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                                 FLAC__byte *buffer ,
                                                                 size_t bytes , unsigned int UNUSED_samples ,
                                                                 unsigned int UNUSED_current_frame ,
                                                                 void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t __cil_tmp8 ;

  {
  {
#line 567
  psf = (SF_PRIVATE *)client_data;
#line 569
  __cil_tmp8 = psf_fwrite((void const   *)buffer, (sf_count_t )1, (sf_count_t )bytes,
                          psf);
  }
#line 569
  if (__cil_tmp8 == (sf_count_t )bytes) {
#line 569
    if (psf->error == 0) {
#line 570
      return ((FLAC__StreamEncoderWriteStatus )0);
    }
  }
#line 572
  return ((FLAC__StreamEncoderWriteStatus )1);
}
}
#line 576 "/root/patchweave_new/23/src/flac.c"
static void flac_write_strings(SF_PRIVATE *psf , FLAC_PRIVATE *pflac ) 
{ 
  FLAC__StreamMetadata_VorbisComment_Entry entry ;
  int k ;
  int string_count ;
  char const   *key ;
  char const   *value___0 ;
  FLAC__bool __cil_tmp12 ;

  {
#line 578
  string_count = 0;
#line 580
  k = 0;
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;

#line 580
    if (! (k < 32)) {
#line 580
      goto while_break;
    }
#line 581
    if (psf->strings.data[k].type != 0) {
#line 582
      string_count ++;
    }
#line 580
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 585
  if (string_count == 0) {
#line 586
    return;
  }
  {
#line 588
  pflac->metadata = FLAC__metadata_object_new((FLAC__MetadataType )4);
  }
#line 588
  if ((unsigned long )pflac->metadata == (unsigned long )((void *)0)) {
#line 588
    if ((unsigned long )pflac->metadata == (unsigned long )((void *)0)) {
      {
#line 589
      psf_log_printf(psf, "FLAC__metadata_object_new returned NULL\n\220");
      }
#line 590
      return;
    }
  }
#line 593
  k = 0;
  {
#line 593
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue___0: ;
#line 593
    if (k < 32) {
#line 593
      if (! (psf->strings.data[k].type != 0)) {
#line 593
        goto while_break___0;
      }
    } else {
#line 593
      goto while_break___0;
    }
#line 597
    if (psf->strings.data[k].type == 3) {
#line 597
      goto case_3;
    }
#line 600
    if (psf->strings.data[k].type == 1) {
#line 600
      goto case_1;
    }
#line 603
    if (psf->strings.data[k].type == 2) {
#line 603
      goto case_2;
    }
#line 606
    if (psf->strings.data[k].type == 4) {
#line 606
      goto case_4;
    }
#line 609
    if (psf->strings.data[k].type == 5) {
#line 609
      goto case_5;
    }
#line 612
    if (psf->strings.data[k].type == 6) {
#line 612
      goto case_6;
    }
#line 615
    if (psf->strings.data[k].type == 7) {
#line 615
      goto case_7;
    }
#line 618
    if (psf->strings.data[k].type == 8) {
#line 618
      goto case_8;
    }
#line 621
    if (psf->strings.data[k].type == 9) {
#line 621
      goto case_9;
    }
#line 624
    if (psf->strings.data[k].type == 16) {
#line 624
      goto case_16;
    }
#line 627
    goto switch_default;
    case_3: 
#line 598
    key = "software\220";
#line 599
    goto switch_break;
    case_1: 
#line 601
    key = "title";
#line 602
    goto switch_break;
    case_2: 
#line 604
    key = "copyright";
#line 605
    goto switch_break;
    case_4: 
#line 607
    key = "artist";
#line 608
    goto switch_break;
    case_5: 
#line 610
    key = "comment";
#line 611
    goto switch_break;
    case_6: 
#line 613
    key = "date";
#line 614
    goto switch_break;
    case_7: 
#line 616
    key = "album";
#line 617
    goto switch_break;
    case_8: 
#line 619
    key = "license";
#line 620
    goto switch_break;
    case_9: 
#line 622
    key = "tracknumber";
#line 623
    goto switch_break;
    case_16: 
#line 625
    key = "genre";
#line 626
    goto switch_break;
    switch_default: 
#line 628
    goto while_continue___0;
    switch_break: 
    {
#line 631
    value___0 = (char const   *)(psf->strings.storage + psf->strings.data[k].offset);
#line 633
    FLAC__metadata_object_vorbiscomment_entry_from_name_value_pair(& entry, key, value___0);
#line 634
    FLAC__metadata_object_vorbiscomment_append_comment(pflac->metadata, entry, 0);
#line 593
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 637
  __cil_tmp12 = FLAC__stream_encoder_set_metadata(pflac->fse, & pflac->metadata, (uint32_t )1);
  }
#line 637
  if (! __cil_tmp12) {
    {
#line 638
    printf("%s %d : fail\n", "flac_write_strings", 638);
    }
#line 639
    return;
  }
#line 642
  return;
}
}
#line 646 "/root/patchweave_new/23/src/flac.c"
static int flac_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  FLAC_PRIVATE *pflac ;
  int err ;
  FLAC__StreamEncoderInitStatus __cil_tmp5 ;
  void *tmp ;

  {
  {
#line 647
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 650
  flac_write_strings(psf, pflac);
#line 652
  __cil_tmp5 = FLAC__stream_encoder_init_stream(pflac->fse, & sf_flac_enc_write_callback,
                                                & sf_flac_enc_seek_callback, & sf_flac_enc_tell_callback,
                                                (void (*)(FLAC__StreamEncoder * ,
                                                          FLAC__StreamMetadata * ,
                                                          void * ))((void *)0), (void *)psf);
#line 652
  err = (int )__cil_tmp5;
  }
#line 652
  if (err != 0) {
    {
#line 653
    psf_log_printf(psf, "Error : FLAC encoder init returned error : %s\n", FLAC__StreamEncoderInitStatusString[err]);
    }
#line 654
    return (156);
  }
#line 657
  if (psf->error == 0) {
    {
#line 658
    psf->dataoffset = psf_ftell(psf);
    }
  }
  {
#line 659
  tmp = calloc(8192UL, sizeof(int32_t ));
#line 659
  pflac->encbuffer = (int32_t *)tmp;
  }
#line 661
  return (psf->error);
}
}
#line 669 "/root/patchweave_new/23/src/flac.c"
int flac_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  FLAC_PRIVATE *pflac ;
  void *__cil_tmp5 ;

  {
  {
#line 671
  error = 0;
#line 673
  __cil_tmp5 = calloc(1UL, sizeof(FLAC_PRIVATE ));
#line 673
  pflac = (FLAC_PRIVATE *)__cil_tmp5;
#line 674
  psf->codec_data = (void *)pflac;
#line 677
  pflac->compression = 5U;
  }
#line 679
  if (psf->file.mode == 48) {
#line 680
    return (24);
  }
#line 682
  if (psf->file.mode == 16) {
    {
#line 683
    error = flac_read_header(psf);
    }
#line 683
    if (error) {
#line 684
      return (error);
    }
  }
#line 687
  subformat = psf->sf.format & 65535;
#line 689
  if (psf->file.mode == 32) {
#line 690
    if ((psf->sf.format & 268369920) != 1507328) {
#line 691
      return (1);
    }
    {
#line 693
    psf->endian = 536870912;
#line 694
    psf->sf.seekable = 0;
#line 696
    psf->strings.flags = (uint32_t )256;
#line 698
    error = flac_enc_init(psf);
    }
#line 698
    if (error) {
#line 699
      return (error);
    }
#line 705
    psf->write_header = & flac_write_header;
  }
#line 708
  psf->datalength = psf->filelength;
#line 709
  psf->dataoffset = (sf_count_t )0;
#line 711
  psf->container_close = & flac_close;
#line 712
  psf->seek = & flac_seek;
#line 713
  psf->byterate = & flac_byterate;
#line 715
  psf->command = & flac_command;
#line 720
  if (subformat == 3) {
#line 720
    goto case_3;
  }
#line 720
  if (subformat == 2) {
#line 720
    goto case_3;
  }
#line 720
  if (subformat == 1) {
#line 720
    goto case_3;
  }
#line 724
  goto switch_default;
  case_3: 
  {
#line 721
  error = flac_init(psf);
  }
#line 722
  goto switch_break;
  switch_default: 
#line 724
  return (18);
  switch_break: ;
#line 727
  return (error);
}
}
#line 734 "/root/patchweave_new/23/src/flac.c"
static int flac_close(SF_PRIVATE *psf ) 
{ 
  FLAC_PRIVATE *pflac ;
  int k ;

  {
#line 738
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 738
  if ((unsigned long )pflac == (unsigned long )((void *)0)) {
#line 739
    return (0);
  }
#line 741
  if ((unsigned long )pflac->metadata != (unsigned long )((void *)0)) {
    {
#line 742
    FLAC__metadata_object_delete(pflac->metadata);
    }
  }
#line 744
  if (psf->file.mode == 32) {
    {
#line 745
    FLAC__stream_encoder_finish(pflac->fse);
#line 746
    FLAC__stream_encoder_delete(pflac->fse);
#line 747
    free((void *)pflac->encbuffer);
    }
  }
#line 750
  if (psf->file.mode == 16) {
    {
#line 751
    FLAC__stream_decoder_finish(pflac->fsd);
#line 752
    FLAC__stream_decoder_delete(pflac->fsd);
    }
  }
#line 755
  k = 0;
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;

#line 755
    if (! (k < (int )(sizeof(pflac->rbuffer) / sizeof(pflac->rbuffer[0])))) {
#line 755
      goto while_break;
    }
    {
#line 756
    free((void *)pflac->rbuffer[k]);
#line 755
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 758
  free((void *)pflac);
#line 759
  psf->codec_data = (void *)0;
  }
#line 761
  return (0);
}
}
#line 765 "/root/patchweave_new/23/src/flac.c"
static int flac_enc_init(SF_PRIVATE *psf ) 
{ 
  FLAC_PRIVATE *pflac ;
  unsigned int bps ;
  FLAC__bool __cil_tmp5 ;
  FLAC__bool __cil_tmp6 ;
  FLAC__bool __cil_tmp7 ;
  FLAC__bool __cil_tmp8 ;

  {
#line 766
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 774
  if (psf->sf.samplerate < 1) {
    {
#line 775
    psf_log_printf(psf, "flac sample rate out of range.\n", psf->sf.samplerate);
    }
#line 776
    return (158);
  } else
#line 774
  if (psf->sf.samplerate > 655350) {
    {
#line 775
    psf_log_printf(psf, "flac sample rate out of range.\n", psf->sf.samplerate);
    }
#line 776
    return (158);
  }
  {
#line 779
  psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 782
  if ((psf->sf.format & 65535) == 1) {
#line 782
    goto case_1;
  }
#line 785
  if ((psf->sf.format & 65535) == 2) {
#line 785
    goto case_2;
  }
#line 788
  if ((psf->sf.format & 65535) == 3) {
#line 788
    goto case_3;
  }
#line 792
  goto switch_default;
  case_1: 
#line 783
  bps = 8U;
#line 784
  goto switch_break;
  case_2: 
#line 786
  bps = 16U;
#line 787
  goto switch_break;
  case_3: 
#line 789
  bps = 24U;
#line 790
  goto switch_break;
  switch_default: 
#line 793
  bps = 0U;
#line 794
  goto switch_break;
  switch_break: ;
#line 797
  if (pflac->fse) {
    {
#line 798
    FLAC__stream_encoder_delete(pflac->fse);
    }
  }
  {
#line 799
  pflac->fse = FLAC__stream_encoder_new();
  }
#line 799
  if ((unsigned long )pflac->fse == (unsigned long )((void *)0)) {
#line 800
    return (155);
  }
  {
#line 802
  __cil_tmp5 = FLAC__stream_encoder_set_channels(pflac->fse, (uint32_t )psf->sf.channels);
  }
#line 802
  if (! __cil_tmp5) {
    {
#line 803
    psf_log_printf(psf, "FLAC__stream_encoder_set_channels (%d) return false.\n",
                   psf->sf.channels);
    }
#line 804
    return (156);
  }
  {
#line 807
  __cil_tmp6 = FLAC__stream_encoder_set_sample_rate(pflac->fse, (uint32_t )psf->sf.samplerate);
  }
#line 807
  if (! __cil_tmp6) {
    {
#line 808
    psf_log_printf(psf, "FLAC__stream_encoder_set_sample_rate (%d) returned false.\n",
                   psf->sf.samplerate);
    }
#line 809
    return (158);
  }
  {
#line 812
  __cil_tmp7 = FLAC__stream_encoder_set_bits_per_sample(pflac->fse, bps);
  }
#line 812
  if (! __cil_tmp7) {
    {
#line 813
    psf_log_printf(psf, "FLAC__stream_encoder_set_bits_per_sample (%d) return false.\n",
                   bps);
    }
#line 814
    return (156);
  }
  {
#line 817
  __cil_tmp8 = FLAC__stream_encoder_set_compression_level(pflac->fse, pflac->compression);
  }
#line 817
  if (! __cil_tmp8) {
    {
#line 818
    psf_log_printf(psf, "FLAC__stream_encoder_set_compression_level (%d) return false.\n",
                   pflac->compression);
    }
#line 819
    return (156);
  }
#line 822
  return (0);
}
}
#line 826 "/root/patchweave_new/23/src/flac.c"
static int flac_read_header(SF_PRIVATE *psf ) 
{ 
  FLAC_PRIVATE *pflac ;
  FLAC__StreamDecoderInitStatus __cil_tmp4 ;
  FLAC__uint64 position ;

  {
  {
#line 827
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 829
  psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 830
  if (pflac->fsd) {
    {
#line 831
    FLAC__stream_decoder_delete(pflac->fsd);
    }
  }
  {
#line 832
  pflac->fsd = FLAC__stream_decoder_new();
  }
#line 832
  if ((unsigned long )pflac->fsd == (unsigned long )((void *)0)) {
#line 833
    return (155);
  }
  {
#line 835
  FLAC__stream_decoder_set_metadata_respond_all(pflac->fsd);
#line 837
  __cil_tmp4 = FLAC__stream_decoder_init_stream(pflac->fsd, & sf_flac_read_callback,
                                                & sf_flac_seek_callback, & sf_flac_tell_callback,
                                                & sf_flac_length_callback, & sf_flac_eof_callback,
                                                & sf_flac_write_callback, & sf_flac_meta_callback,
                                                & sf_flac_error_callback, (void *)psf);
  }
#line 837
  if ((unsigned int )__cil_tmp4 != 0U) {
#line 838
    return (156);
  }
  {
#line 840
  FLAC__stream_decoder_process_until_end_of_metadata(pflac->fsd);
#line 842
  psf_log_printf(psf, "End\n");
  }
#line 844
  if (psf->error == 0) {
    {
#line 847
    FLAC__stream_decoder_get_decode_position(pflac->fsd, & position);
#line 848
    psf->dataoffset = (sf_count_t )position;
    }
  }
#line 851
  return (psf->error);
}
}
#line 855 "/root/patchweave_new/23/src/flac.c"
static int flac_command(SF_PRIVATE *psf , int command , void *data , int datasize ) 
{ 
  FLAC_PRIVATE *pflac ;
  double quality ;
  long __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 856
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 860
  if (command == 4865) {
#line 860
    goto case_4865;
  }
#line 881
  goto switch_default;
  case_4865: 
#line 861
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 862
    return (0);
  } else
#line 861
  if ((unsigned long )datasize != sizeof(double )) {
#line 862
    return (0);
  }
#line 864
  if (psf->have_written) {
#line 865
    return (0);
  }
  {
#line 870
  quality = *((double *)data) * 8.;
#line 872
  __cil_tmp7 = lrint((double )0);
#line 872
  pflac->compression = (unsigned int )__cil_tmp7;
#line 874
  psf_log_printf(psf, "%s : Setting SFC_SET_COMPRESSION_LEVEL to %u.\n", "flac_command",
                 pflac->compression);
#line 876
  __cil_tmp8 = flac_enc_init(psf);
  }
#line 876
  if (__cil_tmp8) {
#line 877
    return (0);
  }
#line 879
  return (1);
  switch_default: 
#line 882
  return (0);

#line 885
  return (0);
}
}
#line 889 "/root/patchweave_new/23/src/flac.c"
int flac_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t tmp ;

  {
#line 891
  if (psf->file.mode == 48) {
#line 892
    return (24);
  }
#line 894
  if (psf->file.mode == 16) {
#line 895
    psf->read_short = & flac_read_flac2s;
#line 896
    psf->read_int = & flac_read_flac2i;
#line 897
    psf->read_float = & flac_read_flac2f;
#line 898
    psf->read_double = & flac_read_flac2d;
  }
#line 901
  if (psf->file.mode == 32) {
#line 902
    psf->write_short = & flac_write_s2flac;
#line 903
    psf->write_int = & flac_write_i2flac;
#line 904
    psf->write_float = & flac_write_f2flac;
#line 905
    psf->write_double = & flac_write_d2flac;
  }
#line 908
  if (psf->filelength > psf->dataoffset) {
#line 909
    if (psf->dataend) {
#line 909
      tmp = psf->dataend - psf->dataoffset;
    } else {
#line 909
      tmp = psf->filelength - psf->dataoffset;
    }
#line 909
    psf->datalength = tmp;
  } else {
#line 911
    psf->datalength = (sf_count_t )0;
  }
#line 913
  return (0);
}
}
#line 917 "/root/patchweave_new/23/src/flac.c"
static unsigned int flac_read_loop(SF_PRIVATE *psf , unsigned int len ) 
{ 
  FLAC_PRIVATE *pflac ;
  FLAC__StreamDecoderState state ;
  FLAC__bool __cil_tmp6 ;

  {
  {
#line 918
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 921
  pflac->pos = 0U;
#line 922
  pflac->len = len;
#line 923
  pflac->remain = len;
#line 925
  state = FLAC__stream_decoder_get_state(pflac->fsd);
  }
#line 926
  if ((unsigned int )state > 4U) {
    {
#line 927
    psf_log_printf(psf, "FLAC__stream_decoder_get_state returned %s\n", FLAC__StreamDecoderStateString[state]);
#line 929
    pflac->frame = (FLAC__Frame *)((void *)0);
    }
  }
#line 933
  if ((unsigned long )pflac->frame != (unsigned long )((void *)0)) {
#line 933
    if (pflac->bufferpos < (pflac->frame)->header.blocksize) {
      {
#line 934
      flac_buffer_copy(psf);
      }
    }
  }
  {
#line 937
  while (1) {
    while_continue: /* CIL Label */ ;

#line 937
    if (! (pflac->pos < pflac->len)) {
#line 937
      goto while_break;
    }
    {
#line 938
    __cil_tmp6 = FLAC__stream_decoder_process_single(pflac->fsd);
    }
#line 938
    if (__cil_tmp6 == 0) {
#line 939
      goto while_break;
    }
    {
#line 940
    state = FLAC__stream_decoder_get_state(pflac->fsd);
    }
#line 941
    if ((unsigned int )state >= 4U) {
      {
#line 942
      psf_log_printf(psf, "FLAC__stream_decoder_get_state returned %s\n", FLAC__StreamDecoderStateString[state]);
#line 944
      pflac->frame = (FLAC__Frame *)((void *)0);
      }
#line 945
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 949
  pflac->ptr = (void *)0;
#line 951
  return (pflac->pos);
}
}
#line 955 "/root/patchweave_new/23/src/flac.c"
static sf_count_t flac_read_flac2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  sf_count_t total ;
  sf_count_t current ;
  unsigned int readlen ;
  unsigned int tmp ;
  unsigned int __cil_tmp9 ;

  {
#line 956
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 957
  total = (sf_count_t )0;
#line 960
  pflac->pcmtype = (PFLAC_PCM )50;
  {
#line 962
  while (1) {
    while_continue: /* CIL Label */ ;

#line 962
    if (! (total < len)) {
#line 962
      goto while_break;
    }
#line 963
    pflac->ptr = (void *)(ptr + total);
#line 964
    if (len - total > 16777216L) {
#line 964
      tmp = 16777216U;
    } else {
#line 964
      tmp = (unsigned int )(len - total);
    }
    {
#line 964
    readlen = tmp;
#line 965
    __cil_tmp9 = flac_read_loop(psf, readlen);
#line 965
    current = (sf_count_t )__cil_tmp9;
    }
#line 966
    if (current == 0L) {
#line 967
      goto while_break;
    }
#line 968
    total += current;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 971
  return (total);
}
}
#line 975 "/root/patchweave_new/23/src/flac.c"
static sf_count_t flac_read_flac2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  sf_count_t total ;
  sf_count_t current ;
  unsigned int readlen ;
  unsigned int tmp ;
  unsigned int __cil_tmp9 ;

  {
#line 976
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 977
  total = (sf_count_t )0;
#line 980
  pflac->pcmtype = (PFLAC_PCM )51;
  {
#line 982
  while (1) {
    while_continue: /* CIL Label */ ;

#line 982
    if (! (total < len)) {
#line 982
      goto while_break;
    }
#line 983
    pflac->ptr = (void *)(ptr + total);
#line 984
    if (len - total > 16777216L) {
#line 984
      tmp = 16777216U;
    } else {
#line 984
      tmp = (unsigned int )(len - total);
    }
    {
#line 984
    readlen = tmp;
#line 985
    __cil_tmp9 = flac_read_loop(psf, readlen);
#line 985
    current = (sf_count_t )__cil_tmp9;
    }
#line 986
    if (current == 0L) {
#line 987
      goto while_break;
    }
#line 988
    total += current;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 991
  return (total);
}
}
#line 995 "/root/patchweave_new/23/src/flac.c"
static sf_count_t flac_read_flac2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  sf_count_t total ;
  sf_count_t current ;
  unsigned int readlen ;
  unsigned int tmp ;
  unsigned int __cil_tmp9 ;

  {
#line 996
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 997
  total = (sf_count_t )0;
#line 1000
  pflac->pcmtype = (PFLAC_PCM )52;
  {
#line 1002
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1002
    if (! (total < len)) {
#line 1002
      goto while_break;
    }
#line 1003
    pflac->ptr = (void *)(ptr + total);
#line 1004
    if (len - total > 16777216L) {
#line 1004
      tmp = 16777216U;
    } else {
#line 1004
      tmp = (unsigned int )(len - total);
    }
    {
#line 1004
    readlen = tmp;
#line 1005
    __cil_tmp9 = flac_read_loop(psf, readlen);
#line 1005
    current = (sf_count_t )__cil_tmp9;
    }
#line 1006
    if (current == 0L) {
#line 1007
      goto while_break;
    }
#line 1008
    total += current;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1011
  return (total);
}
}
#line 1015 "/root/patchweave_new/23/src/flac.c"
static sf_count_t flac_read_flac2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  sf_count_t total ;
  sf_count_t current ;
  unsigned int readlen ;
  unsigned int tmp ;
  unsigned int __cil_tmp9 ;

  {
#line 1016
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 1017
  total = (sf_count_t )0;
#line 1020
  pflac->pcmtype = (PFLAC_PCM )53;
  {
#line 1022
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1022
    if (! (total < len)) {
#line 1022
      goto while_break;
    }
#line 1023
    pflac->ptr = (void *)(ptr + total);
#line 1024
    if (len - total > 16777216L) {
#line 1024
      tmp = 16777216U;
    } else {
#line 1024
      tmp = (unsigned int )(len - total);
    }
    {
#line 1024
    readlen = tmp;
#line 1026
    __cil_tmp9 = flac_read_loop(psf, readlen);
#line 1026
    current = (sf_count_t )__cil_tmp9;
    }
#line 1027
    if (current == 0L) {
#line 1028
      goto while_break;
    }
#line 1029
    total += current;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1032
  return (total);
}
}
#line 1036 "/root/patchweave_new/23/src/flac.c"
static sf_count_t flac_write_s2flac(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  void (*convert)(short const   * , int32_t * , int  ) ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  int32_t *buffer ;
  int tmp ;
  FLAC__bool __cil_tmp12 ;

  {
#line 1037
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 1040
  total = (sf_count_t )0;
#line 1041
  buffer = pflac->encbuffer;
#line 1044
  if ((psf->sf.format & 65535) == 1) {
#line 1044
    goto case_1;
  }
#line 1047
  if ((psf->sf.format & 65535) == 2) {
#line 1047
    goto case_2;
  }
#line 1050
  if ((psf->sf.format & 65535) == 3) {
#line 1050
    goto case_3;
  }
#line 1053
  goto switch_default;
  case_1: 
#line 1045
  convert = & s2flac8_array;
#line 1046
  goto switch_break;
  case_2: 
#line 1048
  convert = & s2flac16_array;
#line 1049
  goto switch_break;
  case_3: 
#line 1051
  convert = & s2flac24_array;
#line 1052
  goto switch_break;
  switch_default: 
#line 1054
  return ((sf_count_t )-1);
  switch_break: 
#line 1057
  bufferlen = (int )(8192UL / (sizeof(int32_t ) * (unsigned long )psf->sf.channels));
#line 1058
  bufferlen *= psf->sf.channels;
  {
#line 1060
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1060
    if (! (len > 0L)) {
#line 1060
      goto while_break;
    }
#line 1061
    if (len >= (long )bufferlen) {
#line 1061
      tmp = bufferlen;
    } else {
#line 1061
      tmp = (int )len;
    }
    {
#line 1061
    writecount = tmp;
#line 1062
    (*convert)(ptr + total, buffer, writecount);
#line 1063
    __cil_tmp12 = FLAC__stream_encoder_process_interleaved(pflac->fse, buffer, (uint32_t )(writecount / psf->sf.channels));
    }
#line 1063
    if (__cil_tmp12) {
#line 1064
      thiswrite = writecount;
    } else {
#line 1066
      goto while_break;
    }
#line 1067
    total += (long )thiswrite;
#line 1068
    if (thiswrite < writecount) {
#line 1069
      goto while_break;
    }
#line 1071
    len -= (long )thiswrite;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1074
  return (total);
}
}
#line 1078 "/root/patchweave_new/23/src/flac.c"
static sf_count_t flac_write_i2flac(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  void (*convert)(int const   * , int32_t * , int  ) ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  int32_t *buffer ;
  int tmp ;
  FLAC__bool __cil_tmp12 ;

  {
#line 1079
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 1082
  total = (sf_count_t )0;
#line 1083
  buffer = pflac->encbuffer;
#line 1086
  if ((psf->sf.format & 65535) == 1) {
#line 1086
    goto case_1;
  }
#line 1089
  if ((psf->sf.format & 65535) == 2) {
#line 1089
    goto case_2;
  }
#line 1092
  if ((psf->sf.format & 65535) == 3) {
#line 1092
    goto case_3;
  }
#line 1095
  goto switch_default;
  case_1: 
#line 1087
  convert = & i2flac8_array;
#line 1088
  goto switch_break;
  case_2: 
#line 1090
  convert = & i2flac16_array;
#line 1091
  goto switch_break;
  case_3: 
#line 1093
  convert = & i2flac24_array;
#line 1094
  goto switch_break;
  switch_default: 
#line 1096
  return ((sf_count_t )-1);
  switch_break: 
#line 1099
  bufferlen = (int )(8192UL / (sizeof(int32_t ) * (unsigned long )psf->sf.channels));
#line 1100
  bufferlen *= psf->sf.channels;
  {
#line 1102
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1102
    if (! (len > 0L)) {
#line 1102
      goto while_break;
    }
#line 1103
    if (len >= (long )bufferlen) {
#line 1103
      tmp = bufferlen;
    } else {
#line 1103
      tmp = (int )len;
    }
    {
#line 1103
    writecount = tmp;
#line 1104
    (*convert)(ptr + total, buffer, writecount);
#line 1105
    __cil_tmp12 = FLAC__stream_encoder_process_interleaved(pflac->fse, buffer, (uint32_t )(writecount / psf->sf.channels));
    }
#line 1105
    if (__cil_tmp12) {
#line 1106
      thiswrite = writecount;
    } else {
#line 1108
      goto while_break;
    }
#line 1109
    total += (long )thiswrite;
#line 1110
    if (thiswrite < writecount) {
#line 1111
      goto while_break;
    }
#line 1113
    len -= (long )thiswrite;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1116
  return (total);
}
}
#line 1120 "/root/patchweave_new/23/src/flac.c"
static sf_count_t flac_write_f2flac(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  void (*convert)(float const   * , int32_t * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  int32_t *buffer ;
  void (*tmp)(float const   *src , int32_t *dest , int count , int normalize ) ;
  void (*tmp___0)(float const   *src , int32_t *dest , int count , int normalize ) ;
  void (*tmp___1)(float const   *src , int32_t *dest , int count , int normalize ) ;
  int tmp___2 ;
  FLAC__bool __cil_tmp15 ;

  {
#line 1121
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 1124
  total = (sf_count_t )0;
#line 1125
  buffer = pflac->encbuffer;
#line 1128
  if ((psf->sf.format & 65535) == 1) {
#line 1128
    goto case_1;
  }
#line 1131
  if ((psf->sf.format & 65535) == 2) {
#line 1131
    goto case_2;
  }
#line 1134
  if ((psf->sf.format & 65535) == 3) {
#line 1134
    goto case_3;
  }
#line 1137
  goto switch_default;
  case_1: 
#line 1129
  if (psf->add_clipping) {
#line 1129
    tmp = & f2flac8_clip_array;
  } else {
#line 1129
    tmp = & f2flac8_array;
  }
#line 1129
  convert = tmp;
#line 1130
  goto switch_break;
  case_2: 
#line 1132
  if (psf->add_clipping) {
#line 1132
    tmp___0 = & f2flac16_clip_array;
  } else {
#line 1132
    tmp___0 = & f2flac16_array;
  }
#line 1132
  convert = tmp___0;
#line 1133
  goto switch_break;
  case_3: 
#line 1135
  if (psf->add_clipping) {
#line 1135
    tmp___1 = & f2flac24_clip_array;
  } else {
#line 1135
    tmp___1 = & f2flac24_array;
  }
#line 1135
  convert = tmp___1;
#line 1136
  goto switch_break;
  switch_default: 
#line 1138
  return ((sf_count_t )-1);
  switch_break: 
#line 1141
  bufferlen = (int )(8192UL / (sizeof(int32_t ) * (unsigned long )psf->sf.channels));
#line 1142
  bufferlen *= psf->sf.channels;
  {
#line 1144
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1144
    if (! (len > 0L)) {
#line 1144
      goto while_break;
    }
#line 1145
    if (len >= (long )bufferlen) {
#line 1145
      tmp___2 = bufferlen;
    } else {
#line 1145
      tmp___2 = (int )len;
    }
    {
#line 1145
    writecount = tmp___2;
#line 1146
    (*convert)(ptr + total, buffer, writecount, psf->norm_float);
#line 1147
    __cil_tmp15 = FLAC__stream_encoder_process_interleaved(pflac->fse, buffer, (uint32_t )(writecount / psf->sf.channels));
    }
#line 1147
    if (__cil_tmp15) {
#line 1148
      thiswrite = writecount;
    } else {
#line 1150
      goto while_break;
    }
#line 1151
    total += (long )thiswrite;
#line 1152
    if (thiswrite < writecount) {
#line 1153
      goto while_break;
    }
#line 1155
    len -= (long )thiswrite;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1158
  return (total);
}
}
#line 1162 "/root/patchweave_new/23/src/flac.c"
static void f2flac8_clip_array(float const   *src , int32_t *dest , int count___0 ,
                               int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1165
  if (normalize) {
#line 1165
    tmp = 8. * (double )16;
  } else {
#line 1165
    tmp = 1.;
  }
#line 1165
  normfact = (float )tmp;
  {
#line 1167
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1167
    count___0 --;
#line 1167
    if (! (count___0 >= 0)) {
#line 1167
      goto while_break;
    }
#line 1168
    scaled_value = (float )(*(src + count___0) * (float const   )normfact);
#line 1169
    if ((double )scaled_value >= 1. * (double )127) {
#line 1170
      *(dest + count___0) = 127;
#line 1171
      goto while_continue;
    }
#line 1173
    if ((double )scaled_value <= - 8. * (double )16) {
#line 1174
      *(dest + count___0) = 128;
#line 1175
      goto while_continue;
    }
    {
#line 1177
    __cil_tmp8 = lrintf(scaled_value);
#line 1177
    *(dest + count___0) = (int32_t )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1180
  return;
}
}
#line 1184 "/root/patchweave_new/23/src/flac.c"
static void f2flac16_clip_array(float const   *src , int32_t *dest , int count___0 ,
                                int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1187
  if (normalize) {
#line 1187
    tmp = 8. * (double )4096;
  } else {
#line 1187
    tmp = 1.;
  }
#line 1187
  normfact = (float )tmp;
  {
#line 1189
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1189
    count___0 --;
#line 1189
    if (! (count___0 >= 0)) {
#line 1189
      goto while_break;
    }
#line 1190
    scaled_value = (float )(*(src + count___0) * (float const   )normfact);
#line 1191
    if ((double )scaled_value >= 1. * (double )32767) {
#line 1192
      *(dest + count___0) = 32767;
#line 1193
      goto while_continue;
    }
#line 1195
    if ((double )scaled_value <= - 8. * (double )4096) {
#line 1196
      *(dest + count___0) = 32768;
#line 1197
      goto while_continue;
    }
    {
#line 1199
    __cil_tmp8 = lrintf(scaled_value);
#line 1199
    *(dest + count___0) = (int32_t )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1205
  return;
}
}
#line 1204 "/root/patchweave_new/23/src/flac.c"
static void f2flac24_clip_array(float const   *src , int32_t *dest , int count___0 ,
                                int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1207
  if (normalize) {
#line 1207
    tmp = 8. * (double )1048576;
  } else {
#line 1207
    tmp = 1.;
  }
#line 1207
  normfact = (float )tmp;
  {
#line 1209
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1209
    count___0 --;
#line 1209
    if (! (count___0 >= 0)) {
#line 1209
      goto while_break;
    }
#line 1210
    scaled_value = (float )(*(src + count___0) * (float const   )normfact);
#line 1211
    if ((double )scaled_value >= 1. * (double )8388607) {
#line 1212
      *(dest + count___0) = 8388607;
#line 1213
      goto while_continue;
    }
#line 1216
    if ((double )scaled_value <= - 8. * (double )1048576) {
#line 1217
      *(dest + count___0) = 8388608;
#line 1218
      goto while_continue;
    }
    {
#line 1220
    __cil_tmp8 = lrintf(scaled_value);
#line 1220
    *(dest + count___0) = (int32_t )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1223
  return;
}
}
#line 1227 "/root/patchweave_new/23/src/flac.c"
static void f2flac8_array(float const   *src , int32_t *dest , int count___0 , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1228
  if (normalize) {
#line 1228
    tmp = 1. * (double )127;
  } else {
#line 1228
    tmp = 1.;
  }
#line 1228
  normfact = (float )tmp;
  {
#line 1230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1230
    count___0 --;
#line 1230
    if (! (count___0 >= 0)) {
#line 1230
      goto while_break;
    }
    {
#line 1231
    __cil_tmp7 = lrintf((float )(*(src + count___0) * (float const   )normfact));
#line 1231
    *(dest + count___0) = (int32_t )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1236
  return;
}
}
#line 1235 "/root/patchweave_new/23/src/flac.c"
static void f2flac16_array(float const   *src , int32_t *dest , int count___0 , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1236
  if (normalize) {
#line 1236
    tmp = 1. * (double )32767;
  } else {
#line 1236
    tmp = 1.;
  }
#line 1236
  normfact = (float )tmp;
  {
#line 1238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1238
    count___0 --;
#line 1238
    if (! (count___0 >= 0)) {
#line 1238
      goto while_break;
    }
    {
#line 1239
    __cil_tmp7 = lrintf((float )(*(src + count___0) * (float const   )normfact));
#line 1239
    *(dest + count___0) = (int32_t )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1244
  return;
}
}
#line 1243 "/root/patchweave_new/23/src/flac.c"
static void f2flac24_array(float const   *src , int32_t *dest , int count___0 , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1244
  if (normalize) {
#line 1244
    tmp = 1. * (double )8388607;
  } else {
#line 1244
    tmp = 1.;
  }
#line 1244
  normfact = (float )tmp;
  {
#line 1246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1246
    count___0 --;
#line 1246
    if (! (count___0 >= 0)) {
#line 1246
      goto while_break;
    }
    {
#line 1247
    __cil_tmp7 = lrintf((float )(*(src + count___0) * (float const   )normfact));
#line 1247
    *(dest + count___0) = (int32_t )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1252
  return;
}
}
#line 1251 "/root/patchweave_new/23/src/flac.c"
static sf_count_t flac_write_d2flac(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  void (*convert)(double const   * , int32_t * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  int32_t *buffer ;
  void (*tmp)(double const   *src , int32_t *dest , int count , int normalize ) ;
  void (*tmp___0)(double const   *src , int32_t *dest , int count , int normalize ) ;
  void (*tmp___1)(double const   *src , int32_t *dest , int count , int normalize ) ;
  int tmp___2 ;
  FLAC__bool __cil_tmp15 ;

  {
#line 1252
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 1255
  total = (sf_count_t )0;
#line 1256
  buffer = pflac->encbuffer;
#line 1259
  if ((psf->sf.format & 65535) == 1) {
#line 1259
    goto case_1;
  }
#line 1262
  if ((psf->sf.format & 65535) == 2) {
#line 1262
    goto case_2;
  }
#line 1265
  if ((psf->sf.format & 65535) == 3) {
#line 1265
    goto case_3;
  }
#line 1268
  goto switch_default;
  case_1: 
#line 1260
  if (psf->add_clipping) {
#line 1260
    tmp = & d2flac8_clip_array;
  } else {
#line 1260
    tmp = & d2flac8_array;
  }
#line 1260
  convert = tmp;
#line 1261
  goto switch_break;
  case_2: 
#line 1263
  if (psf->add_clipping) {
#line 1263
    tmp___0 = & d2flac16_clip_array;
  } else {
#line 1263
    tmp___0 = & d2flac16_array;
  }
#line 1263
  convert = tmp___0;
#line 1264
  goto switch_break;
  case_3: 
#line 1266
  if (psf->add_clipping) {
#line 1266
    tmp___1 = & d2flac24_clip_array;
  } else {
#line 1266
    tmp___1 = & d2flac24_array;
  }
#line 1266
  convert = tmp___1;
#line 1267
  goto switch_break;
  switch_default: 
#line 1269
  return ((sf_count_t )-1);
  switch_break: 
#line 1272
  bufferlen = (int )(8192UL / (sizeof(int32_t ) * (unsigned long )psf->sf.channels));
#line 1273
  bufferlen *= psf->sf.channels;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1275
    if (! (len > 0L)) {
#line 1275
      goto while_break;
    }
#line 1276
    if (len >= (long )bufferlen) {
#line 1276
      tmp___2 = bufferlen;
    } else {
#line 1276
      tmp___2 = (int )len;
    }
    {
#line 1276
    writecount = tmp___2;
#line 1277
    (*convert)(ptr + total, buffer, writecount, psf->norm_double);
#line 1278
    __cil_tmp15 = FLAC__stream_encoder_process_interleaved(pflac->fse, buffer, (uint32_t )(writecount / psf->sf.channels));
    }
#line 1278
    if (__cil_tmp15) {
#line 1279
      thiswrite = writecount;
    } else {
#line 1281
      goto while_break;
    }
#line 1282
    total += (long )thiswrite;
#line 1283
    if (thiswrite < writecount) {
#line 1284
      goto while_break;
    }
#line 1286
    len -= (long )thiswrite;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1289
  return (total);
}
}
#line 1293 "/root/patchweave_new/23/src/flac.c"
static void d2flac8_clip_array(double const   *src , int32_t *dest , int count___0 ,
                               int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1296
  if (normalize) {
#line 1296
    tmp = 8. * (double )16;
  } else {
#line 1296
    tmp = 1.;
  }
#line 1296
  normfact = tmp;
  {
#line 1298
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1298
    count___0 --;
#line 1298
    if (! (count___0 >= 0)) {
#line 1298
      goto while_break;
    }
#line 1299
    scaled_value = (double )(*(src + count___0) * (double const   )normfact);
#line 1300
    if (scaled_value >= 1. * (double )127) {
#line 1301
      *(dest + count___0) = 127;
#line 1302
      goto while_continue;
    }
#line 1304
    if (scaled_value <= - 8. * (double )16) {
#line 1305
      *(dest + count___0) = 128;
#line 1306
      goto while_continue;
    }
    {
#line 1308
    __cil_tmp8 = lrint(scaled_value);
#line 1308
    *(dest + count___0) = (int32_t )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1311
  return;
}
}
#line 1315 "/root/patchweave_new/23/src/flac.c"
static void d2flac16_clip_array(double const   *src , int32_t *dest , int count___0 ,
                                int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1318
  if (normalize) {
#line 1318
    tmp = 8. * (double )4096;
  } else {
#line 1318
    tmp = 1.;
  }
#line 1318
  normfact = tmp;
  {
#line 1320
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1320
    count___0 --;
#line 1320
    if (! (count___0 >= 0)) {
#line 1320
      goto while_break;
    }
#line 1321
    scaled_value = (double )(*(src + count___0) * (double const   )normfact);
#line 1322
    if (scaled_value >= 1. * (double )32767) {
#line 1323
      *(dest + count___0) = 32767;
#line 1324
      goto while_continue;
    }
#line 1326
    if (scaled_value <= - 8. * (double )4096) {
#line 1327
      *(dest + count___0) = 32768;
#line 1328
      goto while_continue;
    }
    {
#line 1330
    __cil_tmp8 = lrint(scaled_value);
#line 1330
    *(dest + count___0) = (int32_t )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1333
  return;
}
}
#line 1337 "/root/patchweave_new/23/src/flac.c"
static void d2flac24_clip_array(double const   *src , int32_t *dest , int count___0 ,
                                int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1340
  if (normalize) {
#line 1340
    tmp = 8. * (double )1048576;
  } else {
#line 1340
    tmp = 1.;
  }
#line 1340
  normfact = tmp;
  {
#line 1342
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1342
    count___0 --;
#line 1342
    if (! (count___0 >= 0)) {
#line 1342
      goto while_break;
    }
#line 1343
    scaled_value = (double )(*(src + count___0) * (double const   )normfact);
#line 1344
    if (scaled_value >= 1. * (double )8388607) {
#line 1345
      *(dest + count___0) = 8388607;
#line 1346
      goto while_continue;
    }
#line 1348
    if (scaled_value <= - 8. * (double )1048576) {
#line 1349
      *(dest + count___0) = 8388608;
#line 1350
      goto while_continue;
    }
    {
#line 1352
    __cil_tmp8 = lrint(scaled_value);
#line 1352
    *(dest + count___0) = (int32_t )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1355
  return;
}
}
#line 1359 "/root/patchweave_new/23/src/flac.c"
static void d2flac8_array(double const   *src , int32_t *dest , int count___0 , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1360
  if (normalize) {
#line 1360
    tmp = 1. * (double )127;
  } else {
#line 1360
    tmp = 1.;
  }
#line 1360
  normfact = tmp;
  {
#line 1362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1362
    count___0 --;
#line 1362
    if (! (count___0 >= 0)) {
#line 1362
      goto while_break;
    }
    {
#line 1363
    __cil_tmp7 = lrint((double )(*(src + count___0) * (double const   )normfact));
#line 1363
    *(dest + count___0) = (int32_t )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1368
  return;
}
}
#line 1367 "/root/patchweave_new/23/src/flac.c"
static void d2flac16_array(double const   *src , int32_t *dest , int count___0 , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1368
  if (normalize) {
#line 1368
    tmp = 1. * (double )32767;
  } else {
#line 1368
    tmp = 1.;
  }
#line 1368
  normfact = tmp;
  {
#line 1370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1370
    count___0 --;
#line 1370
    if (! (count___0 >= 0)) {
#line 1370
      goto while_break;
    }
    {
#line 1371
    __cil_tmp7 = lrint((double )(*(src + count___0) * (double const   )normfact));
#line 1371
    *(dest + count___0) = (int32_t )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1376
  return;
}
}
#line 1375 "/root/patchweave_new/23/src/flac.c"
static void d2flac24_array(double const   *src , int32_t *dest , int count___0 , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1376
  if (normalize) {
#line 1376
    tmp = 1. * (double )8388607;
  } else {
#line 1376
    tmp = 1.;
  }
#line 1376
  normfact = tmp;
  {
#line 1378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1378
    count___0 --;
#line 1378
    if (! (count___0 >= 0)) {
#line 1378
      goto while_break;
    }
    {
#line 1379
    __cil_tmp7 = lrint((double )(*(src + count___0) * (double const   )normfact));
#line 1379
    *(dest + count___0) = (int32_t )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1384
  return;
}
}
#line 1383 "/root/patchweave_new/23/src/flac.c"
static sf_count_t flac_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) 
{ 
  FLAC_PRIVATE *pflac ;
  FLAC__bool __cil_tmp5 ;

  {
#line 1384
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 1386
  if ((unsigned long )pflac == (unsigned long )((void *)0)) {
#line 1387
    return ((sf_count_t )0);
  }
#line 1389
  if (psf->dataoffset < 0L) {
#line 1390
    psf->error = 40;
#line 1391
    return ((sf_count_t )-1);
  }
#line 1394
  pflac->frame = (FLAC__Frame *)((void *)0);
#line 1396
  if (psf->file.mode == 16) {
    {
#line 1397
    __cil_tmp5 = FLAC__stream_decoder_seek_absolute(pflac->fsd, (FLAC__uint64 )offset);
    }
#line 1397
    if (__cil_tmp5) {
#line 1398
      return (offset);
    }
#line 1400
    if (offset == psf->sf.frames) {
#line 1406
      return (offset);
    }
#line 1409
    psf->error = 40;
#line 1410
    return ((sf_count_t )-1);
  }
#line 1414
  psf->error = 40;
#line 1416
  return ((sf_count_t )-1);
}
}
#line 1420 "/root/patchweave_new/23/src/flac.c"
static int flac_byterate(SF_PRIVATE *psf ) 
{ 


  {
#line 1422
  if (psf->file.mode == 16) {
#line 1423
    return ((int )((psf->datalength * (long )psf->sf.samplerate) / psf->sf.frames));
  }
#line 1425
  return (-1);
}
}
#line 33 "/root/patchweave_new/23/src/dwd.c"
int dwd_open(SF_PRIVATE *psf ) 
{ 


  {
#line 34
  if (psf) {
#line 35
    return (18);
  }
#line 36
  return (0);
}
}
#line 97 "/root/patchweave_new/23/src/caf.c"
static int caf_close(SF_PRIVATE *psf ) ;
#line 98
static int caf_read_header(SF_PRIVATE *psf ) ;
#line 99
static int caf_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 100
static int caf_write_tailer(SF_PRIVATE *psf ) ;
#line 101
static int caf_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int UNUSED_datasize ) ;
#line 102
static int caf_read_chanmap(SF_PRIVATE *psf , sf_count_t chunk_size ) ;
#line 103
static int caf_read_strings(SF_PRIVATE *psf , sf_count_t chunk_size ) ;
#line 104
static void caf_write_strings(SF_PRIVATE *psf , int location ) ;
#line 107
static int caf_set_chunk(SF_PRIVATE *psf , SF_CHUNK_INFO *chunk_info ) ;
#line 108
static SF_CHUNK_ITERATOR *caf_next_chunk_iterator(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator ) ;
#line 109
static int caf_get_chunk_size(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 110
static int caf_get_chunk_data(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 117 "/root/patchweave_new/23/src/caf.c"
int caf_open(SF_PRIVATE *psf ) 
{ 
  CAF_PRIVATE *pcaf ;
  int subformat ;
  int format ;
  int error ;

  {
  {
#line 119
  error = 0;
#line 121
  psf->container_data = calloc(1UL, sizeof(CAF_PRIVATE ));
  }
#line 121
  if ((unsigned long )psf->container_data == (unsigned long )((void *)0)) {
#line 122
    return (17);
  }
#line 124
  pcaf = (CAF_PRIVATE *)psf->container_data;
#line 126
  if (psf->file.mode == 16) {
    _L: 
    {
#line 127
    error = caf_read_header(psf);
    }
#line 127
    if (error) {
#line 128
      return (error);
    }
#line 130
    psf->next_chunk_iterator = & caf_next_chunk_iterator;
#line 131
    psf->get_chunk_size = & caf_get_chunk_size;
#line 132
    psf->get_chunk_data = & caf_get_chunk_data;
  } else
#line 126
  if (psf->file.mode == 48) {
#line 126
    if (psf->filelength > 0L) {
#line 126
      goto _L;
    }
  }
#line 135
  subformat = psf->sf.format & 65535;
#line 137
  if (psf->file.mode == 32) {
    _L___39: 
#line 138
    if (psf->is_pipe) {
#line 139
      return (29);
    }
#line 141
    format = psf->sf.format & 268369920;
#line 142
    if (format != 1572864) {
#line 143
      return (1);
    }
#line 145
    psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 147
    if (psf->file.mode != 48) {
#line 148
      psf->filelength = (sf_count_t )0;
#line 149
      psf->datalength = (sf_count_t )0;
#line 150
      psf->dataoffset = (sf_count_t )0;
#line 151
      psf->sf.frames = (sf_count_t )0;
    } else
#line 147
    if (psf->filelength < 44L) {
#line 148
      psf->filelength = (sf_count_t )0;
#line 149
      psf->datalength = (sf_count_t )0;
#line 150
      psf->dataoffset = (sf_count_t )0;
#line 151
      psf->sf.frames = (sf_count_t )0;
    }
#line 154
    psf->strings.flags = (uint32_t )768;
#line 160
    if (psf->file.mode == 32) {
#line 160
      if (subformat == 6) {
        _L___38: 
        {
#line 161
        psf->peak_info = peak_info_calloc(psf->sf.channels);
        }
#line 161
        if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 162
          return (17);
        }
#line 163
        (psf->peak_info)->peak_loc = 42;
      } else
#line 160
      if (subformat == 7) {
#line 160
        goto _L___38;
      }
    }
    {
#line 166
    error = caf_write_header(psf, 0);
    }
#line 166
    if (error != 0) {
#line 167
      return (error);
    }
#line 169
    psf->write_header = & caf_write_header;
#line 170
    psf->set_chunk = & caf_set_chunk;
  } else
#line 137
  if (psf->file.mode == 48) {
#line 137
    goto _L___39;
  }
#line 173
  psf->container_close = & caf_close;
#line 174
  psf->command = & caf_command;
#line 180
  if (subformat == 4) {
#line 180
    goto case_4;
  }
#line 180
  if (subformat == 3) {
#line 180
    goto case_4;
  }
#line 180
  if (subformat == 2) {
#line 180
    goto case_4;
  }
#line 180
  if (subformat == 1) {
#line 180
    goto case_4;
  }
#line 184
  if (subformat == 16) {
#line 184
    goto case_16;
  }
#line 188
  if (subformat == 17) {
#line 188
    goto case_17;
  }
#line 193
  if (subformat == 6) {
#line 193
    goto case_6;
  }
#line 197
  if (subformat == 7) {
#line 197
    goto case_7;
  }
#line 204
  if (subformat == 115) {
#line 204
    goto case_115;
  }
#line 204
  if (subformat == 114) {
#line 204
    goto case_115;
  }
#line 204
  if (subformat == 113) {
#line 204
    goto case_115;
  }
#line 204
  if (subformat == 112) {
#line 204
    goto case_115;
  }
#line 214
  goto switch_default;
  case_4: 
  {
#line 181
  error = pcm_init(psf);
  }
#line 182
  goto switch_break;
  case_16: 
  {
#line 185
  error = ulaw_init(psf);
  }
#line 186
  goto switch_break;
  case_17: 
  {
#line 189
  error = alaw_init(psf);
  }
#line 190
  goto switch_break;
  case_6: 
  {
#line 194
  error = float32_init(psf);
  }
#line 195
  goto switch_break;
  case_7: 
  {
#line 198
  error = double64_init(psf);
  }
#line 199
  goto switch_break;
  case_115: 
#line 205
  if (psf->file.mode == 16) {
    {
#line 207
    error = alac_init(psf, & pcaf->alac);
    }
  } else {
    {
#line 209
    error = alac_init(psf, (ALAC_DECODER_INFO *)((void *)0));
    }
  }
#line 210
  goto switch_break;
  switch_default: 
#line 215
  return (4);
  switch_break: ;
#line 218
  return (error);
}
}
#line 222 "/root/patchweave_new/23/src/caf.c"
static int caf_close(SF_PRIVATE *psf ) 
{ 


  {
#line 224
  if (psf->file.mode == 32) {
    {
#line 225
    caf_write_tailer(psf);
#line 226
    caf_write_header(psf, 1);
    }
  } else
#line 224
  if (psf->file.mode == 48) {
    {
#line 225
    caf_write_tailer(psf);
#line 226
    caf_write_header(psf, 1);
    }
  }
#line 229
  return (0);
}
}
#line 233 "/root/patchweave_new/23/src/caf.c"
static int caf_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int UNUSED_datasize ) 
{ 
  CAF_PRIVATE *pcaf ;

  {
#line 236
  pcaf = (CAF_PRIVATE *)psf->container_data;
#line 236
  if ((unsigned long )pcaf == (unsigned long )((void *)0)) {
#line 237
    return (30);
  }
#line 240
  if (command == 4353) {
#line 240
    goto case_4353;
  }
#line 244
  goto switch_default;
  case_4353: 
  {
#line 241
  pcaf->chanmap_tag = aiff_caf_find_channel_layout_tag((int const   *)psf->channel_map,
                                                       psf->sf.channels);
  }
#line 242
  return (pcaf->chanmap_tag != 0);
  switch_default: 
#line 245
  goto switch_break;
  switch_break: ;
#line 248
  return (0);
}
}
#line 255 "/root/patchweave_new/23/src/caf.c"
static int decode_desc_chunk(SF_PRIVATE *psf , DESC_CHUNK *desc ) 
{ 
  int format ;
  CAF_PRIVATE *pcaf ;
  int tmp ;

  {
#line 256
  format = 1572864;
#line 258
  psf->sf.channels = (int )desc->channels_per_frame;
#line 260
  if (desc->fmt_id == ((unsigned int )((97 | (108 << 8)) | (97 << 16)) | (99U << 24))) {
#line 263
    pcaf = (CAF_PRIVATE *)psf->container_data;
#line 263
    if ((unsigned long )pcaf != (unsigned long )((void *)0)) {
#line 265
      if (desc->fmt_flags == 1U) {
#line 265
        goto case_1;
      }
#line 269
      if (desc->fmt_flags == 2U) {
#line 269
        goto case_2;
      }
#line 273
      if (desc->fmt_flags == 3U) {
#line 273
        goto case_3;
      }
#line 277
      if (desc->fmt_flags == 4U) {
#line 277
        goto case_4;
      }
#line 281
      goto switch_default;
      case_1: 
#line 266
      pcaf->alac.bits_per_sample = 16U;
#line 267
      format |= 112;
#line 268
      goto switch_break;
      case_2: 
#line 270
      pcaf->alac.bits_per_sample = 20U;
#line 271
      format |= 113;
#line 272
      goto switch_break;
      case_3: 
#line 274
      pcaf->alac.bits_per_sample = 24U;
#line 275
      format |= 114;
#line 276
      goto switch_break;
      case_4: 
#line 278
      pcaf->alac.bits_per_sample = 32U;
#line 279
      format |= 115;
#line 280
      goto switch_break;
      switch_default: 
      {
#line 282
      psf_log_printf(psf, "Bad ALAC format flag value of %d\n", desc->fmt_flags);
      }
      switch_break: 
#line 285
      pcaf->alac.frames_per_packet = desc->frames_per_packet;
    }
#line 288
    return (format);
  }
#line 291
  if (psf->endian == 268435456) {
#line 291
    tmp = 268435456;
  } else {
#line 291
    tmp = 0;
  }
#line 291
  format |= tmp;
#line 293
  if (desc->fmt_id == ((unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24))) {
#line 293
    if (desc->fmt_flags & 1U) {
#line 295
      if (desc->bits_per_chan == 32U) {
#line 295
        if (desc->pkt_bytes == 4U * desc->channels_per_frame) {
#line 296
          psf->bytewidth = 4;
#line 297
          return (format | 6);
        }
      }
#line 299
      if (desc->bits_per_chan == 64U) {
#line 299
        if (desc->pkt_bytes == 8U * desc->channels_per_frame) {
#line 300
          psf->bytewidth = 8;
#line 301
          return (format | 7);
        }
      }
    }
  }
#line 305
  if (desc->fmt_id == ((unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24))) {
#line 305
    if ((desc->fmt_flags & 1U) == 0U) {
#line 307
      if (desc->bits_per_chan == 32U) {
#line 307
        if (desc->pkt_bytes == 4U * desc->channels_per_frame) {
#line 308
          psf->bytewidth = 4;
#line 309
          return (format | 4);
        }
      }
#line 311
      if (desc->bits_per_chan == 24U) {
#line 311
        if (desc->pkt_bytes == 3U * desc->channels_per_frame) {
#line 312
          psf->bytewidth = 3;
#line 313
          return (format | 3);
        }
      }
#line 315
      if (desc->bits_per_chan == 16U) {
#line 315
        if (desc->pkt_bytes == 2U * desc->channels_per_frame) {
#line 316
          psf->bytewidth = 2;
#line 317
          return (format | 2);
        }
      }
#line 319
      if (desc->bits_per_chan == 8U) {
#line 319
        if (desc->pkt_bytes == desc->channels_per_frame) {
#line 320
          psf->bytewidth = 1;
#line 321
          return (format | 1);
        }
      }
    }
  }
#line 325
  if (desc->fmt_id == ((unsigned int )((97 | (108 << 8)) | (97 << 16)) | (119U << 24))) {
#line 325
    if (desc->bits_per_chan == 8U) {
#line 326
      psf->bytewidth = 1;
#line 327
      return (format | 17);
    }
  }
#line 330
  if (desc->fmt_id == ((unsigned int )((117 | (108 << 8)) | (97 << 16)) | (119U << 24))) {
#line 330
    if (desc->bits_per_chan == 8U) {
#line 331
      psf->bytewidth = 1;
#line 332
      return (format | 16);
    }
  }
  {
#line 335
  psf_log_printf(psf, "**** Unknown format identifier.\n\220");
  }
#line 337
  return (0);
}
}
#line 341 "/root/patchweave_new/23/src/caf.c"
static int caf_read_header(SF_PRIVATE *psf ) 
{ 
  CAF_PRIVATE *pcaf ;
  BUF_UNION ubuf ;
  DESC_CHUNK desc ;
  sf_count_t chunk_size ;
  double srate ;
  short version ;
  short flags ;
  int marker ;
  int k ;
  int have_data ;
  int error ;
  long __cil_tmp14 ;
  sf_count_t pos ;
  sf_count_t __cil_tmp16 ;
  sf_count_t __cil_tmp17 ;
  size_t __cil_tmp18 ;
  sf_count_t position ;
  float value___0 ;
  size_t __cil_tmp23 ;
  size_t __cil_tmp25 ;
  size_t __cil_tmp26 ;
  sf_count_t __cil_tmp27 ;
  size_t __cil_tmp28 ;
  sf_count_t __cil_tmp29 ;
  size_t __cil_tmp30 ;
  size_t __cil_tmp31 ;
  sf_count_t __cil_tmp32 ;
  int tmp ;

  {
#line 348
  have_data = 0;
#line 350
  pcaf = (CAF_PRIVATE *)psf->container_data;
#line 350
  if ((unsigned long )pcaf == (unsigned long )((void *)0)) {
#line 351
    return (30);
  }
  {
#line 353
  memset((void *)(& desc), 0, sizeof(desc));
#line 356
  psf_binheader_readf(psf, "pmE2E2", 0, & marker, & version, & flags);
#line 357
  psf_log_printf(psf, "%M\n  Version : %d\n  Flags   : %x\n", marker, (int )version,
                 (int )flags);
  }
#line 358
  if ((unsigned int )marker != ((unsigned int )((99 | (97 << 8)) | (102 << 16)) | (102U << 24))) {
#line 359
    return (666);
  }
  {
#line 361
  psf_binheader_readf(psf, "mE8b", & marker, & chunk_size, ubuf.ucbuf, 8);
#line 362
  srate = double64_be_read((unsigned char const   *)(ubuf.ucbuf));
#line 363
  snprintf(ubuf.cbuf, sizeof(ubuf.cbuf), "%5.3f", srate);
#line 364
  psf_log_printf(psf, "%M : %D\n  Sample rate  : %s\n", marker, chunk_size, ubuf.cbuf);
  }
#line 365
  if ((unsigned int )marker != ((unsigned int )((100 | (101 << 8)) | (115 << 16)) | (99U << 24))) {
#line 366
    return (667);
  }
#line 368
  if (chunk_size < (long )((int )sizeof(DESC_CHUNK ))) {
    {
#line 369
    psf_log_printf(psf, "**** Chunk size too small. Should be > 32 bytes.\n");
    }
#line 370
    return (3);
  }
  {
#line 373
  __cil_tmp14 = lrint(srate);
#line 373
  psf->sf.samplerate = (int )__cil_tmp14;
#line 375
  psf_binheader_readf(psf, "mE44444", & desc.fmt_id, & desc.fmt_flags, & desc.pkt_bytes,
                      & desc.frames_per_packet, & desc.channels_per_frame, & desc.bits_per_chan);
#line 377
  psf_log_printf(psf, "  Format id    : %M\n  Format flags : %x\n  Bytes / packet   : %u\n  Frames / packet  : %u\n  Channels / frame : %u\n  Bits / channel   : %u\n",
                 desc.fmt_id, desc.fmt_flags, desc.pkt_bytes, desc.frames_per_packet,
                 desc.channels_per_frame, desc.bits_per_chan);
  }
#line 381
  if (desc.channels_per_frame > 1024U) {
    {
#line 382
    psf_log_printf(psf, "**** Bad channels per frame value %u.\n", desc.channels_per_frame);
    }
#line 383
    return (3);
  }
#line 386
  if (chunk_size > (long )((int )sizeof(DESC_CHUNK ))) {
    {
#line 387
    psf_binheader_readf(psf, "j", (int )((unsigned long )chunk_size - sizeof(DESC_CHUNK )));
    }
  }
#line 389
  psf->sf.channels = (int )desc.channels_per_frame;
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 392
    marker = 0;
#line 393
    chunk_size = (sf_count_t )0;
#line 395
    psf_binheader_readf(psf, "mE8", & marker, & chunk_size);
    }
#line 396
    if (marker == 0) {
      {
#line 397
      __cil_tmp16 = psf_ftell(psf);
#line 397
      pos = __cil_tmp16;
#line 398
      psf_log_printf(psf, "Have 0 marker at position %D (0x%x).\nU", pos, pos);
      }
#line 399
      goto while_break;
    }
#line 401
    if (chunk_size < 0L) {
      {
#line 402
      psf_log_printf(psf, "%M : %D *** Should be >= 0 ***\n", marker, chunk_size);
      }
#line 403
      goto while_break;
    }
#line 405
    if (chunk_size > psf->filelength) {
#line 406
      goto while_break;
    }
    {
#line 408
    __cil_tmp17 = psf_ftell(psf);
#line 408
    psf_store_read_chunk_u32(& psf->rchunks, (uint32_t )marker, __cil_tmp17, (uint32_t )chunk_size);
    }
#line 411
    if (marker == (int )((unsigned int )((112 | (101 << 8)) | (97 << 16)) | (107U << 24))) {
#line 411
      goto case_exp;
    }
#line 442
    if (marker == (int )((unsigned int )((99 | (104 << 8)) | (97 << 16)) | (110U << 24))) {
#line 442
      goto case_exp___0;
    }
#line 455
    if (marker == (int )((unsigned int )((102 | (114 << 8)) | (101 << 16)) | (101U << 24))) {
#line 455
      goto case_exp___1;
    }
#line 460
    if (marker == (int )((unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24))) {
#line 460
      goto case_exp___2;
    }
#line 486
    if (marker == (int )((unsigned int )((107 | (117 << 8)) | (107 << 16)) | (105U << 24))) {
#line 486
      goto case_exp___3;
    }
#line 492
    if (marker == (int )((unsigned int )((112 | (97 << 8)) | (107 << 16)) | (116U << 24))) {
#line 492
      goto case_exp___4;
    }
#line 524
    if (marker == (int )((unsigned int )((105 | (110 << 8)) | (102 << 16)) | (111U << 24))) {
#line 524
      goto case_exp___5;
    }
#line 538
    goto switch_default;
    case_exp: 
    {
#line 412
    psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
    }
#line 413
    if (chunk_size != (long )((int )(sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + 8UL)))) {
      {
#line 414
      __cil_tmp18 = make_size_t((int )chunk_size);
#line 414
      psf_binheader_readf(psf, "j\035\253H\270U", __cil_tmp18);
#line 415
      psf_log_printf(psf, "*** File PEAK chunk %D should be %d.\nU", chunk_size, (int )(sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + 8UL)));
      }
#line 416
      return (668);
    }
    {
#line 419
    psf->peak_info = peak_info_calloc(psf->sf.channels);
    }
#line 419
    if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 420
      return (17);
    }
    {
#line 423
    psf_binheader_readf(psf, "E4\253H\270U", & (psf->peak_info)->edit_number);
#line 424
    psf_log_printf(psf, "  edit count : %d\n\253H\270U", (psf->peak_info)->edit_number);
#line 426
    psf_log_printf(psf, "     Ch   Position       Value\n");
#line 427
    k = 0;
    }
    {
#line 427
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 427
      if (! (k < psf->sf.channels)) {
#line 427
        goto while_break___0;
      }
      {
#line 431
      psf_binheader_readf(psf, "Ef8", & value___0, & position);
#line 432
      (psf->peak_info)->peaks[k].value = (double )value___0;
#line 433
      (psf->peak_info)->peaks[k].position = position;
#line 435
      snprintf(ubuf.cbuf, sizeof(ubuf.cbuf), "    %2d   %-12ld   %g\n", k, position,
               (double )value___0);
#line 436
      psf_log_printf(psf, (char const   *)(ubuf.cbuf));
#line 427
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 439
    (psf->peak_info)->peak_loc = 42;
#line 440
    goto switch_break;
    case_exp___0: 
#line 443
    if (chunk_size < 12L) {
      {
#line 444
      psf_log_printf(psf, "%M : %D (should be >= 12)\n\253H\270U", marker, chunk_size);
#line 445
      __cil_tmp23 = make_size_t((int )chunk_size);
#line 445
      psf_binheader_readf(psf, "j", __cil_tmp23);
      }
#line 446
      goto switch_break;
    }
    {
#line 449
    psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
#line 451
    error = caf_read_chanmap(psf, chunk_size);
    }
#line 451
    if (error) {
#line 452
      return (error);
    }
#line 453
    goto switch_break;
    case_exp___1: 
    {
#line 456
    psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
#line 457
    __cil_tmp25 = make_size_t((int )chunk_size);
#line 457
    psf_binheader_readf(psf, "j", __cil_tmp25);
    }
#line 458
    goto switch_break;
    case_exp___2: 
    {
#line 461
    psf_binheader_readf(psf, "E4", & k);
    }
#line 462
    if (chunk_size == -1L) {
      {
#line 463
      psf_log_printf(psf, "%M : -1\n\220");
#line 464
      chunk_size = psf->filelength - psf->header.indx;
      }
    } else
#line 466
    if (psf->filelength > 0L) {
#line 466
      if (chunk_size > (psf->filelength - psf->header.indx) + 10L) {
        {
#line 467
        psf_log_printf(psf, "%M : %D (should be %D)\n", marker, chunk_size, (psf->filelength - psf->header.indx) - 8L);
#line 468
        psf->datalength = (psf->filelength - psf->header.indx) - 8L;
        }
      } else {
        {
#line 471
        psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
#line 473
        psf->datalength = chunk_size - 4L;
        }
      }
    } else {
      {
#line 471
      psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
#line 473
      psf->datalength = chunk_size - 4L;
      }
    }
    {
#line 476
    psf_log_printf(psf, "  edit : %u\n", k);
#line 478
    psf->dataoffset = psf->header.indx;
    }
#line 479
    if (psf->datalength + psf->dataoffset < psf->filelength) {
#line 480
      psf->dataend = psf->datalength + psf->dataoffset;
    }
    {
#line 482
    __cil_tmp26 = make_size_t((int )psf->datalength);
#line 482
    psf_binheader_readf(psf, "j", __cil_tmp26);
#line 483
    have_data = 1;
    }
#line 484
    goto switch_break;
    case_exp___3: 
    {
#line 487
    psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
#line 488
    __cil_tmp27 = psf_ftell(psf);
#line 488
    pcaf->alac.kuki_offset = (unsigned int )(__cil_tmp27 - 12L);
#line 489
    __cil_tmp28 = make_size_t((int )chunk_size);
#line 489
    psf_binheader_readf(psf, "j", __cil_tmp28);
    }
#line 490
    goto switch_break;
    case_exp___4: 
#line 493
    if (chunk_size < 24L) {
      {
#line 494
      psf_log_printf(psf, "%M : %D (should be > 24)\n", marker, chunk_size);
      }
#line 495
      return (3);
    } else
#line 497
    if (chunk_size > psf->filelength - psf->header.indx) {
      {
#line 498
      psf_log_printf(psf, "%M : %D (should be < %D)\n", marker, chunk_size, psf->filelength - psf->header.indx);
      }
#line 499
      return (3);
    } else {
      {
#line 502
      psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
      }
    }
    {
#line 504
    psf_binheader_readf(psf, "E8844", & pcaf->alac.packets, & pcaf->alac.valid_frames,
                        & pcaf->alac.priming_frames, & pcaf->alac.remainder_frames);
#line 507
    psf_log_printf(psf, "  Packets          : %D\n  Valid frames     : %D\n  Priming frames   : %d\n  Remainder frames : %d\n",
                   pcaf->alac.packets, pcaf->alac.valid_frames, pcaf->alac.priming_frames,
                   pcaf->alac.remainder_frames);
    }
#line 516
    if (pcaf->alac.packets == 0L) {
#line 516
      if (pcaf->alac.valid_frames == 0L) {
#line 516
        if (pcaf->alac.priming_frames == 0) {
#line 516
          if (pcaf->alac.remainder_frames == 0) {
            {
#line 518
            psf_log_printf(psf, "*** \'pakt\' chunk header is all zero.\n");
            }
          }
        }
      }
    }
    {
#line 520
    __cil_tmp29 = psf_ftell(psf);
#line 520
    pcaf->alac.pakt_offset = (unsigned int )(__cil_tmp29 - 12L);
#line 521
    __cil_tmp30 = make_size_t((int )chunk_size);
#line 521
    psf_binheader_readf(psf, "j", __cil_tmp30 - 24UL);
    }
#line 522
    goto switch_break;
    case_exp___5: 
#line 525
    if (chunk_size < 4L) {
      {
#line 526
      psf_log_printf(psf, "%M : %D (should be > 4)\n\230\001", marker, chunk_size);
      }
#line 527
      return (3);
    } else
#line 529
    if (chunk_size > psf->filelength - psf->header.indx) {
      {
#line 530
      psf_log_printf(psf, "%M : %D (should be < %D)\n", marker, chunk_size, psf->filelength - psf->header.indx);
      }
#line 531
      return (3);
    }
    {
#line 533
    psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
    }
#line 534
    if (chunk_size > 4L) {
      {
#line 535
      caf_read_strings(psf, chunk_size - 4L);
      }
    }
#line 536
    goto switch_break;
    switch_default: 
    {
#line 539
    psf_log_printf(psf, "%M : %D (skipped)\n", marker, chunk_size);
#line 540
    __cil_tmp31 = make_size_t((int )chunk_size);
#line 540
    psf_binheader_readf(psf, "j", __cil_tmp31);
    }
#line 541
    goto switch_break;
    switch_break: ;
#line 544
    if ((unsigned int )marker != ((unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24))) {
#line 544
      if (chunk_size >= 4294967040L) {
#line 545
        goto while_break;
      }
    }
#line 547
    if (! psf->sf.seekable) {
#line 547
      if (have_data) {
#line 548
        goto while_break;
      }
    }
    {
#line 550
    __cil_tmp32 = psf_ftell(psf);
    }
#line 550
    if (__cil_tmp32 >= psf->filelength - (long )((int )sizeof(chunk_size))) {
      {
#line 551
      psf_log_printf(psf, "End\n");
      }
#line 552
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 556
  if (have_data == 0) {
    {
#line 557
    psf_log_printf(psf, "**** Error, could not find \'data\' chunk.\n");
    }
#line 558
    return (3);
  }
#line 561
  if (desc.fmt_flags & 2U) {
#line 561
    tmp = 268435456;
  } else {
#line 561
    tmp = 536870912;
  }
  {
#line 561
  psf->endian = tmp;
#line 563
  psf_fseek(psf, psf->dataoffset, 0);
#line 565
  psf->sf.format = decode_desc_chunk(psf, & desc);
  }
#line 565
  if (psf->sf.format == 0) {
#line 566
    return (4);
  }
#line 568
  if (psf->bytewidth > 0) {
#line 569
    psf->sf.frames = psf->datalength / (long )psf->bytewidth;
  }
#line 571
  return (0);
}
}
#line 578 "/root/patchweave_new/23/src/caf.c"
static int caf_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  BUF_UNION ubuf ;
  CAF_PRIVATE *pcaf ;
  DESC_CHUNK desc ;
  sf_count_t current ;
  uint32_t uk ;
  int subformat ;
  int append_free_block ;
  size_t __cil_tmp12 ;
  int k ;
  size_t __cil_tmp15 ;
  sf_count_t free_len ;
  size_t __cil_tmp18 ;

  {
#line 584
  append_free_block = 1;
#line 586
  pcaf = (CAF_PRIVATE *)psf->container_data;
#line 586
  if ((unsigned long )pcaf == (unsigned long )((void *)0)) {
#line 587
    return (30);
  }
  {
#line 589
  memset((void *)(& desc), 0, sizeof(desc));
#line 591
  current = psf_ftell(psf);
  }
#line 593
  if (calc_length) {
    {
#line 594
    psf->filelength = psf_get_filelen(psf);
#line 596
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 598
    if (psf->dataend) {
#line 599
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 601
    if (psf->bytewidth > 0) {
#line 602
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
  {
#line 606
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 607
  psf->header.indx = (sf_count_t )0;
#line 608
  psf_fseek(psf, (sf_count_t )0, 0);
#line 611
  psf_binheader_writef(psf, "Em22\270U", (unsigned int )((99 | (97 << 8)) | (102 << 16)) | (102U << 24),
                       1, 0);
#line 614
  psf_binheader_writef(psf, "Em8H\270U", (unsigned int )((100 | (101 << 8)) | (115 << 16)) | (99U << 24),
                       (sf_count_t )sizeof(DESC_CHUNK ));
#line 616
  double64_be_write(1. * (double )psf->sf.samplerate, ubuf.ucbuf);
#line 617
  __cil_tmp12 = make_size_t(8);
#line 617
  psf_binheader_writef(psf, "b\024\254H\270U", ubuf.ucbuf, __cil_tmp12);
#line 619
  subformat = psf->sf.format & 65535;
#line 621
  psf->endian = psf->sf.format & 805306368;
  }
#line 625
  if (psf->endian == 268435456) {
#line 626
    psf->endian = 268435456;
  } else
#line 625
  if (psf->endian == 805306368) {
#line 626
    psf->endian = 268435456;
  }
#line 628
  if (psf->endian == 268435456) {
#line 629
    desc.fmt_flags = (uint32_t )2;
  } else {
#line 631
    psf->endian = 536870912;
  }
#line 635
  if (subformat == 1) {
#line 635
    goto case_1;
  }
#line 644
  if (subformat == 2) {
#line 644
    goto case_2;
  }
#line 653
  if (subformat == 3) {
#line 653
    goto case_3;
  }
#line 662
  if (subformat == 4) {
#line 662
    goto case_4;
  }
#line 671
  if (subformat == 6) {
#line 671
    goto case_6;
  }
#line 681
  if (subformat == 7) {
#line 681
    goto case_7;
  }
#line 691
  if (subformat == 17) {
#line 691
    goto case_17;
  }
#line 700
  if (subformat == 16) {
#line 700
    goto case_16;
  }
#line 712
  if (subformat == 115) {
#line 712
    goto case_115;
  }
#line 712
  if (subformat == 114) {
#line 712
    goto case_115;
  }
#line 712
  if (subformat == 113) {
#line 712
    goto case_115;
  }
#line 712
  if (subformat == 112) {
#line 712
    goto case_115;
  }
#line 720
  goto switch_default;
  case_1: 
#line 636
  desc.fmt_id = (unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24);
#line 637
  psf->bytewidth = 1;
#line 638
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 639
  desc.frames_per_packet = (uint32_t )1;
#line 640
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 641
  desc.bits_per_chan = (uint32_t )8;
#line 642
  goto switch_break;
  case_2: 
#line 645
  desc.fmt_id = (unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24);
#line 646
  psf->bytewidth = 2;
#line 647
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 648
  desc.frames_per_packet = (uint32_t )1;
#line 649
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 650
  desc.bits_per_chan = (uint32_t )16;
#line 651
  goto switch_break;
  case_3: 
#line 654
  psf->bytewidth = 3;
#line 655
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 656
  desc.frames_per_packet = (uint32_t )1;
#line 657
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 658
  desc.bits_per_chan = (uint32_t )24;
#line 659
  desc.fmt_id = (unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24);
#line 660
  goto switch_break;
  case_4: 
#line 663
  desc.fmt_id = (unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24);
#line 664
  psf->bytewidth = 4;
#line 665
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 666
  desc.frames_per_packet = (uint32_t )1;
#line 667
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 668
  desc.bits_per_chan = (uint32_t )32;
#line 669
  goto switch_break;
  case_6: 
#line 672
  desc.fmt_id = (unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24);
#line 673
  desc.fmt_flags |= 1U;
#line 674
  psf->bytewidth = 4;
#line 675
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 676
  desc.frames_per_packet = (uint32_t )1;
#line 677
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 678
  desc.bits_per_chan = (uint32_t )32;
#line 679
  goto switch_break;
  case_7: 
#line 682
  desc.fmt_id = (unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24);
#line 683
  desc.fmt_flags |= 1U;
#line 684
  psf->bytewidth = 8;
#line 685
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 686
  desc.frames_per_packet = (uint32_t )1;
#line 687
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 688
  desc.bits_per_chan = (uint32_t )64;
#line 689
  goto switch_break;
  case_17: 
#line 692
  desc.fmt_id = (unsigned int )((97 | (108 << 8)) | (97 << 16)) | (119U << 24);
#line 693
  psf->bytewidth = 1;
#line 694
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 695
  desc.frames_per_packet = (uint32_t )1;
#line 696
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 697
  desc.bits_per_chan = (uint32_t )8;
#line 698
  goto switch_break;
  case_16: 
#line 701
  desc.fmt_id = (unsigned int )((117 | (108 << 8)) | (97 << 16)) | (119U << 24);
#line 702
  psf->bytewidth = 1;
#line 703
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 704
  desc.frames_per_packet = (uint32_t )1;
#line 705
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 706
  desc.bits_per_chan = (uint32_t )8;
#line 707
  goto switch_break;
  case_115: 
  {
#line 713
  desc.fmt_id = (unsigned int )((97 | (108 << 8)) | (97 << 16)) | (99U << 24);
#line 714
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 715
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 716
  alac_get_desc_chunk_items(subformat, & desc.fmt_flags, & desc.frames_per_packet);
#line 717
  append_free_block = 0;
  }
#line 718
  goto switch_break;
  switch_default: 
#line 721
  return (18);
  switch_break: 
  {
#line 724
  psf_binheader_writef(psf, "mE44444", desc.fmt_id, desc.fmt_flags, desc.pkt_bytes,
                       desc.frames_per_packet, desc.channels_per_frame, desc.bits_per_chan);
#line 726
  caf_write_strings(psf, 1024);
  }
#line 728
  if ((unsigned long )psf->peak_info != (unsigned long )((void *)0)) {
    {
#line 730
    psf_binheader_writef(psf, "Em84\270U", (unsigned int )((112 | (101 << 8)) | (97 << 16)) | (107U << 24),
                         (sf_count_t )((int )(sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + 8UL))),
                         (psf->peak_info)->edit_number);
#line 731
    k = 0;
    }
    {
#line 731
    while (1) {
      while_continue: /* CIL Label */ ;

#line 731
      if (! (k < psf->sf.channels)) {
#line 731
        goto while_break;
      }
      {
#line 732
      psf_binheader_writef(psf, "Ef8", (double )((float )(psf->peak_info)->peaks[k].value),
                           (psf->peak_info)->peaks[k].position);
#line 731
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 735
  if (psf->channel_map) {
#line 735
    if (pcaf->chanmap_tag) {
      {
#line 736
      psf_binheader_writef(psf, "Em8444", (unsigned int )((99 | (104 << 8)) | (97 << 16)) | (110U << 24),
                           (sf_count_t )12, pcaf->chanmap_tag, 0, 0);
      }
    }
  }
#line 739
  uk = (uint32_t )0;
  {
#line 739
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 739
    if (! (uk < psf->wchunks.used)) {
#line 739
      goto while_break___0;
    }
    {
#line 740
    __cil_tmp15 = make_size_t((int )(psf->wchunks.chunks + uk)->len);
#line 740
    psf_binheader_writef(psf, "m44b\270U", (int )(psf->wchunks.chunks + uk)->mark32,
                         0, (psf->wchunks.chunks + uk)->len, (psf->wchunks.chunks + uk)->data,
                         __cil_tmp15);
#line 739
    uk ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 742
  if (append_free_block) {
#line 744
    free_len = ((4096L - psf->header.indx) - 16L) - 12L;
    {
#line 745
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 745
      if (! (free_len < 0L)) {
#line 745
        goto while_break___1;
      }
#line 746
      free_len += 4096L;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 747
    __cil_tmp18 = make_size_t((int )free_len);
#line 747
    psf_binheader_writef(psf, "Em8z\270U", (unsigned int )((102 | (114 << 8)) | (101 << 16)) | (101U << 24),
                         free_len, __cil_tmp18);
    }
  }
  {
#line 750
  psf_binheader_writef(psf, "Em84\270U", (unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24),
                       psf->datalength + 4L, 0);
#line 752
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 753
  if (psf->error) {
#line 754
    return (psf->error);
  }
#line 756
  psf->dataoffset = psf->header.indx;
#line 757
  if (current < psf->dataoffset) {
    {
#line 758
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 759
  if (current > 0L) {
    {
#line 760
    psf_fseek(psf, current, 0);
    }
  }
#line 762
  return (psf->error);
}
}
#line 766 "/root/patchweave_new/23/src/caf.c"
static int caf_write_tailer(SF_PRIVATE *psf ) 
{ 


  {
#line 769
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 770
  psf->header.indx = (sf_count_t )0;
#line 772
  if (psf->bytewidth > 0) {
#line 772
    if (psf->sf.seekable == 1) {
#line 773
      psf->datalength = (psf->sf.frames * (long )psf->bytewidth) * (long )psf->sf.channels;
#line 774
      psf->dataend = psf->dataoffset + psf->datalength;
    }
  }
#line 777
  if (psf->dataend > 0L) {
    {
#line 778
    psf_fseek(psf, psf->dataend, 0);
    }
  } else {
    {
#line 780
    psf->dataend = psf_fseek(psf, (sf_count_t )0, 2);
    }
  }
#line 782
  if (psf->dataend & 1L) {
    {
#line 783
    psf_binheader_writef(psf, "z", 1);
    }
  }
#line 785
  if (psf->strings.flags & 2048U) {
    {
#line 786
    caf_write_strings(psf, 2048);
    }
  }
#line 789
  if (psf->header.indx > 0L) {
    {
#line 790
    psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1,
               psf);
    }
  }
#line 792
  return (0);
}
}
#line 796 "/root/patchweave_new/23/src/caf.c"
static int caf_read_chanmap(SF_PRIVATE *psf , sf_count_t chunk_size ) 
{ 
  AIFF_CAF_CHANNEL_MAP *map_info ;
  unsigned int channel_bitmap ;
  unsigned int channel_decriptions ;
  unsigned int bytesread ;
  int layout_tag ;
  int __cil_tmp8 ;
  size_t chanmap_size ;
  void *tmp ;

  {
  {
#line 801
  __cil_tmp8 = psf_binheader_readf(psf, "E444\270U", & layout_tag, & channel_bitmap,
                                   & channel_decriptions);
#line 801
  bytesread = (unsigned int )__cil_tmp8;
#line 803
  map_info = aiff_caf_of_channel_layout_tag(layout_tag);
#line 805
  psf_log_printf(psf, "  Tag    : %x\n", layout_tag);
  }
#line 806
  if (map_info) {
    {
#line 807
    psf_log_printf(psf, "  Layout : %s\n", map_info->name);
    }
  }
#line 809
  if ((long )bytesread < chunk_size) {
    {
#line 810
    psf_binheader_readf(psf, "ja\253H\270U", chunk_size - (long )bytesread);
    }
  }
#line 812
  if (map_info) {
#line 812
    if ((unsigned long )map_info->channel_map != (unsigned long )((void *)0)) {
      {
#line 813
      chanmap_size = 0UL;
#line 815
      free((void *)psf->channel_map);
#line 817
      tmp = malloc(chanmap_size);
#line 817
      psf->channel_map = (int *)tmp;
      }
#line 817
      if ((unsigned long )psf->channel_map == (unsigned long )((void *)0)) {
#line 818
        return (17);
      }
      {
#line 820
      memcpy((void *)psf->channel_map, (void const   *)map_info->channel_map, chanmap_size);
      }
    }
  }
#line 823
  return (0);
}
}
#line 828 "/root/patchweave_new/23/src/caf.c"
static uint32_t string_hash32(char const   *str___0 ) 
{ 
  uint32_t hash ;

  {
#line 829
  hash = 2271560481U;
  {
#line 831
  while (1) {
    while_continue: /* CIL Label */ ;

#line 831
    if (! *(str___0 + 0)) {
#line 831
      goto while_break;
    }
#line 832
    hash = hash * 333U + (unsigned int )*(str___0 + 0);
#line 833
    str___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 836
  return (hash);
}
}
#line 840 "/root/patchweave_new/23/src/caf.c"
static int caf_read_strings(SF_PRIVATE *psf , sf_count_t chunk_size ) 
{ 
  char *buf ;
  char *key ;
  char *value___0 ;
  uint32_t count___0 ;
  uint32_t hash ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp12 ;
  void *tmp ;

  {
  {
#line 845
  tmp = malloc((unsigned long )(chunk_size + 1L));
#line 845
  buf = (char *)tmp;
  }
#line 845
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 846
    psf->error = 17;
#line 846
    return (psf->error);
  }
  {
#line 848
  __cil_tmp9 = make_size_t((int )chunk_size);
#line 848
  psf_binheader_readf(psf, "E4bH\270U", & count___0, buf, __cil_tmp9);
#line 849
  psf_log_printf(psf, " count: %u\n", count___0);
#line 852
  *(buf + chunk_size) = (char)0;
#line 854
  key = buf;
  }
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;

#line 854
    if (! ((unsigned long )key < (unsigned long )(buf + chunk_size))) {
#line 854
      goto while_break;
    }
    {
#line 855
    __cil_tmp10 = strlen((char const   *)key);
#line 855
    value___0 = (key + __cil_tmp10) + 1;
    }
#line 856
    if ((unsigned long )value___0 > (unsigned long )(buf + chunk_size)) {
#line 857
      goto while_break;
    }
    {
#line 858
    psf_log_printf(psf, "   %-12s : %s\n", key, value___0);
#line 860
    hash = string_hash32((char const   *)key);
    }
#line 862
    if (hash == 3297122627U) {
#line 862
      goto case_3297122627;
    }
#line 865
    if (hash == 2907153300U) {
#line 865
      goto case_2907153300;
    }
#line 868
    if (hash == 1561824810U) {
#line 868
      goto case_1561824810;
    }
#line 871
    if (hash == 1625608392U) {
#line 871
      goto case_1625608392;
    }
#line 874
    if (hash == 2209730922U) {
#line 874
      goto case_2209730922;
    }
#line 878
    if (hash == 2083093851U) {
#line 878
      goto case_2083093851;
    }
#line 878
    if (hash == 367393928U) {
#line 878
      goto case_2083093851;
    }
#line 881
    if (hash == 614974279U) {
#line 881
      goto case_614974279;
    }
#line 884
    if (hash == 1352867511U) {
#line 884
      goto case_1352867511;
    }
#line 887
    if (hash == 1703105626U) {
#line 887
      goto case_1703105626;
    }
#line 890
    if (hash == 3888532332U) {
#line 890
      goto case_3888532332;
    }
#line 893
    goto switch_default;
    case_3297122627: 
    {
#line 863
    psf_store_string(psf, 1, (char const   *)value___0);
    }
#line 864
    goto switch_break;
    case_2907153300: 
    {
#line 866
    psf_store_string(psf, 3, (char const   *)value___0);
    }
#line 867
    goto switch_break;
    case_1561824810: 
    {
#line 869
    psf_store_string(psf, 2, (char const   *)value___0);
    }
#line 870
    goto switch_break;
    case_1625608392: 
    {
#line 872
    psf_store_string(psf, 4, (char const   *)value___0);
    }
#line 873
    goto switch_break;
    case_2209730922: 
    {
#line 875
    psf_store_string(psf, 16, (char const   *)value___0);
    }
#line 876
    goto switch_break;
    case_2083093851: 
    {
#line 879
    psf_store_string(psf, 5, (char const   *)value___0);
    }
#line 880
    goto switch_break;
    case_614974279: 
    {
#line 882
    psf_store_string(psf, 9, (char const   *)value___0);
    }
#line 883
    goto switch_break;
    case_1352867511: 
    {
#line 885
    psf_store_string(psf, 6, (char const   *)value___0);
    }
#line 886
    goto switch_break;
    case_1703105626: 
    {
#line 888
    psf_store_string(psf, 7, (char const   *)value___0);
    }
#line 889
    goto switch_break;
    case_3888532332: 
    {
#line 891
    psf_store_string(psf, 8, (char const   *)value___0);
    }
#line 892
    goto switch_break;
    switch_default: 
    {
#line 894
    psf_log_printf(psf, " Unhandled hash 0x%x : /* \'%s\' */\n\255H\270U", hash, key);
    }
#line 895
    goto switch_break;
    switch_break: 
    {
#line 898
    __cil_tmp12 = strlen((char const   *)value___0);
#line 898
    key = (value___0 + __cil_tmp12) + 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 901
  free((void *)buf);
  }
#line 903
  return (0);
}
}
#line 912 "/root/patchweave_new/23/src/caf.c"
static uint32_t put_key_value(struct put_buffer *buf , char const   *key , char const   *value___0 ) 
{ 
  uint32_t written ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 915
  __cil_tmp6 = strlen(value___0);
#line 915
  __cil_tmp5 = strlen(key);
  }
#line 915
  if ((((unsigned long )buf->index + __cil_tmp5) + __cil_tmp6) + 2UL > sizeof(buf->s)) {
#line 916
    return ((uint32_t )0);
  }
  {
#line 918
  __cil_tmp7 = snprintf(buf->s + buf->index, sizeof(buf->s) - (unsigned long )buf->index,
                        "%s%c%s%c\230\001", key, 0, value___0, 0);
#line 918
  written = (uint32_t )__cil_tmp7;
  }
#line 920
  if ((unsigned long )(buf->index + written) >= sizeof(buf->s)) {
#line 921
    return ((uint32_t )0);
  }
#line 923
  buf->index += written;
#line 924
  return ((uint32_t )1);
}
}
#line 928 "/root/patchweave_new/23/src/caf.c"
static void caf_write_strings(SF_PRIVATE *psf , int location ) 
{ 
  struct put_buffer buf ;
  char const   *cptr ;
  uint32_t k ;
  uint32_t string_count ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  uint64_t __cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 931
  string_count = (uint32_t )0;
#line 933
  memset((void *)(& buf), 0, sizeof(buf));
#line 935
  k = (uint32_t )0;
  }
  {
#line 935
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 935
    if (! (k < 32U)) {
#line 935
      goto while_break;
    }
#line 936
    if (psf->strings.data[k].type == 0) {
#line 937
      goto while_break;
    }
#line 939
    if (psf->strings.data[k].flags != location) {
#line 940
      goto while_continue;
    }
    {
#line 942
    cptr = psf_get_string(psf, psf->strings.data[k].type);
    }
#line 942
    if ((unsigned long )cptr == (unsigned long )((void *)0)) {
#line 943
      goto while_continue;
    }
#line 946
    if (psf->strings.data[k].type == 1) {
#line 946
      goto case_1;
    }
#line 949
    if (psf->strings.data[k].type == 2) {
#line 949
      goto case_2;
    }
#line 952
    if (psf->strings.data[k].type == 3) {
#line 952
      goto case_3;
    }
#line 955
    if (psf->strings.data[k].type == 4) {
#line 955
      goto case_4;
    }
#line 958
    if (psf->strings.data[k].type == 5) {
#line 958
      goto case_5;
    }
#line 961
    if (psf->strings.data[k].type == 6) {
#line 961
      goto case_6;
    }
#line 964
    if (psf->strings.data[k].type == 7) {
#line 964
      goto case_7;
    }
#line 967
    if (psf->strings.data[k].type == 8) {
#line 967
      goto case_8;
    }
#line 970
    if (psf->strings.data[k].type == 9) {
#line 970
      goto case_9;
    }
#line 973
    if (psf->strings.data[k].type == 16) {
#line 973
      goto case_16;
    }
#line 977
    goto switch_default;
    case_1: 
    {
#line 947
    __cil_tmp8 = put_key_value(& buf, "title", cptr);
#line 947
    string_count += __cil_tmp8;
    }
#line 948
    goto switch_break;
    case_2: 
    {
#line 950
    __cil_tmp9 = put_key_value(& buf, "copyright", cptr);
#line 950
    string_count += __cil_tmp9;
    }
#line 951
    goto switch_break;
    case_3: 
    {
#line 953
    __cil_tmp10 = put_key_value(& buf, "software\230\001", cptr);
#line 953
    string_count += __cil_tmp10;
    }
#line 954
    goto switch_break;
    case_4: 
    {
#line 956
    __cil_tmp11 = put_key_value(& buf, "artist", cptr);
#line 956
    string_count += __cil_tmp11;
    }
#line 957
    goto switch_break;
    case_5: 
    {
#line 959
    __cil_tmp12 = put_key_value(& buf, "comment", cptr);
#line 959
    string_count += __cil_tmp12;
    }
#line 960
    goto switch_break;
    case_6: 
    {
#line 962
    __cil_tmp13 = put_key_value(& buf, "date", cptr);
#line 962
    string_count += __cil_tmp13;
    }
#line 963
    goto switch_break;
    case_7: 
    {
#line 965
    __cil_tmp14 = put_key_value(& buf, "albumU", cptr);
#line 965
    string_count += __cil_tmp14;
    }
#line 966
    goto switch_break;
    case_8: 
    {
#line 968
    __cil_tmp15 = put_key_value(& buf, "license", cptr);
#line 968
    string_count += __cil_tmp15;
    }
#line 969
    goto switch_break;
    case_9: 
    {
#line 971
    __cil_tmp16 = put_key_value(& buf, "tracknumberH\270U", cptr);
#line 971
    string_count += __cil_tmp16;
    }
#line 972
    goto switch_break;
    case_16: 
    {
#line 974
    __cil_tmp17 = put_key_value(& buf, "genreU", cptr);
#line 974
    string_count += __cil_tmp17;
    }
#line 975
    goto switch_break;
    switch_default: 
#line 978
    goto switch_break;
    switch_break: 
#line 935
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 982
  if (string_count == 0U) {
#line 983
    return;
  } else
#line 982
  if (buf.index == 0U) {
#line 983
    return;
  }
  {
#line 985
  __cil_tmp19 = make_size_8((int )(buf.index + 4U));
#line 985
  __cil_tmp20 = make_size_t((int )buf.index);
#line 985
  psf_binheader_writef(psf, "Em84bU", (unsigned int )((105 | (110 << 8)) | (102 << 16)) | (111U << 24),
                       __cil_tmp19, string_count, buf.s, __cil_tmp20);
  }
#line 988
  return;
}
}
#line 992 "/root/patchweave_new/23/src/caf.c"
static int caf_set_chunk(SF_PRIVATE *psf , SF_CHUNK_INFO *chunk_info ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 993
  __cil_tmp3 = psf_save_write_chunk(& psf->wchunks, chunk_info);
  }
#line 993
  return (__cil_tmp3);
}
}
#line 997 "/root/patchweave_new/23/src/caf.c"
static SF_CHUNK_ITERATOR *caf_next_chunk_iterator(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator ) 
{ 
  SF_CHUNK_ITERATOR *__cil_tmp3 ;

  {
  {
#line 998
  __cil_tmp3 = psf_next_chunk_iterator(& psf->rchunks, iterator);
  }
#line 998
  return (__cil_tmp3);
}
}
#line 1002 "/root/patchweave_new/23/src/caf.c"
static int caf_get_chunk_size(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  int indx ;

  {
  {
#line 1005
  indx = psf_find_read_chunk_iterator(& psf->rchunks, iterator);
  }
#line 1005
  if (indx < 0) {
#line 1006
    return (168);
  }
#line 1008
  chunk_info->datalen = (psf->rchunks.chunks + indx)->len;
#line 1010
  return (0);
}
}
#line 1014 "/root/patchweave_new/23/src/caf.c"
static int caf_get_chunk_data(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  int indx ;
  sf_count_t pos ;

  {
  {
#line 1018
  indx = psf_find_read_chunk_iterator(& psf->rchunks, iterator);
  }
#line 1018
  if (indx < 0) {
#line 1019
    return (168);
  }
#line 1021
  if ((unsigned long )chunk_info->data == (unsigned long )((void *)0)) {
#line 1022
    return (171);
  }
  {
#line 1024
  chunk_info->id_size = (psf->rchunks.chunks + indx)->id_size;
#line 1025
  memcpy((void *)(chunk_info->id), (void const   *)((psf->rchunks.chunks + indx)->id),
         sizeof(chunk_info->id) / sizeof(chunk_info->id[0]));
#line 1027
  pos = psf_ftell(psf);
#line 1028
  psf_fseek(psf, (psf->rchunks.chunks + indx)->offset, 0);
#line 1029
  psf_fread(chunk_info->data, (sf_count_t )0, (sf_count_t )1, psf);
#line 1030
  psf_fseek(psf, pos, 0);
  }
#line 1032
  return (0);
}
}
#line 70 "/root/patchweave_new/23/src/avr.c"
static int avr_close(SF_PRIVATE *psf ) ;
#line 72
static int avr_read_header(SF_PRIVATE *psf ) ;
#line 73
static int avr_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 80 "/root/patchweave_new/23/src/avr.c"
int avr_open(SF_PRIVATE *psf ) 
{ 
  int error ;
  int __cil_tmp4 ;

  {
#line 81
  error = 0;
#line 83
  if (psf->file.mode == 16) {
    _L: 
    {
#line 84
    error = avr_read_header(psf);
    }
#line 84
    if (error) {
#line 85
      return (error);
    }
  } else
#line 83
  if (psf->file.mode == 48) {
#line 83
    if (psf->filelength > 0L) {
#line 83
      goto _L;
    }
  }
#line 88
  if ((psf->sf.format & 268369920) != 1179648) {
#line 89
    return (1);
  }
#line 91
  if (psf->file.mode == 32) {
    _L___40: 
    {
#line 92
    psf->endian = 536870912;
#line 94
    __cil_tmp4 = avr_write_header(psf, 0);
    }
#line 94
    if (__cil_tmp4) {
#line 95
      return (psf->error);
    }
#line 97
    psf->write_header = & avr_write_header;
  } else
#line 91
  if (psf->file.mode == 48) {
#line 91
    goto _L___40;
  }
  {
#line 100
  psf->container_close = & avr_close;
#line 102
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 104
  error = pcm_init(psf);
  }
#line 106
  return (error);
}
}
#line 110 "/root/patchweave_new/23/src/avr.c"
static int avr_read_header(SF_PRIVATE *psf ) 
{ 
  AVR_HEADER hdr ;
  char const   *tmp ;
  sf_count_t __cil_tmp4 ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 113
  memset((void *)(& hdr), 0, sizeof(hdr));
#line 115
  psf_binheader_readf(psf, "pmb", 0, & hdr.marker, & hdr.name, sizeof(hdr.name));
#line 116
  psf_log_printf(psf, "%M\n", hdr.marker);
  }
#line 118
  if ((unsigned int )hdr.marker != ((unsigned int )((50 | (66 << 8)) | (73 << 16)) | (84U << 24))) {
#line 119
    return (666);
  }
  {
#line 121
  psf_log_printf(psf, "  Name        : %s\n", hdr.name);
#line 123
  psf_binheader_readf(psf, "E22222", & hdr.mono, & hdr.rez, & hdr.sign, & hdr.loop,
                      & hdr.midi);
#line 125
  psf->sf.channels = ((int )hdr.mono & 1) + 1;
  }
#line 127
  if ((int )hdr.sign) {
#line 127
    tmp = "yes";
  } else {
#line 127
    tmp = "no";
  }
  {
#line 127
  psf_log_printf(psf, "  Channels    : %d\n  Bit width   : %d\n  Signed      : %s\n",
                 ((int )hdr.mono & 1) + 1, (int )hdr.rez, tmp);
  }
#line 131
  if (((int )hdr.rez << 16) + ((int )hdr.sign & 1) == 8 << 16) {
#line 131
    goto case_exp;
  }
#line 136
  if (((int )hdr.rez << 16) + ((int )hdr.sign & 1) == (8 << 16) + 1) {
#line 136
    goto case_exp___0;
  }
#line 141
  if (((int )hdr.rez << 16) + ((int )hdr.sign & 1) == (16 << 16) + 1) {
#line 141
    goto case_exp___1;
  }
#line 146
  goto switch_default;
  case_exp: 
#line 132
  psf->sf.format = 1179653;
#line 133
  psf->bytewidth = 1;
#line 134
  goto switch_break;
  case_exp___0: 
#line 137
  psf->sf.format = 1179649;
#line 138
  psf->bytewidth = 1;
#line 139
  goto switch_break;
  case_exp___1: 
#line 142
  psf->sf.format = 1179650;
#line 143
  psf->bytewidth = 2;
#line 144
  goto switch_break;
  switch_default: 
  {
#line 147
  psf_log_printf(psf, "Error : bad rez/sign combination.\n\311H\270U");
  }
#line 148
  return (666);
  switch_break: 
  {
#line 151
  psf_binheader_readf(psf, "E4444U", & hdr.srate, & hdr.frames, & hdr.lbeg, & hdr.lend);
#line 153
  psf->sf.frames = (sf_count_t )hdr.frames;
#line 154
  psf->sf.samplerate = hdr.srate;
#line 156
  psf_log_printf(psf, "  Frames      : %D\nH\270U", psf->sf.frames);
#line 157
  psf_log_printf(psf, "  Sample rate : %d\nH\270U", psf->sf.samplerate);
#line 159
  psf_binheader_readf(psf, "E222", & hdr.res1, & hdr.res2, & hdr.res3);
#line 160
  psf_binheader_readf(psf, "bb", hdr.ext, sizeof(hdr.ext), hdr.user, sizeof(hdr.user));
#line 162
  psf_log_printf(psf, "  Ext         : %s\n  User        : %s\n", hdr.ext, hdr.user);
#line 164
  psf->endian = 536870912;
#line 166
  psf->dataoffset = (sf_count_t )128;
#line 167
  psf->datalength = (sf_count_t )(hdr.frames * ((int )hdr.rez / 8));
  }
#line 169
  if (psf->fileoffset > 0L) {
#line 170
    psf->filelength = 128L + psf->datalength;
  }
  {
#line 172
  __cil_tmp4 = psf_ftell(psf);
  }
#line 172
  if (__cil_tmp4 != psf->dataoffset) {
    {
#line 173
    __cil_tmp5 = psf_ftell(psf);
#line 173
    psf_binheader_readf(psf, "j", psf->dataoffset - __cil_tmp5);
    }
  }
#line 175
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 177
  if (psf->sf.frames == 0L) {
#line 177
    if (psf->blockwidth) {
#line 178
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    }
  }
#line 180
  return (0);
}
}
#line 184 "/root/patchweave_new/23/src/avr.c"
static int avr_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int sign ;
  size_t __cil_tmp7 ;
  int tmp ;
  int tmp___0 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
#line 188
  if (psf->pipeoffset > 0L) {
#line 189
    return (0);
  }
  {
#line 191
  current = psf_ftell(psf);
  }
#line 193
  if (calc_length) {
    {
#line 194
    psf->filelength = psf_get_filelen(psf);
#line 196
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 197
    if (psf->dataend) {
#line 198
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 200
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
#line 204
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 205
  psf->header.indx = (sf_count_t )0;
#line 211
  if (psf->is_pipe == 0) {
    {
#line 212
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
  {
#line 214
  __cil_tmp7 = make_size_t(8);
  }
#line 214
  if (psf->sf.channels == 2) {
#line 214
    tmp = 65535;
  } else {
#line 214
    tmp = 0;
  }
  {
#line 214
  psf_binheader_writef(psf, "Emz22", (unsigned int )((50 | (66 << 8)) | (73 << 16)) | (84U << 24),
                       __cil_tmp7, tmp, psf->bytewidth * 8);
  }
#line 217
  if ((psf->sf.format & 65535) == 5) {
#line 217
    tmp___0 = 0;
  } else {
#line 217
    tmp___0 = 65535;
  }
  {
#line 217
  sign = tmp___0;
#line 219
  psf_binheader_writef(psf, "E222\270U", sign, 0, 65535);
#line 220
  psf_binheader_writef(psf, "E4444", psf->sf.samplerate, psf->sf.frames, 0, 0);
#line 222
  __cil_tmp10 = make_size_t(20);
#line 222
  __cil_tmp11 = make_size_t(64);
#line 222
  psf_binheader_writef(psf, "E222zz", 0, 0, 0, __cil_tmp10, __cil_tmp11);
#line 225
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 227
  if (psf->error) {
#line 228
    return (psf->error);
  }
#line 230
  psf->dataoffset = psf->header.indx;
#line 232
  if (current > 0L) {
    {
#line 233
    psf_fseek(psf, current, 0);
    }
  }
#line 235
  return (psf->error);
}
}
#line 239 "/root/patchweave_new/23/src/avr.c"
static int avr_close(SF_PRIVATE *psf ) 
{ 


  {
#line 241
  if (psf->file.mode == 32) {
    {
#line 242
    avr_write_header(psf, 1);
    }
  } else
#line 241
  if (psf->file.mode == 48) {
    {
#line 242
    avr_write_header(psf, 1);
    }
  }
#line 244
  return (0);
}
}
#line 93 "/root/patchweave_new/23/src/au.c"
static int au_close(SF_PRIVATE *psf ) ;
#line 95
static int au_format_to_encoding(int format ) ;
#line 97
static int au_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 98
static int au_read_header(SF_PRIVATE *psf ) ;
#line 105 "/root/patchweave_new/23/src/au.c"
int au_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int __cil_tmp5 ;

  {
#line 107
  error = 0;
#line 109
  if (psf->file.mode == 16) {
    _L: 
    {
#line 110
    error = au_read_header(psf);
    }
#line 110
    if (error) {
#line 111
      return (error);
    }
  } else
#line 109
  if (psf->file.mode == 48) {
#line 109
    if (psf->filelength > 0L) {
#line 109
      goto _L;
    }
  }
#line 114
  if ((psf->sf.format & 268369920) != 196608) {
#line 115
    return (1);
  }
#line 117
  subformat = psf->sf.format & 65535;
#line 119
  if (psf->file.mode == 32) {
    _L___41: 
#line 120
    psf->endian = psf->sf.format & 805306368;
#line 121
    if (psf->endian == 805306368) {
#line 122
      psf->endian = 268435456;
    } else
#line 123
    if (psf->endian != 268435456) {
#line 124
      psf->endian = 536870912;
    }
    {
#line 126
    __cil_tmp5 = au_write_header(psf, 0);
    }
#line 126
    if (__cil_tmp5) {
#line 127
      return (psf->error);
    }
#line 129
    psf->write_header = & au_write_header;
  } else
#line 119
  if (psf->file.mode == 48) {
#line 119
    goto _L___41;
  }
#line 132
  psf->container_close = & au_close;
#line 134
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 137
  if (subformat == 16) {
#line 137
    goto case_16;
  }
#line 141
  if (subformat == 1) {
#line 141
    goto case_1;
  }
#line 147
  if (subformat == 4) {
#line 147
    goto case_4;
  }
#line 147
  if (subformat == 3) {
#line 147
    goto case_4;
  }
#line 147
  if (subformat == 2) {
#line 147
    goto case_4;
  }
#line 151
  if (subformat == 17) {
#line 151
    goto case_17;
  }
#line 156
  if (subformat == 6) {
#line 156
    goto case_6;
  }
#line 160
  if (subformat == 7) {
#line 160
    goto case_7;
  }
#line 164
  if (subformat == 48) {
#line 164
    goto case_48;
  }
#line 169
  if (subformat == 49) {
#line 169
    goto case_49;
  }
#line 174
  if (subformat == 50) {
#line 174
    goto case_50;
  }
#line 180
  goto switch_default;
  case_16: 
  {
#line 138
  ulaw_init(psf);
  }
#line 139
  goto switch_break;
  case_1: 
  {
#line 142
  error = pcm_init(psf);
  }
#line 143
  goto switch_break;
  case_4: 
  {
#line 148
  error = pcm_init(psf);
  }
#line 149
  goto switch_break;
  case_17: 
  {
#line 152
  alaw_init(psf);
  }
#line 153
  goto switch_break;
  case_6: 
  {
#line 157
  error = float32_init(psf);
  }
#line 158
  goto switch_break;
  case_7: 
  {
#line 161
  error = double64_init(psf);
  }
#line 162
  goto switch_break;
  case_48: 
  {
#line 165
  error = g72x_init(psf);
#line 166
  psf->sf.seekable = 0;
  }
#line 167
  goto switch_break;
  case_49: 
  {
#line 170
  error = g72x_init(psf);
#line 171
  psf->sf.seekable = 0;
  }
#line 172
  goto switch_break;
  case_50: 
  {
#line 175
  error = g72x_init(psf);
#line 176
  psf->sf.seekable = 0;
  }
#line 177
  goto switch_break;
  switch_default: 
#line 180
  goto switch_break;
  switch_break: ;
#line 183
  return (error);
}
}
#line 190 "/root/patchweave_new/23/src/au.c"
static int au_close(SF_PRIVATE *psf ) 
{ 


  {
#line 192
  if (psf->file.mode == 32) {
    {
#line 193
    au_write_header(psf, 1);
    }
  } else
#line 192
  if (psf->file.mode == 48) {
    {
#line 193
    au_write_header(psf, 1);
    }
  }
#line 195
  return (0);
}
}
#line 199 "/root/patchweave_new/23/src/au.c"
static int au_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int encoding ;
  int datalength ;

  {
#line 203
  if (psf->pipeoffset > 0L) {
#line 204
    return (0);
  }
  {
#line 206
  current = psf_ftell(psf);
  }
#line 208
  if (calc_length) {
    {
#line 209
    psf->filelength = psf_get_filelen(psf);
#line 211
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 212
    if (psf->dataend) {
#line 213
      psf->datalength -= psf->filelength - psf->dataend;
    }
  }
  {
#line 216
  encoding = au_format_to_encoding(psf->sf.format & 65535);
  }
#line 217
  if (! encoding) {
#line 218
    psf->error = 1;
#line 218
    return (psf->error);
  }
#line 221
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 222
  psf->header.indx = (sf_count_t )0;
#line 228
  if (psf->is_pipe == 0) {
    {
#line 229
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
#line 236
  if (psf->datalength < 0L) {
#line 237
    datalength = -1;
  } else
#line 236
  if (psf->datalength > 2147483647L) {
#line 237
    datalength = -1;
  } else {
#line 239
    datalength = (int )(psf->datalength & 2147483647L);
  }
#line 241
  if (psf->endian == 536870912) {
    {
#line 242
    psf_binheader_writef(psf, "Em4", (unsigned int )((46 | (115 << 8)) | (110 << 16)) | (100U << 24),
                         24);
#line 243
    psf_binheader_writef(psf, "E4444U", datalength, encoding, psf->sf.samplerate,
                         psf->sf.channels);
    }
  } else
#line 245
  if (psf->endian == 268435456) {
    {
#line 246
    psf_binheader_writef(psf, "em4", (unsigned int )((100 | (110 << 8)) | (115 << 16)) | (46U << 24),
                         24);
#line 247
    psf_binheader_writef(psf, "e4444", datalength, encoding, psf->sf.samplerate, psf->sf.channels);
    }
  } else {
#line 250
    psf->error = 1;
#line 250
    return (psf->error);
  }
  {
#line 253
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 255
  if (psf->error) {
#line 256
    return (psf->error);
  }
#line 258
  psf->dataoffset = psf->header.indx;
#line 260
  if (current > 0L) {
    {
#line 261
    psf_fseek(psf, current, 0);
    }
  }
#line 263
  return (psf->error);
}
}
#line 267 "/root/patchweave_new/23/src/au.c"
static int au_format_to_encoding(int format ) 
{ 


  {
#line 270
  if (format == 1) {
#line 270
    goto case_1;
  }
#line 271
  if (format == 2) {
#line 271
    goto case_2;
  }
#line 272
  if (format == 3) {
#line 272
    goto case_3;
  }
#line 273
  if (format == 4) {
#line 273
    goto case_4;
  }
#line 275
  if (format == 6) {
#line 275
    goto case_6;
  }
#line 276
  if (format == 7) {
#line 276
    goto case_7;
  }
#line 278
  if (format == 16) {
#line 278
    goto case_16;
  }
#line 279
  if (format == 17) {
#line 279
    goto case_17;
  }
#line 281
  if (format == 48) {
#line 281
    goto case_48;
  }
#line 282
  if (format == 49) {
#line 282
    goto case_49;
  }
#line 283
  if (format == 50) {
#line 283
    goto case_50;
  }
#line 285
  goto switch_default;
  case_1: 
#line 270
  return (2);
  case_2: 
#line 271
  return (3);
  case_3: 
#line 272
  return (4);
  case_4: 
#line 273
  return (5);
  case_6: 
#line 275
  return (6);
  case_7: 
#line 276
  return (7);
  case_16: 
#line 278
  return (1);
  case_17: 
#line 279
  return (27);
  case_48: 
#line 281
  return (23);
  case_49: 
#line 282
  return (25);
  case_50: 
#line 283
  return (26);
  switch_default: 
#line 285
  goto switch_break;
  switch_break: ;
#line 287
  return (0);
}
}
#line 291 "/root/patchweave_new/23/src/au.c"
static int au_read_header(SF_PRIVATE *psf ) 
{ 
  AU_FMT au_fmt ;
  int marker ;
  int dword ;
  sf_count_t __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;

  {
  {
#line 295
  memset((void *)(& au_fmt), 0, sizeof(au_fmt));
#line 296
  psf_binheader_readf(psf, "pm", 0, & marker);
#line 297
  psf_log_printf(psf, "%M\n", marker);
  }
#line 299
  if ((unsigned int )marker == ((unsigned int )((46 | (115 << 8)) | (110 << 16)) | (100U << 24))) {
    {
#line 300
    psf->endian = 536870912;
#line 302
    psf_binheader_readf(psf, "E44444", & au_fmt.dataoffset, & au_fmt.datasize, & au_fmt.encoding,
                        & au_fmt.samplerate, & au_fmt.channels);
    }
  } else
#line 305
  if ((unsigned int )marker == ((unsigned int )((100 | (110 << 8)) | (115 << 16)) | (46U << 24))) {
    {
#line 306
    psf->endian = 268435456;
#line 307
    psf_binheader_readf(psf, "e44444", & au_fmt.dataoffset, & au_fmt.datasize, & au_fmt.encoding,
                        & au_fmt.samplerate, & au_fmt.channels);
    }
  } else {
#line 311
    return (93);
  }
  {
#line 313
  psf_log_printf(psf, "  Data Offset : %d\n", au_fmt.dataoffset);
  }
#line 315
  if (psf->fileoffset > 0L) {
#line 315
    if (au_fmt.datasize == -1) {
      {
#line 316
      psf_log_printf(psf, "  Data Size   : -1\n");
      }
#line 317
      return (94);
    }
  }
#line 320
  if (psf->fileoffset > 0L) {
    {
#line 321
    psf->filelength = (sf_count_t )(au_fmt.dataoffset + au_fmt.datasize);
#line 322
    psf_log_printf(psf, "  Data Size   : %d\nH\270U", au_fmt.datasize);
    }
  } else
#line 324
  if (au_fmt.datasize == -1) {
    {
#line 325
    psf_log_printf(psf, "  Data Size   : %d\nH\270U", au_fmt.datasize);
    }
  } else
#line 324
  if ((long )(au_fmt.dataoffset + au_fmt.datasize) == psf->filelength) {
    {
#line 325
    psf_log_printf(psf, "  Data Size   : %d\nH\270U", au_fmt.datasize);
    }
  } else
#line 326
  if ((long )(au_fmt.dataoffset + au_fmt.datasize) < psf->filelength) {
    {
#line 327
    psf->filelength = (sf_count_t )(au_fmt.dataoffset + au_fmt.datasize);
#line 328
    psf_log_printf(psf, "  Data Size   : %d\nH\270U", au_fmt.datasize);
    }
  } else {
    {
#line 331
    dword = (int )(psf->filelength - (long )au_fmt.dataoffset);
#line 332
    psf_log_printf(psf, "  Data Size   : %d (should be %d)\n", au_fmt.datasize, dword);
#line 333
    au_fmt.datasize = dword;
    }
  }
  {
#line 336
  psf->dataoffset = (sf_count_t )au_fmt.dataoffset;
#line 337
  psf->datalength = psf->filelength - psf->dataoffset;
#line 339
  __cil_tmp5 = psf_ftell(psf);
  }
#line 339
  if (__cil_tmp5 < psf->dataoffset) {
    {
#line 340
    __cil_tmp6 = psf_ftell(psf);
#line 340
    psf_binheader_readf(psf, "j2\347H\270U", psf->dataoffset - __cil_tmp6);
    }
  }
#line 342
  psf->sf.samplerate = au_fmt.samplerate;
#line 343
  psf->sf.channels = au_fmt.channels;
#line 346
  if (psf->endian == 536870912) {
#line 347
    psf->sf.format = 196608;
  } else
#line 348
  if (psf->endian == 268435456) {
#line 349
    psf->sf.format = 268632064;
  }
  {
#line 351
  psf_log_printf(psf, "  Encoding    : %d => ", au_fmt.encoding);
#line 353
  psf->sf.format &= 805306368;
  }
#line 356
  if (au_fmt.encoding == 1) {
#line 356
    goto case_1;
  }
#line 362
  if (au_fmt.encoding == 2) {
#line 362
    goto case_2;
  }
#line 368
  if (au_fmt.encoding == 3) {
#line 368
    goto case_3;
  }
#line 374
  if (au_fmt.encoding == 4) {
#line 374
    goto case_4;
  }
#line 380
  if (au_fmt.encoding == 5) {
#line 380
    goto case_5;
  }
#line 386
  if (au_fmt.encoding == 6) {
#line 386
    goto case_6;
  }
#line 392
  if (au_fmt.encoding == 7) {
#line 392
    goto case_7;
  }
#line 398
  if (au_fmt.encoding == 27) {
#line 398
    goto case_27;
  }
#line 404
  if (au_fmt.encoding == 23) {
#line 404
    goto case_23;
  }
#line 410
  if (au_fmt.encoding == 25) {
#line 410
    goto case_25;
  }
#line 416
  if (au_fmt.encoding == 26) {
#line 416
    goto case_26;
  }
#line 422
  if (au_fmt.encoding == 24) {
#line 422
    goto case_24;
  }
#line 426
  if (au_fmt.encoding == 19) {
#line 426
    goto case_19;
  }
#line 430
  goto switch_default;
  case_1: 
  {
#line 357
  psf->sf.format |= 196624;
#line 358
  psf->bytewidth = 1;
#line 359
  psf_log_printf(psf, "8-bit ISDN u-law\n");
  }
#line 360
  goto switch_break;
  case_2: 
  {
#line 363
  psf->sf.format |= 196609;
#line 364
  psf->bytewidth = 1;
#line 365
  psf_log_printf(psf, "8-bit linear PCM\n");
  }
#line 366
  goto switch_break;
  case_3: 
  {
#line 369
  psf->sf.format |= 196610;
#line 370
  psf->bytewidth = 2;
#line 371
  psf_log_printf(psf, "16-bit linear PCM\n");
  }
#line 372
  goto switch_break;
  case_4: 
  {
#line 375
  psf->sf.format |= 196611;
#line 376
  psf->bytewidth = 3;
#line 377
  psf_log_printf(psf, "24-bit linear PCM\n");
  }
#line 378
  goto switch_break;
  case_5: 
  {
#line 381
  psf->sf.format |= 196612;
#line 382
  psf->bytewidth = 4;
#line 383
  psf_log_printf(psf, "32-bit linear PCM\n");
  }
#line 384
  goto switch_break;
  case_6: 
  {
#line 387
  psf->sf.format |= 196614;
#line 388
  psf->bytewidth = 4;
#line 389
  psf_log_printf(psf, "32-bit float\n");
  }
#line 390
  goto switch_break;
  case_7: 
  {
#line 393
  psf->sf.format |= 196615;
#line 394
  psf->bytewidth = 8;
#line 395
  psf_log_printf(psf, "64-bit double precision float\n");
  }
#line 396
  goto switch_break;
  case_27: 
  {
#line 399
  psf->sf.format |= 196625;
#line 400
  psf->bytewidth = 1;
#line 401
  psf_log_printf(psf, "8-bit ISDN A-law\n");
  }
#line 402
  goto switch_break;
  case_23: 
  {
#line 405
  psf->sf.format |= 196656;
#line 406
  psf->bytewidth = 0;
#line 407
  psf_log_printf(psf, "G721 32kbs ADPCM\n");
  }
#line 408
  goto switch_break;
  case_25: 
  {
#line 411
  psf->sf.format |= 196657;
#line 412
  psf->bytewidth = 0;
#line 413
  psf_log_printf(psf, "G723 24kbs ADPCM\n");
  }
#line 414
  goto switch_break;
  case_26: 
  {
#line 417
  psf->sf.format |= 196658;
#line 418
  psf->bytewidth = 0;
#line 419
  psf_log_printf(psf, "G723 40kbs ADPCM\n");
  }
#line 420
  goto switch_break;
  case_24: 
  {
#line 423
  psf_log_printf(psf, "G722 64 kbs ADPCM (unsupported)\n\220");
  }
#line 424
  goto switch_break;
  case_19: 
  {
#line 427
  psf_log_printf(psf, "Weird NeXT encoding format (unsupported)\n");
  }
#line 428
  goto switch_break;
  switch_default: 
  {
#line 431
  psf_log_printf(psf, "Unknown!!\n");
  }
#line 432
  goto switch_break;
  switch_break: 
  {
#line 435
  psf_log_printf(psf, "  Sample Rate : %d\n", au_fmt.samplerate);
  }
#line 436
  if (au_fmt.channels < 1) {
    {
#line 437
    psf_log_printf(psf, "  Channels    : %d  **** should be >= 1\n\230\001", au_fmt.channels);
    }
#line 438
    return (33);
  } else
#line 440
  if (au_fmt.channels > 1024) {
    {
#line 441
    psf_log_printf(psf, "  Channels    : %d  **** should be <= %d\n", au_fmt.channels,
                   1024);
    }
#line 442
    return (34);
  }
  {
#line 445
  psf_log_printf(psf, "  Channels    : %d\n", au_fmt.channels);
#line 447
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
  }
#line 449
  if (! psf->sf.frames) {
#line 449
    if (psf->blockwidth) {
#line 450
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    }
  }
#line 452
  return (0);
}
}
#line 200 "/root/patchweave_new/23/src/aiff.c"
static int aiff_close(SF_PRIVATE *psf ) ;
#line 202
static int tenbytefloat2int(uint8_t *bytes ) ;
#line 203
static void uint2tenbytefloat(uint32_t num , uint8_t *bytes ) ;
#line 205
static int aiff_read_comm_chunk(SF_PRIVATE *psf , COMM_CHUNK *comm_fmt ) ;
#line 207
static int aiff_read_header(SF_PRIVATE *psf , COMM_CHUNK *comm_fmt ) ;
#line 209
static int aiff_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 210
static int aiff_write_tailer(SF_PRIVATE *psf ) ;
#line 211
static void aiff_write_strings(SF_PRIVATE *psf , int location ) ;
#line 213
static int aiff_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int UNUSED_datasize ) ;
#line 215
static char const   *get_loop_mode_str(int16_t mode ) ;
#line 217
static int16_t get_loop_mode(int16_t mode ) ;
#line 219
static int aiff_read_basc_chunk(SF_PRIVATE *psf , int datasize ) ;
#line 221
static int aiff_read_chanmap(SF_PRIVATE *psf , unsigned int dword ) ;
#line 223
static uint32_t marker_to_position(MARK_ID_POS *m , uint16_t n , int marksize ) ;
#line 225
static int aiff_set_chunk(SF_PRIVATE *psf , SF_CHUNK_INFO *chunk_info ) ;
#line 226
static SF_CHUNK_ITERATOR *aiff_next_chunk_iterator(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator ) ;
#line 227
static int aiff_get_chunk_size(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 228
static int aiff_get_chunk_data(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 235 "/root/patchweave_new/23/src/aiff.c"
int aiff_open(SF_PRIVATE *psf ) 
{ 
  COMM_CHUNK comm_fmt ;
  int error ;
  int subformat ;

  {
  {
#line 239
  memset((void *)(& comm_fmt), 0, sizeof(comm_fmt));
#line 241
  subformat = psf->sf.format & 65535;
#line 243
  psf->container_data = calloc(1UL, sizeof(AIFF_PRIVATE ));
  }
#line 243
  if ((unsigned long )psf->container_data == (unsigned long )((void *)0)) {
#line 244
    return (17);
  }
#line 246
  if (psf->file.mode == 16) {
    _L: 
    {
#line 247
    error = aiff_read_header(psf, & comm_fmt);
    }
#line 247
    if (error) {
#line 248
      return (error);
    }
    {
#line 250
    psf->next_chunk_iterator = & aiff_next_chunk_iterator;
#line 251
    psf->get_chunk_size = & aiff_get_chunk_size;
#line 252
    psf->get_chunk_data = & aiff_get_chunk_data;
#line 254
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 246
  if (psf->file.mode == 48) {
#line 246
    if (psf->filelength > 0L) {
#line 246
      goto _L;
    }
  }
#line 257
  if (psf->file.mode == 32) {
    _L___43: 
#line 258
    if (psf->is_pipe) {
#line 259
      return (29);
    }
#line 261
    if ((psf->sf.format & 268369920) != 131072) {
#line 262
      return (1);
    }
#line 264
    if (psf->file.mode == 32) {
#line 264
      if (subformat == 6) {
        _L___42: 
        {
#line 265
        psf->peak_info = peak_info_calloc(psf->sf.channels);
        }
#line 265
        if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 266
          return (17);
        }
#line 267
        (psf->peak_info)->peak_loc = 42;
      } else
#line 264
      if (subformat == 7) {
#line 264
        goto _L___42;
      }
    }
#line 270
    if (psf->file.mode != 48) {
#line 271
      psf->filelength = (sf_count_t )0;
#line 272
      psf->datalength = (sf_count_t )0;
#line 273
      psf->dataoffset = (sf_count_t )0;
#line 274
      psf->sf.frames = (sf_count_t )0;
    } else
#line 270
    if (psf->filelength < 40L) {
#line 271
      psf->filelength = (sf_count_t )0;
#line 272
      psf->datalength = (sf_count_t )0;
#line 273
      psf->dataoffset = (sf_count_t )0;
#line 274
      psf->sf.frames = (sf_count_t )0;
    }
    {
#line 277
    psf->strings.flags = (uint32_t )768;
#line 279
    error = aiff_write_header(psf, 0);
    }
#line 279
    if (error) {
#line 280
      return (error);
    }
#line 282
    psf->write_header = & aiff_write_header;
#line 283
    psf->set_chunk = & aiff_set_chunk;
  } else
#line 257
  if (psf->file.mode == 48) {
#line 257
    goto _L___43;
  }
#line 286
  psf->container_close = & aiff_close;
#line 287
  psf->command = & aiff_command;
#line 290
  if ((psf->sf.format & 65535) == 5) {
#line 290
    goto case_5;
  }
#line 294
  if ((psf->sf.format & 65535) == 1) {
#line 294
    goto case_1;
  }
#line 300
  if ((psf->sf.format & 65535) == 4) {
#line 300
    goto case_4;
  }
#line 300
  if ((psf->sf.format & 65535) == 3) {
#line 300
    goto case_4;
  }
#line 300
  if ((psf->sf.format & 65535) == 2) {
#line 300
    goto case_4;
  }
#line 304
  if ((psf->sf.format & 65535) == 16) {
#line 304
    goto case_16;
  }
#line 308
  if ((psf->sf.format & 65535) == 17) {
#line 308
    goto case_17;
  }
#line 313
  if ((psf->sf.format & 65535) == 6) {
#line 313
    goto case_6;
  }
#line 317
  if ((psf->sf.format & 65535) == 7) {
#line 317
    goto case_7;
  }
#line 321
  if ((psf->sf.format & 65535) == 64) {
#line 321
    goto case_64;
  }
#line 326
  if ((psf->sf.format & 65535) == 65) {
#line 326
    goto case_65;
  }
#line 332
  if ((psf->sf.format & 65535) == 66) {
#line 332
    goto case_66;
  }
#line 338
  if ((psf->sf.format & 65535) == 67) {
#line 338
    goto case_67;
  }
#line 353
  if ((psf->sf.format & 65535) == 18) {
#line 353
    goto case_18;
  }
#line 362
  if ((psf->sf.format & 65535) == 32) {
#line 362
    goto case_32;
  }
#line 368
  goto switch_default;
  case_5: 
  {
#line 291
  error = pcm_init(psf);
  }
#line 292
  goto switch_break;
  case_1: 
  {
#line 295
  error = pcm_init(psf);
  }
#line 296
  goto switch_break;
  case_4: 
  {
#line 301
  error = pcm_init(psf);
  }
#line 302
  goto switch_break;
  case_16: 
  {
#line 305
  error = ulaw_init(psf);
  }
#line 306
  goto switch_break;
  case_17: 
  {
#line 309
  error = alaw_init(psf);
  }
#line 310
  goto switch_break;
  case_6: 
  {
#line 314
  error = float32_init(psf);
  }
#line 315
  goto switch_break;
  case_7: 
  {
#line 318
  error = double64_init(psf);
  }
#line 319
  goto switch_break;
  case_64: 
#line 322
  if (psf->sf.frames > (long )comm_fmt.numSampleFrames) {
#line 323
    psf->sf.frames = (sf_count_t )comm_fmt.numSampleFrames;
  }
#line 324
  goto switch_break;
  case_65: 
  {
#line 327
  error = dwvw_init(psf, 16);
  }
#line 328
  if (psf->sf.frames > (long )comm_fmt.numSampleFrames) {
#line 329
    psf->sf.frames = (sf_count_t )comm_fmt.numSampleFrames;
  }
#line 330
  goto switch_break;
  case_66: 
  {
#line 333
  error = dwvw_init(psf, 24);
  }
#line 334
  if (psf->sf.frames > (long )comm_fmt.numSampleFrames) {
#line 335
    psf->sf.frames = (sf_count_t )comm_fmt.numSampleFrames;
  }
#line 336
  goto switch_break;
  case_67: 
#line 339
  if (psf->file.mode != 16) {
#line 340
    error = 139;
#line 341
    goto switch_break;
  }
#line 343
  if ((int )comm_fmt.sampleSize >= 8) {
#line 343
    if ((int )comm_fmt.sampleSize < 24) {
      {
#line 344
      error = dwvw_init(psf, (int )comm_fmt.sampleSize);
      }
#line 345
      if (psf->sf.frames > (long )comm_fmt.numSampleFrames) {
#line 346
        psf->sf.frames = (sf_count_t )comm_fmt.numSampleFrames;
      }
#line 347
      goto switch_break;
    }
  }
  {
#line 349
  psf_log_printf(psf, "AIFC/DWVW : Bad bitwidth %d\n", (int )comm_fmt.sampleSize);
#line 350
  error = 139;
  }
#line 351
  goto switch_break;
  case_18: 
  {
#line 358
  error = aiff_ima_init(psf, 34, 64);
  }
#line 359
  goto switch_break;
  case_32: 
  {
#line 363
  error = gsm610_init(psf);
  }
#line 364
  if (psf->sf.frames > (long )comm_fmt.numSampleFrames) {
#line 365
    psf->sf.frames = (sf_count_t )comm_fmt.numSampleFrames;
  }
#line 366
  goto switch_break;
  switch_default: 
#line 368
  return (18);
  switch_break: ;
#line 371
  if (psf->file.mode != 32) {
#line 371
    if (psf->sf.frames - (long )comm_fmt.numSampleFrames != 0L) {
      {
#line 372
      psf_log_printf(psf, "*** Frame count read from \'COMM\' chunk (%u) not equal to frame count\n*** calculated from length of \'SSND\' chunk (%u).\n",
                     comm_fmt.numSampleFrames, (uint32_t )psf->sf.frames);
      }
    }
  }
#line 378
  return (error);
}
}
#line 387 "/root/patchweave_new/23/src/aiff.c"
static uint32_t marker_to_position(MARK_ID_POS *m , uint16_t n , int marksize ) 
{ 
  int i ;

  {
#line 390
  i = 0;
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;

#line 390
    if (! (i < marksize)) {
#line 390
      goto while_break;
    }
#line 391
    if ((int )(m + i)->markerID == (int )n) {
#line 392
      return ((m + i)->position);
    }
#line 390
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 393
  return ((uint32_t )0);
}
}
#line 397 "/root/patchweave_new/23/src/aiff.c"
static int aiff_read_header(SF_PRIVATE *psf , COMM_CHUNK *comm_fmt ) 
{ 
  SSND_CHUNK ssnd_fmt ;
  AIFF_PRIVATE *paiff ;
  BUF_UNION ubuf ;
  uint32_t chunk_size ;
  uint32_t FORMsize ;
  uint32_t SSNDsize ;
  uint32_t bytesread ;
  uint32_t mark_count ;
  int k ;
  int found_chunk ;
  int done ;
  int error ;
  char *cptr ;
  int instr_found ;
  int mark_found ;
  unsigned int marker ;
  size_t jump ;
  sf_count_t pos ;
  sf_count_t __cil_tmp21 ;
  sf_count_t __cil_tmp22 ;
  int tmp ;
  sf_count_t __cil_tmp24 ;
  float value___0 ;
  uint32_t position ;
  int tmp___0 ;
  sf_count_t __cil_tmp31 ;
  uint16_t count___0 ;
  uint16_t id ;
  uint16_t len ;
  uint32_t timestamp ;
  uint32_t bytes ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  unsigned int appl_marker ;
  int __cil_tmp43 ;
  uint8_t bytes___0[6] ;
  int16_t gain ;
  int16_t mode ;
  char const   *loop_mode ;
  uint16_t begin ;
  uint16_t end ;
  uint16_t mark_id ;
  uint16_t n ;
  uint32_t position___0 ;
  int __cil_tmp61 ;
  uint32_t pstr_len ;
  uint8_t ch ;
  int __cil_tmp66 ;
  int tmp___1 ;
  int __cil_tmp68 ;
  uint32_t read_len ;
  int __cil_tmp70 ;
  size_t __cil_tmp73 ;
  sf_count_t __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  sf_count_t __cil_tmp80 ;
  sf_count_t __cil_tmp81 ;
  sf_count_t __cil_tmp82 ;
  sf_count_t __cil_tmp83 ;
  int ji ;
  int str_index ;
  uint32_t j ;
  void *tmp___2 ;

  {
#line 401
  chunk_size = (uint32_t )0;
#line 401
  mark_count = (uint32_t )0;
#line 402
  found_chunk = 0;
#line 402
  done = 0;
#line 402
  error = 0;
#line 404
  instr_found = 0;
#line 404
  mark_found = 0;
#line 406
  if (psf->filelength > 4294967295L) {
    {
#line 407
    psf_log_printf(psf, "Warning : filelength > 0xffffffff. This is bad!!!!\n");
    }
  }
#line 409
  paiff = (AIFF_PRIVATE *)psf->container_data;
#line 409
  if ((unsigned long )paiff == (unsigned long )((void *)0)) {
#line 410
    return (30);
  }
  {
#line 412
  paiff->comm_offset = (sf_count_t )0;
#line 413
  paiff->ssnd_offset = (sf_count_t )0;
#line 416
  psf_binheader_readf(psf, "p\344\005I\270U", 0);
#line 418
  memset((void *)comm_fmt, 0, sizeof(COMM_CHUNK ));
#line 421
  psf->endian = 536870912;
  }
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;

#line 427
    if (! (! done)) {
#line 427
      goto while_break;
    }
    {
#line 429
    jump = (size_t )(chunk_size & 1U);
#line 431
    chunk_size = (uint32_t )0;
#line 431
    marker = chunk_size;
#line 432
    psf_binheader_readf(psf, "Ejm4", jump, & marker, & chunk_size);
    }
#line 433
    if (marker == 0U) {
      {
#line 434
      __cil_tmp21 = psf_ftell(psf);
#line 434
      pos = __cil_tmp21;
#line 435
      psf_log_printf(psf, "Have 0 marker at position %D (0x%x).\nU", pos, pos);
      }
#line 436
      goto while_break;
    }
#line 439
    if (psf->file.mode == 48) {
#line 439
      if (found_chunk & 32) {
#line 440
        return (91);
      }
    }
    {
#line 442
    __cil_tmp22 = psf_ftell(psf);
#line 442
    psf_store_read_chunk_u32(& psf->rchunks, marker, __cil_tmp22, chunk_size);
    }
#line 445
    if (marker == ((unsigned int )((70 | (79 << 8)) | (82 << 16)) | (77U << 24))) {
#line 445
      goto case_exp;
    }
#line 455
    if (marker == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
#line 455
      goto case_exp___0;
    }
#line 455
    if (marker == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24))) {
#line 455
      goto case_exp___0;
    }
#line 479
    if (marker == ((unsigned int )((67 | (79 << 8)) | (77 << 16)) | (77U << 24))) {
#line 479
      goto case_exp___2;
    }
#line 489
    if (marker == ((unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24))) {
#line 489
      goto case_exp___3;
    }
#line 533
    if (marker == ((unsigned int )((83 | (83 << 8)) | (78 << 16)) | (68U << 24))) {
#line 533
      goto case_exp___4;
    }
#line 578
    if (marker == ((unsigned int )((40 | (99 << 8)) | (41 << 16)) | (32U << 24))) {
#line 578
      goto case_exp___5;
    }
#line 597
    if (marker == ((unsigned int )((65 | (85 << 8)) | (84 << 16)) | (72U << 24))) {
#line 597
      goto case_exp___6;
    }
#line 613
    if (marker == ((unsigned int )((67 | (79 << 8)) | (77 << 16)) | (84U << 24))) {
#line 613
      goto case_exp___7;
    }
#line 643
    if (marker == ((unsigned int )((65 | (80 << 8)) | (80 << 16)) | (76U << 24))) {
#line 643
      goto case_exp___8;
    }
#line 676
    if (marker == ((unsigned int )((78 | (65 << 8)) | (77 << 16)) | (69U << 24))) {
#line 676
      goto case_exp___9;
    }
#line 692
    if (marker == ((unsigned int )((65 | (78 << 8)) | (78 << 16)) | (79U << 24))) {
#line 692
      goto case_exp___10;
    }
#line 708
    if (marker == ((unsigned int )((73 | (78 << 8)) | (83 << 16)) | (84U << 24))) {
#line 708
      goto case_exp___11;
    }
#line 774
    if (marker == ((unsigned int )((98 | (97 << 8)) | (115 << 16)) | (99U << 24))) {
#line 774
      goto case_exp___12;
    }
#line 781
    if (marker == ((unsigned int )((77 | (65 << 8)) | (82 << 16)) | (75U << 24))) {
#line 781
      goto case_exp___13;
    }
#line 850
    if (marker == ((unsigned int )((70 | (86 << 8)) | (69 << 16)) | (82U << 24))) {
#line 850
      goto case_exp___14;
    }
#line 854
    if (marker == ((unsigned int )((83 | (70 << 8)) | (88 << 16)) | (33U << 24))) {
#line 854
      goto case_exp___15;
    }
#line 859
    if (marker == ((unsigned int )((78 | (79 << 8)) | (78 << 16)) | (69U << 24))) {
#line 859
      goto case_exp___16;
    }
#line 866
    if (marker == ((unsigned int )((67 | (72 << 8)) | (65 << 16)) | (78U << 24))) {
#line 866
      goto case_exp___17;
    }
#line 879
    goto switch_default___0;
    case_exp: 
#line 446
    if (found_chunk) {
#line 447
      return (80);
    }
    {
#line 449
    FORMsize = chunk_size;
#line 451
    found_chunk |= 1;
#line 452
    psf_binheader_readf(psf, "m", & marker);
    }
#line 455
    if (marker == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
#line 455
      goto case_exp___0;
    }
#line 455
    if (marker == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24))) {
#line 455
      goto case_exp___0;
    }
#line 458
    goto switch_default;
    case_exp___0: 
#line 456
    if (marker == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24))) {
#line 456
      tmp = 6;
    } else {
#line 456
      tmp = 2;
    }
#line 456
    found_chunk |= tmp;
#line 457
    goto switch_break___0;
    switch_default: 
#line 459
    goto switch_break___0;
    switch_break___0: ;
#line 462
    if (psf->fileoffset > 0L) {
#line 462
      if (psf->filelength > (long )(FORMsize + 8U)) {
        {
#line 464
        psf->filelength = (sf_count_t )(FORMsize + 8U);
#line 465
        psf_log_printf(psf, "FORM : %u\n %M\n", FORMsize, marker);
        }
      } else {
#line 462
        goto _L;
      }
    } else
    _L: 
#line 467
    if ((long )FORMsize != psf->filelength - (long )(2 * (int )sizeof(chunk_size))) {
      {
#line 468
      chunk_size = (uint32_t )((unsigned long )psf->filelength - 2UL * sizeof(chunk_size));
#line 469
      psf_log_printf(psf, "FORM : %u (should be %u)\n %M\nU", FORMsize, chunk_size,
                     marker);
#line 470
      FORMsize = chunk_size;
      }
    } else {
      {
#line 473
      psf_log_printf(psf, "FORM : %u\n %M\n", FORMsize, marker);
      }
    }
#line 475
    chunk_size = (uint32_t )0;
#line 476
    goto switch_break;
    case_exp___2: 
    {
#line 480
    __cil_tmp24 = psf_ftell(psf);
#line 480
    paiff->comm_offset = __cil_tmp24 - 8L;
#line 481
    chunk_size += chunk_size & 1U;
#line 482
    comm_fmt->size = chunk_size;
#line 483
    error = aiff_read_comm_chunk(psf, comm_fmt);
    }
#line 483
    if (error != 0) {
#line 484
      return (error);
    }
#line 486
    found_chunk |= 16;
#line 487
    goto switch_break;
    case_exp___3: 
#line 491
    if ((found_chunk & 19) != 19) {
#line 492
      return (87);
    }
    {
#line 494
    psf_log_printf(psf, "%M : %d\n\230\001", marker, chunk_size);
    }
#line 495
    if ((unsigned long )chunk_size != 2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int ))) {
      {
#line 496
      psf_binheader_readf(psf, "j@\006I\270U", chunk_size);
#line 497
      psf_log_printf(psf, "*** File PEAK chunk too big.\nU");
      }
#line 498
      return (68);
    }
    {
#line 501
    psf->peak_info = peak_info_calloc(psf->sf.channels);
    }
#line 501
    if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 502
      return (17);
    }
    {
#line 505
    psf_binheader_readf(psf, "E44I\270U", & (psf->peak_info)->version, & (psf->peak_info)->timestamp);
    }
#line 507
    if ((psf->peak_info)->version != 1U) {
      {
#line 508
      psf_log_printf(psf, "  version    : %d *** (should be version 1)\n\270U", (psf->peak_info)->version);
      }
    } else {
      {
#line 510
      psf_log_printf(psf, "  version    : %d\n\006I\270U", (psf->peak_info)->version);
      }
    }
    {
#line 512
    psf_log_printf(psf, "  time stamp : %d\n\005I\270U", (psf->peak_info)->timestamp);
#line 513
    psf_log_printf(psf, "    Ch   Position       Value\n");
#line 515
    cptr = ubuf.cbuf;
#line 516
    k = 0;
    }
    {
#line 516
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 516
      if (! (k < psf->sf.channels)) {
#line 516
        goto while_break___0;
      }
      {
#line 520
      psf_binheader_readf(psf, "Ef4", & value___0, & position);
#line 521
      (psf->peak_info)->peaks[k].value = (double )value___0;
#line 522
      (psf->peak_info)->peaks[k].position = (sf_count_t )position;
#line 524
      snprintf(cptr, sizeof(ubuf.scbuf), "    %2d   %-12ld   %g\n", k, (psf->peak_info)->peaks[k].position,
               (psf->peak_info)->peaks[k].value);
#line 526
      *(cptr + (sizeof(ubuf.scbuf) - 1UL)) = (char)0;
#line 527
      psf_log_printf(psf, "%s", cptr);
#line 516
      k ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: ;
#line 530
    if ((found_chunk & 32) == 0) {
#line 530
      tmp___0 = 42;
    } else {
#line 530
      tmp___0 = 43;
    }
#line 530
    (psf->peak_info)->peak_loc = tmp___0;
#line 531
    goto switch_break;
    case_exp___4: 
#line 534
    if (found_chunk & 4) {
#line 534
      if ((found_chunk & 8) == 0) {
        {
#line 535
        psf_log_printf(psf, "*** Valid AIFC files should have an FVER chunk.\n\220");
        }
      }
    }
    {
#line 537
    __cil_tmp31 = psf_ftell(psf);
#line 537
    paiff->ssnd_offset = __cil_tmp31 - 8L;
#line 538
    SSNDsize = chunk_size;
#line 539
    psf_binheader_readf(psf, "E44", & ssnd_fmt.offset, & ssnd_fmt.blocksize);
#line 541
    psf->datalength = (sf_count_t )((unsigned long )SSNDsize - sizeof(ssnd_fmt));
#line 542
    psf->dataoffset = psf_ftell(psf);
    }
#line 544
    if (psf->datalength > psf->filelength - psf->dataoffset) {
      {
#line 545
      psf_log_printf(psf, " SSND : %u (should be %D)\n", SSNDsize, (unsigned long )(psf->filelength - psf->dataoffset) + sizeof(SSND_CHUNK ));
#line 546
      psf->datalength = psf->filelength - psf->dataoffset;
      }
    } else
#line 544
    if (psf->datalength < 0L) {
      {
#line 545
      psf_log_printf(psf, " SSND : %u (should be %D)\n", SSNDsize, (unsigned long )(psf->filelength - psf->dataoffset) + sizeof(SSND_CHUNK ));
#line 546
      psf->datalength = psf->filelength - psf->dataoffset;
      }
    } else {
      {
#line 549
      psf_log_printf(psf, " SSND : %u\n", SSNDsize);
      }
    }
#line 551
    if (ssnd_fmt.offset == 0U) {
      {
#line 552
      psf_log_printf(psf, "  Offset     : %u\n", ssnd_fmt.offset);
#line 553
      psf_log_printf(psf, "  Block Size : %u\n", ssnd_fmt.blocksize);
#line 555
      psf->dataoffset += (long )ssnd_fmt.offset;
#line 556
      psf->datalength -= (long )ssnd_fmt.offset;
      }
    } else
#line 551
    if (psf->dataoffset + (long )ssnd_fmt.offset == (long )ssnd_fmt.blocksize) {
      {
#line 552
      psf_log_printf(psf, "  Offset     : %u\n", ssnd_fmt.offset);
#line 553
      psf_log_printf(psf, "  Block Size : %u\n", ssnd_fmt.blocksize);
#line 555
      psf->dataoffset += (long )ssnd_fmt.offset;
#line 556
      psf->datalength -= (long )ssnd_fmt.offset;
      }
    } else {
      {
#line 559
      psf_log_printf(psf, "  Offset     : %u\n", ssnd_fmt.offset);
#line 560
      psf_log_printf(psf, "  Block Size : %u ???\n", ssnd_fmt.blocksize);
#line 561
      psf->dataoffset += (long )ssnd_fmt.offset;
#line 562
      psf->datalength -= (long )ssnd_fmt.offset;
      }
    }
#line 566
    if (psf->datalength + psf->dataoffset < psf->filelength) {
#line 567
      psf->dataend = psf->datalength + psf->dataoffset;
    }
#line 569
    found_chunk |= 32;
#line 571
    if (! psf->sf.seekable) {
#line 572
      goto switch_break;
    }
    {
#line 575
    psf_fseek(psf, psf->dataoffset + psf->datalength, 0);
    }
#line 576
    goto switch_break;
    case_exp___5: 
#line 579
    if (chunk_size == 0U) {
#line 580
      goto switch_break;
    }
#line 581
    if (chunk_size >= (unsigned int )((int )sizeof(ubuf.scbuf))) {
      {
#line 582
      psf_log_printf(psf, " %M : %d (too big)\n", marker, chunk_size);
      }
#line 583
      return (30);
    }
    {
#line 586
    cptr = ubuf.cbuf;
#line 587
    psf_binheader_readf(psf, "b", cptr, chunk_size + (chunk_size & 1U));
#line 588
    *(cptr + chunk_size) = (char)0;
#line 590
    psf_sanitize_string(cptr, (int )chunk_size);
#line 592
    psf_log_printf(psf, " %M : %s\n", marker, cptr);
#line 593
    psf_store_string(psf, 2, (char const   *)cptr);
#line 594
    chunk_size += chunk_size & 1U;
    }
#line 595
    goto switch_break;
    case_exp___6: 
#line 598
    if (chunk_size == 0U) {
#line 599
      goto switch_break;
    }
#line 600
    if (chunk_size >= (unsigned int )((int )sizeof(ubuf.scbuf) - 1)) {
      {
#line 601
      psf_log_printf(psf, " %M : %d (too big)\n", marker, chunk_size);
      }
#line 602
      return (30);
    }
    {
#line 605
    cptr = ubuf.cbuf;
#line 606
    psf_binheader_readf(psf, "b", cptr, chunk_size + (chunk_size & 1U));
#line 607
    *(cptr + chunk_size) = (char)0;
#line 608
    psf_log_printf(psf, " %M : %s\n", marker, cptr);
#line 609
    psf_store_string(psf, 4, (char const   *)cptr);
#line 610
    chunk_size += chunk_size & 1U;
    }
#line 611
    goto switch_break;
    case_exp___7: 
#line 617
    if (chunk_size == 0U) {
#line 618
      goto switch_break;
    }
    {
#line 619
    bytes = chunk_size;
#line 620
    __cil_tmp38 = psf_binheader_readf(psf, "E2", & count___0);
#line 620
    bytes -= (unsigned int )__cil_tmp38;
#line 621
    psf_log_printf(psf, " %M : %d\n  count  : %d\n", marker, chunk_size, (int )count___0);
#line 623
    k = 0;
    }
    {
#line 623
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 623
      if (! (k < (int )count___0)) {
#line 623
        goto while_break___1;
      }
      {
#line 624
      __cil_tmp39 = psf_binheader_readf(psf, "E422", & timestamp, & id, & len);
#line 624
      bytes -= (unsigned int )__cil_tmp39;
#line 625
      psf_log_printf(psf, "   time   : 0x%x\n   marker : %x\n   length : %d\n", timestamp,
                     (int )id, (int )len);
      }
#line 627
      if ((int )len + 1 > (int )sizeof(ubuf.scbuf)) {
        {
#line 628
        psf_log_printf(psf, "\nError : string length (%d) too big.\n", (int )len);
        }
#line 629
        return (30);
      }
      {
#line 632
      cptr = ubuf.cbuf;
#line 633
      __cil_tmp40 = psf_binheader_readf(psf, "b", cptr, (int )len);
#line 633
      bytes -= (unsigned int )__cil_tmp40;
#line 634
      *(cptr + (int )len) = (char)0;
#line 635
      psf_log_printf(psf, "   string : %s\n", cptr);
#line 623
      k ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___1: ;
#line 638
    if (bytes > 0U) {
      {
#line 639
      psf_binheader_readf(psf, "j", bytes);
      }
    }
#line 641
    goto switch_break;
    case_exp___8: 
#line 646
    if (chunk_size == 0U) {
#line 647
      goto switch_break;
    }
#line 648
    if (chunk_size >= (unsigned int )((int )sizeof(ubuf.scbuf) - 1)) {
      {
#line 649
      psf_log_printf(psf, " %M : %u (too big, skipping)\n", marker, chunk_size);
#line 650
      psf_binheader_readf(psf, "j", chunk_size + (chunk_size & 1U));
      }
#line 651
      goto switch_break;
    }
#line 654
    if (chunk_size < 4U) {
      {
#line 655
      psf_log_printf(psf, " %M : %d (too small, skipping)\n", marker, chunk_size);
#line 656
      psf_binheader_readf(psf, "j", chunk_size + (chunk_size & 1U));
      }
#line 657
      goto switch_break;
    }
    {
#line 660
    cptr = ubuf.cbuf;
#line 661
    psf_binheader_readf(psf, "mb", & appl_marker, cptr, (chunk_size + (chunk_size & 1U)) - 4U);
#line 662
    *(cptr + chunk_size) = (char)0;
#line 664
    k = 0;
    }
    {
#line 664
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 664
      if (! (k < (int )chunk_size)) {
#line 664
        goto while_break___2;
      }
      {
#line 665
      __cil_tmp43 = psf_isprint((int )*(cptr + k));
      }
#line 665
      if (! __cil_tmp43) {
#line 666
        *(cptr + k) = (char)0;
#line 667
        goto while_break___2;
      }
#line 664
      k ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 670
    psf_log_printf(psf, " %M : %d\n  AppSig : %M\n  Name   : %s\n", marker, chunk_size,
                   appl_marker, cptr);
#line 671
    psf_store_string(psf, 3, (char const   *)cptr);
#line 672
    chunk_size += chunk_size & 1U;
    }
#line 674
    goto switch_break;
    case_exp___9: 
#line 677
    if (chunk_size == 0U) {
#line 678
      goto switch_break;
    }
#line 679
    if (chunk_size >= (unsigned int )((int )sizeof(ubuf.scbuf) - 2)) {
      {
#line 680
      psf_log_printf(psf, " %M : %d (too big)\n", marker, chunk_size);
      }
#line 681
      return (30);
    }
    {
#line 684
    cptr = ubuf.cbuf;
#line 685
    psf_binheader_readf(psf, "b", cptr, chunk_size + (chunk_size & 1U));
#line 686
    *(cptr + chunk_size) = (char)0;
#line 687
    psf_log_printf(psf, " %M : %s\n", marker, cptr);
#line 688
    psf_store_string(psf, 1, (char const   *)cptr);
#line 689
    chunk_size += chunk_size & 1U;
    }
#line 690
    goto switch_break;
    case_exp___10: 
#line 693
    if (chunk_size == 0U) {
#line 694
      goto switch_break;
    }
#line 695
    if (chunk_size >= (unsigned int )((int )sizeof(ubuf.scbuf) - 2)) {
      {
#line 696
      psf_log_printf(psf, " %M : %d (too big)\n", marker, chunk_size);
      }
#line 697
      return (30);
    }
    {
#line 700
    cptr = ubuf.cbuf;
#line 701
    psf_binheader_readf(psf, "b", cptr, chunk_size + (chunk_size & 1U));
#line 702
    *(cptr + chunk_size) = (char)0;
#line 703
    psf_log_printf(psf, " %M : %s\n", marker, cptr);
#line 704
    psf_store_string(psf, 5, (char const   *)cptr);
#line 705
    chunk_size += chunk_size & 1U;
    }
#line 706
    goto switch_break;
    case_exp___11: 
#line 709
    if (chunk_size != 20U) {
      {
#line 710
      psf_log_printf(psf, " %M : %d (should be %d)\n\230\001", marker, chunk_size,
                     20);
#line 711
      psf_binheader_readf(psf, "j", chunk_size);
      }
#line 712
      goto switch_break;
    }
    {
#line 714
    psf_log_printf(psf, " %M : %d\n", marker, chunk_size);
#line 718
    psf->instrument = psf_instrument_alloc();
    }
#line 718
    if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 718
      if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 719
        return (17);
      }
    }
    {
#line 721
    psf_binheader_readf(psf, "b", bytes___0, 6);
#line 722
    psf_log_printf(psf, "  Base Note : %u\n  Detune    : %u\n  Low  Note : %u\n  High Note : %u\n  Low  Vel. : %u\n  High Vel. : %u\n",
                   (int )bytes___0[0], (int )bytes___0[1], (int )bytes___0[2], (int )bytes___0[3],
                   (int )bytes___0[4], (int )bytes___0[5]);
#line 726
    (psf->instrument)->basenote = (char )bytes___0[0];
#line 727
    (psf->instrument)->detune = (char )bytes___0[1];
#line 728
    (psf->instrument)->key_lo = (char )bytes___0[2];
#line 729
    (psf->instrument)->key_hi = (char )bytes___0[3];
#line 730
    (psf->instrument)->velocity_lo = (char )bytes___0[4];
#line 731
    (psf->instrument)->velocity_hi = (char )bytes___0[5];
#line 732
    psf_binheader_readf(psf, "E2", & gain);
#line 733
    (psf->instrument)->gain = (int )gain;
#line 734
    psf_log_printf(psf, "  Gain (dB) : %d\n", (int )gain);
#line 740
    psf_binheader_readf(psf, "E222", & mode, & begin, & end);
#line 741
    loop_mode = get_loop_mode_str(mode);
#line 742
    mode = get_loop_mode(mode);
    }
#line 743
    if ((int )mode == 800) {
#line 744
      (psf->instrument)->loop_count = 0;
#line 745
      (psf->instrument)->loops[0].mode = 800;
    } else {
#line 748
      (psf->instrument)->loop_count = 1;
#line 749
      (psf->instrument)->loops[0].mode = 801;
#line 750
      (psf->instrument)->loops[0].start = (uint32_t )begin;
#line 751
      (psf->instrument)->loops[0].end = (uint32_t )end;
#line 752
      (psf->instrument)->loops[0].count = (uint32_t )0;
    }
    {
#line 754
    psf_log_printf(psf, "  Sustain\n   mode  : %d => %s\n   begin : %u\n   end   : %u\n",
                   (int )mode, loop_mode, (int )begin, (int )end);
#line 756
    psf_binheader_readf(psf, "E222", & mode, & begin, & end);
#line 757
    loop_mode = get_loop_mode_str(mode);
#line 758
    mode = get_loop_mode(mode);
    }
#line 759
    if ((int )mode == 800) {
#line 760
      (psf->instrument)->loops[1].mode = 800;
    } else {
#line 762
      ((psf->instrument)->loop_count) ++;
#line 763
      (psf->instrument)->loops[1].mode = 801;
#line 764
      (psf->instrument)->loops[1].start = (uint32_t )begin;
#line 765
      (psf->instrument)->loops[1].end = (uint32_t )end;
#line 766
      (psf->instrument)->loops[1].count = (uint32_t )0;
    }
    {
#line 768
    psf_log_printf(psf, "  Release\n   mode  : %d => %s\n   begin : %u\n   end   : %u\n",
                   (int )mode, loop_mode, (int )begin, (int )end);
#line 771
    instr_found ++;
    }
#line 772
    goto switch_break;
    case_exp___12: 
    {
#line 775
    psf_log_printf(psf, " basc : %u\n", chunk_size);
#line 777
    error = aiff_read_basc_chunk(psf, (int )chunk_size);
    }
#line 777
    if (error) {
#line 778
      return (error);
    }
#line 779
    goto switch_break;
    case_exp___13: 
    {
#line 782
    psf_log_printf(psf, " %M : %d\n", marker, chunk_size);
#line 783
    n = (uint16_t )0;
#line 786
    __cil_tmp61 = psf_binheader_readf(psf, "E2", & n);
#line 786
    bytesread = (uint32_t )__cil_tmp61;
#line 787
    mark_count = (uint32_t )n;
#line 788
    psf_log_printf(psf, "  Count : %u\n", mark_count);
    }
#line 789
    if ((unsigned long )paiff->markstr != (unsigned long )((void *)0)) {
      {
#line 790
      psf_log_printf(psf, "*** Second MARK chunk found. Throwing away the first.\n");
#line 791
      free((void *)paiff->markstr);
      }
    }
    {
#line 793
    tmp___2 = calloc((unsigned long )mark_count, sizeof(MARK_ID_POS ));
#line 793
    paiff->markstr = (MARK_ID_POS *)tmp___2;
    }
#line 794
    if ((unsigned long )paiff->markstr == (unsigned long )((void *)0)) {
#line 795
      return (17);
    }
#line 797
    if (mark_count > 1000U) {
      {
#line 798
      psf_log_printf(psf, "  More than 1000 markers, skipping!\n");
#line 799
      psf_binheader_readf(psf, "j", chunk_size - bytesread);
      }
#line 800
      goto switch_break;
    }
    {
#line 803
    psf->cues = psf_cues_alloc(mark_count);
    }
#line 803
    if ((unsigned long )psf->cues == (unsigned long )((void *)0)) {
#line 804
      return (17);
    }
#line 806
    n = (uint16_t )0;
    {
#line 806
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 806
      if ((unsigned int )n < mark_count) {
#line 806
        if (! (bytesread < chunk_size)) {
#line 806
          goto while_break___3;
        }
      } else {
#line 806
        goto while_break___3;
      }
      {
#line 810
      __cil_tmp66 = psf_binheader_readf(psf, "E241", & mark_id, & position___0, & ch);
#line 810
      bytesread += (unsigned int )__cil_tmp66;
#line 811
      psf_log_printf(psf, "   Mark ID  : %u\n   Position : %u\n", (int )mark_id, position___0);
#line 813
      (psf->cues)->cue_points[n].indx = (int32_t )mark_id;
#line 814
      (psf->cues)->cue_points[n].position = (uint32_t )0;
#line 815
      (psf->cues)->cue_points[n].fcc_chunk = (int32_t )((unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24));
#line 816
      (psf->cues)->cue_points[n].chunk_start = 0;
#line 817
      (psf->cues)->cue_points[n].block_start = 0;
#line 818
      (psf->cues)->cue_points[n].sample_offset = position___0;
      }
#line 820
      if ((int )ch & 1) {
#line 820
        tmp___1 = (int )ch;
      } else {
#line 820
        tmp___1 = (int )ch + 1;
      }
#line 820
      pstr_len = (uint32_t )tmp___1;
#line 822
      if ((unsigned long )pstr_len < sizeof(ubuf.scbuf) - 1UL) {
        {
#line 823
        __cil_tmp68 = psf_binheader_readf(psf, "b", ubuf.scbuf, pstr_len);
#line 823
        bytesread += (unsigned int )__cil_tmp68;
#line 824
        ubuf.scbuf[pstr_len] = (signed char)0;
        }
      } else {
        {
#line 827
        read_len = (uint32_t )((unsigned long )pstr_len - (sizeof(ubuf.scbuf) - 1UL));
#line 828
        __cil_tmp70 = psf_binheader_readf(psf, "bj", ubuf.scbuf, read_len, pstr_len - read_len);
#line 828
        bytesread += (unsigned int )__cil_tmp70;
#line 829
        ubuf.scbuf[sizeof(ubuf.scbuf) - 1UL] = (signed char)0;
        }
      }
      {
#line 832
      psf_log_printf(psf, "   Name     : %s\n", ubuf.scbuf);
#line 834
      psf_strlcpy((psf->cues)->cue_points[n].name, sizeof((psf->cues)->cue_points[n].name),
                  (char const   *)(ubuf.cbuf));
#line 836
      (paiff->markstr + (int )n)->markerID = mark_id;
#line 837
      (paiff->markstr + (int )n)->position = position___0;
#line 806
      n = (uint16_t )((int )n + 1);
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___3: 
    {
#line 846
    mark_found ++;
#line 847
    psf_binheader_readf(psf, "j", chunk_size - bytesread);
    }
#line 848
    goto switch_break;
    case_exp___14: 
#line 851
    found_chunk |= 8;
    case_exp___15: 
    {
#line 855
    psf_log_printf(psf, " %M : %d\n", marker, chunk_size);
#line 856
    psf_binheader_readf(psf, "j", chunk_size);
    }
#line 857
    goto switch_break;
    case_exp___16: 
    {
#line 861
    chunk_size = (chunk_size >> 24) - 3U;
#line 862
    psf_log_printf(psf, " %M : %d\n", marker, chunk_size);
#line 863
    __cil_tmp73 = make_size_t((int )chunk_size);
#line 863
    psf_binheader_readf(psf, "j", __cil_tmp73);
    }
#line 864
    goto switch_break;
    case_exp___17: 
#line 867
    if (chunk_size < 12U) {
      {
#line 868
      psf_log_printf(psf, " %M : %d (should be >= 12)\n", marker, chunk_size);
#line 869
      psf_binheader_readf(psf, "j", chunk_size);
      }
#line 870
      goto switch_break;
    }
    {
#line 873
    psf_log_printf(psf, " %M : %d\n", marker, chunk_size);
#line 875
    error = aiff_read_chanmap(psf, chunk_size);
    }
#line 875
    if (error) {
#line 876
      return (error);
    }
#line 877
    goto switch_break;
    switch_default___0: 
#line 880
    if (chunk_size >= 4294901760U) {
      {
#line 881
      done = 1;
#line 882
      __cil_tmp75 = psf_ftell(psf);
#line 882
      psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D with length %u. Exiting parser.\n",
                     marker, __cil_tmp75 - 8L, chunk_size);
      }
#line 883
      goto switch_break;
    }
    {
#line 886
    __cil_tmp79 = psf_isprint((int )(marker & 255U));
#line 886
    __cil_tmp78 = psf_isprint((int )((marker >> 8) & 255U));
#line 886
    __cil_tmp77 = psf_isprint((int )((marker >> 16) & 255U));
#line 886
    __cil_tmp76 = psf_isprint((int )((marker >> 24) & 255U));
    }
#line 886
    if (__cil_tmp76) {
#line 886
      if (__cil_tmp77) {
#line 886
        if (__cil_tmp78) {
#line 886
          if (__cil_tmp79) {
            {
#line 888
            psf_log_printf(psf, " %M : %u (unknown marker)\n", marker, chunk_size);
#line 890
            psf_binheader_readf(psf, "j", chunk_size);
            }
#line 891
            goto switch_break;
          }
        }
      }
    }
    {
#line 894
    __cil_tmp80 = psf_ftell(psf);
    }
#line 894
    if (__cil_tmp80 & 3L) {
      {
#line 895
      __cil_tmp81 = psf_ftell(psf);
#line 895
      psf_log_printf(psf, "  Unknown chunk marker at position %D. Resynching.\n",
                     __cil_tmp81 - 8L);
#line 896
      psf_binheader_readf(psf, "j", -3);
      }
#line 897
      goto switch_break;
    }
    {
#line 899
    __cil_tmp82 = psf_ftell(psf);
#line 899
    psf_log_printf(psf, "*** Unknown chunk marker %X at position %D. Exiting parser.\n",
                   marker, __cil_tmp82);
#line 900
    done = 1;
    }
#line 901
    goto switch_break;
    switch_break: ;
#line 904
    if ((long )chunk_size >= psf->filelength) {
      {
#line 905
      psf_log_printf(psf, "*** Chunk size %u > file length %D. Exiting parser.\n",
                     chunk_size, psf->filelength);
      }
#line 906
      goto while_break;
    }
#line 909
    if (! psf->sf.seekable) {
#line 909
      if (found_chunk & 32) {
#line 910
        goto while_break;
      }
    }
    {
#line 912
    __cil_tmp83 = psf_ftell(psf);
    }
#line 912
    if (__cil_tmp83 >= psf->filelength - (long )(2 * (int )sizeof(int32_t ))) {
#line 913
      goto while_break;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 916
  if (instr_found) {
#line 916
    if (mark_found) {
#line 919
      ji = 0;
      {
#line 919
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 919
        if (! (ji < (psf->instrument)->loop_count)) {
#line 919
          goto while_break___4;
        }
#line 920
        if (ji < (int )(sizeof((psf->instrument)->loops) / sizeof((psf->instrument)->loops[0]))) {
          {
#line 921
          (psf->instrument)->loops[ji].start = marker_to_position(paiff->markstr,
                                                                  (uint16_t )(psf->instrument)->loops[ji].start,
                                                                  (int )mark_count);
#line 922
          (psf->instrument)->loops[ji].end = marker_to_position(paiff->markstr, (uint16_t )(psf->instrument)->loops[ji].end,
                                                                (int )mark_count);
#line 923
          (psf->instrument)->loops[ji].mode = 801;
          }
        }
#line 919
        ji ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___4: ;
#line 928
      if ((psf->cues)->cue_count > (uint32_t )((psf->instrument)->loop_count * 2)) {
#line 931
        j = (uint32_t )0;
        {
#line 931
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 931
          if (! (j < (psf->cues)->cue_count - (uint32_t )((psf->instrument)->loop_count * 2))) {
#line 931
            goto while_break___5;
          }
#line 933
          (psf->cues)->cue_points[j].indx = (psf->cues)->cue_points[j + (unsigned int )((psf->instrument)->loop_count * 2)].indx;
#line 934
          (psf->cues)->cue_points[j].position = (psf->cues)->cue_points[j + (unsigned int )((psf->instrument)->loop_count * 2)].position;
#line 935
          (psf->cues)->cue_points[j].fcc_chunk = (psf->cues)->cue_points[j + (unsigned int )((psf->instrument)->loop_count * 2)].fcc_chunk;
#line 936
          (psf->cues)->cue_points[j].chunk_start = (psf->cues)->cue_points[j + (unsigned int )((psf->instrument)->loop_count * 2)].chunk_start;
#line 937
          (psf->cues)->cue_points[j].block_start = (psf->cues)->cue_points[j + (unsigned int )((psf->instrument)->loop_count * 2)].block_start;
#line 938
          (psf->cues)->cue_points[j].sample_offset = (psf->cues)->cue_points[j + (unsigned int )((psf->instrument)->loop_count * 2)].sample_offset;
#line 939
          str_index = 0;
          {
#line 939
          while (1) {
            while_continue___6: /* CIL Label */ ;

#line 939
            if (! (str_index < 256)) {
#line 939
              goto while_break___6;
            }
#line 940
            (psf->cues)->cue_points[j].name[str_index] = (psf->cues)->cue_points[j + (unsigned int )((psf->instrument)->loop_count * 2)].name[str_index];
#line 939
            str_index ++;
          }
          while_break___14: /* CIL Label */ ;
          }
          while_break___6: 
#line 931
          j ++;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: 
#line 942
        (psf->cues)->cue_count -= (unsigned int )((psf->instrument)->loop_count * 2);
      } else {
        {
#line 945
        free((void *)psf->cues);
#line 946
        psf->cues = (SF_CUES *)((void *)0);
        }
      }
    }
  }
#line 950
  if (psf->sf.channels < 1) {
#line 951
    return (33);
  }
#line 953
  if (psf->sf.channels >= 1024) {
#line 954
    return (34);
  }
#line 956
  if (! (found_chunk & 1)) {
#line 957
    return (80);
  }
#line 959
  if (! (found_chunk & 2)) {
#line 960
    return (82);
  }
#line 962
  if (! (found_chunk & 16)) {
#line 963
    return (83);
  }
#line 965
  if (! psf->dataoffset) {
#line 966
    return (90);
  }
#line 968
  return (0);
}
}
#line 972 "/root/patchweave_new/23/src/aiff.c"
static int aiff_close(SF_PRIVATE *psf ) 
{ 
  AIFF_PRIVATE *paiff ;

  {
#line 973
  paiff = (AIFF_PRIVATE *)psf->container_data;
#line 975
  if ((unsigned long )paiff != (unsigned long )((void *)0)) {
#line 975
    if ((unsigned long )paiff->markstr != (unsigned long )((void *)0)) {
      {
#line 976
      free((void *)paiff->markstr);
#line 977
      paiff->markstr = (MARK_ID_POS *)((void *)0);
      }
    }
  }
#line 980
  if (psf->file.mode == 32) {
    {
#line 981
    aiff_write_tailer(psf);
#line 982
    aiff_write_header(psf, 1);
    }
  } else
#line 980
  if (psf->file.mode == 48) {
    {
#line 981
    aiff_write_tailer(psf);
#line 982
    aiff_write_header(psf, 1);
    }
  }
#line 985
  return (0);
}
}
#line 989 "/root/patchweave_new/23/src/aiff.c"
static int aiff_read_comm_chunk(SF_PRIVATE *psf , COMM_CHUNK *comm_fmt ) 
{ 
  BUF_UNION ubuf ;
  int subformat ;
  int samplerate ;
  int32_t __cil_tmp6 ;
  uint8_t encoding_len ;
  unsigned int read_len ;
  char const   *tmp ;

  {
  {
#line 993
  ubuf.scbuf[0] = (signed char)0;
#line 1000
  psf_binheader_readf(psf, "E242b", & comm_fmt->numChannels, & comm_fmt->numSampleFrames,
                      & comm_fmt->sampleSize, & comm_fmt->sampleRate, (int )sizeof(comm_fmt->sampleRate));
  }
#line 1003
  if (comm_fmt->size > 65536U) {
#line 1003
    if ((comm_fmt->size & 65535U) == 0U) {
      {
#line 1004
      psf_log_printf(psf, " COMM : %d (0x%x) *** should be \230\001", comm_fmt->size,
                     comm_fmt->size);
#line 1005
      __cil_tmp6 = ENDSWAP_32((int32_t )comm_fmt->size);
#line 1005
      comm_fmt->size = (uint32_t )__cil_tmp6;
#line 1006
      psf_log_printf(psf, "%d (0x%x)\n\bI\270U", comm_fmt->size, comm_fmt->size);
      }
    } else {
      {
#line 1009
      psf_log_printf(psf, " COMM : %d\nI\270U", comm_fmt->size);
      }
    }
  } else {
    {
#line 1009
    psf_log_printf(psf, " COMM : %d\nI\270U", comm_fmt->size);
    }
  }
#line 1011
  if (comm_fmt->size == 18U) {
#line 1012
    comm_fmt->encoding = (unsigned int )((78 | (79 << 8)) | (78 << 16)) | (69U << 24);
  } else
#line 1013
  if (comm_fmt->size == 22U) {
    {
#line 1014
    psf_binheader_readf(psf, "Em\322H\270U", & comm_fmt->encoding);
    }
  } else
#line 1015
  if (comm_fmt->size >= 24U) {
    {
#line 1019
    psf_binheader_readf(psf, "Em1I\270U", & comm_fmt->encoding, & encoding_len);
#line 1021
    comm_fmt->size = (uint32_t )0;
#line 1022
    memset((void *)(ubuf.scbuf), 0, (unsigned long )comm_fmt->size);
#line 1023
    read_len = (comm_fmt->size - 24U) + 1U;
#line 1024
    psf_binheader_readf(psf, "b0\bI\270U", ubuf.scbuf, read_len);
#line 1025
    ubuf.scbuf[read_len + 1U] = (signed char)0;
    }
  }
  {
#line 1028
  samplerate = tenbytefloat2int(comm_fmt->sampleRate);
#line 1030
  psf_log_printf(psf, "  Sample Rate : %d\n", samplerate);
  }
#line 1031
  if (comm_fmt->numSampleFrames == 0U) {
#line 1031
    if (psf->filelength > 104L) {
#line 1031
      tmp = " (Should not be 0)";
    } else {
#line 1031
      tmp = "\220";
    }
  } else {
#line 1031
    tmp = "\220";
  }
  {
#line 1031
  psf_log_printf(psf, "  Frames      : %u%s\nU", comm_fmt->numSampleFrames, tmp);
  }
#line 1033
  if ((int )comm_fmt->numChannels < 1) {
    {
#line 1034
    psf_log_printf(psf, "  Channels    : %d (should be >= 1 and < %d)\nU", (int )comm_fmt->numChannels,
                   1024);
    }
#line 1035
    return (35);
  } else
#line 1033
  if ((int )comm_fmt->numChannels >= 1024) {
    {
#line 1034
    psf_log_printf(psf, "  Channels    : %d (should be >= 1 and < %d)\nU", (int )comm_fmt->numChannels,
                   1024);
    }
#line 1035
    return (35);
  }
  {
#line 1038
  psf_log_printf(psf, "  Channels    : %d\nI\270U", (int )comm_fmt->numChannels);
  }
#line 1041
  if (comm_fmt->encoding == ((unsigned int )((102 | (108 << 8)) | (51 << 16)) | (50U << 24))) {
    _L___45: 
#line 1041
    if ((int )comm_fmt->sampleSize != 32) {
      {
#line 1042
      psf_log_printf(psf, "  Sample Size : %d (should be 32)\n\nI\270U", (int )comm_fmt->sampleSize);
#line 1043
      comm_fmt->sampleSize = (int16_t )32;
      }
    } else {
#line 1041
      goto _L___44;
    }
  } else
#line 1041
  if (comm_fmt->encoding == ((unsigned int )((70 | (76 << 8)) | (51 << 16)) | (50U << 24))) {
#line 1041
    goto _L___45;
  } else
  _L___44: 
#line 1045
  if (comm_fmt->encoding == ((unsigned int )((102 | (108 << 8)) | (54 << 16)) | (52U << 24))) {
    _L: 
#line 1045
    if ((int )comm_fmt->sampleSize != 64) {
      {
#line 1046
      psf_log_printf(psf, "  Sample Size : %d (should be 64)\n", (int )comm_fmt->sampleSize);
#line 1047
      comm_fmt->sampleSize = (int16_t )64;
      }
    } else {
      {
#line 1050
      psf_log_printf(psf, "  Sample Size : %d\nI\270U", (int )comm_fmt->sampleSize);
      }
    }
  } else
#line 1045
  if (comm_fmt->encoding == ((unsigned int )((70 | (76 << 8)) | (54 << 16)) | (52U << 24))) {
#line 1045
    goto _L;
  } else {
    {
#line 1050
    psf_log_printf(psf, "  Sample Size : %d\nI\270U", (int )comm_fmt->sampleSize);
    }
  }
  {
#line 1052
  subformat = s_bitwidth_to_subformat((int )comm_fmt->sampleSize);
#line 1054
  psf->sf.samplerate = samplerate;
#line 1055
  psf->sf.frames = (sf_count_t )comm_fmt->numSampleFrames;
#line 1056
  psf->sf.channels = (int )comm_fmt->numChannels;
#line 1057
  psf->bytewidth = ((int )comm_fmt->sampleSize + 7) / 8;
#line 1059
  psf->endian = 536870912;
  }
#line 1062
  if (comm_fmt->encoding == ((unsigned int )((78 | (79 << 8)) | (78 << 16)) | (69U << 24))) {
#line 1062
    goto case_exp;
  }
#line 1068
  if (comm_fmt->encoding == ((unsigned int )((105 | (110 << 8)) | (51 << 16)) | (50U << 24))) {
#line 1068
    goto case_exp___0;
  }
#line 1068
  if (comm_fmt->encoding == ((unsigned int )((105 | (110 << 8)) | (50 << 16)) | (52U << 24))) {
#line 1068
    goto case_exp___0;
  }
#line 1068
  if (comm_fmt->encoding == ((unsigned int )((116 | (119 << 8)) | (111 << 16)) | (115U << 24))) {
#line 1068
    goto case_exp___0;
  }
#line 1074
  if (comm_fmt->encoding == ((unsigned int )((50 | (51 << 8)) | (110 << 16)) | (105U << 24))) {
#line 1074
    goto case_exp___3;
  }
#line 1074
  if (comm_fmt->encoding == ((unsigned int )((52 | (50 << 8)) | (110 << 16)) | (49U << 24))) {
#line 1074
    goto case_exp___3;
  }
#line 1074
  if (comm_fmt->encoding == ((unsigned int )((115 | (111 << 8)) | (119 << 16)) | (116U << 24))) {
#line 1074
    goto case_exp___3;
  }
#line 1080
  if (comm_fmt->encoding == ((unsigned int )((70 | (76 << 8)) | (51 << 16)) | (50U << 24))) {
#line 1080
    goto case_exp___6;
  }
#line 1080
  if (comm_fmt->encoding == ((unsigned int )((102 | (108 << 8)) | (51 << 16)) | (50U << 24))) {
#line 1080
    goto case_exp___6;
  }
#line 1085
  if (comm_fmt->encoding == ((unsigned int )((85 | (76 << 8)) | (65 << 16)) | (87U << 24))) {
#line 1085
    goto case_exp___8;
  }
#line 1085
  if (comm_fmt->encoding == ((unsigned int )((117 | (108 << 8)) | (97 << 16)) | (119U << 24))) {
#line 1085
    goto case_exp___8;
  }
#line 1090
  if (comm_fmt->encoding == ((unsigned int )((65 | (76 << 8)) | (65 << 16)) | (87U << 24))) {
#line 1090
    goto case_exp___10;
  }
#line 1090
  if (comm_fmt->encoding == ((unsigned int )((97 | (108 << 8)) | (97 << 16)) | (119U << 24))) {
#line 1090
    goto case_exp___10;
  }
#line 1095
  if (comm_fmt->encoding == ((unsigned int )((70 | (76 << 8)) | (54 << 16)) | (52U << 24))) {
#line 1095
    goto case_exp___12;
  }
#line 1095
  if (comm_fmt->encoding == ((unsigned int )((102 | (108 << 8)) | (54 << 16)) | (52U << 24))) {
#line 1095
    goto case_exp___12;
  }
#line 1099
  if (comm_fmt->encoding == ((unsigned int )((114 | (97 << 8)) | (119 << 16)) | (32U << 24))) {
#line 1099
    goto case_exp___14;
  }
#line 1103
  if (comm_fmt->encoding == ((unsigned int )((68 | (87 << 8)) | (86 << 16)) | (87U << 24))) {
#line 1103
    goto case_exp___15;
  }
#line 1106
  if (comm_fmt->encoding == 12U) {
#line 1106
    goto case_12;
  }
#line 1109
  if (comm_fmt->encoding == 16U) {
#line 1109
    goto case_16;
  }
#line 1112
  if (comm_fmt->encoding == 24U) {
#line 1112
    goto case_24;
  }
#line 1122
  if (comm_fmt->encoding == ((unsigned int )((71 | (83 << 8)) | (77 << 16)) | (32U << 24))) {
#line 1122
    goto case_exp___16;
  }
#line 1128
  if (comm_fmt->encoding == ((unsigned int )((105 | (109 << 8)) | (97 << 16)) | (52U << 24))) {
#line 1128
    goto case_exp___17;
  }
#line 1133
  goto switch_default___0;
  case_exp: 
#line 1063
  psf->sf.format = 131072 | subformat;
#line 1064
  goto switch_break;
  case_exp___0: 
#line 1069
  psf->sf.format = 537001984 | subformat;
#line 1070
  goto switch_break;
  case_exp___3: 
#line 1075
  psf->endian = 268435456;
#line 1076
  psf->sf.format = 268566528 | subformat;
#line 1077
  goto switch_break;
  case_exp___6: 
#line 1081
  psf->sf.format = 131078;
#line 1082
  goto switch_break;
  case_exp___8: 
#line 1086
  psf->sf.format = 131088;
#line 1087
  goto switch_break;
  case_exp___10: 
#line 1091
  psf->sf.format = 131089;
#line 1092
  goto switch_break;
  case_exp___12: 
#line 1096
  psf->sf.format = 131079;
#line 1097
  goto switch_break;
  case_exp___14: 
#line 1100
  psf->sf.format = 131077;
#line 1101
  goto switch_break;
  case_exp___15: 
#line 1104
  psf->sf.format = 131072;
#line 1106
  if ((int )comm_fmt->sampleSize == 12) {
#line 1106
    goto case_12;
  }
#line 1109
  if ((int )comm_fmt->sampleSize == 16) {
#line 1109
    goto case_16;
  }
#line 1112
  if ((int )comm_fmt->sampleSize == 24) {
#line 1112
    goto case_24;
  }
#line 1116
  goto switch_default;
  case_12: 
#line 1107
  psf->sf.format |= 64;
#line 1108
  goto switch_break___0;
  case_16: 
#line 1110
  psf->sf.format |= 65;
#line 1111
  goto switch_break___0;
  case_24: 
#line 1113
  psf->sf.format |= 66;
#line 1114
  goto switch_break___0;
  switch_default: 
#line 1117
  psf->sf.format |= 67;
#line 1118
  goto switch_break___0;
  switch_break___0: ;
#line 1120
  goto switch_break;
  case_exp___16: 
#line 1123
  psf->sf.format = 131072;
#line 1124
  psf->sf.format = 131104;
#line 1125
  goto switch_break;
  case_exp___17: 
#line 1129
  psf->endian = 536870912;
#line 1130
  psf->sf.format = 131090;
#line 1131
  goto switch_break;
  switch_default___0: 
  {
#line 1134
  psf_log_printf(psf, "AIFC : Unimplemented format : %M\n1\tI\270U", comm_fmt->encoding);
  }
#line 1135
  return (18);
  switch_break: ;
#line 1138
  if (! ubuf.scbuf[0]) {
    {
#line 1139
    psf_log_printf(psf, "  Encoding    : %M\n", comm_fmt->encoding);
    }
  } else {
    {
#line 1141
    psf_log_printf(psf, "  Encoding    : %M => %s\n\200", comm_fmt->encoding, ubuf.scbuf);
    }
  }
#line 1143
  return (0);
}
}
#line 1151 "/root/patchweave_new/23/src/aiff.c"
static void aiff_rewrite_header(SF_PRIVATE *psf ) 
{ 
  int k ;
  int ch ;
  int comm_size ;
  int comm_frames ;
  time_t __cil_tmp8 ;

  {
  {
#line 1160
  psf_fseek(psf, (sf_count_t )0, 0);
#line 1161
  psf_fread((void *)psf->header.ptr, psf->dataoffset, (sf_count_t )1, psf);
#line 1163
  psf->header.indx = (sf_count_t )0;
#line 1166
  psf_binheader_writef(psf, "Etm8\270U", (unsigned int )((70 | (79 << 8)) | (82 << 16)) | (77U << 24),
                       psf->filelength - 8L);
#line 1169
  k = psf_find_read_chunk_m32(& psf->rchunks, (unsigned int )((67 | (79 << 8)) | (77 << 16)) | (77U << 24));
  }
#line 1169
  if (k >= 0) {
    {
#line 1170
    psf->header.indx = (psf->rchunks.chunks + k)->offset - 8L;
#line 1171
    comm_frames = (int )psf->sf.frames;
#line 1172
    comm_size = (int )(psf->rchunks.chunks + k)->len;
#line 1173
    psf_binheader_writef(psf, "Em42t4", (unsigned int )((67 | (79 << 8)) | (77 << 16)) | (77U << 24),
                         comm_size, psf->sf.channels, comm_frames);
    }
  }
  {
#line 1177
  k = psf_find_read_chunk_m32(& psf->rchunks, (unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24));
  }
#line 1177
  if (k >= 0) {
    {
#line 1178
    psf->header.indx = (psf->rchunks.chunks + k)->offset - 8L;
#line 1179
    psf_binheader_writef(psf, "Em4", (unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24),
                         2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int )));
#line 1180
    __cil_tmp8 = time((time_t *)((void *)0));
#line 1180
    psf_binheader_writef(psf, "E44I\270U", 1, __cil_tmp8);
#line 1181
    ch = 0;
    }
    {
#line 1181
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1181
      if (! (ch < psf->sf.channels)) {
#line 1181
        goto while_break;
      }
      {
#line 1182
      psf_binheader_writef(psf, "Eft8", (double )((float )(psf->peak_info)->peaks[ch].value),
                           (psf->peak_info)->peaks[ch].position);
#line 1181
      ch ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 1187
  k = psf_find_read_chunk_m32(& psf->rchunks, (unsigned int )((83 | (83 << 8)) | (78 << 16)) | (68U << 24));
  }
#line 1187
  if (k >= 0) {
    {
#line 1188
    psf->header.indx = (psf->rchunks.chunks + k)->offset - 8L;
#line 1189
    psf_binheader_writef(psf, "Etm8", (unsigned int )((83 | (83 << 8)) | (78 << 16)) | (68U << 24),
                         psf->datalength + 8L);
    }
  }
  {
#line 1193
  psf_fseek(psf, (sf_count_t )0, 0);
#line 1194
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 1196
  return;
}
}
#line 1200 "/root/patchweave_new/23/src/aiff.c"
static uint16_t convert_loop_mode(int type_mode ) 
{ 


  {
#line 1202
  if (type_mode == 800) {
#line 1202
    goto case_800;
  }
#line 1204
  if (type_mode == 801) {
#line 1204
    goto case_801;
  }
#line 1206
  if (type_mode == 803) {
#line 1206
    goto case_803;
  }
#line 1208
  goto switch_default;
  case_800: 
#line 1203
  return ((uint16_t )0);
  case_801: 
#line 1205
  return ((uint16_t )1);
  case_803: 
#line 1207
  return ((uint16_t )2);
  switch_default: 
#line 1208
  goto switch_break;
  switch_break: ;
#line 1211
  return ((uint16_t )0);
}
}
#line 1215 "/root/patchweave_new/23/src/aiff.c"
static int aiff_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  AIFF_PRIVATE *paiff ;
  uint8_t comm_sample_rate[10] ;
  uint8_t comm_zero_bytes[2] ;
  uint32_t comm_type ;
  uint32_t comm_size ;
  uint32_t comm_encoding ;
  uint32_t comm_frames ;
  uint32_t uk ;
  int k ;
  int endian ;
  int has_data ;
  int16_t bit_width ;
  long tmp ;
  uint16_t sustainLoopMode ;
  uint16_t releaseLoopMode ;
  uint32_t idx ;
  uint32_t sLoopStart ;
  uint32_t sLoopEnd ;
  uint32_t rLoopStart ;
  uint32_t rLoopEnd ;
  int totalStringLength ;
  int stringLength ;
  unsigned long __cil_tmp28 ;
  size_t __cil_tmp30 ;
  size_t __cil_tmp31 ;
  size_t __cil_tmp32 ;
  size_t __cil_tmp33 ;
  size_t __cil_tmp35 ;
  size_t __cil_tmp36 ;
  size_t __cil_tmp38 ;
  size_t __cil_tmp39 ;
  uint16_t sustainLoopMode___0 ;
  uint16_t releaseLoopMode___0 ;
  uint32_t sLoopStart___0 ;
  uint32_t sLoopEnd___0 ;
  uint32_t rLoopStart___0 ;
  uint32_t rLoopEnd___0 ;
  size_t __cil_tmp49 ;
  size_t __cil_tmp50 ;
  size_t __cil_tmp51 ;
  size_t __cil_tmp52 ;
  size_t __cil_tmp53 ;
  size_t __cil_tmp54 ;
  size_t __cil_tmp55 ;
  size_t __cil_tmp56 ;
  uint32_t idx___0 ;
  int totalStringLength___0 ;
  int stringLength___0 ;
  unsigned long __cil_tmp62 ;
  int tmp___0 ;
  time_t __cil_tmp66 ;
  size_t __cil_tmp68 ;

  {
#line 1218
  comm_zero_bytes[0] = (uint8_t )0;
#line 1218
  comm_zero_bytes[1] = (uint8_t )0;
#line 1219
  comm_frames = (uint32_t )0;
#line 1220
  has_data = 0;
#line 1223
  paiff = (AIFF_PRIVATE *)psf->container_data;
#line 1223
  if ((unsigned long )paiff == (unsigned long )((void *)0)) {
#line 1224
    return (30);
  }
  {
#line 1226
  current = psf_ftell(psf);
  }
#line 1228
  if (current > psf->dataoffset) {
#line 1229
    has_data = 1;
  }
#line 1231
  if (calc_length) {
    {
#line 1232
    psf->filelength = psf_get_filelen(psf);
#line 1234
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 1235
    if (psf->dataend) {
#line 1236
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 1238
    if (psf->bytewidth > 0) {
#line 1239
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
#line 1242
  if (psf->file.mode == 48) {
#line 1242
    if (psf->dataoffset > 0L) {
#line 1242
      if (psf->rchunks.count > 0U) {
        {
#line 1243
        aiff_rewrite_header(psf);
        }
#line 1244
        if (current > 0L) {
          {
#line 1245
          psf_fseek(psf, current, 0);
          }
        }
#line 1246
        return (0);
      }
    }
  }
#line 1249
  endian = psf->sf.format & 805306368;
#line 1250
  if (endian == 805306368) {
#line 1251
    endian = 268435456;
  }
#line 1254
  bit_width = (int16_t )(psf->bytewidth * 8);
#line 1255
  if (psf->sf.frames > 4294967295L) {
#line 1255
    tmp = 4294967295L;
  } else {
#line 1255
    tmp = psf->sf.frames;
  }
#line 1255
  comm_frames = (uint32_t )tmp;
#line 1258
  if (((psf->sf.format & 65535) | endian) == 536870913) {
#line 1258
    goto case_536870913;
  }
#line 1265
  if (((psf->sf.format & 65535) | endian) == 268435457) {
#line 1265
    goto case_268435457;
  }
#line 1272
  if (((psf->sf.format & 65535) | endian) == 536870914) {
#line 1272
    goto case_536870914;
  }
#line 1279
  if (((psf->sf.format & 65535) | endian) == 268435458) {
#line 1279
    goto case_268435458;
  }
#line 1286
  if (((psf->sf.format & 65535) | endian) == 536870915) {
#line 1286
    goto case_536870915;
  }
#line 1293
  if (((psf->sf.format & 65535) | endian) == 268435459) {
#line 1293
    goto case_268435459;
  }
#line 1300
  if (((psf->sf.format & 65535) | endian) == 536870916) {
#line 1300
    goto case_536870916;
  }
#line 1307
  if (((psf->sf.format & 65535) | endian) == 268435460) {
#line 1307
    goto case_268435460;
  }
#line 1317
  if (((psf->sf.format & 65535) | endian) == 4) {
#line 1317
    goto case_4;
  }
#line 1317
  if (((psf->sf.format & 65535) | endian) == 3) {
#line 1317
    goto case_4;
  }
#line 1317
  if (((psf->sf.format & 65535) | endian) == 2) {
#line 1317
    goto case_4;
  }
#line 1317
  if (((psf->sf.format & 65535) | endian) == 1) {
#line 1317
    goto case_4;
  }
#line 1324
  if (((psf->sf.format & 65535) | endian) == 6) {
#line 1324
    goto case_6;
  }
#line 1331
  if (((psf->sf.format & 65535) | endian) == 7) {
#line 1331
    goto case_7;
  }
#line 1338
  if (((psf->sf.format & 65535) | endian) == 16) {
#line 1338
    goto case_16;
  }
#line 1345
  if (((psf->sf.format & 65535) | endian) == 17) {
#line 1345
    goto case_17;
  }
#line 1352
  if (((psf->sf.format & 65535) | endian) == 5) {
#line 1352
    goto case_5;
  }
#line 1359
  if (((psf->sf.format & 65535) | endian) == 64) {
#line 1359
    goto case_64;
  }
#line 1369
  if (((psf->sf.format & 65535) | endian) == 65) {
#line 1369
    goto case_65;
  }
#line 1379
  if (((psf->sf.format & 65535) | endian) == 66) {
#line 1379
    goto case_66;
  }
#line 1389
  if (((psf->sf.format & 65535) | endian) == 32) {
#line 1389
    goto case_32;
  }
#line 1399
  if (((psf->sf.format & 65535) | endian) == 18) {
#line 1399
    goto case_18;
  }
#line 1410
  goto switch_default;
  case_536870913: 
#line 1259
  psf->endian = 536870912;
#line 1260
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1261
  comm_size = (uint32_t )24;
#line 1262
  comm_encoding = (unsigned int )((116 | (119 << 8)) | (111 << 16)) | (115U << 24);
#line 1263
  goto switch_break;
  case_268435457: 
#line 1266
  psf->endian = 268435456;
#line 1267
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1268
  comm_size = (uint32_t )24;
#line 1269
  comm_encoding = (unsigned int )((115 | (111 << 8)) | (119 << 16)) | (116U << 24);
#line 1270
  goto switch_break;
  case_536870914: 
#line 1273
  psf->endian = 536870912;
#line 1274
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1275
  comm_size = (uint32_t )24;
#line 1276
  comm_encoding = (unsigned int )((116 | (119 << 8)) | (111 << 16)) | (115U << 24);
#line 1277
  goto switch_break;
  case_268435458: 
#line 1280
  psf->endian = 268435456;
#line 1281
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1282
  comm_size = (uint32_t )24;
#line 1283
  comm_encoding = (unsigned int )((115 | (111 << 8)) | (119 << 16)) | (116U << 24);
#line 1284
  goto switch_break;
  case_536870915: 
#line 1287
  psf->endian = 536870912;
#line 1288
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1289
  comm_size = (uint32_t )24;
#line 1290
  comm_encoding = (unsigned int )((105 | (110 << 8)) | (50 << 16)) | (52U << 24);
#line 1291
  goto switch_break;
  case_268435459: 
#line 1294
  psf->endian = 268435456;
#line 1295
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1296
  comm_size = (uint32_t )24;
#line 1297
  comm_encoding = (unsigned int )((52 | (50 << 8)) | (110 << 16)) | (49U << 24);
#line 1298
  goto switch_break;
  case_536870916: 
#line 1301
  psf->endian = 536870912;
#line 1302
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1303
  comm_size = (uint32_t )24;
#line 1304
  comm_encoding = (unsigned int )((105 | (110 << 8)) | (51 << 16)) | (50U << 24);
#line 1305
  goto switch_break;
  case_268435460: 
#line 1308
  psf->endian = 268435456;
#line 1309
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1310
  comm_size = (uint32_t )24;
#line 1311
  comm_encoding = (unsigned int )((50 | (51 << 8)) | (110 << 16)) | (105U << 24);
#line 1312
  goto switch_break;
  case_4: 
#line 1318
  psf->endian = 536870912;
#line 1319
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (70U << 24);
#line 1320
  comm_size = (uint32_t )18;
#line 1321
  comm_encoding = (uint32_t )0;
#line 1322
  goto switch_break;
  case_6: 
#line 1325
  psf->endian = 536870912;
#line 1326
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1327
  comm_size = (uint32_t )24;
#line 1328
  comm_encoding = (unsigned int )((70 | (76 << 8)) | (51 << 16)) | (50U << 24);
#line 1329
  goto switch_break;
  case_7: 
#line 1332
  psf->endian = 536870912;
#line 1333
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1334
  comm_size = (uint32_t )24;
#line 1335
  comm_encoding = (unsigned int )((70 | (76 << 8)) | (54 << 16)) | (52U << 24);
#line 1336
  goto switch_break;
  case_16: 
#line 1339
  psf->endian = 536870912;
#line 1340
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1341
  comm_size = (uint32_t )24;
#line 1342
  comm_encoding = (unsigned int )((117 | (108 << 8)) | (97 << 16)) | (119U << 24);
#line 1343
  goto switch_break;
  case_17: 
#line 1346
  psf->endian = 536870912;
#line 1347
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1348
  comm_size = (uint32_t )24;
#line 1349
  comm_encoding = (unsigned int )((97 | (108 << 8)) | (97 << 16)) | (119U << 24);
#line 1350
  goto switch_break;
  case_5: 
#line 1353
  psf->endian = 536870912;
#line 1354
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1355
  comm_size = (uint32_t )24;
#line 1356
  comm_encoding = (unsigned int )((114 | (97 << 8)) | (119 << 16)) | (32U << 24);
#line 1357
  goto switch_break;
  case_64: 
#line 1360
  psf->endian = 536870912;
#line 1361
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1362
  comm_size = (uint32_t )24;
#line 1363
  comm_encoding = (unsigned int )((68 | (87 << 8)) | (86 << 16)) | (87U << 24);
#line 1366
  bit_width = (int16_t )12;
#line 1367
  goto switch_break;
  case_65: 
#line 1370
  psf->endian = 536870912;
#line 1371
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1372
  comm_size = (uint32_t )24;
#line 1373
  comm_encoding = (unsigned int )((68 | (87 << 8)) | (86 << 16)) | (87U << 24);
#line 1376
  bit_width = (int16_t )16;
#line 1377
  goto switch_break;
  case_66: 
#line 1380
  psf->endian = 536870912;
#line 1381
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1382
  comm_size = (uint32_t )24;
#line 1383
  comm_encoding = (unsigned int )((68 | (87 << 8)) | (86 << 16)) | (87U << 24);
#line 1386
  bit_width = (int16_t )24;
#line 1387
  goto switch_break;
  case_32: 
#line 1390
  psf->endian = 536870912;
#line 1391
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1392
  comm_size = (uint32_t )24;
#line 1393
  comm_encoding = (unsigned int )((71 | (83 << 8)) | (77 << 16)) | (32U << 24);
#line 1396
  bit_width = (int16_t )16;
#line 1397
  goto switch_break;
  case_18: 
#line 1400
  psf->endian = 536870912;
#line 1401
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1402
  comm_size = (uint32_t )24;
#line 1403
  comm_encoding = (unsigned int )((105 | (109 << 8)) | (97 << 16)) | (52U << 24);
#line 1406
  bit_width = (int16_t )16;
#line 1407
  comm_frames = (uint32_t )(psf->sf.frames / 64L);
#line 1408
  goto switch_break;
  switch_default: 
#line 1410
  return (1);
  switch_break: 
  {
#line 1414
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 1415
  psf->header.indx = (sf_count_t )0;
#line 1416
  psf_fseek(psf, (sf_count_t )0, 0);
#line 1418
  psf_binheader_writef(psf, "Etm8\270U", (unsigned int )((70 | (79 << 8)) | (82 << 16)) | (77U << 24),
                       psf->filelength - 8L);
  }
#line 1421
  if (comm_type == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24))) {
    {
#line 1423
    psf_binheader_writef(psf, "Emm44U", comm_type, (unsigned int )((70 | (86 << 8)) | (69 << 16)) | (82U << 24),
                         4, 2726318400U);
    }
  } else {
    {
#line 1425
    psf_binheader_writef(psf, "Em\006I\270U", comm_type);
    }
  }
  {
#line 1427
  paiff->comm_offset = psf->header.indx - 8L;
#line 1429
  memset((void *)(comm_sample_rate), 0, sizeof(comm_sample_rate));
#line 1430
  uint2tenbytefloat((uint32_t )psf->sf.samplerate, comm_sample_rate);
#line 1432
  psf_binheader_writef(psf, "Em42t42", (unsigned int )((67 | (79 << 8)) | (77 << 16)) | (77U << 24),
                       comm_size, psf->sf.channels, comm_frames, (int )bit_width);
#line 1433
  psf_binheader_writef(psf, "b\f\322H\270U", comm_sample_rate, sizeof(comm_sample_rate));
  }
#line 1436
  if (comm_type == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24))) {
    {
#line 1437
    psf_binheader_writef(psf, "mb", comm_encoding, comm_zero_bytes, sizeof(comm_zero_bytes));
    }
  }
#line 1439
  if (psf->channel_map) {
#line 1439
    if (paiff->chanmap_tag) {
      {
#line 1440
      psf_binheader_writef(psf, "Em4444", (unsigned int )((67 | (72 << 8)) | (65 << 16)) | (78U << 24),
                           12, paiff->chanmap_tag, 0, 0);
      }
    }
  }
#line 1443
  if ((unsigned long )psf->instrument != (unsigned long )((void *)0)) {
#line 1443
    if ((unsigned long )psf->cues != (unsigned long )((void *)0)) {
#line 1446
      sLoopStart = (uint32_t )0;
#line 1446
      sLoopEnd = (uint32_t )0;
#line 1446
      rLoopStart = (uint32_t )0;
#line 1446
      rLoopEnd = (uint32_t )0;
#line 1447
      totalStringLength = 0;
#line 1450
      idx = (uint32_t )0;
      {
#line 1450
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1450
        if (! (idx < (psf->cues)->cue_count)) {
#line 1450
          goto while_break;
        }
        {
#line 1451
        __cil_tmp28 = strlen((char const   *)((psf->cues)->cue_points[idx].name));
#line 1451
        stringLength = (int )(__cil_tmp28 + 1UL);
        }
#line 1452
        if (stringLength % 2 == 0) {
#line 1453
          totalStringLength += stringLength;
        } else {
#line 1455
          totalStringLength += stringLength + 1;
        }
#line 1450
        idx ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break: ;
#line 1460
      if ((psf->instrument)->loops[0].mode != 800) {
#line 1460
        if ((psf->instrument)->loops[1].mode != 800) {
          {
#line 1462
          __cil_tmp30 = make_size_t(19);
#line 1462
          __cil_tmp31 = make_size_t(17);
#line 1462
          __cil_tmp32 = make_size_t(19);
#line 1462
          __cil_tmp33 = make_size_t(17);
#line 1462
          psf_binheader_writef(psf, "Em42 241b 241b 241b 241b\221", (unsigned int )((77 | (65 << 8)) | (82 << 16)) | (75U << 24),
                               (102U + (psf->cues)->cue_count * 6U) + (unsigned int )totalStringLength,
                               4U + (psf->cues)->cue_count, 1, (psf->instrument)->loops[0].start,
                               18, "sustain loop start", __cil_tmp30, 2, (psf->instrument)->loops[0].end,
                               16, "sustain loop end\230", __cil_tmp31, 3, (psf->instrument)->loops[1].start,
                               18, "release loop start\005I\270U", __cil_tmp32, 4,
                               (psf->instrument)->loops[1].end, 16, "release loop end\230",
                               __cil_tmp33);
#line 1469
          idx = (uint32_t )0;
          }
          {
#line 1469
          while (1) {
            while_continue___0: /* CIL Label */ ;

#line 1469
            if (! (idx < (psf->cues)->cue_count)) {
#line 1469
              goto while_break___0;
            }
            {
#line 1470
            psf_binheader_writef(psf, "E24p\270U", 5U + idx, (psf->cues)->cue_points[idx].sample_offset,
                                 (psf->cues)->cue_points[idx].name);
#line 1469
            idx ++;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___0: 
#line 1473
          sLoopStart = (uint32_t )1;
#line 1474
          sLoopEnd = (uint32_t )2;
#line 1475
          rLoopStart = (uint32_t )3;
#line 1476
          rLoopEnd = (uint32_t )4;
        } else {
#line 1460
          goto _L___46;
        }
      } else
      _L___46: 
#line 1478
      if ((psf->instrument)->loops[0].mode != 800) {
#line 1478
        if ((psf->instrument)->loops[1].mode == 800) {
          {
#line 1480
          __cil_tmp35 = make_size_t(19);
#line 1480
          __cil_tmp36 = make_size_t(17);
#line 1480
          psf_binheader_writef(psf, "Em42241b241b", (unsigned int )((77 | (65 << 8)) | (82 << 16)) | (75U << 24),
                               (52U + (psf->cues)->cue_count * 6U) + (unsigned int )totalStringLength,
                               2U + (psf->cues)->cue_count, 1, (psf->instrument)->loops[0].start,
                               18, "sustain loop start", __cil_tmp35, 2, (psf->instrument)->loops[0].end,
                               16, "sustain loop end\230", __cil_tmp36);
#line 1485
          idx = (uint32_t )0;
          }
          {
#line 1485
          while (1) {
            while_continue___1: /* CIL Label */ ;

#line 1485
            if (! (idx < (psf->cues)->cue_count)) {
#line 1485
              goto while_break___1;
            }
            {
#line 1486
            psf_binheader_writef(psf, "E24p", 3U + idx, (psf->cues)->cue_points[idx].sample_offset,
                                 (psf->cues)->cue_points[idx].name);
#line 1485
            idx ++;
            }
          }
          while_break___9: /* CIL Label */ ;
          }
          while_break___1: 
#line 1489
          sLoopStart = (uint32_t )1;
#line 1490
          sLoopEnd = (uint32_t )2;
#line 1491
          rLoopStart = (uint32_t )0;
#line 1492
          rLoopEnd = (uint32_t )0;
        } else {
#line 1478
          goto _L;
        }
      } else
      _L: 
#line 1494
      if ((psf->instrument)->loops[0].mode == 800) {
#line 1494
        if ((psf->instrument)->loops[1].mode != 800) {
          {
#line 1496
          __cil_tmp38 = make_size_t(19);
#line 1496
          __cil_tmp39 = make_size_t(17);
#line 1496
          psf_binheader_writef(psf, "Em42241b241b", (unsigned int )((77 | (65 << 8)) | (82 << 16)) | (75U << 24),
                               (52U + (psf->cues)->cue_count * 6U) + (unsigned int )totalStringLength,
                               2U + (psf->cues)->cue_count, 1, (psf->instrument)->loops[1].start,
                               18, "release loop start", __cil_tmp38, 2, (psf->instrument)->loops[1].end,
                               16, "release loop end\230", __cil_tmp39);
#line 1501
          idx = (uint32_t )0;
          }
          {
#line 1501
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 1501
            if (! (idx < (psf->cues)->cue_count)) {
#line 1501
              goto while_break___2;
            }
            {
#line 1502
            psf_binheader_writef(psf, "E24p", 3U + idx, (psf->cues)->cue_points[idx].sample_offset,
                                 (psf->cues)->cue_points[idx].name);
#line 1501
            idx ++;
            }
          }
          while_break___10: /* CIL Label */ ;
          }
          while_break___2: 
#line 1505
          sLoopStart = (uint32_t )0;
#line 1506
          sLoopEnd = (uint32_t )0;
#line 1507
          rLoopStart = (uint32_t )1;
#line 1508
          rLoopEnd = (uint32_t )2;
        }
      }
      {
#line 1512
      sustainLoopMode = convert_loop_mode((psf->instrument)->loops[0].mode);
#line 1513
      releaseLoopMode = convert_loop_mode((psf->instrument)->loops[1].mode);
#line 1516
      psf_binheader_writef(psf, "Em4111111", (unsigned int )((73 | (78 << 8)) | (83 << 16)) | (84U << 24),
                           20, (int )(psf->instrument)->basenote, (int )(psf->instrument)->detune,
                           (int )(psf->instrument)->key_lo, (int )(psf->instrument)->key_hi,
                           (int )(psf->instrument)->velocity_lo, (int )(psf->instrument)->velocity_hi);
#line 1518
      psf_binheader_writef(psf, "E2222222\230\001", (int )((short )(psf->instrument)->gain),
                           (int )sustainLoopMode, sLoopStart, sLoopEnd, (int )releaseLoopMode,
                           rLoopStart, rLoopEnd);
      }
    } else {
#line 1443
      goto _L___50;
    }
  } else
  _L___50: 
#line 1523
  if ((unsigned long )psf->instrument != (unsigned long )((void *)0)) {
#line 1523
    if ((unsigned long )psf->cues == (unsigned long )((void *)0)) {
#line 1526
      sLoopStart___0 = (uint32_t )0;
#line 1526
      sLoopEnd___0 = (uint32_t )0;
#line 1526
      rLoopStart___0 = (uint32_t )0;
#line 1526
      rLoopEnd___0 = (uint32_t )0;
#line 1529
      if ((psf->instrument)->loops[0].mode != 800) {
#line 1529
        if ((psf->instrument)->loops[1].mode != 800) {
          {
#line 1531
          __cil_tmp49 = make_size_t(19);
#line 1531
          __cil_tmp50 = make_size_t(17);
#line 1531
          __cil_tmp51 = make_size_t(19);
#line 1531
          __cil_tmp52 = make_size_t(17);
#line 1531
          psf_binheader_writef(psf, "Em42 241b 241b 241b 241b\221", (unsigned int )((77 | (65 << 8)) | (82 << 16)) | (75U << 24),
                               102, 4, 1, (psf->instrument)->loops[0].start, 18, "sustain loop start",
                               __cil_tmp49, 2, (psf->instrument)->loops[0].end, 16,
                               "sustain loop end\230", __cil_tmp50, 3, (psf->instrument)->loops[1].start,
                               18, "release loop start", __cil_tmp51, 4, (psf->instrument)->loops[1].end,
                               16, "release loop end\230", __cil_tmp52);
#line 1538
          sLoopStart___0 = (uint32_t )1;
#line 1539
          sLoopEnd___0 = (uint32_t )2;
#line 1540
          rLoopStart___0 = (uint32_t )3;
#line 1541
          rLoopEnd___0 = (uint32_t )4;
          }
        } else {
#line 1529
          goto _L___48;
        }
      } else
      _L___48: 
#line 1543
      if ((psf->instrument)->loops[0].mode != 800) {
#line 1543
        if ((psf->instrument)->loops[1].mode == 800) {
          {
#line 1545
          __cil_tmp53 = make_size_t(19);
#line 1545
          __cil_tmp54 = make_size_t(17);
#line 1545
          psf_binheader_writef(psf, "Em42241b241b", (unsigned int )((77 | (65 << 8)) | (82 << 16)) | (75U << 24),
                               52, 2, 1, (psf->instrument)->loops[0].start, 18, "sustain loop start",
                               __cil_tmp53, 2, (psf->instrument)->loops[0].end, 16,
                               "sustain loop end\230", __cil_tmp54);
#line 1550
          sLoopStart___0 = (uint32_t )1;
#line 1551
          sLoopEnd___0 = (uint32_t )2;
#line 1552
          rLoopStart___0 = (uint32_t )0;
#line 1553
          rLoopEnd___0 = (uint32_t )0;
          }
        } else {
#line 1543
          goto _L___47;
        }
      } else
      _L___47: 
#line 1555
      if ((psf->instrument)->loops[0].mode == 800) {
#line 1555
        if ((psf->instrument)->loops[1].mode != 800) {
          {
#line 1557
          __cil_tmp55 = make_size_t(19);
#line 1557
          __cil_tmp56 = make_size_t(17);
#line 1557
          psf_binheader_writef(psf, "Em42241b241b", (unsigned int )((77 | (65 << 8)) | (82 << 16)) | (75U << 24),
                               52, 2, 1, (psf->instrument)->loops[1].start, 18, "release loop start",
                               __cil_tmp55, 2, (psf->instrument)->loops[1].end, 16,
                               "release loop end\230", __cil_tmp56);
#line 1562
          sLoopStart___0 = (uint32_t )0;
#line 1563
          sLoopEnd___0 = (uint32_t )0;
#line 1564
          rLoopStart___0 = (uint32_t )1;
#line 1565
          rLoopEnd___0 = (uint32_t )2;
          }
        }
      }
      {
#line 1569
      sustainLoopMode___0 = convert_loop_mode((psf->instrument)->loops[0].mode);
#line 1570
      releaseLoopMode___0 = convert_loop_mode((psf->instrument)->loops[1].mode);
#line 1573
      psf_binheader_writef(psf, "Em4111111", (unsigned int )((73 | (78 << 8)) | (83 << 16)) | (84U << 24),
                           20, (int )(psf->instrument)->basenote, (int )(psf->instrument)->detune,
                           (int )(psf->instrument)->key_lo, (int )(psf->instrument)->key_hi,
                           (int )(psf->instrument)->velocity_lo, (int )(psf->instrument)->velocity_hi);
#line 1575
      psf_binheader_writef(psf, "E2222222\230\001", (int )((short )(psf->instrument)->gain),
                           (int )sustainLoopMode___0, sLoopStart___0, sLoopEnd___0,
                           (int )releaseLoopMode___0, rLoopStart___0, rLoopEnd___0);
      }
    } else {
#line 1523
      goto _L___49;
    }
  } else
  _L___49: 
#line 1580
  if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 1580
    if ((unsigned long )psf->cues != (unsigned long )((void *)0)) {
#line 1583
      totalStringLength___0 = 0;
#line 1586
      idx___0 = (uint32_t )0;
      {
#line 1586
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1586
        if (! (idx___0 < (psf->cues)->cue_count)) {
#line 1586
          goto while_break___3;
        }
        {
#line 1587
        __cil_tmp62 = strlen((char const   *)((psf->cues)->cue_points[idx___0].name));
#line 1587
        stringLength___0 = (int )(__cil_tmp62 + 1UL);
        }
#line 1588
        if (stringLength___0 % 2 == 0) {
#line 1588
          tmp___0 = 0;
        } else {
#line 1588
          tmp___0 = 1;
        }
#line 1588
        totalStringLength___0 += stringLength___0 + tmp___0;
#line 1586
        idx___0 ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___3: 
      {
#line 1591
      psf_binheader_writef(psf, "Em42", (unsigned int )((77 | (65 << 8)) | (82 << 16)) | (75U << 24),
                           (2U + (psf->cues)->cue_count * 6U) + (unsigned int )totalStringLength___0,
                           (psf->cues)->cue_count);
#line 1594
      idx___0 = (uint32_t )0;
      }
      {
#line 1594
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1594
        if (! (idx___0 < (psf->cues)->cue_count)) {
#line 1594
          goto while_break___4;
        }
        {
#line 1595
        psf_binheader_writef(psf, "E24p", (psf->cues)->cue_points[idx___0].indx, (psf->cues)->cue_points[idx___0].sample_offset,
                             (psf->cues)->cue_points[idx___0].name);
#line 1594
        idx___0 ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___4: ;
    }
  }
#line 1598
  if (psf->strings.flags & 1024U) {
    {
#line 1599
    aiff_write_strings(psf, 1024);
    }
  }
#line 1601
  if ((unsigned long )psf->peak_info != (unsigned long )((void *)0)) {
#line 1601
    if ((psf->peak_info)->peak_loc == 42) {
      {
#line 1602
      psf_binheader_writef(psf, "Em4", (unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24),
                           2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int )));
#line 1603
      __cil_tmp66 = time((time_t *)((void *)0));
#line 1603
      psf_binheader_writef(psf, "E44", 1, __cil_tmp66);
#line 1604
      k = 0;
      }
      {
#line 1604
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 1604
        if (! (k < psf->sf.channels)) {
#line 1604
          goto while_break___5;
        }
        {
#line 1605
        psf_binheader_writef(psf, "Eft8", (double )((float )(psf->peak_info)->peaks[k].value),
                             (psf->peak_info)->peaks[k].position);
#line 1604
        k ++;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___5: ;
    }
  }
#line 1609
  uk = (uint32_t )0;
  {
#line 1609
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 1609
    if (! (uk < psf->wchunks.used)) {
#line 1609
      goto while_break___6;
    }
    {
#line 1610
    __cil_tmp68 = make_size_t((int )(psf->wchunks.chunks + uk)->len);
#line 1610
    psf_binheader_writef(psf, "Em4b", (psf->wchunks.chunks + uk)->mark32, (psf->wchunks.chunks + uk)->len,
                         (psf->wchunks.chunks + uk)->data, __cil_tmp68);
#line 1609
    uk ++;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___6: 
  {
#line 1613
  paiff->ssnd_offset = psf->header.indx;
#line 1614
  psf_binheader_writef(psf, "Etm844", (unsigned int )((83 | (83 << 8)) | (78 << 16)) | (68U << 24),
                       psf->datalength + 8L, 0, 0);
#line 1617
  psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1, psf);
  }
#line 1619
  if (psf->error) {
#line 1620
    return (psf->error);
  }
#line 1622
  if (has_data) {
#line 1622
    if (psf->dataoffset != psf->header.indx) {
#line 1623
      psf->error = 30;
#line 1623
      return (psf->error);
    }
  }
#line 1625
  psf->dataoffset = psf->header.indx;
#line 1627
  if (! has_data) {
    {
#line 1628
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 1629
  if (current > 0L) {
    {
#line 1630
    psf_fseek(psf, current, 0);
    }
  }
#line 1632
  return (psf->error);
}
}
#line 1636 "/root/patchweave_new/23/src/aiff.c"
static int aiff_write_tailer(SF_PRIVATE *psf ) 
{ 
  int k ;
  time_t __cil_tmp5 ;

  {
  {
#line 1640
  *(psf->header.ptr + 0) = (unsigned char)0;
#line 1641
  psf->header.indx = (sf_count_t )0;
#line 1643
  psf->dataend = psf_fseek(psf, (sf_count_t )0, 2);
  }
#line 1646
  if (psf->dataend % 2L == 1L) {
    {
#line 1647
    psf_fwrite((void const   *)psf->header.ptr, (sf_count_t )1, (sf_count_t )1, psf);
#line 1648
    (psf->dataend) ++;
    }
  }
#line 1651
  if ((unsigned long )psf->peak_info != (unsigned long )((void *)0)) {
#line 1651
    if ((psf->peak_info)->peak_loc == 43) {
      {
#line 1652
      psf_binheader_writef(psf, "Em4I\270U", (unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24),
                           2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int )));
#line 1653
      __cil_tmp5 = time((time_t *)((void *)0));
#line 1653
      psf_binheader_writef(psf, "E44", 1, __cil_tmp5);
#line 1654
      k = 0;
      }
      {
#line 1654
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1654
        if (! (k < psf->sf.channels)) {
#line 1654
          goto while_break;
        }
        {
#line 1655
        psf_binheader_writef(psf, "Eft8", (double )((float )(psf->peak_info)->peaks[k].value),
                             (psf->peak_info)->peaks[k].position);
#line 1654
        k ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: ;
    }
  }
#line 1658
  if (psf->strings.flags & 2048U) {
    {
#line 1659
    aiff_write_strings(psf, 2048);
    }
  }
#line 1662
  if (psf->header.indx > 0L) {
    {
#line 1663
    psf_fwrite((void const   *)psf->header.ptr, psf->header.indx, (sf_count_t )1,
               psf);
    }
  }
#line 1665
  return (0);
}
}
#line 1669 "/root/patchweave_new/23/src/aiff.c"
static void aiff_write_strings(SF_PRIVATE *psf , int location ) 
{ 
  int k ;
  int slen ;
  unsigned long __cil_tmp5 ;
  size_t __cil_tmp6 ;

  {
#line 1672
  k = 0;
  {
#line 1672
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1672
    if (! (k < 32)) {
#line 1672
      goto while_break;
    }
#line 1673
    if (psf->strings.data[k].type == 0) {
#line 1674
      goto while_break;
    }
#line 1676
    if (psf->strings.data[k].flags != location) {
#line 1677
      goto while_continue;
    }
#line 1680
    if (psf->strings.data[k].type == 3) {
#line 1680
      goto case_3;
    }
#line 1685
    if (psf->strings.data[k].type == 1) {
#line 1685
      goto case_1;
    }
#line 1689
    if (psf->strings.data[k].type == 2) {
#line 1689
      goto case_2;
    }
#line 1693
    if (psf->strings.data[k].type == 4) {
#line 1693
      goto case_4;
    }
#line 1697
    if (psf->strings.data[k].type == 5) {
#line 1697
      goto case_5;
    }
#line 1679
    goto switch_break;
    case_3: 
    {
#line 1681
    __cil_tmp5 = strlen((char const   *)(psf->strings.storage + psf->strings.data[k].offset));
#line 1681
    slen = (int )__cil_tmp5;
#line 1682
    __cil_tmp6 = make_size_t(slen + (slen & 1));
#line 1682
    psf_binheader_writef(psf, "Em4mbU", (unsigned int )((65 | (80 << 8)) | (80 << 16)) | (76U << 24),
                         slen + 4, (unsigned int )((109 | (51 << 8)) | (103 << 16)) | (97U << 24),
                         psf->strings.storage + psf->strings.data[k].offset, __cil_tmp6);
    }
#line 1683
    goto switch_break;
    case_1: 
    {
#line 1686
    psf_binheader_writef(psf, "EmSI\270U", (unsigned int )((78 | (65 << 8)) | (77 << 16)) | (69U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1687
    goto switch_break;
    case_2: 
    {
#line 1690
    psf_binheader_writef(psf, "EmS", (unsigned int )((40 | (99 << 8)) | (41 << 16)) | (32U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1691
    goto switch_break;
    case_4: 
    {
#line 1694
    psf_binheader_writef(psf, "EmS", (unsigned int )((65 | (85 << 8)) | (84 << 16)) | (72U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1695
    goto switch_break;
    case_5: 
    {
#line 1698
    psf_binheader_writef(psf, "EmS", (unsigned int )((65 | (78 << 8)) | (78 << 16)) | (79U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1699
    goto switch_break;
    switch_break: 
#line 1672
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1709
  return;
}
}
#line 1713 "/root/patchweave_new/23/src/aiff.c"
static int aiff_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int UNUSED_datasize ) 
{ 
  AIFF_PRIVATE *paiff ;

  {
#line 1716
  paiff = (AIFF_PRIVATE *)psf->container_data;
#line 1716
  if ((unsigned long )paiff == (unsigned long )((void *)0)) {
#line 1717
    return (30);
  }
#line 1720
  if (command == 4353) {
#line 1720
    goto case_4353;
  }
#line 1724
  goto switch_default;
  case_4353: 
  {
#line 1721
  paiff->chanmap_tag = aiff_caf_find_channel_layout_tag((int const   *)psf->channel_map,
                                                        psf->sf.channels);
  }
#line 1722
  return (paiff->chanmap_tag != 0);
  switch_default: 
#line 1725
  goto switch_break;
  switch_break: ;
#line 1728
  return (0);
}
}
#line 1732 "/root/patchweave_new/23/src/aiff.c"
static char const   *get_loop_mode_str(int16_t mode ) 
{ 


  {
#line 1734
  if ((int )mode == 0) {
#line 1734
    goto case_0;
  }
#line 1735
  if ((int )mode == 1) {
#line 1735
    goto case_1;
  }
#line 1736
  if ((int )mode == 2) {
#line 1736
    goto case_2;
  }
#line 1733
  goto switch_break;
  case_0: 
#line 1734
  return ("none");
  case_1: 
#line 1735
  return ("forward");
  case_2: 
#line 1736
  return ("backward\220");
  switch_break: ;
#line 1739
  return ("*** unknownI\270U");
}
}
#line 1743 "/root/patchweave_new/23/src/aiff.c"
static int16_t get_loop_mode(int16_t mode ) 
{ 


  {
#line 1745
  if ((int )mode == 0) {
#line 1745
    goto case_0;
  }
#line 1746
  if ((int )mode == 1) {
#line 1746
    goto case_1;
  }
#line 1747
  if ((int )mode == 2) {
#line 1747
    goto case_2;
  }
#line 1744
  goto switch_break;
  case_0: 
#line 1745
  return ((int16_t )800);
  case_1: 
#line 1746
  return ((int16_t )801);
  case_2: 
#line 1747
  return ((int16_t )802);
  switch_break: ;
#line 1750
  return ((int16_t )800);
}
}
#line 1763 "/root/patchweave_new/23/src/aiff.c"
static int tenbytefloat2int(uint8_t *bytes ) 
{ 
  int val ;

  {
#line 1764
  val = 3;
#line 1766
  if ((int )*(bytes + 0) & 128) {
#line 1767
    return (0);
  }
#line 1769
  if ((int )*(bytes + 0) <= 63) {
#line 1770
    return (1);
  }
#line 1772
  if ((int )*(bytes + 0) > 64) {
#line 1773
    return (67108864);
  }
#line 1775
  if ((int )*(bytes + 0) == 64) {
#line 1775
    if ((int )*(bytes + 1) > 28) {
#line 1776
      return (800000000);
    }
  }
#line 1780
  val = ((((int )*(bytes + 2) << 23) | ((int )*(bytes + 3) << 15)) | ((int )*(bytes + 4) << 7)) | ((int )*(bytes + 5) >> 1);
#line 1782
  val >>= 29 - (int )*(bytes + 1);
#line 1784
  return (val);
}
}
#line 1788 "/root/patchweave_new/23/src/aiff.c"
static void uint2tenbytefloat(uint32_t num , uint8_t *bytes ) 
{ 
  uint32_t mask ;
  int count___0 ;
  uint32_t tmp ;

  {
#line 1789
  mask = (uint32_t )1073741824;
#line 1792
  if (num <= 1U) {
#line 1793
    *(bytes + 0) = (uint8_t )63;
#line 1794
    *(bytes + 1) = (uint8_t )255;
#line 1795
    *(bytes + 2) = (uint8_t )128;
#line 1796
    return;
  }
#line 1799
  *(bytes + 0) = (uint8_t )64;
#line 1801
  if (num >= mask) {
#line 1802
    *(bytes + 1) = (uint8_t )29;
#line 1803
    return;
  }
#line 1806
  count___0 = 0;
  {
#line 1806
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1806
    if (! (count___0 < 32)) {
#line 1806
      goto while_break;
    }
#line 1807
    if (num & mask) {
#line 1808
      goto while_break;
    }
#line 1809
    mask >>= 1;
#line 1806
    count___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1812
  if (count___0 < 31) {
#line 1812
    tmp = num << (count___0 + 1);
  } else {
#line 1812
    tmp = 0U;
  }
#line 1812
  num = tmp;
#line 1813
  *(bytes + 1) = (uint8_t )(29 - count___0);
#line 1814
  *(bytes + 2) = (uint8_t )((num >> 24) & 255U);
#line 1815
  *(bytes + 3) = (uint8_t )((num >> 16) & 255U);
#line 1816
  *(bytes + 4) = (uint8_t )((num >> 8) & 255U);
#line 1817
  *(bytes + 5) = (uint8_t )(num & 255U);
#line 1818
  return;
}
}
#line 1822 "/root/patchweave_new/23/src/aiff.c"
static int aiff_read_basc_chunk(SF_PRIVATE *psf , int datasize ) 
{ 
  char const   *type_str ;
  basc_CHUNK bc ;
  int count___0 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 1827
  count___0 = psf_binheader_readf(psf, "E442", & bc.version, & bc.numBeats, & bc.rootNote);
#line 1828
  __cil_tmp7 = psf_binheader_readf(psf, "E222\270U", & bc.scaleType, & bc.sigNumerator,
                                   & bc.sigDenominator);
#line 1828
  count___0 += __cil_tmp7;
#line 1829
  __cil_tmp8 = psf_binheader_readf(psf, "E2jI\270U", & bc.loopType, (unsigned long )datasize - sizeof(bc));
#line 1829
  count___0 += __cil_tmp8;
#line 1831
  psf_log_printf(psf, "  Version ? : %u\n  Num Beats : %u\n  Root Note : 0x%x\nU",
                 bc.version, bc.numBeats, (int )bc.rootNote);
  }
#line 1835
  if ((int )bc.scaleType == 1) {
#line 1835
    goto case_1;
  }
#line 1838
  if ((int )bc.scaleType == 2) {
#line 1838
    goto case_2;
  }
#line 1841
  if ((int )bc.scaleType == 3) {
#line 1841
    goto case_3;
  }
#line 1844
  if ((int )bc.scaleType == 4) {
#line 1844
    goto case_4;
  }
#line 1847
  goto switch_default;
  case_1: 
#line 1836
  type_str = "MINORU";
#line 1837
  goto switch_break;
  case_2: 
#line 1839
  type_str = "MAJORU";
#line 1840
  goto switch_break;
  case_3: 
#line 1842
  type_str = "NEITHER";
#line 1843
  goto switch_break;
  case_4: 
#line 1845
  type_str = "BOTH\270U";
#line 1846
  goto switch_break;
  switch_default: 
#line 1848
  type_str = "!!WRONG!!\355\nI\270U";
#line 1849
  goto switch_break;
  switch_break: 
  {
#line 1852
  psf_log_printf(psf, "  ScaleType : 0x%x (%s)\n\230\001", (int )bc.scaleType, type_str);
#line 1853
  psf_log_printf(psf, "  Time Sig  : %d/%d\n\270U", (int )bc.sigNumerator, (int )bc.sigDenominator);
  }
#line 1856
  if ((int )bc.loopType == 1) {
#line 1856
    goto case_1___0;
  }
#line 1859
  if ((int )bc.loopType == 0) {
#line 1859
    goto case_0;
  }
#line 1862
  goto switch_default___0;
  case_1___0: 
#line 1857
  type_str = "One Shot\220";
#line 1858
  goto switch_break___0;
  case_0: 
#line 1860
  type_str = "Loop";
#line 1861
  goto switch_break___0;
  switch_default___0: 
#line 1863
  type_str = "!!WRONG!!";
#line 1864
  goto switch_break___0;
  switch_break___0: 
  {
#line 1867
  psf_log_printf(psf, "  Loop Type : 0x%x (%s)\n\230\001", (int )bc.loopType, type_str);
#line 1869
  tmp___0 = calloc(1UL, sizeof(SF_LOOP_INFO ));
#line 1869
  psf->loop_info = (SF_LOOP_INFO *)tmp___0;
  }
#line 1869
  if ((unsigned long )psf->loop_info == (unsigned long )((void *)0)) {
#line 1870
    return (17);
  }
#line 1872
  (psf->loop_info)->time_sig_num = (short )bc.sigNumerator;
#line 1873
  (psf->loop_info)->time_sig_den = (short )bc.sigDenominator;
#line 1874
  if ((int )bc.loopType == 1) {
#line 1874
    tmp = 800;
  } else {
#line 1874
    tmp = 801;
  }
#line 1874
  (psf->loop_info)->loop_mode = tmp;
#line 1875
  (psf->loop_info)->num_beats = (int )bc.numBeats;
#line 1878
  (psf->loop_info)->bpm = (float )((((1. / (double )psf->sf.frames) * (double )psf->sf.samplerate) * (((double )bc.numBeats * 4.) / (double )((int )bc.sigDenominator))) * 60.);
#line 1880
  (psf->loop_info)->root_key = (int )bc.rootNote;
#line 1882
  if (count___0 < datasize) {
    {
#line 1883
    psf_binheader_readf(psf, "j\315\nI\270U", datasize - count___0);
    }
  }
#line 1885
  return (0);
}
}
#line 1890 "/root/patchweave_new/23/src/aiff.c"
static int aiff_read_chanmap(SF_PRIVATE *psf , unsigned int dword ) 
{ 
  AIFF_CAF_CHANNEL_MAP *map_info ;
  unsigned int channel_bitmap ;
  unsigned int channel_decriptions ;
  unsigned int bytesread ;
  int layout_tag ;
  int __cil_tmp8 ;
  size_t chanmap_size ;
  void *tmp ;

  {
  {
#line 1895
  __cil_tmp8 = psf_binheader_readf(psf, "444I\270U", & layout_tag, & channel_bitmap,
                                   & channel_decriptions);
#line 1895
  bytesread = (unsigned int )__cil_tmp8;
#line 1897
  map_info = aiff_caf_of_channel_layout_tag(layout_tag);
  }
#line 1897
  if ((unsigned long )map_info == (unsigned long )((void *)0)) {
#line 1898
    return (0);
  }
  {
#line 1900
  psf_log_printf(psf, "  Tag    : %x\n", layout_tag);
  }
#line 1901
  if (map_info) {
    {
#line 1902
    psf_log_printf(psf, "  Layout : %s\n", map_info->name);
    }
  }
#line 1904
  if (bytesread < dword) {
    {
#line 1905
    psf_binheader_readf(psf, "j\226\fI\270U", dword - bytesread);
    }
  }
#line 1907
  if ((unsigned long )map_info->channel_map != (unsigned long )((void *)0)) {
    {
#line 1908
    chanmap_size = (unsigned long )psf->sf.channels * sizeof(*(psf->channel_map + 0));
#line 1910
    free((void *)psf->channel_map);
#line 1912
    tmp = malloc(chanmap_size);
#line 1912
    psf->channel_map = (int *)tmp;
    }
#line 1912
    if ((unsigned long )psf->channel_map == (unsigned long )((void *)0)) {
#line 1913
      return (17);
    }
    {
#line 1915
    memcpy((void *)psf->channel_map, (void const   *)map_info->channel_map, chanmap_size);
    }
  }
#line 1918
  return (0);
}
}
#line 1925 "/root/patchweave_new/23/src/aiff.c"
static int aiff_set_chunk(SF_PRIVATE *psf , SF_CHUNK_INFO *chunk_info ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1926
  __cil_tmp3 = psf_save_write_chunk(& psf->wchunks, chunk_info);
  }
#line 1926
  return (__cil_tmp3);
}
}
#line 1930 "/root/patchweave_new/23/src/aiff.c"
static SF_CHUNK_ITERATOR *aiff_next_chunk_iterator(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator ) 
{ 
  SF_CHUNK_ITERATOR *__cil_tmp3 ;

  {
  {
#line 1931
  __cil_tmp3 = psf_next_chunk_iterator(& psf->rchunks, iterator);
  }
#line 1931
  return (__cil_tmp3);
}
}
#line 1935 "/root/patchweave_new/23/src/aiff.c"
static int aiff_get_chunk_size(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  int indx ;

  {
  {
#line 1938
  indx = psf_find_read_chunk_iterator(& psf->rchunks, iterator);
  }
#line 1938
  if (indx < 0) {
#line 1939
    return (168);
  }
#line 1941
  chunk_info->datalen = (psf->rchunks.chunks + indx)->len;
#line 1943
  return (0);
}
}
#line 1947 "/root/patchweave_new/23/src/aiff.c"
static int aiff_get_chunk_data(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  sf_count_t pos ;
  int indx ;

  {
  {
#line 1951
  indx = psf_find_read_chunk_iterator(& psf->rchunks, iterator);
  }
#line 1951
  if (indx < 0) {
#line 1952
    return (168);
  }
#line 1954
  if ((unsigned long )chunk_info->data == (unsigned long )((void *)0)) {
#line 1955
    return (171);
  }
  {
#line 1957
  chunk_info->id_size = (psf->rchunks.chunks + indx)->id_size;
#line 1958
  memcpy((void *)(chunk_info->id), (void const   *)((psf->rchunks.chunks + indx)->id),
         sizeof(chunk_info->id) / sizeof(chunk_info->id[0]));
#line 1960
  pos = psf_ftell(psf);
#line 1961
  psf_fseek(psf, (psf->rchunks.chunks + indx)->offset, 0);
#line 1962
  psf_fread(chunk_info->data, (sf_count_t )0, (sf_count_t )1, psf);
#line 1963
  psf_fseek(psf, pos, 0);
  }
#line 1965
  return (0);
}
}
#line 57 "/root/patchweave_new/23/src/sndfile.c"
static ErrorStruct SndfileErrors[177]  = 
#line 57 "/root/patchweave_new/23/src/sndfile.c"
  {      {0, "No Error."}, 
        {1, "Format not recognised."}, 
        {2, "System error."}, 
        {3, "Supported file format but file is malformed."}, 
        {4, "Supported file format but unsupported encoding."}, 
        {5, "Error : major format is 0."}, 
        {6, "Error : minor format is 0."}, 
        {7, "File does not exist or is not a regular file (possibly a pipe?).\250"}, 
        {8, "File exists but no data could be read."}, 
        {9, "Could not open file.\270U"}, 
        {10, "Not a valid SNDFILE* pointer."}, 
        {11, "NULL SF_INFO pointer passed to libsndfile."}, 
        {12, "SF_PRIVATE struct incomplete and end of header parsing."}, 
        {13, "Bad FILE pointer."}, 
        {14, "Internal error, Bad pointer."}, 
        {15, "Error : software was misconfigured at compile time (sizeof statbuf.st_size)."}, 
        {16,
      "Error : Could not file temp dir.\250"}, 
        {17, "Internal malloc () failed."}, 
        {18, "File contains data in an unimplemented format."}, 
        {19, "Attempt to read a non-integer number of channels."}, 
        {20, "Attempt to write a non-integer number of channels."}, 
        {21, "File contains data in an unknown format.\250"}, 
        {22, "Read attempted on file currently open for write.\250"}, 
        {23, "Write attempted on file currently open for read.\250"}, 
        {24, "Error : This file format does not support read/write mode."}, 
        {25, "Internal error : SF_INFO struct incomplete."}, 
        {26, "Error : supplied offset beyond end of file."}, 
        {27, "Error : embedding not supported for this file format."}, 
        {28, "Error : cannot open embedded file read/write.U"}, 
        {29, "Error : this file format does not support pipe write.U"}, 
        {36, "Error : bad pointer on SF_VIRTUAL_IO struct."}, 
        {50, "Error : bad coding_history_size in SF_BROADCAST_INFO struct."}, 
        {51, "Error : SF_BROADCAST_INFO struct too large.I\270U"}, 
        {52, "Error: SF_CART_INFO struct too large."}, 
        {53, "Error: bad tag_text_size in SF_CART_INFO struct.\250"}, 
        {37, "Attempt to write to file with non-interleaved data."}, 
        {38, "Bad karma in seek during interleave read operation."}, 
        {39, "Bad karma in read during interleave read operation."}, 
        {30, "Unspecified internal error."}, 
        {31, "Bad parameter passed to function sf_command.\270U"}, 
        {32, "Bad endian-ness. Try default endian-ness\250"}, 
        {33, "Channel count is zero."}, 
        {34, "Too many channels specified."}, 
        {35, "Bad channel count.\025I\270U"}, 
        {40, "Internal psf_fseek() failed."}, 
        {41, "Seek attempted on unseekable file type."}, 
        {42, "Error : combination of file open mode and seek command is ambiguous."}, 
        {43,
      "Error : invalid seek parameters.\250"}, 
        {44, "Error : parameters OK, but psf_seek() failed."}, 
        {45, "Error : bad mode parameter for file open."}, 
        {46, "Error : attempt to open a pipe in read/write mode."}, 
        {47, "Error on RDWR position (cryptic)."}, 
        {48, "Error : Cannot open file in read/write mode due to string data in header."}, 
        {49,
      "Error : Command fails because file already has audio data."}, 
        {54, "Error : File type does not support string data."}, 
        {55, "Error : Trying to set a string when file is not in write mode."}, 
        {56, "Error : Maximum string data storage reached."}, 
        {57, "Error : Maximum string data count reached."}, 
        {58, "Error : Bad string data type."}, 
        {59, "Error : file type does not support strings added at end of file.\250"}, 
        {60,
      "Error : bad string."}, 
        {61, "Error : Weird string error."}, 
        {62, "Error in WAV file. No \'RIFF\' chunk marker."}, 
        {63, "Error in WAV file. No \'WAVE\' chunk marker."}, 
        {64, "Error in WAV/W64/RF64 file. No \'fmt \' chunk marker."}, 
        {65, "Error in WAV/W64/RF64 file. Malformed \'fmt \' chunk."}, 
        {66, "Error in WAV/W64/RF64 file. Short \'fmt \' chunk."}, 
        {67, "Error in WAV file. \'fact\' chunk out of place.U"}, 
        {68, "Error in WAV file. Bad \'PEAK\' chunk."}, 
        {69, "Error in WAV file. \'PEAK\' chunk found before \'fmt \' chunk."}, 
        {70, "Error in WAV file. Errors in \'fmt \' chunk."}, 
        {71, "Error in WAV file. Block alignment in \'fmt \' chunk is incorrect.\250"}, 
        {72,
      "Error in WAV file. No \'data\' chunk marker."}, 
        {73, "Error in WAV file. Malformed LIST chunk.\250"}, 
        {78, "Error in WAV file. File contains an unknown chunk marker."}, 
        {79, "Error in WAV file. Data is in WAVPACK format."}, 
        {74, "Error in ADPCM WAV file. Invalid bit width."}, 
        {75, "Error in ADPCM WAV file. Invalid number of channels."}, 
        {76, "Error in ADPCM WAV file. Invalid number of samples per block."}, 
        {77, "Error in GSM610 WAV file. Invalid format chunk."}, 
        {80, "Error in AIFF file, bad \'FORM\' marker."}, 
        {81, "Error in AIFF file, \'AIFF\' marker without \'FORM\'."}, 
        {82, "Error in AIFF file, \'COMM\' marker without \'FORM\'."}, 
        {83, "Error in AIFF file, \'SSND\' marker without \'COMM\'."}, 
        {84, "Error in AIFF file, unknown chunk."}, 
        {85, "Error in AIFF file, bad \'COMM\' chunk size."}, 
        {86, "Error in AIFF file, bad \'COMM\' chunk."}, 
        {87, "Error in AIFF file. \'PEAK\' chunk found before \'COMM\' chunk."}, 
        {88, "Error in AIFF file. Bad \'PEAK\' chunk."}, 
        {89, "Error in AIFF file, bad \'SSND\' chunk."}, 
        {90, "Error in AIFF file, no sound data."}, 
        {91, "Error in AIFF file, RDWR only possible if SSND chunk at end of file.\004"}, 
        {92,
      "Error in AU file, unknown format."}, 
        {93, "Error in AU file, missing \'.snd\' or \'dns.\' marker."}, 
        {94, "Embedded AU file with unknown length."}, 
        {95, "Error while opening RAW file for read. Must specify format and channels.\nPossibly trying to open unsupported format.\250"}, 
        {96,
      "Error. RAW file bitwidth must be a multiple of 8."}, 
        {97, "Error. Bad format field in SF_INFO struct when opening a RAW file for read."}, 
        {98,
      "Error in PAF file, no marker."}, 
        {99, "Error in PAF file, bad version."}, 
        {100, "Error in PAF file, unknown format."}, 
        {101, "Error in PAF file. File shorter than minimal header."}, 
        {102, "Error in PAF file. Bad channel count."}, 
        {103, "Error in 8SVX / 16SV file, no \'FORM\' marker."}, 
        {104, "Error in 8SVX / 16SV file, no \'BODY\' marker.\004"}, 
        {105, "Error in 8SVX / 16SV file, no sound data."}, 
        {106, "Error in 8SVX / 16SV file, unsupported compression format."}, 
        {107, "Error in 8SVX / 16SV file, NAME chunk too long."}, 
        {108, "Error in NIST file, bad header."}, 
        {109, "Error : NIST file damaged by Windows CR -> CRLF conversion process."}, 
        {110,
      "Error in NIST file, unsupported compression format."}, 
        {111, "Error in VOC file, no \'Creative Voice File\' marker."}, 
        {112, "Error in VOC file, bad format."}, 
        {113, "Error in VOC file, bad version number."}, 
        {114, "Error in VOC file, bad marker in file."}, 
        {115, "Error in VOC file, incompatible VOC sections."}, 
        {116, "Error in VOC file, more than one sample rate defined."}, 
        {117, "Unimplemented VOC file feature, file contains multiple sound sections."}, 
        {118,
      "Error in VOC file, file contains multiple bit or channel widths.\250"}, 
        {119, "Error in VOC file, too many sections."}, 
        {120, "Error : not able to operate on VOC files over a pipe."}, 
        {121, "Error in IRCAM file, bad IRCAM marker."}, 
        {122, "Error in IRCAM file, bad channel count."}, 
        {123, "Error in IRCAM file, unknown encoding format."}, 
        {124, "Error in W64 file, file contains 64 bit offset."}, 
        {125, "Error in W64 file. No \'riff\' chunk marker."}, 
        {126, "Error in W64 file. No \'wave\' chunk marker."}, 
        {127, "Error in W64 file. No \'data\' chunk marker."}, 
        {128, "Error in ADPCM W64 file. Invalid bit width."}, 
        {129, "Error in ADPCM W64 file. Invalid number of channels."}, 
        {130, "Error in GSM610 W64 file. Invalid format chunk."}, 
        {131, "Error in MAT4 file. No variable name."}, 
        {132, "Error in MAT4 file. No sample rate."}, 
        {133, "Error in MAT5 file. Not able to determine endian-ness."}, 
        {134, "Error in MAT5 file. Bad block structure.\250"}, 
        {135, "Error in MAT5 file. Not able to determine sample rate."}, 
        {136, "Error in PVF file. No PVF1 marker."}, 
        {137, "Error in PVF file. Bad header."}, 
        {138, "Error in PVF file. Bad bit width."}, 
        {141, "Error in XI file. Bad header."}, 
        {142, "Error in XI file. Excess samples in file."}, 
        {143, "Error : not able to operate on XI files over a pipe."}, 
        {144, "Error : not able to operate on HTK files over a pipe."}, 
        {145, "Error : not an SDS file.\250"}, 
        {146, "Error : bad bit width for SDS file."}, 
        {147, "Error : cannot open SD2 file without a file name."}, 
        {148, "Error : bad data offset.\250"}, 
        {149, "Error : bad map offset."}, 
        {150, "Error : bad data length.\250"}, 
        {151, "Error : bad map length."}, 
        {152, "Error : bad resource fork."}, 
        {153, "Error : bad sample size."}, 
        {154, "Error : bad flac header.\250"}, 
        {155, "Error : problem while creating flac decoder."}, 
        {156, "Error : problem with initialization of the flac decoder.\250"}, 
        {157, "Error : flac decoder lost sync."}, 
        {158, "Error : flac does not support this sample rate."}, 
        {159, "Error : flac channel changed mid stream.\250"}, 
        {160, "Error : unknown error in flac decoder."}, 
        {161, "Error : not a WVE file."}, 
        {162, "Error : not able to operate on WVE files over a pipe."}, 
        {139, "Error : Bad bit width for DWVW encoding. Must be 12, 16 or 24."}, 
        {140, "Error : G72x encoding does not support more than 1 channel."}, 
        {163, "Error : Sample rate chosen is known to trigger a Vorbis encoder bug on this CPU.\250"}, 
        {164,
      "Error : Not an RF64 file."}, 
        {165, "Error in RF64 file. \'PEAK\' chunk found before \'fmt \' chunk."}, 
        {166, "Error in RF64 file. No \'data\' chunk marker."}, 
        {172, "Error : Failed to open tmp file for ALAC encoding."}, 
        {167, "Error : Bad SF_CHUNK_INFO pointer."}, 
        {168, "Error : Unknown chunk marker."}, 
        {169, "Error : Reading/writing chunks from this file format is not supported."}, 
        {170,
      "Error : Bad chunk marker."}, 
        {171, "Error : Bad data pointer in SF_CHUNK_INFO struct."}, 
        {173, "Error : Supplied filename too long."}, 
        {174, "Error : Length parameter passed to read/write is negative."}, 
        {175, "Maximum error number."}, 
        {176, (char const   *)((void *)0)}};
#line 280
static int format_from_extension(SF_PRIVATE *psf ) ;
#line 281
static int guess_file_type(SF_PRIVATE *psf ) ;
#line 282
static int validate_sfinfo(SF_INFO *sfinfo ) ;
#line 283
static int validate_psf(SF_PRIVATE *psf ) ;
#line 284
static void save_header_info(SF_PRIVATE *psf ) ;
#line 285
static int copy_filename(SF_PRIVATE *psf , char const   *path ) ;
#line 286
static int psf_close(SF_PRIVATE *psf ) ;
#line 288
static int try_resource_fork(SF_PRIVATE *psf ) ;
#line 294 "/root/patchweave_new/23/src/sndfile.c"
int sf_errno  =    0;
#line 295 "/root/patchweave_new/23/src/sndfile.c"
static char sf_parselog[8192]  = {      (char)0};
#line 296 "/root/patchweave_new/23/src/sndfile.c"
static char sf_syserr[256]  = {      (char)0};
#line 325 "/root/patchweave_new/23/src/sndfile.c"
SNDFILE *sf_open(char const   *path , int mode , SF_INFO *sfinfo ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  SNDFILE *__cil_tmp11 ;

  {
  {
#line 331
  psf = psf_allocate();
  }
#line 331
  if ((unsigned long )psf == (unsigned long )((void *)0)) {
#line 332
    sf_errno = 17;
#line 333
    return ((SNDFILE *)((void *)0));
  }
  {
#line 336
  psf_init_files(psf);
#line 338
  psf_log_printf(psf, "File : %s\n", path);
#line 340
  __cil_tmp7 = copy_filename(psf, path);
  }
#line 340
  if (__cil_tmp7 != 0) {
#line 341
    sf_errno = psf->error;
#line 342
    return ((SNDFILE *)((void *)0));
  }
  {
#line 345
  psf->file.mode = mode;
#line 346
  __cil_tmp8 = strcmp(path, "-");
  }
#line 346
  if (__cil_tmp8 == 0) {
    {
#line 347
    psf->error = psf_set_stdio(psf);
    }
  } else {
    {
#line 349
    psf->error = psf_fopen(psf);
    }
  }
  {
#line 351
  __cil_tmp11 = psf_open_file(psf, sfinfo);
  }
#line 351
  return (__cil_tmp11);
}
}
#line 356 "/root/patchweave_new/23/src/sndfile.c"
SNDFILE *sf_open_fd(int fd , int mode , SF_INFO *sfinfo , int close_desc ) 
{ 
  SF_PRIVATE *psf ;
  SNDFILE *__cil_tmp9 ;

  {
#line 359
  if ((sfinfo->format & 268369920) == 1441792) {
#line 360
    sf_errno = 147;
#line 361
    return ((SNDFILE *)((void *)0));
  }
  {
#line 364
  psf = psf_allocate();
  }
#line 364
  if ((unsigned long )psf == (unsigned long )((void *)0)) {
#line 365
    sf_errno = 17;
#line 366
    return ((SNDFILE *)((void *)0));
  }
  {
#line 369
  psf_init_files(psf);
#line 370
  copy_filename(psf, "\220");
#line 372
  psf->file.mode = mode;
#line 373
  psf_set_file(psf, fd);
#line 374
  psf->is_pipe = psf_is_pipe(psf);
#line 375
  psf->fileoffset = psf_ftell(psf);
  }
#line 377
  if (! close_desc) {
#line 378
    psf->file.do_not_close_descriptor = 1;
  }
  {
#line 380
  __cil_tmp9 = psf_open_file(psf, sfinfo);
  }
#line 380
  return (__cil_tmp9);
}
}
#line 385 "/root/patchweave_new/23/src/sndfile.c"
SNDFILE *sf_open_virtual(SF_VIRTUAL_IO *sfvirtual , int mode , SF_INFO *sfinfo , void *user_data ) 
{ 
  SF_PRIVATE *psf ;
  SNDFILE *__cil_tmp7 ;

  {
#line 389
  if ((unsigned long )sfvirtual->get_filelen == (unsigned long )((void *)0)) {
    {
#line 390
    sf_errno = 36;
#line 391
    snprintf(sf_parselog, sizeof(sf_parselog), "Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\nI\270U");
    }
#line 392
    return ((SNDFILE *)((void *)0));
  } else
#line 389
  if ((unsigned long )sfvirtual->seek == (unsigned long )((void *)0)) {
    {
#line 390
    sf_errno = 36;
#line 391
    snprintf(sf_parselog, sizeof(sf_parselog), "Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\nI\270U");
    }
#line 392
    return ((SNDFILE *)((void *)0));
  } else
#line 389
  if ((unsigned long )sfvirtual->tell == (unsigned long )((void *)0)) {
    {
#line 390
    sf_errno = 36;
#line 391
    snprintf(sf_parselog, sizeof(sf_parselog), "Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\nI\270U");
    }
#line 392
    return ((SNDFILE *)((void *)0));
  }
#line 395
  if ((unsigned long )sfvirtual->read == (unsigned long )((void *)0)) {
#line 395
    if (mode == 16) {
      {
#line 396
      sf_errno = 36;
#line 397
      snprintf(sf_parselog, sizeof(sf_parselog), "Bad vio_read in SF_VIRTUAL_IO struct.\n");
      }
#line 398
      return ((SNDFILE *)((void *)0));
    } else
#line 395
    if (mode == 48) {
      {
#line 396
      sf_errno = 36;
#line 397
      snprintf(sf_parselog, sizeof(sf_parselog), "Bad vio_read in SF_VIRTUAL_IO struct.\n");
      }
#line 398
      return ((SNDFILE *)((void *)0));
    }
  }
#line 401
  if ((unsigned long )sfvirtual->write == (unsigned long )((void *)0)) {
#line 401
    if (mode == 32) {
      {
#line 402
      sf_errno = 36;
#line 403
      snprintf(sf_parselog, sizeof(sf_parselog), "Bad vio_write in SF_VIRTUAL_IO struct.\n");
      }
#line 404
      return ((SNDFILE *)((void *)0));
    } else
#line 401
    if (mode == 48) {
      {
#line 402
      sf_errno = 36;
#line 403
      snprintf(sf_parselog, sizeof(sf_parselog), "Bad vio_write in SF_VIRTUAL_IO struct.\n");
      }
#line 404
      return ((SNDFILE *)((void *)0));
    }
  }
  {
#line 407
  psf = psf_allocate();
  }
#line 407
  if ((unsigned long )psf == (unsigned long )((void *)0)) {
#line 408
    sf_errno = 17;
#line 409
    return ((SNDFILE *)((void *)0));
  }
  {
#line 412
  psf_init_files(psf);
#line 414
  psf->virtual_io = 1;
#line 415
  psf->vio = *sfvirtual;
#line 416
  psf->vio_user_data = user_data;
#line 418
  psf->file.mode = mode;
#line 420
  __cil_tmp7 = psf_open_file(psf, sfinfo);
  }
#line 420
  return (__cil_tmp7);
}
}
#line 425 "/root/patchweave_new/23/src/sndfile.c"
int sf_close(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 428
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 428
    sf_errno = 10;
#line 428
    return (0);
  }
  {
#line 428
  psf = (SF_PRIVATE *)sndfile;
#line 428
  __cil_tmp3 = psf_file_valid(psf);
  }
#line 428
  if (psf->virtual_io == 0) {
#line 428
    if (__cil_tmp3 == 0) {
#line 428
      psf->error = 13;
#line 428
      return (0);
    }
  }
#line 428
  if (psf->Magick != 305447134) {
#line 428
    psf->error = 10;
#line 428
    return (0);
  }
  {
#line 428
  psf->error = 0;
#line 430
  __cil_tmp4 = psf_close(psf);
  }
#line 430
  return (__cil_tmp4);
}
}
#line 435 "/root/patchweave_new/23/src/sndfile.c"
void sf_write_sync(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;

  {
#line 438
  psf = (SF_PRIVATE *)sndfile;
#line 438
  if ((unsigned long )psf == (unsigned long )((void *)0)) {
#line 439
    return;
  }
  {
#line 441
  psf_fsync(psf);
  }
#line 443
  return;
}
}
#line 453 "/root/patchweave_new/23/src/sndfile.c"
static char const   *bad_errnum  ;
#line 451 "/root/patchweave_new/23/src/sndfile.c"
char const   *sf_error_number(int errnum ) 
{ 
  int k ;

  {
#line 452
  bad_errnum = "No error defined for this error number. This is a bug in libsndfile.";
#line 456
  if (errnum == 175) {
#line 457
    return (SndfileErrors[0].str);
  }
#line 459
  if (errnum < 0) {
    {
#line 461
    printf("Not a valid error number (%d).\n", errnum);
    }
#line 462
    return (bad_errnum);
  } else
#line 459
  if (errnum > 175) {
    {
#line 461
    printf("Not a valid error number (%d).\n", errnum);
    }
#line 462
    return (bad_errnum);
  }
#line 465
  k = 0;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;

#line 465
    if (! SndfileErrors[k].str) {
#line 465
      goto while_break;
    }
#line 466
    if (errnum == SndfileErrors[k].error) {
#line 467
      return (SndfileErrors[k].str);
    }
#line 465
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 469
  return (bad_errnum);
}
}
#line 474 "/root/patchweave_new/23/src/sndfile.c"
char const   *sf_strerror(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;
  int errnum ;
  char const   *__cil_tmp4 ;

  {
#line 475
  psf = (SF_PRIVATE *)((void *)0);
#line 478
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 479
    errnum = sf_errno;
#line 480
    if (errnum == 2) {
#line 480
      if ((int )sf_syserr[0]) {
#line 481
        return ((char const   *)(sf_syserr));
      }
    }
  } else {
#line 484
    psf = (SF_PRIVATE *)sndfile;
#line 486
    if (psf->Magick != 305447134) {
#line 487
      return ("sf_strerror : Bad magic number.");
    }
#line 489
    errnum = psf->error;
#line 491
    if (errnum == 2) {
#line 491
      if ((int )psf->syserr[0]) {
#line 492
        return ((char const   *)(psf->syserr));
      }
    }
  }
  {
#line 495
  __cil_tmp4 = sf_error_number(errnum);
  }
#line 495
  return (__cil_tmp4);
}
}
#line 503 "/root/patchweave_new/23/src/sndfile.c"
int sf_error(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp3 ;

  {
#line 506
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 507
    return (sf_errno);
  }
#line 509
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 509
    sf_errno = 10;
#line 509
    return (0);
  }
  {
#line 509
  psf = (SF_PRIVATE *)sndfile;
#line 509
  __cil_tmp3 = psf_file_valid(psf);
  }
#line 509
  if (psf->virtual_io == 0) {
#line 509
    if (__cil_tmp3 == 0) {
#line 509
      psf->error = 13;
#line 509
      return (0);
    }
  }
#line 509
  if (psf->Magick != 305447134) {
#line 509
    psf->error = 10;
#line 509
    return (0);
  }
#line 511
  if (psf->error) {
#line 512
    return (psf->error);
  }
#line 514
  return (0);
}
}
#line 522 "/root/patchweave_new/23/src/sndfile.c"
int sf_perror(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;
  int errnum ;
  int __cil_tmp4 ;
  char const   *__cil_tmp5 ;

  {
#line 526
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 527
    errnum = sf_errno;
  } else {
#line 530
    if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 530
      sf_errno = 10;
#line 530
      return (0);
    }
    {
#line 530
    psf = (SF_PRIVATE *)sndfile;
#line 530
    __cil_tmp4 = psf_file_valid(psf);
    }
#line 530
    if (psf->virtual_io == 0) {
#line 530
      if (__cil_tmp4 == 0) {
#line 530
        psf->error = 13;
#line 530
        return (0);
      }
    }
#line 530
    if (psf->Magick != 305447134) {
#line 530
      psf->error = 10;
#line 530
      return (0);
    }
#line 531
    errnum = psf->error;
  }
  {
#line 534
  __cil_tmp5 = sf_error_number(errnum);
#line 534
  fprintf(stderr, "%s\n", __cil_tmp5);
  }
#line 535
  return (0);
}
}
#line 544 "/root/patchweave_new/23/src/sndfile.c"
int sf_error_str(SNDFILE *sndfile , char *str___0 , size_t maxlen ) 
{ 
  SF_PRIVATE *psf ;
  int errnum ;
  int __cil_tmp6 ;
  char const   *__cil_tmp7 ;

  {
#line 548
  if ((unsigned long )str___0 == (unsigned long )((void *)0)) {
#line 549
    return (30);
  }
#line 551
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 552
    errnum = sf_errno;
  } else {
#line 554
    if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 554
      sf_errno = 10;
#line 554
      return (0);
    }
    {
#line 554
    psf = (SF_PRIVATE *)sndfile;
#line 554
    __cil_tmp6 = psf_file_valid(psf);
    }
#line 554
    if (psf->virtual_io == 0) {
#line 554
      if (__cil_tmp6 == 0) {
#line 554
        psf->error = 13;
#line 554
        return (0);
      }
    }
#line 554
    if (psf->Magick != 305447134) {
#line 554
      psf->error = 10;
#line 554
      return (0);
    }
#line 555
    errnum = psf->error;
  }
  {
#line 558
  __cil_tmp7 = sf_error_number(errnum);
#line 558
  snprintf(str___0, maxlen, "%s", __cil_tmp7);
  }
#line 560
  return (0);
}
}
#line 568 "/root/patchweave_new/23/src/sndfile.c"
int sf_format_check(SF_INFO *info ) 
{ 
  int subformat ;
  int endian ;

  {
#line 571
  subformat = info->format & 65535;
#line 572
  endian = info->format & 805306368;
#line 579
  if (info->channels < 1) {
#line 580
    return (0);
  } else
#line 579
  if (info->channels > 1024) {
#line 580
    return (0);
  }
#line 582
  if (info->samplerate < 0) {
#line 583
    return (0);
  }
#line 586
  if ((info->format & 268369920) == 65536) {
#line 586
    goto case_65536;
  }
#line 604
  if ((info->format & 268369920) == 1245184) {
#line 604
    goto case_1245184;
  }
#line 617
  if ((info->format & 268369920) == 131072) {
#line 617
    goto case_131072;
  }
#line 639
  if ((info->format & 268369920) == 196608) {
#line 639
    goto case_196608;
  }
#line 656
  if ((info->format & 268369920) == 1572864) {
#line 656
    goto case_1572864;
  }
#line 671
  if ((info->format & 268369920) == 262144) {
#line 671
    goto case_262144;
  }
#line 689
  if ((info->format & 268369920) == 327680) {
#line 689
    goto case_327680;
  }
#line 694
  if ((info->format & 268369920) == 393216) {
#line 694
    goto case_393216;
  }
#line 706
  if ((info->format & 268369920) == 458752) {
#line 706
    goto case_458752;
  }
#line 715
  if ((info->format & 268369920) == 655360) {
#line 715
    goto case_655360;
  }
#line 724
  if ((info->format & 268369920) == 524288) {
#line 724
    goto case_524288;
  }
#line 736
  if ((info->format & 268369920) == 720896) {
#line 736
    goto case_720896;
  }
#line 754
  if ((info->format & 268369920) == 786432) {
#line 754
    goto case_786432;
  }
#line 761
  if ((info->format & 268369920) == 851968) {
#line 761
    goto case_851968;
  }
#line 768
  if ((info->format & 268369920) == 917504) {
#line 768
    goto case_917504;
  }
#line 773
  if ((info->format & 268369920) == 983040) {
#line 773
    goto case_983040;
  }
#line 780
  if ((info->format & 268369920) == 1048576) {
#line 780
    goto case_1048576;
  }
#line 790
  if ((info->format & 268369920) == 1114112) {
#line 790
    goto case_1114112;
  }
#line 800
  if ((info->format & 268369920) == 1179648) {
#line 800
    goto case_1179648;
  }
#line 810
  if ((info->format & 268369920) == 1507328) {
#line 810
    goto case_1507328;
  }
#line 820
  if ((info->format & 268369920) == 1441792) {
#line 820
    goto case_1441792;
  }
#line 828
  if ((info->format & 268369920) == 1638400) {
#line 828
    goto case_1638400;
  }
#line 838
  if ((info->format & 268369920) == 2097152) {
#line 838
    goto case_2097152;
  }
#line 845
  if ((info->format & 268369920) == 2162688) {
#line 845
    goto case_2162688;
  }
#line 855
  if ((info->format & 268369920) == 2228224) {
#line 855
    goto case_2228224;
  }
#line 867
  goto switch_default;
  case_65536: 
#line 588
  if (subformat == 5) {
#line 589
    return (1);
  } else
#line 588
  if (subformat == 2) {
#line 589
    return (1);
  }
#line 590
  if (subformat == 3) {
#line 591
    return (1);
  } else
#line 590
  if (subformat == 4) {
#line 591
    return (1);
  }
#line 592
  if (subformat == 18) {
    _L: 
#line 592
    if (info->channels <= 2) {
#line 593
      return (1);
    }
  } else
#line 592
  if (subformat == 19) {
#line 592
    goto _L;
  }
#line 594
  if (subformat == 32) {
#line 594
    if (info->channels == 1) {
#line 595
      return (1);
    }
  }
#line 596
  if (subformat == 48) {
#line 596
    if (info->channels == 1) {
#line 597
      return (1);
    }
  }
#line 598
  if (subformat == 16) {
#line 599
    return (1);
  } else
#line 598
  if (subformat == 17) {
#line 599
    return (1);
  }
#line 600
  if (subformat == 6) {
#line 601
    return (1);
  } else
#line 600
  if (subformat == 7) {
#line 601
    return (1);
  }
#line 602
  goto switch_break;
  case_1245184: 
#line 605
  if (endian == 536870912) {
#line 606
    return (0);
  } else
#line 605
  if (endian == 805306368) {
#line 606
    return (0);
  }
#line 607
  if (subformat == 5) {
#line 608
    return (1);
  } else
#line 607
  if (subformat == 2) {
#line 608
    return (1);
  }
#line 609
  if (subformat == 3) {
#line 610
    return (1);
  } else
#line 609
  if (subformat == 4) {
#line 610
    return (1);
  }
#line 611
  if (subformat == 16) {
#line 612
    return (1);
  } else
#line 611
  if (subformat == 17) {
#line 612
    return (1);
  }
#line 613
  if (subformat == 6) {
#line 614
    return (1);
  } else
#line 613
  if (subformat == 7) {
#line 614
    return (1);
  }
#line 615
  goto switch_break;
  case_131072: 
#line 619
  if (subformat == 2) {
#line 620
    return (1);
  } else
#line 619
  if (subformat == 3) {
#line 620
    return (1);
  } else
#line 619
  if (subformat == 4) {
#line 620
    return (1);
  }
#line 622
  if (endian != 0) {
#line 623
    return (0);
  }
#line 624
  if (subformat == 5) {
#line 625
    return (1);
  } else
#line 624
  if (subformat == 1) {
#line 625
    return (1);
  }
#line 626
  if (subformat == 6) {
#line 627
    return (1);
  } else
#line 626
  if (subformat == 7) {
#line 627
    return (1);
  }
#line 628
  if (subformat == 16) {
#line 629
    return (1);
  } else
#line 628
  if (subformat == 17) {
#line 629
    return (1);
  }
#line 630
  if (subformat == 64) {
    _L___51: 
#line 630
    if (info->channels == 1) {
#line 632
      return (1);
    }
  } else
#line 630
  if (subformat == 65) {
#line 630
    goto _L___51;
  } else
#line 630
  if (subformat == 66) {
#line 630
    goto _L___51;
  }
#line 633
  if (subformat == 32) {
#line 633
    if (info->channels == 1) {
#line 634
      return (1);
    }
  }
#line 635
  if (subformat == 18) {
#line 635
    if (info->channels == 1) {
#line 636
      return (1);
    } else
#line 635
    if (info->channels == 2) {
#line 636
      return (1);
    }
  }
#line 637
  goto switch_break;
  case_196608: 
#line 640
  if (subformat == 1) {
#line 641
    return (1);
  } else
#line 640
  if (subformat == 2) {
#line 641
    return (1);
  }
#line 642
  if (subformat == 3) {
#line 643
    return (1);
  } else
#line 642
  if (subformat == 4) {
#line 643
    return (1);
  }
#line 644
  if (subformat == 16) {
#line 645
    return (1);
  } else
#line 644
  if (subformat == 17) {
#line 645
    return (1);
  }
#line 646
  if (subformat == 6) {
#line 647
    return (1);
  } else
#line 646
  if (subformat == 7) {
#line 647
    return (1);
  }
#line 648
  if (subformat == 48) {
#line 648
    if (info->channels == 1) {
#line 649
      return (1);
    }
  }
#line 650
  if (subformat == 49) {
#line 650
    if (info->channels == 1) {
#line 651
      return (1);
    }
  }
#line 652
  if (subformat == 50) {
#line 652
    if (info->channels == 1) {
#line 653
      return (1);
    }
  }
#line 654
  goto switch_break;
  case_1572864: 
#line 657
  if (subformat == 1) {
#line 658
    return (1);
  } else
#line 657
  if (subformat == 2) {
#line 658
    return (1);
  }
#line 659
  if (subformat == 3) {
#line 660
    return (1);
  } else
#line 659
  if (subformat == 4) {
#line 660
    return (1);
  }
#line 661
  if (subformat == 16) {
#line 662
    return (1);
  } else
#line 661
  if (subformat == 17) {
#line 662
    return (1);
  }
#line 663
  if (subformat == 112) {
#line 664
    return (1);
  } else
#line 663
  if (subformat == 113) {
#line 664
    return (1);
  }
#line 665
  if (subformat == 114) {
#line 666
    return (1);
  } else
#line 665
  if (subformat == 115) {
#line 666
    return (1);
  }
#line 667
  if (subformat == 6) {
#line 668
    return (1);
  } else
#line 667
  if (subformat == 7) {
#line 668
    return (1);
  }
#line 669
  goto switch_break;
  case_262144: 
#line 672
  if (subformat == 5) {
#line 673
    return (1);
  } else
#line 672
  if (subformat == 1) {
#line 673
    return (1);
  } else
#line 672
  if (subformat == 2) {
#line 673
    return (1);
  }
#line 674
  if (subformat == 3) {
#line 675
    return (1);
  } else
#line 674
  if (subformat == 4) {
#line 675
    return (1);
  }
#line 676
  if (subformat == 6) {
#line 677
    return (1);
  } else
#line 676
  if (subformat == 7) {
#line 677
    return (1);
  }
#line 678
  if (subformat == 17) {
#line 679
    return (1);
  } else
#line 678
  if (subformat == 16) {
#line 679
    return (1);
  }
#line 680
  if (subformat == 64) {
    _L___53: 
#line 680
    if (info->channels == 1) {
#line 682
      return (1);
    }
  } else
#line 680
  if (subformat == 65) {
#line 680
    goto _L___53;
  } else
#line 680
  if (subformat == 66) {
#line 680
    goto _L___53;
  }
#line 683
  if (subformat == 32) {
#line 683
    if (info->channels == 1) {
#line 684
      return (1);
    }
  }
#line 685
  if (subformat == 33) {
#line 685
    if (info->channels == 1) {
#line 686
      return (1);
    }
  }
#line 687
  goto switch_break;
  case_327680: 
#line 690
  if (subformat == 1) {
#line 691
    return (1);
  } else
#line 690
  if (subformat == 2) {
#line 691
    return (1);
  } else
#line 690
  if (subformat == 3) {
#line 691
    return (1);
  }
#line 692
  goto switch_break;
  case_393216: 
#line 696
  if (info->channels > 1) {
#line 697
    return (0);
  }
#line 699
  if (endian == 268435456) {
#line 700
    return (0);
  } else
#line 699
  if (endian == 805306368) {
#line 700
    return (0);
  }
#line 702
  if (subformat == 1) {
#line 703
    return (1);
  } else
#line 702
  if (subformat == 2) {
#line 703
    return (1);
  }
#line 704
  goto switch_break;
  case_458752: 
#line 707
  if (subformat == 1) {
#line 708
    return (1);
  } else
#line 707
  if (subformat == 2) {
#line 708
    return (1);
  }
#line 709
  if (subformat == 3) {
#line 710
    return (1);
  } else
#line 709
  if (subformat == 4) {
#line 710
    return (1);
  }
#line 711
  if (subformat == 16) {
#line 712
    return (1);
  } else
#line 711
  if (subformat == 17) {
#line 712
    return (1);
  }
#line 713
  goto switch_break;
  case_655360: 
#line 716
  if (info->channels > 256) {
#line 717
    return (0);
  }
#line 718
  if (subformat == 2) {
#line 719
    return (1);
  } else
#line 718
  if (subformat == 4) {
#line 719
    return (1);
  }
#line 720
  if (subformat == 16) {
#line 721
    return (1);
  } else
#line 720
  if (subformat == 17) {
#line 721
    return (1);
  } else
#line 720
  if (subformat == 6) {
#line 721
    return (1);
  }
#line 722
  goto switch_break;
  case_524288: 
#line 725
  if (info->channels > 2) {
#line 726
    return (0);
  }
#line 728
  if (endian == 536870912) {
#line 729
    return (0);
  } else
#line 728
  if (endian == 805306368) {
#line 729
    return (0);
  }
#line 730
  if (subformat == 5) {
#line 731
    return (1);
  } else
#line 730
  if (subformat == 2) {
#line 731
    return (1);
  }
#line 732
  if (subformat == 16) {
#line 733
    return (1);
  } else
#line 732
  if (subformat == 17) {
#line 733
    return (1);
  }
#line 734
  goto switch_break;
  case_720896: 
#line 738
  if (endian == 536870912) {
#line 739
    return (0);
  } else
#line 738
  if (endian == 805306368) {
#line 739
    return (0);
  }
#line 740
  if (subformat == 5) {
#line 741
    return (1);
  } else
#line 740
  if (subformat == 2) {
#line 741
    return (1);
  }
#line 742
  if (subformat == 3) {
#line 743
    return (1);
  } else
#line 742
  if (subformat == 4) {
#line 743
    return (1);
  }
#line 744
  if (subformat == 18) {
    _L___55: 
#line 744
    if (info->channels <= 2) {
#line 745
      return (1);
    }
  } else
#line 744
  if (subformat == 19) {
#line 744
    goto _L___55;
  }
#line 746
  if (subformat == 32) {
#line 746
    if (info->channels == 1) {
#line 747
      return (1);
    }
  }
#line 748
  if (subformat == 16) {
#line 749
    return (1);
  } else
#line 748
  if (subformat == 17) {
#line 749
    return (1);
  }
#line 750
  if (subformat == 6) {
#line 751
    return (1);
  } else
#line 750
  if (subformat == 7) {
#line 751
    return (1);
  }
#line 752
  goto switch_break;
  case_786432: 
#line 755
  if (subformat == 2) {
#line 756
    return (1);
  } else
#line 755
  if (subformat == 4) {
#line 756
    return (1);
  }
#line 757
  if (subformat == 6) {
#line 758
    return (1);
  } else
#line 757
  if (subformat == 7) {
#line 758
    return (1);
  }
#line 759
  goto switch_break;
  case_851968: 
#line 762
  if (subformat == 5) {
#line 763
    return (1);
  } else
#line 762
  if (subformat == 2) {
#line 763
    return (1);
  } else
#line 762
  if (subformat == 4) {
#line 763
    return (1);
  }
#line 764
  if (subformat == 6) {
#line 765
    return (1);
  } else
#line 764
  if (subformat == 7) {
#line 765
    return (1);
  }
#line 766
  goto switch_break;
  case_917504: 
#line 769
  if (subformat == 1) {
#line 770
    return (1);
  } else
#line 769
  if (subformat == 2) {
#line 770
    return (1);
  } else
#line 769
  if (subformat == 4) {
#line 770
    return (1);
  }
#line 771
  goto switch_break;
  case_983040: 
#line 774
  if (info->channels != 1) {
#line 775
    return (0);
  }
#line 776
  if (subformat == 80) {
#line 777
    return (1);
  } else
#line 776
  if (subformat == 81) {
#line 777
    return (1);
  }
#line 778
  goto switch_break;
  case_1048576: 
#line 781
  if (info->channels != 1) {
#line 782
    return (0);
  }
#line 784
  if (endian == 268435456) {
#line 785
    return (0);
  } else
#line 784
  if (endian == 805306368) {
#line 785
    return (0);
  }
#line 786
  if (subformat == 2) {
#line 787
    return (1);
  }
#line 788
  goto switch_break;
  case_1114112: 
#line 791
  if (info->channels != 1) {
#line 792
    return (0);
  }
#line 794
  if (endian == 268435456) {
#line 795
    return (0);
  } else
#line 794
  if (endian == 805306368) {
#line 795
    return (0);
  }
#line 796
  if (subformat == 1) {
#line 797
    return (1);
  } else
#line 796
  if (subformat == 2) {
#line 797
    return (1);
  } else
#line 796
  if (subformat == 3) {
#line 797
    return (1);
  }
#line 798
  goto switch_break;
  case_1179648: 
#line 801
  if (info->channels > 2) {
#line 802
    return (0);
  }
#line 804
  if (endian == 268435456) {
#line 805
    return (0);
  } else
#line 804
  if (endian == 805306368) {
#line 805
    return (0);
  }
#line 806
  if (subformat == 5) {
#line 807
    return (1);
  } else
#line 806
  if (subformat == 1) {
#line 807
    return (1);
  } else
#line 806
  if (subformat == 2) {
#line 807
    return (1);
  }
#line 808
  goto switch_break;
  case_1507328: 
#line 812
  if (info->channels > 8) {
#line 813
    return (0);
  }
#line 814
  if (endian != 0) {
#line 815
    return (0);
  }
#line 816
  if (subformat == 1) {
#line 817
    return (1);
  } else
#line 816
  if (subformat == 2) {
#line 817
    return (1);
  } else
#line 816
  if (subformat == 3) {
#line 817
    return (1);
  }
#line 818
  goto switch_break;
  case_1441792: 
#line 822
  if (endian == 268435456) {
#line 823
    return (0);
  } else
#line 822
  if (endian == 805306368) {
#line 823
    return (0);
  }
#line 824
  if (subformat == 1) {
#line 825
    return (1);
  } else
#line 824
  if (subformat == 2) {
#line 825
    return (1);
  } else
#line 824
  if (subformat == 3) {
#line 825
    return (1);
  } else
#line 824
  if (subformat == 4) {
#line 825
    return (1);
  }
#line 826
  goto switch_break;
  case_1638400: 
#line 829
  if (info->channels > 1) {
#line 830
    return (0);
  }
#line 832
  if (endian == 536870912) {
#line 833
    return (0);
  } else
#line 832
  if (endian == 805306368) {
#line 833
    return (0);
  }
#line 834
  if (subformat == 17) {
#line 835
    return (1);
  }
#line 836
  goto switch_break;
  case_2097152: 
#line 839
  if (endian != 0) {
#line 840
    return (0);
  }
#line 841
  if (subformat == 96) {
#line 842
    return (1);
  }
#line 843
  goto switch_break;
  case_2162688: 
#line 846
  if (info->channels > 2) {
#line 847
    return (0);
  }
#line 849
  if (endian == 536870912) {
#line 850
    return (0);
  } else
#line 849
  if (endian == 805306368) {
#line 850
    return (0);
  }
#line 851
  if (subformat == 2) {
#line 852
    return (1);
  }
#line 853
  goto switch_break;
  case_2228224: 
#line 856
  if (endian == 536870912) {
#line 857
    return (0);
  } else
#line 856
  if (endian == 805306368) {
#line 857
    return (0);
  }
#line 858
  if (subformat == 5) {
#line 859
    return (1);
  } else
#line 858
  if (subformat == 2) {
#line 859
    return (1);
  }
#line 860
  if (subformat == 3) {
#line 861
    return (1);
  } else
#line 860
  if (subformat == 4) {
#line 861
    return (1);
  }
#line 862
  if (subformat == 16) {
#line 863
    return (1);
  } else
#line 862
  if (subformat == 17) {
#line 863
    return (1);
  }
#line 864
  if (subformat == 6) {
#line 865
    return (1);
  } else
#line 864
  if (subformat == 7) {
#line 865
    return (1);
  }
#line 866
  goto switch_break;
  switch_default: 
#line 867
  goto switch_break;
  switch_break: ;
#line 870
  return (0);
}
}
#line 878 "/root/patchweave_new/23/src/sndfile.c"
char const   *sf_version_string(void) 
{ 


  {
#line 883
  return ("libsndfile-1.0.29pre1");
}
}
#line 893 "/root/patchweave_new/23/src/sndfile.c"
int sf_command(SNDFILE *sndfile , int command , void *data , int datasize ) 
{ 
  SF_PRIVATE *psf ;
  double quality ;
  int old_value ;
  char const   *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp11 ;
  int __cil_tmp13 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double __cil_tmp22 ;
  int tmp___2 ;
  int format ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int tmp___3 ;
  sf_count_t position ;
  sf_count_t __cil_tmp34 ;
  int __cil_tmp36 ;
  int tmp___4 ;
  int tmp___5 ;
  int format___0 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int format___1 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int *iptr ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  void *tmp___6 ;

  {
#line 894
  psf = (SF_PRIVATE *)sndfile;
#line 900
  if (command == 4096) {
#line 900
    goto case_4096;
  }
#line 909
  if (command == 4128) {
#line 909
    goto case_4128;
  }
#line 915
  if (command == 4129) {
#line 915
    goto case_4129;
  }
#line 920
  if (command == 4144) {
#line 920
    goto case_4144;
  }
#line 926
  if (command == 4145) {
#line 926
    goto case_4145;
  }
#line 931
  if (command == 4146) {
#line 931
    goto case_4146;
  }
#line 937
  if (command == 4147) {
#line 937
    goto case_4147;
  }
#line 942
  if (command == 4136) {
#line 942
    goto case_4136;
  }
#line 899
  goto switch_break;
  case_4096: 
#line 901
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 902
    if (psf) {
#line 903
      psf->error = 31;
    }
#line 904
    return (31);
  }
  {
#line 906
  __cil_tmp8 = sf_version_string();
#line 906
  snprintf((char *)data, (unsigned long )datasize, "%s\034I\270U", __cil_tmp8);
#line 907
  __cil_tmp9 = strlen((char const   *)data);
  }
#line 907
  return ((int )__cil_tmp9);
  case_4128: 
#line 910
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 911
    sf_errno = 31;
#line 911
    return (sf_errno);
  } else
#line 910
  if (datasize != (int )sizeof(int )) {
#line 911
    sf_errno = 31;
#line 911
    return (sf_errno);
  }
  {
#line 912
  *((int *)data) = psf_get_format_simple_count();
  }
#line 913
  return (0);
  case_4129: 
#line 916
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 917
    sf_errno = 31;
#line 917
    return (sf_errno);
  } else
#line 916
  if (datasize != (int )sizeof(SF_FORMAT_INFO )) {
#line 917
    sf_errno = 31;
#line 917
    return (sf_errno);
  }
  {
#line 918
  __cil_tmp11 = psf_get_format_simple((SF_FORMAT_INFO *)data);
  }
#line 918
  return (__cil_tmp11);
  case_4144: 
#line 921
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 922
    sf_errno = 31;
#line 922
    return (sf_errno);
  } else
#line 921
  if (datasize != (int )sizeof(int )) {
#line 922
    sf_errno = 31;
#line 922
    return (sf_errno);
  }
  {
#line 923
  *((int *)data) = psf_get_format_major_count();
  }
#line 924
  return (0);
  case_4145: 
#line 927
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 928
    sf_errno = 31;
#line 928
    return (sf_errno);
  } else
#line 927
  if (datasize != (int )sizeof(SF_FORMAT_INFO )) {
#line 928
    sf_errno = 31;
#line 928
    return (sf_errno);
  }
  {
#line 929
  __cil_tmp13 = psf_get_format_major((SF_FORMAT_INFO *)data);
  }
#line 929
  return (__cil_tmp13);
  case_4146: 
#line 932
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 933
    sf_errno = 31;
#line 933
    return (sf_errno);
  } else
#line 932
  if (datasize != (int )sizeof(int )) {
#line 933
    sf_errno = 31;
#line 933
    return (sf_errno);
  }
  {
#line 934
  *((int *)data) = psf_get_format_subtype_count();
  }
#line 935
  return (0);
  case_4147: 
#line 938
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 939
    sf_errno = 31;
#line 939
    return (sf_errno);
  } else
#line 938
  if (datasize != (int )sizeof(SF_FORMAT_INFO )) {
#line 939
    sf_errno = 31;
#line 939
    return (sf_errno);
  }
  {
#line 940
  __cil_tmp15 = psf_get_format_subtype((SF_FORMAT_INFO *)data);
  }
#line 940
  return (__cil_tmp15);
  case_4136: 
#line 943
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 944
    sf_errno = 31;
#line 944
    return (sf_errno);
  } else
#line 943
  if (datasize != (int )sizeof(SF_FORMAT_INFO )) {
#line 944
    sf_errno = 31;
#line 944
    return (sf_errno);
  }
  {
#line 945
  __cil_tmp16 = psf_get_format_info((SF_FORMAT_INFO *)data);
  }
#line 945
  return (__cil_tmp16);
  switch_break: ;
#line 948
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 948
    if (command == 4097) {
#line 949
      if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 950
        sf_errno = 31;
#line 950
        return (sf_errno);
      }
      {
#line 951
      snprintf((char *)data, (unsigned long )datasize, "%s", sf_parselog);
#line 952
      __cil_tmp17 = strlen((char const   *)data);
      }
#line 952
      return ((int )__cil_tmp17);
    }
  }
#line 955
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 955
    sf_errno = 10;
#line 955
    return (0);
  }
  {
#line 955
  psf = (SF_PRIVATE *)sndfile;
#line 955
  __cil_tmp18 = psf_file_valid(psf);
  }
#line 955
  if (psf->virtual_io == 0) {
#line 955
    if (__cil_tmp18 == 0) {
#line 955
      psf->error = 13;
#line 955
      return (0);
    }
  }
#line 955
  if (psf->Magick != 305447134) {
#line 955
    psf->error = 10;
#line 955
    return (0);
  }
#line 955
  psf->error = 0;
#line 958
  if (command == 4115) {
#line 958
    goto case_4115;
  }
#line 963
  if (command == 4098) {
#line 963
    goto case_4098;
  }
#line 969
  if (command == 4114) {
#line 969
    goto case_4114;
  }
#line 974
  if (command == 4113) {
#line 974
    goto case_4113;
  }
#line 977
  if (command == 4112) {
#line 977
    goto case_4112;
  }
#line 980
  if (command == 4116) {
#line 980
    goto case_4116;
  }
#line 989
  if (command == 4117) {
#line 989
    goto case_4117;
  }
#line 994
  if (command == 4176) {
#line 994
    goto case_4176;
  }
#line 1003
  if (command == 2228224) {
#line 1003
    goto case_2228224;
  }
#line 1003
  if (command == 1245184) {
#line 1003
    goto case_2228224;
  }
#line 1003
  if (command == 65536) {
#line 1003
    goto case_2228224;
  }
#line 1003
  if (command == 1572864) {
#line 1003
    goto case_2228224;
  }
#line 1003
  if (command == 131072) {
#line 1003
    goto case_2228224;
  }
#line 1040
  if (command == 4177) {
#line 1040
    goto case_4177;
  }
#line 1043
  if (command == 4097) {
#line 1043
    goto case_4097;
  }
#line 1049
  if (command == 4160) {
#line 1049
    goto case_4160;
  }
#line 1055
  if (command == 4161) {
#line 1055
    goto case_4161;
  }
#line 1061
  if (command == 4162) {
#line 1061
    goto case_4162;
  }
#line 1066
  if (command == 4163) {
#line 1066
    goto case_4163;
  }
#line 1071
  if (command == 4164) {
#line 1071
    goto case_4164;
  }
#line 1078
  if (command == 4165) {
#line 1078
    goto case_4165;
  }
#line 1085
  if (command == 4192) {
#line 1085
    goto case_4192;
  }
#line 1090
  if (command == 4193) {
#line 1090
    goto case_4193;
  }
#line 1096
  if (command == 4209) {
#line 1096
    goto case_4209;
  }
#line 1096
  if (command == 4208) {
#line 1096
    goto case_4209;
  }
#line 1104
  if (command == 4256) {
#line 1104
    goto case_4256;
  }
#line 1112
  if (command == 4257) {
#line 1112
    goto case_4257;
  }
#line 1120
  if (command == 4224) {
#line 1120
    goto case_4224;
  }
#line 1145
  if (command == 4240) {
#line 1145
    goto case_4240;
  }
#line 1156
  if (command == 4272) {
#line 1156
    goto case_4272;
  }
#line 1165
  if (command == 24577) {
#line 1165
    goto case_24577;
  }
#line 1176
  if (command == 4288) {
#line 1176
    goto case_4288;
  }
#line 1180
  if (command == 4289) {
#line 1180
    goto case_4289;
  }
#line 1183
  if (command == 4320) {
#line 1183
    goto case_4320;
  }
#line 1193
  if (command == 4337) {
#line 1193
    goto case_4337;
  }
#line 1217
  if (command == 4336) {
#line 1217
    goto case_4336;
  }
#line 1224
  if (command == 5120) {
#line 1224
    goto case_5120;
  }
#line 1245
  if (command == 5121) {
#line 1245
    goto case_5121;
  }
#line 1252
  if (command == 4301) {
#line 1252
    goto case_4301;
  }
#line 1263
  if (command == 4302) {
#line 1263
    goto case_4302;
  }
#line 1273
  if (command == 4303) {
#line 1273
    goto case_4303;
  }
#line 1289
  if (command == 4304) {
#line 1289
    goto case_4304;
  }
#line 1299
  if (command == 4305) {
#line 1299
    goto case_4305;
  }
#line 1317
  if (command == 4368) {
#line 1317
    goto case_4368;
  }
#line 1320
  if (command == 4352) {
#line 1320
    goto case_4352;
  }
#line 1332
  if (command == 4353) {
#line 1332
    goto case_4353;
  }
#line 1368
  if (command == 4864) {
#line 1368
    goto case_4864;
  }
#line 1377
  goto switch_default___0;
  case_4115: 
#line 959
  old_value = psf->norm_float;
#line 960
  if (datasize) {
#line 960
    tmp = 1;
  } else {
#line 960
    tmp = 0;
  }
#line 960
  psf->norm_float = tmp;
#line 961
  return (old_value);
  case_4098: 
#line 964
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 965
    sf_errno = 31;
#line 965
    return (sf_errno);
  } else
#line 964
  if (datasize != (int )sizeof(SF_INFO )) {
#line 965
    sf_errno = 31;
#line 965
    return (sf_errno);
  }
  {
#line 966
  memcpy(data, (void const   *)(& psf->sf), sizeof(SF_INFO ));
  }
#line 967
  goto switch_break___0;
  case_4114: 
#line 970
  old_value = psf->norm_double;
#line 971
  if (datasize) {
#line 971
    tmp___0 = 1;
  } else {
#line 971
    tmp___0 = 0;
  }
#line 971
  psf->norm_double = tmp___0;
#line 972
  return (old_value);
  case_4113: 
#line 975
  return (psf->norm_float);
  case_4112: 
#line 978
  return (psf->norm_double);
  case_4116: 
#line 981
  old_value = psf->float_int_mult;
#line 983
  if (datasize != 0) {
#line 983
    tmp___1 = 1;
  } else {
#line 983
    tmp___1 = 0;
  }
#line 983
  psf->float_int_mult = tmp___1;
#line 984
  if (psf->float_int_mult) {
#line 984
    if ((double )psf->float_max < 0.) {
      {
#line 986
      __cil_tmp22 = psf_calc_signal_max(psf, 0);
#line 986
      psf->float_max = (float )((32768. / 32767.) * __cil_tmp22);
      }
    }
  }
#line 987
  return (old_value);
  case_4117: 
#line 990
  old_value = psf->scale_int_float;
#line 991
  if (datasize != 0) {
#line 991
    tmp___2 = 1;
  } else {
#line 991
    tmp___2 = 0;
  }
#line 991
  psf->scale_int_float = tmp___2;
#line 992
  return (old_value);
  case_4176: 
#line 995
  format = psf->sf.format & 268369920;
#line 1003
  if (format == 2228224) {
#line 1003
    goto case_2228224;
  }
#line 1003
  if (format == 1245184) {
#line 1003
    goto case_2228224;
  }
#line 1003
  if (format == 65536) {
#line 1003
    goto case_2228224;
  }
#line 1003
  if (format == 1572864) {
#line 1003
    goto case_2228224;
  }
#line 1003
  if (format == 131072) {
#line 1003
    goto case_2228224;
  }
#line 1006
  goto switch_default;
  case_2228224: 
#line 1004
  goto switch_break___1;
  switch_default: 
#line 1007
  return (0);
  switch_break___1: 
#line 1010
  format = psf->sf.format & 65535;
#line 1013
  if (format != 6) {
#line 1013
    if (format != 7) {
#line 1014
      return (0);
    }
  }
#line 1018
  if (psf->file.mode != 32) {
#line 1018
    if (psf->file.mode != 48) {
#line 1019
      return (0);
    }
  }
#line 1021
  if (psf->have_written) {
#line 1022
    psf->error = 49;
#line 1023
    return (0);
  }
#line 1026
  if ((unsigned long )psf->peak_info != (unsigned long )((void *)0)) {
#line 1026
    if (datasize == 0) {
      {
#line 1027
      free((void *)psf->peak_info);
#line 1028
      psf->peak_info = (PEAK_INFO *)((void *)0);
      }
    } else {
#line 1026
      goto _L;
    }
  } else
  _L: 
#line 1030
  if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
    {
#line 1031
    psf->peak_info = peak_info_calloc(psf->sf.channels);
    }
#line 1032
    if ((unsigned long )psf->peak_info != (unsigned long )((void *)0)) {
#line 1033
      (psf->peak_info)->peak_loc = 42;
    }
  }
#line 1036
  if (psf->write_header) {
    {
#line 1037
    (*(psf->write_header))(psf, 1);
    }
  }
#line 1038
  return (datasize);
  case_4177: 
#line 1041
  return (0);
  case_4097: 
#line 1044
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1045
    return (31);
  }
  {
#line 1046
  snprintf((char *)data, (unsigned long )datasize, "%s", psf->parselog.buf);
  }
#line 1047
  goto switch_break___0;
  case_4160: 
#line 1050
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1051
    psf->error = 31;
#line 1051
    return (psf->error);
  } else
#line 1050
  if ((unsigned long )datasize != sizeof(double )) {
#line 1051
    psf->error = 31;
#line 1051
    return (psf->error);
  }
  {
#line 1052
  *((double *)data) = psf_calc_signal_max(psf, 0);
  }
#line 1053
  goto switch_break___0;
  case_4161: 
#line 1056
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1057
    psf->error = 31;
#line 1057
    return (psf->error);
  } else
#line 1056
  if ((unsigned long )datasize != sizeof(double )) {
#line 1057
    psf->error = 31;
#line 1057
    return (psf->error);
  }
  {
#line 1058
  *((double *)data) = psf_calc_signal_max(psf, 1);
  }
#line 1059
  goto switch_break___0;
  case_4162: 
#line 1062
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1063
    psf->error = 31;
#line 1063
    return (psf->error);
  } else
#line 1062
  if (datasize != (int )sizeof(double ) * psf->sf.channels) {
#line 1063
    psf->error = 31;
#line 1063
    return (psf->error);
  }
  {
#line 1064
  __cil_tmp28 = psf_calc_max_all_channels(psf, (double *)data, 0);
  }
#line 1064
  return (__cil_tmp28);
  case_4163: 
#line 1067
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1068
    psf->error = 31;
#line 1068
    return (psf->error);
  } else
#line 1067
  if (datasize != (int )sizeof(double ) * psf->sf.channels) {
#line 1068
    psf->error = 31;
#line 1068
    return (psf->error);
  }
  {
#line 1069
  __cil_tmp29 = psf_calc_max_all_channels(psf, (double *)data, 1);
  }
#line 1069
  return (__cil_tmp29);
  case_4164: 
#line 1072
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1073
    psf->error = 31;
#line 1074
    return (0);
  } else
#line 1072
  if ((unsigned long )datasize != sizeof(double )) {
#line 1073
    psf->error = 31;
#line 1074
    return (0);
  }
  {
#line 1076
  __cil_tmp30 = psf_get_signal_max(psf, (double *)data);
  }
#line 1076
  return (__cil_tmp30);
  case_4165: 
#line 1079
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1080
    psf->error = 31;
#line 1081
    return (0);
  } else
#line 1079
  if (datasize != (int )sizeof(double ) * psf->sf.channels) {
#line 1080
    psf->error = 31;
#line 1081
    return (0);
  }
  {
#line 1083
  __cil_tmp31 = psf_get_max_all_channels(psf, (double *)data);
  }
#line 1083
  return (__cil_tmp31);
  case_4192: 
#line 1086
  if (psf->write_header) {
    {
#line 1087
    (*(psf->write_header))(psf, 1);
    }
  }
#line 1088
  goto switch_break___0;
  case_4193: 
#line 1091
  if (datasize) {
#line 1091
    tmp___3 = 1;
  } else {
#line 1091
    tmp___3 = 0;
  }
#line 1091
  psf->auto_header = tmp___3;
#line 1092
  return (psf->auto_header);
#line 1093
  goto switch_break___0;
  case_4209: 
#line 1102
  goto switch_break___0;
  case_4256: 
#line 1105
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1106
    psf->error = 31;
#line 1106
    return (psf->error);
  } else
#line 1105
  if (datasize != (int )sizeof(SF_DITHER_INFO )) {
#line 1106
    psf->error = 31;
#line 1106
    return (psf->error);
  }
  {
#line 1107
  memcpy((void *)(& psf->write_dither), (void const   *)data, sizeof(psf->write_dither));
  }
#line 1108
  if (psf->file.mode == 32) {
    {
#line 1109
    dither_init(psf, 32);
    }
  } else
#line 1108
  if (psf->file.mode == 48) {
    {
#line 1109
    dither_init(psf, 32);
    }
  }
#line 1110
  goto switch_break___0;
  case_4257: 
#line 1113
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1114
    psf->error = 31;
#line 1114
    return (psf->error);
  } else
#line 1113
  if (datasize != (int )sizeof(SF_DITHER_INFO )) {
#line 1114
    psf->error = 31;
#line 1114
    return (psf->error);
  }
  {
#line 1115
  memcpy((void *)(& psf->read_dither), (void const   *)data, sizeof(psf->read_dither));
  }
#line 1116
  if (psf->file.mode == 16) {
    {
#line 1117
    dither_init(psf, 16);
    }
  } else
#line 1116
  if (psf->file.mode == 48) {
    {
#line 1117
    dither_init(psf, 16);
    }
  }
#line 1118
  goto switch_break___0;
  case_4224: 
#line 1121
  if (psf->file.mode != 32) {
#line 1121
    if (psf->file.mode != 48) {
#line 1122
      return (1);
    }
  }
#line 1123
  if ((unsigned long )datasize != sizeof(sf_count_t )) {
#line 1124
    return (1);
  }
#line 1125
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1126
    psf->error = 31;
#line 1127
    return (0);
  } else
#line 1125
  if ((unsigned long )datasize != sizeof(sf_count_t )) {
#line 1126
    psf->error = 31;
#line 1127
    return (0);
  } else {
    {
#line 1132
    position = *((sf_count_t *)data);
#line 1134
    __cil_tmp34 = sf_seek(sndfile, position, 0);
    }
#line 1134
    if (__cil_tmp34 != position) {
#line 1135
      return (1);
    }
    {
#line 1137
    psf->sf.frames = position;
#line 1139
    position = psf_fseek(psf, (sf_count_t )0, 1);
#line 1141
    __cil_tmp36 = psf_ftruncate(psf, position);
    }
#line 1141
    return (__cil_tmp36);
  }
#line 1143
  goto switch_break___0;
  case_4240: 
#line 1146
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1147
    psf->error = 31;
#line 1147
    return (psf->error);
  } else
#line 1146
  if ((unsigned long )datasize != sizeof(sf_count_t )) {
#line 1147
    psf->error = 31;
#line 1147
    return (psf->error);
  }
#line 1149
  if ((psf->sf.format & 268369920) != 262144) {
#line 1150
    psf->error = 31;
#line 1150
    return (psf->error);
  }
  {
#line 1152
  psf->dataoffset = *((sf_count_t *)data);
#line 1153
  sf_seek(sndfile, (sf_count_t )0, 1);
  }
#line 1154
  goto switch_break___0;
  case_4272: 
#line 1157
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1158
    psf->error = 31;
#line 1158
    return (psf->error);
  } else
#line 1157
  if ((unsigned long )datasize != sizeof(SF_EMBED_FILE_INFO )) {
#line 1158
    psf->error = 31;
#line 1158
    return (psf->error);
  }
#line 1160
  ((SF_EMBED_FILE_INFO *)data)->offset = psf->fileoffset;
#line 1161
  ((SF_EMBED_FILE_INFO *)data)->length = psf->filelength;
#line 1162
  goto switch_break___0;
  case_24577: 
#line 1166
  if (datasize) {
#line 1166
    tmp___4 = 1;
  } else {
#line 1166
    tmp___4 = 0;
  }
#line 1166
  psf->ieee_replace = tmp___4;
#line 1167
  if ((psf->sf.format & 65535) == 6) {
    {
#line 1168
    float32_init(psf);
    }
  } else
#line 1169
  if ((psf->sf.format & 65535) == 7) {
    {
#line 1170
    double64_init(psf);
    }
  } else {
#line 1172
    psf->error = 31;
#line 1172
    return (psf->error);
  }
#line 1173
  goto switch_break___0;
  case_4288: 
#line 1177
  if (datasize) {
#line 1177
    tmp___5 = 1;
  } else {
#line 1177
    tmp___5 = 0;
  }
#line 1177
  psf->add_clipping = tmp___5;
#line 1178
  return (psf->add_clipping);
  case_4289: 
#line 1181
  return (psf->add_clipping);
  case_4320: 
#line 1184
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1185
    psf->error = 31;
#line 1186
    return (0);
  } else
#line 1184
  if ((unsigned long )datasize != sizeof(SF_LOOP_INFO )) {
#line 1185
    psf->error = 31;
#line 1186
    return (0);
  }
#line 1188
  if ((unsigned long )psf->loop_info == (unsigned long )((void *)0)) {
#line 1189
    return (0);
  }
  {
#line 1190
  memcpy(data, (void const   *)psf->loop_info, sizeof(SF_LOOP_INFO ));
  }
#line 1191
  return (1);
  case_4337: 
#line 1194
  format___0 = psf->sf.format & 268369920;
#line 1197
  if (format___0 != 65536) {
#line 1197
    if (format___0 != 1245184) {
#line 1197
      if (format___0 != 2228224) {
#line 1198
        return (0);
      }
    }
  }
#line 1202
  if (psf->file.mode != 32) {
#line 1202
    if (psf->file.mode != 48) {
#line 1203
      return (0);
    }
  }
#line 1205
  if ((unsigned long )psf->broadcast_16k == (unsigned long )((void *)0)) {
#line 1205
    if (psf->have_written) {
#line 1206
      psf->error = 49;
#line 1207
      return (0);
    }
  }
  {
#line 1210
  __cil_tmp40 = broadcast_var_set(psf, (SF_BROADCAST_INFO *)data, (size_t )datasize);
  }
#line 1210
  if (! __cil_tmp40) {
#line 1211
    return (0);
  }
#line 1213
  if (psf->write_header) {
    {
#line 1214
    (*(psf->write_header))(psf, 1);
    }
  }
#line 1215
  return (1);
  case_4336: 
#line 1218
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1219
    psf->error = 31;
#line 1220
    return (0);
  }
  {
#line 1222
  __cil_tmp41 = broadcast_var_get(psf, (SF_BROADCAST_INFO *)data, (size_t )datasize);
  }
#line 1222
  return (__cil_tmp41);
  case_5120: 
#line 1225
  format___1 = psf->sf.format & 268369920;
#line 1227
  if (format___1 != 65536) {
#line 1227
    if (format___1 != 2228224) {
#line 1228
      return (0);
    }
  }
#line 1232
  if (psf->file.mode != 32) {
#line 1232
    if (psf->file.mode != 48) {
#line 1233
      return (0);
    }
  }
#line 1235
  if ((unsigned long )psf->cart_16k == (unsigned long )((void *)0)) {
#line 1235
    if (psf->have_written) {
#line 1236
      psf->error = 49;
#line 1237
      return (0);
    }
  }
  {
#line 1239
  __cil_tmp43 = cart_var_set(psf, (SF_CART_INFO *)data, (size_t )datasize);
  }
#line 1239
  if (! __cil_tmp43) {
#line 1240
    return (0);
  }
#line 1241
  if (psf->write_header) {
    {
#line 1242
    (*(psf->write_header))(psf, 1);
    }
  }
#line 1243
  return (1);
  case_5121: 
#line 1246
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1247
    psf->error = 31;
#line 1248
    return (0);
  }
  {
#line 1250
  __cil_tmp44 = cart_var_get(psf, (SF_CART_INFO *)data, (size_t )datasize);
  }
#line 1250
  return (__cil_tmp44);
  case_4301: 
#line 1253
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1254
    psf->error = 31;
#line 1255
    return (0);
  } else
#line 1253
  if ((unsigned long )datasize != sizeof(uint32_t )) {
#line 1254
    psf->error = 31;
#line 1255
    return (0);
  }
#line 1257
  if ((unsigned long )psf->cues != (unsigned long )((void *)0)) {
#line 1258
    *((uint32_t *)data) = (psf->cues)->cue_count;
#line 1259
    return (1);
  }
#line 1261
  return (0);
  case_4302: 
#line 1264
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1265
    psf->error = 31;
#line 1266
    return (0);
  } else
#line 1264
  if ((unsigned long )datasize != sizeof(SF_CUES )) {
#line 1265
    psf->error = 31;
#line 1266
    return (0);
  }
#line 1268
  if ((unsigned long )psf->cues == (unsigned long )((void *)0)) {
#line 1269
    return (0);
  }
  {
#line 1270
  psf_get_cues(psf, data, (size_t )datasize);
  }
#line 1271
  return (1);
  case_4303: 
#line 1274
  if (psf->have_written) {
#line 1275
    psf->error = 49;
#line 1276
    return (0);
  }
#line 1278
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1279
    psf->error = 31;
#line 1280
    return (0);
  } else
#line 1278
  if ((unsigned long )datasize != sizeof(SF_CUES )) {
#line 1279
    psf->error = 31;
#line 1280
    return (0);
  }
  {
#line 1283
  psf->cues = psf_cues_dup((void const   *)data);
  }
#line 1283
  if ((unsigned long )psf->cues == (unsigned long )((void *)0)) {
#line 1283
    if ((unsigned long )psf->cues == (unsigned long )((void *)0)) {
#line 1284
      psf->error = 17;
#line 1285
      return (0);
    }
  }
#line 1287
  return (1);
  case_4304: 
#line 1290
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1291
    psf->error = 31;
#line 1292
    return (0);
  } else
#line 1290
  if ((unsigned long )datasize != sizeof(SF_INSTRUMENT )) {
#line 1291
    psf->error = 31;
#line 1292
    return (0);
  }
#line 1294
  if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 1295
    return (0);
  }
  {
#line 1296
  memcpy(data, (void const   *)psf->instrument, sizeof(SF_INSTRUMENT ));
  }
#line 1297
  return (1);
  case_4305: 
#line 1301
  if (psf->have_written) {
#line 1302
    psf->error = 49;
#line 1303
    return (0);
  }
#line 1305
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1306
    psf->error = 31;
#line 1307
    return (0);
  } else
#line 1305
  if ((unsigned long )datasize != sizeof(SF_INSTRUMENT )) {
#line 1306
    psf->error = 31;
#line 1307
    return (0);
  }
  {
#line 1310
  psf->instrument = psf_instrument_alloc();
  }
#line 1310
  if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 1310
    if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 1311
      psf->error = 17;
#line 1312
      return (0);
    }
  }
  {
#line 1314
  memcpy((void *)psf->instrument, (void const   *)data, sizeof(SF_INSTRUMENT ));
  }
#line 1315
  return (1);
  case_4368: 
#line 1318
  return (psf->data_endswap);
  case_4352: 
#line 1321
  if ((unsigned long )psf->channel_map == (unsigned long )((void *)0)) {
#line 1322
    return (0);
  }
#line 1324
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1325
    psf->error = 31;
#line 1326
    return (0);
  } else
#line 1324
  if (datasize != (int )sizeof(*(psf->channel_map + 0)) * psf->sf.channels) {
#line 1325
    psf->error = 31;
#line 1326
    return (0);
  }
  {
#line 1329
  memcpy(data, (void const   *)psf->channel_map, (unsigned long )datasize);
  }
#line 1330
  return (1);
  case_4353: 
#line 1333
  if (psf->have_written) {
#line 1334
    psf->error = 49;
#line 1335
    return (0);
  }
#line 1337
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1338
    psf->error = 31;
#line 1339
    return (0);
  } else
#line 1337
  if (datasize != (int )sizeof(*(psf->channel_map + 0)) * psf->sf.channels) {
#line 1338
    psf->error = 31;
#line 1339
    return (0);
  }
#line 1344
  iptr = (int *)data;
  {
#line 1344
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1344
    if (! ((unsigned long )iptr < (unsigned long )((int *)data + psf->sf.channels))) {
#line 1344
      goto while_break;
    }
#line 1345
    if (*iptr <= 0) {
#line 1346
      psf->error = 31;
#line 1347
      return (0);
    } else
#line 1345
    if (*iptr >= 27) {
#line 1346
      psf->error = 31;
#line 1347
      return (0);
    }
#line 1344
    iptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1352
  free((void *)psf->channel_map);
#line 1353
  tmp___6 = malloc((unsigned long )datasize);
#line 1353
  psf->channel_map = (int *)tmp___6;
  }
#line 1353
  if ((unsigned long )psf->channel_map == (unsigned long )((void *)0)) {
#line 1354
    psf->error = 17;
#line 1355
    return (0);
  }
  {
#line 1358
  memcpy((void *)psf->channel_map, (void const   *)data, (unsigned long )datasize);
  }
#line 1364
  if (psf->command) {
    {
#line 1365
    __cil_tmp50 = (*(psf->command))(psf, command, (void *)0, 0);
    }
#line 1365
    return (__cil_tmp50);
  }
#line 1366
  return (0);
  case_4864: 
#line 1369
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1370
    return (0);
  } else
#line 1369
  if ((unsigned long )datasize != sizeof(double )) {
#line 1370
    return (0);
  }
  {
#line 1372
  quality = *((double *)data);
#line 1373
  quality = 1. - (double )0;
#line 1374
  __cil_tmp51 = sf_command(sndfile, 4865, (void *)(& quality), (int )sizeof(quality));
  }
#line 1374
  return (__cil_tmp51);
  switch_default___0: 
#line 1379
  if (psf->command) {
    {
#line 1380
    __cil_tmp52 = (*(psf->command))(psf, command, data, datasize);
    }
#line 1380
    return (__cil_tmp52);
  }
  {
#line 1382
  psf_log_printf(psf, "*** sf_command : cmd = 0x%X\n", command);
#line 1383
  psf->error = 31;
  }
#line 1383
  return (psf->error);
  switch_break___0: ;
#line 1386
  return (0);
}
}
#line 1394 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_seek(SNDFILE *sndfile , sf_count_t offset , int whence ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t seek_from_start ;
  sf_count_t retval ;
  int __cil_tmp7 ;
  int new_mode ;
  int tmp ;

  {
#line 1396
  seek_from_start = (sf_count_t )0;
#line 1398
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1398
    sf_errno = 10;
#line 1398
    return ((sf_count_t )0);
  }
  {
#line 1398
  psf = (SF_PRIVATE *)sndfile;
#line 1398
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1398
  if (psf->virtual_io == 0) {
#line 1398
    if (__cil_tmp7 == 0) {
#line 1398
      psf->error = 13;
#line 1398
      return ((sf_count_t )0);
    }
  }
#line 1398
  if (psf->Magick != 305447134) {
#line 1398
    psf->error = 10;
#line 1398
    return ((sf_count_t )0);
  }
#line 1398
  psf->error = 0;
#line 1400
  if (! psf->sf.seekable) {
#line 1401
    psf->error = 41;
#line 1402
    return ((sf_count_t )-1);
  }
#line 1408
  if ((whence & 48) == 32) {
#line 1408
    if (psf->file.mode == 16) {
#line 1410
      psf->error = 43;
#line 1411
      return ((sf_count_t )-1);
    } else {
#line 1408
      goto _L;
    }
  } else
  _L: 
#line 1408
  if ((whence & 48) == 16) {
#line 1408
    if (psf->file.mode == 32) {
#line 1410
      psf->error = 43;
#line 1411
      return ((sf_count_t )-1);
    }
  }
#line 1422
  if (whence == 48) {
#line 1422
    goto case_48;
  }
#line 1422
  if (whence == 32) {
#line 1422
    goto case_48;
  }
#line 1422
  if (whence == 16) {
#line 1422
    goto case_48;
  }
#line 1422
  if (whence == 0) {
#line 1422
    goto case_48;
  }
#line 1427
  if (whence == 1) {
#line 1427
    goto case_1;
  }
#line 1442
  if (whence == 17) {
#line 1442
    goto case_17;
  }
#line 1448
  if (whence == 33) {
#line 1448
    goto case_33;
  }
#line 1457
  if (whence == 34) {
#line 1457
    goto case_34;
  }
#line 1457
  if (whence == 18) {
#line 1457
    goto case_34;
  }
#line 1457
  if (whence == 2) {
#line 1457
    goto case_34;
  }
#line 1461
  goto switch_default;
  case_48: 
#line 1423
  seek_from_start = offset;
#line 1424
  goto switch_break;
  case_1: 
#line 1428
  if (offset == 0L) {
#line 1429
    if (psf->file.mode == 16) {
#line 1430
      return (psf->read_current);
    }
#line 1431
    if (psf->file.mode == 32) {
#line 1432
      return (psf->write_current);
    }
  }
#line 1434
  if (psf->file.mode == 16) {
#line 1435
    seek_from_start = psf->read_current + offset;
  } else
#line 1436
  if (psf->file.mode == 32) {
#line 1437
    seek_from_start = psf->write_current + offset;
  } else
#line 1436
  if (psf->file.mode == 48) {
#line 1437
    seek_from_start = psf->write_current + offset;
  } else {
#line 1439
    psf->error = 42;
  }
#line 1440
  goto switch_break;
  case_17: 
#line 1443
  if (offset == 0L) {
#line 1444
    return (psf->read_current);
  }
#line 1445
  seek_from_start = psf->read_current + offset;
#line 1446
  goto switch_break;
  case_33: 
#line 1449
  if (offset == 0L) {
#line 1450
    return (psf->write_current);
  }
#line 1451
  seek_from_start = psf->write_current + offset;
#line 1452
  goto switch_break;
  case_34: 
#line 1458
  seek_from_start = psf->sf.frames + offset;
#line 1459
  goto switch_break;
  switch_default: 
#line 1462
  psf->error = 40;
#line 1463
  goto switch_break;
  switch_break: ;
#line 1466
  if (psf->error) {
#line 1467
    return ((sf_count_t )-1);
  }
#line 1469
  if (psf->file.mode == 48) {
    _L___56: 
#line 1470
    if (seek_from_start < 0L) {
#line 1471
      psf->error = 40;
#line 1472
      return ((sf_count_t )-1);
    }
  } else
#line 1469
  if (psf->file.mode == 32) {
#line 1469
    goto _L___56;
  } else
#line 1475
  if (seek_from_start < 0L) {
#line 1476
    psf->error = 40;
#line 1477
    return ((sf_count_t )-1);
  } else
#line 1475
  if (seek_from_start > psf->sf.frames) {
#line 1476
    psf->error = 40;
#line 1477
    return ((sf_count_t )-1);
  }
#line 1480
  if (psf->seek) {
#line 1481
    if (whence & 48) {
#line 1481
      tmp = whence & 48;
    } else {
#line 1481
      tmp = psf->file.mode;
    }
    {
#line 1481
    new_mode = tmp;
#line 1483
    retval = (*(psf->seek))(psf, new_mode, seek_from_start);
    }
#line 1486
    if (new_mode == 16) {
#line 1486
      goto case_16___0;
    }
#line 1489
    if (new_mode == 32) {
#line 1489
      goto case_32___0;
    }
#line 1492
    if (new_mode == 48) {
#line 1492
      goto case_48___0;
    }
#line 1485
    goto switch_break___0;
    case_16___0: 
#line 1487
    psf->read_current = retval;
#line 1488
    goto switch_break___0;
    case_32___0: 
#line 1490
    psf->write_current = retval;
#line 1491
    goto switch_break___0;
    case_48___0: 
#line 1493
    psf->read_current = retval;
#line 1494
    psf->write_current = retval;
#line 1495
    new_mode = 16;
#line 1496
    goto switch_break___0;
    switch_break___0: 
#line 1499
    psf->last_op = new_mode;
#line 1501
    return (retval);
  }
#line 1504
  psf->error = 42;
#line 1505
  return ((sf_count_t )-1);
}
}
#line 1513 "/root/patchweave_new/23/src/sndfile.c"
char const   *sf_get_string(SNDFILE *sndfile , int str_type ) 
{ 
  SF_PRIVATE *psf ;
  char const   *__cil_tmp4 ;

  {
#line 1516
  psf = (SF_PRIVATE *)sndfile;
#line 1516
  if ((unsigned long )psf == (unsigned long )((void *)0)) {
#line 1517
    return ((char const   *)((void *)0));
  }
#line 1518
  if (psf->Magick != 305447134) {
#line 1519
    return ((char const   *)((void *)0));
  }
  {
#line 1521
  __cil_tmp4 = psf_get_string(psf, str_type);
  }
#line 1521
  return (__cil_tmp4);
}
}
#line 1526 "/root/patchweave_new/23/src/sndfile.c"
int sf_set_string(SNDFILE *sndfile , int str_type , char const   *str___0 ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 1529
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1529
    sf_errno = 10;
#line 1529
    return (0);
  }
  {
#line 1529
  psf = (SF_PRIVATE *)sndfile;
#line 1529
  __cil_tmp5 = psf_file_valid(psf);
  }
#line 1529
  if (psf->virtual_io == 0) {
#line 1529
    if (__cil_tmp5 == 0) {
#line 1529
      psf->error = 13;
#line 1529
      return (0);
    }
  }
#line 1529
  if (psf->Magick != 305447134) {
#line 1529
    psf->error = 10;
#line 1529
    return (0);
  }
  {
#line 1529
  psf->error = 0;
#line 1531
  __cil_tmp6 = psf_set_string(psf, str_type, str___0);
  }
#line 1531
  return (__cil_tmp6);
}
}
#line 1539 "/root/patchweave_new/23/src/sndfile.c"
int sf_current_byterate(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp3 ;

  {
#line 1542
  psf = (SF_PRIVATE *)sndfile;
#line 1542
  if ((unsigned long )psf == (unsigned long )((void *)0)) {
#line 1543
    return (-1);
  }
#line 1544
  if (psf->Magick != 305447134) {
#line 1545
    return (-1);
  }
#line 1548
  if (psf->bytewidth) {
#line 1549
    return ((psf->sf.samplerate * psf->sf.channels) * psf->bytewidth);
  }
#line 1551
  if (psf->byterate) {
    {
#line 1552
    __cil_tmp3 = (*(psf->byterate))(psf);
    }
#line 1552
    return (__cil_tmp3);
  }
#line 1557
  if ((psf->sf.format & 65535) == 33) {
#line 1557
    goto case_33;
  }
#line 1557
  if ((psf->sf.format & 65535) == 19) {
#line 1557
    goto case_33;
  }
#line 1557
  if ((psf->sf.format & 65535) == 18) {
#line 1557
    goto case_33;
  }
#line 1560
  if ((psf->sf.format & 65535) == 32) {
#line 1560
    goto case_32;
  }
#line 1563
  if ((psf->sf.format & 65535) == 48) {
#line 1563
    goto case_48;
  }
#line 1566
  if ((psf->sf.format & 65535) == 49) {
#line 1566
    goto case_49;
  }
#line 1569
  if ((psf->sf.format & 65535) == 50) {
#line 1569
    goto case_50;
  }
#line 1572
  goto switch_default;
  case_33: 
#line 1558
  return ((psf->sf.samplerate * psf->sf.channels) / 2);
  case_32: 
#line 1561
  return (((psf->sf.samplerate * psf->sf.channels) * 13000) / 8000);
  case_48: 
#line 1564
  return ((psf->sf.samplerate * psf->sf.channels) / 2);
  case_49: 
#line 1567
  return (((psf->sf.samplerate * psf->sf.channels) * 3) / 8);
  case_50: 
#line 1570
  return (((psf->sf.samplerate * psf->sf.channels) * 5) / 8);
  switch_default: 
#line 1573
  goto switch_break;
  switch_break: ;
#line 1576
  return (-1);
}
}
#line 1584 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_read_raw(SNDFILE *sndfile , void *ptr , sf_count_t bytes ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int bytewidth ;
  int blockwidth ;
  int __cil_tmp9 ;
  int tmp ;
  int tmp___0 ;
  sf_count_t __cil_tmp12 ;

  {
#line 1589
  if (bytes == 0L) {
#line 1590
    return ((sf_count_t )0);
  }
#line 1592
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1592
    sf_errno = 10;
#line 1592
    return ((sf_count_t )0);
  }
  {
#line 1592
  psf = (SF_PRIVATE *)sndfile;
#line 1592
  __cil_tmp9 = psf_file_valid(psf);
  }
#line 1592
  if (psf->virtual_io == 0) {
#line 1592
    if (__cil_tmp9 == 0) {
#line 1592
      psf->error = 13;
#line 1592
      return ((sf_count_t )0);
    }
  }
#line 1592
  if (psf->Magick != 305447134) {
#line 1592
    psf->error = 10;
#line 1592
    return ((sf_count_t )0);
  }
#line 1592
  psf->error = 0;
#line 1594
  if (psf->bytewidth > 0) {
#line 1594
    tmp = psf->bytewidth;
  } else {
#line 1594
    tmp = 1;
  }
#line 1594
  bytewidth = tmp;
#line 1595
  if (psf->blockwidth > 0) {
#line 1595
    tmp___0 = psf->blockwidth;
  } else {
#line 1595
    tmp___0 = 1;
  }
#line 1595
  blockwidth = tmp___0;
#line 1597
  if (psf->file.mode == 32) {
#line 1598
    psf->error = 22;
#line 1599
    return ((sf_count_t )0);
  }
#line 1602
  if (bytes < 0L) {
    {
#line 1603
    psf_memset(ptr, 0, bytes);
    }
#line 1604
    return ((sf_count_t )0);
  } else
#line 1602
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1603
    psf_memset(ptr, 0, bytes);
    }
#line 1604
    return ((sf_count_t )0);
  }
#line 1607
  if (bytes % (long )(psf->sf.channels * bytewidth)) {
#line 1608
    psf->error = 19;
#line 1609
    return ((sf_count_t )0);
  }
#line 1612
  if (psf->last_op != 16) {
    {
#line 1613
    __cil_tmp12 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1613
    if (__cil_tmp12 < 0L) {
#line 1614
      return ((sf_count_t )0);
    }
  }
  {
#line 1616
  count___0 = psf_fread(ptr, (sf_count_t )1, bytes, psf);
  }
#line 1618
  if (psf->read_current + count___0 / (long )blockwidth <= psf->sf.frames) {
#line 1619
    psf->read_current += count___0 / (long )blockwidth;
  } else {
    {
#line 1621
    count___0 = (psf->sf.frames - psf->read_current) * (long )blockwidth;
#line 1622
    extra = bytes - count___0;
#line 1623
    psf_memset((void *)((char *)ptr + count___0), 0, extra);
#line 1624
    psf->read_current = psf->sf.frames;
    }
  }
#line 1627
  psf->last_op = 16;
#line 1629
  return (count___0);
}
}
#line 1637 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_read_short(SNDFILE *sndfile , short *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1641
  if (len == 0L) {
#line 1642
    return ((sf_count_t )0);
  }
#line 1644
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1644
    sf_errno = 10;
#line 1644
    return ((sf_count_t )0);
  }
  {
#line 1644
  psf = (SF_PRIVATE *)sndfile;
#line 1644
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1644
  if (psf->virtual_io == 0) {
#line 1644
    if (__cil_tmp7 == 0) {
#line 1644
      psf->error = 13;
#line 1644
      return ((sf_count_t )0);
    }
  }
#line 1644
  if (psf->Magick != 305447134) {
#line 1644
    psf->error = 10;
#line 1644
    return ((sf_count_t )0);
  }
#line 1644
  psf->error = 0;
#line 1646
  if (len <= 0L) {
#line 1647
    psf->error = 174;
#line 1648
    return ((sf_count_t )0);
  }
#line 1651
  if (psf->file.mode == 32) {
#line 1652
    psf->error = 22;
#line 1653
    return ((sf_count_t )0);
  }
#line 1656
  if (len % (long )psf->sf.channels) {
#line 1657
    psf->error = 19;
#line 1658
    return ((sf_count_t )0);
  }
#line 1661
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1662
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )len * sizeof(short )));
    }
#line 1663
    return ((sf_count_t )0);
  }
#line 1666
  if ((unsigned long )psf->read_short == (unsigned long )((void *)0)) {
#line 1667
    psf->error = 18;
#line 1668
    return ((sf_count_t )0);
  } else
#line 1666
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 1667
    psf->error = 18;
#line 1668
    return ((sf_count_t )0);
  }
#line 1671
  if (psf->last_op != 16) {
    {
#line 1672
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1672
    if (__cil_tmp8 < 0L) {
#line 1673
      return ((sf_count_t )0);
    }
  }
  {
#line 1675
  count___0 = (*(psf->read_short))(psf, ptr, len);
  }
#line 1677
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 1678
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 1680
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1681
    extra = len - count___0;
#line 1682
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(short )));
#line 1683
    psf->read_current = psf->sf.frames;
    }
  }
#line 1686
  psf->last_op = 16;
#line 1688
  return (count___0);
}
}
#line 1693 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_readf_short(SNDFILE *sndfile , short *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1697
  if (frames == 0L) {
#line 1698
    return ((sf_count_t )0);
  }
#line 1700
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1700
    sf_errno = 10;
#line 1700
    return ((sf_count_t )0);
  }
  {
#line 1700
  psf = (SF_PRIVATE *)sndfile;
#line 1700
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1700
  if (psf->virtual_io == 0) {
#line 1700
    if (__cil_tmp7 == 0) {
#line 1700
      psf->error = 13;
#line 1700
      return ((sf_count_t )0);
    }
  }
#line 1700
  if (psf->Magick != 305447134) {
#line 1700
    psf->error = 10;
#line 1700
    return ((sf_count_t )0);
  }
#line 1700
  psf->error = 0;
#line 1702
  if (frames <= 0L) {
#line 1703
    psf->error = 174;
#line 1704
    return ((sf_count_t )0);
  }
#line 1707
  if (psf->file.mode == 32) {
#line 1708
    psf->error = 22;
#line 1709
    return ((sf_count_t )0);
  }
#line 1712
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1713
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(short )));
    }
#line 1714
    return ((sf_count_t )0);
  }
#line 1717
  if ((unsigned long )psf->read_short == (unsigned long )((void *)0)) {
#line 1718
    psf->error = 18;
#line 1719
    return ((sf_count_t )0);
  } else
#line 1717
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 1718
    psf->error = 18;
#line 1719
    return ((sf_count_t )0);
  }
#line 1722
  if (psf->last_op != 16) {
    {
#line 1723
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1723
    if (__cil_tmp8 < 0L) {
#line 1724
      return ((sf_count_t )0);
    }
  }
  {
#line 1726
  count___0 = (*(psf->read_short))(psf, ptr, frames * (long )psf->sf.channels);
  }
#line 1728
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 1729
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 1731
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1732
    extra = frames * (long )psf->sf.channels - count___0;
#line 1733
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(short )));
#line 1734
    psf->read_current = psf->sf.frames;
    }
  }
#line 1737
  psf->last_op = 16;
#line 1739
  return (count___0 / (long )psf->sf.channels);
}
}
#line 1747 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_read_int(SNDFILE *sndfile , int *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1751
  if (len == 0L) {
#line 1752
    return ((sf_count_t )0);
  }
#line 1754
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1754
    sf_errno = 10;
#line 1754
    return ((sf_count_t )0);
  }
  {
#line 1754
  psf = (SF_PRIVATE *)sndfile;
#line 1754
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1754
  if (psf->virtual_io == 0) {
#line 1754
    if (__cil_tmp7 == 0) {
#line 1754
      psf->error = 13;
#line 1754
      return ((sf_count_t )0);
    }
  }
#line 1754
  if (psf->Magick != 305447134) {
#line 1754
    psf->error = 10;
#line 1754
    return ((sf_count_t )0);
  }
#line 1754
  psf->error = 0;
#line 1756
  if (len <= 0L) {
#line 1757
    psf->error = 174;
#line 1758
    return ((sf_count_t )0);
  }
#line 1761
  if (psf->file.mode == 32) {
#line 1762
    psf->error = 22;
#line 1763
    return ((sf_count_t )0);
  }
#line 1766
  if (len % (long )psf->sf.channels) {
#line 1767
    psf->error = 19;
#line 1768
    return ((sf_count_t )0);
  }
#line 1771
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1772
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )len * sizeof(int )));
    }
#line 1773
    return ((sf_count_t )0);
  }
#line 1776
  if ((unsigned long )psf->read_int == (unsigned long )((void *)0)) {
#line 1777
    psf->error = 18;
#line 1778
    return ((sf_count_t )0);
  } else
#line 1776
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 1777
    psf->error = 18;
#line 1778
    return ((sf_count_t )0);
  }
#line 1781
  if (psf->last_op != 16) {
    {
#line 1782
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1782
    if (__cil_tmp8 < 0L) {
#line 1783
      return ((sf_count_t )0);
    }
  }
  {
#line 1785
  count___0 = (*(psf->read_int))(psf, ptr, len);
  }
#line 1787
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 1788
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 1790
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1791
    extra = len - count___0;
#line 1792
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(int )));
#line 1793
    psf->read_current = psf->sf.frames;
    }
  }
#line 1796
  psf->last_op = 16;
#line 1798
  return (count___0);
}
}
#line 1803 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_readf_int(SNDFILE *sndfile , int *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1807
  if (frames == 0L) {
#line 1808
    return ((sf_count_t )0);
  }
#line 1810
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1810
    sf_errno = 10;
#line 1810
    return ((sf_count_t )0);
  }
  {
#line 1810
  psf = (SF_PRIVATE *)sndfile;
#line 1810
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1810
  if (psf->virtual_io == 0) {
#line 1810
    if (__cil_tmp7 == 0) {
#line 1810
      psf->error = 13;
#line 1810
      return ((sf_count_t )0);
    }
  }
#line 1810
  if (psf->Magick != 305447134) {
#line 1810
    psf->error = 10;
#line 1810
    return ((sf_count_t )0);
  }
#line 1810
  psf->error = 0;
#line 1812
  if (frames <= 0L) {
#line 1813
    psf->error = 174;
#line 1814
    return ((sf_count_t )0);
  }
#line 1817
  if (psf->file.mode == 32) {
#line 1818
    psf->error = 22;
#line 1819
    return ((sf_count_t )0);
  }
#line 1822
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1823
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(int )));
    }
#line 1824
    return ((sf_count_t )0);
  }
#line 1827
  if ((unsigned long )psf->read_int == (unsigned long )((void *)0)) {
#line 1828
    psf->error = 18;
#line 1829
    return ((sf_count_t )0);
  } else
#line 1827
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 1828
    psf->error = 18;
#line 1829
    return ((sf_count_t )0);
  }
#line 1832
  if (psf->last_op != 16) {
    {
#line 1833
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1833
    if (__cil_tmp8 < 0L) {
#line 1834
      return ((sf_count_t )0);
    }
  }
  {
#line 1836
  count___0 = (*(psf->read_int))(psf, ptr, frames * (long )psf->sf.channels);
  }
#line 1838
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 1839
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 1841
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1842
    extra = frames * (long )psf->sf.channels - count___0;
#line 1843
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(int )));
#line 1844
    psf->read_current = psf->sf.frames;
    }
  }
#line 1847
  psf->last_op = 16;
#line 1849
  return (count___0 / (long )psf->sf.channels);
}
}
#line 1857 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_read_float(SNDFILE *sndfile , float *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1861
  if (len == 0L) {
#line 1862
    return ((sf_count_t )0);
  }
#line 1864
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1864
    sf_errno = 10;
#line 1864
    return ((sf_count_t )0);
  }
  {
#line 1864
  psf = (SF_PRIVATE *)sndfile;
#line 1864
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1864
  if (psf->virtual_io == 0) {
#line 1864
    if (__cil_tmp7 == 0) {
#line 1864
      psf->error = 13;
#line 1864
      return ((sf_count_t )0);
    }
  }
#line 1864
  if (psf->Magick != 305447134) {
#line 1864
    psf->error = 10;
#line 1864
    return ((sf_count_t )0);
  }
#line 1864
  psf->error = 0;
#line 1866
  if (len <= 0L) {
#line 1867
    psf->error = 174;
#line 1868
    return ((sf_count_t )0);
  }
#line 1871
  if (psf->file.mode == 32) {
#line 1872
    psf->error = 22;
#line 1873
    return ((sf_count_t )0);
  }
#line 1876
  if (len % (long )psf->sf.channels) {
#line 1877
    psf->error = 19;
#line 1878
    return ((sf_count_t )0);
  }
#line 1881
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1882
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )len * sizeof(float )));
    }
#line 1883
    return ((sf_count_t )0);
  }
#line 1886
  if ((unsigned long )psf->read_float == (unsigned long )((void *)0)) {
#line 1887
    psf->error = 18;
#line 1888
    return ((sf_count_t )0);
  } else
#line 1886
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 1887
    psf->error = 18;
#line 1888
    return ((sf_count_t )0);
  }
#line 1891
  if (psf->last_op != 16) {
    {
#line 1892
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1892
    if (__cil_tmp8 < 0L) {
#line 1893
      return ((sf_count_t )0);
    }
  }
  {
#line 1895
  count___0 = (*(psf->read_float))(psf, ptr, len);
  }
#line 1897
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 1898
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 1900
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1901
    extra = len - count___0;
#line 1902
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(float )));
#line 1903
    psf->read_current = psf->sf.frames;
    }
  }
#line 1906
  psf->last_op = 16;
#line 1908
  return (count___0);
}
}
#line 1913 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_readf_float(SNDFILE *sndfile , float *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1917
  if (frames == 0L) {
#line 1918
    return ((sf_count_t )0);
  }
#line 1920
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1920
    sf_errno = 10;
#line 1920
    return ((sf_count_t )0);
  }
  {
#line 1920
  psf = (SF_PRIVATE *)sndfile;
#line 1920
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1920
  if (psf->virtual_io == 0) {
#line 1920
    if (__cil_tmp7 == 0) {
#line 1920
      psf->error = 13;
#line 1920
      return ((sf_count_t )0);
    }
  }
#line 1920
  if (psf->Magick != 305447134) {
#line 1920
    psf->error = 10;
#line 1920
    return ((sf_count_t )0);
  }
#line 1920
  psf->error = 0;
#line 1922
  if (frames <= 0L) {
#line 1923
    psf->error = 174;
#line 1924
    return ((sf_count_t )0);
  }
#line 1927
  if (psf->file.mode == 32) {
#line 1928
    psf->error = 22;
#line 1929
    return ((sf_count_t )0);
  }
#line 1932
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1933
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(float )));
    }
#line 1934
    return ((sf_count_t )0);
  }
#line 1937
  if ((unsigned long )psf->read_float == (unsigned long )((void *)0)) {
#line 1938
    psf->error = 18;
#line 1939
    return ((sf_count_t )0);
  } else
#line 1937
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 1938
    psf->error = 18;
#line 1939
    return ((sf_count_t )0);
  }
#line 1942
  if (psf->last_op != 16) {
    {
#line 1943
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1943
    if (__cil_tmp8 < 0L) {
#line 1944
      return ((sf_count_t )0);
    }
  }
  {
#line 1946
  count___0 = (*(psf->read_float))(psf, ptr, frames * (long )psf->sf.channels);
  }
#line 1948
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 1949
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 1951
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1952
    extra = frames * (long )psf->sf.channels - count___0;
#line 1953
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(float )));
#line 1954
    psf->read_current = psf->sf.frames;
    }
  }
#line 1957
  psf->last_op = 16;
#line 1959
  return (count___0 / (long )psf->sf.channels);
}
}
#line 1967 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_read_double(SNDFILE *sndfile , double *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1971
  if (len == 0L) {
#line 1972
    return ((sf_count_t )0);
  }
#line 1974
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1974
    sf_errno = 10;
#line 1974
    return ((sf_count_t )0);
  }
  {
#line 1974
  psf = (SF_PRIVATE *)sndfile;
#line 1974
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1974
  if (psf->virtual_io == 0) {
#line 1974
    if (__cil_tmp7 == 0) {
#line 1974
      psf->error = 13;
#line 1974
      return ((sf_count_t )0);
    }
  }
#line 1974
  if (psf->Magick != 305447134) {
#line 1974
    psf->error = 10;
#line 1974
    return ((sf_count_t )0);
  }
#line 1974
  psf->error = 0;
#line 1976
  if (len <= 0L) {
#line 1977
    psf->error = 174;
#line 1978
    return ((sf_count_t )0);
  }
#line 1981
  if (psf->file.mode == 32) {
#line 1982
    psf->error = 22;
#line 1983
    return ((sf_count_t )0);
  }
#line 1986
  if (len % (long )psf->sf.channels) {
#line 1987
    psf->error = 19;
#line 1988
    return ((sf_count_t )0);
  }
#line 1991
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1992
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )len * sizeof(double )));
    }
#line 1993
    return ((sf_count_t )0);
  }
#line 1996
  if ((unsigned long )psf->read_double == (unsigned long )((void *)0)) {
#line 1997
    psf->error = 18;
#line 1998
    return ((sf_count_t )0);
  } else
#line 1996
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 1997
    psf->error = 18;
#line 1998
    return ((sf_count_t )0);
  }
#line 2001
  if (psf->last_op != 16) {
    {
#line 2002
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 2002
    if (__cil_tmp8 < 0L) {
#line 2003
      return ((sf_count_t )0);
    }
  }
  {
#line 2005
  count___0 = (*(psf->read_double))(psf, ptr, len);
  }
#line 2007
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 2008
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 2010
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 2011
    extra = len - count___0;
#line 2012
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(double )));
#line 2013
    psf->read_current = psf->sf.frames;
    }
  }
#line 2016
  psf->last_op = 16;
#line 2018
  return (count___0);
}
}
#line 2023 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_readf_double(SNDFILE *sndfile , double *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 2027
  if (frames == 0L) {
#line 2028
    return ((sf_count_t )0);
  }
#line 2030
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2030
    sf_errno = 10;
#line 2030
    return ((sf_count_t )0);
  }
  {
#line 2030
  psf = (SF_PRIVATE *)sndfile;
#line 2030
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 2030
  if (psf->virtual_io == 0) {
#line 2030
    if (__cil_tmp7 == 0) {
#line 2030
      psf->error = 13;
#line 2030
      return ((sf_count_t )0);
    }
  }
#line 2030
  if (psf->Magick != 305447134) {
#line 2030
    psf->error = 10;
#line 2030
    return ((sf_count_t )0);
  }
#line 2030
  psf->error = 0;
#line 2032
  if (frames <= 0L) {
#line 2033
    psf->error = 174;
#line 2034
    return ((sf_count_t )0);
  }
#line 2037
  if (psf->file.mode == 32) {
#line 2038
    psf->error = 22;
#line 2039
    return ((sf_count_t )0);
  }
#line 2042
  if (psf->read_current >= psf->sf.frames) {
    {
#line 2043
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(double )));
    }
#line 2044
    return ((sf_count_t )0);
  }
#line 2047
  if ((unsigned long )psf->read_double == (unsigned long )((void *)0)) {
#line 2048
    psf->error = 18;
#line 2049
    return ((sf_count_t )0);
  } else
#line 2047
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2048
    psf->error = 18;
#line 2049
    return ((sf_count_t )0);
  }
#line 2052
  if (psf->last_op != 16) {
    {
#line 2053
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 2053
    if (__cil_tmp8 < 0L) {
#line 2054
      return ((sf_count_t )0);
    }
  }
  {
#line 2056
  count___0 = (*(psf->read_double))(psf, ptr, frames * (long )psf->sf.channels);
  }
#line 2058
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 2059
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 2061
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 2062
    extra = frames * (long )psf->sf.channels - count___0;
#line 2063
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(double )));
#line 2064
    psf->read_current = psf->sf.frames;
    }
  }
#line 2067
  psf->last_op = 16;
#line 2069
  return (count___0 / (long )psf->sf.channels);
}
}
#line 2077 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_write_raw(SNDFILE *sndfile , void const   *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int bytewidth ;
  int blockwidth ;
  int __cil_tmp8 ;
  int tmp ;
  int tmp___0 ;
  sf_count_t __cil_tmp11 ;

  {
#line 2082
  if (len == 0L) {
#line 2083
    return ((sf_count_t )0);
  }
#line 2085
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2085
    sf_errno = 10;
#line 2085
    return ((sf_count_t )0);
  }
  {
#line 2085
  psf = (SF_PRIVATE *)sndfile;
#line 2085
  __cil_tmp8 = psf_file_valid(psf);
  }
#line 2085
  if (psf->virtual_io == 0) {
#line 2085
    if (__cil_tmp8 == 0) {
#line 2085
      psf->error = 13;
#line 2085
      return ((sf_count_t )0);
    }
  }
#line 2085
  if (psf->Magick != 305447134) {
#line 2085
    psf->error = 10;
#line 2085
    return ((sf_count_t )0);
  }
#line 2085
  psf->error = 0;
#line 2087
  if (len <= 0L) {
#line 2088
    psf->error = 174;
#line 2089
    return ((sf_count_t )0);
  }
#line 2092
  if (psf->bytewidth > 0) {
#line 2092
    tmp = psf->bytewidth;
  } else {
#line 2092
    tmp = 1;
  }
#line 2092
  bytewidth = tmp;
#line 2093
  if (psf->blockwidth > 0) {
#line 2093
    tmp___0 = psf->blockwidth;
  } else {
#line 2093
    tmp___0 = 1;
  }
#line 2093
  blockwidth = tmp___0;
#line 2095
  if (psf->file.mode == 16) {
#line 2096
    psf->error = 23;
#line 2097
    return ((sf_count_t )0);
  }
#line 2100
  if (len % (long )(psf->sf.channels * bytewidth)) {
#line 2101
    psf->error = 20;
#line 2102
    return ((sf_count_t )0);
  }
#line 2105
  if (psf->last_op != 32) {
    {
#line 2106
    __cil_tmp11 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2106
    if (__cil_tmp11 < 0L) {
#line 2107
      return ((sf_count_t )0);
    }
  }
#line 2109
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2109
    if (psf->have_written == 0) {
      {
#line 2110
      psf->error = (*(psf->write_header))(psf, 0);
      }
#line 2110
      if (psf->error) {
#line 2111
        return ((sf_count_t )0);
      }
    }
  }
  {
#line 2113
  psf->have_written = 1;
#line 2115
  count___0 = psf_fwrite(ptr, (sf_count_t )1, len, psf);
#line 2117
  psf->write_current += count___0 / (long )blockwidth;
#line 2119
  psf->last_op = 32;
  }
#line 2121
  if (psf->write_current > psf->sf.frames) {
#line 2122
    psf->sf.frames = psf->write_current;
#line 2123
    psf->dataend = (sf_count_t )0;
  }
#line 2126
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2126
    if (psf->auto_header) {
      {
#line 2127
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2129
  return (count___0);
}
}
#line 2137 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_write_short(SNDFILE *sndfile , short const   *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 2141
  if (len == 0L) {
#line 2142
    return ((sf_count_t )0);
  }
#line 2144
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2144
    sf_errno = 10;
#line 2144
    return ((sf_count_t )0);
  }
  {
#line 2144
  psf = (SF_PRIVATE *)sndfile;
#line 2144
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2144
  if (psf->virtual_io == 0) {
#line 2144
    if (__cil_tmp6 == 0) {
#line 2144
      psf->error = 13;
#line 2144
      return ((sf_count_t )0);
    }
  }
#line 2144
  if (psf->Magick != 305447134) {
#line 2144
    psf->error = 10;
#line 2144
    return ((sf_count_t )0);
  }
#line 2144
  psf->error = 0;
#line 2146
  if (len <= 0L) {
#line 2147
    psf->error = 174;
#line 2148
    return ((sf_count_t )0);
  }
#line 2151
  if (psf->file.mode == 16) {
#line 2152
    psf->error = 23;
#line 2153
    return ((sf_count_t )0);
  }
#line 2156
  if (len % (long )psf->sf.channels) {
#line 2157
    psf->error = 20;
#line 2158
    return ((sf_count_t )0);
  }
#line 2161
  if ((unsigned long )psf->write_short == (unsigned long )((void *)0)) {
#line 2162
    psf->error = 18;
#line 2163
    return ((sf_count_t )0);
  } else
#line 2161
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2162
    psf->error = 18;
#line 2163
    return ((sf_count_t )0);
  }
#line 2166
  if (psf->last_op != 32) {
    {
#line 2167
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2167
    if (__cil_tmp7 < 0L) {
#line 2168
      return ((sf_count_t )0);
    }
  }
#line 2170
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2170
    if (psf->have_written == 0) {
      {
#line 2171
      psf->error = (*(psf->write_header))(psf, 0);
      }
#line 2171
      if (psf->error) {
#line 2172
        return ((sf_count_t )0);
      }
    }
  }
  {
#line 2174
  psf->have_written = 1;
#line 2176
  count___0 = (*(psf->write_short))(psf, ptr, len);
#line 2178
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2180
  psf->last_op = 32;
  }
#line 2182
  if (psf->write_current > psf->sf.frames) {
#line 2183
    psf->sf.frames = psf->write_current;
#line 2184
    psf->dataend = (sf_count_t )0;
  }
#line 2187
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2187
    if (psf->auto_header) {
      {
#line 2188
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2190
  return (count___0);
}
}
#line 2195 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_writef_short(SNDFILE *sndfile , short const   *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 2199
  if (frames == 0L) {
#line 2200
    return ((sf_count_t )0);
  }
#line 2202
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2202
    sf_errno = 10;
#line 2202
    return ((sf_count_t )0);
  }
  {
#line 2202
  psf = (SF_PRIVATE *)sndfile;
#line 2202
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2202
  if (psf->virtual_io == 0) {
#line 2202
    if (__cil_tmp6 == 0) {
#line 2202
      psf->error = 13;
#line 2202
      return ((sf_count_t )0);
    }
  }
#line 2202
  if (psf->Magick != 305447134) {
#line 2202
    psf->error = 10;
#line 2202
    return ((sf_count_t )0);
  }
#line 2202
  psf->error = 0;
#line 2204
  if (frames <= 0L) {
#line 2205
    psf->error = 174;
#line 2206
    return ((sf_count_t )0);
  }
#line 2209
  if (psf->file.mode == 16) {
#line 2210
    psf->error = 23;
#line 2211
    return ((sf_count_t )0);
  }
#line 2214
  if ((unsigned long )psf->write_short == (unsigned long )((void *)0)) {
#line 2215
    psf->error = 18;
#line 2216
    return ((sf_count_t )0);
  } else
#line 2214
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2215
    psf->error = 18;
#line 2216
    return ((sf_count_t )0);
  }
#line 2219
  if (psf->last_op != 32) {
    {
#line 2220
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2220
    if (__cil_tmp7 < 0L) {
#line 2221
      return ((sf_count_t )0);
    }
  }
#line 2223
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2223
    if (psf->have_written == 0) {
      {
#line 2224
      psf->error = (*(psf->write_header))(psf, 0);
      }
#line 2224
      if (psf->error) {
#line 2225
        return ((sf_count_t )0);
      }
    }
  }
  {
#line 2227
  psf->have_written = 1;
#line 2229
  count___0 = (*(psf->write_short))(psf, ptr, frames * (long )psf->sf.channels);
#line 2231
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2233
  psf->last_op = 32;
  }
#line 2235
  if (psf->write_current > psf->sf.frames) {
#line 2236
    psf->sf.frames = psf->write_current;
#line 2237
    psf->dataend = (sf_count_t )0;
  }
#line 2240
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2240
    if (psf->auto_header) {
      {
#line 2241
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2243
  return (count___0 / (long )psf->sf.channels);
}
}
#line 2251 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_write_int(SNDFILE *sndfile , int const   *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 2255
  if (len == 0L) {
#line 2256
    return ((sf_count_t )0);
  }
#line 2258
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2258
    sf_errno = 10;
#line 2258
    return ((sf_count_t )0);
  }
  {
#line 2258
  psf = (SF_PRIVATE *)sndfile;
#line 2258
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2258
  if (psf->virtual_io == 0) {
#line 2258
    if (__cil_tmp6 == 0) {
#line 2258
      psf->error = 13;
#line 2258
      return ((sf_count_t )0);
    }
  }
#line 2258
  if (psf->Magick != 305447134) {
#line 2258
    psf->error = 10;
#line 2258
    return ((sf_count_t )0);
  }
#line 2258
  psf->error = 0;
#line 2260
  if (len <= 0L) {
#line 2261
    psf->error = 174;
#line 2262
    return ((sf_count_t )0);
  }
#line 2265
  if (psf->file.mode == 16) {
#line 2266
    psf->error = 23;
#line 2267
    return ((sf_count_t )0);
  }
#line 2270
  if (len % (long )psf->sf.channels) {
#line 2271
    psf->error = 20;
#line 2272
    return ((sf_count_t )0);
  }
#line 2275
  if ((unsigned long )psf->write_int == (unsigned long )((void *)0)) {
#line 2276
    psf->error = 18;
#line 2277
    return ((sf_count_t )0);
  } else
#line 2275
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2276
    psf->error = 18;
#line 2277
    return ((sf_count_t )0);
  }
#line 2280
  if (psf->last_op != 32) {
    {
#line 2281
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2281
    if (__cil_tmp7 < 0L) {
#line 2282
      return ((sf_count_t )0);
    }
  }
#line 2284
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2284
    if (psf->have_written == 0) {
      {
#line 2285
      psf->error = (*(psf->write_header))(psf, 0);
      }
#line 2285
      if (psf->error) {
#line 2286
        return ((sf_count_t )0);
      }
    }
  }
  {
#line 2288
  psf->have_written = 1;
#line 2290
  count___0 = (*(psf->write_int))(psf, ptr, len);
#line 2292
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2294
  psf->last_op = 32;
  }
#line 2296
  if (psf->write_current > psf->sf.frames) {
#line 2297
    psf->sf.frames = psf->write_current;
#line 2298
    psf->dataend = (sf_count_t )0;
  }
#line 2301
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2301
    if (psf->auto_header) {
      {
#line 2302
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2304
  return (count___0);
}
}
#line 2309 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_writef_int(SNDFILE *sndfile , int const   *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 2313
  if (frames == 0L) {
#line 2314
    return ((sf_count_t )0);
  }
#line 2316
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2316
    sf_errno = 10;
#line 2316
    return ((sf_count_t )0);
  }
  {
#line 2316
  psf = (SF_PRIVATE *)sndfile;
#line 2316
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2316
  if (psf->virtual_io == 0) {
#line 2316
    if (__cil_tmp6 == 0) {
#line 2316
      psf->error = 13;
#line 2316
      return ((sf_count_t )0);
    }
  }
#line 2316
  if (psf->Magick != 305447134) {
#line 2316
    psf->error = 10;
#line 2316
    return ((sf_count_t )0);
  }
#line 2316
  psf->error = 0;
#line 2318
  if (frames <= 0L) {
#line 2319
    psf->error = 174;
#line 2320
    return ((sf_count_t )0);
  }
#line 2323
  if (psf->file.mode == 16) {
#line 2324
    psf->error = 23;
#line 2325
    return ((sf_count_t )0);
  }
#line 2328
  if ((unsigned long )psf->write_int == (unsigned long )((void *)0)) {
#line 2329
    psf->error = 18;
#line 2330
    return ((sf_count_t )0);
  } else
#line 2328
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2329
    psf->error = 18;
#line 2330
    return ((sf_count_t )0);
  }
#line 2333
  if (psf->last_op != 32) {
    {
#line 2334
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2334
    if (__cil_tmp7 < 0L) {
#line 2335
      return ((sf_count_t )0);
    }
  }
#line 2337
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2337
    if (psf->have_written == 0) {
      {
#line 2338
      psf->error = (*(psf->write_header))(psf, 0);
      }
#line 2338
      if (psf->error) {
#line 2339
        return ((sf_count_t )0);
      }
    }
  }
  {
#line 2341
  psf->have_written = 1;
#line 2343
  count___0 = (*(psf->write_int))(psf, ptr, frames * (long )psf->sf.channels);
#line 2345
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2347
  psf->last_op = 32;
  }
#line 2349
  if (psf->write_current > psf->sf.frames) {
#line 2350
    psf->sf.frames = psf->write_current;
#line 2351
    psf->dataend = (sf_count_t )0;
  }
#line 2354
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2354
    if (psf->auto_header) {
      {
#line 2355
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2357
  return (count___0 / (long )psf->sf.channels);
}
}
#line 2365 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_write_float(SNDFILE *sndfile , float const   *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 2369
  if (len == 0L) {
#line 2370
    return ((sf_count_t )0);
  }
#line 2372
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2372
    sf_errno = 10;
#line 2372
    return ((sf_count_t )0);
  }
  {
#line 2372
  psf = (SF_PRIVATE *)sndfile;
#line 2372
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2372
  if (psf->virtual_io == 0) {
#line 2372
    if (__cil_tmp6 == 0) {
#line 2372
      psf->error = 13;
#line 2372
      return ((sf_count_t )0);
    }
  }
#line 2372
  if (psf->Magick != 305447134) {
#line 2372
    psf->error = 10;
#line 2372
    return ((sf_count_t )0);
  }
#line 2372
  psf->error = 0;
#line 2374
  if (len <= 0L) {
#line 2375
    psf->error = 174;
#line 2376
    return ((sf_count_t )0);
  }
#line 2379
  if (psf->file.mode == 16) {
#line 2380
    psf->error = 23;
#line 2381
    return ((sf_count_t )0);
  }
#line 2384
  if (len % (long )psf->sf.channels) {
#line 2385
    psf->error = 20;
#line 2386
    return ((sf_count_t )0);
  }
#line 2389
  if ((unsigned long )psf->write_float == (unsigned long )((void *)0)) {
#line 2390
    psf->error = 18;
#line 2391
    return ((sf_count_t )0);
  } else
#line 2389
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2390
    psf->error = 18;
#line 2391
    return ((sf_count_t )0);
  }
#line 2394
  if (psf->last_op != 32) {
    {
#line 2395
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2395
    if (__cil_tmp7 < 0L) {
#line 2396
      return ((sf_count_t )0);
    }
  }
#line 2398
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2398
    if (psf->have_written == 0) {
      {
#line 2399
      psf->error = (*(psf->write_header))(psf, 0);
      }
#line 2399
      if (psf->error) {
#line 2400
        return ((sf_count_t )0);
      }
    }
  }
  {
#line 2402
  psf->have_written = 1;
#line 2404
  count___0 = (*(psf->write_float))(psf, ptr, len);
#line 2406
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2408
  psf->last_op = 32;
  }
#line 2410
  if (psf->write_current > psf->sf.frames) {
#line 2411
    psf->sf.frames = psf->write_current;
#line 2412
    psf->dataend = (sf_count_t )0;
  }
#line 2415
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2415
    if (psf->auto_header) {
      {
#line 2416
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2418
  return (count___0);
}
}
#line 2423 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_writef_float(SNDFILE *sndfile , float const   *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 2427
  if (frames == 0L) {
#line 2428
    return ((sf_count_t )0);
  }
#line 2430
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2430
    sf_errno = 10;
#line 2430
    return ((sf_count_t )0);
  }
  {
#line 2430
  psf = (SF_PRIVATE *)sndfile;
#line 2430
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2430
  if (psf->virtual_io == 0) {
#line 2430
    if (__cil_tmp6 == 0) {
#line 2430
      psf->error = 13;
#line 2430
      return ((sf_count_t )0);
    }
  }
#line 2430
  if (psf->Magick != 305447134) {
#line 2430
    psf->error = 10;
#line 2430
    return ((sf_count_t )0);
  }
#line 2430
  psf->error = 0;
#line 2432
  if (frames <= 0L) {
#line 2433
    psf->error = 174;
#line 2434
    return ((sf_count_t )0);
  }
#line 2437
  if (psf->file.mode == 16) {
#line 2438
    psf->error = 23;
#line 2439
    return ((sf_count_t )0);
  }
#line 2442
  if ((unsigned long )psf->write_float == (unsigned long )((void *)0)) {
#line 2443
    psf->error = 18;
#line 2444
    return ((sf_count_t )0);
  } else
#line 2442
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2443
    psf->error = 18;
#line 2444
    return ((sf_count_t )0);
  }
#line 2447
  if (psf->last_op != 32) {
    {
#line 2448
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2448
    if (__cil_tmp7 < 0L) {
#line 2449
      return ((sf_count_t )0);
    }
  }
#line 2451
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2451
    if (psf->have_written == 0) {
      {
#line 2452
      psf->error = (*(psf->write_header))(psf, 0);
      }
#line 2452
      if (psf->error) {
#line 2453
        return ((sf_count_t )0);
      }
    }
  }
  {
#line 2455
  psf->have_written = 1;
#line 2457
  count___0 = (*(psf->write_float))(psf, ptr, frames * (long )psf->sf.channels);
#line 2459
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2461
  psf->last_op = 32;
  }
#line 2463
  if (psf->write_current > psf->sf.frames) {
#line 2464
    psf->sf.frames = psf->write_current;
#line 2465
    psf->dataend = (sf_count_t )0;
  }
#line 2468
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2468
    if (psf->auto_header) {
      {
#line 2469
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2471
  return (count___0 / (long )psf->sf.channels);
}
}
#line 2479 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_write_double(SNDFILE *sndfile , double const   *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 2483
  if (len == 0L) {
#line 2484
    return ((sf_count_t )0);
  }
#line 2486
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2486
    sf_errno = 10;
#line 2486
    return ((sf_count_t )0);
  }
  {
#line 2486
  psf = (SF_PRIVATE *)sndfile;
#line 2486
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2486
  if (psf->virtual_io == 0) {
#line 2486
    if (__cil_tmp6 == 0) {
#line 2486
      psf->error = 13;
#line 2486
      return ((sf_count_t )0);
    }
  }
#line 2486
  if (psf->Magick != 305447134) {
#line 2486
    psf->error = 10;
#line 2486
    return ((sf_count_t )0);
  }
#line 2486
  psf->error = 0;
#line 2488
  if (len <= 0L) {
#line 2489
    psf->error = 174;
#line 2490
    return ((sf_count_t )0);
  }
#line 2493
  if (psf->file.mode == 16) {
#line 2494
    psf->error = 23;
#line 2495
    return ((sf_count_t )0);
  }
#line 2498
  if (len % (long )psf->sf.channels) {
#line 2499
    psf->error = 20;
#line 2500
    return ((sf_count_t )0);
  }
#line 2503
  if ((unsigned long )psf->write_double == (unsigned long )((void *)0)) {
#line 2504
    psf->error = 18;
#line 2505
    return ((sf_count_t )0);
  } else
#line 2503
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2504
    psf->error = 18;
#line 2505
    return ((sf_count_t )0);
  }
#line 2508
  if (psf->last_op != 32) {
    {
#line 2509
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2509
    if (__cil_tmp7 < 0L) {
#line 2510
      return ((sf_count_t )0);
    }
  }
#line 2512
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2512
    if (psf->have_written == 0) {
      {
#line 2513
      psf->error = (*(psf->write_header))(psf, 0);
      }
#line 2513
      if (psf->error) {
#line 2514
        return ((sf_count_t )0);
      }
    }
  }
  {
#line 2516
  psf->have_written = 1;
#line 2518
  count___0 = (*(psf->write_double))(psf, ptr, len);
#line 2520
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2522
  psf->last_op = 32;
  }
#line 2524
  if (psf->write_current > psf->sf.frames) {
#line 2525
    psf->sf.frames = psf->write_current;
#line 2526
    psf->dataend = (sf_count_t )0;
  }
#line 2529
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2529
    if (psf->auto_header) {
      {
#line 2530
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2532
  return (count___0);
}
}
#line 2537 "/root/patchweave_new/23/src/sndfile.c"
sf_count_t sf_writef_double(SNDFILE *sndfile , double const   *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 2541
  if (frames == 0L) {
#line 2542
    return ((sf_count_t )0);
  }
#line 2544
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2544
    sf_errno = 10;
#line 2544
    return ((sf_count_t )0);
  }
  {
#line 2544
  psf = (SF_PRIVATE *)sndfile;
#line 2544
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2544
  if (psf->virtual_io == 0) {
#line 2544
    if (__cil_tmp6 == 0) {
#line 2544
      psf->error = 13;
#line 2544
      return ((sf_count_t )0);
    }
  }
#line 2544
  if (psf->Magick != 305447134) {
#line 2544
    psf->error = 10;
#line 2544
    return ((sf_count_t )0);
  }
#line 2544
  psf->error = 0;
#line 2546
  if (frames <= 0L) {
#line 2547
    psf->error = 174;
#line 2548
    return ((sf_count_t )0);
  }
#line 2551
  if (psf->file.mode == 16) {
#line 2552
    psf->error = 23;
#line 2553
    return ((sf_count_t )0);
  }
#line 2556
  if ((unsigned long )psf->write_double == (unsigned long )((void *)0)) {
#line 2557
    psf->error = 18;
#line 2558
    return ((sf_count_t )0);
  } else
#line 2556
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2557
    psf->error = 18;
#line 2558
    return ((sf_count_t )0);
  }
#line 2561
  if (psf->last_op != 32) {
    {
#line 2562
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2562
    if (__cil_tmp7 < 0L) {
#line 2563
      return ((sf_count_t )0);
    }
  }
#line 2565
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2565
    if (psf->have_written == 0) {
      {
#line 2566
      psf->error = (*(psf->write_header))(psf, 0);
      }
#line 2566
      if (psf->error) {
#line 2567
        return ((sf_count_t )0);
      }
    }
  }
  {
#line 2569
  psf->have_written = 1;
#line 2571
  count___0 = (*(psf->write_double))(psf, ptr, frames * (long )psf->sf.channels);
#line 2573
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2575
  psf->last_op = 32;
  }
#line 2577
  if (psf->write_current > psf->sf.frames) {
#line 2578
    psf->sf.frames = psf->write_current;
#line 2579
    psf->dataend = (sf_count_t )0;
  }
#line 2582
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2582
    if (psf->auto_header) {
      {
#line 2583
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2585
  return (count___0 / (long )psf->sf.channels);
}
}
#line 2593 "/root/patchweave_new/23/src/sndfile.c"
static int try_resource_fork(SF_PRIVATE *psf ) 
{ 
  int old_error ;
  int __cil_tmp3 ;

  {
  {
#line 2594
  old_error = psf->error;
#line 2597
  psf->rsrc.mode = 16;
#line 2598
  __cil_tmp3 = psf_open_rsrc(psf);
  }
#line 2598
  if (__cil_tmp3 != 0) {
#line 2599
    psf->error = old_error;
#line 2600
    return (0);
  }
  {
#line 2604
  psf_log_printf(psf, "Resource fork : %s\nI\270U", psf->rsrc.path.c);
  }
#line 2606
  return (1441792);
}
}
#line 2610 "/root/patchweave_new/23/src/sndfile.c"
static int format_from_extension(SF_PRIVATE *psf ) 
{ 
  char *cptr ;
  char buffer[16] ;
  int format ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 2613
  format = 0;
#line 2615
  cptr = strrchr((char const   *)(psf->file.name.c), '.');
  }
#line 2615
  if ((unsigned long )cptr == (unsigned long )((void *)0)) {
#line 2616
    return (0);
  }
  {
#line 2618
  cptr ++;
#line 2619
  __cil_tmp7 = strlen((char const   *)cptr);
  }
#line 2619
  if (__cil_tmp7 > sizeof(buffer) - 1UL) {
#line 2620
    return (0);
  }
  {
#line 2622
  psf_strlcpy(buffer, sizeof(buffer), (char const   *)cptr);
#line 2623
  buffer[sizeof(buffer) - 1UL] = (char)0;
#line 2626
  cptr = buffer;
  }
  {
#line 2627
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2627
    if (! *cptr) {
#line 2627
      goto while_break;
    }
#line 2628
    *cptr = (char)0;
#line 2629
    cptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2632
  cptr = buffer;
#line 2634
  __cil_tmp9 = strcmp((char const   *)cptr, "au1I\270U");
  }
#line 2634
  if (__cil_tmp9 == 0) {
#line 2635
    psf->sf.channels = 1;
#line 2636
    psf->sf.samplerate = 8000;
#line 2637
    format = 262160;
  } else {
    {
#line 2639
    __cil_tmp10 = strcmp((char const   *)cptr, "sndI\270U");
    }
#line 2639
    if (__cil_tmp10 == 0) {
#line 2640
      psf->sf.channels = 1;
#line 2641
      psf->sf.samplerate = 8000;
#line 2642
      format = 262160;
    } else {
      {
#line 2645
      __cil_tmp12 = strcmp((char const   *)cptr, "vox8\270U");
#line 2645
      __cil_tmp11 = strcmp((char const   *)cptr, "voxI\270U");
      }
#line 2645
      if (__cil_tmp11 == 0) {
#line 2646
        psf->sf.channels = 1;
#line 2647
        psf->sf.samplerate = 8000;
#line 2648
        format = 262177;
      } else
#line 2645
      if (__cil_tmp12 == 0) {
#line 2646
        psf->sf.channels = 1;
#line 2647
        psf->sf.samplerate = 8000;
#line 2648
        format = 262177;
      } else {
        {
#line 2650
        __cil_tmp13 = strcmp((char const   *)cptr, "vox6\270U");
        }
#line 2650
        if (__cil_tmp13 == 0) {
#line 2651
          psf->sf.channels = 1;
#line 2652
          psf->sf.samplerate = 6000;
#line 2653
          format = 262177;
        } else {
          {
#line 2655
          __cil_tmp14 = strcmp((char const   *)cptr, "gsmI\270U");
          }
#line 2655
          if (__cil_tmp14 == 0) {
#line 2656
            psf->sf.channels = 1;
#line 2657
            psf->sf.samplerate = 8000;
#line 2658
            format = 262176;
          }
        }
      }
    }
  }
#line 2662
  if ((format & 268369920) == 262144) {
#line 2663
    psf->dataoffset = (sf_count_t )0;
  }
#line 2665
  return (format);
}
}
#line 2669 "/root/patchweave_new/23/src/sndfile.c"
static int guess_file_type(SF_PRIVATE *psf ) 
{ 
  uint32_t buffer[3] ;
  uint32_t format ;
  int __cil_tmp4 ;
  int32_t __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 2672
  __cil_tmp4 = psf_binheader_readf(psf, "b\3441I\270U", & buffer, (int )sizeof(buffer));
  }
#line 2672
  if (__cil_tmp4 != (int )sizeof(buffer)) {
#line 2673
    psf->error = 8;
#line 2674
    return (0);
  }
#line 2677
  if (buffer[0] == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
    _L: 
#line 2677
    if (buffer[2] == ((unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24))) {
#line 2679
      return (65536);
    }
  } else
#line 2677
  if (buffer[0] == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (88U << 24))) {
#line 2677
    goto _L;
  }
#line 2681
  if (buffer[0] == ((unsigned int )((70 | (79 << 8)) | (82 << 16)) | (77U << 24))) {
#line 2682
    if (buffer[2] == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
#line 2683
      return (131072);
    } else
#line 2682
    if (buffer[2] == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24))) {
#line 2683
      return (131072);
    }
#line 2684
    if (buffer[2] == ((unsigned int )((56 | (83 << 8)) | (86 << 16)) | (88U << 24))) {
#line 2685
      return (393216);
    } else
#line 2684
    if (buffer[2] == ((unsigned int )((49 | (54 << 8)) | (83 << 16)) | (86U << 24))) {
#line 2685
      return (393216);
    }
#line 2686
    return (0);
  }
#line 2689
  if (buffer[0] == ((unsigned int )((46 | (115 << 8)) | (110 << 16)) | (100U << 24))) {
#line 2690
    return (196608);
  } else
#line 2689
  if (buffer[0] == ((unsigned int )((100 | (110 << 8)) | (115 << 16)) | (46U << 24))) {
#line 2690
    return (196608);
  }
#line 2692
  if (buffer[0] == ((unsigned int )((102 | (97 << 8)) | (112 << 16)) | (32U << 24))) {
#line 2693
    return (327680);
  } else
#line 2692
  if (buffer[0] == ((unsigned int )((32 | (112 << 8)) | (97 << 16)) | (102U << 24))) {
#line 2693
    return (327680);
  }
#line 2695
  if (buffer[0] == ((unsigned int )((78 | (73 << 8)) | (83 << 16)) | (84U << 24))) {
#line 2696
    return (458752);
  }
#line 2698
  if (buffer[0] == ((unsigned int )((67 | (114 << 8)) | (101 << 16)) | (97U << 24))) {
#line 2698
    if (buffer[1] == ((unsigned int )((116 | (105 << 8)) | (118 << 16)) | (101U << 24))) {
#line 2699
      return (524288);
    }
  }
#line 2701
  if ((buffer[0] & ((unsigned int )((255 | (255 << 8)) | (248 << 16)) | (255U << 24))) == (unsigned int )(100 | (163 << 8))) {
#line 2703
    return (655360);
  } else
#line 2701
  if ((buffer[0] & ((unsigned int )((255 | (248 << 8)) | (255 << 16)) | (255U << 24))) == ((unsigned int )(163 << 16) | (100U << 24))) {
#line 2703
    return (655360);
  }
#line 2705
  if (buffer[0] == ((unsigned int )((114 | (105 << 8)) | (102 << 16)) | (102U << 24))) {
#line 2706
    return (720896);
  }
#line 2708
  if (buffer[0] == ((unsigned int )(3 << 16) | (232U << 24))) {
#line 2708
    if (buffer[1] == 1U << 24) {
#line 2708
      if (buffer[2] == 1U << 24) {
#line 2710
        return (786432);
      }
    }
  }
#line 2712
  if (buffer[0] == 0U) {
#line 2712
    if (buffer[1] == 1U) {
#line 2712
      if (buffer[2] == 1U) {
#line 2714
        return (786432);
      }
    }
  }
#line 2716
  if (buffer[0] == ((unsigned int )((77 | (65 << 8)) | (84 << 16)) | (76U << 24))) {
#line 2716
    if (buffer[1] == ((unsigned int )((65 | (66 << 8)) | (32 << 16)) | (53U << 24))) {
#line 2717
      return (851968);
    }
  }
#line 2719
  if (buffer[0] == ((unsigned int )((80 | (86 << 8)) | (70 << 16)) | (49U << 24))) {
#line 2720
    return (917504);
  }
#line 2722
  if (buffer[0] == ((unsigned int )((69 | (120 << 8)) | (116 << 16)) | (101U << 24))) {
#line 2722
    if (buffer[1] == ((unsigned int )((110 | (100 << 8)) | (101 << 16)) | (100U << 24))) {
#line 2722
      if (buffer[2] == ((unsigned int )((32 | (73 << 8)) | (110 << 16)) | (115U << 24))) {
#line 2724
        return (983040);
      }
    }
  }
#line 2726
  if (buffer[0] == ((unsigned int )((99 | (97 << 8)) | (102 << 16)) | (102U << 24))) {
#line 2726
    if (buffer[2] == ((unsigned int )((100 | (101 << 8)) | (115 << 16)) | (99U << 24))) {
#line 2727
      return (1572864);
    }
  }
#line 2729
  if (buffer[0] == ((unsigned int )((79 | (103 << 8)) | (103 << 16)) | (83U << 24))) {
#line 2730
    return (2097152);
  }
#line 2732
  if (buffer[0] == ((unsigned int )((65 | (76 << 8)) | (97 << 16)) | (119U << 24))) {
#line 2732
    if (buffer[1] == ((unsigned int )((83 | (111 << 8)) | (117 << 16)) | (110U << 24))) {
#line 2732
      if (buffer[2] == ((unsigned int )((100 | (70 << 8)) | (105 << 16)) | (108U << 24))) {
#line 2734
        return (1638400);
      }
    }
  }
#line 2736
  if (buffer[0] == ((unsigned int )((68 | (105 << 8)) | (97 << 16)) | (109U << 24))) {
#line 2736
    if (buffer[1] == ((unsigned int )((111 | (110 << 8)) | (100 << 16)) | (87U << 24))) {
#line 2736
      if (buffer[2] == ((unsigned int )((97 | (114 << 8)) | (101 << 16)) | (32U << 24))) {
#line 2738
        return (67371008);
      }
    }
  }
#line 2740
  if (buffer[0] == ((unsigned int )((76 | (77 << 8)) | (56 << 16)) | (57U << 24))) {
#line 2741
    return (67305472);
  } else
#line 2740
  if (buffer[0] == (unsigned int )(53 | (51 << 8))) {
#line 2741
    return (67305472);
  }
#line 2743
  if ((buffer[0] & ((unsigned int )((255 | (255 << 8)) | (128 << 16)) | (255U << 24))) == ((unsigned int )(240 | (126 << 8)) | (1U << 24))) {
#line 2744
    return (1114112);
  }
#line 2746
  if ((buffer[0] & (unsigned int )(255 | (255 << 8))) == (unsigned int )(1 | (4 << 8))) {
#line 2747
    return (2162688);
  }
#line 2749
  if (buffer[0] == ((unsigned int )((67 | (65 << 8)) | (84 << 16)) | (32U << 24))) {
#line 2749
    if (buffer[2] == ((unsigned int )((82 | (69 << 8)) | (88 << 16)) | (50U << 24))) {
#line 2750
      return (67960832);
    }
  }
#line 2752
  if (buffer[0] == ((unsigned int )((48 | (38 << 8)) | (178 << 16)) | (117U << 24))) {
#line 2752
    if (buffer[1] == ((unsigned int )((142 | (102 << 8)) | (207 << 16)) | (17U << 24))) {
#line 2753
      return (0);
    }
  }
  {
#line 2756
  __cil_tmp5 = ENDSWAP_32((int32_t )buffer[0]);
  }
#line 2756
  if (buffer[2] == (unsigned int )(2 << 8)) {
#line 2756
    if (2L * (int64_t )__cil_tmp5 + 12L == psf->filelength) {
#line 2757
      return (1048576);
    }
  }
#line 2759
  if (buffer[0] == ((unsigned int )((102 | (76 << 8)) | (97 << 16)) | (67U << 24))) {
#line 2760
    return (1507328);
  }
#line 2762
  if (buffer[0] == ((unsigned int )((50 | (66 << 8)) | (73 << 16)) | (84U << 24))) {
#line 2763
    return (1179648);
  }
#line 2765
  if (buffer[0] == ((unsigned int )((82 | (70 << 8)) | (54 << 16)) | (52U << 24))) {
#line 2765
    if (buffer[2] == ((unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24))) {
#line 2766
      return (2228224);
    }
  }
#line 2768
  if (buffer[0] == ((unsigned int )((73 | (68 << 8)) | (51 << 16)) | (3U << 24))) {
    {
#line 2769
    psf_log_printf(psf, "Found \'ID3\' marker.\n");
#line 2770
    __cil_tmp6 = id3_skip(psf);
    }
#line 2770
    if (__cil_tmp6) {
      {
#line 2771
      __cil_tmp7 = guess_file_type(psf);
      }
#line 2771
      return (__cil_tmp7);
    }
#line 2772
    return (0);
  }
#line 2776
  if (buffer[0] == ((unsigned int )((83 | (79 << 8)) | (85 << 16)) | (78U << 24))) {
#line 2776
    if (buffer[1] == ((unsigned int )((68 | (32 << 8)) | (83 << 16)) | (65U << 24))) {
#line 2777
      return (0);
    }
  }
#line 2780
  if (buffer[0] == ((unsigned int )((83 | (89 << 8)) | (56 << 16)) | (48U << 24))) {
#line 2781
    return (0);
  } else
#line 2780
  if (buffer[0] == ((unsigned int )((83 | (89 << 8)) | (56 << 16)) | (53U << 24))) {
#line 2781
    return (0);
  }
#line 2783
  if (buffer[0] == ((unsigned int )((97 | (106 << 8)) | (107 << 16)) | (103U << 24))) {
#line 2784
    return (0);
  }
  {
#line 2787
  __cil_tmp8 = try_resource_fork(psf);
#line 2787
  format = (uint32_t )__cil_tmp8;
  }
#line 2787
  if (psf->filelength > 0L) {
#line 2787
    if (format != 0U) {
#line 2788
      return ((int )format);
    }
  }
#line 2790
  return (0);
}
}
#line 2795 "/root/patchweave_new/23/src/sndfile.c"
static int validate_sfinfo(SF_INFO *sfinfo ) 
{ 


  {
#line 2796
  if (sfinfo->samplerate < 1) {
#line 2797
    return (0);
  }
#line 2798
  if (sfinfo->frames < 0L) {
#line 2799
    return (0);
  }
#line 2800
  if (sfinfo->channels < 1) {
#line 2801
    return (0);
  }
#line 2802
  if ((sfinfo->format & 268369920) == 0) {
#line 2803
    return (0);
  }
#line 2804
  if ((sfinfo->format & 65535) == 0) {
#line 2805
    return (0);
  }
#line 2806
  if (sfinfo->sections < 1) {
#line 2807
    return (0);
  }
#line 2808
  return (1);
}
}
#line 2812 "/root/patchweave_new/23/src/sndfile.c"
static int validate_psf(SF_PRIVATE *psf ) 
{ 


  {
#line 2814
  if (psf->datalength < 0L) {
    {
#line 2815
    psf_log_printf(psf, "Invalid SF_PRIVATE field : datalength == %D.\n", psf->datalength);
    }
#line 2816
    return (0);
  }
#line 2818
  if (psf->dataoffset < 0L) {
    {
#line 2819
    psf_log_printf(psf, "Invalid SF_PRIVATE field : dataoffset == %D.\n", psf->dataoffset);
    }
#line 2820
    return (0);
  }
#line 2822
  if (psf->blockwidth) {
#line 2822
    if (psf->blockwidth != psf->sf.channels * psf->bytewidth) {
      {
#line 2823
      psf_log_printf(psf, "Invalid SF_PRIVATE field : channels * bytewidth == %d.\n",
                     psf->sf.channels * psf->bytewidth);
      }
#line 2825
      return (0);
    }
  }
#line 2827
  return (1);
}
}
#line 2831 "/root/patchweave_new/23/src/sndfile.c"
static void save_header_info(SF_PRIVATE *psf ) 
{ 


  {
  {
#line 2832
  snprintf(sf_parselog, sizeof(sf_parselog), "%s", psf->parselog.buf);
  }
#line 2834
  return;
}
}
#line 2836 "/root/patchweave_new/23/src/sndfile.c"
static int copy_filename(SF_PRIVATE *psf , char const   *path ) 
{ 
  char const   *ccptr ;
  char *cptr ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 2840
  __cil_tmp6 = strlen(path);
#line 2840
  __cil_tmp5 = strlen(path);
  }
#line 2840
  if (__cil_tmp5 > 1UL) {
#line 2840
    if (__cil_tmp6 - 1UL >= sizeof(psf->file.path.c)) {
#line 2841
      psf->error = 173;
#line 2842
      return (psf->error);
    }
  }
  {
#line 2845
  snprintf(psf->file.path.c, sizeof(psf->file.path.c), "%s2I\270U", path);
#line 2846
  __cil_tmp8 = strrchr(path, '\\');
#line 2846
  ccptr = (char const   *)__cil_tmp8;
#line 2846
  __cil_tmp7 = strrchr(path, '/');
#line 2846
  ccptr = (char const   *)__cil_tmp7;
  }
#line 2846
  if (ccptr) {
#line 2847
    ccptr ++;
  } else
#line 2846
  if (ccptr) {
#line 2847
    ccptr ++;
  } else {
#line 2849
    ccptr = path;
  }
  {
#line 2851
  snprintf(psf->file.name.c, sizeof(psf->file.name.c), "%s3I\270U", ccptr);
#line 2854
  snprintf(psf->file.dir.c, sizeof(psf->file.dir.c), "%s", path);
#line 2855
  cptr = strrchr((char const   *)(psf->file.dir.c), '\\');
#line 2855
  cptr = strrchr((char const   *)(psf->file.dir.c), '/');
  }
#line 2855
  if (cptr) {
#line 2856
    *(cptr + 1) = (char)0;
  } else
#line 2855
  if (cptr) {
#line 2856
    *(cptr + 1) = (char)0;
  } else {
#line 2858
    psf->file.dir.c[0] = (char)0;
  }
#line 2860
  return (0);
}
}
#line 2867 "/root/patchweave_new/23/src/sndfile.c"
static int psf_close(SF_PRIVATE *psf ) 
{ 
  uint32_t k ;
  int error ;

  {
#line 2869
  error = 0;
#line 2871
  if (psf->codec_close) {
    {
#line 2872
    error = (*(psf->codec_close))(psf);
#line 2874
    psf->codec_close = (int (*)(struct sf_private_tag * ))((void *)0);
    }
  }
#line 2877
  if (psf->container_close) {
    {
#line 2878
    error = (*(psf->container_close))(psf);
    }
  }
  {
#line 2880
  error = psf_fclose(psf);
#line 2881
  psf_close_rsrc(psf);
#line 2884
  free((void *)psf->header.ptr);
#line 2885
  free(psf->container_data);
#line 2886
  free(psf->codec_data);
#line 2887
  free(psf->interleave);
#line 2888
  free(psf->dither);
#line 2889
  free((void *)psf->peak_info);
#line 2890
  free((void *)psf->broadcast_16k);
#line 2891
  free((void *)psf->loop_info);
#line 2892
  free((void *)psf->instrument);
#line 2893
  free((void *)psf->cues);
#line 2894
  free((void *)psf->channel_map);
#line 2895
  free((void *)psf->format_desc);
#line 2896
  free((void *)psf->strings.storage);
  }
#line 2898
  if (psf->wchunks.chunks) {
#line 2899
    k = (uint32_t )0;
    {
#line 2899
    while (1) {
      while_continue: /* CIL Label */ ;

#line 2899
      if (! (k < psf->wchunks.used)) {
#line 2899
        goto while_break;
      }
      {
#line 2900
      free((psf->wchunks.chunks + k)->data);
#line 2899
      k ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 2901
  free((void *)psf->rchunks.chunks);
#line 2902
  free((void *)psf->wchunks.chunks);
#line 2903
  free((void *)psf->iterator);
#line 2904
  free((void *)psf->cart_16k);
#line 2906
  memset((void *)psf, 0, sizeof(SF_PRIVATE ));
#line 2907
  free((void *)psf);
  }
#line 2909
  return (error);
}
}
#line 2913 "/root/patchweave_new/23/src/sndfile.c"
SNDFILE *psf_open_file(SF_PRIVATE *psf , SF_INFO *sfinfo ) 
{ 
  int error ;
  int format ;
  int __cil_tmp5 ;
  int32_t __cil_tmp6 ;
  int __cil_tmp10 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int tmp ;
  char const   *__cil_tmp44 ;

  {
#line 2916
  error = 0;
#line 2916
  sf_errno = error;
#line 2917
  sf_parselog[0] = (char)0;
#line 2919
  if (psf->error) {
#line 2920
    error = psf->error;
#line 2921
    goto error_exit;
  }
#line 2924
  if (psf->file.mode != 16) {
#line 2924
    if (psf->file.mode != 32) {
#line 2924
      if (psf->file.mode != 48) {
#line 2925
        error = 45;
#line 2926
        goto error_exit;
      }
    }
  }
#line 2929
  if ((unsigned long )sfinfo == (unsigned long )((void *)0)) {
#line 2930
    error = 11;
#line 2931
    goto error_exit;
  }
#line 2934
  if (psf->file.mode == 16) {
#line 2935
    if ((sfinfo->format & 268369920) == 262144) {
      {
#line 2936
      __cil_tmp5 = sf_format_check(sfinfo);
      }
#line 2936
      if (__cil_tmp5 == 0) {
#line 2937
        error = 97;
#line 2938
        goto error_exit;
      }
    } else {
      {
#line 2942
      memset((void *)sfinfo, 0, sizeof(SF_INFO ));
      }
    }
  }
  {
#line 2945
  memcpy((void *)(& psf->sf), (void const   *)sfinfo, sizeof(SF_INFO ));
#line 2947
  psf->Magick = 305447134;
#line 2948
  psf->norm_float = 1;
#line 2949
  psf->norm_double = 1;
#line 2950
  psf->dataoffset = (sf_count_t )-1;
#line 2951
  psf->datalength = (sf_count_t )-1;
#line 2952
  psf->read_current = (sf_count_t )-1;
#line 2953
  psf->write_current = (sf_count_t )-1;
#line 2954
  psf->auto_header = 0;
#line 2955
  psf->rwf_endian = 268435456;
#line 2956
  psf->seek = & psf_default_seek;
#line 2957
  psf->float_int_mult = 0;
#line 2958
  psf->float_max = (float )(- 1.);
#line 2961
  __cil_tmp6 = psf_rand_int32();
#line 2961
  psf->unique_id = (unsigned int )__cil_tmp6;
#line 2963
  psf->sf.sections = 1;
#line 2965
  psf->is_pipe = psf_is_pipe(psf);
  }
#line 2967
  if (psf->is_pipe) {
#line 2968
    psf->sf.seekable = 0;
#line 2969
    psf->filelength = (sf_count_t )-1LL;
  } else {
    {
#line 2972
    psf->sf.seekable = 1;
#line 2975
    psf->filelength = psf_get_filelen(psf);
    }
  }
#line 2978
  if (psf->fileoffset > 0L) {
#line 2980
    if (psf->file.mode == 16) {
#line 2980
      goto case_16;
    }
#line 2988
    if (psf->file.mode == 32) {
#line 2988
      goto case_32;
    }
#line 2994
    if (psf->file.mode == 48) {
#line 2994
      goto case_48;
    }
#line 2979
    goto switch_break;
    case_16: 
#line 2981
    if (psf->filelength < 44L) {
      {
#line 2982
      psf_log_printf(psf, "Short filelength: %D (fileoffset: %D)\n", psf->filelength,
                     psf->fileoffset);
#line 2983
      error = 26;
      }
#line 2984
      goto error_exit;
    }
#line 2986
    goto switch_break;
    case_32: 
    {
#line 2989
    psf->fileoffset = (sf_count_t )0;
#line 2990
    psf_fseek(psf, (sf_count_t )0, 2);
#line 2991
    psf->fileoffset = psf_ftell(psf);
    }
#line 2992
    goto switch_break;
    case_48: 
#line 2995
    error = 28;
#line 2996
    goto error_exit;
    switch_break: 
    {
#line 2999
    psf_log_printf(psf, "Embedded file offset : %D\n3I\270U", psf->fileoffset);
    }
  }
#line 3002
  if ((long long )psf->filelength == -1LL) {
    {
#line 3003
    psf_log_printf(psf, "Length : unknown\nT3I\270U");
    }
  } else {
    {
#line 3005
    psf_log_printf(psf, "Length : %D\n\270U", psf->filelength);
    }
  }
#line 3007
  if (psf->file.mode == 32) {
    _L: 
#line 3011
    if ((psf->sf.format & 268369920) == 0) {
#line 3012
      error = 5;
#line 3013
      goto error_exit;
    }
#line 3015
    if ((psf->sf.format & 65535) == 0) {
#line 3016
      error = 6;
#line 3017
      goto error_exit;
    }
    {
#line 3020
    __cil_tmp10 = sf_format_check(& psf->sf);
    }
#line 3020
    if (__cil_tmp10 == 0) {
#line 3021
      error = 1;
#line 3022
      goto error_exit;
    }
  } else
#line 3007
  if (psf->file.mode == 48) {
#line 3007
    if (psf->filelength == 0L) {
#line 3007
      goto _L;
    } else {
#line 3007
      goto _L___57;
    }
  } else
  _L___57: 
#line 3025
  if ((psf->sf.format & 268369920) != 262144) {
    {
#line 3027
    psf->sf.format = guess_file_type(psf);
    }
#line 3029
    if (psf->sf.format == 0) {
      {
#line 3030
      psf->sf.format = format_from_extension(psf);
      }
    }
  }
#line 3034
  psf->last_op = psf->file.mode;
#line 3042
  if ((psf->sf.format & 65535) == 80) {
#line 3042
    goto case_80;
  }
#line 3042
  if ((psf->sf.format & 65535) == 17) {
#line 3042
    goto case_80;
  }
#line 3042
  if ((psf->sf.format & 65535) == 16) {
#line 3042
    goto case_80;
  }
#line 3042
  if ((psf->sf.format & 65535) == 5) {
#line 3042
    goto case_80;
  }
#line 3042
  if ((psf->sf.format & 65535) == 1) {
#line 3042
    goto case_80;
  }
#line 3047
  if ((psf->sf.format & 65535) == 81) {
#line 3047
    goto case_81;
  }
#line 3047
  if ((psf->sf.format & 65535) == 2) {
#line 3047
    goto case_81;
  }
#line 3051
  if ((psf->sf.format & 65535) == 3) {
#line 3051
    goto case_3;
  }
#line 3056
  if ((psf->sf.format & 65535) == 6) {
#line 3056
    goto case_6;
  }
#line 3056
  if ((psf->sf.format & 65535) == 4) {
#line 3056
    goto case_6;
  }
#line 3060
  if ((psf->sf.format & 65535) == 7) {
#line 3060
    goto case_7;
  }
#line 3037
  goto switch_break___0;
  case_80: 
#line 3043
  psf->bytewidth = 1;
#line 3044
  goto switch_break___0;
  case_81: 
#line 3048
  psf->bytewidth = 2;
#line 3049
  goto switch_break___0;
  case_3: 
#line 3052
  psf->bytewidth = 3;
#line 3053
  goto switch_break___0;
  case_6: 
#line 3057
  psf->bytewidth = 4;
#line 3058
  goto switch_break___0;
  case_7: 
#line 3061
  psf->bytewidth = 8;
#line 3062
  goto switch_break___0;
  switch_break___0: ;
#line 3068
  if ((psf->sf.format & 268369920) == 1245184) {
#line 3068
    goto case_1245184;
  }
#line 3068
  if ((psf->sf.format & 268369920) == 65536) {
#line 3068
    goto case_1245184;
  }
#line 3072
  if ((psf->sf.format & 268369920) == 131072) {
#line 3072
    goto case_131072;
  }
#line 3076
  if ((psf->sf.format & 268369920) == 196608) {
#line 3076
    goto case_196608;
  }
#line 3080
  if ((psf->sf.format & 268369920) == 262144) {
#line 3080
    goto case_262144;
  }
#line 3084
  if ((psf->sf.format & 268369920) == 720896) {
#line 3084
    goto case_720896;
  }
#line 3088
  if ((psf->sf.format & 268369920) == 2228224) {
#line 3088
    goto case_2228224;
  }
#line 3093
  if ((psf->sf.format & 268369920) == 327680) {
#line 3093
    goto case_327680;
  }
#line 3097
  if ((psf->sf.format & 268369920) == 393216) {
#line 3097
    goto case_393216;
  }
#line 3101
  if ((psf->sf.format & 268369920) == 458752) {
#line 3101
    goto case_458752;
  }
#line 3105
  if ((psf->sf.format & 268369920) == 655360) {
#line 3105
    goto case_655360;
  }
#line 3109
  if ((psf->sf.format & 268369920) == 524288) {
#line 3109
    goto case_524288;
  }
#line 3113
  if ((psf->sf.format & 268369920) == 1114112) {
#line 3113
    goto case_1114112;
  }
#line 3117
  if ((psf->sf.format & 268369920) == 2097152) {
#line 3117
    goto case_2097152;
  }
#line 3121
  if ((psf->sf.format & 268369920) == 67305472) {
#line 3121
    goto case_67305472;
  }
#line 3125
  if ((psf->sf.format & 268369920) == 1638400) {
#line 3125
    goto case_1638400;
  }
#line 3129
  if ((psf->sf.format & 268369920) == 67371008) {
#line 3129
    goto case_67371008;
  }
#line 3133
  if ((psf->sf.format & 268369920) == 786432) {
#line 3133
    goto case_786432;
  }
#line 3137
  if ((psf->sf.format & 268369920) == 851968) {
#line 3137
    goto case_851968;
  }
#line 3141
  if ((psf->sf.format & 268369920) == 917504) {
#line 3141
    goto case_917504;
  }
#line 3145
  if ((psf->sf.format & 268369920) == 983040) {
#line 3145
    goto case_983040;
  }
#line 3149
  if ((psf->sf.format & 268369920) == 1048576) {
#line 3149
    goto case_1048576;
  }
#line 3153
  if ((psf->sf.format & 268369920) == 1441792) {
#line 3153
    goto case_1441792;
  }
#line 3157
  if ((psf->sf.format & 268369920) == 67960832) {
#line 3157
    goto case_67960832;
  }
#line 3161
  if ((psf->sf.format & 268369920) == 1179648) {
#line 3161
    goto case_1179648;
  }
#line 3165
  if ((psf->sf.format & 268369920) == 1507328) {
#line 3165
    goto case_1507328;
  }
#line 3169
  if ((psf->sf.format & 268369920) == 1572864) {
#line 3169
    goto case_1572864;
  }
#line 3173
  if ((psf->sf.format & 268369920) == 2162688) {
#line 3173
    goto case_2162688;
  }
#line 3179
  goto switch_default;
  case_1245184: 
  {
#line 3069
  error = wav_open(psf);
  }
#line 3070
  goto switch_break___1;
  case_131072: 
  {
#line 3073
  error = aiff_open(psf);
  }
#line 3074
  goto switch_break___1;
  case_196608: 
  {
#line 3077
  error = au_open(psf);
  }
#line 3078
  goto switch_break___1;
  case_262144: 
  {
#line 3081
  error = raw_open(psf);
  }
#line 3082
  goto switch_break___1;
  case_720896: 
  {
#line 3085
  error = w64_open(psf);
  }
#line 3086
  goto switch_break___1;
  case_2228224: 
  {
#line 3089
  error = rf64_open(psf);
  }
#line 3090
  goto switch_break___1;
  case_327680: 
  {
#line 3094
  error = paf_open(psf);
  }
#line 3095
  goto switch_break___1;
  case_393216: 
  {
#line 3098
  error = svx_open(psf);
  }
#line 3099
  goto switch_break___1;
  case_458752: 
  {
#line 3102
  error = nist_open(psf);
  }
#line 3103
  goto switch_break___1;
  case_655360: 
  {
#line 3106
  error = ircam_open(psf);
  }
#line 3107
  goto switch_break___1;
  case_524288: 
  {
#line 3110
  error = voc_open(psf);
  }
#line 3111
  goto switch_break___1;
  case_1114112: 
  {
#line 3114
  error = sds_open(psf);
  }
#line 3115
  goto switch_break___1;
  case_2097152: 
  {
#line 3118
  error = ogg_open(psf);
  }
#line 3119
  goto switch_break___1;
  case_67305472: 
  {
#line 3122
  error = txw_open(psf);
  }
#line 3123
  goto switch_break___1;
  case_1638400: 
  {
#line 3126
  error = wve_open(psf);
  }
#line 3127
  goto switch_break___1;
  case_67371008: 
  {
#line 3130
  error = dwd_open(psf);
  }
#line 3131
  goto switch_break___1;
  case_786432: 
  {
#line 3134
  error = mat4_open(psf);
  }
#line 3135
  goto switch_break___1;
  case_851968: 
  {
#line 3138
  error = mat5_open(psf);
  }
#line 3139
  goto switch_break___1;
  case_917504: 
  {
#line 3142
  error = pvf_open(psf);
  }
#line 3143
  goto switch_break___1;
  case_983040: 
  {
#line 3146
  error = xi_open(psf);
  }
#line 3147
  goto switch_break___1;
  case_1048576: 
  {
#line 3150
  error = htk_open(psf);
  }
#line 3151
  goto switch_break___1;
  case_1441792: 
  {
#line 3154
  error = sd2_open(psf);
  }
#line 3155
  goto switch_break___1;
  case_67960832: 
  {
#line 3158
  error = rx2_open(psf);
  }
#line 3159
  goto switch_break___1;
  case_1179648: 
  {
#line 3162
  error = avr_open(psf);
  }
#line 3163
  goto switch_break___1;
  case_1507328: 
  {
#line 3166
  error = flac_open(psf);
  }
#line 3167
  goto switch_break___1;
  case_1572864: 
  {
#line 3170
  error = caf_open(psf);
  }
#line 3171
  goto switch_break___1;
  case_2162688: 
  {
#line 3174
  error = mpc2k_open(psf);
  }
#line 3175
  goto switch_break___1;
  switch_default: 
#line 3180
  error = 21;
  switch_break___1: ;
#line 3183
  if (error) {
#line 3184
    goto error_exit;
  }
#line 3187
  format = psf->sf.format & 268369920;
#line 3188
  if (psf->fileoffset > 0L) {
#line 3193
    if (format == 196608) {
#line 3193
      goto case_196608___0;
    }
#line 3193
    if (format == 131072) {
#line 3193
      goto case_196608___0;
    }
#line 3193
    if (format == 1245184) {
#line 3193
      goto case_196608___0;
    }
#line 3193
    if (format == 65536) {
#line 3193
      goto case_196608___0;
    }
#line 3197
    if (format == 1507328) {
#line 3197
      goto case_1507328___0;
    }
#line 3201
    goto switch_default___0;
    case_196608___0: 
#line 3195
    goto switch_break___2;
    case_1507328___0: 
#line 3199
    goto switch_break___2;
    switch_default___0: 
#line 3202
    error = 27;
#line 3203
    goto error_exit;
    switch_break___2: ;
  }
#line 3207
  if (psf->fileoffset > 0L) {
    {
#line 3208
    psf_log_printf(psf, "Embedded file length : %D\n3I\270U", psf->filelength);
    }
  }
  {
#line 3210
  __cil_tmp40 = sf_format_check(& psf->sf);
  }
#line 3210
  if (psf->file.mode == 48) {
#line 3210
    if (__cil_tmp40 == 0) {
#line 3211
      error = 24;
#line 3212
      goto error_exit;
    }
  }
  {
#line 3215
  __cil_tmp41 = validate_sfinfo(& psf->sf);
  }
#line 3215
  if (__cil_tmp41 == 0) {
    {
#line 3216
    psf_log_SF_INFO(psf);
#line 3217
    save_header_info(psf);
#line 3218
    error = 25;
    }
#line 3219
    goto error_exit;
  }
  {
#line 3222
  __cil_tmp42 = validate_psf(psf);
  }
#line 3222
  if (__cil_tmp42 == 0) {
    {
#line 3223
    save_header_info(psf);
#line 3224
    error = 30;
    }
#line 3225
    goto error_exit;
  }
#line 3228
  psf->read_current = (sf_count_t )0;
#line 3229
  psf->write_current = (sf_count_t )0;
#line 3230
  if (psf->file.mode == 48) {
#line 3231
    psf->write_current = psf->sf.frames;
#line 3232
    if (psf->sf.frames > 0L) {
#line 3232
      tmp = 1;
    } else {
#line 3232
      tmp = 0;
    }
#line 3232
    psf->have_written = tmp;
  }
  {
#line 3235
  memcpy((void *)sfinfo, (void const   *)(& psf->sf), sizeof(SF_INFO ));
  }
#line 3237
  if (psf->file.mode == 32) {
#line 3239
    sfinfo->frames = (sf_count_t )0;
#line 3240
    sfinfo->sections = 0;
#line 3241
    sfinfo->seekable = 0;
  }
#line 3244
  return ((SNDFILE *)psf);
  error_exit: 
#line 3247
  sf_errno = error;
#line 3249
  if (error == 2) {
    {
#line 3250
    snprintf(sf_syserr, sizeof(sf_syserr), "%s", psf->syserr);
    }
  }
  {
#line 3251
  snprintf(sf_parselog, sizeof(sf_parselog), "%s", psf->parselog.buf);
  }
#line 3256
  if (error == 18) {
#line 3256
    goto case_18;
  }
#line 3256
  if (error == 4) {
#line 3256
    goto case_18;
  }
#line 3256
  if (error == 2) {
#line 3256
    goto case_18;
  }
#line 3259
  if (error == 97) {
#line 3259
    goto case_97;
  }
#line 3262
  goto switch_default___1;
  case_18: 
#line 3257
  goto switch_break___3;
  case_97: 
#line 3260
  goto switch_break___3;
  switch_default___1: 
#line 3263
  if (psf->file.mode == 16) {
    {
#line 3264
    __cil_tmp44 = sf_error_number(error);
#line 3264
    psf_log_printf(psf, "Parse error : %s\n", __cil_tmp44);
#line 3265
    error = 3;
    }
  }
  switch_break___3: 
  {
#line 3269
  psf_close(psf);
  }
#line 3270
  return ((SNDFILE *)((void *)0));
}
}
#line 3281 "/root/patchweave_new/23/src/sndfile.c"
int sf_set_chunk(SNDFILE *sndfile , SF_CHUNK_INFO *chunk_info ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 3284
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 3284
    sf_errno = 10;
#line 3284
    return (0);
  }
  {
#line 3284
  psf = (SF_PRIVATE *)sndfile;
#line 3284
  __cil_tmp4 = psf_file_valid(psf);
  }
#line 3284
  if (psf->virtual_io == 0) {
#line 3284
    if (__cil_tmp4 == 0) {
#line 3284
      psf->error = 13;
#line 3284
      return (0);
    }
  }
#line 3284
  if (psf->Magick != 305447134) {
#line 3284
    psf->error = 10;
#line 3284
    return (0);
  }
#line 3284
  psf->error = 0;
#line 3286
  if ((unsigned long )chunk_info == (unsigned long )((void *)0)) {
#line 3287
    return (167);
  } else
#line 3286
  if ((unsigned long )chunk_info->data == (unsigned long )((void *)0)) {
#line 3287
    return (167);
  }
#line 3289
  if (psf->set_chunk) {
    {
#line 3290
    __cil_tmp5 = (*(psf->set_chunk))(psf, chunk_info);
    }
#line 3290
    return (__cil_tmp5);
  }
#line 3292
  return (169);
}
}
#line 3297 "/root/patchweave_new/23/src/sndfile.c"
SF_CHUNK_ITERATOR *sf_get_chunk_iterator(SNDFILE *sndfile , SF_CHUNK_INFO *chunk_info ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp4 ;
  SF_CHUNK_ITERATOR *__cil_tmp5 ;
  SF_CHUNK_ITERATOR *__cil_tmp6 ;

  {
#line 3300
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 3300
    sf_errno = 10;
#line 3300
    return ((SF_CHUNK_ITERATOR *)0);
  }
  {
#line 3300
  psf = (SF_PRIVATE *)sndfile;
#line 3300
  __cil_tmp4 = psf_file_valid(psf);
  }
#line 3300
  if (psf->virtual_io == 0) {
#line 3300
    if (__cil_tmp4 == 0) {
#line 3300
      psf->error = 13;
#line 3300
      return ((SF_CHUNK_ITERATOR *)0);
    }
  }
#line 3300
  if (psf->Magick != 305447134) {
#line 3300
    psf->error = 10;
#line 3300
    return ((SF_CHUNK_ITERATOR *)0);
  }
#line 3300
  psf->error = 0;
#line 3302
  if (chunk_info) {
    {
#line 3303
    __cil_tmp5 = psf_get_chunk_iterator(psf, (char const   *)(chunk_info->id));
    }
#line 3303
    return (__cil_tmp5);
  }
  {
#line 3305
  __cil_tmp6 = psf_get_chunk_iterator(psf, (char const   *)((void *)0));
  }
#line 3305
  return (__cil_tmp6);
}
}
#line 3310 "/root/patchweave_new/23/src/sndfile.c"
SF_CHUNK_ITERATOR *sf_next_chunk_iterator(SF_CHUNK_ITERATOR *iterator ) 
{ 
  SF_PRIVATE *psf ;
  SNDFILE *sndfile ;
  SNDFILE *tmp ;
  int __cil_tmp5 ;
  SF_CHUNK_ITERATOR *__cil_tmp6 ;

  {
#line 3312
  if (iterator) {
#line 3312
    tmp = iterator->sndfile;
  } else {
#line 3312
    tmp = (SNDFILE *)((void *)0);
  }
#line 3312
  sndfile = tmp;
#line 3314
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 3314
    sf_errno = 10;
#line 3314
    return ((SF_CHUNK_ITERATOR *)0);
  }
  {
#line 3314
  psf = (SF_PRIVATE *)sndfile;
#line 3314
  __cil_tmp5 = psf_file_valid(psf);
  }
#line 3314
  if (psf->virtual_io == 0) {
#line 3314
    if (__cil_tmp5 == 0) {
#line 3314
      psf->error = 13;
#line 3314
      return ((SF_CHUNK_ITERATOR *)0);
    }
  }
#line 3314
  if (psf->Magick != 305447134) {
#line 3314
    psf->error = 10;
#line 3314
    return ((SF_CHUNK_ITERATOR *)0);
  }
#line 3314
  psf->error = 0;
#line 3316
  if (psf->next_chunk_iterator) {
    {
#line 3317
    __cil_tmp6 = (*(psf->next_chunk_iterator))(psf, iterator);
    }
#line 3317
    return (__cil_tmp6);
  }
#line 3319
  return ((SF_CHUNK_ITERATOR *)((void *)0));
}
}
#line 3324 "/root/patchweave_new/23/src/sndfile.c"
int sf_get_chunk_size(SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  SF_PRIVATE *psf ;
  SNDFILE *sndfile ;
  SNDFILE *tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 3326
  if (iterator) {
#line 3326
    tmp = iterator->sndfile;
  } else {
#line 3326
    tmp = (SNDFILE *)((void *)0);
  }
#line 3326
  sndfile = tmp;
#line 3328
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 3328
    sf_errno = 10;
#line 3328
    return (0);
  }
  {
#line 3328
  psf = (SF_PRIVATE *)sndfile;
#line 3328
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 3328
  if (psf->virtual_io == 0) {
#line 3328
    if (__cil_tmp6 == 0) {
#line 3328
      psf->error = 13;
#line 3328
      return (0);
    }
  }
#line 3328
  if (psf->Magick != 305447134) {
#line 3328
    psf->error = 10;
#line 3328
    return (0);
  }
#line 3328
  psf->error = 0;
#line 3330
  if ((unsigned long )chunk_info == (unsigned long )((void *)0)) {
#line 3331
    return (167);
  }
#line 3333
  if (psf->get_chunk_size) {
    {
#line 3334
    __cil_tmp7 = (*(psf->get_chunk_size))(psf, iterator, chunk_info);
    }
#line 3334
    return (__cil_tmp7);
  }
#line 3336
  return (169);
#line 3337
  return (0);
}
}
#line 3342 "/root/patchweave_new/23/src/sndfile.c"
int sf_get_chunk_data(SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  SF_PRIVATE *psf ;
  SNDFILE *sndfile ;
  SNDFILE *tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 3344
  if (iterator) {
#line 3344
    tmp = iterator->sndfile;
  } else {
#line 3344
    tmp = (SNDFILE *)((void *)0);
  }
#line 3344
  sndfile = tmp;
#line 3346
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 3346
    sf_errno = 10;
#line 3346
    return (0);
  }
  {
#line 3346
  psf = (SF_PRIVATE *)sndfile;
#line 3346
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 3346
  if (psf->virtual_io == 0) {
#line 3346
    if (__cil_tmp6 == 0) {
#line 3346
      psf->error = 13;
#line 3346
      return (0);
    }
  }
#line 3346
  if (psf->Magick != 305447134) {
#line 3346
    psf->error = 10;
#line 3346
    return (0);
  }
#line 3346
  psf->error = 0;
#line 3348
  if ((unsigned long )chunk_info == (unsigned long )((void *)0)) {
#line 3349
    return (167);
  } else
#line 3348
  if ((unsigned long )chunk_info->data == (unsigned long )((void *)0)) {
#line 3349
    return (167);
  }
#line 3351
  if (psf->get_chunk_data) {
    {
#line 3352
    __cil_tmp7 = (*(psf->get_chunk_data))(psf, iterator, chunk_info);
    }
#line 3352
    return (__cil_tmp7);
  }
#line 3354
  return (169);
}
}
#line 63 "/root/patchweave_new/23/programs/common.h"
void sfe_apply_metadata_changes(char const   **filenames , METADATA_INFO *info ) ;
#line 65
void sfe_copy_data_fp(SNDFILE *outfile , SNDFILE *infile , int channels , int normalize ) ;
#line 67
void sfe_copy_data_int(SNDFILE *outfile , SNDFILE *infile , int channels ) ;
#line 69
int sfe_file_type_of_ext(char const   *str___0 , int format ) ;
#line 71
void sfe_dump_format_map(void) ;
#line 73
char const   *program_name(char const   *argv0 ) ;
#line 75
char const   *sfe_endian_name(int format ) ;
#line 76
char const   *sfe_container_name(int format ) ;
#line 77
char const   *sfe_codec_name(int format ) ;
#line 51 "/root/patchweave_new/23/programs/common.c"
static double data[4096]  ;
#line 52 "/root/patchweave_new/23/programs/common.c"
static double max  ;
#line 49 "/root/patchweave_new/23/programs/common.c"
void sfe_copy_data_fp(SNDFILE *outfile , SNDFILE *infile , int channels , int normalize ) 
{ 
  int frames ;
  int readcount ;
  int k ;
  sf_count_t __cil_tmp10 ;
  sf_count_t __cil_tmp11 ;

  {
  {
#line 53
  frames = 4096 / channels;
#line 54
  readcount = frames;
#line 56
  sf_command(infile, 4160, (void *)(& max), (int )sizeof(max));
  }
#line 58
  if (! normalize) {
#line 58
    if (max < 1.) {
      {
#line 59
      while (1) {
        while_continue: /* CIL Label */ ;

#line 59
        if (! (readcount > 0)) {
#line 59
          goto while_break;
        }
        {
#line 60
        __cil_tmp10 = sf_readf_double(infile, data, (sf_count_t )frames);
#line 60
        readcount = (int )__cil_tmp10;
#line 61
        sf_writef_double(outfile, (double const   *)(data), (sf_count_t )readcount);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: ;
    } else {
#line 58
      goto _L;
    }
  } else {
    _L: 
    {
#line 65
    sf_command(infile, 4114, (void *)0, 0);
    }
    {
#line 67
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 67
      if (! (readcount > 0)) {
#line 67
        goto while_break___0;
      }
      {
#line 68
      __cil_tmp11 = sf_readf_double(infile, data, (sf_count_t )frames);
#line 68
      readcount = (int )__cil_tmp11;
#line 69
      k = 0;
      }
      {
#line 69
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 69
        if (! (k < readcount * channels)) {
#line 69
          goto while_break___1;
        }
#line 70
        data[k] /= max;
#line 69
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 71
      sf_writef_double(outfile, (double const   *)(data), (sf_count_t )readcount);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 75
  return;
}
}
#line 81 "/root/patchweave_new/23/programs/common.c"
static int data___0[4096]  ;
#line 79 "/root/patchweave_new/23/programs/common.c"
void sfe_copy_data_int(SNDFILE *outfile , SNDFILE *infile , int channels ) 
{ 
  int frames ;
  int readcount ;
  sf_count_t __cil_tmp7 ;

  {
#line 83
  frames = 4096 / channels;
#line 84
  readcount = frames;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;

#line 86
    if (! (readcount > 0)) {
#line 86
      goto while_break;
    }
    {
#line 87
    __cil_tmp7 = sf_readf_int(infile, data___0, (sf_count_t )frames);
#line 87
    readcount = (int )__cil_tmp7;
#line 88
    sf_writef_int(outfile, (int const   *)(data___0), (sf_count_t )readcount);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 91
  return;
}
}
#line 98 "/root/patchweave_new/23/programs/common.c"
static int merge_broadcast_info(SNDFILE *infile , SNDFILE *outfile , int format ,
                                METADATA_INFO *info ) 
{ 
  SF_BROADCAST_INFO_2K binfo ;
  int infileminor ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long tmp ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long tmp___0 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long tmp___1 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long tmp___2 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long tmp___3 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long tmp___4 ;
  uint64_t ts ;
  long long __cil_tmp27 ;
  int slen ;
  unsigned long __cil_tmp29 ;
  unsigned short const   **__cil_tmp30 ;
  int __cil_tmp31 ;
  size_t slen___0 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long tmp___5 ;
  int __cil_tmp36 ;

  {
  {
#line 102
  memset((void *)(& binfo), 0, sizeof(binfo));
  }
#line 104
  if ((268369920 & format) != 65536) {
    {
#line 105
    printf("Error : This is not a WAV file and hence broadcast info cannot be added to it.\n\n\220");
    }
#line 106
    return (1);
  }
#line 109
  infileminor = 65535 & format;
#line 114
  if (infileminor == 4) {
#line 114
    goto case_4;
  }
#line 114
  if (infileminor == 3) {
#line 114
    goto case_4;
  }
#line 114
  if (infileminor == 2) {
#line 114
    goto case_4;
  }
#line 117
  goto switch_default;
  case_4: 
#line 115
  goto switch_break;
  switch_default: 
  {
#line 118
  printf("Warning : The EBU Technical Recommendation R68-2000 states that the only\n          allowed encodings are Linear PCM and MPEG3. This file is not in\n          the right format.\n\n\220");
  }
#line 123
  goto switch_break;
  switch_break: 
  {
#line 126
  __cil_tmp7 = sf_command(infile, 4336, (void *)(& binfo), (int )sizeof(binfo));
  }
#line 126
  if (__cil_tmp7 == 0) {
#line 127
    if ((unsigned long )infile == (unsigned long )outfile) {
      {
#line 128
      printf("Error : Attempting in-place broadcast info update, but file does not\n        have a \'bext\' chunk to modify. The solution is to specify both\n        input and output files on the command line.\n\n");
      }
#line 133
      return (1);
    }
  }
#line 143
  if ((unsigned long )info->description != (unsigned long )((void *)0)) {
    {
#line 143
    memset((void *)(binfo.description), 0, sizeof(binfo.description));
#line 143
    __cil_tmp8 = strlen(info->description);
    }
#line 143
    if (__cil_tmp8 < sizeof(binfo.description)) {
      {
#line 143
      __cil_tmp9 = strlen(info->description);
#line 143
      tmp = __cil_tmp9;
      }
    } else {
#line 143
      tmp = sizeof(binfo.description);
    }
    {
#line 143
    memcpy((void *)(binfo.description), (void const   *)info->description, tmp);
    }
  }
#line 144
  if ((unsigned long )info->originator != (unsigned long )((void *)0)) {
    {
#line 144
    memset((void *)(binfo.originator), 0, sizeof(binfo.originator));
#line 144
    __cil_tmp11 = strlen(info->originator);
    }
#line 144
    if (__cil_tmp11 < sizeof(binfo.originator)) {
      {
#line 144
      __cil_tmp12 = strlen(info->originator);
#line 144
      tmp___0 = __cil_tmp12;
      }
    } else {
#line 144
      tmp___0 = sizeof(binfo.originator);
    }
    {
#line 144
    memcpy((void *)(binfo.originator), (void const   *)info->originator, tmp___0);
    }
  }
#line 145
  if ((unsigned long )info->originator_reference != (unsigned long )((void *)0)) {
    {
#line 145
    memset((void *)(binfo.originator_reference), 0, sizeof(binfo.originator_reference));
#line 145
    __cil_tmp14 = strlen(info->originator_reference);
    }
#line 145
    if (__cil_tmp14 < sizeof(binfo.originator_reference)) {
      {
#line 145
      __cil_tmp15 = strlen(info->originator_reference);
#line 145
      tmp___1 = __cil_tmp15;
      }
    } else {
#line 145
      tmp___1 = sizeof(binfo.originator_reference);
    }
    {
#line 145
    memcpy((void *)(binfo.originator_reference), (void const   *)info->originator_reference,
           tmp___1);
    }
  }
#line 146
  if ((unsigned long )info->origination_date != (unsigned long )((void *)0)) {
    {
#line 146
    memset((void *)(binfo.origination_date), 0, sizeof(binfo.origination_date));
#line 146
    __cil_tmp17 = strlen(info->origination_date);
    }
#line 146
    if (__cil_tmp17 < sizeof(binfo.origination_date)) {
      {
#line 146
      __cil_tmp18 = strlen(info->origination_date);
#line 146
      tmp___2 = __cil_tmp18;
      }
    } else {
#line 146
      tmp___2 = sizeof(binfo.origination_date);
    }
    {
#line 146
    memcpy((void *)(binfo.origination_date), (void const   *)info->origination_date,
           tmp___2);
    }
  }
#line 147
  if ((unsigned long )info->origination_time != (unsigned long )((void *)0)) {
    {
#line 147
    memset((void *)(binfo.origination_time), 0, sizeof(binfo.origination_time));
#line 147
    __cil_tmp20 = strlen(info->origination_time);
    }
#line 147
    if (__cil_tmp20 < sizeof(binfo.origination_time)) {
      {
#line 147
      __cil_tmp21 = strlen(info->origination_time);
#line 147
      tmp___3 = __cil_tmp21;
      }
    } else {
#line 147
      tmp___3 = sizeof(binfo.origination_time);
    }
    {
#line 147
    memcpy((void *)(binfo.origination_time), (void const   *)info->origination_time,
           tmp___3);
    }
  }
#line 148
  if ((unsigned long )info->umid != (unsigned long )((void *)0)) {
    {
#line 148
    memset((void *)(binfo.umid), 0, sizeof(binfo.umid));
#line 148
    __cil_tmp23 = strlen(info->umid);
    }
#line 148
    if (__cil_tmp23 < sizeof(binfo.umid)) {
      {
#line 148
      __cil_tmp24 = strlen(info->umid);
#line 148
      tmp___4 = __cil_tmp24;
      }
    } else {
#line 148
      tmp___4 = sizeof(binfo.umid);
    }
    {
#line 148
    memcpy((void *)(binfo.umid), (void const   *)info->umid, tmp___4);
    }
  }
#line 151
  if ((unsigned long )info->time_ref != (unsigned long )((void *)0)) {
    {
#line 152
    __cil_tmp27 = atoll(info->time_ref);
#line 152
    ts = (uint64_t )__cil_tmp27;
#line 154
    binfo.time_reference_high = (uint32_t )(ts >> 32);
#line 155
    binfo.time_reference_low = (uint32_t )(ts & 4294967295UL);
    }
  }
#line 159
  if ((unsigned long )info->coding_history != (unsigned long )((void *)0)) {
#line 160
    if (info->coding_hist_append) {
      {
#line 161
      __cil_tmp29 = strlen((char const   *)(binfo.coding_history));
#line 161
      slen = (int )__cil_tmp29;
      }
      {
#line 163
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 163
        __cil_tmp30 = __ctype_b_loc();
        }
#line 163
        if (slen > 1) {
#line 163
          if (! ((int )*(*__cil_tmp30 + (int )binfo.coding_history[slen - 1]) & 8192)) {
#line 163
            goto while_break;
          }
        } else {
#line 163
          goto while_break;
        }
#line 164
        __cil_tmp31 = slen;
#line 164
        slen --;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 166
      memcpy((void *)(binfo.coding_history + slen), (void const   *)info->coding_history,
             sizeof(binfo.coding_history) - (unsigned long )slen);
      }
    } else {
      {
#line 169
      __cil_tmp33 = strlen(info->coding_history);
      }
#line 169
      if (__cil_tmp33 < sizeof(binfo.coding_history)) {
        {
#line 169
        __cil_tmp34 = strlen(info->coding_history);
#line 169
        tmp___5 = __cil_tmp34;
        }
      } else {
#line 169
        tmp___5 = sizeof(binfo.coding_history);
      }
      {
#line 169
      slen___0 = tmp___5;
#line 171
      memset((void *)(binfo.coding_history), 0, sizeof(binfo.coding_history));
#line 172
      memcpy((void *)(binfo.coding_history), (void const   *)info->coding_history,
             slen___0);
#line 173
      binfo.coding_history_size = (uint32_t )slen___0;
      }
    }
  }
  {
#line 177
  __cil_tmp36 = sf_command(outfile, 4337, (void *)(& binfo), (int )sizeof(binfo));
  }
#line 177
  if (__cil_tmp36 == 0) {
    {
#line 178
    printf("Error : Setting of broadcast info chunks failed.\n\n");
    }
#line 179
    return (1);
  }
#line 182
  return (0);
}
}
#line 186 "/root/patchweave_new/23/programs/common.c"
static void update_strings(SNDFILE *outfile , METADATA_INFO *info ) 
{ 


  {
#line 188
  if ((unsigned long )info->title != (unsigned long )((void *)0)) {
    {
#line 189
    sf_set_string(outfile, 1, info->title);
    }
  }
#line 191
  if ((unsigned long )info->copyright != (unsigned long )((void *)0)) {
    {
#line 192
    sf_set_string(outfile, 2, info->copyright);
    }
  }
#line 194
  if ((unsigned long )info->artist != (unsigned long )((void *)0)) {
    {
#line 195
    sf_set_string(outfile, 4, info->artist);
    }
  }
#line 197
  if ((unsigned long )info->comment != (unsigned long )((void *)0)) {
    {
#line 198
    sf_set_string(outfile, 5, info->comment);
    }
  }
#line 200
  if ((unsigned long )info->date != (unsigned long )((void *)0)) {
    {
#line 201
    sf_set_string(outfile, 6, info->date);
    }
  }
#line 203
  if ((unsigned long )info->album != (unsigned long )((void *)0)) {
    {
#line 204
    sf_set_string(outfile, 7, info->album);
    }
  }
#line 206
  if ((unsigned long )info->license != (unsigned long )((void *)0)) {
    {
#line 207
    sf_set_string(outfile, 8, info->license);
    }
  }
#line 210
  return;
}
}
#line 214 "/root/patchweave_new/23/programs/common.c"
void sfe_apply_metadata_changes(char const   **filenames , METADATA_INFO *info ) 
{ 
  SNDFILE *infile ;
  SNDFILE *outfile ;
  SF_INFO sfinfo ;
  METADATA_INFO tmpinfo ;
  int error_code ;
  char const   *__cil_tmp11 ;
  char const   *__cil_tmp12 ;
  int __cil_tmp13 ;
  int infileminor ;

  {
  {
#line 215
  infile = (SNDFILE *)((void *)0);
#line 215
  outfile = (SNDFILE *)((void *)0);
#line 218
  error_code = 0;
#line 220
  memset((void *)(& sfinfo), 0, sizeof(sfinfo));
#line 221
  memset((void *)(& tmpinfo), 0, sizeof(tmpinfo));
  }
#line 223
  if ((unsigned long )*(filenames + 1) == (unsigned long )((void *)0)) {
    {
#line 224
    infile = sf_open(*(filenames + 0), 48, & sfinfo);
    }
  } else {
    {
#line 226
    infile = sf_open(*(filenames + 0), 16, & sfinfo);
#line 229
    sfinfo.format = 65536 | (65535 & sfinfo.format);
#line 230
    outfile = sf_open(*(filenames + 1), 32, & sfinfo);
    }
  }
#line 233
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 234
    __cil_tmp11 = sf_strerror(infile);
#line 234
    printf("Error : Not able to open input file \'%s\' : %s\n", *(filenames + 0),
           __cil_tmp11);
#line 235
    error_code = 1;
    }
#line 236
    goto cleanup_exit;
  }
#line 239
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
    {
#line 240
    __cil_tmp12 = sf_strerror(outfile);
#line 240
    printf("Error : Not able to open output file \'%s\' : %s\n", *(filenames + 1),
           __cil_tmp12);
#line 241
    error_code = 1;
    }
#line 242
    goto cleanup_exit;
  }
  {
#line 245
  __cil_tmp13 = merge_broadcast_info(infile, outfile, sfinfo.format, info);
  }
#line 245
  if (info->has_bext_fields) {
#line 245
    if (__cil_tmp13) {
#line 246
      error_code = 1;
#line 247
      goto cleanup_exit;
    }
  }
#line 250
  if ((unsigned long )infile != (unsigned long )outfile) {
#line 251
    infileminor = 65535 & sfinfo.format;
#line 254
    if (infileminor == 7) {
      {
#line 255
      sfe_copy_data_fp(outfile, infile, sfinfo.channels, 0);
      }
    } else
#line 254
    if (infileminor == 6) {
      {
#line 255
      sfe_copy_data_fp(outfile, infile, sfinfo.channels, 0);
      }
    } else {
      {
#line 257
      sfe_copy_data_int(outfile, infile, sfinfo.channels);
      }
    }
  }
  {
#line 260
  update_strings(outfile, info);
  }
  cleanup_exit: 
#line 264
  if ((unsigned long )outfile != (unsigned long )((void *)0)) {
#line 264
    if ((unsigned long )outfile != (unsigned long )infile) {
      {
#line 265
      sf_close(outfile);
      }
    }
  }
#line 267
  if ((unsigned long )infile != (unsigned long )((void *)0)) {
    {
#line 268
    sf_close(infile);
    }
  }
#line 270
  if (error_code) {
    {
#line 271
    exit(error_code);
    }
  }
#line 273
  return;
}
}
#line 285 "/root/patchweave_new/23/programs/common.c"
static OUTPUT_FORMAT_MAP format_map[34]  = 
#line 285
  {      {"wav", 0, 65536}, 
        {"aif", 3, 131072}, 
        {"auLI\270U", 0, 196608}, 
        {"snd", 0, 196608}, 
        {"raw", 0, 262144}, 
        {"gsm", 0, 262144}, 
        {"voxI\270U", 0, 262144}, 
        {"paf", 0, 537198592}, 
        {"fapI\270U", 0, 268763136}, 
        {"svx", 0, 393216}, 
        {"nist", 0, 458752}, 
        {"sphI\270U", 0, 458752}, 
        {"vocI\270U", 0, 524288}, 
        {"ircam", 0, 655360}, 
        {"sf", 0, 655360}, 
        {"w64I\270U", 0, 720896}, 
        {"matI\270U", 0, 786432}, 
        {"mat4\270U", 0, 786432}, 
        {"mat5", 0, 851968}, 
        {"pvfI\270U", 0, 917504}, 
        {"xi", 0, 983040}, 
        {"htk", 0, 1048576}, 
        {"sdsI\270U", 0, 1114112}, 
        {"avr", 0, 1179648}, 
        {"wavex", 0, 1245184}, 
        {"sd2I\270U", 0, 1441792}, 
        {"flac", 0, 1507328}, 
        {"cafI\270U", 0, 1572864}, 
        {"wveI\270U", 0, 1638400}, 
        {"prcI\270U", 0, 1638400}, 
        {"ogg", 0, 2097152}, 
        {"oga", 0, 2097152}, 
        {"mpc", 0, 2162688}, 
        {"rf64\270U", 0, 2228224}};
#line 324 "/root/patchweave_new/23/programs/common.c"
int sfe_file_type_of_ext(char const   *str___0 , int format ) 
{ 
  char buffer[16] ;
  char *cptr ;
  int k ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 328
  format &= 65535;
#line 330
  cptr = strrchr(str___0, '.');
  }
#line 330
  if ((unsigned long )cptr == (unsigned long )((void *)0)) {
#line 331
    return (0);
  }
  {
#line 333
  strncpy(buffer, (char const   *)(cptr + 1), 15UL);
#line 334
  buffer[15] = (char)0;
#line 336
  k = 0;
  }
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;

#line 336
    if (! buffer[k]) {
#line 336
      goto while_break;
    }
#line 337
    buffer[k] = (char)0;
#line 336
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 339
  __cil_tmp8 = strcmp((char const   *)(buffer), "gsm");
  }
#line 339
  if (__cil_tmp8 == 0) {
#line 340
    return (262176);
  }
  {
#line 342
  __cil_tmp9 = strcmp((char const   *)(buffer), "vox");
  }
#line 342
  if (__cil_tmp9 == 0) {
#line 343
    return (262177);
  }
#line 345
  k = 0;
  {
#line 345
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 345
    if (! (k < (int )(sizeof(format_map) / sizeof(format_map[0])))) {
#line 345
      goto while_break___0;
    }
    {
#line 346
    __cil_tmp10 = strncmp((char const   *)(buffer), format_map[k].ext, (unsigned long )format_map[k].len);
    }
#line 346
    if (format_map[k].len > 0) {
#line 346
      if (__cil_tmp10 == 0) {
#line 347
        return (format_map[k].format | format);
      } else {
#line 346
        goto _L;
      }
    } else {
      _L: 
      {
#line 348
      __cil_tmp11 = strcmp((char const   *)(buffer), format_map[k].ext);
      }
#line 348
      if (__cil_tmp11 == 0) {
#line 349
        return (format_map[k].format | format);
      }
    }
#line 345
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 353
  return (65539);
}
}
#line 357 "/root/patchweave_new/23/programs/common.c"
void sfe_dump_format_map(void) 
{ 
  SF_FORMAT_INFO info ;
  int k ;
  char const   *tmp ;

  {
#line 361
  k = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;

#line 361
    if (! (k < (int )(sizeof(format_map) / sizeof(format_map[0])))) {
#line 361
      goto while_break;
    }
    {
#line 362
    info.format = format_map[k].format;
#line 363
    sf_command((SNDFILE *)((void *)0), 4136, (void *)(& info), (int )sizeof(info));
    }
#line 364
    if ((unsigned long )info.name == (unsigned long )((void *)0)) {
#line 364
      tmp = "????";
    } else {
#line 364
      tmp = info.name;
    }
    {
#line 364
    printf("        %-10s : %s\n", format_map[k].ext, tmp);
#line 361
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 366
  return;
}
}
#line 370 "/root/patchweave_new/23/programs/common.c"
char const   *program_name(char const   *argv0 ) 
{ 
  char const   *tmp ;
  char *__cil_tmp3 ;
  char const   *tmp___58 ;
  char *__cil_tmp5 ;

  {
  {
#line 373
  __cil_tmp3 = strrchr(argv0, '/');
#line 373
  tmp = (char const   *)__cil_tmp3;
  }
#line 374
  if (tmp) {
#line 374
    tmp___58 = tmp + 1;
  } else {
#line 374
    tmp___58 = argv0;
  }
  {
#line 374
  argv0 = tmp___58;
#line 377
  __cil_tmp5 = strstr(argv0, "lt-I\270U");
  }
#line 377
  if ((unsigned long )__cil_tmp5 == (unsigned long )argv0) {
#line 378
    return (argv0 + 3);
  }
#line 380
  return (argv0);
}
}
#line 384 "/root/patchweave_new/23/programs/common.c"
char const   *sfe_endian_name(int format ) 
{ 


  {
#line 387
  if ((format & 805306368) == 0) {
#line 387
    goto case_0;
  }
#line 388
  if ((format & 805306368) == 268435456) {
#line 388
    goto case_268435456;
  }
#line 389
  if ((format & 805306368) == 536870912) {
#line 389
    goto case_536870912;
  }
#line 390
  if ((format & 805306368) == 805306368) {
#line 390
    goto case_805306368;
  }
#line 391
  goto switch_default;
  case_0: 
#line 387
  return ("file\270U");
  case_268435456: 
#line 388
  return ("little");
  case_536870912: 
#line 389
  return ("big");
  case_805306368: 
#line 390
  return ("cpuI\270U");
  switch_default: 
#line 391
  goto switch_break;
  switch_break: ;
#line 394
  return ("unknown");
}
}
#line 398 "/root/patchweave_new/23/programs/common.c"
char const   *sfe_container_name(int format ) 
{ 


  {
#line 401
  if ((format & 268369920) == 65536) {
#line 401
    goto case_65536;
  }
#line 402
  if ((format & 268369920) == 131072) {
#line 402
    goto case_131072;
  }
#line 403
  if ((format & 268369920) == 196608) {
#line 403
    goto case_196608;
  }
#line 404
  if ((format & 268369920) == 262144) {
#line 404
    goto case_262144;
  }
#line 405
  if ((format & 268369920) == 327680) {
#line 405
    goto case_327680;
  }
#line 406
  if ((format & 268369920) == 393216) {
#line 406
    goto case_393216;
  }
#line 407
  if ((format & 268369920) == 458752) {
#line 407
    goto case_458752;
  }
#line 408
  if ((format & 268369920) == 524288) {
#line 408
    goto case_524288;
  }
#line 409
  if ((format & 268369920) == 655360) {
#line 409
    goto case_655360;
  }
#line 410
  if ((format & 268369920) == 720896) {
#line 410
    goto case_720896;
  }
#line 411
  if ((format & 268369920) == 786432) {
#line 411
    goto case_786432;
  }
#line 412
  if ((format & 268369920) == 851968) {
#line 412
    goto case_851968;
  }
#line 413
  if ((format & 268369920) == 917504) {
#line 413
    goto case_917504;
  }
#line 414
  if ((format & 268369920) == 983040) {
#line 414
    goto case_983040;
  }
#line 415
  if ((format & 268369920) == 1048576) {
#line 415
    goto case_1048576;
  }
#line 416
  if ((format & 268369920) == 1114112) {
#line 416
    goto case_1114112;
  }
#line 417
  if ((format & 268369920) == 1179648) {
#line 417
    goto case_1179648;
  }
#line 418
  if ((format & 268369920) == 1245184) {
#line 418
    goto case_1245184;
  }
#line 419
  if ((format & 268369920) == 1441792) {
#line 419
    goto case_1441792;
  }
#line 420
  if ((format & 268369920) == 1507328) {
#line 420
    goto case_1507328;
  }
#line 421
  if ((format & 268369920) == 1572864) {
#line 421
    goto case_1572864;
  }
#line 422
  if ((format & 268369920) == 1638400) {
#line 422
    goto case_1638400;
  }
#line 423
  if ((format & 268369920) == 2097152) {
#line 423
    goto case_2097152;
  }
#line 424
  if ((format & 268369920) == 2162688) {
#line 424
    goto case_2162688;
  }
#line 425
  if ((format & 268369920) == 2228224) {
#line 425
    goto case_2228224;
  }
#line 426
  goto switch_default;
  case_65536: 
#line 401
  return ("WAV");
  case_131072: 
#line 402
  return ("AIFF");
  case_196608: 
#line 403
  return ("AULI\270U");
  case_262144: 
#line 404
  return ("RAW");
  case_327680: 
#line 405
  return ("PAFI\270U");
  case_393216: 
#line 406
  return ("SVX");
  case_458752: 
#line 407
  return ("NIST");
  case_524288: 
#line 408
  return ("VOCI\270U");
  case_655360: 
#line 409
  return ("IRCAMU");
  case_720896: 
#line 410
  return ("W64I\270U");
  case_786432: 
#line 411
  return ("MAT4\270U");
  case_851968: 
#line 412
  return ("MAT5\270U");
  case_917504: 
#line 413
  return ("PVFI\270U");
  case_983040: 
#line 414
  return ("XI");
  case_1048576: 
#line 415
  return ("HTKI\270U");
  case_1114112: 
#line 416
  return ("SDS");
  case_1179648: 
#line 417
  return ("AVR");
  case_1245184: 
#line 418
  return ("WAVEX");
  case_1441792: 
#line 419
  return ("SD2");
  case_1507328: 
#line 420
  return ("FLAC");
  case_1572864: 
#line 421
  return ("CAF");
  case_1638400: 
#line 422
  return ("WVEI\270U");
  case_2097152: 
#line 423
  return ("OGGI\270U");
  case_2162688: 
#line 424
  return ("MPC2K");
  case_2228224: 
#line 425
  return ("RF64\270U");
  switch_default: 
#line 426
  goto switch_break;
  switch_break: ;
#line 429
  return ("unknown");
}
}
#line 433 "/root/patchweave_new/23/programs/common.c"
char const   *sfe_codec_name(int format ) 
{ 


  {
#line 436
  if ((format & 65535) == 1) {
#line 436
    goto case_1;
  }
#line 437
  if ((format & 65535) == 2) {
#line 437
    goto case_2;
  }
#line 438
  if ((format & 65535) == 3) {
#line 438
    goto case_3;
  }
#line 439
  if ((format & 65535) == 4) {
#line 439
    goto case_4;
  }
#line 440
  if ((format & 65535) == 5) {
#line 440
    goto case_5;
  }
#line 441
  if ((format & 65535) == 6) {
#line 441
    goto case_6;
  }
#line 442
  if ((format & 65535) == 7) {
#line 442
    goto case_7;
  }
#line 443
  if ((format & 65535) == 16) {
#line 443
    goto case_16;
  }
#line 444
  if ((format & 65535) == 17) {
#line 444
    goto case_17;
  }
#line 445
  if ((format & 65535) == 18) {
#line 445
    goto case_18;
  }
#line 446
  if ((format & 65535) == 19) {
#line 446
    goto case_19;
  }
#line 447
  if ((format & 65535) == 32) {
#line 447
    goto case_32;
  }
#line 448
  if ((format & 65535) == 33) {
#line 448
    goto case_33;
  }
#line 449
  if ((format & 65535) == 48) {
#line 449
    goto case_48;
  }
#line 450
  if ((format & 65535) == 49) {
#line 450
    goto case_49;
  }
#line 451
  if ((format & 65535) == 50) {
#line 451
    goto case_50;
  }
#line 452
  if ((format & 65535) == 64) {
#line 452
    goto case_64;
  }
#line 453
  if ((format & 65535) == 65) {
#line 453
    goto case_65;
  }
#line 454
  if ((format & 65535) == 66) {
#line 454
    goto case_66;
  }
#line 455
  if ((format & 65535) == 67) {
#line 455
    goto case_67;
  }
#line 456
  if ((format & 65535) == 80) {
#line 456
    goto case_80;
  }
#line 457
  if ((format & 65535) == 81) {
#line 457
    goto case_81;
  }
#line 458
  if ((format & 65535) == 96) {
#line 458
    goto case_96;
  }
#line 459
  if ((format & 65535) == 112) {
#line 459
    goto case_112;
  }
#line 460
  if ((format & 65535) == 113) {
#line 460
    goto case_113;
  }
#line 461
  if ((format & 65535) == 114) {
#line 461
    goto case_114;
  }
#line 462
  if ((format & 65535) == 115) {
#line 462
    goto case_115;
  }
#line 463
  goto switch_default;
  case_1: 
#line 436
  return ("signed 8 bit PCM\220");
  case_2: 
#line 437
  return ("16 bit PCMLI\270U");
  case_3: 
#line 438
  return ("24 bit PCMLI\270U");
  case_4: 
#line 439
  return ("32 bit PCMLI\270U");
  case_5: 
#line 440
  return ("unsigned 8 bit PCM");
  case_6: 
#line 441
  return ("32 bit float\270U");
  case_7: 
#line 442
  return ("64 bit doubleU");
  case_16: 
#line 443
  return ("u-lawU");
  case_17: 
#line 444
  return ("a-law");
  case_18: 
#line 445
  return ("IMA ADPCM\260LI\270U");
  case_19: 
#line 446
  return ("MS ADPCM\220");
  case_32: 
#line 447
  return ("gsm610");
  case_33: 
#line 448
  return ("Vox ADPCM\264LI\270U");
  case_48: 
#line 449
  return ("g721 32kbpsI\270U");
  case_49: 
#line 450
  return ("g723 24kbps");
  case_50: 
#line 451
  return ("g723 40kbpsI\270U");
  case_64: 
#line 452
  return ("12 bit DWVW");
  case_65: 
#line 453
  return ("16 bit DWVWI\270U");
  case_66: 
#line 454
  return ("14 bit DWVWI\270U");
  case_67: 
#line 455
  return ("DWVW\270U");
  case_80: 
#line 456
  return ("8 bit DPCM");
  case_81: 
#line 457
  return ("16 bit DPCM");
  case_96: 
#line 458
  return ("Vorbis");
  case_112: 
#line 459
  return ("16 bit ALAC");
  case_113: 
#line 460
  return ("20 bit ALAC");
  case_114: 
#line 461
  return ("24 bit ALAC");
  case_115: 
#line 462
  return ("32 bit ALAC");
  switch_default: 
#line 463
  goto switch_break;
  switch_break: ;
#line 465
  return ("unknown");
}
}
#line 48 "/root/patchweave_new/23/programs/sndfile-convert.c"
static void copy_metadata(SNDFILE *outfile , SNDFILE *infile , int channels ) ;
#line 51 "/root/patchweave_new/23/programs/sndfile-convert.c"
static void usage_exit(char const   *progname ) 
{ 


  {
  {
#line 53
  printf("\nUsage : %s [options] [encoding] <input file> <output file>\n", progname);
#line 54
  puts("\n    where [option] may be:\n\n        -override-sample-rate=X  : force sample rate of input to X\n        -endian=little           : force output file to little endian data\n        -endian=big              : force output file to big endian data\n        -endian=cpu              : force output file same endian-ness as the CPU\n        -normalize               : normalize the data in the output file\n");
#line 63
  puts("    where [encoding] may be one of the following:\n\n        -pcms8     : signed 8 bit pcm\n        -pcmu8     : unsigned 8 bit pcm\n        -pcm16     : 16 bit pcm\n        -pcm24     : 24 bit pcm\n        -pcm32     : 32 bit pcm\n        -float32   : 32 bit floating point\n        -ulaw      : ULAW\n        -alaw      : ALAW\n        -alac16    : 16 bit ALAC (CAF only)\n        -alac20    : 20 bit ALAC (CAF only)\n        -alac24    : 24 bit ALAC (CAF only)\n        -alac32    : 32 bit ALAC (CAF only)\n        -ima-adpcm : IMA ADPCM (WAV only)\n        -ms-adpcm  : MS ADPCM (WAV only)\n        -gsm610    : GSM6.10 (WAV only)\n        -dwvw12    : 12 bit DWVW (AIFF only)\n        -dwvw16    : 16 bit DWVW (AIFF only)\n        -dwvw24    : 24 bit DWVW (AIFF only)\n        -vorbis    : Vorbis (OGG only)\n");
#line 86
  puts("    If no encoding is specified, the program will try to use the encoding\n    of the input file in the output file. This will not always work as\n    most container formats (eg WAV, AIFF etc) only support a small subset\n    of codec formats (eg 16 bit PCM, a-law, Vorbis etc).\n\220");
#line 93
  puts("    The format of the output file is determined by the file extension of the\n    output file name. The following extensions are currently understood:\n");
#line 98
  sfe_dump_format_map();
#line 100
  puts("\220");
#line 101
  exit(1);
  }
}
}
#line 105 "/root/patchweave_new/23/programs/sndfile-convert.c"
static void report_format_error_exit(char const   *argv0 , SF_INFO *sfinfo ) 
{ 
  int old_format ;
  int endian ;
  int __cil_tmp5 ;
  char const   *__cil_tmp6 ;
  char const   *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  char const   *__cil_tmp9 ;

  {
  {
#line 106
  old_format = sfinfo->format;
#line 107
  endian = sfinfo->format & 805306368;
#line 109
  sfinfo->format = old_format & 268435455;
#line 111
  __cil_tmp5 = sf_format_check(sfinfo);
  }
#line 111
  if (endian) {
#line 111
    if (__cil_tmp5) {
      {
#line 112
      __cil_tmp6 = sfe_endian_name(endian);
#line 112
      printf("Error : output file format does not support %s endian-ness.\n", __cil_tmp6);
#line 113
      exit(1);
      }
    }
  }
  {
#line 116
  __cil_tmp7 = sfe_container_name(sfinfo->format);
#line 116
  __cil_tmp8 = sfe_codec_name(sfinfo->format);
#line 116
  __cil_tmp9 = program_name(argv0);
#line 116
  printf("\nError : output file format is invalid.\nThe \'%s\' container does not support \'%s\' codec data.\nRun \'%s --help\' for clues.\n\n",
         __cil_tmp7, __cil_tmp8, __cil_tmp9);
#line 121
  exit(1);
  }
}
}
#line 125 "/root/patchweave_new/23/programs/sndfile-convert.c"
int main(int argc , char **argv ) 
{ 
  char const   *progname ;
  char const   *infilename ;
  char const   *outfilename ;
  SNDFILE *infile ;
  SNDFILE *outfile ;
  SF_INFO sfinfo ;
  int k ;
  int outfilemajor ;
  int outfileminor ;
  int infileminor ;
  int override_sample_rate ;
  int endian ;
  int normalize ;
  int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  char *__cil_tmp38 ;
  char const   *ptr ;
  unsigned long __cil_tmp40 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  char const   *__cil_tmp49 ;
  int __cil_tmp51 ;
  char const   *__cil_tmp53 ;

  {
  {
#line 127
  infile = (SNDFILE *)((void *)0);
#line 127
  outfile = (SNDFILE *)((void *)0);
#line 129
  outfileminor = 0;
#line 130
  override_sample_rate = 0;
#line 131
  endian = 0;
#line 131
  normalize = 0;
#line 133
  progname = program_name((char const   *)*(argv + 0));
  }
#line 135
  if (argc < 3) {
    {
#line 136
    usage_exit(progname);
    }
  } else
#line 135
  if (argc > 5) {
    {
#line 136
    usage_exit(progname);
    }
  }
  {
#line 138
  infilename = (char const   *)*(argv + (argc - 2));
#line 139
  outfilename = (char const   *)*(argv + (argc - 1));
#line 141
  __cil_tmp17 = strcmp(infilename, outfilename);
  }
#line 141
  if (__cil_tmp17 == 0) {
    {
#line 142
    printf("Error : Input and output filenames are the same.\n\n");
#line 143
    usage_exit(progname);
    }
  }
  {
#line 146
  __cil_tmp18 = strlen(infilename);
  }
#line 146
  if (__cil_tmp18 > 1UL) {
#line 146
    if ((int )*(infilename + 0) == 45) {
      {
#line 147
      printf("Error : Input filename (%s) looks like an option.\n\n", infilename);
#line 148
      usage_exit(progname);
      }
    }
  }
#line 151
  if ((int )*(outfilename + 0) == 45) {
    {
#line 152
    printf("Error : Output filename (%s) looks like an option.\n\n", outfilename);
#line 153
    usage_exit(progname);
    }
  }
#line 156
  k = 1;
  {
#line 156
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 156
    if (! (k < argc - 2)) {
#line 156
      goto while_break;
    }
    {
#line 157
    __cil_tmp19 = strcmp((char const   *)*(argv + k), "-pcms8");
    }
#line 157
    if (! __cil_tmp19) {
#line 158
      outfileminor = 1;
#line 159
      goto while_continue;
    }
    {
#line 161
    __cil_tmp20 = strcmp((char const   *)*(argv + k), "-pcmu8");
    }
#line 161
    if (! __cil_tmp20) {
#line 162
      outfileminor = 5;
#line 163
      goto while_continue;
    }
    {
#line 165
    __cil_tmp21 = strcmp((char const   *)*(argv + k), "-pcm16");
    }
#line 165
    if (! __cil_tmp21) {
#line 166
      outfileminor = 2;
#line 167
      goto while_continue;
    }
    {
#line 169
    __cil_tmp22 = strcmp((char const   *)*(argv + k), "-pcm24");
    }
#line 169
    if (! __cil_tmp22) {
#line 170
      outfileminor = 3;
#line 171
      goto while_continue;
    }
    {
#line 173
    __cil_tmp23 = strcmp((char const   *)*(argv + k), "-pcm32");
    }
#line 173
    if (! __cil_tmp23) {
#line 174
      outfileminor = 4;
#line 175
      goto while_continue;
    }
    {
#line 177
    __cil_tmp24 = strcmp((char const   *)*(argv + k), "-float32\220");
    }
#line 177
    if (! __cil_tmp24) {
#line 178
      outfileminor = 6;
#line 179
      goto while_continue;
    }
    {
#line 181
    __cil_tmp25 = strcmp((char const   *)*(argv + k), "-ulaw");
    }
#line 181
    if (! __cil_tmp25) {
#line 182
      outfileminor = 16;
#line 183
      goto while_continue;
    }
    {
#line 185
    __cil_tmp26 = strcmp((char const   *)*(argv + k), "-alaw");
    }
#line 185
    if (! __cil_tmp26) {
#line 186
      outfileminor = 17;
#line 187
      goto while_continue;
    }
    {
#line 189
    __cil_tmp27 = strcmp((char const   *)*(argv + k), "-alac16");
    }
#line 189
    if (! __cil_tmp27) {
#line 190
      outfileminor = 112;
#line 191
      goto while_continue;
    }
    {
#line 193
    __cil_tmp28 = strcmp((char const   *)*(argv + k), "-alac20");
    }
#line 193
    if (! __cil_tmp28) {
#line 194
      outfileminor = 113;
#line 195
      goto while_continue;
    }
    {
#line 197
    __cil_tmp29 = strcmp((char const   *)*(argv + k), "-alac24");
    }
#line 197
    if (! __cil_tmp29) {
#line 198
      outfileminor = 114;
#line 199
      goto while_continue;
    }
    {
#line 201
    __cil_tmp30 = strcmp((char const   *)*(argv + k), "-alac32");
    }
#line 201
    if (! __cil_tmp30) {
#line 202
      outfileminor = 115;
#line 203
      goto while_continue;
    }
    {
#line 205
    __cil_tmp31 = strcmp((char const   *)*(argv + k), "-ima-adpcm");
    }
#line 205
    if (! __cil_tmp31) {
#line 206
      outfileminor = 18;
#line 207
      goto while_continue;
    }
    {
#line 209
    __cil_tmp32 = strcmp((char const   *)*(argv + k), "-ms-adpcm");
    }
#line 209
    if (! __cil_tmp32) {
#line 210
      outfileminor = 19;
#line 211
      goto while_continue;
    }
    {
#line 213
    __cil_tmp33 = strcmp((char const   *)*(argv + k), "-gsm610");
    }
#line 213
    if (! __cil_tmp33) {
#line 214
      outfileminor = 32;
#line 215
      goto while_continue;
    }
    {
#line 217
    __cil_tmp34 = strcmp((char const   *)*(argv + k), "-dwvw12");
    }
#line 217
    if (! __cil_tmp34) {
#line 218
      outfileminor = 64;
#line 219
      goto while_continue;
    }
    {
#line 221
    __cil_tmp35 = strcmp((char const   *)*(argv + k), "-dwvw16");
    }
#line 221
    if (! __cil_tmp35) {
#line 222
      outfileminor = 65;
#line 223
      goto while_continue;
    }
    {
#line 225
    __cil_tmp36 = strcmp((char const   *)*(argv + k), "-dwvw24");
    }
#line 225
    if (! __cil_tmp36) {
#line 226
      outfileminor = 66;
#line 227
      goto while_continue;
    }
    {
#line 229
    __cil_tmp37 = strcmp((char const   *)*(argv + k), "-vorbis");
    }
#line 229
    if (! __cil_tmp37) {
#line 230
      outfileminor = 96;
#line 231
      goto while_continue;
    }
    {
#line 234
    __cil_tmp38 = strstr((char const   *)*(argv + k), "-override-sample-rate=");
    }
#line 234
    if ((unsigned long )__cil_tmp38 == (unsigned long )*(argv + k)) {
      {
#line 237
      __cil_tmp40 = strlen("-override-sample-rate=");
#line 237
      ptr = (char const   *)(*(argv + k) + __cil_tmp40);
#line 238
      override_sample_rate = atoi(ptr);
      }
#line 239
      goto while_continue;
    }
    {
#line 242
    __cil_tmp42 = strcmp((char const   *)*(argv + k), "-endian=little");
    }
#line 242
    if (! __cil_tmp42) {
#line 243
      endian = 268435456;
#line 244
      goto while_continue;
    }
    {
#line 247
    __cil_tmp43 = strcmp((char const   *)*(argv + k), "-endian=big");
    }
#line 247
    if (! __cil_tmp43) {
#line 248
      endian = 536870912;
#line 249
      goto while_continue;
    }
    {
#line 252
    __cil_tmp44 = strcmp((char const   *)*(argv + k), "-endian=cpu");
    }
#line 252
    if (! __cil_tmp44) {
#line 253
      endian = 805306368;
#line 254
      goto while_continue;
    }
    {
#line 257
    __cil_tmp45 = strcmp((char const   *)*(argv + k), "-endian=file");
    }
#line 257
    if (! __cil_tmp45) {
#line 258
      endian = 0;
#line 259
      goto while_continue;
    }
    {
#line 262
    __cil_tmp46 = strcmp((char const   *)*(argv + k), "-normalize");
    }
#line 262
    if (! __cil_tmp46) {
#line 263
      normalize = 1;
#line 264
      goto while_continue;
    }
    {
#line 267
    printf("Error : Not able to decode argunment \'%s\'.\n", *(argv + k));
#line 268
    exit(1);
#line 156
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 271
  memset((void *)(& sfinfo), 0, sizeof(sfinfo));
#line 273
  infile = sf_open(infilename, 16, & sfinfo);
  }
#line 273
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 274
    printf("Not able to open input file %s.\n\230\001", infilename);
#line 275
    __cil_tmp49 = sf_strerror((SNDFILE *)((void *)0));
#line 275
    puts(__cil_tmp49);
    }
#line 276
    return (1);
  }
#line 280
  if (override_sample_rate) {
#line 281
    sfinfo.samplerate = override_sample_rate;
  }
  {
#line 283
  infileminor = sfinfo.format & 65535;
#line 285
  sfinfo.format = sfe_file_type_of_ext(outfilename, sfinfo.format);
  }
#line 285
  if (sfinfo.format == 0) {
    {
#line 286
    printf("Error : Not able to determine output file type for %s.\n", outfilename);
    }
#line 287
    return (1);
  }
#line 290
  outfilemajor = sfinfo.format & 1073676288;
#line 292
  if (outfileminor == 0) {
#line 293
    outfileminor = sfinfo.format & 65535;
  }
#line 295
  if (outfileminor != 0) {
#line 296
    sfinfo.format = outfilemajor | outfileminor;
  } else {
#line 298
    sfinfo.format = outfilemajor | (sfinfo.format & 65535);
  }
#line 300
  sfinfo.format |= endian;
#line 302
  if ((sfinfo.format & 268369920) == 983040) {
#line 304
    if ((sfinfo.format & 65535) == 2) {
#line 304
      goto case_2;
    }
#line 309
    if ((sfinfo.format & 65535) == 5) {
#line 309
      goto case_5;
    }
#line 309
    if ((sfinfo.format & 65535) == 1) {
#line 309
      goto case_5;
    }
#line 303
    goto switch_break;
    case_2: 
#line 305
    sfinfo.format = outfilemajor | 81;
#line 306
    goto switch_break;
    case_5: 
#line 310
    sfinfo.format = outfilemajor | 80;
#line 311
    goto switch_break;
    switch_break: ;
  }
  {
#line 314
  __cil_tmp51 = sf_format_check(& sfinfo);
  }
#line 314
  if (__cil_tmp51 == 0) {
    {
#line 315
    report_format_error_exit((char const   *)*(argv + 0), & sfinfo);
    }
  }
#line 317
  if ((sfinfo.format & 65535) == 32) {
#line 317
    if (sfinfo.samplerate != 8000) {
      {
#line 318
      printf("WARNING: GSM 6.10 data format only supports 8kHz sample rate. The converted\nouput file will contain the input data converted to the GSM 6.10 data format\nbut not re-sampled.\n");
      }
    }
  }
  {
#line 326
  outfile = sf_open(outfilename, 32, & sfinfo);
  }
#line 326
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
    {
#line 327
    __cil_tmp53 = sf_strerror((SNDFILE *)((void *)0));
#line 327
    printf("Not able to open output file %s : %s\n", outfilename, __cil_tmp53);
    }
#line 328
    return (1);
  }
  {
#line 332
  copy_metadata(outfile, infile, sfinfo.channels);
  }
#line 334
  if (normalize) {
    {
#line 338
    sfe_copy_data_fp(outfile, infile, sfinfo.channels, normalize);
    }
  } else
#line 334
  if (outfileminor == 7) {
    {
#line 338
    sfe_copy_data_fp(outfile, infile, sfinfo.channels, normalize);
    }
  } else
#line 334
  if (outfileminor == 6) {
    {
#line 338
    sfe_copy_data_fp(outfile, infile, sfinfo.channels, normalize);
    }
  } else
#line 334
  if (infileminor == 7) {
    {
#line 338
    sfe_copy_data_fp(outfile, infile, sfinfo.channels, normalize);
    }
  } else
#line 334
  if (infileminor == 6) {
    {
#line 338
    sfe_copy_data_fp(outfile, infile, sfinfo.channels, normalize);
    }
  } else
#line 334
  if (infileminor == 96) {
    {
#line 338
    sfe_copy_data_fp(outfile, infile, sfinfo.channels, normalize);
    }
  } else
#line 334
  if (outfileminor == 96) {
    {
#line 338
    sfe_copy_data_fp(outfile, infile, sfinfo.channels, normalize);
    }
  } else {
    {
#line 340
    sfe_copy_data_int(outfile, infile, sfinfo.channels);
    }
  }
  {
#line 342
  sf_close(infile);
#line 343
  sf_close(outfile);
  }
#line 345
  return (0);
}
}
#line 349 "/root/patchweave_new/23/programs/sndfile-convert.c"
static void copy_metadata(SNDFILE *outfile , SNDFILE *infile , int channels ) 
{ 
  SF_INSTRUMENT inst ;
  SF_CUES cues ;
  SF_BROADCAST_INFO_2K binfo ;
  char const   *str___0 ;
  int k ;
  int chanmap[256] ;
  size_t size ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 356
  k = 1;
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;

#line 356
    if (! (k <= 16)) {
#line 356
      goto while_break;
    }
    {
#line 357
    str___0 = sf_get_string(infile, k);
    }
#line 358
    if ((unsigned long )str___0 != (unsigned long )((void *)0)) {
      {
#line 359
      sf_set_string(outfile, k, str___0);
      }
    }
#line 356
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 362
  memset((void *)(& inst), 0, sizeof(inst));
#line 363
  memset((void *)(& cues), 0, sizeof(cues));
#line 364
  memset((void *)(& binfo), 0, sizeof(binfo));
  }
#line 366
  if (channels < (int )(sizeof(chanmap) / sizeof(chanmap[0]))) {
    {
#line 367
    size = (unsigned long )channels * sizeof(chanmap[0]);
#line 369
    __cil_tmp13 = sf_command(infile, 4352, (void *)(chanmap), (int )size);
    }
#line 369
    if (__cil_tmp13 == 1) {
      {
#line 370
      sf_command(outfile, 4353, (void *)(chanmap), (int )size);
      }
    }
  }
  {
#line 373
  __cil_tmp14 = sf_command(infile, 4302, (void *)(& cues), (int )sizeof(cues));
  }
#line 373
  if (__cil_tmp14 == 1) {
    {
#line 374
    sf_command(outfile, 4303, (void *)(& cues), (int )sizeof(cues));
    }
  }
  {
#line 376
  __cil_tmp15 = sf_command(infile, 4304, (void *)(& inst), (int )sizeof(inst));
  }
#line 376
  if (__cil_tmp15 == 1) {
    {
#line 377
    sf_command(outfile, 4305, (void *)(& inst), (int )sizeof(inst));
    }
  }
  {
#line 379
  __cil_tmp16 = sf_command(infile, 4336, (void *)(& binfo), (int )sizeof(binfo));
  }
#line 379
  if (__cil_tmp16 == 1) {
    {
#line 380
    sf_command(outfile, 4337, (void *)(& binfo), (int )sizeof(binfo));
    }
  }
#line 383
  return;
}
}
