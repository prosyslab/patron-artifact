/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef unsigned long size_t;
#line 328 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef int wchar_t;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_5 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_5 __sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_8 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_7 {
   unsigned long long __wseq ;
   struct __anonstruct_8 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_10 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_9 {
   unsigned long long __g1_start ;
   struct __anonstruct_10 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_7 __annonCompField1 ;
   unsigned long long __wseq ;
   struct __anonstruct_8 __wseq32 ;
   union __anonunion_9 __annonCompField2 ;
   unsigned long long __g1_start ;
   struct __anonstruct_10 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_11 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_11 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_12 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_12 pthread_condattr_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_13 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_13 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_14 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_14 pthread_cond_t;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef long ptrdiff_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 90 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 29 "../../src/webp/decode.h"
struct WebPRGBABuffer ;
#line 29 "../../src/webp/decode.h"
typedef struct WebPRGBABuffer WebPRGBABuffer;
#line 30
struct WebPYUVABuffer ;
#line 30 "../../src/webp/decode.h"
typedef struct WebPYUVABuffer WebPYUVABuffer;
#line 31
struct WebPDecBuffer ;
#line 31 "../../src/webp/decode.h"
typedef struct WebPDecBuffer WebPDecBuffer;
#line 32
struct WebPIDecoder ;
#line 32 "../../src/webp/decode.h"
typedef struct WebPIDecoder WebPIDecoder;
#line 33
struct WebPBitstreamFeatures ;
#line 33 "../../src/webp/decode.h"
typedef struct WebPBitstreamFeatures WebPBitstreamFeatures;
#line 34
struct WebPDecoderOptions ;
#line 34 "../../src/webp/decode.h"
typedef struct WebPDecoderOptions WebPDecoderOptions;
#line 35
struct WebPDecoderConfig ;
#line 35 "../../src/webp/decode.h"
typedef struct WebPDecoderConfig WebPDecoderConfig;
#line 149
enum WEBP_CSP_MODE {
    MODE_RGB = 0,
    MODE_RGBA = 1,
    MODE_BGR = 2,
    MODE_BGRA = 3,
    MODE_ARGB = 4,
    MODE_RGBA_4444 = 5,
    MODE_RGB_565 = 6,
    MODE_rgbA = 7,
    MODE_bgrA = 8,
    MODE_Argb = 9,
    MODE_rgbA_4444 = 10,
    MODE_YUV = 11,
    MODE_YUVA = 12,
    MODE_LAST = 13
} ;
#line 162 "../../src/webp/decode.h"
typedef enum WEBP_CSP_MODE WEBP_CSP_MODE;
#line 183 "../../src/webp/decode.h"
struct WebPRGBABuffer {
   uint8_t *rgba ;
   int stride ;
   size_t size ;
};
#line 189 "../../src/webp/decode.h"
struct WebPYUVABuffer {
   uint8_t *y ;
   uint8_t *u ;
   uint8_t *v ;
   uint8_t *a ;
   int y_stride ;
   int u_stride ;
   int v_stride ;
   int a_stride ;
   size_t y_size ;
   size_t u_size ;
   size_t v_size ;
   size_t a_size ;
};
#line 207 "../../src/webp/decode.h"
union __anonunion_21 {
   WebPRGBABuffer RGBA ;
   WebPYUVABuffer YUVA ;
};
#line 200 "../../src/webp/decode.h"
struct WebPDecBuffer {
   WEBP_CSP_MODE colorspace ;
   int width ;
   int height ;
   int is_external_memory ;
   union __anonunion_21 u ;
   uint32_t pad[4] ;
   uint8_t *private_memory ;
};
#line 234
enum VP8StatusCode {
    VP8_STATUS_OK = 0,
    VP8_STATUS_OUT_OF_MEMORY = 1,
    VP8_STATUS_INVALID_PARAM = 2,
    VP8_STATUS_BITSTREAM_ERROR = 3,
    VP8_STATUS_UNSUPPORTED_FEATURE = 4,
    VP8_STATUS_SUSPENDED = 5,
    VP8_STATUS_USER_ABORT = 6,
    VP8_STATUS_NOT_ENOUGH_DATA = 7
} ;
#line 243 "../../src/webp/decode.h"
typedef enum VP8StatusCode VP8StatusCode;
#line 412 "../../src/webp/decode.h"
struct WebPBitstreamFeatures {
   int width ;
   int height ;
   int has_alpha ;
   int has_animation ;
   int format ;
   uint32_t pad[5] ;
};
#line 445 "../../src/webp/decode.h"
struct WebPDecoderOptions {
   int bypass_filtering ;
   int no_fancy_upsampling ;
   int use_cropping ;
   int crop_left ;
   int crop_top ;
   int crop_width ;
   int crop_height ;
   int use_scaling ;
   int scaled_width ;
   int scaled_height ;
   int use_threads ;
   int dithering_strength ;
   int flip ;
   int alpha_dithering_strength ;
   uint32_t pad[5] ;
};
#line 463 "../../src/webp/decode.h"
struct WebPDecoderConfig {
   WebPBitstreamFeatures input ;
   WebPDecBuffer output ;
   WebPDecoderOptions options ;
};
#line 31 "../../src/webp/encode.h"
struct WebPConfig ;
#line 31 "../../src/webp/encode.h"
typedef struct WebPConfig WebPConfig;
#line 32
struct WebPPicture ;
#line 32 "../../src/webp/encode.h"
typedef struct WebPPicture WebPPicture;
#line 33
struct WebPAuxStats ;
#line 33 "../../src/webp/encode.h"
typedef struct WebPAuxStats WebPAuxStats;
#line 34
struct WebPMemoryWriter ;
#line 34 "../../src/webp/encode.h"
typedef struct WebPMemoryWriter WebPMemoryWriter;
#line 86
enum WebPImageHint {
    WEBP_HINT_DEFAULT = 0,
    WEBP_HINT_PICTURE = 1,
    WEBP_HINT_PHOTO = 2,
    WEBP_HINT_GRAPH = 3,
    WEBP_HINT_LAST = 4
} ;
#line 92 "../../src/webp/encode.h"
typedef enum WebPImageHint WebPImageHint;
#line 95 "../../src/webp/encode.h"
struct WebPConfig {
   int lossless ;
   float quality ;
   int method ;
   WebPImageHint image_hint ;
   int target_size ;
   float target_PSNR ;
   int segments ;
   int sns_strength ;
   int filter_strength ;
   int filter_sharpness ;
   int filter_type ;
   int autofilter ;
   int alpha_compression ;
   int alpha_filtering ;
   int alpha_quality ;
   int pass ;
   int show_compressed ;
   int preprocessing ;
   int partitions ;
   int partition_limit ;
   int emulate_jpeg_size ;
   int thread_level ;
   int low_memory ;
   int near_lossless ;
   int exact ;
   int use_delta_palette ;
   int use_sharp_yuv ;
   int qmin ;
   int qmax ;
};
#line 157
enum WebPPreset {
    WEBP_PRESET_DEFAULT = 0,
    WEBP_PRESET_PICTURE = 1,
    WEBP_PRESET_PHOTO = 2,
    WEBP_PRESET_DRAWING = 3,
    WEBP_PRESET_ICON = 4,
    WEBP_PRESET_TEXT = 5
} ;
#line 164 "../../src/webp/encode.h"
typedef enum WebPPreset WebPPreset;
#line 204 "../../src/webp/encode.h"
struct WebPAuxStats {
   int coded_size ;
   float PSNR[5] ;
   int block_count[3] ;
   int header_bytes[2] ;
   int residual_bytes[3][4] ;
   int segment_size[4] ;
   int segment_quant[4] ;
   int segment_level[4] ;
   int alpha_data_size ;
   int layer_data_size ;
   uint32_t lossless_features ;
   int histogram_bits ;
   int transform_bits ;
   int cache_bits ;
   int palette_size ;
   int lossless_size ;
   int lossless_hdr_size ;
   int lossless_data_size ;
   uint32_t pad[2] ;
};
#line 242 "../../src/webp/encode.h"
struct WebPMemoryWriter {
   uint8_t *mem ;
   size_t size ;
   size_t max_size ;
   uint32_t pad[1] ;
};
#line 267
enum WebPEncCSP {
    WEBP_YUV420 = 0,
    WEBP_YUV420A = 4,
    WEBP_CSP_UV_MASK = 3,
    WEBP_CSP_ALPHA_BIT = 4
} ;
#line 273 "../../src/webp/encode.h"
typedef enum WebPEncCSP WebPEncCSP;
#line 276
enum WebPEncodingError {
    VP8_ENC_OK = 0,
    VP8_ENC_ERROR_OUT_OF_MEMORY = 1,
    VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY = 2,
    VP8_ENC_ERROR_NULL_PARAMETER = 3,
    VP8_ENC_ERROR_INVALID_CONFIGURATION = 4,
    VP8_ENC_ERROR_BAD_DIMENSION = 5,
    VP8_ENC_ERROR_PARTITION0_OVERFLOW = 6,
    VP8_ENC_ERROR_PARTITION_OVERFLOW = 7,
    VP8_ENC_ERROR_BAD_WRITE = 8,
    VP8_ENC_ERROR_FILE_TOO_BIG = 9,
    VP8_ENC_ERROR_USER_ABORT = 10,
    VP8_ENC_ERROR_LAST = 11
} ;
#line 289 "../../src/webp/encode.h"
typedef enum WebPEncodingError WebPEncodingError;
#line 300 "../../src/webp/encode.h"
struct WebPPicture {
   int use_argb ;
   WebPEncCSP colorspace ;
   int width ;
   int height ;
   uint8_t *y ;
   uint8_t *u ;
   uint8_t *v ;
   int y_stride ;
   int uv_stride ;
   uint8_t *a ;
   int a_stride ;
   uint32_t pad1[2] ;
   uint32_t *argb ;
   int argb_stride ;
   uint32_t pad2[3] ;
   int (*writer)(uint8_t * , size_t  , WebPPicture * ) ;
   void *custom_ptr ;
   int extra_info_type ;
   uint8_t *extra_info ;
   WebPAuxStats *stats ;
   WebPEncodingError error_code ;
   int (*progress_hook)(int  , WebPPicture * ) ;
   void *user_data ;
   uint32_t pad3[3] ;
   uint8_t *pad4 ;
   uint8_t *pad5 ;
   uint32_t pad6[8] ;
   void *memory_ ;
   void *memory_argb_ ;
   void *pad7[2] ;
};
#line 55 "../../src/webp/format_constants.h"
enum __anonenum__22 {
    PREDICTOR_TRANSFORM = 0,
    CROSS_COLOR_TRANSFORM = 1,
    SUBTRACT_GREEN = 2,
    COLOR_INDEXING_TRANSFORM = 3
} ;
#line 60 "../../src/webp/format_constants.h"
typedef enum __anonenum__22 VP8LImageTransformType;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 718 "/usr/include/pthread.h"
struct __jmp_buf_tag ;
#line 214 "../../src/dsp/dsp.h"
enum __anonenum__36 {
    kSSE2 = 0,
    kSSE3 = 1,
    kSlowSSSE3 = 2,
    kSSE4_1 = 3,
    kAVX = 4,
    kAVX2 = 5,
    kNEON = 6,
    kMIPS32 = 7,
    kMIPSdspR2 = 8,
    kMSA = 9
} ;
#line 225 "../../src/dsp/dsp.h"
typedef enum __anonenum__36 CPUFeature;
#line 279
struct VP8Matrix ;
#line 298 "../../src/dsp/dsp.h"
struct __anonstruct_37 {
   int max_value ;
   int last_non_zero ;
};
#line 302 "../../src/dsp/dsp.h"
typedef struct __anonstruct_37 VP8Histogram;
#line 322
struct VP8Residual ;
#line 339 "../../src/dsp/dsp.h"
struct __anonstruct_38 {
   uint32_t w ;
   uint32_t xm ;
   uint32_t ym ;
   uint32_t xxm ;
   uint32_t xym ;
   uint32_t yym ;
};
#line 343 "../../src/dsp/dsp.h"
typedef struct __anonstruct_38 VP8DistoStats;
#line 390 "../../src/dsp/dsp.h"
typedef void (*VP8PredFunc)(uint8_t * );
#line 446 "../../src/dsp/dsp.h"
typedef void (*WebPUpsampleLinePairFunc)(uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                         uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                         int  );
#line 460 "../../src/dsp/dsp.h"
typedef void (*WebPSamplerRowFunc)(uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                   int  );
#line 478 "../../src/dsp/dsp.h"
typedef void (*WebPYUV444Converter)(uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                    int  );
#line 532
struct WebPRescaler ;
#line 650
enum __anonenum__39 {
    WEBP_FILTER_NONE = 0,
    WEBP_FILTER_HORIZONTAL = 1,
    WEBP_FILTER_VERTICAL = 2,
    WEBP_FILTER_GRADIENT = 3,
    WEBP_FILTER_LAST = 4,
    WEBP_FILTER_BEST = 5,
    WEBP_FILTER_FAST = 6
} ;
#line 658 "../../src/dsp/dsp.h"
typedef enum __anonenum__39 WEBP_FILTER_TYPE;
#line 660 "../../src/dsp/dsp.h"
typedef void (*WebPFilterFunc)(uint8_t * , int  , int  , int  , uint8_t * );
#line 664 "../../src/dsp/dsp.h"
typedef void (*WebPUnfilterFunc)(uint8_t * , uint8_t * , uint8_t * , int  );
#line 28 "../../src/utils/color_cache_utils.h"
struct __anonstruct_40 {
   uint32_t *colors_ ;
   int hash_shift_ ;
   int hash_bits_ ;
};
#line 32 "../../src/utils/color_cache_utils.h"
typedef struct __anonstruct_40 VP8LColorCache;
#line 28 "../../src/utils/thread_utils.h"
enum __anonenum__44 {
    NOT_OK = 0,
    OK = 1,
    WORK = 2
} ;
#line 32 "../../src/utils/thread_utils.h"
typedef enum __anonenum__44 WebPWorkerStatus;
#line 39 "../../src/utils/thread_utils.h"
struct __anonstruct_45 {
   void *impl_ ;
   WebPWorkerStatus status_ ;
   int (*hook)(void * , void * ) ;
   void *data1 ;
   void *data2 ;
   int had_error ;
};
#line 46 "../../src/utils/thread_utils.h"
typedef struct __anonstruct_45 WebPWorker;
#line 50 "../../src/utils/thread_utils.h"
struct __anonstruct_46 {
   void (*Init)(WebPWorker * const   ) ;
   int (*Reset)(WebPWorker * const   ) ;
   int (*Sync)(WebPWorker * const   ) ;
   void (*Launch)(WebPWorker * const   ) ;
   void (*Execute)(WebPWorker * const   ) ;
   void (*End)(WebPWorker * const   ) ;
};
#line 71 "../../src/utils/thread_utils.h"
typedef struct __anonstruct_46 WebPWorkerInterface;
#line 53 "/root/patron-new/new_3/src/utils/thread_utils.c"
struct __anonstruct_76 {
   pthread_mutex_t mutex_ ;
   pthread_cond_t condition_ ;
   pthread_t thread_ ;
};
#line 57 "/root/patron-new/new_3/src/utils/thread_utils.c"
typedef struct __anonstruct_76 WebPWorkerImpl;
#line 29 "../../src/utils/rescaler_utils.h"
typedef uint32_t rescaler_t;
#line 30 "../../src/utils/rescaler_utils.h"
typedef struct WebPRescaler WebPRescaler;
#line 31 "../../src/utils/rescaler_utils.h"
struct WebPRescaler {
   int x_expand ;
   int y_expand ;
   int num_channels ;
   uint32_t fx_scale ;
   uint32_t fy_scale ;
   uint32_t fxy_scale ;
   int y_accum ;
   int y_add ;
   int y_sub ;
   int x_add ;
   int x_sub ;
   int src_width ;
   int src_height ;
   int dst_width ;
   int dst_height ;
   int src_y ;
   int dst_y ;
   uint8_t *dst ;
   int dst_stride ;
   rescaler_t *irow ;
   rescaler_t *frow ;
};
#line 27 "../../src/utils/random_utils.h"
struct __anonenum__44 {
   int index1_ ;
   int index2_ ;
   uint32_t tab_[55] ;
   int amp_ ;
};
#line 31 "../../src/utils/random_utils.h"
typedef struct __anonenum__44 VP8Random;
#line 45 "/root/patron-new/new_3/src/utils/quant_levels_dec_utils.c"
struct __anonstruct_127 {
   int width_ ;
   int height_ ;
   int stride_ ;
   int row_ ;
   uint8_t *src_ ;
   uint8_t *dst_ ;
   int radius_ ;
   int scale_ ;
   void *mem_ ;
   uint16_t *start_ ;
   uint16_t *cur_ ;
   uint16_t *end_ ;
   uint16_t *top_ ;
   uint16_t *average_ ;
   int num_levels_ ;
   int min_ ;
   int max_ ;
   int min_level_dist_ ;
   int16_t *correction_ ;
};
#line 70 "/root/patron-new/new_3/src/utils/quant_levels_dec_utils.c"
typedef struct __anonstruct_127 SmoothParams;
#line 33 "../../src/utils/huffman_utils.h"
struct __anonstruct_131 {
   uint8_t bits ;
   uint16_t value ;
};
#line 36 "../../src/utils/huffman_utils.h"
typedef struct __anonstruct_131 HuffmanCode;
#line 39 "../../src/utils/huffman_utils.h"
struct __anonstruct_132 {
   int bits ;
   uint32_t value ;
};
#line 44 "../../src/utils/huffman_utils.h"
typedef struct __anonstruct_132 HuffmanCode32;
#line 56
struct HTreeGroup ;
#line 56 "../../src/utils/huffman_utils.h"
typedef struct HTreeGroup HTreeGroup;
#line 57 "../../src/utils/huffman_utils.h"
struct HTreeGroup {
   HuffmanCode *htrees[5] ;
   int is_trivial_literal ;
   uint32_t literal_arb ;
   int is_trivial_code ;
   int use_packed_table ;
   HuffmanCode32 packed_table[64] ;
};
#line 24 "../../src/utils/huffman_encode_utils.h"
struct __anonstruct_150 {
   uint8_t code ;
   uint8_t extra_bits ;
};
#line 27 "../../src/utils/huffman_encode_utils.h"
typedef struct __anonstruct_150 HuffmanTreeToken;
#line 30 "../../src/utils/huffman_encode_utils.h"
struct __anonstruct_151 {
   int num_symbols ;
   uint8_t *code_lengths ;
   uint16_t *codes ;
};
#line 34 "../../src/utils/huffman_encode_utils.h"
typedef struct __anonstruct_151 HuffmanTreeCode;
#line 37 "../../src/utils/huffman_encode_utils.h"
struct __anonstruct_152 {
   uint32_t total_count_ ;
   int value_ ;
   int pool_index_left_ ;
   int pool_index_right_ ;
};
#line 42 "../../src/utils/huffman_encode_utils.h"
typedef struct __anonstruct_152 HuffmanTree;
#line 26 "../../src/utils/bit_writer_utils.h"
struct VP8BitWriter ;
#line 26 "../../src/utils/bit_writer_utils.h"
typedef struct VP8BitWriter VP8BitWriter;
#line 27 "../../src/utils/bit_writer_utils.h"
struct VP8BitWriter {
   int32_t range_ ;
   int32_t value_ ;
   int run_ ;
   int nb_bits_ ;
   uint8_t *buf_ ;
   size_t pos_ ;
   size_t max_pos_ ;
   int error_ ;
};
#line 74 "../../src/utils/bit_writer_utils.h"
typedef uint64_t vp8l_atype_t;
#line 75 "../../src/utils/bit_writer_utils.h"
typedef uint32_t vp8l_wtype_t;
#line 89 "../../src/utils/bit_writer_utils.h"
struct __anonstruct_228 {
   vp8l_atype_t bits_ ;
   int used_ ;
   uint8_t *buf_ ;
   uint8_t *cur_ ;
   uint8_t *end_ ;
   int error_ ;
};
#line 101 "../../src/utils/bit_writer_utils.h"
typedef struct __anonstruct_228 VP8LBitWriter;
#line 81 "../../src/utils/bit_reader_utils.h"
typedef uint64_t bit_t;
#line 86 "../../src/utils/bit_reader_utils.h"
typedef uint32_t range_t;
#line 91
struct VP8BitReader ;
#line 91 "../../src/utils/bit_reader_utils.h"
typedef struct VP8BitReader VP8BitReader;
#line 92 "../../src/utils/bit_reader_utils.h"
struct VP8BitReader {
   bit_t value_ ;
   range_t range_ ;
   int bits_ ;
   uint8_t *buf_ ;
   uint8_t *buf_end_ ;
   uint8_t *buf_max_ ;
   int eof_ ;
};
#line 138 "../../src/utils/bit_reader_utils.h"
typedef uint64_t vp8l_val_t;
#line 140 "../../src/utils/bit_reader_utils.h"
struct __anonstruct_274 {
   vp8l_val_t val_ ;
   uint8_t *buf_ ;
   size_t len_ ;
   size_t pos_ ;
   int bit_pos_ ;
   int eos_ ;
};
#line 147 "../../src/utils/bit_reader_utils.h"
typedef struct __anonstruct_274 VP8LBitReader;
#line 38 "../../src/utils/bit_reader_inl_utils.h"
typedef uint64_t lbit_t;
#line 42 "../../src/enc/vp8i_enc.h"
enum __anonenum__302 {
    RD_OPT_NONE = 0,
    RD_OPT_BASIC = 1,
    RD_OPT_TRELLIS = 2,
    RD_OPT_TRELLIS_ALL = 3
} ;
#line 47 "../../src/enc/vp8i_enc.h"
typedef enum __anonenum__302 VP8RDLevel;
#line 107 "../../src/enc/vp8i_enc.h"
typedef int64_t score_t;
#line 129 "../../src/enc/vp8i_enc.h"
typedef uint32_t proba_t;
#line 130 "../../src/enc/vp8i_enc.h"
typedef uint8_t ProbaArray[3][11];
#line 131 "../../src/enc/vp8i_enc.h"
typedef proba_t StatsArray[3][11];
#line 132 "../../src/enc/vp8i_enc.h"
typedef uint16_t CostArray[3][68];
#line 133 "../../src/enc/vp8i_enc.h"
typedef uint16_t *(*CostArrayPtr)[3];
#line 134 "../../src/enc/vp8i_enc.h"
typedef uint16_t *CostArrayMap[16][3];
#line 135 "../../src/enc/vp8i_enc.h"
typedef double LFStats[4][64];
#line 137
struct VP8Encoder ;
#line 137 "../../src/enc/vp8i_enc.h"
typedef struct VP8Encoder VP8Encoder;
#line 140 "../../src/enc/vp8i_enc.h"
struct __anonstruct_303 {
   int num_segments_ ;
   int update_map_ ;
   int size_ ;
};
#line 145 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_303 VP8EncSegmentHeader;
#line 148 "../../src/enc/vp8i_enc.h"
struct __anonstruct_304 {
   uint8_t segments_[3] ;
   uint8_t skip_proba_ ;
   ProbaArray coeffs_[4][8] ;
   StatsArray stats_[4][8] ;
   CostArray level_cost_[4][8] ;
   CostArrayMap remapped_costs_[4] ;
   int dirty_ ;
   int use_skip_proba_ ;
   int nb_skip_ ;
};
#line 158 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_304 VP8EncProba;
#line 162 "../../src/enc/vp8i_enc.h"
struct __anonstruct_305 {
   int simple_ ;
   int level_ ;
   int sharpness_ ;
   int i4x4_lf_delta_ ;
};
#line 167 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_305 VP8EncFilterHeader;
#line 172 "../../src/enc/vp8i_enc.h"
struct __anonstruct_306 {
   unsigned int type_ ;
   unsigned int uv_mode_ ;
   unsigned int skip_ ;
   unsigned int segment_ ;
   uint8_t alpha_ ;
};
#line 179 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_306 VP8MBInfo;
#line 181 "../../src/enc/vp8i_enc.h"
struct VP8Matrix {
   uint16_t q_[16] ;
   uint16_t iq_[16] ;
   uint32_t bias_[16] ;
   uint32_t zthresh_[16] ;
   uint16_t sharpen_[16] ;
};
#line 187 "../../src/enc/vp8i_enc.h"
typedef struct VP8Matrix VP8Matrix;
#line 189 "../../src/enc/vp8i_enc.h"
struct __anonstruct_307 {
   VP8Matrix y1_ ;
   VP8Matrix y2_ ;
   VP8Matrix uv_ ;
   int alpha_ ;
   int beta_ ;
   int quant_ ;
   int fstrength_ ;
   int max_edge_ ;
   int min_disto_ ;
   int lambda_i16_ ;
   int lambda_i4_ ;
   int lambda_uv_ ;
   int lambda_mode_ ;
   int lambda_trellis_ ;
   int tlambda_ ;
   int lambda_trellis_i16_ ;
   int lambda_trellis_i4_ ;
   int lambda_trellis_uv_ ;
   score_t i4_penalty_ ;
};
#line 205 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_307 VP8SegmentInfo;
#line 207 "../../src/enc/vp8i_enc.h"
typedef int8_t DError[2][2];
#line 211 "../../src/enc/vp8i_enc.h"
struct __anonstruct_308 {
   score_t D ;
   score_t SD ;
   score_t H ;
   score_t R ;
   score_t score ;
   int16_t y_dc_levels[16] ;
   int16_t y_ac_levels[16][16] ;
   int16_t uv_levels[8][16] ;
   int mode_i16 ;
   uint8_t modes_i4[16] ;
   int mode_uv ;
   uint32_t nz ;
   int8_t derr[2][3] ;
};
#line 222 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_308 VP8ModeScore;
#line 226 "../../src/enc/vp8i_enc.h"
struct __anonstruct_309 {
   int x_ ;
   int y_ ;
   uint8_t *yuv_in_ ;
   uint8_t *yuv_out_ ;
   uint8_t *yuv_out2_ ;
   uint8_t *yuv_p_ ;
   VP8Encoder *enc_ ;
   VP8MBInfo *mb_ ;
   VP8BitWriter *bw_ ;
   uint8_t *preds_ ;
   uint32_t *nz_ ;
   uint8_t i4_boundary_[37] ;
   uint8_t *i4_top_ ;
   int i4_ ;
   int top_nz_[9] ;
   int left_nz_[9] ;
   uint64_t bit_count_[4][3] ;
   uint64_t luma_bits_ ;
   uint64_t uv_bits_ ;
   LFStats *lf_stats_ ;
   int do_trellis_ ;
   int count_down_ ;
   int count_down0_ ;
   int percent0_ ;
   DError left_derr_ ;
   DError *top_derr_ ;
   uint8_t *y_left_ ;
   uint8_t *u_left_ ;
   uint8_t *v_left_ ;
   uint8_t *y_top_ ;
   uint8_t *uv_top_ ;
   uint8_t yuv_left_mem_[88] ;
   uint8_t yuv_mem_[3359] ;
};
#line 265 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_309 VP8EncIterator;
#line 310
struct VP8Tokens ;
#line 310 "../../src/enc/vp8i_enc.h"
typedef struct VP8Tokens VP8Tokens;
#line 312 "../../src/enc/vp8i_enc.h"
struct __anonstruct_310 {
   VP8Tokens *pages_ ;
   VP8Tokens **last_page_ ;
   uint16_t *tokens_ ;
   int left_ ;
   int page_size_ ;
   int error_ ;
};
#line 321 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_310 VP8TBuffer;
#line 346 "../../src/enc/vp8i_enc.h"
struct VP8Encoder {
   WebPConfig *config_ ;
   WebPPicture *pic_ ;
   VP8EncFilterHeader filter_hdr_ ;
   VP8EncSegmentHeader segment_hdr_ ;
   int profile_ ;
   int mb_w_ ;
   int mb_h_ ;
   int preds_w_ ;
   int num_parts_ ;
   VP8BitWriter bw_ ;
   VP8BitWriter parts_[8] ;
   VP8TBuffer tokens_ ;
   int percent_ ;
   int has_alpha_ ;
   uint8_t *alpha_data_ ;
   uint32_t alpha_data_size_ ;
   WebPWorker alpha_worker_ ;
   VP8SegmentInfo dqm_[4] ;
   int base_quant_ ;
   int alpha_ ;
   int uv_alpha_ ;
   int dq_y1_dc_ ;
   int dq_y2_dc_ ;
   int dq_y2_ac_ ;
   int dq_uv_dc_ ;
   int dq_uv_ac_ ;
   VP8EncProba proba_ ;
   uint64_t sse_[4] ;
   uint64_t sse_count_ ;
   int coded_size_ ;
   int residual_bytes_[3][4] ;
   int block_count_[3] ;
   int method_ ;
   VP8RDLevel rd_opt_level_ ;
   int max_i4_header_bits_ ;
   int mb_header_limit_ ;
   int thread_level_ ;
   int do_search_ ;
   int use_tokens_ ;
   VP8MBInfo *mb_info_ ;
   uint8_t *preds_ ;
   uint32_t *nz_ ;
   uint8_t *y_top_ ;
   uint8_t *uv_top_ ;
   LFStats *lf_stats_ ;
   DError *top_derr_ ;
};
#line 27 "../../src/enc/cost_enc.h"
typedef struct VP8Residual VP8Residual;
#line 28 "../../src/enc/cost_enc.h"
struct VP8Residual {
   int first ;
   int last ;
   int16_t *coeffs ;
   int coeff_type ;
   ProbaArray *prob ;
   StatsArray *stats ;
   CostArrayPtr costs ;
};
#line 39 "../../src/enc/backward_references_enc.h"
struct __anonstruct_312 {
   uint8_t mode ;
   uint16_t len ;
   uint32_t argb_or_distance ;
};
#line 44 "../../src/enc/backward_references_enc.h"
typedef struct __anonstruct_312 PixOrCopy;
#line 122
struct VP8LHashChain ;
#line 122 "../../src/enc/backward_references_enc.h"
typedef struct VP8LHashChain VP8LHashChain;
#line 123 "../../src/enc/backward_references_enc.h"
struct VP8LHashChain {
   uint32_t *offset_length_ ;
   int size_ ;
};
#line 167
struct PixOrCopyBlock ;
#line 167 "../../src/enc/backward_references_enc.h"
typedef struct PixOrCopyBlock PixOrCopyBlock;
#line 168
struct VP8LBackwardRefs ;
#line 168 "../../src/enc/backward_references_enc.h"
typedef struct VP8LBackwardRefs VP8LBackwardRefs;
#line 171 "../../src/enc/backward_references_enc.h"
struct VP8LBackwardRefs {
   int block_size_ ;
   int error_ ;
   PixOrCopyBlock *refs_ ;
   PixOrCopyBlock **tail_ ;
   PixOrCopyBlock *free_blocks_ ;
   PixOrCopyBlock *last_block_ ;
};
#line 187 "../../src/enc/backward_references_enc.h"
struct __anonstruct_313 {
   PixOrCopy *cur_pos ;
   PixOrCopyBlock *cur_block_ ;
   PixOrCopy *last_pos_ ;
};
#line 193 "../../src/enc/backward_references_enc.h"
typedef struct __anonstruct_313 VP8LRefsCursor;
#line 31 "../../src/enc/histogram_enc.h"
struct __anonstruct_314 {
   uint32_t *literal_ ;
   uint32_t red_[256] ;
   uint32_t blue_[256] ;
   uint32_t alpha_[256] ;
   uint32_t distance_[40] ;
   int palette_code_bits_ ;
   uint32_t trivial_symbol_ ;
   double bit_cost_ ;
   double literal_cost_ ;
   double red_cost_ ;
   double blue_cost_ ;
   uint8_t is_used_[5] ;
};
#line 48 "../../src/enc/histogram_enc.h"
typedef struct __anonstruct_314 VP8LHistogram;
#line 52 "../../src/enc/histogram_enc.h"
struct __anonstruct_315 {
   int size ;
   int max_size ;
   VP8LHistogram **histograms ;
};
#line 56 "../../src/enc/histogram_enc.h"
typedef struct __anonstruct_315 VP8LHistogramSet;
#line 39 "../../src/enc/vp8li_enc.h"
enum __anonenum__316 {
    kEncoderNone = 0,
    kEncoderARGB = 1,
    kEncoderNearLossless = 2,
    kEncoderPalette = 3
} ;
#line 44 "../../src/enc/vp8li_enc.h"
typedef enum __anonenum__316 VP8LEncoderARGBContent;
#line 46 "../../src/enc/vp8li_enc.h"
struct __anonstruct_317 {
   WebPConfig *config_ ;
   WebPPicture *pic_ ;
   uint32_t *argb_ ;
   VP8LEncoderARGBContent argb_content_ ;
   uint32_t *argb_scratch_ ;
   uint32_t *transform_data_ ;
   uint32_t *transform_mem_ ;
   size_t transform_mem_size_ ;
   int current_width_ ;
   int histo_bits_ ;
   int transform_bits_ ;
   int cache_bits_ ;
   int use_cross_color_ ;
   int use_subtract_green_ ;
   int use_predict_ ;
   int use_palette_ ;
   int palette_size_ ;
   uint32_t palette_[256] ;
   uint32_t palette_sorted_[256] ;
   struct VP8LBackwardRefs refs_[4] ;
   VP8LHashChain hash_chain_ ;
};
#line 79 "../../src/enc/vp8li_enc.h"
typedef struct __anonstruct_317 VP8LEncoder;
#line 31 "../../src/dsp/lossless.h"
typedef uint32_t (*VP8LPredictorFunc)(uint32_t  , uint32_t * const   );
#line 50 "../../src/dsp/lossless.h"
typedef void (*VP8LPredictorAddSubFunc)(uint32_t * , uint32_t * , int  , uint32_t * );
#line 60 "../../src/dsp/lossless.h"
struct __anonstruct_359 {
   uint8_t green_to_red_ ;
   uint8_t green_to_blue_ ;
   uint8_t red_to_blue_ ;
};
#line 66 "../../src/dsp/lossless.h"
typedef struct __anonstruct_359 VP8LMultipliers;
#line 72
struct VP8LTransform ;
#line 180 "../../src/dsp/lossless.h"
struct __anonstruct_360 {
   int counts[2] ;
   int streaks[2][2] ;
};
#line 183 "../../src/dsp/lossless.h"
typedef struct __anonstruct_360 VP8LStreaks;
#line 185 "../../src/dsp/lossless.h"
struct __anonstruct_361 {
   double entropy ;
   uint32_t sum ;
   int nonzeros ;
   uint32_t max_val ;
   uint32_t nonzero_code ;
};
#line 191 "../../src/dsp/lossless.h"
typedef struct __anonstruct_361 VP8LBitEntropy;
#line 118 "../../src/dsp/lossless_common.h"
struct __anonstruct_362 {
   int8_t code_ ;
   int8_t extra_bits_ ;
};
#line 121 "../../src/dsp/lossless_common.h"
typedef struct __anonstruct_362 VP8LPrefixCode;
#line 232 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
struct Sum {
   uint8_t index ;
   uint32_t sum ;
};
#line 326
enum __anonenum__366 {
    kDirect = 0,
    kSpatial = 1,
    kSubGreen = 2,
    kSpatialSubGreen = 3,
    kPalette = 4,
    kPaletteAndSpatial = 5,
    kNumEntropyIx = 6
} ;
#line 334 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
typedef enum __anonenum__366 EntropyIx;
#line 336
enum __anonenum__367 {
    kSortedDefault = 0,
    kMinimizeDelta = 1,
    kModifiedZeng = 2,
    kUnusedPalette = 3
} ;
#line 341 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
typedef enum __anonenum__367 PaletteSorting;
#line 551 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
struct __anonstruct_369 {
   int lz77_ ;
   int do_no_cache_ ;
};
#line 554 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
typedef struct __anonstruct_369 CrunchSubConfig;
#line 555 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
struct __anonstruct_370 {
   int entropy_idx_ ;
   PaletteSorting palette_sorting_type_ ;
   CrunchSubConfig sub_configs_[2] ;
   int sub_configs_size_ ;
};
#line 560 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
typedef struct __anonstruct_370 CrunchConfig;
#line 1706 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
struct __anonstruct_371 {
   WebPConfig *config_ ;
   WebPPicture *picture_ ;
   VP8LBitWriter *bw_ ;
   VP8LEncoder *enc_ ;
   int use_cache_ ;
   CrunchConfig crunch_configs_[8] ;
   int num_crunch_configs_ ;
   int red_and_blue_always_zero_ ;
   WebPEncodingError err_ ;
   WebPAuxStats *stats_ ;
};
#line 1717 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
typedef struct __anonstruct_371 StreamEncodeContext;
#line 33 "/root/patron-new/new_3/src/enc/token_enc.c"
typedef uint16_t token_t;
#line 36 "/root/patron-new/new_3/src/enc/token_enc.c"
struct VP8Tokens {
   VP8Tokens *next_ ;
};
#line 29 "../../src/webp/mux_types.h"
struct WebPData ;
#line 29 "../../src/webp/mux_types.h"
typedef struct WebPData WebPData;
#line 44
enum WebPMuxAnimDispose {
    WEBP_MUX_DISPOSE_NONE = 0,
    WEBP_MUX_DISPOSE_BACKGROUND = 1
} ;
#line 47 "../../src/webp/mux_types.h"
typedef enum WebPMuxAnimDispose WebPMuxAnimDispose;
#line 51
enum WebPMuxAnimBlend {
    WEBP_MUX_BLEND = 0,
    WEBP_MUX_NO_BLEND = 1
} ;
#line 54 "../../src/webp/mux_types.h"
typedef enum WebPMuxAnimBlend WebPMuxAnimBlend;
#line 59 "../../src/webp/mux_types.h"
struct WebPData {
   uint8_t *bytes ;
   size_t size ;
};
#line 558 "/root/patron-new/new_3/src/enc/quant_enc.c"
struct __anonstruct_522 {
   int8_t prev ;
   int8_t sign ;
   int16_t level ;
};
#line 562 "/root/patron-new/new_3/src/enc/quant_enc.c"
typedef struct __anonstruct_522 Node;
#line 565 "/root/patron-new/new_3/src/enc/quant_enc.c"
struct __anonstruct_523 {
   score_t score ;
   uint16_t *costs ;
};
#line 568 "/root/patron-new/new_3/src/enc/quant_enc.c"
typedef struct __anonstruct_523 ScoreState;
#line 42 "../../src/dec/vp8_dec.h"
struct VP8Io ;
#line 42 "../../src/dec/vp8_dec.h"
typedef struct VP8Io VP8Io;
#line 47 "../../src/dec/vp8_dec.h"
struct VP8Io {
   int width ;
   int height ;
   int mb_y ;
   int mb_w ;
   int mb_h ;
   uint8_t *y ;
   uint8_t *u ;
   uint8_t *v ;
   int y_stride ;
   int uv_stride ;
   void *opaque ;
   int (*put)(VP8Io * ) ;
   int (*setup)(VP8Io * ) ;
   void (*teardown)(VP8Io * ) ;
   int fancy_upsampling ;
   size_t data_size ;
   uint8_t *data ;
   int bypass_filtering ;
   int use_cropping ;
   int crop_left ;
   int crop_right ;
   int crop_top ;
   int crop_bottom ;
   int use_scaling ;
   int scaled_width ;
   int scaled_height ;
   uint8_t *a ;
};
#line 123
struct VP8Decoder ;
#line 123 "../../src/dec/vp8_dec.h"
typedef struct VP8Decoder VP8Decoder;
#line 167 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
typedef int16_t fixed_t;
#line 168 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
typedef uint16_t fixed_y_t;
#line 478 "/root/patron-new/new_3/src/enc/histogram_enc.c"
struct __anonstruct_779 {
   double literal_max_ ;
   double literal_min_ ;
   double red_max_ ;
   double red_min_ ;
   double blue_max_ ;
   double blue_min_ ;
};
#line 485 "/root/patron-new/new_3/src/enc/histogram_enc.c"
typedef struct __anonstruct_779 DominantCostRange;
#line 731 "/root/patron-new/new_3/src/enc/histogram_enc.c"
struct __anonstruct_780 {
   int idx1 ;
   int idx2 ;
   double cost_diff ;
   double cost_combo ;
};
#line 736 "/root/patron-new/new_3/src/enc/histogram_enc.c"
typedef struct __anonstruct_780 HistogramPair;
#line 738 "/root/patron-new/new_3/src/enc/histogram_enc.c"
struct __anonstruct_781 {
   HistogramPair *queue ;
   int size ;
   int max_size ;
};
#line 742 "/root/patron-new/new_3/src/enc/histogram_enc.c"
typedef struct __anonstruct_781 HistoQueue;
#line 655 "/root/patron-new/new_3/src/enc/histogram_enc.c"
struct __anonstruct_782 {
   int16_t first ;
   uint16_t num_combine_failures ;
};
#line 38 "/root/patron-new/new_3/src/enc/frame_enc.c"
struct __anonstruct_808 {
   int is_first ;
   float dq ;
   float q ;
   float last_q ;
   float qmin ;
   float qmax ;
   double value ;
   double last_value ;
   double target ;
   int do_size_search ;
};
#line 46 "/root/patron-new/new_3/src/enc/frame_enc.c"
typedef struct __anonstruct_808 PassStats;
#line 141 "/root/patron-new/new_3/src/enc/config_enc.c"
struct __anonstruct_809 {
   uint8_t method_ ;
   uint8_t quality_ ;
};
#line 79 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
struct PixOrCopyBlock {
   PixOrCopyBlock *next_ ;
   PixOrCopy *start_ ;
   int size_ ;
};
#line 32 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
struct __anonstruct_876 {
   double alpha_[256] ;
   double red_[256] ;
   double blue_[256] ;
   double distance_[40] ;
   double *literal_ ;
};
#line 38 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
typedef struct __anonstruct_876 CostModel;
#line 163
struct CostInterval ;
#line 163 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
typedef struct CostInterval CostInterval;
#line 164 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
struct CostInterval {
   float cost_ ;
   int start_ ;
   int end_ ;
   int index_ ;
   CostInterval *previous_ ;
   CostInterval *next_ ;
};
#line 174 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
struct __anonstruct_877 {
   double cost_ ;
   int start_ ;
   int end_ ;
};
#line 178 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
typedef struct __anonstruct_877 CostCacheInterval;
#line 185 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
struct __anonstruct_878 {
   CostInterval *head_ ;
   int count_ ;
   CostCacheInterval *cache_intervals_ ;
   size_t cache_intervals_size_ ;
   double cost_cache_[4095] ;
   float *costs_ ;
   uint16_t *dist_array_ ;
   CostInterval intervals_[10] ;
   CostInterval *free_intervals_ ;
   CostInterval *recycled_intervals_ ;
};
#line 200 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
typedef struct __anonstruct_878 CostManager;
#line 368 "/root/patron-new/new_3/src/enc/analysis_enc.c"
struct __anonstruct_879 {
   WebPWorker worker ;
   int alphas[256] ;
   int alpha ;
   int uv_alpha ;
   VP8EncIterator it ;
   int delta_progress ;
};
#line 374 "/root/patron-new/new_3/src/enc/analysis_enc.c"
typedef struct __anonstruct_879 SegmentJob;
#line 102 "/root/patron-new/new_3/src/enc/alpha_enc.c"
struct __anonstruct_887 {
   size_t score ;
   VP8BitWriter bw ;
   WebPAuxStats stats ;
};
#line 106 "/root/patron-new/new_3/src/enc/alpha_enc.c"
typedef struct __anonstruct_887 FilterTrial;
#line 27 "../../src/dec/webpi_dec.h"
struct WebPDecParams ;
#line 27 "../../src/dec/webpi_dec.h"
typedef struct WebPDecParams WebPDecParams;
#line 34 "../../src/dec/webpi_dec.h"
struct WebPDecParams {
   WebPDecBuffer *output ;
   uint8_t *tmp_y ;
   uint8_t *tmp_u ;
   uint8_t *tmp_v ;
   int last_y ;
   WebPDecoderOptions *options ;
   WebPRescaler *scaler_y ;
   WebPRescaler *scaler_u ;
   WebPRescaler *scaler_v ;
   WebPRescaler *scaler_a ;
   void *memory ;
   int (*emit)(VP8Io * const   , WebPDecParams * const   ) ;
   int (*emit_alpha)(VP8Io * const   , WebPDecParams * const   , int  ) ;
   int (*emit_alpha_row)(WebPDecParams * const   , int  , int  ) ;
};
#line 57 "../../src/dec/webpi_dec.h"
struct __anonstruct_904 {
   uint8_t *data ;
   size_t data_size ;
   int have_all_data ;
   size_t offset ;
   uint8_t *alpha_data ;
   size_t alpha_data_size ;
   size_t compressed_size ;
   size_t riff_size ;
   int is_lossless ;
};
#line 67 "../../src/dec/webpi_dec.h"
typedef struct __anonstruct_904 WebPHeaderStructure;
#line 28 "../../src/dec/vp8li_dec.h"
enum __anonenum__910 {
    READ_DATA = 0,
    READ_HDR = 1,
    READ_DIM = 2
} ;
#line 32 "../../src/dec/vp8li_dec.h"
typedef enum __anonenum__910 VP8LDecodeState;
#line 34 "../../src/dec/vp8li_dec.h"
typedef struct VP8LTransform VP8LTransform;
#line 35 "../../src/dec/vp8li_dec.h"
struct VP8LTransform {
   VP8LImageTransformType type_ ;
   int bits_ ;
   int xsize_ ;
   int ysize_ ;
   uint32_t *data_ ;
};
#line 43 "../../src/dec/vp8li_dec.h"
struct __anonstruct_911 {
   int color_cache_size_ ;
   VP8LColorCache color_cache_ ;
   VP8LColorCache saved_color_cache_ ;
   int huffman_mask_ ;
   int huffman_subsample_bits_ ;
   int huffman_xsize_ ;
   uint32_t *huffman_image_ ;
   int num_htree_groups_ ;
   HTreeGroup *htree_groups_ ;
   HuffmanCode *huffman_tables_ ;
};
#line 55 "../../src/dec/vp8li_dec.h"
typedef struct __anonstruct_911 VP8LMetadata;
#line 57
struct VP8LDecoder ;
#line 57 "../../src/dec/vp8li_dec.h"
typedef struct VP8LDecoder VP8LDecoder;
#line 58 "../../src/dec/vp8li_dec.h"
struct VP8LDecoder {
   VP8StatusCode status_ ;
   VP8LDecodeState state_ ;
   VP8Io *io_ ;
   WebPDecBuffer *output_ ;
   uint32_t *pixels_ ;
   uint32_t *argb_cache_ ;
   VP8LBitReader br_ ;
   int incremental_ ;
   VP8LBitReader saved_br_ ;
   int saved_last_pixel_ ;
   int width_ ;
   int height_ ;
   int last_row_ ;
   int last_pixel_ ;
   int last_out_row_ ;
   VP8LMetadata hdr_ ;
   int next_transform_ ;
   VP8LTransform transforms_[4] ;
   uint32_t transforms_seen_ ;
   uint8_t *rescaler_memory ;
   WebPRescaler *rescaler ;
};
#line 96
struct ALPHDecoder ;
#line 423 "/root/patron-new/new_3/src/dsp/lossless.c"
union __anonunion_921 {
   uint16_t w ;
   uint8_t b[2] ;
};
#line 70 "../../src/dec/vp8i_dec.h"
struct __anonstruct_949 {
   uint8_t key_frame_ ;
   uint8_t profile_ ;
   uint8_t show_ ;
   uint32_t partition_length_ ;
};
#line 75 "../../src/dec/vp8i_dec.h"
typedef struct __anonstruct_949 VP8FrameHeader;
#line 77 "../../src/dec/vp8i_dec.h"
struct __anonstruct_950 {
   uint16_t width_ ;
   uint16_t height_ ;
   uint8_t xscale_ ;
   uint8_t yscale_ ;
   uint8_t colorspace_ ;
   uint8_t clamp_type_ ;
};
#line 84 "../../src/dec/vp8i_dec.h"
typedef struct __anonstruct_950 VP8PictureHeader;
#line 87 "../../src/dec/vp8i_dec.h"
struct __anonstruct_951 {
   int use_segment_ ;
   int update_map_ ;
   int absolute_delta_ ;
   int8_t quantizer_[4] ;
   int8_t filter_strength_[4] ;
};
#line 93 "../../src/dec/vp8i_dec.h"
typedef struct __anonstruct_951 VP8SegmentHeader;
#line 96 "../../src/dec/vp8i_dec.h"
typedef uint8_t VP8ProbaArray[11];
#line 98 "../../src/dec/vp8i_dec.h"
struct __anonstruct_952 {
   VP8ProbaArray probas_[3] ;
};
#line 100 "../../src/dec/vp8i_dec.h"
typedef struct __anonstruct_952 VP8BandProbas;
#line 103 "../../src/dec/vp8i_dec.h"
struct __anonstruct_953 {
   uint8_t segments_[3] ;
   VP8BandProbas bands_[4][8] ;
   VP8BandProbas *bands_ptr_[4][17] ;
};
#line 108 "../../src/dec/vp8i_dec.h"
typedef struct __anonstruct_953 VP8Proba;
#line 111 "../../src/dec/vp8i_dec.h"
struct __anonstruct_954 {
   int simple_ ;
   int level_ ;
   int sharpness_ ;
   int use_lf_delta_ ;
   int ref_lf_delta_[4] ;
   int mode_lf_delta_[4] ;
};
#line 118 "../../src/dec/vp8i_dec.h"
typedef struct __anonstruct_954 VP8FilterHeader;
#line 123 "../../src/dec/vp8i_dec.h"
struct __anonstruct_955 {
   uint8_t f_limit_ ;
   uint8_t f_ilevel_ ;
   uint8_t f_inner_ ;
   uint8_t hev_thresh_ ;
};
#line 128 "../../src/dec/vp8i_dec.h"
typedef struct __anonstruct_955 VP8FInfo;
#line 130 "../../src/dec/vp8i_dec.h"
struct __anonstruct_956 {
   uint8_t nz_ ;
   uint8_t nz_dc_ ;
};
#line 133 "../../src/dec/vp8i_dec.h"
typedef struct __anonstruct_956 VP8MB;
#line 136 "../../src/dec/vp8i_dec.h"
typedef int quant_t[2];
#line 137 "../../src/dec/vp8i_dec.h"
struct __anonstruct_957 {
   quant_t y1_mat_ ;
   quant_t y2_mat_ ;
   quant_t uv_mat_ ;
   int uv_quant_ ;
   int dither_ ;
};
#line 142 "../../src/dec/vp8i_dec.h"
typedef struct __anonstruct_957 VP8QuantMatrix;
#line 145 "../../src/dec/vp8i_dec.h"
struct __anonstruct_958 {
   int16_t coeffs_[384] ;
   uint8_t is_i4x4_ ;
   uint8_t imodes_[16] ;
   uint8_t uvmode_ ;
   uint32_t non_zero_y_ ;
   uint32_t non_zero_uv_ ;
   uint8_t dither_ ;
   uint8_t skip_ ;
   uint8_t segment_ ;
};
#line 162 "../../src/dec/vp8i_dec.h"
typedef struct __anonstruct_958 VP8MBData;
#line 165 "../../src/dec/vp8i_dec.h"
struct __anonstruct_959 {
   int id_ ;
   int mb_y_ ;
   int filter_row_ ;
   VP8FInfo *f_info_ ;
   VP8MBData *mb_data_ ;
   VP8Io io_ ;
};
#line 172 "../../src/dec/vp8i_dec.h"
typedef struct __anonstruct_959 VP8ThreadContext;
#line 175 "../../src/dec/vp8i_dec.h"
struct __anonstruct_960 {
   uint8_t y[16] ;
   uint8_t u[8] ;
   uint8_t v[8] ;
};
#line 177 "../../src/dec/vp8i_dec.h"
typedef struct __anonstruct_960 VP8TopSamples;
#line 182 "../../src/dec/vp8i_dec.h"
struct VP8Decoder {
   VP8StatusCode status_ ;
   int ready_ ;
   char const   *error_msg_ ;
   VP8BitReader br_ ;
   VP8FrameHeader frm_hdr_ ;
   VP8PictureHeader pic_hdr_ ;
   VP8FilterHeader filter_hdr_ ;
   VP8SegmentHeader segment_hdr_ ;
   WebPWorker worker_ ;
   int mt_method_ ;
   int cache_id_ ;
   int num_caches_ ;
   VP8ThreadContext thread_ctx_ ;
   int mb_w_ ;
   int mb_h_ ;
   int tl_mb_x_ ;
   int tl_mb_y_ ;
   int br_mb_x_ ;
   int br_mb_y_ ;
   uint32_t num_parts_minus_one_ ;
   VP8BitReader parts_[8] ;
   int dither_ ;
   VP8Random dithering_rg_ ;
   VP8QuantMatrix dqm_[4] ;
   VP8Proba proba_ ;
   int use_skip_proba_ ;
   uint8_t skip_p_ ;
   uint8_t *intra_t_ ;
   uint8_t intra_l_[4] ;
   VP8TopSamples *yuv_t_ ;
   VP8MB *mb_info_ ;
   VP8FInfo *f_info_ ;
   uint8_t *yuv_b_ ;
   uint8_t *cache_y_ ;
   uint8_t *cache_u_ ;
   uint8_t *cache_v_ ;
   int cache_y_stride_ ;
   int cache_uv_stride_ ;
   void *mem_ ;
   size_t mem_size_ ;
   int mb_x_ ;
   int mb_y_ ;
   VP8MBData *mb_data_ ;
   int filter_type_ ;
   VP8FInfo fstrengths_[4][2] ;
   struct ALPHDecoder *alph_dec_ ;
   uint8_t *alpha_data_ ;
   size_t alpha_data_size_ ;
   int is_alpha_decoded_ ;
   uint8_t *alpha_plane_mem_ ;
   uint8_t *alpha_plane_ ;
   uint8_t *alpha_prev_line_ ;
   int alpha_dithering_ ;
};
#line 26 "../../src/dec/alphai_dec.h"
typedef struct ALPHDecoder ALPHDecoder;
#line 27 "../../src/dec/alphai_dec.h"
struct ALPHDecoder {
   int width_ ;
   int height_ ;
   int method_ ;
   WEBP_FILTER_TYPE filter_ ;
   int pre_processing_ ;
   struct VP8LDecoder *vp8l_dec_ ;
   VP8Io io_ ;
   int use_8b_decode_ ;
   uint8_t *output_ ;
   uint8_t *prev_line_ ;
};
#line 35 "/root/patron-new/new_3/src/dec/idec_dec.c"
enum __anonenum__1153 {
    STATE_WEBP_HEADER = 0,
    STATE_VP8_HEADER = 1,
    STATE_VP8_PARTS0 = 2,
    STATE_VP8_DATA = 3,
    STATE_VP8L_HEADER = 4,
    STATE_VP8L_DATA = 5,
    STATE_DONE = 6,
    STATE_ERROR = 7
} ;
#line 44 "/root/patron-new/new_3/src/dec/idec_dec.c"
typedef enum __anonenum__1153 DecState;
#line 47
enum __anonenum__1154 {
    MEM_MODE_NONE = 0,
    MEM_MODE_APPEND = 1,
    MEM_MODE_MAP = 2
} ;
#line 51 "/root/patron-new/new_3/src/dec/idec_dec.c"
typedef enum __anonenum__1154 MemBufferMode;
#line 54 "/root/patron-new/new_3/src/dec/idec_dec.c"
struct __anonstruct_1155 {
   MemBufferMode mode_ ;
   size_t start_ ;
   size_t end_ ;
   size_t buf_size_ ;
   uint8_t *buf_ ;
   size_t part0_size_ ;
   uint8_t *part0_buf_ ;
};
#line 63 "/root/patron-new/new_3/src/dec/idec_dec.c"
typedef struct __anonstruct_1155 MemBuffer;
#line 65 "/root/patron-new/new_3/src/dec/idec_dec.c"
struct WebPIDecoder {
   DecState state_ ;
   WebPDecParams params_ ;
   int is_lossless_ ;
   void *dec_ ;
   VP8Io io_ ;
   MemBuffer mem_ ;
   WebPDecBuffer output_ ;
   WebPDecBuffer *final_output_ ;
   size_t chunk_size_ ;
   int last_mb_y_ ;
};
#line 82 "/root/patron-new/new_3/src/dec/idec_dec.c"
struct __anonstruct_1156 {
   VP8MB left_ ;
   VP8MB info_ ;
   VP8BitReader token_br_ ;
};
#line 86 "/root/patron-new/new_3/src/dec/idec_dec.c"
typedef struct __anonstruct_1156 MBContext;
#line 64 "../../src/webp/demux.h"
struct WebPDemuxer ;
#line 64 "../../src/webp/demux.h"
typedef struct WebPDemuxer WebPDemuxer;
#line 65
struct WebPIterator ;
#line 65 "../../src/webp/demux.h"
typedef struct WebPIterator WebPIterator;
#line 66
struct WebPChunkIterator ;
#line 66 "../../src/webp/demux.h"
typedef struct WebPChunkIterator WebPChunkIterator;
#line 67
struct WebPAnimInfo ;
#line 67 "../../src/webp/demux.h"
typedef struct WebPAnimInfo WebPAnimInfo;
#line 68
struct WebPAnimDecoderOptions ;
#line 68 "../../src/webp/demux.h"
typedef struct WebPAnimDecoderOptions WebPAnimDecoderOptions;
#line 79
enum WebPDemuxState {
    WEBP_DEMUX_PARSE_ERROR = -1,
    WEBP_DEMUX_PARSING_HEADER = 0,
    WEBP_DEMUX_PARSED_HEADER = 1,
    WEBP_DEMUX_DONE = 2
} ;
#line 85 "../../src/webp/demux.h"
typedef enum WebPDemuxState WebPDemuxState;
#line 117
enum WebPFormatFeature {
    WEBP_FF_FORMAT_FLAGS = 0,
    WEBP_FF_CANVAS_WIDTH = 1,
    WEBP_FF_CANVAS_HEIGHT = 2,
    WEBP_FF_LOOP_COUNT = 3,
    WEBP_FF_BACKGROUND_COLOR = 4,
    WEBP_FF_FRAME_COUNT = 5
} ;
#line 128 "../../src/webp/demux.h"
typedef enum WebPFormatFeature WebPFormatFeature;
#line 143 "../../src/webp/demux.h"
struct WebPIterator {
   int frame_num ;
   int num_frames ;
   int x_offset ;
   int y_offset ;
   int width ;
   int height ;
   int duration ;
   WebPMuxAnimDispose dispose_method ;
   int complete ;
   WebPData fragment ;
   int has_alpha ;
   WebPMuxAnimBlend blend_method ;
   uint32_t pad[2] ;
   void *private_ ;
};
#line 185 "../../src/webp/demux.h"
struct WebPChunkIterator {
   int chunk_num ;
   int num_chunks ;
   WebPData chunk ;
   uint32_t pad[6] ;
   void *private_ ;
};
#line 248
struct WebPAnimDecoder ;
#line 248 "../../src/webp/demux.h"
typedef struct WebPAnimDecoder WebPAnimDecoder;
#line 251 "../../src/webp/demux.h"
struct WebPAnimDecoderOptions {
   WEBP_CSP_MODE color_mode ;
   int use_threads ;
   uint32_t padding[7] ;
};
#line 294 "../../src/webp/demux.h"
struct WebPAnimInfo {
   uint32_t canvas_width ;
   uint32_t canvas_height ;
   uint32_t loop_count ;
   uint32_t bgcolor ;
   uint32_t frame_count ;
   uint32_t pad[4] ;
};
#line 30 "/root/patron-new/new_3/src/demux/demux.c"
struct __anonstruct_1159 {
   size_t start_ ;
   size_t end_ ;
   size_t riff_end_ ;
   size_t buf_size_ ;
   uint8_t *buf_ ;
};
#line 36 "/root/patron-new/new_3/src/demux/demux.c"
typedef struct __anonstruct_1159 MemBuffer___0;
#line 38 "/root/patron-new/new_3/src/demux/demux.c"
struct __anonstruct_1160 {
   size_t offset_ ;
   size_t size_ ;
};
#line 41 "/root/patron-new/new_3/src/demux/demux.c"
typedef struct __anonstruct_1160 ChunkData;
#line 43 "/root/patron-new/new_3/src/demux/demux.c"
struct Frame {
   int x_offset_ ;
   int y_offset_ ;
   int width_ ;
   int height_ ;
   int has_alpha_ ;
   int duration_ ;
   WebPMuxAnimDispose dispose_method_ ;
   WebPMuxAnimBlend blend_method_ ;
   int frame_num_ ;
   int complete_ ;
   ChunkData img_components_[2] ;
   struct Frame *next_ ;
};
#line 54 "/root/patron-new/new_3/src/demux/demux.c"
typedef struct Frame Frame;
#line 56 "/root/patron-new/new_3/src/demux/demux.c"
struct Chunk {
   ChunkData data_ ;
   struct Chunk *next_ ;
};
#line 59 "/root/patron-new/new_3/src/demux/demux.c"
typedef struct Chunk Chunk;
#line 61 "/root/patron-new/new_3/src/demux/demux.c"
struct WebPDemuxer {
   MemBuffer___0 mem_ ;
   WebPDemuxState state_ ;
   int is_ext_format_ ;
   uint32_t feature_flags_ ;
   int canvas_width_ ;
   int canvas_height_ ;
   int loop_count_ ;
   uint32_t bgcolor_ ;
   int num_frames_ ;
   Frame *frames_ ;
   Frame **frames_tail_ ;
   Chunk *chunks_ ;
   Chunk **chunks_tail_ ;
};
#line 76
enum __anonenum__1161 {
    PARSE_OK = 0,
    PARSE_NEED_MORE_DATA = 1,
    PARSE_ERROR = 2
} ;
#line 80 "/root/patron-new/new_3/src/demux/demux.c"
typedef enum __anonenum__1161 ParseStatus;
#line 82 "/root/patron-new/new_3/src/demux/demux.c"
struct ChunkParser {
   uint8_t id[4] ;
   ParseStatus (*parse)(WebPDemuxer * const   ) ;
   int (*valid)(WebPDemuxer * const   ) ;
};
#line 86 "/root/patron-new/new_3/src/demux/demux.c"
typedef struct ChunkParser ChunkParser;
#line 32 "/root/patron-new/new_3/src/demux/anim_decode.c"
struct WebPAnimDecoder {
   WebPDemuxer *demux_ ;
   WebPDecoderConfig config_ ;
   void (*blend_func_)(uint32_t * const   , uint32_t * const   , int  ) ;
   WebPAnimInfo info_ ;
   uint8_t *curr_frame_ ;
   uint8_t *prev_frame_disposed_ ;
   int prev_frame_timestamp_ ;
   WebPIterator prev_iter_ ;
   int prev_frame_was_keyframe_ ;
   int next_frame_ ;
};
#line 19 "/root/patron-new/new_3/imageio/./wicdec.h"
struct Metadata ;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 22 "/root/patron-new/new_3/imageio/./metadata.h"
struct MetadataPayload {
   uint8_t *bytes ;
   size_t size ;
};
#line 25 "/root/patron-new/new_3/imageio/./metadata.h"
typedef struct MetadataPayload MetadataPayload;
#line 27 "/root/patron-new/new_3/imageio/./metadata.h"
struct Metadata {
   MetadataPayload exif ;
   MetadataPayload iccp ;
   MetadataPayload xmp ;
};
#line 31 "/root/patron-new/new_3/imageio/./metadata.h"
typedef struct Metadata Metadata;
#line 70 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned short uint16;
#line 73 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned int uint32;
#line 76 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned long uint64;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct tiff ;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct tiff TIFF;
#line 65 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef long tmsize_t;
#line 66 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint64 toff_t;
#line 69 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint32 ttag_t;
#line 70 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint16 tdir_t;
#line 75 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tmsize_t tsize_t;
#line 104 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void *thandle_t;
#line 29 "/root/patron-new/new_3/imageio/tiffdec.c"
struct __anonstruct_945 {
   ttag_t tag ;
   size_t storage_offset ;
};
#line 70 "/root/patron-new/new_3/imageio/tiffdec.c"
struct __anonstruct_1198 {
   uint8_t *data ;
   toff_t size ;
   toff_t pos ;
};
#line 74 "/root/patron-new/new_3/imageio/tiffdec.c"
typedef struct __anonstruct_1198 MyData;
#line 32 "/root/patron-new/new_3/imageio/pnmdec.c"
struct __anonstruct_1221 {
   uint8_t *data ;
   size_t data_size ;
   int width ;
   int height ;
   int bytes_per_px ;
   int depth ;
   int max_value ;
   int type ;
   int seen_flags ;
};
#line 41 "/root/patron-new/new_3/imageio/pnmdec.c"
typedef struct __anonstruct_1221 PNMInfo;
#line 33 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 45 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 481 "/usr/include/libpng16/pngconf.h"
typedef unsigned char png_byte;
#line 511 "/usr/include/libpng16/pngconf.h"
typedef unsigned int png_uint_32;
#line 523 "/usr/include/libpng16/pngconf.h"
typedef size_t png_size_t;
#line 557 "/usr/include/libpng16/pngconf.h"
typedef size_t png_alloc_size_t;
#line 577 "/usr/include/libpng16/pngconf.h"
typedef void *png_voidp;
#line 579 "/usr/include/libpng16/pngconf.h"
typedef png_byte *png_bytep;
#line 589 "/usr/include/libpng16/pngconf.h"
typedef char *png_charp;
#line 590 "/usr/include/libpng16/pngconf.h"
typedef char const   *png_const_charp;
#line 606 "/usr/include/libpng16/pngconf.h"
typedef png_byte **png_bytepp;
#line 612 "/usr/include/libpng16/pngconf.h"
typedef char **png_charpp;
#line 454 "/usr/include/libpng16/png.h"
struct png_struct_def ;
#line 454 "/usr/include/libpng16/png.h"
typedef struct png_struct_def png_struct;
#line 456 "/usr/include/libpng16/png.h"
typedef png_struct *png_structp;
#line 457 "/usr/include/libpng16/png.h"
typedef png_struct **png_structpp;
#line 468
struct png_info_def ;
#line 468 "/usr/include/libpng16/png.h"
typedef struct png_info_def png_info;
#line 469 "/usr/include/libpng16/png.h"
typedef png_info *png_infop;
#line 471 "/usr/include/libpng16/png.h"
typedef png_info **png_infopp;
#line 484 "/usr/include/libpng16/png.h"
typedef png_struct *png_structrp;
#line 485 "/usr/include/libpng16/png.h"
typedef png_struct *png_const_structrp;
#line 486 "/usr/include/libpng16/png.h"
typedef png_info *png_inforp;
#line 487 "/usr/include/libpng16/png.h"
typedef png_info *png_const_inforp;
#line 577 "/usr/include/libpng16/png.h"
struct png_text_struct {
   int compression ;
   png_charp key ;
   png_charp text ;
   size_t text_length ;
   size_t itxt_length ;
   png_charp lang ;
   png_charp lang_key ;
};
#line 593 "/usr/include/libpng16/png.h"
typedef struct png_text_struct png_text;
#line 594 "/usr/include/libpng16/png.h"
typedef png_text *png_textp;
#line 43 "/root/patron-new/new_3/imageio/pngdec.c"
typedef png_alloc_size_t LocalPngAllocSize;
#line 130 "/root/patron-new/new_3/imageio/pngdec.c"
struct __anonstruct_1241 {
   char const   *name ;
   int (*process)(char const   * , size_t  , MetadataPayload * const   ) ;
   size_t storage_offset ;
};
#line 215 "/root/patron-new/new_3/imageio/pngdec.c"
struct __anonstruct_1242 {
   uint8_t *data ;
   size_t data_size ;
   png_size_t offset ;
};
#line 219 "/root/patron-new/new_3/imageio/pngdec.c"
typedef struct __anonstruct_1242 PNGReadContext;
#line 51 "/usr/include/jmorecfg.h"
typedef unsigned char JSAMPLE;
#line 91 "/usr/include/jmorecfg.h"
typedef short JCOEF;
#line 102 "/usr/include/jmorecfg.h"
typedef unsigned char JOCTET;
#line 127 "/usr/include/jmorecfg.h"
typedef unsigned char UINT8;
#line 139 "/usr/include/jmorecfg.h"
typedef unsigned short UINT16;
#line 194 "/usr/include/jmorecfg.h"
typedef unsigned int JDIMENSION;
#line 242 "/usr/include/jmorecfg.h"
typedef int boolean;
#line 69 "/usr/include/jpeglib.h"
typedef JSAMPLE *JSAMPROW;
#line 70 "/usr/include/jpeglib.h"
typedef JSAMPROW *JSAMPARRAY;
#line 73 "/usr/include/jpeglib.h"
typedef JCOEF JBLOCK[64];
#line 74 "/usr/include/jpeglib.h"
typedef JBLOCK *JBLOCKROW;
#line 75 "/usr/include/jpeglib.h"
typedef JBLOCKROW *JBLOCKARRAY;
#line 86 "/usr/include/jpeglib.h"
struct __anonstruct_1261 {
   UINT16 quantval[64] ;
   boolean sent_table ;
};
#line 98 "/usr/include/jpeglib.h"
typedef struct __anonstruct_1261 JQUANT_TBL;
#line 103 "/usr/include/jpeglib.h"
struct __anonstruct_1262 {
   UINT8 bits[17] ;
   UINT8 huffval[256] ;
   boolean sent_table ;
};
#line 114 "/usr/include/jpeglib.h"
typedef struct __anonstruct_1262 JHUFF_TBL;
#line 119 "/usr/include/jpeglib.h"
struct __anonstruct_1263 {
   int component_id ;
   int component_index ;
   int h_samp_factor ;
   int v_samp_factor ;
   int quant_tbl_no ;
   int dc_tbl_no ;
   int ac_tbl_no ;
   JDIMENSION width_in_blocks ;
   JDIMENSION height_in_blocks ;
   int DCT_h_scaled_size ;
   int DCT_v_scaled_size ;
   JDIMENSION downsampled_width ;
   JDIMENSION downsampled_height ;
   boolean component_needed ;
   int MCU_width ;
   int MCU_height ;
   int MCU_blocks ;
   int MCU_sample_width ;
   int last_col_width ;
   int last_row_height ;
   JQUANT_TBL *quant_table ;
   void *dct_table ;
};
#line 187 "/usr/include/jpeglib.h"
typedef struct __anonstruct_1263 jpeg_component_info;
#line 201
struct jpeg_marker_struct ;
#line 201 "/usr/include/jpeglib.h"
typedef struct jpeg_marker_struct *jpeg_saved_marker_ptr;
#line 203 "/usr/include/jpeglib.h"
struct jpeg_marker_struct {
   jpeg_saved_marker_ptr next ;
   UINT8 marker ;
   unsigned int original_length ;
   unsigned int data_length ;
   JOCTET *data ;
};
#line 217
enum __anonenum__1265 {
    JCS_UNKNOWN = 0,
    JCS_GRAYSCALE = 1,
    JCS_RGB = 2,
    JCS_YCbCr = 3,
    JCS_CMYK = 4,
    JCS_YCCK = 5,
    JCS_EXT_RGB = 6,
    JCS_EXT_RGBX = 7,
    JCS_EXT_BGR = 8,
    JCS_EXT_BGRX = 9,
    JCS_EXT_XBGR = 10,
    JCS_EXT_XRGB = 11,
    JCS_EXT_RGBA = 12,
    JCS_EXT_BGRA = 13,
    JCS_EXT_ABGR = 14,
    JCS_EXT_ARGB = 15,
    JCS_RGB565 = 16
} ;
#line 242 "/usr/include/jpeglib.h"
typedef enum __anonenum__1265 J_COLOR_SPACE;
#line 246
enum __anonenum__1266 {
    JDCT_ISLOW = 0,
    JDCT_IFAST = 1,
    JDCT_FLOAT = 2
} ;
#line 250 "/usr/include/jpeglib.h"
typedef enum __anonenum__1266 J_DCT_METHOD;
#line 261
enum __anonenum__1267 {
    JDITHER_NONE = 0,
    JDITHER_ORDERED = 1,
    JDITHER_FS = 2
} ;
#line 265 "/usr/include/jpeglib.h"
typedef enum __anonenum__1267 J_DITHER_MODE;
#line 283
struct jpeg_error_mgr ;
#line 283
struct jpeg_memory_mgr ;
#line 283
struct jpeg_progress_mgr ;
#line 282 "/usr/include/jpeglib.h"
struct jpeg_common_struct {
   struct jpeg_error_mgr *err ;
   struct jpeg_memory_mgr *mem ;
   struct jpeg_progress_mgr *progress ;
   void *client_data ;
   boolean is_decompressor ;
   int global_state ;
};
#line 290 "/usr/include/jpeglib.h"
typedef struct jpeg_common_struct *j_common_ptr;
#line 292
struct jpeg_decompress_struct ;
#line 292 "/usr/include/jpeglib.h"
typedef struct jpeg_decompress_struct *j_decompress_ptr;
#line 476
struct jpeg_source_mgr ;
#line 696
struct jpeg_decomp_master ;
#line 697
struct jpeg_d_main_controller ;
#line 698
struct jpeg_d_coef_controller ;
#line 699
struct jpeg_d_post_controller ;
#line 700
struct jpeg_input_controller ;
#line 701
struct jpeg_marker_reader ;
#line 702
struct jpeg_entropy_decoder ;
#line 703
struct jpeg_inverse_dct ;
#line 704
struct jpeg_upsampler ;
#line 705
struct jpeg_color_deconverter ;
#line 706
struct jpeg_color_quantizer ;
#line 472 "/usr/include/jpeglib.h"
struct jpeg_decompress_struct {
   struct jpeg_error_mgr *err ;
   struct jpeg_memory_mgr *mem ;
   struct jpeg_progress_mgr *progress ;
   void *client_data ;
   boolean is_decompressor ;
   int global_state ;
   struct jpeg_source_mgr *src ;
   JDIMENSION image_width ;
   JDIMENSION image_height ;
   int num_components ;
   J_COLOR_SPACE jpeg_color_space ;
   J_COLOR_SPACE out_color_space ;
   unsigned int scale_num ;
   unsigned int scale_denom ;
   double output_gamma ;
   boolean buffered_image ;
   boolean raw_data_out ;
   J_DCT_METHOD dct_method ;
   boolean do_fancy_upsampling ;
   boolean do_block_smoothing ;
   boolean quantize_colors ;
   J_DITHER_MODE dither_mode ;
   boolean two_pass_quantize ;
   int desired_number_of_colors ;
   boolean enable_1pass_quant ;
   boolean enable_external_quant ;
   boolean enable_2pass_quant ;
   JDIMENSION output_width ;
   JDIMENSION output_height ;
   int out_color_components ;
   int output_components ;
   int rec_outbuf_height ;
   int actual_number_of_colors ;
   JSAMPARRAY colormap ;
   JDIMENSION output_scanline ;
   int input_scan_number ;
   JDIMENSION input_iMCU_row ;
   int output_scan_number ;
   JDIMENSION output_iMCU_row ;
   int (*coef_bits)[64] ;
   JQUANT_TBL *quant_tbl_ptrs[4] ;
   JHUFF_TBL *dc_huff_tbl_ptrs[4] ;
   JHUFF_TBL *ac_huff_tbl_ptrs[4] ;
   int data_precision ;
   jpeg_component_info *comp_info ;
   boolean is_baseline ;
   boolean progressive_mode ;
   boolean arith_code ;
   UINT8 arith_dc_L[16] ;
   UINT8 arith_dc_U[16] ;
   UINT8 arith_ac_K[16] ;
   unsigned int restart_interval ;
   boolean saw_JFIF_marker ;
   UINT8 JFIF_major_version ;
   UINT8 JFIF_minor_version ;
   UINT8 density_unit ;
   UINT16 X_density ;
   UINT16 Y_density ;
   boolean saw_Adobe_marker ;
   UINT8 Adobe_transform ;
   boolean CCIR601_sampling ;
   jpeg_saved_marker_ptr marker_list ;
   int max_h_samp_factor ;
   int max_v_samp_factor ;
   int min_DCT_h_scaled_size ;
   int min_DCT_v_scaled_size ;
   JDIMENSION total_iMCU_rows ;
   JSAMPLE *sample_range_limit ;
   int comps_in_scan ;
   jpeg_component_info *cur_comp_info[4] ;
   JDIMENSION MCUs_per_row ;
   JDIMENSION MCU_rows_in_scan ;
   int blocks_in_MCU ;
   int MCU_membership[10] ;
   int Ss ;
   int Se ;
   int Ah ;
   int Al ;
   int block_size ;
   int const   *natural_order ;
   int lim_Se ;
   int unread_marker ;
   struct jpeg_decomp_master *master ;
   struct jpeg_d_main_controller *main ;
   struct jpeg_d_coef_controller *coef ;
   struct jpeg_d_post_controller *post ;
   struct jpeg_input_controller *inputctl ;
   struct jpeg_marker_reader *marker ;
   struct jpeg_entropy_decoder *entropy ;
   struct jpeg_inverse_dct *idct ;
   struct jpeg_upsampler *upsample ;
   struct jpeg_color_deconverter *cconvert ;
   struct jpeg_color_quantizer *cquantize ;
};
#line 738 "/usr/include/jpeglib.h"
union __anonunion_1268 {
   int i[8] ;
   char s[80] ;
};
#line 720 "/usr/include/jpeglib.h"
struct jpeg_error_mgr {
   void (*error_exit)(j_common_ptr  ) ;
   void (*emit_message)(j_common_ptr  , int  ) ;
   void (*output_message)(j_common_ptr  ) ;
   void (*format_message)(j_common_ptr  , char * ) ;
   void (*reset_error_mgr)(j_common_ptr  ) ;
   int msg_code ;
   union __anonunion_1268 msg_parm ;
   int trace_level ;
   long num_warnings ;
   char const   * const  *jpeg_message_table ;
   int last_jpeg_message ;
   char const   * const  *addon_message_table ;
   int first_addon_message ;
   int last_addon_message ;
};
#line 778 "/usr/include/jpeglib.h"
struct jpeg_progress_mgr {
   void (*progress_monitor)(j_common_ptr  ) ;
   long pass_counter ;
   long pass_limit ;
   int completed_passes ;
   int total_passes ;
};
#line 802 "/usr/include/jpeglib.h"
struct jpeg_source_mgr {
   JOCTET *next_input_byte ;
   size_t bytes_in_buffer ;
   void (*init_source)(j_decompress_ptr  ) ;
   boolean (*fill_input_buffer)(j_decompress_ptr  ) ;
   void (*skip_input_data)(j_decompress_ptr  , long  ) ;
   boolean (*resync_to_restart)(j_decompress_ptr  , int  ) ;
   void (*term_source)(j_decompress_ptr  ) ;
};
#line 829
struct jvirt_sarray_control ;
#line 829 "/usr/include/jpeglib.h"
typedef struct jvirt_sarray_control *jvirt_sarray_ptr;
#line 830
struct jvirt_barray_control ;
#line 830 "/usr/include/jpeglib.h"
typedef struct jvirt_barray_control *jvirt_barray_ptr;
#line 833 "/usr/include/jpeglib.h"
struct jpeg_memory_mgr {
   void *(*alloc_small)(j_common_ptr  , int  , size_t  ) ;
   void *(*alloc_large)(j_common_ptr  , int  , size_t  ) ;
   JSAMPARRAY (*alloc_sarray)(j_common_ptr  , int  , JDIMENSION  , JDIMENSION  ) ;
   JBLOCKARRAY (*alloc_barray)(j_common_ptr  , int  , JDIMENSION  , JDIMENSION  ) ;
   jvirt_sarray_ptr (*request_virt_sarray)(j_common_ptr  , int  , boolean  , JDIMENSION  ,
                                           JDIMENSION  , JDIMENSION  ) ;
   jvirt_barray_ptr (*request_virt_barray)(j_common_ptr  , int  , boolean  , JDIMENSION  ,
                                           JDIMENSION  , JDIMENSION  ) ;
   void (*realize_virt_arrays)(j_common_ptr  ) ;
   JSAMPARRAY (*access_virt_sarray)(j_common_ptr  , jvirt_sarray_ptr  , JDIMENSION  ,
                                    JDIMENSION  , boolean  ) ;
   JBLOCKARRAY (*access_virt_barray)(j_common_ptr  , jvirt_barray_ptr  , JDIMENSION  ,
                                     JDIMENSION  , boolean  ) ;
   void (*free_pool)(j_common_ptr  , int  ) ;
   void (*self_destruct)(j_common_ptr  ) ;
   long max_memory_to_use ;
   long max_alloc_chunk ;
};
#line 41 "/root/patron-new/new_3/imageio/jpegdec.c"
struct __anonstruct_1287 {
   uint8_t *data ;
   size_t data_length ;
   int seq ;
};
#line 45 "/root/patron-new/new_3/imageio/jpegdec.c"
typedef struct __anonstruct_1287 ICCPSegment;
#line 202 "/root/patron-new/new_3/imageio/jpegdec.c"
struct my_error_mgr {
   struct jpeg_error_mgr pub ;
   jmp_buf setjmp_buffer ;
};
#line 214 "/root/patron-new/new_3/imageio/jpegdec.c"
struct __anonstruct_1288 {
   struct jpeg_source_mgr pub ;
   uint8_t *data ;
   size_t data_size ;
};
#line 218 "/root/patron-new/new_3/imageio/jpegdec.c"
typedef struct __anonstruct_1288 JPEGReadContext;
#line 152 "/root/patron-new/new_3/imageio/jpegdec.c"
struct __anonstruct_1289 {
   int marker ;
   char const   *signature ;
   size_t signature_length ;
   size_t storage_offset ;
};
#line 35 "/root/patron-new/new_3/imageio/./image_dec.h"
enum __anonenum__1291 {
    WEBP_PNG_FORMAT = 0,
    WEBP_JPEG_FORMAT = 1,
    WEBP_TIFF_FORMAT = 2,
    WEBP_WEBP_FORMAT = 3,
    WEBP_PNM_FORMAT = 4,
    WEBP_UNSUPPORTED_FORMAT = 5
} ;
#line 42 "/root/patron-new/new_3/imageio/./image_dec.h"
typedef enum __anonenum__1291 WebPInputFileFormat;
#line 50 "/root/patron-new/new_3/imageio/./image_dec.h"
typedef int (*WebPImageReader)(uint8_t * const   , size_t  , struct WebPPicture * const   ,
                               int  , struct Metadata * const   );
#line 47 "/root/patron-new/new_3/examples/./example_util.h"
struct __anonstruct_1315 {
   int argc_ ;
   char const   **argv_ ;
   WebPData argv_data_ ;
   int own_argv_ ;
};
#line 52 "/root/patron-new/new_3/examples/./example_util.h"
typedef struct __anonstruct_1315 CommandLineArguments;
#line 45 "/root/patron-new/new_3/examples/./stopwatch.h"
typedef struct timeval Stopwatch;
#line 780 "/root/patron-new/new_3/examples/cwebp.c"
struct __anonstruct_1359 ;
#line 828
struct __anonstruct_1360 ;
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   long __builtin_bswap64(long  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
#line 101 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 180
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 800
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 820
__inline extern void *( __attribute__((__gnu_inline__)) bsearch)(void const   *__key ,
                                                                 void const   *__base ,
                                                                 size_t __nmemb ,
                                                                 size_t __size , int (*__compar)(void const   * ,
                                                                                                 void const   * ) ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *( __attribute__((__gnu_inline__)) bsearch)(void const   *__key ,
                                                                 void const   *__base ,
                                                                 size_t __nmemb ,
                                                                 size_t __size , int (*__compar)(void const   * ,
                                                                                                 void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;

#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 42
  return ((void *)0);
}
}
#line 830 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 929
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctomb)(char *__s ,
                                                                                            wchar_t __wchar ) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                                 char const   *__src ,
                                                                                                 size_t __len ) ;
#line 936
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst ,
                                                                                                 wchar_t *__src ,
                                                                                                 size_t __len ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd , char *__buf ,
                                                                 size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 68
    __cil_tmp5 = 0;
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctomb)(char *__s ,
                                                                                            wchar_t __wchar ) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) wctomb)(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 92
  __cil_tmp3 = __builtin_object_size((void *)__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size((void *)__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                                 char const   *__src ,
                                                                                                 size_t __len ) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                   char const   *__src ,
                                                                   size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size((void *)__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    __cil_tmp5 = 0;
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size((void *)__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size((void *)__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size((void *)__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst ,
                                                                                                 wchar_t *__src ,
                                                                                                 size_t __len ) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst , wchar_t *__src ,
                                                                   size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size((void *)__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 149
    __cil_tmp5 = 0;
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size((void *)__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size((void *)__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size((void *)__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest ,
                                                                                              void const   *__src ,
                                                                                              size_t __len ) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memmove)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memset)(void *__dest ,
                                                                                              int __ch ,
                                                                                              size_t __len ) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 130
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcat)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncat)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 38 "/usr/include/strings.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                                                            void *__dest ,
                                                                                            size_t __len ) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bzero)(void *__dest ,
                                                                                            size_t __len ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                                                            void *__dest ,
                                                                                            size_t __len ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                              void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 27
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bzero)(void *__dest ,
                                                                                            size_t __len ) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__gnu_inline__)) bzero)(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
#line 33
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) explicit_bzero)(void *__dest ,
                                                                                                     size_t __len ) ;
#line 460
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __n ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest ,
                                                                                              void const   *__src ,
                                                                                              size_t __len ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest , void const   *__src ,
                                                                size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memmove)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) memmove)(void *__dest , void const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memset)(void *__dest ,
                                                                                              int __ch ,
                                                                                              size_t __len ) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) memset)(void *__dest , int __ch ,
                                                                size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 77
extern  __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                               size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) explicit_bzero)(void *__dest ,
                                                                                                     size_t __len ) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void ( __attribute__((__gnu_inline__)) explicit_bzero)(void *__dest ,
                                                                       size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
#line 85
  return;
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size((void *)__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest , char const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __n ) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest , char const   *__src ,
                                                                 size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size((void *)__dest, 1);
#line 118
  __cil_tmp5 = 0;
#line 118
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
#line 120
      __cil_tmp7 = __builtin_object_size((void *)__dest, 1);
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
#line 120
      __cil_tmp7 = __builtin_object_size((void *)__dest, 1);
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcat)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strcat)(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size((void *)__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncat)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strncat)(char *__dest , char const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 297 "/usr/include/inttypes.h"
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                                                    char **endptr ,
                                                                                                    int base ) ;
#line 301
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                                                     char **endptr ,
                                                                                                     int base ) ;
#line 305
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                                                    __gwchar_t **endptr ,
                                                                                                    int base ) ;
#line 310
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                                                     __gwchar_t **endptr ,
                                                                                                     int base ) ;
#line 318
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   *__nptr ,
                                                            char **__endptr , int __base ,
                                                            int __group ) ;
#line 324
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                                                    char **endptr ,
                                                                                                    int base ) ;
#line 324 "/usr/include/inttypes.h"
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                      char **endptr ,
                                                                      int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 327
  __cil_tmp4 = __strtol_internal(nptr, endptr, base, 0);
  }
#line 327
  return (__cil_tmp4);
}
}
#line 330
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 336
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                                                     char **endptr ,
                                                                                                     int base ) ;
#line 336 "/usr/include/inttypes.h"
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                       char **endptr ,
                                                                       int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 339
  __cil_tmp4 = __strtoul_internal(nptr, endptr, base, 0);
  }
#line 339
  return (__cil_tmp4);
}
}
#line 342
extern  __attribute__((__nothrow__)) long __wcstol_internal(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                            int __base , int __group ) ;
#line 348
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                                                    __gwchar_t **endptr ,
                                                                                                    int base ) ;
#line 348 "/usr/include/inttypes.h"
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                      __gwchar_t **endptr ,
                                                                      int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 351
  __cil_tmp4 = __wcstol_internal(nptr, endptr, base, 0);
  }
#line 351
  return (__cil_tmp4);
}
}
#line 354
extern  __attribute__((__nothrow__)) unsigned long __wcstoul_internal(__gwchar_t *__nptr ,
                                                                      __gwchar_t **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                                                     __gwchar_t **endptr ,
                                                                                                     int base ) ;
#line 362 "/usr/include/inttypes.h"
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                       __gwchar_t **endptr ,
                                                                       int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 365
  __cil_tmp4 = __wcstoul_internal(nptr, endptr, base, 0);
  }
#line 365
  return (__cil_tmp4);
}
}
#line 59 "../../src/webp/./types.h"
void *WebPMalloc(size_t size ) ;
#line 62
void WebPFree(void *ptr ) ;
#line 39 "../../src/webp/decode.h"
int WebPGetDecoderVersion(void) ;
#line 51
int WebPGetInfo(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 59
uint8_t *WebPDecodeRGBA(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 63
uint8_t *WebPDecodeARGB(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 67
uint8_t *WebPDecodeBGRA(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 72
uint8_t *WebPDecodeRGB(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 76
uint8_t *WebPDecodeBGR(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 89
uint8_t *WebPDecodeYUV(uint8_t *data , size_t data_size , int *width , int *height ,
                       uint8_t **u , uint8_t **v , int *stride , int *uv_stride ) ;
#line 102
uint8_t *WebPDecodeRGBAInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) ;
#line 105
uint8_t *WebPDecodeARGBInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) ;
#line 108
uint8_t *WebPDecodeBGRAInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) ;
#line 114
uint8_t *WebPDecodeRGBInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                           int stride ) ;
#line 117
uint8_t *WebPDecodeBGRInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                           int stride ) ;
#line 128
uint8_t *WebPDecodeYUVInto(uint8_t *data , size_t data_size , uint8_t *luma , size_t luma_size ,
                           int luma_stride , uint8_t *u , size_t u_size , int u_stride ,
                           uint8_t *v , size_t v_size , int v_stride ) ;
#line 165 "../../src/webp/decode.h"
__inline static int WebPIsPremultipliedMode(WEBP_CSP_MODE mode ) 
{ 
  int tmp ;

  {
#line 166
  if ((unsigned int )mode == 7U) {
#line 166
    tmp = 1;
  } else
#line 166
  if ((unsigned int )mode == 8U) {
#line 166
    tmp = 1;
  } else
#line 166
  if ((unsigned int )mode == 9U) {
#line 166
    tmp = 1;
  } else
#line 166
  if ((unsigned int )mode == 10U) {
#line 166
    tmp = 1;
  } else {
#line 166
    tmp = 0;
  }
#line 166
  return (tmp);
}
}
#line 170 "../../src/webp/decode.h"
__inline static int WebPIsAlphaMode(WEBP_CSP_MODE mode ) 
{ 
  int __cil_tmp2 ;
  int tmp ;

  {
  {
#line 171
  __cil_tmp2 = WebPIsPremultipliedMode(mode);
  }
#line 171
  if ((unsigned int )mode == 1U) {
#line 171
    tmp = 1;
  } else
#line 171
  if ((unsigned int )mode == 3U) {
#line 171
    tmp = 1;
  } else
#line 171
  if ((unsigned int )mode == 4U) {
#line 171
    tmp = 1;
  } else
#line 171
  if ((unsigned int )mode == 5U) {
#line 171
    tmp = 1;
  } else
#line 171
  if ((unsigned int )mode == 12U) {
#line 171
    tmp = 1;
  } else
#line 171
  if (__cil_tmp2) {
#line 171
    tmp = 1;
  } else {
#line 171
    tmp = 0;
  }
#line 171
  return (tmp);
}
}
#line 176 "../../src/webp/decode.h"
__inline static int WebPIsRGBMode(WEBP_CSP_MODE mode ) 
{ 


  {
#line 177
  return ((unsigned int )mode < 11U);
}
}
#line 219
int WebPInitDecBufferInternal(WebPDecBuffer *buffer , int version ) ;
#line 223 "../../src/webp/decode.h"
__inline static int WebPInitDecBuffer(WebPDecBuffer *buffer ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 224
  __cil_tmp2 = WebPInitDecBufferInternal(buffer, 521);
  }
#line 224
  return (__cil_tmp2);
}
}
#line 229
void WebPFreeDecBuffer(WebPDecBuffer *buffer ) ;
#line 283
WebPIDecoder *WebPINewDecoder(WebPDecBuffer *output_buffer ) ;
#line 295
WebPIDecoder *WebPINewRGB(WEBP_CSP_MODE csp , uint8_t *output_buffer , size_t output_buffer_size ,
                          int output_stride ) ;
#line 310
WebPIDecoder *WebPINewYUVA(uint8_t *luma , size_t luma_size , int luma_stride , uint8_t *u ,
                           size_t u_size , int u_stride , uint8_t *v , size_t v_size ,
                           int v_stride , uint8_t *a , size_t a_size , int a_stride ) ;
#line 318
WebPIDecoder *WebPINewYUV(uint8_t *luma , size_t luma_size , int luma_stride , uint8_t *u ,
                          size_t u_size , int u_stride , uint8_t *v , size_t v_size ,
                          int v_stride ) ;
#line 325
void WebPIDelete(WebPIDecoder *idec ) ;
#line 330
VP8StatusCode WebPIAppend(WebPIDecoder *idec , uint8_t *data , size_t data_size ) ;
#line 338
VP8StatusCode WebPIUpdate(WebPIDecoder *idec , uint8_t *data , size_t data_size ) ;
#line 348
uint8_t *WebPIDecGetRGB(WebPIDecoder *idec , int *last_y , int *width , int *height ,
                        int *stride ) ;
#line 355
uint8_t *WebPIDecGetYUVA(WebPIDecoder *idec , int *last_y , uint8_t **u , uint8_t **v ,
                         uint8_t **a , int *width , int *height , int *stride , int *uv_stride ,
                         int *a_stride ) ;
#line 375
WebPDecBuffer *WebPIDecodedArea(WebPIDecoder *idec , int *left , int *top , int *width ,
                                int *height ) ;
#line 423
VP8StatusCode WebPGetFeaturesInternal(uint8_t *data , size_t data_size , WebPBitstreamFeatures *features ,
                                      int version ) ;
#line 437 "../../src/webp/decode.h"
__inline static VP8StatusCode WebPGetFeatures(uint8_t *data , size_t data_size , WebPBitstreamFeatures *features ) 
{ 
  VP8StatusCode __cil_tmp4 ;

  {
  {
#line 440
  __cil_tmp4 = WebPGetFeaturesInternal(data, data_size, features, 521);
  }
#line 440
  return (__cil_tmp4);
}
}
#line 470
int WebPInitDecoderConfigInternal(WebPDecoderConfig *config , int version ) ;
#line 475 "../../src/webp/decode.h"
__inline static int WebPInitDecoderConfig(WebPDecoderConfig *config ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 476
  __cil_tmp2 = WebPInitDecoderConfigInternal(config, 521);
  }
#line 476
  return (__cil_tmp2);
}
}
#line 490
WebPIDecoder *WebPIDecode(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) ;
#line 496
VP8StatusCode WebPDecode(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) ;
#line 38 "../../src/webp/encode.h"
int WebPGetEncoderVersion(void) ;
#line 49
size_t WebPEncodeRGB(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 52
size_t WebPEncodeBGR(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 55
size_t WebPEncodeRGBA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 58
size_t WebPEncodeBGRA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 69
size_t WebPEncodeLosslessRGB(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 72
size_t WebPEncodeLosslessBGR(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 75
size_t WebPEncodeLosslessRGBA(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 78
size_t WebPEncodeLosslessBGRA(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 167
int WebPConfigInitInternal(WebPConfig *config , WebPPreset preset , float quality ,
                           int version ) ;
#line 173 "../../src/webp/encode.h"
__inline static int WebPConfigInit(WebPConfig *config ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 174
  __cil_tmp2 = WebPConfigInitInternal(config, (WebPPreset )0, 75.f, 527);
  }
#line 174
  return (__cil_tmp2);
}
}
#line 182 "../../src/webp/encode.h"
__inline static int WebPConfigPreset(WebPConfig *config , WebPPreset preset , float quality ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 184
  __cil_tmp4 = WebPConfigInitInternal(config, preset, quality, 527);
  }
#line 184
  return (__cil_tmp4);
}
}
#line 194
int WebPConfigLosslessPreset(WebPConfig *config , int level ) ;
#line 198
int WebPValidateConfig(WebPConfig *config ) ;
#line 250
void WebPMemoryWriterInit(WebPMemoryWriter *writer ) ;
#line 254
void WebPMemoryWriterClear(WebPMemoryWriter *writer ) ;
#line 258
int WebPMemoryWrite(uint8_t *data , size_t data_size , WebPPicture *picture ) ;
#line 367
int WebPPictureInitInternal(WebPPicture *picture , int version ) ;
#line 373 "../../src/webp/encode.h"
__inline static int WebPPictureInit(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 374
  __cil_tmp2 = WebPPictureInitInternal(picture, 527);
  }
#line 374
  return (__cil_tmp2);
}
}
#line 384
int WebPPictureAlloc(WebPPicture *picture ) ;
#line 391
void WebPPictureFree(WebPPicture *picture ) ;
#line 397
int WebPPictureCopy(WebPPicture *src , WebPPicture *dst ) ;
#line 406
int WebPPlaneDistortion(uint8_t *src , size_t src_stride , uint8_t *ref , size_t ref_stride ,
                        int width , int height , size_t x_step , int type , float *distortion ,
                        float *result ) ;
#line 418
int WebPPictureDistortion(WebPPicture *src , WebPPicture *ref , int type , float *results ) ;
#line 431
int WebPPictureCrop(WebPPicture *pic , int left , int top , int width , int height ) ;
#line 445
int WebPPictureView(WebPPicture *src , int left , int top , int width , int height ,
                    WebPPicture *dst ) ;
#line 451
int WebPPictureIsView(WebPPicture *picture ) ;
#line 458
int WebPPictureRescale(WebPPicture *pic , int width , int height ) ;
#line 464
int WebPPictureImportRGB(WebPPicture *picture , uint8_t *rgb , int rgb_stride ) ;
#line 467
int WebPPictureImportRGBA(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) ;
#line 472
int WebPPictureImportRGBX(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) ;
#line 476
int WebPPictureImportBGR(WebPPicture *picture , uint8_t *rgb , int rgb_stride ) ;
#line 478
int WebPPictureImportBGRA(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) ;
#line 480
int WebPPictureImportBGRX(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) ;
#line 489
int WebPPictureARGBToYUVA(WebPPicture *picture , WebPEncCSP colorspace ) ;
#line 496
int WebPPictureARGBToYUVADithered(WebPPicture *picture , WebPEncCSP colorspace , float dithering ) ;
#line 504
int WebPPictureSharpARGBToYUVA(WebPPicture *picture ) ;
#line 506
int WebPPictureSmartARGBToYUVA(WebPPicture *picture ) ;
#line 514
int WebPPictureYUVAToARGB(WebPPicture *picture ) ;
#line 519
void WebPCleanupTransparentArea(WebPPicture *pic ) ;
#line 524
int WebPPictureHasTransparency(WebPPicture *picture ) ;
#line 529
void WebPBlendAlpha(WebPPicture *pic , uint32_t background_rgb ) ;
#line 544
int WebPEncode(WebPConfig *config , WebPPicture *pic ) ;
#line 198 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t *__newthread , pthread_attr_t *__attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void *__arg ) ;
#line 215
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 254
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 ) ;
#line 725
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t *__mutexattr ) ;
#line 730
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
#line 738
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 756
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 965
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t *__cond ,
                                                           pthread_condattr_t *__cond_attr ) ;
#line 970
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond ) ;
#line 974
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond ) ;
#line 986
extern int pthread_cond_wait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ) ;
#line 1165
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 ) ;
#line 1165 "/usr/include/pthread.h"
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
#line 1167
  return (__thread1 == __thread2);
}
}
#line 228 "../../src/dsp/dsp.h"
int (*VP8GetCPUInfo)(CPUFeature  ) ;
#line 249 "../../src/dsp/dsp.h"
void (*VP8ITransform)(uint8_t * , int16_t * , uint8_t * , int  )  ;
#line 250 "../../src/dsp/dsp.h"
void (*VP8FTransform)(uint8_t * , uint8_t * , int16_t * )  ;
#line 251 "../../src/dsp/dsp.h"
void (*VP8FTransform2)(uint8_t * , uint8_t * , int16_t * )  ;
#line 252 "../../src/dsp/dsp.h"
void (*VP8FTransformWHT)(int16_t * , int16_t * )  ;
#line 258 "../../src/dsp/dsp.h"
void (*VP8EncPredLuma4)(uint8_t * , uint8_t * )  ;
#line 259 "../../src/dsp/dsp.h"
void (*VP8EncPredLuma16)(uint8_t * , uint8_t * , uint8_t * )  ;
#line 260 "../../src/dsp/dsp.h"
void (*VP8EncPredChroma8)(uint8_t * , uint8_t * , uint8_t * )  ;
#line 263 "../../src/dsp/dsp.h"
int (*VP8SSE16x16)(uint8_t * , uint8_t * )  ;
#line 263 "../../src/dsp/dsp.h"
int (*VP8SSE16x8)(uint8_t * , uint8_t * )  ;
#line 263 "../../src/dsp/dsp.h"
int (*VP8SSE8x8)(uint8_t * , uint8_t * )  ;
#line 263 "../../src/dsp/dsp.h"
int (*VP8SSE4x4)(uint8_t * , uint8_t * )  ;
#line 268 "../../src/dsp/dsp.h"
int (*VP8TDisto4x4)(uint8_t * , uint8_t * , uint16_t * const   )  ;
#line 268 "../../src/dsp/dsp.h"
int (*VP8TDisto16x16)(uint8_t * , uint8_t * , uint16_t * const   )  ;
#line 273 "../../src/dsp/dsp.h"
void (*VP8Mean16x4)(uint8_t * , uint32_t * )  ;
#line 276 "../../src/dsp/dsp.h"
void (*VP8Copy4x4)(uint8_t * , uint8_t * )  ;
#line 277 "../../src/dsp/dsp.h"
void (*VP8Copy16x8)(uint8_t * , uint8_t * )  ;
#line 286 "../../src/dsp/dsp.h"
int (*VP8EncQuantizeBlock)(int16_t * , int16_t * , struct VP8Matrix * const   )  ;
#line 287 "../../src/dsp/dsp.h"
int (*VP8EncQuantize2Blocks)(int16_t * , int16_t * , struct VP8Matrix * const   )  ;
#line 292 "../../src/dsp/dsp.h"
int (*VP8EncQuantizeBlockWHT)(int16_t * , int16_t * , struct VP8Matrix * const   )  ;
#line 294
int const   VP8DspScan[24] ;
#line 306 "../../src/dsp/dsp.h"
void (*VP8CollectHistogram)(uint8_t * , uint8_t * , int  , int  , VP8Histogram * const   )  ;
#line 308
void VP8SetHistogramData(int const   *distribution , VP8Histogram *histo ) ;
#line 312
void VP8EncDspInit(void) ;
#line 317
uint16_t VP8EntropyCost[256] ;
#line 319
uint16_t VP8LevelFixedCosts[2048] ;
#line 320
uint8_t VP8EncBands[17] ;
#line 325 "../../src/dsp/dsp.h"
void (*VP8SetResidualCoeffs)(int16_t * const   , struct VP8Residual * const   )  ;
#line 330 "../../src/dsp/dsp.h"
int (*VP8GetResidualCost)(int  , struct VP8Residual * const   )  ;
#line 333
void VP8EncDspCostInit(void) ;
#line 347
double VP8SSIMFromStats(VP8DistoStats *stats ) ;
#line 348
double VP8SSIMFromStatsClipped(VP8DistoStats *stats ) ;
#line 362 "../../src/dsp/dsp.h"
double (*VP8SSIMGet)(uint8_t * , int  , uint8_t * , int  )  ;
#line 363 "../../src/dsp/dsp.h"
double (*VP8SSIMGetClipped)(uint8_t * , int  , uint8_t * , int  , int  , int  , int  ,
                            int  )  ;
#line 369 "../../src/dsp/dsp.h"
uint32_t (*VP8AccumulateSSE)(uint8_t * , uint8_t * , int  )  ;
#line 373
void VP8SSIMDspInit(void) ;
#line 381 "../../src/dsp/dsp.h"
void (*VP8Transform)(int16_t * , uint8_t * , int  )  ;
#line 382 "../../src/dsp/dsp.h"
void (*VP8TransformAC3)(int16_t * , uint8_t * )  ;
#line 383 "../../src/dsp/dsp.h"
void (*VP8TransformUV)(int16_t * , uint8_t * )  ;
#line 384 "../../src/dsp/dsp.h"
void (*VP8TransformDC)(int16_t * , uint8_t * )  ;
#line 385 "../../src/dsp/dsp.h"
void (*VP8TransformDCUV)(int16_t * , uint8_t * )  ;
#line 386 "../../src/dsp/dsp.h"
void (*VP8TransformWHT)(int16_t * , int16_t * )  ;
#line 391 "../../src/dsp/dsp.h"
VP8PredFunc VP8PredLuma16[7]  ;
#line 392 "../../src/dsp/dsp.h"
VP8PredFunc VP8PredChroma8[7]  ;
#line 393 "../../src/dsp/dsp.h"
VP8PredFunc VP8PredLuma4[10]  ;
#line 396
int8_t * const  VP8ksclip1 ;
#line 397
int8_t * const  VP8ksclip2 ;
#line 398
uint8_t * const  VP8kclip1 ;
#line 399
uint8_t * const  VP8kabs0 ;
#line 401
void VP8InitClipTables(void) ;
#line 405 "../../src/dsp/dsp.h"
void (*VP8SimpleVFilter16)(uint8_t * , int  , int  )  ;
#line 406 "../../src/dsp/dsp.h"
void (*VP8SimpleHFilter16)(uint8_t * , int  , int  )  ;
#line 407 "../../src/dsp/dsp.h"
void (*VP8SimpleVFilter16i)(uint8_t * , int  , int  )  ;
#line 408 "../../src/dsp/dsp.h"
void (*VP8SimpleHFilter16i)(uint8_t * , int  , int  )  ;
#line 416 "../../src/dsp/dsp.h"
void (*VP8VFilter16)(uint8_t * , int  , int  , int  , int  )  ;
#line 417 "../../src/dsp/dsp.h"
void (*VP8HFilter16)(uint8_t * , int  , int  , int  , int  )  ;
#line 418 "../../src/dsp/dsp.h"
void (*VP8VFilter8)(uint8_t * , uint8_t * , int  , int  , int  , int  )  ;
#line 419 "../../src/dsp/dsp.h"
void (*VP8HFilter8)(uint8_t * , uint8_t * , int  , int  , int  , int  )  ;
#line 422 "../../src/dsp/dsp.h"
void (*VP8VFilter16i)(uint8_t * , int  , int  , int  , int  )  ;
#line 423 "../../src/dsp/dsp.h"
void (*VP8HFilter16i)(uint8_t * , int  , int  , int  , int  )  ;
#line 424 "../../src/dsp/dsp.h"
void (*VP8VFilter8i)(uint8_t * , uint8_t * , int  , int  , int  , int  )  ;
#line 425 "../../src/dsp/dsp.h"
void (*VP8HFilter8i)(uint8_t * , uint8_t * , int  , int  , int  , int  )  ;
#line 433 "../../src/dsp/dsp.h"
void (*VP8DitherCombine8x8)(uint8_t * , uint8_t * , int  )  ;
#line 437
void VP8DspInit(void) ;
#line 455 "../../src/dsp/dsp.h"
WebPUpsampleLinePairFunc WebPUpsamplers[13]  ;
#line 464
void WebPSamplerProcessPlane(uint8_t *y , int y_stride , uint8_t *u , uint8_t *v ,
                             int uv_stride , uint8_t *dst , int dst_stride , int width ,
                             int height , void (*func)(uint8_t * , uint8_t * , uint8_t * ,
                                                       uint8_t * , int  ) ) ;
#line 470 "../../src/dsp/dsp.h"
WebPSamplerRowFunc WebPSamplers[13]  ;
#line 475
WebPUpsampleLinePairFunc WebPGetLinePairConverter(int alpha_is_last ) ;
#line 482 "../../src/dsp/dsp.h"
WebPYUV444Converter WebPYUV444Converters[13]  ;
#line 486
void WebPInitUpsamplers(void) ;
#line 488
void WebPInitSamplers(void) ;
#line 490
void WebPInitYUV444Converters(void) ;
#line 496 "../../src/dsp/dsp.h"
void (*WebPConvertARGBToY)(uint32_t * , uint8_t * , int  )  ;
#line 500 "../../src/dsp/dsp.h"
void (*WebPConvertARGBToUV)(uint32_t * , uint8_t * , uint8_t * , int  , int  )  ;
#line 504 "../../src/dsp/dsp.h"
void (*WebPConvertRGBA32ToUV)(uint16_t * , uint8_t * , uint8_t * , int  )  ;
#line 508 "../../src/dsp/dsp.h"
void (*WebPConvertRGB24ToY)(uint8_t * , uint8_t * , int  )  ;
#line 509 "../../src/dsp/dsp.h"
void (*WebPConvertBGR24ToY)(uint8_t * , uint8_t * , int  )  ;
#line 512
void WebPConvertARGBToUV_C(uint32_t *argb , uint8_t *u , uint8_t *v , int src_width ,
                           int do_store ) ;
#line 514
void WebPConvertRGBA32ToUV_C(uint16_t *rgb , uint8_t *u , uint8_t *v , int width ) ;
#line 518 "../../src/dsp/dsp.h"
uint64_t (*WebPSharpYUVUpdateY)(uint16_t * , uint16_t * , uint16_t * , int  )  ;
#line 520 "../../src/dsp/dsp.h"
void (*WebPSharpYUVUpdateRGB)(int16_t * , int16_t * , int16_t * , int  )  ;
#line 522 "../../src/dsp/dsp.h"
void (*WebPSharpYUVFilterRow)(int16_t * , int16_t * , int  , uint16_t * , uint16_t * )  ;
#line 527
void WebPInitConvertARGBToYUV(void) ;
#line 540 "../../src/dsp/dsp.h"
void (*WebPRescalerImportRowExpand)(struct WebPRescaler * const   , uint8_t * )  ;
#line 541 "../../src/dsp/dsp.h"
void (*WebPRescalerImportRowShrink)(struct WebPRescaler * const   , uint8_t * )  ;
#line 547 "../../src/dsp/dsp.h"
void (*WebPRescalerExportRowExpand)(struct WebPRescaler * const   )  ;
#line 548 "../../src/dsp/dsp.h"
void (*WebPRescalerExportRowShrink)(struct WebPRescaler * const   )  ;
#line 551
void WebPRescalerImportRowExpand_C(WebPRescaler *wrk , uint8_t *src ) ;
#line 553
void WebPRescalerImportRowShrink_C(WebPRescaler *wrk , uint8_t *src ) ;
#line 555
void WebPRescalerExportRowExpand_C(WebPRescaler *wrk ) ;
#line 556
void WebPRescalerExportRowShrink_C(WebPRescaler *wrk ) ;
#line 559
void WebPRescalerImportRow(WebPRescaler *wrk , uint8_t *src ) ;
#line 562
void WebPRescalerExportRow(WebPRescaler *wrk ) ;
#line 565
void WebPRescalerDspInit(void) ;
#line 572 "../../src/dsp/dsp.h"
void (*WebPApplyAlphaMultiply)(uint8_t * , int  , int  , int  , int  )  ;
#line 576 "../../src/dsp/dsp.h"
void (*WebPApplyAlphaMultiply4444)(uint8_t * , int  , int  , int  )  ;
#line 581 "../../src/dsp/dsp.h"
int (*WebPDispatchAlpha)(uint8_t * , int  , int  , int  , uint8_t * , int  )  ;
#line 587 "../../src/dsp/dsp.h"
void (*WebPDispatchAlphaToGreen)(uint8_t * , int  , int  , int  , uint32_t * , int  )  ;
#line 594 "../../src/dsp/dsp.h"
int (*WebPExtractAlpha)(uint8_t * , int  , int  , int  , uint8_t * , int  )  ;
#line 600 "../../src/dsp/dsp.h"
void (*WebPExtractGreen)(uint32_t * , uint8_t * , int  )  ;
#line 606 "../../src/dsp/dsp.h"
void (*WebPMultARGBRow)(uint32_t * const   , int  , int  )  ;
#line 609
void WebPMultARGBRows(uint8_t *ptr , int stride , int width , int num_rows , int inverse ) ;
#line 613 "../../src/dsp/dsp.h"
void (*WebPMultRow)(uint8_t * const   , uint8_t * const   , int  , int  )  ;
#line 617
void WebPMultRows(uint8_t *ptr , int stride , uint8_t *alpha , int alpha_stride ,
                  int width , int num_rows , int inverse ) ;
#line 622
void WebPMultRow_C(uint8_t *ptr , uint8_t *alpha , int width , int inverse ) ;
#line 624
void WebPMultARGBRow_C(uint32_t *ptr , int width , int inverse ) ;
#line 634 "../../src/dsp/dsp.h"
void (*WebPPackRGB)(uint8_t * , uint8_t * , uint8_t * , int  , int  , uint32_t * )  ;
#line 638 "../../src/dsp/dsp.h"
int (*WebPHasAlpha8b)(uint8_t * , int  )  ;
#line 640 "../../src/dsp/dsp.h"
int (*WebPHasAlpha32b)(uint8_t * , int  )  ;
#line 642 "../../src/dsp/dsp.h"
void (*WebPAlphaReplace)(uint32_t * , int  , uint32_t  )  ;
#line 645
void WebPInitAlphaProcessing(void) ;
#line 672 "../../src/dsp/dsp.h"
WebPFilterFunc WebPFilters[4]  ;
#line 677 "../../src/dsp/dsp.h"
WebPUnfilterFunc WebPUnfilters[4]  ;
#line 680
void VP8FiltersInit(void) ;
#line 34 "../../src/utils/color_cache_utils.h"
static uint32_t kHashMul  =    506832829U;
#line 37 "../../src/utils/color_cache_utils.h"
__inline static int VP8LHashPix(uint32_t argb , int shift ) 
{ 


  {
#line 38
  return ((int )(argb * kHashMul >> shift));
}
}
#line 41 "../../src/utils/color_cache_utils.h"
__inline static uint32_t VP8LColorCacheLookup(VP8LColorCache *cc , uint32_t key ) 
{ 


  {
#line 44
  return (*(cc->colors_ + key));
}
}
#line 47 "../../src/utils/color_cache_utils.h"
__inline static void VP8LColorCacheSet(VP8LColorCache *cc , uint32_t key , uint32_t argb ) 
{ 


  {
#line 50
  *(cc->colors_ + key) = argb;
#line 51
  return;
}
}
#line 75
int VP8LColorCacheInit(VP8LColorCache *color_cache , int hash_bits ) ;
#line 77
void VP8LColorCacheCopy(VP8LColorCache *src , VP8LColorCache *dst ) ;
#line 81
void VP8LColorCacheClear(VP8LColorCache *color_cache ) ;
#line 51 "../../src/utils/utils.h"
void *WebPSafeMalloc(uint64_t nmemb , size_t size ) ;
#line 54
void *WebPSafeCalloc(uint64_t nmemb , size_t size ) ;
#line 57
void WebPSafeFree(void *ptr ) ;
#line 67 "../../src/utils/utils.h"
__inline static uint32_t WebPMemToUint32(uint8_t *ptr ) 
{ 
  uint32_t A ;

  {
  {
#line 69
  memcpy((void *)(& A), (void const   *)ptr, sizeof(A));
  }
#line 70
  return (A);
}
}
#line 72 "../../src/utils/utils.h"
__inline static void WebPUint32ToMem(uint8_t *ptr , uint32_t val ) 
{ 


  {
  {
#line 73
  memcpy((void *)ptr, (void const   *)(& val), sizeof(val));
  }
#line 75
  return;
}
}
#line 80 "../../src/utils/utils.h"
__inline static int GetLE16(uint8_t *data ) 
{ 


  {
#line 81
  return ((int )*(data + 0) | ((int )*(data + 1) << 8));
}
}
#line 84 "../../src/utils/utils.h"
__inline static int GetLE24(uint8_t *data ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 85
  __cil_tmp2 = GetLE16(data);
  }
#line 85
  return (__cil_tmp2 | ((int )*(data + 2) << 16));
}
}
#line 88 "../../src/utils/utils.h"
__inline static uint32_t GetLE32(uint8_t *data ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 89
  __cil_tmp3 = GetLE16(data + 2);
#line 89
  __cil_tmp2 = GetLE16(data);
  }
#line 89
  return ((unsigned int )__cil_tmp2 | ((uint32_t )__cil_tmp3 << 16));
}
}
#line 93 "../../src/utils/utils.h"
__inline static void PutLE16(uint8_t *data , int val ) 
{ 


  {
#line 95
  *(data + 0) = (uint8_t )(val & 255);
#line 96
  *(data + 1) = (uint8_t )((val >> 8) & 255);
#line 97
  return;
}
}
#line 99 "../../src/utils/utils.h"
__inline static void PutLE24(uint8_t *data , int val ) 
{ 


  {
  {
#line 101
  PutLE16(data, val & 65535);
#line 102
  *(data + 2) = (uint8_t )((val >> 16) & 255);
  }
#line 104
  return;
}
}
#line 105 "../../src/utils/utils.h"
__inline static void PutLE32(uint8_t *data , uint32_t val ) 
{ 


  {
  {
#line 106
  PutLE16(data, (int )(val & 65535U));
#line 107
  PutLE16(data + 2, (int )(val >> 16));
  }
#line 109
  return;
}
}
#line 114 "../../src/utils/utils.h"
__inline static int BitsLog2Floor(uint32_t n ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 115
  __cil_tmp2 = __builtin_clz(n);
  }
#line 115
  return (31 ^ __cil_tmp2);
}
}
#line 168
void WebPCopyPlane(uint8_t *src , int src_stride , uint8_t *dst , int dst_stride ,
                   int width , int height ) ;
#line 174
void WebPCopyPixels(WebPPicture *src , WebPPicture *dst ) ;
#line 187
int WebPGetColorPalette(WebPPicture *pic , uint32_t *palette ) ;
#line 171 "/root/patron-new/new_3/src/utils/utils.c"
static int CheckSizeArgumentsOverflow(uint64_t nmemb , size_t size ) 
{ 
  uint64_t total_size ;

  {
#line 172
  total_size = nmemb * size;
#line 173
  if (nmemb == 0UL) {
#line 173
    return (1);
  }
#line 174
  if ((unsigned long long )size > (1ULL << 34) / (unsigned long long )nmemb) {
#line 174
    return (0);
  }
#line 175
  if (total_size != total_size) {
#line 175
    return (0);
  }
#line 191
  return (1);
}
}
#line 194 "/root/patron-new/new_3/src/utils/utils.c"
void *WebPSafeMalloc(uint64_t nmemb , size_t size ) 
{ 
  void *ptr ;
  int __cil_tmp4 ;

  {
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;

#line 196
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 197
  __cil_tmp4 = CheckSizeArgumentsOverflow(nmemb, size);
  }
#line 197
  if (! __cil_tmp4) {
#line 197
    return ((void *)0);
  }
  {
#line 199
  ptr = malloc(nmemb * size);
  }
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 200
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 201
  return (ptr);
}
}
#line 204 "/root/patron-new/new_3/src/utils/utils.c"
void *WebPSafeCalloc(uint64_t nmemb , size_t size ) 
{ 
  void *ptr ;
  int __cil_tmp4 ;

  {
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;

#line 206
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 207
  __cil_tmp4 = CheckSizeArgumentsOverflow(nmemb, size);
  }
#line 207
  if (! __cil_tmp4) {
#line 207
    return ((void *)0);
  }
  {
#line 209
  ptr = calloc(nmemb, size);
  }
  {
#line 210
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 210
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 211
  return (ptr);
}
}
#line 214 "/root/patron-new/new_3/src/utils/utils.c"
void WebPSafeFree(void *ptr ) 
{ 


  {
#line 215
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    {
#line 216
    while (1) {
      while_continue: /* CIL Label */ ;

#line 216
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 217
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  {
#line 219
  free(ptr);
  }
#line 221
  return;
}
}
#line 224 "/root/patron-new/new_3/src/utils/utils.c"
void *WebPMalloc(size_t size ) 
{ 
  void *__cil_tmp2 ;

  {
  {
#line 225
  __cil_tmp2 = WebPSafeMalloc((uint64_t )1, size);
  }
#line 225
  return (__cil_tmp2);
}
}
#line 228 "/root/patron-new/new_3/src/utils/utils.c"
void WebPFree(void *ptr ) 
{ 


  {
  {
#line 229
  WebPSafeFree(ptr);
  }
#line 231
  return;
}
}
#line 234 "/root/patron-new/new_3/src/utils/utils.c"
void WebPCopyPlane(uint8_t *src , int src_stride , uint8_t *dst , int dst_stride ,
                   int width , int height ) 
{ 
  int __cil_tmp7 ;

  {
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    __cil_tmp7 = height;
#line 238
    height --;
#line 238
    if (! (__cil_tmp7 > 0)) {
#line 238
      goto while_break;
    }
    {
#line 239
    memcpy((void *)dst, (void const   *)src, (unsigned long )width);
#line 240
    src += src_stride;
#line 241
    dst += dst_stride;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 246
  return;
}
}
#line 245 "/root/patron-new/new_3/src/utils/utils.c"
void WebPCopyPixels(WebPPicture *src , WebPPicture *dst ) 
{ 


  {
  {
#line 249
  WebPCopyPlane((uint8_t *)src->argb, 4 * src->argb_stride, (uint8_t *)dst->argb,
                4 * dst->argb_stride, 4 * src->width, src->height);
  }
#line 252
  return;
}
}
#line 258 "/root/patron-new/new_3/src/utils/utils.c"
int WebPGetColorPalette(WebPPicture *pic , uint32_t *palette ) 
{ 
  int i ;
  int x ;
  int y ;
  int num_colors ;
  uint8_t in_use[1024] ;
  unsigned int tmp ;
  uint32_t colors[1024] ;
  uint32_t *argb ;
  int width ;
  int height ;
  uint32_t last_pix ;
  int key ;

  {
#line 261
  num_colors = 0;
#line 262
  in_use[0] = (uint8_t )0;
#line 262
  tmp = 1U;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;

#line 262
    if (tmp >= 1024U) {
#line 262
      goto while_break;
    }
#line 262
    in_use[tmp] = (uint8_t )0;
#line 262
    tmp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 264
  argb = pic->argb;
#line 265
  width = pic->width;
#line 266
  height = pic->height;
#line 267
  last_pix = ~ *(argb + 0);
#line 271
  y = 0;
  {
#line 271
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 271
    if (! (y < height)) {
#line 271
      goto while_break___0;
    }
#line 272
    x = 0;
    {
#line 272
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___1: ;
#line 272
      if (! (x < width)) {
#line 272
        goto while_break___1;
      }
#line 274
      if (*(argb + x) == last_pix) {
#line 275
        goto while_continue___1;
      }
      {
#line 277
      last_pix = *(argb + x);
#line 278
      key = VP8LHashPix(last_pix, 22);
      }
      {
#line 279
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 280
        if (! in_use[key]) {
#line 281
          colors[key] = last_pix;
#line 282
          in_use[key] = (uint8_t )1;
#line 283
          num_colors ++;
#line 284
          if (num_colors > 256) {
#line 285
            return (257);
          }
#line 287
          goto while_break___2;
        } else
#line 288
        if (colors[key] == last_pix) {
#line 289
          goto while_break___2;
        } else {
#line 292
          key ++;
#line 293
          key &= 1023;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: 
#line 272
      x ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: 
#line 297
    argb += pic->argb_stride;
#line 271
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: ;
#line 300
  if ((unsigned long )palette != (unsigned long )((void *)0)) {
#line 301
    num_colors = 0;
#line 302
    i = 0;
    {
#line 302
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 302
      if (! (i < 1024)) {
#line 302
        goto while_break___3;
      }
#line 303
      if (in_use[i]) {
#line 304
        *(palette + num_colors) = colors[i];
#line 305
        num_colors ++;
      }
#line 302
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: ;
  }
#line 309
  return (num_colors);
}
}
#line 78 "../../src/utils/thread_utils.h"
int WebPSetWorkerInterface(WebPWorkerInterface *winterface ) ;
#line 82
WebPWorkerInterface *WebPGetWorkerInterface(void) ;
#line 204 "/root/patron-new/new_3/src/utils/thread_utils.c"
static void *ThreadLoop(void *ptr ) 
{ 
  WebPWorker *worker ;
  WebPWorkerImpl *impl ;
  int done ;
  WebPWorkerInterface *__cil_tmp5 ;

  {
#line 205
  worker = (WebPWorker *)ptr;
#line 206
  impl = (WebPWorkerImpl *)worker->impl_;
#line 207
  done = 0;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;

#line 208
    if (! (! done)) {
#line 208
      goto while_break;
    }
    {
#line 209
    pthread_mutex_lock(& impl->mutex_);
    }
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 210
      if (! ((unsigned int )worker->status_ == 1U)) {
#line 210
        goto while_break___0;
      }
      {
#line 211
      pthread_cond_wait(& impl->condition_, & impl->mutex_);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 213
    if ((unsigned int )worker->status_ == 2U) {
      {
#line 214
      (*(__cil_tmp5->Execute))((WebPWorker */* const  */)worker);
#line 215
      worker->status_ = (WebPWorkerStatus )1;
      }
    } else
#line 216
    if ((unsigned int )worker->status_ == 0U) {
#line 217
      done = 1;
    }
    {
#line 224
    pthread_mutex_unlock(& impl->mutex_);
#line 225
    pthread_cond_signal(& impl->condition_);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 227
  return ((void *)0);
}
}
#line 231 "/root/patron-new/new_3/src/utils/thread_utils.c"
static void ChangeState(WebPWorker *worker , WebPWorkerStatus new_status ) 
{ 
  WebPWorkerImpl *impl ;

  {
#line 235
  impl = (WebPWorkerImpl *)worker->impl_;
#line 236
  if ((unsigned long )impl == (unsigned long )((void *)0)) {
#line 236
    return;
  }
  {
#line 238
  pthread_mutex_lock(& impl->mutex_);
  }
#line 239
  if ((unsigned int )worker->status_ >= 1U) {
    {
#line 241
    while (1) {
      while_continue: /* CIL Label */ ;

#line 241
      if (! ((unsigned int )worker->status_ != 1U)) {
#line 241
        goto while_break;
      }
      {
#line 242
      pthread_cond_wait(& impl->condition_, & impl->mutex_);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
#line 245
    if ((unsigned int )new_status != 1U) {
      {
#line 246
      worker->status_ = new_status;
#line 251
      pthread_mutex_unlock(& impl->mutex_);
#line 252
      pthread_cond_signal(& impl->condition_);
      }
#line 253
      return;
    }
  }
  {
#line 256
  pthread_mutex_unlock(& impl->mutex_);
  }
#line 258
  return;
}
}
#line 263 "/root/patron-new/new_3/src/utils/thread_utils.c"
static void Init(WebPWorker *worker ) 
{ 


  {
  {
#line 264
  memset((void *)worker, 0, sizeof(*worker));
#line 265
  worker->status_ = (WebPWorkerStatus )0;
  }
#line 267
  return;
}
}
#line 268 "/root/patron-new/new_3/src/utils/thread_utils.c"
static int Sync(WebPWorker *worker ) 
{ 


  {
  {
#line 270
  ChangeState(worker, (WebPWorkerStatus )1);
  }
#line 273
  return (! worker->had_error);
}
}
#line 276 "/root/patron-new/new_3/src/utils/thread_utils.c"
static int Reset(WebPWorker *worker ) 
{ 
  int ok ;
  WebPWorkerImpl *impl ;
  void *__cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 277
  ok = 1;
#line 278
  worker->had_error = 0;
#line 279
  if ((unsigned int )worker->status_ < 1U) {
    {
#line 281
    __cil_tmp4 = WebPSafeCalloc((uint64_t )1, sizeof(WebPWorkerImpl ));
#line 281
    impl = (WebPWorkerImpl *)__cil_tmp4;
#line 283
    worker->impl_ = (void *)impl;
    }
#line 284
    if ((unsigned long )worker->impl_ == (unsigned long )((void *)0)) {
#line 285
      return (0);
    }
    {
#line 287
    __cil_tmp5 = pthread_mutex_init(& impl->mutex_, (pthread_mutexattr_t *)((void *)0));
    }
#line 287
    if (__cil_tmp5) {
#line 288
      goto Error;
    }
    {
#line 290
    __cil_tmp6 = pthread_cond_init(& impl->condition_, (pthread_condattr_t *)((void *)0));
    }
#line 290
    if (__cil_tmp6) {
      {
#line 291
      pthread_mutex_destroy(& impl->mutex_);
      }
#line 292
      goto Error;
    }
    {
#line 294
    pthread_mutex_lock(& impl->mutex_);
#line 295
    __cil_tmp7 = pthread_create(& impl->thread_, (pthread_attr_t *)((void *)0), & ThreadLoop,
                                (void *)worker);
#line 295
    ok = ! __cil_tmp7;
    }
#line 296
    if (ok) {
#line 296
      worker->status_ = (WebPWorkerStatus )1;
    }
    {
#line 297
    pthread_mutex_unlock(& impl->mutex_);
    }
#line 298
    if (! ok) {
      {
#line 299
      pthread_mutex_destroy(& impl->mutex_);
#line 300
      pthread_cond_destroy(& impl->condition_);
      }
      Error: 
      {
#line 302
      WebPSafeFree((void *)impl);
#line 303
      worker->impl_ = (void *)0;
      }
#line 304
      return (0);
    }
  } else
#line 309
  if ((unsigned int )worker->status_ > 1U) {
    {
#line 310
    ok = Sync(worker);
    }
  }
#line 313
  return (ok);
}
}
#line 316 "/root/patron-new/new_3/src/utils/thread_utils.c"
static void Execute(WebPWorker *worker ) 
{ 
  int __cil_tmp2 ;

  {
#line 317
  if ((unsigned long )worker->hook != (unsigned long )((void *)0)) {
    {
#line 318
    __cil_tmp2 = (*(worker->hook))(worker->data1, worker->data2);
#line 318
    worker->had_error |= ! __cil_tmp2;
    }
  }
#line 320
  return;
}
}
#line 322 "/root/patron-new/new_3/src/utils/thread_utils.c"
static void Launch(WebPWorker *worker ) 
{ 


  {
  {
#line 324
  ChangeState(worker, (WebPWorkerStatus )2);
  }
#line 326
  return;
}
}
#line 330 "/root/patron-new/new_3/src/utils/thread_utils.c"
static void End(WebPWorker *worker ) 
{ 
  WebPWorkerImpl *impl ;

  {
#line 332
  if ((unsigned long )worker->impl_ != (unsigned long )((void *)0)) {
    {
#line 333
    impl = (WebPWorkerImpl *)worker->impl_;
#line 334
    ChangeState(worker, (WebPWorkerStatus )0);
#line 335
    pthread_join(impl->thread_, (void **)((void *)0));
#line 336
    pthread_mutex_destroy(& impl->mutex_);
#line 337
    pthread_cond_destroy(& impl->condition_);
#line 338
    WebPSafeFree((void *)impl);
#line 339
    worker->impl_ = (void *)0;
    }
  }
#line 342
  return;
}
}
#line 350 "/root/patron-new/new_3/src/utils/thread_utils.c"
static WebPWorkerInterface g_worker_interface  =    {(void (*)(WebPWorker * const   ))(& Init), (int (*)(WebPWorker * const   ))(& Reset),
    (int (*)(WebPWorker * const   ))(& Sync), (void (*)(WebPWorker * const   ))(& Launch),
    (void (*)(WebPWorker * const   ))(& Execute), (void (*)(WebPWorker * const   ))(& End)};
#line 354 "/root/patron-new/new_3/src/utils/thread_utils.c"
int WebPSetWorkerInterface(WebPWorkerInterface *winterface ) 
{ 


  {
#line 355
  if ((unsigned long )winterface == (unsigned long )((void *)0)) {
#line 359
    return (0);
  } else
#line 355
  if ((unsigned long )winterface->Init == (unsigned long )((void *)0)) {
#line 359
    return (0);
  } else
#line 355
  if ((unsigned long )winterface->Reset == (unsigned long )((void *)0)) {
#line 359
    return (0);
  } else
#line 355
  if ((unsigned long )winterface->Sync == (unsigned long )((void *)0)) {
#line 359
    return (0);
  } else
#line 355
  if ((unsigned long )winterface->Launch == (unsigned long )((void *)0)) {
#line 359
    return (0);
  } else
#line 355
  if ((unsigned long )winterface->Execute == (unsigned long )((void *)0)) {
#line 359
    return (0);
  } else
#line 355
  if ((unsigned long )winterface->End == (unsigned long )((void *)0)) {
#line 359
    return (0);
  }
#line 361
  g_worker_interface = *winterface;
#line 362
  return (1);
}
}
#line 365 "/root/patron-new/new_3/src/utils/thread_utils.c"
WebPWorkerInterface *WebPGetWorkerInterface(void) 
{ 


  {
#line 366
  return (& g_worker_interface);
}
}
#line 50 "../../src/utils/rescaler_utils.h"
void WebPRescalerInit(WebPRescaler *wrk , int src_width , int src_height , uint8_t *dst ,
                      int dst_width , int dst_height , int dst_stride , int num_channels ,
                      rescaler_t *work ) ;
#line 61
int WebPRescalerGetScaledDimensions(int src_width , int src_height , int *scaled_width ,
                                    int *scaled_height ) ;
#line 67
int WebPRescaleNeededLines(WebPRescaler *rescaler , int max_num_lines ) ;
#line 72
int WebPRescalerImport(WebPRescaler *rescaler , int num_lines , uint8_t *src , int src_stride ) ;
#line 76
int WebPRescalerExport(WebPRescaler *rescaler ) ;
#line 85 "../../src/utils/rescaler_utils.h"
__inline static int WebPRescalerOutputDone(WebPRescaler *rescaler ) 
{ 


  {
#line 86
  return (rescaler->dst_y >= rescaler->dst_height);
}
}
#line 91 "../../src/utils/rescaler_utils.h"
__inline static int WebPRescalerHasPendingOutput(WebPRescaler *rescaler ) 
{ 
  int __cil_tmp2 ;
  int tmp ;

  {
  {
#line 92
  __cil_tmp2 = WebPRescalerOutputDone(rescaler);
  }
#line 92
  if (! __cil_tmp2) {
#line 92
    if (rescaler->y_accum <= 0) {
#line 92
      tmp = 1;
    } else {
#line 92
      tmp = 0;
    }
  } else {
#line 92
    tmp = 0;
  }
#line 92
  return (tmp);
}
}
#line 22 "/root/patron-new/new_3/src/utils/rescaler_utils.c"
void WebPRescalerInit(WebPRescaler *wrk , int src_width , int src_height , uint8_t *dst ,
                      int dst_width , int dst_height , int dst_stride , int num_channels ,
                      rescaler_t *work ) 
{ 
  int x_add ;
  int x_sub ;
  int y_add ;
  int y_sub ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  uint64_t num ;
  uint64_t den ;
  uint64_t ratio ;

  {
#line 26
  x_add = src_width;
#line 26
  x_sub = dst_width;
#line 27
  y_add = src_height;
#line 27
  y_sub = dst_height;
#line 28
  wrk->x_expand = src_width < dst_width;
#line 29
  wrk->y_expand = src_height < dst_height;
#line 30
  wrk->src_width = src_width;
#line 31
  wrk->src_height = src_height;
#line 32
  wrk->dst_width = dst_width;
#line 33
  wrk->dst_height = dst_height;
#line 34
  wrk->src_y = 0;
#line 35
  wrk->dst_y = 0;
#line 36
  wrk->dst = dst;
#line 37
  wrk->dst_stride = dst_stride;
#line 38
  wrk->num_channels = num_channels;
#line 41
  if (wrk->x_expand) {
#line 41
    tmp = x_sub - 1;
  } else {
#line 41
    tmp = x_add;
  }
#line 41
  wrk->x_add = tmp;
#line 42
  if (wrk->x_expand) {
#line 42
    tmp___0 = x_add - 1;
  } else {
#line 42
    tmp___0 = x_sub;
  }
#line 42
  wrk->x_sub = tmp___0;
#line 43
  if (! wrk->x_expand) {
#line 44
    wrk->fx_scale = (uint32_t )((1UL << 32) / (unsigned long )wrk->x_sub);
  }
#line 47
  if (wrk->y_expand) {
#line 47
    tmp___1 = y_add - 1;
  } else {
#line 47
    tmp___1 = y_add;
  }
#line 47
  wrk->y_add = tmp___1;
#line 48
  if (wrk->y_expand) {
#line 48
    tmp___2 = y_sub - 1;
  } else {
#line 48
    tmp___2 = y_sub;
  }
#line 48
  wrk->y_sub = tmp___2;
#line 49
  if (wrk->y_expand) {
#line 49
    tmp___3 = wrk->y_sub;
  } else {
#line 49
    tmp___3 = wrk->y_add;
  }
#line 49
  wrk->y_accum = tmp___3;
#line 50
  if (! wrk->y_expand) {
#line 54
    num = (uint64_t )((unsigned long long )((uint64_t )dst_height) * (1ULL << 32));
#line 55
    den = (uint64_t )wrk->x_add * (unsigned long )wrk->y_add;
#line 56
    ratio = num / den;
#line 57
    if (ratio != (unsigned long )((uint32_t )ratio)) {
#line 62
      wrk->fxy_scale = (uint32_t )0;
    } else {
#line 64
      wrk->fxy_scale = (uint32_t )ratio;
    }
#line 66
    wrk->fy_scale = (uint32_t )((1UL << 32) / (unsigned long )wrk->y_sub);
  } else {
#line 68
    wrk->fy_scale = (uint32_t )((1UL << 32) / (unsigned long )wrk->x_add);
  }
  {
#line 71
  wrk->irow = work;
#line 72
  wrk->frow = work + num_channels * dst_width;
#line 73
  memset((void *)work, 0, (unsigned long )((2 * dst_width) * num_channels) * sizeof(*work));
#line 75
  WebPRescalerDspInit();
  }
#line 77
  return;
}
}
#line 78 "/root/patron-new/new_3/src/utils/rescaler_utils.c"
int WebPRescalerGetScaledDimensions(int src_width , int src_height , int *scaled_width ,
                                    int *scaled_height ) 
{ 
  int width ;
  int height ;

  {
#line 84
  width = *scaled_width;
#line 85
  height = *scaled_height;
#line 88
  if (width == 0) {
#line 88
    if (src_height > 0) {
#line 89
      width = (int )((((uint64_t )src_width * (unsigned long )height + (unsigned long )src_height) - 1UL) / (unsigned long )src_height);
    }
  }
#line 93
  if (height == 0) {
#line 93
    if (src_width > 0) {
#line 94
      height = (int )((((uint64_t )src_height * (unsigned long )width + (unsigned long )src_width) - 1UL) / (unsigned long )src_width);
    }
  }
#line 98
  if (width <= 0) {
#line 99
    return (0);
  } else
#line 98
  if (height <= 0) {
#line 99
    return (0);
  }
#line 102
  *scaled_width = width;
#line 103
  *scaled_height = height;
#line 104
  return (1);
}
}
#line 111 "/root/patron-new/new_3/src/utils/rescaler_utils.c"
int WebPRescaleNeededLines(WebPRescaler *rescaler , int max_num_lines ) 
{ 
  int num_lines ;
  int tmp ;

  {
#line 113
  num_lines = ((rescaler->y_accum + rescaler->y_sub) - 1) / rescaler->y_sub;
#line 115
  if (num_lines > max_num_lines) {
#line 115
    tmp = max_num_lines;
  } else {
#line 115
    tmp = num_lines;
  }
#line 115
  return (tmp);
}
}
#line 118 "/root/patron-new/new_3/src/utils/rescaler_utils.c"
int WebPRescalerImport(WebPRescaler *rescaler , int num_lines , uint8_t *src , int src_stride ) 
{ 
  int total_imported ;
  int __cil_tmp6 ;
  rescaler_t *tmp ;
  int x ;

  {
#line 120
  total_imported = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 121
    __cil_tmp6 = WebPRescalerHasPendingOutput(rescaler);
    }
#line 121
    if (total_imported < num_lines) {
#line 121
      if (! (! __cil_tmp6)) {
#line 121
        goto while_break;
      }
    } else {
#line 121
      goto while_break;
    }
#line 123
    if (rescaler->y_expand) {
#line 124
      tmp = rescaler->irow;
#line 125
      rescaler->irow = rescaler->frow;
#line 126
      rescaler->frow = tmp;
    }
    {
#line 128
    WebPRescalerImportRow(rescaler, src);
    }
#line 129
    if (! rescaler->y_expand) {
#line 131
      x = 0;
      {
#line 131
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 131
        if (! (x < rescaler->num_channels * rescaler->dst_width)) {
#line 131
          goto while_break___0;
        }
#line 132
        *(rescaler->irow + x) += *(rescaler->frow + x);
#line 131
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
    }
#line 135
    (rescaler->src_y) ++;
#line 136
    src += src_stride;
#line 137
    total_imported ++;
#line 138
    rescaler->y_accum -= rescaler->y_sub;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 140
  return (total_imported);
}
}
#line 143 "/root/patron-new/new_3/src/utils/rescaler_utils.c"
int WebPRescalerExport(WebPRescaler *rescaler ) 
{ 
  int total_exported ;
  int __cil_tmp3 ;

  {
#line 144
  total_exported = 0;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 145
    __cil_tmp3 = WebPRescalerHasPendingOutput(rescaler);
    }
#line 145
    if (! __cil_tmp3) {
#line 145
      goto while_break;
    }
    {
#line 146
    WebPRescalerExportRow(rescaler);
#line 147
    total_exported ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 149
  return (total_exported);
}
}
#line 34 "../../src/utils/random_utils.h"
void VP8InitRandom(VP8Random *rg , float dithering ) ;
#line 39 "../../src/utils/random_utils.h"
__inline static int VP8RandomBits2(VP8Random *rg , int num_bits , int amp ) 
{ 
  int diff ;

  {
#line 43
  diff = (int )(rg->tab_[rg->index1_] - rg->tab_[rg->index2_]);
#line 44
  if (diff < 0) {
#line 44
    diff = (int )((unsigned int )diff + (1U << 31));
  }
#line 45
  rg->tab_[rg->index1_] = (uint32_t )diff;
#line 46
  (rg->index1_) ++;
#line 46
  if (rg->index1_ == 55) {
#line 46
    rg->index1_ = 0;
  }
#line 47
  (rg->index2_) ++;
#line 47
  if (rg->index2_ == 55) {
#line 47
    rg->index2_ = 0;
  }
#line 49
  diff = (int )((uint32_t )diff << 1) >> (32 - num_bits);
#line 50
  diff = diff * amp >> 8;
#line 51
  diff += 1 << (num_bits - 1);
#line 52
  return (diff);
}
}
#line 55 "../../src/utils/random_utils.h"
__inline static int VP8RandomBits(VP8Random *rg , int num_bits ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 56
  __cil_tmp3 = VP8RandomBits2(rg, num_bits, rg->amp_);
  }
#line 56
  return (__cil_tmp3);
}
}
#line 20 "/root/patron-new/new_3/src/utils/random_utils.c"
static uint32_t kRandomTable[55]  = 
#line 20 "/root/patron-new/new_3/src/utils/random_utils.c"
  {      (uint32_t )232870448,      (uint32_t )62068870,      (uint32_t )2002758859,      (uint32_t )478700138, 
        (uint32_t )1748524117,      (uint32_t )347322408,      (uint32_t )1250295544,      (uint32_t )1239267403, 
        (uint32_t )1694299031,      (uint32_t )1549075081,      (uint32_t )1244200960,      (uint32_t )226410970, 
        (uint32_t )1497413547,      (uint32_t )1418876797,      (uint32_t )1310313074,      (uint32_t )953388137, 
        (uint32_t )201453157,      (uint32_t )849442143,      (uint32_t )1412953682,      (uint32_t )1522215986, 
        (uint32_t )262821809,      (uint32_t )1945449447,      (uint32_t )1751117530,      (uint32_t )1969474786, 
        (uint32_t )1855524483,      (uint32_t )1194371053,      (uint32_t )1338038726,      (uint32_t )1231754556, 
        (uint32_t )1326711802,      (uint32_t )1411054348,      (uint32_t )1939409714,      (uint32_t )651676444, 
        (uint32_t )1875654406,      (uint32_t )750483416,      (uint32_t )1970679594,      (uint32_t )1680198877, 
        (uint32_t )615732321,      (uint32_t )175998741,      (uint32_t )570692776,      (uint32_t )337559399, 
        (uint32_t )1454642563,      (uint32_t )1944388323,      (uint32_t )1154134383,      (uint32_t )673598786, 
        (uint32_t )1941614331,      (uint32_t )173075437,      (uint32_t )493532923,      (uint32_t )221959179, 
        (uint32_t )903560040,      (uint32_t )721952387,      (uint32_t )2010016661,      (uint32_t )1367467504, 
        (uint32_t )2021997500,      (uint32_t )10458260,      (uint32_t )669379900};
#line 33 "/root/patron-new/new_3/src/utils/random_utils.c"
void VP8InitRandom(VP8Random *rg , float dithering ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 34
  memcpy((void *)(rg->tab_), (void const   *)(kRandomTable), sizeof(rg->tab_));
#line 35
  rg->index1_ = 0;
#line 36
  rg->index2_ = 31;
  }
#line 37
  if ((double )dithering < 0.) {
#line 37
    tmp___0 = 0U;
  } else {
#line 37
    if ((double )dithering > 1.) {
#line 37
      tmp = (unsigned int )(1 << 8);
    } else {
#line 37
      tmp = (uint32_t )((float )(1 << 8) * dithering);
    }
#line 37
    tmp___0 = tmp;
  }
#line 37
  rg->amp_ = (int )tmp___0;
#line 38
  return;
}
}
#line 29 "../../src/utils/quant_levels_utils.h"
int QuantizeLevels(uint8_t *data , int width , int height , int num_levels , uint64_t *sse ) ;
#line 27 "/root/patron-new/new_3/src/utils/quant_levels_utils.c"
int QuantizeLevels(uint8_t *data , int width , int height , int num_levels , uint64_t *sse ) 
{ 
  int freq[256] ;
  unsigned int tmp ;
  int q_level[256] ;
  unsigned int tmp___0 ;
  double inv_q_level[256] ;
  unsigned int tmp___1 ;
  int min_s ;
  int max_s ;
  size_t data_size ;
  int i ;
  int num_levels_in ;
  int iter ;
  double last_err ;
  double err ;
  double err_threshold ;
  size_t n ;
  double q_sum[256] ;
  unsigned int tmp___2 ;
  double q_count[256] ;
  unsigned int tmp___3 ;
  int s ;
  int slot ;
  double count ;
  double error ;
  uint8_t map[256] ;
  int s___0 ;
  size_t n___0 ;
  int slot___0 ;

  {
#line 29
  freq[0] = 0;
#line 29
  tmp = 1U;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;

#line 29
    if (tmp >= 256U) {
#line 29
      goto while_break;
    }
#line 29
    freq[tmp] = 0;
#line 29
    tmp ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break: 
#line 30
  q_level[0] = 0;
#line 30
  tmp___0 = 1U;
  {
#line 30
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 30
    if (tmp___0 >= 256U) {
#line 30
      goto while_break___0;
    }
#line 30
    q_level[tmp___0] = 0;
#line 30
    tmp___0 ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___0: 
#line 31
  inv_q_level[0] = (double )0;
#line 31
  tmp___1 = 1U;
  {
#line 31
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 31
    if (tmp___1 >= 256U) {
#line 31
      goto while_break___1;
    }
#line 31
    inv_q_level[tmp___1] = (double )0;
#line 31
    tmp___1 ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___1: 
#line 32
  min_s = 255;
#line 32
  max_s = 0;
#line 33
  data_size = (size_t )(height * width);
#line 35
  last_err = 1e+38;
#line 35
  err = 0.;
#line 36
  err_threshold = 0.000100000000001 * (double )data_size;
#line 38
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 39
    return (0);
  }
#line 42
  if (width <= 0) {
#line 43
    return (0);
  } else
#line 42
  if (height <= 0) {
#line 43
    return (0);
  }
#line 46
  if (num_levels < 2) {
#line 47
    return (0);
  } else
#line 46
  if (num_levels > 256) {
#line 47
    return (0);
  }
#line 52
  num_levels_in = 0;
#line 53
  n = (size_t )0;
  {
#line 53
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 53
    if (! (n < data_size)) {
#line 53
      goto while_break___2;
    }
#line 54
    num_levels_in += freq[*(data + n)] == 0;
#line 55
    if (min_s > (int )*(data + n)) {
#line 55
      min_s = (int )*(data + n);
    }
#line 56
    if (max_s < (int )*(data + n)) {
#line 56
      max_s = (int )*(data + n);
    }
#line 57
    (freq[*(data + n)]) ++;
#line 53
    n ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___2: ;
#line 61
  if (num_levels_in <= num_levels) {
#line 61
    goto End;
  }
#line 64
  i = 0;
  {
#line 64
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 64
    if (! (i < num_levels)) {
#line 64
      goto while_break___3;
    }
#line 65
    inv_q_level[i] = (double )min_s + ((double )(max_s - min_s) * (double )i) / (double )(num_levels - 1);
#line 64
    i ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___3: 
#line 69
  q_level[min_s] = 0;
#line 70
  q_level[max_s] = num_levels - 1;
#line 75
  iter = 0;
  {
#line 75
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 75
    if (! (iter < 6)) {
#line 75
      goto while_break___4;
    }
#line 76
    q_sum[0] = (double )0;
#line 76
    tmp___2 = 1U;
    {
#line 76
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 76
      if (tmp___2 >= 256U) {
#line 76
        goto while_break___5;
      }
#line 76
      q_sum[tmp___2] = (double )0;
#line 76
      tmp___2 ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___5: 
#line 77
    q_count[0] = (double )0;
#line 77
    tmp___3 = 1U;
    {
#line 77
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 77
      if (tmp___3 >= 256U) {
#line 77
        goto while_break___6;
      }
#line 77
      q_count[tmp___3] = (double )0;
#line 77
      tmp___3 ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___6: 
#line 78
    slot = 0;
#line 81
    s = min_s;
    {
#line 81
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 81
      if (! (s <= max_s)) {
#line 81
        goto while_break___7;
      }
      {
#line 83
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 83
        if (slot < num_levels - 1) {
#line 83
          if (! ((double )(2 * s) > inv_q_level[slot] + inv_q_level[slot + 1])) {
#line 83
            goto while_break___8;
          }
        } else {
#line 83
          goto while_break___8;
        }
#line 85
        slot ++;
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___8: ;
#line 87
      if (freq[s] > 0) {
#line 88
        q_sum[slot] += (double )(s * freq[s]);
#line 89
        q_count[slot] += (double )freq[s];
      }
#line 91
      q_level[s] = slot;
#line 81
      s ++;
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___7: ;
#line 95
    if (num_levels > 2) {
#line 96
      slot = 1;
      {
#line 96
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 96
        if (! (slot < num_levels - 1)) {
#line 96
          goto while_break___9;
        }
#line 97
        count = q_count[slot];
#line 98
        if (count > 0.) {
#line 99
          inv_q_level[slot] = q_sum[slot] / count;
        }
#line 96
        slot ++;
      }
      while_break___23: /* CIL Label */ ;
      }
      while_break___9: ;
    }
#line 105
    err = 0.;
#line 106
    s = min_s;
    {
#line 106
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 106
      if (! (s <= max_s)) {
#line 106
        goto while_break___10;
      }
#line 107
      error = (double )s - inv_q_level[q_level[s]];
#line 108
      err += ((double )freq[s] * error) * error;
#line 106
      s ++;
    }
    while_break___24: /* CIL Label */ ;
    }
    while_break___10: ;
#line 113
    if (last_err - err < err_threshold) {
#line 113
      goto while_break___4;
    }
#line 114
    last_err = err;
#line 75
    iter ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___4: 
#line 125
  s___0 = min_s;
  {
#line 125
  while (1) {
    while_continue___11: /* CIL Label */ ;

#line 125
    if (! (s___0 <= max_s)) {
#line 125
      goto while_break___11;
    }
#line 126
    slot___0 = q_level[s___0];
#line 127
    map[s___0] = (uint8_t )(inv_q_level[slot___0] + 0.5);
#line 125
    s___0 ++;
  }
  while_break___25: /* CIL Label */ ;
  }
  while_break___11: 
#line 130
  n___0 = (size_t )0;
  {
#line 130
  while (1) {
    while_continue___12: /* CIL Label */ ;

#line 130
    if (! (n___0 < data_size)) {
#line 130
      goto while_break___12;
    }
#line 131
    *(data + n___0) = map[*(data + n___0)];
#line 130
    n___0 ++;
  }
  while_break___26: /* CIL Label */ ;
  }
  while_break___12: ;
  End: 
#line 136
  if ((unsigned long )sse != (unsigned long )((void *)0)) {
#line 136
    *sse = (uint64_t )err;
  }
#line 138
  return (1);
}
}
#line 28 "../../src/utils/quant_levels_dec_utils.h"
int WebPDequantizeLevels(uint8_t *data , int width , int height , int stride , int strength ) ;
#line 75 "/root/patron-new/new_3/src/utils/quant_levels_dec_utils.c"
__inline static uint8_t clip_8b(int v ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 76
  if (! (v & (int )(4294967295U << 8))) {
#line 76
    tmp___0 = (unsigned int )((uint8_t )v);
  } else {
#line 76
    if (v < 0) {
#line 76
      tmp = 0U;
    } else {
#line 76
      tmp = 255U;
    }
#line 76
    tmp___0 = tmp;
  }
#line 76
  return ((uint8_t )tmp___0);
}
}
#line 81 "/root/patron-new/new_3/src/utils/quant_levels_dec_utils.c"
static void VFilter(SmoothParams *p ) 
{ 
  uint8_t *src ;
  int w ;
  uint16_t *cur ;
  uint16_t *top ;
  uint16_t *out ;
  uint16_t sum ;
  int x ;
  uint16_t new_value ;

  {
#line 82
  src = p->src_;
#line 83
  w = p->width_;
#line 84
  cur = p->cur_;
#line 85
  top = p->top_;
#line 86
  out = p->end_;
#line 87
  sum = (uint16_t )0;
#line 90
  x = 0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;

#line 90
    if (! (x < w)) {
#line 90
      goto while_break;
    }
#line 92
    sum = (uint16_t )((int )sum + (int )*(src + x));
#line 93
    new_value = (uint16_t )((int )*(top + x) + (int )sum);
#line 94
    *(out + x) = (uint16_t )((int )new_value - (int )*(cur + x));
#line 95
    *(cur + x) = new_value;
#line 90
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 98
  p->top_ = p->cur_;
#line 99
  p->cur_ += w;
#line 100
  if ((unsigned long )p->cur_ == (unsigned long )p->end_) {
#line 100
    p->cur_ = p->start_;
  }
#line 103
  if (p->row_ >= 0) {
#line 103
    if (p->row_ < p->height_ - 1) {
#line 104
      p->src_ += p->stride_;
    }
  }
#line 107
  return;
}
}
#line 110 "/root/patron-new/new_3/src/utils/quant_levels_dec_utils.c"
static void HFilter(SmoothParams *p ) 
{ 
  uint16_t *in ;
  uint16_t *out ;
  uint32_t scale ;
  int w ;
  int r ;
  int x ;
  uint16_t delta ;
  uint16_t delta___0 ;
  uint16_t delta___1 ;

  {
#line 111
  in = p->end_;
#line 112
  out = p->average_;
#line 113
  scale = (uint32_t )p->scale_;
#line 114
  w = p->width_;
#line 115
  r = p->radius_;
#line 118
  x = 0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;

#line 118
    if (! (x <= r)) {
#line 118
      goto while_break;
    }
#line 119
    delta = (uint16_t )((int )*(in + ((x + r) - 1)) + (int )*(in + (r - x)));
#line 120
    *(out + x) = (uint16_t )((unsigned int )delta * scale >> 16);
#line 118
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 122
    if (! (x < w - r)) {
#line 122
      goto while_break___0;
    }
#line 123
    delta___0 = (uint16_t )((int )*(in + (x + r)) - (int )*(in + ((x - r) - 1)));
#line 124
    *(out + x) = (uint16_t )((unsigned int )delta___0 * scale >> 16);
#line 122
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
  {
#line 126
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 126
    if (! (x < w)) {
#line 126
      goto while_break___1;
    }
#line 127
    delta___1 = (uint16_t )((2 * (int )*(in + (w - 1)) - (int )*(in + (((2 * w - 2) - r) - x))) - (int )*(in + ((x - r) - 1)));
#line 129
    *(out + x) = (uint16_t )((unsigned int )delta___1 * scale >> 16);
#line 126
    x ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: ;
#line 130
  return;
}
}
#line 134 "/root/patron-new/new_3/src/utils/quant_levels_dec_utils.c"
static void ApplyFilter(SmoothParams *p ) 
{ 
  uint16_t *average ;
  int w ;
  int16_t *correction ;
  uint8_t *dst ;
  int x ;
  int v ;
  int c ;

  {
#line 135
  average = p->average_;
#line 136
  w = p->width_;
#line 137
  correction = p->correction_;
#line 141
  dst = p->dst_;
#line 143
  x = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;

#line 143
    if (! (x < w)) {
#line 143
      goto while_break;
    }
#line 144
    v = (int )*(dst + x);
#line 145
    if (v < p->max_) {
#line 145
      if (v > p->min_) {
        {
#line 146
        c = v + (int )*(correction + ((int )*(average + x) - (v << 2)));
#line 150
        *(dst + x) = clip_8b(c);
        }
      }
    }
#line 143
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 154
  p->dst_ += p->stride_;
#line 155
  return;
}
}
#line 160 "/root/patron-new/new_3/src/utils/quant_levels_dec_utils.c"
static void InitCorrectionLUT(int16_t *lut , int min_dist ) 
{ 
  int threshold1 ;
  int threshold2 ;
  int max_threshold ;
  int delta ;
  int i ;
  int c ;
  int tmp ;
  int tmp___0 ;

  {
#line 167
  threshold1 = min_dist << 2;
#line 168
  threshold2 = 3 * threshold1 >> 2;
#line 169
  max_threshold = threshold2;
#line 170
  delta = threshold1 - threshold2;
#line 172
  i = 1;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;

#line 172
    if (! (i <= (1 << 10) - 1)) {
#line 172
      goto while_break;
    }
#line 173
    if (i <= threshold2) {
#line 173
      tmp___0 = i;
    } else {
#line 173
      if (i < threshold1) {
#line 173
        tmp = (max_threshold * (threshold1 - i)) / delta;
      } else {
#line 173
        tmp = 0;
      }
#line 173
      tmp___0 = tmp;
    }
#line 173
    c = tmp___0;
#line 176
    c >>= 2;
#line 177
    *(lut + i) = (int16_t )c;
#line 178
    *(lut + - i) = (int16_t )(- c);
#line 172
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 180
  *(lut + 0) = (int16_t )0;
#line 181
  return;
}
}
#line 183 "/root/patron-new/new_3/src/utils/quant_levels_dec_utils.c"
static void CountLevels(SmoothParams *p ) 
{ 
  int i ;
  int j ;
  int last_level ;
  uint8_t used_levels[256] ;
  unsigned int tmp ;
  uint8_t *data ;
  int v ;
  int level_dist ;

  {
#line 185
  used_levels[0] = (uint8_t )0;
#line 185
  tmp = 1U;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;

#line 185
    if (tmp >= 256U) {
#line 185
      goto while_break;
    }
#line 185
    used_levels[tmp] = (uint8_t )0;
#line 185
    tmp ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 186
  data = p->src_;
#line 187
  p->min_ = 255;
#line 188
  p->max_ = 0;
#line 189
  j = 0;
  {
#line 189
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 189
    if (! (j < p->height_)) {
#line 189
      goto while_break___0;
    }
#line 190
    i = 0;
    {
#line 190
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 190
      if (! (i < p->width_)) {
#line 190
        goto while_break___1;
      }
#line 191
      v = (int )*(data + i);
#line 192
      if (v < p->min_) {
#line 192
        p->min_ = v;
      }
#line 193
      if (v > p->max_) {
#line 193
        p->max_ = v;
      }
#line 194
      used_levels[v] = (uint8_t )1;
#line 190
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 196
    data += p->stride_;
#line 189
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
#line 199
  p->min_level_dist_ = p->max_ - p->min_;
#line 200
  last_level = -1;
#line 201
  i = 0;
  {
#line 201
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 201
    if (! (i < 256)) {
#line 201
      goto while_break___2;
    }
#line 202
    if (used_levels[i]) {
#line 203
      (p->num_levels_) ++;
#line 204
      if (last_level >= 0) {
#line 205
        level_dist = i - last_level;
#line 206
        if (level_dist < p->min_level_dist_) {
#line 207
          p->min_level_dist_ = level_dist;
        }
      }
#line 210
      last_level = i;
    }
#line 201
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 205
  return;
}
}
#line 216 "/root/patron-new/new_3/src/utils/quant_levels_dec_utils.c"
static int InitParams(uint8_t *data , int width , int height , int stride , int radius ,
                      SmoothParams *p ) 
{ 
  int R ;
  size_t size_scratch_m ;
  size_t size_m ;
  size_t size_lut ;
  size_t total_size ;
  uint8_t *mem ;
  void *__cil_tmp13 ;

  {
  {
#line 218
  R = 2 * radius + 1;
#line 220
  size_scratch_m = (unsigned long )((R + 1) * width) * sizeof(*(p->start_));
#line 221
  size_m = (unsigned long )width * sizeof(*(p->average_));
#line 222
  size_lut = (unsigned long )(1 + 2 * ((1 << 10) - 1)) * sizeof(*(p->correction_));
#line 223
  total_size = (size_scratch_m + size_m) + size_lut;
#line 224
  __cil_tmp13 = WebPSafeMalloc((uint64_t )1U, total_size);
#line 224
  mem = (uint8_t *)__cil_tmp13;
  }
#line 226
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
#line 226
    return (0);
  }
  {
#line 227
  p->mem_ = (void *)mem;
#line 229
  p->start_ = (uint16_t *)mem;
#line 230
  p->cur_ = p->start_;
#line 231
  p->end_ = p->start_ + R * width;
#line 232
  p->top_ = p->end_ - width;
#line 233
  memset((void *)p->top_, 0, (unsigned long )width * sizeof(*(p->top_)));
#line 234
  mem += size_scratch_m;
#line 236
  p->average_ = (uint16_t *)mem;
#line 237
  mem += size_m;
#line 239
  p->width_ = width;
#line 240
  p->height_ = height;
#line 241
  p->stride_ = stride;
#line 242
  p->src_ = data;
#line 243
  p->dst_ = data;
#line 244
  p->radius_ = radius;
#line 245
  p->scale_ = (1 << 18) / (R * R);
#line 246
  p->row_ = - radius;
#line 249
  CountLevels(p);
#line 252
  p->correction_ = (int16_t *)mem + ((1 << 10) - 1);
#line 253
  InitCorrectionLUT(p->correction_, p->min_level_dist_);
  }
#line 255
  return (1);
}
}
#line 258 "/root/patron-new/new_3/src/utils/quant_levels_dec_utils.c"
static void CleanupParams(SmoothParams *p ) 
{ 


  {
  {
#line 259
  WebPSafeFree(p->mem_);
  }
#line 261
  return;
}
}
#line 262 "/root/patron-new/new_3/src/utils/quant_levels_dec_utils.c"
int WebPDequantizeLevels(uint8_t *data , int width , int height , int stride , int strength ) 
{ 
  int radius ;
  SmoothParams p ;
  int __cil_tmp8 ;

  {
#line 264
  radius = (4 * strength) / 100;
#line 266
  if (strength < 0) {
#line 266
    return (0);
  } else
#line 266
  if (strength > 100) {
#line 266
    return (0);
  }
#line 267
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 267
    return (0);
  } else
#line 267
  if (width <= 0) {
#line 267
    return (0);
  } else
#line 267
  if (height <= 0) {
#line 267
    return (0);
  }
#line 270
  if (2 * radius + 1 > width) {
#line 270
    radius = (width - 1) >> 1;
  }
#line 271
  if (2 * radius + 1 > height) {
#line 271
    radius = (height - 1) >> 1;
  }
#line 273
  if (radius > 0) {
    {
#line 275
    memset((void *)(& p), 0, sizeof(p));
#line 276
    __cil_tmp8 = InitParams(data, width, height, stride, radius, & p);
    }
#line 276
    if (! __cil_tmp8) {
#line 276
      return (0);
    }
#line 277
    if (p.num_levels_ > 2) {
      {
#line 278
      while (1) {
        while_continue: /* CIL Label */ ;

#line 278
        if (! (p.row_ < p.height_)) {
#line 278
          goto while_break;
        }
        {
#line 279
        VFilter(& p);
        }
#line 282
        if (p.row_ >= p.radius_) {
          {
#line 283
          HFilter(& p);
#line 284
          ApplyFilter(& p);
          }
        }
#line 278
        (p.row_) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: ;
    }
    {
#line 288
    CleanupParams(& p);
    }
  }
#line 290
  return (1);
}
}
#line 71 "../../src/utils/huffman_utils.h"
HTreeGroup *VP8LHtreeGroupsNew(int num_htree_groups ) ;
#line 74
void VP8LHtreeGroupsFree(HTreeGroup *htree_groups ) ;
#line 83
int VP8LBuildHuffmanTable(HuffmanCode *root_table , int root_bits , int const   *code_lengths ,
                          int code_lengths_size ) ;
#line 25 "/root/patron-new/new_3/src/utils/huffman_utils.c"
HTreeGroup *VP8LHtreeGroupsNew(int num_htree_groups ) 
{ 
  HTreeGroup *htree_groups ;
  void *__cil_tmp3 ;

  {
  {
#line 26
  __cil_tmp3 = WebPSafeMalloc((uint64_t )num_htree_groups, sizeof(*htree_groups));
#line 26
  htree_groups = (HTreeGroup *)__cil_tmp3;
  }
#line 28
  if ((unsigned long )htree_groups == (unsigned long )((void *)0)) {
#line 29
    return ((HTreeGroup *)((void *)0));
  }
#line 32
  return (htree_groups);
}
}
#line 35 "/root/patron-new/new_3/src/utils/huffman_utils.c"
void VP8LHtreeGroupsFree(HTreeGroup *htree_groups ) 
{ 


  {
#line 36
  if ((unsigned long )htree_groups != (unsigned long )((void *)0)) {
    {
#line 37
    WebPSafeFree((void *)htree_groups);
    }
  }
#line 40
  return;
}
}
#line 43 "/root/patron-new/new_3/src/utils/huffman_utils.c"
__inline static uint32_t GetNextKey(uint32_t key , int len ) 
{ 
  uint32_t step ;
  uint32_t tmp ;

  {
#line 44
  step = (uint32_t )(1 << (len - 1));
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;

#line 45
    if (! (key & step)) {
#line 45
      goto while_break;
    }
#line 46
    step >>= 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 48
  if (step) {
#line 48
    tmp = (key & (step - 1U)) + step;
  } else {
#line 48
    tmp = key;
  }
#line 48
  return (tmp);
}
}
#line 53 "/root/patron-new/new_3/src/utils/huffman_utils.c"
__inline static void ReplicateValue(HuffmanCode *table , int step , int end , HuffmanCode code ) 
{ 


  {
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    end -= step;
#line 59
    *(table + end) = code;
#line 57
    if (! (end > 0)) {
#line 57
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 62
  return;
}
}
#line 66 "/root/patron-new/new_3/src/utils/huffman_utils.c"
__inline static int NextTableBitSize(int const   *count , int len , int root_bits ) 
{ 
  int left ;

  {
#line 68
  left = 1 << (len - root_bits);
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;

#line 69
    if (! (len < 15)) {
#line 69
      goto while_break;
    }
#line 70
    left -= (int )*(count + len);
#line 71
    if (left <= 0) {
#line 71
      goto while_break;
    }
#line 72
    len ++;
#line 73
    left <<= 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 75
  return (len - root_bits);
}
}
#line 80 "/root/patron-new/new_3/src/utils/huffman_utils.c"
static int BuildHuffmanTable(HuffmanCode *root_table , int root_bits , int const   *code_lengths ,
                             int code_lengths_size , uint16_t *sorted ) 
{ 
  HuffmanCode *table ;
  int total_size ;
  int len ;
  int symbol ;
  int count[16] ;
  unsigned int tmp ;
  int offset[16] ;
  int symbol_code_length ;
  int __cil_tmp14 ;
  HuffmanCode code ;
  int step ;
  uint32_t low ;
  uint32_t mask ;
  uint32_t key ;
  int num_nodes ;
  int num_open ;
  int table_bits ;
  int table_size ;
  HuffmanCode code___0 ;
  int __cil_tmp26 ;
  HuffmanCode code___1 ;
  int __cil_tmp30 ;

  {
#line 83
  table = root_table;
#line 84
  total_size = 1 << root_bits;
#line 88
  count[0] = 0;
#line 88
  tmp = 1U;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;

#line 88
    if (tmp >= 16U) {
#line 88
      goto while_break;
    }
#line 88
    count[tmp] = 0;
#line 88
    tmp ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: 
#line 99
  symbol = 0;
  {
#line 99
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 99
    if (! (symbol < code_lengths_size)) {
#line 99
      goto while_break___0;
    }
#line 100
    if (*(code_lengths + symbol) > 15) {
#line 101
      return (0);
    }
#line 103
    (count[*(code_lengths + symbol)]) ++;
#line 99
    symbol ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___0: ;
#line 107
  if (count[0] == code_lengths_size) {
#line 108
    return (0);
  }
#line 112
  offset[1] = 0;
#line 113
  len = 1;
  {
#line 113
  while (1) {
    while_continue___7: /* CIL Label */ ;

#line 113
    if (! (len < 15)) {
#line 113
      goto while_break___1;
    }
#line 114
    if (count[len] > 1 << len) {
#line 115
      return (0);
    }
#line 117
    offset[len + 1] = offset[len] + count[len];
#line 113
    len ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___1: 
#line 121
  symbol = 0;
  {
#line 121
  while (1) {
    while_continue___8: /* CIL Label */ ;

#line 121
    if (! (symbol < code_lengths_size)) {
#line 121
      goto while_break___2;
    }
#line 122
    symbol_code_length = (int )*(code_lengths + symbol);
#line 123
    if (*(code_lengths + symbol) > 0) {
#line 124
      if ((unsigned long )sorted != (unsigned long )((void *)0)) {
#line 125
        __cil_tmp14 = offset[symbol_code_length];
#line 125
        (offset[symbol_code_length]) ++;
#line 125
        *(sorted + __cil_tmp14) = (uint16_t )symbol;
      } else {
#line 127
        (offset[symbol_code_length]) ++;
      }
    }
#line 121
    symbol ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___2: ;
#line 133
  if (offset[15] == 1) {
#line 134
    if ((unsigned long )sorted != (unsigned long )((void *)0)) {
      {
#line 136
      code.bits = (uint8_t )0;
#line 137
      code.value = *(sorted + 0);
#line 138
      ReplicateValue(table, 1, total_size, code);
      }
    }
#line 140
    return (total_size);
  }
#line 145
  low = (uint32_t )-1;
#line 146
  mask = (uint32_t )(total_size - 1);
#line 147
  key = (uint32_t )0;
#line 148
  num_nodes = 1;
#line 149
  num_open = 1;
#line 150
  table_bits = root_bits;
#line 151
  table_size = 1 << table_bits;
#line 152
  symbol = 0;
#line 154
  step = 2;
#line 154
  len = 1;
  {
#line 154
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___3: ;
#line 154
    if (! (len <= root_bits)) {
#line 154
      goto while_break___3;
    }
#line 155
    num_open <<= 1;
#line 156
    num_nodes += num_open;
#line 157
    num_open -= count[len];
#line 158
    if (num_open < 0) {
#line 159
      return (0);
    }
#line 161
    if ((unsigned long )root_table == (unsigned long )((void *)0)) {
#line 161
      goto while_continue___3;
    }
    {
#line 162
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 162
      if (! (count[len] > 0)) {
#line 162
        goto while_break___4;
      }
      {
#line 164
      code___0.bits = (uint8_t )len;
#line 165
      __cil_tmp26 = symbol;
#line 165
      symbol ++;
#line 165
      code___0.value = *(sorted + __cil_tmp26);
#line 166
      ReplicateValue(table + key, step, table_size, code___0);
#line 167
      key = GetNextKey(key, len);
#line 162
      (count[len]) --;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___4: 
#line 154
    step <<= 1;
#line 154
    len ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___3: 
#line 172
  step = 2;
#line 172
  len = root_bits + 1;
  {
#line 172
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___5: ;
#line 172
    if (! (len <= 15)) {
#line 172
      goto while_break___5;
    }
#line 174
    num_open <<= 1;
#line 175
    num_nodes += num_open;
#line 176
    num_open -= count[len];
#line 177
    if (num_open < 0) {
#line 178
      return (0);
    }
#line 180
    if ((unsigned long )root_table == (unsigned long )((void *)0)) {
#line 180
      goto while_continue___5;
    }
    {
#line 181
    while (1) {
      while_continue___12: /* CIL Label */ ;

#line 181
      if (! (count[len] > 0)) {
#line 181
        goto while_break___6;
      }
#line 183
      if ((key & mask) != low) {
        {
#line 184
        table += table_size;
#line 185
        table_bits = NextTableBitSize((int const   *)(count), len, root_bits);
#line 186
        table_size = 1 << table_bits;
#line 187
        total_size += table_size;
#line 188
        low = key & mask;
#line 189
        (root_table + low)->bits = (uint8_t )(table_bits + root_bits);
#line 190
        (root_table + low)->value = (uint16_t )((table - root_table) - (long )low);
        }
      }
      {
#line 192
      code___1.bits = (uint8_t )(len - root_bits);
#line 193
      __cil_tmp30 = symbol;
#line 193
      symbol ++;
#line 193
      code___1.value = *(sorted + __cil_tmp30);
#line 194
      ReplicateValue(table + (key >> root_bits), step, table_size, code___1);
#line 195
      key = GetNextKey(key, len);
#line 181
      (count[len]) --;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___6: 
#line 173
    step <<= 1;
#line 173
    len ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___5: ;
#line 200
  if (num_nodes != 2 * offset[15] - 1) {
#line 201
    return (0);
  }
#line 205
  return (total_size);
}
}
#line 214 "/root/patron-new/new_3/src/utils/huffman_utils.c"
int VP8LBuildHuffmanTable(HuffmanCode *root_table , int root_bits , int const   *code_lengths ,
                          int code_lengths_size ) 
{ 
  int total_size ;
  uint16_t sorted[512] ;
  uint16_t *sorted___0 ;
  void *__cil_tmp10 ;

  {
#line 218
  if ((unsigned long )root_table == (unsigned long )((void *)0)) {
    {
#line 219
    total_size = BuildHuffmanTable((HuffmanCode *)((void *)0), root_bits, code_lengths,
                                   code_lengths_size, (uint16_t *)((void *)0));
    }
  } else
#line 221
  if (code_lengths_size <= 512) {
    {
#line 224
    total_size = BuildHuffmanTable(root_table, root_bits, code_lengths, code_lengths_size,
                                   sorted);
    }
  } else {
    {
#line 227
    __cil_tmp10 = WebPSafeMalloc((uint64_t )code_lengths_size, sizeof(*sorted___0));
#line 227
    sorted___0 = (uint16_t *)__cil_tmp10;
    }
#line 229
    if ((unsigned long )sorted___0 == (unsigned long )((void *)0)) {
#line 229
      return (0);
    }
    {
#line 230
    total_size = BuildHuffmanTable(root_table, root_bits, code_lengths, code_lengths_size,
                                   sorted___0);
#line 232
    WebPSafeFree((void *)sorted___0);
    }
  }
#line 234
  return (total_size);
}
}
#line 46 "../../src/utils/huffman_encode_utils.h"
int VP8LCreateCompressedHuffmanTree(HuffmanTreeCode *tree , HuffmanTreeToken *tokens ,
                                    int max_tokens ) ;
#line 52
void VP8LCreateHuffmanTree(uint32_t *histogram , int tree_depth_limit , uint8_t *buf_rle ,
                           HuffmanTree *huff_tree , HuffmanTreeCode *huff_code ) ;
#line 25 "/root/patron-new/new_3/src/utils/huffman_encode_utils.c"
static int ValuesShouldBeCollapsedToStrideAverage(int a , int b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 26
  __cil_tmp3 = abs(a - b);
  }
#line 26
  return (__cil_tmp3 < 4);
}
}
#line 31 "/root/patron-new/new_3/src/utils/huffman_encode_utils.c"
static void OptimizeHuffmanForRle(int length , uint8_t *good_for_rle , uint32_t *counts ) 
{ 
  int i ;
  uint32_t symbol ;
  int stride ;
  int k ;
  uint32_t stride___0 ;
  uint32_t limit ;
  uint32_t sum ;
  int __cil_tmp11 ;
  uint32_t k___0 ;
  uint32_t count ;

  {
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;

#line 35
    if (! (length >= 0)) {
#line 35
      goto while_break;
    }
#line 36
    if (length == 0) {
#line 37
      return;
    }
#line 39
    if (*(counts + (length - 1)) != 0U) {
#line 41
      goto while_break;
    }
#line 35
    length --;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 50
  symbol = *(counts + 0);
#line 51
  stride = 0;
#line 52
  i = 0;
  {
#line 52
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 52
    if (! (i < length + 1)) {
#line 52
      goto while_break___0;
    }
#line 53
    if (i == length) {
      _L___1: 
#line 54
      if (symbol == 0U) {
#line 54
        if (stride >= 5) {
          _L: 
#line 57
          k = 0;
          {
#line 57
          while (1) {
            while_continue___1: /* CIL Label */ ;

#line 57
            if (! (k < stride)) {
#line 57
              goto while_break___1;
            }
#line 58
            *(good_for_rle + ((i - k) - 1)) = (uint8_t )1;
#line 57
            k ++;
          }
          while_break___6: /* CIL Label */ ;
          }
          while_break___1: ;
        } else {
#line 54
          goto _L___0;
        }
      } else
      _L___0: 
#line 54
      if (symbol != 0U) {
#line 54
        if (stride >= 7) {
#line 54
          goto _L;
        }
      }
#line 61
      stride = 1;
#line 62
      if (i != length) {
#line 63
        symbol = *(counts + i);
      }
    } else
#line 53
    if (*(counts + i) != symbol) {
#line 53
      goto _L___1;
    } else {
#line 66
      stride ++;
    }
#line 52
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
#line 72
  stride___0 = (uint32_t )0;
#line 73
  limit = *(counts + 0);
#line 74
  sum = (uint32_t )0;
#line 75
  i = 0;
  {
#line 75
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 75
    if (! (i < length + 1)) {
#line 75
      goto while_break___2;
    }
    {
#line 76
    __cil_tmp11 = ValuesShouldBeCollapsedToStrideAverage((int )*(counts + i), (int )limit);
    }
#line 76
    if (i == length) {
      _L___3: 
#line 79
      if (stride___0 >= 4U) {
        _L___2: 
#line 82
        count = (sum + stride___0 / 2U) / stride___0;
#line 83
        if (count < 1U) {
#line 84
          count = (uint32_t )1;
        }
#line 86
        if (sum == 0U) {
#line 88
          count = (uint32_t )0;
        }
#line 90
        k___0 = (uint32_t )0;
        {
#line 90
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 90
          if (! (k___0 < stride___0)) {
#line 90
            goto while_break___3;
          }
#line 93
          *(counts + (((unsigned int )i - k___0) - 1U)) = count;
#line 90
          k___0 ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: ;
      } else
#line 79
      if (stride___0 >= 3U) {
#line 79
        if (sum == 0U) {
#line 79
          goto _L___2;
        }
      }
#line 96
      stride___0 = (uint32_t )0;
#line 97
      sum = (uint32_t )0;
#line 98
      if (i < length - 3) {
#line 101
        limit = ((((*(counts + i) + *(counts + (i + 1))) + *(counts + (i + 2))) + *(counts + (i + 3))) + 2U) / 4U;
      } else
#line 103
      if (i < length) {
#line 104
        limit = *(counts + i);
      } else {
#line 106
        limit = (uint32_t )0;
      }
    } else
#line 76
    if ((int )*(good_for_rle + i)) {
#line 76
      goto _L___3;
    } else
#line 76
    if (i != 0) {
#line 76
      if ((int )*(good_for_rle + (i - 1))) {
#line 76
        goto _L___3;
      } else {
#line 76
        goto _L___5;
      }
    } else
    _L___5: 
#line 76
    if (! __cil_tmp11) {
#line 76
      goto _L___3;
    }
#line 109
    stride___0 ++;
#line 110
    if (i != length) {
#line 111
      sum += *(counts + i);
#line 112
      if (stride___0 >= 4U) {
#line 113
        limit = (sum + stride___0 / 2U) / stride___0;
      }
    }
#line 75
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: ;
#line 79
  return;
}
}
#line 122 "/root/patron-new/new_3/src/utils/huffman_encode_utils.c"
static int CompareHuffmanTrees(void const   *ptr1 , void const   *ptr2 ) 
{ 
  HuffmanTree *t1 ;
  HuffmanTree *t2 ;
  int tmp ;

  {
#line 123
  t1 = (HuffmanTree *)ptr1;
#line 124
  t2 = (HuffmanTree *)ptr2;
#line 125
  if (t1->total_count_ > t2->total_count_) {
#line 126
    return (-1);
  } else
#line 127
  if (t1->total_count_ < t2->total_count_) {
#line 128
    return (1);
  } else {
#line 131
    if (t1->value_ < t2->value_) {
#line 131
      tmp = -1;
    } else {
#line 131
      tmp = 1;
    }
#line 131
    return (tmp);
  }
}
}
#line 135 "/root/patron-new/new_3/src/utils/huffman_encode_utils.c"
static void SetBitDepths(HuffmanTree *tree , HuffmanTree *pool , uint8_t *bit_depths ,
                         int level ) 
{ 


  {
#line 138
  if (tree->pool_index_left_ >= 0) {
    {
#line 139
    SetBitDepths(pool + tree->pool_index_left_, pool, bit_depths, level + 1);
#line 140
    SetBitDepths(pool + tree->pool_index_right_, pool, bit_depths, level + 1);
    }
  } else {
#line 142
    *(bit_depths + tree->value_) = (uint8_t )level;
  }
#line 144
  return;
}
}
#line 165 "/root/patron-new/new_3/src/utils/huffman_encode_utils.c"
static void GenerateOptimalTree(uint32_t *histogram , int histogram_size , HuffmanTree *tree ,
                                int tree_depth_limit , uint8_t *bit_depths ) 
{ 
  uint32_t count_min ;
  HuffmanTree *tree_pool ;
  int tree_size_orig ;
  int i ;
  int tree_size ;
  int idx ;
  int j ;
  uint32_t count ;
  uint32_t tmp ;
  int tree_pool_size ;
  uint32_t count___0 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int k ;
  int max_depth ;

  {
#line 171
  tree_size_orig = 0;
#line 174
  i = 0;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;

#line 174
    if (! (i < histogram_size)) {
#line 174
      goto while_break;
    }
#line 175
    if (*(histogram + i) != 0U) {
#line 176
      tree_size_orig ++;
    }
#line 174
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 180
  if (tree_size_orig == 0) {
#line 181
    return;
  }
#line 184
  tree_pool = tree + tree_size_orig;
#line 191
  count_min = (uint32_t )1;
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 192
    tree_size = tree_size_orig;
#line 195
    idx = 0;
#line 197
    j = 0;
    {
#line 197
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 197
      if (! (j < histogram_size)) {
#line 197
        goto while_break___1;
      }
#line 198
      if (*(histogram + j) != 0U) {
#line 199
        if (*(histogram + j) < count_min) {
#line 199
          tmp = count_min;
        } else {
#line 199
          tmp = *(histogram + j);
        }
#line 199
        count = tmp;
#line 201
        (tree + idx)->total_count_ = count;
#line 202
        (tree + idx)->value_ = j;
#line 203
        (tree + idx)->pool_index_left_ = -1;
#line 204
        (tree + idx)->pool_index_right_ = -1;
#line 205
        idx ++;
      }
#line 197
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 210
    qsort((void *)tree, (size_t )tree_size, sizeof(*tree), & CompareHuffmanTrees);
    }
#line 212
    if (tree_size > 1) {
#line 213
      tree_pool_size = 0;
      {
#line 214
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 214
        if (! (tree_size > 1)) {
#line 214
          goto while_break___2;
        }
#line 216
        __cil_tmp17 = tree_pool_size;
#line 216
        tree_pool_size ++;
#line 216
        *(tree_pool + __cil_tmp17) = *(tree + (tree_size - 1));
#line 217
        __cil_tmp18 = tree_pool_size;
#line 217
        tree_pool_size ++;
#line 217
        *(tree_pool + __cil_tmp18) = *(tree + (tree_size - 2));
#line 218
        count___0 = (tree_pool + (tree_pool_size - 1))->total_count_ + (tree_pool + (tree_pool_size - 2))->total_count_;
#line 220
        tree_size -= 2;
#line 224
        k = 0;
        {
#line 224
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 224
          if (! (k < tree_size)) {
#line 224
            goto while_break___3;
          }
#line 225
          if ((tree + k)->total_count_ <= count___0) {
#line 226
            goto while_break___3;
          }
#line 224
          k ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: 
        {
#line 229
        memmove((void *)(tree + (k + 1)), (void const   *)(tree + k), (unsigned long )(tree_size - k) * sizeof(*tree));
#line 230
        (tree + k)->total_count_ = count___0;
#line 231
        (tree + k)->value_ = -1;
#line 233
        (tree + k)->pool_index_left_ = tree_pool_size - 1;
#line 234
        (tree + k)->pool_index_right_ = tree_pool_size - 2;
#line 235
        tree_size ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: 
      {
#line 238
      SetBitDepths(tree + 0, tree_pool, bit_depths, 0);
      }
    } else
#line 239
    if (tree_size == 1) {
#line 240
      *(bit_depths + (tree + 0)->value_) = (uint8_t )1;
    }
#line 245
    max_depth = (int )*(bit_depths + 0);
#line 246
    j = 1;
    {
#line 246
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 246
      if (! (j < histogram_size)) {
#line 246
        goto while_break___4;
      }
#line 247
      if (max_depth < (int )*(bit_depths + j)) {
#line 248
        max_depth = (int )*(bit_depths + j);
      }
#line 246
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: ;
#line 251
    if (max_depth <= tree_depth_limit) {
#line 252
      goto while_break___0;
    }
#line 191
    count_min *= 2U;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: ;
#line 195
  return;
}
}
#line 261 "/root/patron-new/new_3/src/utils/huffman_encode_utils.c"
static HuffmanTreeToken *CodeRepeatedValues(int repetitions , HuffmanTreeToken *tokens ,
                                            int value , int prev_value ) 
{ 
  int i ;

  {
#line 265
  if (value != prev_value) {
#line 266
    tokens->code = (uint8_t )value;
#line 267
    tokens->extra_bits = (uint8_t )0;
#line 268
    tokens ++;
#line 269
    repetitions --;
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;

#line 271
    if (! (repetitions >= 1)) {
#line 271
      goto while_break;
    }
#line 272
    if (repetitions < 3) {
#line 274
      i = 0;
      {
#line 274
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 274
        if (! (i < repetitions)) {
#line 274
          goto while_break___0;
        }
#line 275
        tokens->code = (uint8_t )value;
#line 276
        tokens->extra_bits = (uint8_t )0;
#line 277
        tokens ++;
#line 274
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
#line 279
      goto while_break;
    } else
#line 280
    if (repetitions < 7) {
#line 281
      tokens->code = (uint8_t )16;
#line 282
      tokens->extra_bits = (uint8_t )(repetitions - 3);
#line 283
      tokens ++;
#line 284
      goto while_break;
    } else {
#line 286
      tokens->code = (uint8_t )16;
#line 287
      tokens->extra_bits = (uint8_t )3;
#line 288
      tokens ++;
#line 289
      repetitions -= 6;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 292
  return (tokens);
}
}
#line 295 "/root/patron-new/new_3/src/utils/huffman_encode_utils.c"
static HuffmanTreeToken *CodeRepeatedZeros(int repetitions , HuffmanTreeToken *tokens ) 
{ 
  int i ;

  {
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;

#line 297
    if (! (repetitions >= 1)) {
#line 297
      goto while_break;
    }
#line 298
    if (repetitions < 3) {
#line 300
      i = 0;
      {
#line 300
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 300
        if (! (i < repetitions)) {
#line 300
          goto while_break___0;
        }
#line 301
        tokens->code = (uint8_t )0;
#line 302
        tokens->extra_bits = (uint8_t )0;
#line 303
        tokens ++;
#line 300
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
#line 305
      goto while_break;
    } else
#line 306
    if (repetitions < 11) {
#line 307
      tokens->code = (uint8_t )17;
#line 308
      tokens->extra_bits = (uint8_t )(repetitions - 3);
#line 309
      tokens ++;
#line 310
      goto while_break;
    } else
#line 311
    if (repetitions < 139) {
#line 312
      tokens->code = (uint8_t )18;
#line 313
      tokens->extra_bits = (uint8_t )(repetitions - 11);
#line 314
      tokens ++;
#line 315
      goto while_break;
    } else {
#line 317
      tokens->code = (uint8_t )18;
#line 318
      tokens->extra_bits = (uint8_t )127;
#line 319
      tokens ++;
#line 320
      repetitions -= 138;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 323
  return (tokens);
}
}
#line 326 "/root/patron-new/new_3/src/utils/huffman_encode_utils.c"
int VP8LCreateCompressedHuffmanTree(HuffmanTreeCode *tree , HuffmanTreeToken *tokens ,
                                    int max_tokens ) 
{ 
  HuffmanTreeToken *starting_token ;
  HuffmanTreeToken *ending_token ;
  int depth_size ;
  int prev_value ;
  int i ;
  int value ;
  int k ;
  int runs ;

  {
#line 328
  starting_token = tokens;
#line 329
  ending_token = tokens + max_tokens;
#line 330
  depth_size = tree->num_symbols;
#line 331
  prev_value = 8;
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;

#line 334
    if (! (i < depth_size)) {
#line 334
      goto while_break;
    }
#line 335
    value = (int )*(tree->code_lengths + i);
#line 336
    k = i + 1;
    {
#line 338
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 338
      if (k < depth_size) {
#line 338
        if (! ((int )*(tree->code_lengths + k) == value)) {
#line 338
          goto while_break___0;
        }
      } else {
#line 338
        goto while_break___0;
      }
#line 338
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 339
    runs = k - i;
#line 340
    if (value == 0) {
      {
#line 341
      tokens = CodeRepeatedZeros(runs, tokens);
      }
    } else {
      {
#line 343
      tokens = CodeRepeatedValues(runs, tokens, value, prev_value);
#line 344
      prev_value = value;
      }
    }
#line 346
    i += runs;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 350
  return ((int )(tokens - starting_token));
}
}
#line 356 "/root/patron-new/new_3/src/utils/huffman_encode_utils.c"
static uint8_t kReversedBits[16]  = 
#line 356
  {      (uint8_t )0,      (uint8_t )8,      (uint8_t )4,      (uint8_t )12, 
        (uint8_t )2,      (uint8_t )10,      (uint8_t )6,      (uint8_t )14, 
        (uint8_t )1,      (uint8_t )9,      (uint8_t )5,      (uint8_t )13, 
        (uint8_t )3,      (uint8_t )11,      (uint8_t )7,      (uint8_t )15};
#line 361 "/root/patron-new/new_3/src/utils/huffman_encode_utils.c"
static uint32_t ReverseBits(int num_bits , uint32_t bits ) 
{ 
  uint32_t retval ;
  int i ;

  {
#line 362
  retval = (uint32_t )0;
#line 363
  i = 0;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;

#line 364
    if (! (i < num_bits)) {
#line 364
      goto while_break;
    }
#line 365
    i += 4;
#line 366
    retval |= (unsigned int )((int )kReversedBits[bits & 15U] << (16 - i));
#line 367
    bits >>= 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 369
  retval >>= 16 - num_bits;
#line 370
  return (retval);
}
}
#line 374 "/root/patron-new/new_3/src/utils/huffman_encode_utils.c"
static void ConvertBitDepthsToSymbols(HuffmanTreeCode *tree ) 
{ 
  int i ;
  int len ;
  uint32_t next_code[16] ;
  int depth_count[16] ;
  unsigned int tmp ;
  int code_length ;
  uint32_t code ;
  int code_length___0 ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp11 ;

  {
#line 379
  depth_count[0] = 0;
#line 379
  tmp = 1U;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;

#line 379
    if (tmp >= 16U) {
#line 379
      goto while_break;
    }
#line 379
    depth_count[tmp] = 0;
#line 379
    tmp ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 382
  len = tree->num_symbols;
#line 383
  i = 0;
  {
#line 383
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 383
    if (! (i < len)) {
#line 383
      goto while_break___0;
    }
#line 384
    code_length = (int )*(tree->code_lengths + i);
#line 386
    (depth_count[code_length]) ++;
#line 383
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
#line 388
  depth_count[0] = 0;
#line 389
  next_code[0] = (uint32_t )0;
#line 391
  code = (uint32_t )0;
#line 392
  i = 1;
  {
#line 392
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 392
    if (! (i <= 15)) {
#line 392
      goto while_break___1;
    }
#line 393
    code = (code + (unsigned int )depth_count[i - 1]) << 1;
#line 394
    next_code[i] = code;
#line 392
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: 
#line 397
  i = 0;
  {
#line 397
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 397
    if (! (i < len)) {
#line 397
      goto while_break___2;
    }
    {
#line 398
    code_length___0 = (int )*(tree->code_lengths + i);
#line 399
    __cil_tmp10 = next_code[code_length___0];
#line 399
    (next_code[code_length___0]) ++;
#line 399
    __cil_tmp11 = ReverseBits(code_length___0, __cil_tmp10);
#line 399
    *(tree->codes + i) = (uint16_t )__cil_tmp11;
#line 397
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 401
  return;
}
}
#line 406 "/root/patron-new/new_3/src/utils/huffman_encode_utils.c"
void VP8LCreateHuffmanTree(uint32_t *histogram , int tree_depth_limit , uint8_t *buf_rle ,
                           HuffmanTree *huff_tree , HuffmanTreeCode *huff_code ) 
{ 
  int num_symbols ;

  {
  {
#line 409
  num_symbols = huff_code->num_symbols;
#line 410
  memset((void *)buf_rle, 0, (unsigned long )num_symbols * sizeof(*buf_rle));
#line 411
  OptimizeHuffmanForRle(num_symbols, buf_rle, histogram);
#line 412
  GenerateOptimalTree(histogram, num_symbols, huff_tree, tree_depth_limit, huff_code->code_lengths);
#line 415
  ConvertBitDepthsToSymbols(huff_code);
  }
#line 417
  return;
}
}
#line 25 "../../src/utils/filters_utils.h"
WEBP_FILTER_TYPE WebPEstimateBestFilter(uint8_t *data , int width , int height , int stride ) ;
#line 24 "/root/patron-new/new_3/src/utils/filters_utils.c"
__inline static int GradientPredictor(uint8_t a , uint8_t b , uint8_t c ) 
{ 
  int g ;
  int tmp ;
  int tmp___0 ;

  {
#line 25
  g = ((int )a + (int )b) - (int )c;
#line 26
  if ((g & -256) == 0) {
#line 26
    tmp___0 = g;
  } else {
#line 26
    if (g < 0) {
#line 26
      tmp = 0;
    } else {
#line 26
      tmp = 255;
    }
#line 26
    tmp___0 = tmp;
  }
#line 26
  return (tmp___0);
}
}
#line 29 "/root/patron-new/new_3/src/utils/filters_utils.c"
WEBP_FILTER_TYPE WebPEstimateBestFilter(uint8_t *data , int width , int height , int stride ) 
{ 
  int i ;
  int j ;
  int bins[4][16] ;
  uint8_t *p ;
  int mean ;
  int diff0 ;
  int __cil_tmp11 ;
  int diff1 ;
  int __cil_tmp13 ;
  int diff2 ;
  int __cil_tmp15 ;
  int grad_pred ;
  int __cil_tmp17 ;
  int diff3 ;
  int __cil_tmp19 ;
  int filter ;
  WEBP_FILTER_TYPE best_filter ;
  int best_score ;
  int score ;

  {
  {
#line 33
  memset((void *)(bins), 0, sizeof(bins));
#line 36
  j = 2;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;

#line 36
    if (! (j < height - 1)) {
#line 36
      goto while_break;
    }
#line 37
    p = data + j * stride;
#line 38
    mean = (int )*(p + 0);
#line 39
    i = 2;
    {
#line 39
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 39
      if (! (i < width - 1)) {
#line 39
        goto while_break___0;
      }
      {
#line 40
      __cil_tmp11 = abs((int )*(p + i) - mean);
#line 40
      diff0 = __cil_tmp11 >> 4;
#line 41
      __cil_tmp13 = abs((int )*(p + i) - (int )*(p + (i - 1)));
#line 41
      diff1 = __cil_tmp13 >> 4;
#line 42
      __cil_tmp15 = abs((int )*(p + i) - (int )*(p + (i - width)));
#line 42
      diff2 = __cil_tmp15 >> 4;
#line 43
      __cil_tmp17 = GradientPredictor(*(p + (i - 1)), *(p + (i - width)), *(p + ((i - width) - 1)));
#line 43
      grad_pred = __cil_tmp17;
#line 45
      __cil_tmp19 = abs((int )*(p + i) - grad_pred);
#line 45
      diff3 = __cil_tmp19 >> 4;
#line 46
      bins[0][diff0] = 1;
#line 47
      bins[1][diff1] = 1;
#line 48
      bins[2][diff2] = 1;
#line 49
      bins[3][diff3] = 1;
#line 50
      mean = ((3 * mean + (int )*(p + i)) + 2) >> 2;
#line 39
      i += 2;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 36
    j += 2;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 55
  best_filter = (WEBP_FILTER_TYPE )0;
#line 56
  best_score = 2147483647;
#line 57
  filter = 0;
  {
#line 57
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 57
    if (! (filter < 4)) {
#line 57
      goto while_break___1;
    }
#line 58
    score = 0;
#line 59
    i = 0;
    {
#line 59
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 59
      if (! (i < 16)) {
#line 59
        goto while_break___2;
      }
#line 60
      if (bins[filter][i] > 0) {
#line 61
        score += i;
      }
#line 59
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
#line 64
    if (score < best_score) {
#line 65
      best_score = score;
#line 66
      best_filter = (WEBP_FILTER_TYPE )filter;
    }
#line 57
    filter ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 69
  return (best_filter);
}
}
#line 23 "/root/patron-new/new_3/src/utils/color_cache_utils.c"
int VP8LColorCacheInit(VP8LColorCache *color_cache , int hash_bits ) 
{ 
  int hash_size ;
  void *__cil_tmp4 ;

  {
  {
#line 24
  hash_size = 1 << hash_bits;
#line 27
  __cil_tmp4 = WebPSafeCalloc((uint64_t )hash_size, sizeof(*(color_cache->colors_)));
#line 27
  color_cache->colors_ = (uint32_t *)__cil_tmp4;
  }
#line 29
  if ((unsigned long )color_cache->colors_ == (unsigned long )((void *)0)) {
#line 29
    return (0);
  }
#line 30
  color_cache->hash_shift_ = 32 - hash_bits;
#line 31
  color_cache->hash_bits_ = hash_bits;
#line 32
  return (1);
}
}
#line 35 "/root/patron-new/new_3/src/utils/color_cache_utils.c"
void VP8LColorCacheClear(VP8LColorCache *color_cache ) 
{ 


  {
#line 36
  if ((unsigned long )color_cache != (unsigned long )((void *)0)) {
    {
#line 37
    WebPSafeFree((void *)color_cache->colors_);
#line 38
    color_cache->colors_ = (uint32_t *)((void *)0);
    }
  }
#line 41
  return;
}
}
#line 42 "/root/patron-new/new_3/src/utils/color_cache_utils.c"
void VP8LColorCacheCopy(VP8LColorCache *src , VP8LColorCache *dst ) 
{ 


  {
  {
#line 47
  memcpy((void *)dst->colors_, (void const   *)src->colors_, (1UL << dst->hash_bits_) * sizeof(*(dst->colors_)));
  }
#line 49
  return;
}
}
#line 39 "../../src/utils/bit_writer_utils.h"
int VP8BitWriterInit(VP8BitWriter *bw , size_t expected_size ) ;
#line 41
uint8_t *VP8BitWriterFinish(VP8BitWriter *bw ) ;
#line 44
void VP8BitWriterWipeOut(VP8BitWriter *bw ) ;
#line 46
int VP8PutBit(VP8BitWriter *bw , int bit , int prob ) ;
#line 47
int VP8PutBitUniform(VP8BitWriter *bw , int bit ) ;
#line 48
void VP8PutBits(VP8BitWriter *bw , uint32_t value , int nb_bits ) ;
#line 49
void VP8PutSignedBits(VP8BitWriter *bw , int value , int nb_bits ) ;
#line 52
int VP8BitWriterAppend(VP8BitWriter *bw , uint8_t *data , size_t size ) ;
#line 56 "../../src/utils/bit_writer_utils.h"
__inline static uint64_t VP8BitWriterPos(VP8BitWriter *bw ) 
{ 
  uint64_t nb_bits ;

  {
#line 57
  nb_bits = (uint64_t )(8 + bw->nb_bits_);
#line 58
  return ((bw->pos_ + (unsigned long )bw->run_) * 8UL + nb_bits);
}
}
#line 62 "../../src/utils/bit_writer_utils.h"
__inline static uint8_t *VP8BitWriterBuf(VP8BitWriter *bw ) 
{ 


  {
#line 63
  return (bw->buf_);
}
}
#line 66 "../../src/utils/bit_writer_utils.h"
__inline static size_t VP8BitWriterSize(VP8BitWriter *bw ) 
{ 


  {
#line 67
  return (bw->pos_);
}
}
#line 103 "../../src/utils/bit_writer_utils.h"
__inline static size_t VP8LBitWriterNumBytes(VP8LBitWriter *bw ) 
{ 


  {
#line 104
  return ((size_t )((bw->cur_ - bw->buf_) + (long )((bw->used_ + 7) >> 3)));
}
}
#line 108
int VP8LBitWriterInit(VP8LBitWriter *bw , size_t expected_size ) ;
#line 110
int VP8LBitWriterClone(VP8LBitWriter *src , VP8LBitWriter *dst ) ;
#line 113
uint8_t *VP8LBitWriterFinish(VP8LBitWriter *bw ) ;
#line 115
void VP8LBitWriterWipeOut(VP8LBitWriter *bw ) ;
#line 117
void VP8LBitWriterReset(VP8LBitWriter *bw_init , VP8LBitWriter *bw ) ;
#line 120
void VP8LBitWriterSwap(VP8LBitWriter *src , VP8LBitWriter *dst ) ;
#line 123
void VP8LPutBitsFlushBits(VP8LBitWriter *bw ) ;
#line 126
void VP8LPutBitsInternal(VP8LBitWriter *bw , uint32_t bits , int n_bits ) ;
#line 133 "../../src/utils/bit_writer_utils.h"
__inline static void VP8LPutBits(VP8LBitWriter *bw , uint32_t bits , int n_bits ) 
{ 


  {
#line 135
  if (sizeof(vp8l_wtype_t ) == 4UL) {
#line 136
    if (n_bits > 0) {
#line 137
      if (bw->used_ >= 32) {
        {
#line 138
        VP8LPutBitsFlushBits(bw);
        }
      }
#line 140
      bw->bits_ |= (vp8l_atype_t )bits << bw->used_;
#line 141
      bw->used_ += n_bits;
    }
  } else {
    {
#line 144
    VP8LPutBitsInternal(bw, bits, n_bits);
    }
  }
#line 147
  return;
}
}
#line 53 "../../src/utils/endian_inl_utils.h"
__inline static uint32_t BSwap32(uint32_t x ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 64
  __cil_tmp2 = __builtin_bswap32((int )x);
  }
#line 64
  return ((uint32_t )__cil_tmp2);
}
}
#line 76 "../../src/utils/endian_inl_utils.h"
__inline static uint64_t BSwap64(uint64_t x ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 78
  __cil_tmp2 = __builtin_bswap64((long )x);
  }
#line 78
  return ((uint64_t )__cil_tmp2);
}
}
#line 26 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
static int BitWriterResize(VP8BitWriter *bw , size_t extra_size ) 
{ 
  uint8_t *new_buf ;
  size_t new_size ;
  uint64_t needed_size_64b ;
  size_t needed_size ;
  void *__cil_tmp7 ;

  {
#line 29
  needed_size_64b = bw->pos_ + extra_size;
#line 30
  needed_size = needed_size_64b;
#line 31
  if (needed_size_64b != needed_size) {
#line 32
    bw->error_ = 1;
#line 33
    return (0);
  }
#line 35
  if (needed_size <= bw->max_pos_) {
#line 35
    return (1);
  }
#line 37
  new_size = 2UL * bw->max_pos_;
#line 38
  if (new_size < needed_size) {
#line 38
    new_size = needed_size;
  }
#line 39
  if (new_size < 1024UL) {
#line 39
    new_size = (size_t )1024;
  }
  {
#line 40
  __cil_tmp7 = WebPSafeMalloc((uint64_t )1ULL, new_size);
#line 40
  new_buf = (uint8_t *)__cil_tmp7;
  }
#line 41
  if ((unsigned long )new_buf == (unsigned long )((void *)0)) {
#line 42
    bw->error_ = 1;
#line 43
    return (0);
  }
#line 45
  if (bw->pos_ > 0UL) {
    {
#line 47
    memcpy((void *)new_buf, (void const   *)bw->buf_, bw->pos_);
    }
  }
  {
#line 49
  WebPSafeFree((void *)bw->buf_);
#line 50
  bw->buf_ = new_buf;
#line 51
  bw->max_pos_ = new_size;
  }
#line 52
  return (1);
}
}
#line 55 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
static void Flush(VP8BitWriter *bw ) 
{ 
  int s ;
  int32_t bits ;
  size_t pos ;
  int __cil_tmp5 ;
  int value ;
  int tmp ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;

  {
#line 56
  s = 8 + bw->nb_bits_;
#line 57
  bits = bw->value_ >> s;
#line 59
  bw->value_ -= bits << s;
#line 60
  bw->nb_bits_ -= 8;
#line 61
  if ((bits & 255) != 255) {
    {
#line 62
    pos = bw->pos_;
#line 63
    __cil_tmp5 = BitWriterResize(bw, (size_t )(bw->run_ + 1));
    }
#line 63
    if (! __cil_tmp5) {
#line 64
      return;
    }
#line 66
    if (bits & 256) {
#line 67
      if (pos > 0UL) {
#line 67
        *(bw->buf_ + (pos - 1UL)) = (uint8_t )((int )*(bw->buf_ + (pos - 1UL)) + 1);
      }
    }
#line 69
    if (bw->run_ > 0) {
#line 70
      if (bits & 256) {
#line 70
        tmp = 0;
      } else {
#line 70
        tmp = 255;
      }
#line 70
      value = tmp;
      {
#line 71
      while (1) {
        while_continue: /* CIL Label */ ;

#line 71
        if (! (bw->run_ > 0)) {
#line 71
          goto while_break;
        }
#line 71
        __cil_tmp9 = pos;
#line 71
        pos ++;
#line 71
        *(bw->buf_ + __cil_tmp9) = (uint8_t )value;
#line 71
        (bw->run_) --;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: ;
    }
#line 73
    __cil_tmp10 = pos;
#line 73
    pos ++;
#line 73
    *(bw->buf_ + __cil_tmp10) = (uint8_t )(bits & 255);
#line 74
    bw->pos_ = pos;
  } else {
#line 76
    (bw->run_) ++;
  }
#line 78
  return;
}
}
#line 83 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
static uint8_t kNorm[128]  = 
#line 83
  {      (uint8_t )7,      (uint8_t )6,      (uint8_t )6,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )0};
#line 96 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
static uint8_t kNewRange[128]  = 
#line 96
  {      (uint8_t )127,      (uint8_t )127,      (uint8_t )191,      (uint8_t )127, 
        (uint8_t )159,      (uint8_t )191,      (uint8_t )223,      (uint8_t )127, 
        (uint8_t )143,      (uint8_t )159,      (uint8_t )175,      (uint8_t )191, 
        (uint8_t )207,      (uint8_t )223,      (uint8_t )239,      (uint8_t )127, 
        (uint8_t )135,      (uint8_t )143,      (uint8_t )151,      (uint8_t )159, 
        (uint8_t )167,      (uint8_t )175,      (uint8_t )183,      (uint8_t )191, 
        (uint8_t )199,      (uint8_t )207,      (uint8_t )215,      (uint8_t )223, 
        (uint8_t )231,      (uint8_t )239,      (uint8_t )247,      (uint8_t )127, 
        (uint8_t )131,      (uint8_t )135,      (uint8_t )139,      (uint8_t )143, 
        (uint8_t )147,      (uint8_t )151,      (uint8_t )155,      (uint8_t )159, 
        (uint8_t )163,      (uint8_t )167,      (uint8_t )171,      (uint8_t )175, 
        (uint8_t )179,      (uint8_t )183,      (uint8_t )187,      (uint8_t )191, 
        (uint8_t )195,      (uint8_t )199,      (uint8_t )203,      (uint8_t )207, 
        (uint8_t )211,      (uint8_t )215,      (uint8_t )219,      (uint8_t )223, 
        (uint8_t )227,      (uint8_t )231,      (uint8_t )235,      (uint8_t )239, 
        (uint8_t )243,      (uint8_t )247,      (uint8_t )251,      (uint8_t )127, 
        (uint8_t )129,      (uint8_t )131,      (uint8_t )133,      (uint8_t )135, 
        (uint8_t )137,      (uint8_t )139,      (uint8_t )141,      (uint8_t )143, 
        (uint8_t )145,      (uint8_t )147,      (uint8_t )149,      (uint8_t )151, 
        (uint8_t )153,      (uint8_t )155,      (uint8_t )157,      (uint8_t )159, 
        (uint8_t )161,      (uint8_t )163,      (uint8_t )165,      (uint8_t )167, 
        (uint8_t )169,      (uint8_t )171,      (uint8_t )173,      (uint8_t )175, 
        (uint8_t )177,      (uint8_t )179,      (uint8_t )181,      (uint8_t )183, 
        (uint8_t )185,      (uint8_t )187,      (uint8_t )189,      (uint8_t )191, 
        (uint8_t )193,      (uint8_t )195,      (uint8_t )197,      (uint8_t )199, 
        (uint8_t )201,      (uint8_t )203,      (uint8_t )205,      (uint8_t )207, 
        (uint8_t )209,      (uint8_t )211,      (uint8_t )213,      (uint8_t )215, 
        (uint8_t )217,      (uint8_t )219,      (uint8_t )221,      (uint8_t )223, 
        (uint8_t )225,      (uint8_t )227,      (uint8_t )229,      (uint8_t )231, 
        (uint8_t )233,      (uint8_t )235,      (uint8_t )237,      (uint8_t )239, 
        (uint8_t )241,      (uint8_t )243,      (uint8_t )245,      (uint8_t )247, 
        (uint8_t )249,      (uint8_t )251,      (uint8_t )253,      (uint8_t )127};
#line 108 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
int VP8PutBit(VP8BitWriter *bw , int bit , int prob ) 
{ 
  int split ;
  int shift ;

  {
#line 109
  split = bw->range_ * prob >> 8;
#line 110
  if (bit) {
#line 111
    bw->value_ += split + 1;
#line 112
    bw->range_ -= split + 1;
  } else {
#line 114
    bw->range_ = split;
  }
#line 116
  if (bw->range_ < 127) {
#line 117
    shift = (int )kNorm[bw->range_];
#line 118
    bw->range_ = (int32_t )kNewRange[bw->range_];
#line 119
    bw->value_ <<= shift;
#line 120
    bw->nb_bits_ += shift;
#line 121
    if (bw->nb_bits_ > 0) {
      {
#line 121
      Flush(bw);
      }
    }
  }
#line 123
  return (bit);
}
}
#line 126 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
int VP8PutBitUniform(VP8BitWriter *bw , int bit ) 
{ 
  int split ;

  {
#line 127
  split = bw->range_ >> 1;
#line 128
  if (bit) {
#line 129
    bw->value_ += split + 1;
#line 130
    bw->range_ -= split + 1;
  } else {
#line 132
    bw->range_ = split;
  }
#line 134
  if (bw->range_ < 127) {
#line 135
    bw->range_ = (int32_t )kNewRange[bw->range_];
#line 136
    bw->value_ <<= 1;
#line 137
    (bw->nb_bits_) ++;
#line 138
    if (bw->nb_bits_ > 0) {
      {
#line 138
      Flush(bw);
      }
    }
  }
#line 140
  return (bit);
}
}
#line 143 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
void VP8PutBits(VP8BitWriter *bw , uint32_t value , int nb_bits ) 
{ 
  uint32_t mask ;

  {
#line 146
  mask = 1U << (nb_bits - 1);
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;

#line 146
    if (! mask) {
#line 146
      goto while_break;
    }
    {
#line 147
    VP8PutBitUniform(bw, (int )(value & mask));
#line 146
    mask >>= 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 150
  return;
}
}
#line 151 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
void VP8PutSignedBits(VP8BitWriter *bw , int value , int nb_bits ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 152
  __cil_tmp4 = VP8PutBitUniform(bw, value != 0);
  }
#line 152
  if (! __cil_tmp4) {
#line 152
    return;
  }
#line 153
  if (value < 0) {
    {
#line 154
    VP8PutBits(bw, (uint32_t )((- value << 1) | 1), nb_bits + 1);
    }
  } else {
    {
#line 156
    VP8PutBits(bw, (uint32_t )(value << 1), nb_bits + 1);
    }
  }
#line 159
  return;
}
}
#line 162 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
int VP8BitWriterInit(VP8BitWriter *bw , size_t expected_size ) 
{ 
  int __cil_tmp3 ;
  int tmp ;

  {
#line 163
  bw->range_ = 254;
#line 164
  bw->value_ = 0;
#line 165
  bw->run_ = 0;
#line 166
  bw->nb_bits_ = -8;
#line 167
  bw->pos_ = (size_t )0;
#line 168
  bw->max_pos_ = (size_t )0;
#line 169
  bw->error_ = 0;
#line 170
  bw->buf_ = (uint8_t *)((void *)0);
#line 171
  if (expected_size > 0UL) {
    {
#line 171
    __cil_tmp3 = BitWriterResize(bw, expected_size);
#line 171
    tmp = __cil_tmp3;
    }
  } else {
#line 171
    tmp = 1;
  }
#line 171
  return (tmp);
}
}
#line 174 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
uint8_t *VP8BitWriterFinish(VP8BitWriter *bw ) 
{ 


  {
  {
#line 175
  VP8PutBits(bw, (uint32_t )0, 9 - bw->nb_bits_);
#line 176
  bw->nb_bits_ = 0;
#line 177
  Flush(bw);
  }
#line 178
  return (bw->buf_);
}
}
#line 181 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
int VP8BitWriterAppend(VP8BitWriter *bw , uint8_t *data , size_t size ) 
{ 
  int __cil_tmp4 ;

  {
#line 184
  if (bw->nb_bits_ != -8) {
#line 184
    return (0);
  }
  {
#line 185
  __cil_tmp4 = BitWriterResize(bw, size);
  }
#line 185
  if (! __cil_tmp4) {
#line 185
    return (0);
  }
  {
#line 186
  memcpy((void *)(bw->buf_ + bw->pos_), (void const   *)data, size);
#line 187
  bw->pos_ += size;
  }
#line 188
  return (1);
}
}
#line 191 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
void VP8BitWriterWipeOut(VP8BitWriter *bw ) 
{ 


  {
#line 192
  if ((unsigned long )bw != (unsigned long )((void *)0)) {
    {
#line 193
    WebPSafeFree((void *)bw->buf_);
#line 194
    memset((void *)bw, 0, sizeof(*bw));
    }
  }
#line 197
  return;
}
}
#line 206 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
static int VP8LBitWriterResize(VP8LBitWriter *bw , size_t extra_size ) 
{ 
  uint8_t *allocated_buf ;
  size_t allocated_size ;
  size_t max_bytes ;
  size_t current_size ;
  uint64_t size_required_64b ;
  size_t size_required ;
  void *__cil_tmp9 ;

  {
#line 209
  max_bytes = (size_t )(bw->end_ - bw->buf_);
#line 210
  current_size = (size_t )(bw->cur_ - bw->buf_);
#line 211
  size_required_64b = current_size + extra_size;
#line 212
  size_required = size_required_64b;
#line 213
  if (size_required != size_required_64b) {
#line 214
    bw->error_ = 1;
#line 215
    return (0);
  }
#line 217
  if (max_bytes > 0UL) {
#line 217
    if (size_required <= max_bytes) {
#line 217
      return (1);
    }
  }
#line 218
  allocated_size = 3UL * max_bytes >> 1;
#line 219
  if (allocated_size < size_required) {
#line 219
    allocated_size = size_required;
  }
  {
#line 221
  allocated_size = ((allocated_size >> 10) + 1UL) << 10;
#line 222
  __cil_tmp9 = WebPSafeMalloc((uint64_t )1ULL, allocated_size);
#line 222
  allocated_buf = (uint8_t *)__cil_tmp9;
  }
#line 223
  if ((unsigned long )allocated_buf == (unsigned long )((void *)0)) {
#line 224
    bw->error_ = 1;
#line 225
    return (0);
  }
#line 227
  if (current_size > 0UL) {
    {
#line 228
    memcpy((void *)allocated_buf, (void const   *)bw->buf_, current_size);
    }
  }
  {
#line 230
  WebPSafeFree((void *)bw->buf_);
#line 231
  bw->buf_ = allocated_buf;
#line 232
  bw->cur_ = bw->buf_ + current_size;
#line 233
  bw->end_ = bw->buf_ + allocated_size;
  }
#line 234
  return (1);
}
}
#line 237 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
int VP8LBitWriterInit(VP8LBitWriter *bw , size_t expected_size ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 238
  memset((void *)bw, 0, sizeof(*bw));
#line 239
  __cil_tmp3 = VP8LBitWriterResize(bw, expected_size);
  }
#line 239
  return (__cil_tmp3);
}
}
#line 242 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
int VP8LBitWriterClone(VP8LBitWriter *src , VP8LBitWriter *dst ) 
{ 
  size_t current_size ;
  int __cil_tmp4 ;

  {
  {
#line 244
  current_size = (size_t )(src->cur_ - src->buf_);
#line 246
  __cil_tmp4 = VP8LBitWriterResize(dst, current_size);
  }
#line 246
  if (! __cil_tmp4) {
#line 246
    return (0);
  }
  {
#line 247
  memcpy((void *)dst->buf_, (void const   *)src->buf_, current_size);
#line 248
  dst->bits_ = src->bits_;
#line 249
  dst->used_ = src->used_;
#line 250
  dst->error_ = src->error_;
#line 251
  dst->cur_ = dst->buf_ + current_size;
  }
#line 252
  return (1);
}
}
#line 255 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
void VP8LBitWriterWipeOut(VP8LBitWriter *bw ) 
{ 


  {
#line 256
  if ((unsigned long )bw != (unsigned long )((void *)0)) {
    {
#line 257
    WebPSafeFree((void *)bw->buf_);
#line 258
    memset((void *)bw, 0, sizeof(*bw));
    }
  }
#line 261
  return;
}
}
#line 262 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
void VP8LBitWriterReset(VP8LBitWriter *bw_init , VP8LBitWriter *bw ) 
{ 


  {
#line 264
  bw->bits_ = bw_init->bits_;
#line 265
  bw->used_ = bw_init->used_;
#line 266
  bw->cur_ = bw->buf_ + (bw_init->cur_ - bw_init->buf_);
#line 268
  bw->error_ = bw_init->error_;
#line 269
  return;
}
}
#line 271 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
void VP8LBitWriterSwap(VP8LBitWriter *src , VP8LBitWriter *dst ) 
{ 
  VP8LBitWriter tmp ;

  {
#line 272
  tmp = *src;
#line 273
  *src = *dst;
#line 274
  *dst = tmp;
#line 275
  return;
}
}
#line 277 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
void VP8LPutBitsFlushBits(VP8LBitWriter *bw ) 
{ 
  uint64_t extra_size ;
  int __cil_tmp3 ;

  {
#line 279
  if ((unsigned long )(bw->cur_ + 4) > (unsigned long )bw->end_) {
    {
#line 280
    extra_size = (uint64_t )((unsigned long long )(bw->end_ - bw->buf_) + 32768ULL);
#line 281
    __cil_tmp3 = VP8LBitWriterResize(bw, extra_size);
    }
#line 281
    if (extra_size != extra_size) {
#line 283
      bw->cur_ = bw->buf_;
#line 284
      bw->error_ = 1;
#line 285
      return;
    } else
#line 281
    if (! __cil_tmp3) {
#line 283
      bw->cur_ = bw->buf_;
#line 284
      bw->error_ = 1;
#line 285
      return;
    }
  }
#line 288
  *((vp8l_wtype_t *)bw->cur_) = (vp8l_wtype_t )bw->bits_;
#line 289
  bw->cur_ += 4;
#line 290
  bw->bits_ >>= 32;
#line 291
  bw->used_ -= 32;
#line 292
  return;
}
}
#line 294 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
void VP8LPutBitsInternal(VP8LBitWriter *bw , uint32_t bits , int n_bits ) 
{ 
  vp8l_atype_t lbits ;
  int used ;
  uint64_t extra_size ;
  int __cil_tmp7 ;

  {
#line 298
  if (n_bits > 0) {
#line 299
    lbits = bw->bits_;
#line 300
    used = bw->used_;
    {
#line 314
    while (1) {
      while_continue: /* CIL Label */ ;

#line 314
      if (! (used >= 32)) {
#line 314
        goto while_break;
      }
#line 315
      if ((unsigned long )(bw->cur_ + 4) > (unsigned long )bw->end_) {
        {
#line 316
        extra_size = (uint64_t )((unsigned long long )(bw->end_ - bw->buf_) + 32768ULL);
#line 317
        __cil_tmp7 = VP8LBitWriterResize(bw, extra_size);
        }
#line 317
        if (extra_size != extra_size) {
#line 319
          bw->cur_ = bw->buf_;
#line 320
          bw->error_ = 1;
#line 321
          return;
        } else
#line 317
        if (! __cil_tmp7) {
#line 319
          bw->cur_ = bw->buf_;
#line 320
          bw->error_ = 1;
#line 321
          return;
        }
      }
#line 324
      *((vp8l_wtype_t *)bw->cur_) = (vp8l_wtype_t )lbits;
#line 325
      bw->cur_ += 4;
#line 326
      lbits >>= 32;
#line 327
      used -= 32;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 329
    bw->bits_ = lbits | ((vp8l_atype_t )bits << used);
#line 330
    bw->used_ = used + n_bits;
  }
#line 332
  return;
}
}
#line 334 "/root/patron-new/new_3/src/utils/bit_writer_utils.c"
uint8_t *VP8LBitWriterFinish(VP8LBitWriter *bw ) 
{ 
  int __cil_tmp2 ;
  uint8_t *__cil_tmp3 ;

  {
  {
#line 336
  __cil_tmp2 = VP8LBitWriterResize(bw, (size_t )((bw->used_ + 7) >> 3));
  }
#line 336
  if (__cil_tmp2) {
    {
#line 337
    while (1) {
      while_continue: /* CIL Label */ ;

#line 337
      if (! (bw->used_ > 0)) {
#line 337
        goto while_break;
      }
#line 338
      __cil_tmp3 = bw->cur_;
#line 338
      (bw->cur_) ++;
#line 338
      *__cil_tmp3 = (uint8_t )bw->bits_;
#line 339
      bw->bits_ >>= 8;
#line 340
      bw->used_ -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 342
    bw->used_ = 0;
  }
#line 344
  return (bw->buf_);
}
}
#line 105 "../../src/utils/bit_reader_utils.h"
void VP8InitBitReader(VP8BitReader *br , uint8_t *start , size_t size ) ;
#line 108
void VP8BitReaderSetBuffer(VP8BitReader *br , uint8_t *start , size_t size ) ;
#line 113
void VP8RemapBitReader(VP8BitReader *br , ptrdiff_t offset ) ;
#line 116
uint32_t VP8GetValue(VP8BitReader *br , int bits ) ;
#line 119
int32_t VP8GetSignedValue(VP8BitReader *br , int bits ) ;
#line 149
void VP8LInitBitReader(VP8LBitReader *br , uint8_t *start , size_t length ) ;
#line 154
void VP8LBitReaderSetBuffer(VP8LBitReader *br , uint8_t *buf , size_t len ) ;
#line 161
uint32_t VP8LReadBits(VP8LBitReader *br , int n_bits ) ;
#line 164 "../../src/utils/bit_reader_utils.h"
__inline static uint32_t VP8LPrefetchBits(VP8LBitReader *br ) 
{ 


  {
#line 165
  return ((uint32_t )(br->val_ >> (br->bit_pos_ & 63)));
}
}
#line 170 "../../src/utils/bit_reader_utils.h"
__inline static int VP8LIsEndOfStream(VP8LBitReader *br ) 
{ 
  int tmp ;

  {
#line 172
  if (br->eos_) {
#line 172
    tmp = 1;
  } else
#line 172
  if (br->pos_ == br->len_) {
#line 172
    if (br->bit_pos_ > 64) {
#line 172
      tmp = 1;
    } else {
#line 172
      tmp = 0;
    }
  } else {
#line 172
    tmp = 0;
  }
#line 172
  return (tmp);
}
}
#line 179 "../../src/utils/bit_reader_utils.h"
__inline static void VP8LSetBitPos(VP8LBitReader *br , int val ) 
{ 


  {
#line 180
  br->bit_pos_ = val;
#line 181
  return;
}
}
#line 185
void VP8LDoFillBitWindow(VP8LBitReader *br ) ;
#line 186 "../../src/utils/bit_reader_utils.h"
__inline static void VP8LFillBitWindow(VP8LBitReader *br ) 
{ 


  {
#line 187
  if (br->bit_pos_ >= 32) {
    {
#line 187
    VP8LDoFillBitWindow(br);
    }
  }
#line 190
  return;
}
}
#line 47 "../../src/utils/bit_reader_inl_utils.h"
uint8_t kVP8Log2Range[128] ;
#line 48
uint8_t kVP8NewRange[128] ;
#line 51
void VP8LoadFinalBytes(VP8BitReader *br ) ;
#line 58 "../../src/utils/bit_reader_inl_utils.h"
__inline static void VP8LoadNewBytes(VP8BitReader *br ) 
{ 
  bit_t bits ;
  lbit_t in_bits ;

  {
#line 61
  if ((unsigned long )br->buf_ < (unsigned long )br->buf_max_) {
    {
#line 80
    memcpy((void *)(& in_bits), (void const   *)br->buf_, sizeof(in_bits));
#line 82
    br->buf_ += 56 >> 3;
#line 85
    bits = BSwap64(in_bits);
#line 86
    bits >>= 8;
#line 99
    br->value_ = bits | (br->value_ << 56);
#line 100
    br->bits_ += 56;
    }
  } else {
    {
#line 102
    VP8LoadFinalBytes(br);
    }
  }
#line 105
  return;
}
}
#line 107 "../../src/utils/bit_reader_inl_utils.h"
__inline static int VP8GetBit(VP8BitReader *br , int prob ) 
{ 
  range_t range ;
  int pos ;
  range_t split ;
  range_t value ;
  int bit ;
  int shift ;
  int __cil_tmp9 ;

  {
#line 112
  range = br->range_;
#line 113
  if (br->bits_ < 0) {
    {
#line 114
    VP8LoadNewBytes(br);
    }
  }
#line 117
  pos = br->bits_;
#line 118
  split = range * (unsigned int )prob >> 8;
#line 119
  value = (range_t )(br->value_ >> pos);
#line 120
  bit = value > split;
#line 121
  if (bit) {
#line 122
    range -= split;
#line 123
    br->value_ -= (bit_t )(split + 1U) << pos;
  } else {
#line 125
    range = split + 1U;
  }
  {
#line 128
  __cil_tmp9 = BitsLog2Floor(range);
#line 128
  shift = 7 ^ __cil_tmp9;
#line 129
  range <<= shift;
#line 130
  br->bits_ -= shift;
#line 132
  br->range_ = range - 1U;
  }
#line 134
  return (bit);
}
}
#line 140 "../../src/utils/bit_reader_inl_utils.h"
__inline static int VP8GetSigned(VP8BitReader *br , int v ) 
{ 
  int pos ;
  range_t split ;
  range_t value ;
  int32_t mask ;

  {
#line 141
  if (br->bits_ < 0) {
    {
#line 142
    VP8LoadNewBytes(br);
    }
  }
#line 145
  pos = br->bits_;
#line 146
  split = br->range_ >> 1;
#line 147
  value = (range_t )(br->value_ >> pos);
#line 148
  mask = (int32_t )(split - value) >> 31;
#line 149
  (br->bits_) --;
#line 150
  br->range_ += (unsigned int )mask;
#line 151
  br->range_ |= 1U;
#line 152
  br->value_ -= (bit_t )((split + 1U) & (unsigned int )mask) << pos;
#line 154
  return ((v ^ mask) - mask);
}
}
#line 158 "../../src/utils/bit_reader_inl_utils.h"
__inline static int VP8GetBitAlt(VP8BitReader *br , int prob ) 
{ 
  range_t range ;
  int pos ;
  range_t split ;
  range_t value ;
  int bit ;
  int shift ;

  {
#line 163
  range = br->range_;
#line 164
  if (br->bits_ < 0) {
    {
#line 165
    VP8LoadNewBytes(br);
    }
  }
#line 168
  pos = br->bits_;
#line 169
  split = range * (unsigned int )prob >> 8;
#line 170
  value = (range_t )(br->value_ >> pos);
#line 172
  if (value > split) {
#line 173
    range -= split + 1U;
#line 174
    br->value_ -= (bit_t )(split + 1U) << pos;
#line 175
    bit = 1;
  } else {
#line 177
    range = split;
#line 178
    bit = 0;
  }
#line 180
  if (range <= 126U) {
#line 181
    shift = (int )kVP8Log2Range[range];
#line 182
    range = (range_t )kVP8NewRange[range];
#line 183
    br->bits_ -= shift;
  }
#line 185
  br->range_ = range;
#line 187
  return (bit);
}
}
#line 24 "/root/patron-new/new_3/src/utils/bit_reader_utils.c"
void VP8BitReaderSetBuffer(VP8BitReader *br , uint8_t *start , size_t size ) 
{ 
  uint8_t *tmp ;

  {
#line 27
  br->buf_ = start;
#line 28
  br->buf_end_ = start + size;
#line 29
  if (size >= sizeof(lbit_t )) {
#line 29
    tmp = ((start + size) - sizeof(lbit_t )) + 1;
  } else {
#line 29
    tmp = start;
  }
#line 29
  br->buf_max_ = tmp;
#line 30
  return;
}
}
#line 34 "/root/patron-new/new_3/src/utils/bit_reader_utils.c"
void VP8InitBitReader(VP8BitReader *br , uint8_t *start , size_t size ) 
{ 


  {
  {
#line 39
  br->range_ = (range_t )254;
#line 40
  br->value_ = (bit_t )0;
#line 41
  br->bits_ = -8;
#line 42
  br->eof_ = 0;
#line 43
  VP8BitReaderSetBuffer(br, start, size);
#line 44
  VP8LoadNewBytes(br);
  }
#line 46
  return;
}
}
#line 47 "/root/patron-new/new_3/src/utils/bit_reader_utils.c"
void VP8RemapBitReader(VP8BitReader *br , ptrdiff_t offset ) 
{ 


  {
#line 48
  if ((unsigned long )br->buf_ != (unsigned long )((void *)0)) {
#line 49
    br->buf_ += offset;
#line 50
    br->buf_end_ += offset;
#line 51
    br->buf_max_ += offset;
  }
#line 53
  return;
}
}
#line 55 "/root/patron-new/new_3/src/utils/bit_reader_utils.c"
uint8_t kVP8Log2Range[128]  = 
#line 55
  {      (uint8_t )7,      (uint8_t )6,      (uint8_t )6,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )0};
#line 68 "/root/patron-new/new_3/src/utils/bit_reader_utils.c"
uint8_t kVP8NewRange[128]  = 
#line 68
  {      (uint8_t )127,      (uint8_t )127,      (uint8_t )191,      (uint8_t )127, 
        (uint8_t )159,      (uint8_t )191,      (uint8_t )223,      (uint8_t )127, 
        (uint8_t )143,      (uint8_t )159,      (uint8_t )175,      (uint8_t )191, 
        (uint8_t )207,      (uint8_t )223,      (uint8_t )239,      (uint8_t )127, 
        (uint8_t )135,      (uint8_t )143,      (uint8_t )151,      (uint8_t )159, 
        (uint8_t )167,      (uint8_t )175,      (uint8_t )183,      (uint8_t )191, 
        (uint8_t )199,      (uint8_t )207,      (uint8_t )215,      (uint8_t )223, 
        (uint8_t )231,      (uint8_t )239,      (uint8_t )247,      (uint8_t )127, 
        (uint8_t )131,      (uint8_t )135,      (uint8_t )139,      (uint8_t )143, 
        (uint8_t )147,      (uint8_t )151,      (uint8_t )155,      (uint8_t )159, 
        (uint8_t )163,      (uint8_t )167,      (uint8_t )171,      (uint8_t )175, 
        (uint8_t )179,      (uint8_t )183,      (uint8_t )187,      (uint8_t )191, 
        (uint8_t )195,      (uint8_t )199,      (uint8_t )203,      (uint8_t )207, 
        (uint8_t )211,      (uint8_t )215,      (uint8_t )219,      (uint8_t )223, 
        (uint8_t )227,      (uint8_t )231,      (uint8_t )235,      (uint8_t )239, 
        (uint8_t )243,      (uint8_t )247,      (uint8_t )251,      (uint8_t )127, 
        (uint8_t )129,      (uint8_t )131,      (uint8_t )133,      (uint8_t )135, 
        (uint8_t )137,      (uint8_t )139,      (uint8_t )141,      (uint8_t )143, 
        (uint8_t )145,      (uint8_t )147,      (uint8_t )149,      (uint8_t )151, 
        (uint8_t )153,      (uint8_t )155,      (uint8_t )157,      (uint8_t )159, 
        (uint8_t )161,      (uint8_t )163,      (uint8_t )165,      (uint8_t )167, 
        (uint8_t )169,      (uint8_t )171,      (uint8_t )173,      (uint8_t )175, 
        (uint8_t )177,      (uint8_t )179,      (uint8_t )181,      (uint8_t )183, 
        (uint8_t )185,      (uint8_t )187,      (uint8_t )189,      (uint8_t )191, 
        (uint8_t )193,      (uint8_t )195,      (uint8_t )197,      (uint8_t )199, 
        (uint8_t )201,      (uint8_t )203,      (uint8_t )205,      (uint8_t )207, 
        (uint8_t )209,      (uint8_t )211,      (uint8_t )213,      (uint8_t )215, 
        (uint8_t )217,      (uint8_t )219,      (uint8_t )221,      (uint8_t )223, 
        (uint8_t )225,      (uint8_t )227,      (uint8_t )229,      (uint8_t )231, 
        (uint8_t )233,      (uint8_t )235,      (uint8_t )237,      (uint8_t )239, 
        (uint8_t )241,      (uint8_t )243,      (uint8_t )245,      (uint8_t )247, 
        (uint8_t )249,      (uint8_t )251,      (uint8_t )253,      (uint8_t )127};
#line 87 "/root/patron-new/new_3/src/utils/bit_reader_utils.c"
void VP8LoadFinalBytes(VP8BitReader *br ) 
{ 
  uint8_t *__cil_tmp2 ;

  {
#line 90
  if ((unsigned long )br->buf_ < (unsigned long )br->buf_end_) {
#line 91
    br->bits_ += 8;
#line 92
    __cil_tmp2 = br->buf_;
#line 92
    (br->buf_) ++;
#line 92
    br->value_ = (bit_t )*__cil_tmp2 | (br->value_ << 8);
  } else
#line 93
  if (! br->eof_) {
#line 94
    br->value_ <<= 8;
#line 95
    br->bits_ += 8;
#line 96
    br->eof_ = 1;
  } else {
#line 98
    br->bits_ = 0;
  }
#line 100
  return;
}
}
#line 105 "/root/patron-new/new_3/src/utils/bit_reader_utils.c"
uint32_t VP8GetValue(VP8BitReader *br , int bits ) 
{ 
  uint32_t v ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 106
  v = (uint32_t )0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    __cil_tmp4 = bits;
#line 107
    bits --;
#line 107
    if (! (__cil_tmp4 > 0)) {
#line 107
      goto while_break;
    }
    {
#line 108
    __cil_tmp5 = VP8GetBit(br, 128);
#line 108
    v |= (unsigned int )(__cil_tmp5 << bits);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 110
  return (v);
}
}
#line 113 "/root/patron-new/new_3/src/utils/bit_reader_utils.c"
int32_t VP8GetSignedValue(VP8BitReader *br , int bits ) 
{ 
  int value ;
  uint32_t __cil_tmp4 ;
  uint32_t __cil_tmp5 ;
  int tmp ;

  {
  {
#line 115
  __cil_tmp4 = VP8GetValue(br, bits);
#line 115
  value = (int )__cil_tmp4;
#line 116
  __cil_tmp5 = VP8GetValue(br, 1);
  }
#line 116
  if (__cil_tmp5) {
#line 116
    tmp = - value;
  } else {
#line 116
    tmp = value;
  }
#line 116
  return (tmp);
}
}
#line 130 "/root/patron-new/new_3/src/utils/bit_reader_utils.c"
static uint32_t kBitMask[25]  = 
#line 130
  {      (uint32_t )0,      (uint32_t )1,      (uint32_t )3,      (uint32_t )7, 
        (uint32_t )15,      (uint32_t )31,      (uint32_t )63,      (uint32_t )127, 
        (uint32_t )255,      (uint32_t )511,      (uint32_t )1023,      (uint32_t )2047, 
        (uint32_t )4095,      (uint32_t )8191,      (uint32_t )16383,      (uint32_t )32767, 
        (uint32_t )65535,      (uint32_t )131071,      (uint32_t )262143,      (uint32_t )524287, 
        (uint32_t )1048575,      (uint32_t )2097151,      (uint32_t )4194303,      (uint32_t )8388607, 
        (uint32_t )16777215};
#line 140 "/root/patron-new/new_3/src/utils/bit_reader_utils.c"
void VP8LInitBitReader(VP8LBitReader *br , uint8_t *start , size_t length ) 
{ 
  size_t i ;
  vp8l_val_t value ;

  {
#line 143
  value = (vp8l_val_t )0;
#line 148
  br->len_ = length;
#line 149
  br->val_ = (vp8l_val_t )0;
#line 150
  br->bit_pos_ = 0;
#line 151
  br->eos_ = 0;
#line 153
  if (length > sizeof(br->val_)) {
#line 154
    length = sizeof(br->val_);
  }
#line 156
  i = (size_t )0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;

#line 156
    if (! (i < length)) {
#line 156
      goto while_break;
    }
#line 157
    value |= (vp8l_val_t )*(start + i) << 8UL * i;
#line 156
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 159
  br->val_ = value;
#line 160
  br->pos_ = length;
#line 161
  br->buf_ = start;
#line 162
  return;
}
}
#line 164 "/root/patron-new/new_3/src/utils/bit_reader_utils.c"
void VP8LBitReaderSetBuffer(VP8LBitReader *br , uint8_t *buf , size_t len ) 
{ 
  int __cil_tmp4 ;
  int tmp ;

  {
  {
#line 169
  br->buf_ = buf;
#line 170
  br->len_ = len;
#line 172
  __cil_tmp4 = VP8LIsEndOfStream(br);
  }
#line 172
  if (br->pos_ > br->len_) {
#line 172
    tmp = 1;
  } else
#line 172
  if (__cil_tmp4) {
#line 172
    tmp = 1;
  } else {
#line 172
    tmp = 0;
  }
#line 172
  br->eos_ = tmp;
#line 174
  return;
}
}
#line 175 "/root/patron-new/new_3/src/utils/bit_reader_utils.c"
static void VP8LSetEndOfStream(VP8LBitReader *br ) 
{ 


  {
#line 176
  br->eos_ = 1;
#line 177
  br->bit_pos_ = 0;
#line 178
  return;
}
}
#line 181 "/root/patron-new/new_3/src/utils/bit_reader_utils.c"
static void ShiftBytes(VP8LBitReader *br ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;

#line 182
    if (br->bit_pos_ >= 8) {
#line 182
      if (! (br->pos_ < br->len_)) {
#line 182
        goto while_break;
      }
    } else {
#line 182
      goto while_break;
    }
#line 183
    br->val_ >>= 8;
#line 184
    br->val_ |= (vp8l_val_t )*(br->buf_ + br->pos_) << 56;
#line 185
    (br->pos_) ++;
#line 186
    br->bit_pos_ -= 8;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 188
  __cil_tmp2 = VP8LIsEndOfStream(br);
  }
#line 188
  if (__cil_tmp2) {
    {
#line 189
    VP8LSetEndOfStream(br);
    }
  }
#line 192
  return;
}
}
#line 193 "/root/patron-new/new_3/src/utils/bit_reader_utils.c"
void VP8LDoFillBitWindow(VP8LBitReader *br ) 
{ 
  uint32_t __cil_tmp2 ;

  {
#line 196
  if (br->pos_ + sizeof(br->val_) < br->len_) {
    {
#line 197
    br->val_ >>= 32;
#line 198
    br->bit_pos_ -= 32;
#line 199
    __cil_tmp2 = WebPMemToUint32(br->buf_ + br->pos_);
#line 199
    br->val_ |= (vp8l_val_t )__cil_tmp2 << 32;
#line 201
    br->pos_ += 4UL;
    }
#line 202
    return;
  }
  {
#line 205
  ShiftBytes(br);
  }
#line 207
  return;
}
}
#line 208 "/root/patron-new/new_3/src/utils/bit_reader_utils.c"
uint32_t VP8LReadBits(VP8LBitReader *br , int n_bits ) 
{ 
  uint32_t val ;
  uint32_t __cil_tmp4 ;
  int new_bits ;

  {
#line 211
  if (! br->eos_) {
#line 211
    if (n_bits <= 24) {
      {
#line 212
      __cil_tmp4 = VP8LPrefetchBits(br);
#line 212
      val = __cil_tmp4 & kBitMask[n_bits];
#line 213
      new_bits = br->bit_pos_ + n_bits;
#line 214
      br->bit_pos_ = new_bits;
#line 215
      ShiftBytes(br);
      }
#line 216
      return (val);
    } else {
      {
#line 218
      VP8LSetEndOfStream(br);
      }
#line 219
      return ((uint32_t )0);
    }
  } else {
    {
#line 218
    VP8LSetEndOfStream(br);
    }
#line 219
    return ((uint32_t )0);
  }
}
}
#line 104 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 78 "../../src/enc/vp8i_enc.h"
uint16_t VP8Scan[16] ;
#line 79
uint16_t VP8UVModeOffsets[4] ;
#line 80
uint16_t VP8I16ModeOffsets[4] ;
#line 81
uint16_t VP8I4ModeOffsets[10] ;
#line 116 "../../src/enc/vp8i_enc.h"
__inline static int QUANTDIV(uint32_t n , uint32_t iQ , uint32_t B ) 
{ 


  {
#line 117
  return ((int )((n * iQ + B) >> 17));
}
}
#line 269
void VP8IteratorInit(VP8Encoder *enc , VP8EncIterator *it ) ;
#line 271
void VP8IteratorReset(VP8EncIterator *it ) ;
#line 273
void VP8IteratorSetRow(VP8EncIterator *it , int y ) ;
#line 275
void VP8IteratorSetCountDown(VP8EncIterator *it , int count_down ) ;
#line 277
int VP8IteratorIsDone(VP8EncIterator *it ) ;
#line 281
void VP8IteratorImport(VP8EncIterator *it , uint8_t *tmp_32 ) ;
#line 283
void VP8IteratorExport(VP8EncIterator *it ) ;
#line 285
int VP8IteratorNext(VP8EncIterator *it ) ;
#line 287
void VP8IteratorSaveBoundary(VP8EncIterator *it ) ;
#line 289
int VP8IteratorProgress(VP8EncIterator *it , int delta ) ;
#line 291
void VP8IteratorStartI4(VP8EncIterator *it ) ;
#line 293
int VP8IteratorRotateI4(VP8EncIterator *it , uint8_t *yuv_out ) ;
#line 297
void VP8IteratorNzToBytes(VP8EncIterator *it ) ;
#line 298
void VP8IteratorBytesToNz(VP8EncIterator *it ) ;
#line 301
void VP8SetIntra16Mode(VP8EncIterator *it , int mode ) ;
#line 302
void VP8SetIntra4Mode(VP8EncIterator *it , uint8_t *modes ) ;
#line 303
void VP8SetIntraUVMode(VP8EncIterator *it , int mode ) ;
#line 304
void VP8SetSkip(VP8EncIterator *it , int skip ) ;
#line 305
void VP8SetSegment(VP8EncIterator *it , int segment ) ;
#line 324
void VP8TBufferInit(VP8TBuffer *b , int page_size ) ;
#line 325
void VP8TBufferClear(VP8TBuffer *b ) ;
#line 331
int VP8EmitTokens(VP8TBuffer *b , VP8BitWriter *bw , uint8_t *probas , int final_pass ) ;
#line 335
int VP8RecordCoeffTokens(int ctx , struct VP8Residual *res , VP8TBuffer *tokens ) ;
#line 339
size_t VP8EstimateTokenSize(VP8TBuffer *b , uint8_t *probas ) ;
#line 419
uint8_t VP8CoeffsProba0[4][8][3][11] ;
#line 421
uint8_t VP8CoeffsUpdateProba[4][8][3][11] ;
#line 423
void VP8DefaultProbas(VP8Encoder *enc ) ;
#line 425
void VP8WriteProbas(VP8BitWriter *bw , VP8EncProba *probas ) ;
#line 427
void VP8CodeIntraModes(VP8Encoder *enc ) ;
#line 433
int VP8EncWrite(VP8Encoder *enc ) ;
#line 435
void VP8EncFreeBitWriters(VP8Encoder *enc ) ;
#line 438
uint8_t VP8Cat3[3] ;
#line 439
uint8_t VP8Cat4[4] ;
#line 440
uint8_t VP8Cat5[5] ;
#line 441
uint8_t VP8Cat6[11] ;
#line 444
void VP8MakeLuma16Preds(VP8EncIterator *it ) ;
#line 446
void VP8MakeChroma8Preds(VP8EncIterator *it ) ;
#line 449
void VP8MakeIntra4Preds(VP8EncIterator *it ) ;
#line 451
int VP8GetCostLuma16(VP8EncIterator *it , VP8ModeScore *rd ) ;
#line 452
int VP8GetCostLuma4(VP8EncIterator *it , int16_t *levels ) ;
#line 453
int VP8GetCostUV(VP8EncIterator *it , VP8ModeScore *rd ) ;
#line 455
int VP8EncLoop(VP8Encoder *enc ) ;
#line 456
int VP8EncTokenLoop(VP8Encoder *enc ) ;
#line 460
int WebPEncodingSetError(WebPPicture *pic , WebPEncodingError error ) ;
#line 461
int WebPReportProgress(WebPPicture *pic , int percent , int *percent_store ) ;
#line 467
int VP8EncAnalyze(VP8Encoder *enc ) ;
#line 471
void VP8SetSegmentParams(VP8Encoder *enc , float quality ) ;
#line 473
int VP8Decimate(VP8EncIterator *it , VP8ModeScore *rd , VP8RDLevel rd_opt ) ;
#line 477
void VP8EncInitAlpha(VP8Encoder *enc ) ;
#line 478
int VP8EncStartAlpha(VP8Encoder *enc ) ;
#line 479
int VP8EncFinishAlpha(VP8Encoder *enc ) ;
#line 480
int VP8EncDeleteAlpha(VP8Encoder *enc ) ;
#line 483
void VP8InitFilter(VP8EncIterator *it ) ;
#line 484
void VP8StoreFilterStats(VP8EncIterator *it ) ;
#line 485
void VP8AdjustFilterStrength(VP8EncIterator *it ) ;
#line 489
int VP8FilterStrengthFromDelta(int sharpness , int delta ) ;
#line 494
void WebPPictureResetBuffers(WebPPicture *picture ) ;
#line 499
int WebPPictureAllocARGB(WebPPicture *picture , int width , int height ) ;
#line 505
int WebPPictureAllocYUVA(WebPPicture *picture , int width , int height ) ;
#line 509
void WebPReplaceTransparentPixels(WebPPicture *pic , uint32_t color ) ;
#line 39 "../../src/enc/cost_enc.h"
void VP8InitResidual(int first , int coeff_type , VP8Encoder *enc , VP8Residual *res ) ;
#line 42
int VP8RecordCoeffs(int ctx , VP8Residual *res ) ;
#line 45 "../../src/enc/cost_enc.h"
__inline static int VP8RecordStats(int bit , proba_t *stats ) 
{ 
  proba_t p ;

  {
#line 46
  p = *stats;
#line 49
  if (p >= 4294836224U) {
#line 50
    p = ((p + 1U) >> 1) & 2147450879U;
  }
#line 53
  p += 65536U + (unsigned int )bit;
#line 54
  *stats = p;
#line 55
  return (bit);
}
}
#line 59 "../../src/enc/cost_enc.h"
__inline static int VP8BitCost(int bit , uint8_t proba ) 
{ 
  int tmp ;

  {
#line 60
  if (! bit) {
#line 60
    tmp = (int )VP8EntropyCost[proba];
  } else {
#line 60
    tmp = (int )VP8EntropyCost[255 - (int )proba];
  }
#line 60
  return (tmp);
}
}
#line 64
uint16_t VP8LevelCodes[67][2] ;
#line 65
void VP8CalculateLevelCosts(VP8EncProba *proba ) ;
#line 66 "../../src/enc/cost_enc.h"
__inline static int VP8LevelCost(uint16_t *table , int level ) 
{ 
  int tmp ;

  {
#line 67
  if (level > 67) {
#line 67
    tmp = 67;
  } else {
#line 67
    tmp = level;
  }
#line 67
  return ((int )VP8LevelFixedCosts[level] + (int )*(table + tmp));
}
}
#line 72
uint16_t VP8FixedCostsUV[4] ;
#line 73
uint16_t VP8FixedCostsI16[4] ;
#line 74
uint16_t VP8FixedCostsI4[10][10][10] ;
#line 46 "../../src/enc/backward_references_enc.h"
__inline static PixOrCopy PixOrCopyCreateCopy(uint32_t distance , uint16_t len ) 
{ 
  PixOrCopy retval ;

  {
#line 49
  retval.mode = (uint8_t )2;
#line 50
  retval.argb_or_distance = distance;
#line 51
  retval.len = len;
#line 52
  return (retval);
}
}
#line 55 "../../src/enc/backward_references_enc.h"
__inline static PixOrCopy PixOrCopyCreateCacheIdx(int idx ) 
{ 
  PixOrCopy retval ;

  {
#line 59
  retval.mode = (uint8_t )1;
#line 60
  retval.argb_or_distance = (uint32_t )idx;
#line 61
  retval.len = (uint16_t )1;
#line 62
  return (retval);
}
}
#line 65 "../../src/enc/backward_references_enc.h"
__inline static PixOrCopy PixOrCopyCreateLiteral(uint32_t argb ) 
{ 
  PixOrCopy retval ;

  {
#line 67
  retval.mode = (uint8_t )0;
#line 68
  retval.argb_or_distance = argb;
#line 69
  retval.len = (uint16_t )1;
#line 70
  return (retval);
}
}
#line 73 "../../src/enc/backward_references_enc.h"
__inline static int PixOrCopyIsLiteral(PixOrCopy *p ) 
{ 


  {
#line 74
  return ((int )p->mode == 0);
}
}
#line 77 "../../src/enc/backward_references_enc.h"
__inline static int PixOrCopyIsCacheIdx(PixOrCopy *p ) 
{ 


  {
#line 78
  return ((int )p->mode == 1);
}
}
#line 81 "../../src/enc/backward_references_enc.h"
__inline static int PixOrCopyIsCopy(PixOrCopy *p ) 
{ 


  {
#line 82
  return ((int )p->mode == 2);
}
}
#line 85 "../../src/enc/backward_references_enc.h"
__inline static uint32_t PixOrCopyLiteral(PixOrCopy *p , int component ) 
{ 


  {
#line 88
  return ((p->argb_or_distance >> component * 8) & 255U);
}
}
#line 91 "../../src/enc/backward_references_enc.h"
__inline static uint32_t PixOrCopyLength(PixOrCopy *p ) 
{ 


  {
#line 92
  return ((uint32_t )p->len);
}
}
#line 95 "../../src/enc/backward_references_enc.h"
__inline static uint32_t PixOrCopyCacheIdx(PixOrCopy *p ) 
{ 


  {
#line 98
  return (p->argb_or_distance);
}
}
#line 136
int VP8LHashChainInit(VP8LHashChain *p , int size ) ;
#line 138
int VP8LHashChainFill(VP8LHashChain *p , int quality , uint32_t *argb , int xsize ,
                      int ysize , int low_effort ) ;
#line 141
void VP8LHashChainClear(VP8LHashChain *p ) ;
#line 143 "../../src/enc/backward_references_enc.h"
__inline static int VP8LHashChainFindOffset(VP8LHashChain *p , int base_position ) 
{ 


  {
#line 145
  return ((int )(*(p->offset_length_ + base_position) >> 12));
}
}
#line 148 "../../src/enc/backward_references_enc.h"
__inline static int VP8LHashChainFindLength(VP8LHashChain *p , int base_position ) 
{ 


  {
#line 150
  return ((int )(*(p->offset_length_ + base_position) & ((1U << 12) - 1U)));
}
}
#line 153 "../../src/enc/backward_references_enc.h"
__inline static void VP8LHashChainFindCopy(VP8LHashChain *p , int base_position ,
                                           int *offset_ptr , int *length_ptr ) 
{ 


  {
  {
#line 157
  *offset_ptr = VP8LHashChainFindOffset(p, base_position);
#line 158
  *length_ptr = VP8LHashChainFindLength(p, base_position);
  }
#line 160
  return;
}
}
#line 182
void VP8LBackwardRefsInit(VP8LBackwardRefs *refs , int block_size ) ;
#line 184
void VP8LBackwardRefsClear(VP8LBackwardRefs *refs ) ;
#line 196
VP8LRefsCursor VP8LRefsCursorInit(VP8LBackwardRefs *refs ) ;
#line 198 "../../src/enc/backward_references_enc.h"
__inline static int VP8LRefsCursorOk(VP8LRefsCursor *c ) 
{ 


  {
#line 199
  return ((unsigned long )c->cur_pos != (unsigned long )((void *)0));
}
}
#line 202
void VP8LRefsCursorNextBlock(VP8LRefsCursor *c ) ;
#line 204 "../../src/enc/backward_references_enc.h"
__inline static void VP8LRefsCursorNext(VP8LRefsCursor *c ) 
{ 


  {
#line 207
  (c->cur_pos) ++;
#line 207
  if ((unsigned long )c->cur_pos == (unsigned long )c->last_pos_) {
    {
#line 207
    VP8LRefsCursorNextBlock(c);
    }
  }
#line 210
  return;
}
}
#line 230
WebPEncodingError VP8LGetBackwardReferences(int width , int height , uint32_t *argb ,
                                            int quality , int low_effort , int lz77_types_to_try ,
                                            int cache_bits_max , int do_no_cache ,
                                            VP8LHashChain *hash_chain , VP8LBackwardRefs *refs ,
                                            int *cache_bits_best ) ;
#line 63 "../../src/enc/histogram_enc.h"
void VP8LHistogramCreate(VP8LHistogram *p , VP8LBackwardRefs *refs , int palette_code_bits ) ;
#line 68
int VP8LGetHistogramSize(int cache_bits ) ;
#line 72
void VP8LHistogramInit(VP8LHistogram *p , int palette_code_bits , int init_arrays ) ;
#line 76
void VP8LHistogramStoreRefs(VP8LBackwardRefs *refs , VP8LHistogram *histo ) ;
#line 80
void VP8LFreeHistogram(VP8LHistogram *histo ) ;
#line 83
void VP8LFreeHistogramSet(VP8LHistogramSet *histo ) ;
#line 87
VP8LHistogramSet *VP8LAllocateHistogramSet(int size , int cache_bits ) ;
#line 90
void VP8LHistogramSetClear(VP8LHistogramSet *set ) ;
#line 95
VP8LHistogram *VP8LAllocateHistogram(int cache_bits ) ;
#line 98
void VP8LHistogramAddSinglePixOrCopy(VP8LHistogram *histo , PixOrCopy *v , int (*distance_modifier)(int  ,
                                                                                                    int  ) ,
                                     int distance_modifier_arg0 ) ;
#line 103 "../../src/enc/histogram_enc.h"
__inline static int VP8LHistogramNumCodes(int palette_code_bits ) 
{ 
  int tmp ;

  {
#line 104
  if (palette_code_bits > 0) {
#line 104
    tmp = 1 << palette_code_bits;
  } else {
#line 104
    tmp = 0;
  }
#line 104
  return (280 + tmp);
}
}
#line 109
int VP8LGetHistoImageSymbols(int xsize , int ysize , VP8LBackwardRefs *refs , int quality ,
                             int low_effort , int histogram_bits , int cache_bits ,
                             VP8LHistogramSet *image_histo , VP8LHistogram *tmp_histo ,
                             uint16_t *histogram_symbols ) ;
#line 118
double VP8LBitsEntropy(uint32_t *array , int n ) ;
#line 122
double VP8LHistogramEstimateBits(VP8LHistogram *p ) ;
#line 87 "../../src/enc/vp8li_enc.h"
int VP8LEncodeImage(WebPConfig *config , WebPPicture *picture ) ;
#line 92
WebPEncodingError VP8LEncodeStream(WebPConfig *config , WebPPicture *picture , VP8LBitWriter *bw_main ,
                                   int use_cache ) ;
#line 99
int VP8ApplyNearLossless(WebPPicture *picture , int quality , uint32_t *argb_dst ) ;
#line 106
void VP8LResidualImage(int width , int height , int bits , int low_effort , uint32_t *argb ,
                       uint32_t *argb_scratch , uint32_t *image , int near_lossless_quality ,
                       int exact , int used_subtract_green ) ;
#line 111
void VP8LColorSpaceTransform(int width , int height , int bits , int quality , uint32_t *argb ,
                             uint32_t *image ) ;
#line 32 "/root/patron-new/new_3/src/enc/webp_enc.c"
int WebPGetEncoderVersion(void) 
{ 


  {
#line 33
  return ((1 << 16) | (2 << 8));
}
}
#line 40 "/root/patron-new/new_3/src/enc/webp_enc.c"
static void ResetSegmentHeader(VP8Encoder *enc ) 
{ 
  VP8EncSegmentHeader *hdr ;

  {
#line 41
  hdr = & enc->segment_hdr_;
#line 42
  hdr->num_segments_ = (enc->config_)->segments;
#line 43
  hdr->update_map_ = hdr->num_segments_ > 1;
#line 44
  hdr->size_ = 0;
#line 45
  return;
}
}
#line 47 "/root/patron-new/new_3/src/enc/webp_enc.c"
static void ResetFilterHeader(VP8Encoder *enc ) 
{ 
  VP8EncFilterHeader *hdr ;

  {
#line 48
  hdr = & enc->filter_hdr_;
#line 49
  hdr->simple_ = 1;
#line 50
  hdr->level_ = 0;
#line 51
  hdr->sharpness_ = 0;
#line 52
  hdr->i4x4_lf_delta_ = 0;
#line 53
  return;
}
}
#line 55 "/root/patron-new/new_3/src/enc/webp_enc.c"
static void ResetBoundaryPredictions(VP8Encoder *enc ) 
{ 
  int i ;
  uint8_t *top ;
  uint8_t *left ;

  {
#line 59
  top = enc->preds_ - enc->preds_w_;
#line 60
  left = enc->preds_ - 1;
#line 61
  i = -1;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;

#line 61
    if (! (i < 4 * enc->mb_w_)) {
#line 61
      goto while_break;
    }
#line 62
    *(top + i) = (uint8_t )0;
#line 61
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 64
  i = 0;
  {
#line 64
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 64
    if (! (i < 4 * enc->mb_h_)) {
#line 64
      goto while_break___0;
    }
#line 65
    *(left + i * enc->preds_w_) = (uint8_t )0;
#line 64
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
#line 67
  *(enc->nz_ + -1) = (uint32_t )0;
#line 68
  return;
}
}
#line 95 "/root/patron-new/new_3/src/enc/webp_enc.c"
static void MapConfigToTools(VP8Encoder *enc ) 
{ 
  WebPConfig *config ;
  int method ;
  int limit ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 96
  config = enc->config_;
#line 97
  method = config->method;
#line 98
  limit = 100 - config->partition_limit;
#line 99
  enc->method_ = method;
#line 100
  if (method >= 6) {
#line 100
    tmp___1 = 3;
  } else {
#line 100
    if (method >= 5) {
#line 100
      tmp___0 = 2;
    } else {
#line 100
      if (method >= 3) {
#line 100
        tmp = 1;
      } else {
#line 100
        tmp = 0;
      }
#line 100
      tmp___0 = tmp;
    }
#line 100
    tmp___1 = tmp___0;
  }
#line 100
  enc->rd_opt_level_ = (VP8RDLevel )tmp___1;
#line 104
  enc->max_i4_header_bits_ = (65536 * (limit * limit)) / 10000;
#line 109
  enc->mb_header_limit_ = (int )(1069547520L / (long )(enc->mb_w_ * enc->mb_h_));
#line 112
  enc->thread_level_ = config->thread_level;
#line 114
  if (config->target_size > 0) {
#line 114
    tmp___2 = 1;
  } else
#line 114
  if (config->target_PSNR > (float )0) {
#line 114
    tmp___2 = 1;
  } else {
#line 114
    tmp___2 = 0;
  }
#line 114
  enc->do_search_ = tmp___2;
#line 115
  if (! config->low_memory) {
#line 117
    enc->use_tokens_ = (unsigned int )enc->rd_opt_level_ >= 1U;
#line 119
    if (enc->use_tokens_) {
#line 120
      enc->num_parts_ = 1;
    }
  }
#line 123
  return;
}
}
#line 144 "/root/patron-new/new_3/src/enc/webp_enc.c"
static VP8Encoder *InitVP8Encoder(WebPConfig *config , WebPPicture *picture ) 
{ 
  VP8Encoder *enc ;
  int use_filter ;
  int mb_w ;
  int mb_h ;
  int preds_w ;
  int preds_h ;
  size_t preds_size ;
  int top_stride ;
  size_t nz_size ;
  size_t info_size ;
  size_t samples_size ;
  size_t lf_stats_size ;
  unsigned long tmp ;
  size_t top_derr_size ;
  unsigned long tmp___0 ;
  uint8_t *mem ;
  uint64_t size ;
  void *__cil_tmp20 ;
  LFStats *tmp___1 ;
  DError *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  float scale ;
  int tmp___5 ;

  {
#line 147
  if (config->filter_strength > 0) {
#line 147
    tmp___5 = 1;
  } else
#line 147
  if (config->autofilter > 0) {
#line 147
    tmp___5 = 1;
  } else {
#line 147
    tmp___5 = 0;
  }
#line 147
  use_filter = tmp___5;
#line 149
  mb_w = (picture->width + 15) >> 4;
#line 150
  mb_h = (picture->height + 15) >> 4;
#line 151
  preds_w = 4 * mb_w + 1;
#line 152
  preds_h = 4 * mb_h + 1;
#line 153
  preds_size = (unsigned long )(preds_w * preds_h) * sizeof(*(enc->preds_));
#line 154
  top_stride = mb_w * 16;
#line 155
  nz_size = (unsigned long )(mb_w + 1) * sizeof(*(enc->nz_)) + 31UL;
#line 156
  info_size = (unsigned long )(mb_w * mb_h) * sizeof(*(enc->mb_info_));
#line 157
  samples_size = (unsigned long )(2 * top_stride) * sizeof(*(enc->y_top_)) + 31UL;
#line 160
  if (config->autofilter) {
#line 160
    tmp = sizeof(*(enc->lf_stats_)) + 31UL;
  } else {
#line 160
    tmp = 0UL;
  }
#line 160
  lf_stats_size = tmp;
#line 162
  if (config->quality <= (float )98) {
#line 162
    tmp___0 = (unsigned long )mb_w * sizeof(*(enc->top_derr_));
  } else
#line 162
  if (config->pass > 1) {
#line 162
    tmp___0 = (unsigned long )mb_w * sizeof(*(enc->top_derr_));
  } else {
#line 162
    tmp___0 = 0UL;
  }
  {
#line 162
  top_derr_size = tmp___0;
#line 166
  size = ((((((sizeof(*enc) + 31UL) + info_size) + preds_size) + samples_size) + top_derr_size) + nz_size) + lf_stats_size;
#line 201
  __cil_tmp20 = WebPSafeMalloc(size, sizeof(*mem));
#line 201
  mem = (uint8_t *)__cil_tmp20;
  }
#line 202
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
    {
#line 203
    WebPEncodingSetError(picture, (WebPEncodingError )1);
    }
#line 204
    return ((VP8Encoder *)((void *)0));
  }
  {
#line 206
  enc = (VP8Encoder *)mem;
#line 207
  mem = (uint8_t *)(((uintptr_t )(mem + sizeof(*enc)) + 31UL) & 0xffffffffffffffe0UL);
#line 208
  memset((void *)enc, 0, sizeof(*enc));
#line 209
  enc->num_parts_ = 1 << config->partitions;
#line 210
  enc->mb_w_ = mb_w;
#line 211
  enc->mb_h_ = mb_h;
#line 212
  enc->preds_w_ = preds_w;
#line 213
  enc->mb_info_ = (VP8MBInfo *)mem;
#line 214
  mem += info_size;
#line 215
  enc->preds_ = (mem + 1) + enc->preds_w_;
#line 216
  mem += preds_size;
#line 217
  enc->nz_ = (uint32_t *)(((uintptr_t )mem + 31UL) & 0xffffffffffffffe0UL) + 1;
#line 218
  mem += nz_size;
  }
#line 219
  if (lf_stats_size) {
#line 219
    tmp___1 = (LFStats *)(((uintptr_t )mem + 31UL) & 0xffffffffffffffe0UL);
  } else {
#line 219
    tmp___1 = (LFStats *)((void *)0);
  }
#line 219
  enc->lf_stats_ = (LFStats *)((int )tmp___1);
#line 220
  mem += lf_stats_size;
#line 223
  mem = (uint8_t *)(((uintptr_t )mem + 31UL) & 0xffffffffffffffe0UL);
#line 224
  enc->y_top_ = mem;
#line 225
  enc->uv_top_ = enc->y_top_ + top_stride;
#line 226
  mem += 2 * top_stride;
#line 227
  if (top_derr_size) {
#line 227
    tmp___2 = (DError *)mem;
  } else {
#line 227
    tmp___2 = (DError *)((void *)0);
  }
#line 227
  enc->top_derr_ = (DError *)((int )tmp___2);
#line 228
  mem += top_derr_size;
#line 231
  enc->config_ = config;
#line 232
  if (use_filter) {
#line 232
    if (config->filter_type == 1) {
#line 232
      tmp___3 = 0;
    } else {
#line 232
      tmp___3 = 1;
    }
#line 232
    tmp___4 = tmp___3;
  } else {
#line 232
    tmp___4 = 2;
  }
  {
#line 232
  enc->profile_ = tmp___4;
#line 233
  enc->pic_ = picture;
#line 234
  enc->percent_ = 0;
#line 236
  MapConfigToTools(enc);
#line 237
  VP8EncDspInit();
#line 238
  VP8DefaultProbas(enc);
#line 239
  ResetSegmentHeader(enc);
#line 240
  ResetFilterHeader(enc);
#line 241
  ResetBoundaryPredictions(enc);
#line 242
  VP8EncDspCostInit();
#line 243
  VP8EncInitAlpha(enc);
#line 248
  scale = 1.f + (config->quality * 5.f) / 100.f;
#line 249
  VP8TBufferInit(& enc->tokens_, (int )((float )((mb_w * mb_h) * 4) * scale));
  }
#line 251
  return (enc);
}
}
#line 254 "/root/patron-new/new_3/src/enc/webp_enc.c"
static int DeleteVP8Encoder(VP8Encoder *enc ) 
{ 
  int ok ;

  {
#line 255
  ok = 1;
#line 256
  if ((unsigned long )enc != (unsigned long )((void *)0)) {
    {
#line 257
    ok = VP8EncDeleteAlpha(enc);
#line 258
    VP8TBufferClear(& enc->tokens_);
#line 259
    WebPSafeFree((void *)enc);
    }
  }
#line 261
  return (ok);
}
}
#line 267 "/root/patron-new/new_3/src/enc/webp_enc.c"
static double GetPSNR(uint64_t err , uint64_t size ) 
{ 
  double __cil_tmp3 ;
  double tmp ;

  {
#line 268
  if (err > 0UL) {
#line 268
    if (size > 0UL) {
      {
#line 268
      __cil_tmp3 = log10(((255. * 255.) * (double )size) / (double )err);
#line 268
      tmp = 10. * __cil_tmp3;
      }
    } else {
#line 268
      tmp = 99.;
    }
  } else {
#line 268
    tmp = 99.;
  }
#line 268
  return (tmp);
}
}
#line 271 "/root/patron-new/new_3/src/enc/webp_enc.c"
static void FinalizePSNR(VP8Encoder *enc ) 
{ 
  WebPAuxStats *stats ;
  uint64_t size ;
  uint64_t *sse ;
  double __cil_tmp5 ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;

  {
  {
#line 272
  stats = (enc->pic_)->stats;
#line 273
  size = enc->sse_count_;
#line 274
  sse = enc->sse_;
#line 275
  __cil_tmp5 = GetPSNR(*(sse + 0), size);
#line 275
  stats->PSNR[0] = (float )__cil_tmp5;
#line 276
  __cil_tmp6 = GetPSNR(*(sse + 1), size / 4UL);
#line 276
  stats->PSNR[1] = (float )__cil_tmp6;
#line 277
  __cil_tmp7 = GetPSNR(*(sse + 2), size / 4UL);
#line 277
  stats->PSNR[2] = (float )__cil_tmp7;
#line 278
  __cil_tmp8 = GetPSNR((*(sse + 0) + *(sse + 1)) + *(sse + 2), (size * 3UL) / 2UL);
#line 278
  stats->PSNR[3] = (float )__cil_tmp8;
#line 279
  __cil_tmp9 = GetPSNR(*(sse + 3), size);
#line 279
  stats->PSNR[4] = (float )__cil_tmp9;
  }
#line 281
  return;
}
}
#line 283 "/root/patron-new/new_3/src/enc/webp_enc.c"
static void StoreStats(VP8Encoder *enc ) 
{ 
  WebPAuxStats *stats ;
  int i ;
  int s ;

  {
#line 285
  stats = (enc->pic_)->stats;
#line 286
  if ((unsigned long )stats != (unsigned long )((void *)0)) {
#line 288
    i = 0;
    {
#line 288
    while (1) {
      while_continue: /* CIL Label */ ;

#line 288
      if (! (i < 4)) {
#line 288
        goto while_break;
      }
#line 289
      stats->segment_level[i] = enc->dqm_[i].fstrength_;
#line 290
      stats->segment_quant[i] = enc->dqm_[i].quant_;
#line 291
      s = 0;
      {
#line 291
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 291
        if (! (s <= 2)) {
#line 291
          goto while_break___0;
        }
#line 292
        stats->residual_bytes[s][i] = enc->residual_bytes_[s][i];
#line 291
        s ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: 
#line 288
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: 
    {
#line 295
    FinalizePSNR(enc);
#line 296
    stats->coded_size = enc->coded_size_;
#line 297
    i = 0;
    }
    {
#line 297
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 297
      if (! (i < 3)) {
#line 297
        goto while_break___1;
      }
#line 298
      stats->block_count[i] = enc->block_count_[i];
#line 297
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 302
  return;
}
}
#line 306 "/root/patron-new/new_3/src/enc/webp_enc.c"
int WebPEncodingSetError(WebPPicture *pic , WebPEncodingError error ) 
{ 


  {
#line 310
  pic->error_code = error;
#line 311
  return (0);
}
}
#line 314 "/root/patron-new/new_3/src/enc/webp_enc.c"
int WebPReportProgress(WebPPicture *pic , int percent , int *percent_store ) 
{ 
  int __cil_tmp4 ;

  {
#line 316
  if ((unsigned long )percent_store != (unsigned long )((void *)0)) {
#line 316
    if (percent != *percent_store) {
      {
#line 317
      *percent_store = percent;
#line 318
      __cil_tmp4 = (*(pic->progress_hook))(percent, pic);
      }
#line 318
      if (pic->progress_hook) {
#line 318
        if (! __cil_tmp4) {
          {
#line 320
          WebPEncodingSetError(pic, (WebPEncodingError )10);
          }
#line 321
          return (0);
        }
      }
    }
  }
#line 324
  return (1);
}
}
#line 328 "/root/patron-new/new_3/src/enc/webp_enc.c"
int WebPEncode(WebPConfig *config , WebPPicture *pic ) 
{ 
  int ok ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  VP8Encoder *enc ;
  int __cil_tmp10 ;
  float dithering ;
  float x ;
  float x2 ;
  int __cil_tmp14 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 329
  ok = 0;
#line 330
  if ((unsigned long )pic == (unsigned long )((void *)0)) {
#line 330
    return (0);
  }
  {
#line 332
  WebPEncodingSetError(pic, (WebPEncodingError )0);
  }
#line 333
  if ((unsigned long )config == (unsigned long )((void *)0)) {
    {
#line 334
    __cil_tmp4 = WebPEncodingSetError(pic, (WebPEncodingError )3);
    }
#line 334
    return (__cil_tmp4);
  }
  {
#line 336
  __cil_tmp5 = WebPValidateConfig(config);
  }
#line 336
  if (! __cil_tmp5) {
    {
#line 337
    __cil_tmp6 = WebPEncodingSetError(pic, (WebPEncodingError )4);
    }
#line 337
    return (__cil_tmp6);
  }
#line 339
  if (pic->width <= 0) {
    {
#line 340
    __cil_tmp7 = WebPEncodingSetError(pic, (WebPEncodingError )5);
    }
#line 340
    return (__cil_tmp7);
  } else
#line 339
  if (pic->height <= 0) {
    {
#line 340
    __cil_tmp7 = WebPEncodingSetError(pic, (WebPEncodingError )5);
    }
#line 340
    return (__cil_tmp7);
  }
#line 342
  if (pic->width > 16383) {
    {
#line 343
    __cil_tmp8 = WebPEncodingSetError(pic, (WebPEncodingError )5);
    }
#line 343
    return (__cil_tmp8);
  } else
#line 342
  if (pic->height > 16383) {
    {
#line 343
    __cil_tmp8 = WebPEncodingSetError(pic, (WebPEncodingError )5);
    }
#line 343
    return (__cil_tmp8);
  }
#line 346
  if ((unsigned long )pic->stats != (unsigned long )((void *)0)) {
    {
#line 346
    memset((void *)pic->stats, 0, sizeof(*(pic->stats)));
    }
  }
#line 348
  if (! config->lossless) {
#line 349
    enc = (VP8Encoder *)((void *)0);
#line 351
    if ((unsigned long )pic->y == (unsigned long )((void *)0)) {
      _L___7: 
#line 353
      if (config->use_sharp_yuv) {
        _L: 
        {
#line 354
        __cil_tmp10 = WebPPictureSharpARGBToYUVA(pic);
        }
#line 354
        if (! __cil_tmp10) {
#line 355
          return (0);
        }
      } else
#line 353
      if (config->preprocessing & 4) {
#line 353
        goto _L;
      } else {
#line 358
        dithering = 0.f;
#line 359
        if (config->preprocessing & 2) {
#line 360
          x = config->quality / 100.f;
#line 361
          x2 = x * x;
#line 364
          dithering = 1.f + ((0.5f - 1.f) * x2) * x2;
        }
        {
#line 366
        __cil_tmp14 = WebPPictureARGBToYUVADithered(pic, (WebPEncCSP )0, dithering);
        }
#line 366
        if (! __cil_tmp14) {
#line 367
          return (0);
        }
      }
    } else
#line 351
    if (pic->use_argb) {
#line 351
      goto _L___7;
    } else
#line 351
    if ((unsigned long )pic->u == (unsigned long )((void *)0)) {
#line 351
      goto _L___7;
    } else
#line 351
    if ((unsigned long )pic->v == (unsigned long )((void *)0)) {
#line 351
      goto _L___7;
    }
#line 372
    if (! config->exact) {
      {
#line 373
      WebPCleanupTransparentArea(pic);
      }
    }
    {
#line 376
    enc = InitVP8Encoder(config, pic);
    }
#line 377
    if ((unsigned long )enc == (unsigned long )((void *)0)) {
#line 377
      return (0);
    }
    {
#line 379
    ok = VP8EncAnalyze(enc);
#line 382
    __cil_tmp17 = VP8EncStartAlpha(enc);
    }
#line 382
    if (ok) {
#line 382
      if (__cil_tmp17) {
#line 382
        tmp = 1;
      } else {
#line 382
        tmp = 0;
      }
    } else {
#line 382
      tmp = 0;
    }
#line 382
    ok = tmp;
#line 383
    if (! enc->use_tokens_) {
      {
#line 384
      __cil_tmp18 = VP8EncLoop(enc);
      }
#line 384
      if (ok) {
#line 384
        if (__cil_tmp18) {
#line 384
          tmp___0 = 1;
        } else {
#line 384
          tmp___0 = 0;
        }
      } else {
#line 384
        tmp___0 = 0;
      }
#line 384
      ok = tmp___0;
    } else {
      {
#line 386
      __cil_tmp19 = VP8EncTokenLoop(enc);
      }
#line 386
      if (ok) {
#line 386
        if (__cil_tmp19) {
#line 386
          tmp___1 = 1;
        } else {
#line 386
          tmp___1 = 0;
        }
      } else {
#line 386
        tmp___1 = 0;
      }
#line 386
      ok = tmp___1;
    }
    {
#line 388
    __cil_tmp20 = VP8EncFinishAlpha(enc);
    }
#line 388
    if (ok) {
#line 388
      if (__cil_tmp20) {
#line 388
        tmp___2 = 1;
      } else {
#line 388
        tmp___2 = 0;
      }
    } else {
#line 388
      tmp___2 = 0;
    }
    {
#line 388
    ok = tmp___2;
#line 390
    __cil_tmp21 = VP8EncWrite(enc);
    }
#line 390
    if (ok) {
#line 390
      if (__cil_tmp21) {
#line 390
        tmp___3 = 1;
      } else {
#line 390
        tmp___3 = 0;
      }
    } else {
#line 390
      tmp___3 = 0;
    }
    {
#line 390
    ok = tmp___3;
#line 391
    StoreStats(enc);
    }
#line 392
    if (! ok) {
      {
#line 393
      VP8EncFreeBitWriters(enc);
      }
    }
    {
#line 395
    __cil_tmp22 = DeleteVP8Encoder(enc);
#line 395
    ok &= __cil_tmp22;
    }
  } else {
    {
#line 398
    __cil_tmp23 = WebPPictureYUVAToARGB(pic);
    }
#line 398
    if ((unsigned long )pic->argb == (unsigned long )((void *)0)) {
#line 398
      if (! __cil_tmp23) {
#line 399
        return (0);
      }
    }
#line 402
    if (! config->exact) {
      {
#line 403
      WebPReplaceTransparentPixels(pic, (uint32_t )0);
      }
    }
    {
#line 406
    ok = VP8LEncodeImage(config, pic);
    }
  }
#line 409
  return (ok);
}
}
#line 32 "../../src/dsp/lossless.h"
VP8LPredictorFunc VP8LPredictors[16]  ;
#line 34
uint32_t VP8LPredictor0_C(uint32_t left , uint32_t *top ) ;
#line 35
uint32_t VP8LPredictor1_C(uint32_t left , uint32_t *top ) ;
#line 36
uint32_t VP8LPredictor2_C(uint32_t left , uint32_t *top ) ;
#line 37
uint32_t VP8LPredictor3_C(uint32_t left , uint32_t *top ) ;
#line 38
uint32_t VP8LPredictor4_C(uint32_t left , uint32_t *top ) ;
#line 39
uint32_t VP8LPredictor5_C(uint32_t left , uint32_t *top ) ;
#line 40
uint32_t VP8LPredictor6_C(uint32_t left , uint32_t *top ) ;
#line 41
uint32_t VP8LPredictor7_C(uint32_t left , uint32_t *top ) ;
#line 42
uint32_t VP8LPredictor8_C(uint32_t left , uint32_t *top ) ;
#line 43
uint32_t VP8LPredictor9_C(uint32_t left , uint32_t *top ) ;
#line 44
uint32_t VP8LPredictor10_C(uint32_t left , uint32_t *top ) ;
#line 45
uint32_t VP8LPredictor11_C(uint32_t left , uint32_t *top ) ;
#line 46
uint32_t VP8LPredictor12_C(uint32_t left , uint32_t *top ) ;
#line 47
uint32_t VP8LPredictor13_C(uint32_t left , uint32_t *top ) ;
#line 53 "../../src/dsp/lossless.h"
VP8LPredictorAddSubFunc VP8LPredictorsAdd[16]  ;
#line 54 "../../src/dsp/lossless.h"
VP8LPredictorAddSubFunc VP8LPredictorsAdd_C[16]  ;
#line 58 "../../src/dsp/lossless.h"
void (*VP8LAddGreenToBlueAndRed)(uint32_t * , int  , uint32_t * )  ;
#line 70 "../../src/dsp/lossless.h"
void (*VP8LTransformColorInverse)(VP8LMultipliers * const   , uint32_t * , int  ,
                                  uint32_t * )  ;
#line 78
void VP8LInverseTransform(VP8LTransform *transform , int row_start , int row_end ,
                          uint32_t *in , uint32_t *out ) ;
#line 85 "../../src/dsp/lossless.h"
void (*VP8LConvertBGRAToRGB)(uint32_t * , int  , uint8_t * )  ;
#line 86 "../../src/dsp/lossless.h"
void (*VP8LConvertBGRAToRGBA)(uint32_t * , int  , uint8_t * )  ;
#line 87 "../../src/dsp/lossless.h"
void (*VP8LConvertBGRAToRGBA4444)(uint32_t * , int  , uint8_t * )  ;
#line 88 "../../src/dsp/lossless.h"
void (*VP8LConvertBGRAToRGB565)(uint32_t * , int  , uint8_t * )  ;
#line 89 "../../src/dsp/lossless.h"
void (*VP8LConvertBGRAToBGR)(uint32_t * , int  , uint8_t * )  ;
#line 92
void VP8LConvertFromBGRA(uint32_t *in_data , int num_pixels , WEBP_CSP_MODE out_colorspace ,
                         uint8_t *rgba ) ;
#line 104 "../../src/dsp/lossless.h"
void (*VP8LMapColor32b)(uint32_t * , uint32_t * const   , uint32_t * , int  , int  ,
                        int  )  ;
#line 105 "../../src/dsp/lossless.h"
void (*VP8LMapColor8b)(uint8_t * , uint32_t * const   , uint8_t * , int  , int  ,
                       int  )  ;
#line 110
void VP8LColorIndexInverseTransformAlpha(VP8LTransform *transform , int y_start ,
                                         int y_end , uint8_t *src , uint8_t *dst ) ;
#line 115
void VP8LTransformColorInverse_C(VP8LMultipliers *m , uint32_t *src , int num_pixels ,
                                 uint32_t *dst ) ;
#line 119
void VP8LConvertBGRAToRGB_C(uint32_t *src , int num_pixels , uint8_t *dst ) ;
#line 120
void VP8LConvertBGRAToRGBA_C(uint32_t *src , int num_pixels , uint8_t *dst ) ;
#line 121
void VP8LConvertBGRAToRGBA4444_C(uint32_t *src , int num_pixels , uint8_t *dst ) ;
#line 123
void VP8LConvertBGRAToRGB565_C(uint32_t *src , int num_pixels , uint8_t *dst ) ;
#line 125
void VP8LConvertBGRAToBGR_C(uint32_t *src , int num_pixels , uint8_t *dst ) ;
#line 126
void VP8LAddGreenToBlueAndRed_C(uint32_t *src , int num_pixels , uint32_t *dst ) ;
#line 130
void VP8LDspInit(void) ;
#line 136 "../../src/dsp/lossless.h"
void (*VP8LSubtractGreenFromBlueAndRed)(uint32_t * , int  )  ;
#line 139 "../../src/dsp/lossless.h"
void (*VP8LTransformColor)(VP8LMultipliers * const   , uint32_t * , int  )  ;
#line 144 "../../src/dsp/lossless.h"
void (*VP8LCollectColorBlueTransforms)(uint32_t * , int  , int  , int  , int  , int  ,
                                       int * )  ;
#line 150 "../../src/dsp/lossless.h"
void (*VP8LCollectColorRedTransforms)(uint32_t * , int  , int  , int  , int  , int * )  ;
#line 153
void VP8LTransformColor_C(VP8LMultipliers *m , uint32_t *data , int num_pixels ) ;
#line 155
void VP8LSubtractGreenFromBlueAndRed_C(uint32_t *argb_data , int num_pixels ) ;
#line 156
void VP8LCollectColorRedTransforms_C(uint32_t *argb , int stride , int tile_width ,
                                     int tile_height , int green_to_red , int *histo ) ;
#line 159
void VP8LCollectColorBlueTransforms_C(uint32_t *argb , int stride , int tile_width ,
                                      int tile_height , int green_to_blue , int red_to_blue ,
                                      int *histo ) ;
#line 164 "../../src/dsp/lossless.h"
VP8LPredictorAddSubFunc VP8LPredictorsSub[16]  ;
#line 165 "../../src/dsp/lossless.h"
VP8LPredictorAddSubFunc VP8LPredictorsSub_C[16]  ;
#line 176 "../../src/dsp/lossless.h"
double (*VP8LExtraCost)(uint32_t * , int  )  ;
#line 177 "../../src/dsp/lossless.h"
double (*VP8LExtraCostCombined)(uint32_t * , uint32_t * , int  )  ;
#line 178 "../../src/dsp/lossless.h"
float (*VP8LCombinedShannonEntropy)(int const   * , int const   * )  ;
#line 193
void VP8LBitEntropyInit(VP8LBitEntropy *entropy ) ;
#line 201 "../../src/dsp/lossless.h"
void (*VP8LGetCombinedEntropyUnrefined)(uint32_t * , uint32_t * , int  , VP8LBitEntropy * const   ,
                                        VP8LStreaks * const   )  ;
#line 207 "../../src/dsp/lossless.h"
void (*VP8LGetEntropyUnrefined)(uint32_t * , int  , VP8LBitEntropy * const   , VP8LStreaks * const   )  ;
#line 209
void VP8LBitsEntropyUnrefined(uint32_t *array , int n , VP8LBitEntropy *entropy ) ;
#line 214 "../../src/dsp/lossless.h"
void (*VP8LAddVector)(uint32_t * , uint32_t * , uint32_t * , int  )  ;
#line 216 "../../src/dsp/lossless.h"
void (*VP8LAddVectorEq)(uint32_t * , uint32_t * , int  )  ;
#line 217
void VP8LHistogramAdd(VP8LHistogram *a , VP8LHistogram *b , VP8LHistogram *out ) ;
#line 227 "../../src/dsp/lossless.h"
int (*VP8LVectorMismatch)(uint32_t * const   , uint32_t * const   , int  )  ;
#line 231 "../../src/dsp/lossless.h"
void (*VP8LBundleColorMap)(uint8_t * const   , int  , int  , uint32_t * )  ;
#line 232
void VP8LBundleColorMap_C(uint8_t *row , int width , int xbits , uint32_t *dst ) ;
#line 236
void VP8LEncDspInit(void) ;
#line 31 "../../src/dsp/lossless_common.h"
__inline static uint32_t VP8GetARGBIndex(uint32_t idx ) 
{ 


  {
#line 32
  return ((idx >> 8) & 255U);
}
}
#line 35 "../../src/dsp/lossless_common.h"
__inline static uint8_t VP8GetAlphaIndex(uint8_t idx ) 
{ 


  {
#line 36
  return (idx);
}
}
#line 39 "../../src/dsp/lossless_common.h"
__inline static uint32_t VP8GetARGBValue(uint32_t val ) 
{ 


  {
#line 40
  return (val);
}
}
#line 43 "../../src/dsp/lossless_common.h"
__inline static uint8_t VP8GetAlphaValue(uint32_t val ) 
{ 


  {
#line 44
  return ((uint8_t )((val >> 8) & 255U));
}
}
#line 51 "../../src/dsp/lossless_common.h"
__inline static uint32_t VP8LSubSampleSize(uint32_t size , uint32_t sampling_bits ) 
{ 


  {
#line 53
  return (((size + (unsigned int )(1 << sampling_bits)) - 1U) >> sampling_bits);
}
}
#line 57 "../../src/dsp/lossless_common.h"
__inline static int VP8LNearLosslessBits(int near_lossless_quality ) 
{ 


  {
#line 64
  return (5 - near_lossless_quality / 20);
}
}
#line 78
float const   kLog2Table[256] ;
#line 79
float const   kSLog2Table[256] ;
#line 82 "../../src/dsp/lossless_common.h"
float (*VP8LFastLog2Slow)(uint32_t  )  ;
#line 83 "../../src/dsp/lossless_common.h"
float (*VP8LFastSLog2Slow)(uint32_t  )  ;
#line 85 "../../src/dsp/lossless_common.h"
__inline static float VP8LFastLog2(uint32_t v ) 
{ 
  float __cil_tmp2 ;
  float tmp ;

  {
#line 86
  if (v < 256U) {
#line 86
    tmp = (float )kLog2Table[v];
  } else {
    {
#line 86
    __cil_tmp2 = (*VP8LFastLog2Slow)(v);
#line 86
    tmp = (float )((float const   )__cil_tmp2);
    }
  }
#line 86
  return ((float )((int )tmp));
}
}
#line 89 "../../src/dsp/lossless_common.h"
__inline static float VP8LFastSLog2(uint32_t v ) 
{ 
  float __cil_tmp2 ;
  float tmp ;

  {
#line 90
  if (v < 256U) {
#line 90
    tmp = (float )kSLog2Table[v];
  } else {
    {
#line 90
    __cil_tmp2 = (*VP8LFastSLog2Slow)(v);
#line 90
    tmp = (float )((float const   )__cil_tmp2);
    }
  }
#line 90
  return ((float )((int )tmp));
}
}
#line 99 "../../src/dsp/lossless_common.h"
__inline static void VP8LPrefixEncodeBitsNoLUT(int distance , int *code , int *extra_bits ) 
{ 
  int highest_bit ;
  int __cil_tmp5 ;
  int second_highest_bit ;

  {
  {
#line 101
  distance --;
#line 101
  __cil_tmp5 = BitsLog2Floor((uint32_t )distance);
#line 101
  highest_bit = __cil_tmp5;
#line 102
  second_highest_bit = (distance >> (highest_bit - 1)) & 1;
#line 103
  *extra_bits = highest_bit - 1;
#line 104
  *code = 2 * highest_bit + second_highest_bit;
  }
#line 106
  return;
}
}
#line 107 "../../src/dsp/lossless_common.h"
__inline static void VP8LPrefixEncodeNoLUT(int distance , int *code , int *extra_bits ,
                                           int *extra_bits_value ) 
{ 
  int highest_bit ;
  int __cil_tmp6 ;
  int second_highest_bit ;

  {
  {
#line 110
  distance --;
#line 110
  __cil_tmp6 = BitsLog2Floor((uint32_t )distance);
#line 110
  highest_bit = __cil_tmp6;
#line 111
  second_highest_bit = (distance >> (highest_bit - 1)) & 1;
#line 112
  *extra_bits = highest_bit - 1;
#line 113
  *extra_bits_value = distance & ((1 << *extra_bits) - 1);
#line 114
  *code = 2 * highest_bit + second_highest_bit;
  }
#line 116
  return;
}
}
#line 124
VP8LPrefixCode kPrefixEncodeCode[512] ;
#line 125
uint8_t kPrefixEncodeExtraBitsValue[512] ;
#line 126 "../../src/dsp/lossless_common.h"
__inline static void VP8LPrefixEncodeBits(int distance , int *code , int *extra_bits ) 
{ 
  VP8LPrefixCode prefix_code ;

  {
#line 128
  if (distance < 512) {
#line 129
    prefix_code = kPrefixEncodeCode[distance];
#line 130
    *code = (int )prefix_code.code_;
#line 131
    *extra_bits = (int )prefix_code.extra_bits_;
  } else {
    {
#line 133
    VP8LPrefixEncodeBitsNoLUT(distance, code, extra_bits);
    }
  }
#line 136
  return;
}
}
#line 137 "../../src/dsp/lossless_common.h"
__inline static void VP8LPrefixEncode(int distance , int *code , int *extra_bits ,
                                      int *extra_bits_value ) 
{ 
  VP8LPrefixCode prefix_code ;

  {
#line 140
  if (distance < 512) {
#line 141
    prefix_code = kPrefixEncodeCode[distance];
#line 142
    *code = (int )prefix_code.code_;
#line 143
    *extra_bits = (int )prefix_code.extra_bits_;
#line 144
    *extra_bits_value = (int )kPrefixEncodeExtraBitsValue[distance];
  } else {
    {
#line 146
    VP8LPrefixEncodeNoLUT(distance, code, extra_bits, extra_bits_value);
    }
  }
#line 149
  return;
}
}
#line 152 "../../src/dsp/lossless_common.h"
__inline static uint32_t VP8LAddPixels(uint32_t a , uint32_t b ) 
{ 
  uint32_t alpha_and_green ;
  uint32_t red_and_blue ;

  {
#line 153
  alpha_and_green = (a & 4278255360U) + (b & 4278255360U);
#line 154
  red_and_blue = (a & 16711935U) + (b & 16711935U);
#line 155
  return ((alpha_and_green & 4278255360U) | (red_and_blue & 16711935U));
}
}
#line 160 "../../src/dsp/lossless_common.h"
__inline static uint32_t VP8LSubPixels(uint32_t a , uint32_t b ) 
{ 
  uint32_t alpha_and_green ;
  uint32_t red_and_blue ;

  {
#line 161
  alpha_and_green = (16711935U + (a & 4278255360U)) - (b & 4278255360U);
#line 163
  red_and_blue = (4278255360U + (a & 16711935U)) - (b & 16711935U);
#line 165
  return ((alpha_and_green & 4278255360U) | (red_and_blue & 16711935U));
}
}
#line 34 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static int PaletteCompareColorsForQsort(void const   *p1 , void const   *p2 ) 
{ 
  uint32_t a ;
  uint32_t __cil_tmp4 ;
  uint32_t b ;
  uint32_t __cil_tmp6 ;
  int tmp ;

  {
  {
#line 35
  __cil_tmp4 = WebPMemToUint32((uint8_t *)p1);
#line 35
  a = __cil_tmp4;
#line 36
  __cil_tmp6 = WebPMemToUint32((uint8_t *)p2);
#line 36
  b = __cil_tmp6;
  }
#line 38
  if (a < b) {
#line 38
    tmp = -1;
  } else {
#line 38
    tmp = 1;
  }
#line 38
  return (tmp);
}
}
#line 41 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
__inline static uint32_t PaletteComponentDistance(uint32_t v ) 
{ 
  uint32_t tmp ;

  {
#line 42
  if (v <= 128U) {
#line 42
    tmp = v;
  } else {
#line 42
    tmp = 256U - v;
  }
#line 42
  return (tmp);
}
}
#line 50 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
__inline static uint32_t PaletteColorDistance(uint32_t col1 , uint32_t col2 ) 
{ 
  uint32_t diff ;
  uint32_t __cil_tmp4 ;
  int kMoreWeightForRGBThanForAlpha ;
  uint32_t score ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  uint32_t __cil_tmp10 ;

  {
  {
#line 51
  __cil_tmp4 = VP8LSubPixels(col1, col2);
#line 51
  diff = __cil_tmp4;
#line 52
  kMoreWeightForRGBThanForAlpha = 9;
#line 54
  score = PaletteComponentDistance(diff & 255U);
#line 55
  __cil_tmp8 = PaletteComponentDistance((diff >> 8) & 255U);
#line 55
  score += __cil_tmp8;
#line 56
  __cil_tmp9 = PaletteComponentDistance((diff >> 16) & 255U);
#line 56
  score += __cil_tmp9;
#line 57
  score *= (unsigned int )kMoreWeightForRGBThanForAlpha;
#line 58
  __cil_tmp10 = PaletteComponentDistance((diff >> 24) & 255U);
#line 58
  score += __cil_tmp10;
  }
#line 59
  return (score);
}
}
#line 62 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
__inline static void SwapColor(uint32_t *col1 , uint32_t *col2 ) 
{ 
  uint32_t tmp ;

  {
#line 63
  tmp = *col1;
#line 64
  *col1 = *col2;
#line 65
  *col2 = tmp;
#line 66
  return;
}
}
#line 68 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
__inline static int SearchColorNoIdx(uint32_t *sorted , uint32_t color , int num_colors ) 
{ 
  int low ;
  int hi ;
  int mid ;

  {
#line 70
  low = 0;
#line 70
  hi = num_colors;
#line 71
  if (*(sorted + low) == color) {
#line 71
    return (low);
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    mid = (low + hi) >> 1;
#line 74
    if (*(sorted + mid) == color) {
#line 75
      return (mid);
    } else
#line 76
    if (*(sorted + mid) < color) {
#line 77
      low = mid;
    } else {
#line 79
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 83
  return (0);
}
}
#line 92 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static int PaletteHasNonMonotonousDeltas(uint32_t *palette , int num_colors ) 
{ 
  uint32_t predict ;
  int i ;
  uint8_t sign_found ;
  uint32_t diff ;
  uint32_t __cil_tmp7 ;
  uint8_t rd ;
  uint8_t gd ;
  uint8_t bd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 94
  predict = (uint32_t )0;
#line 96
  sign_found = (uint8_t )0;
#line 97
  i = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;

#line 97
    if (! (i < num_colors)) {
#line 97
      goto while_break;
    }
    {
#line 98
    __cil_tmp7 = VP8LSubPixels(*(palette + i), predict);
#line 98
    diff = __cil_tmp7;
#line 99
    rd = (uint8_t )((diff >> 16) & 255U);
#line 100
    gd = (uint8_t )((diff >> 8) & 255U);
#line 101
    bd = (uint8_t )(diff & 255U);
    }
#line 102
    if ((int )rd != 0) {
#line 103
      if ((int )rd < 128) {
#line 103
        tmp = 1;
      } else {
#line 103
        tmp = 2;
      }
#line 103
      sign_found = (uint8_t )((int )sign_found | tmp);
    }
#line 105
    if ((int )gd != 0) {
#line 106
      if ((int )gd < 128) {
#line 106
        tmp___0 = 8;
      } else {
#line 106
        tmp___0 = 16;
      }
#line 106
      sign_found = (uint8_t )((int )sign_found | tmp___0);
    }
#line 108
    if ((int )bd != 0) {
#line 109
      if ((int )bd < 128) {
#line 109
        tmp___1 = 64;
      } else {
#line 109
        tmp___1 = 128;
      }
#line 109
      sign_found = (uint8_t )((int )sign_found | tmp___1);
    }
#line 111
    predict = *(palette + i);
#line 97
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 113
  return (((int )sign_found & ((int )sign_found << 1)) != 0);
}
}
#line 116 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static void PaletteSortMinimizeDeltas(uint32_t *palette_sorted , int num_colors ,
                                      uint32_t *palette ) 
{ 
  uint32_t predict ;
  int i ;
  int k ;
  int __cil_tmp7 ;
  int best_ix ;
  uint32_t best_score ;
  uint32_t cur_score ;
  uint32_t __cil_tmp11 ;

  {
  {
#line 118
  predict = (uint32_t )0;
#line 120
  memcpy((void *)palette, (void const   *)palette_sorted, (unsigned long )num_colors * sizeof(*palette));
#line 121
  __cil_tmp7 = PaletteHasNonMonotonousDeltas(palette_sorted, num_colors);
  }
#line 121
  if (! __cil_tmp7) {
#line 121
    return;
  }
#line 125
  i = 0;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;

#line 125
    if (! (i < num_colors)) {
#line 125
      goto while_break;
    }
#line 126
    best_ix = i;
#line 127
    best_score = ~ 0U;
#line 128
    k = i;
    {
#line 128
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 128
      if (! (k < num_colors)) {
#line 128
        goto while_break___0;
      }
      {
#line 129
      __cil_tmp11 = PaletteColorDistance(*(palette + k), predict);
#line 129
      cur_score = __cil_tmp11;
      }
#line 130
      if (best_score > cur_score) {
#line 131
        best_score = cur_score;
#line 132
        best_ix = k;
      }
#line 128
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 135
    SwapColor(palette + best_ix, palette + i);
#line 136
    predict = *(palette + i);
#line 125
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 129
  return;
}
}
#line 141 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static void PrepareMapToPalette(uint32_t *palette , uint32_t num_colors , uint32_t *sorted ,
                                uint32_t *idx_map ) 
{ 
  uint32_t i ;
  int __cil_tmp6 ;

  {
  {
#line 144
  memcpy((void *)sorted, (void const   *)palette, (unsigned long )num_colors * sizeof(*(sorted + 0)));
#line 145
  qsort((void *)sorted, (size_t )num_colors, sizeof(*(sorted + 0)), & PaletteCompareColorsForQsort);
#line 146
  i = (uint32_t )0;
  }
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;

#line 146
    if (! (i < num_colors)) {
#line 146
      goto while_break;
    }
    {
#line 147
    __cil_tmp6 = SearchColorNoIdx(sorted, *(palette + i), (int )num_colors);
#line 147
    *(idx_map + __cil_tmp6) = i;
#line 146
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 150
  return;
}
}
#line 157 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static void CoOccurrenceFindMax(uint32_t *cooccurrence , uint32_t num_colors , uint8_t *c1 ,
                                uint8_t *c2 ) 
{ 
  uint32_t best_sum ;
  uint32_t i ;
  uint32_t j ;
  uint32_t best_cooccurrence ;
  uint32_t sum ;

  {
#line 162
  best_sum = 0U;
#line 164
  *c1 = (uint8_t )0U;
#line 165
  i = (uint32_t )0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;

#line 165
    if (! (i < num_colors)) {
#line 165
      goto while_break;
    }
#line 166
    sum = (uint32_t )0;
#line 167
    j = (uint32_t )0;
    {
#line 167
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 167
      if (! (j < num_colors)) {
#line 167
        goto while_break___0;
      }
#line 167
      sum += *(cooccurrence + (i * num_colors + j));
#line 167
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
#line 168
    if (sum > best_sum) {
#line 169
      best_sum = sum;
#line 170
      *c1 = (uint8_t )i;
    }
#line 165
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 174
  *c2 = (uint8_t )0U;
#line 175
  best_cooccurrence = 0U;
#line 176
  i = (uint32_t )0;
  {
#line 176
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 176
    if (! (i < num_colors)) {
#line 176
      goto while_break___1;
    }
#line 177
    if (*(cooccurrence + ((unsigned int )*c1 * num_colors + i)) > best_cooccurrence) {
#line 178
      best_cooccurrence = *(cooccurrence + ((unsigned int )*c1 * num_colors + i));
#line 179
      *c2 = (uint8_t )i;
    }
#line 176
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: ;
#line 180
  return;
}
}
#line 186 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static WebPEncodingError CoOccurrenceBuild(WebPPicture *pic , uint32_t *palette ,
                                           uint32_t num_colors , uint32_t *cooccurrence ) 
{ 
  uint32_t *lines ;
  uint32_t *line_top ;
  uint32_t *line_current ;
  uint32_t *line_tmp ;
  int x ;
  int y ;
  uint32_t *src ;
  uint32_t prev_pix ;
  uint32_t prev_idx ;
  uint32_t idx_map[256] ;
  unsigned int tmp ;
  uint32_t palette_sorted[256] ;
  void *__cil_tmp17 ;
  uint32_t pix ;
  uint32_t left_idx ;
  uint32_t top_idx ;
  int tmp___0 ;

  {
#line 192
  src = pic->argb;
#line 193
  prev_pix = ~ *(src + 0);
#line 194
  prev_idx = 0U;
#line 195
  idx_map[0] = (uint32_t )0;
#line 195
  tmp = 1U;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;

#line 195
    if (tmp >= 256U) {
#line 195
      goto while_break;
    }
#line 195
    idx_map[tmp] = (uint32_t )0;
#line 195
    tmp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 197
  __cil_tmp17 = WebPSafeMalloc((uint64_t )(2 * pic->width), sizeof(*lines));
#line 197
  lines = (uint32_t *)__cil_tmp17;
  }
#line 198
  if ((unsigned long )lines == (unsigned long )((void *)0)) {
#line 198
    return ((WebPEncodingError )1);
  }
  {
#line 199
  line_top = lines + 0;
#line 200
  line_current = lines + pic->width;
#line 201
  PrepareMapToPalette(palette, num_colors, palette_sorted, idx_map);
#line 202
  y = 0;
  }
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 202
    if (! (y < pic->height)) {
#line 202
      goto while_break___0;
    }
#line 203
    x = 0;
    {
#line 203
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 203
      if (! (x < pic->width)) {
#line 203
        goto while_break___1;
      }
#line 204
      pix = *(src + x);
#line 205
      if (pix != prev_pix) {
        {
#line 206
        tmp___0 = SearchColorNoIdx(palette_sorted, pix, (int )num_colors);
#line 206
        prev_idx = (uint32_t )tmp___0;
#line 207
        prev_pix = pix;
        }
      }
#line 209
      *(line_current + x) = prev_idx;
#line 212
      if (x > 0) {
#line 212
        if (prev_idx != *(line_current + (x - 1))) {
#line 213
          left_idx = *(line_current + (x - 1));
#line 214
          (*(cooccurrence + (prev_idx * num_colors + left_idx))) ++;
#line 215
          (*(cooccurrence + (left_idx * num_colors + prev_idx))) ++;
        }
      }
#line 217
      if (y > 0) {
#line 217
        if (prev_idx != *(line_top + x)) {
#line 218
          top_idx = *(line_top + x);
#line 219
          (*(cooccurrence + (prev_idx * num_colors + top_idx))) ++;
#line 220
          (*(cooccurrence + (top_idx * num_colors + prev_idx))) ++;
        }
      }
#line 203
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 223
    line_tmp = line_top;
#line 224
    line_top = line_current;
#line 225
    line_current = line_tmp;
#line 226
    src += pic->argb_stride;
#line 202
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 228
  WebPSafeFree((void *)lines);
  }
#line 229
  return ((WebPEncodingError )0);
}
}
#line 240 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static WebPEncodingError PaletteSortModifiedZeng(WebPPicture *pic , uint32_t *palette_sorted ,
                                                 uint32_t num_colors , uint32_t *palette ) 
{ 
  uint32_t i ;
  uint32_t j ;
  uint32_t ind ;
  uint8_t remapping[256] ;
  uint32_t *cooccurrence ;
  struct Sum sums[256] ;
  uint32_t first ;
  uint32_t last ;
  uint32_t num_sums ;
  void *__cil_tmp14 ;
  WebPEncodingError __cil_tmp15 ;
  struct Sum *best_sum ;
  uint8_t best_index ;
  int32_t delta ;
  int32_t n ;
  uint16_t l_j ;
  uint32_t tmp ;

  {
#line 250
  if (num_colors <= 1U) {
#line 250
    return ((WebPEncodingError )0);
  }
  {
#line 252
  __cil_tmp14 = WebPSafeCalloc((uint64_t )(num_colors * num_colors), sizeof(*cooccurrence));
#line 252
  cooccurrence = (uint32_t *)__cil_tmp14;
  }
#line 254
  if ((unsigned long )cooccurrence == (unsigned long )((void *)0)) {
#line 254
    return ((WebPEncodingError )1);
  }
  {
#line 255
  __cil_tmp15 = CoOccurrenceBuild(pic, palette_sorted, num_colors, cooccurrence);
  }
#line 255
  if ((unsigned int )__cil_tmp15 != 0U) {
    {
#line 257
    WebPSafeFree((void *)cooccurrence);
    }
#line 258
    return ((WebPEncodingError )1);
  }
  {
#line 262
  CoOccurrenceFindMax(cooccurrence, num_colors, & remapping[0], & remapping[1]);
#line 267
  first = (uint32_t )0;
#line 268
  last = (uint32_t )1;
#line 269
  num_sums = num_colors - 2U;
  }
#line 270
  if (num_sums > 0U) {
#line 272
    best_sum = & sums[0];
#line 273
    best_sum->index = (uint8_t )0U;
#line 274
    best_sum->sum = 0U;
#line 275
    j = (uint32_t )0;
#line 275
    i = (uint32_t )0;
    {
#line 275
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: ;
#line 275
      if (! (i < num_colors)) {
#line 275
        goto while_break;
      }
#line 276
      if (i == (unsigned int )remapping[0]) {
#line 276
        goto while_continue;
      } else
#line 276
      if (i == (unsigned int )remapping[1]) {
#line 276
        goto while_continue;
      }
#line 277
      sums[j].index = (uint8_t )i;
#line 278
      sums[j].sum = *(cooccurrence + (i * num_colors + (unsigned int )remapping[0])) + *(cooccurrence + (i * num_colors + (unsigned int )remapping[1]));
#line 280
      if (sums[j].sum > best_sum->sum) {
#line 280
        best_sum = & sums[j];
      }
#line 281
      j ++;
#line 275
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: ;
    {
#line 284
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 284
      if (! (num_sums > 0U)) {
#line 284
        goto while_break___0;
      }
#line 285
      best_index = best_sum->index;
#line 287
      delta = 0;
#line 288
      n = (int32_t )(num_colors - num_sums);
#line 289
      j = (uint32_t )0;
#line 289
      ind = first;
      {
#line 289
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 289
        if (! ((ind + j) % num_colors != last + 1U)) {
#line 289
          goto while_break___1;
        }
#line 290
        l_j = (uint16_t )remapping[(ind + j) % num_colors];
#line 291
        delta += ((n - 1) - 2 * (int32_t )j) * (int32_t )*(cooccurrence + ((unsigned int )best_index * num_colors + (unsigned int )l_j));
#line 289
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: ;
#line 294
      if (delta > 0) {
#line 295
        if (first == 0U) {
#line 295
          tmp = num_colors - 1U;
        } else {
#line 295
          tmp = first - 1U;
        }
#line 295
        first = tmp;
#line 296
        remapping[first] = best_index;
      } else {
#line 298
        last ++;
#line 299
        remapping[last] = best_index;
      }
#line 302
      *best_sum = sums[num_sums - 1U];
#line 303
      num_sums --;
#line 305
      best_sum = & sums[0];
#line 306
      i = (uint32_t )0;
      {
#line 306
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 306
        if (! (i < num_sums)) {
#line 306
          goto while_break___2;
        }
#line 307
        sums[i].sum += *(cooccurrence + ((unsigned int )best_index * num_colors + (unsigned int )sums[i].index));
#line 308
        if (sums[i].sum > best_sum->sum) {
#line 308
          best_sum = & sums[i];
        }
#line 306
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: ;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  {
#line 313
  WebPSafeFree((void *)cooccurrence);
#line 316
  i = (uint32_t )0;
  }
  {
#line 316
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 316
    if (! (i < num_colors)) {
#line 316
      goto while_break___3;
    }
#line 317
    *(palette + i) = *(palette_sorted + (int )remapping[(first + i) % num_colors]);
#line 316
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: ;
#line 319
  return ((WebPEncodingError )0);
}
}
#line 360 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static void AddSingleSubGreen(int p , uint32_t *r , uint32_t *b ) 
{ 
  int green ;

  {
#line 361
  green = p >> 8;
#line 362
  (*(r + (((p >> 16) - green) & 255))) ++;
#line 363
  (*(b + ((p - green) & 255))) ++;
#line 364
  return;
}
}
#line 366 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static void AddSingle(uint32_t p , uint32_t *a , uint32_t *r , uint32_t *g , uint32_t *b ) 
{ 


  {
#line 369
  (*(a + ((p >> 24) & 255U))) ++;
#line 370
  (*(r + ((p >> 16) & 255U))) ++;
#line 371
  (*(g + ((p >> 8) & 255U))) ++;
#line 372
  (*(b + (p & 255U))) ++;
#line 373
  return;
}
}
#line 375 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
__inline static uint32_t HashPix(uint32_t pix ) 
{ 


  {
#line 378
  return ((uint32_t )(((unsigned long long )((uint64_t )pix + (unsigned long )(pix >> 19)) * 969276327ULL & 4294967295ULL) >> 24));
}
}
#line 411 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static uint8_t kHistoPairs[5][2]  ;
#line 381 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static int AnalyzeEntropy(uint32_t *argb , int width , int height , int argb_stride ,
                          int use_palette , int palette_size , int transform_bits ,
                          EntropyIx *min_entropy_ix , int *red_and_blue_always_zero ) 
{ 
  uint32_t *histo ;
  void *__cil_tmp11 ;
  int i ;
  int x ;
  int y ;
  uint32_t *prev_row ;
  uint32_t *curr_row ;
  uint32_t pix_prev ;
  uint32_t pix ;
  uint32_t pix_diff ;
  uint32_t __cil_tmp20 ;
  uint32_t hash ;
  uint32_t __cil_tmp22 ;
  double entropy_comp[13] ;
  double entropy[6] ;
  int k ;
  int last_mode_to_analyze ;
  int tmp ;
  int j ;
  uint32_t __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  float __cil_tmp32 ;
  uint32_t __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  float __cil_tmp35 ;
  uint32_t *red_histo ;
  uint32_t *blue_histo ;

  {
#line 390
  if (use_palette) {
#line 390
    if (palette_size <= 16) {
#line 393
      *min_entropy_ix = (EntropyIx )4;
#line 394
      *red_and_blue_always_zero = 1;
#line 395
      return (1);
    }
  }
  {
#line 397
  __cil_tmp11 = WebPSafeCalloc((uint64_t )13, sizeof(*histo) * 256UL);
#line 397
  histo = (uint32_t *)__cil_tmp11;
  }
#line 398
  if ((unsigned long )histo != (unsigned long )((void *)0)) {
#line 400
    prev_row = (uint32_t *)((void *)0);
#line 401
    curr_row = argb;
#line 402
    pix_prev = *(argb + 0);
#line 403
    y = 0;
    {
#line 403
    while (1) {
      while_continue: /* CIL Label */ ;

#line 403
      if (! (y < height)) {
#line 403
        goto while_break;
      }
#line 404
      x = 0;
      {
#line 404
      while (1) {
        while_continue___1: /* CIL Label */ ;
        while_continue___0: ;
#line 404
        if (! (x < width)) {
#line 404
          goto while_break___0;
        }
        {
#line 405
        pix = *(curr_row + x);
#line 406
        __cil_tmp20 = VP8LSubPixels(pix, pix_prev);
#line 406
        pix_diff = __cil_tmp20;
#line 407
        pix_prev = pix;
        }
#line 408
        if ((unsigned long )prev_row != (unsigned long )((void *)0)) {
#line 408
          if (pix == *(prev_row + x)) {
#line 409
            goto while_continue___0;
          } else {
#line 408
            goto _L;
          }
        } else
        _L: 
#line 408
        if (pix_diff == 0U) {
#line 409
          goto while_continue___0;
        }
        {
#line 411
        AddSingle(pix, histo + 0, histo + 1024, histo + 512, histo + 1536);
#line 416
        AddSingle(pix_diff, histo + 256, histo + 1280, histo + 768, histo + 1792);
#line 421
        AddSingleSubGreen((int )pix, histo + 2048, histo + 2560);
#line 424
        AddSingleSubGreen((int )pix_diff, histo + 2304, histo + 2816);
#line 429
        __cil_tmp22 = HashPix(pix);
#line 429
        hash = __cil_tmp22;
#line 430
        (*(histo + (3072U + hash))) ++;
#line 404
        x ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: 
#line 433
      prev_row = curr_row;
#line 434
      curr_row += argb_stride;
#line 403
      y ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: ;
#line 440
    if (use_palette) {
#line 440
      tmp = 4;
    } else {
#line 440
      tmp = 3;
    }
#line 440
    last_mode_to_analyze = tmp;
#line 445
    (*(histo + 2304)) ++;
#line 446
    (*(histo + 2816)) ++;
#line 447
    (*(histo + 1280)) ++;
#line 448
    (*(histo + 768)) ++;
#line 449
    (*(histo + 1792)) ++;
#line 450
    (*(histo + 256)) ++;
#line 452
    j = 0;
    {
#line 452
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 452
      if (! (j < 13)) {
#line 452
        goto while_break___1;
      }
      {
#line 453
      entropy_comp[j] = VP8LBitsEntropy(histo + j * 256, 256);
#line 452
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 455
    entropy[0] = ((entropy_comp[0] + entropy_comp[4]) + entropy_comp[2]) + entropy_comp[6];
#line 459
    entropy[1] = ((entropy_comp[1] + entropy_comp[5]) + entropy_comp[3]) + entropy_comp[7];
#line 463
    entropy[2] = ((entropy_comp[0] + entropy_comp[8]) + entropy_comp[2]) + entropy_comp[10];
#line 467
    entropy[3] = ((entropy_comp[1] + entropy_comp[9]) + entropy_comp[3]) + entropy_comp[11];
#line 471
    entropy[4] = entropy_comp[12];
#line 476
    __cil_tmp32 = VP8LFastLog2((uint32_t )14);
#line 476
    __cil_tmp31 = VP8LSubSampleSize((uint32_t )height, (uint32_t )transform_bits);
#line 476
    __cil_tmp30 = VP8LSubSampleSize((uint32_t )width, (uint32_t )transform_bits);
#line 476
    entropy[1] += (double )((float )(__cil_tmp30 * __cil_tmp31) * __cil_tmp32);
#line 481
    __cil_tmp35 = VP8LFastLog2((uint32_t )24);
#line 481
    __cil_tmp34 = VP8LSubSampleSize((uint32_t )height, (uint32_t )transform_bits);
#line 481
    __cil_tmp33 = VP8LSubSampleSize((uint32_t )width, (uint32_t )transform_bits);
#line 481
    entropy[3] += (double )((float )(__cil_tmp33 * __cil_tmp34) * __cil_tmp35);
#line 488
    entropy[4] += (double )(palette_size * 8);
#line 490
    *min_entropy_ix = (EntropyIx )0;
#line 491
    k = 1;
    }
    {
#line 491
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 491
      if (! (k <= last_mode_to_analyze)) {
#line 491
        goto while_break___2;
      }
#line 492
      if (entropy[*min_entropy_ix] > entropy[k]) {
#line 493
        *min_entropy_ix = (EntropyIx )k;
      }
#line 491
      k ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 497
    *red_and_blue_always_zero = 1;
#line 502
    kHistoPairs[0][0] = (uint8_t )4;
#line 502
    kHistoPairs[0][1] = (uint8_t )6;
#line 502
    kHistoPairs[1][0] = (uint8_t )5;
#line 502
    kHistoPairs[1][1] = (uint8_t )7;
#line 502
    kHistoPairs[2][0] = (uint8_t )8;
#line 502
    kHistoPairs[2][1] = (uint8_t )10;
#line 502
    kHistoPairs[3][0] = (uint8_t )9;
#line 502
    kHistoPairs[3][1] = (uint8_t )11;
#line 502
    kHistoPairs[4][0] = (uint8_t )4;
#line 502
    kHistoPairs[4][1] = (uint8_t )6;
#line 509
    red_histo = histo + 256 * (int )kHistoPairs[*min_entropy_ix][0];
#line 511
    blue_histo = histo + 256 * (int )kHistoPairs[*min_entropy_ix][1];
#line 513
    i = 1;
    {
#line 513
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 513
      if (! (i < 256)) {
#line 513
        goto while_break___3;
      }
#line 514
      if ((*(red_histo + i) | *(blue_histo + i)) != 0U) {
#line 515
        *red_and_blue_always_zero = 0;
#line 516
        goto while_break___3;
      }
#line 513
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: 
    {
#line 521
    WebPSafeFree((void *)histo);
    }
#line 522
    return (1);
  } else {
#line 524
    return (0);
  }
}
}
#line 528 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static int GetHistoBits(int method , int use_palette , int width , int height ) 
{ 
  int histo_bits ;
  int tmp ;
  int huff_image_size ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 530
  if (use_palette) {
#line 530
    tmp = 9;
  } else {
#line 530
    tmp = 7;
  }
#line 530
  histo_bits = tmp - method;
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 532
    __cil_tmp9 = VP8LSubSampleSize((uint32_t )height, (uint32_t )histo_bits);
#line 532
    __cil_tmp8 = VP8LSubSampleSize((uint32_t )width, (uint32_t )histo_bits);
#line 532
    huff_image_size = (int )(__cil_tmp8 * __cil_tmp9);
    }
#line 534
    if (huff_image_size <= 2600) {
#line 534
      goto while_break;
    }
#line 535
    histo_bits ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 537
  if (histo_bits < 2) {
#line 537
    tmp___1 = 2;
  } else {
#line 537
    if (histo_bits > 9) {
#line 537
      tmp___0 = 9;
    } else {
#line 537
      tmp___0 = histo_bits;
    }
#line 537
    tmp___1 = tmp___0;
  }
#line 537
  return (tmp___1);
}
}
#line 541 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static int GetTransformBits(int method , int histo_bits ) 
{ 
  int max_transform_bits ;
  int tmp ;
  int tmp___0 ;
  int res ;
  int tmp___1 ;

  {
#line 542
  if (method < 4) {
#line 542
    tmp___0 = 6;
  } else {
#line 542
    if (method > 4) {
#line 542
      tmp = 4;
    } else {
#line 542
      tmp = 5;
    }
#line 542
    tmp___0 = tmp;
  }
#line 542
  max_transform_bits = tmp___0;
#line 543
  if (histo_bits > max_transform_bits) {
#line 543
    tmp___1 = max_transform_bits;
  } else {
#line 543
    tmp___1 = histo_bits;
  }
#line 543
  res = tmp___1;
#line 546
  return (res);
}
}
#line 566 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static int EncoderAnalyze(VP8LEncoder *enc , CrunchConfig *crunch_configs , int *crunch_configs_size ,
                          int *red_and_blue_always_zero ) 
{ 
  WebPPicture *pic ;
  int width ;
  int height ;
  WebPConfig *config ;
  int method ;
  int low_effort ;
  int i ;
  int use_palette ;
  int n_lz77s ;
  int do_no_cache ;
  int tmp ;
  int tmp___0 ;
  EntropyIx min_entropy_ix ;
  int tmp___1 ;
  int __cil_tmp22 ;
  int tmp___2 ;
  int j ;
  int tmp___3 ;

  {
  {
#line 570
  pic = enc->pic_;
#line 571
  width = pic->width;
#line 572
  height = pic->height;
#line 573
  config = enc->config_;
#line 574
  method = config->method;
#line 575
  low_effort = config->method == 0;
#line 581
  do_no_cache = 0;
#line 585
  enc->palette_size_ = WebPGetColorPalette(pic, enc->palette_sorted_);
#line 586
  use_palette = enc->palette_size_ <= 256;
  }
#line 587
  if (! use_palette) {
#line 588
    enc->palette_size_ = 0;
  } else {
    {
#line 590
    qsort((void *)(enc->palette_sorted_), (size_t )enc->palette_size_, sizeof(enc->palette_sorted_[0]),
          & PaletteCompareColorsForQsort);
    }
  }
  {
#line 595
  enc->histo_bits_ = GetHistoBits(method, use_palette, pic->width, pic->height);
#line 597
  enc->transform_bits_ = GetTransformBits(method, enc->histo_bits_);
  }
#line 599
  if (low_effort) {
#line 601
    if (use_palette) {
#line 601
      tmp = 4;
    } else {
#line 601
      tmp = 3;
    }
#line 601
    (crunch_configs + 0)->entropy_idx_ = tmp;
#line 602
    if (use_palette) {
#line 602
      tmp___0 = 0;
    } else {
#line 602
      tmp___0 = 3;
    }
#line 602
    (crunch_configs + 0)->palette_sorting_type_ = (PaletteSorting )tmp___0;
#line 604
    n_lz77s = 1;
#line 605
    *crunch_configs_size = 1;
  } else {
#line 609
    if (enc->palette_size_ > 0) {
#line 609
      if (enc->palette_size_ <= 16) {
#line 609
        tmp___1 = 2;
      } else {
#line 609
        tmp___1 = 1;
      }
    } else {
#line 609
      tmp___1 = 1;
    }
    {
#line 609
    n_lz77s = tmp___1;
#line 610
    __cil_tmp22 = AnalyzeEntropy(pic->argb, width, height, pic->argb_stride, use_palette,
                                 enc->palette_size_, enc->transform_bits_, & min_entropy_ix,
                                 red_and_blue_always_zero);
    }
#line 610
    if (! __cil_tmp22) {
#line 613
      return (0);
    }
#line 615
    if (method == 6) {
#line 615
      if (config->quality == (float )100) {
#line 616
        do_no_cache = 1;
#line 618
        *crunch_configs_size = 0;
#line 619
        i = 0;
        {
#line 619
        while (1) {
          while_continue: /* CIL Label */ ;

#line 619
          if (! (i < 6)) {
#line 619
            goto while_break;
          }
#line 622
          if (i != 4) {
#line 622
            if (i != 5) {
              _L: 
#line 624
              (crunch_configs + *crunch_configs_size)->entropy_idx_ = i;
#line 625
              if (use_palette) {
#line 625
                if (i == 4) {
#line 626
                  (crunch_configs + *crunch_configs_size)->palette_sorting_type_ = (PaletteSorting )1;
#line 628
                  (*crunch_configs_size) ++;
#line 630
                  (crunch_configs + *crunch_configs_size)->entropy_idx_ = i;
#line 631
                  (crunch_configs + *crunch_configs_size)->palette_sorting_type_ = (PaletteSorting )2;
                } else
#line 625
                if (i == 5) {
#line 626
                  (crunch_configs + *crunch_configs_size)->palette_sorting_type_ = (PaletteSorting )1;
#line 628
                  (*crunch_configs_size) ++;
#line 630
                  (crunch_configs + *crunch_configs_size)->entropy_idx_ = i;
#line 631
                  (crunch_configs + *crunch_configs_size)->palette_sorting_type_ = (PaletteSorting )2;
                } else {
#line 634
                  (crunch_configs + *crunch_configs_size)->palette_sorting_type_ = (PaletteSorting )3;
                }
              } else {
#line 634
                (crunch_configs + *crunch_configs_size)->palette_sorting_type_ = (PaletteSorting )3;
              }
#line 637
              (*crunch_configs_size) ++;
            } else {
#line 622
              goto _L___10;
            }
          } else
          _L___10: 
#line 622
          if (use_palette) {
#line 622
            goto _L;
          }
#line 619
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break: ;
      } else {
#line 615
        goto _L___11;
      }
    } else {
      _L___11: 
#line 642
      *crunch_configs_size = 1;
#line 643
      (crunch_configs + 0)->entropy_idx_ = (int )min_entropy_ix;
#line 644
      if (use_palette) {
#line 644
        tmp___2 = 1;
      } else {
#line 644
        tmp___2 = 3;
      }
#line 644
      (crunch_configs + 0)->palette_sorting_type_ = (PaletteSorting )tmp___2;
#line 646
      if (config->quality >= (float )75) {
#line 646
        if (method == 5) {
#line 648
          do_no_cache = 1;
#line 650
          if ((unsigned int )min_entropy_ix == 4U) {
#line 651
            *crunch_configs_size = 2;
#line 652
            (crunch_configs + 1)->entropy_idx_ = 5;
#line 653
            (crunch_configs + 1)->palette_sorting_type_ = (PaletteSorting )1;
          }
        }
      }
    }
  }
#line 660
  i = 0;
  {
#line 660
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 660
    if (! (i < *crunch_configs_size)) {
#line 660
      goto while_break___0;
    }
#line 662
    j = 0;
    {
#line 662
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 662
      if (! (j < n_lz77s)) {
#line 662
        goto while_break___1;
      }
#line 664
      if (j == 0) {
#line 664
        tmp___3 = 3;
      } else {
#line 664
        tmp___3 = 4;
      }
#line 664
      (crunch_configs + i)->sub_configs_[j].lz77_ = tmp___3;
#line 666
      (crunch_configs + i)->sub_configs_[j].do_no_cache_ = do_no_cache;
#line 662
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 668
    (crunch_configs + i)->sub_configs_size_ = n_lz77s;
#line 660
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 670
  return (1);
}
}
#line 673 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static int EncoderInit(VP8LEncoder *enc ) 
{ 
  WebPPicture *pic ;
  int width ;
  int height ;
  int pix_cnt ;
  int refs_block_size ;
  int i ;
  int __cil_tmp8 ;

  {
  {
#line 674
  pic = enc->pic_;
#line 675
  width = pic->width;
#line 676
  height = pic->height;
#line 677
  pix_cnt = width * height;
#line 680
  refs_block_size = (pix_cnt - 1) / 16 + 1;
#line 682
  __cil_tmp8 = VP8LHashChainInit(& enc->hash_chain_, pix_cnt);
  }
#line 682
  if (! __cil_tmp8) {
#line 682
    return (0);
  }
#line 684
  i = 0;
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;

#line 684
    if (! (i < 4)) {
#line 684
      goto while_break;
    }
    {
#line 684
    VP8LBackwardRefsInit(& enc->refs_[i], refs_block_size);
#line 684
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 686
  return (1);
}
}
#line 690 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static int GetHuffBitLengthsAndCodes(VP8LHistogramSet *histogram_image , HuffmanTreeCode *huffman_codes ) 
{ 
  int i ;
  int k ;
  int ok ;
  uint64_t total_length_size ;
  uint8_t *mem_buf ;
  int histogram_image_size ;
  int max_num_symbols ;
  uint8_t *buf_rle ;
  HuffmanTree *huff_tree ;
  VP8LHistogram *histo ;
  HuffmanTreeCode *codes ;
  int num_symbols ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;
  uint16_t *codes___0 ;
  uint8_t *lengths ;
  void *__cil_tmp20 ;
  int bit_length ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  HuffmanTreeCode *codes___1 ;
  VP8LHistogram *histo___0 ;

  {
#line 694
  ok = 0;
#line 695
  total_length_size = (uint64_t )0;
#line 696
  mem_buf = (uint8_t *)((void *)0);
#line 697
  histogram_image_size = histogram_image->size;
#line 698
  max_num_symbols = 0;
#line 699
  buf_rle = (uint8_t *)((void *)0);
#line 700
  huff_tree = (HuffmanTree *)((void *)0);
#line 703
  i = 0;
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;

#line 703
    if (! (i < histogram_image_size)) {
#line 703
      goto while_break;
    }
#line 704
    histo = *(histogram_image->histograms + i);
#line 705
    codes = huffman_codes + 5 * i;
#line 707
    k = 0;
    {
#line 707
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 707
      if (! (k < 5)) {
#line 707
        goto while_break___0;
      }
#line 708
      if (k == 0) {
        {
#line 708
        __cil_tmp15 = VP8LHistogramNumCodes(histo->palette_code_bits_);
#line 708
        tmp___0 = __cil_tmp15;
        }
      } else {
#line 708
        if (k == 4) {
#line 708
          tmp = 40;
        } else {
#line 708
          tmp = 256;
        }
#line 708
        tmp___0 = tmp;
      }
#line 708
      num_symbols = tmp___0;
#line 711
      (codes + k)->num_symbols = num_symbols;
#line 712
      total_length_size += (unsigned long )num_symbols;
#line 707
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 703
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 720
  __cil_tmp20 = WebPSafeCalloc(total_length_size, sizeof(*lengths) + sizeof(*codes___0));
#line 720
  mem_buf = (uint8_t *)__cil_tmp20;
  }
#line 722
  if ((unsigned long )mem_buf == (unsigned long )((void *)0)) {
#line 722
    goto End;
  }
#line 724
  codes___0 = (uint16_t *)mem_buf;
#line 725
  lengths = (uint8_t *)(codes___0 + total_length_size);
#line 726
  i = 0;
  {
#line 726
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 726
    if (! (i < 5 * histogram_image_size)) {
#line 726
      goto while_break___1;
    }
#line 727
    bit_length = (huffman_codes + i)->num_symbols;
#line 728
    (huffman_codes + i)->codes = codes___0;
#line 729
    (huffman_codes + i)->code_lengths = lengths;
#line 730
    codes___0 += bit_length;
#line 731
    lengths += bit_length;
#line 732
    if (max_num_symbols < bit_length) {
#line 733
      max_num_symbols = bit_length;
    }
#line 726
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 738
  __cil_tmp22 = WebPSafeMalloc((uint64_t )1ULL, (size_t )max_num_symbols);
#line 738
  buf_rle = (uint8_t *)__cil_tmp22;
#line 739
  __cil_tmp23 = WebPSafeMalloc((uint64_t )(3ULL * (unsigned long long )max_num_symbols),
                               sizeof(*huff_tree));
#line 739
  huff_tree = (HuffmanTree *)__cil_tmp23;
  }
#line 741
  if ((unsigned long )buf_rle == (unsigned long )((void *)0)) {
#line 741
    goto End;
  } else
#line 741
  if ((unsigned long )huff_tree == (unsigned long )((void *)0)) {
#line 741
    goto End;
  }
#line 744
  i = 0;
  {
#line 744
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 744
    if (! (i < histogram_image_size)) {
#line 744
      goto while_break___2;
    }
    {
#line 745
    codes___1 = huffman_codes + 5 * i;
#line 746
    histo___0 = *(histogram_image->histograms + i);
#line 747
    VP8LCreateHuffmanTree(histo___0->literal_, 15, buf_rle, huff_tree, codes___1 + 0);
#line 748
    VP8LCreateHuffmanTree(histo___0->red_, 15, buf_rle, huff_tree, codes___1 + 1);
#line 749
    VP8LCreateHuffmanTree(histo___0->blue_, 15, buf_rle, huff_tree, codes___1 + 2);
#line 750
    VP8LCreateHuffmanTree(histo___0->alpha_, 15, buf_rle, huff_tree, codes___1 + 3);
#line 751
    VP8LCreateHuffmanTree(histo___0->distance_, 15, buf_rle, huff_tree, codes___1 + 4);
#line 744
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: 
#line 753
  ok = 1;
  End: 
  {
#line 755
  WebPSafeFree((void *)huff_tree);
#line 756
  WebPSafeFree((void *)buf_rle);
  }
#line 757
  if (! ok) {
    {
#line 758
    WebPSafeFree((void *)mem_buf);
#line 759
    memset((void *)huffman_codes, 0, (unsigned long )(5 * histogram_image_size) * sizeof(*huffman_codes));
    }
  }
#line 761
  return (ok);
}
}
#line 766 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static uint8_t kStorageOrder[19]  ;
#line 764 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static void StoreHuffmanTreeOfHuffmanTreeToBitMask(VP8LBitWriter *bw , uint8_t *code_length_bitdepth ) 
{ 
  int i ;
  int codes_to_store ;

  {
#line 769
  kStorageOrder[0] = (uint8_t )17;
#line 769
  kStorageOrder[1] = (uint8_t )18;
#line 769
  kStorageOrder[2] = (uint8_t )0;
#line 769
  kStorageOrder[3] = (uint8_t )1;
#line 769
  kStorageOrder[4] = (uint8_t )2;
#line 769
  kStorageOrder[5] = (uint8_t )3;
#line 769
  kStorageOrder[6] = (uint8_t )4;
#line 769
  kStorageOrder[7] = (uint8_t )5;
#line 769
  kStorageOrder[8] = (uint8_t )16;
#line 769
  kStorageOrder[9] = (uint8_t )6;
#line 769
  kStorageOrder[10] = (uint8_t )7;
#line 769
  kStorageOrder[11] = (uint8_t )8;
#line 769
  kStorageOrder[12] = (uint8_t )9;
#line 769
  kStorageOrder[13] = (uint8_t )10;
#line 769
  kStorageOrder[14] = (uint8_t )11;
#line 769
  kStorageOrder[15] = (uint8_t )12;
#line 769
  kStorageOrder[16] = (uint8_t )13;
#line 769
  kStorageOrder[17] = (uint8_t )14;
#line 769
  kStorageOrder[18] = (uint8_t )15;
#line 774
  codes_to_store = 19;
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;

#line 775
    if (! (codes_to_store > 4)) {
#line 775
      goto while_break;
    }
#line 776
    if ((int )*(code_length_bitdepth + (int )kStorageOrder[codes_to_store - 1]) != 0) {
#line 777
      goto while_break;
    }
#line 775
    codes_to_store --;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 780
  VP8LPutBits(bw, (uint32_t )(codes_to_store - 4), 4);
#line 781
  i = 0;
  }
  {
#line 781
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 781
    if (! (i < codes_to_store)) {
#line 781
      goto while_break___0;
    }
    {
#line 782
    VP8LPutBits(bw, (uint32_t )*(code_length_bitdepth + (int )kStorageOrder[i]), 3);
#line 781
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 785
  return;
}
}
#line 786 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static void ClearHuffmanTreeIfOnlyOneSymbol(HuffmanTreeCode *huffman_code ) 
{ 
  int k ;
  int count ;

  {
#line 789
  count = 0;
#line 790
  k = 0;
  {
#line 790
  while (1) {
    while_continue: /* CIL Label */ ;

#line 790
    if (! (k < huffman_code->num_symbols)) {
#line 790
      goto while_break;
    }
#line 791
    if ((int )*(huffman_code->code_lengths + k) != 0) {
#line 792
      count ++;
#line 793
      if (count > 1) {
#line 793
        return;
      }
    }
#line 790
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 796
  k = 0;
  {
#line 796
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 796
    if (! (k < huffman_code->num_symbols)) {
#line 796
      goto while_break___0;
    }
#line 797
    *(huffman_code->code_lengths + k) = (uint8_t )0;
#line 798
    *(huffman_code->codes + k) = (uint16_t )0;
#line 796
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 800
  return;
}
}
#line 802 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static void StoreHuffmanTreeToBitMask(VP8LBitWriter *bw , HuffmanTreeToken *tokens ,
                                      int num_tokens , HuffmanTreeCode *huffman_code ) 
{ 
  int i ;
  int ix ;
  int extra_bits ;

  {
#line 807
  i = 0;
  {
#line 807
  while (1) {
    while_continue: /* CIL Label */ ;

#line 807
    if (! (i < num_tokens)) {
#line 807
      goto while_break;
    }
    {
#line 808
    ix = (int )(tokens + i)->code;
#line 809
    extra_bits = (int )(tokens + i)->extra_bits;
#line 810
    VP8LPutBits(bw, (uint32_t )*(huffman_code->codes + ix), (int )*(huffman_code->code_lengths + ix));
    }
#line 812
    if (ix == 16) {
#line 812
      goto case_16;
    }
#line 815
    if (ix == 17) {
#line 815
      goto case_17;
    }
#line 818
    if (ix == 18) {
#line 818
      goto case_18;
    }
#line 811
    goto switch_break;
    case_16: 
    {
#line 813
    VP8LPutBits(bw, (uint32_t )extra_bits, 2);
    }
#line 814
    goto switch_break;
    case_17: 
    {
#line 816
    VP8LPutBits(bw, (uint32_t )extra_bits, 3);
    }
#line 817
    goto switch_break;
    case_18: 
    {
#line 819
    VP8LPutBits(bw, (uint32_t )extra_bits, 7);
    }
#line 820
    goto switch_break;
    switch_break: 
#line 807
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 811
  return;
}
}
#line 826 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static void StoreFullHuffmanCode(VP8LBitWriter *bw , HuffmanTree *huff_tree , HuffmanTreeToken *tokens ,
                                 HuffmanTreeCode *tree ) 
{ 
  uint8_t code_length_bitdepth[19] ;
  unsigned int tmp ;
  uint16_t code_length_bitdepth_symbols[19] ;
  unsigned int tmp___0 ;
  int max_tokens ;
  int num_tokens ;
  HuffmanTreeCode huffman_code ;
  uint32_t histogram[19] ;
  unsigned int tmp___1 ;
  uint8_t buf_rle[19] ;
  unsigned int tmp___2 ;
  int i ;
  int trailing_zero_bits ;
  int trimmed_length ;
  int write_trimmed_length ;
  int length ;
  int i___0 ;
  int __cil_tmp23 ;
  int ix ;
  int tmp___3 ;
  int nbits ;
  int __cil_tmp27 ;
  int nbitpairs ;
  int tmp___4 ;

  {
#line 830
  code_length_bitdepth[0] = (uint8_t )0;
#line 830
  tmp = 1U;
  {
#line 830
  while (1) {
    while_continue: /* CIL Label */ ;

#line 830
    if (tmp >= 19U) {
#line 830
      goto while_break;
    }
#line 830
    code_length_bitdepth[tmp] = (uint8_t )0;
#line 830
    tmp ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
#line 831
  code_length_bitdepth_symbols[0] = (uint16_t )0;
#line 831
  tmp___0 = 1U;
  {
#line 831
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 831
    if (tmp___0 >= 19U) {
#line 831
      goto while_break___0;
    }
#line 831
    code_length_bitdepth_symbols[tmp___0] = (uint16_t )0;
#line 831
    tmp___0 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 832
  max_tokens = tree->num_symbols;
#line 835
  huffman_code.num_symbols = 19;
#line 836
  huffman_code.code_lengths = code_length_bitdepth;
#line 837
  huffman_code.codes = code_length_bitdepth_symbols;
#line 839
  VP8LPutBits(bw, (uint32_t )0, 1);
#line 840
  num_tokens = VP8LCreateCompressedHuffmanTree(tree, tokens, max_tokens);
#line 842
  histogram[0] = (uint32_t )0;
#line 842
  tmp___1 = 1U;
  }
  {
#line 842
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 842
    if (tmp___1 >= 19U) {
#line 842
      goto while_break___1;
    }
#line 842
    histogram[tmp___1] = (uint32_t )0;
#line 842
    tmp___1 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: 
#line 843
  buf_rle[0] = (uint8_t )0;
#line 843
  tmp___2 = 1U;
  {
#line 843
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 843
    if (tmp___2 >= 19U) {
#line 843
      goto while_break___2;
    }
#line 843
    buf_rle[tmp___2] = (uint8_t )0;
#line 843
    tmp___2 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: 
#line 845
  i = 0;
  {
#line 845
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 845
    if (! (i < num_tokens)) {
#line 845
      goto while_break___3;
    }
#line 846
    (histogram[(tokens + i)->code]) ++;
#line 845
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___3: 
  {
#line 849
  VP8LCreateHuffmanTree(histogram, 7, buf_rle, huff_tree, & huffman_code);
#line 852
  StoreHuffmanTreeOfHuffmanTreeToBitMask(bw, code_length_bitdepth);
#line 853
  ClearHuffmanTreeIfOnlyOneSymbol(& huffman_code);
#line 855
  trailing_zero_bits = 0;
#line 856
  trimmed_length = num_tokens;
#line 859
  i___0 = num_tokens;
  }
  {
#line 860
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 860
    __cil_tmp23 = i___0;
#line 860
    i___0 --;
#line 860
    if (! (__cil_tmp23 > 0)) {
#line 860
      goto while_break___4;
    }
#line 861
    ix = (int )(tokens + i___0)->code;
#line 862
    if (ix == 0) {
      _L: 
#line 863
      trimmed_length --;
#line 864
      trailing_zero_bits += (int )code_length_bitdepth[ix];
#line 865
      if (ix == 17) {
#line 866
        trailing_zero_bits += 3;
      } else
#line 867
      if (ix == 18) {
#line 868
        trailing_zero_bits += 7;
      }
    } else
#line 862
    if (ix == 17) {
#line 862
      goto _L;
    } else
#line 862
    if (ix == 18) {
#line 862
      goto _L;
    } else {
#line 871
      goto while_break___4;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___4: ;
#line 874
  if (trimmed_length > 1) {
#line 874
    if (trailing_zero_bits > 12) {
#line 874
      tmp___4 = 1;
    } else {
#line 874
      tmp___4 = 0;
    }
  } else {
#line 874
    tmp___4 = 0;
  }
#line 874
  write_trimmed_length = tmp___4;
#line 875
  if (write_trimmed_length) {
#line 875
    tmp___3 = trimmed_length;
  } else {
#line 875
    tmp___3 = num_tokens;
  }
  {
#line 875
  length = tmp___3;
#line 876
  VP8LPutBits(bw, (uint32_t )write_trimmed_length, 1);
  }
#line 877
  if (write_trimmed_length) {
#line 878
    if (trimmed_length == 2) {
      {
#line 879
      VP8LPutBits(bw, (uint32_t )0, 5);
      }
    } else {
      {
#line 881
      __cil_tmp27 = BitsLog2Floor((uint32_t )(trimmed_length - 2));
#line 881
      nbits = __cil_tmp27;
#line 882
      nbitpairs = nbits / 2 + 1;
#line 885
      VP8LPutBits(bw, (uint32_t )(nbitpairs - 1), 3);
#line 886
      VP8LPutBits(bw, (uint32_t )(trimmed_length - 2), nbitpairs * 2);
      }
    }
  }
  {
#line 889
  StoreHuffmanTreeToBitMask(bw, tokens, length, & huffman_code);
  }
#line 891
  return;
}
}
#line 894 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static void StoreHuffmanCode(VP8LBitWriter *bw , HuffmanTree *huff_tree , HuffmanTreeToken *tokens ,
                             HuffmanTreeCode *huffman_code ) 
{ 
  int i ;
  int count ;
  int symbols[2] ;
  int kMaxBits ;
  int kMaxSymbol ;

  {
#line 899
  count = 0;
#line 900
  symbols[0] = 0;
#line 900
  symbols[1] = 0;
#line 901
  kMaxBits = 8;
#line 902
  kMaxSymbol = 1 << kMaxBits;
#line 905
  i = 0;
  {
#line 905
  while (1) {
    while_continue: /* CIL Label */ ;

#line 905
    if (i < huffman_code->num_symbols) {
#line 905
      if (! (count < 3)) {
#line 905
        goto while_break;
      }
    } else {
#line 905
      goto while_break;
    }
#line 906
    if ((int )*(huffman_code->code_lengths + i) != 0) {
#line 907
      if (count < 2) {
#line 907
        symbols[count] = i;
      }
#line 908
      count ++;
    }
#line 905
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 912
  if (count == 0) {
    {
#line 914
    VP8LPutBits(bw, (uint32_t )1, 4);
    }
  } else
#line 915
  if (count <= 2) {
#line 915
    if (symbols[0] < kMaxSymbol) {
#line 915
      if (symbols[1] < kMaxSymbol) {
        {
#line 916
        VP8LPutBits(bw, (uint32_t )1, 1);
#line 917
        VP8LPutBits(bw, (uint32_t )(count - 1), 1);
        }
#line 918
        if (symbols[0] <= 1) {
          {
#line 919
          VP8LPutBits(bw, (uint32_t )0, 1);
#line 920
          VP8LPutBits(bw, (uint32_t )symbols[0], 1);
          }
        } else {
          {
#line 922
          VP8LPutBits(bw, (uint32_t )1, 1);
#line 923
          VP8LPutBits(bw, (uint32_t )symbols[0], 8);
          }
        }
#line 925
        if (count == 2) {
          {
#line 926
          VP8LPutBits(bw, (uint32_t )symbols[1], 8);
          }
        }
      } else {
        {
#line 929
        StoreFullHuffmanCode(bw, huff_tree, tokens, huffman_code);
        }
      }
    } else {
      {
#line 929
      StoreFullHuffmanCode(bw, huff_tree, tokens, huffman_code);
      }
    }
  } else {
    {
#line 929
    StoreFullHuffmanCode(bw, huff_tree, tokens, huffman_code);
    }
  }
#line 934
  return;
}
}
#line 933 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
__inline static void WriteHuffmanCode(VP8LBitWriter *bw , HuffmanTreeCode *code ,
                                      int code_index ) 
{ 
  int depth ;
  int symbol ;

  {
  {
#line 936
  depth = (int )*(code->code_lengths + code_index);
#line 937
  symbol = (int )*(code->codes + code_index);
#line 938
  VP8LPutBits(bw, (uint32_t )symbol, depth);
  }
#line 940
  return;
}
}
#line 941 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
__inline static void WriteHuffmanCodeWithExtraBits(VP8LBitWriter *bw , HuffmanTreeCode *code ,
                                                   int code_index , int bits , int n_bits ) 
{ 
  int depth ;
  int symbol ;

  {
  {
#line 947
  depth = (int )*(code->code_lengths + code_index);
#line 948
  symbol = (int )*(code->codes + code_index);
#line 949
  VP8LPutBits(bw, (uint32_t )((bits << depth) | symbol), depth + n_bits);
  }
#line 951
  return;
}
}
#line 972 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static uint8_t order[4]  ;
#line 952 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static WebPEncodingError StoreImageToBitMask(VP8LBitWriter *bw , int width , int histo_bits ,
                                             VP8LBackwardRefs *refs , uint16_t *histogram_symbols ,
                                             HuffmanTreeCode *huffman_codes ) 
{ 
  int histo_xsize ;
  uint32_t __cil_tmp8 ;
  uint32_t tmp ;
  int tile_mask ;
  int tmp___0 ;
  int x ;
  int y ;
  int tile_x ;
  int tile_y ;
  int histogram_ix ;
  HuffmanTreeCode *codes ;
  VP8LRefsCursor c ;
  VP8LRefsCursor __cil_tmp19 ;
  int __cil_tmp20 ;
  PixOrCopy *v ;
  int __cil_tmp22 ;
  int k ;
  int code ;
  uint32_t __cil_tmp26 ;
  int __cil_tmp27 ;
  int code___0 ;
  uint32_t __cil_tmp29 ;
  int literal_ix ;
  int bits ;
  int n_bits ;
  int code___1 ;
  int distance ;
  uint32_t __cil_tmp35 ;
  uint32_t __cil_tmp36 ;
  int tmp___1 ;

  {
#line 957
  if (histo_bits) {
    {
#line 957
    __cil_tmp8 = VP8LSubSampleSize((uint32_t )width, (uint32_t )histo_bits);
#line 957
    tmp = __cil_tmp8;
    }
  } else {
#line 957
    tmp = 1U;
  }
#line 957
  histo_xsize = (int )tmp;
#line 958
  if (histo_bits == 0) {
#line 958
    tmp___0 = 0;
  } else {
#line 958
    tmp___0 = - (1 << histo_bits);
  }
  {
#line 958
  tile_mask = tmp___0;
#line 960
  x = 0;
#line 961
  y = 0;
#line 962
  tile_x = x & tile_mask;
#line 963
  tile_y = y & tile_mask;
#line 964
  histogram_ix = (int )*(histogram_symbols + 0);
#line 965
  codes = huffman_codes + 5 * histogram_ix;
#line 966
  __cil_tmp19 = VP8LRefsCursorInit(refs);
#line 966
  c = __cil_tmp19;
  }
  {
#line 967
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 967
    __cil_tmp20 = VP8LRefsCursorOk(& c);
    }
#line 967
    if (! __cil_tmp20) {
#line 967
      goto while_break;
    }
#line 968
    v = c.cur_pos;
#line 969
    if (tile_x != (x & tile_mask)) {
#line 970
      tile_x = x & tile_mask;
#line 971
      tile_y = y & tile_mask;
#line 972
      histogram_ix = (int )*(histogram_symbols + ((y >> histo_bits) * histo_xsize + (x >> histo_bits)));
#line 974
      codes = huffman_codes + 5 * histogram_ix;
    } else
#line 969
    if (tile_y != (y & tile_mask)) {
#line 970
      tile_x = x & tile_mask;
#line 971
      tile_y = y & tile_mask;
#line 972
      histogram_ix = (int )*(histogram_symbols + ((y >> histo_bits) * histo_xsize + (x >> histo_bits)));
#line 974
      codes = huffman_codes + 5 * histogram_ix;
    }
    {
#line 976
    __cil_tmp22 = PixOrCopyIsLiteral(v);
    }
#line 976
    if (__cil_tmp22) {
#line 977
      order[0] = (uint8_t )1;
#line 977
      order[1] = (uint8_t )2;
#line 977
      order[2] = (uint8_t )0;
#line 977
      order[3] = (uint8_t )3;
#line 979
      k = 0;
      {
#line 979
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 979
        if (! (k < 4)) {
#line 979
          goto while_break___0;
        }
        {
#line 980
        __cil_tmp26 = PixOrCopyLiteral(v, (int )order[k]);
#line 980
        code = (int )__cil_tmp26;
#line 981
        WriteHuffmanCode(bw, codes + k, code);
#line 979
        k ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
      {
#line 983
      __cil_tmp27 = PixOrCopyIsCacheIdx(v);
      }
#line 983
      if (__cil_tmp27) {
        {
#line 984
        __cil_tmp29 = PixOrCopyCacheIdx(v);
#line 984
        code___0 = (int )__cil_tmp29;
#line 985
        literal_ix = 280 + code___0;
#line 986
        WriteHuffmanCode(bw, codes, literal_ix);
        }
      } else {
        {
#line 991
        __cil_tmp35 = PixOrCopyCacheIdx(v);
#line 991
        distance = (int )__cil_tmp35;
#line 992
        VP8LPrefixEncode((int )v->len, & code___1, & n_bits, & bits);
#line 993
        WriteHuffmanCodeWithExtraBits(bw, codes, 256 + code___1, bits, n_bits);
#line 998
        VP8LPrefixEncode(distance, & code___1, & n_bits, & bits);
#line 999
        WriteHuffmanCode(bw, codes + 4, code___1);
#line 1000
        VP8LPutBits(bw, (uint32_t )bits, n_bits);
        }
      }
    }
    {
#line 1002
    __cil_tmp36 = PixOrCopyLength(v);
#line 1002
    x = (int )((uint32_t )x + __cil_tmp36);
    }
    {
#line 1003
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1003
      if (! (x >= width)) {
#line 1003
        goto while_break___1;
      }
#line 1004
      x -= width;
#line 1005
      y ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 1007
    VP8LRefsCursorNext(& c);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 1009
  if (bw->error_) {
#line 1009
    tmp___1 = 1;
  } else {
#line 1009
    tmp___1 = 0;
  }
#line 1009
  return ((WebPEncodingError )tmp___1);
}
}
#line 1013 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static WebPEncodingError EncodeImageNoHuffman(VP8LBitWriter *bw , uint32_t *argb ,
                                              VP8LHashChain *hash_chain , VP8LBackwardRefs *refs_array ,
                                              int width , int height , int quality ,
                                              int low_effort ) 
{ 
  int i ;
  int max_tokens ;
  WebPEncodingError err ;
  VP8LBackwardRefs *refs ;
  HuffmanTreeToken *tokens ;
  HuffmanTreeCode huffman_codes[5] ;
  uint16_t histogram_symbols[1] ;
  int cache_bits ;
  VP8LHistogramSet *histogram_image ;
  HuffmanTree *huff_tree ;
  void *__cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp23 ;
  HuffmanTreeCode *codes ;
  void *__cil_tmp25 ;
  HuffmanTreeCode *codes___0 ;

  {
  {
#line 1018
  max_tokens = 0;
#line 1019
  err = (WebPEncodingError )0;
#line 1021
  tokens = (HuffmanTreeToken *)((void *)0);
#line 1022
  huffman_codes[0].num_symbols = 0;
#line 1022
  huffman_codes[0].code_lengths = (uint8_t *)((void *)0);
#line 1022
  huffman_codes[0].codes = (uint16_t *)((void *)0);
#line 1023
  histogram_symbols[0] = (uint16_t )0;
#line 1024
  cache_bits = 0;
#line 1025
  histogram_image = (VP8LHistogramSet *)((void *)0);
#line 1026
  __cil_tmp19 = WebPSafeMalloc((uint64_t )57ULL, sizeof(*huff_tree));
#line 1026
  huff_tree = (HuffmanTree *)__cil_tmp19;
  }
#line 1028
  if ((unsigned long )huff_tree == (unsigned long )((void *)0)) {
#line 1029
    err = (WebPEncodingError )1;
#line 1030
    goto Error;
  }
  {
#line 1034
  __cil_tmp20 = VP8LHashChainFill(hash_chain, quality, argb, width, height, low_effort);
  }
#line 1034
  if (! __cil_tmp20) {
#line 1036
    err = (WebPEncodingError )1;
#line 1037
    goto Error;
  }
  {
#line 1039
  err = VP8LGetBackwardReferences(width, height, argb, quality, 0, 3, cache_bits,
                                  0, hash_chain, refs_array, & cache_bits);
  }
#line 1042
  if ((unsigned int )err != 0U) {
#line 1042
    goto Error;
  }
  {
#line 1043
  refs = refs_array + 0;
#line 1044
  histogram_image = VP8LAllocateHistogramSet(1, cache_bits);
  }
#line 1045
  if ((unsigned long )histogram_image == (unsigned long )((void *)0)) {
#line 1046
    err = (WebPEncodingError )1;
#line 1047
    goto Error;
  }
  {
#line 1049
  VP8LHistogramSetClear(histogram_image);
#line 1052
  VP8LHistogramStoreRefs(refs, *(histogram_image->histograms + 0));
#line 1056
  __cil_tmp23 = GetHuffBitLengthsAndCodes(histogram_image, huffman_codes);
  }
#line 1056
  if (! __cil_tmp23) {
#line 1057
    err = (WebPEncodingError )1;
#line 1058
    goto Error;
  }
  {
#line 1062
  VP8LPutBits(bw, (uint32_t )0, 1);
#line 1065
  i = 0;
  }
  {
#line 1065
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1065
    if (! (i < 5)) {
#line 1065
      goto while_break;
    }
#line 1066
    codes = & huffman_codes[i];
#line 1067
    if (max_tokens < codes->num_symbols) {
#line 1068
      max_tokens = codes->num_symbols;
    }
#line 1065
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1072
  __cil_tmp25 = WebPSafeMalloc((uint64_t )max_tokens, sizeof(*tokens));
#line 1072
  tokens = (HuffmanTreeToken *)__cil_tmp25;
  }
#line 1073
  if ((unsigned long )tokens == (unsigned long )((void *)0)) {
#line 1074
    err = (WebPEncodingError )1;
#line 1075
    goto Error;
  }
#line 1079
  i = 0;
  {
#line 1079
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1079
    if (! (i < 5)) {
#line 1079
      goto while_break___0;
    }
    {
#line 1080
    codes___0 = & huffman_codes[i];
#line 1081
    StoreHuffmanCode(bw, huff_tree, tokens, codes___0);
#line 1082
    ClearHuffmanTreeIfOnlyOneSymbol(codes___0);
#line 1079
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 1086
  err = StoreImageToBitMask(bw, width, 0, refs, histogram_symbols, huffman_codes);
  }
  Error: 
  {
#line 1090
  WebPSafeFree((void *)tokens);
#line 1091
  WebPSafeFree((void *)huff_tree);
#line 1092
  VP8LFreeHistogramSet(histogram_image);
#line 1093
  WebPSafeFree((void *)huffman_codes[0].codes);
  }
#line 1094
  return (err);
}
}
#line 1097 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static WebPEncodingError EncodeImageInternal(VP8LBitWriter *bw , uint32_t *argb ,
                                             VP8LHashChain *hash_chain , VP8LBackwardRefs *refs_array ,
                                             int width , int height , int quality ,
                                             int low_effort , int use_cache , CrunchConfig *config ,
                                             int *cache_bits , int histogram_bits ,
                                             size_t init_byte_position , int *hdr_size ,
                                             int *data_size ) 
{ 
  WebPEncodingError err ;
  uint32_t histogram_image_xysize ;
  uint32_t __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  VP8LHistogramSet *histogram_image ;
  VP8LHistogram *tmp_histo ;
  int histogram_image_size ;
  size_t bit_array_size ;
  HuffmanTree *huff_tree ;
  void *__cil_tmp25 ;
  HuffmanTreeToken *tokens ;
  HuffmanTreeCode *huffman_codes ;
  uint16_t *histogram_symbols ;
  void *__cil_tmp29 ;
  int sub_configs_idx ;
  int cache_bits_init ;
  int write_histogram_image ;
  VP8LBitWriter bw_init ;
  VP8LBitWriter bw_best ;
  int hdr_size_tmp ;
  VP8LHashChain hash_chain_histogram ;
  size_t bw_size_best ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int tmp ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  CrunchSubConfig *sub_config ;
  int cache_bits_best ;
  int i_cache ;
  int tmp___0 ;
  int cache_bits_tmp ;
  int tmp___1 ;
  int __cil_tmp52 ;
  void *__cil_tmp53 ;
  int __cil_tmp54 ;
  uint32_t *histogram_argb ;
  void *__cil_tmp56 ;
  int max_index ;
  uint32_t i ;
  int symbol_index ;
  uint32_t __cil_tmp60 ;
  uint32_t __cil_tmp61 ;
  WebPEncodingError __cil_tmp62 ;
  int i___0 ;
  int max_tokens ;
  HuffmanTreeCode *codes ;
  void *__cil_tmp66 ;
  HuffmanTreeCode *codes___0 ;
  size_t __cil_tmp68 ;
  size_t __cil_tmp70 ;
  size_t __cil_tmp72 ;

  {
  {
#line 1103
  err = (WebPEncodingError )1;
#line 1104
  __cil_tmp19 = VP8LSubSampleSize((uint32_t )height, (uint32_t )histogram_bits);
#line 1104
  __cil_tmp18 = VP8LSubSampleSize((uint32_t )width, (uint32_t )histogram_bits);
#line 1104
  histogram_image_xysize = __cil_tmp18 * __cil_tmp19;
#line 1107
  histogram_image = (VP8LHistogramSet *)((void *)0);
#line 1108
  tmp_histo = (VP8LHistogram *)((void *)0);
#line 1109
  histogram_image_size = 0;
#line 1110
  bit_array_size = (size_t )0;
#line 1111
  __cil_tmp25 = WebPSafeMalloc((uint64_t )57ULL, sizeof(*huff_tree));
#line 1111
  huff_tree = (HuffmanTree *)__cil_tmp25;
#line 1113
  tokens = (HuffmanTreeToken *)((void *)0);
#line 1114
  huffman_codes = (HuffmanTreeCode *)((void *)0);
#line 1115
  __cil_tmp29 = WebPSafeMalloc((uint64_t )histogram_image_xysize, sizeof(*histogram_symbols));
#line 1115
  histogram_symbols = (uint16_t *)__cil_tmp29;
#line 1120
  bw_init = *bw;
#line 1123
  bw_size_best = ~ ((size_t )0);
#line 1130
  memset((void *)(& hash_chain_histogram), 0, sizeof(hash_chain_histogram));
#line 1131
  __cil_tmp39 = VP8LHashChainFill(hash_chain, quality, argb, width, height, low_effort);
#line 1131
  __cil_tmp38 = VP8LHashChainInit(& hash_chain_histogram, (int )histogram_image_xysize);
  }
#line 1131
  if ((unsigned long )huff_tree == (unsigned long )((void *)0)) {
#line 1135
    goto Error;
  } else
#line 1131
  if ((unsigned long )histogram_symbols == (unsigned long )((void *)0)) {
#line 1135
    goto Error;
  } else
#line 1131
  if (! __cil_tmp38) {
#line 1135
    goto Error;
  } else
#line 1131
  if (! __cil_tmp39) {
#line 1135
    goto Error;
  }
#line 1137
  if (use_cache) {
#line 1140
    if (*cache_bits == 0) {
#line 1140
      tmp = 10;
    } else {
#line 1140
      tmp = *cache_bits;
    }
#line 1140
    cache_bits_init = tmp;
  } else {
#line 1142
    cache_bits_init = 0;
  }
  {
#line 1145
  __cil_tmp42 = VP8LBitWriterClone(bw, & bw_best);
#line 1145
  __cil_tmp41 = VP8LBitWriterInit(& bw_best, (size_t )0);
  }
#line 1145
  if (! __cil_tmp41) {
#line 1149
    goto Error;
  } else
#line 1145
  if (config->sub_configs_size_ > 1) {
    _L: 
#line 1145
    if (! __cil_tmp42) {
#line 1149
      goto Error;
    }
  } else
#line 1145
  if (config->sub_configs_[0].do_no_cache_) {
#line 1145
    goto _L;
  }
#line 1151
  sub_configs_idx = 0;
  {
#line 1151
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1151
    if (! (sub_configs_idx < config->sub_configs_size_)) {
#line 1151
      goto while_break;
    }
    {
#line 1153
    sub_config = & config->sub_configs_[sub_configs_idx];
#line 1156
    err = VP8LGetBackwardReferences(width, height, argb, quality, low_effort, sub_config->lz77_,
                                    cache_bits_init, sub_config->do_no_cache_, hash_chain,
                                    refs_array + 0, & cache_bits_best);
    }
#line 1160
    if ((unsigned int )err != 0U) {
#line 1160
      goto Error;
    }
#line 1162
    i_cache = 0;
    {
#line 1162
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1162
      if (! (i_cache < tmp___0)) {
#line 1162
        goto while_break___0;
      }
#line 1163
      if (i_cache == 0) {
#line 1163
        tmp___1 = cache_bits_best;
      } else {
#line 1163
        tmp___1 = 0;
      }
#line 1163
      cache_bits_tmp = tmp___1;
#line 1166
      if (i_cache == 1) {
#line 1166
        if (cache_bits_best == 0) {
#line 1166
          goto while_break___0;
        }
      }
      {
#line 1169
      VP8LBitWriterReset(& bw_init, bw);
#line 1172
      histogram_image = VP8LAllocateHistogramSet((int )histogram_image_xysize, cache_bits_tmp);
#line 1174
      tmp_histo = VP8LAllocateHistogram(cache_bits_tmp);
#line 1175
      __cil_tmp52 = VP8LGetHistoImageSymbols(width, height, refs_array + i_cache,
                                             quality, low_effort, histogram_bits,
                                             cache_bits_tmp, histogram_image, tmp_histo,
                                             histogram_symbols);
      }
#line 1175
      if ((unsigned long )histogram_image == (unsigned long )((void *)0)) {
#line 1180
        goto Error;
      } else
#line 1175
      if ((unsigned long )tmp_histo == (unsigned long )((void *)0)) {
#line 1180
        goto Error;
      } else
#line 1175
      if (! __cil_tmp52) {
#line 1180
        goto Error;
      }
      {
#line 1183
      histogram_image_size = histogram_image->size;
#line 1184
      bit_array_size = (size_t )(5 * histogram_image_size);
#line 1185
      __cil_tmp53 = WebPSafeCalloc(bit_array_size, sizeof(*huffman_codes));
#line 1185
      huffman_codes = (HuffmanTreeCode *)__cil_tmp53;
#line 1190
      __cil_tmp54 = GetHuffBitLengthsAndCodes(histogram_image, huffman_codes);
      }
#line 1190
      if ((unsigned long )huffman_codes == (unsigned long )((void *)0)) {
#line 1192
        goto Error;
      } else
#line 1190
      if (! __cil_tmp54) {
#line 1192
        goto Error;
      }
      {
#line 1195
      VP8LFreeHistogramSet(histogram_image);
#line 1196
      histogram_image = (VP8LHistogramSet *)((void *)0);
#line 1199
      VP8LFreeHistogram(tmp_histo);
#line 1200
      tmp_histo = (VP8LHistogram *)((void *)0);
      }
#line 1203
      if (cache_bits_tmp > 0) {
        {
#line 1204
        VP8LPutBits(bw, (uint32_t )1, 1);
#line 1205
        VP8LPutBits(bw, (uint32_t )cache_bits_tmp, 4);
        }
      } else {
        {
#line 1207
        VP8LPutBits(bw, (uint32_t )0, 1);
        }
      }
      {
#line 1211
      write_histogram_image = histogram_image_size > 1;
#line 1212
      VP8LPutBits(bw, (uint32_t )write_histogram_image, 1);
      }
#line 1213
      if (write_histogram_image) {
        {
#line 1214
        __cil_tmp56 = WebPSafeMalloc((uint64_t )histogram_image_xysize, sizeof(*histogram_argb));
#line 1214
        histogram_argb = (uint32_t *)__cil_tmp56;
#line 1217
        max_index = 0;
        }
#line 1219
        if ((unsigned long )histogram_argb == (unsigned long )((void *)0)) {
#line 1219
          goto Error;
        }
#line 1220
        i = (uint32_t )0;
        {
#line 1220
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1220
          if (! (i < histogram_image_xysize)) {
#line 1220
            goto while_break___1;
          }
#line 1221
          symbol_index = (int )*(histogram_symbols + i) & 65535;
#line 1222
          *(histogram_argb + i) = (uint32_t )(symbol_index << 8);
#line 1223
          if (symbol_index >= max_index) {
#line 1224
            max_index = symbol_index + 1;
          }
#line 1220
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: 
        {
#line 1227
        histogram_image_size = max_index;
#line 1229
        VP8LPutBits(bw, (uint32_t )(histogram_bits - 2), 3);
#line 1230
        __cil_tmp60 = VP8LSubSampleSize((uint32_t )width, (uint32_t )histogram_bits);
#line 1230
        __cil_tmp61 = VP8LSubSampleSize((uint32_t )height, (uint32_t )histogram_bits);
#line 1230
        __cil_tmp62 = EncodeImageNoHuffman(bw, histogram_argb, & hash_chain_histogram,
                                           refs_array + 2, (int )__cil_tmp60, (int )__cil_tmp61,
                                           quality, low_effort);
#line 1230
        err = __cil_tmp62;
#line 1234
        WebPSafeFree((void *)histogram_argb);
        }
#line 1235
        if ((unsigned int )err != 0U) {
#line 1235
          goto Error;
        }
      }
#line 1241
      max_tokens = 0;
#line 1243
      i___0 = 0;
      {
#line 1243
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1243
        if (! (i___0 < 5 * histogram_image_size)) {
#line 1243
          goto while_break___2;
        }
#line 1244
        codes = huffman_codes + i___0;
#line 1245
        if (max_tokens < codes->num_symbols) {
#line 1246
          max_tokens = codes->num_symbols;
        }
#line 1243
        i___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: 
      {
#line 1249
      __cil_tmp66 = WebPSafeMalloc((uint64_t )max_tokens, sizeof(*tokens));
#line 1249
      tokens = (HuffmanTreeToken *)__cil_tmp66;
      }
#line 1250
      if ((unsigned long )tokens == (unsigned long )((void *)0)) {
#line 1250
        goto Error;
      }
#line 1251
      i___0 = 0;
      {
#line 1251
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1251
        if (! (i___0 < 5 * histogram_image_size)) {
#line 1251
          goto while_break___3;
        }
        {
#line 1252
        codes___0 = huffman_codes + i___0;
#line 1253
        StoreHuffmanCode(bw, huff_tree, tokens, codes___0);
#line 1254
        ClearHuffmanTreeIfOnlyOneSymbol(codes___0);
#line 1251
        i___0 ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
      {
#line 1258
      __cil_tmp68 = VP8LBitWriterNumBytes(bw);
#line 1258
      hdr_size_tmp = (int )(__cil_tmp68 - init_byte_position);
#line 1259
      err = StoreImageToBitMask(bw, width, histogram_bits, refs_array + i_cache, histogram_symbols,
                                huffman_codes);
      }
#line 1261
      if ((unsigned int )err != 0U) {
#line 1261
        goto Error;
      }
      {
#line 1263
      __cil_tmp70 = VP8LBitWriterNumBytes(bw);
      }
#line 1263
      if (__cil_tmp70 < bw_size_best) {
        {
#line 1264
        bw_size_best = VP8LBitWriterNumBytes(bw);
#line 1265
        *cache_bits = cache_bits_tmp;
#line 1266
        *hdr_size = hdr_size_tmp;
#line 1267
        __cil_tmp72 = VP8LBitWriterNumBytes(bw);
#line 1267
        *data_size = (int )((__cil_tmp72 - init_byte_position) - (unsigned long )*hdr_size);
#line 1269
        VP8LBitWriterSwap(bw, & bw_best);
        }
      }
      {
#line 1271
      WebPSafeFree((void *)tokens);
#line 1272
      tokens = (HuffmanTreeToken *)((void *)0);
      }
#line 1273
      if ((unsigned long )huffman_codes != (unsigned long )((void *)0)) {
        {
#line 1274
        WebPSafeFree((void *)huffman_codes->codes);
#line 1275
        WebPSafeFree((void *)huffman_codes);
#line 1276
        huffman_codes = (HuffmanTreeCode *)((void *)0);
        }
      }
#line 1162
      i_cache ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 1152
    sub_configs_idx ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1280
  VP8LBitWriterSwap(bw, & bw_best);
#line 1281
  err = (WebPEncodingError )0;
  }
  Error: 
  {
#line 1284
  WebPSafeFree((void *)tokens);
#line 1285
  WebPSafeFree((void *)huff_tree);
#line 1286
  VP8LFreeHistogramSet(histogram_image);
#line 1287
  VP8LFreeHistogram(tmp_histo);
#line 1288
  VP8LHashChainClear(& hash_chain_histogram);
  }
#line 1289
  if ((unsigned long )huffman_codes != (unsigned long )((void *)0)) {
    {
#line 1290
    WebPSafeFree((void *)huffman_codes->codes);
#line 1291
    WebPSafeFree((void *)huffman_codes);
    }
  }
  {
#line 1293
  WebPSafeFree((void *)histogram_symbols);
#line 1294
  VP8LBitWriterWipeOut(& bw_best);
  }
#line 1295
  return (err);
}
}
#line 1301 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static void ApplySubtractGreen(VP8LEncoder *enc , int width , int height , VP8LBitWriter *bw ) 
{ 


  {
  {
#line 1303
  VP8LPutBits(bw, (uint32_t )1, 1);
#line 1304
  VP8LPutBits(bw, (uint32_t )2, 2);
#line 1305
  (*VP8LSubtractGreenFromBlueAndRed)(enc->argb_, width * height);
  }
#line 1307
  return;
}
}
#line 1308 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static WebPEncodingError ApplyPredictFilter(VP8LEncoder *enc , int width , int height ,
                                            int quality , int low_effort , int used_subtract_green ,
                                            VP8LBitWriter *bw ) 
{ 
  int pred_bits ;
  int transform_width ;
  uint32_t __cil_tmp10 ;
  int transform_height ;
  uint32_t __cil_tmp12 ;
  int near_lossless_strength ;
  int tmp ;
  WebPEncodingError __cil_tmp15 ;

  {
  {
#line 1313
  pred_bits = enc->transform_bits_;
#line 1314
  __cil_tmp10 = VP8LSubSampleSize((uint32_t )width, (uint32_t )pred_bits);
#line 1314
  transform_width = (int )__cil_tmp10;
#line 1315
  __cil_tmp12 = VP8LSubSampleSize((uint32_t )height, (uint32_t )pred_bits);
#line 1315
  transform_height = (int )__cil_tmp12;
  }
#line 1317
  if (enc->use_palette_) {
#line 1317
    tmp = 100;
  } else {
#line 1317
    tmp = (enc->config_)->near_lossless;
  }
  {
#line 1317
  near_lossless_strength = tmp;
#line 1320
  VP8LResidualImage(width, height, pred_bits, low_effort, enc->argb_, enc->argb_scratch_,
                    enc->transform_data_, near_lossless_strength, (enc->config_)->exact,
                    used_subtract_green);
#line 1324
  VP8LPutBits(bw, (uint32_t )1, 1);
#line 1325
  VP8LPutBits(bw, (uint32_t )0, 2);
#line 1327
  VP8LPutBits(bw, (uint32_t )(pred_bits - 2), 3);
#line 1328
  __cil_tmp15 = EncodeImageNoHuffman(bw, enc->transform_data_, & enc->hash_chain_,
                                     & enc->refs_[0], transform_width, transform_height,
                                     quality, low_effort);
  }
#line 1328
  return (__cil_tmp15);
}
}
#line 1334 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static WebPEncodingError ApplyCrossColorFilter(VP8LEncoder *enc , int width , int height ,
                                               int quality , int low_effort , VP8LBitWriter *bw ) 
{ 
  int ccolor_transform_bits ;
  int transform_width ;
  uint32_t __cil_tmp9 ;
  int transform_height ;
  uint32_t __cil_tmp11 ;
  WebPEncodingError __cil_tmp12 ;

  {
  {
#line 1338
  ccolor_transform_bits = enc->transform_bits_;
#line 1339
  __cil_tmp9 = VP8LSubSampleSize((uint32_t )width, (uint32_t )ccolor_transform_bits);
#line 1339
  transform_width = (int )__cil_tmp9;
#line 1340
  __cil_tmp11 = VP8LSubSampleSize((uint32_t )height, (uint32_t )ccolor_transform_bits);
#line 1340
  transform_height = (int )__cil_tmp11;
#line 1342
  VP8LColorSpaceTransform(width, height, ccolor_transform_bits, quality, enc->argb_,
                          enc->transform_data_);
#line 1344
  VP8LPutBits(bw, (uint32_t )1, 1);
#line 1345
  VP8LPutBits(bw, (uint32_t )1, 2);
#line 1347
  VP8LPutBits(bw, (uint32_t )(ccolor_transform_bits - 2), 3);
#line 1348
  __cil_tmp12 = EncodeImageNoHuffman(bw, enc->transform_data_, & enc->hash_chain_,
                                     & enc->refs_[0], transform_width, transform_height,
                                     quality, low_effort);
  }
#line 1348
  return (__cil_tmp12);
}
}
#line 1356 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static WebPEncodingError WriteRiffHeader(WebPPicture *pic , size_t riff_size , size_t vp8l_size ) 
{ 
  uint8_t riff[21] ;
  int __cil_tmp5 ;

  {
  {
#line 1358
  riff[0] = (uint8_t )'R';
#line 1358
  riff[1] = (uint8_t )'I';
#line 1358
  riff[2] = (uint8_t )'F';
#line 1358
  riff[3] = (uint8_t )'F';
#line 1358
  riff[4] = (uint8_t )0;
#line 1358
  riff[5] = (uint8_t )0;
#line 1358
  riff[6] = (uint8_t )0;
#line 1358
  riff[7] = (uint8_t )0;
#line 1358
  riff[8] = (uint8_t )'W';
#line 1358
  riff[9] = (uint8_t )'E';
#line 1358
  riff[10] = (uint8_t )'B';
#line 1358
  riff[11] = (uint8_t )'P';
#line 1358
  riff[12] = (uint8_t )'V';
#line 1358
  riff[13] = (uint8_t )'P';
#line 1358
  riff[14] = (uint8_t )'8';
#line 1358
  riff[15] = (uint8_t )'L';
#line 1358
  riff[16] = (uint8_t )0;
#line 1358
  riff[17] = (uint8_t )0;
#line 1358
  riff[18] = (uint8_t )0;
#line 1358
  riff[19] = (uint8_t )0;
#line 1358
  riff[20] = (uint8_t )47;
#line 1362
  PutLE32(riff + 4, (uint32_t )riff_size);
#line 1363
  PutLE32((riff + 12) + 4, (uint32_t )vp8l_size);
#line 1364
  __cil_tmp5 = (*(pic->writer))(riff, sizeof(riff), pic);
  }
#line 1364
  if (! __cil_tmp5) {
#line 1365
    return ((WebPEncodingError )8);
  }
#line 1367
  return ((WebPEncodingError )0);
}
}
#line 1370 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static int WriteImageSize(WebPPicture *pic , VP8LBitWriter *bw ) 
{ 
  int width ;
  int height ;

  {
  {
#line 1372
  width = pic->width - 1;
#line 1373
  height = pic->height - 1;
#line 1376
  VP8LPutBits(bw, (uint32_t )width, 14);
#line 1377
  VP8LPutBits(bw, (uint32_t )height, 14);
  }
#line 1378
  return (! bw->error_);
}
}
#line 1381 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static int WriteRealAlphaAndVersion(VP8LBitWriter *bw , int has_alpha ) 
{ 


  {
  {
#line 1382
  VP8LPutBits(bw, (uint32_t )has_alpha, 1);
#line 1383
  VP8LPutBits(bw, (uint32_t )0, 3);
  }
#line 1384
  return (! bw->error_);
}
}
#line 1387 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static WebPEncodingError WriteImage(WebPPicture *pic , VP8LBitWriter *bw , size_t *coded_size ) 
{ 
  WebPEncodingError err ;
  uint8_t *webpll_data ;
  uint8_t *__cil_tmp6 ;
  size_t webpll_size ;
  size_t __cil_tmp8 ;
  size_t vp8l_size ;
  size_t pad ;
  size_t riff_size ;
  int __cil_tmp13 ;
  uint8_t pad_byte[1] ;
  int __cil_tmp15 ;

  {
  {
#line 1390
  err = (WebPEncodingError )0;
#line 1391
  __cil_tmp6 = VP8LBitWriterFinish(bw);
#line 1391
  webpll_data = __cil_tmp6;
#line 1392
  __cil_tmp8 = VP8LBitWriterNumBytes(bw);
#line 1392
  webpll_size = __cil_tmp8;
#line 1393
  vp8l_size = 1UL + webpll_size;
#line 1394
  pad = vp8l_size & 1UL;
#line 1395
  riff_size = (12UL + vp8l_size) + pad;
#line 1397
  err = WriteRiffHeader(pic, riff_size, vp8l_size);
  }
#line 1398
  if ((unsigned int )err != 0U) {
#line 1398
    goto Error;
  }
  {
#line 1400
  __cil_tmp13 = (*(pic->writer))(webpll_data, webpll_size, pic);
  }
#line 1400
  if (! __cil_tmp13) {
#line 1401
    err = (WebPEncodingError )8;
#line 1402
    goto Error;
  }
#line 1405
  if (pad) {
    {
#line 1406
    pad_byte[0] = (uint8_t )0;
#line 1407
    __cil_tmp15 = (*(pic->writer))(pad_byte, (size_t )1, pic);
    }
#line 1407
    if (! __cil_tmp15) {
#line 1408
      err = (WebPEncodingError )8;
#line 1409
      goto Error;
    }
  }
#line 1412
  *coded_size = 8UL + riff_size;
#line 1413
  return ((WebPEncodingError )0);
  Error: 
#line 1416
  return (err);
}
}
#line 1421 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static void ClearTransformBuffer(VP8LEncoder *enc ) 
{ 


  {
  {
#line 1422
  WebPSafeFree((void *)enc->transform_mem_);
#line 1423
  enc->transform_mem_ = (uint32_t *)((void *)0);
#line 1424
  enc->transform_mem_size_ = (size_t )0;
  }
#line 1426
  return;
}
}
#line 1432 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static WebPEncodingError AllocateTransformBuffer(VP8LEncoder *enc , int width , int height ) 
{ 
  WebPEncodingError err ;
  uint64_t image_size ;
  uint64_t argb_scratch_size ;
  unsigned long tmp ;
  uint64_t transform_data_size ;
  uint32_t __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  uint32_t tmp___0 ;
  uint64_t max_alignment_in_words ;
  uint64_t mem_size ;
  uint32_t *mem ;
  void *__cil_tmp15 ;

  {
#line 1434
  err = (WebPEncodingError )0;
#line 1435
  image_size = (uint64_t )(width * height);
#line 1439
  if (enc->use_predict_) {
#line 1439
    tmp = (unsigned long )((width + 1) * 2) + (((unsigned long )(width * 2) + sizeof(uint32_t )) - 1UL) / sizeof(uint32_t );
  } else {
#line 1439
    tmp = 0UL;
  }
#line 1439
  argb_scratch_size = tmp;
#line 1444
  if (enc->use_predict_) {
    {
#line 1444
    __cil_tmp10 = VP8LSubSampleSize((uint32_t )height, (uint32_t )enc->transform_bits_);
#line 1444
    __cil_tmp9 = VP8LSubSampleSize((uint32_t )width, (uint32_t )enc->transform_bits_);
#line 1444
    tmp___0 = __cil_tmp9 * __cil_tmp10;
    }
  } else
#line 1444
  if (enc->use_cross_color_) {
    {
#line 1444
    __cil_tmp10 = VP8LSubSampleSize((uint32_t )height, (uint32_t )enc->transform_bits_);
#line 1444
    __cil_tmp9 = VP8LSubSampleSize((uint32_t )width, (uint32_t )enc->transform_bits_);
#line 1444
    tmp___0 = __cil_tmp9 * __cil_tmp10;
    }
  } else {
#line 1444
    tmp___0 = 0U;
  }
#line 1444
  transform_data_size = (uint64_t )tmp___0;
#line 1449
  max_alignment_in_words = ((31UL + sizeof(uint32_t )) - 1UL) / sizeof(uint32_t );
#line 1451
  mem_size = (((image_size + max_alignment_in_words) + argb_scratch_size) + max_alignment_in_words) + transform_data_size;
#line 1455
  mem = enc->transform_mem_;
#line 1456
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
    _L: 
    {
#line 1457
    ClearTransformBuffer(enc);
#line 1458
    __cil_tmp15 = WebPSafeMalloc(mem_size, sizeof(*mem));
#line 1458
    mem = (uint32_t *)__cil_tmp15;
    }
#line 1459
    if ((unsigned long )mem == (unsigned long )((void *)0)) {
#line 1460
      err = (WebPEncodingError )1;
#line 1461
      goto Error;
    }
#line 1463
    enc->transform_mem_ = mem;
#line 1464
    enc->transform_mem_size_ = mem_size;
#line 1465
    enc->argb_content_ = (VP8LEncoderARGBContent )0;
  } else
#line 1456
  if (mem_size > enc->transform_mem_size_) {
#line 1456
    goto _L;
  }
#line 1467
  enc->argb_ = mem;
#line 1468
  mem = (uint32_t *)(((uintptr_t )(mem + image_size) + 31UL) & 0xffffffffffffffe0UL);
#line 1469
  enc->argb_scratch_ = mem;
#line 1470
  mem = (uint32_t *)(((uintptr_t )(mem + argb_scratch_size) + 31UL) & 0xffffffffffffffe0UL);
#line 1471
  enc->transform_data_ = mem;
#line 1473
  enc->current_width_ = width;
  Error: 
#line 1475
  return (err);
}
}
#line 1478 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static WebPEncodingError MakeInputImageCopy(VP8LEncoder *enc ) 
{ 
  WebPEncodingError err ;
  WebPPicture *picture ;
  int width ;
  int height ;
  uint32_t *dst ;
  uint32_t *src ;
  int y ;

  {
  {
#line 1479
  err = (WebPEncodingError )0;
#line 1480
  picture = enc->pic_;
#line 1481
  width = picture->width;
#line 1482
  height = picture->height;
#line 1484
  err = AllocateTransformBuffer(enc, width, height);
  }
#line 1485
  if ((unsigned int )err != 0U) {
#line 1485
    return (err);
  }
#line 1486
  if ((unsigned int )enc->argb_content_ == 1U) {
#line 1486
    return ((WebPEncodingError )0);
  }
#line 1489
  dst = enc->argb_;
#line 1490
  src = picture->argb;
#line 1492
  y = 0;
  {
#line 1492
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1492
    if (! (y < height)) {
#line 1492
      goto while_break;
    }
    {
#line 1493
    memcpy((void *)dst, (void const   *)src, (unsigned long )width * sizeof(*dst));
#line 1494
    dst += width;
#line 1495
    src += picture->argb_stride;
#line 1492
    y ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1498
  enc->argb_content_ = (VP8LEncoderARGBContent )1;
#line 1500
  return ((WebPEncodingError )0);
}
}
#line 1507 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
__inline static uint32_t SearchColorGreedy(uint32_t *palette , int palette_size ,
                                           uint32_t color ) 
{ 


  {
#line 1513
  if (color == *(palette + 0)) {
#line 1513
    return ((uint32_t )0);
  }
#line 1514
  if (color == *(palette + 1)) {
#line 1514
    return ((uint32_t )1);
  }
#line 1515
  if (color == *(palette + 2)) {
#line 1515
    return ((uint32_t )2);
  }
#line 1516
  return ((uint32_t )3);
}
}
#line 1527 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
__inline static uint32_t ApplyPaletteHash1(uint32_t color ) 
{ 


  {
#line 1529
  return ((uint32_t )((unsigned long long )(color & 16777215U) * 4222244071ULL) >> 21);
}
}
#line 1533 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
__inline static uint32_t ApplyPaletteHash2(uint32_t color ) 
{ 


  {
#line 1535
  return ((uint32_t )((unsigned long long )(color & 16777215U) * ((1ULL << 31) - 1ULL)) >> 21);
}
}
#line 1562 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static WebPEncodingError ApplyPalette(uint32_t *src , uint32_t src_stride , uint32_t *dst ,
                                      uint32_t dst_stride , uint32_t *palette , int palette_size ,
                                      int width , int height , int xbits ) 
{ 
  uint8_t *tmp_row ;
  void *__cil_tmp11 ;
  int x ;
  int y ;
  uint32_t prev_pix ;
  uint32_t prev_idx ;
  uint32_t pix ;
  int i ;
  int j ;
  uint16_t buffer[2048] ;
  uint32_t (*hash_functions[3])(uint32_t  ) ;
  int use_LUT ;
  uint32_t ind ;
  uint32_t __cil_tmp24 ;
  uint32_t prev_pix___0 ;
  uint32_t prev_idx___0 ;
  uint32_t pix___0 ;
  uint32_t __cil_tmp28 ;
  uint32_t prev_pix___1 ;
  uint32_t prev_idx___1 ;
  uint32_t pix___1 ;
  uint32_t __cil_tmp32 ;
  uint32_t prev_pix___2 ;
  uint32_t prev_idx___2 ;
  uint32_t pix___2 ;
  uint32_t __cil_tmp36 ;
  uint32_t idx_map[256] ;
  uint32_t palette_sorted[256] ;
  uint32_t prev_pix___3 ;
  uint32_t prev_idx___3 ;
  uint32_t pix___3 ;
  int tmp ;

  {
  {
#line 1568
  __cil_tmp11 = WebPSafeMalloc((uint64_t )width, sizeof(*tmp_row));
#line 1568
  tmp_row = (uint8_t *)__cil_tmp11;
  }
#line 1571
  if ((unsigned long )tmp_row == (unsigned long )((void *)0)) {
#line 1571
    return ((WebPEncodingError )1);
  }
#line 1573
  if (palette_size < 4) {
    {
#line 1574
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1574
      prev_pix = *(palette + 0);
#line 1574
      prev_idx = (uint32_t )0;
#line 1574
      y = 0;
      {
#line 1574
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1574
        if (! (y < height)) {
#line 1574
          goto while_break___0;
        }
#line 1574
        x = 0;
        {
#line 1574
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1574
          if (! (x < width)) {
#line 1574
            goto while_break___1;
          }
#line 1574
          pix = *(src + x);
#line 1574
          if (pix != prev_pix) {
            {
#line 1574
            prev_idx = SearchColorGreedy(palette, palette_size, pix);
#line 1574
            prev_pix = pix;
            }
          }
#line 1574
          *(tmp_row + x) = (uint8_t )prev_idx;
#line 1574
          x ++;
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___1: 
        {
#line 1574
        (*VP8LBundleColorMap)((uint8_t */* const  */)tmp_row, width, xbits, dst);
#line 1574
        src += src_stride;
#line 1574
        dst += dst_stride;
#line 1574
        y ++;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___0: ;
#line 1574
      goto while_break;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 1578
    hash_functions[0] = & VP8GetARGBIndex;
#line 1578
    hash_functions[1] = & ApplyPaletteHash1;
#line 1578
    hash_functions[2] = & ApplyPaletteHash2;
#line 1585
    i = 0;
    {
#line 1585
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 1585
      if (! (i < 3)) {
#line 1585
        goto while_break___2;
      }
      {
#line 1586
      use_LUT = 1;
#line 1588
      memset((void *)(buffer), 255, sizeof(buffer));
#line 1589
      j = 0;
      }
      {
#line 1589
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1589
        if (! (j < palette_size)) {
#line 1589
          goto while_break___3;
        }
        {
#line 1590
        __cil_tmp24 = (*(hash_functions[i]))(*(palette + j));
#line 1590
        ind = __cil_tmp24;
        }
#line 1591
        if ((unsigned int )buffer[ind] != 65535U) {
#line 1592
          use_LUT = 0;
#line 1593
          goto while_break___3;
        } else {
#line 1595
          buffer[ind] = (uint16_t )j;
        }
#line 1589
        j ++;
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___3: ;
#line 1598
      if (use_LUT) {
#line 1598
        goto while_break___2;
      }
#line 1585
      i ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___2: ;
#line 1601
    if (i == 0) {
      {
#line 1602
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1602
        prev_pix___0 = *(palette + 0);
#line 1602
        prev_idx___0 = (uint32_t )0;
#line 1602
        y = 0;
        {
#line 1602
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 1602
          if (! (y < height)) {
#line 1602
            goto while_break___5;
          }
#line 1602
          x = 0;
          {
#line 1602
          while (1) {
            while_continue___6: /* CIL Label */ ;

#line 1602
            if (! (x < width)) {
#line 1602
              goto while_break___6;
            }
#line 1602
            pix___0 = *(src + x);
#line 1602
            if (pix___0 != prev_pix___0) {
              {
#line 1602
              __cil_tmp28 = VP8GetARGBIndex(pix___0);
#line 1602
              prev_idx___0 = (uint32_t )buffer[__cil_tmp28];
#line 1602
              prev_pix___0 = pix___0;
              }
            }
#line 1602
            *(tmp_row + x) = (uint8_t )prev_idx___0;
#line 1602
            x ++;
          }
          while_break___23: /* CIL Label */ ;
          }
          while_break___6: 
          {
#line 1602
          (*VP8LBundleColorMap)((uint8_t */* const  */)tmp_row, width, xbits, dst);
#line 1602
          src += src_stride;
#line 1602
          dst += dst_stride;
#line 1602
          y ++;
          }
        }
        while_break___22: /* CIL Label */ ;
        }
        while_break___5: ;
#line 1602
        goto while_break___4;
      }
      while_break___21: /* CIL Label */ ;
      }
      while_break___4: ;
    } else
#line 1603
    if (i == 1) {
      {
#line 1604
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1604
        prev_pix___1 = *(palette + 0);
#line 1604
        prev_idx___1 = (uint32_t )0;
#line 1604
        y = 0;
        {
#line 1604
        while (1) {
          while_continue___8: /* CIL Label */ ;

#line 1604
          if (! (y < height)) {
#line 1604
            goto while_break___8;
          }
#line 1604
          x = 0;
          {
#line 1604
          while (1) {
            while_continue___9: /* CIL Label */ ;

#line 1604
            if (! (x < width)) {
#line 1604
              goto while_break___9;
            }
#line 1604
            pix___1 = *(src + x);
#line 1604
            if (pix___1 != prev_pix___1) {
              {
#line 1604
              __cil_tmp32 = ApplyPaletteHash1(pix___1);
#line 1604
              prev_idx___1 = (uint32_t )buffer[__cil_tmp32];
#line 1604
              prev_pix___1 = pix___1;
              }
            }
#line 1604
            *(tmp_row + x) = (uint8_t )prev_idx___1;
#line 1604
            x ++;
          }
          while_break___26: /* CIL Label */ ;
          }
          while_break___9: 
          {
#line 1604
          (*VP8LBundleColorMap)((uint8_t */* const  */)tmp_row, width, xbits, dst);
#line 1604
          src += src_stride;
#line 1604
          dst += dst_stride;
#line 1604
          y ++;
          }
        }
        while_break___25: /* CIL Label */ ;
        }
        while_break___8: ;
#line 1604
        goto while_break___7;
      }
      while_break___24: /* CIL Label */ ;
      }
      while_break___7: ;
    } else
#line 1605
    if (i == 2) {
      {
#line 1606
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1606
        prev_pix___2 = *(palette + 0);
#line 1606
        prev_idx___2 = (uint32_t )0;
#line 1606
        y = 0;
        {
#line 1606
        while (1) {
          while_continue___11: /* CIL Label */ ;

#line 1606
          if (! (y < height)) {
#line 1606
            goto while_break___11;
          }
#line 1606
          x = 0;
          {
#line 1606
          while (1) {
            while_continue___12: /* CIL Label */ ;

#line 1606
            if (! (x < width)) {
#line 1606
              goto while_break___12;
            }
#line 1606
            pix___2 = *(src + x);
#line 1606
            if (pix___2 != prev_pix___2) {
              {
#line 1606
              __cil_tmp36 = ApplyPaletteHash2(pix___2);
#line 1606
              prev_idx___2 = (uint32_t )buffer[__cil_tmp36];
#line 1606
              prev_pix___2 = pix___2;
              }
            }
#line 1606
            *(tmp_row + x) = (uint8_t )prev_idx___2;
#line 1606
            x ++;
          }
          while_break___29: /* CIL Label */ ;
          }
          while_break___12: 
          {
#line 1606
          (*VP8LBundleColorMap)((uint8_t */* const  */)tmp_row, width, xbits, dst);
#line 1606
          src += src_stride;
#line 1606
          dst += dst_stride;
#line 1606
          y ++;
          }
        }
        while_break___28: /* CIL Label */ ;
        }
        while_break___11: ;
#line 1606
        goto while_break___10;
      }
      while_break___27: /* CIL Label */ ;
      }
      while_break___10: ;
    } else {
      {
#line 1610
      PrepareMapToPalette(palette, (uint32_t )palette_size, palette_sorted, idx_map);
      }
      {
#line 1611
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 1611
        prev_pix___3 = *(palette + 0);
#line 1611
        prev_idx___3 = (uint32_t )0;
#line 1611
        y = 0;
        {
#line 1611
        while (1) {
          while_continue___14: /* CIL Label */ ;

#line 1611
          if (! (y < height)) {
#line 1611
            goto while_break___14;
          }
#line 1611
          x = 0;
          {
#line 1611
          while (1) {
            while_continue___15: /* CIL Label */ ;

#line 1611
            if (! (x < width)) {
#line 1611
              goto while_break___15;
            }
#line 1611
            pix___3 = *(src + x);
#line 1611
            if (pix___3 != prev_pix___3) {
              {
#line 1611
              tmp = SearchColorNoIdx(palette_sorted, pix___3, palette_size);
#line 1611
              prev_idx___3 = (uint32_t )tmp;
#line 1611
              prev_pix___3 = pix___3;
              }
            }
#line 1611
            *(tmp_row + x) = (uint8_t )prev_idx___3;
#line 1611
            x ++;
          }
          while_break___32: /* CIL Label */ ;
          }
          while_break___15: 
          {
#line 1611
          (*VP8LBundleColorMap)((uint8_t */* const  */)tmp_row, width, xbits, dst);
#line 1611
          src += src_stride;
#line 1611
          dst += dst_stride;
#line 1611
          y ++;
          }
        }
        while_break___31: /* CIL Label */ ;
        }
        while_break___14: ;
#line 1611
        goto while_break___13;
      }
      while_break___30: /* CIL Label */ ;
      }
      while_break___13: ;
    }
  }
  {
#line 1615
  WebPSafeFree((void *)tmp_row);
  }
#line 1616
  return ((WebPEncodingError )0);
}
}
#line 1624 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static WebPEncodingError MapImageFromPalette(VP8LEncoder *enc , int in_place ) 
{ 
  WebPEncodingError err ;
  WebPPicture *pic ;
  int width ;
  int height ;
  uint32_t *palette ;
  uint32_t *src ;
  uint32_t *tmp ;
  int src_stride ;
  int tmp___0 ;
  int palette_size ;
  int xbits ;
  int tmp___1 ;
  int tmp___2 ;
  uint32_t __cil_tmp16 ;
  WebPEncodingError __cil_tmp17 ;

  {
#line 1626
  err = (WebPEncodingError )0;
#line 1627
  pic = enc->pic_;
#line 1628
  width = pic->width;
#line 1629
  height = pic->height;
#line 1630
  palette = enc->palette_;
#line 1631
  if (in_place) {
#line 1631
    tmp = enc->argb_;
  } else {
#line 1631
    tmp = pic->argb;
  }
#line 1631
  src = tmp;
#line 1632
  if (in_place) {
#line 1632
    tmp___0 = enc->current_width_;
  } else {
#line 1632
    tmp___0 = pic->argb_stride;
  }
#line 1632
  src_stride = tmp___0;
#line 1633
  palette_size = enc->palette_size_;
#line 1638
  if (palette_size <= 4) {
#line 1639
    if (palette_size <= 2) {
#line 1639
      tmp___1 = 3;
    } else {
#line 1639
      tmp___1 = 2;
    }
#line 1639
    xbits = tmp___1;
  } else {
#line 1641
    if (palette_size <= 16) {
#line 1641
      tmp___2 = 1;
    } else {
#line 1641
      tmp___2 = 0;
    }
#line 1641
    xbits = tmp___2;
  }
  {
#line 1644
  __cil_tmp16 = VP8LSubSampleSize((uint32_t )width, (uint32_t )xbits);
#line 1644
  __cil_tmp17 = AllocateTransformBuffer(enc, (int )__cil_tmp16, height);
#line 1644
  err = __cil_tmp17;
  }
#line 1645
  if ((unsigned int )err != 0U) {
#line 1645
    return (err);
  }
  {
#line 1647
  err = ApplyPalette(src, (uint32_t )src_stride, enc->argb_, (uint32_t )enc->current_width_,
                     palette, palette_size, width, height, xbits);
#line 1650
  enc->argb_content_ = (VP8LEncoderARGBContent )3;
  }
#line 1651
  return (err);
}
}
#line 1655 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static WebPEncodingError EncodePalette(VP8LBitWriter *bw , int low_effort , VP8LEncoder *enc ) 
{ 
  int i ;
  uint32_t tmp_palette[256] ;
  int palette_size ;
  uint32_t *palette ;
  WebPEncodingError __cil_tmp9 ;

  {
  {
#line 1659
  palette_size = enc->palette_size_;
#line 1660
  palette = enc->palette_;
#line 1661
  VP8LPutBits(bw, (uint32_t )1, 1);
#line 1662
  VP8LPutBits(bw, (uint32_t )3, 2);
#line 1664
  VP8LPutBits(bw, (uint32_t )(palette_size - 1), 8);
#line 1665
  i = palette_size - 1;
  }
  {
#line 1665
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1665
    if (! (i >= 1)) {
#line 1665
      goto while_break;
    }
    {
#line 1666
    tmp_palette[i] = VP8LSubPixels(*(palette + i), *(palette + (i - 1)));
#line 1665
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1668
  tmp_palette[0] = *(palette + 0);
#line 1669
  __cil_tmp9 = EncodeImageNoHuffman(bw, tmp_palette, & enc->hash_chain_, & enc->refs_[0],
                                    palette_size, 1, 20, low_effort);
  }
#line 1669
  return (__cil_tmp9);
}
}
#line 1677 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static VP8LEncoder *VP8LEncoderNew(WebPConfig *config , WebPPicture *picture ) 
{ 
  VP8LEncoder *enc ;
  void *__cil_tmp4 ;

  {
  {
#line 1679
  __cil_tmp4 = WebPSafeCalloc((uint64_t )1ULL, sizeof(*enc));
#line 1679
  enc = (VP8LEncoder *)__cil_tmp4;
  }
#line 1680
  if ((unsigned long )enc == (unsigned long )((void *)0)) {
    {
#line 1681
    WebPEncodingSetError(picture, (WebPEncodingError )1);
    }
#line 1682
    return ((VP8LEncoder *)((void *)0));
  }
  {
#line 1684
  enc->config_ = config;
#line 1685
  enc->pic_ = picture;
#line 1686
  enc->argb_content_ = (VP8LEncoderARGBContent )0;
#line 1688
  VP8LEncDspInit();
  }
#line 1690
  return (enc);
}
}
#line 1693 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static void VP8LEncoderDelete(VP8LEncoder *enc ) 
{ 
  int i ;

  {
#line 1694
  if ((unsigned long )enc != (unsigned long )((void *)0)) {
    {
#line 1696
    VP8LHashChainClear(& enc->hash_chain_);
#line 1697
    i = 0;
    }
    {
#line 1697
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1697
      if (! (i < 4)) {
#line 1697
        goto while_break;
      }
      {
#line 1697
      VP8LBackwardRefsClear(& enc->refs_[i]);
#line 1697
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 1698
    ClearTransformBuffer(enc);
#line 1699
    WebPSafeFree((void *)enc);
    }
  }
#line 1702
  return;
}
}
#line 1719 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
static int EncodeStreamHook(void *input , void *data2 ) 
{ 
  StreamEncodeContext *params ;
  WebPConfig *config ;
  WebPPicture *picture ;
  VP8LBitWriter *bw ;
  VP8LEncoder *enc ;
  int use_cache ;
  CrunchConfig *crunch_configs ;
  int num_crunch_configs ;
  int red_and_blue_always_zero ;
  WebPAuxStats *stats ;
  WebPEncodingError err ;
  int quality ;
  int low_effort ;
  int width ;
  int height ;
  size_t byte_position ;
  size_t __cil_tmp19 ;
  int use_near_lossless ;
  int hdr_size ;
  int data_size ;
  int use_delta_palette ;
  int idx ;
  size_t best_size ;
  VP8LBitWriter bw_init ;
  VP8LBitWriter bw_best ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int entropy_idx ;
  int tmp ;
  int __cil_tmp33 ;
  int __cil_tmp37 ;
  size_t __cil_tmp42 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1720
  params = (StreamEncodeContext *)input;
#line 1721
  config = params->config_;
#line 1722
  picture = params->picture_;
#line 1723
  bw = params->bw_;
#line 1724
  enc = params->enc_;
#line 1725
  use_cache = params->use_cache_;
#line 1726
  crunch_configs = params->crunch_configs_;
#line 1727
  num_crunch_configs = params->num_crunch_configs_;
#line 1728
  red_and_blue_always_zero = params->red_and_blue_always_zero_;
#line 1730
  stats = params->stats_;
#line 1732
  err = (WebPEncodingError )0;
#line 1733
  quality = (int )config->quality;
#line 1734
  low_effort = config->method == 0;
#line 1736
  width = picture->width;
#line 1738
  height = picture->height;
#line 1739
  __cil_tmp19 = VP8LBitWriterNumBytes(bw);
#line 1739
  byte_position = __cil_tmp19;
#line 1741
  use_near_lossless = 0;
#line 1743
  hdr_size = 0;
#line 1744
  data_size = 0;
#line 1745
  use_delta_palette = 0;
#line 1747
  best_size = ~ ((size_t )0);
#line 1748
  bw_init = *bw;
#line 1751
  __cil_tmp29 = VP8LBitWriterClone(bw, & bw_best);
#line 1751
  __cil_tmp28 = VP8LBitWriterInit(& bw_best, (size_t )0);
  }
#line 1751
  if (! __cil_tmp28) {
#line 1753
    err = (WebPEncodingError )1;
#line 1754
    goto Error;
  } else
#line 1751
  if (num_crunch_configs > 1) {
#line 1751
    if (! __cil_tmp29) {
#line 1753
      err = (WebPEncodingError )1;
#line 1754
      goto Error;
    }
  }
#line 1757
  idx = 0;
  {
#line 1757
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1757
    if (! (idx < num_crunch_configs)) {
#line 1757
      goto while_break;
    }
#line 1758
    entropy_idx = (crunch_configs + idx)->entropy_idx_;
#line 1759
    if (entropy_idx == 4) {
#line 1759
      tmp___0 = 1;
    } else
#line 1759
    if (entropy_idx == 5) {
#line 1759
      tmp___0 = 1;
    } else {
#line 1759
      tmp___0 = 0;
    }
#line 1759
    enc->use_palette_ = tmp___0;
#line 1761
    if (entropy_idx == 2) {
#line 1761
      tmp___1 = 1;
    } else
#line 1761
    if (entropy_idx == 3) {
#line 1761
      tmp___1 = 1;
    } else {
#line 1761
      tmp___1 = 0;
    }
#line 1761
    enc->use_subtract_green_ = tmp___1;
#line 1763
    if (entropy_idx == 1) {
#line 1763
      tmp___2 = 1;
    } else
#line 1763
    if (entropy_idx == 3) {
#line 1763
      tmp___2 = 1;
    } else
#line 1763
    if (entropy_idx == 5) {
#line 1763
      tmp___2 = 1;
    } else {
#line 1763
      tmp___2 = 0;
    }
#line 1763
    enc->use_predict_ = tmp___2;
#line 1767
    if (low_effort) {
#line 1768
      enc->use_cross_color_ = 0;
    } else
#line 1767
    if (enc->use_palette_) {
#line 1768
      enc->use_cross_color_ = 0;
    } else {
#line 1770
      if (red_and_blue_always_zero) {
#line 1770
        tmp = 0;
      } else {
#line 1770
        tmp = enc->use_predict_;
      }
#line 1770
      enc->use_cross_color_ = tmp;
    }
    {
#line 1773
    enc->cache_bits_ = 0;
#line 1774
    VP8LBackwardRefsClear(& enc->refs_[0]);
#line 1775
    VP8LBackwardRefsClear(& enc->refs_[1]);
    }
#line 1779
    if (config->near_lossless < 100) {
#line 1779
      if (! enc->use_palette_) {
#line 1779
        if (! enc->use_predict_) {
#line 1779
          tmp___3 = 1;
        } else {
#line 1779
          tmp___3 = 0;
        }
      } else {
#line 1779
        tmp___3 = 0;
      }
    } else {
#line 1779
      tmp___3 = 0;
    }
#line 1779
    use_near_lossless = tmp___3;
#line 1781
    if (use_near_lossless) {
      {
#line 1782
      err = AllocateTransformBuffer(enc, width, height);
      }
#line 1783
      if ((unsigned int )err != 0U) {
#line 1783
        goto Error;
      }
      {
#line 1784
      __cil_tmp33 = VP8ApplyNearLossless(picture, config->near_lossless, enc->argb_);
      }
#line 1784
      if ((unsigned int )enc->argb_content_ != 2U) {
#line 1784
        if (! __cil_tmp33) {
#line 1786
          err = (WebPEncodingError )1;
#line 1787
          goto Error;
        }
      }
#line 1789
      enc->argb_content_ = (VP8LEncoderARGBContent )2;
    } else {
#line 1791
      enc->argb_content_ = (VP8LEncoderARGBContent )0;
    }
#line 1798
    if (enc->use_palette_) {
#line 1799
      if ((unsigned int )(crunch_configs + idx)->palette_sorting_type_ == 0U) {
        {
#line 1801
        memcpy((void *)(enc->palette_), (void const   *)(enc->palette_sorted_), (unsigned long )enc->palette_size_ * sizeof(enc->palette_[0]));
        }
      } else
#line 1803
      if ((unsigned int )(crunch_configs + idx)->palette_sorting_type_ == 1U) {
        {
#line 1804
        PaletteSortMinimizeDeltas(enc->palette_sorted_, enc->palette_size_, enc->palette_);
        }
      } else {
        {
#line 1808
        err = PaletteSortModifiedZeng(enc->pic_, enc->palette_sorted_, (uint32_t )enc->palette_size_,
                                      enc->palette_);
        }
#line 1810
        if ((unsigned int )err != 0U) {
#line 1810
          goto Error;
        }
      }
      {
#line 1812
      err = EncodePalette(bw, low_effort, enc);
      }
#line 1813
      if ((unsigned int )err != 0U) {
#line 1813
        goto Error;
      }
      {
#line 1814
      err = MapImageFromPalette(enc, use_delta_palette);
      }
#line 1815
      if ((unsigned int )err != 0U) {
#line 1815
        goto Error;
      }
#line 1818
      if (use_cache) {
#line 1818
        if (enc->palette_size_ < 1 << 10) {
          {
#line 1819
          __cil_tmp37 = BitsLog2Floor((uint32_t )enc->palette_size_);
#line 1819
          enc->cache_bits_ = __cil_tmp37 + 1;
          }
        }
      }
    }
#line 1822
    if (! use_delta_palette) {
#line 1824
      if ((unsigned int )enc->argb_content_ != 2U) {
#line 1824
        if ((unsigned int )enc->argb_content_ != 3U) {
          {
#line 1826
          err = MakeInputImageCopy(enc);
          }
#line 1827
          if ((unsigned int )err != 0U) {
#line 1827
            goto Error;
          }
        }
      }
#line 1833
      if (enc->use_subtract_green_) {
        {
#line 1834
        ApplySubtractGreen(enc, enc->current_width_, height, bw);
        }
      }
#line 1837
      if (enc->use_predict_) {
        {
#line 1838
        err = ApplyPredictFilter(enc, enc->current_width_, height, quality, low_effort,
                                 enc->use_subtract_green_, bw);
        }
#line 1840
        if ((unsigned int )err != 0U) {
#line 1840
          goto Error;
        }
      }
#line 1843
      if (enc->use_cross_color_) {
        {
#line 1844
        err = ApplyCrossColorFilter(enc, enc->current_width_, height, quality, low_effort,
                                    bw);
        }
#line 1846
        if ((unsigned int )err != 0U) {
#line 1846
          goto Error;
        }
      }
    }
    {
#line 1850
    VP8LPutBits(bw, (uint32_t )0, 1);
#line 1854
    err = EncodeImageInternal(bw, enc->argb_, & enc->hash_chain_, (VP8LBackwardRefs *)(enc->refs_),
                              enc->current_width_, height, quality, low_effort, use_cache,
                              crunch_configs + idx, & enc->cache_bits_, enc->histo_bits_,
                              byte_position, & hdr_size, & data_size);
    }
#line 1859
    if ((unsigned int )err != 0U) {
#line 1859
      goto Error;
    }
    {
#line 1862
    __cil_tmp42 = VP8LBitWriterNumBytes(bw);
    }
#line 1862
    if (__cil_tmp42 < best_size) {
      {
#line 1863
      best_size = VP8LBitWriterNumBytes(bw);
#line 1865
      VP8LBitWriterSwap(bw, & bw_best);
      }
#line 1868
      if ((unsigned long )stats != (unsigned long )((void *)0)) {
#line 1869
        stats->lossless_features = (uint32_t )0;
#line 1870
        if (enc->use_predict_) {
#line 1870
          stats->lossless_features |= 1U;
        }
#line 1871
        if (enc->use_cross_color_) {
#line 1871
          stats->lossless_features |= 2U;
        }
#line 1872
        if (enc->use_subtract_green_) {
#line 1872
          stats->lossless_features |= 4U;
        }
#line 1873
        if (enc->use_palette_) {
#line 1873
          stats->lossless_features |= 8U;
        }
#line 1874
        stats->histogram_bits = enc->histo_bits_;
#line 1875
        stats->transform_bits = enc->transform_bits_;
#line 1876
        stats->cache_bits = enc->cache_bits_;
#line 1877
        stats->palette_size = enc->palette_size_;
#line 1878
        stats->lossless_size = (int )(best_size - byte_position);
#line 1879
        stats->lossless_hdr_size = hdr_size;
#line 1880
        stats->lossless_data_size = data_size;
      }
    }
#line 1885
    if (num_crunch_configs > 1) {
      {
#line 1885
      VP8LBitWriterReset(& bw_init, bw);
      }
    }
#line 1757
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1887
  VP8LBitWriterSwap(& bw_best, bw);
  }
  Error: 
  {
#line 1890
  VP8LBitWriterWipeOut(& bw_best);
#line 1891
  params->err_ = err;
  }
#line 1893
  return ((unsigned int )err == 0U);
}
}
#line 1896 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
WebPEncodingError VP8LEncodeStream(WebPConfig *config , WebPPicture *picture , VP8LBitWriter *bw_main ,
                                   int use_cache ) 
{ 
  WebPEncodingError err ;
  VP8LEncoder *enc_main ;
  VP8LEncoder *__cil_tmp7 ;
  VP8LEncoder *enc_side ;
  CrunchConfig crunch_configs[8] ;
  int num_crunch_configs_main ;
  int num_crunch_configs_side ;
  int idx ;
  int red_and_blue_always_zero ;
  WebPWorker worker_main ;
  WebPWorker worker_side ;
  StreamEncodeContext params_main ;
  StreamEncodeContext params_side ;
  WebPAuxStats stats_side ;
  VP8LBitWriter bw_side ;
  WebPWorkerInterface *worker_interface ;
  WebPWorkerInterface *__cil_tmp21 ;
  int ok_main ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int params_size ;
  int tmp ;
  WebPWorker *worker ;
  WebPWorker *tmp___0 ;
  StreamEncodeContext *param ;
  StreamEncodeContext *tmp___1 ;
  WebPAuxStats *tmp___2 ;
  int __cil_tmp33 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int ok_side ;
  int __cil_tmp39 ;
  unsigned int tmp___3 ;
  size_t __cil_tmp41 ;
  size_t __cil_tmp42 ;

  {
  {
#line 1900
  err = (WebPEncodingError )0;
#line 1901
  __cil_tmp7 = VP8LEncoderNew(config, picture);
#line 1901
  enc_main = __cil_tmp7;
#line 1902
  enc_side = (VP8LEncoder *)((void *)0);
#line 1904
  num_crunch_configs_side = 0;
#line 1906
  red_and_blue_always_zero = 0;
#line 1912
  __cil_tmp21 = WebPGetWorkerInterface();
#line 1912
  worker_interface = __cil_tmp21;
#line 1916
  __cil_tmp25 = VP8LBitWriterInit(& bw_side, (size_t )0);
#line 1916
  __cil_tmp24 = EncoderInit(enc_main);
#line 1916
  __cil_tmp23 = EncoderAnalyze(enc_main, (CrunchConfig *)(crunch_configs), & num_crunch_configs_main,
                               & red_and_blue_always_zero);
  }
#line 1916
  if ((unsigned long )enc_main == (unsigned long )((void *)0)) {
#line 1920
    err = (WebPEncodingError )1;
#line 1921
    goto Error;
  } else
#line 1916
  if (! __cil_tmp23) {
#line 1920
    err = (WebPEncodingError )1;
#line 1921
    goto Error;
  } else
#line 1916
  if (! __cil_tmp24) {
#line 1920
    err = (WebPEncodingError )1;
#line 1921
    goto Error;
  } else
#line 1916
  if (! __cil_tmp25) {
#line 1920
    err = (WebPEncodingError )1;
#line 1921
    goto Error;
  }
#line 1925
  if (config->thread_level > 0) {
#line 1926
    num_crunch_configs_side = num_crunch_configs_main / 2;
#line 1927
    idx = 0;
    {
#line 1927
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1927
      if (! (idx < num_crunch_configs_side)) {
#line 1927
        goto while_break;
      }
#line 1928
      params_side.crunch_configs_[idx] = crunch_configs[(num_crunch_configs_main - num_crunch_configs_side) + idx];
#line 1927
      idx ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: 
#line 1932
    params_side.num_crunch_configs_ = num_crunch_configs_side;
  }
#line 1934
  num_crunch_configs_main -= num_crunch_configs_side;
#line 1935
  idx = 0;
  {
#line 1935
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1935
    if (! (idx < num_crunch_configs_main)) {
#line 1935
      goto while_break___0;
    }
#line 1936
    params_main.crunch_configs_[idx] = crunch_configs[idx];
#line 1935
    idx ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 1938
  params_main.num_crunch_configs_ = num_crunch_configs_main;
#line 1942
  if (num_crunch_configs_side > 0) {
#line 1942
    tmp = 2;
  } else {
#line 1942
    tmp = 1;
  }
#line 1942
  params_size = tmp;
#line 1943
  idx = 0;
  {
#line 1943
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 1943
    if (! (idx < params_size)) {
#line 1943
      goto while_break___1;
    }
#line 1945
    if (idx == 0) {
#line 1945
      tmp___0 = & worker_main;
    } else {
#line 1945
      tmp___0 = & worker_side;
    }
#line 1945
    worker = tmp___0;
#line 1946
    if (idx == 0) {
#line 1946
      tmp___1 = & params_main;
    } else {
#line 1946
      tmp___1 = & params_side;
    }
#line 1946
    param = tmp___1;
#line 1948
    param->config_ = config;
#line 1949
    param->picture_ = picture;
#line 1950
    param->use_cache_ = use_cache;
#line 1951
    param->red_and_blue_always_zero_ = red_and_blue_always_zero;
#line 1952
    if (idx == 0) {
#line 1953
      param->stats_ = picture->stats;
#line 1954
      param->bw_ = bw_main;
#line 1955
      param->enc_ = enc_main;
    } else {
#line 1957
      if ((unsigned long )picture->stats == (unsigned long )((void *)0)) {
#line 1957
        tmp___2 = (WebPAuxStats *)((void *)0);
      } else {
#line 1957
        tmp___2 = & stats_side;
      }
      {
#line 1957
      param->stats_ = tmp___2;
#line 1959
      __cil_tmp33 = VP8LBitWriterClone(bw_main, & bw_side);
      }
#line 1959
      if (! __cil_tmp33) {
#line 1960
        err = (WebPEncodingError )1;
#line 1961
        goto Error;
      }
      {
#line 1963
      param->bw_ = & bw_side;
#line 1965
      enc_side = VP8LEncoderNew(config, picture);
#line 1966
      __cil_tmp35 = EncoderInit(enc_side);
      }
#line 1966
      if ((unsigned long )enc_side == (unsigned long )((void *)0)) {
#line 1967
        err = (WebPEncodingError )1;
#line 1968
        goto Error;
      } else
#line 1966
      if (! __cil_tmp35) {
#line 1967
        err = (WebPEncodingError )1;
#line 1968
        goto Error;
      }
      {
#line 1971
      enc_side->histo_bits_ = enc_main->histo_bits_;
#line 1972
      enc_side->transform_bits_ = enc_main->transform_bits_;
#line 1973
      enc_side->palette_size_ = enc_main->palette_size_;
#line 1974
      memcpy((void *)(enc_side->palette_), (void const   *)(enc_main->palette_), sizeof(enc_main->palette_));
#line 1976
      memcpy((void *)(enc_side->palette_sorted_), (void const   *)(enc_main->palette_sorted_),
             sizeof(enc_main->palette_sorted_));
#line 1978
      param->enc_ = enc_side;
      }
    }
    {
#line 1981
    (*(worker_interface->Init))((WebPWorker */* const  */)worker);
#line 1982
    worker->data1 = (void *)param;
#line 1983
    worker->data2 = (void *)0;
#line 1984
    worker->hook = & EncodeStreamHook;
#line 1943
    idx ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: ;
#line 1989
  if (num_crunch_configs_side != 0) {
    {
#line 1990
    __cil_tmp36 = (*(worker_interface->Reset))((WebPWorker */* const  */)(& worker_side));
    }
#line 1990
    if (! __cil_tmp36) {
#line 1991
      err = (WebPEncodingError )1;
#line 1992
      goto Error;
    }
#line 1997
    if ((unsigned long )picture->stats != (unsigned long )((void *)0)) {
      {
#line 1998
      memcpy((void *)(& stats_side), (void const   *)picture->stats, sizeof(stats_side));
      }
    }
    {
#line 2002
    params_side.err_ = (WebPEncodingError )0;
#line 2003
    (*(worker_interface->Launch))((WebPWorker */* const  */)(& worker_side));
    }
  }
  {
#line 2006
  (*(worker_interface->Execute))((WebPWorker */* const  */)(& worker_main));
#line 2007
  ok_main = (*(worker_interface->Sync))((WebPWorker */* const  */)(& worker_main));
#line 2008
  (*(worker_interface->End))((WebPWorker */* const  */)(& worker_main));
  }
#line 2009
  if (num_crunch_configs_side != 0) {
    {
#line 2011
    __cil_tmp39 = (*(worker_interface->Sync))((WebPWorker */* const  */)(& worker_side));
#line 2011
    ok_side = __cil_tmp39;
#line 2012
    (*(worker_interface->End))((WebPWorker */* const  */)(& worker_side));
    }
#line 2013
    if (! ok_main) {
      _L: 
#line 2014
      if (ok_main) {
#line 2014
        tmp___3 = (unsigned int )params_side.err_;
      } else {
#line 2014
        tmp___3 = (unsigned int )params_main.err_;
      }
#line 2014
      err = (WebPEncodingError )tmp___3;
#line 2015
      goto Error;
    } else
#line 2013
    if (! ok_side) {
#line 2013
      goto _L;
    }
    {
#line 2017
    __cil_tmp42 = VP8LBitWriterNumBytes(bw_main);
#line 2017
    __cil_tmp41 = VP8LBitWriterNumBytes(& bw_side);
    }
#line 2017
    if (__cil_tmp41 < __cil_tmp42) {
      {
#line 2018
      VP8LBitWriterSwap(bw_main, & bw_side);
      }
#line 2020
      if ((unsigned long )picture->stats != (unsigned long )((void *)0)) {
        {
#line 2021
        memcpy((void *)picture->stats, (void const   *)(& stats_side), sizeof(*(picture->stats)));
        }
      }
    }
  } else
#line 2026
  if (! ok_main) {
#line 2027
    err = params_main.err_;
#line 2028
    goto Error;
  }
  Error: 
  {
#line 2033
  VP8LBitWriterWipeOut(& bw_side);
#line 2034
  VP8LEncoderDelete(enc_main);
#line 2035
  VP8LEncoderDelete(enc_side);
  }
#line 2036
  return (err);
}
}
#line 2042 "/root/patron-new/new_3/src/enc/vp8l_enc.c"
int VP8LEncodeImage(WebPConfig *config , WebPPicture *picture ) 
{ 
  int width ;
  int height ;
  int has_alpha ;
  size_t coded_size ;
  int percent ;
  int initial_size ;
  WebPEncodingError err ;
  VP8LBitWriter bw ;
  int tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  WebPAuxStats *stats ;
  int __cil_tmp15 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp20 ;
  int __cil_tmp22 ;
  int mb_w ;
  int mb_h ;

  {
#line 2047
  percent = 0;
#line 2049
  err = (WebPEncodingError )0;
#line 2052
  if ((unsigned long )picture == (unsigned long )((void *)0)) {
#line 2052
    return (0);
  }
#line 2054
  if ((unsigned long )config == (unsigned long )((void *)0)) {
    {
#line 2055
    err = (WebPEncodingError )3;
#line 2056
    WebPEncodingSetError(picture, err);
    }
#line 2057
    return (0);
  } else
#line 2054
  if ((unsigned long )picture->argb == (unsigned long )((void *)0)) {
    {
#line 2055
    err = (WebPEncodingError )3;
#line 2056
    WebPEncodingSetError(picture, err);
    }
#line 2057
    return (0);
  }
#line 2060
  width = picture->width;
#line 2061
  height = picture->height;
#line 2064
  if ((unsigned int )config->image_hint == 3U) {
#line 2064
    tmp = width * height;
  } else {
#line 2064
    tmp = (width * height) * 2;
  }
  {
#line 2064
  initial_size = tmp;
#line 2066
  __cil_tmp12 = VP8LBitWriterInit(& bw, (size_t )initial_size);
  }
#line 2066
  if (! __cil_tmp12) {
#line 2067
    err = (WebPEncodingError )1;
#line 2068
    goto Error;
  }
  {
#line 2071
  __cil_tmp13 = WebPReportProgress(picture, 1, & percent);
  }
#line 2071
  if (! __cil_tmp13) {
    UserAbort: 
#line 2073
    err = (WebPEncodingError )10;
#line 2074
    goto Error;
  }
#line 2077
  if ((unsigned long )picture->stats != (unsigned long )((void *)0)) {
    {
#line 2078
    stats = picture->stats;
#line 2079
    memset((void *)stats, 0, sizeof(*stats));
#line 2080
    stats->PSNR[0] = 99.f;
#line 2081
    stats->PSNR[1] = 99.f;
#line 2082
    stats->PSNR[2] = 99.f;
#line 2083
    stats->PSNR[3] = 99.f;
#line 2084
    stats->PSNR[4] = 99.f;
    }
  }
  {
#line 2088
  __cil_tmp15 = WriteImageSize(picture, & bw);
  }
#line 2088
  if (! __cil_tmp15) {
#line 2089
    err = (WebPEncodingError )1;
#line 2090
    goto Error;
  }
  {
#line 2093
  has_alpha = WebPPictureHasTransparency(picture);
#line 2095
  __cil_tmp17 = WriteRealAlphaAndVersion(& bw, has_alpha);
  }
#line 2095
  if (! __cil_tmp17) {
#line 2096
    err = (WebPEncodingError )1;
#line 2097
    goto Error;
  }
  {
#line 2100
  __cil_tmp18 = WebPReportProgress(picture, 5, & percent);
  }
#line 2100
  if (! __cil_tmp18) {
#line 2100
    goto UserAbort;
  }
  {
#line 2103
  err = VP8LEncodeStream(config, picture, & bw, 1);
  }
#line 2104
  if ((unsigned int )err != 0U) {
#line 2104
    goto Error;
  }
  {
#line 2106
  __cil_tmp20 = WebPReportProgress(picture, 90, & percent);
  }
#line 2106
  if (! __cil_tmp20) {
#line 2106
    goto UserAbort;
  }
  {
#line 2109
  err = WriteImage(picture, & bw, & coded_size);
  }
#line 2110
  if ((unsigned int )err != 0U) {
#line 2110
    goto Error;
  }
  {
#line 2112
  __cil_tmp22 = WebPReportProgress(picture, 100, & percent);
  }
#line 2112
  if (! __cil_tmp22) {
#line 2112
    goto UserAbort;
  }
#line 2116
  if ((unsigned long )picture->stats != (unsigned long )((void *)0)) {
#line 2117
    (picture->stats)->coded_size += (int )coded_size;
#line 2118
    (picture->stats)->lossless_size = (int )coded_size;
  }
#line 2122
  if ((unsigned long )picture->extra_info != (unsigned long )((void *)0)) {
    {
#line 2123
    mb_w = (width + 15) >> 4;
#line 2124
    mb_h = (height + 15) >> 4;
#line 2125
    memset((void *)picture->extra_info, 0, (unsigned long )(mb_w * mb_h) * sizeof(*(picture->extra_info)));
    }
  }
  Error: 
#line 2129
  if (bw.error_) {
#line 2129
    err = (WebPEncodingError )1;
  }
  {
#line 2130
  VP8LBitWriterWipeOut(& bw);
  }
#line 2131
  if ((unsigned int )err != 0U) {
    {
#line 2132
    WebPEncodingSetError(picture, err);
    }
#line 2133
    return (0);
  }
#line 2135
  return (1);
}
}
#line 21 "/root/patron-new/new_3/src/enc/tree_enc.c"
uint8_t VP8CoeffsProba0[4][8][3][11]  = { { { {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )253,            (uint8_t )136,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )228,            (uint8_t )219,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )189,            (uint8_t )129,            (uint8_t )242,            (uint8_t )255, 
                    (uint8_t )227,            (uint8_t )213,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )106,            (uint8_t )126,            (uint8_t )227,            (uint8_t )252, 
                    (uint8_t )214,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )98,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )226,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )181,            (uint8_t )133,            (uint8_t )238,            (uint8_t )254, 
                    (uint8_t )221,            (uint8_t )234,            (uint8_t )255,            (uint8_t )154, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )78,            (uint8_t )134,            (uint8_t )202,            (uint8_t )247, 
                    (uint8_t )198,            (uint8_t )180,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )185,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )243,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )184,            (uint8_t )150,            (uint8_t )247,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )224,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )77,            (uint8_t )110,            (uint8_t )216,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )230,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )101,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )241,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )170,            (uint8_t )139,            (uint8_t )241,            (uint8_t )252, 
                    (uint8_t )236,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )37,            (uint8_t )116,            (uint8_t )196,            (uint8_t )243, 
                    (uint8_t )228,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )204,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )245,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )207,            (uint8_t )160,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )238,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )102,            (uint8_t )103,            (uint8_t )231,            (uint8_t )255, 
                    (uint8_t )211,            (uint8_t )171,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )152,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )240,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )177,            (uint8_t )135,            (uint8_t )243,            (uint8_t )255, 
                    (uint8_t )234,            (uint8_t )225,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )80,            (uint8_t )129,            (uint8_t )211,            (uint8_t )255, 
                    (uint8_t )194,            (uint8_t )224,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )246,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )198,            (uint8_t )35,            (uint8_t )237,            (uint8_t )223, 
                    (uint8_t )193,            (uint8_t )187,            (uint8_t )162,            (uint8_t )160, 
                    (uint8_t )145,            (uint8_t )155,            (uint8_t )62}, 
       {            (uint8_t )131,            (uint8_t )45,            (uint8_t )198,            (uint8_t )221, 
                    (uint8_t )172,            (uint8_t )176,            (uint8_t )220,            (uint8_t )157, 
                    (uint8_t )252,            (uint8_t )221,            (uint8_t )1}, 
       {            (uint8_t )68,            (uint8_t )47,            (uint8_t )146,            (uint8_t )208, 
                    (uint8_t )149,            (uint8_t )167,            (uint8_t )221,            (uint8_t )162, 
                    (uint8_t )255,            (uint8_t )223,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )149,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )221,            (uint8_t )224,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )184,            (uint8_t )141,            (uint8_t )234,            (uint8_t )253, 
                    (uint8_t )222,            (uint8_t )220,            (uint8_t )255,            (uint8_t )199, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )81,            (uint8_t )99,            (uint8_t )181,            (uint8_t )242, 
                    (uint8_t )176,            (uint8_t )190,            (uint8_t )249,            (uint8_t )202, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )129,            (uint8_t )232,            (uint8_t )253, 
                    (uint8_t )214,            (uint8_t )197,            (uint8_t )242,            (uint8_t )196, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )99,            (uint8_t )121,            (uint8_t )210,            (uint8_t )250, 
                    (uint8_t )201,            (uint8_t )198,            (uint8_t )255,            (uint8_t )202, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )23,            (uint8_t )91,            (uint8_t )163,            (uint8_t )242, 
                    (uint8_t )170,            (uint8_t )187,            (uint8_t )247,            (uint8_t )210, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )200,            (uint8_t )246,            (uint8_t )255, 
                    (uint8_t )234,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )109,            (uint8_t )178,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )231,            (uint8_t )245,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )44,            (uint8_t )130,            (uint8_t )201,            (uint8_t )253, 
                    (uint8_t )205,            (uint8_t )192,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )132,            (uint8_t )239,            (uint8_t )251, 
                    (uint8_t )219,            (uint8_t )209,            (uint8_t )255,            (uint8_t )165, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )94,            (uint8_t )136,            (uint8_t )225,            (uint8_t )251, 
                    (uint8_t )218,            (uint8_t )190,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )22,            (uint8_t )100,            (uint8_t )174,            (uint8_t )245, 
                    (uint8_t )186,            (uint8_t )161,            (uint8_t )255,            (uint8_t )199, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )182,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )232,            (uint8_t )235,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )124,            (uint8_t )143,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )227,            (uint8_t )234,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )35,            (uint8_t )77,            (uint8_t )181,            (uint8_t )251, 
                    (uint8_t )193,            (uint8_t )211,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )157,            (uint8_t )247,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )231,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )121,            (uint8_t )141,            (uint8_t )235,            (uint8_t )255, 
                    (uint8_t )225,            (uint8_t )227,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )45,            (uint8_t )99,            (uint8_t )188,            (uint8_t )251, 
                    (uint8_t )195,            (uint8_t )217,            (uint8_t )255,            (uint8_t )224, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )213,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )203,            (uint8_t )1,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )137,            (uint8_t )1,            (uint8_t )177,            (uint8_t )255, 
                    (uint8_t )224,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )253,            (uint8_t )9,            (uint8_t )248,            (uint8_t )251, 
                    (uint8_t )207,            (uint8_t )208,            (uint8_t )255,            (uint8_t )192, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )175,            (uint8_t )13,            (uint8_t )224,            (uint8_t )243, 
                    (uint8_t )193,            (uint8_t )185,            (uint8_t )249,            (uint8_t )198, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )73,            (uint8_t )17,            (uint8_t )171,            (uint8_t )221, 
                    (uint8_t )161,            (uint8_t )179,            (uint8_t )236,            (uint8_t )167, 
                    (uint8_t )255,            (uint8_t )234,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )95,            (uint8_t )247,            (uint8_t )253, 
                    (uint8_t )212,            (uint8_t )183,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )239,            (uint8_t )90,            (uint8_t )244,            (uint8_t )250, 
                    (uint8_t )211,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )155,            (uint8_t )77,            (uint8_t )195,            (uint8_t )248, 
                    (uint8_t )188,            (uint8_t )195,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )24,            (uint8_t )239,            (uint8_t )251, 
                    (uint8_t )218,            (uint8_t )219,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )201,            (uint8_t )51,            (uint8_t )219,            (uint8_t )255, 
                    (uint8_t )196,            (uint8_t )186,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )69,            (uint8_t )46,            (uint8_t )190,            (uint8_t )239, 
                    (uint8_t )201,            (uint8_t )218,            (uint8_t )255,            (uint8_t )228, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )191,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )223,            (uint8_t )165,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )213,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )141,            (uint8_t )124,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )16,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )190,            (uint8_t )36,            (uint8_t )230,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )149,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )226,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )247,            (uint8_t )192,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )240,            (uint8_t )128,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )134,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )213,            (uint8_t )62,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )55,            (uint8_t )93,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )202,            (uint8_t )24,            (uint8_t )213,            (uint8_t )235, 
                    (uint8_t )186,            (uint8_t )191,            (uint8_t )220,            (uint8_t )160, 
                    (uint8_t )240,            (uint8_t )175,            (uint8_t )255}, 
       {            (uint8_t )126,            (uint8_t )38,            (uint8_t )182,            (uint8_t )232, 
                    (uint8_t )169,            (uint8_t )184,            (uint8_t )228,            (uint8_t )174, 
                    (uint8_t )255,            (uint8_t )187,            (uint8_t )128}, 
       {            (uint8_t )61,            (uint8_t )46,            (uint8_t )138,            (uint8_t )219, 
                    (uint8_t )151,            (uint8_t )178,            (uint8_t )240,            (uint8_t )170, 
                    (uint8_t )255,            (uint8_t )216,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )112,            (uint8_t )230,            (uint8_t )250, 
                    (uint8_t )199,            (uint8_t )191,            (uint8_t )247,            (uint8_t )159, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )166,            (uint8_t )109,            (uint8_t )228,            (uint8_t )252, 
                    (uint8_t )211,            (uint8_t )215,            (uint8_t )255,            (uint8_t )174, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )39,            (uint8_t )77,            (uint8_t )162,            (uint8_t )232, 
                    (uint8_t )172,            (uint8_t )180,            (uint8_t )245,            (uint8_t )178, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )52,            (uint8_t )220,            (uint8_t )246, 
                    (uint8_t )198,            (uint8_t )199,            (uint8_t )249,            (uint8_t )220, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )124,            (uint8_t )74,            (uint8_t )191,            (uint8_t )243, 
                    (uint8_t )183,            (uint8_t )193,            (uint8_t )250,            (uint8_t )221, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )24,            (uint8_t )71,            (uint8_t )130,            (uint8_t )219, 
                    (uint8_t )154,            (uint8_t )170,            (uint8_t )243,            (uint8_t )182, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )182,            (uint8_t )225,            (uint8_t )249, 
                    (uint8_t )219,            (uint8_t )240,            (uint8_t )255,            (uint8_t )224, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )149,            (uint8_t )150,            (uint8_t )226,            (uint8_t )252, 
                    (uint8_t )216,            (uint8_t )205,            (uint8_t )255,            (uint8_t )171, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )28,            (uint8_t )108,            (uint8_t )170,            (uint8_t )242, 
                    (uint8_t )183,            (uint8_t )194,            (uint8_t )254,            (uint8_t )223, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )81,            (uint8_t )230,            (uint8_t )252, 
                    (uint8_t )204,            (uint8_t )203,            (uint8_t )255,            (uint8_t )192, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )123,            (uint8_t )102,            (uint8_t )209,            (uint8_t )247, 
                    (uint8_t )188,            (uint8_t )196,            (uint8_t )255,            (uint8_t )233, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )20,            (uint8_t )95,            (uint8_t )153,            (uint8_t )243, 
                    (uint8_t )164,            (uint8_t )173,            (uint8_t )255,            (uint8_t )203, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )222,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )216,            (uint8_t )213,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )168,            (uint8_t )175,            (uint8_t )246,            (uint8_t )252, 
                    (uint8_t )235,            (uint8_t )205,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )47,            (uint8_t )116,            (uint8_t )215,            (uint8_t )255, 
                    (uint8_t )211,            (uint8_t )212,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )121,            (uint8_t )236,            (uint8_t )253, 
                    (uint8_t )212,            (uint8_t )214,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )141,            (uint8_t )84,            (uint8_t )213,            (uint8_t )252, 
                    (uint8_t )201,            (uint8_t )202,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )42,            (uint8_t )80,            (uint8_t )160,            (uint8_t )240, 
                    (uint8_t )162,            (uint8_t )185,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )244,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )238,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}};
#line 156 "/root/patron-new/new_3/src/enc/tree_enc.c"
void VP8DefaultProbas(VP8Encoder *enc ) 
{ 
  VP8EncProba *probas ;

  {
  {
#line 157
  probas = & enc->proba_;
#line 158
  probas->use_skip_proba_ = 0;
#line 159
  memset((void *)(probas->segments_), 255, sizeof(probas->segments_));
#line 160
  memcpy((void *)(probas->coeffs_), (void const   *)(VP8CoeffsProba0), sizeof(VP8CoeffsProba0));
#line 163
  probas->dirty_ = 1;
  }
#line 165
  return;
}
}
#line 167 "/root/patron-new/new_3/src/enc/tree_enc.c"
static uint8_t kBModesProba[10][10][9]  = 
#line 167
  { { {          (uint8_t )231,          (uint8_t )120,          (uint8_t )48,          (uint8_t )89, 
                (uint8_t )115,          (uint8_t )113,          (uint8_t )120,          (uint8_t )152, 
                (uint8_t )112}, 
     {          (uint8_t )152,          (uint8_t )179,          (uint8_t )64,          (uint8_t )126, 
                (uint8_t )170,          (uint8_t )118,          (uint8_t )46,          (uint8_t )70, 
                (uint8_t )95}, 
     {          (uint8_t )175,          (uint8_t )69,          (uint8_t )143,          (uint8_t )80, 
                (uint8_t )85,          (uint8_t )82,          (uint8_t )72,          (uint8_t )155, 
                (uint8_t )103}, 
     {          (uint8_t )56,          (uint8_t )58,          (uint8_t )10,          (uint8_t )171, 
                (uint8_t )218,          (uint8_t )189,          (uint8_t )17,          (uint8_t )13, 
                (uint8_t )152}, 
     {          (uint8_t )114,          (uint8_t )26,          (uint8_t )17,          (uint8_t )163, 
                (uint8_t )44,          (uint8_t )195,          (uint8_t )21,          (uint8_t )10, 
                (uint8_t )173}, 
     {          (uint8_t )121,          (uint8_t )24,          (uint8_t )80,          (uint8_t )195, 
                (uint8_t )26,          (uint8_t )62,          (uint8_t )44,          (uint8_t )64, 
                (uint8_t )85}, 
     {          (uint8_t )144,          (uint8_t )71,          (uint8_t )10,          (uint8_t )38, 
                (uint8_t )171,          (uint8_t )213,          (uint8_t )144,          (uint8_t )34, 
                (uint8_t )26}, 
     {          (uint8_t )170,          (uint8_t )46,          (uint8_t )55,          (uint8_t )19, 
                (uint8_t )136,          (uint8_t )160,          (uint8_t )33,          (uint8_t )206, 
                (uint8_t )71}, 
     {          (uint8_t )63,          (uint8_t )20,          (uint8_t )8,          (uint8_t )114, 
                (uint8_t )114,          (uint8_t )208,          (uint8_t )12,          (uint8_t )9, 
                (uint8_t )226}, 
     {          (uint8_t )81,          (uint8_t )40,          (uint8_t )11,          (uint8_t )96, 
                (uint8_t )182,          (uint8_t )84,          (uint8_t )29,          (uint8_t )16, 
                (uint8_t )36}}, 
   { {          (uint8_t )134,          (uint8_t )183,          (uint8_t )89,          (uint8_t )137, 
                (uint8_t )98,          (uint8_t )101,          (uint8_t )106,          (uint8_t )165, 
                (uint8_t )148}, 
     {          (uint8_t )72,          (uint8_t )187,          (uint8_t )100,          (uint8_t )130, 
                (uint8_t )157,          (uint8_t )111,          (uint8_t )32,          (uint8_t )75, 
                (uint8_t )80}, 
     {          (uint8_t )66,          (uint8_t )102,          (uint8_t )167,          (uint8_t )99, 
                (uint8_t )74,          (uint8_t )62,          (uint8_t )40,          (uint8_t )234, 
                (uint8_t )128}, 
     {          (uint8_t )41,          (uint8_t )53,          (uint8_t )9,          (uint8_t )178, 
                (uint8_t )241,          (uint8_t )141,          (uint8_t )26,          (uint8_t )8, 
                (uint8_t )107}, 
     {          (uint8_t )74,          (uint8_t )43,          (uint8_t )26,          (uint8_t )146, 
                (uint8_t )73,          (uint8_t )166,          (uint8_t )49,          (uint8_t )23, 
                (uint8_t )157}, 
     {          (uint8_t )65,          (uint8_t )38,          (uint8_t )105,          (uint8_t )160, 
                (uint8_t )51,          (uint8_t )52,          (uint8_t )31,          (uint8_t )115, 
                (uint8_t )128}, 
     {          (uint8_t )104,          (uint8_t )79,          (uint8_t )12,          (uint8_t )27, 
                (uint8_t )217,          (uint8_t )255,          (uint8_t )87,          (uint8_t )17, 
                (uint8_t )7}, 
     {          (uint8_t )87,          (uint8_t )68,          (uint8_t )71,          (uint8_t )44, 
                (uint8_t )114,          (uint8_t )51,          (uint8_t )15,          (uint8_t )186, 
                (uint8_t )23}, 
     {          (uint8_t )47,          (uint8_t )41,          (uint8_t )14,          (uint8_t )110, 
                (uint8_t )182,          (uint8_t )183,          (uint8_t )21,          (uint8_t )17, 
                (uint8_t )194}, 
     {          (uint8_t )66,          (uint8_t )45,          (uint8_t )25,          (uint8_t )102, 
                (uint8_t )197,          (uint8_t )189,          (uint8_t )23,          (uint8_t )18, 
                (uint8_t )22}}, 
   { {          (uint8_t )88,          (uint8_t )88,          (uint8_t )147,          (uint8_t )150, 
                (uint8_t )42,          (uint8_t )46,          (uint8_t )45,          (uint8_t )196, 
                (uint8_t )205}, 
     {          (uint8_t )43,          (uint8_t )97,          (uint8_t )183,          (uint8_t )117, 
                (uint8_t )85,          (uint8_t )38,          (uint8_t )35,          (uint8_t )179, 
                (uint8_t )61}, 
     {          (uint8_t )39,          (uint8_t )53,          (uint8_t )200,          (uint8_t )87, 
                (uint8_t )26,          (uint8_t )21,          (uint8_t )43,          (uint8_t )232, 
                (uint8_t )171}, 
     {          (uint8_t )56,          (uint8_t )34,          (uint8_t )51,          (uint8_t )104, 
                (uint8_t )114,          (uint8_t )102,          (uint8_t )29,          (uint8_t )93, 
                (uint8_t )77}, 
     {          (uint8_t )39,          (uint8_t )28,          (uint8_t )85,          (uint8_t )171, 
                (uint8_t )58,          (uint8_t )165,          (uint8_t )90,          (uint8_t )98, 
                (uint8_t )64}, 
     {          (uint8_t )34,          (uint8_t )22,          (uint8_t )116,          (uint8_t )206, 
                (uint8_t )23,          (uint8_t )34,          (uint8_t )43,          (uint8_t )166, 
                (uint8_t )73}, 
     {          (uint8_t )107,          (uint8_t )54,          (uint8_t )32,          (uint8_t )26, 
                (uint8_t )51,          (uint8_t )1,          (uint8_t )81,          (uint8_t )43, 
                (uint8_t )31}, 
     {          (uint8_t )68,          (uint8_t )25,          (uint8_t )106,          (uint8_t )22, 
                (uint8_t )64,          (uint8_t )171,          (uint8_t )36,          (uint8_t )225, 
                (uint8_t )114}, 
     {          (uint8_t )34,          (uint8_t )19,          (uint8_t )21,          (uint8_t )102, 
                (uint8_t )132,          (uint8_t )188,          (uint8_t )16,          (uint8_t )76, 
                (uint8_t )124}, 
     {          (uint8_t )62,          (uint8_t )18,          (uint8_t )78,          (uint8_t )95, 
                (uint8_t )85,          (uint8_t )57,          (uint8_t )50,          (uint8_t )48, 
                (uint8_t )51}}, 
   { {          (uint8_t )193,          (uint8_t )101,          (uint8_t )35,          (uint8_t )159, 
                (uint8_t )215,          (uint8_t )111,          (uint8_t )89,          (uint8_t )46, 
                (uint8_t )111}, 
     {          (uint8_t )60,          (uint8_t )148,          (uint8_t )31,          (uint8_t )172, 
                (uint8_t )219,          (uint8_t )228,          (uint8_t )21,          (uint8_t )18, 
                (uint8_t )111}, 
     {          (uint8_t )112,          (uint8_t )113,          (uint8_t )77,          (uint8_t )85, 
                (uint8_t )179,          (uint8_t )255,          (uint8_t )38,          (uint8_t )120, 
                (uint8_t )114}, 
     {          (uint8_t )40,          (uint8_t )42,          (uint8_t )1,          (uint8_t )196, 
                (uint8_t )245,          (uint8_t )209,          (uint8_t )10,          (uint8_t )25, 
                (uint8_t )109}, 
     {          (uint8_t )88,          (uint8_t )43,          (uint8_t )29,          (uint8_t )140, 
                (uint8_t )166,          (uint8_t )213,          (uint8_t )37,          (uint8_t )43, 
                (uint8_t )154}, 
     {          (uint8_t )61,          (uint8_t )63,          (uint8_t )30,          (uint8_t )155, 
                (uint8_t )67,          (uint8_t )45,          (uint8_t )68,          (uint8_t )1, 
                (uint8_t )209}, 
     {          (uint8_t )100,          (uint8_t )80,          (uint8_t )8,          (uint8_t )43, 
                (uint8_t )154,          (uint8_t )1,          (uint8_t )51,          (uint8_t )26, 
                (uint8_t )71}, 
     {          (uint8_t )142,          (uint8_t )78,          (uint8_t )78,          (uint8_t )16, 
                (uint8_t )255,          (uint8_t )128,          (uint8_t )34,          (uint8_t )197, 
                (uint8_t )171}, 
     {          (uint8_t )41,          (uint8_t )40,          (uint8_t )5,          (uint8_t )102, 
                (uint8_t )211,          (uint8_t )183,          (uint8_t )4,          (uint8_t )1, 
                (uint8_t )221}, 
     {          (uint8_t )51,          (uint8_t )50,          (uint8_t )17,          (uint8_t )168, 
                (uint8_t )209,          (uint8_t )192,          (uint8_t )23,          (uint8_t )25, 
                (uint8_t )82}}, 
   { {          (uint8_t )138,          (uint8_t )31,          (uint8_t )36,          (uint8_t )171, 
                (uint8_t )27,          (uint8_t )166,          (uint8_t )38,          (uint8_t )44, 
                (uint8_t )229}, 
     {          (uint8_t )67,          (uint8_t )87,          (uint8_t )58,          (uint8_t )169, 
                (uint8_t )82,          (uint8_t )115,          (uint8_t )26,          (uint8_t )59, 
                (uint8_t )179}, 
     {          (uint8_t )63,          (uint8_t )59,          (uint8_t )90,          (uint8_t )180, 
                (uint8_t )59,          (uint8_t )166,          (uint8_t )93,          (uint8_t )73, 
                (uint8_t )154}, 
     {          (uint8_t )40,          (uint8_t )40,          (uint8_t )21,          (uint8_t )116, 
                (uint8_t )143,          (uint8_t )209,          (uint8_t )34,          (uint8_t )39, 
                (uint8_t )175}, 
     {          (uint8_t )47,          (uint8_t )15,          (uint8_t )16,          (uint8_t )183, 
                (uint8_t )34,          (uint8_t )223,          (uint8_t )49,          (uint8_t )45, 
                (uint8_t )183}, 
     {          (uint8_t )46,          (uint8_t )17,          (uint8_t )33,          (uint8_t )183, 
                (uint8_t )6,          (uint8_t )98,          (uint8_t )15,          (uint8_t )32, 
                (uint8_t )183}, 
     {          (uint8_t )57,          (uint8_t )46,          (uint8_t )22,          (uint8_t )24, 
                (uint8_t )128,          (uint8_t )1,          (uint8_t )54,          (uint8_t )17, 
                (uint8_t )37}, 
     {          (uint8_t )65,          (uint8_t )32,          (uint8_t )73,          (uint8_t )115, 
                (uint8_t )28,          (uint8_t )128,          (uint8_t )23,          (uint8_t )128, 
                (uint8_t )205}, 
     {          (uint8_t )40,          (uint8_t )3,          (uint8_t )9,          (uint8_t )115, 
                (uint8_t )51,          (uint8_t )192,          (uint8_t )18,          (uint8_t )6, 
                (uint8_t )223}, 
     {          (uint8_t )87,          (uint8_t )37,          (uint8_t )9,          (uint8_t )115, 
                (uint8_t )59,          (uint8_t )77,          (uint8_t )64,          (uint8_t )21, 
                (uint8_t )47}}, 
   { {          (uint8_t )104,          (uint8_t )55,          (uint8_t )44,          (uint8_t )218, 
                (uint8_t )9,          (uint8_t )54,          (uint8_t )53,          (uint8_t )130, 
                (uint8_t )226}, 
     {          (uint8_t )64,          (uint8_t )90,          (uint8_t )70,          (uint8_t )205, 
                (uint8_t )40,          (uint8_t )41,          (uint8_t )23,          (uint8_t )26, 
                (uint8_t )57}, 
     {          (uint8_t )54,          (uint8_t )57,          (uint8_t )112,          (uint8_t )184, 
                (uint8_t )5,          (uint8_t )41,          (uint8_t )38,          (uint8_t )166, 
                (uint8_t )213}, 
     {          (uint8_t )30,          (uint8_t )34,          (uint8_t )26,          (uint8_t )133, 
                (uint8_t )152,          (uint8_t )116,          (uint8_t )10,          (uint8_t )32, 
                (uint8_t )134}, 
     {          (uint8_t )39,          (uint8_t )19,          (uint8_t )53,          (uint8_t )221, 
                (uint8_t )26,          (uint8_t )114,          (uint8_t )32,          (uint8_t )73, 
                (uint8_t )255}, 
     {          (uint8_t )31,          (uint8_t )9,          (uint8_t )65,          (uint8_t )234, 
                (uint8_t )2,          (uint8_t )15,          (uint8_t )1,          (uint8_t )118, 
                (uint8_t )73}, 
     {          (uint8_t )75,          (uint8_t )32,          (uint8_t )12,          (uint8_t )51, 
                (uint8_t )192,          (uint8_t )255,          (uint8_t )160,          (uint8_t )43, 
                (uint8_t )51}, 
     {          (uint8_t )88,          (uint8_t )31,          (uint8_t )35,          (uint8_t )67, 
                (uint8_t )102,          (uint8_t )85,          (uint8_t )55,          (uint8_t )186, 
                (uint8_t )85}, 
     {          (uint8_t )56,          (uint8_t )21,          (uint8_t )23,          (uint8_t )111, 
                (uint8_t )59,          (uint8_t )205,          (uint8_t )45,          (uint8_t )37, 
                (uint8_t )192}, 
     {          (uint8_t )55,          (uint8_t )38,          (uint8_t )70,          (uint8_t )124, 
                (uint8_t )73,          (uint8_t )102,          (uint8_t )1,          (uint8_t )34, 
                (uint8_t )98}}, 
   { {          (uint8_t )125,          (uint8_t )98,          (uint8_t )42,          (uint8_t )88, 
                (uint8_t )104,          (uint8_t )85,          (uint8_t )117,          (uint8_t )175, 
                (uint8_t )82}, 
     {          (uint8_t )95,          (uint8_t )84,          (uint8_t )53,          (uint8_t )89, 
                (uint8_t )128,          (uint8_t )100,          (uint8_t )113,          (uint8_t )101, 
                (uint8_t )45}, 
     {          (uint8_t )75,          (uint8_t )79,          (uint8_t )123,          (uint8_t )47, 
                (uint8_t )51,          (uint8_t )128,          (uint8_t )81,          (uint8_t )171, 
                (uint8_t )1}, 
     {          (uint8_t )57,          (uint8_t )17,          (uint8_t )5,          (uint8_t )71, 
                (uint8_t )102,          (uint8_t )57,          (uint8_t )53,          (uint8_t )41, 
                (uint8_t )49}, 
     {          (uint8_t )38,          (uint8_t )33,          (uint8_t )13,          (uint8_t )121, 
                (uint8_t )57,          (uint8_t )73,          (uint8_t )26,          (uint8_t )1, 
                (uint8_t )85}, 
     {          (uint8_t )41,          (uint8_t )10,          (uint8_t )67,          (uint8_t )138, 
                (uint8_t )77,          (uint8_t )110,          (uint8_t )90,          (uint8_t )47, 
                (uint8_t )114}, 
     {          (uint8_t )115,          (uint8_t )21,          (uint8_t )2,          (uint8_t )10, 
                (uint8_t )102,          (uint8_t )255,          (uint8_t )166,          (uint8_t )23, 
                (uint8_t )6}, 
     {          (uint8_t )101,          (uint8_t )29,          (uint8_t )16,          (uint8_t )10, 
                (uint8_t )85,          (uint8_t )128,          (uint8_t )101,          (uint8_t )196, 
                (uint8_t )26}, 
     {          (uint8_t )57,          (uint8_t )18,          (uint8_t )10,          (uint8_t )102, 
                (uint8_t )102,          (uint8_t )213,          (uint8_t )34,          (uint8_t )20, 
                (uint8_t )43}, 
     {          (uint8_t )117,          (uint8_t )20,          (uint8_t )15,          (uint8_t )36, 
                (uint8_t )163,          (uint8_t )128,          (uint8_t )68,          (uint8_t )1, 
                (uint8_t )26}}, 
   { {          (uint8_t )102,          (uint8_t )61,          (uint8_t )71,          (uint8_t )37, 
                (uint8_t )34,          (uint8_t )53,          (uint8_t )31,          (uint8_t )243, 
                (uint8_t )192}, 
     {          (uint8_t )69,          (uint8_t )60,          (uint8_t )71,          (uint8_t )38, 
                (uint8_t )73,          (uint8_t )119,          (uint8_t )28,          (uint8_t )222, 
                (uint8_t )37}, 
     {          (uint8_t )68,          (uint8_t )45,          (uint8_t )128,          (uint8_t )34, 
                (uint8_t )1,          (uint8_t )47,          (uint8_t )11,          (uint8_t )245, 
                (uint8_t )171}, 
     {          (uint8_t )62,          (uint8_t )17,          (uint8_t )19,          (uint8_t )70, 
                (uint8_t )146,          (uint8_t )85,          (uint8_t )55,          (uint8_t )62, 
                (uint8_t )70}, 
     {          (uint8_t )37,          (uint8_t )43,          (uint8_t )37,          (uint8_t )154, 
                (uint8_t )100,          (uint8_t )163,          (uint8_t )85,          (uint8_t )160, 
                (uint8_t )1}, 
     {          (uint8_t )63,          (uint8_t )9,          (uint8_t )92,          (uint8_t )136, 
                (uint8_t )28,          (uint8_t )64,          (uint8_t )32,          (uint8_t )201, 
                (uint8_t )85}, 
     {          (uint8_t )75,          (uint8_t )15,          (uint8_t )9,          (uint8_t )9, 
                (uint8_t )64,          (uint8_t )255,          (uint8_t )184,          (uint8_t )119, 
                (uint8_t )16}, 
     {          (uint8_t )86,          (uint8_t )6,          (uint8_t )28,          (uint8_t )5, 
                (uint8_t )64,          (uint8_t )255,          (uint8_t )25,          (uint8_t )248, 
                (uint8_t )1}, 
     {          (uint8_t )56,          (uint8_t )8,          (uint8_t )17,          (uint8_t )132, 
                (uint8_t )137,          (uint8_t )255,          (uint8_t )55,          (uint8_t )116, 
                (uint8_t )128}, 
     {          (uint8_t )58,          (uint8_t )15,          (uint8_t )20,          (uint8_t )82, 
                (uint8_t )135,          (uint8_t )57,          (uint8_t )26,          (uint8_t )121, 
                (uint8_t )40}}, 
   { {          (uint8_t )164,          (uint8_t )50,          (uint8_t )31,          (uint8_t )137, 
                (uint8_t )154,          (uint8_t )133,          (uint8_t )25,          (uint8_t )35, 
                (uint8_t )218}, 
     {          (uint8_t )51,          (uint8_t )103,          (uint8_t )44,          (uint8_t )131, 
                (uint8_t )131,          (uint8_t )123,          (uint8_t )31,          (uint8_t )6, 
                (uint8_t )158}, 
     {          (uint8_t )86,          (uint8_t )40,          (uint8_t )64,          (uint8_t )135, 
                (uint8_t )148,          (uint8_t )224,          (uint8_t )45,          (uint8_t )183, 
                (uint8_t )128}, 
     {          (uint8_t )22,          (uint8_t )26,          (uint8_t )17,          (uint8_t )131, 
                (uint8_t )240,          (uint8_t )154,          (uint8_t )14,          (uint8_t )1, 
                (uint8_t )209}, 
     {          (uint8_t )45,          (uint8_t )16,          (uint8_t )21,          (uint8_t )91, 
                (uint8_t )64,          (uint8_t )222,          (uint8_t )7,          (uint8_t )1, 
                (uint8_t )197}, 
     {          (uint8_t )56,          (uint8_t )21,          (uint8_t )39,          (uint8_t )155, 
                (uint8_t )60,          (uint8_t )138,          (uint8_t )23,          (uint8_t )102, 
                (uint8_t )213}, 
     {          (uint8_t )83,          (uint8_t )12,          (uint8_t )13,          (uint8_t )54, 
                (uint8_t )192,          (uint8_t )255,          (uint8_t )68,          (uint8_t )47, 
                (uint8_t )28}, 
     {          (uint8_t )85,          (uint8_t )26,          (uint8_t )85,          (uint8_t )85, 
                (uint8_t )128,          (uint8_t )128,          (uint8_t )32,          (uint8_t )146, 
                (uint8_t )171}, 
     {          (uint8_t )18,          (uint8_t )11,          (uint8_t )7,          (uint8_t )63, 
                (uint8_t )144,          (uint8_t )171,          (uint8_t )4,          (uint8_t )4, 
                (uint8_t )246}, 
     {          (uint8_t )35,          (uint8_t )27,          (uint8_t )10,          (uint8_t )146, 
                (uint8_t )174,          (uint8_t )171,          (uint8_t )12,          (uint8_t )26, 
                (uint8_t )128}}, 
   { {          (uint8_t )190,          (uint8_t )80,          (uint8_t )35,          (uint8_t )99, 
                (uint8_t )180,          (uint8_t )80,          (uint8_t )126,          (uint8_t )54, 
                (uint8_t )45}, 
     {          (uint8_t )85,          (uint8_t )126,          (uint8_t )47,          (uint8_t )87, 
                (uint8_t )176,          (uint8_t )51,          (uint8_t )41,          (uint8_t )20, 
                (uint8_t )32}, 
     {          (uint8_t )101,          (uint8_t )75,          (uint8_t )128,          (uint8_t )139, 
                (uint8_t )118,          (uint8_t )146,          (uint8_t )116,          (uint8_t )128, 
                (uint8_t )85}, 
     {          (uint8_t )56,          (uint8_t )41,          (uint8_t )15,          (uint8_t )176, 
                (uint8_t )236,          (uint8_t )85,          (uint8_t )37,          (uint8_t )9, 
                (uint8_t )62}, 
     {          (uint8_t )71,          (uint8_t )30,          (uint8_t )17,          (uint8_t )119, 
                (uint8_t )118,          (uint8_t )255,          (uint8_t )17,          (uint8_t )18, 
                (uint8_t )138}, 
     {          (uint8_t )101,          (uint8_t )38,          (uint8_t )60,          (uint8_t )138, 
                (uint8_t )55,          (uint8_t )70,          (uint8_t )43,          (uint8_t )26, 
                (uint8_t )142}, 
     {          (uint8_t )146,          (uint8_t )36,          (uint8_t )19,          (uint8_t )30, 
                (uint8_t )171,          (uint8_t )255,          (uint8_t )97,          (uint8_t )27, 
                (uint8_t )20}, 
     {          (uint8_t )138,          (uint8_t )45,          (uint8_t )61,          (uint8_t )62, 
                (uint8_t )219,          (uint8_t )1,          (uint8_t )81,          (uint8_t )188, 
                (uint8_t )64}, 
     {          (uint8_t )32,          (uint8_t )41,          (uint8_t )20,          (uint8_t )117, 
                (uint8_t )151,          (uint8_t )142,          (uint8_t )20,          (uint8_t )21, 
                (uint8_t )163}, 
     {          (uint8_t )112,          (uint8_t )19,          (uint8_t )12,          (uint8_t )61, 
                (uint8_t )195,          (uint8_t )128,          (uint8_t )48,          (uint8_t )4, 
                (uint8_t )24}}};
#line 270 "/root/patron-new/new_3/src/enc/tree_enc.c"
static int PutI4Mode(VP8BitWriter *bw , int mode , uint8_t *prob ) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 272
  __cil_tmp4 = VP8PutBit(bw, mode != 0, (int )*(prob + 0));
  }
#line 272
  if (__cil_tmp4) {
    {
#line 273
    __cil_tmp5 = VP8PutBit(bw, mode != 1, (int )*(prob + 1));
    }
#line 273
    if (__cil_tmp5) {
      {
#line 274
      __cil_tmp6 = VP8PutBit(bw, mode != 2, (int )*(prob + 2));
      }
#line 274
      if (__cil_tmp6) {
        {
#line 275
        __cil_tmp7 = VP8PutBit(bw, mode >= 6, (int )*(prob + 3));
        }
#line 275
        if (! __cil_tmp7) {
          {
#line 276
          __cil_tmp8 = VP8PutBit(bw, mode != 3, (int )*(prob + 4));
          }
#line 276
          if (__cil_tmp8) {
            {
#line 277
            VP8PutBit(bw, mode != 4, (int )*(prob + 5));
            }
          }
        } else {
          {
#line 280
          __cil_tmp9 = VP8PutBit(bw, mode != 6, (int )*(prob + 6));
          }
#line 280
          if (__cil_tmp9) {
            {
#line 281
            __cil_tmp10 = VP8PutBit(bw, mode != 7, (int )*(prob + 7));
            }
#line 281
            if (__cil_tmp10) {
              {
#line 282
              VP8PutBit(bw, mode != 8, (int )*(prob + 8));
              }
            }
          }
        }
      }
    }
  }
#line 289
  return (mode);
}
}
#line 292 "/root/patron-new/new_3/src/enc/tree_enc.c"
static void PutI16Mode(VP8BitWriter *bw , int mode ) 
{ 
  int __cil_tmp3 ;
  int tmp ;

  {
#line 293
  if (mode == 1) {
#line 293
    tmp = 1;
  } else
#line 293
  if (mode == 3) {
#line 293
    tmp = 1;
  } else {
#line 293
    tmp = 0;
  }
  {
#line 293
  __cil_tmp3 = VP8PutBit(bw, tmp, 156);
  }
#line 293
  if (__cil_tmp3) {
    {
#line 294
    VP8PutBit(bw, mode == 1, 128);
    }
  } else {
    {
#line 296
    VP8PutBit(bw, mode == 2, 163);
    }
  }
#line 299
  return;
}
}
#line 300 "/root/patron-new/new_3/src/enc/tree_enc.c"
static void PutUVMode(VP8BitWriter *bw , int uv_mode ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 301
  __cil_tmp3 = VP8PutBit(bw, uv_mode != 0, 142);
  }
#line 301
  if (__cil_tmp3) {
    {
#line 302
    __cil_tmp4 = VP8PutBit(bw, uv_mode != 2, 114);
    }
#line 302
    if (__cil_tmp4) {
      {
#line 303
      VP8PutBit(bw, uv_mode != 3, 183);
      }
    }
  }
#line 307
  return;
}
}
#line 308 "/root/patron-new/new_3/src/enc/tree_enc.c"
static void PutSegment(VP8BitWriter *bw , int s , uint8_t *p ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 309
  __cil_tmp4 = VP8PutBit(bw, s >= 2, (int )*(p + 0));
  }
#line 309
  if (__cil_tmp4) {
#line 309
    p ++;
  }
  {
#line 310
  VP8PutBit(bw, s & 1, (int )*(p + 1));
  }
#line 312
  return;
}
}
#line 313 "/root/patron-new/new_3/src/enc/tree_enc.c"
void VP8CodeIntraModes(VP8Encoder *enc ) 
{ 
  VP8BitWriter *bw ;
  VP8EncIterator it ;
  int __cil_tmp4 ;
  VP8MBInfo *mb ;
  uint8_t *preds ;
  int __cil_tmp7 ;
  int preds_w ;
  uint8_t *top_pred ;
  int x ;
  int y ;
  int left ;
  uint8_t *probas ;

  {
  {
#line 314
  bw = & enc->bw_;
#line 316
  VP8IteratorInit(enc, & it);
  }
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    mb = it.mb_;
#line 319
    preds = it.preds_;
#line 320
    if (enc->segment_hdr_.update_map_) {
      {
#line 321
      PutSegment(bw, (int )mb->segment_, enc->proba_.segments_);
      }
    }
#line 323
    if (enc->proba_.use_skip_proba_) {
      {
#line 324
      VP8PutBit(bw, (int )mb->skip_, (int )enc->proba_.skip_proba_);
      }
    }
    {
#line 326
    __cil_tmp7 = VP8PutBit(bw, (int )mb->type_ != 0, 145);
    }
#line 326
    if (__cil_tmp7) {
      {
#line 327
      PutI16Mode(bw, (int )*(preds + 0));
      }
    } else {
#line 329
      preds_w = enc->preds_w_;
#line 330
      top_pred = preds - preds_w;
#line 332
      y = 0;
      {
#line 332
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 332
        if (! (y < 4)) {
#line 332
          goto while_break___0;
        }
#line 333
        left = (int )*(preds + -1);
#line 334
        x = 0;
        {
#line 334
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 334
          if (! (x < 4)) {
#line 334
            goto while_break___1;
          }
          {
#line 335
          probas = kBModesProba[*(top_pred + x)][left];
#line 336
          left = PutI4Mode(bw, (int )*(preds + x), probas);
#line 334
          x ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: 
#line 338
        top_pred = preds;
#line 339
        preds += preds_w;
#line 332
        y ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    }
    {
#line 342
    PutUVMode(bw, (int )mb->uv_mode_);
    }
#line 317
    if (! __cil_tmp4) {
#line 317
      goto while_break;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 322
  return;
}
}
#line 350 "/root/patron-new/new_3/src/enc/tree_enc.c"
uint8_t VP8CoeffsUpdateProba[4][8][3][11]  = { { { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )176,            (uint8_t )246,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )223,            (uint8_t )241,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )244,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )246,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )239,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )248,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )217,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )225,            (uint8_t )252,            (uint8_t )241,            (uint8_t )253, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )250,            (uint8_t )241,            (uint8_t )250, 
                    (uint8_t )253,            (uint8_t )255,            (uint8_t )253,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )223,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )238,            (uint8_t )253,            (uint8_t )254,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )248,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )247,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )186,            (uint8_t )251,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )251,            (uint8_t )244,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )251,            (uint8_t )243,            (uint8_t )253, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )236,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )253,            (uint8_t )253,            (uint8_t )254, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )248,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )254,            (uint8_t )252,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )248,            (uint8_t )254,            (uint8_t )249,            (uint8_t )253, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )246,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )254,            (uint8_t )251,            (uint8_t )254, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )248,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )254,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )251,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )245,            (uint8_t )251,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )251,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )252,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}};
#line 485 "/root/patron-new/new_3/src/enc/tree_enc.c"
void VP8WriteProbas(VP8BitWriter *bw , VP8EncProba *probas ) 
{ 
  int t ;
  int b ;
  int c ;
  int p ;
  uint8_t p0 ;
  int update ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 487
  t = 0;
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;

#line 487
    if (! (t < 4)) {
#line 487
      goto while_break;
    }
#line 488
    b = 0;
    {
#line 488
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 488
      if (! (b < 8)) {
#line 488
        goto while_break___0;
      }
#line 489
      c = 0;
      {
#line 489
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 489
        if (! (c < 3)) {
#line 489
          goto while_break___1;
        }
#line 490
        p = 0;
        {
#line 490
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 490
          if (! (p < 11)) {
#line 490
            goto while_break___2;
          }
          {
#line 491
          p0 = probas->coeffs_[t][b][c][p];
#line 492
          update = (int )p0 != (int )VP8CoeffsProba0[t][b][c][p];
#line 493
          __cil_tmp9 = VP8PutBit(bw, update, (int )VP8CoeffsUpdateProba[t][b][c][p]);
          }
#line 493
          if (__cil_tmp9) {
            {
#line 494
            VP8PutBits(bw, (uint32_t )p0, 8);
            }
          }
#line 490
          p ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 489
        c ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 488
      b ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 487
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 500
  __cil_tmp10 = VP8PutBitUniform(bw, probas->use_skip_proba_);
  }
#line 500
  if (__cil_tmp10) {
    {
#line 501
    VP8PutBits(bw, (uint32_t )probas->skip_proba_, 8);
    }
  }
#line 504
  return;
}
}
#line 45 "/root/patron-new/new_3/src/enc/token_enc.c"
void VP8TBufferInit(VP8TBuffer *b , int page_size ) 
{ 
  int tmp ;

  {
#line 46
  b->tokens_ = (uint16_t *)((void *)0);
#line 47
  b->pages_ = (VP8Tokens *)((void *)0);
#line 48
  b->last_page_ = & b->pages_;
#line 49
  b->left_ = 0;
#line 50
  if (page_size < 8192) {
#line 50
    tmp = 8192;
  } else {
#line 50
    tmp = page_size;
  }
#line 50
  b->page_size_ = tmp;
#line 51
  b->error_ = 0;
#line 52
  return;
}
}
#line 54 "/root/patron-new/new_3/src/enc/token_enc.c"
void VP8TBufferClear(VP8TBuffer *b ) 
{ 
  VP8Tokens *p ;
  VP8Tokens *next ;

  {
#line 55
  if ((unsigned long )b != (unsigned long )((void *)0)) {
#line 56
    p = b->pages_;
    {
#line 57
    while (1) {
      while_continue: /* CIL Label */ ;

#line 57
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 57
        goto while_break;
      }
      {
#line 58
      next = p->next_;
#line 59
      WebPSafeFree((void *)p);
#line 60
      p = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 62
    VP8TBufferInit(b, b->page_size_);
    }
  }
#line 65
  return;
}
}
#line 66 "/root/patron-new/new_3/src/enc/token_enc.c"
static int TBufferNewPage(VP8TBuffer *b ) 
{ 
  VP8Tokens *page ;
  size_t size ;
  void *__cil_tmp4 ;

  {
#line 67
  page = (VP8Tokens *)((void *)0);
#line 68
  if (! b->error_) {
    {
#line 69
    size = sizeof(*page) + (unsigned long )b->page_size_ * sizeof(token_t );
#line 70
    __cil_tmp4 = WebPSafeMalloc((uint64_t )1ULL, size);
#line 70
    page = (VP8Tokens *)__cil_tmp4;
    }
  }
#line 72
  if ((unsigned long )page == (unsigned long )((void *)0)) {
#line 73
    b->error_ = 1;
#line 74
    return (0);
  }
#line 76
  page->next_ = (VP8Tokens *)((void *)0);
#line 78
  *(b->last_page_) = page;
#line 79
  b->last_page_ = & page->next_;
#line 80
  b->left_ = b->page_size_;
#line 81
  b->tokens_ = (token_t *)(page + 1);
#line 82
  return (1);
}
}
#line 90 "/root/patron-new/new_3/src/enc/token_enc.c"
__inline static uint32_t AddToken(VP8TBuffer *b , uint32_t bit , uint32_t proba_idx ,
                                  proba_t *stats ) 
{ 
  int __cil_tmp5 ;
  int slot ;

  {
  {
#line 95
  __cil_tmp5 = TBufferNewPage(b);
  }
#line 95
  if (b->left_ > 0) {
#line 96
    (b->left_) --;
#line 96
    slot = b->left_;
#line 97
    *(b->tokens_ + slot) = (uint16_t )((bit << 15) | proba_idx);
  } else
#line 95
  if (__cil_tmp5) {
#line 96
    (b->left_) --;
#line 96
    slot = b->left_;
#line 97
    *(b->tokens_ + slot) = (uint16_t )((bit << 15) | proba_idx);
  }
  {
#line 99
  VP8RecordStats((int )bit, stats);
  }
#line 100
  return (bit);
}
}
#line 103 "/root/patron-new/new_3/src/enc/token_enc.c"
__inline static void AddConstantToken(VP8TBuffer *b , uint32_t bit , uint32_t proba ) 
{ 
  int __cil_tmp4 ;
  int slot ;

  {
  {
#line 107
  __cil_tmp4 = TBufferNewPage(b);
  }
#line 107
  if (b->left_ > 0) {
#line 108
    (b->left_) --;
#line 108
    slot = b->left_;
#line 109
    *(b->tokens_ + slot) = (uint16_t )(((bit << 15) | (1U << 14)) | proba);
  } else
#line 107
  if (__cil_tmp4) {
#line 108
    (b->left_) --;
#line 108
    slot = b->left_;
#line 109
    *(b->tokens_ + slot) = (uint16_t )(((bit << 15) | (1U << 14)) | proba);
  }
#line 111
  return;
}
}
#line 113 "/root/patron-new/new_3/src/enc/token_enc.c"
int VP8RecordCoeffTokens(int ctx , struct VP8Residual *res , VP8TBuffer *tokens ) 
{ 
  int16_t *coeffs ;
  int coeff_type ;
  int last ;
  int n ;
  uint32_t base_id ;
  proba_t *s ;
  uint32_t __cil_tmp10 ;
  int c ;
  int __cil_tmp12 ;
  int sign ;
  uint32_t v ;
  int tmp ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  int mask ;
  uint8_t *tab ;
  uint32_t residue ;
  uint8_t *__cil_tmp25 ;
  uint32_t __cil_tmp26 ;

  {
  {
#line 115
  coeffs = res->coeffs;
#line 116
  coeff_type = res->coeff_type;
#line 117
  last = res->last;
#line 118
  n = res->first;
#line 119
  base_id = (uint32_t )(11 * (ctx + 3 * (n + 8 * coeff_type)));
#line 121
  s = (*(res->stats + n))[ctx];
#line 122
  __cil_tmp10 = AddToken(tokens, (uint32_t )(last >= 0), base_id, s + 0);
  }
#line 122
  if (! __cil_tmp10) {
#line 123
    return (0);
  }
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 126
    if (! (n < 16)) {
#line 126
      goto while_break;
    }
#line 127
    __cil_tmp12 = n;
#line 127
    n ++;
#line 127
    c = (int )*(coeffs + __cil_tmp12);
#line 128
    sign = c < 0;
#line 129
    if (sign) {
#line 129
      tmp = - c;
    } else {
#line 129
      tmp = c;
    }
    {
#line 129
    v = (uint32_t )tmp;
#line 130
    __cil_tmp16 = AddToken(tokens, (uint32_t )(v != 0U), base_id + 1U, s + 1);
    }
#line 130
    if (! __cil_tmp16) {
#line 131
      base_id = (uint32_t )(11 * (3 * ((int )VP8EncBands[n] + 8 * coeff_type)));
#line 132
      s = (*(res->stats + (int )VP8EncBands[n]))[0];
#line 133
      goto while_continue;
    }
    {
#line 135
    __cil_tmp17 = AddToken(tokens, (uint32_t )(v > 1U), base_id + 2U, s + 2);
    }
#line 135
    if (! __cil_tmp17) {
#line 136
      base_id = (uint32_t )(11 * (1 + 3 * ((int )VP8EncBands[n] + 8 * coeff_type)));
#line 137
      s = (*(res->stats + (int )VP8EncBands[n]))[1];
    } else {
      {
#line 139
      __cil_tmp18 = AddToken(tokens, (uint32_t )(v > 4U), base_id + 3U, s + 3);
      }
#line 139
      if (! __cil_tmp18) {
        {
#line 140
        __cil_tmp19 = AddToken(tokens, (uint32_t )(v != 2U), base_id + 4U, s + 4);
        }
#line 140
        if (__cil_tmp19) {
          {
#line 141
          AddToken(tokens, (uint32_t )(v == 4U), base_id + 5U, s + 5);
          }
        }
      } else {
        {
#line 143
        __cil_tmp20 = AddToken(tokens, (uint32_t )(v > 10U), base_id + 6U, s + 6);
        }
#line 143
        if (! __cil_tmp20) {
          {
#line 144
          __cil_tmp21 = AddToken(tokens, (uint32_t )(v > 6U), base_id + 7U, s + 7);
          }
#line 144
          if (! __cil_tmp21) {
            {
#line 145
            AddConstantToken(tokens, (uint32_t )(v == 6U), (uint32_t )159);
            }
          } else {
            {
#line 147
            AddConstantToken(tokens, (uint32_t )(v >= 9U), (uint32_t )165);
#line 148
            AddConstantToken(tokens, (uint32_t )(! (v & 1U)), (uint32_t )145);
            }
          }
        } else {
#line 153
          residue = v - 3U;
#line 154
          if (residue < (unsigned int )(8 << 1)) {
            {
#line 155
            AddToken(tokens, (uint32_t )0, base_id + 8U, s + 8);
#line 156
            AddToken(tokens, (uint32_t )0, base_id + 9U, s + 9);
#line 157
            residue -= 8U;
#line 158
            mask = 1 << 2;
#line 159
            tab = VP8Cat3;
            }
          } else
#line 160
          if (residue < (unsigned int )(8 << 2)) {
            {
#line 161
            AddToken(tokens, (uint32_t )0, base_id + 8U, s + 8);
#line 162
            AddToken(tokens, (uint32_t )1, base_id + 9U, s + 9);
#line 163
            residue -= (unsigned int )(8 << 1);
#line 164
            mask = 1 << 3;
#line 165
            tab = VP8Cat4;
            }
          } else
#line 166
          if (residue < (unsigned int )(8 << 3)) {
            {
#line 167
            AddToken(tokens, (uint32_t )1, base_id + 8U, s + 8);
#line 168
            AddToken(tokens, (uint32_t )0, base_id + 10U, s + 9);
#line 169
            residue -= (unsigned int )(8 << 2);
#line 170
            mask = 1 << 4;
#line 171
            tab = VP8Cat5;
            }
          } else {
            {
#line 173
            AddToken(tokens, (uint32_t )1, base_id + 8U, s + 8);
#line 174
            AddToken(tokens, (uint32_t )1, base_id + 10U, s + 9);
#line 175
            residue -= (unsigned int )(8 << 3);
#line 176
            mask = 1 << 10;
#line 177
            tab = VP8Cat6;
            }
          }
          {
#line 179
          while (1) {
            while_continue___1: /* CIL Label */ ;

#line 179
            if (! mask) {
#line 179
              goto while_break___0;
            }
            {
#line 180
            __cil_tmp25 = tab;
#line 180
            tab ++;
#line 180
            AddConstantToken(tokens, (uint32_t )(! (! (residue & (unsigned int )mask))),
                             (uint32_t )*__cil_tmp25);
#line 181
            mask >>= 1;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          while_break___0: ;
        }
      }
#line 184
      base_id = (uint32_t )(11 * (2 + 3 * ((int )VP8EncBands[n] + 8 * coeff_type)));
#line 185
      s = (*(res->stats + (int )VP8EncBands[n]))[2];
    }
    {
#line 187
    AddConstantToken(tokens, (uint32_t )sign, (uint32_t )128);
#line 188
    __cil_tmp26 = AddToken(tokens, (uint32_t )(n <= last), base_id, s + 0);
    }
#line 188
    if (n == 16) {
#line 189
      return (1);
    } else
#line 188
    if (! __cil_tmp26) {
#line 189
      return (1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 192
  return (1);
}
}
#line 200 "/root/patron-new/new_3/src/enc/token_enc.c"
int VP8EmitTokens(VP8TBuffer *b , VP8BitWriter *bw , uint8_t *probas , int final_pass ) 
{ 
  VP8Tokens *p ;
  VP8Tokens *next ;
  int N ;
  int tmp ;
  int n ;
  token_t *tokens ;
  int __cil_tmp11 ;
  token_t token ;
  int bit ;

  {
#line 202
  p = b->pages_;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;

#line 204
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 204
      goto while_break;
    }
#line 205
    next = p->next_;
#line 206
    if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 206
      tmp = b->left_;
    } else {
#line 206
      tmp = 0;
    }
#line 206
    N = tmp;
#line 207
    n = b->page_size_;
#line 208
    tokens = (token_t *)(p + 1);
    {
#line 209
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 209
      __cil_tmp11 = n;
#line 209
      n --;
#line 209
      if (! (__cil_tmp11 > N)) {
#line 209
        goto while_break___0;
      }
#line 210
      token = *(tokens + n);
#line 211
      bit = ((int )token >> 15) & 1;
#line 212
      if ((unsigned int )token & (1U << 14)) {
        {
#line 213
        VP8PutBit(bw, bit, (int )((unsigned int )token & 255U));
        }
      } else {
        {
#line 215
        VP8PutBit(bw, bit, (int )*(probas + ((unsigned int )token & 16383U)));
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 218
    if (final_pass) {
      {
#line 218
      WebPSafeFree((void *)p);
      }
    }
#line 219
    p = next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 221
  if (final_pass) {
#line 221
    b->pages_ = (VP8Tokens *)((void *)0);
  }
#line 222
  return (1);
}
}
#line 226 "/root/patron-new/new_3/src/enc/token_enc.c"
size_t VP8EstimateTokenSize(VP8TBuffer *b , uint8_t *probas ) 
{ 
  size_t size ;
  VP8Tokens *p ;
  VP8Tokens *next ;
  int N ;
  int tmp ;
  int n ;
  token_t *tokens ;
  int __cil_tmp10 ;
  token_t token ;
  int bit ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 227
  size = (size_t )0;
#line 228
  p = b->pages_;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;

#line 230
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 230
      goto while_break;
    }
#line 231
    next = p->next_;
#line 232
    if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 232
      tmp = b->left_;
    } else {
#line 232
      tmp = 0;
    }
#line 232
    N = tmp;
#line 233
    n = b->page_size_;
#line 234
    tokens = (token_t *)(p + 1);
    {
#line 235
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 235
      __cil_tmp10 = n;
#line 235
      n --;
#line 235
      if (! (__cil_tmp10 > N)) {
#line 235
        goto while_break___0;
      }
#line 236
      token = *(tokens + n);
#line 237
      bit = (int )token & (1 << 15);
#line 238
      if ((unsigned int )token & (1U << 14)) {
        {
#line 239
        __cil_tmp13 = VP8BitCost(bit, (uint8_t )((unsigned int )token & 255U));
#line 239
        size += (unsigned long )__cil_tmp13;
        }
      } else {
        {
#line 241
        __cil_tmp14 = VP8BitCost(bit, *(probas + ((unsigned int )token & 16383U)));
#line 241
        size += (unsigned long )__cil_tmp14;
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 244
    p = next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 246
  return (size);
}
}
#line 65 "../../src/webp/mux_types.h"
__inline static void WebPDataInit(WebPData *webp_data ) 
{ 


  {
#line 66
  if ((unsigned long )webp_data != (unsigned long )((void *)0)) {
    {
#line 67
    memset((void *)webp_data, 0, sizeof(*webp_data));
    }
  }
#line 70
  return;
}
}
#line 73 "../../src/webp/mux_types.h"
__inline static void WebPDataClear(WebPData *webp_data ) 
{ 


  {
#line 74
  if ((unsigned long )webp_data != (unsigned long )((void *)0)) {
    {
#line 75
    WebPFree((void *)webp_data->bytes);
#line 76
    WebPDataInit(webp_data);
    }
  }
#line 79
  return;
}
}
#line 24 "/root/patron-new/new_3/src/enc/syntax_enc.c"
static int IsVP8XNeeded(VP8Encoder *enc ) 
{ 


  {
#line 25
  return (! (! enc->has_alpha_));
}
}
#line 29 "/root/patron-new/new_3/src/enc/syntax_enc.c"
static int PutPaddingByte(WebPPicture *pic ) 
{ 
  uint8_t pad_byte[1] ;
  int __cil_tmp3 ;

  {
  {
#line 30
  pad_byte[0] = (uint8_t )0;
#line 31
  __cil_tmp3 = (*(pic->writer))(pad_byte, (size_t )1, pic);
  }
#line 31
  return (! (! __cil_tmp3));
}
}
#line 37 "/root/patron-new/new_3/src/enc/syntax_enc.c"
static WebPEncodingError PutRIFFHeader(VP8Encoder *enc , size_t riff_size ) 
{ 
  WebPPicture *pic ;
  uint8_t riff[12] ;
  int __cil_tmp5 ;

  {
  {
#line 39
  pic = enc->pic_;
#line 40
  riff[0] = (uint8_t )'R';
#line 40
  riff[1] = (uint8_t )'I';
#line 40
  riff[2] = (uint8_t )'F';
#line 40
  riff[3] = (uint8_t )'F';
#line 40
  riff[4] = (uint8_t )0;
#line 40
  riff[5] = (uint8_t )0;
#line 40
  riff[6] = (uint8_t )0;
#line 40
  riff[7] = (uint8_t )0;
#line 40
  riff[8] = (uint8_t )'W';
#line 40
  riff[9] = (uint8_t )'E';
#line 40
  riff[10] = (uint8_t )'B';
#line 40
  riff[11] = (uint8_t )'P';
#line 44
  PutLE32(riff + 4, (uint32_t )riff_size);
#line 45
  __cil_tmp5 = (*(pic->writer))(riff, sizeof(riff), pic);
  }
#line 45
  if (! __cil_tmp5) {
#line 46
    return ((WebPEncodingError )8);
  }
#line 48
  return ((WebPEncodingError )0);
}
}
#line 51 "/root/patron-new/new_3/src/enc/syntax_enc.c"
static WebPEncodingError PutVP8XHeader(VP8Encoder *enc ) 
{ 
  WebPPicture *pic ;
  uint8_t vp8x[18] ;
  unsigned int tmp ;
  uint32_t flags ;
  int __cil_tmp6 ;

  {
#line 52
  pic = enc->pic_;
#line 53
  vp8x[0] = (uint8_t )'V';
#line 53
  vp8x[1] = (uint8_t )'P';
#line 53
  vp8x[2] = (uint8_t )'8';
#line 53
  vp8x[3] = (uint8_t )'X';
#line 53
  tmp = 4U;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;

#line 53
    if (tmp >= 18U) {
#line 53
      goto while_break;
    }
#line 53
    vp8x[tmp] = (uint8_t )0;
#line 53
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 56
  flags = (uint32_t )0;
#line 62
  if (enc->has_alpha_) {
#line 63
    flags |= 16U;
  }
  {
#line 66
  PutLE32(vp8x + 4, (uint32_t )10);
#line 67
  PutLE32(vp8x + 8, flags);
#line 68
  PutLE24((vp8x + 8) + 4, pic->width - 1);
#line 69
  PutLE24((vp8x + 8) + 7, pic->height - 1);
#line 70
  __cil_tmp6 = (*(pic->writer))(vp8x, sizeof(vp8x), pic);
  }
#line 70
  if (! __cil_tmp6) {
#line 71
    return ((WebPEncodingError )8);
  }
#line 73
  return ((WebPEncodingError )0);
}
}
#line 76 "/root/patron-new/new_3/src/enc/syntax_enc.c"
static WebPEncodingError PutAlphaChunk(VP8Encoder *enc ) 
{ 
  WebPPicture *pic ;
  uint8_t alpha_chunk_hdr[8] ;
  unsigned int tmp ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 77
  pic = enc->pic_;
#line 78
  alpha_chunk_hdr[0] = (uint8_t )'A';
#line 78
  alpha_chunk_hdr[1] = (uint8_t )'L';
#line 78
  alpha_chunk_hdr[2] = (uint8_t )'P';
#line 78
  alpha_chunk_hdr[3] = (uint8_t )'H';
#line 78
  tmp = 4U;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;

#line 78
    if (tmp >= 8U) {
#line 78
      goto while_break;
    }
#line 78
    alpha_chunk_hdr[tmp] = (uint8_t )0;
#line 78
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 85
  PutLE32(alpha_chunk_hdr + 4, enc->alpha_data_size_);
#line 86
  __cil_tmp5 = (*(pic->writer))(alpha_chunk_hdr, sizeof(alpha_chunk_hdr), pic);
  }
#line 86
  if (! __cil_tmp5) {
#line 87
    return ((WebPEncodingError )8);
  }
  {
#line 91
  __cil_tmp6 = (*(pic->writer))(enc->alpha_data_, (size_t )enc->alpha_data_size_,
                                pic);
  }
#line 91
  if (! __cil_tmp6) {
#line 92
    return ((WebPEncodingError )8);
  }
  {
#line 96
  __cil_tmp7 = PutPaddingByte(pic);
  }
#line 96
  if (enc->alpha_data_size_ & 1U) {
#line 96
    if (! __cil_tmp7) {
#line 97
      return ((WebPEncodingError )8);
    }
  }
#line 99
  return ((WebPEncodingError )0);
}
}
#line 102 "/root/patron-new/new_3/src/enc/syntax_enc.c"
static WebPEncodingError PutVP8Header(WebPPicture *pic , size_t vp8_size ) 
{ 
  uint8_t vp8_chunk_hdr[8] ;
  unsigned int tmp ;
  int __cil_tmp5 ;

  {
#line 104
  vp8_chunk_hdr[0] = (uint8_t )'V';
#line 104
  vp8_chunk_hdr[1] = (uint8_t )'P';
#line 104
  vp8_chunk_hdr[2] = (uint8_t )'8';
#line 104
  vp8_chunk_hdr[3] = (uint8_t )' ';
#line 104
  tmp = 4U;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;

#line 104
    if (tmp >= 8U) {
#line 104
      goto while_break;
    }
#line 104
    vp8_chunk_hdr[tmp] = (uint8_t )0;
#line 104
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 108
  PutLE32(vp8_chunk_hdr + 4, (uint32_t )vp8_size);
#line 109
  __cil_tmp5 = (*(pic->writer))(vp8_chunk_hdr, sizeof(vp8_chunk_hdr), pic);
  }
#line 109
  if (! __cil_tmp5) {
#line 110
    return ((WebPEncodingError )8);
  }
#line 112
  return ((WebPEncodingError )0);
}
}
#line 115 "/root/patron-new/new_3/src/enc/syntax_enc.c"
static WebPEncodingError PutVP8FrameHeader(WebPPicture *pic , int profile , size_t size0 ) 
{ 
  uint8_t vp8_frm_hdr[10] ;
  uint32_t bits ;
  int __cil_tmp6 ;

  {
#line 120
  if (size0 >= (unsigned long )(1 << 19)) {
#line 121
    return ((WebPEncodingError )6);
  }
  {
#line 125
  bits = (unsigned int )((profile << 1) | (1 << 4)) | ((uint32_t )size0 << 5);
#line 129
  vp8_frm_hdr[0] = (uint8_t )(bits & 255U);
#line 130
  vp8_frm_hdr[1] = (uint8_t )((bits >> 8) & 255U);
#line 131
  vp8_frm_hdr[2] = (uint8_t )((bits >> 16) & 255U);
#line 133
  vp8_frm_hdr[3] = (uint8_t )((10289450 >> 16) & 255);
#line 134
  vp8_frm_hdr[4] = (uint8_t )((10289450 >> 8) & 255);
#line 135
  vp8_frm_hdr[5] = (uint8_t )42;
#line 137
  vp8_frm_hdr[6] = (uint8_t )(pic->width & 255);
#line 138
  vp8_frm_hdr[7] = (uint8_t )(pic->width >> 8);
#line 139
  vp8_frm_hdr[8] = (uint8_t )(pic->height & 255);
#line 140
  vp8_frm_hdr[9] = (uint8_t )(pic->height >> 8);
#line 142
  __cil_tmp6 = (*(pic->writer))(vp8_frm_hdr, sizeof(vp8_frm_hdr), pic);
  }
#line 142
  if (! __cil_tmp6) {
#line 143
    return ((WebPEncodingError )8);
  }
#line 145
  return ((WebPEncodingError )0);
}
}
#line 149 "/root/patron-new/new_3/src/enc/syntax_enc.c"
static int PutWebPHeaders(VP8Encoder *enc , size_t size0 , size_t vp8_size , size_t riff_size ) 
{ 
  WebPPicture *pic ;
  WebPEncodingError err ;
  int __cil_tmp8 ;
  int __cil_tmp13 ;

  {
  {
#line 151
  pic = enc->pic_;
#line 152
  err = (WebPEncodingError )0;
#line 155
  err = PutRIFFHeader(enc, riff_size);
  }
#line 156
  if ((unsigned int )err != 0U) {
#line 156
    goto Error;
  }
  {
#line 159
  __cil_tmp8 = IsVP8XNeeded(enc);
  }
#line 159
  if (__cil_tmp8) {
    {
#line 160
    err = PutVP8XHeader(enc);
    }
#line 161
    if ((unsigned int )err != 0U) {
#line 161
      goto Error;
    }
  }
#line 165
  if (enc->has_alpha_) {
    {
#line 166
    err = PutAlphaChunk(enc);
    }
#line 167
    if ((unsigned int )err != 0U) {
#line 167
      goto Error;
    }
  }
  {
#line 171
  err = PutVP8Header(pic, vp8_size);
  }
#line 172
  if ((unsigned int )err != 0U) {
#line 172
    goto Error;
  }
  {
#line 175
  err = PutVP8FrameHeader(pic, enc->profile_, size0);
  }
#line 176
  if ((unsigned int )err != 0U) {
#line 176
    goto Error;
  }
#line 179
  return (1);
  Error: 
  {
#line 183
  __cil_tmp13 = WebPEncodingSetError(pic, err);
  }
#line 183
  return (__cil_tmp13);
}
}
#line 187 "/root/patron-new/new_3/src/enc/syntax_enc.c"
static void PutSegmentHeader(VP8BitWriter *bw , VP8Encoder *enc ) 
{ 
  VP8EncSegmentHeader *hdr ;
  VP8EncProba *proba ;
  int __cil_tmp5 ;
  int update_data ;
  int s ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 189
  hdr = & enc->segment_hdr_;
#line 190
  proba = & enc->proba_;
#line 191
  __cil_tmp5 = VP8PutBitUniform(bw, hdr->num_segments_ > 1);
  }
#line 191
  if (__cil_tmp5) {
    {
#line 193
    update_data = 1;
#line 195
    VP8PutBitUniform(bw, hdr->update_map_);
#line 196
    __cil_tmp8 = VP8PutBitUniform(bw, update_data);
    }
#line 196
    if (__cil_tmp8) {
      {
#line 198
      VP8PutBitUniform(bw, 1);
#line 199
      s = 0;
      }
      {
#line 199
      while (1) {
        while_continue: /* CIL Label */ ;

#line 199
        if (! (s < 4)) {
#line 199
          goto while_break;
        }
        {
#line 200
        VP8PutSignedBits(bw, enc->dqm_[s].quant_, 7);
#line 199
        s ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: 
#line 202
      s = 0;
      {
#line 202
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 202
        if (! (s < 4)) {
#line 202
          goto while_break___0;
        }
        {
#line 203
        VP8PutSignedBits(bw, enc->dqm_[s].fstrength_, 6);
#line 202
        s ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    }
#line 206
    if (hdr->update_map_) {
#line 207
      s = 0;
      {
#line 207
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 207
        if (! (s < 3)) {
#line 207
          goto while_break___1;
        }
        {
#line 208
        __cil_tmp9 = VP8PutBitUniform(bw, (unsigned int )proba->segments_[s] != 255U);
        }
#line 208
        if (__cil_tmp9) {
          {
#line 209
          VP8PutBits(bw, (uint32_t )proba->segments_[s], 8);
          }
        }
#line 207
        s ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
    }
  }
#line 213
  return;
}
}
#line 217 "/root/patron-new/new_3/src/enc/syntax_enc.c"
static void PutFilterHeader(VP8BitWriter *bw , VP8EncFilterHeader *hdr ) 
{ 
  int use_lf_delta ;
  int __cil_tmp4 ;
  int need_update ;
  int __cil_tmp6 ;

  {
  {
#line 219
  use_lf_delta = hdr->i4x4_lf_delta_ != 0;
#line 220
  VP8PutBitUniform(bw, hdr->simple_);
#line 221
  VP8PutBits(bw, (uint32_t )hdr->level_, 6);
#line 222
  VP8PutBits(bw, (uint32_t )hdr->sharpness_, 3);
#line 223
  __cil_tmp4 = VP8PutBitUniform(bw, use_lf_delta);
  }
#line 223
  if (__cil_tmp4) {
    {
#line 225
    need_update = hdr->i4x4_lf_delta_ != 0;
#line 226
    __cil_tmp6 = VP8PutBitUniform(bw, need_update);
    }
#line 226
    if (__cil_tmp6) {
      {
#line 228
      VP8PutBits(bw, (uint32_t )0, 4);
#line 230
      VP8PutSignedBits(bw, hdr->i4x4_lf_delta_, 6);
#line 231
      VP8PutBits(bw, (uint32_t )0, 3);
      }
    }
  }
#line 235
  return;
}
}
#line 237 "/root/patron-new/new_3/src/enc/syntax_enc.c"
static void PutQuant(VP8BitWriter *bw , VP8Encoder *enc ) 
{ 


  {
  {
#line 239
  VP8PutBits(bw, (uint32_t )enc->base_quant_, 7);
#line 240
  VP8PutSignedBits(bw, enc->dq_y1_dc_, 4);
#line 241
  VP8PutSignedBits(bw, enc->dq_y2_dc_, 4);
#line 242
  VP8PutSignedBits(bw, enc->dq_y2_ac_, 4);
#line 243
  VP8PutSignedBits(bw, enc->dq_uv_dc_, 4);
#line 244
  VP8PutSignedBits(bw, enc->dq_uv_ac_, 4);
  }
#line 246
  return;
}
}
#line 248 "/root/patron-new/new_3/src/enc/syntax_enc.c"
static int EmitPartitionsSize(VP8Encoder *enc , WebPPicture *pic ) 
{ 
  uint8_t buf[21] ;
  int p ;
  size_t part_size ;
  size_t __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int tmp ;

  {
#line 252
  p = 0;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;

#line 252
    if (! (p < enc->num_parts_ - 1)) {
#line 252
      goto while_break;
    }
    {
#line 253
    __cil_tmp6 = VP8BitWriterSize(enc->parts_ + p);
#line 253
    part_size = __cil_tmp6;
    }
#line 254
    if (part_size >= (unsigned long )(1 << 24)) {
      {
#line 255
      __cil_tmp7 = WebPEncodingSetError(pic, (WebPEncodingError )7);
      }
#line 255
      return (__cil_tmp7);
    }
#line 257
    buf[3 * p] = (uint8_t )(part_size & 255UL);
#line 258
    buf[3 * p + 1] = (uint8_t )((part_size >> 8) & 255UL);
#line 259
    buf[3 * p + 2] = (uint8_t )((part_size >> 16) & 255UL);
#line 252
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 261
  if (p) {
    {
#line 261
    __cil_tmp8 = (*(pic->writer))(buf, (size_t )(3 * p), pic);
#line 261
    tmp = __cil_tmp8;
    }
  } else {
#line 261
    tmp = 1;
  }
#line 261
  return (tmp);
}
}
#line 266 "/root/patron-new/new_3/src/enc/syntax_enc.c"
static int GeneratePartition0(VP8Encoder *enc ) 
{ 
  VP8BitWriter *bw ;
  int mb_size ;
  uint64_t pos1 ;
  uint64_t pos2 ;
  uint64_t pos3 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp15 ;

  {
  {
#line 267
  bw = & enc->bw_;
#line 268
  mb_size = enc->mb_w_ * enc->mb_h_;
#line 271
  pos1 = VP8BitWriterPos(bw);
#line 272
  __cil_tmp8 = VP8BitWriterInit(bw, (size_t )((mb_size * 7) / 8));
  }
#line 272
  if (! __cil_tmp8) {
    {
#line 273
    __cil_tmp9 = WebPEncodingSetError(enc->pic_, (WebPEncodingError )1);
    }
#line 273
    return (__cil_tmp9);
  }
  {
#line 275
  VP8PutBitUniform(bw, 0);
#line 276
  VP8PutBitUniform(bw, 0);
#line 278
  PutSegmentHeader(bw, enc);
#line 279
  PutFilterHeader(bw, & enc->filter_hdr_);
  }
#line 280
  if (enc->num_parts_ == 8) {
#line 280
    tmp___1 = 3;
  } else {
#line 280
    if (enc->num_parts_ == 4) {
#line 280
      tmp___0 = 2;
    } else {
#line 280
      if (enc->num_parts_ == 2) {
#line 280
        tmp = 1;
      } else {
#line 280
        tmp = 0;
      }
#line 280
      tmp___0 = tmp;
    }
#line 280
    tmp___1 = tmp___0;
  }
  {
#line 280
  VP8PutBits(bw, (uint32_t )tmp___1, 2);
#line 283
  PutQuant(bw, enc);
#line 284
  VP8PutBitUniform(bw, 0);
#line 285
  VP8WriteProbas(bw, & enc->proba_);
#line 286
  pos2 = VP8BitWriterPos(bw);
#line 287
  VP8CodeIntraModes(enc);
#line 288
  VP8BitWriterFinish(bw);
#line 290
  pos3 = VP8BitWriterPos(bw);
  }
#line 293
  if ((enc->pic_)->stats) {
#line 294
    ((enc->pic_)->stats)->header_bytes[0] = (int )(((pos2 - pos1) + 7UL) >> 3);
#line 295
    ((enc->pic_)->stats)->header_bytes[1] = (int )(((pos3 - pos2) + 7UL) >> 3);
#line 296
    ((enc->pic_)->stats)->alpha_data_size = (int )enc->alpha_data_size_;
  }
#line 303
  if (bw->error_) {
    {
#line 304
    __cil_tmp15 = WebPEncodingSetError(enc->pic_, (WebPEncodingError )1);
    }
#line 304
    return (__cil_tmp15);
  }
#line 306
  return (1);
}
}
#line 309 "/root/patron-new/new_3/src/enc/syntax_enc.c"
void VP8EncFreeBitWriters(VP8Encoder *enc ) 
{ 
  int p ;

  {
  {
#line 311
  VP8BitWriterWipeOut(& enc->bw_);
#line 312
  p = 0;
  }
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;

#line 312
    if (! (p < enc->num_parts_)) {
#line 312
      goto while_break;
    }
    {
#line 313
    VP8BitWriterWipeOut(enc->parts_ + p);
#line 312
    p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 316
  return;
}
}
#line 317 "/root/patron-new/new_3/src/enc/syntax_enc.c"
int VP8EncWrite(VP8Encoder *enc ) 
{ 
  WebPPicture *pic ;
  VP8BitWriter *bw ;
  int task_percent ;
  int percent_per_part ;
  int final_percent ;
  int ok ;
  size_t vp8_size ;
  size_t pad ;
  size_t riff_size ;
  int p ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp14 ;
  int __cil_tmp15 ;
  uint32_t padded_alpha_size ;
  int __cil_tmp17 ;
  uint8_t *part0 ;
  uint8_t *__cil_tmp19 ;
  size_t size0 ;
  size_t __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  uint8_t *buf ;
  uint8_t *__cil_tmp26 ;
  size_t size ;
  size_t __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp32 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 318
  pic = enc->pic_;
#line 319
  bw = & enc->bw_;
#line 320
  task_percent = 19;
#line 321
  percent_per_part = task_percent / enc->num_parts_;
#line 322
  final_percent = enc->percent_ + task_percent;
#line 323
  ok = 0;
#line 328
  ok = GeneratePartition0(enc);
  }
#line 329
  if (! ok) {
#line 329
    return (0);
  }
  {
#line 332
  __cil_tmp13 = VP8BitWriterSize(bw);
#line 332
  vp8_size = (10UL + __cil_tmp13) + (unsigned long )(3 * (enc->num_parts_ - 1));
#line 335
  p = 0;
  }
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;

#line 335
    if (! (p < enc->num_parts_)) {
#line 335
      goto while_break;
    }
    {
#line 336
    __cil_tmp14 = VP8BitWriterSize(enc->parts_ + p);
#line 336
    vp8_size += __cil_tmp14;
#line 335
    p ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 338
  pad = vp8_size & 1UL;
#line 339
  vp8_size += pad;
#line 343
  riff_size = 12UL + vp8_size;
#line 344
  __cil_tmp15 = IsVP8XNeeded(enc);
  }
#line 344
  if (__cil_tmp15) {
#line 345
    riff_size += 18UL;
  }
#line 347
  if (enc->has_alpha_) {
#line 348
    padded_alpha_size = enc->alpha_data_size_ + (enc->alpha_data_size_ & 1U);
#line 350
    riff_size += (unsigned long )(8U + padded_alpha_size);
  }
#line 353
  if (riff_size > 4294967294UL) {
    {
#line 354
    __cil_tmp17 = WebPEncodingSetError(pic, (WebPEncodingError )9);
    }
#line 354
    return (__cil_tmp17);
  }
  {
#line 359
  __cil_tmp19 = VP8BitWriterBuf(bw);
#line 359
  part0 = __cil_tmp19;
#line 360
  __cil_tmp21 = VP8BitWriterSize(bw);
#line 360
  size0 = __cil_tmp21;
#line 361
  __cil_tmp24 = EmitPartitionsSize(enc, pic);
#line 361
  __cil_tmp23 = (*(pic->writer))(part0, size0, pic);
#line 361
  __cil_tmp22 = PutWebPHeaders(enc, size0, vp8_size, riff_size);
  }
#line 361
  if (ok) {
#line 361
    if (__cil_tmp22) {
#line 361
      if (__cil_tmp23) {
#line 361
        if (__cil_tmp24) {
#line 361
          tmp = 1;
        } else {
#line 361
          tmp = 0;
        }
      } else {
#line 361
        tmp = 0;
      }
    } else {
#line 361
      tmp = 0;
    }
  } else {
#line 361
    tmp = 0;
  }
  {
#line 361
  ok = tmp;
#line 364
  VP8BitWriterWipeOut(bw);
#line 368
  p = 0;
  }
  {
#line 368
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 368
    if (! (p < enc->num_parts_)) {
#line 368
      goto while_break___0;
    }
    {
#line 369
    __cil_tmp26 = VP8BitWriterBuf(enc->parts_ + p);
#line 369
    buf = __cil_tmp26;
#line 370
    __cil_tmp28 = VP8BitWriterSize(enc->parts_ + p);
#line 370
    size = __cil_tmp28;
    }
#line 371
    if (size) {
      {
#line 371
      __cil_tmp29 = (*(pic->writer))(buf, size, pic);
      }
#line 371
      if (ok) {
#line 371
        if (__cil_tmp29) {
#line 371
          tmp___0 = 1;
        } else {
#line 371
          tmp___0 = 0;
        }
      } else {
#line 371
        tmp___0 = 0;
      }
#line 371
      ok = tmp___0;
    }
    {
#line 372
    VP8BitWriterWipeOut(enc->parts_ + p);
#line 373
    __cil_tmp30 = WebPReportProgress(pic, enc->percent_ + percent_per_part, & enc->percent_);
    }
#line 373
    if (ok) {
#line 373
      if (__cil_tmp30) {
#line 373
        tmp___1 = 1;
      } else {
#line 373
        tmp___1 = 0;
      }
    } else {
#line 373
      tmp___1 = 0;
    }
#line 373
    ok = tmp___1;
#line 368
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 378
  if (ok) {
#line 378
    if (pad) {
      {
#line 379
      ok = PutPaddingByte(pic);
      }
    }
  }
  {
#line 382
  enc->coded_size_ = (int )(8UL + riff_size);
#line 383
  __cil_tmp32 = WebPReportProgress(pic, final_percent, & enc->percent_);
  }
#line 383
  if (ok) {
#line 383
    if (__cil_tmp32) {
#line 383
      tmp___2 = 1;
    } else {
#line 383
      tmp___2 = 0;
    }
  } else {
#line 383
    tmp___2 = 0;
  }
#line 383
  ok = tmp___2;
#line 384
  return (ok);
}
}
#line 55 "../../src/dsp/quant.h"
__inline static int IsFlat_C(int16_t *levels , int num_blocks , int thresh ) 
{ 
  int score ;
  int __cil_tmp5 ;
  int i ;

  {
#line 57
  score = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    __cil_tmp5 = num_blocks;
#line 58
    num_blocks --;
#line 58
    if (! (__cil_tmp5 > 0)) {
#line 58
      goto while_break;
    }
#line 60
    i = 1;
    {
#line 60
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 60
      if (! (i < 16)) {
#line 60
        goto while_break___0;
      }
#line 61
      score += (int )*(levels + i) != 0;
#line 62
      if (score > thresh) {
#line 62
        return (0);
      }
#line 60
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 64
    levels += 16;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 66
  return (1);
}
}
#line 72 "../../src/dsp/quant.h"
__inline static int IsFlatSource16(uint8_t *src ) 
{ 
  uint32_t v ;
  int i ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 73
  v = (unsigned int )*(src + 0) * 16843009U;
#line 75
  i = 0;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;

#line 75
    if (! (i < 16)) {
#line 75
      goto while_break;
    }
    {
#line 76
    __cil_tmp7 = memcmp((void const   *)(src + 12), (void const   *)(& v), 4UL);
#line 76
    __cil_tmp6 = memcmp((void const   *)(src + 8), (void const   *)(& v), 4UL);
#line 76
    __cil_tmp5 = memcmp((void const   *)(src + 4), (void const   *)(& v), 4UL);
#line 76
    __cil_tmp4 = memcmp((void const   *)(src + 0), (void const   *)(& v), 4UL);
    }
#line 76
    if (__cil_tmp4) {
#line 78
      return (0);
    } else
#line 76
    if (__cil_tmp5) {
#line 78
      return (0);
    } else
#line 76
    if (__cil_tmp6) {
#line 78
      return (0);
    } else
#line 76
    if (__cil_tmp7) {
#line 78
      return (0);
    }
#line 80
    src += 32;
#line 75
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 82
  return (1);
}
}
#line 126 "/root/patron-new/new_3/src/enc/quant_enc.c"
__inline static int clip(int v , int m , int M ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 127
  if (v < m) {
#line 127
    tmp___0 = m;
  } else {
#line 127
    if (v > M) {
#line 127
      tmp = M;
    } else {
#line 127
      tmp = v;
    }
#line 127
    tmp___0 = tmp;
  }
#line 127
  return (tmp___0);
}
}
#line 130 "/root/patron-new/new_3/src/enc/quant_enc.c"
static uint8_t kZigzag[16]  = 
#line 130
  {      (uint8_t )0,      (uint8_t )1,      (uint8_t )4,      (uint8_t )8, 
        (uint8_t )5,      (uint8_t )2,      (uint8_t )3,      (uint8_t )6, 
        (uint8_t )9,      (uint8_t )12,      (uint8_t )13,      (uint8_t )10, 
        (uint8_t )7,      (uint8_t )11,      (uint8_t )14,      (uint8_t )15};
#line 134 "/root/patron-new/new_3/src/enc/quant_enc.c"
static uint8_t kDcTable[128]  = 
#line 134
  {      (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )10, 
        (uint8_t )11,      (uint8_t )12,      (uint8_t )13,      (uint8_t )14, 
        (uint8_t )15,      (uint8_t )16,      (uint8_t )17,      (uint8_t )17, 
        (uint8_t )18,      (uint8_t )19,      (uint8_t )20,      (uint8_t )20, 
        (uint8_t )21,      (uint8_t )21,      (uint8_t )22,      (uint8_t )22, 
        (uint8_t )23,      (uint8_t )23,      (uint8_t )24,      (uint8_t )25, 
        (uint8_t )25,      (uint8_t )26,      (uint8_t )27,      (uint8_t )28, 
        (uint8_t )29,      (uint8_t )30,      (uint8_t )31,      (uint8_t )32, 
        (uint8_t )33,      (uint8_t )34,      (uint8_t )35,      (uint8_t )36, 
        (uint8_t )37,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )46, 
        (uint8_t )47,      (uint8_t )48,      (uint8_t )49,      (uint8_t )50, 
        (uint8_t )51,      (uint8_t )52,      (uint8_t )53,      (uint8_t )54, 
        (uint8_t )55,      (uint8_t )56,      (uint8_t )57,      (uint8_t )58, 
        (uint8_t )59,      (uint8_t )60,      (uint8_t )61,      (uint8_t )62, 
        (uint8_t )63,      (uint8_t )64,      (uint8_t )65,      (uint8_t )66, 
        (uint8_t )67,      (uint8_t )68,      (uint8_t )69,      (uint8_t )70, 
        (uint8_t )71,      (uint8_t )72,      (uint8_t )73,      (uint8_t )74, 
        (uint8_t )75,      (uint8_t )76,      (uint8_t )76,      (uint8_t )77, 
        (uint8_t )78,      (uint8_t )79,      (uint8_t )80,      (uint8_t )81, 
        (uint8_t )82,      (uint8_t )83,      (uint8_t )84,      (uint8_t )85, 
        (uint8_t )86,      (uint8_t )87,      (uint8_t )88,      (uint8_t )89, 
        (uint8_t )91,      (uint8_t )93,      (uint8_t )95,      (uint8_t )96, 
        (uint8_t )98,      (uint8_t )100,      (uint8_t )101,      (uint8_t )102, 
        (uint8_t )104,      (uint8_t )106,      (uint8_t )108,      (uint8_t )110, 
        (uint8_t )112,      (uint8_t )114,      (uint8_t )116,      (uint8_t )118, 
        (uint8_t )122,      (uint8_t )124,      (uint8_t )126,      (uint8_t )128, 
        (uint8_t )130,      (uint8_t )132,      (uint8_t )134,      (uint8_t )136, 
        (uint8_t )138,      (uint8_t )140,      (uint8_t )143,      (uint8_t )145, 
        (uint8_t )148,      (uint8_t )151,      (uint8_t )154,      (uint8_t )157};
#line 153 "/root/patron-new/new_3/src/enc/quant_enc.c"
static uint16_t kAcTable[128]  = 
#line 153
  {      (uint16_t )4,      (uint16_t )5,      (uint16_t )6,      (uint16_t )7, 
        (uint16_t )8,      (uint16_t )9,      (uint16_t )10,      (uint16_t )11, 
        (uint16_t )12,      (uint16_t )13,      (uint16_t )14,      (uint16_t )15, 
        (uint16_t )16,      (uint16_t )17,      (uint16_t )18,      (uint16_t )19, 
        (uint16_t )20,      (uint16_t )21,      (uint16_t )22,      (uint16_t )23, 
        (uint16_t )24,      (uint16_t )25,      (uint16_t )26,      (uint16_t )27, 
        (uint16_t )28,      (uint16_t )29,      (uint16_t )30,      (uint16_t )31, 
        (uint16_t )32,      (uint16_t )33,      (uint16_t )34,      (uint16_t )35, 
        (uint16_t )36,      (uint16_t )37,      (uint16_t )38,      (uint16_t )39, 
        (uint16_t )40,      (uint16_t )41,      (uint16_t )42,      (uint16_t )43, 
        (uint16_t )44,      (uint16_t )45,      (uint16_t )46,      (uint16_t )47, 
        (uint16_t )48,      (uint16_t )49,      (uint16_t )50,      (uint16_t )51, 
        (uint16_t )52,      (uint16_t )53,      (uint16_t )54,      (uint16_t )55, 
        (uint16_t )56,      (uint16_t )57,      (uint16_t )58,      (uint16_t )60, 
        (uint16_t )62,      (uint16_t )64,      (uint16_t )66,      (uint16_t )68, 
        (uint16_t )70,      (uint16_t )72,      (uint16_t )74,      (uint16_t )76, 
        (uint16_t )78,      (uint16_t )80,      (uint16_t )82,      (uint16_t )84, 
        (uint16_t )86,      (uint16_t )88,      (uint16_t )90,      (uint16_t )92, 
        (uint16_t )94,      (uint16_t )96,      (uint16_t )98,      (uint16_t )100, 
        (uint16_t )102,      (uint16_t )104,      (uint16_t )106,      (uint16_t )108, 
        (uint16_t )110,      (uint16_t )112,      (uint16_t )114,      (uint16_t )116, 
        (uint16_t )119,      (uint16_t )122,      (uint16_t )125,      (uint16_t )128, 
        (uint16_t )131,      (uint16_t )134,      (uint16_t )137,      (uint16_t )140, 
        (uint16_t )143,      (uint16_t )146,      (uint16_t )149,      (uint16_t )152, 
        (uint16_t )155,      (uint16_t )158,      (uint16_t )161,      (uint16_t )164, 
        (uint16_t )167,      (uint16_t )170,      (uint16_t )173,      (uint16_t )177, 
        (uint16_t )181,      (uint16_t )185,      (uint16_t )189,      (uint16_t )193, 
        (uint16_t )197,      (uint16_t )201,      (uint16_t )205,      (uint16_t )209, 
        (uint16_t )213,      (uint16_t )217,      (uint16_t )221,      (uint16_t )225, 
        (uint16_t )229,      (uint16_t )234,      (uint16_t )239,      (uint16_t )245, 
        (uint16_t )249,      (uint16_t )254,      (uint16_t )259,      (uint16_t )264, 
        (uint16_t )269,      (uint16_t )274,      (uint16_t )279,      (uint16_t )284};
#line 191 "/root/patron-new/new_3/src/enc/quant_enc.c"
static uint8_t kBiasMatrices[3][2]  = { {        (uint8_t )96,        (uint8_t )110}, 
   {        (uint8_t )96,        (uint8_t )108}, 
   {        (uint8_t )110,        (uint8_t )115}};
#line 198 "/root/patron-new/new_3/src/enc/quant_enc.c"
static uint8_t kFreqSharpening[16]  = 
#line 198
  {      (uint8_t )0,      (uint8_t )30,      (uint8_t )60,      (uint8_t )90, 
        (uint8_t )30,      (uint8_t )60,      (uint8_t )90,      (uint8_t )90, 
        (uint8_t )60,      (uint8_t )90,      (uint8_t )90,      (uint8_t )90, 
        (uint8_t )90,      (uint8_t )90,      (uint8_t )90,      (uint8_t )90};
#line 209 "/root/patron-new/new_3/src/enc/quant_enc.c"
static int ExpandMatrix(VP8Matrix *m , int type ) 
{ 
  int i ;
  int sum ;
  int is_ac_coeff ;
  int bias ;

  {
#line 211
  i = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;

#line 211
    if (! (i < 2)) {
#line 211
      goto while_break;
    }
#line 212
    is_ac_coeff = i > 0;
#line 213
    bias = (int )kBiasMatrices[type][is_ac_coeff];
#line 214
    m->iq_[i] = (uint16_t )((1 << 17) / (int )m->q_[i]);
#line 215
    m->bias_[i] = (uint32_t )(bias << 9);
#line 219
    m->zthresh_[i] = ((unsigned int )((1 << 17) - 1) - m->bias_[i]) / (unsigned int )m->iq_[i];
#line 211
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 221
  i = 2;
  {
#line 221
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 221
    if (! (i < 16)) {
#line 221
      goto while_break___0;
    }
#line 222
    m->q_[i] = m->q_[1];
#line 223
    m->iq_[i] = m->iq_[1];
#line 224
    m->bias_[i] = m->bias_[1];
#line 225
    m->zthresh_[i] = m->zthresh_[1];
#line 221
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 227
  i = 0;
#line 227
  sum = 0;
  {
#line 227
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 227
    if (! (i < 16)) {
#line 227
      goto while_break___1;
    }
#line 228
    if (type == 0) {
#line 229
      m->sharpen_[i] = (uint16_t )((int )kFreqSharpening[i] * (int )m->q_[i] >> 11);
    } else {
#line 231
      m->sharpen_[i] = (uint16_t )0;
    }
#line 233
    sum += (int )m->q_[i];
#line 227
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: ;
#line 235
  return ((sum + 8) >> 4);
}
}
#line 238 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void CheckLambdaValue(int *v ) 
{ 


  {
#line 238
  if (*v < 1) {
#line 238
    *v = 1;
  }
#line 240
  return;
}
}
#line 240 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void SetupMatrices(VP8Encoder *enc ) 
{ 
  int i ;
  int tlambda_scale ;
  int tmp ;
  int num_segments ;
  VP8SegmentInfo *m ;
  int q ;
  int q_i4 ;
  int q_i16 ;
  int q_uv ;
  int __cil_tmp11 ;
  int __cil_tmp13 ;
  int __cil_tmp15 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 242
  if (enc->method_ >= 4) {
#line 242
    tmp = (enc->config_)->sns_strength;
  } else {
#line 242
    tmp = 0;
  }
#line 242
  tlambda_scale = tmp;
#line 245
  num_segments = enc->segment_hdr_.num_segments_;
#line 246
  i = 0;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;

#line 246
    if (! (i < num_segments)) {
#line 246
      goto while_break;
    }
    {
#line 247
    m = & enc->dqm_[i];
#line 248
    q = m->quant_;
#line 250
    __cil_tmp11 = clip(q + enc->dq_y1_dc_, 0, 127);
#line 250
    m->y1_.q_[0] = (uint16_t )kDcTable[__cil_tmp11];
#line 251
    tmp___0 = clip(q, 0, 127);
#line 251
    m->y1_.q_[1] = (uint16_t )tmp___0;
#line 253
    __cil_tmp13 = clip(q + enc->dq_y2_dc_, 0, 127);
#line 253
    m->y2_.q_[0] = (uint16_t )((int )kDcTable[__cil_tmp13] * 2);
#line 254
    tmp___1 = clip(q + enc->dq_y2_ac_, 0, 127);
#line 254
    m->y2_.q_[1] = (uint16_t )tmp___1;
#line 256
    __cil_tmp15 = clip(q + enc->dq_uv_dc_, 0, 117);
#line 256
    m->uv_.q_[0] = (uint16_t )kDcTable[__cil_tmp15];
#line 257
    tmp___2 = clip(q + enc->dq_uv_ac_, 0, 127);
#line 257
    m->uv_.q_[1] = (uint16_t )tmp___2;
#line 259
    q_i4 = ExpandMatrix(& m->y1_, 0);
#line 260
    q_i16 = ExpandMatrix(& m->y2_, 1);
#line 261
    q_uv = ExpandMatrix(& m->uv_, 2);
#line 263
    m->lambda_i4_ = (3 * q_i4) * q_i4 >> 7;
#line 264
    m->lambda_i16_ = (3 * q_i16) * q_i16;
#line 265
    m->lambda_uv_ = (3 * q_uv) * q_uv >> 6;
#line 266
    m->lambda_mode_ = q_i4 * q_i4 >> 7;
#line 267
    m->lambda_trellis_i4_ = (7 * q_i4) * q_i4 >> 3;
#line 268
    m->lambda_trellis_i16_ = q_i16 * q_i16 >> 2;
#line 269
    m->lambda_trellis_uv_ = q_uv * q_uv << 1;
#line 270
    m->tlambda_ = tlambda_scale * q_i4 >> 5;
#line 273
    CheckLambdaValue(& m->lambda_i4_);
#line 274
    CheckLambdaValue(& m->lambda_i16_);
#line 275
    CheckLambdaValue(& m->lambda_uv_);
#line 276
    CheckLambdaValue(& m->lambda_mode_);
#line 277
    CheckLambdaValue(& m->lambda_trellis_i4_);
#line 278
    CheckLambdaValue(& m->lambda_trellis_i16_);
#line 279
    CheckLambdaValue(& m->lambda_trellis_uv_);
#line 280
    CheckLambdaValue(& m->tlambda_);
#line 282
    m->min_disto_ = 20 * (int )m->y1_.q_[0];
#line 283
    m->max_edge_ = 0;
#line 285
    m->i4_penalty_ = (score_t )((1000 * q_i4) * q_i4);
#line 246
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 250
  return;
}
}
#line 296 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void SetupFilterStrength(VP8Encoder *enc ) 
{ 
  int i ;
  int level0 ;
  VP8SegmentInfo *m ;
  int qstep ;
  int __cil_tmp6 ;
  int base_strength ;
  int __cil_tmp8 ;
  int f ;
  int tmp ;
  int tmp___0 ;

  {
#line 299
  level0 = 5 * (enc->config_)->filter_strength;
#line 300
  i = 0;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;

#line 300
    if (! (i < 4)) {
#line 300
      goto while_break;
    }
    {
#line 301
    m = & enc->dqm_[i];
#line 303
    __cil_tmp6 = clip(m->quant_, 0, 127);
#line 303
    qstep = (int )kAcTable[__cil_tmp6] >> 2;
#line 304
    __cil_tmp8 = VP8FilterStrengthFromDelta(enc->filter_hdr_.sharpness_, qstep);
#line 304
    base_strength = __cil_tmp8;
#line 307
    f = (base_strength * level0) / (256 + m->beta_);
    }
#line 308
    if (f < 2) {
#line 308
      tmp___0 = 0;
    } else {
#line 308
      if (f > 63) {
#line 308
        tmp = 63;
      } else {
#line 308
        tmp = f;
      }
#line 308
      tmp___0 = tmp;
    }
#line 308
    m->fstrength_ = tmp___0;
#line 300
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 311
  enc->filter_hdr_.level_ = enc->dqm_[0].fstrength_;
#line 312
  enc->filter_hdr_.simple_ = (enc->config_)->filter_type == 0;
#line 313
  enc->filter_hdr_.sharpness_ = (enc->config_)->filter_sharpness;
#line 314
  return;
}
}
#line 326 "/root/patron-new/new_3/src/enc/quant_enc.c"
static double QualityToCompression(double c ) 
{ 
  double linear_c ;
  double tmp ;
  double v ;
  double __cil_tmp5 ;

  {
#line 327
  if (c < 0.75) {
#line 327
    tmp = c * (2. / 3.);
  } else {
#line 327
    tmp = 2. * c - 1.;
  }
  {
#line 327
  linear_c = tmp;
#line 334
  __cil_tmp5 = pow(linear_c, (double )1 / 3.);
#line 334
  v = __cil_tmp5;
  }
#line 335
  return (v);
}
}
#line 338 "/root/patron-new/new_3/src/enc/quant_enc.c"
static double QualityToJPEGCompression(double c , double alpha ) 
{ 
  double amin ;
  double amax ;
  double exp_min ;
  double exp_max ;
  double slope ;
  double expn ;
  double tmp ;
  double tmp___0 ;
  double v ;
  double __cil_tmp12 ;

  {
#line 343
  amin = 0.3;
#line 344
  amax = 0.85;
#line 345
  exp_min = 0.400000000001;
#line 346
  exp_max = 0.900000000001;
#line 347
  slope = (exp_min - exp_max) / (amax - amin);
#line 350
  if (alpha > amax) {
#line 350
    tmp___0 = exp_min;
  } else {
#line 350
    if (alpha < amin) {
#line 350
      tmp = exp_max;
    } else {
#line 350
      tmp = exp_max + slope * (alpha - amin);
    }
#line 350
    tmp___0 = tmp;
  }
  {
#line 350
  expn = tmp___0;
#line 353
  __cil_tmp12 = pow(c, expn);
#line 353
  v = __cil_tmp12;
  }
#line 354
  return (v);
}
}
#line 357 "/root/patron-new/new_3/src/enc/quant_enc.c"
static int SegmentsAreEquivalent(VP8SegmentInfo *S1 , VP8SegmentInfo *S2 ) 
{ 
  int tmp ;

  {
#line 359
  if (S1->quant_ == S2->quant_) {
#line 359
    if (S1->fstrength_ == S2->fstrength_) {
#line 359
      tmp = 1;
    } else {
#line 359
      tmp = 0;
    }
  } else {
#line 359
    tmp = 0;
  }
#line 359
  return (tmp);
}
}
#line 362 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void SimplifySegments(VP8Encoder *enc ) 
{ 
  int map[4] ;
  int num_segments ;
  int tmp ;
  int num_final_segments ;
  int s1 ;
  int s2 ;
  VP8SegmentInfo *S1 ;
  int found ;
  VP8SegmentInfo *S2 ;
  int __cil_tmp11 ;
  int i ;
  int __cil_tmp13 ;

  {
#line 363
  map[0] = 0;
#line 363
  map[1] = 1;
#line 363
  map[2] = 2;
#line 363
  map[3] = 3;
#line 367
  if (enc->segment_hdr_.num_segments_ < 4) {
#line 367
    tmp = enc->segment_hdr_.num_segments_;
  } else {
#line 367
    tmp = 4;
  }
#line 367
  num_segments = tmp;
#line 370
  num_final_segments = 1;
#line 372
  s1 = 1;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;

#line 372
    if (! (s1 < num_segments)) {
#line 372
      goto while_break;
    }
#line 373
    S1 = & enc->dqm_[s1];
#line 374
    found = 0;
#line 376
    s2 = 0;
    {
#line 376
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 376
      if (! (s2 < num_final_segments)) {
#line 376
        goto while_break___0;
      }
      {
#line 377
      S2 = & enc->dqm_[s2];
#line 378
      __cil_tmp11 = SegmentsAreEquivalent(S1, S2);
      }
#line 378
      if (__cil_tmp11) {
#line 379
        found = 1;
#line 380
        goto while_break___0;
      }
#line 376
      s2 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 383
    map[s1] = s2;
#line 384
    if (! found) {
#line 385
      if (num_final_segments != s1) {
#line 386
        enc->dqm_[num_final_segments] = enc->dqm_[s1];
      }
#line 388
      num_final_segments ++;
    }
#line 372
    s1 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 391
  if (num_final_segments < num_segments) {
#line 392
    i = enc->mb_w_ * enc->mb_h_;
    {
#line 393
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 393
      __cil_tmp13 = i;
#line 393
      i --;
#line 393
      if (! (__cil_tmp13 > 0)) {
#line 393
        goto while_break___1;
      }
#line 393
      (enc->mb_info_ + i)->segment_ = (unsigned int )map[(enc->mb_info_ + i)->segment_];
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 394
    enc->segment_hdr_.num_segments_ = num_final_segments;
#line 396
    i = num_final_segments;
    {
#line 396
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 396
      if (! (i < num_segments)) {
#line 396
        goto while_break___2;
      }
#line 397
      enc->dqm_[i] = enc->dqm_[num_final_segments - 1];
#line 396
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 401
  return;
}
}
#line 402 "/root/patron-new/new_3/src/enc/quant_enc.c"
void VP8SetSegmentParams(VP8Encoder *enc , float quality ) 
{ 
  int i ;
  int dq_uv_ac ;
  int dq_uv_dc ;
  int num_segments ;
  double amp ;
  double Q ;
  double c_base ;
  double __cil_tmp10 ;
  double __cil_tmp11 ;
  double tmp ;
  double expn ;
  double c ;
  double __cil_tmp15 ;
  int q ;

  {
#line 405
  num_segments = enc->segment_hdr_.num_segments_;
#line 406
  amp = ((0.900000000001 * (double )(enc->config_)->sns_strength) / 100.) / 128.;
#line 407
  Q = (double )quality / 100.;
#line 408
  if ((enc->config_)->emulate_jpeg_size) {
    {
#line 408
    __cil_tmp10 = QualityToJPEGCompression(Q, (double )enc->alpha_ / 255.);
#line 408
    tmp = __cil_tmp10;
    }
  } else {
    {
#line 408
    __cil_tmp11 = QualityToCompression(Q);
#line 408
    tmp = __cil_tmp11;
    }
  }
#line 408
  c_base = tmp;
#line 411
  i = 0;
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;

#line 411
    if (! (i < num_segments)) {
#line 411
      goto while_break;
    }
    {
#line 414
    expn = 1. - amp * (double )enc->dqm_[i].alpha_;
#line 415
    __cil_tmp15 = pow(c_base, expn);
#line 415
    c = __cil_tmp15;
#line 416
    q = (int )(127. * (1. - c));
#line 418
    enc->dqm_[i].quant_ = clip(q, 0, 127);
#line 411
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 422
  enc->base_quant_ = enc->dqm_[0].quant_;
#line 425
  i = num_segments;
  {
#line 425
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 425
    if (! (i < 4)) {
#line 425
      goto while_break___0;
    }
#line 426
    enc->dqm_[i].quant_ = enc->base_quant_;
#line 425
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 432
  dq_uv_ac = ((enc->uv_alpha_ - 64) * 10) / 70;
#line 435
  dq_uv_ac = (dq_uv_ac * (enc->config_)->sns_strength) / 100;
#line 437
  dq_uv_ac = clip(dq_uv_ac, -4, 6);
#line 441
  dq_uv_dc = (-4 * (enc->config_)->sns_strength) / 100;
#line 442
  dq_uv_dc = clip(dq_uv_dc, -15, 15);
#line 444
  enc->dq_y1_dc_ = 0;
#line 445
  enc->dq_y2_dc_ = 0;
#line 446
  enc->dq_y2_ac_ = 0;
#line 447
  enc->dq_uv_dc_ = dq_uv_dc;
#line 448
  enc->dq_uv_ac_ = dq_uv_ac;
#line 450
  SetupFilterStrength(enc);
  }
#line 452
  if (num_segments > 1) {
    {
#line 452
    SimplifySegments(enc);
    }
  }
  {
#line 454
  SetupMatrices(enc);
  }
#line 456
  return;
}
}
#line 461 "/root/patron-new/new_3/src/enc/quant_enc.c"
uint16_t VP8I16ModeOffsets[4]  = {      (uint16_t )0,      (uint16_t )16,      (uint16_t )512,      (uint16_t )528};
#line 462 "/root/patron-new/new_3/src/enc/quant_enc.c"
uint16_t VP8UVModeOffsets[4]  = {      (uint16_t )1024,      (uint16_t )1040,      (uint16_t )1280,      (uint16_t )1296};
#line 465 "/root/patron-new/new_3/src/enc/quant_enc.c"
uint16_t VP8I4ModeOffsets[10]  = 
#line 465
  {      (uint16_t )1536,      (uint16_t )1540,      (uint16_t )1544,      (uint16_t )1548, 
        (uint16_t )1552,      (uint16_t )1556,      (uint16_t )1560,      (uint16_t )1564, 
        (uint16_t )1664,      (uint16_t )1668};
#line 469 "/root/patron-new/new_3/src/enc/quant_enc.c"
void VP8MakeLuma16Preds(VP8EncIterator *it ) 
{ 
  uint8_t *left ;
  uint8_t *tmp ;
  uint8_t *top ;
  uint8_t *tmp___0 ;

  {
#line 470
  if (it->x_) {
#line 470
    tmp = it->y_left_;
  } else {
#line 470
    tmp = (uint8_t *)((void *)0);
  }
#line 470
  left = tmp;
#line 471
  if (it->y_) {
#line 471
    tmp___0 = it->y_top_;
  } else {
#line 471
    tmp___0 = (uint8_t *)((void *)0);
  }
  {
#line 471
  top = tmp___0;
#line 472
  (*VP8EncPredLuma16)(it->yuv_p_, left, top);
  }
#line 474
  return;
}
}
#line 475 "/root/patron-new/new_3/src/enc/quant_enc.c"
void VP8MakeChroma8Preds(VP8EncIterator *it ) 
{ 
  uint8_t *left ;
  uint8_t *tmp ;
  uint8_t *top ;
  uint8_t *tmp___0 ;

  {
#line 476
  if (it->x_) {
#line 476
    tmp = it->u_left_;
  } else {
#line 476
    tmp = (uint8_t *)((void *)0);
  }
#line 476
  left = tmp;
#line 477
  if (it->y_) {
#line 477
    tmp___0 = it->uv_top_;
  } else {
#line 477
    tmp___0 = (uint8_t *)((void *)0);
  }
  {
#line 477
  top = tmp___0;
#line 478
  (*VP8EncPredChroma8)(it->yuv_p_, left, top);
  }
#line 480
  return;
}
}
#line 481 "/root/patron-new/new_3/src/enc/quant_enc.c"
void VP8MakeIntra4Preds(VP8EncIterator *it ) 
{ 


  {
  {
#line 482
  (*VP8EncPredLuma4)(it->yuv_p_, it->i4_top_);
  }
#line 484
  return;
}
}
#line 496 "/root/patron-new/new_3/src/enc/quant_enc.c"
uint16_t VP8Scan[16]  = 
#line 496
  {      (uint16_t )0,      (uint16_t )4,      (uint16_t )8,      (uint16_t )12, 
        (uint16_t )128,      (uint16_t )132,      (uint16_t )136,      (uint16_t )140, 
        (uint16_t )256,      (uint16_t )260,      (uint16_t )264,      (uint16_t )268, 
        (uint16_t )384,      (uint16_t )388,      (uint16_t )392,      (uint16_t )396};
#line 503 "/root/patron-new/new_3/src/enc/quant_enc.c"
static uint16_t VP8ScanUV[8]  = 
#line 503
  {      (uint16_t )0,      (uint16_t )4,      (uint16_t )128,      (uint16_t )132, 
        (uint16_t )8,      (uint16_t )12,      (uint16_t )136,      (uint16_t )140};
#line 511 "/root/patron-new/new_3/src/enc/quant_enc.c"
static uint16_t kWeightY[16]  = 
#line 511
  {      (uint16_t )38,      (uint16_t )32,      (uint16_t )20,      (uint16_t )9, 
        (uint16_t )32,      (uint16_t )28,      (uint16_t )17,      (uint16_t )7, 
        (uint16_t )20,      (uint16_t )17,      (uint16_t )10,      (uint16_t )4, 
        (uint16_t )9,      (uint16_t )7,      (uint16_t )4,      (uint16_t )2};
#line 515 "/root/patron-new/new_3/src/enc/quant_enc.c"
static uint16_t kWeightTrellis[16]  = 
#line 515
  {      (uint16_t )30,      (uint16_t )27,      (uint16_t )19,      (uint16_t )11, 
        (uint16_t )27,      (uint16_t )24,      (uint16_t )17,      (uint16_t )10, 
        (uint16_t )19,      (uint16_t )17,      (uint16_t )12,      (uint16_t )8, 
        (uint16_t )11,      (uint16_t )10,      (uint16_t )8,      (uint16_t )6};
#line 527 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void InitScore(VP8ModeScore *rd ) 
{ 


  {
#line 528
  rd->D = (score_t )0;
#line 529
  rd->SD = (score_t )0;
#line 530
  rd->R = (score_t )0;
#line 531
  rd->H = (score_t )0;
#line 532
  rd->nz = (uint32_t )0;
#line 533
  rd->score = (score_t )36028797018963967LL;
#line 534
  return;
}
}
#line 536 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void CopyScore(VP8ModeScore *dst , VP8ModeScore *src ) 
{ 


  {
#line 537
  dst->D = src->D;
#line 538
  dst->SD = src->SD;
#line 539
  dst->R = src->R;
#line 540
  dst->H = src->H;
#line 541
  dst->nz = src->nz;
#line 542
  dst->score = src->score;
#line 543
  return;
}
}
#line 545 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void AddScore(VP8ModeScore *dst , VP8ModeScore *src ) 
{ 


  {
#line 546
  dst->D += src->D;
#line 547
  dst->SD += src->SD;
#line 548
  dst->R += src->R;
#line 549
  dst->H += src->H;
#line 550
  dst->nz |= src->nz;
#line 551
  dst->score += src->score;
#line 552
  return;
}
}
#line 579 "/root/patron-new/new_3/src/enc/quant_enc.c"
__inline static void SetRDScore(int lambda , VP8ModeScore *rd ) 
{ 


  {
#line 580
  rd->score = (rd->R + rd->H) * (long )lambda + 256L * (rd->D + rd->SD);
#line 581
  return;
}
}
#line 583 "/root/patron-new/new_3/src/enc/quant_enc.c"
__inline static score_t RDScoreTrellis(int lambda , score_t rate , score_t distortion ) 
{ 


  {
#line 585
  return (rate * (long )lambda + 256L * distortion);
}
}
#line 588 "/root/patron-new/new_3/src/enc/quant_enc.c"
static int TrellisQuantizeBlock(VP8Encoder *enc , int16_t *in , int16_t *out , int ctx0 ,
                                int coeff_type , VP8Matrix *mtx , int lambda ) 
{ 
  ProbaArray *probas ;
  CostArrayPtr costs ;
  int first ;
  int tmp ;
  Node nodes[16][2] ;
  ScoreState score_states[2][2] ;
  ScoreState *ss_cur ;
  ScoreState *ss_prev ;
  int best_path[3] ;
  score_t best_score ;
  int n ;
  int m ;
  int p ;
  int last ;
  score_t cost ;
  int thresh ;
  int last_proba ;
  int j ;
  int err ;
  int __cil_tmp27 ;
  score_t rate ;
  int __cil_tmp30 ;
  int tmp___0 ;
  int j___0 ;
  uint32_t Q ;
  uint32_t iQ ;
  uint32_t B ;
  int sign ;
  uint32_t coeff0 ;
  int tmp___1 ;
  int level0 ;
  int __cil_tmp41 ;
  int thresh_level ;
  int __cil_tmp43 ;
  ScoreState *tmp___2 ;
  Node *cur ;
  int level ;
  int ctx ;
  int tmp___3 ;
  int band ;
  score_t base_score ;
  score_t best_cur_score ;
  int best_prev ;
  int new_error ;
  int delta_error ;
  score_t cost___0 ;
  int __cil_tmp57 ;
  score_t score ;
  score_t __cil_tmp59 ;
  score_t last_pos_cost ;
  int __cil_tmp61 ;
  int tmp___4 ;
  score_t last_pos_score ;
  score_t __cil_tmp64 ;
  score_t score___0 ;
  int nz ;
  int best_node ;
  Node *node ;
  int j___1 ;
  int tmp___5 ;

  {
#line 593
  probas = enc->proba_.coeffs_[coeff_type];
#line 594
  costs = enc->proba_.remapped_costs_[coeff_type];
#line 596
  if (coeff_type == 0) {
#line 596
    tmp = 1;
  } else {
#line 596
    tmp = 0;
  }
#line 596
  first = tmp;
#line 599
  ss_cur = & score_states[0][0];
#line 600
  ss_prev = & score_states[1][0];
#line 601
  best_path[0] = -1;
#line 601
  best_path[1] = -1;
#line 601
  best_path[2] = -1;
#line 607
  thresh = ((int )mtx->q_[1] * (int )mtx->q_[1]) / 4;
#line 608
  last_proba = (int )(*(probas + (int )VP8EncBands[first]))[ctx0][0];
#line 611
  last = first - 1;
#line 612
  n = 15;
  {
#line 612
  while (1) {
    while_continue: /* CIL Label */ ;

#line 612
    if (! (n >= first)) {
#line 612
      goto while_break;
    }
#line 613
    j = (int )kZigzag[n];
#line 614
    err = (int )*(in + j) * (int )*(in + j);
#line 615
    if (err > thresh) {
#line 616
      last = n;
#line 617
      goto while_break;
    }
#line 612
    n --;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 622
  if (last < 15) {
#line 622
    last ++;
  }
  {
#line 625
  __cil_tmp27 = VP8BitCost(0, (uint8_t )last_proba);
#line 625
  cost = (score_t )__cil_tmp27;
#line 626
  best_score = RDScoreTrellis(lambda, cost, (score_t )0);
#line 629
  m = 0;
  }
  {
#line 629
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 629
    if (! (m <= 1)) {
#line 629
      goto while_break___0;
    }
#line 630
    if (ctx0 == 0) {
      {
#line 630
      __cil_tmp30 = VP8BitCost(1, (uint8_t )last_proba);
#line 630
      tmp___0 = __cil_tmp30;
      }
    } else {
#line 630
      tmp___0 = 0;
    }
    {
#line 630
    rate = (score_t )tmp___0;
#line 631
    (ss_cur + m)->score = RDScoreTrellis(lambda, rate, (score_t )0);
#line 632
    (ss_cur + m)->costs = (*(costs + first))[ctx0];
#line 629
    m ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 637
  n = first;
  {
#line 637
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 637
    if (! (n <= last)) {
#line 637
      goto while_break___1;
    }
#line 638
    j___0 = (int )kZigzag[n];
#line 639
    Q = (uint32_t )mtx->q_[j___0];
#line 640
    iQ = (uint32_t )mtx->iq_[j___0];
#line 641
    B = (uint32_t )0;
#line 644
    sign = (int )*(in + j___0) < 0;
#line 645
    if (sign) {
#line 645
      tmp___1 = - ((int )*(in + j___0));
    } else {
#line 645
      tmp___1 = (int )*(in + j___0);
    }
    {
#line 645
    coeff0 = (uint32_t )(tmp___1 + (int )mtx->sharpen_[j___0]);
#line 646
    __cil_tmp41 = QUANTDIV(coeff0, iQ, B);
#line 646
    level0 = __cil_tmp41;
#line 647
    __cil_tmp43 = QUANTDIV(coeff0, iQ, (uint32_t )(128 << 9));
#line 647
    thresh_level = __cil_tmp43;
    }
#line 648
    if (thresh_level > 2047) {
#line 648
      thresh_level = 2047;
    }
#line 649
    if (level0 > 2047) {
#line 649
      level0 = 2047;
    }
#line 652
    tmp___2 = ss_cur;
#line 653
    ss_cur = ss_prev;
#line 654
    ss_prev = tmp___2;
#line 658
    m = 0;
    {
#line 658
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___2: ;
#line 658
      if (! (m <= 1)) {
#line 658
        goto while_break___2;
      }
#line 659
      cur = & nodes[n][m];
#line 660
      level = level0 + m;
#line 661
      if (level > 2) {
#line 661
        tmp___3 = 2;
      } else {
#line 661
        tmp___3 = level;
      }
#line 661
      ctx = tmp___3;
#line 662
      band = (int )VP8EncBands[n + 1];
#line 664
      best_cur_score = (score_t )36028797018963967LL;
#line 665
      best_prev = 0;
#line 667
      (ss_cur + m)->score = (score_t )36028797018963967LL;
#line 668
      (ss_cur + m)->costs = (*(costs + (n + 1)))[ctx];
#line 669
      if (level < 0) {
#line 671
        goto while_continue___2;
      } else
#line 669
      if (level > thresh_level) {
#line 671
        goto while_continue___2;
      }
      {
#line 678
      new_error = (int )(coeff0 - (unsigned int )level * Q);
#line 679
      delta_error = (int )((unsigned int )kWeightTrellis[j___0] * ((unsigned int )(new_error * new_error) - coeff0 * coeff0));
#line 681
      base_score = RDScoreTrellis(lambda, (score_t )0, (score_t )delta_error);
#line 685
      p = 0;
      }
      {
#line 685
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 685
        if (! (p <= 1)) {
#line 685
          goto while_break___3;
        }
        {
#line 688
        __cil_tmp57 = VP8LevelCost((ss_prev + p)->costs, level);
#line 688
        cost___0 = (score_t )__cil_tmp57;
#line 690
        __cil_tmp59 = RDScoreTrellis(lambda, cost___0, (score_t )0);
#line 690
        score = (base_score + (ss_prev + p)->score) + __cil_tmp59;
        }
#line 692
        if (score < best_cur_score) {
#line 693
          best_cur_score = score;
#line 694
          best_prev = p;
        }
#line 685
        p ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: 
#line 698
      cur->sign = (int8_t )sign;
#line 699
      cur->level = (int16_t )level;
#line 700
      cur->prev = (int8_t )best_prev;
#line 701
      (ss_cur + m)->score = best_cur_score;
#line 704
      if (level != 0) {
#line 705
        if (n < 15) {
          {
#line 705
          __cil_tmp61 = VP8BitCost(0, (*(probas + band))[ctx][0]);
#line 705
          tmp___4 = __cil_tmp61;
          }
        } else {
#line 705
          tmp___4 = 0;
        }
        {
#line 705
        last_pos_cost = (score_t )tmp___4;
#line 707
        __cil_tmp64 = RDScoreTrellis(lambda, last_pos_cost, (score_t )0);
#line 707
        last_pos_score = __cil_tmp64;
#line 708
        score___0 = best_cur_score + last_pos_score;
        }
#line 709
        if (score___0 < best_score) {
#line 710
          best_score = score___0;
#line 711
          best_path[0] = n;
#line 712
          best_path[1] = m;
#line 713
          best_path[2] = best_prev;
        }
      }
#line 658
      m ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: 
#line 637
    n ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 720
  memset((void *)(in + first), 0, (unsigned long )(16 - first) * sizeof(*(in + 0)));
#line 721
  memset((void *)(out + first), 0, (unsigned long )(16 - first) * sizeof(*(out + 0)));
  }
#line 722
  if (best_path[0] == -1) {
#line 723
    return (0);
  }
#line 730
  nz = 0;
#line 731
  best_node = best_path[1];
#line 732
  n = best_path[0];
#line 733
  nodes[n][best_node].prev = (int8_t )best_path[2];
  {
#line 735
  while (1) {
    while_continue___7: /* CIL Label */ ;

#line 735
    if (! (n >= first)) {
#line 735
      goto while_break___4;
    }
#line 736
    node = & nodes[n][best_node];
#line 737
    j___1 = (int )kZigzag[n];
#line 738
    if ((int )node->sign) {
#line 738
      tmp___5 = - ((int )node->level);
    } else {
#line 738
      tmp___5 = (int )node->level;
    }
#line 738
    *(out + n) = (int16_t )tmp___5;
#line 739
    nz |= (int )node->level;
#line 740
    *(in + j___1) = (int16_t )((int )*(out + n) * (int )mtx->q_[j___1]);
#line 741
    best_node = (int )node->prev;
#line 735
    n --;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___4: ;
#line 743
  return (nz != 0);
}
}
#line 754 "/root/patron-new/new_3/src/enc/quant_enc.c"
static int ReconstructIntra16(VP8EncIterator *it , VP8ModeScore *rd , uint8_t *yuv_out ,
                              int mode ) 
{ 
  VP8Encoder *enc ;
  uint8_t *ref ;
  uint8_t *src ;
  VP8SegmentInfo *dqm ;
  int nz ;
  int n ;
  int16_t tmp[16][16] ;
  int16_t dc_tmp[16] ;
  int __cil_tmp13 ;
  int x ;
  int y ;
  int ctx ;
  int non_zero ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 758
  enc = it->enc_;
#line 759
  ref = it->yuv_p_ + (int )VP8I16ModeOffsets[mode];
#line 760
  src = it->yuv_in_ + 0;
#line 761
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 762
  nz = 0;
#line 766
  n = 0;
  {
#line 766
  while (1) {
    while_continue: /* CIL Label */ ;

#line 766
    if (! (n < 16)) {
#line 766
      goto while_break;
    }
    {
#line 767
    (*VP8FTransform2)(src + (int )VP8Scan[n], ref + (int )VP8Scan[n], tmp[n]);
#line 766
    n += 2;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 769
  (*VP8FTransformWHT)(tmp[0], dc_tmp);
#line 770
  __cil_tmp13 = (*VP8EncQuantizeBlockWHT)((int16_t *)(dc_tmp), (int16_t *)(rd->y_dc_levels),
                                          (struct VP8Matrix */* const  */)(& dqm->y2_));
#line 770
  nz |= __cil_tmp13 << 24;
  }
#line 772
  if (it->do_trellis_) {
    {
#line 774
    VP8IteratorNzToBytes(it);
#line 775
    n = 0;
#line 775
    y = 0;
    }
    {
#line 775
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 775
      if (! (y < 4)) {
#line 775
        goto while_break___0;
      }
#line 776
      x = 0;
      {
#line 776
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 776
        if (! (x < 4)) {
#line 776
          goto while_break___1;
        }
        {
#line 777
        ctx = it->top_nz_[x] + it->left_nz_[y];
#line 778
        __cil_tmp18 = TrellisQuantizeBlock(enc, (int16_t *)(tmp[n]), (int16_t *)(rd->y_ac_levels[n]),
                                           ctx, 0, & dqm->y1_, dqm->lambda_trellis_i16_);
#line 778
        non_zero = __cil_tmp18;
#line 781
        it->left_nz_[y] = non_zero;
#line 781
        it->top_nz_[x] = it->left_nz_[y];
#line 782
        rd->y_ac_levels[n][0] = (int16_t )0;
#line 783
        nz |= non_zero << n;
#line 776
        n ++;
#line 776
        x ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
#line 775
      y ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: ;
  } else {
#line 787
    n = 0;
    {
#line 787
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 787
      if (! (n < 16)) {
#line 787
        goto while_break___2;
      }
      {
#line 790
      tmp[n + 1][0] = (int16_t )0;
#line 790
      tmp[n][0] = tmp[n + 1][0];
#line 791
      __cil_tmp19 = (*VP8EncQuantize2Blocks)((int16_t *)(tmp[n]), (int16_t *)(rd->y_ac_levels[n]),
                                             (struct VP8Matrix */* const  */)(& dqm->y1_));
#line 791
      nz |= __cil_tmp19 << n;
#line 787
      n += 2;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: ;
  }
  {
#line 798
  (*VP8TransformWHT)(dc_tmp, tmp[0]);
#line 799
  n = 0;
  }
  {
#line 799
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 799
    if (! (n < 16)) {
#line 799
      goto while_break___3;
    }
    {
#line 800
    (*VP8ITransform)(ref + (int )VP8Scan[n], tmp[n], yuv_out + (int )VP8Scan[n], 1);
#line 799
    n += 2;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: ;
#line 803
  return (nz);
}
}
#line 806 "/root/patron-new/new_3/src/enc/quant_enc.c"
static int ReconstructIntra4(VP8EncIterator *it , int16_t *levels , uint8_t *src ,
                             uint8_t *yuv_out , int mode ) 
{ 
  VP8Encoder *enc ;
  uint8_t *ref ;
  VP8SegmentInfo *dqm ;
  int nz ;
  int16_t tmp[16] ;
  int x ;
  int y ;
  int ctx ;

  {
  {
#line 811
  enc = it->enc_;
#line 812
  ref = it->yuv_p_ + (int )VP8I4ModeOffsets[mode];
#line 813
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 814
  nz = 0;
#line 817
  (*VP8FTransform)(src, ref, tmp);
  }
#line 818
  if (it->do_trellis_) {
    {
#line 819
    x = it->i4_ & 3;
#line 819
    y = it->i4_ >> 2;
#line 820
    ctx = it->top_nz_[x] + it->left_nz_[y];
#line 821
    nz = TrellisQuantizeBlock(enc, (int16_t *)(tmp), levels, ctx, 3, & dqm->y1_, dqm->lambda_trellis_i4_);
    }
  } else {
    {
#line 824
    nz = (*VP8EncQuantizeBlock)((int16_t *)(tmp), levels, (struct VP8Matrix */* const  */)(& dqm->y1_));
    }
  }
  {
#line 826
  (*VP8ITransform)(ref, tmp, yuv_out, 0);
  }
#line 827
  return (nz);
}
}
#line 842 "/root/patron-new/new_3/src/enc/quant_enc.c"
static int QuantizeSingle(int16_t *v , VP8Matrix *mtx ) 
{ 
  int V ;
  int sign ;
  int qV ;
  int __cil_tmp6 ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 843
  V = (int )*v;
#line 844
  sign = V < 0;
#line 845
  if (sign) {
#line 845
    V = - V;
  }
#line 846
  if (V > (int )mtx->zthresh_[0]) {
    {
#line 847
    __cil_tmp6 = QUANTDIV((uint32_t )V, (uint32_t )mtx->iq_[0], mtx->bias_[0]);
#line 847
    qV = __cil_tmp6 * (int )mtx->q_[0];
#line 848
    err = V - qV;
    }
#line 849
    if (sign) {
#line 849
      tmp = - qV;
    } else {
#line 849
      tmp = qV;
    }
#line 849
    *v = (int16_t )tmp;
#line 850
    if (sign) {
#line 850
      tmp___0 = - err;
    } else {
#line 850
      tmp___0 = err;
    }
#line 850
    return (tmp___0 >> 1);
  }
#line 852
  *v = (int16_t )0;
#line 853
  if (sign) {
#line 853
    tmp___1 = - V;
  } else {
#line 853
    tmp___1 = V;
  }
#line 853
  return (tmp___1 >> 1);
}
}
#line 856 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void CorrectDCValues(VP8EncIterator *it , VP8Matrix *mtx , int16_t (*tmp)[16] ,
                            VP8ModeScore *rd ) 
{ 
  int ch ;
  int8_t *top ;
  int8_t *left ;
  int16_t (*c)[16] ;
  int err0 ;
  int err1 ;
  int err2 ;
  int err3 ;

  {
#line 867
  ch = 0;
  {
#line 867
  while (1) {
    while_continue: /* CIL Label */ ;

#line 867
    if (! (ch <= 1)) {
#line 867
      goto while_break;
    }
    {
#line 868
    top = (*(it->top_derr_ + it->x_))[ch];
#line 869
    left = it->left_derr_[ch];
#line 870
    c = tmp + ch * 4;
#line 872
    (*(c + 0))[0] = (int16_t )((int )(*(c + 0))[0] + ((7 * (int )*(top + 0) + 8 * (int )*(left + 0)) >> 3));
#line 873
    err0 = QuantizeSingle(& (*(c + 0))[0], mtx);
#line 874
    (*(c + 1))[0] = (int16_t )((int )(*(c + 1))[0] + ((7 * (int )*(top + 1) + 8 * err0) >> 3));
#line 875
    err1 = QuantizeSingle(& (*(c + 1))[0], mtx);
#line 876
    (*(c + 2))[0] = (int16_t )((int )(*(c + 2))[0] + ((7 * err0 + 8 * (int )*(left + 1)) >> 3));
#line 877
    err2 = QuantizeSingle(& (*(c + 2))[0], mtx);
#line 878
    (*(c + 3))[0] = (int16_t )((int )(*(c + 3))[0] + ((7 * err1 + 8 * err2) >> 3));
#line 879
    err3 = QuantizeSingle(& (*(c + 3))[0], mtx);
#line 883
    rd->derr[ch][0] = (int8_t )err1;
#line 884
    rd->derr[ch][1] = (int8_t )err2;
#line 885
    rd->derr[ch][2] = (int8_t )err3;
#line 867
    ch ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 871
  return;
}
}
#line 889 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void StoreDiffusionErrors(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  int ch ;
  int8_t *top ;
  int8_t *left ;

  {
#line 892
  ch = 0;
  {
#line 892
  while (1) {
    while_continue: /* CIL Label */ ;

#line 892
    if (! (ch <= 1)) {
#line 892
      goto while_break;
    }
#line 893
    top = (*(it->top_derr_ + it->x_))[ch];
#line 894
    left = it->left_derr_[ch];
#line 895
    *(left + 0) = rd->derr[ch][0];
#line 896
    *(left + 1) = (int8_t )(3 * (int )rd->derr[ch][2] >> 2);
#line 897
    *(top + 0) = rd->derr[ch][1];
#line 898
    *(top + 1) = (int8_t )((int )rd->derr[ch][2] - (int )*(left + 1));
#line 892
    ch ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 896
  return;
}
}
#line 909 "/root/patron-new/new_3/src/enc/quant_enc.c"
static int ReconstructUV(VP8EncIterator *it , VP8ModeScore *rd , uint8_t *yuv_out ,
                         int mode ) 
{ 
  VP8Encoder *enc ;
  uint8_t *ref ;
  uint8_t *src ;
  VP8SegmentInfo *dqm ;
  int nz ;
  int n ;
  int16_t tmp[8][16] ;
  int ch ;
  int x ;
  int y ;
  int ctx ;
  int non_zero ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 911
  enc = it->enc_;
#line 912
  ref = it->yuv_p_ + (int )VP8UVModeOffsets[mode];
#line 913
  src = it->yuv_in_ + 16;
#line 914
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 915
  nz = 0;
#line 919
  n = 0;
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;

#line 919
    if (! (n < 8)) {
#line 919
      goto while_break;
    }
    {
#line 920
    (*VP8FTransform2)(src + (int )VP8ScanUV[n], ref + (int )VP8ScanUV[n], tmp[n]);
#line 919
    n += 2;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 922
  if ((unsigned long )it->top_derr_ != (unsigned long )((void *)0)) {
    {
#line 922
    CorrectDCValues(it, & dqm->uv_, tmp, rd);
    }
  }
#line 924
  if (0) {
#line 926
    n = 0;
#line 926
    ch = 0;
    {
#line 926
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 926
      if (! (ch <= 2)) {
#line 926
        goto while_break___0;
      }
#line 927
      y = 0;
      {
#line 927
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 927
        if (! (y < 2)) {
#line 927
          goto while_break___1;
        }
#line 928
        x = 0;
        {
#line 928
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 928
          if (! (x < 2)) {
#line 928
            goto while_break___2;
          }
          {
#line 929
          ctx = it->top_nz_[(4 + ch) + x] + it->left_nz_[(4 + ch) + y];
#line 930
          __cil_tmp17 = TrellisQuantizeBlock(enc, (int16_t *)(tmp[n]), (int16_t *)(rd->uv_levels[n]),
                                             ctx, 2, & dqm->uv_, dqm->lambda_trellis_uv_);
#line 930
          non_zero = __cil_tmp17;
#line 933
          it->left_nz_[(4 + ch) + y] = non_zero;
#line 933
          it->top_nz_[(4 + ch) + x] = it->left_nz_[(4 + ch) + y];
#line 934
          nz |= non_zero << n;
#line 928
          n ++;
#line 928
          x ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: 
#line 927
        y ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: 
#line 926
      ch += 2;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: ;
  } else {
#line 939
    n = 0;
    {
#line 939
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 939
      if (! (n < 8)) {
#line 939
        goto while_break___3;
      }
      {
#line 940
      __cil_tmp18 = (*VP8EncQuantize2Blocks)((int16_t *)(tmp[n]), (int16_t *)(rd->uv_levels[n]),
                                             (struct VP8Matrix */* const  */)(& dqm->uv_));
#line 940
      nz |= __cil_tmp18 << n;
#line 939
      n += 2;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: ;
  }
#line 944
  n = 0;
  {
#line 944
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 944
    if (! (n < 8)) {
#line 944
      goto while_break___4;
    }
    {
#line 945
    (*VP8ITransform)(ref + (int )VP8ScanUV[n], tmp[n], yuv_out + (int )VP8ScanUV[n],
                     1);
#line 944
    n += 2;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___4: ;
#line 947
  return (nz << 16);
}
}
#line 954 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void StoreMaxDelta(VP8SegmentInfo *dqm , int16_t *DCs ) 
{ 
  int v0 ;
  int __cil_tmp4 ;
  int v1 ;
  int __cil_tmp6 ;
  int v2 ;
  int __cil_tmp8 ;
  int max_v ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 957
  __cil_tmp4 = abs((int )*(DCs + 1));
#line 957
  v0 = __cil_tmp4;
#line 958
  __cil_tmp6 = abs((int )*(DCs + 2));
#line 958
  v1 = __cil_tmp6;
#line 959
  __cil_tmp8 = abs((int )*(DCs + 4));
#line 959
  v2 = __cil_tmp8;
  }
#line 960
  if (v1 > v0) {
#line 960
    tmp = v1;
  } else {
#line 960
    tmp = v0;
  }
#line 960
  max_v = tmp;
#line 961
  if (v2 > max_v) {
#line 961
    tmp___0 = v2;
  } else {
#line 961
    tmp___0 = max_v;
  }
#line 961
  max_v = tmp___0;
#line 962
  if (max_v > dqm->max_edge_) {
#line 962
    dqm->max_edge_ = max_v;
  }
#line 964
  return;
}
}
#line 965 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void SwapModeScore(VP8ModeScore **a , VP8ModeScore **b ) 
{ 
  VP8ModeScore *tmp ;

  {
#line 966
  tmp = *a;
#line 967
  *a = *b;
#line 968
  *b = tmp;
#line 969
  return;
}
}
#line 971 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void SwapPtr(uint8_t **a , uint8_t **b ) 
{ 
  uint8_t *tmp ;

  {
#line 972
  tmp = *a;
#line 973
  *a = *b;
#line 974
  *b = tmp;
#line 975
  return;
}
}
#line 977 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void SwapOut(VP8EncIterator *it ) 
{ 


  {
  {
#line 978
  SwapPtr(& it->yuv_out_, & it->yuv_out2_);
  }
#line 980
  return;
}
}
#line 981 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void PickBestIntra16(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  int kNumBlocks ;
  VP8SegmentInfo *dqm ;
  int lambda ;
  int tlambda ;
  uint8_t *src ;
  VP8ModeScore rd_tmp ;
  VP8ModeScore *rd_cur ;
  VP8ModeScore *rd_best ;
  int mode ;
  int is_flat ;
  int __cil_tmp13 ;
  uint8_t *tmp_dst ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp ;
  int __cil_tmp19 ;

  {
  {
#line 982
  kNumBlocks = 16;
#line 983
  dqm = & (it->enc_)->dqm_[(it->mb_)->segment_];
#line 984
  lambda = dqm->lambda_i16_;
#line 985
  tlambda = dqm->tlambda_;
#line 986
  src = it->yuv_in_ + 0;
#line 988
  rd_cur = & rd_tmp;
#line 989
  rd_best = rd;
#line 991
  __cil_tmp13 = IsFlatSource16(it->yuv_in_ + 0);
#line 991
  is_flat = __cil_tmp13;
#line 993
  rd->mode_i16 = -1;
#line 994
  mode = 0;
  }
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;

#line 994
    if (! (mode < 4)) {
#line 994
      goto while_break;
    }
    {
#line 995
    tmp_dst = it->yuv_out2_ + 0;
#line 996
    rd_cur->mode_i16 = mode;
#line 999
    __cil_tmp15 = ReconstructIntra16(it, rd_cur, tmp_dst, mode);
#line 999
    rd_cur->nz = (uint32_t )__cil_tmp15;
#line 1002
    __cil_tmp16 = (*VP8SSE16x16)(src, tmp_dst);
#line 1002
    rd_cur->D = (score_t )__cil_tmp16;
    }
#line 1003
    if (tlambda) {
      {
#line 1003
      __cil_tmp17 = (*VP8TDisto16x16)(src, tmp_dst, (uint16_t */* const  */)(kWeightY));
#line 1003
      tmp = (tlambda * __cil_tmp17 + 128) >> 8;
      }
    } else {
#line 1003
      tmp = 0;
    }
    {
#line 1003
    rd_cur->SD = (score_t )tmp;
#line 1005
    rd_cur->H = (score_t )VP8FixedCostsI16[mode];
#line 1006
    __cil_tmp19 = VP8GetCostLuma16(it, rd_cur);
#line 1006
    rd_cur->R = (score_t )__cil_tmp19;
    }
#line 1007
    if (is_flat) {
      {
#line 1009
      is_flat = IsFlat_C(rd_cur->y_ac_levels[0], kNumBlocks, 0);
      }
#line 1010
      if (is_flat) {
#line 1012
        rd_cur->D *= 2L;
#line 1013
        rd_cur->SD *= 2L;
      }
    }
    {
#line 1018
    SetRDScore(lambda, rd_cur);
    }
#line 1019
    if (mode == 0) {
      {
#line 1020
      SwapModeScore(& rd_cur, & rd_best);
#line 1021
      SwapOut(it);
      }
    } else
#line 1019
    if (rd_cur->score < rd_best->score) {
      {
#line 1020
      SwapModeScore(& rd_cur, & rd_best);
#line 1021
      SwapOut(it);
      }
    }
#line 994
    mode ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1024
  if ((unsigned long )rd_best != (unsigned long )rd) {
    {
#line 1025
    memcpy((void *)rd, (void const   *)rd_best, sizeof(*rd));
    }
  }
  {
#line 1027
  SetRDScore(dqm->lambda_mode_, rd);
#line 1028
  VP8SetIntra16Mode(it, rd->mode_i16);
  }
#line 1033
  if ((rd->nz & 16842751U) == 16777216U) {
#line 1033
    if (rd->D > (long )dqm->min_disto_) {
      {
#line 1034
      StoreMaxDelta(dqm, (int16_t *)(rd->y_dc_levels));
      }
    }
  }
#line 1038
  return;
}
}
#line 1041 "/root/patron-new/new_3/src/enc/quant_enc.c"
static uint16_t *GetCostModeI4(VP8EncIterator *it , uint8_t *modes ) 
{ 
  int preds_w ;
  int x ;
  int y ;
  int left ;
  int tmp ;
  int top ;
  int tmp___0 ;

  {
#line 1043
  preds_w = (it->enc_)->preds_w_;
#line 1044
  x = it->i4_ & 3;
#line 1044
  y = it->i4_ >> 2;
#line 1045
  if (x == 0) {
#line 1045
    tmp = (int )*(it->preds_ + (y * preds_w - 1));
  } else {
#line 1045
    tmp = (int )*(modes + (it->i4_ - 1));
  }
#line 1045
  left = tmp;
#line 1046
  if (y == 0) {
#line 1046
    tmp___0 = (int )*(it->preds_ + (- preds_w + x));
  } else {
#line 1046
    tmp___0 = (int )*(modes + (it->i4_ - 4));
  }
#line 1046
  top = tmp___0;
#line 1047
  return (VP8FixedCostsI4[top][left]);
}
}
#line 1050 "/root/patron-new/new_3/src/enc/quant_enc.c"
static int PickBestIntra4(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Encoder *enc ;
  VP8SegmentInfo *dqm ;
  int lambda ;
  int tlambda ;
  uint8_t *src0 ;
  uint8_t *best_blocks ;
  int total_header_bits ;
  VP8ModeScore rd_best ;
  int __cil_tmp11 ;
  int kNumBlocks ;
  VP8ModeScore rd_i4 ;
  int mode ;
  int best_mode ;
  uint8_t *src ;
  uint16_t *mode_costs ;
  uint16_t *__cil_tmp18 ;
  uint8_t *best_block ;
  uint8_t *tmp_dst ;
  VP8ModeScore rd_tmp ;
  int16_t tmp_levels[16] ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int tmp ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int tmp___0 ;

  {
#line 1051
  enc = it->enc_;
#line 1052
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 1053
  lambda = dqm->lambda_i4_;
#line 1054
  tlambda = dqm->tlambda_;
#line 1055
  src0 = it->yuv_in_ + 0;
#line 1056
  best_blocks = it->yuv_out2_ + 0;
#line 1057
  total_header_bits = 0;
#line 1060
  if (enc->max_i4_header_bits_ == 0) {
#line 1061
    return (0);
  }
  {
#line 1064
  InitScore(& rd_best);
#line 1065
  rd_best.H = (score_t )211;
#line 1066
  SetRDScore(dqm->lambda_mode_, & rd_best);
#line 1067
  VP8IteratorStartI4(it);
  }
  {
#line 1068
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1069
    kNumBlocks = 1;
#line 1072
    best_mode = -1;
#line 1073
    src = src0 + (int )VP8Scan[it->i4_];
#line 1074
    __cil_tmp18 = GetCostModeI4(it, (uint8_t *)(rd->modes_i4));
#line 1074
    mode_costs = __cil_tmp18;
#line 1075
    best_block = best_blocks + (int )VP8Scan[it->i4_];
#line 1076
    tmp_dst = it->yuv_p_ + 1672;
#line 1078
    InitScore(& rd_i4);
#line 1079
    VP8MakeIntra4Preds(it);
#line 1080
    mode = 0;
    }
    {
#line 1080
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue___0: ;
#line 1080
      if (! (mode < 10)) {
#line 1080
        goto while_break___0;
      }
      {
#line 1085
      __cil_tmp23 = ReconstructIntra4(it, (int16_t *)(tmp_levels), src, tmp_dst, mode);
#line 1085
      rd_tmp.nz = (uint32_t )(__cil_tmp23 << it->i4_);
#line 1089
      __cil_tmp24 = (*VP8SSE4x4)(src, tmp_dst);
#line 1089
      rd_tmp.D = (score_t )__cil_tmp24;
      }
#line 1090
      if (tlambda) {
        {
#line 1090
        __cil_tmp25 = (*VP8TDisto4x4)(src, tmp_dst, (uint16_t */* const  */)(kWeightY));
#line 1090
        tmp = (tlambda * __cil_tmp25 + 128) >> 8;
        }
      } else {
#line 1090
        tmp = 0;
      }
      {
#line 1090
      rd_tmp.SD = (score_t )tmp;
#line 1093
      rd_tmp.H = (score_t )*(mode_costs + mode);
#line 1097
      __cil_tmp27 = IsFlat_C(tmp_levels, kNumBlocks, 3);
      }
#line 1097
      if (mode > 0) {
#line 1097
        if (__cil_tmp27) {
#line 1098
          rd_tmp.R = (score_t )(140 * kNumBlocks);
        } else {
#line 1100
          rd_tmp.R = (score_t )0;
        }
      } else {
#line 1100
        rd_tmp.R = (score_t )0;
      }
      {
#line 1104
      SetRDScore(lambda, & rd_tmp);
      }
#line 1105
      if (best_mode >= 0) {
#line 1105
        if (rd_tmp.score >= rd_i4.score) {
#line 1105
          goto while_continue___0;
        }
      }
      {
#line 1108
      __cil_tmp28 = VP8GetCostLuma4(it, (int16_t *)(tmp_levels));
#line 1108
      rd_tmp.R += (long )__cil_tmp28;
#line 1109
      SetRDScore(lambda, & rd_tmp);
      }
#line 1111
      if (best_mode < 0) {
        {
#line 1112
        CopyScore(& rd_i4, & rd_tmp);
#line 1113
        best_mode = mode;
#line 1114
        SwapPtr(& tmp_dst, & best_block);
#line 1115
        memcpy((void *)(rd_best.y_ac_levels[it->i4_]), (void const   *)(tmp_levels),
               sizeof(rd_best.y_ac_levels[it->i4_]));
        }
      } else
#line 1111
      if (rd_tmp.score < rd_i4.score) {
        {
#line 1112
        CopyScore(& rd_i4, & rd_tmp);
#line 1113
        best_mode = mode;
#line 1114
        SwapPtr(& tmp_dst, & best_block);
#line 1115
        memcpy((void *)(rd_best.y_ac_levels[it->i4_]), (void const   *)(tmp_levels),
               sizeof(rd_best.y_ac_levels[it->i4_]));
        }
      }
#line 1080
      mode ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 1119
    SetRDScore(dqm->lambda_mode_, & rd_i4);
#line 1120
    AddScore(& rd_best, & rd_i4);
    }
#line 1121
    if (rd_best.score >= rd->score) {
#line 1122
      return (0);
    }
#line 1124
    total_header_bits += (int )rd_i4.H;
#line 1125
    if (total_header_bits > enc->max_i4_header_bits_) {
#line 1126
      return (0);
    }
#line 1129
    if ((unsigned long )best_block != (unsigned long )(best_blocks + (int )VP8Scan[it->i4_])) {
      {
#line 1130
      (*VP8Copy4x4)(best_block, best_blocks + (int )VP8Scan[it->i4_]);
      }
    }
#line 1132
    rd->modes_i4[it->i4_] = (uint8_t )best_mode;
#line 1133
    if (rd_i4.nz) {
#line 1133
      tmp___0 = 1;
    } else {
#line 1133
      tmp___0 = 0;
    }
#line 1133
    it->left_nz_[it->i4_ >> 2] = tmp___0;
#line 1133
    it->top_nz_[it->i4_ & 3] = it->left_nz_[it->i4_ >> 2];
#line 1068
    if (! __cil_tmp11) {
#line 1068
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1137
  CopyScore(rd, & rd_best);
#line 1138
  VP8SetIntra4Mode(it, rd->modes_i4);
#line 1139
  SwapOut(it);
#line 1140
  memcpy((void *)(rd->y_ac_levels), (void const   *)(rd_best.y_ac_levels), sizeof(rd->y_ac_levels));
  }
#line 1141
  return (1);
}
}
#line 1146 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void PickBestUV(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  int kNumBlocks ;
  VP8SegmentInfo *dqm ;
  int lambda ;
  uint8_t *src ;
  uint8_t *tmp_dst ;
  uint8_t *dst0 ;
  uint8_t *dst ;
  VP8ModeScore rd_best ;
  int mode ;
  VP8ModeScore rd_uv ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 1147
  kNumBlocks = 8;
#line 1148
  dqm = & (it->enc_)->dqm_[(it->mb_)->segment_];
#line 1149
  lambda = dqm->lambda_uv_;
#line 1150
  src = it->yuv_in_ + 16;
#line 1151
  tmp_dst = it->yuv_out2_ + 16;
#line 1152
  dst0 = it->yuv_out_ + 16;
#line 1153
  dst = dst0;
#line 1157
  rd->mode_uv = -1;
#line 1158
  InitScore(& rd_best);
#line 1159
  mode = 0;
  }
  {
#line 1159
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1159
    if (! (mode < 4)) {
#line 1159
      goto while_break;
    }
    {
#line 1163
    __cil_tmp13 = ReconstructUV(it, & rd_uv, tmp_dst, mode);
#line 1163
    rd_uv.nz = (uint32_t )__cil_tmp13;
#line 1166
    __cil_tmp14 = (*VP8SSE16x8)(src, tmp_dst);
#line 1166
    rd_uv.D = (score_t )__cil_tmp14;
#line 1167
    rd_uv.SD = (score_t )0;
#line 1168
    rd_uv.H = (score_t )VP8FixedCostsUV[mode];
#line 1169
    __cil_tmp15 = VP8GetCostUV(it, & rd_uv);
#line 1169
    rd_uv.R = (score_t )__cil_tmp15;
#line 1170
    __cil_tmp16 = IsFlat_C(rd_uv.uv_levels[0], kNumBlocks, 2);
    }
#line 1170
    if (mode > 0) {
#line 1170
      if (__cil_tmp16) {
#line 1171
        rd_uv.R += (long )(140 * kNumBlocks);
      }
    }
    {
#line 1174
    SetRDScore(lambda, & rd_uv);
    }
#line 1175
    if (mode == 0) {
      _L: 
      {
#line 1176
      CopyScore(& rd_best, & rd_uv);
#line 1177
      rd->mode_uv = mode;
#line 1178
      memcpy((void *)(rd->uv_levels), (void const   *)(rd_uv.uv_levels), sizeof(rd->uv_levels));
      }
#line 1179
      if ((unsigned long )it->top_derr_ != (unsigned long )((void *)0)) {
        {
#line 1180
        memcpy((void *)(rd->derr), (void const   *)(rd_uv.derr), sizeof(rd_uv.derr));
        }
      }
      {
#line 1182
      SwapPtr(& dst, & tmp_dst);
      }
    } else
#line 1175
    if (rd_uv.score < rd_best.score) {
#line 1175
      goto _L;
    }
#line 1159
    mode ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1185
  VP8SetIntraUVMode(it, rd->mode_uv);
#line 1186
  AddScore(rd, & rd_best);
  }
#line 1187
  if ((unsigned long )dst != (unsigned long )dst0) {
    {
#line 1188
    (*VP8Copy16x8)(dst, dst0);
    }
  }
#line 1190
  if ((unsigned long )it->top_derr_ != (unsigned long )((void *)0)) {
    {
#line 1191
    StoreDiffusionErrors(it, rd);
    }
  }
#line 1194
  return;
}
}
#line 1198 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void SimpleQuantize(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Encoder *enc ;
  int is_i16 ;
  int nz ;
  int __cil_tmp7 ;
  int mode ;
  uint8_t *src ;
  uint8_t *dst ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 1199
  enc = it->enc_;
#line 1200
  is_i16 = (int )(it->mb_)->type_ == 1;
#line 1201
  nz = 0;
#line 1203
  if (is_i16) {
    {
#line 1204
    nz = ReconstructIntra16(it, rd, it->yuv_out_ + 0, (int )*(it->preds_ + 0));
    }
  } else {
    {
#line 1206
    VP8IteratorStartI4(it);
    }
    {
#line 1207
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1208
      mode = (int )*(it->preds_ + ((it->i4_ & 3) + (it->i4_ >> 2) * enc->preds_w_));
#line 1210
      src = (it->yuv_in_ + 0) + (int )VP8Scan[it->i4_];
#line 1211
      dst = (it->yuv_out_ + 0) + (int )VP8Scan[it->i4_];
#line 1212
      VP8MakeIntra4Preds(it);
#line 1213
      __cil_tmp11 = ReconstructIntra4(it, (int16_t *)(rd->y_ac_levels[it->i4_]), src,
                                      dst, mode);
#line 1213
      nz |= __cil_tmp11 << it->i4_;
      }
#line 1207
      if (! __cil_tmp7) {
#line 1207
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 1218
  __cil_tmp12 = ReconstructUV(it, rd, it->yuv_out_ + 16, (int )(it->mb_)->uv_mode_);
#line 1218
  nz |= __cil_tmp12;
#line 1219
  rd->nz = (uint32_t )nz;
  }
#line 1220
  return;
}
}
#line 1223 "/root/patron-new/new_3/src/enc/quant_enc.c"
static void RefineUsingDistortion(VP8EncIterator *it , int try_both_modes , int refine_uv_mode ,
                                  VP8ModeScore *rd ) 
{ 
  score_t best_score ;
  int nz ;
  int mode ;
  int is_i16 ;
  VP8SegmentInfo *dqm ;
  int lambda_d_i16 ;
  int lambda_d_i4 ;
  int lambda_d_uv ;
  score_t score_i4 ;
  score_t i4_bit_sum ;
  score_t bit_limit ;
  long tmp ;
  int best_mode ;
  uint8_t *src ;
  uint8_t *ref ;
  score_t score ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int tmp___0 ;
  int __cil_tmp24 ;
  int best_i4_mode ;
  score_t best_i4_score ;
  uint8_t *src___0 ;
  uint16_t *mode_costs ;
  uint16_t *__cil_tmp29 ;
  uint8_t *ref___0 ;
  score_t score___0 ;
  int __cil_tmp32 ;
  uint8_t *tmp_dst ;
  int __cil_tmp34 ;
  int best_mode___0 ;
  score_t best_uv_score ;
  uint8_t *src___1 ;
  uint8_t *ref___1 ;
  score_t score___1 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int tmp___1 ;

  {
#line 1226
  best_score = (score_t )36028797018963967LL;
#line 1227
  nz = 0;
#line 1229
  if (try_both_modes) {
#line 1229
    tmp___1 = 1;
  } else
#line 1229
  if ((int )(it->mb_)->type_ == 1) {
#line 1229
    tmp___1 = 1;
  } else {
#line 1229
    tmp___1 = 0;
  }
#line 1229
  is_i16 = tmp___1;
#line 1231
  dqm = & (it->enc_)->dqm_[(it->mb_)->segment_];
#line 1233
  lambda_d_i16 = 106;
#line 1234
  lambda_d_i4 = 11;
#line 1235
  lambda_d_uv = 120;
#line 1236
  score_i4 = dqm->i4_penalty_;
#line 1237
  i4_bit_sum = (score_t )0;
#line 1238
  if (try_both_modes) {
#line 1238
    tmp = (long )(it->enc_)->mb_header_limit_;
  } else {
#line 1238
    tmp = (score_t )36028797018963967LL;
  }
#line 1238
  bit_limit = tmp;
#line 1241
  if (is_i16) {
#line 1242
    best_mode = -1;
#line 1243
    src = it->yuv_in_ + 0;
#line 1244
    mode = 0;
    {
#line 1244
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: ;
#line 1244
      if (! (mode < 4)) {
#line 1244
        goto while_break;
      }
      {
#line 1245
      ref = it->yuv_p_ + (int )VP8I16ModeOffsets[mode];
#line 1246
      __cil_tmp21 = (*VP8SSE16x16)(src, ref);
#line 1246
      score = (score_t )__cil_tmp21 * 256L + (long )((int )VP8FixedCostsI16[mode] * lambda_d_i16);
      }
#line 1248
      if (mode > 0) {
#line 1248
        if ((long )VP8FixedCostsI16[mode] > bit_limit) {
#line 1249
          goto while_continue;
        }
      }
#line 1252
      if (score < best_score) {
#line 1253
        best_mode = mode;
#line 1254
        best_score = score;
      }
#line 1244
      mode ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
#line 1257
    if (it->x_ == 0) {
      _L: 
      {
#line 1259
      __cil_tmp22 = IsFlatSource16(src);
      }
#line 1259
      if (__cil_tmp22) {
#line 1260
        if (it->x_ == 0) {
#line 1260
          tmp___0 = 0;
        } else {
#line 1260
          tmp___0 = 2;
        }
#line 1260
        best_mode = tmp___0;
#line 1261
        try_both_modes = 0;
      }
    } else
#line 1257
    if (it->y_ == 0) {
#line 1257
      goto _L;
    }
    {
#line 1264
    VP8SetIntra16Mode(it, best_mode);
    }
  }
#line 1269
  if (try_both_modes) {
    _L___13: 
    {
#line 1272
    is_i16 = 0;
#line 1273
    VP8IteratorStartI4(it);
    }
    {
#line 1274
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1275
      best_i4_mode = -1;
#line 1276
      best_i4_score = (score_t )36028797018963967LL;
#line 1277
      src___0 = (it->yuv_in_ + 0) + (int )VP8Scan[it->i4_];
#line 1278
      __cil_tmp29 = GetCostModeI4(it, (uint8_t *)(rd->modes_i4));
#line 1278
      mode_costs = __cil_tmp29;
#line 1280
      VP8MakeIntra4Preds(it);
#line 1281
      mode = 0;
      }
      {
#line 1281
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1281
        if (! (mode < 10)) {
#line 1281
          goto while_break___1;
        }
        {
#line 1282
        ref___0 = it->yuv_p_ + (int )VP8I4ModeOffsets[mode];
#line 1283
        __cil_tmp32 = (*VP8SSE4x4)(src___0, ref___0);
#line 1283
        score___0 = (score_t )(__cil_tmp32 * 256 + (int )*(mode_costs + mode) * lambda_d_i4);
        }
#line 1285
        if (score___0 < best_i4_score) {
#line 1286
          best_i4_mode = mode;
#line 1287
          best_i4_score = score___0;
        }
#line 1281
        mode ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 1290
      i4_bit_sum += (long )*(mode_costs + best_i4_mode);
#line 1291
      rd->modes_i4[it->i4_] = (uint8_t )best_i4_mode;
#line 1292
      score_i4 += best_i4_score;
#line 1293
      if (score_i4 >= best_score) {
#line 1295
        is_i16 = 1;
#line 1296
        goto while_break___0;
      } else
#line 1293
      if (i4_bit_sum > bit_limit) {
#line 1295
        is_i16 = 1;
#line 1296
        goto while_break___0;
      } else {
        {
#line 1298
        tmp_dst = (it->yuv_out2_ + 0) + (int )VP8Scan[it->i4_];
#line 1299
        __cil_tmp34 = ReconstructIntra4(it, (int16_t *)(rd->y_ac_levels[it->i4_]),
                                        src___0, tmp_dst, best_i4_mode);
#line 1299
        nz |= __cil_tmp34 << it->i4_;
        }
      }
#line 1274
      if (! __cil_tmp24) {
#line 1274
        goto while_break___0;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: ;
  } else
#line 1269
  if (! is_i16) {
#line 1269
    goto _L___13;
  }
#line 1306
  if (! is_i16) {
    {
#line 1307
    VP8SetIntra4Mode(it, rd->modes_i4);
#line 1308
    SwapOut(it);
#line 1309
    best_score = score_i4;
    }
  } else {
    {
#line 1311
    nz = ReconstructIntra16(it, rd, it->yuv_out_ + 0, (int )*(it->preds_ + 0));
    }
  }
#line 1315
  if (refine_uv_mode) {
#line 1316
    best_mode___0 = -1;
#line 1317
    best_uv_score = (score_t )36028797018963967LL;
#line 1318
    src___1 = it->yuv_in_ + 16;
#line 1319
    mode = 0;
    {
#line 1319
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 1319
      if (! (mode < 4)) {
#line 1319
        goto while_break___2;
      }
      {
#line 1320
      ref___1 = it->yuv_p_ + (int )VP8UVModeOffsets[mode];
#line 1321
      __cil_tmp41 = (*VP8SSE16x8)(src___1, ref___1);
#line 1321
      score___1 = (score_t )(__cil_tmp41 * 256 + (int )VP8FixedCostsUV[mode] * lambda_d_uv);
      }
#line 1323
      if (score___1 < best_uv_score) {
#line 1324
        best_mode___0 = mode;
#line 1325
        best_uv_score = score___1;
      }
#line 1319
      mode ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 1328
    VP8SetIntraUVMode(it, best_mode___0);
    }
  }
  {
#line 1330
  __cil_tmp42 = ReconstructUV(it, rd, it->yuv_out_ + 16, (int )(it->mb_)->uv_mode_);
#line 1330
  nz |= __cil_tmp42;
#line 1332
  rd->nz = (uint32_t )nz;
#line 1333
  rd->score = best_score;
  }
#line 1334
  return;
}
}
#line 1339 "/root/patron-new/new_3/src/enc/quant_enc.c"
int VP8Decimate(VP8EncIterator *it , VP8ModeScore *rd , VP8RDLevel rd_opt ) 
{ 
  int is_skipped ;
  int method ;

  {
  {
#line 1342
  method = (it->enc_)->method_;
#line 1344
  InitScore(rd);
#line 1348
  VP8MakeLuma16Preds(it);
#line 1349
  VP8MakeChroma8Preds(it);
  }
#line 1351
  if ((unsigned int )rd_opt > 0U) {
    {
#line 1352
    it->do_trellis_ = (unsigned int )rd_opt >= 3U;
#line 1353
    PickBestIntra16(it, rd);
    }
#line 1354
    if (method >= 2) {
      {
#line 1355
      PickBestIntra4(it, rd);
      }
    }
    {
#line 1357
    PickBestUV(it, rd);
    }
#line 1358
    if ((unsigned int )rd_opt == 2U) {
      {
#line 1359
      it->do_trellis_ = 1;
#line 1360
      SimpleQuantize(it, rd);
      }
    }
  } else {
    {
#line 1367
    RefineUsingDistortion(it, method >= 2, method >= 1, rd);
    }
  }
  {
#line 1369
  is_skipped = rd->nz == 0U;
#line 1370
  VP8SetSkip(it, is_skipped);
  }
#line 1371
  return (is_skipped);
}
}
#line 23 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static float const   kSpatialPredictorBias  =    (float const   )15.f;
#line 24 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static int const   kPredLowEffort  =    (int const   )11;
#line 25 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static uint32_t kMaskAlpha  =    4278190080U;
#line 28 "/root/patron-new/new_3/src/enc/predictor_enc.c"
__inline static int GetMin(int a , int b ) 
{ 
  int tmp ;

  {
#line 28
  if (a > b) {
#line 28
    tmp = b;
  } else {
#line 28
    tmp = a;
  }
#line 28
  return (tmp);
}
}
#line 33 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static float PredictionCostSpatial(int const   *counts , int weight_0 , double exp_val ) 
{ 
  int significant_symbols ;
  double exp_decay_factor ;
  double bits ;
  int i ;

  {
#line 35
  significant_symbols = 256 >> 4;
#line 36
  exp_decay_factor = 0.6;
#line 37
  bits = (double )(weight_0 * (int )*(counts + 0));
#line 39
  i = 1;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;

#line 39
    if (! (i < significant_symbols)) {
#line 39
      goto while_break;
    }
#line 40
    bits += exp_val * (double )(*(counts + i) + *(counts + (256 - i)));
#line 41
    exp_val *= exp_decay_factor;
#line 39
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 43
  return ((float )(- 0.100000000001 * bits));
}
}
#line 46 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static float PredictionCostSpatialHistogram(int const   (*accumulated)[256] , int const   (*tile)[256] ) 
{ 
  int i ;
  double retval ;
  double kExpValue ;
  float __cil_tmp6 ;
  float __cil_tmp7 ;

  {
#line 49
  retval = (double )0;
#line 50
  i = 0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;

#line 50
    if (! (i < 4)) {
#line 50
      goto while_break;
    }
    {
#line 51
    kExpValue = 0.94;
#line 52
    __cil_tmp6 = PredictionCostSpatial((int const   *)(*(tile + i)), 1, kExpValue);
#line 52
    retval += (double )__cil_tmp6;
#line 53
    __cil_tmp7 = (*VP8LCombinedShannonEntropy)((int const   *)(*(tile + i)), (int const   *)(*(accumulated + i)));
#line 53
    retval += (double )__cil_tmp7;
#line 50
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 55
  return ((float )retval);
}
}
#line 58 "/root/patron-new/new_3/src/enc/predictor_enc.c"
__inline static void UpdateHisto(int (*histo_argb)[256] , uint32_t argb ) 
{ 


  {
#line 59
  ((*(histo_argb + 0))[argb >> 24]) ++;
#line 60
  ((*(histo_argb + 1))[(argb >> 16) & 255U]) ++;
#line 61
  ((*(histo_argb + 2))[(argb >> 8) & 255U]) ++;
#line 62
  ((*(histo_argb + 3))[argb & 255U]) ++;
#line 63
  return;
}
}
#line 68 "/root/patron-new/new_3/src/enc/predictor_enc.c"
__inline static void PredictBatch(int mode , int x_start , int y , int num_pixels ,
                                  uint32_t *current , uint32_t *upper , uint32_t *out ) 
{ 


  {
#line 71
  if (x_start == 0) {
#line 72
    if (y == 0) {
      {
#line 74
      (*(VP8LPredictorsSub[0]))(current, (uint32_t *)((void *)0), 1, out);
      }
    } else {
      {
#line 77
      (*(VP8LPredictorsSub[2]))(current, upper, 1, out);
      }
    }
#line 79
    x_start ++;
#line 80
    out ++;
#line 81
    num_pixels --;
  }
#line 83
  if (y == 0) {
    {
#line 85
    (*(VP8LPredictorsSub[1]))(current + x_start, (uint32_t *)((void *)0), num_pixels,
                              out);
    }
  } else {
    {
#line 87
    (*(VP8LPredictorsSub[mode]))(current + x_start, upper + x_start, num_pixels, out);
    }
  }
#line 90
  return;
}
}
#line 93 "/root/patron-new/new_3/src/enc/predictor_enc.c"
__inline static int GetMax(int a , int b ) 
{ 
  int tmp ;

  {
#line 93
  if (a < b) {
#line 93
    tmp = b;
  } else {
#line 93
    tmp = a;
  }
#line 93
  return (tmp);
}
}
#line 95 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static int MaxDiffBetweenPixels(uint32_t p1 , uint32_t p2 ) 
{ 
  int diff_a ;
  int __cil_tmp4 ;
  int diff_r ;
  int __cil_tmp6 ;
  int diff_g ;
  int __cil_tmp8 ;
  int diff_b ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 96
  __cil_tmp4 = abs((int )(p1 >> 24) - (int )(p2 >> 24));
#line 96
  diff_a = __cil_tmp4;
#line 97
  __cil_tmp6 = abs((int )((p1 >> 16) & 255U) - (int )((p2 >> 16) & 255U));
#line 97
  diff_r = __cil_tmp6;
#line 98
  __cil_tmp8 = abs((int )((p1 >> 8) & 255U) - (int )((p2 >> 8) & 255U));
#line 98
  diff_g = __cil_tmp8;
#line 99
  __cil_tmp10 = abs((int )(p1 & 255U) - (int )(p2 & 255U));
#line 99
  diff_b = __cil_tmp10;
#line 100
  __cil_tmp11 = GetMax(diff_a, diff_r);
#line 100
  __cil_tmp12 = GetMax(diff_g, diff_b);
#line 100
  __cil_tmp13 = GetMax(__cil_tmp11, __cil_tmp12);
  }
#line 100
  return (__cil_tmp13);
}
}
#line 103 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static int MaxDiffAroundPixel(uint32_t current , uint32_t up , uint32_t down , uint32_t left ,
                              uint32_t right ) 
{ 
  int diff_up ;
  int __cil_tmp7 ;
  int diff_down ;
  int __cil_tmp9 ;
  int diff_left ;
  int __cil_tmp11 ;
  int diff_right ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 105
  __cil_tmp7 = MaxDiffBetweenPixels(current, up);
#line 105
  diff_up = __cil_tmp7;
#line 106
  __cil_tmp9 = MaxDiffBetweenPixels(current, down);
#line 106
  diff_down = __cil_tmp9;
#line 107
  __cil_tmp11 = MaxDiffBetweenPixels(current, left);
#line 107
  diff_left = __cil_tmp11;
#line 108
  __cil_tmp13 = MaxDiffBetweenPixels(current, right);
#line 108
  diff_right = __cil_tmp13;
#line 109
  __cil_tmp14 = GetMax(diff_up, diff_down);
#line 109
  __cil_tmp15 = GetMax(diff_left, diff_right);
#line 109
  __cil_tmp16 = GetMax(__cil_tmp14, __cil_tmp15);
  }
#line 109
  return (__cil_tmp16);
}
}
#line 112 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static uint32_t AddGreenToBlueAndRed(uint32_t argb ) 
{ 
  uint32_t green ;
  uint32_t red_blue ;

  {
#line 113
  green = (argb >> 8) & 255U;
#line 114
  red_blue = argb & 16711935U;
#line 115
  red_blue += (green << 16) | green;
#line 116
  red_blue &= 16711935U;
#line 117
  return ((argb & 4278255360U) | red_blue);
}
}
#line 120 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static void MaxDiffsForRow(int width , int stride , uint32_t *argb , uint8_t *max_diffs ,
                           int used_subtract_green ) 
{ 
  uint32_t current ;
  uint32_t up ;
  uint32_t down ;
  uint32_t left ;
  uint32_t right ;
  int x ;
  int __cil_tmp17 ;

  {
#line 124
  if (width <= 2) {
#line 124
    return;
  }
#line 125
  current = *(argb + 0);
#line 126
  right = *(argb + 1);
#line 127
  if (used_subtract_green) {
    {
#line 128
    current = AddGreenToBlueAndRed(current);
#line 129
    right = AddGreenToBlueAndRed(right);
    }
  }
#line 132
  x = 1;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;

#line 132
    if (! (x < width - 1)) {
#line 132
      goto while_break;
    }
#line 133
    up = *(argb + (- stride + x));
#line 134
    down = *(argb + (stride + x));
#line 135
    left = current;
#line 136
    current = right;
#line 137
    right = *(argb + (x + 1));
#line 138
    if (used_subtract_green) {
      {
#line 139
      up = AddGreenToBlueAndRed(up);
#line 140
      down = AddGreenToBlueAndRed(down);
#line 141
      right = AddGreenToBlueAndRed(right);
      }
    }
    {
#line 143
    __cil_tmp17 = MaxDiffAroundPixel(current, up, down, left, right);
#line 143
    *(max_diffs + x) = (uint8_t )__cil_tmp17;
#line 132
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 136
  return;
}
}
#line 150 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static uint8_t NearLosslessComponent(uint8_t value , uint8_t predict , uint8_t boundary ,
                                     int quantization ) 
{ 
  int residual ;
  int boundary_residual ;
  int lower ;
  int upper ;
  int bias ;

  {
#line 152
  residual = ((int )value - (int )predict) & 255;
#line 153
  boundary_residual = ((int )boundary - (int )predict) & 255;
#line 154
  lower = residual & ~ (quantization - 1);
#line 155
  upper = lower + quantization;
#line 158
  bias = (((int )boundary - (int )value) & 255) < boundary_residual;
#line 159
  if (residual - lower < (upper - residual) + bias) {
#line 161
    if (residual > boundary_residual) {
#line 161
      if (lower <= boundary_residual) {
#line 165
        return ((uint8_t )(lower + (quantization >> 1)));
      }
    }
#line 167
    return ((uint8_t )lower);
  } else {
#line 170
    if (residual <= boundary_residual) {
#line 170
      if (upper > boundary_residual) {
#line 174
        return ((uint8_t )(lower + (quantization >> 1)));
      }
    }
#line 176
    return ((uint8_t )(upper & 255));
  }
}
}
#line 180 "/root/patron-new/new_3/src/enc/predictor_enc.c"
__inline static uint8_t NearLosslessDiff(uint8_t a , uint8_t b ) 
{ 


  {
#line 181
  return ((uint8_t )(((int )a - (int )b) & 255));
}
}
#line 189 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static uint32_t NearLossless(uint32_t value , uint32_t predict , int max_quantization ,
                             int max_diff , int used_subtract_green ) 
{ 
  int quantization ;
  uint8_t new_green ;
  uint8_t green_diff ;
  uint8_t a ;
  uint8_t r ;
  uint8_t g ;
  uint8_t b ;
  uint32_t __cil_tmp13 ;
  uint8_t __cil_tmp18 ;
  uint8_t __cil_tmp19 ;
  uint8_t __cil_tmp20 ;
  uint8_t __cil_tmp21 ;

  {
#line 193
  new_green = (uint8_t )0;
#line 194
  green_diff = (uint8_t )0;
#line 196
  if (max_diff <= 2) {
    {
#line 197
    __cil_tmp13 = VP8LSubPixels(value, predict);
    }
#line 197
    return (__cil_tmp13);
  }
#line 199
  quantization = max_quantization;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;

#line 200
    if (! (quantization >= max_diff)) {
#line 200
      goto while_break;
    }
#line 201
    quantization >>= 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 203
  if (value >> 24 == 0U) {
    {
#line 205
    a = NearLosslessDiff((uint8_t )((value >> 24) & 255U), (uint8_t )((predict >> 24) & 255U));
    }
  } else
#line 203
  if (value >> 24 == 255U) {
    {
#line 205
    a = NearLosslessDiff((uint8_t )((value >> 24) & 255U), (uint8_t )((predict >> 24) & 255U));
    }
  } else {
    {
#line 207
    a = NearLosslessComponent((uint8_t )(value >> 24), (uint8_t )(predict >> 24),
                              (uint8_t )255, quantization);
    }
  }
  {
#line 209
  g = NearLosslessComponent((uint8_t )((value >> 8) & 255U), (uint8_t )((predict >> 8) & 255U),
                            (uint8_t )255, quantization);
  }
#line 211
  if (used_subtract_green) {
    {
#line 214
    new_green = (uint8_t )(((predict >> 8) + (unsigned int )g) & 255U);
#line 218
    green_diff = NearLosslessDiff(new_green, (uint8_t )((value >> 8) & 255U));
    }
  }
  {
#line 220
  __cil_tmp18 = NearLosslessDiff((uint8_t )((value >> 16) & 255U), green_diff);
#line 220
  __cil_tmp19 = NearLosslessComponent(__cil_tmp18, (uint8_t )((predict >> 16) & 255U),
                                      (uint8_t )(255 - (int )new_green), quantization);
#line 220
  r = __cil_tmp19;
#line 223
  __cil_tmp20 = NearLosslessDiff((uint8_t )(value & 255U), green_diff);
#line 223
  __cil_tmp21 = NearLosslessComponent(__cil_tmp20, (uint8_t )(predict & 255U), (uint8_t )(255 - (int )new_green),
                                      quantization);
#line 223
  b = __cil_tmp21;
  }
#line 225
  return (((((uint32_t )a << 24) | ((uint32_t )r << 16)) | ((uint32_t )g << 8)) | (unsigned int )b);
}
}
#line 233 "/root/patron-new/new_3/src/enc/predictor_enc.c"
__inline static void GetResidual(int width , int height , uint32_t *upper_row , uint32_t *current_row ,
                                 uint8_t *max_diffs , int mode , int x_start , int x_end ,
                                 int y , int max_quantization , int exact , int used_subtract_green ,
                                 uint32_t *out ) 
{ 
  uint32_t (*pred_func)(uint32_t  , uint32_t * const   ) ;
  int x ;
  uint32_t predict ;
  uint32_t residual ;
  unsigned int tmp ;

  {
#line 238
  if (exact) {
    {
#line 239
    PredictBatch(mode, x_start, y, x_end - x_start, current_row, upper_row, out);
    }
  } else {
#line 242
    pred_func = VP8LPredictors[mode];
#line 244
    x = x_start;
    {
#line 244
    while (1) {
      while_continue: /* CIL Label */ ;

#line 244
      if (! (x < x_end)) {
#line 244
        goto while_break;
      }
#line 247
      if (y == 0) {
#line 248
        if (x == 0) {
#line 248
          tmp = 4278190080U;
        } else {
#line 248
          tmp = *(current_row + (x - 1));
        }
#line 248
        predict = tmp;
      } else
#line 249
      if (x == 0) {
#line 250
        predict = *(upper_row + x);
      } else {
        {
#line 252
        predict = (*pred_func)(*(current_row + (x - 1)), (uint32_t */* const  */)(upper_row + x));
        }
      }
#line 255
      if (max_quantization == 1) {
        {
#line 257
        residual = VP8LSubPixels(*(current_row + x), predict);
        }
      } else
#line 255
      if (mode == 0) {
        {
#line 257
        residual = VP8LSubPixels(*(current_row + x), predict);
        }
      } else
#line 255
      if (y == 0) {
        {
#line 257
        residual = VP8LSubPixels(*(current_row + x), predict);
        }
      } else
#line 255
      if (y == height - 1) {
        {
#line 257
        residual = VP8LSubPixels(*(current_row + x), predict);
        }
      } else
#line 255
      if (x == 0) {
        {
#line 257
        residual = VP8LSubPixels(*(current_row + x), predict);
        }
      } else
#line 255
      if (x == width - 1) {
        {
#line 257
        residual = VP8LSubPixels(*(current_row + x), predict);
        }
      } else {
        {
#line 259
        residual = NearLossless(*(current_row + x), predict, max_quantization, (int )*(max_diffs + x),
                                used_subtract_green);
#line 262
        *(current_row + x) = VP8LAddPixels(predict, residual);
        }
      }
#line 272
      if ((*(current_row + x) & kMaskAlpha) == 0U) {
#line 277
        residual &= kMaskAlpha;
#line 279
        *(current_row + x) = predict & ~ kMaskAlpha;
#line 286
        if (x == 0) {
#line 286
          if (y != 0) {
#line 286
            *(upper_row + width) = *(current_row + 0);
          }
        }
      }
#line 288
      *(out + (x - x_start)) = residual;
#line 244
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 249
  return;
}
}
#line 298 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static int GetBestPredictorForTile(int width , int height , int tile_x , int tile_y ,
                                   int bits , int (*accumulated)[256] , uint32_t *argb_scratch ,
                                   uint32_t *argb , int max_quantization , int exact ,
                                   int used_subtract_green , uint32_t *modes ) 
{ 
  int kNumPredModes ;
  int start_x ;
  int start_y ;
  int tile_size ;
  int max_y ;
  int __cil_tmp18 ;
  int max_x ;
  int __cil_tmp20 ;
  int have_left ;
  int context_start_x ;
  int context_width ;
  int tiles_per_row ;
  uint32_t __cil_tmp25 ;
  int left_mode ;
  uint32_t tmp ;
  int above_mode ;
  uint32_t tmp___0 ;
  uint32_t *upper_row ;
  uint32_t *current_row ;
  uint8_t *max_diffs ;
  float best_diff ;
  int best_mode ;
  int mode ;
  int histo_stack_1[4][256] ;
  int histo_stack_2[4][256] ;
  int (*histo_argb)[256] ;
  int (*best_histo)[256] ;
  int i ;
  int j ;
  uint32_t residuals[64] ;
  float cur_diff ;
  int relative_y ;
  int y ;
  int relative_x ;
  uint32_t *tmp___1 ;
  int (*tmp___2)[256] ;

  {
  {
#line 306
  kNumPredModes = 14;
#line 307
  start_x = tile_x << bits;
#line 308
  start_y = tile_y << bits;
#line 309
  tile_size = 1 << bits;
#line 310
  __cil_tmp18 = GetMin(tile_size, height - start_y);
#line 310
  max_y = __cil_tmp18;
#line 311
  __cil_tmp20 = GetMin(tile_size, width - start_x);
#line 311
  max_x = __cil_tmp20;
#line 313
  have_left = start_x > 0;
#line 316
  context_start_x = start_x - have_left;
#line 318
  context_width = (max_x + have_left) + (max_x < width - start_x);
#line 320
  __cil_tmp25 = VP8LSubSampleSize((uint32_t )width, (uint32_t )bits);
#line 320
  tiles_per_row = (int )__cil_tmp25;
  }
#line 322
  if (tile_x > 0) {
#line 322
    tmp = (*(modes + ((tile_y * tiles_per_row + tile_x) - 1)) >> 8) & 255U;
  } else {
#line 322
    tmp = 255U;
  }
#line 322
  left_mode = (int )tmp;
#line 324
  if (tile_y > 0) {
#line 324
    tmp___0 = (*(modes + ((tile_y - 1) * tiles_per_row + tile_x)) >> 8) & 255U;
  } else {
#line 324
    tmp___0 = 255U;
  }
#line 324
  above_mode = (int )tmp___0;
#line 329
  upper_row = argb_scratch;
#line 330
  current_row = (upper_row + width) + 1;
#line 331
  max_diffs = (uint8_t *)((current_row + width) + 1);
#line 332
  best_diff = 1.00000001505e+30f;
#line 333
  best_mode = 0;
#line 338
  histo_argb = histo_stack_1;
#line 339
  best_histo = histo_stack_2;
#line 345
  mode = 0;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;

#line 345
    if (! (mode < kNumPredModes)) {
#line 345
      goto while_break;
    }
    {
#line 348
    memset((void *)histo_argb, 0, sizeof(histo_stack_1));
    }
#line 349
    if (start_y > 0) {
      {
#line 354
      memcpy((void *)(current_row + context_start_x), (void const   *)((argb + (start_y - 1) * width) + context_start_x),
             sizeof(*argb) * (unsigned long )((max_x + have_left) + 1));
      }
    }
#line 358
    relative_y = 0;
    {
#line 358
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 358
      if (! (relative_y < max_y)) {
#line 358
        goto while_break___0;
      }
      {
#line 359
      y = start_y + relative_y;
#line 361
      tmp___1 = upper_row;
#line 362
      upper_row = current_row;
#line 363
      current_row = tmp___1;
#line 368
      memcpy((void *)(current_row + context_start_x), (void const   *)((argb + y * width) + context_start_x),
             sizeof(*argb) * (unsigned long )((max_x + have_left) + (y + 1 < height)));
      }
#line 372
      if (max_quantization > 1) {
#line 372
        if (y >= 1) {
#line 372
          if (y + 1 < height) {
            {
#line 373
            MaxDiffsForRow(context_width, width, (argb + y * width) + context_start_x,
                           max_diffs + context_start_x, used_subtract_green);
            }
          }
        }
      }
      {
#line 378
      GetResidual(width, height, upper_row, current_row, max_diffs, mode, start_x,
                  start_x + max_x, y, max_quantization, exact, used_subtract_green,
                  residuals);
#line 381
      relative_x = 0;
      }
      {
#line 381
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 381
        if (! (relative_x < max_x)) {
#line 381
          goto while_break___1;
        }
        {
#line 382
        UpdateHisto((int (*)[256])histo_argb, residuals[relative_x]);
#line 381
        relative_x ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
#line 358
      relative_y ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 385
    cur_diff = PredictionCostSpatialHistogram((int const   (*)[256])((int const   (*)[256])accumulated),
                                              (int const   (*)[256])((int const   (*)[256])histo_argb));
    }
#line 388
    if (mode == left_mode) {
#line 388
      cur_diff -= (float )kSpatialPredictorBias;
    }
#line 389
    if (mode == above_mode) {
#line 389
      cur_diff -= (float )kSpatialPredictorBias;
    }
#line 391
    if (cur_diff < best_diff) {
#line 392
      tmp___2 = histo_argb;
#line 393
      histo_argb = best_histo;
#line 394
      best_histo = tmp___2;
#line 395
      best_diff = cur_diff;
#line 396
      best_mode = mode;
    }
#line 345
    mode ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 400
  i = 0;
  {
#line 400
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 400
    if (! (i < 4)) {
#line 400
      goto while_break___2;
    }
#line 401
    j = 0;
    {
#line 401
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 401
      if (! (j < 256)) {
#line 401
        goto while_break___3;
      }
#line 402
      (*(accumulated + i))[j] += (*(best_histo + i))[j];
#line 401
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: 
#line 400
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: ;
#line 406
  return (best_mode);
}
}
#line 413 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static void CopyImageWithPrediction(int width , int height , int bits , uint32_t *modes ,
                                    uint32_t *argb_scratch , uint32_t *argb , int low_effort ,
                                    int max_quantization , int exact , int used_subtract_green ) 
{ 
  int tiles_per_row ;
  uint32_t __cil_tmp12 ;
  uint32_t *upper_row ;
  uint32_t *current_row ;
  uint8_t *current_max_diffs ;
  uint8_t *lower_max_diffs ;
  int y ;
  int x ;
  uint32_t *tmp32 ;
  uint8_t *tmp8 ;
  int mode ;
  int x_end ;

  {
  {
#line 419
  __cil_tmp12 = VP8LSubSampleSize((uint32_t )width, (uint32_t )bits);
#line 419
  tiles_per_row = (int )__cil_tmp12;
#line 423
  upper_row = argb_scratch;
#line 424
  current_row = (upper_row + width) + 1;
#line 425
  current_max_diffs = (uint8_t *)((current_row + width) + 1);
#line 427
  lower_max_diffs = current_max_diffs + width;
#line 431
  y = 0;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;

#line 431
    if (! (y < height)) {
#line 431
      goto while_break;
    }
    {
#line 433
    tmp32 = upper_row;
#line 434
    upper_row = current_row;
#line 435
    current_row = tmp32;
#line 436
    memcpy((void *)current_row, (void const   *)(argb + y * width), sizeof(*argb) * (unsigned long )(width + (y + 1 < height)));
    }
#line 439
    if (low_effort) {
      {
#line 440
      PredictBatch((int )kPredLowEffort, 0, y, width, current_row, upper_row, argb + y * width);
      }
    } else {
#line 444
      if (max_quantization > 1) {
#line 448
        tmp8 = current_max_diffs;
#line 449
        current_max_diffs = lower_max_diffs;
#line 450
        lower_max_diffs = tmp8;
#line 451
        if (y + 2 < height) {
          {
#line 452
          MaxDiffsForRow(width, width, argb + (y + 1) * width, lower_max_diffs, used_subtract_green);
          }
        }
      }
#line 457
      x = 0;
      {
#line 457
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 457
        if (! (x < width)) {
#line 457
          goto while_break___0;
        }
#line 458
        mode = (int )((*(modes + ((y >> bits) * tiles_per_row + (x >> bits))) >> 8) & 255U);
#line 460
        x_end = x + (1 << bits);
#line 461
        if (x_end > width) {
#line 461
          x_end = width;
        }
        {
#line 462
        GetResidual(width, height, upper_row, current_row, current_max_diffs, mode,
                    x, x_end, y, max_quantization, exact, used_subtract_green, (argb + y * width) + x);
#line 465
        x = x_end;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
    }
#line 431
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 435
  return;
}
}
#line 475 "/root/patron-new/new_3/src/enc/predictor_enc.c"
void VP8LResidualImage(int width , int height , int bits , int low_effort , uint32_t *argb ,
                       uint32_t *argb_scratch , uint32_t *image , int near_lossless_quality ,
                       int exact , int used_subtract_green ) 
{ 
  int tiles_per_row ;
  uint32_t __cil_tmp12 ;
  int tiles_per_col ;
  uint32_t __cil_tmp14 ;
  int tile_y ;
  int histo[4][256] ;
  int max_quantization ;
  int __cil_tmp18 ;
  int i ;
  int tile_x ;
  int pred ;
  int __cil_tmp22 ;

  {
  {
#line 479
  __cil_tmp12 = VP8LSubSampleSize((uint32_t )width, (uint32_t )bits);
#line 479
  tiles_per_row = (int )__cil_tmp12;
#line 480
  __cil_tmp14 = VP8LSubSampleSize((uint32_t )height, (uint32_t )bits);
#line 480
  tiles_per_col = (int )__cil_tmp14;
#line 483
  __cil_tmp18 = VP8LNearLosslessBits(near_lossless_quality);
#line 483
  max_quantization = 1 << __cil_tmp18;
  }
#line 484
  if (low_effort) {
#line 486
    i = 0;
    {
#line 486
    while (1) {
      while_continue: /* CIL Label */ ;

#line 486
      if (! (i < tiles_per_row * tiles_per_col)) {
#line 486
        goto while_break;
      }
#line 487
      *(image + i) = 4278190080U | (unsigned int )(kPredLowEffort << 8);
#line 486
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 490
    memset((void *)(histo), 0, sizeof(histo));
#line 491
    tile_y = 0;
    }
    {
#line 491
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 491
      if (! (tile_y < tiles_per_col)) {
#line 491
        goto while_break___0;
      }
#line 493
      tile_x = 0;
      {
#line 493
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 493
        if (! (tile_x < tiles_per_row)) {
#line 493
          goto while_break___1;
        }
        {
#line 494
        __cil_tmp22 = GetBestPredictorForTile(width, height, tile_x, tile_y, bits,
                                              (int (*)[256])(histo), argb_scratch,
                                              argb, max_quantization, exact, used_subtract_green,
                                              image);
#line 494
        pred = __cil_tmp22;
#line 497
        *(image + (tile_y * tiles_per_row + tile_x)) = 4278190080U | (unsigned int )(pred << 8);
#line 493
        tile_x ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 491
      tile_y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  {
#line 502
  CopyImageWithPrediction(width, height, bits, image, argb_scratch, argb, low_effort,
                          max_quantization, exact, used_subtract_green);
  }
#line 505
  return;
}
}
#line 510 "/root/patron-new/new_3/src/enc/predictor_enc.c"
__inline static void MultipliersClear(VP8LMultipliers *m ) 
{ 


  {
#line 511
  m->green_to_red_ = (uint8_t )0;
#line 512
  m->green_to_blue_ = (uint8_t )0;
#line 513
  m->red_to_blue_ = (uint8_t )0;
#line 514
  return;
}
}
#line 516 "/root/patron-new/new_3/src/enc/predictor_enc.c"
__inline static void ColorCodeToMultipliers(uint32_t color_code , VP8LMultipliers *m ) 
{ 


  {
#line 518
  m->green_to_red_ = (uint8_t )(color_code & 255U);
#line 519
  m->green_to_blue_ = (uint8_t )((color_code >> 8) & 255U);
#line 520
  m->red_to_blue_ = (uint8_t )((color_code >> 16) & 255U);
#line 521
  return;
}
}
#line 523 "/root/patron-new/new_3/src/enc/predictor_enc.c"
__inline static uint32_t MultipliersToColorCode(VP8LMultipliers *m ) 
{ 


  {
#line 525
  return (((4278190080U | ((uint32_t )m->red_to_blue_ << 16)) | ((uint32_t )m->green_to_blue_ << 8)) | (unsigned int )m->green_to_red_);
}
}
#line 533 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static double kExpValue  ;
#line 531 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static float PredictionCostCrossColor(int const   *accumulated , int const   *counts ) 
{ 
  float __cil_tmp4 ;
  float __cil_tmp5 ;

  {
  {
#line 535
  kExpValue = 2.4;
#line 536
  __cil_tmp5 = PredictionCostSpatial(counts, 3, kExpValue);
#line 536
  __cil_tmp4 = (*VP8LCombinedShannonEntropy)(counts, accumulated);
  }
#line 536
  return (__cil_tmp4 + __cil_tmp5);
}
}
#line 540 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static float GetPredictionCostCrossColorRed(uint32_t *argb , int stride , int tile_width ,
                                            int tile_height , VP8LMultipliers prev_x ,
                                            VP8LMultipliers prev_y , int green_to_red ,
                                            int const   *accumulated_red_histo ) 
{ 
  int histo[256] ;
  unsigned int tmp ;
  float cur_diff ;

  {
#line 544
  histo[0] = 0;
#line 544
  tmp = 1U;
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;

#line 544
    if (tmp >= 256U) {
#line 544
      goto while_break;
    }
#line 544
    histo[tmp] = 0;
#line 544
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 547
  (*VP8LCollectColorRedTransforms)(argb, stride, tile_width, tile_height, green_to_red,
                                   histo);
#line 550
  cur_diff = PredictionCostCrossColor(accumulated_red_histo, (int const   *)((int const   *)(histo)));
  }
#line 551
  if ((int )((uint8_t )green_to_red) == (int )prev_x.green_to_red_) {
#line 552
    cur_diff -= (float )3;
  }
#line 554
  if ((int )((uint8_t )green_to_red) == (int )prev_y.green_to_red_) {
#line 555
    cur_diff -= (float )3;
  }
#line 557
  if (green_to_red == 0) {
#line 558
    cur_diff -= (float )3;
  }
#line 560
  return (cur_diff);
}
}
#line 563 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static void GetBestGreenToRed(uint32_t *argb , int stride , int tile_width , int tile_height ,
                              VP8LMultipliers prev_x , VP8LMultipliers prev_y , int quality ,
                              int const   *accumulated_red_histo , VP8LMultipliers *best_tx ) 
{ 
  int kMaxIters ;
  int green_to_red_best ;
  int iter ;
  int offset ;
  float best_diff ;
  float __cil_tmp15 ;
  int delta ;
  int green_to_red_cur ;
  float cur_diff ;
  float __cil_tmp19 ;

  {
  {
#line 567
  kMaxIters = 4 + (7 * quality >> 8);
#line 568
  green_to_red_best = 0;
#line 570
  __cil_tmp15 = GetPredictionCostCrossColorRed(argb, stride, tile_width, tile_height,
                                               prev_x, prev_y, green_to_red_best,
                                               accumulated_red_histo);
#line 570
  best_diff = __cil_tmp15;
#line 573
  iter = 0;
  }
  {
#line 573
  while (1) {
    while_continue: /* CIL Label */ ;

#line 573
    if (! (iter < kMaxIters)) {
#line 573
      goto while_break;
    }
#line 577
    delta = 32 >> iter;
#line 579
    offset = - delta;
    {
#line 579
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 579
      if (! (offset <= delta)) {
#line 579
        goto while_break___0;
      }
      {
#line 580
      green_to_red_cur = offset + green_to_red_best;
#line 581
      __cil_tmp19 = GetPredictionCostCrossColorRed(argb, stride, tile_width, tile_height,
                                                   prev_x, prev_y, green_to_red_cur,
                                                   accumulated_red_histo);
#line 581
      cur_diff = __cil_tmp19;
      }
#line 584
      if (cur_diff < best_diff) {
#line 585
        best_diff = cur_diff;
#line 586
        green_to_red_best = green_to_red_cur;
      }
#line 579
      offset += 2 * delta;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 573
    iter ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 590
  best_tx->green_to_red_ = (uint8_t )(green_to_red_best & 255);
#line 591
  return;
}
}
#line 593 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static float GetPredictionCostCrossColorBlue(uint32_t *argb , int stride , int tile_width ,
                                             int tile_height , VP8LMultipliers prev_x ,
                                             VP8LMultipliers prev_y , int green_to_blue ,
                                             int red_to_blue , int const   *accumulated_blue_histo ) 
{ 
  int histo[256] ;
  unsigned int tmp ;
  float cur_diff ;

  {
#line 597
  histo[0] = 0;
#line 597
  tmp = 1U;
  {
#line 597
  while (1) {
    while_continue: /* CIL Label */ ;

#line 597
    if (tmp >= 256U) {
#line 597
      goto while_break;
    }
#line 597
    histo[tmp] = 0;
#line 597
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 600
  (*VP8LCollectColorBlueTransforms)(argb, stride, tile_width, tile_height, green_to_blue,
                                    red_to_blue, histo);
#line 603
  cur_diff = PredictionCostCrossColor(accumulated_blue_histo, (int const   *)((int const   *)(histo)));
  }
#line 604
  if ((int )((uint8_t )green_to_blue) == (int )prev_x.green_to_blue_) {
#line 605
    cur_diff -= (float )3;
  }
#line 607
  if ((int )((uint8_t )green_to_blue) == (int )prev_y.green_to_blue_) {
#line 608
    cur_diff -= (float )3;
  }
#line 610
  if ((int )((uint8_t )red_to_blue) == (int )prev_x.red_to_blue_) {
#line 611
    cur_diff -= (float )3;
  }
#line 613
  if ((int )((uint8_t )red_to_blue) == (int )prev_y.red_to_blue_) {
#line 614
    cur_diff -= (float )3;
  }
#line 616
  if (green_to_blue == 0) {
#line 617
    cur_diff -= (float )3;
  }
#line 619
  if (red_to_blue == 0) {
#line 620
    cur_diff -= (float )3;
  }
#line 622
  return (cur_diff);
}
}
#line 627 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static void GetBestGreenRedToBlue(uint32_t *argb , int stride , int tile_width , int tile_height ,
                                  VP8LMultipliers prev_x , VP8LMultipliers prev_y ,
                                  int quality , int const   *accumulated_blue_histo ,
                                  VP8LMultipliers *best_tx ) 
{ 
  int8_t offset[8][2] ;
  int8_t delta_lut[7] ;
  int iters ;
  int tmp ;
  int tmp___0 ;
  int green_to_blue_best ;
  int red_to_blue_best ;
  int iter ;
  float best_diff ;
  float __cil_tmp19 ;
  int delta ;
  int axis ;
  int green_to_blue_cur ;
  int red_to_blue_cur ;
  float cur_diff ;
  float __cil_tmp25 ;

  {
#line 632
  offset[0][0] = (int8_t )0;
#line 632
  offset[0][1] = (int8_t )-1;
#line 632
  offset[1][0] = (int8_t )0;
#line 632
  offset[1][1] = (int8_t )1;
#line 632
  offset[2][0] = (int8_t )-1;
#line 632
  offset[2][1] = (int8_t )0;
#line 632
  offset[3][0] = (int8_t )1;
#line 632
  offset[3][1] = (int8_t )0;
#line 632
  offset[4][0] = (int8_t )-1;
#line 632
  offset[4][1] = (int8_t )-1;
#line 632
  offset[5][0] = (int8_t )-1;
#line 632
  offset[5][1] = (int8_t )1;
#line 632
  offset[6][0] = (int8_t )1;
#line 632
  offset[6][1] = (int8_t )-1;
#line 632
  offset[7][0] = (int8_t )1;
#line 632
  offset[7][1] = (int8_t )1;
#line 634
  delta_lut[0] = (int8_t )16;
#line 634
  delta_lut[1] = (int8_t )16;
#line 634
  delta_lut[2] = (int8_t )8;
#line 634
  delta_lut[3] = (int8_t )4;
#line 634
  delta_lut[4] = (int8_t )2;
#line 634
  delta_lut[5] = (int8_t )2;
#line 634
  delta_lut[6] = (int8_t )2;
#line 635
  if (quality < 25) {
#line 635
    tmp___0 = 1;
  } else {
#line 635
    if (quality > 50) {
#line 635
      tmp = 7;
    } else {
#line 635
      tmp = 4;
    }
#line 635
    tmp___0 = tmp;
  }
  {
#line 635
  iters = tmp___0;
#line 637
  green_to_blue_best = 0;
#line 638
  red_to_blue_best = 0;
#line 641
  __cil_tmp19 = GetPredictionCostCrossColorBlue(argb, stride, tile_width, tile_height,
                                                prev_x, prev_y, green_to_blue_best,
                                                red_to_blue_best, accumulated_blue_histo);
#line 641
  best_diff = __cil_tmp19;
#line 644
  iter = 0;
  }
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;

#line 644
    if (! (iter < iters)) {
#line 644
      goto while_break;
    }
#line 645
    delta = (int )delta_lut[iter];
#line 647
    axis = 0;
    {
#line 647
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 647
      if (! (axis < 8)) {
#line 647
        goto while_break___0;
      }
      {
#line 648
      green_to_blue_cur = (int )offset[axis][0] * delta + green_to_blue_best;
#line 650
      red_to_blue_cur = (int )offset[axis][1] * delta + red_to_blue_best;
#line 651
      __cil_tmp25 = GetPredictionCostCrossColorBlue(argb, stride, tile_width, tile_height,
                                                    prev_x, prev_y, green_to_blue_cur,
                                                    red_to_blue_cur, accumulated_blue_histo);
#line 651
      cur_diff = __cil_tmp25;
      }
#line 654
      if (cur_diff < best_diff) {
#line 655
        best_diff = cur_diff;
#line 656
        green_to_blue_best = green_to_blue_cur;
#line 657
        red_to_blue_best = red_to_blue_cur;
      }
#line 659
      if (quality < 25) {
#line 659
        if (iter == 4) {
#line 661
          goto while_break___0;
        }
      }
#line 647
      axis ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 664
    if (delta == 2) {
#line 664
      if (green_to_blue_best == 0) {
#line 664
        if (red_to_blue_best == 0) {
#line 666
          goto while_break;
        }
      }
    }
#line 644
    iter ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 669
  best_tx->green_to_blue_ = (uint8_t )(green_to_blue_best & 255);
#line 670
  best_tx->red_to_blue_ = (uint8_t )(red_to_blue_best & 255);
#line 671
  return;
}
}
#line 675 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static VP8LMultipliers GetBestColorTransformForTile(int tile_x , int tile_y , int bits ,
                                                    VP8LMultipliers prev_x , VP8LMultipliers prev_y ,
                                                    int quality , int xsize , int ysize ,
                                                    int const   *accumulated_red_histo ,
                                                    int const   *accumulated_blue_histo ,
                                                    uint32_t *argb ) 
{ 
  int max_tile_size ;
  int tile_y_offset ;
  int tile_x_offset ;
  int all_x_max ;
  int __cil_tmp16 ;
  int all_y_max ;
  int __cil_tmp18 ;
  int tile_width ;
  int tile_height ;
  uint32_t *tile_argb ;
  VP8LMultipliers best_tx ;

  {
  {
#line 683
  max_tile_size = 1 << bits;
#line 684
  tile_y_offset = tile_y * max_tile_size;
#line 685
  tile_x_offset = tile_x * max_tile_size;
#line 686
  __cil_tmp16 = GetMin(tile_x_offset + max_tile_size, xsize);
#line 686
  all_x_max = __cil_tmp16;
#line 687
  __cil_tmp18 = GetMin(tile_y_offset + max_tile_size, ysize);
#line 687
  all_y_max = __cil_tmp18;
#line 688
  tile_width = all_x_max - tile_x_offset;
#line 689
  tile_height = all_y_max - tile_y_offset;
#line 690
  tile_argb = (argb + tile_y_offset * xsize) + tile_x_offset;
#line 693
  MultipliersClear(& best_tx);
#line 695
  GetBestGreenToRed(tile_argb, xsize, tile_width, tile_height, prev_x, prev_y, quality,
                    accumulated_red_histo, & best_tx);
#line 697
  GetBestGreenRedToBlue(tile_argb, xsize, tile_width, tile_height, prev_x, prev_y,
                        quality, accumulated_blue_histo, & best_tx);
  }
#line 700
  return (best_tx);
}
}
#line 703 "/root/patron-new/new_3/src/enc/predictor_enc.c"
static void CopyTileWithColorTransform(int xsize , int ysize , int tile_x , int tile_y ,
                                       int max_tile_size , VP8LMultipliers color_transform ,
                                       uint32_t *argb ) 
{ 
  int xscan ;
  int __cil_tmp9 ;
  int yscan ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 708
  __cil_tmp9 = GetMin(max_tile_size, xsize - tile_x);
#line 708
  xscan = __cil_tmp9;
#line 709
  __cil_tmp11 = GetMin(max_tile_size, ysize - tile_y);
#line 709
  yscan = __cil_tmp11;
#line 710
  argb += tile_y * xsize + tile_x;
  }
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 711
    __cil_tmp12 = yscan;
#line 711
    yscan --;
#line 711
    if (! (__cil_tmp12 > 0)) {
#line 711
      goto while_break;
    }
    {
#line 712
    (*VP8LTransformColor)((VP8LMultipliers */* const  */)(& color_transform), argb,
                          xscan);
#line 713
    argb += xsize;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 718
  return;
}
}
#line 717 "/root/patron-new/new_3/src/enc/predictor_enc.c"
void VP8LColorSpaceTransform(int width , int height , int bits , int quality , uint32_t *argb ,
                             uint32_t *image ) 
{ 
  int max_tile_size ;
  int tile_xsize ;
  uint32_t __cil_tmp9 ;
  int tile_ysize ;
  uint32_t __cil_tmp11 ;
  int accumulated_red_histo[256] ;
  unsigned int tmp ;
  int accumulated_blue_histo[256] ;
  unsigned int tmp___0 ;
  int tile_x ;
  int tile_y ;
  VP8LMultipliers prev_x ;
  VP8LMultipliers prev_y ;
  int y ;
  int tile_x_offset ;
  int tile_y_offset ;
  int all_x_max ;
  int __cil_tmp24 ;
  int all_y_max ;
  int __cil_tmp26 ;
  int offset ;
  int ix ;
  int ix_end ;
  uint32_t pix ;

  {
  {
#line 719
  max_tile_size = 1 << bits;
#line 720
  __cil_tmp9 = VP8LSubSampleSize((uint32_t )width, (uint32_t )bits);
#line 720
  tile_xsize = (int )__cil_tmp9;
#line 721
  __cil_tmp11 = VP8LSubSampleSize((uint32_t )height, (uint32_t )bits);
#line 721
  tile_ysize = (int )__cil_tmp11;
#line 722
  accumulated_red_histo[0] = 0;
#line 722
  tmp = 1U;
  }
  {
#line 722
  while (1) {
    while_continue: /* CIL Label */ ;

#line 722
    if (tmp >= 256U) {
#line 722
      goto while_break;
    }
#line 722
    accumulated_red_histo[tmp] = 0;
#line 722
    tmp ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
#line 723
  accumulated_blue_histo[0] = 0;
#line 723
  tmp___0 = 1U;
  {
#line 723
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 723
    if (tmp___0 >= 256U) {
#line 723
      goto while_break___0;
    }
#line 723
    accumulated_blue_histo[tmp___0] = 0;
#line 723
    tmp___0 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 726
  MultipliersClear(& prev_y);
#line 727
  MultipliersClear(& prev_x);
#line 728
  tile_y = 0;
  }
  {
#line 728
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 728
    if (! (tile_y < tile_ysize)) {
#line 728
      goto while_break___1;
    }
#line 729
    tile_x = 0;
    {
#line 729
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 729
      if (! (tile_x < tile_xsize)) {
#line 729
        goto while_break___2;
      }
      {
#line 731
      tile_x_offset = tile_x * max_tile_size;
#line 732
      tile_y_offset = tile_y * max_tile_size;
#line 733
      __cil_tmp24 = GetMin(tile_x_offset + max_tile_size, width);
#line 733
      all_x_max = __cil_tmp24;
#line 734
      __cil_tmp26 = GetMin(tile_y_offset + max_tile_size, height);
#line 734
      all_y_max = __cil_tmp26;
#line 735
      offset = tile_y * tile_xsize + tile_x;
      }
#line 736
      if (tile_y != 0) {
        {
#line 737
        ColorCodeToMultipliers(*(image + (offset - tile_xsize)), & prev_y);
        }
      }
      {
#line 739
      prev_x = GetBestColorTransformForTile(tile_x, tile_y, bits, prev_x, prev_y,
                                            quality, width, height, (int const   *)((int const   *)(accumulated_red_histo)),
                                            (int const   *)((int const   *)(accumulated_blue_histo)),
                                            argb);
#line 745
      *(image + offset) = MultipliersToColorCode(& prev_x);
#line 746
      CopyTileWithColorTransform(width, height, tile_x_offset, tile_y_offset, max_tile_size,
                                 prev_x, argb);
#line 750
      y = tile_y_offset;
      }
      {
#line 750
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 750
        if (! (y < all_y_max)) {
#line 750
          goto while_break___3;
        }
#line 751
        ix = y * width + tile_x_offset;
#line 752
        ix_end = (ix + all_x_max) - tile_x_offset;
        {
#line 753
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___4: ;
#line 753
          if (! (ix < ix_end)) {
#line 753
            goto while_break___4;
          }
#line 754
          pix = *(argb + ix);
#line 755
          if (ix >= 2) {
#line 755
            if (pix == *(argb + (ix - 2))) {
#line 755
              if (pix == *(argb + (ix - 1))) {
#line 758
                goto while_continue___4;
              }
            }
          }
#line 760
          if (ix >= width + 2) {
#line 760
            if (*(argb + (ix - 2)) == *(argb + ((ix - width) - 2))) {
#line 760
              if (*(argb + (ix - 1)) == *(argb + ((ix - width) - 1))) {
#line 760
                if (pix == *(argb + (ix - width))) {
#line 764
                  goto while_continue___4;
                }
              }
            }
          }
#line 766
          (accumulated_red_histo[(pix >> 16) & 255U]) ++;
#line 767
          (accumulated_blue_histo[pix & 255U]) ++;
#line 753
          ix ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___4: 
#line 750
        y ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: 
#line 729
      tile_x ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: 
#line 728
    tile_y ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: ;
#line 732
  return;
}
}
#line 111 "../../src/dec/vp8_dec.h"
int VP8InitIoInternal(VP8Io *io , int version ) ;
#line 116
int WebPISetIOHooks(WebPIDecoder *idec , int (*put)(VP8Io * ) , int (*setup)(VP8Io * ) ,
                    void (*teardown)(VP8Io * ) , void *user_data ) ;
#line 126
VP8Decoder *VP8New(void) ;
#line 131 "../../src/dec/vp8_dec.h"
__inline static int VP8InitIo(VP8Io *io ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 132
  __cil_tmp2 = VP8InitIoInternal(io, 521);
  }
#line 132
  return (__cil_tmp2);
}
}
#line 137
int VP8GetHeaders(VP8Decoder *dec , VP8Io *io ) ;
#line 141
int VP8Decode(VP8Decoder *dec , VP8Io *io ) ;
#line 144
VP8StatusCode VP8Status(VP8Decoder *dec ) ;
#line 147
char const   *VP8StatusMessage(VP8Decoder *dec ) ;
#line 151
void VP8Clear(VP8Decoder *dec ) ;
#line 154
void VP8Delete(VP8Decoder *dec ) ;
#line 160
int VP8CheckSignature(uint8_t *data , size_t data_size ) ;
#line 165
int VP8GetInfo(uint8_t *data , size_t data_size , size_t chunk_size , int *width ,
               int *height ) ;
#line 172
int VP8LCheckSignature(uint8_t *data , size_t size ) ;
#line 177
int VP8LGetInfo(uint8_t *data , size_t data_size , int *width , int *height , int *has_alpha ) ;
#line 59 "../../src/dsp/yuv.h"
__inline static int MultHi(int v , int coeff ) 
{ 


  {
#line 60
  return (v * coeff >> 8);
}
}
#line 63 "../../src/dsp/yuv.h"
__inline static int VP8Clip8(int v ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 64
  if ((v & -16384) == 0) {
#line 64
    tmp___0 = v >> 6;
  } else {
#line 64
    if (v < 0) {
#line 64
      tmp = 0;
    } else {
#line 64
      tmp = 255;
    }
#line 64
    tmp___0 = tmp;
  }
#line 64
  return (tmp___0);
}
}
#line 67 "../../src/dsp/yuv.h"
__inline static int VP8YUVToR(int y , int v ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 68
  __cil_tmp4 = MultHi(v, 26149);
#line 68
  __cil_tmp3 = MultHi(y, 19077);
#line 68
  __cil_tmp5 = VP8Clip8((__cil_tmp3 + __cil_tmp4) - 14234);
  }
#line 68
  return (__cil_tmp5);
}
}
#line 71 "../../src/dsp/yuv.h"
__inline static int VP8YUVToG(int y , int u , int v ) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 72
  __cil_tmp6 = MultHi(v, 13320);
#line 72
  __cil_tmp5 = MultHi(u, 6419);
#line 72
  __cil_tmp4 = MultHi(y, 19077);
#line 72
  __cil_tmp7 = VP8Clip8(((__cil_tmp4 - __cil_tmp5) - __cil_tmp6) + 8708);
  }
#line 72
  return (__cil_tmp7);
}
}
#line 75 "../../src/dsp/yuv.h"
__inline static int VP8YUVToB(int y , int u ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 76
  __cil_tmp4 = MultHi(u, 33050);
#line 76
  __cil_tmp3 = MultHi(y, 19077);
#line 76
  __cil_tmp5 = VP8Clip8((__cil_tmp3 + __cil_tmp4) - 17685);
  }
#line 76
  return (__cil_tmp5);
}
}
#line 79 "../../src/dsp/yuv.h"
__inline static void VP8YuvToRgb(int y , int u , int v , uint8_t *rgb ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 81
  __cil_tmp5 = VP8YUVToR(y, v);
#line 81
  *(rgb + 0) = (uint8_t )__cil_tmp5;
#line 82
  __cil_tmp6 = VP8YUVToG(y, u, v);
#line 82
  *(rgb + 1) = (uint8_t )__cil_tmp6;
#line 83
  __cil_tmp7 = VP8YUVToB(y, u);
#line 83
  *(rgb + 2) = (uint8_t )__cil_tmp7;
  }
#line 85
  return;
}
}
#line 86 "../../src/dsp/yuv.h"
__inline static void VP8YuvToBgr(int y , int u , int v , uint8_t *bgr ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 88
  __cil_tmp5 = VP8YUVToB(y, u);
#line 88
  *(bgr + 0) = (uint8_t )__cil_tmp5;
#line 89
  __cil_tmp6 = VP8YUVToG(y, u, v);
#line 89
  *(bgr + 1) = (uint8_t )__cil_tmp6;
#line 90
  __cil_tmp7 = VP8YUVToR(y, v);
#line 90
  *(bgr + 2) = (uint8_t )__cil_tmp7;
  }
#line 92
  return;
}
}
#line 93 "../../src/dsp/yuv.h"
__inline static void VP8YuvToRgb565(int y , int u , int v , uint8_t *rgb ) 
{ 
  int r ;
  int __cil_tmp6 ;
  int g ;
  int __cil_tmp8 ;
  int b ;
  int __cil_tmp10 ;
  int rg ;
  int gb ;

  {
  {
#line 95
  __cil_tmp6 = VP8YUVToR(y, v);
#line 95
  r = __cil_tmp6;
#line 96
  __cil_tmp8 = VP8YUVToG(y, u, v);
#line 96
  g = __cil_tmp8;
#line 97
  __cil_tmp10 = VP8YUVToB(y, u);
#line 97
  b = __cil_tmp10;
#line 98
  rg = (r & 248) | (g >> 5);
#line 99
  gb = ((g << 3) & 224) | (b >> 3);
#line 104
  *(rgb + 0) = (uint8_t )rg;
#line 105
  *(rgb + 1) = (uint8_t )gb;
  }
#line 107
  return;
}
}
#line 109 "../../src/dsp/yuv.h"
__inline static void VP8YuvToRgba4444(int y , int u , int v , uint8_t *argb ) 
{ 
  int r ;
  int __cil_tmp6 ;
  int g ;
  int __cil_tmp8 ;
  int b ;
  int __cil_tmp10 ;
  int rg ;
  int ba ;

  {
  {
#line 111
  __cil_tmp6 = VP8YUVToR(y, v);
#line 111
  r = __cil_tmp6;
#line 112
  __cil_tmp8 = VP8YUVToG(y, u, v);
#line 112
  g = __cil_tmp8;
#line 113
  __cil_tmp10 = VP8YUVToB(y, u);
#line 113
  b = __cil_tmp10;
#line 114
  rg = (r & 240) | (g >> 4);
#line 115
  ba = (b & 240) | 15;
#line 120
  *(argb + 0) = (uint8_t )rg;
#line 121
  *(argb + 1) = (uint8_t )ba;
  }
#line 123
  return;
}
}
#line 128 "../../src/dsp/yuv.h"
__inline static void VP8YuvToArgb(uint8_t y , uint8_t u , uint8_t v , uint8_t *argb ) 
{ 


  {
  {
#line 130
  *(argb + 0) = (uint8_t )255;
#line 131
  VP8YuvToRgb((int )y, (int )u, (int )v, argb + 1);
  }
#line 133
  return;
}
}
#line 134 "../../src/dsp/yuv.h"
__inline static void VP8YuvToBgra(uint8_t y , uint8_t u , uint8_t v , uint8_t *bgra ) 
{ 


  {
  {
#line 136
  VP8YuvToBgr((int )y, (int )u, (int )v, bgra);
#line 137
  *(bgra + 3) = (uint8_t )255;
  }
#line 139
  return;
}
}
#line 140 "../../src/dsp/yuv.h"
__inline static void VP8YuvToRgba(uint8_t y , uint8_t u , uint8_t v , uint8_t *rgba ) 
{ 


  {
  {
#line 142
  VP8YuvToRgb((int )y, (int )u, (int )v, rgba);
#line 143
  *(rgba + 3) = (uint8_t )255;
  }
#line 145
  return;
}
}
#line 186 "../../src/dsp/yuv.h"
__inline static int VP8ClipUV(int uv , int rounding ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 187
  uv = ((uv + rounding) + (128 << 18)) >> 18;
#line 188
  if ((uv & -256) == 0) {
#line 188
    tmp___0 = uv;
  } else {
#line 188
    if (uv < 0) {
#line 188
      tmp = 0;
    } else {
#line 188
      tmp = 255;
    }
#line 188
    tmp___0 = tmp;
  }
#line 188
  return (tmp___0);
}
}
#line 191 "../../src/dsp/yuv.h"
__inline static int VP8RGBToY(int r , int g , int b , int rounding ) 
{ 
  int luma ;

  {
#line 192
  luma = (16839 * r + 33059 * g) + 6420 * b;
#line 193
  return (((luma + rounding) + (16 << 16)) >> 16);
}
}
#line 196 "../../src/dsp/yuv.h"
__inline static int VP8RGBToU(int r , int g , int b , int rounding ) 
{ 
  int u ;
  int __cil_tmp6 ;

  {
  {
#line 197
  u = (-9719 * r - 19081 * g) + 28800 * b;
#line 198
  __cil_tmp6 = VP8ClipUV(u, rounding);
  }
#line 198
  return (__cil_tmp6);
}
}
#line 201 "../../src/dsp/yuv.h"
__inline static int VP8RGBToV(int r , int g , int b , int rounding ) 
{ 
  int v ;
  int __cil_tmp6 ;

  {
  {
#line 202
  v = (28800 * r - 24116 * g) - 4684 * b;
#line 203
  __cil_tmp6 = VP8ClipUV(v, rounding);
  }
#line 203
  return (__cil_tmp6);
}
}
#line 24 "/root/patron-new/new_3/src/enc/picture_tools_enc.c"
static int IsTransparentARGBArea(uint32_t *ptr , int stride , int size ) 
{ 
  int y ;
  int x ;

  {
#line 26
  y = 0;
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;

#line 26
    if (! (y < size)) {
#line 26
      goto while_break;
    }
#line 27
    x = 0;
    {
#line 27
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 27
      if (! (x < size)) {
#line 27
        goto while_break___0;
      }
#line 28
      if (*(ptr + x) & 4278190080U) {
#line 29
        return (0);
      }
#line 27
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 32
    ptr += stride;
#line 26
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 34
  return (1);
}
}
#line 37 "/root/patron-new/new_3/src/enc/picture_tools_enc.c"
static void Flatten(uint8_t *ptr , int v , int stride , int size ) 
{ 
  int y ;

  {
#line 39
  y = 0;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;

#line 39
    if (! (y < size)) {
#line 39
      goto while_break;
    }
    {
#line 40
    memset((void *)ptr, v, (unsigned long )size);
#line 41
    ptr += stride;
#line 39
    y ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 43
  return;
}
}
#line 45 "/root/patron-new/new_3/src/enc/picture_tools_enc.c"
static void FlattenARGB(uint32_t *ptr , uint32_t v , int stride , int size ) 
{ 
  int x ;
  int y ;

  {
#line 47
  y = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;

#line 47
    if (! (y < size)) {
#line 47
      goto while_break;
    }
#line 48
    x = 0;
    {
#line 48
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 48
      if (! (x < size)) {
#line 48
        goto while_break___0;
      }
#line 48
      *(ptr + x) = v;
#line 48
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 49
    ptr += stride;
#line 47
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 51
  return;
}
}
#line 55 "/root/patron-new/new_3/src/enc/picture_tools_enc.c"
static int SmoothenBlock(uint8_t *a_ptr , int a_stride , uint8_t *y_ptr , int y_stride ,
                         int width , int height ) 
{ 
  int sum ;
  int count ;
  int x ;
  int y ;
  uint8_t *alpha_ptr ;
  uint8_t *luma_ptr ;
  uint8_t avg_u8 ;

  {
#line 57
  sum = 0;
#line 57
  count = 0;
#line 59
  alpha_ptr = a_ptr;
#line 60
  luma_ptr = y_ptr;
#line 61
  y = 0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;

#line 61
    if (! (y < height)) {
#line 61
      goto while_break;
    }
#line 62
    x = 0;
    {
#line 62
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 62
      if (! (x < width)) {
#line 62
        goto while_break___0;
      }
#line 63
      if ((int )*(alpha_ptr + x) != 0) {
#line 64
        count ++;
#line 65
        sum += (int )*(luma_ptr + x);
      }
#line 62
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 68
    alpha_ptr += a_stride;
#line 69
    luma_ptr += y_stride;
#line 61
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 71
  if (count > 0) {
#line 71
    if (count < width * height) {
#line 72
      avg_u8 = (uint8_t )(sum / count);
#line 73
      alpha_ptr = a_ptr;
#line 74
      luma_ptr = y_ptr;
#line 75
      y = 0;
      {
#line 75
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 75
        if (! (y < height)) {
#line 75
          goto while_break___1;
        }
#line 76
        x = 0;
        {
#line 76
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 76
          if (! (x < width)) {
#line 76
            goto while_break___2;
          }
#line 77
          if ((int )*(alpha_ptr + x) == 0) {
#line 77
            *(luma_ptr + x) = avg_u8;
          }
#line 76
          x ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 79
        alpha_ptr += a_stride;
#line 80
        luma_ptr += y_stride;
#line 75
        y ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: ;
    }
  }
#line 83
  return (count == 0);
}
}
#line 86 "/root/patron-new/new_3/src/enc/picture_tools_enc.c"
void WebPReplaceTransparentPixels(WebPPicture *pic , uint32_t color ) 
{ 
  int y ;
  uint32_t *argb ;
  int __cil_tmp5 ;

  {
#line 87
  if ((unsigned long )pic != (unsigned long )((void *)0)) {
#line 87
    if (pic->use_argb) {
      {
#line 88
      y = pic->height;
#line 89
      argb = pic->argb;
#line 90
      color &= 16777215U;
#line 91
      WebPInitAlphaProcessing();
      }
      {
#line 92
      while (1) {
        while_continue: /* CIL Label */ ;
#line 92
        __cil_tmp5 = y;
#line 92
        y --;
#line 92
        if (! (__cil_tmp5 > 0)) {
#line 92
          goto while_break;
        }
        {
#line 93
        (*WebPAlphaReplace)(argb, pic->width, color);
#line 94
        argb += pic->argb_stride;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: ;
    }
  }
#line 101
  return;
}
}
#line 99 "/root/patron-new/new_3/src/enc/picture_tools_enc.c"
void WebPCleanupTransparentArea(WebPPicture *pic ) 
{ 
  int x ;
  int y ;
  int w ;
  int h ;
  uint32_t argb_value ;
  int need_reset ;
  int off ;
  int __cil_tmp9 ;
  int width ;
  int height ;
  int y_stride ;
  int uv_stride ;
  int a_stride ;
  uint8_t *y_ptr ;
  uint8_t *u_ptr ;
  uint8_t *v_ptr ;
  uint8_t *a_ptr ;
  int values[3] ;
  unsigned int tmp ;
  int need_reset___0 ;
  int __cil_tmp22 ;
  int sub_height ;

  {
#line 101
  if ((unsigned long )pic == (unsigned long )((void *)0)) {
#line 101
    return;
  }
#line 102
  w = pic->width / 8;
#line 103
  h = pic->height / 8;
#line 106
  if (pic->use_argb) {
#line 107
    argb_value = (uint32_t )0;
#line 108
    y = 0;
    {
#line 108
    while (1) {
      while_continue: /* CIL Label */ ;

#line 108
      if (! (y < h)) {
#line 108
        goto while_break;
      }
#line 109
      need_reset = 1;
#line 110
      x = 0;
      {
#line 110
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 110
        if (! (x < w)) {
#line 110
          goto while_break___0;
        }
        {
#line 111
        off = (y * pic->argb_stride + x) * 8;
#line 112
        __cil_tmp9 = IsTransparentARGBArea(pic->argb + off, pic->argb_stride, 8);
        }
#line 112
        if (__cil_tmp9) {
#line 113
          if (need_reset) {
#line 114
            argb_value = *(pic->argb + off);
#line 115
            need_reset = 0;
          }
          {
#line 117
          FlattenARGB(pic->argb + off, argb_value, pic->argb_stride, 8);
          }
        } else {
#line 119
          need_reset = 1;
        }
#line 110
        x ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___0: 
#line 108
      y ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 124
    width = pic->width;
#line 125
    height = pic->height;
#line 126
    y_stride = pic->y_stride;
#line 127
    uv_stride = pic->uv_stride;
#line 128
    a_stride = pic->a_stride;
#line 129
    y_ptr = pic->y;
#line 130
    u_ptr = pic->u;
#line 131
    v_ptr = pic->v;
#line 132
    a_ptr = pic->a;
#line 133
    values[0] = 0;
#line 133
    tmp = 1U;
    {
#line 133
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 133
      if (tmp >= 3U) {
#line 133
        goto while_break___1;
      }
#line 133
      values[tmp] = 0;
#line 133
      tmp ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: ;
#line 134
    if ((unsigned long )a_ptr == (unsigned long )((void *)0)) {
#line 135
      return;
    } else
#line 134
    if ((unsigned long )y_ptr == (unsigned long )((void *)0)) {
#line 135
      return;
    } else
#line 134
    if ((unsigned long )u_ptr == (unsigned long )((void *)0)) {
#line 135
      return;
    } else
#line 134
    if ((unsigned long )v_ptr == (unsigned long )((void *)0)) {
#line 135
      return;
    }
#line 137
    y = 0;
    {
#line 137
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 137
      if (! (y + 8 <= height)) {
#line 137
        goto while_break___2;
      }
#line 138
      need_reset___0 = 1;
#line 139
      x = 0;
      {
#line 139
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 139
        if (! (x + 8 <= width)) {
#line 139
          goto while_break___3;
        }
        {
#line 140
        __cil_tmp22 = SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride, 8, 8);
        }
#line 140
        if (__cil_tmp22) {
#line 142
          if (need_reset___0) {
#line 143
            values[0] = (int )*(y_ptr + x);
#line 144
            values[1] = (int )*(u_ptr + (x >> 1));
#line 145
            values[2] = (int )*(v_ptr + (x >> 1));
#line 146
            need_reset___0 = 0;
          }
          {
#line 148
          Flatten(y_ptr + x, values[0], y_stride, 8);
#line 149
          Flatten(u_ptr + (x >> 1), values[1], uv_stride, 4);
#line 150
          Flatten(v_ptr + (x >> 1), values[2], uv_stride, 4);
          }
        } else {
#line 152
          need_reset___0 = 1;
        }
#line 139
        x += 8;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: ;
#line 155
      if (x < width) {
        {
#line 156
        SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride, width - x, 8);
        }
      }
#line 159
      a_ptr += 8 * a_stride;
#line 160
      y_ptr += 8 * y_stride;
#line 161
      u_ptr += 4 * uv_stride;
#line 162
      v_ptr += 4 * uv_stride;
#line 137
      y += 8;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: ;
#line 164
    if (y < height) {
#line 165
      sub_height = height - y;
#line 166
      x = 0;
      {
#line 166
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 166
        if (! (x + 8 <= width)) {
#line 166
          goto while_break___4;
        }
        {
#line 167
        SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride, 8, sub_height);
#line 166
        x += 8;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: ;
#line 170
      if (x < width) {
        {
#line 171
        SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride, width - x, sub_height);
        }
      }
    }
  }
#line 176
  return;
}
}
#line 189 "/root/patron-new/new_3/src/enc/picture_tools_enc.c"
__inline static uint32_t MakeARGB32(int r , int g , int b ) 
{ 


  {
#line 190
  return (((4278190080U | (unsigned int )(r << 16)) | (unsigned int )(g << 8)) | (unsigned int )b);
}
}
#line 193 "/root/patron-new/new_3/src/enc/picture_tools_enc.c"
void WebPBlendAlpha(WebPPicture *pic , uint32_t background_rgb ) 
{ 
  int red ;
  int green ;
  int blue ;
  int x ;
  int y ;
  int uv_width ;
  int Y0 ;
  int __cil_tmp10 ;
  int U0 ;
  int __cil_tmp12 ;
  int V0 ;
  int __cil_tmp14 ;
  int has_alpha ;
  uint8_t *y_ptr ;
  uint8_t *u_ptr ;
  uint8_t *v_ptr ;
  uint8_t *a_ptr ;
  uint8_t alpha ;
  uint8_t *a_ptr2 ;
  uint8_t *tmp ;
  uint32_t alpha___0 ;
  uint32_t alpha___1 ;
  uint32_t *argb ;
  uint32_t background ;
  uint32_t __cil_tmp27 ;
  int alpha___2 ;
  int r ;
  int g ;
  int b ;

  {
#line 194
  red = (int )((background_rgb >> 16) & 255U);
#line 195
  green = (int )((background_rgb >> 8) & 255U);
#line 196
  blue = (int )(background_rgb & 255U);
#line 198
  if ((unsigned long )pic == (unsigned long )((void *)0)) {
#line 198
    return;
  }
#line 199
  if (! pic->use_argb) {
    {
#line 200
    uv_width = pic->width >> 1;
#line 201
    __cil_tmp10 = VP8RGBToY(red, green, blue, 32768);
#line 201
    Y0 = __cil_tmp10;
#line 203
    __cil_tmp12 = VP8RGBToU(4 * red, 4 * green, 4 * blue, 131072);
#line 203
    U0 = __cil_tmp12;
#line 204
    __cil_tmp14 = VP8RGBToV(4 * red, 4 * green, 4 * blue, 131072);
#line 204
    V0 = __cil_tmp14;
#line 205
    has_alpha = (int )((unsigned int )pic->colorspace & 4U);
#line 206
    y_ptr = pic->y;
#line 207
    u_ptr = pic->u;
#line 208
    v_ptr = pic->v;
#line 209
    a_ptr = pic->a;
    }
#line 210
    if ((unsigned long )a_ptr == (unsigned long )((void *)0)) {
#line 210
      return;
    } else
#line 210
    if (! has_alpha) {
#line 210
      return;
    }
#line 211
    y = 0;
    {
#line 211
    while (1) {
      while_continue: /* CIL Label */ ;

#line 211
      if (! (y < pic->height)) {
#line 211
        goto while_break;
      }
#line 213
      x = 0;
      {
#line 213
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 213
        if (! (x < pic->width)) {
#line 213
          goto while_break___0;
        }
#line 214
        alpha = *(a_ptr + x);
#line 215
        if ((int )alpha < 255) {
#line 216
          *(y_ptr + x) = (uint8_t )(((Y0 * (255 - (int )alpha) + (int )*(y_ptr + x) * (int )alpha) * 257 + 256) >> 16);
        }
#line 213
        x ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: ;
#line 220
      if ((y & 1) == 0) {
#line 221
        if (y + 1 == pic->height) {
#line 221
          tmp = a_ptr;
        } else {
#line 221
          tmp = a_ptr + pic->a_stride;
        }
#line 221
        a_ptr2 = tmp;
#line 223
        x = 0;
        {
#line 223
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 223
          if (! (x < uv_width)) {
#line 223
            goto while_break___1;
          }
#line 226
          alpha___0 = (uint32_t )((((int )*(a_ptr + 2 * x) + (int )*(a_ptr + (2 * x + 1))) + (int )*(a_ptr2 + 2 * x)) + (int )*(a_ptr2 + (2 * x + 1)));
#line 229
          *(u_ptr + x) = (uint8_t )((((unsigned int )U0 * (1020U - alpha___0) + (unsigned int )*(u_ptr + x) * alpha___0) * 257U + 1024U) >> 18);
#line 230
          *(v_ptr + x) = (uint8_t )((((unsigned int )V0 * (1020U - alpha___0) + (unsigned int )*(v_ptr + x) * alpha___0) * 257U + 1024U) >> 18);
#line 223
          x ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: ;
#line 232
        if (pic->width & 1) {
#line 233
          alpha___1 = (uint32_t )(2 * ((int )*(a_ptr + 2 * x) + (int )*(a_ptr2 + 2 * x)));
#line 234
          *(u_ptr + x) = (uint8_t )((((unsigned int )U0 * (1020U - alpha___1) + (unsigned int )*(u_ptr + x) * alpha___1) * 257U + 1024U) >> 18);
#line 235
          *(v_ptr + x) = (uint8_t )((((unsigned int )V0 * (1020U - alpha___1) + (unsigned int )*(v_ptr + x) * alpha___1) * 257U + 1024U) >> 18);
        }
      } else {
#line 238
        u_ptr += pic->uv_stride;
#line 239
        v_ptr += pic->uv_stride;
      }
      {
#line 241
      memset((void *)a_ptr, 255, (unsigned long )pic->width);
#line 242
      a_ptr += pic->a_stride;
#line 243
      y_ptr += pic->y_stride;
#line 211
      y ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 246
    argb = pic->argb;
#line 247
    __cil_tmp27 = MakeARGB32(red, green, blue);
#line 247
    background = __cil_tmp27;
#line 248
    y = 0;
    }
    {
#line 248
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 248
      if (! (y < pic->height)) {
#line 248
        goto while_break___2;
      }
#line 249
      x = 0;
      {
#line 249
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 249
        if (! (x < pic->width)) {
#line 249
          goto while_break___3;
        }
#line 250
        alpha___2 = (int )((*(argb + x) >> 24) & 255U);
#line 251
        if (alpha___2 != 255) {
#line 252
          if (alpha___2 > 0) {
            {
#line 253
            r = (int )((*(argb + x) >> 16) & 255U);
#line 254
            g = (int )((*(argb + x) >> 8) & 255U);
#line 255
            b = (int )(*(argb + x) & 255U);
#line 256
            r = ((red * (255 - alpha___2) + r * alpha___2) * 257 + 256) >> 16;
#line 257
            g = ((green * (255 - alpha___2) + g * alpha___2) * 257 + 256) >> 16;
#line 258
            b = ((blue * (255 - alpha___2) + b * alpha___2) * 257 + 256) >> 16;
#line 259
            *(argb + x) = MakeARGB32(r, g, b);
            }
          } else {
#line 261
            *(argb + x) = background;
          }
        }
#line 249
        x ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 265
      argb += pic->argb_stride;
#line 248
      y ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 253
  return;
}
}
#line 29 "/root/patron-new/new_3/src/enc/picture_rescale_enc.c"
static void PictureGrabSpecs(WebPPicture *src , WebPPicture *dst ) 
{ 


  {
  {
#line 32
  *dst = *src;
#line 33
  WebPPictureResetBuffers(dst);
  }
#line 35
  return;
}
}
#line 39 "/root/patron-new/new_3/src/enc/picture_rescale_enc.c"
static void SnapTopLeftPosition(WebPPicture *pic , int *left , int *top ) 
{ 


  {
#line 41
  if (! pic->use_argb) {
#line 42
    *left &= -2;
#line 43
    *top &= -2;
  }
#line 45
  return;
}
}
#line 48 "/root/patron-new/new_3/src/enc/picture_rescale_enc.c"
static int AdjustAndCheckRectangle(WebPPicture *pic , int *left , int *top , int width ,
                                   int height ) 
{ 


  {
  {
#line 51
  SnapTopLeftPosition(pic, left, top);
  }
#line 52
  if (*left < 0) {
#line 52
    return (0);
  } else
#line 52
  if (*top < 0) {
#line 52
    return (0);
  }
#line 53
  if (width <= 0) {
#line 53
    return (0);
  } else
#line 53
  if (height <= 0) {
#line 53
    return (0);
  }
#line 54
  if (*left + width > pic->width) {
#line 54
    return (0);
  }
#line 55
  if (*top + height > pic->height) {
#line 55
    return (0);
  }
#line 56
  return (1);
}
}
#line 59 "/root/patron-new/new_3/src/enc/picture_rescale_enc.c"
int WebPPictureCopy(WebPPicture *src , WebPPicture *dst ) 
{ 
  int __cil_tmp3 ;

  {
#line 60
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 60
    return (0);
  } else
#line 60
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 60
    return (0);
  }
#line 61
  if ((unsigned long )src == (unsigned long )dst) {
#line 61
    return (1);
  }
  {
#line 63
  PictureGrabSpecs(src, dst);
#line 64
  __cil_tmp3 = WebPPictureAlloc(dst);
  }
#line 64
  if (! __cil_tmp3) {
#line 64
    return (0);
  }
#line 66
  if (! src->use_argb) {
    {
#line 67
    WebPCopyPlane(src->y, src->y_stride, dst->y, dst->y_stride, dst->width, dst->height);
#line 69
    WebPCopyPlane(src->u, src->uv_stride, dst->u, dst->uv_stride, (dst->width + 1) >> 1,
                  (dst->height + 1) >> 1);
#line 71
    WebPCopyPlane(src->v, src->uv_stride, dst->v, dst->uv_stride, (dst->width + 1) >> 1,
                  (dst->height + 1) >> 1);
    }
#line 73
    if ((unsigned long )dst->a != (unsigned long )((void *)0)) {
      {
#line 74
      WebPCopyPlane(src->a, src->a_stride, dst->a, dst->a_stride, dst->width, dst->height);
      }
    }
  } else {
    {
#line 78
    WebPCopyPlane((uint8_t *)src->argb, 4 * src->argb_stride, (uint8_t *)dst->argb,
                  4 * dst->argb_stride, 4 * dst->width, dst->height);
    }
  }
#line 82
  return (1);
}
}
#line 85 "/root/patron-new/new_3/src/enc/picture_rescale_enc.c"
int WebPPictureIsView(WebPPicture *picture ) 
{ 


  {
#line 86
  if ((unsigned long )picture == (unsigned long )((void *)0)) {
#line 86
    return (0);
  }
#line 87
  if (picture->use_argb) {
#line 88
    return ((unsigned long )picture->memory_argb_ == (unsigned long )((void *)0));
  }
#line 90
  return ((unsigned long )picture->memory_ == (unsigned long )((void *)0));
}
}
#line 93 "/root/patron-new/new_3/src/enc/picture_rescale_enc.c"
int WebPPictureView(WebPPicture *src , int left , int top , int width , int height ,
                    WebPPicture *dst ) 
{ 
  int __cil_tmp7 ;

  {
#line 96
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 96
    return (0);
  } else
#line 96
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 96
    return (0);
  }
  {
#line 99
  __cil_tmp7 = AdjustAndCheckRectangle(src, & left, & top, width, height);
  }
#line 99
  if (! __cil_tmp7) {
#line 99
    return (0);
  }
#line 101
  if ((unsigned long )src != (unsigned long )dst) {
    {
#line 102
    PictureGrabSpecs(src, dst);
    }
  }
#line 104
  dst->width = width;
#line 105
  dst->height = height;
#line 106
  if (! src->use_argb) {
#line 107
    dst->y = (src->y + top * src->y_stride) + left;
#line 108
    dst->u = (src->u + (top >> 1) * src->uv_stride) + (left >> 1);
#line 109
    dst->v = (src->v + (top >> 1) * src->uv_stride) + (left >> 1);
#line 110
    dst->y_stride = src->y_stride;
#line 111
    dst->uv_stride = src->uv_stride;
#line 112
    if ((unsigned long )src->a != (unsigned long )((void *)0)) {
#line 113
      dst->a = (src->a + top * src->a_stride) + left;
#line 114
      dst->a_stride = src->a_stride;
    }
  } else {
#line 117
    dst->argb = (src->argb + top * src->argb_stride) + left;
#line 118
    dst->argb_stride = src->argb_stride;
  }
#line 120
  return (1);
}
}
#line 126 "/root/patron-new/new_3/src/enc/picture_rescale_enc.c"
int WebPPictureCrop(WebPPicture *pic , int left , int top , int width , int height ) 
{ 
  WebPPicture tmp ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int y_offset ;
  int uv_offset ;
  int a_offset ;
  uint8_t *src ;

  {
#line 130
  if ((unsigned long )pic == (unsigned long )((void *)0)) {
#line 130
    return (0);
  }
  {
#line 131
  __cil_tmp7 = AdjustAndCheckRectangle(pic, & left, & top, width, height);
  }
#line 131
  if (! __cil_tmp7) {
#line 131
    return (0);
  }
  {
#line 133
  PictureGrabSpecs(pic, & tmp);
#line 134
  tmp.width = width;
#line 135
  tmp.height = height;
#line 136
  __cil_tmp8 = WebPPictureAlloc(& tmp);
  }
#line 136
  if (! __cil_tmp8) {
#line 136
    return (0);
  }
#line 138
  if (! pic->use_argb) {
    {
#line 139
    y_offset = top * pic->y_stride + left;
#line 140
    uv_offset = (top / 2) * pic->uv_stride + left / 2;
#line 141
    WebPCopyPlane(pic->y + y_offset, pic->y_stride, tmp.y, tmp.y_stride, width, height);
#line 143
    WebPCopyPlane(pic->u + uv_offset, pic->uv_stride, tmp.u, tmp.uv_stride, (width + 1) >> 1,
                  (height + 1) >> 1);
#line 145
    WebPCopyPlane(pic->v + uv_offset, pic->uv_stride, tmp.v, tmp.uv_stride, (width + 1) >> 1,
                  (height + 1) >> 1);
    }
#line 148
    if ((unsigned long )tmp.a != (unsigned long )((void *)0)) {
      {
#line 149
      a_offset = top * pic->a_stride + left;
#line 150
      WebPCopyPlane(pic->a + a_offset, pic->a_stride, tmp.a, tmp.a_stride, width,
                    height);
      }
    }
  } else {
    {
#line 154
    src = (uint8_t *)((pic->argb + top * pic->argb_stride) + left);
#line 156
    WebPCopyPlane(src, pic->argb_stride * 4, (uint8_t *)tmp.argb, tmp.argb_stride * 4,
                  width * 4, height);
    }
  }
  {
#line 159
  WebPPictureFree(pic);
#line 160
  *pic = tmp;
  }
#line 161
  return (1);
}
}
#line 167 "/root/patron-new/new_3/src/enc/picture_rescale_enc.c"
static void RescalePlane(uint8_t *src , int src_width , int src_height , int src_stride ,
                         uint8_t *dst , int dst_width , int dst_height , int dst_stride ,
                         rescaler_t *work , int num_channels ) 
{ 
  WebPRescaler rescaler ;
  int y ;
  int __cil_tmp13 ;

  {
  {
#line 174
  y = 0;
#line 175
  WebPRescalerInit(& rescaler, src_width, src_height, dst, dst_width, dst_height,
                   dst_stride, num_channels, work);
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;

#line 178
    if (! (y < src_height)) {
#line 178
      goto while_break;
    }
    {
#line 179
    __cil_tmp13 = WebPRescalerImport(& rescaler, src_height - y, src + y * src_stride,
                                     src_stride);
#line 179
    y += __cil_tmp13;
#line 181
    WebPRescalerExport(& rescaler);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 186
  return;
}
}
#line 185 "/root/patron-new/new_3/src/enc/picture_rescale_enc.c"
static void AlphaMultiplyARGB(WebPPicture *pic , int inverse ) 
{ 


  {
  {
#line 187
  WebPMultARGBRows((uint8_t *)pic->argb, (int )((unsigned long )pic->argb_stride * sizeof(*(pic->argb))),
                   pic->width, pic->height, inverse);
  }
#line 190
  return;
}
}
#line 191 "/root/patron-new/new_3/src/enc/picture_rescale_enc.c"
static void AlphaMultiplyY(WebPPicture *pic , int inverse ) 
{ 


  {
#line 192
  if ((unsigned long )pic->a != (unsigned long )((void *)0)) {
    {
#line 193
    WebPMultRows(pic->y, pic->y_stride, pic->a, pic->a_stride, pic->width, pic->height,
                 inverse);
    }
  }
#line 197
  return;
}
}
#line 198 "/root/patron-new/new_3/src/enc/picture_rescale_enc.c"
int WebPPictureRescale(WebPPicture *pic , int width , int height ) 
{ 
  WebPPicture tmp ;
  int prev_width ;
  int prev_height ;
  rescaler_t *work ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
#line 203
  if ((unsigned long )pic == (unsigned long )((void *)0)) {
#line 203
    return (0);
  }
  {
#line 204
  prev_width = pic->width;
#line 205
  prev_height = pic->height;
#line 206
  __cil_tmp8 = WebPRescalerGetScaledDimensions(prev_width, prev_height, & width, & height);
  }
#line 206
  if (! __cil_tmp8) {
#line 208
    return (0);
  }
  {
#line 211
  PictureGrabSpecs(pic, & tmp);
#line 212
  tmp.width = width;
#line 213
  tmp.height = height;
#line 214
  __cil_tmp9 = WebPPictureAlloc(& tmp);
  }
#line 214
  if (! __cil_tmp9) {
#line 214
    return (0);
  }
#line 216
  if (! pic->use_argb) {
    {
#line 217
    __cil_tmp10 = WebPSafeMalloc((uint64_t )(2ULL * (unsigned long long )width), sizeof(*work));
#line 217
    work = (rescaler_t *)__cil_tmp10;
    }
#line 218
    if ((unsigned long )work == (unsigned long )((void *)0)) {
      {
#line 219
      WebPPictureFree(& tmp);
      }
#line 220
      return (0);
    }
#line 223
    if ((unsigned long )pic->a != (unsigned long )((void *)0)) {
      {
#line 224
      WebPInitAlphaProcessing();
#line 225
      RescalePlane(pic->a, prev_width, prev_height, pic->a_stride, tmp.a, width, height,
                   tmp.a_stride, work, 1);
      }
    }
    {
#line 231
    AlphaMultiplyY(pic, 0);
#line 232
    RescalePlane(pic->y, prev_width, prev_height, pic->y_stride, tmp.y, width, height,
                 tmp.y_stride, work, 1);
#line 234
    AlphaMultiplyY(& tmp, 1);
#line 236
    RescalePlane(pic->u, (prev_width + 1) >> 1, (prev_height + 1) >> 1, pic->uv_stride,
                 tmp.u, (width + 1) >> 1, (height + 1) >> 1, tmp.uv_stride, work,
                 1);
#line 240
    RescalePlane(pic->v, (prev_width + 1) >> 1, (prev_height + 1) >> 1, pic->uv_stride,
                 tmp.v, (width + 1) >> 1, (height + 1) >> 1, tmp.uv_stride, work,
                 1);
    }
  } else {
    {
#line 245
    __cil_tmp11 = WebPSafeMalloc((uint64_t )((2ULL * (unsigned long long )width) * 4ULL),
                                 sizeof(*work));
#line 245
    work = (rescaler_t *)__cil_tmp11;
    }
#line 246
    if ((unsigned long )work == (unsigned long )((void *)0)) {
      {
#line 247
      WebPPictureFree(& tmp);
      }
#line 248
      return (0);
    }
    {
#line 253
    WebPInitAlphaProcessing();
#line 254
    AlphaMultiplyARGB(pic, 0);
#line 255
    RescalePlane((uint8_t *)pic->argb, prev_width, prev_height, pic->argb_stride * 4,
                 (uint8_t *)tmp.argb, width, height, tmp.argb_stride * 4, work, 4);
#line 260
    AlphaMultiplyARGB(& tmp, 1);
    }
  }
  {
#line 262
  WebPPictureFree(pic);
#line 263
  WebPSafeFree((void *)work);
#line 264
  *pic = tmp;
  }
#line 265
  return (1);
}
}
#line 37 "/root/patron-new/new_3/src/enc/picture_psnr_enc.c"
static double AccumulateLSIM(uint8_t *src , int src_stride , uint8_t *ref , int ref_stride ,
                             int w , int h ) 
{ 
  int x ;
  int y ;
  double total_sse ;
  int y_0 ;
  int tmp ;
  int y_1 ;
  int tmp___0 ;
  int x_0 ;
  int tmp___1 ;
  int x_1 ;
  int tmp___2 ;
  double best_sse ;
  double value ;
  int i ;
  int j ;
  uint8_t *s ;
  double diff ;
  double sse ;

  {
#line 41
  total_sse = 0.;
#line 42
  y = 0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;

#line 42
    if (! (y < h)) {
#line 42
      goto while_break;
    }
#line 43
    if (y - 2 < 0) {
#line 43
      tmp = 0;
    } else {
#line 43
      tmp = y - 2;
    }
#line 43
    y_0 = tmp;
#line 44
    if ((y + 2) + 1 >= h) {
#line 44
      tmp___0 = h;
    } else {
#line 44
      tmp___0 = (y + 2) + 1;
    }
#line 44
    y_1 = tmp___0;
#line 45
    x = 0;
    {
#line 45
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 45
      if (! (x < w)) {
#line 45
        goto while_break___0;
      }
#line 46
      if (x - 2 < 0) {
#line 46
        tmp___1 = 0;
      } else {
#line 46
        tmp___1 = x - 2;
      }
#line 46
      x_0 = tmp___1;
#line 47
      if ((x + 2) + 1 >= w) {
#line 47
        tmp___2 = w;
      } else {
#line 47
        tmp___2 = (x + 2) + 1;
      }
#line 47
      x_1 = tmp___2;
#line 48
      best_sse = 255. * 255.;
#line 49
      value = (double )*(ref + (y * ref_stride + x));
#line 51
      j = y_0;
      {
#line 51
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 51
        if (! (j < y_1)) {
#line 51
          goto while_break___1;
        }
#line 52
        s = src + j * src_stride;
#line 53
        i = x_0;
        {
#line 53
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 53
          if (! (i < x_1)) {
#line 53
            goto while_break___2;
          }
#line 54
          diff = (double )((int )*(s + i)) - value;
#line 55
          sse = diff * diff;
#line 56
          if (sse < best_sse) {
#line 56
            best_sse = sse;
          }
#line 53
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 51
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 59
      total_sse += best_sse;
#line 45
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 42
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 62
  return (total_sse);
}
}
#line 66 "/root/patron-new/new_3/src/enc/picture_psnr_enc.c"
static double AccumulateSSE(uint8_t *src , int src_stride , uint8_t *ref , int ref_stride ,
                            int w , int h ) 
{ 
  int y ;
  double total_sse ;
  uint32_t __cil_tmp9 ;

  {
#line 70
  total_sse = 0.;
#line 71
  y = 0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;

#line 71
    if (! (y < h)) {
#line 71
      goto while_break;
    }
    {
#line 72
    __cil_tmp9 = (*VP8AccumulateSSE)(src, ref, w);
#line 72
    total_sse += (double )__cil_tmp9;
#line 73
    src += src_stride;
#line 74
    ref += ref_stride;
#line 71
    y ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 76
  return (total_sse);
}
}
#line 81 "/root/patron-new/new_3/src/enc/picture_psnr_enc.c"
static double AccumulateSSIM(uint8_t *src , int src_stride , uint8_t *ref , int ref_stride ,
                             int w , int h ) 
{ 
  int w0 ;
  int tmp ;
  int w1 ;
  int h0 ;
  int tmp___0 ;
  int h1 ;
  int x ;
  int y ;
  double sum ;
  double __cil_tmp16 ;
  double __cil_tmp17 ;
  int off1 ;
  int off2 ;
  double __cil_tmp20 ;
  double __cil_tmp21 ;
  double __cil_tmp22 ;

  {
#line 84
  if (w < 3) {
#line 84
    tmp = w;
  } else {
#line 84
    tmp = 3;
  }
#line 84
  w0 = tmp;
#line 85
  w1 = (w - 3) - 1;
#line 86
  if (h < 3) {
#line 86
    tmp___0 = h;
  } else {
#line 86
    tmp___0 = 3;
  }
#line 86
  h0 = tmp___0;
#line 87
  h1 = (h - 3) - 1;
#line 89
  sum = 0.;
#line 90
  y = 0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;

#line 90
    if (! (y < h0)) {
#line 90
      goto while_break;
    }
#line 91
    x = 0;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 91
      if (! (x < w)) {
#line 91
        goto while_break___0;
      }
      {
#line 92
      __cil_tmp16 = (*VP8SSIMGetClipped)(src, src_stride, ref, ref_stride, x, y, w,
                                         h);
#line 92
      sum += __cil_tmp16;
#line 91
      x ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 90
    y ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 95
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 95
    if (! (y < h1)) {
#line 95
      goto while_break___1;
    }
#line 96
    x = 0;
    {
#line 96
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 96
      if (! (x < w0)) {
#line 96
        goto while_break___2;
      }
      {
#line 97
      __cil_tmp17 = (*VP8SSIMGetClipped)(src, src_stride, ref, ref_stride, x, y, w,
                                         h);
#line 97
      sum += __cil_tmp17;
#line 96
      x ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___2: ;
    {
#line 99
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 99
      if (! (x < w1)) {
#line 99
        goto while_break___3;
      }
      {
#line 100
      off1 = (x - 3) + (y - 3) * src_stride;
#line 101
      off2 = (x - 3) + (y - 3) * ref_stride;
#line 102
      __cil_tmp20 = (*VP8SSIMGet)(src + off1, src_stride, ref + off2, ref_stride);
#line 102
      sum += __cil_tmp20;
#line 99
      x ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___3: ;
    {
#line 104
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 104
      if (! (x < w)) {
#line 104
        goto while_break___4;
      }
      {
#line 105
      __cil_tmp21 = (*VP8SSIMGetClipped)(src, src_stride, ref, ref_stride, x, y, w,
                                         h);
#line 105
      sum += __cil_tmp21;
#line 104
      x ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___4: 
#line 95
    y ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___1: ;
  {
#line 108
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 108
    if (! (y < h)) {
#line 108
      goto while_break___5;
    }
#line 109
    x = 0;
    {
#line 109
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 109
      if (! (x < w)) {
#line 109
        goto while_break___6;
      }
      {
#line 110
      __cil_tmp22 = (*VP8SSIMGetClipped)(src, src_stride, ref, ref_stride, x, y, w,
                                         h);
#line 110
      sum += __cil_tmp22;
#line 109
      x ++;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___6: 
#line 108
    y ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___5: ;
#line 113
  return (sum);
}
}
#line 120 "/root/patron-new/new_3/src/enc/picture_psnr_enc.c"
static double const   kMinDistortion_dB  =    (double const   )99.;
#line 122 "/root/patron-new/new_3/src/enc/picture_psnr_enc.c"
static double GetPSNR___0(double v , double size ) 
{ 
  double __cil_tmp3 ;
  double tmp ;

  {
#line 123
  if (v > 0.) {
#line 123
    if (size > 0.) {
      {
#line 123
      __cil_tmp3 = log(v / ((size * (double )255) * 255.));
#line 123
      tmp = - 4.3429448 * __cil_tmp3;
      }
    } else {
#line 123
      tmp = (double )kMinDistortion_dB;
    }
  } else {
#line 123
    tmp = (double )kMinDistortion_dB;
  }
#line 123
  return ((double )((int )tmp));
}
}
#line 127 "/root/patron-new/new_3/src/enc/picture_psnr_enc.c"
static double GetLogSSIM(double v , double size ) 
{ 
  double tmp ;
  double __cil_tmp4 ;
  double tmp___0 ;

  {
#line 128
  if (size > 0.) {
#line 128
    tmp = v / size;
  } else {
#line 128
    tmp = 1.;
  }
#line 128
  v = tmp;
#line 129
  if (v < 1.) {
    {
#line 129
    __cil_tmp4 = log10(1. - v);
#line 129
    tmp___0 = - 10. * __cil_tmp4;
    }
  } else {
#line 129
    tmp___0 = (double )kMinDistortion_dB;
  }
#line 129
  return ((double )((int )tmp___0));
}
}
#line 132 "/root/patron-new/new_3/src/enc/picture_psnr_enc.c"
int WebPPlaneDistortion(uint8_t *src , size_t src_stride , uint8_t *ref , size_t ref_stride ,
                        int width , int height , size_t x_step , int type , float *distortion ,
                        float *result ) 
{ 
  uint8_t *allocated ;
  double (*metric)(uint8_t * , int  , uint8_t * , int  , int  , int  ) ;
  double (*tmp)(uint8_t *src , int src_stride , uint8_t *ref , int ref_stride , int w ,
                int h ) ;
  double (*tmp___0)(uint8_t *src , int src_stride , uint8_t *ref , int ref_stride ,
                    int w , int h ) ;
  int x ;
  int y ;
  uint8_t *tmp1 ;
  uint8_t *tmp2 ;
  void *__cil_tmp19 ;
  double __cil_tmp20 ;
  double __cil_tmp21 ;
  double __cil_tmp22 ;
  float tmp___1 ;

  {
#line 136
  allocated = (uint8_t *)((void *)0);
#line 137
  if (type == 0) {
#line 137
    tmp___0 = & AccumulateSSE;
  } else {
#line 137
    if (type == 1) {
#line 137
      tmp = & AccumulateSSIM;
    } else {
#line 137
      tmp = & AccumulateLSIM;
    }
#line 137
    tmp___0 = tmp;
  }
#line 137
  metric = tmp___0;
#line 140
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 143
    return (0);
  } else
#line 140
  if ((unsigned long )ref == (unsigned long )((void *)0)) {
#line 143
    return (0);
  } else
#line 140
  if (src_stride < x_step * (unsigned long )width) {
#line 143
    return (0);
  } else
#line 140
  if (ref_stride < x_step * (unsigned long )width) {
#line 143
    return (0);
  } else
#line 140
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 143
    return (0);
  } else
#line 140
  if ((unsigned long )distortion == (unsigned long )((void *)0)) {
#line 143
    return (0);
  }
  {
#line 146
  VP8SSIMDspInit();
  }
#line 147
  if (x_step != 1UL) {
    {
#line 151
    __cil_tmp19 = WebPSafeMalloc((uint64_t )((2ULL * (unsigned long long )width) * (unsigned long long )height),
                                 sizeof(*allocated));
#line 151
    allocated = (uint8_t *)__cil_tmp19;
    }
#line 153
    if ((unsigned long )allocated == (unsigned long )((void *)0)) {
#line 153
      return (0);
    }
#line 154
    tmp1 = allocated;
#line 155
    tmp2 = tmp1 + (size_t )width * (unsigned long )height;
#line 156
    y = 0;
    {
#line 156
    while (1) {
      while_continue: /* CIL Label */ ;

#line 156
      if (! (y < height)) {
#line 156
        goto while_break;
      }
#line 157
      x = 0;
      {
#line 157
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 157
        if (! (x < width)) {
#line 157
          goto while_break___0;
        }
#line 158
        *(tmp1 + (x + y * width)) = *(src + ((unsigned long )x * x_step + (unsigned long )y * src_stride));
#line 159
        *(tmp2 + (x + y * width)) = *(ref + ((unsigned long )x * x_step + (unsigned long )y * ref_stride));
#line 157
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 156
      y ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
#line 162
    src = tmp1;
#line 163
    ref = tmp2;
  }
  {
#line 165
  __cil_tmp20 = (*metric)(src, width, ref, width, width, height);
#line 165
  *distortion = (float )__cil_tmp20;
#line 166
  WebPSafeFree((void *)allocated);
  }
#line 168
  if (type == 1) {
    {
#line 168
    __cil_tmp21 = GetLogSSIM((double )*distortion, (double )width * (double )height);
#line 168
    tmp___1 = (float )__cil_tmp21;
    }
  } else {
    {
#line 168
    __cil_tmp22 = GetPSNR___0((double )*distortion, (double )width * (double )height);
#line 168
    tmp___1 = (float )__cil_tmp22;
    }
  }
#line 168
  *result = tmp___1;
#line 170
  return (1);
}
}
#line 179 "/root/patron-new/new_3/src/enc/picture_psnr_enc.c"
int WebPPictureDistortion(WebPPicture *src , WebPPicture *ref , int type , float *results ) 
{ 
  int w ;
  int h ;
  int c ;
  int ok ;
  WebPPicture p0 ;
  WebPPicture p1 ;
  double total_size ;
  double total_distortion ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  float distortion ;
  size_t stride0 ;
  size_t stride1 ;
  int offset ;
  int __cil_tmp23 ;
  double __cil_tmp24 ;
  double __cil_tmp25 ;
  float tmp ;

  {
#line 182
  ok = 0;
#line 184
  total_size = 0.;
#line 184
  total_distortion = 0.;
#line 185
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 188
    return (0);
  } else
#line 185
  if ((unsigned long )ref == (unsigned long )((void *)0)) {
#line 188
    return (0);
  } else
#line 185
  if (src->width != ref->width) {
#line 188
    return (0);
  } else
#line 185
  if (src->height != ref->height) {
#line 188
    return (0);
  } else
#line 185
  if ((unsigned long )results == (unsigned long )((void *)0)) {
#line 188
    return (0);
  }
  {
#line 191
  VP8SSIMDspInit();
#line 192
  __cil_tmp14 = WebPPictureInit(& p1);
#line 192
  __cil_tmp13 = WebPPictureInit(& p0);
  }
#line 192
  if (! __cil_tmp13) {
#line 192
    return (0);
  } else
#line 192
  if (! __cil_tmp14) {
#line 192
    return (0);
  }
  {
#line 193
  w = src->width;
#line 194
  h = src->height;
#line 195
  __cil_tmp15 = WebPPictureView(src, 0, 0, w, h, & p0);
  }
#line 195
  if (! __cil_tmp15) {
#line 195
    goto Error;
  }
  {
#line 196
  __cil_tmp16 = WebPPictureView(ref, 0, 0, w, h, & p1);
  }
#line 196
  if (! __cil_tmp16) {
#line 196
    goto Error;
  }
  {
#line 199
  __cil_tmp17 = WebPPictureYUVAToARGB(& p0);
  }
#line 199
  if (p0.use_argb == 0) {
#line 199
    if (! __cil_tmp17) {
#line 199
      goto Error;
    }
  }
  {
#line 200
  __cil_tmp18 = WebPPictureYUVAToARGB(& p1);
  }
#line 200
  if (p1.use_argb == 0) {
#line 200
    if (! __cil_tmp18) {
#line 200
      goto Error;
    }
  }
#line 201
  c = 0;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;

#line 201
    if (! (c < 4)) {
#line 201
      goto while_break;
    }
    {
#line 203
    stride0 = 4UL * (size_t )p0.argb_stride;
#line 204
    stride1 = 4UL * (size_t )p1.argb_stride;
#line 206
    offset = c;
#line 207
    __cil_tmp23 = WebPPlaneDistortion((uint8_t *)p0.argb + offset, stride0, (uint8_t *)p1.argb + offset,
                                      stride1, w, h, (size_t )4, type, & distortion,
                                      (float *)(results + c));
    }
#line 207
    if (! __cil_tmp23) {
#line 210
      goto Error;
    }
#line 212
    total_distortion += (double )distortion;
#line 213
    total_size += (double )(w * h);
#line 201
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 216
  if (type == 1) {
    {
#line 216
    __cil_tmp24 = GetLogSSIM(total_distortion, total_size);
#line 216
    tmp = (float )__cil_tmp24;
    }
  } else {
    {
#line 216
    __cil_tmp25 = GetPSNR___0(total_distortion, total_size);
#line 216
    tmp = (float )__cil_tmp25;
    }
  }
#line 216
  *(results + 4) = tmp;
#line 218
  ok = 1;
  Error: 
  {
#line 221
  WebPPictureFree(& p0);
#line 222
  WebPPictureFree(& p1);
  }
#line 223
  return (ok);
}
}
#line 25 "/root/patron-new/new_3/src/enc/picture_enc.c"
static int DummyWriter(uint8_t *data , size_t data_size , WebPPicture *picture ) 
{ 


  {
#line 31
  return (1);
}
}
#line 34 "/root/patron-new/new_3/src/enc/picture_enc.c"
int WebPPictureInitInternal(WebPPicture *picture , int version ) 
{ 


  {
#line 35
  if (version >> 8 != 527 >> 8) {
#line 36
    return (0);
  }
#line 38
  if ((unsigned long )picture != (unsigned long )((void *)0)) {
    {
#line 39
    memset((void *)picture, 0, sizeof(*picture));
#line 40
    picture->writer = & DummyWriter;
#line 41
    WebPEncodingSetError(picture, (WebPEncodingError )0);
    }
  }
#line 43
  return (1);
}
}
#line 48 "/root/patron-new/new_3/src/enc/picture_enc.c"
static void WebPPictureResetBufferARGB(WebPPicture *picture ) 
{ 


  {
#line 49
  picture->memory_argb_ = (void *)0;
#line 50
  picture->argb = (uint32_t *)((void *)0);
#line 51
  picture->argb_stride = 0;
#line 52
  return;
}
}
#line 54 "/root/patron-new/new_3/src/enc/picture_enc.c"
static void WebPPictureResetBufferYUVA(WebPPicture *picture ) 
{ 


  {
#line 55
  picture->memory_ = (void *)0;
#line 56
  picture->a = (uint8_t *)((void *)0);
#line 56
  picture->v = picture->a;
#line 56
  picture->u = picture->v;
#line 56
  picture->y = picture->u;
#line 57
  picture->uv_stride = 0;
#line 57
  picture->y_stride = picture->uv_stride;
#line 58
  picture->a_stride = 0;
#line 59
  return;
}
}
#line 61 "/root/patron-new/new_3/src/enc/picture_enc.c"
void WebPPictureResetBuffers(WebPPicture *picture ) 
{ 


  {
  {
#line 62
  WebPPictureResetBufferARGB(picture);
#line 63
  WebPPictureResetBufferYUVA(picture);
  }
#line 65
  return;
}
}
#line 66 "/root/patron-new/new_3/src/enc/picture_enc.c"
int WebPPictureAllocARGB(WebPPicture *picture , int width , int height ) 
{ 
  void *memory ;
  uint64_t argb_size ;
  int __cil_tmp6 ;
  int __cil_tmp8 ;

  {
  {
#line 68
  argb_size = (uint64_t )width * (unsigned long )height;
#line 72
  WebPSafeFree(picture->memory_argb_);
#line 73
  WebPPictureResetBufferARGB(picture);
  }
#line 75
  if (width <= 0) {
    {
#line 76
    __cil_tmp6 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
#line 76
    return (__cil_tmp6);
  } else
#line 75
  if (height <= 0) {
    {
#line 76
    __cil_tmp6 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
#line 76
    return (__cil_tmp6);
  }
  {
#line 79
  memory = WebPSafeMalloc(argb_size + 31UL, sizeof(*(picture->argb)));
  }
#line 80
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
    {
#line 81
    __cil_tmp8 = WebPEncodingSetError(picture, (WebPEncodingError )1);
    }
#line 81
    return (__cil_tmp8);
  }
#line 83
  picture->memory_argb_ = memory;
#line 84
  picture->argb = (uint32_t *)(((uintptr_t )memory + 31UL) & 0xffffffffffffffe0UL);
#line 85
  picture->argb_stride = width;
#line 86
  return (1);
}
}
#line 89 "/root/patron-new/new_3/src/enc/picture_enc.c"
int WebPPictureAllocYUVA(WebPPicture *picture , int width , int height ) 
{ 
  WebPEncCSP uv_csp ;
  int has_alpha ;
  int y_stride ;
  int uv_width ;
  int uv_height ;
  int uv_stride ;
  int a_width ;
  int a_stride ;
  uint64_t y_size ;
  uint64_t uv_size ;
  uint64_t a_size ;
  uint64_t total_size ;
  uint8_t *mem ;
  int __cil_tmp17 ;
  int tmp ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;
  int __cil_tmp21 ;

  {
  {
#line 90
  uv_csp = (WebPEncCSP )((int )picture->colorspace & 3);
#line 92
  has_alpha = (int )picture->colorspace & 4;
#line 93
  y_stride = width;
#line 94
  uv_width = (int )(((int64_t )width + 1L) >> 1);
#line 95
  uv_height = (int )(((int64_t )height + 1L) >> 1);
#line 96
  uv_stride = uv_width;
#line 103
  WebPSafeFree(picture->memory_);
#line 104
  WebPPictureResetBufferYUVA(picture);
  }
#line 106
  if ((unsigned int )uv_csp != 0U) {
    {
#line 107
    __cil_tmp17 = WebPEncodingSetError(picture, (WebPEncodingError )4);
    }
#line 107
    return (__cil_tmp17);
  }
#line 111
  if (has_alpha) {
#line 111
    tmp = width;
  } else {
#line 111
    tmp = 0;
  }
#line 111
  a_width = tmp;
#line 112
  a_stride = a_width;
#line 113
  y_size = (uint64_t )y_stride * (unsigned long )height;
#line 114
  uv_size = (uint64_t )uv_stride * (unsigned long )uv_height;
#line 115
  a_size = (uint64_t )a_stride * (unsigned long )height;
#line 117
  total_size = (y_size + a_size) + 2UL * uv_size;
#line 120
  if (width <= 0) {
    {
#line 122
    __cil_tmp19 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
#line 122
    return (__cil_tmp19);
  } else
#line 120
  if (height <= 0) {
    {
#line 122
    __cil_tmp19 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
#line 122
    return (__cil_tmp19);
  } else
#line 120
  if (uv_width <= 0) {
    {
#line 122
    __cil_tmp19 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
#line 122
    return (__cil_tmp19);
  } else
#line 120
  if (uv_height <= 0) {
    {
#line 122
    __cil_tmp19 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
#line 122
    return (__cil_tmp19);
  }
  {
#line 125
  __cil_tmp20 = WebPSafeMalloc(total_size, sizeof(*mem));
#line 125
  mem = (uint8_t *)__cil_tmp20;
  }
#line 126
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
    {
#line 127
    __cil_tmp21 = WebPEncodingSetError(picture, (WebPEncodingError )1);
    }
#line 127
    return (__cil_tmp21);
  }
#line 131
  picture->memory_ = (void *)mem;
#line 132
  picture->y_stride = y_stride;
#line 133
  picture->uv_stride = uv_stride;
#line 134
  picture->a_stride = a_stride;
#line 137
  picture->y = mem;
#line 138
  mem += y_size;
#line 140
  picture->u = mem;
#line 141
  mem += uv_size;
#line 142
  picture->v = mem;
#line 143
  mem += uv_size;
#line 145
  if (a_size > 0UL) {
#line 146
    picture->a = mem;
#line 147
    mem += a_size;
  }
#line 150
  return (1);
}
}
#line 153 "/root/patron-new/new_3/src/enc/picture_enc.c"
int WebPPictureAlloc(WebPPicture *picture ) 
{ 
  int width ;
  int height ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 154
  if ((unsigned long )picture != (unsigned long )((void *)0)) {
    {
#line 155
    width = picture->width;
#line 156
    height = picture->height;
#line 158
    WebPPictureFree(picture);
    }
#line 160
    if (! picture->use_argb) {
      {
#line 161
      __cil_tmp4 = WebPPictureAllocYUVA(picture, width, height);
      }
#line 161
      return (__cil_tmp4);
    } else {
      {
#line 163
      __cil_tmp5 = WebPPictureAllocARGB(picture, width, height);
      }
#line 163
      return (__cil_tmp5);
    }
  }
#line 166
  return (1);
}
}
#line 169 "/root/patron-new/new_3/src/enc/picture_enc.c"
void WebPPictureFree(WebPPicture *picture ) 
{ 


  {
#line 170
  if ((unsigned long )picture != (unsigned long )((void *)0)) {
    {
#line 171
    WebPSafeFree(picture->memory_);
#line 172
    WebPSafeFree(picture->memory_argb_);
#line 173
    WebPPictureResetBuffers(picture);
    }
  }
#line 176
  return;
}
}
#line 180 "/root/patron-new/new_3/src/enc/picture_enc.c"
void WebPMemoryWriterInit(WebPMemoryWriter *writer ) 
{ 


  {
#line 181
  writer->mem = (uint8_t *)((void *)0);
#line 182
  writer->size = (size_t )0;
#line 183
  writer->max_size = (size_t )0;
#line 184
  return;
}
}
#line 186 "/root/patron-new/new_3/src/enc/picture_enc.c"
int WebPMemoryWrite(uint8_t *data , size_t data_size , WebPPicture *picture ) 
{ 
  WebPMemoryWriter *w ;
  uint64_t next_size ;
  uint8_t *new_mem ;
  uint64_t next_max_size ;
  void *__cil_tmp8 ;

  {
#line 188
  w = (WebPMemoryWriter *)picture->custom_ptr;
#line 190
  if ((unsigned long )w == (unsigned long )((void *)0)) {
#line 191
    return (1);
  }
#line 193
  next_size = w->size + data_size;
#line 194
  if (next_size > w->max_size) {
#line 196
    next_max_size = (uint64_t )(2ULL * (unsigned long long )w->max_size);
#line 197
    if (next_max_size < next_size) {
#line 197
      next_max_size = next_size;
    }
#line 198
    if ((unsigned long long )next_max_size < 8192ULL) {
#line 198
      next_max_size = (uint64_t )8192ULL;
    }
    {
#line 199
    __cil_tmp8 = WebPSafeMalloc(next_max_size, (size_t )1);
#line 199
    new_mem = (uint8_t *)__cil_tmp8;
    }
#line 200
    if ((unsigned long )new_mem == (unsigned long )((void *)0)) {
#line 201
      return (0);
    }
#line 203
    if (w->size > 0UL) {
      {
#line 204
      memcpy((void *)new_mem, (void const   *)w->mem, w->size);
      }
    }
    {
#line 206
    WebPSafeFree((void *)w->mem);
#line 207
    w->mem = new_mem;
#line 209
    w->max_size = next_max_size;
    }
  }
#line 211
  if (data_size > 0UL) {
    {
#line 212
    memcpy((void *)(w->mem + w->size), (void const   *)data, data_size);
#line 213
    w->size += data_size;
    }
  }
#line 215
  return (1);
}
}
#line 218 "/root/patron-new/new_3/src/enc/picture_enc.c"
void WebPMemoryWriterClear(WebPMemoryWriter *writer ) 
{ 


  {
#line 219
  if ((unsigned long )writer != (unsigned long )((void *)0)) {
    {
#line 220
    WebPSafeFree((void *)writer->mem);
#line 221
    writer->mem = (uint8_t *)((void *)0);
#line 222
    writer->size = (size_t )0;
#line 223
    writer->max_size = (size_t )0;
    }
  }
#line 226
  return;
}
}
#line 232 "/root/patron-new/new_3/src/enc/picture_enc.c"
static size_t Encode(uint8_t *rgba , int width , int height , int stride , int (*import)(WebPPicture * const   ,
                                                                                         uint8_t * const   ,
                                                                                         int  ) ,
                     float quality_factor , int lossless , uint8_t **output ) 
{ 
  WebPPicture pic ;
  WebPConfig config ;
  WebPMemoryWriter wrt ;
  int ok ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;

  {
#line 240
  if ((unsigned long )output == (unsigned long )((void *)0)) {
#line 240
    return ((size_t )0);
  }
  {
#line 242
  __cil_tmp14 = WebPPictureInit(& pic);
#line 242
  __cil_tmp13 = WebPConfigPreset(& config, (WebPPreset )0, quality_factor);
  }
#line 242
  if (! __cil_tmp13) {
#line 244
    return ((size_t )0);
  } else
#line 242
  if (! __cil_tmp14) {
#line 244
    return ((size_t )0);
  }
  {
#line 247
  config.lossless = ! (! lossless);
#line 248
  pic.use_argb = ! (! lossless);
#line 249
  pic.width = width;
#line 250
  pic.height = height;
#line 251
  pic.writer = & WebPMemoryWrite;
#line 252
  pic.custom_ptr = (void *)(& wrt);
#line 253
  WebPMemoryWriterInit(& wrt);
#line 255
  __cil_tmp16 = WebPEncode(& config, & pic);
#line 255
  __cil_tmp15 = (*import)((WebPPicture */* const  */)(& pic), (uint8_t */* const  */)rgba,
                          stride);
  }
#line 255
  if (__cil_tmp15) {
#line 255
    if (__cil_tmp16) {
#line 255
      tmp = 1;
    } else {
#line 255
      tmp = 0;
    }
  } else {
#line 255
    tmp = 0;
  }
  {
#line 255
  ok = tmp;
#line 256
  WebPPictureFree(& pic);
  }
#line 257
  if (! ok) {
    {
#line 258
    WebPMemoryWriterClear(& wrt);
#line 259
    *output = (uint8_t *)((void *)0);
    }
#line 260
    return ((size_t )0);
  }
#line 262
  *output = wrt.mem;
#line 263
  return (wrt.size);
}
}
#line 272 "/root/patron-new/new_3/src/enc/picture_enc.c"
size_t WebPEncodeRGB(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 272
  __cil_tmp7 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportRGB), q,
                      0, out);
  }
#line 272
  return (__cil_tmp7);
}
}
#line 273 "/root/patron-new/new_3/src/enc/picture_enc.c"
size_t WebPEncodeRGBA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 273
  __cil_tmp7 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportRGBA), q,
                      0, out);
  }
#line 273
  return (__cil_tmp7);
}
}
#line 275 "/root/patron-new/new_3/src/enc/picture_enc.c"
size_t WebPEncodeBGR(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 275
  __cil_tmp7 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportBGR), q,
                      0, out);
  }
#line 275
  return (__cil_tmp7);
}
}
#line 276 "/root/patron-new/new_3/src/enc/picture_enc.c"
size_t WebPEncodeBGRA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 276
  __cil_tmp7 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportBGRA), q,
                      0, out);
  }
#line 276
  return (__cil_tmp7);
}
}
#line 287 "/root/patron-new/new_3/src/enc/picture_enc.c"
size_t WebPEncodeLosslessRGB(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 287
  __cil_tmp6 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportRGB), (float )70.,
                      1, out);
  }
#line 287
  return (__cil_tmp6);
}
}
#line 288 "/root/patron-new/new_3/src/enc/picture_enc.c"
size_t WebPEncodeLosslessRGBA(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 288
  __cil_tmp6 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportRGBA), (float )70.,
                      1, out);
  }
#line 288
  return (__cil_tmp6);
}
}
#line 290 "/root/patron-new/new_3/src/enc/picture_enc.c"
size_t WebPEncodeLosslessBGR(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 290
  __cil_tmp6 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportBGR), (float )70.,
                      1, out);
  }
#line 290
  return (__cil_tmp6);
}
}
#line 291 "/root/patron-new/new_3/src/enc/picture_enc.c"
size_t WebPEncodeLosslessBGRA(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 291
  __cil_tmp6 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportBGRA), (float )70.,
                      1, out);
  }
#line 291
  return (__cil_tmp6);
}
}
#line 45 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int CheckNonOpaque(uint8_t *alpha , int width , int height , int x_step , int y_step ) 
{ 
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 47
  if ((unsigned long )alpha == (unsigned long )((void *)0)) {
#line 47
    return (0);
  }
  {
#line 48
  WebPInitAlphaProcessing();
  }
#line 49
  if (x_step == 1) {
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;

#line 50
      if (! (__cil_tmp6 > 0)) {
#line 50
        goto while_break;
      }
      {
#line 51
      __cil_tmp7 = (*WebPHasAlpha8b)(alpha, width);
      }
#line 51
      if (__cil_tmp7) {
#line 51
        return (1);
      }
#line 50
      alpha += y_step;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 54
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 54
      if (! (__cil_tmp8 > 0)) {
#line 54
        goto while_break___0;
      }
      {
#line 55
      __cil_tmp9 = (*WebPHasAlpha32b)(alpha, width);
      }
#line 55
      if (__cil_tmp9) {
#line 55
        return (1);
      }
#line 54
      alpha += y_step;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 58
  return (0);
}
}
#line 62 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
int WebPPictureHasTransparency(WebPPicture *picture ) 
{ 
  int alpha_offset ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 63
  if ((unsigned long )picture == (unsigned long )((void *)0)) {
#line 63
    return (0);
  }
#line 64
  if (picture->use_argb) {
    {
#line 65
    alpha_offset = 3;
#line 66
    __cil_tmp3 = CheckNonOpaque((uint8_t *)picture->argb + alpha_offset, picture->width,
                                picture->height, 4, (int )((unsigned long )picture->argb_stride * sizeof(*(picture->argb))));
    }
#line 66
    return (__cil_tmp3);
  }
  {
#line 70
  __cil_tmp4 = CheckNonOpaque(picture->a, picture->width, picture->height, 1, picture->a_stride);
  }
#line 70
  return (__cil_tmp4);
}
}
#line 88 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int kLinearToGammaTab[33]  ;
#line 89 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static uint16_t kGammaToLinearTab[256]  ;
#line 90 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int kGammaTablesOk  =    0;
#line 91
void InitGammaTables(void) ;
#line 93
static void InitGammaTables_body(void) ;
#line 95 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int (*InitGammaTables_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 96 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static pthread_mutex_t InitGammaTables_body_lock  ;
#line 93 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
void InitGammaTables(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    InitGammaTables_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& InitGammaTables_body_last_cpuinfo_used);
#line 93
    InitGammaTables_body_lock.__data.__lock = 0;
#line 93
    InitGammaTables_body_lock.__data.__count = 0U;
#line 93
    InitGammaTables_body_lock.__data.__owner = 0;
#line 93
    InitGammaTables_body_lock.__data.__nusers = 0U;
#line 93
    InitGammaTables_body_lock.__data.__kind = 0;
#line 93
    InitGammaTables_body_lock.__data.__spins = (short)0;
#line 93
    InitGammaTables_body_lock.__data.__elision = (short)0;
#line 93
    InitGammaTables_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 93
    InitGammaTables_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 93
    __cil_tmp3 = pthread_mutex_lock(& InitGammaTables_body_lock);
    }
#line 93
    if (__cil_tmp3) {
#line 93
      goto while_break;
    }
#line 93
    if ((unsigned long )InitGammaTables_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 93
      InitGammaTables_body();
      }
    }
    {
#line 93
    InitGammaTables_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 93
    pthread_mutex_unlock(& InitGammaTables_body_lock);
    }
#line 93
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 97
  return;
}
}
#line 93 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static void InitGammaTables_body(void) 
{ 
  int v ;
  double scale ;
  double norm ;
  double __cil_tmp4 ;
  double __cil_tmp5 ;

  {
#line 94
  if (! kGammaTablesOk) {
#line 96
    scale = (double )(1 << 7) / (double )((1 << 12) - 1);
#line 97
    norm = 1. / 255.;
#line 98
    v = 0;
    {
#line 98
    while (1) {
      while_continue: /* CIL Label */ ;

#line 98
      if (! (v <= 255)) {
#line 98
        goto while_break;
      }
      {
#line 99
      __cil_tmp4 = pow(norm * (double )v, 0.800000000001);
#line 99
      kGammaToLinearTab[v] = (uint16_t )(__cil_tmp4 * (double )((1 << 12) - 1) + 0.5);
#line 98
      v ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
#line 102
    v = 0;
    {
#line 102
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 102
      if (! (v <= 1 << 5)) {
#line 102
        goto while_break___0;
      }
      {
#line 103
      __cil_tmp5 = pow(scale * (double )v, 1. / 0.800000000001);
#line 103
      kLinearToGammaTab[v] = (int )(255. * __cil_tmp5 + 0.5);
#line 102
      v ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 105
    kGammaTablesOk = 1;
  }
#line 107
  return;
}
}
#line 109 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static uint32_t GammaToLinear(uint8_t v ) 
{ 


  {
#line 110
  return ((uint32_t )kGammaToLinearTab[v]);
}
}
#line 113 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static int Interpolate(int v ) 
{ 
  int tab_pos ;
  int x ;
  int v0 ;
  int v1 ;
  int y ;

  {
#line 114
  tab_pos = v >> 9;
#line 115
  x = v & (((1 << 7) << 2) - 1);
#line 116
  v0 = kLinearToGammaTab[tab_pos];
#line 117
  v1 = kLinearToGammaTab[tab_pos + 1];
#line 118
  y = v1 * x + v0 * (((1 << 7) << 2) - x);
#line 120
  return (y);
}
}
#line 125 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static int LinearToGamma(uint32_t base_value , int shift ) 
{ 
  int y ;
  int __cil_tmp4 ;

  {
  {
#line 126
  __cil_tmp4 = Interpolate((int )(base_value << shift));
#line 126
  y = __cil_tmp4;
  }
#line 127
  return ((y + ((1 << 7) >> 1)) >> 7);
}
}
#line 143 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int RGBToY(int r , int g , int b , VP8Random *rg ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp ;

  {
#line 144
  if ((unsigned long )rg == (unsigned long )((void *)0)) {
    {
#line 144
    __cil_tmp5 = VP8RGBToY(r, g, b, 32768);
#line 144
    tmp = __cil_tmp5;
    }
  } else {
    {
#line 144
    __cil_tmp6 = VP8RandomBits(rg, 16);
#line 144
    __cil_tmp7 = VP8RGBToY(r, g, b, __cil_tmp6);
#line 144
    tmp = __cil_tmp7;
    }
  }
#line 144
  return (tmp);
}
}
#line 148 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int RGBToU(int r , int g , int b , VP8Random *rg ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp ;

  {
#line 149
  if ((unsigned long )rg == (unsigned long )((void *)0)) {
    {
#line 149
    __cil_tmp5 = VP8RGBToU(r, g, b, 32768 << 2);
#line 149
    tmp = __cil_tmp5;
    }
  } else {
    {
#line 149
    __cil_tmp6 = VP8RandomBits(rg, 18);
#line 149
    __cil_tmp7 = VP8RGBToU(r, g, b, __cil_tmp6);
#line 149
    tmp = __cil_tmp7;
    }
  }
#line 149
  return (tmp);
}
}
#line 153 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int RGBToV(int r , int g , int b , VP8Random *rg ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp ;

  {
#line 154
  if ((unsigned long )rg == (unsigned long )((void *)0)) {
    {
#line 154
    __cil_tmp5 = VP8RGBToV(r, g, b, 32768 << 2);
#line 154
    tmp = __cil_tmp5;
    }
  } else {
    {
#line 154
    __cil_tmp6 = VP8RandomBits(rg, 18);
#line 154
    __cil_tmp7 = VP8RGBToV(r, g, b, __cil_tmp6);
#line 154
    tmp = __cil_tmp7;
    }
  }
#line 154
  return (tmp);
}
}
#line 161 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int const   kNumIterations  =    (int const   )4;
#line 162 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int const   kMinDimensionIterativeConversion  =    (int const   )4;
#line 179 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static uint32_t kLinearToGammaTabS[34]  ;
#line 181 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static uint32_t kGammaToLinearTabS[1024]  ;
#line 182 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int kGammaTablesSOk  =    0;
#line 183
void InitGammaTablesS(void) ;
#line 185
static void InitGammaTablesS_body(void) ;
#line 187 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int (*InitGammaTablesS_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 188 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static pthread_mutex_t InitGammaTablesS_body_lock  ;
#line 185 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
void InitGammaTablesS(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 185
    InitGammaTablesS_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& InitGammaTablesS_body_last_cpuinfo_used);
#line 185
    InitGammaTablesS_body_lock.__data.__lock = 0;
#line 185
    InitGammaTablesS_body_lock.__data.__count = 0U;
#line 185
    InitGammaTablesS_body_lock.__data.__owner = 0;
#line 185
    InitGammaTablesS_body_lock.__data.__nusers = 0U;
#line 185
    InitGammaTablesS_body_lock.__data.__kind = 0;
#line 185
    InitGammaTablesS_body_lock.__data.__spins = (short)0;
#line 185
    InitGammaTablesS_body_lock.__data.__elision = (short)0;
#line 185
    InitGammaTablesS_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 185
    InitGammaTablesS_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 185
    __cil_tmp3 = pthread_mutex_lock(& InitGammaTablesS_body_lock);
    }
#line 185
    if (__cil_tmp3) {
#line 185
      goto while_break;
    }
#line 185
    if ((unsigned long )InitGammaTablesS_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 185
      InitGammaTablesS_body();
      }
    }
    {
#line 185
    InitGammaTablesS_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 185
    pthread_mutex_unlock(& InitGammaTablesS_body_lock);
    }
#line 185
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 189
  return;
}
}
#line 185 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static void InitGammaTablesS_body(void) 
{ 
  int v ;
  double norm ;
  double scale ;
  double a ;
  double thresh ;
  double final_scale ;
  double g ;
  double value ;
  double a_rec ;
  double g___0 ;
  double value___0 ;
  double __cil_tmp13 ;

  {
#line 187
  if (! kGammaTablesSOk) {
#line 189
    norm = 1. / (double )((256 << 2) - 1);
#line 190
    scale = 1. / (double )(1 << 5);
#line 191
    a = 0.0992968268095;
#line 192
    thresh = 0.0180539685109;
#line 193
    final_scale = (double )(1 << 14);
#line 194
    v = 0;
    {
#line 194
    while (1) {
      while_continue: /* CIL Label */ ;

#line 194
      if (! (v <= (256 << 2) - 1)) {
#line 194
        goto while_break;
      }
#line 195
      g = norm * (double )v;
#line 197
      if (g <= thresh * 4.5) {
#line 198
        value = g / 4.5;
      } else {
        {
#line 200
        a_rec = 1. / (1. + a);
#line 201
        value = pow(a_rec * (g + a), 1. / 0.450000000001);
        }
      }
#line 203
      kGammaToLinearTabS[v] = (uint32_t )(value * final_scale + 0.5);
#line 194
      v ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
#line 205
    v = 0;
    {
#line 205
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 205
      if (! (v <= 1 << 5)) {
#line 205
        goto while_break___0;
      }
#line 206
      g___0 = scale * (double )v;
#line 208
      if (g___0 <= thresh) {
#line 209
        value___0 = 4.5 * g___0;
      } else {
        {
#line 211
        __cil_tmp13 = pow(g___0, 1. / (1. / 0.450000000001));
#line 211
        value___0 = (1. + a) * __cil_tmp13 - a;
        }
      }
#line 214
      kLinearToGammaTabS[v] = (uint32_t )((double )((256 << 2) - 1) * value___0) + (unsigned int )((1 << 14) >> 1);
#line 205
      v ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 218
    kLinearToGammaTabS[(1 << 5) + 1] = kLinearToGammaTabS[1 << 5];
#line 219
    kGammaTablesSOk = 1;
  }
#line 221
  return;
}
}
#line 224 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static uint32_t GammaToLinearS(int v ) 
{ 


  {
#line 225
  return (kGammaToLinearTabS[v]);
}
}
#line 228 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static uint32_t LinearToGammaS(uint32_t value ) 
{ 
  uint32_t v ;
  uint32_t tab_pos ;
  uint32_t x ;
  uint32_t v0 ;
  uint32_t v1 ;
  uint32_t v2 ;
  uint32_t result ;

  {
#line 230
  v = value * (unsigned int )(1 << 5);
#line 231
  tab_pos = v >> 14;
#line 233
  x = v - (tab_pos << 14);
#line 235
  v0 = kLinearToGammaTabS[tab_pos];
#line 236
  v1 = kLinearToGammaTabS[tab_pos + 1U];
#line 238
  v2 = (v1 - v0) * x;
#line 239
  result = v0 + (v2 >> 14);
#line 240
  return (result);
}
}
#line 257 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static uint8_t clip_8b___0(fixed_t v ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 258
  if (! ((int )v & -256)) {
#line 258
    tmp___0 = (unsigned int )((uint8_t )v);
  } else {
#line 258
    if ((int )v < 0) {
#line 258
      tmp = 0U;
    } else {
#line 258
      tmp = 255U;
    }
#line 258
    tmp___0 = tmp;
  }
#line 258
  return ((uint8_t )tmp___0);
}
}
#line 261 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static fixed_y_t clip_y(int y ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 262
  if (! (y & ~ ((256 << 2) - 1))) {
#line 262
    tmp___0 = (int )((fixed_y_t )y);
  } else {
#line 262
    if (y < 0) {
#line 262
      tmp = 0;
    } else {
#line 262
      tmp = (256 << 2) - 1;
    }
#line 262
    tmp___0 = tmp;
  }
#line 262
  return ((fixed_y_t )tmp___0);
}
}
#line 267 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int RGBToGray(int r , int g , int b ) 
{ 
  int luma ;

  {
#line 268
  luma = ((13933 * r + 46871 * g) + 4732 * b) + 32768;
#line 269
  return (luma >> 16);
}
}
#line 272 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static uint32_t ScaleDown(int a , int b , int c , int d ) 
{ 
  uint32_t A ;
  uint32_t __cil_tmp6 ;
  uint32_t B ;
  uint32_t __cil_tmp8 ;
  uint32_t C ;
  uint32_t __cil_tmp10 ;
  uint32_t D ;
  uint32_t __cil_tmp12 ;
  uint32_t __cil_tmp13 ;

  {
  {
#line 273
  __cil_tmp6 = GammaToLinearS(a);
#line 273
  A = __cil_tmp6;
#line 274
  __cil_tmp8 = GammaToLinearS(b);
#line 274
  B = __cil_tmp8;
#line 275
  __cil_tmp10 = GammaToLinearS(c);
#line 275
  C = __cil_tmp10;
#line 276
  __cil_tmp12 = GammaToLinearS(d);
#line 276
  D = __cil_tmp12;
#line 277
  __cil_tmp13 = LinearToGammaS(((((A + B) + C) + D) + 2U) >> 2);
  }
#line 277
  return (__cil_tmp13);
}
}
#line 280 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static void UpdateW(fixed_y_t *src , fixed_y_t *dst , int w ) 
{ 
  int i ;
  uint32_t R ;
  uint32_t __cil_tmp6 ;
  uint32_t G ;
  uint32_t __cil_tmp8 ;
  uint32_t B ;
  uint32_t __cil_tmp10 ;
  uint32_t Y ;
  int __cil_tmp12 ;
  uint32_t __cil_tmp13 ;

  {
#line 282
  i = 0;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;

#line 282
    if (! (i < w)) {
#line 282
      goto while_break;
    }
    {
#line 283
    __cil_tmp6 = GammaToLinearS((int )*(src + i));
#line 283
    R = __cil_tmp6;
#line 284
    __cil_tmp8 = GammaToLinearS((int )*(src + (w + i)));
#line 284
    G = __cil_tmp8;
#line 285
    __cil_tmp10 = GammaToLinearS((int )*(src + (2 * w + i)));
#line 285
    B = __cil_tmp10;
#line 286
    __cil_tmp12 = RGBToGray((int )R, (int )G, (int )B);
#line 286
    Y = (uint32_t )__cil_tmp12;
#line 287
    __cil_tmp13 = LinearToGammaS(Y);
#line 287
    *(dst + i) = (fixed_y_t )__cil_tmp13;
#line 282
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 286
  return;
}
}
#line 291 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static void UpdateChroma(fixed_y_t *src1 , fixed_y_t *src2 , fixed_t *dst , int uv_w ) 
{ 
  int i ;
  int r ;
  uint32_t __cil_tmp7 ;
  int g ;
  uint32_t __cil_tmp9 ;
  int b ;
  uint32_t __cil_tmp11 ;
  int W ;
  int __cil_tmp13 ;

  {
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;

#line 294
    if (! (i < uv_w)) {
#line 294
      goto while_break;
    }
    {
#line 295
    __cil_tmp7 = ScaleDown((int )*(src1 + 0), (int )*(src1 + 1), (int )*(src2 + 0),
                           (int )*(src2 + 1));
#line 295
    r = (int )__cil_tmp7;
#line 297
    __cil_tmp9 = ScaleDown((int )*(src1 + 2 * uv_w), (int )*(src1 + (2 * uv_w + 1)),
                           (int )*(src2 + 2 * uv_w), (int )*(src2 + (2 * uv_w + 1)));
#line 297
    g = (int )__cil_tmp9;
#line 299
    __cil_tmp11 = ScaleDown((int )*(src1 + 4 * uv_w), (int )*(src1 + (4 * uv_w + 1)),
                            (int )*(src2 + 4 * uv_w), (int )*(src2 + (4 * uv_w + 1)));
#line 299
    b = (int )__cil_tmp11;
#line 301
    __cil_tmp13 = RGBToGray(r, g, b);
#line 301
    W = __cil_tmp13;
#line 302
    *(dst + 0) = (fixed_t )(r - W);
#line 303
    *(dst + uv_w) = (fixed_t )(g - W);
#line 304
    *(dst + 2 * uv_w) = (fixed_t )(b - W);
#line 305
    dst ++;
#line 306
    src1 += 2;
#line 307
    src2 += 2;
#line 294
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 298
  return;
}
}
#line 311 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static void StoreGray(fixed_y_t *rgb , fixed_y_t *y , int w ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 313
  i = 0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;

#line 313
    if (! (i < w)) {
#line 313
      goto while_break;
    }
    {
#line 314
    __cil_tmp5 = RGBToGray((int )*(rgb + i), (int )*(rgb + (w + i)), (int )*(rgb + (2 * w + i)));
#line 314
    *(y + i) = (fixed_y_t )__cil_tmp5;
#line 313
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 317
  return;
}
}
#line 320 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static fixed_y_t Filter2(int A , int B , int W0 ) 
{ 
  int v0 ;
  fixed_y_t __cil_tmp5 ;

  {
  {
#line 321
  v0 = ((A * 3 + B) + 2) >> 2;
#line 322
  __cil_tmp5 = clip_y(v0 + W0);
  }
#line 322
  return (__cil_tmp5);
}
}
#line 327 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static fixed_y_t UpLift(uint8_t a ) 
{ 


  {
#line 328
  return ((fixed_y_t )(((int )((fixed_y_t )a) << 2) | ((1 << 2) >> 1)));
}
}
#line 331 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static void ImportOneRow(uint8_t *r_ptr , uint8_t *g_ptr , uint8_t *b_ptr , int step ,
                         int pic_width , fixed_y_t *dst ) 
{ 
  int i ;
  int w ;
  int off ;

  {
#line 338
  w = (pic_width + 1) & -2;
#line 339
  i = 0;
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;

#line 339
    if (! (i < pic_width)) {
#line 339
      goto while_break;
    }
    {
#line 340
    off = i * step;
#line 341
    *(dst + i) = UpLift(*(r_ptr + off));
#line 342
    *(dst + (i + w)) = UpLift(*(g_ptr + off));
#line 343
    *(dst + (i + 2 * w)) = UpLift(*(b_ptr + off));
#line 339
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 345
  if (pic_width & 1) {
#line 346
    *(dst + pic_width) = *(dst + (pic_width - 1));
#line 347
    *(dst + (pic_width + w)) = *(dst + ((pic_width + w) - 1));
#line 348
    *(dst + (pic_width + 2 * w)) = *(dst + ((pic_width + 2 * w) - 1));
  }
#line 350
  return;
}
}
#line 352 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static void InterpolateTwoRows(fixed_y_t *best_y , fixed_t *prev_uv , fixed_t *cur_uv ,
                               fixed_t *next_uv , int w , fixed_y_t *out1 , fixed_y_t *out2 ) 
{ 
  int uv_w ;
  int len ;
  int k ;
  int __cil_tmp11 ;

  {
#line 359
  uv_w = w >> 1;
#line 360
  len = (w - 1) >> 1;
#line 361
  k = 3;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    __cil_tmp11 = k;
#line 362
    k --;
#line 362
    if (! (__cil_tmp11 > 0)) {
#line 362
      goto while_break;
    }
    {
#line 364
    *(out1 + 0) = Filter2((int )*(cur_uv + 0), (int )*(prev_uv + 0), (int )*(best_y + 0));
#line 365
    *(out2 + 0) = Filter2((int )*(cur_uv + 0), (int )*(next_uv + 0), (int )*(best_y + w));
#line 367
    (*WebPSharpYUVFilterRow)(cur_uv, prev_uv, len, (best_y + 0) + 1, out1 + 1);
#line 368
    (*WebPSharpYUVFilterRow)(cur_uv, next_uv, len, (best_y + w) + 1, out2 + 1);
    }
#line 371
    if (! (w & 1)) {
      {
#line 372
      *(out1 + (w - 1)) = Filter2((int )*(cur_uv + (uv_w - 1)), (int )*(prev_uv + (uv_w - 1)),
                                  (int )*(best_y + (w - 1)));
#line 374
      *(out2 + (w - 1)) = Filter2((int )*(cur_uv + (uv_w - 1)), (int )*(next_uv + (uv_w - 1)),
                                  (int )*(best_y + ((w - 1) + w)));
      }
    }
#line 377
    out1 += w;
#line 378
    out2 += w;
#line 379
    prev_uv += uv_w;
#line 380
    cur_uv += uv_w;
#line 381
    next_uv += uv_w;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 385
  return;
}
}
#line 385 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static uint8_t ConvertRGBToY(int r , int g , int b ) 
{ 
  int luma ;
  uint8_t __cil_tmp5 ;

  {
  {
#line 386
  luma = ((16839 * r + 33059 * g) + 6420 * b) + (1 << 17);
#line 387
  __cil_tmp5 = clip_8b___0((fixed_t )(16 + (luma >> 18)));
  }
#line 387
  return (__cil_tmp5);
}
}
#line 390 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static uint8_t ConvertRGBToU(int r , int g , int b ) 
{ 
  int u ;
  uint8_t __cil_tmp5 ;

  {
  {
#line 391
  u = ((-9719 * r - 19081 * g) + 28800 * b) + (1 << 17);
#line 392
  __cil_tmp5 = clip_8b___0((fixed_t )(128 + (u >> 18)));
  }
#line 392
  return (__cil_tmp5);
}
}
#line 395 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static uint8_t ConvertRGBToV(int r , int g , int b ) 
{ 
  int v ;
  uint8_t __cil_tmp5 ;

  {
  {
#line 396
  v = ((28800 * r - 24116 * g) - 4684 * b) + (1 << 17);
#line 397
  __cil_tmp5 = clip_8b___0((fixed_t )(128 + (v >> 18)));
  }
#line 397
  return (__cil_tmp5);
}
}
#line 400 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int ConvertWRGBToYUV(fixed_y_t *best_y , fixed_t *best_uv , WebPPicture *picture ) 
{ 
  int i ;
  int j ;
  uint8_t *dst_y ;
  uint8_t *dst_u ;
  uint8_t *dst_v ;
  fixed_t *best_uv_base ;
  int w ;
  int h ;
  int uv_w ;
  int uv_h ;
  int off ;
  int W ;
  int r ;
  int g ;
  int b ;
  int off___0 ;
  int r___0 ;
  int g___0 ;
  int b___0 ;

  {
#line 403
  dst_y = picture->y;
#line 404
  dst_u = picture->u;
#line 405
  dst_v = picture->v;
#line 406
  best_uv_base = best_uv;
#line 407
  w = (picture->width + 1) & -2;
#line 408
  h = (picture->height + 1) & -2;
#line 409
  uv_w = w >> 1;
#line 410
  uv_h = h >> 1;
#line 411
  j = 0;
#line 411
  best_uv = best_uv_base;
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;

#line 411
    if (! (j < picture->height)) {
#line 411
      goto while_break;
    }
#line 412
    i = 0;
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 412
      if (! (i < picture->width)) {
#line 412
        goto while_break___0;
      }
      {
#line 413
      off = i >> 1;
#line 414
      W = (int )*(best_y + i);
#line 415
      r = (int )*(best_uv + off) + W;
#line 416
      g = (int )*(best_uv + (off + uv_w)) + W;
#line 417
      b = (int )*(best_uv + (off + 2 * uv_w)) + W;
#line 418
      *(dst_y + i) = ConvertRGBToY(r, g, b);
#line 412
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 420
    best_y += w;
#line 421
    best_uv += ((j & 1) * 3) * uv_w;
#line 422
    dst_y += picture->y_stride;
#line 411
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 424
  j = 0;
#line 424
  best_uv = best_uv_base;
  {
#line 424
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 424
    if (! (j < uv_h)) {
#line 424
      goto while_break___1;
    }
#line 425
    i = 0;
    {
#line 425
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 425
      if (! (i < uv_w)) {
#line 425
        goto while_break___2;
      }
      {
#line 426
      off___0 = i;
#line 427
      r___0 = (int )*(best_uv + off___0);
#line 428
      g___0 = (int )*(best_uv + (off___0 + uv_w));
#line 429
      b___0 = (int )*(best_uv + (off___0 + 2 * uv_w));
#line 430
      *(dst_u + i) = ConvertRGBToU(r___0, g___0, b___0);
#line 431
      *(dst_v + i) = ConvertRGBToV(r___0, g___0, b___0);
#line 425
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 433
    best_uv += 3 * uv_w;
#line 434
    dst_u += picture->uv_stride;
#line 435
    dst_v += picture->uv_stride;
#line 424
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 437
  return (1);
}
}
#line 445 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int PreprocessARGB(uint8_t *r_ptr , uint8_t *g_ptr , uint8_t *b_ptr , int step ,
                          int rgb_stride , WebPPicture *picture ) 
{ 
  int w ;
  int h ;
  int uv_w ;
  int uv_h ;
  uint64_t prev_diff_y_sum ;
  int j ;
  int iter ;
  fixed_y_t *tmp_buffer ;
  void *__cil_tmp15 ;
  fixed_y_t *best_y_base ;
  void *__cil_tmp17 ;
  fixed_y_t *target_y_base ;
  void *__cil_tmp19 ;
  fixed_y_t *best_rgb_y ;
  void *__cil_tmp21 ;
  fixed_t *best_uv_base ;
  void *__cil_tmp23 ;
  fixed_t *target_uv_base ;
  void *__cil_tmp25 ;
  fixed_t *best_rgb_uv ;
  void *__cil_tmp27 ;
  fixed_y_t *best_y ;
  fixed_y_t *target_y ;
  fixed_t *best_uv ;
  fixed_t *target_uv ;
  uint64_t diff_y_threshold ;
  int ok ;
  int is_last_row ;
  fixed_y_t *src1 ;
  fixed_y_t *src2 ;
  fixed_t *cur_uv ;
  fixed_t *prev_uv ;
  uint64_t diff_y_sum ;
  fixed_y_t *src1___0 ;
  fixed_y_t *src2___0 ;
  fixed_t *next_uv ;
  int tmp ;
  uint64_t __cil_tmp45 ;

  {
  {
#line 451
  w = (picture->width + 1) & -2;
#line 452
  h = (picture->height + 1) & -2;
#line 453
  uv_w = w >> 1;
#line 454
  uv_h = h >> 1;
#line 455
  prev_diff_y_sum = (uint64_t )(~ 0);
#line 460
  __cil_tmp15 = WebPSafeMalloc((uint64_t )((w * 3) * 2), sizeof(fixed_y_t ));
#line 460
  tmp_buffer = (fixed_y_t *)__cil_tmp15;
#line 461
  __cil_tmp17 = WebPSafeMalloc((uint64_t )(w * h), sizeof(fixed_y_t ));
#line 461
  best_y_base = (fixed_y_t *)__cil_tmp17;
#line 462
  __cil_tmp19 = WebPSafeMalloc((uint64_t )(w * h), sizeof(fixed_y_t ));
#line 462
  target_y_base = (fixed_y_t *)__cil_tmp19;
#line 463
  __cil_tmp21 = WebPSafeMalloc((uint64_t )(w * 2), sizeof(fixed_y_t ));
#line 463
  best_rgb_y = (fixed_y_t *)__cil_tmp21;
#line 464
  __cil_tmp23 = WebPSafeMalloc((uint64_t )((uv_w * 3) * uv_h), sizeof(fixed_t ));
#line 464
  best_uv_base = (fixed_t *)__cil_tmp23;
#line 465
  __cil_tmp25 = WebPSafeMalloc((uint64_t )((uv_w * 3) * uv_h), sizeof(fixed_t ));
#line 465
  target_uv_base = (fixed_t *)__cil_tmp25;
#line 466
  __cil_tmp27 = WebPSafeMalloc((uint64_t )(uv_w * 3), sizeof(fixed_t ));
#line 466
  best_rgb_uv = (fixed_t *)__cil_tmp27;
#line 467
  best_y = best_y_base;
#line 468
  target_y = target_y_base;
#line 469
  best_uv = best_uv_base;
#line 470
  target_uv = target_uv_base;
#line 471
  diff_y_threshold = (uint64_t )((3. * (double )w) * (double )h);
  }
#line 474
  if ((unsigned long )best_y_base == (unsigned long )((void *)0)) {
    {
#line 478
    ok = WebPEncodingSetError(picture, (WebPEncodingError )1);
    }
#line 479
    goto End;
  } else
#line 474
  if ((unsigned long )best_uv_base == (unsigned long )((void *)0)) {
    {
#line 478
    ok = WebPEncodingSetError(picture, (WebPEncodingError )1);
    }
#line 479
    goto End;
  } else
#line 474
  if ((unsigned long )target_y_base == (unsigned long )((void *)0)) {
    {
#line 478
    ok = WebPEncodingSetError(picture, (WebPEncodingError )1);
    }
#line 479
    goto End;
  } else
#line 474
  if ((unsigned long )target_uv_base == (unsigned long )((void *)0)) {
    {
#line 478
    ok = WebPEncodingSetError(picture, (WebPEncodingError )1);
    }
#line 479
    goto End;
  } else
#line 474
  if ((unsigned long )best_rgb_y == (unsigned long )((void *)0)) {
    {
#line 478
    ok = WebPEncodingSetError(picture, (WebPEncodingError )1);
    }
#line 479
    goto End;
  } else
#line 474
  if ((unsigned long )best_rgb_uv == (unsigned long )((void *)0)) {
    {
#line 478
    ok = WebPEncodingSetError(picture, (WebPEncodingError )1);
    }
#line 479
    goto End;
  } else
#line 474
  if ((unsigned long )tmp_buffer == (unsigned long )((void *)0)) {
    {
#line 478
    ok = WebPEncodingSetError(picture, (WebPEncodingError )1);
    }
#line 479
    goto End;
  }
  {
#line 484
  WebPInitConvertARGBToYUV();
#line 487
  j = 0;
  }
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;

#line 487
    if (! (j < picture->height)) {
#line 487
      goto while_break;
    }
    {
#line 488
    is_last_row = j == picture->height - 1;
#line 489
    src1 = tmp_buffer + 0;
#line 490
    src2 = tmp_buffer + 3 * w;
#line 493
    ImportOneRow(r_ptr, g_ptr, b_ptr, step, picture->width, src1);
    }
#line 494
    if (! is_last_row) {
      {
#line 495
      ImportOneRow(r_ptr + rgb_stride, g_ptr + rgb_stride, b_ptr + rgb_stride, step,
                   picture->width, src2);
      }
    } else {
      {
#line 498
      memcpy((void *)src2, (void const   *)src1, (unsigned long )(3 * w) * sizeof(*src2));
      }
    }
    {
#line 500
    StoreGray(src1, best_y + 0, w);
#line 501
    StoreGray(src2, best_y + w, w);
#line 503
    UpdateW(src1, target_y, w);
#line 504
    UpdateW(src2, target_y + w, w);
#line 505
    UpdateChroma(src1, src2, target_uv, uv_w);
#line 506
    memcpy((void *)best_uv, (void const   *)target_uv, (unsigned long )(3 * uv_w) * sizeof(*best_uv));
#line 507
    best_y += 2 * w;
#line 508
    best_uv += 3 * uv_w;
#line 509
    target_y += 2 * w;
#line 510
    target_uv += 3 * uv_w;
#line 511
    r_ptr += 2 * rgb_stride;
#line 512
    g_ptr += 2 * rgb_stride;
#line 513
    b_ptr += 2 * rgb_stride;
#line 487
    j += 2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 517
  iter = 0;
  {
#line 517
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 517
    if (! (iter < (int )kNumIterations)) {
#line 517
      goto while_break___0;
    }
#line 518
    cur_uv = best_uv_base;
#line 519
    prev_uv = best_uv_base;
#line 520
    diff_y_sum = (uint64_t )0;
#line 522
    best_y = best_y_base;
#line 523
    best_uv = best_uv_base;
#line 524
    target_y = target_y_base;
#line 525
    target_uv = target_uv_base;
#line 526
    j = 0;
    {
#line 526
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 526
      if (! (j < h)) {
#line 526
        goto while_break___1;
      }
#line 527
      src1___0 = tmp_buffer + 0;
#line 528
      src2___0 = tmp_buffer + 3 * w;
#line 530
      if (j < h - 2) {
#line 530
        tmp = 3 * uv_w;
      } else {
#line 530
        tmp = 0;
      }
      {
#line 530
      next_uv = cur_uv + tmp;
#line 531
      InterpolateTwoRows(best_y, prev_uv, cur_uv, next_uv, w, src1___0, src2___0);
#line 532
      prev_uv = cur_uv;
#line 533
      cur_uv = next_uv;
#line 536
      UpdateW(src1___0, best_rgb_y + 0, w);
#line 537
      UpdateW(src2___0, best_rgb_y + w, w);
#line 538
      UpdateChroma(src1___0, src2___0, best_rgb_uv, uv_w);
#line 541
      __cil_tmp45 = (*WebPSharpYUVUpdateY)(target_y, best_rgb_y, best_y, 2 * w);
#line 541
      diff_y_sum += __cil_tmp45;
#line 542
      (*WebPSharpYUVUpdateRGB)(target_uv, best_rgb_uv, best_uv, 3 * uv_w);
#line 544
      best_y += 2 * w;
#line 545
      best_uv += 3 * uv_w;
#line 546
      target_y += 2 * w;
#line 547
      target_uv += 3 * uv_w;
#line 526
      j += 2;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
#line 550
    if (iter > 0) {
#line 551
      if (diff_y_sum < diff_y_threshold) {
#line 551
        goto while_break___0;
      }
#line 552
      if (diff_y_sum > prev_diff_y_sum) {
#line 552
        goto while_break___0;
      }
    }
#line 554
    prev_diff_y_sum = diff_y_sum;
#line 517
    iter ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 557
  ok = ConvertWRGBToYUV(best_y_base, best_uv_base, picture);
  }
  End: 
  {
#line 560
  WebPSafeFree((void *)best_y_base);
#line 561
  WebPSafeFree((void *)best_uv_base);
#line 562
  WebPSafeFree((void *)target_y_base);
#line 563
  WebPSafeFree((void *)target_uv_base);
#line 564
  WebPSafeFree((void *)best_rgb_y);
#line 565
  WebPSafeFree((void *)best_rgb_uv);
#line 566
  WebPSafeFree((void *)tmp_buffer);
  }
#line 567
  return (ok);
}
}
#line 588 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int const   kAlphaFix  =    (int const   )19;
#line 596 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static uint32_t kInvAlpha[1021]  = 
#line 596
  {      (uint32_t )0,      (uint32_t )524288,      (uint32_t )262144,      (uint32_t )174762, 
        (uint32_t )131072,      (uint32_t )104857,      (uint32_t )87381,      (uint32_t )74898, 
        (uint32_t )65536,      (uint32_t )58254,      (uint32_t )52428,      (uint32_t )47662, 
        (uint32_t )43690,      (uint32_t )40329,      (uint32_t )37449,      (uint32_t )34952, 
        (uint32_t )32768,      (uint32_t )30840,      (uint32_t )29127,      (uint32_t )27594, 
        (uint32_t )26214,      (uint32_t )24966,      (uint32_t )23831,      (uint32_t )22795, 
        (uint32_t )21845,      (uint32_t )20971,      (uint32_t )20164,      (uint32_t )19418, 
        (uint32_t )18724,      (uint32_t )18078,      (uint32_t )17476,      (uint32_t )16912, 
        (uint32_t )16384,      (uint32_t )15887,      (uint32_t )15420,      (uint32_t )14979, 
        (uint32_t )14563,      (uint32_t )14169,      (uint32_t )13797,      (uint32_t )13443, 
        (uint32_t )13107,      (uint32_t )12787,      (uint32_t )12483,      (uint32_t )12192, 
        (uint32_t )11915,      (uint32_t )11650,      (uint32_t )11397,      (uint32_t )11155, 
        (uint32_t )10922,      (uint32_t )10699,      (uint32_t )10485,      (uint32_t )10280, 
        (uint32_t )10082,      (uint32_t )9892,      (uint32_t )9709,      (uint32_t )9532, 
        (uint32_t )9362,      (uint32_t )9198,      (uint32_t )9039,      (uint32_t )8886, 
        (uint32_t )8738,      (uint32_t )8594,      (uint32_t )8456,      (uint32_t )8322, 
        (uint32_t )8192,      (uint32_t )8065,      (uint32_t )7943,      (uint32_t )7825, 
        (uint32_t )7710,      (uint32_t )7598,      (uint32_t )7489,      (uint32_t )7384, 
        (uint32_t )7281,      (uint32_t )7182,      (uint32_t )7084,      (uint32_t )6990, 
        (uint32_t )6898,      (uint32_t )6808,      (uint32_t )6721,      (uint32_t )6636, 
        (uint32_t )6553,      (uint32_t )6472,      (uint32_t )6393,      (uint32_t )6316, 
        (uint32_t )6241,      (uint32_t )6168,      (uint32_t )6096,      (uint32_t )6026, 
        (uint32_t )5957,      (uint32_t )5890,      (uint32_t )5825,      (uint32_t )5761, 
        (uint32_t )5698,      (uint32_t )5637,      (uint32_t )5577,      (uint32_t )5518, 
        (uint32_t )5461,      (uint32_t )5405,      (uint32_t )5349,      (uint32_t )5295, 
        (uint32_t )5242,      (uint32_t )5190,      (uint32_t )5140,      (uint32_t )5090, 
        (uint32_t )5041,      (uint32_t )4993,      (uint32_t )4946,      (uint32_t )4899, 
        (uint32_t )4854,      (uint32_t )4809,      (uint32_t )4766,      (uint32_t )4723, 
        (uint32_t )4681,      (uint32_t )4639,      (uint32_t )4599,      (uint32_t )4559, 
        (uint32_t )4519,      (uint32_t )4481,      (uint32_t )4443,      (uint32_t )4405, 
        (uint32_t )4369,      (uint32_t )4332,      (uint32_t )4297,      (uint32_t )4262, 
        (uint32_t )4228,      (uint32_t )4194,      (uint32_t )4161,      (uint32_t )4128, 
        (uint32_t )4096,      (uint32_t )4064,      (uint32_t )4032,      (uint32_t )4002, 
        (uint32_t )3971,      (uint32_t )3942,      (uint32_t )3912,      (uint32_t )3883, 
        (uint32_t )3855,      (uint32_t )3826,      (uint32_t )3799,      (uint32_t )3771, 
        (uint32_t )3744,      (uint32_t )3718,      (uint32_t )3692,      (uint32_t )3666, 
        (uint32_t )3640,      (uint32_t )3615,      (uint32_t )3591,      (uint32_t )3566, 
        (uint32_t )3542,      (uint32_t )3518,      (uint32_t )3495,      (uint32_t )3472, 
        (uint32_t )3449,      (uint32_t )3426,      (uint32_t )3404,      (uint32_t )3382, 
        (uint32_t )3360,      (uint32_t )3339,      (uint32_t )3318,      (uint32_t )3297, 
        (uint32_t )3276,      (uint32_t )3256,      (uint32_t )3236,      (uint32_t )3216, 
        (uint32_t )3196,      (uint32_t )3177,      (uint32_t )3158,      (uint32_t )3139, 
        (uint32_t )3120,      (uint32_t )3102,      (uint32_t )3084,      (uint32_t )3066, 
        (uint32_t )3048,      (uint32_t )3030,      (uint32_t )3013,      (uint32_t )2995, 
        (uint32_t )2978,      (uint32_t )2962,      (uint32_t )2945,      (uint32_t )2928, 
        (uint32_t )2912,      (uint32_t )2896,      (uint32_t )2880,      (uint32_t )2864, 
        (uint32_t )2849,      (uint32_t )2833,      (uint32_t )2818,      (uint32_t )2803, 
        (uint32_t )2788,      (uint32_t )2774,      (uint32_t )2759,      (uint32_t )2744, 
        (uint32_t )2730,      (uint32_t )2716,      (uint32_t )2702,      (uint32_t )2688, 
        (uint32_t )2674,      (uint32_t )2661,      (uint32_t )2647,      (uint32_t )2634, 
        (uint32_t )2621,      (uint32_t )2608,      (uint32_t )2595,      (uint32_t )2582, 
        (uint32_t )2570,      (uint32_t )2557,      (uint32_t )2545,      (uint32_t )2532, 
        (uint32_t )2520,      (uint32_t )2508,      (uint32_t )2496,      (uint32_t )2484, 
        (uint32_t )2473,      (uint32_t )2461,      (uint32_t )2449,      (uint32_t )2438, 
        (uint32_t )2427,      (uint32_t )2416,      (uint32_t )2404,      (uint32_t )2394, 
        (uint32_t )2383,      (uint32_t )2372,      (uint32_t )2361,      (uint32_t )2351, 
        (uint32_t )2340,      (uint32_t )2330,      (uint32_t )2319,      (uint32_t )2309, 
        (uint32_t )2299,      (uint32_t )2289,      (uint32_t )2279,      (uint32_t )2269, 
        (uint32_t )2259,      (uint32_t )2250,      (uint32_t )2240,      (uint32_t )2231, 
        (uint32_t )2221,      (uint32_t )2212,      (uint32_t )2202,      (uint32_t )2193, 
        (uint32_t )2184,      (uint32_t )2175,      (uint32_t )2166,      (uint32_t )2157, 
        (uint32_t )2148,      (uint32_t )2139,      (uint32_t )2131,      (uint32_t )2122, 
        (uint32_t )2114,      (uint32_t )2105,      (uint32_t )2097,      (uint32_t )2088, 
        (uint32_t )2080,      (uint32_t )2072,      (uint32_t )2064,      (uint32_t )2056, 
        (uint32_t )2048,      (uint32_t )2040,      (uint32_t )2032,      (uint32_t )2024, 
        (uint32_t )2016,      (uint32_t )2008,      (uint32_t )2001,      (uint32_t )1993, 
        (uint32_t )1985,      (uint32_t )1978,      (uint32_t )1971,      (uint32_t )1963, 
        (uint32_t )1956,      (uint32_t )1949,      (uint32_t )1941,      (uint32_t )1934, 
        (uint32_t )1927,      (uint32_t )1920,      (uint32_t )1913,      (uint32_t )1906, 
        (uint32_t )1899,      (uint32_t )1892,      (uint32_t )1885,      (uint32_t )1879, 
        (uint32_t )1872,      (uint32_t )1865,      (uint32_t )1859,      (uint32_t )1852, 
        (uint32_t )1846,      (uint32_t )1839,      (uint32_t )1833,      (uint32_t )1826, 
        (uint32_t )1820,      (uint32_t )1814,      (uint32_t )1807,      (uint32_t )1801, 
        (uint32_t )1795,      (uint32_t )1789,      (uint32_t )1783,      (uint32_t )1777, 
        (uint32_t )1771,      (uint32_t )1765,      (uint32_t )1759,      (uint32_t )1753, 
        (uint32_t )1747,      (uint32_t )1741,      (uint32_t )1736,      (uint32_t )1730, 
        (uint32_t )1724,      (uint32_t )1718,      (uint32_t )1713,      (uint32_t )1707, 
        (uint32_t )1702,      (uint32_t )1696,      (uint32_t )1691,      (uint32_t )1685, 
        (uint32_t )1680,      (uint32_t )1675,      (uint32_t )1669,      (uint32_t )1664, 
        (uint32_t )1659,      (uint32_t )1653,      (uint32_t )1648,      (uint32_t )1643, 
        (uint32_t )1638,      (uint32_t )1633,      (uint32_t )1628,      (uint32_t )1623, 
        (uint32_t )1618,      (uint32_t )1613,      (uint32_t )1608,      (uint32_t )1603, 
        (uint32_t )1598,      (uint32_t )1593,      (uint32_t )1588,      (uint32_t )1583, 
        (uint32_t )1579,      (uint32_t )1574,      (uint32_t )1569,      (uint32_t )1565, 
        (uint32_t )1560,      (uint32_t )1555,      (uint32_t )1551,      (uint32_t )1546, 
        (uint32_t )1542,      (uint32_t )1537,      (uint32_t )1533,      (uint32_t )1528, 
        (uint32_t )1524,      (uint32_t )1519,      (uint32_t )1515,      (uint32_t )1510, 
        (uint32_t )1506,      (uint32_t )1502,      (uint32_t )1497,      (uint32_t )1493, 
        (uint32_t )1489,      (uint32_t )1485,      (uint32_t )1481,      (uint32_t )1476, 
        (uint32_t )1472,      (uint32_t )1468,      (uint32_t )1464,      (uint32_t )1460, 
        (uint32_t )1456,      (uint32_t )1452,      (uint32_t )1448,      (uint32_t )1444, 
        (uint32_t )1440,      (uint32_t )1436,      (uint32_t )1432,      (uint32_t )1428, 
        (uint32_t )1424,      (uint32_t )1420,      (uint32_t )1416,      (uint32_t )1413, 
        (uint32_t )1409,      (uint32_t )1405,      (uint32_t )1401,      (uint32_t )1398, 
        (uint32_t )1394,      (uint32_t )1390,      (uint32_t )1387,      (uint32_t )1383, 
        (uint32_t )1379,      (uint32_t )1376,      (uint32_t )1372,      (uint32_t )1368, 
        (uint32_t )1365,      (uint32_t )1361,      (uint32_t )1358,      (uint32_t )1354, 
        (uint32_t )1351,      (uint32_t )1347,      (uint32_t )1344,      (uint32_t )1340, 
        (uint32_t )1337,      (uint32_t )1334,      (uint32_t )1330,      (uint32_t )1327, 
        (uint32_t )1323,      (uint32_t )1320,      (uint32_t )1317,      (uint32_t )1314, 
        (uint32_t )1310,      (uint32_t )1307,      (uint32_t )1304,      (uint32_t )1300, 
        (uint32_t )1297,      (uint32_t )1294,      (uint32_t )1291,      (uint32_t )1288, 
        (uint32_t )1285,      (uint32_t )1281,      (uint32_t )1278,      (uint32_t )1275, 
        (uint32_t )1272,      (uint32_t )1269,      (uint32_t )1266,      (uint32_t )1263, 
        (uint32_t )1260,      (uint32_t )1257,      (uint32_t )1254,      (uint32_t )1251, 
        (uint32_t )1248,      (uint32_t )1245,      (uint32_t )1242,      (uint32_t )1239, 
        (uint32_t )1236,      (uint32_t )1233,      (uint32_t )1230,      (uint32_t )1227, 
        (uint32_t )1224,      (uint32_t )1222,      (uint32_t )1219,      (uint32_t )1216, 
        (uint32_t )1213,      (uint32_t )1210,      (uint32_t )1208,      (uint32_t )1205, 
        (uint32_t )1202,      (uint32_t )1199,      (uint32_t )1197,      (uint32_t )1194, 
        (uint32_t )1191,      (uint32_t )1188,      (uint32_t )1186,      (uint32_t )1183, 
        (uint32_t )1180,      (uint32_t )1178,      (uint32_t )1175,      (uint32_t )1172, 
        (uint32_t )1170,      (uint32_t )1167,      (uint32_t )1165,      (uint32_t )1162, 
        (uint32_t )1159,      (uint32_t )1157,      (uint32_t )1154,      (uint32_t )1152, 
        (uint32_t )1149,      (uint32_t )1147,      (uint32_t )1144,      (uint32_t )1142, 
        (uint32_t )1139,      (uint32_t )1137,      (uint32_t )1134,      (uint32_t )1132, 
        (uint32_t )1129,      (uint32_t )1127,      (uint32_t )1125,      (uint32_t )1122, 
        (uint32_t )1120,      (uint32_t )1117,      (uint32_t )1115,      (uint32_t )1113, 
        (uint32_t )1110,      (uint32_t )1108,      (uint32_t )1106,      (uint32_t )1103, 
        (uint32_t )1101,      (uint32_t )1099,      (uint32_t )1096,      (uint32_t )1094, 
        (uint32_t )1092,      (uint32_t )1089,      (uint32_t )1087,      (uint32_t )1085, 
        (uint32_t )1083,      (uint32_t )1081,      (uint32_t )1078,      (uint32_t )1076, 
        (uint32_t )1074,      (uint32_t )1072,      (uint32_t )1069,      (uint32_t )1067, 
        (uint32_t )1065,      (uint32_t )1063,      (uint32_t )1061,      (uint32_t )1059, 
        (uint32_t )1057,      (uint32_t )1054,      (uint32_t )1052,      (uint32_t )1050, 
        (uint32_t )1048,      (uint32_t )1046,      (uint32_t )1044,      (uint32_t )1042, 
        (uint32_t )1040,      (uint32_t )1038,      (uint32_t )1036,      (uint32_t )1034, 
        (uint32_t )1032,      (uint32_t )1030,      (uint32_t )1028,      (uint32_t )1026, 
        (uint32_t )1024,      (uint32_t )1022,      (uint32_t )1020,      (uint32_t )1018, 
        (uint32_t )1016,      (uint32_t )1014,      (uint32_t )1012,      (uint32_t )1010, 
        (uint32_t )1008,      (uint32_t )1006,      (uint32_t )1004,      (uint32_t )1002, 
        (uint32_t )1000,      (uint32_t )998,      (uint32_t )996,      (uint32_t )994, 
        (uint32_t )992,      (uint32_t )991,      (uint32_t )989,      (uint32_t )987, 
        (uint32_t )985,      (uint32_t )983,      (uint32_t )981,      (uint32_t )979, 
        (uint32_t )978,      (uint32_t )976,      (uint32_t )974,      (uint32_t )972, 
        (uint32_t )970,      (uint32_t )969,      (uint32_t )967,      (uint32_t )965, 
        (uint32_t )963,      (uint32_t )961,      (uint32_t )960,      (uint32_t )958, 
        (uint32_t )956,      (uint32_t )954,      (uint32_t )953,      (uint32_t )951, 
        (uint32_t )949,      (uint32_t )948,      (uint32_t )946,      (uint32_t )944, 
        (uint32_t )942,      (uint32_t )941,      (uint32_t )939,      (uint32_t )937, 
        (uint32_t )936,      (uint32_t )934,      (uint32_t )932,      (uint32_t )931, 
        (uint32_t )929,      (uint32_t )927,      (uint32_t )926,      (uint32_t )924, 
        (uint32_t )923,      (uint32_t )921,      (uint32_t )919,      (uint32_t )918, 
        (uint32_t )916,      (uint32_t )914,      (uint32_t )913,      (uint32_t )911, 
        (uint32_t )910,      (uint32_t )908,      (uint32_t )907,      (uint32_t )905, 
        (uint32_t )903,      (uint32_t )902,      (uint32_t )900,      (uint32_t )899, 
        (uint32_t )897,      (uint32_t )896,      (uint32_t )894,      (uint32_t )893, 
        (uint32_t )891,      (uint32_t )890,      (uint32_t )888,      (uint32_t )887, 
        (uint32_t )885,      (uint32_t )884,      (uint32_t )882,      (uint32_t )881, 
        (uint32_t )879,      (uint32_t )878,      (uint32_t )876,      (uint32_t )875, 
        (uint32_t )873,      (uint32_t )872,      (uint32_t )870,      (uint32_t )869, 
        (uint32_t )868,      (uint32_t )866,      (uint32_t )865,      (uint32_t )863, 
        (uint32_t )862,      (uint32_t )860,      (uint32_t )859,      (uint32_t )858, 
        (uint32_t )856,      (uint32_t )855,      (uint32_t )853,      (uint32_t )852, 
        (uint32_t )851,      (uint32_t )849,      (uint32_t )848,      (uint32_t )846, 
        (uint32_t )845,      (uint32_t )844,      (uint32_t )842,      (uint32_t )841, 
        (uint32_t )840,      (uint32_t )838,      (uint32_t )837,      (uint32_t )836, 
        (uint32_t )834,      (uint32_t )833,      (uint32_t )832,      (uint32_t )830, 
        (uint32_t )829,      (uint32_t )828,      (uint32_t )826,      (uint32_t )825, 
        (uint32_t )824,      (uint32_t )823,      (uint32_t )821,      (uint32_t )820, 
        (uint32_t )819,      (uint32_t )817,      (uint32_t )816,      (uint32_t )815, 
        (uint32_t )814,      (uint32_t )812,      (uint32_t )811,      (uint32_t )810, 
        (uint32_t )809,      (uint32_t )807,      (uint32_t )806,      (uint32_t )805, 
        (uint32_t )804,      (uint32_t )802,      (uint32_t )801,      (uint32_t )800, 
        (uint32_t )799,      (uint32_t )798,      (uint32_t )796,      (uint32_t )795, 
        (uint32_t )794,      (uint32_t )793,      (uint32_t )791,      (uint32_t )790, 
        (uint32_t )789,      (uint32_t )788,      (uint32_t )787,      (uint32_t )786, 
        (uint32_t )784,      (uint32_t )783,      (uint32_t )782,      (uint32_t )781, 
        (uint32_t )780,      (uint32_t )779,      (uint32_t )777,      (uint32_t )776, 
        (uint32_t )775,      (uint32_t )774,      (uint32_t )773,      (uint32_t )772, 
        (uint32_t )771,      (uint32_t )769,      (uint32_t )768,      (uint32_t )767, 
        (uint32_t )766,      (uint32_t )765,      (uint32_t )764,      (uint32_t )763, 
        (uint32_t )762,      (uint32_t )760,      (uint32_t )759,      (uint32_t )758, 
        (uint32_t )757,      (uint32_t )756,      (uint32_t )755,      (uint32_t )754, 
        (uint32_t )753,      (uint32_t )752,      (uint32_t )751,      (uint32_t )750, 
        (uint32_t )748,      (uint32_t )747,      (uint32_t )746,      (uint32_t )745, 
        (uint32_t )744,      (uint32_t )743,      (uint32_t )742,      (uint32_t )741, 
        (uint32_t )740,      (uint32_t )739,      (uint32_t )738,      (uint32_t )737, 
        (uint32_t )736,      (uint32_t )735,      (uint32_t )734,      (uint32_t )733, 
        (uint32_t )732,      (uint32_t )731,      (uint32_t )730,      (uint32_t )729, 
        (uint32_t )728,      (uint32_t )727,      (uint32_t )726,      (uint32_t )725, 
        (uint32_t )724,      (uint32_t )723,      (uint32_t )722,      (uint32_t )721, 
        (uint32_t )720,      (uint32_t )719,      (uint32_t )718,      (uint32_t )717, 
        (uint32_t )716,      (uint32_t )715,      (uint32_t )714,      (uint32_t )713, 
        (uint32_t )712,      (uint32_t )711,      (uint32_t )710,      (uint32_t )709, 
        (uint32_t )708,      (uint32_t )707,      (uint32_t )706,      (uint32_t )705, 
        (uint32_t )704,      (uint32_t )703,      (uint32_t )702,      (uint32_t )701, 
        (uint32_t )700,      (uint32_t )699,      (uint32_t )699,      (uint32_t )698, 
        (uint32_t )697,      (uint32_t )696,      (uint32_t )695,      (uint32_t )694, 
        (uint32_t )693,      (uint32_t )692,      (uint32_t )691,      (uint32_t )690, 
        (uint32_t )689,      (uint32_t )688,      (uint32_t )688,      (uint32_t )687, 
        (uint32_t )686,      (uint32_t )685,      (uint32_t )684,      (uint32_t )683, 
        (uint32_t )682,      (uint32_t )681,      (uint32_t )680,      (uint32_t )680, 
        (uint32_t )679,      (uint32_t )678,      (uint32_t )677,      (uint32_t )676, 
        (uint32_t )675,      (uint32_t )674,      (uint32_t )673,      (uint32_t )673, 
        (uint32_t )672,      (uint32_t )671,      (uint32_t )670,      (uint32_t )669, 
        (uint32_t )668,      (uint32_t )667,      (uint32_t )667,      (uint32_t )666, 
        (uint32_t )665,      (uint32_t )664,      (uint32_t )663,      (uint32_t )662, 
        (uint32_t )661,      (uint32_t )661,      (uint32_t )660,      (uint32_t )659, 
        (uint32_t )658,      (uint32_t )657,      (uint32_t )657,      (uint32_t )656, 
        (uint32_t )655,      (uint32_t )654,      (uint32_t )653,      (uint32_t )652, 
        (uint32_t )652,      (uint32_t )651,      (uint32_t )650,      (uint32_t )649, 
        (uint32_t )648,      (uint32_t )648,      (uint32_t )647,      (uint32_t )646, 
        (uint32_t )645,      (uint32_t )644,      (uint32_t )644,      (uint32_t )643, 
        (uint32_t )642,      (uint32_t )641,      (uint32_t )640,      (uint32_t )640, 
        (uint32_t )639,      (uint32_t )638,      (uint32_t )637,      (uint32_t )637, 
        (uint32_t )636,      (uint32_t )635,      (uint32_t )634,      (uint32_t )633, 
        (uint32_t )633,      (uint32_t )632,      (uint32_t )631,      (uint32_t )630, 
        (uint32_t )630,      (uint32_t )629,      (uint32_t )628,      (uint32_t )627, 
        (uint32_t )627,      (uint32_t )626,      (uint32_t )625,      (uint32_t )624, 
        (uint32_t )624,      (uint32_t )623,      (uint32_t )622,      (uint32_t )621, 
        (uint32_t )621,      (uint32_t )620,      (uint32_t )619,      (uint32_t )618, 
        (uint32_t )618,      (uint32_t )617,      (uint32_t )616,      (uint32_t )616, 
        (uint32_t )615,      (uint32_t )614,      (uint32_t )613,      (uint32_t )613, 
        (uint32_t )612,      (uint32_t )611,      (uint32_t )611,      (uint32_t )610, 
        (uint32_t )609,      (uint32_t )608,      (uint32_t )608,      (uint32_t )607, 
        (uint32_t )606,      (uint32_t )606,      (uint32_t )605,      (uint32_t )604, 
        (uint32_t )604,      (uint32_t )603,      (uint32_t )602,      (uint32_t )601, 
        (uint32_t )601,      (uint32_t )600,      (uint32_t )599,      (uint32_t )599, 
        (uint32_t )598,      (uint32_t )597,      (uint32_t )597,      (uint32_t )596, 
        (uint32_t )595,      (uint32_t )595,      (uint32_t )594,      (uint32_t )593, 
        (uint32_t )593,      (uint32_t )592,      (uint32_t )591,      (uint32_t )591, 
        (uint32_t )590,      (uint32_t )589,      (uint32_t )589,      (uint32_t )588, 
        (uint32_t )587,      (uint32_t )587,      (uint32_t )586,      (uint32_t )585, 
        (uint32_t )585,      (uint32_t )584,      (uint32_t )583,      (uint32_t )583, 
        (uint32_t )582,      (uint32_t )581,      (uint32_t )581,      (uint32_t )580, 
        (uint32_t )579,      (uint32_t )579,      (uint32_t )578,      (uint32_t )578, 
        (uint32_t )577,      (uint32_t )576,      (uint32_t )576,      (uint32_t )575, 
        (uint32_t )574,      (uint32_t )574,      (uint32_t )573,      (uint32_t )572, 
        (uint32_t )572,      (uint32_t )571,      (uint32_t )571,      (uint32_t )570, 
        (uint32_t )569,      (uint32_t )569,      (uint32_t )568,      (uint32_t )568, 
        (uint32_t )567,      (uint32_t )566,      (uint32_t )566,      (uint32_t )565, 
        (uint32_t )564,      (uint32_t )564,      (uint32_t )563,      (uint32_t )563, 
        (uint32_t )562,      (uint32_t )561,      (uint32_t )561,      (uint32_t )560, 
        (uint32_t )560,      (uint32_t )559,      (uint32_t )558,      (uint32_t )558, 
        (uint32_t )557,      (uint32_t )557,      (uint32_t )556,      (uint32_t )555, 
        (uint32_t )555,      (uint32_t )554,      (uint32_t )554,      (uint32_t )553, 
        (uint32_t )553,      (uint32_t )552,      (uint32_t )551,      (uint32_t )551, 
        (uint32_t )550,      (uint32_t )550,      (uint32_t )549,      (uint32_t )548, 
        (uint32_t )548,      (uint32_t )547,      (uint32_t )547,      (uint32_t )546, 
        (uint32_t )546,      (uint32_t )545,      (uint32_t )544,      (uint32_t )544, 
        (uint32_t )543,      (uint32_t )543,      (uint32_t )542,      (uint32_t )542, 
        (uint32_t )541,      (uint32_t )541,      (uint32_t )540,      (uint32_t )539, 
        (uint32_t )539,      (uint32_t )538,      (uint32_t )538,      (uint32_t )537, 
        (uint32_t )537,      (uint32_t )536,      (uint32_t )536,      (uint32_t )535, 
        (uint32_t )534,      (uint32_t )534,      (uint32_t )533,      (uint32_t )533, 
        (uint32_t )532,      (uint32_t )532,      (uint32_t )531,      (uint32_t )531, 
        (uint32_t )530,      (uint32_t )530,      (uint32_t )529,      (uint32_t )529, 
        (uint32_t )528,      (uint32_t )527,      (uint32_t )527,      (uint32_t )526, 
        (uint32_t )526,      (uint32_t )525,      (uint32_t )525,      (uint32_t )524, 
        (uint32_t )524,      (uint32_t )523,      (uint32_t )523,      (uint32_t )522, 
        (uint32_t )522,      (uint32_t )521,      (uint32_t )521,      (uint32_t )520, 
        (uint32_t )520,      (uint32_t )519,      (uint32_t )519,      (uint32_t )518, 
        (uint32_t )518,      (uint32_t )517,      (uint32_t )517,      (uint32_t )516, 
        (uint32_t )516,      (uint32_t )515,      (uint32_t )515,      (uint32_t )514, 
        (uint32_t )514};
#line 738 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static int LinearToGammaWeighted(uint8_t *src , uint8_t *a_ptr , uint32_t total_a ,
                                          int step , int rgb_stride ) 
{ 
  uint32_t sum ;
  uint32_t __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 742
  __cil_tmp10 = GammaToLinear(*(src + (rgb_stride + step)));
#line 742
  __cil_tmp9 = GammaToLinear(*(src + rgb_stride));
#line 742
  __cil_tmp8 = GammaToLinear(*(src + step));
#line 742
  __cil_tmp7 = GammaToLinear(*(src + 0));
#line 742
  sum = (((unsigned int )*(a_ptr + 0) * __cil_tmp7 + (unsigned int )*(a_ptr + step) * __cil_tmp8) + (unsigned int )*(a_ptr + rgb_stride) * __cil_tmp9) + (unsigned int )*(a_ptr + (rgb_stride + step)) * __cil_tmp10;
#line 751
  __cil_tmp11 = LinearToGamma(sum * kInvAlpha[total_a] >> (kAlphaFix - 2), 0);
  }
#line 751
  return (__cil_tmp11);
}
}
#line 754 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static void ConvertRowToY(uint8_t *r_ptr , uint8_t *g_ptr , uint8_t *b_ptr ,
                                   int step , uint8_t *dst_y , int width , VP8Random *rg ) 
{ 
  int i ;
  int j ;
  int __cil_tmp10 ;

  {
#line 762
  j = 0;
#line 762
  i = 0;
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;

#line 762
    if (! (i < width)) {
#line 762
      goto while_break;
    }
    {
#line 763
    __cil_tmp10 = RGBToY((int )*(r_ptr + j), (int )*(g_ptr + j), (int )*(b_ptr + j),
                         rg);
#line 763
    *(dst_y + i) = (uint8_t )__cil_tmp10;
#line 762
    j += step;
#line 762
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 766
  return;
}
}
#line 767 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static void AccumulateRGBA(uint8_t *r_ptr , uint8_t *g_ptr , uint8_t *b_ptr ,
                                    uint8_t *a_ptr , int rgb_stride , uint16_t *dst ,
                                    int width ) 
{ 
  int i ;
  int j ;
  uint32_t a ;
  int r ;
  int g ;
  int b ;
  uint32_t __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  int __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  int __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  uint32_t __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  int __cil_tmp28 ;
  uint32_t a___0 ;
  int r___0 ;
  int g___0 ;
  int b___0 ;
  uint32_t __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  int __cil_tmp38 ;
  uint32_t __cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  int __cil_tmp41 ;
  uint32_t __cil_tmp42 ;
  uint32_t __cil_tmp43 ;
  int __cil_tmp44 ;

  {
#line 775
  j = 0;
#line 775
  i = 0;
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;

#line 775
    if (! (i < width >> 1)) {
#line 775
      goto while_break;
    }
#line 776
    a = (uint32_t )(((int )*((a_ptr + j) + 0) + (int )*((a_ptr + j) + rgb_stride)) + ((int )*(((a_ptr + j) + 4) + 0) + (int )*(((a_ptr + j) + 4) + rgb_stride)));
#line 778
    if (a == 1020U) {
      _L: 
      {
#line 779
      __cil_tmp17 = GammaToLinear(*((r_ptr + j) + (rgb_stride + 4)));
#line 779
      __cil_tmp16 = GammaToLinear(*((r_ptr + j) + rgb_stride));
#line 779
      __cil_tmp15 = GammaToLinear(*((r_ptr + j) + 4));
#line 779
      __cil_tmp14 = GammaToLinear(*((r_ptr + j) + 0));
#line 779
      __cil_tmp18 = LinearToGamma(((__cil_tmp14 + __cil_tmp15) + __cil_tmp16) + __cil_tmp17,
                                  0);
#line 779
      r = __cil_tmp18;
#line 780
      __cil_tmp22 = GammaToLinear(*((g_ptr + j) + (rgb_stride + 4)));
#line 780
      __cil_tmp21 = GammaToLinear(*((g_ptr + j) + rgb_stride));
#line 780
      __cil_tmp20 = GammaToLinear(*((g_ptr + j) + 4));
#line 780
      __cil_tmp19 = GammaToLinear(*((g_ptr + j) + 0));
#line 780
      __cil_tmp23 = LinearToGamma(((__cil_tmp19 + __cil_tmp20) + __cil_tmp21) + __cil_tmp22,
                                  0);
#line 780
      g = __cil_tmp23;
#line 781
      __cil_tmp27 = GammaToLinear(*((b_ptr + j) + (rgb_stride + 4)));
#line 781
      __cil_tmp26 = GammaToLinear(*((b_ptr + j) + rgb_stride));
#line 781
      __cil_tmp25 = GammaToLinear(*((b_ptr + j) + 4));
#line 781
      __cil_tmp24 = GammaToLinear(*((b_ptr + j) + 0));
#line 781
      __cil_tmp28 = LinearToGamma(((__cil_tmp24 + __cil_tmp25) + __cil_tmp26) + __cil_tmp27,
                                  0);
#line 781
      b = __cil_tmp28;
      }
    } else
#line 778
    if (a == 0U) {
#line 778
      goto _L;
    } else {
      {
#line 783
      r = LinearToGammaWeighted(r_ptr + j, a_ptr + j, a, 4, rgb_stride);
#line 784
      g = LinearToGammaWeighted(g_ptr + j, a_ptr + j, a, 4, rgb_stride);
#line 785
      b = LinearToGammaWeighted(b_ptr + j, a_ptr + j, a, 4, rgb_stride);
      }
    }
#line 787
    *(dst + 0) = (uint16_t )r;
#line 788
    *(dst + 1) = (uint16_t )g;
#line 789
    *(dst + 2) = (uint16_t )b;
#line 790
    *(dst + 3) = (uint16_t )a;
#line 775
    dst += 4;
#line 775
    j += 8;
#line 775
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 792
  if (width & 1) {
#line 793
    a___0 = 2U * (unsigned int )((int )*((a_ptr + j) + 0) + (int )*((a_ptr + j) + rgb_stride));
#line 795
    if (a___0 == 1020U) {
      _L___14: 
      {
#line 796
      __cil_tmp37 = GammaToLinear(*((r_ptr + j) + rgb_stride));
#line 796
      __cil_tmp36 = GammaToLinear(*((r_ptr + j) + 0));
#line 796
      __cil_tmp38 = LinearToGamma(__cil_tmp36 + __cil_tmp37, 1);
#line 796
      r___0 = __cil_tmp38;
#line 797
      __cil_tmp40 = GammaToLinear(*((g_ptr + j) + rgb_stride));
#line 797
      __cil_tmp39 = GammaToLinear(*((g_ptr + j) + 0));
#line 797
      __cil_tmp41 = LinearToGamma(__cil_tmp39 + __cil_tmp40, 1);
#line 797
      g___0 = __cil_tmp41;
#line 798
      __cil_tmp43 = GammaToLinear(*((b_ptr + j) + rgb_stride));
#line 798
      __cil_tmp42 = GammaToLinear(*((b_ptr + j) + 0));
#line 798
      __cil_tmp44 = LinearToGamma(__cil_tmp42 + __cil_tmp43, 1);
#line 798
      b___0 = __cil_tmp44;
      }
    } else
#line 795
    if (a___0 == 0U) {
#line 795
      goto _L___14;
    } else {
      {
#line 800
      r___0 = LinearToGammaWeighted(r_ptr + j, a_ptr + j, a___0, 0, rgb_stride);
#line 801
      g___0 = LinearToGammaWeighted(g_ptr + j, a_ptr + j, a___0, 0, rgb_stride);
#line 802
      b___0 = LinearToGammaWeighted(b_ptr + j, a_ptr + j, a___0, 0, rgb_stride);
      }
    }
#line 804
    *(dst + 0) = (uint16_t )r___0;
#line 805
    *(dst + 1) = (uint16_t )g___0;
#line 806
    *(dst + 2) = (uint16_t )b___0;
#line 807
    *(dst + 3) = (uint16_t )a___0;
  }
#line 809
  return;
}
}
#line 811 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static void AccumulateRGB(uint8_t *r_ptr , uint8_t *g_ptr , uint8_t *b_ptr ,
                                   int step , int rgb_stride , uint16_t *dst , int width ) 
{ 
  int i ;
  int j ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  int __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  int __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  int __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  uint32_t __cil_tmp26 ;
  int __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  int __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  int __cil_tmp33 ;

  {
#line 817
  j = 0;
#line 817
  i = 0;
  {
#line 817
  while (1) {
    while_continue: /* CIL Label */ ;

#line 817
    if (! (i < width >> 1)) {
#line 817
      goto while_break;
    }
    {
#line 818
    __cil_tmp13 = GammaToLinear(*((r_ptr + j) + (rgb_stride + step)));
#line 818
    __cil_tmp12 = GammaToLinear(*((r_ptr + j) + rgb_stride));
#line 818
    __cil_tmp11 = GammaToLinear(*((r_ptr + j) + step));
#line 818
    __cil_tmp10 = GammaToLinear(*((r_ptr + j) + 0));
#line 818
    __cil_tmp14 = LinearToGamma(((__cil_tmp10 + __cil_tmp11) + __cil_tmp12) + __cil_tmp13,
                                0);
#line 818
    *(dst + 0) = (uint16_t )__cil_tmp14;
#line 819
    __cil_tmp18 = GammaToLinear(*((g_ptr + j) + (rgb_stride + step)));
#line 819
    __cil_tmp17 = GammaToLinear(*((g_ptr + j) + rgb_stride));
#line 819
    __cil_tmp16 = GammaToLinear(*((g_ptr + j) + step));
#line 819
    __cil_tmp15 = GammaToLinear(*((g_ptr + j) + 0));
#line 819
    __cil_tmp19 = LinearToGamma(((__cil_tmp15 + __cil_tmp16) + __cil_tmp17) + __cil_tmp18,
                                0);
#line 819
    *(dst + 1) = (uint16_t )__cil_tmp19;
#line 820
    __cil_tmp23 = GammaToLinear(*((b_ptr + j) + (rgb_stride + step)));
#line 820
    __cil_tmp22 = GammaToLinear(*((b_ptr + j) + rgb_stride));
#line 820
    __cil_tmp21 = GammaToLinear(*((b_ptr + j) + step));
#line 820
    __cil_tmp20 = GammaToLinear(*((b_ptr + j) + 0));
#line 820
    __cil_tmp24 = LinearToGamma(((__cil_tmp20 + __cil_tmp21) + __cil_tmp22) + __cil_tmp23,
                                0);
#line 820
    *(dst + 2) = (uint16_t )__cil_tmp24;
#line 817
    dst += 4;
#line 817
    j += 2 * step;
#line 817
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 822
  if (width & 1) {
    {
#line 823
    __cil_tmp26 = GammaToLinear(*((r_ptr + j) + rgb_stride));
#line 823
    __cil_tmp25 = GammaToLinear(*((r_ptr + j) + 0));
#line 823
    __cil_tmp27 = LinearToGamma(__cil_tmp25 + __cil_tmp26, 1);
#line 823
    *(dst + 0) = (uint16_t )__cil_tmp27;
#line 824
    __cil_tmp29 = GammaToLinear(*((g_ptr + j) + rgb_stride));
#line 824
    __cil_tmp28 = GammaToLinear(*((g_ptr + j) + 0));
#line 824
    __cil_tmp30 = LinearToGamma(__cil_tmp28 + __cil_tmp29, 1);
#line 824
    *(dst + 1) = (uint16_t )__cil_tmp30;
#line 825
    __cil_tmp32 = GammaToLinear(*((b_ptr + j) + rgb_stride));
#line 825
    __cil_tmp31 = GammaToLinear(*((b_ptr + j) + 0));
#line 825
    __cil_tmp33 = LinearToGamma(__cil_tmp31 + __cil_tmp32, 1);
#line 825
    *(dst + 2) = (uint16_t )__cil_tmp33;
    }
  }
#line 828
  return;
}
}
#line 829 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
__inline static void ConvertRowsToUV(uint16_t *rgb , uint8_t *dst_u , uint8_t *dst_v ,
                                     int width , VP8Random *rg ) 
{ 
  int i ;
  int r ;
  int g ;
  int b ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 835
  i = 0;
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;

#line 835
    if (! (i < width)) {
#line 835
      goto while_break;
    }
    {
#line 836
    r = (int )*(rgb + 0);
#line 836
    g = (int )*(rgb + 1);
#line 836
    b = (int )*(rgb + 2);
#line 837
    __cil_tmp10 = RGBToU(r, g, b, rg);
#line 837
    *(dst_u + i) = (uint8_t )__cil_tmp10;
#line 838
    __cil_tmp11 = RGBToV(r, g, b, rg);
#line 838
    *(dst_v + i) = (uint8_t )__cil_tmp11;
#line 835
    rgb += 4;
#line 835
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 839
  return;
}
}
#line 842 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int ImportYUVAFromRGBA(uint8_t *r_ptr , uint8_t *g_ptr , uint8_t *b_ptr , uint8_t *a_ptr ,
                              int step , int rgb_stride , float dithering , int use_iterative_conversion ,
                              WebPPicture *picture ) 
{ 
  int y ;
  int width ;
  int height ;
  int has_alpha ;
  int __cil_tmp14 ;
  int is_rgb ;
  int tmp ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int uv_width ;
  int use_dsp ;
  uint16_t *tmp_rgb ;
  void *__cil_tmp22 ;
  uint8_t *dst_y ;
  uint8_t *dst_u ;
  uint8_t *dst_v ;
  uint8_t *dst_a ;
  VP8Random base_rg ;
  VP8Random *rg ;
  int rows_have_alpha ;
  int __cil_tmp30 ;
  int row_has_alpha ;
  int __cil_tmp32 ;

  {
  {
#line 852
  width = picture->width;
#line 853
  height = picture->height;
#line 854
  __cil_tmp14 = CheckNonOpaque(a_ptr, width, height, step, rgb_stride);
#line 854
  has_alpha = __cil_tmp14;
#line 855
  is_rgb = (unsigned long )r_ptr < (unsigned long )b_ptr;
  }
#line 857
  if (has_alpha) {
#line 857
    tmp = 4;
  } else {
#line 857
    tmp = 0;
  }
#line 857
  picture->colorspace = (WebPEncCSP )tmp;
#line 858
  picture->use_argb = 0;
#line 861
  if (width < (int )kMinDimensionIterativeConversion) {
#line 863
    use_iterative_conversion = 0;
  } else
#line 861
  if (height < (int )kMinDimensionIterativeConversion) {
#line 863
    use_iterative_conversion = 0;
  }
  {
#line 866
  __cil_tmp17 = WebPPictureAllocYUVA(picture, width, height);
  }
#line 866
  if (! __cil_tmp17) {
#line 867
    return (0);
  }
#line 876
  if (use_iterative_conversion) {
    {
#line 877
    InitGammaTablesS();
#line 878
    __cil_tmp18 = PreprocessARGB(r_ptr, g_ptr, b_ptr, step, rgb_stride, picture);
    }
#line 878
    if (! __cil_tmp18) {
#line 879
      return (0);
    }
#line 881
    if (has_alpha) {
      {
#line 882
      (*WebPExtractAlpha)(a_ptr, rgb_stride, width, height, picture->a, picture->a_stride);
      }
    }
  } else {
    {
#line 886
    uv_width = (width + 1) >> 1;
#line 887
    use_dsp = step == 3;
#line 889
    __cil_tmp22 = WebPSafeMalloc((uint64_t )(4 * uv_width), sizeof(*tmp_rgb));
#line 889
    tmp_rgb = (uint16_t *)__cil_tmp22;
#line 891
    dst_y = picture->y;
#line 892
    dst_u = picture->u;
#line 893
    dst_v = picture->v;
#line 894
    dst_a = picture->a;
#line 897
    rg = (VP8Random *)((void *)0);
    }
#line 898
    if ((double )dithering > 0.) {
      {
#line 899
      VP8InitRandom(& base_rg, dithering);
#line 900
      rg = & base_rg;
#line 901
      use_dsp = 0;
      }
    }
    {
#line 903
    WebPInitConvertARGBToYUV();
#line 904
    InitGammaTables();
    }
#line 906
    if ((unsigned long )tmp_rgb == (unsigned long )((void *)0)) {
#line 906
      return (0);
    }
#line 909
    y = 0;
    {
#line 909
    while (1) {
      while_continue: /* CIL Label */ ;

#line 909
      if (! (y < height >> 1)) {
#line 909
        goto while_break;
      }
#line 910
      rows_have_alpha = has_alpha;
#line 911
      if (use_dsp) {
#line 912
        if (is_rgb) {
          {
#line 913
          (*WebPConvertRGB24ToY)(r_ptr, dst_y, width);
#line 914
          (*WebPConvertRGB24ToY)(r_ptr + rgb_stride, dst_y + picture->y_stride, width);
          }
        } else {
          {
#line 917
          (*WebPConvertBGR24ToY)(b_ptr, dst_y, width);
#line 918
          (*WebPConvertBGR24ToY)(b_ptr + rgb_stride, dst_y + picture->y_stride, width);
          }
        }
      } else {
        {
#line 922
        ConvertRowToY(r_ptr, g_ptr, b_ptr, step, dst_y, width, rg);
#line 923
        ConvertRowToY(r_ptr + rgb_stride, g_ptr + rgb_stride, b_ptr + rgb_stride,
                      step, dst_y + picture->y_stride, width, rg);
        }
      }
#line 928
      dst_y += 2 * picture->y_stride;
#line 929
      if (has_alpha) {
        {
#line 930
        __cil_tmp30 = (*WebPExtractAlpha)(a_ptr, rgb_stride, width, 2, dst_a, picture->a_stride);
#line 930
        rows_have_alpha &= ! __cil_tmp30;
#line 932
        dst_a += 2 * picture->a_stride;
        }
      }
#line 935
      if (! rows_have_alpha) {
        {
#line 936
        AccumulateRGB(r_ptr, g_ptr, b_ptr, step, rgb_stride, tmp_rgb, width);
        }
      } else {
        {
#line 938
        AccumulateRGBA(r_ptr, g_ptr, b_ptr, a_ptr, rgb_stride, tmp_rgb, width);
        }
      }
#line 941
      if ((unsigned long )rg == (unsigned long )((void *)0)) {
        {
#line 942
        (*WebPConvertRGBA32ToUV)(tmp_rgb, dst_u, dst_v, uv_width);
        }
      } else {
        {
#line 944
        ConvertRowsToUV(tmp_rgb, dst_u, dst_v, uv_width, rg);
        }
      }
#line 946
      dst_u += picture->uv_stride;
#line 947
      dst_v += picture->uv_stride;
#line 948
      r_ptr += 2 * rgb_stride;
#line 949
      b_ptr += 2 * rgb_stride;
#line 950
      g_ptr += 2 * rgb_stride;
#line 951
      if (has_alpha) {
#line 951
        a_ptr += 2 * rgb_stride;
      }
#line 909
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
#line 953
    if (height & 1) {
#line 954
      row_has_alpha = has_alpha;
#line 955
      if (use_dsp) {
#line 956
        if ((unsigned long )r_ptr < (unsigned long )b_ptr) {
          {
#line 957
          (*WebPConvertRGB24ToY)(r_ptr, dst_y, width);
          }
        } else {
          {
#line 959
          (*WebPConvertBGR24ToY)(b_ptr, dst_y, width);
          }
        }
      } else {
        {
#line 962
        ConvertRowToY(r_ptr, g_ptr, b_ptr, step, dst_y, width, rg);
        }
      }
#line 964
      if (row_has_alpha) {
        {
#line 965
        __cil_tmp32 = (*WebPExtractAlpha)(a_ptr, 0, width, 1, dst_a, 0);
#line 965
        row_has_alpha &= ! __cil_tmp32;
        }
      }
#line 968
      if (! row_has_alpha) {
        {
#line 970
        AccumulateRGB(r_ptr, g_ptr, b_ptr, step, 0, tmp_rgb, width);
        }
      } else {
        {
#line 973
        AccumulateRGBA(r_ptr, g_ptr, b_ptr, a_ptr, 0, tmp_rgb, width);
        }
      }
#line 976
      if ((unsigned long )rg == (unsigned long )((void *)0)) {
        {
#line 977
        (*WebPConvertRGBA32ToUV)(tmp_rgb, dst_u, dst_v, uv_width);
        }
      } else {
        {
#line 979
        ConvertRowsToUV(tmp_rgb, dst_u, dst_v, uv_width, rg);
        }
      }
    }
    {
#line 982
    WebPSafeFree((void *)tmp_rgb);
    }
  }
#line 984
  return (1);
}
}
#line 995 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int PictureARGBToYUVA(WebPPicture *picture , WebPEncCSP colorspace , float dithering ,
                             int use_iterative_conversion ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  uint8_t *argb ;
  uint8_t *a ;
  uint8_t *r ;
  uint8_t *g ;
  uint8_t *b ;
  int __cil_tmp12 ;

  {
#line 997
  if ((unsigned long )picture == (unsigned long )((void *)0)) {
#line 997
    return (0);
  }
#line 998
  if ((unsigned long )picture->argb == (unsigned long )((void *)0)) {
    {
#line 999
    __cil_tmp5 = WebPEncodingSetError(picture, (WebPEncodingError )3);
    }
#line 999
    return (__cil_tmp5);
  } else
#line 1000
  if (((unsigned int )colorspace & 3U) != 0U) {
    {
#line 1001
    __cil_tmp6 = WebPEncodingSetError(picture, (WebPEncodingError )4);
    }
#line 1001
    return (__cil_tmp6);
  } else {
    {
#line 1003
    argb = (uint8_t *)picture->argb;
#line 1004
    a = argb + 3;
#line 1005
    r = argb + 2;
#line 1006
    g = argb + 1;
#line 1007
    b = argb + 0;
#line 1009
    picture->colorspace = (WebPEncCSP )0;
#line 1010
    __cil_tmp12 = ImportYUVAFromRGBA(r, g, b, a, 4, 4 * picture->argb_stride, dithering,
                                     use_iterative_conversion, picture);
    }
#line 1010
    return (__cil_tmp12);
  }
}
}
#line 1015 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
int WebPPictureARGBToYUVADithered(WebPPicture *picture , WebPEncCSP colorspace , float dithering ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 1017
  __cil_tmp4 = PictureARGBToYUVA(picture, colorspace, dithering, 0);
  }
#line 1017
  return (__cil_tmp4);
}
}
#line 1020 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
int WebPPictureARGBToYUVA(WebPPicture *picture , WebPEncCSP colorspace ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1021
  __cil_tmp3 = PictureARGBToYUVA(picture, colorspace, 0.f, 0);
  }
#line 1021
  return (__cil_tmp3);
}
}
#line 1024 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
int WebPPictureSharpARGBToYUVA(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1025
  __cil_tmp2 = PictureARGBToYUVA(picture, (WebPEncCSP )0, 0.f, 1);
  }
#line 1025
  return (__cil_tmp2);
}
}
#line 1028 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
int WebPPictureSmartARGBToYUVA(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1029
  __cil_tmp2 = WebPPictureSharpARGBToYUVA(picture);
  }
#line 1029
  return (__cil_tmp2);
}
}
#line 1035 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
int WebPPictureYUVAToARGB(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int y ;
  int width ;
  int height ;
  int argb_stride ;
  uint8_t *dst ;
  uint8_t *cur_u ;
  uint8_t *cur_v ;
  uint8_t *cur_y ;
  void (*upsample)(uint8_t * , uint8_t * , uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                   uint8_t * , uint8_t * , int  ) ;
  void (*__cil_tmp15)(uint8_t * , uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                      uint8_t * , uint8_t * , uint8_t * , int  ) ;
  uint8_t *top_u ;
  uint8_t *top_v ;
  uint32_t *argb_dst ;
  uint8_t *src ;
  int x ;

  {
#line 1036
  if ((unsigned long )picture == (unsigned long )((void *)0)) {
#line 1036
    return (0);
  }
#line 1037
  if ((unsigned long )picture->y == (unsigned long )((void *)0)) {
    {
#line 1038
    __cil_tmp2 = WebPEncodingSetError(picture, (WebPEncodingError )3);
    }
#line 1038
    return (__cil_tmp2);
  } else
#line 1037
  if ((unsigned long )picture->u == (unsigned long )((void *)0)) {
    {
#line 1038
    __cil_tmp2 = WebPEncodingSetError(picture, (WebPEncodingError )3);
    }
#line 1038
    return (__cil_tmp2);
  } else
#line 1037
  if ((unsigned long )picture->v == (unsigned long )((void *)0)) {
    {
#line 1038
    __cil_tmp2 = WebPEncodingSetError(picture, (WebPEncodingError )3);
    }
#line 1038
    return (__cil_tmp2);
  }
#line 1040
  if ((unsigned long )picture->a == (unsigned long )((void *)0)) {
#line 1040
    if ((unsigned int )picture->colorspace & 4U) {
      {
#line 1041
      __cil_tmp3 = WebPEncodingSetError(picture, (WebPEncodingError )3);
      }
#line 1041
      return (__cil_tmp3);
    }
  }
#line 1043
  if (((unsigned int )picture->colorspace & 3U) != 0U) {
    {
#line 1044
    __cil_tmp4 = WebPEncodingSetError(picture, (WebPEncodingError )4);
    }
#line 1044
    return (__cil_tmp4);
  }
  {
#line 1047
  __cil_tmp5 = WebPPictureAllocARGB(picture, picture->width, picture->height);
  }
#line 1047
  if (! __cil_tmp5) {
#line 1047
    return (0);
  }
  {
#line 1048
  picture->use_argb = 1;
#line 1053
  width = picture->width;
#line 1054
  height = picture->height;
#line 1055
  argb_stride = 4 * picture->argb_stride;
#line 1056
  dst = (uint8_t *)picture->argb;
#line 1057
  cur_u = picture->u;
#line 1057
  cur_v = picture->v;
#line 1057
  cur_y = picture->y;
#line 1058
  __cil_tmp15 = WebPGetLinePairConverter(1);
#line 1058
  upsample = __cil_tmp15;
#line 1062
  (*upsample)(cur_y, (uint8_t *)((void *)0), cur_u, cur_v, cur_u, cur_v, dst, (uint8_t *)((void *)0),
              width);
#line 1063
  cur_y += picture->y_stride;
#line 1064
  dst += argb_stride;
#line 1066
  y = 1;
  }
  {
#line 1066
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1066
    if (! (y + 1 < height)) {
#line 1066
      goto while_break;
    }
    {
#line 1067
    top_u = cur_u;
#line 1068
    top_v = cur_v;
#line 1069
    cur_u += picture->uv_stride;
#line 1070
    cur_v += picture->uv_stride;
#line 1071
    (*upsample)(cur_y, cur_y + picture->y_stride, top_u, top_v, cur_u, cur_v, dst,
                dst + argb_stride, width);
#line 1073
    cur_y += 2 * picture->y_stride;
#line 1074
    dst += 2 * argb_stride;
#line 1066
    y += 2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 1077
  if (height > 1) {
#line 1077
    if (! (height & 1)) {
      {
#line 1078
      (*upsample)(cur_y, (uint8_t *)((void *)0), cur_u, cur_v, cur_u, cur_v, dst,
                  (uint8_t *)((void *)0), width);
      }
    }
  }
#line 1081
  if ((unsigned int )picture->colorspace & 4U) {
#line 1082
    y = 0;
    {
#line 1082
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1082
      if (! (y < height)) {
#line 1082
        goto while_break___0;
      }
#line 1083
      argb_dst = picture->argb + y * picture->argb_stride;
#line 1084
      src = picture->a + y * picture->a_stride;
#line 1086
      x = 0;
      {
#line 1086
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1086
        if (! (x < width)) {
#line 1086
          goto while_break___1;
        }
#line 1087
        *(argb_dst + x) = (*(argb_dst + x) & 16777215U) | ((uint32_t )*(src + x) << 24);
#line 1086
        x ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 1082
      y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 1092
  return (1);
}
}
#line 1098 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
static int Import(WebPPicture *picture , uint8_t *rgb , int rgb_stride , int step ,
                  int swap_rb , int import_alpha ) 
{ 
  int y ;
  uint8_t *r_ptr ;
  int tmp ;
  uint8_t *g_ptr ;
  uint8_t *b_ptr ;
  int tmp___0 ;
  int width ;
  int height ;
  uint8_t *a_ptr ;
  uint8_t *tmp___1 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  uint32_t *dst ;
  int do_copy ;
  uint32_t *dst___0 ;

  {
#line 1103
  if (swap_rb) {
#line 1103
    tmp = 2;
  } else {
#line 1103
    tmp = 0;
  }
#line 1103
  r_ptr = rgb + tmp;
#line 1104
  g_ptr = rgb + 1;
#line 1105
  if (swap_rb) {
#line 1105
    tmp___0 = 0;
  } else {
#line 1105
    tmp___0 = 2;
  }
#line 1105
  b_ptr = rgb + tmp___0;
#line 1106
  width = picture->width;
#line 1107
  height = picture->height;
#line 1109
  if (! picture->use_argb) {
#line 1110
    if (import_alpha) {
#line 1110
      tmp___1 = rgb + 3;
    } else {
#line 1110
      tmp___1 = (uint8_t *)((void *)0);
    }
    {
#line 1110
    a_ptr = tmp___1;
#line 1111
    __cil_tmp17 = ImportYUVAFromRGBA(r_ptr, g_ptr, b_ptr, a_ptr, step, rgb_stride,
                                     0.f, 0, picture);
    }
#line 1111
    return (__cil_tmp17);
  }
  {
#line 1114
  __cil_tmp18 = WebPPictureAlloc(picture);
  }
#line 1114
  if (! __cil_tmp18) {
#line 1114
    return (0);
  }
  {
#line 1116
  VP8LDspInit();
#line 1117
  WebPInitAlphaProcessing();
  }
#line 1119
  if (import_alpha) {
#line 1121
    dst = picture->argb;
#line 1122
    do_copy = swap_rb;
#line 1124
    if (do_copy) {
#line 1125
      y = 0;
      {
#line 1125
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1125
        if (! (y < height)) {
#line 1125
          goto while_break;
        }
        {
#line 1126
        memcpy((void *)dst, (void const   *)rgb, (unsigned long )(width * 4));
#line 1127
        rgb += rgb_stride;
#line 1128
        dst += picture->argb_stride;
#line 1125
        y ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: ;
    } else {
#line 1131
      y = 0;
      {
#line 1131
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1131
        if (! (y < height)) {
#line 1131
          goto while_break___0;
        }
        {
#line 1141
        (*VP8LConvertBGRAToRGBA)((uint32_t *)rgb, width, (uint8_t *)dst);
#line 1143
        rgb += rgb_stride;
#line 1144
        dst += picture->argb_stride;
#line 1131
        y ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    }
  } else {
#line 1148
    dst___0 = picture->argb;
#line 1150
    y = 0;
    {
#line 1150
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1150
      if (! (y < height)) {
#line 1150
        goto while_break___1;
      }
      {
#line 1151
      (*WebPPackRGB)(r_ptr, g_ptr, b_ptr, width, step, dst___0);
#line 1152
      r_ptr += rgb_stride;
#line 1153
      g_ptr += rgb_stride;
#line 1154
      b_ptr += rgb_stride;
#line 1155
      dst___0 += picture->argb_stride;
#line 1150
      y ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 1158
  return (1);
}
}
#line 1165 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
int WebPPictureImportBGR(WebPPicture *picture , uint8_t *rgb , int rgb_stride ) 
{ 
  int __cil_tmp4 ;
  int tmp ;

  {
#line 1167
  if ((unsigned long )picture != (unsigned long )((void *)0)) {
#line 1167
    if ((unsigned long )rgb != (unsigned long )((void *)0)) {
      {
#line 1167
      __cil_tmp4 = Import(picture, rgb, rgb_stride, 3, 1, 0);
#line 1167
      tmp = __cil_tmp4;
      }
    } else {
#line 1167
      tmp = 0;
    }
  } else {
#line 1167
    tmp = 0;
  }
#line 1167
  return (tmp);
}
}
#line 1172 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
int WebPPictureImportBGRA(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) 
{ 
  int __cil_tmp4 ;
  int tmp ;

  {
#line 1174
  if ((unsigned long )picture != (unsigned long )((void *)0)) {
#line 1174
    if ((unsigned long )rgba != (unsigned long )((void *)0)) {
      {
#line 1174
      __cil_tmp4 = Import(picture, rgba, rgba_stride, 4, 1, 1);
#line 1174
      tmp = __cil_tmp4;
      }
    } else {
#line 1174
      tmp = 0;
    }
  } else {
#line 1174
    tmp = 0;
  }
#line 1174
  return (tmp);
}
}
#line 1180 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
int WebPPictureImportBGRX(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) 
{ 
  int __cil_tmp4 ;
  int tmp ;

  {
#line 1182
  if ((unsigned long )picture != (unsigned long )((void *)0)) {
#line 1182
    if ((unsigned long )rgba != (unsigned long )((void *)0)) {
      {
#line 1182
      __cil_tmp4 = Import(picture, rgba, rgba_stride, 4, 1, 0);
#line 1182
      tmp = __cil_tmp4;
      }
    } else {
#line 1182
      tmp = 0;
    }
  } else {
#line 1182
    tmp = 0;
  }
#line 1182
  return (tmp);
}
}
#line 1189 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
int WebPPictureImportRGB(WebPPicture *picture , uint8_t *rgb , int rgb_stride ) 
{ 
  int __cil_tmp4 ;
  int tmp ;

  {
#line 1191
  if ((unsigned long )picture != (unsigned long )((void *)0)) {
#line 1191
    if ((unsigned long )rgb != (unsigned long )((void *)0)) {
      {
#line 1191
      __cil_tmp4 = Import(picture, rgb, rgb_stride, 3, 0, 0);
#line 1191
      tmp = __cil_tmp4;
      }
    } else {
#line 1191
      tmp = 0;
    }
  } else {
#line 1191
    tmp = 0;
  }
#line 1191
  return (tmp);
}
}
#line 1196 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
int WebPPictureImportRGBA(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) 
{ 
  int __cil_tmp4 ;
  int tmp ;

  {
#line 1198
  if ((unsigned long )picture != (unsigned long )((void *)0)) {
#line 1198
    if ((unsigned long )rgba != (unsigned long )((void *)0)) {
      {
#line 1198
      __cil_tmp4 = Import(picture, rgba, rgba_stride, 4, 0, 1);
#line 1198
      tmp = __cil_tmp4;
      }
    } else {
#line 1198
      tmp = 0;
    }
  } else {
#line 1198
    tmp = 0;
  }
#line 1198
  return (tmp);
}
}
#line 1203 "/root/patron-new/new_3/src/enc/picture_csp_enc.c"
int WebPPictureImportRGBX(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) 
{ 
  int __cil_tmp4 ;
  int tmp ;

  {
#line 1205
  if ((unsigned long )picture != (unsigned long )((void *)0)) {
#line 1205
    if ((unsigned long )rgba != (unsigned long )((void *)0)) {
      {
#line 1205
      __cil_tmp4 = Import(picture, rgba, rgba_stride, 4, 0, 0);
#line 1205
      tmp = __cil_tmp4;
      }
    } else {
#line 1205
      tmp = 0;
    }
  } else {
#line 1205
    tmp = 0;
  }
#line 1205
  return (tmp);
}
}
#line 31 "/root/patron-new/new_3/src/enc/near_lossless_enc.c"
static uint32_t FindClosestDiscretized(uint32_t a , int bits ) 
{ 
  uint32_t mask ;
  uint32_t biased ;

  {
#line 32
  mask = (1U << bits) - 1U;
#line 33
  biased = (a + (mask >> 1)) + ((a >> bits) & 1U);
#line 35
  if (biased > 255U) {
#line 35
    return ((uint32_t )255);
  }
#line 36
  return (biased & ~ mask);
}
}
#line 40 "/root/patron-new/new_3/src/enc/near_lossless_enc.c"
static uint32_t ClosestDiscretizedArgb(uint32_t a , int bits ) 
{ 
  uint32_t __cil_tmp3 ;
  uint32_t __cil_tmp4 ;
  uint32_t __cil_tmp5 ;
  uint32_t __cil_tmp6 ;

  {
  {
#line 41
  __cil_tmp6 = FindClosestDiscretized(a & 255U, bits);
#line 41
  __cil_tmp5 = FindClosestDiscretized((a >> 8) & 255U, bits);
#line 41
  __cil_tmp4 = FindClosestDiscretized((a >> 16) & 255U, bits);
#line 41
  __cil_tmp3 = FindClosestDiscretized(a >> 24, bits);
  }
#line 41
  return ((((__cil_tmp3 << 24) | (__cil_tmp4 << 16)) | (__cil_tmp5 << 8)) | __cil_tmp6);
}
}
#line 50 "/root/patron-new/new_3/src/enc/near_lossless_enc.c"
static int IsNear(uint32_t a , uint32_t b , int limit ) 
{ 
  int k ;
  int delta ;

  {
#line 52
  k = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;

#line 52
    if (! (k < 4)) {
#line 52
      goto while_break;
    }
#line 53
    delta = (int )((a >> k * 8) & 255U) - (int )((b >> k * 8) & 255U);
#line 55
    if (delta >= limit) {
#line 56
      return (0);
    } else
#line 55
    if (delta <= - limit) {
#line 56
      return (0);
    }
#line 52
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 59
  return (1);
}
}
#line 62 "/root/patron-new/new_3/src/enc/near_lossless_enc.c"
static int IsSmooth(uint32_t *prev_row , uint32_t *curr_row , uint32_t *next_row ,
                    int ix , int limit ) 
{ 
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int tmp ;

  {
  {
#line 67
  __cil_tmp9 = IsNear(*(curr_row + ix), *(next_row + ix), limit);
#line 67
  __cil_tmp8 = IsNear(*(curr_row + ix), *(prev_row + ix), limit);
#line 67
  __cil_tmp7 = IsNear(*(curr_row + ix), *(curr_row + (ix + 1)), limit);
#line 67
  __cil_tmp6 = IsNear(*(curr_row + ix), *(curr_row + (ix - 1)), limit);
  }
#line 67
  if (__cil_tmp6) {
#line 67
    if (__cil_tmp7) {
#line 67
      if (__cil_tmp8) {
#line 67
        if (__cil_tmp9) {
#line 67
          tmp = 1;
        } else {
#line 67
          tmp = 0;
        }
      } else {
#line 67
        tmp = 0;
      }
    } else {
#line 67
      tmp = 0;
    }
  } else {
#line 67
    tmp = 0;
  }
#line 67
  return (tmp);
}
}
#line 74 "/root/patron-new/new_3/src/enc/near_lossless_enc.c"
static void NearLossless___0(int xsize , int ysize , uint32_t *argb_src , int stride ,
                             int limit_bits , uint32_t *copy_buffer , uint32_t *argb_dst ) 
{ 
  int x ;
  int y ;
  int limit ;
  uint32_t *prev_row ;
  uint32_t *curr_row ;
  uint32_t *next_row ;
  int __cil_tmp14 ;
  uint32_t *temp ;

  {
  {
#line 78
  limit = 1 << limit_bits;
#line 79
  prev_row = copy_buffer;
#line 80
  curr_row = prev_row + xsize;
#line 81
  next_row = curr_row + xsize;
#line 82
  memcpy((void *)curr_row, (void const   *)argb_src, (unsigned long )xsize * sizeof(*(argb_src + 0)));
#line 83
  memcpy((void *)next_row, (void const   *)(argb_src + stride), (unsigned long )xsize * sizeof(*(argb_src + 0)));
#line 85
  y = 0;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;

#line 85
    if (! (y < ysize)) {
#line 85
      goto while_break;
    }
#line 86
    if (y == 0) {
      {
#line 87
      memcpy((void *)argb_dst, (void const   *)argb_src, (unsigned long )xsize * sizeof(*(argb_src + 0)));
      }
    } else
#line 86
    if (y == ysize - 1) {
      {
#line 87
      memcpy((void *)argb_dst, (void const   *)argb_src, (unsigned long )xsize * sizeof(*(argb_src + 0)));
      }
    } else {
      {
#line 89
      memcpy((void *)next_row, (void const   *)(argb_src + stride), (unsigned long )xsize * sizeof(*(argb_src + 0)));
#line 90
      *(argb_dst + 0) = *(argb_src + 0);
#line 91
      *(argb_dst + (xsize - 1)) = *(argb_src + (xsize - 1));
#line 92
      x = 1;
      }
      {
#line 92
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 92
        if (! (x < xsize - 1)) {
#line 92
          goto while_break___0;
        }
        {
#line 93
        __cil_tmp14 = IsSmooth(prev_row, curr_row, next_row, x, limit);
        }
#line 93
        if (__cil_tmp14) {
#line 94
          *(argb_dst + x) = *(curr_row + x);
        } else {
          {
#line 96
          *(argb_dst + x) = ClosestDiscretizedArgb(*(curr_row + x), limit_bits);
          }
        }
#line 92
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
    }
#line 102
    temp = prev_row;
#line 103
    prev_row = curr_row;
#line 104
    curr_row = next_row;
#line 105
    next_row = temp;
#line 85
    argb_dst += xsize;
#line 85
    argb_src += stride;
#line 85
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 89
  return;
}
}
#line 110 "/root/patron-new/new_3/src/enc/near_lossless_enc.c"
int VP8ApplyNearLossless(WebPPicture *picture , int quality , uint32_t *argb_dst ) 
{ 
  int i ;
  int xsize ;
  int ysize ;
  int stride ;
  uint32_t *copy_buffer ;
  void *__cil_tmp9 ;
  int limit_bits ;
  int __cil_tmp11 ;

  {
  {
#line 113
  xsize = picture->width;
#line 114
  ysize = picture->height;
#line 115
  stride = picture->argb_stride;
#line 116
  __cil_tmp9 = WebPSafeMalloc((uint64_t )(xsize * 3), sizeof(*copy_buffer));
#line 116
  copy_buffer = (uint32_t *)__cil_tmp9;
#line 118
  __cil_tmp11 = VP8LNearLosslessBits(quality);
#line 118
  limit_bits = __cil_tmp11;
  }
#line 122
  if ((unsigned long )copy_buffer == (unsigned long )((void *)0)) {
#line 123
    return (0);
  }
#line 126
  if (xsize < 64) {
#line 126
    if (ysize < 64) {
      _L: 
#line 129
      i = 0;
      {
#line 129
      while (1) {
        while_continue: /* CIL Label */ ;

#line 129
        if (! (i < ysize)) {
#line 129
          goto while_break;
        }
        {
#line 130
        memcpy((void *)(argb_dst + i * xsize), (void const   *)(picture->argb + i * picture->argb_stride),
               (unsigned long )xsize * sizeof(*argb_dst));
#line 129
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: 
      {
#line 133
      WebPSafeFree((void *)copy_buffer);
      }
#line 134
      return (1);
    } else {
#line 126
      goto _L___15;
    }
  } else
  _L___15: 
#line 126
  if (ysize < 3) {
#line 126
    goto _L;
  }
  {
#line 137
  NearLossless___0(xsize, ysize, picture->argb, stride, limit_bits, copy_buffer, argb_dst);
#line 139
  i = limit_bits - 1;
  }
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 139
    if (! (i != 0)) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    NearLossless___0(xsize, ysize, argb_dst, xsize, i, copy_buffer, argb_dst);
#line 139
    i --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 142
  WebPSafeFree((void *)copy_buffer);
  }
#line 143
  return (1);
}
}
#line 22 "/root/patron-new/new_3/src/enc/iterator_enc.c"
static void InitLeft(VP8EncIterator *it ) 
{ 
  int tmp ;

  {
#line 23
  if (it->y_ > 0) {
#line 23
    tmp = 129;
  } else {
#line 23
    tmp = 127;
  }
  {
#line 23
  *(it->v_left_ + -1) = (uint8_t )tmp;
#line 23
  *(it->u_left_ + -1) = *(it->v_left_ + -1);
#line 23
  *(it->y_left_ + -1) = *(it->u_left_ + -1);
#line 25
  memset((void *)it->y_left_, 129, 16UL);
#line 26
  memset((void *)it->u_left_, 129, 8UL);
#line 27
  memset((void *)it->v_left_, 129, 8UL);
#line 28
  it->left_nz_[8] = 0;
  }
#line 29
  if ((unsigned long )it->top_derr_ != (unsigned long )((void *)0)) {
    {
#line 30
    memset((void *)(& it->left_derr_), 0, sizeof(it->left_derr_));
    }
  }
#line 33
  return;
}
}
#line 34 "/root/patron-new/new_3/src/enc/iterator_enc.c"
static void InitTop(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  size_t top_size ;

  {
  {
#line 35
  enc = it->enc_;
#line 36
  top_size = (size_t )(enc->mb_w_ * 16);
#line 37
  memset((void *)enc->y_top_, 127, 2UL * top_size);
#line 38
  memset((void *)enc->nz_, 0, (unsigned long )enc->mb_w_ * sizeof(*(enc->nz_)));
  }
#line 39
  if ((unsigned long )enc->top_derr_ != (unsigned long )((void *)0)) {
    {
#line 40
    memset((void *)enc->top_derr_, 0, (unsigned long )enc->mb_w_ * sizeof(*(enc->top_derr_)));
    }
  }
#line 43
  return;
}
}
#line 44 "/root/patron-new/new_3/src/enc/iterator_enc.c"
void VP8IteratorSetRow(VP8EncIterator *it , int y ) 
{ 
  VP8Encoder *enc ;

  {
  {
#line 45
  enc = it->enc_;
#line 46
  it->x_ = 0;
#line 47
  it->y_ = y;
#line 48
  it->bw_ = & enc->parts_[y & (enc->num_parts_ - 1)];
#line 49
  it->preds_ = enc->preds_ + (y * 4) * enc->preds_w_;
#line 50
  it->nz_ = enc->nz_;
#line 51
  it->mb_ = enc->mb_info_ + y * enc->mb_w_;
#line 52
  it->y_top_ = enc->y_top_;
#line 53
  it->uv_top_ = enc->uv_top_;
#line 54
  InitLeft(it);
  }
#line 56
  return;
}
}
#line 57 "/root/patron-new/new_3/src/enc/iterator_enc.c"
void VP8IteratorReset(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;

  {
  {
#line 58
  enc = it->enc_;
#line 59
  VP8IteratorSetRow(it, 0);
#line 60
  VP8IteratorSetCountDown(it, enc->mb_w_ * enc->mb_h_);
#line 61
  InitTop(it);
#line 62
  memset((void *)(it->bit_count_), 0, sizeof(it->bit_count_));
#line 63
  it->do_trellis_ = 0;
  }
#line 65
  return;
}
}
#line 66 "/root/patron-new/new_3/src/enc/iterator_enc.c"
void VP8IteratorSetCountDown(VP8EncIterator *it , int count_down ) 
{ 


  {
#line 67
  it->count_down0_ = count_down;
#line 67
  it->count_down_ = it->count_down0_;
#line 68
  return;
}
}
#line 70 "/root/patron-new/new_3/src/enc/iterator_enc.c"
int VP8IteratorIsDone(VP8EncIterator *it ) 
{ 


  {
#line 71
  return (it->count_down_ <= 0);
}
}
#line 74 "/root/patron-new/new_3/src/enc/iterator_enc.c"
void VP8IteratorInit(VP8Encoder *enc , VP8EncIterator *it ) 
{ 


  {
  {
#line 75
  it->enc_ = enc;
#line 76
  it->yuv_in_ = (uint8_t *)(((uintptr_t )(it->yuv_mem_) + 31UL) & 0xffffffffffffffe0UL);
#line 77
  it->yuv_out_ = it->yuv_in_ + 512;
#line 78
  it->yuv_out2_ = it->yuv_out_ + 512;
#line 79
  it->yuv_p_ = it->yuv_out2_ + 512;
#line 80
  it->lf_stats_ = enc->lf_stats_;
#line 81
  it->percent0_ = enc->percent_;
#line 82
  it->y_left_ = (uint8_t *)(((uintptr_t )(it->yuv_left_mem_ + 1) + 31UL) & 0xffffffffffffffe0UL);
#line 83
  it->u_left_ = (it->y_left_ + 16) + 16;
#line 84
  it->v_left_ = it->u_left_ + 16;
#line 85
  it->top_derr_ = enc->top_derr_;
#line 86
  VP8IteratorReset(it);
  }
#line 88
  return;
}
}
#line 89 "/root/patron-new/new_3/src/enc/iterator_enc.c"
int VP8IteratorProgress(VP8EncIterator *it , int delta ) 
{ 
  VP8Encoder *enc ;
  int done ;
  int percent ;
  int tmp ;
  int __cil_tmp7 ;

  {
#line 90
  enc = it->enc_;
#line 91
  if ((unsigned long )(enc->pic_)->progress_hook != (unsigned long )((void *)0)) {
#line 91
    if (delta) {
#line 92
      done = it->count_down0_ - it->count_down_;
#line 93
      if (it->count_down0_ <= 0) {
#line 93
        tmp = it->percent0_;
      } else {
#line 93
        tmp = it->percent0_ + (delta * done) / it->count_down0_;
      }
      {
#line 93
      percent = tmp;
#line 96
      __cil_tmp7 = WebPReportProgress(enc->pic_, percent, & enc->percent_);
      }
#line 96
      return (__cil_tmp7);
    }
  }
#line 98
  return (1);
}
}
#line 105 "/root/patron-new/new_3/src/enc/iterator_enc.c"
__inline static int MinSize(int a , int b ) 
{ 
  int tmp ;

  {
#line 105
  if (a < b) {
#line 105
    tmp = a;
  } else {
#line 105
    tmp = b;
  }
#line 105
  return (tmp);
}
}
#line 107 "/root/patron-new/new_3/src/enc/iterator_enc.c"
static void ImportBlock(uint8_t *src , int src_stride , uint8_t *dst , int w , int h ,
                        int size ) 
{ 
  int i ;

  {
#line 110
  i = 0;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;

#line 110
    if (! (i < h)) {
#line 110
      goto while_break;
    }
    {
#line 111
    memcpy((void *)dst, (void const   *)src, (unsigned long )w);
    }
#line 112
    if (w < size) {
      {
#line 113
      memset((void *)(dst + w), (int )*(dst + (w - 1)), (unsigned long )(size - w));
      }
    }
#line 115
    dst += 32;
#line 116
    src += src_stride;
#line 110
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 118
  i = h;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 118
    if (! (i < size)) {
#line 118
      goto while_break___0;
    }
    {
#line 119
    memcpy((void *)dst, (void const   *)(dst - 32), (unsigned long )size);
#line 120
    dst += 32;
#line 118
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 122
  return;
}
}
#line 124 "/root/patron-new/new_3/src/enc/iterator_enc.c"
static void ImportLine(uint8_t *src , int src_stride , uint8_t *dst , int len , int total_len ) 
{ 
  int i ;

  {
#line 127
  i = 0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;

#line 127
    if (! (i < len)) {
#line 127
      goto while_break;
    }
#line 127
    *(dst + i) = *src;
#line 127
    src += src_stride;
#line 127
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 128
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 128
    if (! (i < total_len)) {
#line 128
      goto while_break___0;
    }
#line 128
    *(dst + i) = *(dst + (len - 1));
#line 128
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 132
  return;
}
}
#line 131 "/root/patron-new/new_3/src/enc/iterator_enc.c"
void VP8IteratorImport(VP8EncIterator *it , uint8_t *tmp_32 ) 
{ 
  VP8Encoder *enc ;
  int x ;
  int y ;
  WebPPicture *pic ;
  uint8_t *ysrc ;
  uint8_t *usrc ;
  uint8_t *vsrc ;
  int w ;
  int __cil_tmp11 ;
  int h ;
  int __cil_tmp13 ;
  int uv_w ;
  int uv_h ;

  {
  {
#line 132
  enc = it->enc_;
#line 133
  x = it->x_;
#line 133
  y = it->y_;
#line 134
  pic = enc->pic_;
#line 135
  ysrc = pic->y + (y * pic->y_stride + x) * 16;
#line 136
  usrc = pic->u + (y * pic->uv_stride + x) * 8;
#line 137
  vsrc = pic->v + (y * pic->uv_stride + x) * 8;
#line 138
  __cil_tmp11 = MinSize(pic->width - x * 16, 16);
#line 138
  w = __cil_tmp11;
#line 139
  __cil_tmp13 = MinSize(pic->height - y * 16, 16);
#line 139
  h = __cil_tmp13;
#line 140
  uv_w = (w + 1) >> 1;
#line 141
  uv_h = (h + 1) >> 1;
#line 143
  ImportBlock(ysrc, pic->y_stride, it->yuv_in_ + 0, w, h, 16);
#line 144
  ImportBlock(usrc, pic->uv_stride, it->yuv_in_ + 16, uv_w, uv_h, 8);
#line 145
  ImportBlock(vsrc, pic->uv_stride, it->yuv_in_ + 24, uv_w, uv_h, 8);
  }
#line 147
  if ((unsigned long )tmp_32 == (unsigned long )((void *)0)) {
#line 147
    return;
  }
#line 150
  if (x == 0) {
    {
#line 151
    InitLeft(it);
    }
  } else {
#line 153
    if (y == 0) {
#line 154
      *(it->v_left_ + -1) = (uint8_t )127;
#line 154
      *(it->u_left_ + -1) = *(it->v_left_ + -1);
#line 154
      *(it->y_left_ + -1) = *(it->u_left_ + -1);
    } else {
#line 156
      *(it->y_left_ + -1) = *(ysrc + (-1 - pic->y_stride));
#line 157
      *(it->u_left_ + -1) = *(usrc + (-1 - pic->uv_stride));
#line 158
      *(it->v_left_ + -1) = *(vsrc + (-1 - pic->uv_stride));
    }
    {
#line 160
    ImportLine(ysrc - 1, pic->y_stride, it->y_left_, h, 16);
#line 161
    ImportLine(usrc - 1, pic->uv_stride, it->u_left_, uv_h, 8);
#line 162
    ImportLine(vsrc - 1, pic->uv_stride, it->v_left_, uv_h, 8);
    }
  }
#line 165
  it->y_top_ = tmp_32 + 0;
#line 166
  it->uv_top_ = tmp_32 + 16;
#line 167
  if (y == 0) {
    {
#line 168
    memset((void *)tmp_32, 127, 32UL * sizeof(*tmp_32));
    }
  } else {
    {
#line 170
    ImportLine(ysrc - pic->y_stride, 1, tmp_32, w, 16);
#line 171
    ImportLine(usrc - pic->uv_stride, 1, tmp_32 + 16, uv_w, 8);
#line 172
    ImportLine(vsrc - pic->uv_stride, 1, (tmp_32 + 16) + 8, uv_w, 8);
    }
  }
#line 175
  return;
}
}
#line 179 "/root/patron-new/new_3/src/enc/iterator_enc.c"
static void ExportBlock(uint8_t *src , uint8_t *dst , int dst_stride , int w , int h ) 
{ 
  int __cil_tmp6 ;

  {
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    __cil_tmp6 = h;
#line 181
    h --;
#line 181
    if (! (__cil_tmp6 > 0)) {
#line 181
      goto while_break;
    }
    {
#line 182
    memcpy((void *)dst, (void const   *)src, (unsigned long )w);
#line 183
    dst += dst_stride;
#line 184
    src += 32;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 189
  return;
}
}
#line 188 "/root/patron-new/new_3/src/enc/iterator_enc.c"
void VP8IteratorExport(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  int x ;
  int y ;
  uint8_t *ysrc ;
  uint8_t *usrc ;
  uint8_t *vsrc ;
  WebPPicture *pic ;
  uint8_t *ydst ;
  uint8_t *udst ;
  uint8_t *vdst ;
  int w ;
  int h ;
  int uv_w ;
  int uv_h ;

  {
#line 189
  enc = it->enc_;
#line 190
  if ((enc->config_)->show_compressed) {
#line 191
    x = it->x_;
#line 191
    y = it->y_;
#line 192
    ysrc = it->yuv_out_ + 0;
#line 193
    usrc = it->yuv_out_ + 16;
#line 194
    vsrc = it->yuv_out_ + 24;
#line 195
    pic = enc->pic_;
#line 196
    ydst = pic->y + (y * pic->y_stride + x) * 16;
#line 197
    udst = pic->u + (y * pic->uv_stride + x) * 8;
#line 198
    vdst = pic->v + (y * pic->uv_stride + x) * 8;
#line 199
    w = pic->width - x * 16;
#line 200
    h = pic->height - y * 16;
#line 202
    if (w > 16) {
#line 202
      w = 16;
    }
#line 203
    if (h > 16) {
#line 203
      h = 16;
    }
    {
#line 206
    ExportBlock(ysrc, ydst, pic->y_stride, w, h);
#line 209
    uv_w = (w + 1) >> 1;
#line 210
    uv_h = (h + 1) >> 1;
#line 211
    ExportBlock(usrc, udst, pic->uv_stride, uv_w, uv_h);
#line 212
    ExportBlock(vsrc, vdst, pic->uv_stride, uv_w, uv_h);
    }
  }
#line 215
  return;
}
}
#line 234 "/root/patron-new/new_3/src/enc/iterator_enc.c"
void VP8IteratorNzToBytes(VP8EncIterator *it ) 
{ 
  int tnz ;
  int lnz ;
  int *top_nz ;
  int *left_nz ;

  {
#line 235
  tnz = (int )*(it->nz_ + 0);
#line 235
  lnz = (int )*(it->nz_ + -1);
#line 236
  top_nz = it->top_nz_;
#line 237
  left_nz = it->left_nz_;
#line 240
  *(top_nz + 0) = ! (! (tnz & (1 << 12)));
#line 241
  *(top_nz + 1) = ! (! (tnz & (1 << 13)));
#line 242
  *(top_nz + 2) = ! (! (tnz & (1 << 14)));
#line 243
  *(top_nz + 3) = ! (! (tnz & (1 << 15)));
#line 245
  *(top_nz + 4) = ! (! (tnz & (1 << 18)));
#line 246
  *(top_nz + 5) = ! (! (tnz & (1 << 19)));
#line 248
  *(top_nz + 6) = ! (! (tnz & (1 << 22)));
#line 249
  *(top_nz + 7) = ! (! (tnz & (1 << 23)));
#line 251
  *(top_nz + 8) = ! (! (tnz & (1 << 24)));
#line 254
  *(left_nz + 0) = ! (! (lnz & (1 << 3)));
#line 255
  *(left_nz + 1) = ! (! (lnz & (1 << 7)));
#line 256
  *(left_nz + 2) = ! (! (lnz & (1 << 11)));
#line 257
  *(left_nz + 3) = ! (! (lnz & (1 << 15)));
#line 259
  *(left_nz + 4) = ! (! (lnz & (1 << 17)));
#line 260
  *(left_nz + 5) = ! (! (lnz & (1 << 19)));
#line 262
  *(left_nz + 6) = ! (! (lnz & (1 << 21)));
#line 263
  *(left_nz + 7) = ! (! (lnz & (1 << 23)));
#line 264
  return;
}
}
#line 267 "/root/patron-new/new_3/src/enc/iterator_enc.c"
void VP8IteratorBytesToNz(VP8EncIterator *it ) 
{ 
  uint32_t nz ;
  int const   *top_nz ;
  int const   *left_nz ;

  {
#line 268
  nz = (uint32_t )0;
#line 269
  top_nz = (int const   *)(it->top_nz_);
#line 270
  left_nz = (int const   *)(it->left_nz_);
#line 272
  nz |= (unsigned int )((*(top_nz + 0) << 12) | (*(top_nz + 1) << 13));
#line 273
  nz |= (unsigned int )((*(top_nz + 2) << 14) | (*(top_nz + 3) << 15));
#line 274
  nz |= (unsigned int )((*(top_nz + 4) << 18) | (*(top_nz + 5) << 19));
#line 275
  nz |= (unsigned int )((*(top_nz + 6) << 22) | (*(top_nz + 7) << 23));
#line 276
  nz |= (unsigned int )(*(top_nz + 8) << 24);
#line 278
  nz |= (unsigned int )((*(left_nz + 0) << 3) | (*(left_nz + 1) << 7));
#line 279
  nz |= (unsigned int )(*(left_nz + 2) << 11);
#line 280
  nz |= (unsigned int )((*(left_nz + 4) << 17) | (*(left_nz + 6) << 21));
#line 282
  *(it->nz_) = nz;
#line 283
  return;
}
}
#line 290 "/root/patron-new/new_3/src/enc/iterator_enc.c"
void VP8IteratorSaveBoundary(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  int x ;
  int y ;
  uint8_t *ysrc ;
  uint8_t *uvsrc ;
  int i ;

  {
#line 291
  enc = it->enc_;
#line 292
  x = it->x_;
#line 292
  y = it->y_;
#line 293
  ysrc = it->yuv_out_ + 0;
#line 294
  uvsrc = it->yuv_out_ + 16;
#line 295
  if (x < enc->mb_w_ - 1) {
#line 297
    i = 0;
    {
#line 297
    while (1) {
      while_continue: /* CIL Label */ ;

#line 297
      if (! (i < 16)) {
#line 297
        goto while_break;
      }
#line 298
      *(it->y_left_ + i) = *(ysrc + (15 + i * 32));
#line 297
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
#line 300
    i = 0;
    {
#line 300
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 300
      if (! (i < 8)) {
#line 300
        goto while_break___0;
      }
#line 301
      *(it->u_left_ + i) = *(uvsrc + (7 + i * 32));
#line 302
      *(it->v_left_ + i) = *(uvsrc + (15 + i * 32));
#line 300
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 305
    *(it->y_left_ + -1) = *(it->y_top_ + 15);
#line 306
    *(it->u_left_ + -1) = *(it->uv_top_ + 7);
#line 307
    *(it->v_left_ + -1) = *(it->uv_top_ + 15);
  }
#line 309
  if (y < enc->mb_h_ - 1) {
    {
#line 310
    memcpy((void *)it->y_top_, (void const   *)(ysrc + 480), 16UL);
#line 311
    memcpy((void *)it->uv_top_, (void const   *)(uvsrc + 224), 16UL);
    }
  }
#line 314
  return;
}
}
#line 315 "/root/patron-new/new_3/src/enc/iterator_enc.c"
int VP8IteratorNext(VP8EncIterator *it ) 
{ 


  {
#line 316
  (it->x_) ++;
#line 316
  if (it->x_ == (it->enc_)->mb_w_) {
    {
#line 317
    (it->y_) ++;
#line 317
    VP8IteratorSetRow(it, it->y_);
    }
  } else {
#line 319
    it->preds_ += 4;
#line 320
    (it->mb_) ++;
#line 321
    (it->nz_) ++;
#line 322
    it->y_top_ += 16;
#line 323
    it->uv_top_ += 16;
  }
#line 325
  (it->count_down_) --;
#line 325
  return (0 < it->count_down_);
}
}
#line 331 "/root/patron-new/new_3/src/enc/iterator_enc.c"
void VP8SetIntra16Mode(VP8EncIterator *it , int mode ) 
{ 
  uint8_t *preds ;
  int y ;

  {
#line 332
  preds = it->preds_;
#line 334
  y = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;

#line 334
    if (! (y < 4)) {
#line 334
      goto while_break;
    }
    {
#line 335
    memset((void *)preds, mode, 4UL);
#line 336
    preds += (it->enc_)->preds_w_;
#line 334
    y ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 338
  (it->mb_)->type_ = 1U;
#line 339
  return;
}
}
#line 341 "/root/patron-new/new_3/src/enc/iterator_enc.c"
void VP8SetIntra4Mode(VP8EncIterator *it , uint8_t *modes ) 
{ 
  uint8_t *preds ;
  int y ;

  {
#line 342
  preds = it->preds_;
#line 344
  y = 4;
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;

#line 344
    if (! (y > 0)) {
#line 344
      goto while_break;
    }
    {
#line 345
    memcpy((void *)preds, (void const   *)modes, 4UL * sizeof(*modes));
#line 346
    preds += (it->enc_)->preds_w_;
#line 347
    modes += 4;
#line 344
    y --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 349
  (it->mb_)->type_ = 0U;
#line 350
  return;
}
}
#line 352 "/root/patron-new/new_3/src/enc/iterator_enc.c"
void VP8SetIntraUVMode(VP8EncIterator *it , int mode ) 
{ 


  {
#line 353
  (it->mb_)->uv_mode_ = (unsigned int )mode;
#line 354
  return;
}
}
#line 356 "/root/patron-new/new_3/src/enc/iterator_enc.c"
void VP8SetSkip(VP8EncIterator *it , int skip ) 
{ 


  {
#line 357
  (it->mb_)->skip_ = (unsigned int )skip;
#line 358
  return;
}
}
#line 360 "/root/patron-new/new_3/src/enc/iterator_enc.c"
void VP8SetSegment(VP8EncIterator *it , int segment ) 
{ 


  {
#line 361
  (it->mb_)->segment_ = (unsigned int )segment;
#line 362
  return;
}
}
#line 396 "/root/patron-new/new_3/src/enc/iterator_enc.c"
static uint8_t VP8TopLeftI4[16]  = 
#line 396
  {      (uint8_t )17,      (uint8_t )21,      (uint8_t )25,      (uint8_t )29, 
        (uint8_t )13,      (uint8_t )17,      (uint8_t )21,      (uint8_t )25, 
        (uint8_t )9,      (uint8_t )13,      (uint8_t )17,      (uint8_t )21, 
        (uint8_t )5,      (uint8_t )9,      (uint8_t )13,      (uint8_t )17};
#line 403 "/root/patron-new/new_3/src/enc/iterator_enc.c"
void VP8IteratorStartI4(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  int i ;

  {
#line 404
  enc = it->enc_;
#line 407
  it->i4_ = 0;
#line 408
  it->i4_top_ = it->i4_boundary_ + (int )VP8TopLeftI4[0];
#line 411
  i = 0;
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;

#line 411
    if (! (i < 17)) {
#line 411
      goto while_break;
    }
#line 412
    it->i4_boundary_[i] = *(it->y_left_ + (15 - i));
#line 411
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 414
  i = 0;
  {
#line 414
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 414
    if (! (i < 16)) {
#line 414
      goto while_break___0;
    }
#line 415
    it->i4_boundary_[17 + i] = *(it->y_top_ + i);
#line 414
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: ;
#line 418
  if (it->x_ < enc->mb_w_ - 1) {
#line 419
    i = 16;
    {
#line 419
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 419
      if (! (i < 20)) {
#line 419
        goto while_break___1;
      }
#line 420
      it->i4_boundary_[17 + i] = *(it->y_top_ + i);
#line 419
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  } else {
#line 423
    i = 16;
    {
#line 423
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 423
      if (! (i < 20)) {
#line 423
        goto while_break___2;
      }
#line 424
      it->i4_boundary_[17 + i] = it->i4_boundary_[32];
#line 423
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
  {
#line 427
  VP8IteratorNzToBytes(it);
  }
#line 429
  return;
}
}
#line 430 "/root/patron-new/new_3/src/enc/iterator_enc.c"
int VP8IteratorRotateI4(VP8EncIterator *it , uint8_t *yuv_out ) 
{ 
  uint8_t *blk ;
  uint8_t *top ;
  int i ;

  {
#line 432
  blk = yuv_out + (int )VP8Scan[it->i4_];
#line 433
  top = it->i4_top_;
#line 437
  i = 0;
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;

#line 437
    if (! (i <= 3)) {
#line 437
      goto while_break;
    }
#line 438
    *(top + (-4 + i)) = *(blk + (i + 96));
#line 437
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 440
  if ((it->i4_ & 3) != 3) {
#line 441
    i = 0;
    {
#line 441
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 441
      if (! (i <= 2)) {
#line 441
        goto while_break___0;
      }
#line 442
      *(top + i) = *(blk + (3 + (2 - i) * 32));
#line 441
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  } else {
#line 445
    i = 0;
    {
#line 445
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 445
      if (! (i <= 3)) {
#line 445
        goto while_break___1;
      }
#line 446
      *(top + i) = *(top + (i + 4));
#line 445
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 450
  (it->i4_) ++;
#line 451
  if (it->i4_ == 16) {
#line 452
    return (0);
  }
#line 455
  it->i4_top_ = it->i4_boundary_ + (int )VP8TopLeftI4[it->i4_];
#line 456
  return (1);
}
}
#line 34 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void HistogramClear(VP8LHistogram *p ) 
{ 
  uint32_t *literal ;
  int cache_bits ;
  int histo_size ;
  int __cil_tmp5 ;

  {
  {
#line 35
  literal = p->literal_;
#line 36
  cache_bits = p->palette_code_bits_;
#line 37
  __cil_tmp5 = VP8LGetHistogramSize(cache_bits);
#line 37
  histo_size = __cil_tmp5;
#line 38
  memset((void *)p, 0, (unsigned long )histo_size);
#line 39
  p->palette_code_bits_ = cache_bits;
#line 40
  p->literal_ = literal;
  }
#line 42
  return;
}
}
#line 44 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void HistogramSwap(VP8LHistogram **A , VP8LHistogram **B ) 
{ 
  VP8LHistogram *tmp ;

  {
#line 45
  tmp = *A;
#line 46
  *A = *B;
#line 47
  *B = tmp;
#line 48
  return;
}
}
#line 50 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void HistogramCopy(VP8LHistogram *src , VP8LHistogram *dst ) 
{ 
  uint32_t *dst_literal ;
  int dst_cache_bits ;
  int literal_size ;
  int __cil_tmp6 ;
  int histo_size ;
  int __cil_tmp8 ;

  {
  {
#line 52
  dst_literal = dst->literal_;
#line 53
  dst_cache_bits = dst->palette_code_bits_;
#line 54
  __cil_tmp6 = VP8LHistogramNumCodes(dst_cache_bits);
#line 54
  literal_size = __cil_tmp6;
#line 55
  __cil_tmp8 = VP8LGetHistogramSize(dst_cache_bits);
#line 55
  histo_size = __cil_tmp8;
#line 57
  memcpy((void *)dst, (void const   *)src, (unsigned long )histo_size);
#line 58
  dst->literal_ = dst_literal;
#line 59
  memcpy((void *)dst->literal_, (void const   *)src->literal_, (unsigned long )literal_size * sizeof(*(dst->literal_)));
  }
#line 61
  return;
}
}
#line 62 "/root/patron-new/new_3/src/enc/histogram_enc.c"
int VP8LGetHistogramSize(int cache_bits ) 
{ 
  int literal_size ;
  int __cil_tmp3 ;
  size_t total_size ;

  {
  {
#line 63
  __cil_tmp3 = VP8LHistogramNumCodes(cache_bits);
#line 63
  literal_size = __cil_tmp3;
#line 64
  total_size = sizeof(VP8LHistogram ) + sizeof(int ) * (unsigned long )literal_size;
  }
#line 66
  return ((int )total_size);
}
}
#line 69 "/root/patron-new/new_3/src/enc/histogram_enc.c"
void VP8LFreeHistogram(VP8LHistogram *histo ) 
{ 


  {
  {
#line 70
  WebPSafeFree((void *)histo);
  }
#line 72
  return;
}
}
#line 73 "/root/patron-new/new_3/src/enc/histogram_enc.c"
void VP8LFreeHistogramSet(VP8LHistogramSet *histo ) 
{ 


  {
  {
#line 74
  WebPSafeFree((void *)histo);
  }
#line 76
  return;
}
}
#line 77 "/root/patron-new/new_3/src/enc/histogram_enc.c"
void VP8LHistogramStoreRefs(VP8LBackwardRefs *refs , VP8LHistogram *histo ) 
{ 
  VP8LRefsCursor c ;
  VP8LRefsCursor __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 79
  __cil_tmp4 = VP8LRefsCursorInit(refs);
#line 79
  c = __cil_tmp4;
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    __cil_tmp5 = VP8LRefsCursorOk(& c);
    }
#line 80
    if (! __cil_tmp5) {
#line 80
      goto while_break;
    }
    {
#line 81
    VP8LHistogramAddSinglePixOrCopy(histo, c.cur_pos, (int (*)(int  , int  ))((void *)0),
                                    0);
#line 82
    VP8LRefsCursorNext(& c);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 87
  return;
}
}
#line 86 "/root/patron-new/new_3/src/enc/histogram_enc.c"
void VP8LHistogramCreate(VP8LHistogram *p , VP8LBackwardRefs *refs , int palette_code_bits ) 
{ 


  {
#line 89
  if (palette_code_bits >= 0) {
#line 90
    p->palette_code_bits_ = palette_code_bits;
  }
  {
#line 92
  HistogramClear(p);
#line 93
  VP8LHistogramStoreRefs(refs, p);
  }
#line 95
  return;
}
}
#line 96 "/root/patron-new/new_3/src/enc/histogram_enc.c"
void VP8LHistogramInit(VP8LHistogram *p , int palette_code_bits , int init_arrays ) 
{ 


  {
#line 98
  p->palette_code_bits_ = palette_code_bits;
#line 99
  if (init_arrays) {
    {
#line 100
    HistogramClear(p);
    }
  } else {
    {
#line 102
    p->trivial_symbol_ = (uint32_t )0;
#line 103
    p->bit_cost_ = 0.;
#line 104
    p->literal_cost_ = 0.;
#line 105
    p->red_cost_ = 0.;
#line 106
    p->blue_cost_ = 0.;
#line 107
    memset((void *)(p->is_used_), 0, sizeof(p->is_used_));
    }
  }
#line 110
  return;
}
}
#line 111 "/root/patron-new/new_3/src/enc/histogram_enc.c"
VP8LHistogram *VP8LAllocateHistogram(int cache_bits ) 
{ 
  VP8LHistogram *histo ;
  int total_size ;
  int __cil_tmp4 ;
  uint8_t *memory ;
  void *__cil_tmp6 ;

  {
  {
#line 112
  histo = (VP8LHistogram *)((void *)0);
#line 113
  __cil_tmp4 = VP8LGetHistogramSize(cache_bits);
#line 113
  total_size = __cil_tmp4;
#line 114
  __cil_tmp6 = WebPSafeMalloc((uint64_t )total_size, sizeof(*memory));
#line 114
  memory = (uint8_t *)__cil_tmp6;
  }
#line 115
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 115
    return ((VP8LHistogram *)((void *)0));
  }
  {
#line 116
  histo = (VP8LHistogram *)memory;
#line 118
  histo->literal_ = (uint32_t *)(memory + sizeof(VP8LHistogram ));
#line 119
  VP8LHistogramInit(histo, cache_bits, 0);
  }
#line 120
  return (histo);
}
}
#line 124 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void HistogramSetResetPointers(VP8LHistogramSet *set , int cache_bits ) 
{ 
  int i ;
  int histo_size ;
  int __cil_tmp5 ;
  uint8_t *memory ;

  {
  {
#line 127
  __cil_tmp5 = VP8LGetHistogramSize(cache_bits);
#line 127
  histo_size = __cil_tmp5;
#line 128
  memory = (uint8_t *)set->histograms;
#line 129
  memory += (unsigned long )set->max_size * sizeof(*(set->histograms));
#line 130
  i = 0;
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;

#line 130
    if (! (i < set->max_size)) {
#line 130
      goto while_break;
    }
#line 131
    memory = (uint8_t *)(((uintptr_t )memory + 31UL) & 0xffffffffffffffe0UL);
#line 132
    *(set->histograms + i) = (VP8LHistogram *)memory;
#line 134
    (*(set->histograms + i))->literal_ = (uint32_t *)(memory + sizeof(VP8LHistogram ));
#line 135
    memory += histo_size;
#line 130
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 134
  return;
}
}
#line 140 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static size_t HistogramSetTotalSize(int size , int cache_bits ) 
{ 
  int histo_size ;
  int __cil_tmp4 ;

  {
  {
#line 141
  __cil_tmp4 = VP8LGetHistogramSize(cache_bits);
#line 141
  histo_size = __cil_tmp4;
  }
#line 142
  return (sizeof(VP8LHistogramSet ) + (unsigned long )size * ((sizeof(VP8LHistogram *) + (unsigned long )histo_size) + 31UL));
}
}
#line 146 "/root/patron-new/new_3/src/enc/histogram_enc.c"
VP8LHistogramSet *VP8LAllocateHistogramSet(int size , int cache_bits ) 
{ 
  int i ;
  VP8LHistogramSet *set ;
  size_t total_size ;
  size_t __cil_tmp6 ;
  uint8_t *memory ;
  void *__cil_tmp8 ;

  {
  {
#line 149
  __cil_tmp6 = HistogramSetTotalSize(size, cache_bits);
#line 149
  total_size = __cil_tmp6;
#line 150
  __cil_tmp8 = WebPSafeMalloc(total_size, sizeof(*memory));
#line 150
  memory = (uint8_t *)__cil_tmp8;
  }
#line 151
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 151
    return ((VP8LHistogramSet *)((void *)0));
  }
  {
#line 153
  set = (VP8LHistogramSet *)memory;
#line 154
  memory += sizeof(*set);
#line 155
  set->histograms = (VP8LHistogram **)memory;
#line 156
  set->max_size = size;
#line 157
  set->size = size;
#line 158
  HistogramSetResetPointers(set, cache_bits);
#line 159
  i = 0;
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;

#line 159
    if (! (i < size)) {
#line 159
      goto while_break;
    }
    {
#line 160
    VP8LHistogramInit(*(set->histograms + i), cache_bits, 0);
#line 159
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 162
  return (set);
}
}
#line 165 "/root/patron-new/new_3/src/enc/histogram_enc.c"
void VP8LHistogramSetClear(VP8LHistogramSet *set ) 
{ 
  int i ;
  int cache_bits ;
  int size ;
  size_t total_size ;
  size_t __cil_tmp6 ;
  uint8_t *memory ;

  {
  {
#line 167
  cache_bits = (*(set->histograms + 0))->palette_code_bits_;
#line 168
  size = set->max_size;
#line 169
  __cil_tmp6 = HistogramSetTotalSize(size, cache_bits);
#line 169
  total_size = __cil_tmp6;
#line 170
  memory = (uint8_t *)set;
#line 172
  memset((void *)memory, 0, total_size);
#line 173
  memory += sizeof(*set);
#line 174
  set->histograms = (VP8LHistogram **)memory;
#line 175
  set->max_size = size;
#line 176
  set->size = size;
#line 177
  HistogramSetResetPointers(set, cache_bits);
#line 178
  i = 0;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;

#line 178
    if (! (i < size)) {
#line 178
      goto while_break;
    }
#line 179
    (*(set->histograms + i))->palette_code_bits_ = cache_bits;
#line 178
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 182
  return;
}
}
#line 184 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void HistogramSetRemoveHistogram(VP8LHistogramSet *set , int i , int *num_used ) 
{ 


  {
#line 187
  *(set->histograms + i) = (VP8LHistogram *)((void *)0);
#line 188
  (*num_used) --;
#line 190
  if (i == set->size - 1) {
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;

#line 191
      if ((unsigned long )*(set->histograms + (set->size - 1)) == (unsigned long )((void *)0)) {
#line 191
        if (! (set->size >= 1)) {
#line 191
          goto while_break;
        }
      } else {
#line 191
        goto while_break;
      }
#line 192
      (set->size) --;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 197
  return;
}
}
#line 199 "/root/patron-new/new_3/src/enc/histogram_enc.c"
void VP8LHistogramAddSinglePixOrCopy(VP8LHistogram *histo , PixOrCopy *v , int (*distance_modifier)(int  ,
                                                                                                    int  ) ,
                                     int distance_modifier_arg0 ) 
{ 
  int __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int literal_ix ;
  uint32_t __cil_tmp12 ;
  int code ;
  int extra_bits ;
  uint32_t __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 203
  __cil_tmp5 = PixOrCopyIsLiteral(v);
  }
#line 203
  if (__cil_tmp5) {
    {
#line 204
    __cil_tmp6 = PixOrCopyLiteral(v, 3);
#line 204
    (histo->alpha_[__cil_tmp6]) ++;
#line 205
    __cil_tmp7 = PixOrCopyLiteral(v, 2);
#line 205
    (histo->red_[__cil_tmp7]) ++;
#line 206
    __cil_tmp8 = PixOrCopyLiteral(v, 1);
#line 206
    (*(histo->literal_ + __cil_tmp8)) ++;
#line 207
    __cil_tmp9 = PixOrCopyLiteral(v, 0);
#line 207
    (histo->blue_[__cil_tmp9]) ++;
    }
  } else {
    {
#line 208
    __cil_tmp10 = PixOrCopyIsCacheIdx(v);
    }
#line 208
    if (__cil_tmp10) {
      {
#line 209
      __cil_tmp12 = PixOrCopyCacheIdx(v);
#line 209
      literal_ix = (int )(280U + __cil_tmp12);
#line 212
      (*(histo->literal_ + literal_ix)) ++;
      }
    } else {
      {
#line 215
      __cil_tmp15 = PixOrCopyLength(v);
#line 215
      VP8LPrefixEncodeBits((int )__cil_tmp15, & code, & extra_bits);
#line 216
      (*(histo->literal_ + (256 + code))) ++;
      }
#line 217
      if ((unsigned long )distance_modifier == (unsigned long )((void *)0)) {
        {
#line 218
        __cil_tmp16 = PixOrCopyCacheIdx(v);
#line 218
        VP8LPrefixEncodeBits((int )__cil_tmp16, & code, & extra_bits);
        }
      } else {
        {
#line 220
        __cil_tmp17 = PixOrCopyCacheIdx(v);
#line 220
        __cil_tmp18 = (*distance_modifier)(distance_modifier_arg0, (int )__cil_tmp17);
#line 220
        VP8LPrefixEncodeBits(__cil_tmp18, & code, & extra_bits);
        }
      }
#line 224
      (histo->distance_[code]) ++;
    }
  }
#line 227
  return;
}
}
#line 231 "/root/patron-new/new_3/src/enc/histogram_enc.c"
__inline static double BitsEntropyRefine(VP8LBitEntropy *entropy ) 
{ 
  double mix ;
  double min_limit ;
  double tmp ;

  {
#line 233
  if (entropy->nonzeros < 5) {
#line 234
    if (entropy->nonzeros <= 1) {
#line 235
      return ((double )0);
    }
#line 240
    if (entropy->nonzeros == 2) {
#line 241
      return (0.99 * (double )entropy->sum + 0.0100000000001 * entropy->entropy);
    }
#line 247
    if (entropy->nonzeros == 3) {
#line 248
      mix = 0.95;
    } else {
#line 250
      mix = 0.7;
    }
  } else {
#line 253
    mix = 0.627000000001;
  }
#line 257
  min_limit = (double )(2U * entropy->sum - entropy->max_val);
#line 258
  min_limit = mix * min_limit + (1. - mix) * entropy->entropy;
#line 259
  if (entropy->entropy < min_limit) {
#line 259
    tmp = min_limit;
  } else {
#line 259
    tmp = entropy->entropy;
  }
#line 259
  return (tmp);
}
}
#line 263 "/root/patron-new/new_3/src/enc/histogram_enc.c"
double VP8LBitsEntropy(uint32_t *array , int n ) 
{ 
  VP8LBitEntropy entropy ;
  double __cil_tmp4 ;

  {
  {
#line 265
  VP8LBitsEntropyUnrefined(array, n, & entropy);
#line 267
  __cil_tmp4 = BitsEntropyRefine(& entropy);
  }
#line 267
  return (__cil_tmp4);
}
}
#line 272 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static int kHuffmanCodeOfHuffmanCodeSize  ;
#line 273 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static double kSmallBias  ;
#line 270 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static double InitialHuffmanCost(void) 
{ 


  {
#line 273
  kHuffmanCodeOfHuffmanCodeSize = 57;
#line 274
  kSmallBias = 9.1;
#line 275
  return ((double )kHuffmanCodeOfHuffmanCodeSize - kSmallBias);
}
}
#line 279 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static double FinalHuffmanCost(VP8LStreaks *stats ) 
{ 
  double retval ;
  double __cil_tmp3 ;

  {
  {
#line 282
  __cil_tmp3 = InitialHuffmanCost();
#line 282
  retval = __cil_tmp3;
#line 285
  retval += (double )stats->counts[0] * 1.5625 + 0.234375 * (double )stats->streaks[0][1];
#line 288
  retval += (double )stats->counts[1] * 2.578125 + 0.703125 * (double )stats->streaks[1][1];
#line 291
  retval += 1.796875 * (double )stats->streaks[0][0];
#line 293
  retval += 3.28125 * (double )stats->streaks[1][0];
  }
#line 294
  return (retval);
}
}
#line 299 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static double PopulationCost(uint32_t *population , int length , uint32_t *trivial_sym ,
                             uint8_t *is_used ) 
{ 
  VP8LBitEntropy bit_entropy ;
  VP8LStreaks stats ;
  uint32_t tmp ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;
  int tmp___0 ;

  {
  {
#line 304
  (*VP8LGetEntropyUnrefined)(population, length, (VP8LBitEntropy */* const  */)(& bit_entropy),
                             (VP8LStreaks */* const  */)(& stats));
  }
#line 305
  if ((unsigned long )trivial_sym != (unsigned long )((void *)0)) {
#line 306
    if (bit_entropy.nonzeros == 1) {
#line 306
      tmp = bit_entropy.nonzero_code;
    } else {
#line 306
      tmp = 4294967295U;
    }
#line 306
    *trivial_sym = tmp;
  }
#line 310
  if (stats.streaks[1][0] != 0) {
#line 310
    tmp___0 = 1;
  } else
#line 310
  if (stats.streaks[1][1] != 0) {
#line 310
    tmp___0 = 1;
  } else {
#line 310
    tmp___0 = 0;
  }
  {
#line 310
  *is_used = (uint8_t )tmp___0;
#line 312
  __cil_tmp9 = FinalHuffmanCost(& stats);
#line 312
  __cil_tmp8 = BitsEntropyRefine(& bit_entropy);
  }
#line 312
  return (__cil_tmp8 + __cil_tmp9);
}
}
#line 317 "/root/patron-new/new_3/src/enc/histogram_enc.c"
__inline static double GetCombinedEntropy(uint32_t *X , uint32_t *Y , int length ,
                                          int is_X_used , int is_Y_used , int trivial_at_end ) 
{ 
  VP8LStreaks stats ;
  double __cil_tmp8 ;
  VP8LBitEntropy bit_entropy ;
  double __cil_tmp10 ;
  double __cil_tmp11 ;

  {
#line 323
  if (trivial_at_end) {
    {
#line 328
    memset((void *)(& stats), 0, sizeof(stats));
#line 330
    stats.streaks[1][0] = 1;
#line 332
    stats.counts[0] = 1;
#line 333
    stats.streaks[0][1] = length - 1;
#line 334
    __cil_tmp8 = FinalHuffmanCost(& stats);
    }
#line 334
    return (__cil_tmp8);
  } else {
#line 337
    if (is_X_used) {
#line 338
      if (is_Y_used) {
        {
#line 339
        (*VP8LGetCombinedEntropyUnrefined)(X, Y, length, (VP8LBitEntropy */* const  */)(& bit_entropy),
                                           (VP8LStreaks */* const  */)(& stats));
        }
      } else {
        {
#line 341
        (*VP8LGetEntropyUnrefined)(X, length, (VP8LBitEntropy */* const  */)(& bit_entropy),
                                   (VP8LStreaks */* const  */)(& stats));
        }
      }
    } else
#line 344
    if (is_Y_used) {
      {
#line 345
      (*VP8LGetEntropyUnrefined)(Y, length, (VP8LBitEntropy */* const  */)(& bit_entropy),
                                 (VP8LStreaks */* const  */)(& stats));
      }
    } else {
      {
#line 347
      memset((void *)(& stats), 0, sizeof(stats));
#line 348
      stats.counts[0] = 1;
#line 349
      stats.streaks[0][length > 3] = length;
#line 350
      VP8LBitEntropyInit(& bit_entropy);
      }
    }
    {
#line 354
    __cil_tmp11 = FinalHuffmanCost(& stats);
#line 354
    __cil_tmp10 = BitsEntropyRefine(& bit_entropy);
    }
#line 354
    return (__cil_tmp10 + __cil_tmp11);
  }
}
}
#line 359 "/root/patron-new/new_3/src/enc/histogram_enc.c"
double VP8LHistogramEstimateBits(VP8LHistogram *p ) 
{ 
  int __cil_tmp2 ;
  double __cil_tmp3 ;
  double __cil_tmp4 ;
  double __cil_tmp5 ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;

  {
  {
#line 360
  __cil_tmp9 = (*VP8LExtraCost)(p->distance_, 40);
#line 360
  __cil_tmp8 = (*VP8LExtraCost)(p->literal_ + 256, 24);
#line 360
  __cil_tmp7 = PopulationCost(p->distance_, 40, (uint32_t *)((void *)0), & p->is_used_[4]);
#line 360
  __cil_tmp6 = PopulationCost(p->alpha_, 256, (uint32_t *)((void *)0), & p->is_used_[3]);
#line 360
  __cil_tmp5 = PopulationCost(p->blue_, 256, (uint32_t *)((void *)0), & p->is_used_[2]);
#line 360
  __cil_tmp4 = PopulationCost(p->red_, 256, (uint32_t *)((void *)0), & p->is_used_[1]);
#line 360
  __cil_tmp2 = VP8LHistogramNumCodes(p->palette_code_bits_);
#line 360
  __cil_tmp3 = PopulationCost(p->literal_, __cil_tmp2, (uint32_t *)((void *)0), & p->is_used_[0]);
  }
#line 360
  return ((((((__cil_tmp3 + __cil_tmp4) + __cil_tmp5) + __cil_tmp6) + __cil_tmp7) + __cil_tmp8) + __cil_tmp9);
}
}
#line 374 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static int GetCombinedHistogramEntropy(VP8LHistogram *a , VP8LHistogram *b , double cost_threshold ,
                                       double *cost ) 
{ 
  int palette_code_bits ;
  int trivial_at_end ;
  int __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;
  uint32_t color_a ;
  uint32_t color_r ;
  uint32_t color_b ;
  double __cil_tmp13 ;
  double __cil_tmp14 ;
  double __cil_tmp15 ;
  double __cil_tmp16 ;
  double __cil_tmp17 ;

  {
  {
#line 378
  palette_code_bits = a->palette_code_bits_;
#line 379
  trivial_at_end = 0;
#line 381
  __cil_tmp7 = VP8LHistogramNumCodes(palette_code_bits);
#line 381
  __cil_tmp8 = GetCombinedEntropy(a->literal_, b->literal_, __cil_tmp7, (int )a->is_used_[0],
                                  (int )b->is_used_[0], 0);
#line 381
  *cost += __cil_tmp8;
#line 384
  __cil_tmp9 = (*VP8LExtraCostCombined)(a->literal_ + 256, b->literal_ + 256, 24);
#line 384
  *cost += __cil_tmp9;
  }
#line 387
  if (*cost > cost_threshold) {
#line 387
    return (0);
  }
#line 389
  if (a->trivial_symbol_ != 4294967295U) {
#line 389
    if (a->trivial_symbol_ == b->trivial_symbol_) {
#line 392
      color_a = (a->trivial_symbol_ >> 24) & 255U;
#line 393
      color_r = (a->trivial_symbol_ >> 16) & 255U;
#line 394
      color_b = a->trivial_symbol_ & 255U;
#line 395
      if (color_a == 0U) {
        _L___16: 
#line 395
        if (color_r == 0U) {
          _L: 
#line 395
          if (color_b == 0U) {
#line 398
            trivial_at_end = 1;
          } else
#line 395
          if (color_b == 255U) {
#line 398
            trivial_at_end = 1;
          }
        } else
#line 395
        if (color_r == 255U) {
#line 395
          goto _L;
        }
      } else
#line 395
      if (color_a == 255U) {
#line 395
        goto _L___16;
      }
    }
  }
  {
#line 402
  __cil_tmp13 = GetCombinedEntropy(a->red_, b->red_, 256, (int )a->is_used_[1], (int )b->is_used_[1],
                                   trivial_at_end);
#line 402
  *cost += __cil_tmp13;
  }
#line 405
  if (*cost > cost_threshold) {
#line 405
    return (0);
  }
  {
#line 407
  __cil_tmp14 = GetCombinedEntropy(a->blue_, b->blue_, 256, (int )a->is_used_[2],
                                   (int )b->is_used_[2], trivial_at_end);
#line 407
  *cost += __cil_tmp14;
  }
#line 410
  if (*cost > cost_threshold) {
#line 410
    return (0);
  }
  {
#line 412
  __cil_tmp15 = GetCombinedEntropy(a->alpha_, b->alpha_, 256, (int )a->is_used_[3],
                                   (int )b->is_used_[3], trivial_at_end);
#line 412
  *cost += __cil_tmp15;
  }
#line 415
  if (*cost > cost_threshold) {
#line 415
    return (0);
  }
  {
#line 417
  __cil_tmp16 = GetCombinedEntropy(a->distance_, b->distance_, 40, (int )a->is_used_[4],
                                   (int )b->is_used_[4], 0);
#line 417
  *cost += __cil_tmp16;
#line 420
  __cil_tmp17 = (*VP8LExtraCostCombined)(a->distance_, b->distance_, 40);
#line 420
  *cost += __cil_tmp17;
  }
#line 422
  if (*cost > cost_threshold) {
#line 422
    return (0);
  }
#line 424
  return (1);
}
}
#line 427 "/root/patron-new/new_3/src/enc/histogram_enc.c"
__inline static void HistogramAdd(VP8LHistogram *a , VP8LHistogram *b , VP8LHistogram *out ) 
{ 
  uint32_t tmp ;

  {
  {
#line 430
  VP8LHistogramAdd(a, b, out);
  }
#line 431
  if (a->trivial_symbol_ == b->trivial_symbol_) {
#line 431
    tmp = a->trivial_symbol_;
  } else {
#line 431
    tmp = 4294967295U;
  }
#line 431
  out->trivial_symbol_ = tmp;
#line 432
  return;
}
}
#line 442 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static double HistogramAddEval(VP8LHistogram *a , VP8LHistogram *b , VP8LHistogram *out ,
                               double cost_threshold ) 
{ 
  double cost ;
  double sum_cost ;
  int __cil_tmp7 ;

  {
  {
#line 446
  cost = (double )0;
#line 447
  sum_cost = a->bit_cost_ + b->bit_cost_;
#line 448
  cost_threshold += sum_cost;
#line 450
  __cil_tmp7 = GetCombinedHistogramEntropy(a, b, cost_threshold, & cost);
  }
#line 450
  if (__cil_tmp7) {
    {
#line 451
    HistogramAdd(a, b, out);
#line 452
    out->bit_cost_ = cost;
#line 453
    out->palette_code_bits_ = a->palette_code_bits_;
    }
  }
#line 456
  return (cost - sum_cost);
}
}
#line 462 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static double HistogramAddThresh(VP8LHistogram *a , VP8LHistogram *b , double cost_threshold ) 
{ 
  double cost ;

  {
  {
#line 467
  cost = - a->bit_cost_;
#line 468
  GetCombinedHistogramEntropy(a, b, cost_threshold, & cost);
  }
#line 469
  return (cost);
}
}
#line 487 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void DominantCostRangeInit(DominantCostRange *c ) 
{ 


  {
#line 488
  c->literal_max_ = 0.;
#line 489
  c->literal_min_ = 1e+38;
#line 490
  c->red_max_ = 0.;
#line 491
  c->red_min_ = 1e+38;
#line 492
  c->blue_max_ = 0.;
#line 493
  c->blue_min_ = 1e+38;
#line 494
  return;
}
}
#line 496 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void UpdateDominantCostRange(VP8LHistogram *h , DominantCostRange *c ) 
{ 


  {
#line 498
  if (c->literal_max_ < h->literal_cost_) {
#line 498
    c->literal_max_ = h->literal_cost_;
  }
#line 499
  if (c->literal_min_ > h->literal_cost_) {
#line 499
    c->literal_min_ = h->literal_cost_;
  }
#line 500
  if (c->red_max_ < h->red_cost_) {
#line 500
    c->red_max_ = h->red_cost_;
  }
#line 501
  if (c->red_min_ > h->red_cost_) {
#line 501
    c->red_min_ = h->red_cost_;
  }
#line 502
  if (c->blue_max_ < h->blue_cost_) {
#line 502
    c->blue_max_ = h->blue_cost_;
  }
#line 503
  if (c->blue_min_ > h->blue_cost_) {
#line 503
    c->blue_min_ = h->blue_cost_;
  }
#line 505
  return;
}
}
#line 506 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void UpdateHistogramCost(VP8LHistogram *h ) 
{ 
  uint32_t alpha_sym ;
  uint32_t red_sym ;
  uint32_t blue_sym ;
  double alpha_cost ;
  double __cil_tmp6 ;
  double distance_cost ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;
  int num_codes ;
  int __cil_tmp11 ;
  double __cil_tmp12 ;
  double __cil_tmp13 ;

  {
  {
#line 508
  __cil_tmp6 = PopulationCost(h->alpha_, 256, & alpha_sym, & h->is_used_[3]);
#line 508
  alpha_cost = __cil_tmp6;
#line 511
  __cil_tmp9 = (*VP8LExtraCost)(h->distance_, 40);
#line 511
  __cil_tmp8 = PopulationCost(h->distance_, 40, (uint32_t *)((void *)0), & h->is_used_[4]);
#line 511
  distance_cost = __cil_tmp8 + __cil_tmp9;
#line 514
  __cil_tmp11 = VP8LHistogramNumCodes(h->palette_code_bits_);
#line 514
  num_codes = __cil_tmp11;
#line 515
  __cil_tmp13 = (*VP8LExtraCost)(h->literal_ + 256, 24);
#line 515
  __cil_tmp12 = PopulationCost(h->literal_, num_codes, (uint32_t *)((void *)0), & h->is_used_[0]);
#line 515
  h->literal_cost_ = __cil_tmp12 + __cil_tmp13;
#line 518
  h->red_cost_ = PopulationCost(h->red_, 256, & red_sym, & h->is_used_[1]);
#line 520
  h->blue_cost_ = PopulationCost(h->blue_, 256, & blue_sym, & h->is_used_[2]);
#line 522
  h->bit_cost_ = (((h->literal_cost_ + h->red_cost_) + h->blue_cost_) + alpha_cost) + distance_cost;
  }
#line 524
  if (((alpha_sym | red_sym) | blue_sym) == 4294967295U) {
#line 525
    h->trivial_symbol_ = 4294967295U;
  } else {
#line 527
    h->trivial_symbol_ = ((alpha_sym << 24) | (red_sym << 16)) | blue_sym;
  }
#line 529
  return;
}
}
#line 532 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static int GetBinIdForEntropy(double min , double max , double val ) 
{ 
  double range ;
  double delta ;

  {
#line 533
  range = max - min;
#line 534
  if (range > 0.) {
#line 535
    delta = val - min;
#line 536
    return ((int )((((double )4 - 1e-06) * delta) / range));
  } else {
#line 538
    return (0);
  }
}
}
#line 542 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static int GetHistoBinIndex(VP8LHistogram *h , DominantCostRange *c , int low_effort ) 
{ 
  int bin_id ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 544
  __cil_tmp5 = GetBinIdForEntropy(c->literal_min_, c->literal_max_, h->literal_cost_);
#line 544
  bin_id = __cil_tmp5;
  }
#line 547
  if (! low_effort) {
    {
#line 548
    __cil_tmp6 = GetBinIdForEntropy(c->red_min_, c->red_max_, h->red_cost_);
#line 548
    bin_id = bin_id * 4 + __cil_tmp6;
#line 550
    __cil_tmp7 = GetBinIdForEntropy(c->blue_min_, c->blue_max_, h->blue_cost_);
#line 550
    bin_id = bin_id * 4 + __cil_tmp7;
    }
  }
#line 554
  return (bin_id);
}
}
#line 558 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void HistogramBuild(int xsize , int histo_bits , VP8LBackwardRefs *backward_refs ,
                           VP8LHistogramSet *image_histo ) 
{ 
  int x ;
  int y ;
  int histo_xsize ;
  uint32_t __cil_tmp8 ;
  VP8LHistogram **histograms ;
  VP8LRefsCursor c ;
  VP8LRefsCursor __cil_tmp11 ;
  int __cil_tmp12 ;
  PixOrCopy *v ;
  int ix ;
  uint32_t __cil_tmp15 ;

  {
  {
#line 561
  x = 0;
#line 561
  y = 0;
#line 562
  __cil_tmp8 = VP8LSubSampleSize((uint32_t )xsize, (uint32_t )histo_bits);
#line 562
  histo_xsize = (int )__cil_tmp8;
#line 563
  histograms = image_histo->histograms;
#line 564
  __cil_tmp11 = VP8LRefsCursorInit(backward_refs);
#line 564
  c = __cil_tmp11;
#line 566
  VP8LHistogramSetClear(image_histo);
  }
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 567
    __cil_tmp12 = VP8LRefsCursorOk(& c);
    }
#line 567
    if (! __cil_tmp12) {
#line 567
      goto while_break;
    }
    {
#line 568
    v = c.cur_pos;
#line 569
    ix = (y >> histo_bits) * histo_xsize + (x >> histo_bits);
#line 570
    VP8LHistogramAddSinglePixOrCopy(*(histograms + ix), v, (int (*)(int  , int  ))((void *)0),
                                    0);
#line 571
    __cil_tmp15 = PixOrCopyLength(v);
#line 571
    x = (int )((uint32_t )x + __cil_tmp15);
    }
    {
#line 572
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 572
      if (! (x >= xsize)) {
#line 572
        goto while_break___0;
      }
#line 573
      x -= xsize;
#line 574
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 576
    VP8LRefsCursorNext(& c);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 581
  return;
}
}
#line 581 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static uint16_t kInvalidHistogramSymbol  =    (uint16_t )-1;
#line 582 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void HistogramCopyAndAnalyze(VP8LHistogramSet *orig_histo , VP8LHistogramSet *image_histo ,
                                    int *num_used , uint16_t *histogram_symbols ) 
{ 
  int i ;
  int cluster_id ;
  int num_used_orig ;
  VP8LHistogram **orig_histograms ;
  VP8LHistogram **histograms ;
  VP8LHistogram *histo ;
  int __cil_tmp11 ;

  {
#line 587
  num_used_orig = *num_used;
#line 588
  orig_histograms = orig_histo->histograms;
#line 589
  histograms = image_histo->histograms;
#line 591
  i = 0;
#line 591
  cluster_id = 0;
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;

#line 591
    if (! (i < orig_histo->max_size)) {
#line 591
      goto while_break;
    }
    {
#line 592
    histo = *(orig_histograms + i);
#line 593
    UpdateHistogramCost(histo);
    }
#line 597
    if (! histo->is_used_[0]) {
#line 597
      if (! histo->is_used_[1]) {
#line 597
        if (! histo->is_used_[2]) {
#line 597
          if (! histo->is_used_[3]) {
#line 597
            if (! histo->is_used_[4]) {
              {
#line 603
              HistogramSetRemoveHistogram(image_histo, i, num_used);
#line 604
              HistogramSetRemoveHistogram(orig_histo, i, & num_used_orig);
#line 605
              *(histogram_symbols + i) = kInvalidHistogramSymbol;
              }
            } else {
              {
#line 608
              HistogramCopy(histo, *(histograms + i));
#line 609
              __cil_tmp11 = cluster_id;
#line 609
              cluster_id ++;
#line 609
              *(histogram_symbols + i) = (uint16_t )__cil_tmp11;
              }
            }
          } else {
            {
#line 608
            HistogramCopy(histo, *(histograms + i));
#line 609
            __cil_tmp11 = cluster_id;
#line 609
            cluster_id ++;
#line 609
            *(histogram_symbols + i) = (uint16_t )__cil_tmp11;
            }
          }
        } else {
          {
#line 608
          HistogramCopy(histo, *(histograms + i));
#line 609
          __cil_tmp11 = cluster_id;
#line 609
          cluster_id ++;
#line 609
          *(histogram_symbols + i) = (uint16_t )__cil_tmp11;
          }
        }
      } else {
        {
#line 608
        HistogramCopy(histo, *(histograms + i));
#line 609
        __cil_tmp11 = cluster_id;
#line 609
        cluster_id ++;
#line 609
        *(histogram_symbols + i) = (uint16_t )__cil_tmp11;
        }
      }
    } else {
      {
#line 608
      HistogramCopy(histo, *(histograms + i));
#line 609
      __cil_tmp11 = cluster_id;
#line 609
      cluster_id ++;
#line 609
      *(histogram_symbols + i) = (uint16_t )__cil_tmp11;
      }
    }
#line 591
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 595
  return;
}
}
#line 617 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void HistogramAnalyzeEntropyBin(VP8LHistogramSet *image_histo , uint16_t *bin_map ,
                                       int low_effort ) 
{ 
  int i ;
  VP8LHistogram **histograms ;
  int histo_size ;
  DominantCostRange cost_range ;
  int __cil_tmp8 ;

  {
  {
#line 621
  histograms = image_histo->histograms;
#line 622
  histo_size = image_histo->size;
#line 624
  DominantCostRangeInit(& cost_range);
#line 627
  i = 0;
  }
  {
#line 627
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: ;
#line 627
    if (! (i < histo_size)) {
#line 627
      goto while_break;
    }
#line 628
    if ((unsigned long )*(histograms + i) == (unsigned long )((void *)0)) {
#line 628
      goto while_continue;
    }
    {
#line 629
    UpdateDominantCostRange(*(histograms + i), & cost_range);
#line 627
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 634
  i = 0;
  {
#line 634
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: ;
#line 634
    if (! (i < histo_size)) {
#line 634
      goto while_break___0;
    }
#line 637
    if ((unsigned long )*(histograms + i) == (unsigned long )((void *)0)) {
#line 637
      goto while_continue___0;
    }
    {
#line 638
    __cil_tmp8 = GetHistoBinIndex(*(histograms + i), & cost_range, low_effort);
#line 638
    *(bin_map + i) = (uint16_t )__cil_tmp8;
#line 634
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 638
  return;
}
}
#line 644 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void HistogramCombineEntropyBin(VP8LHistogramSet *image_histo , int *num_used ,
                                       uint16_t *clusters , uint16_t *cluster_mappings ,
                                       VP8LHistogram *cur_combo , uint16_t *bin_map ,
                                       int num_bins , double combine_cost_factor ,
                                       int low_effort ) 
{ 
  VP8LHistogram **histograms ;
  int idx ;
  struct __anonstruct_782 bin_info[64] ;
  int bin_id ;
  int first ;
  double bit_cost ;
  double bit_cost_thresh ;
  double curr_cost_diff ;
  double __cil_tmp18 ;
  int try_combine ;
  int max_combine_failures ;
  int tmp ;

  {
#line 653
  histograms = image_histo->histograms;
#line 662
  idx = 0;
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;

#line 662
    if (! (idx < num_bins)) {
#line 662
      goto while_break;
    }
#line 663
    bin_info[idx].first = (int16_t )-1;
#line 664
    bin_info[idx].num_combine_failures = (uint16_t )0;
#line 662
    idx ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 668
  idx = 0;
  {
#line 668
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 668
    if (! (idx < *num_used)) {
#line 668
      goto while_break___0;
    }
#line 668
    *(cluster_mappings + idx) = (uint16_t )idx;
#line 668
    idx ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
#line 669
  idx = 0;
  {
#line 669
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: ;
#line 669
    if (! (idx < image_histo->size)) {
#line 669
      goto while_break___1;
    }
#line 671
    if ((unsigned long )*(histograms + idx) == (unsigned long )((void *)0)) {
#line 671
      goto while_continue___1;
    }
#line 672
    bin_id = (int )*(bin_map + idx);
#line 673
    first = (int )bin_info[bin_id].first;
#line 674
    if (first == -1) {
#line 675
      bin_info[bin_id].first = (int16_t )idx;
    } else
#line 676
    if (low_effort) {
      {
#line 677
      HistogramAdd(*(histograms + idx), *(histograms + first), *(histograms + first));
#line 678
      HistogramSetRemoveHistogram(image_histo, idx, num_used);
#line 679
      *(cluster_mappings + (int )*(clusters + idx)) = *(clusters + first);
      }
    } else {
      {
#line 682
      bit_cost = (*(histograms + idx))->bit_cost_;
#line 683
      bit_cost_thresh = - bit_cost * combine_cost_factor;
#line 684
      __cil_tmp18 = HistogramAddEval(*(histograms + first), *(histograms + idx), cur_combo,
                                     bit_cost_thresh);
#line 684
      curr_cost_diff = __cil_tmp18;
      }
#line 687
      if (curr_cost_diff < bit_cost_thresh) {
#line 693
        if (cur_combo->trivial_symbol_ != 4294967295U) {
#line 693
          tmp = 1;
        } else
#line 693
        if ((*(histograms + idx))->trivial_symbol_ == 4294967295U) {
#line 693
          if ((*(histograms + first))->trivial_symbol_ == 4294967295U) {
#line 693
            tmp = 1;
          } else {
#line 693
            tmp = 0;
          }
        } else {
#line 693
          tmp = 0;
        }
#line 693
        try_combine = tmp;
#line 697
        max_combine_failures = 32;
#line 698
        if (try_combine) {
          {
#line 701
          HistogramSwap(& cur_combo, histograms + first);
#line 702
          HistogramSetRemoveHistogram(image_histo, idx, num_used);
#line 703
          *(cluster_mappings + (int )*(clusters + idx)) = *(clusters + first);
          }
        } else
#line 698
        if ((int )bin_info[bin_id].num_combine_failures >= max_combine_failures) {
          {
#line 701
          HistogramSwap(& cur_combo, histograms + first);
#line 702
          HistogramSetRemoveHistogram(image_histo, idx, num_used);
#line 703
          *(cluster_mappings + (int )*(clusters + idx)) = *(clusters + first);
          }
        } else {
#line 705
          bin_info[bin_id].num_combine_failures = (uint16_t )((int )bin_info[bin_id].num_combine_failures + 1);
        }
      }
    }
#line 669
    idx ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 710
  if (low_effort) {
#line 712
    idx = 0;
    {
#line 712
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___2: ;
#line 712
      if (! (idx < image_histo->size)) {
#line 712
        goto while_break___2;
      }
#line 713
      if ((unsigned long )*(histograms + idx) == (unsigned long )((void *)0)) {
#line 713
        goto while_continue___2;
      }
      {
#line 714
      UpdateHistogramCost(*(histograms + idx));
#line 712
      idx ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 717
  return;
}
}
#line 721 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static uint32_t MyRand(uint32_t *seed ) 
{ 


  {
#line 722
  *seed = (uint32_t )(((uint64_t )*seed * 48271UL) % 2147483647UL);
#line 724
  return (*seed);
}
}
#line 744 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static int HistoQueueInit(HistoQueue *histo_queue , int max_size ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 745
  histo_queue->size = 0;
#line 746
  histo_queue->max_size = max_size;
#line 749
  __cil_tmp3 = WebPSafeMalloc((uint64_t )(histo_queue->max_size + 1), sizeof(*(histo_queue->queue)));
#line 749
  histo_queue->queue = (HistogramPair *)__cil_tmp3;
  }
#line 751
  return ((unsigned long )histo_queue->queue != (unsigned long )((void *)0));
}
}
#line 754 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void HistoQueueClear(HistoQueue *histo_queue ) 
{ 


  {
  {
#line 756
  WebPSafeFree((void *)histo_queue->queue);
#line 757
  histo_queue->size = 0;
#line 758
  histo_queue->max_size = 0;
  }
#line 760
  return;
}
}
#line 763 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void HistoQueuePopPair(HistoQueue *histo_queue , HistogramPair *pair ) 
{ 


  {
#line 768
  *pair = *(histo_queue->queue + (histo_queue->size - 1));
#line 769
  (histo_queue->size) --;
#line 770
  return;
}
}
#line 773 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void HistoQueueUpdateHead(HistoQueue *histo_queue , HistogramPair *pair ) 
{ 
  HistogramPair tmp ;

  {
#line 779
  if (pair->cost_diff < (histo_queue->queue + 0)->cost_diff) {
#line 781
    tmp = *(histo_queue->queue + 0);
#line 782
    *(histo_queue->queue + 0) = *pair;
#line 783
    *pair = tmp;
  }
#line 785
  return;
}
}
#line 789 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void HistoQueueUpdatePair(VP8LHistogram *h1 , VP8LHistogram *h2 , double threshold ,
                                 HistogramPair *pair ) 
{ 
  double sum_cost ;

  {
  {
#line 793
  sum_cost = h1->bit_cost_ + h2->bit_cost_;
#line 794
  pair->cost_combo = 0.;
#line 795
  GetCombinedHistogramEntropy(h1, h2, sum_cost + threshold, & pair->cost_combo);
#line 796
  pair->cost_diff = pair->cost_combo - sum_cost;
  }
#line 798
  return;
}
}
#line 802 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static double HistoQueuePush(HistoQueue *histo_queue , VP8LHistogram **histograms ,
                             int idx1 , int idx2 , double threshold ) 
{ 
  VP8LHistogram *h1 ;
  VP8LHistogram *h2 ;
  HistogramPair pair ;
  int tmp ;
  int __cil_tmp10 ;

  {
#line 810
  if (histo_queue->size == histo_queue->max_size) {
#line 810
    return (0.);
  }
#line 812
  if (idx1 > idx2) {
#line 813
    tmp = idx2;
#line 814
    idx2 = idx1;
#line 815
    idx1 = tmp;
  }
  {
#line 817
  pair.idx1 = idx1;
#line 818
  pair.idx2 = idx2;
#line 819
  h1 = *(histograms + idx1);
#line 820
  h2 = *(histograms + idx2);
#line 822
  HistoQueueUpdatePair(h1, h2, threshold, & pair);
  }
#line 825
  if (pair.cost_diff >= threshold) {
#line 825
    return (0.);
  }
  {
#line 827
  __cil_tmp10 = histo_queue->size;
#line 827
  (histo_queue->size) ++;
#line 827
  *(histo_queue->queue + __cil_tmp10) = pair;
#line 828
  HistoQueueUpdateHead(histo_queue, histo_queue->queue + (histo_queue->size - 1));
  }
#line 830
  return (pair.cost_diff);
}
}
#line 837 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static int HistogramCombineGreedy(VP8LHistogramSet *image_histo , int *num_used ) 
{ 
  int ok ;
  int image_histo_size ;
  int i ;
  int j ;
  VP8LHistogram **histograms ;
  HistoQueue histo_queue ;
  int __cil_tmp9 ;
  int idx1 ;
  int idx2 ;
  HistogramPair *p ;

  {
  {
#line 839
  ok = 0;
#line 840
  image_histo_size = image_histo->size;
#line 842
  histograms = image_histo->histograms;
#line 853
  __cil_tmp9 = HistoQueueInit(& histo_queue, image_histo_size * image_histo_size);
  }
#line 853
  if (! __cil_tmp9) {
#line 854
    goto End;
  }
#line 857
  i = 0;
  {
#line 857
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: ;
#line 857
    if (! (i < image_histo_size)) {
#line 857
      goto while_break;
    }
#line 858
    if ((unsigned long )*(image_histo->histograms + i) == (unsigned long )((void *)0)) {
#line 858
      goto while_continue;
    }
#line 859
    j = i + 1;
    {
#line 859
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: ;
#line 859
      if (! (j < image_histo_size)) {
#line 859
        goto while_break___0;
      }
#line 861
      if ((unsigned long )*(image_histo->histograms + j) == (unsigned long )((void *)0)) {
#line 861
        goto while_continue___0;
      }
      {
#line 862
      HistoQueuePush(& histo_queue, histograms, i, j, 0.);
#line 859
      j ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 857
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 866
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 866
    if (! (histo_queue.size > 0)) {
#line 866
      goto while_break___1;
    }
    {
#line 867
    idx1 = (histo_queue.queue + 0)->idx1;
#line 868
    idx2 = (histo_queue.queue + 0)->idx2;
#line 869
    HistogramAdd(*(histograms + idx2), *(histograms + idx1), *(histograms + idx1));
#line 870
    (*(histograms + idx1))->bit_cost_ = (histo_queue.queue + 0)->cost_combo;
#line 873
    HistogramSetRemoveHistogram(image_histo, idx2, num_used);
#line 876
    i = 0;
    }
    {
#line 876
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 876
      if (! (i < histo_queue.size)) {
#line 876
        goto while_break___2;
      }
#line 877
      p = histo_queue.queue + i;
#line 878
      if (p->idx1 == idx1) {
        {
#line 880
        HistoQueuePopPair(& histo_queue, p);
        }
      } else
#line 878
      if (p->idx2 == idx1) {
        {
#line 880
        HistoQueuePopPair(& histo_queue, p);
        }
      } else
#line 878
      if (p->idx1 == idx2) {
        {
#line 880
        HistoQueuePopPair(& histo_queue, p);
        }
      } else
#line 878
      if (p->idx2 == idx2) {
        {
#line 880
        HistoQueuePopPair(& histo_queue, p);
        }
      } else {
        {
#line 882
        HistoQueueUpdateHead(& histo_queue, p);
#line 883
        i ++;
        }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 888
    i = 0;
    {
#line 888
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: ;
#line 888
      if (! (i < image_histo->size)) {
#line 888
        goto while_break___3;
      }
#line 889
      if ((unsigned long )*(image_histo->histograms + i) == (unsigned long )((void *)0)) {
#line 889
        goto while_continue___3;
      } else
#line 889
      if (i == idx1) {
#line 889
        goto while_continue___3;
      }
      {
#line 890
      HistoQueuePush(& histo_queue, image_histo->histograms, idx1, i, 0.);
#line 888
      i ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: ;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
#line 894
  ok = 1;
  End: 
  {
#line 897
  HistoQueueClear(& histo_queue);
  }
#line 898
  return (ok);
}
}
#line 904 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static int PairComparison(void const   *idx1 , void const   *idx2 ) 
{ 


  {
#line 906
  return (*((int *)idx1) - *((int *)idx2));
}
}
#line 908 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static int HistogramCombineStochastic(VP8LHistogramSet *image_histo , int *num_used ,
                                      int min_cluster_size , int *do_greedy ) 
{ 
  int j ;
  int iter ;
  uint32_t seed ;
  int tries_with_no_success ;
  int outer_iters ;
  int num_tries_no_success ;
  VP8LHistogram **histograms ;
  HistoQueue histo_queue ;
  int kHistoQueueSize ;
  int ok ;
  int *mappings ;
  void *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int *mapping_index ;
  double best_cost ;
  double tmp ;
  int best_idx1 ;
  int best_idx2 ;
  uint32_t rand_range ;
  int num_tries ;
  double curr_cost ;
  uint32_t tmp___0 ;
  uint32_t __cil_tmp28 ;
  uint32_t idx1 ;
  uint32_t idx2 ;
  void *__cil_tmp32 ;
  HistogramPair *p ;
  int is_idx1_best ;
  int is_idx2_best ;
  int do_eval ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 912
  seed = (uint32_t )1;
#line 913
  tries_with_no_success = 0;
#line 914
  outer_iters = *num_used;
#line 915
  num_tries_no_success = outer_iters / 2;
#line 916
  histograms = image_histo->histograms;
#line 921
  kHistoQueueSize = 9;
#line 922
  ok = 0;
#line 927
  if (*num_used < min_cluster_size) {
#line 928
    *do_greedy = 1;
#line 929
    return (1);
  }
  {
#line 932
  __cil_tmp16 = WebPSafeMalloc((uint64_t )*num_used, sizeof(*mappings));
#line 932
  mappings = (int *)__cil_tmp16;
  }
#line 933
  if ((unsigned long )mappings == (unsigned long )((void *)0)) {
#line 933
    return (0);
  }
  {
#line 934
  __cil_tmp17 = HistoQueueInit(& histo_queue, kHistoQueueSize);
  }
#line 934
  if (! __cil_tmp17) {
#line 934
    goto End;
  }
#line 936
  iter = 0;
#line 936
  j = 0;
  {
#line 936
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: ;
#line 936
    if (! (iter < image_histo->size)) {
#line 936
      goto while_break;
    }
#line 937
    if ((unsigned long )*(histograms + iter) == (unsigned long )((void *)0)) {
#line 937
      goto while_continue;
    }
#line 938
    __cil_tmp18 = j;
#line 938
    j ++;
#line 938
    *(mappings + __cil_tmp18) = iter;
#line 936
    iter ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 943
  iter = 0;
  {
#line 943
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: ;
#line 943
    if (iter < outer_iters) {
#line 943
      if (*num_used >= min_cluster_size) {
#line 943
        if (! (tries_with_no_success < num_tries_no_success)) {
#line 943
          goto while_break___0;
        }
      } else {
#line 943
        goto while_break___0;
      }
    } else {
#line 943
      goto while_break___0;
    }
#line 948
    if (histo_queue.size == 0) {
#line 948
      tmp = 0.;
    } else {
#line 948
      tmp = (histo_queue.queue + 0)->cost_diff;
    }
#line 948
    best_cost = tmp;
#line 950
    best_idx1 = -1;
#line 950
    best_idx2 = 1;
#line 951
    rand_range = (uint32_t )((*num_used - 1) * *num_used);
#line 954
    num_tries = *num_used / 2;
#line 957
    j = 0;
    {
#line 957
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 957
      if (*num_used >= 2) {
#line 957
        if (! (j < num_tries)) {
#line 957
          goto while_break___1;
        }
      } else {
#line 957
        goto while_break___1;
      }
      {
#line 960
      __cil_tmp28 = MyRand(& seed);
#line 960
      tmp___0 = __cil_tmp28 % rand_range;
#line 961
      idx1 = tmp___0 / (unsigned int )(*num_used - 1);
#line 962
      idx2 = tmp___0 % (unsigned int )(*num_used - 1);
      }
#line 963
      if (idx2 >= idx1) {
#line 963
        idx2 ++;
      }
      {
#line 964
      idx1 = (uint32_t )*(mappings + idx1);
#line 965
      idx2 = (uint32_t )*(mappings + idx2);
#line 968
      curr_cost = HistoQueuePush(& histo_queue, histograms, (int )idx1, (int )idx2,
                                 best_cost);
      }
#line 970
      if (curr_cost < (double )0) {
#line 971
        best_cost = curr_cost;
#line 973
        if (histo_queue.size == histo_queue.max_size) {
#line 973
          goto while_break___1;
        }
      }
#line 957
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
#line 976
    if (histo_queue.size == 0) {
#line 976
      goto while_continue___0;
    }
    {
#line 979
    best_idx1 = (histo_queue.queue + 0)->idx1;
#line 980
    best_idx2 = (histo_queue.queue + 0)->idx2;
#line 983
    __cil_tmp32 = bsearch((void const   *)(& best_idx2), (void const   *)mappings,
                          (size_t )*num_used, sizeof(best_idx2), & PairComparison);
#line 983
    mapping_index = (int *)__cil_tmp32;
#line 986
    memmove((void *)mapping_index, (void const   *)(mapping_index + 1), sizeof(*mapping_index) * (unsigned long )(((mapping_index - mappings) - (long )*num_used) - 1L));
#line 989
    HistogramAdd(*(histograms + best_idx2), *(histograms + best_idx1), *(histograms + best_idx1));
#line 991
    (*(histograms + best_idx1))->bit_cost_ = (histo_queue.queue + 0)->cost_combo;
#line 992
    HistogramSetRemoveHistogram(image_histo, best_idx2, num_used);
#line 995
    j = 0;
    }
    {
#line 995
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: ;
#line 995
      if (! (j < histo_queue.size)) {
#line 995
        goto while_break___2;
      }
#line 996
      p = histo_queue.queue + j;
#line 997
      if (p->idx1 == best_idx1) {
#line 997
        tmp___2 = 1;
      } else
#line 997
      if (p->idx1 == best_idx2) {
#line 997
        tmp___2 = 1;
      } else {
#line 997
        tmp___2 = 0;
      }
#line 997
      is_idx1_best = tmp___2;
#line 998
      if (p->idx2 == best_idx1) {
#line 998
        tmp___3 = 1;
      } else
#line 998
      if (p->idx2 == best_idx2) {
#line 998
        tmp___3 = 1;
      } else {
#line 998
        tmp___3 = 0;
      }
#line 998
      is_idx2_best = tmp___3;
#line 999
      do_eval = 0;
#line 1002
      if (is_idx1_best) {
#line 1002
        if (is_idx2_best) {
          {
#line 1003
          HistoQueuePopPair(& histo_queue, p);
          }
#line 1004
          goto while_continue___2;
        }
      }
#line 1008
      if (is_idx1_best) {
#line 1009
        p->idx1 = best_idx1;
#line 1010
        do_eval = 1;
      } else
#line 1011
      if (is_idx2_best) {
#line 1012
        p->idx2 = best_idx1;
#line 1013
        do_eval = 1;
      }
#line 1016
      if (p->idx1 > p->idx2) {
#line 1017
        tmp___1 = p->idx2;
#line 1018
        p->idx2 = p->idx1;
#line 1019
        p->idx1 = tmp___1;
      }
#line 1021
      if (do_eval) {
        {
#line 1023
        HistoQueueUpdatePair(*(histograms + p->idx1), *(histograms + p->idx2), 0.,
                             p);
        }
#line 1024
        if (p->cost_diff >= 0.) {
          {
#line 1025
          HistoQueuePopPair(& histo_queue, p);
          }
#line 1026
          goto while_continue___2;
        }
      }
      {
#line 1029
      HistoQueueUpdateHead(& histo_queue, p);
#line 1030
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 1032
    tries_with_no_success = 0;
#line 946
    iter ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
#line 1034
  *do_greedy = *num_used <= min_cluster_size;
#line 1035
  ok = 1;
  End: 
  {
#line 1038
  HistoQueueClear(& histo_queue);
#line 1039
  WebPSafeFree((void *)mappings);
  }
#line 1040
  return (ok);
}
}
#line 1049 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void HistogramRemap(VP8LHistogramSet *in , VP8LHistogramSet *out , uint16_t *symbols ) 
{ 
  int i ;
  VP8LHistogram **in_histo ;
  VP8LHistogram **out_histo ;
  int in_size ;
  int out_size ;
  int best_out ;
  double best_bits ;
  int k ;
  double cur_bits ;
  int idx ;

  {
#line 1053
  in_histo = in->histograms;
#line 1054
  out_histo = out->histograms;
#line 1055
  in_size = out->max_size;
#line 1056
  out_size = out->size;
#line 1057
  if (out_size > 1) {
#line 1058
    i = 0;
    {
#line 1058
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: ;
#line 1058
      if (! (i < in_size)) {
#line 1058
        goto while_break;
      }
#line 1059
      best_out = 0;
#line 1060
      best_bits = 1e+38;
#line 1062
      if ((unsigned long )*(in_histo + i) == (unsigned long )((void *)0)) {
#line 1064
        *(symbols + i) = *(symbols + (i - 1));
#line 1065
        goto while_continue;
      }
#line 1067
      k = 0;
      {
#line 1067
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1067
        if (! (k < out_size)) {
#line 1067
          goto while_break___0;
        }
        {
#line 1069
        cur_bits = HistogramAddThresh(*(out_histo + k), *(in_histo + i), best_bits);
        }
#line 1070
        if (k == 0) {
#line 1071
          best_bits = cur_bits;
#line 1072
          best_out = k;
        } else
#line 1070
        if (cur_bits < best_bits) {
#line 1071
          best_bits = cur_bits;
#line 1072
          best_out = k;
        }
#line 1067
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: 
#line 1075
      *(symbols + i) = (uint16_t )best_out;
#line 1058
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 1079
    i = 0;
    {
#line 1079
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 1079
      if (! (i < in_size)) {
#line 1079
        goto while_break___1;
      }
#line 1080
      *(symbols + i) = (uint16_t )0;
#line 1079
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
  {
#line 1085
  VP8LHistogramSetClear(out);
#line 1086
  out->size = out_size;
#line 1088
  i = 0;
  }
  {
#line 1088
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: ;
#line 1088
    if (! (i < in_size)) {
#line 1088
      goto while_break___2;
    }
#line 1090
    if ((unsigned long )*(in_histo + i) == (unsigned long )((void *)0)) {
#line 1090
      goto while_continue___2;
    }
    {
#line 1091
    idx = (int )*(symbols + i);
#line 1092
    HistogramAdd(*(in_histo + i), *(out_histo + idx), *(out_histo + idx));
#line 1088
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 1092
  return;
}
}
#line 1096 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static double GetCombineCostFactor(int histo_size , int quality ) 
{ 
  double combine_cost_factor ;

  {
#line 1097
  combine_cost_factor = 0.160000000001;
#line 1098
  if (quality < 90) {
#line 1099
    if (histo_size > 256) {
#line 1099
      combine_cost_factor /= 2.;
    }
#line 1100
    if (histo_size > 512) {
#line 1100
      combine_cost_factor /= 2.;
    }
#line 1101
    if (histo_size > 1024) {
#line 1101
      combine_cost_factor /= 2.;
    }
#line 1102
    if (quality <= 50) {
#line 1102
      combine_cost_factor /= 2.;
    }
  }
#line 1104
  return (combine_cost_factor);
}
}
#line 1110 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void OptimizeHistogramSymbols(VP8LHistogramSet *set , uint16_t *cluster_mappings ,
                                     int num_clusters , uint16_t *cluster_mappings_tmp ,
                                     uint16_t *symbols ) 
{ 
  int i ;
  int cluster_max ;
  int do_continue ;
  int k ;
  int cluster ;

  {
#line 1116
  do_continue = 1;
  {
#line 1118
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1118
    if (! do_continue) {
#line 1118
      goto while_break;
    }
#line 1119
    do_continue = 0;
#line 1120
    i = 0;
    {
#line 1120
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 1120
      if (! (i < num_clusters)) {
#line 1120
        goto while_break___0;
      }
#line 1122
      k = (int )*(cluster_mappings + i);
      {
#line 1123
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 1123
        if (! (k != (int )*(cluster_mappings + k))) {
#line 1123
          goto while_break___1;
        }
#line 1124
        *(cluster_mappings + k) = *(cluster_mappings + (int )*(cluster_mappings + k));
#line 1125
        k = (int )*(cluster_mappings + k);
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: ;
#line 1127
      if (k != (int )*(cluster_mappings + i)) {
#line 1128
        do_continue = 1;
#line 1129
        *(cluster_mappings + i) = (uint16_t )k;
      }
#line 1120
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1134
  cluster_max = 0;
#line 1135
  memset((void *)cluster_mappings_tmp, 0, (unsigned long )set->max_size * sizeof(*cluster_mappings_tmp));
#line 1139
  i = 0;
  }
  {
#line 1139
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: ;
#line 1139
    if (! (i < set->max_size)) {
#line 1139
      goto while_break___2;
    }
#line 1141
    if ((int )*(symbols + i) == (int )kInvalidHistogramSymbol) {
#line 1141
      goto while_continue___2;
    }
#line 1142
    cluster = (int )*(cluster_mappings + (int )*(symbols + i));
#line 1144
    if (cluster > 0) {
#line 1144
      if ((int )*(cluster_mappings_tmp + cluster) == 0) {
#line 1145
        cluster_max ++;
#line 1146
        *(cluster_mappings_tmp + cluster) = (uint16_t )cluster_max;
      }
    }
#line 1148
    *(symbols + i) = *(cluster_mappings_tmp + cluster);
#line 1139
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: 
#line 1152
  cluster_max = 0;
#line 1153
  i = 0;
  {
#line 1153
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___3: ;
#line 1153
    if (! (i < set->max_size)) {
#line 1153
      goto while_break___3;
    }
#line 1154
    if ((int )*(symbols + i) == (int )kInvalidHistogramSymbol) {
#line 1154
      goto while_continue___3;
    }
#line 1155
    if ((int )*(symbols + i) <= cluster_max) {
#line 1155
      goto while_continue___3;
    }
#line 1156
    cluster_max ++;
#line 1153
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: ;
#line 1157
  return;
}
}
#line 1161 "/root/patron-new/new_3/src/enc/histogram_enc.c"
static void RemoveEmptyHistograms(VP8LHistogramSet *image_histo ) 
{ 
  uint32_t size ;
  int i ;
  uint32_t __cil_tmp4 ;

  {
#line 1164
  size = (uint32_t )0;
#line 1164
  i = 0;
  {
#line 1164
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1164
    if (! (i < image_histo->size)) {
#line 1164
      goto while_break;
    }
#line 1165
    if ((unsigned long )*(image_histo->histograms + i) == (unsigned long )((void *)0)) {
#line 1165
      goto while_continue;
    }
#line 1166
    __cil_tmp4 = size;
#line 1166
    size ++;
#line 1166
    *(image_histo->histograms + __cil_tmp4) = *(image_histo->histograms + i);
#line 1164
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1168
  image_histo->size = (int )size;
#line 1169
  return;
}
}
#line 1171 "/root/patron-new/new_3/src/enc/histogram_enc.c"
int VP8LGetHistoImageSymbols(int xsize , int ysize , VP8LBackwardRefs *refs , int quality ,
                             int low_effort , int histogram_bits , int cache_bits ,
                             VP8LHistogramSet *image_histo , VP8LHistogram *tmp_histo ,
                             uint16_t *histogram_symbols ) 
{ 
  int ok ;
  int histo_xsize ;
  uint32_t __cil_tmp13 ;
  uint32_t tmp ;
  int histo_ysize ;
  uint32_t __cil_tmp16 ;
  uint32_t tmp___0 ;
  int image_histo_raw_size ;
  VP8LHistogramSet *orig_histo ;
  VP8LHistogramSet *__cil_tmp20 ;
  int entropy_combine_num_bins ;
  int tmp___1 ;
  int entropy_combine ;
  uint16_t *map_tmp ;
  void *__cil_tmp25 ;
  uint16_t *cluster_mappings ;
  int num_used ;
  uint16_t *bin_map ;
  double combine_cost_factor ;
  double __cil_tmp30 ;
  uint32_t num_clusters ;
  float x ;
  int threshold_size ;
  int do_greedy ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int tmp___2 ;

  {
#line 1178
  ok = 0;
#line 1179
  if (histogram_bits) {
    {
#line 1179
    __cil_tmp13 = VP8LSubSampleSize((uint32_t )xsize, (uint32_t )histogram_bits);
#line 1179
    tmp = __cil_tmp13;
    }
  } else {
#line 1179
    tmp = 1U;
  }
#line 1179
  histo_xsize = (int )tmp;
#line 1181
  if (histogram_bits) {
    {
#line 1181
    __cil_tmp16 = VP8LSubSampleSize((uint32_t )ysize, (uint32_t )histogram_bits);
#line 1181
    tmp___0 = __cil_tmp16;
    }
  } else {
#line 1181
    tmp___0 = 1U;
  }
  {
#line 1181
  histo_ysize = (int )tmp___0;
#line 1183
  image_histo_raw_size = histo_xsize * histo_ysize;
#line 1184
  __cil_tmp20 = VP8LAllocateHistogramSet(image_histo_raw_size, cache_bits);
#line 1184
  orig_histo = __cil_tmp20;
  }
#line 1189
  if (low_effort) {
#line 1189
    tmp___1 = 4;
  } else {
#line 1189
    tmp___1 = 64;
  }
  {
#line 1189
  entropy_combine_num_bins = tmp___1;
#line 1191
  __cil_tmp25 = WebPSafeMalloc((uint64_t )(2 * image_histo_raw_size), sizeof(map_tmp));
#line 1191
  map_tmp = (uint16_t *)__cil_tmp25;
#line 1193
  cluster_mappings = map_tmp + image_histo_raw_size;
#line 1194
  num_used = image_histo_raw_size;
  }
#line 1195
  if ((unsigned long )orig_histo == (unsigned long )((void *)0)) {
#line 1195
    goto Error;
  } else
#line 1195
  if ((unsigned long )map_tmp == (unsigned long )((void *)0)) {
#line 1195
    goto Error;
  }
  {
#line 1198
  HistogramBuild(xsize, histogram_bits, refs, orig_histo);
#line 1201
  HistogramCopyAndAnalyze(orig_histo, image_histo, & num_used, histogram_symbols);
  }
#line 1204
  if (num_used > entropy_combine_num_bins * 2) {
#line 1204
    if (quality < 100) {
#line 1204
      tmp___2 = 1;
    } else {
#line 1204
      tmp___2 = 0;
    }
  } else {
#line 1204
    tmp___2 = 0;
  }
#line 1204
  entropy_combine = tmp___2;
#line 1207
  if (entropy_combine) {
    {
#line 1208
    bin_map = map_tmp;
#line 1209
    __cil_tmp30 = GetCombineCostFactor(image_histo_raw_size, quality);
#line 1209
    combine_cost_factor = __cil_tmp30;
#line 1211
    num_clusters = (uint32_t )num_used;
#line 1213
    HistogramAnalyzeEntropyBin(image_histo, bin_map, low_effort);
#line 1215
    HistogramCombineEntropyBin(image_histo, & num_used, histogram_symbols, cluster_mappings,
                               tmp_histo, bin_map, entropy_combine_num_bins, combine_cost_factor,
                               low_effort);
#line 1219
    OptimizeHistogramSymbols(image_histo, cluster_mappings, (int )num_clusters, map_tmp,
                             histogram_symbols);
    }
  }
#line 1225
  if (! low_effort) {
    _L: 
    {
#line 1226
    x = (float )quality / 100.f;
#line 1228
    threshold_size = (int )((float )1 + ((x * x) * x) * (float )99);
#line 1230
    __cil_tmp35 = HistogramCombineStochastic(image_histo, & num_used, threshold_size,
                                             & do_greedy);
    }
#line 1230
    if (! __cil_tmp35) {
#line 1232
      goto Error;
    }
#line 1234
    if (do_greedy) {
      {
#line 1235
      RemoveEmptyHistograms(image_histo);
#line 1236
      __cil_tmp36 = HistogramCombineGreedy(image_histo, & num_used);
      }
#line 1236
      if (! __cil_tmp36) {
#line 1237
        goto Error;
      }
    }
  } else
#line 1225
  if (! entropy_combine) {
#line 1225
    goto _L;
  }
  {
#line 1243
  RemoveEmptyHistograms(image_histo);
#line 1244
  HistogramRemap(orig_histo, image_histo, histogram_symbols);
#line 1246
  ok = 1;
  }
  Error: 
  {
#line 1249
  VP8LFreeHistogramSet(orig_histo);
#line 1250
  WebPSafeFree((void *)map_tmp);
  }
#line 1251
  return (ok);
}
}
#line 34 "/root/patron-new/new_3/src/enc/frame_enc.c"
static float Clamp(float v , float min , float max ) 
{ 
  float tmp ;
  float tmp___0 ;

  {
#line 35
  if (v < min) {
#line 35
    tmp___0 = min;
  } else {
#line 35
    if (v > max) {
#line 35
      tmp = max;
    } else {
#line 35
      tmp = v;
    }
#line 35
    tmp___0 = tmp;
  }
#line 35
  return (tmp___0);
}
}
#line 48 "/root/patron-new/new_3/src/enc/frame_enc.c"
static int InitPassStats(VP8Encoder *enc , PassStats *s ) 
{ 
  uint64_t target_size ;
  int do_size_search ;
  float target_PSNR ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 49
  target_size = (uint64_t )(enc->config_)->target_size;
#line 50
  do_size_search = target_size != 0UL;
#line 51
  target_PSNR = (enc->config_)->target_PSNR;
#line 53
  s->is_first = 1;
#line 54
  s->dq = 10.f;
#line 55
  s->qmin = 1.f * (float )(enc->config_)->qmin;
#line 56
  s->qmax = 1.f * (float )(enc->config_)->qmax;
#line 57
  s->q = Clamp((enc->config_)->quality, s->qmin, s->qmax);
  }
#line 58
  if (do_size_search) {
#line 58
    tmp___0 = (double )target_size;
  } else {
#line 58
    if ((double )target_PSNR > 0.) {
#line 58
      tmp = (double )target_PSNR;
    } else {
#line 58
      tmp = 40.;
    }
#line 58
    tmp___0 = tmp;
  }
#line 58
  s->target = tmp___0;
#line 61
  s->last_value = 0.;
#line 61
  s->value = s->last_value;
#line 62
  s->do_size_search = do_size_search;
#line 63
  return (do_size_search);
}
}
#line 66 "/root/patron-new/new_3/src/enc/frame_enc.c"
static float ComputeNextQ(PassStats *s ) 
{ 
  float dq ;
  float tmp ;
  double slope ;

  {
#line 68
  if (s->is_first) {
#line 69
    if (s->value > s->target) {
#line 69
      tmp = - s->dq;
    } else {
#line 69
      tmp = s->dq;
    }
#line 69
    dq = tmp;
#line 70
    s->is_first = 0;
  } else
#line 71
  if (s->value != s->last_value) {
#line 72
    slope = (s->target - s->value) / (s->last_value - s->value);
#line 73
    dq = (float )(slope * (double )(s->last_q - s->q));
  } else {
#line 75
    dq = (float )0.;
  }
  {
#line 78
  s->dq = Clamp(dq, - 30.f, 30.f);
#line 79
  s->last_q = s->q;
#line 80
  s->last_value = s->value;
#line 81
  s->q = Clamp(s->q + s->dq, s->qmin, s->qmax);
  }
#line 82
  return (s->q);
}
}
#line 88 "/root/patron-new/new_3/src/enc/frame_enc.c"
uint8_t VP8Cat3[3]  = {      (uint8_t )173,      (uint8_t )148,      (uint8_t )140};
#line 89 "/root/patron-new/new_3/src/enc/frame_enc.c"
uint8_t VP8Cat4[4]  = {      (uint8_t )176,      (uint8_t )155,      (uint8_t )140,      (uint8_t )135};
#line 90 "/root/patron-new/new_3/src/enc/frame_enc.c"
uint8_t VP8Cat5[5]  = {      (uint8_t )180,      (uint8_t )157,      (uint8_t )141,      (uint8_t )134, 
        (uint8_t )130};
#line 91 "/root/patron-new/new_3/src/enc/frame_enc.c"
uint8_t VP8Cat6[11]  = 
#line 91
  {      (uint8_t )254,      (uint8_t )254,      (uint8_t )243,      (uint8_t )230, 
        (uint8_t )196,      (uint8_t )177,      (uint8_t )153,      (uint8_t )140, 
        (uint8_t )133,      (uint8_t )130,      (uint8_t )129};
#line 97 "/root/patron-new/new_3/src/enc/frame_enc.c"
static void ResetStats(VP8Encoder *enc ) 
{ 
  VP8EncProba *proba ;

  {
  {
#line 98
  proba = & enc->proba_;
#line 99
  VP8CalculateLevelCosts(proba);
#line 100
  proba->nb_skip_ = 0;
  }
#line 102
  return;
}
}
#line 108 "/root/patron-new/new_3/src/enc/frame_enc.c"
static int CalcSkipProba(uint64_t nb , uint64_t total ) 
{ 
  uint64_t tmp ;

  {
#line 109
  if (total) {
#line 109
    tmp = ((total - nb) * 255UL) / total;
  } else {
#line 109
    tmp = 255UL;
  }
#line 109
  return ((int )tmp);
}
}
#line 113 "/root/patron-new/new_3/src/enc/frame_enc.c"
static int FinalizeSkipProba(VP8Encoder *enc ) 
{ 
  VP8EncProba *proba ;
  int nb_mbs ;
  int nb_events ;
  int size ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 114
  proba = & enc->proba_;
#line 115
  nb_mbs = enc->mb_w_ * enc->mb_h_;
#line 116
  nb_events = proba->nb_skip_;
#line 118
  __cil_tmp6 = CalcSkipProba((uint64_t )nb_events, (uint64_t )nb_mbs);
#line 118
  proba->skip_proba_ = (uint8_t )__cil_tmp6;
#line 119
  proba->use_skip_proba_ = (int )proba->skip_proba_ < 250;
#line 120
  size = 256;
  }
#line 121
  if (proba->use_skip_proba_) {
    {
#line 122
    __cil_tmp8 = VP8BitCost(0, proba->skip_proba_);
#line 122
    __cil_tmp7 = VP8BitCost(1, proba->skip_proba_);
#line 122
    size += nb_events * __cil_tmp7 + (nb_mbs - nb_events) * __cil_tmp8;
#line 124
    size += 2048;
    }
  }
#line 126
  return (size);
}
}
#line 131 "/root/patron-new/new_3/src/enc/frame_enc.c"
static int CalcTokenProba(int nb , int total ) 
{ 
  int tmp ;

  {
#line 133
  if (nb) {
#line 133
    tmp = 255 - (nb * 255) / total;
  } else {
#line 133
    tmp = 255;
  }
#line 133
  return (tmp);
}
}
#line 137 "/root/patron-new/new_3/src/enc/frame_enc.c"
static int BranchCost(int nb , int total , int proba ) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 138
  __cil_tmp5 = VP8BitCost(0, (uint8_t )proba);
#line 138
  __cil_tmp4 = VP8BitCost(1, (uint8_t )proba);
  }
#line 138
  return (nb * __cil_tmp4 + (total - nb) * __cil_tmp5);
}
}
#line 141 "/root/patron-new/new_3/src/enc/frame_enc.c"
static void ResetTokenStats(VP8Encoder *enc ) 
{ 
  VP8EncProba *proba ;

  {
  {
#line 142
  proba = & enc->proba_;
#line 143
  memset((void *)(proba->stats_), 0, sizeof(proba->stats_));
  }
#line 145
  return;
}
}
#line 146 "/root/patron-new/new_3/src/enc/frame_enc.c"
static int FinalizeTokenProbas(VP8EncProba *proba ) 
{ 
  int has_changed ;
  int size ;
  int t ;
  int b ;
  int c ;
  int p ;
  proba_t stats ;
  int nb ;
  int total ;
  int update_proba ;
  int old_p ;
  int new_p ;
  int __cil_tmp14 ;
  int old_cost ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int new_cost ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int use_new_p ;
  int __cil_tmp22 ;

  {
#line 147
  has_changed = 0;
#line 148
  size = 0;
#line 150
  t = 0;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;

#line 150
    if (! (t < 4)) {
#line 150
      goto while_break;
    }
#line 151
    b = 0;
    {
#line 151
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 151
      if (! (b < 8)) {
#line 151
        goto while_break___0;
      }
#line 152
      c = 0;
      {
#line 152
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 152
        if (! (c < 3)) {
#line 152
          goto while_break___1;
        }
#line 153
        p = 0;
        {
#line 153
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 153
          if (! (p < 11)) {
#line 153
            goto while_break___2;
          }
          {
#line 154
          stats = proba->stats_[t][b][c][p];
#line 155
          nb = (int )(stats & 65535U);
#line 156
          total = (int )((stats >> 16) & 65535U);
#line 157
          update_proba = (int )VP8CoeffsUpdateProba[t][b][c][p];
#line 158
          old_p = (int )VP8CoeffsProba0[t][b][c][p];
#line 159
          __cil_tmp14 = CalcTokenProba(nb, total);
#line 159
          new_p = __cil_tmp14;
#line 160
          __cil_tmp17 = VP8BitCost(0, (uint8_t )update_proba);
#line 160
          __cil_tmp16 = BranchCost(nb, total, old_p);
#line 160
          old_cost = __cil_tmp16 + __cil_tmp17;
#line 162
          __cil_tmp20 = VP8BitCost(1, (uint8_t )update_proba);
#line 162
          __cil_tmp19 = BranchCost(nb, total, new_p);
#line 162
          new_cost = (__cil_tmp19 + __cil_tmp20) + 2048;
#line 165
          use_new_p = old_cost > new_cost;
#line 166
          __cil_tmp22 = VP8BitCost(use_new_p, (uint8_t )update_proba);
#line 166
          size += __cil_tmp22;
          }
#line 167
          if (use_new_p) {
#line 168
            proba->coeffs_[t][b][c][p] = (uint8_t )new_p;
#line 169
            has_changed |= new_p != old_p;
#line 170
            size += 2048;
          } else {
#line 172
            proba->coeffs_[t][b][c][p] = (uint8_t )old_p;
          }
#line 153
          p ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 152
        c ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 151
      b ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 150
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 178
  proba->dirty_ = has_changed;
#line 179
  return (size);
}
}
#line 185 "/root/patron-new/new_3/src/enc/frame_enc.c"
static int GetProba(int a , int b ) 
{ 
  int total ;
  int tmp ;

  {
#line 186
  total = a + b;
#line 187
  if (total == 0) {
#line 187
    tmp = 255;
  } else {
#line 187
    tmp = (255 * a + total / 2) / total;
  }
#line 187
  return (tmp);
}
}
#line 191 "/root/patron-new/new_3/src/enc/frame_enc.c"
static void ResetSegments(VP8Encoder *enc ) 
{ 
  int n ;

  {
#line 193
  n = 0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;

#line 193
    if (! (n < enc->mb_w_ * enc->mb_h_)) {
#line 193
      goto while_break;
    }
#line 194
    (enc->mb_info_ + n)->segment_ = 0U;
#line 193
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 197
  return;
}
}
#line 198 "/root/patron-new/new_3/src/enc/frame_enc.c"
static void SetSegmentProbas(VP8Encoder *enc ) 
{ 
  int p[4] ;
  unsigned int tmp ;
  int n ;
  VP8MBInfo *mb ;
  uint8_t *probas ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp___0 ;

  {
#line 199
  p[0] = 0;
#line 199
  tmp = 1U;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;

#line 199
    if (tmp >= 4U) {
#line 199
      goto while_break;
    }
#line 199
    p[tmp] = 0;
#line 199
    tmp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 202
  n = 0;
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 202
    if (! (n < enc->mb_w_ * enc->mb_h_)) {
#line 202
      goto while_break___0;
    }
#line 203
    mb = enc->mb_info_ + n;
#line 204
    (p[mb->segment_]) ++;
#line 202
    n ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 207
  if ((unsigned long )(enc->pic_)->stats != (unsigned long )((void *)0)) {
#line 208
    n = 0;
    {
#line 208
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 208
      if (! (n < 4)) {
#line 208
        goto while_break___1;
      }
#line 209
      ((enc->pic_)->stats)->segment_size[n] = p[n];
#line 208
      n ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 213
  if (enc->segment_hdr_.num_segments_ > 1) {
    {
#line 214
    probas = enc->proba_.segments_;
#line 215
    __cil_tmp7 = GetProba(p[0] + p[1], p[2] + p[3]);
#line 215
    *(probas + 0) = (uint8_t )__cil_tmp7;
#line 216
    __cil_tmp8 = GetProba(p[0], p[1]);
#line 216
    *(probas + 1) = (uint8_t )__cil_tmp8;
#line 217
    __cil_tmp9 = GetProba(p[2], p[3]);
#line 217
    *(probas + 2) = (uint8_t )__cil_tmp9;
    }
#line 219
    if ((int )*(probas + 0) != 255) {
#line 219
      tmp___0 = 1;
    } else
#line 219
    if ((int )*(probas + 1) != 255) {
#line 219
      tmp___0 = 1;
    } else
#line 219
    if ((int )*(probas + 2) != 255) {
#line 219
      tmp___0 = 1;
    } else {
#line 219
      tmp___0 = 0;
    }
#line 219
    enc->segment_hdr_.update_map_ = tmp___0;
#line 221
    if (! enc->segment_hdr_.update_map_) {
      {
#line 221
      ResetSegments(enc);
      }
    }
    {
#line 222
    __cil_tmp17 = VP8BitCost(1, *(probas + 2));
#line 222
    __cil_tmp16 = VP8BitCost(1, *(probas + 0));
#line 222
    __cil_tmp15 = VP8BitCost(0, *(probas + 2));
#line 222
    __cil_tmp14 = VP8BitCost(1, *(probas + 0));
#line 222
    __cil_tmp13 = VP8BitCost(1, *(probas + 1));
#line 222
    __cil_tmp12 = VP8BitCost(0, *(probas + 0));
#line 222
    __cil_tmp11 = VP8BitCost(0, *(probas + 1));
#line 222
    __cil_tmp10 = VP8BitCost(0, *(probas + 0));
#line 222
    enc->segment_hdr_.size_ = ((p[0] * (__cil_tmp10 + __cil_tmp11) + p[1] * (__cil_tmp12 + __cil_tmp13)) + p[2] * (__cil_tmp14 + __cil_tmp15)) + p[3] * (__cil_tmp16 + __cil_tmp17);
    }
  } else {
#line 228
    enc->segment_hdr_.update_map_ = 0;
#line 229
    enc->segment_hdr_.size_ = 0;
  }
#line 231
  return;
}
}
#line 236 "/root/patron-new/new_3/src/enc/frame_enc.c"
static int PutCoeffs(VP8BitWriter *bw , int ctx , VP8Residual *res ) 
{ 
  int n ;
  uint8_t *p ;
  int __cil_tmp6 ;
  int c ;
  int __cil_tmp8 ;
  int sign ;
  int v ;
  int tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int mask ;
  uint8_t *tab ;
  uint8_t *__cil_tmp20 ;
  int __cil_tmp21 ;

  {
  {
#line 237
  n = res->first;
#line 239
  p = (*(res->prob + n))[ctx];
#line 240
  __cil_tmp6 = VP8PutBit(bw, res->last >= 0, (int )*(p + 0));
  }
#line 240
  if (! __cil_tmp6) {
#line 241
    return (0);
  }
  {
#line 244
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 244
    if (! (n < 16)) {
#line 244
      goto while_break;
    }
#line 245
    __cil_tmp8 = n;
#line 245
    n ++;
#line 245
    c = (int )*(res->coeffs + __cil_tmp8);
#line 246
    sign = c < 0;
#line 247
    if (sign) {
#line 247
      tmp = - c;
    } else {
#line 247
      tmp = c;
    }
    {
#line 247
    v = tmp;
#line 248
    __cil_tmp12 = VP8PutBit(bw, v != 0, (int )*(p + 1));
    }
#line 248
    if (! __cil_tmp12) {
#line 249
      p = (*(res->prob + (int )VP8EncBands[n]))[0];
#line 250
      goto while_continue;
    }
    {
#line 252
    __cil_tmp13 = VP8PutBit(bw, v > 1, (int )*(p + 2));
    }
#line 252
    if (! __cil_tmp13) {
#line 253
      p = (*(res->prob + (int )VP8EncBands[n]))[1];
    } else {
      {
#line 255
      __cil_tmp14 = VP8PutBit(bw, v > 4, (int )*(p + 3));
      }
#line 255
      if (! __cil_tmp14) {
        {
#line 256
        __cil_tmp15 = VP8PutBit(bw, v != 2, (int )*(p + 4));
        }
#line 256
        if (__cil_tmp15) {
          {
#line 257
          VP8PutBit(bw, v == 4, (int )*(p + 5));
          }
        }
      } else {
        {
#line 259
        __cil_tmp16 = VP8PutBit(bw, v > 10, (int )*(p + 6));
        }
#line 259
        if (! __cil_tmp16) {
          {
#line 260
          __cil_tmp17 = VP8PutBit(bw, v > 6, (int )*(p + 7));
          }
#line 260
          if (! __cil_tmp17) {
            {
#line 261
            VP8PutBit(bw, v == 6, 159);
            }
          } else {
            {
#line 263
            VP8PutBit(bw, v >= 9, 165);
#line 264
            VP8PutBit(bw, ! (v & 1), 145);
            }
          }
        } else {
#line 269
          if (v < 3 + (8 << 1)) {
            {
#line 270
            VP8PutBit(bw, 0, (int )*(p + 8));
#line 271
            VP8PutBit(bw, 0, (int )*(p + 9));
#line 272
            v -= 11;
#line 273
            mask = 1 << 2;
#line 274
            tab = VP8Cat3;
            }
          } else
#line 275
          if (v < 3 + (8 << 2)) {
            {
#line 276
            VP8PutBit(bw, 0, (int )*(p + 8));
#line 277
            VP8PutBit(bw, 1, (int )*(p + 9));
#line 278
            v -= 3 + (8 << 1);
#line 279
            mask = 1 << 3;
#line 280
            tab = VP8Cat4;
            }
          } else
#line 281
          if (v < 3 + (8 << 3)) {
            {
#line 282
            VP8PutBit(bw, 1, (int )*(p + 8));
#line 283
            VP8PutBit(bw, 0, (int )*(p + 10));
#line 284
            v -= 3 + (8 << 2);
#line 285
            mask = 1 << 4;
#line 286
            tab = VP8Cat5;
            }
          } else {
            {
#line 288
            VP8PutBit(bw, 1, (int )*(p + 8));
#line 289
            VP8PutBit(bw, 1, (int )*(p + 10));
#line 290
            v -= 3 + (8 << 3);
#line 291
            mask = 1 << 10;
#line 292
            tab = VP8Cat6;
            }
          }
          {
#line 294
          while (1) {
            while_continue___1: /* CIL Label */ ;

#line 294
            if (! mask) {
#line 294
              goto while_break___0;
            }
            {
#line 295
            __cil_tmp20 = tab;
#line 295
            tab ++;
#line 295
            VP8PutBit(bw, ! (! (v & mask)), (int )*__cil_tmp20);
#line 296
            mask >>= 1;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          while_break___0: ;
        }
      }
#line 299
      p = (*(res->prob + (int )VP8EncBands[n]))[2];
    }
    {
#line 301
    VP8PutBitUniform(bw, sign);
#line 302
    __cil_tmp21 = VP8PutBit(bw, n <= res->last, (int )*(p + 0));
    }
#line 302
    if (n == 16) {
#line 303
      return (1);
    } else
#line 302
    if (! __cil_tmp21) {
#line 303
      return (1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 306
  return (1);
}
}
#line 309 "/root/patron-new/new_3/src/enc/frame_enc.c"
static void CodeResiduals(VP8BitWriter *bw , VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  int x ;
  int y ;
  int ch ;
  VP8Residual res ;
  uint64_t pos1 ;
  uint64_t pos2 ;
  uint64_t pos3 ;
  int i16 ;
  int segment ;
  VP8Encoder *enc ;
  int ctx ;
  int ctx___0 ;

  {
  {
#line 314
  i16 = (int )(it->mb_)->type_ == 1;
#line 315
  segment = (int )(it->mb_)->segment_;
#line 316
  enc = it->enc_;
#line 318
  VP8IteratorNzToBytes(it);
#line 320
  pos1 = VP8BitWriterPos(bw);
  }
#line 321
  if (i16) {
    {
#line 322
    VP8InitResidual(0, 1, enc, & res);
#line 323
    (*VP8SetResidualCoeffs)((int16_t */* const  */)(rd->y_dc_levels), (struct VP8Residual */* const  */)(& res));
#line 324
    it->top_nz_[8] = PutCoeffs(bw, it->top_nz_[8] + it->left_nz_[8], & res);
#line 326
    VP8InitResidual(1, 0, enc, & res);
    }
  } else {
    {
#line 328
    VP8InitResidual(0, 3, enc, & res);
    }
  }
#line 332
  y = 0;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;

#line 332
    if (! (y < 4)) {
#line 332
      goto while_break;
    }
#line 333
    x = 0;
    {
#line 333
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 333
      if (! (x < 4)) {
#line 333
        goto while_break___0;
      }
      {
#line 334
      ctx = it->top_nz_[x] + it->left_nz_[y];
#line 335
      (*VP8SetResidualCoeffs)((int16_t */* const  */)(rd->y_ac_levels[x + y * 4]),
                              (struct VP8Residual */* const  */)(& res));
#line 336
      it->top_nz_[x] = PutCoeffs(bw, ctx, & res);
#line 333
      x ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 332
    y ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 339
  pos2 = VP8BitWriterPos(bw);
#line 342
  VP8InitResidual(0, 2, enc, & res);
#line 343
  ch = 0;
  }
  {
#line 343
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 343
    if (! (ch <= 2)) {
#line 343
      goto while_break___1;
    }
#line 344
    y = 0;
    {
#line 344
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 344
      if (! (y < 2)) {
#line 344
        goto while_break___2;
      }
#line 345
      x = 0;
      {
#line 345
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 345
        if (! (x < 2)) {
#line 345
          goto while_break___3;
        }
        {
#line 346
        ctx___0 = it->top_nz_[(4 + ch) + x] + it->left_nz_[(4 + ch) + y];
#line 347
        (*VP8SetResidualCoeffs)((int16_t */* const  */)(rd->uv_levels[(ch * 2 + x) + y * 2]),
                                (struct VP8Residual */* const  */)(& res));
#line 348
        it->top_nz_[(4 + ch) + x] = PutCoeffs(bw, ctx___0, & res);
#line 345
        x ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 344
      y ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 343
    ch += 2;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 353
  pos3 = VP8BitWriterPos(bw);
#line 354
  it->luma_bits_ = pos2 - pos1;
#line 355
  it->uv_bits_ = pos3 - pos2;
#line 356
  it->bit_count_[segment][i16] += it->luma_bits_;
#line 357
  it->bit_count_[segment][2] += it->uv_bits_;
#line 358
  VP8IteratorBytesToNz(it);
  }
#line 360
  return;
}
}
#line 363 "/root/patron-new/new_3/src/enc/frame_enc.c"
static void RecordResiduals(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  int x ;
  int y ;
  int ch ;
  VP8Residual res ;
  VP8Encoder *enc ;
  int ctx ;
  int ctx___0 ;

  {
  {
#line 367
  enc = it->enc_;
#line 369
  VP8IteratorNzToBytes(it);
  }
#line 371
  if ((int )(it->mb_)->type_ == 1) {
    {
#line 372
    VP8InitResidual(0, 1, enc, & res);
#line 373
    (*VP8SetResidualCoeffs)((int16_t */* const  */)(rd->y_dc_levels), (struct VP8Residual */* const  */)(& res));
#line 374
    it->top_nz_[8] = VP8RecordCoeffs(it->top_nz_[8] + it->left_nz_[8], & res);
#line 376
    VP8InitResidual(1, 0, enc, & res);
    }
  } else {
    {
#line 378
    VP8InitResidual(0, 3, enc, & res);
    }
  }
#line 382
  y = 0;
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;

#line 382
    if (! (y < 4)) {
#line 382
      goto while_break;
    }
#line 383
    x = 0;
    {
#line 383
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 383
      if (! (x < 4)) {
#line 383
        goto while_break___0;
      }
      {
#line 384
      ctx = it->top_nz_[x] + it->left_nz_[y];
#line 385
      (*VP8SetResidualCoeffs)((int16_t */* const  */)(rd->y_ac_levels[x + y * 4]),
                              (struct VP8Residual */* const  */)(& res));
#line 386
      it->top_nz_[x] = VP8RecordCoeffs(ctx, & res);
#line 383
      x ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 382
    y ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 391
  VP8InitResidual(0, 2, enc, & res);
#line 392
  ch = 0;
  }
  {
#line 392
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 392
    if (! (ch <= 2)) {
#line 392
      goto while_break___1;
    }
#line 393
    y = 0;
    {
#line 393
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 393
      if (! (y < 2)) {
#line 393
        goto while_break___2;
      }
#line 394
      x = 0;
      {
#line 394
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 394
        if (! (x < 2)) {
#line 394
          goto while_break___3;
        }
        {
#line 395
        ctx___0 = it->top_nz_[(4 + ch) + x] + it->left_nz_[(4 + ch) + y];
#line 396
        (*VP8SetResidualCoeffs)((int16_t */* const  */)(rd->uv_levels[(ch * 2 + x) + y * 2]),
                                (struct VP8Residual */* const  */)(& res));
#line 397
        it->top_nz_[(4 + ch) + x] = VP8RecordCoeffs(ctx___0, & res);
#line 394
        x ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 393
      y ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 392
    ch += 2;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 403
  VP8IteratorBytesToNz(it);
  }
#line 405
  return;
}
}
#line 411 "/root/patron-new/new_3/src/enc/frame_enc.c"
static int RecordTokens(VP8EncIterator *it , VP8ModeScore *rd , VP8TBuffer *tokens ) 
{ 
  int x ;
  int y ;
  int ch ;
  VP8Residual res ;
  VP8Encoder *enc ;
  int ctx ;
  int ctx___0 ;
  int ctx___1 ;

  {
  {
#line 415
  enc = it->enc_;
#line 417
  VP8IteratorNzToBytes(it);
  }
#line 418
  if ((int )(it->mb_)->type_ == 1) {
    {
#line 419
    ctx = it->top_nz_[8] + it->left_nz_[8];
#line 420
    VP8InitResidual(0, 1, enc, & res);
#line 421
    (*VP8SetResidualCoeffs)((int16_t */* const  */)(rd->y_dc_levels), (struct VP8Residual */* const  */)(& res));
#line 422
    it->top_nz_[8] = VP8RecordCoeffTokens(ctx, & res, tokens);
#line 424
    VP8InitResidual(1, 0, enc, & res);
    }
  } else {
    {
#line 426
    VP8InitResidual(0, 3, enc, & res);
    }
  }
#line 430
  y = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;

#line 430
    if (! (y < 4)) {
#line 430
      goto while_break;
    }
#line 431
    x = 0;
    {
#line 431
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 431
      if (! (x < 4)) {
#line 431
        goto while_break___0;
      }
      {
#line 432
      ctx___0 = it->top_nz_[x] + it->left_nz_[y];
#line 433
      (*VP8SetResidualCoeffs)((int16_t */* const  */)(rd->y_ac_levels[x + y * 4]),
                              (struct VP8Residual */* const  */)(& res));
#line 434
      it->top_nz_[x] = VP8RecordCoeffTokens(ctx___0, & res, tokens);
#line 431
      x ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 430
    y ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 440
  VP8InitResidual(0, 2, enc, & res);
#line 441
  ch = 0;
  }
  {
#line 441
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 441
    if (! (ch <= 2)) {
#line 441
      goto while_break___1;
    }
#line 442
    y = 0;
    {
#line 442
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 442
      if (! (y < 2)) {
#line 442
        goto while_break___2;
      }
#line 443
      x = 0;
      {
#line 443
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 443
        if (! (x < 2)) {
#line 443
          goto while_break___3;
        }
        {
#line 444
        ctx___1 = it->top_nz_[(4 + ch) + x] + it->left_nz_[(4 + ch) + y];
#line 445
        (*VP8SetResidualCoeffs)((int16_t */* const  */)(rd->uv_levels[(ch * 2 + x) + y * 2]),
                                (struct VP8Residual */* const  */)(& res));
#line 446
        it->top_nz_[(4 + ch) + x] = VP8RecordCoeffTokens(ctx___1, & res, tokens);
#line 443
        x ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 442
      y ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 441
    ch += 2;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 451
  VP8IteratorBytesToNz(it);
  }
#line 452
  return (! tokens->error_);
}
}
#line 472 "/root/patron-new/new_3/src/enc/frame_enc.c"
static void ResetSSE(VP8Encoder *enc ) 
{ 


  {
#line 473
  enc->sse_[0] = (uint64_t )0;
#line 474
  enc->sse_[1] = (uint64_t )0;
#line 475
  enc->sse_[2] = (uint64_t )0;
#line 477
  enc->sse_count_ = (uint64_t )0;
#line 478
  return;
}
}
#line 480 "/root/patron-new/new_3/src/enc/frame_enc.c"
static void StoreSSE(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  uint8_t *in ;
  uint8_t *out ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 481
  enc = it->enc_;
#line 482
  in = it->yuv_in_;
#line 483
  out = it->yuv_out_;
#line 485
  __cil_tmp5 = (*VP8SSE16x16)(in + 0, out + 0);
#line 485
  enc->sse_[0] += (unsigned long )__cil_tmp5;
#line 486
  __cil_tmp6 = (*VP8SSE8x8)(in + 16, out + 16);
#line 486
  enc->sse_[1] += (unsigned long )__cil_tmp6;
#line 487
  __cil_tmp7 = (*VP8SSE8x8)(in + 24, out + 24);
#line 487
  enc->sse_[2] += (unsigned long )__cil_tmp7;
#line 488
  enc->sse_count_ += 256UL;
  }
#line 489
  return;
}
}
#line 491 "/root/patron-new/new_3/src/enc/frame_enc.c"
static void StoreSideInfo(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  VP8MBInfo *mb ;
  WebPPicture *pic ;
  uint8_t *info ;
  int tmp ;
  int b ;
  int tmp___0 ;

  {
#line 492
  enc = it->enc_;
#line 493
  mb = it->mb_;
#line 494
  pic = enc->pic_;
#line 496
  if ((unsigned long )pic->stats != (unsigned long )((void *)0)) {
    {
#line 497
    StoreSSE(it);
#line 498
    enc->block_count_[0] += (int )mb->type_ == 0;
#line 499
    enc->block_count_[1] += (int )mb->type_ == 1;
#line 500
    enc->block_count_[2] += (int )mb->skip_ != 0;
    }
  }
#line 503
  if ((unsigned long )pic->extra_info != (unsigned long )((void *)0)) {
#line 504
    info = pic->extra_info + (it->x_ + it->y_ * enc->mb_w_);
#line 506
    if (pic->extra_info_type == 1) {
#line 506
      goto case_1;
    }
#line 507
    if (pic->extra_info_type == 2) {
#line 507
      goto case_2;
    }
#line 508
    if (pic->extra_info_type == 3) {
#line 508
      goto case_3;
    }
#line 509
    if (pic->extra_info_type == 4) {
#line 509
      goto case_4;
    }
#line 510
    if (pic->extra_info_type == 5) {
#line 510
      goto case_5;
    }
#line 511
    if (pic->extra_info_type == 6) {
#line 511
      goto case_6;
    }
#line 515
    if (pic->extra_info_type == 7) {
#line 515
      goto case_7;
    }
#line 516
    goto switch_default;
    case_1: 
#line 506
    *info = (uint8_t )mb->type_;
#line 506
    goto switch_break;
    case_2: 
#line 507
    *info = (uint8_t )mb->segment_;
#line 507
    goto switch_break;
    case_3: 
#line 508
    *info = (uint8_t )enc->dqm_[mb->segment_].quant_;
#line 508
    goto switch_break;
    case_4: 
#line 509
    if ((int )mb->type_ == 1) {
#line 509
      tmp = (int )*(it->preds_ + 0);
    } else {
#line 509
      tmp = 255;
    }
#line 509
    *info = (uint8_t )tmp;
#line 509
    goto switch_break;
    case_5: 
#line 510
    *info = (uint8_t )mb->uv_mode_;
#line 510
    goto switch_break;
    case_6: 
#line 512
    b = (int )(((it->luma_bits_ + it->uv_bits_) + 7UL) >> 3);
#line 513
    if (b > 255) {
#line 513
      tmp___0 = 255;
    } else {
#line 513
      tmp___0 = b;
    }
#line 513
    *info = (uint8_t )tmp___0;
#line 513
    goto switch_break;
    case_7: 
#line 515
    *info = mb->alpha_;
#line 515
    goto switch_break;
    switch_default: 
#line 516
    *info = (uint8_t )0;
#line 516
    goto switch_break;
    switch_break: ;
  }
#line 520
  return;
}
}
#line 526 "/root/patron-new/new_3/src/enc/frame_enc.c"
static void ResetSideInfo(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  WebPPicture *pic ;

  {
#line 527
  enc = it->enc_;
#line 528
  pic = enc->pic_;
#line 529
  if ((unsigned long )pic->stats != (unsigned long )((void *)0)) {
    {
#line 530
    memset((void *)(enc->block_count_), 0, sizeof(enc->block_count_));
    }
  }
  {
#line 532
  ResetSSE(enc);
  }
#line 534
  return;
}
}
#line 554 "/root/patron-new/new_3/src/enc/frame_enc.c"
static double GetPSNR___1(uint64_t mse , uint64_t size ) 
{ 
  double __cil_tmp3 ;
  double tmp ;

  {
#line 555
  if (mse > 0UL) {
#line 555
    if (size > 0UL) {
      {
#line 555
      __cil_tmp3 = log10(((255. * 255.) * (double )size) / (double )mse);
#line 555
      tmp = 10. * __cil_tmp3;
      }
    } else {
#line 555
      tmp = (double )99;
    }
  } else {
#line 555
    tmp = (double )99;
  }
#line 555
  return (tmp);
}
}
#line 563 "/root/patron-new/new_3/src/enc/frame_enc.c"
static void SetLoopParams(VP8Encoder *enc , float q ) 
{ 


  {
  {
#line 565
  q = Clamp(q, 0.f, 100.f);
#line 567
  VP8SetSegmentParams(enc, q);
#line 568
  SetSegmentProbas(enc);
#line 570
  ResetStats(enc);
#line 571
  ResetSSE(enc);
  }
#line 573
  return;
}
}
#line 574 "/root/patron-new/new_3/src/enc/frame_enc.c"
static uint64_t OneStatPass(VP8Encoder *enc , VP8RDLevel rd_opt , int nb_mbs , int percent_delta ,
                            PassStats *s ) 
{ 
  VP8EncIterator it ;
  uint64_t size ;
  uint64_t size_p0 ;
  uint64_t distortion ;
  uint64_t pixel_count ;
  int __cil_tmp11 ;
  VP8ModeScore info ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 578
  size = (uint64_t )0;
#line 579
  size_p0 = (uint64_t )0;
#line 580
  distortion = (uint64_t )0;
#line 581
  pixel_count = (uint64_t )(nb_mbs * 384);
#line 583
  VP8IteratorInit(enc, & it);
#line 584
  SetLoopParams(enc, s->q);
  }
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 587
    VP8IteratorImport(& it, (uint8_t *)((void *)0));
#line 588
    __cil_tmp13 = VP8Decimate(& it, & info, rd_opt);
    }
#line 588
    if (__cil_tmp13) {
#line 590
      (enc->proba_.nb_skip_) ++;
    }
    {
#line 592
    RecordResiduals(& it, & info);
#line 593
    size += (unsigned long )(info.R + info.H);
#line 594
    size_p0 += (unsigned long )info.H;
#line 595
    distortion += (unsigned long )info.D;
#line 596
    __cil_tmp14 = VP8IteratorProgress(& it, percent_delta);
    }
#line 596
    if (percent_delta) {
#line 596
      if (! __cil_tmp14) {
#line 597
        return ((uint64_t )0);
      }
    }
    {
#line 599
    VP8IteratorSaveBoundary(& it);
    }
#line 585
    if (__cil_tmp11) {
#line 585
      if (! (nb_mbs > 0)) {
#line 585
        goto while_break;
      }
    } else {
#line 585
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 602
  size_p0 += (unsigned long )enc->segment_hdr_.size_;
#line 603
  if (s->do_size_search) {
    {
#line 604
    __cil_tmp15 = FinalizeSkipProba(enc);
#line 604
    size += (unsigned long )__cil_tmp15;
#line 605
    __cil_tmp16 = FinalizeTokenProbas(& enc->proba_);
#line 605
    size += (unsigned long )__cil_tmp16;
#line 606
    size = (((size + size_p0) + 1024UL) >> 11) + 30UL;
#line 607
    s->value = (double )size;
    }
  } else {
    {
#line 609
    s->value = GetPSNR___1(distortion, pixel_count);
    }
  }
#line 611
  return (size_p0);
}
}
#line 614 "/root/patron-new/new_3/src/enc/frame_enc.c"
static int StatLoop(VP8Encoder *enc ) 
{ 
  int method ;
  int do_search ;
  int fast_probe ;
  int num_pass_left ;
  int task_percent ;
  int percent_per_pass ;
  int final_percent ;
  VP8RDLevel rd_opt ;
  int tmp ;
  int nb_mbs ;
  PassStats stats ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp15 ;
  int is_last_pass ;
  double __cil_tmp17 ;
  uint64_t size_p0 ;
  uint64_t __cil_tmp19 ;
  double __cil_tmp20 ;
  int __cil_tmp21 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 615
  method = enc->method_;
#line 616
  do_search = enc->do_search_;
#line 617
  if (method == 0) {
#line 617
    goto _L___17;
  } else
#line 617
  if (method == 3) {
    _L___17: /* CIL Label */ 
#line 617
    if (! do_search) {
#line 617
      tmp___2 = 1;
    } else {
#line 617
      tmp___2 = 0;
    }
  } else {
#line 617
    tmp___2 = 0;
  }
#line 617
  fast_probe = tmp___2;
#line 618
  num_pass_left = (enc->config_)->pass;
#line 619
  task_percent = 20;
#line 620
  percent_per_pass = (task_percent + num_pass_left / 2) / num_pass_left;
#line 622
  final_percent = enc->percent_ + task_percent;
#line 623
  if (method >= 3) {
#line 623
    tmp = 1;
  } else
#line 623
  if (do_search) {
#line 623
    tmp = 1;
  } else {
#line 623
    tmp = 0;
  }
  {
#line 623
  rd_opt = (VP8RDLevel )tmp;
#line 625
  nb_mbs = enc->mb_w_ * enc->mb_h_;
#line 628
  InitPassStats(enc, & stats);
#line 629
  ResetTokenStats(enc);
  }
#line 632
  if (fast_probe) {
#line 633
    if (method == 3) {
#line 634
      if (nb_mbs > 200) {
#line 634
        tmp___0 = nb_mbs >> 1;
      } else {
#line 634
        tmp___0 = 100;
      }
#line 634
      nb_mbs = tmp___0;
    } else {
#line 636
      if (nb_mbs > 200) {
#line 636
        tmp___1 = nb_mbs >> 2;
      } else {
#line 636
        tmp___1 = 50;
      }
#line 636
      nb_mbs = tmp___1;
    }
  }
  {
#line 640
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 640
    __cil_tmp15 = num_pass_left;
#line 640
    num_pass_left --;
#line 640
    if (! (__cil_tmp15 > 0)) {
#line 640
      goto while_break;
    }
    {
#line 641
    __cil_tmp17 = fabs((double )stats.dq);
    }
#line 641
    if (__cil_tmp17 <= 0.400000000001) {
#line 641
      tmp___3 = 1;
    } else
#line 641
    if (num_pass_left == 0) {
#line 641
      tmp___3 = 1;
    } else
#line 641
    if (enc->max_i4_header_bits_ == 0) {
#line 641
      tmp___3 = 1;
    } else {
#line 641
      tmp___3 = 0;
    }
    {
#line 641
    is_last_pass = tmp___3;
#line 644
    __cil_tmp19 = OneStatPass(enc, rd_opt, nb_mbs, percent_per_pass, & stats);
#line 644
    size_p0 = __cil_tmp19;
    }
#line 646
    if (size_p0 == 0UL) {
#line 646
      return (0);
    }
#line 651
    if (enc->max_i4_header_bits_ > 0) {
#line 651
      if ((unsigned long long )size_p0 > ((unsigned long long )(1 << 19) - 2048ULL) << 11) {
#line 652
        num_pass_left ++;
#line 653
        enc->max_i4_header_bits_ >>= 1;
#line 654
        goto while_continue;
      }
    }
#line 656
    if (is_last_pass) {
#line 657
      goto while_break;
    }
#line 660
    if (do_search) {
      {
#line 661
      ComputeNextQ(& stats);
#line 662
      __cil_tmp20 = fabs((double )stats.dq);
      }
#line 662
      if (__cil_tmp20 <= 0.400000000001) {
#line 662
        goto while_break;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 665
  if (! do_search) {
    {
#line 667
    FinalizeSkipProba(enc);
#line 668
    FinalizeTokenProbas(& enc->proba_);
    }
  } else
#line 665
  if (! stats.do_size_search) {
    {
#line 667
    FinalizeSkipProba(enc);
#line 668
    FinalizeTokenProbas(& enc->proba_);
    }
  }
  {
#line 670
  VP8CalculateLevelCosts(& enc->proba_);
#line 671
  __cil_tmp21 = WebPReportProgress(enc->pic_, final_percent, & enc->percent_);
  }
#line 671
  return (__cil_tmp21);
}
}
#line 678 "/root/patron-new/new_3/src/enc/frame_enc.c"
static uint8_t kAverageBytesPerMB[8]  = 
#line 678
  {      (uint8_t )50,      (uint8_t )24,      (uint8_t )16,      (uint8_t )9, 
        (uint8_t )7,      (uint8_t )5,      (uint8_t )3,      (uint8_t )2};
#line 680 "/root/patron-new/new_3/src/enc/frame_enc.c"
static int PreLoopInitialize(VP8Encoder *enc ) 
{ 
  int p ;
  int ok ;
  int average_bytes_per_MB ;
  int bytes_per_parts ;

  {
#line 682
  ok = 1;
#line 683
  average_bytes_per_MB = (int )kAverageBytesPerMB[enc->base_quant_ >> 4];
#line 684
  bytes_per_parts = ((enc->mb_w_ * enc->mb_h_) * average_bytes_per_MB) / enc->num_parts_;
#line 687
  p = 0;
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;

#line 687
    if (ok) {
#line 687
      if (! (p < enc->num_parts_)) {
#line 687
        goto while_break;
      }
    } else {
#line 687
      goto while_break;
    }
    {
#line 688
    ok = VP8BitWriterInit(enc->parts_ + p, (size_t )bytes_per_parts);
#line 687
    p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 690
  if (! ok) {
    {
#line 691
    VP8EncFreeBitWriters(enc);
#line 692
    WebPEncodingSetError(enc->pic_, (WebPEncodingError )1);
    }
  }
#line 694
  return (ok);
}
}
#line 697 "/root/patron-new/new_3/src/enc/frame_enc.c"
static int PostLoopFinalize(VP8EncIterator *it , int ok ) 
{ 
  VP8Encoder *enc ;
  int p ;
  int i ;
  int s ;

  {
#line 698
  enc = it->enc_;
#line 699
  if (ok) {
#line 701
    p = 0;
    {
#line 701
    while (1) {
      while_continue: /* CIL Label */ ;

#line 701
      if (! (p < enc->num_parts_)) {
#line 701
        goto while_break;
      }
      {
#line 702
      VP8BitWriterFinish(enc->parts_ + p);
#line 703
      ok &= ! enc->parts_[p].error_;
#line 701
      p ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 707
  if (ok) {
#line 709
    if ((unsigned long )(enc->pic_)->stats != (unsigned long )((void *)0)) {
#line 711
      i = 0;
      {
#line 711
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 711
        if (! (i <= 2)) {
#line 711
          goto while_break___0;
        }
#line 712
        s = 0;
        {
#line 712
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 712
          if (! (s < 4)) {
#line 712
            goto while_break___1;
          }
#line 713
          enc->residual_bytes_[i][s] = (int )((it->bit_count_[s][i] + 7UL) >> 3);
#line 712
          s ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: 
#line 711
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    }
    {
#line 718
    VP8AdjustFilterStrength(it);
    }
  } else {
    {
#line 721
    VP8EncFreeBitWriters(enc);
    }
  }
#line 723
  return (ok);
}
}
#line 729 "/root/patron-new/new_3/src/enc/frame_enc.c"
static void ResetAfterSkip(VP8EncIterator *it ) 
{ 


  {
#line 730
  if ((int )(it->mb_)->type_ == 1) {
#line 731
    *(it->nz_) = (uint32_t )0;
#line 732
    it->left_nz_[8] = 0;
  } else {
#line 734
    *(it->nz_) &= (unsigned int )(1 << 24);
  }
#line 736
  return;
}
}
#line 738 "/root/patron-new/new_3/src/enc/frame_enc.c"
int VP8EncLoop(VP8Encoder *enc ) 
{ 
  VP8EncIterator it ;
  int ok ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  VP8ModeScore info ;
  int dont_use_skip ;
  VP8RDLevel rd_opt ;
  int __cil_tmp9 ;
  int __cil_tmp11 ;

  {
  {
#line 740
  __cil_tmp4 = PreLoopInitialize(enc);
#line 740
  ok = __cil_tmp4;
  }
#line 741
  if (! ok) {
#line 741
    return (0);
  }
  {
#line 743
  StatLoop(enc);
#line 745
  VP8IteratorInit(enc, & it);
#line 746
  VP8InitFilter(& it);
  }
  {
#line 747
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 749
    dont_use_skip = ! enc->proba_.use_skip_proba_;
#line 750
    rd_opt = enc->rd_opt_level_;
#line 752
    VP8IteratorImport(& it, (uint8_t *)((void *)0));
#line 755
    __cil_tmp9 = VP8Decimate(& it, & info, rd_opt);
    }
#line 755
    if (! __cil_tmp9) {
      {
#line 756
      CodeResiduals(it.bw_, & it, & info);
      }
    } else
#line 755
    if (dont_use_skip) {
      {
#line 756
      CodeResiduals(it.bw_, & it, & info);
      }
    } else {
      {
#line 758
      ResetAfterSkip(& it);
      }
    }
    {
#line 760
    StoreSideInfo(& it);
#line 761
    VP8StoreFilterStats(& it);
#line 762
    VP8IteratorExport(& it);
#line 763
    ok = VP8IteratorProgress(& it, 20);
#line 764
    VP8IteratorSaveBoundary(& it);
    }
#line 747
    if (ok) {
#line 747
      if (! __cil_tmp5) {
#line 747
        goto while_break;
      }
    } else {
#line 747
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 767
  __cil_tmp11 = PostLoopFinalize(& it, ok);
  }
#line 767
  return (__cil_tmp11);
}
}
#line 777 "/root/patron-new/new_3/src/enc/frame_enc.c"
int VP8EncTokenLoop(VP8Encoder *enc ) 
{ 
  int max_count ;
  int num_pass_left ;
  int do_search ;
  VP8EncIterator it ;
  VP8EncProba *proba ;
  VP8RDLevel rd_opt ;
  uint64_t pixel_count ;
  PassStats stats ;
  int ok ;
  int __cil_tmp12 ;
  int is_last_pass ;
  double __cil_tmp14 ;
  uint64_t size_p0 ;
  uint64_t distortion ;
  int cnt ;
  int __cil_tmp18 ;
  VP8ModeScore info ;
  uint64_t size ;
  int __cil_tmp23 ;
  size_t __cil_tmp24 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 779
  max_count = enc->mb_w_ * enc->mb_h_ >> 3;
#line 780
  num_pass_left = (enc->config_)->pass;
#line 781
  do_search = enc->do_search_;
#line 783
  proba = & enc->proba_;
#line 784
  rd_opt = enc->rd_opt_level_;
#line 785
  pixel_count = (uint64_t )((enc->mb_w_ * enc->mb_h_) * 384);
#line 789
  InitPassStats(enc, & stats);
#line 790
  ok = PreLoopInitialize(enc);
  }
#line 791
  if (! ok) {
#line 791
    return (0);
  }
#line 793
  if (max_count < 96) {
#line 793
    max_count = 96;
  }
  {
#line 801
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 801
    __cil_tmp12 = num_pass_left;
#line 801
    num_pass_left --;
#line 801
    if (ok) {
#line 801
      if (! (__cil_tmp12 > 0)) {
#line 801
        goto while_break;
      }
    } else {
#line 801
      goto while_break;
    }
    {
#line 802
    __cil_tmp14 = fabs((double )stats.dq);
    }
#line 802
    if (__cil_tmp14 <= 0.400000000001) {
#line 802
      tmp = 1;
    } else
#line 802
    if (num_pass_left == 0) {
#line 802
      tmp = 1;
    } else
#line 802
    if (enc->max_i4_header_bits_ == 0) {
#line 802
      tmp = 1;
    } else {
#line 802
      tmp = 0;
    }
    {
#line 802
    is_last_pass = tmp;
#line 805
    size_p0 = (uint64_t )0;
#line 806
    distortion = (uint64_t )0;
#line 807
    cnt = max_count;
#line 808
    VP8IteratorInit(enc, & it);
#line 809
    SetLoopParams(enc, stats.q);
    }
#line 810
    if (is_last_pass) {
      {
#line 811
      ResetTokenStats(enc);
#line 812
      VP8InitFilter(& it);
      }
    }
    {
#line 814
    VP8TBufferClear(& enc->tokens_);
    }
    {
#line 815
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 817
      VP8IteratorImport(& it, (uint8_t *)((void *)0));
#line 818
      cnt --;
      }
#line 818
      if (cnt < 0) {
        {
#line 819
        FinalizeTokenProbas(proba);
#line 820
        VP8CalculateLevelCosts(proba);
#line 821
        cnt = max_count;
        }
      }
      {
#line 823
      VP8Decimate(& it, & info, rd_opt);
#line 824
      ok = RecordTokens(& it, & info, & enc->tokens_);
      }
#line 825
      if (! ok) {
        {
#line 826
        WebPEncodingSetError(enc->pic_, (WebPEncodingError )1);
        }
#line 827
        goto while_break___0;
      }
#line 829
      size_p0 += (unsigned long )info.H;
#line 830
      distortion += (unsigned long )info.D;
#line 831
      if (is_last_pass) {
        {
#line 832
        StoreSideInfo(& it);
#line 833
        VP8StoreFilterStats(& it);
#line 834
        VP8IteratorExport(& it);
#line 835
        ok = VP8IteratorProgress(& it, 20);
        }
      }
      {
#line 837
      VP8IteratorSaveBoundary(& it);
      }
#line 815
      if (ok) {
#line 815
        if (! __cil_tmp18) {
#line 815
          goto while_break___0;
        }
      } else {
#line 815
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 839
    if (! ok) {
#line 839
      goto while_break;
    }
#line 841
    size_p0 += (unsigned long )enc->segment_hdr_.size_;
#line 842
    if (stats.do_size_search) {
      {
#line 843
      __cil_tmp23 = FinalizeTokenProbas(& enc->proba_);
#line 843
      size = (uint64_t )__cil_tmp23;
#line 844
      __cil_tmp24 = VP8EstimateTokenSize(& enc->tokens_, (uint8_t *)(proba->coeffs_));
#line 844
      size += __cil_tmp24;
#line 846
      size = ((size + size_p0) + 1024UL) >> 11;
#line 847
      size += 30UL;
#line 848
      stats.value = (double )size;
      }
    } else {
      {
#line 850
      stats.value = GetPSNR___1(distortion, pixel_count);
      }
    }
#line 859
    if (enc->max_i4_header_bits_ > 0) {
#line 859
      if ((unsigned long long )size_p0 > ((unsigned long long )(1 << 19) - 2048ULL) << 11) {
#line 860
        num_pass_left ++;
#line 861
        enc->max_i4_header_bits_ >>= 1;
#line 862
        if (is_last_pass) {
          {
#line 863
          ResetSideInfo(& it);
          }
        }
#line 865
        goto while_continue;
      }
    }
#line 867
    if (is_last_pass) {
#line 868
      goto while_break;
    }
#line 870
    if (do_search) {
      {
#line 871
      ComputeNextQ(& stats);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 874
  if (ok) {
#line 875
    if (! stats.do_size_search) {
      {
#line 876
      FinalizeTokenProbas(& enc->proba_);
      }
    }
    {
#line 878
    ok = VP8EmitTokens(& enc->tokens_, enc->parts_ + 0, (uint8_t *)(proba->coeffs_),
                       1);
    }
  }
  {
#line 881
  __cil_tmp27 = WebPReportProgress(enc->pic_, enc->percent_ + 20, & enc->percent_);
  }
#line 881
  if (ok) {
#line 881
    if (__cil_tmp27) {
#line 881
      tmp___0 = 1;
    } else {
#line 881
      tmp___0 = 0;
    }
  } else {
#line 881
    tmp___0 = 0;
  }
  {
#line 881
  ok = tmp___0;
#line 882
  __cil_tmp28 = PostLoopFinalize(& it, ok);
  }
#line 882
  return (__cil_tmp28);
}
}
#line 24 "/root/patron-new/new_3/src/enc/filter_enc.c"
static uint8_t kLevelsFromDelta[8][64]  = 
#line 24 "/root/patron-new/new_3/src/enc/filter_enc.c"
  { {        (uint8_t )0,        (uint8_t )1,        (uint8_t )2,        (uint8_t )3, 
            (uint8_t )4,        (uint8_t )5,        (uint8_t )6,        (uint8_t )7, 
            (uint8_t )8,        (uint8_t )9,        (uint8_t )10,        (uint8_t )11, 
            (uint8_t )12,        (uint8_t )13,        (uint8_t )14,        (uint8_t )15, 
            (uint8_t )16,        (uint8_t )17,        (uint8_t )18,        (uint8_t )19, 
            (uint8_t )20,        (uint8_t )21,        (uint8_t )22,        (uint8_t )23, 
            (uint8_t )24,        (uint8_t )25,        (uint8_t )26,        (uint8_t )27, 
            (uint8_t )28,        (uint8_t )29,        (uint8_t )30,        (uint8_t )31, 
            (uint8_t )32,        (uint8_t )33,        (uint8_t )34,        (uint8_t )35, 
            (uint8_t )36,        (uint8_t )37,        (uint8_t )38,        (uint8_t )39, 
            (uint8_t )40,        (uint8_t )41,        (uint8_t )42,        (uint8_t )43, 
            (uint8_t )44,        (uint8_t )45,        (uint8_t )46,        (uint8_t )47, 
            (uint8_t )48,        (uint8_t )49,        (uint8_t )50,        (uint8_t )51, 
            (uint8_t )52,        (uint8_t )53,        (uint8_t )54,        (uint8_t )55, 
            (uint8_t )56,        (uint8_t )57,        (uint8_t )58,        (uint8_t )59, 
            (uint8_t )60,        (uint8_t )61,        (uint8_t )62,        (uint8_t )63}, 
   {        (uint8_t )0,        (uint8_t )1,        (uint8_t )2,        (uint8_t )3, 
            (uint8_t )5,        (uint8_t )6,        (uint8_t )7,        (uint8_t )8, 
            (uint8_t )9,        (uint8_t )11,        (uint8_t )12,        (uint8_t )13, 
            (uint8_t )14,        (uint8_t )15,        (uint8_t )17,        (uint8_t )18, 
            (uint8_t )20,        (uint8_t )21,        (uint8_t )23,        (uint8_t )24, 
            (uint8_t )26,        (uint8_t )27,        (uint8_t )29,        (uint8_t )30, 
            (uint8_t )32,        (uint8_t )33,        (uint8_t )35,        (uint8_t )36, 
            (uint8_t )38,        (uint8_t )39,        (uint8_t )41,        (uint8_t )42, 
            (uint8_t )44,        (uint8_t )45,        (uint8_t )47,        (uint8_t )48, 
            (uint8_t )50,        (uint8_t )51,        (uint8_t )53,        (uint8_t )54, 
            (uint8_t )56,        (uint8_t )57,        (uint8_t )59,        (uint8_t )60, 
            (uint8_t )62,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63}, 
   {        (uint8_t )0,        (uint8_t )1,        (uint8_t )2,        (uint8_t )3, 
            (uint8_t )5,        (uint8_t )6,        (uint8_t )7,        (uint8_t )8, 
            (uint8_t )9,        (uint8_t )11,        (uint8_t )12,        (uint8_t )13, 
            (uint8_t )14,        (uint8_t )16,        (uint8_t )17,        (uint8_t )19, 
            (uint8_t )20,        (uint8_t )22,        (uint8_t )23,        (uint8_t )25, 
            (uint8_t )26,        (uint8_t )28,        (uint8_t )29,        (uint8_t )31, 
            (uint8_t )32,        (uint8_t )34,        (uint8_t )35,        (uint8_t )37, 
            (uint8_t )38,        (uint8_t )40,        (uint8_t )41,        (uint8_t )43, 
            (uint8_t )44,        (uint8_t )46,        (uint8_t )47,        (uint8_t )49, 
            (uint8_t )50,        (uint8_t )52,        (uint8_t )53,        (uint8_t )55, 
            (uint8_t )56,        (uint8_t )58,        (uint8_t )59,        (uint8_t )61, 
            (uint8_t )62,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63}, 
   {        (uint8_t )0,        (uint8_t )1,        (uint8_t )2,        (uint8_t )3, 
            (uint8_t )5,        (uint8_t )6,        (uint8_t )7,        (uint8_t )8, 
            (uint8_t )9,        (uint8_t )11,        (uint8_t )12,        (uint8_t )13, 
            (uint8_t )15,        (uint8_t )16,        (uint8_t )18,        (uint8_t )19, 
            (uint8_t )21,        (uint8_t )22,        (uint8_t )24,        (uint8_t )25, 
            (uint8_t )27,        (uint8_t )28,        (uint8_t )30,        (uint8_t )31, 
            (uint8_t )33,        (uint8_t )34,        (uint8_t )36,        (uint8_t )37, 
            (uint8_t )39,        (uint8_t )40,        (uint8_t )42,        (uint8_t )43, 
            (uint8_t )45,        (uint8_t )46,        (uint8_t )48,        (uint8_t )49, 
            (uint8_t )51,        (uint8_t )52,        (uint8_t )54,        (uint8_t )55, 
            (uint8_t )57,        (uint8_t )58,        (uint8_t )60,        (uint8_t )61, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63}, 
   {        (uint8_t )0,        (uint8_t )1,        (uint8_t )2,        (uint8_t )3, 
            (uint8_t )5,        (uint8_t )6,        (uint8_t )7,        (uint8_t )8, 
            (uint8_t )9,        (uint8_t )11,        (uint8_t )12,        (uint8_t )14, 
            (uint8_t )15,        (uint8_t )17,        (uint8_t )18,        (uint8_t )20, 
            (uint8_t )21,        (uint8_t )23,        (uint8_t )24,        (uint8_t )26, 
            (uint8_t )27,        (uint8_t )29,        (uint8_t )30,        (uint8_t )32, 
            (uint8_t )33,        (uint8_t )35,        (uint8_t )36,        (uint8_t )38, 
            (uint8_t )39,        (uint8_t )41,        (uint8_t )42,        (uint8_t )44, 
            (uint8_t )45,        (uint8_t )47,        (uint8_t )48,        (uint8_t )50, 
            (uint8_t )51,        (uint8_t )53,        (uint8_t )54,        (uint8_t )56, 
            (uint8_t )57,        (uint8_t )59,        (uint8_t )60,        (uint8_t )62, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63}, 
   {        (uint8_t )0,        (uint8_t )1,        (uint8_t )2,        (uint8_t )4, 
            (uint8_t )5,        (uint8_t )7,        (uint8_t )8,        (uint8_t )9, 
            (uint8_t )11,        (uint8_t )12,        (uint8_t )13,        (uint8_t )15, 
            (uint8_t )16,        (uint8_t )17,        (uint8_t )19,        (uint8_t )20, 
            (uint8_t )22,        (uint8_t )23,        (uint8_t )25,        (uint8_t )26, 
            (uint8_t )28,        (uint8_t )29,        (uint8_t )31,        (uint8_t )32, 
            (uint8_t )34,        (uint8_t )35,        (uint8_t )37,        (uint8_t )38, 
            (uint8_t )40,        (uint8_t )41,        (uint8_t )43,        (uint8_t )44, 
            (uint8_t )46,        (uint8_t )47,        (uint8_t )49,        (uint8_t )50, 
            (uint8_t )52,        (uint8_t )53,        (uint8_t )55,        (uint8_t )56, 
            (uint8_t )58,        (uint8_t )59,        (uint8_t )61,        (uint8_t )62, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63}, 
   {        (uint8_t )0,        (uint8_t )1,        (uint8_t )2,        (uint8_t )4, 
            (uint8_t )5,        (uint8_t )7,        (uint8_t )8,        (uint8_t )9, 
            (uint8_t )11,        (uint8_t )12,        (uint8_t )13,        (uint8_t )15, 
            (uint8_t )16,        (uint8_t )18,        (uint8_t )19,        (uint8_t )21, 
            (uint8_t )22,        (uint8_t )24,        (uint8_t )25,        (uint8_t )27, 
            (uint8_t )28,        (uint8_t )30,        (uint8_t )31,        (uint8_t )33, 
            (uint8_t )34,        (uint8_t )36,        (uint8_t )37,        (uint8_t )39, 
            (uint8_t )40,        (uint8_t )42,        (uint8_t )43,        (uint8_t )45, 
            (uint8_t )46,        (uint8_t )48,        (uint8_t )49,        (uint8_t )51, 
            (uint8_t )52,        (uint8_t )54,        (uint8_t )55,        (uint8_t )57, 
            (uint8_t )58,        (uint8_t )60,        (uint8_t )61,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63}, 
   {        (uint8_t )0,        (uint8_t )1,        (uint8_t )2,        (uint8_t )4, 
            (uint8_t )5,        (uint8_t )7,        (uint8_t )8,        (uint8_t )9, 
            (uint8_t )11,        (uint8_t )12,        (uint8_t )14,        (uint8_t )15, 
            (uint8_t )17,        (uint8_t )18,        (uint8_t )20,        (uint8_t )21, 
            (uint8_t )23,        (uint8_t )24,        (uint8_t )26,        (uint8_t )27, 
            (uint8_t )29,        (uint8_t )30,        (uint8_t )32,        (uint8_t )33, 
            (uint8_t )35,        (uint8_t )36,        (uint8_t )38,        (uint8_t )39, 
            (uint8_t )41,        (uint8_t )42,        (uint8_t )44,        (uint8_t )45, 
            (uint8_t )47,        (uint8_t )48,        (uint8_t )50,        (uint8_t )51, 
            (uint8_t )53,        (uint8_t )54,        (uint8_t )56,        (uint8_t )57, 
            (uint8_t )59,        (uint8_t )60,        (uint8_t )62,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63, 
            (uint8_t )63,        (uint8_t )63,        (uint8_t )63,        (uint8_t )63}};
#line 59 "/root/patron-new/new_3/src/enc/filter_enc.c"
int VP8FilterStrengthFromDelta(int sharpness , int delta ) 
{ 
  int pos ;
  int tmp ;

  {
#line 60
  if (delta < 64) {
#line 60
    tmp = delta;
  } else {
#line 60
    tmp = 63;
  }
#line 60
  pos = tmp;
#line 62
  return ((int )kLevelsFromDelta[sharpness][pos]);
}
}
#line 70 "/root/patron-new/new_3/src/enc/filter_enc.c"
static int GetILevel(int sharpness , int level ) 
{ 


  {
#line 71
  if (sharpness > 0) {
#line 72
    if (sharpness > 4) {
#line 73
      level >>= 2;
    } else {
#line 75
      level >>= 1;
    }
#line 77
    if (level > 9 - sharpness) {
#line 78
      level = 9 - sharpness;
    }
  }
#line 81
  if (level < 1) {
#line 81
    level = 1;
  }
#line 82
  return (level);
}
}
#line 85 "/root/patron-new/new_3/src/enc/filter_enc.c"
static void DoFilter(VP8EncIterator *it , int level ) 
{ 
  VP8Encoder *enc ;
  int ilevel ;
  int __cil_tmp5 ;
  int limit ;
  uint8_t *y_dst ;
  uint8_t *u_dst ;
  uint8_t *v_dst ;
  int hev_thresh ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 86
  enc = it->enc_;
#line 87
  __cil_tmp5 = GetILevel((enc->config_)->filter_sharpness, level);
#line 87
  ilevel = __cil_tmp5;
#line 88
  limit = 2 * level + ilevel;
#line 90
  y_dst = it->yuv_out2_ + 0;
#line 91
  u_dst = it->yuv_out2_ + 16;
#line 92
  v_dst = it->yuv_out2_ + 24;
#line 95
  memcpy((void *)y_dst, (void const   *)it->yuv_out_, 512UL * sizeof(uint8_t ));
  }
#line 97
  if (enc->filter_hdr_.simple_ == 1) {
    {
#line 98
    (*VP8SimpleHFilter16i)(y_dst, 32, limit);
#line 99
    (*VP8SimpleVFilter16i)(y_dst, 32, limit);
    }
  } else {
#line 101
    if (level >= 40) {
#line 101
      tmp___0 = 2;
    } else {
#line 101
      if (level >= 15) {
#line 101
        tmp = 1;
      } else {
#line 101
        tmp = 0;
      }
#line 101
      tmp___0 = tmp;
    }
    {
#line 101
    hev_thresh = tmp___0;
#line 102
    (*VP8HFilter16i)(y_dst, 32, limit, ilevel, hev_thresh);
#line 103
    (*VP8HFilter8i)(u_dst, v_dst, 32, limit, ilevel, hev_thresh);
#line 104
    (*VP8VFilter16i)(y_dst, 32, limit, ilevel, hev_thresh);
#line 105
    (*VP8VFilter8i)(u_dst, v_dst, 32, limit, ilevel, hev_thresh);
    }
  }
#line 108
  return;
}
}
#line 112 "/root/patron-new/new_3/src/enc/filter_enc.c"
static double GetMBSSIM(uint8_t *yuv1 , uint8_t *yuv2 ) 
{ 
  int x ;
  int y ;
  double sum ;
  double __cil_tmp6 ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;

  {
#line 114
  sum = 0.;
#line 117
  y = 3;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;

#line 117
    if (! (y < 13)) {
#line 117
      goto while_break;
    }
#line 118
    x = 3;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 118
      if (! (x < 13)) {
#line 118
        goto while_break___0;
      }
      {
#line 119
      __cil_tmp6 = (*VP8SSIMGetClipped)(yuv1 + 0, 32, yuv2 + 0, 32, x, y, 16, 16);
#line 119
      sum += __cil_tmp6;
#line 118
      x ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 117
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 123
  x = 1;
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 123
    if (! (x < 7)) {
#line 123
      goto while_break___1;
    }
#line 124
    y = 1;
    {
#line 124
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 124
      if (! (y < 7)) {
#line 124
        goto while_break___2;
      }
      {
#line 125
      __cil_tmp9 = (*VP8SSIMGetClipped)(yuv1 + 16, 32, yuv2 + 16, 32, x, y, 8, 8);
#line 125
      sum += __cil_tmp9;
#line 127
      __cil_tmp10 = (*VP8SSIMGetClipped)(yuv1 + 24, 32, yuv2 + 24, 32, x, y, 8, 8);
#line 127
      sum += __cil_tmp10;
#line 124
      y ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 123
    x ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 131
  return (sum);
}
}
#line 140 "/root/patron-new/new_3/src/enc/filter_enc.c"
void VP8InitFilter(VP8EncIterator *it ) 
{ 
  int s ;
  int i ;

  {
#line 142
  if ((unsigned long )it->lf_stats_ != (unsigned long )((void *)0)) {
#line 144
    s = 0;
    {
#line 144
    while (1) {
      while_continue: /* CIL Label */ ;

#line 144
      if (! (s < 4)) {
#line 144
        goto while_break;
      }
#line 145
      i = 0;
      {
#line 145
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 145
        if (! (i < 64)) {
#line 145
          goto while_break___0;
        }
#line 146
        (*(it->lf_stats_))[s][i] = (double )0;
#line 145
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 144
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 149
    VP8SSIMDspInit();
    }
  }
#line 152
  return;
}
}
#line 156 "/root/patron-new/new_3/src/enc/filter_enc.c"
void VP8StoreFilterStats(VP8EncIterator *it ) 
{ 
  int d ;
  VP8Encoder *enc ;
  int s ;
  int level0 ;
  int delta_min ;
  int delta_max ;
  int step_size ;
  int tmp ;
  double __cil_tmp10 ;
  int level ;
  double __cil_tmp12 ;

  {
#line 159
  enc = it->enc_;
#line 160
  s = (int )(it->mb_)->segment_;
#line 161
  level0 = enc->dqm_[s].fstrength_;
#line 164
  delta_min = - enc->dqm_[s].quant_;
#line 165
  delta_max = enc->dqm_[s].quant_;
#line 166
  if (delta_max - delta_min >= 4) {
#line 166
    tmp = 4;
  } else {
#line 166
    tmp = 1;
  }
#line 166
  step_size = tmp;
#line 168
  if ((unsigned long )it->lf_stats_ == (unsigned long )((void *)0)) {
#line 168
    return;
  }
#line 176
  if ((int )(it->mb_)->type_ == 1) {
#line 176
    if ((int )(it->mb_)->skip_) {
#line 176
      return;
    }
  }
  {
#line 179
  __cil_tmp10 = GetMBSSIM(it->yuv_in_, it->yuv_out_);
#line 179
  (*(it->lf_stats_))[s][0] += __cil_tmp10;
#line 181
  d = delta_min;
  }
  {
#line 181
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 181
    if (! (d <= delta_max)) {
#line 181
      goto while_break;
    }
#line 182
    level = level0 + d;
#line 183
    if (level <= 0) {
#line 184
      goto while_continue;
    } else
#line 183
    if (level >= 64) {
#line 184
      goto while_continue;
    }
    {
#line 186
    DoFilter(it, level);
#line 187
    __cil_tmp12 = GetMBSSIM(it->yuv_in_, it->yuv_out2_);
#line 187
    (*(it->lf_stats_))[s][level] += __cil_tmp12;
#line 181
    d += step_size;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 185
  return;
}
}
#line 194 "/root/patron-new/new_3/src/enc/filter_enc.c"
void VP8AdjustFilterStrength(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  int s ;
  int i ;
  int best_level ;
  double best_v ;
  double v ;
  int max_level ;
  int s___0 ;
  VP8SegmentInfo *dqm ;
  int delta ;
  int level ;
  int __cil_tmp15 ;

  {
#line 195
  enc = it->enc_;
#line 197
  if ((unsigned long )it->lf_stats_ != (unsigned long )((void *)0)) {
#line 199
    s = 0;
    {
#line 199
    while (1) {
      while_continue: /* CIL Label */ ;

#line 199
      if (! (s < 4)) {
#line 199
        goto while_break;
      }
#line 200
      best_level = 0;
#line 202
      best_v = 1.00001000001 * (*(it->lf_stats_))[s][0];
#line 203
      i = 1;
      {
#line 203
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 203
        if (! (i < 64)) {
#line 203
          goto while_break___0;
        }
#line 204
        v = (*(it->lf_stats_))[s][i];
#line 205
        if (v > best_v) {
#line 206
          best_v = v;
#line 207
          best_level = i;
        }
#line 203
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: 
#line 210
      enc->dqm_[s].fstrength_ = best_level;
#line 199
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
#line 212
    return;
  }
#line 215
  if ((enc->config_)->filter_strength > 0) {
#line 216
    max_level = 0;
#line 218
    s___0 = 0;
    {
#line 218
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 218
      if (! (s___0 < 4)) {
#line 218
        goto while_break___1;
      }
      {
#line 219
      dqm = & enc->dqm_[s___0];
#line 221
      delta = dqm->max_edge_ * (int )dqm->y2_.q_[1] >> 3;
#line 222
      __cil_tmp15 = VP8FilterStrengthFromDelta(enc->filter_hdr_.sharpness_, delta);
#line 222
      level = __cil_tmp15;
      }
#line 224
      if (level > dqm->fstrength_) {
#line 225
        dqm->fstrength_ = level;
      }
#line 227
      if (max_level < dqm->fstrength_) {
#line 228
        max_level = dqm->fstrength_;
      }
#line 218
      s___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 231
    enc->filter_hdr_.level_ = max_level;
  }
#line 233
  return;
}
}
#line 22 "/root/patron-new/new_3/src/enc/cost_enc.c"
uint16_t VP8LevelCodes[67][2]  = 
#line 22 "/root/patron-new/new_3/src/enc/cost_enc.c"
  { {        (uint16_t )1,        (uint16_t )0}, 
   {        (uint16_t )7,        (uint16_t )1}, 
   {        (uint16_t )15,        (uint16_t )5}, 
   {        (uint16_t )15,        (uint16_t )13}, 
   {        (uint16_t )51,        (uint16_t )3}, 
   {        (uint16_t )51,        (uint16_t )3}, 
   {        (uint16_t )51,        (uint16_t )35}, 
   {        (uint16_t )51,        (uint16_t )35}, 
   {        (uint16_t )51,        (uint16_t )35}, 
   {        (uint16_t )51,        (uint16_t )35}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )339}};
#line 42 "/root/patron-new/new_3/src/enc/cost_enc.c"
static int VariableLevelCost(int level , uint8_t *probas ) 
{ 
  int pattern ;
  int bits ;
  int cost ;
  int i ;
  int __cil_tmp7 ;

  {
#line 43
  pattern = (int )VP8LevelCodes[level - 1][0];
#line 44
  bits = (int )VP8LevelCodes[level - 1][1];
#line 45
  cost = 0;
#line 47
  i = 2;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;

#line 47
    if (! pattern) {
#line 47
      goto while_break;
    }
#line 48
    if (pattern & 1) {
      {
#line 49
      __cil_tmp7 = VP8BitCost(bits & 1, *(probas + i));
#line 49
      cost += __cil_tmp7;
      }
    }
#line 51
    bits >>= 1;
#line 52
    pattern >>= 1;
#line 47
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 54
  return (cost);
}
}
#line 60 "/root/patron-new/new_3/src/enc/cost_enc.c"
void VP8CalculateLevelCosts(VP8EncProba *proba ) 
{ 
  int ctype ;
  int band ;
  int ctx ;
  int n ;
  uint8_t *p ;
  uint16_t *table ;
  int cost0 ;
  int __cil_tmp9 ;
  int tmp ;
  int cost_base ;
  int __cil_tmp12 ;
  int v ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 63
  if (! proba->dirty_) {
#line 63
    return;
  }
#line 65
  ctype = 0;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;

#line 65
    if (! (ctype < 4)) {
#line 65
      goto while_break;
    }
#line 67
    band = 0;
    {
#line 67
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 67
      if (! (band < 8)) {
#line 67
        goto while_break___0;
      }
#line 68
      ctx = 0;
      {
#line 68
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 68
        if (! (ctx < 3)) {
#line 68
          goto while_break___1;
        }
#line 69
        p = proba->coeffs_[ctype][band][ctx];
#line 70
        table = proba->level_cost_[ctype][band][ctx];
#line 71
        if (ctx > 0) {
          {
#line 71
          __cil_tmp9 = VP8BitCost(1, *(p + 0));
#line 71
          tmp = __cil_tmp9;
          }
        } else {
#line 71
          tmp = 0;
        }
        {
#line 71
        cost0 = tmp;
#line 72
        __cil_tmp12 = VP8BitCost(1, *(p + 1));
#line 72
        cost_base = __cil_tmp12 + cost0;
#line 74
        __cil_tmp14 = VP8BitCost(0, *(p + 1));
#line 74
        *(table + 0) = (uint16_t )(__cil_tmp14 + cost0);
#line 75
        v = 1;
        }
        {
#line 75
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 75
          if (! (v <= 67)) {
#line 75
            goto while_break___2;
          }
          {
#line 76
          __cil_tmp15 = VariableLevelCost(v, (uint8_t *)p);
#line 76
          *(table + v) = (uint16_t )(cost_base + __cil_tmp15);
#line 75
          v ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: 
#line 68
        ctx ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: 
#line 67
      band ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: 
#line 82
    n = 0;
    {
#line 82
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 82
      if (! (n < 16)) {
#line 82
        goto while_break___3;
      }
#line 83
      ctx = 0;
      {
#line 83
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 83
        if (! (ctx < 3)) {
#line 83
          goto while_break___4;
        }
#line 84
        proba->remapped_costs_[ctype][n][ctx] = proba->level_cost_[ctype][VP8EncBands[n]][ctx];
#line 83
        ctx ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: 
#line 82
      n ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: 
#line 65
    ctype ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
#line 89
  proba->dirty_ = 0;
#line 90
  return;
}
}
#line 97 "/root/patron-new/new_3/src/enc/cost_enc.c"
uint16_t VP8FixedCostsUV[4]  = {      (uint16_t )302,      (uint16_t )984,      (uint16_t )439,      (uint16_t )642};
#line 99 "/root/patron-new/new_3/src/enc/cost_enc.c"
uint16_t VP8FixedCostsI16[4]  = {      (uint16_t )663,      (uint16_t )919,      (uint16_t )872,      (uint16_t )919};
#line 100 "/root/patron-new/new_3/src/enc/cost_enc.c"
uint16_t VP8FixedCostsI4[10][10][10]  = 
#line 100
  { { {          (uint16_t )40,          (uint16_t )1151,          (uint16_t )1723,          (uint16_t )1874, 
                (uint16_t )2103,          (uint16_t )2019,          (uint16_t )1628,          (uint16_t )1777, 
                (uint16_t )2226,          (uint16_t )2137}, 
     {          (uint16_t )192,          (uint16_t )469,          (uint16_t )1296,          (uint16_t )1308, 
                (uint16_t )1849,          (uint16_t )1794,          (uint16_t )1781,          (uint16_t )1703, 
                (uint16_t )1713,          (uint16_t )1522}, 
     {          (uint16_t )142,          (uint16_t )910,          (uint16_t )762,          (uint16_t )1684, 
                (uint16_t )1849,          (uint16_t )1576,          (uint16_t )1460,          (uint16_t )1305, 
                (uint16_t )1801,          (uint16_t )1657}, 
     {          (uint16_t )559,          (uint16_t )641,          (uint16_t )1370,          (uint16_t )421, 
                (uint16_t )1182,          (uint16_t )1569,          (uint16_t )1612,          (uint16_t )1725, 
                (uint16_t )863,          (uint16_t )1007}, 
     {          (uint16_t )299,          (uint16_t )1059,          (uint16_t )1256,          (uint16_t )1108, 
                (uint16_t )636,          (uint16_t )1068,          (uint16_t )1581,          (uint16_t )1883, 
                (uint16_t )869,          (uint16_t )1142}, 
     {          (uint16_t )277,          (uint16_t )1111,          (uint16_t )707,          (uint16_t )1362, 
                (uint16_t )1089,          (uint16_t )672,          (uint16_t )1603,          (uint16_t )1541, 
                (uint16_t )1545,          (uint16_t )1291}, 
     {          (uint16_t )214,          (uint16_t )781,          (uint16_t )1609,          (uint16_t )1303, 
                (uint16_t )1632,          (uint16_t )2229,          (uint16_t )726,          (uint16_t )1560, 
                (uint16_t )1713,          (uint16_t )918}, 
     {          (uint16_t )152,          (uint16_t )1037,          (uint16_t )1046,          (uint16_t )1759, 
                (uint16_t )1983,          (uint16_t )2174,          (uint16_t )1358,          (uint16_t )742, 
                (uint16_t )1740,          (uint16_t )1390}, 
     {          (uint16_t )512,          (uint16_t )1046,          (uint16_t )1420,          (uint16_t )753, 
                (uint16_t )752,          (uint16_t )1297,          (uint16_t )1486,          (uint16_t )1613, 
                (uint16_t )460,          (uint16_t )1207}, 
     {          (uint16_t )424,          (uint16_t )827,          (uint16_t )1362,          (uint16_t )719, 
                (uint16_t )1462,          (uint16_t )1202,          (uint16_t )1199,          (uint16_t )1476, 
                (uint16_t )1199,          (uint16_t )538}}, 
   { {          (uint16_t )240,          (uint16_t )402,          (uint16_t )1134,          (uint16_t )1491, 
                (uint16_t )1659,          (uint16_t )1505,          (uint16_t )1517,          (uint16_t )1555, 
                (uint16_t )1979,          (uint16_t )2099}, 
     {          (uint16_t )467,          (uint16_t )242,          (uint16_t )960,          (uint16_t )1232, 
                (uint16_t )1714,          (uint16_t )1620,          (uint16_t )1834,          (uint16_t )1570, 
                (uint16_t )1676,          (uint16_t )1391}, 
     {          (uint16_t )500,          (uint16_t )455,          (uint16_t )463,          (uint16_t )1507, 
                (uint16_t )1699,          (uint16_t )1282,          (uint16_t )1564,          (uint16_t )982, 
                (uint16_t )2114,          (uint16_t )2114}, 
     {          (uint16_t )672,          (uint16_t )643,          (uint16_t )1372,          (uint16_t )331, 
                (uint16_t )1589,          (uint16_t )1667,          (uint16_t )1453,          (uint16_t )1938, 
                (uint16_t )996,          (uint16_t )876}, 
     {          (uint16_t )458,          (uint16_t )783,          (uint16_t )1037,          (uint16_t )911, 
                (uint16_t )738,          (uint16_t )968,          (uint16_t )1165,          (uint16_t )1518, 
                (uint16_t )859,          (uint16_t )1033}, 
     {          (uint16_t )504,          (uint16_t )815,          (uint16_t )504,          (uint16_t )1139, 
                (uint16_t )1219,          (uint16_t )719,          (uint16_t )1506,          (uint16_t )1085, 
                (uint16_t )1268,          (uint16_t )1268}, 
     {          (uint16_t )333,          (uint16_t )630,          (uint16_t )1445,          (uint16_t )1239, 
                (uint16_t )1883,          (uint16_t )3672,          (uint16_t )799,          (uint16_t )1548, 
                (uint16_t )1865,          (uint16_t )598}, 
     {          (uint16_t )399,          (uint16_t )644,          (uint16_t )746,          (uint16_t )1342, 
                (uint16_t )1856,          (uint16_t )1350,          (uint16_t )1493,          (uint16_t )613, 
                (uint16_t )1855,          (uint16_t )1015}, 
     {          (uint16_t )622,          (uint16_t )749,          (uint16_t )1205,          (uint16_t )608, 
                (uint16_t )1066,          (uint16_t )1408,          (uint16_t )1290,          (uint16_t )1406, 
                (uint16_t )546,          (uint16_t )971}, 
     {          (uint16_t )500,          (uint16_t )753,          (uint16_t )1041,          (uint16_t )668, 
                (uint16_t )1230,          (uint16_t )1617,          (uint16_t )1297,          (uint16_t )1425, 
                (uint16_t )1383,          (uint16_t )523}}, 
   { {          (uint16_t )394,          (uint16_t )553,          (uint16_t )523,          (uint16_t )1502, 
                (uint16_t )1536,          (uint16_t )981,          (uint16_t )1608,          (uint16_t )1142, 
                (uint16_t )1666,          (uint16_t )2181}, 
     {          (uint16_t )655,          (uint16_t )430,          (uint16_t )375,          (uint16_t )1411, 
                (uint16_t )1861,          (uint16_t )1220,          (uint16_t )1677,          (uint16_t )1135, 
                (uint16_t )1978,          (uint16_t )1553}, 
     {          (uint16_t )690,          (uint16_t )640,          (uint16_t )245,          (uint16_t )1954, 
                (uint16_t )2070,          (uint16_t )1194,          (uint16_t )1528,          (uint16_t )982, 
                (uint16_t )1972,          (uint16_t )2232}, 
     {          (uint16_t )559,          (uint16_t )834,          (uint16_t )741,          (uint16_t )867, 
                (uint16_t )1131,          (uint16_t )980,          (uint16_t )1225,          (uint16_t )852, 
                (uint16_t )1092,          (uint16_t )784}, 
     {          (uint16_t )690,          (uint16_t )875,          (uint16_t )516,          (uint16_t )959, 
                (uint16_t )673,          (uint16_t )894,          (uint16_t )1056,          (uint16_t )1190, 
                (uint16_t )1528,          (uint16_t )1126}, 
     {          (uint16_t )740,          (uint16_t )951,          (uint16_t )384,          (uint16_t )1277, 
                (uint16_t )1177,          (uint16_t )492,          (uint16_t )1579,          (uint16_t )1155, 
                (uint16_t )1846,          (uint16_t )1513}, 
     {          (uint16_t )323,          (uint16_t )775,          (uint16_t )1062,          (uint16_t )1776, 
                (uint16_t )3062,          (uint16_t )1274,          (uint16_t )813,          (uint16_t )1188, 
                (uint16_t )1372,          (uint16_t )655}, 
     {          (uint16_t )488,          (uint16_t )971,          (uint16_t )484,          (uint16_t )1767, 
                (uint16_t )1515,          (uint16_t )1775,          (uint16_t )1115,          (uint16_t )503, 
                (uint16_t )1539,          (uint16_t )1461}, 
     {          (uint16_t )740,          (uint16_t )1006,          (uint16_t )998,          (uint16_t )709, 
                (uint16_t )851,          (uint16_t )1230,          (uint16_t )1337,          (uint16_t )788, 
                (uint16_t )741,          (uint16_t )721}, 
     {          (uint16_t )522,          (uint16_t )1073,          (uint16_t )573,          (uint16_t )1045, 
                (uint16_t )1346,          (uint16_t )887,          (uint16_t )1046,          (uint16_t )1146, 
                (uint16_t )1203,          (uint16_t )697}}, 
   { {          (uint16_t )105,          (uint16_t )864,          (uint16_t )1442,          (uint16_t )1009, 
                (uint16_t )1934,          (uint16_t )1840,          (uint16_t )1519,          (uint16_t )1920, 
                (uint16_t )1673,          (uint16_t )1579}, 
     {          (uint16_t )534,          (uint16_t )305,          (uint16_t )1193,          (uint16_t )683, 
                (uint16_t )1388,          (uint16_t )2164,          (uint16_t )1802,          (uint16_t )1894, 
                (uint16_t )1264,          (uint16_t )1170}, 
     {          (uint16_t )305,          (uint16_t )518,          (uint16_t )877,          (uint16_t )1108, 
                (uint16_t )1426,          (uint16_t )3215,          (uint16_t )1425,          (uint16_t )1064, 
                (uint16_t )1320,          (uint16_t )1242}, 
     {          (uint16_t )683,          (uint16_t )732,          (uint16_t )1927,          (uint16_t )257, 
                (uint16_t )1493,          (uint16_t )2048,          (uint16_t )1858,          (uint16_t )1552, 
                (uint16_t )1055,          (uint16_t )947}, 
     {          (uint16_t )394,          (uint16_t )814,          (uint16_t )1024,          (uint16_t )660, 
                (uint16_t )959,          (uint16_t )1556,          (uint16_t )1282,          (uint16_t )1289, 
                (uint16_t )893,          (uint16_t )1047}, 
     {          (uint16_t )528,          (uint16_t )615,          (uint16_t )996,          (uint16_t )940, 
                (uint16_t )1201,          (uint16_t )635,          (uint16_t )1094,          (uint16_t )2515, 
                (uint16_t )803,          (uint16_t )1358}, 
     {          (uint16_t )347,          (uint16_t )614,          (uint16_t )1609,          (uint16_t )1187, 
                (uint16_t )3133,          (uint16_t )1345,          (uint16_t )1007,          (uint16_t )1339, 
                (uint16_t )1017,          (uint16_t )667}, 
     {          (uint16_t )218,          (uint16_t )740,          (uint16_t )878,          (uint16_t )1605, 
                (uint16_t )3650,          (uint16_t )3650,          (uint16_t )1345,          (uint16_t )758, 
                (uint16_t )1357,          (uint16_t )1617}, 
     {          (uint16_t )672,          (uint16_t )750,          (uint16_t )1541,          (uint16_t )558, 
                (uint16_t )1257,          (uint16_t )1599,          (uint16_t )1870,          (uint16_t )2135, 
                (uint16_t )402,          (uint16_t )1087}, 
     {          (uint16_t )592,          (uint16_t )684,          (uint16_t )1161,          (uint16_t )430, 
                (uint16_t )1092,          (uint16_t )1497,          (uint16_t )1475,          (uint16_t )1489, 
                (uint16_t )1095,          (uint16_t )822}}, 
   { {          (uint16_t )228,          (uint16_t )1056,          (uint16_t )1059,          (uint16_t )1368, 
                (uint16_t )752,          (uint16_t )982,          (uint16_t )1512,          (uint16_t )1518, 
                (uint16_t )987,          (uint16_t )1782}, 
     {          (uint16_t )494,          (uint16_t )514,          (uint16_t )818,          (uint16_t )942, 
                (uint16_t )965,          (uint16_t )892,          (uint16_t )1610,          (uint16_t )1356, 
                (uint16_t )1048,          (uint16_t )1363}, 
     {          (uint16_t )512,          (uint16_t )648,          (uint16_t )591,          (uint16_t )1042, 
                (uint16_t )761,          (uint16_t )991,          (uint16_t )1196,          (uint16_t )1454, 
                (uint16_t )1309,          (uint16_t )1463}, 
     {          (uint16_t )683,          (uint16_t )749,          (uint16_t )1043,          (uint16_t )676, 
                (uint16_t )841,          (uint16_t )1396,          (uint16_t )1133,          (uint16_t )1138, 
                (uint16_t )654,          (uint16_t )939}, 
     {          (uint16_t )622,          (uint16_t )1101,          (uint16_t )1126,          (uint16_t )994, 
                (uint16_t )361,          (uint16_t )1077,          (uint16_t )1203,          (uint16_t )1318, 
                (uint16_t )877,          (uint16_t )1219}, 
     {          (uint16_t )631,          (uint16_t )1068,          (uint16_t )857,          (uint16_t )1650, 
                (uint16_t )651,          (uint16_t )477,          (uint16_t )1650,          (uint16_t )1419, 
                (uint16_t )828,          (uint16_t )1170}, 
     {          (uint16_t )555,          (uint16_t )727,          (uint16_t )1068,          (uint16_t )1335, 
                (uint16_t )3127,          (uint16_t )1339,          (uint16_t )820,          (uint16_t )1331, 
                (uint16_t )1077,          (uint16_t )429}, 
     {          (uint16_t )504,          (uint16_t )879,          (uint16_t )624,          (uint16_t )1398, 
                (uint16_t )889,          (uint16_t )889,          (uint16_t )1392,          (uint16_t )808, 
                (uint16_t )891,          (uint16_t )1406}, 
     {          (uint16_t )683,          (uint16_t )1602,          (uint16_t )1289,          (uint16_t )977, 
                (uint16_t )578,          (uint16_t )983,          (uint16_t )1280,          (uint16_t )1708, 
                (uint16_t )406,          (uint16_t )1122}, 
     {          (uint16_t )399,          (uint16_t )865,          (uint16_t )1433,          (uint16_t )1070, 
                (uint16_t )1072,          (uint16_t )764,          (uint16_t )968,          (uint16_t )1477, 
                (uint16_t )1223,          (uint16_t )678}}, 
   { {          (uint16_t )333,          (uint16_t )760,          (uint16_t )935,          (uint16_t )1638, 
                (uint16_t )1010,          (uint16_t )529,          (uint16_t )1646,          (uint16_t )1410, 
                (uint16_t )1472,          (uint16_t )2219}, 
     {          (uint16_t )512,          (uint16_t )494,          (uint16_t )750,          (uint16_t )1160, 
                (uint16_t )1215,          (uint16_t )610,          (uint16_t )1870,          (uint16_t )1868, 
                (uint16_t )1628,          (uint16_t )1169}, 
     {          (uint16_t )572,          (uint16_t )646,          (uint16_t )492,          (uint16_t )1934, 
                (uint16_t )1208,          (uint16_t )603,          (uint16_t )1580,          (uint16_t )1099, 
                (uint16_t )1398,          (uint16_t )1995}, 
     {          (uint16_t )786,          (uint16_t )789,          (uint16_t )942,          (uint16_t )581, 
                (uint16_t )1018,          (uint16_t )951,          (uint16_t )1599,          (uint16_t )1207, 
                (uint16_t )731,          (uint16_t )768}, 
     {          (uint16_t )690,          (uint16_t )1015,          (uint16_t )672,          (uint16_t )1078, 
                (uint16_t )582,          (uint16_t )504,          (uint16_t )1693,          (uint16_t )1438, 
                (uint16_t )1108,          (uint16_t )2897}, 
     {          (uint16_t )768,          (uint16_t )1267,          (uint16_t )571,          (uint16_t )2005, 
                (uint16_t )1243,          (uint16_t )244,          (uint16_t )2881,          (uint16_t )1380, 
                (uint16_t )1786,          (uint16_t )1453}, 
     {          (uint16_t )452,          (uint16_t )899,          (uint16_t )1293,          (uint16_t )903, 
                (uint16_t )1311,          (uint16_t )3100,          (uint16_t )465,          (uint16_t )1311, 
                (uint16_t )1319,          (uint16_t )813}, 
     {          (uint16_t )394,          (uint16_t )927,          (uint16_t )942,          (uint16_t )1103, 
                (uint16_t )1358,          (uint16_t )1104,          (uint16_t )946,          (uint16_t )593, 
                (uint16_t )1363,          (uint16_t )1109}, 
     {          (uint16_t )559,          (uint16_t )1005,          (uint16_t )1007,          (uint16_t )1016, 
                (uint16_t )658,          (uint16_t )1173,          (uint16_t )1021,          (uint16_t )1164, 
                (uint16_t )623,          (uint16_t )1028}, 
     {          (uint16_t )564,          (uint16_t )796,          (uint16_t )632,          (uint16_t )1005, 
                (uint16_t )1014,          (uint16_t )863,          (uint16_t )2316,          (uint16_t )1268, 
                (uint16_t )938,          (uint16_t )764}}, 
   { {          (uint16_t )266,          (uint16_t )606,          (uint16_t )1098,          (uint16_t )1228, 
                (uint16_t )1497,          (uint16_t )1243,          (uint16_t )948,          (uint16_t )1030, 
                (uint16_t )1734,          (uint16_t )1461}, 
     {          (uint16_t )366,          (uint16_t )585,          (uint16_t )901,          (uint16_t )1060, 
                (uint16_t )1407,          (uint16_t )1247,          (uint16_t )876,          (uint16_t )1134, 
                (uint16_t )1620,          (uint16_t )1054}, 
     {          (uint16_t )452,          (uint16_t )565,          (uint16_t )542,          (uint16_t )1729, 
                (uint16_t )1479,          (uint16_t )1479,          (uint16_t )1016,          (uint16_t )886, 
                (uint16_t )2938,          (uint16_t )1150}, 
     {          (uint16_t )555,          (uint16_t )1088,          (uint16_t )1533,          (uint16_t )950, 
                (uint16_t )1354,          (uint16_t )895,          (uint16_t )834,          (uint16_t )1019, 
                (uint16_t )1021,          (uint16_t )496}, 
     {          (uint16_t )704,          (uint16_t )815,          (uint16_t )1193,          (uint16_t )971, 
                (uint16_t )973,          (uint16_t )640,          (uint16_t )1217,          (uint16_t )2214, 
                (uint16_t )832,          (uint16_t )578}, 
     {          (uint16_t )672,          (uint16_t )1245,          (uint16_t )579,          (uint16_t )871, 
                (uint16_t )875,          (uint16_t )774,          (uint16_t )872,          (uint16_t )1273, 
                (uint16_t )1027,          (uint16_t )949}, 
     {          (uint16_t )296,          (uint16_t )1134,          (uint16_t )2050,          (uint16_t )1784, 
                (uint16_t )1636,          (uint16_t )3425,          (uint16_t )442,          (uint16_t )1550, 
                (uint16_t )2076,          (uint16_t )722}, 
     {          (uint16_t )342,          (uint16_t )982,          (uint16_t )1259,          (uint16_t )1846, 
                (uint16_t )1848,          (uint16_t )1848,          (uint16_t )622,          (uint16_t )568, 
                (uint16_t )1847,          (uint16_t )1052}, 
     {          (uint16_t )555,          (uint16_t )1064,          (uint16_t )1304,          (uint16_t )828, 
                (uint16_t )746,          (uint16_t )1343,          (uint16_t )1075,          (uint16_t )1329, 
                (uint16_t )1078,          (uint16_t )494}, 
     {          (uint16_t )288,          (uint16_t )1167,          (uint16_t )1285,          (uint16_t )1174, 
                (uint16_t )1639,          (uint16_t )1639,          (uint16_t )833,          (uint16_t )2254, 
                (uint16_t )1304,          (uint16_t )509}}, 
   { {          (uint16_t )342,          (uint16_t )719,          (uint16_t )767,          (uint16_t )1866, 
                (uint16_t )1757,          (uint16_t )1270,          (uint16_t )1246,          (uint16_t )550, 
                (uint16_t )1746,          (uint16_t )2151}, 
     {          (uint16_t )483,          (uint16_t )653,          (uint16_t )694,          (uint16_t )1509, 
                (uint16_t )1459,          (uint16_t )1410,          (uint16_t )1218,          (uint16_t )507, 
                (uint16_t )1914,          (uint16_t )1266}, 
     {          (uint16_t )488,          (uint16_t )757,          (uint16_t )447,          (uint16_t )2979, 
                (uint16_t )1813,          (uint16_t )1268,          (uint16_t )1654,          (uint16_t )539, 
                (uint16_t )1849,          (uint16_t )2109}, 
     {          (uint16_t )522,          (uint16_t )1097,          (uint16_t )1085,          (uint16_t )851, 
                (uint16_t )1365,          (uint16_t )1111,          (uint16_t )851,          (uint16_t )901, 
                (uint16_t )961,          (uint16_t )605}, 
     {          (uint16_t )709,          (uint16_t )716,          (uint16_t )841,          (uint16_t )728, 
                (uint16_t )736,          (uint16_t )945,          (uint16_t )941,          (uint16_t )862, 
                (uint16_t )2845,          (uint16_t )1057}, 
     {          (uint16_t )512,          (uint16_t )1323,          (uint16_t )500,          (uint16_t )1336, 
                (uint16_t )1083,          (uint16_t )681,          (uint16_t )1342,          (uint16_t )717, 
                (uint16_t )1604,          (uint16_t )1350}, 
     {          (uint16_t )452,          (uint16_t )1155,          (uint16_t )1372,          (uint16_t )1900, 
                (uint16_t )1501,          (uint16_t )3290,          (uint16_t )311,          (uint16_t )944, 
                (uint16_t )1919,          (uint16_t )922}, 
     {          (uint16_t )403,          (uint16_t )1520,          (uint16_t )977,          (uint16_t )2132, 
                (uint16_t )1733,          (uint16_t )3522,          (uint16_t )1076,          (uint16_t )276, 
                (uint16_t )3335,          (uint16_t )1547}, 
     {          (uint16_t )559,          (uint16_t )1374,          (uint16_t )1101,          (uint16_t )615, 
                (uint16_t )673,          (uint16_t )2462,          (uint16_t )974,          (uint16_t )795, 
                (uint16_t )984,          (uint16_t )984}, 
     {          (uint16_t )547,          (uint16_t )1122,          (uint16_t )1062,          (uint16_t )812, 
                (uint16_t )1410,          (uint16_t )951,          (uint16_t )1140,          (uint16_t )622, 
                (uint16_t )1268,          (uint16_t )651}}, 
   { {          (uint16_t )165,          (uint16_t )982,          (uint16_t )1235,          (uint16_t )938, 
                (uint16_t )1334,          (uint16_t )1366,          (uint16_t )1659,          (uint16_t )1578, 
                (uint16_t )964,          (uint16_t )1612}, 
     {          (uint16_t )592,          (uint16_t )422,          (uint16_t )925,          (uint16_t )847, 
                (uint16_t )1139,          (uint16_t )1112,          (uint16_t )1387,          (uint16_t )2036, 
                (uint16_t )861,          (uint16_t )1041}, 
     {          (uint16_t )403,          (uint16_t )837,          (uint16_t )732,          (uint16_t )770, 
                (uint16_t )941,          (uint16_t )1658,          (uint16_t )1250,          (uint16_t )809, 
                (uint16_t )1407,          (uint16_t )1407}, 
     {          (uint16_t )896,          (uint16_t )874,          (uint16_t )1071,          (uint16_t )381, 
                (uint16_t )1568,          (uint16_t )1722,          (uint16_t )1437,          (uint16_t )2192, 
                (uint16_t )480,          (uint16_t )1035}, 
     {          (uint16_t )640,          (uint16_t )1098,          (uint16_t )1012,          (uint16_t )1032, 
                (uint16_t )684,          (uint16_t )1382,          (uint16_t )1581,          (uint16_t )2106, 
                (uint16_t )416,          (uint16_t )865}, 
     {          (uint16_t )559,          (uint16_t )1005,          (uint16_t )819,          (uint16_t )914, 
                (uint16_t )710,          (uint16_t )770,          (uint16_t )1418,          (uint16_t )920, 
                (uint16_t )838,          (uint16_t )1435}, 
     {          (uint16_t )415,          (uint16_t )1258,          (uint16_t )1245,          (uint16_t )870, 
                (uint16_t )1278,          (uint16_t )3067,          (uint16_t )770,          (uint16_t )1021, 
                (uint16_t )1287,          (uint16_t )522}, 
     {          (uint16_t )406,          (uint16_t )990,          (uint16_t )601,          (uint16_t )1009, 
                (uint16_t )1265,          (uint16_t )1265,          (uint16_t )1267,          (uint16_t )759, 
                (uint16_t )1017,          (uint16_t )1277}, 
     {          (uint16_t )968,          (uint16_t )1182,          (uint16_t )1329,          (uint16_t )788, 
                (uint16_t )1032,          (uint16_t )1292,          (uint16_t )1705,          (uint16_t )1714, 
                (uint16_t )203,          (uint16_t )1403}, 
     {          (uint16_t )732,          (uint16_t )877,          (uint16_t )1279,          (uint16_t )471, 
                (uint16_t )901,          (uint16_t )1161,          (uint16_t )1545,          (uint16_t )1294, 
                (uint16_t )755,          (uint16_t )755}}, 
   { {          (uint16_t )111,          (uint16_t )931,          (uint16_t )1378,          (uint16_t )1185, 
                (uint16_t )1933,          (uint16_t )1648,          (uint16_t )1148,          (uint16_t )1714, 
                (uint16_t )1873,          (uint16_t )1307}, 
     {          (uint16_t )406,          (uint16_t )414,          (uint16_t )1030,          (uint16_t )1023, 
                (uint16_t )1910,          (uint16_t )1404,          (uint16_t )1313,          (uint16_t )1647, 
                (uint16_t )1509,          (uint16_t )793}, 
     {          (uint16_t )342,          (uint16_t )640,          (uint16_t )575,          (uint16_t )1088, 
                (uint16_t )1241,          (uint16_t )1349,          (uint16_t )1161,          (uint16_t )1350, 
                (uint16_t )1756,          (uint16_t )1502}, 
     {          (uint16_t )559,          (uint16_t )766,          (uint16_t )1185,          (uint16_t )357, 
                (uint16_t )1682,          (uint16_t )1428,          (uint16_t )1329,          (uint16_t )1897, 
                (uint16_t )1219,          (uint16_t )802}, 
     {          (uint16_t )473,          (uint16_t )909,          (uint16_t )1164,          (uint16_t )771, 
                (uint16_t )719,          (uint16_t )2508,          (uint16_t )1427,          (uint16_t )1432, 
                (uint16_t )722,          (uint16_t )782}, 
     {          (uint16_t )342,          (uint16_t )892,          (uint16_t )785,          (uint16_t )1145, 
                (uint16_t )1150,          (uint16_t )794,          (uint16_t )1296,          (uint16_t )1550, 
                (uint16_t )973,          (uint16_t )1057}, 
     {          (uint16_t )208,          (uint16_t )1036,          (uint16_t )1326,          (uint16_t )1343, 
                (uint16_t )1606,          (uint16_t )3395,          (uint16_t )815,          (uint16_t )1455, 
                (uint16_t )1618,          (uint16_t )712}, 
     {          (uint16_t )228,          (uint16_t )928,          (uint16_t )890,          (uint16_t )1046, 
                (uint16_t )3499,          (uint16_t )1711,          (uint16_t )994,          (uint16_t )829, 
                (uint16_t )1720,          (uint16_t )1318}, 
     {          (uint16_t )768,          (uint16_t )724,          (uint16_t )1058,          (uint16_t )636, 
                (uint16_t )991,          (uint16_t )1075,          (uint16_t )1319,          (uint16_t )1324, 
                (uint16_t )616,          (uint16_t )825}, 
     {          (uint16_t )305,          (uint16_t )1167,          (uint16_t )1358,          (uint16_t )899, 
                (uint16_t )1587,          (uint16_t )1587,          (uint16_t )987,          (uint16_t )1988, 
                (uint16_t )1332,          (uint16_t )501}}};
#line 206 "/root/patron-new/new_3/src/enc/cost_enc.c"
void VP8InitResidual(int first , int coeff_type , VP8Encoder *enc , VP8Residual *res ) 
{ 


  {
#line 208
  res->coeff_type = coeff_type;
#line 209
  res->prob = enc->proba_.coeffs_[coeff_type];
#line 210
  res->stats = enc->proba_.stats_[coeff_type];
#line 211
  res->costs = enc->proba_.remapped_costs_[coeff_type];
#line 212
  res->first = first;
#line 213
  return;
}
}
#line 218 "/root/patron-new/new_3/src/enc/cost_enc.c"
int VP8GetCostLuma4(VP8EncIterator *it , int16_t *levels ) 
{ 
  int x ;
  int y ;
  VP8Residual res ;
  VP8Encoder *enc ;
  int R ;
  int ctx ;
  int __cil_tmp9 ;

  {
  {
#line 219
  x = it->i4_ & 3;
#line 219
  y = it->i4_ >> 2;
#line 221
  enc = it->enc_;
#line 222
  R = 0;
#line 225
  VP8InitResidual(0, 3, enc, & res);
#line 226
  ctx = it->top_nz_[x] + it->left_nz_[y];
#line 227
  (*VP8SetResidualCoeffs)((int16_t */* const  */)levels, (struct VP8Residual */* const  */)(& res));
#line 228
  __cil_tmp9 = (*VP8GetResidualCost)(ctx, (struct VP8Residual */* const  */)(& res));
#line 228
  R += __cil_tmp9;
  }
#line 229
  return (R);
}
}
#line 232 "/root/patron-new/new_3/src/enc/cost_enc.c"
int VP8GetCostLuma16(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Residual res ;
  VP8Encoder *enc ;
  int x ;
  int y ;
  int R ;
  int __cil_tmp8 ;
  int ctx ;
  int __cil_tmp10 ;

  {
  {
#line 234
  enc = it->enc_;
#line 236
  R = 0;
#line 238
  VP8IteratorNzToBytes(it);
#line 241
  VP8InitResidual(0, 1, enc, & res);
#line 242
  (*VP8SetResidualCoeffs)((int16_t */* const  */)(rd->y_dc_levels), (struct VP8Residual */* const  */)(& res));
#line 243
  __cil_tmp8 = (*VP8GetResidualCost)(it->top_nz_[8] + it->left_nz_[8], (struct VP8Residual */* const  */)(& res));
#line 243
  R += __cil_tmp8;
#line 246
  VP8InitResidual(1, 0, enc, & res);
#line 247
  y = 0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;

#line 247
    if (! (y < 4)) {
#line 247
      goto while_break;
    }
#line 248
    x = 0;
    {
#line 248
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 248
      if (! (x < 4)) {
#line 248
        goto while_break___0;
      }
      {
#line 249
      ctx = it->top_nz_[x] + it->left_nz_[y];
#line 250
      (*VP8SetResidualCoeffs)((int16_t */* const  */)(rd->y_ac_levels[x + y * 4]),
                              (struct VP8Residual */* const  */)(& res));
#line 251
      __cil_tmp10 = (*VP8GetResidualCost)(ctx, (struct VP8Residual */* const  */)(& res));
#line 251
      R += __cil_tmp10;
#line 252
      it->left_nz_[y] = res.last >= 0;
#line 252
      it->top_nz_[x] = it->left_nz_[y];
#line 248
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 247
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 255
  return (R);
}
}
#line 258 "/root/patron-new/new_3/src/enc/cost_enc.c"
int VP8GetCostUV(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Residual res ;
  VP8Encoder *enc ;
  int ch ;
  int x ;
  int y ;
  int R ;
  int ctx ;
  int __cil_tmp10 ;

  {
  {
#line 260
  enc = it->enc_;
#line 262
  R = 0;
#line 264
  VP8IteratorNzToBytes(it);
#line 266
  VP8InitResidual(0, 2, enc, & res);
#line 267
  ch = 0;
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;

#line 267
    if (! (ch <= 2)) {
#line 267
      goto while_break;
    }
#line 268
    y = 0;
    {
#line 268
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 268
      if (! (y < 2)) {
#line 268
        goto while_break___0;
      }
#line 269
      x = 0;
      {
#line 269
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 269
        if (! (x < 2)) {
#line 269
          goto while_break___1;
        }
        {
#line 270
        ctx = it->top_nz_[(4 + ch) + x] + it->left_nz_[(4 + ch) + y];
#line 271
        (*VP8SetResidualCoeffs)((int16_t */* const  */)(rd->uv_levels[(ch * 2 + x) + y * 2]),
                                (struct VP8Residual */* const  */)(& res));
#line 272
        __cil_tmp10 = (*VP8GetResidualCost)(ctx, (struct VP8Residual */* const  */)(& res));
#line 272
        R += __cil_tmp10;
#line 273
        it->left_nz_[(4 + ch) + y] = res.last >= 0;
#line 273
        it->top_nz_[(4 + ch) + x] = it->left_nz_[(4 + ch) + y];
#line 269
        x ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 268
      y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 267
    ch += 2;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 277
  return (R);
}
}
#line 289 "/root/patron-new/new_3/src/enc/cost_enc.c"
int VP8RecordCoeffs(int ctx , VP8Residual *res ) 
{ 
  int n ;
  proba_t *s ;
  int v ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int bits ;
  int pattern ;
  int i ;
  int mask ;

  {
#line 290
  n = res->first;
#line 292
  s = (*(res->stats + n))[ctx];
#line 293
  if (res->last < 0) {
    {
#line 294
    VP8RecordStats(0, s + 0);
    }
#line 295
    return (0);
  }
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;

#line 297
    if (! (n <= res->last)) {
#line 297
      goto while_break;
    }
    {
#line 299
    VP8RecordStats(1, s + 0);
    }
    {
#line 300
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 300
      __cil_tmp6 = n;
#line 300
      n ++;
#line 300
      v = (int )*(res->coeffs + __cil_tmp6);
#line 300
      if (! (v == 0)) {
#line 300
        goto while_break___0;
      }
      {
#line 301
      VP8RecordStats(0, s + 1);
#line 302
      s = (*(res->stats + (int )VP8EncBands[n]))[0];
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 304
    VP8RecordStats(1, s + 1);
#line 305
    __cil_tmp7 = VP8RecordStats(2U < (unsigned int )(v + 1), s + 2);
    }
#line 305
    if (! __cil_tmp7) {
#line 306
      s = (*(res->stats + (int )VP8EncBands[n]))[1];
    } else {
      {
#line 308
      v = abs(v);
      }
#line 321
      if (v > 67) {
#line 322
        v = 67;
      }
#line 326
      bits = (int )VP8LevelCodes[v - 1][1];
#line 327
      pattern = (int )VP8LevelCodes[v - 1][0];
#line 329
      i = 0;
      {
#line 329
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 329
        if (! (pattern != 0)) {
#line 329
          goto while_break___1;
        }
#line 330
        mask = 2 << i;
#line 331
        if (pattern & 1) {
          {
#line 331
          VP8RecordStats(! (! (bits & mask)), (s + 3) + i);
          }
        }
#line 329
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 335
      s = (*(res->stats + (int )VP8EncBands[n]))[2];
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 338
  if (n < 16) {
    {
#line 338
    VP8RecordStats(0, s + 0);
    }
  }
#line 339
  return (1);
}
}
#line 24 "/root/patron-new/new_3/src/enc/config_enc.c"
int WebPConfigInitInternal(WebPConfig *config , WebPPreset preset , float quality ,
                           int version ) 
{ 
  int __cil_tmp5 ;

  {
#line 26
  if (version >> 8 != 527 >> 8) {
#line 27
    return (0);
  }
#line 29
  if ((unsigned long )config == (unsigned long )((void *)0)) {
#line 29
    return (0);
  }
#line 31
  config->quality = quality;
#line 32
  config->target_size = 0;
#line 33
  config->target_PSNR = (float )0.;
#line 34
  config->method = 4;
#line 35
  config->sns_strength = 50;
#line 36
  config->filter_strength = 60;
#line 37
  config->filter_sharpness = 0;
#line 38
  config->filter_type = 1;
#line 39
  config->partitions = 0;
#line 40
  config->segments = 4;
#line 41
  config->pass = 1;
#line 42
  config->qmin = 0;
#line 43
  config->qmax = 100;
#line 44
  config->show_compressed = 0;
#line 45
  config->preprocessing = 0;
#line 46
  config->autofilter = 0;
#line 47
  config->partition_limit = 0;
#line 48
  config->alpha_compression = 1;
#line 49
  config->alpha_filtering = 1;
#line 50
  config->alpha_quality = 100;
#line 51
  config->lossless = 0;
#line 52
  config->exact = 0;
#line 53
  config->image_hint = (WebPImageHint )0;
#line 54
  config->emulate_jpeg_size = 0;
#line 55
  config->thread_level = 0;
#line 56
  config->low_memory = 0;
#line 57
  config->near_lossless = 100;
#line 58
  config->use_delta_palette = 0;
#line 59
  config->use_sharp_yuv = 0;
#line 63
  if ((unsigned int )preset == 1U) {
#line 63
    goto case_1;
  }
#line 69
  if ((unsigned int )preset == 2U) {
#line 69
    goto case_2;
  }
#line 75
  if ((unsigned int )preset == 3U) {
#line 75
    goto case_3;
  }
#line 80
  if ((unsigned int )preset == 4U) {
#line 80
    goto case_4;
  }
#line 85
  if ((unsigned int )preset == 5U) {
#line 85
    goto case_5;
  }
#line 92
  goto switch_default;
  case_1: 
#line 64
  config->sns_strength = 80;
#line 65
  config->filter_sharpness = 4;
#line 66
  config->filter_strength = 35;
#line 67
  config->preprocessing &= -3;
#line 68
  goto switch_break;
  case_2: 
#line 70
  config->sns_strength = 80;
#line 71
  config->filter_sharpness = 3;
#line 72
  config->filter_strength = 30;
#line 73
  config->preprocessing |= 2;
#line 74
  goto switch_break;
  case_3: 
#line 76
  config->sns_strength = 25;
#line 77
  config->filter_sharpness = 6;
#line 78
  config->filter_strength = 10;
#line 79
  goto switch_break;
  case_4: 
#line 81
  config->sns_strength = 0;
#line 82
  config->filter_strength = 0;
#line 83
  config->preprocessing &= -3;
#line 84
  goto switch_break;
  case_5: 
#line 86
  config->sns_strength = 0;
#line 87
  config->filter_strength = 0;
#line 88
  config->preprocessing &= -3;
#line 89
  config->segments = 2;
#line 90
  goto switch_break;
  switch_default: 
#line 93
  goto switch_break;
  switch_break: 
  {
#line 95
  __cil_tmp5 = WebPValidateConfig(config);
  }
#line 95
  return (__cil_tmp5);
}
}
#line 98 "/root/patron-new/new_3/src/enc/config_enc.c"
int WebPValidateConfig(WebPConfig *config ) 
{ 


  {
#line 99
  if ((unsigned long )config == (unsigned long )((void *)0)) {
#line 99
    return (0);
  }
#line 100
  if (config->quality < (float )0) {
#line 100
    return (0);
  } else
#line 100
  if (config->quality > (float )100) {
#line 100
    return (0);
  }
#line 101
  if (config->target_size < 0) {
#line 101
    return (0);
  }
#line 102
  if (config->target_PSNR < (float )0) {
#line 102
    return (0);
  }
#line 103
  if (config->method < 0) {
#line 103
    return (0);
  } else
#line 103
  if (config->method > 6) {
#line 103
    return (0);
  }
#line 104
  if (config->segments < 1) {
#line 104
    return (0);
  } else
#line 104
  if (config->segments > 4) {
#line 104
    return (0);
  }
#line 105
  if (config->sns_strength < 0) {
#line 105
    return (0);
  } else
#line 105
  if (config->sns_strength > 100) {
#line 105
    return (0);
  }
#line 106
  if (config->filter_strength < 0) {
#line 106
    return (0);
  } else
#line 106
  if (config->filter_strength > 100) {
#line 106
    return (0);
  }
#line 107
  if (config->filter_sharpness < 0) {
#line 107
    return (0);
  } else
#line 107
  if (config->filter_sharpness > 7) {
#line 107
    return (0);
  }
#line 108
  if (config->filter_type < 0) {
#line 108
    return (0);
  } else
#line 108
  if (config->filter_type > 1) {
#line 108
    return (0);
  }
#line 109
  if (config->autofilter < 0) {
#line 109
    return (0);
  } else
#line 109
  if (config->autofilter > 1) {
#line 109
    return (0);
  }
#line 110
  if (config->pass < 1) {
#line 110
    return (0);
  } else
#line 110
  if (config->pass > 10) {
#line 110
    return (0);
  }
#line 111
  if (config->qmin < 0) {
#line 112
    return (0);
  } else
#line 111
  if (config->qmax > 100) {
#line 112
    return (0);
  } else
#line 111
  if (config->qmin > config->qmax) {
#line 112
    return (0);
  }
#line 114
  if (config->show_compressed < 0) {
#line 114
    return (0);
  } else
#line 114
  if (config->show_compressed > 1) {
#line 114
    return (0);
  }
#line 115
  if (config->preprocessing < 0) {
#line 115
    return (0);
  } else
#line 115
  if (config->preprocessing > 7) {
#line 115
    return (0);
  }
#line 116
  if (config->partitions < 0) {
#line 116
    return (0);
  } else
#line 116
  if (config->partitions > 3) {
#line 116
    return (0);
  }
#line 117
  if (config->partition_limit < 0) {
#line 117
    return (0);
  } else
#line 117
  if (config->partition_limit > 100) {
#line 117
    return (0);
  }
#line 118
  if (config->alpha_compression < 0) {
#line 118
    return (0);
  }
#line 119
  if (config->alpha_filtering < 0) {
#line 119
    return (0);
  }
#line 120
  if (config->alpha_quality < 0) {
#line 120
    return (0);
  } else
#line 120
  if (config->alpha_quality > 100) {
#line 120
    return (0);
  }
#line 121
  if (config->lossless < 0) {
#line 121
    return (0);
  } else
#line 121
  if (config->lossless > 1) {
#line 121
    return (0);
  }
#line 122
  if (config->near_lossless < 0) {
#line 122
    return (0);
  } else
#line 122
  if (config->near_lossless > 100) {
#line 122
    return (0);
  }
#line 123
  if ((unsigned int )config->image_hint >= 4U) {
#line 123
    return (0);
  }
#line 124
  if (config->emulate_jpeg_size < 0) {
#line 124
    return (0);
  } else
#line 124
  if (config->emulate_jpeg_size > 1) {
#line 124
    return (0);
  }
#line 125
  if (config->thread_level < 0) {
#line 125
    return (0);
  } else
#line 125
  if (config->thread_level > 1) {
#line 125
    return (0);
  }
#line 126
  if (config->low_memory < 0) {
#line 126
    return (0);
  } else
#line 126
  if (config->low_memory > 1) {
#line 126
    return (0);
  }
#line 127
  if (config->exact < 0) {
#line 127
    return (0);
  } else
#line 127
  if (config->exact > 1) {
#line 127
    return (0);
  }
#line 128
  if (config->use_delta_palette < 0) {
#line 129
    return (0);
  } else
#line 128
  if (config->use_delta_palette > 1) {
#line 129
    return (0);
  }
#line 131
  if (config->use_sharp_yuv < 0) {
#line 131
    return (0);
  } else
#line 131
  if (config->use_sharp_yuv > 1) {
#line 131
    return (0);
  }
#line 133
  return (1);
}
}
#line 144 "/root/patron-new/new_3/src/enc/config_enc.c"
static struct __anonstruct_809 kLosslessPresets[10]  = 
#line 144
  {      {(uint8_t )0, (uint8_t )0}, 
        {(uint8_t )1, (uint8_t )20}, 
        {(uint8_t )2, (uint8_t )25}, 
        {(uint8_t )3, (uint8_t )30}, 
        {(uint8_t )3, (uint8_t )50}, 
        {(uint8_t )4, (uint8_t )50}, 
        {(uint8_t )4, (uint8_t )75}, 
        {(uint8_t )4, (uint8_t )90}, 
        {(uint8_t )5, (uint8_t )90}, 
        {(uint8_t )6, (uint8_t )100}};
#line 149 "/root/patron-new/new_3/src/enc/config_enc.c"
int WebPConfigLosslessPreset(WebPConfig *config , int level ) 
{ 


  {
#line 150
  if ((unsigned long )config == (unsigned long )((void *)0)) {
#line 150
    return (0);
  } else
#line 150
  if (level < 0) {
#line 150
    return (0);
  } else
#line 150
  if (level > 9) {
#line 150
    return (0);
  }
#line 151
  config->lossless = 1;
#line 152
  config->method = (int )kLosslessPresets[level].method_;
#line 153
  config->quality = (float )kLosslessPresets[level].quality_;
#line 154
  return (1);
}
}
#line 34 "../../src/utils/color_cache_utils.h"
static uint32_t kHashMul___1  =    506832829U;
#line 37 "../../src/utils/color_cache_utils.h"
__inline static int VP8LHashPix___1(uint32_t argb , int shift ) 
{ 


  {
#line 38
  return ((int )(argb * kHashMul___1 >> shift));
}
}
#line 53 "../../src/utils/color_cache_utils.h"
__inline static void VP8LColorCacheInsert___1(VP8LColorCache *cc , uint32_t argb ) 
{ 
  int key ;
  int __cil_tmp4 ;

  {
  {
#line 55
  __cil_tmp4 = VP8LHashPix___1(argb, cc->hash_shift_);
#line 55
  key = __cil_tmp4;
#line 56
  *(cc->colors_ + key) = argb;
  }
#line 58
  return;
}
}
#line 59 "../../src/utils/color_cache_utils.h"
__inline static int VP8LColorCacheGetIndex___1(VP8LColorCache *cc , uint32_t argb ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 61
  __cil_tmp3 = VP8LHashPix___1(argb, cc->hash_shift_);
  }
#line 61
  return (__cil_tmp3);
}
}
#line 65 "../../src/utils/color_cache_utils.h"
__inline static int VP8LColorCacheContains___1(VP8LColorCache *cc , uint32_t argb ) 
{ 
  int key ;
  int __cil_tmp4 ;
  int tmp ;

  {
  {
#line 67
  __cil_tmp4 = VP8LHashPix___1(argb, cc->hash_shift_);
#line 67
  key = __cil_tmp4;
  }
#line 68
  if (*(cc->colors_ + key) == argb) {
#line 68
    tmp = key;
  } else {
#line 68
    tmp = -1;
  }
#line 68
  return (tmp);
}
}
#line 38 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static uint8_t plane_to_code_lut[128]  = 
#line 38 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
  {      (uint8_t )96,      (uint8_t )73,      (uint8_t )55,      (uint8_t )39, 
        (uint8_t )23,      (uint8_t )13,      (uint8_t )5,      (uint8_t )1, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )101,      (uint8_t )78,      (uint8_t )58,      (uint8_t )42, 
        (uint8_t )26,      (uint8_t )16,      (uint8_t )8,      (uint8_t )2, 
        (uint8_t )0,      (uint8_t )3,      (uint8_t )9,      (uint8_t )17, 
        (uint8_t )27,      (uint8_t )43,      (uint8_t )59,      (uint8_t )79, 
        (uint8_t )102,      (uint8_t )86,      (uint8_t )62,      (uint8_t )46, 
        (uint8_t )32,      (uint8_t )20,      (uint8_t )10,      (uint8_t )6, 
        (uint8_t )4,      (uint8_t )7,      (uint8_t )11,      (uint8_t )21, 
        (uint8_t )33,      (uint8_t )47,      (uint8_t )63,      (uint8_t )87, 
        (uint8_t )105,      (uint8_t )90,      (uint8_t )70,      (uint8_t )52, 
        (uint8_t )37,      (uint8_t )28,      (uint8_t )18,      (uint8_t )14, 
        (uint8_t )12,      (uint8_t )15,      (uint8_t )19,      (uint8_t )29, 
        (uint8_t )38,      (uint8_t )53,      (uint8_t )71,      (uint8_t )91, 
        (uint8_t )110,      (uint8_t )99,      (uint8_t )82,      (uint8_t )66, 
        (uint8_t )48,      (uint8_t )35,      (uint8_t )30,      (uint8_t )24, 
        (uint8_t )22,      (uint8_t )25,      (uint8_t )31,      (uint8_t )36, 
        (uint8_t )49,      (uint8_t )67,      (uint8_t )83,      (uint8_t )100, 
        (uint8_t )115,      (uint8_t )108,      (uint8_t )94,      (uint8_t )76, 
        (uint8_t )64,      (uint8_t )50,      (uint8_t )44,      (uint8_t )40, 
        (uint8_t )34,      (uint8_t )41,      (uint8_t )45,      (uint8_t )51, 
        (uint8_t )65,      (uint8_t )77,      (uint8_t )95,      (uint8_t )109, 
        (uint8_t )118,      (uint8_t )113,      (uint8_t )103,      (uint8_t )92, 
        (uint8_t )80,      (uint8_t )68,      (uint8_t )60,      (uint8_t )56, 
        (uint8_t )54,      (uint8_t )57,      (uint8_t )61,      (uint8_t )69, 
        (uint8_t )81,      (uint8_t )93,      (uint8_t )104,      (uint8_t )114, 
        (uint8_t )119,      (uint8_t )116,      (uint8_t )111,      (uint8_t )106, 
        (uint8_t )97,      (uint8_t )88,      (uint8_t )84,      (uint8_t )74, 
        (uint8_t )72,      (uint8_t )75,      (uint8_t )85,      (uint8_t )89, 
        (uint8_t )98,      (uint8_t )107,      (uint8_t )112,      (uint8_t )117};
#line 49
int VP8LDistanceToPlaneCode(int xsize , int dist ) ;
#line 50 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
int VP8LDistanceToPlaneCode(int xsize , int dist ) 
{ 
  int yoffset ;
  int xoffset ;

  {
#line 51
  yoffset = dist / xsize;
#line 52
  xoffset = dist - yoffset * xsize;
#line 53
  if (xoffset <= 8) {
#line 53
    if (yoffset < 8) {
#line 54
      return ((int )plane_to_code_lut[(yoffset * 16 + 8) - xoffset] + 1);
    } else {
#line 53
      goto _L;
    }
  } else
  _L: 
#line 55
  if (xoffset > xsize - 8) {
#line 55
    if (yoffset < 7) {
#line 56
      return ((int )plane_to_code_lut[((yoffset + 1) * 16 + 8) + (xsize - xoffset)] + 1);
    }
  }
#line 58
  return (dist + 120);
}
}
#line 66 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
__inline static int FindMatchLength(uint32_t *array1 , uint32_t *array2 , int best_len_match ,
                                    int max_limit ) 
{ 
  int __cil_tmp5 ;

  {
#line 71
  if (*(array1 + best_len_match) != *(array2 + best_len_match)) {
#line 71
    return (0);
  }
  {
#line 73
  __cil_tmp5 = (*VP8LVectorMismatch)((uint32_t */* const  */)array1, (uint32_t */* const  */)array2,
                                     max_limit);
  }
#line 73
  return (__cil_tmp5);
}
}
#line 85
void VP8LClearBackwardRefs(VP8LBackwardRefs *refs ) ;
#line 86 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
void VP8LClearBackwardRefs(VP8LBackwardRefs *refs ) 
{ 


  {
#line 88
  if ((unsigned long )refs->tail_ != (unsigned long )((void *)0)) {
#line 89
    *(refs->tail_) = refs->free_blocks_;
  }
#line 91
  refs->free_blocks_ = refs->refs_;
#line 92
  refs->tail_ = & refs->refs_;
#line 93
  refs->last_block_ = (PixOrCopyBlock *)((void *)0);
#line 94
  refs->refs_ = (PixOrCopyBlock *)((void *)0);
#line 95
  return;
}
}
#line 97 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
void VP8LBackwardRefsClear(VP8LBackwardRefs *refs ) 
{ 
  PixOrCopyBlock *next ;

  {
  {
#line 99
  VP8LClearBackwardRefs(refs);
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;

#line 100
    if (! ((unsigned long )refs->free_blocks_ != (unsigned long )((void *)0))) {
#line 100
      goto while_break;
    }
    {
#line 101
    next = (refs->free_blocks_)->next_;
#line 102
    WebPSafeFree((void *)refs->free_blocks_);
#line 103
    refs->free_blocks_ = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 108
  return;
}
}
#line 108 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static void BackwardRefsSwap(VP8LBackwardRefs *refs1 , VP8LBackwardRefs *refs2 ) 
{ 
  int point_to_refs1 ;
  int point_to_refs2 ;
  VP8LBackwardRefs tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 110
  if ((unsigned long )refs1->tail_ != (unsigned long )((void *)0)) {
#line 110
    if ((unsigned long )refs1->tail_ == (unsigned long )(& refs1->refs_)) {
#line 110
      tmp___0 = 1;
    } else {
#line 110
      tmp___0 = 0;
    }
  } else {
#line 110
    tmp___0 = 0;
  }
#line 110
  point_to_refs1 = tmp___0;
#line 112
  if ((unsigned long )refs2->tail_ != (unsigned long )((void *)0)) {
#line 112
    if ((unsigned long )refs2->tail_ == (unsigned long )(& refs2->refs_)) {
#line 112
      tmp___1 = 1;
    } else {
#line 112
      tmp___1 = 0;
    }
  } else {
#line 112
    tmp___1 = 0;
  }
#line 112
  point_to_refs2 = tmp___1;
#line 114
  tmp = *refs1;
#line 115
  *refs1 = *refs2;
#line 116
  *refs2 = tmp;
#line 117
  if (point_to_refs2) {
#line 117
    refs1->tail_ = & refs1->refs_;
  }
#line 118
  if (point_to_refs1) {
#line 118
    refs2->tail_ = & refs2->refs_;
  }
#line 120
  return;
}
}
#line 121 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
void VP8LBackwardRefsInit(VP8LBackwardRefs *refs , int block_size ) 
{ 
  int tmp ;

  {
  {
#line 123
  memset((void *)refs, 0, sizeof(*refs));
#line 124
  refs->tail_ = & refs->refs_;
  }
#line 125
  if (block_size < 256) {
#line 125
    tmp = 256;
  } else {
#line 125
    tmp = block_size;
  }
#line 125
  refs->block_size_ = tmp;
#line 126
  return;
}
}
#line 129 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
VP8LRefsCursor VP8LRefsCursorInit(VP8LBackwardRefs *refs ) 
{ 
  VP8LRefsCursor c ;

  {
#line 131
  c.cur_block_ = refs->refs_;
#line 132
  if ((unsigned long )refs->refs_ != (unsigned long )((void *)0)) {
#line 133
    c.cur_pos = (c.cur_block_)->start_;
#line 134
    c.last_pos_ = c.cur_pos + (c.cur_block_)->size_;
  } else {
#line 136
    c.cur_pos = (PixOrCopy *)((void *)0);
#line 137
    c.last_pos_ = (PixOrCopy *)((void *)0);
  }
#line 139
  return (c);
}
}
#line 142 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
void VP8LRefsCursorNextBlock(VP8LRefsCursor *c ) 
{ 
  PixOrCopyBlock *b ;
  PixOrCopy *tmp ;
  PixOrCopy *tmp___0 ;

  {
#line 143
  b = (c->cur_block_)->next_;
#line 144
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 144
    tmp = (PixOrCopy *)((void *)0);
  } else {
#line 144
    tmp = b->start_;
  }
#line 144
  c->cur_pos = tmp;
#line 145
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 145
    tmp___0 = (PixOrCopy *)((void *)0);
  } else {
#line 145
    tmp___0 = b->start_ + b->size_;
  }
#line 145
  c->last_pos_ = tmp___0;
#line 146
  c->cur_block_ = b;
#line 147
  return;
}
}
#line 150 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static PixOrCopyBlock *BackwardRefsNewBlock(VP8LBackwardRefs *refs ) 
{ 
  PixOrCopyBlock *b ;
  size_t total_size ;
  void *__cil_tmp4 ;

  {
#line 151
  b = refs->free_blocks_;
#line 152
  if ((unsigned long )b == (unsigned long )((void *)0)) {
    {
#line 153
    total_size = sizeof(*b) + (unsigned long )refs->block_size_ * sizeof(*(b->start_));
#line 155
    __cil_tmp4 = WebPSafeMalloc((uint64_t )1ULL, total_size);
#line 155
    b = (PixOrCopyBlock *)__cil_tmp4;
    }
#line 156
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 157
      refs->error_ |= 1;
#line 158
      return ((PixOrCopyBlock *)((void *)0));
    }
#line 160
    b->start_ = (PixOrCopy *)((uint8_t *)b + sizeof(*b));
  } else {
#line 162
    refs->free_blocks_ = b->next_;
  }
#line 164
  *(refs->tail_) = b;
#line 165
  refs->tail_ = & b->next_;
#line 166
  refs->last_block_ = b;
#line 167
  b->next_ = (PixOrCopyBlock *)((void *)0);
#line 168
  b->size_ = 0;
#line 169
  return (b);
}
}
#line 173 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static int BackwardRefsClone(VP8LBackwardRefs *from , VP8LBackwardRefs *to ) 
{ 
  PixOrCopyBlock *block_from ;
  PixOrCopyBlock *block_to ;
  PixOrCopyBlock *__cil_tmp5 ;

  {
  {
#line 175
  block_from = from->refs_;
#line 176
  VP8LClearBackwardRefs(to);
  }
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;

#line 177
    if (! ((unsigned long )block_from != (unsigned long )((void *)0))) {
#line 177
      goto while_break;
    }
    {
#line 178
    __cil_tmp5 = BackwardRefsNewBlock(to);
#line 178
    block_to = __cil_tmp5;
    }
#line 179
    if ((unsigned long )block_to == (unsigned long )((void *)0)) {
#line 179
      return (0);
    }
    {
#line 180
    memcpy((void *)block_to->start_, (void const   *)block_from->start_, (unsigned long )block_from->size_ * sizeof(PixOrCopy ));
#line 182
    block_to->size_ = block_from->size_;
#line 183
    block_from = block_from->next_;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 185
  return (1);
}
}
#line 188
void VP8LBackwardRefsCursorAdd(VP8LBackwardRefs *refs , PixOrCopy v ) ;
#line 190 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
void VP8LBackwardRefsCursorAdd(VP8LBackwardRefs *refs , PixOrCopy v ) 
{ 
  PixOrCopyBlock *b ;
  int __cil_tmp5 ;

  {
#line 192
  b = refs->last_block_;
#line 193
  if ((unsigned long )b == (unsigned long )((void *)0)) {
    _L: 
    {
#line 194
    b = BackwardRefsNewBlock(refs);
    }
#line 195
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 195
      return;
    }
  } else
#line 193
  if (b->size_ == refs->block_size_) {
#line 193
    goto _L;
  }
#line 197
  __cil_tmp5 = b->size_;
#line 197
  (b->size_) ++;
#line 197
  *(b->start_ + __cil_tmp5) = v;
#line 198
  return;
}
}
#line 203 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
int VP8LHashChainInit(VP8LHashChain *p , int size ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 207
  __cil_tmp3 = WebPSafeMalloc((uint64_t )size, sizeof(*(p->offset_length_)));
#line 207
  p->offset_length_ = (uint32_t *)__cil_tmp3;
  }
#line 209
  if ((unsigned long )p->offset_length_ == (unsigned long )((void *)0)) {
#line 209
    return (0);
  }
#line 210
  p->size_ = size;
#line 212
  return (1);
}
}
#line 215 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
void VP8LHashChainClear(VP8LHashChain *p ) 
{ 


  {
  {
#line 217
  WebPSafeFree((void *)p->offset_length_);
#line 219
  p->size_ = 0;
#line 220
  p->offset_length_ = (uint32_t *)((void *)0);
  }
#line 222
  return;
}
}
#line 225 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static uint32_t kHashMultiplierHi  =    3332679571U;
#line 226 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static uint32_t kHashMultiplierLo  =    1540483478U;
#line 229 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
__inline static uint32_t GetPixPairHash64(uint32_t *argb ) 
{ 
  uint32_t key ;

  {
#line 231
  key = *(argb + 1) * kHashMultiplierHi;
#line 232
  key += *(argb + 0) * kHashMultiplierLo;
#line 233
  key >>= 14;
#line 234
  return (key);
}
}
#line 239 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static int GetMaxItersForQuality(int quality ) 
{ 


  {
#line 240
  return (8 + (quality * quality) / 128);
}
}
#line 243 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static int GetWindowSizeForHashChain(int quality , int xsize ) 
{ 
  int max_window_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 244
  if (quality > 75) {
#line 244
    tmp___1 = (1 << 20) - 120;
  } else {
#line 244
    if (quality > 50) {
#line 244
      tmp___0 = xsize << 8;
    } else {
#line 244
      if (quality > 25) {
#line 244
        tmp = xsize << 6;
      } else {
#line 244
        tmp = xsize << 4;
      }
#line 244
      tmp___0 = tmp;
    }
#line 244
    tmp___1 = tmp___0;
  }
#line 244
  max_window_size = tmp___1;
#line 249
  if (max_window_size > (1 << 20) - 120) {
#line 249
    tmp___2 = (1 << 20) - 120;
  } else {
#line 249
    tmp___2 = max_window_size;
  }
#line 249
  return (tmp___2);
}
}
#line 252 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
__inline static int MaxFindCopyLength(int len ) 
{ 
  int tmp ;

  {
#line 253
  if (len < (1 << 12) - 1) {
#line 253
    tmp = len;
  } else {
#line 253
    tmp = (1 << 12) - 1;
  }
#line 253
  return (tmp);
}
}
#line 256 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
int VP8LHashChainFill(VP8LHashChain *p , int quality , uint32_t *argb , int xsize ,
                      int ysize , int low_effort ) 
{ 
  int size ;
  int iter_max ;
  int __cil_tmp9 ;
  uint32_t window_size ;
  int __cil_tmp11 ;
  int pos ;
  int argb_comp ;
  uint32_t base_position ;
  int32_t *hash_to_first_index ;
  int32_t *chain ;
  void *__cil_tmp17 ;
  uint32_t hash_code ;
  int argb_comp_next ;
  uint32_t tmp[2] ;
  uint32_t len ;
  uint32_t __cil_tmp22 ;
  int __cil_tmp24 ;
  int __cil_tmp26 ;
  int max_len ;
  int __cil_tmp29 ;
  uint32_t *argb_start ;
  int iter ;
  int best_length ;
  uint32_t best_distance ;
  uint32_t best_argb ;
  int min_pos ;
  uint32_t tmp___0 ;
  int length_max ;
  int tmp___1 ;
  uint32_t max_base_position ;
  int curr_length ;
  int curr_length___0 ;
  uint32_t tmp___2 ;

  {
  {
#line 259
  size = xsize * ysize;
#line 260
  __cil_tmp9 = GetMaxItersForQuality(quality);
#line 260
  iter_max = __cil_tmp9;
#line 261
  __cil_tmp11 = GetWindowSizeForHashChain(quality, xsize);
#line 261
  window_size = (uint32_t )__cil_tmp11;
#line 267
  chain = (int32_t *)p->offset_length_;
  }
#line 272
  if (size <= 2) {
#line 273
    *(p->offset_length_ + (size - 1)) = (uint32_t )0;
#line 273
    *(p->offset_length_ + 0) = *(p->offset_length_ + (size - 1));
#line 274
    return (1);
  }
  {
#line 277
  __cil_tmp17 = WebPSafeMalloc((uint64_t )(1 << 18), sizeof(*hash_to_first_index));
#line 277
  hash_to_first_index = (int32_t *)__cil_tmp17;
  }
#line 279
  if ((unsigned long )hash_to_first_index == (unsigned long )((void *)0)) {
#line 279
    return (0);
  }
  {
#line 282
  memset((void *)hash_to_first_index, 255, (unsigned long )(1 << 18) * sizeof(*hash_to_first_index));
#line 284
  argb_comp = *(argb + 0) == *(argb + 1);
#line 285
  pos = 0;
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;

#line 285
    if (! (pos < size - 2)) {
#line 285
      goto while_break;
    }
#line 287
    argb_comp_next = *(argb + (pos + 1)) == *(argb + (pos + 2));
#line 288
    if (argb_comp) {
#line 288
      if (argb_comp_next) {
#line 293
        len = (uint32_t )1;
#line 294
        tmp[0] = *(argb + pos);
        {
#line 299
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 299
          if ((pos + (int )len) + 2 < size) {
#line 299
            if (! (*(argb + (((unsigned int )pos + len) + 2U)) == *(argb + pos))) {
#line 299
              goto while_break___0;
            }
          } else {
#line 299
            goto while_break___0;
          }
#line 300
          len ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___0: ;
#line 302
        if (len > (unsigned int )((1 << 12) - 1)) {
          {
#line 307
          memset((void *)(chain + pos), 255, (unsigned long )(len - (unsigned int )((1 << 12) - 1)) * sizeof(*chain));
#line 308
          pos = (int )((uint32_t )pos + (len - (unsigned int )((1 << 12) - 1)));
#line 309
          len = (uint32_t )((1 << 12) - 1);
          }
        }
        {
#line 312
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 312
          if (! len) {
#line 312
            goto while_break___1;
          }
          {
#line 313
          __cil_tmp22 = len;
#line 313
          len --;
#line 313
          tmp[1] = __cil_tmp22;
#line 314
          hash_code = GetPixPairHash64(tmp);
#line 315
          *(chain + pos) = *(hash_to_first_index + hash_code);
#line 316
          __cil_tmp24 = pos;
#line 316
          pos ++;
#line 316
          *(hash_to_first_index + hash_code) = __cil_tmp24;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___1: 
#line 318
        argb_comp = 0;
      } else {
#line 288
        goto _L;
      }
    } else {
      _L: 
      {
#line 321
      hash_code = GetPixPairHash64(argb + pos);
#line 322
      *(chain + pos) = *(hash_to_first_index + hash_code);
#line 323
      __cil_tmp26 = pos;
#line 323
      pos ++;
#line 323
      *(hash_to_first_index + hash_code) = __cil_tmp26;
#line 324
      argb_comp = argb_comp_next;
      }
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
  {
#line 328
  tmp___2 = GetPixPairHash64(argb + pos);
#line 328
  *(chain + pos) = (int32_t )tmp___2;
#line 330
  WebPSafeFree((void *)hash_to_first_index);
#line 337
  *(p->offset_length_ + (size - 1)) = (uint32_t )0;
#line 337
  *(p->offset_length_ + 0) = *(p->offset_length_ + (size - 1));
#line 338
  base_position = (uint32_t )(size - 2);
  }
  {
#line 338
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 338
    if (! (base_position > 0U)) {
#line 338
      goto while_break___2;
    }
    {
#line 339
    __cil_tmp29 = MaxFindCopyLength((int )((unsigned int )(size - 1) - base_position));
#line 339
    max_len = __cil_tmp29;
#line 340
    argb_start = argb + base_position;
#line 341
    iter = iter_max;
#line 342
    best_length = 0;
#line 343
    best_distance = (uint32_t )0;
    }
#line 345
    if (base_position > window_size) {
#line 345
      tmp___0 = base_position - window_size;
    } else {
#line 345
      tmp___0 = 0U;
    }
#line 345
    min_pos = (int )tmp___0;
#line 347
    if (max_len < 256) {
#line 347
      tmp___1 = max_len;
    } else {
#line 347
      tmp___1 = 256;
    }
#line 347
    length_max = tmp___1;
#line 350
    pos = *(chain + base_position);
#line 351
    if (! low_effort) {
#line 354
      if (base_position >= (uint32_t )xsize) {
        {
#line 355
        curr_length = FindMatchLength(argb_start - xsize, argb_start, best_length,
                                      max_len);
        }
#line 357
        if (curr_length > best_length) {
#line 358
          best_length = curr_length;
#line 359
          best_distance = (uint32_t )xsize;
        }
#line 361
        iter --;
      }
      {
#line 364
      curr_length = FindMatchLength(argb_start - 1, argb_start, best_length, max_len);
      }
#line 366
      if (curr_length > best_length) {
#line 367
        best_length = curr_length;
#line 368
        best_distance = (uint32_t )1;
      }
#line 370
      iter --;
#line 372
      if (best_length == (1 << 12) - 1) {
#line 372
        pos = min_pos - 1;
      }
    }
#line 374
    best_argb = *(argb_start + best_length);
    {
#line 376
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___3: ;
#line 376
      if (pos >= min_pos) {
#line 376
        if (! iter) {
#line 376
          goto while_break___3;
        }
      } else {
#line 376
        goto while_break___3;
      }
#line 380
      if (*(argb + (pos + best_length)) != best_argb) {
#line 380
        goto while_continue___3;
      }
      {
#line 382
      curr_length___0 = (*VP8LVectorMismatch)((uint32_t */* const  */)(argb + pos),
                                              (uint32_t */* const  */)argb_start,
                                              max_len);
      }
#line 383
      if (best_length < curr_length___0) {
#line 384
        best_length = curr_length___0;
#line 385
        best_distance = base_position - (unsigned int )pos;
#line 386
        best_argb = *(argb_start + best_length);
#line 388
        if (best_length >= length_max) {
#line 388
          goto while_break___3;
        }
      }
#line 376
      pos = *(chain + pos);
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: 
#line 393
    max_base_position = base_position;
    {
#line 394
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 397
      *(p->offset_length_ + base_position) = (best_distance << 12) | (uint32_t )best_length;
#line 399
      base_position --;
#line 401
      if (best_distance == 0U) {
#line 401
        goto while_break___4;
      } else
#line 401
      if (base_position == 0U) {
#line 401
        goto while_break___4;
      }
#line 403
      if (base_position < best_distance) {
#line 405
        goto while_break___4;
      } else
#line 403
      if (*(argb + (base_position - best_distance)) != *(argb + base_position)) {
#line 405
        goto while_break___4;
      }
#line 411
      if (best_length == (1 << 12) - 1) {
#line 411
        if (best_distance != 1U) {
#line 411
          if (base_position + (unsigned int )((1 << 12) - 1) < max_base_position) {
#line 413
            goto while_break___4;
          }
        }
      }
#line 415
      if (best_length < (1 << 12) - 1) {
#line 416
        best_length ++;
#line 417
        max_base_position = base_position;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: ;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: ;
#line 421
  return (1);
}
}
#line 424 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
__inline static void AddSingleLiteral(uint32_t pixel , int use_color_cache , VP8LColorCache *hashers ,
                                      VP8LBackwardRefs *refs ) 
{ 
  PixOrCopy v ;
  uint32_t key ;
  int __cil_tmp7 ;
  uint32_t __cil_tmp8 ;

  {
#line 428
  if (use_color_cache) {
    {
#line 429
    __cil_tmp7 = VP8LColorCacheGetIndex___1(hashers, pixel);
#line 429
    key = (uint32_t )__cil_tmp7;
#line 430
    __cil_tmp8 = VP8LColorCacheLookup(hashers, key);
    }
#line 430
    if (__cil_tmp8 == pixel) {
      {
#line 431
      v = PixOrCopyCreateCacheIdx((int )key);
      }
    } else {
      {
#line 433
      v = PixOrCopyCreateLiteral(pixel);
#line 434
      VP8LColorCacheSet(hashers, key, pixel);
      }
    }
  } else {
    {
#line 437
    v = PixOrCopyCreateLiteral(pixel);
    }
  }
  {
#line 439
  VP8LBackwardRefsCursorAdd(refs, v);
  }
#line 441
  return;
}
}
#line 442 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static int BackwardReferencesRle(int xsize , int ysize , uint32_t *argb , int cache_bits ,
                                 VP8LBackwardRefs *refs ) 
{ 
  int pix_count ;
  int i ;
  int k ;
  int use_color_cache ;
  VP8LColorCache hashers ;
  int __cil_tmp11 ;
  int max_len ;
  int __cil_tmp13 ;
  int rle_len ;
  int __cil_tmp15 ;
  int prev_row_len ;
  int __cil_tmp17 ;
  int tmp ;
  PixOrCopy __cil_tmp19 ;
  PixOrCopy __cil_tmp20 ;

  {
  {
#line 445
  pix_count = xsize * ysize;
#line 447
  use_color_cache = cache_bits > 0;
#line 450
  __cil_tmp11 = VP8LColorCacheInit(& hashers, cache_bits);
  }
#line 450
  if (use_color_cache) {
#line 450
    if (! __cil_tmp11) {
#line 451
      return (0);
    }
  }
  {
#line 453
  VP8LClearBackwardRefs(refs);
#line 455
  AddSingleLiteral(*(argb + 0), use_color_cache, & hashers, refs);
#line 456
  i = 1;
  }
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;

#line 457
    if (! (i < pix_count)) {
#line 457
      goto while_break;
    }
    {
#line 458
    __cil_tmp13 = MaxFindCopyLength(pix_count - i);
#line 458
    max_len = __cil_tmp13;
#line 459
    __cil_tmp15 = FindMatchLength(argb + i, (argb + i) - 1, 0, max_len);
#line 459
    rle_len = __cil_tmp15;
    }
#line 460
    if (i < xsize) {
#line 460
      tmp = 0;
    } else {
      {
#line 460
      __cil_tmp17 = FindMatchLength(argb + i, (argb + i) - xsize, 0, max_len);
#line 460
      tmp = __cil_tmp17;
      }
    }
#line 460
    prev_row_len = tmp;
#line 462
    if (rle_len >= prev_row_len) {
#line 462
      if (rle_len >= 4) {
        {
#line 463
        __cil_tmp19 = PixOrCopyCreateCopy((uint32_t )1, (uint16_t )rle_len);
#line 463
        VP8LBackwardRefsCursorAdd(refs, __cil_tmp19);
#line 467
        i += rle_len;
        }
      } else {
#line 462
        goto _L;
      }
    } else
    _L: 
#line 468
    if (prev_row_len >= 4) {
      {
#line 469
      __cil_tmp20 = PixOrCopyCreateCopy((uint32_t )xsize, (uint16_t )prev_row_len);
#line 469
      VP8LBackwardRefsCursorAdd(refs, __cil_tmp20);
      }
#line 470
      if (use_color_cache) {
#line 471
        k = 0;
        {
#line 471
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 471
          if (! (k < prev_row_len)) {
#line 471
            goto while_break___0;
          }
          {
#line 472
          VP8LColorCacheInsert___1(& hashers, *(argb + (i + k)));
#line 471
          k ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: ;
      }
#line 475
      i += prev_row_len;
    } else {
      {
#line 477
      AddSingleLiteral(*(argb + i), use_color_cache, & hashers, refs);
#line 478
      i ++;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 481
  if (use_color_cache) {
    {
#line 481
    VP8LColorCacheClear(& hashers);
    }
  }
#line 482
  return (! refs->error_);
}
}
#line 485 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static int BackwardReferencesLz77(int xsize , int ysize , uint32_t *argb , int cache_bits ,
                                  VP8LHashChain *hash_chain , VP8LBackwardRefs *refs ) 
{ 
  int i ;
  int i_last_check ;
  int ok ;
  int cc_init ;
  int use_color_cache ;
  int pix_count ;
  VP8LColorCache hashers ;
  int offset ;
  int len ;
  int j ;
  int len_ini ;
  int max_reach ;
  int j_max ;
  int tmp ;
  int tmp___0 ;
  int len_j ;
  int __cil_tmp24 ;
  int reach ;
  int tmp___1 ;
  PixOrCopy __cil_tmp27 ;

  {
#line 490
  i_last_check = -1;
#line 491
  ok = 0;
#line 492
  cc_init = 0;
#line 493
  use_color_cache = cache_bits > 0;
#line 494
  pix_count = xsize * ysize;
#line 497
  if (use_color_cache) {
    {
#line 498
    cc_init = VP8LColorCacheInit(& hashers, cache_bits);
    }
#line 499
    if (! cc_init) {
#line 499
      goto Error;
    }
  }
  {
#line 501
  VP8LClearBackwardRefs(refs);
#line 502
  i = 0;
  }
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;

#line 502
    if (! (i < pix_count)) {
#line 502
      goto while_break;
    }
    {
#line 504
    offset = 0;
#line 505
    len = 0;
#line 507
    VP8LHashChainFindCopy(hash_chain, i, & offset, & len);
    }
#line 508
    if (len >= 4) {
#line 509
      len_ini = len;
#line 510
      max_reach = 0;
#line 511
      if (i + len_ini >= pix_count) {
#line 511
        tmp = pix_count - 1;
      } else {
#line 511
        tmp = i + len_ini;
      }
#line 511
      j_max = tmp;
#line 514
      if (i > i_last_check) {
#line 514
        tmp___0 = i;
      } else {
#line 514
        tmp___0 = i_last_check;
      }
#line 514
      i_last_check = tmp___0;
#line 521
      j = i_last_check + 1;
      {
#line 521
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 521
        if (! (j <= j_max)) {
#line 521
          goto while_break___0;
        }
        {
#line 522
        __cil_tmp24 = VP8LHashChainFindLength(hash_chain, j);
#line 522
        len_j = __cil_tmp24;
        }
#line 523
        if (len_j >= 4) {
#line 523
          tmp___1 = len_j;
        } else {
#line 523
          tmp___1 = 1;
        }
#line 523
        reach = j + tmp___1;
#line 525
        if (reach > max_reach) {
#line 526
          len = j - i;
#line 527
          max_reach = reach;
#line 528
          if (max_reach >= pix_count) {
#line 528
            goto while_break___0;
          }
        }
#line 521
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 532
      len = 1;
    }
#line 536
    if (len == 1) {
      {
#line 537
      AddSingleLiteral(*(argb + i), use_color_cache, & hashers, refs);
      }
    } else {
      {
#line 539
      __cil_tmp27 = PixOrCopyCreateCopy((uint32_t )offset, (uint16_t )len);
#line 539
      VP8LBackwardRefsCursorAdd(refs, __cil_tmp27);
      }
#line 540
      if (use_color_cache) {
#line 541
        j = i;
        {
#line 541
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 541
          if (! (j < i + len)) {
#line 541
            goto while_break___1;
          }
          {
#line 541
          VP8LColorCacheInsert___1(& hashers, *(argb + j));
#line 541
          j ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: ;
      }
    }
#line 544
    i += len;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 547
  ok = ! refs->error_;
  Error: 
#line 549
  if (cc_init) {
    {
#line 549
    VP8LColorCacheClear(& hashers);
    }
  }
#line 550
  return (ok);
}
}
#line 557 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static int BackwardReferencesLz77Box(int xsize , int ysize , uint32_t *argb , int cache_bits ,
                                     VP8LHashChain *hash_chain_best , VP8LHashChain *hash_chain ,
                                     VP8LBackwardRefs *refs ) 
{ 
  int i ;
  int pix_count ;
  uint16_t *counts ;
  int window_offsets[32] ;
  unsigned int tmp ;
  int window_offsets_new[32] ;
  unsigned int tmp___0 ;
  int window_offsets_size ;
  int window_offsets_new_size ;
  uint16_t *counts_ini ;
  void *__cil_tmp18 ;
  int best_offset_prev ;
  int best_length_prev ;
  int x ;
  int y ;
  int offset ;
  int plane_code ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int j ;
  int is_reachable ;
  int ind ;
  int best_length ;
  int __cil_tmp31 ;
  int best_offset ;
  int do_compute ;
  int use_prev ;
  int num_ind ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int curr_length ;
  int j___0 ;
  int j_offset ;
  int tmp___4 ;
  int counts_j_offset ;
  int counts_j ;
  int tmp___5 ;
  int tmp___6 ;
  int __cil_tmp48 ;
  int tmp___7 ;

  {
#line 563
  pix_count = xsize * ysize;
#line 565
  window_offsets[0] = 0;
#line 565
  tmp = 1U;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;

#line 565
    if (tmp >= 32U) {
#line 565
      goto while_break;
    }
#line 565
    window_offsets[tmp] = 0;
#line 565
    tmp ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break: 
#line 566
  window_offsets_new[0] = 0;
#line 566
  tmp___0 = 1U;
  {
#line 566
  while (1) {
    while_continue___10: /* CIL Label */ ;

#line 566
    if (tmp___0 >= 32U) {
#line 566
      goto while_break___0;
    }
#line 566
    window_offsets_new[tmp___0] = 0;
#line 566
    tmp___0 ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 567
  window_offsets_size = 0;
#line 568
  window_offsets_new_size = 0;
#line 569
  __cil_tmp18 = WebPSafeMalloc((uint64_t )(xsize * ysize), sizeof(*counts_ini));
#line 569
  counts_ini = (uint16_t *)__cil_tmp18;
#line 571
  best_offset_prev = -1;
#line 571
  best_length_prev = -1;
  }
#line 572
  if ((unsigned long )counts_ini == (unsigned long )((void *)0)) {
#line 572
    return (0);
  }
#line 575
  i = pix_count - 2;
#line 576
  counts = counts_ini + i;
#line 577
  *(counts + 1) = (uint16_t )1;
  {
#line 578
  while (1) {
    while_continue___11: /* CIL Label */ ;

#line 578
    if (! (i >= 0)) {
#line 578
      goto while_break___1;
    }
#line 579
    if (*(argb + i) == *(argb + (i + 1))) {
#line 581
      *(counts + 0) = (uint16_t )((int )*(counts + 1) + ((int )*(counts + 1) != (1 << 12) - 1));
    } else {
#line 583
      *(counts + 0) = (uint16_t )1;
    }
#line 578
    counts --;
#line 578
    i --;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___1: 
#line 591
  y = 0;
  {
#line 591
  while (1) {
    while_continue___12: /* CIL Label */ ;

#line 591
    if (! (y <= 6)) {
#line 591
      goto while_break___2;
    }
#line 592
    x = -6;
    {
#line 592
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___3: ;
#line 592
      if (! (x <= 6)) {
#line 592
        goto while_break___3;
      }
#line 593
      offset = y * xsize + x;
#line 596
      if (offset <= 0) {
#line 596
        goto while_continue___3;
      }
      {
#line 597
      __cil_tmp25 = VP8LDistanceToPlaneCode(xsize, offset);
#line 597
      plane_code = __cil_tmp25 - 1;
      }
#line 598
      if (plane_code >= 32) {
#line 598
        goto while_continue___3;
      }
#line 599
      window_offsets[plane_code] = offset;
#line 592
      x ++;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___3: 
#line 591
    y ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___2: 
#line 603
  i = 0;
  {
#line 603
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___4: ;
#line 603
    if (! (i < 32)) {
#line 603
      goto while_break___4;
    }
#line 604
    if (window_offsets[i] == 0) {
#line 604
      goto while_continue___4;
    }
#line 605
    __cil_tmp26 = window_offsets_size;
#line 605
    window_offsets_size ++;
#line 605
    window_offsets[__cil_tmp26] = window_offsets[i];
#line 603
    i ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___4: 
#line 609
  i = 0;
  {
#line 609
  while (1) {
    while_continue___15: /* CIL Label */ ;

#line 609
    if (! (i < window_offsets_size)) {
#line 609
      goto while_break___5;
    }
#line 611
    is_reachable = 0;
#line 612
    j = 0;
    {
#line 612
    while (1) {
      while_continue___16: /* CIL Label */ ;

#line 612
      if (j < window_offsets_size) {
#line 612
        if (! (! is_reachable)) {
#line 612
          goto while_break___6;
        }
      } else {
#line 612
        goto while_break___6;
      }
#line 613
      is_reachable |= window_offsets[i] == window_offsets[j] + 1;
#line 612
      j ++;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___6: ;
#line 615
    if (! is_reachable) {
#line 616
      window_offsets_new[window_offsets_new_size] = window_offsets[i];
#line 617
      window_offsets_new_size ++;
    }
#line 609
    i ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___5: 
#line 622
  *(hash_chain->offset_length_ + 0) = (uint32_t )0;
#line 623
  i = 1;
  {
#line 623
  while (1) {
    while_continue___17: /* CIL Label */ ;

#line 623
    if (! (i < pix_count)) {
#line 623
      goto while_break___7;
    }
    {
#line 625
    __cil_tmp31 = VP8LHashChainFindLength(hash_chain_best, i);
#line 625
    best_length = __cil_tmp31;
#line 627
    do_compute = 1;
    }
#line 629
    if (best_length >= (1 << 12) - 1) {
      {
#line 632
      best_offset = VP8LHashChainFindOffset(hash_chain_best, i);
#line 633
      ind = 0;
      }
      {
#line 633
      while (1) {
        while_continue___18: /* CIL Label */ ;

#line 633
        if (! (ind < window_offsets_size)) {
#line 633
          goto while_break___8;
        }
#line 634
        if (best_offset == window_offsets[ind]) {
#line 635
          do_compute = 0;
#line 636
          goto while_break___8;
        }
#line 633
        ind ++;
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___8: ;
    }
#line 640
    if (do_compute) {
#line 644
      if (best_length_prev > 1) {
#line 644
        if (best_length_prev < (1 << 12) - 1) {
#line 644
          tmp___7 = 1;
        } else {
#line 644
          tmp___7 = 0;
        }
      } else {
#line 644
        tmp___7 = 0;
      }
#line 644
      use_prev = tmp___7;
#line 646
      if (use_prev) {
#line 646
        tmp___1 = window_offsets_new_size;
      } else {
#line 646
        tmp___1 = window_offsets_size;
      }
#line 646
      num_ind = tmp___1;
#line 648
      if (use_prev) {
#line 648
        tmp___2 = best_length_prev - 1;
      } else {
#line 648
        tmp___2 = 0;
      }
#line 648
      best_length = tmp___2;
#line 649
      if (use_prev) {
#line 649
        tmp___3 = best_offset_prev;
      } else {
#line 649
        tmp___3 = 0;
      }
#line 649
      best_offset = tmp___3;
#line 651
      ind = 0;
      {
#line 651
      while (1) {
        while_continue___19: /* CIL Label */ ;
        while_continue___9: ;
#line 651
        if (! (ind < num_ind)) {
#line 651
          goto while_break___9;
        }
#line 652
        curr_length = 0;
#line 653
        j___0 = i;
#line 654
        if (use_prev) {
#line 654
          tmp___4 = i - window_offsets_new[ind];
        } else {
#line 654
          tmp___4 = i - window_offsets[ind];
        }
#line 654
        j_offset = tmp___4;
#line 656
        if (j_offset < 0) {
#line 656
          goto while_continue___9;
        } else
#line 656
        if (*(argb + j_offset) != *(argb + i)) {
#line 656
          goto while_continue___9;
        }
        {
#line 659
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 660
          counts_j_offset = (int )*(counts_ini + j_offset);
#line 661
          counts_j = (int )*(counts_ini + j___0);
#line 662
          if (counts_j_offset != counts_j) {
#line 663
            if (counts_j_offset < counts_j) {
#line 663
              tmp___5 = counts_j_offset;
            } else {
#line 663
              tmp___5 = counts_j;
            }
#line 663
            curr_length += tmp___5;
#line 665
            goto while_break___10;
          }
#line 668
          curr_length += counts_j_offset;
#line 669
          j_offset += counts_j_offset;
#line 670
          j___0 += counts_j_offset;
#line 659
          if (curr_length <= (1 << 12) - 1) {
#line 659
            if (j___0 < pix_count) {
#line 659
              if (! (*(argb + j_offset) == *(argb + j___0))) {
#line 659
                goto while_break___10;
              }
            } else {
#line 659
              goto while_break___10;
            }
          } else {
#line 659
            goto while_break___10;
          }
        }
        while_break___22: /* CIL Label */ ;
        }
        while_break___10: ;
#line 673
        if (best_length < curr_length) {
#line 674
          if (use_prev) {
#line 674
            tmp___6 = window_offsets_new[ind];
          } else {
#line 674
            tmp___6 = window_offsets[ind];
          }
#line 674
          best_offset = tmp___6;
#line 676
          if (curr_length >= (1 << 12) - 1) {
#line 677
            best_length = (1 << 12) - 1;
#line 678
            goto while_break___9;
          } else {
#line 680
            best_length = curr_length;
          }
        }
#line 651
        ind ++;
      }
      while_break___21: /* CIL Label */ ;
      }
      while_break___9: ;
    }
#line 688
    if (best_length <= 4) {
#line 689
      *(hash_chain->offset_length_ + i) = (uint32_t )0;
#line 690
      best_offset_prev = 0;
#line 691
      best_length_prev = 0;
    } else {
#line 693
      *(hash_chain->offset_length_ + i) = (unsigned int )(best_offset << 12) | (uint32_t )best_length;
#line 695
      best_offset_prev = best_offset;
#line 696
      best_length_prev = best_length;
    }
#line 623
    i ++;
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break___7: 
  {
#line 699
  *(hash_chain->offset_length_ + 0) = (uint32_t )0;
#line 700
  WebPSafeFree((void *)counts_ini);
#line 702
  __cil_tmp48 = BackwardReferencesLz77(xsize, ysize, argb, cache_bits, hash_chain,
                                       refs);
  }
#line 702
  return (__cil_tmp48);
}
}
#line 708 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static void BackwardReferences2DLocality(int xsize , VP8LBackwardRefs *refs ) 
{ 
  VP8LRefsCursor c ;
  VP8LRefsCursor __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int dist ;
  int transformed_dist ;
  int __cil_tmp9 ;

  {
  {
#line 710
  __cil_tmp4 = VP8LRefsCursorInit(refs);
#line 710
  c = __cil_tmp4;
  }
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 711
    __cil_tmp5 = VP8LRefsCursorOk(& c);
    }
#line 711
    if (! __cil_tmp5) {
#line 711
      goto while_break;
    }
    {
#line 712
    __cil_tmp6 = PixOrCopyIsCopy(c.cur_pos);
    }
#line 712
    if (__cil_tmp6) {
      {
#line 713
      dist = (int )(c.cur_pos)->argb_or_distance;
#line 714
      __cil_tmp9 = VP8LDistanceToPlaneCode(xsize, dist);
#line 714
      transformed_dist = __cil_tmp9;
#line 715
      (c.cur_pos)->argb_or_distance = (uint32_t )transformed_dist;
      }
    }
    {
#line 717
    VP8LRefsCursorNext(& c);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 722
  return;
}
}
#line 726 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static int CalculateBestCacheSize(uint32_t *argb , int quality , VP8LBackwardRefs *refs ,
                                  int *best_cache_bits ) 
{ 
  int i ;
  int cache_bits_max ;
  int tmp ;
  double entropy_min ;
  int cc_init[11] ;
  unsigned int tmp___0 ;
  VP8LColorCache hashers[11] ;
  VP8LRefsCursor c ;
  VP8LRefsCursor __cil_tmp13 ;
  VP8LHistogram *histos[11] ;
  unsigned int tmp___1 ;
  int ok ;
  int __cil_tmp19 ;
  PixOrCopy *v ;
  int __cil_tmp21 ;
  uint32_t pix ;
  uint32_t *__cil_tmp23 ;
  uint32_t a ;
  uint32_t r ;
  uint32_t g ;
  uint32_t b ;
  int key ;
  int __cil_tmp29 ;
  uint32_t __cil_tmp30 ;
  int code ;
  int extra_bits ;
  int extra_bits_value ;
  int len ;
  uint32_t __cil_tmp35 ;
  uint32_t argb_prev ;
  int key___0 ;
  int __cil_tmp38 ;
  double entropy ;
  double __cil_tmp41 ;

  {
#line 730
  if (quality <= 25) {
#line 730
    tmp = 0;
  } else {
#line 730
    tmp = *best_cache_bits;
  }
#line 730
  cache_bits_max = tmp;
#line 731
  entropy_min = (double )1.00000001505e+30f;
#line 732
  cc_init[0] = 0;
#line 732
  tmp___0 = 1U;
  {
#line 732
  while (1) {
    while_continue: /* CIL Label */ ;

#line 732
    if (tmp___0 >= 11U) {
#line 732
      goto while_break;
    }
#line 732
    cc_init[tmp___0] = 0;
#line 732
    tmp___0 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break: 
  {
#line 734
  __cil_tmp13 = VP8LRefsCursorInit(refs);
#line 734
  c = __cil_tmp13;
#line 735
  histos[0] = (VP8LHistogram *)((void *)0);
#line 735
  tmp___1 = 1U;
  }
  {
#line 735
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 735
    if (tmp___1 >= 11U) {
#line 735
      goto while_break___0;
    }
#line 735
    histos[tmp___1] = (VP8LHistogram *)0;
#line 735
    tmp___1 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___0: 
#line 736
  ok = 0;
#line 740
  if (cache_bits_max == 0) {
#line 741
    *best_cache_bits = 0;
#line 743
    return (1);
  }
#line 747
  i = 0;
  {
#line 747
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___1: ;
#line 747
    if (! (i <= cache_bits_max)) {
#line 747
      goto while_break___1;
    }
    {
#line 748
    histos[i] = VP8LAllocateHistogram(i);
    }
#line 749
    if ((unsigned long )histos[i] == (unsigned long )((void *)0)) {
#line 749
      goto Error;
    }
    {
#line 750
    VP8LHistogramInit(histos[i], i, 1);
    }
#line 751
    if (i == 0) {
#line 751
      goto while_continue___1;
    }
    {
#line 752
    cc_init[i] = VP8LColorCacheInit(& hashers[i], i);
    }
#line 753
    if (! cc_init[i]) {
#line 753
      goto Error;
    }
#line 747
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___1: ;
  {
#line 759
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 759
    __cil_tmp19 = VP8LRefsCursorOk(& c);
    }
#line 759
    if (! __cil_tmp19) {
#line 759
      goto while_break___2;
    }
    {
#line 760
    v = c.cur_pos;
#line 761
    __cil_tmp21 = PixOrCopyIsLiteral(v);
    }
#line 761
    if (__cil_tmp21) {
      {
#line 762
      __cil_tmp23 = argb;
#line 762
      argb ++;
#line 762
      pix = *__cil_tmp23;
#line 763
      a = (pix >> 24) & 255U;
#line 764
      r = (pix >> 16) & 255U;
#line 765
      g = (pix >> 8) & 255U;
#line 766
      b = pix & 255U;
#line 768
      __cil_tmp29 = VP8LHashPix___1(pix, 32 - cache_bits_max);
#line 768
      key = __cil_tmp29;
#line 770
      ((histos[0])->blue_[b]) ++;
#line 771
      (*((histos[0])->literal_ + g)) ++;
#line 772
      ((histos[0])->red_[r]) ++;
#line 773
      ((histos[0])->alpha_[a]) ++;
#line 775
      i = cache_bits_max;
      }
      {
#line 775
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 775
        if (! (i >= 1)) {
#line 775
          goto while_break___3;
        }
        {
#line 776
        __cil_tmp30 = VP8LColorCacheLookup(& hashers[i], (uint32_t )key);
        }
#line 776
        if (__cil_tmp30 == pix) {
#line 777
          (*((histos[i])->literal_ + (280 + key))) ++;
        } else {
          {
#line 779
          VP8LColorCacheSet(& hashers[i], (uint32_t )key, pix);
#line 780
          ((histos[i])->blue_[b]) ++;
#line 781
          (*((histos[i])->literal_ + g)) ++;
#line 782
          ((histos[i])->red_[r]) ++;
#line 783
          ((histos[i])->alpha_[a]) ++;
          }
        }
#line 775
        key >>= 1;
#line 775
        i --;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___3: ;
    } else {
      {
#line 793
      __cil_tmp35 = PixOrCopyLength(v);
#line 793
      len = (int )__cil_tmp35;
#line 794
      argb_prev = *argb ^ 4294967295U;
#line 795
      VP8LPrefixEncode(len, & code, & extra_bits, & extra_bits_value);
#line 796
      i = 0;
      }
      {
#line 796
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 796
        if (! (i <= cache_bits_max)) {
#line 796
          goto while_break___4;
        }
#line 797
        (*((histos[i])->literal_ + (256 + code))) ++;
#line 796
        i ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___4: ;
      {
#line 800
      while (1) {
        while_continue___7: /* CIL Label */ ;

#line 801
        if (*argb != argb_prev) {
          {
#line 803
          __cil_tmp38 = VP8LHashPix___1(*argb, 32 - cache_bits_max);
#line 803
          key___0 = __cil_tmp38;
#line 804
          i = cache_bits_max;
          }
          {
#line 804
          while (1) {
            while_continue___8: /* CIL Label */ ;

#line 804
            if (! (i >= 1)) {
#line 804
              goto while_break___6;
            }
#line 805
            *(hashers[i].colors_ + key___0) = *argb;
#line 804
            key___0 >>= 1;
#line 804
            i --;
          }
          while_break___16: /* CIL Label */ ;
          }
          while_break___6: 
#line 807
          argb_prev = *argb;
        }
#line 809
        argb ++;
#line 800
        if (! (len != 0)) {
#line 800
          goto while_break___5;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___5: ;
    }
    {
#line 812
    VP8LRefsCursorNext(& c);
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___2: 
#line 815
  i = 0;
  {
#line 815
  while (1) {
    while_continue___9: /* CIL Label */ ;

#line 815
    if (! (i <= cache_bits_max)) {
#line 815
      goto while_break___7;
    }
    {
#line 816
    __cil_tmp41 = VP8LHistogramEstimateBits(histos[i]);
#line 816
    entropy = __cil_tmp41;
    }
#line 817
    if (i == 0) {
#line 818
      entropy_min = entropy;
#line 819
      *best_cache_bits = i;
    } else
#line 817
    if (entropy < entropy_min) {
#line 818
      entropy_min = entropy;
#line 819
      *best_cache_bits = i;
    }
#line 815
    i ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___7: 
#line 822
  ok = 1;
  Error: 
#line 824
  i = 0;
  {
#line 824
  while (1) {
    while_continue___10: /* CIL Label */ ;

#line 824
    if (! (i <= cache_bits_max)) {
#line 824
      goto while_break___8;
    }
#line 825
    if (cc_init[i]) {
      {
#line 825
      VP8LColorCacheClear(& hashers[i]);
      }
    }
    {
#line 826
    VP8LFreeHistogram(histos[i]);
#line 824
    i ++;
    }
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___8: ;
#line 828
  return (ok);
}
}
#line 832 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static int BackwardRefsWithLocalCache(uint32_t *argb , int cache_bits , VP8LBackwardRefs *refs ) 
{ 
  int pixel_index ;
  VP8LColorCache hashers ;
  VP8LRefsCursor c ;
  VP8LRefsCursor __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  PixOrCopy *v ;
  int __cil_tmp11 ;
  uint32_t argb_literal ;
  int ix ;
  int __cil_tmp14 ;
  int k ;
  int __cil_tmp17 ;

  {
  {
#line 835
  pixel_index = 0;
#line 837
  __cil_tmp7 = VP8LRefsCursorInit(refs);
#line 837
  c = __cil_tmp7;
#line 838
  __cil_tmp8 = VP8LColorCacheInit(& hashers, cache_bits);
  }
#line 838
  if (! __cil_tmp8) {
#line 838
    return (0);
  }
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 840
    __cil_tmp9 = VP8LRefsCursorOk(& c);
    }
#line 840
    if (! __cil_tmp9) {
#line 840
      goto while_break;
    }
    {
#line 841
    v = c.cur_pos;
#line 842
    __cil_tmp11 = PixOrCopyIsLiteral(v);
    }
#line 842
    if (__cil_tmp11) {
      {
#line 843
      argb_literal = v->argb_or_distance;
#line 844
      __cil_tmp14 = VP8LColorCacheContains___1(& hashers, argb_literal);
#line 844
      ix = __cil_tmp14;
      }
#line 845
      if (ix >= 0) {
        {
#line 847
        *v = PixOrCopyCreateCacheIdx(ix);
        }
      } else {
        {
#line 849
        VP8LColorCacheInsert___1(& hashers, argb_literal);
        }
      }
#line 851
      pixel_index ++;
    } else {
#line 856
      k = 0;
      {
#line 856
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 856
        if (! (k < (int )v->len)) {
#line 856
          goto while_break___0;
        }
        {
#line 857
        __cil_tmp17 = pixel_index;
#line 857
        pixel_index ++;
#line 857
        VP8LColorCacheInsert___1(& hashers, *(argb + __cil_tmp17));
#line 856
        k ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
    }
    {
#line 860
    VP8LRefsCursorNext(& c);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 862
  VP8LColorCacheClear(& hashers);
  }
#line 863
  return (1);
}
}
#line 866 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static VP8LBackwardRefs *GetBackwardReferencesLowEffort(int width , int height , uint32_t *argb ,
                                                        int *cache_bits , VP8LHashChain *hash_chain ,
                                                        VP8LBackwardRefs *refs_lz77 ) 
{ 
  int __cil_tmp7 ;

  {
  {
#line 870
  *cache_bits = 0;
#line 871
  __cil_tmp7 = BackwardReferencesLz77(width, height, argb, 0, hash_chain, refs_lz77);
  }
#line 871
  if (! __cil_tmp7) {
#line 872
    return ((VP8LBackwardRefs *)((void *)0));
  }
  {
#line 874
  BackwardReferences2DLocality(width, refs_lz77);
  }
#line 875
  return (refs_lz77);
}
}
#line 878
int VP8LBackwardReferencesTraceBackwards(int xsize , int ysize , uint32_t *argb ,
                                         int cache_bits , VP8LHashChain *hash_chain ,
                                         VP8LBackwardRefs *refs_src , VP8LBackwardRefs *refs_dst ) ;
#line 882 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
static int GetBackwardReferences(int width , int height , uint32_t *argb , int quality ,
                                 int lz77_types_to_try , int cache_bits_max , int do_no_cache ,
                                 VP8LHashChain *hash_chain , VP8LBackwardRefs *refs ,
                                 int *cache_bits_best ) 
{ 
  VP8LHistogram *histo ;
  int i ;
  int lz77_type ;
  int lz77_types_best[2] ;
  double bit_costs_best[2] ;
  VP8LHashChain hash_chain_box ;
  VP8LBackwardRefs *refs_tmp ;
  int tmp ;
  int status ;
  int res ;
  double bit_cost ;
  int __cil_tmp25 ;
  int cache_bits ;
  int tmp___0 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp32 ;
  VP8LHashChain *hash_chain_tmp ;
  VP8LHashChain *tmp___1 ;
  int cache_bits___0 ;
  int tmp___2 ;
  int __cil_tmp37 ;
  double bit_cost_trace ;
  int __cil_tmp40 ;

  {
#line 889
  histo = (VP8LHistogram *)((void *)0);
#line 892
  lz77_types_best[0] = 0;
#line 892
  lz77_types_best[1] = 0;
#line 893
  bit_costs_best[0] = (double )1.79769313487e+308L;
#line 893
  bit_costs_best[1] = (double )1.79769313487e+308L;
#line 895
  if (do_no_cache) {
#line 895
    tmp = 2;
  } else {
#line 895
    tmp = 1;
  }
  {
#line 895
  refs_tmp = refs + tmp;
#line 896
  status = 0;
#line 897
  memset((void *)(& hash_chain_box), 0, sizeof(hash_chain_box));
#line 899
  histo = VP8LAllocateHistogram(10);
  }
#line 900
  if ((unsigned long )histo == (unsigned long )((void *)0)) {
#line 900
    goto Error;
  }
#line 902
  lz77_type = 1;
  {
#line 902
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: ;
#line 902
    if (! lz77_types_to_try) {
#line 902
      goto while_break;
    }
#line 904
    res = 0;
#line 905
    bit_cost = 0.;
#line 906
    if ((lz77_types_to_try & lz77_type) == 0) {
#line 906
      goto while_continue;
    }
#line 908
    if (lz77_type == 2) {
#line 908
      goto case_2;
    }
#line 911
    if (lz77_type == 1) {
#line 911
      goto case_1;
    }
#line 917
    if (lz77_type == 4) {
#line 917
      goto case_4;
    }
#line 907
    goto switch_break;
    case_2: 
    {
#line 909
    res = BackwardReferencesRle(width, height, argb, 0, refs_tmp);
    }
#line 910
    goto switch_break;
    case_1: 
    {
#line 914
    res = BackwardReferencesLz77(width, height, argb, 0, hash_chain, refs_tmp);
    }
#line 916
    goto switch_break;
    case_4: 
    {
#line 918
    __cil_tmp25 = VP8LHashChainInit(& hash_chain_box, width * height);
    }
#line 918
    if (! __cil_tmp25) {
#line 918
      goto Error;
    }
    {
#line 919
    res = BackwardReferencesLz77Box(width, height, argb, 0, hash_chain, & hash_chain_box,
                                    refs_tmp);
    }
#line 921
    goto switch_break;
    switch_break: ;
#line 925
    if (! res) {
#line 925
      goto Error;
    }
#line 928
    i = 1;
    {
#line 928
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: ;
#line 928
      if (! (i >= 0)) {
#line 928
        goto while_break___0;
      }
#line 929
      if (i == 1) {
#line 929
        tmp___0 = 0;
      } else {
#line 929
        tmp___0 = cache_bits_max;
      }
#line 929
      cache_bits = tmp___0;
#line 931
      if (i == 1) {
#line 931
        if (! do_no_cache) {
#line 931
          goto while_continue___0;
        }
      }
#line 933
      if (i == 0) {
        {
#line 935
        __cil_tmp29 = CalculateBestCacheSize(argb, quality, refs_tmp, & cache_bits);
        }
#line 935
        if (! __cil_tmp29) {
#line 936
          goto Error;
        }
#line 938
        if (cache_bits > 0) {
          {
#line 939
          __cil_tmp30 = BackwardRefsWithLocalCache(argb, cache_bits, refs_tmp);
          }
#line 939
          if (! __cil_tmp30) {
#line 940
            goto Error;
          }
        }
      }
#line 945
      if (i == 0) {
#line 945
        if (do_no_cache) {
#line 945
          if (! (cache_bits == 0)) {
            {
#line 948
            VP8LHistogramCreate(histo, refs_tmp, cache_bits);
#line 949
            bit_cost = VP8LHistogramEstimateBits(histo);
            }
          }
        } else {
          {
#line 948
          VP8LHistogramCreate(histo, refs_tmp, cache_bits);
#line 949
          bit_cost = VP8LHistogramEstimateBits(histo);
          }
        }
      } else {
        {
#line 948
        VP8LHistogramCreate(histo, refs_tmp, cache_bits);
#line 949
        bit_cost = VP8LHistogramEstimateBits(histo);
        }
      }
#line 952
      if (bit_cost < bit_costs_best[i]) {
#line 953
        if (i == 1) {
          {
#line 956
          __cil_tmp32 = BackwardRefsClone(refs_tmp, refs + 1);
          }
#line 956
          if (! __cil_tmp32) {
#line 956
            goto Error;
          }
        } else {
          {
#line 958
          BackwardRefsSwap(refs_tmp, refs + 0);
          }
        }
#line 960
        bit_costs_best[i] = bit_cost;
#line 961
        lz77_types_best[i] = lz77_type;
#line 962
        if (i == 0) {
#line 962
          *cache_bits_best = cache_bits;
        }
      }
#line 928
      i --;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 903
    lz77_type <<= 1;
#line 903
    lz77_types_to_try &= ~ lz77_type;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 971
  i = 1;
  {
#line 971
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: ;
#line 971
    if (! (i >= 0)) {
#line 971
      goto while_break___1;
    }
#line 972
    if (i == 1) {
#line 972
      if (! do_no_cache) {
#line 972
        goto while_continue___1;
      }
    }
#line 973
    if (lz77_types_best[i] == 1) {
      _L: 
#line 973
      if (quality >= 25) {
#line 976
        if (lz77_types_best[i] == 1) {
#line 976
          tmp___1 = hash_chain;
        } else {
#line 976
          tmp___1 = & hash_chain_box;
        }
#line 976
        hash_chain_tmp = tmp___1;
#line 978
        if (i == 1) {
#line 978
          tmp___2 = 0;
        } else {
#line 978
          tmp___2 = *cache_bits_best;
        }
        {
#line 978
        cache_bits___0 = tmp___2;
#line 979
        __cil_tmp37 = VP8LBackwardReferencesTraceBackwards(width, height, argb, cache_bits___0,
                                                           hash_chain_tmp, refs + i,
                                                           refs_tmp);
        }
#line 979
        if (__cil_tmp37) {
          {
#line 983
          VP8LHistogramCreate(histo, refs_tmp, cache_bits___0);
#line 984
          bit_cost_trace = VP8LHistogramEstimateBits(histo);
          }
#line 985
          if (bit_cost_trace < bit_costs_best[i]) {
            {
#line 986
            BackwardRefsSwap(refs_tmp, refs + i);
            }
          }
        }
      }
    } else
#line 973
    if (lz77_types_best[i] == 4) {
#line 973
      goto _L;
    }
    {
#line 991
    BackwardReferences2DLocality(width, refs + i);
    }
#line 993
    if (i == 1) {
#line 993
      if (lz77_types_best[0] == lz77_types_best[1]) {
#line 993
        if (*cache_bits_best == 0) {
          {
#line 997
          __cil_tmp40 = BackwardRefsClone(refs + 1, refs + 0);
          }
#line 997
          if (! __cil_tmp40) {
#line 997
            goto Error;
          }
#line 998
          goto while_break___1;
        }
      }
    }
#line 971
    i --;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
#line 1001
  status = 1;
  Error: 
  {
#line 1004
  VP8LHashChainClear(& hash_chain_box);
#line 1005
  VP8LFreeHistogram(histo);
  }
#line 1006
  return (status);
}
}
#line 1009 "/root/patron-new/new_3/src/enc/backward_references_enc.c"
WebPEncodingError VP8LGetBackwardReferences(int width , int height , uint32_t *argb ,
                                            int quality , int low_effort , int lz77_types_to_try ,
                                            int cache_bits_max , int do_no_cache ,
                                            VP8LHashChain *hash_chain , VP8LBackwardRefs *refs ,
                                            int *cache_bits_best ) 
{ 
  VP8LBackwardRefs *refs_best ;
  int __cil_tmp14 ;

  {
#line 1014
  if (low_effort) {
    {
#line 1016
    *cache_bits_best = cache_bits_max;
#line 1017
    refs_best = GetBackwardReferencesLowEffort(width, height, argb, cache_bits_best,
                                               hash_chain, refs);
    }
#line 1019
    if ((unsigned long )refs_best == (unsigned long )((void *)0)) {
#line 1019
      return ((WebPEncodingError )1);
    }
    {
#line 1021
    BackwardRefsSwap(refs_best, refs + 0);
    }
  } else {
    {
#line 1023
    __cil_tmp14 = GetBackwardReferences(width, height, argb, quality, lz77_types_to_try,
                                        cache_bits_max, do_no_cache, hash_chain, refs,
                                        cache_bits_best);
    }
#line 1023
    if (! __cil_tmp14) {
#line 1026
      return ((WebPEncodingError )1);
    }
  }
#line 1029
  return ((WebPEncodingError )0);
}
}
#line 34 "../../src/utils/color_cache_utils.h"
static uint32_t kHashMul___2  =    506832829U;
#line 37 "../../src/utils/color_cache_utils.h"
__inline static int VP8LHashPix___2(uint32_t argb , int shift ) 
{ 


  {
#line 38
  return ((int )(argb * kHashMul___2 >> shift));
}
}
#line 53 "../../src/utils/color_cache_utils.h"
__inline static void VP8LColorCacheInsert___2(VP8LColorCache *cc , uint32_t argb ) 
{ 
  int key ;
  int __cil_tmp4 ;

  {
  {
#line 55
  __cil_tmp4 = VP8LHashPix___2(argb, cc->hash_shift_);
#line 55
  key = __cil_tmp4;
#line 56
  *(cc->colors_ + key) = argb;
  }
#line 58
  return;
}
}
#line 65 "../../src/utils/color_cache_utils.h"
__inline static int VP8LColorCacheContains___2(VP8LColorCache *cc , uint32_t argb ) 
{ 
  int key ;
  int __cil_tmp4 ;
  int tmp ;

  {
  {
#line 67
  __cil_tmp4 = VP8LHashPix___2(argb, cc->hash_shift_);
#line 67
  key = __cil_tmp4;
  }
#line 68
  if (*(cc->colors_ + key) == argb) {
#line 68
    tmp = key;
  } else {
#line 68
    tmp = -1;
  }
#line 68
  return (tmp);
}
}
#line 40 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
static void ConvertPopulationCountTableToBitEstimates(int num_symbols , uint32_t *population_counts ,
                                                      double *output ) 
{ 
  uint32_t sum ;
  int nonzeros ;
  int i ;
  double logsum ;
  float __cil_tmp8 ;
  float __cil_tmp9 ;

  {
#line 42
  sum = (uint32_t )0;
#line 43
  nonzeros = 0;
#line 45
  i = 0;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;

#line 45
    if (! (i < num_symbols)) {
#line 45
      goto while_break;
    }
#line 46
    sum += *(population_counts + i);
#line 47
    if (*(population_counts + i) > 0U) {
#line 48
      nonzeros ++;
    }
#line 45
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 51
  if (nonzeros <= 1) {
    {
#line 52
    memset((void *)output, 0, (unsigned long )num_symbols * sizeof(*(output + 0)));
    }
  } else {
    {
#line 54
    __cil_tmp8 = VP8LFastLog2(sum);
#line 54
    logsum = (double )__cil_tmp8;
#line 55
    i = 0;
    }
    {
#line 55
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 55
      if (! (i < num_symbols)) {
#line 55
        goto while_break___0;
      }
      {
#line 56
      __cil_tmp9 = VP8LFastLog2(*(population_counts + i));
#line 56
      *(output + i) = logsum - (double )__cil_tmp9;
#line 55
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 60
  return;
}
}
#line 61 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
static int CostModelBuild(CostModel *m , int xsize , int cache_bits , VP8LBackwardRefs *refs ) 
{ 
  int ok ;
  VP8LRefsCursor c ;
  VP8LRefsCursor __cil_tmp7 ;
  VP8LHistogram *histo ;
  VP8LHistogram *__cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 63
  ok = 0;
#line 64
  __cil_tmp7 = VP8LRefsCursorInit(refs);
#line 64
  c = __cil_tmp7;
#line 65
  __cil_tmp9 = VP8LAllocateHistogram(cache_bits);
#line 65
  histo = __cil_tmp9;
  }
#line 66
  if ((unsigned long )histo == (unsigned long )((void *)0)) {
#line 66
    goto Error;
  }
  {
#line 70
  VP8LHistogramInit(histo, cache_bits, 1);
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 71
    __cil_tmp10 = VP8LRefsCursorOk(& c);
    }
#line 71
    if (! __cil_tmp10) {
#line 71
      goto while_break;
    }
    {
#line 72
    VP8LHistogramAddSinglePixOrCopy(histo, c.cur_pos, & VP8LDistanceToPlaneCode, xsize);
#line 74
    VP8LRefsCursorNext(& c);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 77
  __cil_tmp11 = VP8LHistogramNumCodes(histo->palette_code_bits_);
#line 77
  ConvertPopulationCountTableToBitEstimates(__cil_tmp11, histo->literal_, m->literal_);
#line 80
  ConvertPopulationCountTableToBitEstimates(256, histo->red_, m->red_);
#line 82
  ConvertPopulationCountTableToBitEstimates(256, histo->blue_, m->blue_);
#line 84
  ConvertPopulationCountTableToBitEstimates(256, histo->alpha_, m->alpha_);
#line 86
  ConvertPopulationCountTableToBitEstimates(40, histo->distance_, m->distance_);
#line 88
  ok = 1;
  }
  Error: 
  {
#line 91
  VP8LFreeHistogram(histo);
  }
#line 92
  return (ok);
}
}
#line 95 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
__inline static double GetLiteralCost(CostModel *m , uint32_t v ) 
{ 


  {
#line 96
  return (((m->alpha_[v >> 24] + m->red_[(v >> 16) & 255U]) + *(m->literal_ + ((v >> 8) & 255U))) + m->blue_[v & 255U]);
}
}
#line 102 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
__inline static double GetCacheCost(CostModel *m , uint32_t idx ) 
{ 
  int literal_idx ;

  {
#line 103
  literal_idx = (int )(280U + idx);
#line 104
  return (*(m->literal_ + literal_idx));
}
}
#line 107 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
__inline static double GetLengthCost(CostModel *m , uint32_t length ) 
{ 
  int code ;
  int extra_bits ;

  {
  {
#line 110
  VP8LPrefixEncodeBits((int )length, & code, & extra_bits);
  }
#line 111
  return (*(m->literal_ + (256 + code)) + (double )extra_bits);
}
}
#line 114 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
__inline static double GetDistanceCost(CostModel *m , uint32_t distance ) 
{ 
  int code ;
  int extra_bits ;

  {
  {
#line 117
  VP8LPrefixEncodeBits((int )distance, & code, & extra_bits);
  }
#line 118
  return (m->distance_[code] + (double )extra_bits);
}
}
#line 121 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
__inline static void AddSingleLiteralWithCostModel(uint32_t *argb , VP8LColorCache *hashers ,
                                                   CostModel *cost_model , int idx ,
                                                   int use_color_cache , float prev_cost ,
                                                   float *cost , uint16_t *dist_array ) 
{ 
  double cost_val ;
  uint32_t color ;
  int ix ;
  int __cil_tmp12 ;
  int tmp ;
  double mul0 ;
  double __cil_tmp15 ;
  double mul1 ;
  double __cil_tmp17 ;

  {
#line 125
  cost_val = (double )prev_cost;
#line 126
  color = *(argb + idx);
#line 127
  if (use_color_cache) {
    {
#line 127
    __cil_tmp12 = VP8LColorCacheContains___2(hashers, color);
#line 127
    tmp = __cil_tmp12;
    }
  } else {
#line 127
    tmp = -1;
  }
#line 127
  ix = tmp;
#line 128
  if (ix >= 0) {
    {
#line 130
    mul0 = 0.680000000001;
#line 131
    __cil_tmp15 = GetCacheCost(cost_model, (uint32_t )ix);
#line 131
    cost_val += __cil_tmp15 * mul0;
    }
  } else {
#line 133
    mul1 = 0.82;
#line 134
    if (use_color_cache) {
      {
#line 134
      VP8LColorCacheInsert___2(hashers, color);
      }
    }
    {
#line 135
    __cil_tmp17 = GetLiteralCost(cost_model, color);
#line 135
    cost_val += __cil_tmp17 * mul1;
    }
  }
#line 137
  if ((double )*(cost + idx) > cost_val) {
#line 138
    *(cost + idx) = (float )cost_val;
#line 139
    *(dist_array + idx) = (uint16_t )1;
  }
#line 141
  return;
}
}
#line 202 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
static void CostIntervalAddToFreeList(CostManager *manager , CostInterval *interval ) 
{ 


  {
#line 204
  interval->next_ = manager->free_intervals_;
#line 205
  manager->free_intervals_ = interval;
#line 206
  return;
}
}
#line 208 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
static int CostIntervalIsInFreeList(CostManager *manager , CostInterval *interval ) 
{ 
  int tmp ;

  {
#line 210
  if ((unsigned long )interval >= (unsigned long )(& manager->intervals_[0])) {
#line 210
    if ((unsigned long )interval <= (unsigned long )(& manager->intervals_[9])) {
#line 210
      tmp = 1;
    } else {
#line 210
      tmp = 0;
    }
  } else {
#line 210
    tmp = 0;
  }
#line 210
  return (tmp);
}
}
#line 214 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
static void CostManagerInitFreeList(CostManager *manager ) 
{ 
  int i ;

  {
#line 216
  manager->free_intervals_ = (CostInterval *)((void *)0);
#line 217
  i = 0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;

#line 217
    if (! (i < 10)) {
#line 217
      goto while_break;
    }
    {
#line 218
    CostIntervalAddToFreeList(manager, & manager->intervals_[i]);
#line 217
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 221
  return;
}
}
#line 222 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
static void DeleteIntervalList(CostManager *manager , CostInterval *interval ) 
{ 
  CostInterval *next ;
  int __cil_tmp4 ;

  {
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;

#line 224
    if (! ((unsigned long )interval != (unsigned long )((void *)0))) {
#line 224
      goto while_break;
    }
    {
#line 225
    next = interval->next_;
#line 226
    __cil_tmp4 = CostIntervalIsInFreeList(manager, interval);
    }
#line 226
    if (! __cil_tmp4) {
      {
#line 227
      WebPSafeFree((void *)interval);
      }
    }
#line 229
    interval = next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 233
  return;
}
}
#line 233 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
static void CostManagerClear(CostManager *manager ) 
{ 


  {
#line 234
  if ((unsigned long )manager == (unsigned long )((void *)0)) {
#line 234
    return;
  }
  {
#line 236
  WebPSafeFree((void *)manager->costs_);
#line 237
  WebPSafeFree((void *)manager->cache_intervals_);
#line 240
  DeleteIntervalList(manager, manager->head_);
#line 241
  manager->head_ = (CostInterval *)((void *)0);
#line 242
  DeleteIntervalList(manager, manager->recycled_intervals_);
#line 243
  manager->recycled_intervals_ = (CostInterval *)((void *)0);
#line 246
  memset((void *)manager, 0, sizeof(*manager));
#line 247
  CostManagerInitFreeList(manager);
  }
#line 249
  return;
}
}
#line 250 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
static int CostManagerInit(CostManager *manager , uint16_t *dist_array , int pix_count ,
                           CostModel *cost_model ) 
{ 
  int i ;
  int cost_cache_size ;
  int tmp ;
  void *__cil_tmp10 ;
  CostCacheInterval *cur ;
  double cost_val ;
  void *__cil_tmp13 ;

  {
#line 254
  if (pix_count > (1 << 12) - 1) {
#line 254
    tmp = (1 << 12) - 1;
  } else {
#line 254
    tmp = pix_count;
  }
  {
#line 254
  cost_cache_size = tmp;
#line 256
  manager->costs_ = (float *)((void *)0);
#line 257
  manager->cache_intervals_ = (CostCacheInterval *)((void *)0);
#line 258
  manager->head_ = (CostInterval *)((void *)0);
#line 259
  manager->recycled_intervals_ = (CostInterval *)((void *)0);
#line 260
  manager->count_ = 0;
#line 261
  manager->dist_array_ = dist_array;
#line 262
  CostManagerInitFreeList(manager);
#line 265
  manager->cache_intervals_size_ = (size_t )1;
#line 266
  manager->cost_cache_[0] = GetLengthCost(cost_model, (uint32_t )0);
#line 267
  i = 1;
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;

#line 267
    if (! (i < cost_cache_size)) {
#line 267
      goto while_break;
    }
    {
#line 268
    manager->cost_cache_[i] = GetLengthCost(cost_model, (uint32_t )i);
    }
#line 270
    if (manager->cost_cache_[i] != manager->cost_cache_[i - 1]) {
#line 271
      (manager->cache_intervals_size_) ++;
    }
#line 267
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 280
  __cil_tmp10 = WebPSafeMalloc(manager->cache_intervals_size_, sizeof(*(manager->cache_intervals_)));
#line 280
  manager->cache_intervals_ = (CostCacheInterval *)__cil_tmp10;
  }
#line 282
  if ((unsigned long )manager->cache_intervals_ == (unsigned long )((void *)0)) {
    {
#line 283
    CostManagerClear(manager);
    }
#line 284
    return (0);
  }
#line 289
  cur = manager->cache_intervals_;
#line 293
  cur->start_ = 0;
#line 294
  cur->end_ = 1;
#line 295
  cur->cost_ = manager->cost_cache_[0];
#line 296
  i = 1;
  {
#line 296
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 296
    if (! (i < cost_cache_size)) {
#line 296
      goto while_break___0;
    }
#line 297
    cost_val = manager->cost_cache_[i];
#line 298
    if (cost_val != cur->cost_) {
#line 299
      cur ++;
#line 301
      cur->start_ = i;
#line 302
      cur->cost_ = cost_val;
    }
#line 304
    cur->end_ = i + 1;
#line 296
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 308
  __cil_tmp13 = WebPSafeMalloc((uint64_t )pix_count, sizeof(*(manager->costs_)));
#line 308
  manager->costs_ = (float *)__cil_tmp13;
  }
#line 309
  if ((unsigned long )manager->costs_ == (unsigned long )((void *)0)) {
    {
#line 310
    CostManagerClear(manager);
    }
#line 311
    return (0);
  }
#line 314
  i = 0;
  {
#line 314
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 314
    if (! (i < pix_count)) {
#line 314
      goto while_break___1;
    }
#line 314
    *(manager->costs_ + i) = 9.99999968029e+37f;
#line 314
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: ;
#line 316
  return (1);
}
}
#line 321 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
__inline static void UpdateCost(CostManager *manager , int i , int position , float cost ) 
{ 
  int k ;

  {
#line 323
  k = i - position;
#line 326
  if (*(manager->costs_ + i) > cost) {
#line 327
    *(manager->costs_ + i) = cost;
#line 328
    *(manager->dist_array_ + i) = (uint16_t )(k + 1);
  }
#line 330
  return;
}
}
#line 334 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
__inline static void UpdateCostPerInterval(CostManager *manager , int start , int end ,
                                           int position , float cost ) 
{ 
  int i ;

  {
#line 338
  i = start;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;

#line 338
    if (! (i < end)) {
#line 338
      goto while_break;
    }
    {
#line 338
    UpdateCost(manager, i, position, cost);
#line 338
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 342
  return;
}
}
#line 342 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
__inline static void ConnectIntervals(CostManager *manager , CostInterval *prev ,
                                      CostInterval *next ) 
{ 


  {
#line 345
  if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 346
    prev->next_ = next;
  } else {
#line 348
    manager->head_ = next;
  }
#line 351
  if ((unsigned long )next != (unsigned long )((void *)0)) {
#line 351
    next->previous_ = prev;
  }
#line 353
  return;
}
}
#line 355 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
__inline static void PopInterval(CostManager *manager , CostInterval *interval ) 
{ 
  int __cil_tmp3 ;

  {
#line 357
  if ((unsigned long )interval == (unsigned long )((void *)0)) {
#line 357
    return;
  }
  {
#line 359
  ConnectIntervals(manager, interval->previous_, interval->next_);
#line 360
  __cil_tmp3 = CostIntervalIsInFreeList(manager, interval);
  }
#line 360
  if (__cil_tmp3) {
    {
#line 361
    CostIntervalAddToFreeList(manager, interval);
    }
  } else {
#line 363
    interval->next_ = manager->recycled_intervals_;
#line 364
    manager->recycled_intervals_ = interval;
  }
#line 366
  (manager->count_) --;
#line 367
  return;
}
}
#line 374 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
__inline static void UpdateCostAtIndex(CostManager *manager , int i , int do_clean_intervals ) 
{ 
  CostInterval *current ;
  CostInterval *next ;

  {
#line 376
  current = manager->head_;
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;

#line 378
    if ((unsigned long )current != (unsigned long )((void *)0)) {
#line 378
      if (! (current->start_ <= i)) {
#line 378
        goto while_break;
      }
    } else {
#line 378
      goto while_break;
    }
#line 379
    next = current->next_;
#line 380
    if (current->end_ <= i) {
#line 381
      if (do_clean_intervals) {
        {
#line 383
        PopInterval(manager, current);
        }
      }
    } else {
      {
#line 386
      UpdateCost(manager, i, current->index_, current->cost_);
      }
    }
#line 388
    current = next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 392
  return;
}
}
#line 395 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
__inline static void PositionOrphanInterval(CostManager *manager , CostInterval *current ,
                                            CostInterval *previous ) 
{ 


  {
#line 400
  if ((unsigned long )previous == (unsigned long )((void *)0)) {
#line 400
    previous = manager->head_;
  }
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;

#line 401
    if ((unsigned long )previous != (unsigned long )((void *)0)) {
#line 401
      if (! (current->start_ < previous->start_)) {
#line 401
        goto while_break;
      }
    } else {
#line 401
      goto while_break;
    }
#line 402
    previous = previous->previous_;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 404
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 404
    if ((unsigned long )previous != (unsigned long )((void *)0)) {
#line 404
      if ((unsigned long )previous->next_ != (unsigned long )((void *)0)) {
#line 404
        if (! ((previous->next_)->start_ < current->start_)) {
#line 404
          goto while_break___0;
        }
      } else {
#line 404
        goto while_break___0;
      }
    } else {
#line 404
      goto while_break___0;
    }
#line 406
    previous = previous->next_;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 409
  if ((unsigned long )previous != (unsigned long )((void *)0)) {
    {
#line 410
    ConnectIntervals(manager, current, previous->next_);
    }
  } else {
    {
#line 412
    ConnectIntervals(manager, current, manager->head_);
    }
  }
  {
#line 414
  ConnectIntervals(manager, previous, current);
  }
#line 416
  return;
}
}
#line 419 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
__inline static void InsertInterval(CostManager *manager , CostInterval *interval_in ,
                                    float cost , int position , int start , int end ) 
{ 
  CostInterval *interval_new ;
  void *__cil_tmp8 ;

  {
#line 425
  if (start >= end) {
#line 425
    return;
  }
#line 426
  if (manager->count_ >= 500) {
    {
#line 428
    UpdateCostPerInterval(manager, start, end, position, cost);
    }
#line 429
    return;
  }
#line 431
  if ((unsigned long )manager->free_intervals_ != (unsigned long )((void *)0)) {
#line 432
    interval_new = manager->free_intervals_;
#line 433
    manager->free_intervals_ = interval_new->next_;
  } else
#line 434
  if ((unsigned long )manager->recycled_intervals_ != (unsigned long )((void *)0)) {
#line 435
    interval_new = manager->recycled_intervals_;
#line 436
    manager->recycled_intervals_ = interval_new->next_;
  } else {
    {
#line 438
    __cil_tmp8 = WebPSafeMalloc((uint64_t )1, sizeof(*interval_new));
#line 438
    interval_new = (CostInterval *)__cil_tmp8;
    }
#line 439
    if ((unsigned long )interval_new == (unsigned long )((void *)0)) {
      {
#line 441
      UpdateCostPerInterval(manager, start, end, position, cost);
      }
#line 442
      return;
    }
  }
  {
#line 446
  interval_new->cost_ = cost;
#line 447
  interval_new->index_ = position;
#line 448
  interval_new->start_ = start;
#line 449
  interval_new->end_ = end;
#line 450
  PositionOrphanInterval(manager, interval_new, interval_in);
#line 452
  (manager->count_) ++;
  }
#line 454
  return;
}
}
#line 459 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
__inline static void PushInterval(CostManager *manager , double distance_cost , int position ,
                                  int len ) 
{ 
  size_t i ;
  CostInterval *interval ;
  CostInterval *interval_next ;
  CostCacheInterval *cost_cache_intervals ;
  int kSkipDistance ;
  int j ;
  int k ;
  float cost_tmp ;
  int start ;
  int end ;
  int tmp ;
  float cost ;
  int start_new ;
  int end_original ;

  {
#line 463
  interval = manager->head_;
#line 465
  cost_cache_intervals = manager->cache_intervals_;
#line 469
  kSkipDistance = 10;
#line 471
  if (len < kSkipDistance) {
#line 473
    j = position;
    {
#line 473
    while (1) {
      while_continue: /* CIL Label */ ;

#line 473
      if (! (j < position + len)) {
#line 473
        goto while_break;
      }
#line 474
      k = j - position;
#line 477
      cost_tmp = (float )(distance_cost + manager->cost_cache_[k]);
#line 479
      if (*(manager->costs_ + j) > cost_tmp) {
#line 480
        *(manager->costs_ + j) = cost_tmp;
#line 481
        *(manager->dist_array_ + j) = (uint16_t )(k + 1);
      }
#line 473
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
#line 484
    return;
  }
#line 487
  i = (size_t )0;
  {
#line 487
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 487
    if (i < manager->cache_intervals_size_) {
#line 487
      if (! ((cost_cache_intervals + i)->start_ < len)) {
#line 487
        goto while_break___0;
      }
    } else {
#line 487
      goto while_break___0;
    }
#line 491
    start = position + (cost_cache_intervals + i)->start_;
#line 492
    if ((cost_cache_intervals + i)->end_ > len) {
#line 492
      tmp = len;
    } else {
#line 492
      tmp = (cost_cache_intervals + i)->end_;
    }
#line 492
    end = position + tmp;
#line 495
    cost = (float )(distance_cost + (cost_cache_intervals + i)->cost_);
    {
#line 497
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___1: ;
#line 497
      if ((unsigned long )interval != (unsigned long )((void *)0)) {
#line 497
        if (! (interval->start_ < end)) {
#line 497
          goto while_break___1;
        }
      } else {
#line 497
        goto while_break___1;
      }
#line 499
      interval_next = interval->next_;
#line 502
      if (start >= interval->end_) {
#line 502
        goto while_continue___1;
      }
#line 504
      if (cost >= interval->cost_) {
        {
#line 512
        start_new = interval->end_;
#line 513
        InsertInterval(manager, interval, cost, position, start, interval->start_);
#line 515
        start = start_new;
        }
#line 516
        if (start >= end) {
#line 516
          goto while_break___1;
        }
#line 517
        goto while_continue___1;
      }
#line 520
      if (start <= interval->start_) {
#line 521
        if (interval->end_ <= end) {
          {
#line 527
          PopInterval(manager, interval);
          }
        } else {
#line 533
          interval->start_ = end;
#line 534
          goto while_break___1;
        }
      } else
#line 537
      if (end < interval->end_) {
        {
#line 543
        end_original = interval->end_;
#line 544
        interval->end_ = start;
#line 545
        InsertInterval(manager, interval, interval->cost_, interval->index_, end,
                       end_original);
#line 547
        interval = interval->next_;
        }
#line 548
        goto while_break___1;
      } else {
#line 554
        interval->end_ = start;
      }
#line 498
      interval = interval_next;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 559
    InsertInterval(manager, interval, cost, position, start, end);
#line 489
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 493
  return;
}
}
#line 563 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
static int BackwardReferencesHashChainDistanceOnly(int xsize , int ysize , uint32_t *argb ,
                                                   int cache_bits , VP8LHashChain *hash_chain ,
                                                   VP8LBackwardRefs *refs , uint16_t *dist_array ) 
{ 
  int i ;
  int ok ;
  int cc_init ;
  int pix_count ;
  int use_color_cache ;
  size_t literal_array_size ;
  int tmp ;
  size_t cost_model_size ;
  CostModel *cost_model ;
  void *__cil_tmp17 ;
  VP8LColorCache hashers ;
  CostManager *cost_manager ;
  void *__cil_tmp20 ;
  int offset_prev ;
  int len_prev ;
  double offset_cost ;
  int first_offset_is_constant ;
  int reach ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  float prev_cost ;
  int offset ;
  int len ;
  int code ;
  int __cil_tmp33 ;
  int offset_j ;
  int len_j ;
  int j ;

  {
#line 568
  ok = 0;
#line 569
  cc_init = 0;
#line 570
  pix_count = xsize * ysize;
#line 571
  use_color_cache = cache_bits > 0;
#line 572
  if (cache_bits > 0) {
#line 572
    tmp = 1 << cache_bits;
  } else {
#line 572
    tmp = 0;
  }
  {
#line 572
  literal_array_size = sizeof(double ) * (unsigned long )(280 + tmp);
#line 575
  cost_model_size = sizeof(CostModel ) + literal_array_size;
#line 576
  __cil_tmp17 = WebPSafeCalloc((uint64_t )1ULL, cost_model_size);
#line 576
  cost_model = (CostModel *)__cil_tmp17;
#line 579
  __cil_tmp20 = WebPSafeMalloc((uint64_t )1ULL, sizeof(*cost_manager));
#line 579
  cost_manager = (CostManager *)__cil_tmp20;
#line 581
  offset_prev = -1;
#line 581
  len_prev = -1;
#line 582
  offset_cost = (double )-1;
#line 583
  first_offset_is_constant = -1;
#line 584
  reach = 0;
  }
#line 586
  if ((unsigned long )cost_model == (unsigned long )((void *)0)) {
#line 586
    goto Error;
  } else
#line 586
  if ((unsigned long )cost_manager == (unsigned long )((void *)0)) {
#line 586
    goto Error;
  }
#line 588
  cost_model->literal_ = (double *)(cost_model + 1);
#line 589
  if (use_color_cache) {
    {
#line 590
    cc_init = VP8LColorCacheInit(& hashers, cache_bits);
    }
#line 591
    if (! cc_init) {
#line 591
      goto Error;
    }
  }
  {
#line 594
  __cil_tmp27 = CostModelBuild(cost_model, xsize, cache_bits, refs);
  }
#line 594
  if (! __cil_tmp27) {
#line 595
    goto Error;
  }
  {
#line 598
  __cil_tmp28 = CostManagerInit(cost_manager, dist_array, pix_count, cost_model);
  }
#line 598
  if (! __cil_tmp28) {
#line 599
    goto Error;
  }
  {
#line 604
  *(dist_array + 0) = (uint16_t )0;
#line 606
  AddSingleLiteralWithCostModel(argb, & hashers, cost_model, 0, use_color_cache, 0.f,
                                cost_manager->costs_, dist_array);
#line 609
  i = 1;
  }
  {
#line 609
  while (1) {
    while_continue: /* CIL Label */ ;

#line 609
    if (! (i < pix_count)) {
#line 609
      goto while_break;
    }
    {
#line 610
    prev_cost = *(cost_manager->costs_ + (i - 1));
#line 612
    VP8LHashChainFindCopy(hash_chain, i, & offset, & len);
#line 615
    AddSingleLiteralWithCostModel(argb, & hashers, cost_model, i, use_color_cache,
                                  prev_cost, cost_manager->costs_, dist_array);
    }
#line 620
    if (len >= 2) {
#line 621
      if (offset != offset_prev) {
        {
#line 622
        __cil_tmp33 = VP8LDistanceToPlaneCode(xsize, offset);
#line 622
        code = __cil_tmp33;
#line 623
        offset_cost = GetDistanceCost(cost_model, (uint32_t )code);
#line 624
        first_offset_is_constant = 1;
#line 625
        PushInterval(cost_manager, (double )prev_cost + offset_cost, i, len);
        }
      } else {
#line 635
        if (first_offset_is_constant) {
#line 636
          reach = ((i - 1) + len_prev) - 1;
#line 637
          first_offset_is_constant = 0;
        }
#line 640
        if ((i + len) - 1 > reach) {
#line 649
          len_j = 0;
#line 654
          j = i;
          {
#line 654
          while (1) {
            while_continue___0: /* CIL Label */ ;

#line 654
            if (! (j <= reach)) {
#line 654
              goto while_break___0;
            }
            {
#line 655
            VP8LHashChainFindCopy(hash_chain, j + 1, & offset_j, & len_j);
            }
#line 656
            if (offset_j != offset) {
              {
#line 657
              VP8LHashChainFindCopy(hash_chain, j, & offset_j, & len_j);
              }
#line 658
              goto while_break___0;
            }
#line 654
            j ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          while_break___0: 
          {
#line 662
          UpdateCostAtIndex(cost_manager, j - 1, 0);
#line 663
          UpdateCostAtIndex(cost_manager, j, 0);
#line 665
          PushInterval(cost_manager, (double )*(cost_manager->costs_ + (j - 1)) + offset_cost,
                       j, len_j);
#line 667
          reach = (j + len_j) - 1;
          }
        }
      }
    }
    {
#line 672
    UpdateCostAtIndex(cost_manager, i, 1);
#line 673
    offset_prev = offset;
#line 674
    len_prev = len;
#line 609
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 677
  ok = ! refs->error_;
  Error: 
#line 679
  if (cc_init) {
    {
#line 679
    VP8LColorCacheClear(& hashers);
    }
  }
  {
#line 680
  CostManagerClear(cost_manager);
#line 681
  WebPSafeFree((void *)cost_model);
#line 682
  WebPSafeFree((void *)cost_manager);
  }
#line 683
  return (ok);
}
}
#line 689 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
static void TraceBackwards(uint16_t *dist_array , int dist_array_size , uint16_t **chosen_path ,
                           int *chosen_path_size ) 
{ 
  uint16_t *path ;
  uint16_t *cur ;
  int k ;

  {
#line 693
  path = dist_array + dist_array_size;
#line 694
  cur = (dist_array + dist_array_size) - 1;
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;

#line 695
    if (! ((unsigned long )cur >= (unsigned long )dist_array)) {
#line 695
      goto while_break;
    }
#line 696
    k = (int )*cur;
#line 697
    path --;
#line 698
    *path = (uint16_t )k;
#line 699
    cur -= k;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 701
  *chosen_path = path;
#line 702
  *chosen_path_size = (int )((dist_array + dist_array_size) - path);
#line 703
  return;
}
}
#line 705 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
static int BackwardReferencesHashChainFollowChosenPath(uint32_t *argb , int cache_bits ,
                                                       uint16_t *chosen_path , int chosen_path_size ,
                                                       VP8LHashChain *hash_chain ,
                                                       VP8LBackwardRefs *refs ) 
{ 
  int use_color_cache ;
  int ix ;
  int i ;
  int ok ;
  int cc_init ;
  VP8LColorCache hashers ;
  int len ;
  int k ;
  int offset ;
  int __cil_tmp17 ;
  PixOrCopy __cil_tmp18 ;
  PixOrCopy v ;
  int idx ;
  int __cil_tmp21 ;
  int tmp ;

  {
#line 709
  use_color_cache = cache_bits > 0;
#line 711
  i = 0;
#line 712
  ok = 0;
#line 713
  cc_init = 0;
#line 716
  if (use_color_cache) {
    {
#line 717
    cc_init = VP8LColorCacheInit(& hashers, cache_bits);
    }
#line 718
    if (! cc_init) {
#line 718
      goto Error;
    }
  }
  {
#line 721
  VP8LClearBackwardRefs(refs);
#line 722
  ix = 0;
  }
  {
#line 722
  while (1) {
    while_continue: /* CIL Label */ ;

#line 722
    if (! (ix < chosen_path_size)) {
#line 722
      goto while_break;
    }
#line 723
    len = (int )*(chosen_path + ix);
#line 724
    if (len != 1) {
      {
#line 726
      __cil_tmp17 = VP8LHashChainFindOffset(hash_chain, i);
#line 726
      offset = __cil_tmp17;
#line 727
      __cil_tmp18 = PixOrCopyCreateCopy((uint32_t )offset, (uint16_t )len);
#line 727
      VP8LBackwardRefsCursorAdd(refs, __cil_tmp18);
      }
#line 728
      if (use_color_cache) {
#line 729
        k = 0;
        {
#line 729
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 729
          if (! (k < len)) {
#line 729
            goto while_break___0;
          }
          {
#line 730
          VP8LColorCacheInsert___2(& hashers, *(argb + (i + k)));
#line 729
          k ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: ;
      }
#line 733
      i += len;
    } else {
#line 736
      if (use_color_cache) {
        {
#line 736
        __cil_tmp21 = VP8LColorCacheContains___2(& hashers, *(argb + i));
#line 736
        tmp = __cil_tmp21;
        }
      } else {
#line 736
        tmp = -1;
      }
#line 736
      idx = tmp;
#line 738
      if (idx >= 0) {
        {
#line 741
        v = PixOrCopyCreateCacheIdx(idx);
        }
      } else {
#line 743
        if (use_color_cache) {
          {
#line 743
          VP8LColorCacheInsert___2(& hashers, *(argb + i));
          }
        }
        {
#line 744
        v = PixOrCopyCreateLiteral(*(argb + i));
        }
      }
      {
#line 746
      VP8LBackwardRefsCursorAdd(refs, v);
#line 747
      i ++;
      }
    }
#line 722
    ix ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 750
  ok = ! refs->error_;
  Error: 
#line 752
  if (cc_init) {
    {
#line 752
    VP8LColorCacheClear(& hashers);
    }
  }
#line 753
  return (ok);
}
}
#line 761 "/root/patron-new/new_3/src/enc/backward_references_cost_enc.c"
int VP8LBackwardReferencesTraceBackwards(int xsize , int ysize , uint32_t *argb ,
                                         int cache_bits , VP8LHashChain *hash_chain ,
                                         VP8LBackwardRefs *refs_src , VP8LBackwardRefs *refs_dst ) 
{ 
  int ok ;
  int dist_array_size ;
  uint16_t *chosen_path ;
  int chosen_path_size ;
  uint16_t *dist_array ;
  void *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 767
  ok = 0;
#line 768
  dist_array_size = xsize * ysize;
#line 769
  chosen_path = (uint16_t *)((void *)0);
#line 770
  chosen_path_size = 0;
#line 771
  __cil_tmp13 = WebPSafeMalloc((uint64_t )dist_array_size, sizeof(*dist_array));
#line 771
  dist_array = (uint16_t *)__cil_tmp13;
  }
#line 774
  if ((unsigned long )dist_array == (unsigned long )((void *)0)) {
#line 774
    goto Error;
  }
  {
#line 776
  __cil_tmp14 = BackwardReferencesHashChainDistanceOnly(xsize, ysize, argb, cache_bits,
                                                        hash_chain, refs_src, dist_array);
  }
#line 776
  if (! __cil_tmp14) {
#line 778
    goto Error;
  }
  {
#line 780
  TraceBackwards(dist_array, dist_array_size, & chosen_path, & chosen_path_size);
#line 781
  __cil_tmp15 = BackwardReferencesHashChainFollowChosenPath(argb, cache_bits, chosen_path,
                                                            chosen_path_size, hash_chain,
                                                            refs_dst);
  }
#line 781
  if (! __cil_tmp15) {
#line 784
    goto Error;
  }
#line 786
  ok = 1;
  Error: 
  {
#line 788
  WebPSafeFree((void *)dist_array);
  }
#line 789
  return (ok);
}
}
#line 28 "/root/patron-new/new_3/src/enc/analysis_enc.c"
static void SmoothSegmentMap(VP8Encoder *enc ) 
{ 
  int n ;
  int x ;
  int y ;
  int w ;
  int h ;
  int majority_cnt_3_x_3_grid ;
  uint8_t *tmp ;
  void *__cil_tmp9 ;
  int cnt[4] ;
  unsigned int tmp___17 ;
  VP8MBInfo *mb ;
  int majority_seg ;
  VP8MBInfo *mb___0 ;

  {
  {
#line 30
  w = enc->mb_w_;
#line 31
  h = enc->mb_h_;
#line 32
  majority_cnt_3_x_3_grid = 5;
#line 33
  __cil_tmp9 = WebPSafeMalloc((uint64_t )(w * h), sizeof(*tmp));
#line 33
  tmp = (uint8_t *)__cil_tmp9;
  }
#line 36
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 36
    return;
  }
#line 37
  y = 1;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;

#line 37
    if (! (y < h - 1)) {
#line 37
      goto while_break;
    }
#line 38
    x = 1;
    {
#line 38
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 38
      if (! (x < w - 1)) {
#line 38
        goto while_break___0;
      }
#line 39
      cnt[0] = 0;
#line 39
      tmp___17 = 1U;
      {
#line 39
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 39
        if (tmp___17 >= 4U) {
#line 39
          goto while_break___1;
        }
#line 39
        cnt[tmp___17] = 0;
#line 39
        tmp___17 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: 
#line 40
      mb = enc->mb_info_ + (x + w * y);
#line 41
      majority_seg = (int )mb->segment_;
#line 43
      (cnt[(mb + (- w - 1))->segment_]) ++;
#line 44
      (cnt[(mb + - w)->segment_]) ++;
#line 45
      (cnt[(mb + (- w + 1))->segment_]) ++;
#line 46
      (cnt[(mb + -1)->segment_]) ++;
#line 47
      (cnt[(mb + 1)->segment_]) ++;
#line 48
      (cnt[(mb + (w - 1))->segment_]) ++;
#line 49
      (cnt[(mb + w)->segment_]) ++;
#line 50
      (cnt[(mb + (w + 1))->segment_]) ++;
#line 51
      n = 0;
      {
#line 51
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 51
        if (! (n < 4)) {
#line 51
          goto while_break___2;
        }
#line 52
        if (cnt[n] >= majority_cnt_3_x_3_grid) {
#line 53
          majority_seg = n;
#line 54
          goto while_break___2;
        }
#line 51
        n ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: 
#line 57
      *(tmp + (x + y * w)) = (uint8_t )majority_seg;
#line 38
      x ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: 
#line 37
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
#line 60
  y = 1;
  {
#line 60
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 60
    if (! (y < h - 1)) {
#line 60
      goto while_break___3;
    }
#line 61
    x = 1;
    {
#line 61
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 61
      if (! (x < w - 1)) {
#line 61
        goto while_break___4;
      }
#line 62
      mb___0 = enc->mb_info_ + (x + w * y);
#line 63
      mb___0->segment_ = (unsigned int )*(tmp + (x + y * w));
#line 61
      x ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: 
#line 60
    y ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___3: 
  {
#line 66
  WebPSafeFree((void *)tmp);
  }
#line 68
  return;
}
}
#line 76 "/root/patron-new/new_3/src/enc/analysis_enc.c"
static void SetSegmentAlphas(VP8Encoder *enc , int const   *centers , int mid ) 
{ 
  int nb ;
  int min ;
  int max ;
  int n ;
  int alpha ;
  int beta ;

  {
#line 79
  nb = enc->segment_hdr_.num_segments_;
#line 80
  min = (int )*(centers + 0);
#line 80
  max = (int )*(centers + 0);
#line 83
  if (nb > 1) {
#line 84
    n = 0;
    {
#line 84
    while (1) {
      while_continue: /* CIL Label */ ;

#line 84
      if (! (n < nb)) {
#line 84
        goto while_break;
      }
#line 85
      if (min > (int )*(centers + n)) {
#line 85
        min = (int )*(centers + n);
      }
#line 86
      if (max < (int )*(centers + n)) {
#line 86
        max = (int )*(centers + n);
      }
#line 84
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 89
  if (max == min) {
#line 89
    max = min + 1;
  }
#line 91
  n = 0;
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 91
    if (! (n < nb)) {
#line 91
      goto while_break___0;
    }
    {
#line 92
    alpha = (255 * (int )(*(centers + n) - (int const   )mid)) / (max - min);
#line 93
    beta = (255 * (int )(*(centers + n) - (int const   )min)) / (max - min);
#line 94
    enc->dqm_[n].alpha_ = clip(alpha, -127, 127);
#line 95
    enc->dqm_[n].beta_ = clip(beta, 0, 255);
#line 91
    n ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 95
  return;
}
}
#line 108 "/root/patron-new/new_3/src/enc/analysis_enc.c"
static int FinalAlphaValue(int alpha ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 109
  alpha = 255 - alpha;
#line 110
  __cil_tmp2 = clip(alpha, 0, 255);
  }
#line 110
  return (__cil_tmp2);
}
}
#line 113 "/root/patron-new/new_3/src/enc/analysis_enc.c"
static int GetAlpha(VP8Histogram *histo ) 
{ 
  int max_value ;
  int last_non_zero ;
  int alpha ;
  int tmp ;

  {
#line 117
  max_value = histo->max_value;
#line 118
  last_non_zero = histo->last_non_zero;
#line 119
  if (max_value > 1) {
#line 119
    tmp = (510 * last_non_zero) / max_value;
  } else {
#line 119
    tmp = 0;
  }
#line 119
  alpha = tmp;
#line 121
  return (alpha);
}
}
#line 124 "/root/patron-new/new_3/src/enc/analysis_enc.c"
static void InitHistogram(VP8Histogram *histo ) 
{ 


  {
#line 125
  histo->max_value = 0;
#line 126
  histo->last_non_zero = 1;
#line 127
  return;
}
}
#line 132 "/root/patron-new/new_3/src/enc/analysis_enc.c"
static void AssignSegments(VP8Encoder *enc , int const   *alphas ) 
{ 
  int nb ;
  int tmp ;
  int centers[4] ;
  int weighted_average ;
  int map[256] ;
  int a ;
  int n ;
  int k ;
  int min_a ;
  int max_a ;
  int range_a ;
  int accum[4] ;
  int dist_accum[4] ;
  int total_weight ;
  int displaced ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int new_center ;
  int __cil_tmp22 ;
  VP8MBInfo *mb ;
  int alpha ;
  int smooth ;

  {
#line 137
  if (enc->segment_hdr_.num_segments_ < 4) {
#line 137
    tmp = enc->segment_hdr_.num_segments_;
  } else {
#line 137
    tmp = 4;
  }
#line 137
  nb = tmp;
#line 140
  weighted_average = 0;
#line 143
  min_a = 0;
#line 143
  max_a = 255;
#line 151
  n = 0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;

#line 151
    if (n <= 255) {
#line 151
      if (! (*(alphas + n) == 0)) {
#line 151
        goto while_break;
      }
    } else {
#line 151
      goto while_break;
    }
#line 151
    n ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: 
#line 152
  min_a = n;
#line 153
  n = 255;
  {
#line 153
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 153
    if (n > min_a) {
#line 153
      if (! (*(alphas + n) == 0)) {
#line 153
        goto while_break___0;
      }
    } else {
#line 153
      goto while_break___0;
    }
#line 153
    n --;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___0: 
#line 154
  max_a = n;
#line 155
  range_a = max_a - min_a;
#line 158
  n = 1;
#line 158
  k = 0;
  {
#line 158
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 158
    if (! (k < nb)) {
#line 158
      goto while_break___1;
    }
#line 160
    centers[k] = min_a + (n * range_a) / (2 * nb);
#line 158
    n += 2;
#line 158
    k ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___1: 
#line 163
  k = 0;
  {
#line 163
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 163
    if (! (k < 6)) {
#line 163
      goto while_break___2;
    }
#line 167
    n = 0;
    {
#line 167
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 167
      if (! (n < nb)) {
#line 167
        goto while_break___3;
      }
#line 168
      accum[n] = 0;
#line 169
      dist_accum[n] = 0;
#line 167
      n ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___3: 
#line 172
    n = 0;
#line 173
    a = min_a;
    {
#line 173
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 173
      if (! (a <= max_a)) {
#line 173
        goto while_break___4;
      }
#line 174
      if (*(alphas + a)) {
        {
#line 175
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 175
          __cil_tmp19 = abs(a - centers[n]);
#line 175
          __cil_tmp18 = abs(a - centers[n + 1]);
          }
#line 175
          if (n + 1 < nb) {
#line 175
            if (! (__cil_tmp18 < __cil_tmp19)) {
#line 175
              goto while_break___5;
            }
          } else {
#line 175
            goto while_break___5;
          }
#line 176
          n ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___5: 
#line 178
        map[a] = n;
#line 180
        dist_accum[n] += a * (int )*(alphas + a);
#line 181
        accum[n] += (int )*(alphas + a);
      }
#line 173
      a ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___4: 
#line 186
    displaced = 0;
#line 187
    weighted_average = 0;
#line 188
    total_weight = 0;
#line 189
    n = 0;
    {
#line 189
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 189
      if (! (n < nb)) {
#line 189
        goto while_break___6;
      }
#line 190
      if (accum[n]) {
        {
#line 191
        new_center = (dist_accum[n] + accum[n] / 2) / accum[n];
#line 192
        __cil_tmp22 = abs(centers[n] - new_center);
#line 192
        displaced += __cil_tmp22;
#line 193
        centers[n] = new_center;
#line 194
        weighted_average += new_center * accum[n];
#line 195
        total_weight += accum[n];
        }
      }
#line 189
      n ++;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___6: 
#line 198
    weighted_average = (weighted_average + total_weight / 2) / total_weight;
#line 199
    if (displaced < 5) {
#line 199
      goto while_break___2;
    }
#line 163
    k ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___2: 
#line 203
  n = 0;
  {
#line 203
  while (1) {
    while_continue___7: /* CIL Label */ ;

#line 203
    if (! (n < enc->mb_w_ * enc->mb_h_)) {
#line 203
      goto while_break___7;
    }
#line 204
    mb = enc->mb_info_ + n;
#line 205
    alpha = (int )mb->alpha_;
#line 206
    mb->segment_ = (unsigned int )map[alpha];
#line 207
    mb->alpha_ = (uint8_t )centers[map[alpha]];
#line 203
    n ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___7: ;
#line 210
  if (nb > 1) {
#line 211
    smooth = (enc->config_)->preprocessing & 1;
#line 212
    if (smooth) {
      {
#line 212
      SmoothSegmentMap(enc);
      }
    }
  }
  {
#line 215
  SetSegmentAlphas(enc, (int const   *)((int const   *)(centers)), weighted_average);
  }
#line 217
  return;
}
}
#line 230 "/root/patron-new/new_3/src/enc/analysis_enc.c"
static int MBAnalyzeBestIntra16Mode(VP8EncIterator *it ) 
{ 
  int max_mode ;
  int mode ;
  int best_alpha ;
  int best_mode ;
  VP8Histogram histo ;
  int alpha ;

  {
  {
#line 231
  max_mode = 2;
#line 233
  best_alpha = -1;
#line 234
  best_mode = 0;
#line 236
  VP8MakeLuma16Preds(it);
#line 237
  mode = 0;
  }
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;

#line 237
    if (! (mode < max_mode)) {
#line 237
      goto while_break;
    }
    {
#line 241
    InitHistogram(& histo);
#line 242
    (*VP8CollectHistogram)(it->yuv_in_ + 0, it->yuv_p_ + (int )VP8I16ModeOffsets[mode],
                           0, 16, (VP8Histogram */* const  */)(& histo));
#line 245
    alpha = GetAlpha(& histo);
    }
#line 246
    if (alpha > best_alpha) {
#line 247
      best_alpha = alpha;
#line 248
      best_mode = mode;
    }
#line 237
    mode ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 251
  VP8SetIntra16Mode(it, best_mode);
  }
#line 252
  return (best_alpha);
}
}
#line 255 "/root/patron-new/new_3/src/enc/analysis_enc.c"
static int FastMBAnalyze(VP8EncIterator *it ) 
{ 
  int q ;
  uint32_t kThreshold ;
  int k ;
  uint32_t dc[16] ;
  uint32_t m ;
  uint32_t m2 ;
  uint8_t modes[16] ;
  unsigned int tmp ;

  {
#line 258
  q = (int )((it->enc_)->config_)->quality;
#line 259
  kThreshold = (uint32_t )(8 + (9 * q) / 100);
#line 262
  k = 0;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;

#line 262
    if (! (k < 16)) {
#line 262
      goto while_break;
    }
    {
#line 263
    (*VP8Mean16x4)((it->yuv_in_ + 0) + k * 32, (uint32_t *)(& dc[k]));
#line 262
    k += 4;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 265
  k = 0;
#line 265
  m2 = (uint32_t )0;
#line 265
  m = (uint32_t )0;
  {
#line 265
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 265
    if (! (k < 16)) {
#line 265
      goto while_break___0;
    }
#line 266
    m += dc[k];
#line 267
    m2 += dc[k] * dc[k];
#line 265
    k ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 269
  if (kThreshold * m2 < m * m) {
    {
#line 270
    VP8SetIntra16Mode(it, 0);
    }
  } else {
#line 272
    modes[0] = (uint8_t )0;
#line 272
    tmp = 1U;
    {
#line 272
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 272
      if (tmp >= 16U) {
#line 272
        goto while_break___1;
      }
#line 272
      modes[tmp] = (uint8_t )0;
#line 272
      tmp ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 273
    VP8SetIntra4Mode(it, modes);
    }
  }
#line 275
  return (0);
}
}
#line 278 "/root/patron-new/new_3/src/enc/analysis_enc.c"
static int MBAnalyzeBestUVMode(VP8EncIterator *it ) 
{ 
  int best_alpha ;
  int smallest_alpha ;
  int best_mode ;
  int max_mode ;
  int mode ;
  VP8Histogram histo ;
  int alpha ;

  {
  {
#line 279
  best_alpha = -1;
#line 280
  smallest_alpha = 0;
#line 281
  best_mode = 0;
#line 282
  max_mode = 2;
#line 285
  VP8MakeChroma8Preds(it);
#line 286
  mode = 0;
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;

#line 286
    if (! (mode < max_mode)) {
#line 286
      goto while_break;
    }
    {
#line 289
    InitHistogram(& histo);
#line 290
    (*VP8CollectHistogram)(it->yuv_in_ + 16, it->yuv_p_ + (int )VP8UVModeOffsets[mode],
                           16, 24, (VP8Histogram */* const  */)(& histo));
#line 293
    alpha = GetAlpha(& histo);
    }
#line 294
    if (alpha > best_alpha) {
#line 295
      best_alpha = alpha;
    }
#line 298
    if (mode == 0) {
#line 299
      smallest_alpha = alpha;
#line 300
      best_mode = mode;
    } else
#line 298
    if (alpha < smallest_alpha) {
#line 299
      smallest_alpha = alpha;
#line 300
      best_mode = mode;
    }
#line 286
    mode ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 303
  VP8SetIntraUVMode(it, best_mode);
  }
#line 304
  return (best_alpha);
}
}
#line 307 "/root/patron-new/new_3/src/enc/analysis_enc.c"
static void MBAnalyze(VP8EncIterator *it , int *alphas , int *alpha , int *uv_alpha ) 
{ 
  VP8Encoder *enc ;
  int best_alpha ;
  int best_uv_alpha ;

  {
  {
#line 310
  enc = it->enc_;
#line 313
  VP8SetIntra16Mode(it, 0);
#line 314
  VP8SetSkip(it, 0);
#line 315
  VP8SetSegment(it, 0);
  }
#line 317
  if (enc->method_ <= 1) {
    {
#line 318
    best_alpha = FastMBAnalyze(it);
    }
  } else {
    {
#line 320
    best_alpha = MBAnalyzeBestIntra16Mode(it);
    }
  }
  {
#line 322
  best_uv_alpha = MBAnalyzeBestUVMode(it);
#line 325
  best_alpha = ((3 * best_alpha + best_uv_alpha) + 2) >> 2;
#line 326
  best_alpha = FinalAlphaValue(best_alpha);
#line 327
  (*(alphas + best_alpha)) ++;
#line 328
  (it->mb_)->alpha_ = (uint8_t )best_alpha;
#line 331
  *alpha += best_alpha;
#line 332
  *uv_alpha += best_uv_alpha;
  }
#line 334
  return;
}
}
#line 335 "/root/patron-new/new_3/src/enc/analysis_enc.c"
static void DefaultMBInfo(VP8MBInfo *mb ) 
{ 


  {
#line 336
  mb->type_ = 1U;
#line 337
  mb->uv_mode_ = 0U;
#line 338
  mb->skip_ = 0U;
#line 339
  mb->segment_ = 0U;
#line 340
  mb->alpha_ = (uint8_t )0;
#line 341
  return;
}
}
#line 353 "/root/patron-new/new_3/src/enc/analysis_enc.c"
static void ResetAllMBInfo(VP8Encoder *enc ) 
{ 
  int n ;

  {
#line 355
  n = 0;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;

#line 355
    if (! (n < enc->mb_w_ * enc->mb_h_)) {
#line 355
      goto while_break;
    }
    {
#line 356
    DefaultMBInfo(enc->mb_info_ + n);
#line 355
    n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 359
  enc->dqm_[0].alpha_ = 0;
#line 360
  enc->dqm_[0].beta_ = 0;
#line 362
  enc->alpha_ = 0;
#line 363
  enc->uv_alpha_ = 0;
#line 364
  WebPReportProgress(enc->pic_, enc->percent_ + 20, & enc->percent_);
  }
#line 366
  return;
}
}
#line 377 "/root/patron-new/new_3/src/enc/analysis_enc.c"
static int DoSegmentsJob(void *arg1 , void *arg2 ) 
{ 
  SegmentJob *job ;
  VP8EncIterator *it ;
  int ok ;
  int __cil_tmp6 ;
  uint8_t tmp[63] ;
  uint8_t *scratch ;
  int __cil_tmp9 ;

  {
  {
#line 378
  job = (SegmentJob *)arg1;
#line 379
  it = (VP8EncIterator *)arg2;
#line 380
  ok = 1;
#line 381
  __cil_tmp6 = VP8IteratorIsDone(it);
  }
#line 381
  if (! __cil_tmp6) {
#line 383
    scratch = (uint8_t *)(((uintptr_t )(tmp) + 31UL) & 0xffffffffffffffe0UL);
    {
#line 384
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 386
      VP8IteratorImport(it, scratch);
#line 387
      MBAnalyze(it, (int *)(job->alphas), & job->alpha, & job->uv_alpha);
#line 388
      ok = VP8IteratorProgress(it, job->delta_progress);
      }
#line 384
      if (ok) {
#line 384
        if (! __cil_tmp9) {
#line 384
          goto while_break;
        }
      } else {
#line 384
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 391
  return (ok);
}
}
#line 394 "/root/patron-new/new_3/src/enc/analysis_enc.c"
static void MergeJobs(SegmentJob *src , SegmentJob *dst ) 
{ 
  int i ;

  {
#line 396
  i = 0;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;

#line 396
    if (! (i <= 255)) {
#line 396
      goto while_break;
    }
#line 396
    dst->alphas[i] += src->alphas[i];
#line 396
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 397
  dst->alpha += src->alpha;
#line 398
  dst->uv_alpha += src->uv_alpha;
#line 399
  return;
}
}
#line 402 "/root/patron-new/new_3/src/enc/analysis_enc.c"
static void InitSegmentJob(VP8Encoder *enc , SegmentJob *job , int start_row , int end_row ) 
{ 
  WebPWorkerInterface *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 404
  (*(__cil_tmp5->Init))((WebPWorker */* const  */)(& job->worker));
#line 405
  job->worker.data1 = (void *)job;
#line 406
  job->worker.data2 = (void *)(& job->it);
#line 407
  job->worker.hook = & DoSegmentsJob;
#line 408
  VP8IteratorInit(enc, & job->it);
#line 409
  VP8IteratorSetRow(& job->it, start_row);
#line 410
  VP8IteratorSetCountDown(& job->it, (end_row - start_row) * enc->mb_w_);
#line 411
  memset((void *)(job->alphas), 0, sizeof(job->alphas));
#line 412
  job->alpha = 0;
#line 413
  job->uv_alpha = 0;
  }
#line 416
  if (start_row == 0) {
#line 416
    tmp = 20;
  } else {
#line 416
    tmp = 0;
  }
#line 416
  job->delta_progress = tmp;
#line 417
  return;
}
}
#line 420 "/root/patron-new/new_3/src/enc/analysis_enc.c"
int VP8EncAnalyze(VP8Encoder *enc ) 
{ 
  int ok ;
  int do_segments ;
  int last_row ;
  int split_row ;
  int total_mb ;
  int kMinSplitRow ;
  int do_mt ;
  WebPWorkerInterface *worker_interface ;
  WebPWorkerInterface *__cil_tmp10 ;
  SegmentJob main_job ;
  SegmentJob side_job ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;

  {
#line 421
  ok = 1;
#line 422
  if ((enc->config_)->emulate_jpeg_size) {
#line 422
    tmp = 1;
  } else
#line 422
  if (enc->segment_hdr_.num_segments_ > 1) {
#line 422
    tmp = 1;
  } else
#line 422
  if (enc->method_ <= 1) {
#line 422
    tmp = 1;
  } else {
#line 422
    tmp = 0;
  }
#line 422
  do_segments = tmp;
#line 426
  if (do_segments) {
#line 427
    last_row = enc->mb_h_;
#line 429
    split_row = (9 * last_row + 15) >> 4;
#line 430
    total_mb = last_row * enc->mb_w_;
#line 432
    kMinSplitRow = 2;
#line 433
    if (enc->thread_level_ > 0) {
#line 433
      if (split_row >= kMinSplitRow) {
#line 433
        tmp___0 = 1;
      } else {
#line 433
        tmp___0 = 0;
      }
    } else {
#line 433
      tmp___0 = 0;
    }
    {
#line 433
    do_mt = tmp___0;
#line 437
    __cil_tmp10 = WebPGetWorkerInterface();
#line 437
    worker_interface = __cil_tmp10;
    }
#line 440
    if (do_mt) {
      {
#line 444
      InitSegmentJob(enc, & main_job, 0, split_row);
#line 445
      InitSegmentJob(enc, & side_job, split_row, last_row);
#line 448
      __cil_tmp13 = (*(worker_interface->Reset))((WebPWorker */* const  */)(& side_job.worker));
#line 448
      ok &= __cil_tmp13;
      }
#line 450
      if (ok) {
        {
#line 451
        (*(worker_interface->Launch))((WebPWorker */* const  */)(& side_job.worker));
#line 452
        (*(worker_interface->Execute))((WebPWorker */* const  */)(& main_job.worker));
#line 453
        __cil_tmp14 = (*(worker_interface->Sync))((WebPWorker */* const  */)(& side_job.worker));
#line 453
        ok &= __cil_tmp14;
#line 454
        __cil_tmp15 = (*(worker_interface->Sync))((WebPWorker */* const  */)(& main_job.worker));
#line 454
        ok &= __cil_tmp15;
        }
      }
      {
#line 456
      (*(worker_interface->End))((WebPWorker */* const  */)(& side_job.worker));
      }
#line 457
      if (ok) {
        {
#line 457
        MergeJobs(& side_job, & main_job);
        }
      }
    } else {
      {
#line 460
      InitSegmentJob(enc, & main_job, 0, last_row);
#line 461
      (*(worker_interface->Execute))((WebPWorker */* const  */)(& main_job.worker));
#line 462
      __cil_tmp16 = (*(worker_interface->Sync))((WebPWorker */* const  */)(& main_job.worker));
#line 462
      ok &= __cil_tmp16;
      }
    }
    {
#line 464
    (*(worker_interface->End))((WebPWorker */* const  */)(& main_job.worker));
    }
#line 465
    if (ok) {
      {
#line 466
      enc->alpha_ = main_job.alpha / total_mb;
#line 467
      enc->uv_alpha_ = main_job.uv_alpha / total_mb;
#line 468
      AssignSegments(enc, (int const   *)((int const   *)(main_job.alphas)));
      }
    }
  } else {
    {
#line 471
    ResetAllMBInfo(enc);
    }
  }
#line 473
  return (ok);
}
}
#line 49 "/root/patron-new/new_3/src/enc/alpha_enc.c"
static int EncodeLossless(uint8_t *data , int width , int height , int effort_level ,
                          int use_quality_100 , VP8LBitWriter *bw , WebPAuxStats *stats ) 
{ 
  int ok ;
  WebPConfig config ;
  WebPPicture picture ;
  int __cil_tmp11 ;
  float tmp ;
  WebPEncodingError __cil_tmp13 ;
  int tmp___0 ;

  {
  {
#line 53
  ok = 0;
#line 57
  WebPPictureInit(& picture);
#line 58
  picture.width = width;
#line 59
  picture.height = height;
#line 60
  picture.use_argb = 1;
#line 61
  picture.stats = stats;
#line 62
  __cil_tmp11 = WebPPictureAlloc(& picture);
  }
#line 62
  if (! __cil_tmp11) {
#line 62
    return (0);
  }
  {
#line 65
  (*WebPDispatchAlphaToGreen)(data, width, picture.width, picture.height, picture.argb,
                              picture.argb_stride);
#line 68
  WebPConfigInit(& config);
#line 69
  config.lossless = 1;
#line 74
  config.exact = 1;
#line 75
  config.method = effort_level;
  }
#line 81
  if (use_quality_100) {
#line 81
    if (effort_level == 6) {
#line 81
      tmp = (float )100;
    } else {
#line 81
      tmp = 8.f * (float )effort_level;
    }
  } else {
#line 81
    tmp = 8.f * (float )effort_level;
  }
  {
#line 81
  config.quality = tmp;
#line 89
  __cil_tmp13 = VP8LEncodeStream(& config, & picture, bw, 0);
#line 89
  ok = (unsigned int )__cil_tmp13 == 0U;
#line 90
  WebPPictureFree(& picture);
  }
#line 91
  if (ok) {
#line 91
    if (! bw->error_) {
#line 91
      tmp___0 = 1;
    } else {
#line 91
      tmp___0 = 0;
    }
  } else {
#line 91
    tmp___0 = 0;
  }
#line 91
  ok = tmp___0;
#line 92
  if (! ok) {
    {
#line 93
    VP8LBitWriterWipeOut(bw);
    }
#line 94
    return (0);
  }
#line 96
  return (1);
}
}
#line 109 "/root/patron-new/new_3/src/enc/alpha_enc.c"
static int EncodeAlphaInternal(uint8_t *data , int width , int height , int method ,
                               int filter , int reduce_levels , int effort_level ,
                               uint8_t *tmp_alpha , FilterTrial *result ) 
{ 
  int ok ;
  uint8_t *alpha_src ;
  void (*filter_func)(uint8_t * , int  , int  , int  , uint8_t * ) ;
  uint8_t header ;
  size_t data_size ;
  uint8_t *output ;
  size_t output_size ;
  VP8LBitWriter tmp_bw ;
  int __cil_tmp19 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 114
  ok = 0;
#line 118
  data_size = (size_t )(width * height);
#line 119
  output = (uint8_t *)((void *)0);
#line 120
  output_size = (size_t )0;
#line 129
  filter_func = WebPFilters[filter];
#line 130
  if ((unsigned long )filter_func != (unsigned long )((void *)0)) {
    {
#line 131
    (*filter_func)(data, width, height, width, tmp_alpha);
#line 132
    alpha_src = tmp_alpha;
    }
  } else {
#line 134
    alpha_src = data;
  }
#line 137
  if (method != 0) {
    {
#line 138
    ok = VP8LBitWriterInit(& tmp_bw, data_size >> 3);
#line 139
    __cil_tmp19 = EncodeLossless(alpha_src, width, height, effort_level, ! reduce_levels,
                                 & tmp_bw, & result->stats);
    }
#line 139
    if (ok) {
#line 139
      if (__cil_tmp19) {
#line 139
        tmp = 1;
      } else {
#line 139
        tmp = 0;
      }
    } else {
#line 139
      tmp = 0;
    }
#line 139
    ok = tmp;
#line 141
    if (ok) {
      {
#line 142
      output = VP8LBitWriterFinish(& tmp_bw);
#line 143
      output_size = VP8LBitWriterNumBytes(& tmp_bw);
      }
#line 144
      if (output_size > data_size) {
        {
#line 146
        method = 0;
#line 147
        VP8LBitWriterWipeOut(& tmp_bw);
        }
      }
    } else {
      {
#line 150
      VP8LBitWriterWipeOut(& tmp_bw);
      }
#line 151
      return (0);
    }
  }
#line 155
  if (method == 0) {
#line 156
    output = alpha_src;
#line 157
    output_size = data_size;
#line 158
    ok = 1;
  }
#line 162
  header = (uint8_t )(method | (filter << 2));
#line 163
  if (reduce_levels) {
#line 163
    header = (uint8_t )((int )header | (1 << 4));
  }
  {
#line 165
  VP8BitWriterInit(& result->bw, 1UL + output_size);
#line 166
  __cil_tmp22 = VP8BitWriterAppend(& result->bw, & header, (size_t )1);
  }
#line 166
  if (ok) {
#line 166
    if (__cil_tmp22) {
#line 166
      tmp___0 = 1;
    } else {
#line 166
      tmp___0 = 0;
    }
  } else {
#line 166
    tmp___0 = 0;
  }
  {
#line 166
  ok = tmp___0;
#line 167
  __cil_tmp23 = VP8BitWriterAppend(& result->bw, output, output_size);
  }
#line 167
  if (ok) {
#line 167
    if (__cil_tmp23) {
#line 167
      tmp___1 = 1;
    } else {
#line 167
      tmp___1 = 0;
    }
  } else {
#line 167
    tmp___1 = 0;
  }
#line 167
  ok = tmp___1;
#line 169
  if (method != 0) {
    {
#line 170
    VP8LBitWriterWipeOut(& tmp_bw);
    }
  }
#line 172
  if (ok) {
#line 172
    if (! result->bw.error_) {
#line 172
      tmp___2 = 1;
    } else {
#line 172
      tmp___2 = 0;
    }
  } else {
#line 172
    tmp___2 = 0;
  }
  {
#line 172
  ok = tmp___2;
#line 173
  result->score = VP8BitWriterSize(& result->bw);
  }
#line 174
  return (ok);
}
}
#line 179 "/root/patron-new/new_3/src/enc/alpha_enc.c"
static int GetNumColors(uint8_t *data , int width , int height , int stride ) 
{ 
  int j ;
  int colors ;
  uint8_t color[256] ;
  unsigned int tmp ;
  int i ;
  uint8_t *p ;

  {
#line 182
  colors = 0;
#line 183
  color[0] = (uint8_t )0;
#line 183
  tmp = 1U;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;

#line 183
    if (tmp >= 256U) {
#line 183
      goto while_break;
    }
#line 183
    color[tmp] = (uint8_t )0;
#line 183
    tmp ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 185
  j = 0;
  {
#line 185
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 185
    if (! (j < height)) {
#line 185
      goto while_break___0;
    }
#line 187
    p = data + j * stride;
#line 188
    i = 0;
    {
#line 188
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 188
      if (! (i < width)) {
#line 188
        goto while_break___1;
      }
#line 189
      color[*(p + i)] = (uint8_t )1;
#line 188
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 185
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
#line 192
  j = 0;
  {
#line 192
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 192
    if (! (j < 256)) {
#line 192
      goto while_break___2;
    }
#line 193
    if ((int )color[j] > 0) {
#line 193
      colors ++;
    }
#line 192
    j ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 195
  return (colors);
}
}
#line 202 "/root/patron-new/new_3/src/enc/alpha_enc.c"
static uint32_t GetFilterMap(uint8_t *alpha , int width , int height , int filter ,
                             int effort_level ) 
{ 
  uint32_t bit_map ;
  int try_filter_none ;
  int kMinColorsForFilterNone ;
  int kMaxColorsForFilterNone ;
  int num_colors ;
  int __cil_tmp11 ;
  WEBP_FILTER_TYPE __cil_tmp12 ;
  unsigned int tmp ;

  {
#line 204
  bit_map = 0U;
#line 205
  if (filter == 6) {
    {
#line 207
    try_filter_none = effort_level > 3;
#line 208
    kMinColorsForFilterNone = 16;
#line 209
    kMaxColorsForFilterNone = 192;
#line 210
    __cil_tmp11 = GetNumColors(alpha, width, height, width);
#line 210
    num_colors = __cil_tmp11;
    }
#line 212
    if (num_colors <= kMinColorsForFilterNone) {
#line 212
      tmp = 0U;
    } else {
      {
#line 212
      __cil_tmp12 = WebPEstimateBestFilter(alpha, width, height, width);
#line 212
      tmp = (unsigned int )__cil_tmp12;
      }
    }
#line 212
    filter = (int )tmp;
#line 215
    bit_map |= (unsigned int )(1 << filter);
#line 218
    if (try_filter_none) {
#line 219
      bit_map |= 1U;
    } else
#line 218
    if (num_colors > kMaxColorsForFilterNone) {
#line 219
      bit_map |= 1U;
    }
  } else
#line 221
  if (filter == 0) {
#line 222
    bit_map = (uint32_t )1;
  } else {
#line 224
    bit_map = (uint32_t )((1 << 4) - 1);
  }
#line 226
  return (bit_map);
}
}
#line 229 "/root/patron-new/new_3/src/enc/alpha_enc.c"
static void InitFilterTrial(FilterTrial *score ) 
{ 


  {
  {
#line 230
  score->score = (size_t )(~ 0U);
#line 231
  VP8BitWriterInit(& score->bw, (size_t )0);
  }
#line 233
  return;
}
}
#line 234 "/root/patron-new/new_3/src/enc/alpha_enc.c"
static int ApplyFiltersAndEncode(uint8_t *alpha , int width , int height , size_t data_size ,
                                 int method , int filter , int reduce_levels , int effort_level ,
                                 uint8_t **output , size_t *output_size , WebPAuxStats *stats ) 
{ 
  int ok ;
  FilterTrial best ;
  uint32_t try_map ;
  uint32_t __cil_tmp15 ;
  uint8_t *filtered_alpha ;
  void *__cil_tmp17 ;
  FilterTrial trial ;

  {
  {
#line 240
  ok = 1;
#line 242
  __cil_tmp15 = GetFilterMap(alpha, width, height, filter, effort_level);
#line 242
  try_map = __cil_tmp15;
#line 244
  InitFilterTrial(& best);
  }
#line 246
  if (try_map != 1U) {
    {
#line 247
    __cil_tmp17 = WebPSafeMalloc((uint64_t )1ULL, data_size);
#line 247
    filtered_alpha = (uint8_t *)__cil_tmp17;
    }
#line 248
    if ((unsigned long )filtered_alpha == (unsigned long )((void *)0)) {
#line 248
      return (0);
    }
#line 250
    filter = 0;
    {
#line 250
    while (1) {
      while_continue: /* CIL Label */ ;

#line 250
      if (ok) {
#line 250
        if (! try_map) {
#line 250
          goto while_break;
        }
      } else {
#line 250
        goto while_break;
      }
#line 251
      if (try_map & 1U) {
        {
#line 253
        ok = EncodeAlphaInternal(alpha, width, height, method, filter, reduce_levels,
                                 effort_level, filtered_alpha, & trial);
        }
#line 256
        if (ok) {
#line 256
          if (trial.score < best.score) {
            {
#line 257
            VP8BitWriterWipeOut(& best.bw);
#line 258
            best = trial;
            }
          } else {
            {
#line 260
            VP8BitWriterWipeOut(& trial.bw);
            }
          }
        } else {
          {
#line 260
          VP8BitWriterWipeOut(& trial.bw);
          }
        }
      }
#line 250
      try_map >>= 1;
#line 250
      filter ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 264
    WebPSafeFree((void *)filtered_alpha);
    }
  } else {
    {
#line 266
    ok = EncodeAlphaInternal(alpha, width, height, method, 0, reduce_levels, effort_level,
                             (uint8_t *)((void *)0), & best);
    }
  }
#line 269
  if (ok) {
#line 271
    if ((unsigned long )stats != (unsigned long )((void *)0)) {
#line 272
      stats->lossless_features = best.stats.lossless_features;
#line 273
      stats->histogram_bits = best.stats.histogram_bits;
#line 274
      stats->transform_bits = best.stats.transform_bits;
#line 275
      stats->cache_bits = best.stats.cache_bits;
#line 276
      stats->palette_size = best.stats.palette_size;
#line 277
      stats->lossless_size = best.stats.lossless_size;
#line 278
      stats->lossless_hdr_size = best.stats.lossless_hdr_size;
#line 279
      stats->lossless_data_size = best.stats.lossless_data_size;
    }
    {
#line 284
    *output_size = VP8BitWriterSize(& best.bw);
#line 285
    *output = VP8BitWriterBuf(& best.bw);
    }
  } else {
    {
#line 287
    VP8BitWriterWipeOut(& best.bw);
    }
  }
#line 289
  return (ok);
}
}
#line 292 "/root/patron-new/new_3/src/enc/alpha_enc.c"
static int EncodeAlpha(VP8Encoder *enc , int quality , int method , int filter , int effort_level ,
                       uint8_t **output , size_t *output_size ) 
{ 
  WebPPicture *pic ;
  int width ;
  int height ;
  uint8_t *quant_alpha ;
  size_t data_size ;
  uint64_t sse ;
  int ok ;
  int reduce_levels ;
  void *__cil_tmp16 ;
  int alpha_levels ;
  int tmp ;

  {
#line 296
  pic = enc->pic_;
#line 297
  width = pic->width;
#line 298
  height = pic->height;
#line 300
  quant_alpha = (uint8_t *)((void *)0);
#line 301
  data_size = (size_t )(width * height);
#line 302
  sse = (uint64_t )0;
#line 303
  ok = 1;
#line 304
  reduce_levels = quality < 100;
#line 314
  if (quality < 0) {
#line 315
    return (0);
  } else
#line 314
  if (quality > 100) {
#line 315
    return (0);
  }
#line 318
  if (method < 0) {
#line 319
    return (0);
  } else
#line 318
  if (method > 1) {
#line 319
    return (0);
  }
#line 322
  if (method == 0) {
#line 324
    filter = 0;
  }
  {
#line 327
  __cil_tmp16 = WebPSafeMalloc((uint64_t )1ULL, data_size);
#line 327
  quant_alpha = (uint8_t *)__cil_tmp16;
  }
#line 328
  if ((unsigned long )quant_alpha == (unsigned long )((void *)0)) {
#line 329
    return (0);
  }
  {
#line 333
  WebPCopyPlane(pic->a, pic->a_stride, quant_alpha, width, width, height);
  }
#line 335
  if (reduce_levels) {
#line 339
    if (quality <= 70) {
#line 339
      tmp = 2 + quality / 5;
    } else {
#line 339
      tmp = 16 + (quality - 70) * 8;
    }
    {
#line 339
    alpha_levels = tmp;
#line 341
    ok = QuantizeLevels(quant_alpha, width, height, alpha_levels, & sse);
    }
  }
#line 344
  if (ok) {
    {
#line 345
    VP8FiltersInit();
#line 346
    ok = ApplyFiltersAndEncode(quant_alpha, width, height, data_size, method, filter,
                               reduce_levels, effort_level, output, output_size, pic->stats);
    }
#line 350
    if ((unsigned long )pic->stats != (unsigned long )((void *)0)) {
#line 351
      (pic->stats)->coded_size += (int )*output_size;
#line 352
      enc->sse_[3] = sse;
    }
  }
  {
#line 357
  WebPSafeFree((void *)quant_alpha);
  }
#line 358
  return (ok);
}
}
#line 364 "/root/patron-new/new_3/src/enc/alpha_enc.c"
static int CompressAlphaJob(void *arg1 , void *unused ) 
{ 
  VP8Encoder *enc ;
  WebPConfig *config ;
  uint8_t *alpha_data ;
  size_t alpha_size ;
  int effort_level ;
  WEBP_FILTER_TYPE filter ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp11 ;

  {
#line 365
  enc = (VP8Encoder *)arg1;
#line 366
  config = enc->config_;
#line 367
  alpha_data = (uint8_t *)((void *)0);
#line 368
  alpha_size = (size_t )0;
#line 369
  effort_level = config->method;
#line 370
  if (config->alpha_filtering == 0) {
#line 370
    tmp___0 = 0;
  } else {
#line 370
    if (config->alpha_filtering == 1) {
#line 370
      tmp = 6;
    } else {
#line 370
      tmp = 5;
    }
#line 370
    tmp___0 = tmp;
  }
  {
#line 370
  filter = (WEBP_FILTER_TYPE )tmp___0;
#line 374
  __cil_tmp11 = EncodeAlpha(enc, config->alpha_quality, config->alpha_compression,
                            (int )filter, effort_level, & alpha_data, & alpha_size);
  }
#line 374
  if (! __cil_tmp11) {
#line 376
    return (0);
  }
#line 378
  if (alpha_size != (unsigned long )((uint32_t )alpha_size)) {
    {
#line 379
    WebPSafeFree((void *)alpha_data);
    }
#line 380
    return (0);
  }
#line 382
  enc->alpha_data_size_ = (uint32_t )alpha_size;
#line 383
  enc->alpha_data_ = alpha_data;
#line 385
  return (1);
}
}
#line 388 "/root/patron-new/new_3/src/enc/alpha_enc.c"
void VP8EncInitAlpha(VP8Encoder *enc ) 
{ 
  WebPWorker *worker ;
  WebPWorkerInterface *__cil_tmp4 ;

  {
  {
#line 389
  WebPInitAlphaProcessing();
#line 390
  enc->has_alpha_ = WebPPictureHasTransparency(enc->pic_);
#line 391
  enc->alpha_data_ = (uint8_t *)((void *)0);
#line 392
  enc->alpha_data_size_ = (uint32_t )0;
  }
#line 393
  if (enc->thread_level_ > 0) {
    {
#line 394
    worker = & enc->alpha_worker_;
#line 395
    (*(__cil_tmp4->Init))((WebPWorker */* const  */)worker);
#line 396
    worker->data1 = (void *)enc;
#line 397
    worker->data2 = (void *)0;
#line 398
    worker->hook = & CompressAlphaJob;
    }
  }
#line 401
  return;
}
}
#line 402 "/root/patron-new/new_3/src/enc/alpha_enc.c"
int VP8EncStartAlpha(VP8Encoder *enc ) 
{ 
  WebPWorker *worker ;
  WebPWorkerInterface *__cil_tmp3 ;
  int __cil_tmp4 ;
  WebPWorkerInterface *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 403
  if (enc->has_alpha_) {
#line 404
    if (enc->thread_level_ > 0) {
      {
#line 405
      worker = & enc->alpha_worker_;
#line 407
      __cil_tmp4 = (*(__cil_tmp3->Reset))((WebPWorker */* const  */)worker);
      }
#line 407
      if (! __cil_tmp4) {
#line 408
        return (0);
      }
      {
#line 410
      (*(__cil_tmp5->Launch))((WebPWorker */* const  */)worker);
      }
#line 411
      return (1);
    } else {
      {
#line 413
      __cil_tmp6 = CompressAlphaJob((void *)enc, (void *)0);
      }
#line 413
      return (__cil_tmp6);
    }
  }
#line 416
  return (1);
}
}
#line 419 "/root/patron-new/new_3/src/enc/alpha_enc.c"
int VP8EncFinishAlpha(VP8Encoder *enc ) 
{ 
  WebPWorker *worker ;
  WebPWorkerInterface *__cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 420
  if (enc->has_alpha_) {
#line 421
    if (enc->thread_level_ > 0) {
      {
#line 422
      worker = & enc->alpha_worker_;
#line 423
      __cil_tmp4 = (*(__cil_tmp3->Sync))((WebPWorker */* const  */)worker);
      }
#line 423
      if (! __cil_tmp4) {
#line 423
        return (0);
      }
    }
  }
  {
#line 426
  __cil_tmp5 = WebPReportProgress(enc->pic_, enc->percent_ + 20, & enc->percent_);
  }
#line 426
  return (__cil_tmp5);
}
}
#line 429 "/root/patron-new/new_3/src/enc/alpha_enc.c"
int VP8EncDeleteAlpha(VP8Encoder *enc ) 
{ 
  int ok ;
  WebPWorker *worker ;
  WebPWorkerInterface *__cil_tmp4 ;
  WebPWorkerInterface *__cil_tmp6 ;

  {
#line 430
  ok = 1;
#line 431
  if (enc->thread_level_ > 0) {
    {
#line 432
    worker = & enc->alpha_worker_;
#line 434
    ok = (*(__cil_tmp4->Sync))((WebPWorker */* const  */)worker);
#line 436
    (*(__cil_tmp6->End))((WebPWorker */* const  */)worker);
    }
  }
  {
#line 438
  WebPSafeFree((void *)enc->alpha_data_);
#line 439
  enc->alpha_data_ = (uint8_t *)((void *)0);
#line 440
  enc->alpha_data_size_ = (uint32_t )0;
#line 441
  enc->has_alpha_ = 0;
  }
#line 442
  return (ok);
}
}
#line 41 "/root/patron-new/new_3/src/dsp/yuv.c"
static void YuvToRgbRow(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  uint8_t *end ;

  {
#line 41
  end = dst + (len & -2) * 3;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;

#line 41
    if (! ((unsigned long )dst != (unsigned long )end)) {
#line 41
      goto while_break;
    }
    {
#line 41
    VP8YuvToRgb((int )*(y + 0), (int )*(u + 0), (int )*(v + 0), dst);
#line 41
    VP8YuvToRgb((int )*(y + 1), (int )*(u + 0), (int )*(v + 0), dst + 3);
#line 41
    y += 2;
#line 41
    u ++;
#line 41
    v ++;
#line 41
    dst += 6;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 41
  if (len & 1) {
    {
#line 41
    VP8YuvToRgb((int )*(y + 0), (int )*(u + 0), (int )*(v + 0), dst);
    }
  }
#line 44
  return;
}
}
#line 42 "/root/patron-new/new_3/src/dsp/yuv.c"
static void YuvToBgrRow(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  uint8_t *end ;

  {
#line 42
  end = dst + (len & -2) * 3;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;

#line 42
    if (! ((unsigned long )dst != (unsigned long )end)) {
#line 42
      goto while_break;
    }
    {
#line 42
    VP8YuvToBgr((int )*(y + 0), (int )*(u + 0), (int )*(v + 0), dst);
#line 42
    VP8YuvToBgr((int )*(y + 1), (int )*(u + 0), (int )*(v + 0), dst + 3);
#line 42
    y += 2;
#line 42
    u ++;
#line 42
    v ++;
#line 42
    dst += 6;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 42
  if (len & 1) {
    {
#line 42
    VP8YuvToBgr((int )*(y + 0), (int )*(u + 0), (int )*(v + 0), dst);
    }
  }
#line 45
  return;
}
}
#line 43 "/root/patron-new/new_3/src/dsp/yuv.c"
static void YuvToRgbaRow(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  uint8_t *end ;

  {
#line 43
  end = dst + (len & -2) * 4;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;

#line 43
    if (! ((unsigned long )dst != (unsigned long )end)) {
#line 43
      goto while_break;
    }
    {
#line 43
    VP8YuvToRgba(*(y + 0), *(u + 0), *(v + 0), dst);
#line 43
    VP8YuvToRgba(*(y + 1), *(u + 0), *(v + 0), dst + 4);
#line 43
    y += 2;
#line 43
    u ++;
#line 43
    v ++;
#line 43
    dst += 8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 43
  if (len & 1) {
    {
#line 43
    VP8YuvToRgba(*(y + 0), *(u + 0), *(v + 0), dst);
    }
  }
#line 46
  return;
}
}
#line 44 "/root/patron-new/new_3/src/dsp/yuv.c"
static void YuvToBgraRow(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  uint8_t *end ;

  {
#line 44
  end = dst + (len & -2) * 4;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;

#line 44
    if (! ((unsigned long )dst != (unsigned long )end)) {
#line 44
      goto while_break;
    }
    {
#line 44
    VP8YuvToBgra(*(y + 0), *(u + 0), *(v + 0), dst);
#line 44
    VP8YuvToBgra(*(y + 1), *(u + 0), *(v + 0), dst + 4);
#line 44
    y += 2;
#line 44
    u ++;
#line 44
    v ++;
#line 44
    dst += 8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 44
  if (len & 1) {
    {
#line 44
    VP8YuvToBgra(*(y + 0), *(u + 0), *(v + 0), dst);
    }
  }
#line 47
  return;
}
}
#line 45 "/root/patron-new/new_3/src/dsp/yuv.c"
static void YuvToArgbRow(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  uint8_t *end ;

  {
#line 45
  end = dst + (len & -2) * 4;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;

#line 45
    if (! ((unsigned long )dst != (unsigned long )end)) {
#line 45
      goto while_break;
    }
    {
#line 45
    VP8YuvToArgb(*(y + 0), *(u + 0), *(v + 0), dst);
#line 45
    VP8YuvToArgb(*(y + 1), *(u + 0), *(v + 0), dst + 4);
#line 45
    y += 2;
#line 45
    u ++;
#line 45
    v ++;
#line 45
    dst += 8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 45
  if (len & 1) {
    {
#line 45
    VP8YuvToArgb(*(y + 0), *(u + 0), *(v + 0), dst);
    }
  }
#line 48
  return;
}
}
#line 46 "/root/patron-new/new_3/src/dsp/yuv.c"
static void YuvToRgba4444Row(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst ,
                             int len ) 
{ 
  uint8_t *end ;

  {
#line 46
  end = dst + (len & -2) * 2;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;

#line 46
    if (! ((unsigned long )dst != (unsigned long )end)) {
#line 46
      goto while_break;
    }
    {
#line 46
    VP8YuvToRgba4444((int )*(y + 0), (int )*(u + 0), (int )*(v + 0), dst);
#line 46
    VP8YuvToRgba4444((int )*(y + 1), (int )*(u + 0), (int )*(v + 0), dst + 2);
#line 46
    y += 2;
#line 46
    u ++;
#line 46
    v ++;
#line 46
    dst += 4;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 46
  if (len & 1) {
    {
#line 46
    VP8YuvToRgba4444((int )*(y + 0), (int )*(u + 0), (int )*(v + 0), dst);
    }
  }
#line 49
  return;
}
}
#line 47 "/root/patron-new/new_3/src/dsp/yuv.c"
static void YuvToRgb565Row(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  uint8_t *end ;

  {
#line 47
  end = dst + (len & -2) * 2;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;

#line 47
    if (! ((unsigned long )dst != (unsigned long )end)) {
#line 47
      goto while_break;
    }
    {
#line 47
    VP8YuvToRgb565((int )*(y + 0), (int )*(u + 0), (int )*(v + 0), dst);
#line 47
    VP8YuvToRgb565((int )*(y + 1), (int )*(u + 0), (int )*(v + 0), dst + 2);
#line 47
    y += 2;
#line 47
    u ++;
#line 47
    v ++;
#line 47
    dst += 4;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 47
  if (len & 1) {
    {
#line 47
    VP8YuvToRgb565((int )*(y + 0), (int )*(u + 0), (int )*(v + 0), dst);
    }
  }
#line 50
  return;
}
}
#line 52 "/root/patron-new/new_3/src/dsp/yuv.c"
void WebPSamplerProcessPlane(uint8_t *y , int y_stride , uint8_t *u , uint8_t *v ,
                             int uv_stride , uint8_t *dst , int dst_stride , int width ,
                             int height , void (*func)(uint8_t * , uint8_t * , uint8_t * ,
                                                       uint8_t * , int  ) ) 
{ 
  int j ;

  {
#line 57
  j = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;

#line 57
    if (! (j < height)) {
#line 57
      goto while_break;
    }
    {
#line 58
    (*func)(y, u, v, dst, width);
#line 59
    y += y_stride;
    }
#line 60
    if (j & 1) {
#line 61
      u += uv_stride;
#line 62
      v += uv_stride;
    }
#line 64
    dst += dst_stride;
#line 57
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 61
  return;
}
}
#line 73
extern void WebPInitSamplersSSE2(void) ;
#line 74
extern void WebPInitSamplersSSE41(void) ;
#line 78
static void WebPInitSamplers_body(void) ;
#line 80 "/root/patron-new/new_3/src/dsp/yuv.c"
static int (*WebPInitSamplers_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 81 "/root/patron-new/new_3/src/dsp/yuv.c"
static pthread_mutex_t WebPInitSamplers_body_lock  ;
#line 78 "/root/patron-new/new_3/src/dsp/yuv.c"
void WebPInitSamplers(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    WebPInitSamplers_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& WebPInitSamplers_body_last_cpuinfo_used);
#line 78
    WebPInitSamplers_body_lock.__data.__lock = 0;
#line 78
    WebPInitSamplers_body_lock.__data.__count = 0U;
#line 78
    WebPInitSamplers_body_lock.__data.__owner = 0;
#line 78
    WebPInitSamplers_body_lock.__data.__nusers = 0U;
#line 78
    WebPInitSamplers_body_lock.__data.__kind = 0;
#line 78
    WebPInitSamplers_body_lock.__data.__spins = (short)0;
#line 78
    WebPInitSamplers_body_lock.__data.__elision = (short)0;
#line 78
    WebPInitSamplers_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 78
    WebPInitSamplers_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 78
    __cil_tmp3 = pthread_mutex_lock(& WebPInitSamplers_body_lock);
    }
#line 78
    if (__cil_tmp3) {
#line 78
      goto while_break;
    }
#line 78
    if ((unsigned long )WebPInitSamplers_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 78
      WebPInitSamplers_body();
      }
    }
    {
#line 78
    WebPInitSamplers_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 78
    pthread_mutex_unlock(& WebPInitSamplers_body_lock);
    }
#line 78
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 82
  return;
}
}
#line 78 "/root/patron-new/new_3/src/dsp/yuv.c"
static void WebPInitSamplers_body(void) 
{ 
  int __cil_tmp1 ;
  int __cil_tmp2 ;

  {
#line 79
  WebPSamplers[0] = & YuvToRgbRow;
#line 80
  WebPSamplers[1] = & YuvToRgbaRow;
#line 81
  WebPSamplers[2] = & YuvToBgrRow;
#line 82
  WebPSamplers[3] = & YuvToBgraRow;
#line 83
  WebPSamplers[4] = & YuvToArgbRow;
#line 84
  WebPSamplers[5] = & YuvToRgba4444Row;
#line 85
  WebPSamplers[6] = & YuvToRgb565Row;
#line 86
  WebPSamplers[7] = & YuvToRgbaRow;
#line 87
  WebPSamplers[8] = & YuvToBgraRow;
#line 88
  WebPSamplers[9] = & YuvToArgbRow;
#line 89
  WebPSamplers[10] = & YuvToRgba4444Row;
#line 92
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
    {
#line 94
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 94
    if (__cil_tmp1) {
      {
#line 95
      WebPInitSamplersSSE2();
      }
    }
    {
#line 99
    __cil_tmp2 = (*VP8GetCPUInfo)((CPUFeature )3);
    }
#line 99
    if (__cil_tmp2) {
      {
#line 100
      WebPInitSamplersSSE41();
      }
    }
  }
#line 104
  return;
}
}
#line 119 "/root/patron-new/new_3/src/dsp/yuv.c"
static void ConvertARGBToY_C(uint32_t *argb , uint8_t *y , int width ) 
{ 
  int i ;
  uint32_t p ;
  int __cil_tmp6 ;

  {
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;

#line 121
    if (! (i < width)) {
#line 121
      goto while_break;
    }
    {
#line 122
    p = *(argb + i);
#line 123
    __cil_tmp6 = VP8RGBToY((int )((p >> 16) & 255U), (int )((p >> 8) & 255U), (int )(p & 255U),
                           32768);
#line 123
    *(y + i) = (uint8_t )__cil_tmp6;
#line 121
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 125
  return;
}
}
#line 128 "/root/patron-new/new_3/src/dsp/yuv.c"
void WebPConvertARGBToUV_C(uint32_t *argb , uint8_t *u , uint8_t *v , int src_width ,
                           int do_store ) 
{ 
  int uv_width ;
  int i ;
  uint32_t v0 ;
  uint32_t v1 ;
  int r ;
  int g ;
  int b ;
  int tmp_u ;
  int __cil_tmp14 ;
  int tmp_v ;
  int __cil_tmp16 ;
  uint32_t v0___0 ;
  int r___0 ;
  int g___0 ;
  int b___0 ;
  int tmp_u___0 ;
  int __cil_tmp22 ;
  int tmp_v___0 ;
  int __cil_tmp24 ;

  {
#line 131
  uv_width = src_width >> 1;
#line 133
  i = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;

#line 133
    if (! (i < uv_width)) {
#line 133
      goto while_break;
    }
    {
#line 134
    v0 = *(argb + 2 * i);
#line 135
    v1 = *(argb + (2 * i + 1));
#line 138
    r = (int )(((v0 >> 15) & 510U) + ((v1 >> 15) & 510U));
#line 139
    g = (int )(((v0 >> 7) & 510U) + ((v1 >> 7) & 510U));
#line 140
    b = (int )(((v0 << 1) & 510U) + ((v1 << 1) & 510U));
#line 141
    __cil_tmp14 = VP8RGBToU(r, g, b, 32768 << 2);
#line 141
    tmp_u = __cil_tmp14;
#line 142
    __cil_tmp16 = VP8RGBToV(r, g, b, 32768 << 2);
#line 142
    tmp_v = __cil_tmp16;
    }
#line 143
    if (do_store) {
#line 144
      *(u + i) = (uint8_t )tmp_u;
#line 145
      *(v + i) = (uint8_t )tmp_v;
    } else {
#line 148
      *(u + i) = (uint8_t )((((int )*(u + i) + tmp_u) + 1) >> 1);
#line 149
      *(v + i) = (uint8_t )((((int )*(v + i) + tmp_v) + 1) >> 1);
    }
#line 133
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 152
  if (src_width & 1) {
    {
#line 153
    v0___0 = *(argb + 2 * i);
#line 154
    r___0 = (int )((v0___0 >> 14) & 1020U);
#line 155
    g___0 = (int )((v0___0 >> 6) & 1020U);
#line 156
    b___0 = (int )((v0___0 << 2) & 1020U);
#line 157
    __cil_tmp22 = VP8RGBToU(r___0, g___0, b___0, 32768 << 2);
#line 157
    tmp_u___0 = __cil_tmp22;
#line 158
    __cil_tmp24 = VP8RGBToV(r___0, g___0, b___0, 32768 << 2);
#line 158
    tmp_v___0 = __cil_tmp24;
    }
#line 159
    if (do_store) {
#line 160
      *(u + i) = (uint8_t )tmp_u___0;
#line 161
      *(v + i) = (uint8_t )tmp_v___0;
    } else {
#line 163
      *(u + i) = (uint8_t )((((int )*(u + i) + tmp_u___0) + 1) >> 1);
#line 164
      *(v + i) = (uint8_t )((((int )*(v + i) + tmp_v___0) + 1) >> 1);
    }
  }
#line 167
  return;
}
}
#line 171 "/root/patron-new/new_3/src/dsp/yuv.c"
static void ConvertRGB24ToY_C(uint8_t *rgb , uint8_t *y , int width ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 173
  i = 0;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;

#line 173
    if (! (i < width)) {
#line 173
      goto while_break;
    }
    {
#line 174
    __cil_tmp5 = VP8RGBToY((int )*(rgb + 0), (int )*(rgb + 1), (int )*(rgb + 2), 32768);
#line 174
    *(y + i) = (uint8_t )__cil_tmp5;
#line 173
    rgb += 3;
#line 173
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 177
  return;
}
}
#line 178 "/root/patron-new/new_3/src/dsp/yuv.c"
static void ConvertBGR24ToY_C(uint8_t *bgr , uint8_t *y , int width ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 180
  i = 0;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;

#line 180
    if (! (i < width)) {
#line 180
      goto while_break;
    }
    {
#line 181
    __cil_tmp5 = VP8RGBToY((int )*(bgr + 2), (int )*(bgr + 1), (int )*(bgr + 0), 32768);
#line 181
    *(y + i) = (uint8_t )__cil_tmp5;
#line 180
    bgr += 3;
#line 180
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 184
  return;
}
}
#line 185 "/root/patron-new/new_3/src/dsp/yuv.c"
void WebPConvertRGBA32ToUV_C(uint16_t *rgb , uint8_t *u , uint8_t *v , int width ) 
{ 
  int i ;
  int r ;
  int g ;
  int b ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 188
  i = 0;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;

#line 188
    if (! (i < width)) {
#line 188
      goto while_break;
    }
    {
#line 189
    r = (int )*(rgb + 0);
#line 189
    g = (int )*(rgb + 1);
#line 189
    b = (int )*(rgb + 2);
#line 190
    __cil_tmp9 = VP8RGBToU(r, g, b, 32768 << 2);
#line 190
    *(u + i) = (uint8_t )__cil_tmp9;
#line 191
    __cil_tmp10 = VP8RGBToV(r, g, b, 32768 << 2);
#line 191
    *(v + i) = (uint8_t )__cil_tmp10;
#line 188
    rgb += 4;
#line 188
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 192
  return;
}
}
#line 199 "/root/patron-new/new_3/src/dsp/yuv.c"
static uint16_t clip_y___0(int v ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 200
  if (v < 0) {
#line 200
    tmp___0 = 0;
  } else {
#line 200
    if (v > (1 << 10) - 1) {
#line 200
      tmp = (1 << 10) - 1;
    } else {
#line 200
      tmp = (int )((uint16_t )v);
    }
#line 200
    tmp___0 = tmp;
  }
#line 200
  return ((uint16_t )tmp___0);
}
}
#line 203 "/root/patron-new/new_3/src/dsp/yuv.c"
static uint64_t SharpYUVUpdateY_C(uint16_t *ref , uint16_t *src , uint16_t *dst ,
                                  int len ) 
{ 
  uint64_t diff ;
  int i ;
  int diff_y ;
  int new_y ;
  int __cil_tmp10 ;

  {
#line 205
  diff = (uint64_t )0;
#line 207
  i = 0;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;

#line 207
    if (! (i < len)) {
#line 207
      goto while_break;
    }
    {
#line 208
    diff_y = (int )*(ref + i) - (int )*(src + i);
#line 209
    new_y = (int )*(dst + i) + diff_y;
#line 210
    *(dst + i) = clip_y___0(new_y);
#line 211
    __cil_tmp10 = abs(diff_y);
#line 211
    diff += (uint64_t )__cil_tmp10;
#line 207
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 213
  return (diff);
}
}
#line 216 "/root/patron-new/new_3/src/dsp/yuv.c"
static void SharpYUVUpdateRGB_C(int16_t *ref , int16_t *src , int16_t *dst , int len ) 
{ 
  int i ;
  int diff_uv ;

  {
#line 219
  i = 0;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;

#line 219
    if (! (i < len)) {
#line 219
      goto while_break;
    }
#line 220
    diff_uv = (int )*(ref + i) - (int )*(src + i);
#line 221
    *(dst + i) = (int16_t )((int )*(dst + i) + diff_uv);
#line 219
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 223
  return;
}
}
#line 225 "/root/patron-new/new_3/src/dsp/yuv.c"
static void SharpYUVFilterRow_C(int16_t *A , int16_t *B , int len , uint16_t *best_y ,
                                uint16_t *out ) 
{ 
  int i ;
  int v0 ;
  int v1 ;

  {
#line 228
  i = 0;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;

#line 228
    if (! (i < len)) {
#line 228
      goto while_break;
    }
    {
#line 229
    v0 = (((((int )*(A + 0) * 9 + (int )*(A + 1) * 3) + (int )*(B + 0) * 3) + (int )*(B + 1)) + 8) >> 4;
#line 230
    v1 = (((((int )*(A + 1) * 9 + (int )*(A + 0) * 3) + (int )*(B + 1) * 3) + (int )*(B + 0)) + 8) >> 4;
#line 231
    *(out + 2 * i) = clip_y___0((int )*(best_y + 2 * i) + v0);
#line 232
    *(out + (2 * i + 1)) = clip_y___0((int )*(best_y + (2 * i + 1)) + v1);
#line 228
    B ++;
#line 228
    A ++;
#line 228
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 232
  return;
}
}
#line 257
extern void WebPInitConvertARGBToYUVSSE2(void) ;
#line 258
extern void WebPInitConvertARGBToYUVSSE41(void) ;
#line 260
extern void WebPInitSharpYUVSSE2(void) ;
#line 263
static void WebPInitConvertARGBToYUV_body(void) ;
#line 265 "/root/patron-new/new_3/src/dsp/yuv.c"
static int (*WebPInitConvertARGBToYUV_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 266 "/root/patron-new/new_3/src/dsp/yuv.c"
static pthread_mutex_t WebPInitConvertARGBToYUV_body_lock  ;
#line 263 "/root/patron-new/new_3/src/dsp/yuv.c"
void WebPInitConvertARGBToYUV(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 263
    WebPInitConvertARGBToYUV_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& WebPInitConvertARGBToYUV_body_last_cpuinfo_used);
#line 263
    WebPInitConvertARGBToYUV_body_lock.__data.__lock = 0;
#line 263
    WebPInitConvertARGBToYUV_body_lock.__data.__count = 0U;
#line 263
    WebPInitConvertARGBToYUV_body_lock.__data.__owner = 0;
#line 263
    WebPInitConvertARGBToYUV_body_lock.__data.__nusers = 0U;
#line 263
    WebPInitConvertARGBToYUV_body_lock.__data.__kind = 0;
#line 263
    WebPInitConvertARGBToYUV_body_lock.__data.__spins = (short)0;
#line 263
    WebPInitConvertARGBToYUV_body_lock.__data.__elision = (short)0;
#line 263
    WebPInitConvertARGBToYUV_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 263
    WebPInitConvertARGBToYUV_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 263
    __cil_tmp3 = pthread_mutex_lock(& WebPInitConvertARGBToYUV_body_lock);
    }
#line 263
    if (__cil_tmp3) {
#line 263
      goto while_break;
    }
#line 263
    if ((unsigned long )WebPInitConvertARGBToYUV_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 263
      WebPInitConvertARGBToYUV_body();
      }
    }
    {
#line 263
    WebPInitConvertARGBToYUV_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 263
    pthread_mutex_unlock(& WebPInitConvertARGBToYUV_body_lock);
    }
#line 263
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 267
  return;
}
}
#line 263 "/root/patron-new/new_3/src/dsp/yuv.c"
static void WebPInitConvertARGBToYUV_body(void) 
{ 
  int __cil_tmp1 ;
  int __cil_tmp2 ;

  {
#line 264
  WebPConvertARGBToY = & ConvertARGBToY_C;
#line 265
  WebPConvertARGBToUV = & WebPConvertARGBToUV_C;
#line 267
  WebPConvertRGB24ToY = & ConvertRGB24ToY_C;
#line 268
  WebPConvertBGR24ToY = & ConvertBGR24ToY_C;
#line 270
  WebPConvertRGBA32ToUV = & WebPConvertRGBA32ToUV_C;
#line 273
  WebPSharpYUVUpdateY = & SharpYUVUpdateY_C;
#line 274
  WebPSharpYUVUpdateRGB = & SharpYUVUpdateRGB_C;
#line 275
  WebPSharpYUVFilterRow = & SharpYUVFilterRow_C;
#line 278
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
    {
#line 280
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 280
    if (__cil_tmp1) {
      {
#line 281
      WebPInitConvertARGBToYUVSSE2();
#line 282
      WebPInitSharpYUVSSE2();
      }
    }
    {
#line 286
    __cil_tmp2 = (*VP8GetCPUInfo)((CPUFeature )3);
    }
#line 286
    if (__cil_tmp2) {
      {
#line 287
      WebPInitConvertARGBToYUVSSE41();
      }
    }
  }
#line 291
  return;
}
}
#line 97 "/root/patron-new/new_3/src/dsp/upsampling.c"
static void UpsampleRgbaLinePair_C(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                   uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                   uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
  {
#line 97
  last_pixel_pair = (len - 1) >> 1;
#line 97
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 97
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 97
  uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 97
  VP8YuvToRgba(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16), top_dst);
  }
#line 97
  if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
    {
#line 97
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 97
    VP8YuvToRgba(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                 bottom_dst);
    }
  }
#line 97
  x = 1;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;

#line 97
    if (! (x <= last_pixel_pair)) {
#line 97
      goto while_break;
    }
    {
#line 97
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 97
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 97
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 97
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 97
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 97
    uv0___1 = (diag_12 + tl_uv) >> 1;
#line 97
    uv1 = (diag_03 + t_uv) >> 1;
#line 97
    VP8YuvToRgba(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                 top_dst + (2 * x - 1) * 4);
#line 97
    VP8YuvToRgba(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                 top_dst + (2 * x) * 4);
    }
#line 97
    if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
      {
#line 97
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 97
      uv1___0 = (diag_12 + uv) >> 1;
#line 97
      VP8YuvToRgba(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                   bottom_dst + (2 * x - 1) * 4);
#line 97
      VP8YuvToRgba(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                   bottom_dst + (2 * x) * 4);
      }
    }
#line 97
    tl_uv = t_uv;
#line 97
    l_uv = uv;
#line 97
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 97
  if (! (len & 1)) {
    {
#line 97
    uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 97
    VP8YuvToRgba(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                 top_dst + (len - 1) * 4);
    }
#line 97
    if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
      {
#line 97
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 97
      VP8YuvToRgba(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                   bottom_dst + (len - 1) * 4);
      }
    }
  }
#line 102
  return;
}
}
#line 98 "/root/patron-new/new_3/src/dsp/upsampling.c"
static void UpsampleBgraLinePair_C(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                   uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                   uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
  {
#line 98
  last_pixel_pair = (len - 1) >> 1;
#line 98
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 98
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 98
  uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 98
  VP8YuvToBgra(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16), top_dst);
  }
#line 98
  if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
    {
#line 98
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 98
    VP8YuvToBgra(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                 bottom_dst);
    }
  }
#line 98
  x = 1;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;

#line 98
    if (! (x <= last_pixel_pair)) {
#line 98
      goto while_break;
    }
    {
#line 98
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 98
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 98
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 98
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 98
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 98
    uv0___1 = (diag_12 + tl_uv) >> 1;
#line 98
    uv1 = (diag_03 + t_uv) >> 1;
#line 98
    VP8YuvToBgra(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                 top_dst + (2 * x - 1) * 4);
#line 98
    VP8YuvToBgra(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                 top_dst + (2 * x) * 4);
    }
#line 98
    if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
      {
#line 98
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 98
      uv1___0 = (diag_12 + uv) >> 1;
#line 98
      VP8YuvToBgra(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                   bottom_dst + (2 * x - 1) * 4);
#line 98
      VP8YuvToBgra(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                   bottom_dst + (2 * x) * 4);
      }
    }
#line 98
    tl_uv = t_uv;
#line 98
    l_uv = uv;
#line 98
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 98
  if (! (len & 1)) {
    {
#line 98
    uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 98
    VP8YuvToBgra(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                 top_dst + (len - 1) * 4);
    }
#line 98
    if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
      {
#line 98
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 98
      VP8YuvToBgra(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                   bottom_dst + (len - 1) * 4);
      }
    }
  }
#line 103
  return;
}
}
#line 100 "/root/patron-new/new_3/src/dsp/upsampling.c"
static void UpsampleArgbLinePair_C(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                   uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                   uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
  {
#line 100
  last_pixel_pair = (len - 1) >> 1;
#line 100
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 100
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 100
  uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 100
  VP8YuvToArgb(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16), top_dst);
  }
#line 100
  if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
    {
#line 100
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 100
    VP8YuvToArgb(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                 bottom_dst);
    }
  }
#line 100
  x = 1;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;

#line 100
    if (! (x <= last_pixel_pair)) {
#line 100
      goto while_break;
    }
    {
#line 100
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 100
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 100
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 100
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 100
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 100
    uv0___1 = (diag_12 + tl_uv) >> 1;
#line 100
    uv1 = (diag_03 + t_uv) >> 1;
#line 100
    VP8YuvToArgb(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                 top_dst + (2 * x - 1) * 4);
#line 100
    VP8YuvToArgb(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                 top_dst + (2 * x) * 4);
    }
#line 100
    if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
      {
#line 100
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 100
      uv1___0 = (diag_12 + uv) >> 1;
#line 100
      VP8YuvToArgb(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                   bottom_dst + (2 * x - 1) * 4);
#line 100
      VP8YuvToArgb(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                   bottom_dst + (2 * x) * 4);
      }
    }
#line 100
    tl_uv = t_uv;
#line 100
    l_uv = uv;
#line 100
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 100
  if (! (len & 1)) {
    {
#line 100
    uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 100
    VP8YuvToArgb(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                 top_dst + (len - 1) * 4);
    }
#line 100
    if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
      {
#line 100
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 100
      VP8YuvToArgb(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                   bottom_dst + (len - 1) * 4);
      }
    }
  }
#line 105
  return;
}
}
#line 101 "/root/patron-new/new_3/src/dsp/upsampling.c"
static void UpsampleRgbLinePair_C(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                  uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                  uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
  {
#line 101
  last_pixel_pair = (len - 1) >> 1;
#line 101
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 101
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 101
  uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 101
  VP8YuvToRgb((int )*(top_y + 0), (int )(uv0 & 255U), (int )(uv0 >> 16), top_dst);
  }
#line 101
  if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
    {
#line 101
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 101
    VP8YuvToRgb((int )*(bottom_y + 0), (int )(uv0___0 & 255U), (int )(uv0___0 >> 16),
                bottom_dst);
    }
  }
#line 101
  x = 1;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;

#line 101
    if (! (x <= last_pixel_pair)) {
#line 101
      goto while_break;
    }
    {
#line 101
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 101
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 101
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 101
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 101
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 101
    uv0___1 = (diag_12 + tl_uv) >> 1;
#line 101
    uv1 = (diag_03 + t_uv) >> 1;
#line 101
    VP8YuvToRgb((int )*(top_y + (2 * x - 1)), (int )(uv0___1 & 255U), (int )(uv0___1 >> 16),
                top_dst + (2 * x - 1) * 3);
#line 101
    VP8YuvToRgb((int )*(top_y + 2 * x), (int )(uv1 & 255U), (int )(uv1 >> 16), top_dst + (2 * x) * 3);
    }
#line 101
    if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
      {
#line 101
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 101
      uv1___0 = (diag_12 + uv) >> 1;
#line 101
      VP8YuvToRgb((int )*(bottom_y + (2 * x - 1)), (int )(uv0___2 & 255U), (int )(uv0___2 >> 16),
                  bottom_dst + (2 * x - 1) * 3);
#line 101
      VP8YuvToRgb((int )*(bottom_y + 2 * x), (int )(uv1___0 & 255U), (int )(uv1___0 >> 16),
                  bottom_dst + (2 * x) * 3);
      }
    }
#line 101
    tl_uv = t_uv;
#line 101
    l_uv = uv;
#line 101
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 101
  if (! (len & 1)) {
    {
#line 101
    uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 101
    VP8YuvToRgb((int )*(top_y + (len - 1)), (int )(uv0___3 & 255U), (int )(uv0___3 >> 16),
                top_dst + (len - 1) * 3);
    }
#line 101
    if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
      {
#line 101
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 101
      VP8YuvToRgb((int )*(bottom_y + (len - 1)), (int )(uv0___4 & 255U), (int )(uv0___4 >> 16),
                  bottom_dst + (len - 1) * 3);
      }
    }
  }
#line 106
  return;
}
}
#line 102 "/root/patron-new/new_3/src/dsp/upsampling.c"
static void UpsampleBgrLinePair_C(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                  uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                  uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
  {
#line 102
  last_pixel_pair = (len - 1) >> 1;
#line 102
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 102
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 102
  uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 102
  VP8YuvToBgr((int )*(top_y + 0), (int )(uv0 & 255U), (int )(uv0 >> 16), top_dst);
  }
#line 102
  if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
    {
#line 102
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 102
    VP8YuvToBgr((int )*(bottom_y + 0), (int )(uv0___0 & 255U), (int )(uv0___0 >> 16),
                bottom_dst);
    }
  }
#line 102
  x = 1;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;

#line 102
    if (! (x <= last_pixel_pair)) {
#line 102
      goto while_break;
    }
    {
#line 102
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 102
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 102
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 102
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 102
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 102
    uv0___1 = (diag_12 + tl_uv) >> 1;
#line 102
    uv1 = (diag_03 + t_uv) >> 1;
#line 102
    VP8YuvToBgr((int )*(top_y + (2 * x - 1)), (int )(uv0___1 & 255U), (int )(uv0___1 >> 16),
                top_dst + (2 * x - 1) * 3);
#line 102
    VP8YuvToBgr((int )*(top_y + 2 * x), (int )(uv1 & 255U), (int )(uv1 >> 16), top_dst + (2 * x) * 3);
    }
#line 102
    if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
      {
#line 102
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 102
      uv1___0 = (diag_12 + uv) >> 1;
#line 102
      VP8YuvToBgr((int )*(bottom_y + (2 * x - 1)), (int )(uv0___2 & 255U), (int )(uv0___2 >> 16),
                  bottom_dst + (2 * x - 1) * 3);
#line 102
      VP8YuvToBgr((int )*(bottom_y + 2 * x), (int )(uv1___0 & 255U), (int )(uv1___0 >> 16),
                  bottom_dst + (2 * x) * 3);
      }
    }
#line 102
    tl_uv = t_uv;
#line 102
    l_uv = uv;
#line 102
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 102
  if (! (len & 1)) {
    {
#line 102
    uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 102
    VP8YuvToBgr((int )*(top_y + (len - 1)), (int )(uv0___3 & 255U), (int )(uv0___3 >> 16),
                top_dst + (len - 1) * 3);
    }
#line 102
    if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
      {
#line 102
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 102
      VP8YuvToBgr((int )*(bottom_y + (len - 1)), (int )(uv0___4 & 255U), (int )(uv0___4 >> 16),
                  bottom_dst + (len - 1) * 3);
      }
    }
  }
#line 107
  return;
}
}
#line 103 "/root/patron-new/new_3/src/dsp/upsampling.c"
static void UpsampleRgba4444LinePair_C(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                       uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                       uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
  {
#line 103
  last_pixel_pair = (len - 1) >> 1;
#line 103
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 103
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 103
  uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 103
  VP8YuvToRgba4444((int )*(top_y + 0), (int )(uv0 & 255U), (int )(uv0 >> 16), top_dst);
  }
#line 103
  if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
    {
#line 103
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 103
    VP8YuvToRgba4444((int )*(bottom_y + 0), (int )(uv0___0 & 255U), (int )(uv0___0 >> 16),
                     bottom_dst);
    }
  }
#line 103
  x = 1;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;

#line 103
    if (! (x <= last_pixel_pair)) {
#line 103
      goto while_break;
    }
    {
#line 103
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 103
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 103
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 103
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 103
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 103
    uv0___1 = (diag_12 + tl_uv) >> 1;
#line 103
    uv1 = (diag_03 + t_uv) >> 1;
#line 103
    VP8YuvToRgba4444((int )*(top_y + (2 * x - 1)), (int )(uv0___1 & 255U), (int )(uv0___1 >> 16),
                     top_dst + (2 * x - 1) * 2);
#line 103
    VP8YuvToRgba4444((int )*(top_y + 2 * x), (int )(uv1 & 255U), (int )(uv1 >> 16),
                     top_dst + (2 * x) * 2);
    }
#line 103
    if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
      {
#line 103
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 103
      uv1___0 = (diag_12 + uv) >> 1;
#line 103
      VP8YuvToRgba4444((int )*(bottom_y + (2 * x - 1)), (int )(uv0___2 & 255U), (int )(uv0___2 >> 16),
                       bottom_dst + (2 * x - 1) * 2);
#line 103
      VP8YuvToRgba4444((int )*(bottom_y + 2 * x), (int )(uv1___0 & 255U), (int )(uv1___0 >> 16),
                       bottom_dst + (2 * x) * 2);
      }
    }
#line 103
    tl_uv = t_uv;
#line 103
    l_uv = uv;
#line 103
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 103
  if (! (len & 1)) {
    {
#line 103
    uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 103
    VP8YuvToRgba4444((int )*(top_y + (len - 1)), (int )(uv0___3 & 255U), (int )(uv0___3 >> 16),
                     top_dst + (len - 1) * 2);
    }
#line 103
    if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
      {
#line 103
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 103
      VP8YuvToRgba4444((int )*(bottom_y + (len - 1)), (int )(uv0___4 & 255U), (int )(uv0___4 >> 16),
                       bottom_dst + (len - 1) * 2);
      }
    }
  }
#line 108
  return;
}
}
#line 104 "/root/patron-new/new_3/src/dsp/upsampling.c"
static void UpsampleRgb565LinePair_C(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                     uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                     uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
  {
#line 104
  last_pixel_pair = (len - 1) >> 1;
#line 104
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 104
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 104
  uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 104
  VP8YuvToRgb565((int )*(top_y + 0), (int )(uv0 & 255U), (int )(uv0 >> 16), top_dst);
  }
#line 104
  if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
    {
#line 104
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 104
    VP8YuvToRgb565((int )*(bottom_y + 0), (int )(uv0___0 & 255U), (int )(uv0___0 >> 16),
                   bottom_dst);
    }
  }
#line 104
  x = 1;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;

#line 104
    if (! (x <= last_pixel_pair)) {
#line 104
      goto while_break;
    }
    {
#line 104
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 104
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 104
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 104
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 104
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 104
    uv0___1 = (diag_12 + tl_uv) >> 1;
#line 104
    uv1 = (diag_03 + t_uv) >> 1;
#line 104
    VP8YuvToRgb565((int )*(top_y + (2 * x - 1)), (int )(uv0___1 & 255U), (int )(uv0___1 >> 16),
                   top_dst + (2 * x - 1) * 2);
#line 104
    VP8YuvToRgb565((int )*(top_y + 2 * x), (int )(uv1 & 255U), (int )(uv1 >> 16),
                   top_dst + (2 * x) * 2);
    }
#line 104
    if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
      {
#line 104
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 104
      uv1___0 = (diag_12 + uv) >> 1;
#line 104
      VP8YuvToRgb565((int )*(bottom_y + (2 * x - 1)), (int )(uv0___2 & 255U), (int )(uv0___2 >> 16),
                     bottom_dst + (2 * x - 1) * 2);
#line 104
      VP8YuvToRgb565((int )*(bottom_y + 2 * x), (int )(uv1___0 & 255U), (int )(uv1___0 >> 16),
                     bottom_dst + (2 * x) * 2);
      }
    }
#line 104
    tl_uv = t_uv;
#line 104
    l_uv = uv;
#line 104
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 104
  if (! (len & 1)) {
    {
#line 104
    uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 104
    VP8YuvToRgb565((int )*(top_y + (len - 1)), (int )(uv0___3 & 255U), (int )(uv0___3 >> 16),
                   top_dst + (len - 1) * 2);
    }
#line 104
    if ((unsigned long )bottom_y != (unsigned long )((void *)0)) {
      {
#line 104
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 104
      VP8YuvToRgb565((int )*(bottom_y + (len - 1)), (int )(uv0___4 & 255U), (int )(uv0___4 >> 16),
                     bottom_dst + (len - 1) * 2);
      }
    }
  }
#line 109
  return;
}
}
#line 168 "/root/patron-new/new_3/src/dsp/upsampling.c"
WebPUpsampleLinePairFunc WebPGetLinePairConverter(int alpha_is_last ) 
{ 
  int tmp ;

  {
  {
#line 169
  WebPInitUpsamplers();
  }
#line 171
  if (alpha_is_last) {
#line 171
    tmp = 3;
  } else {
#line 171
    tmp = 4;
  }
#line 171
  return (WebPUpsamplers[tmp]);
}
}
#line 189
void WebPYuv444ToRgba_C(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) ;
#line 189 "/root/patron-new/new_3/src/dsp/upsampling.c"
void WebPYuv444ToRgba_C(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 189
  i = 0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;

#line 189
    if (! (i < len)) {
#line 189
      goto while_break;
    }
    {
#line 189
    VP8YuvToRgba(*(y + i), *(u + i), *(v + i), dst + i * 4);
#line 189
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 193
  return;
}
}
#line 190
void WebPYuv444ToBgra_C(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) ;
#line 190 "/root/patron-new/new_3/src/dsp/upsampling.c"
void WebPYuv444ToBgra_C(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 190
  i = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;

#line 190
    if (! (i < len)) {
#line 190
      goto while_break;
    }
    {
#line 190
    VP8YuvToBgra(*(y + i), *(u + i), *(v + i), dst + i * 4);
#line 190
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 194
  return;
}
}
#line 192
void WebPYuv444ToRgb_C(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) ;
#line 192 "/root/patron-new/new_3/src/dsp/upsampling.c"
void WebPYuv444ToRgb_C(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 192
  i = 0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;

#line 192
    if (! (i < len)) {
#line 192
      goto while_break;
    }
    {
#line 192
    VP8YuvToRgb((int )*(y + i), (int )*(u + i), (int )*(v + i), dst + i * 3);
#line 192
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 196
  return;
}
}
#line 193
void WebPYuv444ToBgr_C(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) ;
#line 193 "/root/patron-new/new_3/src/dsp/upsampling.c"
void WebPYuv444ToBgr_C(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 193
  i = 0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;

#line 193
    if (! (i < len)) {
#line 193
      goto while_break;
    }
    {
#line 193
    VP8YuvToBgr((int )*(y + i), (int )*(u + i), (int )*(v + i), dst + i * 3);
#line 193
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 197
  return;
}
}
#line 194
void WebPYuv444ToArgb_C(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) ;
#line 194 "/root/patron-new/new_3/src/dsp/upsampling.c"
void WebPYuv444ToArgb_C(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 194
  i = 0;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;

#line 194
    if (! (i < len)) {
#line 194
      goto while_break;
    }
    {
#line 194
    VP8YuvToArgb(*(y + i), *(u + i), *(v + i), dst + i * 4);
#line 194
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 198
  return;
}
}
#line 195
void WebPYuv444ToRgba4444_C(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst ,
                            int len ) ;
#line 195 "/root/patron-new/new_3/src/dsp/upsampling.c"
void WebPYuv444ToRgba4444_C(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst ,
                            int len ) 
{ 
  int i ;

  {
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;

#line 195
    if (! (i < len)) {
#line 195
      goto while_break;
    }
    {
#line 195
    VP8YuvToRgba4444((int )*(y + i), (int )*(u + i), (int )*(v + i), dst + i * 2);
#line 195
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 199
  return;
}
}
#line 196
void WebPYuv444ToRgb565_C(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) ;
#line 196 "/root/patron-new/new_3/src/dsp/upsampling.c"
void WebPYuv444ToRgb565_C(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 196
  i = 0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;

#line 196
    if (! (i < len)) {
#line 196
      goto while_break;
    }
    {
#line 196
    VP8YuvToRgb565((int )*(y + i), (int )*(u + i), (int )*(v + i), dst + i * 2);
#line 196
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 200
  return;
}
}
#line 219
extern void WebPInitYUV444ConvertersSSE2(void) ;
#line 220
extern void WebPInitYUV444ConvertersSSE41(void) ;
#line 222
static void WebPInitYUV444Converters_body(void) ;
#line 224 "/root/patron-new/new_3/src/dsp/upsampling.c"
static int (*WebPInitYUV444Converters_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 225 "/root/patron-new/new_3/src/dsp/upsampling.c"
static pthread_mutex_t WebPInitYUV444Converters_body_lock  ;
#line 222 "/root/patron-new/new_3/src/dsp/upsampling.c"
void WebPInitYUV444Converters(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 222
    WebPInitYUV444Converters_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& WebPInitYUV444Converters_body_last_cpuinfo_used);
#line 222
    WebPInitYUV444Converters_body_lock.__data.__lock = 0;
#line 222
    WebPInitYUV444Converters_body_lock.__data.__count = 0U;
#line 222
    WebPInitYUV444Converters_body_lock.__data.__owner = 0;
#line 222
    WebPInitYUV444Converters_body_lock.__data.__nusers = 0U;
#line 222
    WebPInitYUV444Converters_body_lock.__data.__kind = 0;
#line 222
    WebPInitYUV444Converters_body_lock.__data.__spins = (short)0;
#line 222
    WebPInitYUV444Converters_body_lock.__data.__elision = (short)0;
#line 222
    WebPInitYUV444Converters_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 222
    WebPInitYUV444Converters_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 222
    __cil_tmp3 = pthread_mutex_lock(& WebPInitYUV444Converters_body_lock);
    }
#line 222
    if (__cil_tmp3) {
#line 222
      goto while_break;
    }
#line 222
    if ((unsigned long )WebPInitYUV444Converters_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 222
      WebPInitYUV444Converters_body();
      }
    }
    {
#line 222
    WebPInitYUV444Converters_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 222
    pthread_mutex_unlock(& WebPInitYUV444Converters_body_lock);
    }
#line 222
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 226
  return;
}
}
#line 222 "/root/patron-new/new_3/src/dsp/upsampling.c"
static void WebPInitYUV444Converters_body(void) 
{ 
  int __cil_tmp1 ;
  int __cil_tmp2 ;

  {
#line 223
  WebPYUV444Converters[1] = & WebPYuv444ToRgba_C;
#line 224
  WebPYUV444Converters[3] = & WebPYuv444ToBgra_C;
#line 225
  WebPYUV444Converters[0] = & WebPYuv444ToRgb_C;
#line 226
  WebPYUV444Converters[2] = & WebPYuv444ToBgr_C;
#line 227
  WebPYUV444Converters[4] = & WebPYuv444ToArgb_C;
#line 228
  WebPYUV444Converters[5] = & WebPYuv444ToRgba4444_C;
#line 229
  WebPYUV444Converters[6] = & WebPYuv444ToRgb565_C;
#line 230
  WebPYUV444Converters[7] = & WebPYuv444ToRgba_C;
#line 231
  WebPYUV444Converters[8] = & WebPYuv444ToBgra_C;
#line 232
  WebPYUV444Converters[9] = & WebPYuv444ToArgb_C;
#line 233
  WebPYUV444Converters[10] = & WebPYuv444ToRgba4444_C;
#line 235
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
    {
#line 237
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 237
    if (__cil_tmp1) {
      {
#line 238
      WebPInitYUV444ConvertersSSE2();
      }
    }
    {
#line 242
    __cil_tmp2 = (*VP8GetCPUInfo)((CPUFeature )3);
    }
#line 242
    if (__cil_tmp2) {
      {
#line 243
      WebPInitYUV444ConvertersSSE41();
      }
    }
  }
#line 247
  return;
}
}
#line 257
extern void WebPInitUpsamplersSSE2(void) ;
#line 258
extern void WebPInitUpsamplersSSE41(void) ;
#line 263
static void WebPInitUpsamplers_body(void) ;
#line 265 "/root/patron-new/new_3/src/dsp/upsampling.c"
static int (*WebPInitUpsamplers_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 266 "/root/patron-new/new_3/src/dsp/upsampling.c"
static pthread_mutex_t WebPInitUpsamplers_body_lock  ;
#line 263 "/root/patron-new/new_3/src/dsp/upsampling.c"
void WebPInitUpsamplers(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 263
    WebPInitUpsamplers_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& WebPInitUpsamplers_body_last_cpuinfo_used);
#line 263
    WebPInitUpsamplers_body_lock.__data.__lock = 0;
#line 263
    WebPInitUpsamplers_body_lock.__data.__count = 0U;
#line 263
    WebPInitUpsamplers_body_lock.__data.__owner = 0;
#line 263
    WebPInitUpsamplers_body_lock.__data.__nusers = 0U;
#line 263
    WebPInitUpsamplers_body_lock.__data.__kind = 0;
#line 263
    WebPInitUpsamplers_body_lock.__data.__spins = (short)0;
#line 263
    WebPInitUpsamplers_body_lock.__data.__elision = (short)0;
#line 263
    WebPInitUpsamplers_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 263
    WebPInitUpsamplers_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 263
    __cil_tmp3 = pthread_mutex_lock(& WebPInitUpsamplers_body_lock);
    }
#line 263
    if (__cil_tmp3) {
#line 263
      goto while_break;
    }
#line 263
    if ((unsigned long )WebPInitUpsamplers_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 263
      WebPInitUpsamplers_body();
      }
    }
    {
#line 263
    WebPInitUpsamplers_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 263
    pthread_mutex_unlock(& WebPInitUpsamplers_body_lock);
    }
#line 263
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 267
  return;
}
}
#line 263 "/root/patron-new/new_3/src/dsp/upsampling.c"
static void WebPInitUpsamplers_body(void) 
{ 
  int __cil_tmp1 ;
  int __cil_tmp2 ;

  {
#line 266
  WebPUpsamplers[1] = & UpsampleRgbaLinePair_C;
#line 267
  WebPUpsamplers[3] = & UpsampleBgraLinePair_C;
#line 268
  WebPUpsamplers[7] = & UpsampleRgbaLinePair_C;
#line 269
  WebPUpsamplers[8] = & UpsampleBgraLinePair_C;
#line 270
  WebPUpsamplers[0] = & UpsampleRgbLinePair_C;
#line 271
  WebPUpsamplers[2] = & UpsampleBgrLinePair_C;
#line 272
  WebPUpsamplers[4] = & UpsampleArgbLinePair_C;
#line 273
  WebPUpsamplers[5] = & UpsampleRgba4444LinePair_C;
#line 274
  WebPUpsamplers[6] = & UpsampleRgb565LinePair_C;
#line 275
  WebPUpsamplers[9] = & UpsampleArgbLinePair_C;
#line 276
  WebPUpsamplers[10] = & UpsampleRgba4444LinePair_C;
#line 280
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
    {
#line 282
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 282
    if (__cil_tmp1) {
      {
#line 283
      WebPInitUpsamplersSSE2();
      }
    }
    {
#line 287
    __cil_tmp2 = (*VP8GetCPUInfo)((CPUFeature )3);
    }
#line 287
    if (__cil_tmp2) {
      {
#line 288
      WebPInitUpsamplersSSE41();
      }
    }
  }
#line 292
  return;
}
}
#line 25 "/root/patron-new/new_3/src/dsp/ssim.c"
static uint32_t kWeight[7]  = {      (uint32_t )1,      (uint32_t )2,      (uint32_t )3,      (uint32_t )4, 
        (uint32_t )3,      (uint32_t )2,      (uint32_t )1};
#line 28 "/root/patron-new/new_3/src/dsp/ssim.c"
static uint32_t kWeightSum  =    (uint32_t )256;
#line 30 "/root/patron-new/new_3/src/dsp/ssim.c"
__inline static double SSIMCalculation(VP8DistoStats *stats , uint32_t N ) 
{ 
  uint32_t w2 ;
  uint32_t C1 ;
  uint32_t C2 ;
  uint32_t C3 ;
  uint64_t xmxm ;
  uint64_t ymym ;
  int64_t xmym ;
  int64_t sxy ;
  uint64_t sxx ;
  uint64_t syy ;
  uint64_t num_S ;
  long tmp ;
  uint64_t den_S ;
  uint64_t fnum ;
  uint64_t fden ;
  double r ;

  {
#line 32
  w2 = N * N;
#line 33
  C1 = 20U * w2;
#line 34
  C2 = 60U * w2;
#line 35
  C3 = 64U * w2;
#line 36
  xmxm = (uint64_t )stats->xm * (unsigned long )stats->xm;
#line 37
  ymym = (uint64_t )stats->ym * (unsigned long )stats->ym;
#line 38
  if (xmxm + ymym >= (unsigned long )C3) {
#line 39
    xmym = (int64_t )stats->xm * (long )stats->ym;
#line 40
    sxy = (int64_t )stats->xym * (long )N - xmym;
#line 41
    sxx = (uint64_t )stats->xxm * (unsigned long )N - xmxm;
#line 42
    syy = (uint64_t )stats->yym * (unsigned long )N - ymym;
#line 44
    if (sxy < 0L) {
#line 44
      tmp = 0L;
    } else {
#line 44
      tmp = sxy;
    }
#line 44
    num_S = (2UL * (uint64_t )tmp + (unsigned long )C2) >> 8;
#line 45
    den_S = ((sxx + syy) + (unsigned long )C2) >> 8;
#line 46
    fnum = (unsigned long )(2L * xmym + (long )C1) * num_S;
#line 47
    fden = ((xmxm + ymym) + (unsigned long )C1) * den_S;
#line 48
    r = (double )fnum / (double )fden;
#line 50
    return (r);
  }
#line 52
  return (1.);
}
}
#line 55 "/root/patron-new/new_3/src/dsp/ssim.c"
double VP8SSIMFromStats(VP8DistoStats *stats ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 56
  __cil_tmp2 = SSIMCalculation(stats, kWeightSum);
  }
#line 56
  return (__cil_tmp2);
}
}
#line 59 "/root/patron-new/new_3/src/dsp/ssim.c"
double VP8SSIMFromStatsClipped(VP8DistoStats *stats ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 60
  __cil_tmp2 = SSIMCalculation(stats, stats->w);
  }
#line 60
  return (__cil_tmp2);
}
}
#line 63 "/root/patron-new/new_3/src/dsp/ssim.c"
static double SSIMGetClipped_C(uint8_t *src1 , int stride1 , uint8_t *src2 , int stride2 ,
                               int xo , int yo , int W , int H ) 
{ 
  VP8DistoStats stats ;
  int ymin ;
  int tmp ;
  int ymax ;
  int tmp___0 ;
  int xmin ;
  int tmp___1 ;
  int xmax ;
  int tmp___2 ;
  int x ;
  int y ;
  uint32_t w ;
  uint32_t s1 ;
  uint32_t s2 ;
  double __cil_tmp23 ;

  {
#line 66
  stats.w = (uint32_t )0;
#line 66
  stats.xm = (uint32_t )0;
#line 66
  stats.ym = (uint32_t )0;
#line 66
  stats.xxm = (uint32_t )0;
#line 66
  stats.xym = (uint32_t )0;
#line 66
  stats.yym = (uint32_t )0;
#line 67
  if (yo - 3 < 0) {
#line 67
    tmp = 0;
  } else {
#line 67
    tmp = yo - 3;
  }
#line 67
  ymin = tmp;
#line 68
  if (yo + 3 > H - 1) {
#line 68
    tmp___0 = H - 1;
  } else {
#line 68
    tmp___0 = yo + 3;
  }
#line 68
  ymax = tmp___0;
#line 70
  if (xo - 3 < 0) {
#line 70
    tmp___1 = 0;
  } else {
#line 70
    tmp___1 = xo - 3;
  }
#line 70
  xmin = tmp___1;
#line 71
  if (xo + 3 > W - 1) {
#line 71
    tmp___2 = W - 1;
  } else {
#line 71
    tmp___2 = xo + 3;
  }
#line 71
  xmax = tmp___2;
#line 74
  src1 += ymin * stride1;
#line 75
  src2 += ymin * stride2;
#line 76
  y = ymin;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;

#line 76
    if (! (y <= ymax)) {
#line 76
      goto while_break;
    }
#line 77
    x = xmin;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 77
      if (! (x <= xmax)) {
#line 77
        goto while_break___0;
      }
#line 78
      w = kWeight[(3 + x) - xo] * kWeight[(3 + y) - yo];
#line 80
      s1 = (uint32_t )*(src1 + x);
#line 81
      s2 = (uint32_t )*(src2 + x);
#line 82
      stats.w += w;
#line 83
      stats.xm += w * s1;
#line 84
      stats.ym += w * s2;
#line 85
      stats.xxm += (w * s1) * s1;
#line 86
      stats.xym += (w * s1) * s2;
#line 87
      stats.yym += (w * s2) * s2;
#line 77
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 76
    src2 += stride2;
#line 76
    src1 += stride1;
#line 76
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 90
  __cil_tmp23 = VP8SSIMFromStatsClipped(& stats);
  }
#line 90
  return (__cil_tmp23);
}
}
#line 93 "/root/patron-new/new_3/src/dsp/ssim.c"
static double SSIMGet_C(uint8_t *src1 , int stride1 , uint8_t *src2 , int stride2 ) 
{ 
  VP8DistoStats stats ;
  int x ;
  int y ;
  uint32_t w ;
  uint32_t s1 ;
  uint32_t s2 ;
  double __cil_tmp11 ;

  {
#line 95
  stats.w = (uint32_t )0;
#line 95
  stats.xm = (uint32_t )0;
#line 95
  stats.ym = (uint32_t )0;
#line 95
  stats.xxm = (uint32_t )0;
#line 95
  stats.xym = (uint32_t )0;
#line 95
  stats.yym = (uint32_t )0;
#line 97
  y = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;

#line 97
    if (! (y <= 6)) {
#line 97
      goto while_break;
    }
#line 98
    x = 0;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 98
      if (! (x <= 6)) {
#line 98
        goto while_break___0;
      }
#line 99
      w = kWeight[x] * kWeight[y];
#line 100
      s1 = (uint32_t )*(src1 + x);
#line 101
      s2 = (uint32_t )*(src2 + x);
#line 102
      stats.xm += w * s1;
#line 103
      stats.ym += w * s2;
#line 104
      stats.xxm += (w * s1) * s1;
#line 105
      stats.xym += (w * s1) * s2;
#line 106
      stats.yym += (w * s2) * s2;
#line 98
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 97
    src2 += stride2;
#line 97
    src1 += stride1;
#line 97
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 109
  __cil_tmp11 = VP8SSIMFromStats(& stats);
  }
#line 109
  return (__cil_tmp11);
}
}
#line 117 "/root/patron-new/new_3/src/dsp/ssim.c"
static uint32_t AccumulateSSE_C(uint8_t *src1 , uint8_t *src2 , int len ) 
{ 
  int i ;
  uint32_t sse2 ;
  int32_t diff ;

  {
#line 120
  sse2 = (uint32_t )0;
#line 122
  i = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;

#line 122
    if (! (i < len)) {
#line 122
      goto while_break;
    }
#line 123
    diff = (int )*(src1 + i) - (int )*(src2 + i);
#line 124
    sse2 += (unsigned int )(diff * diff);
#line 122
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 126
  return (sse2);
}
}
#line 140
extern void VP8SSIMDspInitSSE2(void) ;
#line 142
static void VP8SSIMDspInit_body(void) ;
#line 144 "/root/patron-new/new_3/src/dsp/ssim.c"
static int (*VP8SSIMDspInit_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 145 "/root/patron-new/new_3/src/dsp/ssim.c"
static pthread_mutex_t VP8SSIMDspInit_body_lock  ;
#line 142 "/root/patron-new/new_3/src/dsp/ssim.c"
void VP8SSIMDspInit(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 142
    VP8SSIMDspInit_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& VP8SSIMDspInit_body_last_cpuinfo_used);
#line 142
    VP8SSIMDspInit_body_lock.__data.__lock = 0;
#line 142
    VP8SSIMDspInit_body_lock.__data.__count = 0U;
#line 142
    VP8SSIMDspInit_body_lock.__data.__owner = 0;
#line 142
    VP8SSIMDspInit_body_lock.__data.__nusers = 0U;
#line 142
    VP8SSIMDspInit_body_lock.__data.__kind = 0;
#line 142
    VP8SSIMDspInit_body_lock.__data.__spins = (short)0;
#line 142
    VP8SSIMDspInit_body_lock.__data.__elision = (short)0;
#line 142
    VP8SSIMDspInit_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 142
    VP8SSIMDspInit_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 142
    __cil_tmp3 = pthread_mutex_lock(& VP8SSIMDspInit_body_lock);
    }
#line 142
    if (__cil_tmp3) {
#line 142
      goto while_break;
    }
#line 142
    if ((unsigned long )VP8SSIMDspInit_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 142
      VP8SSIMDspInit_body();
      }
    }
    {
#line 142
    VP8SSIMDspInit_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 142
    pthread_mutex_unlock(& VP8SSIMDspInit_body_lock);
    }
#line 142
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 146
  return;
}
}
#line 142 "/root/patron-new/new_3/src/dsp/ssim.c"
static void VP8SSIMDspInit_body(void) 
{ 
  int __cil_tmp1 ;

  {
#line 144
  VP8SSIMGetClipped = & SSIMGetClipped_C;
#line 145
  VP8SSIMGet = & SSIMGet_C;
#line 149
  VP8AccumulateSSE = & AccumulateSSE_C;
#line 152
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
    {
#line 154
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 154
    if (__cil_tmp1) {
      {
#line 155
      VP8SSIMDspInitSSE2();
      }
    }
  }
#line 159
  return;
}
}
#line 29 "/root/patron-new/new_3/src/dsp/rescaler.c"
void WebPRescalerImportRowExpand_C(WebPRescaler *wrk , uint8_t *src ) 
{ 
  int x_stride ;
  int x_out_max ;
  int channel ;
  int x_in ;
  int x_out ;
  int accum ;
  rescaler_t left ;
  rescaler_t right ;
  rescaler_t tmp ;

  {
#line 31
  x_stride = wrk->num_channels;
#line 32
  x_out_max = wrk->dst_width * wrk->num_channels;
#line 36
  channel = 0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;

#line 36
    if (! (channel < x_stride)) {
#line 36
      goto while_break;
    }
#line 37
    x_in = channel;
#line 38
    x_out = channel;
#line 40
    accum = wrk->x_add;
#line 41
    left = (rescaler_t )*(src + x_in);
#line 42
    if (wrk->src_width > 1) {
#line 42
      tmp = (rescaler_t )*(src + (x_in + x_stride));
    } else {
#line 42
      tmp = left;
    }
#line 42
    right = tmp;
#line 44
    x_in += x_stride;
    {
#line 45
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 46
      *(wrk->frow + x_out) = right * (unsigned int )wrk->x_add + (left - right) * (unsigned int )accum;
#line 47
      x_out += x_stride;
#line 48
      if (x_out >= x_out_max) {
#line 48
        goto while_break___0;
      }
#line 49
      accum -= wrk->x_sub;
#line 50
      if (accum < 0) {
#line 51
        left = right;
#line 52
        x_in += x_stride;
#line 54
        right = (rescaler_t )*(src + x_in);
#line 55
        accum += wrk->x_add;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 36
    channel ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 40
  return;
}
}
#line 62 "/root/patron-new/new_3/src/dsp/rescaler.c"
void WebPRescalerImportRowShrink_C(WebPRescaler *wrk , uint8_t *src ) 
{ 
  int x_stride ;
  int x_out_max ;
  int channel ;
  int x_in ;
  int x_out ;
  uint32_t sum ;
  int accum ;
  uint32_t base ;
  rescaler_t frac ;

  {
#line 64
  x_stride = wrk->num_channels;
#line 65
  x_out_max = wrk->dst_width * wrk->num_channels;
#line 69
  channel = 0;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;

#line 69
    if (! (channel < x_stride)) {
#line 69
      goto while_break;
    }
#line 70
    x_in = channel;
#line 71
    x_out = channel;
#line 72
    sum = (uint32_t )0;
#line 73
    accum = 0;
    {
#line 74
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 74
      if (! (x_out < x_out_max)) {
#line 74
        goto while_break___0;
      }
#line 75
      base = (uint32_t )0;
#line 76
      accum += wrk->x_add;
      {
#line 77
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 77
        if (! (accum > 0)) {
#line 77
          goto while_break___1;
        }
#line 78
        accum -= wrk->x_sub;
#line 80
        base = (uint32_t )*(src + x_in);
#line 81
        sum += base;
#line 82
        x_in += x_stride;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 85
      frac = base * (unsigned int )(- accum);
#line 86
      *(wrk->frow + x_out) = sum * (unsigned int )wrk->x_sub - frac;
#line 88
      sum = (uint32_t )((int )(((unsigned long long )((uint64_t )frac * (unsigned long )wrk->fx_scale) + ((1ULL << 32) >> 1)) >> 32));
#line 90
      x_out += x_stride;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 69
    channel ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 73
  return;
}
}
#line 99 "/root/patron-new/new_3/src/dsp/rescaler.c"
void WebPRescalerExportRowExpand_C(WebPRescaler *wrk ) 
{ 
  int x_out ;
  uint8_t *dst ;
  rescaler_t *irow ;
  int x_out_max ;
  rescaler_t *frow ;
  uint32_t J ;
  int v ;
  unsigned int tmp ;
  uint32_t B ;
  uint32_t A ;
  uint64_t I ;
  uint32_t J___0 ;
  int v___0 ;
  unsigned int tmp___0 ;

  {
#line 101
  dst = wrk->dst;
#line 102
  irow = wrk->irow;
#line 103
  x_out_max = wrk->dst_width * wrk->num_channels;
#line 104
  frow = wrk->frow;
#line 109
  if (wrk->y_accum == 0) {
#line 110
    x_out = 0;
    {
#line 110
    while (1) {
      while_continue: /* CIL Label */ ;

#line 110
      if (! (x_out < x_out_max)) {
#line 110
        goto while_break;
      }
#line 111
      J = *(frow + x_out);
#line 112
      v = (int )(((unsigned long long )((uint64_t )J * (unsigned long )wrk->fy_scale) + ((1ULL << 32) >> 1)) >> 32);
#line 113
      if (v > 255) {
#line 113
        tmp = 255U;
      } else {
#line 113
        tmp = (unsigned int )((uint8_t )v);
      }
#line 113
      *(dst + x_out) = (uint8_t )tmp;
#line 110
      x_out ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 116
    B = (uint32_t )(((uint64_t )(- wrk->y_accum) << 32) / (unsigned long )wrk->y_sub);
#line 117
    A = (uint32_t )((1ULL << 32) - (unsigned long long )B);
#line 118
    x_out = 0;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 118
      if (! (x_out < x_out_max)) {
#line 118
        goto while_break___0;
      }
#line 119
      I = (uint64_t )A * (unsigned long )*(frow + x_out) + (uint64_t )B * (unsigned long )*(irow + x_out);
#line 121
      J___0 = (uint32_t )(((unsigned long long )I + ((1ULL << 32) >> 1)) >> 32);
#line 122
      v___0 = (int )(((unsigned long long )((uint64_t )J___0 * (unsigned long )wrk->fy_scale) + ((1ULL << 32) >> 1)) >> 32);
#line 123
      if (v___0 > 255) {
#line 123
        tmp___0 = 255U;
      } else {
#line 123
        tmp___0 = (unsigned int )((uint8_t )v___0);
      }
#line 123
      *(dst + x_out) = (uint8_t )tmp___0;
#line 118
      x_out ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 123
  return;
}
}
#line 128 "/root/patron-new/new_3/src/dsp/rescaler.c"
void WebPRescalerExportRowShrink_C(WebPRescaler *wrk ) 
{ 
  int x_out ;
  uint8_t *dst ;
  rescaler_t *irow ;
  int x_out_max ;
  rescaler_t *frow ;
  uint32_t yscale ;
  uint32_t frac ;
  int v ;
  unsigned int tmp ;
  int v___0 ;
  unsigned int tmp___0 ;

  {
#line 130
  dst = wrk->dst;
#line 131
  irow = wrk->irow;
#line 132
  x_out_max = wrk->dst_width * wrk->num_channels;
#line 133
  frow = wrk->frow;
#line 134
  yscale = wrk->fy_scale * (unsigned int )(- wrk->y_accum);
#line 138
  if (yscale) {
#line 139
    x_out = 0;
    {
#line 139
    while (1) {
      while_continue: /* CIL Label */ ;

#line 139
      if (! (x_out < x_out_max)) {
#line 139
        goto while_break;
      }
#line 140
      frac = (uint32_t )((uint64_t )*(frow + x_out) * (unsigned long )yscale >> 32);
#line 141
      v = (int )(((unsigned long long )((uint64_t )(*(irow + x_out) - frac) * (unsigned long )wrk->fxy_scale) + ((1ULL << 32) >> 1)) >> 32);
#line 142
      if (v > 255) {
#line 142
        tmp = 255U;
      } else {
#line 142
        tmp = (unsigned int )((uint8_t )v);
      }
#line 142
      *(dst + x_out) = (uint8_t )tmp;
#line 143
      *(irow + x_out) = frac;
#line 139
      x_out ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 146
    x_out = 0;
    {
#line 146
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 146
      if (! (x_out < x_out_max)) {
#line 146
        goto while_break___0;
      }
#line 147
      v___0 = (int )(((unsigned long long )((uint64_t )*(irow + x_out) * (unsigned long )wrk->fxy_scale) + ((1ULL << 32) >> 1)) >> 32);
#line 148
      if (v___0 > 255) {
#line 148
        tmp___0 = 255U;
      } else {
#line 148
        tmp___0 = (unsigned int )((uint8_t )v___0);
      }
#line 148
      *(dst + x_out) = (uint8_t )tmp___0;
#line 149
      *(irow + x_out) = (rescaler_t )0;
#line 146
      x_out ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 151
  return;
}
}
#line 161 "/root/patron-new/new_3/src/dsp/rescaler.c"
void WebPRescalerImportRow(WebPRescaler *wrk , uint8_t *src ) 
{ 


  {
#line 163
  if (! wrk->x_expand) {
    {
#line 164
    (*WebPRescalerImportRowShrink)((struct WebPRescaler */* const  */)wrk, src);
    }
  } else {
    {
#line 166
    (*WebPRescalerImportRowExpand)((struct WebPRescaler */* const  */)wrk, src);
    }
  }
#line 169
  return;
}
}
#line 170 "/root/patron-new/new_3/src/dsp/rescaler.c"
void WebPRescalerExportRow(WebPRescaler *wrk ) 
{ 
  int i ;

  {
#line 171
  if (wrk->y_accum <= 0) {
#line 173
    if (wrk->y_expand) {
      {
#line 174
      (*WebPRescalerExportRowExpand)((struct WebPRescaler */* const  */)wrk);
      }
    } else
#line 175
    if (wrk->fxy_scale) {
      {
#line 176
      (*WebPRescalerExportRowShrink)((struct WebPRescaler */* const  */)wrk);
      }
    } else {
#line 181
      i = 0;
      {
#line 181
      while (1) {
        while_continue: /* CIL Label */ ;

#line 181
        if (! (i < wrk->num_channels * wrk->dst_width)) {
#line 181
          goto while_break;
        }
#line 182
        *(wrk->dst + i) = (uint8_t )*(wrk->irow + i);
#line 183
        *(wrk->irow + i) = (rescaler_t )0;
#line 181
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: ;
    }
#line 186
    wrk->y_accum += wrk->y_add;
#line 187
    wrk->dst += wrk->dst_stride;
#line 188
    (wrk->dst_y) ++;
  }
#line 190
  return;
}
}
#line 200
extern void WebPRescalerDspInitSSE2(void) ;
#line 206
static void WebPRescalerDspInit_body(void) ;
#line 208 "/root/patron-new/new_3/src/dsp/rescaler.c"
static int (*WebPRescalerDspInit_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 209 "/root/patron-new/new_3/src/dsp/rescaler.c"
static pthread_mutex_t WebPRescalerDspInit_body_lock  ;
#line 206 "/root/patron-new/new_3/src/dsp/rescaler.c"
void WebPRescalerDspInit(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    WebPRescalerDspInit_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& WebPRescalerDspInit_body_last_cpuinfo_used);
#line 206
    WebPRescalerDspInit_body_lock.__data.__lock = 0;
#line 206
    WebPRescalerDspInit_body_lock.__data.__count = 0U;
#line 206
    WebPRescalerDspInit_body_lock.__data.__owner = 0;
#line 206
    WebPRescalerDspInit_body_lock.__data.__nusers = 0U;
#line 206
    WebPRescalerDspInit_body_lock.__data.__kind = 0;
#line 206
    WebPRescalerDspInit_body_lock.__data.__spins = (short)0;
#line 206
    WebPRescalerDspInit_body_lock.__data.__elision = (short)0;
#line 206
    WebPRescalerDspInit_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 206
    WebPRescalerDspInit_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 206
    __cil_tmp3 = pthread_mutex_lock(& WebPRescalerDspInit_body_lock);
    }
#line 206
    if (__cil_tmp3) {
#line 206
      goto while_break;
    }
#line 206
    if ((unsigned long )WebPRescalerDspInit_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 206
      WebPRescalerDspInit_body();
      }
    }
    {
#line 206
    WebPRescalerDspInit_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 206
    pthread_mutex_unlock(& WebPRescalerDspInit_body_lock);
    }
#line 206
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 210
  return;
}
}
#line 206 "/root/patron-new/new_3/src/dsp/rescaler.c"
static void WebPRescalerDspInit_body(void) 
{ 
  int __cil_tmp1 ;

  {
#line 209
  WebPRescalerExportRowExpand = (void (*)(struct WebPRescaler * const   ))(& WebPRescalerExportRowExpand_C);
#line 210
  WebPRescalerExportRowShrink = (void (*)(struct WebPRescaler * const   ))(& WebPRescalerExportRowShrink_C);
#line 213
  WebPRescalerImportRowExpand = (void (*)(struct WebPRescaler * const   , uint8_t * ))(& WebPRescalerImportRowExpand_C);
#line 214
  WebPRescalerImportRowShrink = (void (*)(struct WebPRescaler * const   , uint8_t * ))(& WebPRescalerImportRowShrink_C);
#line 216
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
    {
#line 218
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 218
    if (__cil_tmp1) {
      {
#line 219
      WebPRescalerDspInitSSE2();
      }
    }
  }
#line 223
  return;
}
}
#line 51 "../../src/dec/webpi_dec.h"
void WebPResetDecParams(WebPDecParams *params ) ;
#line 75
VP8StatusCode WebPParseHeaders(WebPHeaderStructure *headers ) ;
#line 81
int WebPCheckCropDimensions(int image_width , int image_height , int x , int y , int w ,
                            int h ) ;
#line 86
void WebPInitCustomIo(WebPDecParams *params , VP8Io *io ) ;
#line 90
int WebPIoInitFromOptions(WebPDecoderOptions *options , VP8Io *io , WEBP_CSP_MODE src_colorspace ) ;
#line 106
VP8StatusCode WebPAllocateDecBuffer(int width , int height , WebPDecoderOptions *options ,
                                    WebPDecBuffer *buffer ) ;
#line 111
VP8StatusCode WebPFlipBuffer(WebPDecBuffer *buffer ) ;
#line 115
void WebPCopyDecBuffer(WebPDecBuffer *src , WebPDecBuffer *dst ) ;
#line 119
void WebPGrabDecBuffer(WebPDecBuffer *src , WebPDecBuffer *dst ) ;
#line 123
VP8StatusCode WebPCopyDecBufferPixels(WebPDecBuffer *src_buf , WebPDecBuffer *dst_buf ) ;
#line 128
int WebPAvoidSlowMemory(WebPDecBuffer *output , WebPBitstreamFeatures *features ) ;
#line 102 "../../src/dec/vp8li_dec.h"
int VP8LDecodeAlphaHeader(ALPHDecoder *alph_dec , uint8_t *data , size_t data_size ) ;
#line 109
int VP8LDecodeAlphaImageStream(ALPHDecoder *alph_dec , int last_row ) ;
#line 113
VP8LDecoder *VP8LNew(void) ;
#line 116
int VP8LDecodeHeader(VP8LDecoder *dec , VP8Io *io ) ;
#line 120
int VP8LDecodeImage(VP8LDecoder *dec ) ;
#line 124
void VP8LClear(VP8LDecoder *dec ) ;
#line 127
void VP8LDelete(VP8LDecoder *dec ) ;
#line 28 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
float const   kLog2Table[256]  = 
#line 28 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
  {      (float const   )0.f,      (float const   )0.f,      (float const   )1.f,      (float const   )1.58496248723f, 
        (float const   )2.f,      (float const   )2.3219280243f,      (float const   )2.58496260644f,      (float const   )2.80735492707f, 
        (float const   )3.f,      (float const   )3.16992497445f,      (float const   )3.3219280243f,      (float const   )3.45943164826f, 
        (float const   )3.58496260644f,      (float const   )3.70043969155f,      (float const   )3.80735492707f,      (float const   )3.90689063073f, 
        (float const   )4.f,      (float const   )4.08746290207f,      (float const   )4.16992521287f,      (float const   )4.24792766572f, 
        (float const   )4.3219280243f,      (float const   )4.39231729508f,      (float const   )4.45943164826f,      (float const   )4.5235619545f, 
        (float const   )4.58496236802f,      (float const   )4.64385604859f,      (float const   )4.70043992997f,      (float const   )4.75488758088f, 
        (float const   )4.80735492707f,      (float const   )4.85798120499f,      (float const   )4.90689039231f,      (float const   )4.9541964531f, 
        (float const   )5.f,      (float const   )5.04439401627f,      (float const   )5.08746290207f,      (float const   )5.12928295136f, 
        (float const   )5.16992521287f,      (float const   )5.20945358277f,      (float const   )5.24792766572f,      (float const   )5.28540229798f, 
        (float const   )5.3219280243f,      (float const   )5.35755205155f,      (float const   )5.39231729508f,      (float const   )5.42626476288f, 
        (float const   )5.45943164826f,      (float const   )5.49185323716f,      (float const   )5.5235619545f,      (float const   )5.55458879471f, 
        (float const   )5.58496236802f,      (float const   )5.61470985413f,      (float const   )5.64385604859f,      (float const   )5.67242527009f, 
        (float const   )5.70043992997f,      (float const   )5.72792053223f,      (float const   )5.75488758088f,      (float const   )5.78135967255f, 
        (float const   )5.80735492707f,      (float const   )5.83289003373f,      (float const   )5.85798120499f,      (float const   )5.88264322281f, 
        (float const   )5.90689039231f,      (float const   )5.93073749543f,      (float const   )5.9541964531f,      (float const   )5.97728013993f, 
        (float const   )6.f,      (float const   )6.02236795426f,      (float const   )6.04439401627f,      (float const   )6.06608915329f, 
        (float const   )6.08746290207f,      (float const   )6.10852432251f,      (float const   )6.12928295136f,      (float const   )6.14974689484f, 
        (float const   )6.16992521287f,      (float const   )6.18982458115f,      (float const   )6.20945358277f,      (float const   )6.22881889344f, 
        (float const   )6.24792766572f,      (float const   )6.26678657532f,      (float const   )6.28540229798f,      (float const   )6.30378055573f, 
        (float const   )6.3219280243f,      (float const   )6.33984994889f,      (float const   )6.35755205155f,      (float const   )6.37503957749f, 
        (float const   )6.39231729508f,      (float const   )6.40939092637f,      (float const   )6.42626476288f,      (float const   )6.442943573f, 
        (float const   )6.45943164826f,      (float const   )6.47573328019f,      (float const   )6.49185323716f,      (float const   )6.50779485703f, 
        (float const   )6.5235619545f,      (float const   )6.53915882111f,      (float const   )6.55458879471f,      (float const   )6.56985569001f, 
        (float const   )6.58496236802f,      (float const   )6.59991264344f,      (float const   )6.61470985413f,      (float const   )6.62935638428f, 
        (float const   )6.64385604859f,      (float const   )6.65821170807f,      (float const   )6.67242527009f,      (float const   )6.68650054932f, 
        (float const   )6.70043992997f,      (float const   )6.71424531937f,      (float const   )6.72792053223f,      (float const   )6.74146699906f, 
        (float const   )6.75488758088f,      (float const   )6.76818418503f,      (float const   )6.78135967255f,      (float const   )6.79441595078f, 
        (float const   )6.80735492707f,      (float const   )6.8201789856f,      (float const   )6.83289003373f,      (float const   )6.8454899788f, 
        (float const   )6.85798120499f,      (float const   )6.87036466599f,      (float const   )6.88264322281f,      (float const   )6.89481782914f, 
        (float const   )6.90689039231f,      (float const   )6.91886329651f,      (float const   )6.93073749543f,      (float const   )6.94251441956f, 
        (float const   )6.9541964531f,      (float const   )6.96578407288f,      (float const   )6.97728013993f,      (float const   )6.98868465424f, 
        (float const   )7.f,      (float const   )7.01122713089f,      (float const   )7.02236795426f,      (float const   )7.03342294693f, 
        (float const   )7.04439401627f,      (float const   )7.05528259278f,      (float const   )7.06608915329f,      (float const   )7.07681560517f, 
        (float const   )7.08746290207f,      (float const   )7.09803199769f,      (float const   )7.10852432251f,      (float const   )7.11894130707f, 
        (float const   )7.12928295136f,      (float const   )7.13955116272f,      (float const   )7.14974689484f,      (float const   )7.15987110138f, 
        (float const   )7.16992521287f,      (float const   )7.17990922928f,      (float const   )7.18982458115f,      (float const   )7.19967222214f, 
        (float const   )7.20945358277f,      (float const   )7.21916866303f,      (float const   )7.22881889344f,      (float const   )7.23840475083f, 
        (float const   )7.24792766572f,      (float const   )7.2573876381f,      (float const   )7.26678657532f,      (float const   )7.27612447739f, 
        (float const   )7.28540229798f,      (float const   )7.29462051392f,      (float const   )7.30378055573f,      (float const   )7.31288290024f, 
        (float const   )7.3219280243f,      (float const   )7.33091688157f,      (float const   )7.33984994889f,      (float const   )7.34872817994f, 
        (float const   )7.35755205155f,      (float const   )7.36632204056f,      (float const   )7.37503957749f,      (float const   )7.38370418549f, 
        (float const   )7.39231729508f,      (float const   )7.40087938309f,      (float const   )7.40939092637f,      (float const   )7.41785240174f, 
        (float const   )7.42626476288f,      (float const   )7.4346280098f,      (float const   )7.442943573f,      (float const   )7.45121097565f, 
        (float const   )7.45943164826f,      (float const   )7.46760559083f,      (float const   )7.47573328019f,      (float const   )7.48381567002f, 
        (float const   )7.49185323716f,      (float const   )7.4998459816f,      (float const   )7.50779485703f,      (float const   )7.51569986344f, 
        (float const   )7.5235619545f,      (float const   )7.53138160706f,      (float const   )7.53915882111f,      (float const   )7.54689455033f, 
        (float const   )7.55458879471f,      (float const   )7.56224250794f,      (float const   )7.56985569001f,      (float const   )7.57742881775f, 
        (float const   )7.58496236802f,      (float const   )7.59245681763f,      (float const   )7.59991264344f,      (float const   )7.60733032227f, 
        (float const   )7.61470985413f,      (float const   )7.62205171586f,      (float const   )7.62935638428f,      (float const   )7.63662481308f, 
        (float const   )7.64385604859f,      (float const   )7.65105152131f,      (float const   )7.65821170807f,      (float const   )7.66533613205f, 
        (float const   )7.67242527009f,      (float const   )7.67948007584f,      (float const   )7.68650054932f,      (float const   )7.69348716736f, 
        (float const   )7.70043992997f,      (float const   )7.70735931397f,      (float const   )7.71424531937f,      (float const   )7.72109937668f, 
        (float const   )7.72792053223f,      (float const   )7.73470973969f,      (float const   )7.74146699906f,      (float const   )7.74819278718f, 
        (float const   )7.75488758088f,      (float const   )7.76155138016f,      (float const   )7.76818418503f,      (float const   )7.77478694916f, 
        (float const   )7.78135967255f,      (float const   )7.7879023552f,      (float const   )7.79441595078f,      (float const   )7.80089998246f, 
        (float const   )7.80735492707f,      (float const   )7.81378126145f,      (float const   )7.8201789856f,      (float const   )7.82654857636f, 
        (float const   )7.83289003373f,      (float const   )7.83920383454f,      (float const   )7.8454899788f,      (float const   )7.85174894333f, 
        (float const   )7.85798120499f,      (float const   )7.86418628693f,      (float const   )7.87036466599f,      (float const   )7.87651681901f, 
        (float const   )7.88264322281f,      (float const   )7.88874340058f,      (float const   )7.89481782914f,      (float const   )7.90086698533f, 
        (float const   )7.90689039231f,      (float const   )7.9128894806f,      (float const   )7.91886329651f,      (float const   )7.9248123169f, 
        (float const   )7.93073749543f,      (float const   )7.93663787842f,      (float const   )7.94251441956f,      (float const   )7.94836711884f, 
        (float const   )7.9541964531f,      (float const   )7.9600019455f,      (float const   )7.96578407288f,      (float const   )7.97154378891f, 
        (float const   )7.97728013993f,      (float const   )7.98299360276f,      (float const   )7.98868465424f,      (float const   )7.99435329438f};
#line 159 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
float const   kSLog2Table[256]  = 
#line 159
  {      (float const   )0.f,      (float const   )0.f,      (float const   )2.f,      (float const   )4.75488758088f, 
        (float const   )8.f,      (float const   )11.6096401215f,      (float const   )15.5097751618f,      (float const   )19.6514835358f, 
        (float const   )24.f,      (float const   )28.5293254853f,      (float const   )33.219280243f,      (float const   )38.0537490845f, 
        (float const   )43.0195503235f,      (float const   )48.1057167054f,      (float const   )53.3029670716f,      (float const   )58.6033592225f, 
        (float const   )64.f,      (float const   )69.4868698121f,      (float const   )75.0586471558f,      (float const   )80.7106246949f, 
        (float const   )86.4385604859f,      (float const   )92.2386627198f,      (float const   )98.107498169f,      (float const   )104.041923523f, 
        (float const   )110.039100647f,      (float const   )116.09640503f,      (float const   )122.211433411f,      (float const   )128.381958008f, 
        (float const   )134.605941773f,      (float const   )140.881454468f,      (float const   )147.206710816f,      (float const   )153.580078125f, 
        (float const   )160.f,      (float const   )166.465011597f,      (float const   )172.973739625f,      (float const   )179.524902344f, 
        (float const   )186.117294312f,      (float const   )192.749771119f,      (float const   )199.42124939f,      (float const   )206.130691529f, 
        (float const   )212.877120972f,      (float const   )219.659637452f,      (float const   )226.47732544f,      (float const   )233.32939148f, 
        (float const   )240.214996338f,      (float const   )247.133392334f,      (float const   )254.083847046f,      (float const   )261.065673829f, 
        (float const   )268.078186036f,      (float const   )275.120788575f,      (float const   )282.192810059f,      (float const   )289.293701172f, 
        (float const   )296.422851563f,      (float const   )303.57977295f,      (float const   )310.763916016f,      (float const   )317.974792481f, 
        (float const   )325.211883545f,      (float const   )332.474731446f,      (float const   )339.762908936f,      (float const   )347.075927735f, 
        (float const   )354.413421631f,      (float const   )361.774963379f,      (float const   )369.16015625f,      (float const   )376.568634034f, 
        (float const   )384.f,      (float const   )391.453918458f,      (float const   )398.930023194f,      (float const   )406.427978516f, 
        (float const   )413.947479249f,      (float const   )421.488189698f,      (float const   )429.049804688f,      (float const   )436.632049561f, 
        (float const   )444.234588624f,      (float const   )451.857177735f,      (float const   )459.499542237f,      (float const   )467.161407471f, 
        (float const   )474.84249878f,      (float const   )482.542572022f,      (float const   )490.261383057f,      (float const   )497.998687745f, 
        (float const   )505.754241944f,      (float const   )513.527832032f,      (float const   )521.319274903f,      (float const   )529.128295899f, 
        (float const   )536.954650879f,      (float const   )544.798217774f,      (float const   )552.658752442f,      (float const   )560.536071778f, 
        (float const   )568.429992676f,      (float const   )576.340270997f,      (float const   )584.266784668f,      (float const   )592.209289551f, 
        (float const   )600.16772461f,      (float const   )608.141784668f,      (float const   )616.131347657f,      (float const   )624.136291504f, 
        (float const   )632.156372071f,      (float const   )640.191528321f,      (float const   )648.241577149f,      (float const   )656.30633545f, 
        (float const   )664.385620118f,      (float const   )672.479370118f,      (float const   )680.587402344f,      (float const   )688.709533692f, 
        (float const   )696.845703125f,      (float const   )704.995788575f,      (float const   )713.159545899f,      (float const   )721.336975098f, 
        (float const   )729.527832032f,      (float const   )737.7321167f,      (float const   )745.949584961f,      (float const   )754.180175782f, 
        (float const   )762.42376709f,      (float const   )770.680236817f,      (float const   )778.949462891f,      (float const   )787.231384278f, 
        (float const   )795.525817872f,      (float const   )803.832702637f,      (float const   )812.151855469f,      (float const   )820.483337403f, 
        (float const   )828.826843262f,      (float const   )837.182434083f,      (float const   )845.549926758f,      (float const   )853.929260254f, 
        (float const   )862.3203125f,      (float const   )870.723022461f,      (float const   )879.137268067f,      (float const   )887.562927247f, 
        (float const   )896.f,      (float const   )904.448303223f,      (float const   )912.907836915f,      (float const   )921.378417969f, 
        (float const   )929.860046387f,      (float const   )938.352539063f,      (float const   )946.855957032f,      (float const   )955.370117188f, 
        (float const   )963.894958497f,      (float const   )972.430419922f,      (float const   )980.976379395f,      (float const   )989.532836915f, 
        (float const   )998.099609375f,      (float const   )1006.67675782f,      (float const   )1015.26409913f,      (float const   )1023.86157227f, 
        (float const   )1032.46923829f,      (float const   )1041.086792f,      (float const   )1049.71435547f,      (float const   )1058.35180665f, 
        (float const   )1066.99914551f,      (float const   )1075.65612793f,      (float const   )1084.32275391f,      (float const   )1092.99914551f, 
        (float const   )1101.68493653f,      (float const   )1110.3803711f,      (float const   )1119.08508301f,      (float const   )1127.79931641f, 
        (float const   )1136.52270508f,      (float const   )1145.25549317f,      (float const   )1153.99731446f,      (float const   )1162.74841309f, 
        (float const   )1171.50854493f,      (float const   )1180.2775879f,      (float const   )1189.05566407f,      (float const   )1197.84265137f, 
        (float const   )1206.63854981f,      (float const   )1215.44311524f,      (float const   )1224.2565918f,      (float const   )1233.07861329f, 
        (float const   )1241.90930176f,      (float const   )1250.74865723f,      (float const   )1259.59643555f,      (float const   )1268.45275879f, 
        (float const   )1277.31750489f,      (float const   )1286.19067383f,      (float const   )1295.07214356f,      (float const   )1303.96191407f, 
        (float const   )1312.85998536f,      (float const   )1321.76623536f,      (float const   )1330.680542f,      (float const   )1339.60302735f, 
        (float const   )1348.53356934f,      (float const   )1357.4720459f,      (float const   )1366.41857911f,      (float const   )1375.37304688f, 
        (float const   )1384.33544922f,      (float const   )1393.305542f,      (float const   )1402.28356934f,      (float const   )1411.26928711f, 
        (float const   )1420.26269532f,      (float const   )1429.26379395f,      (float const   )1438.27258301f,      (float const   )1447.28894043f, 
        (float const   )1456.31274415f,      (float const   )1465.34423829f,      (float const   )1474.38305665f,      (float const   )1483.42944336f, 
        (float const   )1492.4831543f,      (float const   )1501.54418946f,      (float const   )1510.6126709f,      (float const   )1519.6883545f, 
        (float const   )1528.77124024f,      (float const   )1537.8614502f,      (float const   )1546.95874024f,      (float const   )1556.06323243f, 
        (float const   )1565.17480469f,      (float const   )1574.29345704f,      (float const   )1583.41906739f,      (float const   )1592.55175782f, 
        (float const   )1601.69140625f,      (float const   )1610.8380127f,      (float const   )1619.99157715f,      (float const   )1629.15197754f, 
        (float const   )1638.3190918f,      (float const   )1647.49316407f,      (float const   )1656.6739502f,      (float const   )1665.8614502f, 
        (float const   )1675.05566407f,      (float const   )1684.2565918f,      (float const   )1693.4642334f,      (float const   )1702.67834473f, 
        (float const   )1711.89916993f,      (float const   )1721.12646485f,      (float const   )1730.36035157f,      (float const   )1739.60070801f, 
        (float const   )1748.84753418f,      (float const   )1758.10070801f,      (float const   )1767.36047364f,      (float const   )1776.62646485f, 
        (float const   )1785.89892579f,      (float const   )1795.17761231f,      (float const   )1804.46276856f,      (float const   )1813.75402833f, 
        (float const   )1823.05163575f,      (float const   )1832.35534668f,      (float const   )1841.66540528f,      (float const   )1850.98144532f, 
        (float const   )1860.30371094f,      (float const   )1869.63220215f,      (float const   )1878.96667481f,      (float const   )1888.30712891f, 
        (float const   )1897.65368653f,      (float const   )1907.00634766f,      (float const   )1916.36486817f,      (float const   )1925.72949219f, 
        (float const   )1935.09985352f,      (float const   )1944.47631836f,      (float const   )1953.85852051f,      (float const   )1963.24670411f, 
        (float const   )1972.640625f,      (float const   )1982.04052735f,      (float const   )1991.44604493f,      (float const   )2000.85742188f, 
        (float const   )2010.27453614f,      (float const   )2019.6973877f,      (float const   )2029.1258545f,      (float const   )2038.56018067f};
#line 226 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
VP8LPrefixCode kPrefixEncodeCode[512]  = 
#line 226
  {      {(int8_t )0, (int8_t )0}, 
        {(int8_t )0, (int8_t )0}, 
        {(int8_t )1, (int8_t )0}, 
        {(int8_t )2, (int8_t )0}, 
        {(int8_t )3, (int8_t )0}, 
        {(int8_t )4, (int8_t )1}, 
        {(int8_t )4, (int8_t )1}, 
        {(int8_t )5, (int8_t )1}, 
        {(int8_t )5, (int8_t )1}, 
        {(int8_t )6, (int8_t )2}, 
        {(int8_t )6, (int8_t )2}, 
        {(int8_t )6, (int8_t )2}, 
        {(int8_t )6, (int8_t )2}, 
        {(int8_t )7, (int8_t )2}, 
        {(int8_t )7, (int8_t )2}, 
        {(int8_t )7, (int8_t )2}, 
        {(int8_t )7, (int8_t )2}, 
        {(int8_t )8, (int8_t )3}, 
        {(int8_t )8, (int8_t )3}, 
        {(int8_t )8, (int8_t )3}, 
        {(int8_t )8, (int8_t )3}, 
        {(int8_t )8, (int8_t )3}, 
        {(int8_t )8, (int8_t )3}, 
        {(int8_t )8, (int8_t )3}, 
        {(int8_t )8, (int8_t )3}, 
        {(int8_t )9, (int8_t )3}, 
        {(int8_t )9, (int8_t )3}, 
        {(int8_t )9, (int8_t )3}, 
        {(int8_t )9, (int8_t )3}, 
        {(int8_t )9, (int8_t )3}, 
        {(int8_t )9, (int8_t )3}, 
        {(int8_t )9, (int8_t )3}, 
        {(int8_t )9, (int8_t )3}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )10, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )11, (int8_t )4}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )12, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )13, (int8_t )5}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )14, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )15, (int8_t )6}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )16, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}, 
        {(int8_t )17, (int8_t )7}};
#line 293 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
uint8_t kPrefixEncodeExtraBitsValue[512]  = 
#line 293
  {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )1,      (uint8_t )0, 
        (uint8_t )1,      (uint8_t )0,      (uint8_t )1,      (uint8_t )2, 
        (uint8_t )3,      (uint8_t )0,      (uint8_t )1,      (uint8_t )2, 
        (uint8_t )3,      (uint8_t )0,      (uint8_t )1,      (uint8_t )2, 
        (uint8_t )3,      (uint8_t )4,      (uint8_t )5,      (uint8_t )6, 
        (uint8_t )7,      (uint8_t )0,      (uint8_t )1,      (uint8_t )2, 
        (uint8_t )3,      (uint8_t )4,      (uint8_t )5,      (uint8_t )6, 
        (uint8_t )7,      (uint8_t )0,      (uint8_t )1,      (uint8_t )2, 
        (uint8_t )3,      (uint8_t )4,      (uint8_t )5,      (uint8_t )6, 
        (uint8_t )7,      (uint8_t )8,      (uint8_t )9,      (uint8_t )10, 
        (uint8_t )11,      (uint8_t )12,      (uint8_t )13,      (uint8_t )14, 
        (uint8_t )15,      (uint8_t )0,      (uint8_t )1,      (uint8_t )2, 
        (uint8_t )3,      (uint8_t )4,      (uint8_t )5,      (uint8_t )6, 
        (uint8_t )7,      (uint8_t )8,      (uint8_t )9,      (uint8_t )10, 
        (uint8_t )11,      (uint8_t )12,      (uint8_t )13,      (uint8_t )14, 
        (uint8_t )15,      (uint8_t )0,      (uint8_t )1,      (uint8_t )2, 
        (uint8_t )3,      (uint8_t )4,      (uint8_t )5,      (uint8_t )6, 
        (uint8_t )7,      (uint8_t )8,      (uint8_t )9,      (uint8_t )10, 
        (uint8_t )11,      (uint8_t )12,      (uint8_t )13,      (uint8_t )14, 
        (uint8_t )15,      (uint8_t )16,      (uint8_t )17,      (uint8_t )18, 
        (uint8_t )19,      (uint8_t )20,      (uint8_t )21,      (uint8_t )22, 
        (uint8_t )23,      (uint8_t )24,      (uint8_t )25,      (uint8_t )26, 
        (uint8_t )27,      (uint8_t )28,      (uint8_t )29,      (uint8_t )30, 
        (uint8_t )31,      (uint8_t )0,      (uint8_t )1,      (uint8_t )2, 
        (uint8_t )3,      (uint8_t )4,      (uint8_t )5,      (uint8_t )6, 
        (uint8_t )7,      (uint8_t )8,      (uint8_t )9,      (uint8_t )10, 
        (uint8_t )11,      (uint8_t )12,      (uint8_t )13,      (uint8_t )14, 
        (uint8_t )15,      (uint8_t )16,      (uint8_t )17,      (uint8_t )18, 
        (uint8_t )19,      (uint8_t )20,      (uint8_t )21,      (uint8_t )22, 
        (uint8_t )23,      (uint8_t )24,      (uint8_t )25,      (uint8_t )26, 
        (uint8_t )27,      (uint8_t )28,      (uint8_t )29,      (uint8_t )30, 
        (uint8_t )31,      (uint8_t )0,      (uint8_t )1,      (uint8_t )2, 
        (uint8_t )3,      (uint8_t )4,      (uint8_t )5,      (uint8_t )6, 
        (uint8_t )7,      (uint8_t )8,      (uint8_t )9,      (uint8_t )10, 
        (uint8_t )11,      (uint8_t )12,      (uint8_t )13,      (uint8_t )14, 
        (uint8_t )15,      (uint8_t )16,      (uint8_t )17,      (uint8_t )18, 
        (uint8_t )19,      (uint8_t )20,      (uint8_t )21,      (uint8_t )22, 
        (uint8_t )23,      (uint8_t )24,      (uint8_t )25,      (uint8_t )26, 
        (uint8_t )27,      (uint8_t )28,      (uint8_t )29,      (uint8_t )30, 
        (uint8_t )31,      (uint8_t )32,      (uint8_t )33,      (uint8_t )34, 
        (uint8_t )35,      (uint8_t )36,      (uint8_t )37,      (uint8_t )38, 
        (uint8_t )39,      (uint8_t )40,      (uint8_t )41,      (uint8_t )42, 
        (uint8_t )43,      (uint8_t )44,      (uint8_t )45,      (uint8_t )46, 
        (uint8_t )47,      (uint8_t )48,      (uint8_t )49,      (uint8_t )50, 
        (uint8_t )51,      (uint8_t )52,      (uint8_t )53,      (uint8_t )54, 
        (uint8_t )55,      (uint8_t )56,      (uint8_t )57,      (uint8_t )58, 
        (uint8_t )59,      (uint8_t )60,      (uint8_t )61,      (uint8_t )62, 
        (uint8_t )63,      (uint8_t )0,      (uint8_t )1,      (uint8_t )2, 
        (uint8_t )3,      (uint8_t )4,      (uint8_t )5,      (uint8_t )6, 
        (uint8_t )7,      (uint8_t )8,      (uint8_t )9,      (uint8_t )10, 
        (uint8_t )11,      (uint8_t )12,      (uint8_t )13,      (uint8_t )14, 
        (uint8_t )15,      (uint8_t )16,      (uint8_t )17,      (uint8_t )18, 
        (uint8_t )19,      (uint8_t )20,      (uint8_t )21,      (uint8_t )22, 
        (uint8_t )23,      (uint8_t )24,      (uint8_t )25,      (uint8_t )26, 
        (uint8_t )27,      (uint8_t )28,      (uint8_t )29,      (uint8_t )30, 
        (uint8_t )31,      (uint8_t )32,      (uint8_t )33,      (uint8_t )34, 
        (uint8_t )35,      (uint8_t )36,      (uint8_t )37,      (uint8_t )38, 
        (uint8_t )39,      (uint8_t )40,      (uint8_t )41,      (uint8_t )42, 
        (uint8_t )43,      (uint8_t )44,      (uint8_t )45,      (uint8_t )46, 
        (uint8_t )47,      (uint8_t )48,      (uint8_t )49,      (uint8_t )50, 
        (uint8_t )51,      (uint8_t )52,      (uint8_t )53,      (uint8_t )54, 
        (uint8_t )55,      (uint8_t )56,      (uint8_t )57,      (uint8_t )58, 
        (uint8_t )59,      (uint8_t )60,      (uint8_t )61,      (uint8_t )62, 
        (uint8_t )63,      (uint8_t )0,      (uint8_t )1,      (uint8_t )2, 
        (uint8_t )3,      (uint8_t )4,      (uint8_t )5,      (uint8_t )6, 
        (uint8_t )7,      (uint8_t )8,      (uint8_t )9,      (uint8_t )10, 
        (uint8_t )11,      (uint8_t )12,      (uint8_t )13,      (uint8_t )14, 
        (uint8_t )15,      (uint8_t )16,      (uint8_t )17,      (uint8_t )18, 
        (uint8_t )19,      (uint8_t )20,      (uint8_t )21,      (uint8_t )22, 
        (uint8_t )23,      (uint8_t )24,      (uint8_t )25,      (uint8_t )26, 
        (uint8_t )27,      (uint8_t )28,      (uint8_t )29,      (uint8_t )30, 
        (uint8_t )31,      (uint8_t )32,      (uint8_t )33,      (uint8_t )34, 
        (uint8_t )35,      (uint8_t )36,      (uint8_t )37,      (uint8_t )38, 
        (uint8_t )39,      (uint8_t )40,      (uint8_t )41,      (uint8_t )42, 
        (uint8_t )43,      (uint8_t )44,      (uint8_t )45,      (uint8_t )46, 
        (uint8_t )47,      (uint8_t )48,      (uint8_t )49,      (uint8_t )50, 
        (uint8_t )51,      (uint8_t )52,      (uint8_t )53,      (uint8_t )54, 
        (uint8_t )55,      (uint8_t )56,      (uint8_t )57,      (uint8_t )58, 
        (uint8_t )59,      (uint8_t )60,      (uint8_t )61,      (uint8_t )62, 
        (uint8_t )63,      (uint8_t )64,      (uint8_t )65,      (uint8_t )66, 
        (uint8_t )67,      (uint8_t )68,      (uint8_t )69,      (uint8_t )70, 
        (uint8_t )71,      (uint8_t )72,      (uint8_t )73,      (uint8_t )74, 
        (uint8_t )75,      (uint8_t )76,      (uint8_t )77,      (uint8_t )78, 
        (uint8_t )79,      (uint8_t )80,      (uint8_t )81,      (uint8_t )82, 
        (uint8_t )83,      (uint8_t )84,      (uint8_t )85,      (uint8_t )86, 
        (uint8_t )87,      (uint8_t )88,      (uint8_t )89,      (uint8_t )90, 
        (uint8_t )91,      (uint8_t )92,      (uint8_t )93,      (uint8_t )94, 
        (uint8_t )95,      (uint8_t )96,      (uint8_t )97,      (uint8_t )98, 
        (uint8_t )99,      (uint8_t )100,      (uint8_t )101,      (uint8_t )102, 
        (uint8_t )103,      (uint8_t )104,      (uint8_t )105,      (uint8_t )106, 
        (uint8_t )107,      (uint8_t )108,      (uint8_t )109,      (uint8_t )110, 
        (uint8_t )111,      (uint8_t )112,      (uint8_t )113,      (uint8_t )114, 
        (uint8_t )115,      (uint8_t )116,      (uint8_t )117,      (uint8_t )118, 
        (uint8_t )119,      (uint8_t )120,      (uint8_t )121,      (uint8_t )122, 
        (uint8_t )123,      (uint8_t )124,      (uint8_t )125,      (uint8_t )126, 
        (uint8_t )127,      (uint8_t )0,      (uint8_t )1,      (uint8_t )2, 
        (uint8_t )3,      (uint8_t )4,      (uint8_t )5,      (uint8_t )6, 
        (uint8_t )7,      (uint8_t )8,      (uint8_t )9,      (uint8_t )10, 
        (uint8_t )11,      (uint8_t )12,      (uint8_t )13,      (uint8_t )14, 
        (uint8_t )15,      (uint8_t )16,      (uint8_t )17,      (uint8_t )18, 
        (uint8_t )19,      (uint8_t )20,      (uint8_t )21,      (uint8_t )22, 
        (uint8_t )23,      (uint8_t )24,      (uint8_t )25,      (uint8_t )26, 
        (uint8_t )27,      (uint8_t )28,      (uint8_t )29,      (uint8_t )30, 
        (uint8_t )31,      (uint8_t )32,      (uint8_t )33,      (uint8_t )34, 
        (uint8_t )35,      (uint8_t )36,      (uint8_t )37,      (uint8_t )38, 
        (uint8_t )39,      (uint8_t )40,      (uint8_t )41,      (uint8_t )42, 
        (uint8_t )43,      (uint8_t )44,      (uint8_t )45,      (uint8_t )46, 
        (uint8_t )47,      (uint8_t )48,      (uint8_t )49,      (uint8_t )50, 
        (uint8_t )51,      (uint8_t )52,      (uint8_t )53,      (uint8_t )54, 
        (uint8_t )55,      (uint8_t )56,      (uint8_t )57,      (uint8_t )58, 
        (uint8_t )59,      (uint8_t )60,      (uint8_t )61,      (uint8_t )62, 
        (uint8_t )63,      (uint8_t )64,      (uint8_t )65,      (uint8_t )66, 
        (uint8_t )67,      (uint8_t )68,      (uint8_t )69,      (uint8_t )70, 
        (uint8_t )71,      (uint8_t )72,      (uint8_t )73,      (uint8_t )74, 
        (uint8_t )75,      (uint8_t )76,      (uint8_t )77,      (uint8_t )78, 
        (uint8_t )79,      (uint8_t )80,      (uint8_t )81,      (uint8_t )82, 
        (uint8_t )83,      (uint8_t )84,      (uint8_t )85,      (uint8_t )86, 
        (uint8_t )87,      (uint8_t )88,      (uint8_t )89,      (uint8_t )90, 
        (uint8_t )91,      (uint8_t )92,      (uint8_t )93,      (uint8_t )94, 
        (uint8_t )95,      (uint8_t )96,      (uint8_t )97,      (uint8_t )98, 
        (uint8_t )99,      (uint8_t )100,      (uint8_t )101,      (uint8_t )102, 
        (uint8_t )103,      (uint8_t )104,      (uint8_t )105,      (uint8_t )106, 
        (uint8_t )107,      (uint8_t )108,      (uint8_t )109,      (uint8_t )110, 
        (uint8_t )111,      (uint8_t )112,      (uint8_t )113,      (uint8_t )114, 
        (uint8_t )115,      (uint8_t )116,      (uint8_t )117,      (uint8_t )118, 
        (uint8_t )119,      (uint8_t )120,      (uint8_t )121,      (uint8_t )122, 
        (uint8_t )123,      (uint8_t )124,      (uint8_t )125,      (uint8_t )126};
#line 329 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static float FastSLog2Slow_C(uint32_t v ) 
{ 
  int log_cnt ;
  int __cil_tmp3 ;
  uint32_t y ;
  int correction ;
  float v_f ;
  uint32_t orig_v ;
  double __cil_tmp8 ;

  {
#line 331
  if (v < 65536U) {
    {
#line 334
    __cil_tmp3 = BitsLog2Floor(v);
#line 334
    log_cnt = __cil_tmp3 - 7;
#line 335
    y = (uint32_t )(1 << log_cnt);
#line 336
    correction = 0;
#line 337
    v_f = (float )v;
#line 338
    orig_v = v;
#line 339
    v >>= log_cnt;
#line 358
    correction = (int )(23U * (orig_v & (y - 1U)) >> 4);
    }
#line 359
    return (v_f * (float )(kLog2Table[v] + (float const   )((float )log_cnt)) + (float )correction);
  } else {
    {
#line 361
    __cil_tmp8 = log((double )v);
    }
#line 361
    return ((float )((1.44269504089 * (double )v) * __cil_tmp8));
  }
}
}
#line 365 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static float FastLog2Slow_C(uint32_t v ) 
{ 
  int log_cnt ;
  int __cil_tmp3 ;
  uint32_t y ;
  uint32_t orig_v ;
  double log_2 ;
  int correction ;
  double __cil_tmp8 ;

  {
#line 367
  if (v < 65536U) {
    {
#line 370
    __cil_tmp3 = BitsLog2Floor(v);
#line 370
    log_cnt = __cil_tmp3 - 7;
#line 371
    y = (uint32_t )(1 << log_cnt);
#line 372
    orig_v = v;
#line 374
    v >>= log_cnt;
#line 386
    log_2 = (double )(kLog2Table[v] + (float const   )((float )log_cnt));
    }
#line 387
    if (orig_v >= 4096U) {
#line 390
      correction = (int )(23U * (orig_v & (y - 1U)) >> 4);
#line 391
      log_2 += (double )correction / (double )orig_v;
    }
#line 393
    return ((float )log_2);
  } else {
    {
#line 395
    __cil_tmp8 = log((double )v);
    }
#line 395
    return ((float )(1.44269504089 * __cil_tmp8));
  }
}
}
#line 403 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static float CombinedShannonEntropy_C(int const   *X , int const   *Y ) 
{ 
  int i ;
  double retval ;
  int sumX ;
  int sumXY ;
  int x ;
  int xy ;
  float __cil_tmp9 ;
  float __cil_tmp10 ;
  float __cil_tmp11 ;
  float __cil_tmp12 ;
  float __cil_tmp13 ;

  {
#line 405
  retval = 0.;
#line 406
  sumX = 0;
#line 406
  sumXY = 0;
#line 407
  i = 0;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;

#line 407
    if (! (i < 256)) {
#line 407
      goto while_break;
    }
#line 408
    x = (int )*(X + i);
#line 409
    if (x != 0) {
      {
#line 410
      xy = x + (int )*(Y + i);
#line 411
      sumX += x;
#line 412
      __cil_tmp9 = VP8LFastSLog2((uint32_t )x);
#line 412
      retval -= (double )__cil_tmp9;
#line 413
      sumXY += xy;
#line 414
      __cil_tmp10 = VP8LFastSLog2((uint32_t )xy);
#line 414
      retval -= (double )__cil_tmp10;
      }
    } else
#line 415
    if (*(Y + i) != 0) {
      {
#line 416
      sumXY += (int )*(Y + i);
#line 417
      __cil_tmp11 = VP8LFastSLog2((uint32_t )*(Y + i));
#line 417
      retval -= (double )__cil_tmp11;
      }
    }
#line 407
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 420
  __cil_tmp13 = VP8LFastSLog2((uint32_t )sumXY);
#line 420
  __cil_tmp12 = VP8LFastSLog2((uint32_t )sumX);
#line 420
  retval += (double )(__cil_tmp12 + __cil_tmp13);
  }
#line 421
  return ((float )retval);
}
}
#line 424 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
void VP8LBitEntropyInit(VP8LBitEntropy *entropy ) 
{ 


  {
#line 425
  entropy->entropy = 0.;
#line 426
  entropy->sum = (uint32_t )0;
#line 427
  entropy->nonzeros = 0;
#line 428
  entropy->max_val = (uint32_t )0;
#line 429
  entropy->nonzero_code = 4294967295U;
#line 430
  return;
}
}
#line 432 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
void VP8LBitsEntropyUnrefined(uint32_t *array , int n , VP8LBitEntropy *entropy ) 
{ 
  int i ;
  float __cil_tmp5 ;
  float __cil_tmp6 ;

  {
  {
#line 436
  VP8LBitEntropyInit(entropy);
#line 438
  i = 0;
  }
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;

#line 438
    if (! (i < n)) {
#line 438
      goto while_break;
    }
#line 439
    if (*(array + i) != 0U) {
      {
#line 440
      entropy->sum += *(array + i);
#line 441
      entropy->nonzero_code = (uint32_t )i;
#line 442
      (entropy->nonzeros) ++;
#line 443
      __cil_tmp5 = VP8LFastSLog2(*(array + i));
#line 443
      entropy->entropy -= (double )__cil_tmp5;
      }
#line 444
      if (entropy->max_val < *(array + i)) {
#line 445
        entropy->max_val = *(array + i);
      }
    }
#line 438
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 449
  __cil_tmp6 = VP8LFastSLog2(entropy->sum);
#line 449
  entropy->entropy += (double )__cil_tmp6;
  }
#line 450
  return;
}
}
#line 452 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
__inline static void GetEntropyUnrefinedHelper(uint32_t val , int i , uint32_t *val_prev ,
                                               int *i_prev , VP8LBitEntropy *bit_entropy ,
                                               VP8LStreaks *stats ) 
{ 
  int streak ;
  float __cil_tmp8 ;

  {
#line 455
  streak = i - *i_prev;
#line 458
  if (*val_prev != 0U) {
    {
#line 459
    bit_entropy->sum += *val_prev * (unsigned int )streak;
#line 460
    bit_entropy->nonzeros += streak;
#line 461
    bit_entropy->nonzero_code = (uint32_t )*i_prev;
#line 462
    __cil_tmp8 = VP8LFastSLog2(*val_prev);
#line 462
    bit_entropy->entropy -= (double )(__cil_tmp8 * (float )streak);
    }
#line 463
    if (bit_entropy->max_val < *val_prev) {
#line 464
      bit_entropy->max_val = *val_prev;
    }
  }
#line 469
  stats->counts[*val_prev != 0U] += streak > 3;
#line 470
  stats->streaks[*val_prev != 0U][streak > 3] += streak;
#line 472
  *val_prev = val;
#line 473
  *i_prev = i;
#line 474
  return;
}
}
#line 476 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void GetEntropyUnrefined_C(uint32_t *X , int length , VP8LBitEntropy *bit_entropy ,
                                  VP8LStreaks *stats ) 
{ 
  int i ;
  int i_prev ;
  uint32_t x_prev ;
  uint32_t x ;
  float __cil_tmp9 ;

  {
  {
#line 480
  i_prev = 0;
#line 481
  x_prev = *(X + 0);
#line 483
  memset((void *)stats, 0, sizeof(*stats));
#line 484
  VP8LBitEntropyInit(bit_entropy);
#line 486
  i = 1;
  }
  {
#line 486
  while (1) {
    while_continue: /* CIL Label */ ;

#line 486
    if (! (i < length)) {
#line 486
      goto while_break;
    }
#line 487
    x = *(X + i);
#line 488
    if (x != x_prev) {
      {
#line 489
      GetEntropyUnrefinedHelper(x, i, & x_prev, & i_prev, bit_entropy, stats);
      }
    }
#line 486
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 492
  GetEntropyUnrefinedHelper((uint32_t )0, i, & x_prev, & i_prev, bit_entropy, stats);
#line 494
  __cil_tmp9 = VP8LFastSLog2(bit_entropy->sum);
#line 494
  bit_entropy->entropy += (double )__cil_tmp9;
  }
#line 495
  return;
}
}
#line 497 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void GetCombinedEntropyUnrefined_C(uint32_t *X , uint32_t *Y , int length ,
                                          VP8LBitEntropy *bit_entropy , VP8LStreaks *stats ) 
{ 
  int i ;
  int i_prev ;
  uint32_t xy_prev ;
  uint32_t xy ;
  float __cil_tmp10 ;

  {
  {
#line 502
  i = 1;
#line 503
  i_prev = 0;
#line 504
  xy_prev = *(X + 0) + *(Y + 0);
#line 506
  memset((void *)stats, 0, sizeof(*stats));
#line 507
  VP8LBitEntropyInit(bit_entropy);
#line 509
  i = 1;
  }
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;

#line 509
    if (! (i < length)) {
#line 509
      goto while_break;
    }
#line 510
    xy = *(X + i) + *(Y + i);
#line 511
    if (xy != xy_prev) {
      {
#line 512
      GetEntropyUnrefinedHelper(xy, i, & xy_prev, & i_prev, bit_entropy, stats);
      }
    }
#line 509
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 515
  GetEntropyUnrefinedHelper((uint32_t )0, i, & xy_prev, & i_prev, bit_entropy, stats);
#line 517
  __cil_tmp10 = VP8LFastSLog2(bit_entropy->sum);
#line 517
  bit_entropy->entropy += (double )__cil_tmp10;
  }
#line 518
  return;
}
}
#line 522 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
void VP8LSubtractGreenFromBlueAndRed_C(uint32_t *argb_data , int num_pixels ) 
{ 
  int i ;
  int argb ;
  int green ;
  uint32_t new_r ;
  uint32_t new_b ;

  {
#line 524
  i = 0;
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;

#line 524
    if (! (i < num_pixels)) {
#line 524
      goto while_break;
    }
#line 525
    argb = (int )*(argb_data + i);
#line 526
    green = (argb >> 8) & 255;
#line 527
    new_r = (uint32_t )((((argb >> 16) & 255) - green) & 255);
#line 528
    new_b = (uint32_t )(((argb & 255) - green) & 255);
#line 529
    *(argb_data + i) = (((unsigned int )argb & 4278255360U) | (new_r << 16)) | new_b;
#line 524
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 528
  return;
}
}
#line 533 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
__inline static int ColorTransformDelta(int8_t color_pred , int8_t color ) 
{ 


  {
#line 534
  return ((int )color_pred * (int )color >> 5);
}
}
#line 537 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
__inline static int8_t U32ToS8(uint32_t v ) 
{ 


  {
#line 538
  return ((int8_t )(v & 255U));
}
}
#line 541 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
void VP8LTransformColor_C(VP8LMultipliers *m , uint32_t *data , int num_pixels ) 
{ 
  int i ;
  uint32_t argb ;
  int8_t green ;
  int8_t __cil_tmp7 ;
  int8_t red ;
  int8_t __cil_tmp9 ;
  int new_red ;
  int new_blue ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 544
  i = 0;
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;

#line 544
    if (! (i < num_pixels)) {
#line 544
      goto while_break;
    }
    {
#line 545
    argb = *(data + i);
#line 546
    __cil_tmp7 = U32ToS8(argb >> 8);
#line 546
    green = __cil_tmp7;
#line 547
    __cil_tmp9 = U32ToS8(argb >> 16);
#line 547
    red = __cil_tmp9;
#line 548
    new_red = (int )red & 255;
#line 549
    new_blue = (int )(argb & 255U);
#line 550
    __cil_tmp12 = ColorTransformDelta((int8_t )m->green_to_red_, green);
#line 550
    new_red -= __cil_tmp12;
#line 551
    new_red &= 255;
#line 552
    __cil_tmp13 = ColorTransformDelta((int8_t )m->green_to_blue_, green);
#line 552
    new_blue -= __cil_tmp13;
#line 553
    __cil_tmp14 = ColorTransformDelta((int8_t )m->red_to_blue_, red);
#line 553
    new_blue -= __cil_tmp14;
#line 554
    new_blue &= 255;
#line 555
    *(data + i) = ((argb & 4278255360U) | (unsigned int )(new_red << 16)) | (unsigned int )new_blue;
#line 544
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 548
  return;
}
}
#line 559 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
__inline static uint8_t TransformColorRed(uint8_t green_to_red , uint32_t argb ) 
{ 
  int8_t green ;
  int8_t __cil_tmp4 ;
  int new_red ;
  int __cil_tmp6 ;

  {
  {
#line 561
  __cil_tmp4 = U32ToS8(argb >> 8);
#line 561
  green = __cil_tmp4;
#line 562
  new_red = (int )(argb >> 16);
#line 563
  __cil_tmp6 = ColorTransformDelta((int8_t )green_to_red, green);
#line 563
  new_red -= __cil_tmp6;
  }
#line 564
  return ((uint8_t )(new_red & 255));
}
}
#line 567 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
__inline static uint8_t TransformColorBlue(uint8_t green_to_blue , uint8_t red_to_blue ,
                                           uint32_t argb ) 
{ 
  int8_t green ;
  int8_t __cil_tmp5 ;
  int8_t red ;
  int8_t __cil_tmp7 ;
  uint8_t new_blue ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 570
  __cil_tmp5 = U32ToS8(argb >> 8);
#line 570
  green = __cil_tmp5;
#line 571
  __cil_tmp7 = U32ToS8(argb >> 16);
#line 571
  red = __cil_tmp7;
#line 572
  new_blue = (uint8_t )(argb & 255U);
#line 573
  __cil_tmp9 = ColorTransformDelta((int8_t )green_to_blue, green);
#line 573
  new_blue = (uint8_t )((int )new_blue - __cil_tmp9);
#line 574
  __cil_tmp10 = ColorTransformDelta((int8_t )red_to_blue, red);
#line 574
  new_blue = (uint8_t )((int )new_blue - __cil_tmp10);
  }
#line 575
  return ((uint8_t )((int )new_blue & 255));
}
}
#line 578 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
void VP8LCollectColorRedTransforms_C(uint32_t *argb , int stride , int tile_width ,
                                     int tile_height , int green_to_red , int *histo ) 
{ 
  int __cil_tmp7 ;
  int x ;
  uint8_t __cil_tmp9 ;

  {
  {
#line 581
  while (1) {
    while_continue: /* CIL Label */ ;
#line 581
    __cil_tmp7 = tile_height;
#line 581
    tile_height --;
#line 581
    if (! (__cil_tmp7 > 0)) {
#line 581
      goto while_break;
    }
#line 583
    x = 0;
    {
#line 583
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 583
      if (! (x < tile_width)) {
#line 583
        goto while_break___0;
      }
      {
#line 584
      __cil_tmp9 = TransformColorRed((uint8_t )green_to_red, *(argb + x));
#line 584
      (*(histo + __cil_tmp9)) ++;
#line 583
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 586
    argb += stride;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 590
  return;
}
}
#line 590 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
void VP8LCollectColorBlueTransforms_C(uint32_t *argb , int stride , int tile_width ,
                                      int tile_height , int green_to_blue , int red_to_blue ,
                                      int *histo ) 
{ 
  int __cil_tmp8 ;
  int x ;
  uint8_t __cil_tmp10 ;

  {
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    __cil_tmp8 = tile_height;
#line 594
    tile_height --;
#line 594
    if (! (__cil_tmp8 > 0)) {
#line 594
      goto while_break;
    }
#line 596
    x = 0;
    {
#line 596
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 596
      if (! (x < tile_width)) {
#line 596
        goto while_break___0;
      }
      {
#line 597
      __cil_tmp10 = TransformColorBlue((uint8_t )green_to_blue, (uint8_t )red_to_blue,
                                       *(argb + x));
#line 597
      (*(histo + __cil_tmp10)) ++;
#line 596
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 600
    argb += stride;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 604
  return;
}
}
#line 606 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static int VectorMismatch_C(uint32_t *array1 , uint32_t *array2 , int length ) 
{ 
  int match_len ;

  {
#line 608
  match_len = 0;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;

#line 610
    if (match_len < length) {
#line 610
      if (! (*(array1 + match_len) == *(array2 + match_len))) {
#line 610
        goto while_break;
      }
    } else {
#line 610
      goto while_break;
    }
#line 611
    match_len ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 613
  return (match_len);
}
}
#line 617 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
void VP8LBundleColorMap_C(uint8_t *row , int width , int xbits , uint32_t *dst ) 
{ 
  int x ;
  int bit_depth ;
  int mask ;
  uint32_t code ;
  int xsub ;

  {
#line 620
  if (xbits > 0) {
#line 621
    bit_depth = 1 << (3 - xbits);
#line 622
    mask = (1 << xbits) - 1;
#line 623
    code = 4278190080U;
#line 624
    x = 0;
    {
#line 624
    while (1) {
      while_continue: /* CIL Label */ ;

#line 624
      if (! (x < width)) {
#line 624
        goto while_break;
      }
#line 625
      xsub = x & mask;
#line 626
      if (xsub == 0) {
#line 627
        code = 4278190080U;
      }
#line 629
      code |= (unsigned int )((int )*(row + x) << (8 + bit_depth * xsub));
#line 630
      *(dst + (x >> xbits)) = code;
#line 624
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 633
    x = 0;
    {
#line 633
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 633
      if (! (x < width)) {
#line 633
        goto while_break___0;
      }
#line 633
      *(dst + x) = 4278190080U | (unsigned int )((int )*(row + x) << 8);
#line 633
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 638
  return;
}
}
#line 639 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static double ExtraCost_C(uint32_t *population , int length ) 
{ 
  int i ;
  double cost ;

  {
#line 641
  cost = 0.;
#line 642
  i = 2;
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;

#line 642
    if (! (i < length - 2)) {
#line 642
      goto while_break;
    }
#line 642
    cost += (double )((unsigned int )(i >> 1) * *(population + (i + 2)));
#line 642
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 643
  return (cost);
}
}
#line 646 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static double ExtraCostCombined_C(uint32_t *X , uint32_t *Y , int length ) 
{ 
  int i ;
  double cost ;
  int xy ;

  {
#line 649
  cost = 0.;
#line 650
  i = 2;
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;

#line 650
    if (! (i < length - 2)) {
#line 650
      goto while_break;
    }
#line 651
    xy = (int )(*(X + (i + 2)) + *(Y + (i + 2)));
#line 652
    cost += (double )((i >> 1) * xy);
#line 650
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 654
  return (cost);
}
}
#line 659 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void AddVector_C(uint32_t *a , uint32_t *b , uint32_t *out , int size ) 
{ 
  int i ;

  {
#line 662
  i = 0;
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;

#line 662
    if (! (i < size)) {
#line 662
      goto while_break;
    }
#line 662
    *(out + i) = *(a + i) + *(b + i);
#line 662
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 666
  return;
}
}
#line 665 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void AddVectorEq_C(uint32_t *a , uint32_t *out , int size ) 
{ 
  int i ;

  {
#line 667
  i = 0;
  {
#line 667
  while (1) {
    while_continue: /* CIL Label */ ;

#line 667
    if (! (i < size)) {
#line 667
      goto while_break;
    }
#line 667
    *(out + i) += *(a + i);
#line 667
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 671
  return;
}
}
#line 694 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
void VP8LHistogramAdd(VP8LHistogram *a , VP8LHistogram *b , VP8LHistogram *out ) 
{ 
  int i ;
  int literal_size ;
  int __cil_tmp6 ;

  {
  {
#line 697
  __cil_tmp6 = VP8LHistogramNumCodes(a->palette_code_bits_);
#line 697
  literal_size = __cil_tmp6;
  }
#line 700
  if ((unsigned long )b != (unsigned long )out) {
    {
#line 701
    while (1) {
      while_continue: /* CIL Label */ ;

#line 701
      if (a->is_used_[0]) {
#line 701
        if (b->is_used_[0]) {
          {
#line 701
          (*VP8LAddVector)(a->literal_, b->literal_, out->literal_, literal_size);
          }
        } else {
          {
#line 701
          memcpy((void *)(out->literal_ + 0), (void const   *)(a->literal_ + 0), (unsigned long )literal_size * sizeof(*(out->literal_ + 0)));
          }
        }
      } else
#line 701
      if (b->is_used_[0]) {
        {
#line 701
        memcpy((void *)(out->literal_ + 0), (void const   *)(b->literal_ + 0), (unsigned long )literal_size * sizeof(*(out->literal_ + 0)));
        }
      } else {
        {
#line 701
        memset((void *)(out->literal_ + 0), 0, (unsigned long )literal_size * sizeof(*(out->literal_ + 0)));
        }
      }
#line 701
      goto while_break;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break: ;
    {
#line 702
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 702
      if (a->is_used_[1]) {
#line 702
        if (b->is_used_[1]) {
          {
#line 702
          (*VP8LAddVector)(a->red_, b->red_, out->red_, 256);
          }
        } else {
          {
#line 702
          memcpy((void *)(& out->red_[0]), (void const   *)(& a->red_[0]), 256UL * sizeof(out->red_[0]));
          }
        }
      } else
#line 702
      if (b->is_used_[1]) {
        {
#line 702
        memcpy((void *)(& out->red_[0]), (void const   *)(& b->red_[0]), 256UL * sizeof(out->red_[0]));
        }
      } else {
        {
#line 702
        memset((void *)(& out->red_[0]), 0, 256UL * sizeof(out->red_[0]));
        }
      }
#line 702
      goto while_break___0;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___0: ;
    {
#line 703
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 703
      if (a->is_used_[2]) {
#line 703
        if (b->is_used_[2]) {
          {
#line 703
          (*VP8LAddVector)(a->blue_, b->blue_, out->blue_, 256);
          }
        } else {
          {
#line 703
          memcpy((void *)(& out->blue_[0]), (void const   *)(& a->blue_[0]), 256UL * sizeof(out->blue_[0]));
          }
        }
      } else
#line 703
      if (b->is_used_[2]) {
        {
#line 703
        memcpy((void *)(& out->blue_[0]), (void const   *)(& b->blue_[0]), 256UL * sizeof(out->blue_[0]));
        }
      } else {
        {
#line 703
        memset((void *)(& out->blue_[0]), 0, 256UL * sizeof(out->blue_[0]));
        }
      }
#line 703
      goto while_break___1;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___1: ;
    {
#line 704
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 704
      if (a->is_used_[3]) {
#line 704
        if (b->is_used_[3]) {
          {
#line 704
          (*VP8LAddVector)(a->alpha_, b->alpha_, out->alpha_, 256);
          }
        } else {
          {
#line 704
          memcpy((void *)(& out->alpha_[0]), (void const   *)(& a->alpha_[0]), 256UL * sizeof(out->alpha_[0]));
          }
        }
      } else
#line 704
      if (b->is_used_[3]) {
        {
#line 704
        memcpy((void *)(& out->alpha_[0]), (void const   *)(& b->alpha_[0]), 256UL * sizeof(out->alpha_[0]));
        }
      } else {
        {
#line 704
        memset((void *)(& out->alpha_[0]), 0, 256UL * sizeof(out->alpha_[0]));
        }
      }
#line 704
      goto while_break___2;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___2: ;
    {
#line 705
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 705
      if (a->is_used_[4]) {
#line 705
        if (b->is_used_[4]) {
          {
#line 705
          (*VP8LAddVector)(a->distance_, b->distance_, out->distance_, 40);
          }
        } else {
          {
#line 705
          memcpy((void *)(& out->distance_[0]), (void const   *)(& a->distance_[0]),
                 40UL * sizeof(out->distance_[0]));
          }
        }
      } else
#line 705
      if (b->is_used_[4]) {
        {
#line 705
        memcpy((void *)(& out->distance_[0]), (void const   *)(& b->distance_[0]),
               40UL * sizeof(out->distance_[0]));
        }
      } else {
        {
#line 705
        memset((void *)(& out->distance_[0]), 0, 40UL * sizeof(out->distance_[0]));
        }
      }
#line 705
      goto while_break___3;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___3: 
#line 706
    i = 0;
    {
#line 706
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 706
      if (! (i < 5)) {
#line 706
        goto while_break___4;
      }
#line 707
      out->is_used_[i] = (uint8_t )((int )a->is_used_[i] | (int )b->is_used_[i]);
#line 706
      i ++;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___4: ;
  } else {
    {
#line 710
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 710
      if (a->is_used_[0]) {
#line 710
        if (out->is_used_[0]) {
          {
#line 710
          (*VP8LAddVectorEq)(a->literal_, out->literal_, literal_size);
          }
        } else {
          {
#line 710
          memcpy((void *)(out->literal_ + 0), (void const   *)(a->literal_ + 0), (unsigned long )literal_size * sizeof(*(out->literal_ + 0)));
          }
        }
      }
#line 710
      goto while_break___5;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___5: ;
    {
#line 711
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 711
      if (a->is_used_[1]) {
#line 711
        if (out->is_used_[1]) {
          {
#line 711
          (*VP8LAddVectorEq)(a->red_, out->red_, 256);
          }
        } else {
          {
#line 711
          memcpy((void *)(& out->red_[0]), (void const   *)(& a->red_[0]), 256UL * sizeof(out->red_[0]));
          }
        }
      }
#line 711
      goto while_break___6;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___6: ;
    {
#line 712
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 712
      if (a->is_used_[2]) {
#line 712
        if (out->is_used_[2]) {
          {
#line 712
          (*VP8LAddVectorEq)(a->blue_, out->blue_, 256);
          }
        } else {
          {
#line 712
          memcpy((void *)(& out->blue_[0]), (void const   *)(& a->blue_[0]), 256UL * sizeof(out->blue_[0]));
          }
        }
      }
#line 712
      goto while_break___7;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___7: ;
    {
#line 713
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 713
      if (a->is_used_[3]) {
#line 713
        if (out->is_used_[3]) {
          {
#line 713
          (*VP8LAddVectorEq)(a->alpha_, out->alpha_, 256);
          }
        } else {
          {
#line 713
          memcpy((void *)(& out->alpha_[0]), (void const   *)(& a->alpha_[0]), 256UL * sizeof(out->alpha_[0]));
          }
        }
      }
#line 713
      goto while_break___8;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___8: ;
    {
#line 714
    while (1) {
      while_continue___9: /* CIL Label */ ;

#line 714
      if (a->is_used_[4]) {
#line 714
        if (out->is_used_[4]) {
          {
#line 714
          (*VP8LAddVectorEq)(a->distance_, out->distance_, 40);
          }
        } else {
          {
#line 714
          memcpy((void *)(& out->distance_[0]), (void const   *)(& a->distance_[0]),
                 40UL * sizeof(out->distance_[0]));
          }
        }
      }
#line 714
      goto while_break___9;
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___9: 
#line 715
    i = 0;
    {
#line 715
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 715
      if (! (i < 5)) {
#line 715
        goto while_break___10;
      }
#line 715
      out->is_used_[i] = (uint8_t )((int )out->is_used_[i] | (int )a->is_used_[i]);
#line 715
      i ++;
    }
    while_break___22: /* CIL Label */ ;
    }
    while_break___10: ;
  }
#line 720
  return;
}
}
#line 724 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void PredictorSub0_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int i ;

  {
#line 727
  i = 0;
  {
#line 727
  while (1) {
    while_continue: /* CIL Label */ ;

#line 727
    if (! (i < num_pixels)) {
#line 727
      goto while_break;
    }
    {
#line 727
    *(out + i) = VP8LSubPixels(*(in + i), 4278190080U);
#line 727
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 731
  return;
}
}
#line 731 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void PredictorSub1_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int i ;

  {
#line 734
  i = 0;
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;

#line 734
    if (! (i < num_pixels)) {
#line 734
      goto while_break;
    }
    {
#line 734
    *(out + i) = VP8LSubPixels(*(in + i), *(in + (i - 1)));
#line 734
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 738
  return;
}
}
#line 753 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void PredictorSub2_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 753
  x = 0;
  {
#line 753
  while (1) {
    while_continue: /* CIL Label */ ;

#line 753
    if (! (x < num_pixels)) {
#line 753
      goto while_break;
    }
    {
#line 753
    __cil_tmp7 = VP8LPredictor2_C(*(in + (x - 1)), upper + x);
#line 753
    pred = __cil_tmp7;
#line 753
    *(out + x) = VP8LSubPixels(*(in + x), pred);
#line 753
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 757
  return;
}
}
#line 754 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void PredictorSub3_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 754
  x = 0;
  {
#line 754
  while (1) {
    while_continue: /* CIL Label */ ;

#line 754
    if (! (x < num_pixels)) {
#line 754
      goto while_break;
    }
    {
#line 754
    __cil_tmp7 = VP8LPredictor3_C(*(in + (x - 1)), upper + x);
#line 754
    pred = __cil_tmp7;
#line 754
    *(out + x) = VP8LSubPixels(*(in + x), pred);
#line 754
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 758
  return;
}
}
#line 755 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void PredictorSub4_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 755
  x = 0;
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;

#line 755
    if (! (x < num_pixels)) {
#line 755
      goto while_break;
    }
    {
#line 755
    __cil_tmp7 = VP8LPredictor4_C(*(in + (x - 1)), upper + x);
#line 755
    pred = __cil_tmp7;
#line 755
    *(out + x) = VP8LSubPixels(*(in + x), pred);
#line 755
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 759
  return;
}
}
#line 756 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void PredictorSub5_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 756
  x = 0;
  {
#line 756
  while (1) {
    while_continue: /* CIL Label */ ;

#line 756
    if (! (x < num_pixels)) {
#line 756
      goto while_break;
    }
    {
#line 756
    __cil_tmp7 = VP8LPredictor5_C(*(in + (x - 1)), upper + x);
#line 756
    pred = __cil_tmp7;
#line 756
    *(out + x) = VP8LSubPixels(*(in + x), pred);
#line 756
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 760
  return;
}
}
#line 757 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void PredictorSub6_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 757
  x = 0;
  {
#line 757
  while (1) {
    while_continue: /* CIL Label */ ;

#line 757
    if (! (x < num_pixels)) {
#line 757
      goto while_break;
    }
    {
#line 757
    __cil_tmp7 = VP8LPredictor6_C(*(in + (x - 1)), upper + x);
#line 757
    pred = __cil_tmp7;
#line 757
    *(out + x) = VP8LSubPixels(*(in + x), pred);
#line 757
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 761
  return;
}
}
#line 758 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void PredictorSub7_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 758
  x = 0;
  {
#line 758
  while (1) {
    while_continue: /* CIL Label */ ;

#line 758
    if (! (x < num_pixels)) {
#line 758
      goto while_break;
    }
    {
#line 758
    __cil_tmp7 = VP8LPredictor7_C(*(in + (x - 1)), upper + x);
#line 758
    pred = __cil_tmp7;
#line 758
    *(out + x) = VP8LSubPixels(*(in + x), pred);
#line 758
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 762
  return;
}
}
#line 759 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void PredictorSub8_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 759
  x = 0;
  {
#line 759
  while (1) {
    while_continue: /* CIL Label */ ;

#line 759
    if (! (x < num_pixels)) {
#line 759
      goto while_break;
    }
    {
#line 759
    __cil_tmp7 = VP8LPredictor8_C(*(in + (x - 1)), upper + x);
#line 759
    pred = __cil_tmp7;
#line 759
    *(out + x) = VP8LSubPixels(*(in + x), pred);
#line 759
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 763
  return;
}
}
#line 760 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void PredictorSub9_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 760
  x = 0;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;

#line 760
    if (! (x < num_pixels)) {
#line 760
      goto while_break;
    }
    {
#line 760
    __cil_tmp7 = VP8LPredictor9_C(*(in + (x - 1)), upper + x);
#line 760
    pred = __cil_tmp7;
#line 760
    *(out + x) = VP8LSubPixels(*(in + x), pred);
#line 760
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 764
  return;
}
}
#line 761 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void PredictorSub10_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 761
  x = 0;
  {
#line 761
  while (1) {
    while_continue: /* CIL Label */ ;

#line 761
    if (! (x < num_pixels)) {
#line 761
      goto while_break;
    }
    {
#line 761
    __cil_tmp7 = VP8LPredictor10_C(*(in + (x - 1)), upper + x);
#line 761
    pred = __cil_tmp7;
#line 761
    *(out + x) = VP8LSubPixels(*(in + x), pred);
#line 761
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 765
  return;
}
}
#line 762 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void PredictorSub11_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 762
  x = 0;
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;

#line 762
    if (! (x < num_pixels)) {
#line 762
      goto while_break;
    }
    {
#line 762
    __cil_tmp7 = VP8LPredictor11_C(*(in + (x - 1)), upper + x);
#line 762
    pred = __cil_tmp7;
#line 762
    *(out + x) = VP8LSubPixels(*(in + x), pred);
#line 762
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 766
  return;
}
}
#line 763 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void PredictorSub12_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 763
  x = 0;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;

#line 763
    if (! (x < num_pixels)) {
#line 763
      goto while_break;
    }
    {
#line 763
    __cil_tmp7 = VP8LPredictor12_C(*(in + (x - 1)), upper + x);
#line 763
    pred = __cil_tmp7;
#line 763
    *(out + x) = VP8LSubPixels(*(in + x), pred);
#line 763
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 767
  return;
}
}
#line 764 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void PredictorSub13_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 764
  x = 0;
  {
#line 764
  while (1) {
    while_continue: /* CIL Label */ ;

#line 764
    if (! (x < num_pixels)) {
#line 764
      goto while_break;
    }
    {
#line 764
    __cil_tmp7 = VP8LPredictor13_C(*(in + (x - 1)), upper + x);
#line 764
    pred = __cil_tmp7;
#line 764
    *(out + x) = VP8LSubPixels(*(in + x), pred);
#line 764
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 768
  return;
}
}
#line 794
extern void VP8LEncDspInitSSE2(void) ;
#line 795
extern void VP8LEncDspInitSSE41(void) ;
#line 801
static void VP8LEncDspInit_body(void) ;
#line 803 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static int (*VP8LEncDspInit_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 804 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static pthread_mutex_t VP8LEncDspInit_body_lock  ;
#line 801 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
void VP8LEncDspInit(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 801
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 801
    VP8LEncDspInit_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& VP8LEncDspInit_body_last_cpuinfo_used);
#line 801
    VP8LEncDspInit_body_lock.__data.__lock = 0;
#line 801
    VP8LEncDspInit_body_lock.__data.__count = 0U;
#line 801
    VP8LEncDspInit_body_lock.__data.__owner = 0;
#line 801
    VP8LEncDspInit_body_lock.__data.__nusers = 0U;
#line 801
    VP8LEncDspInit_body_lock.__data.__kind = 0;
#line 801
    VP8LEncDspInit_body_lock.__data.__spins = (short)0;
#line 801
    VP8LEncDspInit_body_lock.__data.__elision = (short)0;
#line 801
    VP8LEncDspInit_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 801
    VP8LEncDspInit_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 801
    __cil_tmp3 = pthread_mutex_lock(& VP8LEncDspInit_body_lock);
    }
#line 801
    if (__cil_tmp3) {
#line 801
      goto while_break;
    }
#line 801
    if ((unsigned long )VP8LEncDspInit_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 801
      VP8LEncDspInit_body();
      }
    }
    {
#line 801
    VP8LEncDspInit_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 801
    pthread_mutex_unlock(& VP8LEncDspInit_body_lock);
    }
#line 801
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 805
  return;
}
}
#line 801 "/root/patron-new/new_3/src/dsp/lossless_enc.c"
static void VP8LEncDspInit_body(void) 
{ 
  int __cil_tmp1 ;
  int __cil_tmp2 ;

  {
  {
#line 802
  VP8LDspInit();
#line 805
  VP8LSubtractGreenFromBlueAndRed = & VP8LSubtractGreenFromBlueAndRed_C;
#line 807
  VP8LTransformColor = (void (*)(VP8LMultipliers * const   , uint32_t * , int  ))(& VP8LTransformColor_C);
#line 810
  VP8LCollectColorBlueTransforms = & VP8LCollectColorBlueTransforms_C;
#line 811
  VP8LCollectColorRedTransforms = & VP8LCollectColorRedTransforms_C;
#line 813
  VP8LFastLog2Slow = & FastLog2Slow_C;
#line 814
  VP8LFastSLog2Slow = & FastSLog2Slow_C;
#line 816
  VP8LExtraCost = & ExtraCost_C;
#line 817
  VP8LExtraCostCombined = & ExtraCostCombined_C;
#line 818
  VP8LCombinedShannonEntropy = & CombinedShannonEntropy_C;
#line 820
  VP8LGetEntropyUnrefined = (void (*)(uint32_t * , int  , VP8LBitEntropy * const   ,
                                      VP8LStreaks * const   ))(& GetEntropyUnrefined_C);
#line 821
  VP8LGetCombinedEntropyUnrefined = (void (*)(uint32_t * , uint32_t * , int  , VP8LBitEntropy * const   ,
                                              VP8LStreaks * const   ))(& GetCombinedEntropyUnrefined_C);
#line 823
  VP8LAddVector = & AddVector_C;
#line 824
  VP8LAddVectorEq = & AddVectorEq_C;
#line 826
  VP8LVectorMismatch = (int (*)(uint32_t * const   , uint32_t * const   , int  ))(& VectorMismatch_C);
#line 827
  VP8LBundleColorMap = (void (*)(uint8_t * const   , int  , int  , uint32_t * ))(& VP8LBundleColorMap_C);
#line 829
  VP8LPredictorsSub[0] = & PredictorSub0_C;
#line 830
  VP8LPredictorsSub[1] = & PredictorSub1_C;
#line 831
  VP8LPredictorsSub[2] = & PredictorSub2_C;
#line 832
  VP8LPredictorsSub[3] = & PredictorSub3_C;
#line 833
  VP8LPredictorsSub[4] = & PredictorSub4_C;
#line 834
  VP8LPredictorsSub[5] = & PredictorSub5_C;
#line 835
  VP8LPredictorsSub[6] = & PredictorSub6_C;
#line 836
  VP8LPredictorsSub[7] = & PredictorSub7_C;
#line 837
  VP8LPredictorsSub[8] = & PredictorSub8_C;
#line 838
  VP8LPredictorsSub[9] = & PredictorSub9_C;
#line 839
  VP8LPredictorsSub[10] = & PredictorSub10_C;
#line 840
  VP8LPredictorsSub[11] = & PredictorSub11_C;
#line 841
  VP8LPredictorsSub[12] = & PredictorSub12_C;
#line 842
  VP8LPredictorsSub[13] = & PredictorSub13_C;
#line 843
  VP8LPredictorsSub[14] = & PredictorSub0_C;
#line 844
  VP8LPredictorsSub[15] = & PredictorSub0_C;
#line 846
  VP8LPredictorsSub_C[0] = & PredictorSub0_C;
#line 847
  VP8LPredictorsSub_C[1] = & PredictorSub1_C;
#line 848
  VP8LPredictorsSub_C[2] = & PredictorSub2_C;
#line 849
  VP8LPredictorsSub_C[3] = & PredictorSub3_C;
#line 850
  VP8LPredictorsSub_C[4] = & PredictorSub4_C;
#line 851
  VP8LPredictorsSub_C[5] = & PredictorSub5_C;
#line 852
  VP8LPredictorsSub_C[6] = & PredictorSub6_C;
#line 853
  VP8LPredictorsSub_C[7] = & PredictorSub7_C;
#line 854
  VP8LPredictorsSub_C[8] = & PredictorSub8_C;
#line 855
  VP8LPredictorsSub_C[9] = & PredictorSub9_C;
#line 856
  VP8LPredictorsSub_C[10] = & PredictorSub10_C;
#line 857
  VP8LPredictorsSub_C[11] = & PredictorSub11_C;
#line 858
  VP8LPredictorsSub_C[12] = & PredictorSub12_C;
#line 859
  VP8LPredictorsSub_C[13] = & PredictorSub13_C;
#line 860
  VP8LPredictorsSub_C[14] = & PredictorSub0_C;
#line 861
  VP8LPredictorsSub_C[15] = & PredictorSub0_C;
  }
#line 864
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
    {
#line 866
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 866
    if (__cil_tmp1) {
      {
#line 867
      VP8LEncDspInitSSE2();
#line 869
      __cil_tmp2 = (*VP8GetCPUInfo)((CPUFeature )3);
      }
#line 869
      if (__cil_tmp2) {
        {
#line 870
        VP8LEncDspInitSSE41();
        }
      }
    }
  }
#line 875
  return;
}
}
#line 29 "/root/patron-new/new_3/src/dsp/lossless.c"
__inline static uint32_t Average2(uint32_t a0 , uint32_t a1 ) 
{ 


  {
#line 30
  return ((((a0 ^ a1) & 4278124286U) >> 1) + (a0 & a1));
}
}
#line 33 "/root/patron-new/new_3/src/dsp/lossless.c"
__inline static uint32_t Average3(uint32_t a0 , uint32_t a1 , uint32_t a2 ) 
{ 
  uint32_t __cil_tmp4 ;
  uint32_t __cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = Average2(a0, a2);
#line 34
  __cil_tmp5 = Average2(__cil_tmp4, a1);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 37 "/root/patron-new/new_3/src/dsp/lossless.c"
__inline static uint32_t Average4(uint32_t a0 , uint32_t a1 , uint32_t a2 , uint32_t a3 ) 
{ 
  uint32_t __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  uint32_t __cil_tmp7 ;

  {
  {
#line 39
  __cil_tmp5 = Average2(a0, a1);
#line 39
  __cil_tmp6 = Average2(a2, a3);
#line 39
  __cil_tmp7 = Average2(__cil_tmp5, __cil_tmp6);
  }
#line 39
  return (__cil_tmp7);
}
}
#line 42 "/root/patron-new/new_3/src/dsp/lossless.c"
__inline static uint32_t Clip255(uint32_t a ) 
{ 


  {
#line 43
  if (a < 256U) {
#line 44
    return (a);
  }
#line 48
  return (~ a >> 24);
}
}
#line 51 "/root/patron-new/new_3/src/dsp/lossless.c"
__inline static int AddSubtractComponentFull(int a , int b , int c ) 
{ 
  uint32_t __cil_tmp4 ;

  {
  {
#line 52
  __cil_tmp4 = Clip255((uint32_t )((a + b) - c));
  }
#line 52
  return ((int )__cil_tmp4);
}
}
#line 55 "/root/patron-new/new_3/src/dsp/lossless.c"
__inline static uint32_t ClampedAddSubtractFull(uint32_t c0 , uint32_t c1 , uint32_t c2 ) 
{ 
  int a ;
  int __cil_tmp5 ;
  int r ;
  int __cil_tmp7 ;
  int g ;
  int __cil_tmp9 ;
  int b ;
  int __cil_tmp11 ;

  {
  {
#line 57
  __cil_tmp5 = AddSubtractComponentFull((int )(c0 >> 24), (int )(c1 >> 24), (int )(c2 >> 24));
#line 57
  a = __cil_tmp5;
#line 58
  __cil_tmp7 = AddSubtractComponentFull((int )((c0 >> 16) & 255U), (int )((c1 >> 16) & 255U),
                                        (int )((c2 >> 16) & 255U));
#line 58
  r = __cil_tmp7;
#line 61
  __cil_tmp9 = AddSubtractComponentFull((int )((c0 >> 8) & 255U), (int )((c1 >> 8) & 255U),
                                        (int )((c2 >> 8) & 255U));
#line 61
  g = __cil_tmp9;
#line 64
  __cil_tmp11 = AddSubtractComponentFull((int )(c0 & 255U), (int )(c1 & 255U), (int )(c2 & 255U));
#line 64
  b = __cil_tmp11;
  }
#line 65
  return (((((uint32_t )a << 24) | (unsigned int )(r << 16)) | (unsigned int )(g << 8)) | (unsigned int )b);
}
}
#line 68 "/root/patron-new/new_3/src/dsp/lossless.c"
__inline static int AddSubtractComponentHalf(int a , int b ) 
{ 
  uint32_t __cil_tmp3 ;

  {
  {
#line 69
  __cil_tmp3 = Clip255((uint32_t )(a + (a - b) / 2));
  }
#line 69
  return ((int )__cil_tmp3);
}
}
#line 72 "/root/patron-new/new_3/src/dsp/lossless.c"
__inline static uint32_t ClampedAddSubtractHalf(uint32_t c0 , uint32_t c1 , uint32_t c2 ) 
{ 
  uint32_t ave ;
  uint32_t __cil_tmp5 ;
  int a ;
  int __cil_tmp7 ;
  int r ;
  int __cil_tmp9 ;
  int g ;
  int __cil_tmp11 ;
  int b ;
  int __cil_tmp13 ;

  {
  {
#line 74
  __cil_tmp5 = Average2(c0, c1);
#line 74
  ave = __cil_tmp5;
#line 75
  __cil_tmp7 = AddSubtractComponentHalf((int )(ave >> 24), (int )(c2 >> 24));
#line 75
  a = __cil_tmp7;
#line 76
  __cil_tmp9 = AddSubtractComponentHalf((int )((ave >> 16) & 255U), (int )((c2 >> 16) & 255U));
#line 76
  r = __cil_tmp9;
#line 77
  __cil_tmp11 = AddSubtractComponentHalf((int )((ave >> 8) & 255U), (int )((c2 >> 8) & 255U));
#line 77
  g = __cil_tmp11;
#line 78
  __cil_tmp13 = AddSubtractComponentHalf((int )(ave & 255U), (int )(c2 & 255U));
#line 78
  b = __cil_tmp13;
  }
#line 79
  return (((((uint32_t )a << 24) | (unsigned int )(r << 16)) | (unsigned int )(g << 8)) | (unsigned int )b);
}
}
#line 90 "/root/patron-new/new_3/src/dsp/lossless.c"
__inline static int Sub3(int a , int b , int c ) 
{ 
  int pb ;
  int pa ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 91
  pb = b - c;
#line 92
  pa = a - c;
#line 93
  __cil_tmp7 = abs(pa);
#line 93
  __cil_tmp6 = abs(pb);
  }
#line 93
  return (__cil_tmp6 - __cil_tmp7);
}
}
#line 98 "/root/patron-new/new_3/src/dsp/lossless.c"
__inline static uint32_t Select(uint32_t a , uint32_t b , uint32_t c ) 
{ 
  int pa_minus_pb ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  uint32_t tmp ;

  {
  {
#line 99
  __cil_tmp8 = Sub3((int )(a & 255U), (int )(b & 255U), (int )(c & 255U));
#line 99
  __cil_tmp7 = Sub3((int )((a >> 8) & 255U), (int )((b >> 8) & 255U), (int )((c >> 8) & 255U));
#line 99
  __cil_tmp6 = Sub3((int )((a >> 16) & 255U), (int )((b >> 16) & 255U), (int )((c >> 16) & 255U));
#line 99
  __cil_tmp5 = Sub3((int )(a >> 24), (int )(b >> 24), (int )(c >> 24));
#line 99
  pa_minus_pb = ((__cil_tmp5 + __cil_tmp6) + __cil_tmp7) + __cil_tmp8;
  }
#line 104
  if (pa_minus_pb <= 0) {
#line 104
    tmp = a;
  } else {
#line 104
    tmp = b;
  }
#line 104
  return (tmp);
}
}
#line 110 "/root/patron-new/new_3/src/dsp/lossless.c"
uint32_t VP8LPredictor0_C(uint32_t left , uint32_t *top ) 
{ 


  {
#line 113
  return (4278190080U);
}
}
#line 115 "/root/patron-new/new_3/src/dsp/lossless.c"
uint32_t VP8LPredictor1_C(uint32_t left , uint32_t *top ) 
{ 


  {
#line 117
  return (left);
}
}
#line 119 "/root/patron-new/new_3/src/dsp/lossless.c"
uint32_t VP8LPredictor2_C(uint32_t left , uint32_t *top ) 
{ 


  {
#line 121
  return (*(top + 0));
}
}
#line 123 "/root/patron-new/new_3/src/dsp/lossless.c"
uint32_t VP8LPredictor3_C(uint32_t left , uint32_t *top ) 
{ 


  {
#line 125
  return (*(top + 1));
}
}
#line 127 "/root/patron-new/new_3/src/dsp/lossless.c"
uint32_t VP8LPredictor4_C(uint32_t left , uint32_t *top ) 
{ 


  {
#line 129
  return (*(top + -1));
}
}
#line 131 "/root/patron-new/new_3/src/dsp/lossless.c"
uint32_t VP8LPredictor5_C(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 132
  __cil_tmp4 = Average3(left, *(top + 0), *(top + 1));
#line 132
  pred = __cil_tmp4;
  }
#line 133
  return (pred);
}
}
#line 135 "/root/patron-new/new_3/src/dsp/lossless.c"
uint32_t VP8LPredictor6_C(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 136
  __cil_tmp4 = Average2(left, *(top + -1));
#line 136
  pred = __cil_tmp4;
  }
#line 137
  return (pred);
}
}
#line 139 "/root/patron-new/new_3/src/dsp/lossless.c"
uint32_t VP8LPredictor7_C(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 140
  __cil_tmp4 = Average2(left, *(top + 0));
#line 140
  pred = __cil_tmp4;
  }
#line 141
  return (pred);
}
}
#line 143 "/root/patron-new/new_3/src/dsp/lossless.c"
uint32_t VP8LPredictor8_C(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp4 = Average2(*(top + -1), *(top + 0));
#line 144
  pred = __cil_tmp4;
  }
#line 146
  return (pred);
}
}
#line 148 "/root/patron-new/new_3/src/dsp/lossless.c"
uint32_t VP8LPredictor9_C(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 149
  __cil_tmp4 = Average2(*(top + 0), *(top + 1));
#line 149
  pred = __cil_tmp4;
  }
#line 151
  return (pred);
}
}
#line 153 "/root/patron-new/new_3/src/dsp/lossless.c"
uint32_t VP8LPredictor10_C(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 154
  __cil_tmp4 = Average4(left, *(top + -1), *(top + 0), *(top + 1));
#line 154
  pred = __cil_tmp4;
  }
#line 155
  return (pred);
}
}
#line 157 "/root/patron-new/new_3/src/dsp/lossless.c"
uint32_t VP8LPredictor11_C(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 158
  __cil_tmp4 = Select(*(top + 0), left, *(top + -1));
#line 158
  pred = __cil_tmp4;
  }
#line 159
  return (pred);
}
}
#line 161 "/root/patron-new/new_3/src/dsp/lossless.c"
uint32_t VP8LPredictor12_C(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 162
  __cil_tmp4 = ClampedAddSubtractFull(left, *(top + 0), *(top + -1));
#line 162
  pred = __cil_tmp4;
  }
#line 163
  return (pred);
}
}
#line 165 "/root/patron-new/new_3/src/dsp/lossless.c"
uint32_t VP8LPredictor13_C(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 166
  __cil_tmp4 = ClampedAddSubtractHalf(left, *(top + 0), *(top + -1));
#line 166
  pred = __cil_tmp4;
  }
#line 167
  return (pred);
}
}
#line 170 "/root/patron-new/new_3/src/dsp/lossless.c"
static void PredictorAdd0_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;

  {
#line 174
  x = 0;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;

#line 174
    if (! (x < num_pixels)) {
#line 174
      goto while_break;
    }
    {
#line 174
    *(out + x) = VP8LAddPixels(*(in + x), 4278190080U);
#line 174
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 178
  return;
}
}
#line 176 "/root/patron-new/new_3/src/dsp/lossless.c"
static void PredictorAdd1_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int i ;
  uint32_t left ;

  {
#line 179
  left = *(out + -1);
#line 181
  i = 0;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;

#line 181
    if (! (i < num_pixels)) {
#line 181
      goto while_break;
    }
    {
#line 182
    *(out + i) = VP8LAddPixels(*(in + i), left);
#line 181
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 185
  return;
}
}
#line 185 "/root/patron-new/new_3/src/dsp/lossless.c"
static void PredictorAdd2_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 185
  x = 0;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;

#line 185
    if (! (x < num_pixels)) {
#line 185
      goto while_break;
    }
    {
#line 185
    __cil_tmp7 = VP8LPredictor2_C(*(out + (x - 1)), upper + x);
#line 185
    pred = __cil_tmp7;
#line 185
    *(out + x) = VP8LAddPixels(*(in + x), pred);
#line 185
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 189
  return;
}
}
#line 186 "/root/patron-new/new_3/src/dsp/lossless.c"
static void PredictorAdd3_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 186
  x = 0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;

#line 186
    if (! (x < num_pixels)) {
#line 186
      goto while_break;
    }
    {
#line 186
    __cil_tmp7 = VP8LPredictor3_C(*(out + (x - 1)), upper + x);
#line 186
    pred = __cil_tmp7;
#line 186
    *(out + x) = VP8LAddPixels(*(in + x), pred);
#line 186
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 190
  return;
}
}
#line 187 "/root/patron-new/new_3/src/dsp/lossless.c"
static void PredictorAdd4_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 187
  x = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;

#line 187
    if (! (x < num_pixels)) {
#line 187
      goto while_break;
    }
    {
#line 187
    __cil_tmp7 = VP8LPredictor4_C(*(out + (x - 1)), upper + x);
#line 187
    pred = __cil_tmp7;
#line 187
    *(out + x) = VP8LAddPixels(*(in + x), pred);
#line 187
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 191
  return;
}
}
#line 188 "/root/patron-new/new_3/src/dsp/lossless.c"
static void PredictorAdd5_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 188
  x = 0;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;

#line 188
    if (! (x < num_pixels)) {
#line 188
      goto while_break;
    }
    {
#line 188
    __cil_tmp7 = VP8LPredictor5_C(*(out + (x - 1)), upper + x);
#line 188
    pred = __cil_tmp7;
#line 188
    *(out + x) = VP8LAddPixels(*(in + x), pred);
#line 188
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 192
  return;
}
}
#line 189 "/root/patron-new/new_3/src/dsp/lossless.c"
static void PredictorAdd6_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 189
  x = 0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;

#line 189
    if (! (x < num_pixels)) {
#line 189
      goto while_break;
    }
    {
#line 189
    __cil_tmp7 = VP8LPredictor6_C(*(out + (x - 1)), upper + x);
#line 189
    pred = __cil_tmp7;
#line 189
    *(out + x) = VP8LAddPixels(*(in + x), pred);
#line 189
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 193
  return;
}
}
#line 190 "/root/patron-new/new_3/src/dsp/lossless.c"
static void PredictorAdd7_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 190
  x = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;

#line 190
    if (! (x < num_pixels)) {
#line 190
      goto while_break;
    }
    {
#line 190
    __cil_tmp7 = VP8LPredictor7_C(*(out + (x - 1)), upper + x);
#line 190
    pred = __cil_tmp7;
#line 190
    *(out + x) = VP8LAddPixels(*(in + x), pred);
#line 190
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 194
  return;
}
}
#line 191 "/root/patron-new/new_3/src/dsp/lossless.c"
static void PredictorAdd8_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 191
  x = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;

#line 191
    if (! (x < num_pixels)) {
#line 191
      goto while_break;
    }
    {
#line 191
    __cil_tmp7 = VP8LPredictor8_C(*(out + (x - 1)), upper + x);
#line 191
    pred = __cil_tmp7;
#line 191
    *(out + x) = VP8LAddPixels(*(in + x), pred);
#line 191
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 195
  return;
}
}
#line 192 "/root/patron-new/new_3/src/dsp/lossless.c"
static void PredictorAdd9_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 192
  x = 0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;

#line 192
    if (! (x < num_pixels)) {
#line 192
      goto while_break;
    }
    {
#line 192
    __cil_tmp7 = VP8LPredictor9_C(*(out + (x - 1)), upper + x);
#line 192
    pred = __cil_tmp7;
#line 192
    *(out + x) = VP8LAddPixels(*(in + x), pred);
#line 192
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 196
  return;
}
}
#line 193 "/root/patron-new/new_3/src/dsp/lossless.c"
static void PredictorAdd10_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 193
  x = 0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;

#line 193
    if (! (x < num_pixels)) {
#line 193
      goto while_break;
    }
    {
#line 193
    __cil_tmp7 = VP8LPredictor10_C(*(out + (x - 1)), upper + x);
#line 193
    pred = __cil_tmp7;
#line 193
    *(out + x) = VP8LAddPixels(*(in + x), pred);
#line 193
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 197
  return;
}
}
#line 194 "/root/patron-new/new_3/src/dsp/lossless.c"
static void PredictorAdd11_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 194
  x = 0;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;

#line 194
    if (! (x < num_pixels)) {
#line 194
      goto while_break;
    }
    {
#line 194
    __cil_tmp7 = VP8LPredictor11_C(*(out + (x - 1)), upper + x);
#line 194
    pred = __cil_tmp7;
#line 194
    *(out + x) = VP8LAddPixels(*(in + x), pred);
#line 194
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 198
  return;
}
}
#line 195 "/root/patron-new/new_3/src/dsp/lossless.c"
static void PredictorAdd12_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 195
  x = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;

#line 195
    if (! (x < num_pixels)) {
#line 195
      goto while_break;
    }
    {
#line 195
    __cil_tmp7 = VP8LPredictor12_C(*(out + (x - 1)), upper + x);
#line 195
    pred = __cil_tmp7;
#line 195
    *(out + x) = VP8LAddPixels(*(in + x), pred);
#line 195
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 199
  return;
}
}
#line 196 "/root/patron-new/new_3/src/dsp/lossless.c"
static void PredictorAdd13_C(uint32_t *in , uint32_t *upper , int num_pixels , uint32_t *out ) 
{ 
  int x ;
  uint32_t pred ;
  uint32_t __cil_tmp7 ;

  {
#line 196
  x = 0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;

#line 196
    if (! (x < num_pixels)) {
#line 196
      goto while_break;
    }
    {
#line 196
    __cil_tmp7 = VP8LPredictor13_C(*(out + (x - 1)), upper + x);
#line 196
    pred = __cil_tmp7;
#line 196
    *(out + x) = VP8LAddPixels(*(in + x), pred);
#line 196
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 200
  return;
}
}
#line 201 "/root/patron-new/new_3/src/dsp/lossless.c"
static void PredictorInverseTransform_C(VP8LTransform *transform , int y_start , int y_end ,
                                        uint32_t *in , uint32_t *out ) 
{ 
  int width ;
  int y ;
  int tile_width ;
  int mask ;
  int tiles_per_row ;
  uint32_t __cil_tmp11 ;
  uint32_t *pred_mode_base ;
  uint32_t *pred_mode_src ;
  int x ;
  void (*pred_func)(uint32_t * , uint32_t * , int  , uint32_t * ) ;
  uint32_t *__cil_tmp16 ;
  int x_end ;

  {
#line 204
  width = transform->xsize_;
#line 205
  if (y_start == 0) {
    {
#line 206
    PredictorAdd0_C(in, (uint32_t *)((void *)0), 1, out);
#line 207
    PredictorAdd1_C(in + 1, (uint32_t *)((void *)0), width - 1, out + 1);
#line 208
    in += width;
#line 209
    out += width;
#line 210
    y_start ++;
    }
  }
  {
#line 214
  y = y_start;
#line 215
  tile_width = 1 << transform->bits_;
#line 216
  mask = tile_width - 1;
#line 217
  __cil_tmp11 = VP8LSubSampleSize((uint32_t )width, (uint32_t )transform->bits_);
#line 217
  tiles_per_row = (int )__cil_tmp11;
#line 218
  pred_mode_base = transform->data_ + (y >> transform->bits_) * tiles_per_row;
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;

#line 221
    if (! (y < y_end)) {
#line 221
      goto while_break;
    }
    {
#line 222
    pred_mode_src = pred_mode_base;
#line 223
    x = 1;
#line 225
    PredictorAdd2_C(in, out - width, 1, out);
    }
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 227
      if (! (x < width)) {
#line 227
        goto while_break___0;
      }
#line 228
      __cil_tmp16 = pred_mode_src;
#line 228
      pred_mode_src ++;
#line 228
      pred_func = VP8LPredictorsAdd[(*__cil_tmp16 >> 8) & 15U];
#line 230
      x_end = (x & ~ mask) + tile_width;
#line 231
      if (x_end > width) {
#line 231
        x_end = width;
      }
      {
#line 232
      (*pred_func)(in + x, (out + x) - width, x_end - x, out + x);
#line 233
      x = x_end;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 235
    in += width;
#line 236
    out += width;
#line 237
    y ++;
#line 238
    if ((y & mask) == 0) {
#line 239
      pred_mode_base += tiles_per_row;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 244
  return;
}
}
#line 247 "/root/patron-new/new_3/src/dsp/lossless.c"
void VP8LAddGreenToBlueAndRed_C(uint32_t *src , int num_pixels , uint32_t *dst ) 
{ 
  int i ;
  uint32_t argb ;
  uint32_t green ;
  uint32_t red_blue ;

  {
#line 250
  i = 0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;

#line 250
    if (! (i < num_pixels)) {
#line 250
      goto while_break;
    }
#line 251
    argb = *(src + i);
#line 252
    green = (argb >> 8) & 255U;
#line 253
    red_blue = argb & 16711935U;
#line 254
    red_blue += (green << 16) | green;
#line 255
    red_blue &= 16711935U;
#line 256
    *(dst + i) = (argb & 4278255360U) | red_blue;
#line 250
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 254
  return;
}
}
#line 272 "/root/patron-new/new_3/src/dsp/lossless.c"
void VP8LTransformColorInverse_C(VP8LMultipliers *m , uint32_t *src , int num_pixels ,
                                 uint32_t *dst ) 
{ 
  int i ;
  uint32_t argb ;
  int8_t green ;
  uint32_t red ;
  int new_red ;
  int new_blue ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 276
  i = 0;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;

#line 276
    if (! (i < num_pixels)) {
#line 276
      goto while_break;
    }
    {
#line 277
    argb = *(src + i);
#line 278
    green = (int8_t )(argb >> 8);
#line 279
    red = argb >> 16;
#line 280
    new_red = (int )(red & 255U);
#line 281
    new_blue = (int )(argb & 255U);
#line 282
    __cil_tmp11 = ColorTransformDelta((int8_t )m->green_to_red_, green);
#line 282
    new_red += __cil_tmp11;
#line 283
    new_red &= 255;
#line 284
    __cil_tmp12 = ColorTransformDelta((int8_t )m->green_to_blue_, green);
#line 284
    new_blue += __cil_tmp12;
#line 285
    __cil_tmp13 = ColorTransformDelta((int8_t )m->red_to_blue_, (int8_t )new_red);
#line 285
    new_blue += __cil_tmp13;
#line 286
    new_blue &= 255;
#line 287
    *(dst + i) = ((argb & 4278255360U) | (unsigned int )(new_red << 16)) | (unsigned int )new_blue;
#line 276
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 280
  return;
}
}
#line 292 "/root/patron-new/new_3/src/dsp/lossless.c"
static void ColorSpaceInverseTransform_C(VP8LTransform *transform , int y_start ,
                                         int y_end , uint32_t *src , uint32_t *dst ) 
{ 
  int width ;
  int tile_width ;
  int mask ;
  int safe_width ;
  int remaining_width ;
  int tiles_per_row ;
  uint32_t __cil_tmp12 ;
  int y ;
  uint32_t *pred_row ;
  uint32_t *pred ;
  VP8LMultipliers m ;
  uint32_t *src_safe_end ;
  uint32_t *src_end ;
  uint32_t *__cil_tmp19 ;
  uint32_t *__cil_tmp20 ;

  {
  {
#line 295
  width = transform->xsize_;
#line 296
  tile_width = 1 << transform->bits_;
#line 297
  mask = tile_width - 1;
#line 298
  safe_width = width & ~ mask;
#line 299
  remaining_width = width - safe_width;
#line 300
  __cil_tmp12 = VP8LSubSampleSize((uint32_t )width, (uint32_t )transform->bits_);
#line 300
  tiles_per_row = (int )__cil_tmp12;
#line 301
  y = y_start;
#line 302
  pred_row = transform->data_ + (y >> transform->bits_) * tiles_per_row;
  }
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;

#line 305
    if (! (y < y_end)) {
#line 305
      goto while_break;
    }
#line 306
    pred = pred_row;
#line 307
    m.green_to_red_ = (uint8_t )0;
#line 307
    m.green_to_blue_ = (uint8_t )0;
#line 307
    m.red_to_blue_ = (uint8_t )0;
#line 308
    src_safe_end = src + safe_width;
#line 309
    src_end = src + width;
    {
#line 310
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 310
      if (! ((unsigned long )src < (unsigned long )src_safe_end)) {
#line 310
        goto while_break___0;
      }
      {
#line 311
      __cil_tmp19 = pred;
#line 311
      pred ++;
#line 311
      ColorCodeToMultipliers(*__cil_tmp19, & m);
#line 312
      (*VP8LTransformColorInverse)((VP8LMultipliers */* const  */)(& m), src, tile_width,
                                   dst);
#line 313
      src += tile_width;
#line 314
      dst += tile_width;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 316
    if ((unsigned long )src < (unsigned long )src_end) {
      {
#line 317
      __cil_tmp20 = pred;
#line 317
      pred ++;
#line 317
      ColorCodeToMultipliers(*__cil_tmp20, & m);
#line 318
      (*VP8LTransformColorInverse)((VP8LMultipliers */* const  */)(& m), src, remaining_width,
                                   dst);
#line 319
      src += remaining_width;
#line 320
      dst += remaining_width;
      }
    }
#line 322
    y ++;
#line 323
    if ((y & mask) == 0) {
#line 323
      pred_row += tiles_per_row;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 328
  return;
}
}
#line 370 "/root/patron-new/new_3/src/dsp/lossless.c"
static void MapARGB_C(uint32_t *src , uint32_t *color_map , uint32_t *dst , int y_start ,
                      int y_end , int width ) 
{ 
  int y ;
  int x ;
  uint32_t *__cil_tmp9 ;
  uint32_t *__cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  uint32_t __cil_tmp12 ;

  {
#line 370
  y = y_start;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;

#line 370
    if (! (y < y_end)) {
#line 370
      goto while_break;
    }
#line 370
    x = 0;
    {
#line 370
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 370
      if (! (x < width)) {
#line 370
        goto while_break___0;
      }
      {
#line 370
      __cil_tmp10 = src;
#line 370
      src ++;
#line 370
      __cil_tmp11 = VP8GetARGBIndex(*__cil_tmp10);
#line 370
      __cil_tmp12 = VP8GetARGBValue(*(color_map + __cil_tmp11));
#line 370
      __cil_tmp9 = dst;
#line 370
      dst ++;
#line 370
      *__cil_tmp9 = __cil_tmp12;
#line 370
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 370
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 374
  return;
}
}
#line 370 "/root/patron-new/new_3/src/dsp/lossless.c"
static void ColorIndexInverseTransform_C(VP8LTransform *transform , int y_start ,
                                         int y_end , uint32_t *src , uint32_t *dst ) 
{ 
  int y ;
  int bits_per_pixel ;
  int width ;
  uint32_t *color_map ;
  int pixels_per_byte ;
  int count_mask ;
  uint32_t bit_mask ;
  uint32_t packed_pixels ;
  int x ;
  uint32_t *__cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  uint32_t *__cil_tmp17 ;

  {
#line 370
  bits_per_pixel = 8 >> transform->bits_;
#line 370
  width = transform->xsize_;
#line 370
  color_map = transform->data_;
#line 370
  if (bits_per_pixel < 8) {
#line 370
    pixels_per_byte = 1 << transform->bits_;
#line 370
    count_mask = pixels_per_byte - 1;
#line 370
    bit_mask = (uint32_t )((1 << bits_per_pixel) - 1);
#line 370
    y = y_start;
    {
#line 370
    while (1) {
      while_continue: /* CIL Label */ ;

#line 370
      if (! (y < y_end)) {
#line 370
        goto while_break;
      }
#line 370
      packed_pixels = (uint32_t )0;
#line 370
      x = 0;
      {
#line 370
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 370
        if (! (x < width)) {
#line 370
          goto while_break___0;
        }
#line 370
        if ((x & count_mask) == 0) {
          {
#line 370
          __cil_tmp15 = src;
#line 370
          src ++;
#line 370
          __cil_tmp16 = VP8GetARGBIndex(*__cil_tmp15);
#line 370
          packed_pixels = __cil_tmp16;
          }
        }
        {
#line 370
        __cil_tmp17 = dst;
#line 370
        dst ++;
#line 370
        *__cil_tmp17 = VP8GetARGBValue(*(color_map + (packed_pixels & bit_mask)));
#line 370
        packed_pixels >>= bits_per_pixel;
#line 370
        x ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 370
      y ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 370
    (*VP8LMapColor32b)(src, (uint32_t */* const  */)color_map, dst, y_start, y_end,
                       width);
    }
  }
#line 373
  return;
}
}
#line 372 "/root/patron-new/new_3/src/dsp/lossless.c"
static void MapAlpha_C(uint8_t *src , uint32_t *color_map , uint8_t *dst , int y_start ,
                       int y_end , int width ) 
{ 
  int y ;
  int x ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;
  uint8_t __cil_tmp11 ;
  uint8_t __cil_tmp12 ;

  {
#line 372
  y = y_start;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;

#line 372
    if (! (y < y_end)) {
#line 372
      goto while_break;
    }
#line 372
    x = 0;
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 372
      if (! (x < width)) {
#line 372
        goto while_break___0;
      }
      {
#line 372
      __cil_tmp10 = src;
#line 372
      src ++;
#line 372
      __cil_tmp11 = VP8GetAlphaIndex(*__cil_tmp10);
#line 372
      __cil_tmp12 = VP8GetAlphaValue(*(color_map + (int )__cil_tmp11));
#line 372
      __cil_tmp9 = dst;
#line 372
      dst ++;
#line 372
      *__cil_tmp9 = __cil_tmp12;
#line 372
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 372
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 376
  return;
}
}
#line 372 "/root/patron-new/new_3/src/dsp/lossless.c"
void VP8LColorIndexInverseTransformAlpha(VP8LTransform *transform , int y_start ,
                                         int y_end , uint8_t *src , uint8_t *dst ) 
{ 
  int y ;
  int bits_per_pixel ;
  int width ;
  uint32_t *color_map ;
  int pixels_per_byte ;
  int count_mask ;
  uint32_t bit_mask ;
  uint32_t packed_pixels ;
  int x ;
  uint8_t *__cil_tmp15 ;
  uint8_t __cil_tmp16 ;
  uint8_t *__cil_tmp17 ;

  {
#line 372
  bits_per_pixel = 8 >> transform->bits_;
#line 372
  width = transform->xsize_;
#line 372
  color_map = transform->data_;
#line 372
  if (bits_per_pixel < 8) {
#line 372
    pixels_per_byte = 1 << transform->bits_;
#line 372
    count_mask = pixels_per_byte - 1;
#line 372
    bit_mask = (uint32_t )((1 << bits_per_pixel) - 1);
#line 372
    y = y_start;
    {
#line 372
    while (1) {
      while_continue: /* CIL Label */ ;

#line 372
      if (! (y < y_end)) {
#line 372
        goto while_break;
      }
#line 372
      packed_pixels = (uint32_t )0;
#line 372
      x = 0;
      {
#line 372
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 372
        if (! (x < width)) {
#line 372
          goto while_break___0;
        }
#line 372
        if ((x & count_mask) == 0) {
          {
#line 372
          __cil_tmp15 = src;
#line 372
          src ++;
#line 372
          __cil_tmp16 = VP8GetAlphaIndex(*__cil_tmp15);
#line 372
          packed_pixels = (uint32_t )__cil_tmp16;
          }
        }
        {
#line 372
        __cil_tmp17 = dst;
#line 372
        dst ++;
#line 372
        *__cil_tmp17 = VP8GetAlphaValue(*(color_map + (packed_pixels & bit_mask)));
#line 372
        packed_pixels >>= bits_per_pixel;
#line 372
        x ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 372
      y ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 372
    (*VP8LMapColor8b)(src, (uint32_t */* const  */)color_map, dst, y_start, y_end,
                      width);
    }
  }
#line 375
  return;
}
}
#line 377 "/root/patron-new/new_3/src/dsp/lossless.c"
void VP8LInverseTransform(VP8LTransform *transform , int row_start , int row_end ,
                          uint32_t *in , uint32_t *out ) 
{ 
  int width ;
  int out_stride ;
  int in_stride ;
  uint32_t __cil_tmp9 ;
  uint32_t *src ;

  {
#line 380
  width = transform->xsize_;
#line 384
  if ((unsigned int )transform->type_ == 2U) {
#line 384
    goto case_2;
  }
#line 387
  if ((unsigned int )transform->type_ == 0U) {
#line 387
    goto case_0;
  }
#line 396
  if ((unsigned int )transform->type_ == 1U) {
#line 396
    goto case_1;
  }
#line 399
  if ((unsigned int )transform->type_ == 3U) {
#line 399
    goto case_3;
  }
#line 383
  goto switch_break;
  case_2: 
  {
#line 385
  (*VP8LAddGreenToBlueAndRed)(in, (row_end - row_start) * width, out);
  }
#line 386
  goto switch_break;
  case_0: 
  {
#line 388
  PredictorInverseTransform_C(transform, row_start, row_end, in, out);
  }
#line 389
  if (row_end != transform->ysize_) {
    {
#line 392
    memcpy((void *)(out - width), (void const   *)(out + ((row_end - row_start) - 1) * width),
           (unsigned long )width * sizeof(*out));
    }
  }
#line 395
  goto switch_break;
  case_1: 
  {
#line 397
  ColorSpaceInverseTransform_C(transform, row_start, row_end, in, out);
  }
#line 398
  goto switch_break;
  case_3: 
#line 400
  if ((unsigned long )in == (unsigned long )out) {
#line 400
    if (transform->bits_ > 0) {
      {
#line 406
      out_stride = (row_end - row_start) * width;
#line 407
      __cil_tmp9 = VP8LSubSampleSize((uint32_t )transform->xsize_, (uint32_t )transform->bits_);
#line 407
      in_stride = (int )((unsigned int )(row_end - row_start) * __cil_tmp9);
#line 409
      src = (out + out_stride) - in_stride;
#line 410
      memmove((void *)src, (void const   *)out, (unsigned long )in_stride * sizeof(*src));
#line 411
      ColorIndexInverseTransform_C(transform, row_start, row_end, src, out);
      }
    } else {
      {
#line 413
      ColorIndexInverseTransform_C(transform, row_start, row_end, in, out);
      }
    }
  } else {
    {
#line 413
    ColorIndexInverseTransform_C(transform, row_start, row_end, in, out);
    }
  }
#line 415
  goto switch_break;
  switch_break: ;
#line 418
  return;
}
}
#line 424 "/root/patron-new/new_3/src/dsp/lossless.c"
static union __anonunion_921 tmp  ;
#line 422 "/root/patron-new/new_3/src/dsp/lossless.c"
static int is_big_endian(void) 
{ 


  {
#line 423
  tmp.w = (uint16_t )1;
#line 427
  return ((int )tmp.b[0] != 1);
}
}
#line 430 "/root/patron-new/new_3/src/dsp/lossless.c"
void VP8LConvertBGRAToRGB_C(uint32_t *src , int num_pixels , uint8_t *dst ) 
{ 
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp6 ;
  uint8_t *__cil_tmp7 ;
  uint8_t *__cil_tmp8 ;
  uint8_t *__cil_tmp9 ;

  {
#line 432
  src_end = src + num_pixels;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;

#line 433
    if (! ((unsigned long )src < (unsigned long )src_end)) {
#line 433
      goto while_break;
    }
#line 434
    __cil_tmp6 = src;
#line 434
    src ++;
#line 434
    argb = *__cil_tmp6;
#line 435
    __cil_tmp7 = dst;
#line 435
    dst ++;
#line 435
    *__cil_tmp7 = (uint8_t )((argb >> 16) & 255U);
#line 436
    __cil_tmp8 = dst;
#line 436
    dst ++;
#line 436
    *__cil_tmp8 = (uint8_t )((argb >> 8) & 255U);
#line 437
    __cil_tmp9 = dst;
#line 437
    dst ++;
#line 437
    *__cil_tmp9 = (uint8_t )(argb & 255U);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 441
  return;
}
}
#line 441 "/root/patron-new/new_3/src/dsp/lossless.c"
void VP8LConvertBGRAToRGBA_C(uint32_t *src , int num_pixels , uint8_t *dst ) 
{ 
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp6 ;
  uint8_t *__cil_tmp7 ;
  uint8_t *__cil_tmp8 ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 443
  src_end = src + num_pixels;
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;

#line 444
    if (! ((unsigned long )src < (unsigned long )src_end)) {
#line 444
      goto while_break;
    }
#line 445
    __cil_tmp6 = src;
#line 445
    src ++;
#line 445
    argb = *__cil_tmp6;
#line 446
    __cil_tmp7 = dst;
#line 446
    dst ++;
#line 446
    *__cil_tmp7 = (uint8_t )((argb >> 16) & 255U);
#line 447
    __cil_tmp8 = dst;
#line 447
    dst ++;
#line 447
    *__cil_tmp8 = (uint8_t )((argb >> 8) & 255U);
#line 448
    __cil_tmp9 = dst;
#line 448
    dst ++;
#line 448
    *__cil_tmp9 = (uint8_t )(argb & 255U);
#line 449
    __cil_tmp10 = dst;
#line 449
    dst ++;
#line 449
    *__cil_tmp10 = (uint8_t )((argb >> 24) & 255U);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 453
  return;
}
}
#line 453 "/root/patron-new/new_3/src/dsp/lossless.c"
void VP8LConvertBGRAToRGBA4444_C(uint32_t *src , int num_pixels , uint8_t *dst ) 
{ 
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp6 ;
  uint8_t rg ;
  uint8_t ba ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 455
  src_end = src + num_pixels;
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;

#line 456
    if (! ((unsigned long )src < (unsigned long )src_end)) {
#line 456
      goto while_break;
    }
#line 457
    __cil_tmp6 = src;
#line 457
    src ++;
#line 457
    argb = *__cil_tmp6;
#line 458
    rg = (uint8_t )(((argb >> 16) & 240U) | ((argb >> 12) & 15U));
#line 459
    ba = (uint8_t )((argb & 240U) | ((argb >> 28) & 15U));
#line 464
    __cil_tmp9 = dst;
#line 464
    dst ++;
#line 464
    *__cil_tmp9 = rg;
#line 465
    __cil_tmp10 = dst;
#line 465
    dst ++;
#line 465
    *__cil_tmp10 = ba;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 469
  return;
}
}
#line 470 "/root/patron-new/new_3/src/dsp/lossless.c"
void VP8LConvertBGRAToRGB565_C(uint32_t *src , int num_pixels , uint8_t *dst ) 
{ 
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp6 ;
  uint8_t rg ;
  uint8_t gb ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 472
  src_end = src + num_pixels;
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;

#line 473
    if (! ((unsigned long )src < (unsigned long )src_end)) {
#line 473
      goto while_break;
    }
#line 474
    __cil_tmp6 = src;
#line 474
    src ++;
#line 474
    argb = *__cil_tmp6;
#line 475
    rg = (uint8_t )(((argb >> 16) & 248U) | ((argb >> 13) & 7U));
#line 476
    gb = (uint8_t )(((argb >> 5) & 224U) | ((argb >> 3) & 31U));
#line 481
    __cil_tmp9 = dst;
#line 481
    dst ++;
#line 481
    *__cil_tmp9 = rg;
#line 482
    __cil_tmp10 = dst;
#line 482
    dst ++;
#line 482
    *__cil_tmp10 = gb;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 486
  return;
}
}
#line 487 "/root/patron-new/new_3/src/dsp/lossless.c"
void VP8LConvertBGRAToBGR_C(uint32_t *src , int num_pixels , uint8_t *dst ) 
{ 
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp6 ;
  uint8_t *__cil_tmp7 ;
  uint8_t *__cil_tmp8 ;
  uint8_t *__cil_tmp9 ;

  {
#line 489
  src_end = src + num_pixels;
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;

#line 490
    if (! ((unsigned long )src < (unsigned long )src_end)) {
#line 490
      goto while_break;
    }
#line 491
    __cil_tmp6 = src;
#line 491
    src ++;
#line 491
    argb = *__cil_tmp6;
#line 492
    __cil_tmp7 = dst;
#line 492
    dst ++;
#line 492
    *__cil_tmp7 = (uint8_t )(argb & 255U);
#line 493
    __cil_tmp8 = dst;
#line 493
    dst ++;
#line 493
    *__cil_tmp8 = (uint8_t )((argb >> 8) & 255U);
#line 494
    __cil_tmp9 = dst;
#line 494
    dst ++;
#line 494
    *__cil_tmp9 = (uint8_t )((argb >> 16) & 255U);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 498
  return;
}
}
#line 498 "/root/patron-new/new_3/src/dsp/lossless.c"
static void CopyOrSwap(uint32_t *src , int num_pixels , uint8_t *dst , int swap_on_big_endian ) 
{ 
  int __cil_tmp5 ;
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp8 ;
  uint32_t __cil_tmp9 ;

  {
  {
#line 500
  __cil_tmp5 = is_big_endian();
  }
#line 500
  if (__cil_tmp5 == swap_on_big_endian) {
#line 501
    src_end = src + num_pixels;
    {
#line 502
    while (1) {
      while_continue: /* CIL Label */ ;

#line 502
      if (! ((unsigned long )src < (unsigned long )src_end)) {
#line 502
        goto while_break;
      }
      {
#line 503
      __cil_tmp8 = src;
#line 503
      src ++;
#line 503
      argb = *__cil_tmp8;
#line 504
      __cil_tmp9 = BSwap32(argb);
#line 504
      WebPUint32ToMem(dst, __cil_tmp9);
#line 505
      dst += sizeof(argb);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 508
    memcpy((void *)dst, (void const   *)src, (unsigned long )num_pixels * sizeof(*src));
    }
  }
#line 511
  return;
}
}
#line 512 "/root/patron-new/new_3/src/dsp/lossless.c"
void VP8LConvertFromBGRA(uint32_t *in_data , int num_pixels , WEBP_CSP_MODE out_colorspace ,
                         uint8_t *rgba ) 
{ 


  {
#line 515
  if ((unsigned int )out_colorspace == 0U) {
#line 515
    goto case_0;
  }
#line 518
  if ((unsigned int )out_colorspace == 1U) {
#line 518
    goto case_1;
  }
#line 521
  if ((unsigned int )out_colorspace == 7U) {
#line 521
    goto case_7;
  }
#line 525
  if ((unsigned int )out_colorspace == 2U) {
#line 525
    goto case_2;
  }
#line 528
  if ((unsigned int )out_colorspace == 3U) {
#line 528
    goto case_3;
  }
#line 531
  if ((unsigned int )out_colorspace == 8U) {
#line 531
    goto case_8;
  }
#line 535
  if ((unsigned int )out_colorspace == 4U) {
#line 535
    goto case_4;
  }
#line 538
  if ((unsigned int )out_colorspace == 9U) {
#line 538
    goto case_9;
  }
#line 542
  if ((unsigned int )out_colorspace == 5U) {
#line 542
    goto case_5;
  }
#line 545
  if ((unsigned int )out_colorspace == 10U) {
#line 545
    goto case_10;
  }
#line 549
  if ((unsigned int )out_colorspace == 6U) {
#line 549
    goto case_6;
  }
#line 514
  goto switch_break;
  case_0: 
  {
#line 516
  (*VP8LConvertBGRAToRGB)(in_data, num_pixels, rgba);
  }
#line 517
  goto switch_break;
  case_1: 
  {
#line 519
  (*VP8LConvertBGRAToRGBA)(in_data, num_pixels, rgba);
  }
#line 520
  goto switch_break;
  case_7: 
  {
#line 522
  (*VP8LConvertBGRAToRGBA)(in_data, num_pixels, rgba);
#line 523
  (*WebPApplyAlphaMultiply)(rgba, 0, num_pixels, 1, 0);
  }
#line 524
  goto switch_break;
  case_2: 
  {
#line 526
  (*VP8LConvertBGRAToBGR)(in_data, num_pixels, rgba);
  }
#line 527
  goto switch_break;
  case_3: 
  {
#line 529
  CopyOrSwap(in_data, num_pixels, rgba, 1);
  }
#line 530
  goto switch_break;
  case_8: 
  {
#line 532
  CopyOrSwap(in_data, num_pixels, rgba, 1);
#line 533
  (*WebPApplyAlphaMultiply)(rgba, 0, num_pixels, 1, 0);
  }
#line 534
  goto switch_break;
  case_4: 
  {
#line 536
  CopyOrSwap(in_data, num_pixels, rgba, 0);
  }
#line 537
  goto switch_break;
  case_9: 
  {
#line 539
  CopyOrSwap(in_data, num_pixels, rgba, 0);
#line 540
  (*WebPApplyAlphaMultiply)(rgba, 1, num_pixels, 1, 0);
  }
#line 541
  goto switch_break;
  case_5: 
  {
#line 543
  (*VP8LConvertBGRAToRGBA4444)(in_data, num_pixels, rgba);
  }
#line 544
  goto switch_break;
  case_10: 
  {
#line 546
  (*VP8LConvertBGRAToRGBA4444)(in_data, num_pixels, rgba);
#line 547
  (*WebPApplyAlphaMultiply4444)(rgba, num_pixels, 1, 0);
  }
#line 548
  goto switch_break;
  case_6: 
  {
#line 550
  (*VP8LConvertBGRAToRGB565)(in_data, num_pixels, rgba);
  }
#line 551
  goto switch_break;
  switch_break: ;
#line 554
  return;
}
}
#line 577
extern void VP8LDspInitSSE2(void) ;
#line 578
extern void VP8LDspInitSSE41(void) ;
#line 602
static void VP8LDspInit_body(void) ;
#line 604 "/root/patron-new/new_3/src/dsp/lossless.c"
static int (*VP8LDspInit_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 605 "/root/patron-new/new_3/src/dsp/lossless.c"
static pthread_mutex_t VP8LDspInit_body_lock  ;
#line 602 "/root/patron-new/new_3/src/dsp/lossless.c"
void VP8LDspInit(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 602
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 602
    VP8LDspInit_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& VP8LDspInit_body_last_cpuinfo_used);
#line 602
    VP8LDspInit_body_lock.__data.__lock = 0;
#line 602
    VP8LDspInit_body_lock.__data.__count = 0U;
#line 602
    VP8LDspInit_body_lock.__data.__owner = 0;
#line 602
    VP8LDspInit_body_lock.__data.__nusers = 0U;
#line 602
    VP8LDspInit_body_lock.__data.__kind = 0;
#line 602
    VP8LDspInit_body_lock.__data.__spins = (short)0;
#line 602
    VP8LDspInit_body_lock.__data.__elision = (short)0;
#line 602
    VP8LDspInit_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 602
    VP8LDspInit_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 602
    __cil_tmp3 = pthread_mutex_lock(& VP8LDspInit_body_lock);
    }
#line 602
    if (__cil_tmp3) {
#line 602
      goto while_break;
    }
#line 602
    if ((unsigned long )VP8LDspInit_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 602
      VP8LDspInit_body();
      }
    }
    {
#line 602
    VP8LDspInit_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 602
    pthread_mutex_unlock(& VP8LDspInit_body_lock);
    }
#line 602
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 606
  return;
}
}
#line 602 "/root/patron-new/new_3/src/dsp/lossless.c"
static void VP8LDspInit_body(void) 
{ 
  int __cil_tmp1 ;
  int __cil_tmp2 ;

  {
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    VP8LPredictors[0] = (VP8LPredictorFunc )(& VP8LPredictor0_C);
#line 603
    VP8LPredictors[1] = (VP8LPredictorFunc )(& VP8LPredictor1_C);
#line 603
    VP8LPredictors[2] = (VP8LPredictorFunc )(& VP8LPredictor2_C);
#line 603
    VP8LPredictors[3] = (VP8LPredictorFunc )(& VP8LPredictor3_C);
#line 603
    VP8LPredictors[4] = (VP8LPredictorFunc )(& VP8LPredictor4_C);
#line 603
    VP8LPredictors[5] = (VP8LPredictorFunc )(& VP8LPredictor5_C);
#line 603
    VP8LPredictors[6] = (VP8LPredictorFunc )(& VP8LPredictor6_C);
#line 603
    VP8LPredictors[7] = (VP8LPredictorFunc )(& VP8LPredictor7_C);
#line 603
    VP8LPredictors[8] = (VP8LPredictorFunc )(& VP8LPredictor8_C);
#line 603
    VP8LPredictors[9] = (VP8LPredictorFunc )(& VP8LPredictor9_C);
#line 603
    VP8LPredictors[10] = (VP8LPredictorFunc )(& VP8LPredictor10_C);
#line 603
    VP8LPredictors[11] = (VP8LPredictorFunc )(& VP8LPredictor11_C);
#line 603
    VP8LPredictors[12] = (VP8LPredictorFunc )(& VP8LPredictor12_C);
#line 603
    VP8LPredictors[13] = (VP8LPredictorFunc )(& VP8LPredictor13_C);
#line 603
    VP8LPredictors[14] = (VP8LPredictorFunc )(& VP8LPredictor0_C);
#line 603
    VP8LPredictors[15] = (VP8LPredictorFunc )(& VP8LPredictor0_C);
#line 603
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 604
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 604
    VP8LPredictorsAdd[0] = & PredictorAdd0_C;
#line 604
    VP8LPredictorsAdd[1] = & PredictorAdd1_C;
#line 604
    VP8LPredictorsAdd[2] = & PredictorAdd2_C;
#line 604
    VP8LPredictorsAdd[3] = & PredictorAdd3_C;
#line 604
    VP8LPredictorsAdd[4] = & PredictorAdd4_C;
#line 604
    VP8LPredictorsAdd[5] = & PredictorAdd5_C;
#line 604
    VP8LPredictorsAdd[6] = & PredictorAdd6_C;
#line 604
    VP8LPredictorsAdd[7] = & PredictorAdd7_C;
#line 604
    VP8LPredictorsAdd[8] = & PredictorAdd8_C;
#line 604
    VP8LPredictorsAdd[9] = & PredictorAdd9_C;
#line 604
    VP8LPredictorsAdd[10] = & PredictorAdd10_C;
#line 604
    VP8LPredictorsAdd[11] = & PredictorAdd11_C;
#line 604
    VP8LPredictorsAdd[12] = & PredictorAdd12_C;
#line 604
    VP8LPredictorsAdd[13] = & PredictorAdd13_C;
#line 604
    VP8LPredictorsAdd[14] = & PredictorAdd0_C;
#line 604
    VP8LPredictorsAdd[15] = & PredictorAdd0_C;
#line 604
    goto while_break___0;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
  {
#line 605
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 605
    VP8LPredictorsAdd_C[0] = & PredictorAdd0_C;
#line 605
    VP8LPredictorsAdd_C[1] = & PredictorAdd1_C;
#line 605
    VP8LPredictorsAdd_C[2] = & PredictorAdd2_C;
#line 605
    VP8LPredictorsAdd_C[3] = & PredictorAdd3_C;
#line 605
    VP8LPredictorsAdd_C[4] = & PredictorAdd4_C;
#line 605
    VP8LPredictorsAdd_C[5] = & PredictorAdd5_C;
#line 605
    VP8LPredictorsAdd_C[6] = & PredictorAdd6_C;
#line 605
    VP8LPredictorsAdd_C[7] = & PredictorAdd7_C;
#line 605
    VP8LPredictorsAdd_C[8] = & PredictorAdd8_C;
#line 605
    VP8LPredictorsAdd_C[9] = & PredictorAdd9_C;
#line 605
    VP8LPredictorsAdd_C[10] = & PredictorAdd10_C;
#line 605
    VP8LPredictorsAdd_C[11] = & PredictorAdd11_C;
#line 605
    VP8LPredictorsAdd_C[12] = & PredictorAdd12_C;
#line 605
    VP8LPredictorsAdd_C[13] = & PredictorAdd13_C;
#line 605
    VP8LPredictorsAdd_C[14] = & PredictorAdd0_C;
#line 605
    VP8LPredictorsAdd_C[15] = & PredictorAdd0_C;
#line 605
    goto while_break___1;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
#line 608
  VP8LAddGreenToBlueAndRed = & VP8LAddGreenToBlueAndRed_C;
#line 610
  VP8LTransformColorInverse = (void (*)(VP8LMultipliers * const   , uint32_t * , int  ,
                                        uint32_t * ))(& VP8LTransformColorInverse_C);
#line 612
  VP8LConvertBGRAToRGBA = & VP8LConvertBGRAToRGBA_C;
#line 613
  VP8LConvertBGRAToRGB = & VP8LConvertBGRAToRGB_C;
#line 614
  VP8LConvertBGRAToBGR = & VP8LConvertBGRAToBGR_C;
#line 617
  VP8LConvertBGRAToRGBA4444 = & VP8LConvertBGRAToRGBA4444_C;
#line 618
  VP8LConvertBGRAToRGB565 = & VP8LConvertBGRAToRGB565_C;
#line 620
  VP8LMapColor32b = (void (*)(uint32_t * , uint32_t * const   , uint32_t * , int  ,
                              int  , int  ))(& MapARGB_C);
#line 621
  VP8LMapColor8b = (void (*)(uint8_t * , uint32_t * const   , uint8_t * , int  , int  ,
                             int  ))(& MapAlpha_C);
#line 624
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
    {
#line 626
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 626
    if (__cil_tmp1) {
      {
#line 627
      VP8LDspInitSSE2();
#line 629
      __cil_tmp2 = (*VP8GetCPUInfo)((CPUFeature )3);
      }
#line 629
      if (__cil_tmp2) {
        {
#line 630
        VP8LDspInitSSE41();
        }
      }
    }
  }
#line 635
  return;
}
}
#line 32 "/root/patron-new/new_3/src/dsp/filters.c"
__inline static void PredictLine_C(uint8_t *src , uint8_t *pred , uint8_t *dst , int length ,
                                   int inverse ) 
{ 
  int i ;

  {
#line 35
  if (inverse) {
#line 36
    i = 0;
    {
#line 36
    while (1) {
      while_continue: /* CIL Label */ ;

#line 36
      if (! (i < length)) {
#line 36
        goto while_break;
      }
#line 36
      *(dst + i) = (uint8_t )((int )*(src + i) + (int )*(pred + i));
#line 36
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 38
    i = 0;
    {
#line 38
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 38
      if (! (i < length)) {
#line 38
        goto while_break___0;
      }
#line 38
      *(dst + i) = (uint8_t )((int )*(src + i) - (int )*(pred + i));
#line 38
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 43
  return;
}
}
#line 45 "/root/patron-new/new_3/src/dsp/filters.c"
__inline static void DoHorizontalFilter_C(uint8_t *in , int width , int height , int stride ,
                                          int row , int num_rows , int inverse , uint8_t *out ) 
{ 
  uint8_t *preds ;
  size_t start_offset ;
  int last_row ;
  uint8_t *tmp___0 ;

  {
#line 50
  start_offset = (size_t )(row * stride);
#line 51
  last_row = row + num_rows;
#line 53
  in += start_offset;
#line 54
  out += start_offset;
#line 55
  if (inverse) {
#line 55
    tmp___0 = out;
  } else {
#line 55
    tmp___0 = in;
  }
#line 55
  preds = tmp___0;
#line 57
  if (row == 0) {
    {
#line 59
    *(out + 0) = *(in + 0);
#line 60
    PredictLine_C(in + 1, preds, out + 1, width - 1, inverse);
#line 61
    row = 1;
#line 62
    preds += stride;
#line 63
    in += stride;
#line 64
    out += stride;
    }
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;

#line 68
    if (! (row < last_row)) {
#line 68
      goto while_break;
    }
    {
#line 70
    PredictLine_C(in, preds - stride, out, 1, inverse);
#line 71
    PredictLine_C(in + 1, preds, out + 1, width - 1, inverse);
#line 72
    row ++;
#line 73
    preds += stride;
#line 74
    in += stride;
#line 75
    out += stride;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 80
  return;
}
}
#line 82 "/root/patron-new/new_3/src/dsp/filters.c"
__inline static void DoVerticalFilter_C(uint8_t *in , int width , int height , int stride ,
                                        int row , int num_rows , int inverse , uint8_t *out ) 
{ 
  uint8_t *preds ;
  size_t start_offset ;
  int last_row ;
  uint8_t *tmp___0 ;

  {
#line 87
  start_offset = (size_t )(row * stride);
#line 88
  last_row = row + num_rows;
#line 90
  in += start_offset;
#line 91
  out += start_offset;
#line 92
  if (inverse) {
#line 92
    tmp___0 = out;
  } else {
#line 92
    tmp___0 = in;
  }
#line 92
  preds = tmp___0;
#line 94
  if (row == 0) {
    {
#line 96
    *(out + 0) = *(in + 0);
#line 98
    PredictLine_C(in + 1, preds, out + 1, width - 1, inverse);
#line 99
    row = 1;
#line 100
    in += stride;
#line 101
    out += stride;
    }
  } else {
#line 104
    preds -= stride;
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;

#line 108
    if (! (row < last_row)) {
#line 108
      goto while_break;
    }
    {
#line 109
    PredictLine_C(in, preds, out, width, inverse);
#line 110
    row ++;
#line 111
    preds += stride;
#line 112
    in += stride;
#line 113
    out += stride;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 118
  return;
}
}
#line 127 "/root/patron-new/new_3/src/dsp/filters.c"
__inline static void DoGradientFilter_C(uint8_t *in , int width , int height , int stride ,
                                        int row , int num_rows , int inverse , uint8_t *out ) 
{ 
  uint8_t *preds ;
  size_t start_offset ;
  int last_row ;
  uint8_t *tmp___0 ;
  int w ;
  int pred ;
  int __cil_tmp15 ;
  int tmp___1 ;

  {
#line 132
  start_offset = (size_t )(row * stride);
#line 133
  last_row = row + num_rows;
#line 135
  in += start_offset;
#line 136
  out += start_offset;
#line 137
  if (inverse) {
#line 137
    tmp___0 = out;
  } else {
#line 137
    tmp___0 = in;
  }
#line 137
  preds = tmp___0;
#line 140
  if (row == 0) {
    {
#line 141
    *(out + 0) = *(in + 0);
#line 142
    PredictLine_C(in + 1, preds, out + 1, width - 1, inverse);
#line 143
    row = 1;
#line 144
    preds += stride;
#line 145
    in += stride;
#line 146
    out += stride;
    }
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;

#line 150
    if (! (row < last_row)) {
#line 150
      goto while_break;
    }
    {
#line 153
    PredictLine_C(in, preds - stride, out, 1, inverse);
#line 154
    w = 1;
    }
    {
#line 154
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 154
      if (! (w < width)) {
#line 154
        goto while_break___0;
      }
      {
#line 155
      __cil_tmp15 = GradientPredictor(*(preds + (w - 1)), *(preds + (w - stride)),
                                      *(preds + ((w - stride) - 1)));
#line 155
      pred = __cil_tmp15;
      }
#line 158
      if (inverse) {
#line 158
        tmp___1 = pred;
      } else {
#line 158
        tmp___1 = - pred;
      }
#line 158
      *(out + w) = (uint8_t )((int )*(in + w) + tmp___1);
#line 154
      w ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 160
    row ++;
#line 161
    preds += stride;
#line 162
    in += stride;
#line 163
    out += stride;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 167
  return;
}
}
#line 173 "/root/patron-new/new_3/src/dsp/filters.c"
static void HorizontalFilter_C(uint8_t *data , int width , int height , int stride ,
                               uint8_t *filtered_data ) 
{ 


  {
  {
#line 175
  DoHorizontalFilter_C(data, width, height, stride, 0, height, 0, filtered_data);
  }
#line 177
  return;
}
}
#line 179 "/root/patron-new/new_3/src/dsp/filters.c"
static void VerticalFilter_C(uint8_t *data , int width , int height , int stride ,
                             uint8_t *filtered_data ) 
{ 


  {
  {
#line 181
  DoVerticalFilter_C(data, width, height, stride, 0, height, 0, filtered_data);
  }
#line 183
  return;
}
}
#line 184 "/root/patron-new/new_3/src/dsp/filters.c"
static void GradientFilter_C(uint8_t *data , int width , int height , int stride ,
                             uint8_t *filtered_data ) 
{ 


  {
  {
#line 186
  DoGradientFilter_C(data, width, height, stride, 0, height, 0, filtered_data);
  }
#line 188
  return;
}
}
#line 192 "/root/patron-new/new_3/src/dsp/filters.c"
static void HorizontalUnfilter_C(uint8_t *prev , uint8_t *in , uint8_t *out , int width ) 
{ 
  uint8_t pred ;
  int tmp___0 ;
  int i ;

  {
#line 194
  if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 194
    tmp___0 = 0;
  } else {
#line 194
    tmp___0 = (int )*(prev + 0);
  }
#line 194
  pred = (uint8_t )tmp___0;
#line 196
  i = 0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;

#line 196
    if (! (i < width)) {
#line 196
      goto while_break;
    }
#line 197
    *(out + i) = (uint8_t )((int )pred + (int )*(in + i));
#line 198
    pred = *(out + i);
#line 196
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 200
  return;
}
}
#line 203 "/root/patron-new/new_3/src/dsp/filters.c"
static void VerticalUnfilter_C(uint8_t *prev , uint8_t *in , uint8_t *out , int width ) 
{ 
  int i ;

  {
#line 205
  if ((unsigned long )prev == (unsigned long )((void *)0)) {
    {
#line 206
    HorizontalUnfilter_C((uint8_t *)((void *)0), in, out, width);
    }
  } else {
#line 209
    i = 0;
    {
#line 209
    while (1) {
      while_continue: /* CIL Label */ ;

#line 209
      if (! (i < width)) {
#line 209
        goto while_break;
      }
#line 209
      *(out + i) = (uint8_t )((int )*(prev + i) + (int )*(in + i));
#line 209
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 214
  return;
}
}
#line 214 "/root/patron-new/new_3/src/dsp/filters.c"
static void GradientUnfilter_C(uint8_t *prev , uint8_t *in , uint8_t *out , int width ) 
{ 
  uint8_t top ;
  uint8_t top_left ;
  uint8_t left ;
  int i ;
  int __cil_tmp9 ;

  {
#line 216
  if ((unsigned long )prev == (unsigned long )((void *)0)) {
    {
#line 217
    HorizontalUnfilter_C((uint8_t *)((void *)0), in, out, width);
    }
  } else {
#line 219
    top = *(prev + 0);
#line 219
    top_left = top;
#line 219
    left = top;
#line 221
    i = 0;
    {
#line 221
    while (1) {
      while_continue: /* CIL Label */ ;

#line 221
      if (! (i < width)) {
#line 221
        goto while_break;
      }
      {
#line 222
      top = *(prev + i);
#line 223
      __cil_tmp9 = GradientPredictor(left, top, top_left);
#line 223
      left = (uint8_t )((int )*(in + i) + __cil_tmp9);
#line 224
      top_left = top;
#line 225
      *(out + i) = left;
#line 221
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 226
  return;
}
}
#line 239
extern void VP8FiltersInitSSE2(void) ;
#line 241
static void VP8FiltersInit_body(void) ;
#line 243 "/root/patron-new/new_3/src/dsp/filters.c"
static int (*VP8FiltersInit_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 244 "/root/patron-new/new_3/src/dsp/filters.c"
static pthread_mutex_t VP8FiltersInit_body_lock  ;
#line 241 "/root/patron-new/new_3/src/dsp/filters.c"
void VP8FiltersInit(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    VP8FiltersInit_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& VP8FiltersInit_body_last_cpuinfo_used);
#line 241
    VP8FiltersInit_body_lock.__data.__lock = 0;
#line 241
    VP8FiltersInit_body_lock.__data.__count = 0U;
#line 241
    VP8FiltersInit_body_lock.__data.__owner = 0;
#line 241
    VP8FiltersInit_body_lock.__data.__nusers = 0U;
#line 241
    VP8FiltersInit_body_lock.__data.__kind = 0;
#line 241
    VP8FiltersInit_body_lock.__data.__spins = (short)0;
#line 241
    VP8FiltersInit_body_lock.__data.__elision = (short)0;
#line 241
    VP8FiltersInit_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 241
    VP8FiltersInit_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 241
    __cil_tmp3 = pthread_mutex_lock(& VP8FiltersInit_body_lock);
    }
#line 241
    if (__cil_tmp3) {
#line 241
      goto while_break;
    }
#line 241
    if ((unsigned long )VP8FiltersInit_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 241
      VP8FiltersInit_body();
      }
    }
    {
#line 241
    VP8FiltersInit_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 241
    pthread_mutex_unlock(& VP8FiltersInit_body_lock);
    }
#line 241
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 245
  return;
}
}
#line 241 "/root/patron-new/new_3/src/dsp/filters.c"
static void VP8FiltersInit_body(void) 
{ 
  int __cil_tmp1 ;

  {
#line 242
  WebPUnfilters[0] = (void (*)(uint8_t * , uint8_t * , uint8_t * , int  ))((void *)0);
#line 244
  WebPUnfilters[1] = & HorizontalUnfilter_C;
#line 245
  WebPUnfilters[2] = & VerticalUnfilter_C;
#line 247
  WebPUnfilters[3] = & GradientUnfilter_C;
#line 249
  WebPFilters[0] = (void (*)(uint8_t * , int  , int  , int  , uint8_t * ))((void *)0);
#line 251
  WebPFilters[1] = & HorizontalFilter_C;
#line 252
  WebPFilters[2] = & VerticalFilter_C;
#line 253
  WebPFilters[3] = & GradientFilter_C;
#line 256
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
    {
#line 258
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 258
    if (__cil_tmp1) {
      {
#line 259
      VP8FiltersInitSSE2();
      }
    }
  }
#line 263
  return;
}
}
#line 20 "/root/patron-new/new_3/src/dsp/enc.c"
__inline static uint8_t clip_8b___1(int v ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
#line 21
  if (! (v & -256)) {
#line 21
    tmp___1 = v;
  } else {
#line 21
    if (v < 0) {
#line 21
      tmp___0 = 0;
    } else {
#line 21
      tmp___0 = 255;
    }
#line 21
    tmp___1 = tmp___0;
  }
#line 21
  return ((uint8_t )tmp___1);
}
}
#line 34 "/root/patron-new/new_3/src/dsp/enc.c"
int const   VP8DspScan[24]  = 
#line 34
  {      (int const   )0,      (int const   )4,      (int const   )8,      (int const   )12, 
        (int const   )128,      (int const   )132,      (int const   )136,      (int const   )140, 
        (int const   )256,      (int const   )260,      (int const   )264,      (int const   )268, 
        (int const   )384,      (int const   )388,      (int const   )392,      (int const   )396, 
        (int const   )0,      (int const   )4,      (int const   )128,      (int const   )132, 
        (int const   )8,      (int const   )12,      (int const   )136,      (int const   )140};
#line 46 "/root/patron-new/new_3/src/dsp/enc.c"
void VP8SetHistogramData(int const   *distribution , VP8Histogram *histo ) 
{ 
  int max_value ;
  int last_non_zero ;
  int k ;
  int value ;

  {
#line 48
  max_value = 0;
#line 48
  last_non_zero = 1;
#line 50
  k = 0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;

#line 50
    if (! (k <= 31)) {
#line 50
      goto while_break;
    }
#line 51
    value = (int )*(distribution + k);
#line 52
    if (value > 0) {
#line 53
      if (value > max_value) {
#line 53
        max_value = value;
      }
#line 54
      last_non_zero = k;
    }
#line 50
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 57
  histo->max_value = max_value;
#line 58
  histo->last_non_zero = last_non_zero;
#line 59
  return;
}
}
#line 62 "/root/patron-new/new_3/src/dsp/enc.c"
static void CollectHistogram_C(uint8_t *ref , uint8_t *pred , int start_block , int end_block ,
                               VP8Histogram *histo ) 
{ 
  int j ;
  int distribution[32] ;
  unsigned int tmp___0 ;
  int k ;
  int16_t out[16] ;
  int v ;
  int __cil_tmp12 ;
  int clipped_value ;
  int __cil_tmp14 ;

  {
#line 66
  distribution[0] = 0;
#line 66
  tmp___0 = 1U;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;

#line 66
    if (tmp___0 >= 32U) {
#line 66
      goto while_break;
    }
#line 66
    distribution[tmp___0] = 0;
#line 66
    tmp___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 67
  j = start_block;
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 67
    if (! (j < end_block)) {
#line 67
      goto while_break___0;
    }
    {
#line 71
    (*VP8FTransform)(ref + VP8DspScan[j], pred + VP8DspScan[j], out);
#line 74
    k = 0;
    }
    {
#line 74
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 74
      if (! (k < 16)) {
#line 74
        goto while_break___1;
      }
      {
#line 75
      __cil_tmp12 = abs((int )out[k]);
#line 75
      v = __cil_tmp12 >> 3;
#line 76
      __cil_tmp14 = GetMin(v, 31);
#line 76
      clipped_value = __cil_tmp14;
#line 77
      (distribution[clipped_value]) ++;
#line 74
      k ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 67
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 80
  VP8SetHistogramData((int const   *)((int const   *)(distribution)), histo);
  }
#line 82
  return;
}
}
#line 87 "/root/patron-new/new_3/src/dsp/enc.c"
static uint8_t clip1[766]  ;
#line 91 "/root/patron-new/new_3/src/dsp/enc.c"
static int tables_ok  =    0;
#line 93 "/root/patron-new/new_3/src/dsp/enc.c"
static void InitTables(void) 
{ 
  int i ;

  {
#line 94
  if (! tables_ok) {
#line 96
    i = -255;
    {
#line 96
    while (1) {
      while_continue: /* CIL Label */ ;

#line 96
      if (! (i <= 510)) {
#line 96
        goto while_break;
      }
      {
#line 97
      clip1[255 + i] = clip_8b___1(i);
#line 96
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 99
    tables_ok = 1;
  }
#line 101
  return;
}
}
#line 112 "/root/patron-new/new_3/src/dsp/enc.c"
static int const   kC1  =    (int const   )(20091 + (1 << 16));
#line 113 "/root/patron-new/new_3/src/dsp/enc.c"
static int const   kC2  =    (int const   )35468;
#line 116 "/root/patron-new/new_3/src/dsp/enc.c"
__inline static void ITransformOne(uint8_t *ref , int16_t *in , uint8_t *dst ) 
{ 
  int C[16] ;
  int *tmp___0 ;
  int i ;
  int a ;
  int b ;
  int c ;
  int d ;
  int dc ;
  int a___0 ;
  int b___0 ;
  int c___0 ;
  int d___0 ;

  {
#line 120
  tmp___0 = C;
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;

#line 121
    if (! (i < 4)) {
#line 121
      goto while_break;
    }
#line 122
    a = (int )*(in + 0) + (int )*(in + 8);
#line 123
    b = (int )*(in + 0) - (int )*(in + 8);
#line 124
    c = ((int )*(in + 4) * (int )kC2 >> 16) - ((int )*(in + 12) * (int )kC1 >> 16);
#line 125
    d = ((int )*(in + 4) * (int )kC1 >> 16) + ((int )*(in + 12) * (int )kC2 >> 16);
#line 126
    *(tmp___0 + 0) = a + d;
#line 127
    *(tmp___0 + 1) = b + c;
#line 128
    *(tmp___0 + 2) = b - c;
#line 129
    *(tmp___0 + 3) = a - d;
#line 130
    tmp___0 += 4;
#line 131
    in ++;
#line 121
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 134
  tmp___0 = C;
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 135
    if (! (i < 4)) {
#line 135
      goto while_break___0;
    }
    {
#line 136
    dc = *(tmp___0 + 0) + 4;
#line 137
    a___0 = dc + *(tmp___0 + 8);
#line 138
    b___0 = dc - *(tmp___0 + 8);
#line 139
    c___0 = (*(tmp___0 + 4) * (int )kC2 >> 16) - (*(tmp___0 + 12) * (int )kC1 >> 16);
#line 140
    d___0 = (*(tmp___0 + 4) * (int )kC1 >> 16) + (*(tmp___0 + 12) * (int )kC2 >> 16);
#line 141
    *(dst + i * 32) = clip_8b___1((int )*(ref + i * 32) + ((a___0 + d___0) >> 3));
#line 142
    *(dst + (1 + i * 32)) = clip_8b___1((int )*(ref + (1 + i * 32)) + ((b___0 + c___0) >> 3));
#line 143
    *(dst + (2 + i * 32)) = clip_8b___1((int )*(ref + (2 + i * 32)) + ((b___0 - c___0) >> 3));
#line 144
    *(dst + (3 + i * 32)) = clip_8b___1((int )*(ref + (3 + i * 32)) + ((a___0 - d___0) >> 3));
#line 145
    tmp___0 ++;
#line 135
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 139
  return;
}
}
#line 149 "/root/patron-new/new_3/src/dsp/enc.c"
static void ITransform_C(uint8_t *ref , int16_t *in , uint8_t *dst , int do_two ) 
{ 


  {
  {
#line 151
  ITransformOne(ref, in, dst);
  }
#line 152
  if (do_two) {
    {
#line 153
    ITransformOne(ref + 4, in + 16, dst + 4);
    }
  }
#line 156
  return;
}
}
#line 157 "/root/patron-new/new_3/src/dsp/enc.c"
static void FTransform_C(uint8_t *src , uint8_t *ref , int16_t *out ) 
{ 
  int i ;
  int tmp___0[16] ;
  int d0 ;
  int d1 ;
  int d2 ;
  int d3 ;
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;

  {
#line 160
  i = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;

#line 160
    if (! (i < 4)) {
#line 160
      goto while_break;
    }
#line 161
    d0 = (int )*(src + 0) - (int )*(ref + 0);
#line 162
    d1 = (int )*(src + 1) - (int )*(ref + 1);
#line 163
    d2 = (int )*(src + 2) - (int )*(ref + 2);
#line 164
    d3 = (int )*(src + 3) - (int )*(ref + 3);
#line 165
    a0 = d0 + d3;
#line 166
    a1 = d1 + d2;
#line 167
    a2 = d1 - d2;
#line 168
    a3 = d0 - d3;
#line 169
    tmp___0[i * 4] = (a0 + a1) * 8;
#line 170
    tmp___0[1 + i * 4] = ((a2 * 2217 + a3 * 5352) + 1812) >> 9;
#line 171
    tmp___0[2 + i * 4] = (a0 - a1) * 8;
#line 172
    tmp___0[3 + i * 4] = ((a3 * 2217 - a2 * 5352) + 937) >> 9;
#line 160
    ref += 32;
#line 160
    src += 32;
#line 160
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 174
  i = 0;
  {
#line 174
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 174
    if (! (i < 4)) {
#line 174
      goto while_break___0;
    }
#line 175
    a0___0 = tmp___0[i] + tmp___0[12 + i];
#line 176
    a1___0 = tmp___0[4 + i] + tmp___0[8 + i];
#line 177
    a2___0 = tmp___0[4 + i] - tmp___0[8 + i];
#line 178
    a3___0 = tmp___0[i] - tmp___0[12 + i];
#line 179
    *(out + i) = (int16_t )(((a0___0 + a1___0) + 7) >> 4);
#line 180
    *(out + (4 + i)) = (int16_t )((((a2___0 * 2217 + a3___0 * 5352) + 12000) >> 16) + (a3___0 != 0));
#line 181
    *(out + (8 + i)) = (int16_t )(((a0___0 - a1___0) + 7) >> 4);
#line 182
    *(out + (12 + i)) = (int16_t )(((a3___0 * 2217 - a2___0 * 5352) + 51000) >> 16);
#line 174
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 178
  return;
}
}
#line 187 "/root/patron-new/new_3/src/dsp/enc.c"
static void FTransform2_C(uint8_t *src , uint8_t *ref , int16_t *out ) 
{ 


  {
  {
#line 189
  (*VP8FTransform)(src, ref, out);
#line 190
  (*VP8FTransform)(src + 4, ref + 4, out + 16);
  }
#line 192
  return;
}
}
#line 194 "/root/patron-new/new_3/src/dsp/enc.c"
static void FTransformWHT_C(int16_t *in , int16_t *out ) 
{ 
  int32_t tmp___0[16] ;
  int i ;
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;
  int b0 ;
  int b1 ;
  int b2 ;
  int b3 ;

  {
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;

#line 198
    if (! (i < 4)) {
#line 198
      goto while_break;
    }
#line 199
    a0 = (int )*(in + 0) + (int )*(in + 32);
#line 200
    a1 = (int )*(in + 16) + (int )*(in + 48);
#line 201
    a2 = (int )*(in + 16) - (int )*(in + 48);
#line 202
    a3 = (int )*(in + 0) - (int )*(in + 32);
#line 203
    tmp___0[i * 4] = a0 + a1;
#line 204
    tmp___0[1 + i * 4] = a3 + a2;
#line 205
    tmp___0[2 + i * 4] = a3 - a2;
#line 206
    tmp___0[3 + i * 4] = a0 - a1;
#line 198
    in += 64;
#line 198
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 208
  i = 0;
  {
#line 208
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 208
    if (! (i < 4)) {
#line 208
      goto while_break___0;
    }
#line 209
    a0___0 = tmp___0[i] + tmp___0[8 + i];
#line 210
    a1___0 = tmp___0[4 + i] + tmp___0[12 + i];
#line 211
    a2___0 = tmp___0[4 + i] - tmp___0[12 + i];
#line 212
    a3___0 = tmp___0[i] - tmp___0[8 + i];
#line 213
    b0 = a0___0 + a1___0;
#line 214
    b1 = a3___0 + a2___0;
#line 215
    b2 = a3___0 - a2___0;
#line 216
    b3 = a0___0 - a1___0;
#line 217
    *(out + i) = (int16_t )(b0 >> 1);
#line 218
    *(out + (4 + i)) = (int16_t )(b1 >> 1);
#line 219
    *(out + (8 + i)) = (int16_t )(b2 >> 1);
#line 220
    *(out + (12 + i)) = (int16_t )(b3 >> 1);
#line 208
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 212
  return;
}
}
#line 231 "/root/patron-new/new_3/src/dsp/enc.c"
__inline static void Fill(uint8_t *dst , int value , int size ) 
{ 
  int j ;

  {
#line 233
  j = 0;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;

#line 233
    if (! (j < size)) {
#line 233
      goto while_break;
    }
    {
#line 234
    memset((void *)(dst + j * 32), value, (unsigned long )size);
#line 233
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 237
  return;
}
}
#line 238 "/root/patron-new/new_3/src/dsp/enc.c"
__inline static void VerticalPred(uint8_t *dst , uint8_t *top , int size ) 
{ 
  int j ;

  {
#line 241
  if ((unsigned long )top != (unsigned long )((void *)0)) {
#line 242
    j = 0;
    {
#line 242
    while (1) {
      while_continue: /* CIL Label */ ;

#line 242
      if (! (j < size)) {
#line 242
        goto while_break;
      }
      {
#line 242
      memcpy((void *)(dst + j * 32), (void const   *)top, (unsigned long )size);
#line 242
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 244
    Fill(dst, 127, size);
    }
  }
#line 247
  return;
}
}
#line 248 "/root/patron-new/new_3/src/dsp/enc.c"
__inline static void HorizontalPred(uint8_t *dst , uint8_t *left , int size ) 
{ 
  int j ;

  {
#line 250
  if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 252
    j = 0;
    {
#line 252
    while (1) {
      while_continue: /* CIL Label */ ;

#line 252
      if (! (j < size)) {
#line 252
        goto while_break;
      }
      {
#line 253
      memset((void *)(dst + j * 32), (int )*(left + j), (unsigned long )size);
#line 252
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 256
    Fill(dst, 129, size);
    }
  }
#line 259
  return;
}
}
#line 260 "/root/patron-new/new_3/src/dsp/enc.c"
__inline static void TrueMotion(uint8_t *dst , uint8_t *left , uint8_t *top , int size ) 
{ 
  int y ;
  uint8_t *clip___2 ;
  uint8_t *clip_table ;
  int x ;

  {
#line 263
  if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 264
    if ((unsigned long )top != (unsigned long )((void *)0)) {
#line 265
      clip___2 = (clip1 + 255) - (int )*(left + -1);
#line 266
      y = 0;
      {
#line 266
      while (1) {
        while_continue: /* CIL Label */ ;

#line 266
        if (! (y < size)) {
#line 266
          goto while_break;
        }
#line 267
        clip_table = clip___2 + (int )*(left + y);
#line 269
        x = 0;
        {
#line 269
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 269
          if (! (x < size)) {
#line 269
            goto while_break___0;
          }
#line 270
          *(dst + x) = *(clip_table + (int )*(top + x));
#line 269
          x ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: 
#line 272
        dst += 32;
#line 266
        y ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: ;
    } else {
      {
#line 275
      HorizontalPred(dst, left, size);
      }
    }
  } else
#line 282
  if ((unsigned long )top != (unsigned long )((void *)0)) {
    {
#line 283
    VerticalPred(dst, top, size);
    }
  } else {
    {
#line 285
    Fill(dst, 129, size);
    }
  }
#line 288
  return;
}
}
#line 290 "/root/patron-new/new_3/src/dsp/enc.c"
__inline static void DCMode(uint8_t *dst , uint8_t *left , uint8_t *top , int size ,
                            int round___0 , int shift ) 
{ 
  int DC ;
  int j ;

  {
#line 293
  DC = 0;
#line 295
  if ((unsigned long )top != (unsigned long )((void *)0)) {
#line 296
    j = 0;
    {
#line 296
    while (1) {
      while_continue: /* CIL Label */ ;

#line 296
      if (! (j < size)) {
#line 296
        goto while_break;
      }
#line 296
      DC += (int )*(top + j);
#line 296
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
#line 297
    if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 298
      j = 0;
      {
#line 298
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 298
        if (! (j < size)) {
#line 298
          goto while_break___0;
        }
#line 298
        DC += (int )*(left + j);
#line 298
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 300
      DC += DC;
    }
#line 302
    DC = (DC + round___0) >> shift;
  } else
#line 303
  if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 304
    j = 0;
    {
#line 304
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 304
      if (! (j < size)) {
#line 304
        goto while_break___1;
      }
#line 304
      DC += (int )*(left + j);
#line 304
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 305
    DC += DC;
#line 306
    DC = (DC + round___0) >> shift;
  } else {
#line 308
    DC = 128;
  }
  {
#line 310
  Fill(dst, DC, size);
  }
#line 312
  return;
}
}
#line 316 "/root/patron-new/new_3/src/dsp/enc.c"
static void IntraChromaPreds_C(uint8_t *dst , uint8_t *left , uint8_t *top ) 
{ 


  {
  {
#line 319
  DCMode(dst + 1024, left, top, 8, 8, 4);
#line 320
  VerticalPred(dst + 1280, top, 8);
#line 321
  HorizontalPred(dst + 1296, left, 8);
#line 322
  TrueMotion(dst + 1040, left, top, 8);
#line 324
  dst += 8;
  }
#line 325
  if ((unsigned long )top != (unsigned long )((void *)0)) {
#line 325
    top += 8;
  }
#line 326
  if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 326
    left += 16;
  }
  {
#line 327
  DCMode(dst + 1024, left, top, 8, 8, 4);
#line 328
  VerticalPred(dst + 1280, top, 8);
#line 329
  HorizontalPred(dst + 1296, left, 8);
#line 330
  TrueMotion(dst + 1040, left, top, 8);
  }
#line 332
  return;
}
}
#line 336 "/root/patron-new/new_3/src/dsp/enc.c"
static void Intra16Preds_C(uint8_t *dst , uint8_t *left , uint8_t *top ) 
{ 


  {
  {
#line 338
  DCMode(dst + 0, left, top, 16, 16, 5);
#line 339
  VerticalPred(dst + 512, top, 16);
#line 340
  HorizontalPred(dst + 528, left, 16);
#line 341
  TrueMotion(dst + 16, left, top, 16);
  }
#line 343
  return;
}
}
#line 351 "/root/patron-new/new_3/src/dsp/enc.c"
static void VE4(uint8_t *dst , uint8_t *top ) 
{ 
  uint8_t vals[4] ;
  int i ;

  {
#line 352
  vals[0] = (uint8_t )(((((int )*(top + -1) + 2 * (int )*(top + 0)) + (int )*(top + 1)) + 2) >> 2);
#line 352
  vals[1] = (uint8_t )(((((int )*(top + 0) + 2 * (int )*(top + 1)) + (int )*(top + 2)) + 2) >> 2);
#line 352
  vals[2] = (uint8_t )(((((int )*(top + 1) + 2 * (int )*(top + 2)) + (int )*(top + 3)) + 2) >> 2);
#line 352
  vals[3] = (uint8_t )(((((int )*(top + 2) + 2 * (int )*(top + 3)) + (int )*(top + 4)) + 2) >> 2);
#line 359
  i = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;

#line 359
    if (! (i < 4)) {
#line 359
      goto while_break;
    }
    {
#line 360
    memcpy((void *)(dst + i * 32), (void const   *)(vals), 4UL);
#line 359
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 363
  return;
}
}
#line 364 "/root/patron-new/new_3/src/dsp/enc.c"
static void HE4(uint8_t *dst , uint8_t *top ) 
{ 
  int X ;
  int I ;
  int J ;
  int K ;
  int L ;

  {
  {
#line 365
  X = (int )*(top + -1);
#line 366
  I = (int )*(top + -2);
#line 367
  J = (int )*(top + -3);
#line 368
  K = (int )*(top + -4);
#line 369
  L = (int )*(top + -5);
#line 370
  WebPUint32ToMem(dst + 0, 16843009U * (unsigned int )((uint8_t )((((X + 2 * I) + J) + 2) >> 2)));
#line 371
  WebPUint32ToMem(dst + 32, 16843009U * (unsigned int )((uint8_t )((((I + 2 * J) + K) + 2) >> 2)));
#line 372
  WebPUint32ToMem(dst + 64, 16843009U * (unsigned int )((uint8_t )((((J + 2 * K) + L) + 2) >> 2)));
#line 373
  WebPUint32ToMem(dst + 96, 16843009U * (unsigned int )((uint8_t )((((K + 2 * L) + L) + 2) >> 2)));
  }
#line 375
  return;
}
}
#line 376 "/root/patron-new/new_3/src/dsp/enc.c"
static void DC4(uint8_t *dst , uint8_t *top ) 
{ 
  uint32_t dc ;
  int i ;

  {
#line 377
  dc = (uint32_t )4;
#line 379
  i = 0;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;

#line 379
    if (! (i < 4)) {
#line 379
      goto while_break;
    }
#line 379
    dc += (unsigned int )((int )*(top + i) + (int )*(top + (-5 + i)));
#line 379
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 380
  Fill(dst, (int )(dc >> 3), 4);
  }
#line 382
  return;
}
}
#line 383 "/root/patron-new/new_3/src/dsp/enc.c"
static void RD4(uint8_t *dst , uint8_t *top ) 
{ 
  int X ;
  int I ;
  int J ;
  int K ;
  int L ;
  int A ;
  int B ;
  int C ;
  int D ;

  {
#line 384
  X = (int )*(top + -1);
#line 385
  I = (int )*(top + -2);
#line 386
  J = (int )*(top + -3);
#line 387
  K = (int )*(top + -4);
#line 388
  L = (int )*(top + -5);
#line 389
  A = (int )*(top + 0);
#line 390
  B = (int )*(top + 1);
#line 391
  C = (int )*(top + 2);
#line 392
  D = (int )*(top + 3);
#line 393
  *(dst + 96) = (uint8_t )((((J + 2 * K) + L) + 2) >> 2);
#line 394
  *(dst + 97) = (uint8_t )((((I + 2 * J) + K) + 2) >> 2);
#line 394
  *(dst + 64) = *(dst + 97);
#line 395
  *(dst + 98) = (uint8_t )((((X + 2 * I) + J) + 2) >> 2);
#line 395
  *(dst + 65) = *(dst + 98);
#line 395
  *(dst + 32) = *(dst + 65);
#line 396
  *(dst + 99) = (uint8_t )((((A + 2 * X) + I) + 2) >> 2);
#line 396
  *(dst + 66) = *(dst + 99);
#line 396
  *(dst + 33) = *(dst + 66);
#line 396
  *(dst + 0) = *(dst + 33);
#line 397
  *(dst + 67) = (uint8_t )((((B + 2 * A) + X) + 2) >> 2);
#line 397
  *(dst + 34) = *(dst + 67);
#line 397
  *(dst + 1) = *(dst + 34);
#line 398
  *(dst + 35) = (uint8_t )((((C + 2 * B) + A) + 2) >> 2);
#line 398
  *(dst + 2) = *(dst + 35);
#line 399
  *(dst + 3) = (uint8_t )((((D + 2 * C) + B) + 2) >> 2);
#line 400
  return;
}
}
#line 402 "/root/patron-new/new_3/src/dsp/enc.c"
static void LD4(uint8_t *dst , uint8_t *top ) 
{ 
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;
  int F ;
  int G ;
  int H ;

  {
#line 403
  A = (int )*(top + 0);
#line 404
  B = (int )*(top + 1);
#line 405
  C = (int )*(top + 2);
#line 406
  D = (int )*(top + 3);
#line 407
  E = (int )*(top + 4);
#line 408
  F = (int )*(top + 5);
#line 409
  G = (int )*(top + 6);
#line 410
  H = (int )*(top + 7);
#line 411
  *(dst + 0) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 412
  *(dst + 32) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 412
  *(dst + 1) = *(dst + 32);
#line 413
  *(dst + 64) = (uint8_t )((((C + 2 * D) + E) + 2) >> 2);
#line 413
  *(dst + 33) = *(dst + 64);
#line 413
  *(dst + 2) = *(dst + 33);
#line 414
  *(dst + 96) = (uint8_t )((((D + 2 * E) + F) + 2) >> 2);
#line 414
  *(dst + 65) = *(dst + 96);
#line 414
  *(dst + 34) = *(dst + 65);
#line 414
  *(dst + 3) = *(dst + 34);
#line 415
  *(dst + 97) = (uint8_t )((((E + 2 * F) + G) + 2) >> 2);
#line 415
  *(dst + 66) = *(dst + 97);
#line 415
  *(dst + 35) = *(dst + 66);
#line 416
  *(dst + 98) = (uint8_t )((((F + 2 * G) + H) + 2) >> 2);
#line 416
  *(dst + 67) = *(dst + 98);
#line 417
  *(dst + 99) = (uint8_t )((((G + 2 * H) + H) + 2) >> 2);
#line 418
  return;
}
}
#line 420 "/root/patron-new/new_3/src/dsp/enc.c"
static void VR4(uint8_t *dst , uint8_t *top ) 
{ 
  int X ;
  int I ;
  int J ;
  int K ;
  int A ;
  int B ;
  int C ;
  int D ;

  {
#line 421
  X = (int )*(top + -1);
#line 422
  I = (int )*(top + -2);
#line 423
  J = (int )*(top + -3);
#line 424
  K = (int )*(top + -4);
#line 425
  A = (int )*(top + 0);
#line 426
  B = (int )*(top + 1);
#line 427
  C = (int )*(top + 2);
#line 428
  D = (int )*(top + 3);
#line 429
  *(dst + 65) = (uint8_t )(((X + A) + 1) >> 1);
#line 429
  *(dst + 0) = *(dst + 65);
#line 430
  *(dst + 66) = (uint8_t )(((A + B) + 1) >> 1);
#line 430
  *(dst + 1) = *(dst + 66);
#line 431
  *(dst + 67) = (uint8_t )(((B + C) + 1) >> 1);
#line 431
  *(dst + 2) = *(dst + 67);
#line 432
  *(dst + 3) = (uint8_t )(((C + D) + 1) >> 1);
#line 434
  *(dst + 96) = (uint8_t )((((K + 2 * J) + I) + 2) >> 2);
#line 435
  *(dst + 64) = (uint8_t )((((J + 2 * I) + X) + 2) >> 2);
#line 436
  *(dst + 97) = (uint8_t )((((I + 2 * X) + A) + 2) >> 2);
#line 436
  *(dst + 32) = *(dst + 97);
#line 437
  *(dst + 98) = (uint8_t )((((X + 2 * A) + B) + 2) >> 2);
#line 437
  *(dst + 33) = *(dst + 98);
#line 438
  *(dst + 99) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 438
  *(dst + 34) = *(dst + 99);
#line 439
  *(dst + 35) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 440
  return;
}
}
#line 442 "/root/patron-new/new_3/src/dsp/enc.c"
static void VL4(uint8_t *dst , uint8_t *top ) 
{ 
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;
  int F ;
  int G ;
  int H ;

  {
#line 443
  A = (int )*(top + 0);
#line 444
  B = (int )*(top + 1);
#line 445
  C = (int )*(top + 2);
#line 446
  D = (int )*(top + 3);
#line 447
  E = (int )*(top + 4);
#line 448
  F = (int )*(top + 5);
#line 449
  G = (int )*(top + 6);
#line 450
  H = (int )*(top + 7);
#line 451
  *(dst + 0) = (uint8_t )(((A + B) + 1) >> 1);
#line 452
  *(dst + 64) = (uint8_t )(((B + C) + 1) >> 1);
#line 452
  *(dst + 1) = *(dst + 64);
#line 453
  *(dst + 65) = (uint8_t )(((C + D) + 1) >> 1);
#line 453
  *(dst + 2) = *(dst + 65);
#line 454
  *(dst + 66) = (uint8_t )(((D + E) + 1) >> 1);
#line 454
  *(dst + 3) = *(dst + 66);
#line 456
  *(dst + 32) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 457
  *(dst + 96) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 457
  *(dst + 33) = *(dst + 96);
#line 458
  *(dst + 97) = (uint8_t )((((C + 2 * D) + E) + 2) >> 2);
#line 458
  *(dst + 34) = *(dst + 97);
#line 459
  *(dst + 98) = (uint8_t )((((D + 2 * E) + F) + 2) >> 2);
#line 459
  *(dst + 35) = *(dst + 98);
#line 460
  *(dst + 67) = (uint8_t )((((E + 2 * F) + G) + 2) >> 2);
#line 461
  *(dst + 99) = (uint8_t )((((F + 2 * G) + H) + 2) >> 2);
#line 462
  return;
}
}
#line 464 "/root/patron-new/new_3/src/dsp/enc.c"
static void HU4(uint8_t *dst , uint8_t *top ) 
{ 
  int I ;
  int J ;
  int K ;
  int L ;

  {
#line 465
  I = (int )*(top + -2);
#line 466
  J = (int )*(top + -3);
#line 467
  K = (int )*(top + -4);
#line 468
  L = (int )*(top + -5);
#line 469
  *(dst + 0) = (uint8_t )(((I + J) + 1) >> 1);
#line 470
  *(dst + 32) = (uint8_t )(((J + K) + 1) >> 1);
#line 470
  *(dst + 2) = *(dst + 32);
#line 471
  *(dst + 64) = (uint8_t )(((K + L) + 1) >> 1);
#line 471
  *(dst + 34) = *(dst + 64);
#line 472
  *(dst + 1) = (uint8_t )((((I + 2 * J) + K) + 2) >> 2);
#line 473
  *(dst + 33) = (uint8_t )((((J + 2 * K) + L) + 2) >> 2);
#line 473
  *(dst + 3) = *(dst + 33);
#line 474
  *(dst + 65) = (uint8_t )((((K + 2 * L) + L) + 2) >> 2);
#line 474
  *(dst + 35) = *(dst + 65);
#line 475
  *(dst + 99) = (uint8_t )L;
#line 475
  *(dst + 98) = *(dst + 99);
#line 475
  *(dst + 97) = *(dst + 98);
#line 475
  *(dst + 96) = *(dst + 97);
#line 475
  *(dst + 66) = *(dst + 96);
#line 475
  *(dst + 67) = *(dst + 66);
#line 476
  return;
}
}
#line 479 "/root/patron-new/new_3/src/dsp/enc.c"
static void HD4(uint8_t *dst , uint8_t *top ) 
{ 
  int X ;
  int I ;
  int J ;
  int K ;
  int L ;
  int A ;
  int B ;
  int C ;

  {
#line 480
  X = (int )*(top + -1);
#line 481
  I = (int )*(top + -2);
#line 482
  J = (int )*(top + -3);
#line 483
  K = (int )*(top + -4);
#line 484
  L = (int )*(top + -5);
#line 485
  A = (int )*(top + 0);
#line 486
  B = (int )*(top + 1);
#line 487
  C = (int )*(top + 2);
#line 489
  *(dst + 34) = (uint8_t )(((I + X) + 1) >> 1);
#line 489
  *(dst + 0) = *(dst + 34);
#line 490
  *(dst + 66) = (uint8_t )(((J + I) + 1) >> 1);
#line 490
  *(dst + 32) = *(dst + 66);
#line 491
  *(dst + 98) = (uint8_t )(((K + J) + 1) >> 1);
#line 491
  *(dst + 64) = *(dst + 98);
#line 492
  *(dst + 96) = (uint8_t )(((L + K) + 1) >> 1);
#line 494
  *(dst + 3) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 495
  *(dst + 2) = (uint8_t )((((X + 2 * A) + B) + 2) >> 2);
#line 496
  *(dst + 35) = (uint8_t )((((I + 2 * X) + A) + 2) >> 2);
#line 496
  *(dst + 1) = *(dst + 35);
#line 497
  *(dst + 67) = (uint8_t )((((J + 2 * I) + X) + 2) >> 2);
#line 497
  *(dst + 33) = *(dst + 67);
#line 498
  *(dst + 99) = (uint8_t )((((K + 2 * J) + I) + 2) >> 2);
#line 498
  *(dst + 65) = *(dst + 99);
#line 499
  *(dst + 97) = (uint8_t )((((L + 2 * K) + J) + 2) >> 2);
#line 500
  return;
}
}
#line 502 "/root/patron-new/new_3/src/dsp/enc.c"
static void TM4(uint8_t *dst , uint8_t *top ) 
{ 
  int x ;
  int y ;
  uint8_t *clip___2 ;
  uint8_t *clip_table ;

  {
#line 504
  clip___2 = (clip1 + 255) - (int )*(top + -1);
#line 505
  y = 0;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;

#line 505
    if (! (y < 4)) {
#line 505
      goto while_break;
    }
#line 506
    clip_table = clip___2 + (int )*(top + (-2 - y));
#line 507
    x = 0;
    {
#line 507
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 507
      if (! (x < 4)) {
#line 507
        goto while_break___0;
      }
#line 508
      *(dst + x) = *(clip_table + (int )*(top + x));
#line 507
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 510
    dst += 32;
#line 505
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 509
  return;
}
}
#line 520 "/root/patron-new/new_3/src/dsp/enc.c"
static void Intra4Preds_C(uint8_t *dst , uint8_t *top ) 
{ 


  {
  {
#line 521
  DC4(dst + 1536, top);
#line 522
  TM4(dst + 1540, top);
#line 523
  VE4(dst + 1544, top);
#line 524
  HE4(dst + 1548, top);
#line 525
  RD4(dst + 1552, top);
#line 526
  VR4(dst + 1556, top);
#line 527
  LD4(dst + 1560, top);
#line 528
  VL4(dst + 1564, top);
#line 529
  HD4(dst + 1664, top);
#line 530
  HU4(dst + 1668, top);
  }
#line 532
  return;
}
}
#line 537 "/root/patron-new/new_3/src/dsp/enc.c"
__inline static int GetSSE(uint8_t *a , uint8_t *b , int w , int h ) 
{ 
  int count ;
  int y ;
  int x ;
  int diff ;

  {
#line 539
  count = 0;
#line 541
  y = 0;
  {
#line 541
  while (1) {
    while_continue: /* CIL Label */ ;

#line 541
    if (! (y < h)) {
#line 541
      goto while_break;
    }
#line 542
    x = 0;
    {
#line 542
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 542
      if (! (x < w)) {
#line 542
        goto while_break___0;
      }
#line 543
      diff = (int )*(a + x) - (int )*(b + x);
#line 544
      count += diff * diff;
#line 542
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 546
    a += 32;
#line 547
    b += 32;
#line 541
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 549
  return (count);
}
}
#line 552 "/root/patron-new/new_3/src/dsp/enc.c"
static int SSE16x16_C(uint8_t *a , uint8_t *b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 553
  __cil_tmp3 = GetSSE(a, b, 16, 16);
  }
#line 553
  return (__cil_tmp3);
}
}
#line 555 "/root/patron-new/new_3/src/dsp/enc.c"
static int SSE16x8_C(uint8_t *a , uint8_t *b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 556
  __cil_tmp3 = GetSSE(a, b, 16, 8);
  }
#line 556
  return (__cil_tmp3);
}
}
#line 558 "/root/patron-new/new_3/src/dsp/enc.c"
static int SSE8x8_C(uint8_t *a , uint8_t *b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 559
  __cil_tmp3 = GetSSE(a, b, 8, 8);
  }
#line 559
  return (__cil_tmp3);
}
}
#line 561 "/root/patron-new/new_3/src/dsp/enc.c"
static int SSE4x4_C(uint8_t *a , uint8_t *b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 562
  __cil_tmp3 = GetSSE(a, b, 4, 4);
  }
#line 562
  return (__cil_tmp3);
}
}
#line 566 "/root/patron-new/new_3/src/dsp/enc.c"
static void Mean16x4_C(uint8_t *ref , uint32_t *dc ) 
{ 
  int k ;
  int x ;
  int y ;
  uint32_t avg ;

  {
#line 568
  k = 0;
  {
#line 568
  while (1) {
    while_continue: /* CIL Label */ ;

#line 568
    if (! (k < 4)) {
#line 568
      goto while_break;
    }
#line 569
    avg = (uint32_t )0;
#line 570
    y = 0;
    {
#line 570
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 570
      if (! (y < 4)) {
#line 570
        goto while_break___0;
      }
#line 571
      x = 0;
      {
#line 571
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 571
        if (! (x < 4)) {
#line 571
          goto while_break___1;
        }
#line 572
        avg += (unsigned int )*(ref + (x + y * 32));
#line 571
        x ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 570
      y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 575
    *(dc + k) = avg;
#line 576
    ref += 4;
#line 568
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 572
  return;
}
}
#line 590 "/root/patron-new/new_3/src/dsp/enc.c"
static int TTransform(uint8_t *in , uint16_t *w ) 
{ 
  int sum ;
  int tmp___0[16] ;
  int i ;
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;
  int b0 ;
  int b1 ;
  int b2 ;
  int b3 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;

  {
#line 591
  sum = 0;
#line 595
  i = 0;
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;

#line 595
    if (! (i < 4)) {
#line 595
      goto while_break;
    }
#line 596
    a0 = (int )*(in + 0) + (int )*(in + 2);
#line 597
    a1 = (int )*(in + 1) + (int )*(in + 3);
#line 598
    a2 = (int )*(in + 1) - (int )*(in + 3);
#line 599
    a3 = (int )*(in + 0) - (int )*(in + 2);
#line 600
    tmp___0[i * 4] = a0 + a1;
#line 601
    tmp___0[1 + i * 4] = a3 + a2;
#line 602
    tmp___0[2 + i * 4] = a3 - a2;
#line 603
    tmp___0[3 + i * 4] = a0 - a1;
#line 595
    in += 32;
#line 595
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 606
  i = 0;
  {
#line 606
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 606
    if (! (i < 4)) {
#line 606
      goto while_break___0;
    }
    {
#line 607
    a0___0 = tmp___0[i] + tmp___0[8 + i];
#line 608
    a1___0 = tmp___0[4 + i] + tmp___0[12 + i];
#line 609
    a2___0 = tmp___0[4 + i] - tmp___0[12 + i];
#line 610
    a3___0 = tmp___0[i] - tmp___0[8 + i];
#line 611
    b0 = a0___0 + a1___0;
#line 612
    b1 = a3___0 + a2___0;
#line 613
    b2 = a3___0 - a2___0;
#line 614
    b3 = a0___0 - a1___0;
#line 616
    __cil_tmp18 = abs(b0);
#line 616
    sum += (int )*(w + 0) * __cil_tmp18;
#line 617
    __cil_tmp19 = abs(b1);
#line 617
    sum += (int )*(w + 4) * __cil_tmp19;
#line 618
    __cil_tmp20 = abs(b2);
#line 618
    sum += (int )*(w + 8) * __cil_tmp20;
#line 619
    __cil_tmp21 = abs(b3);
#line 619
    sum += (int )*(w + 12) * __cil_tmp21;
#line 606
    w ++;
#line 606
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 621
  return (sum);
}
}
#line 624 "/root/patron-new/new_3/src/dsp/enc.c"
static int Disto4x4_C(uint8_t *a , uint8_t *b , uint16_t *w ) 
{ 
  int sum1 ;
  int __cil_tmp5 ;
  int sum2 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 626
  __cil_tmp5 = TTransform(a, w);
#line 626
  sum1 = __cil_tmp5;
#line 627
  __cil_tmp7 = TTransform(b, w);
#line 627
  sum2 = __cil_tmp7;
#line 628
  __cil_tmp8 = abs(sum2 - sum1);
  }
#line 628
  return (__cil_tmp8 >> 5);
}
}
#line 631 "/root/patron-new/new_3/src/dsp/enc.c"
static int Disto16x16_C(uint8_t *a , uint8_t *b , uint16_t *w ) 
{ 
  int D ;
  int x ;
  int y ;
  int __cil_tmp7 ;

  {
#line 633
  D = 0;
#line 635
  y = 0;
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;

#line 635
    if (! (y < 512)) {
#line 635
      goto while_break;
    }
#line 636
    x = 0;
    {
#line 636
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 636
      if (! (x < 16)) {
#line 636
        goto while_break___0;
      }
      {
#line 637
      __cil_tmp7 = Disto4x4_C((a + x) + y, (b + x) + y, w);
#line 637
      D += __cil_tmp7;
#line 636
      x += 4;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 635
    y += 128;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 640
  return (D);
}
}
#line 648 "/root/patron-new/new_3/src/dsp/enc.c"
static uint8_t kZigzag___0[16]  = 
#line 648
  {      (uint8_t )0,      (uint8_t )1,      (uint8_t )4,      (uint8_t )8, 
        (uint8_t )5,      (uint8_t )2,      (uint8_t )3,      (uint8_t )6, 
        (uint8_t )9,      (uint8_t )12,      (uint8_t )13,      (uint8_t )10, 
        (uint8_t )7,      (uint8_t )11,      (uint8_t )14,      (uint8_t )15};
#line 653 "/root/patron-new/new_3/src/dsp/enc.c"
static int QuantizeBlock_C(int16_t *in , int16_t *out , VP8Matrix *mtx ) 
{ 
  int last ;
  int n ;
  int j ;
  int sign ;
  uint32_t coeff ;
  int tmp___0 ;
  uint32_t Q ;
  uint32_t iQ ;
  uint32_t B ;
  int level ;
  int __cil_tmp14 ;

  {
#line 655
  last = -1;
#line 657
  n = 0;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;

#line 657
    if (! (n < 16)) {
#line 657
      goto while_break;
    }
#line 658
    j = (int )kZigzag___0[n];
#line 659
    sign = (int )*(in + j) < 0;
#line 660
    if (sign) {
#line 660
      tmp___0 = - ((int )*(in + j));
    } else {
#line 660
      tmp___0 = (int )*(in + j);
    }
#line 660
    coeff = (uint32_t )(tmp___0 + (int )mtx->sharpen_[j]);
#line 661
    if (coeff > mtx->zthresh_[j]) {
      {
#line 662
      Q = (uint32_t )mtx->q_[j];
#line 663
      iQ = (uint32_t )mtx->iq_[j];
#line 664
      B = mtx->bias_[j];
#line 665
      __cil_tmp14 = QUANTDIV(coeff, iQ, B);
#line 665
      level = __cil_tmp14;
      }
#line 666
      if (level > 2047) {
#line 666
        level = 2047;
      }
#line 667
      if (sign) {
#line 667
        level = - level;
      }
#line 668
      *(in + j) = (int16_t )(level * (int )Q);
#line 669
      *(out + n) = (int16_t )level;
#line 670
      if (level) {
#line 670
        last = n;
      }
    } else {
#line 672
      *(out + n) = (int16_t )0;
#line 673
      *(in + j) = (int16_t )0;
    }
#line 657
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 676
  return (last >= 0);
}
}
#line 680 "/root/patron-new/new_3/src/dsp/enc.c"
static int Quantize2Blocks_C(int16_t *in , int16_t *out , VP8Matrix *mtx ) 
{ 
  int nz ;
  int __cil_tmp6 ;

  {
  {
#line 683
  nz = (*VP8EncQuantizeBlock)((int16_t *)(in + 0), (int16_t *)(out + 0), (struct VP8Matrix */* const  */)mtx);
#line 684
  __cil_tmp6 = (*VP8EncQuantizeBlock)((int16_t *)(in + 16), (int16_t *)(out + 16),
                                      (struct VP8Matrix */* const  */)mtx);
#line 684
  nz |= __cil_tmp6 << 1;
  }
#line 685
  return (nz);
}
}
#line 692 "/root/patron-new/new_3/src/dsp/enc.c"
__inline static void Copy(uint8_t *src , uint8_t *dst , int w , int h ) 
{ 
  int y ;

  {
#line 694
  y = 0;
  {
#line 694
  while (1) {
    while_continue: /* CIL Label */ ;

#line 694
    if (! (y < h)) {
#line 694
      goto while_break;
    }
    {
#line 695
    memcpy((void *)dst, (void const   *)src, (unsigned long )w);
#line 696
    src += 32;
#line 697
    dst += 32;
#line 694
    y ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 698
  return;
}
}
#line 701 "/root/patron-new/new_3/src/dsp/enc.c"
static void Copy4x4_C(uint8_t *src , uint8_t *dst ) 
{ 


  {
  {
#line 702
  Copy(src, dst, 4, 4);
  }
#line 704
  return;
}
}
#line 705 "/root/patron-new/new_3/src/dsp/enc.c"
static void Copy16x8_C(uint8_t *src , uint8_t *dst ) 
{ 


  {
  {
#line 706
  Copy(src, dst, 16, 8);
  }
#line 708
  return;
}
}
#line 735
extern void VP8EncDspInitSSE2(void) ;
#line 736
extern void VP8EncDspInitSSE41(void) ;
#line 742
static void VP8EncDspInit_body(void) ;
#line 744 "/root/patron-new/new_3/src/dsp/enc.c"
static int (*VP8EncDspInit_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 745 "/root/patron-new/new_3/src/dsp/enc.c"
static pthread_mutex_t VP8EncDspInit_body_lock  ;
#line 742 "/root/patron-new/new_3/src/dsp/enc.c"
void VP8EncDspInit(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 742
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 742
    VP8EncDspInit_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& VP8EncDspInit_body_last_cpuinfo_used);
#line 742
    VP8EncDspInit_body_lock.__data.__lock = 0;
#line 742
    VP8EncDspInit_body_lock.__data.__count = 0U;
#line 742
    VP8EncDspInit_body_lock.__data.__owner = 0;
#line 742
    VP8EncDspInit_body_lock.__data.__nusers = 0U;
#line 742
    VP8EncDspInit_body_lock.__data.__kind = 0;
#line 742
    VP8EncDspInit_body_lock.__data.__spins = (short)0;
#line 742
    VP8EncDspInit_body_lock.__data.__elision = (short)0;
#line 742
    VP8EncDspInit_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 742
    VP8EncDspInit_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 742
    __cil_tmp3 = pthread_mutex_lock(& VP8EncDspInit_body_lock);
    }
#line 742
    if (__cil_tmp3) {
#line 742
      goto while_break;
    }
#line 742
    if ((unsigned long )VP8EncDspInit_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 742
      VP8EncDspInit_body();
      }
    }
    {
#line 742
    VP8EncDspInit_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 742
    pthread_mutex_unlock(& VP8EncDspInit_body_lock);
    }
#line 742
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 746
  return;
}
}
#line 742 "/root/patron-new/new_3/src/dsp/enc.c"
static void VP8EncDspInit_body(void) 
{ 
  int __cil_tmp1 ;
  int __cil_tmp2 ;

  {
  {
#line 743
  VP8DspInit();
#line 744
  InitTables();
#line 748
  VP8ITransform = & ITransform_C;
#line 749
  VP8FTransform = & FTransform_C;
#line 750
  VP8FTransformWHT = & FTransformWHT_C;
#line 751
  VP8TDisto4x4 = (int (*)(uint8_t * , uint8_t * , uint16_t * const   ))(& Disto4x4_C);
#line 752
  VP8TDisto16x16 = (int (*)(uint8_t * , uint8_t * , uint16_t * const   ))(& Disto16x16_C);
#line 753
  VP8CollectHistogram = (void (*)(uint8_t * , uint8_t * , int  , int  , VP8Histogram * const   ))(& CollectHistogram_C);
#line 754
  VP8SSE16x16 = & SSE16x16_C;
#line 755
  VP8SSE16x8 = & SSE16x8_C;
#line 756
  VP8SSE8x8 = & SSE8x8_C;
#line 757
  VP8SSE4x4 = & SSE4x4_C;
#line 761
  VP8EncQuantizeBlock = (int (*)(int16_t * , int16_t * , struct VP8Matrix * const   ))(& QuantizeBlock_C);
#line 762
  VP8EncQuantize2Blocks = (int (*)(int16_t * , int16_t * , struct VP8Matrix * const   ))(& Quantize2Blocks_C);
#line 765
  VP8FTransform2 = & FTransform2_C;
#line 766
  VP8EncPredLuma4 = & Intra4Preds_C;
#line 767
  VP8EncPredLuma16 = & Intra16Preds_C;
#line 768
  VP8EncPredChroma8 = & IntraChromaPreds_C;
#line 769
  VP8Mean16x4 = & Mean16x4_C;
#line 770
  VP8EncQuantizeBlockWHT = (int (*)(int16_t * , int16_t * , struct VP8Matrix * const   ))(& QuantizeBlock_C);
#line 771
  VP8Copy4x4 = & Copy4x4_C;
#line 772
  VP8Copy16x8 = & Copy16x8_C;
  }
#line 775
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
    {
#line 777
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 777
    if (__cil_tmp1) {
      {
#line 778
      VP8EncDspInitSSE2();
#line 780
      __cil_tmp2 = (*VP8GetCPUInfo)((CPUFeature )3);
      }
#line 780
      if (__cil_tmp2) {
        {
#line 781
        VP8EncDspInitSSE41();
        }
      }
    }
  }
#line 786
  return;
}
}
#line 23 "/root/patron-new/new_3/src/dsp/dec_clip_tables.c"
static uint8_t abs0[511]  = 
#line 23 "/root/patron-new/new_3/src/dsp/dec_clip_tables.c"
  {      (uint8_t )255,      (uint8_t )254,      (uint8_t )253,      (uint8_t )252, 
        (uint8_t )251,      (uint8_t )250,      (uint8_t )249,      (uint8_t )248, 
        (uint8_t )247,      (uint8_t )246,      (uint8_t )245,      (uint8_t )244, 
        (uint8_t )243,      (uint8_t )242,      (uint8_t )241,      (uint8_t )240, 
        (uint8_t )239,      (uint8_t )238,      (uint8_t )237,      (uint8_t )236, 
        (uint8_t )235,      (uint8_t )234,      (uint8_t )233,      (uint8_t )232, 
        (uint8_t )231,      (uint8_t )230,      (uint8_t )229,      (uint8_t )228, 
        (uint8_t )227,      (uint8_t )226,      (uint8_t )225,      (uint8_t )224, 
        (uint8_t )223,      (uint8_t )222,      (uint8_t )221,      (uint8_t )220, 
        (uint8_t )219,      (uint8_t )218,      (uint8_t )217,      (uint8_t )216, 
        (uint8_t )215,      (uint8_t )214,      (uint8_t )213,      (uint8_t )212, 
        (uint8_t )211,      (uint8_t )210,      (uint8_t )209,      (uint8_t )208, 
        (uint8_t )207,      (uint8_t )206,      (uint8_t )205,      (uint8_t )204, 
        (uint8_t )203,      (uint8_t )202,      (uint8_t )201,      (uint8_t )200, 
        (uint8_t )199,      (uint8_t )198,      (uint8_t )197,      (uint8_t )196, 
        (uint8_t )195,      (uint8_t )194,      (uint8_t )193,      (uint8_t )192, 
        (uint8_t )191,      (uint8_t )190,      (uint8_t )189,      (uint8_t )188, 
        (uint8_t )187,      (uint8_t )186,      (uint8_t )185,      (uint8_t )184, 
        (uint8_t )183,      (uint8_t )182,      (uint8_t )181,      (uint8_t )180, 
        (uint8_t )179,      (uint8_t )178,      (uint8_t )177,      (uint8_t )176, 
        (uint8_t )175,      (uint8_t )174,      (uint8_t )173,      (uint8_t )172, 
        (uint8_t )171,      (uint8_t )170,      (uint8_t )169,      (uint8_t )168, 
        (uint8_t )167,      (uint8_t )166,      (uint8_t )165,      (uint8_t )164, 
        (uint8_t )163,      (uint8_t )162,      (uint8_t )161,      (uint8_t )160, 
        (uint8_t )159,      (uint8_t )158,      (uint8_t )157,      (uint8_t )156, 
        (uint8_t )155,      (uint8_t )154,      (uint8_t )153,      (uint8_t )152, 
        (uint8_t )151,      (uint8_t )150,      (uint8_t )149,      (uint8_t )148, 
        (uint8_t )147,      (uint8_t )146,      (uint8_t )145,      (uint8_t )144, 
        (uint8_t )143,      (uint8_t )142,      (uint8_t )141,      (uint8_t )140, 
        (uint8_t )139,      (uint8_t )138,      (uint8_t )137,      (uint8_t )136, 
        (uint8_t )135,      (uint8_t )134,      (uint8_t )133,      (uint8_t )132, 
        (uint8_t )131,      (uint8_t )130,      (uint8_t )129,      (uint8_t )128, 
        (uint8_t )127,      (uint8_t )126,      (uint8_t )125,      (uint8_t )124, 
        (uint8_t )123,      (uint8_t )122,      (uint8_t )121,      (uint8_t )120, 
        (uint8_t )119,      (uint8_t )118,      (uint8_t )117,      (uint8_t )116, 
        (uint8_t )115,      (uint8_t )114,      (uint8_t )113,      (uint8_t )112, 
        (uint8_t )111,      (uint8_t )110,      (uint8_t )109,      (uint8_t )108, 
        (uint8_t )107,      (uint8_t )106,      (uint8_t )105,      (uint8_t )104, 
        (uint8_t )103,      (uint8_t )102,      (uint8_t )101,      (uint8_t )100, 
        (uint8_t )99,      (uint8_t )98,      (uint8_t )97,      (uint8_t )96, 
        (uint8_t )95,      (uint8_t )94,      (uint8_t )93,      (uint8_t )92, 
        (uint8_t )91,      (uint8_t )90,      (uint8_t )89,      (uint8_t )88, 
        (uint8_t )87,      (uint8_t )86,      (uint8_t )85,      (uint8_t )84, 
        (uint8_t )83,      (uint8_t )82,      (uint8_t )81,      (uint8_t )80, 
        (uint8_t )79,      (uint8_t )78,      (uint8_t )77,      (uint8_t )76, 
        (uint8_t )75,      (uint8_t )74,      (uint8_t )73,      (uint8_t )72, 
        (uint8_t )71,      (uint8_t )70,      (uint8_t )69,      (uint8_t )68, 
        (uint8_t )67,      (uint8_t )66,      (uint8_t )65,      (uint8_t )64, 
        (uint8_t )63,      (uint8_t )62,      (uint8_t )61,      (uint8_t )60, 
        (uint8_t )59,      (uint8_t )58,      (uint8_t )57,      (uint8_t )56, 
        (uint8_t )55,      (uint8_t )54,      (uint8_t )53,      (uint8_t )52, 
        (uint8_t )51,      (uint8_t )50,      (uint8_t )49,      (uint8_t )48, 
        (uint8_t )47,      (uint8_t )46,      (uint8_t )45,      (uint8_t )44, 
        (uint8_t )43,      (uint8_t )42,      (uint8_t )41,      (uint8_t )40, 
        (uint8_t )39,      (uint8_t )38,      (uint8_t )37,      (uint8_t )36, 
        (uint8_t )35,      (uint8_t )34,      (uint8_t )33,      (uint8_t )32, 
        (uint8_t )31,      (uint8_t )30,      (uint8_t )29,      (uint8_t )28, 
        (uint8_t )27,      (uint8_t )26,      (uint8_t )25,      (uint8_t )24, 
        (uint8_t )23,      (uint8_t )22,      (uint8_t )21,      (uint8_t )20, 
        (uint8_t )19,      (uint8_t )18,      (uint8_t )17,      (uint8_t )16, 
        (uint8_t )15,      (uint8_t )14,      (uint8_t )13,      (uint8_t )12, 
        (uint8_t )11,      (uint8_t )10,      (uint8_t )9,      (uint8_t )8, 
        (uint8_t )7,      (uint8_t )6,      (uint8_t )5,      (uint8_t )4, 
        (uint8_t )3,      (uint8_t )2,      (uint8_t )1,      (uint8_t )0, 
        (uint8_t )1,      (uint8_t )2,      (uint8_t )3,      (uint8_t )4, 
        (uint8_t )5,      (uint8_t )6,      (uint8_t )7,      (uint8_t )8, 
        (uint8_t )9,      (uint8_t )10,      (uint8_t )11,      (uint8_t )12, 
        (uint8_t )13,      (uint8_t )14,      (uint8_t )15,      (uint8_t )16, 
        (uint8_t )17,      (uint8_t )18,      (uint8_t )19,      (uint8_t )20, 
        (uint8_t )21,      (uint8_t )22,      (uint8_t )23,      (uint8_t )24, 
        (uint8_t )25,      (uint8_t )26,      (uint8_t )27,      (uint8_t )28, 
        (uint8_t )29,      (uint8_t )30,      (uint8_t )31,      (uint8_t )32, 
        (uint8_t )33,      (uint8_t )34,      (uint8_t )35,      (uint8_t )36, 
        (uint8_t )37,      (uint8_t )38,      (uint8_t )39,      (uint8_t )40, 
        (uint8_t )41,      (uint8_t )42,      (uint8_t )43,      (uint8_t )44, 
        (uint8_t )45,      (uint8_t )46,      (uint8_t )47,      (uint8_t )48, 
        (uint8_t )49,      (uint8_t )50,      (uint8_t )51,      (uint8_t )52, 
        (uint8_t )53,      (uint8_t )54,      (uint8_t )55,      (uint8_t )56, 
        (uint8_t )57,      (uint8_t )58,      (uint8_t )59,      (uint8_t )60, 
        (uint8_t )61,      (uint8_t )62,      (uint8_t )63,      (uint8_t )64, 
        (uint8_t )65,      (uint8_t )66,      (uint8_t )67,      (uint8_t )68, 
        (uint8_t )69,      (uint8_t )70,      (uint8_t )71,      (uint8_t )72, 
        (uint8_t )73,      (uint8_t )74,      (uint8_t )75,      (uint8_t )76, 
        (uint8_t )77,      (uint8_t )78,      (uint8_t )79,      (uint8_t )80, 
        (uint8_t )81,      (uint8_t )82,      (uint8_t )83,      (uint8_t )84, 
        (uint8_t )85,      (uint8_t )86,      (uint8_t )87,      (uint8_t )88, 
        (uint8_t )89,      (uint8_t )90,      (uint8_t )91,      (uint8_t )92, 
        (uint8_t )93,      (uint8_t )94,      (uint8_t )95,      (uint8_t )96, 
        (uint8_t )97,      (uint8_t )98,      (uint8_t )99,      (uint8_t )100, 
        (uint8_t )101,      (uint8_t )102,      (uint8_t )103,      (uint8_t )104, 
        (uint8_t )105,      (uint8_t )106,      (uint8_t )107,      (uint8_t )108, 
        (uint8_t )109,      (uint8_t )110,      (uint8_t )111,      (uint8_t )112, 
        (uint8_t )113,      (uint8_t )114,      (uint8_t )115,      (uint8_t )116, 
        (uint8_t )117,      (uint8_t )118,      (uint8_t )119,      (uint8_t )120, 
        (uint8_t )121,      (uint8_t )122,      (uint8_t )123,      (uint8_t )124, 
        (uint8_t )125,      (uint8_t )126,      (uint8_t )127,      (uint8_t )128, 
        (uint8_t )129,      (uint8_t )130,      (uint8_t )131,      (uint8_t )132, 
        (uint8_t )133,      (uint8_t )134,      (uint8_t )135,      (uint8_t )136, 
        (uint8_t )137,      (uint8_t )138,      (uint8_t )139,      (uint8_t )140, 
        (uint8_t )141,      (uint8_t )142,      (uint8_t )143,      (uint8_t )144, 
        (uint8_t )145,      (uint8_t )146,      (uint8_t )147,      (uint8_t )148, 
        (uint8_t )149,      (uint8_t )150,      (uint8_t )151,      (uint8_t )152, 
        (uint8_t )153,      (uint8_t )154,      (uint8_t )155,      (uint8_t )156, 
        (uint8_t )157,      (uint8_t )158,      (uint8_t )159,      (uint8_t )160, 
        (uint8_t )161,      (uint8_t )162,      (uint8_t )163,      (uint8_t )164, 
        (uint8_t )165,      (uint8_t )166,      (uint8_t )167,      (uint8_t )168, 
        (uint8_t )169,      (uint8_t )170,      (uint8_t )171,      (uint8_t )172, 
        (uint8_t )173,      (uint8_t )174,      (uint8_t )175,      (uint8_t )176, 
        (uint8_t )177,      (uint8_t )178,      (uint8_t )179,      (uint8_t )180, 
        (uint8_t )181,      (uint8_t )182,      (uint8_t )183,      (uint8_t )184, 
        (uint8_t )185,      (uint8_t )186,      (uint8_t )187,      (uint8_t )188, 
        (uint8_t )189,      (uint8_t )190,      (uint8_t )191,      (uint8_t )192, 
        (uint8_t )193,      (uint8_t )194,      (uint8_t )195,      (uint8_t )196, 
        (uint8_t )197,      (uint8_t )198,      (uint8_t )199,      (uint8_t )200, 
        (uint8_t )201,      (uint8_t )202,      (uint8_t )203,      (uint8_t )204, 
        (uint8_t )205,      (uint8_t )206,      (uint8_t )207,      (uint8_t )208, 
        (uint8_t )209,      (uint8_t )210,      (uint8_t )211,      (uint8_t )212, 
        (uint8_t )213,      (uint8_t )214,      (uint8_t )215,      (uint8_t )216, 
        (uint8_t )217,      (uint8_t )218,      (uint8_t )219,      (uint8_t )220, 
        (uint8_t )221,      (uint8_t )222,      (uint8_t )223,      (uint8_t )224, 
        (uint8_t )225,      (uint8_t )226,      (uint8_t )227,      (uint8_t )228, 
        (uint8_t )229,      (uint8_t )230,      (uint8_t )231,      (uint8_t )232, 
        (uint8_t )233,      (uint8_t )234,      (uint8_t )235,      (uint8_t )236, 
        (uint8_t )237,      (uint8_t )238,      (uint8_t )239,      (uint8_t )240, 
        (uint8_t )241,      (uint8_t )242,      (uint8_t )243,      (uint8_t )244, 
        (uint8_t )245,      (uint8_t )246,      (uint8_t )247,      (uint8_t )248, 
        (uint8_t )249,      (uint8_t )250,      (uint8_t )251,      (uint8_t )252, 
        (uint8_t )253,      (uint8_t )254,      (uint8_t )255};
#line 69 "/root/patron-new/new_3/src/dsp/dec_clip_tables.c"
static uint8_t sclip1[2041]  = 
#line 69
  {      (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )128,      (uint8_t )128,      (uint8_t )128, 
        (uint8_t )128,      (uint8_t )129,      (uint8_t )130,      (uint8_t )131, 
        (uint8_t )132,      (uint8_t )133,      (uint8_t )134,      (uint8_t )135, 
        (uint8_t )136,      (uint8_t )137,      (uint8_t )138,      (uint8_t )139, 
        (uint8_t )140,      (uint8_t )141,      (uint8_t )142,      (uint8_t )143, 
        (uint8_t )144,      (uint8_t )145,      (uint8_t )146,      (uint8_t )147, 
        (uint8_t )148,      (uint8_t )149,      (uint8_t )150,      (uint8_t )151, 
        (uint8_t )152,      (uint8_t )153,      (uint8_t )154,      (uint8_t )155, 
        (uint8_t )156,      (uint8_t )157,      (uint8_t )158,      (uint8_t )159, 
        (uint8_t )160,      (uint8_t )161,      (uint8_t )162,      (uint8_t )163, 
        (uint8_t )164,      (uint8_t )165,      (uint8_t )166,      (uint8_t )167, 
        (uint8_t )168,      (uint8_t )169,      (uint8_t )170,      (uint8_t )171, 
        (uint8_t )172,      (uint8_t )173,      (uint8_t )174,      (uint8_t )175, 
        (uint8_t )176,      (uint8_t )177,      (uint8_t )178,      (uint8_t )179, 
        (uint8_t )180,      (uint8_t )181,      (uint8_t )182,      (uint8_t )183, 
        (uint8_t )184,      (uint8_t )185,      (uint8_t )186,      (uint8_t )187, 
        (uint8_t )188,      (uint8_t )189,      (uint8_t )190,      (uint8_t )191, 
        (uint8_t )192,      (uint8_t )193,      (uint8_t )194,      (uint8_t )195, 
        (uint8_t )196,      (uint8_t )197,      (uint8_t )198,      (uint8_t )199, 
        (uint8_t )200,      (uint8_t )201,      (uint8_t )202,      (uint8_t )203, 
        (uint8_t )204,      (uint8_t )205,      (uint8_t )206,      (uint8_t )207, 
        (uint8_t )208,      (uint8_t )209,      (uint8_t )210,      (uint8_t )211, 
        (uint8_t )212,      (uint8_t )213,      (uint8_t )214,      (uint8_t )215, 
        (uint8_t )216,      (uint8_t )217,      (uint8_t )218,      (uint8_t )219, 
        (uint8_t )220,      (uint8_t )221,      (uint8_t )222,      (uint8_t )223, 
        (uint8_t )224,      (uint8_t )225,      (uint8_t )226,      (uint8_t )227, 
        (uint8_t )228,      (uint8_t )229,      (uint8_t )230,      (uint8_t )231, 
        (uint8_t )232,      (uint8_t )233,      (uint8_t )234,      (uint8_t )235, 
        (uint8_t )236,      (uint8_t )237,      (uint8_t )238,      (uint8_t )239, 
        (uint8_t )240,      (uint8_t )241,      (uint8_t )242,      (uint8_t )243, 
        (uint8_t )244,      (uint8_t )245,      (uint8_t )246,      (uint8_t )247, 
        (uint8_t )248,      (uint8_t )249,      (uint8_t )250,      (uint8_t )251, 
        (uint8_t )252,      (uint8_t )253,      (uint8_t )254,      (uint8_t )255, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )64,      (uint8_t )65,      (uint8_t )66,      (uint8_t )67, 
        (uint8_t )68,      (uint8_t )69,      (uint8_t )70,      (uint8_t )71, 
        (uint8_t )72,      (uint8_t )73,      (uint8_t )74,      (uint8_t )75, 
        (uint8_t )76,      (uint8_t )77,      (uint8_t )78,      (uint8_t )79, 
        (uint8_t )80,      (uint8_t )81,      (uint8_t )82,      (uint8_t )83, 
        (uint8_t )84,      (uint8_t )85,      (uint8_t )86,      (uint8_t )87, 
        (uint8_t )88,      (uint8_t )89,      (uint8_t )90,      (uint8_t )91, 
        (uint8_t )92,      (uint8_t )93,      (uint8_t )94,      (uint8_t )95, 
        (uint8_t )96,      (uint8_t )97,      (uint8_t )98,      (uint8_t )99, 
        (uint8_t )100,      (uint8_t )101,      (uint8_t )102,      (uint8_t )103, 
        (uint8_t )104,      (uint8_t )105,      (uint8_t )106,      (uint8_t )107, 
        (uint8_t )108,      (uint8_t )109,      (uint8_t )110,      (uint8_t )111, 
        (uint8_t )112,      (uint8_t )113,      (uint8_t )114,      (uint8_t )115, 
        (uint8_t )116,      (uint8_t )117,      (uint8_t )118,      (uint8_t )119, 
        (uint8_t )120,      (uint8_t )121,      (uint8_t )122,      (uint8_t )123, 
        (uint8_t )124,      (uint8_t )125,      (uint8_t )126,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127, 
        (uint8_t )127,      (uint8_t )127,      (uint8_t )127,      (uint8_t )127};
#line 242 "/root/patron-new/new_3/src/dsp/dec_clip_tables.c"
static uint8_t sclip2[225]  = 
#line 242
  {      (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )240,      (uint8_t )240,      (uint8_t )240, 
        (uint8_t )240,      (uint8_t )241,      (uint8_t )242,      (uint8_t )243, 
        (uint8_t )244,      (uint8_t )245,      (uint8_t )246,      (uint8_t )247, 
        (uint8_t )248,      (uint8_t )249,      (uint8_t )250,      (uint8_t )251, 
        (uint8_t )252,      (uint8_t )253,      (uint8_t )254,      (uint8_t )255, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15, 
        (uint8_t )15,      (uint8_t )15,      (uint8_t )15,      (uint8_t )15};
#line 264 "/root/patron-new/new_3/src/dsp/dec_clip_tables.c"
static uint8_t clip1___0[767]  = 
#line 264
  {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0, 
        (uint8_t )1,      (uint8_t )2,      (uint8_t )3,      (uint8_t )4, 
        (uint8_t )5,      (uint8_t )6,      (uint8_t )7,      (uint8_t )8, 
        (uint8_t )9,      (uint8_t )10,      (uint8_t )11,      (uint8_t )12, 
        (uint8_t )13,      (uint8_t )14,      (uint8_t )15,      (uint8_t )16, 
        (uint8_t )17,      (uint8_t )18,      (uint8_t )19,      (uint8_t )20, 
        (uint8_t )21,      (uint8_t )22,      (uint8_t )23,      (uint8_t )24, 
        (uint8_t )25,      (uint8_t )26,      (uint8_t )27,      (uint8_t )28, 
        (uint8_t )29,      (uint8_t )30,      (uint8_t )31,      (uint8_t )32, 
        (uint8_t )33,      (uint8_t )34,      (uint8_t )35,      (uint8_t )36, 
        (uint8_t )37,      (uint8_t )38,      (uint8_t )39,      (uint8_t )40, 
        (uint8_t )41,      (uint8_t )42,      (uint8_t )43,      (uint8_t )44, 
        (uint8_t )45,      (uint8_t )46,      (uint8_t )47,      (uint8_t )48, 
        (uint8_t )49,      (uint8_t )50,      (uint8_t )51,      (uint8_t )52, 
        (uint8_t )53,      (uint8_t )54,      (uint8_t )55,      (uint8_t )56, 
        (uint8_t )57,      (uint8_t )58,      (uint8_t )59,      (uint8_t )60, 
        (uint8_t )61,      (uint8_t )62,      (uint8_t )63,      (uint8_t )64, 
        (uint8_t )65,      (uint8_t )66,      (uint8_t )67,      (uint8_t )68, 
        (uint8_t )69,      (uint8_t )70,      (uint8_t )71,      (uint8_t )72, 
        (uint8_t )73,      (uint8_t )74,      (uint8_t )75,      (uint8_t )76, 
        (uint8_t )77,      (uint8_t )78,      (uint8_t )79,      (uint8_t )80, 
        (uint8_t )81,      (uint8_t )82,      (uint8_t )83,      (uint8_t )84, 
        (uint8_t )85,      (uint8_t )86,      (uint8_t )87,      (uint8_t )88, 
        (uint8_t )89,      (uint8_t )90,      (uint8_t )91,      (uint8_t )92, 
        (uint8_t )93,      (uint8_t )94,      (uint8_t )95,      (uint8_t )96, 
        (uint8_t )97,      (uint8_t )98,      (uint8_t )99,      (uint8_t )100, 
        (uint8_t )101,      (uint8_t )102,      (uint8_t )103,      (uint8_t )104, 
        (uint8_t )105,      (uint8_t )106,      (uint8_t )107,      (uint8_t )108, 
        (uint8_t )109,      (uint8_t )110,      (uint8_t )111,      (uint8_t )112, 
        (uint8_t )113,      (uint8_t )114,      (uint8_t )115,      (uint8_t )116, 
        (uint8_t )117,      (uint8_t )118,      (uint8_t )119,      (uint8_t )120, 
        (uint8_t )121,      (uint8_t )122,      (uint8_t )123,      (uint8_t )124, 
        (uint8_t )125,      (uint8_t )126,      (uint8_t )127,      (uint8_t )128, 
        (uint8_t )129,      (uint8_t )130,      (uint8_t )131,      (uint8_t )132, 
        (uint8_t )133,      (uint8_t )134,      (uint8_t )135,      (uint8_t )136, 
        (uint8_t )137,      (uint8_t )138,      (uint8_t )139,      (uint8_t )140, 
        (uint8_t )141,      (uint8_t )142,      (uint8_t )143,      (uint8_t )144, 
        (uint8_t )145,      (uint8_t )146,      (uint8_t )147,      (uint8_t )148, 
        (uint8_t )149,      (uint8_t )150,      (uint8_t )151,      (uint8_t )152, 
        (uint8_t )153,      (uint8_t )154,      (uint8_t )155,      (uint8_t )156, 
        (uint8_t )157,      (uint8_t )158,      (uint8_t )159,      (uint8_t )160, 
        (uint8_t )161,      (uint8_t )162,      (uint8_t )163,      (uint8_t )164, 
        (uint8_t )165,      (uint8_t )166,      (uint8_t )167,      (uint8_t )168, 
        (uint8_t )169,      (uint8_t )170,      (uint8_t )171,      (uint8_t )172, 
        (uint8_t )173,      (uint8_t )174,      (uint8_t )175,      (uint8_t )176, 
        (uint8_t )177,      (uint8_t )178,      (uint8_t )179,      (uint8_t )180, 
        (uint8_t )181,      (uint8_t )182,      (uint8_t )183,      (uint8_t )184, 
        (uint8_t )185,      (uint8_t )186,      (uint8_t )187,      (uint8_t )188, 
        (uint8_t )189,      (uint8_t )190,      (uint8_t )191,      (uint8_t )192, 
        (uint8_t )193,      (uint8_t )194,      (uint8_t )195,      (uint8_t )196, 
        (uint8_t )197,      (uint8_t )198,      (uint8_t )199,      (uint8_t )200, 
        (uint8_t )201,      (uint8_t )202,      (uint8_t )203,      (uint8_t )204, 
        (uint8_t )205,      (uint8_t )206,      (uint8_t )207,      (uint8_t )208, 
        (uint8_t )209,      (uint8_t )210,      (uint8_t )211,      (uint8_t )212, 
        (uint8_t )213,      (uint8_t )214,      (uint8_t )215,      (uint8_t )216, 
        (uint8_t )217,      (uint8_t )218,      (uint8_t )219,      (uint8_t )220, 
        (uint8_t )221,      (uint8_t )222,      (uint8_t )223,      (uint8_t )224, 
        (uint8_t )225,      (uint8_t )226,      (uint8_t )227,      (uint8_t )228, 
        (uint8_t )229,      (uint8_t )230,      (uint8_t )231,      (uint8_t )232, 
        (uint8_t )233,      (uint8_t )234,      (uint8_t )235,      (uint8_t )236, 
        (uint8_t )237,      (uint8_t )238,      (uint8_t )239,      (uint8_t )240, 
        (uint8_t )241,      (uint8_t )242,      (uint8_t )243,      (uint8_t )244, 
        (uint8_t )245,      (uint8_t )246,      (uint8_t )247,      (uint8_t )248, 
        (uint8_t )249,      (uint8_t )250,      (uint8_t )251,      (uint8_t )252, 
        (uint8_t )253,      (uint8_t )254,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255};
#line 345 "/root/patron-new/new_3/src/dsp/dec_clip_tables.c"
int8_t * const  VP8ksclip1  =    (int8_t */* const  */)((int8_t *)(& sclip1[1020]));
#line 346 "/root/patron-new/new_3/src/dsp/dec_clip_tables.c"
int8_t * const  VP8ksclip2  =    (int8_t */* const  */)((int8_t *)(& sclip2[112]));
#line 347 "/root/patron-new/new_3/src/dsp/dec_clip_tables.c"
uint8_t * const  VP8kclip1  =    (uint8_t */* const  */)(& clip1___0[255]);
#line 348 "/root/patron-new/new_3/src/dsp/dec_clip_tables.c"
uint8_t * const  VP8kabs0  =    (uint8_t */* const  */)(& abs0[255]);
#line 350 "/root/patron-new/new_3/src/dsp/dec_clip_tables.c"
void VP8InitClipTables(void) 
{ 


  {
#line 355
  return;
}
}
#line 271 "../../src/dec/vp8i_dec.h"
int VP8SetError(VP8Decoder *dec , VP8StatusCode error , char const   *msg ) ;
#line 275
void VP8ResetProba(VP8Proba *proba ) ;
#line 276
void VP8ParseProba(VP8BitReader *br , VP8Decoder *dec ) ;
#line 278
int VP8ParseIntraModeRow(VP8BitReader *br , VP8Decoder *dec ) ;
#line 281
void VP8ParseQuant(VP8Decoder *dec ) ;
#line 284
int VP8InitFrame(VP8Decoder *dec , VP8Io *io ) ;
#line 289
VP8StatusCode VP8EnterCritical(VP8Decoder *dec , VP8Io *io ) ;
#line 292
int VP8ExitCritical(VP8Decoder *dec , VP8Io *io ) ;
#line 295
int VP8GetThreadMethod(WebPDecoderOptions *options , WebPHeaderStructure *headers ,
                       int width , int height ) ;
#line 299
void VP8InitDithering(WebPDecoderOptions *options , VP8Decoder *dec ) ;
#line 302
int VP8ProcessRow(VP8Decoder *dec , VP8Io *io ) ;
#line 304
void VP8InitScanline(VP8Decoder *dec ) ;
#line 306
int VP8DecodeMB(VP8Decoder *dec , VP8BitReader *token_br ) ;
#line 309
uint8_t *VP8DecompressAlphaRows(VP8Decoder *dec , VP8Io *io , int row , int num_rows ) ;
#line 44 "/root/patron-new/new_3/src/dsp/dec.c"
static void TransformOne_C(int16_t *in , uint8_t *dst ) 
{ 
  int C[16] ;
  int *tmp___0 ;
  int i ;
  int a ;
  int b ;
  int c ;
  int d ;
  int dc ;
  int a___0 ;
  int b___0 ;
  int c___0 ;
  int d___0 ;

  {
#line 47
  tmp___0 = C;
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;

#line 48
    if (! (i < 4)) {
#line 48
      goto while_break;
    }
#line 49
    a = (int )*(in + 0) + (int )*(in + 8);
#line 50
    b = (int )*(in + 0) - (int )*(in + 8);
#line 51
    c = ((int )*(in + 4) * 35468 >> 16) - (((int )*(in + 12) * 20091 >> 16) + (int )*(in + 12));
#line 52
    d = (((int )*(in + 4) * 20091 >> 16) + (int )*(in + 4)) + ((int )*(in + 12) * 35468 >> 16);
#line 53
    *(tmp___0 + 0) = a + d;
#line 54
    *(tmp___0 + 1) = b + c;
#line 55
    *(tmp___0 + 2) = b - c;
#line 56
    *(tmp___0 + 3) = a - d;
#line 57
    tmp___0 += 4;
#line 58
    in ++;
#line 48
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 67
  tmp___0 = C;
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 68
    if (! (i < 4)) {
#line 68
      goto while_break___0;
    }
    {
#line 69
    dc = *(tmp___0 + 0) + 4;
#line 70
    a___0 = dc + *(tmp___0 + 8);
#line 71
    b___0 = dc - *(tmp___0 + 8);
#line 72
    c___0 = (*(tmp___0 + 4) * 35468 >> 16) - ((*(tmp___0 + 12) * 20091 >> 16) + *(tmp___0 + 12));
#line 73
    d___0 = ((*(tmp___0 + 4) * 20091 >> 16) + *(tmp___0 + 4)) + (*(tmp___0 + 12) * 35468 >> 16);
#line 74
    *(dst + 0) = clip_8b___1((int )*(dst + 0) + ((a___0 + d___0) >> 3));
#line 75
    *(dst + 1) = clip_8b___1((int )*(dst + 1) + ((b___0 + c___0) >> 3));
#line 76
    *(dst + 2) = clip_8b___1((int )*(dst + 2) + ((b___0 - c___0) >> 3));
#line 77
    *(dst + 3) = clip_8b___1((int )*(dst + 3) + ((a___0 - d___0) >> 3));
#line 78
    tmp___0 ++;
#line 79
    dst += 32;
#line 68
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 72
  return;
}
}
#line 84 "/root/patron-new/new_3/src/dsp/dec.c"
static void TransformAC3_C(int16_t *in , uint8_t *dst ) 
{ 
  int a ;
  int c4 ;
  int d4 ;
  int c1 ;
  int d1 ;
  int DC ;
  int DC___0 ;
  int DC___1 ;
  int DC___2 ;

  {
#line 85
  a = (int )*(in + 0) + 4;
#line 86
  c4 = (int )*(in + 4) * 35468 >> 16;
#line 87
  d4 = ((int )*(in + 4) * 20091 >> 16) + (int )*(in + 4);
#line 88
  c1 = (int )*(in + 1) * 35468 >> 16;
#line 89
  d1 = ((int )*(in + 1) * 20091 >> 16) + (int )*(in + 1);
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 90
    DC = a + d4;
#line 90
    *(dst + 0) = clip_8b___1((int )*(dst + 0) + ((DC + d1) >> 3));
#line 90
    *(dst + 1) = clip_8b___1((int )*(dst + 1) + ((DC + c1) >> 3));
#line 90
    *(dst + 2) = clip_8b___1((int )*(dst + 2) + ((DC - c1) >> 3));
#line 90
    *(dst + 3) = clip_8b___1((int )*(dst + 3) + ((DC - d1) >> 3));
    }
#line 90
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 91
    DC___0 = a + c4;
#line 91
    *(dst + 32) = clip_8b___1((int )*(dst + 32) + ((DC___0 + d1) >> 3));
#line 91
    *(dst + 33) = clip_8b___1((int )*(dst + 33) + ((DC___0 + c1) >> 3));
#line 91
    *(dst + 34) = clip_8b___1((int )*(dst + 34) + ((DC___0 - c1) >> 3));
#line 91
    *(dst + 35) = clip_8b___1((int )*(dst + 35) + ((DC___0 - d1) >> 3));
    }
#line 91
    goto while_break___0;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: ;
  {
#line 92
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 92
    DC___1 = a - c4;
#line 92
    *(dst + 64) = clip_8b___1((int )*(dst + 64) + ((DC___1 + d1) >> 3));
#line 92
    *(dst + 65) = clip_8b___1((int )*(dst + 65) + ((DC___1 + c1) >> 3));
#line 92
    *(dst + 66) = clip_8b___1((int )*(dst + 66) + ((DC___1 - c1) >> 3));
#line 92
    *(dst + 67) = clip_8b___1((int )*(dst + 67) + ((DC___1 - d1) >> 3));
    }
#line 92
    goto while_break___1;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
  {
#line 93
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 93
    DC___2 = a - d4;
#line 93
    *(dst + 96) = clip_8b___1((int )*(dst + 96) + ((DC___2 + d1) >> 3));
#line 93
    *(dst + 97) = clip_8b___1((int )*(dst + 97) + ((DC___2 + c1) >> 3));
#line 93
    *(dst + 98) = clip_8b___1((int )*(dst + 98) + ((DC___2 - c1) >> 3));
#line 93
    *(dst + 99) = clip_8b___1((int )*(dst + 99) + ((DC___2 - d1) >> 3));
    }
#line 93
    goto while_break___2;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 97
  return;
}
}
#line 99 "/root/patron-new/new_3/src/dsp/dec.c"
static void TransformTwo_C(int16_t *in , uint8_t *dst , int do_two ) 
{ 


  {
  {
#line 100
  TransformOne_C(in, dst);
  }
#line 101
  if (do_two) {
    {
#line 102
    TransformOne_C(in + 16, dst + 4);
    }
  }
#line 105
  return;
}
}
#line 107 "/root/patron-new/new_3/src/dsp/dec.c"
static void TransformUV_C(int16_t *in , uint8_t *dst ) 
{ 


  {
  {
#line 108
  (*VP8Transform)(in + 0, dst, 1);
#line 109
  (*VP8Transform)(in + 32, dst + 128, 1);
  }
#line 111
  return;
}
}
#line 113 "/root/patron-new/new_3/src/dsp/dec.c"
static void TransformDC_C(int16_t *in , uint8_t *dst ) 
{ 
  int DC ;
  int i ;
  int j ;

  {
#line 114
  DC = (int )*(in + 0) + 4;
#line 116
  j = 0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;

#line 116
    if (! (j < 4)) {
#line 116
      goto while_break;
    }
#line 117
    i = 0;
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 117
      if (! (i < 4)) {
#line 117
        goto while_break___0;
      }
      {
#line 118
      *(dst + (i + j * 32)) = clip_8b___1((int )*(dst + (i + j * 32)) + (DC >> 3));
#line 117
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 116
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 120
  return;
}
}
#line 124 "/root/patron-new/new_3/src/dsp/dec.c"
static void TransformDCUV_C(int16_t *in , uint8_t *dst ) 
{ 


  {
#line 125
  if (*(in + 0)) {
    {
#line 125
    (*VP8TransformDC)(in + 0, dst);
    }
  }
#line 126
  if (*(in + 16)) {
    {
#line 126
    (*VP8TransformDC)(in + 16, dst + 4);
    }
  }
#line 127
  if (*(in + 32)) {
    {
#line 127
    (*VP8TransformDC)(in + 32, dst + 128);
    }
  }
#line 128
  if (*(in + 48)) {
    {
#line 128
    (*VP8TransformDC)(in + 48, (dst + 128) + 4);
    }
  }
#line 131
  return;
}
}
#line 137 "/root/patron-new/new_3/src/dsp/dec.c"
static void TransformWHT_C(int16_t *in , int16_t *out ) 
{ 
  int tmp___0[16] ;
  int i ;
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int dc ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;

  {
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;

#line 140
    if (! (i < 4)) {
#line 140
      goto while_break;
    }
#line 141
    a0 = (int )*(in + i) + (int )*(in + (12 + i));
#line 142
    a1 = (int )*(in + (4 + i)) + (int )*(in + (8 + i));
#line 143
    a2 = (int )*(in + (4 + i)) - (int )*(in + (8 + i));
#line 144
    a3 = (int )*(in + i) - (int )*(in + (12 + i));
#line 145
    tmp___0[i] = a0 + a1;
#line 146
    tmp___0[8 + i] = a0 - a1;
#line 147
    tmp___0[4 + i] = a3 + a2;
#line 148
    tmp___0[12 + i] = a3 - a2;
#line 140
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 150
  i = 0;
  {
#line 150
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 150
    if (! (i < 4)) {
#line 150
      goto while_break___0;
    }
#line 151
    dc = tmp___0[i * 4] + 3;
#line 152
    a0___0 = dc + tmp___0[3 + i * 4];
#line 153
    a1___0 = tmp___0[1 + i * 4] + tmp___0[2 + i * 4];
#line 154
    a2___0 = tmp___0[1 + i * 4] - tmp___0[2 + i * 4];
#line 155
    a3___0 = dc - tmp___0[3 + i * 4];
#line 156
    *(out + 0) = (int16_t )((a0___0 + a1___0) >> 3);
#line 157
    *(out + 16) = (int16_t )((a3___0 + a2___0) >> 3);
#line 158
    *(out + 32) = (int16_t )((a0___0 - a1___0) >> 3);
#line 159
    *(out + 48) = (int16_t )((a3___0 - a2___0) >> 3);
#line 160
    out += 64;
#line 150
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 154
  return;
}
}
#line 173 "/root/patron-new/new_3/src/dsp/dec.c"
__inline static void TrueMotion___0(uint8_t *dst , int size ) 
{ 
  uint8_t *top ;
  uint8_t *clip0 ;
  int y ;
  uint8_t *clip___2 ;
  int x ;

  {
#line 174
  top = dst - 32;
#line 175
  clip0 = (uint8_t *)(VP8kclip1 - (int )*(top + -1));
#line 177
  y = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;

#line 177
    if (! (y < size)) {
#line 177
      goto while_break;
    }
#line 178
    clip___2 = clip0 + (int )*(dst + -1);
#line 180
    x = 0;
    {
#line 180
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 180
      if (! (x < size)) {
#line 180
        goto while_break___0;
      }
#line 181
      *(dst + x) = *(clip___2 + (int )*(top + x));
#line 180
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 183
    dst += 32;
#line 177
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 181
  return;
}
}
#line 186 "/root/patron-new/new_3/src/dsp/dec.c"
static void TM4_C(uint8_t *dst ) 
{ 


  {
  {
#line 186
  TrueMotion___0(dst, 4);
  }
#line 188
  return;
}
}
#line 187 "/root/patron-new/new_3/src/dsp/dec.c"
static void TM8uv_C(uint8_t *dst ) 
{ 


  {
  {
#line 187
  TrueMotion___0(dst, 8);
  }
#line 189
  return;
}
}
#line 188 "/root/patron-new/new_3/src/dsp/dec.c"
static void TM16_C(uint8_t *dst ) 
{ 


  {
  {
#line 188
  TrueMotion___0(dst, 16);
  }
#line 190
  return;
}
}
#line 193 "/root/patron-new/new_3/src/dsp/dec.c"
static void VE16_C(uint8_t *dst ) 
{ 
  int j ;

  {
#line 195
  j = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;

#line 195
    if (! (j < 16)) {
#line 195
      goto while_break;
    }
    {
#line 196
    memcpy((void *)(dst + j * 32), (void const   *)(dst - 32), 16UL);
#line 195
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 199
  return;
}
}
#line 200 "/root/patron-new/new_3/src/dsp/dec.c"
static void HE16_C(uint8_t *dst ) 
{ 
  int j ;

  {
#line 202
  j = 16;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;

#line 202
    if (! (j > 0)) {
#line 202
      goto while_break;
    }
    {
#line 203
    memset((void *)dst, (int )*(dst + -1), 16UL);
#line 204
    dst += 32;
#line 202
    j --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 206
  return;
}
}
#line 208 "/root/patron-new/new_3/src/dsp/dec.c"
__inline static void Put16(int v , uint8_t *dst ) 
{ 
  int j ;

  {
#line 210
  j = 0;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;

#line 210
    if (! (j < 16)) {
#line 210
      goto while_break;
    }
    {
#line 211
    memset((void *)(dst + j * 32), v, 16UL);
#line 210
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 214
  return;
}
}
#line 215 "/root/patron-new/new_3/src/dsp/dec.c"
static void DC16_C(uint8_t *dst ) 
{ 
  int DC ;
  int j ;

  {
#line 216
  DC = 16;
#line 218
  j = 0;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;

#line 218
    if (! (j < 16)) {
#line 218
      goto while_break;
    }
#line 219
    DC += (int )*(dst + (-1 + j * 32)) + (int )*(dst + (j - 32));
#line 218
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 221
  Put16(DC >> 5, dst);
  }
#line 223
  return;
}
}
#line 224 "/root/patron-new/new_3/src/dsp/dec.c"
static void DC16NoTop_C(uint8_t *dst ) 
{ 
  int DC ;
  int j ;

  {
#line 225
  DC = 8;
#line 227
  j = 0;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;

#line 227
    if (! (j < 16)) {
#line 227
      goto while_break;
    }
#line 228
    DC += (int )*(dst + (-1 + j * 32));
#line 227
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 230
  Put16(DC >> 4, dst);
  }
#line 232
  return;
}
}
#line 233 "/root/patron-new/new_3/src/dsp/dec.c"
static void DC16NoLeft_C(uint8_t *dst ) 
{ 
  int DC ;
  int i ;

  {
#line 234
  DC = 8;
#line 236
  i = 0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;

#line 236
    if (! (i < 16)) {
#line 236
      goto while_break;
    }
#line 237
    DC += (int )*(dst + (i - 32));
#line 236
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 239
  Put16(DC >> 4, dst);
  }
#line 241
  return;
}
}
#line 242 "/root/patron-new/new_3/src/dsp/dec.c"
static void DC16NoTopLeft_C(uint8_t *dst ) 
{ 


  {
  {
#line 243
  Put16(128, dst);
  }
#line 245
  return;
}
}
#line 256 "/root/patron-new/new_3/src/dsp/dec.c"
static void VE4_C(uint8_t *dst ) 
{ 
  uint8_t *top ;
  uint8_t vals[4] ;
  int i ;

  {
#line 257
  top = dst - 32;
#line 258
  vals[0] = (uint8_t )(((((int )*(top + -1) + 2 * (int )*(top + 0)) + (int )*(top + 1)) + 2) >> 2);
#line 258
  vals[1] = (uint8_t )(((((int )*(top + 0) + 2 * (int )*(top + 1)) + (int )*(top + 2)) + 2) >> 2);
#line 258
  vals[2] = (uint8_t )(((((int )*(top + 1) + 2 * (int )*(top + 2)) + (int )*(top + 3)) + 2) >> 2);
#line 258
  vals[3] = (uint8_t )(((((int )*(top + 2) + 2 * (int )*(top + 3)) + (int )*(top + 4)) + 2) >> 2);
#line 265
  i = 0;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;

#line 265
    if (! (i < 4)) {
#line 265
      goto while_break;
    }
    {
#line 266
    memcpy((void *)(dst + i * 32), (void const   *)(vals), sizeof(vals));
#line 265
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 269
  return;
}
}
#line 271 "/root/patron-new/new_3/src/dsp/dec.c"
static void HE4_C(uint8_t *dst ) 
{ 
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;

  {
  {
#line 272
  A = (int )*(dst + -33);
#line 273
  B = (int )*(dst + -1);
#line 274
  C = (int )*(dst + 31);
#line 275
  D = (int )*(dst + 63);
#line 276
  E = (int )*(dst + 95);
#line 277
  WebPUint32ToMem(dst + 0, 16843009U * (unsigned int )((uint8_t )((((A + 2 * B) + C) + 2) >> 2)));
#line 278
  WebPUint32ToMem(dst + 32, 16843009U * (unsigned int )((uint8_t )((((B + 2 * C) + D) + 2) >> 2)));
#line 279
  WebPUint32ToMem(dst + 64, 16843009U * (unsigned int )((uint8_t )((((C + 2 * D) + E) + 2) >> 2)));
#line 280
  WebPUint32ToMem(dst + 96, 16843009U * (unsigned int )((uint8_t )((((D + 2 * E) + E) + 2) >> 2)));
  }
#line 282
  return;
}
}
#line 284 "/root/patron-new/new_3/src/dsp/dec.c"
static void DC4_C(uint8_t *dst ) 
{ 
  uint32_t dc ;
  int i ;

  {
#line 285
  dc = (uint32_t )4;
#line 287
  i = 0;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;

#line 287
    if (! (i < 4)) {
#line 287
      goto while_break;
    }
#line 287
    dc += (unsigned int )((int )*(dst + (i - 32)) + (int )*(dst + (-1 + i * 32)));
#line 287
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 288
  dc >>= 3;
#line 289
  i = 0;
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 289
    if (! (i < 4)) {
#line 289
      goto while_break___0;
    }
    {
#line 289
    memset((void *)(dst + i * 32), (int )dc, 4UL);
#line 289
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 293
  return;
}
}
#line 292 "/root/patron-new/new_3/src/dsp/dec.c"
static void RD4_C(uint8_t *dst ) 
{ 
  int I ;
  int J ;
  int K ;
  int L ;
  int X ;
  int A ;
  int B ;
  int C ;
  int D ;

  {
#line 293
  I = (int )*(dst + -1);
#line 294
  J = (int )*(dst + 31);
#line 295
  K = (int )*(dst + 63);
#line 296
  L = (int )*(dst + 95);
#line 297
  X = (int )*(dst + -33);
#line 298
  A = (int )*(dst + -32);
#line 299
  B = (int )*(dst + -31);
#line 300
  C = (int )*(dst + -30);
#line 301
  D = (int )*(dst + -29);
#line 302
  *(dst + 96) = (uint8_t )((((J + 2 * K) + L) + 2) >> 2);
#line 303
  *(dst + 64) = (uint8_t )((((I + 2 * J) + K) + 2) >> 2);
#line 303
  *(dst + 97) = *(dst + 64);
#line 304
  *(dst + 32) = (uint8_t )((((X + 2 * I) + J) + 2) >> 2);
#line 304
  *(dst + 65) = *(dst + 32);
#line 304
  *(dst + 98) = *(dst + 65);
#line 305
  *(dst + 0) = (uint8_t )((((A + 2 * X) + I) + 2) >> 2);
#line 305
  *(dst + 33) = *(dst + 0);
#line 305
  *(dst + 66) = *(dst + 33);
#line 305
  *(dst + 99) = *(dst + 66);
#line 306
  *(dst + 1) = (uint8_t )((((B + 2 * A) + X) + 2) >> 2);
#line 306
  *(dst + 34) = *(dst + 1);
#line 306
  *(dst + 67) = *(dst + 34);
#line 307
  *(dst + 2) = (uint8_t )((((C + 2 * B) + A) + 2) >> 2);
#line 307
  *(dst + 35) = *(dst + 2);
#line 308
  *(dst + 3) = (uint8_t )((((D + 2 * C) + B) + 2) >> 2);
#line 309
  return;
}
}
#line 311 "/root/patron-new/new_3/src/dsp/dec.c"
static void LD4_C(uint8_t *dst ) 
{ 
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;
  int F ;
  int G ;
  int H ;

  {
#line 312
  A = (int )*(dst + -32);
#line 313
  B = (int )*(dst + -31);
#line 314
  C = (int )*(dst + -30);
#line 315
  D = (int )*(dst + -29);
#line 316
  E = (int )*(dst + -28);
#line 317
  F = (int )*(dst + -27);
#line 318
  G = (int )*(dst + -26);
#line 319
  H = (int )*(dst + -25);
#line 320
  *(dst + 0) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 321
  *(dst + 32) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 321
  *(dst + 1) = *(dst + 32);
#line 322
  *(dst + 64) = (uint8_t )((((C + 2 * D) + E) + 2) >> 2);
#line 322
  *(dst + 33) = *(dst + 64);
#line 322
  *(dst + 2) = *(dst + 33);
#line 323
  *(dst + 96) = (uint8_t )((((D + 2 * E) + F) + 2) >> 2);
#line 323
  *(dst + 65) = *(dst + 96);
#line 323
  *(dst + 34) = *(dst + 65);
#line 323
  *(dst + 3) = *(dst + 34);
#line 324
  *(dst + 97) = (uint8_t )((((E + 2 * F) + G) + 2) >> 2);
#line 324
  *(dst + 66) = *(dst + 97);
#line 324
  *(dst + 35) = *(dst + 66);
#line 325
  *(dst + 98) = (uint8_t )((((F + 2 * G) + H) + 2) >> 2);
#line 325
  *(dst + 67) = *(dst + 98);
#line 326
  *(dst + 99) = (uint8_t )((((G + 2 * H) + H) + 2) >> 2);
#line 327
  return;
}
}
#line 330 "/root/patron-new/new_3/src/dsp/dec.c"
static void VR4_C(uint8_t *dst ) 
{ 
  int I ;
  int J ;
  int K ;
  int X ;
  int A ;
  int B ;
  int C ;
  int D ;

  {
#line 331
  I = (int )*(dst + -1);
#line 332
  J = (int )*(dst + 31);
#line 333
  K = (int )*(dst + 63);
#line 334
  X = (int )*(dst + -33);
#line 335
  A = (int )*(dst + -32);
#line 336
  B = (int )*(dst + -31);
#line 337
  C = (int )*(dst + -30);
#line 338
  D = (int )*(dst + -29);
#line 339
  *(dst + 65) = (uint8_t )(((X + A) + 1) >> 1);
#line 339
  *(dst + 0) = *(dst + 65);
#line 340
  *(dst + 66) = (uint8_t )(((A + B) + 1) >> 1);
#line 340
  *(dst + 1) = *(dst + 66);
#line 341
  *(dst + 67) = (uint8_t )(((B + C) + 1) >> 1);
#line 341
  *(dst + 2) = *(dst + 67);
#line 342
  *(dst + 3) = (uint8_t )(((C + D) + 1) >> 1);
#line 344
  *(dst + 96) = (uint8_t )((((K + 2 * J) + I) + 2) >> 2);
#line 345
  *(dst + 64) = (uint8_t )((((J + 2 * I) + X) + 2) >> 2);
#line 346
  *(dst + 97) = (uint8_t )((((I + 2 * X) + A) + 2) >> 2);
#line 346
  *(dst + 32) = *(dst + 97);
#line 347
  *(dst + 98) = (uint8_t )((((X + 2 * A) + B) + 2) >> 2);
#line 347
  *(dst + 33) = *(dst + 98);
#line 348
  *(dst + 99) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 348
  *(dst + 34) = *(dst + 99);
#line 349
  *(dst + 35) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 350
  return;
}
}
#line 352 "/root/patron-new/new_3/src/dsp/dec.c"
static void VL4_C(uint8_t *dst ) 
{ 
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;
  int F ;
  int G ;
  int H ;

  {
#line 353
  A = (int )*(dst + -32);
#line 354
  B = (int )*(dst + -31);
#line 355
  C = (int )*(dst + -30);
#line 356
  D = (int )*(dst + -29);
#line 357
  E = (int )*(dst + -28);
#line 358
  F = (int )*(dst + -27);
#line 359
  G = (int )*(dst + -26);
#line 360
  H = (int )*(dst + -25);
#line 361
  *(dst + 0) = (uint8_t )(((A + B) + 1) >> 1);
#line 362
  *(dst + 64) = (uint8_t )(((B + C) + 1) >> 1);
#line 362
  *(dst + 1) = *(dst + 64);
#line 363
  *(dst + 65) = (uint8_t )(((C + D) + 1) >> 1);
#line 363
  *(dst + 2) = *(dst + 65);
#line 364
  *(dst + 66) = (uint8_t )(((D + E) + 1) >> 1);
#line 364
  *(dst + 3) = *(dst + 66);
#line 366
  *(dst + 32) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 367
  *(dst + 96) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 367
  *(dst + 33) = *(dst + 96);
#line 368
  *(dst + 97) = (uint8_t )((((C + 2 * D) + E) + 2) >> 2);
#line 368
  *(dst + 34) = *(dst + 97);
#line 369
  *(dst + 98) = (uint8_t )((((D + 2 * E) + F) + 2) >> 2);
#line 369
  *(dst + 35) = *(dst + 98);
#line 370
  *(dst + 67) = (uint8_t )((((E + 2 * F) + G) + 2) >> 2);
#line 371
  *(dst + 99) = (uint8_t )((((F + 2 * G) + H) + 2) >> 2);
#line 372
  return;
}
}
#line 374 "/root/patron-new/new_3/src/dsp/dec.c"
static void HU4_C(uint8_t *dst ) 
{ 
  int I ;
  int J ;
  int K ;
  int L ;

  {
#line 375
  I = (int )*(dst + -1);
#line 376
  J = (int )*(dst + 31);
#line 377
  K = (int )*(dst + 63);
#line 378
  L = (int )*(dst + 95);
#line 379
  *(dst + 0) = (uint8_t )(((I + J) + 1) >> 1);
#line 380
  *(dst + 32) = (uint8_t )(((J + K) + 1) >> 1);
#line 380
  *(dst + 2) = *(dst + 32);
#line 381
  *(dst + 64) = (uint8_t )(((K + L) + 1) >> 1);
#line 381
  *(dst + 34) = *(dst + 64);
#line 382
  *(dst + 1) = (uint8_t )((((I + 2 * J) + K) + 2) >> 2);
#line 383
  *(dst + 33) = (uint8_t )((((J + 2 * K) + L) + 2) >> 2);
#line 383
  *(dst + 3) = *(dst + 33);
#line 384
  *(dst + 65) = (uint8_t )((((K + 2 * L) + L) + 2) >> 2);
#line 384
  *(dst + 35) = *(dst + 65);
#line 385
  *(dst + 99) = (uint8_t )L;
#line 385
  *(dst + 98) = *(dst + 99);
#line 385
  *(dst + 97) = *(dst + 98);
#line 385
  *(dst + 96) = *(dst + 97);
#line 385
  *(dst + 66) = *(dst + 96);
#line 385
  *(dst + 67) = *(dst + 66);
#line 386
  return;
}
}
#line 389 "/root/patron-new/new_3/src/dsp/dec.c"
static void HD4_C(uint8_t *dst ) 
{ 
  int I ;
  int J ;
  int K ;
  int L ;
  int X ;
  int A ;
  int B ;
  int C ;

  {
#line 390
  I = (int )*(dst + -1);
#line 391
  J = (int )*(dst + 31);
#line 392
  K = (int )*(dst + 63);
#line 393
  L = (int )*(dst + 95);
#line 394
  X = (int )*(dst + -33);
#line 395
  A = (int )*(dst + -32);
#line 396
  B = (int )*(dst + -31);
#line 397
  C = (int )*(dst + -30);
#line 399
  *(dst + 34) = (uint8_t )(((I + X) + 1) >> 1);
#line 399
  *(dst + 0) = *(dst + 34);
#line 400
  *(dst + 66) = (uint8_t )(((J + I) + 1) >> 1);
#line 400
  *(dst + 32) = *(dst + 66);
#line 401
  *(dst + 98) = (uint8_t )(((K + J) + 1) >> 1);
#line 401
  *(dst + 64) = *(dst + 98);
#line 402
  *(dst + 96) = (uint8_t )(((L + K) + 1) >> 1);
#line 404
  *(dst + 3) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 405
  *(dst + 2) = (uint8_t )((((X + 2 * A) + B) + 2) >> 2);
#line 406
  *(dst + 35) = (uint8_t )((((I + 2 * X) + A) + 2) >> 2);
#line 406
  *(dst + 1) = *(dst + 35);
#line 407
  *(dst + 67) = (uint8_t )((((J + 2 * I) + X) + 2) >> 2);
#line 407
  *(dst + 33) = *(dst + 67);
#line 408
  *(dst + 99) = (uint8_t )((((K + 2 * J) + I) + 2) >> 2);
#line 408
  *(dst + 65) = *(dst + 99);
#line 409
  *(dst + 97) = (uint8_t )((((L + 2 * K) + J) + 2) >> 2);
#line 410
  return;
}
}
#line 422 "/root/patron-new/new_3/src/dsp/dec.c"
static void VE8uv_C(uint8_t *dst ) 
{ 
  int j ;

  {
#line 424
  j = 0;
  {
#line 424
  while (1) {
    while_continue: /* CIL Label */ ;

#line 424
    if (! (j < 8)) {
#line 424
      goto while_break;
    }
    {
#line 425
    memcpy((void *)(dst + j * 32), (void const   *)(dst - 32), 8UL);
#line 424
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 428
  return;
}
}
#line 429 "/root/patron-new/new_3/src/dsp/dec.c"
static void HE8uv_C(uint8_t *dst ) 
{ 
  int j ;

  {
#line 431
  j = 0;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;

#line 431
    if (! (j < 8)) {
#line 431
      goto while_break;
    }
    {
#line 432
    memset((void *)dst, (int )*(dst + -1), 8UL);
#line 433
    dst += 32;
#line 431
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 435
  return;
}
}
#line 438 "/root/patron-new/new_3/src/dsp/dec.c"
__inline static void Put8x8uv(uint8_t value , uint8_t *dst ) 
{ 
  int j ;

  {
#line 440
  j = 0;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;

#line 440
    if (! (j < 8)) {
#line 440
      goto while_break;
    }
    {
#line 441
    memset((void *)(dst + j * 32), (int )value, 8UL);
#line 440
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 444
  return;
}
}
#line 445 "/root/patron-new/new_3/src/dsp/dec.c"
static void DC8uv_C(uint8_t *dst ) 
{ 
  int dc0 ;
  int i ;

  {
#line 446
  dc0 = 8;
#line 448
  i = 0;
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;

#line 448
    if (! (i < 8)) {
#line 448
      goto while_break;
    }
#line 449
    dc0 += (int )*(dst + (i - 32)) + (int )*(dst + (-1 + i * 32));
#line 448
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 451
  Put8x8uv((uint8_t )(dc0 >> 4), dst);
  }
#line 453
  return;
}
}
#line 454 "/root/patron-new/new_3/src/dsp/dec.c"
static void DC8uvNoLeft_C(uint8_t *dst ) 
{ 
  int dc0 ;
  int i ;

  {
#line 455
  dc0 = 4;
#line 457
  i = 0;
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;

#line 457
    if (! (i < 8)) {
#line 457
      goto while_break;
    }
#line 458
    dc0 += (int )*(dst + (i - 32));
#line 457
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 460
  Put8x8uv((uint8_t )(dc0 >> 3), dst);
  }
#line 462
  return;
}
}
#line 463 "/root/patron-new/new_3/src/dsp/dec.c"
static void DC8uvNoTop_C(uint8_t *dst ) 
{ 
  int dc0 ;
  int i ;

  {
#line 464
  dc0 = 4;
#line 466
  i = 0;
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;

#line 466
    if (! (i < 8)) {
#line 466
      goto while_break;
    }
#line 467
    dc0 += (int )*(dst + (-1 + i * 32));
#line 466
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 469
  Put8x8uv((uint8_t )(dc0 >> 3), dst);
  }
#line 471
  return;
}
}
#line 472 "/root/patron-new/new_3/src/dsp/dec.c"
static void DC8uvNoTopLeft_C(uint8_t *dst ) 
{ 


  {
  {
#line 473
  Put8x8uv((uint8_t )128, dst);
  }
#line 475
  return;
}
}
#line 484 "/root/patron-new/new_3/src/dsp/dec.c"
__inline static void DoFilter2_C(uint8_t *p , int step ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int a ;
  int a1 ;
  int a2 ;

  {
#line 485
  p1 = (int )*(p + -2 * step);
#line 485
  p0 = (int )*(p + - step);
#line 485
  q0 = (int )*(p + 0);
#line 485
  q1 = (int )*(p + step);
#line 486
  a = 3 * (q0 - p0) + (int )*(VP8ksclip1 + (p1 - q1));
#line 487
  a1 = (int )*(VP8ksclip2 + ((a + 4) >> 3));
#line 488
  a2 = (int )*(VP8ksclip2 + ((a + 3) >> 3));
#line 489
  *(p + - step) = *(VP8kclip1 + (p0 + a2));
#line 490
  *(p + 0) = *(VP8kclip1 + (q0 - a1));
#line 491
  return;
}
}
#line 494 "/root/patron-new/new_3/src/dsp/dec.c"
__inline static void DoFilter4_C(uint8_t *p , int step ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int a ;
  int a1 ;
  int a2 ;
  int a3 ;

  {
#line 495
  p1 = (int )*(p + -2 * step);
#line 495
  p0 = (int )*(p + - step);
#line 495
  q0 = (int )*(p + 0);
#line 495
  q1 = (int )*(p + step);
#line 496
  a = 3 * (q0 - p0);
#line 497
  a1 = (int )*(VP8ksclip2 + ((a + 4) >> 3));
#line 498
  a2 = (int )*(VP8ksclip2 + ((a + 3) >> 3));
#line 499
  a3 = (a1 + 1) >> 1;
#line 500
  *(p + -2 * step) = *(VP8kclip1 + (p1 + a3));
#line 501
  *(p + - step) = *(VP8kclip1 + (p0 + a2));
#line 502
  *(p + 0) = *(VP8kclip1 + (q0 - a1));
#line 503
  *(p + step) = *(VP8kclip1 + (q1 - a3));
#line 504
  return;
}
}
#line 507 "/root/patron-new/new_3/src/dsp/dec.c"
__inline static void DoFilter6_C(uint8_t *p , int step ) 
{ 
  int p2 ;
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int q2 ;
  int a ;
  int a1 ;
  int a2 ;
  int a3 ;

  {
#line 508
  p2 = (int )*(p + -3 * step);
#line 508
  p1 = (int )*(p + -2 * step);
#line 508
  p0 = (int )*(p + - step);
#line 509
  q0 = (int )*(p + 0);
#line 509
  q1 = (int )*(p + step);
#line 509
  q2 = (int )*(p + 2 * step);
#line 510
  a = (int )*(VP8ksclip1 + (3 * (q0 - p0) + (int )*(VP8ksclip1 + (p1 - q1))));
#line 512
  a1 = (27 * a + 63) >> 7;
#line 513
  a2 = (18 * a + 63) >> 7;
#line 514
  a3 = (9 * a + 63) >> 7;
#line 515
  *(p + -3 * step) = *(VP8kclip1 + (p2 + a3));
#line 516
  *(p + -2 * step) = *(VP8kclip1 + (p1 + a2));
#line 517
  *(p + - step) = *(VP8kclip1 + (p0 + a1));
#line 518
  *(p + 0) = *(VP8kclip1 + (q0 - a1));
#line 519
  *(p + step) = *(VP8kclip1 + (q1 - a2));
#line 520
  *(p + 2 * step) = *(VP8kclip1 + (q2 - a3));
#line 521
  return;
}
}
#line 523 "/root/patron-new/new_3/src/dsp/dec.c"
__inline static int Hev(uint8_t *p , int step , int thresh ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int tmp___0 ;

  {
#line 524
  p1 = (int )*(p + -2 * step);
#line 524
  p0 = (int )*(p + - step);
#line 524
  q0 = (int )*(p + 0);
#line 524
  q1 = (int )*(p + step);
#line 525
  if ((int )*(VP8kabs0 + (p1 - p0)) > thresh) {
#line 525
    tmp___0 = 1;
  } else
#line 525
  if ((int )*(VP8kabs0 + (q1 - q0)) > thresh) {
#line 525
    tmp___0 = 1;
  } else {
#line 525
    tmp___0 = 0;
  }
#line 525
  return (tmp___0);
}
}
#line 530 "/root/patron-new/new_3/src/dsp/dec.c"
__inline static int NeedsFilter_C(uint8_t *p , int step , int t ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;

  {
#line 531
  p1 = (int )*(p + -2 * step);
#line 531
  p0 = (int )*(p + - step);
#line 531
  q0 = (int )*(p + 0);
#line 531
  q1 = (int )*(p + step);
#line 532
  return (4 * (int )*(VP8kabs0 + (p0 - q0)) + (int )*(VP8kabs0 + (p1 - q1)) <= t);
}
}
#line 537 "/root/patron-new/new_3/src/dsp/dec.c"
__inline static int NeedsFilter2_C(uint8_t *p , int step , int t , int it ) 
{ 
  int p3 ;
  int p2 ;
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int q2 ;
  int q3 ;
  int tmp___0 ;

  {
#line 539
  p3 = (int )*(p + -4 * step);
#line 539
  p2 = (int )*(p + -3 * step);
#line 539
  p1 = (int )*(p + -2 * step);
#line 540
  p0 = (int )*(p + - step);
#line 540
  q0 = (int )*(p + 0);
#line 541
  q1 = (int )*(p + step);
#line 541
  q2 = (int )*(p + 2 * step);
#line 541
  q3 = (int )*(p + 3 * step);
#line 542
  if (4 * (int )*(VP8kabs0 + (p0 - q0)) + (int )*(VP8kabs0 + (p1 - q1)) > t) {
#line 542
    return (0);
  }
#line 543
  if ((int )*(VP8kabs0 + (p3 - p2)) <= it) {
#line 543
    if ((int )*(VP8kabs0 + (p2 - p1)) <= it) {
#line 543
      if ((int )*(VP8kabs0 + (p1 - p0)) <= it) {
#line 543
        if ((int )*(VP8kabs0 + (q3 - q2)) <= it) {
#line 543
          if ((int )*(VP8kabs0 + (q2 - q1)) <= it) {
#line 543
            if ((int )*(VP8kabs0 + (q1 - q0)) <= it) {
#line 543
              tmp___0 = 1;
            } else {
#line 543
              tmp___0 = 0;
            }
          } else {
#line 543
            tmp___0 = 0;
          }
        } else {
#line 543
          tmp___0 = 0;
        }
      } else {
#line 543
        tmp___0 = 0;
      }
    } else {
#line 543
      tmp___0 = 0;
    }
  } else {
#line 543
    tmp___0 = 0;
  }
#line 543
  return (tmp___0);
}
}
#line 553 "/root/patron-new/new_3/src/dsp/dec.c"
static void SimpleVFilter16_C(uint8_t *p , int stride , int thresh ) 
{ 
  int i ;
  int thresh2 ;
  int __cil_tmp6 ;

  {
#line 555
  thresh2 = 2 * thresh + 1;
#line 556
  i = 0;
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;

#line 556
    if (! (i < 16)) {
#line 556
      goto while_break;
    }
    {
#line 557
    __cil_tmp6 = NeedsFilter_C(p + i, stride, thresh2);
    }
#line 557
    if (__cil_tmp6) {
      {
#line 558
      DoFilter2_C(p + i, stride);
      }
    }
#line 556
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 560
  return;
}
}
#line 563 "/root/patron-new/new_3/src/dsp/dec.c"
static void SimpleHFilter16_C(uint8_t *p , int stride , int thresh ) 
{ 
  int i ;
  int thresh2 ;
  int __cil_tmp6 ;

  {
#line 565
  thresh2 = 2 * thresh + 1;
#line 566
  i = 0;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;

#line 566
    if (! (i < 16)) {
#line 566
      goto while_break;
    }
    {
#line 567
    __cil_tmp6 = NeedsFilter_C(p + i * stride, 1, thresh2);
    }
#line 567
    if (__cil_tmp6) {
      {
#line 568
      DoFilter2_C(p + i * stride, 1);
      }
    }
#line 566
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 570
  return;
}
}
#line 573 "/root/patron-new/new_3/src/dsp/dec.c"
static void SimpleVFilter16i_C(uint8_t *p , int stride , int thresh ) 
{ 
  int k ;

  {
#line 575
  k = 3;
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;

#line 575
    if (! (k > 0)) {
#line 575
      goto while_break;
    }
    {
#line 576
    p += 4 * stride;
#line 577
    SimpleVFilter16_C(p, stride, thresh);
#line 575
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 579
  return;
}
}
#line 581 "/root/patron-new/new_3/src/dsp/dec.c"
static void SimpleHFilter16i_C(uint8_t *p , int stride , int thresh ) 
{ 
  int k ;

  {
#line 583
  k = 3;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;

#line 583
    if (! (k > 0)) {
#line 583
      goto while_break;
    }
    {
#line 584
    p += 4;
#line 585
    SimpleHFilter16_C(p, stride, thresh);
#line 583
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 587
  return;
}
}
#line 594 "/root/patron-new/new_3/src/dsp/dec.c"
__inline static void FilterLoop26_C(uint8_t *p , int hstride , int vstride , int size ,
                                    int thresh , int ithresh , int hev_thresh ) 
{ 
  int thresh2 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 598
  thresh2 = 2 * thresh + 1;
  {
#line 599
  while (1) {
    while_continue: /* CIL Label */ ;
#line 599
    __cil_tmp9 = size;
#line 599
    size --;
#line 599
    if (! (__cil_tmp9 > 0)) {
#line 599
      goto while_break;
    }
    {
#line 600
    __cil_tmp10 = NeedsFilter2_C(p, hstride, thresh2, ithresh);
    }
#line 600
    if (__cil_tmp10) {
      {
#line 601
      __cil_tmp11 = Hev(p, hstride, hev_thresh);
      }
#line 601
      if (__cil_tmp11) {
        {
#line 602
        DoFilter2_C(p, hstride);
        }
      } else {
        {
#line 604
        DoFilter6_C(p, hstride);
        }
      }
    }
#line 607
    p += vstride;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 611
  return;
}
}
#line 611 "/root/patron-new/new_3/src/dsp/dec.c"
__inline static void FilterLoop24_C(uint8_t *p , int hstride , int vstride , int size ,
                                    int thresh , int ithresh , int hev_thresh ) 
{ 
  int thresh2 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 615
  thresh2 = 2 * thresh + 1;
  {
#line 616
  while (1) {
    while_continue: /* CIL Label */ ;
#line 616
    __cil_tmp9 = size;
#line 616
    size --;
#line 616
    if (! (__cil_tmp9 > 0)) {
#line 616
      goto while_break;
    }
    {
#line 617
    __cil_tmp10 = NeedsFilter2_C(p, hstride, thresh2, ithresh);
    }
#line 617
    if (__cil_tmp10) {
      {
#line 618
      __cil_tmp11 = Hev(p, hstride, hev_thresh);
      }
#line 618
      if (__cil_tmp11) {
        {
#line 619
        DoFilter2_C(p, hstride);
        }
      } else {
        {
#line 621
        DoFilter4_C(p, hstride);
        }
      }
    }
#line 624
    p += vstride;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 628
  return;
}
}
#line 631 "/root/patron-new/new_3/src/dsp/dec.c"
static void VFilter16_C(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 


  {
  {
#line 633
  FilterLoop26_C(p, stride, 1, 16, thresh, ithresh, hev_thresh);
  }
#line 635
  return;
}
}
#line 636 "/root/patron-new/new_3/src/dsp/dec.c"
static void HFilter16_C(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 


  {
  {
#line 638
  FilterLoop26_C(p, 1, stride, 16, thresh, ithresh, hev_thresh);
  }
#line 640
  return;
}
}
#line 642 "/root/patron-new/new_3/src/dsp/dec.c"
static void VFilter16i_C(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 
  int k ;

  {
#line 645
  k = 3;
  {
#line 645
  while (1) {
    while_continue: /* CIL Label */ ;

#line 645
    if (! (k > 0)) {
#line 645
      goto while_break;
    }
    {
#line 646
    p += 4 * stride;
#line 647
    FilterLoop24_C(p, stride, 1, 16, thresh, ithresh, hev_thresh);
#line 645
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 649
  return;
}
}
#line 653 "/root/patron-new/new_3/src/dsp/dec.c"
static void HFilter16i_C(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 
  int k ;

  {
#line 656
  k = 3;
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;

#line 656
    if (! (k > 0)) {
#line 656
      goto while_break;
    }
    {
#line 657
    p += 4;
#line 658
    FilterLoop24_C(p, 1, stride, 16, thresh, ithresh, hev_thresh);
#line 656
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 660
  return;
}
}
#line 665 "/root/patron-new/new_3/src/dsp/dec.c"
static void VFilter8_C(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                       int hev_thresh ) 
{ 


  {
  {
#line 667
  FilterLoop26_C(u, stride, 1, 8, thresh, ithresh, hev_thresh);
#line 668
  FilterLoop26_C(v, stride, 1, 8, thresh, ithresh, hev_thresh);
  }
#line 670
  return;
}
}
#line 673 "/root/patron-new/new_3/src/dsp/dec.c"
static void HFilter8_C(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                       int hev_thresh ) 
{ 


  {
  {
#line 675
  FilterLoop26_C(u, 1, stride, 8, thresh, ithresh, hev_thresh);
#line 676
  FilterLoop26_C(v, 1, stride, 8, thresh, ithresh, hev_thresh);
  }
#line 678
  return;
}
}
#line 681 "/root/patron-new/new_3/src/dsp/dec.c"
static void VFilter8i_C(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                        int hev_thresh ) 
{ 


  {
  {
#line 683
  FilterLoop24_C(u + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
#line 684
  FilterLoop24_C(v + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
  }
#line 686
  return;
}
}
#line 689 "/root/patron-new/new_3/src/dsp/dec.c"
static void HFilter8i_C(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                        int hev_thresh ) 
{ 


  {
  {
#line 691
  FilterLoop24_C(u + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
#line 692
  FilterLoop24_C(v + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
  }
#line 694
  return;
}
}
#line 698 "/root/patron-new/new_3/src/dsp/dec.c"
static void DitherCombine8x8_C(uint8_t *dither , uint8_t *dst , int dst_stride ) 
{ 
  int i ;
  int j ;
  int delta0 ;
  int delta1 ;

  {
#line 701
  j = 0;
  {
#line 701
  while (1) {
    while_continue: /* CIL Label */ ;

#line 701
    if (! (j < 8)) {
#line 701
      goto while_break;
    }
#line 702
    i = 0;
    {
#line 702
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 702
      if (! (i < 8)) {
#line 702
        goto while_break___0;
      }
      {
#line 703
      delta0 = (int )*(dither + i) - (1 << 7);
#line 704
      delta1 = (delta0 + (1 << 3)) >> 4;
#line 706
      *(dst + i) = clip_8b___1((int )*(dst + i) + delta1);
#line 702
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 708
    dst += dst_stride;
#line 709
    dither += 8;
#line 701
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 705
  return;
}
}
#line 737
extern void VP8DspInitSSE2(void) ;
#line 738
extern void VP8DspInitSSE41(void) ;
#line 744
static void VP8DspInit_body(void) ;
#line 746 "/root/patron-new/new_3/src/dsp/dec.c"
static int (*VP8DspInit_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 747 "/root/patron-new/new_3/src/dsp/dec.c"
static pthread_mutex_t VP8DspInit_body_lock  ;
#line 744 "/root/patron-new/new_3/src/dsp/dec.c"
void VP8DspInit(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 744
    VP8DspInit_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& VP8DspInit_body_last_cpuinfo_used);
#line 744
    VP8DspInit_body_lock.__data.__lock = 0;
#line 744
    VP8DspInit_body_lock.__data.__count = 0U;
#line 744
    VP8DspInit_body_lock.__data.__owner = 0;
#line 744
    VP8DspInit_body_lock.__data.__nusers = 0U;
#line 744
    VP8DspInit_body_lock.__data.__kind = 0;
#line 744
    VP8DspInit_body_lock.__data.__spins = (short)0;
#line 744
    VP8DspInit_body_lock.__data.__elision = (short)0;
#line 744
    VP8DspInit_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 744
    VP8DspInit_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 744
    __cil_tmp3 = pthread_mutex_lock(& VP8DspInit_body_lock);
    }
#line 744
    if (__cil_tmp3) {
#line 744
      goto while_break;
    }
#line 744
    if ((unsigned long )VP8DspInit_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 744
      VP8DspInit_body();
      }
    }
    {
#line 744
    VP8DspInit_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 744
    pthread_mutex_unlock(& VP8DspInit_body_lock);
    }
#line 744
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 748
  return;
}
}
#line 744 "/root/patron-new/new_3/src/dsp/dec.c"
static void VP8DspInit_body(void) 
{ 
  int __cil_tmp1 ;
  int __cil_tmp2 ;

  {
  {
#line 745
  VP8InitClipTables();
#line 748
  VP8TransformWHT = & TransformWHT_C;
#line 749
  VP8Transform = & TransformTwo_C;
#line 750
  VP8TransformDC = & TransformDC_C;
#line 751
  VP8TransformAC3 = & TransformAC3_C;
#line 753
  VP8TransformUV = & TransformUV_C;
#line 754
  VP8TransformDCUV = & TransformDCUV_C;
#line 757
  VP8VFilter16 = & VFilter16_C;
#line 758
  VP8VFilter16i = & VFilter16i_C;
#line 759
  VP8HFilter16 = & HFilter16_C;
#line 760
  VP8VFilter8 = & VFilter8_C;
#line 761
  VP8VFilter8i = & VFilter8i_C;
#line 762
  VP8SimpleVFilter16 = & SimpleVFilter16_C;
#line 763
  VP8SimpleHFilter16 = & SimpleHFilter16_C;
#line 764
  VP8SimpleVFilter16i = & SimpleVFilter16i_C;
#line 765
  VP8SimpleHFilter16i = & SimpleHFilter16i_C;
#line 769
  VP8HFilter16i = & HFilter16i_C;
#line 770
  VP8HFilter8 = & HFilter8_C;
#line 771
  VP8HFilter8i = & HFilter8i_C;
#line 775
  VP8PredLuma4[0] = & DC4_C;
#line 776
  VP8PredLuma4[1] = & TM4_C;
#line 777
  VP8PredLuma4[2] = & VE4_C;
#line 778
  VP8PredLuma4[4] = & RD4_C;
#line 779
  VP8PredLuma4[6] = & LD4_C;
#line 782
  VP8PredLuma4[3] = & HE4_C;
#line 783
  VP8PredLuma4[5] = & VR4_C;
#line 784
  VP8PredLuma4[7] = & VL4_C;
#line 785
  VP8PredLuma4[8] = & HD4_C;
#line 786
  VP8PredLuma4[9] = & HU4_C;
#line 789
  VP8PredLuma16[0] = & DC16_C;
#line 790
  VP8PredLuma16[1] = & TM16_C;
#line 791
  VP8PredLuma16[2] = & VE16_C;
#line 792
  VP8PredLuma16[3] = & HE16_C;
#line 793
  VP8PredLuma16[4] = & DC16NoTop_C;
#line 794
  VP8PredLuma16[5] = & DC16NoLeft_C;
#line 795
  VP8PredLuma16[6] = & DC16NoTopLeft_C;
#line 797
  VP8PredChroma8[0] = & DC8uv_C;
#line 798
  VP8PredChroma8[1] = & TM8uv_C;
#line 799
  VP8PredChroma8[2] = & VE8uv_C;
#line 800
  VP8PredChroma8[3] = & HE8uv_C;
#line 801
  VP8PredChroma8[4] = & DC8uvNoTop_C;
#line 802
  VP8PredChroma8[5] = & DC8uvNoLeft_C;
#line 803
  VP8PredChroma8[6] = & DC8uvNoTopLeft_C;
#line 806
  VP8DitherCombine8x8 = & DitherCombine8x8_C;
  }
#line 809
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
    {
#line 811
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 811
    if (__cil_tmp1) {
      {
#line 812
      VP8DspInitSSE2();
#line 814
      __cil_tmp2 = (*VP8GetCPUInfo)((CPUFeature )3);
      }
#line 814
      if (__cil_tmp2) {
        {
#line 815
        VP8DspInitSSE41();
        }
      }
    }
  }
#line 820
  return;
}
}
#line 52 "/root/patron-new/new_3/src/dsp/cpu.c"
__inline static void GetCPUInfo(int *cpu_info , int info_type ) 
{ 


  {
#line 57
  __asm__  ("asm":);
#line 58
  return;
}
}
#line 74 "/root/patron-new/new_3/src/dsp/cpu.c"
__inline static uint64_t xgetbv(void) 
{ 
  uint32_t ecx ;
  uint32_t eax ;
  uint32_t edx ;

  {
#line 75
  ecx = (uint32_t )0;
#line 76
  __asm__  ("asm":);
#line 81
  return (((uint64_t )edx << 32) | (unsigned long )eax);
}
}
#line 108 "/root/patron-new/new_3/src/dsp/cpu.c"
static uint8_t kSlowModels[6]  ;
#line 106 "/root/patron-new/new_3/src/dsp/cpu.c"
static int CheckSlowModel(int info ) 
{ 
  uint32_t model ;
  uint32_t family ;
  size_t i ;

  {
#line 110
  kSlowModels[0] = (uint8_t )55;
#line 110
  kSlowModels[1] = (uint8_t )74;
#line 110
  kSlowModels[2] = (uint8_t )77;
#line 110
  kSlowModels[3] = (uint8_t )28;
#line 110
  kSlowModels[4] = (uint8_t )38;
#line 110
  kSlowModels[5] = (uint8_t )39;
#line 114
  model = (uint32_t )(((info & 983040) >> 12) | ((info >> 4) & 15));
#line 115
  family = (uint32_t )((info >> 8) & 15);
#line 116
  if (family == 6U) {
#line 118
    i = (size_t )0;
    {
#line 118
    while (1) {
      while_continue: /* CIL Label */ ;

#line 118
      if (! (i < sizeof(kSlowModels) / sizeof(kSlowModels[0]))) {
#line 118
        goto while_break;
      }
#line 119
      if (model == (unsigned int )kSlowModels[i]) {
#line 119
        return (1);
      }
#line 118
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 122
  return (0);
}
}
#line 125 "/root/patron-new/new_3/src/dsp/cpu.c"
static int x86CPUInfo(CPUFeature feature ) 
{ 
  int max_cpuid_value ;
  int cpu_info[4] ;
  int is_intel ;
  int VENDOR_ID_INTEL_EBX ;
  int VENDOR_ID_INTEL_EDX ;
  int VENDOR_ID_INTEL_ECX ;
  int __cil_tmp8 ;
  uint64_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int tmp___0 ;

  {
  {
#line 128
  is_intel = 0;
#line 131
  GetCPUInfo((int *)(cpu_info), 0);
#line 132
  max_cpuid_value = cpu_info[0];
  }
#line 133
  if (max_cpuid_value < 1) {
#line 134
    return (0);
  } else {
#line 136
    VENDOR_ID_INTEL_EBX = 1970169159;
#line 137
    VENDOR_ID_INTEL_EDX = 1231384169;
#line 138
    VENDOR_ID_INTEL_ECX = 1818588270;
#line 139
    if (cpu_info[1] == VENDOR_ID_INTEL_EBX) {
#line 139
      if (cpu_info[2] == VENDOR_ID_INTEL_ECX) {
#line 139
        if (cpu_info[3] == VENDOR_ID_INTEL_EDX) {
#line 139
          tmp___0 = 1;
        } else {
#line 139
          tmp___0 = 0;
        }
      } else {
#line 139
        tmp___0 = 0;
      }
    } else {
#line 139
      tmp___0 = 0;
    }
#line 139
    is_intel = tmp___0;
  }
  {
#line 144
  GetCPUInfo((int *)(cpu_info), 1);
  }
#line 145
  if ((unsigned int )feature == 0U) {
#line 146
    return (! (! (cpu_info[3] & (1 << 26))));
  }
#line 148
  if ((unsigned int )feature == 1U) {
#line 149
    return (! (! (cpu_info[2] & 1)));
  }
#line 151
  if ((unsigned int )feature == 2U) {
#line 152
    if (is_intel) {
#line 152
      if (cpu_info[2] & (1 << 9)) {
        {
#line 153
        __cil_tmp8 = CheckSlowModel(cpu_info[0]);
        }
#line 153
        return (__cil_tmp8);
      }
    }
#line 155
    return (0);
  }
#line 158
  if ((unsigned int )feature == 3U) {
#line 159
    return (! (! (cpu_info[2] & (1 << 19))));
  }
#line 161
  if ((unsigned int )feature == 4U) {
#line 163
    if ((cpu_info[2] & 402653184) == 402653184) {
      {
#line 165
      __cil_tmp9 = xgetbv();
      }
#line 165
      return ((__cil_tmp9 & 6UL) == 6UL);
    }
  }
#line 168
  if ((unsigned int )feature == 5U) {
    {
#line 169
    __cil_tmp10 = x86CPUInfo((CPUFeature )4);
    }
#line 169
    if (__cil_tmp10) {
#line 169
      if (max_cpuid_value >= 7) {
        {
#line 170
        GetCPUInfo((int *)(cpu_info), 7);
        }
#line 171
        return (! (! (cpu_info[1] & (1 << 5))));
      }
    }
  }
#line 174
  return (0);
}
}
#line 176 "/root/patron-new/new_3/src/dsp/cpu.c"
int (*VP8GetCPUInfo)(CPUFeature  )  =    & x86CPUInfo;
#line 18 "/root/patron-new/new_3/src/dsp/cost.c"
uint16_t VP8EntropyCost[256]  = 
#line 18 "/root/patron-new/new_3/src/dsp/cost.c"
  {      (uint16_t )1792,      (uint16_t )1792,      (uint16_t )1792,      (uint16_t )1536, 
        (uint16_t )1536,      (uint16_t )1408,      (uint16_t )1366,      (uint16_t )1280, 
        (uint16_t )1280,      (uint16_t )1216,      (uint16_t )1178,      (uint16_t )1152, 
        (uint16_t )1110,      (uint16_t )1076,      (uint16_t )1061,      (uint16_t )1024, 
        (uint16_t )1024,      (uint16_t )992,      (uint16_t )968,      (uint16_t )951, 
        (uint16_t )939,      (uint16_t )911,      (uint16_t )896,      (uint16_t )878, 
        (uint16_t )871,      (uint16_t )854,      (uint16_t )838,      (uint16_t )820, 
        (uint16_t )811,      (uint16_t )794,      (uint16_t )786,      (uint16_t )768, 
        (uint16_t )768,      (uint16_t )752,      (uint16_t )740,      (uint16_t )732, 
        (uint16_t )720,      (uint16_t )709,      (uint16_t )704,      (uint16_t )690, 
        (uint16_t )683,      (uint16_t )672,      (uint16_t )666,      (uint16_t )655, 
        (uint16_t )647,      (uint16_t )640,      (uint16_t )631,      (uint16_t )622, 
        (uint16_t )615,      (uint16_t )607,      (uint16_t )598,      (uint16_t )592, 
        (uint16_t )586,      (uint16_t )576,      (uint16_t )572,      (uint16_t )564, 
        (uint16_t )559,      (uint16_t )555,      (uint16_t )547,      (uint16_t )541, 
        (uint16_t )534,      (uint16_t )528,      (uint16_t )522,      (uint16_t )512, 
        (uint16_t )512,      (uint16_t )504,      (uint16_t )500,      (uint16_t )494, 
        (uint16_t )488,      (uint16_t )483,      (uint16_t )477,      (uint16_t )473, 
        (uint16_t )467,      (uint16_t )461,      (uint16_t )458,      (uint16_t )452, 
        (uint16_t )448,      (uint16_t )443,      (uint16_t )438,      (uint16_t )434, 
        (uint16_t )427,      (uint16_t )424,      (uint16_t )419,      (uint16_t )415, 
        (uint16_t )410,      (uint16_t )406,      (uint16_t )403,      (uint16_t )399, 
        (uint16_t )394,      (uint16_t )390,      (uint16_t )384,      (uint16_t )384, 
        (uint16_t )377,      (uint16_t )374,      (uint16_t )370,      (uint16_t )366, 
        (uint16_t )362,      (uint16_t )359,      (uint16_t )355,      (uint16_t )351, 
        (uint16_t )347,      (uint16_t )342,      (uint16_t )342,      (uint16_t )336, 
        (uint16_t )333,      (uint16_t )330,      (uint16_t )326,      (uint16_t )323, 
        (uint16_t )320,      (uint16_t )316,      (uint16_t )312,      (uint16_t )308, 
        (uint16_t )305,      (uint16_t )302,      (uint16_t )299,      (uint16_t )296, 
        (uint16_t )293,      (uint16_t )288,      (uint16_t )287,      (uint16_t )283, 
        (uint16_t )280,      (uint16_t )277,      (uint16_t )274,      (uint16_t )272, 
        (uint16_t )268,      (uint16_t )266,      (uint16_t )262,      (uint16_t )256, 
        (uint16_t )256,      (uint16_t )256,      (uint16_t )251,      (uint16_t )248, 
        (uint16_t )245,      (uint16_t )242,      (uint16_t )240,      (uint16_t )237, 
        (uint16_t )234,      (uint16_t )232,      (uint16_t )228,      (uint16_t )226, 
        (uint16_t )223,      (uint16_t )221,      (uint16_t )218,      (uint16_t )216, 
        (uint16_t )214,      (uint16_t )211,      (uint16_t )208,      (uint16_t )205, 
        (uint16_t )203,      (uint16_t )201,      (uint16_t )198,      (uint16_t )196, 
        (uint16_t )192,      (uint16_t )191,      (uint16_t )188,      (uint16_t )187, 
        (uint16_t )183,      (uint16_t )181,      (uint16_t )179,      (uint16_t )176, 
        (uint16_t )175,      (uint16_t )171,      (uint16_t )171,      (uint16_t )168, 
        (uint16_t )165,      (uint16_t )163,      (uint16_t )160,      (uint16_t )159, 
        (uint16_t )156,      (uint16_t )154,      (uint16_t )152,      (uint16_t )150, 
        (uint16_t )148,      (uint16_t )146,      (uint16_t )144,      (uint16_t )142, 
        (uint16_t )139,      (uint16_t )138,      (uint16_t )135,      (uint16_t )133, 
        (uint16_t )131,      (uint16_t )128,      (uint16_t )128,      (uint16_t )125, 
        (uint16_t )123,      (uint16_t )121,      (uint16_t )119,      (uint16_t )117, 
        (uint16_t )115,      (uint16_t )113,      (uint16_t )111,      (uint16_t )110, 
        (uint16_t )107,      (uint16_t )105,      (uint16_t )103,      (uint16_t )102, 
        (uint16_t )100,      (uint16_t )98,      (uint16_t )96,      (uint16_t )94, 
        (uint16_t )92,      (uint16_t )91,      (uint16_t )89,      (uint16_t )86, 
        (uint16_t )86,      (uint16_t )83,      (uint16_t )82,      (uint16_t )80, 
        (uint16_t )77,      (uint16_t )76,      (uint16_t )74,      (uint16_t )73, 
        (uint16_t )71,      (uint16_t )69,      (uint16_t )67,      (uint16_t )66, 
        (uint16_t )64,      (uint16_t )63,      (uint16_t )61,      (uint16_t )59, 
        (uint16_t )57,      (uint16_t )55,      (uint16_t )54,      (uint16_t )52, 
        (uint16_t )51,      (uint16_t )49,      (uint16_t )47,      (uint16_t )46, 
        (uint16_t )44,      (uint16_t )43,      (uint16_t )41,      (uint16_t )40, 
        (uint16_t )38,      (uint16_t )36,      (uint16_t )35,      (uint16_t )33, 
        (uint16_t )32,      (uint16_t )30,      (uint16_t )29,      (uint16_t )27, 
        (uint16_t )25,      (uint16_t )24,      (uint16_t )22,      (uint16_t )21, 
        (uint16_t )19,      (uint16_t )18,      (uint16_t )16,      (uint16_t )15, 
        (uint16_t )13,      (uint16_t )12,      (uint16_t )10,      (uint16_t )9, 
        (uint16_t )7,      (uint16_t )6,      (uint16_t )4,      (uint16_t )3};
#line 52 "/root/patron-new/new_3/src/dsp/cost.c"
uint16_t VP8LevelFixedCosts[2048]  = 
#line 52
  {      (uint16_t )0,      (uint16_t )256,      (uint16_t )256,      (uint16_t )256, 
        (uint16_t )256,      (uint16_t )432,      (uint16_t )618,      (uint16_t )630, 
        (uint16_t )731,      (uint16_t )640,      (uint16_t )640,      (uint16_t )828, 
        (uint16_t )901,      (uint16_t )948,      (uint16_t )1021,      (uint16_t )1101, 
        (uint16_t )1174,      (uint16_t )1221,      (uint16_t )1294,      (uint16_t )1042, 
        (uint16_t )1085,      (uint16_t )1115,      (uint16_t )1158,      (uint16_t )1202, 
        (uint16_t )1245,      (uint16_t )1275,      (uint16_t )1318,      (uint16_t )1337, 
        (uint16_t )1380,      (uint16_t )1410,      (uint16_t )1453,      (uint16_t )1497, 
        (uint16_t )1540,      (uint16_t )1570,      (uint16_t )1613,      (uint16_t )1280, 
        (uint16_t )1295,      (uint16_t )1317,      (uint16_t )1332,      (uint16_t )1358, 
        (uint16_t )1373,      (uint16_t )1395,      (uint16_t )1410,      (uint16_t )1454, 
        (uint16_t )1469,      (uint16_t )1491,      (uint16_t )1506,      (uint16_t )1532, 
        (uint16_t )1547,      (uint16_t )1569,      (uint16_t )1584,      (uint16_t )1601, 
        (uint16_t )1616,      (uint16_t )1638,      (uint16_t )1653,      (uint16_t )1679, 
        (uint16_t )1694,      (uint16_t )1716,      (uint16_t )1731,      (uint16_t )1775, 
        (uint16_t )1790,      (uint16_t )1812,      (uint16_t )1827,      (uint16_t )1853, 
        (uint16_t )1868,      (uint16_t )1890,      (uint16_t )1905,      (uint16_t )1727, 
        (uint16_t )1733,      (uint16_t )1742,      (uint16_t )1748,      (uint16_t )1759, 
        (uint16_t )1765,      (uint16_t )1774,      (uint16_t )1780,      (uint16_t )1800, 
        (uint16_t )1806,      (uint16_t )1815,      (uint16_t )1821,      (uint16_t )1832, 
        (uint16_t )1838,      (uint16_t )1847,      (uint16_t )1853,      (uint16_t )1878, 
        (uint16_t )1884,      (uint16_t )1893,      (uint16_t )1899,      (uint16_t )1910, 
        (uint16_t )1916,      (uint16_t )1925,      (uint16_t )1931,      (uint16_t )1951, 
        (uint16_t )1957,      (uint16_t )1966,      (uint16_t )1972,      (uint16_t )1983, 
        (uint16_t )1989,      (uint16_t )1998,      (uint16_t )2004,      (uint16_t )2027, 
        (uint16_t )2033,      (uint16_t )2042,      (uint16_t )2048,      (uint16_t )2059, 
        (uint16_t )2065,      (uint16_t )2074,      (uint16_t )2080,      (uint16_t )2100, 
        (uint16_t )2106,      (uint16_t )2115,      (uint16_t )2121,      (uint16_t )2132, 
        (uint16_t )2138,      (uint16_t )2147,      (uint16_t )2153,      (uint16_t )2178, 
        (uint16_t )2184,      (uint16_t )2193,      (uint16_t )2199,      (uint16_t )2210, 
        (uint16_t )2216,      (uint16_t )2225,      (uint16_t )2231,      (uint16_t )2251, 
        (uint16_t )2257,      (uint16_t )2266,      (uint16_t )2272,      (uint16_t )2283, 
        (uint16_t )2289,      (uint16_t )2298,      (uint16_t )2304,      (uint16_t )2168, 
        (uint16_t )2174,      (uint16_t )2183,      (uint16_t )2189,      (uint16_t )2200, 
        (uint16_t )2206,      (uint16_t )2215,      (uint16_t )2221,      (uint16_t )2241, 
        (uint16_t )2247,      (uint16_t )2256,      (uint16_t )2262,      (uint16_t )2273, 
        (uint16_t )2279,      (uint16_t )2288,      (uint16_t )2294,      (uint16_t )2319, 
        (uint16_t )2325,      (uint16_t )2334,      (uint16_t )2340,      (uint16_t )2351, 
        (uint16_t )2357,      (uint16_t )2366,      (uint16_t )2372,      (uint16_t )2392, 
        (uint16_t )2398,      (uint16_t )2407,      (uint16_t )2413,      (uint16_t )2424, 
        (uint16_t )2430,      (uint16_t )2439,      (uint16_t )2445,      (uint16_t )2468, 
        (uint16_t )2474,      (uint16_t )2483,      (uint16_t )2489,      (uint16_t )2500, 
        (uint16_t )2506,      (uint16_t )2515,      (uint16_t )2521,      (uint16_t )2541, 
        (uint16_t )2547,      (uint16_t )2556,      (uint16_t )2562,      (uint16_t )2573, 
        (uint16_t )2579,      (uint16_t )2588,      (uint16_t )2594,      (uint16_t )2619, 
        (uint16_t )2625,      (uint16_t )2634,      (uint16_t )2640,      (uint16_t )2651, 
        (uint16_t )2657,      (uint16_t )2666,      (uint16_t )2672,      (uint16_t )2692, 
        (uint16_t )2698,      (uint16_t )2707,      (uint16_t )2713,      (uint16_t )2724, 
        (uint16_t )2730,      (uint16_t )2739,      (uint16_t )2745,      (uint16_t )2540, 
        (uint16_t )2546,      (uint16_t )2555,      (uint16_t )2561,      (uint16_t )2572, 
        (uint16_t )2578,      (uint16_t )2587,      (uint16_t )2593,      (uint16_t )2613, 
        (uint16_t )2619,      (uint16_t )2628,      (uint16_t )2634,      (uint16_t )2645, 
        (uint16_t )2651,      (uint16_t )2660,      (uint16_t )2666,      (uint16_t )2691, 
        (uint16_t )2697,      (uint16_t )2706,      (uint16_t )2712,      (uint16_t )2723, 
        (uint16_t )2729,      (uint16_t )2738,      (uint16_t )2744,      (uint16_t )2764, 
        (uint16_t )2770,      (uint16_t )2779,      (uint16_t )2785,      (uint16_t )2796, 
        (uint16_t )2802,      (uint16_t )2811,      (uint16_t )2817,      (uint16_t )2840, 
        (uint16_t )2846,      (uint16_t )2855,      (uint16_t )2861,      (uint16_t )2872, 
        (uint16_t )2878,      (uint16_t )2887,      (uint16_t )2893,      (uint16_t )2913, 
        (uint16_t )2919,      (uint16_t )2928,      (uint16_t )2934,      (uint16_t )2945, 
        (uint16_t )2951,      (uint16_t )2960,      (uint16_t )2966,      (uint16_t )2991, 
        (uint16_t )2997,      (uint16_t )3006,      (uint16_t )3012,      (uint16_t )3023, 
        (uint16_t )3029,      (uint16_t )3038,      (uint16_t )3044,      (uint16_t )3064, 
        (uint16_t )3070,      (uint16_t )3079,      (uint16_t )3085,      (uint16_t )3096, 
        (uint16_t )3102,      (uint16_t )3111,      (uint16_t )3117,      (uint16_t )2981, 
        (uint16_t )2987,      (uint16_t )2996,      (uint16_t )3002,      (uint16_t )3013, 
        (uint16_t )3019,      (uint16_t )3028,      (uint16_t )3034,      (uint16_t )3054, 
        (uint16_t )3060,      (uint16_t )3069,      (uint16_t )3075,      (uint16_t )3086, 
        (uint16_t )3092,      (uint16_t )3101,      (uint16_t )3107,      (uint16_t )3132, 
        (uint16_t )3138,      (uint16_t )3147,      (uint16_t )3153,      (uint16_t )3164, 
        (uint16_t )3170,      (uint16_t )3179,      (uint16_t )3185,      (uint16_t )3205, 
        (uint16_t )3211,      (uint16_t )3220,      (uint16_t )3226,      (uint16_t )3237, 
        (uint16_t )3243,      (uint16_t )3252,      (uint16_t )3258,      (uint16_t )3281, 
        (uint16_t )3287,      (uint16_t )3296,      (uint16_t )3302,      (uint16_t )3313, 
        (uint16_t )3319,      (uint16_t )3328,      (uint16_t )3334,      (uint16_t )3354, 
        (uint16_t )3360,      (uint16_t )3369,      (uint16_t )3375,      (uint16_t )3386, 
        (uint16_t )3392,      (uint16_t )3401,      (uint16_t )3407,      (uint16_t )3432, 
        (uint16_t )3438,      (uint16_t )3447,      (uint16_t )3453,      (uint16_t )3464, 
        (uint16_t )3470,      (uint16_t )3479,      (uint16_t )3485,      (uint16_t )3505, 
        (uint16_t )3511,      (uint16_t )3520,      (uint16_t )3526,      (uint16_t )3537, 
        (uint16_t )3543,      (uint16_t )3552,      (uint16_t )3558,      (uint16_t )2816, 
        (uint16_t )2822,      (uint16_t )2831,      (uint16_t )2837,      (uint16_t )2848, 
        (uint16_t )2854,      (uint16_t )2863,      (uint16_t )2869,      (uint16_t )2889, 
        (uint16_t )2895,      (uint16_t )2904,      (uint16_t )2910,      (uint16_t )2921, 
        (uint16_t )2927,      (uint16_t )2936,      (uint16_t )2942,      (uint16_t )2967, 
        (uint16_t )2973,      (uint16_t )2982,      (uint16_t )2988,      (uint16_t )2999, 
        (uint16_t )3005,      (uint16_t )3014,      (uint16_t )3020,      (uint16_t )3040, 
        (uint16_t )3046,      (uint16_t )3055,      (uint16_t )3061,      (uint16_t )3072, 
        (uint16_t )3078,      (uint16_t )3087,      (uint16_t )3093,      (uint16_t )3116, 
        (uint16_t )3122,      (uint16_t )3131,      (uint16_t )3137,      (uint16_t )3148, 
        (uint16_t )3154,      (uint16_t )3163,      (uint16_t )3169,      (uint16_t )3189, 
        (uint16_t )3195,      (uint16_t )3204,      (uint16_t )3210,      (uint16_t )3221, 
        (uint16_t )3227,      (uint16_t )3236,      (uint16_t )3242,      (uint16_t )3267, 
        (uint16_t )3273,      (uint16_t )3282,      (uint16_t )3288,      (uint16_t )3299, 
        (uint16_t )3305,      (uint16_t )3314,      (uint16_t )3320,      (uint16_t )3340, 
        (uint16_t )3346,      (uint16_t )3355,      (uint16_t )3361,      (uint16_t )3372, 
        (uint16_t )3378,      (uint16_t )3387,      (uint16_t )3393,      (uint16_t )3257, 
        (uint16_t )3263,      (uint16_t )3272,      (uint16_t )3278,      (uint16_t )3289, 
        (uint16_t )3295,      (uint16_t )3304,      (uint16_t )3310,      (uint16_t )3330, 
        (uint16_t )3336,      (uint16_t )3345,      (uint16_t )3351,      (uint16_t )3362, 
        (uint16_t )3368,      (uint16_t )3377,      (uint16_t )3383,      (uint16_t )3408, 
        (uint16_t )3414,      (uint16_t )3423,      (uint16_t )3429,      (uint16_t )3440, 
        (uint16_t )3446,      (uint16_t )3455,      (uint16_t )3461,      (uint16_t )3481, 
        (uint16_t )3487,      (uint16_t )3496,      (uint16_t )3502,      (uint16_t )3513, 
        (uint16_t )3519,      (uint16_t )3528,      (uint16_t )3534,      (uint16_t )3557, 
        (uint16_t )3563,      (uint16_t )3572,      (uint16_t )3578,      (uint16_t )3589, 
        (uint16_t )3595,      (uint16_t )3604,      (uint16_t )3610,      (uint16_t )3630, 
        (uint16_t )3636,      (uint16_t )3645,      (uint16_t )3651,      (uint16_t )3662, 
        (uint16_t )3668,      (uint16_t )3677,      (uint16_t )3683,      (uint16_t )3708, 
        (uint16_t )3714,      (uint16_t )3723,      (uint16_t )3729,      (uint16_t )3740, 
        (uint16_t )3746,      (uint16_t )3755,      (uint16_t )3761,      (uint16_t )3781, 
        (uint16_t )3787,      (uint16_t )3796,      (uint16_t )3802,      (uint16_t )3813, 
        (uint16_t )3819,      (uint16_t )3828,      (uint16_t )3834,      (uint16_t )3629, 
        (uint16_t )3635,      (uint16_t )3644,      (uint16_t )3650,      (uint16_t )3661, 
        (uint16_t )3667,      (uint16_t )3676,      (uint16_t )3682,      (uint16_t )3702, 
        (uint16_t )3708,      (uint16_t )3717,      (uint16_t )3723,      (uint16_t )3734, 
        (uint16_t )3740,      (uint16_t )3749,      (uint16_t )3755,      (uint16_t )3780, 
        (uint16_t )3786,      (uint16_t )3795,      (uint16_t )3801,      (uint16_t )3812, 
        (uint16_t )3818,      (uint16_t )3827,      (uint16_t )3833,      (uint16_t )3853, 
        (uint16_t )3859,      (uint16_t )3868,      (uint16_t )3874,      (uint16_t )3885, 
        (uint16_t )3891,      (uint16_t )3900,      (uint16_t )3906,      (uint16_t )3929, 
        (uint16_t )3935,      (uint16_t )3944,      (uint16_t )3950,      (uint16_t )3961, 
        (uint16_t )3967,      (uint16_t )3976,      (uint16_t )3982,      (uint16_t )4002, 
        (uint16_t )4008,      (uint16_t )4017,      (uint16_t )4023,      (uint16_t )4034, 
        (uint16_t )4040,      (uint16_t )4049,      (uint16_t )4055,      (uint16_t )4080, 
        (uint16_t )4086,      (uint16_t )4095,      (uint16_t )4101,      (uint16_t )4112, 
        (uint16_t )4118,      (uint16_t )4127,      (uint16_t )4133,      (uint16_t )4153, 
        (uint16_t )4159,      (uint16_t )4168,      (uint16_t )4174,      (uint16_t )4185, 
        (uint16_t )4191,      (uint16_t )4200,      (uint16_t )4206,      (uint16_t )4070, 
        (uint16_t )4076,      (uint16_t )4085,      (uint16_t )4091,      (uint16_t )4102, 
        (uint16_t )4108,      (uint16_t )4117,      (uint16_t )4123,      (uint16_t )4143, 
        (uint16_t )4149,      (uint16_t )4158,      (uint16_t )4164,      (uint16_t )4175, 
        (uint16_t )4181,      (uint16_t )4190,      (uint16_t )4196,      (uint16_t )4221, 
        (uint16_t )4227,      (uint16_t )4236,      (uint16_t )4242,      (uint16_t )4253, 
        (uint16_t )4259,      (uint16_t )4268,      (uint16_t )4274,      (uint16_t )4294, 
        (uint16_t )4300,      (uint16_t )4309,      (uint16_t )4315,      (uint16_t )4326, 
        (uint16_t )4332,      (uint16_t )4341,      (uint16_t )4347,      (uint16_t )4370, 
        (uint16_t )4376,      (uint16_t )4385,      (uint16_t )4391,      (uint16_t )4402, 
        (uint16_t )4408,      (uint16_t )4417,      (uint16_t )4423,      (uint16_t )4443, 
        (uint16_t )4449,      (uint16_t )4458,      (uint16_t )4464,      (uint16_t )4475, 
        (uint16_t )4481,      (uint16_t )4490,      (uint16_t )4496,      (uint16_t )4521, 
        (uint16_t )4527,      (uint16_t )4536,      (uint16_t )4542,      (uint16_t )4553, 
        (uint16_t )4559,      (uint16_t )4568,      (uint16_t )4574,      (uint16_t )4594, 
        (uint16_t )4600,      (uint16_t )4609,      (uint16_t )4615,      (uint16_t )4626, 
        (uint16_t )4632,      (uint16_t )4641,      (uint16_t )4647,      (uint16_t )3515, 
        (uint16_t )3521,      (uint16_t )3530,      (uint16_t )3536,      (uint16_t )3547, 
        (uint16_t )3553,      (uint16_t )3562,      (uint16_t )3568,      (uint16_t )3588, 
        (uint16_t )3594,      (uint16_t )3603,      (uint16_t )3609,      (uint16_t )3620, 
        (uint16_t )3626,      (uint16_t )3635,      (uint16_t )3641,      (uint16_t )3666, 
        (uint16_t )3672,      (uint16_t )3681,      (uint16_t )3687,      (uint16_t )3698, 
        (uint16_t )3704,      (uint16_t )3713,      (uint16_t )3719,      (uint16_t )3739, 
        (uint16_t )3745,      (uint16_t )3754,      (uint16_t )3760,      (uint16_t )3771, 
        (uint16_t )3777,      (uint16_t )3786,      (uint16_t )3792,      (uint16_t )3815, 
        (uint16_t )3821,      (uint16_t )3830,      (uint16_t )3836,      (uint16_t )3847, 
        (uint16_t )3853,      (uint16_t )3862,      (uint16_t )3868,      (uint16_t )3888, 
        (uint16_t )3894,      (uint16_t )3903,      (uint16_t )3909,      (uint16_t )3920, 
        (uint16_t )3926,      (uint16_t )3935,      (uint16_t )3941,      (uint16_t )3966, 
        (uint16_t )3972,      (uint16_t )3981,      (uint16_t )3987,      (uint16_t )3998, 
        (uint16_t )4004,      (uint16_t )4013,      (uint16_t )4019,      (uint16_t )4039, 
        (uint16_t )4045,      (uint16_t )4054,      (uint16_t )4060,      (uint16_t )4071, 
        (uint16_t )4077,      (uint16_t )4086,      (uint16_t )4092,      (uint16_t )3956, 
        (uint16_t )3962,      (uint16_t )3971,      (uint16_t )3977,      (uint16_t )3988, 
        (uint16_t )3994,      (uint16_t )4003,      (uint16_t )4009,      (uint16_t )4029, 
        (uint16_t )4035,      (uint16_t )4044,      (uint16_t )4050,      (uint16_t )4061, 
        (uint16_t )4067,      (uint16_t )4076,      (uint16_t )4082,      (uint16_t )4107, 
        (uint16_t )4113,      (uint16_t )4122,      (uint16_t )4128,      (uint16_t )4139, 
        (uint16_t )4145,      (uint16_t )4154,      (uint16_t )4160,      (uint16_t )4180, 
        (uint16_t )4186,      (uint16_t )4195,      (uint16_t )4201,      (uint16_t )4212, 
        (uint16_t )4218,      (uint16_t )4227,      (uint16_t )4233,      (uint16_t )4256, 
        (uint16_t )4262,      (uint16_t )4271,      (uint16_t )4277,      (uint16_t )4288, 
        (uint16_t )4294,      (uint16_t )4303,      (uint16_t )4309,      (uint16_t )4329, 
        (uint16_t )4335,      (uint16_t )4344,      (uint16_t )4350,      (uint16_t )4361, 
        (uint16_t )4367,      (uint16_t )4376,      (uint16_t )4382,      (uint16_t )4407, 
        (uint16_t )4413,      (uint16_t )4422,      (uint16_t )4428,      (uint16_t )4439, 
        (uint16_t )4445,      (uint16_t )4454,      (uint16_t )4460,      (uint16_t )4480, 
        (uint16_t )4486,      (uint16_t )4495,      (uint16_t )4501,      (uint16_t )4512, 
        (uint16_t )4518,      (uint16_t )4527,      (uint16_t )4533,      (uint16_t )4328, 
        (uint16_t )4334,      (uint16_t )4343,      (uint16_t )4349,      (uint16_t )4360, 
        (uint16_t )4366,      (uint16_t )4375,      (uint16_t )4381,      (uint16_t )4401, 
        (uint16_t )4407,      (uint16_t )4416,      (uint16_t )4422,      (uint16_t )4433, 
        (uint16_t )4439,      (uint16_t )4448,      (uint16_t )4454,      (uint16_t )4479, 
        (uint16_t )4485,      (uint16_t )4494,      (uint16_t )4500,      (uint16_t )4511, 
        (uint16_t )4517,      (uint16_t )4526,      (uint16_t )4532,      (uint16_t )4552, 
        (uint16_t )4558,      (uint16_t )4567,      (uint16_t )4573,      (uint16_t )4584, 
        (uint16_t )4590,      (uint16_t )4599,      (uint16_t )4605,      (uint16_t )4628, 
        (uint16_t )4634,      (uint16_t )4643,      (uint16_t )4649,      (uint16_t )4660, 
        (uint16_t )4666,      (uint16_t )4675,      (uint16_t )4681,      (uint16_t )4701, 
        (uint16_t )4707,      (uint16_t )4716,      (uint16_t )4722,      (uint16_t )4733, 
        (uint16_t )4739,      (uint16_t )4748,      (uint16_t )4754,      (uint16_t )4779, 
        (uint16_t )4785,      (uint16_t )4794,      (uint16_t )4800,      (uint16_t )4811, 
        (uint16_t )4817,      (uint16_t )4826,      (uint16_t )4832,      (uint16_t )4852, 
        (uint16_t )4858,      (uint16_t )4867,      (uint16_t )4873,      (uint16_t )4884, 
        (uint16_t )4890,      (uint16_t )4899,      (uint16_t )4905,      (uint16_t )4769, 
        (uint16_t )4775,      (uint16_t )4784,      (uint16_t )4790,      (uint16_t )4801, 
        (uint16_t )4807,      (uint16_t )4816,      (uint16_t )4822,      (uint16_t )4842, 
        (uint16_t )4848,      (uint16_t )4857,      (uint16_t )4863,      (uint16_t )4874, 
        (uint16_t )4880,      (uint16_t )4889,      (uint16_t )4895,      (uint16_t )4920, 
        (uint16_t )4926,      (uint16_t )4935,      (uint16_t )4941,      (uint16_t )4952, 
        (uint16_t )4958,      (uint16_t )4967,      (uint16_t )4973,      (uint16_t )4993, 
        (uint16_t )4999,      (uint16_t )5008,      (uint16_t )5014,      (uint16_t )5025, 
        (uint16_t )5031,      (uint16_t )5040,      (uint16_t )5046,      (uint16_t )5069, 
        (uint16_t )5075,      (uint16_t )5084,      (uint16_t )5090,      (uint16_t )5101, 
        (uint16_t )5107,      (uint16_t )5116,      (uint16_t )5122,      (uint16_t )5142, 
        (uint16_t )5148,      (uint16_t )5157,      (uint16_t )5163,      (uint16_t )5174, 
        (uint16_t )5180,      (uint16_t )5189,      (uint16_t )5195,      (uint16_t )5220, 
        (uint16_t )5226,      (uint16_t )5235,      (uint16_t )5241,      (uint16_t )5252, 
        (uint16_t )5258,      (uint16_t )5267,      (uint16_t )5273,      (uint16_t )5293, 
        (uint16_t )5299,      (uint16_t )5308,      (uint16_t )5314,      (uint16_t )5325, 
        (uint16_t )5331,      (uint16_t )5340,      (uint16_t )5346,      (uint16_t )4604, 
        (uint16_t )4610,      (uint16_t )4619,      (uint16_t )4625,      (uint16_t )4636, 
        (uint16_t )4642,      (uint16_t )4651,      (uint16_t )4657,      (uint16_t )4677, 
        (uint16_t )4683,      (uint16_t )4692,      (uint16_t )4698,      (uint16_t )4709, 
        (uint16_t )4715,      (uint16_t )4724,      (uint16_t )4730,      (uint16_t )4755, 
        (uint16_t )4761,      (uint16_t )4770,      (uint16_t )4776,      (uint16_t )4787, 
        (uint16_t )4793,      (uint16_t )4802,      (uint16_t )4808,      (uint16_t )4828, 
        (uint16_t )4834,      (uint16_t )4843,      (uint16_t )4849,      (uint16_t )4860, 
        (uint16_t )4866,      (uint16_t )4875,      (uint16_t )4881,      (uint16_t )4904, 
        (uint16_t )4910,      (uint16_t )4919,      (uint16_t )4925,      (uint16_t )4936, 
        (uint16_t )4942,      (uint16_t )4951,      (uint16_t )4957,      (uint16_t )4977, 
        (uint16_t )4983,      (uint16_t )4992,      (uint16_t )4998,      (uint16_t )5009, 
        (uint16_t )5015,      (uint16_t )5024,      (uint16_t )5030,      (uint16_t )5055, 
        (uint16_t )5061,      (uint16_t )5070,      (uint16_t )5076,      (uint16_t )5087, 
        (uint16_t )5093,      (uint16_t )5102,      (uint16_t )5108,      (uint16_t )5128, 
        (uint16_t )5134,      (uint16_t )5143,      (uint16_t )5149,      (uint16_t )5160, 
        (uint16_t )5166,      (uint16_t )5175,      (uint16_t )5181,      (uint16_t )5045, 
        (uint16_t )5051,      (uint16_t )5060,      (uint16_t )5066,      (uint16_t )5077, 
        (uint16_t )5083,      (uint16_t )5092,      (uint16_t )5098,      (uint16_t )5118, 
        (uint16_t )5124,      (uint16_t )5133,      (uint16_t )5139,      (uint16_t )5150, 
        (uint16_t )5156,      (uint16_t )5165,      (uint16_t )5171,      (uint16_t )5196, 
        (uint16_t )5202,      (uint16_t )5211,      (uint16_t )5217,      (uint16_t )5228, 
        (uint16_t )5234,      (uint16_t )5243,      (uint16_t )5249,      (uint16_t )5269, 
        (uint16_t )5275,      (uint16_t )5284,      (uint16_t )5290,      (uint16_t )5301, 
        (uint16_t )5307,      (uint16_t )5316,      (uint16_t )5322,      (uint16_t )5345, 
        (uint16_t )5351,      (uint16_t )5360,      (uint16_t )5366,      (uint16_t )5377, 
        (uint16_t )5383,      (uint16_t )5392,      (uint16_t )5398,      (uint16_t )5418, 
        (uint16_t )5424,      (uint16_t )5433,      (uint16_t )5439,      (uint16_t )5450, 
        (uint16_t )5456,      (uint16_t )5465,      (uint16_t )5471,      (uint16_t )5496, 
        (uint16_t )5502,      (uint16_t )5511,      (uint16_t )5517,      (uint16_t )5528, 
        (uint16_t )5534,      (uint16_t )5543,      (uint16_t )5549,      (uint16_t )5569, 
        (uint16_t )5575,      (uint16_t )5584,      (uint16_t )5590,      (uint16_t )5601, 
        (uint16_t )5607,      (uint16_t )5616,      (uint16_t )5622,      (uint16_t )5417, 
        (uint16_t )5423,      (uint16_t )5432,      (uint16_t )5438,      (uint16_t )5449, 
        (uint16_t )5455,      (uint16_t )5464,      (uint16_t )5470,      (uint16_t )5490, 
        (uint16_t )5496,      (uint16_t )5505,      (uint16_t )5511,      (uint16_t )5522, 
        (uint16_t )5528,      (uint16_t )5537,      (uint16_t )5543,      (uint16_t )5568, 
        (uint16_t )5574,      (uint16_t )5583,      (uint16_t )5589,      (uint16_t )5600, 
        (uint16_t )5606,      (uint16_t )5615,      (uint16_t )5621,      (uint16_t )5641, 
        (uint16_t )5647,      (uint16_t )5656,      (uint16_t )5662,      (uint16_t )5673, 
        (uint16_t )5679,      (uint16_t )5688,      (uint16_t )5694,      (uint16_t )5717, 
        (uint16_t )5723,      (uint16_t )5732,      (uint16_t )5738,      (uint16_t )5749, 
        (uint16_t )5755,      (uint16_t )5764,      (uint16_t )5770,      (uint16_t )5790, 
        (uint16_t )5796,      (uint16_t )5805,      (uint16_t )5811,      (uint16_t )5822, 
        (uint16_t )5828,      (uint16_t )5837,      (uint16_t )5843,      (uint16_t )5868, 
        (uint16_t )5874,      (uint16_t )5883,      (uint16_t )5889,      (uint16_t )5900, 
        (uint16_t )5906,      (uint16_t )5915,      (uint16_t )5921,      (uint16_t )5941, 
        (uint16_t )5947,      (uint16_t )5956,      (uint16_t )5962,      (uint16_t )5973, 
        (uint16_t )5979,      (uint16_t )5988,      (uint16_t )5994,      (uint16_t )5858, 
        (uint16_t )5864,      (uint16_t )5873,      (uint16_t )5879,      (uint16_t )5890, 
        (uint16_t )5896,      (uint16_t )5905,      (uint16_t )5911,      (uint16_t )5931, 
        (uint16_t )5937,      (uint16_t )5946,      (uint16_t )5952,      (uint16_t )5963, 
        (uint16_t )5969,      (uint16_t )5978,      (uint16_t )5984,      (uint16_t )6009, 
        (uint16_t )6015,      (uint16_t )6024,      (uint16_t )6030,      (uint16_t )6041, 
        (uint16_t )6047,      (uint16_t )6056,      (uint16_t )6062,      (uint16_t )6082, 
        (uint16_t )6088,      (uint16_t )6097,      (uint16_t )6103,      (uint16_t )6114, 
        (uint16_t )6120,      (uint16_t )6129,      (uint16_t )6135,      (uint16_t )6158, 
        (uint16_t )6164,      (uint16_t )6173,      (uint16_t )6179,      (uint16_t )6190, 
        (uint16_t )6196,      (uint16_t )6205,      (uint16_t )6211,      (uint16_t )6231, 
        (uint16_t )6237,      (uint16_t )6246,      (uint16_t )6252,      (uint16_t )6263, 
        (uint16_t )6269,      (uint16_t )6278,      (uint16_t )6284,      (uint16_t )6309, 
        (uint16_t )6315,      (uint16_t )6324,      (uint16_t )6330,      (uint16_t )6341, 
        (uint16_t )6347,      (uint16_t )6356,      (uint16_t )6362,      (uint16_t )6382, 
        (uint16_t )6388,      (uint16_t )6397,      (uint16_t )6403,      (uint16_t )6414, 
        (uint16_t )6420,      (uint16_t )6429,      (uint16_t )6435,      (uint16_t )3515, 
        (uint16_t )3521,      (uint16_t )3530,      (uint16_t )3536,      (uint16_t )3547, 
        (uint16_t )3553,      (uint16_t )3562,      (uint16_t )3568,      (uint16_t )3588, 
        (uint16_t )3594,      (uint16_t )3603,      (uint16_t )3609,      (uint16_t )3620, 
        (uint16_t )3626,      (uint16_t )3635,      (uint16_t )3641,      (uint16_t )3666, 
        (uint16_t )3672,      (uint16_t )3681,      (uint16_t )3687,      (uint16_t )3698, 
        (uint16_t )3704,      (uint16_t )3713,      (uint16_t )3719,      (uint16_t )3739, 
        (uint16_t )3745,      (uint16_t )3754,      (uint16_t )3760,      (uint16_t )3771, 
        (uint16_t )3777,      (uint16_t )3786,      (uint16_t )3792,      (uint16_t )3815, 
        (uint16_t )3821,      (uint16_t )3830,      (uint16_t )3836,      (uint16_t )3847, 
        (uint16_t )3853,      (uint16_t )3862,      (uint16_t )3868,      (uint16_t )3888, 
        (uint16_t )3894,      (uint16_t )3903,      (uint16_t )3909,      (uint16_t )3920, 
        (uint16_t )3926,      (uint16_t )3935,      (uint16_t )3941,      (uint16_t )3966, 
        (uint16_t )3972,      (uint16_t )3981,      (uint16_t )3987,      (uint16_t )3998, 
        (uint16_t )4004,      (uint16_t )4013,      (uint16_t )4019,      (uint16_t )4039, 
        (uint16_t )4045,      (uint16_t )4054,      (uint16_t )4060,      (uint16_t )4071, 
        (uint16_t )4077,      (uint16_t )4086,      (uint16_t )4092,      (uint16_t )3956, 
        (uint16_t )3962,      (uint16_t )3971,      (uint16_t )3977,      (uint16_t )3988, 
        (uint16_t )3994,      (uint16_t )4003,      (uint16_t )4009,      (uint16_t )4029, 
        (uint16_t )4035,      (uint16_t )4044,      (uint16_t )4050,      (uint16_t )4061, 
        (uint16_t )4067,      (uint16_t )4076,      (uint16_t )4082,      (uint16_t )4107, 
        (uint16_t )4113,      (uint16_t )4122,      (uint16_t )4128,      (uint16_t )4139, 
        (uint16_t )4145,      (uint16_t )4154,      (uint16_t )4160,      (uint16_t )4180, 
        (uint16_t )4186,      (uint16_t )4195,      (uint16_t )4201,      (uint16_t )4212, 
        (uint16_t )4218,      (uint16_t )4227,      (uint16_t )4233,      (uint16_t )4256, 
        (uint16_t )4262,      (uint16_t )4271,      (uint16_t )4277,      (uint16_t )4288, 
        (uint16_t )4294,      (uint16_t )4303,      (uint16_t )4309,      (uint16_t )4329, 
        (uint16_t )4335,      (uint16_t )4344,      (uint16_t )4350,      (uint16_t )4361, 
        (uint16_t )4367,      (uint16_t )4376,      (uint16_t )4382,      (uint16_t )4407, 
        (uint16_t )4413,      (uint16_t )4422,      (uint16_t )4428,      (uint16_t )4439, 
        (uint16_t )4445,      (uint16_t )4454,      (uint16_t )4460,      (uint16_t )4480, 
        (uint16_t )4486,      (uint16_t )4495,      (uint16_t )4501,      (uint16_t )4512, 
        (uint16_t )4518,      (uint16_t )4527,      (uint16_t )4533,      (uint16_t )4328, 
        (uint16_t )4334,      (uint16_t )4343,      (uint16_t )4349,      (uint16_t )4360, 
        (uint16_t )4366,      (uint16_t )4375,      (uint16_t )4381,      (uint16_t )4401, 
        (uint16_t )4407,      (uint16_t )4416,      (uint16_t )4422,      (uint16_t )4433, 
        (uint16_t )4439,      (uint16_t )4448,      (uint16_t )4454,      (uint16_t )4479, 
        (uint16_t )4485,      (uint16_t )4494,      (uint16_t )4500,      (uint16_t )4511, 
        (uint16_t )4517,      (uint16_t )4526,      (uint16_t )4532,      (uint16_t )4552, 
        (uint16_t )4558,      (uint16_t )4567,      (uint16_t )4573,      (uint16_t )4584, 
        (uint16_t )4590,      (uint16_t )4599,      (uint16_t )4605,      (uint16_t )4628, 
        (uint16_t )4634,      (uint16_t )4643,      (uint16_t )4649,      (uint16_t )4660, 
        (uint16_t )4666,      (uint16_t )4675,      (uint16_t )4681,      (uint16_t )4701, 
        (uint16_t )4707,      (uint16_t )4716,      (uint16_t )4722,      (uint16_t )4733, 
        (uint16_t )4739,      (uint16_t )4748,      (uint16_t )4754,      (uint16_t )4779, 
        (uint16_t )4785,      (uint16_t )4794,      (uint16_t )4800,      (uint16_t )4811, 
        (uint16_t )4817,      (uint16_t )4826,      (uint16_t )4832,      (uint16_t )4852, 
        (uint16_t )4858,      (uint16_t )4867,      (uint16_t )4873,      (uint16_t )4884, 
        (uint16_t )4890,      (uint16_t )4899,      (uint16_t )4905,      (uint16_t )4769, 
        (uint16_t )4775,      (uint16_t )4784,      (uint16_t )4790,      (uint16_t )4801, 
        (uint16_t )4807,      (uint16_t )4816,      (uint16_t )4822,      (uint16_t )4842, 
        (uint16_t )4848,      (uint16_t )4857,      (uint16_t )4863,      (uint16_t )4874, 
        (uint16_t )4880,      (uint16_t )4889,      (uint16_t )4895,      (uint16_t )4920, 
        (uint16_t )4926,      (uint16_t )4935,      (uint16_t )4941,      (uint16_t )4952, 
        (uint16_t )4958,      (uint16_t )4967,      (uint16_t )4973,      (uint16_t )4993, 
        (uint16_t )4999,      (uint16_t )5008,      (uint16_t )5014,      (uint16_t )5025, 
        (uint16_t )5031,      (uint16_t )5040,      (uint16_t )5046,      (uint16_t )5069, 
        (uint16_t )5075,      (uint16_t )5084,      (uint16_t )5090,      (uint16_t )5101, 
        (uint16_t )5107,      (uint16_t )5116,      (uint16_t )5122,      (uint16_t )5142, 
        (uint16_t )5148,      (uint16_t )5157,      (uint16_t )5163,      (uint16_t )5174, 
        (uint16_t )5180,      (uint16_t )5189,      (uint16_t )5195,      (uint16_t )5220, 
        (uint16_t )5226,      (uint16_t )5235,      (uint16_t )5241,      (uint16_t )5252, 
        (uint16_t )5258,      (uint16_t )5267,      (uint16_t )5273,      (uint16_t )5293, 
        (uint16_t )5299,      (uint16_t )5308,      (uint16_t )5314,      (uint16_t )5325, 
        (uint16_t )5331,      (uint16_t )5340,      (uint16_t )5346,      (uint16_t )4604, 
        (uint16_t )4610,      (uint16_t )4619,      (uint16_t )4625,      (uint16_t )4636, 
        (uint16_t )4642,      (uint16_t )4651,      (uint16_t )4657,      (uint16_t )4677, 
        (uint16_t )4683,      (uint16_t )4692,      (uint16_t )4698,      (uint16_t )4709, 
        (uint16_t )4715,      (uint16_t )4724,      (uint16_t )4730,      (uint16_t )4755, 
        (uint16_t )4761,      (uint16_t )4770,      (uint16_t )4776,      (uint16_t )4787, 
        (uint16_t )4793,      (uint16_t )4802,      (uint16_t )4808,      (uint16_t )4828, 
        (uint16_t )4834,      (uint16_t )4843,      (uint16_t )4849,      (uint16_t )4860, 
        (uint16_t )4866,      (uint16_t )4875,      (uint16_t )4881,      (uint16_t )4904, 
        (uint16_t )4910,      (uint16_t )4919,      (uint16_t )4925,      (uint16_t )4936, 
        (uint16_t )4942,      (uint16_t )4951,      (uint16_t )4957,      (uint16_t )4977, 
        (uint16_t )4983,      (uint16_t )4992,      (uint16_t )4998,      (uint16_t )5009, 
        (uint16_t )5015,      (uint16_t )5024,      (uint16_t )5030,      (uint16_t )5055, 
        (uint16_t )5061,      (uint16_t )5070,      (uint16_t )5076,      (uint16_t )5087, 
        (uint16_t )5093,      (uint16_t )5102,      (uint16_t )5108,      (uint16_t )5128, 
        (uint16_t )5134,      (uint16_t )5143,      (uint16_t )5149,      (uint16_t )5160, 
        (uint16_t )5166,      (uint16_t )5175,      (uint16_t )5181,      (uint16_t )5045, 
        (uint16_t )5051,      (uint16_t )5060,      (uint16_t )5066,      (uint16_t )5077, 
        (uint16_t )5083,      (uint16_t )5092,      (uint16_t )5098,      (uint16_t )5118, 
        (uint16_t )5124,      (uint16_t )5133,      (uint16_t )5139,      (uint16_t )5150, 
        (uint16_t )5156,      (uint16_t )5165,      (uint16_t )5171,      (uint16_t )5196, 
        (uint16_t )5202,      (uint16_t )5211,      (uint16_t )5217,      (uint16_t )5228, 
        (uint16_t )5234,      (uint16_t )5243,      (uint16_t )5249,      (uint16_t )5269, 
        (uint16_t )5275,      (uint16_t )5284,      (uint16_t )5290,      (uint16_t )5301, 
        (uint16_t )5307,      (uint16_t )5316,      (uint16_t )5322,      (uint16_t )5345, 
        (uint16_t )5351,      (uint16_t )5360,      (uint16_t )5366,      (uint16_t )5377, 
        (uint16_t )5383,      (uint16_t )5392,      (uint16_t )5398,      (uint16_t )5418, 
        (uint16_t )5424,      (uint16_t )5433,      (uint16_t )5439,      (uint16_t )5450, 
        (uint16_t )5456,      (uint16_t )5465,      (uint16_t )5471,      (uint16_t )5496, 
        (uint16_t )5502,      (uint16_t )5511,      (uint16_t )5517,      (uint16_t )5528, 
        (uint16_t )5534,      (uint16_t )5543,      (uint16_t )5549,      (uint16_t )5569, 
        (uint16_t )5575,      (uint16_t )5584,      (uint16_t )5590,      (uint16_t )5601, 
        (uint16_t )5607,      (uint16_t )5616,      (uint16_t )5622,      (uint16_t )5417, 
        (uint16_t )5423,      (uint16_t )5432,      (uint16_t )5438,      (uint16_t )5449, 
        (uint16_t )5455,      (uint16_t )5464,      (uint16_t )5470,      (uint16_t )5490, 
        (uint16_t )5496,      (uint16_t )5505,      (uint16_t )5511,      (uint16_t )5522, 
        (uint16_t )5528,      (uint16_t )5537,      (uint16_t )5543,      (uint16_t )5568, 
        (uint16_t )5574,      (uint16_t )5583,      (uint16_t )5589,      (uint16_t )5600, 
        (uint16_t )5606,      (uint16_t )5615,      (uint16_t )5621,      (uint16_t )5641, 
        (uint16_t )5647,      (uint16_t )5656,      (uint16_t )5662,      (uint16_t )5673, 
        (uint16_t )5679,      (uint16_t )5688,      (uint16_t )5694,      (uint16_t )5717, 
        (uint16_t )5723,      (uint16_t )5732,      (uint16_t )5738,      (uint16_t )5749, 
        (uint16_t )5755,      (uint16_t )5764,      (uint16_t )5770,      (uint16_t )5790, 
        (uint16_t )5796,      (uint16_t )5805,      (uint16_t )5811,      (uint16_t )5822, 
        (uint16_t )5828,      (uint16_t )5837,      (uint16_t )5843,      (uint16_t )5868, 
        (uint16_t )5874,      (uint16_t )5883,      (uint16_t )5889,      (uint16_t )5900, 
        (uint16_t )5906,      (uint16_t )5915,      (uint16_t )5921,      (uint16_t )5941, 
        (uint16_t )5947,      (uint16_t )5956,      (uint16_t )5962,      (uint16_t )5973, 
        (uint16_t )5979,      (uint16_t )5988,      (uint16_t )5994,      (uint16_t )5858, 
        (uint16_t )5864,      (uint16_t )5873,      (uint16_t )5879,      (uint16_t )5890, 
        (uint16_t )5896,      (uint16_t )5905,      (uint16_t )5911,      (uint16_t )5931, 
        (uint16_t )5937,      (uint16_t )5946,      (uint16_t )5952,      (uint16_t )5963, 
        (uint16_t )5969,      (uint16_t )5978,      (uint16_t )5984,      (uint16_t )6009, 
        (uint16_t )6015,      (uint16_t )6024,      (uint16_t )6030,      (uint16_t )6041, 
        (uint16_t )6047,      (uint16_t )6056,      (uint16_t )6062,      (uint16_t )6082, 
        (uint16_t )6088,      (uint16_t )6097,      (uint16_t )6103,      (uint16_t )6114, 
        (uint16_t )6120,      (uint16_t )6129,      (uint16_t )6135,      (uint16_t )6158, 
        (uint16_t )6164,      (uint16_t )6173,      (uint16_t )6179,      (uint16_t )6190, 
        (uint16_t )6196,      (uint16_t )6205,      (uint16_t )6211,      (uint16_t )6231, 
        (uint16_t )6237,      (uint16_t )6246,      (uint16_t )6252,      (uint16_t )6263, 
        (uint16_t )6269,      (uint16_t )6278,      (uint16_t )6284,      (uint16_t )6309, 
        (uint16_t )6315,      (uint16_t )6324,      (uint16_t )6330,      (uint16_t )6341, 
        (uint16_t )6347,      (uint16_t )6356,      (uint16_t )6362,      (uint16_t )6382, 
        (uint16_t )6388,      (uint16_t )6397,      (uint16_t )6403,      (uint16_t )6414, 
        (uint16_t )6420,      (uint16_t )6429,      (uint16_t )6435,      (uint16_t )5303, 
        (uint16_t )5309,      (uint16_t )5318,      (uint16_t )5324,      (uint16_t )5335, 
        (uint16_t )5341,      (uint16_t )5350,      (uint16_t )5356,      (uint16_t )5376, 
        (uint16_t )5382,      (uint16_t )5391,      (uint16_t )5397,      (uint16_t )5408, 
        (uint16_t )5414,      (uint16_t )5423,      (uint16_t )5429,      (uint16_t )5454, 
        (uint16_t )5460,      (uint16_t )5469,      (uint16_t )5475,      (uint16_t )5486, 
        (uint16_t )5492,      (uint16_t )5501,      (uint16_t )5507,      (uint16_t )5527, 
        (uint16_t )5533,      (uint16_t )5542,      (uint16_t )5548,      (uint16_t )5559, 
        (uint16_t )5565,      (uint16_t )5574,      (uint16_t )5580,      (uint16_t )5603, 
        (uint16_t )5609,      (uint16_t )5618,      (uint16_t )5624,      (uint16_t )5635, 
        (uint16_t )5641,      (uint16_t )5650,      (uint16_t )5656,      (uint16_t )5676, 
        (uint16_t )5682,      (uint16_t )5691,      (uint16_t )5697,      (uint16_t )5708, 
        (uint16_t )5714,      (uint16_t )5723,      (uint16_t )5729,      (uint16_t )5754, 
        (uint16_t )5760,      (uint16_t )5769,      (uint16_t )5775,      (uint16_t )5786, 
        (uint16_t )5792,      (uint16_t )5801,      (uint16_t )5807,      (uint16_t )5827, 
        (uint16_t )5833,      (uint16_t )5842,      (uint16_t )5848,      (uint16_t )5859, 
        (uint16_t )5865,      (uint16_t )5874,      (uint16_t )5880,      (uint16_t )5744, 
        (uint16_t )5750,      (uint16_t )5759,      (uint16_t )5765,      (uint16_t )5776, 
        (uint16_t )5782,      (uint16_t )5791,      (uint16_t )5797,      (uint16_t )5817, 
        (uint16_t )5823,      (uint16_t )5832,      (uint16_t )5838,      (uint16_t )5849, 
        (uint16_t )5855,      (uint16_t )5864,      (uint16_t )5870,      (uint16_t )5895, 
        (uint16_t )5901,      (uint16_t )5910,      (uint16_t )5916,      (uint16_t )5927, 
        (uint16_t )5933,      (uint16_t )5942,      (uint16_t )5948,      (uint16_t )5968, 
        (uint16_t )5974,      (uint16_t )5983,      (uint16_t )5989,      (uint16_t )6000, 
        (uint16_t )6006,      (uint16_t )6015,      (uint16_t )6021,      (uint16_t )6044, 
        (uint16_t )6050,      (uint16_t )6059,      (uint16_t )6065,      (uint16_t )6076, 
        (uint16_t )6082,      (uint16_t )6091,      (uint16_t )6097,      (uint16_t )6117, 
        (uint16_t )6123,      (uint16_t )6132,      (uint16_t )6138,      (uint16_t )6149, 
        (uint16_t )6155,      (uint16_t )6164,      (uint16_t )6170,      (uint16_t )6195, 
        (uint16_t )6201,      (uint16_t )6210,      (uint16_t )6216,      (uint16_t )6227, 
        (uint16_t )6233,      (uint16_t )6242,      (uint16_t )6248,      (uint16_t )6268, 
        (uint16_t )6274,      (uint16_t )6283,      (uint16_t )6289,      (uint16_t )6300, 
        (uint16_t )6306,      (uint16_t )6315,      (uint16_t )6321,      (uint16_t )6116, 
        (uint16_t )6122,      (uint16_t )6131,      (uint16_t )6137,      (uint16_t )6148, 
        (uint16_t )6154,      (uint16_t )6163,      (uint16_t )6169,      (uint16_t )6189, 
        (uint16_t )6195,      (uint16_t )6204,      (uint16_t )6210,      (uint16_t )6221, 
        (uint16_t )6227,      (uint16_t )6236,      (uint16_t )6242,      (uint16_t )6267, 
        (uint16_t )6273,      (uint16_t )6282,      (uint16_t )6288,      (uint16_t )6299, 
        (uint16_t )6305,      (uint16_t )6314,      (uint16_t )6320,      (uint16_t )6340, 
        (uint16_t )6346,      (uint16_t )6355,      (uint16_t )6361,      (uint16_t )6372, 
        (uint16_t )6378,      (uint16_t )6387,      (uint16_t )6393,      (uint16_t )6416, 
        (uint16_t )6422,      (uint16_t )6431,      (uint16_t )6437,      (uint16_t )6448, 
        (uint16_t )6454,      (uint16_t )6463,      (uint16_t )6469,      (uint16_t )6489, 
        (uint16_t )6495,      (uint16_t )6504,      (uint16_t )6510,      (uint16_t )6521, 
        (uint16_t )6527,      (uint16_t )6536,      (uint16_t )6542,      (uint16_t )6567, 
        (uint16_t )6573,      (uint16_t )6582,      (uint16_t )6588,      (uint16_t )6599, 
        (uint16_t )6605,      (uint16_t )6614,      (uint16_t )6620,      (uint16_t )6640, 
        (uint16_t )6646,      (uint16_t )6655,      (uint16_t )6661,      (uint16_t )6672, 
        (uint16_t )6678,      (uint16_t )6687,      (uint16_t )6693,      (uint16_t )6557, 
        (uint16_t )6563,      (uint16_t )6572,      (uint16_t )6578,      (uint16_t )6589, 
        (uint16_t )6595,      (uint16_t )6604,      (uint16_t )6610,      (uint16_t )6630, 
        (uint16_t )6636,      (uint16_t )6645,      (uint16_t )6651,      (uint16_t )6662, 
        (uint16_t )6668,      (uint16_t )6677,      (uint16_t )6683,      (uint16_t )6708, 
        (uint16_t )6714,      (uint16_t )6723,      (uint16_t )6729,      (uint16_t )6740, 
        (uint16_t )6746,      (uint16_t )6755,      (uint16_t )6761,      (uint16_t )6781, 
        (uint16_t )6787,      (uint16_t )6796,      (uint16_t )6802,      (uint16_t )6813, 
        (uint16_t )6819,      (uint16_t )6828,      (uint16_t )6834,      (uint16_t )6857, 
        (uint16_t )6863,      (uint16_t )6872,      (uint16_t )6878,      (uint16_t )6889, 
        (uint16_t )6895,      (uint16_t )6904,      (uint16_t )6910,      (uint16_t )6930, 
        (uint16_t )6936,      (uint16_t )6945,      (uint16_t )6951,      (uint16_t )6962, 
        (uint16_t )6968,      (uint16_t )6977,      (uint16_t )6983,      (uint16_t )7008, 
        (uint16_t )7014,      (uint16_t )7023,      (uint16_t )7029,      (uint16_t )7040, 
        (uint16_t )7046,      (uint16_t )7055,      (uint16_t )7061,      (uint16_t )7081, 
        (uint16_t )7087,      (uint16_t )7096,      (uint16_t )7102,      (uint16_t )7113, 
        (uint16_t )7119,      (uint16_t )7128,      (uint16_t )7134,      (uint16_t )6392, 
        (uint16_t )6398,      (uint16_t )6407,      (uint16_t )6413,      (uint16_t )6424, 
        (uint16_t )6430,      (uint16_t )6439,      (uint16_t )6445,      (uint16_t )6465, 
        (uint16_t )6471,      (uint16_t )6480,      (uint16_t )6486,      (uint16_t )6497, 
        (uint16_t )6503,      (uint16_t )6512,      (uint16_t )6518,      (uint16_t )6543, 
        (uint16_t )6549,      (uint16_t )6558,      (uint16_t )6564,      (uint16_t )6575, 
        (uint16_t )6581,      (uint16_t )6590,      (uint16_t )6596,      (uint16_t )6616, 
        (uint16_t )6622,      (uint16_t )6631,      (uint16_t )6637,      (uint16_t )6648, 
        (uint16_t )6654,      (uint16_t )6663,      (uint16_t )6669,      (uint16_t )6692, 
        (uint16_t )6698,      (uint16_t )6707,      (uint16_t )6713,      (uint16_t )6724, 
        (uint16_t )6730,      (uint16_t )6739,      (uint16_t )6745,      (uint16_t )6765, 
        (uint16_t )6771,      (uint16_t )6780,      (uint16_t )6786,      (uint16_t )6797, 
        (uint16_t )6803,      (uint16_t )6812,      (uint16_t )6818,      (uint16_t )6843, 
        (uint16_t )6849,      (uint16_t )6858,      (uint16_t )6864,      (uint16_t )6875, 
        (uint16_t )6881,      (uint16_t )6890,      (uint16_t )6896,      (uint16_t )6916, 
        (uint16_t )6922,      (uint16_t )6931,      (uint16_t )6937,      (uint16_t )6948, 
        (uint16_t )6954,      (uint16_t )6963,      (uint16_t )6969,      (uint16_t )6833, 
        (uint16_t )6839,      (uint16_t )6848,      (uint16_t )6854,      (uint16_t )6865, 
        (uint16_t )6871,      (uint16_t )6880,      (uint16_t )6886,      (uint16_t )6906, 
        (uint16_t )6912,      (uint16_t )6921,      (uint16_t )6927,      (uint16_t )6938, 
        (uint16_t )6944,      (uint16_t )6953,      (uint16_t )6959,      (uint16_t )6984, 
        (uint16_t )6990,      (uint16_t )6999,      (uint16_t )7005,      (uint16_t )7016, 
        (uint16_t )7022,      (uint16_t )7031,      (uint16_t )7037,      (uint16_t )7057, 
        (uint16_t )7063,      (uint16_t )7072,      (uint16_t )7078,      (uint16_t )7089, 
        (uint16_t )7095,      (uint16_t )7104,      (uint16_t )7110,      (uint16_t )7133, 
        (uint16_t )7139,      (uint16_t )7148,      (uint16_t )7154,      (uint16_t )7165, 
        (uint16_t )7171,      (uint16_t )7180,      (uint16_t )7186,      (uint16_t )7206, 
        (uint16_t )7212,      (uint16_t )7221,      (uint16_t )7227,      (uint16_t )7238, 
        (uint16_t )7244,      (uint16_t )7253,      (uint16_t )7259,      (uint16_t )7284, 
        (uint16_t )7290,      (uint16_t )7299,      (uint16_t )7305,      (uint16_t )7316, 
        (uint16_t )7322,      (uint16_t )7331,      (uint16_t )7337,      (uint16_t )7357, 
        (uint16_t )7363,      (uint16_t )7372,      (uint16_t )7378,      (uint16_t )7389, 
        (uint16_t )7395,      (uint16_t )7404,      (uint16_t )7410,      (uint16_t )7205, 
        (uint16_t )7211,      (uint16_t )7220,      (uint16_t )7226,      (uint16_t )7237, 
        (uint16_t )7243,      (uint16_t )7252,      (uint16_t )7258,      (uint16_t )7278, 
        (uint16_t )7284,      (uint16_t )7293,      (uint16_t )7299,      (uint16_t )7310, 
        (uint16_t )7316,      (uint16_t )7325,      (uint16_t )7331,      (uint16_t )7356, 
        (uint16_t )7362,      (uint16_t )7371,      (uint16_t )7377,      (uint16_t )7388, 
        (uint16_t )7394,      (uint16_t )7403,      (uint16_t )7409,      (uint16_t )7429, 
        (uint16_t )7435,      (uint16_t )7444,      (uint16_t )7450,      (uint16_t )7461, 
        (uint16_t )7467,      (uint16_t )7476,      (uint16_t )7482,      (uint16_t )7505, 
        (uint16_t )7511,      (uint16_t )7520,      (uint16_t )7526,      (uint16_t )7537, 
        (uint16_t )7543,      (uint16_t )7552,      (uint16_t )7558,      (uint16_t )7578, 
        (uint16_t )7584,      (uint16_t )7593,      (uint16_t )7599,      (uint16_t )7610, 
        (uint16_t )7616,      (uint16_t )7625,      (uint16_t )7631,      (uint16_t )7656, 
        (uint16_t )7662,      (uint16_t )7671,      (uint16_t )7677,      (uint16_t )7688, 
        (uint16_t )7694,      (uint16_t )7703,      (uint16_t )7709,      (uint16_t )7729, 
        (uint16_t )7735,      (uint16_t )7744,      (uint16_t )7750,      (uint16_t )7761};
#line 314 "/root/patron-new/new_3/src/dsp/cost.c"
uint8_t VP8EncBands[17]  = 
#line 314
  {      (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )6,      (uint8_t )4,      (uint8_t )5,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )0};
#line 322 "/root/patron-new/new_3/src/dsp/cost.c"
static int GetResidualCost_C(int ctx0 , VP8Residual *res ) 
{ 
  int n ;
  int p0 ;
  CostArrayPtr costs ;
  uint16_t *t ;
  int cost ;
  int __cil_tmp8 ;
  int tmp___0 ;
  int __cil_tmp10 ;
  int v ;
  int __cil_tmp12 ;
  int ctx ;
  int tmp___1 ;
  int __cil_tmp15 ;
  int v___0 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int b ;
  int ctx___0 ;
  int tmp___2 ;
  int last_p0 ;
  int __cil_tmp23 ;

  {
#line 323
  n = res->first;
#line 325
  p0 = (int )(*(res->prob + n))[ctx0][0];
#line 326
  costs = res->costs;
#line 327
  t = (*(costs + n))[ctx0];
#line 331
  if (ctx0 == 0) {
    {
#line 331
    __cil_tmp8 = VP8BitCost(1, (uint8_t )p0);
#line 331
    tmp___0 = __cil_tmp8;
    }
  } else {
#line 331
    tmp___0 = 0;
  }
#line 331
  cost = tmp___0;
#line 333
  if (res->last < 0) {
    {
#line 334
    __cil_tmp10 = VP8BitCost(0, (uint8_t )p0);
    }
#line 334
    return (__cil_tmp10);
  }
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;

#line 336
    if (! (n < res->last)) {
#line 336
      goto while_break;
    }
    {
#line 337
    __cil_tmp12 = abs((int )*(res->coeffs + n));
#line 337
    v = __cil_tmp12;
    }
#line 338
    if (v >= 2) {
#line 338
      tmp___1 = 2;
    } else {
#line 338
      tmp___1 = v;
    }
    {
#line 338
    ctx = tmp___1;
#line 339
    __cil_tmp15 = VP8LevelCost(t, v);
#line 339
    cost += __cil_tmp15;
#line 340
    t = (*(costs + (n + 1)))[ctx];
#line 336
    n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 344
  __cil_tmp17 = abs((int )*(res->coeffs + n));
#line 344
  v___0 = __cil_tmp17;
#line 346
  __cil_tmp18 = VP8LevelCost(t, v___0);
#line 346
  cost += __cil_tmp18;
  }
#line 347
  if (n < 15) {
#line 348
    b = (int )VP8EncBands[n + 1];
#line 349
    if (v___0 == 1) {
#line 349
      tmp___2 = 1;
    } else {
#line 349
      tmp___2 = 2;
    }
    {
#line 349
    ctx___0 = tmp___2;
#line 350
    last_p0 = (int )(*(res->prob + b))[ctx___0][0];
#line 351
    __cil_tmp23 = VP8BitCost(0, (uint8_t )last_p0);
#line 351
    cost += __cil_tmp23;
    }
  }
#line 354
  return (cost);
}
}
#line 357 "/root/patron-new/new_3/src/dsp/cost.c"
static void SetResidualCoeffs_C(int16_t *coeffs , VP8Residual *res ) 
{ 
  int n ;

  {
#line 360
  res->last = -1;
#line 362
  n = 15;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;

#line 362
    if (! (n >= 0)) {
#line 362
      goto while_break;
    }
#line 363
    if (*(coeffs + n)) {
#line 364
      res->last = n;
#line 365
      goto while_break;
    }
#line 362
    n --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 368
  res->coeffs = coeffs;
#line 369
  return;
}
}
#line 379
extern void VP8EncDspCostInitSSE2(void) ;
#line 382
static void VP8EncDspCostInit_body(void) ;
#line 384 "/root/patron-new/new_3/src/dsp/cost.c"
static int (*VP8EncDspCostInit_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 385 "/root/patron-new/new_3/src/dsp/cost.c"
static pthread_mutex_t VP8EncDspCostInit_body_lock  ;
#line 382 "/root/patron-new/new_3/src/dsp/cost.c"
void VP8EncDspCostInit(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 382
    VP8EncDspCostInit_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& VP8EncDspCostInit_body_last_cpuinfo_used);
#line 382
    VP8EncDspCostInit_body_lock.__data.__lock = 0;
#line 382
    VP8EncDspCostInit_body_lock.__data.__count = 0U;
#line 382
    VP8EncDspCostInit_body_lock.__data.__owner = 0;
#line 382
    VP8EncDspCostInit_body_lock.__data.__nusers = 0U;
#line 382
    VP8EncDspCostInit_body_lock.__data.__kind = 0;
#line 382
    VP8EncDspCostInit_body_lock.__data.__spins = (short)0;
#line 382
    VP8EncDspCostInit_body_lock.__data.__elision = (short)0;
#line 382
    VP8EncDspCostInit_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 382
    VP8EncDspCostInit_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 382
    __cil_tmp3 = pthread_mutex_lock(& VP8EncDspCostInit_body_lock);
    }
#line 382
    if (__cil_tmp3) {
#line 382
      goto while_break;
    }
#line 382
    if ((unsigned long )VP8EncDspCostInit_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 382
      VP8EncDspCostInit_body();
      }
    }
    {
#line 382
    VP8EncDspCostInit_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 382
    pthread_mutex_unlock(& VP8EncDspCostInit_body_lock);
    }
#line 382
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 386
  return;
}
}
#line 382 "/root/patron-new/new_3/src/dsp/cost.c"
static void VP8EncDspCostInit_body(void) 
{ 
  int __cil_tmp1 ;

  {
#line 383
  VP8GetResidualCost = (int (*)(int  , struct VP8Residual * const   ))(& GetResidualCost_C);
#line 384
  VP8SetResidualCoeffs = (void (*)(int16_t * const   , struct VP8Residual * const   ))(& SetResidualCoeffs_C);
#line 387
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
    {
#line 399
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 399
    if (__cil_tmp1) {
      {
#line 400
      VP8EncDspCostInitSSE2();
      }
    }
  }
#line 404
  return;
}
}
#line 29 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
static uint32_t Mult(uint8_t x , uint32_t mult ) 
{ 
  uint32_t v ;

  {
#line 30
  v = ((unsigned int )x * mult + ((1U << 24) >> 1)) >> 24;
#line 32
  return (v);
}
}
#line 134 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
__inline static uint32_t GetScale(uint32_t a , int inverse ) 
{ 
  unsigned int tmp___0 ;

  {
#line 135
  if (inverse) {
#line 135
    tmp___0 = (255U << 24) / a;
  } else {
#line 135
    tmp___0 = a * ((1U << 24) / 255U);
  }
#line 135
  return (tmp___0);
}
}
#line 140 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
void WebPMultARGBRow_C(uint32_t *ptr , int width , int inverse ) 
{ 
  int x ;
  uint32_t argb ;
  uint32_t alpha ;
  uint32_t scale ;
  uint32_t __cil_tmp8 ;
  uint32_t out ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  uint32_t __cil_tmp12 ;

  {
#line 142
  x = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;

#line 142
    if (! (x < width)) {
#line 142
      goto while_break;
    }
#line 143
    argb = *(ptr + x);
#line 144
    if (argb < 4278190080U) {
#line 145
      if (argb <= 16777215U) {
#line 146
        *(ptr + x) = (uint32_t )0;
      } else {
        {
#line 148
        alpha = (argb >> 24) & 255U;
#line 149
        __cil_tmp8 = GetScale(alpha, inverse);
#line 149
        scale = __cil_tmp8;
#line 150
        out = argb & 4278190080U;
#line 151
        __cil_tmp10 = Mult((uint8_t )argb, scale);
#line 151
        out |= __cil_tmp10;
#line 152
        __cil_tmp11 = Mult((uint8_t )(argb >> 8), scale);
#line 152
        out |= __cil_tmp11 << 8;
#line 153
        __cil_tmp12 = Mult((uint8_t )(argb >> 16), scale);
#line 153
        out |= __cil_tmp12 << 16;
#line 154
        *(ptr + x) = out;
        }
      }
    }
#line 142
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 146
  return;
}
}
#line 160 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
void WebPMultRow_C(uint8_t *ptr , uint8_t *alpha , int width , int inverse ) 
{ 
  int x ;
  uint32_t a ;
  uint32_t scale ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;

  {
#line 163
  x = 0;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;

#line 163
    if (! (x < width)) {
#line 163
      goto while_break;
    }
#line 164
    a = (uint32_t )*(alpha + x);
#line 165
    if (a != 255U) {
#line 166
      if (a == 0U) {
#line 167
        *(ptr + x) = (uint8_t )0;
      } else {
        {
#line 169
        __cil_tmp8 = GetScale(a, inverse);
#line 169
        scale = __cil_tmp8;
#line 170
        __cil_tmp9 = Mult(*(ptr + x), scale);
#line 170
        *(ptr + x) = (uint8_t )__cil_tmp9;
        }
      }
    }
#line 163
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 167
  return;
}
}
#line 187 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
void WebPMultARGBRows(uint8_t *ptr , int stride , int width , int num_rows , int inverse ) 
{ 
  int n ;

  {
#line 190
  n = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;

#line 190
    if (! (n < num_rows)) {
#line 190
      goto while_break;
    }
    {
#line 191
    (*WebPMultARGBRow)((uint32_t */* const  */)((uint32_t *)ptr), width, inverse);
#line 192
    ptr += stride;
#line 190
    n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 194
  return;
}
}
#line 196 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
void WebPMultRows(uint8_t *ptr , int stride , uint8_t *alpha , int alpha_stride ,
                  int width , int num_rows , int inverse ) 
{ 
  int n ;

  {
#line 200
  n = 0;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;

#line 200
    if (! (n < num_rows)) {
#line 200
      goto while_break;
    }
    {
#line 201
    (*WebPMultRow)((uint8_t */* const  */)ptr, (uint8_t */* const  */)alpha, width,
                   inverse);
#line 202
    ptr += stride;
#line 203
    alpha += alpha_stride;
#line 200
    n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 204
  return;
}
}
#line 224 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
static void ApplyAlphaMultiply_C(uint8_t *rgba , int alpha_first , int w , int h ,
                                 int stride ) 
{ 
  int __cil_tmp6 ;
  uint8_t *rgb ;
  int tmp___0 ;
  uint8_t *alpha ;
  int tmp___1 ;
  int i ;
  uint32_t a ;
  uint32_t mult ;

  {
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    __cil_tmp6 = h;
#line 226
    h --;
#line 226
    if (! (__cil_tmp6 > 0)) {
#line 226
      goto while_break;
    }
#line 227
    if (alpha_first) {
#line 227
      tmp___0 = 1;
    } else {
#line 227
      tmp___0 = 0;
    }
#line 227
    rgb = rgba + tmp___0;
#line 228
    if (alpha_first) {
#line 228
      tmp___1 = 0;
    } else {
#line 228
      tmp___1 = 3;
    }
#line 228
    alpha = rgba + tmp___1;
#line 230
    i = 0;
    {
#line 230
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 230
      if (! (i < w)) {
#line 230
        goto while_break___0;
      }
#line 231
      a = (uint32_t )*(alpha + 4 * i);
#line 232
      if (a != 255U) {
#line 233
        mult = a * 32897U;
#line 234
        *(rgb + 4 * i) = (uint8_t )((unsigned int )*(rgb + 4 * i) * mult >> 23);
#line 235
        *(rgb + (4 * i + 1)) = (uint8_t )((unsigned int )*(rgb + (4 * i + 1)) * mult >> 23);
#line 236
        *(rgb + (4 * i + 2)) = (uint8_t )((unsigned int )*(rgb + (4 * i + 2)) * mult >> 23);
      }
#line 230
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 239
    rgba += stride;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 243
  return;
}
}
#line 250 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
__inline static uint8_t dither_hi(uint8_t x ) 
{ 


  {
#line 251
  return ((uint8_t )(((int )x & 240) | ((int )x >> 4)));
}
}
#line 254 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
__inline static uint8_t dither_lo(uint8_t x ) 
{ 


  {
#line 255
  return ((uint8_t )(((int )x & 15) | ((int )x << 4)));
}
}
#line 258 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
__inline static uint8_t multiply(uint8_t x , uint32_t m ) 
{ 


  {
#line 259
  return ((uint8_t )((unsigned int )x * m >> 16));
}
}
#line 262 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
__inline static void ApplyAlphaMultiply4444_C(uint8_t *rgba4444 , int w , int h ,
                                              int stride , int rg_byte_pos ) 
{ 
  int __cil_tmp6 ;
  int i ;
  uint32_t rg ;
  uint32_t ba ;
  uint8_t a ;
  uint32_t mult ;
  uint8_t r ;
  uint8_t __cil_tmp13 ;
  uint8_t __cil_tmp14 ;
  uint8_t g ;
  uint8_t __cil_tmp16 ;
  uint8_t __cil_tmp17 ;
  uint8_t b ;
  uint8_t __cil_tmp19 ;
  uint8_t __cil_tmp20 ;

  {
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    __cil_tmp6 = h;
#line 265
    h --;
#line 265
    if (! (__cil_tmp6 > 0)) {
#line 265
      goto while_break;
    }
#line 267
    i = 0;
    {
#line 267
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 267
      if (! (i < w)) {
#line 267
        goto while_break___0;
      }
      {
#line 268
      rg = (uint32_t )*(rgba4444 + (2 * i + rg_byte_pos));
#line 269
      ba = (uint32_t )*(rgba4444 + (2 * i + (rg_byte_pos ^ 1)));
#line 270
      a = (uint8_t )(ba & 15U);
#line 271
      mult = (uint32_t )((int )a * 4369);
#line 272
      __cil_tmp13 = dither_hi((uint8_t )rg);
#line 272
      __cil_tmp14 = multiply(__cil_tmp13, mult);
#line 272
      r = __cil_tmp14;
#line 273
      __cil_tmp16 = dither_lo((uint8_t )rg);
#line 273
      __cil_tmp17 = multiply(__cil_tmp16, mult);
#line 273
      g = __cil_tmp17;
#line 274
      __cil_tmp19 = dither_hi((uint8_t )ba);
#line 274
      __cil_tmp20 = multiply(__cil_tmp19, mult);
#line 274
      b = __cil_tmp20;
#line 275
      *(rgba4444 + (2 * i + rg_byte_pos)) = (uint8_t )(((int )r & 240) | (((int )g >> 4) & 15));
#line 276
      *(rgba4444 + (2 * i + (rg_byte_pos ^ 1))) = (uint8_t )(((int )b & 240) | (int )a);
#line 267
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 278
    rgba4444 += stride;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 282
  return;
}
}
#line 283 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
static void ApplyAlphaMultiply_16b_C(uint8_t *rgba4444 , int w , int h , int stride ) 
{ 


  {
  {
#line 288
  ApplyAlphaMultiply4444_C(rgba4444, w, h, stride, 0);
  }
#line 290
  return;
}
}
#line 293 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
static int DispatchAlpha_C(uint8_t *alpha , int alpha_stride , int width , int height ,
                           uint8_t *dst , int dst_stride ) 
{ 
  uint32_t alpha_mask ;
  int i ;
  int j ;
  uint32_t alpha_value ;

  {
#line 296
  alpha_mask = (uint32_t )255;
#line 299
  j = 0;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;

#line 299
    if (! (j < height)) {
#line 299
      goto while_break;
    }
#line 300
    i = 0;
    {
#line 300
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 300
      if (! (i < width)) {
#line 300
        goto while_break___0;
      }
#line 301
      alpha_value = (uint32_t )*(alpha + i);
#line 302
      *(dst + 4 * i) = (uint8_t )alpha_value;
#line 303
      alpha_mask &= alpha_value;
#line 300
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 305
    alpha += alpha_stride;
#line 306
    dst += dst_stride;
#line 299
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 309
  return (alpha_mask != 255U);
}
}
#line 312 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
static void DispatchAlphaToGreen_C(uint8_t *alpha , int alpha_stride , int width ,
                                   int height , uint32_t *dst , int dst_stride ) 
{ 
  int i ;
  int j ;

  {
#line 316
  j = 0;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;

#line 316
    if (! (j < height)) {
#line 316
      goto while_break;
    }
#line 317
    i = 0;
    {
#line 317
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 317
      if (! (i < width)) {
#line 317
        goto while_break___0;
      }
#line 318
      *(dst + i) = (uint32_t )((int )*(alpha + i) << 8);
#line 317
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 320
    alpha += alpha_stride;
#line 321
    dst += dst_stride;
#line 316
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 320
  return;
}
}
#line 325 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
static int ExtractAlpha_C(uint8_t *argb , int argb_stride , int width , int height ,
                          uint8_t *alpha , int alpha_stride ) 
{ 
  uint8_t alpha_mask ;
  int i ;
  int j ;
  uint8_t alpha_value ;

  {
#line 328
  alpha_mask = (uint8_t )255;
#line 331
  j = 0;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;

#line 331
    if (! (j < height)) {
#line 331
      goto while_break;
    }
#line 332
    i = 0;
    {
#line 332
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 332
      if (! (i < width)) {
#line 332
        goto while_break___0;
      }
#line 333
      alpha_value = *(argb + 4 * i);
#line 334
      *(alpha + i) = alpha_value;
#line 335
      alpha_mask = (uint8_t )((int )alpha_mask & (int )alpha_value);
#line 332
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 337
    argb += argb_stride;
#line 338
    alpha += alpha_stride;
#line 331
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 340
  return ((int )alpha_mask == 255);
}
}
#line 343 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
static void ExtractGreen_C(uint32_t *argb , uint8_t *alpha , int size ) 
{ 
  int i ;

  {
#line 345
  i = 0;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;

#line 345
    if (! (i < size)) {
#line 345
      goto while_break;
    }
#line 345
    *(alpha + i) = (uint8_t )(*(argb + i) >> 8);
#line 345
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 349
  return;
}
}
#line 351 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
static int HasAlpha8b_C(uint8_t *src , int length ) 
{ 
  int __cil_tmp3 ;
  uint8_t *__cil_tmp4 ;

  {
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    __cil_tmp3 = length;
#line 352
    length --;
#line 352
    if (! (__cil_tmp3 > 0)) {
#line 352
      goto while_break;
    }
#line 352
    __cil_tmp4 = src;
#line 352
    src ++;
#line 352
    if ((int )*__cil_tmp4 != 255) {
#line 352
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 353
  return (0);
}
}
#line 356 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
static int HasAlpha32b_C(uint8_t *src , int length ) 
{ 
  int x ;
  int __cil_tmp4 ;

  {
#line 358
  x = 0;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;

#line 358
    if (! (__cil_tmp4 > 0)) {
#line 358
      goto while_break;
    }
#line 358
    if ((int )*(src + x) != 255) {
#line 358
      return (1);
    }
#line 358
    x += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 359
  return (0);
}
}
#line 362 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
static void AlphaReplace_C(uint32_t *src , int length , uint32_t color ) 
{ 
  int x ;

  {
#line 364
  x = 0;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;

#line 364
    if (! (x < length)) {
#line 364
      goto while_break;
    }
#line 364
    if (*(src + x) >> 24 == 0U) {
#line 364
      *(src + x) = color;
    }
#line 364
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 368
  return;
}
}
#line 370 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
__inline static uint32_t MakeARGB32___0(int a , int r , int g , int b ) 
{ 


  {
#line 371
  return (((((uint32_t )a << 24) | (unsigned int )(r << 16)) | (unsigned int )(g << 8)) | (unsigned int )b);
}
}
#line 384 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
static void PackRGB_C(uint8_t *r , uint8_t *g , uint8_t *b , int len , int step ,
                      uint32_t *out ) 
{ 
  int i ;
  int offset ;

  {
#line 386
  offset = 0;
#line 387
  i = 0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;

#line 387
    if (! (i < len)) {
#line 387
      goto while_break;
    }
    {
#line 388
    *(out + i) = MakeARGB32___0(255, (int )*(r + offset), (int )*(g + offset), (int )*(b + offset));
#line 389
    offset += step;
#line 387
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 391
  return;
}
}
#line 414
extern void WebPInitAlphaProcessingSSE2(void) ;
#line 415
extern void WebPInitAlphaProcessingSSE41(void) ;
#line 418
static void WebPInitAlphaProcessing_body(void) ;
#line 420 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
static int (*WebPInitAlphaProcessing_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 421 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
static pthread_mutex_t WebPInitAlphaProcessing_body_lock  ;
#line 418 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
void WebPInitAlphaProcessing(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 418
    WebPInitAlphaProcessing_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& WebPInitAlphaProcessing_body_last_cpuinfo_used);
#line 418
    WebPInitAlphaProcessing_body_lock.__data.__lock = 0;
#line 418
    WebPInitAlphaProcessing_body_lock.__data.__count = 0U;
#line 418
    WebPInitAlphaProcessing_body_lock.__data.__owner = 0;
#line 418
    WebPInitAlphaProcessing_body_lock.__data.__nusers = 0U;
#line 418
    WebPInitAlphaProcessing_body_lock.__data.__kind = 0;
#line 418
    WebPInitAlphaProcessing_body_lock.__data.__spins = (short)0;
#line 418
    WebPInitAlphaProcessing_body_lock.__data.__elision = (short)0;
#line 418
    WebPInitAlphaProcessing_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 418
    WebPInitAlphaProcessing_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 418
    __cil_tmp3 = pthread_mutex_lock(& WebPInitAlphaProcessing_body_lock);
    }
#line 418
    if (__cil_tmp3) {
#line 418
      goto while_break;
    }
#line 418
    if ((unsigned long )WebPInitAlphaProcessing_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 418
      WebPInitAlphaProcessing_body();
      }
    }
    {
#line 418
    WebPInitAlphaProcessing_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 418
    pthread_mutex_unlock(& WebPInitAlphaProcessing_body_lock);
    }
#line 418
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 422
  return;
}
}
#line 418 "/root/patron-new/new_3/src/dsp/alpha_processing.c"
static void WebPInitAlphaProcessing_body(void) 
{ 
  int __cil_tmp1 ;
  int __cil_tmp2 ;

  {
#line 419
  WebPMultARGBRow = (void (*)(uint32_t * const   , int  , int  ))(& WebPMultARGBRow_C);
#line 420
  WebPMultRow = (void (*)(uint8_t * const   , uint8_t * const   , int  , int  ))(& WebPMultRow_C);
#line 421
  WebPApplyAlphaMultiply4444 = & ApplyAlphaMultiply_16b_C;
#line 426
  WebPPackRGB = & PackRGB_C;
#line 428
  WebPApplyAlphaMultiply = & ApplyAlphaMultiply_C;
#line 429
  WebPDispatchAlpha = & DispatchAlpha_C;
#line 430
  WebPDispatchAlphaToGreen = & DispatchAlphaToGreen_C;
#line 431
  WebPExtractAlpha = & ExtractAlpha_C;
#line 432
  WebPExtractGreen = & ExtractGreen_C;
#line 435
  WebPHasAlpha8b = & HasAlpha8b_C;
#line 436
  WebPHasAlpha32b = & HasAlpha32b_C;
#line 437
  WebPAlphaReplace = & AlphaReplace_C;
#line 440
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
    {
#line 442
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 442
    if (__cil_tmp1) {
      {
#line 443
      WebPInitAlphaProcessingSSE2();
#line 445
      __cil_tmp2 = (*VP8GetCPUInfo)((CPUFeature )3);
      }
#line 445
      if (__cil_tmp2) {
        {
#line 446
        WebPInitAlphaProcessingSSE41();
        }
      }
    }
  }
#line 451
  return;
}
}
#line 54 "/root/patron-new/new_3/src/dec/webp_dec.c"
static VP8StatusCode ParseRIFF(uint8_t **data , size_t *data_size , int have_all_data ,
                               size_t *riff_size ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  uint32_t size ;
  uint32_t __cil_tmp8 ;

  {
  {
#line 61
  *riff_size = (size_t )0;
#line 62
  __cil_tmp5 = memcmp((void const   *)*data, (void const   *)"RIFF", 4UL);
  }
#line 62
  if (*data_size >= 12UL) {
#line 62
    if (! __cil_tmp5) {
      {
#line 63
      __cil_tmp6 = memcmp((void const   *)(*data + 8), (void const   *)"WEBP", 4UL);
      }
#line 63
      if (__cil_tmp6) {
#line 64
        return ((VP8StatusCode )3);
      } else {
        {
#line 66
        __cil_tmp8 = GetLE32(*data + 4);
#line 66
        size = __cil_tmp8;
        }
#line 68
        if (size < 12U) {
#line 69
          return ((VP8StatusCode )3);
        }
#line 71
        if (size > 4294967286U) {
#line 72
          return ((VP8StatusCode )3);
        }
#line 74
        if (have_all_data) {
#line 74
          if ((unsigned long )size > *data_size - 8UL) {
#line 75
            return ((VP8StatusCode )7);
          }
        }
#line 78
        *riff_size = (size_t )size;
#line 79
        *data += 12;
#line 80
        *data_size -= 12UL;
      }
    }
  }
#line 83
  return ((VP8StatusCode )0);
}
}
#line 93 "/root/patron-new/new_3/src/dec/webp_dec.c"
static VP8StatusCode ParseVP8X(uint8_t **data , size_t *data_size , int *found_vp8x ,
                               int *width_ptr , int *height_ptr , uint32_t *flags_ptr ) 
{ 
  uint32_t vp8x_size ;
  int __cil_tmp8 ;
  int width ;
  int height ;
  uint32_t flags ;
  uint32_t chunk_size ;
  uint32_t __cil_tmp13 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 98
  vp8x_size = (uint32_t )18;
#line 103
  *found_vp8x = 0;
#line 105
  if (*data_size < 8UL) {
#line 106
    return ((VP8StatusCode )7);
  }
  {
#line 109
  __cil_tmp8 = memcmp((void const   *)*data, (void const   *)"VP8X\001V", 4UL);
  }
#line 109
  if (! __cil_tmp8) {
    {
#line 112
    __cil_tmp13 = GetLE32(*data + 4);
#line 112
    chunk_size = __cil_tmp13;
    }
#line 113
    if (chunk_size != 10U) {
#line 114
      return ((VP8StatusCode )3);
    }
#line 118
    if (*data_size < (unsigned long )vp8x_size) {
#line 119
      return ((VP8StatusCode )7);
    }
    {
#line 121
    flags = GetLE32(*data + 8);
#line 122
    __cil_tmp15 = GetLE24(*data + 12);
#line 122
    width = 1 + __cil_tmp15;
#line 123
    __cil_tmp16 = GetLE24(*data + 15);
#line 123
    height = 1 + __cil_tmp16;
    }
#line 124
    if ((unsigned long long )((unsigned long )width * (uint64_t )height) >= 1ULL << 32) {
#line 125
      return ((VP8StatusCode )3);
    }
#line 128
    if ((unsigned long )flags_ptr != (unsigned long )((void *)0)) {
#line 128
      *flags_ptr = flags;
    }
#line 129
    if ((unsigned long )width_ptr != (unsigned long )((void *)0)) {
#line 129
      *width_ptr = width;
    }
#line 130
    if ((unsigned long )height_ptr != (unsigned long )((void *)0)) {
#line 130
      *height_ptr = height;
    }
#line 132
    *data += vp8x_size;
#line 133
    *data_size -= (unsigned long )vp8x_size;
#line 134
    *found_vp8x = 1;
  }
#line 136
  return ((VP8StatusCode )0);
}
}
#line 146 "/root/patron-new/new_3/src/dec/webp_dec.c"
static VP8StatusCode ParseOptionalChunks(uint8_t **data , size_t *data_size , size_t riff_size ,
                                         uint8_t **alpha_data , size_t *alpha_size ) 
{ 
  uint8_t *buf ;
  size_t buf_size ;
  uint32_t total_size ;
  uint32_t chunk_size ;
  uint32_t disk_chunk_size ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 153
  total_size = (uint32_t )22;
#line 158
  buf = *data;
#line 159
  buf_size = *data_size;
#line 163
  *alpha_data = (uint8_t *)((void *)0);
#line 164
  *alpha_size = (size_t )0;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    *data = buf;
#line 171
    *data_size = buf_size;
#line 173
    if (buf_size < 8UL) {
#line 174
      return ((VP8StatusCode )7);
    }
    {
#line 177
    chunk_size = GetLE32(buf + 4);
    }
#line 178
    if (chunk_size > 4294967286U) {
#line 179
      return ((VP8StatusCode )3);
    }
#line 182
    disk_chunk_size = ((8U + chunk_size) + 1U) & 4294967294U;
#line 183
    total_size += disk_chunk_size;
#line 186
    if (riff_size > 0UL) {
#line 186
      if ((unsigned long )total_size > riff_size) {
#line 187
        return ((VP8StatusCode )3);
      }
    }
    {
#line 194
    __cil_tmp13 = memcmp((void const   *)buf, (void const   *)"VP8L", 4UL);
#line 194
    __cil_tmp12 = memcmp((void const   *)buf, (void const   *)"VP8 ", 4UL);
    }
#line 194
    if (! __cil_tmp12) {
#line 196
      return ((VP8StatusCode )0);
    } else
#line 194
    if (! __cil_tmp13) {
#line 196
      return ((VP8StatusCode )0);
    }
#line 199
    if (buf_size < (unsigned long )disk_chunk_size) {
#line 200
      return ((VP8StatusCode )7);
    }
    {
#line 203
    __cil_tmp14 = memcmp((void const   *)buf, (void const   *)"ALPH", 4UL);
    }
#line 203
    if (! __cil_tmp14) {
#line 204
      *alpha_data = buf + 8;
#line 205
      *alpha_size = (size_t )chunk_size;
    }
#line 209
    buf += disk_chunk_size;
#line 210
    buf_size -= (unsigned long )disk_chunk_size;
  }
  while_break: /* CIL Label */ ;
  }

#line 215
  return ((enum VP8StatusCode )0);
}
}
#line 222 "/root/patron-new/new_3/src/dec/webp_dec.c"
static VP8StatusCode ParseVP8Header(uint8_t **data_ptr , size_t *data_size , int have_all_data ,
                                    size_t riff_size , size_t *chunk_size , int *is_lossless ) 
{ 
  uint8_t *data ;
  int is_vp8 ;
  int __cil_tmp9 ;
  int is_vp8l ;
  int __cil_tmp11 ;
  uint32_t minimal_size ;
  uint32_t size ;
  uint32_t __cil_tmp14 ;

  {
  {
#line 226
  data = *data_ptr;
#line 227
  __cil_tmp9 = memcmp((void const   *)data, (void const   *)"VP8 \001V", 4UL);
#line 227
  is_vp8 = ! __cil_tmp9;
#line 228
  __cil_tmp11 = memcmp((void const   *)data, (void const   *)"VP8L\001V", 4UL);
#line 228
  is_vp8l = ! __cil_tmp11;
#line 229
  minimal_size = (uint32_t )12;
  }
#line 237
  if (*data_size < 8UL) {
#line 238
    return ((VP8StatusCode )7);
  }
#line 241
  if (is_vp8) {
    _L: 
    {
#line 243
    __cil_tmp14 = GetLE32(data + 4);
#line 243
    size = __cil_tmp14;
    }
#line 244
    if (riff_size >= (unsigned long )minimal_size) {
#line 244
      if ((unsigned long )size > riff_size - (unsigned long )minimal_size) {
#line 245
        return ((VP8StatusCode )3);
      }
    }
#line 247
    if (have_all_data) {
#line 247
      if ((unsigned long )size > *data_size - 8UL) {
#line 248
        return ((VP8StatusCode )7);
      }
    }
#line 251
    *chunk_size = (size_t )size;
#line 252
    *data_ptr += 8;
#line 253
    *data_size -= 8UL;
#line 254
    *is_lossless = is_vp8l;
  } else
#line 241
  if (is_vp8l) {
#line 241
    goto _L;
  } else {
    {
#line 257
    *is_lossless = VP8LCheckSignature(data, *data_size);
#line 258
    *chunk_size = *data_size;
    }
  }
#line 261
  return ((VP8StatusCode )0);
}
}
#line 277 "/root/patron-new/new_3/src/dec/webp_dec.c"
static VP8StatusCode ParseHeadersInternal(uint8_t *data , size_t data_size , int *width ,
                                          int *height , int *has_alpha , int *has_animation ,
                                          int *format , WebPHeaderStructure *headers ) 
{ 
  int canvas_width ;
  int canvas_height ;
  int image_width ;
  int image_height ;
  int found_riff ;
  int found_vp8x ;
  int animation_present ;
  int have_all_data ;
  int tmp___0 ;
  VP8StatusCode status ;
  WebPHeaderStructure hdrs ;
  uint32_t flags ;
  int __cil_tmp23 ;
  int tmp___1 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;

  {
#line 285
  canvas_width = 0;
#line 286
  canvas_height = 0;
#line 287
  image_width = 0;
#line 288
  image_height = 0;
#line 289
  found_riff = 0;
#line 290
  found_vp8x = 0;
#line 291
  animation_present = 0;
#line 292
  if ((unsigned long )headers != (unsigned long )((void *)0)) {
#line 292
    tmp___0 = headers->have_all_data;
  } else {
#line 292
    tmp___0 = 0;
  }
#line 292
  have_all_data = tmp___0;
#line 297
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 298
    return ((VP8StatusCode )7);
  } else
#line 297
  if (data_size < 12UL) {
#line 298
    return ((VP8StatusCode )7);
  }
  {
#line 300
  memset((void *)(& hdrs), 0, sizeof(hdrs));
#line 301
  hdrs.data = data;
#line 302
  hdrs.data_size = data_size;
#line 305
  status = ParseRIFF(& data, & data_size, have_all_data, & hdrs.riff_size);
  }
#line 306
  if ((unsigned int )status != 0U) {
#line 307
    return (status);
  }
  {
#line 309
  found_riff = hdrs.riff_size > 0UL;
#line 313
  flags = (uint32_t )0;
#line 314
  status = ParseVP8X(& data, & data_size, & found_vp8x, & canvas_width, & canvas_height,
                     & flags);
  }
#line 316
  if ((unsigned int )status != 0U) {
#line 317
    return (status);
  }
#line 319
  animation_present = ! (! (flags & 2U));
#line 320
  if (! found_riff) {
#line 320
    if (found_vp8x) {
#line 323
      return ((VP8StatusCode )3);
    }
  }
#line 325
  if ((unsigned long )has_alpha != (unsigned long )((void *)0)) {
#line 325
    *has_alpha = ! (! (flags & 16U));
  }
#line 326
  if ((unsigned long )has_animation != (unsigned long )((void *)0)) {
#line 326
    *has_animation = animation_present;
  }
#line 327
  if ((unsigned long )format != (unsigned long )((void *)0)) {
#line 327
    *format = 0;
  }
#line 329
  image_width = canvas_width;
#line 330
  image_height = canvas_height;
#line 331
  if ((unsigned long )headers == (unsigned long )((void *)0)) {
#line 331
    if (found_vp8x) {
#line 331
      if (animation_present) {
#line 332
        status = (VP8StatusCode )0;
#line 333
        goto ReturnWidthHeight;
      }
    }
  }
#line 337
  if (data_size < 4UL) {
#line 338
    status = (VP8StatusCode )7;
#line 339
    goto ReturnWidthHeight;
  }
  {
#line 343
  __cil_tmp23 = memcmp((void const   *)data, (void const   *)"ALPH", 4UL);
  }
#line 343
  if (found_riff) {
#line 343
    if (found_vp8x) {
      _L: 
      {
#line 345
      status = ParseOptionalChunks(& data, & data_size, hdrs.riff_size, & hdrs.alpha_data,
                                   & hdrs.alpha_data_size);
      }
#line 347
      if ((unsigned int )status != 0U) {
#line 348
        goto ReturnWidthHeight;
      }
    } else {
#line 343
      goto _L___18;
    }
  } else
  _L___18: 
#line 343
  if (! found_riff) {
#line 343
    if (! found_vp8x) {
#line 343
      if (! __cil_tmp23) {
#line 343
        goto _L;
      }
    }
  }
  {
#line 353
  status = ParseVP8Header(& data, & data_size, have_all_data, hdrs.riff_size, & hdrs.compressed_size,
                          & hdrs.is_lossless);
  }
#line 355
  if ((unsigned int )status != 0U) {
#line 356
    goto ReturnWidthHeight;
  }
#line 358
  if (hdrs.compressed_size > 4294967286UL) {
#line 359
    return ((VP8StatusCode )3);
  }
#line 362
  if ((unsigned long )format != (unsigned long )((void *)0)) {
#line 362
    if (! animation_present) {
#line 363
      if (hdrs.is_lossless) {
#line 363
        tmp___1 = 2;
      } else {
#line 363
        tmp___1 = 1;
      }
#line 363
      *format = tmp___1;
    }
  }
#line 366
  if (! hdrs.is_lossless) {
#line 367
    if (data_size < 10UL) {
#line 368
      status = (VP8StatusCode )7;
#line 369
      goto ReturnWidthHeight;
    }
    {
#line 372
    __cil_tmp27 = VP8GetInfo(data, data_size, (size_t )((uint32_t )hdrs.compressed_size),
                             & image_width, & image_height);
    }
#line 372
    if (! __cil_tmp27) {
#line 374
      return ((VP8StatusCode )3);
    }
  } else {
#line 377
    if (data_size < 5UL) {
#line 378
      status = (VP8StatusCode )7;
#line 379
      goto ReturnWidthHeight;
    }
    {
#line 382
    __cil_tmp28 = VP8LGetInfo(data, data_size, & image_width, & image_height, has_alpha);
    }
#line 382
    if (! __cil_tmp28) {
#line 383
      return ((VP8StatusCode )3);
    }
  }
#line 387
  if (found_vp8x) {
#line 388
    if (canvas_width != image_width) {
#line 389
      return ((VP8StatusCode )3);
    } else
#line 388
    if (canvas_height != image_height) {
#line 389
      return ((VP8StatusCode )3);
    }
  }
#line 392
  if ((unsigned long )headers != (unsigned long )((void *)0)) {
#line 393
    *headers = hdrs;
#line 394
    headers->offset = (size_t )(data - headers->data);
  }
  ReturnWidthHeight: 
#line 399
  if ((unsigned long )headers == (unsigned long )((void *)0)) {
#line 399
    if ((unsigned int )status == 7U) {
#line 399
      if (found_vp8x) {
        _L___19: 
#line 401
        if ((unsigned long )has_alpha != (unsigned long )((void *)0)) {
#line 404
          *has_alpha |= (unsigned long )hdrs.alpha_data != (unsigned long )((void *)0);
        }
#line 406
        if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 406
          *width = image_width;
        }
#line 407
        if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 407
          *height = image_height;
        }
#line 408
        return ((VP8StatusCode )0);
      } else {
#line 399
        goto _L___20;
      }
    } else {
#line 399
      goto _L___20;
    }
  } else
  _L___20: 
#line 399
  if ((unsigned int )status == 0U) {
#line 399
    goto _L___19;
  } else {
#line 410
    return (status);
  }
}
}
#line 414 "/root/patron-new/new_3/src/dec/webp_dec.c"
VP8StatusCode WebPParseHeaders(WebPHeaderStructure *headers ) 
{ 
  VP8StatusCode status ;
  int has_animation ;

  {
  {
#line 417
  has_animation = 0;
#line 420
  status = ParseHeadersInternal(headers->data, headers->data_size, (int *)((void *)0),
                                (int *)((void *)0), (int *)((void *)0), & has_animation,
                                (int *)((void *)0), headers);
  }
#line 423
  if ((unsigned int )status == 0U) {
    _L: 
#line 427
    if (has_animation) {
#line 428
      status = (VP8StatusCode )4;
    }
  } else
#line 423
  if ((unsigned int )status == 7U) {
#line 423
    goto _L;
  }
#line 431
  return (status);
}
}
#line 437 "/root/patron-new/new_3/src/dec/webp_dec.c"
void WebPResetDecParams(WebPDecParams *params ) 
{ 


  {
#line 438
  if ((unsigned long )params != (unsigned long )((void *)0)) {
    {
#line 439
    memset((void *)params, 0, sizeof(*params));
    }
  }
#line 442
  return;
}
}
#line 447 "/root/patron-new/new_3/src/dec/webp_dec.c"
static VP8StatusCode DecodeInto(uint8_t *data , size_t data_size , WebPDecParams *params ) 
{ 
  VP8StatusCode status ;
  VP8Io io ;
  WebPHeaderStructure headers ;
  VP8Decoder *dec ;
  VP8Decoder *__cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp13 ;
  VP8LDecoder *dec___0 ;
  VP8LDecoder *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp18 ;

  {
  {
#line 453
  headers.data = data;
#line 454
  headers.data_size = data_size;
#line 455
  headers.have_all_data = 1;
#line 456
  status = WebPParseHeaders(& headers);
  }
#line 457
  if ((unsigned int )status != 0U) {
#line 458
    return (status);
  }
  {
#line 462
  VP8InitIo(& io);
#line 463
  io.data = headers.data + headers.offset;
#line 464
  io.data_size = headers.data_size - headers.offset;
#line 465
  WebPInitCustomIo(params, & io);
  }
#line 467
  if (! headers.is_lossless) {
    {
#line 468
    __cil_tmp9 = VP8New();
#line 468
    dec = __cil_tmp9;
    }
#line 469
    if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 470
      return ((VP8StatusCode )1);
    }
    {
#line 472
    dec->alpha_data_ = headers.alpha_data;
#line 473
    dec->alpha_data_size_ = headers.alpha_data_size;
#line 476
    __cil_tmp10 = VP8GetHeaders(dec, & io);
    }
#line 476
    if (! __cil_tmp10) {
#line 477
      status = dec->status_;
    } else {
      {
#line 480
      status = WebPAllocateDecBuffer(io.width, io.height, params->options, params->output);
      }
#line 482
      if ((unsigned int )status == 0U) {
        {
#line 484
        dec->mt_method_ = VP8GetThreadMethod(params->options, & headers, io.width,
                                             io.height);
#line 486
        VP8InitDithering(params->options, dec);
#line 487
        __cil_tmp13 = VP8Decode(dec, & io);
        }
#line 487
        if (! __cil_tmp13) {
#line 488
          status = dec->status_;
        }
      }
    }
    {
#line 492
    VP8Delete(dec);
    }
  } else {
    {
#line 494
    __cil_tmp15 = VP8LNew();
#line 494
    dec___0 = __cil_tmp15;
    }
#line 495
    if ((unsigned long )dec___0 == (unsigned long )((void *)0)) {
#line 496
      return ((VP8StatusCode )1);
    }
    {
#line 498
    __cil_tmp16 = VP8LDecodeHeader(dec___0, & io);
    }
#line 498
    if (! __cil_tmp16) {
#line 499
      status = dec___0->status_;
    } else {
      {
#line 502
      status = WebPAllocateDecBuffer(io.width, io.height, params->options, params->output);
      }
#line 504
      if ((unsigned int )status == 0U) {
        {
#line 505
        __cil_tmp18 = VP8LDecodeImage(dec___0);
        }
#line 505
        if (! __cil_tmp18) {
#line 506
          status = dec___0->status_;
        }
      }
    }
    {
#line 510
    VP8LDelete(dec___0);
    }
  }
#line 513
  if ((unsigned int )status != 0U) {
    {
#line 514
    WebPFreeDecBuffer(params->output);
    }
  } else
#line 516
  if ((unsigned long )params->options != (unsigned long )((void *)0)) {
#line 516
    if ((params->options)->flip) {
      {
#line 519
      status = WebPFlipBuffer(params->output);
      }
    }
  }
#line 522
  return (status);
}
}
#line 526 "/root/patron-new/new_3/src/dec/webp_dec.c"
static uint8_t *DecodeIntoRGBABuffer(WEBP_CSP_MODE colorspace , uint8_t *data , size_t data_size ,
                                     uint8_t *rgba , int stride , size_t size ) 
{ 
  WebPDecParams params ;
  WebPDecBuffer buf ;
  VP8StatusCode __cil_tmp9 ;

  {
#line 533
  if ((unsigned long )rgba == (unsigned long )((void *)0)) {
#line 534
    return ((uint8_t *)((void *)0));
  }
  {
#line 536
  WebPInitDecBuffer(& buf);
#line 537
  WebPResetDecParams(& params);
#line 538
  params.output = & buf;
#line 539
  buf.colorspace = colorspace;
#line 540
  buf.u.RGBA.rgba = rgba;
#line 541
  buf.u.RGBA.stride = stride;
#line 542
  buf.u.RGBA.size = size;
#line 543
  buf.is_external_memory = 1;
#line 544
  __cil_tmp9 = DecodeInto(data, data_size, & params);
  }
#line 544
  if ((unsigned int )__cil_tmp9 != 0U) {
#line 545
    return ((uint8_t *)((void *)0));
  }
#line 547
  return (rgba);
}
}
#line 550 "/root/patron-new/new_3/src/dec/webp_dec.c"
uint8_t *WebPDecodeRGBInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                           int stride ) 
{ 
  uint8_t *__cil_tmp6 ;

  {
  {
#line 552
  __cil_tmp6 = DecodeIntoRGBABuffer((WEBP_CSP_MODE )0, data, data_size, output, stride,
                                    size);
  }
#line 552
  return (__cil_tmp6);
}
}
#line 555 "/root/patron-new/new_3/src/dec/webp_dec.c"
uint8_t *WebPDecodeRGBAInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) 
{ 
  uint8_t *__cil_tmp6 ;

  {
  {
#line 557
  __cil_tmp6 = DecodeIntoRGBABuffer((WEBP_CSP_MODE )1, data, data_size, output, stride,
                                    size);
  }
#line 557
  return (__cil_tmp6);
}
}
#line 560 "/root/patron-new/new_3/src/dec/webp_dec.c"
uint8_t *WebPDecodeARGBInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) 
{ 
  uint8_t *__cil_tmp6 ;

  {
  {
#line 562
  __cil_tmp6 = DecodeIntoRGBABuffer((WEBP_CSP_MODE )4, data, data_size, output, stride,
                                    size);
  }
#line 562
  return (__cil_tmp6);
}
}
#line 565 "/root/patron-new/new_3/src/dec/webp_dec.c"
uint8_t *WebPDecodeBGRInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                           int stride ) 
{ 
  uint8_t *__cil_tmp6 ;

  {
  {
#line 567
  __cil_tmp6 = DecodeIntoRGBABuffer((WEBP_CSP_MODE )2, data, data_size, output, stride,
                                    size);
  }
#line 567
  return (__cil_tmp6);
}
}
#line 570 "/root/patron-new/new_3/src/dec/webp_dec.c"
uint8_t *WebPDecodeBGRAInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) 
{ 
  uint8_t *__cil_tmp6 ;

  {
  {
#line 572
  __cil_tmp6 = DecodeIntoRGBABuffer((WEBP_CSP_MODE )3, data, data_size, output, stride,
                                    size);
  }
#line 572
  return (__cil_tmp6);
}
}
#line 575 "/root/patron-new/new_3/src/dec/webp_dec.c"
uint8_t *WebPDecodeYUVInto(uint8_t *data , size_t data_size , uint8_t *luma , size_t luma_size ,
                           int luma_stride , uint8_t *u , size_t u_size , int u_stride ,
                           uint8_t *v , size_t v_size , int v_stride ) 
{ 
  WebPDecParams params ;
  WebPDecBuffer output ;
  VP8StatusCode __cil_tmp14 ;

  {
#line 581
  if ((unsigned long )luma == (unsigned long )((void *)0)) {
#line 581
    return ((uint8_t *)((void *)0));
  }
  {
#line 582
  WebPInitDecBuffer(& output);
#line 583
  WebPResetDecParams(& params);
#line 584
  params.output = & output;
#line 585
  output.colorspace = (WEBP_CSP_MODE )11;
#line 586
  output.u.YUVA.y = luma;
#line 587
  output.u.YUVA.y_stride = luma_stride;
#line 588
  output.u.YUVA.y_size = luma_size;
#line 589
  output.u.YUVA.u = u;
#line 590
  output.u.YUVA.u_stride = u_stride;
#line 591
  output.u.YUVA.u_size = u_size;
#line 592
  output.u.YUVA.v = v;
#line 593
  output.u.YUVA.v_stride = v_stride;
#line 594
  output.u.YUVA.v_size = v_size;
#line 595
  output.is_external_memory = 1;
#line 596
  __cil_tmp14 = DecodeInto(data, data_size, & params);
  }
#line 596
  if ((unsigned int )__cil_tmp14 != 0U) {
#line 597
    return ((uint8_t *)((void *)0));
  }
#line 599
  return (luma);
}
}
#line 604 "/root/patron-new/new_3/src/dec/webp_dec.c"
static uint8_t *Decode(WEBP_CSP_MODE mode , uint8_t *data , size_t data_size , int *width ,
                       int *height , WebPDecBuffer *keep_info ) 
{ 
  WebPDecParams params ;
  WebPDecBuffer output ;
  int __cil_tmp9 ;
  VP8StatusCode __cil_tmp10 ;
  int __cil_tmp11 ;
  uint8_t *tmp___0 ;

  {
  {
#line 610
  WebPInitDecBuffer(& output);
#line 611
  WebPResetDecParams(& params);
#line 612
  params.output = & output;
#line 613
  output.colorspace = mode;
#line 616
  __cil_tmp9 = WebPGetInfo(data, data_size, & output.width, & output.height);
  }
#line 616
  if (! __cil_tmp9) {
#line 617
    return ((uint8_t *)((void *)0));
  }
#line 619
  if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 619
    *width = output.width;
  }
#line 620
  if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 620
    *height = output.height;
  }
  {
#line 623
  __cil_tmp10 = DecodeInto(data, data_size, & params);
  }
#line 623
  if ((unsigned int )__cil_tmp10 != 0U) {
#line 624
    return ((uint8_t *)((void *)0));
  }
#line 626
  if ((unsigned long )keep_info != (unsigned long )((void *)0)) {
    {
#line 627
    WebPCopyDecBuffer(& output, keep_info);
    }
  }
  {
#line 630
  __cil_tmp11 = WebPIsRGBMode(mode);
  }
#line 630
  if (__cil_tmp11) {
#line 630
    tmp___0 = output.u.RGBA.rgba;
  } else {
#line 630
    tmp___0 = output.u.YUVA.y;
  }
#line 630
  return (tmp___0);
}
}
#line 633 "/root/patron-new/new_3/src/dec/webp_dec.c"
uint8_t *WebPDecodeRGB(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  uint8_t *__cil_tmp5 ;

  {
  {
#line 635
  __cil_tmp5 = Decode((WEBP_CSP_MODE )0, data, data_size, width, height, (WebPDecBuffer *)((void *)0));
  }
#line 635
  return (__cil_tmp5);
}
}
#line 638 "/root/patron-new/new_3/src/dec/webp_dec.c"
uint8_t *WebPDecodeRGBA(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  uint8_t *__cil_tmp5 ;

  {
  {
#line 640
  __cil_tmp5 = Decode((WEBP_CSP_MODE )1, data, data_size, width, height, (WebPDecBuffer *)((void *)0));
  }
#line 640
  return (__cil_tmp5);
}
}
#line 643 "/root/patron-new/new_3/src/dec/webp_dec.c"
uint8_t *WebPDecodeARGB(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  uint8_t *__cil_tmp5 ;

  {
  {
#line 645
  __cil_tmp5 = Decode((WEBP_CSP_MODE )4, data, data_size, width, height, (WebPDecBuffer *)((void *)0));
  }
#line 645
  return (__cil_tmp5);
}
}
#line 648 "/root/patron-new/new_3/src/dec/webp_dec.c"
uint8_t *WebPDecodeBGR(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  uint8_t *__cil_tmp5 ;

  {
  {
#line 650
  __cil_tmp5 = Decode((WEBP_CSP_MODE )2, data, data_size, width, height, (WebPDecBuffer *)((void *)0));
  }
#line 650
  return (__cil_tmp5);
}
}
#line 653 "/root/patron-new/new_3/src/dec/webp_dec.c"
uint8_t *WebPDecodeBGRA(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  uint8_t *__cil_tmp5 ;

  {
  {
#line 655
  __cil_tmp5 = Decode((WEBP_CSP_MODE )3, data, data_size, width, height, (WebPDecBuffer *)((void *)0));
  }
#line 655
  return (__cil_tmp5);
}
}
#line 658 "/root/patron-new/new_3/src/dec/webp_dec.c"
uint8_t *WebPDecodeYUV(uint8_t *data , size_t data_size , int *width , int *height ,
                       uint8_t **u , uint8_t **v , int *stride , int *uv_stride ) 
{ 
  WebPDecBuffer output ;
  uint8_t *out ;
  uint8_t *__cil_tmp11 ;
  WebPYUVABuffer *buf ;

  {
  {
#line 662
  __cil_tmp11 = Decode((WEBP_CSP_MODE )11, data, data_size, width, height, & output);
#line 662
  out = __cil_tmp11;
  }
#line 665
  if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 666
    buf = & output.u.YUVA;
#line 667
    *u = buf->u;
#line 668
    *v = buf->v;
#line 669
    *stride = buf->y_stride;
#line 670
    *uv_stride = buf->u_stride;
  }
#line 673
  return (out);
}
}
#line 676 "/root/patron-new/new_3/src/dec/webp_dec.c"
static void DefaultFeatures(WebPBitstreamFeatures *features ) 
{ 


  {
  {
#line 678
  memset((void *)features, 0, sizeof(*features));
  }
#line 680
  return;
}
}
#line 681 "/root/patron-new/new_3/src/dec/webp_dec.c"
static VP8StatusCode GetFeatures(uint8_t *data , size_t data_size , WebPBitstreamFeatures *features ) 
{ 
  VP8StatusCode __cil_tmp4 ;

  {
#line 683
  if ((unsigned long )features == (unsigned long )((void *)0)) {
#line 684
    return ((VP8StatusCode )2);
  } else
#line 683
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 684
    return ((VP8StatusCode )2);
  }
  {
#line 686
  DefaultFeatures(features);
#line 689
  __cil_tmp4 = ParseHeadersInternal(data, data_size, & features->width, & features->height,
                                    & features->has_alpha, & features->has_animation,
                                    & features->format, (WebPHeaderStructure *)((void *)0));
  }
#line 689
  return (__cil_tmp4);
}
}
#line 698 "/root/patron-new/new_3/src/dec/webp_dec.c"
int WebPGetInfo(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  WebPBitstreamFeatures features ;
  VP8StatusCode __cil_tmp6 ;

  {
  {
#line 702
  __cil_tmp6 = GetFeatures(data, data_size, & features);
  }
#line 702
  if ((unsigned int )__cil_tmp6 != 0U) {
#line 703
    return (0);
  }
#line 706
  if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 707
    *width = features.width;
  }
#line 709
  if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 710
    *height = features.height;
  }
#line 713
  return (1);
}
}
#line 719 "/root/patron-new/new_3/src/dec/webp_dec.c"
int WebPInitDecoderConfigInternal(WebPDecoderConfig *config , int version ) 
{ 


  {
#line 721
  if (version >> 8 != 521 >> 8) {
#line 722
    return (0);
  }
#line 724
  if ((unsigned long )config == (unsigned long )((void *)0)) {
#line 725
    return (0);
  }
  {
#line 727
  memset((void *)config, 0, sizeof(*config));
#line 728
  DefaultFeatures(& config->input);
#line 729
  WebPInitDecBuffer(& config->output);
  }
#line 730
  return (1);
}
}
#line 733 "/root/patron-new/new_3/src/dec/webp_dec.c"
VP8StatusCode WebPGetFeaturesInternal(uint8_t *data , size_t data_size , WebPBitstreamFeatures *features ,
                                      int version ) 
{ 
  VP8StatusCode __cil_tmp5 ;

  {
#line 736
  if (version >> 8 != 521 >> 8) {
#line 737
    return ((VP8StatusCode )2);
  }
#line 739
  if ((unsigned long )features == (unsigned long )((void *)0)) {
#line 740
    return ((VP8StatusCode )2);
  }
  {
#line 742
  __cil_tmp5 = GetFeatures(data, data_size, features);
  }
#line 742
  return (__cil_tmp5);
}
}
#line 745 "/root/patron-new/new_3/src/dec/webp_dec.c"
VP8StatusCode WebPDecode(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) 
{ 
  WebPDecParams params ;
  VP8StatusCode status ;
  int __cil_tmp7 ;
  WebPDecBuffer in_mem_buffer ;

  {
#line 750
  if ((unsigned long )config == (unsigned long )((void *)0)) {
#line 751
    return ((VP8StatusCode )2);
  }
  {
#line 754
  status = GetFeatures(data, data_size, & config->input);
  }
#line 755
  if ((unsigned int )status != 0U) {
#line 756
    if ((unsigned int )status == 7U) {
#line 757
      return ((VP8StatusCode )3);
    }
#line 759
    return (status);
  }
  {
#line 762
  WebPResetDecParams(& params);
#line 763
  params.options = & config->options;
#line 764
  params.output = & config->output;
#line 765
  __cil_tmp7 = WebPAvoidSlowMemory(params.output, & config->input);
  }
#line 765
  if (__cil_tmp7) {
    {
#line 768
    WebPInitDecBuffer(& in_mem_buffer);
#line 769
    in_mem_buffer.colorspace = config->output.colorspace;
#line 770
    in_mem_buffer.width = config->input.width;
#line 771
    in_mem_buffer.height = config->input.height;
#line 772
    params.output = & in_mem_buffer;
#line 773
    status = DecodeInto(data, data_size, & params);
    }
#line 774
    if ((unsigned int )status == 0U) {
      {
#line 775
      status = WebPCopyDecBufferPixels(& in_mem_buffer, & config->output);
      }
    }
    {
#line 777
    WebPFreeDecBuffer(& in_mem_buffer);
    }
  } else {
    {
#line 779
    status = DecodeInto(data, data_size, & params);
    }
  }
#line 782
  return (status);
}
}
#line 788 "/root/patron-new/new_3/src/dec/webp_dec.c"
int WebPCheckCropDimensions(int image_width , int image_height , int x , int y , int w ,
                            int h ) 
{ 
  int tmp___0 ;

  {
#line 790
  if (x < 0) {
#line 790
    tmp___0 = 0;
  } else
#line 790
  if (y < 0) {
#line 790
    tmp___0 = 0;
  } else
#line 790
  if (w <= 0) {
#line 790
    tmp___0 = 0;
  } else
#line 790
  if (h <= 0) {
#line 790
    tmp___0 = 0;
  } else
#line 790
  if (x >= image_width) {
#line 790
    tmp___0 = 0;
  } else
#line 790
  if (w > image_width) {
#line 790
    tmp___0 = 0;
  } else
#line 790
  if (w > image_width - x) {
#line 790
    tmp___0 = 0;
  } else
#line 790
  if (y >= image_height) {
#line 790
    tmp___0 = 0;
  } else
#line 790
  if (h > image_height) {
#line 790
    tmp___0 = 0;
  } else
#line 790
  if (h > image_height - y) {
#line 790
    tmp___0 = 0;
  } else {
#line 790
    tmp___0 = 1;
  }
#line 790
  return (tmp___0);
}
}
#line 795 "/root/patron-new/new_3/src/dec/webp_dec.c"
int WebPIoInitFromOptions(WebPDecoderOptions *options , VP8Io *io , WEBP_CSP_MODE src_colorspace ) 
{ 
  int W ;
  int H ;
  int x ;
  int y ;
  int w ;
  int h ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int scaled_width ;
  int scaled_height ;
  int __cil_tmp14 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 797
  W = io->width;
#line 798
  H = io->height;
#line 799
  x = 0;
#line 799
  y = 0;
#line 799
  w = W;
#line 799
  h = H;
#line 802
  if ((unsigned long )options != (unsigned long )((void *)0)) {
#line 802
    if (options->use_cropping) {
#line 802
      tmp___0 = 1;
    } else {
#line 802
      tmp___0 = 0;
    }
  } else {
#line 802
    tmp___0 = 0;
  }
#line 802
  io->use_cropping = tmp___0;
#line 803
  if (io->use_cropping) {
    {
#line 804
    w = options->crop_width;
#line 805
    h = options->crop_height;
#line 806
    x = options->crop_left;
#line 807
    y = options->crop_top;
#line 808
    __cil_tmp10 = WebPIsRGBMode(src_colorspace);
    }
#line 808
    if (! __cil_tmp10) {
#line 809
      x &= -2;
#line 810
      y &= -2;
    }
    {
#line 812
    __cil_tmp11 = WebPCheckCropDimensions(W, H, x, y, w, h);
    }
#line 812
    if (! __cil_tmp11) {
#line 813
      return (0);
    }
  }
#line 816
  io->crop_left = x;
#line 817
  io->crop_top = y;
#line 818
  io->crop_right = x + w;
#line 819
  io->crop_bottom = y + h;
#line 820
  io->mb_w = w;
#line 821
  io->mb_h = h;
#line 824
  if ((unsigned long )options != (unsigned long )((void *)0)) {
#line 824
    if (options->use_scaling) {
#line 824
      tmp___1 = 1;
    } else {
#line 824
      tmp___1 = 0;
    }
  } else {
#line 824
    tmp___1 = 0;
  }
#line 824
  io->use_scaling = tmp___1;
#line 825
  if (io->use_scaling) {
    {
#line 826
    scaled_width = options->scaled_width;
#line 827
    scaled_height = options->scaled_height;
#line 828
    __cil_tmp14 = WebPRescalerGetScaledDimensions(w, h, & scaled_width, & scaled_height);
    }
#line 828
    if (! __cil_tmp14) {
#line 829
      return (0);
    }
#line 831
    io->scaled_width = scaled_width;
#line 832
    io->scaled_height = scaled_height;
  }
#line 836
  if ((unsigned long )options != (unsigned long )((void *)0)) {
#line 836
    if (options->bypass_filtering) {
#line 836
      tmp___2 = 1;
    } else {
#line 836
      tmp___2 = 0;
    }
  } else {
#line 836
    tmp___2 = 0;
  }
#line 836
  io->bypass_filtering = tmp___2;
#line 840
  if ((unsigned long )options == (unsigned long )((void *)0)) {
#line 840
    tmp___3 = 1;
  } else
#line 840
  if (! options->no_fancy_upsampling) {
#line 840
    tmp___3 = 1;
  } else {
#line 840
    tmp___3 = 0;
  }
#line 840
  io->fancy_upsampling = tmp___3;
#line 843
  if (io->use_scaling) {
#line 845
    if (io->scaled_width < (W * 3) / 4) {
#line 845
      if (io->scaled_height < (H * 3) / 4) {
#line 845
        tmp___4 = 1;
      } else {
#line 845
        tmp___4 = 0;
      }
    } else {
#line 845
      tmp___4 = 0;
    }
#line 845
    io->bypass_filtering |= tmp___4;
#line 847
    io->fancy_upsampling = 0;
  }
#line 849
  return (1);
}
}
#line 46 "../../src/dec/alphai_dec.h"
void WebPDeallocateAlphaMemory(VP8Decoder *dec ) ;
#line 34 "../../src/utils/color_cache_utils.h"
static uint32_t kHashMul___7  =    506832829U;
#line 37 "../../src/utils/color_cache_utils.h"
__inline static int VP8LHashPix___7(uint32_t argb , int shift ) 
{ 


  {
#line 38
  return ((int )(argb * kHashMul___7 >> shift));
}
}
#line 53 "../../src/utils/color_cache_utils.h"
__inline static void VP8LColorCacheInsert___7(VP8LColorCache *cc , uint32_t argb ) 
{ 
  int key ;
  int __cil_tmp4 ;

  {
  {
#line 55
  __cil_tmp4 = VP8LHashPix___7(argb, cc->hash_shift_);
#line 55
  key = __cil_tmp4;
#line 56
  *(cc->colors_ + key) = argb;
  }
#line 58
  return;
}
}
#line 29 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int const   kCodeLengthLiterals  =    (int const   )16;
#line 30 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int const   kCodeLengthRepeatCode  =    (int const   )16;
#line 31 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static uint8_t kCodeLengthExtraBits[3]  = {      (uint8_t )2,      (uint8_t )3,      (uint8_t )7};
#line 32 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static uint8_t kCodeLengthRepeatOffsets[3]  = {      (uint8_t )3,      (uint8_t )3,      (uint8_t )11};
#line 49 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static uint16_t kAlphabetSize[5]  = {      (uint16_t )280,      (uint16_t )256,      (uint16_t )256,      (uint16_t )256, 
        (uint16_t )40};
#line 55 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static uint8_t kLiteralMap[5]  = {      (uint8_t )0,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )0};
#line 60 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static uint8_t kCodeLengthCodeOrder[19]  = 
#line 60
  {      (uint8_t )17,      (uint8_t )18,      (uint8_t )0,      (uint8_t )1, 
        (uint8_t )2,      (uint8_t )3,      (uint8_t )4,      (uint8_t )5, 
        (uint8_t )16,      (uint8_t )6,      (uint8_t )7,      (uint8_t )8, 
        (uint8_t )9,      (uint8_t )10,      (uint8_t )11,      (uint8_t )12, 
        (uint8_t )13,      (uint8_t )14,      (uint8_t )15};
#line 65 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static uint8_t kCodeToPlane[120]  = 
#line 65
  {      (uint8_t )24,      (uint8_t )7,      (uint8_t )23,      (uint8_t )25, 
        (uint8_t )40,      (uint8_t )6,      (uint8_t )39,      (uint8_t )41, 
        (uint8_t )22,      (uint8_t )26,      (uint8_t )38,      (uint8_t )42, 
        (uint8_t )56,      (uint8_t )5,      (uint8_t )55,      (uint8_t )57, 
        (uint8_t )21,      (uint8_t )27,      (uint8_t )54,      (uint8_t )58, 
        (uint8_t )37,      (uint8_t )43,      (uint8_t )72,      (uint8_t )4, 
        (uint8_t )71,      (uint8_t )73,      (uint8_t )20,      (uint8_t )28, 
        (uint8_t )53,      (uint8_t )59,      (uint8_t )70,      (uint8_t )74, 
        (uint8_t )36,      (uint8_t )44,      (uint8_t )88,      (uint8_t )69, 
        (uint8_t )75,      (uint8_t )52,      (uint8_t )60,      (uint8_t )3, 
        (uint8_t )87,      (uint8_t )89,      (uint8_t )19,      (uint8_t )29, 
        (uint8_t )86,      (uint8_t )90,      (uint8_t )35,      (uint8_t )45, 
        (uint8_t )68,      (uint8_t )76,      (uint8_t )85,      (uint8_t )91, 
        (uint8_t )51,      (uint8_t )61,      (uint8_t )104,      (uint8_t )2, 
        (uint8_t )103,      (uint8_t )105,      (uint8_t )18,      (uint8_t )30, 
        (uint8_t )102,      (uint8_t )106,      (uint8_t )34,      (uint8_t )46, 
        (uint8_t )84,      (uint8_t )92,      (uint8_t )67,      (uint8_t )77, 
        (uint8_t )101,      (uint8_t )107,      (uint8_t )50,      (uint8_t )62, 
        (uint8_t )120,      (uint8_t )1,      (uint8_t )119,      (uint8_t )121, 
        (uint8_t )83,      (uint8_t )93,      (uint8_t )17,      (uint8_t )31, 
        (uint8_t )100,      (uint8_t )108,      (uint8_t )66,      (uint8_t )78, 
        (uint8_t )118,      (uint8_t )122,      (uint8_t )33,      (uint8_t )47, 
        (uint8_t )117,      (uint8_t )123,      (uint8_t )49,      (uint8_t )63, 
        (uint8_t )99,      (uint8_t )109,      (uint8_t )82,      (uint8_t )94, 
        (uint8_t )0,      (uint8_t )116,      (uint8_t )124,      (uint8_t )65, 
        (uint8_t )79,      (uint8_t )16,      (uint8_t )32,      (uint8_t )98, 
        (uint8_t )110,      (uint8_t )48,      (uint8_t )115,      (uint8_t )125, 
        (uint8_t )81,      (uint8_t )95,      (uint8_t )64,      (uint8_t )114, 
        (uint8_t )126,      (uint8_t )97,      (uint8_t )111,      (uint8_t )80, 
        (uint8_t )113,      (uint8_t )127,      (uint8_t )96,      (uint8_t )112};
#line 89 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static uint16_t kTableSize[12]  = 
#line 89
  {      (uint16_t )2954,      (uint16_t )2956,      (uint16_t )2958,      (uint16_t )2962, 
        (uint16_t )2970,      (uint16_t )2986,      (uint16_t )3018,      (uint16_t )3082, 
        (uint16_t )3212,      (uint16_t )3468,      (uint16_t )3980,      (uint16_t )5004};
#line 104
static int DecodeImageStream(int xsize , int ysize , int is_level0 , VP8LDecoder *dec ,
                             uint32_t **decoded_data ) ;
#line 111 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
int VP8LCheckSignature(uint8_t *data , size_t size ) 
{ 
  int tmp___0 ;

  {
#line 112
  if (size >= 5UL) {
#line 112
    if ((int )*(data + 0) == 47) {
#line 112
      if ((int )*(data + 4) >> 5 == 0) {
#line 112
        tmp___0 = 1;
      } else {
#line 112
        tmp___0 = 0;
      }
    } else {
#line 112
      tmp___0 = 0;
    }
  } else {
#line 112
    tmp___0 = 0;
  }
#line 112
  return (tmp___0);
}
}
#line 117 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int ReadImageInfo(VP8LBitReader *br , int *width , int *height , int *has_alpha ) 
{ 
  uint32_t __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;

  {
  {
#line 120
  __cil_tmp5 = VP8LReadBits(br, 8);
  }
#line 120
  if (__cil_tmp5 != 47U) {
#line 120
    return (0);
  }
  {
#line 121
  __cil_tmp6 = VP8LReadBits(br, 14);
#line 121
  *width = (int )(__cil_tmp6 + 1U);
#line 122
  __cil_tmp7 = VP8LReadBits(br, 14);
#line 122
  *height = (int )(__cil_tmp7 + 1U);
#line 123
  __cil_tmp8 = VP8LReadBits(br, 1);
#line 123
  *has_alpha = (int )__cil_tmp8;
#line 124
  __cil_tmp9 = VP8LReadBits(br, 3);
  }
#line 124
  if (__cil_tmp9 != 0U) {
#line 124
    return (0);
  }
#line 125
  return (! br->eos_);
}
}
#line 128 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
int VP8LGetInfo(uint8_t *data , size_t data_size , int *width , int *height , int *has_alpha ) 
{ 
  int __cil_tmp6 ;
  int w ;
  int h ;
  int a ;
  VP8LBitReader br ;
  int __cil_tmp11 ;

  {
#line 130
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 131
    return (0);
  } else
#line 130
  if (data_size < 5UL) {
#line 131
    return (0);
  } else {
    {
#line 132
    __cil_tmp6 = VP8LCheckSignature(data, data_size);
    }
#line 132
    if (! __cil_tmp6) {
#line 133
      return (0);
    } else {
      {
#line 137
      VP8LInitBitReader(& br, data, data_size);
#line 138
      __cil_tmp11 = ReadImageInfo(& br, & w, & h, & a);
      }
#line 138
      if (! __cil_tmp11) {
#line 139
        return (0);
      }
#line 141
      if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 141
        *width = w;
      }
#line 142
      if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 142
        *height = h;
      }
#line 143
      if ((unsigned long )has_alpha != (unsigned long )((void *)0)) {
#line 143
        *has_alpha = a;
      }
#line 144
      return (1);
    }
  }
}
}
#line 150 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
__inline static int GetCopyDistance(int distance_symbol , VP8LBitReader *br ) 
{ 
  int extra_bits ;
  int offset ;
  uint32_t __cil_tmp5 ;

  {
#line 153
  if (distance_symbol < 4) {
#line 154
    return (distance_symbol + 1);
  }
  {
#line 156
  extra_bits = (distance_symbol - 2) >> 1;
#line 157
  offset = (2 + (distance_symbol & 1)) << extra_bits;
#line 158
  __cil_tmp5 = VP8LReadBits(br, extra_bits);
  }
#line 158
  return ((int )(((unsigned int )offset + __cil_tmp5) + 1U));
}
}
#line 161 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
__inline static int GetCopyLength(int length_symbol , VP8LBitReader *br ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 164
  __cil_tmp3 = GetCopyDistance(length_symbol, br);
  }
#line 164
  return (__cil_tmp3);
}
}
#line 167 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
__inline static int PlaneCodeToDistance(int xsize , int plane_code ) 
{ 
  int dist_code ;
  int yoffset ;
  int xoffset ;
  int dist ;
  int tmp___0 ;

  {
#line 168
  if (plane_code > 120) {
#line 169
    return (plane_code - 120);
  } else {
#line 171
    dist_code = (int )kCodeToPlane[plane_code - 1];
#line 172
    yoffset = dist_code >> 4;
#line 173
    xoffset = 8 - (dist_code & 15);
#line 174
    dist = yoffset * xsize + xoffset;
#line 175
    if (dist >= 1) {
#line 175
      tmp___0 = dist;
    } else {
#line 175
      tmp___0 = 1;
    }
#line 175
    return (tmp___0);
  }
}
}
#line 183 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
__inline static int ReadSymbol(HuffmanCode *table , VP8LBitReader *br ) 
{ 
  int nbits ;
  uint32_t val ;
  uint32_t __cil_tmp5 ;

  {
  {
#line 186
  __cil_tmp5 = VP8LPrefetchBits(br);
#line 186
  val = __cil_tmp5;
#line 187
  table += val & (unsigned int )((1 << 8) - 1);
#line 188
  nbits = (int )table->bits - 8;
  }
#line 189
  if (nbits > 0) {
    {
#line 190
    VP8LSetBitPos(br, br->bit_pos_ + 8);
#line 191
    val = VP8LPrefetchBits(br);
#line 192
    table += (int )table->value;
#line 193
    table += val & (unsigned int )((1 << nbits) - 1);
    }
  }
  {
#line 195
  VP8LSetBitPos(br, br->bit_pos_ + (int )table->bits);
  }
#line 196
  return ((int )table->value);
}
}
#line 202 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
__inline static int ReadPackedSymbols(HTreeGroup *group , VP8LBitReader *br , uint32_t *dst ) 
{ 
  uint32_t val ;
  uint32_t __cil_tmp5 ;
  HuffmanCode32 code ;

  {
  {
#line 205
  __cil_tmp5 = VP8LPrefetchBits(br);
#line 205
  val = __cil_tmp5 & ((1U << 6) - 1U);
#line 206
  code = group->packed_table[val];
  }
#line 208
  if (code.bits < 256) {
    {
#line 209
    VP8LSetBitPos(br, br->bit_pos_ + code.bits);
#line 210
    *dst = code.value;
    }
#line 211
    return (0);
  } else {
    {
#line 213
    VP8LSetBitPos(br, (br->bit_pos_ + code.bits) - 256);
    }
#line 215
    return ((int )code.value);
  }
}
}
#line 219 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int AccumulateHCode(HuffmanCode hcode , int shift , HuffmanCode32 *huff ) 
{ 


  {
#line 221
  huff->bits += (int )hcode.bits;
#line 222
  huff->value |= (uint32_t )hcode.value << shift;
#line 224
  return ((int )hcode.bits);
}
}
#line 227 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static void BuildPackedTable(HTreeGroup *htree_group ) 
{ 
  uint32_t code ;
  uint32_t bits ;
  HuffmanCode32 *huff ;
  HuffmanCode hcode ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 229
  code = (uint32_t )0;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;

#line 229
    if (! (code < 1U << 6)) {
#line 229
      goto while_break;
    }
#line 230
    bits = code;
#line 231
    huff = & htree_group->packed_table[bits];
#line 232
    hcode = *(htree_group->htrees[0] + bits);
#line 233
    if ((int )hcode.value >= 256) {
#line 234
      huff->bits = (int )hcode.bits + 256;
#line 235
      huff->value = (uint32_t )hcode.value;
    } else {
      {
#line 237
      huff->bits = 0;
#line 238
      huff->value = (uint32_t )0;
#line 239
      __cil_tmp6 = AccumulateHCode(hcode, 8, huff);
#line 239
      bits >>= __cil_tmp6;
#line 240
      __cil_tmp7 = AccumulateHCode(*(htree_group->htrees[1] + bits), 16, huff);
#line 240
      bits >>= __cil_tmp7;
#line 241
      __cil_tmp8 = AccumulateHCode(*(htree_group->htrees[2] + bits), 0, huff);
#line 241
      bits >>= __cil_tmp8;
#line 242
      __cil_tmp9 = AccumulateHCode(*(htree_group->htrees[3] + bits), 24, huff);
#line 242
      bits >>= __cil_tmp9;
      }
    }
#line 229
    code ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 233
  return;
}
}
#line 248 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int ReadHuffmanCodeLengths(VP8LDecoder *dec , int const   *code_length_code_lengths ,
                                  int num_symbols , int *code_lengths ) 
{ 
  int ok ;
  VP8LBitReader *br ;
  int symbol ;
  int max_symbol ;
  int prev_code_len ;
  HuffmanCode table[128] ;
  int __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  int length_nbits ;
  uint32_t __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  HuffmanCode *p ;
  int code_len ;
  int __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  int __cil_tmp20 ;
  int use_prev ;
  int slot ;
  int extra_bits ;
  int repeat_offset ;
  int repeat ;
  uint32_t __cil_tmp26 ;
  int length ;
  int tmp___0 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;

  {
  {
#line 251
  ok = 0;
#line 252
  br = & dec->br_;
#line 255
  prev_code_len = 8;
#line 258
  __cil_tmp11 = VP8LBuildHuffmanTable(table, 7, code_length_code_lengths, 19);
  }
#line 258
  if (! __cil_tmp11) {
#line 261
    goto End;
  }
  {
#line 264
  __cil_tmp12 = VP8LReadBits(br, 1);
  }
#line 264
  if (__cil_tmp12) {
    {
#line 265
    __cil_tmp14 = VP8LReadBits(br, 3);
#line 265
    length_nbits = (int )(2U + 2U * __cil_tmp14);
#line 266
    __cil_tmp15 = VP8LReadBits(br, length_nbits);
#line 266
    max_symbol = (int )(2U + __cil_tmp15);
    }
#line 267
    if (max_symbol > num_symbols) {
#line 268
      goto End;
    }
  } else {
#line 271
    max_symbol = num_symbols;
  }
#line 274
  symbol = 0;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;

#line 275
    if (! (symbol < num_symbols)) {
#line 275
      goto while_break;
    }
#line 278
    __cil_tmp18 = max_symbol;
#line 278
    max_symbol --;
#line 278
    if (__cil_tmp18 == 0) {
#line 278
      goto while_break;
    }
    {
#line 279
    VP8LFillBitWindow(br);
#line 280
    __cil_tmp19 = VP8LPrefetchBits(br);
#line 280
    p = & table[__cil_tmp19 & (unsigned int )((1 << 7) - 1)];
#line 281
    VP8LSetBitPos(br, br->bit_pos_ + (int )p->bits);
#line 282
    code_len = (int )p->value;
    }
#line 283
    if (code_len < (int )kCodeLengthLiterals) {
#line 284
      __cil_tmp20 = symbol;
#line 284
      symbol ++;
#line 284
      *(code_lengths + __cil_tmp20) = code_len;
#line 285
      if (code_len != 0) {
#line 285
        prev_code_len = code_len;
      }
    } else {
      {
#line 287
      use_prev = code_len == (int )kCodeLengthRepeatCode;
#line 288
      slot = code_len - (int )kCodeLengthLiterals;
#line 289
      extra_bits = (int )kCodeLengthExtraBits[slot];
#line 290
      repeat_offset = (int )kCodeLengthRepeatOffsets[slot];
#line 291
      __cil_tmp26 = VP8LReadBits(br, extra_bits);
#line 291
      repeat = (int )(__cil_tmp26 + (unsigned int )repeat_offset);
      }
#line 292
      if (symbol + repeat > num_symbols) {
#line 293
        goto End;
      } else {
#line 295
        if (use_prev) {
#line 295
          tmp___0 = prev_code_len;
        } else {
#line 295
          tmp___0 = 0;
        }
#line 295
        length = tmp___0;
        {
#line 296
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 296
          __cil_tmp29 = repeat;
#line 296
          repeat --;
#line 296
          if (! (__cil_tmp29 > 0)) {
#line 296
            goto while_break___0;
          }
#line 296
          __cil_tmp30 = symbol;
#line 296
          symbol ++;
#line 296
          *(code_lengths + __cil_tmp30) = length;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: ;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 300
  ok = 1;
  End: 
#line 303
  if (! ok) {
#line 303
    dec->status_ = (VP8StatusCode )3;
  }
#line 304
  return (ok);
}
}
#line 309 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int ReadHuffmanCode(int alphabet_size , VP8LDecoder *dec , int *code_lengths ,
                           HuffmanCode *table ) 
{ 
  int ok ;
  int size ;
  VP8LBitReader *br ;
  int simple_code ;
  uint32_t __cil_tmp9 ;
  int num_symbols ;
  uint32_t __cil_tmp11 ;
  int first_symbol_len_code ;
  uint32_t __cil_tmp13 ;
  int symbol ;
  int tmp___0 ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  int i ;
  int code_length_code_lengths[19] ;
  unsigned int tmp___1 ;
  int num_codes ;
  uint32_t __cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  int tmp___2 ;

  {
  {
#line 311
  ok = 0;
#line 312
  size = 0;
#line 313
  br = & dec->br_;
#line 314
  __cil_tmp9 = VP8LReadBits(br, 1);
#line 314
  simple_code = (int )__cil_tmp9;
#line 316
  memset((void *)code_lengths, 0, (unsigned long )alphabet_size * sizeof(*code_lengths));
  }
#line 318
  if (simple_code) {
    {
#line 319
    __cil_tmp11 = VP8LReadBits(br, 1);
#line 319
    num_symbols = (int )(__cil_tmp11 + 1U);
#line 320
    __cil_tmp13 = VP8LReadBits(br, 1);
#line 320
    first_symbol_len_code = (int )__cil_tmp13;
    }
#line 322
    if (first_symbol_len_code == 0) {
#line 322
      tmp___0 = 1;
    } else {
#line 322
      tmp___0 = 8;
    }
    {
#line 322
    __cil_tmp16 = VP8LReadBits(br, tmp___0);
#line 322
    symbol = (int )__cil_tmp16;
#line 323
    *(code_lengths + symbol) = 1;
    }
#line 325
    if (num_symbols == 2) {
      {
#line 326
      __cil_tmp17 = VP8LReadBits(br, 8);
#line 326
      symbol = (int )__cil_tmp17;
#line 327
      *(code_lengths + symbol) = 1;
      }
    }
#line 329
    ok = 1;
  } else {
#line 332
    code_length_code_lengths[0] = 0;
#line 332
    tmp___1 = 1U;
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;

#line 332
      if (tmp___1 >= 19U) {
#line 332
        goto while_break;
      }
#line 332
      code_length_code_lengths[tmp___1] = 0;
#line 332
      tmp___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 333
    __cil_tmp22 = VP8LReadBits(br, 4);
#line 333
    num_codes = (int )(__cil_tmp22 + 4U);
    }
#line 334
    if (num_codes > 19) {
#line 335
      dec->status_ = (VP8StatusCode )3;
#line 336
      return (0);
    }
#line 339
    i = 0;
    {
#line 339
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 339
      if (! (i < num_codes)) {
#line 339
        goto while_break___0;
      }
      {
#line 340
      __cil_tmp23 = VP8LReadBits(br, 3);
#line 340
      code_length_code_lengths[kCodeLengthCodeOrder[i]] = (int )__cil_tmp23;
#line 339
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 342
    ok = ReadHuffmanCodeLengths(dec, (int const   *)(code_length_code_lengths), alphabet_size,
                                code_lengths);
    }
  }
#line 346
  if (ok) {
#line 346
    if (! br->eos_) {
#line 346
      tmp___2 = 1;
    } else {
#line 346
      tmp___2 = 0;
    }
  } else {
#line 346
    tmp___2 = 0;
  }
#line 346
  ok = tmp___2;
#line 347
  if (ok) {
    {
#line 348
    size = VP8LBuildHuffmanTable(table, 8, (int const   *)code_lengths, alphabet_size);
    }
  }
#line 351
  if (! ok) {
#line 352
    dec->status_ = (VP8StatusCode )3;
#line 353
    return (0);
  } else
#line 351
  if (size == 0) {
#line 352
    dec->status_ = (VP8StatusCode )3;
#line 353
    return (0);
  }
#line 355
  return (size);
}
}
#line 358 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int ReadHuffmanCodes(VP8LDecoder *dec , int xsize , int ysize , int color_cache_bits ,
                            int allow_recursion ) 
{ 
  int i ;
  int j ;
  VP8LBitReader *br ;
  VP8LMetadata *hdr ;
  uint32_t *huffman_image ;
  HTreeGroup *htree_groups ;
  HuffmanCode *huffman_tables ;
  HuffmanCode *huffman_table ;
  int num_htree_groups ;
  int num_htree_groups_max ;
  int max_alphabet_size ;
  int *code_lengths ;
  int table_size ;
  int *mapping ;
  int ok ;
  uint32_t __cil_tmp21 ;
  int huffman_precision ;
  uint32_t __cil_tmp23 ;
  int huffman_xsize ;
  uint32_t __cil_tmp25 ;
  int huffman_ysize ;
  uint32_t __cil_tmp27 ;
  int huffman_pixs ;
  int __cil_tmp29 ;
  int group ;
  void *__cil_tmp31 ;
  int *mapped_group ;
  int __cil_tmp33 ;
  int alphabet_size ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  int alphabet_size___0 ;
  int __cil_tmp39 ;
  HTreeGroup *htree_group ;
  int tmp___0 ;
  HuffmanCode **htrees ;
  int size ;
  int total_size ;
  int is_trivial_literal ;
  int max_bits ;
  int alphabet_size___1 ;
  int local_max_bits ;
  int k ;
  int red ;
  int blue ;
  int alpha ;
  int tmp___1 ;

  {
  {
#line 361
  br = & dec->br_;
#line 362
  hdr = & dec->hdr_;
#line 363
  huffman_image = (uint32_t *)((void *)0);
#line 364
  htree_groups = (HTreeGroup *)((void *)0);
#line 365
  huffman_tables = (HuffmanCode *)((void *)0);
#line 366
  huffman_table = (HuffmanCode *)((void *)0);
#line 367
  num_htree_groups = 1;
#line 368
  num_htree_groups_max = 1;
#line 369
  max_alphabet_size = 0;
#line 370
  code_lengths = (int *)((void *)0);
#line 371
  table_size = (int )kTableSize[color_cache_bits];
#line 372
  mapping = (int *)((void *)0);
#line 373
  ok = 0;
#line 375
  __cil_tmp21 = VP8LReadBits(br, 1);
  }
#line 375
  if (allow_recursion) {
#line 375
    if (__cil_tmp21) {
      {
#line 377
      __cil_tmp23 = VP8LReadBits(br, 3);
#line 377
      huffman_precision = (int )(__cil_tmp23 + 2U);
#line 378
      __cil_tmp25 = VP8LSubSampleSize((uint32_t )xsize, (uint32_t )huffman_precision);
#line 378
      huffman_xsize = (int )__cil_tmp25;
#line 379
      __cil_tmp27 = VP8LSubSampleSize((uint32_t )ysize, (uint32_t )huffman_precision);
#line 379
      huffman_ysize = (int )__cil_tmp27;
#line 380
      huffman_pixs = huffman_xsize * huffman_ysize;
#line 381
      __cil_tmp29 = DecodeImageStream(huffman_xsize, huffman_ysize, 0, dec, & huffman_image);
      }
#line 381
      if (! __cil_tmp29) {
#line 383
        goto Error;
      }
#line 385
      hdr->huffman_subsample_bits_ = huffman_precision;
#line 386
      i = 0;
      {
#line 386
      while (1) {
        while_continue: /* CIL Label */ ;

#line 386
        if (! (i < huffman_pixs)) {
#line 386
          goto while_break;
        }
#line 388
        group = (int )((*(huffman_image + i) >> 8) & 65535U);
#line 389
        *(huffman_image + i) = (uint32_t )group;
#line 390
        if (group >= num_htree_groups_max) {
#line 391
          num_htree_groups_max = group + 1;
        }
#line 386
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break: ;
#line 400
      if (num_htree_groups_max > 1000) {
        _L: 
        {
#line 403
        __cil_tmp31 = WebPSafeMalloc((uint64_t )num_htree_groups_max, sizeof(*mapping));
#line 403
        mapping = (int *)__cil_tmp31;
        }
#line 404
        if ((unsigned long )mapping == (unsigned long )((void *)0)) {
#line 405
          dec->status_ = (VP8StatusCode )1;
#line 406
          goto Error;
        }
        {
#line 410
        memset((void *)mapping, 255, (unsigned long )num_htree_groups_max * sizeof(*mapping));
#line 411
        i = 0;
#line 411
        num_htree_groups = 0;
        }
        {
#line 411
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 411
          if (! (i < huffman_pixs)) {
#line 411
            goto while_break___0;
          }
#line 413
          mapped_group = mapping + *(huffman_image + i);
#line 414
          if (*mapped_group == -1) {
#line 414
            __cil_tmp33 = num_htree_groups;
#line 414
            num_htree_groups ++;
#line 414
            *mapped_group = __cil_tmp33;
          }
#line 415
          *(huffman_image + i) = (uint32_t )*mapped_group;
#line 411
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___0: ;
      } else
#line 400
      if (num_htree_groups_max > xsize * ysize) {
#line 400
        goto _L;
      } else {
#line 418
        num_htree_groups = num_htree_groups_max;
      }
    }
  }
#line 422
  if (br->eos_) {
#line 422
    goto Error;
  }
#line 425
  j = 0;
  {
#line 425
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 425
    if (! (j < 5)) {
#line 425
      goto while_break___1;
    }
#line 426
    alphabet_size = (int )kAlphabetSize[j];
#line 427
    if (j == 0) {
#line 427
      if (color_cache_bits > 0) {
#line 428
        alphabet_size += 1 << color_cache_bits;
      }
    }
#line 430
    if (max_alphabet_size < alphabet_size) {
#line 431
      max_alphabet_size = alphabet_size;
    }
#line 425
    j ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 435
  __cil_tmp35 = WebPSafeCalloc((uint64_t )max_alphabet_size, sizeof(*code_lengths));
#line 435
  code_lengths = (int *)__cil_tmp35;
#line 437
  __cil_tmp36 = WebPSafeMalloc((uint64_t )(num_htree_groups * table_size), sizeof(*huffman_tables));
#line 437
  huffman_tables = (HuffmanCode *)__cil_tmp36;
#line 439
  htree_groups = VP8LHtreeGroupsNew(num_htree_groups);
  }
#line 441
  if ((unsigned long )htree_groups == (unsigned long )((void *)0)) {
#line 442
    dec->status_ = (VP8StatusCode )1;
#line 443
    goto Error;
  } else
#line 441
  if ((unsigned long )code_lengths == (unsigned long )((void *)0)) {
#line 442
    dec->status_ = (VP8StatusCode )1;
#line 443
    goto Error;
  } else
#line 441
  if ((unsigned long )huffman_tables == (unsigned long )((void *)0)) {
#line 442
    dec->status_ = (VP8StatusCode )1;
#line 443
    goto Error;
  }
#line 446
  huffman_table = huffman_tables;
#line 447
  i = 0;
  {
#line 447
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 447
    if (! (i < num_htree_groups_max)) {
#line 447
      goto while_break___2;
    }
#line 450
    if ((unsigned long )mapping != (unsigned long )((void *)0)) {
#line 450
      if (*(mapping + i) == -1) {
#line 451
        j = 0;
        {
#line 451
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 451
          if (! (j < 5)) {
#line 451
            goto while_break___3;
          }
#line 452
          alphabet_size___0 = (int )kAlphabetSize[j];
#line 453
          if (j == 0) {
#line 453
            if (color_cache_bits > 0) {
#line 454
              alphabet_size___0 += 1 << color_cache_bits;
            }
          }
          {
#line 457
          __cil_tmp39 = ReadHuffmanCode(alphabet_size___0, dec, code_lengths, (HuffmanCode *)((void *)0));
          }
#line 457
          if (! __cil_tmp39) {
#line 458
            goto Error;
          }
#line 451
          j ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___3: ;
      } else {
#line 450
        goto _L___21;
      }
    } else {
      _L___21: 
#line 462
      if ((unsigned long )mapping == (unsigned long )((void *)0)) {
#line 462
        tmp___0 = i;
      } else {
#line 462
        tmp___0 = *(mapping + i);
      }
#line 462
      htree_group = htree_groups + tmp___0;
#line 464
      htrees = htree_group->htrees;
#line 466
      total_size = 0;
#line 467
      is_trivial_literal = 1;
#line 468
      max_bits = 0;
#line 469
      j = 0;
      {
#line 469
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 469
        if (! (j < 5)) {
#line 469
          goto while_break___4;
        }
#line 470
        alphabet_size___1 = (int )kAlphabetSize[j];
#line 471
        *(htrees + j) = huffman_table;
#line 472
        if (j == 0) {
#line 472
          if (color_cache_bits > 0) {
#line 473
            alphabet_size___1 += 1 << color_cache_bits;
          }
        }
        {
#line 475
        size = ReadHuffmanCode(alphabet_size___1, dec, code_lengths, huffman_table);
        }
#line 476
        if (size == 0) {
#line 477
          goto Error;
        }
#line 479
        if (is_trivial_literal) {
#line 479
          if ((int )kLiteralMap[j] == 1) {
#line 480
            is_trivial_literal = (int )huffman_table->bits == 0;
          }
        }
#line 482
        total_size += (int )huffman_table->bits;
#line 483
        huffman_table += size;
#line 484
        if (j <= 3) {
#line 485
          local_max_bits = *(code_lengths + 0);
#line 487
          k = 1;
          {
#line 487
          while (1) {
            while_continue___5: /* CIL Label */ ;

#line 487
            if (! (k < alphabet_size___1)) {
#line 487
              goto while_break___5;
            }
#line 488
            if (*(code_lengths + k) > local_max_bits) {
#line 489
              local_max_bits = *(code_lengths + k);
            }
#line 487
            k ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___5: 
#line 492
          max_bits += local_max_bits;
        }
#line 469
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: 
#line 495
      htree_group->is_trivial_literal = is_trivial_literal;
#line 496
      htree_group->is_trivial_code = 0;
#line 497
      if (is_trivial_literal) {
#line 498
        red = (int )(*(htrees + 1) + 0)->value;
#line 499
        blue = (int )(*(htrees + 2) + 0)->value;
#line 500
        alpha = (int )(*(htrees + 3) + 0)->value;
#line 501
        htree_group->literal_arb = (((uint32_t )alpha << 24) | (unsigned int )(red << 16)) | (unsigned int )blue;
#line 502
        if (total_size == 0) {
#line 502
          if ((int )(*(htrees + 0) + 0)->value < 256) {
#line 503
            htree_group->is_trivial_code = 1;
#line 504
            htree_group->literal_arb |= (unsigned int )((int )(*(htrees + 0) + 0)->value << 8);
          }
        }
      }
#line 507
      if (! htree_group->is_trivial_code) {
#line 507
        if (max_bits < 6) {
#line 507
          tmp___1 = 1;
        } else {
#line 507
          tmp___1 = 0;
        }
      } else {
#line 507
        tmp___1 = 0;
      }
#line 507
      htree_group->use_packed_table = tmp___1;
#line 509
      if (htree_group->use_packed_table) {
        {
#line 509
        BuildPackedTable(htree_group);
        }
      }
    }
#line 447
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___2: 
#line 512
  ok = 1;
#line 515
  hdr->huffman_image_ = huffman_image;
#line 516
  hdr->num_htree_groups_ = num_htree_groups;
#line 517
  hdr->htree_groups_ = htree_groups;
#line 518
  hdr->huffman_tables_ = huffman_tables;
  Error: 
  {
#line 521
  WebPSafeFree((void *)code_lengths);
#line 522
  WebPSafeFree((void *)mapping);
  }
#line 523
  if (! ok) {
    {
#line 524
    WebPSafeFree((void *)huffman_image);
#line 525
    WebPSafeFree((void *)huffman_tables);
#line 526
    VP8LHtreeGroupsFree(htree_groups);
    }
  }
#line 528
  return (ok);
}
}
#line 535 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int AllocateAndInitRescaler(VP8LDecoder *dec , VP8Io *io ) 
{ 
  int num_channels ;
  int in_width ;
  int out_width ;
  int in_height ;
  int out_height ;
  uint64_t work_size ;
  rescaler_t *work ;
  uint64_t scaled_data_size ;
  uint32_t *scaled_data ;
  uint64_t memory_size ;
  uint8_t *memory ;
  void *__cil_tmp14 ;

  {
  {
#line 536
  num_channels = 4;
#line 537
  in_width = io->mb_w;
#line 538
  out_width = io->scaled_width;
#line 539
  in_height = io->mb_h;
#line 540
  out_height = io->scaled_height;
#line 541
  work_size = (unsigned long )(2 * num_channels) * (uint64_t )out_width;
#line 543
  scaled_data_size = (uint64_t )out_width;
#line 545
  memory_size = (sizeof(*(dec->rescaler)) + work_size * sizeof(*work)) + scaled_data_size * sizeof(*scaled_data);
#line 548
  __cil_tmp14 = WebPSafeMalloc(memory_size, sizeof(*memory));
#line 548
  memory = (uint8_t *)__cil_tmp14;
  }
#line 549
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 550
    dec->status_ = (VP8StatusCode )1;
#line 551
    return (0);
  }
  {
#line 554
  dec->rescaler_memory = memory;
#line 556
  dec->rescaler = (WebPRescaler *)memory;
#line 557
  memory += sizeof(*(dec->rescaler));
#line 558
  work = (rescaler_t *)memory;
#line 559
  memory += work_size * sizeof(*work);
#line 560
  scaled_data = (uint32_t *)memory;
#line 562
  WebPRescalerInit(dec->rescaler, in_width, in_height, (uint8_t *)scaled_data, out_width,
                   out_height, 0, num_channels, work);
  }
#line 564
  return (1);
}
}
#line 574 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int Export(WebPRescaler *rescaler , WEBP_CSP_MODE colorspace , int rgba_stride ,
                  uint8_t *rgba ) 
{ 
  uint32_t *src ;
  uint8_t *dst ;
  int dst_width ;
  int num_lines_out ;
  int __cil_tmp9 ;

  {
#line 576
  src = (uint32_t *)rescaler->dst;
#line 577
  dst = rgba;
#line 578
  dst_width = rescaler->dst_width;
#line 579
  num_lines_out = 0;
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 580
    __cil_tmp9 = WebPRescalerHasPendingOutput(rescaler);
    }
#line 580
    if (! __cil_tmp9) {
#line 580
      goto while_break;
    }
    {
#line 581
    WebPRescalerExportRow(rescaler);
#line 582
    (*WebPMultARGBRow)((uint32_t */* const  */)src, dst_width, 1);
#line 583
    VP8LConvertFromBGRA(src, dst_width, colorspace, dst);
#line 584
    dst += rgba_stride;
#line 585
    num_lines_out ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 587
  return (num_lines_out);
}
}
#line 591 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int EmitRescaledRowsRGBA(VP8LDecoder *dec , uint8_t *in , int in_stride , int mb_h ,
                                uint8_t *out , int out_stride ) 
{ 
  WEBP_CSP_MODE colorspace ;
  int num_lines_in ;
  int num_lines_out ;
  uint8_t *row_in ;
  uint8_t *row_out ;
  int lines_left ;
  int needed_lines ;
  int __cil_tmp14 ;
  int lines_imported ;
  int __cil_tmp17 ;

  {
#line 594
  colorspace = (dec->output_)->colorspace;
#line 595
  num_lines_in = 0;
#line 596
  num_lines_out = 0;
  {
#line 597
  while (1) {
    while_continue: /* CIL Label */ ;

#line 597
    if (! (num_lines_in < mb_h)) {
#line 597
      goto while_break;
    }
    {
#line 598
    row_in = in + (unsigned long )num_lines_in * (unsigned long )in_stride;
#line 599
    row_out = out + (unsigned long )num_lines_out * (unsigned long )out_stride;
#line 600
    lines_left = mb_h - num_lines_in;
#line 601
    __cil_tmp14 = WebPRescaleNeededLines(dec->rescaler, lines_left);
#line 601
    needed_lines = __cil_tmp14;
#line 604
    WebPMultARGBRows(row_in, in_stride, (dec->rescaler)->src_width, needed_lines,
                     0);
#line 606
    lines_imported = WebPRescalerImport(dec->rescaler, lines_left, row_in, in_stride);
#line 609
    num_lines_in += lines_imported;
#line 610
    __cil_tmp17 = Export(dec->rescaler, colorspace, out_stride, row_out);
#line 610
    num_lines_out += __cil_tmp17;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 612
  return (num_lines_out);
}
}
#line 618 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int EmitRows(WEBP_CSP_MODE colorspace , uint8_t *row_in , int in_stride , int mb_w ,
                    int mb_h , uint8_t *out , int out_stride ) 
{ 
  int lines ;
  uint8_t *row_out ;
  int __cil_tmp10 ;

  {
#line 622
  lines = mb_h;
#line 623
  row_out = out;
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 624
    __cil_tmp10 = lines;
#line 624
    lines --;
#line 624
    if (! (__cil_tmp10 > 0)) {
#line 624
      goto while_break;
    }
    {
#line 625
    VP8LConvertFromBGRA((uint32_t *)row_in, mb_w, colorspace, row_out);
#line 626
    row_in += in_stride;
#line 627
    row_out += out_stride;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 629
  return (mb_h);
}
}
#line 635 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static void ConvertToYUVA(uint32_t *src , int width , int y_pos , WebPDecBuffer *output ) 
{ 
  WebPYUVABuffer *buf ;
  uint8_t *u ;
  uint8_t *v ;
  uint8_t *a ;

  {
  {
#line 637
  buf = & output->u.YUVA;
#line 640
  (*WebPConvertARGBToY)(src, buf->y + y_pos * buf->y_stride, width);
#line 644
  u = buf->u + (y_pos >> 1) * buf->u_stride;
#line 645
  v = buf->v + (y_pos >> 1) * buf->v_stride;
#line 648
  (*WebPConvertARGBToUV)(src, u, v, width, ! (y_pos & 1));
  }
#line 651
  if ((unsigned long )buf->a != (unsigned long )((void *)0)) {
    {
#line 652
    a = buf->a + y_pos * buf->a_stride;
#line 656
    (*WebPExtractAlpha)((uint8_t *)src + 3, 0, width, 1, a, 0);
    }
  }
#line 659
  return;
}
}
#line 661 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int ExportYUVA(VP8LDecoder *dec , int y_pos ) 
{ 
  WebPRescaler *rescaler ;
  uint32_t *src ;
  int dst_width ;
  int num_lines_out ;
  int __cil_tmp7 ;

  {
#line 662
  rescaler = dec->rescaler;
#line 663
  src = (uint32_t *)rescaler->dst;
#line 664
  dst_width = rescaler->dst_width;
#line 665
  num_lines_out = 0;
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 666
    __cil_tmp7 = WebPRescalerHasPendingOutput(rescaler);
    }
#line 666
    if (! __cil_tmp7) {
#line 666
      goto while_break;
    }
    {
#line 667
    WebPRescalerExportRow(rescaler);
#line 668
    (*WebPMultARGBRow)((uint32_t */* const  */)src, dst_width, 1);
#line 669
    ConvertToYUVA(src, dst_width, y_pos, dec->output_);
#line 670
    y_pos ++;
#line 671
    num_lines_out ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 673
  return (num_lines_out);
}
}
#line 676 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int EmitRescaledRowsYUVA(VP8LDecoder *dec , uint8_t *in , int in_stride , int mb_h ) 
{ 
  int num_lines_in ;
  int y_pos ;
  int lines_left ;
  int needed_lines ;
  int __cil_tmp9 ;
  int lines_imported ;
  int __cil_tmp12 ;

  {
#line 678
  num_lines_in = 0;
#line 679
  y_pos = dec->last_out_row_;
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;

#line 680
    if (! (num_lines_in < mb_h)) {
#line 680
      goto while_break;
    }
    {
#line 681
    lines_left = mb_h - num_lines_in;
#line 682
    __cil_tmp9 = WebPRescaleNeededLines(dec->rescaler, lines_left);
#line 682
    needed_lines = __cil_tmp9;
#line 684
    WebPMultARGBRows(in, in_stride, (dec->rescaler)->src_width, needed_lines, 0);
#line 685
    lines_imported = WebPRescalerImport(dec->rescaler, lines_left, in, in_stride);
#line 688
    num_lines_in += lines_imported;
#line 689
    in += needed_lines * in_stride;
#line 690
    __cil_tmp12 = ExportYUVA(dec, y_pos);
#line 690
    y_pos += __cil_tmp12;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 692
  return (y_pos);
}
}
#line 695 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int EmitRowsYUVA(VP8LDecoder *dec , uint8_t *in , int in_stride , int mb_w ,
                        int num_rows ) 
{ 
  int y_pos ;
  int __cil_tmp7 ;

  {
#line 698
  y_pos = dec->last_out_row_;
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    __cil_tmp7 = num_rows;
#line 699
    num_rows --;
#line 699
    if (! (__cil_tmp7 > 0)) {
#line 699
      goto while_break;
    }
    {
#line 700
    ConvertToYUVA((uint32_t *)in, mb_w, y_pos, dec->output_);
#line 701
    in += in_stride;
#line 702
    y_pos ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 704
  return (y_pos);
}
}
#line 715 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int SetCropWindow(VP8Io *io , int y_start , int y_end , uint8_t **in_data ,
                         int pixel_stride ) 
{ 
  int delta ;

  {
#line 719
  if (y_end > io->crop_bottom) {
#line 720
    y_end = io->crop_bottom;
  }
#line 722
  if (y_start < io->crop_top) {
#line 723
    delta = io->crop_top - y_start;
#line 724
    y_start = io->crop_top;
#line 725
    *in_data += delta * pixel_stride;
  }
#line 727
  if (y_start >= y_end) {
#line 727
    return (0);
  }
#line 729
  *in_data += (unsigned long )io->crop_left * sizeof(uint32_t );
#line 731
  io->mb_y = y_start - io->crop_top;
#line 732
  io->mb_w = io->crop_right - io->crop_left;
#line 733
  io->mb_h = y_end - y_start;
#line 734
  return (1);
}
}
#line 739 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
__inline static int GetMetaIndex(uint32_t *image , int xsize , int bits , int x ,
                                 int y ) 
{ 


  {
#line 741
  if (bits == 0) {
#line 741
    return (0);
  }
#line 742
  return ((int )*(image + (xsize * (y >> bits) + (x >> bits))));
}
}
#line 745 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
__inline static HTreeGroup *GetHtreeGroupForPos(VP8LMetadata *hdr , int x , int y ) 
{ 
  int meta_index ;
  int __cil_tmp5 ;

  {
  {
#line 747
  __cil_tmp5 = GetMetaIndex(hdr->huffman_image_, hdr->huffman_xsize_, hdr->huffman_subsample_bits_,
                            x, y);
#line 747
  meta_index = __cil_tmp5;
  }
#line 750
  return (hdr->htree_groups_ + meta_index);
}
}
#line 758 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static void ApplyInverseTransforms(VP8LDecoder *dec , int start_row , int num_rows ,
                                   uint32_t *rows ) 
{ 
  int n ;
  int cache_pixs ;
  int end_row ;
  uint32_t *rows_in ;
  uint32_t *rows_out ;
  int __cil_tmp10 ;
  VP8LTransform *transform ;

  {
#line 761
  n = dec->next_transform_;
#line 762
  cache_pixs = dec->width_ * num_rows;
#line 763
  end_row = start_row + num_rows;
#line 764
  rows_in = rows;
#line 765
  rows_out = dec->argb_cache_;
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;
#line 768
    __cil_tmp10 = n;
#line 768
    n --;
#line 768
    if (! (__cil_tmp10 > 0)) {
#line 768
      goto while_break;
    }
    {
#line 769
    transform = & dec->transforms_[n];
#line 770
    VP8LInverseTransform(transform, start_row, end_row, rows_in, rows_out);
#line 771
    rows_in = rows_out;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 773
  if ((unsigned long )rows_in != (unsigned long )rows_out) {
    {
#line 775
    memcpy((void *)rows_out, (void const   *)rows_in, (unsigned long )cache_pixs * sizeof(*rows_out));
    }
  }
#line 778
  return;
}
}
#line 781 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static void ProcessRows(VP8LDecoder *dec , int row ) 
{ 
  uint32_t *rows ;
  int num_rows ;
  VP8Io *io ;
  uint8_t *rows_data ;
  int in_stride ;
  int __cil_tmp8 ;
  WebPDecBuffer *output ;
  int __cil_tmp10 ;
  WebPRGBABuffer *buf ;
  uint8_t *rgba ;
  int num_rows_out ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp___0 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int tmp___1 ;

  {
#line 782
  rows = dec->pixels_ + dec->width_ * dec->last_row_;
#line 783
  num_rows = row - dec->last_row_;
#line 789
  if (num_rows > 0) {
    {
#line 790
    io = dec->io_;
#line 791
    rows_data = (uint8_t *)dec->argb_cache_;
#line 792
    in_stride = (int )((unsigned long )io->width * sizeof(uint32_t ));
#line 793
    ApplyInverseTransforms(dec, dec->last_row_, num_rows, rows);
#line 794
    __cil_tmp8 = SetCropWindow(io, dec->last_row_, row, & rows_data, in_stride);
    }
#line 794
    if (! (! __cil_tmp8)) {
      {
#line 797
      output = dec->output_;
#line 798
      __cil_tmp10 = WebPIsRGBMode(output->colorspace);
      }
#line 798
      if (__cil_tmp10) {
#line 799
        buf = & output->u.RGBA;
#line 800
        rgba = buf->rgba + dec->last_out_row_ * buf->stride;
#line 801
        if (io->use_scaling) {
          {
#line 801
          __cil_tmp14 = EmitRescaledRowsRGBA(dec, rows_data, in_stride, io->mb_h,
                                             rgba, buf->stride);
#line 801
          tmp___0 = __cil_tmp14;
          }
        } else {
          {
#line 801
          __cil_tmp15 = EmitRows(output->colorspace, rows_data, in_stride, io->mb_w,
                                 io->mb_h, rgba, buf->stride);
#line 801
          tmp___0 = __cil_tmp15;
          }
        }
#line 801
        num_rows_out = tmp___0;
#line 810
        dec->last_out_row_ += num_rows_out;
      } else {
#line 812
        if (io->use_scaling) {
          {
#line 812
          __cil_tmp17 = EmitRescaledRowsYUVA(dec, rows_data, in_stride, io->mb_h);
#line 812
          tmp___1 = __cil_tmp17;
          }
        } else {
          {
#line 812
          __cil_tmp18 = EmitRowsYUVA(dec, rows_data, in_stride, io->mb_w, io->mb_h);
#line 812
          tmp___1 = __cil_tmp18;
          }
        }
#line 812
        dec->last_out_row_ = tmp___1;
      }
    }
  }
#line 821
  dec->last_row_ = row;
#line 822
  return;
}
}
#line 827 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int Is8bOptimizable(VP8LMetadata *hdr ) 
{ 
  int i ;
  HuffmanCode **htrees ;

  {
#line 829
  if (hdr->color_cache_size_ > 0) {
#line 829
    return (0);
  }
#line 832
  i = 0;
  {
#line 832
  while (1) {
    while_continue: /* CIL Label */ ;

#line 832
    if (! (i < hdr->num_htree_groups_)) {
#line 832
      goto while_break;
    }
#line 833
    htrees = (hdr->htree_groups_ + i)->htrees;
#line 834
    if ((int )(*(htrees + 1) + 0)->bits > 0) {
#line 834
      return (0);
    }
#line 835
    if ((int )(*(htrees + 2) + 0)->bits > 0) {
#line 835
      return (0);
    }
#line 836
    if ((int )(*(htrees + 3) + 0)->bits > 0) {
#line 836
      return (0);
    }
#line 832
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 838
  return (1);
}
}
#line 841 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static void AlphaApplyFilter(ALPHDecoder *alph_dec , int first_row , int last_row ,
                             uint8_t *out , int stride ) 
{ 
  int y ;
  uint8_t *prev_line ;

  {
#line 844
  if ((unsigned int )alph_dec->filter_ != 0U) {
#line 846
    prev_line = alph_dec->prev_line_;
#line 848
    y = first_row;
    {
#line 848
    while (1) {
      while_continue: /* CIL Label */ ;

#line 848
      if (! (y < last_row)) {
#line 848
        goto while_break;
      }
      {
#line 849
      (*(WebPUnfilters[alph_dec->filter_]))(prev_line, out, out, stride);
#line 850
      prev_line = out;
#line 851
      out += stride;
#line 848
      y ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 853
    alph_dec->prev_line_ = prev_line;
  }
#line 855
  return;
}
}
#line 857 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static void ExtractPalettedAlphaRows(VP8LDecoder *dec , int last_row ) 
{ 
  ALPHDecoder *alph_dec ;
  int top_row ;
  int tmp___0 ;
  int first_row ;
  int tmp___1 ;
  int width ;
  uint8_t *out ;
  uint8_t *in ;
  VP8LTransform *transform ;

  {
#line 860
  alph_dec = (ALPHDecoder *)(dec->io_)->opaque;
#line 861
  if ((unsigned int )alph_dec->filter_ == 0U) {
#line 861
    tmp___0 = (dec->io_)->crop_top;
  } else
#line 861
  if ((unsigned int )alph_dec->filter_ == 1U) {
#line 861
    tmp___0 = (dec->io_)->crop_top;
  } else {
#line 861
    tmp___0 = dec->last_row_;
  }
#line 861
  top_row = tmp___0;
#line 865
  if (dec->last_row_ < top_row) {
#line 865
    tmp___1 = top_row;
  } else {
#line 865
    tmp___1 = dec->last_row_;
  }
#line 865
  first_row = tmp___1;
#line 867
  if (last_row > first_row) {
    {
#line 869
    width = (dec->io_)->width;
#line 870
    out = alph_dec->output_ + width * first_row;
#line 871
    in = (uint8_t *)dec->pixels_ + dec->width_ * first_row;
#line 873
    transform = & dec->transforms_[0];
#line 876
    VP8LColorIndexInverseTransformAlpha(transform, first_row, last_row, in, out);
#line 878
    AlphaApplyFilter(alph_dec, first_row, last_row, out, width);
    }
  }
#line 880
  dec->last_out_row_ = last_row;
#line 880
  dec->last_row_ = dec->last_out_row_;
#line 881
  return;
}
}
#line 887 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
__inline static uint32_t Rotate8b(uint32_t V ) 
{ 


  {
#line 891
  return (((V & 255U) << 24) | (V >> 8));
}
}
#line 896 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
__inline static void CopySmallPattern8b(uint8_t *src , uint8_t *dst , int length ,
                                        uint32_t pattern ) 
{ 
  int i ;
  uint8_t *__cil_tmp6 ;
  uint8_t *__cil_tmp7 ;

  {
  {
#line 900
  while (1) {
    while_continue: /* CIL Label */ ;

#line 900
    if (! ((uintptr_t )dst & 3UL)) {
#line 900
      goto while_break;
    }
    {
#line 901
    __cil_tmp7 = src;
#line 901
    src ++;
#line 901
    __cil_tmp6 = dst;
#line 901
    dst ++;
#line 901
    *__cil_tmp6 = *__cil_tmp7;
#line 902
    pattern = Rotate8b(pattern);
#line 903
    length --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 906
  i = 0;
  {
#line 906
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 906
    if (! (i < length >> 2)) {
#line 906
      goto while_break___0;
    }
#line 907
    *((uint32_t *)dst + i) = pattern;
#line 906
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 911
  i <<= 2;
  {
#line 911
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 911
    if (! (i < length)) {
#line 911
      goto while_break___1;
    }
#line 912
    *(dst + i) = *(src + i);
#line 911
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: ;
#line 915
  return;
}
}
#line 916 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
__inline static void CopyBlock8b(uint8_t *dst , int dist , int length ) 
{ 
  uint8_t *src ;
  uint32_t pattern ;
  int i ;

  {
#line 917
  src = dst - dist;
#line 918
  if (length >= 8) {
#line 919
    pattern = (uint32_t )0;
#line 921
    if (dist == 1) {
#line 921
      goto case_1;
    }
#line 932
    if (dist == 2) {
#line 932
      goto case_2;
    }
#line 946
    if (dist == 4) {
#line 946
      goto case_4;
    }
#line 949
    goto switch_default;
    case_1: 
#line 922
    pattern = (uint32_t )*(src + 0);
#line 929
    pattern = 16843009U * pattern;
#line 931
    goto switch_break;
    case_2: 
    {
#line 934
    memcpy((void *)(& pattern), (void const   *)src, sizeof(uint16_t ));
#line 943
    pattern = 65537U * pattern;
    }
#line 945
    goto switch_break;
    case_4: 
    {
#line 947
    memcpy((void *)(& pattern), (void const   *)src, sizeof(uint32_t ));
    }
#line 948
    goto switch_break;
    switch_default: 
#line 950
    goto Copy;
    switch_break: 
    {
#line 952
    CopySmallPattern8b(src, dst, length, pattern);
    }
#line 953
    return;
  }
  Copy: 
#line 956
  if (dist >= length) {
    {
#line 957
    memcpy((void *)dst, (void const   *)src, (unsigned long )length * sizeof(*dst));
    }
  } else {
#line 960
    i = 0;
    {
#line 960
    while (1) {
      while_continue: /* CIL Label */ ;

#line 960
      if (! (i < length)) {
#line 960
        goto while_break;
      }
#line 960
      *(dst + i) = *(src + i);
#line 960
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 965
  return;
}
}
#line 965 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
__inline static void CopySmallPattern32b(uint32_t *src , uint32_t *dst , int length ,
                                         uint64_t pattern ) 
{ 
  int i ;
  uint32_t *__cil_tmp6 ;
  uint32_t *__cil_tmp7 ;

  {
#line 969
  if ((uintptr_t )dst & 4UL) {
#line 970
    __cil_tmp7 = src;
#line 970
    src ++;
#line 970
    __cil_tmp6 = dst;
#line 970
    dst ++;
#line 970
    *__cil_tmp6 = *__cil_tmp7;
#line 971
    pattern = (pattern >> 32) | (pattern << 32);
#line 972
    length --;
  }
#line 975
  i = 0;
  {
#line 975
  while (1) {
    while_continue: /* CIL Label */ ;

#line 975
    if (! (i < length >> 1)) {
#line 975
      goto while_break;
    }
#line 976
    *((uint64_t *)dst + i) = pattern;
#line 975
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 978
  if (length & 1) {
#line 979
    *(dst + (i << 1)) = *(src + (i << 1));
  }
#line 981
  return;
}
}
#line 983 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
__inline static void CopyBlock32b(uint32_t *dst , int dist , int length ) 
{ 
  uint32_t *src ;
  uint64_t pattern ;
  int i ;

  {
#line 985
  src = dst - dist;
#line 986
  if (dist <= 2) {
#line 986
    if (length >= 4) {
#line 986
      if (((uintptr_t )dst & 3UL) == 0UL) {
#line 988
        if (dist == 1) {
#line 989
          pattern = (uint64_t )*(src + 0);
#line 990
          pattern |= pattern << 32;
        } else {
          {
#line 992
          memcpy((void *)(& pattern), (void const   *)src, sizeof(pattern));
          }
        }
        {
#line 994
        CopySmallPattern32b(src, dst, length, pattern);
        }
      } else {
#line 986
        goto _L;
      }
    } else {
#line 986
      goto _L;
    }
  } else
  _L: 
#line 995
  if (dist >= length) {
    {
#line 996
    memcpy((void *)dst, (void const   *)src, (unsigned long )length * sizeof(*dst));
    }
  } else {
#line 999
    i = 0;
    {
#line 999
    while (1) {
      while_continue: /* CIL Label */ ;

#line 999
      if (! (i < length)) {
#line 999
        goto while_break;
      }
#line 999
      *(dst + i) = *(src + i);
#line 999
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 1004
  return;
}
}
#line 1005 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int DecodeAlphaData(VP8LDecoder *dec , uint8_t *data , int width , int height ,
                           int last_row ) 
{ 
  int ok ;
  int row ;
  int col ;
  VP8LBitReader *br ;
  VP8LMetadata *hdr ;
  int pos ;
  int end ;
  int last ;
  int len_code_limit ;
  int mask ;
  HTreeGroup *htree_group ;
  HTreeGroup *__cil_tmp17 ;
  HTreeGroup *tmp___0 ;
  int code ;
  int dist_code ;
  int dist ;
  int length_sym ;
  int length ;
  int __cil_tmp26 ;
  int dist_symbol ;
  int __cil_tmp28 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1007
  ok = 1;
#line 1008
  row = dec->last_pixel_ / width;
#line 1009
  col = dec->last_pixel_ % width;
#line 1010
  br = & dec->br_;
#line 1011
  hdr = & dec->hdr_;
#line 1012
  pos = dec->last_pixel_;
#line 1013
  end = width * height;
#line 1014
  last = width * last_row;
#line 1015
  len_code_limit = 280;
#line 1016
  mask = hdr->huffman_mask_;
#line 1017
  if (pos < last) {
    {
#line 1017
    __cil_tmp17 = GetHtreeGroupForPos(hdr, col, row);
#line 1017
    tmp___0 = __cil_tmp17;
    }
  } else {
#line 1017
    tmp___0 = (HTreeGroup *)((void *)0);
  }
#line 1017
  htree_group = tmp___0;
  {
#line 1023
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1023
    if (! br->eos_) {
#line 1023
      if (! (pos < last)) {
#line 1023
        goto while_break;
      }
    } else {
#line 1023
      goto while_break;
    }
#line 1026
    if ((col & mask) == 0) {
      {
#line 1027
      htree_group = GetHtreeGroupForPos(hdr, col, row);
      }
    }
    {
#line 1030
    VP8LFillBitWindow(br);
#line 1031
    code = ReadSymbol(htree_group->htrees[0], br);
    }
#line 1032
    if (code < 256) {
#line 1033
      *(data + pos) = (uint8_t )code;
#line 1034
      pos ++;
#line 1035
      col ++;
#line 1036
      if (col >= width) {
#line 1037
        col = 0;
#line 1038
        row ++;
#line 1039
        if (row <= last_row) {
#line 1039
          if (row % 16 == 0) {
            {
#line 1040
            ExtractPalettedAlphaRows(dec, row);
            }
          }
        }
      }
    } else
#line 1043
    if (code < len_code_limit) {
      {
#line 1045
      length_sym = code - 256;
#line 1046
      __cil_tmp26 = GetCopyLength(length_sym, br);
#line 1046
      length = __cil_tmp26;
#line 1047
      __cil_tmp28 = ReadSymbol(htree_group->htrees[4], br);
#line 1047
      dist_symbol = __cil_tmp28;
#line 1048
      VP8LFillBitWindow(br);
#line 1049
      dist_code = GetCopyDistance(dist_symbol, br);
#line 1050
      dist = PlaneCodeToDistance(width, dist_code);
      }
#line 1051
      if (pos >= dist) {
#line 1051
        if (end - pos >= length) {
          {
#line 1052
          CopyBlock8b(data + pos, dist, length);
          }
        } else {
#line 1054
          ok = 0;
#line 1055
          goto End;
        }
      } else {
#line 1054
        ok = 0;
#line 1055
        goto End;
      }
#line 1057
      pos += length;
#line 1058
      col += length;
      {
#line 1059
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1059
        if (! (col >= width)) {
#line 1059
          goto while_break___0;
        }
#line 1060
        col -= width;
#line 1061
        row ++;
#line 1062
        if (row <= last_row) {
#line 1062
          if (row % 16 == 0) {
            {
#line 1063
            ExtractPalettedAlphaRows(dec, row);
            }
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
#line 1066
      if (pos < last) {
#line 1066
        if (col & mask) {
          {
#line 1067
          htree_group = GetHtreeGroupForPos(hdr, col, row);
          }
        }
      }
    } else {
#line 1070
      ok = 0;
#line 1071
      goto End;
    }
    {
#line 1073
    br->eos_ = VP8LIsEndOfStream(br);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1076
  if (row > last_row) {
#line 1076
    tmp___1 = last_row;
  } else {
#line 1076
    tmp___1 = row;
  }
  {
#line 1076
  ExtractPalettedAlphaRows(dec, tmp___1);
  }
  End: 
  {
#line 1079
  br->eos_ = VP8LIsEndOfStream(br);
  }
#line 1080
  if (! ok) {
    _L: 
#line 1081
    ok = 0;
#line 1082
    if (br->eos_) {
#line 1082
      tmp___2 = 5;
    } else {
#line 1082
      tmp___2 = 3;
    }
#line 1082
    dec->status_ = (VP8StatusCode )tmp___2;
  } else
#line 1080
  if (br->eos_) {
#line 1080
    if (pos < end) {
#line 1080
      goto _L;
    } else {
#line 1085
      dec->last_pixel_ = pos;
    }
  } else {
#line 1085
    dec->last_pixel_ = pos;
  }
#line 1087
  return (ok);
}
}
#line 1090 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static void SaveState(VP8LDecoder *dec , int last_pixel ) 
{ 


  {
#line 1092
  dec->saved_br_ = dec->br_;
#line 1093
  dec->saved_last_pixel_ = last_pixel;
#line 1094
  if (dec->hdr_.color_cache_size_ > 0) {
    {
#line 1095
    VP8LColorCacheCopy(& dec->hdr_.color_cache_, & dec->hdr_.saved_color_cache_);
    }
  }
#line 1098
  return;
}
}
#line 1099 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static void RestoreState(VP8LDecoder *dec ) 
{ 


  {
#line 1101
  dec->status_ = (VP8StatusCode )5;
#line 1102
  dec->br_ = dec->saved_br_;
#line 1103
  dec->last_pixel_ = dec->saved_last_pixel_;
#line 1104
  if (dec->hdr_.color_cache_size_ > 0) {
    {
#line 1105
    VP8LColorCacheCopy(& dec->hdr_.saved_color_cache_, & dec->hdr_.color_cache_);
    }
  }
#line 1108
  return;
}
}
#line 1110 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int DecodeImageData(VP8LDecoder *dec , uint32_t *data , int width , int height ,
                           int last_row , void (*process_func)(VP8LDecoder * const   ,
                                                               int  ) ) 
{ 
  int row ;
  int col ;
  VP8LBitReader *br ;
  VP8LMetadata *hdr ;
  uint32_t *src ;
  uint32_t *last_cached ;
  uint32_t *src_end ;
  uint32_t *src_last ;
  int len_code_limit ;
  int color_cache_limit ;
  int next_sync_row ;
  int tmp___0 ;
  VP8LColorCache *color_cache ;
  VP8LColorCache *tmp___1 ;
  int mask ;
  HTreeGroup *htree_group ;
  HTreeGroup *__cil_tmp23 ;
  HTreeGroup *tmp___2 ;
  int code ;
  int __cil_tmp28 ;
  int __cil_tmp30 ;
  int red ;
  int blue ;
  int alpha ;
  int __cil_tmp37 ;
  uint32_t *__cil_tmp38 ;
  int dist_code ;
  int dist ;
  int length_sym ;
  int length ;
  int __cil_tmp43 ;
  int dist_symbol ;
  int __cil_tmp45 ;
  int __cil_tmp48 ;
  uint32_t *__cil_tmp50 ;
  int key ;
  uint32_t *__cil_tmp52 ;
  int tmp___3 ;

  {
#line 1113
  row = dec->last_pixel_ / width;
#line 1114
  col = dec->last_pixel_ % width;
#line 1115
  br = & dec->br_;
#line 1116
  hdr = & dec->hdr_;
#line 1117
  src = data + dec->last_pixel_;
#line 1118
  last_cached = src;
#line 1119
  src_end = data + width * height;
#line 1120
  src_last = data + width * last_row;
#line 1121
  len_code_limit = 280;
#line 1122
  color_cache_limit = len_code_limit + hdr->color_cache_size_;
#line 1123
  if (dec->incremental_) {
#line 1123
    tmp___0 = row;
  } else {
#line 1123
    tmp___0 = 1 << 24;
  }
#line 1123
  next_sync_row = tmp___0;
#line 1124
  if (hdr->color_cache_size_ > 0) {
#line 1124
    tmp___1 = & hdr->color_cache_;
  } else {
#line 1124
    tmp___1 = (VP8LColorCache *)((void *)0);
  }
#line 1124
  color_cache = tmp___1;
#line 1126
  mask = hdr->huffman_mask_;
#line 1127
  if ((unsigned long )src < (unsigned long )src_last) {
    {
#line 1127
    __cil_tmp23 = GetHtreeGroupForPos(hdr, col, row);
#line 1127
    tmp___2 = __cil_tmp23;
    }
  } else {
#line 1127
    tmp___2 = (HTreeGroup *)((void *)0);
  }
#line 1127
  htree_group = tmp___2;
  {
#line 1132
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1132
    if (! ((unsigned long )src < (unsigned long )src_last)) {
#line 1132
      goto while_break;
    }
#line 1134
    if (row >= next_sync_row) {
      {
#line 1135
      SaveState(dec, (int )(src - data));
#line 1136
      next_sync_row = row + 8;
      }
    }
#line 1141
    if ((col & mask) == 0) {
      {
#line 1142
      htree_group = GetHtreeGroupForPos(hdr, col, row);
      }
    }
#line 1145
    if (htree_group->is_trivial_code) {
#line 1146
      *src = htree_group->literal_arb;
#line 1147
      goto AdvanceByOne;
    }
    {
#line 1149
    VP8LFillBitWindow(br);
    }
#line 1150
    if (htree_group->use_packed_table) {
      {
#line 1151
      code = ReadPackedSymbols(htree_group, br, src);
#line 1152
      __cil_tmp28 = VP8LIsEndOfStream(br);
      }
#line 1152
      if (__cil_tmp28) {
#line 1152
        goto while_break;
      }
#line 1153
      if (code == 0) {
#line 1153
        goto AdvanceByOne;
      }
    } else {
      {
#line 1155
      code = ReadSymbol(htree_group->htrees[0], br);
      }
    }
    {
#line 1157
    __cil_tmp30 = VP8LIsEndOfStream(br);
    }
#line 1157
    if (__cil_tmp30) {
#line 1157
      goto while_break;
    }
#line 1158
    if (code < 256) {
#line 1159
      if (htree_group->is_trivial_literal) {
#line 1160
        *src = htree_group->literal_arb | (unsigned int )(code << 8);
      } else {
        {
#line 1163
        red = ReadSymbol(htree_group->htrees[1], br);
#line 1164
        VP8LFillBitWindow(br);
#line 1165
        blue = ReadSymbol(htree_group->htrees[2], br);
#line 1166
        alpha = ReadSymbol(htree_group->htrees[3], br);
#line 1167
        __cil_tmp37 = VP8LIsEndOfStream(br);
        }
#line 1167
        if (__cil_tmp37) {
#line 1167
          goto while_break;
        }
#line 1168
        *src = ((((uint32_t )alpha << 24) | (unsigned int )(red << 16)) | (unsigned int )(code << 8)) | (unsigned int )blue;
      }
      AdvanceByOne: 
#line 1171
      src ++;
#line 1172
      col ++;
#line 1173
      if (col >= width) {
#line 1174
        col = 0;
#line 1175
        row ++;
#line 1176
        if ((unsigned long )process_func != (unsigned long )((void *)0)) {
#line 1177
          if (row <= last_row) {
#line 1177
            if (row % 16 == 0) {
              {
#line 1178
              (*process_func)((VP8LDecoder */* const  */)dec, row);
              }
            }
          }
        }
#line 1181
        if ((unsigned long )color_cache != (unsigned long )((void *)0)) {
          {
#line 1182
          while (1) {
            while_continue___0: /* CIL Label */ ;

#line 1182
            if (! ((unsigned long )last_cached < (unsigned long )src)) {
#line 1182
              goto while_break___0;
            }
            {
#line 1183
            __cil_tmp38 = last_cached;
#line 1183
            last_cached ++;
#line 1183
            VP8LColorCacheInsert___7(color_cache, *__cil_tmp38);
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          while_break___0: ;
        }
      }
    } else
#line 1187
    if (code < len_code_limit) {
      {
#line 1189
      length_sym = code - 256;
#line 1190
      __cil_tmp43 = GetCopyLength(length_sym, br);
#line 1190
      length = __cil_tmp43;
#line 1191
      __cil_tmp45 = ReadSymbol(htree_group->htrees[4], br);
#line 1191
      dist_symbol = __cil_tmp45;
#line 1192
      VP8LFillBitWindow(br);
#line 1193
      dist_code = GetCopyDistance(dist_symbol, br);
#line 1194
      dist = PlaneCodeToDistance(width, dist_code);
#line 1196
      __cil_tmp48 = VP8LIsEndOfStream(br);
      }
#line 1196
      if (__cil_tmp48) {
#line 1196
        goto while_break;
      }
#line 1197
      if (src - data < (ptrdiff_t )dist) {
#line 1198
        goto Error;
      } else
#line 1197
      if (src_end - src < (ptrdiff_t )length) {
#line 1198
        goto Error;
      } else {
        {
#line 1200
        CopyBlock32b(src, dist, length);
        }
      }
#line 1202
      src += length;
#line 1203
      col += length;
      {
#line 1204
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1204
        if (! (col >= width)) {
#line 1204
          goto while_break___1;
        }
#line 1205
        col -= width;
#line 1206
        row ++;
#line 1207
        if ((unsigned long )process_func != (unsigned long )((void *)0)) {
#line 1208
          if (row <= last_row) {
#line 1208
            if (row % 16 == 0) {
              {
#line 1209
              (*process_func)((VP8LDecoder */* const  */)dec, row);
              }
            }
          }
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: ;
#line 1216
      if (col & mask) {
        {
#line 1216
        htree_group = GetHtreeGroupForPos(hdr, col, row);
        }
      }
#line 1217
      if ((unsigned long )color_cache != (unsigned long )((void *)0)) {
        {
#line 1218
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1218
          if (! ((unsigned long )last_cached < (unsigned long )src)) {
#line 1218
            goto while_break___2;
          }
          {
#line 1219
          __cil_tmp50 = last_cached;
#line 1219
          last_cached ++;
#line 1219
          VP8LColorCacheInsert___7(color_cache, *__cil_tmp50);
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: ;
      }
    } else
#line 1222
    if (code < color_cache_limit) {
#line 1223
      key = code - len_code_limit;
      {
#line 1225
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1225
        if (! ((unsigned long )last_cached < (unsigned long )src)) {
#line 1225
          goto while_break___3;
        }
        {
#line 1226
        __cil_tmp52 = last_cached;
#line 1226
        last_cached ++;
#line 1226
        VP8LColorCacheInsert___7(color_cache, *__cil_tmp52);
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
      {
#line 1228
      *src = VP8LColorCacheLookup(color_cache, (uint32_t )key);
      }
#line 1229
      goto AdvanceByOne;
    } else {
#line 1231
      goto Error;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1235
  br->eos_ = VP8LIsEndOfStream(br);
  }
#line 1236
  if ((unsigned long )src < (unsigned long )src_end) {
#line 1236
    if (dec->incremental_) {
#line 1236
      if (br->eos_) {
        {
#line 1237
        RestoreState(dec);
        }
      } else {
#line 1236
        goto _L;
      }
    } else {
#line 1236
      goto _L;
    }
  } else
  _L: 
#line 1238
  if (! br->eos_) {
#line 1240
    if ((unsigned long )process_func != (unsigned long )((void *)0)) {
#line 1241
      if (row > last_row) {
#line 1241
        tmp___3 = last_row;
      } else {
#line 1241
        tmp___3 = row;
      }
      {
#line 1241
      (*process_func)((VP8LDecoder */* const  */)dec, tmp___3);
      }
    }
#line 1243
    dec->status_ = (VP8StatusCode )0;
#line 1244
    dec->last_pixel_ = (int )(src - data);
  } else {
#line 1248
    goto Error;
  }
#line 1250
  return (1);
  Error: 
#line 1253
  dec->status_ = (VP8StatusCode )3;
#line 1254
  return (0);
}
}
#line 1260 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static void ClearTransform(VP8LTransform *transform ) 
{ 


  {
  {
#line 1261
  WebPSafeFree((void *)transform->data_);
#line 1262
  transform->data_ = (uint32_t *)((void *)0);
  }
#line 1264
  return;
}
}
#line 1267 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int ExpandColorMap(int num_colors , VP8LTransform *transform ) 
{ 
  int i ;
  int final_num_colors ;
  uint32_t *new_color_map ;
  void *__cil_tmp6 ;
  uint8_t *data ;
  uint8_t *new_data ;

  {
  {
#line 1269
  final_num_colors = 1 << (8 >> transform->bits_);
#line 1270
  __cil_tmp6 = WebPSafeMalloc((uint64_t )final_num_colors, sizeof(*new_color_map));
#line 1270
  new_color_map = (uint32_t *)__cil_tmp6;
  }
#line 1273
  if ((unsigned long )new_color_map == (unsigned long )((void *)0)) {
#line 1274
    return (0);
  } else {
#line 1276
    data = (uint8_t *)transform->data_;
#line 1277
    new_data = (uint8_t *)new_color_map;
#line 1278
    *(new_color_map + 0) = *(transform->data_ + 0);
#line 1279
    i = 4;
    {
#line 1279
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1279
      if (! (i < 4 * num_colors)) {
#line 1279
        goto while_break;
      }
#line 1281
      *(new_data + i) = (uint8_t )(((int )*(data + i) + (int )*(new_data + (i - 4))) & 255);
#line 1279
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
    {
#line 1283
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1283
      if (! (i < 4 * final_num_colors)) {
#line 1283
        goto while_break___0;
      }
#line 1284
      *(new_data + i) = (uint8_t )0;
#line 1283
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 1286
    WebPSafeFree((void *)transform->data_);
#line 1287
    transform->data_ = new_color_map;
    }
  }
#line 1289
  return (1);
}
}
#line 1292 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int ReadTransform(int *xsize , int const   *ysize , VP8LDecoder *dec ) 
{ 
  int ok ;
  VP8LBitReader *br ;
  VP8LTransform *transform ;
  VP8LImageTransformType type ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  int __cil_tmp12 ;
  int num_colors ;
  uint32_t __cil_tmp14 ;
  int bits ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint32_t __cil_tmp19 ;
  int __cil_tmp21 ;
  int tmp___3 ;

  {
  {
#line 1294
  ok = 1;
#line 1295
  br = & dec->br_;
#line 1296
  transform = & dec->transforms_[dec->next_transform_];
#line 1297
  __cil_tmp8 = VP8LReadBits(br, 2);
#line 1297
  type = (VP8LImageTransformType )__cil_tmp8;
  }
#line 1301
  if (dec->transforms_seen_ & (1U << (unsigned int )type)) {
#line 1302
    return (0);
  }
#line 1304
  dec->transforms_seen_ |= 1U << (unsigned int )type;
#line 1306
  transform->type_ = type;
#line 1307
  transform->xsize_ = *xsize;
#line 1308
  transform->ysize_ = (int )*ysize;
#line 1309
  transform->data_ = (uint32_t *)((void *)0);
#line 1310
  (dec->next_transform_) ++;
#line 1315
  if ((unsigned int )type == 1U) {
#line 1315
    goto case_1;
  }
#line 1315
  if ((unsigned int )type == 0U) {
#line 1315
    goto case_1;
  }
#line 1323
  if ((unsigned int )type == 3U) {
#line 1323
    goto case_3;
  }
#line 1335
  if ((unsigned int )type == 2U) {
#line 1335
    goto case_2;
  }
#line 1313
  goto switch_break;
  case_1: 
  {
#line 1316
  __cil_tmp9 = VP8LReadBits(br, 3);
#line 1316
  transform->bits_ = (int )(__cil_tmp9 + 2U);
#line 1317
  __cil_tmp10 = VP8LSubSampleSize((uint32_t )transform->xsize_, (uint32_t )transform->bits_);
#line 1317
  __cil_tmp11 = VP8LSubSampleSize((uint32_t )transform->ysize_, (uint32_t )transform->bits_);
#line 1317
  __cil_tmp12 = DecodeImageStream((int )__cil_tmp10, (int )__cil_tmp11, 0, dec, & transform->data_);
#line 1317
  ok = __cil_tmp12;
  }
#line 1322
  goto switch_break;
  case_3: 
  {
#line 1324
  __cil_tmp14 = VP8LReadBits(br, 8);
#line 1324
  num_colors = (int )(__cil_tmp14 + 1U);
  }
#line 1325
  if (num_colors > 16) {
#line 1325
    tmp___2 = 0;
  } else {
#line 1325
    if (num_colors > 4) {
#line 1325
      tmp___1 = 1;
    } else {
#line 1325
      if (num_colors > 2) {
#line 1325
        tmp___0 = 2;
      } else {
#line 1325
        tmp___0 = 3;
      }
#line 1325
      tmp___1 = tmp___0;
    }
#line 1325
    tmp___2 = tmp___1;
  }
  {
#line 1325
  bits = tmp___2;
#line 1329
  __cil_tmp19 = VP8LSubSampleSize((uint32_t )transform->xsize_, (uint32_t )bits);
#line 1329
  *xsize = (int )__cil_tmp19;
#line 1330
  transform->bits_ = bits;
#line 1331
  ok = DecodeImageStream(num_colors, 1, 0, dec, & transform->data_);
#line 1332
  __cil_tmp21 = ExpandColorMap(num_colors, transform);
  }
#line 1332
  if (ok) {
#line 1332
    if (__cil_tmp21) {
#line 1332
      tmp___3 = 1;
    } else {
#line 1332
      tmp___3 = 0;
    }
  } else {
#line 1332
    tmp___3 = 0;
  }
#line 1332
  ok = tmp___3;
#line 1333
  goto switch_break;
  case_2: 
#line 1336
  goto switch_break;
#line 1339
  goto switch_break;
  switch_break: ;
#line 1342
  return (ok);
}
}
#line 1348 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static void InitMetadata(VP8LMetadata *hdr ) 
{ 


  {
  {
#line 1350
  memset((void *)hdr, 0, sizeof(*hdr));
  }
#line 1352
  return;
}
}
#line 1353 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static void ClearMetadata(VP8LMetadata *hdr ) 
{ 


  {
  {
#line 1356
  WebPSafeFree((void *)hdr->huffman_image_);
#line 1357
  WebPSafeFree((void *)hdr->huffman_tables_);
#line 1358
  VP8LHtreeGroupsFree(hdr->htree_groups_);
#line 1359
  VP8LColorCacheClear(& hdr->color_cache_);
#line 1360
  VP8LColorCacheClear(& hdr->saved_color_cache_);
#line 1361
  InitMetadata(hdr);
  }
#line 1363
  return;
}
}
#line 1367 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
VP8LDecoder *VP8LNew(void) 
{ 
  VP8LDecoder *dec ;
  void *__cil_tmp2 ;

  {
  {
#line 1368
  __cil_tmp2 = WebPSafeCalloc((uint64_t )1ULL, sizeof(*dec));
#line 1368
  dec = (VP8LDecoder *)__cil_tmp2;
  }
#line 1369
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 1369
    return ((VP8LDecoder *)((void *)0));
  }
  {
#line 1370
  dec->status_ = (VP8StatusCode )0;
#line 1371
  dec->state_ = (VP8LDecodeState )2;
#line 1373
  VP8LDspInit();
  }
#line 1375
  return (dec);
}
}
#line 1378 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
void VP8LClear(VP8LDecoder *dec ) 
{ 
  int i ;

  {
#line 1380
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 1380
    return;
  }
  {
#line 1381
  ClearMetadata(& dec->hdr_);
#line 1383
  WebPSafeFree((void *)dec->pixels_);
#line 1384
  dec->pixels_ = (uint32_t *)((void *)0);
#line 1385
  i = 0;
  }
  {
#line 1385
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1385
    if (! (i < dec->next_transform_)) {
#line 1385
      goto while_break;
    }
    {
#line 1386
    ClearTransform(& dec->transforms_[i]);
#line 1385
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1388
  dec->next_transform_ = 0;
#line 1389
  dec->transforms_seen_ = (uint32_t )0;
#line 1391
  WebPSafeFree((void *)dec->rescaler_memory);
#line 1392
  dec->rescaler_memory = (uint8_t *)((void *)0);
#line 1394
  dec->output_ = (WebPDecBuffer *)((void *)0);
  }
#line 1396
  return;
}
}
#line 1397 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
void VP8LDelete(VP8LDecoder *dec ) 
{ 


  {
#line 1398
  if ((unsigned long )dec != (unsigned long )((void *)0)) {
    {
#line 1399
    VP8LClear(dec);
#line 1400
    WebPSafeFree((void *)dec);
    }
  }
#line 1403
  return;
}
}
#line 1404 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static void UpdateDecoder(VP8LDecoder *dec , int width , int height ) 
{ 
  VP8LMetadata *hdr ;
  int num_bits ;
  uint32_t __cil_tmp6 ;
  int tmp___0 ;

  {
  {
#line 1405
  hdr = & dec->hdr_;
#line 1406
  num_bits = hdr->huffman_subsample_bits_;
#line 1407
  dec->width_ = width;
#line 1408
  dec->height_ = height;
#line 1410
  __cil_tmp6 = VP8LSubSampleSize((uint32_t )width, (uint32_t )num_bits);
#line 1410
  hdr->huffman_xsize_ = (int )__cil_tmp6;
  }
#line 1411
  if (num_bits == 0) {
#line 1411
    tmp___0 = ~ 0;
  } else {
#line 1411
    tmp___0 = (1 << num_bits) - 1;
  }
#line 1411
  hdr->huffman_mask_ = tmp___0;
#line 1412
  return;
}
}
#line 1414 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int DecodeImageStream(int xsize , int ysize , int is_level0 , VP8LDecoder *dec ,
                             uint32_t **decoded_data ) 
{ 
  int ok ;
  int transform_xsize ;
  int transform_ysize ;
  VP8LBitReader *br ;
  VP8LMetadata *hdr ;
  uint32_t *data ;
  int color_cache_bits ;
  uint32_t __cil_tmp13 ;
  uint32_t __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  uint64_t total_size ;
  void *__cil_tmp20 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1418
  ok = 1;
#line 1419
  transform_xsize = xsize;
#line 1420
  transform_ysize = ysize;
#line 1421
  br = & dec->br_;
#line 1422
  hdr = & dec->hdr_;
#line 1423
  data = (uint32_t *)((void *)0);
#line 1424
  color_cache_bits = 0;
#line 1427
  if (is_level0) {
    {
#line 1428
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1428
      __cil_tmp13 = VP8LReadBits(br, 1);
      }
#line 1428
      if (ok) {
#line 1428
        if (! __cil_tmp13) {
#line 1428
          goto while_break;
        }
      } else {
#line 1428
        goto while_break;
      }
      {
#line 1429
      ok = ReadTransform(& transform_xsize, (int const   *)(& transform_ysize), dec);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 1434
  __cil_tmp15 = VP8LReadBits(br, 1);
  }
#line 1434
  if (ok) {
#line 1434
    if (__cil_tmp15) {
      {
#line 1435
      __cil_tmp16 = VP8LReadBits(br, 4);
#line 1435
      color_cache_bits = (int )__cil_tmp16;
      }
#line 1436
      if (color_cache_bits >= 1) {
#line 1436
        if (color_cache_bits <= 11) {
#line 1436
          tmp___0 = 1;
        } else {
#line 1436
          tmp___0 = 0;
        }
      } else {
#line 1436
        tmp___0 = 0;
      }
#line 1436
      ok = tmp___0;
#line 1437
      if (! ok) {
#line 1438
        dec->status_ = (VP8StatusCode )3;
#line 1439
        goto End;
      }
    }
  }
  {
#line 1444
  __cil_tmp17 = ReadHuffmanCodes(dec, transform_xsize, transform_ysize, color_cache_bits,
                                 is_level0);
  }
#line 1444
  if (ok) {
#line 1444
    if (__cil_tmp17) {
#line 1444
      tmp___1 = 1;
    } else {
#line 1444
      tmp___1 = 0;
    }
  } else {
#line 1444
    tmp___1 = 0;
  }
#line 1444
  ok = tmp___1;
#line 1446
  if (! ok) {
#line 1447
    dec->status_ = (VP8StatusCode )3;
#line 1448
    goto End;
  }
#line 1452
  if (color_cache_bits > 0) {
    {
#line 1453
    hdr->color_cache_size_ = 1 << color_cache_bits;
#line 1454
    __cil_tmp18 = VP8LColorCacheInit(& hdr->color_cache_, color_cache_bits);
    }
#line 1454
    if (! __cil_tmp18) {
#line 1455
      dec->status_ = (VP8StatusCode )1;
#line 1456
      ok = 0;
#line 1457
      goto End;
    }
  } else {
#line 1460
    hdr->color_cache_size_ = 0;
  }
  {
#line 1462
  UpdateDecoder(dec, transform_xsize, transform_ysize);
  }
#line 1464
  if (is_level0) {
#line 1465
    dec->state_ = (VP8LDecodeState )1;
#line 1466
    goto End;
  }
  {
#line 1470
  total_size = (uint64_t )transform_xsize * (unsigned long )transform_ysize;
#line 1471
  __cil_tmp20 = WebPSafeMalloc(total_size, sizeof(*data));
#line 1471
  data = (uint32_t *)__cil_tmp20;
  }
#line 1472
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1473
    dec->status_ = (VP8StatusCode )1;
#line 1474
    ok = 0;
#line 1475
    goto End;
  }
  {
#line 1480
  ok = DecodeImageData(dec, data, transform_xsize, transform_ysize, transform_ysize,
                       (void (*)(VP8LDecoder * const   , int  ))((void *)0));
  }
#line 1482
  if (ok) {
#line 1482
    if (! br->eos_) {
#line 1482
      tmp___2 = 1;
    } else {
#line 1482
      tmp___2 = 0;
    }
  } else {
#line 1482
    tmp___2 = 0;
  }
#line 1482
  ok = tmp___2;
  End: 
#line 1485
  if (! ok) {
    {
#line 1486
    WebPSafeFree((void *)data);
#line 1487
    ClearMetadata(hdr);
    }
  } else {
#line 1489
    if ((unsigned long )decoded_data != (unsigned long )((void *)0)) {
#line 1490
      *decoded_data = data;
    }
#line 1497
    dec->last_pixel_ = 0;
#line 1498
    if (! is_level0) {
      {
#line 1498
      ClearMetadata(hdr);
      }
    }
  }
#line 1500
  return (ok);
}
}
#line 1505 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int AllocateInternalBuffers32b(VP8LDecoder *dec , int final_width ) 
{ 
  uint64_t num_pixels ;
  uint64_t cache_top_pixels ;
  uint64_t cache_pixels ;
  uint64_t total_num_pixels ;
  void *__cil_tmp7 ;

  {
  {
#line 1506
  num_pixels = (uint64_t )dec->width_ * (unsigned long )dec->height_;
#line 1509
  cache_top_pixels = (uint64_t )((uint16_t )final_width);
#line 1511
  cache_pixels = (uint64_t )final_width * 16UL;
#line 1512
  total_num_pixels = (num_pixels + cache_top_pixels) + cache_pixels;
#line 1516
  __cil_tmp7 = WebPSafeMalloc(total_num_pixels, sizeof(uint32_t ));
#line 1516
  dec->pixels_ = (uint32_t *)__cil_tmp7;
  }
#line 1517
  if ((unsigned long )dec->pixels_ == (unsigned long )((void *)0)) {
#line 1518
    dec->argb_cache_ = (uint32_t *)((void *)0);
#line 1519
    dec->status_ = (VP8StatusCode )1;
#line 1520
    return (0);
  }
#line 1522
  dec->argb_cache_ = (dec->pixels_ + num_pixels) + cache_top_pixels;
#line 1523
  return (1);
}
}
#line 1526 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static int AllocateInternalBuffers8b(VP8LDecoder *dec ) 
{ 
  uint64_t total_num_pixels ;
  void *__cil_tmp3 ;

  {
  {
#line 1527
  total_num_pixels = (uint64_t )dec->width_ * (unsigned long )dec->height_;
#line 1528
  dec->argb_cache_ = (uint32_t *)((void *)0);
#line 1529
  __cil_tmp3 = WebPSafeMalloc(total_num_pixels, sizeof(uint8_t ));
#line 1529
  dec->pixels_ = (uint32_t *)__cil_tmp3;
  }
#line 1530
  if ((unsigned long )dec->pixels_ == (unsigned long )((void *)0)) {
#line 1531
    dec->status_ = (VP8StatusCode )1;
#line 1532
    return (0);
  }
#line 1534
  return (1);
}
}
#line 1540 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
static void ExtractAlphaRows(VP8LDecoder *dec , int last_row ) 
{ 
  int cur_row ;
  int num_rows ;
  uint32_t *in ;
  int num_rows_to_process ;
  int tmp___0 ;
  ALPHDecoder *alph_dec ;
  uint8_t *output ;
  int width ;
  int cache_pixs ;
  uint8_t *dst ;
  uint32_t *src ;

  {
#line 1541
  cur_row = dec->last_row_;
#line 1542
  num_rows = last_row - cur_row;
#line 1543
  in = dec->pixels_ + dec->width_ * cur_row;
  {
#line 1546
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1546
    if (! (num_rows > 0)) {
#line 1546
      goto while_break;
    }
#line 1547
    if (num_rows > 16) {
#line 1547
      tmp___0 = 16;
    } else {
#line 1547
      tmp___0 = num_rows;
    }
    {
#line 1547
    num_rows_to_process = tmp___0;
#line 1550
    alph_dec = (ALPHDecoder *)(dec->io_)->opaque;
#line 1551
    output = alph_dec->output_;
#line 1552
    width = (dec->io_)->width;
#line 1553
    cache_pixs = width * num_rows_to_process;
#line 1554
    dst = output + width * cur_row;
#line 1555
    src = dec->argb_cache_;
#line 1556
    ApplyInverseTransforms(dec, cur_row, num_rows_to_process, in);
#line 1557
    (*WebPExtractGreen)(src, dst, cache_pixs);
#line 1558
    AlphaApplyFilter(alph_dec, cur_row, cur_row + num_rows_to_process, dst, width);
#line 1560
    num_rows -= num_rows_to_process;
#line 1561
    in += num_rows_to_process * dec->width_;
#line 1562
    cur_row += num_rows_to_process;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1565
  dec->last_out_row_ = last_row;
#line 1565
  dec->last_row_ = dec->last_out_row_;
#line 1566
  return;
}
}
#line 1568 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
int VP8LDecodeAlphaHeader(ALPHDecoder *alph_dec , uint8_t *data , size_t data_size ) 
{ 
  int ok ;
  VP8LDecoder *dec ;
  VP8LDecoder *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 1570
  ok = 0;
#line 1571
  __cil_tmp6 = VP8LNew();
#line 1571
  dec = __cil_tmp6;
  }
#line 1573
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 1573
    return (0);
  }
  {
#line 1577
  dec->width_ = alph_dec->width_;
#line 1578
  dec->height_ = alph_dec->height_;
#line 1579
  dec->io_ = & alph_dec->io_;
#line 1580
  (dec->io_)->opaque = (void *)alph_dec;
#line 1581
  (dec->io_)->width = alph_dec->width_;
#line 1582
  (dec->io_)->height = alph_dec->height_;
#line 1584
  dec->status_ = (VP8StatusCode )0;
#line 1585
  VP8LInitBitReader(& dec->br_, data, data_size);
#line 1587
  __cil_tmp7 = DecodeImageStream(alph_dec->width_, alph_dec->height_, 1, dec, (uint32_t **)((void *)0));
  }
#line 1587
  if (! __cil_tmp7) {
#line 1588
    goto Err;
  }
  {
#line 1594
  __cil_tmp8 = Is8bOptimizable(& dec->hdr_);
  }
#line 1594
  if (dec->next_transform_ == 1) {
#line 1594
    if ((unsigned int )dec->transforms_[0].type_ == 3U) {
#line 1594
      if (__cil_tmp8) {
        {
#line 1597
        alph_dec->use_8b_decode_ = 1;
#line 1598
        ok = AllocateInternalBuffers8b(dec);
        }
      } else {
        {
#line 1601
        alph_dec->use_8b_decode_ = 0;
#line 1602
        ok = AllocateInternalBuffers32b(dec, alph_dec->width_);
        }
      }
    } else {
      {
#line 1601
      alph_dec->use_8b_decode_ = 0;
#line 1602
      ok = AllocateInternalBuffers32b(dec, alph_dec->width_);
      }
    }
  } else {
    {
#line 1601
    alph_dec->use_8b_decode_ = 0;
#line 1602
    ok = AllocateInternalBuffers32b(dec, alph_dec->width_);
    }
  }
#line 1605
  if (! ok) {
#line 1605
    goto Err;
  }
#line 1608
  alph_dec->vp8l_dec_ = dec;
#line 1609
  return (1);
  Err: 
  {
#line 1612
  VP8LDelete(dec);
  }
#line 1613
  return (0);
}
}
#line 1616 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
int VP8LDecodeAlphaImageStream(ALPHDecoder *alph_dec , int last_row ) 
{ 
  VP8LDecoder *dec ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int tmp___0 ;

  {
#line 1617
  dec = alph_dec->vp8l_dec_;
#line 1621
  if (dec->last_row_ >= last_row) {
#line 1622
    return (1);
  }
#line 1625
  if (! alph_dec->use_8b_decode_) {
    {
#line 1625
    WebPInitAlphaProcessing();
    }
  }
#line 1628
  if (alph_dec->use_8b_decode_) {
    {
#line 1628
    __cil_tmp4 = DecodeAlphaData(dec, (uint8_t *)dec->pixels_, dec->width_, dec->height_,
                                 last_row);
#line 1628
    tmp___0 = __cil_tmp4;
    }
  } else {
    {
#line 1628
    __cil_tmp5 = DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_, last_row,
                                 (void (*)(VP8LDecoder * const   , int  ))(& ExtractAlphaRows));
#line 1628
    tmp___0 = __cil_tmp5;
    }
  }
#line 1628
  return (tmp___0);
}
}
#line 1637 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
int VP8LDecodeHeader(VP8LDecoder *dec , VP8Io *io ) 
{ 
  int width ;
  int height ;
  int has_alpha ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 1640
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 1640
    return (0);
  }
#line 1641
  if ((unsigned long )io == (unsigned long )((void *)0)) {
#line 1642
    dec->status_ = (VP8StatusCode )2;
#line 1643
    return (0);
  }
  {
#line 1646
  dec->io_ = io;
#line 1647
  dec->status_ = (VP8StatusCode )0;
#line 1648
  VP8LInitBitReader(& dec->br_, io->data, io->data_size);
#line 1649
  __cil_tmp6 = ReadImageInfo(& dec->br_, & width, & height, & has_alpha);
  }
#line 1649
  if (! __cil_tmp6) {
#line 1650
    dec->status_ = (VP8StatusCode )3;
#line 1651
    goto Error;
  }
  {
#line 1653
  dec->state_ = (VP8LDecodeState )2;
#line 1654
  io->width = width;
#line 1655
  io->height = height;
#line 1657
  __cil_tmp7 = DecodeImageStream(width, height, 1, dec, (uint32_t **)((void *)0));
  }
#line 1657
  if (! __cil_tmp7) {
#line 1657
    goto Error;
  }
#line 1658
  return (1);
  Error: 
  {
#line 1661
  VP8LClear(dec);
  }
#line 1663
  return (0);
}
}
#line 1666 "/root/patron-new/new_3/src/dec/vp8l_dec.c"
int VP8LDecodeImage(VP8LDecoder *dec ) 
{ 
  VP8Io *io ;
  WebPDecParams *params ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 1667
  io = (VP8Io *)((void *)0);
#line 1668
  params = (WebPDecParams *)((void *)0);
#line 1670
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 1670
    return (0);
  }
#line 1676
  io = dec->io_;
#line 1678
  params = (WebPDecParams *)io->opaque;
#line 1682
  if ((unsigned int )dec->state_ != 0U) {
    {
#line 1683
    dec->output_ = params->output;
#line 1686
    __cil_tmp4 = WebPIoInitFromOptions(params->options, io, (WEBP_CSP_MODE )3);
    }
#line 1686
    if (! __cil_tmp4) {
#line 1687
      dec->status_ = (VP8StatusCode )2;
#line 1688
      goto Err;
    }
    {
#line 1691
    __cil_tmp5 = AllocateInternalBuffers32b(dec, io->width);
    }
#line 1691
    if (! __cil_tmp5) {
#line 1691
      goto Err;
    }
    {
#line 1694
    __cil_tmp6 = AllocateAndInitRescaler(dec, io);
    }
#line 1694
    if (io->use_scaling) {
#line 1694
      if (! __cil_tmp6) {
#line 1694
        goto Err;
      }
    }
    {
#line 1701
    __cil_tmp7 = WebPIsPremultipliedMode((dec->output_)->colorspace);
    }
#line 1701
    if (io->use_scaling) {
      {
#line 1703
      WebPInitAlphaProcessing();
      }
    } else
#line 1701
    if (__cil_tmp7) {
      {
#line 1703
      WebPInitAlphaProcessing();
      }
    }
    {
#line 1706
    __cil_tmp8 = WebPIsRGBMode((dec->output_)->colorspace);
    }
#line 1706
    if (! __cil_tmp8) {
      {
#line 1707
      WebPInitConvertARGBToYUV();
      }
#line 1708
      if ((unsigned long )(dec->output_)->u.YUVA.a != (unsigned long )((void *)0)) {
        {
#line 1708
        WebPInitAlphaProcessing();
        }
      }
    }
#line 1710
    if (dec->incremental_) {
#line 1711
      if ((unsigned long )dec->hdr_.saved_color_cache_.colors_ == (unsigned long )((void *)0)) {
#line 1711
        if (dec->hdr_.color_cache_size_ > 0) {
          {
#line 1713
          __cil_tmp9 = VP8LColorCacheInit(& dec->hdr_.saved_color_cache_, dec->hdr_.color_cache_.hash_bits_);
          }
#line 1713
          if (! __cil_tmp9) {
#line 1715
            dec->status_ = (VP8StatusCode )1;
#line 1716
            goto Err;
          }
        }
      }
    }
#line 1720
    dec->state_ = (VP8LDecodeState )0;
  }
  {
#line 1724
  __cil_tmp10 = DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_, io->crop_bottom,
                                (void (*)(VP8LDecoder * const   , int  ))(& ProcessRows));
  }
#line 1724
  if (! __cil_tmp10) {
#line 1726
    goto Err;
  }
#line 1729
  params->last_y = dec->last_out_row_;
#line 1730
  return (1);
  Err: 
  {
#line 1733
  VP8LClear(dec);
  }
#line 1735
  return (0);
}
}
#line 25 "/root/patron-new/new_3/src/dec/vp8_dec.c"
int WebPGetDecoderVersion(void) 
{ 


  {
#line 26
  return ((1 << 16) | (2 << 8));
}
}
#line 35 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static int (*GetCoeffs)(VP8BitReader * const   , VP8BandProbas * const  * , int  ,
                        int * , int  , int16_t * )  =    (int (*)(VP8BitReader * const   , VP8BandProbas * const  * , int  , int * , int  ,
            int16_t * ))((void *)0);
#line 37
void InitGetCoeffs(void) ;
#line 42 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static void SetOk(VP8Decoder *dec ) 
{ 


  {
  {
#line 43
  dec->status_ = (VP8StatusCode )0;
#line 44
  strcpy((char *)dec->error_msg_, "OK");
  }
#line 45
  return;
}
}
#line 47 "/root/patron-new/new_3/src/dec/vp8_dec.c"
int VP8InitIoInternal(VP8Io *io , int version ) 
{ 


  {
#line 48
  if (version >> 8 != 521 >> 8) {
#line 49
    return (0);
  }
#line 51
  if ((unsigned long )io != (unsigned long )((void *)0)) {
    {
#line 52
    memset((void *)io, 0, sizeof(*io));
    }
  }
#line 54
  return (1);
}
}
#line 57 "/root/patron-new/new_3/src/dec/vp8_dec.c"
VP8Decoder *VP8New(void) 
{ 
  VP8Decoder *dec ;
  void *__cil_tmp2 ;
  WebPWorkerInterface *__cil_tmp3 ;

  {
  {
#line 58
  __cil_tmp2 = WebPSafeCalloc((uint64_t )1ULL, sizeof(*dec));
#line 58
  dec = (VP8Decoder *)__cil_tmp2;
  }
#line 59
  if ((unsigned long )dec != (unsigned long )((void *)0)) {
    {
#line 60
    SetOk(dec);
#line 61
    (*(__cil_tmp3->Init))((WebPWorker */* const  */)(& dec->worker_));
#line 62
    dec->ready_ = 0;
#line 63
    dec->num_parts_minus_one_ = (uint32_t )0;
#line 64
    InitGetCoeffs();
    }
  }
#line 66
  return (dec);
}
}
#line 69 "/root/patron-new/new_3/src/dec/vp8_dec.c"
VP8StatusCode VP8Status(VP8Decoder *dec ) 
{ 


  {
#line 70
  if (! dec) {
#line 70
    return ((VP8StatusCode )2);
  }
#line 71
  return (dec->status_);
}
}
#line 74 "/root/patron-new/new_3/src/dec/vp8_dec.c"
char const   *VP8StatusMessage(VP8Decoder *dec ) 
{ 


  {
#line 75
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 75
    return ("no object");
  }
#line 76
  if (! dec->error_msg_) {
#line 76
    return ("OK");
  }
#line 77
  return (dec->error_msg_);
}
}
#line 80 "/root/patron-new/new_3/src/dec/vp8_dec.c"
void VP8Delete(VP8Decoder *dec ) 
{ 


  {
#line 81
  if ((unsigned long )dec != (unsigned long )((void *)0)) {
    {
#line 82
    VP8Clear(dec);
#line 83
    WebPSafeFree((void *)dec);
    }
  }
#line 86
  return;
}
}
#line 87 "/root/patron-new/new_3/src/dec/vp8_dec.c"
int VP8SetError(VP8Decoder *dec , VP8StatusCode error , char const   *msg ) 
{ 


  {
#line 90
  if ((unsigned int )dec->status_ == 0U) {
#line 91
    dec->status_ = error;
#line 92
    dec->error_msg_ = msg;
#line 93
    dec->ready_ = 0;
  }
#line 95
  return (0);
}
}
#line 100 "/root/patron-new/new_3/src/dec/vp8_dec.c"
int VP8CheckSignature(uint8_t *data , size_t data_size ) 
{ 
  int tmp___0 ;

  {
#line 101
  if (data_size >= 3UL) {
#line 101
    if ((int )*(data + 0) == 157) {
#line 101
      if ((int )*(data + 1) == 1) {
#line 101
        if ((int )*(data + 2) == 42) {
#line 101
          tmp___0 = 1;
        } else {
#line 101
          tmp___0 = 0;
        }
      } else {
#line 101
        tmp___0 = 0;
      }
    } else {
#line 101
      tmp___0 = 0;
    }
  } else {
#line 101
    tmp___0 = 0;
  }
#line 101
  return (tmp___0);
}
}
#line 105 "/root/patron-new/new_3/src/dec/vp8_dec.c"
int VP8GetInfo(uint8_t *data , size_t data_size , size_t chunk_size , int *width ,
               int *height ) 
{ 
  int __cil_tmp6 ;
  uint32_t bits ;
  int key_frame ;
  int w ;
  int h ;

  {
#line 107
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 108
    return (0);
  } else
#line 107
  if (data_size < 10UL) {
#line 108
    return (0);
  }
  {
#line 111
  __cil_tmp6 = VP8CheckSignature(data + 3, data_size - 3UL);
  }
#line 111
  if (! __cil_tmp6) {
#line 112
    return (0);
  } else {
#line 114
    bits = (uint32_t )(((int )*(data + 0) | ((int )*(data + 1) << 8)) | ((int )*(data + 2) << 16));
#line 115
    key_frame = ! (bits & 1U);
#line 116
    w = (((int )*(data + 7) << 8) | (int )*(data + 6)) & 16383;
#line 117
    h = (((int )*(data + 9) << 8) | (int )*(data + 8)) & 16383;
#line 119
    if (! key_frame) {
#line 120
      return (0);
    }
#line 123
    if (((bits >> 1) & 7U) > 3U) {
#line 124
      return (0);
    }
#line 126
    if (! ((bits >> 4) & 1U)) {
#line 127
      return (0);
    }
#line 129
    if ((unsigned long )(bits >> 5) >= chunk_size) {
#line 130
      return (0);
    }
#line 132
    if (w == 0) {
#line 133
      return (0);
    } else
#line 132
    if (h == 0) {
#line 133
      return (0);
    }
#line 136
    if (width) {
#line 137
      *width = w;
    }
#line 139
    if (height) {
#line 140
      *height = h;
    }
#line 143
    return (1);
  }
}
}
#line 150 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static void ResetSegmentHeader___0(VP8SegmentHeader *hdr ) 
{ 


  {
  {
#line 152
  hdr->use_segment_ = 0;
#line 153
  hdr->update_map_ = 0;
#line 154
  hdr->absolute_delta_ = 1;
#line 155
  memset((void *)(hdr->quantizer_), 0, sizeof(hdr->quantizer_));
#line 156
  memset((void *)(hdr->filter_strength_), 0, sizeof(hdr->filter_strength_));
  }
#line 158
  return;
}
}
#line 160 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static int ParseSegmentHeader(VP8BitReader *br , VP8SegmentHeader *hdr , VP8Proba *proba ) 
{ 
  uint32_t __cil_tmp4 ;
  uint32_t __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  int s ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  int32_t __cil_tmp10 ;
  int32_t tmp___0 ;
  uint32_t __cil_tmp12 ;
  int32_t __cil_tmp13 ;
  int32_t tmp___1 ;
  int s___0 ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  uint32_t tmp___2 ;

  {
  {
#line 164
  __cil_tmp4 = VP8GetValue(br, 1);
#line 164
  hdr->use_segment_ = (int )__cil_tmp4;
  }
#line 165
  if (hdr->use_segment_) {
    {
#line 166
    __cil_tmp5 = VP8GetValue(br, 1);
#line 166
    hdr->update_map_ = (int )__cil_tmp5;
#line 167
    __cil_tmp6 = VP8GetValue(br, 1);
    }
#line 167
    if (__cil_tmp6) {
      {
#line 169
      __cil_tmp8 = VP8GetValue(br, 1);
#line 169
      hdr->absolute_delta_ = (int )__cil_tmp8;
#line 170
      s = 0;
      }
      {
#line 170
      while (1) {
        while_continue: /* CIL Label */ ;

#line 170
        if (! (s < 4)) {
#line 170
          goto while_break;
        }
        {
#line 171
        __cil_tmp9 = VP8GetValue(br, 1);
        }
#line 171
        if (__cil_tmp9) {
          {
#line 171
          __cil_tmp10 = VP8GetSignedValue(br, 7);
#line 171
          tmp___0 = __cil_tmp10;
          }
        } else {
#line 171
          tmp___0 = 0;
        }
#line 171
        hdr->quantizer_[s] = (int8_t )tmp___0;
#line 170
        s ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: 
#line 174
      s = 0;
      {
#line 174
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 174
        if (! (s < 4)) {
#line 174
          goto while_break___0;
        }
        {
#line 175
        __cil_tmp12 = VP8GetValue(br, 1);
        }
#line 175
        if (__cil_tmp12) {
          {
#line 175
          __cil_tmp13 = VP8GetSignedValue(br, 6);
#line 175
          tmp___1 = __cil_tmp13;
          }
        } else {
#line 175
          tmp___1 = 0;
        }
#line 175
        hdr->filter_strength_[s] = (int8_t )tmp___1;
#line 174
        s ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    }
#line 179
    if (hdr->update_map_) {
#line 181
      s___0 = 0;
      {
#line 181
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 181
        if (! (s___0 < 3)) {
#line 181
          goto while_break___1;
        }
        {
#line 182
        __cil_tmp16 = VP8GetValue(br, 1);
        }
#line 182
        if (__cil_tmp16) {
          {
#line 182
          __cil_tmp17 = VP8GetValue(br, 8);
#line 182
          tmp___2 = __cil_tmp17;
          }
        } else {
#line 182
          tmp___2 = 255U;
        }
#line 182
        proba->segments_[s___0] = (uint8_t )tmp___2;
#line 181
        s___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
    }
  } else {
#line 187
    hdr->update_map_ = 0;
  }
#line 189
  return (! br->eof_);
}
}
#line 201 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static VP8StatusCode ParsePartitions(VP8Decoder *dec , uint8_t *buf , size_t size ) 
{ 
  VP8BitReader *br ;
  uint8_t *sz ;
  uint8_t *buf_end ;
  uint8_t *part_start ;
  size_t size_left ;
  size_t last_part ;
  size_t p ;
  uint32_t __cil_tmp11 ;
  size_t psize ;
  int tmp___0 ;

  {
  {
#line 203
  br = & dec->br_;
#line 204
  sz = buf;
#line 205
  buf_end = buf + size;
#line 207
  size_left = size;
#line 211
  __cil_tmp11 = VP8GetValue(br, 2);
#line 211
  dec->num_parts_minus_one_ = (uint32_t )((1 << __cil_tmp11) - 1);
#line 212
  last_part = (size_t )dec->num_parts_minus_one_;
  }
#line 213
  if (size < 3UL * last_part) {
#line 215
    return ((VP8StatusCode )7);
  }
#line 217
  part_start = buf + last_part * 3UL;
#line 218
  size_left -= last_part * 3UL;
#line 219
  p = (size_t )0;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;

#line 219
    if (! (p < last_part)) {
#line 219
      goto while_break;
    }
#line 220
    psize = (size_t )(((int )*(sz + 0) | ((int )*(sz + 1) << 8)) | ((int )*(sz + 2) << 16));
#line 221
    if (psize > size_left) {
#line 221
      psize = size_left;
    }
    {
#line 222
    VP8InitBitReader(dec->parts_ + p, part_start, psize);
#line 223
    part_start += psize;
#line 224
    size_left -= psize;
#line 225
    sz += 3;
#line 219
    p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 227
  VP8InitBitReader(dec->parts_ + last_part, part_start, size_left);
  }
#line 228
  if ((unsigned long )part_start < (unsigned long )buf_end) {
#line 228
    tmp___0 = 0;
  } else {
#line 228
    tmp___0 = 5;
  }
#line 228
  return ((VP8StatusCode )tmp___0);
}
}
#line 233 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static int ParseFilterHeader(VP8BitReader *br , VP8Decoder *dec ) 
{ 
  VP8FilterHeader *hdr ;
  uint32_t __cil_tmp4 ;
  uint32_t __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  int i ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp12 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 234
  hdr = & dec->filter_hdr_;
#line 235
  __cil_tmp4 = VP8GetValue(br, 1);
#line 235
  hdr->simple_ = (int )__cil_tmp4;
#line 236
  __cil_tmp5 = VP8GetValue(br, 6);
#line 236
  hdr->level_ = (int )__cil_tmp5;
#line 237
  __cil_tmp6 = VP8GetValue(br, 3);
#line 237
  hdr->sharpness_ = (int )__cil_tmp6;
#line 238
  __cil_tmp7 = VP8GetValue(br, 1);
#line 238
  hdr->use_lf_delta_ = (int )__cil_tmp7;
  }
#line 239
  if (hdr->use_lf_delta_) {
    {
#line 240
    __cil_tmp8 = VP8GetValue(br, 1);
    }
#line 240
    if (__cil_tmp8) {
#line 242
      i = 0;
      {
#line 242
      while (1) {
        while_continue: /* CIL Label */ ;

#line 242
        if (! (i < 4)) {
#line 242
          goto while_break;
        }
        {
#line 243
        __cil_tmp10 = VP8GetValue(br, 1);
        }
#line 243
        if (__cil_tmp10) {
          {
#line 244
          hdr->ref_lf_delta_[i] = VP8GetSignedValue(br, 6);
          }
        }
#line 242
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: 
#line 247
      i = 0;
      {
#line 247
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 247
        if (! (i < 4)) {
#line 247
          goto while_break___0;
        }
        {
#line 248
        __cil_tmp12 = VP8GetValue(br, 1);
        }
#line 248
        if (__cil_tmp12) {
          {
#line 249
          hdr->mode_lf_delta_[i] = VP8GetSignedValue(br, 6);
          }
        }
#line 247
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
    }
  }
#line 254
  if (hdr->level_ == 0) {
#line 254
    tmp___1 = 0;
  } else {
#line 254
    if (hdr->simple_) {
#line 254
      tmp___0 = 1;
    } else {
#line 254
      tmp___0 = 2;
    }
#line 254
    tmp___1 = tmp___0;
  }
#line 254
  dec->filter_type_ = tmp___1;
#line 255
  return (! br->eof_);
}
}
#line 259 "/root/patron-new/new_3/src/dec/vp8_dec.c"
int VP8GetHeaders(VP8Decoder *dec , VP8Io *io ) 
{ 
  uint8_t *buf ;
  size_t buf_size ;
  VP8FrameHeader *frm_hdr ;
  VP8PictureHeader *pic_hdr ;
  VP8BitReader *br ;
  VP8StatusCode status ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  uint32_t bits ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;

  {
#line 267
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 268
    return (0);
  }
  {
#line 270
  SetOk(dec);
  }
#line 271
  if ((unsigned long )io == (unsigned long )((void *)0)) {
    {
#line 272
    __cil_tmp9 = VP8SetError(dec, (VP8StatusCode )2, "null VP8Io passed to VP8GetHeaders()\001V");
    }
#line 272
    return (__cil_tmp9);
  }
#line 275
  buf = io->data;
#line 276
  buf_size = io->data_size;
#line 277
  if (buf_size < 4UL) {
    {
#line 278
    __cil_tmp10 = VP8SetError(dec, (VP8StatusCode )7, "Truncated header.");
    }
#line 278
    return (__cil_tmp10);
  }
#line 284
  bits = (uint32_t )(((int )*(buf + 0) | ((int )*(buf + 1) << 8)) | ((int )*(buf + 2) << 16));
#line 285
  frm_hdr = & dec->frm_hdr_;
#line 286
  frm_hdr->key_frame_ = (uint8_t )(! (bits & 1U));
#line 287
  frm_hdr->profile_ = (uint8_t )((bits >> 1) & 7U);
#line 288
  frm_hdr->show_ = (uint8_t )((bits >> 4) & 1U);
#line 289
  frm_hdr->partition_length_ = bits >> 5;
#line 290
  if ((int )frm_hdr->profile_ > 3) {
    {
#line 291
    __cil_tmp12 = VP8SetError(dec, (VP8StatusCode )3, "Incorrect keyframe parameters.");
    }
#line 291
    return (__cil_tmp12);
  }
#line 294
  if (! frm_hdr->show_) {
    {
#line 295
    __cil_tmp13 = VP8SetError(dec, (VP8StatusCode )4, "Frame not displayable.");
    }
#line 295
    return (__cil_tmp13);
  }
#line 298
  buf += 3;
#line 299
  buf_size -= 3UL;
#line 302
  pic_hdr = & dec->pic_hdr_;
#line 303
  if (frm_hdr->key_frame_) {
#line 305
    if (buf_size < 7UL) {
      {
#line 306
      __cil_tmp14 = VP8SetError(dec, (VP8StatusCode )7, "cannot parse picture header");
      }
#line 306
      return (__cil_tmp14);
    }
    {
#line 309
    __cil_tmp15 = VP8CheckSignature(buf, buf_size);
    }
#line 309
    if (! __cil_tmp15) {
      {
#line 310
      __cil_tmp16 = VP8SetError(dec, (VP8StatusCode )3, "Bad code word");
      }
#line 310
      return (__cil_tmp16);
    }
    {
#line 313
    pic_hdr->width_ = (uint16_t )((((int )*(buf + 4) << 8) | (int )*(buf + 3)) & 16383);
#line 314
    pic_hdr->xscale_ = (uint8_t )((int )*(buf + 4) >> 6);
#line 315
    pic_hdr->height_ = (uint16_t )((((int )*(buf + 6) << 8) | (int )*(buf + 5)) & 16383);
#line 316
    pic_hdr->yscale_ = (uint8_t )((int )*(buf + 6) >> 6);
#line 317
    buf += 7;
#line 318
    buf_size -= 7UL;
#line 320
    dec->mb_w_ = ((int )pic_hdr->width_ + 15) >> 4;
#line 321
    dec->mb_h_ = ((int )pic_hdr->height_ + 15) >> 4;
#line 324
    io->width = (int )pic_hdr->width_;
#line 325
    io->height = (int )pic_hdr->height_;
#line 329
    io->use_cropping = 0;
#line 330
    io->crop_top = 0;
#line 331
    io->crop_left = 0;
#line 332
    io->crop_right = io->width;
#line 333
    io->crop_bottom = io->height;
#line 334
    io->use_scaling = 0;
#line 335
    io->scaled_width = io->width;
#line 336
    io->scaled_height = io->height;
#line 338
    io->mb_w = io->width;
#line 339
    io->mb_h = io->height;
#line 341
    VP8ResetProba(& dec->proba_);
#line 342
    ResetSegmentHeader___0(& dec->segment_hdr_);
    }
  }
#line 347
  if ((unsigned long )frm_hdr->partition_length_ > buf_size) {
    {
#line 348
    __cil_tmp17 = VP8SetError(dec, (VP8StatusCode )7, "bad partition length");
    }
#line 348
    return (__cil_tmp17);
  }
  {
#line 352
  br = & dec->br_;
#line 353
  VP8InitBitReader(br, buf, (size_t )frm_hdr->partition_length_);
#line 354
  buf += frm_hdr->partition_length_;
#line 355
  buf_size -= (unsigned long )frm_hdr->partition_length_;
  }
#line 357
  if (frm_hdr->key_frame_) {
    {
#line 358
    __cil_tmp18 = VP8GetValue(br, 1);
#line 358
    pic_hdr->colorspace_ = (uint8_t )__cil_tmp18;
#line 359
    __cil_tmp19 = VP8GetValue(br, 1);
#line 359
    pic_hdr->clamp_type_ = (uint8_t )__cil_tmp19;
    }
  }
  {
#line 361
  __cil_tmp20 = ParseSegmentHeader(br, & dec->segment_hdr_, & dec->proba_);
  }
#line 361
  if (! __cil_tmp20) {
    {
#line 362
    __cil_tmp21 = VP8SetError(dec, (VP8StatusCode )3, "cannot parse segment header");
    }
#line 362
    return (__cil_tmp21);
  }
  {
#line 366
  __cil_tmp22 = ParseFilterHeader(br, dec);
  }
#line 366
  if (! __cil_tmp22) {
    {
#line 367
    __cil_tmp23 = VP8SetError(dec, (VP8StatusCode )3, "cannot parse filter header");
    }
#line 367
    return (__cil_tmp23);
  }
  {
#line 370
  status = ParsePartitions(dec, buf, buf_size);
  }
#line 371
  if ((unsigned int )status != 0U) {
    {
#line 372
    __cil_tmp25 = VP8SetError(dec, status, "cannot parse partitions");
    }
#line 372
    return (__cil_tmp25);
  }
  {
#line 376
  VP8ParseQuant(dec);
  }
#line 379
  if (! frm_hdr->key_frame_) {
    {
#line 380
    __cil_tmp26 = VP8SetError(dec, (VP8StatusCode )4, "Not a key frame.\220");
    }
#line 380
    return (__cil_tmp26);
  }
  {
#line 384
  VP8GetValue(br, 1);
#line 386
  VP8ParseProba(br, dec);
#line 389
  dec->ready_ = 1;
  }
#line 390
  return (1);
}
}
#line 396 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static uint8_t kCat3[4]  = {      (uint8_t )173,      (uint8_t )148,      (uint8_t )140,      (uint8_t )0};
#line 397 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static uint8_t kCat4[5]  = {      (uint8_t )176,      (uint8_t )155,      (uint8_t )140,      (uint8_t )135, 
        (uint8_t )0};
#line 398 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static uint8_t kCat5[6]  = {      (uint8_t )180,      (uint8_t )157,      (uint8_t )141,      (uint8_t )134, 
        (uint8_t )130,      (uint8_t )0};
#line 399 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static uint8_t kCat6[12]  = 
#line 399
  {      (uint8_t )254,      (uint8_t )254,      (uint8_t )243,      (uint8_t )230, 
        (uint8_t )196,      (uint8_t )177,      (uint8_t )153,      (uint8_t )140, 
        (uint8_t )133,      (uint8_t )130,      (uint8_t )129,      (uint8_t )0};
#line 401 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static uint8_t * const  kCat3456[4]  = {      (uint8_t */* const  */)(kCat3),      (uint8_t */* const  */)(kCat4),      (uint8_t */* const  */)(kCat5),      (uint8_t */* const  */)(kCat6)};
#line 402 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static uint8_t kZigzag___1[16]  = 
#line 402
  {      (uint8_t )0,      (uint8_t )1,      (uint8_t )4,      (uint8_t )8, 
        (uint8_t )5,      (uint8_t )2,      (uint8_t )3,      (uint8_t )6, 
        (uint8_t )9,      (uint8_t )12,      (uint8_t )13,      (uint8_t )10, 
        (uint8_t )7,      (uint8_t )11,      (uint8_t )14,      (uint8_t )15};
#line 407 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static int GetLargeValue(VP8BitReader *br , uint8_t *p ) 
{ 
  int v ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  uint8_t *tab ;
  int bit1 ;
  int __cil_tmp14 ;
  int bit0 ;
  int __cil_tmp16 ;
  int cat ;
  int __cil_tmp18 ;

  {
  {
#line 409
  __cil_tmp4 = VP8GetBit(br, (int )*(p + 3));
  }
#line 409
  if (! __cil_tmp4) {
    {
#line 410
    __cil_tmp5 = VP8GetBit(br, (int )*(p + 4));
    }
#line 410
    if (! __cil_tmp5) {
#line 411
      v = 2;
    } else {
      {
#line 413
      __cil_tmp6 = VP8GetBit(br, (int )*(p + 5));
#line 413
      v = 3 + __cil_tmp6;
      }
    }
  } else {
    {
#line 416
    __cil_tmp7 = VP8GetBit(br, (int )*(p + 6));
    }
#line 416
    if (! __cil_tmp7) {
      {
#line 417
      __cil_tmp8 = VP8GetBit(br, (int )*(p + 7));
      }
#line 417
      if (! __cil_tmp8) {
        {
#line 418
        __cil_tmp9 = VP8GetBit(br, 159);
#line 418
        v = 5 + __cil_tmp9;
        }
      } else {
        {
#line 420
        __cil_tmp10 = VP8GetBit(br, 165);
#line 420
        v = 7 + 2 * __cil_tmp10;
#line 421
        __cil_tmp11 = VP8GetBit(br, 145);
#line 421
        v += __cil_tmp11;
        }
      }
    } else {
      {
#line 425
      __cil_tmp14 = VP8GetBit(br, (int )*(p + 8));
#line 425
      bit1 = __cil_tmp14;
#line 426
      __cil_tmp16 = VP8GetBit(br, (int )*(p + (9 + bit1)));
#line 426
      bit0 = __cil_tmp16;
#line 427
      cat = 2 * bit1 + bit0;
#line 428
      v = 0;
#line 429
      tab = (uint8_t *)kCat3456[cat];
      }
      {
#line 429
      while (1) {
        while_continue: /* CIL Label */ ;

#line 429
        if (! *tab) {
#line 429
          goto while_break;
        }
        {
#line 430
        __cil_tmp18 = VP8GetBit(br, (int )*tab);
#line 430
        v += v + __cil_tmp18;
#line 429
        tab ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
#line 432
      v += 3 + (8 << cat);
    }
  }
#line 435
  return (v);
}
}
#line 439 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static int GetCoeffsFast(VP8BitReader *br , VP8BandProbas * const  *prob , int ctx ,
                         int *dq , int n , int16_t *out ) 
{ 
  uint8_t *p ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  VP8ProbaArray *p_ctx ;
  int v ;
  int __cil_tmp12 ;
  int __cil_tmp14 ;

  {
#line 442
  p = (*(prob + n))->probas_[ctx];
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;

#line 443
    if (! (n < 16)) {
#line 443
      goto while_break;
    }
    {
#line 444
    __cil_tmp8 = VP8GetBit(br, (int )*(p + 0));
    }
#line 444
    if (! __cil_tmp8) {
#line 445
      return (n);
    }
    {
#line 447
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 447
      __cil_tmp9 = VP8GetBit(br, (int )*(p + 1));
      }
#line 447
      if (! (! __cil_tmp9)) {
#line 447
        goto while_break___0;
      }
#line 448
      p = (*(prob + n))->probas_[0];
#line 449
      if (n == 16) {
#line 449
        return (16);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 452
    p_ctx = & (*(prob + (n + 1)))->probas_[0];
#line 454
    __cil_tmp12 = VP8GetBit(br, (int )*(p + 2));
    }
#line 454
    if (! __cil_tmp12) {
#line 455
      v = 1;
#line 456
      p = *(p_ctx + 1);
    } else {
      {
#line 458
      v = GetLargeValue(br, p);
#line 459
      p = *(p_ctx + 2);
      }
    }
    {
#line 461
    __cil_tmp14 = VP8GetSigned(br, v);
#line 461
    *(out + (int )kZigzag___1[n]) = (int16_t )(__cil_tmp14 * *(dq + (n > 0)));
#line 443
    n ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 464
  return (16);
}
}
#line 469 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static int GetCoeffsAlt(VP8BitReader *br , VP8BandProbas * const  *prob , int ctx ,
                        int *dq , int n , int16_t *out ) 
{ 
  uint8_t *p ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  VP8ProbaArray *p_ctx ;
  int v ;
  int __cil_tmp12 ;
  int __cil_tmp14 ;

  {
#line 472
  p = (*(prob + n))->probas_[ctx];
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;

#line 473
    if (! (n < 16)) {
#line 473
      goto while_break;
    }
    {
#line 474
    __cil_tmp8 = VP8GetBitAlt(br, (int )*(p + 0));
    }
#line 474
    if (! __cil_tmp8) {
#line 475
      return (n);
    }
    {
#line 477
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 477
      __cil_tmp9 = VP8GetBitAlt(br, (int )*(p + 1));
      }
#line 477
      if (! (! __cil_tmp9)) {
#line 477
        goto while_break___0;
      }
#line 478
      p = (*(prob + n))->probas_[0];
#line 479
      if (n == 16) {
#line 479
        return (16);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 482
    p_ctx = & (*(prob + (n + 1)))->probas_[0];
#line 484
    __cil_tmp12 = VP8GetBitAlt(br, (int )*(p + 2));
    }
#line 484
    if (! __cil_tmp12) {
#line 485
      v = 1;
#line 486
      p = *(p_ctx + 1);
    } else {
      {
#line 488
      v = GetLargeValue(br, p);
#line 489
      p = *(p_ctx + 2);
      }
    }
    {
#line 491
    __cil_tmp14 = VP8GetSigned(br, v);
#line 491
    *(out + (int )kZigzag___1[n]) = (int16_t )(__cil_tmp14 * *(dq + (n > 0)));
#line 473
    n ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 494
  return (16);
}
}
#line 497
static void InitGetCoeffs_body(void) ;
#line 499 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static int (*InitGetCoeffs_body_last_cpuinfo_used)(CPUFeature  )  ;
#line 500 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static pthread_mutex_t InitGetCoeffs_body_lock  ;
#line 497 "/root/patron-new/new_3/src/dec/vp8_dec.c"
void InitGetCoeffs(void) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 497
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 497
    InitGetCoeffs_body_last_cpuinfo_used = (int (*)(CPUFeature  ))(& InitGetCoeffs_body_last_cpuinfo_used);
#line 497
    InitGetCoeffs_body_lock.__data.__lock = 0;
#line 497
    InitGetCoeffs_body_lock.__data.__count = 0U;
#line 497
    InitGetCoeffs_body_lock.__data.__owner = 0;
#line 497
    InitGetCoeffs_body_lock.__data.__nusers = 0U;
#line 497
    InitGetCoeffs_body_lock.__data.__kind = 0;
#line 497
    InitGetCoeffs_body_lock.__data.__spins = (short)0;
#line 497
    InitGetCoeffs_body_lock.__data.__elision = (short)0;
#line 497
    InitGetCoeffs_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 497
    InitGetCoeffs_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 497
    __cil_tmp3 = pthread_mutex_lock(& InitGetCoeffs_body_lock);
    }
#line 497
    if (__cil_tmp3) {
#line 497
      goto while_break;
    }
#line 497
    if ((unsigned long )InitGetCoeffs_body_last_cpuinfo_used != (unsigned long )VP8GetCPUInfo) {
      {
#line 497
      InitGetCoeffs_body();
      }
    }
    {
#line 497
    InitGetCoeffs_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 497
    pthread_mutex_unlock(& InitGetCoeffs_body_lock);
    }
#line 497
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 501
  return;
}
}
#line 497 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static void InitGetCoeffs_body(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 498
  __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )2);
  }
#line 498
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
#line 498
    if (__cil_tmp1) {
#line 499
      GetCoeffs = (int (*)(VP8BitReader * const   , VP8BandProbas * const  * , int  ,
                           int * , int  , int16_t * ))(& GetCoeffsAlt);
    } else {
#line 501
      GetCoeffs = (int (*)(VP8BitReader * const   , VP8BandProbas * const  * , int  ,
                           int * , int  , int16_t * ))(& GetCoeffsFast);
    }
  } else {
#line 501
    GetCoeffs = (int (*)(VP8BitReader * const   , VP8BandProbas * const  * , int  ,
                         int * , int  , int16_t * ))(& GetCoeffsFast);
  }
#line 503
  return;
}
}
#line 505 "/root/patron-new/new_3/src/dec/vp8_dec.c"
__inline static uint32_t NzCodeBits(uint32_t nz_coeffs , int nz , int dc_nz ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
#line 506
  nz_coeffs <<= 2;
#line 507
  if (nz > 3) {
#line 507
    tmp___1 = 3;
  } else {
#line 507
    if (nz > 1) {
#line 507
      tmp___0 = 2;
    } else {
#line 507
      tmp___0 = dc_nz;
    }
#line 507
    tmp___1 = tmp___0;
  }
#line 507
  nz_coeffs |= (unsigned int )tmp___1;
#line 508
  return (nz_coeffs);
}
}
#line 511 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static int ParseResiduals(VP8Decoder *dec , VP8MB *mb , VP8BitReader *token_br ) 
{ 
  VP8BandProbas *(*bands)[17] ;
  VP8BandProbas * const  *ac_proba ;
  VP8MBData *block ;
  VP8QuantMatrix *q ;
  int16_t *dst ;
  VP8MB *left_mb ;
  uint8_t tnz ;
  uint8_t lnz ;
  uint32_t non_zero_y ;
  uint32_t non_zero_uv ;
  int x ;
  int y ;
  int ch ;
  uint32_t out_t_nz ;
  uint32_t out_l_nz ;
  int first ;
  int16_t dc[16] ;
  unsigned int tmp___0 ;
  int ctx ;
  int nz ;
  int __cil_tmp24 ;
  int i ;
  int dc0 ;
  int l ;
  uint32_t nz_coeffs ;
  int ctx___0 ;
  int nz___0 ;
  int __cil_tmp31 ;
  uint32_t nz_coeffs___0 ;
  int l___0 ;
  int ctx___1 ;
  int nz___1 ;
  int __cil_tmp37 ;
  int tmp___1 ;

  {
  {
#line 513
  bands = dec->proba_.bands_ptr_;
#line 515
  block = dec->mb_data_ + dec->mb_x_;
#line 516
  q = & dec->dqm_[block->segment_];
#line 517
  dst = block->coeffs_;
#line 518
  left_mb = dec->mb_info_ - 1;
#line 520
  non_zero_y = (uint32_t )0;
#line 521
  non_zero_uv = (uint32_t )0;
#line 526
  memset((void *)dst, 0, 384UL * sizeof(*dst));
  }
#line 527
  if (! block->is_i4x4_) {
#line 528
    dc[0] = (int16_t )0;
#line 528
    tmp___0 = 1U;
    {
#line 528
    while (1) {
      while_continue: /* CIL Label */ ;

#line 528
      if (tmp___0 >= 16U) {
#line 528
        goto while_break;
      }
#line 528
      dc[tmp___0] = (int16_t )0;
#line 528
      tmp___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break: 
    {
#line 529
    ctx = (int )mb->nz_dc_ + (int )left_mb->nz_dc_;
#line 530
    __cil_tmp24 = (*GetCoeffs)((VP8BitReader */* const  */)token_br, (VP8BandProbas * const  *)((VP8BandProbas **/* const  */)(*(bands + 1))),
                               ctx, (int *)((int const   *)(q->y2_mat_)), 0, dc);
#line 530
    nz = __cil_tmp24;
#line 531
    left_mb->nz_dc_ = (uint8_t )(nz > 0);
#line 531
    mb->nz_dc_ = left_mb->nz_dc_;
    }
#line 532
    if (nz > 1) {
      {
#line 533
      (*VP8TransformWHT)(dc, dst);
      }
    } else {
#line 536
      dc0 = ((int )dc[0] + 3) >> 3;
#line 537
      i = 0;
      {
#line 537
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 537
        if (! (i < 256)) {
#line 537
          goto while_break___0;
        }
#line 537
        *(dst + i) = (int16_t )dc0;
#line 537
        i += 16;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___0: ;
    }
#line 539
    first = 1;
#line 540
    ac_proba = (VP8BandProbas * const  *)(*(bands + 0));
  } else {
#line 542
    first = 0;
#line 543
    ac_proba = (VP8BandProbas * const  *)(*(bands + 3));
  }
#line 546
  tnz = (uint8_t )((int )mb->nz_ & 15);
#line 547
  lnz = (uint8_t )((int )left_mb->nz_ & 15);
#line 548
  y = 0;
  {
#line 548
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 548
    if (! (y < 4)) {
#line 548
      goto while_break___1;
    }
#line 549
    l = (int )lnz & 1;
#line 550
    nz_coeffs = (uint32_t )0;
#line 551
    x = 0;
    {
#line 551
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 551
      if (! (x < 4)) {
#line 551
        goto while_break___2;
      }
      {
#line 552
      ctx___0 = l + ((int )tnz & 1);
#line 553
      __cil_tmp31 = (*GetCoeffs)((VP8BitReader */* const  */)token_br, ac_proba, ctx___0,
                                 (int *)((int const   *)(q->y1_mat_)), first, dst);
#line 553
      nz___0 = __cil_tmp31;
#line 554
      l = nz___0 > first;
#line 555
      tnz = (uint8_t )(((int )tnz >> 1) | (l << 7));
#line 556
      nz_coeffs = NzCodeBits(nz_coeffs, nz___0, (int )*(dst + 0) != 0);
#line 557
      dst += 16;
#line 551
      x ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: 
#line 559
    tnz = (uint8_t )((int )tnz >> 4);
#line 560
    lnz = (uint8_t )(((int )lnz >> 1) | (l << 7));
#line 561
    non_zero_y = (non_zero_y << 8) | nz_coeffs;
#line 548
    y ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: 
#line 563
  out_t_nz = (uint32_t )tnz;
#line 564
  out_l_nz = (uint32_t )((int )lnz >> 4);
#line 566
  ch = 0;
  {
#line 566
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 566
    if (! (ch < 4)) {
#line 566
      goto while_break___3;
    }
#line 567
    nz_coeffs___0 = (uint32_t )0;
#line 568
    tnz = (uint8_t )((int )mb->nz_ >> (4 + ch));
#line 569
    lnz = (uint8_t )((int )left_mb->nz_ >> (4 + ch));
#line 570
    y = 0;
    {
#line 570
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 570
      if (! (y < 2)) {
#line 570
        goto while_break___4;
      }
#line 571
      l___0 = (int )lnz & 1;
#line 572
      x = 0;
      {
#line 572
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 572
        if (! (x < 2)) {
#line 572
          goto while_break___5;
        }
        {
#line 573
        ctx___1 = l___0 + ((int )tnz & 1);
#line 574
        __cil_tmp37 = (*GetCoeffs)((VP8BitReader */* const  */)token_br, (VP8BandProbas * const  *)((VP8BandProbas **/* const  */)(*(bands + 2))),
                                   ctx___1, (int *)((int const   *)(q->uv_mat_)),
                                   0, dst);
#line 574
        nz___1 = __cil_tmp37;
#line 575
        l___0 = nz___1 > 0;
#line 576
        tnz = (uint8_t )(((int )tnz >> 1) | (l___0 << 3));
#line 577
        nz_coeffs___0 = NzCodeBits(nz_coeffs___0, nz___1, (int )*(dst + 0) != 0);
#line 578
        dst += 16;
#line 572
        x ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___5: 
#line 580
      tnz = (uint8_t )((int )tnz >> 2);
#line 581
      lnz = (uint8_t )(((int )lnz >> 1) | (l___0 << 5));
#line 570
      y ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___4: 
#line 584
    non_zero_uv |= nz_coeffs___0 << 4 * ch;
#line 585
    out_t_nz |= (unsigned int )(((int )tnz << 4) << ch);
#line 586
    out_l_nz |= (unsigned int )(((int )lnz & 240) << ch);
#line 566
    ch += 2;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___3: 
#line 588
  mb->nz_ = (uint8_t )out_t_nz;
#line 589
  left_mb->nz_ = (uint8_t )out_l_nz;
#line 591
  block->non_zero_y_ = non_zero_y;
#line 592
  block->non_zero_uv_ = non_zero_uv;
#line 597
  if (non_zero_uv & 43690U) {
#line 597
    tmp___1 = 0;
  } else {
#line 597
    tmp___1 = q->dither_;
  }
#line 597
  block->dither_ = (uint8_t )tmp___1;
#line 599
  return (! (non_zero_y | non_zero_uv));
}
}
#line 605 "/root/patron-new/new_3/src/dec/vp8_dec.c"
int VP8DecodeMB(VP8Decoder *dec , VP8BitReader *token_br ) 
{ 
  VP8MB *left ;
  VP8MB *mb ;
  VP8MBData *block ;
  int skip ;
  int tmp___0 ;
  VP8FInfo *finfo ;

  {
#line 606
  left = dec->mb_info_ - 1;
#line 607
  mb = dec->mb_info_ + dec->mb_x_;
#line 608
  block = dec->mb_data_ + dec->mb_x_;
#line 609
  if (dec->use_skip_proba_) {
#line 609
    tmp___0 = (int )block->skip_;
  } else {
#line 609
    tmp___0 = 0;
  }
#line 609
  skip = tmp___0;
#line 611
  if (! skip) {
    {
#line 612
    skip = ParseResiduals(dec, mb, token_br);
    }
  } else {
#line 614
    mb->nz_ = (uint8_t )0;
#line 614
    left->nz_ = mb->nz_;
#line 615
    if (! block->is_i4x4_) {
#line 616
      mb->nz_dc_ = (uint8_t )0;
#line 616
      left->nz_dc_ = mb->nz_dc_;
    }
#line 618
    block->non_zero_y_ = (uint32_t )0;
#line 619
    block->non_zero_uv_ = (uint32_t )0;
#line 620
    block->dither_ = (uint8_t )0;
  }
#line 623
  if (dec->filter_type_ > 0) {
#line 624
    finfo = dec->f_info_ + dec->mb_x_;
#line 625
    *finfo = dec->fstrengths_[block->segment_][block->is_i4x4_];
#line 626
    finfo->f_inner_ = (uint8_t )((int )finfo->f_inner_ | ! skip);
  }
#line 629
  return (! token_br->eof_);
}
}
#line 632 "/root/patron-new/new_3/src/dec/vp8_dec.c"
void VP8InitScanline(VP8Decoder *dec ) 
{ 
  VP8MB *left ;

  {
  {
#line 633
  left = dec->mb_info_ - 1;
#line 634
  left->nz_ = (uint8_t )0;
#line 635
  left->nz_dc_ = (uint8_t )0;
#line 636
  memset((void *)(dec->intra_l_), 0, sizeof(dec->intra_l_));
#line 637
  dec->mb_x_ = 0;
  }
#line 639
  return;
}
}
#line 640 "/root/patron-new/new_3/src/dec/vp8_dec.c"
static int ParseFrame(VP8Decoder *dec , VP8Io *io ) 
{ 
  VP8BitReader *token_br ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  WebPWorkerInterface *__cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 641
  dec->mb_y_ = 0;
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;

#line 641
    if (! (dec->mb_y_ < dec->br_mb_y_)) {
#line 641
      goto while_break;
    }
    {
#line 643
    token_br = & dec->parts_[(unsigned int )dec->mb_y_ & dec->num_parts_minus_one_];
#line 645
    __cil_tmp4 = VP8ParseIntraModeRow(& dec->br_, dec);
    }
#line 645
    if (! __cil_tmp4) {
      {
#line 646
      __cil_tmp5 = VP8SetError(dec, (VP8StatusCode )7, "Premature end-of-partition0 encountered.\220");
      }
#line 646
      return (__cil_tmp5);
    }
    {
#line 649
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 649
      if (! (dec->mb_x_ < dec->mb_w_)) {
#line 649
        goto while_break___0;
      }
      {
#line 650
      __cil_tmp6 = VP8DecodeMB(dec, token_br);
      }
#line 650
      if (! __cil_tmp6) {
        {
#line 651
        __cil_tmp7 = VP8SetError(dec, (VP8StatusCode )7, "Premature end-of-file encountered.");
        }
#line 651
        return (__cil_tmp7);
      }
#line 649
      (dec->mb_x_) ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 655
    VP8InitScanline(dec);
#line 658
    __cil_tmp8 = VP8ProcessRow(dec, io);
    }
#line 658
    if (! __cil_tmp8) {
      {
#line 659
      __cil_tmp9 = VP8SetError(dec, (VP8StatusCode )6, "Output aborted.");
      }
#line 659
      return (__cil_tmp9);
    }
#line 641
    (dec->mb_y_) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 662
  if (dec->mt_method_ > 0) {
    {
#line 663
    __cil_tmp11 = (*(__cil_tmp10->Sync))((WebPWorker */* const  */)(& dec->worker_));
    }
#line 663
    if (! __cil_tmp11) {
#line 663
      return (0);
    }
  }
#line 666
  return (1);
}
}
#line 670 "/root/patron-new/new_3/src/dec/vp8_dec.c"
int VP8Decode(VP8Decoder *dec , VP8Io *io ) 
{ 
  int ok ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  VP8StatusCode __cil_tmp6 ;
  int __cil_tmp9 ;

  {
#line 671
  ok = 0;
#line 672
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 673
    return (0);
  }
#line 675
  if ((unsigned long )io == (unsigned long )((void *)0)) {
    {
#line 676
    __cil_tmp4 = VP8SetError(dec, (VP8StatusCode )2, "NULL VP8Io parameter in VP8Decode().");
    }
#line 676
    return (__cil_tmp4);
  }
#line 680
  if (! dec->ready_) {
    {
#line 681
    __cil_tmp5 = VP8GetHeaders(dec, io);
    }
#line 681
    if (! __cil_tmp5) {
#line 682
      return (0);
    }
  }
  {
#line 688
  __cil_tmp6 = VP8EnterCritical(dec, io);
#line 688
  ok = (unsigned int )__cil_tmp6 == 0U;
  }
#line 689
  if (ok) {
#line 691
    if (ok) {
      {
#line 691
      ok = VP8InitFrame(dec, io);
      }
    }
#line 694
    if (ok) {
      {
#line 694
      ok = ParseFrame(dec, io);
      }
    }
    {
#line 697
    __cil_tmp9 = VP8ExitCritical(dec, io);
#line 697
    ok &= __cil_tmp9;
    }
  }
#line 700
  if (! ok) {
    {
#line 701
    VP8Clear(dec);
    }
#line 702
    return (0);
  }
#line 705
  dec->ready_ = 0;
#line 706
  return (ok);
}
}
#line 709 "/root/patron-new/new_3/src/dec/vp8_dec.c"
void VP8Clear(VP8Decoder *dec ) 
{ 
  WebPWorkerInterface *__cil_tmp2 ;

  {
#line 710
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 711
    return;
  }
  {
#line 713
  (*(__cil_tmp2->End))((WebPWorker */* const  */)(& dec->worker_));
#line 714
  WebPDeallocateAlphaMemory(dec);
#line 715
  WebPSafeFree(dec->mem_);
#line 716
  dec->mem_ = (void *)0;
#line 717
  dec->mem_size_ = (size_t )0;
#line 718
  memset((void *)(& dec->br_), 0, sizeof(dec->br_));
#line 719
  dec->ready_ = 0;
  }
#line 721
  return;
}
}
#line 27 "/root/patron-new/new_3/src/dec/tree_dec.c"
static int8_t kYModesIntra4[18]  = 
#line 27 "/root/patron-new/new_3/src/dec/tree_dec.c"
  {      (int8_t )0,      (int8_t )1,      (int8_t )-1,      (int8_t )2, 
        (int8_t )-2,      (int8_t )3,      (int8_t )4,      (int8_t )6, 
        (int8_t )-3,      (int8_t )5,      (int8_t )-4,      (int8_t )-5, 
        (int8_t )-6,      (int8_t )7,      (int8_t )-7,      (int8_t )8, 
        (int8_t )-8,      (int8_t )-9};
#line 45 "/root/patron-new/new_3/src/dec/tree_dec.c"
static uint8_t CoeffsProba0[4][8][3][11]  = { { { {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )253,            (uint8_t )136,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )228,            (uint8_t )219,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )189,            (uint8_t )129,            (uint8_t )242,            (uint8_t )255, 
                    (uint8_t )227,            (uint8_t )213,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )106,            (uint8_t )126,            (uint8_t )227,            (uint8_t )252, 
                    (uint8_t )214,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )98,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )226,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )181,            (uint8_t )133,            (uint8_t )238,            (uint8_t )254, 
                    (uint8_t )221,            (uint8_t )234,            (uint8_t )255,            (uint8_t )154, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )78,            (uint8_t )134,            (uint8_t )202,            (uint8_t )247, 
                    (uint8_t )198,            (uint8_t )180,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )185,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )243,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )184,            (uint8_t )150,            (uint8_t )247,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )224,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )77,            (uint8_t )110,            (uint8_t )216,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )230,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )101,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )241,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )170,            (uint8_t )139,            (uint8_t )241,            (uint8_t )252, 
                    (uint8_t )236,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )37,            (uint8_t )116,            (uint8_t )196,            (uint8_t )243, 
                    (uint8_t )228,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )204,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )245,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )207,            (uint8_t )160,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )238,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )102,            (uint8_t )103,            (uint8_t )231,            (uint8_t )255, 
                    (uint8_t )211,            (uint8_t )171,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )152,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )240,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )177,            (uint8_t )135,            (uint8_t )243,            (uint8_t )255, 
                    (uint8_t )234,            (uint8_t )225,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )80,            (uint8_t )129,            (uint8_t )211,            (uint8_t )255, 
                    (uint8_t )194,            (uint8_t )224,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )246,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )198,            (uint8_t )35,            (uint8_t )237,            (uint8_t )223, 
                    (uint8_t )193,            (uint8_t )187,            (uint8_t )162,            (uint8_t )160, 
                    (uint8_t )145,            (uint8_t )155,            (uint8_t )62}, 
       {            (uint8_t )131,            (uint8_t )45,            (uint8_t )198,            (uint8_t )221, 
                    (uint8_t )172,            (uint8_t )176,            (uint8_t )220,            (uint8_t )157, 
                    (uint8_t )252,            (uint8_t )221,            (uint8_t )1}, 
       {            (uint8_t )68,            (uint8_t )47,            (uint8_t )146,            (uint8_t )208, 
                    (uint8_t )149,            (uint8_t )167,            (uint8_t )221,            (uint8_t )162, 
                    (uint8_t )255,            (uint8_t )223,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )149,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )221,            (uint8_t )224,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )184,            (uint8_t )141,            (uint8_t )234,            (uint8_t )253, 
                    (uint8_t )222,            (uint8_t )220,            (uint8_t )255,            (uint8_t )199, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )81,            (uint8_t )99,            (uint8_t )181,            (uint8_t )242, 
                    (uint8_t )176,            (uint8_t )190,            (uint8_t )249,            (uint8_t )202, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )129,            (uint8_t )232,            (uint8_t )253, 
                    (uint8_t )214,            (uint8_t )197,            (uint8_t )242,            (uint8_t )196, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )99,            (uint8_t )121,            (uint8_t )210,            (uint8_t )250, 
                    (uint8_t )201,            (uint8_t )198,            (uint8_t )255,            (uint8_t )202, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )23,            (uint8_t )91,            (uint8_t )163,            (uint8_t )242, 
                    (uint8_t )170,            (uint8_t )187,            (uint8_t )247,            (uint8_t )210, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )200,            (uint8_t )246,            (uint8_t )255, 
                    (uint8_t )234,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )109,            (uint8_t )178,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )231,            (uint8_t )245,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )44,            (uint8_t )130,            (uint8_t )201,            (uint8_t )253, 
                    (uint8_t )205,            (uint8_t )192,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )132,            (uint8_t )239,            (uint8_t )251, 
                    (uint8_t )219,            (uint8_t )209,            (uint8_t )255,            (uint8_t )165, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )94,            (uint8_t )136,            (uint8_t )225,            (uint8_t )251, 
                    (uint8_t )218,            (uint8_t )190,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )22,            (uint8_t )100,            (uint8_t )174,            (uint8_t )245, 
                    (uint8_t )186,            (uint8_t )161,            (uint8_t )255,            (uint8_t )199, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )182,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )232,            (uint8_t )235,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )124,            (uint8_t )143,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )227,            (uint8_t )234,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )35,            (uint8_t )77,            (uint8_t )181,            (uint8_t )251, 
                    (uint8_t )193,            (uint8_t )211,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )157,            (uint8_t )247,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )231,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )121,            (uint8_t )141,            (uint8_t )235,            (uint8_t )255, 
                    (uint8_t )225,            (uint8_t )227,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )45,            (uint8_t )99,            (uint8_t )188,            (uint8_t )251, 
                    (uint8_t )195,            (uint8_t )217,            (uint8_t )255,            (uint8_t )224, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )213,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )203,            (uint8_t )1,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )137,            (uint8_t )1,            (uint8_t )177,            (uint8_t )255, 
                    (uint8_t )224,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )253,            (uint8_t )9,            (uint8_t )248,            (uint8_t )251, 
                    (uint8_t )207,            (uint8_t )208,            (uint8_t )255,            (uint8_t )192, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )175,            (uint8_t )13,            (uint8_t )224,            (uint8_t )243, 
                    (uint8_t )193,            (uint8_t )185,            (uint8_t )249,            (uint8_t )198, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )73,            (uint8_t )17,            (uint8_t )171,            (uint8_t )221, 
                    (uint8_t )161,            (uint8_t )179,            (uint8_t )236,            (uint8_t )167, 
                    (uint8_t )255,            (uint8_t )234,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )95,            (uint8_t )247,            (uint8_t )253, 
                    (uint8_t )212,            (uint8_t )183,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )239,            (uint8_t )90,            (uint8_t )244,            (uint8_t )250, 
                    (uint8_t )211,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )155,            (uint8_t )77,            (uint8_t )195,            (uint8_t )248, 
                    (uint8_t )188,            (uint8_t )195,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )24,            (uint8_t )239,            (uint8_t )251, 
                    (uint8_t )218,            (uint8_t )219,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )201,            (uint8_t )51,            (uint8_t )219,            (uint8_t )255, 
                    (uint8_t )196,            (uint8_t )186,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )69,            (uint8_t )46,            (uint8_t )190,            (uint8_t )239, 
                    (uint8_t )201,            (uint8_t )218,            (uint8_t )255,            (uint8_t )228, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )191,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )223,            (uint8_t )165,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )213,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )141,            (uint8_t )124,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )16,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )190,            (uint8_t )36,            (uint8_t )230,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )149,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )226,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )247,            (uint8_t )192,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )240,            (uint8_t )128,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )134,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )213,            (uint8_t )62,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )55,            (uint8_t )93,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )202,            (uint8_t )24,            (uint8_t )213,            (uint8_t )235, 
                    (uint8_t )186,            (uint8_t )191,            (uint8_t )220,            (uint8_t )160, 
                    (uint8_t )240,            (uint8_t )175,            (uint8_t )255}, 
       {            (uint8_t )126,            (uint8_t )38,            (uint8_t )182,            (uint8_t )232, 
                    (uint8_t )169,            (uint8_t )184,            (uint8_t )228,            (uint8_t )174, 
                    (uint8_t )255,            (uint8_t )187,            (uint8_t )128}, 
       {            (uint8_t )61,            (uint8_t )46,            (uint8_t )138,            (uint8_t )219, 
                    (uint8_t )151,            (uint8_t )178,            (uint8_t )240,            (uint8_t )170, 
                    (uint8_t )255,            (uint8_t )216,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )112,            (uint8_t )230,            (uint8_t )250, 
                    (uint8_t )199,            (uint8_t )191,            (uint8_t )247,            (uint8_t )159, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )166,            (uint8_t )109,            (uint8_t )228,            (uint8_t )252, 
                    (uint8_t )211,            (uint8_t )215,            (uint8_t )255,            (uint8_t )174, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )39,            (uint8_t )77,            (uint8_t )162,            (uint8_t )232, 
                    (uint8_t )172,            (uint8_t )180,            (uint8_t )245,            (uint8_t )178, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )52,            (uint8_t )220,            (uint8_t )246, 
                    (uint8_t )198,            (uint8_t )199,            (uint8_t )249,            (uint8_t )220, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )124,            (uint8_t )74,            (uint8_t )191,            (uint8_t )243, 
                    (uint8_t )183,            (uint8_t )193,            (uint8_t )250,            (uint8_t )221, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )24,            (uint8_t )71,            (uint8_t )130,            (uint8_t )219, 
                    (uint8_t )154,            (uint8_t )170,            (uint8_t )243,            (uint8_t )182, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )182,            (uint8_t )225,            (uint8_t )249, 
                    (uint8_t )219,            (uint8_t )240,            (uint8_t )255,            (uint8_t )224, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )149,            (uint8_t )150,            (uint8_t )226,            (uint8_t )252, 
                    (uint8_t )216,            (uint8_t )205,            (uint8_t )255,            (uint8_t )171, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )28,            (uint8_t )108,            (uint8_t )170,            (uint8_t )242, 
                    (uint8_t )183,            (uint8_t )194,            (uint8_t )254,            (uint8_t )223, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )81,            (uint8_t )230,            (uint8_t )252, 
                    (uint8_t )204,            (uint8_t )203,            (uint8_t )255,            (uint8_t )192, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )123,            (uint8_t )102,            (uint8_t )209,            (uint8_t )247, 
                    (uint8_t )188,            (uint8_t )196,            (uint8_t )255,            (uint8_t )233, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )20,            (uint8_t )95,            (uint8_t )153,            (uint8_t )243, 
                    (uint8_t )164,            (uint8_t )173,            (uint8_t )255,            (uint8_t )203, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )222,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )216,            (uint8_t )213,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )168,            (uint8_t )175,            (uint8_t )246,            (uint8_t )252, 
                    (uint8_t )235,            (uint8_t )205,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )47,            (uint8_t )116,            (uint8_t )215,            (uint8_t )255, 
                    (uint8_t )211,            (uint8_t )212,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )121,            (uint8_t )236,            (uint8_t )253, 
                    (uint8_t )212,            (uint8_t )214,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )141,            (uint8_t )84,            (uint8_t )213,            (uint8_t )252, 
                    (uint8_t )201,            (uint8_t )202,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )42,            (uint8_t )80,            (uint8_t )160,            (uint8_t )240, 
                    (uint8_t )162,            (uint8_t )185,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )244,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )238,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}};
#line 181 "/root/patron-new/new_3/src/dec/tree_dec.c"
static uint8_t kBModesProba___0[10][10][9]  = 
#line 181
  { { {          (uint8_t )231,          (uint8_t )120,          (uint8_t )48,          (uint8_t )89, 
                (uint8_t )115,          (uint8_t )113,          (uint8_t )120,          (uint8_t )152, 
                (uint8_t )112}, 
     {          (uint8_t )152,          (uint8_t )179,          (uint8_t )64,          (uint8_t )126, 
                (uint8_t )170,          (uint8_t )118,          (uint8_t )46,          (uint8_t )70, 
                (uint8_t )95}, 
     {          (uint8_t )175,          (uint8_t )69,          (uint8_t )143,          (uint8_t )80, 
                (uint8_t )85,          (uint8_t )82,          (uint8_t )72,          (uint8_t )155, 
                (uint8_t )103}, 
     {          (uint8_t )56,          (uint8_t )58,          (uint8_t )10,          (uint8_t )171, 
                (uint8_t )218,          (uint8_t )189,          (uint8_t )17,          (uint8_t )13, 
                (uint8_t )152}, 
     {          (uint8_t )114,          (uint8_t )26,          (uint8_t )17,          (uint8_t )163, 
                (uint8_t )44,          (uint8_t )195,          (uint8_t )21,          (uint8_t )10, 
                (uint8_t )173}, 
     {          (uint8_t )121,          (uint8_t )24,          (uint8_t )80,          (uint8_t )195, 
                (uint8_t )26,          (uint8_t )62,          (uint8_t )44,          (uint8_t )64, 
                (uint8_t )85}, 
     {          (uint8_t )144,          (uint8_t )71,          (uint8_t )10,          (uint8_t )38, 
                (uint8_t )171,          (uint8_t )213,          (uint8_t )144,          (uint8_t )34, 
                (uint8_t )26}, 
     {          (uint8_t )170,          (uint8_t )46,          (uint8_t )55,          (uint8_t )19, 
                (uint8_t )136,          (uint8_t )160,          (uint8_t )33,          (uint8_t )206, 
                (uint8_t )71}, 
     {          (uint8_t )63,          (uint8_t )20,          (uint8_t )8,          (uint8_t )114, 
                (uint8_t )114,          (uint8_t )208,          (uint8_t )12,          (uint8_t )9, 
                (uint8_t )226}, 
     {          (uint8_t )81,          (uint8_t )40,          (uint8_t )11,          (uint8_t )96, 
                (uint8_t )182,          (uint8_t )84,          (uint8_t )29,          (uint8_t )16, 
                (uint8_t )36}}, 
   { {          (uint8_t )134,          (uint8_t )183,          (uint8_t )89,          (uint8_t )137, 
                (uint8_t )98,          (uint8_t )101,          (uint8_t )106,          (uint8_t )165, 
                (uint8_t )148}, 
     {          (uint8_t )72,          (uint8_t )187,          (uint8_t )100,          (uint8_t )130, 
                (uint8_t )157,          (uint8_t )111,          (uint8_t )32,          (uint8_t )75, 
                (uint8_t )80}, 
     {          (uint8_t )66,          (uint8_t )102,          (uint8_t )167,          (uint8_t )99, 
                (uint8_t )74,          (uint8_t )62,          (uint8_t )40,          (uint8_t )234, 
                (uint8_t )128}, 
     {          (uint8_t )41,          (uint8_t )53,          (uint8_t )9,          (uint8_t )178, 
                (uint8_t )241,          (uint8_t )141,          (uint8_t )26,          (uint8_t )8, 
                (uint8_t )107}, 
     {          (uint8_t )74,          (uint8_t )43,          (uint8_t )26,          (uint8_t )146, 
                (uint8_t )73,          (uint8_t )166,          (uint8_t )49,          (uint8_t )23, 
                (uint8_t )157}, 
     {          (uint8_t )65,          (uint8_t )38,          (uint8_t )105,          (uint8_t )160, 
                (uint8_t )51,          (uint8_t )52,          (uint8_t )31,          (uint8_t )115, 
                (uint8_t )128}, 
     {          (uint8_t )104,          (uint8_t )79,          (uint8_t )12,          (uint8_t )27, 
                (uint8_t )217,          (uint8_t )255,          (uint8_t )87,          (uint8_t )17, 
                (uint8_t )7}, 
     {          (uint8_t )87,          (uint8_t )68,          (uint8_t )71,          (uint8_t )44, 
                (uint8_t )114,          (uint8_t )51,          (uint8_t )15,          (uint8_t )186, 
                (uint8_t )23}, 
     {          (uint8_t )47,          (uint8_t )41,          (uint8_t )14,          (uint8_t )110, 
                (uint8_t )182,          (uint8_t )183,          (uint8_t )21,          (uint8_t )17, 
                (uint8_t )194}, 
     {          (uint8_t )66,          (uint8_t )45,          (uint8_t )25,          (uint8_t )102, 
                (uint8_t )197,          (uint8_t )189,          (uint8_t )23,          (uint8_t )18, 
                (uint8_t )22}}, 
   { {          (uint8_t )88,          (uint8_t )88,          (uint8_t )147,          (uint8_t )150, 
                (uint8_t )42,          (uint8_t )46,          (uint8_t )45,          (uint8_t )196, 
                (uint8_t )205}, 
     {          (uint8_t )43,          (uint8_t )97,          (uint8_t )183,          (uint8_t )117, 
                (uint8_t )85,          (uint8_t )38,          (uint8_t )35,          (uint8_t )179, 
                (uint8_t )61}, 
     {          (uint8_t )39,          (uint8_t )53,          (uint8_t )200,          (uint8_t )87, 
                (uint8_t )26,          (uint8_t )21,          (uint8_t )43,          (uint8_t )232, 
                (uint8_t )171}, 
     {          (uint8_t )56,          (uint8_t )34,          (uint8_t )51,          (uint8_t )104, 
                (uint8_t )114,          (uint8_t )102,          (uint8_t )29,          (uint8_t )93, 
                (uint8_t )77}, 
     {          (uint8_t )39,          (uint8_t )28,          (uint8_t )85,          (uint8_t )171, 
                (uint8_t )58,          (uint8_t )165,          (uint8_t )90,          (uint8_t )98, 
                (uint8_t )64}, 
     {          (uint8_t )34,          (uint8_t )22,          (uint8_t )116,          (uint8_t )206, 
                (uint8_t )23,          (uint8_t )34,          (uint8_t )43,          (uint8_t )166, 
                (uint8_t )73}, 
     {          (uint8_t )107,          (uint8_t )54,          (uint8_t )32,          (uint8_t )26, 
                (uint8_t )51,          (uint8_t )1,          (uint8_t )81,          (uint8_t )43, 
                (uint8_t )31}, 
     {          (uint8_t )68,          (uint8_t )25,          (uint8_t )106,          (uint8_t )22, 
                (uint8_t )64,          (uint8_t )171,          (uint8_t )36,          (uint8_t )225, 
                (uint8_t )114}, 
     {          (uint8_t )34,          (uint8_t )19,          (uint8_t )21,          (uint8_t )102, 
                (uint8_t )132,          (uint8_t )188,          (uint8_t )16,          (uint8_t )76, 
                (uint8_t )124}, 
     {          (uint8_t )62,          (uint8_t )18,          (uint8_t )78,          (uint8_t )95, 
                (uint8_t )85,          (uint8_t )57,          (uint8_t )50,          (uint8_t )48, 
                (uint8_t )51}}, 
   { {          (uint8_t )193,          (uint8_t )101,          (uint8_t )35,          (uint8_t )159, 
                (uint8_t )215,          (uint8_t )111,          (uint8_t )89,          (uint8_t )46, 
                (uint8_t )111}, 
     {          (uint8_t )60,          (uint8_t )148,          (uint8_t )31,          (uint8_t )172, 
                (uint8_t )219,          (uint8_t )228,          (uint8_t )21,          (uint8_t )18, 
                (uint8_t )111}, 
     {          (uint8_t )112,          (uint8_t )113,          (uint8_t )77,          (uint8_t )85, 
                (uint8_t )179,          (uint8_t )255,          (uint8_t )38,          (uint8_t )120, 
                (uint8_t )114}, 
     {          (uint8_t )40,          (uint8_t )42,          (uint8_t )1,          (uint8_t )196, 
                (uint8_t )245,          (uint8_t )209,          (uint8_t )10,          (uint8_t )25, 
                (uint8_t )109}, 
     {          (uint8_t )88,          (uint8_t )43,          (uint8_t )29,          (uint8_t )140, 
                (uint8_t )166,          (uint8_t )213,          (uint8_t )37,          (uint8_t )43, 
                (uint8_t )154}, 
     {          (uint8_t )61,          (uint8_t )63,          (uint8_t )30,          (uint8_t )155, 
                (uint8_t )67,          (uint8_t )45,          (uint8_t )68,          (uint8_t )1, 
                (uint8_t )209}, 
     {          (uint8_t )100,          (uint8_t )80,          (uint8_t )8,          (uint8_t )43, 
                (uint8_t )154,          (uint8_t )1,          (uint8_t )51,          (uint8_t )26, 
                (uint8_t )71}, 
     {          (uint8_t )142,          (uint8_t )78,          (uint8_t )78,          (uint8_t )16, 
                (uint8_t )255,          (uint8_t )128,          (uint8_t )34,          (uint8_t )197, 
                (uint8_t )171}, 
     {          (uint8_t )41,          (uint8_t )40,          (uint8_t )5,          (uint8_t )102, 
                (uint8_t )211,          (uint8_t )183,          (uint8_t )4,          (uint8_t )1, 
                (uint8_t )221}, 
     {          (uint8_t )51,          (uint8_t )50,          (uint8_t )17,          (uint8_t )168, 
                (uint8_t )209,          (uint8_t )192,          (uint8_t )23,          (uint8_t )25, 
                (uint8_t )82}}, 
   { {          (uint8_t )138,          (uint8_t )31,          (uint8_t )36,          (uint8_t )171, 
                (uint8_t )27,          (uint8_t )166,          (uint8_t )38,          (uint8_t )44, 
                (uint8_t )229}, 
     {          (uint8_t )67,          (uint8_t )87,          (uint8_t )58,          (uint8_t )169, 
                (uint8_t )82,          (uint8_t )115,          (uint8_t )26,          (uint8_t )59, 
                (uint8_t )179}, 
     {          (uint8_t )63,          (uint8_t )59,          (uint8_t )90,          (uint8_t )180, 
                (uint8_t )59,          (uint8_t )166,          (uint8_t )93,          (uint8_t )73, 
                (uint8_t )154}, 
     {          (uint8_t )40,          (uint8_t )40,          (uint8_t )21,          (uint8_t )116, 
                (uint8_t )143,          (uint8_t )209,          (uint8_t )34,          (uint8_t )39, 
                (uint8_t )175}, 
     {          (uint8_t )47,          (uint8_t )15,          (uint8_t )16,          (uint8_t )183, 
                (uint8_t )34,          (uint8_t )223,          (uint8_t )49,          (uint8_t )45, 
                (uint8_t )183}, 
     {          (uint8_t )46,          (uint8_t )17,          (uint8_t )33,          (uint8_t )183, 
                (uint8_t )6,          (uint8_t )98,          (uint8_t )15,          (uint8_t )32, 
                (uint8_t )183}, 
     {          (uint8_t )57,          (uint8_t )46,          (uint8_t )22,          (uint8_t )24, 
                (uint8_t )128,          (uint8_t )1,          (uint8_t )54,          (uint8_t )17, 
                (uint8_t )37}, 
     {          (uint8_t )65,          (uint8_t )32,          (uint8_t )73,          (uint8_t )115, 
                (uint8_t )28,          (uint8_t )128,          (uint8_t )23,          (uint8_t )128, 
                (uint8_t )205}, 
     {          (uint8_t )40,          (uint8_t )3,          (uint8_t )9,          (uint8_t )115, 
                (uint8_t )51,          (uint8_t )192,          (uint8_t )18,          (uint8_t )6, 
                (uint8_t )223}, 
     {          (uint8_t )87,          (uint8_t )37,          (uint8_t )9,          (uint8_t )115, 
                (uint8_t )59,          (uint8_t )77,          (uint8_t )64,          (uint8_t )21, 
                (uint8_t )47}}, 
   { {          (uint8_t )104,          (uint8_t )55,          (uint8_t )44,          (uint8_t )218, 
                (uint8_t )9,          (uint8_t )54,          (uint8_t )53,          (uint8_t )130, 
                (uint8_t )226}, 
     {          (uint8_t )64,          (uint8_t )90,          (uint8_t )70,          (uint8_t )205, 
                (uint8_t )40,          (uint8_t )41,          (uint8_t )23,          (uint8_t )26, 
                (uint8_t )57}, 
     {          (uint8_t )54,          (uint8_t )57,          (uint8_t )112,          (uint8_t )184, 
                (uint8_t )5,          (uint8_t )41,          (uint8_t )38,          (uint8_t )166, 
                (uint8_t )213}, 
     {          (uint8_t )30,          (uint8_t )34,          (uint8_t )26,          (uint8_t )133, 
                (uint8_t )152,          (uint8_t )116,          (uint8_t )10,          (uint8_t )32, 
                (uint8_t )134}, 
     {          (uint8_t )39,          (uint8_t )19,          (uint8_t )53,          (uint8_t )221, 
                (uint8_t )26,          (uint8_t )114,          (uint8_t )32,          (uint8_t )73, 
                (uint8_t )255}, 
     {          (uint8_t )31,          (uint8_t )9,          (uint8_t )65,          (uint8_t )234, 
                (uint8_t )2,          (uint8_t )15,          (uint8_t )1,          (uint8_t )118, 
                (uint8_t )73}, 
     {          (uint8_t )75,          (uint8_t )32,          (uint8_t )12,          (uint8_t )51, 
                (uint8_t )192,          (uint8_t )255,          (uint8_t )160,          (uint8_t )43, 
                (uint8_t )51}, 
     {          (uint8_t )88,          (uint8_t )31,          (uint8_t )35,          (uint8_t )67, 
                (uint8_t )102,          (uint8_t )85,          (uint8_t )55,          (uint8_t )186, 
                (uint8_t )85}, 
     {          (uint8_t )56,          (uint8_t )21,          (uint8_t )23,          (uint8_t )111, 
                (uint8_t )59,          (uint8_t )205,          (uint8_t )45,          (uint8_t )37, 
                (uint8_t )192}, 
     {          (uint8_t )55,          (uint8_t )38,          (uint8_t )70,          (uint8_t )124, 
                (uint8_t )73,          (uint8_t )102,          (uint8_t )1,          (uint8_t )34, 
                (uint8_t )98}}, 
   { {          (uint8_t )125,          (uint8_t )98,          (uint8_t )42,          (uint8_t )88, 
                (uint8_t )104,          (uint8_t )85,          (uint8_t )117,          (uint8_t )175, 
                (uint8_t )82}, 
     {          (uint8_t )95,          (uint8_t )84,          (uint8_t )53,          (uint8_t )89, 
                (uint8_t )128,          (uint8_t )100,          (uint8_t )113,          (uint8_t )101, 
                (uint8_t )45}, 
     {          (uint8_t )75,          (uint8_t )79,          (uint8_t )123,          (uint8_t )47, 
                (uint8_t )51,          (uint8_t )128,          (uint8_t )81,          (uint8_t )171, 
                (uint8_t )1}, 
     {          (uint8_t )57,          (uint8_t )17,          (uint8_t )5,          (uint8_t )71, 
                (uint8_t )102,          (uint8_t )57,          (uint8_t )53,          (uint8_t )41, 
                (uint8_t )49}, 
     {          (uint8_t )38,          (uint8_t )33,          (uint8_t )13,          (uint8_t )121, 
                (uint8_t )57,          (uint8_t )73,          (uint8_t )26,          (uint8_t )1, 
                (uint8_t )85}, 
     {          (uint8_t )41,          (uint8_t )10,          (uint8_t )67,          (uint8_t )138, 
                (uint8_t )77,          (uint8_t )110,          (uint8_t )90,          (uint8_t )47, 
                (uint8_t )114}, 
     {          (uint8_t )115,          (uint8_t )21,          (uint8_t )2,          (uint8_t )10, 
                (uint8_t )102,          (uint8_t )255,          (uint8_t )166,          (uint8_t )23, 
                (uint8_t )6}, 
     {          (uint8_t )101,          (uint8_t )29,          (uint8_t )16,          (uint8_t )10, 
                (uint8_t )85,          (uint8_t )128,          (uint8_t )101,          (uint8_t )196, 
                (uint8_t )26}, 
     {          (uint8_t )57,          (uint8_t )18,          (uint8_t )10,          (uint8_t )102, 
                (uint8_t )102,          (uint8_t )213,          (uint8_t )34,          (uint8_t )20, 
                (uint8_t )43}, 
     {          (uint8_t )117,          (uint8_t )20,          (uint8_t )15,          (uint8_t )36, 
                (uint8_t )163,          (uint8_t )128,          (uint8_t )68,          (uint8_t )1, 
                (uint8_t )26}}, 
   { {          (uint8_t )102,          (uint8_t )61,          (uint8_t )71,          (uint8_t )37, 
                (uint8_t )34,          (uint8_t )53,          (uint8_t )31,          (uint8_t )243, 
                (uint8_t )192}, 
     {          (uint8_t )69,          (uint8_t )60,          (uint8_t )71,          (uint8_t )38, 
                (uint8_t )73,          (uint8_t )119,          (uint8_t )28,          (uint8_t )222, 
                (uint8_t )37}, 
     {          (uint8_t )68,          (uint8_t )45,          (uint8_t )128,          (uint8_t )34, 
                (uint8_t )1,          (uint8_t )47,          (uint8_t )11,          (uint8_t )245, 
                (uint8_t )171}, 
     {          (uint8_t )62,          (uint8_t )17,          (uint8_t )19,          (uint8_t )70, 
                (uint8_t )146,          (uint8_t )85,          (uint8_t )55,          (uint8_t )62, 
                (uint8_t )70}, 
     {          (uint8_t )37,          (uint8_t )43,          (uint8_t )37,          (uint8_t )154, 
                (uint8_t )100,          (uint8_t )163,          (uint8_t )85,          (uint8_t )160, 
                (uint8_t )1}, 
     {          (uint8_t )63,          (uint8_t )9,          (uint8_t )92,          (uint8_t )136, 
                (uint8_t )28,          (uint8_t )64,          (uint8_t )32,          (uint8_t )201, 
                (uint8_t )85}, 
     {          (uint8_t )75,          (uint8_t )15,          (uint8_t )9,          (uint8_t )9, 
                (uint8_t )64,          (uint8_t )255,          (uint8_t )184,          (uint8_t )119, 
                (uint8_t )16}, 
     {          (uint8_t )86,          (uint8_t )6,          (uint8_t )28,          (uint8_t )5, 
                (uint8_t )64,          (uint8_t )255,          (uint8_t )25,          (uint8_t )248, 
                (uint8_t )1}, 
     {          (uint8_t )56,          (uint8_t )8,          (uint8_t )17,          (uint8_t )132, 
                (uint8_t )137,          (uint8_t )255,          (uint8_t )55,          (uint8_t )116, 
                (uint8_t )128}, 
     {          (uint8_t )58,          (uint8_t )15,          (uint8_t )20,          (uint8_t )82, 
                (uint8_t )135,          (uint8_t )57,          (uint8_t )26,          (uint8_t )121, 
                (uint8_t )40}}, 
   { {          (uint8_t )164,          (uint8_t )50,          (uint8_t )31,          (uint8_t )137, 
                (uint8_t )154,          (uint8_t )133,          (uint8_t )25,          (uint8_t )35, 
                (uint8_t )218}, 
     {          (uint8_t )51,          (uint8_t )103,          (uint8_t )44,          (uint8_t )131, 
                (uint8_t )131,          (uint8_t )123,          (uint8_t )31,          (uint8_t )6, 
                (uint8_t )158}, 
     {          (uint8_t )86,          (uint8_t )40,          (uint8_t )64,          (uint8_t )135, 
                (uint8_t )148,          (uint8_t )224,          (uint8_t )45,          (uint8_t )183, 
                (uint8_t )128}, 
     {          (uint8_t )22,          (uint8_t )26,          (uint8_t )17,          (uint8_t )131, 
                (uint8_t )240,          (uint8_t )154,          (uint8_t )14,          (uint8_t )1, 
                (uint8_t )209}, 
     {          (uint8_t )45,          (uint8_t )16,          (uint8_t )21,          (uint8_t )91, 
                (uint8_t )64,          (uint8_t )222,          (uint8_t )7,          (uint8_t )1, 
                (uint8_t )197}, 
     {          (uint8_t )56,          (uint8_t )21,          (uint8_t )39,          (uint8_t )155, 
                (uint8_t )60,          (uint8_t )138,          (uint8_t )23,          (uint8_t )102, 
                (uint8_t )213}, 
     {          (uint8_t )83,          (uint8_t )12,          (uint8_t )13,          (uint8_t )54, 
                (uint8_t )192,          (uint8_t )255,          (uint8_t )68,          (uint8_t )47, 
                (uint8_t )28}, 
     {          (uint8_t )85,          (uint8_t )26,          (uint8_t )85,          (uint8_t )85, 
                (uint8_t )128,          (uint8_t )128,          (uint8_t )32,          (uint8_t )146, 
                (uint8_t )171}, 
     {          (uint8_t )18,          (uint8_t )11,          (uint8_t )7,          (uint8_t )63, 
                (uint8_t )144,          (uint8_t )171,          (uint8_t )4,          (uint8_t )4, 
                (uint8_t )246}, 
     {          (uint8_t )35,          (uint8_t )27,          (uint8_t )10,          (uint8_t )146, 
                (uint8_t )174,          (uint8_t )171,          (uint8_t )12,          (uint8_t )26, 
                (uint8_t )128}}, 
   { {          (uint8_t )190,          (uint8_t )80,          (uint8_t )35,          (uint8_t )99, 
                (uint8_t )180,          (uint8_t )80,          (uint8_t )126,          (uint8_t )54, 
                (uint8_t )45}, 
     {          (uint8_t )85,          (uint8_t )126,          (uint8_t )47,          (uint8_t )87, 
                (uint8_t )176,          (uint8_t )51,          (uint8_t )41,          (uint8_t )20, 
                (uint8_t )32}, 
     {          (uint8_t )101,          (uint8_t )75,          (uint8_t )128,          (uint8_t )139, 
                (uint8_t )118,          (uint8_t )146,          (uint8_t )116,          (uint8_t )128, 
                (uint8_t )85}, 
     {          (uint8_t )56,          (uint8_t )41,          (uint8_t )15,          (uint8_t )176, 
                (uint8_t )236,          (uint8_t )85,          (uint8_t )37,          (uint8_t )9, 
                (uint8_t )62}, 
     {          (uint8_t )71,          (uint8_t )30,          (uint8_t )17,          (uint8_t )119, 
                (uint8_t )118,          (uint8_t )255,          (uint8_t )17,          (uint8_t )18, 
                (uint8_t )138}, 
     {          (uint8_t )101,          (uint8_t )38,          (uint8_t )60,          (uint8_t )138, 
                (uint8_t )55,          (uint8_t )70,          (uint8_t )43,          (uint8_t )26, 
                (uint8_t )142}, 
     {          (uint8_t )146,          (uint8_t )36,          (uint8_t )19,          (uint8_t )30, 
                (uint8_t )171,          (uint8_t )255,          (uint8_t )97,          (uint8_t )27, 
                (uint8_t )20}, 
     {          (uint8_t )138,          (uint8_t )45,          (uint8_t )61,          (uint8_t )62, 
                (uint8_t )219,          (uint8_t )1,          (uint8_t )81,          (uint8_t )188, 
                (uint8_t )64}, 
     {          (uint8_t )32,          (uint8_t )41,          (uint8_t )20,          (uint8_t )117, 
                (uint8_t )151,          (uint8_t )142,          (uint8_t )20,          (uint8_t )21, 
                (uint8_t )163}, 
     {          (uint8_t )112,          (uint8_t )19,          (uint8_t )12,          (uint8_t )61, 
                (uint8_t )195,          (uint8_t )128,          (uint8_t )48,          (uint8_t )4, 
                (uint8_t )24}}};
#line 284 "/root/patron-new/new_3/src/dec/tree_dec.c"
void VP8ResetProba(VP8Proba *proba ) 
{ 


  {
  {
#line 285
  memset((void *)(proba->segments_), 255, sizeof(proba->segments_));
  }
#line 287
  return;
}
}
#line 289 "/root/patron-new/new_3/src/dec/tree_dec.c"
static void ParseIntraMode(VP8BitReader *br , VP8Decoder *dec , int mb_x ) 
{ 
  uint8_t *top ;
  uint8_t *left ;
  VP8MBData *block ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int tmp___0 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int ymode ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp___1 ;
  int __cil_tmp17 ;
  int tmp___2 ;
  int tmp___3 ;
  uint8_t *modes ;
  int y ;
  int ymode___0 ;
  int x ;
  uint8_t *prob ;
  int i ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 291
  top = dec->intra_t_ + 4 * mb_x;
#line 292
  left = dec->intra_l_;
#line 293
  block = dec->mb_data_ + mb_x;
#line 297
  if (dec->segment_hdr_.update_map_) {
    {
#line 299
    __cil_tmp7 = VP8GetBit(br, (int )dec->proba_.segments_[0]);
    }
#line 299
    if (! __cil_tmp7) {
      {
#line 299
      __cil_tmp8 = VP8GetBit(br, (int )dec->proba_.segments_[1]);
#line 299
      tmp___0 = __cil_tmp8;
      }
    } else {
      {
#line 299
      __cil_tmp9 = VP8GetBit(br, (int )dec->proba_.segments_[2]);
#line 299
      tmp___0 = __cil_tmp9 + 2;
      }
    }
#line 299
    block->segment_ = (uint8_t )tmp___0;
  } else {
#line 303
    block->segment_ = (uint8_t )0;
  }
#line 305
  if (dec->use_skip_proba_) {
    {
#line 305
    __cil_tmp11 = VP8GetBit(br, (int )dec->skip_p_);
#line 305
    block->skip_ = (uint8_t )__cil_tmp11;
    }
  }
  {
#line 307
  __cil_tmp12 = VP8GetBit(br, 145);
#line 307
  block->is_i4x4_ = (uint8_t )(! __cil_tmp12);
  }
#line 308
  if (! block->is_i4x4_) {
    {
#line 310
    __cil_tmp14 = VP8GetBit(br, 156);
    }
#line 310
    if (__cil_tmp14) {
      {
#line 310
      __cil_tmp15 = VP8GetBit(br, 128);
      }
#line 310
      if (__cil_tmp15) {
#line 310
        tmp___1 = 1;
      } else {
#line 310
        tmp___1 = 3;
      }
#line 310
      tmp___3 = tmp___1;
    } else {
      {
#line 310
      __cil_tmp17 = VP8GetBit(br, 163);
      }
#line 310
      if (__cil_tmp17) {
#line 310
        tmp___2 = 2;
      } else {
#line 310
        tmp___2 = 0;
      }
#line 310
      tmp___3 = tmp___2;
    }
    {
#line 310
    ymode = tmp___3;
#line 314
    block->imodes_[0] = (uint8_t )ymode;
#line 315
    memset((void *)top, ymode, 4UL * sizeof(*top));
#line 316
    memset((void *)left, ymode, 4UL * sizeof(*left));
    }
  } else {
#line 318
    modes = block->imodes_;
#line 320
    y = 0;
    {
#line 320
    while (1) {
      while_continue: /* CIL Label */ ;

#line 320
      if (! (y < 4)) {
#line 320
        goto while_break;
      }
#line 321
      ymode___0 = (int )*(left + y);
#line 323
      x = 0;
      {
#line 323
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 323
        if (! (x < 4)) {
#line 323
          goto while_break___0;
        }
        {
#line 324
        prob = kBModesProba___0[*(top + x)][ymode___0];
#line 327
        __cil_tmp26 = VP8GetBit(br, (int )*(prob + 0));
#line 327
        i = (int )kYModesIntra4[__cil_tmp26];
        }
        {
#line 328
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 328
          if (! (i > 0)) {
#line 328
            goto while_break___1;
          }
          {
#line 329
          __cil_tmp27 = VP8GetBit(br, (int )*(prob + i));
#line 329
          i = (int )kYModesIntra4[2 * i + __cil_tmp27];
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: 
#line 331
        ymode___0 = - i;
#line 347
        *(top + x) = (uint8_t )ymode___0;
#line 323
        x ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: 
      {
#line 349
      memcpy((void *)modes, (void const   *)top, 4UL * sizeof(*top));
#line 350
      modes += 4;
#line 351
      *(left + y) = (uint8_t )ymode___0;
#line 320
      y ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 355
  __cil_tmp28 = VP8GetBit(br, 142);
  }
#line 355
  if (! __cil_tmp28) {
#line 355
    tmp___6 = 0;
  } else {
    {
#line 355
    __cil_tmp29 = VP8GetBit(br, 114);
    }
#line 355
    if (! __cil_tmp29) {
#line 355
      tmp___5 = 2;
    } else {
      {
#line 355
      __cil_tmp30 = VP8GetBit(br, 183);
      }
#line 355
      if (__cil_tmp30) {
#line 355
        tmp___4 = 1;
      } else {
#line 355
        tmp___4 = 3;
      }
#line 355
      tmp___5 = tmp___4;
    }
#line 355
    tmp___6 = tmp___5;
  }
#line 355
  block->uvmode_ = (uint8_t )tmp___6;
#line 356
  return;
}
}
#line 360 "/root/patron-new/new_3/src/dec/tree_dec.c"
int VP8ParseIntraModeRow(VP8BitReader *br , VP8Decoder *dec ) 
{ 
  int mb_x ;

  {
#line 362
  mb_x = 0;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;

#line 362
    if (! (mb_x < dec->mb_w_)) {
#line 362
      goto while_break;
    }
    {
#line 363
    ParseIntraMode(br, dec, mb_x);
#line 362
    mb_x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 365
  return (! dec->br_.eof_);
}
}
#line 372 "/root/patron-new/new_3/src/dec/tree_dec.c"
static uint8_t CoeffsUpdateProba[4][8][3][11]  = { { { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )176,            (uint8_t )246,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )223,            (uint8_t )241,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )244,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )246,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )239,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )248,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )217,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )225,            (uint8_t )252,            (uint8_t )241,            (uint8_t )253, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )250,            (uint8_t )241,            (uint8_t )250, 
                    (uint8_t )253,            (uint8_t )255,            (uint8_t )253,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )223,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )238,            (uint8_t )253,            (uint8_t )254,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )248,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )247,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )186,            (uint8_t )251,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )251,            (uint8_t )244,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )251,            (uint8_t )243,            (uint8_t )253, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )236,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )253,            (uint8_t )253,            (uint8_t )254, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )248,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )254,            (uint8_t )252,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )248,            (uint8_t )254,            (uint8_t )249,            (uint8_t )253, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )246,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )254,            (uint8_t )251,            (uint8_t )254, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )248,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )254,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )251,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )245,            (uint8_t )251,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )251,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )252,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}};
#line 509 "/root/patron-new/new_3/src/dec/tree_dec.c"
static uint8_t kBands[17]  = 
#line 509
  {      (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )6,      (uint8_t )4,      (uint8_t )5,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )0};
#line 514 "/root/patron-new/new_3/src/dec/tree_dec.c"
void VP8ParseProba(VP8BitReader *br , VP8Decoder *dec ) 
{ 
  VP8Proba *proba ;
  int t ;
  int b ;
  int c ;
  int p ;
  int v ;
  int __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  uint32_t tmp___0 ;
  uint32_t __cil_tmp12 ;
  uint32_t __cil_tmp13 ;

  {
#line 515
  proba = & dec->proba_;
#line 517
  t = 0;
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;

#line 517
    if (! (t < 4)) {
#line 517
      goto while_break;
    }
#line 518
    b = 0;
    {
#line 518
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 518
      if (! (b < 8)) {
#line 518
        goto while_break___0;
      }
#line 519
      c = 0;
      {
#line 519
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 519
        if (! (c < 3)) {
#line 519
          goto while_break___1;
        }
#line 520
        p = 0;
        {
#line 520
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 520
          if (! (p < 11)) {
#line 520
            goto while_break___2;
          }
          {
#line 521
          __cil_tmp9 = VP8GetBit(br, (int )CoeffsUpdateProba[t][b][c][p]);
          }
#line 521
          if (__cil_tmp9) {
            {
#line 521
            __cil_tmp10 = VP8GetValue(br, 8);
#line 521
            tmp___0 = __cil_tmp10;
            }
          } else {
#line 521
            tmp___0 = (unsigned int )CoeffsProba0[t][b][c][p];
          }
#line 521
          v = (int )tmp___0;
#line 525
          proba->bands_[t][b].probas_[c][p] = (uint8_t )v;
#line 520
          p ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: 
#line 519
        c ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
#line 518
      b ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 529
    b = 0;
    {
#line 529
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 529
      if (! (b < 17)) {
#line 529
        goto while_break___3;
      }
#line 530
      proba->bands_ptr_[t][b] = & proba->bands_[t][kBands[b]];
#line 529
      b ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: 
#line 517
    t ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 533
  __cil_tmp12 = VP8GetValue(br, 1);
#line 533
  dec->use_skip_proba_ = (int )__cil_tmp12;
  }
#line 534
  if (dec->use_skip_proba_) {
    {
#line 535
    __cil_tmp13 = VP8GetValue(br, 8);
#line 535
    dec->skip_p_ = (uint8_t )__cil_tmp13;
    }
  }
#line 538
  return;
}
}
#line 16 "/root/patron-new/new_3/src/dec/quant_dec.c"
__inline static int clip___1(int v , int M ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
#line 17
  if (v < 0) {
#line 17
    tmp___1 = 0;
  } else {
#line 17
    if (v > M) {
#line 17
      tmp___0 = M;
    } else {
#line 17
      tmp___0 = v;
    }
#line 17
    tmp___1 = tmp___0;
  }
#line 17
  return (tmp___1);
}
}
#line 21 "/root/patron-new/new_3/src/dec/quant_dec.c"
static uint8_t kDcTable___0[128]  = 
#line 21
  {      (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )10, 
        (uint8_t )11,      (uint8_t )12,      (uint8_t )13,      (uint8_t )14, 
        (uint8_t )15,      (uint8_t )16,      (uint8_t )17,      (uint8_t )17, 
        (uint8_t )18,      (uint8_t )19,      (uint8_t )20,      (uint8_t )20, 
        (uint8_t )21,      (uint8_t )21,      (uint8_t )22,      (uint8_t )22, 
        (uint8_t )23,      (uint8_t )23,      (uint8_t )24,      (uint8_t )25, 
        (uint8_t )25,      (uint8_t )26,      (uint8_t )27,      (uint8_t )28, 
        (uint8_t )29,      (uint8_t )30,      (uint8_t )31,      (uint8_t )32, 
        (uint8_t )33,      (uint8_t )34,      (uint8_t )35,      (uint8_t )36, 
        (uint8_t )37,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )46, 
        (uint8_t )47,      (uint8_t )48,      (uint8_t )49,      (uint8_t )50, 
        (uint8_t )51,      (uint8_t )52,      (uint8_t )53,      (uint8_t )54, 
        (uint8_t )55,      (uint8_t )56,      (uint8_t )57,      (uint8_t )58, 
        (uint8_t )59,      (uint8_t )60,      (uint8_t )61,      (uint8_t )62, 
        (uint8_t )63,      (uint8_t )64,      (uint8_t )65,      (uint8_t )66, 
        (uint8_t )67,      (uint8_t )68,      (uint8_t )69,      (uint8_t )70, 
        (uint8_t )71,      (uint8_t )72,      (uint8_t )73,      (uint8_t )74, 
        (uint8_t )75,      (uint8_t )76,      (uint8_t )76,      (uint8_t )77, 
        (uint8_t )78,      (uint8_t )79,      (uint8_t )80,      (uint8_t )81, 
        (uint8_t )82,      (uint8_t )83,      (uint8_t )84,      (uint8_t )85, 
        (uint8_t )86,      (uint8_t )87,      (uint8_t )88,      (uint8_t )89, 
        (uint8_t )91,      (uint8_t )93,      (uint8_t )95,      (uint8_t )96, 
        (uint8_t )98,      (uint8_t )100,      (uint8_t )101,      (uint8_t )102, 
        (uint8_t )104,      (uint8_t )106,      (uint8_t )108,      (uint8_t )110, 
        (uint8_t )112,      (uint8_t )114,      (uint8_t )116,      (uint8_t )118, 
        (uint8_t )122,      (uint8_t )124,      (uint8_t )126,      (uint8_t )128, 
        (uint8_t )130,      (uint8_t )132,      (uint8_t )134,      (uint8_t )136, 
        (uint8_t )138,      (uint8_t )140,      (uint8_t )143,      (uint8_t )145, 
        (uint8_t )148,      (uint8_t )151,      (uint8_t )154,      (uint8_t )157};
#line 40 "/root/patron-new/new_3/src/dec/quant_dec.c"
static uint16_t kAcTable___0[128]  = 
#line 40
  {      (uint16_t )4,      (uint16_t )5,      (uint16_t )6,      (uint16_t )7, 
        (uint16_t )8,      (uint16_t )9,      (uint16_t )10,      (uint16_t )11, 
        (uint16_t )12,      (uint16_t )13,      (uint16_t )14,      (uint16_t )15, 
        (uint16_t )16,      (uint16_t )17,      (uint16_t )18,      (uint16_t )19, 
        (uint16_t )20,      (uint16_t )21,      (uint16_t )22,      (uint16_t )23, 
        (uint16_t )24,      (uint16_t )25,      (uint16_t )26,      (uint16_t )27, 
        (uint16_t )28,      (uint16_t )29,      (uint16_t )30,      (uint16_t )31, 
        (uint16_t )32,      (uint16_t )33,      (uint16_t )34,      (uint16_t )35, 
        (uint16_t )36,      (uint16_t )37,      (uint16_t )38,      (uint16_t )39, 
        (uint16_t )40,      (uint16_t )41,      (uint16_t )42,      (uint16_t )43, 
        (uint16_t )44,      (uint16_t )45,      (uint16_t )46,      (uint16_t )47, 
        (uint16_t )48,      (uint16_t )49,      (uint16_t )50,      (uint16_t )51, 
        (uint16_t )52,      (uint16_t )53,      (uint16_t )54,      (uint16_t )55, 
        (uint16_t )56,      (uint16_t )57,      (uint16_t )58,      (uint16_t )60, 
        (uint16_t )62,      (uint16_t )64,      (uint16_t )66,      (uint16_t )68, 
        (uint16_t )70,      (uint16_t )72,      (uint16_t )74,      (uint16_t )76, 
        (uint16_t )78,      (uint16_t )80,      (uint16_t )82,      (uint16_t )84, 
        (uint16_t )86,      (uint16_t )88,      (uint16_t )90,      (uint16_t )92, 
        (uint16_t )94,      (uint16_t )96,      (uint16_t )98,      (uint16_t )100, 
        (uint16_t )102,      (uint16_t )104,      (uint16_t )106,      (uint16_t )108, 
        (uint16_t )110,      (uint16_t )112,      (uint16_t )114,      (uint16_t )116, 
        (uint16_t )119,      (uint16_t )122,      (uint16_t )125,      (uint16_t )128, 
        (uint16_t )131,      (uint16_t )134,      (uint16_t )137,      (uint16_t )140, 
        (uint16_t )143,      (uint16_t )146,      (uint16_t )149,      (uint16_t )152, 
        (uint16_t )155,      (uint16_t )158,      (uint16_t )161,      (uint16_t )164, 
        (uint16_t )167,      (uint16_t )170,      (uint16_t )173,      (uint16_t )177, 
        (uint16_t )181,      (uint16_t )185,      (uint16_t )189,      (uint16_t )193, 
        (uint16_t )197,      (uint16_t )201,      (uint16_t )205,      (uint16_t )209, 
        (uint16_t )213,      (uint16_t )217,      (uint16_t )221,      (uint16_t )225, 
        (uint16_t )229,      (uint16_t )234,      (uint16_t )239,      (uint16_t )245, 
        (uint16_t )249,      (uint16_t )254,      (uint16_t )259,      (uint16_t )264, 
        (uint16_t )269,      (uint16_t )274,      (uint16_t )279,      (uint16_t )284};
#line 62 "/root/patron-new/new_3/src/dec/quant_dec.c"
void VP8ParseQuant(VP8Decoder *dec ) 
{ 
  VP8BitReader *br ;
  int base_q0 ;
  uint32_t __cil_tmp4 ;
  int dqy1_dc ;
  uint32_t __cil_tmp6 ;
  int32_t __cil_tmp7 ;
  int32_t tmp___0 ;
  int dqy2_dc ;
  uint32_t __cil_tmp10 ;
  int32_t __cil_tmp11 ;
  int32_t tmp___1 ;
  int dqy2_ac ;
  uint32_t __cil_tmp14 ;
  int32_t __cil_tmp15 ;
  int32_t tmp___2 ;
  int dquv_dc ;
  uint32_t __cil_tmp18 ;
  int32_t __cil_tmp19 ;
  int32_t tmp___3 ;
  int dquv_ac ;
  uint32_t __cil_tmp22 ;
  int32_t __cil_tmp23 ;
  int32_t tmp___4 ;
  VP8SegmentHeader *hdr ;
  int i ;
  int q ;
  VP8QuantMatrix *m ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;

  {
  {
#line 63
  br = & dec->br_;
#line 64
  __cil_tmp4 = VP8GetValue(br, 7);
#line 64
  base_q0 = (int )__cil_tmp4;
#line 65
  __cil_tmp6 = VP8GetValue(br, 1);
  }
#line 65
  if (__cil_tmp6) {
    {
#line 65
    __cil_tmp7 = VP8GetSignedValue(br, 4);
#line 65
    tmp___0 = __cil_tmp7;
    }
  } else {
#line 65
    tmp___0 = 0;
  }
  {
#line 65
  dqy1_dc = tmp___0;
#line 67
  __cil_tmp10 = VP8GetValue(br, 1);
  }
#line 67
  if (__cil_tmp10) {
    {
#line 67
    __cil_tmp11 = VP8GetSignedValue(br, 4);
#line 67
    tmp___1 = __cil_tmp11;
    }
  } else {
#line 67
    tmp___1 = 0;
  }
  {
#line 67
  dqy2_dc = tmp___1;
#line 69
  __cil_tmp14 = VP8GetValue(br, 1);
  }
#line 69
  if (__cil_tmp14) {
    {
#line 69
    __cil_tmp15 = VP8GetSignedValue(br, 4);
#line 69
    tmp___2 = __cil_tmp15;
    }
  } else {
#line 69
    tmp___2 = 0;
  }
  {
#line 69
  dqy2_ac = tmp___2;
#line 71
  __cil_tmp18 = VP8GetValue(br, 1);
  }
#line 71
  if (__cil_tmp18) {
    {
#line 71
    __cil_tmp19 = VP8GetSignedValue(br, 4);
#line 71
    tmp___3 = __cil_tmp19;
    }
  } else {
#line 71
    tmp___3 = 0;
  }
  {
#line 71
  dquv_dc = tmp___3;
#line 73
  __cil_tmp22 = VP8GetValue(br, 1);
  }
#line 73
  if (__cil_tmp22) {
    {
#line 73
    __cil_tmp23 = VP8GetSignedValue(br, 4);
#line 73
    tmp___4 = __cil_tmp23;
    }
  } else {
#line 73
    tmp___4 = 0;
  }
#line 73
  dquv_ac = tmp___4;
#line 76
  hdr = & dec->segment_hdr_;
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 79
    if (! (i < 4)) {
#line 79
      goto while_break;
    }
#line 81
    if (hdr->use_segment_) {
#line 82
      q = (int )hdr->quantizer_[i];
#line 83
      if (! hdr->absolute_delta_) {
#line 84
        q += base_q0;
      }
    } else
#line 87
    if (i > 0) {
#line 88
      dec->dqm_[i] = dec->dqm_[0];
#line 89
      goto while_continue;
    } else {
#line 91
      q = base_q0;
    }
    {
#line 95
    m = & dec->dqm_[i];
#line 96
    __cil_tmp29 = clip___1(q + dqy1_dc, 127);
#line 96
    m->y1_mat_[0] = (int )kDcTable___0[__cil_tmp29];
#line 97
    __cil_tmp30 = clip___1(q, 127);
#line 97
    m->y1_mat_[1] = (int )kAcTable___0[__cil_tmp30];
#line 99
    __cil_tmp31 = clip___1(q + dqy2_dc, 127);
#line 99
    m->y2_mat_[0] = (int )kDcTable___0[__cil_tmp31] * 2;
#line 103
    __cil_tmp32 = clip___1(q + dqy2_ac, 127);
#line 103
    m->y2_mat_[1] = (int )kAcTable___0[__cil_tmp32] * 101581 >> 16;
    }
#line 104
    if (m->y2_mat_[1] < 8) {
#line 104
      m->y2_mat_[1] = 8;
    }
    {
#line 106
    __cil_tmp33 = clip___1(q + dquv_dc, 117);
#line 106
    m->uv_mat_[0] = (int )kDcTable___0[__cil_tmp33];
#line 107
    __cil_tmp34 = clip___1(q + dquv_ac, 127);
#line 107
    m->uv_mat_[1] = (int )kAcTable___0[__cil_tmp34];
#line 109
    m->uv_quant_ = q + dquv_ac;
#line 79
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 83
  return;
}
}
#line 25 "/root/patron-new/new_3/src/dec/io_dec.c"
static int EmitYUV(VP8Io *io , WebPDecParams *p ) 
{ 
  WebPDecBuffer *output ;
  WebPYUVABuffer *buf ;
  uint8_t *y_dst ;
  uint8_t *u_dst ;
  uint8_t *v_dst ;
  int mb_w ;
  int mb_h ;
  int uv_w ;
  int uv_h ;

  {
  {
#line 26
  output = p->output;
#line 27
  buf = & output->u.YUVA;
#line 28
  y_dst = buf->y + (size_t )io->mb_y * (unsigned long )buf->y_stride;
#line 29
  u_dst = buf->u + (size_t )(io->mb_y >> 1) * (unsigned long )buf->u_stride;
#line 30
  v_dst = buf->v + (size_t )(io->mb_y >> 1) * (unsigned long )buf->v_stride;
#line 31
  mb_w = io->mb_w;
#line 32
  mb_h = io->mb_h;
#line 33
  uv_w = (mb_w + 1) / 2;
#line 34
  uv_h = (mb_h + 1) / 2;
#line 35
  WebPCopyPlane(io->y, io->y_stride, y_dst, buf->y_stride, mb_w, mb_h);
#line 36
  WebPCopyPlane(io->u, io->uv_stride, u_dst, buf->u_stride, uv_w, uv_h);
#line 37
  WebPCopyPlane(io->v, io->uv_stride, v_dst, buf->v_stride, uv_w, uv_h);
  }
#line 38
  return (io->mb_h);
}
}
#line 42 "/root/patron-new/new_3/src/dec/io_dec.c"
static int EmitSampledRGB(VP8Io *io , WebPDecParams *p ) 
{ 
  WebPDecBuffer *output ;
  WebPRGBABuffer *buf ;
  uint8_t *dst ;

  {
  {
#line 43
  output = p->output;
#line 44
  buf = & output->u.RGBA;
#line 45
  dst = buf->rgba + (size_t )io->mb_y * (unsigned long )buf->stride;
#line 46
  WebPSamplerProcessPlane(io->y, io->y_stride, io->u, io->v, io->uv_stride, dst, buf->stride,
                          io->mb_w, io->mb_h, WebPSamplers[output->colorspace]);
  }
#line 50
  return (io->mb_h);
}
}
#line 57 "/root/patron-new/new_3/src/dec/io_dec.c"
static int EmitFancyRGB(VP8Io *io , WebPDecParams *p ) 
{ 
  int num_lines_out ;
  WebPRGBABuffer *buf ;
  uint8_t *dst ;
  void (*upsample)(uint8_t * , uint8_t * , uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                   uint8_t * , uint8_t * , int  ) ;
  uint8_t *cur_y ;
  uint8_t *cur_u ;
  uint8_t *cur_v ;
  uint8_t *top_u ;
  uint8_t *top_v ;
  int y ;
  int y_end ;
  int mb_w ;
  int uv_w ;
  int __cil_tmp16 ;

  {
#line 58
  num_lines_out = io->mb_h;
#line 59
  buf = & (p->output)->u.RGBA;
#line 60
  dst = buf->rgba + (size_t )io->mb_y * (unsigned long )buf->stride;
#line 61
  upsample = WebPUpsamplers[(p->output)->colorspace];
#line 62
  cur_y = io->y;
#line 63
  cur_u = io->u;
#line 64
  cur_v = io->v;
#line 65
  top_u = p->tmp_u;
#line 66
  top_v = p->tmp_v;
#line 67
  y = io->mb_y;
#line 68
  y_end = io->mb_y + io->mb_h;
#line 69
  mb_w = io->mb_w;
#line 70
  uv_w = (mb_w + 1) / 2;
#line 72
  if (y == 0) {
    {
#line 74
    (*upsample)(cur_y, (uint8_t *)((void *)0), cur_u, cur_v, cur_u, cur_v, dst, (uint8_t *)((void *)0),
                mb_w);
    }
  } else {
    {
#line 77
    (*upsample)(p->tmp_y, cur_y, top_u, top_v, cur_u, cur_v, dst - buf->stride, dst,
                mb_w);
#line 79
    num_lines_out ++;
    }
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;

#line 82
    if (! (y + 2 < y_end)) {
#line 82
      goto while_break;
    }
    {
#line 83
    top_u = cur_u;
#line 84
    top_v = cur_v;
#line 85
    cur_u += io->uv_stride;
#line 86
    cur_v += io->uv_stride;
#line 87
    dst += 2 * buf->stride;
#line 88
    cur_y += 2 * io->y_stride;
#line 89
    (*upsample)(cur_y - io->y_stride, cur_y, top_u, top_v, cur_u, cur_v, dst - buf->stride,
                dst, mb_w);
#line 82
    y += 2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 94
  cur_y += io->y_stride;
#line 95
  if (io->crop_top + y_end < io->crop_bottom) {
    {
#line 97
    memcpy((void *)p->tmp_y, (void const   *)cur_y, (unsigned long )mb_w * sizeof(*(p->tmp_y)));
#line 98
    memcpy((void *)p->tmp_u, (void const   *)cur_u, (unsigned long )uv_w * sizeof(*(p->tmp_u)));
#line 99
    memcpy((void *)p->tmp_v, (void const   *)cur_v, (unsigned long )uv_w * sizeof(*(p->tmp_v)));
#line 102
    __cil_tmp16 = num_lines_out;
#line 102
    num_lines_out --;
    }
  } else
#line 105
  if (! (y_end & 1)) {
    {
#line 106
    (*upsample)(cur_y, (uint8_t *)((void *)0), cur_u, cur_v, cur_u, cur_v, dst + buf->stride,
                (uint8_t *)((void *)0), mb_w);
    }
  }
#line 110
  return (num_lines_out);
}
}
#line 117 "/root/patron-new/new_3/src/dec/io_dec.c"
static void FillAlphaPlane(uint8_t *dst , int w , int h , int stride ) 
{ 
  int j ;

  {
#line 119
  j = 0;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;

#line 119
    if (! (j < h)) {
#line 119
      goto while_break;
    }
    {
#line 120
    memset((void *)dst, 255, (unsigned long )w * sizeof(*dst));
#line 121
    dst += stride;
#line 119
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 123
  return;
}
}
#line 125 "/root/patron-new/new_3/src/dec/io_dec.c"
static int EmitAlphaYUV(VP8Io *io , WebPDecParams *p , int expected_num_lines_out ) 
{ 
  uint8_t *alpha ;
  WebPYUVABuffer *buf ;
  int mb_w ;
  int mb_h ;
  uint8_t *dst ;
  int j ;

  {
#line 127
  alpha = io->a;
#line 128
  buf = & (p->output)->u.YUVA;
#line 129
  mb_w = io->mb_w;
#line 130
  mb_h = io->mb_h;
#line 131
  dst = buf->a + (size_t )io->mb_y * (unsigned long )buf->a_stride;
#line 135
  if ((unsigned long )alpha != (unsigned long )((void *)0)) {
#line 136
    j = 0;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;

#line 136
      if (! (j < mb_h)) {
#line 136
        goto while_break;
      }
      {
#line 137
      memcpy((void *)dst, (void const   *)alpha, (unsigned long )mb_w * sizeof(*dst));
#line 138
      alpha += io->width;
#line 139
      dst += buf->a_stride;
#line 136
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  } else
#line 141
  if ((unsigned long )buf->a != (unsigned long )((void *)0)) {
    {
#line 143
    FillAlphaPlane(dst, mb_w, mb_h, buf->a_stride);
    }
  }
#line 145
  return (0);
}
}
#line 148 "/root/patron-new/new_3/src/dec/io_dec.c"
static int GetAlphaSourceRow(VP8Io *io , uint8_t **alpha , int *num_rows ) 
{ 
  int start_y ;

  {
#line 150
  start_y = io->mb_y;
#line 151
  *num_rows = io->mb_h;
#line 155
  if (io->fancy_upsampling) {
#line 156
    if (start_y == 0) {
#line 158
      (*num_rows) --;
    } else {
#line 160
      start_y --;
#line 164
      *alpha -= io->width;
    }
#line 166
    if ((io->crop_top + io->mb_y) + io->mb_h == io->crop_bottom) {
#line 168
      *num_rows = (io->crop_bottom - io->crop_top) - start_y;
    }
  }
#line 171
  return (start_y);
}
}
#line 174 "/root/patron-new/new_3/src/dec/io_dec.c"
static int EmitAlphaRGB(VP8Io *io , WebPDecParams *p , int expected_num_lines_out ) 
{ 
  uint8_t *alpha ;
  int mb_w ;
  WEBP_CSP_MODE colorspace ;
  int alpha_first ;
  WebPRGBABuffer *buf ;
  int num_rows ;
  size_t start_y ;
  int __cil_tmp11 ;
  uint8_t *base_rgba ;
  uint8_t *dst ;
  int tmp___0 ;
  int has_alpha ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp___1 ;

  {
#line 176
  alpha = io->a;
#line 177
  if ((unsigned long )alpha != (unsigned long )((void *)0)) {
#line 178
    mb_w = io->mb_w;
#line 179
    colorspace = (p->output)->colorspace;
#line 180
    if ((unsigned int )colorspace == 4U) {
#line 180
      tmp___1 = 1;
    } else
#line 180
    if ((unsigned int )colorspace == 9U) {
#line 180
      tmp___1 = 1;
    } else {
#line 180
      tmp___1 = 0;
    }
    {
#line 180
    alpha_first = tmp___1;
#line 182
    buf = & (p->output)->u.RGBA;
#line 184
    __cil_tmp11 = GetAlphaSourceRow(io, & alpha, & num_rows);
#line 184
    start_y = (size_t )__cil_tmp11;
#line 185
    base_rgba = buf->rgba + start_y * (unsigned long )buf->stride;
    }
#line 186
    if (alpha_first) {
#line 186
      tmp___0 = 0;
    } else {
#line 186
      tmp___0 = 3;
    }
    {
#line 186
    dst = base_rgba + tmp___0;
#line 187
    __cil_tmp16 = (*WebPDispatchAlpha)(alpha, io->width, mb_w, num_rows, dst, buf->stride);
#line 187
    has_alpha = __cil_tmp16;
#line 192
    __cil_tmp17 = WebPIsPremultipliedMode(colorspace);
    }
#line 192
    if (has_alpha) {
#line 192
      if (__cil_tmp17) {
        {
#line 193
        (*WebPApplyAlphaMultiply)(base_rgba, alpha_first, mb_w, num_rows, buf->stride);
        }
      }
    }
  }
#line 197
  return (0);
}
}
#line 200 "/root/patron-new/new_3/src/dec/io_dec.c"
static int EmitAlphaRGBA4444(VP8Io *io , WebPDecParams *p , int expected_num_lines_out ) 
{ 
  uint8_t *alpha ;
  int mb_w ;
  WEBP_CSP_MODE colorspace ;
  WebPRGBABuffer *buf ;
  int num_rows ;
  size_t start_y ;
  int __cil_tmp10 ;
  uint8_t *base_rgba ;
  uint8_t *alpha_dst ;
  uint32_t alpha_mask ;
  int i ;
  int j ;
  uint32_t alpha_value ;
  int __cil_tmp17 ;

  {
#line 202
  alpha = io->a;
#line 203
  if ((unsigned long )alpha != (unsigned long )((void *)0)) {
    {
#line 204
    mb_w = io->mb_w;
#line 205
    colorspace = (p->output)->colorspace;
#line 206
    buf = & (p->output)->u.RGBA;
#line 208
    __cil_tmp10 = GetAlphaSourceRow(io, & alpha, & num_rows);
#line 208
    start_y = (size_t )__cil_tmp10;
#line 209
    base_rgba = buf->rgba + start_y * (unsigned long )buf->stride;
#line 213
    alpha_dst = base_rgba + 1;
#line 215
    alpha_mask = (uint32_t )15;
#line 217
    j = 0;
    }
    {
#line 217
    while (1) {
      while_continue: /* CIL Label */ ;

#line 217
      if (! (j < num_rows)) {
#line 217
        goto while_break;
      }
#line 218
      i = 0;
      {
#line 218
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 218
        if (! (i < mb_w)) {
#line 218
          goto while_break___0;
        }
#line 220
        alpha_value = (uint32_t )((int )*(alpha + i) >> 4);
#line 221
        *(alpha_dst + 2 * i) = (uint8_t )((unsigned int )((int )*(alpha_dst + 2 * i) & 240) | alpha_value);
#line 222
        alpha_mask &= alpha_value;
#line 218
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 224
      alpha += io->width;
#line 225
      alpha_dst += buf->stride;
#line 217
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 229
    __cil_tmp17 = WebPIsPremultipliedMode(colorspace);
    }
#line 229
    if (alpha_mask != 15U) {
#line 229
      if (__cil_tmp17) {
        {
#line 230
        (*WebPApplyAlphaMultiply4444)(base_rgba, mb_w, num_rows, buf->stride);
        }
      }
    }
  }
#line 233
  return (0);
}
}
#line 240 "/root/patron-new/new_3/src/dec/io_dec.c"
static int Rescale(uint8_t *src , int src_stride , int new_lines , WebPRescaler *wrk ) 
{ 
  int num_lines_out ;
  int lines_in ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 242
  num_lines_out = 0;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;

#line 243
    if (! (new_lines > 0)) {
#line 243
      goto while_break;
    }
    {
#line 244
    __cil_tmp7 = WebPRescalerImport(wrk, new_lines, src, src_stride);
#line 244
    lines_in = __cil_tmp7;
#line 245
    src += lines_in * src_stride;
#line 246
    new_lines -= lines_in;
#line 247
    __cil_tmp8 = WebPRescalerExport(wrk);
#line 247
    num_lines_out += __cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 249
  return (num_lines_out);
}
}
#line 252 "/root/patron-new/new_3/src/dec/io_dec.c"
static int EmitRescaledYUV(VP8Io *io , WebPDecParams *p ) 
{ 
  int mb_h ;
  int uv_mb_h ;
  WebPRescaler *scaler ;
  int num_lines_out ;
  int __cil_tmp7 ;

  {
  {
#line 253
  mb_h = io->mb_h;
#line 254
  uv_mb_h = (mb_h + 1) >> 1;
#line 255
  scaler = p->scaler_y;
#line 256
  num_lines_out = 0;
#line 257
  __cil_tmp7 = WebPIsAlphaMode((p->output)->colorspace);
  }
#line 257
  if ((unsigned long )io->a != (unsigned long )((void *)0)) {
#line 257
    if (__cil_tmp7) {
      {
#line 262
      WebPMultRows(io->y, io->y_stride, io->a, io->width, io->mb_w, mb_h, 0);
      }
    }
  }
  {
#line 265
  num_lines_out = Rescale(io->y, io->y_stride, mb_h, scaler);
#line 266
  Rescale(io->u, io->uv_stride, uv_mb_h, p->scaler_u);
#line 267
  Rescale(io->v, io->uv_stride, uv_mb_h, p->scaler_v);
  }
#line 268
  return (num_lines_out);
}
}
#line 271 "/root/patron-new/new_3/src/dec/io_dec.c"
static int EmitRescaledAlphaYUV(VP8Io *io , WebPDecParams *p , int expected_num_lines_out ) 
{ 
  WebPYUVABuffer *buf ;
  uint8_t *dst_a ;
  uint8_t *dst_y ;
  int num_lines_out ;
  int __cil_tmp8 ;

  {
#line 273
  buf = & (p->output)->u.YUVA;
#line 274
  dst_a = buf->a + (size_t )p->last_y * (unsigned long )buf->a_stride;
#line 275
  if ((unsigned long )io->a != (unsigned long )((void *)0)) {
    {
#line 276
    dst_y = buf->y + (size_t )p->last_y * (unsigned long )buf->y_stride;
#line 277
    __cil_tmp8 = Rescale(io->a, io->width, io->mb_h, p->scaler_a);
#line 277
    num_lines_out = __cil_tmp8;
    }
#line 279
    if (num_lines_out > 0) {
      {
#line 280
      WebPMultRows(dst_y, buf->y_stride, dst_a, buf->a_stride, (p->scaler_a)->dst_width,
                   num_lines_out, 1);
      }
    }
  } else
#line 283
  if ((unsigned long )buf->a != (unsigned long )((void *)0)) {
    {
#line 286
    FillAlphaPlane(dst_a, io->scaled_width, expected_num_lines_out, buf->a_stride);
    }
  }
#line 289
  return (0);
}
}
#line 292 "/root/patron-new/new_3/src/dec/io_dec.c"
static int InitYUVRescaler(VP8Io *io , WebPDecParams *p ) 
{ 
  int has_alpha ;
  int __cil_tmp4 ;
  WebPYUVABuffer *buf ;
  int out_width ;
  int out_height ;
  int uv_out_width ;
  int uv_out_height ;
  int uv_in_width ;
  int uv_in_height ;
  size_t work_size ;
  size_t uv_work_size ;
  uint64_t total_size ;
  size_t rescaler_size ;
  rescaler_t *work ;
  WebPRescaler *scalers ;
  int num_rescalers ;
  int tmp___0 ;
  WebPRescaler *tmp___1 ;

  {
  {
#line 293
  __cil_tmp4 = WebPIsAlphaMode((p->output)->colorspace);
#line 293
  has_alpha = __cil_tmp4;
#line 294
  buf = & (p->output)->u.YUVA;
#line 295
  out_width = io->scaled_width;
#line 296
  out_height = io->scaled_height;
#line 297
  uv_out_width = (out_width + 1) >> 1;
#line 298
  uv_out_height = (out_height + 1) >> 1;
#line 299
  uv_in_width = (io->mb_w + 1) >> 1;
#line 300
  uv_in_height = (io->mb_h + 1) >> 1;
#line 301
  work_size = (size_t )(2 * out_width);
#line 302
  uv_work_size = (size_t )(2 * uv_out_width);
  }
#line 307
  if (has_alpha) {
#line 307
    tmp___0 = 4;
  } else {
#line 307
    tmp___0 = 3;
  }
#line 307
  num_rescalers = tmp___0;
#line 309
  total_size = (work_size + 2UL * uv_work_size) * sizeof(*work);
#line 310
  if (has_alpha) {
#line 311
    total_size += work_size * sizeof(*work);
  }
#line 313
  rescaler_size = (unsigned long )num_rescalers * sizeof(*(p->scaler_y)) + 31UL;
#line 314
  total_size += rescaler_size;
#line 315
  if (total_size != total_size) {
#line 316
    return (0);
  }
  {
#line 319
  p->memory = WebPSafeMalloc((uint64_t )1ULL, total_size);
  }
#line 320
  if ((unsigned long )p->memory == (unsigned long )((void *)0)) {
#line 321
    return (0);
  }
#line 323
  work = (rescaler_t *)p->memory;
#line 325
  scalers = (WebPRescaler *)(((uintptr_t )(((uint8_t *)work + total_size) - rescaler_size) + 31UL) & 0xffffffffffffffe0UL);
#line 327
  p->scaler_y = scalers + 0;
#line 328
  p->scaler_u = scalers + 1;
#line 329
  p->scaler_v = scalers + 2;
#line 330
  if (has_alpha) {
#line 330
    tmp___1 = scalers + 3;
  } else {
#line 330
    tmp___1 = (WebPRescaler *)((void *)0);
  }
  {
#line 330
  p->scaler_a = tmp___1;
#line 332
  WebPRescalerInit(p->scaler_y, io->mb_w, io->mb_h, buf->y, out_width, out_height,
                   buf->y_stride, 1, work);
#line 335
  WebPRescalerInit(p->scaler_u, uv_in_width, uv_in_height, buf->u, uv_out_width, uv_out_height,
                   buf->u_stride, 1, work + work_size);
#line 338
  WebPRescalerInit(p->scaler_v, uv_in_width, uv_in_height, buf->v, uv_out_width, uv_out_height,
                   buf->v_stride, 1, (work + work_size) + uv_work_size);
#line 341
  p->emit = (int (*)(VP8Io * const   , WebPDecParams * const   ))(& EmitRescaledYUV);
  }
#line 343
  if (has_alpha) {
    {
#line 344
    WebPRescalerInit(p->scaler_a, io->mb_w, io->mb_h, buf->a, out_width, out_height,
                     buf->a_stride, 1, (work + work_size) + 2UL * uv_work_size);
#line 347
    p->emit_alpha = (int (*)(VP8Io * const   , WebPDecParams * const   , int  ))(& EmitRescaledAlphaYUV);
#line 348
    WebPInitAlphaProcessing();
    }
  }
#line 350
  return (1);
}
}
#line 356 "/root/patron-new/new_3/src/dec/io_dec.c"
static int ExportRGB(WebPDecParams *p , int y_pos ) 
{ 
  void (*convert)(uint8_t * , uint8_t * , uint8_t * , uint8_t * , int  ) ;
  WebPRGBABuffer *buf ;
  uint8_t *dst ;
  int num_lines_out ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 357
  convert = WebPYUV444Converters[(p->output)->colorspace];
#line 359
  buf = & (p->output)->u.RGBA;
#line 360
  dst = buf->rgba + (size_t )y_pos * (unsigned long )buf->stride;
#line 361
  num_lines_out = 0;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 364
    __cil_tmp8 = WebPRescalerHasPendingOutput(p->scaler_u);
#line 364
    __cil_tmp7 = WebPRescalerHasPendingOutput(p->scaler_y);
    }
#line 364
    if (__cil_tmp7) {
#line 364
      if (! __cil_tmp8) {
#line 364
        goto while_break;
      }
    } else {
#line 364
      goto while_break;
    }
    {
#line 368
    WebPRescalerExportRow(p->scaler_y);
#line 369
    WebPRescalerExportRow(p->scaler_u);
#line 370
    WebPRescalerExportRow(p->scaler_v);
#line 371
    (*convert)((p->scaler_y)->dst, (p->scaler_u)->dst, (p->scaler_v)->dst, dst, (p->scaler_y)->dst_width);
#line 373
    dst += buf->stride;
#line 374
    num_lines_out ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 376
  return (num_lines_out);
}
}
#line 379 "/root/patron-new/new_3/src/dec/io_dec.c"
static int EmitRescaledRGB(VP8Io *io , WebPDecParams *p ) 
{ 
  int mb_h ;
  int uv_mb_h ;
  int j ;
  int uv_j ;
  int num_lines_out ;
  int y_lines_in ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int u_lines_in ;
  int __cil_tmp12 ;
  int v_lines_in ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 380
  mb_h = io->mb_h;
#line 381
  uv_mb_h = (mb_h + 1) >> 1;
#line 382
  j = 0;
#line 382
  uv_j = 0;
#line 383
  num_lines_out = 0;
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;

#line 384
    if (! (j < mb_h)) {
#line 384
      goto while_break;
    }
    {
#line 385
    __cil_tmp9 = WebPRescalerImport(p->scaler_y, mb_h - j, io->y + (size_t )j * (unsigned long )io->y_stride,
                                    io->y_stride);
#line 385
    y_lines_in = __cil_tmp9;
#line 388
    j += y_lines_in;
#line 389
    __cil_tmp10 = WebPRescaleNeededLines(p->scaler_u, uv_mb_h - uv_j);
    }
#line 389
    if (__cil_tmp10) {
      {
#line 390
      __cil_tmp12 = WebPRescalerImport(p->scaler_u, uv_mb_h - uv_j, io->u + (size_t )uv_j * (unsigned long )io->uv_stride,
                                       io->uv_stride);
#line 390
      u_lines_in = __cil_tmp12;
#line 393
      __cil_tmp14 = WebPRescalerImport(p->scaler_v, uv_mb_h - uv_j, io->v + (size_t )uv_j * (unsigned long )io->uv_stride,
                                       io->uv_stride);
#line 393
      v_lines_in = __cil_tmp14;
#line 398
      uv_j += u_lines_in;
      }
    }
    {
#line 400
    __cil_tmp15 = ExportRGB(p, p->last_y + num_lines_out);
#line 400
    num_lines_out += __cil_tmp15;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 402
  return (num_lines_out);
}
}
#line 405 "/root/patron-new/new_3/src/dec/io_dec.c"
static int ExportAlpha(WebPDecParams *p , int y_pos , int max_lines_out ) 
{ 
  WebPRGBABuffer *buf ;
  uint8_t *base_rgba ;
  WEBP_CSP_MODE colorspace ;
  int alpha_first ;
  uint8_t *dst ;
  int tmp___0 ;
  int num_lines_out ;
  int is_premult_alpha ;
  int __cil_tmp12 ;
  uint32_t non_opaque ;
  int width ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp___1 ;

  {
#line 406
  buf = & (p->output)->u.RGBA;
#line 407
  base_rgba = buf->rgba + (size_t )y_pos * (unsigned long )buf->stride;
#line 408
  colorspace = (p->output)->colorspace;
#line 409
  if ((unsigned int )colorspace == 4U) {
#line 409
    tmp___1 = 1;
  } else
#line 409
  if ((unsigned int )colorspace == 9U) {
#line 409
    tmp___1 = 1;
  } else {
#line 409
    tmp___1 = 0;
  }
#line 409
  alpha_first = tmp___1;
#line 411
  if (alpha_first) {
#line 411
    tmp___0 = 0;
  } else {
#line 411
    tmp___0 = 3;
  }
  {
#line 411
  dst = base_rgba + tmp___0;
#line 412
  num_lines_out = 0;
#line 413
  __cil_tmp12 = WebPIsPremultipliedMode(colorspace);
#line 413
  is_premult_alpha = __cil_tmp12;
#line 414
  non_opaque = (uint32_t )0;
#line 415
  width = (p->scaler_a)->dst_width;
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 417
    __cil_tmp15 = WebPRescalerHasPendingOutput(p->scaler_a);
    }
#line 417
    if (__cil_tmp15) {
#line 417
      if (! (num_lines_out < max_lines_out)) {
#line 417
        goto while_break;
      }
    } else {
#line 417
      goto while_break;
    }
    {
#line 420
    WebPRescalerExportRow(p->scaler_a);
#line 421
    __cil_tmp16 = (*WebPDispatchAlpha)((p->scaler_a)->dst, 0, width, 1, dst, 0);
#line 421
    non_opaque |= (unsigned int )__cil_tmp16;
#line 422
    dst += buf->stride;
#line 423
    num_lines_out ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 425
  if (is_premult_alpha) {
#line 425
    if (non_opaque) {
      {
#line 426
      (*WebPApplyAlphaMultiply)(base_rgba, alpha_first, width, num_lines_out, buf->stride);
      }
    }
  }
#line 429
  return (num_lines_out);
}
}
#line 432 "/root/patron-new/new_3/src/dec/io_dec.c"
static int ExportAlphaRGBA4444(WebPDecParams *p , int y_pos , int max_lines_out ) 
{ 
  WebPRGBABuffer *buf ;
  uint8_t *base_rgba ;
  uint8_t *alpha_dst ;
  int num_lines_out ;
  WEBP_CSP_MODE colorspace ;
  int width ;
  int is_premult_alpha ;
  int __cil_tmp11 ;
  uint32_t alpha_mask ;
  int __cil_tmp13 ;
  int i ;
  uint32_t alpha_value ;

  {
  {
#line 434
  buf = & (p->output)->u.RGBA;
#line 435
  base_rgba = buf->rgba + (size_t )y_pos * (unsigned long )buf->stride;
#line 439
  alpha_dst = base_rgba + 1;
#line 441
  num_lines_out = 0;
#line 442
  colorspace = (p->output)->colorspace;
#line 443
  width = (p->scaler_a)->dst_width;
#line 444
  __cil_tmp11 = WebPIsPremultipliedMode(colorspace);
#line 444
  is_premult_alpha = __cil_tmp11;
#line 445
  alpha_mask = (uint32_t )15;
  }
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 447
    __cil_tmp13 = WebPRescalerHasPendingOutput(p->scaler_a);
    }
#line 447
    if (__cil_tmp13) {
#line 447
      if (! (num_lines_out < max_lines_out)) {
#line 447
        goto while_break;
      }
    } else {
#line 447
      goto while_break;
    }
    {
#line 451
    WebPRescalerExportRow(p->scaler_a);
#line 452
    i = 0;
    }
    {
#line 452
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 452
      if (! (i < width)) {
#line 452
        goto while_break___0;
      }
#line 454
      alpha_value = (uint32_t )((int )*((p->scaler_a)->dst + i) >> 4);
#line 455
      *(alpha_dst + 2 * i) = (uint8_t )((unsigned int )((int )*(alpha_dst + 2 * i) & 240) | alpha_value);
#line 456
      alpha_mask &= alpha_value;
#line 452
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 458
    alpha_dst += buf->stride;
#line 459
    num_lines_out ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 461
  if (is_premult_alpha) {
#line 461
    if (alpha_mask != 15U) {
      {
#line 462
      (*WebPApplyAlphaMultiply4444)(base_rgba, width, num_lines_out, buf->stride);
      }
    }
  }
#line 464
  return (num_lines_out);
}
}
#line 467 "/root/patron-new/new_3/src/dec/io_dec.c"
static int EmitRescaledAlphaRGB(VP8Io *io , WebPDecParams *p , int expected_num_out_lines ) 
{ 
  WebPRescaler *scaler ;
  int lines_left ;
  int y_end ;
  int64_t row_offset ;
  int __cil_tmp8 ;

  {
#line 469
  if ((unsigned long )io->a != (unsigned long )((void *)0)) {
#line 470
    scaler = p->scaler_a;
#line 471
    lines_left = expected_num_out_lines;
#line 472
    y_end = p->last_y + lines_left;
    {
#line 473
    while (1) {
      while_continue: /* CIL Label */ ;

#line 473
      if (! (lines_left > 0)) {
#line 473
        goto while_break;
      }
      {
#line 474
      row_offset = (int64_t )scaler->src_y - (long )io->mb_y;
#line 475
      WebPRescalerImport(scaler, (io->mb_h + io->mb_y) - scaler->src_y, io->a + row_offset * (long )io->width,
                         io->width);
#line 477
      __cil_tmp8 = (*(p->emit_alpha_row))((WebPDecParams */* const  */)p, y_end - lines_left,
                                          lines_left);
#line 477
      lines_left -= __cil_tmp8;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 480
  return (0);
}
}
#line 483 "/root/patron-new/new_3/src/dec/io_dec.c"
static int InitRGBRescaler(VP8Io *io , WebPDecParams *p ) 
{ 
  int has_alpha ;
  int __cil_tmp4 ;
  int out_width ;
  int out_height ;
  int uv_in_width ;
  int uv_in_height ;
  size_t work_size ;
  rescaler_t *work ;
  uint8_t *tmp___0 ;
  uint64_t tmp_size1 ;
  uint64_t tmp_size2 ;
  uint64_t total_size ;
  size_t rescaler_size ;
  WebPRescaler *scalers ;
  int num_rescalers ;
  int tmp___23 ;
  WebPRescaler *tmp___24 ;

  {
  {
#line 484
  __cil_tmp4 = WebPIsAlphaMode((p->output)->colorspace);
#line 484
  has_alpha = __cil_tmp4;
#line 485
  out_width = io->scaled_width;
#line 486
  out_height = io->scaled_height;
#line 487
  uv_in_width = (io->mb_w + 1) >> 1;
#line 488
  uv_in_height = (io->mb_h + 1) >> 1;
#line 489
  work_size = (size_t )(2 * out_width);
  }
#line 495
  if (has_alpha) {
#line 495
    tmp___23 = 4;
  } else {
#line 495
    tmp___23 = 3;
  }
#line 495
  num_rescalers = tmp___23;
#line 497
  tmp_size1 = (uint64_t )num_rescalers * work_size;
#line 498
  tmp_size2 = (uint64_t )num_rescalers * (unsigned long )out_width;
#line 499
  total_size = tmp_size1 * sizeof(*work) + tmp_size2 * sizeof(*tmp___0);
#line 500
  rescaler_size = (unsigned long )num_rescalers * sizeof(*(p->scaler_y)) + 31UL;
#line 501
  total_size += rescaler_size;
#line 502
  if (total_size != total_size) {
#line 503
    return (0);
  }
  {
#line 506
  p->memory = WebPSafeMalloc((uint64_t )1ULL, total_size);
  }
#line 507
  if ((unsigned long )p->memory == (unsigned long )((void *)0)) {
#line 508
    return (0);
  }
#line 510
  work = (rescaler_t *)p->memory;
#line 511
  tmp___0 = (uint8_t *)(work + tmp_size1);
#line 513
  scalers = (WebPRescaler *)(((uintptr_t )(((uint8_t *)work + total_size) - rescaler_size) + 31UL) & 0xffffffffffffffe0UL);
#line 515
  p->scaler_y = scalers + 0;
#line 516
  p->scaler_u = scalers + 1;
#line 517
  p->scaler_v = scalers + 2;
#line 518
  if (has_alpha) {
#line 518
    tmp___24 = scalers + 3;
  } else {
#line 518
    tmp___24 = (WebPRescaler *)((void *)0);
  }
  {
#line 518
  p->scaler_a = tmp___24;
#line 520
  WebPRescalerInit(p->scaler_y, io->mb_w, io->mb_h, tmp___0 + 0, out_width, out_height,
                   0, 1, work + 0UL);
#line 523
  WebPRescalerInit(p->scaler_u, uv_in_width, uv_in_height, tmp___0 + out_width, out_width,
                   out_height, 0, 1, work + work_size);
#line 526
  WebPRescalerInit(p->scaler_v, uv_in_width, uv_in_height, tmp___0 + 2 * out_width,
                   out_width, out_height, 0, 1, work + 2UL * work_size);
#line 529
  p->emit = (int (*)(VP8Io * const   , WebPDecParams * const   ))(& EmitRescaledRGB);
#line 530
  WebPInitYUV444Converters();
  }
#line 532
  if (has_alpha) {
    {
#line 533
    WebPRescalerInit(p->scaler_a, io->mb_w, io->mb_h, tmp___0 + 3 * out_width, out_width,
                     out_height, 0, 1, work + 3UL * work_size);
#line 536
    p->emit_alpha = (int (*)(VP8Io * const   , WebPDecParams * const   , int  ))(& EmitRescaledAlphaRGB);
    }
#line 537
    if ((unsigned int )(p->output)->colorspace == 5U) {
#line 539
      p->emit_alpha_row = (int (*)(WebPDecParams * const   , int  , int  ))(& ExportAlphaRGBA4444);
    } else
#line 537
    if ((unsigned int )(p->output)->colorspace == 10U) {
#line 539
      p->emit_alpha_row = (int (*)(WebPDecParams * const   , int  , int  ))(& ExportAlphaRGBA4444);
    } else {
#line 541
      p->emit_alpha_row = (int (*)(WebPDecParams * const   , int  , int  ))(& ExportAlpha);
    }
    {
#line 543
    WebPInitAlphaProcessing();
    }
  }
#line 545
  return (1);
}
}
#line 553 "/root/patron-new/new_3/src/dec/io_dec.c"
static int CustomSetup(VP8Io *io ) 
{ 
  WebPDecParams *p ;
  WEBP_CSP_MODE colorspace ;
  int is_rgb ;
  int __cil_tmp5 ;
  int is_alpha ;
  int __cil_tmp7 ;
  int tmp___0 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int ok ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int tmp___1 ;
  int uv_width ;
  int (*tmp___2)(VP8Io * const  io , WebPDecParams * const  p , int expected_num_lines_out ) ;
  int (*tmp___3)(VP8Io * const  io , WebPDecParams * const  p , int expected_num_lines_out ) ;

  {
  {
#line 554
  p = (WebPDecParams *)io->opaque;
#line 555
  colorspace = (p->output)->colorspace;
#line 556
  __cil_tmp5 = WebPIsRGBMode(colorspace);
#line 556
  is_rgb = __cil_tmp5;
#line 557
  __cil_tmp7 = WebPIsAlphaMode(colorspace);
#line 557
  is_alpha = __cil_tmp7;
#line 559
  p->memory = (void *)0;
#line 560
  p->emit = (int (*)(VP8Io * const   , WebPDecParams * const   ))((void *)0);
#line 561
  p->emit_alpha = (int (*)(VP8Io * const   , WebPDecParams * const   , int  ))((void *)0);
#line 562
  p->emit_alpha_row = (int (*)(WebPDecParams * const   , int  , int  ))((void *)0);
  }
#line 563
  if (is_alpha) {
#line 563
    tmp___0 = 11;
  } else {
#line 563
    tmp___0 = 12;
  }
  {
#line 563
  __cil_tmp9 = WebPIoInitFromOptions(p->options, io, (WEBP_CSP_MODE )tmp___0);
  }
#line 563
  if (! __cil_tmp9) {
#line 564
    return (0);
  }
  {
#line 566
  __cil_tmp10 = WebPIsPremultipliedMode(colorspace);
  }
#line 566
  if (is_alpha) {
#line 566
    if (__cil_tmp10) {
      {
#line 567
      WebPInitUpsamplers();
      }
    }
  }
#line 569
  if (io->use_scaling) {
#line 571
    if (is_rgb) {
      {
#line 571
      __cil_tmp12 = InitRGBRescaler(io, p);
#line 571
      tmp___1 = __cil_tmp12;
      }
    } else {
      {
#line 571
      __cil_tmp13 = InitYUVRescaler(io, p);
#line 571
      tmp___1 = __cil_tmp13;
      }
    }
#line 571
    ok = tmp___1;
#line 572
    if (! ok) {
#line 573
      return (0);
    }
  } else {
#line 579
    if (is_rgb) {
      {
#line 580
      WebPInitSamplers();
#line 581
      p->emit = (int (*)(VP8Io * const   , WebPDecParams * const   ))(& EmitSampledRGB);
      }
#line 582
      if (io->fancy_upsampling) {
        {
#line 584
        uv_width = (io->mb_w + 1) >> 1;
#line 585
        p->memory = WebPSafeMalloc((uint64_t )1ULL, (size_t )(io->mb_w + 2 * uv_width));
        }
#line 586
        if ((unsigned long )p->memory == (unsigned long )((void *)0)) {
#line 587
          return (0);
        }
        {
#line 589
        p->tmp_y = (uint8_t *)p->memory;
#line 590
        p->tmp_u = p->tmp_y + io->mb_w;
#line 591
        p->tmp_v = p->tmp_u + uv_width;
#line 592
        p->emit = (int (*)(VP8Io * const   , WebPDecParams * const   ))(& EmitFancyRGB);
#line 593
        WebPInitUpsamplers();
        }
      }
    } else {
#line 597
      p->emit = (int (*)(VP8Io * const   , WebPDecParams * const   ))(& EmitYUV);
    }
#line 599
    if (is_alpha) {
#line 600
      if ((unsigned int )colorspace == 5U) {
#line 600
        tmp___3 = (int (*)(VP8Io * const  io , WebPDecParams * const  p , int expected_num_lines_out ))(& EmitAlphaRGBA4444);
      } else
#line 600
      if ((unsigned int )colorspace == 10U) {
#line 600
        tmp___3 = (int (*)(VP8Io * const  io , WebPDecParams * const  p , int expected_num_lines_out ))(& EmitAlphaRGBA4444);
      } else {
#line 600
        if (is_rgb) {
#line 600
          tmp___2 = (int (*)(VP8Io * const  io , WebPDecParams * const  p , int expected_num_lines_out ))(& EmitAlphaRGB);
        } else {
#line 600
          tmp___2 = (int (*)(VP8Io * const  io , WebPDecParams * const  p , int expected_num_lines_out ))(& EmitAlphaYUV);
        }
#line 600
        tmp___3 = tmp___2;
      }
#line 600
      p->emit_alpha = tmp___3;
#line 605
      if (is_rgb) {
        {
#line 606
        WebPInitAlphaProcessing();
        }
      }
    }
  }
#line 611
  return (1);
}
}
#line 616 "/root/patron-new/new_3/src/dec/io_dec.c"
static int CustomPut(VP8Io *io ) 
{ 
  WebPDecParams *p ;
  int mb_w ;
  int mb_h ;
  int num_lines_out ;

  {
#line 617
  p = (WebPDecParams *)io->opaque;
#line 618
  mb_w = io->mb_w;
#line 619
  mb_h = io->mb_h;
#line 623
  if (mb_w <= 0) {
#line 624
    return (0);
  } else
#line 623
  if (mb_h <= 0) {
#line 624
    return (0);
  }
  {
#line 626
  num_lines_out = (*(p->emit))((VP8Io */* const  */)io, (WebPDecParams */* const  */)p);
  }
#line 627
  if ((unsigned long )p->emit_alpha != (unsigned long )((void *)0)) {
    {
#line 628
    (*(p->emit_alpha))((VP8Io */* const  */)io, (WebPDecParams */* const  */)p, num_lines_out);
    }
  }
#line 630
  p->last_y += num_lines_out;
#line 631
  return (1);
}
}
#line 636 "/root/patron-new/new_3/src/dec/io_dec.c"
static void CustomTeardown(VP8Io *io ) 
{ 
  WebPDecParams *p ;

  {
  {
#line 637
  p = (WebPDecParams *)io->opaque;
#line 638
  WebPSafeFree(p->memory);
#line 639
  p->memory = (void *)0;
  }
#line 641
  return;
}
}
#line 645 "/root/patron-new/new_3/src/dec/io_dec.c"
void WebPInitCustomIo(WebPDecParams *params , VP8Io *io ) 
{ 


  {
#line 646
  io->put = & CustomPut;
#line 647
  io->setup = & CustomSetup;
#line 648
  io->teardown = & CustomTeardown;
#line 649
  io->opaque = (void *)params;
#line 650
  return;
}
}
#line 91 "/root/patron-new/new_3/src/dec/idec_dec.c"
__inline static size_t MemDataSize(MemBuffer *mem ) 
{ 


  {
#line 92
  return (mem->end_ - mem->start_);
}
}
#line 97 "/root/patron-new/new_3/src/dec/idec_dec.c"
static int NeedCompressedAlpha(WebPIDecoder *idec ) 
{ 
  VP8Decoder *dec ;
  int tmp___0 ;

  {
#line 98
  if ((unsigned int )idec->state_ == 0U) {
#line 101
    return (0);
  }
#line 103
  if (idec->is_lossless_) {
#line 104
    return (0);
  } else {
#line 106
    dec = (VP8Decoder *)idec->dec_;
#line 108
    if ((unsigned long )dec->alpha_data_ != (unsigned long )((void *)0)) {
#line 108
      if (! dec->is_alpha_decoded_) {
#line 108
        tmp___0 = 1;
      } else {
#line 108
        tmp___0 = 0;
      }
    } else {
#line 108
      tmp___0 = 0;
    }
#line 108
    return (tmp___0);
  }
}
}
#line 112 "/root/patron-new/new_3/src/dec/idec_dec.c"
static void DoRemap(WebPIDecoder *idec , ptrdiff_t offset ) 
{ 
  MemBuffer *mem ;
  uint8_t *new_base ;
  VP8Decoder *dec ;
  uint32_t last_part ;
  uint32_t p ;
  uint8_t *last_start ;
  int __cil_tmp10 ;
  ALPHDecoder *alph_dec ;
  VP8LDecoder *alph_vp8l_dec ;
  VP8LDecoder *dec___0 ;
  size_t __cil_tmp14 ;

  {
  {
#line 113
  mem = & idec->mem_;
#line 114
  new_base = mem->buf_ + mem->start_;
#line 117
  idec->io_.data = new_base;
#line 118
  idec->io_.data_size = MemDataSize(mem);
  }
#line 120
  if ((unsigned long )idec->dec_ != (unsigned long )((void *)0)) {
#line 121
    if (! idec->is_lossless_) {
#line 122
      dec = (VP8Decoder *)idec->dec_;
#line 123
      last_part = dec->num_parts_minus_one_;
#line 124
      if (offset != 0L) {
#line 126
        p = (uint32_t )0;
        {
#line 126
        while (1) {
          while_continue: /* CIL Label */ ;

#line 126
          if (! (p <= last_part)) {
#line 126
            goto while_break;
          }
          {
#line 127
          VP8RemapBitReader(dec->parts_ + p, offset);
#line 126
          p ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        while_break: ;
#line 131
        if ((unsigned int )mem->mode_ == 2U) {
          {
#line 132
          VP8RemapBitReader(& dec->br_, offset);
          }
        }
      }
      {
#line 136
      last_start = dec->parts_[last_part].buf_;
#line 137
      VP8BitReaderSetBuffer(& dec->parts_[last_part], last_start, (size_t )((mem->buf_ + mem->end_) - last_start));
#line 140
      __cil_tmp10 = NeedCompressedAlpha(idec);
      }
#line 140
      if (__cil_tmp10) {
#line 141
        alph_dec = dec->alph_dec_;
#line 142
        dec->alpha_data_ += offset;
#line 143
        if ((unsigned long )alph_dec != (unsigned long )((void *)0)) {
#line 143
          if ((unsigned long )alph_dec->vp8l_dec_ != (unsigned long )((void *)0)) {
#line 144
            if (alph_dec->method_ == 1) {
              {
#line 145
              alph_vp8l_dec = alph_dec->vp8l_dec_;
#line 147
              VP8LBitReaderSetBuffer(& alph_vp8l_dec->br_, dec->alpha_data_ + 1, dec->alpha_data_size_ - 1UL);
              }
            }
          }
        }
      }
    } else {
      {
#line 156
      dec___0 = (VP8LDecoder *)idec->dec_;
#line 157
      __cil_tmp14 = MemDataSize(mem);
#line 157
      VP8LBitReaderSetBuffer(& dec___0->br_, new_base, __cil_tmp14);
      }
    }
  }
#line 161
  return;
}
}
#line 164 "/root/patron-new/new_3/src/dec/idec_dec.c"
static int AppendToMemBuffer(WebPIDecoder *idec , uint8_t *data , size_t data_size ) 
{ 
  VP8Decoder *dec ;
  MemBuffer *mem ;
  int need_compressed_alpha ;
  int __cil_tmp7 ;
  uint8_t *old_start ;
  uint8_t *tmp___0 ;
  uint8_t *old_base ;
  uint8_t *tmp___1 ;
  size_t new_mem_start ;
  size_t current_size ;
  size_t __cil_tmp14 ;
  uint64_t new_size ;
  uint64_t extra_size ;
  uint8_t *new_buf ;
  void *__cil_tmp18 ;

  {
  {
#line 166
  dec = (VP8Decoder *)idec->dec_;
#line 167
  mem = & idec->mem_;
#line 168
  __cil_tmp7 = NeedCompressedAlpha(idec);
#line 168
  need_compressed_alpha = __cil_tmp7;
  }
#line 169
  if ((unsigned long )mem->buf_ == (unsigned long )((void *)0)) {
#line 169
    tmp___0 = (uint8_t *)((void *)0);
  } else {
#line 169
    tmp___0 = mem->buf_ + mem->start_;
  }
#line 169
  old_start = tmp___0;
#line 171
  if (need_compressed_alpha) {
#line 171
    tmp___1 = dec->alpha_data_;
  } else {
#line 171
    tmp___1 = old_start;
  }
#line 171
  old_base = tmp___1;
#line 175
  if (data_size > 4294967286UL) {
#line 178
    return (0);
  }
#line 181
  if (mem->end_ + data_size > mem->buf_size_) {
    {
#line 182
    new_mem_start = (size_t )(old_start - old_base);
#line 183
    __cil_tmp14 = MemDataSize(mem);
#line 183
    current_size = __cil_tmp14 + new_mem_start;
#line 184
    new_size = current_size + data_size;
#line 185
    extra_size = ((new_size + 4096UL) - 1UL) & 0xfffffffffffff000UL;
#line 186
    __cil_tmp18 = WebPSafeMalloc(extra_size, sizeof(*new_buf));
#line 186
    new_buf = (uint8_t *)__cil_tmp18;
    }
#line 188
    if ((unsigned long )new_buf == (unsigned long )((void *)0)) {
#line 188
      return (0);
    }
#line 189
    if ((unsigned long )old_base != (unsigned long )((void *)0)) {
      {
#line 189
      memcpy((void *)new_buf, (void const   *)old_base, current_size);
      }
    }
    {
#line 190
    WebPSafeFree((void *)mem->buf_);
#line 191
    mem->buf_ = new_buf;
#line 192
    mem->buf_size_ = extra_size;
#line 193
    mem->start_ = new_mem_start;
#line 194
    mem->end_ = current_size;
    }
  }
  {
#line 198
  memcpy((void *)(mem->buf_ + mem->end_), (void const   *)data, data_size);
#line 199
  mem->end_ += data_size;
#line 202
  DoRemap(idec, (mem->buf_ + mem->start_) - old_start);
  }
#line 203
  return (1);
}
}
#line 206 "/root/patron-new/new_3/src/dec/idec_dec.c"
static int RemapMemBuffer(WebPIDecoder *idec , uint8_t *data , size_t data_size ) 
{ 
  MemBuffer *mem ;
  uint8_t *old_buf ;
  uint8_t *old_start ;
  uint8_t *tmp___0 ;

  {
#line 208
  mem = & idec->mem_;
#line 209
  old_buf = mem->buf_;
#line 210
  if ((unsigned long )old_buf == (unsigned long )((void *)0)) {
#line 210
    tmp___0 = (uint8_t *)((void *)0);
  } else {
#line 210
    tmp___0 = old_buf + mem->start_;
  }
#line 210
  old_start = tmp___0;
#line 215
  if (data_size < mem->buf_size_) {
#line 215
    return (0);
  }
  {
#line 217
  mem->buf_ = data;
#line 218
  mem->buf_size_ = data_size;
#line 218
  mem->end_ = mem->buf_size_;
#line 220
  DoRemap(idec, (mem->buf_ + mem->start_) - old_start);
  }
#line 221
  return (1);
}
}
#line 224 "/root/patron-new/new_3/src/dec/idec_dec.c"
static void InitMemBuffer(MemBuffer *mem ) 
{ 


  {
#line 225
  mem->mode_ = (MemBufferMode )0;
#line 226
  mem->buf_ = (uint8_t *)((void *)0);
#line 227
  mem->buf_size_ = (size_t )0;
#line 228
  mem->part0_buf_ = (uint8_t *)((void *)0);
#line 229
  mem->part0_size_ = (size_t )0;
#line 230
  return;
}
}
#line 232 "/root/patron-new/new_3/src/dec/idec_dec.c"
static void ClearMemBuffer(MemBuffer *mem ) 
{ 


  {
#line 234
  if ((unsigned int )mem->mode_ == 1U) {
    {
#line 235
    WebPSafeFree((void *)mem->buf_);
#line 236
    WebPSafeFree((void *)mem->part0_buf_);
    }
  }
#line 239
  return;
}
}
#line 240 "/root/patron-new/new_3/src/dec/idec_dec.c"
static int CheckMemBufferMode(MemBuffer *mem , MemBufferMode expected ) 
{ 


  {
#line 241
  if ((unsigned int )mem->mode_ == 0U) {
#line 242
    mem->mode_ = expected;
  } else
#line 243
  if ((unsigned int )mem->mode_ != (unsigned int )expected) {
#line 244
    return (0);
  }
#line 247
  return (1);
}
}
#line 251 "/root/patron-new/new_3/src/dec/idec_dec.c"
static VP8StatusCode FinishDecoding(WebPIDecoder *idec ) 
{ 
  WebPDecoderOptions *options ;
  WebPDecBuffer *output ;
  VP8StatusCode status ;
  VP8StatusCode __cil_tmp5 ;

  {
#line 252
  options = idec->params_.options;
#line 253
  output = idec->params_.output;
#line 255
  idec->state_ = (DecState )6;
#line 256
  if ((unsigned long )options != (unsigned long )((void *)0)) {
#line 256
    if (options->flip) {
      {
#line 257
      __cil_tmp5 = WebPFlipBuffer(output);
#line 257
      status = __cil_tmp5;
      }
#line 258
      if ((unsigned int )status != 0U) {
#line 258
        return (status);
      }
    }
  }
#line 260
  if ((unsigned long )idec->final_output_ != (unsigned long )((void *)0)) {
    {
#line 261
    WebPCopyDecBufferPixels(output, idec->final_output_);
#line 262
    WebPFreeDecBuffer(& idec->output_);
#line 263
    *output = *(idec->final_output_);
#line 264
    idec->final_output_ = (WebPDecBuffer *)((void *)0);
    }
  }
#line 266
  return ((VP8StatusCode )0);
}
}
#line 272 "/root/patron-new/new_3/src/dec/idec_dec.c"
static void SaveContext(VP8Decoder *dec , VP8BitReader *token_br , MBContext *context ) 
{ 


  {
#line 274
  context->left_ = *(dec->mb_info_ + -1);
#line 275
  context->info_ = *(dec->mb_info_ + dec->mb_x_);
#line 276
  context->token_br_ = *token_br;
#line 277
  return;
}
}
#line 279 "/root/patron-new/new_3/src/dec/idec_dec.c"
static void RestoreContext(MBContext *context , VP8Decoder *dec , VP8BitReader *token_br ) 
{ 


  {
#line 281
  *(dec->mb_info_ + -1) = context->left_;
#line 282
  *(dec->mb_info_ + dec->mb_x_) = context->info_;
#line 283
  *token_br = context->token_br_;
#line 284
  return;
}
}
#line 288 "/root/patron-new/new_3/src/dec/idec_dec.c"
static VP8StatusCode IDecError(WebPIDecoder *idec , VP8StatusCode error ) 
{ 


  {
#line 289
  if ((unsigned int )idec->state_ == 3U) {
    {
#line 291
    VP8ExitCritical((VP8Decoder *)idec->dec_, & idec->io_);
    }
  }
#line 293
  idec->state_ = (DecState )7;
#line 294
  return (error);
}
}
#line 297 "/root/patron-new/new_3/src/dec/idec_dec.c"
static void ChangeState___0(WebPIDecoder *idec , DecState new_state , size_t consumed_bytes ) 
{ 
  MemBuffer *mem ;

  {
  {
#line 299
  mem = & idec->mem_;
#line 300
  idec->state_ = new_state;
#line 301
  mem->start_ += consumed_bytes;
#line 303
  idec->io_.data = mem->buf_ + mem->start_;
#line 304
  idec->io_.data_size = MemDataSize(mem);
  }
#line 306
  return;
}
}
#line 308 "/root/patron-new/new_3/src/dec/idec_dec.c"
static VP8StatusCode DecodeWebPHeaders(WebPIDecoder *idec ) 
{ 
  MemBuffer *mem ;
  uint8_t *data ;
  size_t curr_size ;
  size_t __cil_tmp5 ;
  VP8StatusCode status ;
  WebPHeaderStructure headers ;
  VP8StatusCode __cil_tmp9 ;
  VP8Decoder *dec ;
  VP8Decoder *__cil_tmp11 ;
  VP8LDecoder *dec___0 ;
  VP8LDecoder *__cil_tmp13 ;

  {
  {
#line 309
  mem = & idec->mem_;
#line 310
  data = mem->buf_ + mem->start_;
#line 311
  __cil_tmp5 = MemDataSize(mem);
#line 311
  curr_size = __cil_tmp5;
#line 315
  headers.data = data;
#line 316
  headers.data_size = curr_size;
#line 317
  headers.have_all_data = 0;
#line 318
  status = WebPParseHeaders(& headers);
  }
#line 319
  if ((unsigned int )status == 7U) {
#line 320
    return ((VP8StatusCode )5);
  } else
#line 321
  if ((unsigned int )status != 0U) {
    {
#line 322
    __cil_tmp9 = IDecError(idec, status);
    }
#line 322
    return (__cil_tmp9);
  }
#line 325
  idec->chunk_size_ = headers.compressed_size;
#line 326
  idec->is_lossless_ = headers.is_lossless;
#line 327
  if (! idec->is_lossless_) {
    {
#line 328
    __cil_tmp11 = VP8New();
#line 328
    dec = __cil_tmp11;
    }
#line 329
    if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 330
      return ((VP8StatusCode )1);
    }
    {
#line 332
    idec->dec_ = (void *)dec;
#line 333
    dec->alpha_data_ = headers.alpha_data;
#line 334
    dec->alpha_data_size_ = headers.alpha_data_size;
#line 335
    ChangeState___0(idec, (DecState )1, headers.offset);
    }
  } else {
    {
#line 337
    __cil_tmp13 = VP8LNew();
#line 337
    dec___0 = __cil_tmp13;
    }
#line 338
    if ((unsigned long )dec___0 == (unsigned long )((void *)0)) {
#line 339
      return ((VP8StatusCode )1);
    }
    {
#line 341
    idec->dec_ = (void *)dec___0;
#line 342
    ChangeState___0(idec, (DecState )4, headers.offset);
    }
  }
#line 344
  return ((VP8StatusCode )0);
}
}
#line 347 "/root/patron-new/new_3/src/dec/idec_dec.c"
static VP8StatusCode DecodeVP8FrameHeader(WebPIDecoder *idec ) 
{ 
  uint8_t *data ;
  size_t curr_size ;
  size_t __cil_tmp4 ;
  int width ;
  int height ;
  uint32_t bits ;
  int __cil_tmp8 ;
  VP8StatusCode __cil_tmp9 ;

  {
  {
#line 348
  data = idec->mem_.buf_ + idec->mem_.start_;
#line 349
  __cil_tmp4 = MemDataSize(& idec->mem_);
#line 349
  curr_size = __cil_tmp4;
  }
#line 353
  if (curr_size < 10UL) {
#line 355
    return ((VP8StatusCode )5);
  }
  {
#line 357
  __cil_tmp8 = VP8GetInfo(data, curr_size, idec->chunk_size_, & width, & height);
  }
#line 357
  if (! __cil_tmp8) {
    {
#line 358
    __cil_tmp9 = IDecError(idec, (VP8StatusCode )3);
    }
#line 358
    return (__cil_tmp9);
  }
#line 361
  bits = (uint32_t )(((int )*(data + 0) | ((int )*(data + 1) << 8)) | ((int )*(data + 2) << 16));
#line 362
  idec->mem_.part0_size_ = (size_t )((bits >> 5) + 10U);
#line 364
  idec->io_.data = data;
#line 365
  idec->io_.data_size = curr_size;
#line 366
  idec->state_ = (DecState )2;
#line 367
  return ((VP8StatusCode )0);
}
}
#line 371 "/root/patron-new/new_3/src/dec/idec_dec.c"
static VP8StatusCode CopyParts0Data(WebPIDecoder *idec ) 
{ 
  VP8Decoder *dec ;
  VP8BitReader *br ;
  size_t part_size ;
  MemBuffer *mem ;
  uint8_t *part0_buf ;
  void *__cil_tmp7 ;

  {
#line 372
  dec = (VP8Decoder *)idec->dec_;
#line 373
  br = & dec->br_;
#line 374
  part_size = (size_t )(br->buf_end_ - br->buf_);
#line 375
  mem = & idec->mem_;
#line 380
  if (part_size == 0UL) {
#line 381
    return ((VP8StatusCode )3);
  }
#line 383
  if ((unsigned int )mem->mode_ == 1U) {
    {
#line 385
    __cil_tmp7 = WebPSafeMalloc((uint64_t )1ULL, part_size);
#line 385
    part0_buf = (uint8_t *)__cil_tmp7;
    }
#line 386
    if ((unsigned long )part0_buf == (unsigned long )((void *)0)) {
#line 387
      return ((VP8StatusCode )1);
    }
    {
#line 389
    memcpy((void *)part0_buf, (void const   *)br->buf_, part_size);
#line 390
    mem->part0_buf_ = part0_buf;
#line 391
    VP8BitReaderSetBuffer(br, part0_buf, part_size);
    }
  }
#line 395
  mem->start_ += part_size;
#line 396
  return ((VP8StatusCode )0);
}
}
#line 399 "/root/patron-new/new_3/src/dec/idec_dec.c"
static VP8StatusCode DecodePartition0(WebPIDecoder *idec ) 
{ 
  VP8Decoder *dec ;
  VP8Io *io ;
  WebPDecParams *params ;
  WebPDecBuffer *output ;
  size_t __cil_tmp6 ;
  int __cil_tmp7 ;
  VP8StatusCode status ;
  VP8StatusCode __cil_tmp9 ;
  VP8StatusCode __cil_tmp11 ;
  VP8StatusCode __cil_tmp14 ;
  VP8StatusCode __cil_tmp15 ;
  VP8StatusCode __cil_tmp16 ;
  int __cil_tmp17 ;
  VP8StatusCode __cil_tmp18 ;

  {
  {
#line 400
  dec = (VP8Decoder *)idec->dec_;
#line 401
  io = & idec->io_;
#line 402
  params = & idec->params_;
#line 403
  output = params->output;
#line 406
  __cil_tmp6 = MemDataSize(& idec->mem_);
  }
#line 406
  if (__cil_tmp6 < idec->mem_.part0_size_) {
#line 407
    return ((VP8StatusCode )5);
  }
  {
#line 410
  __cil_tmp7 = VP8GetHeaders(dec, io);
  }
#line 410
  if (! __cil_tmp7) {
#line 411
    status = dec->status_;
#line 412
    if ((unsigned int )status == 5U) {
#line 415
      return ((VP8StatusCode )5);
    } else
#line 412
    if ((unsigned int )status == 7U) {
#line 415
      return ((VP8StatusCode )5);
    }
    {
#line 417
    __cil_tmp9 = IDecError(idec, status);
    }
#line 417
    return (__cil_tmp9);
  }
  {
#line 421
  dec->status_ = WebPAllocateDecBuffer(io->width, io->height, params->options, output);
  }
#line 423
  if ((unsigned int )dec->status_ != 0U) {
    {
#line 424
    __cil_tmp11 = IDecError(idec, dec->status_);
    }
#line 424
    return (__cil_tmp11);
  }
  {
#line 427
  dec->mt_method_ = VP8GetThreadMethod(params->options, (WebPHeaderStructure *)((void *)0),
                                       io->width, io->height);
#line 429
  VP8InitDithering(params->options, dec);
#line 431
  dec->status_ = CopyParts0Data(idec);
  }
#line 432
  if ((unsigned int )dec->status_ != 0U) {
    {
#line 433
    __cil_tmp14 = IDecError(idec, dec->status_);
    }
#line 433
    return (__cil_tmp14);
  }
  {
#line 437
  __cil_tmp15 = VP8EnterCritical(dec, io);
  }
#line 437
  if ((unsigned int )__cil_tmp15 != 0U) {
    {
#line 438
    __cil_tmp16 = IDecError(idec, dec->status_);
    }
#line 438
    return (__cil_tmp16);
  }
  {
#line 443
  idec->state_ = (DecState )3;
#line 445
  __cil_tmp17 = VP8InitFrame(dec, io);
  }
#line 445
  if (! __cil_tmp17) {
    {
#line 446
    __cil_tmp18 = IDecError(idec, dec->status_);
    }
#line 446
    return (__cil_tmp18);
  }
#line 448
  return ((VP8StatusCode )0);
}
}
#line 452 "/root/patron-new/new_3/src/dec/idec_dec.c"
static VP8StatusCode DecodeRemaining(WebPIDecoder *idec ) 
{ 
  VP8Decoder *dec ;
  VP8Io *io ;
  VP8StatusCode __cil_tmp4 ;
  int __cil_tmp5 ;
  VP8StatusCode __cil_tmp6 ;
  VP8BitReader *token_br ;
  MBContext context ;
  int __cil_tmp9 ;
  size_t __cil_tmp10 ;
  VP8StatusCode __cil_tmp11 ;
  WebPWorkerInterface *__cil_tmp12 ;
  int __cil_tmp13 ;
  VP8StatusCode __cil_tmp14 ;
  int __cil_tmp15 ;
  VP8StatusCode __cil_tmp16 ;
  int __cil_tmp17 ;
  VP8StatusCode __cil_tmp18 ;
  VP8StatusCode __cil_tmp19 ;

  {
#line 453
  dec = (VP8Decoder *)idec->dec_;
#line 454
  io = & idec->io_;
#line 457
  if (! dec->ready_) {
    {
#line 458
    __cil_tmp4 = IDecError(idec, (VP8StatusCode )3);
    }
#line 458
    return (__cil_tmp4);
  }
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;

#line 460
    if (! (dec->mb_y_ < dec->mb_h_)) {
#line 460
      goto while_break;
    }
#line 461
    if (idec->last_mb_y_ != dec->mb_y_) {
      {
#line 462
      __cil_tmp5 = VP8ParseIntraModeRow(& dec->br_, dec);
      }
#line 462
      if (! __cil_tmp5) {
        {
#line 466
        __cil_tmp6 = IDecError(idec, (VP8StatusCode )3);
        }
#line 466
        return (__cil_tmp6);
      }
#line 468
      idec->last_mb_y_ = dec->mb_y_;
    }
    {
#line 470
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 470
      if (! (dec->mb_x_ < dec->mb_w_)) {
#line 470
        goto while_break___0;
      }
      {
#line 471
      token_br = & dec->parts_[(unsigned int )dec->mb_y_ & dec->num_parts_minus_one_];
#line 474
      SaveContext(dec, token_br, & context);
#line 475
      __cil_tmp9 = VP8DecodeMB(dec, token_br);
      }
#line 475
      if (! __cil_tmp9) {
        {
#line 477
        __cil_tmp10 = MemDataSize(& idec->mem_);
        }
#line 477
        if (dec->num_parts_minus_one_ == 0U) {
#line 477
          if (__cil_tmp10 > 4096UL) {
            {
#line 479
            __cil_tmp11 = IDecError(idec, (VP8StatusCode )3);
            }
#line 479
            return (__cil_tmp11);
          }
        }
#line 482
        if (dec->mt_method_ > 0) {
          {
#line 483
          __cil_tmp13 = (*(__cil_tmp12->Sync))((WebPWorker */* const  */)(& dec->worker_));
          }
#line 483
          if (! __cil_tmp13) {
            {
#line 484
            __cil_tmp14 = IDecError(idec, (VP8StatusCode )3);
            }
#line 484
            return (__cil_tmp14);
          }
        }
        {
#line 487
        RestoreContext(& context, dec, token_br);
        }
#line 488
        return ((VP8StatusCode )5);
      }
#line 491
      if (dec->num_parts_minus_one_ == 0U) {
#line 492
        idec->mem_.start_ = (size_t )(token_br->buf_ - idec->mem_.buf_);
      }
#line 470
      (dec->mb_x_) ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 496
    VP8InitScanline(dec);
#line 499
    __cil_tmp15 = VP8ProcessRow(dec, io);
    }
#line 499
    if (! __cil_tmp15) {
      {
#line 500
      __cil_tmp16 = IDecError(idec, (VP8StatusCode )6);
      }
#line 500
      return (__cil_tmp16);
    }
#line 460
    (dec->mb_y_) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 504
  __cil_tmp17 = VP8ExitCritical(dec, io);
  }
#line 504
  if (! __cil_tmp17) {
    {
#line 505
    idec->state_ = (DecState )7;
#line 506
    __cil_tmp18 = IDecError(idec, (VP8StatusCode )6);
    }
#line 506
    return (__cil_tmp18);
  }
  {
#line 508
  dec->ready_ = 0;
#line 509
  __cil_tmp19 = FinishDecoding(idec);
  }
#line 509
  return (__cil_tmp19);
}
}
#line 512 "/root/patron-new/new_3/src/dec/idec_dec.c"
static VP8StatusCode ErrorStatusLossless(WebPIDecoder *idec , VP8StatusCode status ) 
{ 
  VP8StatusCode __cil_tmp3 ;

  {
#line 514
  if ((unsigned int )status == 5U) {
#line 515
    return ((VP8StatusCode )5);
  } else
#line 514
  if ((unsigned int )status == 7U) {
#line 515
    return ((VP8StatusCode )5);
  }
  {
#line 517
  __cil_tmp3 = IDecError(idec, status);
  }
#line 517
  return (__cil_tmp3);
}
}
#line 520 "/root/patron-new/new_3/src/dec/idec_dec.c"
static VP8StatusCode DecodeVP8LHeader(WebPIDecoder *idec ) 
{ 
  VP8Io *io ;
  VP8LDecoder *dec ;
  WebPDecParams *params ;
  WebPDecBuffer *output ;
  size_t curr_size ;
  size_t __cil_tmp7 ;
  VP8StatusCode __cil_tmp8 ;
  int __cil_tmp9 ;
  VP8StatusCode __cil_tmp10 ;
  VP8StatusCode __cil_tmp12 ;

  {
  {
#line 521
  io = & idec->io_;
#line 522
  dec = (VP8LDecoder *)idec->dec_;
#line 523
  params = & idec->params_;
#line 524
  output = params->output;
#line 525
  __cil_tmp7 = MemDataSize(& idec->mem_);
#line 525
  curr_size = __cil_tmp7;
  }
#line 529
  if (curr_size < idec->chunk_size_ >> 3) {
    {
#line 530
    dec->status_ = (VP8StatusCode )5;
#line 531
    __cil_tmp8 = ErrorStatusLossless(idec, dec->status_);
    }
#line 531
    return (__cil_tmp8);
  }
  {
#line 534
  __cil_tmp9 = VP8LDecodeHeader(dec, io);
  }
#line 534
  if (! __cil_tmp9) {
#line 535
    if ((unsigned int )dec->status_ == 3U) {
#line 535
      if (curr_size < idec->chunk_size_) {
#line 537
        dec->status_ = (VP8StatusCode )5;
      }
    }
    {
#line 539
    __cil_tmp10 = ErrorStatusLossless(idec, dec->status_);
    }
#line 539
    return (__cil_tmp10);
  }
  {
#line 542
  dec->status_ = WebPAllocateDecBuffer(io->width, io->height, params->options, output);
  }
#line 544
  if ((unsigned int )dec->status_ != 0U) {
    {
#line 545
    __cil_tmp12 = IDecError(idec, dec->status_);
    }
#line 545
    return (__cil_tmp12);
  }
#line 548
  idec->state_ = (DecState )5;
#line 549
  return ((VP8StatusCode )0);
}
}
#line 552 "/root/patron-new/new_3/src/dec/idec_dec.c"
static VP8StatusCode DecodeVP8LData(WebPIDecoder *idec ) 
{ 
  VP8LDecoder *dec ;
  size_t curr_size ;
  size_t __cil_tmp4 ;
  int __cil_tmp5 ;
  VP8StatusCode __cil_tmp6 ;
  VP8StatusCode __cil_tmp7 ;
  unsigned int tmp___0 ;

  {
  {
#line 553
  dec = (VP8LDecoder *)idec->dec_;
#line 554
  __cil_tmp4 = MemDataSize(& idec->mem_);
#line 554
  curr_size = __cil_tmp4;
#line 558
  dec->incremental_ = curr_size < idec->chunk_size_;
#line 560
  __cil_tmp5 = VP8LDecodeImage(dec);
  }
#line 560
  if (! __cil_tmp5) {
    {
#line 561
    __cil_tmp6 = ErrorStatusLossless(idec, dec->status_);
    }
#line 561
    return (__cil_tmp6);
  }
#line 564
  if ((unsigned int )dec->status_ == 5U) {
#line 564
    tmp___0 = (unsigned int )dec->status_;
  } else {
    {
#line 564
    __cil_tmp7 = FinishDecoding(idec);
#line 564
    tmp___0 = (unsigned int )__cil_tmp7;
    }
  }
#line 564
  return ((VP8StatusCode )tmp___0);
}
}
#line 569 "/root/patron-new/new_3/src/dec/idec_dec.c"
static VP8StatusCode IDecode(WebPIDecoder *idec ) 
{ 
  VP8StatusCode status ;
  VP8Decoder *dec ;

  {
#line 570
  status = (VP8StatusCode )5;
#line 572
  if ((unsigned int )idec->state_ == 0U) {
    {
#line 573
    status = DecodeWebPHeaders(idec);
    }
  } else
#line 575
  if ((unsigned long )idec->dec_ == (unsigned long )((void *)0)) {
#line 576
    return ((VP8StatusCode )5);
  }
#line 579
  if ((unsigned int )idec->state_ == 1U) {
    {
#line 580
    status = DecodeVP8FrameHeader(idec);
    }
  }
#line 582
  if ((unsigned int )idec->state_ == 2U) {
    {
#line 583
    status = DecodePartition0(idec);
    }
  }
#line 585
  if ((unsigned int )idec->state_ == 3U) {
#line 586
    dec = (VP8Decoder *)idec->dec_;
#line 587
    if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 588
      return ((VP8StatusCode )5);
    }
    {
#line 590
    status = DecodeRemaining(idec);
    }
  }
#line 592
  if ((unsigned int )idec->state_ == 4U) {
    {
#line 593
    status = DecodeVP8LHeader(idec);
    }
  }
#line 595
  if ((unsigned int )idec->state_ == 5U) {
    {
#line 596
    status = DecodeVP8LData(idec);
    }
  }
#line 598
  return (status);
}
}
#line 604 "/root/patron-new/new_3/src/dec/idec_dec.c"
static WebPIDecoder *NewDecoder(WebPDecBuffer *output_buffer , WebPBitstreamFeatures *features ) 
{ 
  WebPIDecoder *idec ;
  void *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 606
  __cil_tmp4 = WebPSafeCalloc((uint64_t )1ULL, sizeof(*idec));
#line 606
  idec = (WebPIDecoder *)__cil_tmp4;
  }
#line 607
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 608
    return ((WebPIDecoder *)((void *)0));
  }
  {
#line 611
  idec->state_ = (DecState )0;
#line 612
  idec->chunk_size_ = (size_t )0;
#line 614
  idec->last_mb_y_ = -1;
#line 616
  InitMemBuffer(& idec->mem_);
#line 617
  WebPInitDecBuffer(& idec->output_);
#line 618
  VP8InitIo(& idec->io_);
#line 620
  WebPResetDecParams(& idec->params_);
#line 621
  __cil_tmp5 = WebPAvoidSlowMemory(output_buffer, features);
  }
#line 621
  if ((unsigned long )output_buffer == (unsigned long )((void *)0)) {
    _L: 
#line 622
    idec->params_.output = & idec->output_;
#line 623
    idec->final_output_ = output_buffer;
#line 624
    if ((unsigned long )output_buffer != (unsigned long )((void *)0)) {
#line 625
      (idec->params_.output)->colorspace = output_buffer->colorspace;
    }
  } else
#line 621
  if (__cil_tmp5) {
#line 621
    goto _L;
  } else {
#line 628
    idec->params_.output = output_buffer;
#line 629
    idec->final_output_ = (WebPDecBuffer *)((void *)0);
  }
  {
#line 631
  WebPInitCustomIo(& idec->params_, & idec->io_);
  }
#line 633
  return (idec);
}
}
#line 639 "/root/patron-new/new_3/src/dec/idec_dec.c"
WebPIDecoder *WebPINewDecoder(WebPDecBuffer *output_buffer ) 
{ 
  WebPIDecoder *__cil_tmp2 ;

  {
  {
#line 640
  __cil_tmp2 = NewDecoder(output_buffer, (WebPBitstreamFeatures *)((void *)0));
  }
#line 640
  return (__cil_tmp2);
}
}
#line 643 "/root/patron-new/new_3/src/dec/idec_dec.c"
WebPIDecoder *WebPIDecode(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) 
{ 
  WebPIDecoder *idec ;
  WebPBitstreamFeatures tmp_features ;
  WebPBitstreamFeatures *features ;
  WebPBitstreamFeatures *tmp___0 ;
  VP8StatusCode __cil_tmp8 ;
  WebPIDecoder *__cil_tmp9 ;
  WebPIDecoder *__cil_tmp10 ;
  WebPIDecoder *tmp___1 ;

  {
#line 647
  if ((unsigned long )config == (unsigned long )((void *)0)) {
#line 647
    tmp___0 = & tmp_features;
  } else {
#line 647
    tmp___0 = & config->input;
  }
  {
#line 647
  features = tmp___0;
#line 649
  memset((void *)(& tmp_features), 0, sizeof(tmp_features));
  }
#line 652
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 652
    if (data_size > 0UL) {
      {
#line 653
      __cil_tmp8 = WebPGetFeatures(data, data_size, features);
      }
#line 653
      if ((unsigned int )__cil_tmp8 != 0U) {
#line 654
        return ((WebPIDecoder *)((void *)0));
      }
    }
  }
#line 659
  if ((unsigned long )config != (unsigned long )((void *)0)) {
    {
#line 659
    __cil_tmp9 = NewDecoder(& config->output, features);
#line 659
    tmp___1 = __cil_tmp9;
    }
  } else {
    {
#line 659
    __cil_tmp10 = NewDecoder((WebPDecBuffer *)((void *)0), features);
#line 659
    tmp___1 = __cil_tmp10;
    }
  }
#line 659
  idec = tmp___1;
#line 661
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 662
    return ((WebPIDecoder *)((void *)0));
  }
#line 665
  if ((unsigned long )config != (unsigned long )((void *)0)) {
#line 666
    idec->params_.options = & config->options;
  }
#line 668
  return (idec);
}
}
#line 671 "/root/patron-new/new_3/src/dec/idec_dec.c"
void WebPIDelete(WebPIDecoder *idec ) 
{ 


  {
#line 672
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 672
    return;
  }
#line 673
  if ((unsigned long )idec->dec_ != (unsigned long )((void *)0)) {
#line 674
    if (! idec->is_lossless_) {
#line 675
      if ((unsigned int )idec->state_ == 3U) {
        {
#line 677
        VP8ExitCritical((VP8Decoder *)idec->dec_, & idec->io_);
        }
      }
      {
#line 679
      VP8Delete((VP8Decoder *)idec->dec_);
      }
    } else {
      {
#line 681
      VP8LDelete((VP8LDecoder *)idec->dec_);
      }
    }
  }
  {
#line 684
  ClearMemBuffer(& idec->mem_);
#line 685
  WebPFreeDecBuffer(& idec->output_);
#line 686
  WebPSafeFree((void *)idec);
  }
#line 688
  return;
}
}
#line 692 "/root/patron-new/new_3/src/dec/idec_dec.c"
WebPIDecoder *WebPINewRGB(WEBP_CSP_MODE csp , uint8_t *output_buffer , size_t output_buffer_size ,
                          int output_stride ) 
{ 
  int is_external_memory ;
  int tmp___0 ;
  WebPIDecoder *idec ;

  {
#line 694
  if ((unsigned long )output_buffer != (unsigned long )((void *)0)) {
#line 694
    tmp___0 = 1;
  } else {
#line 694
    tmp___0 = 0;
  }
#line 694
  is_external_memory = tmp___0;
#line 697
  if ((unsigned int )csp >= 11U) {
#line 697
    return ((WebPIDecoder *)((void *)0));
  }
#line 698
  if (is_external_memory == 0) {
#line 699
    output_buffer_size = (size_t )0;
#line 700
    output_stride = 0;
  } else
#line 702
  if (output_stride == 0) {
#line 703
    return ((WebPIDecoder *)((void *)0));
  } else
#line 702
  if (output_buffer_size == 0UL) {
#line 703
    return ((WebPIDecoder *)((void *)0));
  }
  {
#line 706
  idec = WebPINewDecoder((WebPDecBuffer *)((void *)0));
  }
#line 707
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 707
    return ((WebPIDecoder *)((void *)0));
  }
#line 708
  idec->output_.colorspace = csp;
#line 709
  idec->output_.is_external_memory = is_external_memory;
#line 710
  idec->output_.u.RGBA.rgba = output_buffer;
#line 711
  idec->output_.u.RGBA.stride = output_stride;
#line 712
  idec->output_.u.RGBA.size = output_buffer_size;
#line 713
  return (idec);
}
}
#line 716 "/root/patron-new/new_3/src/dec/idec_dec.c"
WebPIDecoder *WebPINewYUVA(uint8_t *luma , size_t luma_size , int luma_stride , uint8_t *u ,
                           size_t u_size , int u_stride , uint8_t *v , size_t v_size ,
                           int v_stride , uint8_t *a , size_t a_size , int a_stride ) 
{ 
  int is_external_memory ;
  int tmp___0 ;
  WebPIDecoder *idec ;
  WEBP_CSP_MODE colorspace ;
  int tmp___1 ;

  {
#line 720
  if ((unsigned long )luma != (unsigned long )((void *)0)) {
#line 720
    tmp___0 = 1;
  } else {
#line 720
    tmp___0 = 0;
  }
#line 720
  is_external_memory = tmp___0;
#line 724
  if (is_external_memory == 0) {
#line 725
    a_size = (size_t )0;
#line 725
    v_size = a_size;
#line 725
    u_size = v_size;
#line 725
    luma_size = u_size;
#line 726
    a_stride = 0;
#line 726
    v_stride = a_stride;
#line 726
    u_stride = v_stride;
#line 726
    luma_stride = u_stride;
#line 727
    a = (uint8_t *)((void *)0);
#line 727
    v = a;
#line 727
    u = v;
#line 728
    colorspace = (WEBP_CSP_MODE )12;
  } else {
#line 730
    if ((unsigned long )u == (unsigned long )((void *)0)) {
#line 730
      return ((WebPIDecoder *)((void *)0));
    } else
#line 730
    if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 730
      return ((WebPIDecoder *)((void *)0));
    }
#line 731
    if (luma_size == 0UL) {
#line 731
      return ((WebPIDecoder *)((void *)0));
    } else
#line 731
    if (u_size == 0UL) {
#line 731
      return ((WebPIDecoder *)((void *)0));
    } else
#line 731
    if (v_size == 0UL) {
#line 731
      return ((WebPIDecoder *)((void *)0));
    }
#line 732
    if (luma_stride == 0) {
#line 732
      return ((WebPIDecoder *)((void *)0));
    } else
#line 732
    if (u_stride == 0) {
#line 732
      return ((WebPIDecoder *)((void *)0));
    } else
#line 732
    if (v_stride == 0) {
#line 732
      return ((WebPIDecoder *)((void *)0));
    }
#line 733
    if ((unsigned long )a != (unsigned long )((void *)0)) {
#line 734
      if (a_size == 0UL) {
#line 734
        return ((WebPIDecoder *)((void *)0));
      } else
#line 734
      if (a_stride == 0) {
#line 734
        return ((WebPIDecoder *)((void *)0));
      }
    }
#line 736
    if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 736
      tmp___1 = 11;
    } else {
#line 736
      tmp___1 = 12;
    }
#line 736
    colorspace = (WEBP_CSP_MODE )tmp___1;
  }
  {
#line 739
  idec = WebPINewDecoder((WebPDecBuffer *)((void *)0));
  }
#line 740
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 740
    return ((WebPIDecoder *)((void *)0));
  }
#line 742
  idec->output_.colorspace = colorspace;
#line 743
  idec->output_.is_external_memory = is_external_memory;
#line 744
  idec->output_.u.YUVA.y = luma;
#line 745
  idec->output_.u.YUVA.y_stride = luma_stride;
#line 746
  idec->output_.u.YUVA.y_size = luma_size;
#line 747
  idec->output_.u.YUVA.u = u;
#line 748
  idec->output_.u.YUVA.u_stride = u_stride;
#line 749
  idec->output_.u.YUVA.u_size = u_size;
#line 750
  idec->output_.u.YUVA.v = v;
#line 751
  idec->output_.u.YUVA.v_stride = v_stride;
#line 752
  idec->output_.u.YUVA.v_size = v_size;
#line 753
  idec->output_.u.YUVA.a = a;
#line 754
  idec->output_.u.YUVA.a_stride = a_stride;
#line 755
  idec->output_.u.YUVA.a_size = a_size;
#line 756
  return (idec);
}
}
#line 759 "/root/patron-new/new_3/src/dec/idec_dec.c"
WebPIDecoder *WebPINewYUV(uint8_t *luma , size_t luma_size , int luma_stride , uint8_t *u ,
                          size_t u_size , int u_stride , uint8_t *v , size_t v_size ,
                          int v_stride ) 
{ 
  WebPIDecoder *__cil_tmp10 ;

  {
  {
#line 762
  __cil_tmp10 = WebPINewYUVA(luma, luma_size, luma_stride, u, u_size, u_stride, v,
                             v_size, v_stride, (uint8_t *)((void *)0), (size_t )0,
                             0);
  }
#line 762
  return (__cil_tmp10);
}
}
#line 770 "/root/patron-new/new_3/src/dec/idec_dec.c"
static VP8StatusCode IDecCheckStatus(WebPIDecoder *idec ) 
{ 


  {
#line 772
  if ((unsigned int )idec->state_ == 7U) {
#line 773
    return ((VP8StatusCode )3);
  }
#line 775
  if ((unsigned int )idec->state_ == 6U) {
#line 776
    return ((VP8StatusCode )0);
  }
#line 778
  return ((VP8StatusCode )5);
}
}
#line 781 "/root/patron-new/new_3/src/dec/idec_dec.c"
VP8StatusCode WebPIAppend(WebPIDecoder *idec , uint8_t *data , size_t data_size ) 
{ 
  VP8StatusCode status ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  VP8StatusCode __cil_tmp8 ;

  {
#line 784
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 785
    return ((VP8StatusCode )2);
  } else
#line 784
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 785
    return ((VP8StatusCode )2);
  }
  {
#line 787
  status = IDecCheckStatus(idec);
  }
#line 788
  if ((unsigned int )status != 5U) {
#line 789
    return (status);
  }
  {
#line 792
  __cil_tmp6 = CheckMemBufferMode(& idec->mem_, (MemBufferMode )1);
  }
#line 792
  if (! __cil_tmp6) {
#line 793
    return ((VP8StatusCode )2);
  }
  {
#line 796
  __cil_tmp7 = AppendToMemBuffer(idec, data, data_size);
  }
#line 796
  if (! __cil_tmp7) {
#line 797
    return ((VP8StatusCode )1);
  }
  {
#line 799
  __cil_tmp8 = IDecode(idec);
  }
#line 799
  return (__cil_tmp8);
}
}
#line 802 "/root/patron-new/new_3/src/dec/idec_dec.c"
VP8StatusCode WebPIUpdate(WebPIDecoder *idec , uint8_t *data , size_t data_size ) 
{ 
  VP8StatusCode status ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  VP8StatusCode __cil_tmp8 ;

  {
#line 805
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 806
    return ((VP8StatusCode )2);
  } else
#line 805
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 806
    return ((VP8StatusCode )2);
  }
  {
#line 808
  status = IDecCheckStatus(idec);
  }
#line 809
  if ((unsigned int )status != 5U) {
#line 810
    return (status);
  }
  {
#line 813
  __cil_tmp6 = CheckMemBufferMode(& idec->mem_, (MemBufferMode )2);
  }
#line 813
  if (! __cil_tmp6) {
#line 814
    return ((VP8StatusCode )2);
  }
  {
#line 817
  __cil_tmp7 = RemapMemBuffer(idec, data, data_size);
  }
#line 817
  if (! __cil_tmp7) {
#line 818
    return ((VP8StatusCode )2);
  }
  {
#line 820
  __cil_tmp8 = IDecode(idec);
  }
#line 820
  return (__cil_tmp8);
}
}
#line 825 "/root/patron-new/new_3/src/dec/idec_dec.c"
static WebPDecBuffer *GetOutputBuffer(WebPIDecoder *idec ) 
{ 


  {
#line 826
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 827
    return ((WebPDecBuffer *)((void *)0));
  } else
#line 826
  if ((unsigned long )idec->dec_ == (unsigned long )((void *)0)) {
#line 827
    return ((WebPDecBuffer *)((void *)0));
  }
#line 829
  if ((unsigned int )idec->state_ <= 2U) {
#line 830
    return ((WebPDecBuffer *)((void *)0));
  }
#line 832
  if ((unsigned long )idec->final_output_ != (unsigned long )((void *)0)) {
#line 833
    return ((WebPDecBuffer *)((void *)0));
  }
#line 835
  return (idec->params_.output);
}
}
#line 838 "/root/patron-new/new_3/src/dec/idec_dec.c"
WebPDecBuffer *WebPIDecodedArea(WebPIDecoder *idec , int *left , int *top , int *width ,
                                int *height ) 
{ 
  WebPDecBuffer *src ;
  WebPDecBuffer *__cil_tmp7 ;

  {
  {
#line 841
  __cil_tmp7 = GetOutputBuffer(idec);
#line 841
  src = __cil_tmp7;
  }
#line 842
  if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 842
    *left = 0;
  }
#line 843
  if ((unsigned long )top != (unsigned long )((void *)0)) {
#line 843
    *top = 0;
  }
#line 844
  if ((unsigned long )src != (unsigned long )((void *)0)) {
#line 845
    if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 845
      *width = src->width;
    }
#line 846
    if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 846
      *height = idec->params_.last_y;
    }
  } else {
#line 848
    if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 848
      *width = 0;
    }
#line 849
    if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 849
      *height = 0;
    }
  }
#line 851
  return (src);
}
}
#line 854 "/root/patron-new/new_3/src/dec/idec_dec.c"
uint8_t *WebPIDecGetRGB(WebPIDecoder *idec , int *last_y , int *width , int *height ,
                        int *stride ) 
{ 
  WebPDecBuffer *src ;
  WebPDecBuffer *__cil_tmp7 ;

  {
  {
#line 856
  __cil_tmp7 = GetOutputBuffer(idec);
#line 856
  src = __cil_tmp7;
  }
#line 857
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 857
    return ((uint8_t *)((void *)0));
  }
#line 858
  if ((unsigned int )src->colorspace >= 11U) {
#line 859
    return ((uint8_t *)((void *)0));
  }
#line 862
  if ((unsigned long )last_y != (unsigned long )((void *)0)) {
#line 862
    *last_y = idec->params_.last_y;
  }
#line 863
  if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 863
    *width = src->width;
  }
#line 864
  if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 864
    *height = src->height;
  }
#line 865
  if ((unsigned long )stride != (unsigned long )((void *)0)) {
#line 865
    *stride = src->u.RGBA.stride;
  }
#line 867
  return (src->u.RGBA.rgba);
}
}
#line 870 "/root/patron-new/new_3/src/dec/idec_dec.c"
uint8_t *WebPIDecGetYUVA(WebPIDecoder *idec , int *last_y , uint8_t **u , uint8_t **v ,
                         uint8_t **a , int *width , int *height , int *stride , int *uv_stride ,
                         int *a_stride ) 
{ 
  WebPDecBuffer *src ;
  WebPDecBuffer *__cil_tmp12 ;

  {
  {
#line 874
  __cil_tmp12 = GetOutputBuffer(idec);
#line 874
  src = __cil_tmp12;
  }
#line 875
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 875
    return ((uint8_t *)((void *)0));
  }
#line 876
  if ((unsigned int )src->colorspace < 11U) {
#line 877
    return ((uint8_t *)((void *)0));
  }
#line 880
  if ((unsigned long )last_y != (unsigned long )((void *)0)) {
#line 880
    *last_y = idec->params_.last_y;
  }
#line 881
  if ((unsigned long )u != (unsigned long )((void *)0)) {
#line 881
    *u = src->u.YUVA.u;
  }
#line 882
  if ((unsigned long )v != (unsigned long )((void *)0)) {
#line 882
    *v = src->u.YUVA.v;
  }
#line 883
  if ((unsigned long )a != (unsigned long )((void *)0)) {
#line 883
    *a = src->u.YUVA.a;
  }
#line 884
  if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 884
    *width = src->width;
  }
#line 885
  if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 885
    *height = src->height;
  }
#line 886
  if ((unsigned long )stride != (unsigned long )((void *)0)) {
#line 886
    *stride = src->u.YUVA.y_stride;
  }
#line 887
  if ((unsigned long )uv_stride != (unsigned long )((void *)0)) {
#line 887
    *uv_stride = src->u.YUVA.u_stride;
  }
#line 888
  if ((unsigned long )a_stride != (unsigned long )((void *)0)) {
#line 888
    *a_stride = src->u.YUVA.a_stride;
  }
#line 890
  return (src->u.YUVA.y);
}
}
#line 893 "/root/patron-new/new_3/src/dec/idec_dec.c"
int WebPISetIOHooks(WebPIDecoder *idec , int (*put)(VP8Io * ) , int (*setup)(VP8Io * ) ,
                    void (*teardown)(VP8Io * ) , void *user_data ) 
{ 


  {
#line 898
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 899
    return (0);
  } else
#line 898
  if ((unsigned int )idec->state_ > 0U) {
#line 899
    return (0);
  }
#line 902
  idec->io_.put = put;
#line 903
  idec->io_.setup = setup;
#line 904
  idec->io_.teardown = teardown;
#line 905
  idec->io_.opaque = user_data;
#line 907
  return (1);
}
}
#line 21 "/root/patron-new/new_3/src/dec/frame_dec.c"
static uint16_t kScan[16]  = 
#line 21 "/root/patron-new/new_3/src/dec/frame_dec.c"
  {      (uint16_t )0,      (uint16_t )4,      (uint16_t )8,      (uint16_t )12, 
        (uint16_t )128,      (uint16_t )132,      (uint16_t )136,      (uint16_t )140, 
        (uint16_t )256,      (uint16_t )260,      (uint16_t )264,      (uint16_t )268, 
        (uint16_t )384,      (uint16_t )388,      (uint16_t )392,      (uint16_t )396};
#line 28 "/root/patron-new/new_3/src/dec/frame_dec.c"
static int CheckMode(int mb_x , int mb_y , int mode ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
#line 29
  if (mode == 0) {
#line 30
    if (mb_x == 0) {
#line 31
      if (mb_y == 0) {
#line 31
        tmp___0 = 6;
      } else {
#line 31
        tmp___0 = 5;
      }
#line 31
      return (tmp___0);
    } else {
#line 33
      if (mb_y == 0) {
#line 33
        tmp___1 = 4;
      } else {
#line 33
        tmp___1 = 0;
      }
#line 33
      return (tmp___1);
    }
  }
#line 36
  return (mode);
}
}
#line 39 "/root/patron-new/new_3/src/dec/frame_dec.c"
static void Copy32b(uint8_t *dst , uint8_t *src ) 
{ 


  {
  {
#line 40
  memcpy((void *)dst, (void const   *)src, 4UL);
  }
#line 42
  return;
}
}
#line 43 "/root/patron-new/new_3/src/dec/frame_dec.c"
__inline static void DoTransform(uint32_t bits , int16_t *src , uint8_t *dst ) 
{ 


  {
#line 46
  if (bits >> 30 == 3U) {
#line 46
    goto case_3;
  }
#line 49
  if (bits >> 30 == 2U) {
#line 49
    goto case_2;
  }
#line 52
  if (bits >> 30 == 1U) {
#line 52
    goto case_1;
  }
#line 55
  goto switch_default;
  case_3: 
  {
#line 47
  (*VP8Transform)(src, dst, 0);
  }
#line 48
  goto switch_break;
  case_2: 
  {
#line 50
  (*VP8TransformAC3)(src, dst);
  }
#line 51
  goto switch_break;
  case_1: 
  {
#line 53
  (*VP8TransformDC)(src, dst);
  }
#line 54
  goto switch_break;
  switch_default: 
#line 56
  goto switch_break;
  switch_break: ;
#line 59
  return;
}
}
#line 60 "/root/patron-new/new_3/src/dec/frame_dec.c"
static void DoUVTransform(uint32_t bits , int16_t *src , uint8_t *dst ) 
{ 


  {
#line 62
  if (bits & 255U) {
#line 63
    if (bits & 170U) {
      {
#line 64
      (*VP8TransformUV)(src, dst);
      }
    } else {
      {
#line 66
      (*VP8TransformDCUV)(src, dst);
      }
    }
  }
#line 70
  return;
}
}
#line 71 "/root/patron-new/new_3/src/dec/frame_dec.c"
static void ReconstructRow(VP8Decoder *dec , VP8ThreadContext *ctx ) 
{ 
  int j ;
  int mb_x ;
  int mb_y ;
  int cache_id ;
  uint8_t *y_dst ;
  uint8_t *u_dst ;
  uint8_t *v_dst ;
  VP8MBData *block ;
  VP8TopSamples *top_yuv ;
  int16_t *coeffs ;
  uint32_t bits ;
  int n ;
  uint32_t *top_right ;
  uint8_t *dst ;
  int pred_func ;
  int __cil_tmp18 ;
  uint32_t bits_uv ;
  int pred_func___0 ;
  int __cil_tmp21 ;
  int y_offset ;
  int uv_offset ;
  uint8_t *y_out ;
  uint8_t *u_out ;
  uint8_t *v_out ;

  {
#line 75
  mb_y = ctx->mb_y_;
#line 76
  cache_id = ctx->id_;
#line 77
  y_dst = dec->yuv_b_ + 40;
#line 78
  u_dst = dec->yuv_b_ + 584;
#line 79
  v_dst = dec->yuv_b_ + 600;
#line 82
  j = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;

#line 82
    if (! (j < 16)) {
#line 82
      goto while_break;
    }
#line 83
    *(y_dst + (j * 32 - 1)) = (uint8_t )129;
#line 82
    j ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: 
#line 85
  j = 0;
  {
#line 85
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 85
    if (! (j < 8)) {
#line 85
      goto while_break___0;
    }
#line 86
    *(u_dst + (j * 32 - 1)) = (uint8_t )129;
#line 87
    *(v_dst + (j * 32 - 1)) = (uint8_t )129;
#line 85
    j ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___0: ;
#line 91
  if (mb_y > 0) {
#line 92
    *(v_dst + -33) = (uint8_t )129;
#line 92
    *(u_dst + -33) = *(v_dst + -33);
#line 92
    *(y_dst + -33) = *(u_dst + -33);
  } else {
    {
#line 96
    memset((void *)((y_dst - 32) - 1), 127, 21UL);
#line 97
    memset((void *)((u_dst - 32) - 1), 127, 9UL);
#line 98
    memset((void *)((v_dst - 32) - 1), 127, 9UL);
    }
  }
#line 102
  mb_x = 0;
  {
#line 102
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 102
    if (! (mb_x < dec->mb_w_)) {
#line 102
      goto while_break___1;
    }
#line 103
    block = ctx->mb_data_ + mb_x;
#line 107
    if (mb_x > 0) {
#line 108
      j = -1;
      {
#line 108
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 108
        if (! (j < 16)) {
#line 108
          goto while_break___2;
        }
        {
#line 109
        Copy32b(y_dst + (j * 32 - 4), y_dst + (j * 32 + 12));
#line 108
        j ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___2: 
#line 111
      j = -1;
      {
#line 111
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 111
        if (! (j < 8)) {
#line 111
          goto while_break___3;
        }
        {
#line 112
        Copy32b(u_dst + (j * 32 - 4), u_dst + (j * 32 + 4));
#line 113
        Copy32b(v_dst + (j * 32 - 4), v_dst + (j * 32 + 4));
#line 111
        j ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___3: ;
    }
#line 118
    top_yuv = dec->yuv_t_ + mb_x;
#line 119
    coeffs = block->coeffs_;
#line 120
    bits = block->non_zero_y_;
#line 123
    if (mb_y > 0) {
      {
#line 124
      memcpy((void *)(y_dst - 32), (void const   *)((top_yuv + 0)->y), 16UL);
#line 125
      memcpy((void *)(u_dst - 32), (void const   *)((top_yuv + 0)->u), 8UL);
#line 126
      memcpy((void *)(v_dst - 32), (void const   *)((top_yuv + 0)->v), 8UL);
      }
    }
#line 130
    if (block->is_i4x4_) {
#line 131
      top_right = (uint32_t *)((y_dst - 32) + 16);
#line 133
      if (mb_y > 0) {
#line 134
        if (mb_x >= dec->mb_w_ - 1) {
          {
#line 135
          memset((void *)top_right, (int )(top_yuv + 0)->y[15], sizeof(*top_right));
          }
        } else {
          {
#line 137
          memcpy((void *)top_right, (void const   *)((top_yuv + 1)->y), sizeof(*top_right));
          }
        }
      }
#line 141
      *(top_right + 96) = *(top_right + 0);
#line 141
      *(top_right + 64) = *(top_right + 96);
#line 141
      *(top_right + 32) = *(top_right + 64);
#line 144
      n = 0;
      {
#line 144
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 144
        if (! (n < 16)) {
#line 144
          goto while_break___4;
        }
        {
#line 145
        dst = y_dst + (int )kScan[n];
#line 146
        (*(VP8PredLuma4[block->imodes_[n]]))(dst);
#line 147
        DoTransform(bits, coeffs + n * 16, dst);
#line 144
        bits <<= 2;
#line 144
        n ++;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___4: ;
    } else {
      {
#line 150
      __cil_tmp18 = CheckMode(mb_x, mb_y, (int )block->imodes_[0]);
#line 150
      pred_func = __cil_tmp18;
#line 151
      (*(VP8PredLuma16[pred_func]))(y_dst);
      }
#line 152
      if (bits != 0U) {
#line 153
        n = 0;
        {
#line 153
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 153
          if (! (n < 16)) {
#line 153
            goto while_break___5;
          }
          {
#line 154
          DoTransform(bits, coeffs + n * 16, y_dst + (int )kScan[n]);
#line 153
          bits <<= 2;
#line 153
          n ++;
          }
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___5: ;
      }
    }
    {
#line 160
    bits_uv = block->non_zero_uv_;
#line 161
    __cil_tmp21 = CheckMode(mb_x, mb_y, (int )block->uvmode_);
#line 161
    pred_func___0 = __cil_tmp21;
#line 162
    (*(VP8PredChroma8[pred_func___0]))(u_dst);
#line 163
    (*(VP8PredChroma8[pred_func___0]))(v_dst);
#line 164
    DoUVTransform(bits_uv, coeffs + 256, u_dst);
#line 165
    DoUVTransform(bits_uv >> 8, coeffs + 320, v_dst);
    }
#line 169
    if (mb_y < dec->mb_h_ - 1) {
      {
#line 170
      memcpy((void *)((top_yuv + 0)->y), (void const   *)(y_dst + 480), 16UL);
#line 171
      memcpy((void *)((top_yuv + 0)->u), (void const   *)(u_dst + 224), 8UL);
#line 172
      memcpy((void *)((top_yuv + 0)->v), (void const   *)(v_dst + 224), 8UL);
      }
    }
#line 177
    y_offset = (cache_id * 16) * dec->cache_y_stride_;
#line 178
    uv_offset = (cache_id * 8) * dec->cache_uv_stride_;
#line 179
    y_out = (dec->cache_y_ + mb_x * 16) + y_offset;
#line 180
    u_out = (dec->cache_u_ + mb_x * 8) + uv_offset;
#line 181
    v_out = (dec->cache_v_ + mb_x * 8) + uv_offset;
#line 182
    j = 0;
    {
#line 182
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 182
      if (! (j < 16)) {
#line 182
        goto while_break___6;
      }
      {
#line 183
      memcpy((void *)(y_out + j * dec->cache_y_stride_), (void const   *)(y_dst + j * 32),
             16UL);
#line 182
      j ++;
      }
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___6: 
#line 185
    j = 0;
    {
#line 185
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 185
      if (! (j < 8)) {
#line 185
        goto while_break___7;
      }
      {
#line 186
      memcpy((void *)(u_out + j * dec->cache_uv_stride_), (void const   *)(u_dst + j * 32),
             8UL);
#line 187
      memcpy((void *)(v_out + j * dec->cache_uv_stride_), (void const   *)(v_dst + j * 32),
             8UL);
#line 185
      j ++;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___7: 
#line 102
    mb_x ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___1: ;
#line 106
  return;
}
}
#line 201 "/root/patron-new/new_3/src/dec/frame_dec.c"
static uint8_t kFilterExtraRows[3]  = {      (uint8_t )0,      (uint8_t )2,      (uint8_t )8};
#line 203 "/root/patron-new/new_3/src/dec/frame_dec.c"
static void DoFilter___0(VP8Decoder *dec , int mb_x , int mb_y ) 
{ 
  VP8ThreadContext *ctx ;
  int cache_id ;
  int y_bps ;
  VP8FInfo *f_info ;
  uint8_t *y_dst ;
  int ilevel ;
  int limit ;
  int uv_bps ;
  uint8_t *u_dst ;
  uint8_t *v_dst ;
  int hev_thresh ;

  {
#line 204
  ctx = & dec->thread_ctx_;
#line 205
  cache_id = ctx->id_;
#line 206
  y_bps = dec->cache_y_stride_;
#line 207
  f_info = ctx->f_info_ + mb_x;
#line 208
  y_dst = (dec->cache_y_ + (cache_id * 16) * y_bps) + mb_x * 16;
#line 209
  ilevel = (int )f_info->f_ilevel_;
#line 210
  limit = (int )f_info->f_limit_;
#line 211
  if (limit == 0) {
#line 212
    return;
  }
#line 215
  if (dec->filter_type_ == 1) {
#line 216
    if (mb_x > 0) {
      {
#line 217
      (*VP8SimpleHFilter16)(y_dst, y_bps, limit + 4);
      }
    }
#line 219
    if (f_info->f_inner_) {
      {
#line 220
      (*VP8SimpleHFilter16i)(y_dst, y_bps, limit);
      }
    }
#line 222
    if (mb_y > 0) {
      {
#line 223
      (*VP8SimpleVFilter16)(y_dst, y_bps, limit + 4);
      }
    }
#line 225
    if (f_info->f_inner_) {
      {
#line 226
      (*VP8SimpleVFilter16i)(y_dst, y_bps, limit);
      }
    }
  } else {
#line 229
    uv_bps = dec->cache_uv_stride_;
#line 230
    u_dst = (dec->cache_u_ + (cache_id * 8) * uv_bps) + mb_x * 8;
#line 231
    v_dst = (dec->cache_v_ + (cache_id * 8) * uv_bps) + mb_x * 8;
#line 232
    hev_thresh = (int )f_info->hev_thresh_;
#line 233
    if (mb_x > 0) {
      {
#line 234
      (*VP8HFilter16)(y_dst, y_bps, limit + 4, ilevel, hev_thresh);
#line 235
      (*VP8HFilter8)(u_dst, v_dst, uv_bps, limit + 4, ilevel, hev_thresh);
      }
    }
#line 237
    if (f_info->f_inner_) {
      {
#line 238
      (*VP8HFilter16i)(y_dst, y_bps, limit, ilevel, hev_thresh);
#line 239
      (*VP8HFilter8i)(u_dst, v_dst, uv_bps, limit, ilevel, hev_thresh);
      }
    }
#line 241
    if (mb_y > 0) {
      {
#line 242
      (*VP8VFilter16)(y_dst, y_bps, limit + 4, ilevel, hev_thresh);
#line 243
      (*VP8VFilter8)(u_dst, v_dst, uv_bps, limit + 4, ilevel, hev_thresh);
      }
    }
#line 245
    if (f_info->f_inner_) {
      {
#line 246
      (*VP8VFilter16i)(y_dst, y_bps, limit, ilevel, hev_thresh);
#line 247
      (*VP8VFilter8i)(u_dst, v_dst, uv_bps, limit, ilevel, hev_thresh);
      }
    }
  }
#line 251
  return;
}
}
#line 253 "/root/patron-new/new_3/src/dec/frame_dec.c"
static void FilterRow(VP8Decoder *dec ) 
{ 
  int mb_x ;
  int mb_y ;

  {
#line 255
  mb_y = dec->thread_ctx_.mb_y_;
#line 257
  mb_x = dec->tl_mb_x_;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;

#line 257
    if (! (mb_x < dec->br_mb_x_)) {
#line 257
      goto while_break;
    }
    {
#line 258
    DoFilter___0(dec, mb_x, mb_y);
#line 257
    mb_x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 261
  return;
}
}
#line 265 "/root/patron-new/new_3/src/dec/frame_dec.c"
static void PrecomputeFilterStrengths(VP8Decoder *dec ) 
{ 
  int s ;
  VP8FilterHeader *hdr ;
  int i4x4 ;
  int base_level ;
  VP8FInfo *info ;
  int level ;
  int tmp___0 ;
  int tmp___1 ;
  int ilevel ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 266
  if (dec->filter_type_ > 0) {
#line 268
    hdr = & dec->filter_hdr_;
#line 269
    s = 0;
    {
#line 269
    while (1) {
      while_continue: /* CIL Label */ ;

#line 269
      if (! (s < 4)) {
#line 269
        goto while_break;
      }
#line 273
      if (dec->segment_hdr_.use_segment_) {
#line 274
        base_level = (int )dec->segment_hdr_.filter_strength_[s];
#line 275
        if (! dec->segment_hdr_.absolute_delta_) {
#line 276
          base_level += hdr->level_;
        }
      } else {
#line 279
        base_level = hdr->level_;
      }
#line 281
      i4x4 = 0;
      {
#line 281
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 281
        if (! (i4x4 <= 1)) {
#line 281
          goto while_break___0;
        }
#line 282
        info = & dec->fstrengths_[s][i4x4];
#line 283
        level = base_level;
#line 284
        if (hdr->use_lf_delta_) {
#line 285
          level += hdr->ref_lf_delta_[0];
#line 286
          if (i4x4) {
#line 287
            level += hdr->mode_lf_delta_[0];
          }
        }
#line 290
        if (level < 0) {
#line 290
          tmp___1 = 0;
        } else {
#line 290
          if (level > 63) {
#line 290
            tmp___0 = 63;
          } else {
#line 290
            tmp___0 = level;
          }
#line 290
          tmp___1 = tmp___0;
        }
#line 290
        level = tmp___1;
#line 291
        if (level > 0) {
#line 292
          ilevel = level;
#line 293
          if (hdr->sharpness_ > 0) {
#line 294
            if (hdr->sharpness_ > 4) {
#line 295
              ilevel >>= 2;
            } else {
#line 297
              ilevel >>= 1;
            }
#line 299
            if (ilevel > 9 - hdr->sharpness_) {
#line 300
              ilevel = 9 - hdr->sharpness_;
            }
          }
#line 303
          if (ilevel < 1) {
#line 303
            ilevel = 1;
          }
#line 304
          info->f_ilevel_ = (uint8_t )ilevel;
#line 305
          info->f_limit_ = (uint8_t )(2 * level + ilevel);
#line 306
          if (level >= 40) {
#line 306
            tmp___3 = 2;
          } else {
#line 306
            if (level >= 15) {
#line 306
              tmp___2 = 1;
            } else {
#line 306
              tmp___2 = 0;
            }
#line 306
            tmp___3 = tmp___2;
          }
#line 306
          info->hev_thresh_ = (uint8_t )tmp___3;
        } else {
#line 308
          info->f_limit_ = (uint8_t )0;
        }
#line 310
        info->f_inner_ = (uint8_t )i4x4;
#line 281
        i4x4 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 269
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 274
  return;
}
}
#line 323 "/root/patron-new/new_3/src/dec/frame_dec.c"
static uint8_t kQuantToDitherAmp[12]  = 
#line 323
  {      (uint8_t )8,      (uint8_t )7,      (uint8_t )6,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1};
#line 328 "/root/patron-new/new_3/src/dec/frame_dec.c"
void VP8InitDithering(WebPDecoderOptions *options , VP8Decoder *dec ) 
{ 
  int d ;
  int max_amp ;
  int f ;
  int tmp___0 ;
  int tmp___1 ;
  int s ;
  int all_amp ;
  VP8QuantMatrix *dqm ;
  int idx ;
  int tmp___2 ;

  {
#line 331
  if ((unsigned long )options != (unsigned long )((void *)0)) {
#line 332
    d = options->dithering_strength;
#line 333
    max_amp = (1 << 8) - 1;
#line 334
    if (d < 0) {
#line 334
      tmp___1 = 0;
    } else {
#line 334
      if (d > 100) {
#line 334
        tmp___0 = max_amp;
      } else {
#line 334
        tmp___0 = (d * max_amp) / 100;
      }
#line 334
      tmp___1 = tmp___0;
    }
#line 334
    f = tmp___1;
#line 335
    if (f > 0) {
#line 337
      all_amp = 0;
#line 338
      s = 0;
      {
#line 338
      while (1) {
        while_continue: /* CIL Label */ ;

#line 338
        if (! (s < 4)) {
#line 338
          goto while_break;
        }
#line 339
        dqm = & dec->dqm_[s];
#line 340
        if (dqm->uv_quant_ < 12) {
#line 341
          if (dqm->uv_quant_ < 0) {
#line 341
            tmp___2 = 0;
          } else {
#line 341
            tmp___2 = dqm->uv_quant_;
          }
#line 341
          idx = tmp___2;
#line 342
          dqm->dither_ = f * (int )kQuantToDitherAmp[idx] >> 3;
        }
#line 344
        all_amp |= dqm->dither_;
#line 338
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: ;
#line 346
      if (all_amp != 0) {
        {
#line 347
        VP8InitRandom(& dec->dithering_rg_, 1.f);
#line 348
        dec->dither_ = 1;
        }
      }
    }
#line 352
    dec->alpha_dithering_ = options->alpha_dithering_strength;
#line 353
    if (dec->alpha_dithering_ > 100) {
#line 354
      dec->alpha_dithering_ = 100;
    } else
#line 355
    if (dec->alpha_dithering_ < 0) {
#line 356
      dec->alpha_dithering_ = 0;
    }
  }
#line 359
  return;
}
}
#line 362 "/root/patron-new/new_3/src/dec/frame_dec.c"
static void Dither8x8(VP8Random *rg , uint8_t *dst , int bps , int amp ) 
{ 
  uint8_t dither[64] ;
  int i ;
  int __cil_tmp7 ;

  {
#line 365
  i = 0;
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;

#line 365
    if (! (i < 64)) {
#line 365
      goto while_break;
    }
    {
#line 366
    __cil_tmp7 = VP8RandomBits2(rg, 8, amp);
#line 366
    dither[i] = (uint8_t )__cil_tmp7;
#line 365
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 368
  (*VP8DitherCombine8x8)(dither, dst, bps);
  }
#line 370
  return;
}
}
#line 371 "/root/patron-new/new_3/src/dec/frame_dec.c"
static void DitherRow(VP8Decoder *dec ) 
{ 
  int mb_x ;
  VP8ThreadContext *ctx ;
  VP8MBData *data ;
  int cache_id ;
  int uv_bps ;
  uint8_t *u_dst ;
  uint8_t *v_dst ;

  {
#line 374
  mb_x = dec->tl_mb_x_;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;

#line 374
    if (! (mb_x < dec->br_mb_x_)) {
#line 374
      goto while_break;
    }
#line 375
    ctx = & dec->thread_ctx_;
#line 376
    data = ctx->mb_data_ + mb_x;
#line 377
    cache_id = ctx->id_;
#line 378
    uv_bps = dec->cache_uv_stride_;
#line 379
    if ((int )data->dither_ >= 4) {
      {
#line 380
      u_dst = (dec->cache_u_ + (cache_id * 8) * uv_bps) + mb_x * 8;
#line 381
      v_dst = (dec->cache_v_ + (cache_id * 8) * uv_bps) + mb_x * 8;
#line 382
      Dither8x8(& dec->dithering_rg_, u_dst, uv_bps, (int )data->dither_);
#line 383
      Dither8x8(& dec->dithering_rg_, v_dst, uv_bps, (int )data->dither_);
      }
    }
#line 374
    mb_x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 378
  return;
}
}
#line 402 "/root/patron-new/new_3/src/dec/frame_dec.c"
static int FinishRow(void *arg1 , void *arg2 ) 
{ 
  VP8Decoder *dec ;
  VP8Io *io ;
  int ok ;
  VP8ThreadContext *ctx ;
  int cache_id ;
  int extra_y_rows ;
  int ysize ;
  int uvsize ;
  int y_offset ;
  int uv_offset ;
  uint8_t *ydst ;
  uint8_t *udst ;
  uint8_t *vdst ;
  int mb_y ;
  int is_first_row ;
  int is_last_row ;
  int y_start ;
  int y_end ;
  int __cil_tmp22 ;
  int delta_y ;

  {
#line 403
  dec = (VP8Decoder *)arg1;
#line 404
  io = (VP8Io *)arg2;
#line 405
  ok = 1;
#line 406
  ctx = & dec->thread_ctx_;
#line 407
  cache_id = ctx->id_;
#line 408
  extra_y_rows = (int )kFilterExtraRows[dec->filter_type_];
#line 409
  ysize = extra_y_rows * dec->cache_y_stride_;
#line 410
  uvsize = (extra_y_rows / 2) * dec->cache_uv_stride_;
#line 411
  y_offset = (cache_id * 16) * dec->cache_y_stride_;
#line 412
  uv_offset = (cache_id * 8) * dec->cache_uv_stride_;
#line 413
  ydst = (dec->cache_y_ - ysize) + y_offset;
#line 414
  udst = (dec->cache_u_ - uvsize) + uv_offset;
#line 415
  vdst = (dec->cache_v_ - uvsize) + uv_offset;
#line 416
  mb_y = ctx->mb_y_;
#line 417
  is_first_row = mb_y == 0;
#line 418
  is_last_row = mb_y >= dec->br_mb_y_ - 1;
#line 420
  if (dec->mt_method_ == 2) {
    {
#line 421
    ReconstructRow(dec, ctx);
    }
  }
#line 424
  if (ctx->filter_row_) {
    {
#line 425
    FilterRow(dec);
    }
  }
#line 428
  if (dec->dither_) {
    {
#line 429
    DitherRow(dec);
    }
  }
#line 432
  if ((unsigned long )io->put != (unsigned long )((void *)0)) {
#line 433
    y_start = mb_y * 16;
#line 434
    y_end = (mb_y + 1) * 16;
#line 435
    if (! is_first_row) {
#line 436
      y_start -= extra_y_rows;
#line 437
      io->y = ydst;
#line 438
      io->u = udst;
#line 439
      io->v = vdst;
    } else {
#line 441
      io->y = dec->cache_y_ + y_offset;
#line 442
      io->u = dec->cache_u_ + uv_offset;
#line 443
      io->v = dec->cache_v_ + uv_offset;
    }
#line 446
    if (! is_last_row) {
#line 447
      y_end -= extra_y_rows;
    }
#line 449
    if (y_end > io->crop_bottom) {
#line 450
      y_end = io->crop_bottom;
    }
#line 453
    io->a = (uint8_t *)((void *)0);
#line 454
    if ((unsigned long )dec->alpha_data_ != (unsigned long )((void *)0)) {
#line 454
      if (y_start < y_end) {
        {
#line 455
        io->a = VP8DecompressAlphaRows(dec, io, y_start, y_end - y_start);
        }
#line 456
        if ((unsigned long )io->a == (unsigned long )((void *)0)) {
          {
#line 457
          __cil_tmp22 = VP8SetError(dec, (VP8StatusCode )3, "Could not decode alpha data.");
          }
#line 457
          return (__cil_tmp22);
        }
      }
    }
#line 461
    if (y_start < io->crop_top) {
#line 462
      delta_y = io->crop_top - y_start;
#line 463
      y_start = io->crop_top;
#line 465
      io->y += dec->cache_y_stride_ * delta_y;
#line 466
      io->u += dec->cache_uv_stride_ * (delta_y >> 1);
#line 467
      io->v += dec->cache_uv_stride_ * (delta_y >> 1);
#line 468
      if ((unsigned long )io->a != (unsigned long )((void *)0)) {
#line 469
        io->a += io->width * delta_y;
      }
    }
#line 472
    if (y_start < y_end) {
#line 473
      io->y += io->crop_left;
#line 474
      io->u += io->crop_left >> 1;
#line 475
      io->v += io->crop_left >> 1;
#line 476
      if ((unsigned long )io->a != (unsigned long )((void *)0)) {
#line 477
        io->a += io->crop_left;
      }
      {
#line 479
      io->mb_y = y_start - io->crop_top;
#line 480
      io->mb_w = io->crop_right - io->crop_left;
#line 481
      io->mb_h = y_end - y_start;
#line 482
      ok = (*(io->put))(io);
      }
    }
  }
#line 486
  if (cache_id + 1 == dec->num_caches_) {
#line 487
    if (! is_last_row) {
      {
#line 488
      memcpy((void *)(dec->cache_y_ - ysize), (void const   *)(ydst + 16 * dec->cache_y_stride_),
             (unsigned long )ysize);
#line 489
      memcpy((void *)(dec->cache_u_ - uvsize), (void const   *)(udst + 8 * dec->cache_uv_stride_),
             (unsigned long )uvsize);
#line 490
      memcpy((void *)(dec->cache_v_ - uvsize), (void const   *)(vdst + 8 * dec->cache_uv_stride_),
             (unsigned long )uvsize);
      }
    }
  }
#line 494
  return (ok);
}
}
#line 501 "/root/patron-new/new_3/src/dec/frame_dec.c"
int VP8ProcessRow(VP8Decoder *dec , VP8Io *io ) 
{ 
  int ok ;
  VP8ThreadContext *ctx ;
  int filter_row ;
  WebPWorker *worker ;
  WebPWorkerInterface *__cil_tmp8 ;
  int __cil_tmp9 ;
  VP8MBData *tmp___0 ;
  VP8FInfo *tmp___1 ;
  WebPWorkerInterface *__cil_tmp12 ;
  int tmp___2 ;

  {
#line 502
  ok = 1;
#line 503
  ctx = & dec->thread_ctx_;
#line 504
  if (dec->filter_type_ > 0) {
#line 504
    if (dec->mb_y_ >= dec->tl_mb_y_) {
#line 504
      if (dec->mb_y_ <= dec->br_mb_y_) {
#line 504
        tmp___2 = 1;
      } else {
#line 504
        tmp___2 = 0;
      }
    } else {
#line 504
      tmp___2 = 0;
    }
  } else {
#line 504
    tmp___2 = 0;
  }
#line 504
  filter_row = tmp___2;
#line 507
  if (dec->mt_method_ == 0) {
    {
#line 509
    ctx->mb_y_ = dec->mb_y_;
#line 510
    ctx->filter_row_ = filter_row;
#line 511
    ReconstructRow(dec, ctx);
#line 512
    ok = FinishRow((void *)dec, (void *)io);
    }
  } else {
    {
#line 514
    worker = & dec->worker_;
#line 516
    __cil_tmp9 = (*(__cil_tmp8->Sync))((WebPWorker */* const  */)worker);
#line 516
    ok &= __cil_tmp9;
    }
#line 518
    if (ok) {
#line 519
      ctx->io_ = *io;
#line 520
      ctx->id_ = dec->cache_id_;
#line 521
      ctx->mb_y_ = dec->mb_y_;
#line 522
      ctx->filter_row_ = filter_row;
#line 523
      if (dec->mt_method_ == 2) {
#line 524
        tmp___0 = ctx->mb_data_;
#line 525
        ctx->mb_data_ = dec->mb_data_;
#line 526
        dec->mb_data_ = tmp___0;
      } else {
        {
#line 529
        ReconstructRow(dec, ctx);
        }
      }
#line 531
      if (filter_row) {
#line 532
        tmp___1 = ctx->f_info_;
#line 533
        ctx->f_info_ = dec->f_info_;
#line 534
        dec->f_info_ = tmp___1;
      }
      {
#line 537
      (*(__cil_tmp12->Launch))((WebPWorker */* const  */)worker);
#line 538
      (dec->cache_id_) ++;
      }
#line 538
      if (dec->cache_id_ == dec->num_caches_) {
#line 539
        dec->cache_id_ = 0;
      }
    }
  }
#line 543
  return (ok);
}
}
#line 549 "/root/patron-new/new_3/src/dec/frame_dec.c"
VP8StatusCode VP8EnterCritical(VP8Decoder *dec , VP8Io *io ) 
{ 
  int __cil_tmp3 ;
  int extra_pixels ;

  {
  {
#line 552
  __cil_tmp3 = (*(io->setup))(io);
  }
#line 552
  if ((unsigned long )io->setup != (unsigned long )((void *)0)) {
#line 552
    if (! __cil_tmp3) {
      {
#line 553
      VP8SetError(dec, (VP8StatusCode )6, "Frame setup failed");
      }
#line 554
      return (dec->status_);
    }
  }
#line 558
  if (io->bypass_filtering) {
#line 559
    dec->filter_type_ = 0;
  }
#line 572
  extra_pixels = (int )kFilterExtraRows[dec->filter_type_];
#line 573
  if (dec->filter_type_ == 2) {
#line 575
    dec->tl_mb_x_ = 0;
#line 576
    dec->tl_mb_y_ = 0;
  } else {
#line 582
    dec->tl_mb_x_ = (io->crop_left - extra_pixels) >> 4;
#line 583
    dec->tl_mb_y_ = (io->crop_top - extra_pixels) >> 4;
#line 584
    if (dec->tl_mb_x_ < 0) {
#line 584
      dec->tl_mb_x_ = 0;
    }
#line 585
    if (dec->tl_mb_y_ < 0) {
#line 585
      dec->tl_mb_y_ = 0;
    }
  }
#line 588
  dec->br_mb_y_ = ((io->crop_bottom + 15) + extra_pixels) >> 4;
#line 589
  dec->br_mb_x_ = ((io->crop_right + 15) + extra_pixels) >> 4;
#line 590
  if (dec->br_mb_x_ > dec->mb_w_) {
#line 591
    dec->br_mb_x_ = dec->mb_w_;
  }
#line 593
  if (dec->br_mb_y_ > dec->mb_h_) {
#line 594
    dec->br_mb_y_ = dec->mb_h_;
  }
  {
#line 597
  PrecomputeFilterStrengths(dec);
  }
#line 598
  return ((VP8StatusCode )0);
}
}
#line 601 "/root/patron-new/new_3/src/dec/frame_dec.c"
int VP8ExitCritical(VP8Decoder *dec , VP8Io *io ) 
{ 
  int ok ;
  WebPWorkerInterface *__cil_tmp4 ;

  {
#line 602
  ok = 1;
#line 603
  if (dec->mt_method_ > 0) {
    {
#line 604
    ok = (*(__cil_tmp4->Sync))((WebPWorker */* const  */)(& dec->worker_));
    }
  }
#line 607
  if ((unsigned long )io->teardown != (unsigned long )((void *)0)) {
    {
#line 608
    (*(io->teardown))(io);
    }
  }
#line 610
  return (ok);
}
}
#line 641 "/root/patron-new/new_3/src/dec/frame_dec.c"
static int InitThreadContext(VP8Decoder *dec ) 
{ 
  WebPWorker *worker ;
  WebPWorkerInterface *__cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int tmp___0 ;

  {
#line 642
  dec->cache_id_ = 0;
#line 643
  if (dec->mt_method_ > 0) {
    {
#line 644
    worker = & dec->worker_;
#line 645
    __cil_tmp4 = (*(__cil_tmp3->Reset))((WebPWorker */* const  */)worker);
    }
#line 645
    if (! __cil_tmp4) {
      {
#line 646
      __cil_tmp5 = VP8SetError(dec, (VP8StatusCode )1, "thread initialization failed.");
      }
#line 646
      return (__cil_tmp5);
    }
#line 649
    worker->data1 = (void *)dec;
#line 650
    worker->data2 = (void *)(& dec->thread_ctx_.io_);
#line 651
    worker->hook = & FinishRow;
#line 652
    if (dec->filter_type_ > 0) {
#line 652
      tmp___0 = 3;
    } else {
#line 652
      tmp___0 = 2;
    }
#line 652
    dec->num_caches_ = tmp___0;
  } else {
#line 655
    dec->num_caches_ = 1;
  }
#line 657
  return (1);
}
}
#line 660 "/root/patron-new/new_3/src/dec/frame_dec.c"
int VP8GetThreadMethod(WebPDecoderOptions *options , WebPHeaderStructure *headers ,
                       int width , int height ) 
{ 


  {
#line 663
  if ((unsigned long )options == (unsigned long )((void *)0)) {
#line 664
    return (0);
  } else
#line 663
  if (options->use_threads == 0) {
#line 664
    return (0);
  }
#line 671
  if (width >= 512) {
#line 671
    return (2);
  }
#line 673
  return (0);
}
}
#line 682 "/root/patron-new/new_3/src/dec/frame_dec.c"
static int AllocateMemory(VP8Decoder *dec ) 
{ 
  int num_caches ;
  int mb_w ;
  size_t intra_pred_mode_size ;
  size_t top_size ;
  size_t mb_info_size ;
  size_t f_info_size ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  size_t yuv_size ;
  size_t mb_data_size ;
  int tmp___2 ;
  size_t cache_height ;
  size_t cache_size ;
  uint64_t alpha_size ;
  unsigned long long tmp___3 ;
  uint64_t needed ;
  uint8_t *mem ;
  int __cil_tmp20 ;
  VP8FInfo *tmp___4 ;
  int extra_rows ;
  int extra_y ;
  int extra_uv ;
  uint8_t *tmp___5 ;

  {
#line 683
  num_caches = dec->num_caches_;
#line 684
  mb_w = dec->mb_w_;
#line 686
  intra_pred_mode_size = (unsigned long )(4 * mb_w) * sizeof(uint8_t );
#line 687
  top_size = sizeof(VP8TopSamples ) * (unsigned long )mb_w;
#line 688
  mb_info_size = (unsigned long )(mb_w + 1) * sizeof(VP8MB );
#line 689
  if (dec->filter_type_ > 0) {
#line 689
    if (dec->mt_method_ > 0) {
#line 689
      tmp___0 = 2;
    } else {
#line 689
      tmp___0 = 1;
    }
#line 689
    tmp___1 = (unsigned long )(mb_w * tmp___0) * sizeof(VP8FInfo );
  } else {
#line 689
    tmp___1 = 0UL;
  }
#line 689
  f_info_size = tmp___1;
#line 693
  yuv_size = 832UL * sizeof(*(dec->yuv_b_));
#line 694
  if (dec->mt_method_ == 2) {
#line 694
    tmp___2 = 2;
  } else {
#line 694
    tmp___2 = 1;
  }
#line 694
  mb_data_size = (unsigned long )(tmp___2 * mb_w) * sizeof(*(dec->mb_data_));
#line 696
  cache_height = (size_t )(((16 * num_caches + (int )kFilterExtraRows[dec->filter_type_]) * 3) / 2);
#line 698
  cache_size = top_size * cache_height;
#line 700
  if ((unsigned long )dec->alpha_data_ != (unsigned long )((void *)0)) {
#line 700
    tmp___3 = (unsigned long long )((uint64_t )dec->pic_hdr_.width_ * (unsigned long )dec->pic_hdr_.height_);
  } else {
#line 700
    tmp___3 = 0ULL;
  }
#line 700
  alpha_size = (uint64_t )tmp___3;
#line 702
  needed = (((((((intra_pred_mode_size + top_size) + mb_info_size) + f_info_size) + yuv_size) + mb_data_size) + cache_size) + alpha_size) + 31UL;
#line 708
  if (needed != needed) {
#line 708
    return (0);
  }
#line 709
  if (needed > dec->mem_size_) {
    {
#line 710
    WebPSafeFree(dec->mem_);
#line 711
    dec->mem_size_ = (size_t )0;
#line 712
    dec->mem_ = WebPSafeMalloc(needed, sizeof(uint8_t ));
    }
#line 713
    if ((unsigned long )dec->mem_ == (unsigned long )((void *)0)) {
      {
#line 714
      __cil_tmp20 = VP8SetError(dec, (VP8StatusCode )1, "no memory during frame initialization.");
      }
#line 714
      return (__cil_tmp20);
    }
#line 718
    dec->mem_size_ = needed;
  }
#line 721
  mem = (uint8_t *)dec->mem_;
#line 722
  dec->intra_t_ = mem;
#line 723
  mem += intra_pred_mode_size;
#line 725
  dec->yuv_t_ = (VP8TopSamples *)mem;
#line 726
  mem += top_size;
#line 728
  dec->mb_info_ = (VP8MB *)mem + 1;
#line 729
  mem += mb_info_size;
#line 731
  if (f_info_size) {
#line 731
    tmp___4 = (VP8FInfo *)mem;
  } else {
#line 731
    tmp___4 = (VP8FInfo *)((void *)0);
  }
#line 731
  dec->f_info_ = tmp___4;
#line 732
  mem += f_info_size;
#line 733
  dec->thread_ctx_.id_ = 0;
#line 734
  dec->thread_ctx_.f_info_ = dec->f_info_;
#line 735
  if (dec->filter_type_ > 0) {
#line 735
    if (dec->mt_method_ > 0) {
#line 739
      dec->thread_ctx_.f_info_ += mb_w;
    }
  }
#line 742
  mem = (uint8_t *)(((uintptr_t )mem + 31UL) & 0xffffffffffffffe0UL);
#line 744
  dec->yuv_b_ = mem;
#line 745
  mem += yuv_size;
#line 747
  dec->mb_data_ = (VP8MBData *)mem;
#line 748
  dec->thread_ctx_.mb_data_ = (VP8MBData *)mem;
#line 749
  if (dec->mt_method_ == 2) {
#line 750
    dec->thread_ctx_.mb_data_ += mb_w;
  }
#line 752
  mem += mb_data_size;
#line 754
  dec->cache_y_stride_ = 16 * mb_w;
#line 755
  dec->cache_uv_stride_ = 8 * mb_w;
#line 757
  extra_rows = (int )kFilterExtraRows[dec->filter_type_];
#line 758
  extra_y = extra_rows * dec->cache_y_stride_;
#line 759
  extra_uv = (extra_rows / 2) * dec->cache_uv_stride_;
#line 760
  dec->cache_y_ = mem + extra_y;
#line 761
  dec->cache_u_ = (dec->cache_y_ + (16 * num_caches) * dec->cache_y_stride_) + extra_uv;
#line 763
  dec->cache_v_ = (dec->cache_u_ + (8 * num_caches) * dec->cache_uv_stride_) + extra_uv;
#line 765
  dec->cache_id_ = 0;
#line 767
  mem += cache_size;
#line 770
  if (alpha_size) {
#line 770
    tmp___5 = mem;
  } else {
#line 770
    tmp___5 = (uint8_t *)((void *)0);
  }
  {
#line 770
  dec->alpha_plane_ = tmp___5;
#line 771
  mem += alpha_size;
#line 775
  memset((void *)(dec->mb_info_ - 1), 0, mb_info_size);
#line 776
  VP8InitScanline(dec);
#line 779
  memset((void *)dec->intra_t_, 0, intra_pred_mode_size);
  }
#line 781
  return (1);
}
}
#line 784 "/root/patron-new/new_3/src/dec/frame_dec.c"
static void InitIo(VP8Decoder *dec , VP8Io *io ) 
{ 


  {
#line 786
  io->mb_y = 0;
#line 787
  io->y = dec->cache_y_;
#line 788
  io->u = dec->cache_u_;
#line 789
  io->v = dec->cache_v_;
#line 790
  io->y_stride = dec->cache_y_stride_;
#line 791
  io->uv_stride = dec->cache_uv_stride_;
#line 792
  io->a = (uint8_t *)((void *)0);
#line 793
  return;
}
}
#line 795 "/root/patron-new/new_3/src/dec/frame_dec.c"
int VP8InitFrame(VP8Decoder *dec , VP8Io *io ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 796
  __cil_tmp3 = InitThreadContext(dec);
  }
#line 796
  if (! __cil_tmp3) {
#line 796
    return (0);
  }
  {
#line 797
  __cil_tmp4 = AllocateMemory(dec);
  }
#line 797
  if (! __cil_tmp4) {
#line 797
    return (0);
  }
  {
#line 798
  InitIo(dec, io);
#line 799
  VP8DspInit();
  }
#line 800
  return (1);
}
}
#line 24 "/root/patron-new/new_3/src/dec/buffer_dec.c"
static uint8_t kModeBpp[13]  = 
#line 24 "/root/patron-new/new_3/src/dec/buffer_dec.c"
  {      (uint8_t )3,      (uint8_t )4,      (uint8_t )3,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )2,      (uint8_t )2,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )2,      (uint8_t )1, 
        (uint8_t )1};
#line 32 "/root/patron-new/new_3/src/dec/buffer_dec.c"
static int IsValidColorspace(int webp_csp_mode ) 
{ 
  int tmp___0 ;

  {
#line 33
  if (webp_csp_mode >= 0) {
#line 33
    if (webp_csp_mode < 13) {
#line 33
      tmp___0 = 1;
    } else {
#line 33
      tmp___0 = 0;
    }
  } else {
#line 33
    tmp___0 = 0;
  }
#line 33
  return (tmp___0);
}
}
#line 41 "/root/patron-new/new_3/src/dec/buffer_dec.c"
static VP8StatusCode CheckDecBuffer(WebPDecBuffer *buffer ) 
{ 
  int ok ;
  WEBP_CSP_MODE mode ;
  int width ;
  int height ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  WebPYUVABuffer *buf ;
  int uv_width ;
  int uv_height ;
  int y_stride ;
  int __cil_tmp12 ;
  int u_stride ;
  int __cil_tmp14 ;
  int v_stride ;
  int __cil_tmp16 ;
  int a_stride ;
  int __cil_tmp18 ;
  uint64_t y_size ;
  uint64_t u_size ;
  uint64_t v_size ;
  uint64_t a_size ;
  WebPRGBABuffer *buf___0 ;
  int stride ;
  int __cil_tmp25 ;
  uint64_t size ;
  int tmp___0 ;

  {
  {
#line 42
  ok = 1;
#line 43
  mode = buffer->colorspace;
#line 44
  width = buffer->width;
#line 45
  height = buffer->height;
#line 46
  __cil_tmp6 = IsValidColorspace((int )mode);
  }
#line 46
  if (! __cil_tmp6) {
#line 47
    ok = 0;
  } else {
    {
#line 48
    __cil_tmp7 = WebPIsRGBMode(mode);
    }
#line 48
    if (! __cil_tmp7) {
      {
#line 49
      buf = & buffer->u.YUVA;
#line 50
      uv_width = (width + 1) / 2;
#line 51
      uv_height = (height + 1) / 2;
#line 52
      __cil_tmp12 = abs(buf->y_stride);
#line 52
      y_stride = __cil_tmp12;
#line 53
      __cil_tmp14 = abs(buf->u_stride);
#line 53
      u_stride = __cil_tmp14;
#line 54
      __cil_tmp16 = abs(buf->v_stride);
#line 54
      v_stride = __cil_tmp16;
#line 55
      __cil_tmp18 = abs(buf->a_stride);
#line 55
      a_stride = __cil_tmp18;
#line 56
      y_size = (uint64_t )y_stride * (unsigned long )(height - 1) + (unsigned long )width;
#line 57
      u_size = (uint64_t )u_stride * (unsigned long )(uv_height - 1) + (unsigned long )uv_width;
#line 58
      v_size = (uint64_t )v_stride * (unsigned long )(uv_height - 1) + (unsigned long )uv_width;
#line 59
      a_size = (uint64_t )a_stride * (unsigned long )(height - 1) + (unsigned long )width;
#line 60
      ok &= y_size <= buf->y_size;
#line 61
      ok &= u_size <= buf->u_size;
#line 62
      ok &= v_size <= buf->v_size;
#line 63
      ok &= y_stride >= width;
#line 64
      ok &= u_stride >= uv_width;
#line 65
      ok &= v_stride >= uv_width;
#line 66
      ok &= (unsigned long )buf->y != (unsigned long )((void *)0);
#line 67
      ok &= (unsigned long )buf->u != (unsigned long )((void *)0);
#line 68
      ok &= (unsigned long )buf->v != (unsigned long )((void *)0);
      }
#line 69
      if ((unsigned int )mode == 12U) {
#line 70
        ok &= a_stride >= width;
#line 71
        ok &= a_size <= buf->a_size;
#line 72
        ok &= (unsigned long )buf->a != (unsigned long )((void *)0);
      }
    } else {
      {
#line 75
      buf___0 = & buffer->u.RGBA;
#line 76
      __cil_tmp25 = abs(buf___0->stride);
#line 76
      stride = __cil_tmp25;
#line 77
      size = (uint64_t )stride * (unsigned long )(height - 1) + (unsigned long )(width * (int )kModeBpp[mode]);
#line 79
      ok &= size <= buf___0->size;
#line 80
      ok &= stride >= width * (int )kModeBpp[mode];
#line 81
      ok &= (unsigned long )buf___0->rgba != (unsigned long )((void *)0);
      }
    }
  }
#line 83
  if (ok) {
#line 83
    tmp___0 = 0;
  } else {
#line 83
    tmp___0 = 2;
  }
#line 83
  return ((VP8StatusCode )tmp___0);
}
}
#line 87 "/root/patron-new/new_3/src/dec/buffer_dec.c"
static VP8StatusCode AllocateBuffer(WebPDecBuffer *buffer ) 
{ 
  int w ;
  int h ;
  WEBP_CSP_MODE mode ;
  int __cil_tmp5 ;
  uint8_t *output ;
  int uv_stride ;
  int a_stride ;
  uint64_t uv_size ;
  uint64_t a_size ;
  uint64_t total_size ;
  int stride ;
  uint64_t size ;
  int __cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  WebPYUVABuffer *buf ;
  WebPRGBABuffer *buf___0 ;
  VP8StatusCode __cil_tmp19 ;

  {
  {
#line 88
  w = buffer->width;
#line 89
  h = buffer->height;
#line 90
  mode = buffer->colorspace;
#line 92
  __cil_tmp5 = IsValidColorspace((int )mode);
  }
#line 92
  if (w <= 0) {
#line 93
    return ((VP8StatusCode )2);
  } else
#line 92
  if (h <= 0) {
#line 93
    return ((VP8StatusCode )2);
  } else
#line 92
  if (! __cil_tmp5) {
#line 93
    return ((VP8StatusCode )2);
  }
#line 96
  if ((unsigned long )buffer->private_memory == (unsigned long )((void *)0)) {
#line 96
    if (buffer->is_external_memory <= 0) {
#line 98
      uv_stride = 0;
#line 98
      a_stride = 0;
#line 99
      uv_size = (uint64_t )0;
#line 99
      a_size = (uint64_t )0;
#line 105
      if ((unsigned long long )((uint64_t )w * (unsigned long )kModeBpp[mode]) >= 1ULL << 31) {
#line 106
        return ((VP8StatusCode )2);
      }
      {
#line 108
      stride = w * (int )kModeBpp[mode];
#line 109
      size = (uint64_t )stride * (unsigned long )h;
#line 110
      __cil_tmp14 = WebPIsRGBMode(mode);
      }
#line 110
      if (! __cil_tmp14) {
#line 111
        uv_stride = (w + 1) / 2;
#line 112
        uv_size = (uint64_t )uv_stride * (unsigned long )((h + 1) / 2);
#line 113
        if ((unsigned int )mode == 12U) {
#line 114
          a_stride = w;
#line 115
          a_size = (uint64_t )a_stride * (unsigned long )h;
        }
      }
      {
#line 118
      total_size = (size + 2UL * uv_size) + a_size;
#line 120
      __cil_tmp15 = WebPSafeMalloc(total_size, sizeof(*output));
#line 120
      output = (uint8_t *)__cil_tmp15;
      }
#line 121
      if ((unsigned long )output == (unsigned long )((void *)0)) {
#line 122
        return ((VP8StatusCode )1);
      }
      {
#line 124
      buffer->private_memory = output;
#line 126
      __cil_tmp16 = WebPIsRGBMode(mode);
      }
#line 126
      if (! __cil_tmp16) {
#line 127
        buf = & buffer->u.YUVA;
#line 128
        buf->y = output;
#line 129
        buf->y_stride = stride;
#line 130
        buf->y_size = size;
#line 131
        buf->u = output + size;
#line 132
        buf->u_stride = uv_stride;
#line 133
        buf->u_size = uv_size;
#line 134
        buf->v = (output + size) + uv_size;
#line 135
        buf->v_stride = uv_stride;
#line 136
        buf->v_size = uv_size;
#line 137
        if ((unsigned int )mode == 12U) {
#line 138
          buf->a = (output + size) + 2UL * uv_size;
        }
#line 140
        buf->a_size = a_size;
#line 141
        buf->a_stride = a_stride;
      } else {
#line 143
        buf___0 = & buffer->u.RGBA;
#line 144
        buf___0->rgba = output;
#line 145
        buf___0->stride = stride;
#line 146
        buf___0->size = size;
      }
    }
  }
  {
#line 149
  __cil_tmp19 = CheckDecBuffer(buffer);
  }
#line 149
  return (__cil_tmp19);
}
}
#line 152 "/root/patron-new/new_3/src/dec/buffer_dec.c"
VP8StatusCode WebPFlipBuffer(WebPDecBuffer *buffer ) 
{ 
  int __cil_tmp2 ;
  WebPRGBABuffer *buf ;
  WebPYUVABuffer *buf___0 ;
  int64_t H ;

  {
#line 153
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 154
    return ((VP8StatusCode )2);
  }
  {
#line 156
  __cil_tmp2 = WebPIsRGBMode(buffer->colorspace);
  }
#line 156
  if (__cil_tmp2) {
#line 157
    buf = & buffer->u.RGBA;
#line 158
    buf->rgba += (int64_t )(buffer->height - 1) * (long )buf->stride;
#line 159
    buf->stride = - buf->stride;
  } else {
#line 161
    buf___0 = & buffer->u.YUVA;
#line 162
    H = (int64_t )buffer->height;
#line 163
    buf___0->y += (H - 1L) * (long )buf___0->y_stride;
#line 164
    buf___0->y_stride = - buf___0->y_stride;
#line 165
    buf___0->u += ((H - 1L) >> 1) * (long )buf___0->u_stride;
#line 166
    buf___0->u_stride = - buf___0->u_stride;
#line 167
    buf___0->v += ((H - 1L) >> 1) * (long )buf___0->v_stride;
#line 168
    buf___0->v_stride = - buf___0->v_stride;
#line 169
    if ((unsigned long )buf___0->a != (unsigned long )((void *)0)) {
#line 170
      buf___0->a += (H - 1L) * (long )buf___0->a_stride;
#line 171
      buf___0->a_stride = - buf___0->a_stride;
    }
  }
#line 174
  return ((VP8StatusCode )0);
}
}
#line 177 "/root/patron-new/new_3/src/dec/buffer_dec.c"
VP8StatusCode WebPAllocateDecBuffer(int width , int height , WebPDecoderOptions *options ,
                                    WebPDecBuffer *buffer ) 
{ 
  VP8StatusCode status ;
  int cw ;
  int ch ;
  int x ;
  int y ;
  int __cil_tmp10 ;
  int scaled_width ;
  int scaled_height ;
  int __cil_tmp13 ;

  {
#line 181
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 182
    return ((VP8StatusCode )2);
  } else
#line 181
  if (width <= 0) {
#line 182
    return ((VP8StatusCode )2);
  } else
#line 181
  if (height <= 0) {
#line 182
    return ((VP8StatusCode )2);
  }
#line 184
  if ((unsigned long )options != (unsigned long )((void *)0)) {
#line 185
    if (options->use_cropping) {
      {
#line 186
      cw = options->crop_width;
#line 187
      ch = options->crop_height;
#line 188
      x = options->crop_left & -2;
#line 189
      y = options->crop_top & -2;
#line 190
      __cil_tmp10 = WebPCheckCropDimensions(width, height, x, y, cw, ch);
      }
#line 190
      if (! __cil_tmp10) {
#line 191
        return ((VP8StatusCode )2);
      }
#line 193
      width = cw;
#line 194
      height = ch;
    }
#line 197
    if (options->use_scaling) {
      {
#line 199
      scaled_width = options->scaled_width;
#line 200
      scaled_height = options->scaled_height;
#line 201
      __cil_tmp13 = WebPRescalerGetScaledDimensions(width, height, & scaled_width,
                                                    & scaled_height);
      }
#line 201
      if (! __cil_tmp13) {
#line 203
        return ((VP8StatusCode )2);
      }
#line 205
      width = scaled_width;
#line 206
      height = scaled_height;
    }
  }
  {
#line 212
  buffer->width = width;
#line 213
  buffer->height = height;
#line 216
  status = AllocateBuffer(buffer);
  }
#line 217
  if ((unsigned int )status != 0U) {
#line 217
    return (status);
  }
#line 220
  if ((unsigned long )options != (unsigned long )((void *)0)) {
#line 220
    if (options->flip) {
      {
#line 221
      status = WebPFlipBuffer(buffer);
      }
    }
  }
#line 223
  return (status);
}
}
#line 229 "/root/patron-new/new_3/src/dec/buffer_dec.c"
int WebPInitDecBufferInternal(WebPDecBuffer *buffer , int version ) 
{ 


  {
#line 230
  if (version >> 8 != 521 >> 8) {
#line 231
    return (0);
  }
#line 233
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 233
    return (0);
  }
  {
#line 234
  memset((void *)buffer, 0, sizeof(*buffer));
  }
#line 235
  return (1);
}
}
#line 238 "/root/patron-new/new_3/src/dec/buffer_dec.c"
void WebPFreeDecBuffer(WebPDecBuffer *buffer ) 
{ 


  {
#line 239
  if ((unsigned long )buffer != (unsigned long )((void *)0)) {
#line 240
    if (buffer->is_external_memory <= 0) {
      {
#line 241
      WebPSafeFree((void *)buffer->private_memory);
      }
    }
#line 243
    buffer->private_memory = (uint8_t *)((void *)0);
  }
#line 245
  return;
}
}
#line 247 "/root/patron-new/new_3/src/dec/buffer_dec.c"
void WebPCopyDecBuffer(WebPDecBuffer *src , WebPDecBuffer *dst ) 
{ 


  {
#line 249
  if ((unsigned long )src != (unsigned long )((void *)0)) {
#line 249
    if ((unsigned long )dst != (unsigned long )((void *)0)) {
#line 250
      *dst = *src;
#line 251
      if ((unsigned long )src->private_memory != (unsigned long )((void *)0)) {
#line 252
        dst->is_external_memory = 1;
#line 253
        dst->private_memory = (uint8_t *)((void *)0);
      }
    }
  }
#line 257
  return;
}
}
#line 259 "/root/patron-new/new_3/src/dec/buffer_dec.c"
void WebPGrabDecBuffer(WebPDecBuffer *src , WebPDecBuffer *dst ) 
{ 


  {
#line 260
  if ((unsigned long )src != (unsigned long )((void *)0)) {
#line 260
    if ((unsigned long )dst != (unsigned long )((void *)0)) {
#line 261
      *dst = *src;
#line 262
      if ((unsigned long )src->private_memory != (unsigned long )((void *)0)) {
#line 263
        src->is_external_memory = 1;
#line 264
        src->private_memory = (uint8_t *)((void *)0);
      }
    }
  }
#line 268
  return;
}
}
#line 269 "/root/patron-new/new_3/src/dec/buffer_dec.c"
VP8StatusCode WebPCopyDecBufferPixels(WebPDecBuffer *src_buf , WebPDecBuffer *dst_buf ) 
{ 
  VP8StatusCode __cil_tmp3 ;
  int __cil_tmp4 ;
  WebPRGBABuffer *src ;
  WebPRGBABuffer *dst ;
  WebPYUVABuffer *src___0 ;
  WebPYUVABuffer *dst___0 ;
  int __cil_tmp9 ;

  {
  {
#line 274
  dst_buf->width = src_buf->width;
#line 275
  dst_buf->height = src_buf->height;
#line 276
  __cil_tmp3 = CheckDecBuffer(dst_buf);
  }
#line 276
  if ((unsigned int )__cil_tmp3 != 0U) {
#line 277
    return ((VP8StatusCode )2);
  }
  {
#line 279
  __cil_tmp4 = WebPIsRGBMode(src_buf->colorspace);
  }
#line 279
  if (__cil_tmp4) {
    {
#line 280
    src = & src_buf->u.RGBA;
#line 281
    dst = & dst_buf->u.RGBA;
#line 282
    WebPCopyPlane(src->rgba, src->stride, dst->rgba, dst->stride, src_buf->width * (int )kModeBpp[src_buf->colorspace],
                  src_buf->height);
    }
  } else {
    {
#line 286
    src___0 = & src_buf->u.YUVA;
#line 287
    dst___0 = & dst_buf->u.YUVA;
#line 288
    WebPCopyPlane(src___0->y, src___0->y_stride, dst___0->y, dst___0->y_stride, src_buf->width,
                  src_buf->height);
#line 290
    WebPCopyPlane(src___0->u, src___0->u_stride, dst___0->u, dst___0->u_stride, (src_buf->width + 1) / 2,
                  (src_buf->height + 1) / 2);
#line 292
    WebPCopyPlane(src___0->v, src___0->v_stride, dst___0->v, dst___0->v_stride, (src_buf->width + 1) / 2,
                  (src_buf->height + 1) / 2);
#line 294
    __cil_tmp9 = WebPIsAlphaMode(src_buf->colorspace);
    }
#line 294
    if (__cil_tmp9) {
      {
#line 295
      WebPCopyPlane(src___0->a, src___0->a_stride, dst___0->a, dst___0->a_stride,
                    src_buf->width, src_buf->height);
      }
    }
  }
#line 299
  return ((VP8StatusCode )0);
}
}
#line 302 "/root/patron-new/new_3/src/dec/buffer_dec.c"
int WebPAvoidSlowMemory(WebPDecBuffer *output , WebPBitstreamFeatures *features ) 
{ 
  int __cil_tmp3 ;
  int tmp___0 ;

  {
  {
#line 305
  __cil_tmp3 = WebPIsPremultipliedMode(output->colorspace);
  }
#line 305
  if ((unsigned long )features != (unsigned long )((void *)0)) {
#line 305
    if (features->has_alpha) {
#line 305
      if (output->is_external_memory >= 2) {
#line 305
        if (__cil_tmp3) {
#line 305
          tmp___0 = 1;
        } else {
#line 305
          tmp___0 = 0;
        }
      } else {
#line 305
        tmp___0 = 0;
      }
    } else {
#line 305
      tmp___0 = 0;
    }
  } else {
#line 305
    tmp___0 = 0;
  }
#line 305
  return (tmp___0);
}
}
#line 27 "/root/patron-new/new_3/src/dec/alpha_dec.c"
static ALPHDecoder *ALPHNew(void) 
{ 
  ALPHDecoder *dec ;
  void *__cil_tmp2 ;

  {
  {
#line 28
  __cil_tmp2 = WebPSafeCalloc((uint64_t )1ULL, sizeof(*dec));
#line 28
  dec = (ALPHDecoder *)__cil_tmp2;
  }
#line 29
  return (dec);
}
}
#line 33 "/root/patron-new/new_3/src/dec/alpha_dec.c"
static void ALPHDelete(ALPHDecoder *dec ) 
{ 


  {
#line 34
  if ((unsigned long )dec != (unsigned long )((void *)0)) {
    {
#line 35
    VP8LDelete(dec->vp8l_dec_);
#line 36
    dec->vp8l_dec_ = (struct VP8LDecoder *)((void *)0);
#line 37
    WebPSafeFree((void *)dec);
    }
  }
#line 40
  return;
}
}
#line 48 "/root/patron-new/new_3/src/dec/alpha_dec.c"
static int ALPHInit(ALPHDecoder *dec , uint8_t *data , size_t data_size , VP8Io *src_io ,
                    uint8_t *output ) 
{ 
  int ok ;
  uint8_t *alpha_data ;
  size_t alpha_data_size ;
  int rsrv ;
  VP8Io *io ;
  size_t alpha_decoded_size ;

  {
  {
#line 51
  ok = 0;
#line 52
  alpha_data = data + 1;
#line 53
  alpha_data_size = data_size - 1UL;
#line 55
  io = & dec->io_;
#line 59
  VP8FiltersInit();
#line 60
  dec->output_ = output;
#line 61
  dec->width_ = src_io->width;
#line 62
  dec->height_ = src_io->height;
  }
#line 65
  if (data_size <= 1UL) {
#line 66
    return (0);
  }
#line 69
  dec->method_ = (int )*(data + 0) & 3;
#line 70
  dec->filter_ = (WEBP_FILTER_TYPE )(((int )*(data + 0) >> 2) & 3);
#line 71
  dec->pre_processing_ = ((int )*(data + 0) >> 4) & 3;
#line 72
  rsrv = ((int )*(data + 0) >> 6) & 3;
#line 73
  if (dec->method_ < 0) {
#line 78
    return (0);
  } else
#line 73
  if (dec->method_ > 1) {
#line 78
    return (0);
  } else
#line 73
  if ((unsigned int )dec->filter_ >= 4U) {
#line 78
    return (0);
  } else
#line 73
  if (dec->pre_processing_ > 1) {
#line 78
    return (0);
  } else
#line 73
  if (rsrv != 0) {
#line 78
    return (0);
  }
  {
#line 82
  VP8InitIo(io);
#line 83
  WebPInitCustomIo((WebPDecParams *)((void *)0), io);
#line 84
  io->opaque = (void *)dec;
#line 85
  io->width = src_io->width;
#line 86
  io->height = src_io->height;
#line 88
  io->use_cropping = src_io->use_cropping;
#line 89
  io->crop_left = src_io->crop_left;
#line 90
  io->crop_right = src_io->crop_right;
#line 91
  io->crop_top = src_io->crop_top;
#line 92
  io->crop_bottom = src_io->crop_bottom;
  }
#line 95
  if (dec->method_ == 0) {
#line 96
    alpha_decoded_size = (size_t )(dec->width_ * dec->height_);
#line 97
    ok = alpha_data_size >= alpha_decoded_size;
  } else {
    {
#line 100
    ok = VP8LDecodeAlphaHeader(dec, alpha_data, alpha_data_size);
    }
  }
#line 103
  return (ok);
}
}
#line 110 "/root/patron-new/new_3/src/dec/alpha_dec.c"
static int ALPHDecode(VP8Decoder *dec , int row , int num_rows ) 
{ 
  ALPHDecoder *alph_dec ;
  int width ;
  int height ;
  int y ;
  uint8_t *prev_line ;
  uint8_t *deltas ;
  uint8_t *dst ;
  int __cil_tmp11 ;

  {
#line 111
  alph_dec = dec->alph_dec_;
#line 112
  width = alph_dec->width_;
#line 113
  height = alph_dec->io_.crop_bottom;
#line 114
  if (alph_dec->method_ == 0) {
#line 116
    prev_line = dec->alpha_prev_line_;
#line 117
    deltas = (dec->alpha_data_ + 1) + row * width;
#line 118
    dst = dec->alpha_plane_ + row * width;
#line 120
    if ((unsigned int )alph_dec->filter_ != 0U) {
#line 122
      y = 0;
      {
#line 122
      while (1) {
        while_continue: /* CIL Label */ ;

#line 122
        if (! (y < num_rows)) {
#line 122
          goto while_break;
        }
        {
#line 123
        (*(WebPUnfilters[alph_dec->filter_]))(prev_line, deltas, dst, width);
#line 124
        prev_line = dst;
#line 125
        dst += width;
#line 126
        deltas += width;
#line 122
        y ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: ;
    } else {
#line 129
      y = 0;
      {
#line 129
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 129
        if (! (y < num_rows)) {
#line 129
          goto while_break___0;
        }
        {
#line 130
        memcpy((void *)dst, (void const   *)deltas, (unsigned long )width * sizeof(*dst));
#line 131
        prev_line = dst;
#line 132
        dst += width;
#line 133
        deltas += width;
#line 129
        y ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
    }
#line 136
    dec->alpha_prev_line_ = prev_line;
  } else {
    {
#line 139
    __cil_tmp11 = VP8LDecodeAlphaImageStream(alph_dec, row + num_rows);
    }
#line 139
    if (! __cil_tmp11) {
#line 140
      return (0);
    }
  }
#line 144
  if (row + num_rows >= height) {
#line 145
    dec->is_alpha_decoded_ = 1;
  }
#line 147
  return (1);
}
}
#line 150 "/root/patron-new/new_3/src/dec/alpha_dec.c"
static int AllocateAlphaPlane(VP8Decoder *dec , VP8Io *io ) 
{ 
  int stride ;
  int height ;
  uint64_t alpha_size ;
  void *__cil_tmp6 ;

  {
  {
#line 151
  stride = io->width;
#line 152
  height = io->crop_bottom;
#line 153
  alpha_size = (uint64_t )stride * (unsigned long )height;
#line 155
  __cil_tmp6 = WebPSafeMalloc(alpha_size, sizeof(*(dec->alpha_plane_)));
#line 155
  dec->alpha_plane_mem_ = (uint8_t *)__cil_tmp6;
  }
#line 157
  if ((unsigned long )dec->alpha_plane_mem_ == (unsigned long )((void *)0)) {
#line 158
    return (0);
  }
#line 160
  dec->alpha_plane_ = dec->alpha_plane_mem_;
#line 161
  dec->alpha_prev_line_ = (uint8_t *)((void *)0);
#line 162
  return (1);
}
}
#line 165 "/root/patron-new/new_3/src/dec/alpha_dec.c"
void WebPDeallocateAlphaMemory(VP8Decoder *dec ) 
{ 


  {
  {
#line 167
  WebPSafeFree((void *)dec->alpha_plane_mem_);
#line 168
  dec->alpha_plane_mem_ = (uint8_t *)((void *)0);
#line 169
  dec->alpha_plane_ = (uint8_t *)((void *)0);
#line 170
  ALPHDelete(dec->alph_dec_);
#line 171
  dec->alph_dec_ = (struct ALPHDecoder *)((void *)0);
  }
#line 173
  return;
}
}
#line 177 "/root/patron-new/new_3/src/dec/alpha_dec.c"
uint8_t *VP8DecompressAlphaRows(VP8Decoder *dec , VP8Io *io , int row , int num_rows ) 
{ 
  int width ;
  int height ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  uint8_t *alpha ;
  int __cil_tmp12 ;

  {
#line 180
  width = io->width;
#line 181
  height = io->crop_bottom;
#line 185
  if (row < 0) {
#line 186
    return ((uint8_t *)((void *)0));
  } else
#line 185
  if (num_rows <= 0) {
#line 186
    return ((uint8_t *)((void *)0));
  } else
#line 185
  if (row + num_rows > height) {
#line 186
    return ((uint8_t *)((void *)0));
  }
#line 189
  if (! dec->is_alpha_decoded_) {
#line 190
    if ((unsigned long )dec->alph_dec_ == (unsigned long )((void *)0)) {
      {
#line 191
      dec->alph_dec_ = ALPHNew();
      }
#line 192
      if ((unsigned long )dec->alph_dec_ == (unsigned long )((void *)0)) {
#line 192
        return ((uint8_t *)((void *)0));
      }
      {
#line 193
      __cil_tmp8 = AllocateAlphaPlane(dec, io);
      }
#line 193
      if (! __cil_tmp8) {
#line 193
        goto Error;
      }
      {
#line 194
      __cil_tmp9 = ALPHInit(dec->alph_dec_, dec->alpha_data_, dec->alpha_data_size_,
                            io, dec->alpha_plane_);
      }
#line 194
      if (! __cil_tmp9) {
#line 196
        goto Error;
      }
#line 199
      if ((dec->alph_dec_)->pre_processing_ != 1) {
#line 200
        dec->alpha_dithering_ = 0;
      } else {
#line 202
        num_rows = height - row;
      }
    }
    {
#line 208
    __cil_tmp10 = ALPHDecode(dec, row, num_rows);
    }
#line 208
    if (! __cil_tmp10) {
#line 208
      goto Error;
    }
#line 210
    if (dec->is_alpha_decoded_) {
      {
#line 211
      ALPHDelete(dec->alph_dec_);
#line 212
      dec->alph_dec_ = (struct ALPHDecoder *)((void *)0);
      }
#line 213
      if (dec->alpha_dithering_ > 0) {
        {
#line 214
        alpha = (dec->alpha_plane_ + io->crop_top * width) + io->crop_left;
#line 216
        __cil_tmp12 = WebPDequantizeLevels(alpha, io->crop_right - io->crop_left,
                                           io->crop_bottom - io->crop_top, width,
                                           dec->alpha_dithering_);
        }
#line 216
        if (! __cil_tmp12) {
#line 220
          goto Error;
        }
      }
    }
  }
#line 227
  return (dec->alpha_plane_ + row * width);
  Error: 
  {
#line 230
  WebPDeallocateAlphaMemory(dec);
  }
#line 231
  return ((uint8_t *)((void *)0));
}
}
#line 74 "../../src/webp/demux.h"
int WebPGetDemuxVersion(void) ;
#line 88
WebPDemuxer *WebPDemuxInternal(WebPData *data , int allow_partial , WebPDemuxState *state ,
                               int version ) ;
#line 94 "../../src/webp/demux.h"
__inline static WebPDemuxer *WebPDemux(WebPData *data ) 
{ 
  WebPDemuxer *__cil_tmp2 ;

  {
  {
#line 95
  __cil_tmp2 = WebPDemuxInternal(data, 0, (WebPDemuxState *)((void *)0), 263);
  }
#line 95
  return (__cil_tmp2);
}
}
#line 112
void WebPDemuxDelete(WebPDemuxer *dmux ) ;
#line 137
uint32_t WebPDemuxGetI(WebPDemuxer *dmux , WebPFormatFeature feature ) ;
#line 167
int WebPDemuxGetFrame(WebPDemuxer *dmux , int frame , WebPIterator *iter ) ;
#line 173
int WebPDemuxNextFrame(WebPIterator *iter ) ;
#line 174
int WebPDemuxPrevFrame(WebPIterator *iter ) ;
#line 180
void WebPDemuxReleaseIterator(WebPIterator *iter ) ;
#line 205
int WebPDemuxGetChunk(WebPDemuxer *dmux , char const   *fourcc , int chunk_num , WebPChunkIterator *iter ) ;
#line 212
int WebPDemuxNextChunk(WebPChunkIterator *iter ) ;
#line 213
int WebPDemuxPrevChunk(WebPChunkIterator *iter ) ;
#line 218
void WebPDemuxReleaseChunkIterator(WebPChunkIterator *iter ) ;
#line 260
int WebPAnimDecoderOptionsInitInternal(WebPAnimDecoderOptions *dec_options , int abi_version ) ;
#line 274
WebPAnimDecoder *WebPAnimDecoderNewInternal(WebPData *webp_data , WebPAnimDecoderOptions *dec_options ,
                                            int abi_version ) ;
#line 309
int WebPAnimDecoderGetInfo(WebPAnimDecoder *dec , WebPAnimInfo *info ) ;
#line 324
int WebPAnimDecoderGetNext(WebPAnimDecoder *dec , uint8_t **buf_ptr , int *timestamp_ptr ) ;
#line 333
int WebPAnimDecoderHasMoreFrames(WebPAnimDecoder *dec ) ;
#line 341
void WebPAnimDecoderReset(WebPAnimDecoder *dec ) ;
#line 351
WebPDemuxer *WebPAnimDecoderGetDemuxer(WebPAnimDecoder *dec ) ;
#line 357
void WebPAnimDecoderDelete(WebPAnimDecoder *dec ) ;
#line 88 "/root/patron-new/new_3/src/demux/demux.c"
static ParseStatus ParseSingleImage(WebPDemuxer *dmux ) ;
#line 89
static ParseStatus ParseVP8X___2(WebPDemuxer *dmux ) ;
#line 90
static int IsValidSimpleFormat(WebPDemuxer *dmux ) ;
#line 91
static int IsValidExtendedFormat(WebPDemuxer *dmux ) ;
#line 93 "/root/patron-new/new_3/src/demux/demux.c"
static ChunkParser kMasterChunks[4]  = {      {{(uint8_t )'V', (uint8_t )'P', (uint8_t )'8', (uint8_t )' '}, (ParseStatus (*)(WebPDemuxer * const   ))(& ParseSingleImage),
      (int (*)(WebPDemuxer * const   ))(& IsValidSimpleFormat)}, 
        {{(uint8_t )'V', (uint8_t )'P', (uint8_t )'8', (uint8_t )'L'}, (ParseStatus (*)(WebPDemuxer * const   ))(& ParseSingleImage),
      (int (*)(WebPDemuxer * const   ))(& IsValidSimpleFormat)}, 
        {{(uint8_t )'V', (uint8_t )'P', (uint8_t )'8', (uint8_t )'X'}, (ParseStatus (*)(WebPDemuxer * const   ))(& ParseVP8X___2),
      (int (*)(WebPDemuxer * const   ))(& IsValidExtendedFormat)}, 
        {{(uint8_t )'0', (uint8_t )'0', (uint8_t )'0', (uint8_t )'0'}, (ParseStatus (*)(WebPDemuxer * const   ))((void *)0),
      (int (*)(WebPDemuxer * const   ))((void *)0)}};
#line 102 "/root/patron-new/new_3/src/demux/demux.c"
int WebPGetDemuxVersion(void) 
{ 


  {
#line 103
  return ((1 << 16) | (2 << 8));
}
}
#line 109 "/root/patron-new/new_3/src/demux/demux.c"
static int RemapMemBuffer___2(MemBuffer___0 *mem , uint8_t *data , size_t size ) 
{ 


  {
#line 111
  if (size < mem->buf_size_) {
#line 111
    return (0);
  }
#line 113
  mem->buf_ = data;
#line 114
  mem->buf_size_ = size;
#line 114
  mem->end_ = mem->buf_size_;
#line 115
  return (1);
}
}
#line 118 "/root/patron-new/new_3/src/demux/demux.c"
static int InitMemBuffer___2(MemBuffer___0 *mem , uint8_t *data , size_t size ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 120
  memset((void *)mem, 0, sizeof(*mem));
#line 121
  __cil_tmp4 = RemapMemBuffer___2(mem, data, size);
  }
#line 121
  return (__cil_tmp4);
}
}
#line 125 "/root/patron-new/new_3/src/demux/demux.c"
__inline static size_t MemDataSize___2(MemBuffer___0 *mem ) 
{ 


  {
#line 126
  return (mem->end_ - mem->start_);
}
}
#line 130 "/root/patron-new/new_3/src/demux/demux.c"
__inline static int SizeIsInvalid(MemBuffer___0 *mem , size_t size ) 
{ 


  {
#line 131
  return (size > mem->riff_end_ - mem->start_);
}
}
#line 134 "/root/patron-new/new_3/src/demux/demux.c"
__inline static void Skip(MemBuffer___0 *mem , size_t size ) 
{ 


  {
#line 135
  mem->start_ += size;
#line 136
  return;
}
}
#line 138 "/root/patron-new/new_3/src/demux/demux.c"
__inline static void Rewind(MemBuffer___0 *mem , size_t size ) 
{ 


  {
#line 139
  mem->start_ -= size;
#line 140
  return;
}
}
#line 142 "/root/patron-new/new_3/src/demux/demux.c"
__inline static uint8_t *GetBuffer(MemBuffer___0 *mem ) 
{ 


  {
#line 143
  return (mem->buf_ + mem->start_);
}
}
#line 147 "/root/patron-new/new_3/src/demux/demux.c"
__inline static uint8_t ReadByte(MemBuffer___0 *mem ) 
{ 
  uint8_t byte ;

  {
  {
#line 148
  byte = *(mem->buf_ + mem->start_);
#line 149
  Skip(mem, (size_t )1);
  }
#line 150
  return (byte);
}
}
#line 153 "/root/patron-new/new_3/src/demux/demux.c"
__inline static int ReadLE16s(MemBuffer___0 *mem ) 
{ 
  uint8_t *data ;
  int val ;
  int __cil_tmp4 ;

  {
  {
#line 154
  data = mem->buf_ + mem->start_;
#line 155
  __cil_tmp4 = GetLE16(data);
#line 155
  val = __cil_tmp4;
#line 156
  Skip(mem, (size_t )2);
  }
#line 157
  return (val);
}
}
#line 160 "/root/patron-new/new_3/src/demux/demux.c"
__inline static int ReadLE24s(MemBuffer___0 *mem ) 
{ 
  uint8_t *data ;
  int val ;
  int __cil_tmp4 ;

  {
  {
#line 161
  data = mem->buf_ + mem->start_;
#line 162
  __cil_tmp4 = GetLE24(data);
#line 162
  val = __cil_tmp4;
#line 163
  Skip(mem, (size_t )3);
  }
#line 164
  return (val);
}
}
#line 167 "/root/patron-new/new_3/src/demux/demux.c"
__inline static uint32_t ReadLE32(MemBuffer___0 *mem ) 
{ 
  uint8_t *data ;
  uint32_t val ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 168
  data = mem->buf_ + mem->start_;
#line 169
  __cil_tmp4 = GetLE32(data);
#line 169
  val = __cil_tmp4;
#line 170
  Skip(mem, (size_t )4);
  }
#line 171
  return (val);
}
}
#line 177 "/root/patron-new/new_3/src/demux/demux.c"
static void AddChunk(WebPDemuxer *dmux , Chunk *chunk ) 
{ 


  {
#line 178
  *(dmux->chunks_tail_) = chunk;
#line 179
  chunk->next_ = (struct Chunk *)((void *)0);
#line 180
  dmux->chunks_tail_ = & chunk->next_;
#line 181
  return;
}
}
#line 185 "/root/patron-new/new_3/src/demux/demux.c"
static int AddFrame(WebPDemuxer *dmux , Frame *frame ) 
{ 
  Frame *last_frame ;

  {
#line 186
  last_frame = *(dmux->frames_tail_);
#line 187
  if ((unsigned long )last_frame != (unsigned long )((void *)0)) {
#line 187
    if (! last_frame->complete_) {
#line 187
      return (0);
    }
  }
#line 189
  *(dmux->frames_tail_) = frame;
#line 190
  frame->next_ = (struct Frame *)((void *)0);
#line 191
  dmux->frames_tail_ = & frame->next_;
#line 192
  return (1);
}
}
#line 195 "/root/patron-new/new_3/src/demux/demux.c"
static void SetFrameInfo(size_t start_offset , size_t size , int frame_num , int complete ,
                         WebPBitstreamFeatures *features , Frame *frame ) 
{ 


  {
#line 199
  frame->img_components_[0].offset_ = start_offset;
#line 200
  frame->img_components_[0].size_ = size;
#line 201
  frame->width_ = features->width;
#line 202
  frame->height_ = features->height;
#line 203
  frame->has_alpha_ |= features->has_alpha;
#line 204
  frame->frame_num_ = frame_num;
#line 205
  frame->complete_ = complete;
#line 206
  return;
}
}
#line 210 "/root/patron-new/new_3/src/demux/demux.c"
static ParseStatus StoreFrame(int frame_num , uint32_t min_size , MemBuffer___0 *mem ,
                              Frame *frame ) 
{ 
  int alpha_chunks ;
  int image_chunks ;
  int done ;
  size_t __cil_tmp8 ;
  size_t __cil_tmp9 ;
  ParseStatus status ;
  size_t chunk_start_offset ;
  uint32_t fourcc ;
  uint32_t __cil_tmp13 ;
  uint32_t payload_size ;
  uint32_t __cil_tmp15 ;
  uint32_t payload_size_padded ;
  size_t payload_available ;
  size_t chunk_size ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;
  size_t tmp___2 ;
  int __cil_tmp22 ;
  size_t __cil_tmp23 ;
  WebPBitstreamFeatures features ;
  VP8StatusCode vp8_status ;
  VP8StatusCode __cil_tmp26 ;
  size_t __cil_tmp27 ;
  int tmp___3 ;

  {
  {
#line 212
  alpha_chunks = 0;
#line 213
  image_chunks = 0;
#line 214
  __cil_tmp9 = MemDataSize___2(mem);
#line 214
  __cil_tmp8 = MemDataSize___2(mem);
  }
#line 214
  if (__cil_tmp8 < 8UL) {
#line 214
    tmp___3 = 1;
  } else
#line 214
  if (__cil_tmp9 < (unsigned long )min_size) {
#line 214
    tmp___3 = 1;
  } else {
#line 214
    tmp___3 = 0;
  }
#line 214
  done = tmp___3;
#line 216
  status = (ParseStatus )0;
#line 218
  if (done) {
#line 218
    return ((ParseStatus )1);
  }
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 221
    chunk_start_offset = mem->start_;
#line 222
    __cil_tmp13 = ReadLE32(mem);
#line 222
    fourcc = __cil_tmp13;
#line 223
    __cil_tmp15 = ReadLE32(mem);
#line 223
    payload_size = __cil_tmp15;
    }
#line 228
    if (payload_size > 4294967286U) {
#line 228
      return ((ParseStatus )2);
    }
    {
#line 230
    payload_size_padded = payload_size + (payload_size & 1U);
#line 231
    __cil_tmp19 = MemDataSize___2(mem);
    }
#line 231
    if ((unsigned long )payload_size_padded > __cil_tmp19) {
      {
#line 231
      __cil_tmp20 = MemDataSize___2(mem);
#line 231
      tmp___2 = __cil_tmp20;
      }
    } else {
#line 231
      tmp___2 = (unsigned long )payload_size_padded;
    }
    {
#line 231
    payload_available = tmp___2;
#line 233
    chunk_size = 8UL + payload_available;
#line 234
    __cil_tmp22 = SizeIsInvalid(mem, (size_t )payload_size_padded);
    }
#line 234
    if (__cil_tmp22) {
#line 234
      return ((ParseStatus )2);
    }
    {
#line 235
    __cil_tmp23 = MemDataSize___2(mem);
    }
#line 235
    if ((unsigned long )payload_size_padded > __cil_tmp23) {
#line 235
      status = (ParseStatus )1;
    }
#line 238
    if (fourcc == ((unsigned int )((65 | (76 << 8)) | (80 << 16)) | (72U << 24))) {
#line 238
      goto case_exp;
    }
#line 250
    if (fourcc == ((unsigned int )((86 | (80 << 8)) | (56 << 16)) | (76U << 24))) {
#line 250
      goto case_exp___0;
    }
#line 253
    if (fourcc == ((unsigned int )((86 | (80 << 8)) | (56 << 16)) | (32U << 24))) {
#line 253
      goto case_exp___1;
    }
#line 277
    goto switch_default;
    case_exp: 
#line 239
    if (alpha_chunks == 0) {
      {
#line 240
      alpha_chunks ++;
#line 241
      frame->img_components_[1].offset_ = chunk_start_offset;
#line 242
      frame->img_components_[1].size_ = chunk_size;
#line 243
      frame->has_alpha_ = 1;
#line 244
      frame->frame_num_ = frame_num;
#line 245
      Skip(mem, payload_available);
      }
    } else {
#line 247
      goto switch_default;
    }
#line 249
    goto switch_break;
    case_exp___0: 
#line 251
    if (alpha_chunks > 0) {
#line 251
      return ((ParseStatus )2);
    }
    case_exp___1: 
#line 254
    if (image_chunks == 0) {
      {
#line 258
      __cil_tmp26 = WebPGetFeatures(mem->buf_ + chunk_start_offset, chunk_size, & features);
#line 258
      vp8_status = __cil_tmp26;
      }
#line 261
      if ((unsigned int )status == 1U) {
#line 261
        if ((unsigned int )vp8_status == 7U) {
#line 263
          return ((ParseStatus )1);
        } else {
#line 261
          goto _L;
        }
      } else
      _L: 
#line 264
      if ((unsigned int )vp8_status != 0U) {
#line 266
        return ((ParseStatus )2);
      }
      {
#line 268
      image_chunks ++;
#line 269
      SetFrameInfo(chunk_start_offset, chunk_size, frame_num, (unsigned int )status == 0U,
                   & features, frame);
#line 271
      Skip(mem, payload_available);
      }
    } else {
#line 273
      goto switch_default;
    }
#line 275
    goto switch_break;
    switch_default: 
    {
#line 279
    Rewind(mem, (size_t )8);
#line 280
    done = 1;
    }
#line 281
    goto switch_break;
    switch_break: ;
#line 284
    if (mem->start_ == mem->riff_end_) {
#line 285
      done = 1;
    } else {
      {
#line 286
      __cil_tmp27 = MemDataSize___2(mem);
      }
#line 286
      if (__cil_tmp27 < 8UL) {
#line 287
        status = (ParseStatus )1;
      }
    }
#line 220
    if (! done) {
#line 220
      if (! ((unsigned int )status == 0U)) {
#line 220
        goto while_break;
      }
    } else {
#line 220
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 291
  return (status);
}
}
#line 298 "/root/patron-new/new_3/src/demux/demux.c"
static ParseStatus NewFrame(MemBuffer___0 *mem , uint32_t min_size , uint32_t actual_size ,
                            Frame **frame ) 
{ 
  int __cil_tmp5 ;
  size_t __cil_tmp6 ;
  void *__cil_tmp7 ;
  int tmp___2 ;

  {
  {
#line 301
  __cil_tmp5 = SizeIsInvalid(mem, (size_t )min_size);
  }
#line 301
  if (__cil_tmp5) {
#line 301
    return ((ParseStatus )2);
  }
#line 302
  if (actual_size < min_size) {
#line 302
    return ((ParseStatus )2);
  }
  {
#line 303
  __cil_tmp6 = MemDataSize___2(mem);
  }
#line 303
  if (__cil_tmp6 < (unsigned long )min_size) {
#line 303
    return ((ParseStatus )1);
  }
  {
#line 305
  __cil_tmp7 = WebPSafeCalloc((uint64_t )1ULL, sizeof(*(*frame)));
#line 305
  *frame = (Frame *)__cil_tmp7;
  }
#line 306
  if ((unsigned long )*frame == (unsigned long )((void *)0)) {
#line 306
    tmp___2 = 2;
  } else {
#line 306
    tmp___2 = 0;
  }
#line 306
  return ((ParseStatus )tmp___2);
}
}
#line 311 "/root/patron-new/new_3/src/demux/demux.c"
static ParseStatus ParseAnimationFrame(WebPDemuxer *dmux , uint32_t frame_chunk_size ) 
{ 
  int is_animation ;
  uint32_t anmf_payload_size ;
  int added_frame ;
  int bits ;
  MemBuffer___0 *mem ;
  Frame *frame ;
  size_t start_offset ;
  ParseStatus status ;
  ParseStatus __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  uint8_t __cil_tmp17 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 313
  is_animation = ! (! (dmux->feature_flags_ & 2U));
#line 314
  anmf_payload_size = frame_chunk_size - 16U;
#line 315
  added_frame = 0;
#line 317
  mem = & dmux->mem_;
#line 320
  __cil_tmp11 = NewFrame(mem, (uint32_t )16, frame_chunk_size, & frame);
#line 320
  status = __cil_tmp11;
  }
#line 322
  if ((unsigned int )status != 0U) {
#line 322
    return (status);
  }
  {
#line 324
  __cil_tmp12 = ReadLE24s(mem);
#line 324
  frame->x_offset_ = 2 * __cil_tmp12;
#line 325
  __cil_tmp13 = ReadLE24s(mem);
#line 325
  frame->y_offset_ = 2 * __cil_tmp13;
#line 326
  __cil_tmp14 = ReadLE24s(mem);
#line 326
  frame->width_ = 1 + __cil_tmp14;
#line 327
  __cil_tmp15 = ReadLE24s(mem);
#line 327
  frame->height_ = 1 + __cil_tmp15;
#line 328
  frame->duration_ = ReadLE24s(mem);
#line 329
  __cil_tmp17 = ReadByte(mem);
#line 329
  bits = (int )__cil_tmp17;
  }
#line 330
  if (bits & 1) {
#line 330
    tmp___2 = 1;
  } else {
#line 330
    tmp___2 = 0;
  }
#line 330
  frame->dispose_method_ = (WebPMuxAnimDispose )tmp___2;
#line 332
  if (bits & 2) {
#line 332
    tmp___3 = 1;
  } else {
#line 332
    tmp___3 = 0;
  }
#line 332
  frame->blend_method_ = (WebPMuxAnimBlend )tmp___3;
#line 333
  if ((unsigned long long )((unsigned long )frame->width_ * (uint64_t )frame->height_) >= 1ULL << 32) {
    {
#line 334
    WebPSafeFree((void *)frame);
    }
#line 335
    return ((ParseStatus )2);
  }
  {
#line 340
  start_offset = mem->start_;
#line 341
  status = StoreFrame(dmux->num_frames_ + 1, anmf_payload_size, mem, frame);
  }
#line 342
  if ((unsigned int )status != 2U) {
#line 342
    if (mem->start_ - start_offset > (unsigned long )anmf_payload_size) {
#line 343
      status = (ParseStatus )2;
    }
  }
#line 345
  if ((unsigned int )status != 2U) {
#line 345
    if (is_animation) {
#line 345
      if (frame->frame_num_ > 0) {
        {
#line 346
        added_frame = AddFrame(dmux, frame);
        }
#line 347
        if (added_frame) {
#line 348
          (dmux->num_frames_) ++;
        } else {
#line 350
          status = (ParseStatus )2;
        }
      }
    }
  }
#line 354
  if (! added_frame) {
    {
#line 354
    WebPSafeFree((void *)frame);
    }
  }
#line 355
  return (status);
}
}
#line 362 "/root/patron-new/new_3/src/demux/demux.c"
static int StoreChunk(WebPDemuxer *dmux , size_t start_offset , uint32_t size ) 
{ 
  Chunk *chunk ;
  void *__cil_tmp5 ;

  {
  {
#line 364
  __cil_tmp5 = WebPSafeCalloc((uint64_t )1ULL, sizeof(*chunk));
#line 364
  chunk = (Chunk *)__cil_tmp5;
  }
#line 365
  if ((unsigned long )chunk == (unsigned long )((void *)0)) {
#line 365
    return (0);
  }
  {
#line 367
  chunk->data_.offset_ = start_offset;
#line 368
  chunk->data_.size_ = (size_t )size;
#line 369
  AddChunk(dmux, chunk);
  }
#line 370
  return (1);
}
}
#line 376 "/root/patron-new/new_3/src/demux/demux.c"
static ParseStatus ReadHeader(MemBuffer___0 *mem ) 
{ 
  size_t min_size ;
  uint32_t riff_size ;
  size_t __cil_tmp4 ;
  uint8_t *__cil_tmp5 ;
  int __cil_tmp6 ;
  uint8_t *__cil_tmp7 ;
  int __cil_tmp8 ;
  uint8_t *__cil_tmp9 ;
  uint32_t __cil_tmp10 ;

  {
  {
#line 377
  min_size = (size_t )20;
#line 381
  __cil_tmp4 = MemDataSize___2(mem);
  }
#line 381
  if (__cil_tmp4 < min_size) {
#line 381
    return ((ParseStatus )1);
  }
  {
#line 382
  __cil_tmp7 = GetBuffer(mem);
#line 382
  __cil_tmp8 = memcmp((void const   *)(__cil_tmp7 + 8), (void const   *)"WEBP\001V",
                      4UL);
#line 382
  __cil_tmp5 = GetBuffer(mem);
#line 382
  __cil_tmp6 = memcmp((void const   *)__cil_tmp5, (void const   *)"RIFF", 4UL);
  }
#line 382
  if (__cil_tmp6) {
#line 384
    return ((ParseStatus )2);
  } else
#line 382
  if (__cil_tmp8) {
#line 384
    return ((ParseStatus )2);
  }
  {
#line 387
  __cil_tmp9 = GetBuffer(mem);
#line 387
  __cil_tmp10 = GetLE32(__cil_tmp9 + 4);
#line 387
  riff_size = __cil_tmp10;
  }
#line 388
  if (riff_size < 8U) {
#line 388
    return ((ParseStatus )2);
  }
#line 389
  if (riff_size > 4294967286U) {
#line 389
    return ((ParseStatus )2);
  }
#line 392
  mem->riff_end_ = (size_t )(riff_size + 8U);
#line 393
  if (mem->buf_size_ > mem->riff_end_) {
#line 394
    mem->end_ = mem->riff_end_;
#line 394
    mem->buf_size_ = mem->end_;
  }
  {
#line 397
  Skip(mem, (size_t )12);
  }
#line 398
  return ((ParseStatus )0);
}
}
#line 401 "/root/patron-new/new_3/src/demux/demux.c"
static ParseStatus ParseSingleImage(WebPDemuxer *dmux ) 
{ 
  size_t min_size ;
  MemBuffer___0 *mem ;
  Frame *frame ;
  ParseStatus status ;
  int image_added ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;
  void *__cil_tmp9 ;
  int has_alpha ;
  int tmp___2 ;
  int __cil_tmp13 ;

  {
#line 402
  min_size = (size_t )8;
#line 403
  mem = & dmux->mem_;
#line 406
  image_added = 0;
#line 408
  if ((unsigned long )dmux->frames_ != (unsigned long )((void *)0)) {
#line 408
    return ((ParseStatus )2);
  }
  {
#line 409
  __cil_tmp7 = SizeIsInvalid(mem, min_size);
  }
#line 409
  if (__cil_tmp7) {
#line 409
    return ((ParseStatus )2);
  }
  {
#line 410
  __cil_tmp8 = MemDataSize___2(mem);
  }
#line 410
  if (__cil_tmp8 < min_size) {
#line 410
    return ((ParseStatus )1);
  }
  {
#line 412
  __cil_tmp9 = WebPSafeCalloc((uint64_t )1ULL, sizeof(*frame));
#line 412
  frame = (Frame *)__cil_tmp9;
  }
#line 413
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
#line 413
    return ((ParseStatus )2);
  }
  {
#line 417
  status = StoreFrame(1, (uint32_t )0, & dmux->mem_, frame);
  }
#line 418
  if ((unsigned int )status != 2U) {
#line 419
    has_alpha = ! (! (dmux->feature_flags_ & 16U));
#line 421
    if (! has_alpha) {
#line 421
      if (frame->img_components_[1].size_ > 0UL) {
#line 422
        frame->img_components_[1].offset_ = (size_t )0;
#line 423
        frame->img_components_[1].size_ = (size_t )0;
#line 424
        frame->has_alpha_ = 0;
      }
    }
#line 429
    if (! dmux->is_ext_format_) {
#line 429
      if (frame->width_ > 0) {
#line 429
        if (frame->height_ > 0) {
#line 430
          dmux->state_ = (WebPDemuxState )1;
#line 431
          dmux->canvas_width_ = frame->width_;
#line 432
          dmux->canvas_height_ = frame->height_;
#line 433
          if (frame->has_alpha_) {
#line 433
            tmp___2 = 16;
          } else {
#line 433
            tmp___2 = 0;
          }
#line 433
          dmux->feature_flags_ |= (unsigned int )tmp___2;
        }
      }
    }
    {
#line 435
    __cil_tmp13 = AddFrame(dmux, frame);
    }
#line 435
    if (! __cil_tmp13) {
#line 436
      status = (ParseStatus )2;
    } else {
#line 438
      image_added = 1;
#line 439
      dmux->num_frames_ = 1;
    }
  }
#line 443
  if (! image_added) {
    {
#line 443
    WebPSafeFree((void *)frame);
    }
  }
#line 444
  return (status);
}
}
#line 447 "/root/patron-new/new_3/src/demux/demux.c"
static ParseStatus ParseVP8XChunks(WebPDemuxer *dmux ) 
{ 
  int is_animation ;
  MemBuffer___0 *mem ;
  int anim_chunks ;
  ParseStatus status ;
  int store_chunk ;
  size_t chunk_start_offset ;
  uint32_t fourcc ;
  uint32_t __cil_tmp9 ;
  uint32_t chunk_size ;
  uint32_t __cil_tmp11 ;
  uint32_t chunk_size_padded ;
  int __cil_tmp13 ;
  size_t __cil_tmp15 ;
  size_t __cil_tmp19 ;
  int __cil_tmp20 ;
  size_t __cil_tmp21 ;

  {
#line 448
  is_animation = ! (! (dmux->feature_flags_ & 2U));
#line 449
  mem = & dmux->mem_;
#line 450
  anim_chunks = 0;
#line 451
  status = (ParseStatus )0;
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 454
    store_chunk = 1;
#line 455
    chunk_start_offset = mem->start_;
#line 456
    __cil_tmp9 = ReadLE32(mem);
#line 456
    fourcc = __cil_tmp9;
#line 457
    __cil_tmp11 = ReadLE32(mem);
#line 457
    chunk_size = __cil_tmp11;
    }
#line 460
    if (chunk_size > 4294967286U) {
#line 460
      return ((ParseStatus )2);
    }
    {
#line 462
    chunk_size_padded = chunk_size + (chunk_size & 1U);
#line 463
    __cil_tmp13 = SizeIsInvalid(mem, (size_t )chunk_size_padded);
    }
#line 463
    if (__cil_tmp13) {
#line 463
      return ((ParseStatus )2);
    }
#line 466
    if (fourcc == ((unsigned int )((86 | (80 << 8)) | (56 << 16)) | (88U << 24))) {
#line 466
      goto case_exp;
    }
#line 471
    if (fourcc == ((unsigned int )((86 | (80 << 8)) | (56 << 16)) | (76U << 24))) {
#line 471
      goto case_exp___0;
    }
#line 471
    if (fourcc == ((unsigned int )((86 | (80 << 8)) | (56 << 16)) | (32U << 24))) {
#line 471
      goto case_exp___0;
    }
#line 471
    if (fourcc == ((unsigned int )((65 | (76 << 8)) | (80 << 16)) | (72U << 24))) {
#line 471
      goto case_exp___0;
    }
#line 479
    if (fourcc == ((unsigned int )((65 | (78 << 8)) | (73 << 16)) | (77U << 24))) {
#line 479
      goto case_exp___3;
    }
#line 495
    if (fourcc == ((unsigned int )((65 | (78 << 8)) | (77 << 16)) | (70U << 24))) {
#line 495
      goto case_exp___4;
    }
#line 500
    if (fourcc == ((unsigned int )((73 | (67 << 8)) | (67 << 16)) | (80U << 24))) {
#line 500
      goto case_exp___5;
    }
#line 504
    if (fourcc == ((unsigned int )((69 | (88 << 8)) | (73 << 16)) | (70U << 24))) {
#line 504
      goto case_exp___6;
    }
#line 508
    if (fourcc == ((unsigned int )((88 | (77 << 8)) | (80 << 16)) | (32U << 24))) {
#line 508
      goto case_exp___7;
    }
#line 513
    goto switch_default;
    case_exp: 
#line 467
    return ((ParseStatus )2);
    case_exp___0: 
#line 473
    if (anim_chunks > 0) {
#line 473
      return ((ParseStatus )2);
    } else
#line 473
    if (is_animation) {
#line 473
      return ((ParseStatus )2);
    }
    {
#line 475
    Rewind(mem, (size_t )8);
#line 476
    status = ParseSingleImage(dmux);
    }
#line 477
    goto switch_break;
    case_exp___3: 
#line 480
    if (chunk_size_padded < 6U) {
#line 480
      return ((ParseStatus )2);
    }
    {
#line 482
    __cil_tmp15 = MemDataSize___2(mem);
    }
#line 482
    if (__cil_tmp15 < (unsigned long )chunk_size_padded) {
#line 483
      status = (ParseStatus )1;
    } else
#line 484
    if (anim_chunks == 0) {
      {
#line 485
      anim_chunks ++;
#line 486
      dmux->bgcolor_ = ReadLE32(mem);
#line 487
      dmux->loop_count_ = ReadLE16s(mem);
#line 488
      Skip(mem, (size_t )(chunk_size_padded - 6U));
      }
    } else {
#line 490
      store_chunk = 0;
#line 491
      goto switch_default;
    }
#line 493
    goto switch_break;
    case_exp___4: 
#line 496
    if (anim_chunks == 0) {
#line 496
      return ((ParseStatus )2);
    }
    {
#line 497
    status = ParseAnimationFrame(dmux, chunk_size_padded);
    }
#line 498
    goto switch_break;
    case_exp___5: 
#line 501
    store_chunk = ! (! (dmux->feature_flags_ & 32U));
#line 502
    goto switch_default;
    case_exp___6: 
#line 505
    store_chunk = ! (! (dmux->feature_flags_ & 8U));
#line 506
    goto switch_default;
    case_exp___7: 
#line 509
    store_chunk = ! (! (dmux->feature_flags_ & 4U));
#line 510
    goto switch_default;
    switch_default: 
    {
#line 514
    __cil_tmp19 = MemDataSize___2(mem);
    }
#line 514
    if ((unsigned long )chunk_size_padded <= __cil_tmp19) {
#line 515
      if (store_chunk) {
        {
#line 518
        __cil_tmp20 = StoreChunk(dmux, chunk_start_offset, 8U + chunk_size);
        }
#line 518
        if (! __cil_tmp20) {
#line 520
          return ((ParseStatus )2);
        }
      }
      {
#line 523
      Skip(mem, (size_t )chunk_size_padded);
      }
    } else {
#line 525
      status = (ParseStatus )1;
    }
    switch_break: ;
#line 530
    if (mem->start_ == mem->riff_end_) {
#line 531
      goto while_break;
    } else {
      {
#line 532
      __cil_tmp21 = MemDataSize___2(mem);
      }
#line 532
      if (__cil_tmp21 < 8UL) {
#line 533
        status = (ParseStatus )1;
      }
    }
#line 453
    if (! ((unsigned int )status == 0U)) {
#line 453
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 537
  return (status);
}
}
#line 540 "/root/patron-new/new_3/src/demux/demux.c"
static ParseStatus ParseVP8X___2(WebPDemuxer *dmux ) 
{ 
  MemBuffer___0 *mem ;
  uint32_t vp8x_size ;
  size_t __cil_tmp4 ;
  int __cil_tmp6 ;
  size_t __cil_tmp7 ;
  uint8_t __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  size_t __cil_tmp12 ;
  ParseStatus __cil_tmp13 ;

  {
  {
#line 541
  mem = & dmux->mem_;
#line 544
  __cil_tmp4 = MemDataSize___2(mem);
  }
#line 544
  if (__cil_tmp4 < 8UL) {
#line 544
    return ((ParseStatus )1);
  }
  {
#line 546
  dmux->is_ext_format_ = 1;
#line 547
  Skip(mem, (size_t )4);
#line 548
  vp8x_size = ReadLE32(mem);
  }
#line 549
  if (vp8x_size > 4294967286U) {
#line 549
    return ((ParseStatus )2);
  }
#line 550
  if (vp8x_size < 10U) {
#line 550
    return ((ParseStatus )2);
  }
  {
#line 551
  vp8x_size += vp8x_size & 1U;
#line 552
  __cil_tmp6 = SizeIsInvalid(mem, (size_t )vp8x_size);
  }
#line 552
  if (__cil_tmp6) {
#line 552
    return ((ParseStatus )2);
  }
  {
#line 553
  __cil_tmp7 = MemDataSize___2(mem);
  }
#line 553
  if (__cil_tmp7 < (unsigned long )vp8x_size) {
#line 553
    return ((ParseStatus )1);
  }
  {
#line 555
  __cil_tmp8 = ReadByte(mem);
#line 555
  dmux->feature_flags_ = (uint32_t )__cil_tmp8;
#line 556
  Skip(mem, (size_t )3);
#line 557
  __cil_tmp9 = ReadLE24s(mem);
#line 557
  dmux->canvas_width_ = 1 + __cil_tmp9;
#line 558
  __cil_tmp10 = ReadLE24s(mem);
#line 558
  dmux->canvas_height_ = 1 + __cil_tmp10;
  }
#line 559
  if ((unsigned long long )((unsigned long )dmux->canvas_width_ * (uint64_t )dmux->canvas_height_) >= 1ULL << 32) {
#line 560
    return ((ParseStatus )2);
  }
  {
#line 562
  Skip(mem, (size_t )(vp8x_size - 10U));
#line 563
  dmux->state_ = (WebPDemuxState )1;
#line 565
  __cil_tmp11 = SizeIsInvalid(mem, (size_t )8);
  }
#line 565
  if (__cil_tmp11) {
#line 565
    return ((ParseStatus )2);
  }
  {
#line 566
  __cil_tmp12 = MemDataSize___2(mem);
  }
#line 566
  if (__cil_tmp12 < 8UL) {
#line 566
    return ((ParseStatus )1);
  }
  {
#line 568
  __cil_tmp13 = ParseVP8XChunks(dmux);
  }
#line 568
  return (__cil_tmp13);
}
}
#line 574 "/root/patron-new/new_3/src/demux/demux.c"
static int IsValidSimpleFormat(WebPDemuxer *dmux ) 
{ 
  Frame *frame ;

  {
#line 575
  frame = dmux->frames_;
#line 576
  if ((int )dmux->state_ == 0) {
#line 576
    return (1);
  }
#line 578
  if (dmux->canvas_width_ <= 0) {
#line 578
    return (0);
  } else
#line 578
  if (dmux->canvas_height_ <= 0) {
#line 578
    return (0);
  }
#line 579
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
#line 579
    if ((int )dmux->state_ == 2) {
#line 579
      return (0);
    }
  }
#line 581
  if (frame->width_ <= 0) {
#line 581
    return (0);
  } else
#line 581
  if (frame->height_ <= 0) {
#line 581
    return (0);
  }
#line 582
  return (1);
}
}
#line 587 "/root/patron-new/new_3/src/demux/demux.c"
static int CheckFrameBounds(Frame *frame , int exact , int canvas_width , int canvas_height ) 
{ 


  {
#line 589
  if (exact) {
#line 590
    if (frame->x_offset_ != 0) {
#line 591
      return (0);
    } else
#line 590
    if (frame->y_offset_ != 0) {
#line 591
      return (0);
    }
#line 593
    if (frame->width_ != canvas_width) {
#line 594
      return (0);
    } else
#line 593
    if (frame->height_ != canvas_height) {
#line 594
      return (0);
    }
  } else {
#line 597
    if (frame->x_offset_ < 0) {
#line 597
      return (0);
    } else
#line 597
    if (frame->y_offset_ < 0) {
#line 597
      return (0);
    }
#line 598
    if (frame->width_ + frame->x_offset_ > canvas_width) {
#line 598
      return (0);
    }
#line 599
    if (frame->height_ + frame->y_offset_ > canvas_height) {
#line 599
      return (0);
    }
  }
#line 601
  return (1);
}
}
#line 604 "/root/patron-new/new_3/src/demux/demux.c"
static int IsValidExtendedFormat(WebPDemuxer *dmux ) 
{ 
  int is_animation ;
  Frame *f ;
  int cur_frame_set ;
  int frame_count ;
  ChunkData *image ;
  ChunkData *alpha ;
  int __cil_tmp8 ;

  {
#line 605
  is_animation = ! (! (dmux->feature_flags_ & 2U));
#line 606
  f = dmux->frames_;
#line 608
  if ((int )dmux->state_ == 0) {
#line 608
    return (1);
  }
#line 610
  if (dmux->canvas_width_ <= 0) {
#line 610
    return (0);
  } else
#line 610
  if (dmux->canvas_height_ <= 0) {
#line 610
    return (0);
  }
#line 611
  if (dmux->loop_count_ < 0) {
#line 611
    return (0);
  }
#line 612
  if ((unsigned long )dmux->frames_ == (unsigned long )((void *)0)) {
#line 612
    if ((int )dmux->state_ == 2) {
#line 612
      return (0);
    }
  }
#line 613
  if (dmux->feature_flags_ & 4294967233U) {
#line 613
    return (0);
  }
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;

#line 615
    if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 615
      goto while_break;
    }
#line 616
    cur_frame_set = f->frame_num_;
#line 617
    frame_count = 0;
    {
#line 620
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 620
      if ((unsigned long )f != (unsigned long )((void *)0)) {
#line 620
        if (! (f->frame_num_ == cur_frame_set)) {
#line 620
          goto while_break___0;
        }
      } else {
#line 620
        goto while_break___0;
      }
#line 621
      image = f->img_components_;
#line 622
      alpha = f->img_components_ + 1;
#line 624
      if (! is_animation) {
#line 624
        if (f->frame_num_ > 1) {
#line 624
          return (0);
        }
      }
#line 626
      if (f->complete_) {
#line 627
        if (alpha->size_ == 0UL) {
#line 627
          if (image->size_ == 0UL) {
#line 627
            return (0);
          }
        }
#line 629
        if (alpha->size_ > 0UL) {
#line 629
          if (alpha->offset_ > image->offset_) {
#line 630
            return (0);
          }
        }
#line 633
        if (f->width_ <= 0) {
#line 633
          return (0);
        } else
#line 633
        if (f->height_ <= 0) {
#line 633
          return (0);
        }
      } else {
#line 636
        if ((int )dmux->state_ == 2) {
#line 636
          return (0);
        }
#line 639
        if (alpha->size_ > 0UL) {
#line 639
          if (image->size_ > 0UL) {
#line 639
            if (alpha->offset_ > image->offset_) {
#line 641
              return (0);
            }
          }
        }
#line 644
        if ((unsigned long )f->next_ != (unsigned long )((void *)0)) {
#line 644
          return (0);
        }
      }
      {
#line 647
      __cil_tmp8 = CheckFrameBounds(f, ! is_animation, dmux->canvas_width_, dmux->canvas_height_);
      }
#line 647
      if (f->width_ > 0) {
#line 647
        if (f->height_ > 0) {
#line 647
          if (! __cil_tmp8) {
#line 650
            return (0);
          }
        }
      }
#line 653
      frame_count ++;
#line 620
      f = f->next_;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 656
  return (1);
}
}
#line 662 "/root/patron-new/new_3/src/demux/demux.c"
static void InitDemux(WebPDemuxer *dmux , MemBuffer___0 *mem ) 
{ 


  {
#line 663
  dmux->state_ = (WebPDemuxState )0;
#line 664
  dmux->loop_count_ = 1;
#line 665
  dmux->bgcolor_ = 4294967295U;
#line 666
  dmux->canvas_width_ = -1;
#line 667
  dmux->canvas_height_ = -1;
#line 668
  dmux->frames_tail_ = & dmux->frames_;
#line 669
  dmux->chunks_tail_ = & dmux->chunks_;
#line 670
  dmux->mem_ = *mem;
#line 671
  return;
}
}
#line 673 "/root/patron-new/new_3/src/demux/demux.c"
static ParseStatus CreateRawImageDemuxer(MemBuffer___0 *mem , WebPDemuxer **demuxer ) 
{ 
  WebPBitstreamFeatures features ;
  VP8StatusCode status ;
  VP8StatusCode __cil_tmp5 ;
  int tmp___2 ;
  WebPDemuxer *dmux ;
  void *__cil_tmp8 ;
  Frame *frame ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;
  int tmp___3 ;

  {
  {
#line 676
  __cil_tmp5 = WebPGetFeatures(mem->buf_, mem->buf_size_, & features);
#line 676
  status = __cil_tmp5;
#line 678
  *demuxer = (WebPDemuxer *)((void *)0);
  }
#line 679
  if ((unsigned int )status != 0U) {
#line 680
    if ((unsigned int )status == 7U) {
#line 680
      tmp___2 = 1;
    } else {
#line 680
      tmp___2 = 2;
    }
#line 680
    return ((ParseStatus )tmp___2);
  }
  {
#line 685
  __cil_tmp8 = WebPSafeCalloc((uint64_t )1ULL, sizeof(*dmux));
#line 685
  dmux = (WebPDemuxer *)__cil_tmp8;
#line 686
  __cil_tmp10 = WebPSafeCalloc((uint64_t )1ULL, sizeof(*frame));
#line 686
  frame = (Frame *)__cil_tmp10;
  }
#line 687
  if ((unsigned long )dmux == (unsigned long )((void *)0)) {
#line 687
    goto Error;
  } else
#line 687
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
#line 687
    goto Error;
  }
  {
#line 688
  InitDemux(dmux, mem);
#line 689
  SetFrameInfo((size_t )0, mem->buf_size_, 1, 1, & features, frame);
#line 691
  __cil_tmp11 = AddFrame(dmux, frame);
  }
#line 691
  if (! __cil_tmp11) {
#line 691
    goto Error;
  }
#line 692
  dmux->state_ = (WebPDemuxState )2;
#line 693
  dmux->canvas_width_ = frame->width_;
#line 694
  dmux->canvas_height_ = frame->height_;
#line 695
  if (frame->has_alpha_) {
#line 695
    tmp___3 = 16;
  } else {
#line 695
    tmp___3 = 0;
  }
#line 695
  dmux->feature_flags_ |= (unsigned int )tmp___3;
#line 696
  dmux->num_frames_ = 1;
#line 698
  *demuxer = dmux;
#line 699
  return ((ParseStatus )0);
  Error: 
  {
#line 702
  WebPSafeFree((void *)dmux);
#line 703
  WebPSafeFree((void *)frame);
  }
#line 704
  return ((ParseStatus )2);
}
}
#line 708 "/root/patron-new/new_3/src/demux/demux.c"
WebPDemuxer *WebPDemuxInternal(WebPData *data , int allow_partial , WebPDemuxState *state ,
                               int version ) 
{ 
  ChunkParser *parser ;
  int partial ;
  ParseStatus status ;
  MemBuffer___0 mem ;
  WebPDemuxer *dmux ;
  int __cil_tmp10 ;
  int tmp___2 ;
  void *__cil_tmp14 ;
  uint8_t *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp18 ;

  {
#line 712
  status = (ParseStatus )2;
#line 716
  if ((unsigned long )state != (unsigned long )((void *)0)) {
#line 716
    *state = (WebPDemuxState )-1;
  }
#line 718
  if (version >> 8 != 263 >> 8) {
#line 718
    return ((WebPDemuxer *)((void *)0));
  }
#line 719
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 719
    return ((WebPDemuxer *)((void *)0));
  } else
#line 719
  if ((unsigned long )data->bytes == (unsigned long )((void *)0)) {
#line 719
    return ((WebPDemuxer *)((void *)0));
  } else
#line 719
  if (data->size == 0UL) {
#line 719
    return ((WebPDemuxer *)((void *)0));
  }
  {
#line 721
  __cil_tmp10 = InitMemBuffer___2(& mem, data->bytes, data->size);
  }
#line 721
  if (! __cil_tmp10) {
#line 721
    return ((WebPDemuxer *)((void *)0));
  }
  {
#line 722
  status = ReadHeader(& mem);
  }
#line 723
  if ((unsigned int )status != 0U) {
#line 726
    if ((unsigned int )status == 2U) {
      {
#line 727
      status = CreateRawImageDemuxer(& mem, & dmux);
      }
#line 728
      if ((unsigned int )status == 0U) {
#line 729
        if ((unsigned long )state != (unsigned long )((void *)0)) {
#line 729
          *state = (WebPDemuxState )2;
        }
#line 730
        return (dmux);
      }
    }
#line 733
    if ((unsigned long )state != (unsigned long )((void *)0)) {
#line 734
      if ((unsigned int )status == 1U) {
#line 734
        tmp___2 = 0;
      } else {
#line 734
        tmp___2 = -1;
      }
#line 734
      *state = (WebPDemuxState )tmp___2;
    }
#line 737
    return ((WebPDemuxer *)((void *)0));
  }
#line 740
  partial = mem.buf_size_ < mem.riff_end_;
#line 741
  if (! allow_partial) {
#line 741
    if (partial) {
#line 741
      return ((WebPDemuxer *)((void *)0));
    }
  }
  {
#line 743
  __cil_tmp14 = WebPSafeCalloc((uint64_t )1ULL, sizeof(*dmux));
#line 743
  dmux = (WebPDemuxer *)__cil_tmp14;
  }
#line 744
  if ((unsigned long )dmux == (unsigned long )((void *)0)) {
#line 744
    return ((WebPDemuxer *)((void *)0));
  }
  {
#line 745
  InitDemux(dmux, & mem);
#line 747
  status = (ParseStatus )2;
#line 748
  parser = kMasterChunks;
  }
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;

#line 748
    if (! ((unsigned long )parser->parse != (unsigned long )((void *)0))) {
#line 748
      goto while_break;
    }
    {
#line 749
    __cil_tmp15 = GetBuffer(& dmux->mem_);
#line 749
    __cil_tmp16 = memcmp((void const   *)(parser->id), (void const   *)__cil_tmp15,
                         4UL);
    }
#line 749
    if (! __cil_tmp16) {
      {
#line 750
      status = (*(parser->parse))((WebPDemuxer */* const  */)dmux);
      }
#line 751
      if ((unsigned int )status == 0U) {
#line 751
        dmux->state_ = (WebPDemuxState )2;
      }
#line 752
      if ((unsigned int )status == 1U) {
#line 752
        if (! partial) {
#line 752
          status = (ParseStatus )2;
        }
      }
      {
#line 753
      __cil_tmp18 = (*(parser->valid))((WebPDemuxer */* const  */)dmux);
      }
#line 753
      if ((unsigned int )status != 2U) {
#line 753
        if (! __cil_tmp18) {
#line 753
          status = (ParseStatus )2;
        }
      }
#line 754
      if ((unsigned int )status == 2U) {
#line 754
        dmux->state_ = (WebPDemuxState )-1;
      }
#line 755
      goto while_break;
    }
#line 748
    parser ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 758
  if ((unsigned long )state != (unsigned long )((void *)0)) {
#line 758
    *state = dmux->state_;
  }
#line 760
  if ((unsigned int )status == 2U) {
    {
#line 761
    WebPDemuxDelete(dmux);
    }
#line 762
    return ((WebPDemuxer *)((void *)0));
  }
#line 764
  return (dmux);
}
}
#line 767 "/root/patron-new/new_3/src/demux/demux.c"
void WebPDemuxDelete(WebPDemuxer *dmux ) 
{ 
  Chunk *c ;
  Frame *f ;
  Frame *cur_frame ;
  Chunk *cur_chunk ;

  {
#line 770
  if ((unsigned long )dmux == (unsigned long )((void *)0)) {
#line 770
    return;
  }
#line 772
  f = dmux->frames_;
  {
#line 772
  while (1) {
    while_continue: /* CIL Label */ ;

#line 772
    if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 772
      goto while_break;
    }
    {
#line 773
    cur_frame = f;
#line 774
    f = f->next_;
#line 775
    WebPSafeFree((void *)cur_frame);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 777
  c = dmux->chunks_;
  {
#line 777
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 777
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 777
      goto while_break___0;
    }
    {
#line 778
    cur_chunk = c;
#line 779
    c = c->next_;
#line 780
    WebPSafeFree((void *)cur_chunk);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 782
  WebPSafeFree((void *)dmux);
  }
#line 784
  return;
}
}
#line 787 "/root/patron-new/new_3/src/demux/demux.c"
uint32_t WebPDemuxGetI(WebPDemuxer *dmux , WebPFormatFeature feature ) 
{ 


  {
#line 788
  if ((unsigned long )dmux == (unsigned long )((void *)0)) {
#line 788
    return ((uint32_t )0);
  }
#line 791
  if ((unsigned int )feature == 0U) {
#line 791
    goto case_0;
  }
#line 792
  if ((unsigned int )feature == 1U) {
#line 792
    goto case_1;
  }
#line 793
  if ((unsigned int )feature == 2U) {
#line 793
    goto case_2;
  }
#line 794
  if ((unsigned int )feature == 3U) {
#line 794
    goto case_3;
  }
#line 795
  if ((unsigned int )feature == 4U) {
#line 795
    goto case_4;
  }
#line 796
  if ((unsigned int )feature == 5U) {
#line 796
    goto case_5;
  }
#line 790
  goto switch_break;
  case_0: 
#line 791
  return (dmux->feature_flags_);
  case_1: 
#line 792
  return ((uint32_t )dmux->canvas_width_);
  case_2: 
#line 793
  return ((uint32_t )dmux->canvas_height_);
  case_3: 
#line 794
  return ((uint32_t )dmux->loop_count_);
  case_4: 
#line 795
  return (dmux->bgcolor_);
  case_5: 
#line 796
  return ((uint32_t )dmux->num_frames_);
  switch_break: ;
#line 798
  return ((uint32_t )0);
}
}
#line 804 "/root/patron-new/new_3/src/demux/demux.c"
static Frame *GetFrame(WebPDemuxer *dmux , int frame_num ) 
{ 
  Frame *f ;

  {
#line 806
  f = dmux->frames_;
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;

#line 806
    if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 806
      goto while_break;
    }
#line 807
    if (frame_num == f->frame_num_) {
#line 807
      goto while_break;
    }
#line 806
    f = f->next_;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 809
  return (f);
}
}
#line 812 "/root/patron-new/new_3/src/demux/demux.c"
static uint8_t *GetFramePayload(uint8_t *mem_buf , Frame *frame , size_t *data_size ) 
{ 
  ChunkData *image ;
  ChunkData *alpha ;
  size_t start_offset ;
  size_t inter_size ;
  size_t tmp___2 ;

  {
#line 815
  *data_size = (size_t )0;
#line 816
  if ((unsigned long )frame != (unsigned long )((void *)0)) {
#line 817
    image = frame->img_components_;
#line 818
    alpha = frame->img_components_ + 1;
#line 819
    start_offset = image->offset_;
#line 820
    *data_size = image->size_;
#line 824
    if (alpha->size_ > 0UL) {
#line 825
      if (image->offset_ > 0UL) {
#line 825
        tmp___2 = image->offset_ - (alpha->offset_ + alpha->size_);
      } else {
#line 825
        tmp___2 = 0UL;
      }
#line 825
      inter_size = tmp___2;
#line 828
      start_offset = alpha->offset_;
#line 829
      *data_size += alpha->size_ + inter_size;
    }
#line 831
    return (mem_buf + start_offset);
  }
#line 833
  return ((uint8_t *)((void *)0));
}
}
#line 837 "/root/patron-new/new_3/src/demux/demux.c"
static int SynthesizeFrame(WebPDemuxer *dmux , Frame *frame , WebPIterator *iter ) 
{ 
  uint8_t *mem_buf ;
  size_t payload_size ;
  uint8_t *payload ;
  uint8_t *__cil_tmp7 ;

  {
  {
#line 840
  mem_buf = dmux->mem_.buf_;
#line 841
  payload_size = (size_t )0;
#line 842
  __cil_tmp7 = GetFramePayload(mem_buf, frame, & payload_size);
#line 842
  payload = __cil_tmp7;
  }
#line 843
  if ((unsigned long )payload == (unsigned long )((void *)0)) {
#line 843
    return (0);
  }
#line 846
  iter->frame_num = frame->frame_num_;
#line 847
  iter->num_frames = dmux->num_frames_;
#line 848
  iter->x_offset = frame->x_offset_;
#line 849
  iter->y_offset = frame->y_offset_;
#line 850
  iter->width = frame->width_;
#line 851
  iter->height = frame->height_;
#line 852
  iter->has_alpha = frame->has_alpha_;
#line 853
  iter->duration = frame->duration_;
#line 854
  iter->dispose_method = frame->dispose_method_;
#line 855
  iter->blend_method = frame->blend_method_;
#line 856
  iter->complete = frame->complete_;
#line 857
  iter->fragment.bytes = payload;
#line 858
  iter->fragment.size = payload_size;
#line 859
  return (1);
}
}
#line 862 "/root/patron-new/new_3/src/demux/demux.c"
static int SetFrame(int frame_num , WebPIterator *iter ) 
{ 
  Frame *frame ;
  WebPDemuxer *dmux ;
  int __cil_tmp6 ;

  {
#line 864
  dmux = (WebPDemuxer *)iter->private_;
#line 865
  if ((unsigned long )dmux == (unsigned long )((void *)0)) {
#line 865
    return (0);
  } else
#line 865
  if (frame_num < 0) {
#line 865
    return (0);
  }
#line 866
  if (frame_num > dmux->num_frames_) {
#line 866
    return (0);
  }
#line 867
  if (frame_num == 0) {
#line 867
    frame_num = dmux->num_frames_;
  }
  {
#line 869
  frame = GetFrame(dmux, frame_num);
  }
#line 870
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
#line 870
    return (0);
  }
  {
#line 872
  __cil_tmp6 = SynthesizeFrame(dmux, frame, iter);
  }
#line 872
  return (__cil_tmp6);
}
}
#line 875 "/root/patron-new/new_3/src/demux/demux.c"
int WebPDemuxGetFrame(WebPDemuxer *dmux , int frame , WebPIterator *iter ) 
{ 
  int __cil_tmp4 ;

  {
#line 876
  if ((unsigned long )iter == (unsigned long )((void *)0)) {
#line 876
    return (0);
  }
  {
#line 878
  memset((void *)iter, 0, sizeof(*iter));
#line 879
  iter->private_ = (void *)dmux;
#line 880
  __cil_tmp4 = SetFrame(frame, iter);
  }
#line 880
  return (__cil_tmp4);
}
}
#line 883 "/root/patron-new/new_3/src/demux/demux.c"
int WebPDemuxNextFrame(WebPIterator *iter ) 
{ 
  int __cil_tmp2 ;

  {
#line 884
  if ((unsigned long )iter == (unsigned long )((void *)0)) {
#line 884
    return (0);
  }
  {
#line 885
  __cil_tmp2 = SetFrame(iter->frame_num + 1, iter);
  }
#line 885
  return (__cil_tmp2);
}
}
#line 888 "/root/patron-new/new_3/src/demux/demux.c"
int WebPDemuxPrevFrame(WebPIterator *iter ) 
{ 
  int __cil_tmp2 ;

  {
#line 889
  if ((unsigned long )iter == (unsigned long )((void *)0)) {
#line 889
    return (0);
  }
#line 890
  if (iter->frame_num <= 1) {
#line 890
    return (0);
  }
  {
#line 891
  __cil_tmp2 = SetFrame(iter->frame_num - 1, iter);
  }
#line 891
  return (__cil_tmp2);
}
}
#line 894 "/root/patron-new/new_3/src/demux/demux.c"
void WebPDemuxReleaseIterator(WebPIterator *iter ) 
{ 


  {
#line 899
  return;
}
}
#line 901 "/root/patron-new/new_3/src/demux/demux.c"
static int ChunkCount(WebPDemuxer *dmux , char const   *fourcc ) 
{ 
  uint8_t *mem_buf ;
  Chunk *c ;
  int count ;
  uint8_t *header ;
  int __cil_tmp7 ;

  {
#line 902
  mem_buf = dmux->mem_.buf_;
#line 904
  count = 0;
#line 905
  c = dmux->chunks_;
  {
#line 905
  while (1) {
    while_continue: /* CIL Label */ ;

#line 905
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 905
      goto while_break;
    }
    {
#line 906
    header = mem_buf + c->data_.offset_;
#line 907
    __cil_tmp7 = memcmp((void const   *)header, (void const   *)fourcc, 4UL);
    }
#line 907
    if (! __cil_tmp7) {
#line 907
      count ++;
    }
#line 905
    c = c->next_;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 909
  return (count);
}
}
#line 912 "/root/patron-new/new_3/src/demux/demux.c"
static Chunk *GetChunk(WebPDemuxer *dmux , char const   *fourcc , int chunk_num ) 
{ 
  uint8_t *mem_buf ;
  Chunk *c ;
  int count ;
  uint8_t *header ;
  int __cil_tmp8 ;

  {
#line 914
  mem_buf = dmux->mem_.buf_;
#line 916
  count = 0;
#line 917
  c = dmux->chunks_;
  {
#line 917
  while (1) {
    while_continue: /* CIL Label */ ;

#line 917
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 917
      goto while_break;
    }
    {
#line 918
    header = mem_buf + c->data_.offset_;
#line 919
    __cil_tmp8 = memcmp((void const   *)header, (void const   *)fourcc, 4UL);
    }
#line 919
    if (! __cil_tmp8) {
#line 919
      count ++;
    }
#line 920
    if (count == chunk_num) {
#line 920
      goto while_break;
    }
#line 917
    c = c->next_;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 922
  return (c);
}
}
#line 925 "/root/patron-new/new_3/src/demux/demux.c"
static int SetChunk(char const   *fourcc , int chunk_num , WebPChunkIterator *iter ) 
{ 
  WebPDemuxer *dmux ;
  int count ;
  uint8_t *mem_buf ;
  Chunk *chunk ;
  Chunk *__cil_tmp9 ;

  {
#line 927
  dmux = (WebPDemuxer *)iter->private_;
#line 930
  if ((unsigned long )dmux == (unsigned long )((void *)0)) {
#line 930
    return (0);
  } else
#line 930
  if ((unsigned long )fourcc == (unsigned long )((void *)0)) {
#line 930
    return (0);
  } else
#line 930
  if (chunk_num < 0) {
#line 930
    return (0);
  }
  {
#line 931
  count = ChunkCount(dmux, fourcc);
  }
#line 932
  if (count == 0) {
#line 932
    return (0);
  }
#line 933
  if (chunk_num == 0) {
#line 933
    chunk_num = count;
  }
#line 935
  if (chunk_num <= count) {
    {
#line 936
    mem_buf = dmux->mem_.buf_;
#line 937
    __cil_tmp9 = GetChunk(dmux, fourcc, chunk_num);
#line 937
    chunk = __cil_tmp9;
#line 938
    iter->chunk.bytes = (mem_buf + chunk->data_.offset_) + 8;
#line 939
    iter->chunk.size = chunk->data_.size_ - 8UL;
#line 940
    iter->num_chunks = count;
#line 941
    iter->chunk_num = chunk_num;
    }
#line 942
    return (1);
  }
#line 944
  return (0);
}
}
#line 947 "/root/patron-new/new_3/src/demux/demux.c"
int WebPDemuxGetChunk(WebPDemuxer *dmux , char const   *fourcc , int chunk_num , WebPChunkIterator *iter ) 
{ 
  int __cil_tmp5 ;

  {
#line 950
  if ((unsigned long )iter == (unsigned long )((void *)0)) {
#line 950
    return (0);
  }
  {
#line 952
  memset((void *)iter, 0, sizeof(*iter));
#line 953
  iter->private_ = (void *)dmux;
#line 954
  __cil_tmp5 = SetChunk(fourcc, chunk_num, iter);
  }
#line 954
  return (__cil_tmp5);
}
}
#line 957 "/root/patron-new/new_3/src/demux/demux.c"
int WebPDemuxNextChunk(WebPChunkIterator *iter ) 
{ 
  char const   *fourcc ;
  int __cil_tmp3 ;

  {
#line 958
  if ((unsigned long )iter != (unsigned long )((void *)0)) {
    {
#line 959
    fourcc = (char const   *)iter->chunk.bytes - 8;
#line 961
    __cil_tmp3 = SetChunk((char const   *)fourcc, iter->chunk_num + 1, iter);
    }
#line 961
    return (__cil_tmp3);
  }
#line 963
  return (0);
}
}
#line 966 "/root/patron-new/new_3/src/demux/demux.c"
int WebPDemuxPrevChunk(WebPChunkIterator *iter ) 
{ 
  char const   *fourcc ;
  int __cil_tmp3 ;

  {
#line 967
  if ((unsigned long )iter != (unsigned long )((void *)0)) {
#line 967
    if (iter->chunk_num > 1) {
      {
#line 968
      fourcc = (char const   *)iter->chunk.bytes - 8;
#line 970
      __cil_tmp3 = SetChunk((char const   *)fourcc, iter->chunk_num - 1, iter);
      }
#line 970
      return (__cil_tmp3);
    }
  }
#line 972
  return (0);
}
}
#line 975 "/root/patron-new/new_3/src/demux/demux.c"
void WebPDemuxReleaseChunkIterator(WebPChunkIterator *iter ) 
{ 


  {
#line 980
  return;
}
}
#line 27 "/root/patron-new/new_3/src/demux/anim_decode.c"
static void BlendPixelRowNonPremult(uint32_t *src , uint32_t *dst , int num_pixels ) ;
#line 29
static void BlendPixelRowPremult(uint32_t *src , uint32_t *dst , int num_pixels ) ;
#line 48 "/root/patron-new/new_3/src/demux/anim_decode.c"
static void DefaultDecoderOptions(WebPAnimDecoderOptions *dec_options ) 
{ 


  {
#line 49
  dec_options->color_mode = (WEBP_CSP_MODE )1;
#line 50
  dec_options->use_threads = 0;
#line 51
  return;
}
}
#line 53 "/root/patron-new/new_3/src/demux/anim_decode.c"
int WebPAnimDecoderOptionsInitInternal(WebPAnimDecoderOptions *dec_options , int abi_version ) 
{ 


  {
#line 55
  if ((unsigned long )dec_options == (unsigned long )((void *)0)) {
#line 57
    return (0);
  } else
#line 55
  if (abi_version >> 8 != 263 >> 8) {
#line 57
    return (0);
  }
  {
#line 59
  DefaultDecoderOptions(dec_options);
  }
#line 60
  return (1);
}
}
#line 63 "/root/patron-new/new_3/src/demux/anim_decode.c"
static int ApplyDecoderOptions(WebPAnimDecoderOptions *dec_options , WebPAnimDecoder *dec ) 
{ 
  WEBP_CSP_MODE mode ;
  WebPDecoderConfig *config ;
  void (*tmp___2)(uint32_t * const  src , uint32_t * const  dst , int num_pixels ) ;

  {
#line 66
  config = & dec->config_;
#line 69
  mode = dec_options->color_mode;
#line 70
  if ((unsigned int )mode != 1U) {
#line 70
    if ((unsigned int )mode != 3U) {
#line 70
      if ((unsigned int )mode != 7U) {
#line 70
        if ((unsigned int )mode != 8U) {
#line 72
          return (0);
        }
      }
    }
  }
#line 74
  if ((unsigned int )mode == 1U) {
#line 74
    tmp___2 = (void (*)(uint32_t * const  src , uint32_t * const  dst , int num_pixels ))(& BlendPixelRowNonPremult);
  } else
#line 74
  if ((unsigned int )mode == 3U) {
#line 74
    tmp___2 = (void (*)(uint32_t * const  src , uint32_t * const  dst , int num_pixels ))(& BlendPixelRowNonPremult);
  } else {
#line 74
    tmp___2 = (void (*)(uint32_t * const  src , uint32_t * const  dst , int num_pixels ))(& BlendPixelRowPremult);
  }
  {
#line 74
  dec->blend_func_ = tmp___2;
#line 77
  WebPInitDecoderConfig(config);
#line 78
  config->output.colorspace = mode;
#line 79
  config->output.is_external_memory = 1;
#line 80
  config->options.use_threads = dec_options->use_threads;
  }
#line 82
  return (1);
}
}
#line 85 "/root/patron-new/new_3/src/demux/anim_decode.c"
WebPAnimDecoder *WebPAnimDecoderNewInternal(WebPData *webp_data , WebPAnimDecoderOptions *dec_options ,
                                            int abi_version ) 
{ 
  WebPAnimDecoderOptions options ;
  WebPAnimDecoder *dec ;
  WebPBitstreamFeatures features ;
  VP8StatusCode __cil_tmp7 ;
  void *__cil_tmp8 ;
  int __cil_tmp9 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
#line 89
  dec = (WebPAnimDecoder *)((void *)0);
#line 91
  if ((unsigned long )webp_data == (unsigned long )((void *)0)) {
#line 93
    return ((WebPAnimDecoder *)((void *)0));
  } else
#line 91
  if (abi_version >> 8 != 263 >> 8) {
#line 93
    return ((WebPAnimDecoder *)((void *)0));
  }
  {
#line 98
  __cil_tmp7 = WebPGetFeatures(webp_data->bytes, webp_data->size, & features);
  }
#line 98
  if ((unsigned int )__cil_tmp7 != 0U) {
#line 100
    return ((WebPAnimDecoder *)((void *)0));
  }
  {
#line 104
  __cil_tmp8 = WebPSafeCalloc((uint64_t )1ULL, sizeof(*dec));
#line 104
  dec = (WebPAnimDecoder *)__cil_tmp8;
  }
#line 105
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 105
    goto Error;
  }
#line 107
  if ((unsigned long )dec_options != (unsigned long )((void *)0)) {
#line 108
    options = *dec_options;
  } else {
    {
#line 110
    DefaultDecoderOptions(& options);
    }
  }
  {
#line 112
  __cil_tmp9 = ApplyDecoderOptions(& options, dec);
  }
#line 112
  if (! __cil_tmp9) {
#line 112
    goto Error;
  }
  {
#line 114
  dec->demux_ = WebPDemux(webp_data);
  }
#line 115
  if ((unsigned long )dec->demux_ == (unsigned long )((void *)0)) {
#line 115
    goto Error;
  }
  {
#line 117
  dec->info_.canvas_width = WebPDemuxGetI(dec->demux_, (WebPFormatFeature )1);
#line 118
  dec->info_.canvas_height = WebPDemuxGetI(dec->demux_, (WebPFormatFeature )2);
#line 119
  dec->info_.loop_count = WebPDemuxGetI(dec->demux_, (WebPFormatFeature )3);
#line 120
  dec->info_.bgcolor = WebPDemuxGetI(dec->demux_, (WebPFormatFeature )4);
#line 121
  dec->info_.frame_count = WebPDemuxGetI(dec->demux_, (WebPFormatFeature )5);
#line 124
  __cil_tmp16 = WebPSafeCalloc((uint64_t )(dec->info_.canvas_width * 4U), (size_t )dec->info_.canvas_height);
#line 124
  dec->curr_frame_ = (uint8_t *)__cil_tmp16;
  }
#line 126
  if ((unsigned long )dec->curr_frame_ == (unsigned long )((void *)0)) {
#line 126
    goto Error;
  }
  {
#line 127
  __cil_tmp17 = WebPSafeCalloc((uint64_t )(dec->info_.canvas_width * 4U), (size_t )dec->info_.canvas_height);
#line 127
  dec->prev_frame_disposed_ = (uint8_t *)__cil_tmp17;
  }
#line 129
  if ((unsigned long )dec->prev_frame_disposed_ == (unsigned long )((void *)0)) {
#line 129
    goto Error;
  }
  {
#line 131
  WebPAnimDecoderReset(dec);
  }
#line 132
  return (dec);
  Error: 
  {
#line 135
  WebPAnimDecoderDelete(dec);
  }
#line 136
  return ((WebPAnimDecoder *)((void *)0));
}
}
#line 139 "/root/patron-new/new_3/src/demux/anim_decode.c"
int WebPAnimDecoderGetInfo(WebPAnimDecoder *dec , WebPAnimInfo *info ) 
{ 


  {
#line 140
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 140
    return (0);
  } else
#line 140
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 140
    return (0);
  }
#line 141
  *info = dec->info_;
#line 142
  return (1);
}
}
#line 146 "/root/patron-new/new_3/src/demux/anim_decode.c"
static int IsFullFrame(int width , int height , int canvas_width , int canvas_height ) 
{ 
  int tmp___2 ;

  {
#line 148
  if (width == canvas_width) {
#line 148
    if (height == canvas_height) {
#line 148
      tmp___2 = 1;
    } else {
#line 148
      tmp___2 = 0;
    }
  } else {
#line 148
    tmp___2 = 0;
  }
#line 148
  return (tmp___2);
}
}
#line 152 "/root/patron-new/new_3/src/demux/anim_decode.c"
static int ZeroFillCanvas(uint8_t *buf , uint32_t canvas_width , uint32_t canvas_height ) 
{ 
  uint64_t size ;

  {
#line 154
  size = (((uint64_t )canvas_width * (unsigned long )canvas_height) * 4UL) * sizeof(*buf);
#line 156
  if (size != size) {
#line 156
    return (0);
  }
  {
#line 157
  memset((void *)buf, 0, size);
  }
#line 158
  return (1);
}
}
#line 162 "/root/patron-new/new_3/src/demux/anim_decode.c"
static void ZeroFillFrameRect(uint8_t *buf , int buf_stride , int x_offset , int y_offset ,
                              int width , int height ) 
{ 
  int j ;

  {
#line 166
  buf += y_offset * buf_stride + x_offset * 4;
#line 167
  j = 0;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;

#line 167
    if (! (j < height)) {
#line 167
      goto while_break;
    }
    {
#line 168
    memset((void *)buf, 0, (unsigned long )(width * 4));
#line 169
    buf += buf_stride;
#line 167
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 171
  return;
}
}
#line 174 "/root/patron-new/new_3/src/demux/anim_decode.c"
static int CopyCanvas(uint8_t *src , uint8_t *dst , uint32_t width , uint32_t height ) 
{ 
  uint64_t size ;

  {
#line 176
  size = ((uint64_t )width * (unsigned long )height) * 4UL;
#line 177
  if (size != size) {
#line 177
    return (0);
  }
  {
#line 179
  memcpy((void *)dst, (void const   *)src, size);
  }
#line 180
  return (1);
}
}
#line 184 "/root/patron-new/new_3/src/demux/anim_decode.c"
static int IsKeyFrame(WebPIterator *curr , WebPIterator *prev , int prev_frame_was_key_frame ,
                      int canvas_width , int canvas_height ) 
{ 
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 188
  if (curr->frame_num == 1) {
#line 189
    return (1);
  } else {
    {
#line 190
    __cil_tmp6 = IsFullFrame(curr->width, curr->height, canvas_width, canvas_height);
    }
#line 190
    if (! curr->has_alpha) {
      _L: 
#line 190
      if (__cil_tmp6) {
#line 193
        return (1);
      } else {
        {
#line 195
        __cil_tmp7 = IsFullFrame(prev->width, prev->height, canvas_width, canvas_height);
        }
#line 195
        if ((unsigned int )prev->dispose_method == 1U) {
#line 195
          if (__cil_tmp7) {
#line 195
            tmp___2 = 1;
          } else
#line 195
          if (prev_frame_was_key_frame) {
#line 195
            tmp___2 = 1;
          } else {
#line 195
            tmp___2 = 0;
          }
        } else {
#line 195
          tmp___2 = 0;
        }
#line 195
        return (tmp___2);
      }
    } else
#line 190
    if ((unsigned int )curr->blend_method == 1U) {
#line 190
      goto _L;
    } else {
      {
#line 195
      __cil_tmp7 = IsFullFrame(prev->width, prev->height, canvas_width, canvas_height);
      }
#line 195
      if ((unsigned int )prev->dispose_method == 1U) {
#line 195
        if (__cil_tmp7) {
#line 195
          tmp___3 = 1;
        } else
#line 195
        if (prev_frame_was_key_frame) {
#line 195
          tmp___3 = 1;
        } else {
#line 195
          tmp___3 = 0;
        }
      } else {
#line 195
        tmp___3 = 0;
      }
#line 195
      return (tmp___3);
    }
  }
}
}
#line 205 "/root/patron-new/new_3/src/demux/anim_decode.c"
static uint8_t BlendChannelNonPremult(uint32_t src , uint8_t src_a , uint32_t dst ,
                                      uint8_t dst_a , uint32_t scale , int shift ) 
{ 
  uint8_t src_channel ;
  uint8_t dst_channel ;
  uint32_t blend_unscaled ;

  {
#line 208
  src_channel = (uint8_t )((src >> shift) & 255U);
#line 209
  dst_channel = (uint8_t )((dst >> shift) & 255U);
#line 210
  blend_unscaled = (uint32_t )((int )src_channel * (int )src_a + (int )dst_channel * (int )dst_a);
#line 212
  return ((uint8_t )(blend_unscaled * scale >> 24));
}
}
#line 216 "/root/patron-new/new_3/src/demux/anim_decode.c"
static uint32_t BlendPixelNonPremult(uint32_t src , uint32_t dst ) 
{ 
  uint8_t src_a ;
  uint8_t dst_a ;
  uint8_t dst_factor_a ;
  uint8_t blend_a ;
  uint32_t scale ;
  uint8_t blend_r ;
  uint8_t __cil_tmp9 ;
  uint8_t blend_g ;
  uint8_t __cil_tmp11 ;
  uint8_t blend_b ;
  uint8_t __cil_tmp13 ;

  {
#line 217
  src_a = (uint8_t )((src >> 24) & 255U);
#line 219
  if ((int )src_a == 0) {
#line 220
    return (dst);
  } else {
    {
#line 222
    dst_a = (uint8_t )((dst >> 24) & 255U);
#line 225
    dst_factor_a = (uint8_t )((int )dst_a * (256 - (int )src_a) >> 8);
#line 226
    blend_a = (uint8_t )((int )src_a + (int )dst_factor_a);
#line 227
    scale = (uint32_t )((1UL << 24) / (unsigned long )blend_a);
#line 229
    __cil_tmp9 = BlendChannelNonPremult(src, src_a, dst, dst_factor_a, scale, 0);
#line 229
    blend_r = __cil_tmp9;
#line 231
    __cil_tmp11 = BlendChannelNonPremult(src, src_a, dst, dst_factor_a, scale, 8);
#line 231
    blend_g = __cil_tmp11;
#line 233
    __cil_tmp13 = BlendChannelNonPremult(src, src_a, dst, dst_factor_a, scale, 16);
#line 233
    blend_b = __cil_tmp13;
    }
#line 237
    return ((unsigned int )(((int )blend_r | ((int )blend_g << 8)) | ((int )blend_b << 16)) | ((uint32_t )blend_a << 24));
  }
}
}
#line 246 "/root/patron-new/new_3/src/demux/anim_decode.c"
static void BlendPixelRowNonPremult(uint32_t *src , uint32_t *dst , int num_pixels ) 
{ 
  int i ;
  uint8_t src_alpha ;

  {
#line 249
  i = 0;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;

#line 249
    if (! (i < num_pixels)) {
#line 249
      goto while_break;
    }
#line 250
    src_alpha = (uint8_t )((*(src + i) >> 24) & 255U);
#line 251
    if ((int )src_alpha != 255) {
      {
#line 252
      *(src + i) = BlendPixelNonPremult(*(src + i), *(dst + i));
      }
    }
#line 249
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 253
  return;
}
}
#line 258 "/root/patron-new/new_3/src/demux/anim_decode.c"
__inline static uint32_t ChannelwiseMultiply(uint32_t pix , uint32_t scale ) 
{ 
  uint32_t mask ;
  uint32_t rb ;
  uint32_t ag ;

  {
#line 259
  mask = (uint32_t )16711935;
#line 260
  rb = (pix & mask) * scale >> 8;
#line 261
  ag = ((pix >> 8) & mask) * scale;
#line 262
  return ((rb & mask) | (ag & ~ mask));
}
}
#line 266 "/root/patron-new/new_3/src/demux/anim_decode.c"
static uint32_t BlendPixelPremult(uint32_t src , uint32_t dst ) 
{ 
  uint8_t src_a ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 267
  src_a = (uint8_t )((src >> 24) & 255U);
#line 268
  __cil_tmp4 = ChannelwiseMultiply(dst, (uint32_t )(256 - (int )src_a));
  }
#line 268
  return (src + __cil_tmp4);
}
}
#line 273 "/root/patron-new/new_3/src/demux/anim_decode.c"
static void BlendPixelRowPremult(uint32_t *src , uint32_t *dst , int num_pixels ) 
{ 
  int i ;
  uint8_t src_alpha ;

  {
#line 276
  i = 0;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;

#line 276
    if (! (i < num_pixels)) {
#line 276
      goto while_break;
    }
#line 277
    src_alpha = (uint8_t )((*(src + i) >> 24) & 255U);
#line 278
    if ((int )src_alpha != 255) {
      {
#line 279
      *(src + i) = BlendPixelPremult(*(src + i), *(dst + i));
      }
    }
#line 276
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 280
  return;
}
}
#line 286 "/root/patron-new/new_3/src/demux/anim_decode.c"
static void FindBlendRangeAtRow(WebPIterator *src , WebPIterator *dst , int canvas_y ,
                                int *left1 , int *width1 , int *left2 , int *width2 ) 
{ 
  int src_max_x ;
  int dst_max_x ;
  int dst_max_y ;

  {
#line 290
  src_max_x = src->x_offset + src->width;
#line 291
  dst_max_x = dst->x_offset + dst->width;
#line 292
  dst_max_y = dst->y_offset + dst->height;
#line 294
  *left1 = -1;
#line 295
  *width1 = 0;
#line 296
  *left2 = -1;
#line 297
  *width2 = 0;
#line 299
  if (canvas_y < dst->y_offset) {
#line 301
    *left1 = src->x_offset;
#line 302
    *width1 = src->width;
#line 303
    return;
  } else
#line 299
  if (canvas_y >= dst_max_y) {
#line 301
    *left1 = src->x_offset;
#line 302
    *width1 = src->width;
#line 303
    return;
  } else
#line 299
  if (src->x_offset >= dst_max_x) {
#line 301
    *left1 = src->x_offset;
#line 302
    *width1 = src->width;
#line 303
    return;
  } else
#line 299
  if (src_max_x <= dst->x_offset) {
#line 301
    *left1 = src->x_offset;
#line 302
    *width1 = src->width;
#line 303
    return;
  }
#line 306
  if (src->x_offset < dst->x_offset) {
#line 307
    *left1 = src->x_offset;
#line 308
    *width1 = dst->x_offset - src->x_offset;
  }
#line 311
  if (src_max_x > dst_max_x) {
#line 312
    *left2 = dst_max_x;
#line 313
    *width2 = src_max_x - dst_max_x;
  }
#line 315
  return;
}
}
#line 317 "/root/patron-new/new_3/src/demux/anim_decode.c"
int WebPAnimDecoderGetNext(WebPAnimDecoder *dec , uint8_t **buf_ptr , int *timestamp_ptr ) 
{ 
  WebPIterator iter ;
  uint32_t width ;
  uint32_t height ;
  int is_key_frame ;
  int timestamp ;
  void (*blend_row)(uint32_t * const   , uint32_t * const   , int  ) ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  uint8_t *in ;
  size_t in_size ;
  uint32_t stride ;
  uint64_t out_offset ;
  uint64_t size ;
  WebPDecoderConfig *config ;
  WebPRGBABuffer *buf ;
  VP8StatusCode __cil_tmp22 ;
  int y ;
  size_t offset ;
  int y___0 ;
  int canvas_y ;
  int left1 ;
  int width1 ;
  int left2 ;
  int width2 ;
  size_t offset1 ;
  size_t offset2 ;

  {
#line 326
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 326
    return (0);
  } else
#line 326
  if ((unsigned long )buf_ptr == (unsigned long )((void *)0)) {
#line 326
    return (0);
  } else
#line 326
  if ((unsigned long )timestamp_ptr == (unsigned long )((void *)0)) {
#line 326
    return (0);
  }
  {
#line 327
  __cil_tmp10 = WebPAnimDecoderHasMoreFrames(dec);
  }
#line 327
  if (! __cil_tmp10) {
#line 327
    return (0);
  }
  {
#line 329
  width = dec->info_.canvas_width;
#line 330
  height = dec->info_.canvas_height;
#line 331
  blend_row = dec->blend_func_;
#line 334
  __cil_tmp11 = WebPDemuxGetFrame(dec->demux_, dec->next_frame_, & iter);
  }
#line 334
  if (! __cil_tmp11) {
#line 335
    return (0);
  }
  {
#line 337
  timestamp = dec->prev_frame_timestamp_ + iter.duration;
#line 340
  is_key_frame = IsKeyFrame(& iter, & dec->prev_iter_, dec->prev_frame_was_keyframe_,
                            (int )width, (int )height);
  }
#line 342
  if (is_key_frame) {
    {
#line 343
    __cil_tmp13 = ZeroFillCanvas(dec->curr_frame_, width, height);
    }
#line 343
    if (! __cil_tmp13) {
#line 344
      goto Error;
    }
  } else {
    {
#line 347
    __cil_tmp14 = CopyCanvas(dec->prev_frame_disposed_, dec->curr_frame_, width, height);
    }
#line 347
    if (! __cil_tmp14) {
#line 349
      goto Error;
    }
  }
#line 355
  in = iter.fragment.bytes;
#line 356
  in_size = iter.fragment.size;
#line 357
  stride = width * 4U;
#line 358
  out_offset = (uint64_t )iter.y_offset * (unsigned long )stride + (uint64_t )iter.x_offset * 4UL;
#line 360
  size = (uint64_t )iter.height * (unsigned long )stride;
#line 361
  config = & dec->config_;
#line 362
  buf = & config->output.u.RGBA;
#line 363
  if (size != size) {
#line 363
    goto Error;
  }
  {
#line 364
  buf->stride = (int )stride;
#line 365
  buf->size = size;
#line 366
  buf->rgba = dec->curr_frame_ + out_offset;
#line 368
  __cil_tmp22 = WebPDecode(in, in_size, config);
  }
#line 368
  if ((unsigned int )__cil_tmp22 != 0U) {
#line 369
    goto Error;
  }
#line 377
  if (iter.frame_num > 1) {
#line 377
    if ((unsigned int )iter.blend_method == 0U) {
#line 377
      if (! is_key_frame) {
#line 379
        if ((unsigned int )dec->prev_iter_.dispose_method == 0U) {
#line 382
          y = 0;
          {
#line 382
          while (1) {
            while_continue: /* CIL Label */ ;

#line 382
            if (! (y < iter.height)) {
#line 382
              goto while_break;
            }
            {
#line 383
            offset = (size_t )((unsigned int )(iter.y_offset + y) * width + (unsigned int )iter.x_offset);
#line 385
            (*blend_row)((uint32_t */* const  */)((uint32_t *)dec->curr_frame_ + offset),
                         (uint32_t */* const  */)((uint32_t *)dec->prev_frame_disposed_ + offset),
                         iter.width);
#line 382
            y ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          while_break: ;
        } else {
#line 395
          y___0 = 0;
          {
#line 395
          while (1) {
            while_continue___0: /* CIL Label */ ;

#line 395
            if (! (y___0 < iter.height)) {
#line 395
              goto while_break___0;
            }
            {
#line 396
            canvas_y = iter.y_offset + y___0;
#line 398
            FindBlendRangeAtRow(& iter, & dec->prev_iter_, canvas_y, & left1, & width1,
                                & left2, & width2);
            }
#line 400
            if (width1 > 0) {
              {
#line 401
              offset1 = (size_t )((unsigned int )canvas_y * width + (unsigned int )left1);
#line 402
              (*blend_row)((uint32_t */* const  */)((uint32_t *)dec->curr_frame_ + offset1),
                           (uint32_t */* const  */)((uint32_t *)dec->prev_frame_disposed_ + offset1),
                           width1);
              }
            }
#line 405
            if (width2 > 0) {
              {
#line 406
              offset2 = (size_t )((unsigned int )canvas_y * width + (unsigned int )left2);
#line 407
              (*blend_row)((uint32_t */* const  */)((uint32_t *)dec->curr_frame_ + offset2),
                           (uint32_t */* const  */)((uint32_t *)dec->prev_frame_disposed_ + offset2),
                           width2);
              }
            }
#line 395
            y___0 ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          while_break___0: ;
        }
      }
    }
  }
  {
#line 415
  dec->prev_frame_timestamp_ = timestamp;
#line 416
  WebPDemuxReleaseIterator(& dec->prev_iter_);
#line 417
  dec->prev_iter_ = iter;
#line 418
  dec->prev_frame_was_keyframe_ = is_key_frame;
#line 419
  CopyCanvas(dec->curr_frame_, dec->prev_frame_disposed_, width, height);
  }
#line 420
  if ((unsigned int )dec->prev_iter_.dispose_method == 1U) {
    {
#line 421
    ZeroFillFrameRect(dec->prev_frame_disposed_, (int )(width * 4U), dec->prev_iter_.x_offset,
                      dec->prev_iter_.y_offset, dec->prev_iter_.width, dec->prev_iter_.height);
    }
  }
#line 425
  (dec->next_frame_) ++;
#line 428
  *buf_ptr = dec->curr_frame_;
#line 429
  *timestamp_ptr = timestamp;
#line 430
  return (1);
  Error: 
  {
#line 433
  WebPDemuxReleaseIterator(& iter);
  }
#line 434
  return (0);
}
}
#line 437 "/root/patron-new/new_3/src/demux/anim_decode.c"
int WebPAnimDecoderHasMoreFrames(WebPAnimDecoder *dec ) 
{ 


  {
#line 438
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 438
    return (0);
  }
#line 439
  return (dec->next_frame_ <= (int )dec->info_.frame_count);
}
}
#line 442 "/root/patron-new/new_3/src/demux/anim_decode.c"
void WebPAnimDecoderReset(WebPAnimDecoder *dec ) 
{ 


  {
#line 443
  if ((unsigned long )dec != (unsigned long )((void *)0)) {
    {
#line 444
    dec->prev_frame_timestamp_ = 0;
#line 445
    WebPDemuxReleaseIterator(& dec->prev_iter_);
#line 446
    memset((void *)(& dec->prev_iter_), 0, sizeof(dec->prev_iter_));
#line 447
    dec->prev_frame_was_keyframe_ = 0;
#line 448
    dec->next_frame_ = 1;
    }
  }
#line 451
  return;
}
}
#line 452 "/root/patron-new/new_3/src/demux/anim_decode.c"
WebPDemuxer *WebPAnimDecoderGetDemuxer(WebPAnimDecoder *dec ) 
{ 


  {
#line 453
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 453
    return ((WebPDemuxer *)((void *)0));
  }
#line 454
  return (dec->demux_);
}
}
#line 457 "/root/patron-new/new_3/src/demux/anim_decode.c"
void WebPAnimDecoderDelete(WebPAnimDecoder *dec ) 
{ 


  {
#line 458
  if ((unsigned long )dec != (unsigned long )((void *)0)) {
    {
#line 459
    WebPDemuxReleaseIterator(& dec->prev_iter_);
#line 460
    WebPDemuxDelete(dec->demux_);
#line 461
    WebPSafeFree((void *)dec->curr_frame_);
#line 462
    WebPSafeFree((void *)dec->prev_frame_disposed_);
#line 463
    WebPSafeFree((void *)dec);
    }
  }
#line 466
  return;
}
}
#line 26 "/root/patron-new/new_3/imageio/./wicdec.h"
int ReadPictureWithWIC(char const   *filename , struct WebPPicture *pic , int keep_alpha ,
                       struct Metadata *metadata ) ;
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 326
__inline extern int ( __attribute__((__gnu_inline__)) fprintf)(FILE *__stream , char const   *__fmt 
                                                               , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__)) printf)(char const   *__fmt 
                                                              , ...) ;
#line 334
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) sprintf)(char *__s ,
                                                                                             char const   *__fmt 
                                                                                             , ...) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__)) vfprintf)(FILE *__stream , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   *__fmt ,
                                                               __gnuc_va_list __ap ) ;
#line 349
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s ,
                                                                                              char const   *__fmt ,
                                                                                              __gnuc_va_list __ap ) ;
#line 354
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) snprintf)(char *__s ,
                                                                                              size_t __n ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s ,
                                                                                               size_t __n ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 379
__inline extern int ( __attribute__((__gnu_inline__)) vdprintf)(int __fd , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) ;
#line 382
__inline extern int ( __attribute__((__gnu_inline__)) dprintf)(int __fd , char const   *__fmt 
                                                               , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 499
extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
#line 500
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 510
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 537
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__gnu_inline__)) fgets)(char *__s , int __n ,
                                                               FILE *__stream ) ;
#line 646
__inline extern unsigned long ( __attribute__((__gnu_inline__)) fread)(void *__ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE *__stream ) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 673
__inline extern size_t ( __attribute__((__gnu_inline__)) fread_unlocked)(void *__ptr ,
                                                                         size_t __size ,
                                                                         size_t __n ,
                                                                         FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  int tmp___2 ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                                0L);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp___2 = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp___2 = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp___2);
}
}
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  int tmp___2 ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                                0L);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp___2 = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp___2 = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp___2);
}
}
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp___2 ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                                0L);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp___2 = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp___2 = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp___2);
}
}
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp___2 ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                                0L);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp___2 = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp___2 = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp___2);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) sprintf)(char *__s ,
                                                                                             char const   *__fmt 
                                                                                             , ...) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) sprintf)(char *__s , char const   *__fmt 
                                                               , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp3 = __builtin_object_size((void *)__s, 1);
#line 36
  __cil_tmp4 = (int )__builtin_va_arg_pack();
#line 36
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 46
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s ,
                                                                                              char const   *__fmt ,
                                                                                              __gnuc_va_list __ap ) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 49
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 49
  return (__cil_tmp5);
}
}
#line 64
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) snprintf)(char *__s ,
                                                                                              size_t __n ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) snprintf)(char *__s , size_t __n ,
                                                                char const   *__fmt 
                                                                , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 67
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 67
  __cil_tmp5 = (int )__builtin_va_arg_pack();
#line 67
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 67
  return (__cil_tmp6);
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s ,
                                                                                               size_t __n ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s , size_t __n ,
                                                                 char const   *__fmt ,
                                                                 __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 80
  __cil_tmp5 = __builtin_object_size((void *)__s, 1);
#line 80
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 80
  return (__cil_tmp6);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) fprintf)(FILE *__stream , char const   *__fmt 
                                                               , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 100
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 100
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 100
  return (__cil_tmp4);
}
}
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) printf)(char const   *__fmt 
                                                              , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp2 = (int )__builtin_va_arg_pack();
#line 107
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   *__fmt ,
                                                               __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 120
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 120
  return (__cil_tmp3);
}
}
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vfprintf)(FILE *__stream , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 134
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 136
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) dprintf)(int __fd , char const   *__fmt 
                                                               , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 144
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 144
  return (__cil_tmp4);
}
}
#line 153 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vdprintf)(int __fd , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 155
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 155
  return (__cil_tmp4);
}
}
#line 243
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 248
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 255 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__gnu_inline__)) fgets)(char *__s , int __n ,
                                                               FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 257
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
  }
#line 257
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 259
    __cil_tmp5 = 0;
#line 259
    if (! __cil_tmp5) {
      {
#line 260
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 260
      return (__cil_tmp7);
    } else
#line 259
    if (__n <= 0) {
      {
#line 260
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 260
      return (__cil_tmp7);
    }
    {
#line 262
    __cil_tmp8 = __builtin_object_size((void *)__s, 1);
    }
#line 262
    if ((size_t )__n > __cil_tmp8) {
      {
#line 263
      __cil_tmp9 = __builtin_object_size((void *)__s, 1);
#line 263
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 263
      return (__cil_tmp10);
    }
  }
  {
#line 265
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 265
  return (__cil_tmp11);
}
}
#line 268
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 271
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 275
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 284 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long ( __attribute__((__gnu_inline__)) fread)(void *__ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 287
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 287
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 289
    __cil_tmp7 = 0;
#line 289
    __cil_tmp6 = 0;
#line 289
    if (! __cil_tmp6) {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if (! __cil_tmp7) {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp9);
    }
    {
#line 294
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 294
    if (__size * __n > __cil_tmp10) {
      {
#line 295
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 297
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 297
  return (__cil_tmp13);
}
}
#line 329
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 332
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 336
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) fread_unlocked)(void *__ptr ,
                                                                         size_t __size ,
                                                                         size_t __n ,
                                                                         FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 350
    __cil_tmp7 = 0;
#line 350
    __cil_tmp6 = 0;
#line 350
    if (! __cil_tmp6) {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
#line 362
  __cil_tmp14 = 0;
#line 362
  __cil_tmp13 = 0;
#line 362
  if (__cil_tmp13) {
#line 362
    if (__cil_tmp14) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;

#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
            {
#line 374
            __cil_tmp18 = getc_unlocked(__stream);
#line 374
            __c = __cil_tmp18;
            }
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            __cil_tmp19 = __cptr;
#line 377
            __cptr ++;
#line 377
            *__cil_tmp19 = (char )__c;
#line 372
            __cnt --;
          }
          while_break___0: /* CIL Label */ ;
          }
          while_break: ;
#line 379
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 382
  __cil_tmp20 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp20);
}
}
#line 393 "/root/patron-new/new_3/imageio/wicdec.c"
int ReadPictureWithWIC(char const   *filename , struct WebPPicture *pic , int keep_alpha ,
                       struct Metadata *metadata ) 
{ 


  {
  {
#line 400
  fprintf(stderr, "Windows Imaging Component (WIC) support not compiled. Visual Studio and mingw-w64 builds support WIC. Make sure wincodec.h detection is working correctly if using autoconf and HAVE_WINCODEC_H is defined before building.\n\220");
  }
#line 404
  return (0);
}
}
#line 30 "/root/patron-new/new_3/imageio/./webpdec.h"
void PrintWebPError(char const   *in_file , int status ) ;
#line 35
int LoadWebP(char const   *in_file , uint8_t **data , size_t *data_size , WebPBitstreamFeatures *bitstream ) ;
#line 44
VP8StatusCode DecodeWebP(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) ;
#line 48
VP8StatusCode DecodeWebPIncremental(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) ;
#line 59
int ReadWebP(uint8_t *data , size_t data_size , WebPPicture *pic , int keep_alpha ,
             Metadata *metadata ) ;
#line 28 "/root/patron-new/new_3/imageio/./imageio_util.h"
FILE *ImgIoUtilSetBinaryMode(FILE *file ) ;
#line 38
int ImgIoUtilReadFile(char const   *file_name , uint8_t **data , size_t *data_size ) ;
#line 42
int ImgIoUtilReadFromStdin(uint8_t **data , size_t *data_size ) ;
#line 46
int ImgIoUtilWriteFile(char const   *file_name , uint8_t *data , size_t data_size ) ;
#line 52
void ImgIoUtilCopyPlane(uint8_t *src , int src_stride , uint8_t *dst , int dst_stride ,
                        int width , int height ) ;
#line 58
int ImgIoUtilCheckSizeArgumentsOverflow(uint64_t stride , size_t height ) ;
#line 35 "/root/patron-new/new_3/imageio/./metadata.h"
void MetadataInit(Metadata *metadata ) ;
#line 36
void MetadataPayloadDelete(MetadataPayload *payload ) ;
#line 37
void MetadataFree(Metadata *metadata ) ;
#line 40
int MetadataCopy(char const   *metadata , size_t metadata_len , MetadataPayload *payload ) ;
#line 32 "/root/patron-new/new_3/imageio/webpdec.c"
static char const   * const  kStatusMessages[8]  = 
#line 32 "/root/patron-new/new_3/imageio/webpdec.c"
  {      (char const   */* const  */)"OK",      (char const   */* const  */)"OUT_OF_MEMORY",      (char const   */* const  */)"INVALID_PARAM",      (char const   */* const  */)"BITSTREAM_ERROR", 
        (char const   */* const  */)"UNSUPPORTED_FEATURE",      (char const   */* const  */)"SUSPENDED",      (char const   */* const  */)"USER_ABORT",      (char const   */* const  */)"NOT_ENOUGH_DATA"};
#line 37 "/root/patron-new/new_3/imageio/webpdec.c"
static void PrintAnimationWarning(WebPDecoderConfig *config ) 
{ 


  {
#line 38
  if (config->input.has_animation) {
    {
#line 39
    fprintf(stderr, "Error! Decoding of an animated WebP file is not supported.\n       Use webpmux to extract the individual frames or\n       vwebp to view this image.\n");
    }
  }
#line 42
  return;
}
}
#line 46 "/root/patron-new/new_3/imageio/webpdec.c"
void PrintWebPError(char const   *in_file , int status ) 
{ 


  {
  {
#line 47
  fprintf(stderr, "Decoding of %s failed.\n", in_file);
#line 48
  fprintf(stderr, "Status: %d", status);
  }
#line 49
  if (status >= 0) {
#line 49
    if (status <= 7) {
      {
#line 50
      fprintf(stderr, "(%s)", kStatusMessages[status]);
      }
    }
  }
  {
#line 52
  fprintf(stderr, "\n");
  }
#line 54
  return;
}
}
#line 55 "/root/patron-new/new_3/imageio/webpdec.c"
int LoadWebP(char const   *in_file , uint8_t **data , size_t *data_size , WebPBitstreamFeatures *bitstream ) 
{ 
  VP8StatusCode status ;
  WebPBitstreamFeatures local_features ;
  int __cil_tmp7 ;

  {
  {
#line 60
  __cil_tmp7 = ImgIoUtilReadFile(in_file, data, data_size);
  }
#line 60
  if (! __cil_tmp7) {
#line 60
    return (0);
  }
#line 62
  if ((unsigned long )bitstream == (unsigned long )((void *)0)) {
#line 63
    bitstream = & local_features;
  }
  {
#line 66
  status = WebPGetFeatures(*data, *data_size, bitstream);
  }
#line 67
  if ((unsigned int )status != 0U) {
    {
#line 68
    WebPFree((void *)*data);
#line 69
    *data = (uint8_t *)((void *)0);
#line 70
    *data_size = (size_t )0;
#line 71
    PrintWebPError(in_file, (int )status);
    }
#line 72
    return (0);
  }
#line 74
  return (1);
}
}
#line 79 "/root/patron-new/new_3/imageio/webpdec.c"
VP8StatusCode DecodeWebP(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) 
{ 
  VP8StatusCode __cil_tmp4 ;

  {
#line 81
  if ((unsigned long )config == (unsigned long )((void *)0)) {
#line 81
    return ((VP8StatusCode )2);
  }
  {
#line 82
  PrintAnimationWarning(config);
#line 83
  __cil_tmp4 = WebPDecode(data, data_size, config);
  }
#line 83
  return (__cil_tmp4);
}
}
#line 86 "/root/patron-new/new_3/imageio/webpdec.c"
VP8StatusCode DecodeWebPIncremental(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) 
{ 
  VP8StatusCode status ;
  WebPIDecoder *idec ;
  WebPIDecoder *__cil_tmp6 ;

  {
#line 89
  status = (VP8StatusCode )0;
#line 90
  if ((unsigned long )config == (unsigned long )((void *)0)) {
#line 90
    return ((VP8StatusCode )2);
  }
  {
#line 92
  PrintAnimationWarning(config);
#line 96
  __cil_tmp6 = WebPIDecode(data, data_size, config);
#line 96
  idec = __cil_tmp6;
  }
#line 97
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
    {
#line 98
    fprintf(stderr, "Failed during WebPIDecode().\nV");
    }
#line 99
    return ((VP8StatusCode )1);
  } else {
    {
#line 101
    status = WebPIUpdate(idec, data, data_size);
#line 102
    WebPIDelete(idec);
    }
  }
#line 105
  return (status);
}
}
#line 111 "/root/patron-new/new_3/imageio/webpdec.c"
static int ExtractMetadata(uint8_t *data , size_t data_size , Metadata *metadata ) 
{ 
  WebPData webp_data ;
  WebPDemuxer *demux ;
  WebPDemuxer *__cil_tmp6 ;
  WebPChunkIterator chunk_iter ;
  uint32_t flags ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 113
  webp_data.bytes = data;
#line 113
  webp_data.size = data_size;
#line 114
  __cil_tmp6 = WebPDemux(& webp_data);
#line 114
  demux = __cil_tmp6;
  }
#line 118
  if ((unsigned long )demux == (unsigned long )((void *)0)) {
#line 118
    return (0);
  }
  {
#line 121
  flags = WebPDemuxGetI(demux, (WebPFormatFeature )0);
#line 123
  __cil_tmp10 = WebPDemuxGetChunk(demux, (char const   *)"ICCP\001V", 1, & chunk_iter);
  }
#line 123
  if (flags & 32U) {
#line 123
    if (__cil_tmp10) {
      {
#line 124
      MetadataCopy((char const   *)chunk_iter.chunk.bytes, chunk_iter.chunk.size,
                   & metadata->iccp);
#line 126
      WebPDemuxReleaseChunkIterator(& chunk_iter);
      }
    }
  }
  {
#line 128
  __cil_tmp11 = WebPDemuxGetChunk(demux, (char const   *)"EXIF", 1, & chunk_iter);
  }
#line 128
  if (flags & 8U) {
#line 128
    if (__cil_tmp11) {
      {
#line 129
      MetadataCopy((char const   *)chunk_iter.chunk.bytes, chunk_iter.chunk.size,
                   & metadata->exif);
#line 131
      WebPDemuxReleaseChunkIterator(& chunk_iter);
      }
    }
  }
  {
#line 133
  __cil_tmp12 = WebPDemuxGetChunk(demux, (char const   *)"XMP ", 1, & chunk_iter);
  }
#line 133
  if (flags & 4U) {
#line 133
    if (__cil_tmp12) {
      {
#line 134
      MetadataCopy((char const   *)chunk_iter.chunk.bytes, chunk_iter.chunk.size,
                   & metadata->xmp);
#line 136
      WebPDemuxReleaseChunkIterator(& chunk_iter);
      }
    }
  }
  {
#line 138
  WebPDemuxDelete(demux);
  }
#line 139
  return (1);
}
}
#line 144 "/root/patron-new/new_3/imageio/webpdec.c"
int ReadWebP(uint8_t *data , size_t data_size , WebPPicture *pic , int keep_alpha ,
             Metadata *metadata ) 
{ 
  int ok ;
  VP8StatusCode status ;
  WebPDecoderConfig config ;
  WebPDecBuffer *output_buffer ;
  WebPBitstreamFeatures *bitstream ;
  int __cil_tmp11 ;
  int has_alpha ;
  uint64_t stride ;
  int tmp___2 ;
  int tmp___3 ;
  int __cil_tmp17 ;
  int tmp___4 ;
  uint8_t *tmp___5 ;
  int tmp___6 ;
  int x ;
  int y ;
  uint32_t *argb ;
  int tmp___7 ;

  {
#line 147
  ok = 0;
#line 148
  status = (VP8StatusCode )0;
#line 150
  output_buffer = & config.output;
#line 151
  bitstream = & config.input;
#line 153
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 153
    return (0);
  } else
#line 153
  if (data_size == 0UL) {
#line 153
    return (0);
  } else
#line 153
  if ((unsigned long )pic == (unsigned long )((void *)0)) {
#line 153
    return (0);
  }
  {
#line 155
  __cil_tmp11 = WebPInitDecoderConfig(& config);
  }
#line 155
  if (! __cil_tmp11) {
    {
#line 156
    fprintf(stderr, "Library version mismatch!\n");
    }
#line 157
    return (0);
  }
  {
#line 160
  status = WebPGetFeatures(data, data_size, bitstream);
  }
#line 161
  if ((unsigned int )status != 0U) {
    {
#line 162
    PrintWebPError("input data", (int )status);
    }
#line 163
    return (0);
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;

#line 167
    if (keep_alpha) {
#line 167
      if (bitstream->has_alpha) {
#line 167
        tmp___7 = 1;
      } else {
#line 167
        tmp___7 = 0;
      }
    } else {
#line 167
      tmp___7 = 0;
    }
#line 167
    has_alpha = tmp___7;
#line 169
    pic->width = bitstream->width;
#line 170
    pic->height = bitstream->height;
#line 171
    if (pic->use_argb) {
#line 172
      stride = (uint64_t )bitstream->width * 4UL;
    } else {
#line 174
      if (has_alpha) {
#line 174
        tmp___2 = 5;
      } else {
#line 174
        tmp___2 = 3;
      }
#line 174
      stride = ((uint64_t )bitstream->width * (unsigned long )tmp___2) / 2UL;
#line 175
      if (has_alpha) {
#line 175
        tmp___3 = 4;
      } else {
#line 175
        tmp___3 = 0;
      }
#line 175
      pic->colorspace = (WebPEncCSP )tmp___3;
    }
    {
#line 178
    __cil_tmp17 = ImgIoUtilCheckSizeArgumentsOverflow(stride, (size_t )bitstream->height);
    }
#line 178
    if (! __cil_tmp17) {
#line 179
      status = (VP8StatusCode )1;
#line 180
      goto while_break;
    }
    {
#line 183
    ok = WebPPictureAlloc(pic);
    }
#line 184
    if (! ok) {
#line 185
      status = (VP8StatusCode )1;
#line 186
      goto while_break;
    }
#line 188
    if (pic->use_argb) {
#line 192
      output_buffer->colorspace = (WEBP_CSP_MODE )3;
#line 194
      output_buffer->u.RGBA.rgba = (uint8_t *)pic->argb;
#line 195
      output_buffer->u.RGBA.stride = (int )((unsigned long )pic->argb_stride * sizeof(uint32_t ));
#line 196
      output_buffer->u.RGBA.size = (size_t )(output_buffer->u.RGBA.stride * pic->height);
    } else {
#line 198
      if (has_alpha) {
#line 198
        tmp___4 = 12;
      } else {
#line 198
        tmp___4 = 11;
      }
#line 198
      output_buffer->colorspace = (WEBP_CSP_MODE )tmp___4;
#line 199
      output_buffer->u.YUVA.y = pic->y;
#line 200
      output_buffer->u.YUVA.u = pic->u;
#line 201
      output_buffer->u.YUVA.v = pic->v;
#line 202
      if (has_alpha) {
#line 202
        tmp___5 = pic->a;
      } else {
#line 202
        tmp___5 = (uint8_t *)((void *)0);
      }
#line 202
      output_buffer->u.YUVA.a = tmp___5;
#line 203
      output_buffer->u.YUVA.y_stride = pic->y_stride;
#line 204
      output_buffer->u.YUVA.u_stride = pic->uv_stride;
#line 205
      output_buffer->u.YUVA.v_stride = pic->uv_stride;
#line 206
      if (has_alpha) {
#line 206
        tmp___6 = pic->a_stride;
      } else {
#line 206
        tmp___6 = 0;
      }
#line 206
      output_buffer->u.YUVA.a_stride = tmp___6;
#line 207
      output_buffer->u.YUVA.y_size = (size_t )(pic->height * pic->y_stride);
#line 208
      output_buffer->u.YUVA.u_size = (size_t )(((pic->height + 1) / 2) * pic->uv_stride);
#line 209
      output_buffer->u.YUVA.v_size = (size_t )(((pic->height + 1) / 2) * pic->uv_stride);
#line 210
      output_buffer->u.YUVA.a_size = (size_t )(pic->height * pic->a_stride);
    }
    {
#line 212
    output_buffer->is_external_memory = 1;
#line 214
    status = DecodeWebP(data, data_size, & config);
#line 215
    ok = (unsigned int )status == 0U;
    }
#line 216
    if (ok) {
#line 216
      if (! keep_alpha) {
#line 216
        if (pic->use_argb) {
#line 219
          argb = pic->argb;
#line 220
          y = 0;
          {
#line 220
          while (1) {
            while_continue___0: /* CIL Label */ ;

#line 220
            if (! (y < pic->height)) {
#line 220
              goto while_break___0;
            }
#line 221
            x = 0;
            {
#line 221
            while (1) {
              while_continue___1: /* CIL Label */ ;

#line 221
              if (! (x < pic->width)) {
#line 221
                goto while_break___1;
              }
#line 221
              *(argb + x) |= 4278190080U;
#line 221
              x ++;
            }
            while_break___4: /* CIL Label */ ;
            }
            while_break___1: 
#line 222
            argb += pic->argb_stride;
#line 220
            y ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          while_break___0: ;
        }
      }
    }
#line 166
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 227
  if ((unsigned int )status != 0U) {
    {
#line 228
    PrintWebPError("input data", (int )status);
#line 229
    ok = 0;
    }
  }
  {
#line 232
  WebPFreeDecBuffer(output_buffer);
  }
#line 234
  if ((unsigned long )metadata != (unsigned long )((void *)0)) {
#line 234
    if (ok) {
      {
#line 235
      ok = ExtractMetadata(data, data_size, metadata);
      }
#line 236
      if (! ok) {
        {
#line 237
        PrintWebPError("metadata\230", 3);
        }
      }
    }
  }
#line 240
  if (! ok) {
    {
#line 240
    WebPPictureFree(pic);
    }
  }
#line 241
  return (ok);
}
}
#line 29 "/root/patron-new/new_3/imageio/./tiffdec.h"
int ReadTIFF(uint8_t *data , size_t data_size , WebPPicture *pic , int keep_alpha ,
             Metadata *metadata ) ;
#line 293 "/usr/include/x86_64-linux-gnu/tiffio.h"
extern void *_TIFFmalloc(tmsize_t s ) ;
#line 299
extern void _TIFFfree(void *p ) ;
#line 343
extern void TIFFClose(TIFF *tif ) ;
#line 346
extern int TIFFGetField(TIFF *tif , uint32 tag  , ...) ;
#line 348
extern int TIFFGetFieldDefaulted(TIFF *tif , uint32 tag  , ...) ;
#line 391
extern uint16 TIFFNumberOfDirectories(TIFF * ) ;
#line 429
extern int TIFFReadRGBAImageOriented(TIFF * , uint32  , uint32  , uint32 * , int  ,
                                     int  ) ;
#line 445
extern TIFF *TIFFClientOpen(char const   * , char const   * , thandle_t  , tmsize_t (*)(thandle_t  ,
                                                                                        void * ,
                                                                                        tmsize_t  ) ,
                            tmsize_t (*)(thandle_t  , void * , tmsize_t  ) , toff_t (*)(thandle_t  ,
                                                                                        toff_t  ,
                                                                                        int  ) ,
                            int (*)(thandle_t  ) , toff_t (*)(thandle_t  ) , int (*)(thandle_t  ,
                                                                                     void ** ,
                                                                                     toff_t * ) ,
                            void (*)(thandle_t  , void * , toff_t  ) ) ;
#line 32 "/root/patron-new/new_3/imageio/tiffdec.c"
static struct __anonstruct_945 kTIFFMetadataMap[3]  = {      {(ttag_t )34675, (size_t )0}, 
        {(ttag_t )700, (size_t )0}, 
        {(ttag_t )0, (size_t )0}};
#line 40 "/root/patron-new/new_3/imageio/tiffdec.c"
static int ExtractMetadataFromTIFF(TIFF *tif , Metadata *metadata ) 
{ 
  int i ;
  toff_t exif_ifd_offset ;
  MetadataPayload *payload ;
  void *tag_data ;
  uint32 tag_data_len ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 44
  i = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;

#line 44
    if (! (kTIFFMetadataMap[i].tag != 0U)) {
#line 44
      goto while_break;
    }
    {
#line 45
    payload = (MetadataPayload *)((uint8_t *)metadata + kTIFFMetadataMap[i].storage_offset);
#line 51
    __cil_tmp9 = MetadataCopy((char const   *)tag_data, (size_t )tag_data_len, payload);
#line 51
    __cil_tmp8 = TIFFGetField(tif, kTIFFMetadataMap[i].tag, & tag_data_len, & tag_data);
    }
#line 51
    if (__cil_tmp8) {
#line 51
      if (! __cil_tmp9) {
#line 53
        return (0);
      }
    }
#line 44
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 63
  __cil_tmp10 = TIFFGetField(tif, (uint32 )34665, & exif_ifd_offset);
  }
#line 63
  if (__cil_tmp10) {
    {
#line 64
    fprintf(stderr, "Warning: EXIF extraction from TIFF is unsupported.\n");
    }
  }
#line 66
  return (1);
}
}
#line 76 "/root/patron-new/new_3/imageio/tiffdec.c"
static int MyClose(thandle_t opaque ) 
{ 


  {
#line 78
  return (0);
}
}
#line 81 "/root/patron-new/new_3/imageio/tiffdec.c"
static toff_t MySize(thandle_t opaque ) 
{ 
  MyData *my_data ;

  {
#line 82
  my_data = (MyData *)opaque;
#line 83
  return (my_data->size);
}
}
#line 86 "/root/patron-new/new_3/imageio/tiffdec.c"
static toff_t MySeek(thandle_t opaque , toff_t offset , int whence ) 
{ 
  MyData *my_data ;
  unsigned long tmp___2 ;
  toff_t tmp___3 ;

  {
#line 87
  my_data = (MyData *)opaque;
#line 88
  if (whence == 1) {
#line 88
    tmp___3 = my_data->pos;
  } else {
#line 88
    if (whence == 0) {
#line 88
      tmp___2 = 0UL;
    } else {
#line 88
      tmp___2 = my_data->size;
    }
#line 88
    tmp___3 = tmp___2;
  }
#line 88
  offset += tmp___3;
#line 91
  if (offset > my_data->size) {
#line 91
    return ((toff_t )-1);
  }
#line 92
  my_data->pos = offset;
#line 93
  return (offset);
}
}
#line 96 "/root/patron-new/new_3/imageio/tiffdec.c"
static int MyMapFile(thandle_t opaque , void **base , toff_t *size ) 
{ 


  {
#line 100
  return (0);
}
}
#line 102 "/root/patron-new/new_3/imageio/tiffdec.c"
static void MyUnmapFile(thandle_t opaque , void *base , toff_t size ) 
{ 


  {
#line 107
  return;
}
}
#line 108 "/root/patron-new/new_3/imageio/tiffdec.c"
static tsize_t MyRead(thandle_t opaque , void *dst , tsize_t size ) 
{ 
  MyData *my_data ;

  {
#line 109
  my_data = (MyData *)opaque;
#line 110
  if (my_data->pos + (unsigned long )size > my_data->size) {
#line 111
    size = (tsize_t )(my_data->size - my_data->pos);
  }
#line 113
  if (size > 0L) {
    {
#line 114
    memcpy(dst, (void const   *)(my_data->data + my_data->pos), (unsigned long )size);
#line 115
    my_data->pos += (unsigned long )size;
    }
  }
#line 117
  return (size);
}
}
#line 125 "/root/patron-new/new_3/imageio/tiffdec.c"
static uint32_t Unmult(uint8_t x , uint32_t mult ) 
{ 
  uint32_t v ;
  unsigned int tmp___2 ;

  {
#line 126
  v = ((unsigned int )x * mult + ((1U << 24) >> 1)) >> 24;
#line 127
  if (v > 255U) {
#line 127
    tmp___2 = 255U;
  } else {
#line 127
    tmp___2 = v;
  }
#line 127
  return (tmp___2);
}
}
#line 130 "/root/patron-new/new_3/imageio/tiffdec.c"
__inline static uint32_t GetScale___2(uint32_t a ) 
{ 


  {
#line 131
  return ((255U << 24) / a);
}
}
#line 137 "/root/patron-new/new_3/imageio/tiffdec.c"
static void MultARGBRow(uint8_t *ptr , int width ) 
{ 
  int x ;
  uint32_t alpha ;
  uint32_t scale ;
  uint32_t __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;

  {
#line 139
  x = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;

#line 139
    if (! (x < width)) {
#line 139
      goto while_break;
    }
#line 140
    alpha = (uint32_t )*(ptr + 3);
#line 141
    if (alpha < 255U) {
#line 142
      if (alpha == 0U) {
#line 143
        *(ptr + 2) = (uint8_t )0;
#line 143
        *(ptr + 1) = *(ptr + 2);
#line 143
        *(ptr + 0) = *(ptr + 1);
      } else {
        {
#line 145
        __cil_tmp6 = GetScale___2(alpha);
#line 145
        scale = __cil_tmp6;
#line 146
        __cil_tmp7 = Unmult(*(ptr + 0), scale);
#line 146
        *(ptr + 0) = (uint8_t )__cil_tmp7;
#line 147
        __cil_tmp8 = Unmult(*(ptr + 1), scale);
#line 147
        *(ptr + 1) = (uint8_t )__cil_tmp8;
#line 148
        __cil_tmp9 = Unmult(*(ptr + 2), scale);
#line 148
        *(ptr + 2) = (uint8_t )__cil_tmp9;
        }
      }
    }
#line 139
    ptr += 4;
#line 139
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 143
  return;
}
}
#line 154 "/root/patron-new/new_3/imageio/tiffdec.c"
int ReadTIFF(uint8_t *data , size_t data_size , WebPPicture *pic , int keep_alpha ,
             Metadata *metadata ) 
{ 
  MyData my_data ;
  TIFF *tif ;
  uint32_t image_width ;
  uint32_t image_height ;
  uint32_t tile_width ;
  uint32_t tile_height ;
  uint64_t stride ;
  uint16_t samples_per_px ;
  uint16_t extra_samples ;
  uint16_t *extra_samples_ptr ;
  uint32_t *raster ;
  int64_t alloc_size ;
  int ok ;
  tdir_t dircount ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  void *__cil_tmp30 ;
  int __cil_tmp31 ;
  uint32_t y ;
  uint8_t *tmp___2 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int tmp___3 ;

  {
#line 157
  my_data.data = data;
#line 157
  my_data.size = data_size;
#line 157
  my_data.pos = (toff_t )0;
#line 161
  samples_per_px = (uint16_t )0;
#line 162
  extra_samples = (uint16_t )0;
#line 163
  extra_samples_ptr = (uint16_t *)((void *)0);
#line 166
  ok = 0;
#line 169
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 170
    return (0);
  } else
#line 169
  if (data_size == 0UL) {
#line 170
    return (0);
  } else
#line 169
  if (data_size > 2147483647UL) {
#line 170
    return (0);
  } else
#line 169
  if ((unsigned long )pic == (unsigned long )((void *)0)) {
#line 170
    return (0);
  }
  {
#line 173
  tif = TIFFClientOpen("Memory", "r", (thandle_t )(& my_data), & MyRead, & MyRead,
                       & MySeek, & MyClose, & MySize, & MyMapFile, & MyUnmapFile);
  }
#line 176
  if ((unsigned long )tif == (unsigned long )((void *)0)) {
    {
#line 177
    fprintf(stderr, "Error! Cannot parse TIFF file\n");
    }
#line 178
    return (0);
  }
  {
#line 181
  dircount = TIFFNumberOfDirectories(tif);
  }
#line 182
  if ((int )dircount > 1) {
    {
#line 183
    fprintf(stderr, "Warning: multi-directory TIFF files are not supported.\nOnly the first will be used, %d will be ignored.\n",
            (int )dircount - 1);
    }
  }
  {
#line 187
  __cil_tmp22 = TIFFGetFieldDefaulted(tif, (uint32 )277, & samples_per_px);
  }
#line 187
  if (! __cil_tmp22) {
    {
#line 188
    fprintf(stderr, "Error! Cannot retrieve TIFF samples-per-pixel info.\n");
    }
#line 189
    goto End;
  }
#line 191
  if ((int )samples_per_px < 3) {
#line 191
    goto End;
  } else
#line 191
  if ((int )samples_per_px > 4) {
#line 191
    goto End;
  }
  {
#line 193
  __cil_tmp24 = TIFFGetField(tif, (uint32 )257, & image_height);
#line 193
  __cil_tmp23 = TIFFGetField(tif, (uint32 )256, & image_width);
  }
#line 193
  if (__cil_tmp23) {
#line 193
    if (! __cil_tmp24) {
      {
#line 195
      fprintf(stderr, "Error! Cannot retrieve TIFF image dimensions.\n");
      }
#line 196
      goto End;
    }
  } else {
    {
#line 195
    fprintf(stderr, "Error! Cannot retrieve TIFF image dimensions.\n");
    }
#line 196
    goto End;
  }
  {
#line 198
  stride = (uint64_t )image_width * sizeof(*raster);
#line 199
  __cil_tmp25 = ImgIoUtilCheckSizeArgumentsOverflow(stride, (size_t )image_height);
  }
#line 199
  if (! __cil_tmp25) {
    {
#line 200
    fprintf(stderr, "Error! TIFF image dimension (%d x %d) is too large.\n", image_width,
            image_height);
    }
#line 202
    goto End;
  }
  {
#line 211
  __cil_tmp27 = TIFFGetField(tif, (uint32 )323, & tile_height);
#line 211
  __cil_tmp26 = TIFFGetField(tif, (uint32 )322, & tile_width);
  }
#line 211
  if (__cil_tmp26) {
#line 211
    if (__cil_tmp27) {
      {
#line 213
      __cil_tmp28 = ImgIoUtilCheckSizeArgumentsOverflow((uint64_t )tile_width * sizeof(*raster),
                                                        (size_t )tile_height);
      }
#line 213
      if (tile_width > 32U) {
#line 213
        if (tile_width / 2U > image_width) {
          {
#line 217
          fprintf(stderr, "Error! TIFF tile dimension (%d x %d) is too large.\n",
                  tile_width, tile_height);
          }
#line 219
          goto End;
        } else {
#line 213
          goto _L___75;
        }
      } else
      _L___75: 
#line 213
      if (tile_height > 32U) {
#line 213
        if (tile_height / 2U > image_height) {
          {
#line 217
          fprintf(stderr, "Error! TIFF tile dimension (%d x %d) is too large.\n",
                  tile_width, tile_height);
          }
#line 219
          goto End;
        } else {
#line 213
          goto _L;
        }
      } else
      _L: 
#line 213
      if (__cil_tmp28) {
        {
#line 217
        fprintf(stderr, "Error! TIFF tile dimension (%d x %d) is too large.\n", tile_width,
                tile_height);
        }
#line 219
        goto End;
      }
    }
  }
  {
#line 223
  __cil_tmp29 = TIFFGetField(tif, (uint32 )338, & extra_samples, & extra_samples_ptr);
  }
#line 223
  if ((int )samples_per_px > 3) {
#line 223
    if (! __cil_tmp29) {
      {
#line 225
      fprintf(stderr, "Error! Cannot retrieve TIFF ExtraSamples info.\n");
      }
#line 226
      goto End;
    }
  }
#line 230
  alloc_size = (int64_t )(stride * (unsigned long )image_height);
#line 231
  if (alloc_size < 0L) {
#line 231
    goto End;
  } else
#line 231
  if (alloc_size != alloc_size) {
#line 231
    goto End;
  }
  {
#line 233
  __cil_tmp30 = _TIFFmalloc(alloc_size);
#line 233
  raster = (uint32 *)__cil_tmp30;
  }
#line 234
  if ((unsigned long )raster != (unsigned long )((void *)0)) {
    {
#line 235
    __cil_tmp31 = TIFFReadRGBAImageOriented(tif, image_width, image_height, raster,
                                            1, 1);
    }
#line 235
    if (__cil_tmp31) {
#line 237
      pic->width = (int )image_width;
#line 238
      pic->height = (int )image_height;
#line 244
      if ((unsigned long )extra_samples_ptr != (unsigned long )((void *)0)) {
#line 244
        if ((int )extra_samples == 1) {
#line 244
          if ((int )*(extra_samples_ptr + 0) == 1) {
#line 247
            tmp___2 = (uint8_t *)raster;
#line 248
            y = (uint32_t )0;
            {
#line 248
            while (1) {
              while_continue: /* CIL Label */ ;

#line 248
              if (! (y < image_height)) {
#line 248
                goto while_break;
              }
              {
#line 249
              MultARGBRow(tmp___2, (int )image_width);
#line 250
              tmp___2 += stride;
#line 248
              y ++;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
            while_break: ;
          }
        }
      }
#line 253
      if (keep_alpha) {
        {
#line 253
        __cil_tmp34 = WebPPictureImportRGBA(pic, (uint8_t *)raster, (int )stride);
#line 253
        tmp___3 = __cil_tmp34;
        }
      } else {
        {
#line 253
        __cil_tmp35 = WebPPictureImportRGBX(pic, (uint8_t *)raster, (int )stride);
#line 253
        tmp___3 = __cil_tmp35;
        }
      }
#line 253
      ok = tmp___3;
    }
    {
#line 257
    _TIFFfree((void *)raster);
    }
  } else {
    {
#line 259
    fprintf(stderr, "Error allocating TIFF RGBA memory!\n");
    }
  }
#line 262
  if (ok) {
#line 263
    if ((unsigned long )metadata != (unsigned long )((void *)0)) {
      {
#line 264
      ok = ExtractMetadataFromTIFF(tif, metadata);
      }
#line 265
      if (! ok) {
        {
#line 266
        fprintf(stderr, "Error extracting TIFF metadata!\n\220");
#line 267
        MetadataFree(metadata);
#line 268
        WebPPictureFree(pic);
        }
      }
    }
  }
  End: 
  {
#line 273
  TIFFClose(tif);
  }
#line 274
  return (ok);
}
}
#line 29 "/root/patron-new/new_3/imageio/./pnmdec.h"
int ReadPNM(uint8_t *data , size_t data_size , WebPPicture *pic , int keep_alpha ,
            struct Metadata *metadata ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
#line 207 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp___2 ;

  {
#line 209
  if (__c >= -128) {
#line 209
    if (__c < 256) {
      {
#line 209
      __cil_tmp2 = __ctype_tolower_loc();
#line 209
      tmp___2 = *(*__cil_tmp2 + __c);
      }
    } else {
#line 209
      tmp___2 = __c;
    }
  } else {
#line 209
    tmp___2 = __c;
  }
#line 209
  return (tmp___2);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
#line 213 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp___2 ;

  {
#line 215
  if (__c >= -128) {
#line 215
    if (__c < 256) {
      {
#line 215
      __cil_tmp2 = __ctype_toupper_loc();
#line 215
      tmp___2 = *(*__cil_tmp2 + __c);
      }
    } else {
#line 215
      tmp___2 = __c;
    }
  } else {
#line 215
    tmp___2 = __c;
  }
#line 215
  return (tmp___2);
}
}
#line 47 "/root/patron-new/new_3/imageio/pnmdec.c"
static size_t kMinPNMHeaderSize  =    (size_t )3;
#line 49 "/root/patron-new/new_3/imageio/pnmdec.c"
static size_t ReadLine(uint8_t *data , size_t off , size_t data_size , char *out ,
                       size_t *out_size ) 
{ 
  size_t i ;
  size_t __cil_tmp7 ;

  {
#line 51
  i = (size_t )0;
#line 52
  *out_size = (size_t )0;
  redo: 
#line 54
  i = (size_t )0;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;

#line 54
    if (i < 1024UL) {
#line 54
      if (! (off < data_size)) {
#line 54
        goto while_break;
      }
    } else {
#line 54
      goto while_break;
    }
#line 55
    __cil_tmp7 = off;
#line 55
    off ++;
#line 55
    *(out + i) = (char )*(data + __cil_tmp7);
#line 56
    if ((int )*(out + i) == 10) {
#line 56
      goto while_break;
    }
#line 54
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 58
  if (off < data_size) {
#line 59
    if (i == 0UL) {
#line 59
      goto redo;
    }
#line 60
    if ((int )*(out + 0) == 35) {
#line 60
      goto redo;
    }
  }
#line 62
  *(out + i) = (char)0;
#line 63
  *out_size = i;
#line 64
  return (off);
}
}
#line 67 "/root/patron-new/new_3/imageio/pnmdec.c"
static size_t FlagError(char const   *flag ) 
{ 


  {
  {
#line 68
  fprintf(stderr, "PAM header error: flags \'%s\' already seen.\n", flag);
  }
#line 69
  return ((size_t )0);
}
}
#line 93 "/root/patron-new/new_3/imageio/pnmdec.c"
static char const   kEllipsis[5]  ;
#line 73 "/root/patron-new/new_3/imageio/pnmdec.c"
static size_t ReadPAMFields(PNMInfo *info , size_t off ) 
{ 
  char out[1025] ;
  size_t out_size ;
  int tmp___2 ;
  int expected_depth ;
  int __cil_tmp8 ;
  size_t __cil_tmp9 ;
  int __cil_tmp10 ;
  size_t __cil_tmp11 ;
  int __cil_tmp12 ;
  size_t __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int i ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned short const   **__cil_tmp25 ;
  char const   *tmp___76 ;
  char const   *tmp___77 ;
  char const   *tmp___78 ;
  char const   *tmp___79 ;

  {
#line 77
  expected_depth = -1;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    off = ReadLine(info->data, off, info->data_size, (char *)(out), & out_size);
    }
#line 81
    if (off == 0UL) {
#line 81
      return ((size_t )0);
    }
    {
#line 82
    __cil_tmp8 = sscanf((char const   *)(out), "WIDTH %d\230\001", & tmp___2);
    }
#line 82
    if (__cil_tmp8 == 1) {
#line 83
      if (info->seen_flags & 1) {
        {
#line 83
        __cil_tmp9 = FlagError("WIDTH");
        }
#line 83
        return (__cil_tmp9);
      }
#line 84
      info->seen_flags |= 1;
#line 85
      info->width = tmp___2;
    } else {
      {
#line 86
      __cil_tmp10 = sscanf((char const   *)(out), "HEIGHT %d", & tmp___2);
      }
#line 86
      if (__cil_tmp10 == 1) {
#line 87
        if (info->seen_flags & 2) {
          {
#line 87
          __cil_tmp11 = FlagError("HEIGHT");
          }
#line 87
          return (__cil_tmp11);
        }
#line 88
        info->seen_flags |= 2;
#line 89
        info->height = tmp___2;
      } else {
        {
#line 90
        __cil_tmp12 = sscanf((char const   *)(out), "DEPTH %d\230\001", & tmp___2);
        }
#line 90
        if (__cil_tmp12 == 1) {
#line 91
          if (info->seen_flags & 4) {
            {
#line 91
            __cil_tmp13 = FlagError("DEPTH");
            }
#line 91
            return (__cil_tmp13);
          }
#line 92
          info->seen_flags |= 4;
#line 93
          info->depth = tmp___2;
        } else {
          {
#line 94
          __cil_tmp14 = sscanf((char const   *)(out), "MAXVAL %d", & tmp___2);
          }
#line 94
          if (__cil_tmp14 == 1) {
#line 95
            if (info->seen_flags & 8) {
              {
#line 95
              __cil_tmp15 = FlagError("MAXVAL");
              }
#line 95
              return (__cil_tmp15);
            }
#line 96
            info->seen_flags |= 8;
#line 97
            info->max_value = tmp___2;
          } else {
            {
#line 98
            __cil_tmp16 = strcmp((char const   *)(out), "TUPLTYPE RGB_ALPHA");
            }
#line 98
            if (! __cil_tmp16) {
#line 99
              expected_depth = 4;
#line 100
              info->seen_flags |= 16;
            } else {
              {
#line 101
              __cil_tmp17 = strcmp((char const   *)(out), "TUPLTYPE RGB");
              }
#line 101
              if (! __cil_tmp17) {
#line 102
                expected_depth = 3;
#line 103
                info->seen_flags |= 16;
              } else {
                {
#line 104
                __cil_tmp18 = strcmp((char const   *)(out), "TUPLTYPE GRAYSCALE_ALPHA\220");
                }
#line 104
                if (! __cil_tmp18) {
#line 105
                  expected_depth = 2;
#line 106
                  info->seen_flags |= 16;
                } else {
                  {
#line 107
                  __cil_tmp19 = strcmp((char const   *)(out), "TUPLTYPE GRAYSCALE");
                  }
#line 107
                  if (! __cil_tmp19) {
#line 108
                    expected_depth = 1;
#line 109
                    info->seen_flags |= 16;
                  } else {
                    {
#line 110
                    __cil_tmp20 = strcmp((char const   *)(out), "ENDHDR");
                    }
#line 110
                    if (! __cil_tmp20) {
#line 111
                      goto while_break;
                    } else {
                      {
#line 113
                      strcpy((char *)(kEllipsis), " ...");
                      }
#line 115
                      if (out_size > 20UL) {
                        {
#line 115
                        __cil_tmp23 = strlen(kEllipsis);
#line 115
                        sprintf((out + 20) - __cil_tmp23, kEllipsis);
                        }
                      }
#line 116
                      i = 0;
                      {
#line 116
                      while (1) {
                        while_continue___0: /* CIL Label */ ;

#line 116
                        if (! (i < (int )__cil_tmp24)) {
#line 116
                          goto while_break___0;
                        }
                        {
#line 118
                        __cil_tmp25 = __ctype_b_loc();
                        }
#line 118
                        if (! ((int )*(*__cil_tmp25 + (int )out[i]) & 16384)) {
#line 118
                          out[i] = (char )' ';
                        }
#line 116
                        i ++;
                      }
                      while_break___2: /* CIL Label */ ;
                      }
                      while_break___0: 
                      {
#line 120
                      fprintf(stderr, "PAM header error: unrecognized entry [%s]\n",
                              out);
                      }
#line 121
                      return ((size_t )0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 124
  if (! (info->seen_flags & 15)) {
#line 125
    if (info->seen_flags & 1) {
      {
#line 125
      strcpy((char *)tmp___76, "\323\001 ");
      }
    } else {
      {
#line 125
      strcpy((char *)tmp___76, " WIDTH");
      }
    }
#line 125
    if (info->seen_flags & 2) {
      {
#line 125
      strcpy((char *)tmp___77, "\323\001 ");
      }
    } else {
      {
#line 125
      strcpy((char *)tmp___77, " HEIGHT");
      }
    }
#line 125
    if (info->seen_flags & 4) {
      {
#line 125
      strcpy((char *)tmp___78, "\323\001 ");
      }
    } else {
      {
#line 125
      strcpy((char *)tmp___78, " DEPTH");
      }
    }
#line 125
    if (info->seen_flags & 8) {
      {
#line 125
      strcpy((char *)tmp___79, "\323\001 ");
      }
    } else {
      {
#line 125
      strcpy((char *)tmp___79, " MAXVAL");
      }
    }
    {
#line 125
    fprintf(stderr, "PAM header error: missing tags%s%s%s%s\n", tmp___76, tmp___77,
            tmp___78, tmp___79);
    }
#line 130
    return ((size_t )0);
  }
#line 132
  if (expected_depth != -1) {
#line 132
    if (info->depth != expected_depth) {
      {
#line 133
      fprintf(stderr, "PAM header error: expected DEPTH %d but got DEPTH %d\n", expected_depth,
              info->depth);
      }
#line 135
      return ((size_t )0);
    }
  }
#line 137
  return (off);
}
}
#line 140 "/root/patron-new/new_3/imageio/pnmdec.c"
static size_t ReadHeader___0(PNMInfo *info ) 
{ 
  size_t off ;
  char out[1025] ;
  size_t out_size ;
  int __cil_tmp6 ;
  int __cil_tmp9 ;
  int __cil_tmp11 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 141
  off = (size_t )0;
#line 144
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 144
    return ((size_t )0);
  }
#line 145
  if ((unsigned long )info->data == (unsigned long )((void *)0)) {
#line 145
    return ((size_t )0);
  } else
#line 145
  if (info->data_size < kMinPNMHeaderSize) {
#line 145
    return ((size_t )0);
  }
  {
#line 147
  info->height = 0;
#line 147
  info->width = info->height;
#line 148
  info->type = -1;
#line 149
  info->seen_flags = 0;
#line 150
  info->bytes_per_px = 0;
#line 151
  info->depth = 0;
#line 152
  info->max_value = 0;
#line 154
  off = ReadLine(info->data, off, info->data_size, (char *)(out), & out_size);
#line 155
  __cil_tmp6 = sscanf((char const   *)(out), "P%d+\001V", & info->type);
  }
#line 155
  if (off == 0UL) {
#line 155
    return ((size_t )0);
  } else
#line 155
  if (__cil_tmp6 != 1) {
#line 155
    return ((size_t )0);
  }
#line 156
  if (info->type == 7) {
    {
#line 157
    off = ReadPAMFields(info, off);
    }
  } else {
    {
#line 159
    off = ReadLine(info->data, off, info->data_size, (char *)(out), & out_size);
#line 160
    __cil_tmp9 = sscanf((char const   *)(out), "%d %d", & info->width, & info->height);
    }
#line 160
    if (off == 0UL) {
#line 161
      return ((size_t )0);
    } else
#line 160
    if (__cil_tmp9 != 2) {
#line 161
      return ((size_t )0);
    }
    {
#line 163
    off = ReadLine(info->data, off, info->data_size, (char *)(out), & out_size);
#line 164
    __cil_tmp11 = sscanf((char const   *)(out), "%d\330+\001V", & info->max_value);
    }
#line 164
    if (off == 0UL) {
#line 164
      return ((size_t )0);
    } else
#line 164
    if (__cil_tmp11 != 1) {
#line 164
      return ((size_t )0);
    }
#line 167
    if (info->type == 5) {
#line 167
      tmp___2 = 1;
    } else {
#line 167
      tmp___2 = 3;
    }
#line 167
    info->depth = tmp___2;
  }
#line 170
  if (info->width <= 0) {
#line 174
    return ((size_t )0);
  } else
#line 170
  if (info->height <= 0) {
#line 174
    return ((size_t )0);
  } else
#line 170
  if (info->type <= 0) {
#line 174
    return ((size_t )0);
  } else
#line 170
  if (info->type >= 9) {
#line 174
    return ((size_t )0);
  } else
#line 170
  if (info->depth <= 0) {
#line 174
    return ((size_t )0);
  } else
#line 170
  if (info->depth > 4) {
#line 174
    return ((size_t )0);
  } else
#line 170
  if (info->max_value <= 0) {
#line 174
    return ((size_t )0);
  } else
#line 170
  if (info->max_value >= 65536) {
#line 174
    return ((size_t )0);
  }
#line 176
  if (info->max_value > 255) {
#line 176
    tmp___3 = 2;
  } else {
#line 176
    tmp___3 = 1;
  }
#line 176
  info->bytes_per_px = info->depth * tmp___3;
#line 177
  return (off);
}
}
#line 180 "/root/patron-new/new_3/imageio/pnmdec.c"
int ReadPNM(uint8_t *data , size_t data_size , WebPPicture *pic , int keep_alpha ,
            struct Metadata *metadata ) 
{ 
  int ok ;
  int i ;
  int j ;
  uint64_t stride ;
  uint64_t pixel_bytes ;
  uint64_t sample_size ;
  uint64_t depth ;
  uint8_t *rgb ;
  uint8_t *tmp_rgb ;
  size_t offset ;
  PNMInfo info ;
  int tmp___2 ;
  int tmp___3 ;
  int __cil_tmp20 ;
  void *__cil_tmp21 ;
  uint8_t *in ;
  uint32_t round___0 ;
  int k ;
  uint32_t v ;
  unsigned int tmp___4 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int tmp___5 ;

  {
  {
#line 183
  ok = 0;
#line 186
  rgb = (uint8_t *)((void *)0);
#line 190
  info.data = data;
#line 191
  info.data_size = data_size;
#line 192
  offset = ReadHeader___0(& info);
  }
#line 193
  if (offset == 0UL) {
    {
#line 194
    fprintf(stderr, "Error parsing PNM header.\n\330+\001V");
    }
#line 195
    goto End;
  }
#line 198
  if (info.type < 5) {
    {
#line 199
    fprintf(stderr, "Unsupported P%d PNM format.\n\001V", info.type);
    }
#line 200
    goto End;
  } else
#line 198
  if (info.type > 7) {
    {
#line 199
    fprintf(stderr, "Unsupported P%d PNM format.\n\001V", info.type);
    }
#line 200
    goto End;
  }
#line 204
  if ((unsigned long )pic == (unsigned long )((void *)0)) {
#line 204
    goto End;
  }
#line 205
  if (info.width > 16383) {
    {
#line 206
    fprintf(stderr, "Invalid %dx%d dimension for PNM\n\230\001", info.width, info.height);
    }
#line 208
    goto End;
  } else
#line 205
  if (info.height > 16383) {
    {
#line 206
    fprintf(stderr, "Invalid %dx%d dimension for PNM\n\230\001", info.width, info.height);
    }
#line 208
    goto End;
  }
#line 211
  pixel_bytes = ((uint64_t )info.width * (unsigned long )info.height) * (unsigned long )info.bytes_per_px;
#line 212
  if (data_size < offset + pixel_bytes) {
    {
#line 213
    fprintf(stderr, "Truncated PNM file (P%d).\n", info.type);
    }
#line 214
    goto End;
  }
#line 216
  if (info.max_value > 255) {
#line 216
    tmp___2 = 2;
  } else {
#line 216
    tmp___2 = 1;
  }
#line 216
  sample_size = (uint64_t )tmp___2;
#line 218
  if (info.depth == 1) {
#line 218
    tmp___3 = 3;
  } else
#line 218
  if (info.depth == 3) {
#line 218
    tmp___3 = 3;
  } else
#line 218
  if (! keep_alpha) {
#line 218
    tmp___3 = 3;
  } else {
#line 218
    tmp___3 = 4;
  }
  {
#line 218
  depth = (uint64_t )tmp___3;
#line 219
  stride = depth * (unsigned long )info.width;
#line 220
  __cil_tmp20 = ImgIoUtilCheckSizeArgumentsOverflow(stride, (size_t )info.height);
  }
#line 220
  if (stride != stride) {
#line 222
    goto End;
  } else
#line 220
  if (! __cil_tmp20) {
#line 222
    goto End;
  }
  {
#line 225
  __cil_tmp21 = malloc(stride * (unsigned long )info.height);
#line 225
  rgb = (uint8_t *)__cil_tmp21;
  }
#line 226
  if ((unsigned long )rgb == (unsigned long )((void *)0)) {
#line 226
    goto End;
  }
#line 230
  tmp_rgb = rgb;
#line 231
  j = 0;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;

#line 231
    if (! (j < info.height)) {
#line 231
      goto while_break;
    }
#line 232
    in = data + offset;
#line 233
    offset += (unsigned long )(info.bytes_per_px * info.width);
#line 235
    if (info.max_value == 255) {
#line 235
      if (info.depth >= 3) {
#line 237
        if (info.depth == 3) {
          {
#line 238
          memcpy((void *)tmp_rgb, (void const   *)in, (unsigned long )(info.depth * info.width) * sizeof(*in));
          }
        } else
#line 237
        if (keep_alpha) {
          {
#line 238
          memcpy((void *)tmp_rgb, (void const   *)in, (unsigned long )(info.depth * info.width) * sizeof(*in));
          }
        } else {
#line 241
          i = 0;
          {
#line 241
          while (1) {
            while_continue___0: /* CIL Label */ ;

#line 241
            if (! (i < info.width)) {
#line 241
              goto while_break___0;
            }
#line 242
            *(tmp_rgb + 3 * i) = *(in + 4 * i);
#line 243
            *(tmp_rgb + (3 * i + 1)) = *(in + (4 * i + 1));
#line 244
            *(tmp_rgb + (3 * i + 2)) = *(in + (4 * i + 2));
#line 241
            i ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          while_break___0: ;
        }
      } else {
#line 235
        goto _L;
      }
    } else {
      _L: 
#line 252
      round___0 = (uint32_t )(info.max_value / 2);
#line 253
      k = 0;
#line 254
      i = 0;
      {
#line 254
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 254
        if (! (i < info.width * info.depth)) {
#line 254
          goto while_break___1;
        }
#line 255
        if (sample_size == 2UL) {
#line 255
          tmp___4 = 256U * (unsigned int )*(in + 2 * i) + (unsigned int )*(in + (2 * i + 1));
        } else {
#line 255
          tmp___4 = (unsigned int )*(in + i);
        }
#line 255
        v = tmp___4;
#line 257
        if (info.max_value != 255) {
#line 257
          v = (v * 255U + round___0) / (unsigned int )info.max_value;
        }
#line 258
        if (v > 255U) {
#line 258
          v = 255U;
        }
#line 259
        if (info.depth > 2) {
#line 260
          if (! keep_alpha) {
#line 260
            if (info.depth == 4) {
#line 260
              if (! (i % 4 == 3)) {
#line 263
                *(tmp_rgb + k) = (uint8_t )v;
#line 264
                k ++;
              }
            } else {
#line 263
              *(tmp_rgb + k) = (uint8_t )v;
#line 264
              k ++;
            }
          } else {
#line 263
            *(tmp_rgb + k) = (uint8_t )v;
#line 264
            k ++;
          }
        } else
#line 266
        if (info.depth == 1) {
#line 267
          *(tmp_rgb + (k + 2)) = (uint8_t )v;
#line 267
          *(tmp_rgb + (k + 1)) = *(tmp_rgb + (k + 2));
#line 267
          *(tmp_rgb + k) = *(tmp_rgb + (k + 1));
#line 268
          k += 3;
        } else
#line 266
        if (i % 2 == 0) {
#line 267
          *(tmp_rgb + (k + 2)) = (uint8_t )v;
#line 267
          *(tmp_rgb + (k + 1)) = *(tmp_rgb + (k + 2));
#line 267
          *(tmp_rgb + k) = *(tmp_rgb + (k + 1));
#line 268
          k += 3;
        } else
#line 269
        if (keep_alpha) {
#line 269
          if (info.depth == 2) {
#line 270
            *(tmp_rgb + k) = (uint8_t )v;
#line 271
            k ++;
          }
        }
#line 254
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
    }
#line 277
    tmp_rgb += stride;
#line 231
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 281
  pic->width = info.width;
#line 282
  pic->height = info.height;
#line 283
  if (depth == 4UL) {
    {
#line 283
    __cil_tmp27 = WebPPictureImportRGBA(pic, rgb, (int )stride);
#line 283
    tmp___5 = __cil_tmp27;
    }
  } else {
    {
#line 283
    __cil_tmp28 = WebPPictureImportRGB(pic, rgb, (int )stride);
#line 283
    tmp___5 = __cil_tmp28;
    }
  }
#line 283
  ok = tmp___5;
#line 285
  if (! ok) {
#line 285
    goto End;
  }
#line 287
  ok = 1;
  End: 
  {
#line 289
  free((void *)rgb);
  }
#line 293
  return (ok);
}
}
#line 29 "/root/patron-new/new_3/imageio/./pngdec.h"
int ReadPNG(uint8_t *data , size_t data_size , struct WebPPicture *pic , int keep_alpha ,
            struct Metadata *metadata ) ;
#line 58 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 67
extern  __attribute__((__nothrow__)) void longjmp(struct __jmp_buf_tag *__env , int __val ) ;
#line 973 "/usr/include/libpng16/png.h"
extern jmp_buf *png_set_longjmp_fn(png_structrp png_ptr , void (*longjmp_fn)(struct __jmp_buf_tag * ,
                                                                             int  ) ,
                                   size_t jmp_buf_size ) ;
#line 996
extern png_structp png_create_read_struct_2(png_const_charp user_png_ver , png_voidp error_ptr ,
                                            void (*error_fn)(png_structp  , png_const_charp  ) ,
                                            void (*warn_fn)(png_structp  , png_const_charp  ) ,
                                            png_voidp mem_ptr , png_voidp (*malloc_fn)(png_structp  ,
                                                                                       png_alloc_size_t  ) ,
                                            void (*free_fn)(png_structp  , png_voidp  ) ) ;
#line 1027
extern png_infop png_create_info_struct(png_const_structrp png_ptr ) ;
#line 1045
extern void png_read_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1075
extern void png_set_expand_gray_1_2_4_to_8(png_structrp png_ptr ) ;
#line 1076
extern void png_set_palette_to_rgb(png_structrp png_ptr ) ;
#line 1077
extern void png_set_tRNS_to_alpha(png_structrp png_ptr ) ;
#line 1094
extern void png_set_gray_to_rgb(png_structrp png_ptr ) ;
#line 1253
extern void png_set_strip_alpha(png_structrp png_ptr ) ;
#line 1285
extern void png_set_packing(png_structrp png_ptr ) ;
#line 1308
extern int png_set_interlace_handling(png_structrp png_ptr ) ;
#line 1344
extern void png_set_strip_16(png_structrp png_ptr ) ;
#line 1373
extern void png_set_gamma(png_structrp png_ptr , double screen_gamma , double override_file_gamma ) ;
#line 1390
extern void png_read_update_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1395
extern void png_read_rows(png_structrp png_ptr , png_bytepp row , png_bytepp display_row ,
                          png_uint_32 num_rows ) ;
#line 1431
extern void png_read_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1439
extern void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                                    png_infopp end_info_ptr_ptr ) ;
#line 1594
extern void png_set_error_fn(png_structrp png_ptr , png_voidp error_ptr , void (*error_fn)(png_structp  ,
                                                                                           png_const_charp  ) ,
                             void (*warning_fn)(png_structp  , png_const_charp  ) ) ;
#line 1614
extern void png_set_read_fn(png_structrp png_ptr , png_voidp io_ptr , void (*read_data_fn)(png_structp  ,
                                                                                           png_bytep  ,
                                                                                           size_t  ) ) ;
#line 1618
extern png_voidp png_get_io_ptr(png_const_structrp png_ptr ) ;
#line 1797
extern void png_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 1861
extern png_uint_32 png_get_valid(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                 png_uint_32 flag ) ;
#line 2017
extern png_uint_32 png_get_gAMA(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                double *file_gamma ) ;
#line 2038
extern png_uint_32 png_get_IHDR(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_uint_32 *width , png_uint_32 *height , int *bit_depth ,
                                int *color_type , int *interlace_method , int *compression_method ,
                                int *filter_method ) ;
#line 2101
extern png_uint_32 png_get_sRGB(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                int *file_srgb_intent ) ;
#line 2113
extern png_uint_32 png_get_iCCP(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_charpp name , int *compression_type , png_bytepp profile ,
                                png_uint_32 *proflen ) ;
#line 2136
extern int png_get_text(png_const_structrp png_ptr , png_inforp info_ptr , png_textp *text_ptr ,
                        int *num_text ) ;
#line 2396
extern void png_set_chunk_malloc_max(png_structrp png_ptr , png_alloc_size_t user_chunk_cache_max ) ;
#line 2398
extern png_alloc_size_t png_get_chunk_malloc_max(png_const_structrp png_ptr ) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                  char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size((void *)__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 42
    __cil_tmp4 = __builtin_object_size((void *)__resolved, 1);
    }
#line 42
    if (__cil_tmp4 < 4096UL) {
      {
#line 43
      __cil_tmp5 = __builtin_object_size((void *)__resolved, 1);
#line 43
      __cil_tmp6 = __realpath_chk_warn(__name, __resolved, __cil_tmp5);
      }
#line 43
      return (__cil_tmp6);
    }
    {
#line 45
    __cil_tmp7 = __builtin_object_size((void *)__resolved, 1);
#line 45
    __cil_tmp8 = __realpath_chk(__name, __resolved, __cil_tmp7);
    }
#line 45
    return (__cil_tmp8);
  }
  {
#line 48
  __cil_tmp9 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp9);
}
}
#line 37 "/root/patron-new/new_3/imageio/pngdec.c"
static void error_function(png_structp png , png_const_charp error ) 
{ 
  jmp_buf *__cil_tmp3 ;

  {
#line 38
  if ((unsigned long )error != (unsigned long )((void *)0)) {
    {
#line 38
    fprintf(stderr, "libpng error: %s\n", error);
    }
  }
  {
#line 39
  __cil_tmp3 = png_set_longjmp_fn(png, & longjmp, sizeof(jmp_buf ));
#line 39
  longjmp((struct __jmp_buf_tag *)(*__cil_tmp3), 1);
  }
#line 41
  return;
}
}
#line 48 "/root/patron-new/new_3/imageio/pngdec.c"
static png_voidp MallocFunc(png_structp png_ptr , LocalPngAllocSize size ) 
{ 
  int __cil_tmp3 ;
  void *__cil_tmp4 ;

  {
#line 50
  if (size != size) {
#line 50
    return ((void *)0);
  }
  {
#line 51
  __cil_tmp3 = ImgIoUtilCheckSizeArgumentsOverflow(size, (size_t )1);
  }
#line 51
  if (! __cil_tmp3) {
#line 51
    return ((void *)0);
  }
  {
#line 52
  __cil_tmp4 = malloc(size);
  }
#line 52
  return (__cil_tmp4);
}
}
#line 55 "/root/patron-new/new_3/imageio/pngdec.c"
static void FreeFunc(png_structp png_ptr , png_voidp ptr ) 
{ 


  {
  {
#line 57
  free(ptr);
  }
#line 59
  return;
}
}
#line 69 "/root/patron-new/new_3/imageio/pngdec.c"
static uint8_t *HexStringToBytes(char const   *hexstring , size_t expected_length ) 
{ 
  char const   *src ;
  size_t actual_length ;
  uint8_t *raw_data ;
  void *__cil_tmp6 ;
  uint8_t *dst ;
  char *end ;
  char val[3] ;
  char const   *__cil_tmp10 ;
  uint8_t *__cil_tmp11 ;
  long __cil_tmp12 ;

  {
  {
#line 71
  src = hexstring;
#line 72
  actual_length = (size_t )0;
#line 73
  __cil_tmp6 = malloc(expected_length);
#line 73
  raw_data = (uint8_t *)__cil_tmp6;
  }
#line 76
  if ((unsigned long )raw_data == (unsigned long )((void *)0)) {
#line 76
    return ((uint8_t *)((void *)0));
  }
#line 78
  dst = raw_data;
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 78
    if (actual_length < expected_length) {
#line 78
      if (! ((int )*src != 0)) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
#line 81
    if ((int )*src == 10) {
#line 81
      goto while_continue;
    }
    {
#line 82
    __cil_tmp10 = src;
#line 82
    src ++;
#line 82
    val[0] = (char )*__cil_tmp10;
#line 83
    val[1] = (char )*src;
#line 84
    val[2] = (char )'\000';
#line 85
    __cil_tmp12 = strtol((char const   *)(val), & end, 16);
#line 85
    __cil_tmp11 = dst;
#line 85
    dst ++;
#line 85
    *__cil_tmp11 = (uint8_t )__cil_tmp12;
    }
#line 86
    if ((unsigned long )end != (unsigned long )(val + 2)) {
#line 86
      goto while_break;
    }
#line 87
    actual_length ++;
#line 78
    src ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 90
  if (actual_length != expected_length) {
    {
#line 91
    free((void *)raw_data);
    }
#line 92
    return ((uint8_t *)((void *)0));
  }
#line 94
  return (raw_data);
}
}
#line 97 "/root/patron-new/new_3/imageio/pngdec.c"
static int ProcessRawProfile(char const   *profile , size_t profile_len , MetadataPayload *payload ) 
{ 
  char const   *src ;
  char *end ;
  int expected_length ;
  char const   *__cil_tmp7 ;
  long __cil_tmp8 ;

  {
#line 99
  src = profile;
#line 103
  if ((unsigned long )profile == (unsigned long )((void *)0)) {
#line 103
    return (0);
  } else
#line 103
  if (profile_len == 0UL) {
#line 103
    return (0);
  }
#line 107
  if ((int )*src != 10) {
    {
#line 108
    fprintf(stderr, "Malformed raw profile, expected \'\\n\' got \'\\x%.2X\'\n", (int )*src);
    }
#line 110
    return (0);
  }
#line 112
  src ++;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    __cil_tmp7 = src;
#line 114
    src ++;
#line 114
    if ((int )*src != 0) {
#line 114
      if (! ((int )*__cil_tmp7 != 10)) {
#line 114
        goto while_break;
      }
    } else {
#line 114
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 115
  __cil_tmp8 = strtol(src, & end, 10);
#line 115
  expected_length = (int )__cil_tmp8;
  }
#line 116
  if ((int )*end != 10) {
    {
#line 117
    fprintf(stderr, "Malformed raw profile, expected \'\\n\' got \'\\x%.2X\'\n", (int )*end);
    }
#line 119
    return (0);
  }
  {
#line 121
  end ++;
#line 124
  payload->bytes = HexStringToBytes((char const   *)end, (size_t )expected_length);
  }
#line 125
  if ((unsigned long )payload->bytes == (unsigned long )((void *)0)) {
#line 125
    return (0);
  }
#line 126
  payload->size = (size_t )expected_length;
#line 127
  return (1);
}
}
#line 135 "/root/patron-new/new_3/imageio/pngdec.c"
static struct __anonstruct_1241 kPNGMetadataMap[5]  = {      {"Raw profile type exif", (int (*)(char const   * , size_t  , MetadataPayload * const   ))(& ProcessRawProfile),
      (size_t )0}, 
        {"Raw profile type xmp", (int (*)(char const   * , size_t  , MetadataPayload * const   ))(& ProcessRawProfile),
      (size_t )0}, 
        {"Raw profile type APP1", (int (*)(char const   * , size_t  , MetadataPayload * const   ))(& ProcessRawProfile),
      (size_t )0}, 
        {"XML:com.adobe.xmp", (int (*)(char const   * , size_t  , MetadataPayload * const   ))(& MetadataCopy),
      (size_t )0}, 
        {(char const   *)((void *)0), (int (*)(char const   * , size_t  , MetadataPayload * const   ))((void *)0),
      (size_t )0}};
#line 151 "/root/patron-new/new_3/imageio/pngdec.c"
static int ExtractMetadataFromPNG(png_structp png , png_infop head_info , png_infop end_info ,
                                  Metadata *metadata ) 
{ 
  int p ;
  png_infop info ;
  png_infop tmp___2 ;
  png_textp text ;
  png_uint_32 num ;
  int __cil_tmp10 ;
  png_uint_32 i ;
  int j ;
  int __cil_tmp13 ;
  MetadataPayload *payload ;
  png_size_t text_length ;
  int __cil_tmp16 ;
  png_charp name ;
  int comp_type ;
  png_bytep profile ;
  png_uint_32 len ;
  png_uint_32 __cil_tmp21 ;
  int __cil_tmp22 ;

  {
#line 157
  p = 0;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;

#line 157
    if (! (p < 2)) {
#line 157
      goto while_break;
    }
#line 158
    if (p == 0) {
#line 158
      tmp___2 = head_info;
    } else {
#line 158
      tmp___2 = end_info;
    }
    {
#line 158
    info = tmp___2;
#line 159
    text = (png_textp )((void *)0);
#line 160
    __cil_tmp10 = png_get_text(png, info, & text, (int *)((void *)0));
#line 160
    num = (png_uint_32 )__cil_tmp10;
#line 163
    i = (png_uint_32 )0;
    }
    {
#line 163
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 163
      if (! (i < num)) {
#line 163
        goto while_break___0;
      }
#line 165
      j = 0;
      {
#line 165
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 165
        if (! ((unsigned long )kPNGMetadataMap[j].name != (unsigned long )((void *)0))) {
#line 165
          goto while_break___1;
        }
        {
#line 166
        __cil_tmp13 = strcmp((char const   *)text->key, kPNGMetadataMap[j].name);
        }
#line 166
        if (! __cil_tmp13) {
#line 167
          payload = (MetadataPayload *)((uint8_t *)metadata + kPNGMetadataMap[j].storage_offset);
#line 174
          if (text->compression == 2) {
#line 174
            goto case_2;
          }
#line 174
          if (text->compression == 1) {
#line 174
            goto case_2;
          }
#line 180
          goto switch_default;
          case_2: 
#line 175
          text_length = text->itxt_length;
#line 176
          goto switch_break;
          switch_default: 
#line 181
          text_length = text->text_length;
#line 182
          goto switch_break;
          switch_break: ;
#line 184
          if ((unsigned long )payload->bytes != (unsigned long )((void *)0)) {
            {
#line 185
            fprintf(stderr, "Ignoring additional \'%s\'\n", text->key);
            }
          } else {
            {
#line 186
            __cil_tmp16 = (*(kPNGMetadataMap[j].process))((char const   *)text->text,
                                                          text_length, (MetadataPayload */* const  */)payload);
            }
#line 186
            if (! __cil_tmp16) {
              {
#line 188
              fprintf(stderr, "Failed to process: \'%s\'\n\230\001", text->key);
              }
#line 189
              return (0);
            }
          }
#line 191
          goto while_break___1;
        }
#line 165
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 163
      text ++;
#line 163
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 206
    __cil_tmp21 = png_get_iCCP(png, info, & name, & comp_type, & profile, & len);
    }
#line 206
    if (__cil_tmp21 == 4096U) {
      {
#line 208
      __cil_tmp22 = MetadataCopy((char const   *)profile, (size_t )len, & metadata->iccp);
      }
#line 208
      if (! __cil_tmp22) {
#line 208
        return (0);
      }
    }
#line 157
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 212
  return (1);
}
}
#line 221 "/root/patron-new/new_3/imageio/pngdec.c"
static void ReadFunc(png_structp png_ptr , png_bytep data , png_size_t length ) 
{ 
  PNGReadContext *ctx ;
  png_voidp __cil_tmp5 ;

  {
  {
#line 222
  __cil_tmp5 = png_get_io_ptr(png_ptr);
#line 222
  ctx = (PNGReadContext *)__cil_tmp5;
  }
#line 223
  if (ctx->data_size - ctx->offset < length) {
    {
#line 224
    png_error(png_ptr, "ReadFunc: invalid read length (overflow)!");
    }
  }
  {
#line 226
  memcpy((void *)data, (void const   *)(ctx->data + ctx->offset), length);
#line 227
  ctx->offset += length;
  }
#line 229
  return;
}
}
#line 230 "/root/patron-new/new_3/imageio/pngdec.c"
int ReadPNG(uint8_t *data , size_t data_size , struct WebPPicture *pic , int keep_alpha ,
            struct Metadata *metadata ) 
{ 
  png_structp png ;
  png_infop info ;
  png_infop end_info ;
  PNGReadContext context ;
  int color_type ;
  int bit_depth ;
  int interlaced ;
  int has_alpha ;
  int num_passes ;
  int p ;
  int ok ;
  png_uint_32 width ;
  png_uint_32 height ;
  png_uint_32 y ;
  int64_t stride ;
  uint8_t *rgb ;
  jmp_buf *__cil_tmp23 ;
  int __cil_tmp24 ;
  png_alloc_size_t __cil_tmp25 ;
  png_uint_32 __cil_tmp28 ;
  png_uint_32 __cil_tmp29 ;
  double image_gamma ;
  double screen_gamma ;
  int srgb_intent ;
  png_uint_32 __cil_tmp33 ;
  png_uint_32 __cil_tmp34 ;
  int tmp___2 ;
  int __cil_tmp37 ;
  void *__cil_tmp38 ;
  png_bytep row ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int tmp___3 ;

  {
#line 233
  png = (png_structp )((void *)0);
#line 234
  info = (png_infop )((void *)0);
#line 235
  end_info = (png_infop )((void *)0);
#line 236
  context.data = (uint8_t *)((void *)0);
#line 236
  context.data_size = (size_t )0;
#line 236
  context.offset = (png_size_t )0;
#line 241
  ok = 0;
#line 244
  rgb = (uint8_t *)((void *)0);
#line 246
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 246
    return (0);
  } else
#line 246
  if (data_size == 0UL) {
#line 246
    return (0);
  } else
#line 246
  if ((unsigned long )pic == (unsigned long )((void *)0)) {
#line 246
    return (0);
  }
  {
#line 248
  context.data = data;
#line 249
  context.data_size = data_size;
#line 251
  png = png_create_read_struct_2("1.6.37", (void *)0, (void (*)(png_structp  , png_const_charp  ))((void *)0),
                                 (void (*)(png_structp  , png_const_charp  ))((void *)0),
                                 (void *)0, & MallocFunc, & FreeFunc);
  }
#line 253
  if ((unsigned long )png == (unsigned long )((void *)0)) {
#line 253
    goto End;
  }
  {
#line 255
  png_set_error_fn(png, (png_voidp )0, & error_function, (void (*)(png_structp  ,
                                                                   png_const_charp  ))((void *)0));
#line 256
  __cil_tmp23 = png_set_longjmp_fn(png, & longjmp, sizeof(jmp_buf ));
#line 256
  __cil_tmp24 = _setjmp((struct __jmp_buf_tag *)(*__cil_tmp23));
  }
#line 256
  if (__cil_tmp24) {
    Error: 
    {
#line 258
    MetadataFree(metadata);
    }
#line 259
    goto End;
  }
  {
#line 266
  __cil_tmp25 = png_get_chunk_malloc_max(png);
  }
#line 266
  if (data_size > __cil_tmp25) {
#line 266
    if (data_size < (unsigned long )(1U << 24)) {
      {
#line 267
      png_set_chunk_malloc_max(png, data_size);
      }
    }
  }
  {
#line 271
  info = png_create_info_struct(png);
  }
#line 272
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 272
    goto Error;
  }
  {
#line 273
  end_info = png_create_info_struct(png);
  }
#line 274
  if ((unsigned long )end_info == (unsigned long )((void *)0)) {
#line 274
    goto Error;
  }
  {
#line 276
  png_set_read_fn(png, (png_voidp )(& context), & ReadFunc);
#line 277
  png_read_info(png, info);
#line 278
  __cil_tmp28 = png_get_IHDR(png, info, & width, & height, & bit_depth, & color_type,
                             & interlaced, (int *)((void *)0), (int *)((void *)0));
  }
#line 278
  if (! __cil_tmp28) {
#line 280
    goto Error;
  }
  {
#line 282
  png_set_strip_16(png);
#line 283
  png_set_packing(png);
  }
#line 284
  if (color_type == 3) {
    {
#line 285
    png_set_palette_to_rgb(png);
    }
  }
#line 287
  if (color_type == 0) {
    _L: 
#line 289
    if (bit_depth < 8) {
      {
#line 290
      png_set_expand_gray_1_2_4_to_8(png);
      }
    }
    {
#line 292
    png_set_gray_to_rgb(png);
    }
  } else
#line 287
  if (color_type == 4) {
#line 287
    goto _L;
  }
  {
#line 294
  __cil_tmp29 = png_get_valid(png, info, 16U);
  }
#line 294
  if (__cil_tmp29) {
    {
#line 295
    png_set_tRNS_to_alpha(png);
#line 296
    has_alpha = 1;
    }
  } else {
#line 298
    has_alpha = ! (! (color_type & 4));
  }
  {
#line 303
  image_gamma = (double )1 / 2.20000000001;
#line 303
  screen_gamma = 2.20000000001;
#line 305
  __cil_tmp34 = png_get_gAMA(png, info, & image_gamma);
#line 305
  __cil_tmp33 = png_get_sRGB(png, info, & srgb_intent);
  }
#line 305
  if (__cil_tmp33) {
    {
#line 307
    png_set_gamma(png, screen_gamma, image_gamma);
    }
  } else
#line 305
  if (__cil_tmp34) {
    {
#line 307
    png_set_gamma(png, screen_gamma, image_gamma);
    }
  }
#line 311
  if (! keep_alpha) {
    {
#line 312
    png_set_strip_alpha(png);
#line 313
    has_alpha = 0;
    }
  }
  {
#line 316
  num_passes = png_set_interlace_handling(png);
#line 317
  png_read_update_info(png, info);
  }
#line 319
  if (has_alpha) {
#line 319
    tmp___2 = 4;
  } else {
#line 319
    tmp___2 = 3;
  }
  {
#line 319
  stride = (int64_t )((unsigned long )((int64_t )tmp___2 * (long )width) * sizeof(*rgb));
#line 320
  __cil_tmp37 = ImgIoUtilCheckSizeArgumentsOverflow((uint64_t )stride, (size_t )height);
  }
#line 320
  if (stride != (long )((int )stride)) {
#line 322
    goto Error;
  } else
#line 320
  if (! __cil_tmp37) {
#line 322
    goto Error;
  }
  {
#line 325
  __cil_tmp38 = malloc((size_t )stride * (unsigned long )height);
#line 325
  rgb = (uint8_t *)__cil_tmp38;
  }
#line 326
  if ((unsigned long )rgb == (unsigned long )((void *)0)) {
#line 326
    goto Error;
  }
#line 327
  p = 0;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;

#line 327
    if (! (p < num_passes)) {
#line 327
      goto while_break;
    }
#line 328
    row = rgb;
#line 329
    y = (png_uint_32 )0;
    {
#line 329
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 329
      if (! (y < height)) {
#line 329
        goto while_break___0;
      }
      {
#line 330
      png_read_rows(png, & row, (png_bytepp )((void *)0), (png_uint_32 )1);
#line 331
      row += stride;
#line 329
      y ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 327
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 334
  png_read_end(png, end_info);
#line 336
  __cil_tmp40 = ExtractMetadataFromPNG(png, info, end_info, metadata);
  }
#line 336
  if ((unsigned long )metadata != (unsigned long )((void *)0)) {
#line 336
    if (! __cil_tmp40) {
      {
#line 338
      fprintf(stderr, "Error extracting PNG metadata!\n");
      }
#line 339
      goto Error;
    }
  }
#line 342
  pic->width = (int )width;
#line 343
  pic->height = (int )height;
#line 344
  if (has_alpha) {
    {
#line 344
    __cil_tmp41 = WebPPictureImportRGBA(pic, rgb, (int )stride);
#line 344
    tmp___3 = __cil_tmp41;
    }
  } else {
    {
#line 344
    __cil_tmp42 = WebPPictureImportRGB(pic, rgb, (int )stride);
#line 344
    tmp___3 = __cil_tmp42;
    }
  }
#line 344
  ok = tmp___3;
#line 347
  if (! ok) {
#line 348
    goto Error;
  }
  End: 
#line 352
  if ((unsigned long )png != (unsigned long )((void *)0)) {
    {
#line 353
    png_destroy_read_struct(& png, & info, & end_info);
    }
  }
  {
#line 356
  free((void *)rgb);
  }
#line 357
  return (ok);
}
}
#line 20 "/root/patron-new/new_3/imageio/metadata.c"
void MetadataInit(Metadata *metadata ) 
{ 


  {
#line 21
  if ((unsigned long )metadata == (unsigned long )((void *)0)) {
#line 21
    return;
  }
  {
#line 22
  memset((void *)metadata, 0, sizeof(*metadata));
  }
#line 24
  return;
}
}
#line 25 "/root/patron-new/new_3/imageio/metadata.c"
void MetadataPayloadDelete(MetadataPayload *payload ) 
{ 


  {
#line 26
  if ((unsigned long )payload == (unsigned long )((void *)0)) {
#line 26
    return;
  }
  {
#line 27
  free((void *)payload->bytes);
#line 28
  payload->bytes = (uint8_t *)((void *)0);
#line 29
  payload->size = (size_t )0;
  }
#line 31
  return;
}
}
#line 32 "/root/patron-new/new_3/imageio/metadata.c"
void MetadataFree(Metadata *metadata ) 
{ 


  {
#line 33
  if ((unsigned long )metadata == (unsigned long )((void *)0)) {
#line 33
    return;
  }
  {
#line 34
  MetadataPayloadDelete(& metadata->exif);
#line 35
  MetadataPayloadDelete(& metadata->iccp);
#line 36
  MetadataPayloadDelete(& metadata->xmp);
  }
#line 38
  return;
}
}
#line 39 "/root/patron-new/new_3/imageio/metadata.c"
int MetadataCopy(char const   *metadata , size_t metadata_len , MetadataPayload *payload ) 
{ 
  void *__cil_tmp4 ;

  {
#line 41
  if ((unsigned long )metadata == (unsigned long )((void *)0)) {
#line 41
    return (0);
  } else
#line 41
  if (metadata_len == 0UL) {
#line 41
    return (0);
  } else
#line 41
  if ((unsigned long )payload == (unsigned long )((void *)0)) {
#line 41
    return (0);
  }
  {
#line 42
  __cil_tmp4 = malloc(metadata_len);
#line 42
  payload->bytes = (uint8_t *)__cil_tmp4;
  }
#line 43
  if ((unsigned long )payload->bytes == (unsigned long )((void *)0)) {
#line 43
    return (0);
  }
  {
#line 44
  payload->size = metadata_len;
#line 45
  memcpy((void *)payload->bytes, (void const   *)metadata, metadata_len);
  }
#line 46
  return (1);
}
}
#line 29 "/root/patron-new/new_3/imageio/./jpegdec.h"
int ReadJPEG(uint8_t *data , size_t data_size , WebPPicture *pic , int keep_alpha ,
             Metadata *metadata ) ;
#line 891 "/usr/include/jpeglib.h"
extern struct jpeg_error_mgr *jpeg_std_error(struct jpeg_error_mgr *err ) ;
#line 908
extern void jpeg_CreateDecompress(j_decompress_ptr cinfo , int version , size_t structsize ) ;
#line 912
extern void jpeg_destroy_decompress(j_decompress_ptr cinfo ) ;
#line 985
extern int jpeg_read_header(j_decompress_ptr cinfo , boolean require_image ) ;
#line 997
extern boolean jpeg_start_decompress(j_decompress_ptr cinfo ) ;
#line 998
extern JDIMENSION jpeg_read_scanlines(j_decompress_ptr cinfo , JSAMPARRAY scanlines ,
                                      JDIMENSION max_lines ) ;
#line 1005
extern boolean jpeg_finish_decompress(j_decompress_ptr cinfo ) ;
#line 1032
extern void jpeg_save_markers(j_decompress_ptr cinfo , int marker_code , unsigned int length_limit ) ;
#line 1063
extern boolean jpeg_resync_to_restart(j_decompress_ptr cinfo , int desired ) ;
#line 47 "/root/patron-new/new_3/imageio/jpegdec.c"
static void SaveMetadataMarkers(j_decompress_ptr dinfo ) 
{ 
  unsigned int max_marker_length ;

  {
  {
#line 48
  max_marker_length = 65535U;
#line 49
  jpeg_save_markers(dinfo, 225, max_marker_length);
#line 50
  jpeg_save_markers(dinfo, 226, max_marker_length);
  }
#line 52
  return;
}
}
#line 53 "/root/patron-new/new_3/imageio/jpegdec.c"
static int CompareICCPSegments(void const   *a , void const   *b ) 
{ 
  ICCPSegment *s1 ;
  ICCPSegment *s2 ;

  {
#line 54
  s1 = (ICCPSegment *)a;
#line 55
  s2 = (ICCPSegment *)b;
#line 56
  return (s1->seq - s2->seq);
}
}
#line 64 "/root/patron-new/new_3/imageio/jpegdec.c"
static char const   kICCPSignature[12]  ;
#line 65 "/root/patron-new/new_3/imageio/jpegdec.c"
static size_t kICCPSignatureLength  ;
#line 66 "/root/patron-new/new_3/imageio/jpegdec.c"
static size_t kICCPSkipLength  ;
#line 62 "/root/patron-new/new_3/imageio/jpegdec.c"
static int StoreICCP(j_decompress_ptr dinfo , MetadataPayload *iccp ) 
{ 
  int expected_count ;
  int actual_count ;
  int seq_max ;
  size_t total_size ;
  ICCPSegment iccp_segments[255] ;
  jpeg_saved_marker_ptr marker ;
  int __cil_tmp12 ;
  int seq ;
  int count ;
  size_t segment_size ;
  ICCPSegment *segment ;
  void *__cil_tmp17 ;
  int i ;
  size_t offset ;

  {
  {
#line 64
  strcpy((char *)(kICCPSignature), "ICC_PROFILE");
#line 65
  kICCPSignatureLength = (size_t )12;
#line 66
  kICCPSkipLength = (size_t )14;
#line 67
  expected_count = 0;
#line 68
  actual_count = 0;
#line 69
  seq_max = 0;
#line 70
  total_size = (size_t )0;
#line 74
  memset((void *)(iccp_segments), 0, sizeof(iccp_segments));
#line 75
  marker = dinfo->marker_list;
  }
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;

#line 75
    if (! ((unsigned long )marker != (unsigned long )((void *)0))) {
#line 75
      goto while_break;
    }
    {
#line 76
    __cil_tmp12 = memcmp((void const   *)marker->data, (void const   *)(kICCPSignature),
                         kICCPSignatureLength);
    }
#line 76
    if ((int )marker->marker == 226) {
#line 76
      if ((unsigned long )marker->data_length > kICCPSkipLength) {
#line 76
        if (! __cil_tmp12) {
#line 80
          seq = (int )*(marker->data + kICCPSignatureLength);
#line 81
          count = (int )*(marker->data + (kICCPSignatureLength + 1UL));
#line 82
          segment_size = (unsigned long )marker->data_length - kICCPSkipLength;
#line 85
          if (segment_size == 0UL) {
            {
#line 86
            fprintf(stderr, "[ICCP] size (%d) / count (%d) / sequence number (%d) cannot be 0!\n",
                    (int )segment_size, seq, count);
            }
#line 89
            return (0);
          } else
#line 85
          if (count == 0) {
            {
#line 86
            fprintf(stderr, "[ICCP] size (%d) / count (%d) / sequence number (%d) cannot be 0!\n",
                    (int )segment_size, seq, count);
            }
#line 89
            return (0);
          } else
#line 85
          if (seq == 0) {
            {
#line 86
            fprintf(stderr, "[ICCP] size (%d) / count (%d) / sequence number (%d) cannot be 0!\n",
                    (int )segment_size, seq, count);
            }
#line 89
            return (0);
          }
#line 92
          if (expected_count == 0) {
#line 93
            expected_count = count;
          } else
#line 94
          if (expected_count != count) {
            {
#line 95
            fprintf(stderr, "[ICCP] Inconsistent segment count (%d / %d)!\n", expected_count,
                    count);
            }
#line 97
            return (0);
          }
#line 100
          segment = (iccp_segments + seq) - 1;
#line 101
          if (segment->data_length != 0UL) {
            {
#line 102
            fprintf(stderr, "[ICCP] Duplicate segment number (%d)!\n", seq);
            }
#line 103
            return (0);
          }
#line 106
          segment->data = marker->data + kICCPSkipLength;
#line 107
          segment->data_length = segment_size;
#line 108
          segment->seq = seq;
#line 109
          total_size += segment_size;
#line 110
          if (seq > seq_max) {
#line 110
            seq_max = seq;
          }
#line 111
          actual_count ++;
        }
      }
    }
#line 75
    marker = marker->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 115
  if (actual_count == 0) {
#line 115
    return (1);
  }
#line 116
  if (seq_max != actual_count) {
    {
#line 117
    fprintf(stderr, "[ICCP] Discontinuous segments, expected: %d actual: %d!\n\230\001",
            actual_count, seq_max);
    }
#line 119
    return (0);
  }
#line 121
  if (expected_count != actual_count) {
    {
#line 122
    fprintf(stderr, "[ICCP] Segment count: %d does not match expected: %d!\n", actual_count,
            expected_count);
    }
#line 124
    return (0);
  }
  {
#line 129
  qsort((void *)(iccp_segments), (size_t )actual_count, sizeof(iccp_segments[0]),
        & CompareICCPSegments);
#line 132
  __cil_tmp17 = malloc(total_size);
#line 132
  iccp->bytes = (uint8_t *)__cil_tmp17;
  }
#line 133
  if ((unsigned long )iccp->bytes == (unsigned long )((void *)0)) {
#line 133
    return (0);
  }
#line 134
  iccp->size = total_size;
#line 138
  offset = (size_t )0;
#line 139
  i = 0;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 139
    if (! (i < seq_max)) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    memcpy((void *)(iccp->bytes + offset), (void const   *)iccp_segments[i].data,
           iccp_segments[i].data_length);
#line 142
    offset += iccp_segments[i].data_length;
#line 139
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 145
  return (1);
}
}
#line 152 "/root/patron-new/new_3/imageio/jpegdec.c"
static struct __anonstruct_1289 kJPEGMetadataMap[3]  ;
#line 150 "/root/patron-new/new_3/imageio/jpegdec.c"
static int ExtractMetadataFromJPEG(j_decompress_ptr dinfo , Metadata *metadata ) 
{ 
  jpeg_saved_marker_ptr marker ;
  int __cil_tmp5 ;
  int i ;
  int __cil_tmp7 ;
  MetadataPayload *payload ;
  char const   *marker_data ;
  size_t marker_data_length ;
  int __cil_tmp11 ;

  {
  {
#line 152
  kJPEGMetadataMap[0].marker = 225;
#line 152
  strcpy((char *)kJPEGMetadataMap[0].signature, "Exif");
#line 152
  kJPEGMetadataMap[0].signature_length = (size_t )6;
#line 152
  kJPEGMetadataMap[0].storage_offset = (size_t )0;
#line 152
  kJPEGMetadataMap[1].marker = 225;
#line 152
  strcpy((char *)kJPEGMetadataMap[1].signature, "http://ns.adobe.com/xap/1.0/");
#line 152
  kJPEGMetadataMap[1].signature_length = (size_t )29;
#line 152
  kJPEGMetadataMap[1].storage_offset = (size_t )0;
#line 152
  kJPEGMetadataMap[2].marker = 0;
#line 152
  kJPEGMetadataMap[2].signature = (char const   *)((void *)0);
#line 152
  kJPEGMetadataMap[2].signature_length = (size_t )0;
#line 152
  kJPEGMetadataMap[2].storage_offset = (size_t )0;
#line 167
  __cil_tmp5 = StoreICCP(dinfo, & metadata->iccp);
  }
#line 167
  if (! __cil_tmp5) {
#line 167
    return (0);
  }
#line 169
  marker = dinfo->marker_list;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;

#line 169
    if (! ((unsigned long )marker != (unsigned long )((void *)0))) {
#line 169
      goto while_break;
    }
#line 171
    i = 0;
    {
#line 171
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 171
      if (! (kJPEGMetadataMap[i].marker != 0)) {
#line 171
        goto while_break___0;
      }
      {
#line 172
      __cil_tmp7 = memcmp((void const   *)marker->data, (void const   *)kJPEGMetadataMap[i].signature,
                          kJPEGMetadataMap[i].signature_length);
      }
#line 172
      if ((int )marker->marker == kJPEGMetadataMap[i].marker) {
#line 172
        if ((unsigned long )marker->data_length > kJPEGMetadataMap[i].signature_length) {
#line 172
          if (! __cil_tmp7) {
#line 176
            payload = (MetadataPayload *)((uint8_t *)metadata + kJPEGMetadataMap[i].storage_offset);
#line 180
            if ((unsigned long )payload->bytes == (unsigned long )((void *)0)) {
              {
#line 181
              marker_data = (char const   *)marker->data + kJPEGMetadataMap[i].signature_length;
#line 183
              marker_data_length = (unsigned long )marker->data_length - kJPEGMetadataMap[i].signature_length;
#line 185
              __cil_tmp11 = MetadataCopy(marker_data, marker_data_length, payload);
              }
#line 185
              if (! __cil_tmp11) {
#line 185
                return (0);
              }
            } else {
              {
#line 187
              fprintf(stderr, "Ignoring additional \'%s\' marker\n\230\001", kJPEGMetadataMap[i].signature);
              }
            }
          }
        }
      }
#line 171
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 169
    marker = marker->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 193
  return (1);
}
}
#line 207 "/root/patron-new/new_3/imageio/jpegdec.c"
static void my_error_exit(j_common_ptr dinfo ) 
{ 
  struct my_error_mgr *myerr ;

  {
  {
#line 208
  myerr = (struct my_error_mgr *)dinfo->err;
#line 209
  fprintf(stderr, "libjpeg error: ");
#line 210
  (*((dinfo->err)->output_message))(dinfo);
#line 211
  longjmp((struct __jmp_buf_tag *)(myerr->setjmp_buffer), 1);
  }
#line 213
  return;
}
}
#line 220 "/root/patron-new/new_3/imageio/jpegdec.c"
static void ContextInit(j_decompress_ptr cinfo ) 
{ 
  JPEGReadContext *ctx ;

  {
#line 221
  ctx = (JPEGReadContext *)cinfo->src;
#line 222
  ctx->pub.next_input_byte = ctx->data;
#line 223
  ctx->pub.bytes_in_buffer = ctx->data_size;
#line 224
  return;
}
}
#line 226 "/root/patron-new/new_3/imageio/jpegdec.c"
static boolean ContextFill(j_decompress_ptr cinfo ) 
{ 


  {
  {
#line 228
  (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
#line 228
  (cinfo->err)->msg_code = 37;
  }
#line 229
  return (0);
}
}
#line 232 "/root/patron-new/new_3/imageio/jpegdec.c"
static void ContextSkip(j_decompress_ptr cinfo , long jump_size ) 
{ 
  JPEGReadContext *ctx ;
  size_t jump ;

  {
#line 233
  ctx = (JPEGReadContext *)cinfo->src;
#line 234
  jump = (size_t )jump_size;
#line 235
  if (jump > ctx->pub.bytes_in_buffer) {
#line 236
    jump = ctx->pub.bytes_in_buffer;
  }
#line 238
  ctx->pub.bytes_in_buffer -= jump;
#line 239
  ctx->pub.next_input_byte += jump;
#line 240
  return;
}
}
#line 242 "/root/patron-new/new_3/imageio/jpegdec.c"
static void ContextTerm(j_decompress_ptr cinfo ) 
{ 


  {
#line 247
  return;
}
}
#line 246 "/root/patron-new/new_3/imageio/jpegdec.c"
static void ContextSetup(struct jpeg_decompress_struct *cinfo , JPEGReadContext *ctx ) 
{ 


  {
#line 248
  cinfo->src = (struct jpeg_source_mgr *)ctx;
#line 249
  ctx->pub.init_source = & ContextInit;
#line 250
  ctx->pub.fill_input_buffer = & ContextFill;
#line 251
  ctx->pub.skip_input_data = & ContextSkip;
#line 252
  ctx->pub.resync_to_restart = & jpeg_resync_to_restart;
#line 253
  ctx->pub.term_source = & ContextTerm;
#line 254
  ctx->pub.bytes_in_buffer = (size_t )0;
#line 255
  ctx->pub.next_input_byte = (JOCTET *)((void *)0);
#line 256
  return;
}
}
#line 258 "/root/patron-new/new_3/imageio/jpegdec.c"
int ReadJPEG(uint8_t *data , size_t data_size , WebPPicture *pic , int keep_alpha ,
             Metadata *metadata ) 
{ 
  int ok ;
  int width ;
  int height ;
  int64_t stride ;
  struct jpeg_decompress_struct dinfo ;
  struct my_error_mgr jerr ;
  uint8_t *rgb ;
  JSAMPROW buffer[1] ;
  JPEGReadContext ctx ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  void *__cil_tmp18 ;
  JDIMENSION __cil_tmp19 ;

  {
#line 261
  ok = 0;
#line 266
  rgb = (uint8_t *)((void *)0);
#line 270
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 270
    return (0);
  } else
#line 270
  if (data_size == 0UL) {
#line 270
    return (0);
  } else
#line 270
  if ((unsigned long )pic == (unsigned long )((void *)0)) {
#line 270
    return (0);
  }
  {
#line 273
  memset((void *)(& ctx), 0, sizeof(ctx));
#line 274
  ctx.data = data;
#line 275
  ctx.data_size = data_size;
#line 277
  memset((void *)(& dinfo), 0, sizeof(dinfo));
#line 278
  dinfo.err = jpeg_std_error(& jerr.pub);
#line 279
  jerr.pub.error_exit = & my_error_exit;
#line 281
  __cil_tmp16 = _setjmp((struct __jmp_buf_tag *)(jerr.setjmp_buffer));
  }
#line 281
  if (__cil_tmp16) {
    Error: 
    {
#line 283
    MetadataFree(metadata);
#line 284
    jpeg_destroy_decompress(& dinfo);
    }
#line 285
    goto End;
  }
  {
#line 288
  jpeg_CreateDecompress(& dinfo, 80, sizeof(struct jpeg_decompress_struct ));
#line 289
  ContextSetup(& dinfo, & ctx);
  }
#line 290
  if ((unsigned long )metadata != (unsigned long )((void *)0)) {
    {
#line 290
    SaveMetadataMarkers(& dinfo);
    }
  }
  {
#line 291
  jpeg_read_header(& dinfo, 1);
#line 293
  dinfo.out_color_space = (J_COLOR_SPACE )2;
#line 294
  dinfo.do_fancy_upsampling = 1;
#line 296
  jpeg_start_decompress(& dinfo);
  }
#line 298
  if (dinfo.output_components != 3) {
#line 299
    goto Error;
  }
  {
#line 302
  width = (int )dinfo.output_width;
#line 303
  height = (int )dinfo.output_height;
#line 304
  stride = (int64_t )((unsigned long )((int64_t )dinfo.output_width * (long )dinfo.output_components) * sizeof(*rgb));
#line 306
  __cil_tmp17 = ImgIoUtilCheckSizeArgumentsOverflow((uint64_t )stride, (size_t )height);
  }
#line 306
  if (stride != (long )((int )stride)) {
#line 308
    goto Error;
  } else
#line 306
  if (! __cil_tmp17) {
#line 308
    goto Error;
  }
  {
#line 311
  __cil_tmp18 = malloc((size_t )stride * (unsigned long )height);
#line 311
  rgb = (uint8_t *)__cil_tmp18;
  }
#line 312
  if ((unsigned long )rgb == (unsigned long )((void *)0)) {
#line 313
    goto Error;
  }
#line 315
  buffer[0] = rgb;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;

#line 317
    if (! (dinfo.output_scanline < dinfo.output_height)) {
#line 317
      goto while_break;
    }
    {
#line 318
    __cil_tmp19 = jpeg_read_scanlines(& dinfo, buffer, (JDIMENSION )1);
    }
#line 318
    if (__cil_tmp19 != 1U) {
#line 319
      goto Error;
    }
#line 321
    buffer[0] += stride;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 324
  if ((unsigned long )metadata != (unsigned long )((void *)0)) {
    {
#line 325
    ok = ExtractMetadataFromJPEG(& dinfo, metadata);
    }
#line 326
    if (! ok) {
      {
#line 327
      fprintf(stderr, "Error extracting JPEG metadata!\n\220");
      }
#line 328
      goto Error;
    }
  }
  {
#line 332
  jpeg_finish_decompress(& dinfo);
#line 333
  jpeg_destroy_decompress(& dinfo);
#line 336
  pic->width = width;
#line 337
  pic->height = height;
#line 338
  ok = WebPPictureImportRGB(pic, rgb, (int )stride);
  }
#line 339
  if (! ok) {
#line 339
    goto Error;
  }
  End: 
  {
#line 342
  free((void *)rgb);
  }
#line 343
  return (ok);
}
}
#line 46 "/root/patron-new/new_3/imageio/./image_dec.h"
WebPInputFileFormat WebPGuessImageType(uint8_t *data , size_t data_size ) ;
#line 55
WebPImageReader WebPGetImageReader(WebPInputFileFormat format ) ;
#line 60
WebPImageReader WebPGuessImageReader(uint8_t *data , size_t data_size ) ;
#line 14 "/root/patron-new/new_3/imageio/image_dec.c"
__inline static uint32_t GetBE32(uint8_t *buf ) 
{ 


  {
#line 15
  return (((((uint32_t )*(buf + 0) << 24) | (unsigned int )((int )*(buf + 1) << 16)) | (unsigned int )((int )*(buf + 2) << 8)) | (unsigned int )*(buf + 3));
}
}
#line 18 "/root/patron-new/new_3/imageio/image_dec.c"
WebPInputFileFormat WebPGuessImageType(uint8_t *data , size_t data_size ) 
{ 
  WebPInputFileFormat format ;
  uint32_t magic1 ;
  uint32_t __cil_tmp5 ;
  uint32_t magic2 ;
  uint32_t __cil_tmp7 ;
  int type ;

  {
#line 20
  format = (WebPInputFileFormat )5;
#line 21
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 21
    if (data_size >= 12UL) {
      {
#line 22
      __cil_tmp5 = GetBE32(data + 0);
#line 22
      magic1 = __cil_tmp5;
#line 23
      __cil_tmp7 = GetBE32(data + 8);
#line 23
      magic2 = __cil_tmp7;
      }
#line 24
      if (magic1 == 2303741511U) {
#line 25
        format = (WebPInputFileFormat )0;
      } else
#line 26
      if (magic1 >= 4292411136U) {
#line 26
        if (magic1 <= 4292411391U) {
#line 27
          format = (WebPInputFileFormat )1;
        } else {
#line 26
          goto _L___80;
        }
      } else
      _L___80: 
#line 28
      if (magic1 == 1229531648U) {
#line 29
        format = (WebPInputFileFormat )2;
      } else
#line 28
      if (magic1 == 1296891946U) {
#line 29
        format = (WebPInputFileFormat )2;
      } else
#line 30
      if (magic1 == 1380533830U) {
#line 30
        if (magic2 == 1464156752U) {
#line 31
          format = (WebPInputFileFormat )3;
        } else {
#line 30
          goto _L;
        }
      } else
      _L: 
#line 32
      if (((magic1 >> 24) & 255U) == 80U) {
#line 33
        type = (int )((magic1 >> 16) & 255U);
#line 35
        if (type >= 53) {
#line 35
          if (type <= 55) {
#line 35
            format = (WebPInputFileFormat )4;
          }
        }
      }
    }
  }
#line 38
  return (format);
}
}
#line 41 "/root/patron-new/new_3/imageio/image_dec.c"
static int FailReader(uint8_t *data , size_t data_size , struct WebPPicture *pic ,
                      int keep_alpha , struct Metadata *metadata ) 
{ 


  {
#line 49
  return (0);
}
}
#line 52 "/root/patron-new/new_3/imageio/image_dec.c"
WebPImageReader WebPGetImageReader(WebPInputFileFormat format ) 
{ 


  {
#line 54
  if ((unsigned int )format == 0U) {
#line 54
    goto case_0;
  }
#line 55
  if ((unsigned int )format == 1U) {
#line 55
    goto case_1;
  }
#line 56
  if ((unsigned int )format == 2U) {
#line 56
    goto case_2;
  }
#line 57
  if ((unsigned int )format == 3U) {
#line 57
    goto case_3;
  }
#line 58
  if ((unsigned int )format == 4U) {
#line 58
    goto case_4;
  }
#line 59
  goto switch_default;
  case_0: 
#line 54
  return ((WebPImageReader )(& ReadPNG));
  case_1: 
#line 55
  return ((WebPImageReader )(& ReadJPEG));
  case_2: 
#line 56
  return ((WebPImageReader )(& ReadTIFF));
  case_3: 
#line 57
  return ((WebPImageReader )(& ReadWebP));
  case_4: 
#line 58
  return ((WebPImageReader )(& ReadPNM));
  switch_default: 
#line 59
  return ((WebPImageReader )(& FailReader));

#line 63
  return ((int (*)(uint8_t * const   , size_t  , struct WebPPicture * const   , int  ,
                   struct Metadata * const   ))0);
}
}
#line 63 "/root/patron-new/new_3/imageio/image_dec.c"
WebPImageReader WebPGuessImageReader(uint8_t *data , size_t data_size ) 
{ 
  WebPInputFileFormat __cil_tmp3 ;
  int (*__cil_tmp4)(uint8_t * const   , size_t  , struct WebPPicture * const   , int  ,
                    struct Metadata * const   ) ;

  {
  {
#line 65
  __cil_tmp3 = WebPGuessImageType(data, data_size);
#line 65
  __cil_tmp4 = WebPGetImageReader(__cil_tmp3);
  }
#line 65
  return (__cil_tmp4);
}
}
#line 26 "/root/patron-new/new_3/imageio/imageio_util.c"
FILE *ImgIoUtilSetBinaryMode(FILE *file ) 
{ 


  {
#line 33
  return (file);
}
}
#line 38 "/root/patron-new/new_3/imageio/imageio_util.c"
static size_t kBlockSize  ;
#line 36 "/root/patron-new/new_3/imageio/imageio_util.c"
int ImgIoUtilReadFromStdin(uint8_t **data , size_t *data_size ) 
{ 
  size_t max_size ;
  size_t size ;
  uint8_t *input ;
  FILE *__cil_tmp7 ;
  int __cil_tmp8 ;
  size_t extra_size ;
  size_t tmp___2 ;
  void *new_data ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 37
  kBlockSize = (size_t )16384;
#line 38
  max_size = (size_t )0;
#line 39
  size = (size_t )0;
#line 40
  input = (uint8_t *)((void *)0);
#line 42
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 42
    return (0);
  } else
#line 42
  if ((unsigned long )data_size == (unsigned long )((void *)0)) {
#line 42
    return (0);
  }
  {
#line 43
  *data = (uint8_t *)((void *)0);
#line 44
  *data_size = (size_t )0;
#line 46
  __cil_tmp7 = ImgIoUtilSetBinaryMode(stdin);
  }
#line 46
  if (! __cil_tmp7) {
#line 46
    return (0);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 48
    __cil_tmp8 = feof(stdin);
    }
#line 48
    if (! (! __cil_tmp8)) {
#line 48
      goto while_break;
    }
#line 50
    if (max_size == 0UL) {
#line 50
      tmp___2 = kBlockSize;
    } else {
#line 50
      tmp___2 = max_size;
    }
    {
#line 50
    extra_size = tmp___2;
#line 52
    __cil_tmp12 = realloc((void *)input, (max_size + extra_size) + 1UL);
#line 52
    new_data = __cil_tmp12;
    }
#line 53
    if ((unsigned long )new_data == (unsigned long )((void *)0)) {
#line 53
      goto Error;
    }
    {
#line 54
    input = (uint8_t *)new_data;
#line 55
    max_size += extra_size;
#line 56
    __cil_tmp13 = fread((void *)(input + size), 1UL, extra_size, stdin);
#line 56
    size += __cil_tmp13;
    }
#line 57
    if (size < max_size) {
#line 57
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 59
  __cil_tmp14 = ferror(stdin);
  }
#line 59
  if (__cil_tmp14) {
#line 59
    goto Error;
  }
#line 60
  if ((unsigned long )input != (unsigned long )((void *)0)) {
#line 60
    *(input + size) = (uint8_t )'\000';
  }
#line 61
  *data = input;
#line 62
  *data_size = size;
#line 63
  return (1);
  Error: 
  {
#line 66
  free((void *)input);
#line 67
  fprintf(stderr, "Could not read from stdin\n");
  }
#line 68
  return (0);
}
}
#line 71 "/root/patron-new/new_3/imageio/imageio_util.c"
int ImgIoUtilReadFile(char const   *file_name , uint8_t **data , size_t *data_size ) 
{ 
  int ok ;
  uint8_t *file_data ;
  size_t file_size ;
  FILE *in ;
  int from_stdin ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  long __cil_tmp12 ;
  void *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int tmp___2 ;

  {
  {
#line 77
  __cil_tmp9 = strcmp(file_name, "-");
  }
#line 77
  if ((unsigned long )file_name == (unsigned long )((void *)0)) {
#line 77
    tmp___2 = 1;
  } else
#line 77
  if (! __cil_tmp9) {
#line 77
    tmp___2 = 1;
  } else {
#line 77
    tmp___2 = 0;
  }
#line 77
  from_stdin = tmp___2;
#line 79
  if (from_stdin) {
    {
#line 79
    __cil_tmp10 = ImgIoUtilReadFromStdin(data, data_size);
    }
#line 79
    return (__cil_tmp10);
  }
#line 81
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 81
    return (0);
  } else
#line 81
  if ((unsigned long )data_size == (unsigned long )((void *)0)) {
#line 81
    return (0);
  }
  {
#line 82
  *data = (uint8_t *)((void *)0);
#line 83
  *data_size = (size_t )0;
#line 85
  in = fopen(file_name, "rbB,\001V");
  }
#line 86
  if ((unsigned long )in == (unsigned long )((void *)0)) {
    {
#line 87
    fprintf(stderr, "cannot open input file \'%s\'\n", file_name);
    }
#line 88
    return (0);
  }
  {
#line 90
  fseek(in, 0L, 2);
#line 91
  __cil_tmp12 = ftell(in);
#line 91
  file_size = (size_t )__cil_tmp12;
#line 92
  fseek(in, 0L, 0);
#line 94
  __cil_tmp13 = WebPMalloc(file_size + 1UL);
#line 94
  file_data = (uint8_t *)__cil_tmp13;
  }
#line 95
  if ((unsigned long )file_data == (unsigned long )((void *)0)) {
    {
#line 96
    fclose(in);
#line 97
    fprintf(stderr, "memory allocation failure when reading file %s\n", file_name);
    }
#line 99
    return (0);
  }
  {
#line 101
  __cil_tmp14 = fread((void *)file_data, file_size, 1UL, in);
#line 101
  ok = __cil_tmp14 == 1UL;
#line 102
  fclose(in);
  }
#line 104
  if (! ok) {
    {
#line 105
    fprintf(stderr, "Could not read %d bytes of data from file %s\n", (int )file_size,
            file_name);
#line 107
    WebPFree((void *)file_data);
    }
#line 108
    return (0);
  }
#line 110
  *(file_data + file_size) = (uint8_t )'\000';
#line 111
  *data = file_data;
#line 112
  *data_size = file_size;
#line 113
  return (1);
}
}
#line 118 "/root/patron-new/new_3/imageio/imageio_util.c"
int ImgIoUtilWriteFile(char const   *file_name , uint8_t *data , size_t data_size ) 
{ 
  int ok ;
  FILE *out ;
  int to_stdout ;
  int __cil_tmp7 ;
  FILE *__cil_tmp8 ;
  FILE *__cil_tmp9 ;
  FILE *tmp___2 ;
  unsigned long __cil_tmp11 ;
  int tmp___3 ;

  {
  {
#line 122
  __cil_tmp7 = strcmp(file_name, "-");
  }
#line 122
  if ((unsigned long )file_name == (unsigned long )((void *)0)) {
#line 122
    tmp___3 = 1;
  } else
#line 122
  if (! __cil_tmp7) {
#line 122
    tmp___3 = 1;
  } else {
#line 122
    tmp___3 = 0;
  }
#line 122
  to_stdout = tmp___3;
#line 124
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 125
    return (0);
  }
#line 127
  if (to_stdout) {
    {
#line 127
    __cil_tmp8 = ImgIoUtilSetBinaryMode(stdout);
#line 127
    tmp___2 = __cil_tmp8;
    }
  } else {
    {
#line 127
    __cil_tmp9 = fopen(file_name, "wb");
#line 127
    tmp___2 = __cil_tmp9;
    }
  }
#line 127
  out = tmp___2;
#line 128
  if ((unsigned long )out == (unsigned long )((void *)0)) {
    {
#line 129
    fprintf(stderr, "Error! Cannot open output file \'%s\'\n", file_name);
    }
#line 131
    return (0);
  }
  {
#line 133
  __cil_tmp11 = fwrite((void const   *)data, data_size, 1UL, out);
#line 133
  ok = __cil_tmp11 == 1UL;
  }
#line 134
  if ((unsigned long )out != (unsigned long )stdout) {
    {
#line 134
    fclose(out);
    }
  }
#line 135
  return (ok);
}
}
#line 140 "/root/patron-new/new_3/imageio/imageio_util.c"
void ImgIoUtilCopyPlane(uint8_t *src , int src_stride , uint8_t *dst , int dst_stride ,
                        int width , int height ) 
{ 
  int __cil_tmp7 ;

  {
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    __cil_tmp7 = height;
#line 142
    height --;
#line 142
    if (! (__cil_tmp7 > 0)) {
#line 142
      goto while_break;
    }
    {
#line 143
    memcpy((void *)dst, (void const   *)src, (unsigned long )width * sizeof(*dst));
#line 144
    src += src_stride;
#line 145
    dst += dst_stride;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 150
  return;
}
}
#line 151 "/root/patron-new/new_3/imageio/imageio_util.c"
int ImgIoUtilCheckSizeArgumentsOverflow(uint64_t stride , size_t height ) 
{ 
  uint64_t total_size ;
  int ok ;
  int tmp___2 ;

  {
#line 152
  total_size = stride * height;
#line 153
  ok = total_size == total_size;
#line 155
  if (ok) {
#line 155
    if ((uint64_t )((int )stride) == stride) {
#line 155
      tmp___2 = 1;
    } else {
#line 155
      tmp___2 = 0;
    }
  } else {
#line 155
    tmp___2 = 0;
  }
#line 155
  ok = tmp___2;
#line 159
  return (ok);
}
}
#line 29 "/root/patron-new/new_3/examples/./example_util.h"
uint32_t ExUtilGetUInt(char const   *v , int base , int *error ) ;
#line 30
int ExUtilGetInt(char const   *v , int base , int *error ) ;
#line 31
float ExUtilGetFloat(char const   *v , int *error ) ;
#line 37
int ExUtilGetInts(char const   *v , int base , int max_output , int *output ) ;
#line 41
int ExUtilReadFileToWebPData(char const   *filename , WebPData *webp_data ) ;
#line 60
int ExUtilInitCommandLineArguments(int argc , char const   **argv , CommandLineArguments *args ) ;
#line 64
void ExUtilDeleteCommandLineArguments(CommandLineArguments *args ) ;
#line 26 "/root/patron-new/new_3/examples/example_util.c"
uint32_t ExUtilGetUInt(char const   *v , int base , int *error ) 
{ 
  char *end ;
  uint32_t n ;
  unsigned long __cil_tmp6 ;
  uint32_t tmp___2 ;
  char const   *tmp___3 ;

  {
#line 27
  end = (char *)((void *)0);
#line 28
  if ((unsigned long )v != (unsigned long )((void *)0)) {
    {
#line 28
    __cil_tmp6 = strtoul(v, & end, base);
#line 28
    tmp___2 = (uint32_t )__cil_tmp6;
    }
  } else {
#line 28
    tmp___2 = 0U;
  }
#line 28
  n = tmp___2;
#line 29
  if ((unsigned long )end == (unsigned long )v) {
#line 29
    if ((unsigned long )error != (unsigned long )((void *)0)) {
#line 29
      if (! *error) {
#line 30
        *error = 1;
#line 31
        if ((unsigned long )v != (unsigned long )((void *)0)) {
#line 31
          tmp___3 = v;
        } else {
          {
#line 31
          strcpy((char *)tmp___3, "(null)");
          }
        }
        {
#line 31
        fprintf(stderr, "Error! \'%s\' is not an integer.\n", tmp___3);
        }
      }
    }
  }
#line 34
  return (n);
}
}
#line 37 "/root/patron-new/new_3/examples/example_util.c"
int ExUtilGetInt(char const   *v , int base , int *error ) 
{ 
  uint32_t __cil_tmp4 ;

  {
  {
#line 38
  __cil_tmp4 = ExUtilGetUInt(v, base, error);
  }
#line 38
  return ((int )__cil_tmp4);
}
}
#line 41 "/root/patron-new/new_3/examples/example_util.c"
int ExUtilGetInts(char const   *v , int base , int max_output , int *output ) 
{ 
  int n ;
  int error ;
  int value ;
  int __cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 42
  error = 0;
#line 43
  n = 0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;

#line 43
    if ((unsigned long )v != (unsigned long )((void *)0)) {
#line 43
      if (! (n < max_output)) {
#line 43
        goto while_break;
      }
    } else {
#line 43
      goto while_break;
    }
    {
#line 44
    __cil_tmp8 = ExUtilGetInt(v, base, & error);
#line 44
    value = __cil_tmp8;
    }
#line 45
    if (error) {
#line 45
      return (-1);
    }
    {
#line 46
    *(output + n) = value;
#line 47
    __cil_tmp9 = strchr(v, ',');
#line 47
    v = (char const   *)__cil_tmp9;
    }
#line 48
    if ((unsigned long )v != (unsigned long )((void *)0)) {
#line 48
      v ++;
    }
#line 43
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 50
  return (n);
}
}
#line 53 "/root/patron-new/new_3/examples/example_util.c"
float ExUtilGetFloat(char const   *v , int *error ) 
{ 
  char *end ;
  float f ;
  double __cil_tmp5 ;
  float tmp___2 ;
  char const   *tmp___3 ;

  {
#line 54
  end = (char *)((void *)0);
#line 55
  if ((unsigned long )v != (unsigned long )((void *)0)) {
    {
#line 55
    __cil_tmp5 = strtod(v, & end);
#line 55
    tmp___2 = (float )__cil_tmp5;
    }
  } else {
#line 55
    tmp___2 = 0.f;
  }
#line 55
  f = tmp___2;
#line 56
  if ((unsigned long )end == (unsigned long )v) {
#line 56
    if ((unsigned long )error != (unsigned long )((void *)0)) {
#line 56
      if (! *error) {
#line 57
        *error = 1;
#line 58
        if ((unsigned long )v != (unsigned long )((void *)0)) {
#line 58
          tmp___3 = v;
        } else {
          {
#line 58
          strcpy((char *)tmp___3, "(null)");
          }
        }
        {
#line 58
        fprintf(stderr, "Error! \'%s\' is not a floating point number.\n", tmp___3);
        }
      }
    }
  }
#line 61
  return (f);
}
}
#line 66 "/root/patron-new/new_3/examples/example_util.c"
static void ResetCommandLineArguments(int argc , char const   **argv , CommandLineArguments *args ) 
{ 


  {
  {
#line 69
  args->argc_ = argc;
#line 70
  args->argv_ = argv;
#line 71
  args->own_argv_ = 0;
#line 72
  WebPDataInit(& args->argv_data_);
  }
#line 74
  return;
}
}
#line 75 "/root/patron-new/new_3/examples/example_util.c"
void ExUtilDeleteCommandLineArguments(CommandLineArguments *args ) 
{ 


  {
#line 76
  if ((unsigned long )args != (unsigned long )((void *)0)) {
#line 77
    if (args->own_argv_) {
      {
#line 78
      WebPFree((void *)args->argv_);
#line 79
      WebPDataClear(& args->argv_data_);
      }
    }
    {
#line 81
    ResetCommandLineArguments(0, (char const   **)((void *)0), args);
    }
  }
#line 84
  return;
}
}
#line 86 "/root/patron-new/new_3/examples/example_util.c"
int ExUtilInitCommandLineArguments(int argc , char const   **argv , CommandLineArguments *args ) 
{ 
  char *cur ;
  char sep[7] ;
  int __cil_tmp6 ;
  void *__cil_tmp7 ;
  int __cil_tmp9 ;

  {
#line 88
  if ((unsigned long )args == (unsigned long )((void *)0)) {
#line 88
    return (0);
  } else
#line 88
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
#line 88
    return (0);
  }
  {
#line 89
  ResetCommandLineArguments(argc, argv, args);
  }
#line 90
  if (argc == 1) {
#line 90
    if ((int )*(*(argv + 0) + 0) != 45) {
      {
#line 92
      strcpy(sep, " \t\r\n\f\v");
#line 101
      __cil_tmp6 = ExUtilReadFileToWebPData(*(argv + 0), & args->argv_data_);
      }
#line 101
      if (! __cil_tmp6) {
#line 102
        return (0);
      }
      {
#line 104
      args->own_argv_ = 1;
#line 105
      __cil_tmp7 = WebPMalloc(16384UL * sizeof(*(args->argv_)));
#line 105
      args->argv_ = (char const   **)__cil_tmp7;
      }
#line 106
      if ((unsigned long )args->argv_ == (unsigned long )((void *)0)) {
#line 106
        return (0);
      }
      {
#line 108
      argc = 0;
#line 109
      cur = strtok((char *)args->argv_data_.bytes, (char const   *)(sep));
      }
      {
#line 109
      while (1) {
        while_continue: /* CIL Label */ ;

#line 109
        if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 109
          goto while_break;
        }
#line 112
        if (argc == 16384) {
          {
#line 113
          fprintf(stderr, "ERROR: Arguments limit %d reached\n", 16384);
          }
#line 114
          return (0);
        }
        {
#line 117
        __cil_tmp9 = argc;
#line 117
        argc ++;
#line 117
        *(args->argv_ + __cil_tmp9) = (char const   *)cur;
#line 111
        cur = strtok((char *)((void *)0), (char const   *)(sep));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
#line 119
      args->argc_ = argc;
    }
  }
#line 121
  return (1);
}
}
#line 126 "/root/patron-new/new_3/examples/example_util.c"
int ExUtilReadFileToWebPData(char const   *filename , WebPData *webp_data ) 
{ 
  uint8_t *data ;
  size_t size ;
  int __cil_tmp5 ;

  {
#line 130
  if ((unsigned long )webp_data == (unsigned long )((void *)0)) {
#line 130
    return (0);
  }
  {
#line 131
  __cil_tmp5 = ImgIoUtilReadFile(filename, & data, & size);
  }
#line 131
  if (! __cil_tmp5) {
#line 131
    return (0);
  }
#line 132
  webp_data->bytes = data;
#line 133
  webp_data->size = size;
#line 134
  return (1);
}
}
#line 66 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 47 "/root/patron-new/new_3/examples/./stopwatch.h"
__inline static void StopwatchReset(Stopwatch *watch ) 
{ 


  {
  {
#line 48
  gettimeofday(watch, (void *)0);
  }
#line 50
  return;
}
}
#line 51 "/root/patron-new/new_3/examples/./stopwatch.h"
__inline static double StopwatchReadAndReset(Stopwatch *watch ) 
{ 
  struct timeval old_value ;
  double delta_sec ;
  double delta_usec ;

  {
  {
#line 54
  memcpy((void *)(& old_value), (void const   *)watch, sizeof(old_value));
#line 55
  gettimeofday(watch, (void *)0);
#line 56
  delta_sec = (double )watch->tv_sec - (double )old_value.tv_sec;
#line 57
  delta_usec = (double )watch->tv_usec - (double )old_value.tv_usec;
  }
#line 58
  return (delta_sec + delta_usec / 1000000.);
}
}
#line 46 "/root/patron-new/new_3/examples/cwebp.c"
static int verbose  =    0;
#line 48 "/root/patron-new/new_3/examples/cwebp.c"
static int ReadYUV(uint8_t *data , size_t data_size , WebPPicture *pic ) 
{ 
  int use_argb ;
  int uv_width ;
  int uv_height ;
  int y_plane_size ;
  int uv_plane_size ;
  size_t expected_data_size ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int tmp___2 ;

  {
#line 50
  use_argb = pic->use_argb;
#line 51
  uv_width = (pic->width + 1) / 2;
#line 52
  uv_height = (pic->height + 1) / 2;
#line 53
  y_plane_size = pic->width * pic->height;
#line 54
  uv_plane_size = uv_width * uv_height;
#line 55
  expected_data_size = (size_t )(y_plane_size + 2 * uv_plane_size);
#line 57
  if (data_size != expected_data_size) {
    {
#line 58
    fprintf(stderr, "input data doesn\'t have the expected size (%d instead of %d)\n",
            (int )data_size, (int )expected_data_size);
    }
#line 61
    return (0);
  }
  {
#line 64
  pic->use_argb = 0;
#line 65
  __cil_tmp10 = WebPPictureAlloc(pic);
  }
#line 65
  if (! __cil_tmp10) {
#line 65
    return (0);
  }
  {
#line 66
  ImgIoUtilCopyPlane(data, pic->width, pic->y, pic->y_stride, pic->width, pic->height);
#line 68
  ImgIoUtilCopyPlane(data + y_plane_size, uv_width, pic->u, pic->uv_stride, uv_width,
                     uv_height);
#line 70
  ImgIoUtilCopyPlane((data + y_plane_size) + uv_plane_size, uv_width, pic->v, pic->uv_stride,
                     uv_width, uv_height);
  }
#line 72
  if (use_argb) {
    {
#line 72
    __cil_tmp11 = WebPPictureYUVAToARGB(pic);
#line 72
    tmp___2 = __cil_tmp11;
    }
  } else {
#line 72
    tmp___2 = 1;
  }
#line 72
  return (tmp___2);
}
}
#line 103 "/root/patron-new/new_3/examples/cwebp.c"
static int ReadPicture(char const   *filename , WebPPicture *pic , int keep_alpha ,
                       Metadata *metadata ) 
{ 
  uint8_t *data ;
  size_t data_size ;
  int ok ;
  int (*reader)(uint8_t * const   , size_t  , struct WebPPicture * const   , int  ,
                struct Metadata * const   ) ;
  int (*__cil_tmp10)(uint8_t * const   , size_t  , struct WebPPicture * const   ,
                     int  , struct Metadata * const   ) ;

  {
  {
#line 105
  data = (uint8_t *)((void *)0);
#line 106
  data_size = (size_t )0;
#line 107
  ok = 0;
#line 109
  ok = ImgIoUtilReadFile(filename, & data, & data_size);
  }
#line 110
  if (! ok) {
#line 110
    goto End;
  }
#line 112
  if (pic->width == 0) {
    {
#line 113
    __cil_tmp10 = WebPGuessImageReader(data, data_size);
#line 113
    reader = __cil_tmp10;
#line 114
    ok = (*reader)((uint8_t */* const  */)data, data_size, (struct WebPPicture */* const  */)pic,
                   keep_alpha, (struct Metadata */* const  */)metadata);
    }
  } else
#line 112
  if (pic->height == 0) {
    {
#line 113
    __cil_tmp10 = WebPGuessImageReader(data, data_size);
#line 113
    reader = __cil_tmp10;
#line 114
    ok = (*reader)((uint8_t */* const  */)data, data_size, (struct WebPPicture */* const  */)pic,
                   keep_alpha, (struct Metadata */* const  */)metadata);
    }
  } else {
    {
#line 117
    ok = ReadYUV(data, data_size, pic);
    }
  }
  End: 
#line 120
  if (! ok) {
    {
#line 121
    fprintf(stderr, "Error! Could not process file %s\n", filename);
    }
  }
  {
#line 124
  WebPFree((void *)data);
  }
#line 125
  return (ok);
}
}
#line 130 "/root/patron-new/new_3/examples/cwebp.c"
static void AllocExtraInfo(WebPPicture *pic ) 
{ 
  int mb_w ;
  int mb_h ;
  void *__cil_tmp4 ;

  {
  {
#line 131
  mb_w = (pic->width + 15) / 16;
#line 132
  mb_h = (pic->height + 15) / 16;
#line 133
  __cil_tmp4 = WebPMalloc((unsigned long )(mb_w * mb_h) * sizeof(*(pic->extra_info)));
#line 133
  pic->extra_info = (uint8_t *)__cil_tmp4;
  }
#line 135
  return;
}
}
#line 137 "/root/patron-new/new_3/examples/cwebp.c"
static void PrintByteCount(int const   *bytes , int total_size , int *totals ) 
{ 
  int s ;
  int total ;

  {
#line 140
  total = 0;
#line 141
  s = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;

#line 141
    if (! (s < 4)) {
#line 141
      goto while_break;
    }
    {
#line 142
    fprintf(stderr, "| %7d ", *(bytes + s));
#line 143
    total += (int )*(bytes + s);
    }
#line 144
    if (totals) {
#line 144
      *(totals + s) += (int )*(bytes + s);
    }
#line 141
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 146
  fprintf(stderr, "| %7d  (%.1f%%)\n\230\001", total, (double )((100.f * (float )total) / (float )total_size));
  }
#line 148
  return;
}
}
#line 149 "/root/patron-new/new_3/examples/cwebp.c"
static void PrintPercents(int const   *counts ) 
{ 
  int s ;
  int total ;

  {
#line 151
  total = (int )(((*(counts + 0) + *(counts + 1)) + *(counts + 2)) + *(counts + 3));
#line 152
  s = 0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;

#line 152
    if (! (s < 4)) {
#line 152
      goto while_break;
    }
    {
#line 153
    fprintf(stderr, "|     %3d%%", (int )((100. * (double )*(counts + s)) / (double )total + 0.5));
#line 152
    s ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 155
  fprintf(stderr, "| %7d\n", total);
  }
#line 157
  return;
}
}
#line 158 "/root/patron-new/new_3/examples/cwebp.c"
static void PrintValues(int const   *values ) 
{ 
  int s ;

  {
#line 160
  s = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;

#line 160
    if (! (s < 4)) {
#line 160
      goto while_break;
    }
    {
#line 161
    fprintf(stderr, "| %7d ", *(values + s));
#line 160
    s ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 163
  fprintf(stderr, "|\no,\001V");
  }
#line 165
  return;
}
}
#line 166 "/root/patron-new/new_3/examples/cwebp.c"
static void PrintFullLosslessInfo(WebPAuxStats *stats , char const   *description ) 
{ 


  {
  {
#line 168
  fprintf(stderr, "Lossless-%s compressed size: %d bytes\n", description, stats->lossless_size);
#line 170
  fprintf(stderr, "  * Header size: %d bytes, image data size: %d\n", stats->lossless_hdr_size,
          stats->lossless_data_size);
  }
#line 172
  if (stats->lossless_features) {
    {
#line 173
    fprintf(stderr, "  * Lossless features used:");
    }
#line 174
    if (stats->lossless_features & 1U) {
      {
#line 174
      fprintf(stderr, " PREDICTION");
      }
    }
#line 175
    if (stats->lossless_features & 2U) {
      {
#line 175
      fprintf(stderr, " CROSS-COLOR-TRANSFORM");
      }
    }
#line 176
    if (stats->lossless_features & 4U) {
      {
#line 176
      fprintf(stderr, " SUBTRACT-GREEN");
      }
    }
#line 177
    if (stats->lossless_features & 8U) {
      {
#line 177
      fprintf(stderr, " PALETTE\220");
      }
    }
    {
#line 178
    fprintf(stderr, "\n");
    }
  }
  {
#line 180
  fprintf(stderr, "  * Precision Bits: histogram=%d transform=%d cache=%d\n", stats->histogram_bits,
          stats->transform_bits, stats->cache_bits);
  }
#line 182
  if (stats->palette_size > 0) {
    {
#line 183
    fprintf(stderr, "  * Palette size:   %d\n", stats->palette_size);
    }
  }
#line 186
  return;
}
}
#line 187 "/root/patron-new/new_3/examples/cwebp.c"
static void PrintExtraInfoLossless(WebPPicture *pic , int short_output , char const   *file_name ) 
{ 
  WebPAuxStats *stats ;

  {
#line 190
  stats = pic->stats;
#line 191
  if (short_output) {
    {
#line 192
    fprintf(stderr, "%7d %2.2f\n", stats->coded_size, (double )stats->PSNR[3]);
    }
  } else {
    {
#line 194
    fprintf(stderr, "File:      %s\n", file_name);
#line 195
    fprintf(stderr, "Dimension: %d x %d\n", pic->width, pic->height);
#line 196
    fprintf(stderr, "Output:    %d bytes (%.2f bpp)\n", stats->coded_size, (double )(((8.f * (float )stats->coded_size) / (float )pic->width) / (float )pic->height));
#line 198
    PrintFullLosslessInfo(stats, "ARGB");
    }
  }
#line 201
  return;
}
}
#line 202 "/root/patron-new/new_3/examples/cwebp.c"
static void PrintExtraInfoLossy(WebPPicture *pic , int short_output , int full_details ,
                                char const   *file_name ) 
{ 
  WebPAuxStats *stats ;
  int num_i4 ;
  int num_i16 ;
  int num_skip ;
  int total ;
  char const   *tmp___2 ;
  int totals[4] ;

  {
#line 205
  stats = pic->stats;
#line 206
  if (short_output) {
    {
#line 207
    fprintf(stderr, "%7d %2.2f\n", stats->coded_size, (double )stats->PSNR[3]);
    }
  } else {
    {
#line 209
    num_i4 = stats->block_count[0];
#line 210
    num_i16 = stats->block_count[1];
#line 211
    num_skip = stats->block_count[2];
#line 212
    total = num_i4 + num_i16;
#line 213
    fprintf(stderr, "File:      %s\n", file_name);
    }
#line 214
    if (stats->alpha_data_size) {
      {
#line 214
      strcpy((char *)tmp___2, " (with alpha)");
      }
    } else {
      {
#line 214
      strcpy((char *)tmp___2, "\220");
      }
    }
    {
#line 214
    fprintf(stderr, "Dimension: %d x %d%s\n", pic->width, pic->height, tmp___2);
#line 217
    fprintf(stderr, "Output:    %d bytes Y-U-V-All-PSNR %2.2f %2.2f %2.2f   %2.2f dB\n           (%.2f bpp)\n",
            stats->coded_size, (double )stats->PSNR[0], (double )stats->PSNR[1], (double )stats->PSNR[2],
            (double )stats->PSNR[3], (double )(((8.f * (float )stats->coded_size) / (float )pic->width) / (float )pic->height));
    }
#line 223
    if (total > 0) {
      {
#line 224
      totals[0] = 0;
#line 224
      totals[1] = 0;
#line 224
      totals[2] = 0;
#line 224
      totals[3] = 0;
#line 225
      fprintf(stderr, "block count:  intra4:     %6d  (%.2f%%)\n              intra16:    %6d  (%.2f%%)\n              skipped:    %6d  (%.2f%%)\n\230\001",
              num_i4, (double )((100.f * (float )num_i4) / (float )total), num_i16,
              (double )((100.f * (float )num_i16) / (float )total), num_skip, (double )((100.f * (float )num_skip) / (float )total));
#line 231
      fprintf(stderr, "bytes used:  header:         %6d  (%.1f%%)\n             mode-partition: %6d  (%.1f%%)\n",
              stats->header_bytes[0], (double )((100.f * (float )stats->header_bytes[0]) / (float )stats->coded_size),
              stats->header_bytes[1], (double )((100.f * (float )stats->header_bytes[1]) / (float )stats->coded_size));
      }
#line 237
      if (stats->alpha_data_size > 0) {
        {
#line 238
        fprintf(stderr, "             transparency:   %6d (%.1f dB)\n", stats->alpha_data_size,
                (double )stats->PSNR[4]);
        }
      }
      {
#line 241
      fprintf(stderr, " Residuals bytes  |segment 1|segment 2|segment 3|segment 4|  total\n");
      }
#line 244
      if (full_details) {
        {
#line 245
        fprintf(stderr, "  intra4-coeffs:  ");
#line 246
        PrintByteCount((int const   *)((int const   *)(stats->residual_bytes[0])),
                       stats->coded_size, totals);
#line 247
        fprintf(stderr, " intra16-coeffs:  ");
#line 248
        PrintByteCount((int const   *)((int const   *)(stats->residual_bytes[1])),
                       stats->coded_size, totals);
#line 249
        fprintf(stderr, "  chroma coeffs:  ");
#line 250
        PrintByteCount((int const   *)((int const   *)(stats->residual_bytes[2])),
                       stats->coded_size, totals);
        }
      }
      {
#line 252
      fprintf(stderr, "    macroblocks:  ");
#line 253
      PrintPercents((int const   *)((int const   *)(stats->segment_size)));
#line 254
      fprintf(stderr, "      quantizer:  ");
#line 255
      PrintValues((int const   *)((int const   *)(stats->segment_quant)));
#line 256
      fprintf(stderr, "   filter level:  ");
#line 257
      PrintValues((int const   *)((int const   *)(stats->segment_level)));
      }
#line 258
      if (full_details) {
        {
#line 259
        fprintf(stderr, "------------------+---------");
#line 260
        fprintf(stderr, "+---------+---------+---------+-----------------\n");
#line 261
        fprintf(stderr, " segments total:  ");
#line 262
        PrintByteCount((int const   *)((int const   *)(totals)), stats->coded_size,
                       (int *)((void *)0));
        }
      }
    }
#line 265
    if (stats->lossless_size > 0) {
      {
#line 266
      PrintFullLosslessInfo(stats, "alpha");
      }
    }
  }
#line 270
  return;
}
}
#line 271 "/root/patron-new/new_3/examples/cwebp.c"
static void PrintMapInfo(WebPPicture *pic ) 
{ 
  int mb_w ;
  int mb_h ;
  int type ;
  int x ;
  int y ;
  int c ;

  {
#line 272
  if ((unsigned long )pic->extra_info != (unsigned long )((void *)0)) {
#line 273
    mb_w = (pic->width + 15) / 16;
#line 274
    mb_h = (pic->height + 15) / 16;
#line 275
    type = pic->extra_info_type;
#line 277
    y = 0;
    {
#line 277
    while (1) {
      while_continue: /* CIL Label */ ;

#line 277
      if (! (y < mb_h)) {
#line 277
        goto while_break;
      }
#line 278
      x = 0;
      {
#line 278
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 278
        if (! (x < mb_w)) {
#line 278
          goto while_break___0;
        }
#line 279
        c = (int )*(pic->extra_info + (x + y * mb_w));
#line 280
        if (type == 1) {
          {
#line 281
          fprintf(stderr, "%c", (int )*("+." + c));
          }
        } else
#line 282
        if (type == 2) {
          {
#line 283
          fprintf(stderr, "%c", (int )*(".-*X" + c));
          }
        } else
#line 284
        if (type == 3) {
          {
#line 285
          fprintf(stderr, "%.2d V", c);
          }
        } else
#line 286
        if (type == 6) {
          {
#line 287
          fprintf(stderr, "%3d \377\377\377\377\230\001", c);
          }
        } else
#line 286
        if (type == 7) {
          {
#line 287
          fprintf(stderr, "%3d \377\377\377\377\230\001", c);
          }
        } else {
          {
#line 289
          fprintf(stderr, "0x%.2x ", c);
          }
        }
#line 278
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
      {
#line 292
      fprintf(stderr, "\n\016`,\001V");
#line 277
      y ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 282
  return;
}
}
#line 299 "/root/patron-new/new_3/examples/cwebp.c"
static int MyWriter(uint8_t *data , size_t data_size , WebPPicture *pic ) 
{ 
  FILE *out ;
  unsigned long __cil_tmp5 ;
  unsigned long tmp___2 ;

  {
#line 301
  out = (FILE *)pic->custom_ptr;
#line 302
  if (data_size) {
    {
#line 302
    __cil_tmp5 = fwrite((void const   *)data, data_size, 1UL, out);
#line 302
    tmp___2 = (unsigned long )(__cil_tmp5 == 1UL);
    }
  } else {
#line 302
    tmp___2 = 1UL;
  }
#line 302
  return ((int )tmp___2);
}
}
#line 306 "/root/patron-new/new_3/examples/cwebp.c"
static int DumpPicture(WebPPicture *picture , char const   *PGM_name ) 
{ 
  int y ;
  int uv_width ;
  int uv_height ;
  int stride ;
  uint8_t *src_y ;
  uint8_t *src_u ;
  uint8_t *src_v ;
  uint8_t *src_a ;
  int alpha_height ;
  int __cil_tmp12 ;
  int tmp___2 ;
  int height ;
  FILE *f ;
  FILE *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;

  {
  {
#line 308
  uv_width = (picture->width + 1) / 2;
#line 309
  uv_height = (picture->height + 1) / 2;
#line 310
  stride = (picture->width + 1) & -2;
#line 311
  src_y = picture->y;
#line 312
  src_u = picture->u;
#line 313
  src_v = picture->v;
#line 314
  src_a = picture->a;
#line 315
  __cil_tmp12 = WebPPictureHasTransparency(picture);
  }
#line 315
  if (__cil_tmp12) {
#line 315
    tmp___2 = picture->height;
  } else {
#line 315
    tmp___2 = 0;
  }
  {
#line 315
  alpha_height = tmp___2;
#line 317
  height = (picture->height + uv_height) + alpha_height;
#line 318
  __cil_tmp16 = fopen(PGM_name, "wb");
#line 318
  f = __cil_tmp16;
  }
#line 319
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 319
    return (0);
  }
  {
#line 320
  fprintf(f, "P5\n%d %d\n255\n", stride, height);
#line 321
  y = 0;
  }
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;

#line 321
    if (! (y < picture->height)) {
#line 321
      goto while_break;
    }
    {
#line 322
    __cil_tmp17 = fwrite((void const   *)src_y, (unsigned long )picture->width, 1UL,
                         f);
    }
#line 322
    if (__cil_tmp17 != 1UL) {
#line 322
      return (0);
    }
#line 323
    if (picture->width & 1) {
      {
#line 323
      fputc(0, f);
      }
    }
#line 324
    src_y += picture->y_stride;
#line 321
    y ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 326
  y = 0;
  {
#line 326
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 326
    if (! (y < uv_height)) {
#line 326
      goto while_break___0;
    }
    {
#line 327
    __cil_tmp18 = fwrite((void const   *)src_u, (unsigned long )uv_width, 1UL, f);
    }
#line 327
    if (__cil_tmp18 != 1UL) {
#line 327
      return (0);
    }
    {
#line 328
    __cil_tmp19 = fwrite((void const   *)src_v, (unsigned long )uv_width, 1UL, f);
    }
#line 328
    if (__cil_tmp19 != 1UL) {
#line 328
      return (0);
    }
#line 329
    src_u += picture->uv_stride;
#line 330
    src_v += picture->uv_stride;
#line 326
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 332
  y = 0;
  {
#line 332
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 332
    if (! (y < alpha_height)) {
#line 332
      goto while_break___1;
    }
    {
#line 333
    __cil_tmp20 = fwrite((void const   *)src_a, (unsigned long )picture->width, 1UL,
                         f);
    }
#line 333
    if (__cil_tmp20 != 1UL) {
#line 333
      return (0);
    }
#line 334
    if (picture->width & 1) {
      {
#line 334
      fputc(0, f);
      }
    }
#line 335
    src_a += picture->a_stride;
#line 332
    y ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 337
  fclose(f);
  }
#line 338
  return (1);
}
}
#line 351 "/root/patron-new/new_3/examples/cwebp.c"
static int const   kChunkHeaderSize  =    (int const   )8;
#line 352 "/root/patron-new/new_3/examples/cwebp.c"
static int const   kTagSize  =    (int const   )4;
#line 354 "/root/patron-new/new_3/examples/cwebp.c"
static void PrintMetadataInfo(Metadata *metadata , int metadata_written ) 
{ 


  {
#line 356
  if ((unsigned long )metadata == (unsigned long )((void *)0)) {
#line 356
    return;
  } else
#line 356
  if (metadata_written == 0) {
#line 356
    return;
  }
  {
#line 358
  fprintf(stderr, "Metadata:\ni,\001V");
  }
#line 359
  if (metadata_written & 2) {
    {
#line 360
    fprintf(stderr, "  * ICC profile:  %6d bytes\n\001V", (int )metadata->iccp.size);
    }
  }
#line 362
  if (metadata_written & 1) {
    {
#line 363
    fprintf(stderr, "  * EXIF data:    %6d bytes\n\001V", (int )metadata->exif.size);
    }
  }
#line 365
  if (metadata_written & 4) {
    {
#line 366
    fprintf(stderr, "  * XMP data:     %6d bytes\n", (int )metadata->xmp.size);
    }
  }
#line 369
  return;
}
}
#line 371 "/root/patron-new/new_3/examples/cwebp.c"
static int WriteLE(FILE *out , uint32_t val , int num ) 
{ 
  uint8_t buf[4] ;
  int i ;
  unsigned long __cil_tmp6 ;

  {
#line 374
  i = 0;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;

#line 374
    if (! (i < num)) {
#line 374
      goto while_break;
    }
#line 375
    buf[i] = (uint8_t )(val & 255U);
#line 376
    val >>= 8;
#line 374
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 378
  __cil_tmp6 = fwrite((void const   *)(buf), (unsigned long )num, 1UL, out);
  }
#line 378
  return (__cil_tmp6 == 1UL);
}
}
#line 381 "/root/patron-new/new_3/examples/cwebp.c"
static int WriteLE24(FILE *out , uint32_t val ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 382
  __cil_tmp3 = WriteLE(out, val, 3);
  }
#line 382
  return (__cil_tmp3);
}
}
#line 385 "/root/patron-new/new_3/examples/cwebp.c"
static int WriteLE32(FILE *out , uint32_t val ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 386
  __cil_tmp3 = WriteLE(out, val, 4);
  }
#line 386
  return (__cil_tmp3);
}
}
#line 389 "/root/patron-new/new_3/examples/cwebp.c"
static int WriteMetadataChunk(FILE *out , char const   *fourcc , MetadataPayload *payload ) 
{ 
  uint8_t zero ;
  size_t need_padding ;
  int ok ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 391
  zero = (uint8_t )0;
#line 392
  need_padding = payload->size & 1UL;
#line 393
  __cil_tmp7 = fwrite((void const   *)fourcc, (unsigned long )kTagSize, 1UL, out);
#line 393
  ok = __cil_tmp7 == 1UL;
#line 394
  __cil_tmp8 = WriteLE32(out, (uint32_t )payload->size);
  }
#line 394
  if (ok) {
#line 394
    if (__cil_tmp8) {
#line 394
      tmp___2 = 1;
    } else {
#line 394
      tmp___2 = 0;
    }
  } else {
#line 394
    tmp___2 = 0;
  }
  {
#line 394
  ok = tmp___2;
#line 395
  __cil_tmp9 = fwrite((void const   *)payload->bytes, payload->size, 1UL, out);
  }
#line 395
  if (ok) {
#line 395
    if (__cil_tmp9 == 1UL) {
#line 395
      tmp___3 = 1;
    } else {
#line 395
      tmp___3 = 0;
    }
  } else {
#line 395
    tmp___3 = 0;
  }
  {
#line 395
  ok = tmp___3;
#line 396
  __cil_tmp10 = fwrite((void const   *)(& zero), need_padding, need_padding, out);
  }
#line 396
  if (ok) {
#line 396
    if (__cil_tmp10 == need_padding) {
#line 396
      tmp___4 = 1;
    } else {
#line 396
      tmp___4 = 0;
    }
  } else {
#line 396
    tmp___4 = 0;
  }
#line 396
  return (tmp___4);
}
}
#line 401 "/root/patron-new/new_3/examples/cwebp.c"
static int UpdateFlagsAndSize(MetadataPayload *payload , int keep , int flag , uint32_t *vp8x_flags ,
                              uint64_t *metadata_size ) 
{ 


  {
#line 404
  if ((unsigned long )payload->bytes != (unsigned long )((void *)0)) {
#line 404
    if (keep) {
#line 404
      if (payload->size > 0UL) {
#line 405
        *vp8x_flags |= (unsigned int )flag;
#line 406
        *metadata_size += ((unsigned long )kChunkHeaderSize + payload->size) + (payload->size & 1UL);
#line 407
        return (1);
      }
    }
  }
#line 409
  return (0);
}
}
#line 416 "/root/patron-new/new_3/examples/cwebp.c"
static int WriteWebPWithMetadata(FILE *out , WebPPicture *picture , WebPMemoryWriter *memory_writer ,
                                 Metadata *metadata , int keep_metadata , int *metadata_written ) 
{ 
  char kVP8XHeader[9] ;
  int kAlphaFlag ;
  int kEXIFFlag ;
  int kICCPFlag ;
  int kXMPFlag ;
  size_t kRiffHeaderSize ;
  size_t kMaxChunkPayload ;
  size_t kMinSize ;
  uint32_t flags ;
  uint64_t metadata_size ;
  int write_exif ;
  int __cil_tmp18 ;
  int write_iccp ;
  int __cil_tmp20 ;
  int write_xmp ;
  int __cil_tmp22 ;
  uint8_t *webp ;
  size_t webp_size ;
  int kVP8XChunkSize ;
  int has_vp8x ;
  int __cil_tmp27 ;
  uint32_t riff_size ;
  int tmp___2 ;
  int ok ;
  unsigned long __cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int is_lossless ;
  int __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 422
  strcpy(kVP8XHeader, "VP8X\n");
#line 423
  kAlphaFlag = 16;
#line 424
  kEXIFFlag = 8;
#line 425
  kICCPFlag = 32;
#line 426
  kXMPFlag = 4;
#line 427
  kRiffHeaderSize = (size_t )12;
#line 428
  kMaxChunkPayload = (size_t )((-1 - (int )kChunkHeaderSize) - 1);
#line 429
  kMinSize = kRiffHeaderSize + (unsigned long )kChunkHeaderSize;
#line 430
  flags = (uint32_t )0;
#line 431
  metadata_size = (uint64_t )0;
#line 432
  __cil_tmp18 = UpdateFlagsAndSize(& metadata->exif, ! (! (keep_metadata & 1)), kEXIFFlag,
                                   & flags, & metadata_size);
#line 432
  write_exif = __cil_tmp18;
#line 435
  __cil_tmp20 = UpdateFlagsAndSize(& metadata->iccp, ! (! (keep_metadata & 2)), kICCPFlag,
                                   & flags, & metadata_size);
#line 435
  write_iccp = __cil_tmp20;
#line 438
  __cil_tmp22 = UpdateFlagsAndSize(& metadata->xmp, ! (! (keep_metadata & 4)), kXMPFlag,
                                   & flags, & metadata_size);
#line 438
  write_xmp = __cil_tmp22;
#line 441
  webp = memory_writer->mem;
#line 442
  webp_size = memory_writer->size;
#line 444
  *metadata_written = 0;
  }
#line 446
  if (webp_size < kMinSize) {
#line 446
    return (0);
  }
#line 447
  if ((webp_size - (unsigned long )kChunkHeaderSize) + metadata_size > kMaxChunkPayload) {
    {
#line 448
    fprintf(stderr, "Error! Addition of metadata would exceed container size limit.\n,\001V");
    }
#line 450
    return (0);
  }
#line 453
  if (metadata_size > 0UL) {
    {
#line 454
    kVP8XChunkSize = 18;
#line 455
    __cil_tmp27 = memcmp((void const   *)(webp + kRiffHeaderSize), (void const   *)"VP8X",
                         (unsigned long )kTagSize);
#line 455
    has_vp8x = ! __cil_tmp27;
    }
#line 456
    if (has_vp8x) {
#line 456
      tmp___2 = 0;
    } else {
#line 456
      tmp___2 = kVP8XChunkSize;
    }
    {
#line 456
    riff_size = (uint32_t )(((webp_size - (unsigned long )kChunkHeaderSize) + (unsigned long )tmp___2) + metadata_size);
#line 460
    __cil_tmp31 = fwrite((void const   *)webp, (unsigned long )kTagSize, 1UL, out);
#line 460
    ok = __cil_tmp31 == 1UL;
#line 462
    __cil_tmp32 = WriteLE32(out, riff_size);
    }
#line 462
    if (ok) {
#line 462
      if (__cil_tmp32) {
#line 462
        tmp___3 = 1;
      } else {
#line 462
        tmp___3 = 0;
      }
    } else {
#line 462
      tmp___3 = 0;
    }
    {
#line 462
    ok = tmp___3;
#line 463
    webp += kChunkHeaderSize;
#line 464
    webp_size -= (unsigned long )kChunkHeaderSize;
#line 466
    __cil_tmp33 = fwrite((void const   *)webp, (unsigned long )kTagSize, 1UL, out);
    }
#line 466
    if (ok) {
#line 466
      if (__cil_tmp33 == 1UL) {
#line 466
        tmp___4 = 1;
      } else {
#line 466
        tmp___4 = 0;
      }
    } else {
#line 466
      tmp___4 = 0;
    }
#line 466
    ok = tmp___4;
#line 467
    webp += kTagSize;
#line 468
    webp_size -= (unsigned long )kTagSize;
#line 469
    if (has_vp8x) {
      {
#line 470
      *(webp + kChunkHeaderSize) = (uint8_t )((int )*(webp + kChunkHeaderSize) | (int )((uint8_t )(flags & 255U)));
#line 471
      __cil_tmp34 = fwrite((void const   *)webp, (unsigned long )kVP8XChunkSize, 1UL,
                           out);
      }
#line 471
      if (ok) {
#line 471
        if (__cil_tmp34 == 1UL) {
#line 471
          tmp___5 = 1;
        } else {
#line 471
          tmp___5 = 0;
        }
      } else {
#line 471
        tmp___5 = 0;
      }
#line 471
      ok = tmp___5;
#line 472
      webp += kVP8XChunkSize;
#line 473
      webp_size -= (unsigned long )kVP8XChunkSize;
    } else {
      {
#line 475
      __cil_tmp36 = memcmp((void const   *)webp, (void const   *)"VP8L", (unsigned long )kTagSize);
#line 475
      is_lossless = ! __cil_tmp36;
      }
#line 476
      if (is_lossless) {
#line 479
        if ((int )*(webp + (kChunkHeaderSize + 4)) & (1 << 4)) {
#line 479
          flags |= (unsigned int )kAlphaFlag;
        }
      }
      {
#line 481
      __cil_tmp37 = fwrite((void const   *)((char const   *)(kVP8XHeader)), (unsigned long )kChunkHeaderSize,
                           1UL, out);
      }
#line 481
      if (ok) {
#line 481
        if (__cil_tmp37 == 1UL) {
#line 481
          tmp___6 = 1;
        } else {
#line 481
          tmp___6 = 0;
        }
      } else {
#line 481
        tmp___6 = 0;
      }
      {
#line 481
      ok = tmp___6;
#line 482
      __cil_tmp38 = WriteLE32(out, flags);
      }
#line 482
      if (ok) {
#line 482
        if (__cil_tmp38) {
#line 482
          tmp___7 = 1;
        } else {
#line 482
          tmp___7 = 0;
        }
      } else {
#line 482
        tmp___7 = 0;
      }
      {
#line 482
      ok = tmp___7;
#line 483
      __cil_tmp39 = WriteLE24(out, (uint32_t )(picture->width - 1));
      }
#line 483
      if (ok) {
#line 483
        if (__cil_tmp39) {
#line 483
          tmp___8 = 1;
        } else {
#line 483
          tmp___8 = 0;
        }
      } else {
#line 483
        tmp___8 = 0;
      }
      {
#line 483
      ok = tmp___8;
#line 484
      __cil_tmp40 = WriteLE24(out, (uint32_t )(picture->height - 1));
      }
#line 484
      if (ok) {
#line 484
        if (__cil_tmp40) {
#line 484
          tmp___9 = 1;
        } else {
#line 484
          tmp___9 = 0;
        }
      } else {
#line 484
        tmp___9 = 0;
      }
#line 484
      ok = tmp___9;
    }
#line 486
    if (write_iccp) {
      {
#line 487
      __cil_tmp41 = WriteMetadataChunk(out, (char const   *)"ICCP", & metadata->iccp);
      }
#line 487
      if (ok) {
#line 487
        if (__cil_tmp41) {
#line 487
          tmp___10 = 1;
        } else {
#line 487
          tmp___10 = 0;
        }
      } else {
#line 487
        tmp___10 = 0;
      }
#line 487
      ok = tmp___10;
#line 488
      *metadata_written |= 2;
    }
    {
#line 491
    __cil_tmp42 = fwrite((void const   *)webp, webp_size, 1UL, out);
    }
#line 491
    if (ok) {
#line 491
      if (__cil_tmp42 == 1UL) {
#line 491
        tmp___11 = 1;
      } else {
#line 491
        tmp___11 = 0;
      }
    } else {
#line 491
      tmp___11 = 0;
    }
#line 491
    ok = tmp___11;
#line 492
    if (write_exif) {
      {
#line 493
      __cil_tmp43 = WriteMetadataChunk(out, (char const   *)"EXIF", & metadata->exif);
      }
#line 493
      if (ok) {
#line 493
        if (__cil_tmp43) {
#line 493
          tmp___12 = 1;
        } else {
#line 493
          tmp___12 = 0;
        }
      } else {
#line 493
        tmp___12 = 0;
      }
#line 493
      ok = tmp___12;
#line 494
      *metadata_written |= 1;
    }
#line 496
    if (write_xmp) {
      {
#line 497
      __cil_tmp44 = WriteMetadataChunk(out, (char const   *)"XMP ", & metadata->xmp);
      }
#line 497
      if (ok) {
#line 497
        if (__cil_tmp44) {
#line 497
          tmp___13 = 1;
        } else {
#line 497
          tmp___13 = 0;
        }
      } else {
#line 497
        tmp___13 = 0;
      }
#line 497
      ok = tmp___13;
#line 498
      *metadata_written |= 4;
    }
#line 500
    return (ok);
  }
  {
#line 504
  __cil_tmp45 = fwrite((void const   *)webp, webp_size, 1UL, out);
  }
#line 504
  return (__cil_tmp45 == 1UL);
}
}
#line 509 "/root/patron-new/new_3/examples/cwebp.c"
static int ProgressReport(int percent , WebPPicture *picture ) 
{ 


  {
  {
#line 510
  fprintf(stderr, "[%s]: %3d %%      \r", (char *)picture->user_data, percent);
  }
#line 512
  return (1);
}
}
#line 517 "/root/patron-new/new_3/examples/cwebp.c"
static void HelpShort(void) 
{ 


  {
  {
#line 518
  printf("Usage:\n\n\220");
#line 519
  printf("   cwebp [options] -q quality input.png -o output.webp\n\n\220");
#line 520
  printf("where quality is between 0 (poor) to 100 (very good).\n");
#line 521
  printf("Typical value is around 80.\n\nV");
#line 522
  printf("Try -longhelp for an exhaustive list of advanced options.\n");
  }
#line 524
  return;
}
}
#line 525 "/root/patron-new/new_3/examples/cwebp.c"
static void HelpLong(void) 
{ 


  {
  {
#line 526
  printf("Usage:\n");
#line 527
  printf(" cwebp [-preset <...>] [options] in_file [-o out_file]\n\n\220");
#line 528
  printf("If input size (-s) for an image is not specified, it is\nassumed to be a PNG, JPEG, TIFF or WebP file.\nq,\001V");
#line 530
  printf("Note: Animated PNG and WebP files are not supported.\nV");
#line 534
  printf("\nOptions:\n");
#line 535
  printf("  -h / -help ............. short help\n");
#line 536
  printf("  -H / -longhelp ......... long help\nV");
#line 537
  printf("  -q <float> ............. quality factor (0:small..100:big), default=75\n");
#line 539
  printf("  -alpha_q <int> ......... transparency-compression quality (0..100),\n                           default=100\n\fq,\001V");
#line 541
  printf("  -preset <string> ....... preset setting, one of:\n");
#line 542
  printf("                            default, photo, picture,\nV");
#line 543
  printf("                            drawing, icon, text\n\220");
#line 544
  printf("     -preset must come first, as it overwrites other parameters\n\220");
#line 545
  printf("  -z <int> ............... activates lossless preset with given\n                           level in [0:fast, ..., 9:slowest]\n\354p,\001V");
#line 547
  printf("\n");
#line 548
  printf("  -m <int> ............... compression method (0=fast, 6=slowest), default=4\n\034q,\001V");
#line 550
  printf("  -segments <int> ........ number of segments to use (1..4), default=4\n,\001V");
#line 552
  printf("  -size <int> ............ target size (in bytes)\nq,\001V");
#line 553
  printf("  -psnr <float> .......... target PSNR (in dB. typically: 42)\n");
#line 554
  printf("\n\352p,\001V");
#line 555
  printf("  -s <int> <int> ......... input size (width x height) for YUV\n");
#line 556
  printf("  -sns <int> ............. spatial noise shaping (0:off, 100:max), default=50\n");
#line 558
  printf("  -f <int> ............... filter strength (0=off..100), default=60\n\220");
#line 560
  printf("  -sharpness <int> ....... filter sharpness (0:most .. 7:least sharp), default=0\n");
#line 562
  printf("  -strong ................ use strong filter instead of simple (default)\n");
#line 564
  printf("  -nostrong .............. use simple filter instead of strong\n");
#line 565
  printf("  -sharp_yuv ............. use sharper (and slower) RGB->YUV conversion\n\001V");
#line 567
  printf("  -partition_limit <int> . limit quality to fit the 512k limit on\np,\001V");
#line 568
  printf("                           the first partition (0=no degradation ... 100=full)\n");
#line 570
  printf("  -pass <int> ............ analysis pass number (1..10)\n\220");
#line 571
  printf("  -qrange <min> <max> .... specifies the permissible quality range\n                           (default: 0 100)\n,\001V");
#line 573
  printf("  -crop <x> <y> <w> <h> .. crop picture with the given rectangle\n\346Z,\001V");
#line 574
  printf("  -resize <w> <h> ........ resize picture (after any cropping)\n");
#line 575
  printf("  -mt .................... use multi-threading if available\n");
#line 576
  printf("  -low_memory ............ reduce memory usage (slower encoding)\n");
#line 577
  printf("  -map <int> ............. print map of extra info\n");
#line 578
  printf("  -print_psnr ............ prints averaged PSNR distortion\n,\001V");
#line 579
  printf("  -print_ssim ............ prints averaged SSIM distortion\n,\001V");
#line 580
  printf("  -print_lsim ............ prints local-similarity distortion\n");
#line 581
  printf("  -d <file.pgm> .......... dump the compressed output (PGM file)\n\330p,\001V");
#line 582
  printf("  -alpha_method <int> .... transparency-compression method (0..1), default=1\n:q,\001V");
#line 584
  printf("  -alpha_filter <string> . predictive filtering for alpha plane,\n");
#line 585
  printf("                           one of: none, fast (default) or best\n\220");
#line 586
  printf("  -exact ................. preserve RGB values in transparent area, default=off\n");
#line 588
  printf("  -blend_alpha <hex> ..... blend colors against background color\n                           expressed as RGB values written in\n                           hexadecimal, e.g. 0xc0e0d0 for red=0xc0\n                           green=0xe0 and blue=0xd0\n");
#line 592
  printf("  -noalpha ............... discard any transparency information\n\220");
#line 593
  printf("  -lossless .............. encode image losslessly, default=off\n\220");
#line 594
  printf("  -near_lossless <int> ... use near-lossless image\n                           preprocessing (0..100=off), default=100\n");
#line 597
  printf("  -hint <string> ......... specify image characteristics hint,\n");
#line 598
  printf("                           one of: photo, picture or graph\n,\001V");
#line 600
  printf("\n");
#line 601
  printf("  -metadata <string> ..... comma separated list of metadata to\n");
#line 602
  printf("                           ,\001V");
#line 603
  printf("copy from the input to the output if present.\n");
#line 604
  printf("                           Valid values: all, none (default), exif, icc, xmp\n");
#line 607
  printf("\n\317p,\001V");
#line 608
  printf("  -short ................. condense printed message\n");
#line 609
  printf("  -quiet ................. don\'t print anything\n\220");
#line 610
  printf("  -version ............... print version number and exit\n");
#line 612
  printf("  -noasm ................. disable all assembly optimizations\n");
#line 614
  printf("  -v ..................... verbose, e.g. print encoding/decoding times\n,\001V");
#line 616
  printf("  -progress .............. report encoding progress\n\001V");
#line 617
  printf("\n");
#line 618
  printf("Experimental Options:\n");
#line 619
  printf("  -jpeg_like ............. roughly match expected JPEG size\n\001V");
#line 620
  printf("  -af .................... auto-adjust filter strength\n");
#line 621
  printf("  -pre <int> ............. pre-processing filter\n\036q,\001V");
#line 622
  printf("\nZq,\001V");
  }
#line 624
  return;
}
}
#line 628 "/root/patron-new/new_3/examples/cwebp.c"
static char const   * const  kErrorMessages[11]  = 
#line 628
  {      (char const   */* const  */)"OK",      (char const   */* const  */)"OUT_OF_MEMORY: Out of memory allocating objects",      (char const   */* const  */)"BITSTREAM_OUT_OF_MEMORY: Out of memory re-allocating byte buffer\323\001 ,\001",      (char const   */* const  */)"NULL_PARAMETER: NULL parameter passed to function", 
        (char const   */* const  */)"INVALID_CONFIGURATION: configuration is invalid",      (char const   */* const  */)"BAD_DIMENSION: Bad picture dimension. Maximum width and height allowed is 16383 pixels.,\001V",      (char const   */* const  */)"PARTITION0_OVERFLOW: Partition #0 is too big to fit 512k.\nTo reduce the size of this partition, try using less segments with the -segments option, and eventually reduce the number of header bits using -partition_limit. More details are available in the manual (`man cwebp`)",      (char const   */* const  */)"PARTITION_OVERFLOW: Partition is too big to fit 16M,\001V", 
        (char const   */* const  */)"BAD_WRITE: Picture writer returned an I/O error",      (char const   */* const  */)"FILE_TOO_BIG: File would be too big to fit in 4G\001",      (char const   */* const  */)"USER_ABORT: encoding abort requested by user"};
#line 780 "/root/patron-new/new_3/examples/cwebp.c"
static struct __anonstruct_1359 kTokens[5]  ;
#line 833 "/root/patron-new/new_3/examples/cwebp.c"
static char const   *distortion_names[3]  ;
#line 649 "/root/patron-new/new_3/examples/cwebp.c"
int main(int argc , char const   **argv ) 
{ 
  int return_value ;
  char const   *in_file ;
  char const   *out_file ;
  char const   *dump_file ;
  FILE *out ;
  int c ;
  int short_output ;
  int quiet ;
  int keep_alpha ;
  int blend_alpha ;
  uint32_t background_color ;
  int crop ;
  int crop_x ;
  int crop_y ;
  int crop_w ;
  int crop_h ;
  int resize_w ;
  int resize_h ;
  int lossless_preset ;
  int use_lossless_preset ;
  int show_progress ;
  int keep_metadata ;
  int metadata_written ;
  WebPPicture picture ;
  int print_distortion ;
  WebPPicture original_picture ;
  WebPConfig config ;
  WebPAuxStats stats ;
  WebPMemoryWriter memory_writer ;
  int use_memory_writer ;
  Metadata metadata ;
  Stopwatch stop_watch ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int parse_error ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  float __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  float __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  int version ;
  int __cil_tmp119 ;
  int __cil_tmp120 ;
  int __cil_tmp121 ;
  int __cil_tmp122 ;
  WebPPreset preset ;
  int __cil_tmp124 ;
  int __cil_tmp125 ;
  int __cil_tmp126 ;
  int __cil_tmp127 ;
  int __cil_tmp128 ;
  int __cil_tmp129 ;
  int __cil_tmp130 ;
  int __cil_tmp131 ;
  size_t kNumTokens ;
  char const   *start ;
  char const   *end ;
  unsigned long __cil_tmp136 ;
  size_t i ;
  char const   *token ;
  char *__cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  int __cil_tmp142 ;
  int __cil_tmp143 ;
  int __cil_tmp144 ;
  int __cil_tmp145 ;
  int __cil_tmp146 ;
  Metadata *tmp___2 ;
  int __cil_tmp148 ;
  int (*tmp___3)(int percent , WebPPicture * const  picture ) ;
  double read_time ;
  double __cil_tmp151 ;
  int use_stdout ;
  int __cil_tmp153 ;
  FILE *__cil_tmp154 ;
  FILE *__cil_tmp155 ;
  FILE *tmp___4 ;
  int __cil_tmp157 ;
  WebPPicture picture_no_alpha ;
  int __cil_tmp159 ;
  int x ;
  int y ;
  uint32_t *argb_no_alpha ;
  int __cil_tmp163 ;
  int __cil_tmp164 ;
  int x___0 ;
  int y___0 ;
  uint32_t *argb_no_alpha___0 ;
  uint32_t *argb ;
  double preproc_time ;
  double __cil_tmp170 ;
  int __cil_tmp171 ;
  int __cil_tmp172 ;
  double encode_time ;
  double __cil_tmp174 ;
  int __cil_tmp175 ;
  int __cil_tmp176 ;
  int __cil_tmp177 ;
  int __cil_tmp178 ;
  int __cil_tmp179 ;
  struct __anonstruct_1360 *iter ;
  struct __anonstruct_1360 info[4] ;
  uint32_t unused1 ;
  uint64_t unused2 ;
  float values[5] ;
  int __cil_tmp187 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 650
  return_value = -1;
#line 651
  in_file = (char const   *)((void *)0);
#line 651
  out_file = (char const   *)((void *)0);
#line 651
  dump_file = (char const   *)((void *)0);
#line 652
  out = (FILE *)((void *)0);
#line 654
  short_output = 0;
#line 655
  quiet = 0;
#line 656
  keep_alpha = 1;
#line 657
  blend_alpha = 0;
#line 658
  background_color = 16777215U;
#line 659
  crop = 0;
#line 659
  crop_x = 0;
#line 659
  crop_y = 0;
#line 659
  crop_w = 0;
#line 659
  crop_h = 0;
#line 660
  resize_w = 0;
#line 660
  resize_h = 0;
#line 661
  lossless_preset = 6;
#line 662
  use_lossless_preset = -1;
#line 663
  show_progress = 0;
#line 664
  keep_metadata = 0;
#line 665
  metadata_written = 0;
#line 667
  print_distortion = -1;
#line 678
  MetadataInit(& metadata);
#line 679
  WebPMemoryWriterInit(& memory_writer);
#line 680
  __cil_tmp37 = WebPConfigInit(& config);
#line 680
  __cil_tmp36 = WebPPictureInit(& original_picture);
#line 680
  __cil_tmp35 = WebPPictureInit(& picture);
  }
#line 680
  if (! __cil_tmp35) {
    _L: 
    {
#line 683
    fprintf(stderr, "Error! Version mismatch!\n");
    }
    {
#line 684
    while (1) {
      while_continue: /* CIL Label */ ;

#line 684
      return (-1);
#line 684
      goto while_break;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break: ;
  } else
#line 680
  if (! __cil_tmp36) {
#line 680
    goto _L;
  } else
#line 680
  if (! __cil_tmp37) {
#line 680
    goto _L;
  }
#line 687
  if (argc == 1) {
    {
#line 688
    HelpShort();
    }
    {
#line 689
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 689
      return (0);
#line 689
      goto while_break___0;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 692
  c = 1;
  {
#line 692
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 692
    if (! (c < argc)) {
#line 692
      goto while_break___1;
    }
    {
#line 693
    parse_error = 0;
#line 694
    __cil_tmp40 = strcmp(*(argv + c), "-help");
#line 694
    __cil_tmp39 = strcmp(*(argv + c), "-h");
    }
#line 694
    if (! __cil_tmp39) {
      _L___110: 
      {
#line 695
      HelpShort();
      }
      {
#line 696
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 696
        return (0);
#line 696
        goto while_break___2;
      }
      while_break___19: /* CIL Label */ ;
      }
      while_break___2: ;
    } else
#line 694
    if (! __cil_tmp40) {
#line 694
      goto _L___110;
    } else {
      {
#line 697
      __cil_tmp42 = strcmp(*(argv + c), "-longhelp");
#line 697
      __cil_tmp41 = strcmp(*(argv + c), "-H");
      }
#line 697
      if (! __cil_tmp41) {
        _L___109: 
        {
#line 698
        HelpLong();
        }
        {
#line 699
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 699
          return (0);
#line 699
          goto while_break___3;
        }
        while_break___20: /* CIL Label */ ;
        }
        while_break___3: ;
      } else
#line 697
      if (! __cil_tmp42) {
#line 697
        goto _L___109;
      } else {
        {
#line 700
        __cil_tmp43 = strcmp(*(argv + c), "-o");
        }
#line 700
        if (! __cil_tmp43) {
#line 700
          if (c + 1 < argc) {
#line 701
            c ++;
#line 701
            out_file = *(argv + c);
          } else {
#line 700
            goto _L___108;
          }
        } else {
          _L___108: 
          {
#line 702
          __cil_tmp44 = strcmp(*(argv + c), "-d");
          }
#line 702
          if (! __cil_tmp44) {
#line 702
            if (c + 1 < argc) {
#line 703
              c ++;
#line 703
              dump_file = *(argv + c);
#line 704
              config.show_compressed = 1;
            } else {
#line 702
              goto _L___107;
            }
          } else {
            _L___107: 
            {
#line 705
            __cil_tmp45 = strcmp(*(argv + c), "-print_psnr");
            }
#line 705
            if (! __cil_tmp45) {
#line 706
              config.show_compressed = 1;
#line 707
              print_distortion = 0;
            } else {
              {
#line 708
              __cil_tmp46 = strcmp(*(argv + c), "-print_ssim");
              }
#line 708
              if (! __cil_tmp46) {
#line 709
                config.show_compressed = 1;
#line 710
                print_distortion = 1;
              } else {
                {
#line 711
                __cil_tmp47 = strcmp(*(argv + c), "-print_lsim");
                }
#line 711
                if (! __cil_tmp47) {
#line 712
                  config.show_compressed = 1;
#line 713
                  print_distortion = 2;
                } else {
                  {
#line 714
                  __cil_tmp48 = strcmp(*(argv + c), "-short");
                  }
#line 714
                  if (! __cil_tmp48) {
#line 715
                    short_output ++;
                  } else {
                    {
#line 716
                    __cil_tmp49 = strcmp(*(argv + c), "-s");
                    }
#line 716
                    if (! __cil_tmp49) {
#line 716
                      if (c + 2 < argc) {
                        {
#line 717
                        c ++;
#line 717
                        __cil_tmp50 = ExUtilGetInt(*(argv + c), 0, & parse_error);
#line 717
                        picture.width = __cil_tmp50;
#line 718
                        c ++;
#line 718
                        __cil_tmp51 = ExUtilGetInt(*(argv + c), 0, & parse_error);
#line 718
                        picture.height = __cil_tmp51;
                        }
#line 719
                        if (picture.width > 16383) {
                          {
#line 721
                          fprintf(stderr, "Specified dimension (%d x %d) is out of range.\n",
                                  picture.width, picture.height);
                          }
#line 724
                          goto Error;
                        } else
#line 719
                        if (picture.width < 0) {
                          {
#line 721
                          fprintf(stderr, "Specified dimension (%d x %d) is out of range.\n",
                                  picture.width, picture.height);
                          }
#line 724
                          goto Error;
                        } else
#line 719
                        if (picture.height > 16383) {
                          {
#line 721
                          fprintf(stderr, "Specified dimension (%d x %d) is out of range.\n",
                                  picture.width, picture.height);
                          }
#line 724
                          goto Error;
                        } else
#line 719
                        if (picture.height < 0) {
                          {
#line 721
                          fprintf(stderr, "Specified dimension (%d x %d) is out of range.\n",
                                  picture.width, picture.height);
                          }
#line 724
                          goto Error;
                        }
                      } else {
#line 716
                        goto _L___106;
                      }
                    } else {
                      _L___106: 
                      {
#line 726
                      __cil_tmp52 = strcmp(*(argv + c), "-m");
                      }
#line 726
                      if (! __cil_tmp52) {
#line 726
                        if (c + 1 < argc) {
                          {
#line 727
                          c ++;
#line 727
                          __cil_tmp53 = ExUtilGetInt(*(argv + c), 0, & parse_error);
#line 727
                          config.method = __cil_tmp53;
#line 728
                          use_lossless_preset = 0;
                          }
                        } else {
#line 726
                          goto _L___105;
                        }
                      } else {
                        _L___105: 
                        {
#line 729
                        __cil_tmp54 = strcmp(*(argv + c), "-q");
                        }
#line 729
                        if (! __cil_tmp54) {
#line 729
                          if (c + 1 < argc) {
                            {
#line 730
                            c ++;
#line 730
                            __cil_tmp55 = ExUtilGetFloat(*(argv + c), & parse_error);
#line 730
                            config.quality = __cil_tmp55;
#line 731
                            use_lossless_preset = 0;
                            }
                          } else {
#line 729
                            goto _L___104;
                          }
                        } else {
                          _L___104: 
                          {
#line 732
                          __cil_tmp56 = strcmp(*(argv + c), "-z");
                          }
#line 732
                          if (! __cil_tmp56) {
#line 732
                            if (c + 1 < argc) {
                              {
#line 733
                              c ++;
#line 733
                              __cil_tmp57 = ExUtilGetInt(*(argv + c), 0, & parse_error);
#line 733
                              lossless_preset = __cil_tmp57;
                              }
#line 734
                              if (use_lossless_preset != 0) {
#line 734
                                use_lossless_preset = 1;
                              }
                            } else {
#line 732
                              goto _L___103;
                            }
                          } else {
                            _L___103: 
                            {
#line 735
                            __cil_tmp58 = strcmp(*(argv + c), "-alpha_q\220");
                            }
#line 735
                            if (! __cil_tmp58) {
#line 735
                              if (c + 1 < argc) {
                                {
#line 736
                                c ++;
#line 736
                                __cil_tmp59 = ExUtilGetInt(*(argv + c), 0, & parse_error);
#line 736
                                config.alpha_quality = __cil_tmp59;
                                }
                              } else {
#line 735
                                goto _L___102;
                              }
                            } else {
                              _L___102: 
                              {
#line 737
                              __cil_tmp60 = strcmp(*(argv + c), "-alpha_method");
                              }
#line 737
                              if (! __cil_tmp60) {
#line 737
                                if (c + 1 < argc) {
                                  {
#line 738
                                  c ++;
#line 738
                                  __cil_tmp61 = ExUtilGetInt(*(argv + c), 0, & parse_error);
#line 738
                                  config.alpha_compression = __cil_tmp61;
                                  }
                                } else {
#line 737
                                  goto _L___101;
                                }
                              } else {
                                _L___101: 
                                {
#line 739
                                __cil_tmp62 = strcmp(*(argv + c), "-alpha_cleanup");
                                }
#line 739
                                if (! __cil_tmp62) {
#line 741
                                  config.exact = 0;
                                } else {
                                  {
#line 742
                                  __cil_tmp63 = strcmp(*(argv + c), "-exact");
                                  }
#line 742
                                  if (! __cil_tmp63) {
#line 743
                                    config.exact = 1;
                                  } else {
                                    {
#line 744
                                    __cil_tmp64 = strcmp(*(argv + c), "-blend_alpha");
                                    }
#line 744
                                    if (! __cil_tmp64) {
#line 744
                                      if (c + 1 < argc) {
                                        {
#line 745
                                        blend_alpha = 1;
#line 747
                                        c ++;
#line 747
                                        __cil_tmp65 = ExUtilGetInt(*(argv + c), 16,
                                                                   & parse_error);
#line 747
                                        background_color = (uint32_t )__cil_tmp65;
#line 748
                                        background_color &= 16777215U;
                                        }
                                      } else {
#line 744
                                        goto _L___100;
                                      }
                                    } else {
                                      _L___100: 
                                      {
#line 749
                                      __cil_tmp66 = strcmp(*(argv + c), "-alpha_filter");
                                      }
#line 749
                                      if (! __cil_tmp66) {
#line 749
                                        if (c + 1 < argc) {
                                          {
#line 750
                                          c ++;
#line 751
                                          __cil_tmp67 = strcmp(*(argv + c), "none");
                                          }
#line 751
                                          if (! __cil_tmp67) {
#line 752
                                            config.alpha_filtering = 0;
                                          } else {
                                            {
#line 753
                                            __cil_tmp68 = strcmp(*(argv + c), "fast");
                                            }
#line 753
                                            if (! __cil_tmp68) {
#line 754
                                              config.alpha_filtering = 1;
                                            } else {
                                              {
#line 755
                                              __cil_tmp69 = strcmp(*(argv + c), "best");
                                              }
#line 755
                                              if (! __cil_tmp69) {
#line 756
                                                config.alpha_filtering = 2;
                                              } else {
                                                {
#line 758
                                                fprintf(stderr, "Error! Unrecognized alpha filter: %s\n",
                                                        *(argv + c));
                                                }
#line 759
                                                goto Error;
                                              }
                                            }
                                          }
                                        } else {
#line 749
                                          goto _L___99;
                                        }
                                      } else {
                                        _L___99: 
                                        {
#line 761
                                        __cil_tmp70 = strcmp(*(argv + c), "-noalpha\220");
                                        }
#line 761
                                        if (! __cil_tmp70) {
#line 762
                                          keep_alpha = 0;
                                        } else {
                                          {
#line 763
                                          __cil_tmp71 = strcmp(*(argv + c), "-lossless");
                                          }
#line 763
                                          if (! __cil_tmp71) {
#line 764
                                            config.lossless = 1;
                                          } else {
                                            {
#line 765
                                            __cil_tmp72 = strcmp(*(argv + c), "-near_lossless");
                                            }
#line 765
                                            if (! __cil_tmp72) {
#line 765
                                              if (c + 1 < argc) {
                                                {
#line 766
                                                c ++;
#line 766
                                                __cil_tmp73 = ExUtilGetInt(*(argv + c),
                                                                           0, & parse_error);
#line 766
                                                config.near_lossless = __cil_tmp73;
#line 767
                                                config.lossless = 1;
                                                }
                                              } else {
#line 765
                                                goto _L___98;
                                              }
                                            } else {
                                              _L___98: 
                                              {
#line 768
                                              __cil_tmp74 = strcmp(*(argv + c), "-hint");
                                              }
#line 768
                                              if (! __cil_tmp74) {
#line 768
                                                if (c + 1 < argc) {
                                                  {
#line 769
                                                  c ++;
#line 770
                                                  __cil_tmp75 = strcmp(*(argv + c),
                                                                       "photo");
                                                  }
#line 770
                                                  if (! __cil_tmp75) {
#line 771
                                                    config.image_hint = (WebPImageHint )2;
                                                  } else {
                                                    {
#line 772
                                                    __cil_tmp76 = strcmp(*(argv + c),
                                                                         "picture");
                                                    }
#line 772
                                                    if (! __cil_tmp76) {
#line 773
                                                      config.image_hint = (WebPImageHint )1;
                                                    } else {
                                                      {
#line 774
                                                      __cil_tmp77 = strcmp(*(argv + c),
                                                                           "graph");
                                                      }
#line 774
                                                      if (! __cil_tmp77) {
#line 775
                                                        config.image_hint = (WebPImageHint )3;
                                                      } else {
                                                        {
#line 777
                                                        fprintf(stderr, "Error! Unrecognized image hint: %s\n",
                                                                *(argv + c));
                                                        }
#line 778
                                                        goto Error;
                                                      }
                                                    }
                                                  }
                                                } else {
#line 768
                                                  goto _L___97;
                                                }
                                              } else {
                                                _L___97: 
                                                {
#line 780
                                                __cil_tmp78 = strcmp(*(argv + c),
                                                                     "-size");
                                                }
#line 780
                                                if (! __cil_tmp78) {
#line 780
                                                  if (c + 1 < argc) {
                                                    {
#line 781
                                                    c ++;
#line 781
                                                    __cil_tmp79 = ExUtilGetInt(*(argv + c),
                                                                               0,
                                                                               & parse_error);
#line 781
                                                    config.target_size = __cil_tmp79;
                                                    }
                                                  } else {
#line 780
                                                    goto _L___96;
                                                  }
                                                } else {
                                                  _L___96: 
                                                  {
#line 782
                                                  __cil_tmp80 = strcmp(*(argv + c),
                                                                       "-psnr");
                                                  }
#line 782
                                                  if (! __cil_tmp80) {
#line 782
                                                    if (c + 1 < argc) {
                                                      {
#line 783
                                                      c ++;
#line 783
                                                      __cil_tmp81 = ExUtilGetFloat(*(argv + c),
                                                                                   & parse_error);
#line 783
                                                      config.target_PSNR = __cil_tmp81;
                                                      }
                                                    } else {
#line 782
                                                      goto _L___95;
                                                    }
                                                  } else {
                                                    _L___95: 
                                                    {
#line 784
                                                    __cil_tmp82 = strcmp(*(argv + c),
                                                                         "-sns");
                                                    }
#line 784
                                                    if (! __cil_tmp82) {
#line 784
                                                      if (c + 1 < argc) {
                                                        {
#line 785
                                                        c ++;
#line 785
                                                        __cil_tmp83 = ExUtilGetInt(*(argv + c),
                                                                                   0,
                                                                                   & parse_error);
#line 785
                                                        config.sns_strength = __cil_tmp83;
                                                        }
                                                      } else {
#line 784
                                                        goto _L___94;
                                                      }
                                                    } else {
                                                      _L___94: 
                                                      {
#line 786
                                                      __cil_tmp84 = strcmp(*(argv + c),
                                                                           "-f");
                                                      }
#line 786
                                                      if (! __cil_tmp84) {
#line 786
                                                        if (c + 1 < argc) {
                                                          {
#line 787
                                                          c ++;
#line 787
                                                          __cil_tmp85 = ExUtilGetInt(*(argv + c),
                                                                                     0,
                                                                                     & parse_error);
#line 787
                                                          config.filter_strength = __cil_tmp85;
                                                          }
                                                        } else {
#line 786
                                                          goto _L___93;
                                                        }
                                                      } else {
                                                        _L___93: 
                                                        {
#line 788
                                                        __cil_tmp86 = strcmp(*(argv + c),
                                                                             "-af");
                                                        }
#line 788
                                                        if (! __cil_tmp86) {
#line 789
                                                          config.autofilter = 1;
                                                        } else {
                                                          {
#line 790
                                                          __cil_tmp87 = strcmp(*(argv + c),
                                                                               "-jpeg_like");
                                                          }
#line 790
                                                          if (! __cil_tmp87) {
#line 791
                                                            config.emulate_jpeg_size = 1;
                                                          } else {
                                                            {
#line 792
                                                            __cil_tmp88 = strcmp(*(argv + c),
                                                                                 "-mt");
                                                            }
#line 792
                                                            if (! __cil_tmp88) {
#line 793
                                                              (config.thread_level) ++;
                                                            } else {
                                                              {
#line 794
                                                              __cil_tmp89 = strcmp(*(argv + c),
                                                                                   "-low_memory");
                                                              }
#line 794
                                                              if (! __cil_tmp89) {
#line 795
                                                                config.low_memory = 1;
                                                              } else {
                                                                {
#line 796
                                                                __cil_tmp90 = strcmp(*(argv + c),
                                                                                     "-strong");
                                                                }
#line 796
                                                                if (! __cil_tmp90) {
#line 797
                                                                  config.filter_type = 1;
                                                                } else {
                                                                  {
#line 798
                                                                  __cil_tmp91 = strcmp(*(argv + c),
                                                                                       "-nostrong");
                                                                  }
#line 798
                                                                  if (! __cil_tmp91) {
#line 799
                                                                    config.filter_type = 0;
                                                                  } else {
                                                                    {
#line 800
                                                                    __cil_tmp92 = strcmp(*(argv + c),
                                                                                         "-sharpness");
                                                                    }
#line 800
                                                                    if (! __cil_tmp92) {
#line 800
                                                                      if (c + 1 < argc) {
                                                                        {
#line 801
                                                                        c ++;
#line 801
                                                                        __cil_tmp93 = ExUtilGetInt(*(argv + c),
                                                                                                   0,
                                                                                                   & parse_error);
#line 801
                                                                        config.filter_sharpness = __cil_tmp93;
                                                                        }
                                                                      } else {
#line 800
                                                                        goto _L___92;
                                                                      }
                                                                    } else {
                                                                      _L___92: 
                                                                      {
#line 802
                                                                      __cil_tmp94 = strcmp(*(argv + c),
                                                                                           "-sharp_yuv");
                                                                      }
#line 802
                                                                      if (! __cil_tmp94) {
#line 803
                                                                        config.use_sharp_yuv = 1;
                                                                      } else {
                                                                        {
#line 804
                                                                        __cil_tmp95 = strcmp(*(argv + c),
                                                                                             "-pass");
                                                                        }
#line 804
                                                                        if (! __cil_tmp95) {
#line 804
                                                                          if (c + 1 < argc) {
                                                                            {
#line 805
                                                                            c ++;
#line 805
                                                                            __cil_tmp96 = ExUtilGetInt(*(argv + c),
                                                                                                       0,
                                                                                                       & parse_error);
#line 805
                                                                            config.pass = __cil_tmp96;
                                                                            }
                                                                          } else {
#line 804
                                                                            goto _L___91;
                                                                          }
                                                                        } else {
                                                                          _L___91: 
                                                                          {
#line 806
                                                                          __cil_tmp97 = strcmp(*(argv + c),
                                                                                               "-qrange");
                                                                          }
#line 806
                                                                          if (! __cil_tmp97) {
#line 806
                                                                            if (c + 2 < argc) {
                                                                              {
#line 807
                                                                              c ++;
#line 807
                                                                              __cil_tmp98 = ExUtilGetInt(*(argv + c),
                                                                                                         0,
                                                                                                         & parse_error);
#line 807
                                                                              config.qmin = __cil_tmp98;
#line 808
                                                                              c ++;
#line 808
                                                                              __cil_tmp99 = ExUtilGetInt(*(argv + c),
                                                                                                         0,
                                                                                                         & parse_error);
#line 808
                                                                              config.qmax = __cil_tmp99;
                                                                              }
#line 809
                                                                              if (config.qmin < 0) {
#line 809
                                                                                config.qmin = 0;
                                                                              }
#line 810
                                                                              if (config.qmax > 100) {
#line 810
                                                                                config.qmax = 100;
                                                                              }
                                                                            } else {
#line 806
                                                                              goto _L___90;
                                                                            }
                                                                          } else {
                                                                            _L___90: 
                                                                            {
#line 811
                                                                            __cil_tmp100 = strcmp(*(argv + c),
                                                                                                  "-pre");
                                                                            }
#line 811
                                                                            if (! __cil_tmp100) {
#line 811
                                                                              if (c + 1 < argc) {
                                                                                {
#line 812
                                                                                c ++;
#line 812
                                                                                __cil_tmp101 = ExUtilGetInt(*(argv + c),
                                                                                                            0,
                                                                                                            & parse_error);
#line 812
                                                                                config.preprocessing = __cil_tmp101;
                                                                                }
                                                                              } else {
#line 811
                                                                                goto _L___89;
                                                                              }
                                                                            } else {
                                                                              _L___89: 
                                                                              {
#line 813
                                                                              __cil_tmp102 = strcmp(*(argv + c),
                                                                                                    "-segments");
                                                                              }
#line 813
                                                                              if (! __cil_tmp102) {
#line 813
                                                                                if (c + 1 < argc) {
                                                                                  {
#line 814
                                                                                  c ++;
#line 814
                                                                                  __cil_tmp103 = ExUtilGetInt(*(argv + c),
                                                                                                              0,
                                                                                                              & parse_error);
#line 814
                                                                                  config.segments = __cil_tmp103;
                                                                                  }
                                                                                } else {
#line 813
                                                                                  goto _L___88;
                                                                                }
                                                                              } else {
                                                                                _L___88: 
                                                                                {
#line 815
                                                                                __cil_tmp104 = strcmp(*(argv + c),
                                                                                                      "-partition_limit\220");
                                                                                }
#line 815
                                                                                if (! __cil_tmp104) {
#line 815
                                                                                  if (c + 1 < argc) {
                                                                                    {
#line 816
                                                                                    c ++;
#line 816
                                                                                    __cil_tmp105 = ExUtilGetInt(*(argv + c),
                                                                                                                0,
                                                                                                                & parse_error);
#line 816
                                                                                    config.partition_limit = __cil_tmp105;
                                                                                    }
                                                                                  } else {
#line 815
                                                                                    goto _L___87;
                                                                                  }
                                                                                } else {
                                                                                  _L___87: 
                                                                                  {
#line 817
                                                                                  __cil_tmp106 = strcmp(*(argv + c),
                                                                                                        "-map");
                                                                                  }
#line 817
                                                                                  if (! __cil_tmp106) {
#line 817
                                                                                    if (c + 1 < argc) {
                                                                                      {
#line 818
                                                                                      c ++;
#line 818
                                                                                      __cil_tmp107 = ExUtilGetInt(*(argv + c),
                                                                                                                  0,
                                                                                                                  & parse_error);
#line 818
                                                                                      picture.extra_info_type = __cil_tmp107;
                                                                                      }
                                                                                    } else {
#line 817
                                                                                      goto _L___86;
                                                                                    }
                                                                                  } else {
                                                                                    _L___86: 
                                                                                    {
#line 819
                                                                                    __cil_tmp108 = strcmp(*(argv + c),
                                                                                                          "-crop");
                                                                                    }
#line 819
                                                                                    if (! __cil_tmp108) {
#line 819
                                                                                      if (c + 4 < argc) {
                                                                                        {
#line 820
                                                                                        crop = 1;
#line 821
                                                                                        c ++;
#line 821
                                                                                        __cil_tmp109 = ExUtilGetInt(*(argv + c),
                                                                                                                    0,
                                                                                                                    & parse_error);
#line 821
                                                                                        crop_x = __cil_tmp109;
#line 822
                                                                                        c ++;
#line 822
                                                                                        __cil_tmp110 = ExUtilGetInt(*(argv + c),
                                                                                                                    0,
                                                                                                                    & parse_error);
#line 822
                                                                                        crop_y = __cil_tmp110;
#line 823
                                                                                        c ++;
#line 823
                                                                                        __cil_tmp111 = ExUtilGetInt(*(argv + c),
                                                                                                                    0,
                                                                                                                    & parse_error);
#line 823
                                                                                        crop_w = __cil_tmp111;
#line 824
                                                                                        c ++;
#line 824
                                                                                        __cil_tmp112 = ExUtilGetInt(*(argv + c),
                                                                                                                    0,
                                                                                                                    & parse_error);
#line 824
                                                                                        crop_h = __cil_tmp112;
                                                                                        }
                                                                                      } else {
#line 819
                                                                                        goto _L___85;
                                                                                      }
                                                                                    } else {
                                                                                      _L___85: 
                                                                                      {
#line 825
                                                                                      __cil_tmp113 = strcmp(*(argv + c),
                                                                                                            "-resize");
                                                                                      }
#line 825
                                                                                      if (! __cil_tmp113) {
#line 825
                                                                                        if (c + 2 < argc) {
                                                                                          {
#line 826
                                                                                          c ++;
#line 826
                                                                                          __cil_tmp114 = ExUtilGetInt(*(argv + c),
                                                                                                                      0,
                                                                                                                      & parse_error);
#line 826
                                                                                          resize_w = __cil_tmp114;
#line 827
                                                                                          c ++;
#line 827
                                                                                          __cil_tmp115 = ExUtilGetInt(*(argv + c),
                                                                                                                      0,
                                                                                                                      & parse_error);
#line 827
                                                                                          resize_h = __cil_tmp115;
                                                                                          }
                                                                                        } else {
#line 825
                                                                                          goto _L___84;
                                                                                        }
                                                                                      } else {
                                                                                        _L___84: 
                                                                                        {
#line 829
                                                                                        __cil_tmp116 = strcmp(*(argv + c),
                                                                                                              "-noasm");
                                                                                        }
#line 829
                                                                                        if (! __cil_tmp116) {
#line 830
                                                                                          VP8GetCPUInfo = (int (*)(CPUFeature  ))((void *)0);
                                                                                        } else {
                                                                                          {
#line 832
                                                                                          __cil_tmp117 = strcmp(*(argv + c),
                                                                                                                "-version\220");
                                                                                          }
#line 832
                                                                                          if (! __cil_tmp117) {
                                                                                            {
#line 833
                                                                                            __cil_tmp119 = WebPGetEncoderVersion();
#line 833
                                                                                            version = __cil_tmp119;
#line 834
                                                                                            printf("%d.%d.%d\n",
                                                                                                   (version >> 16) & 255,
                                                                                                   (version >> 8) & 255,
                                                                                                   version & 255);
                                                                                            }
                                                                                            {
#line 836
                                                                                            while (1) {
                                                                                              while_continue___4: /* CIL Label */ ;

#line 836
                                                                                              return (0);
#line 836
                                                                                              goto while_break___4;
                                                                                            }
                                                                                            while_break___21: /* CIL Label */ ;
                                                                                            }
                                                                                            while_break___4: ;
                                                                                          } else {
                                                                                            {
#line 837
                                                                                            __cil_tmp120 = strcmp(*(argv + c),
                                                                                                                  "-progress");
                                                                                            }
#line 837
                                                                                            if (! __cil_tmp120) {
#line 838
                                                                                              show_progress = 1;
                                                                                            } else {
                                                                                              {
#line 839
                                                                                              __cil_tmp121 = strcmp(*(argv + c),
                                                                                                                    "-quiet");
                                                                                              }
#line 839
                                                                                              if (! __cil_tmp121) {
#line 840
                                                                                                quiet = 1;
                                                                                              } else {
                                                                                                {
#line 841
                                                                                                __cil_tmp122 = strcmp(*(argv + c),
                                                                                                                      "-preset");
                                                                                                }
#line 841
                                                                                                if (! __cil_tmp122) {
#line 841
                                                                                                  if (c + 1 < argc) {
                                                                                                    {
#line 843
                                                                                                    c ++;
#line 844
                                                                                                    __cil_tmp124 = strcmp(*(argv + c),
                                                                                                                          "default");
                                                                                                    }
#line 844
                                                                                                    if (! __cil_tmp124) {
#line 845
                                                                                                      preset = (WebPPreset )0;
                                                                                                    } else {
                                                                                                      {
#line 846
                                                                                                      __cil_tmp125 = strcmp(*(argv + c),
                                                                                                                            "photo");
                                                                                                      }
#line 846
                                                                                                      if (! __cil_tmp125) {
#line 847
                                                                                                        preset = (WebPPreset )2;
                                                                                                      } else {
                                                                                                        {
#line 848
                                                                                                        __cil_tmp126 = strcmp(*(argv + c),
                                                                                                                              "picture");
                                                                                                        }
#line 848
                                                                                                        if (! __cil_tmp126) {
#line 849
                                                                                                          preset = (WebPPreset )1;
                                                                                                        } else {
                                                                                                          {
#line 850
                                                                                                          __cil_tmp127 = strcmp(*(argv + c),
                                                                                                                                "drawing");
                                                                                                          }
#line 850
                                                                                                          if (! __cil_tmp127) {
#line 851
                                                                                                            preset = (WebPPreset )3;
                                                                                                          } else {
                                                                                                            {
#line 852
                                                                                                            __cil_tmp128 = strcmp(*(argv + c),
                                                                                                                                  "icon");
                                                                                                            }
#line 852
                                                                                                            if (! __cil_tmp128) {
#line 853
                                                                                                              preset = (WebPPreset )4;
                                                                                                            } else {
                                                                                                              {
#line 854
                                                                                                              __cil_tmp129 = strcmp(*(argv + c),
                                                                                                                                    "text");
                                                                                                              }
#line 854
                                                                                                              if (! __cil_tmp129) {
#line 855
                                                                                                                preset = (WebPPreset )5;
                                                                                                              } else {
                                                                                                                {
#line 857
                                                                                                                fprintf(stderr,
                                                                                                                        "Error! Unrecognized preset: %s\n",
                                                                                                                        *(argv + c));
                                                                                                                }
#line 858
                                                                                                                goto Error;
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                    {
#line 860
                                                                                                    __cil_tmp130 = WebPConfigPreset(& config,
                                                                                                                                    preset,
                                                                                                                                    config.quality);
                                                                                                    }
#line 860
                                                                                                    if (! __cil_tmp130) {
                                                                                                      {
#line 861
                                                                                                      fprintf(stderr,
                                                                                                              "Error! Could initialize configuration with preset.\n");
                                                                                                      }
#line 862
                                                                                                      goto Error;
                                                                                                    }
                                                                                                  } else {
#line 841
                                                                                                    goto _L___83;
                                                                                                  }
                                                                                                } else {
                                                                                                  _L___83: 
                                                                                                  {
#line 864
                                                                                                  __cil_tmp131 = strcmp(*(argv + c),
                                                                                                                        "-metadata");
                                                                                                  }
#line 864
                                                                                                  if (! __cil_tmp131) {
#line 864
                                                                                                    if (c + 1 < argc) {
                                                                                                      {
#line 875
                                                                                                      kNumTokens = sizeof(kTokens) / sizeof(kTokens[0]);
#line 876
                                                                                                      c ++;
#line 876
                                                                                                      start = *(argv + c);
#line 877
                                                                                                      __cil_tmp136 = strlen(start);
#line 877
                                                                                                      end = start + __cil_tmp136;
                                                                                                      }
                                                                                                      {
#line 879
                                                                                                      while (1) {
                                                                                                        while_continue___5: /* CIL Label */ ;

#line 879
                                                                                                        if (! ((unsigned long )start < (unsigned long )end)) {
#line 879
                                                                                                          goto while_break___5;
                                                                                                        }
                                                                                                        {
#line 881
                                                                                                        __cil_tmp139 = strchr(start,
                                                                                                                              ',');
#line 881
                                                                                                        token = (char const   *)__cil_tmp139;
                                                                                                        }
#line 882
                                                                                                        if ((unsigned long )token == (unsigned long )((void *)0)) {
#line 882
                                                                                                          token = end;
                                                                                                        }
#line 884
                                                                                                        i = (size_t )0;
                                                                                                        {
#line 884
                                                                                                        while (1) {
                                                                                                          while_continue___6: /* CIL Label */ ;

#line 884
                                                                                                          if (! (i < kNumTokens)) {
#line 884
                                                                                                            goto while_break___6;
                                                                                                          }
#line 885
                                                                                                          if ((size_t )(token - start) == __cil_tmp140) {
#line 885
                                                                                                            if (! __cil_tmp142) {
#line 890
                                                                                                              keep_metadata = 0;
#line 892
                                                                                                              goto while_break___6;
                                                                                                            }
                                                                                                          }
#line 884
                                                                                                          i ++;
                                                                                                        }
                                                                                                        while_break___23: /* CIL Label */ ;
                                                                                                        }
                                                                                                        while_break___6: ;
#line 895
                                                                                                        if (i == kNumTokens) {
                                                                                                          {
#line 896
                                                                                                          fprintf(stderr,
                                                                                                                  "Error! Unknown metadata type \'%.*s\'\n",
                                                                                                                  (int )(token - start),
                                                                                                                  start);
                                                                                                          }
                                                                                                          {
#line 898
                                                                                                          while (1) {
                                                                                                            while_continue___7: /* CIL Label */ ;

#line 898
                                                                                                            return (-1);
#line 898
                                                                                                            goto while_break___7;
                                                                                                          }
                                                                                                          while_break___24: /* CIL Label */ ;
                                                                                                          }
                                                                                                          while_break___7: ;
                                                                                                        }
#line 900
                                                                                                        start = token + 1;
                                                                                                      }
                                                                                                      while_break___22: /* CIL Label */ ;
                                                                                                      }
                                                                                                      while_break___5: ;
                                                                                                    } else {
#line 864
                                                                                                      goto _L___82;
                                                                                                    }
                                                                                                  } else {
                                                                                                    _L___82: 
                                                                                                    {
#line 909
                                                                                                    __cil_tmp143 = strcmp(*(argv + c),
                                                                                                                          "-v");
                                                                                                    }
#line 909
                                                                                                    if (! __cil_tmp143) {
#line 910
                                                                                                      verbose = 1;
                                                                                                    } else {
                                                                                                      {
#line 911
                                                                                                      __cil_tmp144 = strcmp(*(argv + c),
                                                                                                                            "--");
                                                                                                      }
#line 911
                                                                                                      if (! __cil_tmp144) {
#line 912
                                                                                                        if (c + 1 < argc) {
#line 912
                                                                                                          c ++;
#line 912
                                                                                                          in_file = *(argv + c);
                                                                                                        }
#line 913
                                                                                                        goto while_break___1;
                                                                                                      } else
#line 914
                                                                                                      if ((int )*(*(argv + c) + 0) == 45) {
                                                                                                        {
#line 915
                                                                                                        fprintf(stderr,
                                                                                                                "Error! Unknown option \'%s\'\n",
                                                                                                                *(argv + c));
#line 916
                                                                                                        HelpLong();
                                                                                                        }
                                                                                                        {
#line 917
                                                                                                        while (1) {
                                                                                                          while_continue___8: /* CIL Label */ ;

#line 917
                                                                                                          return (-1);
#line 917
                                                                                                          goto while_break___8;
                                                                                                        }
                                                                                                        while_break___25: /* CIL Label */ ;
                                                                                                        }
                                                                                                        while_break___8: ;
                                                                                                      } else {
#line 919
                                                                                                        in_file = *(argv + c);
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 922
    if (parse_error) {
      {
#line 923
      HelpLong();
      }
      {
#line 924
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 924
        return (-1);
#line 924
        goto while_break___9;
      }
      while_break___26: /* CIL Label */ ;
      }
      while_break___9: ;
    }
#line 692
    c ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___1: ;
#line 927
  if ((unsigned long )in_file == (unsigned long )((void *)0)) {
    {
#line 928
    fprintf(stderr, "No input file specified!\n");
#line 929
    HelpShort();
    }
#line 930
    goto Error;
  }
#line 933
  if (use_lossless_preset == 1) {
    {
#line 934
    __cil_tmp145 = WebPConfigLosslessPreset(& config, lossless_preset);
    }
#line 934
    if (! __cil_tmp145) {
      {
#line 935
      fprintf(stderr, "Invalid lossless preset (-z %d)\n\230\001", lossless_preset);
      }
#line 936
      goto Error;
    }
  }
#line 942
  if (! quiet) {
#line 942
    if (config.lossless == 1) {
#line 943
      if (config.target_size > 0) {
        {
#line 944
        fprintf(stderr, "Encoding for specified size or PSNR is not supported for lossless encoding. Ignoring such option(s)!\n");
        }
      } else
#line 943
      if (config.target_PSNR > (float )0) {
        {
#line 944
        fprintf(stderr, "Encoding for specified size or PSNR is not supported for lossless encoding. Ignoring such option(s)!\n");
        }
      }
#line 947
      if (config.partition_limit > 0) {
        {
#line 948
        fprintf(stderr, "Partition limit option is not required for lossless encoding. Ignoring this option!\n\220");
        }
      }
    }
  }
#line 954
  if (config.target_size > 0) {
    _L___111: 
#line 955
    if (config.pass == 1) {
#line 955
      config.pass = 6;
    }
  } else
#line 954
  if (config.target_PSNR > (float )0) {
#line 954
    goto _L___111;
  }
  {
#line 958
  __cil_tmp146 = WebPValidateConfig(& config);
  }
#line 958
  if (! __cil_tmp146) {
    {
#line 959
    fprintf(stderr, "Error! Invalid configuration.\n");
    }
#line 960
    goto Error;
  }
#line 966
  if (config.lossless) {
#line 966
    tmp___5 = 1;
  } else
#line 966
  if (config.use_sharp_yuv) {
#line 966
    tmp___5 = 1;
  } else
#line 966
  if (config.preprocessing > 0) {
#line 966
    tmp___5 = 1;
  } else
#line 966
  if (crop) {
#line 966
    tmp___5 = 1;
  } else
#line 966
  if ((resize_w | resize_h) > 0) {
#line 966
    tmp___5 = 1;
  } else {
#line 966
    tmp___5 = 0;
  }
#line 966
  picture.use_argb = tmp___5;
#line 969
  if (verbose) {
    {
#line 970
    StopwatchReset(& stop_watch);
    }
  }
#line 972
  if (keep_metadata == 0) {
#line 972
    tmp___2 = (Metadata *)((void *)0);
  } else {
#line 972
    tmp___2 = & metadata;
  }
  {
#line 972
  __cil_tmp148 = ReadPicture(in_file, & picture, keep_alpha, tmp___2);
  }
#line 972
  if (! __cil_tmp148) {
    {
#line 974
    fprintf(stderr, "Error! Cannot read input picture file \'%s\'\n", in_file);
    }
#line 976
    goto Error;
  }
#line 978
  if (show_progress) {
#line 978
    if (! quiet) {
#line 978
      tmp___3 = (int (*)(int percent , WebPPicture * const  picture ))(& ProgressReport);
    } else {
#line 978
      tmp___3 = (int (*)(int  , WebPPicture * const   ))((void *)0);
    }
  } else {
#line 978
    tmp___3 = (int (*)(int  , WebPPicture * const   ))((void *)0);
  }
#line 978
  picture.progress_hook = (int (*)(int  , WebPPicture * ))tmp___3;
#line 980
  if (blend_alpha) {
    {
#line 981
    WebPBlendAlpha(& picture, background_color);
    }
  }
#line 984
  if (verbose) {
    {
#line 985
    __cil_tmp151 = StopwatchReadAndReset(& stop_watch);
#line 985
    read_time = __cil_tmp151;
#line 986
    fprintf(stderr, "Time to read input: %.3fs\nN,\001V", read_time);
    }
  }
#line 993
  if ((unsigned long )out_file != (unsigned long )((void *)0)) {
#line 993
    if (keep_metadata) {
#line 993
      tmp___6 = 1;
    } else {
#line 993
      goto _L___113;
    }
  } else
  _L___113: /* CIL Label */ 
#line 993
  if (! quiet) {
#line 993
    if (print_distortion >= 0) {
#line 993
      if (config.lossless) {
#line 993
        if (config.near_lossless < 100) {
#line 993
          tmp___6 = 1;
        } else {
#line 993
          tmp___6 = 0;
        }
      } else {
#line 993
        tmp___6 = 0;
      }
    } else {
#line 993
      tmp___6 = 0;
    }
  } else {
#line 993
    tmp___6 = 0;
  }
#line 993
  use_memory_writer = tmp___6;
#line 998
  if ((unsigned long )out_file != (unsigned long )((void *)0)) {
    {
#line 999
    __cil_tmp153 = strcmp(out_file, "-");
#line 999
    use_stdout = ! __cil_tmp153;
    }
#line 1000
    if (use_stdout) {
      {
#line 1000
      __cil_tmp154 = ImgIoUtilSetBinaryMode(stdout);
#line 1000
      tmp___4 = __cil_tmp154;
      }
    } else {
      {
#line 1000
      __cil_tmp155 = fopen(out_file, "wb");
#line 1000
      tmp___4 = __cil_tmp155;
      }
    }
#line 1000
    out = tmp___4;
#line 1001
    if ((unsigned long )out == (unsigned long )((void *)0)) {
      {
#line 1002
      fprintf(stderr, "Error! Cannot open output file \'%s\'\n", out_file);
      }
#line 1004
      goto Error;
    } else
#line 1006
    if (! short_output) {
#line 1006
      if (! quiet) {
        {
#line 1007
        fprintf(stderr, "Saving file \'%s\'\n", out_file);
        }
      }
    }
#line 1010
    if (use_memory_writer) {
#line 1011
      picture.writer = & WebPMemoryWrite;
#line 1012
      picture.custom_ptr = (void *)(& memory_writer);
    } else {
#line 1014
      picture.writer = & MyWriter;
#line 1015
      picture.custom_ptr = (void *)out;
    }
  } else {
#line 1018
    out = (FILE *)((void *)0);
#line 1019
    if (use_memory_writer) {
#line 1020
      picture.writer = & WebPMemoryWrite;
#line 1021
      picture.custom_ptr = (void *)(& memory_writer);
    }
#line 1023
    if (! quiet) {
#line 1023
      if (! short_output) {
        {
#line 1024
        fprintf(stderr, "No output file specified (no -o flag). Encoding will\n");
#line 1025
        fprintf(stderr, "be performed, but its results discarded.\n\n");
        }
      }
    }
  }
#line 1028
  if (! quiet) {
#line 1029
    picture.stats = & stats;
#line 1030
    picture.user_data = (void *)in_file;
  }
#line 1034
  if (verbose) {
    {
#line 1035
    StopwatchReset(& stop_watch);
    }
  }
#line 1037
  if (crop != 0) {
    {
#line 1039
    __cil_tmp157 = WebPPictureView(& picture, crop_x, crop_y, crop_w, crop_h, & picture);
    }
#line 1039
    if (! __cil_tmp157) {
      {
#line 1040
      fprintf(stderr, "Error! Cannot crop picture\n");
      }
#line 1041
      goto Error;
    }
  }
#line 1044
  if ((resize_w | resize_h) > 0) {
#line 1046
    if (config.exact) {
      {
#line 1051
      __cil_tmp159 = WebPPictureCopy(& picture, & picture_no_alpha);
      }
#line 1051
      if (! __cil_tmp159) {
        {
#line 1052
        fprintf(stderr, "Error! Cannot copy temporary picture\n");
        }
#line 1053
        goto Error;
      }
#line 1059
      argb_no_alpha = picture_no_alpha.argb;
#line 1060
      y = 0;
      {
#line 1060
      while (1) {
        while_continue___10: /* CIL Label */ ;

#line 1060
        if (! (y < picture_no_alpha.height)) {
#line 1060
          goto while_break___10;
        }
#line 1061
        x = 0;
        {
#line 1061
        while (1) {
          while_continue___11: /* CIL Label */ ;

#line 1061
          if (! (x < picture_no_alpha.width)) {
#line 1061
            goto while_break___11;
          }
#line 1062
          *(argb_no_alpha + x) |= 4278190080U;
#line 1061
          x ++;
        }
        while_break___28: /* CIL Label */ ;
        }
        while_break___11: 
#line 1064
        argb_no_alpha += picture_no_alpha.argb_stride;
#line 1060
        y ++;
      }
      while_break___27: /* CIL Label */ ;
      }
      while_break___10: 
      {
#line 1068
      __cil_tmp163 = WebPPictureRescale(& picture_no_alpha, resize_w, resize_h);
      }
#line 1068
      if (! __cil_tmp163) {
        {
#line 1069
        fprintf(stderr, "Error! Cannot resize temporary picture\n");
        }
#line 1070
        goto Error;
      }
    }
    {
#line 1074
    __cil_tmp164 = WebPPictureRescale(& picture, resize_w, resize_h);
    }
#line 1074
    if (! __cil_tmp164) {
      {
#line 1075
      fprintf(stderr, "Error! Cannot resize picture\n");
      }
#line 1076
      goto Error;
    }
#line 1079
    if (config.exact) {
#line 1081
      argb_no_alpha___0 = picture_no_alpha.argb;
#line 1082
      argb = picture.argb;
#line 1083
      y___0 = 0;
      {
#line 1083
      while (1) {
        while_continue___12: /* CIL Label */ ;

#line 1083
        if (! (y___0 < picture_no_alpha.height)) {
#line 1083
          goto while_break___12;
        }
#line 1084
        x___0 = 0;
        {
#line 1084
        while (1) {
          while_continue___13: /* CIL Label */ ;

#line 1084
          if (! (x___0 < picture_no_alpha.width)) {
#line 1084
            goto while_break___13;
          }
#line 1085
          *(argb + x___0) = (*(argb + x___0) & 4278190080U) | (*(argb_no_alpha___0 + x___0) & 16777215U);
#line 1084
          x___0 ++;
        }
        while_break___30: /* CIL Label */ ;
        }
        while_break___13: 
#line 1087
        argb_no_alpha___0 += picture_no_alpha.argb_stride;
#line 1088
        argb += picture.argb_stride;
#line 1083
        y___0 ++;
      }
      while_break___29: /* CIL Label */ ;
      }
      while_break___12: 
      {
#line 1090
      WebPPictureFree(& picture_no_alpha);
      }
    }
  }
#line 1093
  if (verbose) {
#line 1093
    if (crop != 0) {
      {
#line 1094
      __cil_tmp170 = StopwatchReadAndReset(& stop_watch);
#line 1094
      preproc_time = __cil_tmp170;
#line 1095
      fprintf(stderr, "Time to crop/resize picture: %.3fs\n", preproc_time);
      }
    } else
#line 1093
    if ((resize_w | resize_h) > 0) {
      {
#line 1094
      __cil_tmp170 = StopwatchReadAndReset(& stop_watch);
#line 1094
      preproc_time = __cil_tmp170;
#line 1095
      fprintf(stderr, "Time to crop/resize picture: %.3fs\n", preproc_time);
      }
    }
  }
#line 1098
  if (picture.extra_info_type > 0) {
    {
#line 1099
    AllocExtraInfo(& picture);
    }
  }
  {
#line 1103
  __cil_tmp171 = WebPPictureCopy(& picture, & original_picture);
  }
#line 1103
  if (print_distortion >= 0) {
#line 1103
    if (! config.lossless) {
#line 1103
      if (! __cil_tmp171) {
        {
#line 1105
        fprintf(stderr, "Error! Cannot copy temporary picture\n");
        }
#line 1106
        goto Error;
      }
    }
  }
#line 1110
  if (verbose) {
    {
#line 1111
    StopwatchReset(& stop_watch);
    }
  }
  {
#line 1113
  __cil_tmp172 = WebPEncode(& config, & picture);
  }
#line 1113
  if (! __cil_tmp172) {
    {
#line 1114
    fprintf(stderr, "Error! Cannot encode picture as WebP\n");
#line 1115
    fprintf(stderr, "Error code: %d (%s)\n", (unsigned int )picture.error_code, kErrorMessages[picture.error_code]);
    }
#line 1117
    goto Error;
  }
#line 1119
  if (verbose) {
    {
#line 1120
    __cil_tmp174 = StopwatchReadAndReset(& stop_watch);
#line 1120
    encode_time = __cil_tmp174;
#line 1121
    fprintf(stderr, "Time to encode picture: %.3fs\n", encode_time);
    }
  }
#line 1125
  if (! quiet) {
#line 1125
    if (print_distortion >= 0) {
#line 1125
      if (config.lossless) {
#line 1126
        if (config.near_lossless == 100) {
#line 1129
          original_picture = picture;
#line 1130
          original_picture.memory_argb_ = (void *)0;
#line 1130
          original_picture.memory_ = original_picture.memory_argb_;
        } else {
          {
#line 1135
          original_picture = picture;
#line 1136
          __cil_tmp175 = WebPPictureInit(& picture);
          }
#line 1136
          if (! __cil_tmp175) {
            {
#line 1137
            fprintf(stderr, "Error! Version mismatch!\n");
            }
#line 1138
            goto Error;
          }
          {
#line 1141
          picture.use_argb = 1;
#line 1142
          __cil_tmp176 = WebPPictureHasTransparency(& picture);
#line 1142
          __cil_tmp177 = ReadWebP(memory_writer.mem, memory_writer.size, & picture,
                                  __cil_tmp176, (struct Metadata *)((void *)0));
          }
#line 1142
          if (! __cil_tmp177) {
            {
#line 1145
            fprintf(stderr, "Error! Cannot decode encoded WebP bitstream\n");
#line 1146
            fprintf(stderr, "Error code: %d (%s)\n", (unsigned int )picture.error_code,
                    kErrorMessages[picture.error_code]);
            }
#line 1148
            goto Error;
          }
#line 1150
          picture.stats = original_picture.stats;
        }
#line 1152
        original_picture.stats = (WebPAuxStats *)((void *)0);
      }
    }
  }
#line 1156
  if (dump_file) {
#line 1157
    if (picture.use_argb) {
      {
#line 1158
      fprintf(stderr, "Warning: can\'t dump file (-d option) in lossless mode.\n");
      }
    } else {
      {
#line 1160
      __cil_tmp178 = DumpPicture(& picture, dump_file);
      }
#line 1160
      if (! __cil_tmp178) {
        {
#line 1161
        fprintf(stderr, "Warning, couldn\'t dump picture %s\n", dump_file);
        }
      }
    }
  }
  {
#line 1166
  __cil_tmp179 = WriteWebPWithMetadata(out, & picture, & memory_writer, & metadata,
                                       keep_metadata, & metadata_written);
  }
#line 1166
  if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 1166
    if (use_memory_writer) {
#line 1166
      if (! __cil_tmp179) {
        {
#line 1169
        fprintf(stderr, "Error writing WebP file!\n");
        }
#line 1170
        goto Error;
      }
    }
  }
#line 1173
  if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 1173
    if (keep_metadata) {
#line 1182
      unused1 = (uint32_t )0;
#line 1183
      unused2 = (uint64_t )0;
#line 1185
      iter = info;
      {
#line 1185
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 1185
        iter ++;
      }
      while_break___31: /* CIL Label */ ;
      }

    }
  }
#line 1193
  if (! quiet) {
#line 1194
    if (! short_output) {
      _L___112: 
#line 1195
      if (config.lossless) {
        {
#line 1196
        PrintExtraInfoLossless(& picture, short_output, in_file);
        }
      } else {
        {
#line 1198
        PrintExtraInfoLossy(& picture, short_output, config.low_memory, in_file);
        }
      }
    } else
#line 1194
    if (print_distortion < 0) {
#line 1194
      goto _L___112;
    }
#line 1201
    if (! short_output) {
#line 1201
      if (picture.extra_info_type > 0) {
        {
#line 1202
        PrintMapInfo(& picture);
        }
      }
    }
#line 1204
    if (print_distortion >= 0) {
      {
#line 1205
      strcpy((char *)distortion_names[0], "PSNR");
#line 1205
      strcpy((char *)distortion_names[1], "SSIM");
#line 1205
      strcpy((char *)distortion_names[2], "LSIM");
#line 1207
      __cil_tmp187 = WebPPictureDistortion(& picture, & original_picture, print_distortion,
                                           (float *)(values));
      }
#line 1207
      if (! __cil_tmp187) {
        {
#line 1209
        fprintf(stderr, "Error while computing the distortion.\n");
        }
#line 1210
        goto Error;
      }
#line 1212
      if (! short_output) {
        {
#line 1213
        fprintf(stderr, "%s: ", distortion_names[print_distortion]);
#line 1214
        fprintf(stderr, "B:%.2f G:%.2f R:%.2f A:%.2f  Total:%.2f\n\230\001", (double )values[0],
                (double )values[1], (double )values[2], (double )values[3], (double )values[4]);
        }
      } else {
        {
#line 1217
        fprintf(stderr, "%7d %.4f\n", (picture.stats)->coded_size, (double )values[4]);
        }
      }
    }
#line 1220
    if (! short_output) {
      {
#line 1221
      PrintMetadataInfo(& metadata, metadata_written);
      }
    }
  }
#line 1224
  return_value = 0;
  Error: 
  {
#line 1227
  WebPMemoryWriterClear(& memory_writer);
#line 1228
  WebPFree((void *)picture.extra_info);
#line 1229
  MetadataFree(& metadata);
#line 1230
  WebPPictureFree(& picture);
#line 1231
  WebPPictureFree(& original_picture);
  }
#line 1232
  if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 1232
    if ((unsigned long )out != (unsigned long )stdout) {
      {
#line 1233
      fclose(out);
      }
    }
  }
  {
#line 1236
  while (1) {
    while_continue___15: /* CIL Label */ ;

#line 1236
    return (return_value);
#line 1236
    goto while_break___15;
  }
  while_break___32: /* CIL Label */ ;
  }
  while_break___15: ;
#line 1240
  return (0);
}
}
