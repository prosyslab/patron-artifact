/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef unsigned long size_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 328 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef int wchar_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
enum __anonenum__0 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
typedef enum __anonenum__0 idtype_t;
#line 58 "/usr/include/stdlib.h"
struct __anonstruct_1 {
   int quot ;
   int rem ;
};
#line 62 "/usr/include/stdlib.h"
typedef struct __anonstruct_1 div_t;
#line 66 "/usr/include/stdlib.h"
struct __anonstruct_2 {
   long quot ;
   long rem ;
};
#line 70 "/usr/include/stdlib.h"
typedef struct __anonstruct_2 ldiv_t;
#line 76 "/usr/include/stdlib.h"
struct __anonstruct_3 {
   long long quot ;
   long long rem ;
};
#line 80 "/usr/include/stdlib.h"
typedef struct __anonstruct_3 lldiv_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_4 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_4 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 191 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 206 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 209 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 85 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 97 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 108 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_5 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_5 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_6 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_6 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_8 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_7 {
   unsigned long long __wseq ;
   struct __anonstruct_8 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_10 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_9 {
   unsigned long long __g1_start ;
   struct __anonstruct_10 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_7  ;
   unsigned long long __wseq ;
   struct __anonstruct_8 __wseq32 ;
   union __anonunion_9  ;
   unsigned long long __g1_start ;
   struct __anonstruct_10 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_11 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_11 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_12 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_12 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_13 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_13 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_14 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_14 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_15 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_15 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_16 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_16 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_17 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_17 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_18 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_18 pthread_barrierattr_t;
#line 423 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 490 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 808 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 149 "/usr/include/math.h"
typedef float float_t;
#line 150 "/usr/include/math.h"
typedef double double_t;
#line 853
enum __anonenum__19 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_21 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_20 {
   int __count ;
   union __anonunion_21 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_20 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 106 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef int OPJ_BOOL;
#line 110 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef char OPJ_CHAR;
#line 111 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef float OPJ_FLOAT32;
#line 112 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef double OPJ_FLOAT64;
#line 113 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef unsigned char OPJ_BYTE;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 43 "/usr/include/stdint.h"
typedef __int_least8_t int_least8_t;
#line 44 "/usr/include/stdint.h"
typedef __int_least16_t int_least16_t;
#line 45 "/usr/include/stdint.h"
typedef __int_least32_t int_least32_t;
#line 46 "/usr/include/stdint.h"
typedef __int_least64_t int_least64_t;
#line 49 "/usr/include/stdint.h"
typedef __uint_least8_t uint_least8_t;
#line 50 "/usr/include/stdint.h"
typedef __uint_least16_t uint_least16_t;
#line 51 "/usr/include/stdint.h"
typedef __uint_least32_t uint_least32_t;
#line 52 "/usr/include/stdint.h"
typedef __uint_least64_t uint_least64_t;
#line 58 "/usr/include/stdint.h"
typedef signed char int_fast8_t;
#line 60 "/usr/include/stdint.h"
typedef long int_fast16_t;
#line 61 "/usr/include/stdint.h"
typedef long int_fast32_t;
#line 62 "/usr/include/stdint.h"
typedef long int_fast64_t;
#line 71 "/usr/include/stdint.h"
typedef unsigned char uint_fast8_t;
#line 73 "/usr/include/stdint.h"
typedef unsigned long uint_fast16_t;
#line 74 "/usr/include/stdint.h"
typedef unsigned long uint_fast32_t;
#line 75 "/usr/include/stdint.h"
typedef unsigned long uint_fast64_t;
#line 87 "/usr/include/stdint.h"
typedef long intptr_t;
#line 90 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 117 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef int8_t OPJ_INT8;
#line 118 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef uint8_t OPJ_UINT8;
#line 119 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef int16_t OPJ_INT16;
#line 120 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef uint16_t OPJ_UINT16;
#line 121 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef int32_t OPJ_INT32;
#line 122 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef uint32_t OPJ_UINT32;
#line 123 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef int64_t OPJ_INT64;
#line 124 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef uint64_t OPJ_UINT64;
#line 126 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef int64_t OPJ_OFF_T;
#line 129 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef size_t OPJ_SIZE_T;
#line 242
enum RSIZ_CAPABILITIES {
    OPJ_STD_RSIZ = 0,
    OPJ_CINEMA2K = 3,
    OPJ_CINEMA4K = 4,
    OPJ_MCT = 33024
} ;
#line 247 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef enum RSIZ_CAPABILITIES OPJ_RSIZ_CAPABILITIES;
#line 253
enum CINEMA_MODE {
    OPJ_OFF = 0,
    OPJ_CINEMA2K_24 = 1,
    OPJ_CINEMA2K_48 = 2,
    OPJ_CINEMA4K_24 = 3
} ;
#line 258 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef enum CINEMA_MODE OPJ_CINEMA_MODE;
#line 263
enum PROG_ORDER {
    OPJ_PROG_UNKNOWN = -1,
    OPJ_LRCP = 0,
    OPJ_RLCP = 1,
    OPJ_RPCL = 2,
    OPJ_PCRL = 3,
    OPJ_CPRL = 4
} ;
#line 270 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef enum PROG_ORDER OPJ_PROG_ORDER;
#line 275
enum COLOR_SPACE {
    OPJ_CLRSPC_UNKNOWN = -1,
    OPJ_CLRSPC_UNSPECIFIED = 0,
    OPJ_CLRSPC_SRGB = 1,
    OPJ_CLRSPC_GRAY = 2,
    OPJ_CLRSPC_SYCC = 3,
    OPJ_CLRSPC_EYCC = 4,
    OPJ_CLRSPC_CMYK = 5
} ;
#line 283 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef enum COLOR_SPACE OPJ_COLOR_SPACE;
#line 288
enum CODEC_FORMAT {
    OPJ_CODEC_UNKNOWN = -1,
    OPJ_CODEC_J2K = 0,
    OPJ_CODEC_JPT = 1,
    OPJ_CODEC_JP2 = 2,
    OPJ_CODEC_JPP = 3,
    OPJ_CODEC_JPX = 4
} ;
#line 295 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef enum CODEC_FORMAT OPJ_CODEC_FORMAT;
#line 309 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef void (*opj_msg_callback)(char const   * , void * );
#line 321 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_poc {
   OPJ_UINT32 resno0 ;
   OPJ_UINT32 compno0 ;
   OPJ_UINT32 layno1 ;
   OPJ_UINT32 resno1 ;
   OPJ_UINT32 compno1 ;
   OPJ_UINT32 layno0 ;
   OPJ_UINT32 precno0 ;
   OPJ_UINT32 precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   OPJ_CHAR progorder[5] ;
   OPJ_UINT32 tile ;
   OPJ_INT32 tx0 ;
   OPJ_INT32 tx1 ;
   OPJ_INT32 ty0 ;
   OPJ_INT32 ty1 ;
   OPJ_UINT32 layS ;
   OPJ_UINT32 resS ;
   OPJ_UINT32 compS ;
   OPJ_UINT32 prcS ;
   OPJ_UINT32 layE ;
   OPJ_UINT32 resE ;
   OPJ_UINT32 compE ;
   OPJ_UINT32 prcE ;
   OPJ_UINT32 txS ;
   OPJ_UINT32 txE ;
   OPJ_UINT32 tyS ;
   OPJ_UINT32 tyE ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 lay_t ;
   OPJ_UINT32 res_t ;
   OPJ_UINT32 comp_t ;
   OPJ_UINT32 prc_t ;
   OPJ_UINT32 tx0_t ;
   OPJ_UINT32 ty0_t ;
};
#line 344 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_poc opj_poc_t;
#line 349 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_cparameters {
   OPJ_BOOL tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t POC[32] ;
   OPJ_UINT32 numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   OPJ_BOOL jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
   OPJ_BOOL jpip_on ;
   void *mct_data ;
   int max_cs_size ;
   OPJ_UINT16 rsiz ;
};
#line 497 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_cparameters opj_cparameters_t;
#line 504 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_dparameters {
   OPJ_UINT32 cp_reduce ;
   OPJ_UINT32 cp_layer ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   OPJ_UINT32 DA_x0 ;
   OPJ_UINT32 DA_x1 ;
   OPJ_UINT32 DA_y0 ;
   OPJ_UINT32 DA_y1 ;
   OPJ_BOOL m_verbose ;
   OPJ_UINT32 tile_index ;
   OPJ_UINT32 nb_tile_to_decode ;
   OPJ_BOOL jpwl_correct ;
   int jpwl_exp_comps ;
   int jpwl_max_tiles ;
   unsigned int flags ;
};
#line 564 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_dparameters opj_dparameters_t;
#line 570 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef void *opj_codec_t;
#line 589 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef OPJ_SIZE_T (*opj_stream_read_fn)(void * , OPJ_SIZE_T  , void * );
#line 594 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef OPJ_SIZE_T (*opj_stream_write_fn)(void * , OPJ_SIZE_T  , void * );
#line 599 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef OPJ_OFF_T (*opj_stream_skip_fn)(OPJ_OFF_T  , void * );
#line 604 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef OPJ_BOOL (*opj_stream_seek_fn)(OPJ_OFF_T  , void * );
#line 609 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef void (*opj_stream_free_user_data_fn)(void * );
#line 614 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef void *opj_stream_t;
#line 625 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_image_comp {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 prec ;
   OPJ_UINT32 bpp ;
   OPJ_UINT32 sgnd ;
   OPJ_UINT32 resno_decoded ;
   OPJ_UINT32 factor ;
   OPJ_INT32 *data ;
   OPJ_UINT16 alpha ;
};
#line 652 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_image_comp opj_image_comp_t;
#line 657 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_image {
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 x1 ;
   OPJ_UINT32 y1 ;
   OPJ_UINT32 numcomps ;
   OPJ_COLOR_SPACE color_space ;
   opj_image_comp_t *comps ;
   OPJ_BYTE *icc_profile_buf ;
   OPJ_UINT32 icc_profile_len ;
};
#line 676 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_image opj_image_t;
#line 682 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_image_comptparm {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 prec ;
   OPJ_UINT32 bpp ;
   OPJ_UINT32 sgnd ;
};
#line 701 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_image_comptparm opj_image_cmptparm_t;
#line 714 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_packet_info {
   OPJ_OFF_T start_pos ;
   OPJ_OFF_T end_ph_pos ;
   OPJ_OFF_T end_pos ;
   double disto ;
};
#line 723 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_packet_info opj_packet_info_t;
#line 730 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_marker_info {
   unsigned short type ;
   OPJ_OFF_T pos ;
   int len ;
};
#line 737 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_marker_info opj_marker_info_t;
#line 743 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_tp_info {
   int tp_start_pos ;
   int tp_end_header ;
   int tp_end_pos ;
   int tp_start_pack ;
   int tp_numpacks ;
};
#line 754 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_tp_info opj_tp_info_t;
#line 759 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_tile_info {
   double *thresh ;
   int tileno ;
   int start_pos ;
   int end_header ;
   int end_pos ;
   int pw[33] ;
   int ph[33] ;
   int pdx[33] ;
   int pdy[33] ;
   opj_packet_info_t *packet ;
   int numpix ;
   double distotile ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int num_tps ;
   opj_tp_info_t *tp ;
};
#line 794 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_info opj_tile_info_t;
#line 799 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_codestream_info {
   double D_max ;
   int packno ;
   int index_write ;
   int image_w ;
   int image_h ;
   OPJ_PROG_ORDER prog ;
   int tile_x ;
   int tile_y ;
   int tile_Ox ;
   int tile_Oy ;
   int tw ;
   int th ;
   int numcomps ;
   int numlayers ;
   int *numdecompos ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int main_head_start ;
   int main_head_end ;
   int codestream_size ;
   opj_tile_info_t *tile ;
};
#line 846 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_info opj_codestream_info_t;
#line 854 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_tccp_info {
   OPJ_UINT32 compno ;
   OPJ_UINT32 csty ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 cblkw ;
   OPJ_UINT32 cblkh ;
   OPJ_UINT32 cblksty ;
   OPJ_UINT32 qmfbid ;
   OPJ_UINT32 qntsty ;
   OPJ_UINT32 stepsizes_mant[97] ;
   OPJ_UINT32 stepsizes_expn[97] ;
   OPJ_UINT32 numgbits ;
   OPJ_INT32 roishift ;
   OPJ_UINT32 prcw[33] ;
   OPJ_UINT32 prch[33] ;
};
#line 885 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_tccp_info opj_tccp_info_t;
#line 890 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_tile_v2_info {
   int tileno ;
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 mct ;
   opj_tccp_info_t *tccp_info ;
};
#line 906 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_v2_info opj_tile_info_v2_t;
#line 911 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_codestream_info_v2 {
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_UINT32 nbcomps ;
   opj_tile_info_v2_t m_default_tile_info ;
   opj_tile_info_v2_t *tile_info ;
};
#line 935 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_info_v2 opj_codestream_info_v2_t;
#line 941 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_tp_index {
   OPJ_OFF_T start_pos ;
   OPJ_OFF_T end_header ;
   OPJ_OFF_T end_pos ;
};
#line 949 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_tp_index opj_tp_index_t;
#line 954 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_tile_index {
   OPJ_UINT32 tileno ;
   OPJ_UINT32 nb_tps ;
   OPJ_UINT32 current_nb_tps ;
   OPJ_UINT32 current_tpsno ;
   opj_tp_index_t *tp_index ;
   OPJ_UINT32 marknum ;
   opj_marker_info_t *marker ;
   OPJ_UINT32 maxmarknum ;
   OPJ_UINT32 nb_packet ;
   opj_packet_info_t *packet_index ;
};
#line 981 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_index opj_tile_index_t;
#line 986 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_codestream_index {
   OPJ_OFF_T main_head_start ;
   OPJ_OFF_T main_head_end ;
   OPJ_UINT64 codestream_size ;
   OPJ_UINT32 marknum ;
   opj_marker_info_t *marker ;
   OPJ_UINT32 maxmarknum ;
   OPJ_UINT32 nb_of_tiles ;
   opj_tile_index_t *tile_index ;
};
#line 1009 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_index opj_codestream_index_t;
#line 1022 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_jp2_metadata {
   OPJ_INT32 not_used ;
};
#line 1026 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_jp2_metadata opj_jp2_metadata_t;
#line 1032 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
struct opj_jp2_index {
   OPJ_INT32 not_used ;
};
#line 1036 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
typedef struct opj_jp2_index opj_jp2_index_t;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 271 "/usr/include/inttypes.h"
struct __anonstruct_23 {
   long quot ;
   long rem ;
};
#line 275 "/usr/include/inttypes.h"
typedef struct __anonstruct_23 imaxdiv_t;
#line 52 "/root/patron/new_21/src/lib/openjp2/function_list.h"
typedef void (*opj_procedure)(void);
#line 57 "/root/patron/new_21/src/lib/openjp2/function_list.h"
struct opj_procedure_list {
   OPJ_UINT32 m_nb_procedures ;
   OPJ_UINT32 m_nb_max_procedures ;
   opj_procedure *m_procedures ;
};
#line 72 "/root/patron/new_21/src/lib/openjp2/function_list.h"
typedef struct opj_procedure_list opj_procedure_list_t;
#line 50 "/root/patron/new_21/src/lib/openjp2/event.h"
struct opj_event_mgr {
   void *m_error_data ;
   void *m_warning_data ;
   void *m_info_data ;
   opj_msg_callback error_handler ;
   opj_msg_callback warning_handler ;
   opj_msg_callback info_handler ;
};
#line 64 "/root/patron/new_21/src/lib/openjp2/event.h"
typedef struct opj_event_mgr opj_event_mgr_t;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef long ptrdiff_t;
#line 426 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
struct __anonstruct_24 {
   long long __max_align_ll ;
   long double __max_align_ld ;
};
#line 437 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef struct __anonstruct_24 max_align_t;
#line 56 "/root/patron/new_21/src/lib/openjp2/bio.h"
struct opj_bio {
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
   OPJ_BYTE *bp ;
   OPJ_UINT32 buf ;
   OPJ_UINT32 ct ;
};
#line 67 "/root/patron/new_21/src/lib/openjp2/bio.h"
typedef struct opj_bio opj_bio_t;
#line 74 "/root/patron/new_21/src/lib/openjp2/cio.h"
enum __anonenum__25 {
    opj_signed_sentinel = -1,
    opj_stream_e_output = 1,
    opj_stream_e_input = 2,
    opj_stream_e_end = 4,
    opj_stream_e_error = 8
} ;
#line 82 "/root/patron/new_21/src/lib/openjp2/cio.h"
typedef enum __anonenum__25 opj_stream_flag;
#line 87 "/root/patron/new_21/src/lib/openjp2/cio.h"
struct opj_stream_private {
   void *m_user_data ;
   opj_stream_free_user_data_fn m_free_user_data_fn ;
   OPJ_UINT64 m_user_data_length ;
   opj_stream_read_fn m_read_fn ;
   opj_stream_write_fn m_write_fn ;
   opj_stream_skip_fn m_skip_fn ;
   opj_stream_seek_fn m_seek_fn ;
   OPJ_BYTE *m_stored_data ;
   OPJ_BYTE *m_current_data ;
   OPJ_OFF_T (*m_opj_skip)(struct opj_stream_private * , OPJ_OFF_T  , struct opj_event_mgr * ) ;
   OPJ_BOOL (*m_opj_seek)(struct opj_stream_private * , OPJ_OFF_T  , struct opj_event_mgr * ) ;
   OPJ_SIZE_T m_bytes_in_buffer ;
   OPJ_OFF_T m_byte_offset ;
   OPJ_SIZE_T m_buffer_size ;
   opj_stream_flag m_status ;
};
#line 169 "/root/patron/new_21/src/lib/openjp2/cio.h"
typedef struct opj_stream_private opj_stream_private_t;
#line 41 "/root/patron/new_21/src/lib/openjp2/image.h"
struct opj_cp ;
#line 118 "/root/patron/new_21/src/lib/openjp2/j2k.h"
enum J2K_STATUS {
    J2K_STATE_NONE = 0,
    J2K_STATE_MHSOC = 1,
    J2K_STATE_MHSIZ = 2,
    J2K_STATE_MH = 4,
    J2K_STATE_TPHSOT = 8,
    J2K_STATE_TPH = 16,
    J2K_STATE_MT = 32,
    J2K_STATE_NEOC = 64,
    J2K_STATE_EOC = 256,
    J2K_STATE_ERR = 32768
} ;
#line 130 "/root/patron/new_21/src/lib/openjp2/j2k.h"
typedef enum J2K_STATUS J2K_STATUS;
#line 135
enum MCT_ELEMENT_TYPE {
    MCT_TYPE_INT16 = 0,
    MCT_TYPE_INT32 = 1,
    MCT_TYPE_FLOAT = 2,
    MCT_TYPE_DOUBLE = 3
} ;
#line 141 "/root/patron/new_21/src/lib/openjp2/j2k.h"
typedef enum MCT_ELEMENT_TYPE J2K_MCT_ELEMENT_TYPE;
#line 146
enum MCT_ARRAY_TYPE {
    MCT_TYPE_DEPENDENCY = 0,
    MCT_TYPE_DECORRELATION = 1,
    MCT_TYPE_OFFSET = 2
} ;
#line 151 "/root/patron/new_21/src/lib/openjp2/j2k.h"
typedef enum MCT_ARRAY_TYPE J2K_MCT_ARRAY_TYPE;
#line 158
enum T2_MODE {
    THRESH_CALC = 0,
    FINAL_PASS = 1
} ;
#line 161 "/root/patron/new_21/src/lib/openjp2/j2k.h"
typedef enum T2_MODE J2K_T2_MODE;
#line 166 "/root/patron/new_21/src/lib/openjp2/j2k.h"
struct opj_stepsize {
   OPJ_INT32 expn ;
   OPJ_INT32 mant ;
};
#line 171 "/root/patron/new_21/src/lib/openjp2/j2k.h"
typedef struct opj_stepsize opj_stepsize_t;
#line 176 "/root/patron/new_21/src/lib/openjp2/j2k.h"
struct opj_tccp {
   OPJ_UINT32 csty ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 cblkw ;
   OPJ_UINT32 cblkh ;
   OPJ_UINT32 cblksty ;
   OPJ_UINT32 qmfbid ;
   OPJ_UINT32 qntsty ;
   opj_stepsize_t stepsizes[97] ;
   OPJ_UINT32 numgbits ;
   OPJ_INT32 roishift ;
   OPJ_UINT32 prcw[33] ;
   OPJ_UINT32 prch[33] ;
   OPJ_INT32 m_dc_level_shift ;
};
#line 205 "/root/patron/new_21/src/lib/openjp2/j2k.h"
typedef struct opj_tccp opj_tccp_t;
#line 212 "/root/patron/new_21/src/lib/openjp2/j2k.h"
struct opj_mct_data {
   J2K_MCT_ELEMENT_TYPE m_element_type ;
   J2K_MCT_ARRAY_TYPE m_array_type ;
   OPJ_UINT32 m_index ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
};
#line 220 "/root/patron/new_21/src/lib/openjp2/j2k.h"
typedef struct opj_mct_data opj_mct_data_t;
#line 225 "/root/patron/new_21/src/lib/openjp2/j2k.h"
struct opj_simple_mcc_decorrelation_data {
   OPJ_UINT32 m_index ;
   OPJ_UINT32 m_nb_comps ;
   opj_mct_data_t *m_decorrelation_array ;
   opj_mct_data_t *m_offset_array ;
   OPJ_UINT32 m_is_irreversible ;
};
#line 233 "/root/patron/new_21/src/lib/openjp2/j2k.h"
typedef struct opj_simple_mcc_decorrelation_data opj_simple_mcc_decorrelation_data_t;
#line 240 "/root/patron/new_21/src/lib/openjp2/j2k.h"
struct opj_tcp {
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 num_layers_to_decode ;
   OPJ_UINT32 mct ;
   OPJ_FLOAT32 rates[100] ;
   OPJ_UINT32 numpocs ;
   opj_poc_t pocs[32] ;
   OPJ_BYTE *ppt_data ;
   OPJ_BYTE *ppt_buffer ;
   OPJ_UINT32 ppt_data_size ;
   OPJ_UINT32 ppt_len ;
   OPJ_FLOAT32 distoratio[100] ;
   opj_tccp_t *tccps ;
   OPJ_UINT32 m_nb_tile_parts ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
   OPJ_FLOAT64 *mct_norms ;
   OPJ_FLOAT32 *m_mct_decoding_matrix ;
   OPJ_FLOAT32 *m_mct_coding_matrix ;
   opj_mct_data_t *m_mct_records ;
   OPJ_UINT32 m_nb_mct_records ;
   OPJ_UINT32 m_nb_max_mct_records ;
   opj_simple_mcc_decorrelation_data_t *m_mcc_records ;
   OPJ_UINT32 m_nb_mcc_records ;
   OPJ_UINT32 m_nb_max_mcc_records ;
   OPJ_UINT32 ppt ;
   OPJ_UINT32 POC ;
};
#line 300 "/root/patron/new_21/src/lib/openjp2/j2k.h"
typedef struct opj_tcp opj_tcp_t;
#line 305 "/root/patron/new_21/src/lib/openjp2/j2k.h"
struct opj_encoding_param {
   OPJ_UINT32 m_max_comp_size ;
   OPJ_INT32 m_tp_pos ;
   OPJ_INT32 *m_matrice ;
   OPJ_BYTE m_tp_flag ;
   OPJ_UINT32 m_disto_alloc ;
   OPJ_UINT32 m_fixed_alloc ;
   OPJ_UINT32 m_fixed_quality ;
   OPJ_UINT32 m_tp_on ;
};
#line 324 "/root/patron/new_21/src/lib/openjp2/j2k.h"
typedef struct opj_encoding_param opj_encoding_param_t;
#line 326 "/root/patron/new_21/src/lib/openjp2/j2k.h"
struct opj_decoding_param {
   OPJ_UINT32 m_reduce ;
   OPJ_UINT32 m_layer ;
};
#line 333 "/root/patron/new_21/src/lib/openjp2/j2k.h"
typedef struct opj_decoding_param opj_decoding_param_t;
#line 383 "/root/patron/new_21/src/lib/openjp2/j2k.h"
union __anonunion_26 {
   opj_decoding_param_t m_dec ;
   opj_encoding_param_t m_enc ;
};
#line 339 "/root/patron/new_21/src/lib/openjp2/j2k.h"
struct opj_cp {
   OPJ_UINT16 rsiz ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_CHAR *comment ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_BYTE *ppm_data ;
   OPJ_UINT32 ppm_len ;
   OPJ_UINT32 ppm_data_read ;
   OPJ_BYTE *ppm_data_current ;
   OPJ_BYTE *ppm_buffer ;
   OPJ_BYTE *ppm_data_first ;
   OPJ_UINT32 ppm_data_size ;
   OPJ_INT32 ppm_store ;
   OPJ_INT32 ppm_previous ;
   opj_tcp_t *tcps ;
   union __anonunion_26 m_specific_param ;
   OPJ_UINT32 ppm ;
   OPJ_UINT32 m_is_decoder ;
};
#line 441 "/root/patron/new_21/src/lib/openjp2/j2k.h"
typedef struct opj_cp opj_cp_t;
#line 444 "/root/patron/new_21/src/lib/openjp2/j2k.h"
struct opj_j2k_dec {
   OPJ_UINT32 m_state ;
   opj_tcp_t *m_default_tcp ;
   OPJ_BYTE *m_header_data ;
   OPJ_UINT32 m_header_data_size ;
   OPJ_UINT32 m_sot_length ;
   OPJ_UINT32 m_start_tile_x ;
   OPJ_UINT32 m_start_tile_y ;
   OPJ_UINT32 m_end_tile_x ;
   OPJ_UINT32 m_end_tile_y ;
   OPJ_UINT32 m_DA_x0 ;
   OPJ_UINT32 m_DA_y0 ;
   OPJ_UINT32 m_DA_x1 ;
   OPJ_UINT32 m_DA_y1 ;
   OPJ_INT32 m_tile_ind_to_dec ;
   OPJ_OFF_T m_last_sot_read_pos ;
   OPJ_BOOL m_last_tile_part ;
   OPJ_UINT32 m_can_decode ;
   OPJ_UINT32 m_discard_tiles ;
   OPJ_UINT32 m_skip_data ;
};
#line 485 "/root/patron/new_21/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_dec opj_j2k_dec_t;
#line 487 "/root/patron/new_21/src/lib/openjp2/j2k.h"
struct opj_j2k_enc {
   OPJ_UINT32 m_current_poc_tile_part_number ;
   OPJ_UINT32 m_current_tile_part_number ;
   OPJ_OFF_T m_tlm_start ;
   OPJ_BYTE *m_tlm_sot_offsets_buffer ;
   OPJ_BYTE *m_tlm_sot_offsets_current ;
   OPJ_UINT32 m_total_tile_parts ;
   OPJ_BYTE *m_encoded_tile_data ;
   OPJ_UINT32 m_encoded_tile_size ;
   OPJ_BYTE *m_header_tile_data ;
   OPJ_UINT32 m_header_tile_data_size ;
};
#line 526 "/root/patron/new_21/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_enc opj_j2k_enc_t;
#line 530
struct opj_tcd ;
#line 540 "/root/patron/new_21/src/lib/openjp2/j2k.h"
union __anonunion_27 {
   opj_j2k_dec_t m_decoder ;
   opj_j2k_enc_t m_encoder ;
};
#line 534 "/root/patron/new_21/src/lib/openjp2/j2k.h"
struct opj_j2k {
   OPJ_BOOL m_is_decoder ;
   union __anonunion_27 m_specific_param ;
   opj_image_t *m_private_image ;
   opj_image_t *m_output_image ;
   opj_cp_t m_cp ;
   opj_procedure_list_t *m_procedure_list ;
   opj_procedure_list_t *m_validation_list ;
   opj_codestream_index_t *cstr_index ;
   OPJ_UINT32 m_current_tile_number ;
   struct opj_tcd *m_tcd ;
};
#line 572 "/root/patron/new_21/src/lib/openjp2/j2k.h"
typedef struct opj_j2k opj_j2k_t;
#line 73 "/root/patron/new_21/src/lib/openjp2/jp2.h"
enum __anonenum__28 {
    JP2_STATE_NONE = 0,
    JP2_STATE_SIGNATURE = 1,
    JP2_STATE_FILE_TYPE = 2,
    JP2_STATE_HEADER = 4,
    JP2_STATE_CODESTREAM = 8,
    JP2_STATE_END_CODESTREAM = 16,
    JP2_STATE_UNKNOWN = 2147483647
} ;
#line 83 "/root/patron/new_21/src/lib/openjp2/jp2.h"
typedef enum __anonenum__28 JP2_STATE;
#line 85
enum __anonenum__29 {
    JP2_IMG_STATE_NONE = 0,
    JP2_IMG_STATE_UNKNOWN = 2147483647
} ;
#line 90 "/root/patron/new_21/src/lib/openjp2/jp2.h"
typedef enum __anonenum__29 JP2_IMG_STATE;
#line 95 "/root/patron/new_21/src/lib/openjp2/jp2.h"
struct opj_jp2_cdef_info {
   OPJ_UINT16 cn ;
   OPJ_UINT16 typ ;
   OPJ_UINT16 asoc ;
};
#line 98 "/root/patron/new_21/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cdef_info opj_jp2_cdef_info_t;
#line 103 "/root/patron/new_21/src/lib/openjp2/jp2.h"
struct opj_jp2_cdef {
   opj_jp2_cdef_info_t *info ;
   OPJ_UINT16 n ;
};
#line 107 "/root/patron/new_21/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cdef opj_jp2_cdef_t;
#line 112 "/root/patron/new_21/src/lib/openjp2/jp2.h"
struct opj_jp2_cmap_comp {
   OPJ_UINT16 cmp ;
   OPJ_BYTE mtyp ;
   OPJ_BYTE pcol ;
};
#line 116 "/root/patron/new_21/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cmap_comp opj_jp2_cmap_comp_t;
#line 121 "/root/patron/new_21/src/lib/openjp2/jp2.h"
struct opj_jp2_pclr {
   OPJ_UINT32 *entries ;
   OPJ_BYTE *channel_sign ;
   OPJ_BYTE *channel_size ;
   opj_jp2_cmap_comp_t *cmap ;
   OPJ_UINT16 nr_entries ;
   OPJ_BYTE nr_channels ;
};
#line 129 "/root/patron/new_21/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_pclr opj_jp2_pclr_t;
#line 134 "/root/patron/new_21/src/lib/openjp2/jp2.h"
struct opj_jp2_color {
   OPJ_BYTE *icc_profile_buf ;
   OPJ_UINT32 icc_profile_len ;
   opj_jp2_cdef_t *jp2_cdef ;
   opj_jp2_pclr_t *jp2_pclr ;
   OPJ_BYTE jp2_has_colr ;
};
#line 142 "/root/patron/new_21/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_color opj_jp2_color_t;
#line 147 "/root/patron/new_21/src/lib/openjp2/jp2.h"
struct opj_jp2_comps {
   OPJ_UINT32 depth ;
   OPJ_UINT32 sgnd ;
   OPJ_UINT32 bpcc ;
};
#line 151 "/root/patron/new_21/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_comps opj_jp2_comps_t;
#line 156 "/root/patron/new_21/src/lib/openjp2/jp2.h"
struct opj_jp2 {
   opj_j2k_t *j2k ;
   struct opj_procedure_list *m_validation_list ;
   struct opj_procedure_list *m_procedure_list ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 numcomps ;
   OPJ_UINT32 bpc ;
   OPJ_UINT32 C ;
   OPJ_UINT32 UnkC ;
   OPJ_UINT32 IPR ;
   OPJ_UINT32 meth ;
   OPJ_UINT32 approx ;
   OPJ_UINT32 enumcs ;
   OPJ_UINT32 precedence ;
   OPJ_UINT32 brand ;
   OPJ_UINT32 minversion ;
   OPJ_UINT32 numcl ;
   OPJ_UINT32 *cl ;
   opj_jp2_comps_t *comps ;
   OPJ_OFF_T j2k_codestream_offset ;
   OPJ_OFF_T jpip_iptr_offset ;
   OPJ_BOOL jpip_on ;
   OPJ_UINT32 jp2_state ;
   OPJ_UINT32 jp2_img_state ;
   opj_jp2_color_t color ;
   OPJ_BOOL ignore_pclr_cmap_cdef ;
};
#line 199 "/root/patron/new_21/src/lib/openjp2/jp2.h"
typedef struct opj_jp2 opj_jp2_t;
#line 204 "/root/patron/new_21/src/lib/openjp2/jp2.h"
struct opj_jp2_box {
   OPJ_UINT32 length ;
   OPJ_UINT32 type ;
   OPJ_INT32 init_pos ;
};
#line 208 "/root/patron/new_21/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_box opj_jp2_box_t;
#line 210 "/root/patron/new_21/src/lib/openjp2/jp2.h"
struct opj_jp2_header_handler {
   OPJ_UINT32 id ;
   OPJ_BOOL (*handler)(opj_jp2_t * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 220 "/root/patron/new_21/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_header_handler opj_jp2_header_handler_t;
#line 223 "/root/patron/new_21/src/lib/openjp2/jp2.h"
struct opj_jp2_img_header_writer_handler {
   OPJ_BYTE *(*handler)(opj_jp2_t * , OPJ_UINT32 * ) ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_size ;
};
#line 232 "/root/patron/new_21/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_img_header_writer_handler opj_jp2_img_header_writer_handler_t;
#line 55 "/root/patron/new_21/src/lib/openjp2/mqc.h"
struct opj_mqc_state {
   OPJ_UINT32 qeval ;
   OPJ_UINT32 mps ;
   struct opj_mqc_state *nmps ;
   struct opj_mqc_state *nlps ;
};
#line 64 "/root/patron/new_21/src/lib/openjp2/mqc.h"
typedef struct opj_mqc_state opj_mqc_state_t;
#line 71 "/root/patron/new_21/src/lib/openjp2/mqc.h"
struct opj_mqc {
   OPJ_UINT32 c ;
   OPJ_UINT32 a ;
   OPJ_UINT32 ct ;
   OPJ_BYTE *bp ;
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
   opj_mqc_state_t *ctxs[19] ;
   opj_mqc_state_t **curctx ;
};
#line 83 "/root/patron/new_21/src/lib/openjp2/mqc.h"
typedef struct opj_mqc opj_mqc_t;
#line 52 "/root/patron/new_21/src/lib/openjp2/raw.h"
struct opj_raw {
   OPJ_BYTE c ;
   OPJ_UINT32 ct ;
   OPJ_UINT32 lenmax ;
   OPJ_UINT32 len ;
   OPJ_BYTE *bp ;
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
};
#line 67 "/root/patron/new_21/src/lib/openjp2/raw.h"
typedef struct opj_raw opj_raw_t;
#line 55 "/root/patron/new_21/src/lib/openjp2/pi.h"
struct opj_pi_resolution {
   OPJ_UINT32 pdx ;
   OPJ_UINT32 pdy ;
   OPJ_UINT32 pw ;
   OPJ_UINT32 ph ;
};
#line 58 "/root/patron/new_21/src/lib/openjp2/pi.h"
typedef struct opj_pi_resolution opj_pi_resolution_t;
#line 63 "/root/patron/new_21/src/lib/openjp2/pi.h"
struct opj_pi_comp {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 numresolutions ;
   opj_pi_resolution_t *resolutions ;
};
#line 68 "/root/patron/new_21/src/lib/openjp2/pi.h"
typedef struct opj_pi_comp opj_pi_comp_t;
#line 73 "/root/patron/new_21/src/lib/openjp2/pi.h"
struct opj_pi_iterator {
   OPJ_BYTE tp_on ;
   OPJ_INT16 *include ;
   OPJ_UINT32 step_l ;
   OPJ_UINT32 step_r ;
   OPJ_UINT32 step_c ;
   OPJ_UINT32 step_p ;
   OPJ_UINT32 compno ;
   OPJ_UINT32 resno ;
   OPJ_UINT32 precno ;
   OPJ_UINT32 layno ;
   OPJ_BOOL first ;
   opj_poc_t poc ;
   OPJ_UINT32 numcomps ;
   opj_pi_comp_t *comps ;
   OPJ_INT32 tx0 ;
   OPJ_INT32 ty0 ;
   OPJ_INT32 tx1 ;
   OPJ_INT32 ty1 ;
   OPJ_INT32 x ;
   OPJ_INT32 y ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
};
#line 108 "/root/patron/new_21/src/lib/openjp2/pi.h"
typedef struct opj_pi_iterator opj_pi_iterator_t;
#line 57 "/root/patron/new_21/src/lib/openjp2/tgt.h"
struct opj_tgt_node {
   struct opj_tgt_node *parent ;
   OPJ_INT32 value ;
   OPJ_INT32 low ;
   OPJ_UINT32 known ;
};
#line 62 "/root/patron/new_21/src/lib/openjp2/tgt.h"
typedef struct opj_tgt_node opj_tgt_node_t;
#line 67 "/root/patron/new_21/src/lib/openjp2/tgt.h"
struct opj_tgt_tree {
   OPJ_UINT32 numleafsh ;
   OPJ_UINT32 numleafsv ;
   OPJ_UINT32 numnodes ;
   opj_tgt_node_t *nodes ;
   OPJ_UINT32 nodes_size ;
};
#line 74 "/root/patron/new_21/src/lib/openjp2/tgt.h"
typedef struct opj_tgt_tree opj_tgt_tree_t;
#line 55 "/root/patron/new_21/src/lib/openjp2/tcd.h"
struct opj_tcd_seg {
   OPJ_BYTE **data ;
   OPJ_UINT32 dataindex ;
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 real_num_passes ;
   OPJ_UINT32 len ;
   OPJ_UINT32 maxpasses ;
   OPJ_UINT32 numnewpasses ;
   OPJ_UINT32 newlen ;
};
#line 64 "/root/patron/new_21/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_seg opj_tcd_seg_t;
#line 69 "/root/patron/new_21/src/lib/openjp2/tcd.h"
struct opj_tcd_pass {
   OPJ_UINT32 rate ;
   OPJ_FLOAT64 distortiondec ;
   OPJ_UINT32 len ;
   OPJ_UINT32 term ;
};
#line 74 "/root/patron/new_21/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_pass opj_tcd_pass_t;
#line 79 "/root/patron/new_21/src/lib/openjp2/tcd.h"
struct opj_tcd_layer {
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 len ;
   OPJ_FLOAT64 disto ;
   OPJ_BYTE *data ;
};
#line 84 "/root/patron/new_21/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_layer opj_tcd_layer_t;
#line 89 "/root/patron/new_21/src/lib/openjp2/tcd.h"
struct opj_tcd_cblk_enc {
   OPJ_BYTE *data ;
   opj_tcd_layer_t *layers ;
   opj_tcd_pass_t *passes ;
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numbps ;
   OPJ_UINT32 numlenbits ;
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 numpassesinlayers ;
   OPJ_UINT32 totalpasses ;
};
#line 99 "/root/patron/new_21/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_cblk_enc opj_tcd_cblk_enc_t;
#line 102 "/root/patron/new_21/src/lib/openjp2/tcd.h"
struct opj_tcd_cblk_dec {
   OPJ_BYTE *data ;
   opj_tcd_seg_t *segs ;
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numbps ;
   OPJ_UINT32 numlenbits ;
   OPJ_UINT32 data_max_size ;
   OPJ_UINT32 data_current_size ;
   OPJ_UINT32 numnewpasses ;
   OPJ_UINT32 numsegs ;
   OPJ_UINT32 real_num_segs ;
   OPJ_UINT32 m_current_max_segs ;
};
#line 114 "/root/patron/new_21/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_cblk_dec opj_tcd_cblk_dec_t;
#line 122 "/root/patron/new_21/src/lib/openjp2/tcd.h"
union __anonunion_30 {
   opj_tcd_cblk_enc_t *enc ;
   opj_tcd_cblk_dec_t *dec ;
};
#line 119 "/root/patron/new_21/src/lib/openjp2/tcd.h"
struct opj_tcd_precinct {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 cw ;
   OPJ_UINT32 ch ;
   union __anonunion_30 cblks ;
   OPJ_UINT32 block_size ;
   opj_tgt_tree_t *incltree ;
   opj_tgt_tree_t *imsbtree ;
};
#line 129 "/root/patron/new_21/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_precinct opj_tcd_precinct_t;
#line 134 "/root/patron/new_21/src/lib/openjp2/tcd.h"
struct opj_tcd_band {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 bandno ;
   opj_tcd_precinct_t *precincts ;
   OPJ_UINT32 precincts_data_size ;
   OPJ_INT32 numbps ;
   OPJ_FLOAT32 stepsize ;
};
#line 141 "/root/patron/new_21/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_band opj_tcd_band_t;
#line 146 "/root/patron/new_21/src/lib/openjp2/tcd.h"
struct opj_tcd_resolution {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 pw ;
   OPJ_UINT32 ph ;
   OPJ_UINT32 numbands ;
   opj_tcd_band_t bands[3] ;
};
#line 151 "/root/patron/new_21/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_resolution opj_tcd_resolution_t;
#line 156 "/root/patron/new_21/src/lib/openjp2/tcd.h"
struct opj_tcd_tilecomp {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 minimum_num_resolutions ;
   opj_tcd_resolution_t *resolutions ;
   OPJ_UINT32 resolutions_size ;
   OPJ_INT32 *data ;
   OPJ_UINT32 data_size ;
   OPJ_INT32 numpix ;
};
#line 166 "/root/patron/new_21/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_tilecomp opj_tcd_tilecomp_t;
#line 172 "/root/patron/new_21/src/lib/openjp2/tcd.h"
struct opj_tcd_tile {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numcomps ;
   opj_tcd_tilecomp_t *comps ;
   OPJ_INT32 numpix ;
   OPJ_FLOAT64 distotile ;
   OPJ_FLOAT64 distolayer[100] ;
   OPJ_UINT32 packno ;
};
#line 180 "/root/patron/new_21/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_tile opj_tcd_tile_t;
#line 185 "/root/patron/new_21/src/lib/openjp2/tcd.h"
struct opj_tcd_image {
   opj_tcd_tile_t *tiles ;
};
#line 189 "/root/patron/new_21/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_image opj_tcd_image_t;
#line 195 "/root/patron/new_21/src/lib/openjp2/tcd.h"
struct opj_tcd {
   OPJ_INT32 tp_pos ;
   OPJ_UINT32 tp_num ;
   OPJ_UINT32 cur_tp_num ;
   OPJ_UINT32 cur_totnum_tp ;
   OPJ_UINT32 cur_pino ;
   opj_tcd_image_t *tcd_image ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_tcp_t *tcp ;
   OPJ_UINT32 tcd_tileno ;
   OPJ_UINT32 m_is_decoder ;
};
#line 219 "/root/patron/new_21/src/lib/openjp2/tcd.h"
typedef struct opj_tcd opj_tcd_t;
#line 94 "/root/patron/new_21/src/lib/openjp2/t1.h"
typedef OPJ_INT16 opj_flag_t;
#line 99 "/root/patron/new_21/src/lib/openjp2/t1.h"
struct opj_t1 {
   opj_mqc_t *mqc ;
   opj_raw_t *raw ;
   OPJ_INT32 *data ;
   opj_flag_t *flags ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 datasize ;
   OPJ_UINT32 flagssize ;
   OPJ_UINT32 flags_stride ;
};
#line 113 "/root/patron/new_21/src/lib/openjp2/t1.h"
typedef struct opj_t1 opj_t1_t;
#line 53 "/root/patron/new_21/src/lib/openjp2/t2.h"
struct opj_t2 {
   opj_image_t *image ;
   opj_cp_t *cp ;
};
#line 59 "/root/patron/new_21/src/lib/openjp2/t2.h"
typedef struct opj_t2 opj_t2_t;
#line 50 "/root/patron/new_21/src/lib/openjp2/opj_codec.h"
struct opj_decompression {
   OPJ_BOOL (*opj_read_header)(struct opj_stream_private * , void * , opj_image_t ** ,
                               struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_decode)(void * , struct opj_stream_private * , opj_image_t * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_read_tile_header)(void * , OPJ_UINT32 * , OPJ_UINT32 * , OPJ_INT32 * ,
                                    OPJ_INT32 * , OPJ_INT32 * , OPJ_INT32 * , OPJ_UINT32 * ,
                                    OPJ_BOOL * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_decode_tile_data)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  ,
                                    struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_decompress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   void (*opj_setup_decoder)(void * , opj_dparameters_t * ) ;
   OPJ_BOOL (*opj_set_decode_area)(void * , opj_image_t * , OPJ_INT32  , OPJ_INT32  ,
                                   OPJ_INT32  , OPJ_INT32  , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_get_decoded_tile)(void * , opj_stream_private_t * , opj_image_t * ,
                                    struct opj_event_mgr * , OPJ_UINT32  ) ;
   OPJ_BOOL (*opj_set_decoded_resolution_factor)(void * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 121 "/root/patron/new_21/src/lib/openjp2/opj_codec.h"
struct opj_compression {
   OPJ_BOOL (*opj_start_compress)(void * , struct opj_stream_private * , struct opj_image * ,
                                  struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_encode)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_write_tile)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  , struct opj_stream_private * ,
                              struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_compress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   OPJ_BOOL (*opj_setup_encoder)(void * , opj_cparameters_t * , struct opj_image * ,
                                 struct opj_event_mgr * ) ;
};
#line 45 "/root/patron/new_21/src/lib/openjp2/opj_codec.h"
union __anonunion_31 {
   struct opj_decompression m_decompression ;
   struct opj_compression m_compression ;
};
#line 42 "/root/patron/new_21/src/lib/openjp2/opj_codec.h"
struct opj_codec_private {
   union __anonunion_31 m_codec_data ;
   void *m_codec ;
   opj_event_mgr_t m_event_mgr ;
   OPJ_BOOL is_decompressor ;
   void (*opj_dump_codec)(void * , OPJ_INT32  , FILE * ) ;
   opj_codestream_info_v2_t *(*opj_get_codec_info)(void * ) ;
   opj_codestream_index_t *(*opj_get_codec_index)(void * ) ;
};
#line 161 "/root/patron/new_21/src/lib/openjp2/opj_codec.h"
typedef struct opj_codec_private opj_codec_private_t;
#line 853 "/usr/include/math.h"
enum __anonenum__19___0 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___0 {
    _ISupper___0 = 256,
    _ISlower___0 = 512,
    _ISalpha___0 = 1024,
    _ISdigit___0 = 2048,
    _ISxdigit___0 = 4096,
    _ISspace___0 = 8192,
    _ISprint___0 = 16384,
    _ISgraph___0 = 32768,
    _ISblank___0 = 1,
    _IScntrl___0 = 2,
    _ISpunct___0 = 4,
    _ISalnum___0 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__19___1 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___1 {
    _ISupper___1 = 256,
    _ISlower___1 = 512,
    _ISalpha___1 = 1024,
    _ISdigit___1 = 2048,
    _ISxdigit___1 = 4096,
    _ISspace___1 = 8192,
    _ISprint___1 = 16384,
    _ISgraph___1 = 32768,
    _ISblank___1 = 1,
    _IScntrl___1 = 2,
    _ISpunct___1 = 4,
    _ISalnum___1 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__19___2 {
    FP_NAN___2 = 0,
    FP_INFINITE___2 = 1,
    FP_ZERO___2 = 2,
    FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___2 {
    _ISupper___2 = 256,
    _ISlower___2 = 512,
    _ISalpha___2 = 1024,
    _ISdigit___2 = 2048,
    _ISxdigit___2 = 4096,
    _ISspace___2 = 8192,
    _ISprint___2 = 16384,
    _ISgraph___2 = 32768,
    _ISblank___2 = 1,
    _IScntrl___2 = 2,
    _ISpunct___2 = 4,
    _ISalnum___2 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__19___3 {
    FP_NAN___3 = 0,
    FP_INFINITE___3 = 1,
    FP_ZERO___3 = 2,
    FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___3 {
    _ISupper___3 = 256,
    _ISlower___3 = 512,
    _ISalpha___3 = 1024,
    _ISdigit___3 = 2048,
    _ISxdigit___3 = 4096,
    _ISspace___3 = 8192,
    _ISprint___3 = 16384,
    _ISgraph___3 = 32768,
    _ISblank___3 = 1,
    _IScntrl___3 = 2,
    _ISpunct___3 = 4,
    _ISalnum___3 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__19___4 {
    FP_NAN___4 = 0,
    FP_INFINITE___4 = 1,
    FP_ZERO___4 = 2,
    FP_SUBNORMAL___4 = 3,
    FP_NORMAL___4 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___4 {
    _ISupper___4 = 256,
    _ISlower___4 = 512,
    _ISalpha___4 = 1024,
    _ISdigit___4 = 2048,
    _ISxdigit___4 = 4096,
    _ISspace___4 = 8192,
    _ISprint___4 = 16384,
    _ISgraph___4 = 32768,
    _ISblank___4 = 1,
    _IScntrl___4 = 2,
    _ISpunct___4 = 4,
    _ISalnum___4 = 8
} ;
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 89
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 105 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 158
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1
} ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_35 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 47 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_36 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_37 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 59 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_38 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_39 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_40 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 78 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_41 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 85 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_42 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_43 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_44 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_45 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 109 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_46 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 117 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_47 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_48 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion_35  ;
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
   union __anonunion_36  ;
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
   union __anonunion_37  ;
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
   union __anonunion_38  ;
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
   union __anonunion_39  ;
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
   union __anonunion_40  ;
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
   union __anonunion_41  ;
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
   union __anonunion_42  ;
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
   union __anonunion_43  ;
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
   union __anonunion_44  ;
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
   union __anonunion_45  ;
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
   union __anonunion_46  ;
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
   union __anonunion_47  ;
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
   union __anonunion_48  ;
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
#line 32 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__65 {
    FP_NAN___5 = 0,
    FP_INFINITE___5 = 1,
    FP_ZERO___5 = 2,
    FP_SUBNORMAL___5 = 3,
    FP_NORMAL___5 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__68 {
    _ISupper___5 = 256,
    _ISlower___5 = 512,
    _ISalpha___5 = 1024,
    _ISdigit___5 = 2048,
    _ISxdigit___5 = 4096,
    _ISspace___5 = 8192,
    _ISprint___5 = 16384,
    _ISgraph___5 = 32768,
    _ISblank___5 = 1,
    _IScntrl___5 = 2,
    _ISpunct___5 = 4,
    _ISalnum___5 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__19___5 {
    FP_NAN___6 = 0,
    FP_INFINITE___6 = 1,
    FP_ZERO___6 = 2,
    FP_SUBNORMAL___6 = 3,
    FP_NORMAL___6 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___5 {
    _ISupper___6 = 256,
    _ISlower___6 = 512,
    _ISalpha___6 = 1024,
    _ISdigit___6 = 2048,
    _ISxdigit___6 = 4096,
    _ISspace___6 = 8192,
    _ISprint___6 = 16384,
    _ISgraph___6 = 32768,
    _ISblank___6 = 1,
    _IScntrl___6 = 2,
    _ISpunct___6 = 4,
    _ISalnum___6 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__19___6 {
    FP_NAN___7 = 0,
    FP_INFINITE___7 = 1,
    FP_ZERO___7 = 2,
    FP_SUBNORMAL___7 = 3,
    FP_NORMAL___7 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___6 {
    _ISupper___7 = 256,
    _ISlower___7 = 512,
    _ISalpha___7 = 1024,
    _ISdigit___7 = 2048,
    _ISxdigit___7 = 4096,
    _ISspace___7 = 8192,
    _ISprint___7 = 16384,
    _ISgraph___7 = 32768,
    _ISblank___7 = 1,
    _IScntrl___7 = 2,
    _ISpunct___7 = 4,
    _ISalnum___7 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__19___7 {
    FP_NAN___8 = 0,
    FP_INFINITE___8 = 1,
    FP_ZERO___8 = 2,
    FP_SUBNORMAL___8 = 3,
    FP_NORMAL___8 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___7 {
    _ISupper___8 = 256,
    _ISlower___8 = 512,
    _ISalpha___8 = 1024,
    _ISdigit___8 = 2048,
    _ISxdigit___8 = 4096,
    _ISspace___8 = 8192,
    _ISprint___8 = 16384,
    _ISgraph___8 = 32768,
    _ISblank___8 = 1,
    _IScntrl___8 = 2,
    _ISpunct___8 = 4,
    _ISalnum___8 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__19___8 {
    FP_NAN___9 = 0,
    FP_INFINITE___9 = 1,
    FP_ZERO___9 = 2,
    FP_SUBNORMAL___9 = 3,
    FP_NORMAL___9 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___8 {
    _ISupper___9 = 256,
    _ISlower___9 = 512,
    _ISalpha___9 = 1024,
    _ISdigit___9 = 2048,
    _ISxdigit___9 = 4096,
    _ISspace___9 = 8192,
    _ISprint___9 = 16384,
    _ISgraph___9 = 32768,
    _ISblank___9 = 1,
    _IScntrl___9 = 2,
    _ISpunct___9 = 4,
    _ISalnum___9 = 8
} ;
#line 192 "/root/patron/new_21/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler ;
#line 1177 "/root/patron/new_21/src/lib/openjp2/j2k.c"
struct j2k_prog_order {
   OPJ_PROG_ORDER enum_prog ;
   char str_prog[5] ;
};
#line 1180 "/root/patron/new_21/src/lib/openjp2/j2k.c"
typedef struct j2k_prog_order j2k_prog_order_t;
#line 1202 "/root/patron/new_21/src/lib/openjp2/j2k.c"
typedef void (*opj_j2k_mct_function)(void const   * , void * , OPJ_UINT32  );
#line 1228 "/root/patron/new_21/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler {
   OPJ_UINT32 id ;
   OPJ_UINT32 states ;
   OPJ_BOOL (*handler)(opj_j2k_t * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 1240 "/root/patron/new_21/src/lib/openjp2/j2k.c"
typedef struct opj_dec_memory_marker_handler opj_dec_memory_marker_handler_t;
#line 853 "/usr/include/math.h"
enum __anonenum__19___9 {
    FP_NAN___10 = 0,
    FP_INFINITE___10 = 1,
    FP_ZERO___10 = 2,
    FP_SUBNORMAL___10 = 3,
    FP_NORMAL___10 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___9 {
    _ISupper___10 = 256,
    _ISlower___10 = 512,
    _ISalpha___10 = 1024,
    _ISdigit___10 = 2048,
    _ISxdigit___10 = 4096,
    _ISspace___10 = 8192,
    _ISprint___10 = 16384,
    _ISgraph___10 = 32768,
    _ISblank___10 = 1,
    _IScntrl___10 = 2,
    _ISpunct___10 = 4,
    _ISalnum___10 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__19___10 {
    FP_NAN___11 = 0,
    FP_INFINITE___11 = 1,
    FP_ZERO___11 = 2,
    FP_SUBNORMAL___11 = 3,
    FP_NORMAL___11 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___10 {
    _ISupper___11 = 256,
    _ISlower___11 = 512,
    _ISalpha___11 = 1024,
    _ISdigit___11 = 2048,
    _ISxdigit___11 = 4096,
    _ISspace___11 = 8192,
    _ISprint___11 = 16384,
    _ISgraph___11 = 32768,
    _ISblank___11 = 1,
    _IScntrl___11 = 2,
    _ISpunct___11 = 4,
    _ISalnum___11 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__19___11 {
    FP_NAN___12 = 0,
    FP_INFINITE___12 = 1,
    FP_ZERO___12 = 2,
    FP_SUBNORMAL___12 = 3,
    FP_NORMAL___12 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___11 {
    _ISupper___12 = 256,
    _ISlower___12 = 512,
    _ISalpha___12 = 1024,
    _ISdigit___12 = 2048,
    _ISxdigit___12 = 4096,
    _ISspace___12 = 8192,
    _ISprint___12 = 16384,
    _ISgraph___12 = 32768,
    _ISblank___12 = 1,
    _IScntrl___12 = 2,
    _ISpunct___12 = 4,
    _ISalnum___12 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__19___12 {
    FP_NAN___13 = 0,
    FP_INFINITE___13 = 1,
    FP_ZERO___13 = 2,
    FP_SUBNORMAL___13 = 3,
    FP_NORMAL___13 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___12 {
    _ISupper___13 = 256,
    _ISlower___13 = 512,
    _ISalpha___13 = 1024,
    _ISdigit___13 = 2048,
    _ISxdigit___13 = 4096,
    _ISspace___13 = 8192,
    _ISprint___13 = 16384,
    _ISgraph___13 = 32768,
    _ISblank___13 = 1,
    _IScntrl___13 = 2,
    _ISpunct___13 = 4,
    _ISalnum___13 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__19___13 {
    FP_NAN___14 = 0,
    FP_INFINITE___14 = 1,
    FP_ZERO___14 = 2,
    FP_SUBNORMAL___14 = 3,
    FP_NORMAL___14 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___13 {
    _ISupper___14 = 256,
    _ISlower___14 = 512,
    _ISalpha___14 = 1024,
    _ISdigit___14 = 2048,
    _ISxdigit___14 = 4096,
    _ISspace___14 = 8192,
    _ISprint___14 = 16384,
    _ISgraph___14 = 32768,
    _ISblank___14 = 1,
    _IScntrl___14 = 2,
    _ISpunct___14 = 4,
    _ISalnum___14 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__19___14 {
    FP_NAN___15 = 0,
    FP_INFINITE___15 = 1,
    FP_ZERO___15 = 2,
    FP_SUBNORMAL___15 = 3,
    FP_NORMAL___15 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___14 {
    _ISupper___15 = 256,
    _ISlower___15 = 512,
    _ISalpha___15 = 1024,
    _ISdigit___15 = 2048,
    _ISxdigit___15 = 4096,
    _ISspace___15 = 8192,
    _ISprint___15 = 16384,
    _ISgraph___15 = 32768,
    _ISblank___15 = 1,
    _IScntrl___15 = 2,
    _ISpunct___15 = 4,
    _ISalnum___15 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__19___15 {
    FP_NAN___16 = 0,
    FP_INFINITE___16 = 1,
    FP_ZERO___16 = 2,
    FP_SUBNORMAL___16 = 3,
    FP_NORMAL___16 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___15 {
    _ISupper___16 = 256,
    _ISlower___16 = 512,
    _ISalpha___16 = 1024,
    _ISdigit___16 = 2048,
    _ISxdigit___16 = 4096,
    _ISspace___16 = 8192,
    _ISprint___16 = 16384,
    _ISgraph___16 = 32768,
    _ISblank___16 = 1,
    _IScntrl___16 = 2,
    _ISpunct___16 = 4,
    _ISalnum___16 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__81 {
    FP_NAN___17 = 0,
    FP_INFINITE___17 = 1,
    FP_ZERO___17 = 2,
    FP_SUBNORMAL___17 = 3,
    FP_NORMAL___17 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__101 {
    _ISupper___17 = 256,
    _ISlower___17 = 512,
    _ISalpha___17 = 1024,
    _ISdigit___17 = 2048,
    _ISxdigit___17 = 4096,
    _ISspace___17 = 8192,
    _ISprint___17 = 16384,
    _ISgraph___17 = 32768,
    _ISblank___17 = 1,
    _IScntrl___17 = 2,
    _ISpunct___17 = 4,
    _ISalnum___17 = 8
} ;
#line 66 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef signed char int8;
#line 67 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned char uint8;
#line 69 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef short int16;
#line 70 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned short uint16;
#line 72 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef int int32;
#line 73 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned int uint32;
#line 75 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef long int64;
#line 76 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned long uint64;
#line 86 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef int uint16_vap;
#line 91 "/usr/include/x86_64-linux-gnu/tiff.h"
struct __anonstruct_102 {
   uint16 tiff_magic ;
   uint16 tiff_version ;
};
#line 94 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef struct __anonstruct_102 TIFFHeaderCommon;
#line 95 "/usr/include/x86_64-linux-gnu/tiff.h"
struct __anonstruct_103 {
   uint16 tiff_magic ;
   uint16 tiff_version ;
   uint32 tiff_diroff ;
};
#line 99 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef struct __anonstruct_103 TIFFHeaderClassic;
#line 100 "/usr/include/x86_64-linux-gnu/tiff.h"
struct __anonstruct_104 {
   uint16 tiff_magic ;
   uint16 tiff_version ;
   uint16 tiff_offsetsize ;
   uint16 tiff_unused ;
   uint64 tiff_diroff ;
};
#line 106 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef struct __anonstruct_104 TIFFHeaderBig;
#line 123
enum __anonenum__105 {
    TIFF_NOTYPE = 0,
    TIFF_BYTE = 1,
    TIFF_ASCII = 2,
    TIFF_SHORT = 3,
    TIFF_LONG = 4,
    TIFF_RATIONAL = 5,
    TIFF_SBYTE = 6,
    TIFF_UNDEFINED = 7,
    TIFF_SSHORT = 8,
    TIFF_SLONG = 9,
    TIFF_SRATIONAL = 10,
    TIFF_FLOAT = 11,
    TIFF_DOUBLE = 12,
    TIFF_IFD = 13,
    TIFF_LONG8 = 16,
    TIFF_SLONG8 = 17,
    TIFF_IFD8 = 18
} ;
#line 141 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef enum __anonenum__105 TIFFDataType;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct tiff ;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct tiff TIFF;
#line 65 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef long tmsize_t;
#line 66 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint64 toff_t;
#line 69 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint32 ttag_t;
#line 70 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint16 tdir_t;
#line 71 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint16 tsample_t;
#line 72 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint32 tstrile_t;
#line 73 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tstrile_t tstrip_t;
#line 74 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tstrile_t ttile_t;
#line 75 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tmsize_t tsize_t;
#line 76 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void *tdata_t;
#line 104 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void *thandle_t;
#line 136 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef unsigned char TIFFRGBValue;
#line 138 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_106 {
   float d_mat[3][3] ;
   float d_YCR ;
   float d_YCG ;
   float d_YCB ;
   uint32 d_Vrwr ;
   uint32 d_Vrwg ;
   uint32 d_Vrwb ;
   float d_Y0R ;
   float d_Y0G ;
   float d_Y0B ;
   float d_gammaR ;
   float d_gammaG ;
   float d_gammaB ;
};
#line 152 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_106 TIFFDisplay;
#line 154 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_107 {
   TIFFRGBValue *clamptab ;
   int *Cr_r_tab ;
   int *Cb_b_tab ;
   int32 *Cr_g_tab ;
   int32 *Cb_g_tab ;
   int32 *Y_tab ;
};
#line 161 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_107 TIFFYCbCrToRGB;
#line 163 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_108 {
   int range ;
   float rstep ;
   float gstep ;
   float bstep ;
   float X0 ;
   float Y0 ;
   float Z0 ;
   TIFFDisplay display ;
   float Yr2r[1501] ;
   float Yg2g[1501] ;
   float Yb2b[1501] ;
};
#line 172 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_108 TIFFCIELabToRGB;
#line 177
struct _TIFFRGBAImage ;
#line 177 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct _TIFFRGBAImage TIFFRGBAImage;
#line 188 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*tileContigRoutine)(TIFFRGBAImage * , uint32 * , uint32  , uint32  ,
                                  uint32  , uint32  , int32  , int32  , unsigned char * );
#line 191 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*tileSeparateRoutine)(TIFFRGBAImage * , uint32 * , uint32  , uint32  ,
                                    uint32  , uint32  , int32  , int32  , unsigned char * ,
                                    unsigned char * , unsigned char * , unsigned char * );
#line 215 "/usr/include/x86_64-linux-gnu/tiffio.h"
union __anonunion_109 {
   void (*any)(TIFFRGBAImage * ) ;
   tileContigRoutine contig ;
   tileSeparateRoutine separate ;
};
#line 197 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct _TIFFRGBAImage {
   TIFF *tif ;
   int stoponerr ;
   int isContig ;
   int alpha ;
   uint32 width ;
   uint32 height ;
   uint16 bitspersample ;
   uint16 samplesperpixel ;
   uint16 orientation ;
   uint16 req_orientation ;
   uint16 photometric ;
   uint16 *redcmap ;
   uint16 *greencmap ;
   uint16 *bluecmap ;
   int (*get)(TIFFRGBAImage * , uint32 * , uint32  , uint32  ) ;
   union __anonunion_109 put ;
   TIFFRGBValue *Map ;
   uint32 **BWmap ;
   uint32 **PALmap ;
   TIFFYCbCrToRGB *ycbcr ;
   TIFFCIELabToRGB *cielab ;
   uint8 *UaToAa ;
   uint8 *Bitdepth16To8 ;
   int row_offset ;
   int col_offset ;
};
#line 249 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef int (*TIFFInitMethod)(TIFF * , int  );
#line 250 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_110 {
   char *name ;
   uint16 scheme ;
   TIFFInitMethod init ;
};
#line 254 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_110 TIFFCodec;
#line 271 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*TIFFErrorHandler)(char const   * , char const   * , va_list  );
#line 272 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*TIFFErrorHandlerExt)(thandle_t  , char const   * , char const   * ,
                                    va_list  );
#line 273 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tmsize_t (*TIFFReadWriteProc)(thandle_t  , void * , tmsize_t  );
#line 274 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef toff_t (*TIFFSeekProc)(thandle_t  , toff_t  , int  );
#line 275 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef int (*TIFFCloseProc)(thandle_t  );
#line 276 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef toff_t (*TIFFSizeProc)(thandle_t  );
#line 277 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef int (*TIFFMapFileProc)(thandle_t  , void ** , toff_t * );
#line 278 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*TIFFUnmapFileProc)(thandle_t  , void * , toff_t  );
#line 279 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*TIFFExtendProc)(TIFF * );
#line 314
struct _TIFFField ;
#line 314 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct _TIFFField TIFFField;
#line 315
struct _TIFFFieldArray ;
#line 315 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct _TIFFFieldArray TIFFFieldArray;
#line 328 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef int (*TIFFVSetMethod)(TIFF * , uint32  , va_list  );
#line 329 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef int (*TIFFVGetMethod)(TIFF * , uint32  , va_list  );
#line 330 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*TIFFPrintMethod)(TIFF * , FILE * , long  );
#line 332 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_111 {
   TIFFVSetMethod vsetfield ;
   TIFFVGetMethod vgetfield ;
   TIFFPrintMethod printdir ;
};
#line 336 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_111 TIFFTagMethods;
#line 542 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_112 {
   ttag_t field_tag ;
   short field_readcount ;
   short field_writecount ;
   TIFFDataType field_type ;
   unsigned short field_bit ;
   unsigned char field_oktochange ;
   unsigned char field_passcount ;
   char *field_name ;
};
#line 551 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_112 TIFFFieldInfo;
#line 248 "/usr/include/zconf.h"
typedef size_t z_size_t;
#line 391 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 393 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 394 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 400 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 402 "/usr/include/zconf.h"
typedef char charf;
#line 403 "/usr/include/zconf.h"
typedef int intf;
#line 404 "/usr/include/zconf.h"
typedef uInt uIntf;
#line 405 "/usr/include/zconf.h"
typedef uLong uLongf;
#line 408 "/usr/include/zconf.h"
typedef void const   *voidpc;
#line 409 "/usr/include/zconf.h"
typedef void *voidpf;
#line 410 "/usr/include/zconf.h"
typedef void *voidp;
#line 429 "/usr/include/zconf.h"
typedef unsigned int z_crc_t;
#line 255 "/usr/include/unistd.h"
typedef __useconds_t useconds_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__114 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20
} ;
#line 71
enum __anonenum__115 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248
} ;
#line 533
enum __anonenum__116 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149
} ;
#line 81 "/usr/include/zlib.h"
typedef voidpf (*alloc_func)(voidpf  , uInt  , uInt  );
#line 82 "/usr/include/zlib.h"
typedef void (*free_func)(voidpf  , voidpf  );
#line 84
struct internal_state ;
#line 86 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   alloc_func zalloc ;
   free_func zfree ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 106 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 108 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 114 "/usr/include/zlib.h"
struct gz_header_s {
   int text ;
   uLong time ;
   int xflags ;
   int os ;
   Bytef *extra ;
   uInt extra_len ;
   uInt extra_max ;
   Bytef *name ;
   uInt name_max ;
   Bytef *comment ;
   uInt comm_max ;
   int hcrc ;
   int done ;
};
#line 129 "/usr/include/zlib.h"
typedef struct gz_header_s gz_header;
#line 131 "/usr/include/zlib.h"
typedef gz_header *gz_headerp;
#line 1093 "/usr/include/zlib.h"
typedef unsigned int (*in_func)(void * , unsigned char ** );
#line 1095 "/usr/include/zlib.h"
typedef int (*out_func)(void * , unsigned char * , unsigned int  );
#line 1301
struct gzFile_s ;
#line 1301 "/usr/include/zlib.h"
typedef struct gzFile_s *gzFile;
#line 1818 "/usr/include/zlib.h"
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off_t pos ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 33 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 45 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 83 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 481 "/usr/include/pngconf.h"
typedef unsigned char png_byte;
#line 489 "/usr/include/pngconf.h"
typedef short png_int_16;
#line 497 "/usr/include/pngconf.h"
typedef unsigned short png_uint_16;
#line 503 "/usr/include/pngconf.h"
typedef int png_int_32;
#line 511 "/usr/include/pngconf.h"
typedef unsigned int png_uint_32;
#line 523 "/usr/include/pngconf.h"
typedef size_t png_size_t;
#line 524 "/usr/include/pngconf.h"
typedef ptrdiff_t png_ptrdiff_t;
#line 557 "/usr/include/pngconf.h"
typedef size_t png_alloc_size_t;
#line 574 "/usr/include/pngconf.h"
typedef png_int_32 png_fixed_point;
#line 577 "/usr/include/pngconf.h"
typedef void *png_voidp;
#line 578 "/usr/include/pngconf.h"
typedef void const   *png_const_voidp;
#line 579 "/usr/include/pngconf.h"
typedef png_byte *png_bytep;
#line 580 "/usr/include/pngconf.h"
typedef png_byte *png_const_bytep;
#line 581 "/usr/include/pngconf.h"
typedef png_uint_32 *png_uint_32p;
#line 582 "/usr/include/pngconf.h"
typedef png_uint_32 *png_const_uint_32p;
#line 583 "/usr/include/pngconf.h"
typedef png_int_32 *png_int_32p;
#line 584 "/usr/include/pngconf.h"
typedef png_int_32 *png_const_int_32p;
#line 585 "/usr/include/pngconf.h"
typedef png_uint_16 *png_uint_16p;
#line 586 "/usr/include/pngconf.h"
typedef png_uint_16 *png_const_uint_16p;
#line 587 "/usr/include/pngconf.h"
typedef png_int_16 *png_int_16p;
#line 588 "/usr/include/pngconf.h"
typedef png_int_16 *png_const_int_16p;
#line 589 "/usr/include/pngconf.h"
typedef char *png_charp;
#line 590 "/usr/include/pngconf.h"
typedef char const   *png_const_charp;
#line 591 "/usr/include/pngconf.h"
typedef png_fixed_point *png_fixed_point_p;
#line 592 "/usr/include/pngconf.h"
typedef png_fixed_point *png_const_fixed_point_p;
#line 593 "/usr/include/pngconf.h"
typedef size_t *png_size_tp;
#line 594 "/usr/include/pngconf.h"
typedef size_t *png_const_size_tp;
#line 597 "/usr/include/pngconf.h"
typedef FILE *png_FILE_p;
#line 601 "/usr/include/pngconf.h"
typedef double *png_doublep;
#line 602 "/usr/include/pngconf.h"
typedef double const   *png_const_doublep;
#line 606 "/usr/include/pngconf.h"
typedef png_byte **png_bytepp;
#line 607 "/usr/include/pngconf.h"
typedef png_uint_32 **png_uint_32pp;
#line 608 "/usr/include/pngconf.h"
typedef png_int_32 **png_int_32pp;
#line 609 "/usr/include/pngconf.h"
typedef png_uint_16 **png_uint_16pp;
#line 610 "/usr/include/pngconf.h"
typedef png_int_16 **png_int_16pp;
#line 611 "/usr/include/pngconf.h"
typedef char const   **png_const_charpp;
#line 612 "/usr/include/pngconf.h"
typedef char **png_charpp;
#line 613 "/usr/include/pngconf.h"
typedef png_fixed_point **png_fixed_point_pp;
#line 615 "/usr/include/pngconf.h"
typedef double **png_doublepp;
#line 619 "/usr/include/pngconf.h"
typedef char ***png_charppp;
#line 446 "/usr/include/png.h"
typedef char *png_libpng_version_1_6_37;
#line 454
struct png_struct_def ;
#line 454 "/usr/include/png.h"
typedef struct png_struct_def png_struct;
#line 455 "/usr/include/png.h"
typedef png_struct *png_const_structp;
#line 456 "/usr/include/png.h"
typedef png_struct *png_structp;
#line 457 "/usr/include/png.h"
typedef png_struct **png_structpp;
#line 468
struct png_info_def ;
#line 468 "/usr/include/png.h"
typedef struct png_info_def png_info;
#line 469 "/usr/include/png.h"
typedef png_info *png_infop;
#line 470 "/usr/include/png.h"
typedef png_info *png_const_infop;
#line 471 "/usr/include/png.h"
typedef png_info **png_infopp;
#line 484 "/usr/include/png.h"
typedef png_struct *png_structrp;
#line 485 "/usr/include/png.h"
typedef png_struct *png_const_structrp;
#line 486 "/usr/include/png.h"
typedef png_info *png_inforp;
#line 487 "/usr/include/png.h"
typedef png_info *png_const_inforp;
#line 493 "/usr/include/png.h"
struct png_color_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
};
#line 498 "/usr/include/png.h"
typedef struct png_color_struct png_color;
#line 499 "/usr/include/png.h"
typedef png_color *png_colorp;
#line 500 "/usr/include/png.h"
typedef png_color *png_const_colorp;
#line 501 "/usr/include/png.h"
typedef png_color **png_colorpp;
#line 503 "/usr/include/png.h"
struct png_color_16_struct {
   png_byte index ;
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 gray ;
};
#line 510 "/usr/include/png.h"
typedef struct png_color_16_struct png_color_16;
#line 511 "/usr/include/png.h"
typedef png_color_16 *png_color_16p;
#line 512 "/usr/include/png.h"
typedef png_color_16 *png_const_color_16p;
#line 513 "/usr/include/png.h"
typedef png_color_16 **png_color_16pp;
#line 515 "/usr/include/png.h"
struct png_color_8_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
   png_byte gray ;
   png_byte alpha ;
};
#line 522 "/usr/include/png.h"
typedef struct png_color_8_struct png_color_8;
#line 523 "/usr/include/png.h"
typedef png_color_8 *png_color_8p;
#line 524 "/usr/include/png.h"
typedef png_color_8 *png_const_color_8p;
#line 525 "/usr/include/png.h"
typedef png_color_8 **png_color_8pp;
#line 531 "/usr/include/png.h"
struct png_sPLT_entry_struct {
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 alpha ;
   png_uint_16 frequency ;
};
#line 538 "/usr/include/png.h"
typedef struct png_sPLT_entry_struct png_sPLT_entry;
#line 539 "/usr/include/png.h"
typedef png_sPLT_entry *png_sPLT_entryp;
#line 540 "/usr/include/png.h"
typedef png_sPLT_entry *png_const_sPLT_entryp;
#line 541 "/usr/include/png.h"
typedef png_sPLT_entry **png_sPLT_entrypp;
#line 548 "/usr/include/png.h"
struct png_sPLT_struct {
   png_charp name ;
   png_byte depth ;
   png_sPLT_entryp entries ;
   png_int_32 nentries ;
};
#line 554 "/usr/include/png.h"
typedef struct png_sPLT_struct png_sPLT_t;
#line 555 "/usr/include/png.h"
typedef png_sPLT_t *png_sPLT_tp;
#line 556 "/usr/include/png.h"
typedef png_sPLT_t *png_const_sPLT_tp;
#line 557 "/usr/include/png.h"
typedef png_sPLT_t **png_sPLT_tpp;
#line 577 "/usr/include/png.h"
struct png_text_struct {
   int compression ;
   png_charp key ;
   png_charp text ;
   size_t text_length ;
   size_t itxt_length ;
   png_charp lang ;
   png_charp lang_key ;
};
#line 593 "/usr/include/png.h"
typedef struct png_text_struct png_text;
#line 594 "/usr/include/png.h"
typedef png_text *png_textp;
#line 595 "/usr/include/png.h"
typedef png_text *png_const_textp;
#line 596 "/usr/include/png.h"
typedef png_text **png_textpp;
#line 615 "/usr/include/png.h"
struct png_time_struct {
   png_uint_16 year ;
   png_byte month ;
   png_byte day ;
   png_byte hour ;
   png_byte minute ;
   png_byte second ;
};
#line 623 "/usr/include/png.h"
typedef struct png_time_struct png_time;
#line 624 "/usr/include/png.h"
typedef png_time *png_timep;
#line 625 "/usr/include/png.h"
typedef png_time *png_const_timep;
#line 626 "/usr/include/png.h"
typedef png_time **png_timepp;
#line 637 "/usr/include/png.h"
struct png_unknown_chunk_t {
   png_byte name[5] ;
   png_byte *data ;
   size_t size ;
   png_byte location ;
};
#line 651 "/usr/include/png.h"
typedef struct png_unknown_chunk_t png_unknown_chunk;
#line 653 "/usr/include/png.h"
typedef png_unknown_chunk *png_unknown_chunkp;
#line 654 "/usr/include/png.h"
typedef png_unknown_chunk *png_const_unknown_chunkp;
#line 655 "/usr/include/png.h"
typedef png_unknown_chunk **png_unknown_chunkpp;
#line 773 "/usr/include/png.h"
struct png_row_info_struct {
   png_uint_32 width ;
   size_t rowbytes ;
   png_byte color_type ;
   png_byte bit_depth ;
   png_byte channels ;
   png_byte pixel_depth ;
};
#line 781 "/usr/include/png.h"
typedef struct png_row_info_struct png_row_info;
#line 783 "/usr/include/png.h"
typedef png_row_info *png_row_infop;
#line 784 "/usr/include/png.h"
typedef png_row_info **png_row_infopp;
#line 794 "/usr/include/png.h"
typedef void (*png_error_ptr)(png_structp  , png_const_charp  );
#line 795 "/usr/include/png.h"
typedef void (*png_rw_ptr)(png_structp  , png_bytep  , size_t  );
#line 796 "/usr/include/png.h"
typedef void (*png_flush_ptr)(png_structp  );
#line 797 "/usr/include/png.h"
typedef void (*png_read_status_ptr)(png_structp  , png_uint_32  , int  );
#line 799 "/usr/include/png.h"
typedef void (*png_write_status_ptr)(png_structp  , png_uint_32  , int  );
#line 803 "/usr/include/png.h"
typedef void (*png_progressive_info_ptr)(png_structp  , png_infop  );
#line 804 "/usr/include/png.h"
typedef void (*png_progressive_end_ptr)(png_structp  , png_infop  );
#line 806 "/usr/include/png.h"
typedef void (*png_progressive_frame_ptr)(png_structp  , png_uint_32  );
#line 820 "/usr/include/png.h"
typedef void (*png_progressive_row_ptr)(png_structp  , png_bytep  , png_uint_32  ,
                                        int  );
#line 826 "/usr/include/png.h"
typedef void (*png_user_transform_ptr)(png_structp  , png_row_infop  , png_bytep  );
#line 831 "/usr/include/png.h"
typedef int (*png_user_chunk_ptr)(png_structp  , png_unknown_chunkp  );
#line 851 "/usr/include/png.h"
typedef void (*png_longjmp_ptr)(jmp_buf  , int  );
#line 890 "/usr/include/png.h"
typedef png_voidp (*png_malloc_ptr)(png_structp  , png_alloc_size_t  );
#line 892 "/usr/include/png.h"
typedef void (*png_free_ptr)(png_structp  , png_voidp  );
#line 2694
struct png_control ;
#line 2694 "/usr/include/png.h"
typedef struct png_control *png_controlp;
#line 2695 "/usr/include/png.h"
struct __anonstruct_117 {
   png_controlp opaque ;
   png_uint_32 version ;
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 format ;
   png_uint_32 flags ;
   png_uint_32 colormap_entries ;
   png_uint_32 warning_or_error ;
   char message[64] ;
};
#line 2731 "/usr/include/png.h"
typedef struct __anonstruct_117 png_image;
#line 2731 "/usr/include/png.h"
typedef struct __anonstruct_117 *png_imagep;
#line 42 "/root/patron/new_21/src/bin/jp2/convert.h"
struct raw_comp_cparameters {
   int dx ;
   int dy ;
};
#line 48 "/root/patron/new_21/src/bin/jp2/convert.h"
typedef struct raw_comp_cparameters raw_comp_cparameters_t;
#line 52 "/root/patron/new_21/src/bin/jp2/convert.h"
struct raw_cparameters {
   int rawWidth ;
   int rawHeight ;
   int rawComp ;
   int rawBitDepth ;
   OPJ_BOOL rawSigned ;
   raw_comp_cparameters_t *rawComps ;
};
#line 66 "/root/patron/new_21/src/bin/jp2/convert.h"
typedef struct raw_cparameters raw_cparameters_t;
#line 539 "/root/patron/new_21/src/bin/jp2/convert.c"
typedef unsigned short WORD;
#line 542 "/root/patron/new_21/src/bin/jp2/convert.c"
typedef unsigned int DWORD;
#line 544 "/root/patron/new_21/src/bin/jp2/convert.c"
struct __anonstruct_118 {
   WORD bfType ;
   DWORD bfSize ;
   WORD bfReserved1 ;
   WORD bfReserved2 ;
   DWORD bfOffBits ;
};
#line 550 "/root/patron/new_21/src/bin/jp2/convert.c"
typedef struct __anonstruct_118 BITMAPFILEHEADER_t;
#line 552 "/root/patron/new_21/src/bin/jp2/convert.c"
struct __anonstruct_119 {
   DWORD biSize ;
   DWORD biWidth ;
   DWORD biHeight ;
   WORD biPlanes ;
   WORD biBitCount ;
   DWORD biCompression ;
   DWORD biSizeImage ;
   DWORD biXpelsPerMeter ;
   DWORD biYpelsPerMeter ;
   DWORD biClrUsed ;
   DWORD biClrImportant ;
};
#line 564 "/root/patron/new_21/src/bin/jp2/convert.c"
typedef struct __anonstruct_119 BITMAPINFOHEADER_t;
#line 1532 "/root/patron/new_21/src/bin/jp2/convert.c"
struct pnm_header {
   int width ;
   int height ;
   int maxval ;
   int depth ;
   int format ;
   char rgb ;
   char rgba ;
   char gray ;
   char graya ;
   char bw ;
   char ok ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__140 {
    FP_NAN___18 = 0,
    FP_INFINITE___18 = 1,
    FP_ZERO___18 = 2,
    FP_SUBNORMAL___18 = 3,
    FP_NORMAL___18 = 4
} ;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 97 "/usr/include/dirent.h"
enum __anonenum__141 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
} ;
#line 127
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 6 "/root/patron/new_21/src/bin/common/opj_getopt.h"
struct opj_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 12 "/root/patron/new_21/src/bin/common/opj_getopt.h"
typedef struct opj_option opj_option_t;
#line 76 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
struct dircnt {
   char *filename_buf ;
   char **filename ;
};
#line 81 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
typedef struct dircnt dircnt_t;
#line 84 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
struct img_folder {
   char *imgdirpath ;
   char const   *out_format ;
   char set_imgdir ;
   char set_out_format ;
};
#line 94 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
typedef struct img_folder img_fol_t;
#line 853 "/usr/include/math.h"
enum __anonenum__140___0 {
    FP_NAN___19 = 0,
    FP_INFINITE___19 = 1,
    FP_ZERO___19 = 2,
    FP_SUBNORMAL___19 = 3,
    FP_NORMAL___19 = 4
} ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                  size_t __n ) ;
#line 47
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n ) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 91
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 122
extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src ) ;
#line 125
extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                   size_t __n ) ;
#line 130
extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src ) ;
#line 133
extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                   size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 147
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 156
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 160
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 167
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 175
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 277
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 303
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 341
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 346
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 391
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 410
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 428
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                size_t __n ) ;
#line 42
extern  __attribute__((__nothrow__)) void bzero(void *__s , size_t __n ) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 436 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void explicit_bzero(void *__s , size_t __n ) ;
#line 440
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 447
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 450
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 452
extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src ) ;
#line 457
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 460
extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                   size_t __n ) ;
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 101
extern  __attribute__((__nothrow__)) double atof(char const   *__nptr ) ;
#line 104
extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr ) ;
#line 107
extern  __attribute__((__nothrow__)) long atol(char const   *__nptr ) ;
#line 112
extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr ) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 123
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 126
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 180
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 192
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 205
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 385
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 388
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 113
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 401 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 404
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 410
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 415
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 434
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 437
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 440
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 445
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 453
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 455
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 459
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 467
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 468
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 471
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 472
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 476
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 477
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 481
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 482
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 484
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 501
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 503
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 508
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 511
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 517
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 520
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 526
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 529
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 532
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 559
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 574 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 580
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 591
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 595
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 603
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 623
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 629
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 647
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 653
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 657
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 664
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 675
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 688
extern int mkstemp(char *__template ) ;
#line 710
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 731
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 784
extern int system(char const   *__command ) ;
#line 800
extern  __attribute__((__nothrow__)) char *realpath(char const   *__name , char *__resolved ) ;
#line 820
extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                     size_t __size , __compar_fn_t __compar ) ;
#line 830
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 841
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 844
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 854
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 858
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 872
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 878
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 884
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 890
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 893
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 896
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 902
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 905
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 909
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 922
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 925
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 929
extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar ) ;
#line 933
extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__pwcs , char const   *__s ,
                                                     size_t __n ) ;
#line 936
extern  __attribute__((__nothrow__)) size_t wcstombs(char *__s , wchar_t *__pwcs ,
                                                     size_t __n ) ;
#line 946
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 957
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 1003
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 217
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 249
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 185
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 185
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 189
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 189
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 196
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 201
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 217
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 217
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 249
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 256
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 259
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 276
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 290
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 294
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 307
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 326
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 326
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 335
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 335
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 400
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 400
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 217
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 249
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 773 "/usr/include/math.h"
extern int signgam ;
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 75
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 78
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 82
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 88
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 104
extern  __attribute__((__nothrow__)) size_t strftime_l(char *__s , size_t __maxsize ,
                                                       char const   *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 119
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 128
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 133
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 139
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 142
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 149
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 153
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 159
extern char *__tzname[2] ;
#line 160
extern int __daylight ;
#line 161
extern long __timezone ;
#line 166
extern char *tzname[2] ;
#line 170
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 174
extern int daylight ;
#line 175
extern long timezone ;
#line 190
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 193
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 196
extern  __attribute__((__nothrow__)) int dysize(int __year ) ;
#line 205
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 210
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 213
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 216
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 224
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 229
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 234
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 239
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 242
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 247
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 251
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 257
extern  __attribute__((__nothrow__)) int timespec_get(struct timespec *__ts , int __base ) ;
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 148
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 152
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 173
extern FILE *tmpfile(void) ;
#line 187
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
#line 192
extern  __attribute__((__nothrow__)) char *tmpnam_r(char *__s ) ;
#line 204
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 227
extern int fflush_unlocked(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 252
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 279
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 292
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 298
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 304
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 308
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 314
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 318
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 326
extern int fprintf(FILE *__stream , char const   *__format  , ...) ;
#line 332
extern int printf(char const   *__format  , ...) ;
#line 334
extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__format 
                                                 , ...) ;
#line 341
extern int vfprintf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 347
extern int vprintf(char const   *__format , __gnuc_va_list __arg ) ;
#line 349
extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__format ,
                                                  __gnuc_va_list __arg ) ;
#line 354
extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __maxlen , char const   *__format 
                                                  , ...) ;
#line 358
extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __maxlen , char const   *__format ,
                                                   __gnuc_va_list __arg ) ;
#line 379
extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 382
extern int dprintf(int __fd , char const   *__fmt  , ...) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 397
extern int scanf(char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 432
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 440
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 444
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
extern int getchar(void) ;
#line 499
extern int getc_unlocked(FILE *__stream ) ;
#line 500
extern int getchar_unlocked(void) ;
#line 510
extern int fgetc_unlocked(FILE *__stream ) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
extern int putchar(int __c ) ;
#line 537
extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 545
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 546
extern int putchar_unlocked(int __c ) ;
#line 553
extern int getw(FILE *__stream ) ;
#line 556
extern int putw(int __w , FILE *__stream ) ;
#line 564
extern char *fgets(char *__s , int __n , FILE *__stream ) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 606
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 646
extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 673
extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 675
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 731
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 766
extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream ) ;
#line 767
extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream ) ;
#line 775
extern void perror(char const   *__s ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern int sys_nerr ;
#line 27
extern char const   * const  sys_errlist[] ;
#line 786 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 791
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 812
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 840
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 844
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 847
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 125
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 142
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
#line 146
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
#line 150
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
#line 151
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
#line 251
extern  __attribute__((__nothrow__)) int isalnum_l(int  , locale_t  ) ;
#line 252
extern  __attribute__((__nothrow__)) int isalpha_l(int  , locale_t  ) ;
#line 253
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , locale_t  ) ;
#line 254
extern  __attribute__((__nothrow__)) int isdigit_l(int  , locale_t  ) ;
#line 255
extern  __attribute__((__nothrow__)) int islower_l(int  , locale_t  ) ;
#line 256
extern  __attribute__((__nothrow__)) int isgraph_l(int  , locale_t  ) ;
#line 257
extern  __attribute__((__nothrow__)) int isprint_l(int  , locale_t  ) ;
#line 258
extern  __attribute__((__nothrow__)) int ispunct_l(int  , locale_t  ) ;
#line 259
extern  __attribute__((__nothrow__)) int isspace_l(int  , locale_t  ) ;
#line 260
extern  __attribute__((__nothrow__)) int isupper_l(int  , locale_t  ) ;
#line 261
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , locale_t  ) ;
#line 263
extern  __attribute__((__nothrow__)) int isblank_l(int  , locale_t  ) ;
#line 267
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , locale_t __l ) ;
#line 268
extern  __attribute__((__nothrow__)) int tolower_l(int __c , locale_t __l ) ;
#line 271
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , locale_t __l ) ;
#line 272
extern  __attribute__((__nothrow__)) int toupper_l(int __c , locale_t __l ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__)) void __assert_fail(char const   *__assertion ,
                                                        char const   *__file , unsigned int __line ,
                                                        char const   *__function ) ;
#line 74
extern  __attribute__((__nothrow__)) void __assert_perror_fail(int __errnum , char const   *__file ,
                                                               unsigned int __line ,
                                                               char const   *__function ) ;
#line 81
extern  __attribute__((__nothrow__)) void __assert(char const   *__assertion , char const   *__file ,
                                                   int __line ) ;
#line 1051 "/root/patron/new_21/src/lib/openjp2/openjpeg.h"
char const   *opj_version(void) ;
#line 1067
opj_image_t *opj_image_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                              OPJ_COLOR_SPACE clrspc ) ;
#line 1074
void opj_image_destroy(opj_image_t *image ) ;
#line 1085
opj_image_t *opj_image_tile_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                                   OPJ_COLOR_SPACE clrspc ) ;
#line 1100
opj_stream_t *opj_stream_default_create(OPJ_BOOL l_is_input ) ;
#line 1110
opj_stream_t *opj_stream_create(OPJ_SIZE_T p_buffer_size , OPJ_BOOL l_is_input ) ;
#line 1118
void opj_stream_destroy(opj_stream_t *p_stream ) ;
#line 1125
void opj_stream_set_read_function(opj_stream_t *p_stream , opj_stream_read_fn p_function ) ;
#line 1132
void opj_stream_set_write_function(opj_stream_t *p_stream , opj_stream_write_fn p_function ) ;
#line 1139
void opj_stream_set_skip_function(opj_stream_t *p_stream , opj_stream_skip_fn p_function ) ;
#line 1146
void opj_stream_set_seek_function(opj_stream_t *p_stream , opj_stream_seek_fn p_function ) ;
#line 1154
void opj_stream_set_user_data(opj_stream_t *p_stream , void *p_data , opj_stream_free_user_data_fn p_function ) ;
#line 1162
void opj_stream_set_user_data_length(opj_stream_t *p_stream , OPJ_UINT64 data_length ) ;
#line 1169
opj_stream_t *opj_stream_create_default_file_stream(char const   *fname , OPJ_BOOL p_is_read_stream ) ;
#line 1176
opj_stream_t *opj_stream_create_file_stream(char const   *fname , OPJ_SIZE_T p_size ,
                                            OPJ_BOOL p_is_read_stream ) ;
#line 1191
OPJ_BOOL opj_set_info_handler(opj_codec_t *p_codec , opj_msg_callback p_callback ,
                              void *p_user_data ) ;
#line 1200
OPJ_BOOL opj_set_warning_handler(opj_codec_t *p_codec , opj_msg_callback p_callback ,
                                 void *p_user_data ) ;
#line 1209
OPJ_BOOL opj_set_error_handler(opj_codec_t *p_codec , opj_msg_callback p_callback ,
                               void *p_user_data ) ;
#line 1225
opj_codec_t *opj_create_decompress(OPJ_CODEC_FORMAT p_format ) ;
#line 1232
void opj_destroy_codec(opj_codec_t *p_codec ) ;
#line 1239
OPJ_BOOL opj_end_decompress(opj_codec_t *p_codec , opj_stream_t *p_stream ) ;
#line 1247
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) ;
#line 1258
OPJ_BOOL opj_setup_decoder(opj_codec_t *p_codec , opj_dparameters_t *parameters ) ;
#line 1270
OPJ_BOOL opj_read_header(opj_stream_t *p_stream , opj_codec_t *p_codec , opj_image_t **p_image ) ;
#line 1286
OPJ_BOOL opj_set_decode_area(opj_codec_t *p_codec , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                             OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ) ;
#line 1299
OPJ_BOOL opj_decode(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ) ;
#line 1313
OPJ_BOOL opj_get_decoded_tile(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ,
                              OPJ_UINT32 tile_index ) ;
#line 1325
OPJ_BOOL opj_set_decoded_resolution_factor(opj_codec_t *p_codec , OPJ_UINT32 res_factor ) ;
#line 1339
OPJ_BOOL opj_write_tile(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                        OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) ;
#line 1366
OPJ_BOOL opj_read_tile_header(opj_codec_t *p_codec , opj_stream_t *p_stream , OPJ_UINT32 *p_tile_index ,
                              OPJ_UINT32 *p_data_size , OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 ,
                              OPJ_INT32 *p_tile_x1 , OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                              OPJ_BOOL *p_should_go_on ) ;
#line 1387
OPJ_BOOL opj_decode_tile_data(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                              OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) ;
#line 1400
opj_codec_t *opj_create_compress(OPJ_CODEC_FORMAT p_format ) ;
#line 1423
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) ;
#line 1431
OPJ_BOOL opj_setup_encoder(opj_codec_t *p_codec , opj_cparameters_t *parameters ,
                           opj_image_t *p_image ) ;
#line 1441
OPJ_BOOL opj_start_compress(opj_codec_t *p_codec , opj_image_t *p_image , opj_stream_t *p_stream ) ;
#line 1450
OPJ_BOOL opj_end_compress(opj_codec_t *p_codec , opj_stream_t *p_stream ) ;
#line 1460
OPJ_BOOL opj_encode(opj_codec_t *p_info , opj_stream_t *p_stream ) ;
#line 1473
void opj_destroy_cstr_info(opj_codestream_info_v2_t **cstr_info ) ;
#line 1484
void opj_dump_codec(opj_codec_t *p_codec , OPJ_INT32 info_flag , FILE *output_stream ) ;
#line 1496
opj_codestream_info_v2_t *opj_get_cstr_info(opj_codec_t *p_codec ) ;
#line 1506
opj_codestream_index_t *opj_get_cstr_index(opj_codec_t *p_codec ) ;
#line 1508
void opj_destroy_cstr_index(opj_codestream_index_t **p_cstr_index ) ;
#line 1519
opj_jp2_metadata_t *opj_get_jp2_metadata(opj_codec_t *p_codec ) ;
#line 1529
opj_jp2_index_t *opj_get_jp2_index(opj_codec_t *p_codec ) ;
#line 1548
OPJ_BOOL opj_set_MCT(opj_cparameters_t *parameters , OPJ_FLOAT32 *pEncodingMatrix ,
                     OPJ_INT32 *p_dc_shift , OPJ_UINT32 pNbComp ) ;
#line 290 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t imaxabs(intmax_t __n ) ;
#line 293
extern  __attribute__((__nothrow__)) imaxdiv_t imaxdiv(intmax_t __numer , intmax_t __denom ) ;
#line 297
extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *__nptr , char **__endptr ,
                                                        int __base ) ;
#line 301
extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *__nptr , char **__endptr ,
                                                         int __base ) ;
#line 305
extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                        int __base ) ;
#line 310
extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                         int __base ) ;
#line 51 "/root/patron/new_21/src/lib/openjp2/opj_clock.h"
OPJ_FLOAT64 opj_clock(void) ;
#line 81 "/root/patron/new_21/src/lib/openjp2/function_list.h"
opj_procedure_list_t *opj_procedure_list_create(void) ;
#line 88
void opj_procedure_list_destroy(opj_procedure_list_t *p_list ) ;
#line 98
OPJ_BOOL opj_procedure_list_add_procedure(opj_procedure_list_t *p_validation_list ,
                                          opj_procedure p_procedure ) ;
#line 107
OPJ_UINT32 opj_procedure_list_get_nb_procedures(opj_procedure_list_t *p_validation_list ) ;
#line 118
opj_procedure *opj_procedure_list_get_first_procedure(opj_procedure_list_t *p_validation_list ) ;
#line 127
void opj_procedure_list_clear(opj_procedure_list_t *p_validation_list ) ;
#line 90 "/root/patron/new_21/src/lib/openjp2/event.h"
OPJ_BOOL opj_event_msg(opj_event_mgr_t *p_event_mgr , OPJ_INT32 event_type , char const   *fmt 
                       , ...) ;
#line 96
void opj_set_default_event_handler(opj_event_mgr_t *p_manager ) ;
#line 76 "/root/patron/new_21/src/lib/openjp2/bio.h"
opj_bio_t *opj_bio_create(void) ;
#line 81
void opj_bio_destroy(opj_bio_t *bio ) ;
#line 87
ptrdiff_t opj_bio_numbytes(opj_bio_t *bio ) ;
#line 94
void opj_bio_init_enc(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 101
void opj_bio_init_dec(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 108
void opj_bio_write(opj_bio_t *bio , OPJ_UINT32 v , OPJ_UINT32 n ) ;
#line 115
OPJ_UINT32 opj_bio_read(opj_bio_t *bio , OPJ_UINT32 n ) ;
#line 121
OPJ_BOOL opj_bio_flush(opj_bio_t *bio ) ;
#line 127
OPJ_BOOL opj_bio_inalign(opj_bio_t *bio ) ;
#line 180 "/root/patron/new_21/src/lib/openjp2/cio.h"
void opj_write_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 189
void opj_read_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 198
void opj_write_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 207
void opj_read_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 215
void opj_write_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) ;
#line 222
void opj_write_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) ;
#line 229
void opj_read_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) ;
#line 236
void opj_read_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) ;
#line 243
void opj_read_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) ;
#line 250
void opj_read_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) ;
#line 257
void opj_write_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) ;
#line 264
void opj_write_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) ;
#line 274
OPJ_SIZE_T opj_stream_read_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) ;
#line 284
OPJ_SIZE_T opj_stream_write_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                 OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) ;
#line 292
OPJ_BOOL opj_stream_flush(opj_stream_private_t *p_stream , opj_event_mgr_t *p_event_mgr ) ;
#line 301
OPJ_OFF_T opj_stream_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , opj_event_mgr_t *p_event_mgr ) ;
#line 310
OPJ_OFF_T opj_stream_tell(opj_stream_private_t *p_stream ) ;
#line 320
OPJ_OFF_T opj_stream_get_number_byte_left(opj_stream_private_t *p_stream ) ;
#line 329
OPJ_OFF_T opj_stream_write_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                                opj_event_mgr_t *p_event_mgr ) ;
#line 338
OPJ_OFF_T opj_stream_read_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) ;
#line 347
OPJ_BOOL opj_stream_read_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                              opj_event_mgr_t *p_event_mgr ) ;
#line 356
OPJ_BOOL opj_stream_write_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) ;
#line 365
OPJ_BOOL opj_stream_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , struct opj_event_mgr *p_event_mgr ) ;
#line 370
OPJ_BOOL opj_stream_has_seek(opj_stream_private_t *p_stream ) ;
#line 375
OPJ_SIZE_T opj_stream_default_read(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) ;
#line 380
OPJ_SIZE_T opj_stream_default_write(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) ;
#line 385
OPJ_OFF_T opj_stream_default_skip(OPJ_OFF_T p_nb_bytes , void *p_user_data ) ;
#line 390
OPJ_BOOL opj_stream_default_seek(OPJ_OFF_T p_nb_bytes , void *p_user_data ) ;
#line 51 "/root/patron/new_21/src/lib/openjp2/image.h"
opj_image_t *opj_image_create0(void) ;
#line 61
void opj_image_comp_header_update(opj_image_t *p_image_header , struct opj_cp *p_cp ) ;
#line 63
void opj_copy_image_header(opj_image_t *p_image_src , opj_image_t *p_image_dest ) ;
#line 56 "/root/patron/new_21/src/lib/openjp2/invert.h"
OPJ_BOOL opj_matrix_inversion_f(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix ,
                                OPJ_UINT32 nb_compo ) ;
#line 587 "/root/patron/new_21/src/lib/openjp2/j2k.h"
void opj_j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) ;
#line 594
opj_j2k_t *opj_j2k_create_compress(void) ;
#line 597
OPJ_BOOL opj_j2k_setup_encoder(opj_j2k_t *p_j2k , opj_cparameters_t *parameters ,
                               opj_image_t *image , opj_event_mgr_t *p_manager ) ;
#line 605
char *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) ;
#line 616
OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) ;
#line 630
OPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream , opj_j2k_t *p_j2k , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) ;
#line 641
void opj_j2k_destroy(opj_j2k_t *p_j2k ) ;
#line 648
void j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind ) ;
#line 659
OPJ_BOOL opj_j2k_decode_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) ;
#line 680
OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t *p_j2k , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 706
OPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) ;
#line 717
opj_j2k_t *opj_j2k_create_decompress(void) ;
#line 728
void j2k_dump(opj_j2k_t *p_j2k , OPJ_INT32 flag , FILE *out_stream ) ;
#line 739
void j2k_dump_image_header(opj_image_t *img_header , OPJ_BOOL dev_dump_flag , FILE *out_stream ) ;
#line 748
void j2k_dump_image_comp_header(opj_image_comp_t *comp_header , OPJ_BOOL dev_dump_flag ,
                                FILE *out_stream ) ;
#line 757
opj_codestream_info_v2_t *j2k_get_cstr_info(opj_j2k_t *p_j2k ) ;
#line 766
opj_codestream_index_t *j2k_get_cstr_index(opj_j2k_t *p_j2k ) ;
#line 776
OPJ_BOOL opj_j2k_decode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) ;
#line 782
OPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) ;
#line 788
OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) ;
#line 802
OPJ_BOOL opj_j2k_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) ;
#line 812
OPJ_BOOL opj_j2k_encode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 826
OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_image_t *p_image , opj_event_mgr_t *p_manager ) ;
#line 835
OPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) ;
#line 839
OPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t *p_tcp , opj_image_t *p_image ) ;
#line 247 "/root/patron/new_21/src/lib/openjp2/jp2.h"
OPJ_BOOL opj_jp2_write_jp2h(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 257
void opj_jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) ;
#line 268
OPJ_BOOL opj_jp2_decode(opj_jp2_t *jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) ;
#line 283
OPJ_BOOL opj_jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ,
                               opj_event_mgr_t *p_manager ) ;
#line 295
OPJ_BOOL opj_jp2_encode(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 310
OPJ_BOOL opj_jp2_start_compress(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_image_t *p_image ,
                                opj_event_mgr_t *p_manager ) ;
#line 320
OPJ_BOOL opj_jp2_end_compress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 330
OPJ_BOOL opj_jp2_end_decompress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 344
OPJ_BOOL opj_jp2_read_header(opj_stream_private_t *p_stream , opj_jp2_t *jp2 , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) ;
#line 363
OPJ_BOOL opj_jp2_read_tile_header(opj_jp2_t *p_jp2 , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 385
OPJ_BOOL opj_jp2_write_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) ;
#line 403
OPJ_BOOL opj_jp2_decode_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) ;
#line 415
opj_jp2_t *opj_jp2_create(OPJ_BOOL p_is_decoder ) ;
#line 421
void opj_jp2_destroy(opj_jp2_t *jp2 ) ;
#line 437
OPJ_BOOL opj_jp2_set_decode_area(opj_jp2_t *p_jp2 , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) ;
#line 446
OPJ_BOOL opj_jp2_get_tile(opj_jp2_t *p_jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) ;
#line 456
OPJ_BOOL opj_jp2_set_decoded_resolution_factor(opj_jp2_t *p_jp2 , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) ;
#line 470
void jp2_dump(opj_jp2_t *p_jp2 , OPJ_INT32 flag , FILE *out_stream ) ;
#line 479
opj_codestream_info_v2_t *jp2_get_cstr_info(opj_jp2_t *p_jp2 ) ;
#line 488
opj_codestream_index_t *jp2_get_cstr_index(opj_jp2_t *p_jp2 ) ;
#line 92 "/root/patron/new_21/src/lib/openjp2/mqc.h"
opj_mqc_t *opj_mqc_create(void) ;
#line 97
void opj_mqc_destroy(opj_mqc_t *mqc ) ;
#line 103
OPJ_UINT32 opj_mqc_numbytes(opj_mqc_t *mqc ) ;
#line 109
void opj_mqc_resetstates(opj_mqc_t *mqc ) ;
#line 117
void opj_mqc_setstate(opj_mqc_t *mqc , OPJ_UINT32 ctxno , OPJ_UINT32 msb , OPJ_INT32 prob ) ;
#line 123
void opj_mqc_init_enc(opj_mqc_t *mqc , OPJ_BYTE *bp ) ;
#line 135
void opj_mqc_encode(opj_mqc_t *mqc , OPJ_UINT32 d ) ;
#line 140
void opj_mqc_flush(opj_mqc_t *mqc ) ;
#line 147
void opj_mqc_bypass_init_enc(opj_mqc_t *mqc ) ;
#line 155
void opj_mqc_bypass_enc(opj_mqc_t *mqc , OPJ_UINT32 d ) ;
#line 162
OPJ_UINT32 opj_mqc_bypass_flush_enc(opj_mqc_t *mqc ) ;
#line 167
void opj_mqc_reset_enc(opj_mqc_t *mqc ) ;
#line 173
OPJ_UINT32 opj_mqc_restart_enc(opj_mqc_t *mqc ) ;
#line 178
void opj_mqc_restart_init_enc(opj_mqc_t *mqc ) ;
#line 183
void opj_mqc_erterm_enc(opj_mqc_t *mqc ) ;
#line 188
void opj_mqc_segmark_enc(opj_mqc_t *mqc ) ;
#line 195
OPJ_BOOL opj_mqc_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 201
OPJ_INT32 opj_mqc_decode(opj_mqc_t *mqc ) ;
#line 76 "/root/patron/new_21/src/lib/openjp2/raw.h"
opj_raw_t *opj_raw_create(void) ;
#line 81
void opj_raw_destroy(opj_raw_t *raw ) ;
#line 87
OPJ_UINT32 opj_raw_numbytes(opj_raw_t *raw ) ;
#line 94
void opj_raw_init_dec(opj_raw_t *raw , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 100
OPJ_UINT32 opj_raw_decode(opj_raw_t *raw ) ;
#line 123 "/root/patron/new_21/src/lib/openjp2/pi.h"
opj_pi_iterator_t *opj_pi_initialise_encode(opj_image_t *p_image , opj_cp_t *p_cp ,
                                            OPJ_UINT32 p_tile_no , J2K_T2_MODE p_t2_mode ) ;
#line 135
void opj_pi_update_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) ;
#line 149
void opj_pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , OPJ_UINT32 tileno ,
                          OPJ_UINT32 pino , OPJ_UINT32 tpnum , OPJ_INT32 tppos , J2K_T2_MODE t2_mode ) ;
#line 165
opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) ;
#line 174
void opj_pi_destroy(opj_pi_iterator_t *p_pi , OPJ_UINT32 p_nb_elements ) ;
#line 182
OPJ_BOOL opj_pi_next(opj_pi_iterator_t *pi ) ;
#line 86 "/root/patron/new_21/src/lib/openjp2/tgt.h"
opj_tgt_tree_t *opj_tgt_create(OPJ_UINT32 numleafsh , OPJ_UINT32 numleafsv ) ;
#line 96
opj_tgt_tree_t *opj_tgt_init(opj_tgt_tree_t *p_tree , OPJ_UINT32 p_num_leafs_h , OPJ_UINT32 p_num_leafs_v ) ;
#line 103
void opj_tgt_destroy(opj_tgt_tree_t *p_tree ) ;
#line 108
void opj_tgt_reset(opj_tgt_tree_t *p_tree ) ;
#line 115
void opj_tgt_setvalue(opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 value ) ;
#line 125
void opj_tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 threshold ) ;
#line 137
OPJ_UINT32 opj_tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno ,
                          OPJ_INT32 threshold ) ;
#line 235 "/root/patron/new_21/src/lib/openjp2/tcd.h"
opj_tcd_t *opj_tcd_create(OPJ_BOOL p_is_decoder ) ;
#line 241
void opj_tcd_destroy(opj_tcd_t *tcd ) ;
#line 251
OPJ_BOOL opj_tcd_init(opj_tcd_t *p_tcd , opj_image_t *p_image , opj_cp_t *p_cp ) ;
#line 264
OPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ) ;
#line 266
void opj_tcd_makelayer_fixed(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_UINT32 final ) ;
#line 268
void opj_tcd_rateallocate_fixed(opj_tcd_t *tcd ) ;
#line 270
void opj_tcd_makelayer(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_FLOAT64 thresh , OPJ_UINT32 final ) ;
#line 275
OPJ_BOOL opj_tcd_rateallocate(opj_tcd_t *tcd , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 len , opj_codestream_info_t *cstr_info ) ;
#line 284
OPJ_UINT32 opj_tcd_get_decoded_tile_size(opj_tcd_t *p_tcd ) ;
#line 296
OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , OPJ_BYTE *p_dest ,
                             OPJ_UINT32 *p_data_written , OPJ_UINT32 p_max_length ,
                             opj_codestream_info_t *p_cstr_info ) ;
#line 312
OPJ_BOOL opj_tcd_decode_tile(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_UINT32 p_max_length ,
                             OPJ_UINT32 p_tile_no , opj_codestream_index_t *p_cstr_index ) ;
#line 322
OPJ_BOOL opj_tcd_update_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest , OPJ_UINT32 p_dest_length ) ;
#line 329
OPJ_UINT32 opj_tcd_get_encoded_tile_size(opj_tcd_t *p_tcd ) ;
#line 339
OPJ_BOOL opj_tcd_init_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ) ;
#line 345
OPJ_BOOL opj_tcd_copy_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_UINT32 p_src_length ) ;
#line 128 "/root/patron/new_21/src/lib/openjp2/t1.h"
OPJ_BOOL opj_t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                             OPJ_FLOAT64 *mct_norms ) ;
#line 139
OPJ_BOOL opj_t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) ;
#line 150
opj_t1_t *opj_t1_create(void) ;
#line 157
void opj_t1_destroy(opj_t1_t *p_t1 ) ;
#line 61 "/root/patron/new_21/src/lib/openjp2/dwt.h"
OPJ_BOOL opj_dwt_encode(opj_tcd_tilecomp_t *tilec ) ;
#line 69
OPJ_BOOL opj_dwt_decode(opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) ;
#line 76
OPJ_UINT32 opj_dwt_getgain(OPJ_UINT32 orient ) ;
#line 83
OPJ_FLOAT64 opj_dwt_getnorm(OPJ_UINT32 level , OPJ_UINT32 orient ) ;
#line 89
OPJ_BOOL opj_dwt_encode_real(opj_tcd_tilecomp_t *tilec ) ;
#line 96
OPJ_BOOL opj_dwt_decode_real(opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) ;
#line 103
OPJ_UINT32 opj_dwt_getgain_real(OPJ_UINT32 orient ) ;
#line 110
OPJ_FLOAT64 opj_dwt_getnorm_real(OPJ_UINT32 level , OPJ_UINT32 orient ) ;
#line 116
void opj_dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , OPJ_UINT32 prec ) ;
#line 80 "/root/patron/new_21/src/lib/openjp2/t2.h"
OPJ_BOOL opj_t2_encode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_UINT32 p_maxlayers , OPJ_BYTE *p_dest , OPJ_UINT32 *p_data_written ,
                               OPJ_UINT32 p_max_len , opj_codestream_info_t *cstr_info ,
                               OPJ_UINT32 p_tp_num , OPJ_INT32 p_tp_pos , OPJ_UINT32 p_pino ,
                               J2K_T2_MODE p_t2_mode ) ;
#line 105
OPJ_BOOL opj_t2_decode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_len ,
                               opj_codestream_index_t *p_cstr_index ) ;
#line 120
opj_t2_t *opj_t2_create(opj_image_t *p_image , opj_cp_t *p_cp ) ;
#line 126
void opj_t2_destroy(opj_t2_t *t2 ) ;
#line 63 "/root/patron/new_21/src/lib/openjp2/mct.h"
void opj_mct_encode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_UINT32 n ) ;
#line 71
void opj_mct_decode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_UINT32 n ) ;
#line 77
OPJ_FLOAT64 opj_mct_getnorm(OPJ_UINT32 compno ) ;
#line 86
void opj_mct_encode_real(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_UINT32 n ) ;
#line 94
void opj_mct_decode_real(OPJ_FLOAT32 *c0 , OPJ_FLOAT32 *c1 , OPJ_FLOAT32 *c2 , OPJ_UINT32 n ) ;
#line 100
OPJ_FLOAT64 opj_mct_getnorm_real(OPJ_UINT32 compno ) ;
#line 111
OPJ_BOOL opj_mct_encode_custom(OPJ_BYTE *p_coding_data , OPJ_UINT32 n , OPJ_BYTE **p_data ,
                               OPJ_UINT32 p_nb_comp , OPJ_UINT32 is_signed ) ;
#line 126
OPJ_BOOL opj_mct_decode_custom(OPJ_BYTE *pDecodingData , OPJ_UINT32 n , OPJ_BYTE **pData ,
                               OPJ_UINT32 pNbComp , OPJ_UINT32 isSigned ) ;
#line 139
void opj_calculate_norms(OPJ_FLOAT64 *pNorms , OPJ_UINT32 p_nb_comps , OPJ_FLOAT32 *pMatrix ) ;
#line 145
OPJ_FLOAT64 *opj_mct_get_mct_norms(void) ;
#line 149
OPJ_FLOAT64 *opj_mct_get_mct_norms_real(void) ;
#line 56 "/root/patron/new_21/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_min(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 57
  if (a < b) {
#line 57
    tmp = a;
  } else {
#line 57
    tmp = b;
  }
#line 57
  return (tmp);
}
}
#line 64 "/root/patron/new_21/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_min(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 65
  if (a < b) {
#line 65
    tmp = a;
  } else {
#line 65
    tmp = b;
  }
#line 65
  return (tmp);
}
}
#line 72 "/root/patron/new_21/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_max(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 73
  if (a > b) {
#line 73
    tmp = a;
  } else {
#line 73
    tmp = b;
  }
#line 73
  return (tmp);
}
}
#line 80 "/root/patron/new_21/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_max(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 81
  if (a > b) {
#line 81
    tmp = a;
  } else {
#line 81
    tmp = b;
  }
#line 81
  return (tmp);
}
}
#line 93 "/root/patron/new_21/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_clamp(OPJ_INT32 a , OPJ_INT32 min , OPJ_INT32 max ) 
{ 


  {
#line 94
  if (a < min) {
#line 95
    return (min);
  }
#line 96
  if (a > max) {
#line 97
    return (max);
  }
#line 98
  return (a);
}
}
#line 103 "/root/patron/new_21/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_abs(OPJ_INT32 a ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 104
  if (a < 0) {
#line 104
    tmp = - a;
  } else {
#line 104
    tmp = a;
  }
#line 104
  return (tmp);
}
}
#line 110 "/root/patron/new_21/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_ceildiv(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  int tmp ;

  {
#line 112
  return (((a + b) - 1) / b);
}
}
#line 119 "/root/patron/new_21/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_ceildiv(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 


  {
#line 120
  return (((a + b) - 1U) / b);
}
}
#line 127 "/root/patron/new_21/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_ceildivpow2(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 128
  return ((OPJ_INT32 )((((long )a + (OPJ_INT64 )(1 << b)) - 1L) >> b));
}
}
#line 134 "/root/patron/new_21/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_floordivpow2(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 135
  return (a >> b);
}
}
#line 141 "/root/patron/new_21/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_floorlog2(OPJ_INT32 a ) 
{ 
  OPJ_INT32 l ;
  OPJ_INT32 __cil_tmp3 ;

  {
#line 143
  l = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (a > 1)) {
#line 143
      goto while_break;
    }
#line 144
    a >>= 1;
#line 143
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return (l);
}
}
#line 152 "/root/patron/new_21/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_floorlog2(OPJ_UINT32 a ) 
{ 
  OPJ_UINT32 l ;

  {
#line 154
  l = (OPJ_UINT32 )0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (a > 1U)) {
#line 154
      goto while_break;
    }
#line 156
    a >>= 1;
#line 154
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (l);
}
}
#line 167 "/root/patron/new_21/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_fix_mul(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT64 temp ;

  {
#line 168
  temp = (OPJ_INT64 )a * (OPJ_INT64 )b;
#line 169
  temp += temp & 4096L;
#line 170
  return ((OPJ_INT32 )(temp >> 13));
}
}
#line 48 "/root/patron/new_21/src/lib/openjp2/tgt.c"
opj_tgt_tree_t *opj_tgt_create(OPJ_UINT32 numleafsh , OPJ_UINT32 numleafsv ) 
{ 
  OPJ_INT32 nplh[32] ;
  OPJ_INT32 nplv[32] ;
  opj_tgt_node_t *node ;
  opj_tgt_node_t *l_parent_node ;
  opj_tgt_node_t *l_parent_node0 ;
  opj_tgt_tree_t *tree ;
  OPJ_UINT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 k ;
  OPJ_UINT32 numlvls ;
  OPJ_UINT32 n ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  {
#line 51
  node = (opj_tgt_node_t *)0;
#line 52
  l_parent_node = (opj_tgt_node_t *)0;
#line 53
  l_parent_node0 = (opj_tgt_node_t *)0;
#line 54
  tree = (opj_tgt_tree_t *)0;
#line 60
  __cil_tmp14 = calloc((unsigned long )1, sizeof(opj_tgt_tree_t ));
#line 60
  tree = (opj_tgt_tree_t *)__cil_tmp14;
  }
#line 61
  if (! tree) {
    {
#line 62
    fprintf(stderr, "ERROR in tgt_create while allocating tree\n");
    }
#line 63
    return ((opj_tgt_tree_t *)0);
  }
#line 66
  tree->numleafsh = numleafsh;
#line 67
  tree->numleafsv = numleafsv;
#line 69
  numlvls = (OPJ_UINT32 )0;
#line 70
  nplh[0] = (OPJ_INT32 )numleafsh;
#line 71
  nplv[0] = (OPJ_INT32 )numleafsv;
#line 72
  tree->numnodes = (OPJ_UINT32 )0;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    n = (OPJ_UINT32 )(nplh[numlvls] * nplv[numlvls]);
#line 75
    nplh[numlvls + 1U] = (nplh[numlvls] + 1) / 2;
#line 76
    nplv[numlvls + 1U] = (nplv[numlvls] + 1) / 2;
#line 77
    tree->numnodes += n;
#line 78
    numlvls ++;
#line 73
    if (! (n > 1U)) {
#line 73
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  if (tree->numnodes == 0U) {
    {
#line 83
    free(tree);
#line 84
    fprintf(stderr, "WARNING in tgt_create tree->numnodes == 0, no tree created.\n");
    }
#line 85
    return ((opj_tgt_tree_t *)0);
  }
  {
#line 88
  __cil_tmp15 = calloc((unsigned long )tree->numnodes, sizeof(opj_tgt_node_t ));
#line 88
  tree->nodes = (opj_tgt_node_t *)__cil_tmp15;
  }
#line 89
  if (! tree->nodes) {
    {
#line 90
    fprintf(stderr, "ERROR in tgt_create while allocating node of the tree\n");
#line 91
    free(tree);
    }
#line 92
    return ((opj_tgt_tree_t *)0);
  }
#line 94
  tree->nodes_size = tree->numnodes * (OPJ_UINT32 )sizeof(opj_tgt_node_t );
#line 96
  node = tree->nodes;
#line 97
  l_parent_node = tree->nodes + tree->numleafsh * tree->numleafsv;
#line 98
  l_parent_node0 = l_parent_node;
#line 100
  i = (OPJ_UINT32 )0;
  {
#line 100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 100
    if (! (i < numlvls - 1U)) {
#line 100
      goto while_break___0;
    }
#line 101
    j = 0;
    {
#line 101
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 101
      if (! (j < nplv[i])) {
#line 101
        goto while_break___1;
      }
#line 102
      k = nplh[i];
      {
#line 103
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 103
        k --;
#line 103
        if (! (k >= 0)) {
#line 103
          goto while_break___2;
        }
#line 104
        node->parent = l_parent_node;
#line 105
        node ++;
#line 106
        k --;
#line 106
        if (k >= 0) {
#line 107
          node->parent = l_parent_node;
#line 108
          node ++;
        }
#line 110
        l_parent_node ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 112
      if (j & 1) {
#line 113
        l_parent_node0 = l_parent_node;
      } else
#line 112
      if (j == nplv[i] - 1) {
#line 113
        l_parent_node0 = l_parent_node;
      } else {
#line 115
        l_parent_node = l_parent_node0;
#line 116
        l_parent_node0 += nplh[i];
      }
#line 101
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 100
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 120
  node->parent = (struct opj_tgt_node *)0;
#line 121
  opj_tgt_reset(tree);
  }
#line 122
  return (tree);
}
}
#line 133 "/root/patron/new_21/src/lib/openjp2/tgt.c"
opj_tgt_tree_t *opj_tgt_init(opj_tgt_tree_t *p_tree , OPJ_UINT32 p_num_leafs_h , OPJ_UINT32 p_num_leafs_v ) 
{ 
  OPJ_INT32 l_nplh[32] ;
  OPJ_INT32 l_nplv[32] ;
  opj_tgt_node_t *l_node ;
  opj_tgt_node_t *l_parent_node ;
  opj_tgt_node_t *l_parent_node0 ;
  OPJ_UINT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 k ;
  OPJ_UINT32 l_num_levels ;
  OPJ_UINT32 n ;
  OPJ_UINT32 l_node_size ;
  opj_tgt_node_t *new_nodes ;
  void *__cil_tmp16 ;

  {
#line 137
  l_node = (opj_tgt_node_t *)0;
#line 138
  l_parent_node = (opj_tgt_node_t *)0;
#line 139
  l_parent_node0 = (opj_tgt_node_t *)0;
#line 146
  if (! p_tree) {
#line 147
    return ((opj_tgt_tree_t *)0);
  }
#line 150
  if (p_tree->numleafsh != p_num_leafs_h) {
    _L: /* CIL Label */ 
#line 151
    p_tree->numleafsh = p_num_leafs_h;
#line 152
    p_tree->numleafsv = p_num_leafs_v;
#line 154
    l_num_levels = (OPJ_UINT32 )0;
#line 155
    l_nplh[0] = (OPJ_INT32 )p_num_leafs_h;
#line 156
    l_nplv[0] = (OPJ_INT32 )p_num_leafs_v;
#line 157
    p_tree->numnodes = (OPJ_UINT32 )0;
    {
#line 158
    while (1) {
      while_continue: /* CIL Label */ ;
#line 160
      n = (OPJ_UINT32 )(l_nplh[l_num_levels] * l_nplv[l_num_levels]);
#line 161
      l_nplh[l_num_levels + 1U] = (l_nplh[l_num_levels] + 1) / 2;
#line 162
      l_nplv[l_num_levels + 1U] = (l_nplv[l_num_levels] + 1) / 2;
#line 163
      p_tree->numnodes += n;
#line 164
      l_num_levels ++;
#line 158
      if (! (n > 1U)) {
#line 158
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 169
    if (p_tree->numnodes == 0U) {
      {
#line 170
      opj_tgt_destroy(p_tree);
      }
#line 171
      return ((opj_tgt_tree_t *)0);
    }
#line 173
    l_node_size = p_tree->numnodes * (OPJ_UINT32 )sizeof(opj_tgt_node_t );
#line 175
    if (l_node_size > p_tree->nodes_size) {
      {
#line 176
      __cil_tmp16 = realloc(p_tree->nodes, (unsigned long )l_node_size);
#line 176
      new_nodes = (opj_tgt_node_t *)__cil_tmp16;
      }
#line 177
      if (! new_nodes) {
        {
#line 178
        fprintf(stderr, "ERROR Not enough memory to reinitialize the tag tree\n");
#line 179
        opj_tgt_destroy(p_tree);
        }
#line 180
        return ((opj_tgt_tree_t *)0);
      }
      {
#line 182
      p_tree->nodes = new_nodes;
#line 183
      memset((char *)p_tree->nodes + p_tree->nodes_size, 0, (unsigned long )(l_node_size - p_tree->nodes_size));
#line 184
      p_tree->nodes_size = l_node_size;
      }
    }
#line 186
    l_node = p_tree->nodes;
#line 187
    l_parent_node = p_tree->nodes + p_tree->numleafsh * p_tree->numleafsv;
#line 188
    l_parent_node0 = l_parent_node;
#line 190
    i = (OPJ_UINT32 )0;
    {
#line 190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 190
      if (! (i < l_num_levels - 1U)) {
#line 190
        goto while_break___0;
      }
#line 191
      j = 0;
      {
#line 191
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 191
        if (! (j < l_nplv[i])) {
#line 191
          goto while_break___1;
        }
#line 192
        k = l_nplh[i];
        {
#line 193
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 193
          k --;
#line 193
          if (! (k >= 0)) {
#line 193
            goto while_break___2;
          }
#line 194
          l_node->parent = l_parent_node;
#line 195
          l_node ++;
#line 196
          k --;
#line 196
          if (k >= 0) {
#line 197
            l_node->parent = l_parent_node;
#line 198
            l_node ++;
          }
#line 200
          l_parent_node ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 202
        if (j & 1) {
#line 204
          l_parent_node0 = l_parent_node;
        } else
#line 202
        if (j == l_nplv[i] - 1) {
#line 204
          l_parent_node0 = l_parent_node;
        } else {
#line 208
          l_parent_node = l_parent_node0;
#line 209
          l_parent_node0 += l_nplh[i];
        }
#line 191
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 190
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 213
    l_node->parent = (struct opj_tgt_node *)0;
  } else
#line 150
  if (p_tree->numleafsv != p_num_leafs_v) {
#line 150
    goto _L;
  }
  {
#line 215
  opj_tgt_reset(p_tree);
  }
#line 217
  return (p_tree);
}
}
#line 220 "/root/patron/new_21/src/lib/openjp2/tgt.c"
void opj_tgt_destroy(opj_tgt_tree_t *p_tree ) 
{ 


  {
#line 222
  if (! p_tree) {
#line 223
    return;
  }
#line 226
  if (p_tree->nodes) {
    {
#line 227
    free(p_tree->nodes);
#line 228
    p_tree->nodes = (opj_tgt_node_t *)0;
    }
  }
  {
#line 230
  free(p_tree);
  }
  return;
}
}
#line 233 "/root/patron/new_21/src/lib/openjp2/tgt.c"
void opj_tgt_reset(opj_tgt_tree_t *p_tree ) 
{ 
  OPJ_UINT32 i ;
  opj_tgt_node_t *l_current_node ;

  {
#line 235
  l_current_node = (opj_tgt_node_t *)0;
#line 237
  if (! p_tree) {
#line 238
    return;
  }
#line 241
  l_current_node = p_tree->nodes;
#line 242
  i = (OPJ_UINT32 )0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < p_tree->numnodes)) {
#line 242
      goto while_break;
    }
#line 244
    l_current_node->value = 999;
#line 245
    l_current_node->low = 0;
#line 246
    l_current_node->known = (OPJ_UINT32 )0;
#line 247
    l_current_node ++;
#line 242
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 251 "/root/patron/new_21/src/lib/openjp2/tgt.c"
void opj_tgt_setvalue(opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 value ) 
{ 
  opj_tgt_node_t *node ;

  {
#line 253
  node = tree->nodes + leafno;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! (node && node->value > value)) {
#line 254
      goto while_break;
    }
#line 255
    node->value = value;
#line 256
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 260 "/root/patron/new_21/src/lib/openjp2/tgt.c"
void opj_tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  OPJ_INT32 low ;
  opj_tgt_node_t **__cil_tmp9 ;

  {
#line 266
  stkptr = (opj_tgt_node_t **)stk;
#line 267
  node = tree->nodes + leafno;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! node->parent) {
#line 268
      goto while_break;
    }
#line 269
    __cil_tmp9 = stkptr;
#line 269
    stkptr ++;
#line 269
    *__cil_tmp9 = node;
#line 270
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  low = 0;
  {
#line 274
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 274
    if (! 1) {
#line 274
      goto while_break___0;
    }
#line 275
    if (low > node->low) {
#line 276
      node->low = low;
    } else {
#line 278
      low = node->low;
    }
    {
#line 281
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 281
      if (! (low < threshold)) {
#line 281
        goto while_break___1;
      }
#line 282
      if (low >= node->value) {
#line 283
        if (! node->known) {
          {
#line 284
          opj_bio_write(bio, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
#line 285
          node->known = (OPJ_UINT32 )1;
          }
        }
#line 287
        goto while_break___1;
      }
      {
#line 289
      opj_bio_write(bio, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 290
      low ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 293
    node->low = low;
#line 294
    if (stkptr == (opj_tgt_node_t **)stk) {
#line 295
      goto while_break___0;
    }
#line 296
    stkptr --;
#line 296
    node = *stkptr;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 300 "/root/patron/new_21/src/lib/openjp2/tgt.c"
OPJ_UINT32 opj_tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno ,
                          OPJ_INT32 threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  OPJ_INT32 low ;
  opj_tgt_node_t **__cil_tmp9 ;
  OPJ_UINT32 __cil_tmp10 ;
  int tmp ;

  {
#line 306
  stkptr = (opj_tgt_node_t **)stk;
#line 307
  node = tree->nodes + leafno;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! node->parent) {
#line 308
      goto while_break;
    }
#line 309
    __cil_tmp9 = stkptr;
#line 309
    stkptr ++;
#line 309
    *__cil_tmp9 = node;
#line 310
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  low = 0;
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if (! 1) {
#line 314
      goto while_break___0;
    }
#line 315
    if (low > node->low) {
#line 316
      node->low = low;
    } else {
#line 318
      low = node->low;
    }
    {
#line 320
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 320
      if (! (low < threshold && low < node->value)) {
#line 320
        goto while_break___1;
      }
      {
#line 321
      __cil_tmp10 = opj_bio_read(bio, (OPJ_UINT32 )1);
      }
#line 321
      if (__cil_tmp10) {
#line 322
        node->value = low;
      } else {
#line 324
        low ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 327
    node->low = low;
#line 328
    if (stkptr == (opj_tgt_node_t **)stk) {
#line 329
      goto while_break___0;
    }
#line 331
    stkptr --;
#line 331
    node = *stkptr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 334
  if (node->value < threshold) {
#line 334
    tmp = 1;
  } else {
#line 334
    tmp = 0;
  }
#line 334
  return ((OPJ_UINT32 )tmp);
}
}
#line 109 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *p_code_block ) ;
#line 114
void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t *p_precinct ) ;
#line 119
OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *p_code_block ) ;
#line 124
void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t *p_precinct ) ;
#line 131
void opj_tcd_free_tile(opj_tcd_t *p_tcd ) ;
#line 134
OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd , OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                           OPJ_UINT32 p_max_src_size , opj_codestream_index_t *p_cstr_index ) ;
#line 140
OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd ) ;
#line 142
OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd ) ;
#line 144
OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd ) ;
#line 146
OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd ) ;
#line 149
OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd ) ;
#line 151
OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd ) ;
#line 153
OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd ) ;
#line 155
OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd ) ;
#line 157
OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 *p_data_written ,
                           OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ) ;
#line 163
OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 p_max_dest_size ,
                                      opj_codestream_info_t *p_cstr_info ) ;
#line 173 "/root/patron/new_21/src/lib/openjp2/tcd.c"
opj_tcd_t *opj_tcd_create(OPJ_BOOL p_is_decoder ) 
{ 
  opj_tcd_t *l_tcd ;
  void *__cil_tmp3 ;
  int tmp ;
  void *__cil_tmp5 ;

  {
  {
#line 175
  l_tcd = (opj_tcd_t *)0;
#line 178
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_tcd_t ));
#line 178
  l_tcd = (opj_tcd_t *)__cil_tmp3;
  }
#line 179
  if (! l_tcd) {
#line 180
    return ((opj_tcd_t *)0);
  }
#line 183
  if (p_is_decoder) {
#line 183
    tmp = 1;
  } else {
#line 183
    tmp = 0;
  }
  {
#line 183
  l_tcd->m_is_decoder = (OPJ_UINT32 )tmp;
#line 185
  __cil_tmp5 = calloc((unsigned long )1, sizeof(opj_tcd_image_t ));
#line 185
  l_tcd->tcd_image = (opj_tcd_image_t *)__cil_tmp5;
  }
#line 186
  if (! l_tcd->tcd_image) {
    {
#line 187
    free(l_tcd);
    }
#line 188
    return ((opj_tcd_t *)0);
  }
#line 191
  return (l_tcd);
}
}
#line 197 "/root/patron/new_21/src/lib/openjp2/tcd.c"
void opj_tcd_rateallocate_fixed(opj_tcd_t *tcd ) 
{ 
  OPJ_UINT32 layno ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 200
  layno = (OPJ_UINT32 )0;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (layno < (tcd->tcp)->numlayers)) {
#line 200
      goto while_break;
    }
    {
#line 201
    opj_tcd_makelayer_fixed(tcd, layno, (OPJ_UINT32 )1);
    }
#line 200
    layno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 206 "/root/patron/new_21/src/lib/openjp2/tcd.c"
void opj_tcd_makelayer(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_FLOAT64 thresh , OPJ_UINT32 final ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 passno ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  OPJ_UINT32 n ;
  OPJ_UINT32 dr ;
  OPJ_FLOAT64 dd ;
  opj_tcd_pass_t *pass ;
  OPJ_UINT32 __cil_tmp22 ;
  OPJ_UINT32 __cil_tmp23 ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_UINT32 __cil_tmp27 ;

  {
#line 214
  tcd_tile = (tcd->tcd_image)->tiles;
#line 216
  tcd_tile->distolayer[layno] = (OPJ_FLOAT64 )0;
#line 218
  compno = (OPJ_UINT32 )0;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (compno < tcd_tile->numcomps)) {
#line 218
      goto while_break;
    }
#line 219
    tilec = tcd_tile->comps + compno;
#line 221
    resno = (OPJ_UINT32 )0;
    {
#line 221
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 221
      if (! (resno < tilec->numresolutions)) {
#line 221
        goto while_break___0;
      }
#line 222
      res = tilec->resolutions + resno;
#line 224
      bandno = (OPJ_UINT32 )0;
      {
#line 224
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 224
        if (! (bandno < res->numbands)) {
#line 224
          goto while_break___1;
        }
#line 225
        band = & res->bands[bandno];
#line 227
        precno = (OPJ_UINT32 )0;
        {
#line 227
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 227
          if (! (precno < res->pw * res->ph)) {
#line 227
            goto while_break___2;
          }
#line 228
          prc = band->precincts + precno;
#line 230
          cblkno = (OPJ_UINT32 )0;
          {
#line 230
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 230
            if (! (cblkno < prc->cw * prc->ch)) {
#line 230
              goto while_break___3;
            }
#line 231
            cblk = prc->cblks.enc + cblkno;
#line 232
            layer = cblk->layers + layno;
#line 235
            if (layno == 0U) {
#line 236
              cblk->numpassesinlayers = (OPJ_UINT32 )0;
            }
#line 239
            n = cblk->numpassesinlayers;
#line 241
            passno = cblk->numpassesinlayers;
            {
#line 241
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 241
              if (! (passno < cblk->totalpasses)) {
#line 241
                goto while_break___4;
              }
#line 244
              pass = cblk->passes + passno;
#line 246
              if (n == 0U) {
#line 247
                dr = pass->rate;
#line 248
                dd = pass->distortiondec;
              } else {
#line 250
                dr = pass->rate - (cblk->passes + (n - 1U))->rate;
#line 251
                dd = pass->distortiondec - (cblk->passes + (n - 1U))->distortiondec;
              }
#line 254
              if (! dr) {
#line 255
                if (dd != (double )0) {
#line 256
                  n = passno + 1U;
                }
#line 257
                goto while_continue___4;
              }
#line 259
              if (dd / (double )dr >= thresh) {
#line 260
                n = passno + 1U;
              }
#line 241
              passno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 263
            layer->numpasses = n - cblk->numpassesinlayers;
#line 265
            if (! layer->numpasses) {
#line 266
              layer->disto = (OPJ_FLOAT64 )0;
#line 267
              goto while_continue___3;
            }
#line 270
            if (cblk->numpassesinlayers == 0U) {
#line 271
              layer->len = (cblk->passes + (n - 1U))->rate;
#line 272
              layer->data = cblk->data;
#line 273
              layer->disto = (cblk->passes + (n - 1U))->distortiondec;
            } else {
#line 275
              layer->len = (cblk->passes + (n - 1U))->rate - (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 276
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 277
              layer->disto = (cblk->passes + (n - 1U))->distortiondec - (cblk->passes + (cblk->numpassesinlayers - 1U))->distortiondec;
            }
#line 280
            tcd_tile->distolayer[layno] += layer->disto;
#line 282
            if (final) {
#line 283
              cblk->numpassesinlayers = n;
            }
#line 230
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 227
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 224
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 221
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 218
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 291 "/root/patron/new_21/src/lib/openjp2/tcd.c"
void opj_tcd_makelayer_fixed(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_UINT32 final ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_INT32 value ;
  OPJ_INT32 matrice[10][10][3] ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  OPJ_UINT32 __cil_tmp18 ;
  OPJ_UINT32 __cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  OPJ_UINT32 n ;
  OPJ_INT32 imsb ;
  OPJ_UINT32 __cil_tmp28 ;
  OPJ_UINT32 __cil_tmp29 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  OPJ_UINT32 __cil_tmp32 ;

  {
#line 297
  cp = tcd->cp;
#line 298
  tcd_tile = (tcd->tcd_image)->tiles;
#line 299
  tcd_tcp = tcd->tcp;
#line 301
  compno = (OPJ_UINT32 )0;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! (compno < tcd_tile->numcomps)) {
#line 301
      goto while_break;
    }
#line 302
    tilec = tcd_tile->comps + compno;
#line 304
    i = (OPJ_UINT32 )0;
    {
#line 304
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 304
      if (! (i < tcd_tcp->numlayers)) {
#line 304
        goto while_break___0;
      }
#line 305
      j = (OPJ_UINT32 )0;
      {
#line 305
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 305
        if (! (j < tilec->numresolutions)) {
#line 305
          goto while_break___1;
        }
#line 306
        k = (OPJ_UINT32 )0;
        {
#line 306
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 306
          if (! (k < 3U)) {
#line 306
            goto while_break___2;
          }
#line 307
          matrice[i][j][k] = (OPJ_INT32 )((OPJ_FLOAT32 )*(cp->m_specific_param.m_enc.m_matrice + (((i * tilec->numresolutions) * 3U + j * 3U) + k)) * (OPJ_FLOAT32 )((double )((tcd->image)->comps + compno)->prec / 16.));
#line 306
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 305
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 304
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 314
    resno = (OPJ_UINT32 )0;
    {
#line 314
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 314
      if (! (resno < tilec->numresolutions)) {
#line 314
        goto while_break___3;
      }
#line 315
      res = tilec->resolutions + resno;
#line 317
      bandno = (OPJ_UINT32 )0;
      {
#line 317
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 317
        if (! (bandno < res->numbands)) {
#line 317
          goto while_break___4;
        }
#line 318
        band = & res->bands[bandno];
#line 320
        precno = (OPJ_UINT32 )0;
        {
#line 320
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 320
          if (! (precno < res->pw * res->ph)) {
#line 320
            goto while_break___5;
          }
#line 321
          prc = band->precincts + precno;
#line 323
          cblkno = (OPJ_UINT32 )0;
          {
#line 323
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 323
            if (! (cblkno < prc->cw * prc->ch)) {
#line 323
              goto while_break___6;
            }
#line 324
            cblk = prc->cblks.enc + cblkno;
#line 325
            layer = cblk->layers + layno;
#line 327
            imsb = (OPJ_INT32 )(((tcd->image)->comps + compno)->prec - cblk->numbps);
#line 330
            if (layno == 0U) {
#line 331
              value = matrice[layno][resno][bandno];
#line 332
              if (imsb >= value) {
#line 333
                value = 0;
              } else {
#line 335
                value -= imsb;
              }
            } else {
#line 338
              value = matrice[layno][resno][bandno] - matrice[layno - 1U][resno][bandno];
#line 339
              if (imsb >= matrice[layno - 1U][resno][bandno]) {
#line 340
                value -= imsb - matrice[layno - 1U][resno][bandno];
#line 341
                if (value < 0) {
#line 342
                  value = 0;
                }
              }
            }
#line 347
            if (layno == 0U) {
#line 348
              cblk->numpassesinlayers = (OPJ_UINT32 )0;
            }
#line 351
            n = cblk->numpassesinlayers;
#line 352
            if (cblk->numpassesinlayers == 0U) {
#line 353
              if (value != 0) {
#line 354
                n = (3U * (OPJ_UINT32 )value - 2U) + cblk->numpassesinlayers;
              } else {
#line 356
                n = cblk->numpassesinlayers;
              }
            } else {
#line 359
              n = 3U * (OPJ_UINT32 )value + cblk->numpassesinlayers;
            }
#line 362
            layer->numpasses = n - cblk->numpassesinlayers;
#line 364
            if (! layer->numpasses) {
#line 365
              goto while_continue___6;
            }
#line 367
            if (cblk->numpassesinlayers == 0U) {
#line 368
              layer->len = (cblk->passes + (n - 1U))->rate;
#line 369
              layer->data = cblk->data;
            } else {
#line 371
              layer->len = (cblk->passes + (n - 1U))->rate - (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 372
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
            }
#line 375
            if (final) {
#line 376
              cblk->numpassesinlayers = n;
            }
#line 323
            cblkno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 320
          precno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 317
        bandno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 314
      resno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 301
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 384 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_rateallocate(opj_tcd_t *tcd , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 len , opj_codestream_info_t *cstr_info ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 passno ;
  OPJ_FLOAT64 min ;
  OPJ_FLOAT64 max ;
  OPJ_FLOAT64 cumdisto[100] ;
  OPJ_FLOAT64 K ;
  OPJ_FLOAT64 maxSE ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  OPJ_INT32 dr ;
  OPJ_FLOAT64 dd ;
  OPJ_FLOAT64 rdslope ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;
  opj_tile_info_t *tile_info ;
  void *__cil_tmp37 ;
  OPJ_FLOAT64 lo ;
  OPJ_FLOAT64 hi ;
  OPJ_BOOL success ;
  OPJ_UINT32 maxlen ;
  double __cil_tmp42 ;
  OPJ_UINT32 __cil_tmp43 ;
  OPJ_UINT32 tmp ;
  OPJ_FLOAT64 goodthresh ;
  OPJ_FLOAT64 stable_thresh ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 distotarget ;
  double __cil_tmp49 ;
  opj_t2_t *t2 ;
  opj_t2_t *__cil_tmp51 ;
  OPJ_FLOAT64 thresh ;
  OPJ_FLOAT64 distoachieved ;
  OPJ_BOOL __cil_tmp54 ;
  OPJ_FLOAT64 tmp___0 ;
  OPJ_FLOAT64 tmp___1 ;
  OPJ_BOOL __cil_tmp57 ;
  OPJ_FLOAT64 tmp___2 ;
  OPJ_FLOAT64 tmp___3 ;
  OPJ_UINT32 __cil_tmp60 ;

  {
#line 394
  K = (OPJ_FLOAT64 )1;
#line 395
  maxSE = (OPJ_FLOAT64 )0;
#line 397
  cp = tcd->cp;
#line 398
  tcd_tile = (tcd->tcd_image)->tiles;
#line 399
  tcd_tcp = tcd->tcp;
#line 401
  min = (double )1.79769313487e+308L;
#line 402
  max = (OPJ_FLOAT64 )0;
#line 404
  tcd_tile->numpix = 0;
#line 406
  compno = (OPJ_UINT32 )0;
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (! (compno < tcd_tile->numcomps)) {
#line 406
      goto while_break;
    }
#line 407
    tilec = tcd_tile->comps + compno;
#line 408
    tilec->numpix = 0;
#line 410
    resno = (OPJ_UINT32 )0;
    {
#line 410
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 410
      if (! (resno < tilec->numresolutions)) {
#line 410
        goto while_break___0;
      }
#line 411
      res = tilec->resolutions + resno;
#line 413
      bandno = (OPJ_UINT32 )0;
      {
#line 413
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 413
        if (! (bandno < res->numbands)) {
#line 413
          goto while_break___1;
        }
#line 414
        band = & res->bands[bandno];
#line 416
        precno = (OPJ_UINT32 )0;
        {
#line 416
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 416
          if (! (precno < res->pw * res->ph)) {
#line 416
            goto while_break___2;
          }
#line 417
          prc = band->precincts + precno;
#line 419
          cblkno = (OPJ_UINT32 )0;
          {
#line 419
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 419
            if (! (cblkno < prc->cw * prc->ch)) {
#line 419
              goto while_break___3;
            }
#line 420
            cblk = prc->cblks.enc + cblkno;
#line 422
            passno = (OPJ_UINT32 )0;
            {
#line 422
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 422
              if (! (passno < cblk->totalpasses)) {
#line 422
                goto while_break___4;
              }
#line 423
              pass = cblk->passes + passno;
#line 427
              if (passno == 0U) {
#line 428
                dr = (OPJ_INT32 )pass->rate;
#line 429
                dd = pass->distortiondec;
              } else {
#line 431
                dr = (OPJ_INT32 )(pass->rate - (cblk->passes + (passno - 1U))->rate);
#line 432
                dd = pass->distortiondec - (cblk->passes + (passno - 1U))->distortiondec;
              }
#line 435
              if (dr == 0) {
#line 436
                goto while_continue___4;
              }
#line 439
              rdslope = dd / (double )dr;
#line 440
              if (rdslope < min) {
#line 441
                min = rdslope;
              }
#line 444
              if (rdslope > max) {
#line 445
                max = rdslope;
              }
#line 422
              passno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 450
            tcd_tile->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 451
            tilec->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 419
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 416
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 413
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 410
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 457
    maxSE += (((OPJ_FLOAT64 )(1 << ((tcd->image)->comps + compno)->prec) - 1.) * ((OPJ_FLOAT64 )(1 << ((tcd->image)->comps + compno)->prec) - 1.)) * (OPJ_FLOAT64 )tilec->numpix;
#line 406
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  if (cstr_info) {
    {
#line 464
    tile_info = cstr_info->tile + tcd->tcd_tileno;
#line 465
    tile_info->numpix = tcd_tile->numpix;
#line 466
    tile_info->distotile = tcd_tile->distotile;
#line 467
    __cil_tmp37 = malloc((unsigned long )tcd_tcp->numlayers * sizeof(OPJ_FLOAT64 ));
#line 467
    tile_info->thresh = (OPJ_FLOAT64 *)__cil_tmp37;
    }
#line 468
    if (! tile_info->thresh) {
#line 470
      return (0);
    }
  }
#line 474
  layno = (OPJ_UINT32 )0;
  {
#line 474
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 474
    if (! (layno < tcd_tcp->numlayers)) {
#line 474
      goto while_break___5;
    }
#line 475
    lo = min;
#line 476
    hi = max;
#line 477
    success = 0;
#line 478
    if (tcd_tcp->rates[layno]) {
      {
#line 478
      __cil_tmp42 = ceil((double )tcd_tcp->rates[layno]);
#line 478
      __cil_tmp43 = opj_uint_min((OPJ_UINT32 )__cil_tmp42, len);
#line 478
      tmp = __cil_tmp43;
      }
    } else {
#line 478
      tmp = len;
    }
    {
#line 478
    maxlen = tmp;
#line 479
    goodthresh = (OPJ_FLOAT64 )0;
#line 480
    stable_thresh = (OPJ_FLOAT64 )0;
#line 485
    __cil_tmp49 = pow((double )((OPJ_FLOAT32 )10), (double )(tcd_tcp->distoratio[layno] / (float )10));
#line 485
    distotarget = tcd_tile->distotile - (K * maxSE) / __cil_tmp49;
    }
#line 491
    if ((int )cp->m_specific_param.m_enc.m_disto_alloc == 1) {
#line 491
      if (tcd_tcp->rates[layno] > (float )0) {
        _L___0: /* CIL Label */ 
        {
#line 492
        __cil_tmp51 = opj_t2_create(tcd->image, cp);
#line 492
        t2 = __cil_tmp51;
#line 493
        thresh = (OPJ_FLOAT64 )0;
        }
#line 495
        if (t2 == (opj_t2_t *)0) {
#line 496
          return (0);
        }
#line 499
        i = (OPJ_UINT32 )0;
        {
#line 499
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 499
          if (! (i < 128U)) {
#line 499
            goto while_break___6;
          }
          {
#line 500
          distoachieved = (OPJ_FLOAT64 )0;
#line 502
          thresh = (lo + hi) / (double )2;
#line 504
          opj_tcd_makelayer(tcd, layno, thresh, (OPJ_UINT32 )0);
          }
#line 506
          if (cp->m_specific_param.m_enc.m_fixed_quality) {
#line 507
            if ((int )cp->rsiz >= 3) {
#line 507
              if ((int )cp->rsiz <= 6) {
                {
#line 508
                __cil_tmp54 = opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile,
                                                    layno + 1U, dest, p_data_written,
                                                    maxlen, cstr_info, tcd->cur_tp_num,
                                                    tcd->tp_pos, tcd->cur_pino, (J2K_T2_MODE )0);
                }
#line 508
                if (! __cil_tmp54) {
#line 510
                  lo = thresh;
#line 511
                  goto while_continue___6;
                } else {
#line 514
                  if (layno == 0U) {
#line 514
                    tmp___0 = tcd_tile->distolayer[0];
                  } else {
#line 514
                    tmp___0 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
                  }
#line 514
                  distoachieved = tmp___0;
#line 517
                  if (distoachieved < distotarget) {
#line 518
                    hi = thresh;
#line 519
                    stable_thresh = thresh;
#line 520
                    goto while_continue___6;
                  } else {
#line 522
                    lo = thresh;
                  }
                }
              } else {
#line 507
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 526
              if (layno == 0U) {
#line 526
                tmp___1 = tcd_tile->distolayer[0];
              } else {
#line 526
                tmp___1 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
              }
#line 526
              distoachieved = tmp___1;
#line 529
              if (distoachieved < distotarget) {
#line 530
                hi = thresh;
#line 531
                stable_thresh = thresh;
#line 532
                goto while_continue___6;
              }
#line 534
              lo = thresh;
            }
          } else {
            {
#line 537
            __cil_tmp57 = opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1U,
                                                dest, p_data_written, maxlen, cstr_info,
                                                tcd->cur_tp_num, tcd->tp_pos, tcd->cur_pino,
                                                (J2K_T2_MODE )0);
            }
#line 537
            if (! __cil_tmp57) {
#line 541
              lo = thresh;
#line 542
              goto while_continue___6;
            }
#line 545
            hi = thresh;
#line 546
            stable_thresh = thresh;
          }
#line 499
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 550
        success = 1;
#line 551
        if (stable_thresh == (double )0) {
#line 551
          tmp___2 = thresh;
        } else {
#line 551
          tmp___2 = stable_thresh;
        }
        {
#line 551
        goodthresh = tmp___2;
#line 553
        opj_t2_destroy(t2);
        }
      } else {
#line 491
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 491
    if ((int )cp->m_specific_param.m_enc.m_fixed_quality == 1) {
#line 491
      if (tcd_tcp->distoratio[layno] > (float )0) {
#line 491
        goto _L___0;
      } else {
#line 555
        success = 1;
#line 556
        goodthresh = min;
      }
    } else {
#line 555
      success = 1;
#line 556
      goodthresh = min;
    }
#line 559
    if (! success) {
#line 560
      return (0);
    }
#line 563
    if (cstr_info) {
#line 564
      *((cstr_info->tile + tcd->tcd_tileno)->thresh + layno) = goodthresh;
    }
    {
#line 567
    opj_tcd_makelayer(tcd, layno, goodthresh, (OPJ_UINT32 )1);
    }
#line 570
    if (layno == 0U) {
#line 570
      tmp___3 = tcd_tile->distolayer[0];
    } else {
#line 570
      tmp___3 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
    }
#line 570
    cumdisto[layno] = tmp___3;
#line 474
    layno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 573
  return (1);
}
}
#line 576 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init(opj_tcd_t *p_tcd , opj_image_t *p_image , opj_cp_t *p_cp ) 
{ 
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 580
  p_tcd->image = p_image;
#line 581
  p_tcd->cp = p_cp;
#line 583
  __cil_tmp4 = calloc((unsigned long )1, sizeof(opj_tcd_tile_t ));
#line 583
  (p_tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp4;
  }
#line 584
  if (! (p_tcd->tcd_image)->tiles) {
#line 585
    return (0);
  }
  {
#line 588
  __cil_tmp5 = calloc((unsigned long )p_image->numcomps, sizeof(opj_tcd_tilecomp_t ));
#line 588
  ((p_tcd->tcd_image)->tiles)->comps = (opj_tcd_tilecomp_t *)__cil_tmp5;
  }
#line 589
  if (! ((p_tcd->tcd_image)->tiles)->comps) {
#line 590
    return (0);
  }
#line 593
  ((p_tcd->tcd_image)->tiles)->numcomps = p_image->numcomps;
#line 594
  p_tcd->tp_pos = p_cp->m_specific_param.m_enc.m_tp_pos;
#line 596
  return (1);
}
}
#line 602 "/root/patron/new_21/src/lib/openjp2/tcd.c"
void opj_tcd_destroy(opj_tcd_t *tcd ) 
{ 


  {
#line 603
  if (tcd) {
    {
#line 604
    opj_tcd_free_tile(tcd);
    }
#line 606
    if (tcd->tcd_image) {
      {
#line 607
      free(tcd->tcd_image);
#line 608
      tcd->tcd_image = (opj_tcd_image_t *)0;
      }
    }
    {
#line 610
    free(tcd);
    }
  }
  return;
}
}
#line 999 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 (*l_gain_ptr)(OPJ_UINT32  ) ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  opj_tcp_t *l_tcp ;
  opj_cp_t *l_cp ;
  opj_tcd_tile_t *l_tile ;
  opj_tccp_t *l_tccp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_image_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_band_t *l_band ;
  opj_stepsize_t *l_step_size ;
  opj_tcd_precinct_t *l_current_precinct ;
  opj_tcd_cblk_enc_t *l_code_block ;
  opj_image_t *l_image ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_level_no ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_gain ;
  OPJ_INT32 l_x0b ;
  OPJ_INT32 l_y0b ;
  OPJ_INT32 l_tl_prc_x_start ;
  OPJ_INT32 l_tl_prc_y_start ;
  OPJ_INT32 l_br_prc_x_end ;
  OPJ_INT32 l_br_prc_y_end ;
  OPJ_UINT32 l_nb_precincts ;
  OPJ_UINT32 l_nb_precinct_size ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_UINT32 l_nb_code_blocks_size ;
  OPJ_UINT32 l_data_size ;
  OPJ_INT32 __cil_tmp38 ;
  OPJ_INT32 __cil_tmp39 ;
  OPJ_INT32 __cil_tmp40 ;
  OPJ_INT32 __cil_tmp41 ;
  OPJ_INT32 __cil_tmp42 ;
  OPJ_INT32 __cil_tmp43 ;
  OPJ_INT32 __cil_tmp44 ;
  OPJ_INT32 __cil_tmp45 ;
  void *__cil_tmp46 ;
  OPJ_INT32 *new_data ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  opj_tcd_resolution_t *new_resolutions ;
  void *__cil_tmp51 ;
  OPJ_INT32 tlcbgxstart ;
  OPJ_INT32 tlcbgystart ;
  OPJ_UINT32 cbgwidthexpn ;
  OPJ_UINT32 cbgheightexpn ;
  OPJ_UINT32 cblkwidthexpn ;
  OPJ_UINT32 cblkheightexpn ;
  OPJ_INT32 __cil_tmp58 ;
  OPJ_INT32 __cil_tmp59 ;
  OPJ_INT32 __cil_tmp60 ;
  OPJ_INT32 __cil_tmp61 ;
  OPJ_INT32 __cil_tmp62 ;
  OPJ_INT32 __cil_tmp63 ;
  OPJ_INT32 __cil_tmp64 ;
  OPJ_INT32 __cil_tmp65 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  OPJ_INT32 __cil_tmp68 ;
  OPJ_INT32 __cil_tmp69 ;
  OPJ_UINT32 __cil_tmp70 ;
  OPJ_UINT32 __cil_tmp71 ;
  OPJ_INT32 numbps ;
  OPJ_INT32 __cil_tmp73 ;
  OPJ_INT32 __cil_tmp74 ;
  OPJ_INT32 __cil_tmp75 ;
  OPJ_INT32 __cil_tmp76 ;
  OPJ_INT32 __cil_tmp77 ;
  OPJ_INT32 __cil_tmp78 ;
  OPJ_INT32 __cil_tmp79 ;
  OPJ_INT32 __cil_tmp80 ;
  OPJ_UINT32 __cil_tmp81 ;
  double __cil_tmp82 ;
  void *__cil_tmp83 ;
  opj_tcd_precinct_t *new_precincts ;
  void *__cil_tmp85 ;
  OPJ_INT32 tlcblkxstart ;
  OPJ_INT32 tlcblkystart ;
  OPJ_INT32 brcblkxend ;
  OPJ_INT32 brcblkyend ;
  OPJ_INT32 cbgxstart ;
  OPJ_INT32 cbgystart ;
  OPJ_INT32 cbgxend ;
  OPJ_INT32 cbgyend ;
  OPJ_INT32 __cil_tmp94 ;
  OPJ_INT32 __cil_tmp95 ;
  OPJ_INT32 __cil_tmp96 ;
  OPJ_INT32 __cil_tmp97 ;
  OPJ_INT32 __cil_tmp98 ;
  OPJ_INT32 __cil_tmp99 ;
  OPJ_INT32 __cil_tmp100 ;
  OPJ_INT32 __cil_tmp101 ;
  void *__cil_tmp102 ;
  opj_tcd_cblk_enc_t *new_ELEMENT ;
  void *__cil_tmp104 ;
  opj_tgt_tree_t *__cil_tmp105 ;
  opj_tgt_tree_t *__cil_tmp106 ;
  opj_tgt_tree_t *__cil_tmp107 ;
  opj_tgt_tree_t *__cil_tmp108 ;
  OPJ_INT32 cblkxstart ;
  OPJ_INT32 cblkystart ;
  OPJ_INT32 cblkxend ;
  OPJ_INT32 cblkyend ;
  OPJ_BOOL __cil_tmp113 ;
  OPJ_INT32 __cil_tmp114 ;
  OPJ_INT32 __cil_tmp115 ;
  OPJ_INT32 __cil_tmp116 ;
  OPJ_INT32 __cil_tmp117 ;

  {
  {
#line 999
  l_gain_ptr = (OPJ_UINT32 (*)(OPJ_UINT32  ))0;
#line 999
  l_tcp = (opj_tcp_t *)0;
#line 999
  l_cp = (opj_cp_t *)0;
#line 999
  l_tile = (opj_tcd_tile_t *)0;
#line 999
  l_tccp = (opj_tccp_t *)0;
#line 999
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 999
  l_image_comp = (opj_image_comp_t *)0;
#line 999
  l_res = (opj_tcd_resolution_t *)0;
#line 999
  l_band = (opj_tcd_band_t *)0;
#line 999
  l_step_size = (opj_stepsize_t *)0;
#line 999
  l_current_precinct = (opj_tcd_precinct_t *)0;
#line 999
  l_code_block = (opj_tcd_cblk_enc_t *)0;
#line 999
  l_image = (opj_image_t *)0;
#line 999
  l_cp = p_tcd->cp;
#line 999
  l_tcp = l_cp->tcps + p_tile_no;
#line 999
  l_tile = (p_tcd->tcd_image)->tiles;
#line 999
  l_tccp = l_tcp->tccps;
#line 999
  l_tilec = l_tile->comps;
#line 999
  l_image = p_tcd->image;
#line 999
  l_image_comp = (p_tcd->image)->comps;
#line 999
  p = p_tile_no % l_cp->tw;
#line 999
  q = p_tile_no / l_cp->tw;
#line 999
  l_tile->x0 = opj_int_max((OPJ_INT32 )(l_cp->tx0 + p * l_cp->tdx), (OPJ_INT32 )l_image->x0);
#line 999
  l_tile->y0 = opj_int_max((OPJ_INT32 )(l_cp->ty0 + q * l_cp->tdy), (OPJ_INT32 )l_image->y0);
#line 999
  l_tile->x1 = opj_int_min((OPJ_INT32 )(l_cp->tx0 + (p + 1U) * l_cp->tdx), (OPJ_INT32 )l_image->x1);
#line 999
  l_tile->y1 = opj_int_min((OPJ_INT32 )(l_cp->ty0 + (q + 1U) * l_cp->tdy), (OPJ_INT32 )l_image->y1);
  }
#line 999
  if (l_tccp->numresolutions == 0U) {
    {
#line 999
    fprintf(stderr, "tiles require at least one resolution\n");
    }
#line 999
    return (0);
  }
#line 999
  compno = (OPJ_UINT32 )0;
  {
#line 999
  while (1) {
    while_continue: /* CIL Label */ ;
#line 999
    if (! (compno < l_tile->numcomps)) {
#line 999
      goto while_break;
    }
    {
#line 999
    l_image_comp->resno_decoded = (OPJ_UINT32 )0;
#line 999
    l_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32 )l_image_comp->dx);
#line 999
    l_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32 )l_image_comp->dy);
#line 999
    l_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32 )l_image_comp->dx);
#line 999
    l_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32 )l_image_comp->dy);
#line 999
    l_data_size = ((OPJ_UINT32 )(l_tilec->x1 - l_tilec->x0) * (OPJ_UINT32 )(l_tilec->y1 - l_tilec->y0)) * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 999
    l_tilec->numresolutions = l_tccp->numresolutions;
    }
#line 999
    if (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {
#line 999
      l_tilec->minimum_num_resolutions = (OPJ_UINT32 )1;
    } else {
#line 999
      l_tilec->minimum_num_resolutions = l_tccp->numresolutions - l_cp->m_specific_param.m_dec.m_reduce;
    }
#line 999
    if (l_tilec->data == (OPJ_INT32 *)0) {
      {
#line 999
      __cil_tmp46 = malloc((unsigned long )l_data_size);
#line 999
      l_tilec->data = (OPJ_INT32 *)__cil_tmp46;
      }
#line 999
      if (! l_tilec->data) {
#line 999
        return (0);
      }
#line 999
      l_tilec->data_size = l_data_size;
    } else
#line 999
    if (l_data_size > l_tilec->data_size) {
      {
#line 999
      __cil_tmp48 = realloc(l_tilec->data, (unsigned long )l_data_size);
#line 999
      new_data = (OPJ_INT32 *)__cil_tmp48;
#line 999
      fprintf(stderr, "Not enough memory to handle tile data\n");
      }
#line 999
      if (! new_data) {
        {
#line 999
        free(l_tilec->data);
#line 999
        l_tilec->data = (OPJ_INT32 *)((void *)0);
#line 999
        l_tilec->data_size = (OPJ_UINT32 )0;
        }
#line 999
        return (0);
      }
#line 999
      l_tilec->data = new_data;
#line 999
      l_tilec->data_size = l_data_size;
    }
#line 999
    l_data_size = l_tilec->numresolutions * (OPJ_UINT32 )sizeof(opj_tcd_resolution_t );
#line 999
    if (l_tilec->resolutions == (opj_tcd_resolution_t *)0) {
      {
#line 999
      __cil_tmp49 = malloc((unsigned long )l_data_size);
#line 999
      l_tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp49;
      }
#line 999
      if (! l_tilec->resolutions) {
#line 999
        return (0);
      }
      {
#line 999
      l_tilec->resolutions_size = l_data_size;
#line 999
      memset(l_tilec->resolutions, 0, (unsigned long )l_data_size);
      }
    } else
#line 999
    if (l_data_size > l_tilec->resolutions_size) {
      {
#line 999
      __cil_tmp51 = realloc(l_tilec->resolutions, (unsigned long )l_data_size);
#line 999
      new_resolutions = (opj_tcd_resolution_t *)__cil_tmp51;
      }
#line 999
      if (! new_resolutions) {
        {
#line 999
        fprintf(stderr, "Not enough memory to tile resolutions\n");
#line 999
        free(l_tilec->resolutions);
#line 999
        l_tilec->resolutions = (opj_tcd_resolution_t *)((void *)0);
#line 999
        l_tilec->resolutions_size = (OPJ_UINT32 )0;
        }
#line 999
        return (0);
      }
      {
#line 999
      l_tilec->resolutions = new_resolutions;
#line 999
      memset((OPJ_BYTE *)l_tilec->resolutions + l_tilec->resolutions_size, 0, (unsigned long )(l_data_size - l_tilec->resolutions_size));
#line 999
      l_tilec->resolutions_size = l_data_size;
      }
    }
#line 999
    l_level_no = l_tilec->numresolutions - 1U;
#line 999
    l_res = l_tilec->resolutions;
#line 999
    l_step_size = (opj_stepsize_t *)l_tccp->stepsizes;
#line 999
    if (l_tccp->qmfbid == 0U) {
#line 999
      l_gain_ptr = & opj_dwt_getgain_real;
    } else {
#line 999
      l_gain_ptr = & opj_dwt_getgain;
    }
#line 999
    resno = (OPJ_UINT32 )0;
    {
#line 999
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 999
      if (! (resno < l_tilec->numresolutions)) {
#line 999
        goto while_break___0;
      }
      {
#line 999
      l_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 999
      l_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 999
      l_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 999
      l_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
#line 999
      l_pdx = l_tccp->prcw[resno];
#line 999
      l_pdy = l_tccp->prch[resno];
#line 999
      __cil_tmp62 = opj_int_floordivpow2(l_res->x0, (OPJ_INT32 )l_pdx);
#line 999
      l_tl_prc_x_start = __cil_tmp62 << l_pdx;
#line 999
      __cil_tmp63 = opj_int_floordivpow2(l_res->y0, (OPJ_INT32 )l_pdy);
#line 999
      l_tl_prc_y_start = __cil_tmp63 << l_pdy;
#line 999
      __cil_tmp64 = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32 )l_pdx);
#line 999
      l_br_prc_x_end = __cil_tmp64 << l_pdx;
#line 999
      __cil_tmp65 = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32 )l_pdy);
#line 999
      l_br_prc_y_end = __cil_tmp65 << l_pdy;
      }
#line 999
      if (l_res->x0 == l_res->x1) {
#line 999
        tmp = (unsigned int )0;
      } else {
#line 999
        tmp = (OPJ_UINT32 )((l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);
      }
#line 999
      l_res->pw = tmp;
#line 999
      if (l_res->y0 == l_res->y1) {
#line 999
        tmp___0 = (unsigned int )0;
      } else {
#line 999
        tmp___0 = (OPJ_UINT32 )((l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);
      }
#line 999
      l_res->ph = tmp___0;
#line 999
      l_nb_precincts = l_res->pw * l_res->ph;
#line 999
      l_nb_precinct_size = l_nb_precincts * (OPJ_UINT32 )sizeof(opj_tcd_precinct_t );
#line 999
      if (resno == 0U) {
#line 999
        tlcbgxstart = l_tl_prc_x_start;
#line 999
        tlcbgystart = l_tl_prc_y_start;
#line 999
        cbgwidthexpn = l_pdx;
#line 999
        cbgheightexpn = l_pdy;
#line 999
        l_res->numbands = (OPJ_UINT32 )1;
      } else {
        {
#line 999
        tlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);
#line 999
        tlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);
#line 999
        cbgwidthexpn = l_pdx - 1U;
#line 999
        cbgheightexpn = l_pdy - 1U;
#line 999
        l_res->numbands = (OPJ_UINT32 )3;
        }
      }
      {
#line 999
      cblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);
#line 999
      cblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);
#line 999
      l_band = (opj_tcd_band_t *)l_res->bands;
#line 999
      bandno = (OPJ_UINT32 )0;
      }
      {
#line 999
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 999
        if (! (bandno < l_res->numbands)) {
#line 999
          goto while_break___1;
        }
#line 999
        if (resno == 0U) {
          {
#line 999
          l_band->bandno = (OPJ_UINT32 )0;
#line 999
          l_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 999
          l_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 999
          l_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 999
          l_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
          }
        } else {
          {
#line 999
          l_band->bandno = bandno + 1U;
#line 999
          l_x0b = (OPJ_INT32 )(l_band->bandno & 1U);
#line 999
          l_y0b = (OPJ_INT32 )(l_band->bandno >> 1);
#line 999
          l_band->x0 = opj_int_ceildivpow2(l_tilec->x0 - (1 << l_level_no) * l_x0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
#line 999
          l_band->y0 = opj_int_ceildivpow2(l_tilec->y0 - (1 << l_level_no) * l_y0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
#line 999
          l_band->x1 = opj_int_ceildivpow2(l_tilec->x1 - (1 << l_level_no) * l_x0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
#line 999
          l_band->y1 = opj_int_ceildivpow2(l_tilec->y1 - (1 << l_level_no) * l_y0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
          }
        }
        {
#line 999
        l_gain = (*l_gain_ptr)(l_band->bandno);
#line 999
        numbps = (OPJ_INT32 )(l_image_comp->prec + l_gain);
#line 999
        __cil_tmp82 = pow(2., (double )((OPJ_INT32 )(numbps - l_step_size->expn)));
#line 999
        l_band->stepsize = (OPJ_FLOAT32 )((1. + (double )l_step_size->mant / 2048.) * __cil_tmp82) * 1.f;
#line 999
        l_band->numbps = (l_step_size->expn + (OPJ_INT32 )l_tccp->numgbits) - 1;
        }
#line 999
        if (! l_band->precincts) {
          {
#line 999
          __cil_tmp83 = malloc((unsigned long )l_nb_precinct_size);
#line 999
          l_band->precincts = (opj_tcd_precinct_t *)__cil_tmp83;
          }
#line 999
          if (! l_band->precincts) {
#line 999
            return (0);
          }
          {
#line 999
          memset(l_band->precincts, 0, (unsigned long )l_nb_precinct_size);
#line 999
          l_band->precincts_data_size = l_nb_precinct_size;
          }
        } else
#line 999
        if (l_band->precincts_data_size < l_nb_precinct_size) {
          {
#line 999
          __cil_tmp85 = realloc(l_band->precincts, (unsigned long )l_nb_precinct_size);
#line 999
          new_precincts = (opj_tcd_precinct_t *)__cil_tmp85;
          }
#line 999
          if (! new_precincts) {
            {
#line 999
            fprintf(stderr, "Not enough memory to handle band precints\n");
#line 999
            free(l_band->precincts);
#line 999
            l_band->precincts = (opj_tcd_precinct_t *)((void *)0);
#line 999
            l_band->precincts_data_size = (OPJ_UINT32 )0;
            }
#line 999
            return (0);
          }
          {
#line 999
          l_band->precincts = new_precincts;
#line 999
          memset((OPJ_BYTE *)l_band->precincts + l_band->precincts_data_size, 0, (unsigned long )(l_nb_precinct_size - l_band->precincts_data_size));
#line 999
          l_band->precincts_data_size = l_nb_precinct_size;
          }
        }
#line 999
        l_current_precinct = l_band->precincts;
#line 999
        precno = (OPJ_UINT32 )0;
        {
#line 999
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 999
          if (! (precno < l_nb_precincts)) {
#line 999
            goto while_break___2;
          }
          {
#line 999
          cbgxstart = tlcbgxstart + (OPJ_INT32 )(precno % l_res->pw) * (1 << cbgwidthexpn);
#line 999
          cbgystart = tlcbgystart + (OPJ_INT32 )(precno / l_res->pw) * (1 << cbgheightexpn);
#line 999
          cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 999
          cbgyend = cbgystart + (1 << cbgheightexpn);
#line 999
          l_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);
#line 999
          l_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);
#line 999
          l_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);
#line 999
          l_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);
#line 999
          __cil_tmp98 = opj_int_floordivpow2(l_current_precinct->x0, (OPJ_INT32 )cblkwidthexpn);
#line 999
          tlcblkxstart = __cil_tmp98 << cblkwidthexpn;
#line 999
          __cil_tmp99 = opj_int_floordivpow2(l_current_precinct->y0, (OPJ_INT32 )cblkheightexpn);
#line 999
          tlcblkystart = __cil_tmp99 << cblkheightexpn;
#line 999
          __cil_tmp100 = opj_int_ceildivpow2(l_current_precinct->x1, (OPJ_INT32 )cblkwidthexpn);
#line 999
          brcblkxend = __cil_tmp100 << cblkwidthexpn;
#line 999
          __cil_tmp101 = opj_int_ceildivpow2(l_current_precinct->y1, (OPJ_INT32 )cblkheightexpn);
#line 999
          brcblkyend = __cil_tmp101 << cblkheightexpn;
#line 999
          l_current_precinct->cw = (OPJ_UINT32 )((brcblkxend - tlcblkxstart) >> cblkwidthexpn);
#line 999
          l_current_precinct->ch = (OPJ_UINT32 )((brcblkyend - tlcblkystart) >> cblkheightexpn);
#line 999
          l_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;
#line 999
          l_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32 )sizeof(opj_tcd_cblk_enc_t );
          }
#line 999
          if (! l_current_precinct->cblks.enc) {
            {
#line 999
            __cil_tmp102 = malloc((unsigned long )l_nb_code_blocks_size);
#line 999
            l_current_precinct->cblks.enc = (opj_tcd_cblk_enc_t *)__cil_tmp102;
            }
#line 999
            if (! l_current_precinct->cblks.enc) {
#line 999
              return (0);
            }
            {
#line 999
            memset(l_current_precinct->cblks.enc, 0, (unsigned long )l_nb_code_blocks_size);
#line 999
            l_current_precinct->block_size = l_nb_code_blocks_size;
            }
          } else
#line 999
          if (l_nb_code_blocks_size > l_current_precinct->block_size) {
            {
#line 999
            __cil_tmp104 = realloc(l_current_precinct->cblks.enc, (unsigned long )l_nb_code_blocks_size);
#line 999
            new_ELEMENT = (opj_tcd_cblk_enc_t *)__cil_tmp104;
            }
#line 999
            if (! new_ELEMENT) {
              {
#line 999
              free(l_current_precinct->cblks.enc);
#line 999
              l_current_precinct->cblks.enc = (opj_tcd_cblk_enc_t *)((void *)0);
#line 999
              l_current_precinct->block_size = (OPJ_UINT32 )0;
#line 999
              fprintf(stderr, "Not enough memory for current precinct codeblock element\n");
              }
#line 999
              return (0);
            }
            {
#line 999
            l_current_precinct->cblks.enc = new_ELEMENT;
#line 999
            memset((OPJ_BYTE *)l_current_precinct->cblks.enc + l_current_precinct->block_size,
                   0, (unsigned long )(l_nb_code_blocks_size - l_current_precinct->block_size));
#line 999
            l_current_precinct->block_size = l_nb_code_blocks_size;
            }
          }
#line 999
          if (! l_current_precinct->incltree) {
            {
#line 999
            l_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch);
            }
          } else {
            {
#line 999
            l_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,
                                                        l_current_precinct->cw, l_current_precinct->ch);
            }
          }
#line 999
          if (! l_current_precinct->incltree) {
            {
#line 999
            fprintf(stderr, "WARNING: No incltree created.\n");
            }
          }
#line 999
          if (! l_current_precinct->imsbtree) {
            {
#line 999
            l_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch);
            }
          } else {
            {
#line 999
            l_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree,
                                                        l_current_precinct->cw, l_current_precinct->ch);
            }
          }
#line 999
          if (! l_current_precinct->imsbtree) {
            {
#line 999
            fprintf(stderr, "WARNING: No imsbtree created.\n");
            }
          }
#line 999
          l_code_block = l_current_precinct->cblks.enc;
#line 999
          cblkno = (OPJ_UINT32 )0;
          {
#line 999
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 999
            if (! (cblkno < l_nb_code_blocks)) {
#line 999
              goto while_break___3;
            }
            {
#line 999
            cblkxstart = tlcblkxstart + (OPJ_INT32 )(cblkno % l_current_precinct->cw) * (1 << cblkwidthexpn);
#line 999
            cblkystart = tlcblkystart + (OPJ_INT32 )(cblkno / l_current_precinct->cw) * (1 << cblkheightexpn);
#line 999
            cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 999
            cblkyend = cblkystart + (1 << cblkheightexpn);
#line 999
            __cil_tmp113 = opj_tcd_code_block_enc_allocate(l_code_block);
            }
#line 999
            if (! __cil_tmp113) {
#line 999
              return (0);
            }
            {
#line 999
            l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
#line 999
            l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
#line 999
            l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
#line 999
            l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);
#line 999
            l_code_block ++;
            }
#line 999
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 999
          l_current_precinct ++;
#line 999
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 999
        l_band ++;
#line 999
        l_step_size ++;
#line 999
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 999
      l_res ++;
#line 999
      l_level_no --;
#line 999
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 999
    l_tccp ++;
#line 999
    l_tilec ++;
#line 999
    l_image_comp ++;
#line 999
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 999
  return (1);
}
}
#line 1000 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 (*l_gain_ptr)(OPJ_UINT32  ) ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  opj_tcp_t *l_tcp ;
  opj_cp_t *l_cp ;
  opj_tcd_tile_t *l_tile ;
  opj_tccp_t *l_tccp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_image_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_band_t *l_band ;
  opj_stepsize_t *l_step_size ;
  opj_tcd_precinct_t *l_current_precinct ;
  opj_tcd_cblk_dec_t *l_code_block ;
  opj_image_t *l_image ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_level_no ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_gain ;
  OPJ_INT32 l_x0b ;
  OPJ_INT32 l_y0b ;
  OPJ_INT32 l_tl_prc_x_start ;
  OPJ_INT32 l_tl_prc_y_start ;
  OPJ_INT32 l_br_prc_x_end ;
  OPJ_INT32 l_br_prc_y_end ;
  OPJ_UINT32 l_nb_precincts ;
  OPJ_UINT32 l_nb_precinct_size ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_UINT32 l_nb_code_blocks_size ;
  OPJ_UINT32 l_data_size ;
  OPJ_INT32 __cil_tmp38 ;
  OPJ_INT32 __cil_tmp39 ;
  OPJ_INT32 __cil_tmp40 ;
  OPJ_INT32 __cil_tmp41 ;
  OPJ_INT32 __cil_tmp42 ;
  OPJ_INT32 __cil_tmp43 ;
  OPJ_INT32 __cil_tmp44 ;
  OPJ_INT32 __cil_tmp45 ;
  void *__cil_tmp46 ;
  OPJ_INT32 *new_data ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  opj_tcd_resolution_t *new_resolutions ;
  void *__cil_tmp51 ;
  OPJ_INT32 tlcbgxstart ;
  OPJ_INT32 tlcbgystart ;
  OPJ_UINT32 cbgwidthexpn ;
  OPJ_UINT32 cbgheightexpn ;
  OPJ_UINT32 cblkwidthexpn ;
  OPJ_UINT32 cblkheightexpn ;
  OPJ_INT32 __cil_tmp58 ;
  OPJ_INT32 __cil_tmp59 ;
  OPJ_INT32 __cil_tmp60 ;
  OPJ_INT32 __cil_tmp61 ;
  OPJ_INT32 __cil_tmp62 ;
  OPJ_INT32 __cil_tmp63 ;
  OPJ_INT32 __cil_tmp64 ;
  OPJ_INT32 __cil_tmp65 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  OPJ_INT32 __cil_tmp68 ;
  OPJ_INT32 __cil_tmp69 ;
  OPJ_UINT32 __cil_tmp70 ;
  OPJ_UINT32 __cil_tmp71 ;
  OPJ_INT32 numbps ;
  OPJ_INT32 __cil_tmp73 ;
  OPJ_INT32 __cil_tmp74 ;
  OPJ_INT32 __cil_tmp75 ;
  OPJ_INT32 __cil_tmp76 ;
  OPJ_INT32 __cil_tmp77 ;
  OPJ_INT32 __cil_tmp78 ;
  OPJ_INT32 __cil_tmp79 ;
  OPJ_INT32 __cil_tmp80 ;
  OPJ_UINT32 __cil_tmp81 ;
  double __cil_tmp82 ;
  void *__cil_tmp83 ;
  opj_tcd_precinct_t *new_precincts ;
  void *__cil_tmp85 ;
  OPJ_INT32 tlcblkxstart ;
  OPJ_INT32 tlcblkystart ;
  OPJ_INT32 brcblkxend ;
  OPJ_INT32 brcblkyend ;
  OPJ_INT32 cbgxstart ;
  OPJ_INT32 cbgystart ;
  OPJ_INT32 cbgxend ;
  OPJ_INT32 cbgyend ;
  OPJ_INT32 __cil_tmp94 ;
  OPJ_INT32 __cil_tmp95 ;
  OPJ_INT32 __cil_tmp96 ;
  OPJ_INT32 __cil_tmp97 ;
  OPJ_INT32 __cil_tmp98 ;
  OPJ_INT32 __cil_tmp99 ;
  OPJ_INT32 __cil_tmp100 ;
  OPJ_INT32 __cil_tmp101 ;
  void *__cil_tmp102 ;
  opj_tcd_cblk_dec_t *new_ELEMENT ;
  void *__cil_tmp104 ;
  opj_tgt_tree_t *__cil_tmp105 ;
  opj_tgt_tree_t *__cil_tmp106 ;
  opj_tgt_tree_t *__cil_tmp107 ;
  opj_tgt_tree_t *__cil_tmp108 ;
  OPJ_INT32 cblkxstart ;
  OPJ_INT32 cblkystart ;
  OPJ_INT32 cblkxend ;
  OPJ_INT32 cblkyend ;
  OPJ_BOOL __cil_tmp113 ;
  OPJ_INT32 __cil_tmp114 ;
  OPJ_INT32 __cil_tmp115 ;
  OPJ_INT32 __cil_tmp116 ;
  OPJ_INT32 __cil_tmp117 ;

  {
  {
#line 1000
  l_gain_ptr = (OPJ_UINT32 (*)(OPJ_UINT32  ))0;
#line 1000
  l_tcp = (opj_tcp_t *)0;
#line 1000
  l_cp = (opj_cp_t *)0;
#line 1000
  l_tile = (opj_tcd_tile_t *)0;
#line 1000
  l_tccp = (opj_tccp_t *)0;
#line 1000
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 1000
  l_image_comp = (opj_image_comp_t *)0;
#line 1000
  l_res = (opj_tcd_resolution_t *)0;
#line 1000
  l_band = (opj_tcd_band_t *)0;
#line 1000
  l_step_size = (opj_stepsize_t *)0;
#line 1000
  l_current_precinct = (opj_tcd_precinct_t *)0;
#line 1000
  l_code_block = (opj_tcd_cblk_dec_t *)0;
#line 1000
  l_image = (opj_image_t *)0;
#line 1000
  l_cp = p_tcd->cp;
#line 1000
  l_tcp = l_cp->tcps + p_tile_no;
#line 1000
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1000
  l_tccp = l_tcp->tccps;
#line 1000
  l_tilec = l_tile->comps;
#line 1000
  l_image = p_tcd->image;
#line 1000
  l_image_comp = (p_tcd->image)->comps;
#line 1000
  p = p_tile_no % l_cp->tw;
#line 1000
  q = p_tile_no / l_cp->tw;
#line 1000
  l_tile->x0 = opj_int_max((OPJ_INT32 )(l_cp->tx0 + p * l_cp->tdx), (OPJ_INT32 )l_image->x0);
#line 1000
  l_tile->y0 = opj_int_max((OPJ_INT32 )(l_cp->ty0 + q * l_cp->tdy), (OPJ_INT32 )l_image->y0);
#line 1000
  l_tile->x1 = opj_int_min((OPJ_INT32 )(l_cp->tx0 + (p + 1U) * l_cp->tdx), (OPJ_INT32 )l_image->x1);
#line 1000
  l_tile->y1 = opj_int_min((OPJ_INT32 )(l_cp->ty0 + (q + 1U) * l_cp->tdy), (OPJ_INT32 )l_image->y1);
  }
#line 1000
  if (l_tccp->numresolutions == 0U) {
    {
#line 1000
    fprintf(stderr, "tiles require at least one resolution\n");
    }
#line 1000
    return (0);
  }
#line 1000
  compno = (OPJ_UINT32 )0;
  {
#line 1000
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1000
    if (! (compno < l_tile->numcomps)) {
#line 1000
      goto while_break;
    }
    {
#line 1000
    l_image_comp->resno_decoded = (OPJ_UINT32 )0;
#line 1000
    l_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32 )l_image_comp->dx);
#line 1000
    l_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32 )l_image_comp->dy);
#line 1000
    l_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32 )l_image_comp->dx);
#line 1000
    l_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32 )l_image_comp->dy);
#line 1000
    l_data_size = ((OPJ_UINT32 )(l_tilec->x1 - l_tilec->x0) * (OPJ_UINT32 )(l_tilec->y1 - l_tilec->y0)) * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 1000
    l_tilec->numresolutions = l_tccp->numresolutions;
    }
#line 1000
    if (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {
#line 1000
      l_tilec->minimum_num_resolutions = (OPJ_UINT32 )1;
    } else {
#line 1000
      l_tilec->minimum_num_resolutions = l_tccp->numresolutions - l_cp->m_specific_param.m_dec.m_reduce;
    }
#line 1000
    if (l_tilec->data == (OPJ_INT32 *)0) {
      {
#line 1000
      __cil_tmp46 = malloc((unsigned long )l_data_size);
#line 1000
      l_tilec->data = (OPJ_INT32 *)__cil_tmp46;
      }
#line 1000
      if (! l_tilec->data) {
#line 1000
        return (0);
      }
#line 1000
      l_tilec->data_size = l_data_size;
    } else
#line 1000
    if (l_data_size > l_tilec->data_size) {
      {
#line 1000
      __cil_tmp48 = realloc(l_tilec->data, (unsigned long )l_data_size);
#line 1000
      new_data = (OPJ_INT32 *)__cil_tmp48;
#line 1000
      fprintf(stderr, "Not enough memory to handle tile data\n");
      }
#line 1000
      if (! new_data) {
        {
#line 1000
        free(l_tilec->data);
#line 1000
        l_tilec->data = (OPJ_INT32 *)((void *)0);
#line 1000
        l_tilec->data_size = (OPJ_UINT32 )0;
        }
#line 1000
        return (0);
      }
#line 1000
      l_tilec->data = new_data;
#line 1000
      l_tilec->data_size = l_data_size;
    }
#line 1000
    l_data_size = l_tilec->numresolutions * (OPJ_UINT32 )sizeof(opj_tcd_resolution_t );
#line 1000
    if (l_tilec->resolutions == (opj_tcd_resolution_t *)0) {
      {
#line 1000
      __cil_tmp49 = malloc((unsigned long )l_data_size);
#line 1000
      l_tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp49;
      }
#line 1000
      if (! l_tilec->resolutions) {
#line 1000
        return (0);
      }
      {
#line 1000
      l_tilec->resolutions_size = l_data_size;
#line 1000
      memset(l_tilec->resolutions, 0, (unsigned long )l_data_size);
      }
    } else
#line 1000
    if (l_data_size > l_tilec->resolutions_size) {
      {
#line 1000
      __cil_tmp51 = realloc(l_tilec->resolutions, (unsigned long )l_data_size);
#line 1000
      new_resolutions = (opj_tcd_resolution_t *)__cil_tmp51;
      }
#line 1000
      if (! new_resolutions) {
        {
#line 1000
        fprintf(stderr, "Not enough memory to tile resolutions\n");
#line 1000
        free(l_tilec->resolutions);
#line 1000
        l_tilec->resolutions = (opj_tcd_resolution_t *)((void *)0);
#line 1000
        l_tilec->resolutions_size = (OPJ_UINT32 )0;
        }
#line 1000
        return (0);
      }
      {
#line 1000
      l_tilec->resolutions = new_resolutions;
#line 1000
      memset((OPJ_BYTE *)l_tilec->resolutions + l_tilec->resolutions_size, 0, (unsigned long )(l_data_size - l_tilec->resolutions_size));
#line 1000
      l_tilec->resolutions_size = l_data_size;
      }
    }
#line 1000
    l_level_no = l_tilec->numresolutions - 1U;
#line 1000
    l_res = l_tilec->resolutions;
#line 1000
    l_step_size = (opj_stepsize_t *)l_tccp->stepsizes;
#line 1000
    if (l_tccp->qmfbid == 0U) {
#line 1000
      l_gain_ptr = & opj_dwt_getgain_real;
    } else {
#line 1000
      l_gain_ptr = & opj_dwt_getgain;
    }
#line 1000
    resno = (OPJ_UINT32 )0;
    {
#line 1000
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1000
      if (! (resno < l_tilec->numresolutions)) {
#line 1000
        goto while_break___0;
      }
      {
#line 1000
      l_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 1000
      l_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 1000
      l_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 1000
      l_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
#line 1000
      l_pdx = l_tccp->prcw[resno];
#line 1000
      l_pdy = l_tccp->prch[resno];
#line 1000
      __cil_tmp62 = opj_int_floordivpow2(l_res->x0, (OPJ_INT32 )l_pdx);
#line 1000
      l_tl_prc_x_start = __cil_tmp62 << l_pdx;
#line 1000
      __cil_tmp63 = opj_int_floordivpow2(l_res->y0, (OPJ_INT32 )l_pdy);
#line 1000
      l_tl_prc_y_start = __cil_tmp63 << l_pdy;
#line 1000
      __cil_tmp64 = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32 )l_pdx);
#line 1000
      l_br_prc_x_end = __cil_tmp64 << l_pdx;
#line 1000
      __cil_tmp65 = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32 )l_pdy);
#line 1000
      l_br_prc_y_end = __cil_tmp65 << l_pdy;
      }
#line 1000
      if (l_res->x0 == l_res->x1) {
#line 1000
        tmp = (unsigned int )0;
      } else {
#line 1000
        tmp = (OPJ_UINT32 )((l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);
      }
#line 1000
      l_res->pw = tmp;
#line 1000
      if (l_res->y0 == l_res->y1) {
#line 1000
        tmp___0 = (unsigned int )0;
      } else {
#line 1000
        tmp___0 = (OPJ_UINT32 )((l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);
      }
#line 1000
      l_res->ph = tmp___0;
#line 1000
      l_nb_precincts = l_res->pw * l_res->ph;
#line 1000
      l_nb_precinct_size = l_nb_precincts * (OPJ_UINT32 )sizeof(opj_tcd_precinct_t );
#line 1000
      if (resno == 0U) {
#line 1000
        tlcbgxstart = l_tl_prc_x_start;
#line 1000
        tlcbgystart = l_tl_prc_y_start;
#line 1000
        cbgwidthexpn = l_pdx;
#line 1000
        cbgheightexpn = l_pdy;
#line 1000
        l_res->numbands = (OPJ_UINT32 )1;
      } else {
        {
#line 1000
        tlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);
#line 1000
        tlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);
#line 1000
        cbgwidthexpn = l_pdx - 1U;
#line 1000
        cbgheightexpn = l_pdy - 1U;
#line 1000
        l_res->numbands = (OPJ_UINT32 )3;
        }
      }
      {
#line 1000
      cblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);
#line 1000
      cblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);
#line 1000
      l_band = (opj_tcd_band_t *)l_res->bands;
#line 1000
      bandno = (OPJ_UINT32 )0;
      }
      {
#line 1000
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1000
        if (! (bandno < l_res->numbands)) {
#line 1000
          goto while_break___1;
        }
#line 1000
        if (resno == 0U) {
          {
#line 1000
          l_band->bandno = (OPJ_UINT32 )0;
#line 1000
          l_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 1000
          l_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 1000
          l_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 1000
          l_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
          }
        } else {
          {
#line 1000
          l_band->bandno = bandno + 1U;
#line 1000
          l_x0b = (OPJ_INT32 )(l_band->bandno & 1U);
#line 1000
          l_y0b = (OPJ_INT32 )(l_band->bandno >> 1);
#line 1000
          l_band->x0 = opj_int_ceildivpow2(l_tilec->x0 - (1 << l_level_no) * l_x0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
#line 1000
          l_band->y0 = opj_int_ceildivpow2(l_tilec->y0 - (1 << l_level_no) * l_y0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
#line 1000
          l_band->x1 = opj_int_ceildivpow2(l_tilec->x1 - (1 << l_level_no) * l_x0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
#line 1000
          l_band->y1 = opj_int_ceildivpow2(l_tilec->y1 - (1 << l_level_no) * l_y0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
          }
        }
        {
#line 1000
        l_gain = (*l_gain_ptr)(l_band->bandno);
#line 1000
        numbps = (OPJ_INT32 )(l_image_comp->prec + l_gain);
#line 1000
        __cil_tmp82 = pow(2., (double )((OPJ_INT32 )(numbps - l_step_size->expn)));
#line 1000
        l_band->stepsize = (OPJ_FLOAT32 )((1. + (double )l_step_size->mant / 2048.) * __cil_tmp82) * 0.5f;
#line 1000
        l_band->numbps = (l_step_size->expn + (OPJ_INT32 )l_tccp->numgbits) - 1;
        }
#line 1000
        if (! l_band->precincts) {
          {
#line 1000
          __cil_tmp83 = malloc((unsigned long )l_nb_precinct_size);
#line 1000
          l_band->precincts = (opj_tcd_precinct_t *)__cil_tmp83;
          }
#line 1000
          if (! l_band->precincts) {
#line 1000
            return (0);
          }
          {
#line 1000
          memset(l_band->precincts, 0, (unsigned long )l_nb_precinct_size);
#line 1000
          l_band->precincts_data_size = l_nb_precinct_size;
          }
        } else
#line 1000
        if (l_band->precincts_data_size < l_nb_precinct_size) {
          {
#line 1000
          __cil_tmp85 = realloc(l_band->precincts, (unsigned long )l_nb_precinct_size);
#line 1000
          new_precincts = (opj_tcd_precinct_t *)__cil_tmp85;
          }
#line 1000
          if (! new_precincts) {
            {
#line 1000
            fprintf(stderr, "Not enough memory to handle band precints\nOh\347U");
#line 1000
            free(l_band->precincts);
#line 1000
            l_band->precincts = (opj_tcd_precinct_t *)((void *)0);
#line 1000
            l_band->precincts_data_size = (OPJ_UINT32 )0;
            }
#line 1000
            return (0);
          }
          {
#line 1000
          l_band->precincts = new_precincts;
#line 1000
          memset((OPJ_BYTE *)l_band->precincts + l_band->precincts_data_size, 0, (unsigned long )(l_nb_precinct_size - l_band->precincts_data_size));
#line 1000
          l_band->precincts_data_size = l_nb_precinct_size;
          }
        }
#line 1000
        l_current_precinct = l_band->precincts;
#line 1000
        precno = (OPJ_UINT32 )0;
        {
#line 1000
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1000
          if (! (precno < l_nb_precincts)) {
#line 1000
            goto while_break___2;
          }
          {
#line 1000
          cbgxstart = tlcbgxstart + (OPJ_INT32 )(precno % l_res->pw) * (1 << cbgwidthexpn);
#line 1000
          cbgystart = tlcbgystart + (OPJ_INT32 )(precno / l_res->pw) * (1 << cbgheightexpn);
#line 1000
          cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 1000
          cbgyend = cbgystart + (1 << cbgheightexpn);
#line 1000
          l_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);
#line 1000
          l_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);
#line 1000
          l_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);
#line 1000
          l_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);
#line 1000
          __cil_tmp98 = opj_int_floordivpow2(l_current_precinct->x0, (OPJ_INT32 )cblkwidthexpn);
#line 1000
          tlcblkxstart = __cil_tmp98 << cblkwidthexpn;
#line 1000
          __cil_tmp99 = opj_int_floordivpow2(l_current_precinct->y0, (OPJ_INT32 )cblkheightexpn);
#line 1000
          tlcblkystart = __cil_tmp99 << cblkheightexpn;
#line 1000
          __cil_tmp100 = opj_int_ceildivpow2(l_current_precinct->x1, (OPJ_INT32 )cblkwidthexpn);
#line 1000
          brcblkxend = __cil_tmp100 << cblkwidthexpn;
#line 1000
          __cil_tmp101 = opj_int_ceildivpow2(l_current_precinct->y1, (OPJ_INT32 )cblkheightexpn);
#line 1000
          brcblkyend = __cil_tmp101 << cblkheightexpn;
#line 1000
          l_current_precinct->cw = (OPJ_UINT32 )((brcblkxend - tlcblkxstart) >> cblkwidthexpn);
#line 1000
          l_current_precinct->ch = (OPJ_UINT32 )((brcblkyend - tlcblkystart) >> cblkheightexpn);
#line 1000
          l_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;
#line 1000
          l_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32 )sizeof(opj_tcd_cblk_dec_t );
          }
#line 1000
          if (! l_current_precinct->cblks.dec) {
            {
#line 1000
            __cil_tmp102 = malloc((unsigned long )l_nb_code_blocks_size);
#line 1000
            l_current_precinct->cblks.dec = (opj_tcd_cblk_dec_t *)__cil_tmp102;
            }
#line 1000
            if (! l_current_precinct->cblks.dec) {
#line 1000
              return (0);
            }
            {
#line 1000
            memset(l_current_precinct->cblks.dec, 0, (unsigned long )l_nb_code_blocks_size);
#line 1000
            l_current_precinct->block_size = l_nb_code_blocks_size;
            }
          } else
#line 1000
          if (l_nb_code_blocks_size > l_current_precinct->block_size) {
            {
#line 1000
            __cil_tmp104 = realloc(l_current_precinct->cblks.dec, (unsigned long )l_nb_code_blocks_size);
#line 1000
            new_ELEMENT = (opj_tcd_cblk_dec_t *)__cil_tmp104;
            }
#line 1000
            if (! new_ELEMENT) {
              {
#line 1000
              free(l_current_precinct->cblks.dec);
#line 1000
              l_current_precinct->cblks.dec = (opj_tcd_cblk_dec_t *)((void *)0);
#line 1000
              l_current_precinct->block_size = (OPJ_UINT32 )0;
#line 1000
              fprintf(stderr, "Not enough memory for current precinct codeblock element\n");
              }
#line 1000
              return (0);
            }
            {
#line 1000
            l_current_precinct->cblks.dec = new_ELEMENT;
#line 1000
            memset((OPJ_BYTE *)l_current_precinct->cblks.dec + l_current_precinct->block_size,
                   0, (unsigned long )(l_nb_code_blocks_size - l_current_precinct->block_size));
#line 1000
            l_current_precinct->block_size = l_nb_code_blocks_size;
            }
          }
#line 1000
          if (! l_current_precinct->incltree) {
            {
#line 1000
            l_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch);
            }
          } else {
            {
#line 1000
            l_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,
                                                        l_current_precinct->cw, l_current_precinct->ch);
            }
          }
#line 1000
          if (! l_current_precinct->incltree) {
            {
#line 1000
            fprintf(stderr, "WARNING: No incltree created.\n");
            }
          }
#line 1000
          if (! l_current_precinct->imsbtree) {
            {
#line 1000
            l_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch);
            }
          } else {
            {
#line 1000
            l_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree,
                                                        l_current_precinct->cw, l_current_precinct->ch);
            }
          }
#line 1000
          if (! l_current_precinct->imsbtree) {
            {
#line 1000
            fprintf(stderr, "WARNING: No imsbtree created.\n");
            }
          }
#line 1000
          l_code_block = l_current_precinct->cblks.dec;
#line 1000
          cblkno = (OPJ_UINT32 )0;
          {
#line 1000
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1000
            if (! (cblkno < l_nb_code_blocks)) {
#line 1000
              goto while_break___3;
            }
            {
#line 1000
            cblkxstart = tlcblkxstart + (OPJ_INT32 )(cblkno % l_current_precinct->cw) * (1 << cblkwidthexpn);
#line 1000
            cblkystart = tlcblkystart + (OPJ_INT32 )(cblkno / l_current_precinct->cw) * (1 << cblkheightexpn);
#line 1000
            cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 1000
            cblkyend = cblkystart + (1 << cblkheightexpn);
#line 1000
            __cil_tmp113 = opj_tcd_code_block_dec_allocate(l_code_block);
            }
#line 1000
            if (! __cil_tmp113) {
#line 1000
              return (0);
            }
            {
#line 1000
            l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
#line 1000
            l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
#line 1000
            l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
#line 1000
            l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);
#line 1000
            l_code_block ++;
            }
#line 1000
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1000
          l_current_precinct ++;
#line 1000
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1000
        l_band ++;
#line 1000
        l_step_size ++;
#line 1000
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1000
      l_res ++;
#line 1000
      l_level_no --;
#line 1000
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1000
    l_tccp ++;
#line 1000
    l_tilec ++;
#line 1000
    l_image_comp ++;
#line 1000
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1000
  return (1);
}
}
#line 1007 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *p_code_block ) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
#line 1009
  if (! p_code_block->data) {
    {
#line 1011
    __cil_tmp2 = malloc((unsigned long )16384);
#line 1011
    p_code_block->data = (OPJ_BYTE *)__cil_tmp2;
    }
#line 1012
    if (! p_code_block->data) {
#line 1013
      return (0);
    }
    {
#line 1016
    *(p_code_block->data + 0) = (OPJ_BYTE )0;
#line 1017
    (p_code_block->data) ++;
#line 1020
    __cil_tmp3 = calloc((unsigned long )100, sizeof(opj_tcd_layer_t ));
#line 1020
    p_code_block->layers = (opj_tcd_layer_t *)__cil_tmp3;
    }
#line 1021
    if (! p_code_block->layers) {
#line 1022
      return (0);
    }
    {
#line 1025
    __cil_tmp4 = calloc((unsigned long )100, sizeof(opj_tcd_pass_t ));
#line 1025
    p_code_block->passes = (opj_tcd_pass_t *)__cil_tmp4;
    }
#line 1026
    if (! p_code_block->passes) {
#line 1027
      return (0);
    }
  }
#line 1031
  return (1);
}
}
#line 1037 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *p_code_block ) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  OPJ_BYTE *l_data ;
  OPJ_UINT32 l_data_max_size ;
  opj_tcd_seg_t *l_segs ;
  OPJ_UINT32 l_current_max_segs ;

  {
#line 1039
  if (! p_code_block->data) {
    {
#line 1041
    __cil_tmp2 = malloc((unsigned long )8192);
#line 1041
    p_code_block->data = (OPJ_BYTE *)__cil_tmp2;
    }
#line 1042
    if (! p_code_block->data) {
#line 1043
      return (0);
    }
    {
#line 1045
    p_code_block->data_max_size = (OPJ_UINT32 )8192;
#line 1048
    __cil_tmp3 = calloc((unsigned long )10, sizeof(opj_tcd_seg_t ));
#line 1048
    p_code_block->segs = (opj_tcd_seg_t *)__cil_tmp3;
    }
#line 1049
    if (! p_code_block->segs) {
#line 1050
      return (0);
    }
#line 1054
    p_code_block->m_current_max_segs = (OPJ_UINT32 )10;
  } else {
    {
#line 1058
    l_data = p_code_block->data;
#line 1059
    l_data_max_size = p_code_block->data_max_size;
#line 1060
    l_segs = p_code_block->segs;
#line 1061
    l_current_max_segs = p_code_block->m_current_max_segs;
#line 1063
    memset(p_code_block, 0, sizeof(opj_tcd_cblk_dec_t ));
#line 1064
    p_code_block->data = l_data;
#line 1065
    p_code_block->data_max_size = l_data_max_size;
#line 1066
    p_code_block->segs = l_segs;
#line 1067
    p_code_block->m_current_max_segs = l_current_max_segs;
    }
  }
#line 1070
  return (1);
}
}
#line 1073 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_UINT32 opj_tcd_get_decoded_tile_size(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tcd_resolution_t *l_res ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;

  {
#line 1076
  l_data_size = (OPJ_UINT32 )0;
#line 1077
  l_img_comp = (opj_image_comp_t *)0;
#line 1078
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1079
  l_res = (opj_tcd_resolution_t *)0;
#line 1082
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 1083
  l_img_comp = (p_tcd->image)->comps;
#line 1085
  i = (OPJ_UINT32 )0;
  {
#line 1085
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1085
    if (! (i < (p_tcd->image)->numcomps)) {
#line 1085
      goto while_break;
    }
#line 1086
    l_size_comp = l_img_comp->prec >> 3;
#line 1087
    l_remaining = l_img_comp->prec & 7U;
#line 1089
    if (l_remaining) {
#line 1090
      l_size_comp ++;
    }
#line 1093
    if (l_size_comp == 3U) {
#line 1094
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 1097
    l_res = (l_tile_comp->resolutions + l_tile_comp->minimum_num_resolutions) - 1;
#line 1098
    l_data_size += l_size_comp * (OPJ_UINT32 )((l_res->x1 - l_res->x0) * (l_res->y1 - l_res->y0));
#line 1099
    l_img_comp ++;
#line 1100
    l_tile_comp ++;
#line 1085
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1103
  return (l_data_size);
}
}
#line 1106 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , OPJ_BYTE *p_dest ,
                             OPJ_UINT32 *p_data_written , OPJ_UINT32 p_max_length ,
                             opj_codestream_info_t *p_cstr_info ) 
{ 
  OPJ_UINT32 l_num_packs ;
  OPJ_UINT32 i ;
  opj_tcd_tilecomp_t *l_tilec_idx ;
  opj_tccp_t *l_tccp ;
  opj_tcd_resolution_t *l_res_idx ;
  OPJ_UINT32 __cil_tmp12 ;
  void *__cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;

  {
#line 1114
  if (p_tcd->cur_tp_num == 0U) {
#line 1116
    p_tcd->tcd_tileno = p_tile_no;
#line 1117
    p_tcd->tcp = (p_tcd->cp)->tcps + p_tile_no;
#line 1120
    if (p_cstr_info) {
#line 1121
      l_num_packs = (OPJ_UINT32 )0;
#line 1123
      l_tilec_idx = ((p_tcd->tcd_image)->tiles)->comps + 0;
#line 1124
      l_tccp = (p_tcd->tcp)->tccps;
#line 1126
      i = (OPJ_UINT32 )0;
      {
#line 1126
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1126
        if (! (i < l_tilec_idx->numresolutions)) {
#line 1126
          goto while_break;
        }
#line 1127
        l_res_idx = l_tilec_idx->resolutions + i;
#line 1129
        (p_cstr_info->tile + p_tile_no)->pw[i] = (int )l_res_idx->pw;
#line 1130
        (p_cstr_info->tile + p_tile_no)->ph[i] = (int )l_res_idx->ph;
#line 1132
        l_num_packs += l_res_idx->pw * l_res_idx->ph;
#line 1133
        (p_cstr_info->tile + p_tile_no)->pdx[i] = (int )l_tccp->prcw[i];
#line 1134
        (p_cstr_info->tile + p_tile_no)->pdy[i] = (int )l_tccp->prch[i];
#line 1126
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1136
      __cil_tmp13 = calloc(((size_t )p_cstr_info->numcomps * (size_t )p_cstr_info->numlayers) * (unsigned long )l_num_packs,
                           sizeof(opj_packet_info_t ));
#line 1136
      (p_cstr_info->tile + p_tile_no)->packet = (opj_packet_info_t *)__cil_tmp13;
      }
#line 1137
      if (! (p_cstr_info->tile + p_tile_no)->packet) {
#line 1139
        return (0);
      }
    }
    {
#line 1146
    __cil_tmp14 = opj_tcd_dc_level_shift_encode(p_tcd);
    }
#line 1146
    if (! __cil_tmp14) {
#line 1147
      return (0);
    }
    {
#line 1152
    __cil_tmp15 = opj_tcd_mct_encode(p_tcd);
    }
#line 1152
    if (! __cil_tmp15) {
#line 1153
      return (0);
    }
    {
#line 1158
    __cil_tmp16 = opj_tcd_dwt_encode(p_tcd);
    }
#line 1158
    if (! __cil_tmp16) {
#line 1159
      return (0);
    }
    {
#line 1164
    __cil_tmp17 = opj_tcd_t1_encode(p_tcd);
    }
#line 1164
    if (! __cil_tmp17) {
#line 1165
      return (0);
    }
    {
#line 1170
    __cil_tmp18 = opj_tcd_rate_allocate_encode(p_tcd, p_dest, p_max_length, p_cstr_info);
    }
#line 1170
    if (! __cil_tmp18) {
#line 1171
      return (0);
    }
  }
#line 1179
  if (p_cstr_info) {
#line 1180
    p_cstr_info->index_write = 1;
  }
  {
#line 1184
  __cil_tmp19 = opj_tcd_t2_encode(p_tcd, p_dest, p_data_written, p_max_length, p_cstr_info);
  }
#line 1184
  if (! __cil_tmp19) {
#line 1185
    return (0);
  }
#line 1191
  return (1);
}
}
#line 1194 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_decode_tile(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_UINT32 p_max_length ,
                             OPJ_UINT32 p_tile_no , opj_codestream_index_t *p_cstr_index ) 
{ 
  OPJ_UINT32 l_data_read ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 1202
  p_tcd->tcd_tileno = p_tile_no;
#line 1203
  p_tcd->tcp = (p_tcd->cp)->tcps + p_tile_no;
#line 1230
  l_data_read = (OPJ_UINT32 )0;
#line 1231
  __cil_tmp7 = opj_tcd_t2_decode(p_tcd, p_src, & l_data_read, p_max_length, p_cstr_index);
  }
#line 1231
  if (! __cil_tmp7) {
#line 1233
    return (0);
  }
  {
#line 1240
  __cil_tmp8 = opj_tcd_t1_decode(p_tcd);
  }
#line 1240
  if (! __cil_tmp8) {
#line 1243
    return (0);
  }
  {
#line 1250
  __cil_tmp9 = opj_tcd_dwt_decode(p_tcd);
  }
#line 1250
  if (! __cil_tmp9) {
#line 1253
    return (0);
  }
  {
#line 1259
  __cil_tmp10 = opj_tcd_mct_decode(p_tcd);
  }
#line 1259
  if (! __cil_tmp10) {
#line 1262
    return (0);
  }
  {
#line 1267
  __cil_tmp11 = opj_tcd_dc_level_shift_decode(p_tcd);
  }
#line 1267
  if (! __cil_tmp11) {
#line 1270
    return (0);
  }
#line 1276
  return (1);
}
}
#line 1279 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_update_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest , OPJ_UINT32 p_dest_length ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_tcd_resolution_t *l_res ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_UINT32 l_stride ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 __cil_tmp16 ;
  OPJ_CHAR *l_dest_ptr ;
  OPJ_INT32 *l_src_ptr ;
  OPJ_CHAR *__cil_tmp19 ;
  OPJ_INT32 *__cil_tmp20 ;
  OPJ_CHAR *__cil_tmp21 ;
  OPJ_INT32 *__cil_tmp22 ;
  OPJ_INT32 *l_src_ptr___0 ;
  OPJ_INT16 *l_dest_ptr___0 ;
  OPJ_INT16 *__cil_tmp25 ;
  OPJ_INT32 *__cil_tmp26 ;
  OPJ_INT16 *__cil_tmp27 ;
  OPJ_INT32 *__cil_tmp28 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *l_src_ptr___1 ;
  OPJ_INT32 *__cil_tmp31 ;
  OPJ_INT32 *__cil_tmp32 ;

  {
  {
#line 1284
  l_data_size = (OPJ_UINT32 )0;
#line 1285
  l_img_comp = (opj_image_comp_t *)0;
#line 1286
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 1291
  l_data_size = opj_tcd_get_decoded_tile_size(p_tcd);
  }
#line 1292
  if (l_data_size > p_dest_length) {
#line 1293
    return (0);
  }
#line 1296
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 1297
  l_img_comp = (p_tcd->image)->comps;
#line 1299
  i = (OPJ_UINT32 )0;
  {
#line 1299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1299
    if (! (i < (p_tcd->image)->numcomps)) {
#line 1299
      goto while_break;
    }
#line 1300
    l_size_comp = l_img_comp->prec >> 3;
#line 1301
    l_remaining = l_img_comp->prec & 7U;
#line 1302
    l_res = l_tilec->resolutions + l_img_comp->resno_decoded;
#line 1303
    l_width = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 1304
    l_height = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
#line 1305
    l_stride = (OPJ_UINT32 )(l_tilec->x1 - l_tilec->x0) - l_width;
#line 1307
    if (l_remaining) {
#line 1308
      l_size_comp ++;
    }
#line 1311
    if (l_size_comp == 3U) {
#line 1312
      l_size_comp = (OPJ_UINT32 )4;
    }
    {
#line 1317
    if (l_size_comp == (OPJ_UINT32 )1) {
#line 1317
      goto case_1;
    }
#line 1342
    if (l_size_comp == (OPJ_UINT32 )2) {
#line 1342
      goto case_2;
    }
#line 1367
    if (l_size_comp == (OPJ_UINT32 )4) {
#line 1367
      goto case_4;
    }
#line 1315
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1319
    l_dest_ptr = (OPJ_CHAR *)p_dest;
#line 1320
    l_src_ptr = l_tilec->data;
#line 1322
    if (l_img_comp->sgnd) {
#line 1323
      j = (OPJ_UINT32 )0;
      {
#line 1323
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1323
        if (! (j < l_height)) {
#line 1323
          goto while_break___0;
        }
#line 1324
        k = (OPJ_UINT32 )0;
        {
#line 1324
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1324
          if (! (k < l_width)) {
#line 1324
            goto while_break___1;
          }
#line 1325
          __cil_tmp20 = l_src_ptr;
#line 1325
          l_src_ptr ++;
#line 1325
          __cil_tmp19 = l_dest_ptr;
#line 1325
          l_dest_ptr ++;
#line 1325
          *__cil_tmp19 = (OPJ_CHAR )*__cil_tmp20;
#line 1324
          k ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1327
        l_src_ptr += l_stride;
#line 1323
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 1331
      j = (OPJ_UINT32 )0;
      {
#line 1331
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1331
        if (! (j < l_height)) {
#line 1331
          goto while_break___2;
        }
#line 1332
        k = (OPJ_UINT32 )0;
        {
#line 1332
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1332
          if (! (k < l_width)) {
#line 1332
            goto while_break___3;
          }
#line 1333
          __cil_tmp22 = l_src_ptr;
#line 1333
          l_src_ptr ++;
#line 1333
          __cil_tmp21 = l_dest_ptr;
#line 1333
          l_dest_ptr ++;
#line 1333
          *__cil_tmp21 = (OPJ_CHAR )(*__cil_tmp22 & 255);
#line 1332
          k ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1335
        l_src_ptr += l_stride;
#line 1331
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1339
    p_dest = (OPJ_BYTE *)l_dest_ptr;
#line 1341
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1344
    l_src_ptr___0 = l_tilec->data;
#line 1345
    l_dest_ptr___0 = (OPJ_INT16 *)p_dest;
#line 1347
    if (l_img_comp->sgnd) {
#line 1348
      j = (OPJ_UINT32 )0;
      {
#line 1348
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1348
        if (! (j < l_height)) {
#line 1348
          goto while_break___4;
        }
#line 1349
        k = (OPJ_UINT32 )0;
        {
#line 1349
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1349
          if (! (k < l_width)) {
#line 1349
            goto while_break___5;
          }
#line 1350
          __cil_tmp26 = l_src_ptr___0;
#line 1350
          l_src_ptr___0 ++;
#line 1350
          __cil_tmp25 = l_dest_ptr___0;
#line 1350
          l_dest_ptr___0 ++;
#line 1350
          *__cil_tmp25 = (OPJ_INT16 )*__cil_tmp26;
#line 1349
          k ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1352
        l_src_ptr___0 += l_stride;
#line 1348
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 1356
      j = (OPJ_UINT32 )0;
      {
#line 1356
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1356
        if (! (j < l_height)) {
#line 1356
          goto while_break___6;
        }
#line 1357
        k = (OPJ_UINT32 )0;
        {
#line 1357
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1357
          if (! (k < l_width)) {
#line 1357
            goto while_break___7;
          }
#line 1358
          __cil_tmp28 = l_src_ptr___0;
#line 1358
          l_src_ptr___0 ++;
#line 1358
          __cil_tmp27 = l_dest_ptr___0;
#line 1358
          l_dest_ptr___0 ++;
#line 1358
          *__cil_tmp27 = (OPJ_INT16 )(*__cil_tmp28 & 65535);
#line 1357
          k ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1360
        l_src_ptr___0 += l_stride;
#line 1356
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 1364
    p_dest = (OPJ_BYTE *)l_dest_ptr___0;
#line 1366
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1369
    l_dest_ptr___1 = (OPJ_INT32 *)p_dest;
#line 1370
    l_src_ptr___1 = l_tilec->data;
#line 1372
    j = (OPJ_UINT32 )0;
    {
#line 1372
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1372
      if (! (j < l_height)) {
#line 1372
        goto while_break___8;
      }
#line 1373
      k = (OPJ_UINT32 )0;
      {
#line 1373
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1373
        if (! (k < l_width)) {
#line 1373
          goto while_break___9;
        }
#line 1374
        __cil_tmp32 = l_src_ptr___1;
#line 1374
        l_src_ptr___1 ++;
#line 1374
        __cil_tmp31 = l_dest_ptr___1;
#line 1374
        l_dest_ptr___1 ++;
#line 1374
        *__cil_tmp31 = *__cil_tmp32;
#line 1373
        k ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1376
      l_src_ptr___1 += l_stride;
#line 1372
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1379
    p_dest = (OPJ_BYTE *)l_dest_ptr___1;
#line 1381
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1384
    l_img_comp ++;
#line 1385
    l_tilec ++;
#line 1299
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1388
  return (1);
}
}
#line 1394 "/root/patron/new_21/src/lib/openjp2/tcd.c"
void opj_tcd_free_tile(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_band_t *l_band ;
  opj_tcd_precinct_t *l_precinct ;
  OPJ_UINT32 l_nb_resolutions ;
  OPJ_UINT32 l_nb_precincts ;
  void (*l_tcd_code_block_deallocate)(opj_tcd_precinct_t * ) ;

  {
#line 1397
  l_tile = (opj_tcd_tile_t *)0;
#line 1398
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1399
  l_res = (opj_tcd_resolution_t *)0;
#line 1400
  l_band = (opj_tcd_band_t *)0;
#line 1401
  l_precinct = (opj_tcd_precinct_t *)0;
#line 1403
  l_tcd_code_block_deallocate = (void (*)(opj_tcd_precinct_t * ))0;
#line 1405
  if (! p_tcd) {
#line 1406
    return;
  }
#line 1409
  if (! p_tcd->tcd_image) {
#line 1410
    return;
  }
#line 1413
  if (p_tcd->m_is_decoder) {
#line 1414
    l_tcd_code_block_deallocate = & opj_tcd_code_block_dec_deallocate;
  } else {
#line 1417
    l_tcd_code_block_deallocate = & opj_tcd_code_block_enc_deallocate;
  }
#line 1420
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1421
  if (! l_tile) {
#line 1422
    return;
  }
#line 1425
  l_tile_comp = l_tile->comps;
#line 1427
  compno = (OPJ_UINT32 )0;
  {
#line 1427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1427
    if (! (compno < l_tile->numcomps)) {
#line 1427
      goto while_break;
    }
#line 1428
    l_res = l_tile_comp->resolutions;
#line 1429
    if (l_res) {
#line 1431
      l_nb_resolutions = (OPJ_UINT32 )((unsigned long )l_tile_comp->resolutions_size / sizeof(opj_tcd_resolution_t ));
#line 1432
      resno = (OPJ_UINT32 )0;
      {
#line 1432
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1432
        if (! (resno < l_nb_resolutions)) {
#line 1432
          goto while_break___0;
        }
#line 1433
        l_band = (opj_tcd_band_t *)l_res->bands;
#line 1434
        bandno = (OPJ_UINT32 )0;
        {
#line 1434
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1434
          if (! (bandno < 3U)) {
#line 1434
            goto while_break___1;
          }
#line 1435
          l_precinct = l_band->precincts;
#line 1436
          if (l_precinct) {
#line 1438
            l_nb_precincts = (OPJ_UINT32 )((unsigned long )l_band->precincts_data_size / sizeof(opj_tcd_precinct_t ));
#line 1439
            precno = (OPJ_UINT32 )0;
            {
#line 1439
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 1439
              if (! (precno < l_nb_precincts)) {
#line 1439
                goto while_break___2;
              }
              {
#line 1440
              opj_tgt_destroy(l_precinct->incltree);
#line 1441
              l_precinct->incltree = (opj_tgt_tree_t *)0;
#line 1442
              opj_tgt_destroy(l_precinct->imsbtree);
#line 1443
              l_precinct->imsbtree = (opj_tgt_tree_t *)0;
#line 1444
              (*l_tcd_code_block_deallocate)(l_precinct);
#line 1445
              l_precinct ++;
              }
#line 1439
              precno ++;
            }
            while_break___2: /* CIL Label */ ;
            }
            {
#line 1448
            free(l_band->precincts);
#line 1449
            l_band->precincts = (opj_tcd_precinct_t *)0;
            }
          }
#line 1451
          l_band ++;
#line 1434
          bandno ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1453
        l_res ++;
#line 1432
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1456
      free(l_tile_comp->resolutions);
#line 1457
      l_tile_comp->resolutions = (opj_tcd_resolution_t *)0;
      }
    }
#line 1460
    if (l_tile_comp->data) {
      {
#line 1461
      free(l_tile_comp->data);
#line 1462
      l_tile_comp->data = (OPJ_INT32 *)0;
      }
    }
#line 1464
    l_tile_comp ++;
#line 1427
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1467
  free(l_tile->comps);
#line 1468
  l_tile->comps = (opj_tcd_tilecomp_t *)0;
#line 1469
  free((p_tcd->tcd_image)->tiles);
#line 1470
  (p_tcd->tcd_image)->tiles = (opj_tcd_tile_t *)0;
  }
  return;
}
}
#line 1474 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd , OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                           OPJ_UINT32 p_max_src_size , opj_codestream_index_t *p_cstr_index ) 
{ 
  opj_t2_t *l_t2 ;
  opj_t2_t *__cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1483
  l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);
  }
#line 1484
  if (l_t2 == (opj_t2_t *)0) {
#line 1485
    return (0);
  }
  {
#line 1488
  __cil_tmp8 = opj_t2_decode_packets(l_t2, p_tcd->tcd_tileno, (p_tcd->tcd_image)->tiles,
                                     p_src_data, p_data_read, p_max_src_size, p_cstr_index);
  }
#line 1488
  if (! __cil_tmp8) {
    {
#line 1496
    opj_t2_destroy(l_t2);
    }
#line 1497
    return (0);
  }
  {
#line 1500
  opj_t2_destroy(l_t2);
  }
#line 1503
  return (1);
}
}
#line 1506 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_t1_t *l_t1 ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_t1_t *__cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1510
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1511
  l_tile_comp = l_tile->comps;
#line 1512
  l_tccp = (p_tcd->tcp)->tccps;
#line 1515
  l_t1 = opj_t1_create();
  }
#line 1516
  if (l_t1 == (opj_t1_t *)0) {
#line 1517
    return (0);
  }
#line 1520
  compno = (OPJ_UINT32 )0;
  {
#line 1520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1520
    if (! (compno < l_tile->numcomps)) {
#line 1520
      goto while_break;
    }
    {
#line 1522
    __cil_tmp8 = opj_t1_decode_cblks(l_t1, l_tile_comp, l_tccp);
    }
#line 1522
    if (0 == __cil_tmp8) {
      {
#line 1523
      opj_t1_destroy(l_t1);
      }
#line 1524
      return (0);
    }
#line 1526
    l_tile_comp ++;
#line 1527
    l_tccp ++;
#line 1520
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1530
  opj_t1_destroy(l_t1);
  }
#line 1532
  return (1);
}
}
#line 1536 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_UINT32 __cil_tmp9 ;

  {
#line 1539
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1540
  l_tile_comp = l_tile->comps;
#line 1541
  l_tccp = (p_tcd->tcp)->tccps;
#line 1542
  l_img_comp = (p_tcd->image)->comps;
#line 1544
  compno = (OPJ_UINT32 )0;
  {
#line 1544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1544
    if (! (compno < l_tile->numcomps)) {
#line 1544
      goto while_break;
    }
#line 1558
    if (l_tccp->qmfbid == 1U) {
      {
#line 1559
      __cil_tmp7 = opj_dwt_decode(l_tile_comp, l_img_comp->resno_decoded + 1U);
      }
#line 1559
      if (! __cil_tmp7) {
#line 1560
        return (0);
      }
    } else {
      {
#line 1564
      __cil_tmp8 = opj_dwt_decode_real(l_tile_comp, l_img_comp->resno_decoded + 1U);
      }
#line 1564
      if (! __cil_tmp8) {
#line 1565
        return (0);
      }
    }
#line 1569
    l_tile_comp ++;
#line 1570
    l_img_comp ++;
#line 1571
    l_tccp ++;
#line 1544
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1574
  return (1);
}
}
#line 1576 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcp_t *l_tcp ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  OPJ_UINT32 l_samples ;
  OPJ_UINT32 i ;
  OPJ_BYTE **l_data ;
  void *__cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 1578
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1579
  l_tcp = p_tcd->tcp;
#line 1580
  l_tile_comp = l_tile->comps;
#line 1583
  if (! l_tcp->mct) {
#line 1584
    return (1);
  }
#line 1587
  l_samples = (OPJ_UINT32 )((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));
#line 1589
  if (l_tile->numcomps >= 3U) {
#line 1591
    if (((l_tile->comps + 0)->x1 - (l_tile->comps + 0)->x0) * ((l_tile->comps + 0)->y1 - (l_tile->comps + 0)->y0) < (OPJ_INT32 )l_samples) {
      {
      {
      {
#line 1594
      fprintf(stderr, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
      }
      }
      }
#line 1595
      return (0);
    } else
#line 1591
    if (((l_tile->comps + 1)->x1 - (l_tile->comps + 1)->x0) * ((l_tile->comps + 1)->y1 - (l_tile->comps + 1)->y0) < (OPJ_INT32 )l_samples) {
      {
      {
      {
#line 1594
      fprintf(stderr, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
      }
      }
      }
#line 1595
      return (0);
    } else
#line 1591
    if (((l_tile->comps + 2)->x1 - (l_tile->comps + 2)->x0) * ((l_tile->comps + 2)->y1 - (l_tile->comps + 2)->y0) < (OPJ_INT32 )l_samples) {
      {
      {
      {
#line 1594
      fprintf(stderr, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
      }
      }
      }
#line 1595
      return (0);
    } else
#line 1597
    if (l_tcp->mct == 2U) {
#line 1600
      if (! l_tcp->m_mct_decoding_matrix) {
#line 1601
        return (1);
      }
      {
#line 1604
      __cil_tmp8 = malloc((unsigned long )l_tile->numcomps * sizeof(OPJ_BYTE *));
#line 1604
      l_data = (OPJ_BYTE **)__cil_tmp8;
      }
#line 1605
      if (! l_data) {
#line 1606
        return (0);
      }
#line 1609
      i = (OPJ_UINT32 )0;
      {
#line 1609
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1609
        if (! (i < l_tile->numcomps)) {
#line 1609
          goto while_break;
        }
#line 1610
        *(l_data + i) = (OPJ_BYTE *)l_tile_comp->data;
#line 1611
        l_tile_comp ++;
#line 1609
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1614
      __cil_tmp9 = opj_mct_decode_custom((OPJ_BYTE *)l_tcp->m_mct_decoding_matrix,
                                         l_samples, l_data, l_tile->numcomps, ((p_tcd->image)->comps)->sgnd);
      }
#line 1614
      if (! __cil_tmp9) {
        {
#line 1624
        free(l_data);
        }
#line 1625
        return (0);
      }
      {
#line 1628
      free(l_data);
      }
    } else
#line 1631
    if ((l_tcp->tccps)->qmfbid == 1U) {
      {
#line 1632
      opj_mct_decode((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                     l_samples);
      }
    } else {
      {
#line 1638
      opj_mct_decode_real((OPJ_FLOAT32 *)(l_tile->comps + 0)->data, (OPJ_FLOAT32 *)(l_tile->comps + 1)->data,
                          (OPJ_FLOAT32 *)(l_tile->comps + 2)->data, l_samples);
      }
    }
  } else {
    {
#line 1647
    fprintf(stderr, "Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\n\020",
            l_tile->numcomps);
    }
  }
#line 1650
  return (1);
}
}
#line 1654 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_tile_t *l_tile ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_INT32 *l_current_ptr ;
  OPJ_INT32 l_min ;
  OPJ_INT32 l_max ;
  OPJ_UINT32 l_stride ;
  int tmp ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_FLOAT32 l_value ;
  long __cil_tmp19 ;
  OPJ_INT32 __cil_tmp20 ;
  OPJ_UINT32 __cil_tmp21 ;

  {
#line 1657
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1658
  l_tccp = (opj_tccp_t *)0;
#line 1659
  l_img_comp = (opj_image_comp_t *)0;
#line 1660
  l_res = (opj_tcd_resolution_t *)0;
#line 1667
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1668
  l_tile_comp = l_tile->comps;
#line 1669
  l_tccp = (p_tcd->tcp)->tccps;
#line 1670
  l_img_comp = (p_tcd->image)->comps;
#line 1672
  compno = (OPJ_UINT32 )0;
  {
#line 1672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1672
    if (! (compno < l_tile->numcomps)) {
#line 1672
      goto while_break;
    }
#line 1673
    l_res = l_tile_comp->resolutions + l_img_comp->resno_decoded;
#line 1674
    l_width = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 1675
    l_height = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
#line 1676
    l_stride = (OPJ_UINT32 )(l_tile_comp->x1 - l_tile_comp->x0) - l_width;
#line 1680
    if (l_img_comp->sgnd) {
#line 1681
      l_min = - (1 << (l_img_comp->prec - 1U));
#line 1682
      l_max = (1 << (l_img_comp->prec - 1U)) - 1;
    } else {
#line 1685
      l_min = 0;
#line 1686
      l_max = (1 << l_img_comp->prec) - 1;
    }
#line 1689
    l_current_ptr = l_tile_comp->data;
#line 1691
    if (l_tccp->qmfbid == 1U) {
#line 1692
      j = (OPJ_UINT32 )0;
      {
#line 1692
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1692
        if (! (j < l_height)) {
#line 1692
          goto while_break___0;
        }
#line 1693
        i = (OPJ_UINT32 )0;
        {
#line 1693
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1693
          if (! (i < l_width)) {
#line 1693
            goto while_break___1;
          }
          {
#line 1694
          *l_current_ptr = opj_int_clamp(*l_current_ptr + l_tccp->m_dc_level_shift,
                                         l_min, l_max);
#line 1695
          l_current_ptr ++;
          }
#line 1693
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1697
        l_current_ptr += l_stride;
#line 1692
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 1701
      j = (OPJ_UINT32 )0;
      {
#line 1701
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1701
        if (! (j < l_height)) {
#line 1701
          goto while_break___2;
        }
#line 1702
        i = (OPJ_UINT32 )0;
        {
#line 1702
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1702
          if (! (i < l_width)) {
#line 1702
            goto while_break___3;
          }
          {
#line 1703
          l_value = *((OPJ_FLOAT32 *)l_current_ptr);
#line 1704
          __cil_tmp19 = lrintf(l_value);
#line 1704
          __cil_tmp20 = opj_int_clamp((OPJ_INT32 )__cil_tmp19 + l_tccp->m_dc_level_shift,
                                      l_min, l_max);
#line 1704
          *l_current_ptr = __cil_tmp20;
#line 1705
          l_current_ptr ++;
          }
#line 1702
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1707
        l_current_ptr += l_stride;
#line 1701
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1711
    l_img_comp ++;
#line 1712
    l_tccp ++;
#line 1713
    l_tile_comp ++;
#line 1672
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1716
  return (1);
}
}
#line 1724 "/root/patron/new_21/src/lib/openjp2/tcd.c"
void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t *p_precinct ) 
{ 
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_cblk_dec_t *l_code_block ;

  {
#line 1728
  l_code_block = p_precinct->cblks.dec;
#line 1729
  if (l_code_block) {
#line 1736
    l_nb_code_blocks = (OPJ_UINT32 )((unsigned long )p_precinct->block_size / sizeof(opj_tcd_cblk_dec_t ));
#line 1739
    cblkno = (OPJ_UINT32 )0;
    {
#line 1739
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1739
      if (! (cblkno < l_nb_code_blocks)) {
#line 1739
        goto while_break;
      }
#line 1741
      if (l_code_block->data) {
        {
#line 1742
        free(l_code_block->data);
#line 1743
        l_code_block->data = (OPJ_BYTE *)0;
        }
      }
#line 1746
      if (l_code_block->segs) {
        {
#line 1747
        free(l_code_block->segs);
#line 1748
        l_code_block->segs = (opj_tcd_seg_t *)0;
        }
      }
#line 1751
      l_code_block ++;
#line 1739
      cblkno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1754
    free(p_precinct->cblks.dec);
#line 1755
    p_precinct->cblks.dec = (opj_tcd_cblk_dec_t *)0;
    }
  }
  return;
}
}
#line 1762 "/root/patron/new_21/src/lib/openjp2/tcd.c"
void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t *p_precinct ) 
{ 
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_cblk_enc_t *l_code_block ;

  {
#line 1766
  l_code_block = p_precinct->cblks.enc;
#line 1767
  if (l_code_block) {
#line 1768
    l_nb_code_blocks = (OPJ_UINT32 )((unsigned long )p_precinct->block_size / sizeof(opj_tcd_cblk_enc_t ));
#line 1770
    cblkno = (OPJ_UINT32 )0;
    {
#line 1770
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1770
      if (! (cblkno < l_nb_code_blocks)) {
#line 1770
        goto while_break;
      }
#line 1771
      if (l_code_block->data) {
        {
#line 1772
        free(l_code_block->data - 1);
#line 1773
        l_code_block->data = (OPJ_BYTE *)0;
        }
      }
#line 1776
      if (l_code_block->layers) {
        {
#line 1777
        free(l_code_block->layers);
#line 1778
        l_code_block->layers = (opj_tcd_layer_t *)0;
        }
      }
#line 1781
      if (l_code_block->passes) {
        {
#line 1782
        free(l_code_block->passes);
#line 1783
        l_code_block->passes = (opj_tcd_pass_t *)0;
        }
      }
#line 1785
      l_code_block ++;
#line 1770
      cblkno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1788
    free(p_precinct->cblks.enc);
#line 1790
    p_precinct->cblks.enc = (opj_tcd_cblk_enc_t *)0;
    }
  }
  return;
}
}
#line 1794 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_UINT32 opj_tcd_get_encoded_tile_size(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;

  {
#line 1796
  l_data_size = (OPJ_UINT32 )0;
#line 1797
  l_img_comp = (opj_image_comp_t *)0;
#line 1798
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 1801
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 1802
  l_img_comp = (p_tcd->image)->comps;
#line 1803
  i = (OPJ_UINT32 )0;
  {
#line 1803
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1803
    if (! (i < (p_tcd->image)->numcomps)) {
#line 1803
      goto while_break;
    }
#line 1804
    l_size_comp = l_img_comp->prec >> 3;
#line 1805
    l_remaining = l_img_comp->prec & 7U;
#line 1807
    if (l_remaining) {
#line 1808
      l_size_comp ++;
    }
#line 1811
    if (l_size_comp == 3U) {
#line 1812
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 1815
    l_data_size += l_size_comp * (OPJ_UINT32 )((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0));
#line 1816
    l_img_comp ++;
#line 1817
    l_tilec ++;
#line 1803
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1820
  return (l_data_size);
}
}
#line 1823 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tile_t *l_tile ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_UINT32 i ;
  OPJ_INT32 *l_current_ptr ;
  OPJ_UINT32 __cil_tmp10 ;

  {
#line 1826
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1827
  l_tccp = (opj_tccp_t *)0;
#line 1828
  l_img_comp = (opj_image_comp_t *)0;
#line 1833
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1834
  l_tile_comp = l_tile->comps;
#line 1835
  l_tccp = (p_tcd->tcp)->tccps;
#line 1836
  l_img_comp = (p_tcd->image)->comps;
#line 1838
  compno = (OPJ_UINT32 )0;
  {
#line 1838
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1838
    if (! (compno < l_tile->numcomps)) {
#line 1838
      goto while_break;
    }
#line 1839
    l_current_ptr = l_tile_comp->data;
#line 1840
    l_nb_elem = (OPJ_UINT32 )((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));
#line 1842
    if (l_tccp->qmfbid == 1U) {
#line 1843
      i = (OPJ_UINT32 )0;
      {
#line 1843
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1843
        if (! (i < l_nb_elem)) {
#line 1843
          goto while_break___0;
        }
#line 1844
        *l_current_ptr -= l_tccp->m_dc_level_shift;
#line 1845
        l_current_ptr ++;
#line 1843
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 1849
      i = (OPJ_UINT32 )0;
      {
#line 1849
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1849
        if (! (i < l_nb_elem)) {
#line 1849
          goto while_break___1;
        }
#line 1850
        *l_current_ptr = (*l_current_ptr - l_tccp->m_dc_level_shift) << 11;
#line 1851
        l_current_ptr ++;
#line 1849
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1855
    l_img_comp ++;
#line 1856
    l_tccp ++;
#line 1857
    l_tile_comp ++;
#line 1838
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1860
  return (1);
}
}
#line 1863 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  OPJ_UINT32 samples ;
  OPJ_UINT32 i ;
  OPJ_BYTE **l_data ;
  opj_tcp_t *l_tcp ;
  void *__cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 1865
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1866
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 1867
  samples = (OPJ_UINT32 )((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));
#line 1869
  l_data = (OPJ_BYTE **)0;
#line 1870
  l_tcp = p_tcd->tcp;
#line 1872
  if (! (p_tcd->tcp)->mct) {
#line 1873
    return (1);
  }
#line 1876
  if ((p_tcd->tcp)->mct == 2U) {
#line 1877
    if (! (p_tcd->tcp)->m_mct_coding_matrix) {
#line 1878
      return (1);
    }
    {
#line 1881
    __cil_tmp8 = malloc((unsigned long )l_tile->numcomps * sizeof(OPJ_BYTE *));
#line 1881
    l_data = (OPJ_BYTE **)__cil_tmp8;
    }
#line 1882
    if (! l_data) {
#line 1883
      return (0);
    }
#line 1886
    i = (OPJ_UINT32 )0;
    {
#line 1886
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1886
      if (! (i < l_tile->numcomps)) {
#line 1886
        goto while_break;
      }
#line 1887
      *(l_data + i) = (OPJ_BYTE *)l_tile_comp->data;
#line 1888
      l_tile_comp ++;
#line 1886
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1891
    __cil_tmp9 = opj_mct_encode_custom((OPJ_BYTE *)(p_tcd->tcp)->m_mct_coding_matrix,
                                       samples, l_data, l_tile->numcomps, ((p_tcd->image)->comps)->sgnd);
    }
#line 1891
    if (! __cil_tmp9) {
      {
#line 1902
      free(l_data);
      }
#line 1903
      return (0);
    }
    {
#line 1906
    free(l_data);
    }
  } else
#line 1908
  if ((l_tcp->tccps)->qmfbid == 0U) {
    {
#line 1909
    opj_mct_encode_real((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                        samples);
    }
  } else {
    {
#line 1912
    opj_mct_encode((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                   samples);
    }
  }
#line 1915
  return (1);
}
}
#line 1918 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 1920
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1921
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 1922
  l_tccp = (p_tcd->tcp)->tccps;
#line 1925
  compno = (OPJ_UINT32 )0;
  {
#line 1925
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1925
    if (! (compno < l_tile->numcomps)) {
#line 1925
      goto while_break;
    }
#line 1926
    if (l_tccp->qmfbid == 1U) {
      {
#line 1927
      __cil_tmp6 = opj_dwt_encode(l_tile_comp);
      }
#line 1927
      if (! __cil_tmp6) {
#line 1928
        return (0);
      }
    } else
#line 1931
    if (l_tccp->qmfbid == 0U) {
      {
#line 1932
      __cil_tmp7 = opj_dwt_encode_real(l_tile_comp);
      }
#line 1932
      if (! __cil_tmp7) {
#line 1933
        return (0);
      }
    }
#line 1937
    l_tile_comp ++;
#line 1938
    l_tccp ++;
#line 1925
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1941
  return (1);
}
}
#line 1944 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_t1_t *l_t1 ;
  OPJ_FLOAT64 *l_mct_norms ;
  opj_tcp_t *l_tcp ;
  opj_t1_t *__cil_tmp5 ;
  OPJ_FLOAT64 *__cil_tmp6 ;
  OPJ_FLOAT64 *__cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1948
  l_tcp = p_tcd->tcp;
#line 1950
  l_t1 = opj_t1_create();
  }
#line 1951
  if (l_t1 == (opj_t1_t *)0) {
#line 1952
    return (0);
  }
#line 1955
  if (l_tcp->mct == 1U) {
#line 1957
    if ((l_tcp->tccps)->qmfbid == 0U) {
      {
#line 1958
      l_mct_norms = opj_mct_get_mct_norms_real();
      }
    } else {
      {
#line 1961
      l_mct_norms = opj_mct_get_mct_norms();
      }
    }
  } else {
#line 1965
    l_mct_norms = (OPJ_FLOAT64 *)l_tcp->mct_norms;
  }
  {
#line 1968
  __cil_tmp8 = opj_t1_encode_cblks(l_t1, (p_tcd->tcd_image)->tiles, l_tcp, l_mct_norms);
  }
#line 1968
  if (! __cil_tmp8) {
    {
#line 1969
    opj_t1_destroy(l_t1);
    }
#line 1970
    return (0);
  }
  {
#line 1973
  opj_t1_destroy(l_t1);
  }
#line 1975
  return (1);
}
}
#line 1978 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 *p_data_written ,
                           OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ) 
{ 
  opj_t2_t *l_t2 ;
  opj_t2_t *__cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1986
  l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);
  }
#line 1987
  if (l_t2 == (opj_t2_t *)0) {
#line 1988
    return (0);
  }
  {
#line 1991
  __cil_tmp8 = opj_t2_encode_packets(l_t2, p_tcd->tcd_tileno, (p_tcd->tcd_image)->tiles,
                                     (p_tcd->tcp)->numlayers, p_dest_data, p_data_written,
                                     p_max_dest_size, p_cstr_info, p_tcd->tp_num,
                                     p_tcd->tp_pos, p_tcd->cur_pino, (J2K_T2_MODE )1);
  }
#line 1991
  if (! __cil_tmp8) {
    {
#line 2005
    opj_t2_destroy(l_t2);
    }
#line 2006
    return (0);
  }
  {
#line 2009
  opj_t2_destroy(l_t2);
  }
#line 2012
  return (1);
}
}
#line 2016 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 p_max_dest_size ,
                                      opj_codestream_info_t *p_cstr_info ) 
{ 
  opj_cp_t *l_cp ;
  OPJ_UINT32 l_nb_written ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 2021
  l_cp = p_tcd->cp;
#line 2022
  l_nb_written = (OPJ_UINT32 )0;
#line 2024
  if (p_cstr_info) {
#line 2025
    p_cstr_info->index_write = 0;
  }
#line 2028
  if ((int )l_cp->m_specific_param.m_enc.m_disto_alloc) {
    _L: /* CIL Label */ 
    {
#line 2031
    __cil_tmp7 = opj_tcd_rateallocate(p_tcd, p_dest_data, & l_nb_written, p_max_dest_size,
                                      p_cstr_info);
    }
#line 2031
    if (! __cil_tmp7) {
#line 2032
      return (0);
    }
  } else
#line 2028
  if ((int )l_cp->m_specific_param.m_enc.m_fixed_quality) {
#line 2028
    goto _L;
  } else {
    {
#line 2037
    opj_tcd_rateallocate_fixed(p_tcd);
    }
  }
#line 2040
  return (1);
}
}
#line 2044 "/root/patron/new_21/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_copy_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_UINT32 p_src_length ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_CHAR *l_src_ptr ;
  OPJ_INT32 *l_dest_ptr ;
  OPJ_INT32 *__cil_tmp15 ;
  OPJ_CHAR *__cil_tmp16 ;
  OPJ_INT32 *__cil_tmp17 ;
  OPJ_CHAR *__cil_tmp18 ;
  OPJ_INT32 *l_dest_ptr___0 ;
  OPJ_INT16 *l_src_ptr___0 ;
  OPJ_INT32 *__cil_tmp21 ;
  OPJ_INT16 *__cil_tmp22 ;
  OPJ_INT32 *__cil_tmp23 ;
  OPJ_INT16 *__cil_tmp24 ;
  OPJ_INT32 *l_src_ptr___1 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *__cil_tmp27 ;
  OPJ_INT32 *__cil_tmp28 ;

  {
  {
#line 2048
  l_data_size = (OPJ_UINT32 )0;
#line 2049
  l_img_comp = (opj_image_comp_t *)0;
#line 2050
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 2054
  l_data_size = opj_tcd_get_encoded_tile_size(p_tcd);
  }
#line 2055
  if (l_data_size != p_src_length) {
#line 2056
    return (0);
  }
#line 2059
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 2060
  l_img_comp = (p_tcd->image)->comps;
#line 2061
  i = (OPJ_UINT32 )0;
  {
#line 2061
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2061
    if (! (i < (p_tcd->image)->numcomps)) {
#line 2061
      goto while_break;
    }
#line 2062
    l_size_comp = l_img_comp->prec >> 3;
#line 2063
    l_remaining = l_img_comp->prec & 7U;
#line 2064
    l_nb_elem = (OPJ_UINT32 )((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0));
#line 2066
    if (l_remaining) {
#line 2067
      l_size_comp ++;
    }
#line 2070
    if (l_size_comp == 3U) {
#line 2071
      l_size_comp = (OPJ_UINT32 )4;
    }
    {
#line 2075
    if (l_size_comp == (OPJ_UINT32 )1) {
#line 2075
      goto case_1;
    }
#line 2094
    if (l_size_comp == (OPJ_UINT32 )2) {
#line 2094
      goto case_2;
    }
#line 2113
    if (l_size_comp == (OPJ_UINT32 )4) {
#line 2113
      goto case_4;
    }
#line 2074
    goto switch_break;
    case_1: /* CIL Label */ 
#line 2077
    l_src_ptr = (OPJ_CHAR *)p_src;
#line 2078
    l_dest_ptr = l_tilec->data;
#line 2080
    if (l_img_comp->sgnd) {
#line 2081
      j = (OPJ_UINT32 )0;
      {
#line 2081
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2081
        if (! (j < l_nb_elem)) {
#line 2081
          goto while_break___0;
        }
#line 2082
        __cil_tmp16 = l_src_ptr;
#line 2082
        l_src_ptr ++;
#line 2082
        __cil_tmp15 = l_dest_ptr;
#line 2082
        l_dest_ptr ++;
#line 2082
        *__cil_tmp15 = (OPJ_INT32 )*__cil_tmp16;
#line 2081
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 2086
      j = (OPJ_UINT32 )0;
      {
#line 2086
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2086
        if (! (j < l_nb_elem)) {
#line 2086
          goto while_break___1;
        }
#line 2087
        __cil_tmp18 = l_src_ptr;
#line 2087
        l_src_ptr ++;
#line 2087
        __cil_tmp17 = l_dest_ptr;
#line 2087
        l_dest_ptr ++;
#line 2087
        *__cil_tmp17 = (int )*__cil_tmp18 & 255;
#line 2086
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2091
    p_src = (OPJ_BYTE *)l_src_ptr;
#line 2093
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2096
    l_dest_ptr___0 = l_tilec->data;
#line 2097
    l_src_ptr___0 = (OPJ_INT16 *)p_src;
#line 2099
    if (l_img_comp->sgnd) {
#line 2100
      j = (OPJ_UINT32 )0;
      {
#line 2100
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2100
        if (! (j < l_nb_elem)) {
#line 2100
          goto while_break___2;
        }
#line 2101
        __cil_tmp22 = l_src_ptr___0;
#line 2101
        l_src_ptr___0 ++;
#line 2101
        __cil_tmp21 = l_dest_ptr___0;
#line 2101
        l_dest_ptr___0 ++;
#line 2101
        *__cil_tmp21 = (OPJ_INT32 )*__cil_tmp22;
#line 2100
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 2105
      j = (OPJ_UINT32 )0;
      {
#line 2105
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2105
        if (! (j < l_nb_elem)) {
#line 2105
          goto while_break___3;
        }
#line 2106
        __cil_tmp24 = l_src_ptr___0;
#line 2106
        l_src_ptr___0 ++;
#line 2106
        __cil_tmp23 = l_dest_ptr___0;
#line 2106
        l_dest_ptr___0 ++;
#line 2106
        *__cil_tmp23 = (int )*__cil_tmp24 & 65535;
#line 2105
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 2110
    p_src = (OPJ_BYTE *)l_src_ptr___0;
#line 2112
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2115
    l_src_ptr___1 = (OPJ_INT32 *)p_src;
#line 2116
    l_dest_ptr___1 = l_tilec->data;
#line 2118
    j = (OPJ_UINT32 )0;
    {
#line 2118
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2118
      if (! (j < l_nb_elem)) {
#line 2118
        goto while_break___4;
      }
#line 2119
      __cil_tmp28 = l_src_ptr___1;
#line 2119
      l_src_ptr___1 ++;
#line 2119
      __cil_tmp27 = l_dest_ptr___1;
#line 2119
      l_dest_ptr___1 ++;
#line 2119
      *__cil_tmp27 = (OPJ_INT32 )*__cil_tmp28;
#line 2118
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2122
    p_src = (OPJ_BYTE *)l_src_ptr___1;
#line 2124
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2127
    l_img_comp ++;
#line 2128
    l_tilec ++;
#line 2061
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2131
  return (1);
}
}
#line 3 "/root/patron/new_21/src/lib/openjp2/t1_luts.h"
static OPJ_BYTE lut_ctxno_zc[1024]  = 
#line 3 "/root/patron/new_21/src/lib/openjp2/t1_luts.h"
  {      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )0,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )6, 
        (OPJ_BYTE )3,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8};
#line 38 "/root/patron/new_21/src/lib/openjp2/t1_luts.h"
static OPJ_BYTE lut_ctxno_sc[256]  = 
#line 38
  {      (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )9, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )9, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )9, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )9, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13};
#line 57 "/root/patron/new_21/src/lib/openjp2/t1_luts.h"
static OPJ_BYTE lut_spb[256]  = 
#line 57
  {      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1};
#line 68 "/root/patron/new_21/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_sig[128]  = 
#line 68
  {      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )384,      (OPJ_INT16 )768,      (OPJ_INT16 )1152, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1920,      (OPJ_INT16 )2304,      (OPJ_INT16 )2688, 
        (OPJ_INT16 )3072,      (OPJ_INT16 )3456,      (OPJ_INT16 )3840,      (OPJ_INT16 )4224, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4992,      (OPJ_INT16 )5376,      (OPJ_INT16 )5760, 
        (OPJ_INT16 )6144,      (OPJ_INT16 )6528,      (OPJ_INT16 )6912,      (OPJ_INT16 )7296, 
        (OPJ_INT16 )7680,      (OPJ_INT16 )8064,      (OPJ_INT16 )8448,      (OPJ_INT16 )8832, 
        (OPJ_INT16 )9216,      (OPJ_INT16 )9600,      (OPJ_INT16 )9984,      (OPJ_INT16 )10368, 
        (OPJ_INT16 )10752,      (OPJ_INT16 )11136,      (OPJ_INT16 )11520,      (OPJ_INT16 )11904, 
        (OPJ_INT16 )12288,      (OPJ_INT16 )12672,      (OPJ_INT16 )13056,      (OPJ_INT16 )13440, 
        (OPJ_INT16 )13824,      (OPJ_INT16 )14208,      (OPJ_INT16 )14592,      (OPJ_INT16 )14976, 
        (OPJ_INT16 )15360,      (OPJ_INT16 )15744,      (OPJ_INT16 )16128,      (OPJ_INT16 )16512, 
        (OPJ_INT16 )16896,      (OPJ_INT16 )17280,      (OPJ_INT16 )17664,      (OPJ_INT16 )18048, 
        (OPJ_INT16 )18432,      (OPJ_INT16 )18816,      (OPJ_INT16 )19200,      (OPJ_INT16 )19584, 
        (OPJ_INT16 )19968,      (OPJ_INT16 )20352,      (OPJ_INT16 )20736,      (OPJ_INT16 )21120, 
        (OPJ_INT16 )21504,      (OPJ_INT16 )21888,      (OPJ_INT16 )22272,      (OPJ_INT16 )22656, 
        (OPJ_INT16 )23040,      (OPJ_INT16 )23424,      (OPJ_INT16 )23808,      (OPJ_INT16 )24192, 
        (OPJ_INT16 )24576,      (OPJ_INT16 )24960,      (OPJ_INT16 )25344,      (OPJ_INT16 )25728, 
        (OPJ_INT16 )26112,      (OPJ_INT16 )26496,      (OPJ_INT16 )26880,      (OPJ_INT16 )27264, 
        (OPJ_INT16 )27648,      (OPJ_INT16 )28032,      (OPJ_INT16 )28416,      (OPJ_INT16 )28800, 
        (OPJ_INT16 )29184,      (OPJ_INT16 )29568,      (OPJ_INT16 )29952,      (OPJ_INT16 )30336};
#line 87 "/root/patron/new_21/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_sig0[128]  = 
#line 87
  {      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )128,      (OPJ_INT16 )128, 
        (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )256,      (OPJ_INT16 )256, 
        (OPJ_INT16 )256,      (OPJ_INT16 )384,      (OPJ_INT16 )384,      (OPJ_INT16 )512, 
        (OPJ_INT16 )512,      (OPJ_INT16 )640,      (OPJ_INT16 )640,      (OPJ_INT16 )768, 
        (OPJ_INT16 )768,      (OPJ_INT16 )896,      (OPJ_INT16 )1024,      (OPJ_INT16 )1024, 
        (OPJ_INT16 )1152,      (OPJ_INT16 )1280,      (OPJ_INT16 )1408,      (OPJ_INT16 )1408, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1664,      (OPJ_INT16 )1792,      (OPJ_INT16 )1920, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )2176,      (OPJ_INT16 )2304,      (OPJ_INT16 )2432, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2688,      (OPJ_INT16 )2944,      (OPJ_INT16 )3072, 
        (OPJ_INT16 )3200,      (OPJ_INT16 )3328,      (OPJ_INT16 )3584,      (OPJ_INT16 )3712, 
        (OPJ_INT16 )3840,      (OPJ_INT16 )4096,      (OPJ_INT16 )4224,      (OPJ_INT16 )4480, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4864,      (OPJ_INT16 )4992,      (OPJ_INT16 )5248, 
        (OPJ_INT16 )5376,      (OPJ_INT16 )5632,      (OPJ_INT16 )5888,      (OPJ_INT16 )6016, 
        (OPJ_INT16 )6272,      (OPJ_INT16 )6528,      (OPJ_INT16 )6784,      (OPJ_INT16 )6912, 
        (OPJ_INT16 )7168,      (OPJ_INT16 )7424,      (OPJ_INT16 )7680,      (OPJ_INT16 )7936, 
        (OPJ_INT16 )8192,      (OPJ_INT16 )8448,      (OPJ_INT16 )8704,      (OPJ_INT16 )8960, 
        (OPJ_INT16 )9216,      (OPJ_INT16 )9472,      (OPJ_INT16 )9856,      (OPJ_INT16 )10112, 
        (OPJ_INT16 )10368,      (OPJ_INT16 )10624,      (OPJ_INT16 )11008,      (OPJ_INT16 )11264, 
        (OPJ_INT16 )11520,      (OPJ_INT16 )11904,      (OPJ_INT16 )12160,      (OPJ_INT16 )12544, 
        (OPJ_INT16 )12800,      (OPJ_INT16 )13184,      (OPJ_INT16 )13440,      (OPJ_INT16 )13824, 
        (OPJ_INT16 )14080,      (OPJ_INT16 )14464,      (OPJ_INT16 )14848,      (OPJ_INT16 )15104, 
        (OPJ_INT16 )15488,      (OPJ_INT16 )15872,      (OPJ_INT16 )16256,      (OPJ_INT16 )16512, 
        (OPJ_INT16 )16896,      (OPJ_INT16 )17280,      (OPJ_INT16 )17664,      (OPJ_INT16 )18048, 
        (OPJ_INT16 )18432,      (OPJ_INT16 )18816,      (OPJ_INT16 )19200,      (OPJ_INT16 )19584, 
        (OPJ_INT16 )19968,      (OPJ_INT16 )20352,      (OPJ_INT16 )20864,      (OPJ_INT16 )21248, 
        (OPJ_INT16 )21632,      (OPJ_INT16 )22016,      (OPJ_INT16 )22528,      (OPJ_INT16 )22912, 
        (OPJ_INT16 )23296,      (OPJ_INT16 )23808,      (OPJ_INT16 )24192,      (OPJ_INT16 )24704, 
        (OPJ_INT16 )25088,      (OPJ_INT16 )25600,      (OPJ_INT16 )25984,      (OPJ_INT16 )26496, 
        (OPJ_INT16 )26880,      (OPJ_INT16 )27392,      (OPJ_INT16 )27904,      (OPJ_INT16 )28288, 
        (OPJ_INT16 )28800,      (OPJ_INT16 )29312,      (OPJ_INT16 )29824,      (OPJ_INT16 )30208, 
        (OPJ_INT16 )30720,      (OPJ_INT16 )31232,      (OPJ_INT16 )31744,      (OPJ_INT16 )32256};
#line 106 "/root/patron/new_21/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_ref[128]  = 
#line 106
  {      (OPJ_INT16 )6144,      (OPJ_INT16 )6016,      (OPJ_INT16 )5888,      (OPJ_INT16 )5760, 
        (OPJ_INT16 )5632,      (OPJ_INT16 )5504,      (OPJ_INT16 )5376,      (OPJ_INT16 )5248, 
        (OPJ_INT16 )5120,      (OPJ_INT16 )4992,      (OPJ_INT16 )4864,      (OPJ_INT16 )4736, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4480,      (OPJ_INT16 )4352,      (OPJ_INT16 )4224, 
        (OPJ_INT16 )4096,      (OPJ_INT16 )3968,      (OPJ_INT16 )3840,      (OPJ_INT16 )3712, 
        (OPJ_INT16 )3584,      (OPJ_INT16 )3456,      (OPJ_INT16 )3328,      (OPJ_INT16 )3200, 
        (OPJ_INT16 )3072,      (OPJ_INT16 )2944,      (OPJ_INT16 )2816,      (OPJ_INT16 )2688, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2432,      (OPJ_INT16 )2304,      (OPJ_INT16 )2176, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )1920,      (OPJ_INT16 )1792,      (OPJ_INT16 )1664, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1408,      (OPJ_INT16 )1280,      (OPJ_INT16 )1152, 
        (OPJ_INT16 )1024,      (OPJ_INT16 )896,      (OPJ_INT16 )768,      (OPJ_INT16 )640, 
        (OPJ_INT16 )512,      (OPJ_INT16 )384,      (OPJ_INT16 )256,      (OPJ_INT16 )128, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )128,      (OPJ_INT16 )256,      (OPJ_INT16 )384, 
        (OPJ_INT16 )512,      (OPJ_INT16 )640,      (OPJ_INT16 )768,      (OPJ_INT16 )896, 
        (OPJ_INT16 )1024,      (OPJ_INT16 )1152,      (OPJ_INT16 )1280,      (OPJ_INT16 )1408, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1664,      (OPJ_INT16 )1792,      (OPJ_INT16 )1920, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )2176,      (OPJ_INT16 )2304,      (OPJ_INT16 )2432, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2688,      (OPJ_INT16 )2816,      (OPJ_INT16 )2944, 
        (OPJ_INT16 )3072,      (OPJ_INT16 )3200,      (OPJ_INT16 )3328,      (OPJ_INT16 )3456, 
        (OPJ_INT16 )3584,      (OPJ_INT16 )3712,      (OPJ_INT16 )3840,      (OPJ_INT16 )3968, 
        (OPJ_INT16 )4096,      (OPJ_INT16 )4224,      (OPJ_INT16 )4352,      (OPJ_INT16 )4480, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4736,      (OPJ_INT16 )4864,      (OPJ_INT16 )4992, 
        (OPJ_INT16 )5120,      (OPJ_INT16 )5248,      (OPJ_INT16 )5376,      (OPJ_INT16 )5504, 
        (OPJ_INT16 )5632,      (OPJ_INT16 )5760,      (OPJ_INT16 )5888,      (OPJ_INT16 )6016};
#line 125 "/root/patron/new_21/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_ref0[128]  = 
#line 125
  {      (OPJ_INT16 )8192,      (OPJ_INT16 )7936,      (OPJ_INT16 )7680,      (OPJ_INT16 )7424, 
        (OPJ_INT16 )7168,      (OPJ_INT16 )6912,      (OPJ_INT16 )6784,      (OPJ_INT16 )6528, 
        (OPJ_INT16 )6272,      (OPJ_INT16 )6016,      (OPJ_INT16 )5888,      (OPJ_INT16 )5632, 
        (OPJ_INT16 )5376,      (OPJ_INT16 )5248,      (OPJ_INT16 )4992,      (OPJ_INT16 )4864, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4480,      (OPJ_INT16 )4224,      (OPJ_INT16 )4096, 
        (OPJ_INT16 )3840,      (OPJ_INT16 )3712,      (OPJ_INT16 )3584,      (OPJ_INT16 )3328, 
        (OPJ_INT16 )3200,      (OPJ_INT16 )3072,      (OPJ_INT16 )2944,      (OPJ_INT16 )2688, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2432,      (OPJ_INT16 )2304,      (OPJ_INT16 )2176, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )1920,      (OPJ_INT16 )1792,      (OPJ_INT16 )1664, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1408,      (OPJ_INT16 )1408,      (OPJ_INT16 )1280, 
        (OPJ_INT16 )1152,      (OPJ_INT16 )1024,      (OPJ_INT16 )1024,      (OPJ_INT16 )896, 
        (OPJ_INT16 )768,      (OPJ_INT16 )768,      (OPJ_INT16 )640,      (OPJ_INT16 )640, 
        (OPJ_INT16 )512,      (OPJ_INT16 )512,      (OPJ_INT16 )384,      (OPJ_INT16 )384, 
        (OPJ_INT16 )256,      (OPJ_INT16 )256,      (OPJ_INT16 )256,      (OPJ_INT16 )128, 
        (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )128,      (OPJ_INT16 )128, 
        (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )256,      (OPJ_INT16 )256, 
        (OPJ_INT16 )256,      (OPJ_INT16 )384,      (OPJ_INT16 )384,      (OPJ_INT16 )512, 
        (OPJ_INT16 )512,      (OPJ_INT16 )640,      (OPJ_INT16 )640,      (OPJ_INT16 )768, 
        (OPJ_INT16 )768,      (OPJ_INT16 )896,      (OPJ_INT16 )1024,      (OPJ_INT16 )1024, 
        (OPJ_INT16 )1152,      (OPJ_INT16 )1280,      (OPJ_INT16 )1408,      (OPJ_INT16 )1408, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1664,      (OPJ_INT16 )1792,      (OPJ_INT16 )1920, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )2176,      (OPJ_INT16 )2304,      (OPJ_INT16 )2432, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2688,      (OPJ_INT16 )2944,      (OPJ_INT16 )3072, 
        (OPJ_INT16 )3200,      (OPJ_INT16 )3328,      (OPJ_INT16 )3584,      (OPJ_INT16 )3712, 
        (OPJ_INT16 )3840,      (OPJ_INT16 )4096,      (OPJ_INT16 )4224,      (OPJ_INT16 )4480, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4864,      (OPJ_INT16 )4992,      (OPJ_INT16 )5248, 
        (OPJ_INT16 )5376,      (OPJ_INT16 )5632,      (OPJ_INT16 )5888,      (OPJ_INT16 )6016, 
        (OPJ_INT16 )6272,      (OPJ_INT16 )6528,      (OPJ_INT16 )6784,      (OPJ_INT16 )6912, 
        (OPJ_INT16 )7168,      (OPJ_INT16 )7424,      (OPJ_INT16 )7680,      (OPJ_INT16 )7936};
#line 48 "/root/patron/new_21/src/lib/openjp2/t1.c"
OPJ_BYTE opj_t1_getctxno_zc(OPJ_UINT32 f , OPJ_UINT32 orient ) ;
#line 49
OPJ_BYTE opj_t1_getctxno_sc(OPJ_UINT32 f ) ;
#line 50
OPJ_UINT32 opj_t1_getctxno_mag(OPJ_UINT32 f ) ;
#line 51
OPJ_BYTE opj_t1_getspb(OPJ_UINT32 f ) ;
#line 52
OPJ_INT16 opj_t1_getnmsedec_sig(OPJ_UINT32 x , OPJ_UINT32 bitpos ) ;
#line 53
OPJ_INT16 opj_t1_getnmsedec_ref(OPJ_UINT32 x , OPJ_UINT32 bitpos ) ;
#line 54
void opj_t1_updateflags(opj_flag_t *flagsp , OPJ_UINT32 s , OPJ_UINT32 stride ) ;
#line 58
void opj_t1_enc_sigpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_INT32 one ,
                             OPJ_INT32 *nmsedec , OPJ_BYTE type , OPJ_UINT32 vsc ) ;
#line 81
__inline static void opj_t1_dec_sigpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                                 OPJ_INT32 *datap , OPJ_INT32 orient ,
                                                 OPJ_INT32 oneplushalf , OPJ_INT32 vsc ) ;
#line 88
__inline void opj_t1_dec_sigpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 orient , OPJ_INT32 oneplushalf ) ;
#line 94
__inline void opj_t1_dec_sigpass_step_mqc_vsc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                              OPJ_INT32 *datap , OPJ_INT32 orient ,
                                              OPJ_INT32 oneplushalf , OPJ_INT32 vsc ) ;
#line 106
void opj_t1_enc_sigpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_UINT32 orient , OPJ_INT32 *nmsedec ,
                        OPJ_BYTE type , OPJ_UINT32 cblksty ) ;
#line 116
void opj_t1_dec_sigpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient , OPJ_INT32 cblksty ) ;
#line 121
void opj_t1_dec_sigpass_mqc(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ) ;
#line 125
void opj_t1_dec_sigpass_mqc_vsc(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ) ;
#line 135
void opj_t1_enc_refpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_INT32 bpno , OPJ_INT32 one , OPJ_INT32 *nmsedec ,
                             OPJ_BYTE type , OPJ_UINT32 vsc ) ;
#line 148
void opj_t1_enc_refpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 *nmsedec , OPJ_BYTE type ,
                        OPJ_UINT32 cblksty ) ;
#line 157
void opj_t1_dec_refpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 cblksty ) ;
#line 161
void opj_t1_dec_refpass_mqc(opj_t1_t *t1 , OPJ_INT32 bpno ) ;
#line 164
void opj_t1_dec_refpass_mqc_vsc(opj_t1_t *t1 , OPJ_INT32 bpno ) ;
#line 182
__inline void opj_t1_dec_refpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 poshalf , OPJ_INT32 neghalf ,
                                          OPJ_INT32 vsc ) ;
#line 189
__inline void opj_t1_dec_refpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 poshalf , OPJ_INT32 neghalf ) ;
#line 195
__inline void opj_t1_dec_refpass_step_mqc_vsc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                              OPJ_INT32 *datap , OPJ_INT32 poshalf ,
                                              OPJ_INT32 neghalf , OPJ_INT32 vsc ) ;
#line 208
void opj_t1_enc_clnpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_INT32 one ,
                             OPJ_INT32 *nmsedec , OPJ_UINT32 partial , OPJ_UINT32 vsc ) ;
#line 221
static void opj_t1_dec_clnpass_step_partial(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                            OPJ_INT32 orient , OPJ_INT32 oneplushalf ) ;
#line 227
static void opj_t1_dec_clnpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                    OPJ_INT32 orient , OPJ_INT32 oneplushalf ) ;
#line 233
static void opj_t1_dec_clnpass_step_vsc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                        OPJ_INT32 orient , OPJ_INT32 oneplushalf ,
                                        OPJ_INT32 partial , OPJ_INT32 vsc ) ;
#line 244
void opj_t1_enc_clnpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_UINT32 orient , OPJ_INT32 *nmsedec ,
                        OPJ_UINT32 cblksty ) ;
#line 253
static void opj_t1_dec_clnpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ,
                               OPJ_INT32 cblksty ) ;
#line 259
static OPJ_FLOAT64 opj_t1_getwmsedec(OPJ_INT32 nmsedec , OPJ_UINT32 compno , OPJ_UINT32 level ,
                                     OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_UINT32 qmfbid ,
                                     OPJ_FLOAT64 stepsize , OPJ_UINT32 numcomps ,
                                     OPJ_FLOAT64 *mct_norms ) ;
#line 270
void opj_t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , OPJ_UINT32 orient ,
                        OPJ_UINT32 compno , OPJ_UINT32 level , OPJ_UINT32 qmfbid ,
                        OPJ_FLOAT64 stepsize , OPJ_UINT32 cblksty , OPJ_UINT32 numcomps ,
                        opj_tcd_tile_t *tile , OPJ_FLOAT64 *mct_norms ) ;
#line 290
OPJ_BOOL opj_t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 orient ,
                            OPJ_UINT32 roishift , OPJ_UINT32 cblksty ) ;
#line 296
OPJ_BOOL opj_t1_allocate_buffers(opj_t1_t *t1 , OPJ_UINT32 w , OPJ_UINT32 h ) ;
#line 306 "/root/patron/new_21/src/lib/openjp2/t1.c"
OPJ_BYTE opj_t1_getctxno_zc(OPJ_UINT32 f , OPJ_UINT32 orient ) 
{ 


  {
#line 307
  return (lut_ctxno_zc[(orient << 8) | (f & 255U)]);
}
}
#line 310 "/root/patron/new_21/src/lib/openjp2/t1.c"
OPJ_BYTE opj_t1_getctxno_sc(OPJ_UINT32 f ) 
{ 


  {
#line 311
  return (lut_ctxno_sc[(f & 4080U) >> 4]);
}
}
#line 314 "/root/patron/new_21/src/lib/openjp2/t1.c"
OPJ_UINT32 opj_t1_getctxno_mag(OPJ_UINT32 f ) 
{ 
  OPJ_UINT32 tmp1 ;
  int tmp ;
  OPJ_UINT32 tmp2 ;
  unsigned int tmp___0 ;

  {
#line 315
  if (f & 255U) {
#line 315
    tmp = 15;
  } else {
#line 315
    tmp = 14;
  }
#line 315
  tmp1 = (OPJ_UINT32 )tmp;
#line 316
  if (f & 8192U) {
#line 316
    tmp___0 = (unsigned int )16;
  } else {
#line 316
    tmp___0 = tmp1;
  }
#line 316
  tmp2 = tmp___0;
#line 317
  return (tmp2);
}
}
#line 320 "/root/patron/new_21/src/lib/openjp2/t1.c"
OPJ_BYTE opj_t1_getspb(OPJ_UINT32 f ) 
{ 


  {
#line 321
  return (lut_spb[(f & 4080U) >> 4]);
}
}
#line 324 "/root/patron/new_21/src/lib/openjp2/t1.c"
OPJ_INT16 opj_t1_getnmsedec_sig(OPJ_UINT32 x , OPJ_UINT32 bitpos ) 
{ 


  {
#line 325
  if (bitpos > 6U) {
#line 326
    return (lut_nmsedec_sig[(x >> (bitpos - 6U)) & (unsigned int )((1 << 7) - 1)]);
  }
#line 329
  return (lut_nmsedec_sig0[x & (unsigned int )((1 << 7) - 1)]);
}
}
#line 332 "/root/patron/new_21/src/lib/openjp2/t1.c"
OPJ_INT16 opj_t1_getnmsedec_ref(OPJ_UINT32 x , OPJ_UINT32 bitpos ) 
{ 


  {
#line 333
  if (bitpos > 6U) {
#line 334
    return (lut_nmsedec_ref[(x >> (bitpos - 6U)) & (unsigned int )((1 << 7) - 1)]);
  }
#line 337
  return (lut_nmsedec_ref0[x & (unsigned int )((1 << 7) - 1)]);
}
}
#line 340 "/root/patron/new_21/src/lib/openjp2/t1.c"
void opj_t1_updateflags(opj_flag_t *flagsp , OPJ_UINT32 s , OPJ_UINT32 stride ) 
{ 
  opj_flag_t *np ;
  opj_flag_t *sp ;
  static opj_flag_t mod[8] ;

  {
#line 341
  np = flagsp - stride;
#line 342
  sp = flagsp + stride;
#line 344
  mod[0] = (opj_flag_t )64;
#line 344
  mod[1] = (opj_flag_t )1088;
#line 344
  mod[2] = (opj_flag_t )32;
#line 344
  mod[3] = (opj_flag_t )544;
#line 344
  mod[4] = (opj_flag_t )128;
#line 344
  mod[5] = (opj_flag_t )2176;
#line 344
  mod[6] = (opj_flag_t )16;
#line 344
  mod[7] = (opj_flag_t )272;
#line 351
  *(np + - 1) |= 2;
#line 352
  *(np + 0) |= (int )mod[s];
#line 353
  *(np + 1) |= 4;
#line 355
  *(flagsp + - 1) |= (int )mod[s + 2U];
#line 356
  *(flagsp + 0) |= 4096;
#line 357
  *(flagsp + 1) |= (int )mod[s + 4U];
#line 359
  *(sp + - 1) |= 1;
#line 360
  *(sp + 0) |= (int )mod[s + 6U];
#line 361
  *(sp + 1) |= 8;
  return;
}
}
#line 364 "/root/patron/new_21/src/lib/openjp2/t1.c"
void opj_t1_enc_sigpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_INT32 one ,
                             OPJ_INT32 *nmsedec , OPJ_BYTE type , OPJ_UINT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_UINT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 tmp ;
  OPJ_INT32 __cil_tmp14 ;
  int tmp___0 ;
  OPJ_BYTE __cil_tmp16 ;
  int tmp___1 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT16 __cil_tmp19 ;
  OPJ_BYTE __cil_tmp20 ;
  OPJ_BYTE __cil_tmp21 ;

  {
#line 378
  mqc = t1->mqc;
#line 380
  if (vsc) {
#line 380
    tmp = (OPJ_UINT32 )((int )*flagsp & -1095);
  } else {
#line 380
    tmp = (OPJ_UINT32 )*flagsp;
  }
#line 380
  flag = tmp;
#line 381
  if (flag & 255U) {
#line 381
    if (! (flag & 20480U)) {
      {
#line 382
      __cil_tmp14 = opj_int_abs(*datap);
      }
#line 382
      if (__cil_tmp14 & one) {
#line 382
        tmp___0 = 1;
      } else {
#line 382
        tmp___0 = 0;
      }
      {
#line 382
      v = tmp___0;
#line 383
      __cil_tmp16 = opj_t1_getctxno_zc(flag, orient);
#line 383
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp16];
      }
#line 384
      if ((int )type == 1) {
        {
#line 385
        opj_mqc_bypass_enc(mqc, (OPJ_UINT32 )v);
        }
      } else {
        {
#line 387
        opj_mqc_encode(mqc, (OPJ_UINT32 )v);
        }
      }
#line 389
      if (v) {
#line 390
        if (*datap < 0) {
#line 390
          tmp___1 = 1;
        } else {
#line 390
          tmp___1 = 0;
        }
        {
#line 390
        v = tmp___1;
#line 391
        __cil_tmp18 = opj_int_abs(*datap);
#line 391
        __cil_tmp19 = opj_t1_getnmsedec_sig((OPJ_UINT32 )__cil_tmp18, (OPJ_UINT32 )(bpno + 6));
        }
        {
#line 391
        *nmsedec += (int )__cil_tmp19;
#line 392
        __cil_tmp20 = opj_t1_getctxno_sc(flag);
#line 392
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp20];
        }
#line 393
        if ((int )type == 1) {
          {
#line 394
          opj_mqc_bypass_enc(mqc, (OPJ_UINT32 )v);
          }
        } else {
          {
#line 396
          __cil_tmp21 = opj_t1_getspb((OPJ_UINT32 )flag);
#line 396
          opj_mqc_encode(mqc, (OPJ_UINT32 )(v ^ (int )__cil_tmp21));
          }
        }
        {
#line 398
        opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
        }
      }
#line 400
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 405 "/root/patron/new_21/src/lib/openjp2/t1.c"
__inline static void opj_t1_dec_sigpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                                 OPJ_INT32 *datap , OPJ_INT32 orient ,
                                                 OPJ_INT32 oneplushalf , OPJ_INT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_raw_t *raw ;
  int tmp ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_INT32 tmp___0 ;

  {
#line 414
  raw = t1->raw;
#line 417
  if (vsc) {
#line 417
    tmp = (int )*flagsp & -1095;
  } else {
#line 417
    tmp = (int )*flagsp;
  }
#line 417
  flag = tmp;
#line 418
  if (flag & 255) {
#line 418
    if (! (flag & 20480)) {
      {
#line 419
      __cil_tmp11 = opj_raw_decode(raw);
      }
#line 419
      if (__cil_tmp11) {
        {
#line 420
        __cil_tmp12 = opj_raw_decode(raw);
#line 420
        v = (OPJ_INT32 )__cil_tmp12;
        }
#line 421
        if (v) {
#line 421
          tmp___0 = - oneplushalf;
        } else {
#line 421
          tmp___0 = oneplushalf;
        }
        {
#line 421
        *datap = tmp___0;
#line 422
        opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
        }
      }
#line 424
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 428 "/root/patron/new_21/src/lib/openjp2/t1.c"
__inline void opj_t1_dec_sigpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 orient , OPJ_INT32 oneplushalf ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_BYTE __cil_tmp9 ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_BYTE __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_BYTE __cil_tmp13 ;
  OPJ_INT32 tmp ;

  {
#line 437
  mqc = t1->mqc;
#line 439
  flag = (OPJ_INT32 )*flagsp;
#line 440
  if (flag & 255) {
#line 440
    if (! (flag & 20480)) {
      {
#line 441
      __cil_tmp9 = opj_t1_getctxno_zc((OPJ_UINT32 )flag, (OPJ_UINT32 )orient);
#line 441
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp9];
#line 442
      __cil_tmp10 = opj_mqc_decode(mqc);
      }
#line 442
      if (__cil_tmp10) {
        {
#line 443
        __cil_tmp11 = opj_t1_getctxno_sc((OPJ_UINT32 )flag);
#line 443
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp11];
#line 444
        __cil_tmp13 = opj_t1_getspb((OPJ_UINT32 )flag);
        }
        {
#line 444
        __cil_tmp12 = opj_mqc_decode(mqc);
#line 444
        v = __cil_tmp12 ^ (int )__cil_tmp13;
        }
#line 445
        if (v) {
#line 445
          tmp = - oneplushalf;
        } else {
#line 445
          tmp = oneplushalf;
        }
        {
#line 445
        *datap = tmp;
#line 446
        opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
        }
      }
#line 448
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 452 "/root/patron/new_21/src/lib/openjp2/t1.c"
__inline void opj_t1_dec_sigpass_step_mqc_vsc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                              OPJ_INT32 *datap , OPJ_INT32 orient ,
                                              OPJ_INT32 oneplushalf , OPJ_INT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  OPJ_BYTE __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_BYTE __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_BYTE __cil_tmp15 ;
  OPJ_INT32 tmp___0 ;

  {
#line 462
  mqc = t1->mqc;
#line 464
  if (vsc) {
#line 464
    tmp = (int )*flagsp & -1095;
  } else {
#line 464
    tmp = (int )*flagsp;
  }
#line 464
  flag = tmp;
#line 465
  if (flag & 255) {
#line 465
    if (! (flag & 20480)) {
      {
#line 466
      __cil_tmp11 = opj_t1_getctxno_zc((OPJ_UINT32 )flag, (OPJ_UINT32 )orient);
#line 466
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp11];
#line 467
      __cil_tmp12 = opj_mqc_decode(mqc);
      }
#line 467
      if (__cil_tmp12) {
        {
#line 468
        __cil_tmp13 = opj_t1_getctxno_sc((OPJ_UINT32 )flag);
#line 468
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp13];
#line 469
        __cil_tmp15 = opj_t1_getspb((OPJ_UINT32 )flag);
        }
        {
#line 469
        __cil_tmp14 = opj_mqc_decode(mqc);
#line 469
        v = __cil_tmp14 ^ (int )__cil_tmp15;
        }
#line 470
        if (v) {
#line 470
          tmp___0 = - oneplushalf;
        } else {
#line 470
          tmp___0 = oneplushalf;
        }
        {
#line 470
        *datap = tmp___0;
#line 471
        opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
        }
      }
#line 473
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 479 "/root/patron/new_21/src/lib/openjp2/t1.c"
void opj_t1_enc_sigpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_UINT32 orient , OPJ_INT32 *nmsedec ,
                        OPJ_BYTE type , OPJ_UINT32 cblksty ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 vsc ;
  OPJ_INT32 one ;
  int tmp ;

  {
#line 490
  *nmsedec = 0;
#line 491
  one = 1 << (bpno + 6);
#line 492
  k = (OPJ_UINT32 )0;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! (k < t1->h)) {
#line 492
      goto while_break;
    }
#line 493
    i = (OPJ_UINT32 )0;
    {
#line 493
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 493
      if (! (i < t1->w)) {
#line 493
        goto while_break___0;
      }
#line 494
      j = k;
      {
#line 494
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 494
        if (! (j < k + 4U && j < t1->h)) {
#line 494
          goto while_break___1;
        }
#line 495
        if (cblksty & 8U && (j == k + 3U || j == t1->h - 1U)) {
#line 495
          tmp = 1;
        } else {
#line 495
          tmp = 0;
        }
        {
#line 495
        vsc = (OPJ_UINT32 )tmp;
#line 496
        opj_t1_enc_sigpass_step(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                t1->data + (j * t1->w + i), orient, bpno, one, nmsedec,
                                type, vsc);
        }
#line 494
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 493
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 492
    k += (unsigned int )4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 511 "/root/patron/new_21/src/lib/openjp2/t1.c"
void opj_t1_dec_sigpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient , OPJ_INT32 cblksty ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_INT32 vsc ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  int tmp ;

  {
#line 519
  one = 1 << bpno;
#line 520
  half = one >> 1;
#line 521
  oneplushalf = one | half;
#line 522
  k = (OPJ_UINT32 )0;
  {
#line 522
  while (1) {
    while_continue: /* CIL Label */ ;
#line 522
    if (! (k < t1->h)) {
#line 522
      goto while_break;
    }
#line 523
    i = (OPJ_UINT32 )0;
    {
#line 523
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 523
      if (! (i < t1->w)) {
#line 523
        goto while_break___0;
      }
#line 524
      j = k;
      {
#line 524
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 524
        if (! (j < k + 4U && j < t1->h)) {
#line 524
          goto while_break___1;
        }
#line 525
        if (cblksty & 8 && (j == k + 3U || j == t1->h - 1U)) {
#line 525
          tmp = 1;
        } else {
#line 525
          tmp = 0;
        }
        {
#line 525
        vsc = tmp;
#line 526
        opj_t1_dec_sigpass_step_raw(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                    t1->data + (j * t1->w + i), orient, oneplushalf,
                                    vsc);
        }
#line 524
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 523
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 522
    k += (unsigned int )4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 538 "/root/patron/new_21/src/lib/openjp2/t1.c"
void opj_t1_dec_sigpass_mqc(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 *data1 ;
  opj_flag_t *flags1 ;
  OPJ_INT32 *data2 ;
  opj_flag_t *flags2 ;
  OPJ_INT32 *data2___0 ;
  opj_flag_t *flags2___0 ;

  {
#line 545
  data1 = t1->data;
#line 546
  flags1 = t1->flags + 1;
#line 547
  one = 1 << bpno;
#line 548
  half = one >> 1;
#line 549
  oneplushalf = one | half;
#line 550
  k = (OPJ_UINT32 )0;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    if (! (k < (t1->h & 4294967292U))) {
#line 550
      goto while_break;
    }
#line 551
    i = (OPJ_UINT32 )0;
    {
#line 551
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 551
      if (! (i < t1->w)) {
#line 551
        goto while_break___0;
      }
      {
#line 552
      data2 = data1 + i;
#line 553
      flags2 = flags1 + i;
#line 554
      flags2 += t1->flags_stride;
#line 555
      opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 556
      data2 += t1->w;
#line 557
      flags2 += t1->flags_stride;
#line 558
      opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 559
      data2 += t1->w;
#line 560
      flags2 += t1->flags_stride;
#line 561
      opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 562
      data2 += t1->w;
#line 563
      flags2 += t1->flags_stride;
#line 564
      opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 565
      data2 += t1->w;
      }
#line 551
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 567
    data1 += t1->w << 2;
#line 568
    flags1 += t1->flags_stride << 2;
#line 550
    k += (unsigned int )4;
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  i = (OPJ_UINT32 )0;
  {
#line 570
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 570
    if (! (i < t1->w)) {
#line 570
      goto while_break___1;
    }
#line 571
    data2___0 = data1 + i;
#line 572
    flags2___0 = flags1 + i;
#line 573
    j = k;
    {
#line 573
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 573
      if (! (j < t1->h)) {
#line 573
        goto while_break___2;
      }
      {
#line 574
      flags2___0 += t1->flags_stride;
#line 575
      opj_t1_dec_sigpass_step_mqc(t1, flags2___0, data2___0, orient, oneplushalf);
#line 576
      data2___0 += t1->w;
      }
#line 573
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 570
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 581 "/root/patron/new_21/src/lib/openjp2/t1.c"
void opj_t1_dec_sigpass_mqc_vsc(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_INT32 vsc ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  int tmp ;

  {
#line 588
  one = 1 << bpno;
#line 589
  half = one >> 1;
#line 590
  oneplushalf = one | half;
#line 591
  k = (OPJ_UINT32 )0;
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
#line 591
    if (! (k < t1->h)) {
#line 591
      goto while_break;
    }
#line 592
    i = (OPJ_UINT32 )0;
    {
#line 592
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 592
      if (! (i < t1->w)) {
#line 592
        goto while_break___0;
      }
#line 593
      j = k;
      {
#line 593
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 593
        if (! (j < k + 4U && j < t1->h)) {
#line 593
          goto while_break___1;
        }
#line 594
        if (j == k + 3U || j == t1->h - 1U) {
#line 594
          tmp = 1;
        } else {
#line 594
          tmp = 0;
        }
        {
#line 594
        vsc = tmp;
#line 595
        opj_t1_dec_sigpass_step_mqc_vsc(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                        t1->data + (j * t1->w + i), orient, oneplushalf,
                                        vsc);
        }
#line 593
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 592
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 591
    k += (unsigned int )4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 609 "/root/patron/new_21/src/lib/openjp2/t1.c"
void opj_t1_enc_refpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_INT32 bpno , OPJ_INT32 one , OPJ_INT32 *nmsedec ,
                             OPJ_BYTE type , OPJ_UINT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_UINT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 tmp ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT16 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  int tmp___0 ;
  OPJ_UINT32 __cil_tmp17 ;

  {
#line 621
  mqc = t1->mqc;
#line 623
  if (vsc) {
#line 623
    tmp = (OPJ_UINT32 )((int )*flagsp & -1095);
  } else {
#line 623
    tmp = (OPJ_UINT32 )*flagsp;
  }
#line 623
  flag = tmp;
#line 624
  if ((flag & 20480U) == 4096U) {
    {
#line 625
    __cil_tmp13 = opj_int_abs(*datap);
#line 625
    __cil_tmp14 = opj_t1_getnmsedec_ref((OPJ_UINT32 )__cil_tmp13, (OPJ_UINT32 )(bpno + 6));
    }
    {
#line 625
    *nmsedec += (int )__cil_tmp14;
#line 626
    __cil_tmp15 = opj_int_abs(*datap);
    }
#line 626
    if (__cil_tmp15 & one) {
#line 626
      tmp___0 = 1;
    } else {
#line 626
      tmp___0 = 0;
    }
    {
#line 626
    v = tmp___0;
#line 627
    __cil_tmp17 = opj_t1_getctxno_mag(flag);
#line 627
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp17];
    }
#line 628
    if ((int )type == 1) {
      {
#line 629
      opj_mqc_bypass_enc(mqc, (OPJ_UINT32 )v);
      }
    } else {
      {
#line 631
      opj_mqc_encode(mqc, (OPJ_UINT32 )v);
      }
    }
#line 633
    *flagsp |= 8192;
  }
  return;
}
}
#line 637 "/root/patron/new_21/src/lib/openjp2/t1.c"
__inline void opj_t1_dec_refpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 poshalf , OPJ_INT32 neghalf ,
                                          OPJ_INT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 t ;
  OPJ_INT32 flag ;
  opj_raw_t *raw ;
  int tmp ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 tmp___1 ;

  {
#line 647
  raw = t1->raw;
#line 649
  if (vsc) {
#line 649
    tmp = (int )*flagsp & -1095;
  } else {
#line 649
    tmp = (int )*flagsp;
  }
#line 649
  flag = tmp;
#line 650
  if ((flag & 20480) == 4096) {
    {
#line 651
    __cil_tmp12 = opj_raw_decode(raw);
#line 651
    v = (OPJ_INT32 )__cil_tmp12;
    }
#line 652
    if (v) {
#line 652
      tmp___0 = poshalf;
    } else {
#line 652
      tmp___0 = neghalf;
    }
#line 652
    t = tmp___0;
#line 653
    if (*datap < 0) {
#line 653
      tmp___1 = - t;
    } else {
#line 653
      tmp___1 = t;
    }
#line 653
    *datap += tmp___1;
#line 654
    *flagsp |= 8192;
  }
  return;
}
}
#line 658 "/root/patron/new_21/src/lib/openjp2/t1.c"
__inline void opj_t1_dec_refpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 poshalf , OPJ_INT32 neghalf ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 t ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_INT32 __cil_tmp11 ;
  OPJ_INT32 tmp ;
  OPJ_INT32 tmp___0 ;

  {
#line 667
  mqc = t1->mqc;
#line 669
  flag = (OPJ_INT32 )*flagsp;
#line 670
  if ((flag & 20480) == 4096) {
    {
#line 671
    __cil_tmp10 = opj_t1_getctxno_mag((OPJ_UINT32 )flag);
#line 671
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp10];
#line 672
    v = opj_mqc_decode(mqc);
    }
#line 673
    if (v) {
#line 673
      tmp = poshalf;
    } else {
#line 673
      tmp = neghalf;
    }
#line 673
    t = tmp;
#line 674
    if (*datap < 0) {
#line 674
      tmp___0 = - t;
    } else {
#line 674
      tmp___0 = t;
    }
#line 674
    *datap += tmp___0;
#line 675
    *flagsp |= 8192;
  }
  return;
}
}
#line 679 "/root/patron/new_21/src/lib/openjp2/t1.c"
__inline void opj_t1_dec_refpass_step_mqc_vsc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                              OPJ_INT32 *datap , OPJ_INT32 poshalf ,
                                              OPJ_INT32 neghalf , OPJ_INT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 t ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 tmp___1 ;

  {
#line 689
  mqc = t1->mqc;
#line 691
  if (vsc) {
#line 691
    tmp = (int )*flagsp & -1095;
  } else {
#line 691
    tmp = (int )*flagsp;
  }
#line 691
  flag = tmp;
#line 692
  if ((flag & 20480) == 4096) {
    {
#line 693
    __cil_tmp12 = opj_t1_getctxno_mag((OPJ_UINT32 )flag);
#line 693
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp12];
#line 694
    v = opj_mqc_decode(mqc);
    }
#line 695
    if (v) {
#line 695
      tmp___0 = poshalf;
    } else {
#line 695
      tmp___0 = neghalf;
    }
#line 695
    t = tmp___0;
#line 696
    if (*datap < 0) {
#line 696
      tmp___1 = - t;
    } else {
#line 696
      tmp___1 = t;
    }
#line 696
    *datap += tmp___1;
#line 697
    *flagsp |= 8192;
  }
  return;
}
}
#line 702 "/root/patron/new_21/src/lib/openjp2/t1.c"
void opj_t1_enc_refpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 *nmsedec , OPJ_BYTE type ,
                        OPJ_UINT32 cblksty ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 vsc ;
  OPJ_INT32 one ;
  int tmp ;

  {
#line 712
  *nmsedec = 0;
#line 713
  one = 1 << (bpno + 6);
#line 714
  k = (OPJ_UINT32 )0;
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;
#line 714
    if (! (k < t1->h)) {
#line 714
      goto while_break;
    }
#line 715
    i = (OPJ_UINT32 )0;
    {
#line 715
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 715
      if (! (i < t1->w)) {
#line 715
        goto while_break___0;
      }
#line 716
      j = k;
      {
#line 716
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 716
        if (! (j < k + 4U && j < t1->h)) {
#line 716
          goto while_break___1;
        }
#line 717
        if (cblksty & 8U && (j == k + 3U || j == t1->h - 1U)) {
#line 717
          tmp = 1;
        } else {
#line 717
          tmp = 0;
        }
        {
#line 717
        vsc = (OPJ_UINT32 )tmp;
#line 718
        opj_t1_enc_refpass_step(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                t1->data + (j * t1->w + i), bpno, one, nmsedec, type,
                                vsc);
        }
#line 716
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 715
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 714
    k += (unsigned int )4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 732 "/root/patron/new_21/src/lib/openjp2/t1.c"
void opj_t1_dec_refpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 cblksty ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 poshalf ;
  OPJ_INT32 neghalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 vsc ;
  OPJ_INT32 tmp ;
  int tmp___0 ;

  {
#line 740
  one = 1 << bpno;
#line 741
  poshalf = one >> 1;
#line 742
  if (bpno > 0) {
#line 742
    tmp = - poshalf;
  } else {
#line 742
    tmp = - 1;
  }
#line 742
  neghalf = tmp;
#line 743
  k = (OPJ_UINT32 )0;
  {
#line 743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 743
    if (! (k < t1->h)) {
#line 743
      goto while_break;
    }
#line 744
    i = (OPJ_UINT32 )0;
    {
#line 744
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 744
      if (! (i < t1->w)) {
#line 744
        goto while_break___0;
      }
#line 745
      j = k;
      {
#line 745
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 745
        if (! (j < k + 4U && j < t1->h)) {
#line 745
          goto while_break___1;
        }
#line 746
        if (cblksty & 8 && (j == k + 3U || j == t1->h - 1U)) {
#line 746
          tmp___0 = 1;
        } else {
#line 746
          tmp___0 = 0;
        }
        {
#line 746
        vsc = tmp___0;
#line 747
        opj_t1_dec_refpass_step_raw(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                    t1->data + (j * t1->w + i), poshalf, neghalf,
                                    vsc);
        }
#line 745
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 744
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 743
    k += (unsigned int )4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 759 "/root/patron/new_21/src/lib/openjp2/t1.c"
void opj_t1_dec_refpass_mqc(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 poshalf ;
  OPJ_INT32 neghalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 *data1 ;
  opj_flag_t *flags1 ;
  OPJ_INT32 tmp ;
  OPJ_INT32 *data2 ;
  opj_flag_t *flags2 ;
  OPJ_INT32 *data2___0 ;
  opj_flag_t *flags2___0 ;

  {
#line 765
  data1 = t1->data;
#line 766
  flags1 = t1->flags + 1;
#line 767
  one = 1 << bpno;
#line 768
  poshalf = one >> 1;
#line 769
  if (bpno > 0) {
#line 769
    tmp = - poshalf;
  } else {
#line 769
    tmp = - 1;
  }
#line 769
  neghalf = tmp;
#line 770
  k = (OPJ_UINT32 )0;
  {
#line 770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 770
    if (! (k < (t1->h & 4294967292U))) {
#line 770
      goto while_break;
    }
#line 771
    i = (OPJ_UINT32 )0;
    {
#line 771
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 771
      if (! (i < t1->w)) {
#line 771
        goto while_break___0;
      }
      {
#line 772
      data2 = data1 + i;
#line 773
      flags2 = flags1 + i;
#line 774
      flags2 += t1->flags_stride;
#line 775
      opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 776
      data2 += t1->w;
#line 777
      flags2 += t1->flags_stride;
#line 778
      opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 779
      data2 += t1->w;
#line 780
      flags2 += t1->flags_stride;
#line 781
      opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 782
      data2 += t1->w;
#line 783
      flags2 += t1->flags_stride;
#line 784
      opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 785
      data2 += t1->w;
      }
#line 771
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 787
    data1 += t1->w << 2;
#line 788
    flags1 += t1->flags_stride << 2;
#line 770
    k += (unsigned int )4;
  }
  while_break: /* CIL Label */ ;
  }
#line 790
  i = (OPJ_UINT32 )0;
  {
#line 790
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 790
    if (! (i < t1->w)) {
#line 790
      goto while_break___1;
    }
#line 791
    data2___0 = data1 + i;
#line 792
    flags2___0 = flags1 + i;
#line 793
    j = k;
    {
#line 793
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 793
      if (! (j < t1->h)) {
#line 793
        goto while_break___2;
      }
      {
#line 794
      flags2___0 += t1->flags_stride;
#line 795
      opj_t1_dec_refpass_step_mqc(t1, flags2___0, data2___0, poshalf, neghalf);
#line 796
      data2___0 += t1->w;
      }
#line 793
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 790
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 801 "/root/patron/new_21/src/lib/openjp2/t1.c"
void opj_t1_dec_refpass_mqc_vsc(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 poshalf ;
  OPJ_INT32 neghalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 vsc ;
  OPJ_INT32 tmp ;
  int tmp___0 ;

  {
#line 808
  one = 1 << bpno;
#line 809
  poshalf = one >> 1;
#line 810
  if (bpno > 0) {
#line 810
    tmp = - poshalf;
  } else {
#line 810
    tmp = - 1;
  }
#line 810
  neghalf = tmp;
#line 811
  k = (OPJ_UINT32 )0;
  {
#line 811
  while (1) {
    while_continue: /* CIL Label */ ;
#line 811
    if (! (k < t1->h)) {
#line 811
      goto while_break;
    }
#line 812
    i = (OPJ_UINT32 )0;
    {
#line 812
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 812
      if (! (i < t1->w)) {
#line 812
        goto while_break___0;
      }
#line 813
      j = k;
      {
#line 813
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 813
        if (! (j < k + 4U && j < t1->h)) {
#line 813
          goto while_break___1;
        }
#line 814
        if (j == k + 3U || j == t1->h - 1U) {
#line 814
          tmp___0 = 1;
        } else {
#line 814
          tmp___0 = 0;
        }
        {
#line 814
        vsc = tmp___0;
#line 815
        opj_t1_dec_refpass_step_mqc_vsc(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                        t1->data + (j * t1->w + i), poshalf, neghalf,
                                        vsc);
        }
#line 813
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 812
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 811
    k += (unsigned int )4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 828 "/root/patron/new_21/src/lib/openjp2/t1.c"
void opj_t1_enc_clnpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_INT32 one ,
                             OPJ_INT32 *nmsedec , OPJ_UINT32 partial , OPJ_UINT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_UINT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 tmp ;
  OPJ_BYTE __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  int tmp___0 ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_INT16 __cil_tmp18 ;
  OPJ_BYTE __cil_tmp19 ;
  int tmp___1 ;
  OPJ_BYTE __cil_tmp21 ;

  {
#line 842
  mqc = t1->mqc;
#line 844
  if (vsc) {
#line 844
    tmp = (OPJ_UINT32 )((int )*flagsp & -1095);
  } else {
#line 844
    tmp = (OPJ_UINT32 )*flagsp;
  }
#line 844
  flag = tmp;
#line 845
  if (partial) {
#line 846
    goto LABEL_PARTIAL;
  }
#line 848
  if (! ((int )*flagsp & 20480)) {
    {
#line 849
    __cil_tmp14 = opj_t1_getctxno_zc(flag, orient);
#line 849
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp14];
#line 850
    __cil_tmp15 = opj_int_abs(*datap);
    }
#line 850
    if (__cil_tmp15 & one) {
#line 850
      tmp___0 = 1;
    } else {
#line 850
      tmp___0 = 0;
    }
    {
#line 850
    v = tmp___0;
#line 851
    opj_mqc_encode(mqc, (OPJ_UINT32 )v);
    }
#line 852
    if (v) {
      LABEL_PARTIAL: 
      {
#line 854
      __cil_tmp17 = opj_int_abs(*datap);
#line 854
      __cil_tmp18 = opj_t1_getnmsedec_sig((OPJ_UINT32 )__cil_tmp17, (OPJ_UINT32 )(bpno + 6));
      }
      {
#line 854
      *nmsedec += (int )__cil_tmp18;
#line 855
      __cil_tmp19 = opj_t1_getctxno_sc(flag);
#line 855
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp19];
      }
#line 856
      if (*datap < 0) {
#line 856
        tmp___1 = 1;
      } else {
#line 856
        tmp___1 = 0;
      }
      {
#line 856
      v = tmp___1;
#line 857
      __cil_tmp21 = opj_t1_getspb((OPJ_UINT32 )flag);
#line 857
      opj_mqc_encode(mqc, (OPJ_UINT32 )(v ^ (int )__cil_tmp21));
#line 858
      opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
      }
    }
  }
#line 861
  *flagsp &= ~ 16384;
  return;
}
}
#line 864 "/root/patron/new_21/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass_step_partial(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                            OPJ_INT32 orient , OPJ_INT32 oneplushalf ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_BYTE __cil_tmp9 ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_BYTE __cil_tmp11 ;
  OPJ_INT32 tmp ;

  {
  {
#line 872
  mqc = t1->mqc;
#line 876
  flag = (OPJ_INT32 )*flagsp;
#line 877
  __cil_tmp9 = opj_t1_getctxno_sc((OPJ_UINT32 )flag);
#line 877
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp9];
#line 878
  __cil_tmp11 = opj_t1_getspb((OPJ_UINT32 )flag);
  }
  {
#line 878
  __cil_tmp10 = opj_mqc_decode(mqc);
#line 878
  v = __cil_tmp10 ^ (int )__cil_tmp11;
  }
#line 879
  if (v) {
#line 879
    tmp = - oneplushalf;
  } else {
#line 879
    tmp = oneplushalf;
  }
  {
#line 879
  *datap = tmp;
#line 880
  opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
#line 881
  *flagsp &= ~ 16384;
  }
  return;
}
}
#line 884 "/root/patron/new_21/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                    OPJ_INT32 orient , OPJ_INT32 oneplushalf ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_BYTE __cil_tmp9 ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_BYTE __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_BYTE __cil_tmp13 ;
  OPJ_INT32 tmp ;

  {
#line 893
  mqc = t1->mqc;
#line 895
  flag = (OPJ_INT32 )*flagsp;
#line 896
  if (! (flag & 20480)) {
    {
#line 897
    __cil_tmp9 = opj_t1_getctxno_zc((OPJ_UINT32 )flag, (OPJ_UINT32 )orient);
#line 897
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp9];
#line 898
    __cil_tmp10 = opj_mqc_decode(mqc);
    }
#line 898
    if (__cil_tmp10) {
      {
#line 899
      __cil_tmp11 = opj_t1_getctxno_sc((OPJ_UINT32 )flag);
#line 899
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp11];
#line 900
      __cil_tmp13 = opj_t1_getspb((OPJ_UINT32 )flag);
      }
      {
#line 900
      __cil_tmp12 = opj_mqc_decode(mqc);
#line 900
      v = __cil_tmp12 ^ (int )__cil_tmp13;
      }
#line 901
      if (v) {
#line 901
        tmp = - oneplushalf;
      } else {
#line 901
        tmp = oneplushalf;
      }
      {
#line 901
      *datap = tmp;
#line 902
      opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
      }
    }
  }
#line 905
  *flagsp &= ~ 16384;
  return;
}
}
#line 908 "/root/patron/new_21/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass_step_vsc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                        OPJ_INT32 orient , OPJ_INT32 oneplushalf ,
                                        OPJ_INT32 partial , OPJ_INT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  OPJ_BYTE __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_BYTE __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_BYTE __cil_tmp16 ;
  OPJ_INT32 tmp___0 ;

  {
#line 919
  mqc = t1->mqc;
#line 921
  if (vsc) {
#line 921
    tmp = (int )*flagsp & -1095;
  } else {
#line 921
    tmp = (int )*flagsp;
  }
#line 921
  flag = tmp;
#line 922
  if (partial) {
#line 923
    goto LABEL_PARTIAL;
  }
#line 925
  if (! (flag & 20480)) {
    {
#line 926
    __cil_tmp12 = opj_t1_getctxno_zc((OPJ_UINT32 )flag, (OPJ_UINT32 )orient);
#line 926
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp12];
#line 927
    __cil_tmp13 = opj_mqc_decode(mqc);
    }
#line 927
    if (__cil_tmp13) {
      LABEL_PARTIAL: 
      {
#line 929
      __cil_tmp14 = opj_t1_getctxno_sc((OPJ_UINT32 )flag);
#line 929
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp14];
      }
      {
#line 930
      __cil_tmp16 = opj_t1_getspb((OPJ_UINT32 )flag);
      }
      {
#line 930
      __cil_tmp15 = opj_mqc_decode(mqc);
#line 930
      v = __cil_tmp15 ^ (int )__cil_tmp16;
      }
#line 931
      if (v) {
#line 931
        tmp___0 = - oneplushalf;
      } else {
#line 931
        tmp___0 = oneplushalf;
      }
      {
#line 931
      *datap = tmp___0;
#line 932
      opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
      }
    }
  }
#line 935
  *flagsp &= ~ 16384;
  return;
}
}
#line 938 "/root/patron/new_21/src/lib/openjp2/t1.c"
void opj_t1_enc_clnpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_UINT32 orient , OPJ_INT32 *nmsedec ,
                        OPJ_UINT32 cblksty ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 one ;
  OPJ_UINT32 agg ;
  OPJ_UINT32 runlen ;
  OPJ_UINT32 vsc ;
  opj_mqc_t *mqc ;
  OPJ_INT32 __cil_tmp14 ;
  int tmp ;

  {
#line 949
  mqc = t1->mqc;
#line 951
  *nmsedec = 0;
#line 952
  one = 1 << (bpno + 6);
#line 953
  k = (OPJ_UINT32 )0;
  {
#line 953
  while (1) {
    while_continue: /* CIL Label */ ;
#line 953
    if (! (k < t1->h)) {
#line 953
      goto while_break;
    }
#line 954
    i = (OPJ_UINT32 )0;
    {
#line 954
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 954
      if (! (i < t1->w)) {
#line 954
        goto while_break___0;
      }
#line 955
      if (k + 3U < t1->h) {
#line 956
        if (cblksty & 8U) {
#line 957
          agg = (OPJ_UINT32 )(! ((((int )*(t1->flags + ((1U + k) * t1->flags_stride + (1U + i))) & 20735 || (int )*(t1->flags + (((1U + k) + 1U) * t1->flags_stride + (1U + i))) & 20735) || (int )*(t1->flags + (((1U + k) + 2U) * t1->flags_stride + (1U + i))) & 20735) || ((int )*(t1->flags + (((1U + k) + 3U) * t1->flags_stride + (1U + i))) & -1095) & 20735));
        } else {
#line 963
          agg = (OPJ_UINT32 )(! ((((int )*(t1->flags + ((1U + k) * t1->flags_stride + (1U + i))) & 20735 || (int )*(t1->flags + (((1U + k) + 1U) * t1->flags_stride + (1U + i))) & 20735) || (int )*(t1->flags + (((1U + k) + 2U) * t1->flags_stride + (1U + i))) & 20735) || (int )*(t1->flags + (((1U + k) + 3U) * t1->flags_stride + (1U + i))) & 20735));
        }
      } else {
#line 969
        agg = (OPJ_UINT32 )0;
      }
#line 971
      if (agg) {
#line 972
        runlen = (OPJ_UINT32 )0;
        {
#line 972
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 972
          if (! (runlen < 4U)) {
#line 972
            goto while_break___1;
          }
          {
#line 973
          __cil_tmp14 = opj_int_abs(*(t1->data + ((k + runlen) * t1->w + i)));
          }
#line 973
          if (__cil_tmp14 & one) {
#line 974
            goto while_break___1;
          }
#line 972
          runlen ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 976
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )17];
#line 977
        opj_mqc_encode(mqc, runlen != 4U);
        }
#line 978
        if (runlen == 4U) {
#line 979
          goto while_continue___0;
        }
        {
#line 981
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 982
        opj_mqc_encode(mqc, runlen >> 1);
#line 983
        opj_mqc_encode(mqc, runlen & 1U);
        }
      } else {
#line 985
        runlen = (OPJ_UINT32 )0;
      }
#line 987
      j = k + runlen;
      {
#line 987
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 987
        if (! (j < k + 4U && j < t1->h)) {
#line 987
          goto while_break___2;
        }
#line 988
        if (cblksty & 8U && (j == k + 3U || j == t1->h - 1U)) {
#line 988
          tmp = 1;
        } else {
#line 988
          tmp = 0;
        }
        {
#line 988
        vsc = (OPJ_UINT32 )tmp;
#line 989
        opj_t1_enc_clnpass_step(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                t1->data + (j * t1->w + i), orient, bpno, one, nmsedec,
                                agg && j == k + runlen, vsc);
        }
#line 987
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 954
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 953
    k += (unsigned int )4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1004 "/root/patron/new_21/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ,
                               OPJ_INT32 cblksty ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_INT32 agg ;
  OPJ_INT32 runlen ;
  OPJ_INT32 vsc ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 segsym ;
  opj_mqc_t *mqc ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;
  int tmp ;
  OPJ_INT32 *data1 ;
  opj_flag_t *flags1 ;
  OPJ_INT32 *data2 ;
  opj_flag_t *flags2 ;
  OPJ_INT32 __cil_tmp24 ;
  OPJ_INT32 __cil_tmp25 ;
  OPJ_INT32 __cil_tmp26 ;
  OPJ_INT32 *data2___0 ;
  opj_flag_t *flags2___0 ;
  OPJ_INT32 v ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_INT32 __cil_tmp32 ;
  OPJ_INT32 __cil_tmp33 ;

  {
#line 1012
  segsym = cblksty & 32;
#line 1014
  mqc = t1->mqc;
#line 1016
  one = 1 << bpno;
#line 1017
  half = one >> 1;
#line 1018
  oneplushalf = one | half;
#line 1019
  if (cblksty & 8) {
#line 1020
    k = (OPJ_UINT32 )0;
    {
#line 1020
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1020
      if (! (k < t1->h)) {
#line 1020
        goto while_break;
      }
#line 1021
      i = (OPJ_UINT32 )0;
      {
#line 1021
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1021
        if (! (i < t1->w)) {
#line 1021
          goto while_break___0;
        }
#line 1022
        if (k + 3U < t1->h) {
#line 1023
          agg = ! ((((int )*(t1->flags + ((1U + k) * t1->flags_stride + (1U + i))) & 20735 || (int )*(t1->flags + (((1U + k) + 1U) * t1->flags_stride + (1U + i))) & 20735) || (int )*(t1->flags + (((1U + k) + 2U) * t1->flags_stride + (1U + i))) & 20735) || ((int )*(t1->flags + (((1U + k) + 3U) * t1->flags_stride + (1U + i))) & -1095) & 20735);
        } else {
#line 1029
          agg = 0;
        }
#line 1031
        if (agg) {
          {
#line 1032
          mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )17];
#line 1033
          __cil_tmp16 = opj_mqc_decode(mqc);
          }
#line 1033
          if (! __cil_tmp16) {
#line 1034
            goto while_continue___0;
          }
          {
#line 1036
          mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 1037
          runlen = opj_mqc_decode(mqc);
#line 1038
          __cil_tmp18 = opj_mqc_decode(mqc);
#line 1038
          runlen = (runlen << 1) | __cil_tmp18;
          }
        } else {
#line 1040
          runlen = 0;
        }
#line 1042
        j = k + (OPJ_UINT32 )runlen;
        {
#line 1042
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1042
          if (! (j < k + 4U && j < t1->h)) {
#line 1042
            goto while_break___1;
          }
#line 1043
          if (j == k + 3U || j == t1->h - 1U) {
#line 1043
            tmp = 1;
          } else {
#line 1043
            tmp = 0;
          }
          {
#line 1043
          vsc = tmp;
#line 1044
          opj_t1_dec_clnpass_step_vsc(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                      t1->data + (j * t1->w + i), orient, oneplushalf,
                                      agg && j == k + (OPJ_UINT32 )runlen, vsc);
          }
#line 1042
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1021
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1020
      k += (unsigned int )4;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1056
    data1 = t1->data;
#line 1057
    flags1 = t1->flags + 1;
#line 1058
    k = (OPJ_UINT32 )0;
    {
#line 1058
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1058
      if (! (k < (t1->h & 4294967292U))) {
#line 1058
        goto while_break___2;
      }
#line 1059
      i = (OPJ_UINT32 )0;
      {
#line 1059
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1059
        if (! (i < t1->w)) {
#line 1059
          goto while_break___3;
        }
#line 1060
        data2 = data1 + i;
#line 1061
        flags2 = flags1 + i;
#line 1062
        agg = ! ((((int )*(t1->flags + ((1U + k) * t1->flags_stride + (1U + i))) & 20735 || (int )*(t1->flags + (((1U + k) + 1U) * t1->flags_stride + (1U + i))) & 20735) || (int )*(t1->flags + (((1U + k) + 2U) * t1->flags_stride + (1U + i))) & 20735) || (int )*(t1->flags + (((1U + k) + 3U) * t1->flags_stride + (1U + i))) & 20735);
#line 1066
        if (agg) {
          {
#line 1067
          mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )17];
#line 1068
          __cil_tmp24 = opj_mqc_decode(mqc);
          }
#line 1068
          if (! __cil_tmp24) {
#line 1069
            goto while_continue___3;
          }
          {
#line 1071
          mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 1072
          runlen = opj_mqc_decode(mqc);
#line 1073
          __cil_tmp26 = opj_mqc_decode(mqc);
#line 1073
          runlen = (runlen << 1) | __cil_tmp26;
#line 1074
          flags2 += (OPJ_UINT32 )runlen * t1->flags_stride;
#line 1075
          data2 += (OPJ_UINT32 )runlen * t1->w;
#line 1076
          j = k + (OPJ_UINT32 )runlen;
          }
          {
#line 1076
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1076
            if (! (j < k + 4U && j < t1->h)) {
#line 1076
              goto while_break___4;
            }
#line 1077
            flags2 += t1->flags_stride;
#line 1078
            if (agg) {
#line 1078
              if (j == k + (OPJ_UINT32 )runlen) {
                {
#line 1079
                opj_t1_dec_clnpass_step_partial(t1, flags2, data2, orient, oneplushalf);
                }
              } else {
                {
                {
#line 1081
                opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
                }
                }
              }
            } else {
              {
              {
#line 1081
              opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
              }
              }
            }
#line 1083
            data2 += t1->w;
#line 1076
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
          {
#line 1086
          flags2 += t1->flags_stride;
#line 1087
          opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1088
          data2 += t1->w;
#line 1089
          flags2 += t1->flags_stride;
#line 1090
          opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1091
          data2 += t1->w;
#line 1092
          flags2 += t1->flags_stride;
#line 1093
          opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1094
          data2 += t1->w;
#line 1095
          flags2 += t1->flags_stride;
#line 1096
          opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1097
          data2 += t1->w;
          }
        }
#line 1059
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1100
      data1 += t1->w << 2;
#line 1101
      flags1 += t1->flags_stride << 2;
#line 1058
      k += (unsigned int )4;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1103
    i = (OPJ_UINT32 )0;
    {
#line 1103
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1103
      if (! (i < t1->w)) {
#line 1103
        goto while_break___5;
      }
#line 1104
      data2___0 = data1 + i;
#line 1105
      flags2___0 = flags1 + i;
#line 1106
      j = k;
      {
#line 1106
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1106
        if (! (j < t1->h)) {
#line 1106
          goto while_break___6;
        }
        {
#line 1107
        flags2___0 += t1->flags_stride;
#line 1108
        opj_t1_dec_clnpass_step(t1, flags2___0, data2___0, orient, oneplushalf);
#line 1109
        data2___0 += t1->w;
        }
#line 1106
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1103
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1114
  if (segsym) {
    {
#line 1115
    v = 0;
#line 1116
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 1117
    v = opj_mqc_decode(mqc);
#line 1118
    __cil_tmp31 = opj_mqc_decode(mqc);
#line 1118
    v = (v << 1) | __cil_tmp31;
#line 1119
    __cil_tmp32 = opj_mqc_decode(mqc);
#line 1119
    v = (v << 1) | __cil_tmp32;
#line 1120
    __cil_tmp33 = opj_mqc_decode(mqc);
#line 1120
    v = (v << 1) | __cil_tmp33;
    }
  }
  return;
}
}
#line 1131 "/root/patron/new_21/src/lib/openjp2/t1.c"
static OPJ_FLOAT64 opj_t1_getwmsedec(OPJ_INT32 nmsedec , OPJ_UINT32 compno , OPJ_UINT32 level ,
                                     OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_UINT32 qmfbid ,
                                     OPJ_FLOAT64 stepsize , OPJ_UINT32 numcomps ,
                                     OPJ_FLOAT64 *mct_norms ) 
{ 
  OPJ_FLOAT64 w1 ;
  OPJ_FLOAT64 w2 ;
  OPJ_FLOAT64 wmsedec ;
  OPJ_FLOAT64 __cil_tmp13 ;
  OPJ_FLOAT64 __cil_tmp14 ;

  {
#line 1142
  w1 = (OPJ_FLOAT64 )1;
#line 1145
  if (mct_norms) {
#line 1146
    w1 = *(mct_norms + compno);
  }
#line 1149
  if (qmfbid == 1U) {
    {
#line 1150
    w2 = opj_dwt_getnorm(level, orient);
    }
  } else {
    {
#line 1152
    w2 = opj_dwt_getnorm_real(level, orient);
    }
  }
#line 1155
  wmsedec = ((w1 * w2) * stepsize) * (double )(1 << bpno);
#line 1156
  wmsedec *= (wmsedec * (double )nmsedec) / 8192.;
#line 1158
  return (wmsedec);
}
}
#line 1161 "/root/patron/new_21/src/lib/openjp2/t1.c"
OPJ_BOOL opj_t1_allocate_buffers(opj_t1_t *t1 , OPJ_UINT32 w , OPJ_UINT32 h ) 
{ 
  OPJ_UINT32 datasize ;
  OPJ_UINT32 flagssize ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 1166
  datasize = w * h;
#line 1169
  if (datasize > t1->datasize) {
    {
#line 1170
    free(t1->data);
#line 1171
    __cil_tmp6 = malloc((unsigned long )datasize * sizeof(OPJ_INT32 ));
#line 1171
    t1->data = (OPJ_INT32 *)__cil_tmp6;
    }
#line 1172
    if (! t1->data) {
#line 1174
      return (0);
    }
#line 1176
    t1->datasize = datasize;
  }
  {
#line 1178
  memset(t1->data, 0, (unsigned long )datasize * sizeof(OPJ_INT32 ));
#line 1180
  t1->flags_stride = w + 2U;
#line 1181
  flagssize = t1->flags_stride * (h + 2U);
  }
#line 1183
  if (flagssize > t1->flagssize) {
    {
#line 1184
    free(t1->flags);
#line 1185
    __cil_tmp7 = malloc((unsigned long )flagssize * sizeof(opj_flag_t ));
#line 1185
    t1->flags = (opj_flag_t *)__cil_tmp7;
    }
#line 1186
    if (! t1->flags) {
#line 1188
      return (0);
    }
#line 1190
    t1->flagssize = flagssize;
  }
  {
#line 1192
  memset(t1->flags, 0, (unsigned long )flagssize * sizeof(opj_flag_t ));
#line 1194
  t1->w = w;
#line 1195
  t1->h = h;
  }
#line 1197
  return (1);
}
}
#line 1208 "/root/patron/new_21/src/lib/openjp2/t1.c"
opj_t1_t *opj_t1_create(void) 
{ 
  opj_t1_t *l_t1 ;
  void *__cil_tmp2 ;
  opj_mqc_t *__cil_tmp3 ;
  opj_raw_t *__cil_tmp4 ;

  {
  {
#line 1210
  l_t1 = (opj_t1_t *)0;
#line 1212
  __cil_tmp2 = calloc((unsigned long )1, sizeof(opj_t1_t ));
#line 1212
  l_t1 = (opj_t1_t *)__cil_tmp2;
  }
#line 1213
  if (! l_t1) {
#line 1214
    return ((opj_t1_t *)0);
  }
  {
#line 1218
  l_t1->mqc = opj_mqc_create();
  }
#line 1219
  if (! l_t1->mqc) {
    {
#line 1220
    opj_t1_destroy(l_t1);
    }
#line 1221
    return ((opj_t1_t *)0);
  }
  {
#line 1224
  l_t1->raw = opj_raw_create();
  }
#line 1225
  if (! l_t1->raw) {
    {
#line 1226
    opj_t1_destroy(l_t1);
    }
#line 1227
    return ((opj_t1_t *)0);
  }
#line 1230
  return (l_t1);
}
}
#line 1239 "/root/patron/new_21/src/lib/openjp2/t1.c"
void opj_t1_destroy(opj_t1_t *p_t1 ) 
{ 


  {
#line 1241
  if (! p_t1) {
#line 1242
    return;
  }
  {
#line 1246
  opj_mqc_destroy(p_t1->mqc);
#line 1247
  p_t1->mqc = (opj_mqc_t *)0;
#line 1248
  opj_raw_destroy(p_t1->raw);
#line 1249
  p_t1->raw = (opj_raw_t *)0;
  }
#line 1251
  if (p_t1->data) {
    {
#line 1252
    free(p_t1->data);
#line 1253
    p_t1->data = (OPJ_INT32 *)0;
    }
  }
#line 1256
  if (p_t1->flags) {
    {
#line 1257
    free(p_t1->flags);
#line 1258
    p_t1->flags = (opj_flag_t *)0;
    }
  }
  {
#line 1261
  free(p_t1);
  }
  return;
}
}
#line 1264 "/root/patron/new_21/src/lib/openjp2/t1.c"
OPJ_BOOL opj_t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) 
{ 
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *precinct ;
  opj_tcd_cblk_dec_t *cblk ;
  OPJ_INT32 *datap ;
  OPJ_UINT32 cblk_w ;
  OPJ_UINT32 cblk_h ;
  OPJ_INT32 x ;
  OPJ_INT32 y ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_BOOL __cil_tmp20 ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  OPJ_INT32 thresh ;
  OPJ_INT32 val ;
  OPJ_INT32 mag ;
  int __cil_tmp26 ;
  OPJ_INT32 tmp ;
  OPJ_INT32 *tiledp ;
  OPJ_INT32 tmp___0 ;
  OPJ_FLOAT32 *tiledp___0 ;
  OPJ_FLOAT32 *tiledp2 ;
  OPJ_FLOAT32 tmp___1 ;
  OPJ_INT32 *__cil_tmp33 ;
  OPJ_FLOAT32 *__cil_tmp34 ;

  {
#line 1270
  tile_w = (OPJ_UINT32 )(tilec->x1 - tilec->x0);
#line 1272
  resno = (OPJ_UINT32 )0;
  {
#line 1272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1272
    if (! (resno < tilec->minimum_num_resolutions)) {
#line 1272
      goto while_break;
    }
#line 1273
    res = tilec->resolutions + resno;
#line 1275
    bandno = (OPJ_UINT32 )0;
    {
#line 1275
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1275
      if (! (bandno < res->numbands)) {
#line 1275
        goto while_break___0;
      }
#line 1276
      band = & res->bands[bandno];
#line 1278
      precno = (OPJ_UINT32 )0;
      {
#line 1278
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1278
        if (! (precno < res->pw * res->ph)) {
#line 1278
          goto while_break___1;
        }
#line 1279
        precinct = band->precincts + precno;
#line 1281
        cblkno = (OPJ_UINT32 )0;
        {
#line 1281
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1281
          if (! (cblkno < precinct->cw * precinct->ch)) {
#line 1281
            goto while_break___2;
          }
          {
#line 1282
          cblk = precinct->cblks.dec + cblkno;
#line 1289
          __cil_tmp20 = opj_t1_decode_cblk(t1, cblk, band->bandno, (OPJ_UINT32 )tccp->roishift,
                                           tccp->cblksty);
          }
#line 1289
          if (0 == __cil_tmp20) {
#line 1295
            return (0);
          }
#line 1298
          x = cblk->x0 - band->x0;
#line 1299
          y = cblk->y0 - band->y0;
#line 1300
          if (band->bandno & 1U) {
#line 1301
            pres = tilec->resolutions + (resno - 1U);
#line 1302
            x += pres->x1 - pres->x0;
          }
#line 1304
          if (band->bandno & 2U) {
#line 1305
            pres___0 = tilec->resolutions + (resno - 1U);
#line 1306
            y += pres___0->y1 - pres___0->y0;
          }
#line 1309
          datap = t1->data;
#line 1310
          cblk_w = t1->w;
#line 1311
          cblk_h = t1->h;
#line 1313
          if (tccp->roishift) {
#line 1314
            thresh = 1 << tccp->roishift;
#line 1315
            j = (OPJ_UINT32 )0;
            {
#line 1315
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1315
              if (! (j < cblk_h)) {
#line 1315
                goto while_break___3;
              }
#line 1316
              i = (OPJ_UINT32 )0;
              {
#line 1316
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1316
                if (! (i < cblk_w)) {
#line 1316
                  goto while_break___4;
                }
                {
#line 1317
                val = *(datap + (j * cblk_w + i));
#line 1318
                __cil_tmp26 = abs(val);
#line 1318
                mag = __cil_tmp26;
                }
#line 1319
                if (mag >= thresh) {
#line 1320
                  mag >>= tccp->roishift;
#line 1321
                  if (val < 0) {
#line 1321
                    tmp = - mag;
                  } else {
#line 1321
                    tmp = mag;
                  }
#line 1321
                  *(datap + (j * cblk_w + i)) = tmp;
                }
#line 1316
                i ++;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 1315
              j ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 1328
          if (tccp->qmfbid == 1U) {
#line 1329
            tiledp = tilec->data + ((OPJ_UINT32 )y * tile_w + (OPJ_UINT32 )x);
#line 1330
            j = (OPJ_UINT32 )0;
            {
#line 1330
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 1330
              if (! (j < cblk_h)) {
#line 1330
                goto while_break___5;
              }
#line 1331
              i = (OPJ_UINT32 )0;
              {
#line 1331
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 1331
                if (! (i < cblk_w)) {
#line 1331
                  goto while_break___6;
                }
#line 1332
                tmp___0 = *(datap + (j * cblk_w + i));
#line 1333
                *((OPJ_INT32 *)tiledp + (j * tile_w + i)) = tmp___0 / 2;
#line 1331
                i ++;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 1330
              j ++;
            }
            while_break___5: /* CIL Label */ ;
            }
          } else {
#line 1337
            tiledp___0 = (OPJ_FLOAT32 *)(tilec->data + ((OPJ_UINT32 )y * tile_w + (OPJ_UINT32 )x));
#line 1338
            j = (OPJ_UINT32 )0;
            {
#line 1338
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 1338
              if (! (j < cblk_h)) {
#line 1338
                goto while_break___7;
              }
#line 1339
              tiledp2 = tiledp___0;
#line 1340
              i = (OPJ_UINT32 )0;
              {
#line 1340
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 1340
                if (! (i < cblk_w)) {
#line 1340
                  goto while_break___8;
                }
#line 1341
                tmp___1 = (OPJ_FLOAT32 )*datap * band->stepsize;
#line 1342
                *tiledp2 = tmp___1;
#line 1343
                datap ++;
#line 1344
                tiledp2 ++;
#line 1340
                i ++;
              }
              while_break___8: /* CIL Label */ ;
              }
#line 1349
              tiledp___0 += tile_w;
#line 1338
              j ++;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
#line 1281
          cblkno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1278
        precno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1275
      bandno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1272
    resno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1360
  return (1);
}
}
#line 1364 "/root/patron/new_21/src/lib/openjp2/t1.c"
OPJ_BOOL opj_t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 orient ,
                            OPJ_UINT32 roishift , OPJ_UINT32 cblksty ) 
{ 
  opj_raw_t *raw ;
  opj_mqc_t *mqc ;
  OPJ_INT32 bpno ;
  OPJ_UINT32 passtype ;
  OPJ_UINT32 segno ;
  OPJ_UINT32 passno ;
  OPJ_BYTE type ;
  OPJ_BOOL __cil_tmp13 ;
  opj_tcd_seg_t *seg ;
  int tmp ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_INT32 __cil_tmp17 ;

  {
  {
#line 1370
  raw = t1->raw;
#line 1371
  mqc = t1->mqc;
#line 1376
  type = (OPJ_BYTE )0;
#line 1378
  __cil_tmp13 = opj_t1_allocate_buffers(t1, (OPJ_UINT32 )(cblk->x1 - cblk->x0), (OPJ_UINT32 )(cblk->y1 - cblk->y0));
  }
#line 1378
  if (! __cil_tmp13) {
#line 1383
    return (0);
  }
  {
#line 1386
  bpno = (OPJ_INT32 )((roishift + cblk->numbps) - 1U);
#line 1387
  passtype = (OPJ_UINT32 )2;
#line 1389
  opj_mqc_resetstates(mqc);
#line 1390
  opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 1391
  opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 1392
  opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
#line 1394
  segno = (OPJ_UINT32 )0;
  }
  {
#line 1394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1394
    if (! (segno < cblk->real_num_segs)) {
#line 1394
      goto while_break;
    }
#line 1395
    seg = cblk->segs + segno;
#line 1398
    if ((bpno <= ((OPJ_INT32 )cblk->numbps - 1) - 4 && passtype < 2U) && cblksty & 1U) {
#line 1398
      tmp = 1;
    } else {
#line 1398
      tmp = 0;
    }
#line 1398
    type = (OPJ_BYTE )tmp;
#line 1400
    if (seg->data == (OPJ_BYTE **)0) {
#line 1401
      goto while_continue;
    }
#line 1403
    if ((int )type == 1) {
      {
#line 1404
      opj_raw_init_dec(raw, *(seg->data) + seg->dataindex, seg->len);
      }
    } else {
      {
#line 1406
      __cil_tmp16 = opj_mqc_init_dec(mqc, *(seg->data) + seg->dataindex, seg->len);
      }
#line 1406
      if (0 == __cil_tmp16) {
#line 1407
        return (0);
      }
    }
#line 1411
    passno = (OPJ_UINT32 )0;
    {
#line 1411
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1411
      if (! (passno < seg->real_num_passes)) {
#line 1411
        goto while_break___0;
      }
      {
#line 1413
      if (passtype == (OPJ_UINT32 )0) {
#line 1413
        goto case_0;
      }
#line 1424
      if (passtype == (OPJ_UINT32 )1) {
#line 1424
        goto case_1;
      }
#line 1435
      if (passtype == (OPJ_UINT32 )2) {
#line 1435
        goto case_2;
      }
#line 1412
      goto switch_break;
      case_0: /* CIL Label */ 
#line 1414
      if ((int )type == 1) {
        {
#line 1415
        opj_t1_dec_sigpass_raw(t1, bpno + 1, (OPJ_INT32 )orient, (OPJ_INT32 )cblksty);
        }
      } else
#line 1417
      if (cblksty & 8U) {
        {
#line 1418
        opj_t1_dec_sigpass_mqc_vsc(t1, bpno + 1, (OPJ_INT32 )orient);
        }
      } else {
        {
#line 1420
        opj_t1_dec_sigpass_mqc(t1, bpno + 1, (OPJ_INT32 )orient);
        }
      }
#line 1423
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1425
      if ((int )type == 1) {
        {
#line 1426
        opj_t1_dec_refpass_raw(t1, bpno + 1, (OPJ_INT32 )cblksty);
        }
      } else
#line 1428
      if (cblksty & 8U) {
        {
#line 1429
        opj_t1_dec_refpass_mqc_vsc(t1, bpno + 1);
        }
      } else {
        {
#line 1431
        opj_t1_dec_refpass_mqc(t1, bpno + 1);
        }
      }
#line 1434
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 1436
      opj_t1_dec_clnpass(t1, bpno + 1, (OPJ_INT32 )orient, (OPJ_INT32 )cblksty);
      }
#line 1437
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1440
      if (cblksty & 2U) {
#line 1440
        if ((int )type == 0) {
          {
#line 1441
          opj_mqc_resetstates(mqc);
#line 1442
          opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 1443
          opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 1444
          opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
          }
        }
      }
#line 1446
      passtype ++;
#line 1446
      if (passtype == 3U) {
#line 1447
        passtype = (OPJ_UINT32 )0;
#line 1448
        __cil_tmp17 = bpno;
#line 1448
        bpno --;
      }
#line 1411
      passno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1394
    segno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1452
  return (1);
}
}
#line 1458 "/root/patron/new_21/src/lib/openjp2/t1.c"
OPJ_BOOL opj_t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                             OPJ_FLOAT64 *mct_norms ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tccp_t *tccp ;
  OPJ_UINT32 tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  OPJ_INT32 bandconst ;
  double __cil_tmp16 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  OPJ_INT32 *datap ;
  OPJ_INT32 *tiledp ;
  OPJ_UINT32 cblk_w ;
  OPJ_UINT32 cblk_h ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_INT32 x ;
  OPJ_INT32 y ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  OPJ_BOOL __cil_tmp29 ;
  OPJ_INT32 tmp ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 __cil_tmp32 ;

  {
#line 1466
  tile->distotile = (OPJ_FLOAT64 )0;
#line 1468
  compno = (OPJ_UINT32 )0;
  {
#line 1468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1468
    if (! (compno < tile->numcomps)) {
#line 1468
      goto while_break;
    }
#line 1469
    tilec = tile->comps + compno;
#line 1470
    tccp = tcp->tccps + compno;
#line 1471
    tile_w = (OPJ_UINT32 )(tilec->x1 - tilec->x0);
#line 1473
    resno = (OPJ_UINT32 )0;
    {
#line 1473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1473
      if (! (resno < tilec->numresolutions)) {
#line 1473
        goto while_break___0;
      }
#line 1474
      res = tilec->resolutions + resno;
#line 1476
      bandno = (OPJ_UINT32 )0;
      {
#line 1476
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1476
        if (! (bandno < res->numbands)) {
#line 1476
          goto while_break___1;
        }
        {
#line 1477
        band = & res->bands[bandno];
#line 1478
        __cil_tmp16 = floor((double )(band->stepsize * (float )8192));
#line 1478
        bandconst = 67108864 / (OPJ_INT32 )__cil_tmp16;
#line 1480
        precno = (OPJ_UINT32 )0;
        }
        {
#line 1480
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1480
          if (! (precno < res->pw * res->ph)) {
#line 1480
            goto while_break___2;
          }
#line 1481
          prc = band->precincts + precno;
#line 1483
          cblkno = (OPJ_UINT32 )0;
          {
#line 1483
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1483
            if (! (cblkno < prc->cw * prc->ch)) {
#line 1483
              goto while_break___3;
            }
#line 1484
            cblk = prc->cblks.enc + cblkno;
#line 1491
            x = cblk->x0 - band->x0;
#line 1492
            y = cblk->y0 - band->y0;
#line 1493
            if (band->bandno & 1U) {
#line 1494
              pres = tilec->resolutions + (resno - 1U);
#line 1495
              x += pres->x1 - pres->x0;
            }
#line 1497
            if (band->bandno & 2U) {
#line 1498
              pres___0 = tilec->resolutions + (resno - 1U);
#line 1499
              y += pres___0->y1 - pres___0->y0;
            }
            {
#line 1502
            __cil_tmp29 = opj_t1_allocate_buffers(t1, (OPJ_UINT32 )(cblk->x1 - cblk->x0),
                                                  (OPJ_UINT32 )(cblk->y1 - cblk->y0));
            }
#line 1502
            if (! __cil_tmp29) {
#line 1507
              return (0);
            }
#line 1510
            datap = t1->data;
#line 1511
            cblk_w = t1->w;
#line 1512
            cblk_h = t1->h;
#line 1514
            tiledp = tilec->data + ((OPJ_UINT32 )y * tile_w + (OPJ_UINT32 )x);
#line 1515
            if (tccp->qmfbid == 1U) {
#line 1516
              j = (OPJ_UINT32 )0;
              {
#line 1516
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1516
                if (! (j < cblk_h)) {
#line 1516
                  goto while_break___4;
                }
#line 1517
                i = (OPJ_UINT32 )0;
                {
#line 1517
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 1517
                  if (! (i < cblk_w)) {
#line 1517
                    goto while_break___5;
                  }
#line 1518
                  tmp = *(tiledp + (j * tile_w + i));
#line 1519
                  *(datap + (j * cblk_w + i)) = tmp << 6;
#line 1517
                  i ++;
                }
                while_break___5: /* CIL Label */ ;
                }
#line 1516
                j ++;
              }
              while_break___4: /* CIL Label */ ;
              }
            } else {
#line 1523
              j = (OPJ_UINT32 )0;
              {
#line 1523
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 1523
                if (! (j < cblk_h)) {
#line 1523
                  goto while_break___6;
                }
#line 1524
                i = (OPJ_UINT32 )0;
                {
#line 1524
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 1524
                  if (! (i < cblk_w)) {
#line 1524
                    goto while_break___7;
                  }
                  {
#line 1525
                  tmp___0 = *(tiledp + (j * tile_w + i));
#line 1526
                  __cil_tmp32 = opj_int_fix_mul(tmp___0, bandconst);
#line 1526
                  *(datap + (j * cblk_w + i)) = __cil_tmp32 >> 5;
                  }
#line 1524
                  i ++;
                }
                while_break___7: /* CIL Label */ ;
                }
#line 1523
                j ++;
              }
              while_break___6: /* CIL Label */ ;
              }
            }
            {
#line 1534
            opj_t1_encode_cblk(t1, cblk, band->bandno, compno, (tilec->numresolutions - 1U) - resno,
                               tccp->qmfbid, (OPJ_FLOAT64 )band->stepsize, tccp->cblksty,
                               tile->numcomps, tile, mct_norms);
            }
#line 1483
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1480
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1476
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1473
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1468
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1552
  return (1);
}
}
#line 1556 "/root/patron/new_21/src/lib/openjp2/t1.c"
void opj_t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , OPJ_UINT32 orient ,
                        OPJ_UINT32 compno , OPJ_UINT32 level , OPJ_UINT32 qmfbid ,
                        OPJ_FLOAT64 stepsize , OPJ_UINT32 cblksty , OPJ_UINT32 numcomps ,
                        opj_tcd_tile_t *tile , OPJ_FLOAT64 *mct_norms ) 
{ 
  OPJ_FLOAT64 cumwmsedec ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 passno ;
  OPJ_INT32 bpno ;
  OPJ_UINT32 passtype ;
  OPJ_INT32 nmsedec ;
  OPJ_INT32 max ;
  OPJ_UINT32 i ;
  OPJ_BYTE type ;
  OPJ_FLOAT64 tempwmsedec ;
  OPJ_INT32 tmp ;
  int __cil_tmp23 ;
  OPJ_INT32 __cil_tmp24 ;
  OPJ_INT32 __cil_tmp25 ;
  OPJ_UINT32 tmp___0 ;
  opj_tcd_pass_t *pass ;
  OPJ_UINT32 correction ;
  int tmp___1 ;
  OPJ_FLOAT64 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  int tmp___2 ;
  OPJ_UINT32 __cil_tmp33 ;
  opj_tcd_pass_t *pass___0 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 __cil_tmp36 ;
  OPJ_UINT32 __cil_tmp37 ;
  unsigned int tmp___3 ;
  OPJ_UINT32 __cil_tmp39 ;

  {
#line 1568
  cumwmsedec = 0.;
#line 1570
  mqc = t1->mqc;
#line 1575
  nmsedec = 0;
#line 1578
  type = (OPJ_BYTE )0;
#line 1581
  max = 0;
#line 1582
  i = (OPJ_UINT32 )0;
  {
#line 1582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1582
    if (! (i < t1->w * t1->h)) {
#line 1582
      goto while_break;
    }
    {
#line 1583
    __cil_tmp23 = abs(*(t1->data + i));
#line 1583
    tmp = __cil_tmp23;
#line 1584
    max = opj_int_max(max, tmp);
    }
#line 1582
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1587
  if (max) {
    {
#line 1587
    __cil_tmp25 = opj_int_floorlog2(max);
#line 1587
    tmp___0 = (OPJ_UINT32 )((__cil_tmp25 + 1) - 6);
    }
  } else {
#line 1587
    tmp___0 = (unsigned int )0;
  }
  {
#line 1587
  cblk->numbps = tmp___0;
#line 1589
  bpno = (OPJ_INT32 )(cblk->numbps - 1U);
#line 1590
  passtype = (OPJ_UINT32 )2;
#line 1592
  opj_mqc_resetstates(mqc);
#line 1593
  opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 1594
  opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 1595
  opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
#line 1596
  opj_mqc_init_enc(mqc, cblk->data);
#line 1598
  passno = (OPJ_UINT32 )0;
  }
  {
#line 1598
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1598
    if (! (bpno >= 0)) {
#line 1598
      goto while_break___0;
    }
#line 1599
    pass = cblk->passes + passno;
#line 1600
    correction = (OPJ_UINT32 )3;
#line 1601
    if ((bpno < (OPJ_INT32 )cblk->numbps - 4 && passtype < 2U) && cblksty & 1U) {
#line 1601
      tmp___1 = 1;
    } else {
#line 1601
      tmp___1 = 0;
    }
#line 1601
    type = (OPJ_BYTE )tmp___1;
    {
#line 1604
    if (passtype == (OPJ_UINT32 )0) {
#line 1604
      goto case_0;
    }
#line 1607
    if (passtype == (OPJ_UINT32 )1) {
#line 1607
      goto case_1;
    }
#line 1610
    if (passtype == (OPJ_UINT32 )2) {
#line 1610
      goto case_2;
    }
#line 1603
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1605
    opj_t1_enc_sigpass(t1, bpno, orient, & nmsedec, type, cblksty);
    }
#line 1606
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1608
    opj_t1_enc_refpass(t1, bpno, & nmsedec, type, cblksty);
    }
#line 1609
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1611
    opj_t1_enc_clnpass(t1, bpno, orient, & nmsedec, cblksty);
    }
#line 1613
    if (cblksty & 32U) {
      {
#line 1614
      opj_mqc_segmark_enc(mqc);
      }
    }
#line 1615
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1619
    tempwmsedec = opj_t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid,
                                    stepsize, numcomps, mct_norms);
#line 1620
    cumwmsedec += tempwmsedec;
#line 1621
    tile->distotile += tempwmsedec;
    }
#line 1624
    if (cblksty & 4U) {
#line 1624
      if (! (passtype == 2U && bpno - 1 < 0)) {
#line 1625
        if ((int )type == 1) {
          {
#line 1626
          opj_mqc_flush(mqc);
#line 1627
          correction = (OPJ_UINT32 )1;
          }
        } else {
          {
#line 1630
          opj_mqc_flush(mqc);
#line 1631
          correction = (OPJ_UINT32 )1;
          }
        }
#line 1633
        pass->term = (OPJ_UINT32 )1;
      } else {
#line 1624
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 1635
    if (bpno < (OPJ_INT32 )cblk->numbps - 4) {
#line 1635
      if (passtype > 0U) {
        _L: /* CIL Label */ 
#line 1635
        if (cblksty & 1U) {
#line 1637
          if ((int )type == 1) {
            {
#line 1638
            opj_mqc_flush(mqc);
#line 1639
            correction = (OPJ_UINT32 )1;
            }
          } else {
            {
#line 1642
            opj_mqc_flush(mqc);
#line 1643
            correction = (OPJ_UINT32 )1;
            }
          }
#line 1645
          pass->term = (OPJ_UINT32 )1;
        } else {
#line 1647
          pass->term = (OPJ_UINT32 )0;
        }
      } else {
#line 1635
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1635
    if (bpno == (OPJ_INT32 )cblk->numbps - 4) {
#line 1635
      if (passtype == 2U) {
#line 1635
        goto _L;
      } else {
#line 1647
        pass->term = (OPJ_UINT32 )0;
      }
    } else {
#line 1647
      pass->term = (OPJ_UINT32 )0;
    }
#line 1651
    passtype ++;
#line 1651
    if (passtype == 3U) {
#line 1652
      passtype = (OPJ_UINT32 )0;
#line 1653
      __cil_tmp31 = bpno;
#line 1653
      bpno --;
    }
#line 1656
    if ((int )pass->term) {
#line 1656
      if (bpno > 0) {
#line 1657
        if ((bpno < (OPJ_INT32 )cblk->numbps - 4 && passtype < 2U) && cblksty & 1U) {
#line 1657
          tmp___2 = 1;
        } else {
#line 1657
          tmp___2 = 0;
        }
#line 1657
        type = (OPJ_BYTE )tmp___2;
#line 1658
        if ((int )type == 1) {
          {
#line 1659
          opj_mqc_bypass_init_enc(mqc);
          }
        } else {
          {
#line 1661
          opj_mqc_restart_init_enc(mqc);
          }
        }
      }
    }
    {
#line 1664
    pass->distortiondec = cumwmsedec;
#line 1665
    __cil_tmp33 = opj_mqc_numbytes(mqc);
#line 1665
    pass->rate = __cil_tmp33 + correction;
    }
#line 1668
    if (cblksty & 2U) {
      {
#line 1669
      opj_mqc_reset_enc(mqc);
      }
    }
#line 1598
    passno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1673
  if (cblksty & 16U) {
    {
#line 1674
    opj_mqc_erterm_enc(mqc);
    }
  } else
#line 1675
  if (! (cblksty & 1U)) {
    {
#line 1676
    opj_mqc_flush(mqc);
    }
  }
#line 1678
  cblk->totalpasses = passno;
#line 1680
  passno = (OPJ_UINT32 )0;
  {
#line 1680
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1680
    if (! (passno < cblk->totalpasses)) {
#line 1680
      goto while_break___1;
    }
    {
#line 1681
    pass___0 = cblk->passes + passno;
#line 1682
    __cil_tmp35 = opj_mqc_numbytes(mqc);
    }
#line 1682
    if (pass___0->rate > __cil_tmp35) {
      {
#line 1683
      pass___0->rate = opj_mqc_numbytes(mqc);
      }
    }
#line 1685
    if (pass___0->rate > 1U) {
#line 1685
      if ((int )*(cblk->data + (pass___0->rate - 1U)) == 255) {
#line 1686
        __cil_tmp37 = pass___0->rate;
#line 1686
        (pass___0->rate) --;
      }
    }
#line 1688
    if (passno == 0U) {
#line 1688
      tmp___3 = (unsigned int )0;
    } else {
#line 1688
      tmp___3 = (cblk->passes + (passno - 1U))->rate;
    }
#line 1688
    pass___0->len = pass___0->rate - tmp___3;
#line 1680
    passno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 51 "/root/patron/new_21/src/lib/openjp2/raw.c"
opj_raw_t *opj_raw_create(void) 
{ 
  opj_raw_t *raw ;
  void *__cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = malloc(sizeof(opj_raw_t ));
#line 52
  raw = (opj_raw_t *)__cil_tmp2;
  }
#line 53
  return (raw);
}
}
#line 56 "/root/patron/new_21/src/lib/openjp2/raw.c"
void opj_raw_destroy(opj_raw_t *raw ) 
{ 


  {
#line 57
  if (raw) {
    {
#line 58
    free(raw);
    }
  }
  return;
}
}
#line 62 "/root/patron/new_21/src/lib/openjp2/raw.c"
OPJ_UINT32 opj_raw_numbytes(opj_raw_t *raw ) 
{ 
  ptrdiff_t diff ;
  int tmp ;

  {
#line 63
  diff = raw->bp - raw->start;
#line 65
  return ((OPJ_UINT32 )diff);
}
}
#line 68 "/root/patron/new_21/src/lib/openjp2/raw.c"
void opj_raw_init_dec(opj_raw_t *raw , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 69
  raw->start = bp;
#line 70
  raw->lenmax = len;
#line 71
  raw->len = (OPJ_UINT32 )0;
#line 72
  raw->c = (OPJ_BYTE )0;
#line 73
  raw->ct = (OPJ_UINT32 )0;
  return;
}
}
#line 76 "/root/patron/new_21/src/lib/openjp2/raw.c"
OPJ_UINT32 opj_raw_decode(opj_raw_t *raw ) 
{ 
  OPJ_UINT32 d ;
  OPJ_UINT32 __cil_tmp3 ;
  OPJ_UINT32 __cil_tmp4 ;

  {
#line 78
  if (raw->ct == 0U) {
#line 79
    raw->ct = (OPJ_UINT32 )8;
#line 80
    if (raw->len == raw->lenmax) {
#line 81
      raw->c = (OPJ_BYTE )255;
    } else {
#line 83
      if ((int )raw->c == 255) {
#line 84
        raw->ct = (OPJ_UINT32 )7;
      }
#line 86
      raw->c = *(raw->start + raw->len);
#line 87
      (raw->len) ++;
    }
  }
#line 90
  __cil_tmp4 = raw->ct;
#line 90
  (raw->ct) --;
#line 91
  d = (OPJ_UINT32 )(((int )raw->c >> raw->ct) & 1);
#line 93
  return (d);
}
}
#line 48 "/root/patron/new_21/src/lib/openjp2/t2.c"
static void opj_t2_putcommacode(opj_bio_t *bio , OPJ_INT32 n ) ;
#line 50
OPJ_UINT32 opj_t2_getcommacode(opj_bio_t *bio ) ;
#line 56
void opj_t2_putnumpasses(opj_bio_t *bio , OPJ_UINT32 n ) ;
#line 57
OPJ_UINT32 opj_t2_getnumpasses(opj_bio_t *bio ) ;
#line 71
OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                              opj_pi_iterator_t *pi , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 length , opj_codestream_info_t *cstr_info ) ;
#line 93
OPJ_BOOL opj_t2_decode_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                              opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                              OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) ;
#line 102
static OPJ_BOOL opj_t2_skip_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) ;
#line 111
OPJ_BOOL opj_t2_read_packet_header(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BOOL *p_is_data_present ,
                                   OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) ;
#line 121
OPJ_BOOL opj_t2_read_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_pi_iterator_t *p_pi ,
                                 OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                 OPJ_UINT32 p_max_length , opj_packet_info_t *pack_info ) ;
#line 129
OPJ_BOOL opj_t2_skip_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_pi_iterator_t *p_pi ,
                                 OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                 opj_packet_info_t *pack_info ) ;
#line 142
OPJ_BOOL opj_t2_init_seg(opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 index___0 , OPJ_UINT32 cblksty ,
                         OPJ_UINT32 first ) ;
#line 154 "/root/patron/new_21/src/lib/openjp2/t2.c"
static void opj_t2_putcommacode(opj_bio_t *bio , OPJ_INT32 n ) 
{ 


  {
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    n --;
#line 155
    if (! (n >= 0)) {
#line 155
      goto while_break;
    }
    {
#line 156
    opj_bio_write(bio, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  opj_bio_write(bio, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
  }
  return;
}
}
#line 161 "/root/patron/new_21/src/lib/openjp2/t2.c"
OPJ_UINT32 opj_t2_getcommacode(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 n ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 163
  n = (OPJ_UINT32 )0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 164
    __cil_tmp3 = opj_bio_read(bio, (OPJ_UINT32 )1);
    }
#line 164
    if (! __cil_tmp3) {
#line 164
      goto while_break;
    }
#line 165
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return (n);
}
}
#line 170 "/root/patron/new_21/src/lib/openjp2/t2.c"
void opj_t2_putnumpasses(opj_bio_t *bio , OPJ_UINT32 n ) 
{ 


  {
#line 171
  if (n == 1U) {
    {
#line 172
    opj_bio_write(bio, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
    }
  } else
#line 173
  if (n == 2U) {
    {
#line 174
    opj_bio_write(bio, (OPJ_UINT32 )2, (OPJ_UINT32 )2);
    }
  } else
#line 175
  if (n <= 5U) {
    {
#line 176
    opj_bio_write(bio, 12U | (n - 3U), (OPJ_UINT32 )4);
    }
  } else
#line 177
  if (n <= 36U) {
    {
#line 178
    opj_bio_write(bio, 480U | (n - 6U), (OPJ_UINT32 )9);
    }
  } else
#line 179
  if (n <= 164U) {
    {
#line 180
    opj_bio_write(bio, 65408U | (n - 37U), (OPJ_UINT32 )16);
    }
  }
  return;
}
}
#line 184 "/root/patron/new_21/src/lib/openjp2/t2.c"
OPJ_UINT32 opj_t2_getnumpasses(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 n ;
  OPJ_UINT32 __cil_tmp3 ;
  OPJ_UINT32 __cil_tmp4 ;
  OPJ_UINT32 __cil_tmp5 ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;

  {
  {
#line 186
  __cil_tmp3 = opj_bio_read(bio, (OPJ_UINT32 )1);
  }
#line 186
  if (! __cil_tmp3) {
#line 187
    return ((OPJ_UINT32 )1);
  }
  {
#line 188
  __cil_tmp4 = opj_bio_read(bio, (OPJ_UINT32 )1);
  }
#line 188
  if (! __cil_tmp4) {
#line 189
    return ((OPJ_UINT32 )2);
  }
  {
#line 190
  n = opj_bio_read(bio, (OPJ_UINT32 )2);
  }
#line 190
  if (n != 3U) {
#line 191
    return (3U + n);
  }
  {
#line 192
  n = opj_bio_read(bio, (OPJ_UINT32 )5);
  }
#line 192
  if (n != 31U) {
#line 193
    return (6U + n);
  }
  {
#line 194
  __cil_tmp7 = opj_bio_read(bio, (OPJ_UINT32 )7);
  }
#line 194
  return (37U + __cil_tmp7);
}
}
#line 199 "/root/patron/new_21/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_encode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_UINT32 p_maxlayers , OPJ_BYTE *p_dest , OPJ_UINT32 *p_data_written ,
                               OPJ_UINT32 p_max_len , opj_codestream_info_t *cstr_info ,
                               OPJ_UINT32 p_tp_num , OPJ_INT32 p_tp_pos , OPJ_UINT32 p_pino ,
                               J2K_T2_MODE p_t2_mode ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 poc ;
  opj_pi_iterator_t *l_pi ;
  opj_pi_iterator_t *l_current_pi ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 pocno ;
  int tmp ;
  OPJ_UINT32 l_max_comp ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 l_nb_pocs ;
  opj_pi_iterator_t *__cil_tmp27 ;
  OPJ_UINT32 l_comp_len ;
  OPJ_UINT32 l_tp_num ;
  OPJ_BOOL __cil_tmp30 ;
  OPJ_BOOL __cil_tmp31 ;
  OPJ_BOOL __cil_tmp32 ;
  OPJ_BOOL __cil_tmp33 ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  OPJ_OFF_T tmp___1 ;
  int __cil_tmp37 ;

  {
#line 212
  l_current_data = p_dest;
#line 213
  l_nb_bytes = (OPJ_UINT32 )0;
#line 216
  l_pi = (opj_pi_iterator_t *)0;
#line 217
  l_current_pi = (opj_pi_iterator_t *)0;
#line 218
  l_image = p_t2->image;
#line 219
  l_cp = p_t2->cp;
#line 220
  l_tcp = l_cp->tcps + p_tile_no;
#line 221
  if ((int )l_cp->rsiz == 4) {
#line 221
    tmp = 2;
  } else {
#line 221
    tmp = 1;
  }
#line 221
  pocno = (OPJ_UINT32 )tmp;
#line 222
  if (l_cp->m_specific_param.m_enc.m_max_comp_size > 0U) {
#line 222
    tmp___0 = l_image->numcomps;
  } else {
#line 222
    tmp___0 = (unsigned int )1;
  }
  {
#line 222
  l_max_comp = tmp___0;
#line 223
  l_nb_pocs = l_tcp->numpocs + 1U;
#line 225
  l_pi = opj_pi_initialise_encode(l_image, l_cp, p_tile_no, p_t2_mode);
  }
#line 226
  if (! l_pi) {
#line 227
    return (0);
  }
#line 230
  *p_data_written = (OPJ_UINT32 )0;
#line 232
  if ((unsigned int )p_t2_mode == 0U) {
#line 233
    l_current_pi = l_pi;
#line 235
    compno = (OPJ_UINT32 )0;
    {
#line 235
    while (1) {
      while_continue: /* CIL Label */ ;
#line 235
      if (! (compno < l_max_comp)) {
#line 235
        goto while_break;
      }
#line 236
      l_comp_len = (OPJ_UINT32 )0;
#line 237
      l_current_pi = l_pi;
#line 239
      poc = (OPJ_UINT32 )0;
      {
#line 239
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 239
        if (! (poc < pocno)) {
#line 239
          goto while_break___0;
        }
        {
#line 240
        l_tp_num = compno;
#line 243
        opj_pi_create_encode(l_pi, l_cp, p_tile_no, poc, l_tp_num, p_tp_pos, p_t2_mode);
        }
#line 245
        if ((int )l_current_pi->poc.prg == -1) {
          {
#line 247
          opj_pi_destroy(l_pi, l_nb_pocs);
          }
#line 248
          return (0);
        }
        {
#line 250
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 250
          __cil_tmp30 = opj_pi_next(l_current_pi);
          }
#line 250
          if (! __cil_tmp30) {
#line 250
            goto while_break___1;
          }
#line 251
          if (l_current_pi->layno < p_maxlayers) {
            {
#line 252
            l_nb_bytes = (OPJ_UINT32 )0;
#line 254
            __cil_tmp31 = opj_t2_encode_packet(p_tile_no, p_tile, l_tcp, l_current_pi,
                                               l_current_data, & l_nb_bytes, p_max_len,
                                               cstr_info);
            }
#line 254
            if (! __cil_tmp31) {
              {
#line 255
              opj_pi_destroy(l_pi, l_nb_pocs);
              }
#line 256
              return (0);
            }
#line 259
            l_comp_len += l_nb_bytes;
#line 260
            l_current_data += l_nb_bytes;
#line 261
            p_max_len -= l_nb_bytes;
#line 263
            *p_data_written += l_nb_bytes;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 267
        if (l_cp->m_specific_param.m_enc.m_max_comp_size) {
#line 268
          if (l_comp_len > l_cp->m_specific_param.m_enc.m_max_comp_size) {
            {
#line 269
            opj_pi_destroy(l_pi, l_nb_pocs);
            }
#line 270
            return (0);
          }
        }
#line 274
        l_current_pi ++;
#line 239
        poc ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 235
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 279
    opj_pi_create_encode(l_pi, l_cp, p_tile_no, p_pino, p_tp_num, p_tp_pos, p_t2_mode);
#line 281
    l_current_pi = l_pi + p_pino;
    }
#line 282
    if ((int )l_current_pi->poc.prg == -1) {
      {
#line 284
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 285
      return (0);
    }
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 287
      __cil_tmp32 = opj_pi_next(l_current_pi);
      }
#line 287
      if (! __cil_tmp32) {
#line 287
        goto while_break___2;
      }
#line 288
      if (l_current_pi->layno < p_maxlayers) {
        {
#line 289
        l_nb_bytes = (OPJ_UINT32 )0;
#line 291
        __cil_tmp33 = opj_t2_encode_packet(p_tile_no, p_tile, l_tcp, l_current_pi,
                                           l_current_data, & l_nb_bytes, p_max_len,
                                           cstr_info);
        }
#line 291
        if (! __cil_tmp33) {
          {
#line 292
          opj_pi_destroy(l_pi, l_nb_pocs);
          }
#line 293
          return (0);
        }
#line 296
        l_current_data += l_nb_bytes;
#line 297
        p_max_len -= l_nb_bytes;
#line 299
        *p_data_written += l_nb_bytes;
#line 302
        if (cstr_info) {
#line 303
          if (cstr_info->index_write) {
#line 304
            info_TL = cstr_info->tile + p_tile_no;
#line 305
            info_PK = info_TL->packet + cstr_info->packno;
#line 306
            if (! cstr_info->packno) {
#line 307
              info_PK->start_pos = (OPJ_OFF_T )(info_TL->end_header + 1);
            } else {
#line 309
              if ((int )l_cp->m_specific_param.m_enc.m_tp_on | (int )l_tcp->POC && info_PK->start_pos) {
#line 309
                tmp___1 = info_PK->start_pos;
              } else {
#line 309
                tmp___1 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1L;
              }
#line 309
              info_PK->start_pos = tmp___1;
            }
#line 311
            info_PK->end_pos = (info_PK->start_pos + (long )l_nb_bytes) - 1L;
#line 312
            info_PK->end_ph_pos += info_PK->start_pos - 1L;
          }
#line 316
          (cstr_info->packno) ++;
        }
#line 319
        (p_tile->packno) ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 324
  opj_pi_destroy(l_pi, l_nb_pocs);
  }
#line 326
  return (1);
}
}
#line 334 "/root/patron/new_21/src/lib/openjp2/t2.c"
static void opj_null_jas_fprintf(FILE *file , char const   *format  , ...) 
{ 


  {
  return;
}
}
#line 342 "/root/patron/new_21/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_decode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_len ,
                               opj_codestream_index_t *p_cstr_index ) 
{ 
  OPJ_BYTE *l_current_data ;
  opj_pi_iterator_t *l_pi ;
  OPJ_UINT32 pino ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_pocs ;
  opj_pi_iterator_t *l_current_pi ;
  opj_packet_info_t *l_pack_info ;
  opj_image_comp_t *l_img_comp ;
  opj_pi_iterator_t *__cil_tmp19 ;
  OPJ_BOOL *first_pass_failed ;
  void *__cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;
  OPJ_BOOL __cil_tmp23 ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_BOOL __cil_tmp25 ;

  {
  {
#line 350
  l_current_data = p_src;
#line 351
  l_pi = (opj_pi_iterator_t *)0;
#line 353
  l_image = p_t2->image;
#line 354
  l_cp = p_t2->cp;
#line 355
  l_tcp = (p_t2->cp)->tcps + p_tile_no;
#line 357
  l_nb_pocs = l_tcp->numpocs + 1U;
#line 358
  l_current_pi = (opj_pi_iterator_t *)0;
#line 363
  l_pack_info = (opj_packet_info_t *)0;
#line 364
  l_img_comp = (opj_image_comp_t *)0;
#line 375
  l_pi = opj_pi_create_decode(l_image, l_cp, p_tile_no);
  }
#line 376
  if (! l_pi) {
#line 377
    return (0);
  }
#line 381
  l_current_pi = l_pi;
#line 383
  pino = (OPJ_UINT32 )0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! (pino <= l_tcp->numpocs)) {
#line 383
      goto while_break;
    }
    {
#line 390
    __cil_tmp21 = malloc((unsigned long )l_image->numcomps * sizeof(OPJ_BOOL ));
#line 390
    first_pass_failed = (OPJ_BOOL *)__cil_tmp21;
    }
#line 391
    if (! first_pass_failed) {
      {
#line 393
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 394
      return (0);
    }
    {
#line 396
    memset(first_pass_failed, 1, (unsigned long )l_image->numcomps * sizeof(OPJ_BOOL ));
    }
#line 398
    if ((int )l_current_pi->poc.prg == -1) {
      {
#line 400
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 401
      return (0);
    }
    {
#line 403
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 403
      __cil_tmp22 = opj_pi_next(l_current_pi);
      }
#line 403
      if (! __cil_tmp22) {
#line 403
        goto while_break___0;
      }
      {
#line 404
      opj_null_jas_fprintf(stderr, "packet offset=00000166 prg=%d cmptno=%02d rlvlno=%02d prcno=%03d lyrno=%02d\n\n",
                           (int )l_current_pi->poc.prg1, l_current_pi->compno, l_current_pi->resno,
                           l_current_pi->precno, l_current_pi->layno);
      }
#line 407
      if (l_tcp->num_layers_to_decode > l_current_pi->layno) {
#line 407
        if (l_current_pi->resno < (p_tile->comps + l_current_pi->compno)->minimum_num_resolutions) {
          {
#line 409
          l_nb_bytes_read = (OPJ_UINT32 )0;
#line 411
          *(first_pass_failed + l_current_pi->compno) = 0;
#line 413
          __cil_tmp23 = opj_t2_decode_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
                                             & l_nb_bytes_read, p_max_len, l_pack_info);
          }
#line 413
          if (! __cil_tmp23) {
            {
#line 414
            opj_pi_destroy(l_pi, l_nb_pocs);
#line 415
            free(first_pass_failed);
            }
#line 416
            return (0);
          }
          {
#line 419
          l_img_comp = l_image->comps + l_current_pi->compno;
#line 420
          l_img_comp->resno_decoded = opj_uint_max(l_current_pi->resno, l_img_comp->resno_decoded);
          }
        } else {
#line 407
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 423
        l_nb_bytes_read = (OPJ_UINT32 )0;
#line 424
        __cil_tmp25 = opj_t2_skip_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
                                         & l_nb_bytes_read, p_max_len, l_pack_info);
        }
#line 424
        if (! __cil_tmp25) {
          {
#line 425
          opj_pi_destroy(l_pi, l_nb_pocs);
#line 426
          free(first_pass_failed);
          }
#line 427
          return (0);
        }
      }
#line 431
      if (*(first_pass_failed + l_current_pi->compno)) {
#line 432
        l_img_comp = l_image->comps + l_current_pi->compno;
#line 433
        if (l_img_comp->resno_decoded == 0U) {
#line 434
          l_img_comp->resno_decoded = (p_tile->comps + l_current_pi->compno)->minimum_num_resolutions - 1U;
        }
      }
#line 437
      l_current_data += l_nb_bytes_read;
#line 438
      p_max_len -= l_nb_bytes_read;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 463
    l_current_pi ++;
#line 465
    free(first_pass_failed);
    }
#line 383
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 477
  opj_pi_destroy(l_pi, l_nb_pocs);
#line 478
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src);
  }
#line 479
  return (1);
}
}
#line 491 "/root/patron/new_21/src/lib/openjp2/t2.c"
opj_t2_t *opj_t2_create(opj_image_t *p_image , opj_cp_t *p_cp ) 
{ 
  opj_t2_t *l_t2 ;
  void *__cil_tmp4 ;

  {
  {
#line 494
  __cil_tmp4 = calloc((unsigned long )1, sizeof(opj_t2_t ));
#line 494
  l_t2 = (opj_t2_t *)__cil_tmp4;
  }
#line 495
  if (! l_t2) {
#line 496
    return ((opj_t2_t *)((void *)0));
  }
#line 499
  l_t2->image = p_image;
#line 500
  l_t2->cp = p_cp;
#line 502
  return (l_t2);
}
}
#line 505 "/root/patron/new_21/src/lib/openjp2/t2.c"
void opj_t2_destroy(opj_t2_t *t2 ) 
{ 


  {
#line 506
  if (t2) {
    {
#line 507
    free(t2);
    }
  }
  return;
}
}
#line 511 "/root/patron/new_21/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_decode_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                              opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                              OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) 
{ 
  OPJ_BOOL l_read_data ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_total_bytes_read ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 521
  l_nb_bytes_read = (OPJ_UINT32 )0;
#line 522
  l_nb_total_bytes_read = (OPJ_UINT32 )0;
#line 524
  *p_data_read = (OPJ_UINT32 )0;
#line 526
  __cil_tmp12 = opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, & l_read_data,
                                          p_src, & l_nb_bytes_read, p_max_length,
                                          p_pack_info);
  }
#line 526
  if (! __cil_tmp12) {
#line 527
    return (0);
  }
#line 530
  p_src += l_nb_bytes_read;
#line 531
  l_nb_total_bytes_read += l_nb_bytes_read;
#line 532
  p_max_length -= l_nb_bytes_read;
#line 535
  if (l_read_data) {
    {
#line 536
    l_nb_bytes_read = (OPJ_UINT32 )0;
#line 538
    __cil_tmp13 = opj_t2_read_packet_data(p_t2, p_tile, p_pi, p_src, & l_nb_bytes_read,
                                          p_max_length, p_pack_info);
    }
#line 538
    if (! __cil_tmp13) {
#line 539
      return (0);
    }
#line 542
    l_nb_total_bytes_read += l_nb_bytes_read;
  }
#line 545
  *p_data_read = l_nb_total_bytes_read;
#line 547
  return (1);
}
}
#line 550 "/root/patron/new_21/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                              opj_pi_iterator_t *pi , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 length , opj_codestream_info_t *cstr_info ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_BYTE *c ;
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 l_nb_blocks ;
  opj_tcd_band_t *band ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_bio_t *bio ;
  opj_tcd_precinct_t *prc ;
  opj_bio_t *__cil_tmp25 ;
  opj_tcd_precinct_t *prc___0 ;
  opj_tcd_layer_t *layer ;
  opj_tcd_layer_t *layer___0 ;
  OPJ_UINT32 increment ;
  OPJ_UINT32 nump ;
  OPJ_UINT32 len ;
  OPJ_UINT32 passno ;
  OPJ_UINT32 l_nb_passes ;
  OPJ_INT32 __cil_tmp34 ;
  OPJ_INT32 __cil_tmp35 ;
  OPJ_INT32 __cil_tmp36 ;
  OPJ_UINT32 __cil_tmp37 ;
  OPJ_INT32 __cil_tmp38 ;
  OPJ_UINT32 __cil_tmp39 ;
  OPJ_BOOL __cil_tmp40 ;
  ptrdiff_t __cil_tmp41 ;
  opj_packet_info_t *info_PK ;
  opj_tcd_precinct_t *prc___1 ;
  opj_tcd_layer_t *layer___1 ;
  opj_packet_info_t *info_PK___0 ;
  OPJ_UINT32 __cil_tmp46 ;
  int tmp ;

  {
#line 560
  c = dest;
#line 562
  compno = pi->compno;
#line 563
  resno = pi->resno;
#line 564
  precno = pi->precno;
#line 565
  layno = pi->layno;
#line 567
  band = (opj_tcd_band_t *)0;
#line 568
  cblk = (opj_tcd_cblk_enc_t *)0;
#line 569
  pass = (opj_tcd_pass_t *)0;
#line 571
  tilec = tile->comps + compno;
#line 572
  res = tilec->resolutions + resno;
#line 574
  bio = (opj_bio_t *)0;
#line 577
  if (tcp->csty & 2U) {
#line 578
    *(c + 0) = (OPJ_BYTE )255;
#line 579
    *(c + 1) = (OPJ_BYTE )145;
#line 580
    *(c + 2) = (OPJ_BYTE )0;
#line 581
    *(c + 3) = (OPJ_BYTE )4;
#line 586
    *(c + 4) = (OPJ_BYTE )((tile->packno >> 8) & 255U);
#line 587
    *(c + 5) = (OPJ_BYTE )(tile->packno & 255U);
#line 589
    c += 6;
#line 590
    length -= (unsigned int )6;
  }
#line 594
  if (! layno) {
#line 595
    band = (opj_tcd_band_t *)res->bands;
#line 597
    bandno = (OPJ_UINT32 )0;
    {
#line 597
    while (1) {
      while_continue: /* CIL Label */ ;
#line 597
      if (! (bandno < res->numbands)) {
#line 597
        goto while_break;
      }
      {
#line 598
      prc = band->precincts + precno;
#line 600
      opj_tgt_reset(prc->incltree);
#line 601
      opj_tgt_reset(prc->imsbtree);
#line 603
      l_nb_blocks = prc->cw * prc->ch;
#line 604
      cblkno = (OPJ_UINT32 )0;
      }
      {
#line 604
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 604
        if (! (cblkno < l_nb_blocks)) {
#line 604
          goto while_break___0;
        }
        {
#line 605
        cblk = prc->cblks.enc + cblkno;
#line 607
        cblk->numpasses = (OPJ_UINT32 )0;
#line 608
        opj_tgt_setvalue(prc->imsbtree, cblkno, band->numbps - (OPJ_INT32 )cblk->numbps);
        }
#line 604
        cblkno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 610
      band ++;
#line 597
      bandno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 614
  bio = opj_bio_create();
  }
#line 615
  if (! bio) {
#line 617
    return (0);
  }
  {
#line 619
  opj_bio_init_enc(bio, c, length);
#line 620
  opj_bio_write(bio, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
#line 623
  band = (opj_tcd_band_t *)res->bands;
#line 624
  bandno = (OPJ_UINT32 )0;
  }
  {
#line 624
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 624
    if (! (bandno < res->numbands)) {
#line 624
      goto while_break___1;
    }
#line 625
    prc___0 = band->precincts + precno;
#line 627
    l_nb_blocks = prc___0->cw * prc___0->ch;
#line 628
    cblk = prc___0->cblks.enc;
#line 630
    cblkno = (OPJ_UINT32 )0;
    {
#line 630
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 630
      if (! (cblkno < l_nb_blocks)) {
#line 630
        goto while_break___2;
      }
#line 631
      layer = cblk->layers + layno;
#line 633
      if (! cblk->numpasses) {
#line 633
        if (layer->numpasses) {
          {
#line 634
          opj_tgt_setvalue(prc___0->incltree, cblkno, (OPJ_INT32 )layno);
          }
        }
      }
#line 637
      cblk ++;
#line 630
      cblkno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 640
    cblk = prc___0->cblks.enc;
#line 641
    cblkno = (OPJ_UINT32 )0;
    {
#line 641
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 641
      if (! (cblkno < l_nb_blocks)) {
#line 641
        goto while_break___3;
      }
#line 642
      layer___0 = cblk->layers + layno;
#line 643
      increment = (OPJ_UINT32 )0;
#line 644
      nump = (OPJ_UINT32 )0;
#line 645
      len = (OPJ_UINT32 )0;
#line 649
      if (! cblk->numpasses) {
        {
#line 650
        opj_tgt_encode(bio, prc___0->incltree, cblkno, (OPJ_INT32 )(layno + 1U));
        }
      } else {
        {
#line 652
        opj_bio_write(bio, layer___0->numpasses != 0U, (OPJ_UINT32 )1);
        }
      }
#line 656
      if (! layer___0->numpasses) {
#line 657
        cblk ++;
#line 658
        goto while_continue___3;
      }
#line 662
      if (! cblk->numpasses) {
        {
#line 663
        cblk->numlenbits = (OPJ_UINT32 )3;
#line 664
        opj_tgt_encode(bio, prc___0->imsbtree, cblkno, 999);
        }
      }
      {
#line 668
      opj_t2_putnumpasses(bio, layer___0->numpasses);
#line 669
      l_nb_passes = cblk->numpasses + layer___0->numpasses;
#line 670
      pass = cblk->passes + cblk->numpasses;
#line 673
      passno = cblk->numpasses;
      }
      {
#line 673
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 673
        if (! (passno < l_nb_passes)) {
#line 673
          goto while_break___4;
        }
#line 674
        nump ++;
#line 675
        len += pass->len;
#line 677
        if ((int )pass->term) {
          _L: /* CIL Label */ 
          {
#line 678
          __cil_tmp35 = opj_int_floorlog2((OPJ_INT32 )nump);
          }
          {
#line 678
          __cil_tmp34 = opj_int_floorlog2((OPJ_INT32 )len);
#line 678
          __cil_tmp36 = opj_int_max((OPJ_INT32 )increment, (__cil_tmp34 + 1) - ((OPJ_INT32 )cblk->numlenbits + __cil_tmp35));
#line 678
          increment = (OPJ_UINT32 )__cil_tmp36;
#line 680
          len = (OPJ_UINT32 )0;
#line 681
          nump = (OPJ_UINT32 )0;
          }
        } else
#line 677
        if (passno == (cblk->numpasses + layer___0->numpasses) - 1U) {
#line 677
          goto _L;
        }
#line 684
        pass ++;
#line 673
        passno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 686
      opj_t2_putcommacode(bio, (OPJ_INT32 )increment);
#line 689
      cblk->numlenbits += increment;
#line 691
      pass = cblk->passes + cblk->numpasses;
#line 693
      passno = cblk->numpasses;
      }
      {
#line 693
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 693
        if (! (passno < l_nb_passes)) {
#line 693
          goto while_break___5;
        }
#line 694
        nump ++;
#line 695
        len += pass->len;
#line 697
        if ((int )pass->term) {
          {
          {
#line 698
          __cil_tmp38 = opj_int_floorlog2((OPJ_INT32 )nump);
          }
          {
#line 698
          opj_bio_write(bio, (OPJ_UINT32 )len, cblk->numlenbits + (OPJ_UINT32 )__cil_tmp38);
          }
#line 699
          len = (OPJ_UINT32 )0;
#line 700
          nump = (OPJ_UINT32 )0;
          }
        } else
#line 697
        if (passno == (cblk->numpasses + layer___0->numpasses) - 1U) {
          {
          {
#line 698
          __cil_tmp38 = opj_int_floorlog2((OPJ_INT32 )nump);
          }
          {
#line 698
          opj_bio_write(bio, (OPJ_UINT32 )len, cblk->numlenbits + (OPJ_UINT32 )__cil_tmp38);
          }
#line 699
          len = (OPJ_UINT32 )0;
#line 700
          nump = (OPJ_UINT32 )0;
          }
        }
#line 702
        pass ++;
#line 693
        passno ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 705
      cblk ++;
#line 641
      cblkno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 708
    band ++;
#line 624
    bandno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 711
  __cil_tmp40 = opj_bio_flush(bio);
  }
#line 711
  if (! __cil_tmp40) {
    {
#line 712
    opj_bio_destroy(bio);
    }
#line 713
    return (0);
  }
  {
#line 716
  __cil_tmp41 = opj_bio_numbytes(bio);
#line 716
  l_nb_bytes = (OPJ_UINT32 )__cil_tmp41;
#line 717
  c += l_nb_bytes;
#line 718
  length -= l_nb_bytes;
#line 720
  opj_bio_destroy(bio);
  }
#line 723
  if (tcp->csty & 4U) {
#line 724
    *(c + 0) = (OPJ_BYTE )255;
#line 725
    *(c + 1) = (OPJ_BYTE )146;
#line 726
    c += 2;
#line 727
    length -= (unsigned int )2;
  }
#line 734
  if (cstr_info) {
#line 734
    if (cstr_info->index_write) {
#line 735
      info_PK = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 736
      info_PK->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(c - dest));
    }
  }
#line 741
  band = (opj_tcd_band_t *)res->bands;
#line 742
  bandno = (OPJ_UINT32 )0;
  {
#line 742
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 742
    if (! (bandno < res->numbands)) {
#line 742
      goto while_break___6;
    }
#line 743
    prc___1 = band->precincts + precno;
#line 745
    l_nb_blocks = prc___1->cw * prc___1->ch;
#line 746
    cblk = prc___1->cblks.enc;
#line 748
    cblkno = (OPJ_UINT32 )0;
    {
#line 748
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 748
      if (! (cblkno < l_nb_blocks)) {
#line 748
        goto while_break___7;
      }
#line 749
      layer___1 = cblk->layers + layno;
#line 751
      if (! layer___1->numpasses) {
#line 752
        cblk ++;
#line 753
        goto while_continue___7;
      }
#line 756
      if (layer___1->len > length) {
#line 757
        return (0);
      }
      {
#line 760
      memcpy(c, layer___1->data, (unsigned long )layer___1->len);
#line 761
      cblk->numpasses += layer___1->numpasses;
#line 762
      c += layer___1->len;
#line 763
      length -= layer___1->len;
      }
#line 766
      if (cstr_info) {
#line 766
        if (cstr_info->index_write) {
#line 767
          info_PK___0 = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 768
          info_PK___0->disto += layer___1->disto;
#line 769
          if (cstr_info->D_max < info_PK___0->disto) {
#line 770
            cstr_info->D_max = info_PK___0->disto;
          }
        }
      }
#line 774
      cblk ++;
#line 748
      cblkno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 777
    band ++;
#line 742
    bandno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 781
  *p_data_written += (OPJ_UINT32 )(c - dest);
#line 783
  return (1);
}
}
#line 786 "/root/patron/new_21/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_skip_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) 
{ 
  OPJ_BOOL l_read_data ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_total_bytes_read ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 796
  l_nb_bytes_read = (OPJ_UINT32 )0;
#line 797
  l_nb_total_bytes_read = (OPJ_UINT32 )0;
#line 799
  *p_data_read = (OPJ_UINT32 )0;
#line 801
  __cil_tmp12 = opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, & l_read_data,
                                          p_src, & l_nb_bytes_read, p_max_length,
                                          p_pack_info);
  }
#line 801
  if (! __cil_tmp12) {
#line 802
    return (0);
  }
#line 805
  p_src += l_nb_bytes_read;
#line 806
  l_nb_total_bytes_read += l_nb_bytes_read;
#line 807
  p_max_length -= l_nb_bytes_read;
#line 810
  if (l_read_data) {
    {
#line 811
    l_nb_bytes_read = (OPJ_UINT32 )0;
#line 813
    __cil_tmp13 = opj_t2_skip_packet_data(p_t2, p_tile, p_pi, & l_nb_bytes_read, p_max_length,
                                          p_pack_info);
    }
#line 813
    if (! __cil_tmp13) {
#line 814
      return (0);
    }
#line 817
    l_nb_total_bytes_read += l_nb_bytes_read;
  }
#line 819
  *p_data_read = l_nb_total_bytes_read;
#line 821
  return (1);
}
}
#line 825 "/root/patron/new_21/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_read_packet_header(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BOOL *p_is_data_present ,
                                   OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_UINT32 l_remaining_length ;
  OPJ_UINT32 l_header_length ;
  OPJ_UINT32 *l_modified_length_ptr ;
  OPJ_BYTE *l_current_data ;
  opj_cp_t *l_cp ;
  opj_bio_t *l_bio ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  OPJ_BYTE *l_header_data ;
  OPJ_BYTE **l_header_data_start ;
  OPJ_UINT32 l_present ;
  opj_tcd_precinct_t *l_prc ;
  opj_bio_t *__cil_tmp26 ;
  OPJ_UINT32 __cil_tmp27 ;
  ptrdiff_t __cil_tmp28 ;
  opj_tcd_precinct_t *l_prc___0 ;
  OPJ_UINT32 l_included ;
  OPJ_UINT32 l_increment ;
  OPJ_UINT32 l_segno ;
  OPJ_INT32 n ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp37 ;
  OPJ_UINT32 __cil_tmp38 ;
  OPJ_UINT32 __cil_tmp39 ;
  OPJ_BOOL __cil_tmp40 ;
  OPJ_BOOL __cil_tmp41 ;
  OPJ_INT32 __cil_tmp42 ;
  OPJ_UINT32 __cil_tmp43 ;
  OPJ_UINT32 __cil_tmp44 ;
  OPJ_BOOL __cil_tmp45 ;
  OPJ_UINT32 __cil_tmp46 ;
  OPJ_BOOL __cil_tmp47 ;
  ptrdiff_t __cil_tmp48 ;

  {
#line 841
  l_modified_length_ptr = (OPJ_UINT32 *)0;
#line 842
  l_current_data = p_src_data;
#line 843
  l_cp = p_t2->cp;
#line 844
  l_bio = (opj_bio_t *)0;
#line 845
  l_band = (opj_tcd_band_t *)0;
#line 846
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 847
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 849
  l_header_data = (OPJ_BYTE *)0;
#line 850
  l_header_data_start = (OPJ_BYTE **)0;
#line 854
  if (p_pi->layno == 0U) {
#line 855
    l_band = (opj_tcd_band_t *)l_res->bands;
#line 858
    bandno = (OPJ_UINT32 )0;
    {
#line 858
    while (1) {
      while_continue: /* CIL Label */ ;
#line 858
      if (! (bandno < l_res->numbands)) {
#line 858
        goto while_break;
      }
#line 859
      l_prc = l_band->precincts + p_pi->precno;
#line 861
      if (! (l_band->x1 - l_band->x0 == 0 || l_band->y1 - l_band->y0 == 0)) {
        {
#line 862
        opj_tgt_reset(l_prc->incltree);
#line 863
        opj_tgt_reset(l_prc->imsbtree);
#line 864
        l_cblk = l_prc->cblks.dec;
#line 866
        l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 867
        cblkno = (OPJ_UINT32 )0;
        }
        {
#line 867
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 867
          if (! (cblkno < l_nb_code_blocks)) {
#line 867
            goto while_break___0;
          }
#line 868
          l_cblk->numsegs = (OPJ_UINT32 )0;
#line 869
          l_cblk->real_num_segs = (OPJ_UINT32 )0;
#line 870
          l_cblk ++;
#line 867
          cblkno ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 874
      l_band ++;
#line 858
      bandno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 880
  if (p_tcp->csty & 2U) {
#line 881
    if (p_max_length < 6U) {
      {
#line 883
      fprintf(stderr, "Not enough space for expected SOP marker\n");
      }
    } else
#line 884
    if ((int )*l_current_data != 255) {
      {
      {
#line 886
      fprintf(stderr, "Warning: expected SOP marker\nU");
      }
      }
    } else
#line 884
    if ((int )*(l_current_data + 1) != 145) {
      {
      {
#line 886
      fprintf(stderr, "Warning: expected SOP marker\nU");
      }
      }
    } else {
#line 888
      l_current_data += 6;
    }
  }
  {
#line 901
  l_bio = opj_bio_create();
  }
#line 902
  if (! l_bio) {
#line 903
    return (0);
  }
#line 906
  if ((int )l_cp->ppm == 1) {
#line 907
    l_header_data_start = & l_cp->ppm_data;
#line 908
    l_header_data = *l_header_data_start;
#line 909
    l_modified_length_ptr = & l_cp->ppm_len;
  } else
#line 912
  if ((int )p_tcp->ppt == 1) {
#line 913
    l_header_data_start = & p_tcp->ppt_data;
#line 914
    l_header_data = *l_header_data_start;
#line 915
    l_modified_length_ptr = & p_tcp->ppt_len;
  } else {
#line 918
    l_header_data_start = & l_current_data;
#line 919
    l_header_data = *l_header_data_start;
#line 920
    l_remaining_length = (OPJ_UINT32 )((p_src_data + p_max_length) - l_header_data);
#line 921
    l_modified_length_ptr = & l_remaining_length;
  }
  {
#line 924
  opj_bio_init_dec(l_bio, l_header_data, *l_modified_length_ptr);
#line 926
  l_present = opj_bio_read(l_bio, (OPJ_UINT32 )1);
#line 927
  opj_null_jas_fprintf(stderr, "present=%d \n\347U", l_present);
  }
#line 928
  if (! l_present) {
    {
#line 930
    opj_bio_inalign(l_bio);
#line 931
    __cil_tmp28 = opj_bio_numbytes(l_bio);
    }
    {
#line 931
    l_header_data += __cil_tmp28;
#line 932
    opj_bio_destroy(l_bio);
    }
#line 935
    if (p_tcp->csty & 4U) {
#line 936
      if (*l_modified_length_ptr - (OPJ_UINT32 )(l_header_data - *l_header_data_start) < 2U) {
        {
#line 937
        fprintf(stderr, "Not enough space for expected EPH marker\n\327\262h\347U");
        }
      } else
#line 938
      if ((int )*l_header_data != 255) {
        {
        {
#line 939
        fprintf(stderr, "Error : expected EPH marker\n");
        }
        }
      } else
#line 938
      if ((int )*(l_header_data + 1) != 146) {
        {
        {
#line 939
        fprintf(stderr, "Error : expected EPH marker\n");
        }
        }
      } else {
#line 941
        l_header_data += 2;
      }
    }
#line 945
    l_header_length = (OPJ_UINT32 )(l_header_data - *l_header_data_start);
#line 946
    *l_modified_length_ptr -= l_header_length;
#line 947
    *l_header_data_start += l_header_length;
#line 952
    if (p_pack_info) {
#line 953
      p_pack_info->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(l_current_data - p_src_data));
    }
#line 957
    *p_is_data_present = 0;
#line 958
    *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 959
    return (1);
  }
#line 962
  l_band = (opj_tcd_band_t *)l_res->bands;
#line 963
  bandno = (OPJ_UINT32 )0;
  {
#line 963
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 963
    if (! (bandno < l_res->numbands)) {
#line 963
      goto while_break___1;
    }
#line 964
    l_prc___0 = l_band->precincts + p_pi->precno;
#line 966
    if (l_band->x1 - l_band->x0 == 0) {
#line 967
      l_band ++;
#line 968
      goto while_continue___1;
    } else
#line 966
    if (l_band->y1 - l_band->y0 == 0) {
#line 967
      l_band ++;
#line 968
      goto while_continue___1;
    }
#line 971
    l_nb_code_blocks = l_prc___0->cw * l_prc___0->ch;
#line 972
    l_cblk = l_prc___0->cblks.dec;
#line 973
    cblkno = (OPJ_UINT32 )0;
    {
#line 973
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 973
      if (! (cblkno < l_nb_code_blocks)) {
#line 973
        goto while_break___2;
      }
#line 978
      if (! l_cblk->numsegs) {
        {
#line 979
        l_included = opj_tgt_decode(l_bio, l_prc___0->incltree, cblkno, (OPJ_INT32 )(p_pi->layno + 1U));
        }
      } else {
        {
#line 983
        l_included = opj_bio_read(l_bio, (OPJ_UINT32 )1);
        }
      }
#line 987
      if (! l_included) {
        {
#line 988
        l_cblk->numnewpasses = (OPJ_UINT32 )0;
#line 989
        l_cblk ++;
#line 990
        opj_null_jas_fprintf(stderr, "included=%d \nU", l_included);
        }
#line 991
        goto while_continue___2;
      }
#line 995
      if (! l_cblk->numsegs) {
#line 996
        i = (OPJ_UINT32 )0;
        {
#line 998
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 998
          __cil_tmp37 = opj_tgt_decode(l_bio, l_prc___0->imsbtree, cblkno, (OPJ_INT32 )i);
          }
#line 998
          if (! (! __cil_tmp37)) {
#line 998
            goto while_break___3;
          }
#line 999
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1002
        l_cblk->numbps = ((OPJ_UINT32 )l_band->numbps + 1U) - i;
#line 1003
        l_cblk->numlenbits = (OPJ_UINT32 )3;
      }
      {
#line 1007
      l_cblk->numnewpasses = opj_t2_getnumpasses(l_bio);
#line 1008
      l_increment = opj_t2_getcommacode(l_bio);
#line 1011
      l_cblk->numlenbits += l_increment;
#line 1012
      l_segno = (OPJ_UINT32 )0;
      }
#line 1014
      if (! l_cblk->numsegs) {
        {
#line 1015
        __cil_tmp40 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                      (OPJ_UINT32 )1);
        }
#line 1015
        if (! __cil_tmp40) {
          {
#line 1016
          opj_bio_destroy(l_bio);
          }
#line 1017
          return (0);
        }
      } else {
#line 1021
        l_segno = l_cblk->numsegs - 1U;
#line 1022
        if ((l_cblk->segs + l_segno)->numpasses == (l_cblk->segs + l_segno)->maxpasses) {
          {
#line 1023
          l_segno ++;
#line 1024
          __cil_tmp41 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                        (OPJ_UINT32 )0);
          }
#line 1024
          if (! __cil_tmp41) {
            {
#line 1025
            opj_bio_destroy(l_bio);
            }
#line 1026
            return (0);
          }
        }
      }
#line 1030
      n = (OPJ_INT32 )l_cblk->numnewpasses;
      {
#line 1032
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1033
        __cil_tmp42 = opj_int_min((OPJ_INT32 )((l_cblk->segs + l_segno)->maxpasses - (l_cblk->segs + l_segno)->numpasses),
                                  n);
#line 1033
        (l_cblk->segs + l_segno)->numnewpasses = (OPJ_UINT32 )__cil_tmp42;
#line 1034
        __cil_tmp43 = opj_uint_floorlog2((l_cblk->segs + l_segno)->numnewpasses);
#line 1034
        __cil_tmp44 = opj_bio_read(l_bio, l_cblk->numlenbits + __cil_tmp43);
#line 1034
        (l_cblk->segs + l_segno)->newlen = __cil_tmp44;
#line 1035
        opj_null_jas_fprintf(stderr, "included=%d numnewpasses=%d increment=%d len=%d \n~\262h\347U",
                             l_included, (l_cblk->segs + l_segno)->numnewpasses, l_increment,
                             (l_cblk->segs + l_segno)->newlen);
#line 1037
        n -= (OPJ_INT32 )(l_cblk->segs + l_segno)->numnewpasses;
        }
#line 1038
        if (n > 0) {
          {
#line 1039
          l_segno ++;
#line 1041
          __cil_tmp45 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                        (OPJ_UINT32 )0);
          }
#line 1041
          if (! __cil_tmp45) {
            {
#line 1042
            opj_bio_destroy(l_bio);
            }
#line 1043
            return (0);
          }
        }
#line 1032
        if (! (n > 0)) {
#line 1032
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1048
      l_cblk ++;
#line 973
      cblkno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1051
    l_band ++;
#line 963
    bandno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1054
  __cil_tmp47 = opj_bio_inalign(l_bio);
  }
#line 1054
  if (! __cil_tmp47) {
    {
#line 1055
    opj_bio_destroy(l_bio);
    }
#line 1056
    return (0);
  }
  {
#line 1059
  __cil_tmp48 = opj_bio_numbytes(l_bio);
  }
  {
#line 1059
  l_header_data += __cil_tmp48;
#line 1060
  opj_bio_destroy(l_bio);
  }
#line 1063
  if (p_tcp->csty & 4U) {
#line 1064
    if (*l_modified_length_ptr - (OPJ_UINT32 )(l_header_data - *l_header_data_start) < 2U) {
      {
#line 1065
      fprintf(stderr, "Not enough space for expected EPH marker\n");
      }
    } else
#line 1066
    if ((int )*l_header_data != 255) {
      {
      {
#line 1068
      fprintf(stderr, "Error : expected EPH marker\n");
      }
      }
    } else
#line 1066
    if ((int )*(l_header_data + 1) != 146) {
      {
      {
#line 1068
      fprintf(stderr, "Error : expected EPH marker\n");
      }
      }
    } else {
#line 1070
      l_header_data += 2;
    }
  }
  {
#line 1074
  l_header_length = (OPJ_UINT32 )(l_header_data - *l_header_data_start);
#line 1075
  opj_null_jas_fprintf(stderr, "hdrlen=%d \n", l_header_length);
#line 1076
  opj_null_jas_fprintf(stderr, "packet body\n");
#line 1077
  *l_modified_length_ptr -= l_header_length;
#line 1078
  *l_header_data_start += l_header_length;
  }
#line 1083
  if (p_pack_info) {
#line 1084
    p_pack_info->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(l_current_data - p_src_data));
  }
#line 1088
  *p_is_data_present = 1;
#line 1089
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 1091
  return (1);
}
}
#line 1094 "/root/patron/new_21/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_read_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_pi_iterator_t *p_pi ,
                                 OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                 OPJ_UINT32 p_max_length , opj_packet_info_t *pack_info ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_BYTE *l_current_data ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_precinct_t *l_prc ;
  opj_tcd_seg_t *l_seg ;
  OPJ_BYTE *new_cblk_data ;
  void *__cil_tmp18 ;

  {
#line 1104
  l_current_data = p_src_data;
#line 1105
  l_band = (opj_tcd_band_t *)0;
#line 1106
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 1107
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 1112
  l_band = (opj_tcd_band_t *)l_res->bands;
#line 1113
  bandno = (OPJ_UINT32 )0;
  {
#line 1113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1113
    if (! (bandno < l_res->numbands)) {
#line 1113
      goto while_break;
    }
#line 1114
    l_prc = l_band->precincts + p_pi->precno;
#line 1116
    if (l_band->x1 - l_band->x0 == 0) {
#line 1117
      l_band ++;
#line 1118
      goto while_continue;
    } else
#line 1116
    if (l_band->y1 - l_band->y0 == 0) {
#line 1117
      l_band ++;
#line 1118
      goto while_continue;
    }
#line 1121
    l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 1122
    l_cblk = l_prc->cblks.dec;
#line 1124
    cblkno = (OPJ_UINT32 )0;
    {
#line 1124
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1124
      if (! (cblkno < l_nb_code_blocks)) {
#line 1124
        goto while_break___0;
      }
#line 1125
      l_seg = (opj_tcd_seg_t *)0;
#line 1127
      if (! l_cblk->numnewpasses) {
#line 1129
        l_cblk ++;
#line 1130
        goto while_continue___0;
      }
#line 1133
      if (! l_cblk->numsegs) {
#line 1134
        l_seg = l_cblk->segs;
#line 1135
        (l_cblk->numsegs) ++;
#line 1136
        l_cblk->data_current_size = (OPJ_UINT32 )0;
      } else {
#line 1139
        l_seg = l_cblk->segs + (l_cblk->numsegs - 1U);
#line 1141
        if (l_seg->numpasses == l_seg->maxpasses) {
#line 1142
          l_seg ++;
#line 1143
          (l_cblk->numsegs) ++;
        }
      }
      {
#line 1147
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1149
        if (l_current_data + l_seg->newlen > p_src_data + p_max_length) {
          {
          {
#line 1150
          fprintf(stderr, "read: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n",
                  l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno, p_pi->resno,
                  p_pi->compno);
          }
          }
#line 1152
          return (0);
        } else
#line 1149
        if ((OPJ_SIZE_T )l_current_data + (OPJ_SIZE_T )l_seg->newlen < (OPJ_SIZE_T )l_current_data) {
          {
          {
#line 1150
          fprintf(stderr, "read: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n",
                  l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno, p_pi->resno,
                  p_pi->compno);
          }
          }
#line 1152
          return (0);
        }
#line 1175
        if (l_cblk->data_current_size + l_seg->newlen < l_cblk->data_current_size) {
          {
#line 1176
          fprintf(stderr, "read: segment too long (%d) with current size (%d > %d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n\264h\347U",
                  l_seg->newlen, l_cblk->data_current_size, 4294967295U - l_seg->newlen,
                  cblkno, p_pi->precno, bandno, p_pi->resno, p_pi->compno);
          }
#line 1178
          return (0);
        }
#line 1181
        if (l_cblk->data_current_size + l_seg->newlen > l_cblk->data_max_size) {
          {
#line 1182
          __cil_tmp18 = realloc(l_cblk->data, (unsigned long )(l_cblk->data_current_size + l_seg->newlen));
#line 1182
          new_cblk_data = (OPJ_BYTE *)__cil_tmp18;
          }
#line 1183
          if (! new_cblk_data) {
            {
#line 1184
            free(l_cblk->data);
#line 1185
            l_cblk->data = (OPJ_BYTE *)((void *)0);
#line 1186
            l_cblk->data_max_size = (OPJ_UINT32 )0;
            }
#line 1188
            return (0);
          }
#line 1190
          l_cblk->data_max_size = l_cblk->data_current_size + l_seg->newlen;
#line 1191
          l_cblk->data = new_cblk_data;
        }
        {
#line 1194
        memcpy(l_cblk->data + l_cblk->data_current_size, l_current_data, (unsigned long )l_seg->newlen);
        }
#line 1196
        if (l_seg->numpasses == 0U) {
#line 1197
          l_seg->data = & l_cblk->data;
#line 1198
          l_seg->dataindex = l_cblk->data_current_size;
        }
#line 1201
        l_current_data += l_seg->newlen;
#line 1202
        l_seg->numpasses += l_seg->numnewpasses;
#line 1203
        l_cblk->numnewpasses -= l_seg->numnewpasses;
#line 1205
        l_seg->real_num_passes = l_seg->numpasses;
#line 1206
        l_cblk->data_current_size += l_seg->newlen;
#line 1207
        l_seg->len += l_seg->newlen;
#line 1209
        if (l_cblk->numnewpasses > 0U) {
#line 1210
          l_seg ++;
#line 1211
          (l_cblk->numsegs) ++;
        }
#line 1147
        if (! (l_cblk->numnewpasses > 0U)) {
#line 1147
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1215
      l_cblk->real_num_segs = l_cblk->numsegs;
#line 1216
      l_cblk ++;
#line 1124
      cblkno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1219
    l_band ++;
#line 1113
    bandno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1222
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 1225
  return (1);
}
}
#line 1228 "/root/patron/new_21/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_skip_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_pi_iterator_t *p_pi ,
                                 OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                 opj_packet_info_t *pack_info ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_precinct_t *l_prc ;
  opj_tcd_seg_t *l_seg ;

  {
#line 1237
  l_band = (opj_tcd_band_t *)0;
#line 1238
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 1239
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 1244
  *p_data_read = (OPJ_UINT32 )0;
#line 1245
  l_band = (opj_tcd_band_t *)l_res->bands;
#line 1247
  bandno = (OPJ_UINT32 )0;
  {
#line 1247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1247
    if (! (bandno < l_res->numbands)) {
#line 1247
      goto while_break;
    }
#line 1248
    l_prc = l_band->precincts + p_pi->precno;
#line 1250
    if (l_band->x1 - l_band->x0 == 0) {
#line 1251
      l_band ++;
#line 1252
      goto while_continue;
    } else
#line 1250
    if (l_band->y1 - l_band->y0 == 0) {
#line 1251
      l_band ++;
#line 1252
      goto while_continue;
    }
#line 1255
    l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 1256
    l_cblk = l_prc->cblks.dec;
#line 1258
    cblkno = (OPJ_UINT32 )0;
    {
#line 1258
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1258
      if (! (cblkno < l_nb_code_blocks)) {
#line 1258
        goto while_break___0;
      }
#line 1259
      l_seg = (opj_tcd_seg_t *)0;
#line 1261
      if (! l_cblk->numnewpasses) {
#line 1263
        l_cblk ++;
#line 1264
        goto while_continue___0;
      }
#line 1267
      if (! l_cblk->numsegs) {
#line 1268
        l_seg = l_cblk->segs;
#line 1269
        (l_cblk->numsegs) ++;
#line 1270
        l_cblk->data_current_size = (OPJ_UINT32 )0;
      } else {
#line 1273
        l_seg = l_cblk->segs + (l_cblk->numsegs - 1U);
#line 1275
        if (l_seg->numpasses == l_seg->maxpasses) {
#line 1276
          l_seg ++;
#line 1277
          (l_cblk->numsegs) ++;
        }
      }
      {
#line 1281
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1283
        if (*p_data_read + l_seg->newlen < *p_data_read) {
          {
          {
#line 1284
          fprintf(stderr, "skip: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n\347U",
                  l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno, p_pi->resno,
                  p_pi->compno);
          }
          }
#line 1286
          return (0);
        } else
#line 1283
        if (*p_data_read + l_seg->newlen > p_max_length) {
          {
          {
#line 1284
          fprintf(stderr, "skip: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n\347U",
                  l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno, p_pi->resno,
                  p_pi->compno);
          }
          }
#line 1286
          return (0);
        }
        {
#line 1308
        opj_null_jas_fprintf(stderr, "p_data_read (%d) newlen (%d) \n", *p_data_read,
                             l_seg->newlen);
#line 1309
        *p_data_read += l_seg->newlen;
#line 1311
        l_seg->numpasses += l_seg->numnewpasses;
#line 1312
        l_cblk->numnewpasses -= l_seg->numnewpasses;
        }
#line 1313
        if (l_cblk->numnewpasses > 0U) {
#line 1315
          l_seg ++;
#line 1316
          (l_cblk->numsegs) ++;
        }
#line 1281
        if (! (l_cblk->numnewpasses > 0U)) {
#line 1281
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1320
      l_cblk ++;
#line 1258
      cblkno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1323
    l_band ++;
#line 1247
    bandno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1326
  return (1);
}
}
#line 1330 "/root/patron/new_21/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_init_seg(opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 index___0 , OPJ_UINT32 cblksty ,
                         OPJ_UINT32 first ) 
{ 
  opj_tcd_seg_t *seg ;
  OPJ_UINT32 l_nb_segs ;
  opj_tcd_seg_t *new_segs ;
  void *__cil_tmp8 ;
  int tmp ;

  {
#line 1335
  seg = (opj_tcd_seg_t *)0;
#line 1336
  l_nb_segs = index___0 + 1U;
#line 1338
  if (l_nb_segs > cblk->m_current_max_segs) {
    {
#line 1340
    cblk->m_current_max_segs += (unsigned int )10;
#line 1342
    __cil_tmp8 = realloc(cblk->segs, (unsigned long )cblk->m_current_max_segs * sizeof(opj_tcd_seg_t ));
#line 1342
    new_segs = (opj_tcd_seg_t *)__cil_tmp8;
    }
#line 1343
    if (! new_segs) {
      {
#line 1344
      free(cblk->segs);
#line 1345
      cblk->segs = (opj_tcd_seg_t *)((void *)0);
#line 1346
      cblk->m_current_max_segs = (OPJ_UINT32 )0;
      }
#line 1348
      return (0);
    }
#line 1350
    cblk->segs = new_segs;
  }
  {
#line 1353
  seg = cblk->segs + index___0;
#line 1354
  memset(seg, 0, sizeof(opj_tcd_seg_t ));
  }
#line 1356
  if (cblksty & 4U) {
#line 1357
    seg->maxpasses = (OPJ_UINT32 )1;
  } else
#line 1359
  if (cblksty & 1U) {
#line 1360
    if (first) {
#line 1361
      seg->maxpasses = (OPJ_UINT32 )10;
    } else {
#line 1363
      if ((seg - 1)->maxpasses == 1U || (seg - 1)->maxpasses == 10U) {
#line 1363
        tmp = 2;
      } else {
#line 1363
        tmp = 1;
      }
#line 1363
      seg->maxpasses = (OPJ_UINT32 )tmp;
    }
  } else {
#line 1366
    seg->maxpasses = (OPJ_UINT32 )109;
  }
#line 1369
  return (1);
}
}
#line 52 "/root/patron/new_21/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t *pi ) ;
#line 58
OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t *pi ) ;
#line 64
OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t *pi ) ;
#line 70
OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t *pi ) ;
#line 76
OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t *pi ) ;
#line 92
void opj_pi_update_encode_poc_and_final(opj_cp_t *p_cp , OPJ_UINT32 p_tileno , OPJ_INT32 p_tx0 ,
                                        OPJ_INT32 p_tx1 , OPJ_INT32 p_ty0 , OPJ_INT32 p_ty1 ,
                                        OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                        OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) ;
#line 118
void opj_pi_update_encode_not_poc(opj_cp_t *p_cp , OPJ_UINT32 p_num_comps , OPJ_UINT32 p_tileno ,
                                  OPJ_INT32 p_tx0 , OPJ_INT32 p_tx1 , OPJ_INT32 p_ty0 ,
                                  OPJ_INT32 p_ty1 , OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                  OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) ;
#line 144
void opj_get_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tileno ,
                                 OPJ_INT32 *p_tx0 , OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                 OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                 OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ) ;
#line 176
void opj_get_all_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 tileno ,
                                     OPJ_INT32 *p_tx0 , OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                     OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                     OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ,
                                     OPJ_UINT32 **p_resolutions ) ;
#line 196
opj_pi_iterator_t *opj_pi_create(opj_image_t *image , opj_cp_t *cp , OPJ_UINT32 tileno ) ;
#line 202
void opj_pi_update_decode_not_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp , OPJ_UINT32 p_max_precision ,
                                  OPJ_UINT32 p_max_res ) ;
#line 209
void opj_pi_update_decode_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp , OPJ_UINT32 p_max_precision ,
                              OPJ_UINT32 p_max_res ) ;
#line 217
OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos , opj_cp_t *cp , OPJ_UINT32 tileno ,
                                 OPJ_UINT32 pino , OPJ_CHAR *prog ) ;
#line 233 "/root/patron/new_21/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___4 ;
  OPJ_UINT32 __cil_tmp5 ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;

  {
#line 234
  comp = (opj_pi_comp_t *)((void *)0);
#line 235
  res = (opj_pi_resolution_t *)((void *)0);
#line 236
  index___4 = (OPJ_UINT32 )0;
#line 238
  if (! pi->first) {
#line 239
    comp = pi->comps + pi->compno;
#line 240
    res = comp->resolutions + pi->resno;
#line 241
    goto LABEL_SKIP;
  } else {
#line 243
    pi->first = 0;
  }
#line 246
  pi->layno = pi->poc.layno0;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (pi->layno < pi->poc.layno1)) {
#line 246
      goto while_break;
    }
#line 247
    pi->resno = pi->poc.resno0;
    {
#line 247
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 247
      if (! (pi->resno < pi->poc.resno1)) {
#line 247
        goto while_break___0;
      }
#line 249
      pi->compno = pi->poc.compno0;
      {
#line 249
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 249
        if (! (pi->compno < pi->poc.compno1)) {
#line 249
          goto while_break___1;
        }
#line 250
        comp = pi->comps + pi->compno;
#line 251
        if (pi->resno >= comp->numresolutions) {
#line 252
          goto while_continue___1;
        }
#line 254
        res = comp->resolutions + pi->resno;
#line 255
        if (! pi->tp_on) {
#line 256
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 258
        pi->precno = pi->poc.precno0;
        {
#line 258
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 258
          if (! (pi->precno < pi->poc.precno1)) {
#line 258
            goto while_break___2;
          }
#line 259
          index___4 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 260
          if (! *(pi->include + index___4)) {
#line 261
            *(pi->include + index___4) = (OPJ_INT16 )1;
#line 262
            return (1);
          }
          LABEL_SKIP: ;
#line 258
          (pi->precno) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 249
        (pi->compno) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 248
      (pi->resno) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 246
    (pi->layno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  return (0);
}
}
#line 273 "/root/patron/new_21/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___5 ;
  OPJ_UINT32 __cil_tmp5 ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;

  {
#line 274
  comp = (opj_pi_comp_t *)((void *)0);
#line 275
  res = (opj_pi_resolution_t *)((void *)0);
#line 276
  index___5 = (OPJ_UINT32 )0;
#line 278
  if (! pi->first) {
#line 279
    comp = pi->comps + pi->compno;
#line 280
    res = comp->resolutions + pi->resno;
#line 281
    goto LABEL_SKIP;
  } else {
#line 283
    pi->first = 0;
  }
#line 286
  pi->resno = pi->poc.resno0;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! (pi->resno < pi->poc.resno1)) {
#line 286
      goto while_break;
    }
#line 287
    pi->layno = pi->poc.layno0;
    {
#line 287
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 287
      if (! (pi->layno < pi->poc.layno1)) {
#line 287
        goto while_break___0;
      }
#line 288
      pi->compno = pi->poc.compno0;
      {
#line 288
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 288
        if (! (pi->compno < pi->poc.compno1)) {
#line 288
          goto while_break___1;
        }
#line 289
        comp = pi->comps + pi->compno;
#line 290
        if (pi->resno >= comp->numresolutions) {
#line 291
          goto while_continue___1;
        }
#line 293
        res = comp->resolutions + pi->resno;
#line 294
        if (! pi->tp_on) {
#line 295
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 297
        pi->precno = pi->poc.precno0;
        {
#line 297
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 297
          if (! (pi->precno < pi->poc.precno1)) {
#line 297
            goto while_break___2;
          }
#line 298
          index___5 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 299
          if (! *(pi->include + index___5)) {
#line 300
            *(pi->include + index___5) = (OPJ_INT16 )1;
#line 301
            return (1);
          }
          LABEL_SKIP: ;
#line 297
          (pi->precno) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 288
        (pi->compno) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 287
      (pi->layno) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 286
    (pi->resno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  return (0);
}
}
#line 312 "/root/patron/new_21/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___6 ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 __cil_tmp14 ;
  OPJ_UINT32 levelno ;
  OPJ_INT32 trx0 ;
  OPJ_INT32 try0 ;
  OPJ_INT32 trx1 ;
  OPJ_INT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_INT32 prci ;
  OPJ_INT32 prcj ;
  OPJ_INT32 __cil_tmp24 ;
  OPJ_INT32 __cil_tmp25 ;
  OPJ_INT32 __cil_tmp26 ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_INT32 __cil_tmp32 ;
  OPJ_INT32 __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 __cil_tmp36 ;

  {
#line 313
  comp = (opj_pi_comp_t *)((void *)0);
#line 314
  res = (opj_pi_resolution_t *)((void *)0);
#line 315
  index___6 = (OPJ_UINT32 )0;
#line 317
  if (! pi->first) {
#line 318
    goto LABEL_SKIP;
  } else {
#line 321
    pi->first = 0;
#line 322
    pi->dx = (OPJ_UINT32 )0;
#line 323
    pi->dy = (OPJ_UINT32 )0;
#line 324
    compno = (OPJ_UINT32 )0;
    {
#line 324
    while (1) {
      while_continue: /* CIL Label */ ;
#line 324
      if (! (compno < pi->numcomps)) {
#line 324
        goto while_break;
      }
#line 325
      comp = pi->comps + compno;
#line 326
      resno = (OPJ_UINT32 )0;
      {
#line 326
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 326
        if (! (resno < comp->numresolutions)) {
#line 326
          goto while_break___0;
        }
#line 328
        res = comp->resolutions + resno;
#line 329
        dx = comp->dx * (1U << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 330
        dy = comp->dy * (1U << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 331
        if (! pi->dx) {
#line 331
          tmp = dx;
        } else {
          {
#line 331
          __cil_tmp9 = opj_uint_min(pi->dx, dx);
#line 331
          tmp = __cil_tmp9;
          }
        }
#line 331
        pi->dx = tmp;
#line 332
        if (! pi->dy) {
#line 332
          tmp___0 = dy;
        } else {
          {
#line 332
          __cil_tmp11 = opj_uint_min(pi->dy, dy);
#line 332
          tmp___0 = __cil_tmp11;
          }
        }
#line 332
        pi->dy = tmp___0;
#line 326
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 324
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 336
  if (! pi->tp_on) {
#line 337
    pi->poc.ty0 = pi->ty0;
#line 338
    pi->poc.tx0 = pi->tx0;
#line 339
    pi->poc.ty1 = pi->ty1;
#line 340
    pi->poc.tx1 = pi->tx1;
  }
#line 342
  pi->resno = pi->poc.resno0;
  {
#line 342
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 342
    if (! (pi->resno < pi->poc.resno1)) {
#line 342
      goto while_break___1;
    }
#line 343
    pi->y = pi->poc.ty0;
    {
#line 343
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 343
      if (! (pi->y < pi->poc.ty1)) {
#line 343
        goto while_break___2;
      }
#line 344
      pi->x = pi->poc.tx0;
      {
#line 344
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 344
        if (! (pi->x < pi->poc.tx1)) {
#line 344
          goto while_break___3;
        }
#line 345
        pi->compno = pi->poc.compno0;
        {
#line 345
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 345
          if (! (pi->compno < pi->poc.compno1)) {
#line 345
            goto while_break___4;
          }
#line 351
          comp = pi->comps + pi->compno;
#line 352
          if (pi->resno >= comp->numresolutions) {
#line 353
            goto while_continue___4;
          }
          {
#line 355
          res = comp->resolutions + pi->resno;
#line 356
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 357
          trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32 )(comp->dx << levelno));
#line 358
          try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32 )(comp->dy << levelno));
#line 359
          trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32 )(comp->dx << levelno));
#line 360
          try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32 )(comp->dy << levelno));
#line 361
          rpx = res->pdx + levelno;
#line 362
          rpy = res->pdy + levelno;
          }
#line 363
          if (! (pi->y % (OPJ_INT32 )(comp->dy << rpy) == 0 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpy)))) {
#line 364
            goto while_continue___4;
          }
#line 366
          if (! (pi->x % (OPJ_INT32 )(comp->dx << rpx) == 0 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
#line 367
            goto while_continue___4;
          }
#line 370
          if (res->pw == 0U) {
#line 370
            goto while_continue___4;
          } else
#line 370
          if (res->ph == 0U) {
#line 370
            goto while_continue___4;
          }
#line 372
          if (trx0 == trx1) {
#line 372
            goto while_continue___4;
          } else
#line 372
          if (try0 == try1) {
#line 372
            goto while_continue___4;
          }
          {
#line 374
          __cil_tmp30 = opj_int_floordivpow2(trx0, (OPJ_INT32 )res->pdx);
          }
          {
#line 374
          __cil_tmp28 = opj_int_ceildiv(pi->x, (OPJ_INT32 )(comp->dx << levelno));
#line 374
          __cil_tmp29 = opj_int_floordivpow2(__cil_tmp28, (OPJ_INT32 )res->pdx);
#line 374
          prci = __cil_tmp29 - __cil_tmp30;
#line 376
          __cil_tmp33 = opj_int_floordivpow2(try0, (OPJ_INT32 )res->pdy);
          }
          {
#line 376
          __cil_tmp31 = opj_int_ceildiv(pi->y, (OPJ_INT32 )(comp->dy << levelno));
#line 376
          __cil_tmp32 = opj_int_floordivpow2(__cil_tmp31, (OPJ_INT32 )res->pdy);
#line 376
          prcj = __cil_tmp32 - __cil_tmp33;
#line 378
          pi->precno = (OPJ_UINT32 )(prci + prcj * (OPJ_INT32 )res->pw);
#line 379
          pi->layno = pi->poc.layno0;
          }
          {
#line 379
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 379
            if (! (pi->layno < pi->poc.layno1)) {
#line 379
              goto while_break___5;
            }
#line 380
            index___6 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 381
            if (! *(pi->include + index___6)) {
#line 382
              *(pi->include + index___6) = (OPJ_INT16 )1;
#line 383
              return (1);
            }
            LABEL_SKIP: ;
#line 379
            (pi->layno) ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 345
          (pi->compno) ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 344
        pi->x += (OPJ_INT32 )(pi->dx - (OPJ_UINT32 )(pi->x % (OPJ_INT32 )pi->dx));
      }
      while_break___3: /* CIL Label */ ;
      }
#line 343
      pi->y += (OPJ_INT32 )(pi->dy - (OPJ_UINT32 )(pi->y % (OPJ_INT32 )pi->dy));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 342
    (pi->resno) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 392
  return (0);
}
}
#line 395 "/root/patron/new_21/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___7 ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 __cil_tmp14 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 levelno ;
  OPJ_INT32 trx0 ;
  OPJ_INT32 try0 ;
  OPJ_INT32 trx1 ;
  OPJ_INT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_INT32 prci ;
  OPJ_INT32 prcj ;
  OPJ_INT32 __cil_tmp25 ;
  OPJ_INT32 __cil_tmp26 ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_INT32 __cil_tmp32 ;
  OPJ_INT32 __cil_tmp33 ;
  OPJ_INT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 __cil_tmp36 ;
  OPJ_UINT32 __cil_tmp37 ;

  {
#line 396
  comp = (opj_pi_comp_t *)((void *)0);
#line 397
  res = (opj_pi_resolution_t *)((void *)0);
#line 398
  index___7 = (OPJ_UINT32 )0;
#line 400
  if (! pi->first) {
#line 401
    comp = pi->comps + pi->compno;
#line 402
    goto LABEL_SKIP;
  } else {
#line 405
    pi->first = 0;
#line 406
    pi->dx = (OPJ_UINT32 )0;
#line 407
    pi->dy = (OPJ_UINT32 )0;
#line 408
    compno = (OPJ_UINT32 )0;
    {
#line 408
    while (1) {
      while_continue: /* CIL Label */ ;
#line 408
      if (! (compno < pi->numcomps)) {
#line 408
        goto while_break;
      }
#line 409
      comp = pi->comps + compno;
#line 410
      resno = (OPJ_UINT32 )0;
      {
#line 410
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 410
        if (! (resno < comp->numresolutions)) {
#line 410
          goto while_break___0;
        }
#line 412
        res = comp->resolutions + resno;
#line 413
        dx = comp->dx * (1U << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 414
        dy = comp->dy * (1U << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 415
        if (! pi->dx) {
#line 415
          tmp = dx;
        } else {
          {
#line 415
          __cil_tmp9 = opj_uint_min(pi->dx, dx);
#line 415
          tmp = __cil_tmp9;
          }
        }
#line 415
        pi->dx = tmp;
#line 416
        if (! pi->dy) {
#line 416
          tmp___0 = dy;
        } else {
          {
#line 416
          __cil_tmp11 = opj_uint_min(pi->dy, dy);
#line 416
          tmp___0 = __cil_tmp11;
          }
        }
#line 416
        pi->dy = tmp___0;
#line 410
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 408
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 420
  if (! pi->tp_on) {
#line 421
    pi->poc.ty0 = pi->ty0;
#line 422
    pi->poc.tx0 = pi->tx0;
#line 423
    pi->poc.ty1 = pi->ty1;
#line 424
    pi->poc.tx1 = pi->tx1;
  }
#line 426
  pi->y = pi->poc.ty0;
  {
#line 426
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 426
    if (! (pi->y < pi->poc.ty1)) {
#line 426
      goto while_break___1;
    }
#line 427
    pi->x = pi->poc.tx0;
    {
#line 427
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 427
      if (! (pi->x < pi->poc.tx1)) {
#line 427
        goto while_break___2;
      }
#line 428
      pi->compno = pi->poc.compno0;
      {
#line 428
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 428
        if (! (pi->compno < pi->poc.compno1)) {
#line 428
          goto while_break___3;
        }
#line 429
        comp = pi->comps + pi->compno;
#line 430
        pi->resno = pi->poc.resno0;
        {
#line 430
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 430
          if (! (pi->resno < __cil_tmp15)) {
#line 430
            goto while_break___4;
          }
          {
#line 436
          res = comp->resolutions + pi->resno;
#line 437
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 438
          trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32 )(comp->dx << levelno));
#line 439
          try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32 )(comp->dy << levelno));
#line 440
          trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32 )(comp->dx << levelno));
#line 441
          try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32 )(comp->dy << levelno));
#line 442
          rpx = res->pdx + levelno;
#line 443
          rpy = res->pdy + levelno;
          }
#line 444
          if (! (pi->y % (OPJ_INT32 )(comp->dy << rpy) == 0 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpy)))) {
#line 445
            goto while_continue___4;
          }
#line 447
          if (! (pi->x % (OPJ_INT32 )(comp->dx << rpx) == 0 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
#line 448
            goto while_continue___4;
          }
#line 451
          if (res->pw == 0U) {
#line 451
            goto while_continue___4;
          } else
#line 451
          if (res->ph == 0U) {
#line 451
            goto while_continue___4;
          }
#line 453
          if (trx0 == trx1) {
#line 453
            goto while_continue___4;
          } else
#line 453
          if (try0 == try1) {
#line 453
            goto while_continue___4;
          }
          {
#line 455
          __cil_tmp31 = opj_int_floordivpow2(trx0, (OPJ_INT32 )res->pdx);
          }
          {
#line 455
          __cil_tmp29 = opj_int_ceildiv(pi->x, (OPJ_INT32 )(comp->dx << levelno));
#line 455
          __cil_tmp30 = opj_int_floordivpow2(__cil_tmp29, (OPJ_INT32 )res->pdx);
#line 455
          prci = __cil_tmp30 - __cil_tmp31;
#line 457
          __cil_tmp34 = opj_int_floordivpow2(try0, (OPJ_INT32 )res->pdy);
          }
          {
#line 457
          __cil_tmp32 = opj_int_ceildiv(pi->y, (OPJ_INT32 )(comp->dy << levelno));
#line 457
          __cil_tmp33 = opj_int_floordivpow2(__cil_tmp32, (OPJ_INT32 )res->pdy);
#line 457
          prcj = __cil_tmp33 - __cil_tmp34;
#line 459
          pi->precno = (OPJ_UINT32 )(prci + prcj * (OPJ_INT32 )res->pw);
#line 460
          pi->layno = pi->poc.layno0;
          }
          {
#line 460
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 460
            if (! (pi->layno < pi->poc.layno1)) {
#line 460
              goto while_break___5;
            }
#line 461
            index___7 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 462
            if (! *(pi->include + index___7)) {
#line 463
              *(pi->include + index___7) = (OPJ_INT16 )1;
#line 464
              return (1);
            }
            LABEL_SKIP: ;
#line 460
            (pi->layno) ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 430
          (pi->resno) ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 428
        (pi->compno) ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 427
      pi->x += (OPJ_INT32 )(pi->dx - (OPJ_UINT32 )(pi->x % (OPJ_INT32 )pi->dx));
    }
    while_break___2: /* CIL Label */ ;
    }
#line 426
    pi->y += (OPJ_INT32 )(pi->dy - (OPJ_UINT32 )(pi->y % (OPJ_INT32 )pi->dy));
  }
  while_break___1: /* CIL Label */ ;
  }
#line 473
  return (0);
}
}
#line 476 "/root/patron/new_21/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___8 ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp8 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 levelno ;
  OPJ_INT32 trx0 ;
  OPJ_INT32 try0 ;
  OPJ_INT32 trx1 ;
  OPJ_INT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_INT32 prci ;
  OPJ_INT32 prcj ;
  OPJ_INT32 __cil_tmp23 ;
  OPJ_INT32 __cil_tmp24 ;
  OPJ_INT32 __cil_tmp25 ;
  OPJ_INT32 __cil_tmp26 ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_INT32 __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;

  {
#line 477
  comp = (opj_pi_comp_t *)((void *)0);
#line 478
  res = (opj_pi_resolution_t *)((void *)0);
#line 479
  index___8 = (OPJ_UINT32 )0;
#line 481
  if (! pi->first) {
#line 482
    comp = pi->comps + pi->compno;
#line 483
    goto LABEL_SKIP;
  } else {
#line 485
    pi->first = 0;
  }
#line 488
  pi->compno = pi->poc.compno0;
  {
#line 488
  while (1) {
    while_continue: /* CIL Label */ ;
#line 488
    if (! (pi->compno < pi->poc.compno1)) {
#line 488
      goto while_break;
    }
#line 490
    comp = pi->comps + pi->compno;
#line 491
    pi->dx = (OPJ_UINT32 )0;
#line 492
    pi->dy = (OPJ_UINT32 )0;
#line 493
    resno = (OPJ_UINT32 )0;
    {
#line 493
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 493
      if (! (resno < comp->numresolutions)) {
#line 493
        goto while_break___0;
      }
#line 495
      res = comp->resolutions + resno;
#line 496
      dx = comp->dx * (1U << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 497
      dy = comp->dy * (1U << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 498
      if (! pi->dx) {
#line 498
        tmp = dx;
      } else {
        {
#line 498
        __cil_tmp8 = opj_uint_min(pi->dx, dx);
#line 498
        tmp = __cil_tmp8;
        }
      }
#line 498
      pi->dx = tmp;
#line 499
      if (! pi->dy) {
#line 499
        tmp___0 = dy;
      } else {
        {
#line 499
        __cil_tmp10 = opj_uint_min(pi->dy, dy);
#line 499
        tmp___0 = __cil_tmp10;
        }
      }
#line 499
      pi->dy = tmp___0;
#line 493
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 501
    if (! pi->tp_on) {
#line 502
      pi->poc.ty0 = pi->ty0;
#line 503
      pi->poc.tx0 = pi->tx0;
#line 504
      pi->poc.ty1 = pi->ty1;
#line 505
      pi->poc.tx1 = pi->tx1;
    }
#line 507
    pi->y = pi->poc.ty0;
    {
#line 507
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 507
      if (! (pi->y < pi->poc.ty1)) {
#line 507
        goto while_break___1;
      }
#line 508
      pi->x = pi->poc.tx0;
      {
#line 508
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 508
        if (! (pi->x < pi->poc.tx1)) {
#line 508
          goto while_break___2;
        }
#line 509
        pi->resno = pi->poc.resno0;
        {
#line 509
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 509
          if (! (pi->resno < __cil_tmp13)) {
#line 509
            goto while_break___3;
          }
          {
#line 515
          res = comp->resolutions + pi->resno;
#line 516
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 517
          trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32 )(comp->dx << levelno));
#line 518
          try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32 )(comp->dy << levelno));
#line 519
          trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32 )(comp->dx << levelno));
#line 520
          try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32 )(comp->dy << levelno));
#line 521
          rpx = res->pdx + levelno;
#line 522
          rpy = res->pdy + levelno;
          }
#line 523
          if (! (pi->y % (OPJ_INT32 )(comp->dy << rpy) == 0 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpy)))) {
#line 524
            goto while_continue___3;
          }
#line 526
          if (! (pi->x % (OPJ_INT32 )(comp->dx << rpx) == 0 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
#line 527
            goto while_continue___3;
          }
#line 530
          if (res->pw == 0U) {
#line 530
            goto while_continue___3;
          } else
#line 530
          if (res->ph == 0U) {
#line 530
            goto while_continue___3;
          }
#line 532
          if (trx0 == trx1) {
#line 532
            goto while_continue___3;
          } else
#line 532
          if (try0 == try1) {
#line 532
            goto while_continue___3;
          }
          {
#line 534
          __cil_tmp29 = opj_int_floordivpow2(trx0, (OPJ_INT32 )res->pdx);
          }
          {
#line 534
          __cil_tmp27 = opj_int_ceildiv(pi->x, (OPJ_INT32 )(comp->dx << levelno));
#line 534
          __cil_tmp28 = opj_int_floordivpow2(__cil_tmp27, (OPJ_INT32 )res->pdx);
#line 534
          prci = __cil_tmp28 - __cil_tmp29;
#line 536
          __cil_tmp32 = opj_int_floordivpow2(try0, (OPJ_INT32 )res->pdy);
          }
          {
#line 536
          __cil_tmp30 = opj_int_ceildiv(pi->y, (OPJ_INT32 )(comp->dy << levelno));
#line 536
          __cil_tmp31 = opj_int_floordivpow2(__cil_tmp30, (OPJ_INT32 )res->pdy);
#line 536
          prcj = __cil_tmp31 - __cil_tmp32;
#line 538
          pi->precno = (OPJ_UINT32 )(prci + prcj * (OPJ_INT32 )res->pw);
#line 539
          pi->layno = pi->poc.layno0;
          }
          {
#line 539
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 539
            if (! (pi->layno < pi->poc.layno1)) {
#line 539
              goto while_break___4;
            }
#line 540
            index___8 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 541
            if (! *(pi->include + index___8)) {
#line 542
              *(pi->include + index___8) = (OPJ_INT16 )1;
#line 543
              return (1);
            }
            LABEL_SKIP: ;
#line 539
            (pi->layno) ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 509
          (pi->resno) ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 508
        pi->x += (OPJ_INT32 )(pi->dx - (OPJ_UINT32 )(pi->x % (OPJ_INT32 )pi->dx));
      }
      while_break___2: /* CIL Label */ ;
      }
#line 507
      pi->y += (OPJ_INT32 )(pi->dy - (OPJ_UINT32 )(pi->y % (OPJ_INT32 )pi->dy));
    }
    while_break___1: /* CIL Label */ ;
    }
#line 488
    (pi->compno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 552
  return (0);
}
}
#line 555 "/root/patron/new_21/src/lib/openjp2/pi.c"
void opj_get_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tileno ,
                                 OPJ_INT32 *p_tx0 , OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                 OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                 OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_INT32 __cil_tmp22 ;
  OPJ_INT32 __cil_tmp23 ;
  OPJ_INT32 __cil_tmp24 ;
  OPJ_INT32 __cil_tmp25 ;
  OPJ_UINT32 l_level_no ;
  OPJ_INT32 l_rx0 ;
  OPJ_INT32 l_ry0 ;
  OPJ_INT32 l_rx1 ;
  OPJ_INT32 l_ry1 ;
  OPJ_INT32 l_px0 ;
  OPJ_INT32 l_py0 ;
  OPJ_INT32 l_px1 ;
  OPJ_INT32 py1 ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_pw ;
  OPJ_UINT32 l_ph ;
  OPJ_UINT32 l_product ;
  OPJ_INT32 l_tcx0 ;
  OPJ_INT32 l_tcy0 ;
  OPJ_INT32 l_tcx1 ;
  OPJ_INT32 l_tcy1 ;
  OPJ_INT32 __cil_tmp44 ;
  OPJ_INT32 __cil_tmp45 ;
  OPJ_INT32 __cil_tmp46 ;
  OPJ_INT32 __cil_tmp47 ;
  OPJ_UINT32 l_dx ;
  OPJ_UINT32 l_dy ;
  OPJ_UINT32 __cil_tmp50 ;
  OPJ_UINT32 __cil_tmp51 ;
  OPJ_INT32 __cil_tmp52 ;
  OPJ_INT32 __cil_tmp53 ;
  OPJ_INT32 __cil_tmp54 ;
  OPJ_INT32 __cil_tmp55 ;
  OPJ_INT32 __cil_tmp56 ;
  OPJ_INT32 __cil_tmp57 ;
  OPJ_INT32 __cil_tmp58 ;
  OPJ_INT32 __cil_tmp59 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 570
  l_tcp = (opj_tcp_t *)0;
#line 571
  l_tccp = (opj_tccp_t *)0;
#line 572
  l_img_comp = (opj_image_comp_t *)0;
#line 583
  l_tcp = p_cp->tcps + p_tileno;
#line 584
  l_img_comp = p_image->comps;
#line 585
  l_tccp = l_tcp->tccps;
#line 588
  p = p_tileno % p_cp->tw;
#line 589
  q = p_tileno / p_cp->tw;
#line 592
  *p_tx0 = opj_int_max((OPJ_INT32 )(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32 )p_image->x0);
#line 593
  *p_tx1 = opj_int_min((OPJ_INT32 )(p_cp->tx0 + (p + 1U) * p_cp->tdx), (OPJ_INT32 )p_image->x1);
#line 594
  *p_ty0 = opj_int_max((OPJ_INT32 )(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32 )p_image->y0);
#line 595
  *p_ty1 = opj_int_min((OPJ_INT32 )(p_cp->ty0 + (q + 1U) * p_cp->tdy), (OPJ_INT32 )p_image->y1);
#line 598
  *p_max_prec = (OPJ_UINT32 )0;
#line 599
  *p_max_res = (OPJ_UINT32 )0;
#line 602
  *p_dx_min = (OPJ_UINT32 )2147483647;
#line 603
  *p_dy_min = (OPJ_UINT32 )2147483647;
#line 605
  compno = (OPJ_UINT32 )0;
  }
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (! (compno < p_image->numcomps)) {
#line 605
      goto while_break;
    }
    {
#line 615
    l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32 )l_img_comp->dx);
#line 616
    l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32 )l_img_comp->dy);
#line 617
    l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32 )l_img_comp->dx);
#line 618
    l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32 )l_img_comp->dy);
    }
#line 620
    if (l_tccp->numresolutions > *p_max_res) {
#line 621
      *p_max_res = l_tccp->numresolutions;
    }
#line 625
    resno = (OPJ_UINT32 )0;
    {
#line 625
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 625
      if (! (resno < l_tccp->numresolutions)) {
#line 625
        goto while_break___0;
      }
      {
#line 629
      l_pdx = l_tccp->prcw[resno];
#line 630
      l_pdy = l_tccp->prch[resno];
#line 632
      l_dx = l_img_comp->dx * (1U << (((l_pdx + l_tccp->numresolutions) - 1U) - resno));
#line 633
      l_dy = l_img_comp->dy * (1U << (((l_pdy + l_tccp->numresolutions) - 1U) - resno));
#line 636
      *p_dx_min = opj_uint_min(*p_dx_min, l_dx);
#line 637
      *p_dy_min = opj_uint_min(*p_dy_min, l_dy);
#line 640
      l_level_no = (l_tccp->numresolutions - 1U) - resno;
#line 642
      l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32 )l_level_no);
#line 643
      l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32 )l_level_no);
#line 644
      l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32 )l_level_no);
#line 645
      l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32 )l_level_no);
#line 647
      __cil_tmp56 = opj_int_floordivpow2(l_rx0, (OPJ_INT32 )l_pdx);
#line 647
      l_px0 = __cil_tmp56 << l_pdx;
#line 648
      __cil_tmp57 = opj_int_floordivpow2(l_ry0, (OPJ_INT32 )l_pdy);
#line 648
      l_py0 = __cil_tmp57 << l_pdy;
#line 649
      __cil_tmp58 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32 )l_pdx);
#line 649
      l_px1 = __cil_tmp58 << l_pdx;
#line 651
      __cil_tmp59 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32 )l_pdy);
#line 651
      py1 = __cil_tmp59 << l_pdy;
      }
#line 653
      if (l_rx0 == l_rx1) {
#line 653
        tmp___2 = (unsigned int )0;
      } else {
#line 653
        tmp___2 = (OPJ_UINT32 )((l_px1 - l_px0) >> l_pdx);
      }
#line 653
      l_pw = tmp___2;
#line 654
      if (l_ry0 == l_ry1) {
#line 654
        tmp___3 = (unsigned int )0;
      } else {
#line 654
        tmp___3 = (OPJ_UINT32 )((py1 - l_py0) >> l_pdy);
      }
#line 654
      l_ph = tmp___3;
#line 656
      l_product = l_pw * l_ph;
#line 659
      if (l_product > *p_max_prec) {
#line 660
        *p_max_prec = l_product;
      }
#line 625
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 663
    l_img_comp ++;
#line 664
    l_tccp ++;
#line 605
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 669 "/root/patron/new_21/src/lib/openjp2/pi.c"
void opj_get_all_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 tileno ,
                                     OPJ_INT32 *p_tx0 , OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                     OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                     OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ,
                                     OPJ_UINT32 **p_resolutions ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  opj_tcp_t *tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 *lResolutionPtr ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_INT32 __cil_tmp24 ;
  OPJ_INT32 __cil_tmp25 ;
  OPJ_INT32 __cil_tmp26 ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_UINT32 l_level_no ;
  OPJ_INT32 l_rx0 ;
  OPJ_INT32 l_ry0 ;
  OPJ_INT32 l_rx1 ;
  OPJ_INT32 l_ry1 ;
  OPJ_INT32 l_px0 ;
  OPJ_INT32 l_py0 ;
  OPJ_INT32 l_px1 ;
  OPJ_INT32 py1 ;
  OPJ_UINT32 l_product ;
  OPJ_INT32 l_tcx0 ;
  OPJ_INT32 l_tcy0 ;
  OPJ_INT32 l_tcx1 ;
  OPJ_INT32 l_tcy1 ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_pw ;
  OPJ_UINT32 l_ph ;
  OPJ_INT32 __cil_tmp46 ;
  OPJ_INT32 __cil_tmp47 ;
  OPJ_INT32 __cil_tmp48 ;
  OPJ_INT32 __cil_tmp49 ;
  OPJ_UINT32 l_dx ;
  OPJ_UINT32 l_dy ;
  OPJ_UINT32 *__cil_tmp52 ;
  OPJ_UINT32 *__cil_tmp53 ;
  OPJ_INT32 __cil_tmp54 ;
  OPJ_INT32 __cil_tmp55 ;
  OPJ_INT32 __cil_tmp56 ;
  OPJ_INT32 __cil_tmp57 ;
  OPJ_INT32 __cil_tmp58 ;
  OPJ_INT32 __cil_tmp59 ;
  OPJ_INT32 __cil_tmp60 ;
  OPJ_INT32 __cil_tmp61 ;
  OPJ_INT32 __cil_tmp62 ;
  OPJ_INT32 __cil_tmp63 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  OPJ_UINT32 *__cil_tmp66 ;
  OPJ_UINT32 *__cil_tmp67 ;

  {
  {
#line 686
  tcp = (opj_tcp_t *)0;
#line 687
  l_tccp = (opj_tccp_t *)0;
#line 688
  l_img_comp = (opj_image_comp_t *)0;
#line 702
  tcp = p_cp->tcps + tileno;
#line 703
  l_tccp = tcp->tccps;
#line 704
  l_img_comp = p_image->comps;
#line 707
  p = tileno % p_cp->tw;
#line 708
  q = tileno / p_cp->tw;
#line 711
  *p_tx0 = opj_int_max((OPJ_INT32 )(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32 )p_image->x0);
#line 712
  *p_tx1 = opj_int_min((OPJ_INT32 )(p_cp->tx0 + (p + 1U) * p_cp->tdx), (OPJ_INT32 )p_image->x1);
#line 713
  *p_ty0 = opj_int_max((OPJ_INT32 )(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32 )p_image->y0);
#line 714
  *p_ty1 = opj_int_min((OPJ_INT32 )(p_cp->ty0 + (q + 1U) * p_cp->tdy), (OPJ_INT32 )p_image->y1);
#line 717
  *p_max_prec = (OPJ_UINT32 )0;
#line 718
  *p_max_res = (OPJ_UINT32 )0;
#line 721
  *p_dx_min = (OPJ_UINT32 )2147483647;
#line 722
  *p_dy_min = (OPJ_UINT32 )2147483647;
#line 724
  compno = (OPJ_UINT32 )0;
  }
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (compno < p_image->numcomps)) {
#line 724
      goto while_break;
    }
    {
#line 733
    lResolutionPtr = *(p_resolutions + compno);
#line 735
    l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32 )l_img_comp->dx);
#line 736
    l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32 )l_img_comp->dy);
#line 737
    l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32 )l_img_comp->dx);
#line 738
    l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32 )l_img_comp->dy);
    }
#line 740
    if (l_tccp->numresolutions > *p_max_res) {
#line 741
      *p_max_res = l_tccp->numresolutions;
    }
#line 745
    l_level_no = l_tccp->numresolutions - 1U;
#line 746
    resno = (OPJ_UINT32 )0;
    {
#line 746
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 746
      if (! (resno < l_tccp->numresolutions)) {
#line 746
        goto while_break___0;
      }
      {
#line 750
      l_pdx = l_tccp->prcw[resno];
#line 751
      l_pdy = l_tccp->prch[resno];
#line 752
      __cil_tmp52 = lResolutionPtr;
#line 752
      lResolutionPtr ++;
#line 752
      *__cil_tmp52 = l_pdx;
#line 753
      __cil_tmp53 = lResolutionPtr;
#line 753
      lResolutionPtr ++;
#line 753
      *__cil_tmp53 = l_pdy;
#line 754
      l_dx = l_img_comp->dx * (1U << (l_pdx + l_level_no));
#line 755
      l_dy = l_img_comp->dy * (1U << (l_pdy + l_level_no));
#line 757
      __cil_tmp54 = opj_int_min((OPJ_INT32 )*p_dx_min, (OPJ_INT32 )l_dx);
#line 757
      *p_dx_min = (OPJ_UINT32 )__cil_tmp54;
#line 758
      __cil_tmp55 = opj_int_min((OPJ_INT32 )*p_dy_min, (OPJ_INT32 )l_dy);
#line 758
      *p_dy_min = (OPJ_UINT32 )__cil_tmp55;
#line 761
      l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32 )l_level_no);
#line 762
      l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32 )l_level_no);
#line 763
      l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32 )l_level_no);
#line 764
      l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32 )l_level_no);
#line 765
      __cil_tmp60 = opj_int_floordivpow2(l_rx0, (OPJ_INT32 )l_pdx);
#line 765
      l_px0 = __cil_tmp60 << l_pdx;
#line 766
      __cil_tmp61 = opj_int_floordivpow2(l_ry0, (OPJ_INT32 )l_pdy);
#line 766
      l_py0 = __cil_tmp61 << l_pdy;
#line 767
      __cil_tmp62 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32 )l_pdx);
#line 767
      l_px1 = __cil_tmp62 << l_pdx;
#line 768
      __cil_tmp63 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32 )l_pdy);
#line 768
      py1 = __cil_tmp63 << l_pdy;
      }
#line 769
      if (l_rx0 == l_rx1) {
#line 769
        tmp___2 = (unsigned int )0;
      } else {
#line 769
        tmp___2 = (OPJ_UINT32 )((l_px1 - l_px0) >> l_pdx);
      }
#line 769
      l_pw = tmp___2;
#line 770
      if (l_ry0 == l_ry1) {
#line 770
        tmp___3 = (unsigned int )0;
      } else {
#line 770
        tmp___3 = (OPJ_UINT32 )((py1 - l_py0) >> l_pdy);
      }
#line 770
      l_ph = tmp___3;
#line 771
      __cil_tmp66 = lResolutionPtr;
#line 771
      lResolutionPtr ++;
#line 771
      *__cil_tmp66 = l_pw;
#line 772
      __cil_tmp67 = lResolutionPtr;
#line 772
      lResolutionPtr ++;
#line 772
      *__cil_tmp67 = l_ph;
#line 773
      l_product = l_pw * l_ph;
#line 776
      if (l_product > *p_max_prec) {
#line 777
        *p_max_prec = l_product;
      }
#line 780
      l_level_no --;
#line 746
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 782
    l_tccp ++;
#line 783
    l_img_comp ++;
#line 724
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 787 "/root/patron/new_21/src/lib/openjp2/pi.c"
opj_pi_iterator_t *opj_pi_create(opj_image_t *image , opj_cp_t *cp , OPJ_UINT32 tileno ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 l_poc_bound ;
  opj_pi_iterator_t *l_pi ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_pi_iterator_t *l_current_pi ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp17 ;

  {
  {
#line 797
  l_pi = (opj_pi_iterator_t *)0;
#line 798
  tcp = (opj_tcp_t *)0;
#line 799
  tccp = (opj_tccp_t *)0;
#line 802
  l_current_pi = (opj_pi_iterator_t *)0;
#line 810
  tcp = cp->tcps + tileno;
#line 811
  l_poc_bound = tcp->numpocs + 1U;
#line 814
  __cil_tmp14 = calloc((unsigned long )l_poc_bound, sizeof(opj_pi_iterator_t ));
#line 814
  l_pi = (opj_pi_iterator_t *)__cil_tmp14;
  }
#line 815
  if (! l_pi) {
#line 816
    return ((opj_pi_iterator_t *)((void *)0));
  }
#line 819
  l_current_pi = l_pi;
#line 820
  pino = (OPJ_UINT32 )0;
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 820
    if (! (pino < l_poc_bound)) {
#line 820
      goto while_break;
    }
    {
#line 822
    __cil_tmp15 = calloc((unsigned long )image->numcomps, sizeof(opj_pi_comp_t ));
#line 822
    l_current_pi->comps = (opj_pi_comp_t *)__cil_tmp15;
    }
#line 823
    if (! l_current_pi->comps) {
      {
#line 824
      opj_pi_destroy(l_pi, l_poc_bound);
      }
#line 825
      return ((opj_pi_iterator_t *)((void *)0));
    }
#line 828
    l_current_pi->numcomps = image->numcomps;
#line 830
    compno = (OPJ_UINT32 )0;
    {
#line 830
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 830
      if (! (compno < image->numcomps)) {
#line 830
        goto while_break___0;
      }
      {
#line 831
      comp = l_current_pi->comps + compno;
#line 833
      tccp = tcp->tccps + compno;
#line 835
      __cil_tmp17 = calloc((unsigned long )tccp->numresolutions, sizeof(opj_pi_resolution_t ));
#line 835
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp17;
      }
#line 836
      if (! comp->resolutions) {
        {
#line 837
        opj_pi_destroy(l_pi, l_poc_bound);
        }
#line 838
        return ((opj_pi_iterator_t *)0);
      }
#line 841
      comp->numresolutions = tccp->numresolutions;
#line 830
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 843
    l_current_pi ++;
#line 820
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  return (l_pi);
}
}
#line 848 "/root/patron/new_21/src/lib/openjp2/pi.c"
void opj_pi_update_encode_poc_and_final(opj_cp_t *p_cp , OPJ_UINT32 p_tileno , OPJ_INT32 p_tx0 ,
                                        OPJ_INT32 p_tx1 , OPJ_INT32 p_ty0 , OPJ_INT32 p_ty1 ,
                                        OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                        OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) 
{ 
  OPJ_UINT32 pino ;
  opj_tcp_t *l_tcp ;
  opj_poc_t *l_current_poc ;
  OPJ_UINT32 l_poc_bound ;
  int tmp ;
  int tmp___0 ;
  OPJ_UINT32 tmp___1 ;

  {
#line 862
  l_tcp = (opj_tcp_t *)0;
#line 864
  l_current_poc = (opj_poc_t *)0;
#line 876
  l_tcp = p_cp->tcps + p_tileno;
#line 878
  l_poc_bound = l_tcp->numpocs + 1U;
#line 882
  l_current_poc = (opj_poc_t *)l_tcp->pocs;
#line 884
  l_current_poc->compS = l_current_poc->compno0;
#line 885
  l_current_poc->compE = l_current_poc->compno1;
#line 886
  l_current_poc->resS = l_current_poc->resno0;
#line 887
  l_current_poc->resE = l_current_poc->resno1;
#line 888
  l_current_poc->layE = l_current_poc->layno1;
#line 891
  l_current_poc->layS = (OPJ_UINT32 )0;
#line 892
  l_current_poc->prg = l_current_poc->prg1;
#line 893
  l_current_poc->prcS = (OPJ_UINT32 )0;
#line 895
  l_current_poc->prcE = p_max_prec;
#line 896
  l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 897
  l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 898
  l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 899
  l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 900
  l_current_poc->dx = p_dx_min;
#line 901
  l_current_poc->dy = p_dy_min;
#line 903
  l_current_poc ++;
#line 904
  pino = (OPJ_UINT32 )1;
  {
#line 904
  while (1) {
    while_continue: /* CIL Label */ ;
#line 904
    if (! (pino < l_poc_bound)) {
#line 904
      goto while_break;
    }
#line 905
    l_current_poc->compS = l_current_poc->compno0;
#line 906
    l_current_poc->compE = l_current_poc->compno1;
#line 907
    l_current_poc->resS = l_current_poc->resno0;
#line 908
    l_current_poc->resE = l_current_poc->resno1;
#line 909
    l_current_poc->layE = l_current_poc->layno1;
#line 910
    l_current_poc->prg = l_current_poc->prg1;
#line 911
    l_current_poc->prcS = (OPJ_UINT32 )0;
#line 913
    if (l_current_poc->layE > (l_current_poc - 1)->layE) {
#line 913
      tmp___1 = l_current_poc->layE;
    } else {
#line 913
      tmp___1 = (unsigned int )0;
    }
#line 913
    l_current_poc->layS = tmp___1;
#line 915
    l_current_poc->prcE = p_max_prec;
#line 916
    l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 917
    l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 918
    l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 919
    l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 920
    l_current_poc->dx = p_dx_min;
#line 921
    l_current_poc->dy = p_dy_min;
#line 922
    l_current_poc ++;
#line 904
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 926 "/root/patron/new_21/src/lib/openjp2/pi.c"
void opj_pi_update_encode_not_poc(opj_cp_t *p_cp , OPJ_UINT32 p_num_comps , OPJ_UINT32 p_tileno ,
                                  OPJ_INT32 p_tx0 , OPJ_INT32 p_tx1 , OPJ_INT32 p_ty0 ,
                                  OPJ_INT32 p_ty1 , OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                  OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) 
{ 
  OPJ_UINT32 pino ;
  opj_tcp_t *l_tcp ;
  opj_poc_t *l_current_poc ;
  OPJ_UINT32 l_poc_bound ;
  int tmp ;
  int tmp___0 ;

  {
#line 941
  l_tcp = (opj_tcp_t *)0;
#line 943
  l_current_poc = (opj_poc_t *)0;
#line 952
  l_tcp = p_cp->tcps + p_tileno;
#line 955
  l_poc_bound = l_tcp->numpocs + 1U;
#line 959
  l_current_poc = (opj_poc_t *)l_tcp->pocs;
#line 961
  pino = (OPJ_UINT32 )0;
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 961
    if (! (pino < l_poc_bound)) {
#line 961
      goto while_break;
    }
#line 962
    l_current_poc->compS = (OPJ_UINT32 )0;
#line 963
    l_current_poc->compE = p_num_comps;
#line 964
    l_current_poc->resS = (OPJ_UINT32 )0;
#line 965
    l_current_poc->resE = p_max_res;
#line 966
    l_current_poc->layS = (OPJ_UINT32 )0;
#line 967
    l_current_poc->layE = l_tcp->numlayers;
#line 968
    l_current_poc->prg = l_tcp->prg;
#line 969
    l_current_poc->prcS = (OPJ_UINT32 )0;
#line 970
    l_current_poc->prcE = p_max_prec;
#line 971
    l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 972
    l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 973
    l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 974
    l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 975
    l_current_poc->dx = p_dx_min;
#line 976
    l_current_poc->dy = p_dy_min;
#line 977
    l_current_poc ++;
#line 961
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 981 "/root/patron/new_21/src/lib/openjp2/pi.c"
void opj_pi_update_decode_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp , OPJ_UINT32 p_max_precision ,
                              OPJ_UINT32 p_max_res ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 l_bound ;
  opj_pi_iterator_t *l_current_pi ;
  opj_poc_t *l_current_poc ;
  int tmp ;
  int tmp___0 ;

  {
#line 992
  l_current_pi = (opj_pi_iterator_t *)0;
#line 993
  l_current_poc = (opj_poc_t *)0;
#line 1002
  l_bound = p_tcp->numpocs + 1U;
#line 1003
  l_current_pi = p_pi;
#line 1004
  l_current_poc = (opj_poc_t *)p_tcp->pocs;
#line 1006
  pino = (OPJ_UINT32 )0;
  {
#line 1006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1006
    if (! (pino < l_bound)) {
#line 1006
      goto while_break;
    }
#line 1007
    l_current_pi->poc.prg = l_current_poc->prg;
#line 1008
    l_current_pi->first = 1;
#line 1010
    l_current_pi->poc.resno0 = l_current_poc->resno0;
#line 1011
    l_current_pi->poc.compno0 = l_current_poc->compno0;
#line 1012
    l_current_pi->poc.layno0 = (OPJ_UINT32 )0;
#line 1013
    l_current_pi->poc.precno0 = (OPJ_UINT32 )0;
#line 1014
    l_current_pi->poc.resno1 = l_current_poc->resno1;
#line 1015
    l_current_pi->poc.compno1 = l_current_poc->compno1;
#line 1016
    l_current_pi->poc.layno1 = l_current_poc->layno1;
#line 1017
    l_current_pi->poc.precno1 = p_max_precision;
#line 1018
    l_current_pi ++;
#line 1019
    l_current_poc ++;
#line 1006
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1023 "/root/patron/new_21/src/lib/openjp2/pi.c"
void opj_pi_update_decode_not_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp , OPJ_UINT32 p_max_precision ,
                                  OPJ_UINT32 p_max_res ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 l_bound ;
  opj_pi_iterator_t *l_current_pi ;
  int tmp ;
  int tmp___0 ;

  {
#line 1034
  l_current_pi = (opj_pi_iterator_t *)0;
#line 1040
  l_bound = p_tcp->numpocs + 1U;
#line 1041
  l_current_pi = p_pi;
#line 1043
  pino = (OPJ_UINT32 )0;
  {
#line 1043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1043
    if (! (pino < l_bound)) {
#line 1043
      goto while_break;
    }
#line 1044
    l_current_pi->poc.prg = p_tcp->prg;
#line 1045
    l_current_pi->first = 1;
#line 1046
    l_current_pi->poc.resno0 = (OPJ_UINT32 )0;
#line 1047
    l_current_pi->poc.compno0 = (OPJ_UINT32 )0;
#line 1048
    l_current_pi->poc.layno0 = (OPJ_UINT32 )0;
#line 1049
    l_current_pi->poc.precno0 = (OPJ_UINT32 )0;
#line 1050
    l_current_pi->poc.resno1 = p_max_res;
#line 1051
    l_current_pi->poc.compno1 = l_current_pi->numcomps;
#line 1052
    l_current_pi->poc.layno1 = p_tcp->numlayers;
#line 1053
    l_current_pi->poc.precno1 = p_max_precision;
#line 1054
    l_current_pi ++;
#line 1043
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1060 "/root/patron/new_21/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos , opj_cp_t *cp , OPJ_UINT32 tileno ,
                                 OPJ_UINT32 pino , OPJ_CHAR *prog ) 
{ 
  OPJ_INT32 i ;
  opj_tcp_t *tcps ;
  opj_poc_t *tcp ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;

  {
#line 1067
  tcps = cp->tcps + tileno;
#line 1068
  tcp = & tcps->pocs[pino];
#line 1070
  if (pos >= 0) {
#line 1071
    i = pos;
    {
#line 1071
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1071
      if (! (pos >= 0)) {
#line 1071
        goto while_break;
      }
      {
#line 1073
      if ((int )*(prog + i) == 'R') {
#line 1073
        goto case_82;
      }
#line 1084
      if ((int )*(prog + i) == 'C') {
#line 1084
        goto case_67;
      }
#line 1095
      if ((int )*(prog + i) == 'L') {
#line 1095
        goto case_76;
      }
#line 1106
      if ((int )*(prog + i) == 'P') {
#line 1106
        goto case_80;
      }
#line 1109
      if ((int )*(prog + i) == 1) {
#line 1109
        goto case_1;
      }
#line 1109
      if ((int )*(prog + i) == 0) {
#line 1109
        goto case_1;
      }
#line 1120
      goto switch_default;
      case_82: /* CIL Label */ 
#line 1074
      if (tcp->res_t == tcp->resE) {
        {
#line 1075
        __cil_tmp9 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1075
        if (__cil_tmp9) {
#line 1076
          return (1);
        } else {
#line 1078
          return (0);
        }
      } else {
#line 1081
        return (1);
      }
#line 1083
      goto switch_break;
      case_67: /* CIL Label */ 
#line 1085
      if (tcp->comp_t == tcp->compE) {
        {
#line 1086
        __cil_tmp10 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1086
        if (__cil_tmp10) {
#line 1087
          return (1);
        } else {
#line 1089
          return (0);
        }
      } else {
#line 1092
        return (1);
      }
#line 1094
      goto switch_break;
      case_76: /* CIL Label */ 
#line 1096
      if (tcp->lay_t == tcp->layE) {
        {
#line 1097
        __cil_tmp11 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1097
        if (__cil_tmp11) {
#line 1098
          return (1);
        } else {
#line 1100
          return (0);
        }
      } else {
#line 1103
        return (1);
      }
#line 1105
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 1109
      if ((int )tcp->prg == 1) {
#line 1109
        goto case_1;
      }
#line 1109
      if ((int )tcp->prg == 0) {
#line 1109
        goto case_1;
      }
#line 1120
      goto switch_default;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 1110
      if (tcp->prc_t == tcp->prcE) {
        {
#line 1111
        __cil_tmp12 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
        }
#line 1111
        if (__cil_tmp12) {
#line 1112
          return (1);
        } else {
#line 1114
          return (0);
        }
      } else {
#line 1117
        return (1);
      }
#line 1119
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 1121
      if (tcp->tx0_t == tcp->txE) {
#line 1123
        if (tcp->ty0_t == tcp->tyE) {
          {
#line 1124
          __cil_tmp13 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
          }
#line 1124
          if (__cil_tmp13) {
#line 1125
            return (1);
          } else {
#line 1127
            return (0);
          }
        } else {
#line 1130
          return (1);
        }
      } else {
#line 1133
        return (1);
      }
#line 1135
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      switch_break: /* CIL Label */ ;
      }
#line 1071
      __cil_tmp14 = i;
#line 1071
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1140
  return (0);
}
}
#line 1149 "/root/patron/new_21/src/lib/openjp2/pi.c"
opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 *l_tmp_data ;
  OPJ_UINT32 **l_tmp_ptr ;
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_INT32 l_tx0 ;
  OPJ_INT32 l_tx1 ;
  OPJ_INT32 l_ty0 ;
  OPJ_INT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  OPJ_UINT32 l_bound ;
  OPJ_UINT32 l_step_p ;
  OPJ_UINT32 l_step_c ;
  OPJ_UINT32 l_step_r ;
  OPJ_UINT32 l_step_l ;
  OPJ_UINT32 l_data_stride ;
  opj_pi_iterator_t *l_pi ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_pi_comp_t *l_current_comp ;
  opj_image_comp_t *l_img_comp ;
  opj_pi_iterator_t *l_current_pi ;
  OPJ_UINT32 *l_encoding_value_ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  opj_pi_iterator_t *__cil_tmp35 ;
  void *__cil_tmp36 ;
  opj_pi_resolution_t *l_res ;
  OPJ_UINT32 *__cil_tmp38 ;
  OPJ_UINT32 *__cil_tmp39 ;
  OPJ_UINT32 *__cil_tmp40 ;
  OPJ_UINT32 *__cil_tmp41 ;
  OPJ_UINT32 __cil_tmp42 ;
  opj_pi_resolution_t *l_res___0 ;
  OPJ_UINT32 *__cil_tmp44 ;
  OPJ_UINT32 *__cil_tmp45 ;
  OPJ_UINT32 *__cil_tmp46 ;
  OPJ_UINT32 *__cil_tmp47 ;
  OPJ_UINT32 __cil_tmp48 ;

  {
  {
#line 1171
  l_pi = (opj_pi_iterator_t *)0;
#line 1172
  l_tcp = (opj_tcp_t *)0;
#line 1173
  l_tccp = (opj_tccp_t *)0;
#line 1174
  l_current_comp = (opj_pi_comp_t *)0;
#line 1175
  l_img_comp = (opj_image_comp_t *)0;
#line 1176
  l_current_pi = (opj_pi_iterator_t *)0;
#line 1177
  l_encoding_value_ptr = (OPJ_UINT32 *)0;
#line 1185
  l_tcp = p_cp->tcps + p_tile_no;
#line 1186
  l_bound = l_tcp->numpocs + 1U;
#line 1188
  l_data_stride = (OPJ_UINT32 )132;
#line 1189
  __cil_tmp33 = malloc((unsigned long )(l_data_stride * p_image->numcomps) * sizeof(OPJ_UINT32 ));
#line 1189
  l_tmp_data = (OPJ_UINT32 *)__cil_tmp33;
  }
#line 1191
  if (! l_tmp_data) {
#line 1194
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1196
  __cil_tmp34 = malloc((unsigned long )p_image->numcomps * sizeof(OPJ_UINT32 *));
#line 1196
  l_tmp_ptr = (OPJ_UINT32 **)__cil_tmp34;
  }
#line 1198
  if (! l_tmp_ptr) {
    {
#line 1201
    free(l_tmp_data);
    }
#line 1202
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1206
  l_pi = opj_pi_create(p_image, p_cp, p_tile_no);
  }
#line 1207
  if (! l_pi) {
    {
#line 1208
    free(l_tmp_data);
#line 1209
    free(l_tmp_ptr);
    }
#line 1210
    return ((opj_pi_iterator_t *)0);
  }
#line 1213
  l_encoding_value_ptr = l_tmp_data;
#line 1216
  compno = (OPJ_UINT32 )0;
  {
#line 1215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1215
    if (! (compno < p_image->numcomps)) {
#line 1215
      goto while_break;
    }
#line 1218
    *(l_tmp_ptr + compno) = l_encoding_value_ptr;
#line 1219
    l_encoding_value_ptr += l_data_stride;
#line 1216
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1222
  opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                                  & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res,
                                  l_tmp_ptr);
#line 1225
  l_step_p = (OPJ_UINT32 )1;
#line 1226
  l_step_c = l_max_prec * l_step_p;
#line 1227
  l_step_r = p_image->numcomps * l_step_c;
#line 1228
  l_step_l = l_max_res * l_step_r;
#line 1231
  l_current_pi = l_pi;
#line 1234
  __cil_tmp36 = calloc((unsigned long )((l_tcp->numlayers + 1U) * l_step_l), sizeof(OPJ_INT16 ));
#line 1234
  l_current_pi->include = (OPJ_INT16 *)__cil_tmp36;
  }
#line 1235
  if (! l_current_pi->include) {
    {
#line 1238
    free(l_tmp_data);
#line 1239
    free(l_tmp_ptr);
#line 1240
    opj_pi_destroy(l_pi, l_bound);
    }
#line 1241
    return ((opj_pi_iterator_t *)0);
  }
#line 1245
  l_current_comp = l_current_pi->comps;
#line 1246
  l_img_comp = p_image->comps;
#line 1247
  l_tccp = l_tcp->tccps;
#line 1249
  l_current_pi->tx0 = l_tx0;
#line 1250
  l_current_pi->ty0 = l_ty0;
#line 1251
  l_current_pi->tx1 = l_tx1;
#line 1252
  l_current_pi->ty1 = l_ty1;
#line 1257
  l_current_pi->step_p = l_step_p;
#line 1258
  l_current_pi->step_c = l_step_c;
#line 1259
  l_current_pi->step_r = l_step_r;
#line 1260
  l_current_pi->step_l = l_step_l;
#line 1264
  compno = (OPJ_UINT32 )0;
  {
#line 1263
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1263
    if (! (compno < l_current_pi->numcomps)) {
#line 1263
      goto while_break___0;
    }
#line 1266
    l_res = l_current_comp->resolutions;
#line 1267
    l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1269
    l_current_comp->dx = l_img_comp->dx;
#line 1270
    l_current_comp->dy = l_img_comp->dy;
#line 1273
    resno = (OPJ_UINT32 )0;
    {
#line 1272
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1272
      if (! (resno < l_current_comp->numresolutions)) {
#line 1272
        goto while_break___1;
      }
#line 1275
      __cil_tmp38 = l_encoding_value_ptr;
#line 1275
      l_encoding_value_ptr ++;
#line 1275
      l_res->pdx = *__cil_tmp38;
#line 1276
      __cil_tmp39 = l_encoding_value_ptr;
#line 1276
      l_encoding_value_ptr ++;
#line 1276
      l_res->pdy = *__cil_tmp39;
#line 1277
      __cil_tmp40 = l_encoding_value_ptr;
#line 1277
      l_encoding_value_ptr ++;
#line 1277
      l_res->pw = *__cil_tmp40;
#line 1278
      __cil_tmp41 = l_encoding_value_ptr;
#line 1278
      l_encoding_value_ptr ++;
#line 1278
      l_res->ph = *__cil_tmp41;
#line 1279
      l_res ++;
#line 1273
      resno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1281
    l_current_comp ++;
#line 1282
    l_img_comp ++;
#line 1283
    l_tccp ++;
#line 1264
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1285
  l_current_pi ++;
#line 1287
  pino = (OPJ_UINT32 )1;
  {
#line 1287
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1287
    if (! (pino < l_bound)) {
#line 1287
      goto while_break___2;
    }
#line 1289
    l_current_comp = l_current_pi->comps;
#line 1290
    l_img_comp = p_image->comps;
#line 1291
    l_tccp = l_tcp->tccps;
#line 1293
    l_current_pi->tx0 = l_tx0;
#line 1294
    l_current_pi->ty0 = l_ty0;
#line 1295
    l_current_pi->tx1 = l_tx1;
#line 1296
    l_current_pi->ty1 = l_ty1;
#line 1299
    l_current_pi->step_p = l_step_p;
#line 1300
    l_current_pi->step_c = l_step_c;
#line 1301
    l_current_pi->step_r = l_step_r;
#line 1302
    l_current_pi->step_l = l_step_l;
#line 1306
    compno = (OPJ_UINT32 )0;
    {
#line 1305
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1305
      if (! (compno < l_current_pi->numcomps)) {
#line 1305
        goto while_break___3;
      }
#line 1308
      l_res___0 = l_current_comp->resolutions;
#line 1309
      l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1311
      l_current_comp->dx = l_img_comp->dx;
#line 1312
      l_current_comp->dy = l_img_comp->dy;
#line 1315
      resno = (OPJ_UINT32 )0;
      {
#line 1314
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1314
        if (! (resno < l_current_comp->numresolutions)) {
#line 1314
          goto while_break___4;
        }
#line 1317
        __cil_tmp44 = l_encoding_value_ptr;
#line 1317
        l_encoding_value_ptr ++;
#line 1317
        l_res___0->pdx = *__cil_tmp44;
#line 1318
        __cil_tmp45 = l_encoding_value_ptr;
#line 1318
        l_encoding_value_ptr ++;
#line 1318
        l_res___0->pdy = *__cil_tmp45;
#line 1319
        __cil_tmp46 = l_encoding_value_ptr;
#line 1319
        l_encoding_value_ptr ++;
#line 1319
        l_res___0->pw = *__cil_tmp46;
#line 1320
        __cil_tmp47 = l_encoding_value_ptr;
#line 1320
        l_encoding_value_ptr ++;
#line 1320
        l_res___0->ph = *__cil_tmp47;
#line 1321
        l_res___0 ++;
#line 1315
        resno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1323
      l_current_comp ++;
#line 1324
      l_img_comp ++;
#line 1325
      l_tccp ++;
#line 1306
      compno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1328
    l_current_pi->include = (l_current_pi - 1)->include;
#line 1329
    l_current_pi ++;
#line 1287
    pino ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1331
  free(l_tmp_data);
#line 1332
  l_tmp_data = (OPJ_UINT32 *)0;
#line 1333
  free(l_tmp_ptr);
#line 1334
  l_tmp_ptr = (OPJ_UINT32 **)0;
  }
#line 1335
  if (l_tcp->POC) {
    {
#line 1338
    opj_pi_update_decode_poc(l_pi, l_tcp, l_max_prec, l_max_res);
    }
  } else {
    {
#line 1342
    opj_pi_update_decode_not_poc(l_pi, l_tcp, l_max_prec, l_max_res);
    }
  }
#line 1344
  return (l_pi);
}
}
#line 1349 "/root/patron/new_21/src/lib/openjp2/pi.c"
opj_pi_iterator_t *opj_pi_initialise_encode(opj_image_t *p_image , opj_cp_t *p_cp ,
                                            OPJ_UINT32 p_tile_no , J2K_T2_MODE p_t2_mode ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 *l_tmp_data ;
  OPJ_UINT32 **l_tmp_ptr ;
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_INT32 l_tx0 ;
  OPJ_INT32 l_tx1 ;
  OPJ_INT32 l_ty0 ;
  OPJ_INT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  OPJ_UINT32 l_bound ;
  OPJ_UINT32 l_step_p ;
  OPJ_UINT32 l_step_c ;
  OPJ_UINT32 l_step_r ;
  OPJ_UINT32 l_step_l ;
  OPJ_UINT32 l_data_stride ;
  opj_pi_iterator_t *l_pi ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_pi_comp_t *l_current_comp ;
  opj_image_comp_t *l_img_comp ;
  opj_pi_iterator_t *l_current_pi ;
  OPJ_UINT32 *l_encoding_value_ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  opj_pi_iterator_t *__cil_tmp36 ;
  void *__cil_tmp37 ;
  opj_pi_resolution_t *l_res ;
  OPJ_UINT32 *__cil_tmp39 ;
  OPJ_UINT32 *__cil_tmp40 ;
  OPJ_UINT32 *__cil_tmp41 ;
  OPJ_UINT32 *__cil_tmp42 ;
  OPJ_UINT32 __cil_tmp43 ;
  opj_pi_resolution_t *l_res___0 ;
  OPJ_UINT32 *__cil_tmp45 ;
  OPJ_UINT32 *__cil_tmp46 ;
  OPJ_UINT32 *__cil_tmp47 ;
  OPJ_UINT32 *__cil_tmp48 ;
  OPJ_UINT32 __cil_tmp49 ;

  {
  {
#line 1372
  l_pi = (opj_pi_iterator_t *)0;
#line 1373
  l_tcp = (opj_tcp_t *)0;
#line 1374
  l_tccp = (opj_tccp_t *)0;
#line 1375
  l_current_comp = (opj_pi_comp_t *)0;
#line 1376
  l_img_comp = (opj_image_comp_t *)0;
#line 1377
  l_current_pi = (opj_pi_iterator_t *)0;
#line 1378
  l_encoding_value_ptr = (OPJ_UINT32 *)0;
#line 1386
  l_tcp = p_cp->tcps + p_tile_no;
#line 1387
  l_bound = l_tcp->numpocs + 1U;
#line 1389
  l_data_stride = (OPJ_UINT32 )132;
#line 1390
  __cil_tmp34 = malloc((unsigned long )(l_data_stride * p_image->numcomps) * sizeof(OPJ_UINT32 ));
#line 1390
  l_tmp_data = (OPJ_UINT32 *)__cil_tmp34;
  }
#line 1392
  if (! l_tmp_data) {
#line 1393
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1396
  __cil_tmp35 = malloc((unsigned long )p_image->numcomps * sizeof(OPJ_UINT32 *));
#line 1396
  l_tmp_ptr = (OPJ_UINT32 **)__cil_tmp35;
  }
#line 1398
  if (! l_tmp_ptr) {
    {
#line 1399
    free(l_tmp_data);
    }
#line 1400
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1404
  l_pi = opj_pi_create(p_image, p_cp, p_tile_no);
  }
#line 1405
  if (! l_pi) {
    {
#line 1406
    free(l_tmp_data);
#line 1407
    free(l_tmp_ptr);
    }
#line 1408
    return ((opj_pi_iterator_t *)0);
  }
#line 1411
  l_encoding_value_ptr = l_tmp_data;
#line 1413
  compno = (OPJ_UINT32 )0;
  {
#line 1413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1413
    if (! (compno < p_image->numcomps)) {
#line 1413
      goto while_break;
    }
#line 1414
    *(l_tmp_ptr + compno) = l_encoding_value_ptr;
#line 1415
    l_encoding_value_ptr += l_data_stride;
#line 1413
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1419
  opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                                  & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res,
                                  l_tmp_ptr);
#line 1422
  l_step_p = (OPJ_UINT32 )1;
#line 1423
  l_step_c = l_max_prec * l_step_p;
#line 1424
  l_step_r = p_image->numcomps * l_step_c;
#line 1425
  l_step_l = l_max_res * l_step_r;
#line 1428
  l_pi->tp_on = (OPJ_BYTE )p_cp->m_specific_param.m_enc.m_tp_on;
#line 1429
  l_current_pi = l_pi;
#line 1432
  __cil_tmp37 = calloc((unsigned long )(l_tcp->numlayers * l_step_l), sizeof(OPJ_INT16 ));
#line 1432
  l_current_pi->include = (OPJ_INT16 *)__cil_tmp37;
  }
#line 1433
  if (! l_current_pi->include) {
    {
#line 1434
    free(l_tmp_data);
#line 1435
    free(l_tmp_ptr);
#line 1436
    opj_pi_destroy(l_pi, l_bound);
    }
#line 1437
    return ((opj_pi_iterator_t *)0);
  }
#line 1441
  l_current_comp = l_current_pi->comps;
#line 1442
  l_img_comp = p_image->comps;
#line 1443
  l_tccp = l_tcp->tccps;
#line 1444
  l_current_pi->tx0 = l_tx0;
#line 1445
  l_current_pi->ty0 = l_ty0;
#line 1446
  l_current_pi->tx1 = l_tx1;
#line 1447
  l_current_pi->ty1 = l_ty1;
#line 1448
  l_current_pi->dx = l_dx_min;
#line 1449
  l_current_pi->dy = l_dy_min;
#line 1450
  l_current_pi->step_p = l_step_p;
#line 1451
  l_current_pi->step_c = l_step_c;
#line 1452
  l_current_pi->step_r = l_step_r;
#line 1453
  l_current_pi->step_l = l_step_l;
#line 1456
  compno = (OPJ_UINT32 )0;
  {
#line 1456
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1456
    if (! (compno < l_current_pi->numcomps)) {
#line 1456
      goto while_break___0;
    }
#line 1457
    l_res = l_current_comp->resolutions;
#line 1458
    l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1460
    l_current_comp->dx = l_img_comp->dx;
#line 1461
    l_current_comp->dy = l_img_comp->dy;
#line 1464
    resno = (OPJ_UINT32 )0;
    {
#line 1464
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1464
      if (! (resno < l_current_comp->numresolutions)) {
#line 1464
        goto while_break___1;
      }
#line 1465
      __cil_tmp39 = l_encoding_value_ptr;
#line 1465
      l_encoding_value_ptr ++;
#line 1465
      l_res->pdx = *__cil_tmp39;
#line 1466
      __cil_tmp40 = l_encoding_value_ptr;
#line 1466
      l_encoding_value_ptr ++;
#line 1466
      l_res->pdy = *__cil_tmp40;
#line 1467
      __cil_tmp41 = l_encoding_value_ptr;
#line 1467
      l_encoding_value_ptr ++;
#line 1467
      l_res->pw = *__cil_tmp41;
#line 1468
      __cil_tmp42 = l_encoding_value_ptr;
#line 1468
      l_encoding_value_ptr ++;
#line 1468
      l_res->ph = *__cil_tmp42;
#line 1469
      l_res ++;
#line 1464
      resno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1472
    l_current_comp ++;
#line 1473
    l_img_comp ++;
#line 1474
    l_tccp ++;
#line 1456
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1476
  l_current_pi ++;
#line 1478
  pino = (OPJ_UINT32 )1;
  {
#line 1478
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1478
    if (! (pino < l_bound)) {
#line 1478
      goto while_break___2;
    }
#line 1479
    l_current_comp = l_current_pi->comps;
#line 1480
    l_img_comp = p_image->comps;
#line 1481
    l_tccp = l_tcp->tccps;
#line 1483
    l_current_pi->tx0 = l_tx0;
#line 1484
    l_current_pi->ty0 = l_ty0;
#line 1485
    l_current_pi->tx1 = l_tx1;
#line 1486
    l_current_pi->ty1 = l_ty1;
#line 1487
    l_current_pi->dx = l_dx_min;
#line 1488
    l_current_pi->dy = l_dy_min;
#line 1489
    l_current_pi->step_p = l_step_p;
#line 1490
    l_current_pi->step_c = l_step_c;
#line 1491
    l_current_pi->step_r = l_step_r;
#line 1492
    l_current_pi->step_l = l_step_l;
#line 1495
    compno = (OPJ_UINT32 )0;
    {
#line 1495
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1495
      if (! (compno < l_current_pi->numcomps)) {
#line 1495
        goto while_break___3;
      }
#line 1496
      l_res___0 = l_current_comp->resolutions;
#line 1497
      l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1499
      l_current_comp->dx = l_img_comp->dx;
#line 1500
      l_current_comp->dy = l_img_comp->dy;
#line 1502
      resno = (OPJ_UINT32 )0;
      {
#line 1502
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1502
        if (! (resno < l_current_comp->numresolutions)) {
#line 1502
          goto while_break___4;
        }
#line 1503
        __cil_tmp45 = l_encoding_value_ptr;
#line 1503
        l_encoding_value_ptr ++;
#line 1503
        l_res___0->pdx = *__cil_tmp45;
#line 1504
        __cil_tmp46 = l_encoding_value_ptr;
#line 1504
        l_encoding_value_ptr ++;
#line 1504
        l_res___0->pdy = *__cil_tmp46;
#line 1505
        __cil_tmp47 = l_encoding_value_ptr;
#line 1505
        l_encoding_value_ptr ++;
#line 1505
        l_res___0->pw = *__cil_tmp47;
#line 1506
        __cil_tmp48 = l_encoding_value_ptr;
#line 1506
        l_encoding_value_ptr ++;
#line 1506
        l_res___0->ph = *__cil_tmp48;
#line 1507
        l_res___0 ++;
#line 1502
        resno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1509
      l_current_comp ++;
#line 1510
      l_img_comp ++;
#line 1511
      l_tccp ++;
#line 1495
      compno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1515
    l_current_pi->include = (l_current_pi - 1)->include;
#line 1516
    l_current_pi ++;
#line 1478
    pino ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1519
  free(l_tmp_data);
#line 1520
  l_tmp_data = (OPJ_UINT32 *)0;
#line 1521
  free(l_tmp_ptr);
#line 1522
  l_tmp_ptr = (OPJ_UINT32 **)0;
  }
#line 1524
  if ((int )l_tcp->POC) {
#line 1524
    if ((int )p_cp->rsiz >= 3) {
#line 1524
      if ((int )p_cp->rsiz <= 6) {
        {
        {
#line 1525
        opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                           l_max_prec, l_max_res, l_dx_min, l_dy_min);
        }
        }
      } else {
#line 1524
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1524
    if ((unsigned int )p_t2_mode == 1U) {
      {
      {
#line 1525
      opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                         l_max_prec, l_max_res, l_dx_min, l_dy_min);
      }
      }
    } else {
      {
      {
#line 1528
      opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,
                                   l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min,
                                   l_dy_min);
      }
      }
    }
  } else {
    {
    {
#line 1528
    opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,
                                 l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
    }
  }
#line 1531
  return (l_pi);
}
}
#line 1534 "/root/patron/new_21/src/lib/openjp2/pi.c"
void opj_pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , OPJ_UINT32 tileno ,
                          OPJ_UINT32 pino , OPJ_UINT32 tpnum , OPJ_INT32 tppos , J2K_T2_MODE t2_mode ) 
{ 
  OPJ_CHAR *prog ;
  OPJ_INT32 i ;
  OPJ_UINT32 incr_top ;
  OPJ_UINT32 resetX ;
  opj_tcp_t *tcps ;
  opj_poc_t *tcp ;
  char *__cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_INT32 __cil_tmp22 ;

  {
#line 1544
  incr_top = (OPJ_UINT32 )1;
  {
#line 1544
  resetX = (OPJ_UINT32 )0;
#line 1545
  tcps = cp->tcps + tileno;
#line 1546
  tcp = & tcps->pocs[pino];
#line 1548
  prog = opj_j2k_convert_progression_order(tcp->prg);
#line 1550
  (pi + pino)->first = 1;
#line 1551
  (pi + pino)->poc.prg = tcp->prg;
  }
#line 1553
  if (! ((int )cp->m_specific_param.m_enc.m_tp_on && ((! ((int )cp->rsiz >= 3 && (int )cp->rsiz <= 6) && (unsigned int )t2_mode == 1U) || ((int )cp->rsiz >= 3 && (int )cp->rsiz <= 6)))) {
#line 1554
    (pi + pino)->poc.resno0 = tcp->resS;
#line 1555
    (pi + pino)->poc.resno1 = tcp->resE;
#line 1556
    (pi + pino)->poc.compno0 = tcp->compS;
#line 1557
    (pi + pino)->poc.compno1 = tcp->compE;
#line 1558
    (pi + pino)->poc.layno0 = tcp->layS;
#line 1559
    (pi + pino)->poc.layno1 = tcp->layE;
#line 1560
    (pi + pino)->poc.precno0 = tcp->prcS;
#line 1561
    (pi + pino)->poc.precno1 = tcp->prcE;
#line 1562
    (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->txS;
#line 1563
    (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->tyS;
#line 1564
    (pi + pino)->poc.tx1 = (OPJ_INT32 )tcp->txE;
#line 1565
    (pi + pino)->poc.ty1 = (OPJ_INT32 )tcp->tyE;
  } else {
#line 1567
    i = tppos + 1;
    {
#line 1567
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1567
      if (! (i < 4)) {
#line 1567
        goto while_break;
      }
      {
#line 1569
      if ((int )*(prog + i) == 'R') {
#line 1569
        goto case_82;
      }
#line 1573
      if ((int )*(prog + i) == 'C') {
#line 1573
        goto case_67;
      }
#line 1577
      if ((int )*(prog + i) == 'L') {
#line 1577
        goto case_76;
      }
#line 1581
      if ((int )*(prog + i) == 'P') {
#line 1581
        goto case_80;
      }
#line 1584
      if ((int )*(prog + i) == 1) {
#line 1584
        goto case_1;
      }
#line 1584
      if ((int )*(prog + i) == 0) {
#line 1584
        goto case_1;
      }
#line 1588
      goto switch_default;
      case_82: /* CIL Label */ 
#line 1570
      (pi + pino)->poc.resno0 = tcp->resS;
#line 1571
      (pi + pino)->poc.resno1 = tcp->resE;
#line 1572
      goto switch_break;
      case_67: /* CIL Label */ 
#line 1574
      (pi + pino)->poc.compno0 = tcp->compS;
#line 1575
      (pi + pino)->poc.compno1 = tcp->compE;
#line 1576
      goto switch_break;
      case_76: /* CIL Label */ 
#line 1578
      (pi + pino)->poc.layno0 = tcp->layS;
#line 1579
      (pi + pino)->poc.layno1 = tcp->layE;
#line 1580
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 1584
      if ((int )tcp->prg == 1) {
#line 1584
        goto case_1;
      }
#line 1584
      if ((int )tcp->prg == 0) {
#line 1584
        goto case_1;
      }
#line 1588
      goto switch_default;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 1585
      (pi + pino)->poc.precno0 = tcp->prcS;
#line 1586
      (pi + pino)->poc.precno1 = tcp->prcE;
#line 1587
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 1589
      (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->txS;
#line 1590
      (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->tyS;
#line 1591
      (pi + pino)->poc.tx1 = (OPJ_INT32 )tcp->txE;
#line 1592
      (pi + pino)->poc.ty1 = (OPJ_INT32 )tcp->tyE;
#line 1593
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 1595
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1567
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1599
    if (tpnum == 0U) {
#line 1600
      i = tppos;
      {
#line 1600
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1600
        if (! (i >= 0)) {
#line 1600
          goto while_break___0;
        }
        {
#line 1602
        if ((int )*(prog + i) == 'C') {
#line 1602
          goto case_67___0;
        }
#line 1608
        if ((int )*(prog + i) == 'R') {
#line 1608
          goto case_82___0;
        }
#line 1614
        if ((int )*(prog + i) == 'L') {
#line 1614
          goto case_76___0;
        }
#line 1620
        if ((int )*(prog + i) == 'P') {
#line 1620
          goto case_80___0;
        }
#line 1623
        if ((int )*(prog + i) == 1) {
#line 1623
          goto case_1___0;
        }
#line 1623
        if ((int )*(prog + i) == 0) {
#line 1623
          goto case_1___0;
        }
#line 1629
        goto switch_default___0;
        case_67___0: /* CIL Label */ 
#line 1603
        tcp->comp_t = tcp->compS;
#line 1604
        (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1605
        (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1606
        tcp->comp_t += (unsigned int )1;
#line 1607
        goto switch_break___1;
        case_82___0: /* CIL Label */ 
#line 1609
        tcp->res_t = tcp->resS;
#line 1610
        (pi + pino)->poc.resno0 = tcp->res_t;
#line 1611
        (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1612
        tcp->res_t += (unsigned int )1;
#line 1613
        goto switch_break___1;
        case_76___0: /* CIL Label */ 
#line 1615
        tcp->lay_t = tcp->layS;
#line 1616
        (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1617
        (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1618
        tcp->lay_t += (unsigned int )1;
#line 1619
        goto switch_break___1;
        case_80___0: /* CIL Label */ 
        {
#line 1623
        if ((int )tcp->prg == 1) {
#line 1623
          goto case_1___0;
        }
#line 1623
        if ((int )tcp->prg == 0) {
#line 1623
          goto case_1___0;
        }
#line 1629
        goto switch_default___0;
        case_1___0: /* CIL Label */ 
        case_0___0: /* CIL Label */ 
#line 1624
        tcp->prc_t = tcp->prcS;
#line 1625
        (pi + pino)->poc.precno0 = tcp->prc_t;
#line 1626
        (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 1627
        tcp->prc_t += (unsigned int )1;
#line 1628
        goto switch_break___2;
        switch_default___0: /* CIL Label */ 
#line 1630
        tcp->tx0_t = tcp->txS;
#line 1631
        tcp->ty0_t = tcp->tyS;
#line 1632
        (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->tx0_t;
#line 1633
        (pi + pino)->poc.tx1 = (OPJ_INT32 )((tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1634
        (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->ty0_t;
#line 1635
        (pi + pino)->poc.ty1 = (OPJ_INT32 )((tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1636
        tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
#line 1637
        tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 1638
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
#line 1640
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 1600
        __cil_tmp16 = i;
#line 1600
        i --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1643
      incr_top = (OPJ_UINT32 )1;
    } else {
#line 1645
      i = tppos;
      {
#line 1645
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1645
        if (! (i >= 0)) {
#line 1645
          goto while_break___1;
        }
        {
#line 1647
        if ((int )*(prog + i) == 'C') {
#line 1647
          goto case_67___1;
        }
#line 1651
        if ((int )*(prog + i) == 'R') {
#line 1651
          goto case_82___1;
        }
#line 1655
        if ((int )*(prog + i) == 'L') {
#line 1655
          goto case_76___1;
        }
#line 1659
        if ((int )*(prog + i) == 'P') {
#line 1659
          goto case_80___1;
        }
#line 1662
        if ((int )*(prog + i) == 1) {
#line 1662
          goto case_1___1;
        }
#line 1662
        if ((int )*(prog + i) == 0) {
#line 1662
          goto case_1___1;
        }
#line 1666
        goto switch_default___1;
        case_67___1: /* CIL Label */ 
#line 1648
        (pi + pino)->poc.compno0 = tcp->comp_t - 1U;
#line 1649
        (pi + pino)->poc.compno1 = tcp->comp_t;
#line 1650
        goto switch_break___3;
        case_82___1: /* CIL Label */ 
#line 1652
        (pi + pino)->poc.resno0 = tcp->res_t - 1U;
#line 1653
        (pi + pino)->poc.resno1 = tcp->res_t;
#line 1654
        goto switch_break___3;
        case_76___1: /* CIL Label */ 
#line 1656
        (pi + pino)->poc.layno0 = tcp->lay_t - 1U;
#line 1657
        (pi + pino)->poc.layno1 = tcp->lay_t;
#line 1658
        goto switch_break___3;
        case_80___1: /* CIL Label */ 
        {
#line 1662
        if ((int )tcp->prg == 1) {
#line 1662
          goto case_1___1;
        }
#line 1662
        if ((int )tcp->prg == 0) {
#line 1662
          goto case_1___1;
        }
#line 1666
        goto switch_default___1;
        case_1___1: /* CIL Label */ 
        case_0___1: /* CIL Label */ 
#line 1663
        (pi + pino)->poc.precno0 = tcp->prc_t - 1U;
#line 1664
        (pi + pino)->poc.precno1 = tcp->prc_t;
#line 1665
        goto switch_break___4;
        switch_default___1: /* CIL Label */ 
#line 1667
        (pi + pino)->poc.tx0 = (OPJ_INT32 )((tcp->tx0_t - tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1668
        (pi + pino)->poc.tx1 = (OPJ_INT32 )tcp->tx0_t;
#line 1669
        (pi + pino)->poc.ty0 = (OPJ_INT32 )((tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1670
        (pi + pino)->poc.ty1 = (OPJ_INT32 )tcp->ty0_t;
#line 1671
        goto switch_break___4;
        switch_break___4: /* CIL Label */ ;
        }
#line 1673
        goto switch_break___3;
        switch_break___3: /* CIL Label */ ;
        }
#line 1675
        if (incr_top == 1U) {
          {
#line 1677
          if ((int )*(prog + i) == 'R') {
#line 1677
            goto case_82___2;
          }
#line 1695
          if ((int )*(prog + i) == 'C') {
#line 1695
            goto case_67___2;
          }
#line 1713
          if ((int )*(prog + i) == 'L') {
#line 1713
            goto case_76___2;
          }
#line 1731
          if ((int )*(prog + i) == 'P') {
#line 1731
            goto case_80___2;
          }
#line 1734
          if ((int )*(prog + i) == 1) {
#line 1734
            goto case_1___2;
          }
#line 1734
          if ((int )*(prog + i) == 0) {
#line 1734
            goto case_1___2;
          }
#line 1752
          goto switch_default___2;
          case_82___2: /* CIL Label */ 
#line 1678
          if (tcp->res_t == tcp->resE) {
            {
#line 1679
            __cil_tmp17 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
            }
#line 1679
            if (__cil_tmp17) {
#line 1680
              tcp->res_t = tcp->resS;
#line 1681
              (pi + pino)->poc.resno0 = tcp->res_t;
#line 1682
              (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1683
              tcp->res_t += (unsigned int )1;
#line 1684
              incr_top = (OPJ_UINT32 )1;
            } else {
#line 1686
              incr_top = (OPJ_UINT32 )0;
            }
          } else {
#line 1689
            (pi + pino)->poc.resno0 = tcp->res_t;
#line 1690
            (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1691
            tcp->res_t += (unsigned int )1;
#line 1692
            incr_top = (OPJ_UINT32 )0;
          }
#line 1694
          goto switch_break___5;
          case_67___2: /* CIL Label */ 
#line 1696
          if (tcp->comp_t == tcp->compE) {
            {
#line 1697
            __cil_tmp18 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
            }
#line 1697
            if (__cil_tmp18) {
#line 1698
              tcp->comp_t = tcp->compS;
#line 1699
              (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1700
              (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1701
              tcp->comp_t += (unsigned int )1;
#line 1702
              incr_top = (OPJ_UINT32 )1;
            } else {
#line 1704
              incr_top = (OPJ_UINT32 )0;
            }
          } else {
#line 1707
            (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1708
            (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1709
            tcp->comp_t += (unsigned int )1;
#line 1710
            incr_top = (OPJ_UINT32 )0;
          }
#line 1712
          goto switch_break___5;
          case_76___2: /* CIL Label */ 
#line 1714
          if (tcp->lay_t == tcp->layE) {
            {
#line 1715
            __cil_tmp19 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
            }
#line 1715
            if (__cil_tmp19) {
#line 1716
              tcp->lay_t = tcp->layS;
#line 1717
              (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1718
              (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1719
              tcp->lay_t += (unsigned int )1;
#line 1720
              incr_top = (OPJ_UINT32 )1;
            } else {
#line 1722
              incr_top = (OPJ_UINT32 )0;
            }
          } else {
#line 1725
            (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1726
            (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1727
            tcp->lay_t += (unsigned int )1;
#line 1728
            incr_top = (OPJ_UINT32 )0;
          }
#line 1730
          goto switch_break___5;
          case_80___2: /* CIL Label */ 
          {
#line 1734
          if ((int )tcp->prg == 1) {
#line 1734
            goto case_1___2;
          }
#line 1734
          if ((int )tcp->prg == 0) {
#line 1734
            goto case_1___2;
          }
#line 1752
          goto switch_default___2;
          case_1___2: /* CIL Label */ 
          case_0___2: /* CIL Label */ 
#line 1735
          if (tcp->prc_t == tcp->prcE) {
            {
#line 1736
            __cil_tmp20 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
            }
#line 1736
            if (__cil_tmp20) {
#line 1737
              tcp->prc_t = tcp->prcS;
#line 1738
              (pi + pino)->poc.precno0 = tcp->prc_t;
#line 1739
              (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 1740
              tcp->prc_t += (unsigned int )1;
#line 1741
              incr_top = (OPJ_UINT32 )1;
            } else {
#line 1743
              incr_top = (OPJ_UINT32 )0;
            }
          } else {
#line 1746
            (pi + pino)->poc.precno0 = tcp->prc_t;
#line 1747
            (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 1748
            tcp->prc_t += (unsigned int )1;
#line 1749
            incr_top = (OPJ_UINT32 )0;
          }
#line 1751
          goto switch_break___6;
          switch_default___2: /* CIL Label */ 
#line 1753
          if (tcp->tx0_t >= tcp->txE) {
#line 1754
            if (tcp->ty0_t >= tcp->tyE) {
              {
#line 1755
              __cil_tmp21 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
              }
#line 1755
              if (__cil_tmp21) {
#line 1756
                tcp->ty0_t = tcp->tyS;
#line 1757
                (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->ty0_t;
#line 1758
                (pi + pino)->poc.ty1 = (OPJ_INT32 )((tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1759
                tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 1760
                incr_top = (OPJ_UINT32 )1;
#line 1760
                resetX = (OPJ_UINT32 )1;
              } else {
#line 1762
                incr_top = (OPJ_UINT32 )0;
#line 1762
                resetX = (OPJ_UINT32 )0;
              }
            } else {
#line 1765
              (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->ty0_t;
#line 1766
              (pi + pino)->poc.ty1 = (OPJ_INT32 )((tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1767
              tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 1768
              incr_top = (OPJ_UINT32 )0;
#line 1768
              resetX = (OPJ_UINT32 )1;
            }
#line 1770
            if (resetX == 1U) {
#line 1771
              tcp->tx0_t = tcp->txS;
#line 1772
              (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->tx0_t;
#line 1773
              (pi + pino)->poc.tx1 = (OPJ_INT32 )((tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1774
              tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
            }
          } else {
#line 1777
            (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->tx0_t;
#line 1778
            (pi + pino)->poc.tx1 = (OPJ_INT32 )((tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1779
            tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
#line 1780
            incr_top = (OPJ_UINT32 )0;
          }
#line 1782
          goto switch_break___6;
          switch_break___6: /* CIL Label */ ;
          }
#line 1784
          goto switch_break___5;
          switch_break___5: /* CIL Label */ ;
          }
        }
#line 1645
        __cil_tmp22 = i;
#line 1645
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 1792 "/root/patron/new_21/src/lib/openjp2/pi.c"
void opj_pi_destroy(opj_pi_iterator_t *p_pi , OPJ_UINT32 p_nb_elements ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 pino ;
  opj_pi_iterator_t *l_current_pi ;
  opj_pi_comp_t *l_current_component ;
  OPJ_UINT32 __cil_tmp7 ;

  {
#line 1796
  l_current_pi = p_pi;
#line 1797
  if (p_pi) {
#line 1798
    if (p_pi->include) {
      {
#line 1799
      free(p_pi->include);
#line 1800
      p_pi->include = (OPJ_INT16 *)0;
      }
    }
#line 1802
    pino = (OPJ_UINT32 )0;
    {
#line 1802
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1802
      if (! (pino < p_nb_elements)) {
#line 1802
        goto while_break;
      }
#line 1803
      if (l_current_pi->comps) {
#line 1804
        l_current_component = l_current_pi->comps;
#line 1805
        compno = (OPJ_UINT32 )0;
        {
#line 1805
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1805
          if (! (compno < l_current_pi->numcomps)) {
#line 1805
            goto while_break___0;
          }
#line 1806
          if (l_current_component->resolutions) {
            {
#line 1807
            free(l_current_component->resolutions);
#line 1808
            l_current_component->resolutions = (opj_pi_resolution_t *)0;
            }
          }
#line 1811
          l_current_component ++;
#line 1805
          compno ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1813
        free(l_current_pi->comps);
#line 1814
        l_current_pi->comps = (opj_pi_comp_t *)0;
        }
      }
#line 1816
      l_current_pi ++;
#line 1802
      pino ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1818
    free(p_pi);
    }
  }
  return;
}
}
#line 1824 "/root/patron/new_21/src/lib/openjp2/pi.c"
void opj_pi_update_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_INT32 l_tx0 ;
  OPJ_INT32 l_tx1 ;
  OPJ_INT32 l_ty0 ;
  OPJ_INT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  opj_tcp_t *l_tcp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1835
  l_tcp = (opj_tcp_t *)0;
#line 1842
  l_tcp = p_cp->tcps + p_tile_no;
#line 1845
  opj_get_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                              & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res);
  }
#line 1847
  if (l_tcp->POC) {
    {
#line 1848
    opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                       l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
  } else {
    {
#line 1851
    opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,
                                 l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
  }
  return;
}
}
#line 1855 "/root/patron/new_21/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next(opj_pi_iterator_t *pi ) 
{ 
  OPJ_BOOL __cil_tmp2 ;
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
  {
#line 1857
  if ((int )pi->poc.prg == 0) {
#line 1857
    goto case_0;
  }
#line 1859
  if ((int )pi->poc.prg == 1) {
#line 1859
    goto case_1;
  }
#line 1861
  if ((int )pi->poc.prg == 2) {
#line 1861
    goto case_2;
  }
#line 1863
  if ((int )pi->poc.prg == 3) {
#line 1863
    goto case_3;
  }
#line 1865
  if ((int )pi->poc.prg == 4) {
#line 1865
    goto case_4;
  }
#line 1867
  if ((int )pi->poc.prg == -1) {
#line 1867
    goto case_neg_1;
  }
#line 1856
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1858
  __cil_tmp2 = opj_pi_next_lrcp(pi);
  }
#line 1858
  return (__cil_tmp2);
  case_1: /* CIL Label */ 
  {
#line 1860
  __cil_tmp3 = opj_pi_next_rlcp(pi);
  }
#line 1860
  return (__cil_tmp3);
  case_2: /* CIL Label */ 
  {
#line 1862
  __cil_tmp4 = opj_pi_next_rpcl(pi);
  }
#line 1862
  return (__cil_tmp4);
  case_3: /* CIL Label */ 
  {
#line 1864
  __cil_tmp5 = opj_pi_next_pcrl(pi);
  }
#line 1864
  return (__cil_tmp5);
  case_4: /* CIL Label */ 
  {
#line 1866
  __cil_tmp6 = opj_pi_next_cprl(pi);
  }
#line 1866
  return (__cil_tmp6);
  case_neg_1: /* CIL Label */ 
#line 1868
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 1871
  return (0);
}
}
#line 66 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 75
extern  __attribute__((__nothrow__)) int settimeofday(struct timeval *__tv , struct timezone *__tz ) ;
#line 83
extern  __attribute__((__nothrow__)) int adjtime(struct timeval *__delta , struct timeval *__olddelta ) ;
#line 123
extern  __attribute__((__nothrow__)) int getitimer(__itimer_which_t __which , struct itimerval *__value ) ;
#line 129
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval *__new ,
                                                   struct itimerval *__old ) ;
#line 136
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 141
extern  __attribute__((__nothrow__)) int lutimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 145
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval __tvp[2] ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 87
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 93
extern  __attribute__((__nothrow__)) int getpriority(__priority_which_t __which ,
                                                     id_t __who ) ;
#line 97
extern  __attribute__((__nothrow__)) int setpriority(__priority_which_t __which ,
                                                     id_t __who , int __prio ) ;
#line 46 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t times(struct tms *__buffer ) ;
#line 41 "/root/patron/new_21/src/lib/openjp2/opj_clock.c"
OPJ_FLOAT64 opj_clock(void) 
{ 
  struct rusage t ;
  OPJ_FLOAT64 procTime ;

  {
  {
#line 56
  getrusage(0, & t);
#line 59
  procTime = (OPJ_FLOAT64 )(t.ru_utime.tv_sec + t.ru_stime.tv_sec);
  }
#line 61
  return (procTime + (OPJ_FLOAT64 )(t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-06);
}
}
#line 44 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_info_handler(opj_codec_t *p_codec , opj_msg_callback p_callback ,
                              void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 48
  l_codec = (opj_codec_private_t *)p_codec;
#line 49
  if (! l_codec) {
#line 50
    return (0);
  }
#line 53
  l_codec->m_event_mgr.info_handler = p_callback;
#line 54
  l_codec->m_event_mgr.m_info_data = p_user_data;
#line 56
  return (1);
}
}
#line 59 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_warning_handler(opj_codec_t *p_codec , opj_msg_callback p_callback ,
                                 void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 63
  l_codec = (opj_codec_private_t *)p_codec;
#line 64
  if (! l_codec) {
#line 65
    return (0);
  }
#line 68
  l_codec->m_event_mgr.warning_handler = p_callback;
#line 69
  l_codec->m_event_mgr.m_warning_data = p_user_data;
#line 71
  return (1);
}
}
#line 74 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_error_handler(opj_codec_t *p_codec , opj_msg_callback p_callback ,
                               void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 78
  l_codec = (opj_codec_private_t *)p_codec;
#line 79
  if (! l_codec) {
#line 80
    return (0);
  }
#line 83
  l_codec->m_event_mgr.error_handler = p_callback;
#line 84
  l_codec->m_event_mgr.m_error_data = p_user_data;
#line 86
  return (1);
}
}
#line 91 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
static OPJ_SIZE_T opj_read_from_file(void *p_buffer , OPJ_SIZE_T p_nb_bytes , FILE *p_file ) 
{ 
  OPJ_SIZE_T l_nb_read ;
  unsigned long __cil_tmp5 ;
  OPJ_SIZE_T tmp ;

  {
  {
#line 93
  __cil_tmp5 = fread(p_buffer, (unsigned long )1, p_nb_bytes, p_file);
#line 93
  l_nb_read = __cil_tmp5;
  }
#line 94
  if (l_nb_read) {
#line 94
    tmp = l_nb_read;
  } else {
#line 94
    tmp = (OPJ_SIZE_T )(- 1);
  }
#line 94
  return (tmp);
}
}
#line 97 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
static OPJ_UINT64 opj_get_data_length_from_file(FILE *p_file ) 
{ 
  OPJ_OFF_T file_length ;
  __off_t __cil_tmp3 ;

  {
  {
#line 99
  file_length = (OPJ_OFF_T )0;
#line 101
  fseeko(p_file, (__off_t )0, 2);
#line 102
  __cil_tmp3 = ftello(p_file);
#line 102
  file_length = (OPJ_OFF_T )__cil_tmp3;
#line 103
  fseeko(p_file, (__off_t )0, 0);
  }
#line 105
  return ((OPJ_UINT64 )file_length);
}
}
#line 108 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
static OPJ_SIZE_T opj_write_from_file(void *p_buffer , OPJ_SIZE_T p_nb_bytes , FILE *p_file ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 110
  __cil_tmp4 = fwrite(p_buffer, (unsigned long )1, p_nb_bytes, p_file);
  }
#line 110
  return (__cil_tmp4);
}
}
#line 113 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
static OPJ_OFF_T opj_skip_from_file(OPJ_OFF_T p_nb_bytes , FILE *p_user_data ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 115
  __cil_tmp3 = fseeko(p_user_data, p_nb_bytes, 1);
  }
#line 115
  if (__cil_tmp3) {
#line 116
    return ((OPJ_OFF_T )(- 1));
  }
#line 119
  return (p_nb_bytes);
}
}
#line 122 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
static OPJ_BOOL opj_seek_from_file(OPJ_OFF_T p_nb_bytes , FILE *p_user_data ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 124
  __cil_tmp3 = fseeko(p_user_data, p_nb_bytes, 0);
  }
#line 124
  if (__cil_tmp3) {
#line 125
    return (0);
  }
#line 128
  return (1);
}
}
#line 157 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
char const   *opj_version(void) 
{ 


  {
#line 158
  return ("2.1.0U");
}
}
#line 164 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
opj_codec_t *opj_create_decompress(OPJ_CODEC_FORMAT p_format ) 
{ 
  opj_codec_private_t *l_codec ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_jp2_t *__cil_tmp5 ;

  {
  {
#line 166
  l_codec = (opj_codec_private_t *)0;
#line 168
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_codec_private_t ));
#line 168
  l_codec = (opj_codec_private_t *)__cil_tmp3;
  }
#line 169
  if (! l_codec) {
#line 170
    return ((opj_codec_t *)0);
  }
#line 173
  l_codec->is_decompressor = 1;
  {
#line 176
  if ((int )p_format == 0) {
#line 176
    goto case_0;
  }
#line 251
  if ((int )p_format == 2) {
#line 251
    goto case_2;
  }
#line 328
  goto switch_default;
  case_0: /* CIL Label */ 
#line 177
  l_codec->opj_dump_codec = (void (*)(void * , OPJ_INT32  , FILE * ))(& j2k_dump);
  {
#line 179
  l_codec->opj_get_codec_info = (opj_codestream_info_v2_t *(*)(void * ))(& j2k_get_cstr_info);
#line 181
  l_codec->opj_get_codec_index = (opj_codestream_index_t *(*)(void * ))(& j2k_get_cstr_index);
#line 183
  l_codec->m_codec_data.m_decompression.opj_decode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                   opj_image_t * ,
                                                                   struct opj_event_mgr * ))(& opj_j2k_decode);
#line 188
  l_codec->m_codec_data.m_decompression.opj_end_decompress = (OPJ_BOOL (*)(void * ,
                                                                           struct opj_stream_private * ,
                                                                           struct opj_event_mgr * ))(& opj_j2k_end_decompress);
#line 193
  l_codec->m_codec_data.m_decompression.opj_read_header = (OPJ_BOOL (*)(struct opj_stream_private * ,
                                                                        void * , opj_image_t ** ,
                                                                        struct opj_event_mgr * ))(& opj_j2k_read_header);
#line 199
  l_codec->m_codec_data.m_decompression.opj_destroy = (void (*)(void * ))(& opj_j2k_destroy);
#line 202
  l_codec->m_codec_data.m_decompression.opj_setup_decoder = (void (*)(void * , opj_dparameters_t * ))(& opj_j2k_setup_decoder);
#line 205
  l_codec->m_codec_data.m_decompression.opj_read_tile_header = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_BOOL * ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_j2k_read_tile_header);
#line 216
  l_codec->m_codec_data.m_decompression.opj_decode_tile_data = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32  ,
                                                                             OPJ_BYTE * ,
                                                                             OPJ_UINT32  ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_j2k_decode_tile);
#line 224
  l_codec->m_codec_data.m_decompression.opj_set_decode_area = (OPJ_BOOL (*)(void * ,
                                                                            opj_image_t * ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            struct opj_event_mgr * ))(& opj_j2k_set_decode_area);
#line 230
  l_codec->m_codec_data.m_decompression.opj_get_decoded_tile = (OPJ_BOOL (*)(void * ,
                                                                             opj_stream_private_t * ,
                                                                             opj_image_t * ,
                                                                             struct opj_event_mgr * ,
                                                                             OPJ_UINT32  ))(& opj_j2k_get_tile);
#line 237
  l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor = (OPJ_BOOL (*)(void * ,
                                                                                          OPJ_UINT32  ,
                                                                                          struct opj_event_mgr * ))(& opj_j2k_set_decoded_resolution_factor);
#line 242
  l_codec->m_codec = (void *)opj_j2k_create_decompress();
  }
#line 244
  if (! l_codec->m_codec) {
    {
#line 245
    free(l_codec);
    }
#line 246
    return ((opj_codec_t *)((void *)0));
  }
#line 249
  goto switch_break;
  case_2: /* CIL Label */ 
#line 253
  l_codec->opj_dump_codec = (void (*)(void * , OPJ_INT32  , FILE * ))(& jp2_dump);
  {
#line 255
  l_codec->opj_get_codec_info = (opj_codestream_info_v2_t *(*)(void * ))(& jp2_get_cstr_info);
#line 257
  l_codec->opj_get_codec_index = (opj_codestream_index_t *(*)(void * ))(& jp2_get_cstr_index);
#line 259
  l_codec->m_codec_data.m_decompression.opj_decode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                   opj_image_t * ,
                                                                   struct opj_event_mgr * ))(& opj_jp2_decode);
#line 265
  l_codec->m_codec_data.m_decompression.opj_end_decompress = (OPJ_BOOL (*)(void * ,
                                                                           struct opj_stream_private * ,
                                                                           struct opj_event_mgr * ))(& opj_jp2_end_decompress);
#line 270
  l_codec->m_codec_data.m_decompression.opj_read_header = (OPJ_BOOL (*)(struct opj_stream_private * ,
                                                                        void * , opj_image_t ** ,
                                                                        struct opj_event_mgr * ))(& opj_jp2_read_header);
#line 276
  l_codec->m_codec_data.m_decompression.opj_read_tile_header = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_BOOL * ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_jp2_read_tile_header);
#line 289
  l_codec->m_codec_data.m_decompression.opj_decode_tile_data = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32  ,
                                                                             OPJ_BYTE * ,
                                                                             OPJ_UINT32  ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_jp2_decode_tile);
#line 295
  l_codec->m_codec_data.m_decompression.opj_destroy = (void (*)(void * ))(& opj_jp2_destroy);
#line 297
  l_codec->m_codec_data.m_decompression.opj_setup_decoder = (void (*)(void * , opj_dparameters_t * ))(& opj_jp2_setup_decoder);
#line 300
  l_codec->m_codec_data.m_decompression.opj_set_decode_area = (OPJ_BOOL (*)(void * ,
                                                                            opj_image_t * ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            struct opj_event_mgr * ))(& opj_jp2_set_decode_area);
#line 306
  l_codec->m_codec_data.m_decompression.opj_get_decoded_tile = (OPJ_BOOL (*)(void * ,
                                                                             opj_stream_private_t * ,
                                                                             opj_image_t * ,
                                                                             struct opj_event_mgr * ,
                                                                             OPJ_UINT32  ))(& opj_jp2_get_tile);
#line 313
  l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor = (OPJ_BOOL (*)(void * ,
                                                                                          OPJ_UINT32  ,
                                                                                          opj_event_mgr_t * ))(& opj_jp2_set_decoded_resolution_factor);
#line 318
  l_codec->m_codec = (void *)opj_jp2_create(1);
  }
#line 320
  if (! l_codec->m_codec) {
    {
#line 321
    free(l_codec);
    }
#line 322
    return ((opj_codec_t *)0);
  }
#line 325
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
  {
#line 329
  free(l_codec);
  }
#line 330
  return ((opj_codec_t *)0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 333
  opj_set_default_event_handler(& l_codec->m_event_mgr);
  }
#line 334
  return ((opj_codec_t *)l_codec);
}
}
#line 337 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) 
{ 


  {
#line 338
  if (parameters) {
    {
#line 339
    memset(parameters, 0, sizeof(opj_dparameters_t ));
#line 341
    parameters->cp_layer = (OPJ_UINT32 )0;
#line 342
    parameters->cp_reduce = (OPJ_UINT32 )0;
#line 344
    parameters->decod_format = - 1;
#line 345
    parameters->cod_format = - 1;
#line 346
    parameters->flags = (unsigned int )0;
    }
  }
  return;
}
}
#line 357 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_setup_decoder(opj_codec_t *p_codec , opj_dparameters_t *parameters ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 361
  if (p_codec) {
#line 361
    if (parameters) {
#line 362
      l_codec = (opj_codec_private_t *)p_codec;
#line 364
      if (! l_codec->is_decompressor) {
        {
#line 365
        opj_event_msg(& l_codec->m_event_mgr, 1, "Codec provided to the opj_setup_decoder function is not a decompressor handler.\n@q\021i\347U");
        }
#line 367
        return (0);
      }
      {
#line 370
      (*(l_codec->m_codec_data.m_decompression.opj_setup_decoder))(l_codec->m_codec,
                                                                   parameters);
      }
#line 372
      return (1);
    }
  }
#line 374
  return (0);
}
}
#line 377 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_read_header(opj_stream_t *p_stream , opj_codec_t *p_codec , opj_image_t **p_image ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 381
  if (p_codec) {
#line 381
    if (p_stream) {
#line 382
      l_codec = (opj_codec_private_t *)p_codec;
#line 383
      l_stream = (opj_stream_private_t *)p_stream;
#line 385
      if (! l_codec->is_decompressor) {
        {
#line 386
        opj_event_msg(& l_codec->m_event_mgr, 1, "Codec provided to the opj_read_header function is not a decompressor handler.\n");
        }
#line 388
        return (0);
      }
      {
#line 391
      __cil_tmp6 = (*(l_codec->m_codec_data.m_decompression.opj_read_header))(l_stream,
                                                                              l_codec->m_codec,
                                                                              p_image,
                                                                              & l_codec->m_event_mgr);
      }
#line 391
      return (__cil_tmp6);
    }
  }
#line 397
  return (0);
}
}
#line 400 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_decode(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 404
  if (p_codec) {
#line 404
    if (p_stream) {
#line 405
      l_codec = (opj_codec_private_t *)p_codec;
#line 406
      l_stream = (opj_stream_private_t *)p_stream;
#line 408
      if (! l_codec->is_decompressor) {
#line 409
        return (0);
      }
      {
#line 412
      __cil_tmp6 = (*(l_codec->m_codec_data.m_decompression.opj_decode))(l_codec->m_codec,
                                                                         l_stream,
                                                                         p_image,
                                                                         & l_codec->m_event_mgr);
      }
#line 412
      return (__cil_tmp6);
    }
  }
#line 418
  return (0);
}
}
#line 421 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_decode_area(opj_codec_t *p_codec , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                             OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ) 
{ 
  opj_codec_private_t *l_codec ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 427
  if (p_codec) {
#line 428
    l_codec = (opj_codec_private_t *)p_codec;
#line 430
    if (! l_codec->is_decompressor) {
#line 431
      return (0);
    }
    {
#line 434
    __cil_tmp8 = (*(l_codec->m_codec_data.m_decompression.opj_set_decode_area))(l_codec->m_codec,
                                                                                p_image,
                                                                                p_start_x,
                                                                                p_start_y,
                                                                                p_end_x,
                                                                                p_end_y,
                                                                                & l_codec->m_event_mgr);
    }
#line 434
    return (__cil_tmp8);
  }
#line 440
  return (0);
}
}
#line 443 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_read_tile_header(opj_codec_t *p_codec , opj_stream_t *p_stream , OPJ_UINT32 *p_tile_index ,
                              OPJ_UINT32 *p_data_size , OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 ,
                              OPJ_INT32 *p_tile_x1 , OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                              OPJ_BOOL *p_should_go_on ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp13 ;

  {
#line 452
  if (p_codec) {
#line 452
    if (p_stream) {
#line 452
      if (p_data_size) {
#line 452
        if (p_tile_index) {
#line 453
          l_codec = (opj_codec_private_t *)p_codec;
#line 454
          l_stream = (opj_stream_private_t *)p_stream;
#line 456
          if (! l_codec->is_decompressor) {
#line 457
            return (0);
          }
          {
#line 460
          __cil_tmp13 = (*(l_codec->m_codec_data.m_decompression.opj_read_tile_header))(l_codec->m_codec,
                                                                                        p_tile_index,
                                                                                        p_data_size,
                                                                                        p_tile_x0,
                                                                                        p_tile_y0,
                                                                                        p_tile_x1,
                                                                                        p_tile_y1,
                                                                                        p_nb_comps,
                                                                                        p_should_go_on,
                                                                                        l_stream,
                                                                                        & l_codec->m_event_mgr);
          }
#line 460
          return (__cil_tmp13);
        }
      }
    }
  }
#line 470
  return (0);
}
}
#line 473 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_decode_tile_data(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                              OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 480
  if (p_codec) {
#line 480
    if (p_data) {
#line 480
      if (p_stream) {
#line 481
        l_codec = (opj_codec_private_t *)p_codec;
#line 482
        l_stream = (opj_stream_private_t *)p_stream;
#line 484
        if (! l_codec->is_decompressor) {
#line 485
          return (0);
        }
        {
#line 488
        __cil_tmp8 = (*(l_codec->m_codec_data.m_decompression.opj_decode_tile_data))(l_codec->m_codec,
                                                                                     p_tile_index,
                                                                                     p_data,
                                                                                     p_data_size,
                                                                                     l_stream,
                                                                                     & l_codec->m_event_mgr);
        }
#line 488
        return (__cil_tmp8);
      }
    }
  }
#line 495
  return (0);
}
}
#line 498 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_get_decoded_tile(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ,
                              OPJ_UINT32 tile_index ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 503
  if (p_codec) {
#line 503
    if (p_stream) {
#line 504
      l_codec = (opj_codec_private_t *)p_codec;
#line 505
      l_stream = (opj_stream_private_t *)p_stream;
#line 507
      if (! l_codec->is_decompressor) {
#line 508
        return (0);
      }
      {
#line 511
      __cil_tmp7 = (*(l_codec->m_codec_data.m_decompression.opj_get_decoded_tile))(l_codec->m_codec,
                                                                                   l_stream,
                                                                                   p_image,
                                                                                   & l_codec->m_event_mgr,
                                                                                   tile_index);
      }
#line 511
      return (__cil_tmp7);
    }
  }
#line 518
  return (0);
}
}
#line 521 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_decoded_resolution_factor(opj_codec_t *p_codec , OPJ_UINT32 res_factor ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 524
  l_codec = (opj_codec_private_t *)p_codec;
#line 526
  if (! l_codec) {
    {
#line 527
    fprintf(stderr, "[ERROR] Input parameters of the setup_decoder function are incorrect.\n");
    }
#line 528
    return (0);
  }
  {
#line 531
  (*(l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor))(l_codec->m_codec,
                                                                               res_factor,
                                                                               & l_codec->m_event_mgr);
  }
#line 534
  return (1);
}
}
#line 540 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
opj_codec_t *opj_create_compress(OPJ_CODEC_FORMAT p_format ) 
{ 
  opj_codec_private_t *l_codec ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_jp2_t *__cil_tmp5 ;

  {
  {
#line 542
  l_codec = (opj_codec_private_t *)0;
#line 544
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_codec_private_t ));
#line 544
  l_codec = (opj_codec_private_t *)__cil_tmp3;
  }
#line 545
  if (! l_codec) {
#line 546
    return ((opj_codec_t *)0);
  }
#line 549
  l_codec->is_decompressor = 0;
  {
#line 552
  if ((int )p_format == 0) {
#line 552
    goto case_0;
  }
#line 588
  if ((int )p_format == 2) {
#line 588
    goto case_2;
  }
#line 627
  goto switch_default;
  case_0: /* CIL Label */ 
#line 553
  l_codec->m_codec_data.m_compression.opj_encode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                 struct opj_event_mgr * ))(& opj_j2k_encode);
  {
#line 557
  l_codec->m_codec_data.m_compression.opj_end_compress = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                       struct opj_event_mgr * ))(& opj_j2k_end_compress);
#line 561
  l_codec->m_codec_data.m_compression.opj_start_compress = (OPJ_BOOL (*)(void * ,
                                                                         struct opj_stream_private * ,
                                                                         struct opj_image * ,
                                                                         struct opj_event_mgr * ))(& opj_j2k_start_compress);
#line 566
  l_codec->m_codec_data.m_compression.opj_write_tile = (OPJ_BOOL (*)(void * , OPJ_UINT32  ,
                                                                     OPJ_BYTE * ,
                                                                     OPJ_UINT32  ,
                                                                     struct opj_stream_private * ,
                                                                     struct opj_event_mgr * ))(& opj_j2k_write_tile);
#line 573
  l_codec->m_codec_data.m_compression.opj_destroy = (void (*)(void * ))(& opj_j2k_destroy);
#line 575
  l_codec->m_codec_data.m_compression.opj_setup_encoder = (OPJ_BOOL (*)(void * , opj_cparameters_t * ,
                                                                        struct opj_image * ,
                                                                        struct opj_event_mgr * ))(& opj_j2k_setup_encoder);
#line 580
  l_codec->m_codec = (void *)opj_j2k_create_compress();
  }
#line 581
  if (! l_codec->m_codec) {
    {
#line 582
    free(l_codec);
    }
#line 583
    return ((opj_codec_t *)0);
  }
#line 586
  goto switch_break;
  case_2: /* CIL Label */ 
#line 590
  l_codec->m_codec_data.m_compression.opj_encode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                 struct opj_event_mgr * ))(& opj_jp2_encode);
  {
#line 594
  l_codec->m_codec_data.m_compression.opj_end_compress = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                       struct opj_event_mgr * ))(& opj_jp2_end_compress);
#line 598
  l_codec->m_codec_data.m_compression.opj_start_compress = (OPJ_BOOL (*)(void * ,
                                                                         struct opj_stream_private * ,
                                                                         struct opj_image * ,
                                                                         struct opj_event_mgr * ))(& opj_jp2_start_compress);
#line 603
  l_codec->m_codec_data.m_compression.opj_write_tile = (OPJ_BOOL (*)(void * , OPJ_UINT32  ,
                                                                     OPJ_BYTE * ,
                                                                     OPJ_UINT32  ,
                                                                     struct opj_stream_private * ,
                                                                     struct opj_event_mgr * ))(& opj_jp2_write_tile);
#line 610
  l_codec->m_codec_data.m_compression.opj_destroy = (void (*)(void * ))(& opj_jp2_destroy);
#line 612
  l_codec->m_codec_data.m_compression.opj_setup_encoder = (OPJ_BOOL (*)(void * , opj_cparameters_t * ,
                                                                        struct opj_image * ,
                                                                        struct opj_event_mgr * ))(& opj_jp2_setup_encoder);
#line 617
  l_codec->m_codec = (void *)opj_jp2_create(0);
  }
#line 618
  if (! l_codec->m_codec) {
    {
#line 619
    free(l_codec);
    }
#line 620
    return ((opj_codec_t *)0);
  }
#line 623
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
  {
#line 628
  free(l_codec);
  }
#line 629
  return ((opj_codec_t *)0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 632
  opj_set_default_event_handler(& l_codec->m_event_mgr);
  }
#line 633
  return ((opj_codec_t *)l_codec);
}
}
#line 636 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) 
{ 


  {
#line 637
  if (parameters) {
    {
#line 638
    memset(parameters, 0, sizeof(opj_cparameters_t ));
#line 640
    parameters->cp_cinema = (OPJ_CINEMA_MODE )0;
#line 641
    parameters->rsiz = (OPJ_UINT16 )0;
#line 642
    parameters->max_comp_size = 0;
#line 643
    parameters->numresolution = 6;
#line 644
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
#line 645
    parameters->cblockw_init = 64;
#line 646
    parameters->cblockh_init = 64;
#line 647
    parameters->prog_order = (OPJ_PROG_ORDER )0;
#line 648
    parameters->roi_compno = - 1;
#line 649
    parameters->subsampling_dx = 1;
#line 650
    parameters->subsampling_dy = 1;
#line 651
    parameters->tp_on = (char )0;
#line 652
    parameters->decod_format = - 1;
#line 653
    parameters->cod_format = - 1;
#line 654
    parameters->tcp_rates[0] = (float )0;
#line 655
    parameters->tcp_numlayers = 0;
#line 656
    parameters->cp_disto_alloc = 0;
#line 657
    parameters->cp_fixed_alloc = 0;
#line 658
    parameters->cp_fixed_quality = 0;
#line 659
    parameters->jpip_on = 0;
    }
  }
  return;
}
}
#line 695 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_setup_encoder(opj_codec_t *p_codec , opj_cparameters_t *parameters ,
                           opj_image_t *p_image ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 699
  if (p_codec) {
#line 699
    if (parameters) {
#line 699
      if (p_image) {
#line 700
        l_codec = (opj_codec_private_t *)p_codec;
#line 702
        if (! l_codec->is_decompressor) {
          {
#line 703
          (*(l_codec->m_codec_data.m_compression.opj_setup_encoder))(l_codec->m_codec,
                                                                     parameters, p_image,
                                                                     & l_codec->m_event_mgr);
          }
#line 707
          return (1);
        }
      }
    }
  }
#line 711
  return (0);
}
}
#line 714 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_start_compress(opj_codec_t *p_codec , opj_image_t *p_image , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 718
  if (p_codec) {
#line 718
    if (p_stream) {
#line 719
      l_codec = (opj_codec_private_t *)p_codec;
#line 720
      l_stream = (opj_stream_private_t *)p_stream;
#line 722
      if (! l_codec->is_decompressor) {
        {
#line 723
        __cil_tmp6 = (*(l_codec->m_codec_data.m_compression.opj_start_compress))(l_codec->m_codec,
                                                                                 l_stream,
                                                                                 p_image,
                                                                                 & l_codec->m_event_mgr);
        }
#line 723
        return (__cil_tmp6);
      }
    }
  }
#line 730
  return (0);
}
}
#line 733 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_encode(opj_codec_t *p_info , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 735
  if (p_info) {
#line 735
    if (p_stream) {
#line 736
      l_codec = (opj_codec_private_t *)p_info;
#line 737
      l_stream = (opj_stream_private_t *)p_stream;
#line 739
      if (! l_codec->is_decompressor) {
        {
#line 740
        __cil_tmp5 = (*(l_codec->m_codec_data.m_compression.opj_encode))(l_codec->m_codec,
                                                                         l_stream,
                                                                         & l_codec->m_event_mgr);
        }
#line 740
        return (__cil_tmp5);
      }
    }
  }
#line 746
  return (0);
}
}
#line 750 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_end_compress(opj_codec_t *p_codec , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 753
  if (p_codec) {
#line 753
    if (p_stream) {
#line 754
      l_codec = (opj_codec_private_t *)p_codec;
#line 755
      l_stream = (opj_stream_private_t *)p_stream;
#line 757
      if (! l_codec->is_decompressor) {
        {
#line 758
        __cil_tmp5 = (*(l_codec->m_codec_data.m_compression.opj_end_compress))(l_codec->m_codec,
                                                                               l_stream,
                                                                               & l_codec->m_event_mgr);
        }
#line 758
        return (__cil_tmp5);
      }
    }
  }
#line 763
  return (0);
}
}
#line 767 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_end_decompress(opj_codec_t *p_codec , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 770
  if (p_codec) {
#line 770
    if (p_stream) {
#line 771
      l_codec = (opj_codec_private_t *)p_codec;
#line 772
      l_stream = (opj_stream_private_t *)p_stream;
#line 774
      if (! l_codec->is_decompressor) {
#line 775
        return (0);
      }
      {
#line 778
      __cil_tmp5 = (*(l_codec->m_codec_data.m_decompression.opj_end_decompress))(l_codec->m_codec,
                                                                                 l_stream,
                                                                                 & l_codec->m_event_mgr);
      }
#line 778
      return (__cil_tmp5);
    }
  }
#line 783
  return (0);
}
}
#line 786 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_MCT(opj_cparameters_t *parameters , OPJ_FLOAT32 *pEncodingMatrix ,
                     OPJ_INT32 *p_dc_shift , OPJ_UINT32 pNbComp ) 
{ 
  OPJ_UINT32 l_matrix_size ;
  OPJ_UINT32 l_dc_shift_size ;
  OPJ_UINT32 l_mct_total_size ;
  void *__cil_tmp8 ;

  {
#line 790
  l_matrix_size = (pNbComp * pNbComp) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 791
  l_dc_shift_size = pNbComp * (OPJ_UINT32 )sizeof(OPJ_INT32 );
#line 792
  l_mct_total_size = l_matrix_size + l_dc_shift_size;
#line 795
  if ((int )parameters->rsiz & 32768) {
#line 796
    parameters->rsiz |= 256;
  } else {
#line 798
    parameters->rsiz = (OPJ_UINT16 )33024;
  }
  {
#line 800
  parameters->irreversible = 1;
#line 803
  parameters->tcp_mct = (char )2;
#line 804
  parameters->mct_data = malloc((unsigned long )l_mct_total_size);
  }
#line 805
  if (! parameters->mct_data) {
#line 806
    return (0);
  }
  {
#line 809
  memcpy(parameters->mct_data, pEncodingMatrix, (unsigned long )l_matrix_size);
#line 810
  memcpy((OPJ_BYTE *)parameters->mct_data + l_matrix_size, p_dc_shift, (unsigned long )l_dc_shift_size);
  }
#line 812
  return (1);
}
}
#line 815 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_write_tile(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                        OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 821
  if (p_codec) {
#line 821
    if (p_stream) {
#line 821
      if (p_data) {
#line 822
        l_codec = (opj_codec_private_t *)p_codec;
#line 823
        l_stream = (opj_stream_private_t *)p_stream;
#line 825
        if (l_codec->is_decompressor) {
#line 826
          return (0);
        }
        {
#line 829
        __cil_tmp8 = (*(l_codec->m_codec_data.m_compression.opj_write_tile))(l_codec->m_codec,
                                                                             p_tile_index,
                                                                             p_data,
                                                                             p_data_size,
                                                                             l_stream,
                                                                             & l_codec->m_event_mgr);
        }
#line 829
        return (__cil_tmp8);
      }
    }
  }
#line 837
  return (0);
}
}
#line 842 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
void opj_destroy_codec(opj_codec_t *p_codec ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 844
  if (p_codec) {
#line 845
    l_codec = (opj_codec_private_t *)p_codec;
#line 847
    if (l_codec->is_decompressor) {
      {
#line 848
      (*(l_codec->m_codec_data.m_decompression.opj_destroy))(l_codec->m_codec);
      }
    } else {
      {
#line 851
      (*(l_codec->m_codec_data.m_compression.opj_destroy))(l_codec->m_codec);
      }
    }
    {
#line 854
    l_codec->m_codec = (void *)0;
#line 855
    free(l_codec);
    }
  }
  return;
}
}
#line 861 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
void opj_dump_codec(opj_codec_t *p_codec , OPJ_INT32 info_flag , FILE *output_stream ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 865
  if (p_codec) {
    {
#line 866
    l_codec = (opj_codec_private_t *)p_codec;
#line 868
    (*(l_codec->opj_dump_codec))(l_codec->m_codec, info_flag, output_stream);
    }
#line 869
    return;
  }
  {
#line 872
  fprintf(stderr, "[ERROR] Input parameter of the dump_codec function are incorrect.\n");
  }
#line 873
  return;
}
}
#line 876 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
opj_codestream_info_v2_t *opj_get_cstr_info(opj_codec_t *p_codec ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_codestream_info_v2_t *__cil_tmp3 ;

  {
#line 878
  if (p_codec) {
    {
#line 879
    l_codec = (opj_codec_private_t *)p_codec;
#line 881
    __cil_tmp3 = (*(l_codec->opj_get_codec_info))(l_codec->m_codec);
    }
#line 881
    return (__cil_tmp3);
  }
#line 884
  return ((opj_codestream_info_v2_t *)((void *)0));
}
}
#line 887 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
void opj_destroy_cstr_info(opj_codestream_info_v2_t **cstr_info ) 
{ 


  {
#line 888
  if (cstr_info) {
#line 890
    if ((*cstr_info)->m_default_tile_info.tccp_info) {
      {
#line 891
      free((*cstr_info)->m_default_tile_info.tccp_info);
      }
    }
#line 894
    if ((*cstr_info)->tile_info) {

    }
    {
#line 898
    free(*cstr_info);
#line 899
    *cstr_info = (opj_codestream_info_v2_t *)((void *)0);
    }
  }
  return;
}
}
#line 903 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
opj_codestream_index_t *opj_get_cstr_index(opj_codec_t *p_codec ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_codestream_index_t *__cil_tmp3 ;

  {
#line 905
  if (p_codec) {
    {
#line 906
    l_codec = (opj_codec_private_t *)p_codec;
#line 908
    __cil_tmp3 = (*(l_codec->opj_get_codec_index))(l_codec->m_codec);
    }
#line 908
    return (__cil_tmp3);
  }
#line 911
  return ((opj_codestream_index_t *)((void *)0));
}
}
#line 914 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
void opj_destroy_cstr_index(opj_codestream_index_t **p_cstr_index ) 
{ 


  {
#line 916
  if (*p_cstr_index) {
    {
#line 917
    j2k_destroy_cstr_index(*p_cstr_index);
#line 918
    *p_cstr_index = (opj_codestream_index_t *)((void *)0);
    }
  }
  return;
}
}
#line 922 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
opj_stream_t *opj_stream_create_default_file_stream(char const   *fname , OPJ_BOOL p_is_read_stream ) 
{ 
  opj_stream_t *__cil_tmp3 ;

  {
  {
#line 924
  __cil_tmp3 = opj_stream_create_file_stream(fname, (OPJ_SIZE_T )1048576, p_is_read_stream);
  }
#line 924
  return (__cil_tmp3);
}
}
#line 927 "/root/patron/new_21/src/lib/openjp2/openjpeg.c"
opj_stream_t *opj_stream_create_file_stream(char const   *fname , OPJ_SIZE_T p_size ,
                                            OPJ_BOOL p_is_read_stream ) 
{ 
  opj_stream_t *l_stream ;
  FILE *p_file ;
  char const   *mode ;
  FILE *__cil_tmp7 ;
  opj_stream_t *__cil_tmp8 ;
  OPJ_UINT64 __cil_tmp9 ;

  {
#line 932
  l_stream = (opj_stream_t *)0;
#line 936
  if (! fname) {
#line 937
    return ((opj_stream_t *)((void *)0));
  }
#line 940
  if (p_is_read_stream) {
#line 940
    strcpy((char *)mode, "rb");;
  } else {
#line 940
    strcpy((char *)mode, "wb");;
  }
  {
#line 942
  p_file = fopen(fname, mode);
  }
#line 944
  if (! p_file) {
#line 945
    return ((opj_stream_t *)((void *)0));
  }
  {
#line 948
  l_stream = opj_stream_create(p_size, p_is_read_stream);
  }
#line 949
  if (! l_stream) {
    {
#line 950
    fclose(p_file);
    }
#line 951
    return ((opj_stream_t *)((void *)0));
  }
  {
#line 954
  opj_stream_set_user_data(l_stream, p_file, (opj_stream_free_user_data_fn )(& fclose));
#line 955
  __cil_tmp9 = opj_get_data_length_from_file(p_file);
#line 955
  opj_stream_set_user_data_length(l_stream, __cil_tmp9);
#line 956
  opj_stream_set_read_function(l_stream, (opj_stream_read_fn )(& opj_read_from_file));
#line 957
  opj_stream_set_write_function(l_stream, (opj_stream_write_fn )(& opj_write_from_file));
#line 958
  opj_stream_set_skip_function(l_stream, (opj_stream_skip_fn )(& opj_skip_from_file));
#line 959
  opj_stream_set_seek_function(l_stream, (opj_stream_seek_fn )(& opj_seek_from_file));
  }
#line 961
  return (l_stream);
}
}
#line 52 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_byteout(opj_mqc_t *mqc ) ;
#line 57
void opj_mqc_renorme(opj_mqc_t *mqc ) ;
#line 62
void opj_mqc_codemps(opj_mqc_t *mqc ) ;
#line 67
void opj_mqc_codelps(opj_mqc_t *mqc ) ;
#line 72
void opj_mqc_setbits(opj_mqc_t *mqc ) ;
#line 78
__inline static OPJ_INT32 opj_mqc_mpsexchange(opj_mqc_t *mqc ) ;
#line 84
__inline static OPJ_INT32 opj_mqc_lpsexchange(opj_mqc_t *mqc ) ;
#line 89
static void opj_mqc_bytein(opj_mqc_t *mqc ) ;
#line 94
__inline static void opj_mqc_renormd(opj_mqc_t *mqc ) ;
#line 102 "/root/patron/new_21/src/lib/openjp2/mqc.c"
static opj_mqc_state_t mqc_states[94]  = 
#line 102
  {      {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[2], & mqc_states[3]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[3], & mqc_states[2]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )0, & mqc_states[4], & mqc_states[12]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )1, & mqc_states[5], & mqc_states[13]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )0, & mqc_states[6], & mqc_states[18]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )1, & mqc_states[7], & mqc_states[19]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )0, & mqc_states[8], & mqc_states[24]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )1, & mqc_states[9], & mqc_states[25]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )0, & mqc_states[10], & mqc_states[58]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )1, & mqc_states[11], & mqc_states[59]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )0, & mqc_states[76], & mqc_states[66]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )1, & mqc_states[77], & mqc_states[67]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[14], & mqc_states[13]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[15], & mqc_states[12]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )0, & mqc_states[16], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )1, & mqc_states[17], & mqc_states[29]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )0, & mqc_states[18], & mqc_states[28]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )1, & mqc_states[19], & mqc_states[29]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )0, & mqc_states[20], & mqc_states[28]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )1, & mqc_states[21], & mqc_states[29]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )0, & mqc_states[22], & mqc_states[34]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )1, & mqc_states[23], & mqc_states[35]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )0, & mqc_states[24], & mqc_states[36]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )1, & mqc_states[25], & mqc_states[37]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )0, & mqc_states[26], & mqc_states[40]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )1, & mqc_states[27], & mqc_states[41]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )0, & mqc_states[58], & mqc_states[42]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )1, & mqc_states[59], & mqc_states[43]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[30], & mqc_states[29]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[31], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )0, & mqc_states[32], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )1, & mqc_states[33], & mqc_states[29]}, 
        {(OPJ_UINT32 )20737, (OPJ_UINT32 )0, & mqc_states[34], & mqc_states[30]}, 
        {(OPJ_UINT32 )20737, (OPJ_UINT32 )1, & mqc_states[35], & mqc_states[31]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )0, & mqc_states[36], & mqc_states[32]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )1, & mqc_states[37], & mqc_states[33]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )0, & mqc_states[38], & mqc_states[34]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )1, & mqc_states[39], & mqc_states[35]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )0, & mqc_states[40], & mqc_states[36]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )1, & mqc_states[41], & mqc_states[37]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )0, & mqc_states[42], & mqc_states[38]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )1, & mqc_states[43], & mqc_states[39]}, 
        {(OPJ_UINT32 )10241, (OPJ_UINT32 )0, & mqc_states[44], & mqc_states[38]}, 
        {(OPJ_UINT32 )10241, (OPJ_UINT32 )1, & mqc_states[45], & mqc_states[39]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )0, & mqc_states[46], & mqc_states[40]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )1, & mqc_states[47], & mqc_states[41]}, 
        {(OPJ_UINT32 )8705, (OPJ_UINT32 )0, & mqc_states[48], & mqc_states[42]}, 
        {(OPJ_UINT32 )8705, (OPJ_UINT32 )1, & mqc_states[49], & mqc_states[43]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )0, & mqc_states[50], & mqc_states[44]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )1, & mqc_states[51], & mqc_states[45]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )0, & mqc_states[52], & mqc_states[46]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )1, & mqc_states[53], & mqc_states[47]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )0, & mqc_states[54], & mqc_states[48]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )1, & mqc_states[55], & mqc_states[49]}, 
        {(OPJ_UINT32 )5121, (OPJ_UINT32 )0, & mqc_states[56], & mqc_states[50]}, 
        {(OPJ_UINT32 )5121, (OPJ_UINT32 )1, & mqc_states[57], & mqc_states[51]}, 
        {(OPJ_UINT32 )4609, (OPJ_UINT32 )0, & mqc_states[58], & mqc_states[52]}, 
        {(OPJ_UINT32 )4609, (OPJ_UINT32 )1, & mqc_states[59], & mqc_states[53]}, 
        {(OPJ_UINT32 )4353, (OPJ_UINT32 )0, & mqc_states[60], & mqc_states[54]}, 
        {(OPJ_UINT32 )4353, (OPJ_UINT32 )1, & mqc_states[61], & mqc_states[55]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )0, & mqc_states[62], & mqc_states[56]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )1, & mqc_states[63], & mqc_states[57]}, 
        {(OPJ_UINT32 )2497, (OPJ_UINT32 )0, & mqc_states[64], & mqc_states[58]}, 
        {(OPJ_UINT32 )2497, (OPJ_UINT32 )1, & mqc_states[65], & mqc_states[59]}, 
        {(OPJ_UINT32 )2209, (OPJ_UINT32 )0, & mqc_states[66], & mqc_states[60]}, 
        {(OPJ_UINT32 )2209, (OPJ_UINT32 )1, & mqc_states[67], & mqc_states[61]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )0, & mqc_states[68], & mqc_states[62]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )1, & mqc_states[69], & mqc_states[63]}, 
        {(OPJ_UINT32 )1089, (OPJ_UINT32 )0, & mqc_states[70], & mqc_states[64]}, 
        {(OPJ_UINT32 )1089, (OPJ_UINT32 )1, & mqc_states[71], & mqc_states[65]}, 
        {(OPJ_UINT32 )673, (OPJ_UINT32 )0, & mqc_states[72], & mqc_states[66]}, 
        {(OPJ_UINT32 )673, (OPJ_UINT32 )1, & mqc_states[73], & mqc_states[67]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )0, & mqc_states[74], & mqc_states[68]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )1, & mqc_states[75], & mqc_states[69]}, 
        {(OPJ_UINT32 )321, (OPJ_UINT32 )0, & mqc_states[76], & mqc_states[70]}, 
        {(OPJ_UINT32 )321, (OPJ_UINT32 )1, & mqc_states[77], & mqc_states[71]}, 
        {(OPJ_UINT32 )273, (OPJ_UINT32 )0, & mqc_states[78], & mqc_states[72]}, 
        {(OPJ_UINT32 )273, (OPJ_UINT32 )1, & mqc_states[79], & mqc_states[73]}, 
        {(OPJ_UINT32 )133, (OPJ_UINT32 )0, & mqc_states[80], & mqc_states[74]}, 
        {(OPJ_UINT32 )133, (OPJ_UINT32 )1, & mqc_states[81], & mqc_states[75]}, 
        {(OPJ_UINT32 )73, (OPJ_UINT32 )0, & mqc_states[82], & mqc_states[76]}, 
        {(OPJ_UINT32 )73, (OPJ_UINT32 )1, & mqc_states[83], & mqc_states[77]}, 
        {(OPJ_UINT32 )37, (OPJ_UINT32 )0, & mqc_states[84], & mqc_states[78]}, 
        {(OPJ_UINT32 )37, (OPJ_UINT32 )1, & mqc_states[85], & mqc_states[79]}, 
        {(OPJ_UINT32 )21, (OPJ_UINT32 )0, & mqc_states[86], & mqc_states[80]}, 
        {(OPJ_UINT32 )21, (OPJ_UINT32 )1, & mqc_states[87], & mqc_states[81]}, 
        {(OPJ_UINT32 )9, (OPJ_UINT32 )0, & mqc_states[88], & mqc_states[82]}, 
        {(OPJ_UINT32 )9, (OPJ_UINT32 )1, & mqc_states[89], & mqc_states[83]}, 
        {(OPJ_UINT32 )5, (OPJ_UINT32 )0, & mqc_states[90], & mqc_states[84]}, 
        {(OPJ_UINT32 )5, (OPJ_UINT32 )1, & mqc_states[91], & mqc_states[85]}, 
        {(OPJ_UINT32 )1, (OPJ_UINT32 )0, & mqc_states[90], & mqc_states[86]}, 
        {(OPJ_UINT32 )1, (OPJ_UINT32 )1, & mqc_states[91], & mqc_states[87]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[92], & mqc_states[92]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[93], & mqc_states[93]}};
#line 205 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_byteout(opj_mqc_t *mqc ) 
{ 
  OPJ_BYTE *__cil_tmp2 ;
  OPJ_BYTE *__cil_tmp3 ;
  OPJ_BYTE __cil_tmp4 ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 206
  if ((int )*(mqc->bp) == 255) {
#line 207
    (mqc->bp) ++;
#line 208
    *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 20);
#line 209
    mqc->c &= (unsigned int )1048575;
#line 210
    mqc->ct = (OPJ_UINT32 )7;
  } else
#line 212
  if ((mqc->c & 134217728U) == 0U) {
#line 213
    (mqc->bp) ++;
#line 214
    *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 19);
#line 215
    mqc->c &= (unsigned int )524287;
#line 216
    mqc->ct = (OPJ_UINT32 )8;
  } else {
#line 218
    (*(mqc->bp)) ++;
#line 219
    if ((int )*(mqc->bp) == 255) {
#line 220
      mqc->c &= (unsigned int )134217727;
#line 221
      (mqc->bp) ++;
#line 222
      *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 20);
#line 223
      mqc->c &= (unsigned int )1048575;
#line 224
      mqc->ct = (OPJ_UINT32 )7;
    } else {
#line 226
      (mqc->bp) ++;
#line 227
      *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 19);
#line 228
      mqc->c &= (unsigned int )524287;
#line 229
      mqc->ct = (OPJ_UINT32 )8;
    }
  }
  return;
}
}
#line 235 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_renorme(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    mqc->a <<= 1;
#line 238
    mqc->c <<= 1;
#line 239
    __cil_tmp2 = mqc->ct;
#line 239
    (mqc->ct) --;
#line 240
    if (mqc->ct == 0U) {
      {
#line 241
      opj_mqc_byteout(mqc);
      }
    }
#line 236
    if (! ((mqc->a & 32768U) == 0U)) {
#line 236
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 246 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_codemps(opj_mqc_t *mqc ) 
{ 


  {
#line 247
  mqc->a -= (*(mqc->curctx))->qeval;
#line 248
  if ((mqc->a & 32768U) == 0U) {
#line 249
    if (mqc->a < (*(mqc->curctx))->qeval) {
#line 250
      mqc->a = (*(mqc->curctx))->qeval;
    } else {
#line 252
      mqc->c += (*(mqc->curctx))->qeval;
    }
    {
#line 254
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
#line 255
    opj_mqc_renorme(mqc);
    }
  } else {
#line 257
    mqc->c += (*(mqc->curctx))->qeval;
  }
  return;
}
}
#line 261 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_codelps(opj_mqc_t *mqc ) 
{ 


  {
#line 262
  mqc->a -= (*(mqc->curctx))->qeval;
#line 263
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 264
    mqc->c += (*(mqc->curctx))->qeval;
  } else {
#line 266
    mqc->a = (*(mqc->curctx))->qeval;
  }
  {
#line 268
  *(mqc->curctx) = (*(mqc->curctx))->nlps;
#line 269
  opj_mqc_renorme(mqc);
  }
  return;
}
}
#line 272 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_setbits(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 tempc ;

  {
#line 273
  tempc = mqc->c + mqc->a;
#line 274
  mqc->c |= (unsigned int )65535;
#line 275
  if (mqc->c >= tempc) {
#line 276
    mqc->c -= (unsigned int )32768;
  }
  return;
}
}
#line 280 "/root/patron/new_21/src/lib/openjp2/mqc.c"
__inline static OPJ_INT32 opj_mqc_mpsexchange(opj_mqc_t *mqc ) 
{ 
  OPJ_INT32 d ;

  {
#line 282
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 283
    d = (OPJ_INT32 )(1U - (*(mqc->curctx))->mps);
#line 284
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  } else {
#line 286
    d = (OPJ_INT32 )(*(mqc->curctx))->mps;
#line 287
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  }
#line 290
  return (d);
}
}
#line 293 "/root/patron/new_21/src/lib/openjp2/mqc.c"
__inline static OPJ_INT32 opj_mqc_lpsexchange(opj_mqc_t *mqc ) 
{ 
  OPJ_INT32 d ;

  {
#line 295
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 296
    mqc->a = (*(mqc->curctx))->qeval;
#line 297
    d = (OPJ_INT32 )(*(mqc->curctx))->mps;
#line 298
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  } else {
#line 300
    mqc->a = (*(mqc->curctx))->qeval;
#line 301
    d = (OPJ_INT32 )(1U - (*(mqc->curctx))->mps);
#line 302
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  }
#line 305
  return (d);
}
}
#line 316 "/root/patron/new_21/src/lib/openjp2/mqc.c"
static void opj_mqc_bytein(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 c ;
  OPJ_BYTE *__cil_tmp3 ;
  OPJ_BYTE *__cil_tmp4 ;

  {
#line 317
  if (mqc->bp != mqc->end) {
#line 319
    if (mqc->bp + 1 != mqc->end) {
#line 320
      c = (OPJ_UINT32 )*(mqc->bp + 1);
    } else {
#line 322
      c = (OPJ_UINT32 )255;
    }
#line 324
    if ((int )*(mqc->bp) == 255) {
#line 325
      if (c > 143U) {
#line 326
        mqc->c += (unsigned int )65280;
#line 327
        mqc->ct = (OPJ_UINT32 )8;
      } else {
#line 329
        (mqc->bp) ++;
#line 330
        mqc->c += c << 9;
#line 331
        mqc->ct = (OPJ_UINT32 )7;
      }
    } else {
#line 334
      (mqc->bp) ++;
#line 335
      mqc->c += c << 8;
#line 336
      mqc->ct = (OPJ_UINT32 )8;
    }
  } else {
#line 339
    mqc->c += (unsigned int )65280;
#line 340
    mqc->ct = (OPJ_UINT32 )8;
  }
  return;
}
}
#line 345 "/root/patron/new_21/src/lib/openjp2/mqc.c"
__inline static void opj_mqc_renormd(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (mqc->ct == 0U) {
      {
#line 348
      opj_mqc_bytein(mqc);
      }
    }
#line 350
    mqc->a <<= 1;
#line 351
    mqc->c <<= 1;
#line 352
    __cil_tmp2 = mqc->ct;
#line 352
    (mqc->ct) --;
#line 346
    if (! (mqc->a < 32768U)) {
#line 346
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 362 "/root/patron/new_21/src/lib/openjp2/mqc.c"
opj_mqc_t *opj_mqc_create(void) 
{ 
  opj_mqc_t *mqc ;
  void *__cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = malloc(sizeof(opj_mqc_t ));
#line 363
  mqc = (opj_mqc_t *)__cil_tmp2;
  }
#line 369
  return (mqc);
}
}
#line 372 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_destroy(opj_mqc_t *mqc ) 
{ 


  {
#line 373
  if (mqc) {
    {
#line 379
    free(mqc);
    }
  }
  return;
}
}
#line 383 "/root/patron/new_21/src/lib/openjp2/mqc.c"
OPJ_UINT32 opj_mqc_numbytes(opj_mqc_t *mqc ) 
{ 
  ptrdiff_t diff ;

  {
#line 384
  diff = mqc->bp - mqc->start;
#line 388
  return ((OPJ_UINT32 )diff);
}
}
#line 391 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_init_enc(opj_mqc_t *mqc , OPJ_BYTE *bp ) 
{ 


  {
#line 393
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )0];
#line 394
  mqc->a = (OPJ_UINT32 )32768;
#line 395
  mqc->c = (OPJ_UINT32 )0;
#line 396
  mqc->bp = bp - 1;
#line 397
  mqc->ct = (OPJ_UINT32 )12;
#line 398
  if ((int )*(mqc->bp) == 255) {
#line 399
    mqc->ct = (OPJ_UINT32 )13;
  }
#line 401
  mqc->start = bp;
  return;
}
}
#line 404 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_encode(opj_mqc_t *mqc , OPJ_UINT32 d ) 
{ 


  {
#line 405
  if ((*(mqc->curctx))->mps == d) {
    {
#line 406
    opj_mqc_codemps(mqc);
    }
  } else {
    {
#line 408
    opj_mqc_codelps(mqc);
    }
  }
  return;
}
}
#line 412 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_flush(opj_mqc_t *mqc ) 
{ 
  OPJ_BYTE *__cil_tmp2 ;

  {
  {
#line 413
  opj_mqc_setbits(mqc);
#line 414
  mqc->c <<= mqc->ct;
#line 415
  opj_mqc_byteout(mqc);
#line 416
  mqc->c <<= mqc->ct;
#line 417
  opj_mqc_byteout(mqc);
  }
#line 419
  if ((int )*(mqc->bp) != 255) {
#line 420
    (mqc->bp) ++;
  }
  return;
}
}
#line 424 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_bypass_init_enc(opj_mqc_t *mqc ) 
{ 


  {
#line 425
  mqc->c = (OPJ_UINT32 )0;
#line 426
  mqc->ct = (OPJ_UINT32 )8;
  return;
}
}
#line 432 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_bypass_enc(opj_mqc_t *mqc , OPJ_UINT32 d ) 
{ 
  OPJ_UINT32 __cil_tmp3 ;
  OPJ_BYTE *__cil_tmp4 ;

  {
#line 433
  __cil_tmp3 = mqc->ct;
#line 433
  (mqc->ct) --;
#line 434
  mqc->c += d << mqc->ct;
#line 435
  if (mqc->ct == 0U) {
#line 436
    (mqc->bp) ++;
#line 437
    *(mqc->bp) = (OPJ_BYTE )mqc->c;
#line 438
    mqc->ct = (OPJ_UINT32 )8;
#line 439
    if ((int )*(mqc->bp) == 255) {
#line 440
      mqc->ct = (OPJ_UINT32 )7;
    }
#line 442
    mqc->c = (OPJ_UINT32 )0;
  }
  return;
}
}
#line 446 "/root/patron/new_21/src/lib/openjp2/mqc.c"
OPJ_UINT32 opj_mqc_bypass_flush_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_BYTE bit_padding ;
  OPJ_UINT32 __cil_tmp3 ;
  OPJ_BYTE *__cil_tmp4 ;

  {
#line 449
  bit_padding = (OPJ_BYTE )0;
#line 451
  if (mqc->ct != 0U) {
    {
#line 452
    while (1) {
      while_continue: /* CIL Label */ ;
#line 452
      if (! (mqc->ct > 0U)) {
#line 452
        goto while_break;
      }
#line 453
      __cil_tmp3 = mqc->ct;
#line 453
      (mqc->ct) --;
#line 454
      mqc->c += (OPJ_UINT32 )((int )bit_padding << mqc->ct);
#line 455
      bit_padding = (OPJ_BYTE )(((int )bit_padding + 1) & 1);
    }
    while_break: /* CIL Label */ ;
    }
#line 457
    (mqc->bp) ++;
#line 458
    *(mqc->bp) = (OPJ_BYTE )mqc->c;
#line 459
    mqc->ct = (OPJ_UINT32 )8;
#line 460
    mqc->c = (OPJ_UINT32 )0;
  }
#line 463
  return ((OPJ_UINT32 )1);
}
}
#line 466 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_reset_enc(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 467
  opj_mqc_resetstates(mqc);
#line 468
  opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 469
  opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 470
  opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
  }
  return;
}
}
#line 473 "/root/patron/new_21/src/lib/openjp2/mqc.c"
OPJ_UINT32 opj_mqc_restart_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 correction ;
  OPJ_INT32 n ;

  {
#line 474
  correction = (OPJ_UINT32 )1;
#line 477
  n = (OPJ_INT32 )(12U - mqc->ct);
#line 478
  mqc->c <<= mqc->ct;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! (n > 0)) {
#line 479
      goto while_break;
    }
    {
#line 480
    opj_mqc_byteout(mqc);
#line 481
    n -= (OPJ_INT32 )mqc->ct;
#line 482
    mqc->c <<= mqc->ct;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 484
  opj_mqc_byteout(mqc);
  }
#line 486
  return (correction);
}
}
#line 489 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_restart_init_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_BYTE *__cil_tmp2 ;

  {
#line 491
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )0];
#line 492
  mqc->a = (OPJ_UINT32 )32768;
#line 493
  mqc->c = (OPJ_UINT32 )0;
#line 494
  mqc->ct = (OPJ_UINT32 )12;
#line 495
  __cil_tmp2 = mqc->bp;
#line 495
  (mqc->bp) --;
#line 496
  if ((int )*(mqc->bp) == 255) {
#line 497
    mqc->ct = (OPJ_UINT32 )13;
  }
  return;
}
}
#line 501 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_erterm_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_INT32 k ;

  {
#line 502
  k = (OPJ_INT32 )((11U - mqc->ct) + 1U);
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (! (k > 0)) {
#line 504
      goto while_break;
    }
    {
#line 505
    mqc->c <<= mqc->ct;
#line 506
    mqc->ct = (OPJ_UINT32 )0;
#line 507
    opj_mqc_byteout(mqc);
#line 508
    k -= (OPJ_INT32 )mqc->ct;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 511
  if ((int )*(mqc->bp) != 255) {
    {
#line 512
    opj_mqc_byteout(mqc);
    }
  }
  return;
}
}
#line 516 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_segmark_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 518
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 520
  i = (OPJ_UINT32 )1;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    if (! (i < 5U)) {
#line 520
      goto while_break;
    }
    {
#line 521
    opj_mqc_encode(mqc, i % 2U);
    }
#line 520
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 525 "/root/patron/new_21/src/lib/openjp2/mqc.c"
OPJ_BOOL opj_mqc_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 526
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )0];
#line 527
  mqc->start = bp;
#line 528
  mqc->end = bp + len;
#line 529
  mqc->bp = bp;
#line 530
  if (len == 0U) {
#line 530
    mqc->c = (OPJ_UINT32 )(255 << 16);
  } else {
#line 531
    mqc->c = (OPJ_UINT32 )((int )*(mqc->bp) << 16);
  }
  {
#line 577
  opj_mqc_bytein(mqc);
#line 578
  mqc->c <<= 7;
#line 579
  mqc->ct -= (unsigned int )7;
#line 580
  mqc->a = (OPJ_UINT32 )32768;
  }
#line 581
  return (1);
}
}
#line 584 "/root/patron/new_21/src/lib/openjp2/mqc.c"
OPJ_INT32 opj_mqc_decode(opj_mqc_t *mqc ) 
{ 
  OPJ_INT32 d ;
  OPJ_INT32 __cil_tmp3 ;
  OPJ_INT32 __cil_tmp4 ;

  {
#line 586
  mqc->a -= (*(mqc->curctx))->qeval;
#line 587
  if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
    {
#line 588
    d = opj_mqc_lpsexchange(mqc);
#line 589
    opj_mqc_renormd(mqc);
    }
  } else {
#line 591
    mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 592
    if ((mqc->a & 32768U) == 0U) {
      {
#line 593
      d = opj_mqc_mpsexchange(mqc);
#line 594
      opj_mqc_renormd(mqc);
      }
    } else {
#line 596
      d = (OPJ_INT32 )(*(mqc->curctx))->mps;
    }
  }
#line 600
  return (d);
}
}
#line 603 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_resetstates(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 605
  i = (OPJ_UINT32 )0;
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (! (i < 19U)) {
#line 605
      goto while_break;
    }
#line 606
    mqc->ctxs[i] = (opj_mqc_state_t *)mqc_states;
#line 605
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 610 "/root/patron/new_21/src/lib/openjp2/mqc.c"
void opj_mqc_setstate(opj_mqc_t *mqc , OPJ_UINT32 ctxno , OPJ_UINT32 msb , OPJ_INT32 prob ) 
{ 


  {
#line 611
  mqc->ctxs[ctxno] = & mqc_states[msb + (OPJ_UINT32 )(prob << 1)];
  return;
}
}
#line 62 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_ihdr(opj_jp2_t *jp2 , OPJ_BYTE *p_image_header_data , OPJ_UINT32 p_image_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 75
OPJ_BYTE *opj_jp2_write_ihdr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 86
OPJ_BYTE *opj_jp2_write_bpcc(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 99
OPJ_BOOL opj_jp2_read_bpcc(opj_jp2_t *jp2 , OPJ_BYTE *p_bpc_header_data , OPJ_UINT32 p_bpc_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 104
OPJ_BOOL opj_jp2_read_cdef(opj_jp2_t *jp2 , OPJ_BYTE *p_cdef_header_data , OPJ_UINT32 p_cdef_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 109
void opj_jp2_apply_cdef(opj_image_t *image , opj_jp2_color_t *color ) ;
#line 119
OPJ_BYTE *opj_jp2_write_colr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 131
OPJ_BOOL opj_jp2_write_ftyp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 145
static OPJ_BOOL opj_jp2_read_ftyp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) ;
#line 150
OPJ_BOOL opj_jp2_skip_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 164
static OPJ_BOOL opj_jp2_read_jp2h(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) ;
#line 178
OPJ_BOOL opj_jp2_write_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 224
static OPJ_BOOL opj_jp2_read_jp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                opj_event_mgr_t *p_manager ) ;
#line 238
OPJ_BOOL opj_jp2_write_jp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 247
void opj_jp2_apply_pclr(opj_image_t *image , opj_jp2_color_t *color ) ;
#line 249
void opj_jp2_free_pclr(opj_jp2_color_t *color ) ;
#line 261
OPJ_BOOL opj_jp2_read_pclr(opj_jp2_t *jp2 , OPJ_BYTE *p_pclr_header_data , OPJ_UINT32 p_pclr_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 277
OPJ_BOOL opj_jp2_read_cmap(opj_jp2_t *jp2 , OPJ_BYTE *p_cmap_header_data , OPJ_UINT32 p_cmap_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 292
OPJ_BOOL opj_jp2_read_colr(opj_jp2_t *jp2 , OPJ_BYTE *p_colr_header_data , OPJ_UINT32 p_colr_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 305
void opj_jp2_setup_end_header_writing(opj_jp2_t *jp2 ) ;
#line 311
void opj_jp2_setup_end_header_reading(opj_jp2_t *jp2 ) ;
#line 322
OPJ_BOOL opj_jp2_read_header_procedure(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                       opj_event_mgr_t *p_manager ) ;
#line 336
static OPJ_BOOL opj_jp2_exec(opj_jp2_t *jp2 , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 351
OPJ_BOOL opj_jp2_read_boxhdr(opj_jp2_box_t *box , OPJ_UINT32 *p_number_bytes_read ,
                             opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 360
void opj_jp2_setup_encoding_validation(opj_jp2_t *jp2 ) ;
#line 365
void opj_jp2_setup_header_writing(opj_jp2_t *jp2 ) ;
#line 367
OPJ_BOOL opj_jp2_default_validation(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 378
static opj_jp2_header_handler_t *opj_jp2_img_find_handler(OPJ_UINT32 p_id ) ;
#line 387
opj_jp2_header_handler_t *opj_jp2_find_handler(OPJ_UINT32 p_id ) ;
#line 389 "/root/patron/new_21/src/lib/openjp2/jp2.c"
opj_jp2_header_handler_t jp2_header[3]  = {      {(OPJ_UINT32 )1783636000, & opj_jp2_read_jp}, 
        {(OPJ_UINT32 )1718909296, & opj_jp2_read_ftyp}, 
        {(OPJ_UINT32 )1785737832, & opj_jp2_read_jp2h}};
#line 396 "/root/patron/new_21/src/lib/openjp2/jp2.c"
opj_jp2_header_handler_t jp2_img_header[6]  = {      {(OPJ_UINT32 )1768449138, & opj_jp2_read_ihdr}, 
        {(OPJ_UINT32 )1668246642, & opj_jp2_read_colr}, 
        {(OPJ_UINT32 )1651532643, & opj_jp2_read_bpcc}, 
        {(OPJ_UINT32 )1885564018, & opj_jp2_read_pclr}, 
        {(OPJ_UINT32 )1668112752, & opj_jp2_read_cmap}, 
        {(OPJ_UINT32 )1667523942, & opj_jp2_read_cdef}};
#line 418
OPJ_BOOL opj_jp2_read_boxhdr_char(opj_jp2_box_t *box , OPJ_BYTE *p_data , OPJ_UINT32 *p_number_bytes_read ,
                                  OPJ_UINT32 p_box_max_size , opj_event_mgr_t *p_manager ) ;
#line 428
void opj_jp2_setup_decoding_validation(opj_jp2_t *jp2 ) ;
#line 434
void opj_jp2_setup_header_reading(opj_jp2_t *jp2 ) ;
#line 437 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_boxhdr(opj_jp2_box_t *box , OPJ_UINT32 *p_number_bytes_read ,
                             opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_data_header[8] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  OPJ_SIZE_T __cil_tmp10 ;
  OPJ_OFF_T bleft ;
  OPJ_OFF_T __cil_tmp12 ;
  int tmp___3 ;
  OPJ_UINT32 l_xl_part_size ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
  {
#line 451
  __cil_tmp10 = opj_stream_read_data(cio, (OPJ_BYTE *)l_data_header, (OPJ_SIZE_T )8,
                                     p_manager);
#line 451
  *p_number_bytes_read = (OPJ_UINT32 )__cil_tmp10;
  }
#line 452
  if (*p_number_bytes_read != 8U) {
#line 453
    return (0);
  }
  {
#line 457
  opj_read_bytes_LE((OPJ_BYTE *)l_data_header, & box->length, (OPJ_UINT32 )4);
#line 458
  opj_read_bytes_LE((OPJ_BYTE *)l_data_header + 4, & box->type, (OPJ_UINT32 )4);
  }
#line 460
  if (box->length == 0U) {
    {
#line 462
    __cil_tmp12 = opj_stream_get_number_byte_left(cio);
#line 462
    bleft = __cil_tmp12;
#line 463
    box->length = (OPJ_UINT32 )bleft;
    }
#line 465
    return (1);
  }
#line 470
  if (box->length == 1U) {
    {
#line 473
    __cil_tmp16 = opj_stream_read_data(cio, (OPJ_BYTE *)l_data_header, (OPJ_SIZE_T )8,
                                       p_manager);
#line 473
    l_nb_bytes_read = (OPJ_UINT32 )__cil_tmp16;
    }
#line 474
    if (l_nb_bytes_read != 8U) {
#line 475
      if (l_nb_bytes_read > 0U) {
#line 476
        *p_number_bytes_read += l_nb_bytes_read;
      }
#line 479
      return (0);
    }
    {
#line 482
    *p_number_bytes_read = (OPJ_UINT32 )16;
#line 483
    opj_read_bytes_LE((OPJ_BYTE *)l_data_header, & l_xl_part_size, (OPJ_UINT32 )4);
    }
#line 484
    if (l_xl_part_size != 0U) {
      {
#line 485
      opj_event_msg(p_manager, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 486
      return (0);
    }
    {
#line 488
    opj_read_bytes_LE((OPJ_BYTE *)l_data_header + 4, & box->length, (OPJ_UINT32 )4);
    }
  }
#line 490
  return (1);
}
}
#line 517 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_ihdr(opj_jp2_t *jp2 , OPJ_BYTE *p_image_header_data , OPJ_UINT32 p_image_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp8 ;

  {
#line 527
  if (p_image_header_size != 14U) {
    {
#line 528
    opj_event_msg(p_manager, 1, "Bad image header box (bad size)\n\220");
    }
#line 529
    return (0);
  }
  {
#line 532
  opj_read_bytes_LE(p_image_header_data, & jp2->h, (OPJ_UINT32 )4);
#line 533
  p_image_header_data += 4;
#line 534
  opj_read_bytes_LE(p_image_header_data, & jp2->w, (OPJ_UINT32 )4);
#line 535
  p_image_header_data += 4;
#line 536
  opj_read_bytes_LE(p_image_header_data, & jp2->numcomps, (OPJ_UINT32 )2);
#line 537
  p_image_header_data += 2;
#line 540
  __cil_tmp8 = calloc((unsigned long )jp2->numcomps, sizeof(opj_jp2_comps_t ));
#line 540
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp8;
  }
#line 541
  if (jp2->comps == (opj_jp2_comps_t *)0) {
    {
#line 542
    opj_event_msg(p_manager, 1, "Not enough memory to handle image header (ihdr)\n\220");
    }
#line 543
    return (0);
  }
  {
#line 546
  opj_read_bytes_LE(p_image_header_data, & jp2->bpc, (OPJ_UINT32 )1);
#line 547
  p_image_header_data ++;
#line 549
  opj_read_bytes_LE(p_image_header_data, & jp2->C, (OPJ_UINT32 )1);
#line 550
  p_image_header_data ++;
  }
#line 553
  if (jp2->C != 7U) {
    {
#line 554
    opj_event_msg(p_manager, 4, "JP2 IHDR box: compression type indicate that the file is not a conforming JP2 file (%d) \n\032Ni\347U",
                  jp2->C);
    }
  }
  {
#line 557
  opj_read_bytes_LE(p_image_header_data, & jp2->UnkC, (OPJ_UINT32 )1);
#line 558
  p_image_header_data ++;
#line 559
  opj_read_bytes_LE(p_image_header_data, & jp2->IPR, (OPJ_UINT32 )1);
#line 560
  p_image_header_data ++;
  }
#line 562
  return (1);
}
}
#line 565 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BYTE *opj_jp2_write_ihdr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_BYTE *l_ihdr_data ;
  OPJ_BYTE *l_current_ihdr_ptr ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;

  {
  {
#line 576
  __cil_tmp7 = calloc((unsigned long )1, (unsigned long )22);
#line 576
  l_ihdr_data = (OPJ_BYTE *)__cil_tmp7;
  }
#line 577
  if (l_ihdr_data == (OPJ_BYTE *)0) {
#line 578
    return ((OPJ_BYTE *)0);
  }
  {
#line 581
  l_current_ihdr_ptr = l_ihdr_data;
#line 583
  opj_write_bytes_LE(l_current_ihdr_ptr, (OPJ_UINT32 )22, (OPJ_UINT32 )4);
#line 584
  l_current_ihdr_ptr += 4;
#line 586
  opj_write_bytes_LE(l_current_ihdr_ptr, (OPJ_UINT32 )1768449138, (OPJ_UINT32 )4);
#line 587
  l_current_ihdr_ptr += 4;
#line 589
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->h, (OPJ_UINT32 )4);
#line 590
  l_current_ihdr_ptr += 4;
#line 592
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->w, (OPJ_UINT32 )4);
#line 593
  l_current_ihdr_ptr += 4;
#line 595
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->numcomps, (OPJ_UINT32 )2);
#line 596
  l_current_ihdr_ptr += 2;
#line 598
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->bpc, (OPJ_UINT32 )1);
#line 599
  l_current_ihdr_ptr ++;
#line 601
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->C, (OPJ_UINT32 )1);
#line 602
  l_current_ihdr_ptr ++;
#line 604
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->UnkC, (OPJ_UINT32 )1);
#line 605
  l_current_ihdr_ptr ++;
#line 607
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->IPR, (OPJ_UINT32 )1);
#line 608
  l_current_ihdr_ptr ++;
#line 610
  *p_nb_bytes_written = (OPJ_UINT32 )22;
  }
#line 612
  return (l_ihdr_data);
}
}
#line 615 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BYTE *opj_jp2_write_bpcc(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_bpcc_size ;
  OPJ_BYTE *l_bpcc_data ;
  OPJ_BYTE *l_current_bpcc_ptr ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;

  {
  {
#line 621
  l_bpcc_size = 8U + jp2->numcomps;
#line 628
  __cil_tmp9 = calloc((unsigned long )1, (unsigned long )l_bpcc_size);
#line 628
  l_bpcc_data = (OPJ_BYTE *)__cil_tmp9;
  }
#line 629
  if (l_bpcc_data == (OPJ_BYTE *)0) {
#line 630
    return ((OPJ_BYTE *)0);
  }
  {
#line 633
  l_current_bpcc_ptr = l_bpcc_data;
#line 635
  opj_write_bytes_LE(l_current_bpcc_ptr, l_bpcc_size, (OPJ_UINT32 )4);
#line 636
  l_current_bpcc_ptr += 4;
#line 638
  opj_write_bytes_LE(l_current_bpcc_ptr, (OPJ_UINT32 )1651532643, (OPJ_UINT32 )4);
#line 639
  l_current_bpcc_ptr += 4;
#line 641
  i = (OPJ_UINT32 )0;
  }
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 641
    if (! (i < jp2->numcomps)) {
#line 641
      goto while_break;
    }
    {
#line 642
    opj_write_bytes_LE(l_current_bpcc_ptr, (jp2->comps + i)->bpcc, (OPJ_UINT32 )1);
#line 643
    l_current_bpcc_ptr ++;
    }
#line 641
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 646
  *p_nb_bytes_written = l_bpcc_size;
#line 648
  return (l_bpcc_data);
}
}
#line 651 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_bpcc(opj_jp2_t *jp2 , OPJ_BYTE *p_bpc_header_data , OPJ_UINT32 p_bpc_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 665
  if (jp2->bpc != 255U) {
    {
#line 666
    opj_event_msg(p_manager, 2, "A BPCC header box is available although BPC given by the IHDR box (%d) indicate components bit depth is constant\n",
                  jp2->bpc);
    }
  }
#line 670
  if (p_bpc_header_size != jp2->numcomps) {
    {
#line 671
    opj_event_msg(p_manager, 1, "Bad BPCC header box (bad size)\n");
    }
#line 672
    return (0);
  }
#line 676
  i = (OPJ_UINT32 )0;
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! (i < jp2->numcomps)) {
#line 676
      goto while_break;
    }
    {
#line 677
    opj_read_bytes_LE(p_bpc_header_data, & (jp2->comps + i)->bpcc, (OPJ_UINT32 )1);
#line 678
    p_bpc_header_data ++;
    }
#line 676
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 681
  return (1);
}
}
#line 684 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BYTE *opj_jp2_write_colr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_UINT32 l_colr_size ;
  OPJ_BYTE *l_colr_data ;
  OPJ_BYTE *l_current_colr_ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp10 ;
  OPJ_UINT32 i ;

  {
#line 689
  l_colr_size = (OPJ_UINT32 )11;
  {
#line 698
  if (jp2->meth == (OPJ_UINT32 )1) {
#line 698
    goto case_1;
  }
#line 705
  goto switch_default;
  case_1: /* CIL Label */ 
#line 699
  l_colr_size += (unsigned int )4;
#line 700
  goto switch_break;
#line 703
  l_colr_size += jp2->color.icc_profile_len;
#line 704
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 706
  return ((OPJ_BYTE *)0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 709
  __cil_tmp10 = calloc((unsigned long )1, (unsigned long )l_colr_size);
#line 709
  l_colr_data = (OPJ_BYTE *)__cil_tmp10;
  }
#line 710
  if (l_colr_data == (OPJ_BYTE *)0) {
#line 711
    return ((OPJ_BYTE *)0);
  }
  {
#line 714
  l_current_colr_ptr = l_colr_data;
#line 716
  opj_write_bytes_LE(l_current_colr_ptr, l_colr_size, (OPJ_UINT32 )4);
#line 717
  l_current_colr_ptr += 4;
#line 719
  opj_write_bytes_LE(l_current_colr_ptr, (OPJ_UINT32 )1668246642, (OPJ_UINT32 )4);
#line 720
  l_current_colr_ptr += 4;
#line 722
  opj_write_bytes_LE(l_current_colr_ptr, jp2->meth, (OPJ_UINT32 )1);
#line 723
  l_current_colr_ptr ++;
#line 725
  opj_write_bytes_LE(l_current_colr_ptr, jp2->precedence, (OPJ_UINT32 )1);
#line 726
  l_current_colr_ptr ++;
#line 728
  opj_write_bytes_LE(l_current_colr_ptr, jp2->approx, (OPJ_UINT32 )1);
#line 729
  l_current_colr_ptr ++;
  }
#line 731
  if (jp2->meth == 1U) {
    {
#line 732
    opj_write_bytes_LE(l_current_colr_ptr, jp2->enumcs, (OPJ_UINT32 )4);
    }
  } else
#line 734
  if (jp2->meth == 2U) {
#line 736
    i = (OPJ_UINT32 )0;
    {
#line 736
    while (1) {
      while_continue: /* CIL Label */ ;
#line 736
      if (! (i < jp2->color.icc_profile_len)) {
#line 736
        goto while_break;
      }
      {
#line 737
      opj_write_bytes_LE(l_current_colr_ptr, (OPJ_UINT32 )*(jp2->color.icc_profile_buf + i),
                         (OPJ_UINT32 )1);
#line 738
      l_current_colr_ptr ++;
      }
#line 736
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 743
  *p_nb_bytes_written = l_colr_size;
#line 745
  return (l_colr_data);
}
}
#line 748 "/root/patron/new_21/src/lib/openjp2/jp2.c"
void opj_jp2_free_pclr(opj_jp2_color_t *color ) 
{ 


  {
  {
#line 750
  free((color->jp2_pclr)->channel_sign);
#line 751
  free((color->jp2_pclr)->channel_size);
#line 752
  free((color->jp2_pclr)->entries);
  }
#line 754
  if ((color->jp2_pclr)->cmap) {
    {
#line 754
    free((color->jp2_pclr)->cmap);
    }
  }
  {
#line 756
  free(color->jp2_pclr);
#line 756
  color->jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
  }
  return;
}
}
#line 759 "/root/patron/new_21/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_check_color(opj_image_t *image , opj_jp2_color_t *color ,
                                    opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT16 i ;
  opj_jp2_cdef_info_t *info ;
  OPJ_UINT16 n ;
  OPJ_UINT32 nr_channels ;
  OPJ_UINT16 __cil_tmp8 ;
  OPJ_UINT16 nr_channels___0 ;
  opj_jp2_cmap_comp_t *cmap ;
  OPJ_BOOL *pcol_usage ;
  OPJ_BOOL is_sane ;
  OPJ_UINT16 __cil_tmp13 ;
  void *__cil_tmp14 ;
  OPJ_UINT16 pcol ;
  int tmp ;
  OPJ_UINT16 __cil_tmp17 ;
  OPJ_UINT16 __cil_tmp18 ;

  {
#line 764
  if (color->jp2_cdef) {
#line 765
    info = (color->jp2_cdef)->info;
#line 766
    n = (color->jp2_cdef)->n;
#line 767
    nr_channels = image->numcomps;
#line 770
    if (color->jp2_pclr) {
#line 770
      if ((color->jp2_pclr)->cmap) {
#line 771
        nr_channels = (OPJ_UINT32 )(color->jp2_pclr)->nr_channels;
      }
    }
#line 774
    i = (OPJ_UINT16 )0;
    {
#line 774
    while (1) {
      while_continue: /* CIL Label */ ;
#line 774
      if (! ((int )i < (int )n)) {
#line 774
        goto while_break;
      }
#line 775
      if ((unsigned int )(info + i)->cn >= image->numcomps) {
        {
#line 776
        opj_event_msg(p_manager, 1, "Invalid component index %d (>= %d).\n", (int )(info + i)->cn,
                      image->numcomps);
        }
#line 777
        return (0);
      }
#line 779
      if ((int )(info + i)->asoc > 0) {
#line 779
        if ((OPJ_UINT32 )((int )(info + i)->asoc - 1) >= image->numcomps) {
          {
#line 780
          opj_event_msg(p_manager, 1, "Invalid component index %d (>= %d).\n\347U",
                        (int )(info + i)->asoc - 1, image->numcomps);
          }
#line 781
          return (0);
        }
      }
#line 774
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 787
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 787
      if (! (nr_channels > 0U)) {
#line 787
        goto while_break___0;
      }
#line 789
      i = (OPJ_UINT16 )0;
      {
#line 789
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 789
        if (! ((int )i < (int )n)) {
#line 789
          goto while_break___1;
        }
#line 790
        if ((OPJ_UINT32 )(info + i)->cn == nr_channels - 1U) {
#line 791
          goto while_break___1;
        }
#line 789
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 794
      if ((int )i == (int )n) {
        {
#line 795
        opj_event_msg(p_manager, 1, "Incomplete channel definitions.\n\220");
        }
#line 796
        return (0);
      }
#line 798
      nr_channels --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 804
  if (color->jp2_pclr) {
#line 804
    if ((color->jp2_pclr)->cmap) {
#line 805
      nr_channels___0 = (OPJ_UINT16 )(color->jp2_pclr)->nr_channels;
#line 806
      cmap = (color->jp2_pclr)->cmap;
#line 807
      is_sane = 1;
#line 810
      i = (OPJ_UINT16 )0;
      {
#line 810
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 810
        if (! ((int )i < (int )nr_channels___0)) {
#line 810
          goto while_break___2;
        }
#line 811
        if ((unsigned int )(cmap + i)->cmp >= image->numcomps) {
          {
#line 812
          opj_event_msg(p_manager, 1, "Invalid component index %d (>= %d).\n\347U",
                        (int )(cmap + i)->cmp, image->numcomps);
#line 813
          is_sane = 0;
          }
        }
#line 810
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 817
      pcol_usage = (OPJ_BOOL *)calloc((unsigned long )nr_channels___0, sizeof(OPJ_BOOL ));
      }
#line 818
      if (! pcol_usage) {
        {
#line 819
        opj_event_msg(p_manager, 1, "Unexpected OOM.\n\220");
        }
#line 820
        return (0);
      }
#line 823
      i = (OPJ_UINT16 )0;
      {
#line 823
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 823
        if (! ((int )i < (int )nr_channels___0)) {
#line 823
          goto while_break___3;
        }
#line 824
        pcol = (OPJ_UINT16 )(cmap + i)->pcol;
#line 826
        if ((int )pcol >= (int )nr_channels___0) {
          {
#line 827
          opj_event_msg(p_manager, 1, "Invalid component/palette index for direct mapping %d.\n",
                        (int )pcol);
#line 828
          is_sane = 0;
          }
        } else
#line 830
        if (*(pcol_usage + pcol)) {
#line 830
          if ((int )(cmap + i)->mtyp == 1) {
            {
#line 831
            opj_event_msg(p_manager, 1, "Component %d is mapped twice.\n", (int )pcol);
#line 832
            is_sane = 0;
            }
          } else {
#line 830
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 834
        if ((int )(cmap + i)->mtyp == 0) {
#line 834
          if ((int )(cmap + i)->pcol != 0) {
            {
#line 837
            opj_event_msg(p_manager, 1, "Direct use at #%d however pcol=%d.\n", (int )i,
                          (int )pcol);
#line 838
            is_sane = 0;
            }
          } else {
#line 841
            *(pcol_usage + pcol) = 1;
          }
        } else {
#line 841
          *(pcol_usage + pcol) = 1;
        }
#line 823
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 844
      i = (OPJ_UINT16 )0;
      {
#line 844
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 844
        if (! ((int )i < (int )nr_channels___0)) {
#line 844
          goto while_break___4;
        }
#line 845
        if (! *(pcol_usage + i)) {
#line 845
          if ((int )(cmap + i)->mtyp != 0) {
            {
#line 846
            opj_event_msg(p_manager, 1, "Component %d doesn\'t have a mapping.\n",
                          (int )i);
#line 847
            is_sane = 0;
            }
          }
        }
#line 844
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 850
      free(pcol_usage);
      }
#line 851
      if (! is_sane) {
#line 852
        return (0);
      }
    }
  }
#line 856
  return (1);
}
}
#line 860 "/root/patron/new_21/src/lib/openjp2/jp2.c"
void opj_jp2_apply_pclr(opj_image_t *image , opj_jp2_color_t *color ) 
{ 
  opj_image_comp_t *old_comps ;
  opj_image_comp_t *new_comps ;
  OPJ_BYTE *channel_size ;
  OPJ_BYTE *channel_sign ;
  OPJ_UINT32 *entries ;
  opj_jp2_cmap_comp_t *cmap ;
  OPJ_INT32 *src ;
  OPJ_INT32 *dst ;
  OPJ_UINT32 j ;
  OPJ_UINT32 max ;
  OPJ_UINT16 i ;
  OPJ_UINT16 nr_channels ;
  OPJ_UINT16 cmp ;
  OPJ_UINT16 pcol ;
  OPJ_INT32 k ;
  OPJ_INT32 top_k ;
  void *__cil_tmp19 ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp22 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 871
  channel_size = (color->jp2_pclr)->channel_size;
#line 872
  channel_sign = (color->jp2_pclr)->channel_sign;
#line 873
  entries = (color->jp2_pclr)->entries;
#line 874
  cmap = (color->jp2_pclr)->cmap;
#line 875
  nr_channels = (OPJ_UINT16 )(color->jp2_pclr)->nr_channels;
#line 877
  old_comps = image->comps;
#line 878
  __cil_tmp19 = malloc((unsigned long )nr_channels * sizeof(opj_image_comp_t ));
#line 878
  new_comps = (opj_image_comp_t *)__cil_tmp19;
  }
#line 880
  if (! new_comps) {
#line 883
    return;
  }
#line 885
  i = (OPJ_UINT16 )0;
  {
#line 885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 885
    if (! ((int )i < (int )nr_channels)) {
#line 885
      goto while_break;
    }
#line 886
    pcol = (OPJ_UINT16 )(cmap + i)->pcol;
#line 886
    cmp = (cmap + i)->cmp;
#line 889
    if ((int )(cmap + i)->mtyp == 0) {
#line 891
      *(new_comps + i) = *(old_comps + cmp);
    } else {
#line 894
      *(new_comps + pcol) = *(old_comps + cmp);
    }
    {
#line 898
    __cil_tmp22 = malloc((unsigned long )((old_comps + cmp)->w * (old_comps + cmp)->h) * sizeof(OPJ_INT32 ));
#line 898
    (new_comps + i)->data = (OPJ_INT32 *)__cil_tmp22;
    }
#line 900
    if (! (new_comps + i)->data) {
      {
#line 901
      free(new_comps);
#line 902
      new_comps = (opj_image_comp_t *)((void *)0);
      }
#line 905
      return;
    }
#line 907
    (new_comps + i)->prec = (OPJ_UINT32 )*(channel_size + i);
#line 908
    (new_comps + i)->sgnd = (OPJ_UINT32 )*(channel_sign + i);
#line 885
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 911
  top_k = (int )(color->jp2_pclr)->nr_entries - 1;
#line 913
  i = (OPJ_UINT16 )0;
  {
#line 913
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 913
    if (! ((int )i < (int )nr_channels)) {
#line 913
      goto while_break___0;
    }
#line 915
    cmp = (cmap + i)->cmp;
#line 915
    pcol = (OPJ_UINT16 )(cmap + i)->pcol;
#line 916
    src = (old_comps + cmp)->data;
#line 918
    max = (new_comps + pcol)->w * (new_comps + pcol)->h;
#line 921
    if ((int )(cmap + i)->mtyp == 0) {
#line 923
      dst = (new_comps + i)->data;
#line 925
      j = (OPJ_UINT32 )0;
      {
#line 925
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 925
        if (! (j < max)) {
#line 925
          goto while_break___1;
        }
#line 926
        *(dst + j) = *(src + j);
#line 925
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 931
      dst = (new_comps + pcol)->data;
#line 933
      j = (OPJ_UINT32 )0;
      {
#line 933
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 933
        if (! (j < max)) {
#line 933
          goto while_break___2;
        }
#line 935
        k = *(src + j);
#line 935
        if (k < 0) {
#line 935
          k = 0;
        } else
#line 935
        if (k > top_k) {
#line 935
          k = top_k;
        }
#line 938
        *(dst + j) = (OPJ_INT32 )*(entries + (k * (int )nr_channels + (int )pcol));
#line 933
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 913
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 943
  max = image->numcomps;
#line 944
  i = (OPJ_UINT16 )0;
  {
#line 944
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 944
    if (! ((unsigned int )i < max)) {
#line 944
      goto while_break___3;
    }
#line 945
    if ((old_comps + i)->data) {
      {
#line 945
      free((old_comps + i)->data);
      }
    }
#line 944
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 948
  free(old_comps);
#line 949
  image->comps = new_comps;
#line 950
  image->numcomps = (OPJ_UINT32 )nr_channels;
#line 952
  opj_jp2_free_pclr(color);
  }
  return;
}
}
#line 956 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_pclr(opj_jp2_t *jp2 , OPJ_BYTE *p_pclr_header_data , OPJ_UINT32 p_pclr_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_pclr_t *jp2_pclr ;
  OPJ_BYTE *channel_size ;
  OPJ_BYTE *channel_sign ;
  OPJ_UINT32 *entries ;
  OPJ_UINT16 nr_entries ;
  OPJ_UINT16 nr_channels ;
  OPJ_UINT16 i ;
  OPJ_UINT16 j ;
  OPJ_UINT32 l_value ;
  OPJ_BYTE *orig_header_data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  int tmp___2 ;
  OPJ_UINT32 bytes_to_read ;
  OPJ_UINT32 *__cil_tmp24 ;

  {
#line 968
  orig_header_data = p_pclr_header_data;
#line 976
  if (jp2->color.jp2_pclr) {
#line 977
    return (0);
  }
#line 979
  if (p_pclr_header_size < 3U) {
#line 980
    return (0);
  }
  {
#line 982
  opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )2);
#line 983
  p_pclr_header_data += 2;
#line 984
  nr_entries = (OPJ_UINT16 )l_value;
#line 986
  opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )1);
#line 987
  p_pclr_header_data ++;
#line 988
  nr_channels = (OPJ_UINT16 )l_value;
  }
#line 990
  if (p_pclr_header_size < 3U + (OPJ_UINT32 )nr_channels) {
#line 991
    return (0);
  } else
#line 990
  if ((int )nr_channels == 0) {
#line 991
    return (0);
  } else
#line 990
  if ((unsigned int )nr_entries >= 4294967295U / (unsigned int )nr_channels) {
#line 991
    return (0);
  }
  {
#line 993
  __cil_tmp18 = malloc(((size_t )nr_channels * (unsigned long )nr_entries) * sizeof(OPJ_UINT32 ));
#line 993
  entries = (OPJ_UINT32 *)__cil_tmp18;
  }
#line 994
  if (! entries) {
#line 995
    return (0);
  }
  {
#line 996
  __cil_tmp19 = malloc((unsigned long )nr_channels);
#line 996
  channel_size = (OPJ_BYTE *)__cil_tmp19;
  }
#line 997
  if (! channel_size) {
    {
#line 999
    free(entries);
    }
#line 1000
    return (0);
  }
  {
#line 1002
  __cil_tmp20 = malloc((unsigned long )nr_channels);
#line 1002
  channel_sign = (OPJ_BYTE *)__cil_tmp20;
  }
#line 1003
  if (! channel_sign) {
    {
#line 1005
    free(entries);
#line 1006
    free(channel_size);
    }
#line 1007
    return (0);
  }
  {
#line 1010
  __cil_tmp21 = malloc(sizeof(opj_jp2_pclr_t ));
#line 1010
  jp2_pclr = (opj_jp2_pclr_t *)__cil_tmp21;
  }
#line 1011
  if (! jp2_pclr) {
    {
#line 1013
    free(entries);
#line 1014
    free(channel_size);
#line 1015
    free(channel_sign);
    }
#line 1016
    return (0);
  }
#line 1019
  jp2_pclr->channel_sign = channel_sign;
#line 1020
  jp2_pclr->channel_size = channel_size;
#line 1021
  jp2_pclr->entries = entries;
#line 1022
  jp2_pclr->nr_entries = nr_entries;
#line 1023
  jp2_pclr->nr_channels = (OPJ_BYTE )l_value;
#line 1024
  jp2_pclr->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
#line 1026
  jp2->color.jp2_pclr = jp2_pclr;
#line 1028
  i = (OPJ_UINT16 )0;
  {
#line 1028
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1028
    if (! ((int )i < (int )nr_channels)) {
#line 1028
      goto while_break;
    }
    {
#line 1029
    opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )1);
#line 1030
    p_pclr_header_data ++;
#line 1032
    *(channel_size + i) = (OPJ_BYTE )((l_value & 127U) + 1U);
    }
#line 1033
    if (l_value & 128U) {
#line 1033
      tmp___2 = 1;
    } else {
#line 1033
      tmp___2 = 0;
    }
#line 1033
    *(channel_sign + i) = (OPJ_BYTE )tmp___2;
#line 1028
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1036
  j = (OPJ_UINT16 )0;
  {
#line 1036
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1036
    if (! ((int )j < (int )nr_entries)) {
#line 1036
      goto while_break___0;
    }
#line 1037
    i = (OPJ_UINT16 )0;
    {
#line 1037
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1037
      if (! ((int )i < (int )nr_channels)) {
#line 1037
        goto while_break___1;
      }
#line 1038
      bytes_to_read = (OPJ_UINT32 )(((int )*(channel_size + i) + 7) >> 3);
#line 1040
      if ((unsigned long )bytes_to_read > sizeof(OPJ_UINT32 )) {
#line 1041
        bytes_to_read = (OPJ_UINT32 )sizeof(OPJ_UINT32 );
      }
#line 1042
      if ((ptrdiff_t )p_pclr_header_size < (ptrdiff_t )(p_pclr_header_data - orig_header_data) + (ptrdiff_t )bytes_to_read) {
#line 1043
        return (0);
      }
      {
#line 1045
      opj_read_bytes_LE(p_pclr_header_data, & l_value, bytes_to_read);
#line 1046
      p_pclr_header_data += bytes_to_read;
#line 1047
      *entries = (OPJ_UINT32 )l_value;
#line 1048
      entries ++;
      }
#line 1037
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1036
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1052
  return (1);
}
}
#line 1055 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_cmap(opj_jp2_t *jp2 , OPJ_BYTE *p_cmap_header_data , OPJ_UINT32 p_cmap_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_cmap_comp_t *cmap ;
  OPJ_BYTE i ;
  OPJ_BYTE nr_channels ;
  OPJ_UINT32 l_value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp12 ;

  {
#line 1072
  if (jp2->color.jp2_pclr == (void *)0) {
    {
#line 1073
    opj_event_msg(p_manager, 1, "Need to read a PCLR box before the CMAP box.\n");
    }
#line 1074
    return (0);
  }
#line 1080
  if ((jp2->color.jp2_pclr)->cmap) {
    {
#line 1081
    opj_event_msg(p_manager, 1, "Only one CMAP box is allowed.\n");
    }
#line 1082
    return (0);
  }
#line 1085
  nr_channels = (jp2->color.jp2_pclr)->nr_channels;
#line 1086
  if (p_cmap_header_size < (OPJ_UINT32 )nr_channels * 4U) {
    {
#line 1087
    opj_event_msg(p_manager, 1, "Insufficient data for CMAP box.\n\220");
    }
#line 1088
    return (0);
  }
  {
#line 1091
  __cil_tmp12 = malloc((unsigned long )nr_channels * sizeof(opj_jp2_cmap_comp_t ));
#line 1091
  cmap = (opj_jp2_cmap_comp_t *)__cil_tmp12;
  }
#line 1092
  if (! cmap) {
#line 1093
    return (0);
  }
#line 1096
  i = (OPJ_BYTE )0;
  {
#line 1096
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1096
    if (! ((int )i < (int )nr_channels)) {
#line 1096
      goto while_break;
    }
    {
#line 1097
    opj_read_bytes_LE(p_cmap_header_data, & l_value, (OPJ_UINT32 )2);
#line 1098
    p_cmap_header_data += 2;
#line 1099
    (cmap + i)->cmp = (OPJ_UINT16 )l_value;
#line 1101
    opj_read_bytes_LE(p_cmap_header_data, & l_value, (OPJ_UINT32 )1);
#line 1102
    p_cmap_header_data ++;
#line 1103
    (cmap + i)->mtyp = (OPJ_BYTE )l_value;
#line 1105
    opj_read_bytes_LE(p_cmap_header_data, & l_value, (OPJ_UINT32 )1);
#line 1106
    p_cmap_header_data ++;
#line 1107
    (cmap + i)->pcol = (OPJ_BYTE )l_value;
    }
#line 1096
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1110
  (jp2->color.jp2_pclr)->cmap = cmap;
#line 1112
  return (1);
}
}
#line 1115 "/root/patron/new_21/src/lib/openjp2/jp2.c"
void opj_jp2_apply_cdef(opj_image_t *image , opj_jp2_color_t *color ) 
{ 
  opj_jp2_cdef_info_t *info ;
  OPJ_UINT16 i ;
  OPJ_UINT16 n ;
  OPJ_UINT16 cn ;
  OPJ_UINT16 asoc ;
  OPJ_UINT16 acn ;
  opj_image_comp_t saved ;

  {
#line 1120
  info = (color->jp2_cdef)->info;
#line 1121
  n = (color->jp2_cdef)->n;
#line 1123
  i = (OPJ_UINT16 )0;
  {
#line 1123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1123
    if (! ((int )i < (int )n)) {
#line 1123
      goto while_break;
    }
#line 1126
    asoc = (info + i)->asoc;
#line 1127
    if ((int )asoc == 0) {
      _L: /* CIL Label */ 
#line 1129
      if ((unsigned int )i < image->numcomps) {
#line 1130
        (image->comps + i)->alpha = (info + i)->typ;
      }
#line 1131
      goto while_continue;
    } else
#line 1127
    if ((int )asoc == 65535) {
#line 1127
      goto _L;
    }
#line 1134
    cn = (info + i)->cn;
#line 1135
    acn = (OPJ_UINT16 )((int )asoc - 1);
#line 1136
    if ((unsigned int )cn >= image->numcomps) {
      {
      {
#line 1138
      fprintf(stderr, "cn=%d, acn=%d, numcomps=%d\n", (int )cn, (int )acn, image->numcomps);
      }
      }
#line 1139
      goto while_continue;
    } else
#line 1136
    if ((unsigned int )acn >= image->numcomps) {
      {
      {
#line 1138
      fprintf(stderr, "cn=%d, acn=%d, numcomps=%d\n", (int )cn, (int )acn, image->numcomps);
      }
      }
#line 1139
      goto while_continue;
    }
#line 1142
    if ((int )cn != (int )acn) {
      {
#line 1146
      memcpy(& saved, image->comps + cn, sizeof(opj_image_comp_t ));
#line 1147
      memcpy(image->comps + cn, image->comps + acn, sizeof(opj_image_comp_t ));
#line 1148
      memcpy(image->comps + acn, & saved, sizeof(opj_image_comp_t ));
#line 1150
      (info + i)->asoc = (OPJ_UINT16 )((int )cn + 1);
#line 1151
      (info + acn)->asoc = (OPJ_UINT16 )((int )(info + acn)->cn + 1);
      }
    }
#line 1154
    (image->comps + cn)->alpha = (info + i)->typ;
#line 1123
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1157
  if ((color->jp2_cdef)->info) {
    {
#line 1157
    free((color->jp2_cdef)->info);
    }
  }
  {
#line 1159
  free(color->jp2_cdef);
#line 1159
  color->jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
  }
  return;
}
}
#line 1163 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_cdef(opj_jp2_t *jp2 , OPJ_BYTE *p_cdef_header_data , OPJ_UINT32 p_cdef_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_cdef_info_t *cdef_info ;
  OPJ_UINT16 i ;
  OPJ_UINT32 l_value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;

  {
#line 1181
  if (jp2->color.jp2_cdef) {
#line 1181
    return (0);
  }
#line 1183
  if (p_cdef_header_size < 2U) {
    {
#line 1184
    opj_event_msg(p_manager, 1, "Insufficient data for CDEF box.\n\220");
    }
#line 1185
    return (0);
  }
  {
#line 1188
  opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1189
  p_cdef_header_data += 2;
  }
#line 1191
  if ((int )((OPJ_UINT16 )l_value) == 0) {
    {
#line 1192
    opj_event_msg(p_manager, 1, "Number of channel description is equal to zero in CDEF box.\n");
    }
#line 1193
    return (0);
  }
#line 1196
  if (p_cdef_header_size < 2U + (OPJ_UINT32 )((OPJ_UINT16 )l_value) * 6U) {
    {
#line 1197
    opj_event_msg(p_manager, 1, "Insufficient data for CDEF box.\n\220");
    }
#line 1198
    return (0);
  }
  {
#line 1201
  __cil_tmp11 = malloc((unsigned long )l_value * sizeof(opj_jp2_cdef_info_t ));
#line 1201
  cdef_info = (opj_jp2_cdef_info_t *)__cil_tmp11;
  }
#line 1202
  if (! cdef_info) {
#line 1203
    return (0);
  }
  {
#line 1205
  __cil_tmp12 = malloc(sizeof(opj_jp2_cdef_t ));
#line 1205
  jp2->color.jp2_cdef = (opj_jp2_cdef_t *)__cil_tmp12;
  }
#line 1206
  if (! jp2->color.jp2_cdef) {
    {
#line 1208
    free(cdef_info);
    }
#line 1209
    return (0);
  }
#line 1211
  (jp2->color.jp2_cdef)->info = cdef_info;
#line 1212
  (jp2->color.jp2_cdef)->n = (OPJ_UINT16 )l_value;
#line 1214
  i = (OPJ_UINT16 )0;
  {
#line 1214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1214
    if (! ((int )i < (int )(jp2->color.jp2_cdef)->n)) {
#line 1214
      goto while_break;
    }
    {
#line 1215
    opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1216
    p_cdef_header_data += 2;
#line 1217
    (cdef_info + i)->cn = (OPJ_UINT16 )l_value;
#line 1219
    opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1220
    p_cdef_header_data += 2;
#line 1221
    (cdef_info + i)->typ = (OPJ_UINT16 )l_value;
#line 1223
    opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1224
    p_cdef_header_data += 2;
#line 1225
    (cdef_info + i)->asoc = (OPJ_UINT16 )l_value;
    }
#line 1214
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1228
  return (1);
}
}
#line 1231 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_colr(opj_jp2_t *jp2 , OPJ_BYTE *p_colr_header_data , OPJ_UINT32 p_colr_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_INT32 it_icc_value ;
  OPJ_INT32 icc_len ;
  void *__cil_tmp11 ;

  {
#line 1244
  if (p_colr_header_size < 3U) {
    {
#line 1245
    opj_event_msg(p_manager, 1, "Bad COLR header box (bad size)\n");
    }
#line 1246
    return (0);
  }
#line 1252
  if (jp2->color.jp2_has_colr) {
    {
#line 1253
    opj_event_msg(p_manager, 4, "A conforming JP2 reader shall ignore all Colour Specification boxes after the first, so we ignore this one.\n");
#line 1254
    p_colr_header_data += p_colr_header_size;
    }
#line 1255
    return (1);
  }
  {
#line 1258
  opj_read_bytes_LE(p_colr_header_data, & jp2->meth, (OPJ_UINT32 )1);
#line 1259
  p_colr_header_data ++;
#line 1261
  opj_read_bytes_LE(p_colr_header_data, & jp2->precedence, (OPJ_UINT32 )1);
#line 1262
  p_colr_header_data ++;
#line 1264
  opj_read_bytes_LE(p_colr_header_data, & jp2->approx, (OPJ_UINT32 )1);
#line 1265
  p_colr_header_data ++;
  }
#line 1267
  if (jp2->meth == 1U) {
#line 1268
    if (p_colr_header_size < 7U) {
      {
#line 1269
      opj_event_msg(p_manager, 1, "Bad COLR header box (bad size: %d)\ni\347U", p_colr_header_size);
      }
#line 1270
      return (0);
    }
#line 1272
    if (p_colr_header_size > 7U) {
      {
#line 1274
      opj_event_msg(p_manager, 2, "Bad COLR header box (bad size: %d)\n", p_colr_header_size);
      }
    }
    {
#line 1277
    opj_read_bytes_LE(p_colr_header_data, & jp2->enumcs, (OPJ_UINT32 )4);
#line 1279
    jp2->color.jp2_has_colr = (OPJ_BYTE )1;
    }
  } else
#line 1281
  if (jp2->meth == 2U) {
    {
#line 1283
    it_icc_value = 0;
#line 1284
    icc_len = (OPJ_INT32 )p_colr_header_size - 3;
#line 1286
    jp2->color.icc_profile_len = (OPJ_UINT32 )icc_len;
#line 1287
    __cil_tmp11 = calloc((unsigned long )1, (size_t )icc_len);
#line 1287
    jp2->color.icc_profile_buf = (OPJ_BYTE *)__cil_tmp11;
    }
#line 1288
    if (! jp2->color.icc_profile_buf) {
#line 1290
      jp2->color.icc_profile_len = (OPJ_UINT32 )0;
#line 1291
      return (0);
    }
#line 1294
    it_icc_value = 0;
    {
#line 1294
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1294
      if (! (it_icc_value < icc_len)) {
#line 1294
        goto while_break;
      }
      {
#line 1296
      opj_read_bytes_LE(p_colr_header_data, & l_value, (OPJ_UINT32 )1);
#line 1297
      p_colr_header_data ++;
#line 1298
      *(jp2->color.icc_profile_buf + it_icc_value) = (OPJ_BYTE )l_value;
      }
#line 1294
      it_icc_value ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1301
    jp2->color.jp2_has_colr = (OPJ_BYTE )1;
  } else
#line 1303
  if (jp2->meth > 2U) {
    {
#line 1307
    opj_event_msg(p_manager, 4, "COLR BOX meth value is not a regular value (%d), so we will ignore the entire Colour Specification box. \n",
                  jp2->meth);
    }
  }
#line 1310
  return (1);
}
}
#line 1313 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_decode(opj_jp2_t *jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 1318
  if (! p_image) {
#line 1319
    return (0);
  }
  {
#line 1322
  __cil_tmp5 = opj_j2k_decode(jp2->j2k, p_stream, p_image, p_manager);
  }
#line 1322
  if (! __cil_tmp5) {
    {
#line 1323
    opj_event_msg(p_manager, 1, "Failed to decode the codestream in the JP2 file\n\220");
    }
#line 1324
    return (0);
  }
#line 1327
  if (! jp2->ignore_pclr_cmap_cdef) {
    {
#line 1328
    __cil_tmp6 = opj_jp2_check_color(p_image, & jp2->color, p_manager);
    }
#line 1328
    if (! __cil_tmp6) {
#line 1329
      return (0);
    }
#line 1333
    if (jp2->enumcs == 16U) {
#line 1334
      p_image->color_space = (OPJ_COLOR_SPACE )1;
    } else
#line 1335
    if (jp2->enumcs == 17U) {
#line 1336
      p_image->color_space = (OPJ_COLOR_SPACE )2;
    } else
#line 1337
    if (jp2->enumcs == 18U) {
#line 1338
      p_image->color_space = (OPJ_COLOR_SPACE )3;
    } else
#line 1339
    if (jp2->enumcs == 24U) {
#line 1340
      p_image->color_space = (OPJ_COLOR_SPACE )4;
    } else {
#line 1342
      p_image->color_space = (OPJ_COLOR_SPACE )-1;
    }
#line 1345
    if (jp2->color.jp2_cdef) {
      {
#line 1346
      opj_jp2_apply_cdef(p_image, & jp2->color);
      }
    }
#line 1349
    if (jp2->color.jp2_pclr) {
#line 1351
      if (! (jp2->color.jp2_pclr)->cmap) {
        {
#line 1352
        opj_jp2_free_pclr(& jp2->color);
        }
      } else {
        {
#line 1354
        opj_jp2_apply_pclr(p_image, & jp2->color);
        }
      }
    }
#line 1357
    if (jp2->color.icc_profile_buf) {
#line 1358
      p_image->icc_profile_buf = jp2->color.icc_profile_buf;
#line 1359
      p_image->icc_profile_len = jp2->color.icc_profile_len;
#line 1360
      jp2->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
    }
  }
#line 1364
  return (1);
}
}
#line 1367 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_jp2h(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_img_header_writer_handler_t l_writers[3] ;
  opj_jp2_img_header_writer_handler_t *l_current_writer ;
  OPJ_INT32 i ;
  OPJ_INT32 l_nb_pass ;
  OPJ_UINT32 l_jp2h_size ;
  OPJ_BOOL l_result ;
  OPJ_BYTE l_jp2h_data[8] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
  {
#line 1377
  l_jp2h_size = (OPJ_UINT32 )8;
#line 1378
  l_result = 1;
#line 1388
  memset((opj_jp2_img_header_writer_handler_t *)l_writers, 0, sizeof(l_writers));
  }
#line 1390
  if (jp2->bpc == 255U) {
#line 1391
    l_nb_pass = 3;
#line 1392
    l_writers[0].handler = & opj_jp2_write_ihdr;
#line 1393
    l_writers[1].handler = & opj_jp2_write_bpcc;
#line 1394
    l_writers[2].handler = & opj_jp2_write_colr;
  } else {
#line 1397
    l_nb_pass = 2;
#line 1398
    l_writers[0].handler = & opj_jp2_write_ihdr;
#line 1399
    l_writers[1].handler = & opj_jp2_write_colr;
  }
  {
#line 1404
  opj_write_bytes_LE((OPJ_BYTE *)l_jp2h_data + 4, (OPJ_UINT32 )1785737832, (OPJ_UINT32 )4);
#line 1406
  l_current_writer = (opj_jp2_img_header_writer_handler_t *)l_writers;
#line 1407
  i = 0;
  }
  {
#line 1407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1407
    if (! (i < l_nb_pass)) {
#line 1407
      goto while_break;
    }
    {
#line 1408
    l_current_writer->m_data = (*(l_current_writer->handler))(jp2, & l_current_writer->m_size);
    }
#line 1409
    if (l_current_writer->m_data == (OPJ_BYTE *)0) {
      {
#line 1410
      opj_event_msg(p_manager, 1, "Not enough memory to hold JP2 Header data\n");
#line 1411
      l_result = 0;
      }
#line 1412
      goto while_break;
    }
#line 1415
    l_jp2h_size += l_current_writer->m_size;
#line 1416
    l_current_writer ++;
#line 1407
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1419
  if (! l_result) {
#line 1420
    l_current_writer = (opj_jp2_img_header_writer_handler_t *)l_writers;
#line 1421
    i = 0;
    {
#line 1421
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1421
      if (! (i < l_nb_pass)) {
#line 1421
        goto while_break___0;
      }
#line 1422
      if (l_current_writer->m_data != (OPJ_BYTE *)0) {
        {
#line 1423
        free(l_current_writer->m_data);
        }
      }
#line 1425
      l_current_writer ++;
#line 1421
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1428
    return (0);
  }
  {
#line 1432
  opj_write_bytes_LE((OPJ_BYTE *)l_jp2h_data, l_jp2h_size, (OPJ_UINT32 )4);
#line 1435
  __cil_tmp15 = opj_stream_write_data(stream, (OPJ_BYTE *)l_jp2h_data, (OPJ_SIZE_T )8,
                                      p_manager);
  }
#line 1435
  if (__cil_tmp15 != 8UL) {
    {
#line 1436
    opj_event_msg(p_manager, 1, "Stream error while writing JP2 Header box\n");
#line 1437
    l_result = 0;
    }
  }
#line 1440
  if (l_result) {
#line 1441
    l_current_writer = (opj_jp2_img_header_writer_handler_t *)l_writers;
#line 1442
    i = 0;
    {
#line 1442
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1442
      if (! (i < l_nb_pass)) {
#line 1442
        goto while_break___1;
      }
      {
#line 1443
      __cil_tmp16 = opj_stream_write_data(stream, l_current_writer->m_data, (OPJ_SIZE_T )l_current_writer->m_size,
                                          p_manager);
      }
#line 1443
      if (__cil_tmp16 != (unsigned long )l_current_writer->m_size) {
        {
#line 1444
        opj_event_msg(p_manager, 1, "Stream error while writing JP2 Header box\n");
#line 1445
        l_result = 0;
        }
#line 1446
        goto while_break___1;
      }
#line 1448
      l_current_writer ++;
#line 1442
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1452
  l_current_writer = (opj_jp2_img_header_writer_handler_t *)l_writers;
#line 1455
  i = 0;
  {
#line 1455
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1455
    if (! (i < l_nb_pass)) {
#line 1455
      goto while_break___2;
    }
#line 1456
    if (l_current_writer->m_data != (OPJ_BYTE *)0) {
      {
#line 1457
      free(l_current_writer->m_data);
      }
    }
#line 1459
    l_current_writer ++;
#line 1455
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1462
  return (l_result);
}
}
#line 1465 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_ftyp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_ftyp_size ;
  OPJ_BYTE *l_ftyp_data ;
  OPJ_BYTE *l_current_data_ptr ;
  OPJ_BOOL l_result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp12 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 1470
  l_ftyp_size = 16U + 4U * jp2->numcl;
#line 1479
  __cil_tmp12 = calloc((unsigned long )1, (unsigned long )l_ftyp_size);
#line 1479
  l_ftyp_data = (OPJ_BYTE *)__cil_tmp12;
  }
#line 1481
  if (l_ftyp_data == (OPJ_BYTE *)0) {
    {
#line 1482
    opj_event_msg(p_manager, 1, "Not enough memory to handle ftyp data\n");
    }
#line 1483
    return (0);
  }
  {
#line 1486
  l_current_data_ptr = l_ftyp_data;
#line 1488
  opj_write_bytes_LE(l_current_data_ptr, l_ftyp_size, (OPJ_UINT32 )4);
#line 1489
  l_current_data_ptr += 4;
#line 1491
  opj_write_bytes_LE(l_current_data_ptr, (OPJ_UINT32 )1718909296, (OPJ_UINT32 )4);
#line 1492
  l_current_data_ptr += 4;
#line 1494
  opj_write_bytes_LE(l_current_data_ptr, jp2->brand, (OPJ_UINT32 )4);
#line 1495
  l_current_data_ptr += 4;
#line 1497
  opj_write_bytes_LE(l_current_data_ptr, jp2->minversion, (OPJ_UINT32 )4);
#line 1498
  l_current_data_ptr += 4;
#line 1500
  i = (OPJ_UINT32 )0;
  }
  {
#line 1500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1500
    if (! (i < jp2->numcl)) {
#line 1500
      goto while_break;
    }
    {
#line 1501
    opj_write_bytes_LE(l_current_data_ptr, *(jp2->cl + i), (OPJ_UINT32 )4);
    }
#line 1500
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1504
  __cil_tmp14 = opj_stream_write_data(cio, l_ftyp_data, (OPJ_SIZE_T )l_ftyp_size,
                                      p_manager);
#line 1504
  l_result = __cil_tmp14 == (unsigned long )l_ftyp_size;
  }
#line 1505
  if (! l_result) {
    {
#line 1507
    opj_event_msg(p_manager, 1, "Error while writing ftyp data to stream\n\220");
    }
  }
  {
#line 1510
  free(l_ftyp_data);
  }
#line 1512
  return (l_result);
}
}
#line 1515 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_OFF_T j2k_codestream_exit ;
  OPJ_BYTE l_data_header[8] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BOOL __cil_tmp9 ;
  int tmp___2 ;
  OPJ_OFF_T __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 1528
  j2k_codestream_exit = opj_stream_tell(cio);
#line 1529
  opj_write_bytes_LE((OPJ_BYTE *)l_data_header, (OPJ_UINT32 )(j2k_codestream_exit - jp2->j2k_codestream_offset),
                     (OPJ_UINT32 )4);
#line 1532
  opj_write_bytes_LE((OPJ_BYTE *)l_data_header + 4, (OPJ_UINT32 )1785737827, (OPJ_UINT32 )4);
#line 1534
  __cil_tmp12 = opj_stream_seek(cio, jp2->j2k_codestream_offset, p_manager);
  }
#line 1534
  if (! __cil_tmp12) {
    {
#line 1535
    opj_event_msg(p_manager, 1, "Failed to seek in the stream.\n");
    }
#line 1536
    return (0);
  }
  {
#line 1539
  __cil_tmp13 = opj_stream_write_data(cio, (OPJ_BYTE *)l_data_header, (OPJ_SIZE_T )8,
                                      p_manager);
  }
#line 1539
  if (__cil_tmp13 != 8UL) {
    {
#line 1540
    opj_event_msg(p_manager, 1, "Failed to seek in the stream.\n");
    }
#line 1541
    return (0);
  }
  {
#line 1544
  __cil_tmp14 = opj_stream_seek(cio, j2k_codestream_exit, p_manager);
  }
#line 1544
  if (! __cil_tmp14) {
    {
#line 1545
    opj_event_msg(p_manager, 1, "Failed to seek in the stream.\n");
    }
#line 1546
    return (0);
  }
#line 1549
  return (1);
}
}
#line 1552 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_jp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_signature_data[12] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_SIZE_T __cil_tmp8 ;

  {
  {
#line 1565
  opj_write_bytes_LE((OPJ_BYTE *)l_signature_data, (OPJ_UINT32 )12, (OPJ_UINT32 )4);
#line 1567
  opj_write_bytes_LE((OPJ_BYTE *)l_signature_data + 4, (OPJ_UINT32 )1783636000, (OPJ_UINT32 )4);
#line 1569
  opj_write_bytes_LE((OPJ_BYTE *)l_signature_data + 8, (OPJ_UINT32 )218793738, (OPJ_UINT32 )4);
#line 1571
  __cil_tmp8 = opj_stream_write_data(cio, (OPJ_BYTE *)l_signature_data, (OPJ_SIZE_T )12,
                                     p_manager);
  }
#line 1571
  if (__cil_tmp8 != 12UL) {
#line 1572
    return (0);
  }
#line 1575
  return (1);
}
}
#line 1582 "/root/patron/new_21/src/lib/openjp2/jp2.c"
void opj_jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) 
{ 


  {
  {
#line 1585
  opj_j2k_setup_decoder(jp2->j2k, parameters);
#line 1588
  jp2->color.jp2_has_colr = (OPJ_BYTE )0;
#line 1589
  jp2->ignore_pclr_cmap_cdef = (OPJ_BOOL )(parameters->flags & 1U);
  }
  return;
}
}
#line 1596 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ,
                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 depth_0 ;
  OPJ_UINT32 sign ;
  OPJ_BOOL __cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  OPJ_UINT32 depth ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_UINT32 __cil_tmp13 ;

  {
#line 1605
  if (! jp2) {
#line 1606
    return (0);
  } else
#line 1605
  if (! parameters) {
#line 1606
    return (0);
  } else
#line 1605
  if (! image) {
#line 1606
    return (0);
  }
#line 1612
  if (image->numcomps < 1U) {
    {
    {
#line 1613
    opj_event_msg(p_manager, 1, "Invalid number of components specified while setting up JP2 encoder\n\222\v\003");
    }
    }
#line 1614
    return (0);
  } else
#line 1612
  if (image->numcomps > 16384U) {
    {
    {
#line 1613
    opj_event_msg(p_manager, 1, "Invalid number of components specified while setting up JP2 encoder\n\222\v\003");
    }
    }
#line 1614
    return (0);
  }
  {
#line 1617
  __cil_tmp8 = opj_j2k_setup_encoder(jp2->j2k, parameters, image, p_manager);
  }
#line 1617
  if (__cil_tmp8 == 0) {
#line 1618
    return (0);
  }
  {
#line 1626
  jp2->brand = (OPJ_UINT32 )1785737760;
#line 1627
  jp2->minversion = (OPJ_UINT32 )0;
#line 1628
  jp2->numcl = (OPJ_UINT32 )1;
#line 1629
  __cil_tmp9 = malloc((unsigned long )jp2->numcl * sizeof(OPJ_UINT32 ));
#line 1629
  jp2->cl = (OPJ_UINT32 *)__cil_tmp9;
  }
#line 1630
  if (! jp2->cl) {
    {
#line 1631
    jp2->cl = (OPJ_UINT32 *)((void *)0);
#line 1632
    opj_event_msg(p_manager, 1, "Not enough memory when setup the JP2 encoder\n");
    }
#line 1633
    return (0);
  }
  {
#line 1635
  *(jp2->cl + 0) = (OPJ_UINT32 )1785737760;
#line 1639
  jp2->numcomps = image->numcomps;
#line 1640
  __cil_tmp10 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 1640
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp10;
  }
#line 1641
  if (! jp2->comps) {
    {
#line 1642
    jp2->comps = (opj_jp2_comps_t *)((void *)0);
#line 1643
    opj_event_msg(p_manager, 1, "Not enough memory when setup the JP2 encoder\n");
    }
#line 1645
    return (0);
  }
#line 1648
  jp2->h = image->y1 - image->y0;
#line 1649
  jp2->w = image->x1 - image->x0;
#line 1651
  depth_0 = (image->comps + 0)->prec - 1U;
#line 1652
  sign = (image->comps + 0)->sgnd;
#line 1653
  jp2->bpc = depth_0 + (sign << 7);
#line 1654
  i = (OPJ_UINT32 )1;
  {
#line 1654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1654
    if (! (i < image->numcomps)) {
#line 1654
      goto while_break;
    }
#line 1655
    depth = (image->comps + i)->prec - 1U;
#line 1656
    sign = (image->comps + i)->sgnd;
#line 1657
    if (depth_0 != depth) {
#line 1658
      jp2->bpc = (OPJ_UINT32 )255;
    }
#line 1654
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1660
  jp2->C = (OPJ_UINT32 )7;
#line 1661
  jp2->UnkC = (OPJ_UINT32 )0;
#line 1662
  jp2->IPR = (OPJ_UINT32 )0;
#line 1665
  i = (OPJ_UINT32 )0;
  {
#line 1665
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1665
    if (! (i < image->numcomps)) {
#line 1665
      goto while_break___0;
    }
#line 1666
    (jp2->comps + i)->bpcc = ((image->comps + i)->prec - 1U) + ((image->comps + i)->sgnd << 7);
#line 1665
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1670
  if (image->icc_profile_len) {
#line 1671
    jp2->meth = (OPJ_UINT32 )2;
#line 1672
    jp2->enumcs = (OPJ_UINT32 )0;
  } else {
#line 1675
    jp2->meth = (OPJ_UINT32 )1;
#line 1676
    if ((int )image->color_space == 1) {
#line 1677
      jp2->enumcs = (OPJ_UINT32 )16;
    } else
#line 1678
    if ((int )image->color_space == 2) {
#line 1679
      jp2->enumcs = (OPJ_UINT32 )17;
    } else
#line 1680
    if ((int )image->color_space == 3) {
#line 1681
      jp2->enumcs = (OPJ_UINT32 )18;
    }
  }
#line 1685
  jp2->precedence = (OPJ_UINT32 )0;
#line 1686
  jp2->approx = (OPJ_UINT32 )0;
#line 1688
  jp2->jpip_on = parameters->jpip_on;
#line 1690
  return (1);
}
}
#line 1693 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_encode(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 1697
  __cil_tmp4 = opj_j2k_encode(jp2->j2k, stream, p_manager);
  }
#line 1697
  return (__cil_tmp4);
}
}
#line 1700 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_end_decompress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1711
  opj_jp2_setup_end_header_reading(jp2);
#line 1714
  __cil_tmp7 = opj_jp2_exec(jp2, jp2->m_procedure_list, cio, p_manager);
  }
#line 1714
  if (! __cil_tmp7) {
#line 1715
    return (0);
  }
  {
#line 1718
  __cil_tmp8 = opj_j2k_end_decompress(jp2->j2k, cio, p_manager);
  }
#line 1718
  return (__cil_tmp8);
}
}
#line 1721 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_end_compress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1732
  opj_jp2_setup_end_header_writing(jp2);
#line 1734
  __cil_tmp7 = opj_j2k_end_compress(jp2->j2k, cio, p_manager);
  }
#line 1734
  if (! __cil_tmp7) {
#line 1735
    return (0);
  }
  {
#line 1739
  __cil_tmp8 = opj_jp2_exec(jp2, jp2->m_procedure_list, cio, p_manager);
  }
#line 1739
  return (__cil_tmp8);
}
}
#line 1742 "/root/patron/new_21/src/lib/openjp2/jp2.c"
void opj_jp2_setup_end_header_writing(opj_jp2_t *jp2 ) 
{ 
  int tmp ;

  {
  {
#line 1751
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jp2_write_jp2c));
  }
  return;
}
}
#line 1762 "/root/patron/new_21/src/lib/openjp2/jp2.c"
void opj_jp2_setup_end_header_reading(opj_jp2_t *jp2 ) 
{ 
  int tmp ;

  {
  {
#line 1766
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jp2_read_header_procedure));
  }
  return;
}
}
#line 1770 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_default_validation(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;
  OPJ_UINT32 i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 1775
  l_is_valid = 1;
#line 1787
  l_is_valid &= jp2->jp2_state == 0U;
#line 1790
  l_is_valid &= jp2->jp2_img_state == 0U;
#line 1794
  l_is_valid &= jp2->j2k != (opj_j2k_t *)0;
#line 1797
  l_is_valid &= jp2->m_procedure_list != (struct opj_procedure_list *)0;
#line 1800
  l_is_valid &= jp2->m_validation_list != (struct opj_procedure_list *)0;
#line 1804
  l_is_valid &= jp2->numcl > 0U;
#line 1806
  l_is_valid &= jp2->h > 0U;
#line 1808
  l_is_valid &= jp2->w > 0U;
#line 1810
  i = (OPJ_UINT32 )0;
  {
#line 1810
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1810
    if (! (i < jp2->numcomps)) {
#line 1810
      goto while_break;
    }
#line 1811
    l_is_valid &= (jp2->comps + i)->bpcc > 0U;
#line 1810
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1815
  l_is_valid &= jp2->meth > 0U && jp2->meth < 3U;
#line 1819
  __cil_tmp9 = opj_stream_has_seek(cio);
  }
#line 1819
  l_is_valid &= __cil_tmp9;
#line 1821
  return (l_is_valid);
}
}
#line 1824 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_header_procedure(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                       opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_box_t box ;
  OPJ_UINT32 l_nb_bytes_read ;
  opj_jp2_header_handler_t *l_current_handler ;
  OPJ_UINT32 l_last_data_size ;
  OPJ_UINT32 l_current_data_size ;
  OPJ_BYTE *l_current_data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  opj_jp2_header_handler_t *__cil_tmp15 ;
  OPJ_OFF_T __cil_tmp16 ;
  OPJ_OFF_T __cil_tmp17 ;
  OPJ_BYTE *new_current_data ;
  void *__cil_tmp19 ;
  OPJ_SIZE_T __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_OFF_T __cil_tmp22 ;

  {
  {
#line 1832
  l_last_data_size = (OPJ_UINT32 )1024;
#line 1834
  l_current_data = (OPJ_BYTE *)0;
#line 1841
  __cil_tmp13 = calloc((unsigned long )1, (unsigned long )l_last_data_size);
#line 1841
  l_current_data = (OPJ_BYTE *)__cil_tmp13;
  }
#line 1843
  if (l_current_data == (OPJ_BYTE *)0) {
    {
#line 1844
    opj_event_msg(p_manager, 1, "Not enough memory to handle jpeg2000 file header\n");
    }
#line 1845
    return (0);
  }
  {
#line 1848
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1848
    __cil_tmp14 = opj_jp2_read_boxhdr(& box, & l_nb_bytes_read, stream, p_manager);
    }
#line 1848
    if (! __cil_tmp14) {
#line 1848
      goto while_break;
    }
#line 1850
    if (box.type == 1785737827U) {
#line 1851
      if (jp2->jp2_state & 4U) {
        {
#line 1852
        jp2->jp2_state |= (unsigned int )8;
#line 1853
        free(l_current_data);
        }
#line 1854
        return (1);
      } else {
        {
#line 1857
        opj_event_msg(p_manager, 1, "bad placed jpeg codestream\n");
#line 1858
        free(l_current_data);
        }
#line 1859
        return (0);
      }
    } else
#line 1862
    if (box.length == 0U) {
      {
#line 1863
      opj_event_msg(p_manager, 1, "Cannot handle box of undefined sizes\n");
#line 1864
      free(l_current_data);
      }
#line 1865
      return (0);
    } else
#line 1868
    if (box.length < l_nb_bytes_read) {
      {
#line 1869
      opj_event_msg(p_manager, 1, "invalid box size %d (%x)\n", box.length, box.type);
#line 1870
      free(l_current_data);
      }
#line 1871
      return (0);
    }
    {
#line 1874
    l_current_handler = opj_jp2_find_handler(box.type);
#line 1875
    l_current_data_size = box.length - l_nb_bytes_read;
    }
#line 1877
    if (l_current_handler != (opj_jp2_header_handler_t *)0) {
      {
#line 1878
      __cil_tmp16 = opj_stream_get_number_byte_left(stream);
      }
#line 1878
      if ((OPJ_OFF_T )l_current_data_size > __cil_tmp16) {
        {
#line 1880
        __cil_tmp17 = opj_stream_get_number_byte_left(stream);
#line 1880
        opj_event_msg(p_manager, 1, "Invalid box size %d for box \'%c%c%c%c\'. Need %d bytes, %d bytes remaining \n",
                      box.length, (int )((OPJ_BYTE )(box.type >> 24)), (int )((OPJ_BYTE )(box.type >> 16)),
                      (int )((OPJ_BYTE )(box.type >> 8)), (int )((OPJ_BYTE )box.type),
                      l_current_data_size, (OPJ_UINT32 )__cil_tmp17);
#line 1881
        free(l_current_data);
        }
#line 1882
        return (0);
      }
#line 1884
      if (l_current_data_size > l_last_data_size) {
        {
#line 1885
        __cil_tmp19 = realloc(l_current_data, (unsigned long )l_current_data_size);
#line 1885
        new_current_data = (OPJ_BYTE *)__cil_tmp19;
        }
#line 1886
        if (! new_current_data) {
          {
#line 1887
          free(l_current_data);
#line 1888
          opj_event_msg(p_manager, 1, "Not enough memory to handle jpeg2000 box\n");
          }
#line 1889
          return (0);
        }
#line 1891
        l_current_data = new_current_data;
#line 1892
        l_last_data_size = l_current_data_size;
      }
      {
#line 1895
      __cil_tmp20 = opj_stream_read_data(stream, l_current_data, (OPJ_SIZE_T )l_current_data_size,
                                         p_manager);
#line 1895
      l_nb_bytes_read = (OPJ_UINT32 )__cil_tmp20;
      }
#line 1896
      if (l_nb_bytes_read != l_current_data_size) {
        {
#line 1897
        opj_event_msg(p_manager, 1, "Problem with reading JPEG2000 box, stream error\n\220");
#line 1898
        free(l_current_data);
        }
#line 1899
        return (0);
      }
      {
#line 1902
      __cil_tmp21 = (*(l_current_handler->handler))(jp2, l_current_data, l_current_data_size,
                                                    p_manager);
      }
#line 1902
      if (! __cil_tmp21) {
        {
#line 1903
        free(l_current_data);
        }
#line 1904
        return (0);
      }
    } else {
      {
#line 1908
      jp2->jp2_state |= (unsigned int )2147483647;
#line 1909
      __cil_tmp22 = opj_stream_skip(stream, (OPJ_OFF_T )l_current_data_size, p_manager);
      }
#line 1909
      if (__cil_tmp22 != (long )l_current_data_size) {
        {
#line 1910
        opj_event_msg(p_manager, 1, "Problem with skipping JPEG2000 box, stream error\n");
#line 1911
        free(l_current_data);
        }
#line 1912
        return (0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1917
  free(l_current_data);
  }
#line 1919
  return (1);
}
}
#line 1932 "/root/patron/new_21/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_exec(opj_jp2_t *jp2 , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL (**l_procedure)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ) ;
  OPJ_BOOL l_result ;
  OPJ_UINT32 l_nb_proc ;
  OPJ_UINT32 i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  OPJ_UINT32 __cil_tmp13 ;
  opj_procedure *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;

  {
  {
#line 1939
  l_procedure = (OPJ_BOOL (**)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ))0;
#line 1940
  l_result = 1;
#line 1949
  l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);
#line 1950
  __cil_tmp14 = opj_procedure_list_get_first_procedure(p_procedure_list);
#line 1950
  l_procedure = (OPJ_BOOL (**)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ))__cil_tmp14;
#line 1952
  i = (OPJ_UINT32 )0;
  }
  {
#line 1952
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1952
    if (! (i < l_nb_proc)) {
#line 1952
      goto while_break;
    }
    {
#line 1953
    __cil_tmp15 = (*(*l_procedure))(jp2, stream, p_manager);
#line 1953
    l_result = l_result && __cil_tmp15;
#line 1954
    l_procedure ++;
    }
#line 1952
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1958
  opj_procedure_list_clear(p_procedure_list);
  }
#line 1959
  return (l_result);
}
}
#line 1962 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_start_compress(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_image_t *p_image ,
                                opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;

  {
  {
#line 1974
  opj_jp2_setup_encoding_validation(jp2);
#line 1977
  __cil_tmp8 = opj_jp2_exec(jp2, jp2->m_validation_list, stream, p_manager);
  }
#line 1977
  if (! __cil_tmp8) {
#line 1978
    return (0);
  }
  {
#line 1982
  opj_jp2_setup_header_writing(jp2);
#line 1985
  __cil_tmp9 = opj_jp2_exec(jp2, jp2->m_procedure_list, stream, p_manager);
  }
#line 1985
  if (! __cil_tmp9) {
#line 1986
    return (0);
  }
  {
#line 1989
  __cil_tmp10 = opj_j2k_start_compress(jp2->j2k, stream, p_image, p_manager);
  }
#line 1989
  return (__cil_tmp10);
}
}
#line 1992 "/root/patron/new_21/src/lib/openjp2/jp2.c"
opj_jp2_header_handler_t *opj_jp2_find_handler(OPJ_UINT32 p_id ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_handler_size ;

  {
#line 1994
  l_handler_size = (OPJ_UINT32 )(sizeof(jp2_header) / sizeof(opj_jp2_header_handler_t ));
#line 1996
  i = (OPJ_UINT32 )0;
  {
#line 1996
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1996
    if (! (i < l_handler_size)) {
#line 1996
      goto while_break;
    }
#line 1997
    if (jp2_header[i].id == p_id) {
#line 1998
      return (& jp2_header[i]);
    }
#line 1996
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2001
  return ((opj_jp2_header_handler_t *)((void *)0));
}
}
#line 2011 "/root/patron/new_21/src/lib/openjp2/jp2.c"
static opj_jp2_header_handler_t *opj_jp2_img_find_handler(OPJ_UINT32 p_id ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_handler_size ;

  {
#line 2013
  l_handler_size = (OPJ_UINT32 )(sizeof(jp2_img_header) / sizeof(opj_jp2_header_handler_t ));
#line 2014
  i = (OPJ_UINT32 )0;
  {
#line 2014
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2014
    if (! (i < l_handler_size)) {
#line 2014
      goto while_break;
    }
#line 2016
    if (jp2_img_header[i].id == p_id) {
#line 2017
      return (& jp2_img_header[i]);
    }
#line 2014
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2021
  return ((opj_jp2_header_handler_t *)((void *)0));
}
}
#line 2034 "/root/patron/new_21/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_jp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_magic_number ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2048
  if (jp2->jp2_state != 0U) {
    {
#line 2049
    opj_event_msg(p_manager, 1, "The signature box must be the first box in the file.\n");
    }
#line 2050
    return (0);
  }
#line 2054
  if (p_header_size != 4U) {
    {
#line 2055
    opj_event_msg(p_manager, 1, "Error with JP signature Box size\n");
    }
#line 2056
    return (0);
  }
  {
#line 2060
  opj_read_bytes_LE(p_header_data, & l_magic_number, (OPJ_UINT32 )4);
  }
#line 2061
  if (l_magic_number != 218793738U) {
    {
#line 2062
    opj_event_msg(p_manager, 1, "Error with JP Signature : bad magic number\n");
    }
#line 2063
    return (0);
  }
#line 2066
  jp2->jp2_state |= (unsigned int )1;
#line 2068
  return (1);
}
}
#line 2081 "/root/patron/new_21/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_ftyp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_remaining_bytes ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp10 ;

  {
#line 2094
  if (jp2->jp2_state != 1U) {
    {
#line 2095
    opj_event_msg(p_manager, 1, "The ftyp box must be the second box in the file.\n");
    }
#line 2096
    return (0);
  }
#line 2100
  if (p_header_size < 8U) {
    {
#line 2101
    opj_event_msg(p_manager, 1, "Error with FTYP signature Box size\n");
    }
#line 2102
    return (0);
  }
  {
#line 2105
  opj_read_bytes_LE(p_header_data, & jp2->brand, (OPJ_UINT32 )4);
#line 2106
  p_header_data += 4;
#line 2108
  opj_read_bytes_LE(p_header_data, & jp2->minversion, (OPJ_UINT32 )4);
#line 2109
  p_header_data += 4;
#line 2111
  l_remaining_bytes = p_header_size - 8U;
  }
#line 2114
  if ((l_remaining_bytes & 3U) != 0U) {
    {
#line 2115
    opj_event_msg(p_manager, 1, "Error with FTYP signature Box size\n");
    }
#line 2116
    return (0);
  }
#line 2120
  jp2->numcl = l_remaining_bytes >> 2;
#line 2121
  if (jp2->numcl) {
    {
#line 2122
    __cil_tmp10 = calloc((unsigned long )jp2->numcl, sizeof(OPJ_UINT32 ));
#line 2122
    jp2->cl = (OPJ_UINT32 *)__cil_tmp10;
    }
#line 2123
    if (jp2->cl == (OPJ_UINT32 *)0) {
      {
#line 2124
      opj_event_msg(p_manager, 1, "Not enough memory with FTYP Box\n\220");
      }
#line 2125
      return (0);
    }
  }
#line 2129
  i = (OPJ_UINT32 )0;
  {
#line 2129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2129
    if (! (i < jp2->numcl)) {
#line 2129
      goto while_break;
    }
    {
#line 2131
    opj_read_bytes_LE(p_header_data, jp2->cl + i, (OPJ_UINT32 )4);
#line 2132
    p_header_data += 4;
    }
#line 2129
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2135
  jp2->jp2_state |= (unsigned int )2;
#line 2137
  return (1);
}
}
#line 2140 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_skip_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_OFF_T __cil_tmp7 ;
  OPJ_OFF_T __cil_tmp8 ;

  {
  {
#line 2149
  jp2->j2k_codestream_offset = opj_stream_tell(stream);
#line 2151
  __cil_tmp8 = opj_stream_skip(stream, (OPJ_OFF_T )8, p_manager);
  }
#line 2151
  if (__cil_tmp8 != 8L) {
#line 2152
    return (0);
  }
#line 2155
  return (1);
}
}
#line 2158 "/root/patron/new_21/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jpip_skip_iptr(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_OFF_T __cil_tmp7 ;
  OPJ_OFF_T __cil_tmp8 ;

  {
  {
#line 2167
  jp2->jpip_iptr_offset = opj_stream_tell(stream);
#line 2169
  __cil_tmp8 = opj_stream_skip(stream, (OPJ_OFF_T )24, p_manager);
  }
#line 2169
  if (__cil_tmp8 != 24L) {
#line 2170
    return (0);
  }
#line 2173
  return (1);
}
}
#line 2186 "/root/patron/new_21/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_jp2h(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_box_size ;
  OPJ_UINT32 l_current_data_size ;
  opj_jp2_box_t box ;
  opj_jp2_header_handler_t *l_current_handler ;
  OPJ_BOOL l_has_ihdr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BOOL __cil_tmp13 ;
  opj_jp2_header_handler_t *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;

  {
#line 2192
  l_box_size = (OPJ_UINT32 )0;
#line 2192
  l_current_data_size = (OPJ_UINT32 )0;
#line 2195
  l_has_ihdr = 0;
#line 2203
  if ((jp2->jp2_state & 2U) != 2U) {
    {
#line 2204
    opj_event_msg(p_manager, 1, "The  box must be the first box in the file.\n");
    }
#line 2205
    return (0);
  }
#line 2208
  jp2->jp2_img_state = (OPJ_UINT32 )0;
  {
#line 2211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2211
    if (! (p_header_size > 0U)) {
#line 2211
      goto while_break;
    }
    {
#line 2213
    __cil_tmp13 = opj_jp2_read_boxhdr_char(& box, p_header_data, & l_box_size, p_header_size,
                                           p_manager);
    }
#line 2213
    if (! __cil_tmp13) {
      {
#line 2214
      opj_event_msg(p_manager, 1, "Stream error while reading JP2 Header box\n");
      }
#line 2215
      return (0);
    }
#line 2218
    if (box.length > p_header_size) {
      {
#line 2219
      opj_event_msg(p_manager, 1, "Stream error while reading JP2 Header box: box length is inconsistent.\n");
      }
#line 2220
      return (0);
    }
    {
#line 2223
    l_current_handler = opj_jp2_img_find_handler(box.type);
#line 2224
    l_current_data_size = box.length - l_box_size;
#line 2225
    p_header_data += l_box_size;
    }
#line 2227
    if (l_current_handler != (opj_jp2_header_handler_t *)0) {
      {
#line 2228
      __cil_tmp15 = (*(l_current_handler->handler))(jp2, p_header_data, l_current_data_size,
                                                    p_manager);
      }
#line 2228
      if (! __cil_tmp15) {
#line 2229
        return (0);
      }
    } else {
#line 2233
      jp2->jp2_img_state |= (unsigned int )2147483647;
    }
#line 2236
    if (box.type == 1768449138U) {
#line 2237
      l_has_ihdr = 1;
    }
#line 2240
    p_header_data += l_current_data_size;
#line 2241
    p_header_size -= box.length;
  }
  while_break: /* CIL Label */ ;
  }
#line 2244
  if (l_has_ihdr == 0) {
    {
#line 2245
    opj_event_msg(p_manager, 1, "Stream error while reading JP2 Header box: no \'ihdr\' box.\n");
    }
#line 2246
    return (0);
  }
#line 2249
  jp2->jp2_state |= (unsigned int )4;
#line 2251
  return (1);
}
}
#line 2254 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_boxhdr_char(opj_jp2_box_t *box , OPJ_BYTE *p_data , OPJ_UINT32 *p_number_bytes_read ,
                                  OPJ_UINT32 p_box_max_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  OPJ_UINT32 l_xl_part_size ;

  {
#line 2269
  if (p_box_max_size < 8U) {
    {
#line 2270
    opj_event_msg(p_manager, 1, "Cannot handle box of less than 8 bytes\n");
    }
#line 2271
    return (0);
  }
  {
#line 2275
  opj_read_bytes_LE(p_data, & l_value, (OPJ_UINT32 )4);
#line 2276
  p_data += 4;
#line 2277
  box->length = (OPJ_UINT32 )l_value;
#line 2279
  opj_read_bytes_LE(p_data, & l_value, (OPJ_UINT32 )4);
#line 2280
  p_data += 4;
#line 2281
  box->type = (OPJ_UINT32 )l_value;
#line 2283
  *p_number_bytes_read = (OPJ_UINT32 )8;
  }
#line 2287
  if (box->length == 1U) {
#line 2290
    if (p_box_max_size < 16U) {
      {
#line 2291
      opj_event_msg(p_manager, 1, "Cannot handle XL box of less than 16 bytes\n");
      }
#line 2292
      return (0);
    }
    {
#line 2295
    opj_read_bytes_LE(p_data, & l_xl_part_size, (OPJ_UINT32 )4);
#line 2296
    p_data += 4;
#line 2297
    *p_number_bytes_read += (unsigned int )4;
    }
#line 2299
    if (l_xl_part_size != 0U) {
      {
#line 2300
      opj_event_msg(p_manager, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 2301
      return (0);
    }
    {
#line 2304
    opj_read_bytes_LE(p_data, & l_value, (OPJ_UINT32 )4);
#line 2305
    *p_number_bytes_read += (unsigned int )4;
#line 2306
    box->length = (OPJ_UINT32 )l_value;
    }
#line 2308
    if (box->length == 0U) {
      {
#line 2309
      opj_event_msg(p_manager, 1, "Cannot handle box of undefined sizes\n");
      }
#line 2310
      return (0);
    }
  } else
#line 2313
  if (box->length == 0U) {
    {
#line 2314
    opj_event_msg(p_manager, 1, "Cannot handle box of undefined sizes\n");
    }
#line 2315
    return (0);
  }
#line 2317
  if (box->length < *p_number_bytes_read) {
    {
#line 2318
    opj_event_msg(p_manager, 1, "Box length is inconsistent.\n");
    }
#line 2319
    return (0);
  }
#line 2321
  return (1);
}
}
#line 2324 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_header(opj_stream_private_t *p_stream , opj_jp2_t *jp2 , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;

  {
  {
#line 2336
  opj_jp2_setup_decoding_validation(jp2);
#line 2339
  opj_jp2_setup_header_reading(jp2);
#line 2342
  __cil_tmp8 = opj_jp2_exec(jp2, jp2->m_validation_list, p_stream, p_manager);
  }
#line 2342
  if (! __cil_tmp8) {
#line 2343
    return (0);
  }
  {
#line 2347
  __cil_tmp9 = opj_jp2_exec(jp2, jp2->m_procedure_list, p_stream, p_manager);
  }
#line 2347
  if (! __cil_tmp9) {
#line 2348
    return (0);
  }
  {
#line 2351
  __cil_tmp10 = opj_j2k_read_header(p_stream, jp2->j2k, p_image, p_manager);
  }
#line 2351
  return (__cil_tmp10);
}
}
#line 2357 "/root/patron/new_21/src/lib/openjp2/jp2.c"
void opj_jp2_setup_encoding_validation(opj_jp2_t *jp2 ) 
{ 
  int tmp ;

  {
  {
#line 2362
  opj_procedure_list_add_procedure(jp2->m_validation_list, (opj_procedure )(& opj_jp2_default_validation));
  }
  return;
}
}
#line 2366 "/root/patron/new_21/src/lib/openjp2/jp2.c"
void opj_jp2_setup_decoding_validation(opj_jp2_t *jp2 ) 
{ 
  int tmp ;

  {
  return;
}
}
#line 2373 "/root/patron/new_21/src/lib/openjp2/jp2.c"
void opj_jp2_setup_header_writing(opj_jp2_t *jp2 ) 
{ 
  int tmp ;

  {
  {
#line 2378
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jp2_write_jp));
#line 2379
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jp2_write_ftyp));
#line 2380
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jp2_write_jp2h));
  }
#line 2381
  if (jp2->jpip_on) {
    {
#line 2382
    opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jpip_skip_iptr));
    }
  }
  {
#line 2383
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jp2_skip_jp2c));
  }
  return;
}
}
#line 2389 "/root/patron/new_21/src/lib/openjp2/jp2.c"
void opj_jp2_setup_header_reading(opj_jp2_t *jp2 ) 
{ 
  int tmp ;

  {
  {
#line 2394
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jp2_read_header_procedure));
  }
  return;
}
}
#line 2398 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_tile_header(opj_jp2_t *p_jp2 , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 2411
  __cil_tmp12 = opj_j2k_read_tile_header(p_jp2->j2k, p_tile_index, p_data_size, p_tile_x0,
                                         p_tile_y0, p_tile_x1, p_tile_y1, p_nb_comps,
                                         p_go_on, p_stream, p_manager);
  }
#line 2411
  return (__cil_tmp12);
}
}
#line 2422 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;

  {
  {
#line 2431
  __cil_tmp7 = opj_j2k_write_tile(p_jp2->j2k, p_tile_index, p_data, p_data_size, p_stream,
                                  p_manager);
  }
#line 2431
  return (__cil_tmp7);
}
}
#line 2434 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_decode_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;

  {
  {
#line 2442
  __cil_tmp7 = opj_j2k_decode_tile(p_jp2->j2k, p_tile_index, p_data, p_data_size,
                                   p_stream, p_manager);
  }
#line 2442
  return (__cil_tmp7);
}
}
#line 2445 "/root/patron/new_21/src/lib/openjp2/jp2.c"
void opj_jp2_destroy(opj_jp2_t *jp2 ) 
{ 


  {
#line 2447
  if (jp2) {
    {
#line 2449
    opj_j2k_destroy(jp2->j2k);
#line 2450
    jp2->j2k = (opj_j2k_t *)0;
    }
#line 2452
    if (jp2->comps) {
      {
#line 2453
      free(jp2->comps);
#line 2454
      jp2->comps = (opj_jp2_comps_t *)0;
      }
    }
#line 2457
    if (jp2->cl) {
      {
#line 2458
      free(jp2->cl);
#line 2459
      jp2->cl = (OPJ_UINT32 *)0;
      }
    }
#line 2462
    if (jp2->color.icc_profile_buf) {
      {
#line 2463
      free(jp2->color.icc_profile_buf);
#line 2464
      jp2->color.icc_profile_buf = (OPJ_BYTE *)0;
      }
    }
#line 2467
    if (jp2->color.jp2_cdef) {
#line 2468
      if ((jp2->color.jp2_cdef)->info) {
        {
#line 2469
        free((jp2->color.jp2_cdef)->info);
#line 2470
        (jp2->color.jp2_cdef)->info = (opj_jp2_cdef_info_t *)((void *)0);
        }
      }
      {
#line 2473
      free(jp2->color.jp2_cdef);
#line 2474
      jp2->color.jp2_cdef = (opj_jp2_cdef_t *)0;
      }
    }
#line 2477
    if (jp2->color.jp2_pclr) {
#line 2478
      if ((jp2->color.jp2_pclr)->cmap) {
        {
#line 2479
        free((jp2->color.jp2_pclr)->cmap);
#line 2480
        (jp2->color.jp2_pclr)->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
        }
      }
#line 2482
      if ((jp2->color.jp2_pclr)->channel_sign) {
        {
#line 2483
        free((jp2->color.jp2_pclr)->channel_sign);
#line 2484
        (jp2->color.jp2_pclr)->channel_sign = (OPJ_BYTE *)((void *)0);
        }
      }
#line 2486
      if ((jp2->color.jp2_pclr)->channel_size) {
        {
#line 2487
        free((jp2->color.jp2_pclr)->channel_size);
#line 2488
        (jp2->color.jp2_pclr)->channel_size = (OPJ_BYTE *)((void *)0);
        }
      }
#line 2490
      if ((jp2->color.jp2_pclr)->entries) {
        {
#line 2491
        free((jp2->color.jp2_pclr)->entries);
#line 2492
        (jp2->color.jp2_pclr)->entries = (OPJ_UINT32 *)((void *)0);
        }
      }
      {
#line 2495
      free(jp2->color.jp2_pclr);
#line 2496
      jp2->color.jp2_pclr = (opj_jp2_pclr_t *)0;
      }
    }
#line 2499
    if (jp2->m_validation_list) {
      {
#line 2500
      opj_procedure_list_destroy(jp2->m_validation_list);
#line 2501
      jp2->m_validation_list = (struct opj_procedure_list *)0;
      }
    }
#line 2504
    if (jp2->m_procedure_list) {
      {
#line 2505
      opj_procedure_list_destroy(jp2->m_procedure_list);
#line 2506
      jp2->m_procedure_list = (struct opj_procedure_list *)0;
      }
    }
    {
#line 2509
    free(jp2);
    }
  }
  return;
}
}
#line 2513 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_decode_area(opj_jp2_t *p_jp2 , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 2520
  __cil_tmp8 = opj_j2k_set_decode_area(p_jp2->j2k, p_image, p_start_x, p_start_y,
                                       p_end_x, p_end_y, p_manager);
  }
#line 2520
  return (__cil_tmp8);
}
}
#line 2523 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_get_tile(opj_jp2_t *p_jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) 
{ 
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 2530
  if (! p_image) {
#line 2531
    return (0);
  }
  {
#line 2533
  opj_event_msg(p_manager, 2, "JP2 box which are after the codestream will not be read by this function.\n");
#line 2535
  __cil_tmp6 = opj_j2k_get_tile(p_jp2->j2k, p_stream, p_image, p_manager, tile_index);
  }
#line 2535
  if (! __cil_tmp6) {
    {
#line 2536
    opj_event_msg(p_manager, 1, "Failed to decode the codestream in the JP2 file\n\220");
    }
#line 2537
    return (0);
  }
  {
#line 2540
  __cil_tmp7 = opj_jp2_check_color(p_image, & p_jp2->color, p_manager);
  }
#line 2540
  if (! __cil_tmp7) {
#line 2541
    return (0);
  }
#line 2545
  if (p_jp2->enumcs == 16U) {
#line 2546
    p_image->color_space = (OPJ_COLOR_SPACE )1;
  } else
#line 2547
  if (p_jp2->enumcs == 17U) {
#line 2548
    p_image->color_space = (OPJ_COLOR_SPACE )2;
  } else
#line 2549
  if (p_jp2->enumcs == 18U) {
#line 2550
    p_image->color_space = (OPJ_COLOR_SPACE )3;
  } else {
#line 2552
    p_image->color_space = (OPJ_COLOR_SPACE )-1;
  }
#line 2555
  if (p_jp2->color.jp2_cdef) {
    {
#line 2556
    opj_jp2_apply_cdef(p_image, & p_jp2->color);
    }
  }
#line 2559
  if (p_jp2->color.jp2_pclr) {
#line 2561
    if (! (p_jp2->color.jp2_pclr)->cmap) {
      {
#line 2562
      opj_jp2_free_pclr(& p_jp2->color);
      }
    } else {
      {
#line 2564
      opj_jp2_apply_pclr(p_image, & p_jp2->color);
      }
    }
  }
#line 2567
  if (p_jp2->color.icc_profile_buf) {
#line 2568
    p_image->icc_profile_buf = p_jp2->color.icc_profile_buf;
#line 2569
    p_image->icc_profile_len = p_jp2->color.icc_profile_len;
#line 2570
    p_jp2->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
  }
#line 2573
  return (1);
}
}
#line 2580 "/root/patron/new_21/src/lib/openjp2/jp2.c"
opj_jp2_t *opj_jp2_create(OPJ_BOOL p_is_decoder ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_j2k_t *__cil_tmp5 ;
  opj_procedure_list_t *__cil_tmp6 ;
  opj_procedure_list_t *__cil_tmp7 ;

  {
  {
#line 2582
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_jp2_t ));
#line 2582
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 2583
  if (jp2) {
#line 2586
    if (! p_is_decoder) {
      {
#line 2587
      jp2->j2k = opj_j2k_create_compress();
      }
    } else {
      {
#line 2590
      jp2->j2k = opj_j2k_create_decompress();
      }
    }
#line 2593
    if (jp2->j2k == (opj_j2k_t *)0) {
      {
#line 2594
      opj_jp2_destroy(jp2);
      }
#line 2595
      return ((opj_jp2_t *)0);
    }
    {
#line 2599
    jp2->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 2600
    jp2->color.icc_profile_len = (OPJ_UINT32 )0;
#line 2601
    jp2->color.jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
#line 2602
    jp2->color.jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
#line 2603
    jp2->color.jp2_has_colr = (OPJ_BYTE )0;
#line 2606
    jp2->m_validation_list = opj_procedure_list_create();
    }
#line 2607
    if (! jp2->m_validation_list) {
      {
#line 2608
      opj_jp2_destroy(jp2);
      }
#line 2609
      return ((opj_jp2_t *)0);
    }
    {
#line 2613
    jp2->m_procedure_list = opj_procedure_list_create();
    }
#line 2614
    if (! jp2->m_procedure_list) {
      {
#line 2615
      opj_jp2_destroy(jp2);
      }
#line 2616
      return ((opj_jp2_t *)0);
    }
  }
#line 2620
  return (jp2);
}
}
#line 2623 "/root/patron/new_21/src/lib/openjp2/jp2.c"
void jp2_dump(opj_jp2_t *p_jp2 , OPJ_INT32 flag , FILE *out_stream ) 
{ 
  int tmp ;

  {
  {
#line 2628
  j2k_dump(p_jp2->j2k, flag, out_stream);
  }
  return;
}
}
#line 2633 "/root/patron/new_21/src/lib/openjp2/jp2.c"
opj_codestream_index_t *jp2_get_cstr_index(opj_jp2_t *p_jp2 ) 
{ 
  opj_codestream_index_t *__cil_tmp2 ;

  {
  {
#line 2635
  __cil_tmp2 = j2k_get_cstr_index(p_jp2->j2k);
  }
#line 2635
  return (__cil_tmp2);
}
}
#line 2638 "/root/patron/new_21/src/lib/openjp2/jp2.c"
opj_codestream_info_v2_t *jp2_get_cstr_info(opj_jp2_t *p_jp2 ) 
{ 
  opj_codestream_info_v2_t *__cil_tmp2 ;

  {
  {
#line 2640
  __cil_tmp2 = j2k_get_cstr_info(p_jp2->j2k);
  }
#line 2640
  return (__cil_tmp2);
}
}
#line 2643 "/root/patron/new_21/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_decoded_resolution_factor(opj_jp2_t *p_jp2 , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 2647
  __cil_tmp4 = opj_j2k_set_decoded_resolution_factor(p_jp2->j2k, res_factor, p_manager);
  }
#line 2647
  return (__cil_tmp4);
}
}
#line 54 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_setup_header_reading(opj_j2k_t *p_j2k ) ;
#line 59
OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                       opj_event_mgr_t *p_manager ) ;
#line 72
OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) ;
#line 85
OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) ;
#line 93
void opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k ) ;
#line 99
void opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k ) ;
#line 105
void opj_j2k_setup_end_compress(opj_j2k_t *p_j2k ) ;
#line 116
OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) ;
#line 123
OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                               opj_event_mgr_t *p_manager ) ;
#line 129
OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                               opj_event_mgr_t *p_manager ) ;
#line 140
static OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                   opj_event_mgr_t *p_manager ) ;
#line 154
OPJ_BOOL opj_j2k_exec(opj_j2k_t *p_j2k , opj_procedure_list_t *p_procedure_list ,
                      opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 166
OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) ;
#line 174
static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                                        opj_event_mgr_t *p_manager ) ;
#line 181
static OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) ;
#line 192
struct opj_dec_memory_marker_handler *opj_j2k_get_marker_handler(OPJ_UINT32 p_id ) ;
#line 199
void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp ) ;
#line 206
void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp ) ;
#line 213
void opj_j2k_cp_destroy(opj_cp_t *p_cp ) ;
#line 227
OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                   OPJ_BYTE *p_data , OPJ_UINT32 *p_header_size ,
                                   struct opj_event_mgr *p_manager ) ;
#line 243
OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                        OPJ_UINT32 p_comp_no ) ;
#line 255
OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 compno , OPJ_BYTE *p_header_data ,
                                  OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) ;
#line 270
OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ) ;
#line 285
OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                 OPJ_BYTE *p_data , OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) ;
#line 295
void opj_j2k_update_tlm(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_part_size ) ;
#line 307
OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_header_data ,
                                OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) ;
#line 318
void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k ) ;
#line 325
void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k ) ;
#line 330
OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) ;
#line 334
OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) ;
#line 339
OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data , opj_image_t *p_output_image ) ;
#line 341
void opj_j2k_get_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data ) ;
#line 343
OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 p_data_size ,
                                 opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 353
void opj_j2k_setup_header_writing(opj_j2k_t *p_j2k ) ;
#line 355
OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                       OPJ_UINT32 p_total_data_size , opj_stream_private_t *p_stream ,
                                       struct opj_event_mgr *p_manager ) ;
#line 362
OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                      OPJ_UINT32 p_total_data_size , opj_stream_private_t *p_stream ,
                                      struct opj_event_mgr *p_manager ) ;
#line 376
OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                struct opj_event_mgr *p_manager ) ;
#line 380
OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k ) ;
#line 395
OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 405
static OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) ;
#line 416
OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 427
static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 439
OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 450
static OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 461
OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 472
static OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 514
OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k ) ;
#line 523
static OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 535
OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 546
static OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 585
OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k ) ;
#line 594
static OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 605
OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 616
void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                 opj_event_mgr_t *p_manager ) ;
#line 623
OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k ) ;
#line 633
static OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 641
OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k ) ;
#line 648
OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k ) ;
#line 658
static OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 670
static OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 682
OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                   struct opj_event_mgr *p_manager ) ;
#line 694
static OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 706
static OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 728
OPJ_BOOL j2k_read_ppm_v3(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                         struct opj_event_mgr *p_manager ) ;
#line 742
static OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 753
OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 766
OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                           opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 780
OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                          opj_event_mgr_t *p_manager ) ;
#line 795
OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k , opj_tcd_t *p_tile_coder , OPJ_BYTE *p_data ,
                           OPJ_UINT32 *p_data_written , OPJ_UINT32 p_total_data_size ,
                           opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 810
OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 814 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_update_tlm(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_part_size ) 
{ 


  {
  {
#line 816
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                     p_j2k->m_current_tile_number, (OPJ_UINT32 )1);
#line 817
  (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current) ++;
#line 819
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                     p_tile_part_size, (OPJ_UINT32 )4);
#line 820
  p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current += 4;
  }
  return;
}
}
#line 833
OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                           OPJ_UINT32 nb_comps , opj_stream_private_t *p_stream ,
                           opj_event_mgr_t *p_manager ) ;
#line 848
static OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 860
OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 884
OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) ;
#line 895
OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) ;
#line 906
static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index , OPJ_UINT32 type ,
                                     OPJ_OFF_T pos , OPJ_UINT32 len ) ;
#line 915
static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno , opj_codestream_index_t *cstr_index ,
                                     OPJ_UINT32 type , OPJ_OFF_T pos , OPJ_UINT32 len ) ;
#line 927
OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , OPJ_UINT32 *output_marker ,
                          opj_event_mgr_t *p_manager ) ;
#line 940
OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k , opj_mct_data_t *p_mct_record ,
                                  struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) ;
#line 953
static OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 966
OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k , struct opj_simple_mcc_decorrelation_data *p_mcc_record ,
                                  struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) ;
#line 979
OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                          opj_event_mgr_t *p_manager ) ;
#line 991
OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) ;
#line 1003
static OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1008
OPJ_BOOL opj_j2k_add_mct(opj_tcp_t *p_tcp , opj_image_t *p_image , OPJ_UINT32 p_index ) ;
#line 1010
void opj_j2k_read_int16_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1011
void opj_j2k_read_int32_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1012
void opj_j2k_read_float32_to_float(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) ;
#line 1013
void opj_j2k_read_float64_to_float(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) ;
#line 1015
void opj_j2k_read_int16_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1016
void opj_j2k_read_int32_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1017
void opj_j2k_read_float32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) ;
#line 1018
void opj_j2k_read_float64_to_int32(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) ;
#line 1020
void opj_j2k_write_float_to_int16(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1021
void opj_j2k_write_float_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1022
void opj_j2k_write_float_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1023
void opj_j2k_write_float_to_float64(void const   *p_src_data , void *p_dest_data ,
                                    OPJ_UINT32 p_nb_elem ) ;
#line 1032
OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                              struct opj_event_mgr *p_manager ) ;
#line 1043
OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) ;
#line 1054
static OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1092
OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                               struct opj_event_mgr *p_manager ) ;
#line 1103
OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) ;
#line 1120
OPJ_BOOL opj_j2k_check_poc_val(opj_poc_t *p_pocs , OPJ_UINT32 p_nb_pocs , OPJ_UINT32 p_nb_resolutions ,
                               OPJ_UINT32 p_num_comps , OPJ_UINT32 p_num_layers ,
                               opj_event_mgr_t *p_manager ) ;
#line 1136
OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp , OPJ_UINT32 pino , OPJ_UINT32 tileno ) ;
#line 1150
OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k , opj_cp_t *cp , OPJ_UINT32 *p_nb_tiles ,
                              opj_image_t *image , opj_event_mgr_t *p_manager ) ;
#line 1156
void opj_j2k_dump_MH_info(opj_j2k_t *p_j2k , FILE *out_stream ) ;
#line 1158
void opj_j2k_dump_MH_index(opj_j2k_t *p_j2k , FILE *out_stream ) ;
#line 1160
opj_codestream_index_t *opj_j2k_create_cstr_index(void) ;
#line 1162
OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t *p_tcp ) ;
#line 1164
OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t *p_tcp ) ;
#line 1166
int opj_j2k_initialise_4K_poc(opj_poc_t *POC , int numres ) ;
#line 1168
void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                   opj_event_mgr_t *p_manager ) ;
#line 1170
OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image , OPJ_UINT16 rsiz , opj_event_mgr_t *p_manager ) ;
#line 1182 "/root/patron/new_21/src/lib/openjp2/j2k.c"
j2k_prog_order_t j2k_prog_order_list[6]  = {      {(OPJ_PROG_ORDER )4, {"CPRL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )0, {"LRCP", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )3, {"PCRL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )1, {"RLCP", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )2, {"RPCL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )(- 1), {"\250", (char )0, (char )0, (char )0, (char )0}}};
#line 1194 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_UINT32 MCT_ELEMENT_SIZE[4]  = {      (OPJ_UINT32 )2,      (OPJ_UINT32 )4,      (OPJ_UINT32 )4,      (OPJ_UINT32 )8};
#line 1204 "/root/patron/new_21/src/lib/openjp2/j2k.c"
opj_j2k_mct_function j2k_mct_read_functions_to_float[4]  = {      & opj_j2k_read_int16_to_float,      & opj_j2k_read_int32_to_float,      & opj_j2k_read_float32_to_float,      & opj_j2k_read_float64_to_float};
#line 1212 "/root/patron/new_21/src/lib/openjp2/j2k.c"
opj_j2k_mct_function j2k_mct_read_functions_to_int32[4]  = {      & opj_j2k_read_int16_to_int32,      & opj_j2k_read_int32_to_int32,      & opj_j2k_read_float32_to_int32,      & opj_j2k_read_float64_to_int32};
#line 1220 "/root/patron/new_21/src/lib/openjp2/j2k.c"
opj_j2k_mct_function j2k_mct_write_functions_from_float[4]  = {      & opj_j2k_write_float_to_int16,      & opj_j2k_write_float_to_int32,      & opj_j2k_write_float_to_float,      & opj_j2k_write_float_to_float64};
#line 1242 "/root/patron/new_21/src/lib/openjp2/j2k.c"
opj_dec_memory_marker_handler_t j2k_memory_marker_handler_tab[21]  = 
#line 1242
  {      {(OPJ_UINT32 )65424, (OPJ_UINT32 )12, & opj_j2k_read_sot}, 
        {(OPJ_UINT32 )65362, (OPJ_UINT32 )20, & opj_j2k_read_cod}, 
        {(OPJ_UINT32 )65363, (OPJ_UINT32 )20, & opj_j2k_read_coc}, 
        {(OPJ_UINT32 )65374, (OPJ_UINT32 )20, & opj_j2k_read_rgn}, 
        {(OPJ_UINT32 )65372, (OPJ_UINT32 )20, & opj_j2k_read_qcd}, 
        {(OPJ_UINT32 )65373, (OPJ_UINT32 )20, & opj_j2k_read_qcc}, 
        {(OPJ_UINT32 )65375, (OPJ_UINT32 )20, & opj_j2k_read_poc}, 
        {(OPJ_UINT32 )65361, (OPJ_UINT32 )2, & opj_j2k_read_siz}, 
        {(OPJ_UINT32 )65365, (OPJ_UINT32 )4, & opj_j2k_read_tlm}, 
        {(OPJ_UINT32 )65367, (OPJ_UINT32 )4, & opj_j2k_read_plm}, 
        {(OPJ_UINT32 )65368, (OPJ_UINT32 )16, & opj_j2k_read_plt}, 
        {(OPJ_UINT32 )65376, (OPJ_UINT32 )4, & j2k_read_ppm_v3}, 
        {(OPJ_UINT32 )65377, (OPJ_UINT32 )16, & opj_j2k_read_ppt}, 
        {(OPJ_UINT32 )65425, (OPJ_UINT32 )0, (OPJ_BOOL (*)(opj_j2k_t * , OPJ_BYTE * ,
                                                        OPJ_UINT32  , opj_event_mgr_t * ))0}, 
        {(OPJ_UINT32 )65379,
      (OPJ_UINT32 )4, & opj_j2k_read_crg}, 
        {(OPJ_UINT32 )65380, (OPJ_UINT32 )20, & opj_j2k_read_com}, 
        {(OPJ_UINT32 )65396, (OPJ_UINT32 )20, & opj_j2k_read_mct}, 
        {(OPJ_UINT32 )65400, (OPJ_UINT32 )4, & opj_j2k_read_cbd}, 
        {(OPJ_UINT32 )65397, (OPJ_UINT32 )20, & opj_j2k_read_mcc}, 
        {(OPJ_UINT32 )65399, (OPJ_UINT32 )20, & opj_j2k_read_mco}, 
        {(OPJ_UINT32 )0, (OPJ_UINT32 )20, (OPJ_BOOL (*)(opj_j2k_t * , OPJ_BYTE * , OPJ_UINT32  ,
                                                     opj_event_mgr_t * ))0}};
#line 1279 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_read_int16_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1281
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1282
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1286
  i = (OPJ_UINT32 )0;
  {
#line 1286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1286
    if (! (i < p_nb_elem)) {
#line 1286
      goto while_break;
    }
    {
#line 1287
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )2);
#line 1289
    l_src_data += sizeof(OPJ_INT16 );
#line 1291
    __cil_tmp8 = l_dest_data;
#line 1291
    l_dest_data ++;
#line 1291
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
    }
#line 1286
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1295 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_read_int32_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1297
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1298
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1302
  i = (OPJ_UINT32 )0;
  {
#line 1302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1302
    if (! (i < p_nb_elem)) {
#line 1302
      goto while_break;
    }
    {
#line 1303
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )4);
#line 1305
    l_src_data += sizeof(OPJ_INT32 );
#line 1307
    __cil_tmp8 = l_dest_data;
#line 1307
    l_dest_data ++;
#line 1307
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
    }
#line 1302
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1311 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_read_float32_to_float(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1313
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1314
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1318
  i = (OPJ_UINT32 )0;
  {
#line 1318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1318
    if (! (i < p_nb_elem)) {
#line 1318
      goto while_break;
    }
    {
#line 1319
    opj_read_float_LE(l_src_data, & l_temp);
#line 1321
    l_src_data += sizeof(OPJ_FLOAT32 );
#line 1323
    __cil_tmp8 = l_dest_data;
#line 1323
    l_dest_data ++;
#line 1323
    *__cil_tmp8 = l_temp;
    }
#line 1318
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1327 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_read_float64_to_float(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1329
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1330
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1334
  i = (OPJ_UINT32 )0;
  {
#line 1334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1334
    if (! (i < p_nb_elem)) {
#line 1334
      goto while_break;
    }
    {
#line 1335
    opj_read_double_LE(l_src_data, & l_temp);
#line 1337
    l_src_data += sizeof(OPJ_FLOAT64 );
#line 1339
    __cil_tmp8 = l_dest_data;
#line 1339
    l_dest_data ++;
#line 1339
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
    }
#line 1334
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1343 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_read_int16_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1345
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1346
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1350
  i = (OPJ_UINT32 )0;
  {
#line 1350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1350
    if (! (i < p_nb_elem)) {
#line 1350
      goto while_break;
    }
    {
#line 1351
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )2);
#line 1353
    l_src_data += sizeof(OPJ_INT16 );
#line 1355
    __cil_tmp8 = l_dest_data;
#line 1355
    l_dest_data ++;
#line 1355
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
    }
#line 1350
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1359 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_read_int32_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1361
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1362
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1366
  i = (OPJ_UINT32 )0;
  {
#line 1366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1366
    if (! (i < p_nb_elem)) {
#line 1366
      goto while_break;
    }
    {
#line 1367
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )4);
#line 1369
    l_src_data += sizeof(OPJ_INT32 );
#line 1371
    __cil_tmp8 = l_dest_data;
#line 1371
    l_dest_data ++;
#line 1371
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
    }
#line 1366
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1375 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_read_float32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1377
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1378
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1382
  i = (OPJ_UINT32 )0;
  {
#line 1382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1382
    if (! (i < p_nb_elem)) {
#line 1382
      goto while_break;
    }
    {
#line 1383
    opj_read_float_LE(l_src_data, & l_temp);
#line 1385
    l_src_data += sizeof(OPJ_FLOAT32 );
#line 1387
    __cil_tmp8 = l_dest_data;
#line 1387
    l_dest_data ++;
#line 1387
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
    }
#line 1382
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1391 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_read_float64_to_int32(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1393
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1394
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1398
  i = (OPJ_UINT32 )0;
  {
#line 1398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1398
    if (! (i < p_nb_elem)) {
#line 1398
      goto while_break;
    }
    {
#line 1399
    opj_read_double_LE(l_src_data, & l_temp);
#line 1401
    l_src_data += sizeof(OPJ_FLOAT64 );
#line 1403
    __cil_tmp8 = l_dest_data;
#line 1403
    l_dest_data ++;
#line 1403
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
    }
#line 1398
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1407 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_write_float_to_int16(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1409
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1410
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1414
  i = (OPJ_UINT32 )0;
  {
#line 1414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1414
    if (! (i < p_nb_elem)) {
#line 1414
      goto while_break;
    }
    {
#line 1415
    __cil_tmp8 = l_src_data;
#line 1415
    l_src_data ++;
#line 1415
    l_temp = (OPJ_UINT32 )*__cil_tmp8;
#line 1417
    opj_write_bytes_LE(l_dest_data, l_temp, (OPJ_UINT32 )sizeof(OPJ_INT16 ));
#line 1419
    l_dest_data += sizeof(OPJ_INT16 );
    }
#line 1414
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1423 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_write_float_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1425
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1426
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1430
  i = (OPJ_UINT32 )0;
  {
#line 1430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1430
    if (! (i < p_nb_elem)) {
#line 1430
      goto while_break;
    }
    {
#line 1431
    __cil_tmp8 = l_src_data;
#line 1431
    l_src_data ++;
#line 1431
    l_temp = (OPJ_UINT32 )*__cil_tmp8;
#line 1433
    opj_write_bytes_LE(l_dest_data, l_temp, (OPJ_UINT32 )sizeof(OPJ_INT32 ));
#line 1435
    l_dest_data += sizeof(OPJ_INT32 );
    }
#line 1430
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1439 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_write_float_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1441
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1442
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1446
  i = (OPJ_UINT32 )0;
  {
#line 1446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1446
    if (! (i < p_nb_elem)) {
#line 1446
      goto while_break;
    }
    {
#line 1447
    __cil_tmp8 = l_src_data;
#line 1447
    l_src_data ++;
#line 1447
    l_temp = (OPJ_FLOAT32 )*__cil_tmp8;
#line 1449
    opj_write_float_LE(l_dest_data, l_temp);
#line 1451
    l_dest_data += sizeof(OPJ_FLOAT32 );
    }
#line 1446
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1455 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_write_float_to_float64(void const   *p_src_data , void *p_dest_data ,
                                    OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1457
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1458
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1462
  i = (OPJ_UINT32 )0;
  {
#line 1462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1462
    if (! (i < p_nb_elem)) {
#line 1462
      goto while_break;
    }
    {
#line 1463
    __cil_tmp8 = l_src_data;
#line 1463
    l_src_data ++;
#line 1463
    l_temp = (OPJ_FLOAT64 )*__cil_tmp8;
#line 1465
    opj_write_double_LE(l_dest_data, l_temp);
#line 1467
    l_dest_data += sizeof(OPJ_FLOAT64 );
    }
#line 1462
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1471 "/root/patron/new_21/src/lib/openjp2/j2k.c"
char *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) 
{ 
  j2k_prog_order_t *po ;
  j2k_prog_order_t *__cil_tmp3 ;

  {
#line 1473
  po = (j2k_prog_order_t *)j2k_prog_order_list;
  {
#line 1473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1473
    if (! ((int )po->enum_prog != -1)) {
#line 1473
      goto while_break;
    }
#line 1474
    if ((int )po->enum_prog == (int )prg_order) {
#line 1475
      return ((char *)po->str_prog);
    }
#line 1473
    po ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1478
  return ((char *)po->str_prog);
}
}
#line 1481 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_check_poc_val(opj_poc_t *p_pocs , OPJ_UINT32 p_nb_pocs , OPJ_UINT32 p_nb_resolutions ,
                               OPJ_UINT32 p_num_comps , OPJ_UINT32 p_num_layers ,
                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 *packet_array ;
  OPJ_UINT32 index___9 ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 i ;
  OPJ_UINT32 step_c ;
  OPJ_UINT32 step_r ;
  OPJ_UINT32 step_l ;
  OPJ_BOOL loss ;
  OPJ_UINT32 layno0 ;
  void *__cil_tmp18 ;
  OPJ_UINT32 res_index ;
  OPJ_UINT32 comp_index ;
  OPJ_UINT32 l_last_layno1 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 res_index___0 ;
  OPJ_UINT32 comp_index___0 ;

  {
  {
#line 1491
  step_c = (OPJ_UINT32 )1;
#line 1492
  step_r = p_num_comps * step_c;
#line 1493
  step_l = p_nb_resolutions * step_r;
#line 1494
  loss = 0;
#line 1495
  layno0 = (OPJ_UINT32 )0;
#line 1497
  __cil_tmp18 = calloc((unsigned long )(step_l * p_num_layers), sizeof(OPJ_UINT32 ));
#line 1497
  packet_array = (OPJ_UINT32 *)__cil_tmp18;
  }
#line 1498
  if (packet_array == (OPJ_UINT32 *)0) {
    {
#line 1499
    opj_event_msg(p_manager, 1, "Not enough memory for checking the poc values.\n");
    }
#line 1500
    return (0);
  }
#line 1503
  if (p_nb_pocs == 0U) {
    {
#line 1504
    free(packet_array);
    }
#line 1505
    return (1);
  }
#line 1508
  index___9 = step_r * p_pocs->resno0;
#line 1510
  resno = p_pocs->resno0;
  {
#line 1510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1510
    if (! (resno < p_pocs->resno1)) {
#line 1510
      goto while_break;
    }
#line 1512
    res_index = index___9 + p_pocs->compno0 * step_c;
#line 1515
    compno = p_pocs->compno0;
    {
#line 1515
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1515
      if (! (compno < p_pocs->compno1)) {
#line 1515
        goto while_break___0;
      }
#line 1516
      comp_index = res_index + layno0 * step_l;
#line 1519
      layno = layno0;
      {
#line 1519
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1519
        if (! (layno < p_pocs->layno1)) {
#line 1519
          goto while_break___1;
        }
#line 1521
        *(packet_array + comp_index) = (OPJ_UINT32 )1;
#line 1522
        comp_index += step_l;
#line 1519
        layno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1525
      res_index += step_c;
#line 1515
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1528
    index___9 += step_r;
#line 1510
    resno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1530
  p_pocs ++;
#line 1533
  i = (OPJ_UINT32 )1;
  {
#line 1533
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1533
    if (! (i < p_nb_pocs)) {
#line 1533
      goto while_break___2;
    }
#line 1534
    l_last_layno1 = (p_pocs - 1)->layno1;
#line 1536
    if (p_pocs->layno1 > l_last_layno1) {
#line 1536
      tmp = l_last_layno1;
    } else {
#line 1536
      tmp = (unsigned int )0;
    }
#line 1536
    layno0 = tmp;
#line 1537
    index___9 = step_r * p_pocs->resno0;
#line 1540
    resno = p_pocs->resno0;
    {
#line 1540
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1540
      if (! (resno < p_pocs->resno1)) {
#line 1540
        goto while_break___3;
      }
#line 1541
      res_index___0 = index___9 + p_pocs->compno0 * step_c;
#line 1544
      compno = p_pocs->compno0;
      {
#line 1544
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1544
        if (! (compno < p_pocs->compno1)) {
#line 1544
          goto while_break___4;
        }
#line 1545
        comp_index___0 = res_index___0 + layno0 * step_l;
#line 1548
        layno = layno0;
        {
#line 1548
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1548
          if (! (layno < p_pocs->layno1)) {
#line 1548
            goto while_break___5;
          }
#line 1550
          *(packet_array + comp_index___0) = (OPJ_UINT32 )1;
#line 1551
          comp_index___0 += step_l;
#line 1548
          layno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1554
        res_index___0 += step_c;
#line 1544
        compno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1557
      index___9 += step_r;
#line 1540
      resno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1560
    p_pocs ++;
#line 1533
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1563
  index___9 = (OPJ_UINT32 )0;
#line 1564
  layno = (OPJ_UINT32 )0;
  {
#line 1564
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1564
    if (! (layno < p_num_layers)) {
#line 1564
      goto while_break___6;
    }
#line 1565
    resno = (OPJ_UINT32 )0;
    {
#line 1565
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1565
      if (! (resno < p_nb_resolutions)) {
#line 1565
        goto while_break___7;
      }
#line 1566
      compno = (OPJ_UINT32 )0;
      {
#line 1566
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1566
        if (! (compno < p_num_comps)) {
#line 1566
          goto while_break___8;
        }
#line 1567
        loss |= *(packet_array + index___9) != 1U;
#line 1569
        index___9 += step_c;
#line 1566
        compno ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1565
      resno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1564
    layno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1574
  if (loss) {
    {
#line 1575
    opj_event_msg(p_manager, 1, "Missing packets possible loss of data\n");
    }
  }
  {
#line 1578
  free(packet_array);
  }
#line 1580
  return (! loss);
}
}
#line 1585 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp , OPJ_UINT32 pino , OPJ_UINT32 tileno ) 
{ 
  OPJ_CHAR *prog ;
  OPJ_INT32 i ;
  OPJ_UINT32 tpnum ;
  opj_tcp_t *tcp ;
  opj_poc_t *l_current_poc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int tmp___3 ;

  {
  {
#line 1587
  prog = (OPJ_CHAR *)0;
#line 1589
  tpnum = (OPJ_UINT32 )1;
#line 1590
  tcp = (opj_tcp_t *)0;
#line 1591
  l_current_poc = (opj_poc_t *)0;
#line 1598
  tcp = cp->tcps + tileno;
#line 1601
  l_current_poc = & tcp->pocs[pino];
#line 1605
  prog = opj_j2k_convert_progression_order(tcp->prg);
  }
#line 1608
  if ((int )cp->m_specific_param.m_enc.m_tp_on == 1) {
#line 1609
    i = 0;
    {
#line 1609
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1609
      if (! (i < 4)) {
#line 1609
        goto while_break;
      }
      {
#line 1613
      if ((int )*(prog + i) == 'C') {
#line 1613
        goto case_67;
      }
#line 1617
      if ((int )*(prog + i) == 'R') {
#line 1617
        goto case_82;
      }
#line 1621
      if ((int )*(prog + i) == 'P') {
#line 1621
        goto case_80;
      }
#line 1625
      if ((int )*(prog + i) == 'L') {
#line 1625
        goto case_76;
      }
#line 1610
      goto switch_break;
      case_67: /* CIL Label */ 
#line 1614
      tpnum *= l_current_poc->compE;
#line 1615
      goto switch_break;
      case_82: /* CIL Label */ 
#line 1618
      tpnum *= l_current_poc->resE;
#line 1619
      goto switch_break;
      case_80: /* CIL Label */ 
#line 1622
      tpnum *= l_current_poc->prcE;
#line 1623
      goto switch_break;
      case_76: /* CIL Label */ 
#line 1626
      tpnum *= l_current_poc->layE;
#line 1627
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1630
      if ((int )cp->m_specific_param.m_enc.m_tp_flag == (int )*(prog + i)) {
#line 1631
        cp->m_specific_param.m_enc.m_tp_pos = i;
#line 1632
        goto while_break;
      }
#line 1609
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1637
    tpnum = (OPJ_UINT32 )1;
  }
#line 1640
  return (tpnum);
}
}
#line 1643 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k , opj_cp_t *cp , OPJ_UINT32 *p_nb_tiles ,
                              opj_image_t *image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 tileno ;
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *tcp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  OPJ_UINT32 cur_totnum_tp ;
  OPJ_UINT32 tp_num ;
  OPJ_UINT32 __cil_tmp17 ;

  {
#line 1661
  l_nb_tiles = cp->tw * cp->th;
#line 1662
  *p_nb_tiles = (OPJ_UINT32 )0;
#line 1663
  tcp = cp->tcps;
#line 1700
  tileno = (OPJ_UINT32 )0;
  {
#line 1700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1700
    if (! (tileno < l_nb_tiles)) {
#line 1700
      goto while_break;
    }
    {
#line 1701
    cur_totnum_tp = (OPJ_UINT32 )0;
#line 1703
    opj_pi_update_encoding_parameters(image, cp, tileno);
#line 1705
    pino = (OPJ_UINT32 )0;
    }
    {
#line 1705
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1705
      if (! (pino <= tcp->numpocs)) {
#line 1705
        goto while_break___0;
      }
      {
#line 1706
      __cil_tmp17 = opj_j2k_get_num_tp(cp, pino, tileno);
#line 1706
      tp_num = __cil_tmp17;
#line 1708
      *p_nb_tiles += tp_num;
#line 1710
      cur_totnum_tp += tp_num;
      }
#line 1705
      pino ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1712
    tcp->m_nb_tile_parts = cur_totnum_tp;
#line 1714
    tcp ++;
#line 1700
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1718
  return (1);
}
}
#line 1721 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_start_stream ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_SIZE_T __cil_tmp8 ;

  {
  {
#line 1726
  l_start_stream = (OPJ_BYTE *)0;
#line 1733
  l_start_stream = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 1736
  opj_write_bytes_LE(l_start_stream, (OPJ_UINT32 )65359, (OPJ_UINT32 )2);
#line 1738
  __cil_tmp8 = opj_stream_write_data(p_stream, l_start_stream, (OPJ_SIZE_T )2, p_manager);
  }
#line 1738
  if (__cil_tmp8 != 2UL) {
#line 1739
    return (0);
  }
#line 1752
  return (1);
}
}
#line 1761 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_data[2] ;
  OPJ_UINT32 l_marker ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_SIZE_T __cil_tmp9 ;
  OPJ_OFF_T __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 1774
  __cil_tmp9 = opj_stream_read_data(p_stream, (OPJ_BYTE *)l_data, (OPJ_SIZE_T )2,
                                    p_manager);
  }
#line 1774
  if (__cil_tmp9 != 2UL) {
#line 1775
    return (0);
  }
  {
#line 1778
  opj_read_bytes_LE((OPJ_BYTE *)l_data, & l_marker, (OPJ_UINT32 )2);
  }
#line 1779
  if (l_marker != 65359U) {
#line 1780
    return (0);
  }
  {
#line 1784
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )2;
#line 1787
  __cil_tmp10 = opj_stream_tell(p_stream);
#line 1787
  (p_j2k->cstr_index)->main_head_start = __cil_tmp10 - 2L;
#line 1789
  opj_event_msg(p_manager, 4, "Start to read j2k main header (%d).\n\347U", (p_j2k->cstr_index)->main_head_start);
#line 1792
  __cil_tmp11 = opj_j2k_add_mhmarker(p_j2k->cstr_index, (OPJ_UINT32 )65359, (p_j2k->cstr_index)->main_head_start,
                                     (OPJ_UINT32 )2);
  }
#line 1792
  if (0 == __cil_tmp11) {
    {
#line 1793
    opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n");
    }
#line 1794
    return (0);
  }
#line 1796
  return (1);
}
}
#line 1799 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_size_len ;
  OPJ_BYTE *l_current_ptr ;
  opj_image_t *l_image ;
  opj_cp_t *cp ;
  opj_image_comp_t *l_img_comp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;

  {
#line 1806
  l_image = (opj_image_t *)0;
#line 1807
  cp = (opj_cp_t *)0;
#line 1808
  l_img_comp = (opj_image_comp_t *)0;
#line 1815
  l_image = p_j2k->m_private_image;
#line 1816
  cp = & p_j2k->m_cp;
#line 1817
  l_size_len = 40U + 3U * l_image->numcomps;
#line 1818
  l_img_comp = l_image->comps;
#line 1820
  if (l_size_len > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 1822
    __cil_tmp14 = realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (unsigned long )l_size_len);
#line 1822
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp14;
    }
#line 1823
    if (! new_header_tile_data) {
      {
#line 1824
      free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 1825
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 1826
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 1827
      opj_event_msg(p_manager, 1, "Not enough memory for the SIZ marker\n");
      }
#line 1828
      return (0);
    }
#line 1830
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 1831
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_size_len;
  }
  {
#line 1834
  l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 1837
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )65361, (OPJ_UINT32 )2);
#line 1838
  l_current_ptr += 2;
#line 1840
  opj_write_bytes_LE(l_current_ptr, l_size_len - 2U, (OPJ_UINT32 )2);
#line 1841
  l_current_ptr += 2;
#line 1843
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )cp->rsiz, (OPJ_UINT32 )2);
#line 1844
  l_current_ptr += 2;
#line 1846
  opj_write_bytes_LE(l_current_ptr, l_image->x1, (OPJ_UINT32 )4);
#line 1847
  l_current_ptr += 4;
#line 1849
  opj_write_bytes_LE(l_current_ptr, l_image->y1, (OPJ_UINT32 )4);
#line 1850
  l_current_ptr += 4;
#line 1852
  opj_write_bytes_LE(l_current_ptr, l_image->x0, (OPJ_UINT32 )4);
#line 1853
  l_current_ptr += 4;
#line 1855
  opj_write_bytes_LE(l_current_ptr, l_image->y0, (OPJ_UINT32 )4);
#line 1856
  l_current_ptr += 4;
#line 1858
  opj_write_bytes_LE(l_current_ptr, cp->tdx, (OPJ_UINT32 )4);
#line 1859
  l_current_ptr += 4;
#line 1861
  opj_write_bytes_LE(l_current_ptr, cp->tdy, (OPJ_UINT32 )4);
#line 1862
  l_current_ptr += 4;
#line 1864
  opj_write_bytes_LE(l_current_ptr, cp->tx0, (OPJ_UINT32 )4);
#line 1865
  l_current_ptr += 4;
#line 1867
  opj_write_bytes_LE(l_current_ptr, cp->ty0, (OPJ_UINT32 )4);
#line 1868
  l_current_ptr += 4;
#line 1870
  opj_write_bytes_LE(l_current_ptr, l_image->numcomps, (OPJ_UINT32 )2);
#line 1871
  l_current_ptr += 2;
#line 1873
  i = (OPJ_UINT32 )0;
  }
  {
#line 1873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1873
    if (! (i < l_image->numcomps)) {
#line 1873
      goto while_break;
    }
    {
#line 1875
    opj_write_bytes_LE(l_current_ptr, (l_img_comp->prec - 1U) + (l_img_comp->sgnd << 7),
                       (OPJ_UINT32 )1);
#line 1876
    l_current_ptr ++;
#line 1878
    opj_write_bytes_LE(l_current_ptr, l_img_comp->dx, (OPJ_UINT32 )1);
#line 1879
    l_current_ptr ++;
#line 1881
    opj_write_bytes_LE(l_current_ptr, l_img_comp->dy, (OPJ_UINT32 )1);
#line 1882
    l_current_ptr ++;
#line 1884
    l_img_comp ++;
    }
#line 1873
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1887
  __cil_tmp15 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_size_len, p_manager);
  }
#line 1887
  if (__cil_tmp15 != (unsigned long )l_size_len) {
#line 1888
    return (0);
  }
#line 1891
  return (1);
}
}
#line 1901 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_comp_remain ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_tmp ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcp_t *l_current_tile_param ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp18 ;
  OPJ_UINT32 tmp___2 ;
  OPJ_INT32 __cil_tmp20 ;
  OPJ_INT32 __cil_tmp21 ;
  OPJ_INT32 __cil_tmp22 ;
  OPJ_INT32 __cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;

  {
#line 1913
  l_image = (opj_image_t *)0;
#line 1914
  l_cp = (opj_cp_t *)0;
#line 1915
  l_img_comp = (opj_image_comp_t *)0;
#line 1916
  l_current_tile_param = (opj_tcp_t *)0;
#line 1923
  l_image = p_j2k->m_private_image;
#line 1924
  l_cp = & p_j2k->m_cp;
#line 1927
  if (p_header_size < 36U) {
    {
#line 1928
    opj_event_msg(p_manager, 1, "Error with SIZ marker size\n");
    }
#line 1929
    return (0);
  }
#line 1932
  l_remaining_size = p_header_size - 36U;
#line 1933
  l_nb_comp = l_remaining_size / 3U;
#line 1934
  l_nb_comp_remain = l_remaining_size % 3U;
#line 1935
  if (l_nb_comp_remain != 0U) {
    {
#line 1936
    opj_event_msg(p_manager, 1, "Error with SIZ marker size\ni\347U");
    }
#line 1937
    return (0);
  }
  {
#line 1940
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 1941
  p_header_data += 2;
#line 1942
  l_cp->rsiz = (OPJ_UINT16 )l_tmp;
#line 1943
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_image->x1), (OPJ_UINT32 )4);
#line 1944
  p_header_data += 4;
#line 1945
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_image->y1), (OPJ_UINT32 )4);
#line 1946
  p_header_data += 4;
#line 1947
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_image->x0), (OPJ_UINT32 )4);
#line 1948
  p_header_data += 4;
#line 1949
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_image->y0), (OPJ_UINT32 )4);
#line 1950
  p_header_data += 4;
#line 1951
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_cp->tdx), (OPJ_UINT32 )4);
#line 1952
  p_header_data += 4;
#line 1953
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_cp->tdy), (OPJ_UINT32 )4);
#line 1954
  p_header_data += 4;
#line 1955
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_cp->tx0), (OPJ_UINT32 )4);
#line 1956
  p_header_data += 4;
#line 1957
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_cp->ty0), (OPJ_UINT32 )4);
#line 1958
  p_header_data += 4;
#line 1959
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_tmp), (OPJ_UINT32 )2);
#line 1960
  p_header_data += 2;
  }
#line 1961
  if (l_tmp < 16385U) {
#line 1962
    l_image->numcomps = (OPJ_UINT32 )((OPJ_UINT16 )l_tmp);
  } else {
    {
#line 1964
    opj_event_msg(p_manager, 1, "Error with SIZ marker: number of component is illegal -> %d\n\347U",
                  l_tmp);
    }
#line 1965
    return (0);
  }
#line 1968
  if (l_image->numcomps != l_nb_comp) {
    {
#line 1969
    opj_event_msg(p_manager, 1, "Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\n\325ui\347U",
                  l_image->numcomps, l_nb_comp);
    }
#line 1970
    return (0);
  }
#line 1974
  if (l_image->x0 > l_image->x1) {
    {
    {
#line 1975
    opj_event_msg(p_manager, 1, "Error with SIZ marker: negative image size (%d x %d)\nU",
                  l_image->x1 - l_image->x0, l_image->y1 - l_image->y0);
    }
    }
#line 1976
    return (0);
  } else
#line 1974
  if (l_image->y0 > l_image->y1) {
    {
    {
#line 1975
    opj_event_msg(p_manager, 1, "Error with SIZ marker: negative image size (%d x %d)\nU",
                  l_image->x1 - l_image->x0, l_image->y1 - l_image->y0);
    }
    }
#line 1976
    return (0);
  }
#line 1979
  if (! (l_cp->tdx * l_cp->tdy)) {
    {
#line 1980
    opj_event_msg(p_manager, 1, "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n\347U",
                  l_cp->tdx, l_cp->tdy);
    }
#line 1981
    return (0);
  }
#line 1985
  if ((OPJ_UINT64 )l_image->x1 * (OPJ_UINT64 )l_image->y1 != (unsigned long )(l_image->x1 * l_image->y1)) {
    {
#line 1986
    opj_event_msg(p_manager, 1, "Prevent buffer overflow (x1: %d, y1: %d)\n_vi\347U",
                  l_image->x1, l_image->y1);
    }
#line 1987
    return (0);
  }
  {
#line 2033
  __cil_tmp18 = calloc((unsigned long )l_image->numcomps, sizeof(opj_image_comp_t ));
#line 2033
  l_image->comps = (opj_image_comp_t *)__cil_tmp18;
  }
#line 2034
  if (l_image->comps == (opj_image_comp_t *)0) {
    {
#line 2035
    l_image->numcomps = (OPJ_UINT32 )0;
#line 2036
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2037
    return (0);
  }
#line 2040
  l_img_comp = l_image->comps;
#line 2043
  i = (OPJ_UINT32 )0;
  {
#line 2043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2043
    if (! (i < l_image->numcomps)) {
#line 2043
      goto while_break;
    }
    {
#line 2045
    opj_read_bytes_LE(p_header_data, & tmp___2, (OPJ_UINT32 )1);
#line 2046
    p_header_data ++;
#line 2047
    l_img_comp->prec = (tmp___2 & 127U) + 1U;
#line 2048
    l_img_comp->sgnd = tmp___2 >> 7;
#line 2049
    opj_read_bytes_LE(p_header_data, & tmp___2, (OPJ_UINT32 )1);
#line 2050
    p_header_data ++;
#line 2051
    l_img_comp->dx = (OPJ_UINT32 )tmp___2;
#line 2052
    opj_read_bytes_LE(p_header_data, & tmp___2, (OPJ_UINT32 )1);
#line 2053
    p_header_data ++;
#line 2054
    l_img_comp->dy = (OPJ_UINT32 )tmp___2;
    }
#line 2055
    if (l_img_comp->dx < 1U) {
      {
      {
      {
      {
#line 2057
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u\n (should be between 1 and 255 according the JPEG2000 norm)",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
      }
      }
      }
#line 2060
      return (0);
    } else
#line 2055
    if (l_img_comp->dx > 255U) {
      {
      {
      {
      {
#line 2057
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u\n (should be between 1 and 255 according the JPEG2000 norm)",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
      }
      }
      }
#line 2060
      return (0);
    } else
#line 2055
    if (l_img_comp->dy < 1U) {
      {
      {
      {
      {
#line 2057
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u\n (should be between 1 and 255 according the JPEG2000 norm)",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
      }
      }
      }
#line 2060
      return (0);
    } else
#line 2055
    if (l_img_comp->dy > 255U) {
      {
      {
      {
      {
#line 2057
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u\n (should be between 1 and 255 according the JPEG2000 norm)",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
      }
      }
      }
#line 2060
      return (0);
    }
#line 2090
    l_img_comp->resno_decoded = (OPJ_UINT32 )0;
#line 2091
    l_img_comp->factor = l_cp->m_specific_param.m_dec.m_reduce;
#line 2092
    l_img_comp ++;
#line 2043
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2096
  __cil_tmp20 = opj_int_ceildiv((OPJ_INT32 )(l_image->x1 - l_cp->tx0), (OPJ_INT32 )l_cp->tdx);
#line 2096
  l_cp->tw = (OPJ_UINT32 )__cil_tmp20;
#line 2097
  __cil_tmp21 = opj_int_ceildiv((OPJ_INT32 )(l_image->y1 - l_cp->ty0), (OPJ_INT32 )l_cp->tdy);
#line 2097
  l_cp->th = (OPJ_UINT32 )__cil_tmp21;
  }
#line 2100
  if (l_cp->tw == 0U) {
    {
    {
    {
#line 2101
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
    }
    }
#line 2104
    return (0);
  } else
#line 2100
  if (l_cp->th == 0U) {
    {
    {
    {
#line 2101
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
    }
    }
#line 2104
    return (0);
  } else
#line 2100
  if (l_cp->tw > 65535U / l_cp->th) {
    {
    {
    {
#line 2101
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
    }
    }
#line 2104
    return (0);
  }
#line 2106
  l_nb_tiles = l_cp->tw * l_cp->th;
#line 2109
  if (p_j2k->m_specific_param.m_decoder.m_discard_tiles) {
    {
#line 2110
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (p_j2k->m_specific_param.m_decoder.m_start_tile_x - l_cp->tx0) / l_cp->tdx;
#line 2111
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (p_j2k->m_specific_param.m_decoder.m_start_tile_y - l_cp->ty0) / l_cp->tdy;
#line 2112
    __cil_tmp22 = opj_int_ceildiv((OPJ_INT32 )(p_j2k->m_specific_param.m_decoder.m_end_tile_x - l_cp->tx0),
                                  (OPJ_INT32 )l_cp->tdx);
#line 2112
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32 )__cil_tmp22;
#line 2113
    __cil_tmp23 = opj_int_ceildiv((OPJ_INT32 )(p_j2k->m_specific_param.m_decoder.m_end_tile_y - l_cp->ty0),
                                  (OPJ_INT32 )l_cp->tdy);
#line 2113
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32 )__cil_tmp23;
    }
  } else {
#line 2116
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 2117
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 2118
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 2119
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
  }
  {
#line 2163
  __cil_tmp24 = calloc((unsigned long )l_nb_tiles, sizeof(opj_tcp_t ));
#line 2163
  l_cp->tcps = (opj_tcp_t *)__cil_tmp24;
  }
#line 2164
  if (l_cp->tcps == (opj_tcp_t *)0) {
    {
#line 2165
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2166
    return (0);
  }
  {
#line 2182
  __cil_tmp25 = calloc((unsigned long )l_image->numcomps, sizeof(opj_tccp_t ));
#line 2182
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps = (opj_tccp_t *)__cil_tmp25;
  }
#line 2184
  if ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps == (opj_tccp_t *)0) {
    {
#line 2185
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2186
    return (0);
  }
  {
#line 2189
  __cil_tmp26 = calloc((unsigned long )10, sizeof(opj_mct_data_t ));
#line 2189
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mct_records = (opj_mct_data_t *)__cil_tmp26;
  }
#line 2192
  if (! (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mct_records) {
    {
#line 2193
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2194
    return (0);
  }
  {
#line 2196
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_nb_max_mct_records = (OPJ_UINT32 )10;
#line 2198
  __cil_tmp27 = calloc((unsigned long )10, sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 2198
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp27;
  }
#line 2202
  if (! (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mcc_records) {
    {
#line 2203
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2204
    return (0);
  }
#line 2206
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_nb_max_mcc_records = (OPJ_UINT32 )10;
#line 2209
  i = (OPJ_UINT32 )0;
  {
#line 2209
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2209
    if (! (i < l_image->numcomps)) {
#line 2209
      goto while_break___0;
    }
#line 2210
    if (! (l_image->comps + i)->sgnd) {
#line 2211
      ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps + i)->m_dc_level_shift = 1 << ((l_image->comps + i)->prec - 1U);
    }
#line 2209
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2215
  l_current_tile_param = l_cp->tcps;
#line 2216
  i = (OPJ_UINT32 )0;
  {
#line 2216
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2216
    if (! (i < l_nb_tiles)) {
#line 2216
      goto while_break___1;
    }
    {
#line 2217
    __cil_tmp28 = calloc((unsigned long )l_image->numcomps, sizeof(opj_tccp_t ));
#line 2217
    l_current_tile_param->tccps = (opj_tccp_t *)__cil_tmp28;
    }
#line 2218
    if (l_current_tile_param->tccps == (opj_tccp_t *)0) {
      {
#line 2219
      opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
      }
#line 2220
      return (0);
    }
#line 2223
    l_current_tile_param ++;
#line 2216
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2226
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )4;
#line 2227
  opj_image_comp_header_update(l_image, l_cp);
  }
#line 2229
  return (1);
}
}
#line 2232 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_comment_size ;
  OPJ_UINT32 l_total_com_size ;
  OPJ_CHAR *l_comment ;
  OPJ_BYTE *l_current_ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long __cil_tmp11 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 2240
  l_current_ptr = (OPJ_BYTE *)0;
#line 2247
  l_comment = p_j2k->m_cp.comment;
#line 2248
  __cil_tmp11 = strlen(l_comment);
#line 2248
  l_comment_size = (OPJ_UINT32 )__cil_tmp11;
#line 2249
  l_total_com_size = l_comment_size + 6U;
  }
#line 2251
  if (l_total_com_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2252
    __cil_tmp13 = realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (unsigned long )l_total_com_size);
#line 2252
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp13;
    }
#line 2253
    if (! new_header_tile_data) {
      {
#line 2254
      free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2255
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2256
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2257
      opj_event_msg(p_manager, 1, "Not enough memory to write the COM marker\nvi\347U");
      }
#line 2258
      return (0);
    }
#line 2260
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2261
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_total_com_size;
  }
  {
#line 2264
  l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2266
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )65380, (OPJ_UINT32 )2);
#line 2267
  l_current_ptr += 2;
#line 2269
  opj_write_bytes_LE(l_current_ptr, l_total_com_size - 2U, (OPJ_UINT32 )2);
#line 2270
  l_current_ptr += 2;
#line 2272
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )1, (OPJ_UINT32 )2);
#line 2273
  l_current_ptr += 2;
#line 2275
  memcpy(l_current_ptr, l_comment, (unsigned long )l_comment_size);
#line 2277
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_total_com_size, p_manager);
  }
#line 2277
  if (__cil_tmp14 != (unsigned long )l_total_com_size) {
#line 2278
    return (0);
  }
#line 2281
  return (1);
}
}
#line 2291 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2303
  return (1);
}
}
#line 2306 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_code_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
  {
#line 2310
  l_cp = (opj_cp_t *)0;
#line 2311
  l_tcp = (opj_tcp_t *)0;
#line 2313
  l_current_data = (OPJ_BYTE *)0;
#line 2320
  l_cp = & p_j2k->m_cp;
#line 2321
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 2322
  __cil_tmp12 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, p_j2k->m_current_tile_number,
                                             (OPJ_UINT32 )0);
#line 2322
  l_code_size = 9U + __cil_tmp12;
#line 2323
  l_remaining_size = l_code_size;
  }
#line 2325
  if (l_code_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2326
    __cil_tmp14 = realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (unsigned long )l_code_size);
#line 2326
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp14;
    }
#line 2327
    if (! new_header_tile_data) {
      {
#line 2328
      free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2329
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2330
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2331
      opj_event_msg(p_manager, 1, "Not enough memory to write COD marker\n");
      }
#line 2332
      return (0);
    }
#line 2334
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2335
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_code_size;
  }
  {
#line 2338
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2340
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65362, (OPJ_UINT32 )2);
#line 2341
  l_current_data += 2;
#line 2343
  opj_write_bytes_LE(l_current_data, l_code_size - 2U, (OPJ_UINT32 )2);
#line 2344
  l_current_data += 2;
#line 2346
  opj_write_bytes_LE(l_current_data, l_tcp->csty, (OPJ_UINT32 )1);
#line 2347
  l_current_data ++;
#line 2349
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_tcp->prg, (OPJ_UINT32 )1);
#line 2350
  l_current_data ++;
#line 2352
  opj_write_bytes_LE(l_current_data, l_tcp->numlayers, (OPJ_UINT32 )2);
#line 2353
  l_current_data += 2;
#line 2355
  opj_write_bytes_LE(l_current_data, l_tcp->mct, (OPJ_UINT32 )1);
#line 2356
  l_current_data ++;
#line 2358
  l_remaining_size -= (unsigned int )9;
#line 2360
  __cil_tmp15 = opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0,
                                          l_current_data, & l_remaining_size, p_manager);
  }
#line 2360
  if (! __cil_tmp15) {
    {
#line 2361
    opj_event_msg(p_manager, 1, "Error writing COD marker\n|wi\347U");
    }
#line 2362
    return (0);
  }
#line 2365
  if (l_remaining_size != 0U) {
    {
#line 2366
    opj_event_msg(p_manager, 1, "Error writing COD marker\n\022[i\347U");
    }
#line 2367
    return (0);
  }
  {
#line 2370
  __cil_tmp16 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_code_size, p_manager);
  }
#line 2370
  if (__cil_tmp16 != (unsigned long )l_code_size) {
#line 2371
    return (0);
  }
#line 2374
  return (1);
}
}
#line 2384 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_tmp ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_image_t *l_image ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  opj_tcp_t *tmp___2 ;
  OPJ_BOOL __cil_tmp14 ;

  {
#line 2393
  l_cp = (opj_cp_t *)0;
#line 2394
  l_tcp = (opj_tcp_t *)0;
#line 2395
  l_image = (opj_image_t *)0;
#line 2402
  l_image = p_j2k->m_private_image;
#line 2403
  l_cp = & p_j2k->m_cp;
#line 2406
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 2406
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 2406
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 2406
  l_tcp = tmp___2;
#line 2411
  if (p_header_size < 5U) {
    {
#line 2412
    opj_event_msg(p_manager, 1, "Error reading COD marker\n\214wi\347U");
    }
#line 2413
    return (0);
  }
  {
#line 2416
  opj_read_bytes_LE(p_header_data, & l_tcp->csty, (OPJ_UINT32 )1);
#line 2417
  p_header_data ++;
  }
#line 2419
  if ((l_tcp->csty & 4294967288U) != 0U) {
    {
#line 2420
    opj_event_msg(p_manager, 1, "Unknown Scod value in COD marker\n\032vi\347U");
    }
#line 2421
    return (0);
  }
  {
#line 2423
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 2424
  p_header_data ++;
#line 2425
  l_tcp->prg = (OPJ_PROG_ORDER )l_tmp;
  }
#line 2427
  if ((int )l_tcp->prg > 4) {
    {
#line 2428
    opj_event_msg(p_manager, 1, "Unknown progression order in COD marker\n\220");
#line 2429
    l_tcp->prg = (OPJ_PROG_ORDER )-1;
    }
  }
  {
#line 2431
  opj_read_bytes_LE(p_header_data, & l_tcp->numlayers, (OPJ_UINT32 )2);
#line 2432
  p_header_data += 2;
  }
#line 2435
  if (l_cp->m_specific_param.m_dec.m_layer) {
#line 2436
    l_tcp->num_layers_to_decode = l_cp->m_specific_param.m_dec.m_layer;
  } else {
#line 2439
    l_tcp->num_layers_to_decode = l_tcp->numlayers;
  }
  {
#line 2442
  opj_read_bytes_LE(p_header_data, & l_tcp->mct, (OPJ_UINT32 )1);
#line 2443
  p_header_data ++;
#line 2445
  p_header_size -= (unsigned int )5;
#line 2446
  i = (OPJ_UINT32 )0;
  }
  {
#line 2446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2446
    if (! (i < l_image->numcomps)) {
#line 2446
      goto while_break;
    }
#line 2447
    (l_tcp->tccps + i)->csty = l_tcp->csty & 1U;
#line 2446
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2450
  __cil_tmp14 = opj_j2k_read_SPCod_SPCoc(p_j2k, (OPJ_UINT32 )0, p_header_data, & p_header_size,
                                         p_manager);
  }
#line 2450
  if (! __cil_tmp14) {
    {
#line 2451
    opj_event_msg(p_manager, 1, "Error reading COD marker\n7wi\347U");
    }
#line 2452
    return (0);
  }
#line 2455
  if (p_header_size != 0U) {
    {
#line 2456
    opj_event_msg(p_manager, 1, "Error reading COD marker\n");
    }
#line 2457
    return (0);
  }
  {
#line 2461
  opj_j2k_copy_tile_component_parameters(p_j2k);
  }
#line 2476
  return (1);
}
}
#line 2573 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;

  {
#line 2578
  l_max = (OPJ_UINT32 )0;
#line 2582
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 2583
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 2585
  i = (OPJ_UINT32 )0;
  {
#line 2585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2585
    if (! (i < l_nb_tiles)) {
#line 2585
      goto while_break;
    }
#line 2586
    j = (OPJ_UINT32 )0;
    {
#line 2586
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2586
      if (! (j < l_nb_comp)) {
#line 2586
        goto while_break___0;
      }
      {
#line 2587
      __cil_tmp7 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, i, j);
#line 2587
      __cil_tmp8 = opj_uint_max(l_max, __cil_tmp7);
#line 2587
      l_max = __cil_tmp8;
      }
#line 2586
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2585
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2591
  return (6U + l_max);
}
}
#line 2601 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_comp_room ;
  OPJ_UINT32 l_comp_no ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  opj_tcp_t *tmp___2 ;
  int tmp___3 ;
  OPJ_BOOL __cil_tmp15 ;

  {
#line 2607
  l_cp = (opj_cp_t *)((void *)0);
#line 2608
  l_tcp = (opj_tcp_t *)((void *)0);
#line 2609
  l_image = (opj_image_t *)((void *)0);
#line 2618
  l_cp = & p_j2k->m_cp;
#line 2619
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 2619
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 2619
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 2619
  l_tcp = tmp___2;
#line 2622
  l_image = p_j2k->m_private_image;
#line 2624
  if (l_image->numcomps <= 256U) {
#line 2624
    tmp___3 = 1;
  } else {
#line 2624
    tmp___3 = 2;
  }
#line 2624
  l_comp_room = (OPJ_UINT32 )tmp___3;
#line 2627
  if (p_header_size < l_comp_room + 1U) {
    {
#line 2628
    opj_event_msg(p_manager, 1, "Error reading COC marker\n\332wi\347U");
    }
#line 2629
    return (0);
  }
  {
#line 2631
  p_header_size -= l_comp_room + 1U;
#line 2633
  opj_read_bytes_LE(p_header_data, & l_comp_no, l_comp_room);
#line 2634
  p_header_data += l_comp_room;
  }
#line 2635
  if (l_comp_no >= l_image->numcomps) {
    {
#line 2636
    opj_event_msg(p_manager, 1, "Error reading COC marker (bad number of components)\n");
    }
#line 2637
    return (0);
  }
  {
#line 2640
  opj_read_bytes_LE(p_header_data, & (l_tcp->tccps + l_comp_no)->csty, (OPJ_UINT32 )1);
#line 2641
  p_header_data ++;
#line 2643
  __cil_tmp15 = opj_j2k_read_SPCod_SPCoc(p_j2k, l_comp_no, p_header_data, & p_header_size,
                                         p_manager);
  }
#line 2643
  if (! __cil_tmp15) {
    {
#line 2644
    opj_event_msg(p_manager, 1, "Error reading COC marker\n~wi\347U");
    }
#line 2645
    return (0);
  }
#line 2648
  if (p_header_size != 0U) {
    {
#line 2649
    opj_event_msg(p_manager, 1, "Error reading COC marker\n");
    }
#line 2650
    return (0);
  }
#line 2652
  return (1);
}
}
#line 2655 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_qcd_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 2661
  l_current_data = (OPJ_BYTE *)0;
#line 2668
  __cil_tmp10 = opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0);
#line 2668
  l_qcd_size = 4U + __cil_tmp10;
#line 2669
  l_remaining_size = l_qcd_size;
  }
#line 2671
  if (l_qcd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2672
    __cil_tmp12 = realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (unsigned long )l_qcd_size);
#line 2672
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp12;
    }
#line 2673
    if (! new_header_tile_data) {
      {
#line 2674
      free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2675
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2676
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2677
      opj_event_msg(p_manager, 1, "Not enough memory to write QCD marker\n");
      }
#line 2678
      return (0);
    }
#line 2680
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2681
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcd_size;
  }
  {
#line 2684
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2686
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65372, (OPJ_UINT32 )2);
#line 2687
  l_current_data += 2;
#line 2689
  opj_write_bytes_LE(l_current_data, l_qcd_size - 2U, (OPJ_UINT32 )2);
#line 2690
  l_current_data += 2;
#line 2692
  l_remaining_size -= (unsigned int )4;
#line 2694
  __cil_tmp13 = opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0,
                                        l_current_data, & l_remaining_size, p_manager);
  }
#line 2694
  if (! __cil_tmp13) {
    {
#line 2695
    opj_event_msg(p_manager, 1, "Error writing QCD marker\n\316wi\347U");
    }
#line 2696
    return (0);
  }
#line 2699
  if (l_remaining_size != 0U) {
    {
#line 2700
    opj_event_msg(p_manager, 1, "Error writing QCD marker\n\037xi\347U");
    }
#line 2701
    return (0);
  }
  {
#line 2704
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_qcd_size, p_manager);
  }
#line 2704
  if (__cil_tmp14 != (unsigned long )l_qcd_size) {
#line 2705
    return (0);
  }
#line 2708
  return (1);
}
}
#line 2718 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 2729
  __cil_tmp8 = opj_j2k_read_SQcd_SQcc(p_j2k, (OPJ_UINT32 )0, p_header_data, & p_header_size,
                                      p_manager);
  }
#line 2729
  if (! __cil_tmp8) {
    {
#line 2730
    opj_event_msg(p_manager, 1, "Error reading QCD marker\n");
    }
#line 2731
    return (0);
  }
#line 2734
  if (p_header_size != 0U) {
    {
#line 2735
    opj_event_msg(p_manager, 1, "Error reading QCD marker\n");
    }
#line 2736
    return (0);
  }
  {
#line 2740
  opj_j2k_copy_tile_quantization_parameters(p_j2k);
  }
#line 2742
  return (1);
}
}
#line 2837 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
  {
#line 2839
  __cil_tmp2 = opj_j2k_get_max_coc_size(p_j2k);
  }
#line 2839
  return (__cil_tmp2);
}
}
#line 2849 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_num_comp ;
  OPJ_UINT32 l_comp_no ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BOOL __cil_tmp10 ;

  {
#line 2862
  l_num_comp = (p_j2k->m_private_image)->numcomps;
#line 2864
  if (l_num_comp <= 256U) {
#line 2865
    if (p_header_size < 1U) {
      {
#line 2866
      opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
      }
#line 2867
      return (0);
    }
    {
#line 2869
    opj_read_bytes_LE(p_header_data, & l_comp_no, (OPJ_UINT32 )1);
#line 2870
    p_header_data ++;
#line 2871
    p_header_size --;
    }
  } else {
#line 2874
    if (p_header_size < 2U) {
      {
#line 2875
      opj_event_msg(p_manager, 1, "Error reading QCC marker\nL\001");
      }
#line 2876
      return (0);
    }
    {
#line 2878
    opj_read_bytes_LE(p_header_data, & l_comp_no, (OPJ_UINT32 )2);
#line 2879
    p_header_data += 2;
#line 2880
    p_header_size -= (unsigned int )2;
    }
  }
#line 2909
  if (l_comp_no >= (p_j2k->m_private_image)->numcomps) {
    {
#line 2910
    opj_event_msg(p_manager, 1, "Invalid component number: %d, regarding the number of components %d\nM",
                  l_comp_no, (p_j2k->m_private_image)->numcomps);
    }
#line 2913
    return (0);
  }
  {
#line 2916
  __cil_tmp10 = opj_j2k_read_SQcd_SQcc(p_j2k, l_comp_no, p_header_data, & p_header_size,
                                       p_manager);
  }
#line 2916
  if (! __cil_tmp10) {
    {
#line 2917
    opj_event_msg(p_manager, 1, "Error reading QCC marker\n\347\001");
    }
#line 2918
    return (0);
  }
#line 2921
  if (p_header_size != 0U) {
    {
#line 2922
    opj_event_msg(p_manager, 1, "Error reading QCC marker\n\365\001");
    }
#line 2923
    return (0);
  }
#line 2926
  return (1);
}
}
#line 2929 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_poc ;
  OPJ_UINT32 l_poc_size ;
  OPJ_UINT32 l_written_size ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_poc_room ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;

  {
#line 2937
  l_written_size = (OPJ_UINT32 )0;
#line 2938
  l_tcp = (opj_tcp_t *)0;
#line 2946
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 2947
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 2948
  l_nb_poc = 1U + l_tcp->numpocs;
#line 2950
  if (l_nb_comp <= 256U) {
#line 2951
    l_poc_room = (OPJ_UINT32 )1;
  } else {
#line 2954
    l_poc_room = (OPJ_UINT32 )2;
  }
#line 2956
  l_poc_size = 4U + (5U + 2U * l_poc_room) * l_nb_poc;
#line 2958
  if (l_poc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2959
    __cil_tmp14 = realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (unsigned long )l_poc_size);
#line 2959
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp14;
    }
#line 2960
    if (! new_header_tile_data) {
      {
#line 2961
      free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2962
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2963
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2964
      opj_event_msg(p_manager, 1, "Not enough memory to write POC marker\n");
      }
#line 2965
      return (0);
    }
#line 2967
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2968
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_poc_size;
  }
  {
#line 2971
  opj_j2k_write_poc_in_memory(p_j2k, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              & l_written_size, p_manager);
#line 2973
  __cil_tmp15 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_poc_size, p_manager);
  }
#line 2973
  if (__cil_tmp15 != (unsigned long )l_poc_size) {
#line 2974
    return (0);
  }
#line 2977
  return (1);
}
}
#line 2980 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_poc ;
  OPJ_UINT32 l_poc_size ;
  opj_image_t *l_image ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_poc_t *l_current_poc ;
  OPJ_UINT32 l_poc_room ;
  int tmp ;
  int tmp___0 ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;

  {
#line 2987
  l_current_data = (OPJ_BYTE *)0;
#line 2991
  l_image = (opj_image_t *)0;
#line 2992
  l_tcp = (opj_tcp_t *)0;
#line 2993
  l_tccp = (opj_tccp_t *)0;
#line 2994
  l_current_poc = (opj_poc_t *)0;
#line 3001
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 3002
  l_tccp = l_tcp->tccps + 0;
#line 3003
  l_image = p_j2k->m_private_image;
#line 3004
  l_nb_comp = l_image->numcomps;
#line 3005
  l_nb_poc = 1U + l_tcp->numpocs;
#line 3007
  if (l_nb_comp <= 256U) {
#line 3008
    l_poc_room = (OPJ_UINT32 )1;
  } else {
#line 3011
    l_poc_room = (OPJ_UINT32 )2;
  }
  {
#line 3014
  l_poc_size = 4U + (5U + 2U * l_poc_room) * l_nb_poc;
#line 3016
  l_current_data = p_data;
#line 3018
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65375, (OPJ_UINT32 )2);
#line 3019
  l_current_data += 2;
#line 3021
  opj_write_bytes_LE(l_current_data, l_poc_size - 2U, (OPJ_UINT32 )2);
#line 3022
  l_current_data += 2;
#line 3024
  l_current_poc = (opj_poc_t *)l_tcp->pocs;
#line 3025
  i = (OPJ_UINT32 )0;
  }
  {
#line 3025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3025
    if (! (i < l_nb_poc)) {
#line 3025
      goto while_break;
    }
    {
#line 3026
    opj_write_bytes_LE(l_current_data, l_current_poc->resno0, (OPJ_UINT32 )1);
#line 3027
    l_current_data ++;
#line 3029
    opj_write_bytes_LE(l_current_data, l_current_poc->compno0, l_poc_room);
#line 3030
    l_current_data += l_poc_room;
#line 3032
    opj_write_bytes_LE(l_current_data, l_current_poc->layno1, (OPJ_UINT32 )2);
#line 3033
    l_current_data += 2;
#line 3035
    opj_write_bytes_LE(l_current_data, l_current_poc->resno1, (OPJ_UINT32 )1);
#line 3036
    l_current_data ++;
#line 3038
    opj_write_bytes_LE(l_current_data, l_current_poc->compno1, l_poc_room);
#line 3039
    l_current_data += l_poc_room;
#line 3041
    opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_current_poc->prg, (OPJ_UINT32 )1);
#line 3042
    l_current_data ++;
#line 3045
    __cil_tmp17 = opj_int_min((OPJ_INT32 )l_current_poc->layno1, (OPJ_INT32 )l_tcp->numlayers);
#line 3045
    l_current_poc->layno1 = (OPJ_UINT32 )__cil_tmp17;
#line 3046
    __cil_tmp18 = opj_int_min((OPJ_INT32 )l_current_poc->resno1, (OPJ_INT32 )l_tccp->numresolutions);
#line 3046
    l_current_poc->resno1 = (OPJ_UINT32 )__cil_tmp18;
#line 3047
    __cil_tmp19 = opj_int_min((OPJ_INT32 )l_current_poc->compno1, (OPJ_INT32 )l_nb_comp);
#line 3047
    l_current_poc->compno1 = (OPJ_UINT32 )__cil_tmp19;
#line 3049
    l_current_poc ++;
    }
#line 3025
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3052
  *p_data_written = l_poc_size;
  return;
}
}
#line 3055 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k ) 
{ 
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max_poc ;
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp6 ;

  {
#line 3057
  l_tcp = (opj_tcp_t *)0;
#line 3058
  l_nb_tiles = (OPJ_UINT32 )0;
#line 3059
  l_max_poc = (OPJ_UINT32 )0;
#line 3062
  l_tcp = p_j2k->m_cp.tcps;
#line 3063
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 3065
  i = (OPJ_UINT32 )0;
  {
#line 3065
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3065
    if (! (i < l_nb_tiles)) {
#line 3065
      goto while_break;
    }
    {
#line 3066
    l_max_poc = opj_uint_max(l_max_poc, l_tcp->numpocs);
#line 3067
    l_tcp ++;
    }
#line 3065
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3070
  l_max_poc ++;
#line 3072
  return (4U + 9U * l_max_poc);
}
}
#line 3075 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 __cil_tmp6 ;

  {
#line 3079
  l_max = (OPJ_UINT32 )0;
#line 3080
  l_tcp = (opj_tcp_t *)0;
#line 3082
  l_tcp = p_j2k->m_cp.tcps;
#line 3083
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 3085
  i = (OPJ_UINT32 )0;
  {
#line 3085
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3085
    if (! (i < l_nb_tiles)) {
#line 3085
      goto while_break;
    }
    {
#line 3086
    l_max = opj_uint_max(l_max, l_tcp->m_nb_tile_parts);
#line 3088
    l_tcp ++;
    }
#line 3085
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3091
  return (12U * l_max);
}
}
#line 3094 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_coc_bytes ;
  OPJ_UINT32 l_qcc_bytes ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;
  OPJ_UINT32 __cil_tmp9 ;

  {
  {
#line 3096
  l_nb_bytes = (OPJ_UINT32 )0;
#line 3100
  l_nb_comps = (p_j2k->m_private_image)->numcomps - 1U;
#line 3101
  __cil_tmp6 = opj_j2k_get_max_toc_size(p_j2k);
  }
#line 3101
  l_nb_bytes += __cil_tmp6;
#line 3103
  if (! ((int )p_j2k->m_cp.rsiz >= 3 && (int )p_j2k->m_cp.rsiz <= 6)) {
    {
#line 3104
    l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k);
#line 3105
    l_nb_bytes += l_nb_comps * l_coc_bytes;
#line 3107
    l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k);
#line 3108
    l_nb_bytes += l_nb_comps * l_qcc_bytes;
    }
  }
  {
#line 3111
  __cil_tmp9 = opj_j2k_get_max_poc_size(p_j2k);
  }
#line 3111
  l_nb_bytes += __cil_tmp9;
#line 3115
  return (l_nb_bytes);
}
}
#line 3126 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_tmp ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_old_poc_nb ;
  OPJ_UINT32 l_current_poc_nb ;
  OPJ_UINT32 l_current_poc_remaining ;
  OPJ_UINT32 l_chunk_size ;
  OPJ_UINT32 l_comp_room ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_poc_t *l_current_poc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  opj_tcp_t *tmp___2 ;
  OPJ_UINT32 tmp___3 ;
  int tmp___4 ;
  OPJ_UINT32 __cil_tmp23 ;
  OPJ_UINT32 __cil_tmp24 ;

  {
#line 3133
  l_image = (opj_image_t *)0;
#line 3137
  l_cp = (opj_cp_t *)0;
#line 3138
  l_tcp = (opj_tcp_t *)0;
#line 3139
  l_current_poc = (opj_poc_t *)0;
#line 3146
  l_image = p_j2k->m_private_image;
#line 3147
  l_nb_comp = l_image->numcomps;
#line 3148
  if (l_nb_comp <= 256U) {
#line 3149
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 3152
    l_comp_room = (OPJ_UINT32 )2;
  }
#line 3154
  l_chunk_size = 5U + 2U * l_comp_room;
#line 3155
  l_current_poc_nb = p_header_size / l_chunk_size;
#line 3156
  l_current_poc_remaining = p_header_size % l_chunk_size;
#line 3158
  if (l_current_poc_nb <= 0U) {
    {
    {
#line 3159
    opj_event_msg(p_manager, 1, "Error reading POC marker\n");
    }
    }
#line 3160
    return (0);
  } else
#line 3158
  if (l_current_poc_remaining != 0U) {
    {
    {
#line 3159
    opj_event_msg(p_manager, 1, "Error reading POC marker\n");
    }
    }
#line 3160
    return (0);
  }
#line 3163
  l_cp = & p_j2k->m_cp;
#line 3164
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 3164
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 3164
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 3164
  l_tcp = tmp___2;
#line 3167
  if ((int )l_tcp->POC) {
#line 3167
    tmp___3 = l_tcp->numpocs + 1U;
  } else {
#line 3167
    tmp___3 = (unsigned int )0;
  }
#line 3167
  l_old_poc_nb = tmp___3;
#line 3168
  l_current_poc_nb += l_old_poc_nb;
#line 3170
  if (l_current_poc_nb >= 32U) {
    {
#line 3172
    opj_event_msg(p_manager, 1, "Too many POCs %d\n", l_current_poc_nb);
    }
#line 3173
    return (0);
  }
#line 3178
  l_tcp->POC = (OPJ_UINT32 )1;
#line 3180
  l_current_poc = & l_tcp->pocs[l_old_poc_nb];
#line 3181
  i = l_old_poc_nb;
  {
#line 3181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3181
    if (! (i < l_current_poc_nb)) {
#line 3181
      goto while_break;
    }
    {
#line 3182
    opj_read_bytes_LE(p_header_data, & l_current_poc->resno0, (OPJ_UINT32 )1);
#line 3183
    p_header_data ++;
#line 3184
    opj_read_bytes_LE(p_header_data, & l_current_poc->compno0, l_comp_room);
#line 3185
    p_header_data += l_comp_room;
#line 3186
    opj_read_bytes_LE(p_header_data, & l_current_poc->layno1, (OPJ_UINT32 )2);
#line 3188
    l_current_poc->layno1 = opj_uint_min(l_current_poc->layno1, l_tcp->numlayers);
#line 3189
    p_header_data += 2;
#line 3190
    opj_read_bytes_LE(p_header_data, & l_current_poc->resno1, (OPJ_UINT32 )1);
#line 3191
    p_header_data ++;
#line 3192
    opj_read_bytes_LE(p_header_data, & l_current_poc->compno1, l_comp_room);
#line 3193
    p_header_data += l_comp_room;
#line 3194
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 3195
    p_header_data ++;
#line 3196
    l_current_poc->prg = (OPJ_PROG_ORDER )l_tmp;
#line 3198
    l_current_poc->compno1 = opj_uint_min(l_current_poc->compno1, l_nb_comp);
#line 3199
    l_current_poc ++;
    }
#line 3181
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3202
  l_tcp->numpocs = l_current_poc_nb - 1U;
#line 3203
  return (1);
}
}
#line 3214 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3226
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 3228
  if (p_header_size != l_nb_comp * 4U) {
    {
#line 3229
    opj_event_msg(p_manager, 1, "Error reading CRG marker\n\224yi\347U");
    }
#line 3230
    return (0);
  }
#line 3243
  return (1);
}
}
#line 3254 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_Ztlm ;
  OPJ_UINT32 l_Stlm ;
  OPJ_UINT32 l_ST ;
  OPJ_UINT32 l_SP ;
  OPJ_UINT32 l_tot_num_tp_remaining ;
  OPJ_UINT32 l_quotient ;
  OPJ_UINT32 l_Ptlm_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3266
  if (p_header_size < 2U) {
    {
#line 3267
    opj_event_msg(p_manager, 1, "Error reading TLM marker\n\311yi\347U");
    }
#line 3268
    return (0);
  }
  {
#line 3270
  p_header_size -= (unsigned int )2;
#line 3272
  opj_read_bytes_LE(p_header_data, & l_Ztlm, (OPJ_UINT32 )1);
#line 3273
  p_header_data ++;
#line 3274
  opj_read_bytes_LE(p_header_data, & l_Stlm, (OPJ_UINT32 )1);
#line 3275
  p_header_data ++;
#line 3277
  l_ST = (l_Stlm >> 4) & 3U;
#line 3278
  l_SP = (l_Stlm >> 6) & 1U;
#line 3280
  l_Ptlm_size = (l_SP + 1U) * 2U;
#line 3281
  l_quotient = l_Ptlm_size + l_ST;
#line 3283
  l_tot_num_tp_remaining = p_header_size % l_quotient;
  }
#line 3285
  if (l_tot_num_tp_remaining != 0U) {
    {
#line 3286
    opj_event_msg(p_manager, 1, "Error reading TLM marker\n\324yi\347U");
    }
#line 3287
    return (0);
  }
#line 3299
  return (1);
}
}
#line 3310 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3321
  if (p_header_size < 1U) {
    {
#line 3322
    opj_event_msg(p_manager, 1, "Error reading PLM marker\n\317yi\347U");
    }
#line 3323
    return (0);
  }
#line 3369
  return (1);
}
}
#line 3380 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_Zplt ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_packet_len ;
  OPJ_UINT32 i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3386
  l_packet_len = (OPJ_UINT32 )0;
#line 3393
  if (p_header_size < 1U) {
    {
#line 3394
    opj_event_msg(p_manager, 1, "Error reading PLT marker\n\002zi\347U");
    }
#line 3395
    return (0);
  }
  {
#line 3398
  opj_read_bytes_LE(p_header_data, & l_Zplt, (OPJ_UINT32 )1);
#line 3399
  p_header_data ++;
#line 3400
  p_header_size --;
#line 3402
  i = (OPJ_UINT32 )0;
  }
  {
#line 3402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3402
    if (! (i < p_header_size)) {
#line 3402
      goto while_break;
    }
    {
#line 3403
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 3404
    p_header_data ++;
#line 3406
    l_packet_len |= l_tmp & 127U;
    }
#line 3407
    if (l_tmp & 128U) {
#line 3408
      l_packet_len <<= 7;
    } else {
#line 3412
      l_packet_len = (OPJ_UINT32 )0;
    }
#line 3402
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3416
  if (l_packet_len != 0U) {
    {
#line 3417
    opj_event_msg(p_manager, 1, "Error reading PLT marker\n");
    }
#line 3418
    return (0);
  }
#line 3421
  return (1);
}
}
#line 3527 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL j2k_read_ppm_v3(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                         struct opj_event_mgr *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  OPJ_UINT32 l_remaining_data ;
  OPJ_UINT32 l_Z_ppm ;
  OPJ_UINT32 l_N_ppm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp12 ;
  OPJ_BYTE *new_ppm_data ;
  int tmp___2 ;
  void *__cil_tmp15 ;
  OPJ_BYTE *new_ppm_data___0 ;
  int tmp___3 ;
  void *__cil_tmp18 ;
  OPJ_BYTE *new_ppm_data___1 ;
  int tmp___4 ;
  void *__cil_tmp21 ;

  {
#line 3534
  l_cp = (opj_cp_t *)0;
#line 3543
  if (p_header_size < 1U) {
    {
#line 3544
    opj_event_msg(p_manager, 1, "Error reading PPM marker\n$zi\347U");
    }
#line 3545
    return (0);
  }
  {
#line 3548
  l_cp = & p_j2k->m_cp;
#line 3549
  l_cp->ppm = (OPJ_UINT32 )1;
#line 3551
  opj_read_bytes_LE(p_header_data, & l_Z_ppm, (OPJ_UINT32 )1);
#line 3552
  p_header_data ++;
#line 3553
  p_header_size --;
  }
#line 3556
  if (l_Z_ppm == 0U) {
#line 3557
    if (l_cp->ppm_data != (void *)0) {
      {
#line 3558
      opj_event_msg(p_manager, 1, "Zppm O already processed. Found twice.\n");
#line 3559
      free(l_cp->ppm_data);
#line 3560
      l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3561
      l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3562
      l_cp->ppm = (OPJ_UINT32 )0;
      }
#line 3563
      return (0);
    }
#line 3566
    if (p_header_size < 4U) {
      {
#line 3567
      opj_event_msg(p_manager, 1, "Error reading PPM marker\n&zi\347U");
      }
#line 3568
      return (0);
    }
    {
#line 3571
    opj_read_bytes_LE(p_header_data, & l_N_ppm, (OPJ_UINT32 )4);
#line 3572
    p_header_data += 4;
#line 3573
    p_header_size -= (unsigned int )4;
    }
#line 3576
    if (p_header_size < l_N_ppm) {
      {
#line 3578
      opj_event_msg(p_manager, 1, "Not enough bytes (%u) to hold Ippm series (%u), Index (%d)\n",
                    p_header_size, l_N_ppm, l_Z_ppm);
#line 3579
      free(l_cp->ppm_data);
#line 3580
      l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3581
      l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3582
      l_cp->ppm = (OPJ_UINT32 )0;
      }
#line 3583
      return (0);
    }
    {
#line 3587
    l_cp->ppm_len = l_N_ppm;
#line 3588
    l_cp->ppm_data_read = (OPJ_UINT32 )0;
#line 3590
    __cil_tmp12 = calloc((unsigned long )1, (unsigned long )l_cp->ppm_len);
#line 3590
    l_cp->ppm_data = (OPJ_BYTE *)__cil_tmp12;
#line 3591
    l_cp->ppm_buffer = l_cp->ppm_data;
    }
#line 3592
    if (l_cp->ppm_data == (OPJ_BYTE *)0) {
      {
#line 3593
      opj_event_msg(p_manager, 1, "Not enough memory to read ppm marker\n");
      }
#line 3594
      return (0);
    }
#line 3597
    l_cp->ppm_data_current = l_cp->ppm_data;
  } else
#line 3602
  if (p_header_size < 4U) {
    {
#line 3603
    opj_event_msg(p_manager, 2, "Empty PPM marker\n");
    }
#line 3604
    return (1);
  } else
#line 3608
  if (l_cp->ppm_data_read < l_cp->ppm_len) {
#line 3610
    l_cp->ppm_data_current = l_cp->ppm_data + l_cp->ppm_data_read;
#line 3611
    l_N_ppm = l_cp->ppm_len - l_cp->ppm_data_read;
  } else {
    {
#line 3615
    opj_read_bytes_LE(p_header_data, & l_N_ppm, (OPJ_UINT32 )4);
#line 3616
    p_header_data += 4;
#line 3617
    p_header_size -= (unsigned int )4;
    }
#line 3620
    if (p_header_size < l_N_ppm) {
      {
#line 3622
      opj_event_msg(p_manager, 1, "Not enough bytes (%u) to hold Ippm series (%u), Index (%d)\n",
                    p_header_size, l_N_ppm, l_Z_ppm);
#line 3623
      free(l_cp->ppm_data);
#line 3624
      l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3625
      l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3626
      l_cp->ppm = (OPJ_UINT32 )0;
      }
#line 3627
      return (0);
    }
    {
#line 3631
    __cil_tmp15 = realloc(l_cp->ppm_data, (unsigned long )(l_cp->ppm_len + l_N_ppm));
#line 3631
    new_ppm_data = (OPJ_BYTE *)__cil_tmp15;
    }
#line 3632
    if (! new_ppm_data) {
      {
#line 3633
      free(l_cp->ppm_data);
#line 3634
      l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3635
      l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3636
      l_cp->ppm_len = (OPJ_UINT32 )0;
#line 3637
      opj_event_msg(p_manager, 1, "Not enough memory to increase the size of ppm_data to add the new Ippm series\n");
      }
#line 3638
      return (0);
    }
#line 3640
    l_cp->ppm_data = new_ppm_data;
#line 3641
    l_cp->ppm_buffer = l_cp->ppm_data;
#line 3644
    l_cp->ppm_data_current = l_cp->ppm_data + l_cp->ppm_len;
#line 3645
    l_cp->ppm_len += l_N_ppm;
  }
#line 3650
  l_remaining_data = p_header_size;
  {
#line 3652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3652
    if (! (l_remaining_data >= l_N_ppm)) {
#line 3652
      goto while_break;
    }
    {
#line 3654
    memcpy(l_cp->ppm_data_current, p_header_data, (unsigned long )l_N_ppm);
#line 3655
    p_header_size -= l_N_ppm;
#line 3656
    p_header_data += l_N_ppm;
#line 3658
    l_cp->ppm_data_read += l_N_ppm;
    }
#line 3660
    if (p_header_size) {
#line 3662
      if (p_header_size < 4U) {
        {
#line 3663
        free(l_cp->ppm_data);
#line 3664
        l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3665
        l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3666
        l_cp->ppm_len = (OPJ_UINT32 )0;
#line 3667
        l_cp->ppm = (OPJ_UINT32 )0;
#line 3668
        opj_event_msg(p_manager, 1, "Error reading PPM marker\n");
        }
#line 3669
        return (0);
      }
      {
#line 3671
      opj_read_bytes_LE(p_header_data, & l_N_ppm, (OPJ_UINT32 )4);
#line 3672
      p_header_data += 4;
#line 3673
      p_header_size -= (unsigned int )4;
      }
    } else {
#line 3676
      l_remaining_data = p_header_size;
#line 3677
      goto while_break;
    }
#line 3680
    l_remaining_data = p_header_size;
#line 3683
    if (l_remaining_data >= l_N_ppm) {
#line 3688
      if (l_cp->ppm_len + l_N_ppm < l_N_ppm) {
        {
#line 3689
        free(l_cp->ppm_data);
#line 3690
        l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3691
        l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3692
        l_cp->ppm_len = (OPJ_UINT32 )0;
#line 3693
        opj_event_msg(p_manager, 1, "Not enough memory to increase the size of ppm_data to add the new (complete) Ippm series\n");
        }
#line 3694
        return (0);
      }
      {
#line 3696
      __cil_tmp18 = realloc(l_cp->ppm_data, (unsigned long )(l_cp->ppm_len + l_N_ppm));
#line 3696
      new_ppm_data___0 = (OPJ_BYTE *)__cil_tmp18;
      }
#line 3697
      if (! new_ppm_data___0) {
        {
#line 3698
        free(l_cp->ppm_data);
#line 3699
        l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3700
        l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3701
        l_cp->ppm_len = (OPJ_UINT32 )0;
#line 3702
        opj_event_msg(p_manager, 1, "Not enough memory to increase the size of ppm_data to add the new (complete) Ippm series\n");
        }
#line 3703
        return (0);
      }
#line 3705
      l_cp->ppm_data = new_ppm_data___0;
#line 3706
      l_cp->ppm_buffer = l_cp->ppm_data;
#line 3709
      l_cp->ppm_data_current = l_cp->ppm_data + l_cp->ppm_len;
#line 3710
      l_cp->ppm_len += l_N_ppm;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3716
  if (l_remaining_data) {
#line 3721
    if (l_cp->ppm_len + l_N_ppm < l_N_ppm) {
      {
#line 3722
      free(l_cp->ppm_data);
#line 3723
      l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3724
      l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3725
      l_cp->ppm_len = (OPJ_UINT32 )0;
#line 3726
      opj_event_msg(p_manager, 1, "Not enough memory to increase the size of ppm_data to add the new (complete) Ippm series\n");
      }
#line 3727
      return (0);
    }
    {
#line 3729
    __cil_tmp21 = realloc(l_cp->ppm_data, (unsigned long )(l_cp->ppm_len + l_N_ppm));
#line 3729
    new_ppm_data___1 = (OPJ_BYTE *)__cil_tmp21;
    }
#line 3730
    if (! new_ppm_data___1) {
      {
#line 3731
      free(l_cp->ppm_data);
#line 3732
      l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3733
      l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3734
      l_cp->ppm_len = (OPJ_UINT32 )0;
#line 3735
      opj_event_msg(p_manager, 1, "Not enough memory to increase the size of ppm_data to add the new (incomplete) Ippm series\n");
      }
#line 3736
      return (0);
    }
    {
#line 3738
    l_cp->ppm_data = new_ppm_data___1;
#line 3739
    l_cp->ppm_buffer = l_cp->ppm_data;
#line 3742
    l_cp->ppm_data_current = l_cp->ppm_data + l_cp->ppm_len;
#line 3743
    l_cp->ppm_len += l_N_ppm;
#line 3746
    memcpy(l_cp->ppm_data_current, p_header_data, (unsigned long )l_remaining_data);
#line 3747
    p_header_size -= l_remaining_data;
#line 3748
    p_header_data += l_remaining_data;
#line 3750
    l_cp->ppm_data_read += l_remaining_data;
    }
  }
#line 3799
  return (1);
}
}
#line 3810 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_Z_ppt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp11 ;
  OPJ_BYTE *new_ppt_buffer ;
  void *__cil_tmp13 ;

  {
#line 3816
  l_cp = (opj_cp_t *)0;
#line 3817
  l_tcp = (opj_tcp_t *)0;
#line 3826
  if (p_header_size < 1U) {
    {
#line 3827
    opj_event_msg(p_manager, 1, "Error reading PPT marker\n\251zi\347U");
    }
#line 3828
    return (0);
  }
#line 3831
  l_cp = & p_j2k->m_cp;
#line 3832
  if (l_cp->ppm) {
    {
#line 3833
    opj_event_msg(p_manager, 1, "Error reading PPT marker: packet header have been previously found in the main header (PPM marker).\n\347U");
    }
#line 3834
    return (0);
  }
  {
#line 3837
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 3838
  l_tcp->ppt = (OPJ_UINT32 )1;
#line 3840
  opj_read_bytes_LE(p_header_data, & l_Z_ppt, (OPJ_UINT32 )1);
#line 3841
  p_header_data ++;
#line 3842
  p_header_size --;
  }
#line 3845
  if (l_Z_ppt == 0U) {
    {
#line 3847
    l_tcp->ppt_data_size = (OPJ_UINT32 )0;
#line 3848
    l_tcp->ppt_len = p_header_size;
#line 3850
    free(l_tcp->ppt_buffer);
#line 3851
    __cil_tmp11 = calloc((unsigned long )l_tcp->ppt_len, sizeof(OPJ_BYTE ));
#line 3851
    l_tcp->ppt_buffer = (OPJ_BYTE *)__cil_tmp11;
    }
#line 3852
    if (l_tcp->ppt_buffer == (OPJ_BYTE *)0) {
      {
#line 3853
      opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\n");
      }
#line 3854
      return (0);
    }
#line 3856
    l_tcp->ppt_data = l_tcp->ppt_buffer;
  } else {
    {
#line 3862
    l_tcp->ppt_len += p_header_size;
#line 3864
    __cil_tmp13 = realloc(l_tcp->ppt_buffer, (unsigned long )l_tcp->ppt_len);
#line 3864
    new_ppt_buffer = (OPJ_BYTE *)__cil_tmp13;
    }
#line 3865
    if (! new_ppt_buffer) {
      {
#line 3866
      free(l_tcp->ppt_buffer);
#line 3867
      l_tcp->ppt_buffer = (OPJ_BYTE *)((void *)0);
#line 3868
      l_tcp->ppt_len = (OPJ_UINT32 )0;
#line 3869
      opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\n");
      }
#line 3870
      return (0);
    }
    {
#line 3872
    l_tcp->ppt_buffer = new_ppt_buffer;
#line 3873
    l_tcp->ppt_data = l_tcp->ppt_buffer;
#line 3875
    memset(l_tcp->ppt_buffer + l_tcp->ppt_data_size, 0, (unsigned long )p_header_size);
    }
  }
  {
#line 3879
  memcpy(l_tcp->ppt_buffer + l_tcp->ppt_data_size, p_header_data, (unsigned long )p_header_size);
#line 3881
  l_tcp->ppt_data_size += p_header_size;
  }
#line 3883
  return (1);
}
}
#line 3886 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tlm_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp10 ;
  OPJ_OFF_T __cil_tmp11 ;
  OPJ_SIZE_T __cil_tmp12 ;

  {
#line 3891
  l_current_data = (OPJ_BYTE *)0;
#line 3899
  l_tlm_size = 6U + 5U * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;
#line 3901
  if (l_tlm_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 3902
    __cil_tmp10 = realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (unsigned long )l_tlm_size);
#line 3902
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp10;
    }
#line 3903
    if (! new_header_tile_data) {
      {
#line 3904
      free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 3905
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 3906
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 3907
      opj_event_msg(p_manager, 1, "Not enough memory to write TLM marker\n");
      }
#line 3908
      return (0);
    }
#line 3910
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 3911
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_tlm_size;
  }
  {
#line 3914
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 3918
  p_j2k->m_specific_param.m_encoder.m_tlm_start = opj_stream_tell(p_stream);
#line 3920
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65365, (OPJ_UINT32 )2);
#line 3921
  l_current_data += 2;
#line 3923
  opj_write_bytes_LE(l_current_data, l_tlm_size - 2U, (OPJ_UINT32 )2);
#line 3924
  l_current_data += 2;
#line 3926
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 3927
  l_current_data ++;
#line 3929
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )80, (OPJ_UINT32 )1);
#line 3930
  l_current_data ++;
#line 3933
  __cil_tmp12 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_tlm_size, p_manager);
  }
#line 3933
  if (__cil_tmp12 != (unsigned long )l_tlm_size) {
#line 3934
    return (0);
  }
#line 3937
  return (1);
}
}
#line 3940 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                           opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3952
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )65424, (OPJ_UINT32 )2);
#line 3953
  p_data += 2;
#line 3955
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )10, (OPJ_UINT32 )2);
#line 3956
  p_data += 2;
#line 3958
  opj_write_bytes_LE(p_data, p_j2k->m_current_tile_number, (OPJ_UINT32 )2);
#line 3959
  p_data += 2;
#line 3962
  p_data += 4;
#line 3964
  opj_write_bytes_LE(p_data, p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,
                     (OPJ_UINT32 )1);
#line 3965
  p_data ++;
#line 3967
  opj_write_bytes_LE(p_data, (p_j2k->m_cp.tcps + p_j2k->m_current_tile_number)->m_nb_tile_parts,
                     (OPJ_UINT32 )1);
#line 3968
  p_data ++;
#line 3979
  *p_data_written = (OPJ_UINT32 )12;
  }
#line 3981
  return (1);
}
}
#line 3984 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                          opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_tot_len ;
  OPJ_UINT32 l_num_parts ;
  OPJ_UINT32 l_current_part ;
  OPJ_UINT32 l_tile_x ;
  OPJ_UINT32 l_tile_y ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp17 ;
  opj_tp_index_t *new_tp_index ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  opj_tp_index_t *new_tp_index___0 ;
  void *__cil_tmp22 ;

  {
#line 3989
  l_cp = (opj_cp_t *)0;
#line 3990
  l_tcp = (opj_tcp_t *)0;
#line 3991
  l_num_parts = (OPJ_UINT32 )0;
#line 4001
  if (p_header_size != 8U) {
    {
#line 4002
    opj_event_msg(p_manager, 1, "Error reading SOT marker\n\024{i\347U");
    }
#line 4003
    return (0);
  }
  {
#line 4006
  l_cp = & p_j2k->m_cp;
#line 4007
  opj_read_bytes_LE(p_header_data, & p_j2k->m_current_tile_number, (OPJ_UINT32 )2);
#line 4008
  p_header_data += 2;
  }
#line 4011
  if (p_j2k->m_current_tile_number >= l_cp->tw * l_cp->th) {
    {
#line 4012
    opj_event_msg(p_manager, 1, "Invalid tile number %d\n", p_j2k->m_current_tile_number);
    }
#line 4013
    return (0);
  }
  {
#line 4016
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 4017
  l_tile_x = p_j2k->m_current_tile_number % l_cp->tw;
#line 4018
  l_tile_y = p_j2k->m_current_tile_number / l_cp->tw;
#line 4051
  opj_read_bytes_LE(p_header_data, & l_tot_len, (OPJ_UINT32 )4);
#line 4052
  p_header_data += 4;
  }
#line 4055
  if (l_tot_len != 0U) {
#line 4055
    if (l_tot_len < 14U) {
#line 4057
      if (l_tot_len == 12U) {
        {
#line 4059
        opj_event_msg(p_manager, 2, "Empty SOT marker detected: Psot=%d.\n", l_tot_len);
        }
      } else {
        {
#line 4063
        opj_event_msg(p_manager, 1, "Psot value is not correct regards to the JPEG2000 norm: %d.\n\347U",
                      l_tot_len);
        }
#line 4064
        return (0);
      }
    }
  }
#line 4090
  if (! l_tot_len) {
    {
#line 4091
    opj_event_msg(p_manager, 4, "Psot value of the current tile-part is equal to zero, we assuming it is the last tile-part of the codestream.\n{i\347U");
#line 4093
    p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
    }
  }
  {
#line 4096
  opj_read_bytes_LE(p_header_data, & l_current_part, (OPJ_UINT32 )1);
#line 4097
  p_header_data ++;
#line 4099
  opj_read_bytes_LE(p_header_data, & l_num_parts, (OPJ_UINT32 )1);
#line 4100
  p_header_data ++;
  }
#line 4102
  if (l_num_parts != 0U) {
#line 4105
    if (l_tcp->m_nb_tile_parts) {
#line 4106
      if (l_current_part >= l_tcp->m_nb_tile_parts) {
        {
#line 4107
        opj_event_msg(p_manager, 1, "In SOT marker, TPSot (%d) is not valid regards to the current number of tile-part (%d), giving up\n",
                      l_current_part, l_tcp->m_nb_tile_parts);
#line 4109
        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
        }
#line 4110
        return (0);
      }
    }
#line 4113
    if (l_current_part >= l_num_parts) {
      {
#line 4115
      opj_event_msg(p_manager, 1, "In SOT marker, TPSot (%d) is not valid regards to the current number of tile-part (header) (%d), giving up\n",
                    l_current_part, l_num_parts);
#line 4117
      p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
      }
#line 4118
      return (0);
    }
#line 4120
    l_tcp->m_nb_tile_parts = l_num_parts;
  }
#line 4124
  if (l_tcp->m_nb_tile_parts) {
#line 4125
    if (l_tcp->m_nb_tile_parts == l_current_part + 1U) {
#line 4126
      p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_UINT32 )1;
    }
  }
#line 4130
  if (! p_j2k->m_specific_param.m_decoder.m_last_tile_part) {
#line 4132
    p_j2k->m_specific_param.m_decoder.m_sot_length = l_tot_len - 12U;
  } else {
#line 4136
    p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32 )0;
  }
#line 4139
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )16;
#line 4142
  if (p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec == -1) {
#line 4143
    p_j2k->m_specific_param.m_decoder.m_skip_data = ((l_tile_x < p_j2k->m_specific_param.m_decoder.m_start_tile_x || l_tile_x >= p_j2k->m_specific_param.m_decoder.m_end_tile_x) || l_tile_y < p_j2k->m_specific_param.m_decoder.m_start_tile_y) || l_tile_y >= p_j2k->m_specific_param.m_decoder.m_end_tile_y;
  } else {
#line 4151
    p_j2k->m_specific_param.m_decoder.m_skip_data = p_j2k->m_current_tile_number != (OPJ_UINT32 )p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec;
  }
#line 4156
  if (p_j2k->cstr_index) {
#line 4159
    ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tileno = p_j2k->m_current_tile_number;
#line 4160
    ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_tpsno = l_current_part;
#line 4162
    if (l_num_parts != 0U) {
#line 4163
      ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->nb_tps = l_num_parts;
#line 4164
      ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = l_num_parts;
#line 4166
      if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
        {
#line 4167
        __cil_tmp17 = calloc((unsigned long )l_num_parts, sizeof(opj_tp_index_t ));
#line 4167
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)__cil_tmp17;
        }
#line 4169
        if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
          {
#line 4170
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4171
          return (0);
        }
      } else {
        {
#line 4175
        __cil_tmp19 = realloc(((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index,
                              (unsigned long )l_num_parts * sizeof(opj_tp_index_t ));
#line 4175
        new_tp_index = (opj_tp_index_t *)__cil_tmp19;
        }
#line 4177
        if (! new_tp_index) {
          {
#line 4178
          free(((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index);
#line 4179
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)((void *)0);
#line 4180
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4181
          return (0);
        }
#line 4183
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = new_tp_index;
      }
    } else {
#line 4189
      if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
        {
#line 4190
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )10;
#line 4191
        __cil_tmp20 = calloc((unsigned long )((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps,
                             sizeof(opj_tp_index_t ));
#line 4191
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)__cil_tmp20;
        }
#line 4194
        if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
          {
#line 4195
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )0;
#line 4196
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4197
          return (0);
        }
      }
#line 4201
      if (l_current_part >= ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps) {
        {
#line 4203
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = l_current_part + 1U;
#line 4204
        __cil_tmp22 = realloc(((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index,
                              (unsigned long )((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps * sizeof(opj_tp_index_t ));
#line 4204
        new_tp_index___0 = (opj_tp_index_t *)__cil_tmp22;
        }
#line 4207
        if (! new_tp_index___0) {
          {
#line 4208
          free(((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index);
#line 4209
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)((void *)0);
#line 4210
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )0;
#line 4211
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4212
          return (0);
        }
#line 4214
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = new_tp_index___0;
      }
    }
  }
#line 4249
  return (1);
}
}
#line 4252 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k , opj_tcd_t *p_tile_coder , OPJ_BYTE *p_data ,
                           OPJ_UINT32 *p_data_written , OPJ_UINT32 p_total_data_size ,
                           opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  opj_codestream_info_t *l_cstr_info ;
  OPJ_UINT32 l_remaining_data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 4261
  l_cstr_info = (opj_codestream_info_t *)0;
#line 4269
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )65427, (OPJ_UINT32 )2);
#line 4270
  p_data += 2;
#line 4273
  l_remaining_data = p_total_data_size - 4U;
#line 4276
  p_tile_coder->tp_num = p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number;
#line 4277
  p_tile_coder->cur_tp_num = p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
  }
#line 4307
  if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0U) {
#line 4308
    ((p_tile_coder->tcd_image)->tiles)->packno = (OPJ_UINT32 )0;
#line 4309
    if (l_cstr_info) {
#line 4310
      l_cstr_info->packno = 0;
    }
  }
  {
#line 4314
  *p_data_written = (OPJ_UINT32 )0;
#line 4316
  __cil_tmp13 = opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data,
                                    p_data_written, l_remaining_data, l_cstr_info);
  }
#line 4316
  if (! __cil_tmp13) {
    {
#line 4317
    opj_event_msg(p_manager, 1, "Cannot encode tile\n");
    }
#line 4318
    return (0);
  }
#line 4321
  *p_data_written += (unsigned int )2;
#line 4323
  return (1);
}
}
#line 4326 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_SIZE_T l_current_read_size ;
  opj_codestream_index_t *l_cstr_index ;
  OPJ_BYTE **l_current_data ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 *l_tile_len ;
  OPJ_BOOL l_sot_length_pb_detected ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_OFF_T __cil_tmp13 ;
  OPJ_OFF_T __cil_tmp14 ;
  void *__cil_tmp15 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp17 ;
  OPJ_OFF_T l_current_pos ;
  OPJ_OFF_T __cil_tmp19 ;
  OPJ_UINT32 l_current_tile_part ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_SIZE_T __cil_tmp22 ;

  {
#line 4332
  l_cstr_index = (opj_codestream_index_t *)0;
#line 4333
  l_current_data = (OPJ_BYTE **)0;
#line 4334
  l_tcp = (opj_tcp_t *)0;
#line 4335
  l_tile_len = (OPJ_UINT32 *)0;
#line 4336
  l_sot_length_pb_detected = 0;
#line 4343
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 4345
  if (p_j2k->m_specific_param.m_decoder.m_last_tile_part) {
    {
#line 4350
    __cil_tmp13 = opj_stream_get_number_byte_left(p_stream);
#line 4350
    p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32 )(__cil_tmp13 - 2L);
    }
  } else
#line 4354
  if (p_j2k->m_specific_param.m_decoder.m_sot_length >= 2U) {
#line 4355
    p_j2k->m_specific_param.m_decoder.m_sot_length -= (unsigned int )2;
  }
#line 4361
  l_current_data = & l_tcp->m_data;
#line 4362
  l_tile_len = & l_tcp->m_data_size;
#line 4365
  if (p_j2k->m_specific_param.m_decoder.m_sot_length) {
    {
#line 4368
    __cil_tmp14 = opj_stream_get_number_byte_left(p_stream);
    }
#line 4368
    if ((OPJ_OFF_T )p_j2k->m_specific_param.m_decoder.m_sot_length > __cil_tmp14) {
      {
#line 4369
      opj_event_msg(p_manager, 1, "Tile part length size inconsistent with stream length\n");
      }
#line 4370
      return (0);
    }
#line 4372
    if (! *l_current_data) {
      {
#line 4376
      __cil_tmp15 = malloc((unsigned long )p_j2k->m_specific_param.m_decoder.m_sot_length);
#line 4376
      *l_current_data = (OPJ_BYTE *)__cil_tmp15;
      }
    } else {
      {
#line 4379
      __cil_tmp17 = realloc(*l_current_data, (unsigned long )(*l_tile_len + p_j2k->m_specific_param.m_decoder.m_sot_length));
#line 4379
      l_new_current_data = (OPJ_BYTE *)__cil_tmp17;
      }
#line 4380
      if (! l_new_current_data) {
        {
#line 4381
        free(*l_current_data);
        }
      }
#line 4387
      *l_current_data = l_new_current_data;
    }
#line 4390
    if (*l_current_data == (OPJ_BYTE *)0) {
      {
#line 4391
      opj_event_msg(p_manager, 1, "Not enough memory to decode tile\n");
      }
#line 4392
      return (0);
    }
  } else {
#line 4396
    l_sot_length_pb_detected = 1;
  }
#line 4400
  l_cstr_index = p_j2k->cstr_index;
#line 4401
  if (l_cstr_index) {
    {
#line 4402
    __cil_tmp19 = opj_stream_tell(p_stream);
#line 4402
    l_current_pos = __cil_tmp19 - 2L;
#line 4404
    l_current_tile_part = (l_cstr_index->tile_index + p_j2k->m_current_tile_number)->current_tpsno;
#line 4405
    ((l_cstr_index->tile_index + p_j2k->m_current_tile_number)->tp_index + l_current_tile_part)->end_header = l_current_pos;
#line 4407
    ((l_cstr_index->tile_index + p_j2k->m_current_tile_number)->tp_index + l_current_tile_part)->end_pos = (l_current_pos + (long )p_j2k->m_specific_param.m_decoder.m_sot_length) + 2L;
#line 4410
    __cil_tmp21 = opj_j2k_add_tlmarker(p_j2k->m_current_tile_number, l_cstr_index,
                                       (OPJ_UINT32 )65427, l_current_pos, p_j2k->m_specific_param.m_decoder.m_sot_length + 2U);
    }
#line 4410
    if (0 == __cil_tmp21) {
      {
#line 4415
      opj_event_msg(p_manager, 1, "Not enough memory to add tl marker\ni\347U");
      }
#line 4416
      return (0);
    }
  }
#line 4423
  if (! l_sot_length_pb_detected) {
    {
#line 4424
    l_current_read_size = opj_stream_read_data(p_stream, *l_current_data + *l_tile_len,
                                               (OPJ_SIZE_T )p_j2k->m_specific_param.m_decoder.m_sot_length,
                                               p_manager);
    }
  } else {
#line 4432
    l_current_read_size = (OPJ_SIZE_T )0;
  }
#line 4435
  if (l_current_read_size != (unsigned long )p_j2k->m_specific_param.m_decoder.m_sot_length) {
#line 4436
    p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
  } else {
#line 4439
    p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
  }
#line 4442
  *l_tile_len += (OPJ_UINT32 )l_current_read_size;
#line 4444
  return (1);
}
}
#line 4447 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                           OPJ_UINT32 nb_comps , opj_stream_private_t *p_stream ,
                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_rgn_size ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 l_comp_room ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
#line 4455
  l_current_data = (OPJ_BYTE *)0;
#line 4457
  l_cp = (opj_cp_t *)0;
#line 4458
  l_tcp = (opj_tcp_t *)0;
#line 4459
  l_tccp = (opj_tccp_t *)0;
#line 4467
  l_cp = & p_j2k->m_cp;
#line 4468
  l_tcp = l_cp->tcps + p_tile_no;
#line 4469
  l_tccp = l_tcp->tccps + p_comp_no;
#line 4471
  if (nb_comps <= 256U) {
#line 4472
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 4475
    l_comp_room = (OPJ_UINT32 )2;
  }
  {
#line 4478
  l_rgn_size = 6U + l_comp_room;
#line 4480
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 4482
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65374, (OPJ_UINT32 )2);
#line 4483
  l_current_data += 2;
#line 4485
  opj_write_bytes_LE(l_current_data, l_rgn_size - 2U, (OPJ_UINT32 )2);
#line 4486
  l_current_data += 2;
#line 4488
  opj_write_bytes_LE(l_current_data, p_comp_no, l_comp_room);
#line 4489
  l_current_data += l_comp_room;
#line 4491
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 4492
  l_current_data ++;
#line 4494
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_tccp->roishift, (OPJ_UINT32 )1);
#line 4495
  l_current_data ++;
#line 4497
  __cil_tmp16 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_rgn_size, p_manager);
  }
#line 4497
  if (__cil_tmp16 != (unsigned long )l_rgn_size) {
#line 4498
    return (0);
  }
#line 4501
  return (1);
}
}
#line 4504 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_SIZE_T __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 4514
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (OPJ_UINT32 )65497,
                     (OPJ_UINT32 )2);
#line 4524
  __cil_tmp7 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                     (OPJ_SIZE_T )2, p_manager);
  }
#line 4524
  if (__cil_tmp7 != 2UL) {
#line 4525
    return (0);
  }
  {
#line 4528
  __cil_tmp8 = opj_stream_flush(p_stream, p_manager);
  }
#line 4528
  if (! __cil_tmp8) {
#line 4529
    return (0);
  }
#line 4532
  return (1);
}
}
#line 4543 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_comp_room ;
  OPJ_UINT32 l_comp_no ;
  OPJ_UINT32 l_roi_sty ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  opj_tcp_t *tmp___2 ;

  {
#line 4550
  l_image = (opj_image_t *)0;
#line 4552
  l_cp = (opj_cp_t *)0;
#line 4553
  l_tcp = (opj_tcp_t *)0;
#line 4561
  l_image = p_j2k->m_private_image;
#line 4562
  l_nb_comp = l_image->numcomps;
#line 4564
  if (l_nb_comp <= 256U) {
#line 4565
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 4567
    l_comp_room = (OPJ_UINT32 )2;
  }
#line 4569
  if (p_header_size != 2U + l_comp_room) {
    {
#line 4570
    opj_event_msg(p_manager, 1, "Error reading RGN marker\n\375|i\347U");
    }
#line 4571
    return (0);
  }
#line 4574
  l_cp = & p_j2k->m_cp;
#line 4575
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 4575
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 4575
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
  {
#line 4575
  l_tcp = tmp___2;
#line 4579
  opj_read_bytes_LE(p_header_data, & l_comp_no, l_comp_room);
#line 4580
  p_header_data += l_comp_room;
#line 4581
  opj_read_bytes_LE(p_header_data, & l_roi_sty, (OPJ_UINT32 )1);
#line 4582
  p_header_data ++;
  }
#line 4600
  if (l_comp_no >= l_nb_comp) {
    {
#line 4601
    opj_event_msg(p_manager, 1, "bad component number in RGN (%d when there are only %d)\n\230\001",
                  l_comp_no, l_nb_comp);
    }
#line 4604
    return (0);
  }
  {
#line 4607
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& (l_tcp->tccps + l_comp_no)->roishift),
                    (OPJ_UINT32 )1);
#line 4608
  p_header_data ++;
  }
#line 4610
  return (1);
}
}
#line 4614 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t *p_tcp ) 
{ 


  {
#line 4616
  return ((OPJ_FLOAT32 )((p_tcp->m_nb_tile_parts - 1U) * 14U));
}
}
#line 4619 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t *p_tcp ) 
{ 


  {
#line 4622
  return ((OPJ_FLOAT32 )0);
}
}
#line 4625 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_image_t *l_image ;
  opj_tcp_t *l_tcp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 l_x0 ;
  OPJ_INT32 l_y0 ;
  OPJ_INT32 l_x1 ;
  OPJ_INT32 l_y1 ;
  OPJ_FLOAT32 *l_rates ;
  OPJ_FLOAT32 l_sot_remove ;
  OPJ_UINT32 l_bits_empty ;
  OPJ_UINT32 l_size_pixel ;
  OPJ_UINT32 l_tile_size ;
  OPJ_UINT32 l_last_res ;
  OPJ_FLOAT32 (*l_tp_stride_func)(opj_tcp_t * ) ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_OFF_T __cil_tmp25 ;
  OPJ_FLOAT32 l_offset ;
  OPJ_FLOAT32 __cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;

  {
  {
#line 4629
  l_cp = (opj_cp_t *)0;
#line 4630
  l_image = (opj_image_t *)0;
#line 4631
  l_tcp = (opj_tcp_t *)0;
#line 4632
  l_img_comp = (opj_image_comp_t *)0;
#line 4636
  l_rates = (OPJ_FLOAT32 *)0;
#line 4639
  l_tile_size = (OPJ_UINT32 )0;
#line 4641
  l_tp_stride_func = (OPJ_FLOAT32 (*)(opj_tcp_t * ))0;
#line 4648
  l_cp = & p_j2k->m_cp;
#line 4649
  l_image = p_j2k->m_private_image;
#line 4650
  l_tcp = l_cp->tcps;
#line 4652
  l_bits_empty = (8U * (l_image->comps)->dx) * (l_image->comps)->dy;
#line 4653
  l_size_pixel = l_image->numcomps * (l_image->comps)->prec;
#line 4654
  __cil_tmp25 = opj_stream_tell(p_stream);
#line 4654
  l_sot_remove = (OPJ_FLOAT32 )__cil_tmp25 / (OPJ_FLOAT32 )(l_cp->th * l_cp->tw);
  }
#line 4656
  if (l_cp->m_specific_param.m_enc.m_tp_on) {
#line 4657
    l_tp_stride_func = & opj_j2k_get_tp_stride;
  } else {
#line 4660
    l_tp_stride_func = & opj_j2k_get_default_stride;
  }
#line 4663
  i = (OPJ_UINT32 )0;
  {
#line 4663
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4663
    if (! (i < l_cp->th)) {
#line 4663
      goto while_break;
    }
#line 4664
    j = (OPJ_UINT32 )0;
    {
#line 4664
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4664
      if (! (j < l_cp->tw)) {
#line 4664
        goto while_break___0;
      }
      {
#line 4665
      __cil_tmp27 = (*l_tp_stride_func)(l_tcp);
#line 4665
      l_offset = (OPJ_FLOAT32 )__cil_tmp27 / (OPJ_FLOAT32 )l_tcp->numlayers;
#line 4668
      l_x0 = opj_int_max((OPJ_INT32 )(l_cp->tx0 + j * l_cp->tdx), (OPJ_INT32 )l_image->x0);
#line 4669
      l_y0 = opj_int_max((OPJ_INT32 )(l_cp->ty0 + i * l_cp->tdy), (OPJ_INT32 )l_image->y0);
#line 4670
      l_x1 = opj_int_min((OPJ_INT32 )(l_cp->tx0 + (j + 1U) * l_cp->tdx), (OPJ_INT32 )l_image->x1);
#line 4671
      l_y1 = opj_int_min((OPJ_INT32 )(l_cp->ty0 + (i + 1U) * l_cp->tdy), (OPJ_INT32 )l_image->y1);
#line 4673
      l_rates = (OPJ_FLOAT32 *)l_tcp->rates;
      }
#line 4676
      if (*l_rates) {
#line 4677
        *l_rates = (OPJ_FLOAT32 )((l_size_pixel * (OPJ_UINT32 )(l_x1 - l_x0)) * (OPJ_UINT32 )(l_y1 - l_y0)) / (*l_rates * (OPJ_FLOAT32 )l_bits_empty) - l_offset;
      }
#line 4685
      l_rates ++;
#line 4687
      k = (OPJ_UINT32 )1;
      {
#line 4687
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4687
        if (! (k < l_tcp->numlayers)) {
#line 4687
          goto while_break___1;
        }
#line 4688
        if (*l_rates) {
#line 4689
          *l_rates = (OPJ_FLOAT32 )((l_size_pixel * (OPJ_UINT32 )(l_x1 - l_x0)) * (OPJ_UINT32 )(l_y1 - l_y0)) / (*l_rates * (OPJ_FLOAT32 )l_bits_empty) - l_offset;
        }
#line 4697
        l_rates ++;
#line 4687
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 4700
      l_tcp ++;
#line 4664
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4663
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4705
  l_tcp = l_cp->tcps;
#line 4707
  i = (OPJ_UINT32 )0;
  {
#line 4707
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 4707
    if (! (i < l_cp->th)) {
#line 4707
      goto while_break___2;
    }
#line 4708
    j = (OPJ_UINT32 )0;
    {
#line 4708
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 4708
      if (! (j < l_cp->tw)) {
#line 4708
        goto while_break___3;
      }
#line 4709
      l_rates = (OPJ_FLOAT32 *)l_tcp->rates;
#line 4711
      if (*l_rates) {
#line 4712
        *l_rates -= l_sot_remove;
#line 4714
        if (*l_rates < (float )30) {
#line 4715
          *l_rates = (OPJ_FLOAT32 )30;
        }
      }
#line 4719
      l_rates ++;
#line 4721
      l_last_res = l_tcp->numlayers - 1U;
#line 4723
      k = (OPJ_UINT32 )1;
      {
#line 4723
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 4723
        if (! (k < l_last_res)) {
#line 4723
          goto while_break___4;
        }
#line 4725
        if (*l_rates) {
#line 4726
          *l_rates -= l_sot_remove;
#line 4728
          if (*l_rates < *(l_rates - 1) + (float )10) {
#line 4729
            *l_rates = *(l_rates - 1) + (float )20;
          }
        }
#line 4733
        l_rates ++;
#line 4723
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 4736
      if (*l_rates) {
#line 4737
        *l_rates -= l_sot_remove + 2.f;
#line 4739
        if (*l_rates < *(l_rates - 1) + (float )10) {
#line 4740
          *l_rates = *(l_rates - 1) + (float )20;
        }
      }
#line 4744
      l_tcp ++;
#line 4708
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 4707
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 4748
  l_img_comp = l_image->comps;
#line 4749
  l_tile_size = (OPJ_UINT32 )0;
#line 4751
  i = (OPJ_UINT32 )0;
  {
#line 4751
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 4751
    if (! (i < l_image->numcomps)) {
#line 4751
      goto while_break___5;
    }
    {
#line 4752
    __cil_tmp33 = opj_uint_ceildiv(l_cp->tdy, l_img_comp->dy);
    }
    {
#line 4752
    __cil_tmp32 = opj_uint_ceildiv(l_cp->tdx, l_img_comp->dx);
    }
#line 4752
    l_tile_size += (__cil_tmp32 * __cil_tmp33) * l_img_comp->prec;
#line 4759
    l_img_comp ++;
#line 4751
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 4762
  l_tile_size = (OPJ_UINT32 )((double )l_tile_size * 0.162500000001);
#line 4764
  __cil_tmp34 = opj_j2k_get_specific_header_sizes(p_j2k);
  }
  {
#line 4764
  l_tile_size += __cil_tmp34;
#line 4766
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = l_tile_size;
#line 4767
  __cil_tmp35 = malloc((unsigned long )p_j2k->m_specific_param.m_encoder.m_encoded_tile_size);
#line 4767
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)__cil_tmp35;
  }
#line 4769
  if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data == (OPJ_BYTE *)0) {
#line 4770
    return (0);
  }
#line 4773
  if ((int )l_cp->rsiz >= 3) {
#line 4773
    if ((int )l_cp->rsiz <= 6) {
      {
#line 4774
      __cil_tmp36 = malloc((unsigned long )(5U * p_j2k->m_specific_param.m_encoder.m_total_tile_parts));
#line 4774
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)__cil_tmp36;
      }
#line 4776
      if (! p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
#line 4777
        return (0);
      }
#line 4780
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer;
    }
  }
#line 4784
  return (1);
}
}
#line 4838 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                struct opj_event_mgr *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_OFF_T __cil_tmp7 ;

  {
  {
#line 4847
  (p_j2k->cstr_index)->main_head_end = opj_stream_tell(p_stream);
  }
#line 4849
  return (1);
}
}
#line 4852 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_mct_record ;
  opj_tcp_t *l_tcp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 4866
  __cil_tmp11 = opj_j2k_write_cbd(p_j2k, p_stream, p_manager);
  }
#line 4866
  if (! __cil_tmp11) {
#line 4867
    return (0);
  }
#line 4870
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 4871
  l_mct_record = l_tcp->m_mct_records;
#line 4873
  i = (OPJ_UINT32 )0;
  {
#line 4873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4873
    if (! (i < l_tcp->m_nb_mct_records)) {
#line 4873
      goto while_break;
    }
    {
#line 4875
    __cil_tmp12 = opj_j2k_write_mct_record(p_j2k, l_mct_record, p_stream, p_manager);
    }
#line 4875
    if (! __cil_tmp12) {
#line 4876
      return (0);
    }
#line 4879
    l_mct_record ++;
#line 4873
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4882
  l_mcc_record = l_tcp->m_mcc_records;
#line 4884
  i = (OPJ_UINT32 )0;
  {
#line 4884
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4884
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 4884
      goto while_break___0;
    }
    {
#line 4886
    __cil_tmp13 = opj_j2k_write_mcc_record(p_j2k, l_mcc_record, p_stream, p_manager);
    }
#line 4886
    if (! __cil_tmp13) {
#line 4887
      return (0);
    }
#line 4890
    l_mcc_record ++;
#line 4884
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4893
  __cil_tmp14 = opj_j2k_write_mco(p_j2k, p_stream, p_manager);
  }
#line 4893
  if (! __cil_tmp14) {
#line 4894
    return (0);
  }
#line 4897
  return (1);
}
}
#line 4947 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                               struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  opj_tccp_t *l_tccp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 4952
  l_tccp = (opj_tccp_t *)0;
#line 4959
  l_tccp = (p_j2k->m_cp.tcps)->tccps;
#line 4961
  compno = (OPJ_UINT32 )0;
  {
#line 4961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4961
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 4961
      goto while_break;
    }
#line 4962
    if (l_tccp->roishift) {
      {
#line 4964
      __cil_tmp9 = opj_j2k_write_rgn(p_j2k, (OPJ_UINT32 )0, compno, (p_j2k->m_private_image)->numcomps,
                                     p_stream, p_manager);
      }
#line 4964
      if (! __cil_tmp9) {
#line 4965
        return (0);
      }
    }
#line 4969
    l_tccp ++;
#line 4961
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4972
  return (1);
}
}
#line 4975 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) 
{ 
  opj_codestream_index_t *l_cstr_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_OFF_T __cil_tmp8 ;

  {
#line 4979
  l_cstr_index = (opj_codestream_index_t *)0;
#line 4986
  l_cstr_index = p_j2k->cstr_index;
#line 4987
  if (l_cstr_index) {
    {
#line 4988
    __cil_tmp8 = opj_stream_tell(p_stream);
#line 4988
    l_cstr_index->codestream_size = (OPJ_UINT64 )__cil_tmp8;
#line 4993
    l_cstr_index->codestream_size -= (OPJ_UINT64 )l_cstr_index->main_head_start;
    }
  }
#line 5010
  return (1);
}
}
#line 5013 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , OPJ_UINT32 *output_marker ,
                          opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_unknown_marker ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  OPJ_UINT32 l_size_unk ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_SIZE_T __cil_tmp11 ;
  struct opj_dec_memory_marker_handler *__cil_tmp12 ;
  OPJ_BOOL res ;
  OPJ_OFF_T __cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;

  {
  {
#line 5021
  l_size_unk = (OPJ_UINT32 )2;
#line 5028
  opj_event_msg(p_manager, 2, "Unknown marker\n");
  }
  {
#line 5030
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5032
    __cil_tmp11 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 5032
    if (__cil_tmp11 != 2UL) {
      {
#line 5033
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 5034
      return (0);
    }
    {
#line 5038
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_unknown_marker,
                      (OPJ_UINT32 )2);
    }
#line 5040
    if (! (l_unknown_marker < 65280U)) {
      {
#line 5043
      l_marker_handler = opj_j2k_get_marker_handler(l_unknown_marker);
      }
#line 5045
      if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
        {
#line 5046
        opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n");
        }
#line 5047
        return (0);
      } else
#line 5050
      if (l_marker_handler->id != 0U) {
#line 5052
        if (l_marker_handler->id != 65424U) {
          {
#line 5054
          __cil_tmp14 = opj_stream_tell(p_stream);
#line 5054
          __cil_tmp15 = opj_j2k_add_mhmarker(p_j2k->cstr_index, (OPJ_UINT32 )0, (OPJ_OFF_T )((OPJ_UINT32 )__cil_tmp14 - l_size_unk),
                                             l_size_unk);
#line 5054
          res = __cil_tmp15;
          }
#line 5057
          if (res == 0) {
            {
#line 5058
            opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n");
            }
#line 5059
            return (0);
          }
        }
#line 5062
        goto while_break;
      } else {
#line 5065
        l_size_unk += (unsigned int )2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5070
  *output_marker = l_marker_handler->id;
#line 5072
  return (1);
}
}
#line 5075 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k , opj_mct_data_t *p_mct_record ,
                                  struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_mct_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tmp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp13 ;

  {
#line 5081
  l_current_data = (OPJ_BYTE *)0;
#line 5089
  l_mct_size = 10U + p_mct_record->m_data_size;
#line 5091
  if (l_mct_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5092
    __cil_tmp12 = realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (unsigned long )l_mct_size);
#line 5092
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp12;
    }
#line 5093
    if (! new_header_tile_data) {
      {
#line 5094
      free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5095
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5096
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5097
      opj_event_msg(p_manager, 1, "Not enough memory to write MCT marker\n");
      }
#line 5098
      return (0);
    }
#line 5100
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5101
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mct_size;
  }
  {
#line 5104
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5106
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65396, (OPJ_UINT32 )2);
#line 5107
  l_current_data += 2;
#line 5109
  opj_write_bytes_LE(l_current_data, l_mct_size - 2U, (OPJ_UINT32 )2);
#line 5110
  l_current_data += 2;
#line 5112
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5113
  l_current_data += 2;
#line 5116
  l_tmp = ((p_mct_record->m_index & 255U) | ((unsigned int )p_mct_record->m_array_type << 8)) | ((unsigned int )p_mct_record->m_element_type << 10);
#line 5118
  opj_write_bytes_LE(l_current_data, l_tmp, (OPJ_UINT32 )2);
#line 5119
  l_current_data += 2;
#line 5121
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5122
  l_current_data += 2;
#line 5124
  memcpy(l_current_data, p_mct_record->m_data, (unsigned long )p_mct_record->m_data_size);
#line 5126
  __cil_tmp13 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mct_size, p_manager);
  }
#line 5126
  if (__cil_tmp13 != (unsigned long )l_mct_size) {
#line 5127
    return (0);
  }
#line 5130
  return (1);
}
}
#line 5141 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_indix ;
  opj_mct_data_t *l_mct_data ;
  int tmp ;
  int tmp___0 ;
  opj_tcp_t *tmp___1 ;
  opj_mct_data_t *new_mct_records ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
#line 5148
  l_tcp = (opj_tcp_t *)0;
#line 5157
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 5157
    tmp___1 = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 5157
    tmp___1 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 5157
  l_tcp = tmp___1;
#line 5161
  if (p_header_size < 2U) {
    {
#line 5162
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5163
    return (0);
  }
  {
#line 5167
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5168
  p_header_data += 2;
  }
#line 5169
  if (l_tmp != 0U) {
    {
#line 5170
    opj_event_msg(p_manager, 2, "Cannot take in charge mct data within multiple MCT records\n");
    }
#line 5171
    return (1);
  }
#line 5174
  if (p_header_size <= 6U) {
    {
#line 5175
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5176
    return (0);
  }
  {
#line 5180
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5181
  p_header_data += 2;
#line 5183
  l_indix = l_tmp & 255U;
#line 5184
  l_mct_data = l_tcp->m_mct_records;
#line 5186
  i = (OPJ_UINT32 )0;
  }
  {
#line 5186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5186
    if (! (i < l_tcp->m_nb_mct_records)) {
#line 5186
      goto while_break;
    }
#line 5187
    if (l_mct_data->m_index == l_indix) {
#line 5188
      goto while_break;
    }
#line 5190
    l_mct_data ++;
#line 5186
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5194
  if (i == l_tcp->m_nb_mct_records) {
#line 5195
    if (l_tcp->m_nb_mct_records == l_tcp->m_nb_max_mct_records) {
      {
#line 5197
      l_tcp->m_nb_max_mct_records += (unsigned int )10;
#line 5199
      __cil_tmp14 = realloc(l_tcp->m_mct_records, (unsigned long )l_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 5199
      new_mct_records = (opj_mct_data_t *)__cil_tmp14;
      }
#line 5200
      if (! new_mct_records) {
        {
#line 5201
        free(l_tcp->m_mct_records);
#line 5202
        l_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 5203
        l_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 5204
        l_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
#line 5205
        opj_event_msg(p_manager, 1, "Not enough memory to read MCT marker\n");
        }
#line 5206
        return (0);
      }
      {
#line 5208
      l_tcp->m_mct_records = new_mct_records;
#line 5209
      l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
#line 5210
      memset(l_mct_data, 0, (unsigned long )(l_tcp->m_nb_max_mct_records - l_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
      }
    }
#line 5213
    l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
  }
#line 5216
  if (l_mct_data->m_data) {
    {
#line 5217
    free(l_mct_data->m_data);
#line 5218
    l_mct_data->m_data = (OPJ_BYTE *)0;
    }
  }
  {
#line 5221
  l_mct_data->m_index = l_indix;
#line 5222
  l_mct_data->m_array_type = (J2K_MCT_ARRAY_TYPE )((l_tmp >> 8) & 3U);
#line 5223
  l_mct_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )((l_tmp >> 10) & 3U);
#line 5225
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5226
  p_header_data += 2;
  }
#line 5227
  if (l_tmp != 0U) {
    {
#line 5228
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple MCT markers\n");
    }
#line 5229
    return (1);
  }
  {
#line 5232
  p_header_size -= (unsigned int )6;
#line 5234
  __cil_tmp15 = malloc((unsigned long )p_header_size);
#line 5234
  l_mct_data->m_data = (OPJ_BYTE *)__cil_tmp15;
  }
#line 5235
  if (! l_mct_data->m_data) {
    {
#line 5236
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5237
    return (0);
  }
  {
#line 5239
  memcpy(l_mct_data->m_data, p_header_data, (unsigned long )p_header_size);
#line 5241
  l_mct_data->m_data_size = p_header_size;
#line 5242
  (l_tcp->m_nb_mct_records) ++;
  }
#line 5244
  return (1);
}
}
#line 5247 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k , struct opj_simple_mcc_decorrelation_data *p_mcc_record ,
                                  struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_mcc_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_bytes_for_comp ;
  OPJ_UINT32 l_mask ;
  OPJ_UINT32 l_tmcc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp15 ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
#line 5254
  l_current_data = (OPJ_BYTE *)0;
#line 5264
  if (p_mcc_record->m_nb_comps > 255U) {
#line 5265
    l_nb_bytes_for_comp = (OPJ_UINT32 )2;
#line 5266
    l_mask = (OPJ_UINT32 )32768;
  } else {
#line 5269
    l_nb_bytes_for_comp = (OPJ_UINT32 )1;
#line 5270
    l_mask = (OPJ_UINT32 )0;
  }
#line 5273
  l_mcc_size = (p_mcc_record->m_nb_comps * 2U) * l_nb_bytes_for_comp + 19U;
#line 5274
  if (l_mcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5276
    __cil_tmp15 = realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (unsigned long )l_mcc_size);
#line 5276
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp15;
    }
#line 5277
    if (! new_header_tile_data) {
      {
#line 5278
      free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5279
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5280
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5281
      opj_event_msg(p_manager, 1, "Not enough memory to write MCC marker\n");
      }
#line 5282
      return (0);
    }
#line 5284
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5285
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mcc_size;
  }
  {
#line 5288
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5290
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65397, (OPJ_UINT32 )2);
#line 5291
  l_current_data += 2;
#line 5293
  opj_write_bytes_LE(l_current_data, l_mcc_size - 2U, (OPJ_UINT32 )2);
#line 5294
  l_current_data += 2;
#line 5297
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5298
  l_current_data += 2;
#line 5300
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_index, (OPJ_UINT32 )1);
#line 5301
  l_current_data ++;
#line 5304
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5305
  l_current_data += 2;
#line 5307
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )1, (OPJ_UINT32 )2);
#line 5308
  l_current_data += 2;
#line 5310
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
#line 5311
  l_current_data ++;
#line 5313
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_nb_comps | l_mask, (OPJ_UINT32 )2);
#line 5314
  l_current_data += 2;
#line 5316
  i = (OPJ_UINT32 )0;
  }
  {
#line 5316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5316
    if (! (i < p_mcc_record->m_nb_comps)) {
#line 5316
      goto while_break;
    }
    {
#line 5317
    opj_write_bytes_LE(l_current_data, i, l_nb_bytes_for_comp);
#line 5318
    l_current_data += l_nb_bytes_for_comp;
    }
#line 5316
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5321
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_nb_comps | l_mask, (OPJ_UINT32 )2);
#line 5322
  l_current_data += 2;
#line 5324
  i = (OPJ_UINT32 )0;
  }
  {
#line 5324
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5324
    if (! (i < p_mcc_record->m_nb_comps)) {
#line 5324
      goto while_break___0;
    }
    {
#line 5326
    opj_write_bytes_LE(l_current_data, i, l_nb_bytes_for_comp);
#line 5327
    l_current_data += l_nb_bytes_for_comp;
    }
#line 5324
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5330
  l_tmcc = (! p_mcc_record->m_is_irreversible & 1) << 16;
#line 5332
  if (p_mcc_record->m_decorrelation_array) {
#line 5333
    l_tmcc |= (p_mcc_record->m_decorrelation_array)->m_index;
  }
#line 5336
  if (p_mcc_record->m_offset_array) {
#line 5337
    l_tmcc |= (p_mcc_record->m_offset_array)->m_index << 8;
  }
  {
#line 5340
  opj_write_bytes_LE(l_current_data, l_tmcc, (OPJ_UINT32 )3);
#line 5341
  l_current_data += 3;
#line 5343
  __cil_tmp16 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mcc_size, p_manager);
  }
#line 5343
  if (__cil_tmp16 != (unsigned long )l_mcc_size) {
#line 5344
    return (0);
  }
#line 5347
  return (1);
}
}
#line 5350 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                          opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_indix ;
  opj_tcp_t *l_tcp ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_mct_data ;
  OPJ_UINT32 l_nb_collections ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_nb_bytes_by_comp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  opj_tcp_t *tmp___2 ;
  opj_simple_mcc_decorrelation_data_t *new_mcc_records ;
  void *__cil_tmp20 ;

  {
#line 5370
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 5370
    tmp___2 = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 5370
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 5370
  l_tcp = tmp___2;
#line 5374
  if (p_header_size < 2U) {
    {
#line 5375
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
    }
#line 5376
    return (0);
  }
  {
#line 5380
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5381
  p_header_data += 2;
  }
#line 5382
  if (l_tmp != 0U) {
    {
#line 5383
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple data spanning\n");
    }
#line 5384
    return (1);
  }
#line 5387
  if (p_header_size < 7U) {
    {
#line 5388
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
    }
#line 5389
    return (0);
  }
  {
#line 5392
  opj_read_bytes_LE(p_header_data, & l_indix, (OPJ_UINT32 )1);
#line 5393
  p_header_data ++;
#line 5395
  l_mcc_record = l_tcp->m_mcc_records;
#line 5397
  i = (OPJ_UINT32 )0;
  }
  {
#line 5397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5397
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 5397
      goto while_break;
    }
#line 5398
    if (l_mcc_record->m_index == l_indix) {
#line 5399
      goto while_break;
    }
#line 5401
    l_mcc_record ++;
#line 5397
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5405
  if (i == l_tcp->m_nb_mcc_records) {
#line 5406
    if (l_tcp->m_nb_mcc_records == l_tcp->m_nb_max_mcc_records) {
      {
#line 5408
      l_tcp->m_nb_max_mcc_records += (unsigned int )10;
#line 5410
      __cil_tmp20 = realloc(l_tcp->m_mcc_records, (unsigned long )l_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 5410
      new_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp20;
      }
#line 5412
      if (! new_mcc_records) {
        {
#line 5413
        free(l_tcp->m_mcc_records);
#line 5414
        l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)((void *)0);
#line 5415
        l_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 5416
        l_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
#line 5417
        opj_event_msg(p_manager, 1, "Not enough memory to read MCC marker\n");
        }
#line 5418
        return (0);
      }
      {
#line 5420
      l_tcp->m_mcc_records = new_mcc_records;
#line 5421
      l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
#line 5422
      memset(l_mcc_record, 0, (unsigned long )(l_tcp->m_nb_max_mcc_records - l_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t ));
      }
    }
#line 5424
    l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
  }
  {
#line 5426
  l_mcc_record->m_index = l_indix;
#line 5429
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5430
  p_header_data += 2;
  }
#line 5431
  if (l_tmp != 0U) {
    {
#line 5432
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple data spanning\n");
    }
#line 5433
    return (1);
  }
  {
#line 5436
  opj_read_bytes_LE(p_header_data, & l_nb_collections, (OPJ_UINT32 )2);
#line 5437
  p_header_data += 2;
  }
#line 5439
  if (l_nb_collections > 1U) {
    {
#line 5440
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple collections\ni\347U");
    }
#line 5441
    return (1);
  }
#line 5444
  p_header_size -= (unsigned int )7;
#line 5446
  i = (OPJ_UINT32 )0;
  {
#line 5446
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5446
    if (! (i < l_nb_collections)) {
#line 5446
      goto while_break___0;
    }
#line 5447
    if (p_header_size < 3U) {
      {
#line 5448
      opj_event_msg(p_manager, 1, "Error reading MCC marker\nr\177i\347U");
      }
#line 5449
      return (0);
    }
    {
#line 5452
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 5453
    p_header_data ++;
    }
#line 5455
    if (l_tmp != 1U) {
      {
#line 5456
      opj_event_msg(p_manager, 2, "Cannot take in charge collections other than array decorrelation\n\315^h\347U");
      }
#line 5457
      return (1);
    }
    {
#line 5460
    opj_read_bytes_LE(p_header_data, & l_nb_comps, (OPJ_UINT32 )2);
#line 5462
    p_header_data += 2;
#line 5463
    p_header_size -= (unsigned int )3;
#line 5465
    l_nb_bytes_by_comp = 1U + (l_nb_comps >> 15);
#line 5466
    l_mcc_record->m_nb_comps = l_nb_comps & 32767U;
    }
#line 5468
    if (p_header_size < l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2U) {
      {
#line 5469
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
      }
#line 5470
      return (0);
    }
#line 5473
    p_header_size -= l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2U;
#line 5475
    j = (OPJ_UINT32 )0;
    {
#line 5475
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5475
      if (! (j < l_mcc_record->m_nb_comps)) {
#line 5475
        goto while_break___1;
      }
      {
#line 5476
      opj_read_bytes_LE(p_header_data, & l_tmp, l_nb_bytes_by_comp);
#line 5477
      p_header_data += l_nb_bytes_by_comp;
      }
#line 5479
      if (l_tmp != j) {
        {
#line 5480
        opj_event_msg(p_manager, 2, "Cannot take in charge collections with indix shuffle\n");
        }
#line 5481
        return (1);
      }
#line 5475
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 5485
    opj_read_bytes_LE(p_header_data, & l_nb_comps, (OPJ_UINT32 )2);
#line 5486
    p_header_data += 2;
#line 5488
    l_nb_bytes_by_comp = 1U + (l_nb_comps >> 15);
#line 5489
    l_nb_comps &= (unsigned int )32767;
    }
#line 5491
    if (l_nb_comps != l_mcc_record->m_nb_comps) {
      {
#line 5492
      opj_event_msg(p_manager, 2, "Cannot take in charge collections without same number of indixes\n");
      }
#line 5493
      return (1);
    }
#line 5496
    if (p_header_size < l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3U) {
      {
#line 5497
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
      }
#line 5498
      return (0);
    }
#line 5501
    p_header_size -= l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3U;
#line 5503
    j = (OPJ_UINT32 )0;
    {
#line 5503
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 5503
      if (! (j < l_mcc_record->m_nb_comps)) {
#line 5503
        goto while_break___2;
      }
      {
#line 5504
      opj_read_bytes_LE(p_header_data, & l_tmp, l_nb_bytes_by_comp);
#line 5505
      p_header_data += l_nb_bytes_by_comp;
      }
#line 5507
      if (l_tmp != j) {
        {
#line 5508
        opj_event_msg(p_manager, 2, "Cannot take in charge collections with indix shuffle\n");
        }
#line 5509
        return (1);
      }
#line 5503
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 5513
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )3);
#line 5514
    p_header_data += 3;
#line 5516
    l_mcc_record->m_is_irreversible = ! ((l_tmp >> 16) & 1U);
#line 5517
    l_mcc_record->m_decorrelation_array = (opj_mct_data_t *)0;
#line 5518
    l_mcc_record->m_offset_array = (opj_mct_data_t *)0;
#line 5520
    l_indix = l_tmp & 255U;
    }
#line 5521
    if (l_indix != 0U) {
#line 5522
      l_mct_data = l_tcp->m_mct_records;
#line 5523
      j = (OPJ_UINT32 )0;
      {
#line 5523
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 5523
        if (! (j < l_tcp->m_nb_mct_records)) {
#line 5523
          goto while_break___3;
        }
#line 5524
        if (l_mct_data->m_index == l_indix) {
#line 5525
          l_mcc_record->m_decorrelation_array = l_mct_data;
#line 5526
          goto while_break___3;
        }
#line 5528
        l_mct_data ++;
#line 5523
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 5531
      if (l_mcc_record->m_decorrelation_array == (opj_mct_data_t *)0) {
        {
#line 5532
        opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
        }
#line 5533
        return (0);
      }
    }
#line 5537
    l_indix = (l_tmp >> 8) & 255U;
#line 5538
    if (l_indix != 0U) {
#line 5539
      l_mct_data = l_tcp->m_mct_records;
#line 5540
      j = (OPJ_UINT32 )0;
      {
#line 5540
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 5540
        if (! (j < l_tcp->m_nb_mct_records)) {
#line 5540
          goto while_break___4;
        }
#line 5541
        if (l_mct_data->m_index == l_indix) {
#line 5542
          l_mcc_record->m_offset_array = l_mct_data;
#line 5543
          goto while_break___4;
        }
#line 5545
        l_mct_data ++;
#line 5540
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 5548
      if (l_mcc_record->m_offset_array == (opj_mct_data_t *)0) {
        {
#line 5549
        opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
        }
#line 5550
        return (0);
      }
    }
#line 5446
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5555
  if (p_header_size != 0U) {
    {
#line 5556
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
    }
#line 5557
    return (0);
  }
#line 5560
  (l_tcp->m_nb_mcc_records) ++;
#line 5562
  return (1);
}
}
#line 5565 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_mco_size ;
  opj_tcp_t *l_tcp ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  OPJ_UINT32 i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
#line 5570
  l_current_data = (OPJ_BYTE *)0;
#line 5572
  l_tcp = (opj_tcp_t *)0;
#line 5581
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 5582
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5584
  l_mco_size = 5U + l_tcp->m_nb_mcc_records;
#line 5585
  if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5587
    __cil_tmp13 = realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (unsigned long )l_mco_size);
#line 5587
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp13;
    }
#line 5588
    if (! new_header_tile_data) {
      {
#line 5589
      free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5590
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5591
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5592
      opj_event_msg(p_manager, 1, "Not enough memory to write MCO marker\n");
      }
#line 5593
      return (0);
    }
#line 5595
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5596
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;
  }
  {
#line 5599
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65399, (OPJ_UINT32 )2);
#line 5600
  l_current_data += 2;
#line 5602
  opj_write_bytes_LE(l_current_data, l_mco_size - 2U, (OPJ_UINT32 )2);
#line 5603
  l_current_data += 2;
#line 5605
  opj_write_bytes_LE(l_current_data, l_tcp->m_nb_mcc_records, (OPJ_UINT32 )1);
#line 5606
  l_current_data ++;
#line 5608
  l_mcc_record = l_tcp->m_mcc_records;
#line 5609
  i = (OPJ_UINT32 )0;
  }
  {
#line 5609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5609
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 5609
      goto while_break;
    }
    {
#line 5610
    opj_write_bytes_LE(l_current_data, l_mcc_record->m_index, (OPJ_UINT32 )1);
#line 5611
    l_current_data ++;
#line 5613
    l_mcc_record ++;
    }
#line 5609
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5616
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mco_size, p_manager);
  }
#line 5616
  if (__cil_tmp14 != (unsigned long )l_mco_size) {
#line 5617
    return (0);
  }
#line 5620
  return (1);
}
}
#line 5631 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_stages ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_t *l_image ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  opj_tcp_t *tmp___2 ;
  OPJ_BOOL __cil_tmp15 ;

  {
#line 5648
  l_image = p_j2k->m_private_image;
#line 5649
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 5649
    tmp___2 = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 5649
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 5649
  l_tcp = tmp___2;
#line 5653
  if (p_header_size < 1U) {
    {
#line 5654
    opj_event_msg(p_manager, 1, "Error reading MCO marker\n\372\177i\347U");
    }
#line 5655
    return (0);
  }
  {
#line 5658
  opj_read_bytes_LE(p_header_data, & l_nb_stages, (OPJ_UINT32 )1);
#line 5659
  p_header_data ++;
  }
#line 5661
  if (l_nb_stages > 1U) {
    {
#line 5662
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple transformation stages.\n");
    }
#line 5663
    return (1);
  }
#line 5666
  if (p_header_size != l_nb_stages + 1U) {
    {
#line 5667
    opj_event_msg(p_manager, 2, "Error reading MCO marker\n");
    }
#line 5668
    return (0);
  }
#line 5671
  l_tccp = l_tcp->tccps;
#line 5673
  i = (OPJ_UINT32 )0;
  {
#line 5673
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5673
    if (! (i < l_image->numcomps)) {
#line 5673
      goto while_break;
    }
#line 5674
    l_tccp->m_dc_level_shift = 0;
#line 5675
    l_tccp ++;
#line 5673
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5678
  if (l_tcp->m_mct_decoding_matrix) {
    {
#line 5679
    free(l_tcp->m_mct_decoding_matrix);
#line 5680
    l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 5683
  i = (OPJ_UINT32 )0;
  {
#line 5683
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5683
    if (! (i < l_nb_stages)) {
#line 5683
      goto while_break___0;
    }
    {
#line 5684
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 5685
    p_header_data ++;
#line 5687
    __cil_tmp15 = opj_j2k_add_mct(l_tcp, p_j2k->m_private_image, l_tmp);
    }
#line 5687
    if (! __cil_tmp15) {
#line 5688
      return (0);
    }
#line 5683
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5692
  return (1);
}
}
#line 5695 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_add_mct(opj_tcp_t *p_tcp , opj_image_t *p_image , OPJ_UINT32 p_index ) 
{ 
  OPJ_UINT32 i ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_deco_array ;
  opj_mct_data_t *l_offset_array ;
  OPJ_UINT32 l_data_size ;
  OPJ_UINT32 l_mct_size ;
  OPJ_UINT32 l_offset_size ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_UINT32 *l_offset_data ;
  OPJ_UINT32 *l_current_offset_data ;
  opj_tccp_t *l_tccp ;
  int tmp ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  OPJ_UINT32 *__cil_tmp18 ;

  {
#line 5708
  l_mcc_record = p_tcp->m_mcc_records;
#line 5710
  i = (OPJ_UINT32 )0;
  {
#line 5710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5710
    if (! (i < p_tcp->m_nb_mcc_records)) {
#line 5710
      goto while_break;
    }
#line 5711
    if (l_mcc_record->m_index == p_index) {
#line 5712
      goto while_break;
    }
#line 5710
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5716
  if (i == p_tcp->m_nb_mcc_records) {
#line 5718
    return (1);
  }
#line 5721
  if (l_mcc_record->m_nb_comps != p_image->numcomps) {
#line 5723
    return (1);
  }
#line 5726
  l_deco_array = l_mcc_record->m_decorrelation_array;
#line 5728
  if (l_deco_array) {
#line 5729
    l_data_size = (MCT_ELEMENT_SIZE[l_deco_array->m_element_type] * p_image->numcomps) * p_image->numcomps;
#line 5730
    if (l_deco_array->m_data_size != l_data_size) {
#line 5731
      return (0);
    }
    {
#line 5734
    l_nb_elem = p_image->numcomps * p_image->numcomps;
#line 5735
    l_mct_size = l_nb_elem * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 5736
    __cil_tmp16 = malloc((unsigned long )l_mct_size);
#line 5736
    p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp16;
    }
#line 5738
    if (! p_tcp->m_mct_decoding_matrix) {
#line 5739
      return (0);
    }
    {
#line 5742
    (*(j2k_mct_read_functions_to_float[l_deco_array->m_element_type]))(l_deco_array->m_data,
                                                                       p_tcp->m_mct_decoding_matrix,
                                                                       l_nb_elem);
    }
  }
#line 5745
  l_offset_array = l_mcc_record->m_offset_array;
#line 5747
  if (l_offset_array) {
#line 5748
    l_data_size = MCT_ELEMENT_SIZE[l_offset_array->m_element_type] * p_image->numcomps;
#line 5749
    if (l_offset_array->m_data_size != l_data_size) {
#line 5750
      return (0);
    }
    {
#line 5753
    l_nb_elem = p_image->numcomps;
#line 5754
    l_offset_size = l_nb_elem * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 5755
    __cil_tmp17 = malloc((unsigned long )l_offset_size);
#line 5755
    l_offset_data = (OPJ_UINT32 *)__cil_tmp17;
    }
#line 5757
    if (! l_offset_data) {
#line 5758
      return (0);
    }
    {
#line 5761
    (*(j2k_mct_read_functions_to_int32[l_offset_array->m_element_type]))(l_offset_array->m_data,
                                                                         l_offset_data,
                                                                         l_nb_elem);
#line 5763
    l_tccp = p_tcp->tccps;
#line 5764
    l_current_offset_data = l_offset_data;
#line 5766
    i = (OPJ_UINT32 )0;
    }
    {
#line 5766
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5766
      if (! (i < p_image->numcomps)) {
#line 5766
        goto while_break___0;
      }
#line 5767
      __cil_tmp18 = l_current_offset_data;
#line 5767
      l_current_offset_data ++;
#line 5767
      l_tccp->m_dc_level_shift = (OPJ_INT32 )*__cil_tmp18;
#line 5768
      l_tccp ++;
#line 5766
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 5771
    free(l_offset_data);
    }
  }
#line 5774
  return (1);
}
}
#line 5777 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_cbd_size ;
  OPJ_BYTE *l_current_data ;
  opj_image_t *l_image ;
  opj_image_comp_t *l_comp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
#line 5783
  l_current_data = (OPJ_BYTE *)0;
#line 5784
  l_image = (opj_image_t *)0;
#line 5785
  l_comp = (opj_image_comp_t *)0;
#line 5792
  l_image = p_j2k->m_private_image;
#line 5793
  l_cbd_size = 6U + (p_j2k->m_private_image)->numcomps;
#line 5795
  if (l_cbd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5796
    __cil_tmp13 = realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (unsigned long )l_cbd_size);
#line 5796
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp13;
    }
#line 5797
    if (! new_header_tile_data) {
      {
#line 5798
      free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5799
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5800
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5801
      opj_event_msg(p_manager, 1, "Not enough memory to write CBD marker\n");
      }
#line 5802
      return (0);
    }
#line 5804
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5805
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_cbd_size;
  }
  {
#line 5808
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5810
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65400, (OPJ_UINT32 )2);
#line 5811
  l_current_data += 2;
#line 5813
  opj_write_bytes_LE(l_current_data, l_cbd_size - 2U, (OPJ_UINT32 )2);
#line 5814
  l_current_data += 2;
#line 5816
  opj_write_bytes_LE(l_current_data, l_image->numcomps, (OPJ_UINT32 )2);
#line 5817
  l_current_data += 2;
#line 5819
  l_comp = l_image->comps;
#line 5821
  i = (OPJ_UINT32 )0;
  }
  {
#line 5821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5821
    if (! (i < l_image->numcomps)) {
#line 5821
      goto while_break;
    }
    {
#line 5822
    opj_write_bytes_LE(l_current_data, (l_comp->sgnd << 7) | (l_comp->prec - 1U),
                       (OPJ_UINT32 )1);
#line 5823
    l_current_data ++;
#line 5825
    l_comp ++;
    }
#line 5821
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5828
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_cbd_size, p_manager);
  }
#line 5828
  if (__cil_tmp14 != (unsigned long )l_cbd_size) {
#line 5829
    return (0);
  }
#line 5832
  return (1);
}
}
#line 5842 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_num_comp ;
  OPJ_UINT32 l_comp_def ;
  OPJ_UINT32 i ;
  opj_image_comp_t *l_comp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 5851
  l_comp = (opj_image_comp_t *)0;
#line 5858
  l_num_comp = (p_j2k->m_private_image)->numcomps;
#line 5860
  if (p_header_size != (p_j2k->m_private_image)->numcomps + 2U) {
    {
#line 5861
    opj_event_msg(p_manager, 1, "Crror reading CBD marker\nS\200i\347U");
    }
#line 5862
    return (0);
  }
  {
#line 5865
  opj_read_bytes_LE(p_header_data, & l_nb_comp, (OPJ_UINT32 )2);
#line 5866
  p_header_data += 2;
  }
#line 5868
  if (l_nb_comp != l_num_comp) {
    {
#line 5869
    opj_event_msg(p_manager, 1, "Crror reading CBD marker\nA}i\347U");
    }
#line 5870
    return (0);
  }
#line 5873
  l_comp = (p_j2k->m_private_image)->comps;
#line 5874
  i = (OPJ_UINT32 )0;
  {
#line 5874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5874
    if (! (i < l_num_comp)) {
#line 5874
      goto while_break;
    }
    {
#line 5875
    opj_read_bytes_LE(p_header_data, & l_comp_def, (OPJ_UINT32 )1);
#line 5876
    p_header_data ++;
#line 5877
    l_comp->sgnd = (l_comp_def >> 7) & 1U;
#line 5878
    l_comp->prec = (l_comp_def & 127U) + 1U;
#line 5879
    l_comp ++;
    }
#line 5874
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5882
  return (1);
}
}
#line 5889 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) 
{ 


  {
#line 5891
  if (j2k) {
#line 5891
    if (parameters) {
#line 5892
      j2k->m_cp.m_specific_param.m_dec.m_layer = parameters->cp_layer;
#line 5893
      j2k->m_cp.m_specific_param.m_dec.m_reduce = parameters->cp_reduce;
    }
  }
  return;
}
}
#line 5907 "/root/patron/new_21/src/lib/openjp2/j2k.c"
opj_j2k_t *opj_j2k_create_compress(void) 
{ 
  opj_j2k_t *l_j2k ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  opj_procedure_list_t *__cil_tmp4 ;
  opj_procedure_list_t *__cil_tmp5 ;

  {
  {
#line 5909
  __cil_tmp2 = calloc((unsigned long )1, sizeof(opj_j2k_t ));
#line 5909
  l_j2k = (opj_j2k_t *)__cil_tmp2;
  }
#line 5910
  if (! l_j2k) {
#line 5911
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 5915
  l_j2k->m_is_decoder = 0;
#line 5916
  l_j2k->m_cp.m_is_decoder = (OPJ_UINT32 )0;
#line 5918
  __cil_tmp3 = malloc((unsigned long )1000);
#line 5918
  l_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)__cil_tmp3;
  }
#line 5919
  if (! l_j2k->m_specific_param.m_encoder.m_header_tile_data) {
    {
#line 5920
    opj_j2k_destroy(l_j2k);
    }
#line 5921
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 5924
  l_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )1000;
#line 5927
  l_j2k->m_validation_list = opj_procedure_list_create();
  }
#line 5928
  if (! l_j2k->m_validation_list) {
    {
#line 5929
    opj_j2k_destroy(l_j2k);
    }
#line 5930
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 5934
  l_j2k->m_procedure_list = opj_procedure_list_create();
  }
#line 5935
  if (! l_j2k->m_procedure_list) {
    {
#line 5936
    opj_j2k_destroy(l_j2k);
    }
#line 5937
    return ((opj_j2k_t *)((void *)0));
  }
#line 5940
  return (l_j2k);
}
}
#line 5943 "/root/patron/new_21/src/lib/openjp2/j2k.c"
int opj_j2k_initialise_4K_poc(opj_poc_t *POC , int numres ) 
{ 


  {
#line 5944
  (POC + 0)->tile = (OPJ_UINT32 )1;
#line 5945
  (POC + 0)->resno0 = (OPJ_UINT32 )0;
#line 5946
  (POC + 0)->compno0 = (OPJ_UINT32 )0;
#line 5947
  (POC + 0)->layno1 = (OPJ_UINT32 )1;
#line 5948
  (POC + 0)->resno1 = (OPJ_UINT32 )(numres - 1);
#line 5949
  (POC + 0)->compno1 = (OPJ_UINT32 )3;
#line 5950
  (POC + 0)->prg1 = (OPJ_PROG_ORDER )4;
#line 5951
  (POC + 1)->tile = (OPJ_UINT32 )1;
#line 5952
  (POC + 1)->resno0 = (OPJ_UINT32 )(numres - 1);
#line 5953
  (POC + 1)->compno0 = (OPJ_UINT32 )0;
#line 5954
  (POC + 1)->layno1 = (OPJ_UINT32 )1;
#line 5955
  (POC + 1)->resno1 = (OPJ_UINT32 )numres;
#line 5956
  (POC + 1)->compno1 = (OPJ_UINT32 )3;
#line 5957
  (POC + 1)->prg1 = (OPJ_PROG_ORDER )4;
#line 5958
  return (2);
}
}
#line 5961 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  int i ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 5967
  parameters->tile_size_on = 0;
#line 5968
  parameters->cp_tdx = 1;
#line 5969
  parameters->cp_tdy = 1;
#line 5972
  parameters->tp_flag = (char )'C';
#line 5973
  parameters->tp_on = (char )1;
#line 5976
  parameters->cp_tx0 = 0;
#line 5977
  parameters->cp_ty0 = 0;
#line 5978
  parameters->image_offset_x0 = 0;
#line 5979
  parameters->image_offset_y0 = 0;
#line 5982
  parameters->cblockw_init = 32;
#line 5983
  parameters->cblockh_init = 32;
#line 5986
  parameters->mode = 0;
#line 5989
  parameters->roi_compno = - 1;
#line 5992
  parameters->subsampling_dx = 1;
#line 5993
  parameters->subsampling_dy = 1;
#line 5996
  parameters->irreversible = 1;
#line 5999
  if (parameters->tcp_numlayers > 1) {
    {
#line 6000
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n1 single quality layer-> Number of layers forced to 1 (rather than %d)\n-> Rate of the last layer (%3.1f) will be used\230\001",
                  parameters->tcp_numlayers, (double )parameters->tcp_rates[parameters->tcp_numlayers - 1]);
#line 6006
    parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];
#line 6007
    parameters->tcp_numlayers = 1;
    }
  }
  {
#line 6012
  if ((int )parameters->rsiz == 3) {
#line 6012
    goto case_3;
  }
#line 6022
  if ((int )parameters->rsiz == 4) {
#line 6022
    goto case_4;
  }
#line 6039
  goto switch_default;
  case_3: /* CIL Label */ 
#line 6013
  if (parameters->numresolution > 6) {
    {
#line 6014
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nNumber of decomposition levels <= 5\n-> Number of decomposition levels forced to 5 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 6019
    parameters->numresolution = 6;
    }
  }
#line 6021
  goto switch_break;
  case_4: /* CIL Label */ 
#line 6023
  if (parameters->numresolution < 2) {
    {
#line 6024
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 1 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 6029
    parameters->numresolution = 1;
    }
  } else
#line 6030
  if (parameters->numresolution > 7) {
    {
#line 6031
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 6 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 6036
    parameters->numresolution = 7;
    }
  }
#line 6038
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 6040
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 6044
  parameters->csty |= 1;
#line 6045
  parameters->res_spec = parameters->numresolution - 1;
#line 6046
  i = 0;
  {
#line 6046
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6046
    if (! (i < parameters->res_spec)) {
#line 6046
      goto while_break;
    }
#line 6047
    parameters->prcw_init[i] = 256;
#line 6048
    parameters->prch_init[i] = 256;
#line 6046
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6052
  parameters->prog_order = (OPJ_PROG_ORDER )4;
#line 6055
  if ((int )parameters->rsiz == 4) {
    {
#line 6056
    __cil_tmp6 = opj_j2k_initialise_4K_poc((opj_poc_t *)parameters->POC, parameters->numresolution);
#line 6056
    parameters->numpocs = (OPJ_UINT32 )__cil_tmp6;
    }
  } else {
#line 6058
    parameters->numpocs = (OPJ_UINT32 )0;
  }
#line 6062
  parameters->cp_disto_alloc = 1;
#line 6063
  if (parameters->max_cs_size <= 0) {
    {
#line 6065
    parameters->max_cs_size = 1302083;
#line 6066
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1302083 compressed bytes @ 24fps\nAs no rate has been given, this limit will be used.\n");
    }
  } else
#line 6070
  if (parameters->max_cs_size > 1302083) {
    {
#line 6071
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1302083 compressed bytes @ 24fps\n-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\n");
#line 6075
    parameters->max_cs_size = 1302083;
    }
  }
#line 6078
  if (parameters->max_comp_size <= 0) {
    {
#line 6080
    parameters->max_comp_size = 1041666;
#line 6081
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1041666 compressed bytes @ 24fps\nAs no rate has been given, this limit will be used.\n");
    }
  } else
#line 6085
  if (parameters->max_comp_size > 1041666) {
    {
#line 6086
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1041666 compressed bytes @ 24fps\n-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\n");
#line 6090
    parameters->max_comp_size = 1041666;
    }
  }
#line 6093
  parameters->tcp_rates[0] = (OPJ_FLOAT32 )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (OPJ_FLOAT32 )((((OPJ_UINT32 )parameters->max_cs_size * 8U) * (image->comps + 0)->dx) * (image->comps + 0)->dy);
  return;
}
}
#line 6098 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image , OPJ_UINT16 rsiz , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  char signed_str[7] ;
  char unsigned_str[9] ;
  char *tmp_str ;
  char *tmp ;
  OPJ_UINT32 __cil_tmp9 ;

  {
#line 6103
  if (image->numcomps != 3U) {
    {
#line 6104
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\n3 components-> Number of components of input image (%d) is not compliant\n-> Non-profile-3 codestream will be generated\n",
                  image->numcomps);
    }
#line 6110
    return (0);
  }
#line 6114
  i = (OPJ_UINT32 )0;
  {
#line 6114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6114
    if (! (i < image->numcomps)) {
#line 6114
      goto while_break;
    }
#line 6115
    if (((image->comps + i)->bpp != 12U) | (image->comps + i)->sgnd) {
#line 6116
      strcpy((char *)signed_str, "signed");;
#line 6117
      strcpy((char *)unsigned_str, "unsigned\f");;
#line 6118
      if ((image->comps + i)->sgnd) {
#line 6118
        tmp = (char *)signed_str;
      } else {
#line 6118
        tmp = (char *)unsigned_str;
      }
      {
#line 6118
      tmp_str = tmp;
#line 6119
      opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nPrecision of each component shall be 12 bits unsigned-> At least component %d of input image (%d bits, %s) is not compliant\n-> Non-profile-3 codestream will be generated\n",
                    i, (image->comps + i)->bpp, tmp_str);
      }
#line 6125
      return (0);
    }
#line 6114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6131
  if ((int )rsiz == 3) {
#line 6131
    goto case_3;
  }
#line 6142
  if ((int )rsiz == 4) {
#line 6142
    goto case_4;
  }
#line 6153
  goto switch_default;
  case_3: /* CIL Label */ 
#line 6132
  if (((image->comps + 0)->w > 2048U) | ((image->comps + 0)->h > 1080U)) {
    {
#line 6133
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nwidth <= 2048 and height <= 1080\n-> Input image size %d x %d is not compliant\n-> Non-profile-3 codestream will be generated\n",
                  (image->comps + 0)->w, (image->comps + 0)->h);
    }
#line 6139
    return (0);
  }
#line 6141
  goto switch_break;
  case_4: /* CIL Label */ 
#line 6143
  if (((image->comps + 0)->w > 4096U) | ((image->comps + 0)->h > 2160U)) {
    {
#line 6144
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nwidth <= 4096 and height <= 2160\n-> Image size %d x %d is not compliant\n-> Non-profile-4 codestream will be generated\n\230\001",
                  (image->comps + 0)->w, (image->comps + 0)->h);
    }
#line 6150
    return (0);
  }
#line 6152
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 6154
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 6157
  return (1);
}
}
#line 6160 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_setup_encoder(opj_j2k_t *p_j2k , opj_cparameters_t *parameters ,
                               opj_image_t *image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 tileno ;
  OPJ_UINT32 numpocs_tile ;
  opj_cp_t *cp ;
  OPJ_BOOL deprecated_used ;
  OPJ_FLOAT32 temp_size ;
  double __cil_tmp12 ;
  OPJ_FLOAT32 temp_rate ;
  OPJ_BOOL cap ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  size_t array_size ;
  void *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  void *__cil_tmp20 ;
  char const   comment[29] ;
  size_t clen ;
  unsigned long __cil_tmp23 ;
  char const   *version ;
  char const   *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  void *__cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;
  void *__cil_tmp30 ;
  opj_tcp_t *tcp ;
  OPJ_UINT32 __cil_tmp32 ;
  opj_poc_t *tcp_poc ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;
  void *__cil_tmp36 ;
  OPJ_UINT32 lMctSize ;
  OPJ_FLOAT32 *lTmpBuf ;
  void *__cil_tmp39 ;
  OPJ_INT32 *l_dc_shift ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  OPJ_BOOL __cil_tmp43 ;
  void *__cil_tmp44 ;
  opj_tccp_t *tccp ;
  OPJ_UINT32 __cil_tmp46 ;
  OPJ_BOOL __cil_tmp47 ;
  opj_tccp_t *tccp___0 ;
  opj_image_comp_t *l_comp ;
  OPJ_UINT32 __cil_tmp50 ;
  opj_tccp_t *tccp___1 ;
  OPJ_INT32 __cil_tmp52 ;
  OPJ_INT32 __cil_tmp53 ;
  int tmp ;
  int tmp___0 ;
  OPJ_INT32 p ;
  OPJ_INT32 it_res ;
  int tmp___1 ;
  OPJ_INT32 __cil_tmp59 ;
  OPJ_INT32 __cil_tmp60 ;
  OPJ_INT32 res_spec ;
  OPJ_INT32 size_prcw ;
  OPJ_INT32 size_prch ;
  int tmp___2 ;
  OPJ_INT32 __cil_tmp65 ;
  OPJ_INT32 __cil_tmp66 ;
  OPJ_INT32 __cil_tmp67 ;
  OPJ_INT32 __cil_tmp68 ;
  OPJ_UINT32 __cil_tmp69 ;
  OPJ_UINT32 __cil_tmp70 ;
  OPJ_UINT32 __cil_tmp71 ;

  {
#line 6166
  cp = (opj_cp_t *)0;
#line 6168
  if (! p_j2k) {
#line 6169
    return (0);
  } else
#line 6168
  if (! parameters) {
#line 6169
    return (0);
  } else
#line 6168
  if (! image) {
#line 6169
    return (0);
  }
#line 6172
  if (parameters->numresolution <= 0) {
    {
    {
#line 6173
    opj_event_msg(p_manager, 1, "Invalid number of resolutions : %d not in range [1,%d]\n",
                  parameters->numresolution, 33);
    }
    }
#line 6174
    return (0);
  } else
#line 6172
  if (parameters->numresolution > 33) {
    {
    {
#line 6173
    opj_event_msg(p_manager, 1, "Invalid number of resolutions : %d not in range [1,%d]\n",
                  parameters->numresolution, 33);
    }
    }
#line 6174
    return (0);
  }
#line 6178
  cp = & p_j2k->m_cp;
#line 6181
  cp->tw = (OPJ_UINT32 )1;
#line 6182
  cp->th = (OPJ_UINT32 )1;
#line 6185
  if ((int )parameters->rsiz == 0) {
#line 6186
    deprecated_used = 0;
    {
#line 6188
    if ((unsigned int )parameters->cp_cinema == (unsigned int )1) {
#line 6188
      goto case_1;
    }
#line 6194
    if ((unsigned int )parameters->cp_cinema == (unsigned int )2) {
#line 6194
      goto case_2;
    }
#line 6200
    if ((unsigned int )parameters->cp_cinema == (unsigned int )3) {
#line 6200
      goto case_3;
    }
#line 6207
    goto switch_default;
    case_1: /* CIL Label */ 
#line 6189
    parameters->rsiz = (OPJ_UINT16 )3;
#line 6190
    parameters->max_cs_size = 1302083;
#line 6191
    parameters->max_comp_size = 1041666;
#line 6192
    deprecated_used = 1;
#line 6193
    goto switch_break;
    case_2: /* CIL Label */ 
#line 6195
    parameters->rsiz = (OPJ_UINT16 )3;
#line 6196
    parameters->max_cs_size = 651041;
#line 6197
    parameters->max_comp_size = 520833;
#line 6198
    deprecated_used = 1;
#line 6199
    goto switch_break;
    case_3: /* CIL Label */ 
#line 6201
    parameters->rsiz = (OPJ_UINT16 )4;
#line 6202
    parameters->max_cs_size = 1302083;
#line 6203
    parameters->max_comp_size = 1041666;
#line 6204
    deprecated_used = 1;
#line 6205
    goto switch_break;
    switch_default: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 6208
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 6211
    if ((unsigned int )parameters->cp_rsiz == (unsigned int )3) {
#line 6211
      goto case_3___0;
    }
#line 6215
    if ((unsigned int )parameters->cp_rsiz == (unsigned int )4) {
#line 6215
      goto case_4;
    }
#line 6219
    if ((unsigned int )parameters->cp_rsiz == (unsigned int )33024) {
#line 6219
      goto case_33024;
    }
#line 6223
    goto switch_default___0;
    case_3___0: /* CIL Label */ 
#line 6212
    parameters->rsiz = (OPJ_UINT16 )3;
#line 6213
    deprecated_used = 1;
#line 6214
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 6216
    parameters->rsiz = (OPJ_UINT16 )4;
#line 6217
    deprecated_used = 1;
#line 6218
    goto switch_break___0;
    case_33024: /* CIL Label */ 
#line 6220
    parameters->rsiz = (OPJ_UINT16 )33024;
#line 6221
    deprecated_used = 1;
    switch_default___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 6224
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 6226
    if (deprecated_used) {
      {
#line 6227
      opj_event_msg(p_manager, 2, "Deprecated fields cp_cinema or cp_rsiz are used\nPlease consider using only the rsiz field\nSee openjpeg.h documentation for more details\n\220");
      }
    }
  }
#line 6235
  if (parameters->max_cs_size <= 0) {
#line 6236
    if (parameters->tcp_rates[parameters->tcp_numlayers - 1] > (float )0) {
      {
#line 6238
      temp_size = (OPJ_FLOAT32 )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (((parameters->tcp_rates[parameters->tcp_numlayers - 1] * (float )8) * (OPJ_FLOAT32 )(image->comps + 0)->dx) * (OPJ_FLOAT32 )(image->comps + 0)->dy);
#line 6240
      __cil_tmp12 = floor((double )temp_size);
#line 6240
      parameters->max_cs_size = (int )__cil_tmp12;
      }
    } else {
#line 6242
      parameters->max_cs_size = 0;
    }
  } else {
#line 6246
    cap = 0;
#line 6247
    temp_rate = (OPJ_FLOAT32 )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (OPJ_FLOAT32 )((((OPJ_UINT32 )parameters->max_cs_size * 8U) * (image->comps + 0)->dx) * (image->comps + 0)->dy);
#line 6249
    i = (OPJ_UINT32 )0;
    {
#line 6249
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6249
      if (! (i < (OPJ_UINT32 )parameters->tcp_numlayers)) {
#line 6249
        goto while_break;
      }
#line 6250
      if (parameters->tcp_rates[i] < temp_rate) {
#line 6251
        parameters->tcp_rates[i] = temp_rate;
#line 6252
        cap = 1;
      }
#line 6249
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 6255
    if (cap) {
      {
#line 6256
      opj_event_msg(p_manager, 2, "The desired maximum codestream size has limited\nat least one of the desired quality layers\n");
      }
    }
  }
#line 6264
  if ((int )parameters->rsiz >= 3) {
#line 6264
    if ((int )parameters->rsiz <= 6) {
#line 6265
      if ((int )parameters->rsiz == 5) {
        {
        {
#line 6267
        opj_event_msg(p_manager, 2, "JPEG 2000 Scalable Digital Cinema profiles not yet supported\n");
        }
#line 6269
        parameters->rsiz = (OPJ_UINT16 )0;
        }
      } else
#line 6265
      if ((int )parameters->rsiz == 6) {
        {
        {
#line 6267
        opj_event_msg(p_manager, 2, "JPEG 2000 Scalable Digital Cinema profiles not yet supported\n");
        }
#line 6269
        parameters->rsiz = (OPJ_UINT16 )0;
        }
      } else {
        {
#line 6271
        opj_j2k_set_cinema_parameters(parameters, image, p_manager);
#line 6272
        __cil_tmp16 = opj_j2k_is_cinema_compliant(image, parameters->rsiz, p_manager);
        }
#line 6272
        if (! __cil_tmp16) {
#line 6273
          parameters->rsiz = (OPJ_UINT16 )0;
        }
      }
    } else {
#line 6264
      goto _L___11;
    }
  } else
  _L___11: /* CIL Label */ 
#line 6276
  if ((int )parameters->rsiz == 7) {
    {
#line 6277
    opj_event_msg(p_manager, 2, "JPEG 2000 Long Term Storage profile not yet supported\n");
#line 6279
    parameters->rsiz = (OPJ_UINT16 )0;
    }
  } else
#line 6280
  if ((int )parameters->rsiz >= 256) {
#line 6280
    if ((int )parameters->rsiz <= 779) {
      {
#line 6281
      opj_event_msg(p_manager, 2, "JPEG 2000 Broadcast profiles not yet supported\n");
#line 6283
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    } else {
#line 6280
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 6284
  if ((int )parameters->rsiz >= 1024) {
#line 6284
    if ((int )parameters->rsiz <= 2203) {
      {
#line 6285
      opj_event_msg(p_manager, 2, "JPEG 2000 IMF profiles not yet supported\n");
#line 6287
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    } else {
#line 6284
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 6288
  if ((int )parameters->rsiz & 32768) {
#line 6289
    if ((int )parameters->rsiz == 32768) {
      {
#line 6290
      opj_event_msg(p_manager, 2, "JPEG 2000 Part-2 profile defined\nbut no Part-2 extension enabled.\nProfile set to NONE.\n");
#line 6294
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    } else
#line 6295
    if ((int )parameters->rsiz != 33024) {
      {
#line 6296
      opj_event_msg(p_manager, 2, "Unsupported Part-2 extension enabled\nProfile set to NONE.\n");
#line 6299
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    }
  }
#line 6306
  cp->m_specific_param.m_enc.m_max_comp_size = (OPJ_UINT32 )parameters->max_comp_size;
#line 6307
  cp->rsiz = parameters->rsiz;
#line 6308
  cp->m_specific_param.m_enc.m_disto_alloc = (OPJ_UINT32 )parameters->cp_disto_alloc & 1U;
#line 6309
  cp->m_specific_param.m_enc.m_fixed_alloc = (OPJ_UINT32 )parameters->cp_fixed_alloc & 1U;
#line 6310
  cp->m_specific_param.m_enc.m_fixed_quality = (OPJ_UINT32 )parameters->cp_fixed_quality & 1U;
#line 6313
  if (parameters->cp_matrice) {
#line 6313
    if (parameters->cp_fixed_alloc) {
      {
#line 6314
      array_size = (((size_t )parameters->tcp_numlayers * (size_t )parameters->numresolution) * 3UL) * sizeof(OPJ_INT32 );
#line 6315
      __cil_tmp18 = malloc(array_size);
#line 6315
      cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *)__cil_tmp18;
      }
#line 6316
      if (! cp->m_specific_param.m_enc.m_matrice) {
        {
#line 6317
        opj_event_msg(p_manager, 1, "Not enough memory to allocate copy of user encoding parameters matrix \n");
        }
#line 6318
        return (0);
      }
      {
#line 6320
      memcpy(cp->m_specific_param.m_enc.m_matrice, parameters->cp_matrice, array_size);
      }
    }
  }
#line 6324
  cp->tdx = (OPJ_UINT32 )parameters->cp_tdx;
#line 6325
  cp->tdy = (OPJ_UINT32 )parameters->cp_tdy;
#line 6328
  cp->tx0 = (OPJ_UINT32 )parameters->cp_tx0;
#line 6329
  cp->ty0 = (OPJ_UINT32 )parameters->cp_ty0;
#line 6332
  if (parameters->cp_comment) {
    {
#line 6333
    __cil_tmp19 = strlen((char const   *)parameters->cp_comment);
#line 6333
    __cil_tmp20 = malloc(__cil_tmp19 + 1UL);
#line 6333
    cp->comment = (char *)__cil_tmp20;
    }
#line 6334
    if (! cp->comment) {
      {
#line 6335
      opj_event_msg(p_manager, 1, "Not enough memory to allocate copy of comment string\n");
      }
#line 6336
      return (0);
    }
    {
#line 6338
    strcpy(cp->comment, (char const   *)parameters->cp_comment);
    }
  } else {
    {
#line 6341
    strcpy((char *)comment, "Created by OpenJPEG version ");;
#line 6342
    __cil_tmp23 = strlen((char const   *)comment);
#line 6342
    clen = __cil_tmp23;
#line 6343
    __cil_tmp25 = opj_version();
#line 6343
    version = __cil_tmp25;
#line 6354
    __cil_tmp26 = strlen(version);
#line 6354
    __cil_tmp27 = malloc((clen + __cil_tmp26) + 1UL);
#line 6354
    cp->comment = (char *)__cil_tmp27;
    }
#line 6355
    if (! cp->comment) {
      {
#line 6356
      opj_event_msg(p_manager, 1, "Not enough memory to allocate comment string\n");
      }
#line 6357
      return (0);
    }
    {
#line 6359
    sprintf(cp->comment, "%s%s", (char const   *)comment, version);
    }
  }
#line 6368
  if (parameters->tile_size_on) {
    {
#line 6369
    __cil_tmp28 = opj_int_ceildiv((OPJ_INT32 )(image->x1 - cp->tx0), (OPJ_INT32 )cp->tdx);
#line 6369
    cp->tw = (OPJ_UINT32 )__cil_tmp28;
#line 6370
    __cil_tmp29 = opj_int_ceildiv((OPJ_INT32 )(image->y1 - cp->ty0), (OPJ_INT32 )cp->tdy);
#line 6370
    cp->th = (OPJ_UINT32 )__cil_tmp29;
    }
  } else {
#line 6372
    cp->tdx = image->x1 - cp->tx0;
#line 6373
    cp->tdy = image->y1 - cp->ty0;
  }
#line 6376
  if (parameters->tp_on) {
#line 6377
    cp->m_specific_param.m_enc.m_tp_flag = (OPJ_BYTE )parameters->tp_flag;
#line 6378
    cp->m_specific_param.m_enc.m_tp_on = (OPJ_UINT32 )1;
  }
  {
#line 6439
  __cil_tmp30 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 6439
  cp->tcps = (opj_tcp_t *)__cil_tmp30;
  }
#line 6440
  if (! cp->tcps) {
    {
#line 6441
    opj_event_msg(p_manager, 1, "Not enough memory to allocate tile coding parameters\n");
    }
#line 6442
    return (0);
  }
#line 6444
  if (parameters->numpocs) {
    {
#line 6446
    opj_j2k_check_poc_val((opj_poc_t *)parameters->POC, parameters->numpocs, (OPJ_UINT32 )parameters->numresolution,
                          image->numcomps, (OPJ_UINT32 )parameters->tcp_numlayers,
                          p_manager);
    }
  }
#line 6450
  tileno = (OPJ_UINT32 )0;
  {
#line 6450
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6450
    if (! (tileno < cp->tw * cp->th)) {
#line 6450
      goto while_break___0;
    }
#line 6451
    tcp = cp->tcps + tileno;
#line 6452
    tcp->numlayers = (OPJ_UINT32 )parameters->tcp_numlayers;
#line 6454
    j = (OPJ_UINT32 )0;
    {
#line 6454
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 6454
      if (! (j < tcp->numlayers)) {
#line 6454
        goto while_break___1;
      }
#line 6455
      if ((int )cp->rsiz >= 3) {
#line 6455
        if ((int )cp->rsiz <= 6) {
#line 6456
          if (cp->m_specific_param.m_enc.m_fixed_quality) {
#line 6457
            tcp->distoratio[j] = parameters->tcp_distoratio[j];
          }
#line 6459
          tcp->rates[j] = parameters->tcp_rates[j];
        } else {
#line 6455
          goto _L___12;
        }
      } else
      _L___12: /* CIL Label */ 
#line 6461
      if (cp->m_specific_param.m_enc.m_fixed_quality) {
#line 6462
        tcp->distoratio[j] = parameters->tcp_distoratio[j];
      } else {
#line 6464
        tcp->rates[j] = parameters->tcp_rates[j];
      }
#line 6454
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 6469
    tcp->csty = (OPJ_UINT32 )parameters->csty;
#line 6470
    tcp->prg = parameters->prog_order;
#line 6471
    tcp->mct = (OPJ_UINT32 )parameters->tcp_mct;
#line 6473
    numpocs_tile = (OPJ_UINT32 )0;
#line 6474
    tcp->POC = (OPJ_UINT32 )0;
#line 6476
    if (parameters->numpocs) {
#line 6478
      tcp->POC = (OPJ_UINT32 )1;
#line 6479
      i = (OPJ_UINT32 )0;
      {
#line 6479
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 6479
        if (! (i < parameters->numpocs)) {
#line 6479
          goto while_break___2;
        }
#line 6480
        if (tileno + 1U == parameters->POC[i].tile) {
#line 6481
          tcp_poc = & tcp->pocs[numpocs_tile];
#line 6483
          tcp_poc->resno0 = parameters->POC[numpocs_tile].resno0;
#line 6484
          tcp_poc->compno0 = parameters->POC[numpocs_tile].compno0;
#line 6485
          tcp_poc->layno1 = parameters->POC[numpocs_tile].layno1;
#line 6486
          tcp_poc->resno1 = parameters->POC[numpocs_tile].resno1;
#line 6487
          tcp_poc->compno1 = parameters->POC[numpocs_tile].compno1;
#line 6488
          tcp_poc->prg1 = parameters->POC[numpocs_tile].prg1;
#line 6489
          tcp_poc->tile = parameters->POC[numpocs_tile].tile;
#line 6491
          numpocs_tile ++;
        }
#line 6479
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 6495
      tcp->numpocs = numpocs_tile - 1U;
    } else {
#line 6497
      tcp->numpocs = (OPJ_UINT32 )0;
    }
    {
#line 6500
    __cil_tmp36 = calloc((unsigned long )image->numcomps, sizeof(opj_tccp_t ));
#line 6500
    tcp->tccps = (opj_tccp_t *)__cil_tmp36;
    }
#line 6501
    if (! tcp->tccps) {
      {
#line 6502
      opj_event_msg(p_manager, 1, "Not enough memory to allocate tile component coding parameters\n");
      }
#line 6503
      return (0);
    }
#line 6505
    if (parameters->mct_data) {
      {
#line 6507
      lMctSize = (image->numcomps * image->numcomps) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 6508
      __cil_tmp39 = malloc((unsigned long )lMctSize);
#line 6508
      lTmpBuf = (OPJ_FLOAT32 *)__cil_tmp39;
#line 6509
      l_dc_shift = (OPJ_INT32 *)((OPJ_BYTE *)parameters->mct_data + lMctSize);
      }
#line 6511
      if (! lTmpBuf) {
        {
#line 6512
        opj_event_msg(p_manager, 1, "Not enough memory to allocate temp buffer\n");
        }
#line 6513
        return (0);
      }
      {
#line 6516
      tcp->mct = (OPJ_UINT32 )2;
#line 6517
      __cil_tmp41 = malloc((unsigned long )lMctSize);
#line 6517
      tcp->m_mct_coding_matrix = (OPJ_FLOAT32 *)__cil_tmp41;
      }
#line 6518
      if (! tcp->m_mct_coding_matrix) {
        {
#line 6519
        free(lTmpBuf);
#line 6520
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 6521
        opj_event_msg(p_manager, 1, "Not enough memory to allocate encoder MCT coding matrix \n");
        }
#line 6522
        return (0);
      }
      {
#line 6524
      memcpy(tcp->m_mct_coding_matrix, parameters->mct_data, (unsigned long )lMctSize);
#line 6525
      memcpy(lTmpBuf, parameters->mct_data, (unsigned long )lMctSize);
#line 6527
      __cil_tmp42 = malloc((unsigned long )lMctSize);
#line 6527
      tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp42;
      }
#line 6528
      if (! tcp->m_mct_decoding_matrix) {
        {
#line 6529
        free(lTmpBuf);
#line 6530
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 6531
        opj_event_msg(p_manager, 1, "Not enough memory to allocate encoder MCT decoding matrix \n");
        }
#line 6532
        return (0);
      }
      {
#line 6534
      __cil_tmp43 = opj_matrix_inversion_f(lTmpBuf, tcp->m_mct_decoding_matrix, image->numcomps);
      }
#line 6534
      if (__cil_tmp43 == 0) {
        {
#line 6535
        free(lTmpBuf);
#line 6536
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 6537
        opj_event_msg(p_manager, 1, "Failed to inverse encoder MCT decoding matrix \n");
        }
#line 6538
        return (0);
      }
      {
#line 6541
      __cil_tmp44 = malloc((unsigned long )image->numcomps * sizeof(OPJ_FLOAT64 ));
#line 6541
      tcp->mct_norms = (OPJ_FLOAT64 *)__cil_tmp44;
      }
#line 6543
      if (! tcp->mct_norms) {
        {
#line 6544
        free(lTmpBuf);
#line 6545
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 6546
        opj_event_msg(p_manager, 1, "Not enough memory to allocate encoder MCT norms \n");
        }
#line 6547
        return (0);
      }
      {
#line 6549
      opj_calculate_norms(tcp->mct_norms, image->numcomps, tcp->m_mct_decoding_matrix);
#line 6550
      free(lTmpBuf);
#line 6552
      i = (OPJ_UINT32 )0;
      }
      {
#line 6552
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 6552
        if (! (i < image->numcomps)) {
#line 6552
          goto while_break___3;
        }
#line 6553
        tccp = tcp->tccps + i;
#line 6554
        tccp->m_dc_level_shift = *(l_dc_shift + i);
#line 6552
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 6557
      __cil_tmp47 = opj_j2k_setup_mct_encoding(tcp, image);
      }
#line 6557
      if (__cil_tmp47 == 0) {
        {
#line 6559
        opj_event_msg(p_manager, 1, "Failed to setup j2k mct encoding\n");
        }
#line 6560
        return (0);
      }
    } else {
#line 6564
      if (tcp->mct == 1U) {
#line 6564
        if (image->numcomps == 3U) {
#line 6565
          if ((image->comps + 0)->dx != (image->comps + 1)->dx) {
            {
            {
            {
            {
#line 6569
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
            }
            }
            }
#line 6570
            tcp->mct = (OPJ_UINT32 )0;
            }
          } else
#line 6565
          if ((image->comps + 0)->dx != (image->comps + 2)->dx) {
            {
            {
            {
            {
#line 6569
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
            }
            }
            }
#line 6570
            tcp->mct = (OPJ_UINT32 )0;
            }
          } else
#line 6565
          if ((image->comps + 0)->dy != (image->comps + 1)->dy) {
            {
            {
            {
            {
#line 6569
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
            }
            }
            }
#line 6570
            tcp->mct = (OPJ_UINT32 )0;
            }
          } else
#line 6565
          if ((image->comps + 0)->dy != (image->comps + 2)->dy) {
            {
            {
            {
            {
#line 6569
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
            }
            }
            }
#line 6570
            tcp->mct = (OPJ_UINT32 )0;
            }
          }
        }
      }
#line 6573
      i = (OPJ_UINT32 )0;
      {
#line 6573
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 6573
        if (! (i < image->numcomps)) {
#line 6573
          goto while_break___4;
        }
#line 6574
        tccp___0 = tcp->tccps + i;
#line 6575
        l_comp = image->comps + i;
#line 6577
        if (! l_comp->sgnd) {
#line 6578
          tccp___0->m_dc_level_shift = 1 << (l_comp->prec - 1U);
        }
#line 6573
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 6583
    i = (OPJ_UINT32 )0;
    {
#line 6583
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 6583
      if (! (i < image->numcomps)) {
#line 6583
        goto while_break___5;
      }
      {
#line 6584
      tccp___1 = tcp->tccps + i;
#line 6586
      tccp___1->csty = (OPJ_UINT32 )(parameters->csty & 1);
#line 6587
      tccp___1->numresolutions = (OPJ_UINT32 )parameters->numresolution;
#line 6588
      __cil_tmp52 = opj_int_floorlog2(parameters->cblockw_init);
#line 6588
      tccp___1->cblkw = (OPJ_UINT32 )__cil_tmp52;
#line 6589
      __cil_tmp53 = opj_int_floorlog2(parameters->cblockh_init);
#line 6589
      tccp___1->cblkh = (OPJ_UINT32 )__cil_tmp53;
#line 6590
      tccp___1->cblksty = (OPJ_UINT32 )parameters->mode;
      }
#line 6591
      if (parameters->irreversible) {
#line 6591
        tmp = 0;
      } else {
#line 6591
        tmp = 1;
      }
#line 6591
      tccp___1->qmfbid = (OPJ_UINT32 )tmp;
#line 6592
      if (parameters->irreversible) {
#line 6592
        tmp___0 = 2;
      } else {
#line 6592
        tmp___0 = 0;
      }
#line 6592
      tccp___1->qntsty = (OPJ_UINT32 )tmp___0;
#line 6593
      tccp___1->numgbits = (OPJ_UINT32 )2;
#line 6595
      if ((OPJ_INT32 )i == parameters->roi_compno) {
#line 6596
        tccp___1->roishift = parameters->roi_shift;
      } else {
#line 6598
        tccp___1->roishift = 0;
      }
#line 6601
      if (parameters->csty & 1) {
#line 6602
        p = 0;
#line 6604
        it_res = (OPJ_INT32 )tccp___1->numresolutions - 1;
        {
#line 6604
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 6604
          if (! (it_res >= 0)) {
#line 6604
            goto while_break___6;
          }
#line 6605
          if (p < parameters->res_spec) {
#line 6607
            if (parameters->prcw_init[p] < 1) {
#line 6608
              tccp___1->prcw[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 6610
              __cil_tmp59 = opj_int_floorlog2(parameters->prcw_init[p]);
#line 6610
              tccp___1->prcw[it_res] = (OPJ_UINT32 )__cil_tmp59;
              }
            }
#line 6613
            if (parameters->prch_init[p] < 1) {
#line 6614
              tccp___1->prch[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 6616
              __cil_tmp60 = opj_int_floorlog2(parameters->prch_init[p]);
#line 6616
              tccp___1->prch[it_res] = (OPJ_UINT32 )__cil_tmp60;
              }
            }
          } else {
#line 6620
            res_spec = parameters->res_spec;
#line 6621
            size_prcw = 0;
#line 6622
            size_prch = 0;
#line 6625
            size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
#line 6626
            size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));
#line 6629
            if (size_prcw < 1) {
#line 6630
              tccp___1->prcw[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 6632
              __cil_tmp65 = opj_int_floorlog2(size_prcw);
#line 6632
              tccp___1->prcw[it_res] = (OPJ_UINT32 )__cil_tmp65;
              }
            }
#line 6635
            if (size_prch < 1) {
#line 6636
              tccp___1->prch[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 6638
              __cil_tmp66 = opj_int_floorlog2(size_prch);
#line 6638
              tccp___1->prch[it_res] = (OPJ_UINT32 )__cil_tmp66;
              }
            }
          }
#line 6641
          p ++;
#line 6604
          __cil_tmp68 = it_res;
#line 6604
          it_res --;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else {
#line 6645
        j = (OPJ_UINT32 )0;
        {
#line 6645
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 6645
          if (! (j < tccp___1->numresolutions)) {
#line 6645
            goto while_break___7;
          }
#line 6646
          tccp___1->prcw[j] = (OPJ_UINT32 )15;
#line 6647
          tccp___1->prch[j] = (OPJ_UINT32 )15;
#line 6645
          j ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
      {
#line 6651
      opj_dwt_calc_explicit_stepsizes(tccp___1, (image->comps + i)->prec);
      }
#line 6583
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 6450
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6655
  if (parameters->mct_data) {
    {
#line 6656
    free(parameters->mct_data);
#line 6657
    parameters->mct_data = (void *)0;
    }
  }
#line 6659
  return (1);
}
}
#line 6662 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index , OPJ_UINT32 type ,
                                     OPJ_OFF_T pos , OPJ_UINT32 len ) 
{ 
  int tmp ;
  opj_marker_info_t *new_marker ;
  void *__cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;

  {
#line 6667
  if (cstr_index->marknum + 1U > cstr_index->maxmarknum) {
    {
#line 6669
    cstr_index->maxmarknum = (OPJ_UINT32 )((float )100 + (OPJ_FLOAT32 )cstr_index->maxmarknum);
#line 6670
    __cil_tmp7 = realloc(cstr_index->marker, (unsigned long )cstr_index->maxmarknum * sizeof(opj_marker_info_t ));
#line 6670
    new_marker = (opj_marker_info_t *)__cil_tmp7;
    }
#line 6671
    if (! new_marker) {
      {
#line 6672
      free(cstr_index->marker);
#line 6673
      cstr_index->marker = (opj_marker_info_t *)((void *)0);
#line 6674
      cstr_index->maxmarknum = (OPJ_UINT32 )0;
#line 6675
      cstr_index->marknum = (OPJ_UINT32 )0;
      }
#line 6677
      return (0);
    }
#line 6679
    cstr_index->marker = new_marker;
  }
#line 6683
  (cstr_index->marker + cstr_index->marknum)->type = (OPJ_UINT16 )type;
#line 6684
  (cstr_index->marker + cstr_index->marknum)->pos = (OPJ_OFF_T )((OPJ_INT32 )pos);
#line 6685
  (cstr_index->marker + cstr_index->marknum)->len = (OPJ_INT32 )len;
#line 6686
  (cstr_index->marknum) ++;
#line 6687
  return (1);
}
}
#line 6690 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno , opj_codestream_index_t *cstr_index ,
                                     OPJ_UINT32 type , OPJ_OFF_T pos , OPJ_UINT32 len ) 
{ 
  int tmp ;
  int tmp___0 ;
  opj_marker_info_t *new_marker ;
  void *__cil_tmp9 ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_UINT32 l_current_tile_part ;

  {
#line 6696
  if ((cstr_index->tile_index + tileno)->marknum + 1U > (cstr_index->tile_index + tileno)->maxmarknum) {
    {
#line 6698
    (cstr_index->tile_index + tileno)->maxmarknum = (OPJ_UINT32 )((float )100 + (OPJ_FLOAT32 )(cstr_index->tile_index + tileno)->maxmarknum);
#line 6699
    __cil_tmp9 = realloc((cstr_index->tile_index + tileno)->marker, (unsigned long )(cstr_index->tile_index + tileno)->maxmarknum * sizeof(opj_marker_info_t ));
#line 6699
    new_marker = (opj_marker_info_t *)__cil_tmp9;
    }
#line 6702
    if (! new_marker) {
      {
#line 6703
      free((cstr_index->tile_index + tileno)->marker);
#line 6704
      (cstr_index->tile_index + tileno)->marker = (opj_marker_info_t *)((void *)0);
#line 6705
      (cstr_index->tile_index + tileno)->maxmarknum = (OPJ_UINT32 )0;
#line 6706
      (cstr_index->tile_index + tileno)->marknum = (OPJ_UINT32 )0;
      }
#line 6708
      return (0);
    }
#line 6710
    (cstr_index->tile_index + tileno)->marker = new_marker;
  }
#line 6714
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->type = (OPJ_UINT16 )type;
#line 6715
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->pos = (OPJ_OFF_T )((OPJ_INT32 )pos);
#line 6716
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->len = (OPJ_INT32 )len;
#line 6717
  ((cstr_index->tile_index + tileno)->marknum) ++;
#line 6719
  if (type == 65424U) {
#line 6720
    l_current_tile_part = (cstr_index->tile_index + tileno)->current_tpsno;
#line 6722
    if ((cstr_index->tile_index + tileno)->tp_index) {
#line 6723
      ((cstr_index->tile_index + tileno)->tp_index + l_current_tile_part)->start_pos = pos;
    }
  }
#line 6726
  return (1);
}
}
#line 6735 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) 
{ 


  {
#line 6743
  return (1);
}
}
#line 6746 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream , opj_j2k_t *p_j2k , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  opj_image_t *__cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  opj_image_t *__cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 6757
  p_j2k->m_private_image = opj_image_create0();
  }
#line 6758
  if (! p_j2k->m_private_image) {
#line 6759
    return (0);
  }
  {
#line 6763
  opj_j2k_setup_decoding_validation(p_j2k);
#line 6766
  __cil_tmp9 = opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager);
  }
#line 6766
  if (! __cil_tmp9) {
    {
#line 6767
    opj_image_destroy(p_j2k->m_private_image);
#line 6768
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 6769
    return (0);
  }
  {
#line 6773
  opj_j2k_setup_header_reading(p_j2k);
#line 6776
  __cil_tmp10 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 6776
  if (! __cil_tmp10) {
    {
#line 6777
    opj_image_destroy(p_j2k->m_private_image);
#line 6778
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 6779
    return (0);
  }
  {
#line 6782
  *p_image = opj_image_create0();
  }
#line 6783
  if (! *p_image) {
#line 6784
    return (0);
  }
  {
#line 6788
  opj_copy_image_header(p_j2k->m_private_image, *p_image);
#line 6791
  __cil_tmp12 = opj_j2k_allocate_tile_element_cstr_index(p_j2k);
  }
#line 6791
  if (! __cil_tmp12) {
#line 6792
    return (0);
  }
#line 6795
  return (1);
}
}
#line 6798 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_setup_header_reading(opj_j2k_t *p_j2k ) 
{ 
  int tmp ;

  {
  {
#line 6803
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_read_header_procedure));
#line 6806
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_copy_default_tcp_and_create_tcd));
  }
  return;
}
}
#line 6810 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k ) 
{ 
  int tmp ;

  {
  {
#line 6815
  opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure )(& opj_j2k_build_decoder));
#line 6816
  opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure )(& opj_j2k_decoding_validation));
  }
  return;
}
}
#line 6821 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 6825
  l_is_valid = 1;
#line 6833
  if (((int )p_j2k->m_cp.rsiz & 33280) == 33280) {
#line 6834
    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 6835
    l_tcp = p_j2k->m_cp.tcps;
#line 6837
    i = (OPJ_UINT32 )0;
    {
#line 6837
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6837
      if (! (i < l_nb_tiles)) {
#line 6837
        goto while_break;
      }
#line 6838
      if (l_tcp->mct == 2U) {
#line 6839
        l_tccp = l_tcp->tccps;
#line 6840
        l_is_valid &= l_tcp->m_mct_coding_matrix != (OPJ_FLOAT32 *)0;
#line 6842
        j = (OPJ_UINT32 )0;
        {
#line 6842
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 6842
          if (! (j < (p_j2k->m_private_image)->numcomps)) {
#line 6842
            goto while_break___0;
          }
#line 6843
          l_is_valid &= ! (l_tccp->qmfbid & 1U);
#line 6844
          l_tccp ++;
#line 6842
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 6847
      l_tcp ++;
#line 6837
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 6851
  return (l_is_valid);
}
}
#line 6854 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t *p_tcp , opj_image_t *p_image ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_indix ;
  opj_mct_data_t *l_mct_deco_data ;
  opj_mct_data_t *l_mct_offset_data ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_data ;
  OPJ_UINT32 l_mct_size ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_FLOAT32 *l_data ;
  OPJ_FLOAT32 *l_current_data ;
  opj_tccp_t *l_tccp ;
  int tmp ;
  opj_mct_data_t *new_mct_records ;
  void *__cil_tmp15 ;
  OPJ_UINT32 __cil_tmp16 ;
  void *__cil_tmp17 ;
  opj_mct_data_t *new_mct_records___0 ;
  void *__cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  OPJ_FLOAT32 *__cil_tmp23 ;
  opj_simple_mcc_decorrelation_data_t *new_mcc_records ;
  void *__cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;

  {
#line 6857
  l_indix = (OPJ_UINT32 )1;
#line 6858
  l_mct_deco_data = (opj_mct_data_t *)0;
#line 6858
  l_mct_offset_data = (opj_mct_data_t *)0;
#line 6867
  if (p_tcp->mct != 2U) {
#line 6868
    return (1);
  }
#line 6871
  if (p_tcp->m_mct_decoding_matrix) {
#line 6872
    if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
      {
#line 6874
      p_tcp->m_nb_max_mct_records += (unsigned int )10;
#line 6876
      __cil_tmp15 = realloc(p_tcp->m_mct_records, (unsigned long )p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 6876
      new_mct_records = (opj_mct_data_t *)__cil_tmp15;
      }
#line 6877
      if (! new_mct_records) {
        {
#line 6878
        free(p_tcp->m_mct_records);
#line 6879
        p_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 6880
        p_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 6881
        p_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
        }
#line 6883
        return (0);
      }
      {
#line 6885
      p_tcp->m_mct_records = new_mct_records;
#line 6886
      l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 6888
      memset(l_mct_deco_data, 0, (unsigned long )(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
      }
    }
#line 6890
    l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 6892
    if (l_mct_deco_data->m_data) {
      {
#line 6893
      free(l_mct_deco_data->m_data);
#line 6894
      l_mct_deco_data->m_data = (OPJ_BYTE *)0;
      }
    }
    {
#line 6897
    __cil_tmp16 = l_indix;
#line 6897
    l_indix ++;
#line 6897
    l_mct_deco_data->m_index = __cil_tmp16;
#line 6898
    l_mct_deco_data->m_array_type = (J2K_MCT_ARRAY_TYPE )1;
#line 6899
    l_mct_deco_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )2;
#line 6900
    l_nb_elem = p_image->numcomps * p_image->numcomps;
#line 6901
    l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_deco_data->m_element_type];
#line 6902
    __cil_tmp17 = malloc((unsigned long )l_mct_size);
#line 6902
    l_mct_deco_data->m_data = (OPJ_BYTE *)__cil_tmp17;
    }
#line 6904
    if (! l_mct_deco_data->m_data) {
#line 6905
      return (0);
    }
    {
#line 6908
    (*(j2k_mct_write_functions_from_float[l_mct_deco_data->m_element_type]))(p_tcp->m_mct_decoding_matrix,
                                                                             l_mct_deco_data->m_data,
                                                                             l_nb_elem);
#line 6910
    l_mct_deco_data->m_data_size = l_mct_size;
#line 6911
    (p_tcp->m_nb_mct_records) ++;
    }
  }
#line 6914
  if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
    {
#line 6916
    p_tcp->m_nb_max_mct_records += (unsigned int )10;
#line 6917
    __cil_tmp19 = realloc(p_tcp->m_mct_records, (unsigned long )p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 6917
    new_mct_records___0 = (opj_mct_data_t *)__cil_tmp19;
    }
#line 6918
    if (! new_mct_records___0) {
      {
#line 6919
      free(p_tcp->m_mct_records);
#line 6920
      p_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 6921
      p_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 6922
      p_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
      }
#line 6924
      return (0);
    }
    {
#line 6926
    p_tcp->m_mct_records = new_mct_records___0;
#line 6927
    l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 6929
    memset(l_mct_offset_data, 0, (unsigned long )(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
    }
#line 6931
    if (l_mct_deco_data) {
#line 6932
      l_mct_deco_data = l_mct_offset_data - 1;
    }
  }
#line 6936
  l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 6938
  if (l_mct_offset_data->m_data) {
    {
#line 6939
    free(l_mct_offset_data->m_data);
#line 6940
    l_mct_offset_data->m_data = (OPJ_BYTE *)0;
    }
  }
  {
#line 6943
  __cil_tmp20 = l_indix;
#line 6943
  l_indix ++;
#line 6943
  l_mct_offset_data->m_index = __cil_tmp20;
#line 6944
  l_mct_offset_data->m_array_type = (J2K_MCT_ARRAY_TYPE )2;
#line 6945
  l_mct_offset_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )2;
#line 6946
  l_nb_elem = p_image->numcomps;
#line 6947
  l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_offset_data->m_element_type];
#line 6948
  __cil_tmp21 = malloc((unsigned long )l_mct_size);
#line 6948
  l_mct_offset_data->m_data = (OPJ_BYTE *)__cil_tmp21;
  }
#line 6950
  if (! l_mct_offset_data->m_data) {
#line 6951
    return (0);
  }
  {
#line 6954
  __cil_tmp22 = malloc((unsigned long )l_nb_elem * sizeof(OPJ_FLOAT32 ));
#line 6954
  l_data = (OPJ_FLOAT32 *)__cil_tmp22;
  }
#line 6955
  if (! l_data) {
    {
#line 6956
    free(l_mct_offset_data->m_data);
#line 6957
    l_mct_offset_data->m_data = (OPJ_BYTE *)0;
    }
#line 6958
    return (0);
  }
#line 6961
  l_tccp = p_tcp->tccps;
#line 6962
  l_current_data = l_data;
#line 6964
  i = (OPJ_UINT32 )0;
  {
#line 6964
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6964
    if (! (i < l_nb_elem)) {
#line 6964
      goto while_break;
    }
#line 6965
    __cil_tmp23 = l_current_data;
#line 6965
    l_current_data ++;
#line 6965
    *__cil_tmp23 = (OPJ_FLOAT32 )l_tccp->m_dc_level_shift;
#line 6966
    l_tccp ++;
#line 6964
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6969
  (*(j2k_mct_write_functions_from_float[l_mct_offset_data->m_element_type]))(l_data,
                                                                             l_mct_offset_data->m_data,
                                                                             l_nb_elem);
#line 6971
  free(l_data);
#line 6973
  l_mct_offset_data->m_data_size = l_mct_size;
#line 6975
  (p_tcp->m_nb_mct_records) ++;
  }
#line 6977
  if (p_tcp->m_nb_mcc_records == p_tcp->m_nb_max_mcc_records) {
    {
#line 6979
    p_tcp->m_nb_max_mcc_records += (unsigned int )10;
#line 6980
    __cil_tmp25 = realloc(p_tcp->m_mcc_records, (unsigned long )p_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 6980
    new_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp25;
    }
#line 6982
    if (! new_mcc_records) {
      {
#line 6983
      free(p_tcp->m_mcc_records);
#line 6984
      p_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)((void *)0);
#line 6985
      p_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 6986
      p_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
      }
#line 6988
      return (0);
    }
    {
#line 6990
    p_tcp->m_mcc_records = new_mcc_records;
#line 6991
    l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
#line 6992
    memset(l_mcc_data, 0, (unsigned long )(p_tcp->m_nb_max_mcc_records - p_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t ));
    }
  }
#line 6996
  l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
#line 6997
  l_mcc_data->m_decorrelation_array = l_mct_deco_data;
#line 6998
  l_mcc_data->m_is_irreversible = (OPJ_UINT32 )1;
#line 6999
  l_mcc_data->m_nb_comps = p_image->numcomps;
#line 7000
  __cil_tmp26 = l_indix;
#line 7000
  l_indix ++;
#line 7000
  l_mcc_data->m_index = __cil_tmp26;
#line 7001
  l_mcc_data->m_offset_array = l_mct_offset_data;
#line 7002
  (p_tcp->m_nb_mcc_records) ++;
#line 7004
  return (1);
}
}
#line 7007 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                               opj_event_mgr_t *p_manager ) 
{ 


  {
#line 7016
  return (1);
}
}
#line 7019 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                               opj_event_mgr_t *p_manager ) 
{ 


  {
#line 7028
  return (1);
}
}
#line 7031 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 7035
  l_is_valid = 1;
#line 7044
  l_is_valid &= p_j2k->m_specific_param.m_decoder.m_state == 0U;
#line 7048
  l_is_valid &= p_j2k->m_procedure_list != (opj_procedure_list_t *)0;
#line 7050
  l_is_valid &= p_j2k->m_validation_list != (opj_procedure_list_t *)0;
#line 7056
  if (((p_j2k->m_cp.tcps)->tccps)->numresolutions <= 0U) {
    {
    {
#line 7057
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\n");
    }
    }
#line 7058
    return (0);
  } else
#line 7056
  if (((p_j2k->m_cp.tcps)->tccps)->numresolutions > 31U) {
    {
    {
#line 7057
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\n");
    }
    }
#line 7058
    return (0);
  }
#line 7061
  if (p_j2k->m_cp.tdx < (OPJ_UINT32 )(1 << ((p_j2k->m_cp.tcps)->tccps)->numresolutions)) {
    {
#line 7062
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\n");
    }
#line 7063
    return (0);
  }
#line 7066
  if (p_j2k->m_cp.tdy < (OPJ_UINT32 )(1 << ((p_j2k->m_cp.tcps)->tccps)->numresolutions)) {
    {
#line 7067
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\nU");
    }
#line 7068
    return (0);
  }
#line 7072
  return (l_is_valid);
}
}
#line 7075 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 7080
  l_is_valid = 1;
#line 7092
  l_is_valid &= p_j2k->m_specific_param.m_decoder.m_state == 0U;
#line 7097
  l_is_valid &= p_j2k->m_procedure_list != (opj_procedure_list_t *)0;
#line 7099
  l_is_valid &= p_j2k->m_validation_list != (opj_procedure_list_t *)0;
#line 7102
  return (l_is_valid);
}
}
#line 7105 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                       opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  OPJ_BOOL l_has_siz ;
  OPJ_BOOL l_has_cod ;
  OPJ_BOOL l_has_qcd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;
  struct opj_dec_memory_marker_handler *__cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  struct opj_dec_memory_marker_handler *__cil_tmp17 ;
  OPJ_SIZE_T __cil_tmp18 ;
  OPJ_BYTE *new_header_data ;
  void *__cil_tmp20 ;
  OPJ_SIZE_T __cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;
  OPJ_OFF_T __cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;
  OPJ_SIZE_T __cil_tmp25 ;
  OPJ_OFF_T __cil_tmp26 ;

  {
  {
#line 7111
  l_marker_handler = (opj_dec_memory_marker_handler_t *)0;
#line 7112
  l_has_siz = 0;
#line 7113
  l_has_cod = 0;
#line 7114
  l_has_qcd = 0;
#line 7122
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )1;
#line 7125
  __cil_tmp13 = opj_j2k_read_soc(p_j2k, p_stream, p_manager);
  }
#line 7125
  if (! __cil_tmp13) {
    {
#line 7126
    opj_event_msg(p_manager, 1, "Expected a SOC marker \n");
    }
#line 7127
    return (0);
  }
  {
#line 7131
  __cil_tmp14 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                     (OPJ_SIZE_T )2, p_manager);
  }
#line 7131
  if (__cil_tmp14 != 2UL) {
    {
#line 7132
    opj_event_msg(p_manager, 1, "Stream too short\n");
    }
#line 7133
    return (0);
  }
  {
#line 7137
  opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                    (OPJ_UINT32 )2);
  }
  {
#line 7140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7140
    if (! (l_current_marker != 65424U)) {
#line 7140
      goto while_break;
    }
#line 7143
    if (l_current_marker < 65280U) {
      {
#line 7144
      opj_event_msg(p_manager, 1, "We expected read a marker ID (0xff--) instead of %.8x\n",
                    l_current_marker);
      }
#line 7145
      return (0);
    }
    {
#line 7149
    l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
    }
#line 7152
    if (l_marker_handler->id == 0U) {
      {
#line 7153
      __cil_tmp16 = opj_j2k_read_unk(p_j2k, p_stream, & l_current_marker, p_manager);
      }
#line 7153
      if (! __cil_tmp16) {
        {
#line 7154
        opj_event_msg(p_manager, 1, "Unknow marker have been detected and generated error.\n");
        }
#line 7155
        return (0);
      }
#line 7158
      if (l_current_marker == 65424U) {
#line 7159
        goto while_break;
      } else {
        {
#line 7161
        l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
        }
      }
    }
#line 7164
    if (l_marker_handler->id == 65361U) {
#line 7166
      l_has_siz = 1;
    }
#line 7168
    if (l_marker_handler->id == 65362U) {
#line 7170
      l_has_cod = 1;
    }
#line 7172
    if (l_marker_handler->id == 65372U) {
#line 7174
      l_has_qcd = 1;
    }
#line 7178
    if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
      {
#line 7179
      opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n");
      }
#line 7180
      return (0);
    }
    {
#line 7184
    __cil_tmp18 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 7184
    if (__cil_tmp18 != 2UL) {
      {
#line 7185
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 7186
      return (0);
    }
    {
#line 7190
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_marker_size,
                      (OPJ_UINT32 )2);
#line 7191
    l_marker_size -= (unsigned int )2;
    }
#line 7194
    if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
      {
#line 7195
      __cil_tmp20 = realloc(p_j2k->m_specific_param.m_decoder.m_header_data, (unsigned long )l_marker_size);
#line 7195
      new_header_data = (OPJ_BYTE *)__cil_tmp20;
      }
#line 7196
      if (! new_header_data) {
        {
#line 7197
        free(p_j2k->m_specific_param.m_decoder.m_header_data);
#line 7198
        p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)((void *)0);
#line 7199
        p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
#line 7200
        opj_event_msg(p_manager, 1, "Not enough memory to read header\n");
        }
#line 7201
        return (0);
      }
#line 7203
      p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
#line 7204
      p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
    }
    {
#line 7208
    __cil_tmp21 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )l_marker_size, p_manager);
    }
#line 7208
    if (__cil_tmp21 != (unsigned long )l_marker_size) {
      {
#line 7209
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 7210
      return (0);
    }
    {
#line 7214
    __cil_tmp22 = (*(l_marker_handler->handler))(p_j2k, p_j2k->m_specific_param.m_decoder.m_header_data,
                                                 l_marker_size, p_manager);
    }
#line 7214
    if (! __cil_tmp22) {
      {
#line 7215
      opj_event_msg(p_manager, 1, "Marker handler function failed to read the marker segment\n");
      }
#line 7216
      return (0);
    }
    {
#line 7220
    __cil_tmp23 = opj_stream_tell(p_stream);
#line 7220
    __cil_tmp24 = opj_j2k_add_mhmarker(p_j2k->cstr_index, l_marker_handler->id, (OPJ_OFF_T )(((OPJ_UINT32 )__cil_tmp23 - l_marker_size) - 4U),
                                       l_marker_size + 4U);
    }
#line 7220
    if (0 == __cil_tmp24) {
      {
#line 7225
      opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n");
      }
#line 7226
      return (0);
    }
    {
#line 7230
    __cil_tmp25 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 7230
    if (__cil_tmp25 != 2UL) {
      {
#line 7231
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 7232
      return (0);
    }
    {
#line 7236
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                      (OPJ_UINT32 )2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 7239
  if (l_has_siz == 0) {
    {
#line 7240
    opj_event_msg(p_manager, 1, "required SIZ marker not found in main header\n");
    }
#line 7241
    return (0);
  }
#line 7243
  if (l_has_cod == 0) {
    {
#line 7244
    opj_event_msg(p_manager, 1, "required COD marker not found in main header\n");
    }
#line 7245
    return (0);
  }
#line 7247
  if (l_has_qcd == 0) {
    {
#line 7248
    opj_event_msg(p_manager, 1, "required QCD marker not found in main header\n");
    }
#line 7249
    return (0);
  }
  {
#line 7252
  opj_event_msg(p_manager, 4, "Main header has been correctly decoded.\n\220");
#line 7255
  __cil_tmp26 = opj_stream_tell(p_stream);
#line 7255
  (p_j2k->cstr_index)->main_head_end = (OPJ_OFF_T )((OPJ_UINT32 )__cil_tmp26 - 2U);
#line 7258
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
  }
#line 7260
  return (1);
}
}
#line 7263 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_exec(opj_j2k_t *p_j2k , opj_procedure_list_t *p_procedure_list ,
                      opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL (**l_procedure)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ) ;
  OPJ_BOOL l_result ;
  OPJ_UINT32 l_nb_proc ;
  OPJ_UINT32 i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  OPJ_UINT32 __cil_tmp13 ;
  opj_procedure *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;

  {
  {
#line 7268
  l_procedure = (OPJ_BOOL (**)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ))0;
#line 7269
  l_result = 1;
#line 7278
  l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);
#line 7279
  __cil_tmp14 = opj_procedure_list_get_first_procedure(p_procedure_list);
#line 7279
  l_procedure = (OPJ_BOOL (**)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ))__cil_tmp14;
#line 7281
  i = (OPJ_UINT32 )0;
  }
  {
#line 7281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7281
    if (! (i < l_nb_proc)) {
#line 7281
      goto while_break;
    }
    {
#line 7282
    __cil_tmp15 = (*(*l_procedure))(p_j2k, p_stream, p_manager);
#line 7282
    l_result = l_result && __cil_tmp15;
#line 7283
    l_procedure ++;
    }
#line 7281
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7287
  opj_procedure_list_clear(p_procedure_list);
  }
#line 7288
  return (l_result);
}
}
#line 7292 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                                        opj_event_mgr_t *p_manager ) 
{ 
  opj_tcp_t *l_tcp ;
  opj_tcp_t *l_default_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  opj_tccp_t *l_current_tccp ;
  OPJ_UINT32 l_tccp_size ;
  OPJ_UINT32 l_mct_size ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_mcc_records_size ;
  OPJ_UINT32 l_mct_records_size ;
  opj_mct_data_t *l_src_mct_rec ;
  opj_mct_data_t *l_dest_mct_rec ;
  opj_simple_mcc_decorrelation_data_t *l_src_mcc_rec ;
  opj_simple_mcc_decorrelation_data_t *l_dest_mcc_rec ;
  OPJ_UINT32 l_offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  opj_tcd_t *__cil_tmp27 ;
  OPJ_BOOL __cil_tmp28 ;

  {
#line 7297
  l_tcp = (opj_tcp_t *)0;
#line 7298
  l_default_tcp = (opj_tcp_t *)0;
#line 7301
  l_current_tccp = (opj_tccp_t *)0;
#line 7315
  l_image = p_j2k->m_private_image;
#line 7316
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 7317
  l_tcp = p_j2k->m_cp.tcps;
#line 7318
  l_tccp_size = l_image->numcomps * (OPJ_UINT32 )sizeof(opj_tccp_t );
#line 7319
  l_default_tcp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
#line 7320
  l_mct_size = (l_image->numcomps * l_image->numcomps) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 7323
  i = (OPJ_UINT32 )0;
  {
#line 7323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7323
    if (! (i < l_nb_tiles)) {
#line 7323
      goto while_break;
    }
    {
#line 7325
    l_current_tccp = l_tcp->tccps;
#line 7327
    memcpy(l_tcp, l_default_tcp, sizeof(opj_tcp_t ));
#line 7329
    l_tcp->ppt = (OPJ_UINT32 )0;
#line 7330
    l_tcp->ppt_data = (OPJ_BYTE *)0;
#line 7332
    l_tcp->tccps = l_current_tccp;
    }
#line 7335
    if (l_default_tcp->m_mct_decoding_matrix) {
      {
#line 7336
      __cil_tmp23 = malloc((unsigned long )l_mct_size);
#line 7336
      l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp23;
      }
#line 7337
      if (! l_tcp->m_mct_decoding_matrix) {
#line 7338
        return (0);
      }
      {
#line 7340
      memcpy(l_tcp->m_mct_decoding_matrix, l_default_tcp->m_mct_decoding_matrix, (unsigned long )l_mct_size);
      }
    }
    {
#line 7344
    l_mct_records_size = l_default_tcp->m_nb_max_mct_records * (OPJ_UINT32 )sizeof(opj_mct_data_t );
#line 7345
    __cil_tmp24 = malloc((unsigned long )l_mct_records_size);
#line 7345
    l_tcp->m_mct_records = (opj_mct_data_t *)__cil_tmp24;
    }
#line 7346
    if (! l_tcp->m_mct_records) {
#line 7347
      return (0);
    }
    {
#line 7349
    memcpy(l_tcp->m_mct_records, l_default_tcp->m_mct_records, (unsigned long )l_mct_records_size);
#line 7352
    l_src_mct_rec = l_default_tcp->m_mct_records;
#line 7353
    l_dest_mct_rec = l_tcp->m_mct_records;
#line 7355
    j = (OPJ_UINT32 )0;
    }
    {
#line 7355
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 7355
      if (! (j < l_default_tcp->m_nb_mct_records)) {
#line 7355
        goto while_break___0;
      }
#line 7357
      if (l_src_mct_rec->m_data) {
        {
#line 7359
        __cil_tmp25 = malloc((unsigned long )l_src_mct_rec->m_data_size);
#line 7359
        l_dest_mct_rec->m_data = (OPJ_BYTE *)__cil_tmp25;
        }
#line 7360
        if (! l_dest_mct_rec->m_data) {
#line 7361
          return (0);
        }
        {
#line 7363
        memcpy(l_dest_mct_rec->m_data, l_src_mct_rec->m_data, (unsigned long )l_src_mct_rec->m_data_size);
        }
      }
#line 7366
      l_src_mct_rec ++;
#line 7367
      l_dest_mct_rec ++;
#line 7355
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 7371
    l_mcc_records_size = l_default_tcp->m_nb_max_mcc_records * (OPJ_UINT32 )sizeof(opj_simple_mcc_decorrelation_data_t );
#line 7372
    __cil_tmp26 = malloc((unsigned long )l_mcc_records_size);
#line 7372
    l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp26;
    }
#line 7373
    if (! l_tcp->m_mcc_records) {
#line 7374
      return (0);
    }
    {
#line 7376
    memcpy(l_tcp->m_mcc_records, l_default_tcp->m_mcc_records, (unsigned long )l_mcc_records_size);
#line 7379
    l_src_mcc_rec = l_default_tcp->m_mcc_records;
#line 7380
    l_dest_mcc_rec = l_tcp->m_mcc_records;
#line 7382
    j = (OPJ_UINT32 )0;
    }
    {
#line 7382
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 7382
      if (! (j < l_default_tcp->m_nb_max_mcc_records)) {
#line 7382
        goto while_break___1;
      }
#line 7384
      if (l_src_mcc_rec->m_decorrelation_array) {
#line 7385
        l_offset = (OPJ_UINT32 )(l_src_mcc_rec->m_decorrelation_array - l_default_tcp->m_mct_records);
#line 7386
        l_dest_mcc_rec->m_decorrelation_array = l_tcp->m_mct_records + l_offset;
      }
#line 7389
      if (l_src_mcc_rec->m_offset_array) {
#line 7390
        l_offset = (OPJ_UINT32 )(l_src_mcc_rec->m_offset_array - l_default_tcp->m_mct_records);
#line 7391
        l_dest_mcc_rec->m_offset_array = l_tcp->m_mct_records + l_offset;
      }
#line 7394
      l_src_mcc_rec ++;
#line 7395
      l_dest_mcc_rec ++;
#line 7382
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 7399
    memcpy(l_current_tccp, l_default_tcp->tccps, (unsigned long )l_tccp_size);
#line 7402
    l_tcp ++;
    }
#line 7323
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7406
  __cil_tmp27 = opj_tcd_create(1);
#line 7406
  p_j2k->m_tcd = (opj_tcd_t *)__cil_tmp27;
  }
#line 7407
  if (! p_j2k->m_tcd) {
#line 7408
    return (0);
  }
  {
#line 7411
  __cil_tmp28 = opj_tcd_init(p_j2k->m_tcd, l_image, & p_j2k->m_cp);
  }
#line 7411
  if (! __cil_tmp28) {
    {
#line 7412
    opj_tcd_destroy(p_j2k->m_tcd);
#line 7413
    p_j2k->m_tcd = (struct opj_tcd *)0;
#line 7414
    opj_event_msg(p_manager, 1, "Cannot decode tile, memory error\n\375\204i\347U");
    }
#line 7415
    return (0);
  }
#line 7418
  return (1);
}
}
#line 7421 "/root/patron/new_21/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler *opj_j2k_get_marker_handler(OPJ_UINT32 p_id ) 
{ 
  opj_dec_memory_marker_handler_t *e ;

  {
#line 7424
  e = (opj_dec_memory_marker_handler_t *)j2k_memory_marker_handler_tab;
  {
#line 7424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7424
    if (! (e->id != 0U)) {
#line 7424
      goto while_break;
    }
#line 7425
    if (e->id == p_id) {
#line 7426
      goto while_break;
    }
#line 7424
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 7429
  return (e);
}
}
#line 7432 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_destroy(opj_j2k_t *p_j2k ) 
{ 


  {
#line 7434
  if (p_j2k == (opj_j2k_t *)0) {
#line 7435
    return;
  }
#line 7438
  if (p_j2k->m_is_decoder) {
#line 7440
    if (p_j2k->m_specific_param.m_decoder.m_default_tcp != (opj_tcp_t *)0) {
      {
#line 7441
      opj_j2k_tcp_destroy(p_j2k->m_specific_param.m_decoder.m_default_tcp);
#line 7442
      free(p_j2k->m_specific_param.m_decoder.m_default_tcp);
#line 7443
      p_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t *)0;
      }
    }
#line 7446
    if (p_j2k->m_specific_param.m_decoder.m_header_data != (OPJ_BYTE *)0) {
      {
#line 7447
      free(p_j2k->m_specific_param.m_decoder.m_header_data);
#line 7448
      p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)0;
#line 7449
      p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
      }
    }
  } else {
#line 7454
    if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
      {
#line 7455
      free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
#line 7456
      p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)0;
      }
    }
#line 7459
    if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
      {
#line 7460
      free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
#line 7461
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)0;
#line 7462
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = (OPJ_BYTE *)0;
      }
    }
#line 7465
    if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
      {
#line 7466
      free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 7467
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)0;
#line 7468
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
      }
    }
  }
  {
#line 7472
  opj_tcd_destroy(p_j2k->m_tcd);
#line 7474
  opj_j2k_cp_destroy(& p_j2k->m_cp);
#line 7475
  memset(& p_j2k->m_cp, 0, sizeof(opj_cp_t ));
#line 7477
  opj_procedure_list_destroy(p_j2k->m_procedure_list);
#line 7478
  p_j2k->m_procedure_list = (opj_procedure_list_t *)0;
#line 7480
  opj_procedure_list_destroy(p_j2k->m_validation_list);
#line 7481
  p_j2k->m_procedure_list = (opj_procedure_list_t *)0;
#line 7483
  j2k_destroy_cstr_index(p_j2k->cstr_index);
#line 7484
  p_j2k->cstr_index = (opj_codestream_index_t *)((void *)0);
#line 7486
  opj_image_destroy(p_j2k->m_private_image);
#line 7487
  p_j2k->m_private_image = (opj_image_t *)((void *)0);
#line 7489
  opj_image_destroy(p_j2k->m_output_image);
#line 7490
  p_j2k->m_output_image = (opj_image_t *)((void *)0);
#line 7492
  free(p_j2k);
  }
  return;
}
}
#line 7495 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind ) 
{ 
  OPJ_UINT32 it_tile ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 7497
  if (p_cstr_ind) {
#line 7499
    if (p_cstr_ind->marker) {
      {
#line 7500
      free(p_cstr_ind->marker);
#line 7501
      p_cstr_ind->marker = (opj_marker_info_t *)((void *)0);
      }
    }
#line 7504
    if (p_cstr_ind->tile_index) {
#line 7505
      it_tile = (OPJ_UINT32 )0;
#line 7507
      it_tile = (OPJ_UINT32 )0;
      {
#line 7507
      while (1) {
        while_continue: /* CIL Label */ ;
#line 7507
        if (! (it_tile < p_cstr_ind->nb_of_tiles)) {
#line 7507
          goto while_break;
        }
#line 7509
        if ((p_cstr_ind->tile_index + it_tile)->packet_index) {
          {
#line 7510
          free((p_cstr_ind->tile_index + it_tile)->packet_index);
#line 7511
          (p_cstr_ind->tile_index + it_tile)->packet_index = (opj_packet_info_t *)((void *)0);
          }
        }
#line 7514
        if ((p_cstr_ind->tile_index + it_tile)->tp_index) {
          {
#line 7515
          free((p_cstr_ind->tile_index + it_tile)->tp_index);
#line 7516
          (p_cstr_ind->tile_index + it_tile)->tp_index = (opj_tp_index_t *)((void *)0);
          }
        }
#line 7519
        if ((p_cstr_ind->tile_index + it_tile)->marker) {
          {
#line 7520
          free((p_cstr_ind->tile_index + it_tile)->marker);
#line 7521
          (p_cstr_ind->tile_index + it_tile)->marker = (opj_marker_info_t *)((void *)0);
          }
        }
#line 7507
        it_tile ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 7526
      free(p_cstr_ind->tile_index);
#line 7527
      p_cstr_ind->tile_index = (opj_tile_index_t *)((void *)0);
      }
    }
    {
#line 7530
    free(p_cstr_ind);
    }
  }
  return;
}
}
#line 7534 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp ) 
{ 
  opj_mct_data_t *l_mct_data ;
  OPJ_UINT32 i ;

  {
#line 7536
  if (p_tcp == (opj_tcp_t *)0) {
#line 7537
    return;
  }
#line 7540
  if (p_tcp->ppt_buffer != (OPJ_BYTE *)0) {
    {
#line 7541
    free(p_tcp->ppt_buffer);
#line 7542
    p_tcp->ppt_buffer = (OPJ_BYTE *)0;
    }
  }
#line 7545
  if (p_tcp->tccps != (opj_tccp_t *)0) {
    {
#line 7546
    free(p_tcp->tccps);
#line 7547
    p_tcp->tccps = (opj_tccp_t *)0;
    }
  }
#line 7550
  if (p_tcp->m_mct_coding_matrix != (OPJ_FLOAT32 *)0) {
    {
#line 7551
    free(p_tcp->m_mct_coding_matrix);
#line 7552
    p_tcp->m_mct_coding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 7555
  if (p_tcp->m_mct_decoding_matrix != (OPJ_FLOAT32 *)0) {
    {
#line 7556
    free(p_tcp->m_mct_decoding_matrix);
#line 7557
    p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 7560
  if (p_tcp->m_mcc_records) {
    {
#line 7561
    free(p_tcp->m_mcc_records);
#line 7562
    p_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)0;
#line 7563
    p_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 7564
    p_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
    }
  }
#line 7567
  if (p_tcp->m_mct_records) {
#line 7568
    l_mct_data = p_tcp->m_mct_records;
#line 7571
    i = (OPJ_UINT32 )0;
    {
#line 7571
    while (1) {
      while_continue: /* CIL Label */ ;
#line 7571
      if (! (i < p_tcp->m_nb_mct_records)) {
#line 7571
        goto while_break;
      }
#line 7572
      if (l_mct_data->m_data) {
        {
#line 7573
        free(l_mct_data->m_data);
#line 7574
        l_mct_data->m_data = (OPJ_BYTE *)0;
        }
      }
#line 7577
      l_mct_data ++;
#line 7571
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 7580
    free(p_tcp->m_mct_records);
#line 7581
    p_tcp->m_mct_records = (opj_mct_data_t *)0;
    }
  }
#line 7584
  if (p_tcp->mct_norms != (OPJ_FLOAT64 *)0) {
    {
#line 7585
    free(p_tcp->mct_norms);
#line 7586
    p_tcp->mct_norms = (OPJ_FLOAT64 *)0;
    }
  }
  {
#line 7589
  opj_j2k_tcp_data_destroy(p_tcp);
  }
  return;
}
}
#line 7593 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp ) 
{ 


  {
#line 7595
  if (p_tcp->m_data) {
    {
#line 7596
    free(p_tcp->m_data);
#line 7597
    p_tcp->m_data = (OPJ_BYTE *)((void *)0);
#line 7598
    p_tcp->m_data_size = (OPJ_UINT32 )0;
    }
  }
  return;
}
}
#line 7602 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_cp_destroy(opj_cp_t *p_cp ) 
{ 
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *l_current_tile ;
  OPJ_UINT32 i ;

  {
#line 7605
  l_current_tile = (opj_tcp_t *)0;
#line 7608
  if (p_cp == (opj_cp_t *)0) {
#line 7610
    return;
  }
#line 7612
  if (p_cp->tcps != (opj_tcp_t *)0) {
#line 7614
    l_current_tile = p_cp->tcps;
#line 7615
    l_nb_tiles = p_cp->th * p_cp->tw;
#line 7617
    i = (OPJ_UINT32 )0;
    {
#line 7617
    while (1) {
      while_continue: /* CIL Label */ ;
#line 7617
      if (! (i < l_nb_tiles)) {
#line 7617
        goto while_break;
      }
      {
#line 7619
      opj_j2k_tcp_destroy(l_current_tile);
#line 7620
      l_current_tile ++;
      }
#line 7617
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 7622
    free(p_cp->tcps);
#line 7623
    p_cp->tcps = (opj_tcp_t *)0;
    }
  }
  {
#line 7625
  free(p_cp->ppm_buffer);
#line 7626
  p_cp->ppm_buffer = (OPJ_BYTE *)0;
#line 7627
  p_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 7628
  free(p_cp->comment);
#line 7629
  p_cp->comment = (OPJ_CHAR *)0;
  }
#line 7630
  if (! p_cp->m_is_decoder) {
    {
#line 7632
    free(p_cp->m_specific_param.m_enc.m_matrice);
#line 7633
    p_cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *)0;
    }
  }
  return;
}
}
#line 7637 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t *p_j2k , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_OFF_T __cil_tmp20 ;
  OPJ_SIZE_T __cil_tmp21 ;
  OPJ_OFF_T __cil_tmp22 ;
  struct opj_dec_memory_marker_handler *__cil_tmp23 ;
  OPJ_BYTE *new_header_data ;
  OPJ_OFF_T __cil_tmp25 ;
  void *__cil_tmp26 ;
  OPJ_SIZE_T __cil_tmp27 ;
  OPJ_BOOL __cil_tmp28 ;
  OPJ_OFF_T __cil_tmp29 ;
  OPJ_BOOL __cil_tmp30 ;
  OPJ_UINT32 sot_pos ;
  OPJ_OFF_T __cil_tmp32 ;
  OPJ_OFF_T __cil_tmp33 ;
  OPJ_SIZE_T __cil_tmp34 ;
  OPJ_OFF_T __cil_tmp35 ;
  OPJ_BOOL __cil_tmp36 ;
  OPJ_SIZE_T __cil_tmp37 ;
  OPJ_SIZE_T __cil_tmp38 ;
  OPJ_BOOL __cil_tmp39 ;
  OPJ_UINT32 __cil_tmp40 ;

  {
#line 7647
  l_current_marker = (OPJ_UINT32 )65424;
#line 7649
  l_marker_handler = (opj_dec_memory_marker_handler_t *)0;
#line 7650
  l_tcp = (opj_tcp_t *)((void *)0);
#line 7659
  if (p_j2k->m_specific_param.m_decoder.m_state == 256U) {
#line 7660
    l_current_marker = (OPJ_UINT32 )65497;
  } else
#line 7663
  if (p_j2k->m_specific_param.m_decoder.m_state != 8U) {
#line 7664
    return (0);
  }
  {
#line 7668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7668
    if (! (! p_j2k->m_specific_param.m_decoder.m_can_decode && l_current_marker != 65497U)) {
#line 7668
      goto while_break;
    }
    {
#line 7671
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 7671
      if (! (l_current_marker != 65427U)) {
#line 7671
        goto while_break___0;
      }
      {
#line 7673
      __cil_tmp20 = opj_stream_get_number_byte_left(p_stream);
      }
#line 7673
      if (__cil_tmp20 == 0L) {
#line 7675
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 7676
        goto while_break___0;
      }
      {
#line 7680
      __cil_tmp21 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )2, p_manager);
      }
#line 7680
      if (__cil_tmp21 != 2UL) {
        {
#line 7681
        opj_event_msg(p_manager, 1, "Stream too short\n");
        }
#line 7682
        return (0);
      }
      {
#line 7686
      opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_marker_size,
                        (OPJ_UINT32 )2);
      }
#line 7689
      if (l_marker_size < 2U) {
        {
#line 7690
        opj_event_msg(p_manager, 1, "Inconsistent marker size\n");
        }
#line 7691
        return (0);
      }
      {
#line 7695
      __cil_tmp22 = opj_stream_get_number_byte_left(p_stream);
      }
#line 7695
      if (l_current_marker == 32896U) {
#line 7695
        if (__cil_tmp22 == 0L) {
#line 7696
          p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 7697
          goto while_break___0;
        }
      }
#line 7701
      if (p_j2k->m_specific_param.m_decoder.m_state & 16U) {
#line 7702
        p_j2k->m_specific_param.m_decoder.m_sot_length -= l_marker_size + 2U;
      }
      {
#line 7704
      l_marker_size -= (unsigned int )2;
#line 7707
      l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
      }
#line 7710
      if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
        {
#line 7711
        opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n");
        }
#line 7712
        return (0);
      }
#line 7717
      if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
        {
#line 7718
        new_header_data = (OPJ_BYTE *)((void *)0);
#line 7721
        __cil_tmp25 = opj_stream_get_number_byte_left(p_stream);
        }
#line 7721
        if ((OPJ_OFF_T )l_marker_size > __cil_tmp25) {
          {
#line 7722
          opj_event_msg(p_manager, 1, "Marker size inconsistent with stream length\n");
          }
#line 7723
          return (0);
        }
        {
#line 7725
        __cil_tmp26 = realloc(p_j2k->m_specific_param.m_decoder.m_header_data, (unsigned long )l_marker_size);
#line 7725
        new_header_data = (OPJ_BYTE *)__cil_tmp26;
        }
#line 7726
        if (! new_header_data) {
          {
#line 7727
          free(p_j2k->m_specific_param.m_decoder.m_header_data);
#line 7728
          p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)((void *)0);
#line 7729
          p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
#line 7730
          opj_event_msg(p_manager, 1, "Not enough memory to read header\n");
          }
#line 7731
          return (0);
        }
#line 7733
        p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
#line 7734
        p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
      }
      {
#line 7738
      __cil_tmp27 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )l_marker_size, p_manager);
      }
#line 7738
      if (__cil_tmp27 != (unsigned long )l_marker_size) {
        {
#line 7739
        opj_event_msg(p_manager, 1, "Stream too short\n");
        }
#line 7740
        return (0);
      }
#line 7743
      if (! l_marker_handler->handler) {
        {
#line 7745
        opj_event_msg(p_manager, 1, "Not sure how that happened.\n");
        }
#line 7746
        return (0);
      }
      {
#line 7749
      __cil_tmp28 = (*(l_marker_handler->handler))(p_j2k, p_j2k->m_specific_param.m_decoder.m_header_data,
                                                   l_marker_size, p_manager);
      }
#line 7749
      if (! __cil_tmp28) {
        {
#line 7750
        opj_event_msg(p_manager, 1, "Fail to read the current marker segment (%#x)\n",
                      l_current_marker);
        }
#line 7751
        return (0);
      }
      {
#line 7755
      __cil_tmp29 = opj_stream_tell(p_stream);
#line 7755
      __cil_tmp30 = opj_j2k_add_tlmarker(p_j2k->m_current_tile_number, p_j2k->cstr_index,
                                         l_marker_handler->id, (OPJ_OFF_T )(((OPJ_UINT32 )__cil_tmp29 - l_marker_size) - 4U),
                                         l_marker_size + 4U);
      }
#line 7755
      if (0 == __cil_tmp30) {
        {
#line 7760
        opj_event_msg(p_manager, 1, "Not enough memory to add tl marker\n");
        }
#line 7761
        return (0);
      }
#line 7765
      if (l_marker_handler->id == 65424U) {
        {
#line 7766
        __cil_tmp32 = opj_stream_tell(p_stream);
#line 7766
        sot_pos = ((OPJ_UINT32 )__cil_tmp32 - l_marker_size) - 4U;
        }
#line 7767
        if ((long )sot_pos > p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos) {
#line 7769
          p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = (OPJ_OFF_T )sot_pos;
        }
      }
#line 7773
      if (p_j2k->m_specific_param.m_decoder.m_skip_data) {
        {
#line 7775
        __cil_tmp33 = opj_stream_skip(p_stream, (OPJ_OFF_T )p_j2k->m_specific_param.m_decoder.m_sot_length,
                                      p_manager);
        }
#line 7775
        if (__cil_tmp33 != (long )p_j2k->m_specific_param.m_decoder.m_sot_length) {
          {
#line 7776
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 7777
          return (0);
        }
#line 7779
        l_current_marker = (OPJ_UINT32 )65427;
      } else {
        {
#line 7783
        __cil_tmp34 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                           (OPJ_SIZE_T )2, p_manager);
        }
#line 7783
        if (__cil_tmp34 != 2UL) {
          {
#line 7784
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 7785
          return (0);
        }
        {
#line 7788
        opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                          (OPJ_UINT32 )2);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 7791
    __cil_tmp35 = opj_stream_get_number_byte_left(p_stream);
    }
#line 7791
    if (__cil_tmp35 == 0L) {
#line 7791
      if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 7793
        goto while_break;
      }
    }
#line 7796
    if (! p_j2k->m_specific_param.m_decoder.m_skip_data) {
      {
#line 7798
      __cil_tmp36 = opj_j2k_read_sod(p_j2k, p_stream, p_manager);
      }
#line 7798
      if (! __cil_tmp36) {
#line 7799
        return (0);
      }
#line 7802
      if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
        {
#line 7804
        __cil_tmp37 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                           (OPJ_SIZE_T )2, p_manager);
        }
#line 7804
        if (__cil_tmp37 != 2UL) {
          {
#line 7805
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 7806
          return (0);
        }
        {
#line 7810
        opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                          (OPJ_UINT32 )2);
        }
      }
    } else {
      {
#line 7815
      p_j2k->m_specific_param.m_decoder.m_skip_data = (OPJ_UINT32 )0;
#line 7816
      p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_UINT32 )0;
#line 7817
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
#line 7820
      __cil_tmp38 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )2, p_manager);
      }
#line 7820
      if (__cil_tmp38 != 2UL) {
        {
#line 7821
        opj_event_msg(p_manager, 1, "Stream too short\n");
        }
#line 7822
        return (0);
      }
      {
#line 7826
      opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                        (OPJ_UINT32 )2);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 7831
  if (l_current_marker == 65497U) {
#line 7832
    if (p_j2k->m_specific_param.m_decoder.m_state != 256U) {
#line 7833
      p_j2k->m_current_tile_number = (OPJ_UINT32 )0;
#line 7834
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
    }
  }
#line 7839
  if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
#line 7840
    l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 7841
    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
    {
#line 7843
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 7843
      if (! (l_tcp->m_data == (OPJ_BYTE *)0 && p_j2k->m_current_tile_number < l_nb_tiles)) {
#line 7843
        goto while_break___1;
      }
#line 7844
      (p_j2k->m_current_tile_number) ++;
#line 7845
      l_tcp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 7848
    if (p_j2k->m_current_tile_number == l_nb_tiles) {
#line 7849
      *p_go_on = 0;
#line 7850
      return (1);
    }
  }
  {
#line 7855
  __cil_tmp39 = opj_tcd_init_decode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number);
  }
#line 7855
  if (! __cil_tmp39) {
    {
#line 7856
    opj_event_msg(p_manager, 1, "Cannot decode tile, memory error\n");
    }
#line 7857
    return (0);
  }
  {
#line 7860
  opj_event_msg(p_manager, 4, "Header of tile %d / %d has been read.\n", p_j2k->m_current_tile_number + 1U,
                p_j2k->m_cp.th * p_j2k->m_cp.tw);
#line 7863
  *p_tile_index = p_j2k->m_current_tile_number;
#line 7864
  *p_go_on = 1;
#line 7865
  *p_data_size = opj_tcd_get_decoded_tile_size(p_j2k->m_tcd);
#line 7866
  *p_tile_x0 = (((p_j2k->m_tcd)->tcd_image)->tiles)->x0;
#line 7867
  *p_tile_y0 = (((p_j2k->m_tcd)->tcd_image)->tiles)->y0;
#line 7868
  *p_tile_x1 = (((p_j2k->m_tcd)->tcd_image)->tiles)->x1;
#line 7869
  *p_tile_y1 = (((p_j2k->m_tcd)->tcd_image)->tiles)->y1;
#line 7870
  *p_nb_comps = (((p_j2k->m_tcd)->tcd_image)->tiles)->numcomps;
#line 7872
  p_j2k->m_specific_param.m_decoder.m_state |= (unsigned int )128;
  }
#line 7874
  return (1);
}
}
#line 7877 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_BYTE l_data[2] ;
  opj_tcp_t *l_tcp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_OFF_T __cil_tmp15 ;
  OPJ_SIZE_T __cil_tmp16 ;
  OPJ_OFF_T __cil_tmp17 ;

  {
#line 7893
  if (! (p_j2k->m_specific_param.m_decoder.m_state & 128U)) {
#line 7895
    return (0);
  } else
#line 7893
  if (p_tile_index != p_j2k->m_current_tile_number) {
#line 7895
    return (0);
  }
#line 7898
  l_tcp = p_j2k->m_cp.tcps + p_tile_index;
#line 7899
  if (! l_tcp->m_data) {
    {
#line 7900
    opj_j2k_tcp_destroy(l_tcp);
    }
#line 7901
    return (0);
  }
  {
#line 7904
  __cil_tmp13 = opj_tcd_decode_tile(p_j2k->m_tcd, l_tcp->m_data, l_tcp->m_data_size,
                                    p_tile_index, p_j2k->cstr_index);
  }
#line 7904
  if (! __cil_tmp13) {
    {
#line 7909
    opj_j2k_tcp_destroy(l_tcp);
#line 7910
    p_j2k->m_specific_param.m_decoder.m_state |= (unsigned int )32768;
#line 7911
    opj_event_msg(p_manager, 1, "Failed to decode.\n");
    }
#line 7912
    return (0);
  }
  {
#line 7915
  __cil_tmp14 = opj_tcd_update_tile_data(p_j2k->m_tcd, p_data, p_data_size);
  }
#line 7915
  if (! __cil_tmp14) {
#line 7916
    return (0);
  }
  {
#line 7923
  opj_j2k_tcp_data_destroy(l_tcp);
#line 7925
  p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_UINT32 )0;
#line 7926
  p_j2k->m_specific_param.m_decoder.m_state &= ~ 128U;
#line 7928
  __cil_tmp15 = opj_stream_get_number_byte_left(p_stream);
  }
#line 7928
  if (__cil_tmp15 == 0L) {
#line 7928
    if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 7930
      return (1);
    }
  }
#line 7933
  if (p_j2k->m_specific_param.m_decoder.m_state != 256U) {
    {
#line 7934
    __cil_tmp16 = opj_stream_read_data(p_stream, (OPJ_BYTE *)l_data, (OPJ_SIZE_T )2,
                                       p_manager);
    }
#line 7934
    if (__cil_tmp16 != 2UL) {
      {
#line 7935
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 7936
      return (0);
    }
    {
#line 7939
    opj_read_bytes_LE((OPJ_BYTE *)l_data, & l_current_marker, (OPJ_UINT32 )2);
    }
#line 7941
    if (l_current_marker == 65497U) {
#line 7942
      p_j2k->m_current_tile_number = (OPJ_UINT32 )0;
#line 7943
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
    } else
#line 7945
    if (l_current_marker != 65424U) {
      {
#line 7947
      __cil_tmp17 = opj_stream_get_number_byte_left(p_stream);
      }
#line 7947
      if (__cil_tmp17 == 0L) {
        {
#line 7948
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 7949
        opj_event_msg(p_manager, 2, "Stream does not end with EOC\n");
        }
#line 7950
        return (1);
      }
      {
#line 7952
      opj_event_msg(p_manager, 1, "Stream too short, expected SOT\n");
      }
#line 7953
      return (0);
    }
  }
#line 7957
  return (1);
}
}
#line 7960 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data , opj_image_t *p_output_image ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 l_width_src ;
  OPJ_UINT32 l_height_src ;
  OPJ_UINT32 l_width_dest ;
  OPJ_UINT32 l_height_dest ;
  OPJ_INT32 l_offset_x0_src ;
  OPJ_INT32 l_offset_y0_src ;
  OPJ_INT32 l_offset_x1_src ;
  OPJ_INT32 l_offset_y1_src ;
  OPJ_INT32 l_start_offset_src ;
  OPJ_INT32 l_line_offset_src ;
  OPJ_INT32 l_end_offset_src ;
  OPJ_UINT32 l_start_x_dest ;
  OPJ_UINT32 l_start_y_dest ;
  OPJ_UINT32 l_x0_dest ;
  OPJ_UINT32 l_y0_dest ;
  OPJ_UINT32 l_x1_dest ;
  OPJ_UINT32 l_y1_dest ;
  OPJ_INT32 l_start_offset_dest ;
  OPJ_INT32 l_line_offset_dest ;
  opj_image_comp_t *l_img_comp_src ;
  opj_image_comp_t *l_img_comp_dest ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_t *l_image_src ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_INT32 *l_dest_ptr ;
  opj_tcd_resolution_t *l_res ;
  void *__cil_tmp34 ;
  OPJ_INT32 __cil_tmp35 ;
  OPJ_INT32 __cil_tmp36 ;
  int tmp ;
  int tmp___0 ;
  OPJ_CHAR *l_src_ptr ;
  OPJ_INT32 *__cil_tmp40 ;
  OPJ_CHAR *__cil_tmp41 ;
  OPJ_INT32 *__cil_tmp42 ;
  OPJ_CHAR *__cil_tmp43 ;
  OPJ_INT16 *l_src_ptr___0 ;
  OPJ_INT32 *__cil_tmp45 ;
  OPJ_INT16 *__cil_tmp46 ;
  OPJ_INT32 *__cil_tmp47 ;
  OPJ_INT16 *__cil_tmp48 ;
  OPJ_INT32 *l_src_ptr___1 ;
  OPJ_INT32 *__cil_tmp50 ;
  OPJ_INT32 *__cil_tmp51 ;
  OPJ_UINT32 __cil_tmp52 ;

  {
#line 7962
  k = (OPJ_UINT32 )0;
#line 7971
  l_img_comp_src = (opj_image_comp_t *)0;
#line 7972
  l_img_comp_dest = (opj_image_comp_t *)0;
#line 7974
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 7975
  l_image_src = (opj_image_t *)0;
#line 7978
  l_res = (opj_tcd_resolution_t *)0;
#line 7980
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 7981
  l_image_src = p_tcd->image;
#line 7982
  l_img_comp_src = l_image_src->comps;
#line 7984
  l_img_comp_dest = p_output_image->comps;
#line 7986
  i = (OPJ_UINT32 )0;
  {
#line 7986
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7986
    if (! (i < l_image_src->numcomps)) {
#line 7986
      goto while_break;
    }
#line 7989
    if (! l_img_comp_dest->data) {
      {
#line 7991
      __cil_tmp34 = calloc((unsigned long )(l_img_comp_dest->w * l_img_comp_dest->h),
                           sizeof(OPJ_INT32 ));
#line 7991
      l_img_comp_dest->data = (OPJ_INT32 *)__cil_tmp34;
      }
#line 7992
      if (! l_img_comp_dest->data) {
#line 7993
        return (0);
      }
    }
#line 7998
    l_img_comp_dest->resno_decoded = l_img_comp_src->resno_decoded;
#line 8002
    l_size_comp = l_img_comp_src->prec >> 3;
#line 8003
    l_remaining = l_img_comp_src->prec & 7U;
#line 8004
    l_res = l_tilec->resolutions + l_img_comp_src->resno_decoded;
#line 8006
    if (l_remaining) {
#line 8007
      l_size_comp ++;
    }
#line 8010
    if (l_size_comp == 3U) {
#line 8011
      l_size_comp = (OPJ_UINT32 )4;
    }
    {
#line 8021
    l_width_src = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 8022
    l_height_src = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
#line 8025
    __cil_tmp35 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp_dest->x0, (OPJ_INT32 )l_img_comp_dest->factor);
#line 8025
    l_x0_dest = (OPJ_UINT32 )__cil_tmp35;
#line 8026
    __cil_tmp36 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp_dest->y0, (OPJ_INT32 )l_img_comp_dest->factor);
#line 8026
    l_y0_dest = (OPJ_UINT32 )__cil_tmp36;
#line 8027
    l_x1_dest = l_x0_dest + l_img_comp_dest->w;
#line 8028
    l_y1_dest = l_y0_dest + l_img_comp_dest->h;
    }
#line 8044
    if (l_x0_dest < (OPJ_UINT32 )l_res->x0) {
#line 8045
      l_start_x_dest = (OPJ_UINT32 )l_res->x0 - l_x0_dest;
#line 8046
      l_offset_x0_src = 0;
#line 8048
      if (l_x1_dest >= (OPJ_UINT32 )l_res->x1) {
#line 8049
        l_width_dest = l_width_src;
#line 8050
        l_offset_x1_src = 0;
      } else {
#line 8053
        l_width_dest = l_x1_dest - (OPJ_UINT32 )l_res->x0;
#line 8054
        l_offset_x1_src = (OPJ_INT32 )(l_width_src - l_width_dest);
      }
    } else {
#line 8058
      l_start_x_dest = (OPJ_UINT32 )0;
#line 8059
      l_offset_x0_src = (OPJ_INT32 )l_x0_dest - l_res->x0;
#line 8061
      if (l_x1_dest >= (OPJ_UINT32 )l_res->x1) {
#line 8062
        l_width_dest = l_width_src - (OPJ_UINT32 )l_offset_x0_src;
#line 8063
        l_offset_x1_src = 0;
      } else {
#line 8066
        l_width_dest = l_img_comp_dest->w;
#line 8067
        l_offset_x1_src = l_res->x1 - (OPJ_INT32 )l_x1_dest;
      }
    }
#line 8071
    if (l_y0_dest < (OPJ_UINT32 )l_res->y0) {
#line 8072
      l_start_y_dest = (OPJ_UINT32 )l_res->y0 - l_y0_dest;
#line 8073
      l_offset_y0_src = 0;
#line 8075
      if (l_y1_dest >= (OPJ_UINT32 )l_res->y1) {
#line 8076
        l_height_dest = l_height_src;
#line 8077
        l_offset_y1_src = 0;
      } else {
#line 8080
        l_height_dest = l_y1_dest - (OPJ_UINT32 )l_res->y0;
#line 8081
        l_offset_y1_src = (OPJ_INT32 )(l_height_src - l_height_dest);
      }
    } else {
#line 8085
      l_start_y_dest = (OPJ_UINT32 )0;
#line 8086
      l_offset_y0_src = (OPJ_INT32 )l_y0_dest - l_res->y0;
#line 8088
      if (l_y1_dest >= (OPJ_UINT32 )l_res->y1) {
#line 8089
        l_height_dest = l_height_src - (OPJ_UINT32 )l_offset_y0_src;
#line 8090
        l_offset_y1_src = 0;
      } else {
#line 8093
        l_height_dest = l_img_comp_dest->h;
#line 8094
        l_offset_y1_src = l_res->y1 - (OPJ_INT32 )l_y1_dest;
      }
    }
#line 8098
    if (l_offset_x0_src < 0) {
#line 8099
      return (0);
    } else
#line 8098
    if (l_offset_y0_src < 0) {
#line 8099
      return (0);
    } else
#line 8098
    if (l_offset_x1_src < 0) {
#line 8099
      return (0);
    } else
#line 8098
    if (l_offset_y1_src < 0) {
#line 8099
      return (0);
    }
#line 8102
    if ((OPJ_INT32 )l_width_dest < 0) {
#line 8103
      return (0);
    } else
#line 8102
    if ((OPJ_INT32 )l_height_dest < 0) {
#line 8103
      return (0);
    }
#line 8108
    l_start_offset_src = l_offset_x0_src + l_offset_y0_src * (OPJ_INT32 )l_width_src;
#line 8109
    l_line_offset_src = l_offset_x1_src + l_offset_x0_src;
#line 8110
    l_end_offset_src = l_offset_y1_src * (OPJ_INT32 )l_width_src - l_offset_x0_src;
#line 8113
    l_start_offset_dest = (OPJ_INT32 )(l_start_x_dest + l_start_y_dest * l_img_comp_dest->w);
#line 8114
    l_line_offset_dest = (OPJ_INT32 )(l_img_comp_dest->w - l_width_dest);
#line 8117
    l_dest_ptr = l_img_comp_dest->data + l_start_offset_dest;
    {
#line 8134
    if (l_size_comp == (OPJ_UINT32 )1) {
#line 8134
      goto case_1;
    }
#line 8164
    if (l_size_comp == (OPJ_UINT32 )2) {
#line 8164
      goto case_2;
    }
#line 8194
    if (l_size_comp == (OPJ_UINT32 )4) {
#line 8194
      goto case_4;
    }
#line 8133
    goto switch_break;
    case_1: /* CIL Label */ 
#line 8136
    l_src_ptr = (OPJ_CHAR *)p_data;
#line 8137
    l_src_ptr += l_start_offset_src;
#line 8139
    if (l_img_comp_src->sgnd) {
#line 8140
      j = (OPJ_UINT32 )0;
      {
#line 8140
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 8140
        if (! (j < l_height_dest)) {
#line 8140
          goto while_break___0;
        }
#line 8141
        k = (OPJ_UINT32 )0;
        {
#line 8141
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 8141
          if (! (k < l_width_dest)) {
#line 8141
            goto while_break___1;
          }
#line 8142
          __cil_tmp41 = l_src_ptr;
#line 8142
          l_src_ptr ++;
#line 8142
          __cil_tmp40 = l_dest_ptr;
#line 8142
          l_dest_ptr ++;
#line 8142
          *__cil_tmp40 = (OPJ_INT32 )*__cil_tmp41;
#line 8141
          k ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 8145
        l_dest_ptr += l_line_offset_dest;
#line 8146
        l_src_ptr += l_line_offset_src;
#line 8140
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 8150
      j = (OPJ_UINT32 )0;
      {
#line 8150
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 8150
        if (! (j < l_height_dest)) {
#line 8150
          goto while_break___2;
        }
#line 8151
        k = (OPJ_UINT32 )0;
        {
#line 8151
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 8151
          if (! (k < l_width_dest)) {
#line 8151
            goto while_break___3;
          }
#line 8152
          __cil_tmp43 = l_src_ptr;
#line 8152
          l_src_ptr ++;
#line 8152
          __cil_tmp42 = l_dest_ptr;
#line 8152
          l_dest_ptr ++;
#line 8152
          *__cil_tmp42 = (OPJ_INT32 )((int )*__cil_tmp43 & 255);
#line 8151
          k ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 8155
        l_dest_ptr += l_line_offset_dest;
#line 8156
        l_src_ptr += l_line_offset_src;
#line 8150
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 8160
    l_src_ptr += l_end_offset_src;
#line 8161
    p_data = (OPJ_BYTE *)l_src_ptr;
#line 8163
    goto switch_break;
    case_2: /* CIL Label */ 
#line 8166
    l_src_ptr___0 = (OPJ_INT16 *)p_data;
#line 8167
    l_src_ptr___0 += l_start_offset_src;
#line 8169
    if (l_img_comp_src->sgnd) {
#line 8170
      j = (OPJ_UINT32 )0;
      {
#line 8170
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 8170
        if (! (j < l_height_dest)) {
#line 8170
          goto while_break___4;
        }
#line 8171
        k = (OPJ_UINT32 )0;
        {
#line 8171
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 8171
          if (! (k < l_width_dest)) {
#line 8171
            goto while_break___5;
          }
#line 8172
          __cil_tmp46 = l_src_ptr___0;
#line 8172
          l_src_ptr___0 ++;
#line 8172
          __cil_tmp45 = l_dest_ptr;
#line 8172
          l_dest_ptr ++;
#line 8172
          *__cil_tmp45 = (OPJ_INT32 )*__cil_tmp46;
#line 8171
          k ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 8175
        l_dest_ptr += l_line_offset_dest;
#line 8176
        l_src_ptr___0 += l_line_offset_src;
#line 8170
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 8180
      j = (OPJ_UINT32 )0;
      {
#line 8180
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 8180
        if (! (j < l_height_dest)) {
#line 8180
          goto while_break___6;
        }
#line 8181
        k = (OPJ_UINT32 )0;
        {
#line 8181
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 8181
          if (! (k < l_width_dest)) {
#line 8181
            goto while_break___7;
          }
#line 8182
          __cil_tmp48 = l_src_ptr___0;
#line 8182
          l_src_ptr___0 ++;
#line 8182
          __cil_tmp47 = l_dest_ptr;
#line 8182
          l_dest_ptr ++;
#line 8182
          *__cil_tmp47 = (int )*__cil_tmp48 & 65535;
#line 8181
          k ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 8185
        l_dest_ptr += l_line_offset_dest;
#line 8186
        l_src_ptr___0 += l_line_offset_src;
#line 8180
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 8190
    l_src_ptr___0 += l_end_offset_src;
#line 8191
    p_data = (OPJ_BYTE *)l_src_ptr___0;
#line 8193
    goto switch_break;
    case_4: /* CIL Label */ 
#line 8196
    l_src_ptr___1 = (OPJ_INT32 *)p_data;
#line 8197
    l_src_ptr___1 += l_start_offset_src;
#line 8199
    j = (OPJ_UINT32 )0;
    {
#line 8199
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 8199
      if (! (j < l_height_dest)) {
#line 8199
        goto while_break___8;
      }
#line 8200
      k = (OPJ_UINT32 )0;
      {
#line 8200
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 8200
        if (! (k < l_width_dest)) {
#line 8200
          goto while_break___9;
        }
#line 8201
        __cil_tmp51 = l_src_ptr___1;
#line 8201
        l_src_ptr___1 ++;
#line 8201
        __cil_tmp50 = l_dest_ptr;
#line 8201
        l_dest_ptr ++;
#line 8201
        *__cil_tmp50 = *__cil_tmp51;
#line 8200
        k ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 8204
      l_dest_ptr += l_line_offset_dest;
#line 8205
      l_src_ptr___1 += l_line_offset_src;
#line 8199
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 8208
    l_src_ptr___1 += l_end_offset_src;
#line 8209
    p_data = (OPJ_BYTE *)l_src_ptr___1;
#line 8211
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 8214
    l_img_comp_dest ++;
#line 8215
    l_img_comp_src ++;
#line 8216
    l_tilec ++;
#line 7986
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 8219
  return (1);
}
}
#line 8222 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_image_t *l_image ;
  OPJ_UINT32 it_comp ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  opj_image_comp_t *l_img_comp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  OPJ_INT32 l_h ;
  OPJ_INT32 l_w ;
  OPJ_INT32 __cil_tmp22 ;
  OPJ_INT32 __cil_tmp23 ;
  OPJ_INT32 __cil_tmp24 ;
  OPJ_INT32 __cil_tmp25 ;
  OPJ_INT32 __cil_tmp26 ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;
  opj_image_comp_t *__cil_tmp30 ;

  {
#line 8228
  l_cp = & p_j2k->m_cp;
#line 8229
  l_image = p_j2k->m_private_image;
#line 8233
  l_img_comp = (opj_image_comp_t *)((void *)0);
#line 8236
  if (p_j2k->m_specific_param.m_decoder.m_state != 8U) {
    {
#line 8237
    opj_event_msg(p_manager, 1, "Need to decode the main header before begin to decode the remaining codestream");
    }
#line 8238
    return (0);
  }
#line 8241
  if (! p_start_x) {
#line 8241
    if (! p_start_y) {
#line 8241
      if (! p_end_x) {
#line 8241
        if (! p_end_y) {
          {
#line 8242
          opj_event_msg(p_manager, 4, "No decoded area parameters, set the decoded area to the whole image\n\347U");
#line 8244
          p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 8245
          p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 8246
          p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 8247
          p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
          }
#line 8249
          return (1);
        }
      }
    }
  }
#line 8259
  if ((OPJ_UINT32 )p_start_x > l_image->x1) {
    {
#line 8260
    opj_event_msg(p_manager, 1, "Left position of the decoded area (region_x0=%d) is outside the image area (Xsiz=%d).\n",
                  p_start_x, l_image->x1);
    }
#line 8263
    return (0);
  } else
#line 8265
  if ((OPJ_UINT32 )p_start_x < l_image->x0) {
    {
#line 8266
    opj_event_msg(p_manager, 2, "Left position of the decoded area (region_x0=%d) is outside the image area (XOsiz=%d).\n",
                  p_start_x, l_image->x0);
#line 8269
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 8270
    p_image->x0 = l_image->x0;
    }
  } else {
#line 8273
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = ((OPJ_UINT32 )p_start_x - l_cp->tx0) / l_cp->tdx;
#line 8274
    p_image->x0 = (OPJ_UINT32 )p_start_x;
  }
#line 8278
  if ((OPJ_UINT32 )p_start_y > l_image->y1) {
    {
#line 8279
    opj_event_msg(p_manager, 1, "Up position of the decoded area (region_y0=%d) is outside the image area (Ysiz=%d).\n",
                  p_start_y, l_image->y1);
    }
#line 8282
    return (0);
  } else
#line 8284
  if ((OPJ_UINT32 )p_start_y < l_image->y0) {
    {
#line 8285
    opj_event_msg(p_manager, 2, "Up position of the decoded area (region_y0=%d) is outside the image area (YOsiz=%d).\n",
                  p_start_y, l_image->y0);
#line 8288
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 8289
    p_image->y0 = l_image->y0;
    }
  } else {
#line 8292
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = ((OPJ_UINT32 )p_start_y - l_cp->ty0) / l_cp->tdy;
#line 8293
    p_image->y0 = (OPJ_UINT32 )p_start_y;
  }
#line 8299
  if ((OPJ_UINT32 )p_end_x < l_image->x0) {
    {
#line 8300
    opj_event_msg(p_manager, 1, "Right position of the decoded area (region_x1=%d) is outside the image area (XOsiz=%d).\n\230\001",
                  p_end_x, l_image->x0);
    }
#line 8303
    return (0);
  } else
#line 8305
  if ((OPJ_UINT32 )p_end_x > l_image->x1) {
    {
#line 8306
    opj_event_msg(p_manager, 2, "Right position of the decoded area (region_x1=%d) is outside the image area (Xsiz=%d).\n",
                  p_end_x, l_image->x1);
#line 8309
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 8310
    p_image->x1 = l_image->x1;
    }
  } else {
    {
#line 8313
    __cil_tmp18 = opj_int_ceildiv(p_end_x - (OPJ_INT32 )l_cp->tx0, (OPJ_INT32 )l_cp->tdx);
#line 8313
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32 )__cil_tmp18;
#line 8314
    p_image->x1 = (OPJ_UINT32 )p_end_x;
    }
  }
#line 8318
  if ((OPJ_UINT32 )p_end_y < l_image->y0) {
    {
#line 8319
    opj_event_msg(p_manager, 1, "Bottom position of the decoded area (region_y1=%d) is outside the image area (YOsiz=%d).\n*\210i\347U",
                  p_end_y, l_image->y0);
    }
#line 8322
    return (0);
  }
#line 8324
  if ((OPJ_UINT32 )p_end_y > l_image->y1) {
    {
#line 8325
    opj_event_msg(p_manager, 2, "Bottom position of the decoded area (region_y1=%d) is outside the image area (Ysiz=%d).\n\230\001",
                  p_end_y, l_image->y1);
#line 8328
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
#line 8329
    p_image->y1 = l_image->y1;
    }
  } else {
    {
#line 8332
    __cil_tmp19 = opj_int_ceildiv(p_end_y - (OPJ_INT32 )l_cp->ty0, (OPJ_INT32 )l_cp->tdy);
#line 8332
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32 )__cil_tmp19;
#line 8333
    p_image->y1 = (OPJ_UINT32 )p_end_y;
    }
  }
#line 8337
  p_j2k->m_specific_param.m_decoder.m_discard_tiles = (OPJ_UINT32 )1;
#line 8339
  l_img_comp = p_image->comps;
#line 8340
  it_comp = (OPJ_UINT32 )0;
  {
#line 8340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8340
    if (! (it_comp < p_image->numcomps)) {
#line 8340
      goto while_break;
    }
    {
#line 8344
    __cil_tmp22 = opj_int_ceildiv((OPJ_INT32 )p_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 8344
    l_img_comp->x0 = (OPJ_UINT32 )__cil_tmp22;
#line 8345
    __cil_tmp23 = opj_int_ceildiv((OPJ_INT32 )p_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 8345
    l_img_comp->y0 = (OPJ_UINT32 )__cil_tmp23;
#line 8346
    l_comp_x1 = opj_int_ceildiv((OPJ_INT32 )p_image->x1, (OPJ_INT32 )l_img_comp->dx);
#line 8347
    l_comp_y1 = opj_int_ceildiv((OPJ_INT32 )p_image->y1, (OPJ_INT32 )l_img_comp->dy);
#line 8349
    __cil_tmp27 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->x0, (OPJ_INT32 )l_img_comp->factor);
    }
    {
#line 8349
    __cil_tmp26 = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32 )l_img_comp->factor);
#line 8349
    l_w = __cil_tmp26 - __cil_tmp27;
    }
#line 8351
    if (l_w < 0) {
      {
#line 8352
      opj_event_msg(p_manager, 1, "Size x of the decoded component image is incorrect (comp[%d].w=%d).\n",
                    it_comp, l_w);
      }
#line 8355
      return (0);
    }
    {
#line 8357
    l_img_comp->w = (OPJ_UINT32 )l_w;
#line 8359
    __cil_tmp29 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->y0, (OPJ_INT32 )l_img_comp->factor);
    }
    {
#line 8359
    __cil_tmp28 = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32 )l_img_comp->factor);
#line 8359
    l_h = __cil_tmp28 - __cil_tmp29;
    }
#line 8361
    if (l_h < 0) {
      {
#line 8362
      opj_event_msg(p_manager, 1, "Size y of the decoded component image is incorrect (comp[%d].h=%d).\n\347U",
                    it_comp, l_h);
      }
#line 8365
      return (0);
    }
#line 8367
    l_img_comp->h = (OPJ_UINT32 )l_h;
#line 8369
    l_img_comp ++;
#line 8340
    it_comp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 8372
  opj_event_msg(p_manager, 4, "Setting decoding area to %d,%d,%d,%d\n", p_image->x0,
                p_image->y0, p_image->x1, p_image->y1);
  }
#line 8375
  return (1);
}
}
#line 8378 "/root/patron/new_21/src/lib/openjp2/j2k.c"
opj_j2k_t *opj_j2k_create_decompress(void) 
{ 
  opj_j2k_t *l_j2k ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  opj_codestream_index_t *__cil_tmp5 ;
  opj_procedure_list_t *__cil_tmp6 ;
  opj_procedure_list_t *__cil_tmp7 ;

  {
  {
#line 8380
  __cil_tmp2 = calloc((unsigned long )1, sizeof(opj_j2k_t ));
#line 8380
  l_j2k = (opj_j2k_t *)__cil_tmp2;
  }
#line 8381
  if (! l_j2k) {
#line 8382
    return ((opj_j2k_t *)0);
  }
  {
#line 8385
  l_j2k->m_is_decoder = 1;
#line 8386
  l_j2k->m_cp.m_is_decoder = (OPJ_UINT32 )1;
#line 8388
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_tcp_t ));
#line 8388
  l_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t *)__cil_tmp3;
  }
#line 8389
  if (! l_j2k->m_specific_param.m_decoder.m_default_tcp) {
    {
#line 8390
    opj_j2k_destroy(l_j2k);
    }
#line 8391
    return ((opj_j2k_t *)0);
  }
  {
#line 8394
  __cil_tmp4 = calloc((unsigned long )1, (unsigned long )1000);
#line 8394
  l_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)__cil_tmp4;
  }
#line 8395
  if (! l_j2k->m_specific_param.m_decoder.m_header_data) {
    {
#line 8396
    opj_j2k_destroy(l_j2k);
    }
#line 8397
    return ((opj_j2k_t *)0);
  }
  {
#line 8400
  l_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )1000;
#line 8402
  l_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = - 1;
#line 8404
  l_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = (OPJ_OFF_T )0;
#line 8407
  l_j2k->cstr_index = opj_j2k_create_cstr_index();
  }
#line 8408
  if (! l_j2k->cstr_index) {
    {
#line 8409
    opj_j2k_destroy(l_j2k);
    }
#line 8410
    return ((opj_j2k_t *)0);
  }
  {
#line 8414
  l_j2k->m_validation_list = opj_procedure_list_create();
  }
#line 8415
  if (! l_j2k->m_validation_list) {
    {
#line 8416
    opj_j2k_destroy(l_j2k);
    }
#line 8417
    return ((opj_j2k_t *)0);
  }
  {
#line 8421
  l_j2k->m_procedure_list = opj_procedure_list_create();
  }
#line 8422
  if (! l_j2k->m_procedure_list) {
    {
#line 8423
    opj_j2k_destroy(l_j2k);
    }
#line 8424
    return ((opj_j2k_t *)0);
  }
#line 8427
  return (l_j2k);
}
}
#line 8430 "/root/patron/new_21/src/lib/openjp2/j2k.c"
opj_codestream_index_t *opj_j2k_create_cstr_index(void) 
{ 
  opj_codestream_index_t *cstr_index ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 8432
  __cil_tmp2 = calloc((unsigned long )1, sizeof(opj_codestream_index_t ));
#line 8432
  cstr_index = (opj_codestream_index_t *)__cil_tmp2;
  }
#line 8434
  if (! cstr_index) {
#line 8435
    return ((opj_codestream_index_t *)((void *)0));
  }
  {
#line 8437
  cstr_index->maxmarknum = (OPJ_UINT32 )100;
#line 8438
  cstr_index->marknum = (OPJ_UINT32 )0;
#line 8439
  __cil_tmp3 = calloc((unsigned long )cstr_index->maxmarknum, sizeof(opj_marker_info_t ));
#line 8439
  cstr_index->marker = (opj_marker_info_t *)__cil_tmp3;
  }
#line 8441
  if (! cstr_index->marker) {
#line 8442
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 8444
  cstr_index->tile_index = (opj_tile_index_t *)((void *)0);
#line 8446
  return (cstr_index);
}
}
#line 8449 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                        OPJ_UINT32 p_comp_no ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 8453
  l_cp = (opj_cp_t *)0;
#line 8454
  l_tcp = (opj_tcp_t *)0;
#line 8455
  l_tccp = (opj_tccp_t *)0;
#line 8460
  l_cp = & p_j2k->m_cp;
#line 8461
  l_tcp = l_cp->tcps + p_tile_no;
#line 8462
  l_tccp = l_tcp->tccps + p_comp_no;
#line 8468
  if (l_tccp->csty & 1U) {
#line 8469
    return (5U + l_tccp->numresolutions);
  } else {
#line 8472
    return ((OPJ_UINT32 )5);
  }
}
}
#line 8476 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                   OPJ_BYTE *p_data , OPJ_UINT32 *p_header_size ,
                                   struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 8484
  l_cp = (opj_cp_t *)0;
#line 8485
  l_tcp = (opj_tcp_t *)0;
#line 8486
  l_tccp = (opj_tccp_t *)0;
#line 8494
  l_cp = & p_j2k->m_cp;
#line 8495
  l_tcp = l_cp->tcps + p_tile_no;
#line 8496
  l_tccp = l_tcp->tccps + p_comp_no;
#line 8502
  if (*p_header_size < 5U) {
    {
#line 8503
    opj_event_msg(p_manager, 1, "Error writing SPCod SPCoc element\n\210i\347U");
    }
#line 8504
    return (0);
  }
  {
#line 8507
  opj_write_bytes_LE(p_data, l_tccp->numresolutions - 1U, (OPJ_UINT32 )1);
#line 8508
  p_data ++;
#line 8510
  opj_write_bytes_LE(p_data, l_tccp->cblkw - 2U, (OPJ_UINT32 )1);
#line 8511
  p_data ++;
#line 8513
  opj_write_bytes_LE(p_data, l_tccp->cblkh - 2U, (OPJ_UINT32 )1);
#line 8514
  p_data ++;
#line 8516
  opj_write_bytes_LE(p_data, l_tccp->cblksty, (OPJ_UINT32 )1);
#line 8517
  p_data ++;
#line 8519
  opj_write_bytes_LE(p_data, l_tccp->qmfbid, (OPJ_UINT32 )1);
#line 8520
  p_data ++;
#line 8522
  *p_header_size -= 5U;
  }
#line 8524
  if (l_tccp->csty & 1U) {
#line 8526
    if (*p_header_size < l_tccp->numresolutions) {
      {
#line 8527
      opj_event_msg(p_manager, 1, "Error writing SPCod SPCoc element\n\210i\347U");
      }
#line 8528
      return (0);
    }
#line 8531
    i = (OPJ_UINT32 )0;
    {
#line 8531
    while (1) {
      while_continue: /* CIL Label */ ;
#line 8531
      if (! (i < l_tccp->numresolutions)) {
#line 8531
        goto while_break;
      }
      {
#line 8532
      opj_write_bytes_LE(p_data, l_tccp->prcw[i] + (l_tccp->prch[i] << 4), (OPJ_UINT32 )1);
#line 8533
      p_data ++;
      }
#line 8531
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 8536
    *p_header_size -= l_tccp->numresolutions;
  }
#line 8539
  return (1);
}
}
#line 8542 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 compno , OPJ_BYTE *p_header_data ,
                                  OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_tmp ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_BYTE *l_current_ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  opj_tcp_t *tmp___2 ;
  int tmp___3 ;

  {
#line 8549
  l_cp = (opj_cp_t *)((void *)0);
#line 8550
  l_tcp = (opj_tcp_t *)((void *)0);
#line 8551
  l_tccp = (opj_tccp_t *)((void *)0);
#line 8552
  l_current_ptr = (OPJ_BYTE *)((void *)0);
#line 8559
  l_cp = & p_j2k->m_cp;
#line 8560
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 8560
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 8560
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 8560
  l_tcp = tmp___2;
#line 8567
  l_tccp = l_tcp->tccps + compno;
#line 8568
  l_current_ptr = p_header_data;
#line 8571
  if (*p_header_size < 5U) {
    {
#line 8572
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element\n\210i\347U");
    }
#line 8573
    return (0);
  }
  {
#line 8576
  opj_read_bytes_LE(l_current_ptr, & l_tccp->numresolutions, (OPJ_UINT32 )1);
#line 8577
  (l_tccp->numresolutions) ++;
  }
#line 8578
  if (l_tccp->numresolutions > 33U) {
    {
#line 8579
    opj_event_msg(p_manager, 1, "Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\n",
                  l_tccp->numresolutions, 33);
    }
#line 8582
    return (0);
  }
#line 8584
  l_current_ptr ++;
#line 8587
  if (l_cp->m_specific_param.m_dec.m_reduce >= l_tccp->numresolutions) {
    {
#line 8588
    opj_event_msg(p_manager, 1, "Error decoding component %d.\nThe number of resolutions to remove is higher than the number of resolutions of this component\nModify the cp_reduce parameter.\n\n",
                  compno);
#line 8590
    p_j2k->m_specific_param.m_decoder.m_state |= (unsigned int )32768;
    }
#line 8591
    return (0);
  }
  {
#line 8594
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblkw, (OPJ_UINT32 )1);
#line 8595
  l_current_ptr ++;
#line 8596
  l_tccp->cblkw += (unsigned int )2;
#line 8598
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblkh, (OPJ_UINT32 )1);
#line 8599
  l_current_ptr ++;
#line 8600
  l_tccp->cblkh += (unsigned int )2;
#line 8602
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblksty, (OPJ_UINT32 )1);
#line 8603
  l_current_ptr ++;
#line 8605
  opj_read_bytes_LE(l_current_ptr, & l_tccp->qmfbid, (OPJ_UINT32 )1);
#line 8606
  l_current_ptr ++;
#line 8608
  *p_header_size -= 5U;
  }
#line 8611
  if (l_tccp->csty & 1U) {
#line 8612
    if (*p_header_size < l_tccp->numresolutions) {
      {
#line 8613
      opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element\n");
      }
#line 8614
      return (0);
    }
#line 8617
    i = (OPJ_UINT32 )0;
    {
#line 8617
    while (1) {
      while_continue: /* CIL Label */ ;
#line 8617
      if (! (i < l_tccp->numresolutions)) {
#line 8617
        goto while_break;
      }
      {
#line 8618
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 8619
      l_current_ptr ++;
#line 8620
      l_tccp->prcw[i] = l_tmp & 15U;
#line 8621
      l_tccp->prch[i] = l_tmp >> 4;
      }
#line 8617
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 8624
    *p_header_size -= l_tccp->numresolutions;
  } else {
#line 8628
    i = (OPJ_UINT32 )0;
    {
#line 8628
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 8628
      if (! (i < l_tccp->numresolutions)) {
#line 8628
        goto while_break___0;
      }
#line 8629
      l_tccp->prcw[i] = (OPJ_UINT32 )15;
#line 8630
      l_tccp->prch[i] = (OPJ_UINT32 )15;
#line 8628
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 8651
  return (1);
}
}
#line 8654 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_ref_tccp ;
  opj_tccp_t *l_copied_tccp ;
  OPJ_UINT32 l_prc_size ;
  int tmp ;
  opj_tcp_t *tmp___0 ;

  {
#line 8658
  l_cp = (opj_cp_t *)((void *)0);
#line 8659
  l_tcp = (opj_tcp_t *)((void *)0);
#line 8660
  l_ref_tccp = (opj_tccp_t *)((void *)0);
#line 8660
  l_copied_tccp = (opj_tccp_t *)((void *)0);
#line 8666
  l_cp = & p_j2k->m_cp;
#line 8667
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 8667
    tmp___0 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 8667
    tmp___0 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 8667
  l_tcp = tmp___0;
#line 8671
  l_ref_tccp = l_tcp->tccps + 0;
#line 8672
  l_copied_tccp = l_ref_tccp + 1;
#line 8673
  l_prc_size = l_ref_tccp->numresolutions * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 8675
  i = (OPJ_UINT32 )1;
  {
#line 8675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8675
    if (! (i < (p_j2k->m_private_image)->numcomps)) {
#line 8675
      goto while_break;
    }
    {
#line 8676
    l_copied_tccp->numresolutions = l_ref_tccp->numresolutions;
#line 8677
    l_copied_tccp->cblkw = l_ref_tccp->cblkw;
#line 8678
    l_copied_tccp->cblkh = l_ref_tccp->cblkh;
#line 8679
    l_copied_tccp->cblksty = l_ref_tccp->cblksty;
#line 8680
    l_copied_tccp->qmfbid = l_ref_tccp->qmfbid;
#line 8681
    memcpy((OPJ_UINT32 *)l_copied_tccp->prcw, (OPJ_UINT32 *)l_ref_tccp->prcw, (unsigned long )l_prc_size);
#line 8682
    memcpy((OPJ_UINT32 *)l_copied_tccp->prch, (OPJ_UINT32 *)l_ref_tccp->prch, (unsigned long )l_prc_size);
#line 8683
    l_copied_tccp ++;
    }
#line 8675
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 8687 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ) 
{ 
  OPJ_UINT32 l_num_bands ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 8693
  l_cp = (opj_cp_t *)0;
#line 8694
  l_tcp = (opj_tcp_t *)0;
#line 8695
  l_tccp = (opj_tccp_t *)0;
#line 8700
  l_cp = & p_j2k->m_cp;
#line 8701
  l_tcp = l_cp->tcps + p_tile_no;
#line 8702
  l_tccp = l_tcp->tccps + p_comp_no;
#line 8708
  if (l_tccp->qntsty == 1U) {
#line 8708
    tmp___2 = (unsigned int )1;
  } else {
#line 8708
    tmp___2 = l_tccp->numresolutions * 3U - 2U;
  }
#line 8708
  l_num_bands = tmp___2;
#line 8710
  if (l_tccp->qntsty == 0U) {
#line 8711
    return (1U + l_num_bands);
  } else {
#line 8714
    return (1U + 2U * l_num_bands);
  }
}
}
#line 8718 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                 OPJ_BYTE *p_data , OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_header_size ;
  OPJ_UINT32 l_band_no ;
  OPJ_UINT32 l_num_bands ;
  OPJ_UINT32 l_expn ;
  OPJ_UINT32 l_mant ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 8729
  l_cp = (opj_cp_t *)0;
#line 8730
  l_tcp = (opj_tcp_t *)0;
#line 8731
  l_tccp = (opj_tccp_t *)0;
#line 8739
  l_cp = & p_j2k->m_cp;
#line 8740
  l_tcp = l_cp->tcps + p_tile_no;
#line 8741
  l_tccp = l_tcp->tccps + p_comp_no;
#line 8747
  if (l_tccp->qntsty == 1U) {
#line 8747
    tmp___5 = (unsigned int )1;
  } else {
#line 8747
    tmp___5 = l_tccp->numresolutions * 3U - 2U;
  }
#line 8747
  l_num_bands = tmp___5;
#line 8749
  if (l_tccp->qntsty == 0U) {
#line 8750
    l_header_size = 1U + l_num_bands;
#line 8752
    if (*p_header_size < l_header_size) {
      {
#line 8753
      opj_event_msg(p_manager, 1, "Error writing SQcd SQcc element\n\220");
      }
#line 8754
      return (0);
    }
    {
#line 8757
    opj_write_bytes_LE(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5), (OPJ_UINT32 )1);
#line 8758
    p_data ++;
#line 8760
    l_band_no = (OPJ_UINT32 )0;
    }
    {
#line 8760
    while (1) {
      while_continue: /* CIL Label */ ;
#line 8760
      if (! (l_band_no < l_num_bands)) {
#line 8760
        goto while_break;
      }
      {
#line 8761
      l_expn = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].expn;
#line 8762
      opj_write_bytes_LE(p_data, l_expn << 3, (OPJ_UINT32 )1);
#line 8763
      p_data ++;
      }
#line 8760
      l_band_no ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 8767
    l_header_size = 1U + 2U * l_num_bands;
#line 8769
    if (*p_header_size < l_header_size) {
      {
#line 8770
      opj_event_msg(p_manager, 1, "Error writing SQcd SQcc element\n\220");
      }
#line 8771
      return (0);
    }
    {
#line 8774
    opj_write_bytes_LE(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5), (OPJ_UINT32 )1);
#line 8775
    p_data ++;
#line 8777
    l_band_no = (OPJ_UINT32 )0;
    }
    {
#line 8777
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 8777
      if (! (l_band_no < l_num_bands)) {
#line 8777
        goto while_break___0;
      }
      {
#line 8778
      l_expn = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].expn;
#line 8779
      l_mant = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].mant;
#line 8781
      opj_write_bytes_LE(p_data, (l_expn << 11) + l_mant, (OPJ_UINT32 )2);
#line 8782
      p_data += 2;
      }
#line 8777
      l_band_no ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 8786
  *p_header_size -= l_header_size;
#line 8788
  return (1);
}
}
#line 8791 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_header_data ,
                                OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_band_no ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_BYTE *l_current_ptr ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_num_band ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  opj_tcp_t *tmp___2 ;
  int tmp___3 ;
  OPJ_UINT32 tmp___4 ;
  OPJ_UINT32 __cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;
  OPJ_INT32 tmp___5 ;
  OPJ_UINT32 __cil_tmp22 ;

  {
#line 8800
  l_cp = (opj_cp_t *)0;
#line 8801
  l_tcp = (opj_tcp_t *)0;
#line 8802
  l_tccp = (opj_tccp_t *)0;
#line 8803
  l_current_ptr = (OPJ_BYTE *)0;
#line 8811
  l_cp = & p_j2k->m_cp;
#line 8813
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 8813
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 8813
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 8813
  l_tcp = tmp___2;
#line 8820
  l_tccp = l_tcp->tccps + p_comp_no;
#line 8821
  l_current_ptr = p_header_data;
#line 8823
  if (*p_header_size < 1U) {
    {
#line 8824
    opj_event_msg(p_manager, 1, "Error reading SQcd or SQcc element\n");
    }
#line 8825
    return (0);
  }
  {
#line 8827
  *p_header_size -= (unsigned int )1;
#line 8829
  opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 8830
  l_current_ptr ++;
#line 8832
  l_tccp->qntsty = l_tmp & 31U;
#line 8833
  l_tccp->numgbits = l_tmp >> 5;
  }
#line 8834
  if (l_tccp->qntsty == 1U) {
#line 8835
    l_num_band = (OPJ_UINT32 )1;
  } else {
#line 8838
    if (l_tccp->qntsty == 0U) {
#line 8838
      tmp___4 = *p_header_size;
    } else {
#line 8838
      tmp___4 = *p_header_size / 2U;
    }
#line 8838
    l_num_band = tmp___4;
#line 8842
    if (l_num_band > 97U) {
      {
#line 8843
      opj_event_msg(p_manager, 2, "While reading CCP_QNTSTY element inside QCD or QCC marker segment, number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to OPJ_J2K_MAXBANDS (%d) and skip the rest. \n",
                    l_num_band, 97, 97);
      }
    }
  }
#line 8872
  if (l_tccp->qntsty == 0U) {
#line 8873
    l_band_no = (OPJ_UINT32 )0;
    {
#line 8873
    while (1) {
      while_continue: /* CIL Label */ ;
#line 8873
      if (! (l_band_no < l_num_band)) {
#line 8873
        goto while_break;
      }
      {
#line 8874
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 8875
      l_current_ptr ++;
      }
#line 8876
      if (l_band_no < 97U) {
#line 8877
        l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32 )(l_tmp >> 3);
#line 8878
        l_tccp->stepsizes[l_band_no].mant = 0;
      }
#line 8873
      l_band_no ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 8881
    *p_header_size -= l_num_band;
  } else {
#line 8884
    l_band_no = (OPJ_UINT32 )0;
    {
#line 8884
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 8884
      if (! (l_band_no < l_num_band)) {
#line 8884
        goto while_break___0;
      }
      {
#line 8885
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )2);
#line 8886
      l_current_ptr += 2;
      }
#line 8887
      if (l_band_no < 97U) {
#line 8888
        l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32 )(l_tmp >> 11);
#line 8889
        l_tccp->stepsizes[l_band_no].mant = (OPJ_INT32 )(l_tmp & 2047U);
      }
#line 8884
      l_band_no ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 8892
    *p_header_size -= 2U * l_num_band;
  }
#line 8896
  if (l_tccp->qntsty == 1U) {
#line 8897
    l_band_no = (OPJ_UINT32 )1;
    {
#line 8897
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 8897
      if (! (l_band_no < 97U)) {
#line 8897
        goto while_break___1;
      }
#line 8898
      if ((OPJ_INT32 )l_tccp->stepsizes[0].expn - (OPJ_INT32 )((l_band_no - 1U) / 3U) > 0) {
#line 8898
        tmp___5 = (OPJ_INT32 )l_tccp->stepsizes[0].expn - (OPJ_INT32 )((l_band_no - 1U) / 3U);
      } else {
#line 8898
        tmp___5 = 0;
      }
#line 8898
      l_tccp->stepsizes[l_band_no].expn = tmp___5;
#line 8901
      l_tccp->stepsizes[l_band_no].mant = l_tccp->stepsizes[0].mant;
#line 8897
      l_band_no ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 8905
  return (1);
}
}
#line 8908 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_ref_tccp ;
  opj_tccp_t *l_copied_tccp ;
  OPJ_UINT32 l_size ;
  int tmp ;
  opj_tcp_t *tmp___0 ;

  {
#line 8911
  l_cp = (opj_cp_t *)((void *)0);
#line 8912
  l_tcp = (opj_tcp_t *)((void *)0);
#line 8913
  l_ref_tccp = (opj_tccp_t *)((void *)0);
#line 8914
  l_copied_tccp = (opj_tccp_t *)((void *)0);
#line 8920
  l_cp = & p_j2k->m_cp;
#line 8921
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 8921
    tmp___0 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 8921
    tmp___0 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 8921
  l_tcp = tmp___0;
#line 8925
  l_ref_tccp = l_tcp->tccps + 0;
#line 8926
  l_copied_tccp = l_ref_tccp + 1;
#line 8927
  l_size = (OPJ_UINT32 )(97UL * sizeof(opj_stepsize_t ));
#line 8929
  i = (OPJ_UINT32 )1;
  {
#line 8929
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8929
    if (! (i < (p_j2k->m_private_image)->numcomps)) {
#line 8929
      goto while_break;
    }
    {
#line 8930
    l_copied_tccp->qntsty = l_ref_tccp->qntsty;
#line 8931
    l_copied_tccp->numgbits = l_ref_tccp->numgbits;
#line 8932
    memcpy((opj_stepsize_t *)l_copied_tccp->stepsizes, (opj_stepsize_t *)l_ref_tccp->stepsizes,
           (unsigned long )l_size);
#line 8933
    l_copied_tccp ++;
    }
#line 8929
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 8937 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static void opj_j2k_dump_tile_info(opj_tcp_t *l_default_tile , OPJ_INT32 numcomps ,
                                   FILE *out_stream ) 
{ 
  OPJ_INT32 compno ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 resno ;
  OPJ_INT32 bandno ;
  OPJ_INT32 numbands ;
  OPJ_UINT32 __cil_tmp9 ;
  int tmp ;
  OPJ_INT32 __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;

  {
#line 8939
  if (l_default_tile) {
    {
#line 8943
    fprintf(out_stream, "\t default tile {\n");
#line 8944
    fprintf(out_stream, "\t\t csty=%#x\n\347U", l_default_tile->csty);
#line 8945
    fprintf(out_stream, "\t\t prg=%#x\n", (int )l_default_tile->prg);
#line 8946
    fprintf(out_stream, "\t\t numlayers=%d\n\230\001", l_default_tile->numlayers);
#line 8947
    fprintf(out_stream, "\t\t mct=%x\n\212i\347U", l_default_tile->mct);
#line 8949
    compno = 0;
    }
    {
#line 8949
    while (1) {
      while_continue: /* CIL Label */ ;
#line 8949
      if (! (compno < numcomps)) {
#line 8949
        goto while_break;
      }
      {
#line 8950
      l_tccp = l_default_tile->tccps + compno;
#line 8955
      fprintf(out_stream, "\t\t comp %d {\n", compno);
#line 8956
      fprintf(out_stream, "\t\t\t csty=%#x\nU", l_tccp->csty);
#line 8957
      fprintf(out_stream, "\t\t\t numresolutions=%d\n", l_tccp->numresolutions);
#line 8958
      fprintf(out_stream, "\t\t\t cblkw=2^%d\n", l_tccp->cblkw);
#line 8959
      fprintf(out_stream, "\t\t\t cblkh=2^%d\n", l_tccp->cblkh);
#line 8960
      fprintf(out_stream, "\t\t\t cblksty=%#x\n\230\001", l_tccp->cblksty);
#line 8961
      fprintf(out_stream, "\t\t\t qmfbid=%d\n", l_tccp->qmfbid);
#line 8963
      fprintf(out_stream, "\t\t\t preccintsize (w,h)=");
#line 8964
      resno = (OPJ_UINT32 )0;
      }
      {
#line 8964
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 8964
        if (! (resno < l_tccp->numresolutions)) {
#line 8964
          goto while_break___0;
        }
        {
#line 8965
        fprintf(out_stream, "(%d,%d) \230\001", l_tccp->prcw[resno], l_tccp->prch[resno]);
        }
#line 8964
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 8967
      fprintf(out_stream, "\n");
#line 8970
      fprintf(out_stream, "\t\t\t qntsty=%d\n", l_tccp->qntsty);
#line 8971
      fprintf(out_stream, "\t\t\t numgbits=%d\n\230\001", l_tccp->numgbits);
#line 8972
      fprintf(out_stream, "\t\t\t stepsizes (m,e)=");
      }
#line 8973
      if (l_tccp->qntsty == 1U) {
#line 8973
        tmp = 1;
      } else {
#line 8973
        tmp = (OPJ_INT32 )l_tccp->numresolutions * 3 - 2;
      }
#line 8973
      numbands = tmp;
#line 8974
      bandno = 0;
      {
#line 8974
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 8974
        if (! (bandno < numbands)) {
#line 8974
          goto while_break___1;
        }
        {
#line 8975
        fprintf(out_stream, "(%d,%d) \230\001", l_tccp->stepsizes[bandno].mant, l_tccp->stepsizes[bandno].expn);
        }
#line 8974
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 8978
      fprintf(out_stream, "\no\212i\347U");
#line 8981
      fprintf(out_stream, "\t\t\t roishift=%d\n\230\001", l_tccp->roishift);
#line 8983
      fprintf(out_stream, "\t\t }\nU");
      }
#line 8949
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 8985
    fprintf(out_stream, "\t }\n\347U");
    }
  }
  return;
}
}
#line 8989 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void j2k_dump(opj_j2k_t *p_j2k , OPJ_INT32 flag , FILE *out_stream ) 
{ 
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 i ;
  opj_tcp_t *l_tcp ;

  {
#line 8992
  if (flag & 128) {
    {
    {
#line 8993
    fprintf(out_stream, "Wrong flag\n");
    }
    }
#line 8994
    return;
  } else
#line 8992
  if (flag & 256) {
    {
    {
#line 8993
    fprintf(out_stream, "Wrong flag\n");
    }
    }
#line 8994
    return;
  }
#line 8998
  if (flag & 1) {
#line 8999
    if (p_j2k->m_private_image) {
      {
#line 9000
      j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);
      }
    }
  }
#line 9004
  if (flag & 2) {
    {
#line 9005
    opj_j2k_dump_MH_info(p_j2k, out_stream);
    }
  }
#line 9008
  if (flag & 8) {
#line 9009
    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 9011
    l_tcp = p_j2k->m_cp.tcps;
#line 9012
    i = (OPJ_UINT32 )0;
    {
#line 9012
    while (1) {
      while_continue: /* CIL Label */ ;
#line 9012
      if (! (i < l_nb_tiles)) {
#line 9012
        goto while_break;
      }
      {
#line 9013
      opj_j2k_dump_tile_info(l_tcp, (OPJ_INT32 )(p_j2k->m_private_image)->numcomps,
                             out_stream);
#line 9014
      l_tcp ++;
      }
#line 9012
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 9019
  if (flag & 4) {

  }
#line 9024
  if (flag & 16) {
    {
#line 9025
    opj_j2k_dump_MH_index(p_j2k, out_stream);
    }
  }
#line 9029
  if (flag & 32) {

  }
  return;
}
}
#line 9035 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_dump_MH_index(opj_j2k_t *p_j2k , FILE *out_stream ) 
{ 
  opj_codestream_index_t *cstr_index ;
  OPJ_UINT32 it_marker ;
  OPJ_UINT32 it_tile ;
  OPJ_UINT32 it_tile_part ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 l_acc_nb_of_tile_part ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 nb_of_tile_part ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_UINT32 __cil_tmp13 ;

  {
  {
#line 9037
  cstr_index = p_j2k->cstr_index;
#line 9040
  fprintf(out_stream, "Codestream index from main header: {\nU");
#line 9042
  fprintf(out_stream, "\t Main header start position=%li\n\t Main header end position=%li\n",
          cstr_index->main_head_start, cstr_index->main_head_end);
#line 9046
  fprintf(out_stream, "\t Marker list: {\n");
  }
#line 9048
  if (cstr_index->marker) {
#line 9049
    it_marker = (OPJ_UINT32 )0;
    {
#line 9049
    while (1) {
      while_continue: /* CIL Label */ ;
#line 9049
      if (! (it_marker < cstr_index->marknum)) {
#line 9049
        goto while_break;
      }
      {
#line 9050
      fprintf(out_stream, "\t\t type=%#x, pos=%li, len=%d\n\224\212i\347U", (int )(cstr_index->marker + it_marker)->type,
              (cstr_index->marker + it_marker)->pos, (cstr_index->marker + it_marker)->len);
      }
#line 9049
      it_marker ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 9057
  fprintf(out_stream, "\t }\n");
  }
#line 9059
  if (cstr_index->tile_index) {
#line 9062
    l_acc_nb_of_tile_part = (OPJ_UINT32 )0;
#line 9063
    it_tile = (OPJ_UINT32 )0;
    {
#line 9063
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 9063
      if (! (it_tile < cstr_index->nb_of_tiles)) {
#line 9063
        goto while_break___0;
      }
#line 9064
      l_acc_nb_of_tile_part += (cstr_index->tile_index + it_tile)->nb_tps;
#line 9063
      it_tile ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 9067
    if (l_acc_nb_of_tile_part) {
      {
#line 9069
      fprintf(out_stream, "\t Tile index: {\n\220");
#line 9071
      it_tile = (OPJ_UINT32 )0;
      }
      {
#line 9071
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 9071
        if (! (it_tile < cstr_index->nb_of_tiles)) {
#line 9071
          goto while_break___1;
        }
        {
#line 9072
        nb_of_tile_part = (cstr_index->tile_index + it_tile)->nb_tps;
#line 9074
        fprintf(out_stream, "\t\t nb of tile-part in tile [%d]=%d\n", it_tile, nb_of_tile_part);
        }
#line 9076
        if ((cstr_index->tile_index + it_tile)->tp_index) {
#line 9077
          it_tile_part = (OPJ_UINT32 )0;
          {
#line 9077
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 9077
            if (! (it_tile_part < nb_of_tile_part)) {
#line 9077
              goto while_break___2;
            }
            {
#line 9078
            fprintf(out_stream, "\t\t\t tile-part[%d]: star_pos=%li, end_header=%li, end_pos=%li.\n",
                    it_tile_part, ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->start_pos,
                    ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->end_header,
                    ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->end_pos);
            }
#line 9077
            it_tile_part ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 9086
        if ((cstr_index->tile_index + it_tile)->marker) {
#line 9087
          it_marker = (OPJ_UINT32 )0;
          {
#line 9087
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 9087
            if (! (it_marker < (cstr_index->tile_index + it_tile)->marknum)) {
#line 9087
              goto while_break___3;
            }
            {
#line 9088
            fprintf(out_stream, "\t\t type=%#x, pos=%li, len=%d\n", (int )((cstr_index->tile_index + it_tile)->marker + it_marker)->type,
                    ((cstr_index->tile_index + it_tile)->marker + it_marker)->pos,
                    ((cstr_index->tile_index + it_tile)->marker + it_marker)->len);
            }
#line 9087
            it_marker ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 9071
        it_tile ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 9095
      fprintf(out_stream, "\t }\n");
      }
    }
  }
  {
#line 9099
  fprintf(out_stream, "}\n");
  }
  return;
}
}
#line 9104 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_dump_MH_info(opj_j2k_t *p_j2k , FILE *out_stream ) 
{ 


  {
  {
#line 9107
  fprintf(out_stream, "Codestream info from main header: {\n");
#line 9109
  fprintf(out_stream, "\t tx0=%d, ty0=%d\n", p_j2k->m_cp.tx0, p_j2k->m_cp.ty0);
#line 9110
  fprintf(out_stream, "\t tdx=%d, tdy=%d\n", p_j2k->m_cp.tdx, p_j2k->m_cp.tdy);
#line 9111
  fprintf(out_stream, "\t tw=%d, th=%d\n", p_j2k->m_cp.tw, p_j2k->m_cp.th);
#line 9112
  opj_j2k_dump_tile_info(p_j2k->m_specific_param.m_decoder.m_default_tcp, (OPJ_INT32 )(p_j2k->m_private_image)->numcomps,
                         out_stream);
#line 9113
  fprintf(out_stream, "}\n");
  }
  return;
}
}
#line 9116 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void j2k_dump_image_header(opj_image_t *img_header , OPJ_BOOL dev_dump_flag , FILE *out_stream ) 
{ 
  char tab[2] ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 __cil_tmp6 ;

  {
#line 9120
  if (dev_dump_flag) {
    {
#line 9121
    fprintf(stdout, "[DEV] Dump an image_header struct {\n");
#line 9122
    tab[0] = (char )'\000';
    }
  } else {
    {
#line 9125
    fprintf(out_stream, "Image info {\n");
#line 9126
    tab[0] = (char )'\t';
#line 9126
    tab[1] = (char )'\000';
    }
  }
  {
#line 9129
  fprintf(out_stream, "%s x0=%d, y0=%d\n\230\001", (char *)tab, img_header->x0, img_header->y0);
#line 9130
  fprintf(out_stream, "%s x1=%d, y1=%d\n\230\001", (char *)tab, img_header->x1, img_header->y1);
#line 9131
  fprintf(out_stream, "%s numcomps=%d\n", (char *)tab, img_header->numcomps);
  }
#line 9133
  if (img_header->comps) {
#line 9135
    compno = (OPJ_UINT32 )0;
    {
#line 9135
    while (1) {
      while_continue: /* CIL Label */ ;
#line 9135
      if (! (compno < img_header->numcomps)) {
#line 9135
        goto while_break;
      }
      {
#line 9136
      fprintf(out_stream, "%s\t component %d {\n", (char *)tab, compno);
#line 9137
      j2k_dump_image_comp_header(img_header->comps + compno, dev_dump_flag, out_stream);
#line 9138
      fprintf(out_stream, "%s}\n", (char *)tab);
      }
#line 9135
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 9142
  fprintf(out_stream, "}\n");
  }
  return;
}
}
#line 9145 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void j2k_dump_image_comp_header(opj_image_comp_t *comp_header , OPJ_BOOL dev_dump_flag ,
                                FILE *out_stream ) 
{ 
  char tab[3] ;

  {
#line 9149
  if (dev_dump_flag) {
    {
#line 9150
    fprintf(stdout, "[DEV] Dump an image_comp_header struct {\n");
#line 9151
    tab[0] = (char )'\000';
    }
  } else {
#line 9153
    tab[0] = (char )'\t';
#line 9153
    tab[1] = (char )'\t';
#line 9153
    tab[2] = (char )'\000';
  }
  {
#line 9156
  fprintf(out_stream, "%s dx=%d, dy=%d\n\230\001", (char *)tab, comp_header->dx, comp_header->dy);
#line 9157
  fprintf(out_stream, "%s prec=%d\n", (char *)tab, comp_header->prec);
#line 9158
  fprintf(out_stream, "%s sgnd=%d\n", (char *)tab, comp_header->sgnd);
  }
#line 9160
  if (dev_dump_flag) {
    {
#line 9161
    fprintf(out_stream, "}\n");
    }
  }
  return;
}
}
#line 9164 "/root/patron/new_21/src/lib/openjp2/j2k.c"
opj_codestream_info_v2_t *j2k_get_cstr_info(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 numcomps ;
  opj_tcp_t *l_default_tile ;
  opj_codestream_info_v2_t *cstr_info ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_tccp_t *l_tccp ;
  opj_tccp_info_t *l_tccp_info ;
  OPJ_INT32 bandno ;
  OPJ_INT32 numbands ;
  int tmp ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_UINT32 __cil_tmp14 ;

  {
  {
#line 9167
  numcomps = (p_j2k->m_private_image)->numcomps;
#line 9169
  __cil_tmp6 = calloc((unsigned long )1, sizeof(opj_codestream_info_v2_t ));
#line 9169
  cstr_info = (opj_codestream_info_v2_t *)__cil_tmp6;
  }
#line 9170
  if (! cstr_info) {
#line 9171
    return ((opj_codestream_info_v2_t *)((void *)0));
  }
  {
#line 9173
  cstr_info->nbcomps = (p_j2k->m_private_image)->numcomps;
#line 9175
  cstr_info->tx0 = p_j2k->m_cp.tx0;
#line 9176
  cstr_info->ty0 = p_j2k->m_cp.ty0;
#line 9177
  cstr_info->tdx = p_j2k->m_cp.tdx;
#line 9178
  cstr_info->tdy = p_j2k->m_cp.tdy;
#line 9179
  cstr_info->tw = p_j2k->m_cp.tw;
#line 9180
  cstr_info->th = p_j2k->m_cp.th;
#line 9182
  cstr_info->tile_info = (opj_tile_info_v2_t *)((void *)0);
#line 9184
  l_default_tile = p_j2k->m_specific_param.m_decoder.m_default_tcp;
#line 9186
  cstr_info->m_default_tile_info.csty = l_default_tile->csty;
#line 9187
  cstr_info->m_default_tile_info.prg = l_default_tile->prg;
#line 9188
  cstr_info->m_default_tile_info.numlayers = l_default_tile->numlayers;
#line 9189
  cstr_info->m_default_tile_info.mct = l_default_tile->mct;
#line 9191
  __cil_tmp7 = calloc((unsigned long )cstr_info->nbcomps, sizeof(opj_tccp_info_t ));
#line 9191
  cstr_info->m_default_tile_info.tccp_info = (opj_tccp_info_t *)__cil_tmp7;
  }
#line 9192
  if (! cstr_info->m_default_tile_info.tccp_info) {
    {
#line 9194
    opj_destroy_cstr_info(& cstr_info);
    }
#line 9195
    return ((opj_codestream_info_v2_t *)((void *)0));
  }
#line 9198
  compno = (OPJ_UINT32 )0;
  {
#line 9198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9198
    if (! (compno < numcomps)) {
#line 9198
      goto while_break;
    }
#line 9199
    l_tccp = l_default_tile->tccps + compno;
#line 9200
    l_tccp_info = cstr_info->m_default_tile_info.tccp_info + compno;
#line 9204
    l_tccp_info->csty = l_tccp->csty;
#line 9205
    l_tccp_info->numresolutions = l_tccp->numresolutions;
#line 9206
    l_tccp_info->cblkw = l_tccp->cblkw;
#line 9207
    l_tccp_info->cblkh = l_tccp->cblkh;
#line 9208
    l_tccp_info->cblksty = l_tccp->cblksty;
#line 9209
    l_tccp_info->qmfbid = l_tccp->qmfbid;
#line 9210
    if (l_tccp->numresolutions < 33U) {
      {
#line 9212
      memcpy((OPJ_UINT32 *)l_tccp_info->prch, (OPJ_UINT32 *)l_tccp->prch, (unsigned long )l_tccp->numresolutions);
#line 9213
      memcpy((OPJ_UINT32 *)l_tccp_info->prcw, (OPJ_UINT32 *)l_tccp->prcw, (unsigned long )l_tccp->numresolutions);
      }
    }
#line 9217
    l_tccp_info->qntsty = l_tccp->qntsty;
#line 9218
    l_tccp_info->numgbits = l_tccp->numgbits;
#line 9220
    if (l_tccp->qntsty == 1U) {
#line 9220
      tmp = 1;
    } else {
#line 9220
      tmp = (OPJ_INT32 )l_tccp->numresolutions * 3 - 2;
    }
#line 9220
    numbands = tmp;
#line 9221
    if (numbands < 97) {
#line 9222
      bandno = 0;
      {
#line 9222
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 9222
        if (! (bandno < numbands)) {
#line 9222
          goto while_break___0;
        }
#line 9223
        l_tccp_info->stepsizes_mant[bandno] = (OPJ_UINT32 )l_tccp->stepsizes[bandno].mant;
#line 9224
        l_tccp_info->stepsizes_expn[bandno] = (OPJ_UINT32 )l_tccp->stepsizes[bandno].expn;
#line 9222
        bandno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 9229
    l_tccp_info->roishift = l_tccp->roishift;
#line 9198
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 9232
  return (cstr_info);
}
}
#line 9235 "/root/patron/new_21/src/lib/openjp2/j2k.c"
opj_codestream_index_t *j2k_get_cstr_index(opj_j2k_t *p_j2k ) 
{ 
  opj_codestream_index_t *l_cstr_index ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  OPJ_UINT32 it_tile ;
  void *__cil_tmp7 ;
  OPJ_UINT32 it_tile_free ;
  OPJ_UINT32 __cil_tmp9 ;
  void *__cil_tmp10 ;
  OPJ_UINT32 it_tile_free___0 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_UINT32 __cil_tmp13 ;

  {
  {
#line 9237
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_codestream_index_t ));
#line 9237
  l_cstr_index = (opj_codestream_index_t *)__cil_tmp3;
  }
#line 9239
  if (! l_cstr_index) {
#line 9240
    return ((opj_codestream_index_t *)((void *)0));
  }
  {
#line 9242
  l_cstr_index->main_head_start = (p_j2k->cstr_index)->main_head_start;
#line 9243
  l_cstr_index->main_head_end = (p_j2k->cstr_index)->main_head_end;
#line 9244
  l_cstr_index->codestream_size = (p_j2k->cstr_index)->codestream_size;
#line 9246
  l_cstr_index->marknum = (p_j2k->cstr_index)->marknum;
#line 9247
  __cil_tmp4 = malloc((unsigned long )l_cstr_index->marknum * sizeof(opj_marker_info_t ));
#line 9247
  l_cstr_index->marker = (opj_marker_info_t *)__cil_tmp4;
  }
#line 9248
  if (! l_cstr_index->marker) {
    {
#line 9249
    free(l_cstr_index);
    }
#line 9250
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 9253
  if ((p_j2k->cstr_index)->marker) {
    {
#line 9254
    memcpy(l_cstr_index->marker, (p_j2k->cstr_index)->marker, (unsigned long )l_cstr_index->marknum * sizeof(opj_marker_info_t ));
    }
  } else {
    {
#line 9256
    free(l_cstr_index->marker);
#line 9257
    l_cstr_index->marker = (opj_marker_info_t *)((void *)0);
    }
  }
  {
#line 9260
  l_cstr_index->nb_of_tiles = (p_j2k->cstr_index)->nb_of_tiles;
#line 9261
  __cil_tmp5 = calloc((unsigned long )l_cstr_index->nb_of_tiles, sizeof(opj_tile_index_t ));
#line 9261
  l_cstr_index->tile_index = (opj_tile_index_t *)__cil_tmp5;
  }
#line 9262
  if (! l_cstr_index->tile_index) {
    {
#line 9263
    free(l_cstr_index->marker);
#line 9264
    free(l_cstr_index);
    }
#line 9265
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 9268
  if (! (p_j2k->cstr_index)->tile_index) {
    {
#line 9269
    free(l_cstr_index->tile_index);
#line 9270
    l_cstr_index->tile_index = (opj_tile_index_t *)((void *)0);
    }
  } else {
#line 9273
    it_tile = (OPJ_UINT32 )0;
#line 9274
    it_tile = (OPJ_UINT32 )0;
    {
#line 9274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 9274
      if (! (it_tile < l_cstr_index->nb_of_tiles)) {
#line 9274
        goto while_break;
      }
      {
#line 9277
      (l_cstr_index->tile_index + it_tile)->marknum = ((p_j2k->cstr_index)->tile_index + it_tile)->marknum;
#line 9279
      __cil_tmp7 = malloc((unsigned long )(l_cstr_index->tile_index + it_tile)->marknum * sizeof(opj_marker_info_t ));
#line 9279
      (l_cstr_index->tile_index + it_tile)->marker = (opj_marker_info_t *)__cil_tmp7;
      }
#line 9282
      if (! (l_cstr_index->tile_index + it_tile)->marker) {
#line 9285
        it_tile_free = (OPJ_UINT32 )0;
        {
#line 9285
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 9285
          if (! (it_tile_free < it_tile)) {
#line 9285
            goto while_break___0;
          }
          {
#line 9286
          free((l_cstr_index->tile_index + it_tile_free)->marker);
          }
#line 9285
          it_tile_free ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 9289
        free(l_cstr_index->tile_index);
#line 9290
        free(l_cstr_index->marker);
#line 9291
        free(l_cstr_index);
        }
#line 9292
        return ((opj_codestream_index_t *)((void *)0));
      }
#line 9295
      if (((p_j2k->cstr_index)->tile_index + it_tile)->marker) {
        {
#line 9296
        memcpy((l_cstr_index->tile_index + it_tile)->marker, ((p_j2k->cstr_index)->tile_index + it_tile)->marker,
               (unsigned long )(l_cstr_index->tile_index + it_tile)->marknum * sizeof(opj_marker_info_t ));
        }
      } else {
        {
#line 9300
        free((l_cstr_index->tile_index + it_tile)->marker);
#line 9301
        (l_cstr_index->tile_index + it_tile)->marker = (opj_marker_info_t *)((void *)0);
        }
      }
      {
#line 9305
      (l_cstr_index->tile_index + it_tile)->nb_tps = ((p_j2k->cstr_index)->tile_index + it_tile)->nb_tps;
#line 9307
      __cil_tmp10 = malloc((unsigned long )(l_cstr_index->tile_index + it_tile)->nb_tps * sizeof(opj_tp_index_t ));
#line 9307
      (l_cstr_index->tile_index + it_tile)->tp_index = (opj_tp_index_t *)__cil_tmp10;
      }
#line 9310
      if (! (l_cstr_index->tile_index + it_tile)->tp_index) {
#line 9313
        it_tile_free___0 = (OPJ_UINT32 )0;
        {
#line 9313
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 9313
          if (! (it_tile_free___0 < it_tile)) {
#line 9313
            goto while_break___1;
          }
          {
#line 9314
          free((l_cstr_index->tile_index + it_tile_free___0)->marker);
#line 9315
          free((l_cstr_index->tile_index + it_tile_free___0)->tp_index);
          }
#line 9313
          it_tile_free___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 9318
        free(l_cstr_index->tile_index);
#line 9319
        free(l_cstr_index->marker);
#line 9320
        free(l_cstr_index);
        }
#line 9321
        return ((opj_codestream_index_t *)((void *)0));
      }
#line 9324
      if (((p_j2k->cstr_index)->tile_index + it_tile)->tp_index) {
        {
#line 9325
        memcpy((l_cstr_index->tile_index + it_tile)->tp_index, ((p_j2k->cstr_index)->tile_index + it_tile)->tp_index,
               (unsigned long )(l_cstr_index->tile_index + it_tile)->nb_tps * sizeof(opj_tp_index_t ));
        }
      } else {
        {
#line 9330
        free((l_cstr_index->tile_index + it_tile)->tp_index);
#line 9331
        (l_cstr_index->tile_index + it_tile)->tp_index = (opj_tp_index_t *)((void *)0);
        }
      }
#line 9335
      (l_cstr_index->tile_index + it_tile)->nb_packet = (OPJ_UINT32 )0;
#line 9336
      (l_cstr_index->tile_index + it_tile)->packet_index = (opj_packet_info_t *)((void *)0);
#line 9274
      it_tile ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 9341
  return (l_cstr_index);
}
}
#line 9344 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 it_tile ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  OPJ_UINT32 __cil_tmp5 ;

  {
  {
#line 9346
  it_tile = (OPJ_UINT32 )0;
#line 9348
  (p_j2k->cstr_index)->nb_of_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 9349
  __cil_tmp3 = calloc((unsigned long )(p_j2k->cstr_index)->nb_of_tiles, sizeof(opj_tile_index_t ));
#line 9349
  (p_j2k->cstr_index)->tile_index = (opj_tile_index_t *)__cil_tmp3;
  }
#line 9350
  if (! (p_j2k->cstr_index)->tile_index) {
#line 9351
    return (0);
  }
#line 9353
  it_tile = (OPJ_UINT32 )0;
  {
#line 9353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9353
    if (! (it_tile < (p_j2k->cstr_index)->nb_of_tiles)) {
#line 9353
      goto while_break;
    }
    {
#line 9354
    ((p_j2k->cstr_index)->tile_index + it_tile)->maxmarknum = (OPJ_UINT32 )100;
#line 9355
    ((p_j2k->cstr_index)->tile_index + it_tile)->marknum = (OPJ_UINT32 )0;
#line 9356
    __cil_tmp4 = calloc((unsigned long )((p_j2k->cstr_index)->tile_index + it_tile)->maxmarknum,
                        sizeof(opj_marker_info_t ));
#line 9356
    ((p_j2k->cstr_index)->tile_index + it_tile)->marker = (opj_marker_info_t *)__cil_tmp4;
    }
#line 9358
    if (! ((p_j2k->cstr_index)->tile_index + it_tile)->marker) {
#line 9359
      return (0);
    }
#line 9353
    it_tile ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 9362
  return (1);
}
}
#line 9365 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_go_on ;
  OPJ_UINT32 l_current_tile_no ;
  OPJ_UINT32 l_data_size ;
  OPJ_UINT32 l_max_data_size ;
  OPJ_INT32 l_tile_x0 ;
  OPJ_INT32 l_tile_y0 ;
  OPJ_INT32 l_tile_x1 ;
  OPJ_INT32 l_tile_y1 ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 nr_tiles ;
  void *__cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_OFF_T __cil_tmp21 ;

  {
  {
#line 9369
  l_go_on = 1;
#line 9375
  nr_tiles = (OPJ_UINT32 )0;
#line 9377
  __cil_tmp15 = malloc((unsigned long )1000);
#line 9377
  l_current_data = (OPJ_BYTE *)__cil_tmp15;
  }
#line 9378
  if (! l_current_data) {
    {
#line 9379
    opj_event_msg(p_manager, 1, "Not enough memory to decode tiles\n");
    }
#line 9380
    return (0);
  }
#line 9382
  l_max_data_size = (OPJ_UINT32 )1000;
  {
#line 9384
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 9385
    __cil_tmp16 = opj_j2k_read_tile_header(p_j2k, & l_current_tile_no, & l_data_size,
                                           & l_tile_x0, & l_tile_y0, & l_tile_x1,
                                           & l_tile_y1, & l_nb_comps, & l_go_on, p_stream,
                                           p_manager);
    }
#line 9385
    if (! __cil_tmp16) {
      {
#line 9394
      free(l_current_data);
      }
#line 9395
      return (0);
    }
#line 9398
    if (! l_go_on) {
#line 9399
      goto while_break;
    }
#line 9402
    if (l_data_size > l_max_data_size) {
      {
#line 9403
      __cil_tmp18 = realloc(l_current_data, (unsigned long )l_data_size);
#line 9403
      l_new_current_data = (OPJ_BYTE *)__cil_tmp18;
      }
#line 9404
      if (! l_new_current_data) {
        {
#line 9405
        free(l_current_data);
#line 9406
        opj_event_msg(p_manager, 1, "Not enough memory to decode tile %d/%d\n", l_current_tile_no + 1U,
                      p_j2k->m_cp.th * p_j2k->m_cp.tw);
        }
#line 9407
        return (0);
      }
#line 9409
      l_current_data = l_new_current_data;
#line 9410
      l_max_data_size = l_data_size;
    }
    {
#line 9413
    __cil_tmp19 = opj_j2k_decode_tile(p_j2k, l_current_tile_no, l_current_data, l_data_size,
                                      p_stream, p_manager);
    }
#line 9413
    if (! __cil_tmp19) {
      {
#line 9414
      free(l_current_data);
#line 9415
      opj_event_msg(p_manager, 1, "Failed to decode tile %d/%d\n", l_current_tile_no + 1U,
                    p_j2k->m_cp.th * p_j2k->m_cp.tw);
      }
#line 9416
      return (0);
    }
    {
#line 9418
    opj_event_msg(p_manager, 4, "Tile %d/%d has been decoded.\nU", l_current_tile_no + 1U,
                  p_j2k->m_cp.th * p_j2k->m_cp.tw);
#line 9420
    __cil_tmp20 = opj_j2k_update_image_data(p_j2k->m_tcd, l_current_data, p_j2k->m_output_image);
    }
#line 9420
    if (! __cil_tmp20) {
      {
#line 9421
      free(l_current_data);
      }
#line 9422
      return (0);
    }
    {
#line 9424
    opj_event_msg(p_manager, 4, "Image data has been updated with tile %d.\n\ni\347U",
                  l_current_tile_no + 1U);
#line 9426
    __cil_tmp21 = opj_stream_get_number_byte_left(p_stream);
    }
#line 9426
    if (__cil_tmp21 == 0L) {
#line 9426
      if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 9428
        goto while_break;
      }
    }
#line 9429
    nr_tiles ++;
#line 9429
    if (nr_tiles == p_j2k->m_cp.th * p_j2k->m_cp.tw) {
#line 9430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 9433
  free(l_current_data);
  }
#line 9435
  return (1);
}
}
#line 9441 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static void opj_j2k_setup_decoding(opj_j2k_t *p_j2k ) 
{ 
  int tmp ;

  {
  {
#line 9446
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_decode_tiles));
  }
  return;
}
}
#line 9454 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_decode_one_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_go_on ;
  OPJ_UINT32 l_current_tile_no ;
  OPJ_UINT32 l_tile_no_to_dec ;
  OPJ_UINT32 l_data_size ;
  OPJ_UINT32 l_max_data_size ;
  OPJ_INT32 l_tile_x0 ;
  OPJ_INT32 l_tile_y0 ;
  OPJ_INT32 l_tile_x1 ;
  OPJ_INT32 l_tile_y1 ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_BYTE *l_current_data ;
  void *__cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;
  OPJ_BOOL __cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;

  {
  {
#line 9458
  l_go_on = 1;
#line 9466
  __cil_tmp15 = malloc((unsigned long )1000);
#line 9466
  l_current_data = (OPJ_BYTE *)__cil_tmp15;
  }
#line 9467
  if (! l_current_data) {
    {
#line 9468
    opj_event_msg(p_manager, 1, "Not enough memory to decode one tile\n");
    }
#line 9469
    return (0);
  }
#line 9471
  l_max_data_size = (OPJ_UINT32 )1000;
#line 9474
  if (! (p_j2k->cstr_index)->tile_index) {
    {
#line 9476
    __cil_tmp16 = opj_j2k_allocate_tile_element_cstr_index(p_j2k);
    }
#line 9476
    if (! __cil_tmp16) {
      {
#line 9477
      free(l_current_data);
      }
#line 9478
      return (0);
    }
  }
#line 9482
  l_tile_no_to_dec = (OPJ_UINT32 )p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec;
#line 9483
  if ((p_j2k->cstr_index)->tile_index) {
#line 9484
    if (((p_j2k->cstr_index)->tile_index)->tp_index) {
#line 9486
      if (! ((p_j2k->cstr_index)->tile_index + l_tile_no_to_dec)->nb_tps) {
        {
#line 9489
        __cil_tmp17 = opj_stream_read_seek(p_stream, p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos + 2L,
                                           p_manager);
        }
#line 9489
        if (! __cil_tmp17) {
          {
#line 9490
          opj_event_msg(p_manager, 1, "Problem with seek function\n");
#line 9491
          free(l_current_data);
          }
#line 9492
          return (0);
        }
      } else {
        {
#line 9496
        __cil_tmp18 = opj_stream_read_seek(p_stream, (((p_j2k->cstr_index)->tile_index + l_tile_no_to_dec)->tp_index + 0)->start_pos + 2L,
                                           p_manager);
        }
#line 9496
        if (! __cil_tmp18) {
          {
#line 9497
          opj_event_msg(p_manager, 1, "Problem with seek function\n");
#line 9498
          free(l_current_data);
          }
#line 9499
          return (0);
        }
      }
#line 9503
      if (p_j2k->m_specific_param.m_decoder.m_state == 256U) {
#line 9504
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
      }
    }
  }
  {
#line 9507
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 9508
    __cil_tmp19 = opj_j2k_read_tile_header(p_j2k, & l_current_tile_no, & l_data_size,
                                           & l_tile_x0, & l_tile_y0, & l_tile_x1,
                                           & l_tile_y1, & l_nb_comps, & l_go_on, p_stream,
                                           p_manager);
    }
#line 9508
    if (! __cil_tmp19) {
      {
#line 9517
      free(l_current_data);
      }
#line 9518
      return (0);
    }
#line 9521
    if (! l_go_on) {
#line 9522
      goto while_break;
    }
#line 9525
    if (l_data_size > l_max_data_size) {
      {
#line 9526
      __cil_tmp21 = realloc(l_current_data, (unsigned long )l_data_size);
#line 9526
      l_new_current_data = (OPJ_BYTE *)__cil_tmp21;
      }
#line 9527
      if (! l_new_current_data) {
        {
#line 9528
        free(l_current_data);
#line 9529
        l_current_data = (OPJ_BYTE *)((void *)0);
#line 9532
        opj_event_msg(p_manager, 1, "Not enough memory to decode tile %d/%d\n", l_current_tile_no,
                      p_j2k->m_cp.th * p_j2k->m_cp.tw - 1U);
        }
#line 9533
        return (0);
      }
#line 9535
      l_current_data = l_new_current_data;
#line 9536
      l_max_data_size = l_data_size;
    }
    {
#line 9539
    __cil_tmp22 = opj_j2k_decode_tile(p_j2k, l_current_tile_no, l_current_data, l_data_size,
                                      p_stream, p_manager);
    }
#line 9539
    if (! __cil_tmp22) {
      {
#line 9540
      free(l_current_data);
      }
#line 9541
      return (0);
    }
    {
#line 9543
    opj_event_msg(p_manager, 4, "Tile %d/%d has been decoded.\nU", l_current_tile_no,
                  p_j2k->m_cp.th * p_j2k->m_cp.tw - 1U);
#line 9545
    __cil_tmp23 = opj_j2k_update_image_data(p_j2k->m_tcd, l_current_data, p_j2k->m_output_image);
    }
#line 9545
    if (! __cil_tmp23) {
      {
#line 9546
      free(l_current_data);
      }
#line 9547
      return (0);
    }
    {
#line 9549
    opj_event_msg(p_manager, 4, "Image data has been updated with tile %d.\n\ni\347U",
                  l_current_tile_no);
    }
#line 9551
    if (l_current_tile_no == l_tile_no_to_dec) {
      {
#line 9554
      __cil_tmp24 = opj_stream_read_seek(p_stream, (p_j2k->cstr_index)->main_head_end + 2L,
                                         p_manager);
      }
#line 9554
      if (! __cil_tmp24) {
        {
#line 9555
        opj_event_msg(p_manager, 1, "Problem with seek function\ni\347U");
        }
#line 9556
        return (0);
      }
#line 9558
      goto while_break;
    } else {
      {
#line 9561
      opj_event_msg(p_manager, 2, "Tile read, decode and updated is not the desired (%d vs %d).\nU",
                    l_current_tile_no, l_tile_no_to_dec);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 9566
  free(l_current_data);
  }
#line 9568
  return (1);
}
}
#line 9574 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static void opj_j2k_setup_decoding_tile(opj_j2k_t *p_j2k ) 
{ 
  int tmp ;

  {
  {
#line 9579
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_decode_one_tile));
  }
  return;
}
}
#line 9584 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_t *__cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;

  {
#line 9591
  if (! p_image) {
#line 9592
    return (0);
  }
  {
#line 9594
  p_j2k->m_output_image = opj_image_create0();
  }
#line 9595
  if (! p_j2k->m_output_image) {
#line 9596
    return (0);
  }
  {
#line 9598
  opj_copy_image_header(p_image, p_j2k->m_output_image);
#line 9601
  opj_j2k_setup_decoding(p_j2k);
#line 9604
  __cil_tmp7 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 9604
  if (! __cil_tmp7) {
    {
#line 9605
    opj_image_destroy(p_j2k->m_private_image);
#line 9606
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 9607
    return (0);
  }
#line 9611
  compno = (OPJ_UINT32 )0;
  {
#line 9611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9611
    if (! (compno < p_image->numcomps)) {
#line 9611
      goto while_break;
    }
#line 9612
    (p_image->comps + compno)->resno_decoded = ((p_j2k->m_output_image)->comps + compno)->resno_decoded;
#line 9613
    (p_image->comps + compno)->data = ((p_j2k->m_output_image)->comps + compno)->data;
#line 9621
    ((p_j2k->m_output_image)->comps + compno)->data = (OPJ_INT32 *)((void *)0);
#line 9611
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 9624
  return (1);
}
}
#line 9627 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 l_tile_x ;
  OPJ_UINT32 l_tile_y ;
  opj_image_comp_t *l_img_comp ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  opj_image_comp_t *__cil_tmp20 ;
  opj_image_t *__cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;
  OPJ_UINT32 __cil_tmp23 ;

  {
#line 9637
  if (! p_image) {
    {
#line 9638
    opj_event_msg(p_manager, 1, "We need an image previously created.\nU");
    }
#line 9639
    return (0);
  }
#line 9642
  if (tile_index >= p_j2k->m_cp.tw * p_j2k->m_cp.th) {
    {
#line 9643
    opj_event_msg(p_manager, 1, "Tile index provided by the user is incorrect %d (max = %d) \n",
                  tile_index, p_j2k->m_cp.tw * p_j2k->m_cp.th - 1U);
    }
#line 9644
    return (0);
  }
#line 9648
  l_tile_x = tile_index % p_j2k->m_cp.tw;
#line 9649
  l_tile_y = tile_index / p_j2k->m_cp.tw;
#line 9651
  p_image->x0 = l_tile_x * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
#line 9652
  if (p_image->x0 < (p_j2k->m_private_image)->x0) {
#line 9653
    p_image->x0 = (p_j2k->m_private_image)->x0;
  }
#line 9654
  p_image->x1 = (l_tile_x + 1U) * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
#line 9655
  if (p_image->x1 > (p_j2k->m_private_image)->x1) {
#line 9656
    p_image->x1 = (p_j2k->m_private_image)->x1;
  }
#line 9658
  p_image->y0 = l_tile_y * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
#line 9659
  if (p_image->y0 < (p_j2k->m_private_image)->y0) {
#line 9660
    p_image->y0 = (p_j2k->m_private_image)->y0;
  }
#line 9661
  p_image->y1 = (l_tile_y + 1U) * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
#line 9662
  if (p_image->y1 > (p_j2k->m_private_image)->y1) {
#line 9663
    p_image->y1 = (p_j2k->m_private_image)->y1;
  }
#line 9665
  l_img_comp = p_image->comps;
#line 9666
  compno = (OPJ_UINT32 )0;
  {
#line 9666
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9666
    if (! (compno < p_image->numcomps)) {
#line 9666
      goto while_break;
    }
    {
#line 9670
    l_img_comp->factor = ((p_j2k->m_private_image)->comps + compno)->factor;
#line 9672
    __cil_tmp12 = opj_int_ceildiv((OPJ_INT32 )p_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 9672
    l_img_comp->x0 = (OPJ_UINT32 )__cil_tmp12;
#line 9673
    __cil_tmp13 = opj_int_ceildiv((OPJ_INT32 )p_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 9673
    l_img_comp->y0 = (OPJ_UINT32 )__cil_tmp13;
#line 9674
    l_comp_x1 = opj_int_ceildiv((OPJ_INT32 )p_image->x1, (OPJ_INT32 )l_img_comp->dx);
#line 9675
    l_comp_y1 = opj_int_ceildiv((OPJ_INT32 )p_image->y1, (OPJ_INT32 )l_img_comp->dy);
#line 9677
    __cil_tmp17 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->x0, (OPJ_INT32 )l_img_comp->factor);
    }
    {
#line 9677
    __cil_tmp16 = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32 )l_img_comp->factor);
#line 9677
    l_img_comp->w = (OPJ_UINT32 )(__cil_tmp16 - __cil_tmp17);
#line 9678
    __cil_tmp19 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->y0, (OPJ_INT32 )l_img_comp->factor);
    }
    {
#line 9678
    __cil_tmp18 = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32 )l_img_comp->factor);
#line 9678
    l_img_comp->h = (OPJ_UINT32 )(__cil_tmp18 - __cil_tmp19);
#line 9680
    l_img_comp ++;
    }
#line 9666
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 9684
  if (p_j2k->m_output_image) {
    {
#line 9685
    opj_image_destroy(p_j2k->m_output_image);
    }
  }
  {
#line 9688
  p_j2k->m_output_image = opj_image_create0();
  }
#line 9689
  if (! p_j2k->m_output_image) {
#line 9690
    return (0);
  }
  {
#line 9692
  opj_copy_image_header(p_image, p_j2k->m_output_image);
#line 9694
  p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = (OPJ_INT32 )tile_index;
#line 9697
  opj_j2k_setup_decoding_tile(p_j2k);
#line 9700
  __cil_tmp22 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 9700
  if (! __cil_tmp22) {
    {
#line 9701
    opj_image_destroy(p_j2k->m_private_image);
#line 9702
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 9703
    return (0);
  }
#line 9707
  compno = (OPJ_UINT32 )0;
  {
#line 9707
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 9707
    if (! (compno < p_image->numcomps)) {
#line 9707
      goto while_break___0;
    }
#line 9708
    (p_image->comps + compno)->resno_decoded = ((p_j2k->m_output_image)->comps + compno)->resno_decoded;
#line 9710
    if ((p_image->comps + compno)->data) {
      {
#line 9711
      free((p_image->comps + compno)->data);
      }
    }
#line 9713
    (p_image->comps + compno)->data = ((p_j2k->m_output_image)->comps + compno)->data;
#line 9715
    ((p_j2k->m_output_image)->comps + compno)->data = (OPJ_INT32 *)((void *)0);
#line 9707
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 9718
  return (1);
}
}
#line 9721 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 it_comp ;
  OPJ_UINT32 max_res ;
  OPJ_UINT32 __cil_tmp6 ;

  {
#line 9727
  p_j2k->m_cp.m_specific_param.m_dec.m_reduce = res_factor;
#line 9729
  if (p_j2k->m_private_image) {
#line 9730
    if ((p_j2k->m_private_image)->comps) {
#line 9731
      if (p_j2k->m_specific_param.m_decoder.m_default_tcp) {
#line 9732
        if ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps) {
#line 9733
          it_comp = (OPJ_UINT32 )0;
          {
#line 9733
          while (1) {
            while_continue: /* CIL Label */ ;
#line 9733
            if (! (it_comp < (p_j2k->m_private_image)->numcomps)) {
#line 9733
              goto while_break;
            }
#line 9734
            max_res = ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps + it_comp)->numresolutions;
#line 9735
            if (res_factor >= max_res) {
              {
#line 9736
              opj_event_msg(p_manager, 1, "Resolution factor is greater than the maximum resolution in the component.\n");
              }
#line 9737
              return (0);
            }
#line 9739
            ((p_j2k->m_private_image)->comps + it_comp)->factor = res_factor;
#line 9733
            it_comp ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 9741
          return (1);
        }
      }
    }
  }
#line 9747
  return (0);
}
}
#line 9750 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_encode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max_tile_size ;
  OPJ_UINT32 l_current_tile_size ;
  OPJ_BYTE *l_current_data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_UINT32 __cil_tmp14 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;

  {
  {
#line 9764
  __cil_tmp12 = malloc((unsigned long )1000);
#line 9764
  l_current_data = (OPJ_BYTE *)__cil_tmp12;
  }
#line 9765
  if (! l_current_data) {
    {
#line 9766
    opj_event_msg(p_manager, 1, "Not enough memory to encode all tiles\n");
    }
#line 9767
    return (0);
  }
#line 9769
  l_max_tile_size = (OPJ_UINT32 )1000;
#line 9771
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 9772
  i = (OPJ_UINT32 )0;
  {
#line 9772
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9772
    if (! (i < l_nb_tiles)) {
#line 9772
      goto while_break;
    }
    {
#line 9773
    __cil_tmp13 = opj_j2k_pre_write_tile(p_j2k, i, p_stream, p_manager);
    }
#line 9773
    if (! __cil_tmp13) {
      {
#line 9774
      free(l_current_data);
      }
#line 9775
      return (0);
    }
    {
#line 9778
    l_current_tile_size = opj_tcd_get_encoded_tile_size(p_j2k->m_tcd);
    }
#line 9779
    if (l_current_tile_size > l_max_tile_size) {
      {
#line 9780
      __cil_tmp16 = realloc(l_current_data, (unsigned long )l_current_tile_size);
#line 9780
      l_new_current_data = (OPJ_BYTE *)__cil_tmp16;
      }
#line 9781
      if (! l_new_current_data) {
        {
#line 9782
        free(l_current_data);
#line 9783
        opj_event_msg(p_manager, 1, "Not enough memory to encode all tiles\n");
        }
#line 9784
        return (0);
      }
#line 9786
      l_current_data = l_new_current_data;
#line 9787
      l_max_tile_size = l_current_tile_size;
    }
    {
#line 9790
    opj_j2k_get_tile_data(p_j2k->m_tcd, l_current_data);
#line 9792
    __cil_tmp17 = opj_j2k_post_write_tile(p_j2k, l_current_data, l_current_tile_size,
                                          p_stream, p_manager);
    }
#line 9792
    if (! __cil_tmp17) {
#line 9793
      return (0);
    }
#line 9772
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 9797
  free(l_current_data);
  }
#line 9798
  return (1);
}
}
#line 9801 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 9806
  opj_j2k_setup_end_compress(p_j2k);
#line 9808
  __cil_tmp4 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 9808
  if (! __cil_tmp4) {
#line 9810
    return (0);
  }
#line 9813
  return (1);
}
}
#line 9816 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_image_t *p_image , opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  opj_image_t *__cil_tmp8 ;
  OPJ_UINT32 it_comp ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 9826
  p_j2k->m_private_image = opj_image_create0();
  }
#line 9827
  if (! p_j2k->m_private_image) {
    {
#line 9828
    opj_event_msg(p_manager, 1, "Failed to allocate image header.\220");
    }
#line 9829
    return (0);
  }
  {
#line 9831
  opj_copy_image_header(p_image, p_j2k->m_private_image);
  }
#line 9834
  if (p_image->comps) {
#line 9836
    it_comp = (OPJ_UINT32 )0;
    {
#line 9836
    while (1) {
      while_continue: /* CIL Label */ ;
#line 9836
      if (! (it_comp < p_image->numcomps)) {
#line 9836
        goto while_break;
      }
#line 9837
      if ((p_image->comps + it_comp)->data) {
#line 9838
        ((p_j2k->m_private_image)->comps + it_comp)->data = (p_image->comps + it_comp)->data;
#line 9839
        (p_image->comps + it_comp)->data = (OPJ_INT32 *)((void *)0);
      }
#line 9836
      it_comp ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 9846
  opj_j2k_setup_encoding_validation(p_j2k);
#line 9849
  __cil_tmp11 = opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager);
  }
#line 9849
  if (! __cil_tmp11) {
#line 9850
    return (0);
  }
  {
#line 9854
  opj_j2k_setup_header_writing(p_j2k);
#line 9857
  __cil_tmp12 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 9857
  if (! __cil_tmp12) {
#line 9858
    return (0);
  }
#line 9861
  return (1);
}
}
#line 9864 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
#line 9870
  if (p_tile_index != p_j2k->m_current_tile_number) {
    {
#line 9871
    opj_event_msg(p_manager, 1, "The given tile index does not match.\347U");
    }
#line 9872
    return (0);
  }
  {
#line 9875
  opj_event_msg(p_manager, 4, "tile number %d / %d\n", p_j2k->m_current_tile_number + 1U,
                p_j2k->m_cp.tw * p_j2k->m_cp.th);
#line 9877
  p_j2k->m_specific_param.m_encoder.m_current_tile_part_number = (OPJ_UINT32 )0;
#line 9878
  (p_j2k->m_tcd)->cur_totnum_tp = (p_j2k->m_cp.tcps + p_tile_index)->m_nb_tile_parts;
#line 9879
  p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = (OPJ_UINT32 )0;
#line 9882
  __cil_tmp5 = opj_tcd_init_encode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number);
  }
#line 9882
  if (! __cil_tmp5) {
#line 9883
    return (0);
  }
#line 9886
  return (1);
}
}
#line 9889 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_get_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 l_stride ;
  OPJ_UINT32 l_offset_x ;
  OPJ_UINT32 l_offset_y ;
  OPJ_UINT32 l_image_width ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_INT32 *l_src_ptr ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  OPJ_INT32 __cil_tmp20 ;
  OPJ_CHAR *l_dest_ptr ;
  OPJ_INT16 *l_dest_ptr___0 ;
  OPJ_INT16 *__cil_tmp23 ;
  OPJ_INT32 *__cil_tmp24 ;
  OPJ_INT16 *__cil_tmp25 ;
  OPJ_INT32 *__cil_tmp26 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *__cil_tmp28 ;
  OPJ_INT32 *__cil_tmp29 ;

  {
#line 9891
  k = (OPJ_UINT32 )0;
#line 9893
  l_img_comp = (opj_image_comp_t *)0;
#line 9894
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 9895
  l_image = (opj_image_t *)0;
#line 9898
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 9899
  l_image = p_tcd->image;
#line 9900
  l_img_comp = l_image->comps;
#line 9902
  i = (OPJ_UINT32 )0;
  {
#line 9902
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9902
    if (! (i < (p_tcd->image)->numcomps)) {
#line 9902
      goto while_break;
    }
#line 9903
    l_size_comp = l_img_comp->prec >> 3;
#line 9904
    l_remaining = l_img_comp->prec & 7U;
#line 9905
    if (l_remaining) {
#line 9906
      l_size_comp ++;
    }
#line 9909
    if (l_size_comp == 3U) {
#line 9910
      l_size_comp = (OPJ_UINT32 )4;
    }
    {
#line 9913
    l_width = (OPJ_UINT32 )(l_tilec->x1 - l_tilec->x0);
#line 9914
    l_height = (OPJ_UINT32 )(l_tilec->y1 - l_tilec->y0);
#line 9915
    __cil_tmp18 = opj_int_ceildiv((OPJ_INT32 )l_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 9915
    l_offset_x = (OPJ_UINT32 )__cil_tmp18;
#line 9916
    __cil_tmp19 = opj_int_ceildiv((OPJ_INT32 )l_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 9916
    l_offset_y = (OPJ_UINT32 )__cil_tmp19;
#line 9917
    __cil_tmp20 = opj_int_ceildiv((OPJ_INT32 )l_image->x1 - (OPJ_INT32 )l_image->x0,
                                  (OPJ_INT32 )l_img_comp->dx);
#line 9917
    l_image_width = (OPJ_UINT32 )__cil_tmp20;
#line 9918
    l_stride = l_image_width - l_width;
#line 9919
    l_src_ptr = (l_img_comp->data + ((OPJ_UINT32 )l_tilec->x0 - l_offset_x)) + ((OPJ_UINT32 )l_tilec->y0 - l_offset_y) * l_image_width;
    }
    {
#line 9922
    if (l_size_comp == (OPJ_UINT32 )1) {
#line 9922
      goto case_1;
    }
#line 9949
    if (l_size_comp == (OPJ_UINT32 )2) {
#line 9949
      goto case_2;
    }
#line 9972
    if (l_size_comp == (OPJ_UINT32 )4) {
#line 9972
      goto case_4;
    }
#line 9921
    goto switch_break;
    case_1: /* CIL Label */ 
#line 9924
    l_dest_ptr = (OPJ_CHAR *)p_data;
#line 9925
    if (l_img_comp->sgnd) {
#line 9926
      j = (OPJ_UINT32 )0;
      {
#line 9926
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 9926
        if (! (j < l_height)) {
#line 9926
          goto while_break___0;
        }
#line 9927
        k = (OPJ_UINT32 )0;
        {
#line 9927
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 9927
          if (! (k < l_width)) {
#line 9927
            goto while_break___1;
          }
#line 9928
          *l_dest_ptr = (OPJ_CHAR )*l_src_ptr;
#line 9929
          l_dest_ptr ++;
#line 9930
          l_src_ptr ++;
#line 9927
          k ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 9932
        l_src_ptr += l_stride;
#line 9926
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 9936
      j = (OPJ_UINT32 )0;
      {
#line 9936
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 9936
        if (! (j < l_height)) {
#line 9936
          goto while_break___2;
        }
#line 9937
        k = (OPJ_UINT32 )0;
        {
#line 9937
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 9937
          if (! (k < l_width)) {
#line 9937
            goto while_break___3;
          }
#line 9938
          *l_dest_ptr = (OPJ_CHAR )(*l_src_ptr & 255);
#line 9939
          l_dest_ptr ++;
#line 9940
          l_src_ptr ++;
#line 9937
          k ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 9942
        l_src_ptr += l_stride;
#line 9936
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 9946
    p_data = (OPJ_BYTE *)l_dest_ptr;
#line 9948
    goto switch_break;
    case_2: /* CIL Label */ 
#line 9951
    l_dest_ptr___0 = (OPJ_INT16 *)p_data;
#line 9952
    if (l_img_comp->sgnd) {
#line 9953
      j = (OPJ_UINT32 )0;
      {
#line 9953
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 9953
        if (! (j < l_height)) {
#line 9953
          goto while_break___4;
        }
#line 9954
        k = (OPJ_UINT32 )0;
        {
#line 9954
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 9954
          if (! (k < l_width)) {
#line 9954
            goto while_break___5;
          }
#line 9955
          __cil_tmp24 = l_src_ptr;
#line 9955
          l_src_ptr ++;
#line 9955
          __cil_tmp23 = l_dest_ptr___0;
#line 9955
          l_dest_ptr___0 ++;
#line 9955
          *__cil_tmp23 = (OPJ_INT16 )*__cil_tmp24;
#line 9954
          k ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 9957
        l_src_ptr += l_stride;
#line 9953
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 9961
      j = (OPJ_UINT32 )0;
      {
#line 9961
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 9961
        if (! (j < l_height)) {
#line 9961
          goto while_break___6;
        }
#line 9962
        k = (OPJ_UINT32 )0;
        {
#line 9962
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 9962
          if (! (k < l_width)) {
#line 9962
            goto while_break___7;
          }
#line 9963
          __cil_tmp26 = l_src_ptr;
#line 9963
          l_src_ptr ++;
#line 9963
          __cil_tmp25 = l_dest_ptr___0;
#line 9963
          l_dest_ptr___0 ++;
#line 9963
          *__cil_tmp25 = (OPJ_INT16 )(*__cil_tmp26 & 65535);
#line 9962
          k ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 9965
        l_src_ptr += l_stride;
#line 9961
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 9969
    p_data = (OPJ_BYTE *)l_dest_ptr___0;
#line 9971
    goto switch_break;
    case_4: /* CIL Label */ 
#line 9974
    l_dest_ptr___1 = (OPJ_INT32 *)p_data;
#line 9975
    j = (OPJ_UINT32 )0;
    {
#line 9975
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 9975
      if (! (j < l_height)) {
#line 9975
        goto while_break___8;
      }
#line 9976
      k = (OPJ_UINT32 )0;
      {
#line 9976
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 9976
        if (! (k < l_width)) {
#line 9976
          goto while_break___9;
        }
#line 9977
        __cil_tmp29 = l_src_ptr;
#line 9977
        l_src_ptr ++;
#line 9977
        __cil_tmp28 = l_dest_ptr___1;
#line 9977
        l_dest_ptr___1 ++;
#line 9977
        *__cil_tmp28 = *__cil_tmp29;
#line 9976
        k ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 9979
      l_src_ptr += l_stride;
#line 9975
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 9982
    p_data = (OPJ_BYTE *)l_dest_ptr___1;
#line 9984
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 9987
    l_img_comp ++;
#line 9988
    l_tilec ++;
#line 9902
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 9992 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 p_data_size ,
                                 opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  opj_tcd_t *l_tcd ;
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tile_size ;
  OPJ_UINT32 l_available_data ;
  int tmp ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;

  {
  {
#line 9998
  l_tcd = (opj_tcd_t *)0;
#line 10000
  l_current_data = (OPJ_BYTE *)0;
#line 10001
  l_tile_size = (OPJ_UINT32 )0;
#line 10007
  l_tcd = p_j2k->m_tcd;
#line 10009
  l_tile_size = p_j2k->m_specific_param.m_encoder.m_encoded_tile_size;
#line 10010
  l_available_data = l_tile_size;
#line 10011
  l_current_data = p_j2k->m_specific_param.m_encoder.m_encoded_tile_data;
#line 10013
  __cil_tmp12 = opj_tcd_copy_tile_data(l_tcd, p_data, p_data_size);
  }
#line 10013
  if (! __cil_tmp12) {
    {
#line 10014
    opj_event_msg(p_manager, 1, "Size mismatch between tile data and sent data.");
    }
#line 10015
    return (0);
  }
  {
#line 10018
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 10019
  __cil_tmp13 = opj_j2k_write_first_tile_part(p_j2k, l_current_data, & l_nb_bytes_written,
                                              l_available_data, p_stream, p_manager);
  }
#line 10019
  if (! __cil_tmp13) {
#line 10020
    return (0);
  }
  {
#line 10022
  l_current_data += l_nb_bytes_written;
#line 10023
  l_available_data -= l_nb_bytes_written;
#line 10025
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 10026
  __cil_tmp14 = opj_j2k_write_all_tile_parts(p_j2k, l_current_data, & l_nb_bytes_written,
                                             l_available_data, p_stream, p_manager);
  }
#line 10026
  if (! __cil_tmp14) {
#line 10027
    return (0);
  }
  {
#line 10030
  l_available_data -= l_nb_bytes_written;
#line 10031
  l_nb_bytes_written = l_tile_size - l_available_data;
#line 10033
  __cil_tmp15 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_encoded_tile_data,
                                      (OPJ_SIZE_T )l_nb_bytes_written, p_manager);
  }
#line 10033
  if (__cil_tmp15 != (unsigned long )l_nb_bytes_written) {
#line 10036
    return (0);
  }
#line 10039
  (p_j2k->m_current_tile_number) ++;
#line 10041
  return (1);
}
}
#line 10044 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_setup_end_compress(opj_j2k_t *p_j2k ) 
{ 
  int tmp ;

  {
  {
#line 10050
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_eoc));
  }
#line 10052
  if ((int )p_j2k->m_cp.rsiz >= 3) {
#line 10052
    if ((int )p_j2k->m_cp.rsiz <= 6) {
      {
#line 10053
      opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_updated_tlm));
      }
    }
  }
  {
#line 10056
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_epc));
#line 10057
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_end_encoding));
#line 10058
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_destroy_header_memory));
  }
  return;
}
}
#line 10061 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k ) 
{ 
  int tmp ;

  {
  {
#line 10066
  opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure )(& opj_j2k_build_encoder));
#line 10067
  opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure )(& opj_j2k_encoding_validation));
#line 10070
  opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure )(& opj_j2k_mct_validation));
  }
  return;
}
}
#line 10073 "/root/patron/new_21/src/lib/openjp2/j2k.c"
void opj_j2k_setup_header_writing(opj_j2k_t *p_j2k ) 
{ 
  int tmp ;

  {
  {
#line 10078
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_init_info));
#line 10079
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_soc));
#line 10080
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_siz));
#line 10081
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_cod));
#line 10082
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_qcd));
  }
#line 10084
  if ((int )p_j2k->m_cp.rsiz >= 3) {
#line 10084
    if ((int )p_j2k->m_cp.rsiz <= 6) {
      {
#line 10089
      opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_tlm));
      }
#line 10091
      if ((int )p_j2k->m_cp.rsiz == 4) {
        {
#line 10092
        opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_poc));
        }
      }
    }
  }
  {
#line 10096
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_regions));
  }
#line 10098
  if (p_j2k->m_cp.comment != (OPJ_CHAR *)0) {
    {
#line 10099
    opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_com));
    }
  }
#line 10103
  if ((int )p_j2k->m_cp.rsiz & 256) {
    {
#line 10104
    opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_mct_data_group));
    }
  }
#line 10108
  if (p_j2k->cstr_index) {
    {
#line 10109
    opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_get_end_header));
    }
  }
  {
#line 10112
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_create_tcd));
#line 10113
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_update_rates));
  }
  return;
}
}
#line 10116 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                       OPJ_UINT32 p_total_data_size , opj_stream_private_t *p_stream ,
                                       struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_UINT32 l_current_nb_bytes_written ;
  OPJ_BYTE *l_begin_data ;
  opj_tcd_t *l_tcd ;
  opj_cp_t *l_cp ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 10123
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 10125
  l_begin_data = (OPJ_BYTE *)0;
#line 10127
  l_tcd = (opj_tcd_t *)0;
#line 10128
  l_cp = (opj_cp_t *)0;
#line 10130
  l_tcd = p_j2k->m_tcd;
#line 10131
  l_cp = & p_j2k->m_cp;
#line 10133
  l_tcd->cur_pino = (OPJ_UINT32 )0;
#line 10136
  p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = (OPJ_UINT32 )0;
#line 10141
  l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 10142
  l_begin_data = p_data;
#line 10143
  __cil_tmp12 = opj_j2k_write_sot(p_j2k, p_data, & l_current_nb_bytes_written, p_stream,
                                  p_manager);
  }
#line 10143
  if (! __cil_tmp12) {
#line 10145
    return (0);
  }
#line 10148
  l_nb_bytes_written += l_current_nb_bytes_written;
#line 10149
  p_data += l_current_nb_bytes_written;
#line 10150
  p_total_data_size -= l_current_nb_bytes_written;
#line 10152
  if (! ((int )l_cp->rsiz >= 3 && (int )l_cp->rsiz <= 6)) {
#line 10169
    if ((l_cp->tcps + p_j2k->m_current_tile_number)->numpocs) {
      {
#line 10170
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 10171
      opj_j2k_write_poc_in_memory(p_j2k, p_data, & l_current_nb_bytes_written, p_manager);
#line 10172
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 10173
      p_data += l_current_nb_bytes_written;
#line 10174
      p_total_data_size -= l_current_nb_bytes_written;
      }
    }
  }
  {
#line 10178
  l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 10179
  __cil_tmp13 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                  p_total_data_size, p_stream, p_manager);
  }
#line 10179
  if (! __cil_tmp13) {
#line 10180
    return (0);
  }
  {
#line 10183
  l_nb_bytes_written += l_current_nb_bytes_written;
#line 10184
  *p_data_written = l_nb_bytes_written;
#line 10187
  opj_write_bytes_LE(l_begin_data + 6, l_nb_bytes_written, (OPJ_UINT32 )4);
  }
#line 10189
  if ((int )l_cp->rsiz >= 3) {
#line 10189
    if ((int )l_cp->rsiz <= 6) {
      {
#line 10190
      opj_j2k_update_tlm(p_j2k, l_nb_bytes_written);
      }
    }
  }
#line 10193
  return (1);
}
}
#line 10196 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                      OPJ_UINT32 p_total_data_size , opj_stream_private_t *p_stream ,
                                      struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 tilepartno ;
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_UINT32 l_current_nb_bytes_written ;
  OPJ_UINT32 l_part_tile_size ;
  OPJ_UINT32 tot_num_tp ;
  OPJ_UINT32 pino ;
  OPJ_BYTE *l_begin_data ;
  opj_tcp_t *l_tcp ;
  opj_tcd_t *l_tcd ;
  opj_cp_t *l_cp ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;

  {
  {
#line 10204
  tilepartno = (OPJ_UINT32 )0;
#line 10205
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 10212
  l_tcp = (opj_tcp_t *)0;
#line 10213
  l_tcd = (opj_tcd_t *)0;
#line 10214
  l_cp = (opj_cp_t *)0;
#line 10216
  l_tcd = p_j2k->m_tcd;
#line 10217
  l_cp = & p_j2k->m_cp;
#line 10218
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 10221
  tot_num_tp = opj_j2k_get_num_tp(l_cp, (OPJ_UINT32 )0, p_j2k->m_current_tile_number);
#line 10224
  (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 10225
  tilepartno = (OPJ_UINT32 )1;
  }
  {
#line 10225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10225
    if (! (tilepartno < tot_num_tp)) {
#line 10225
      goto while_break;
    }
    {
#line 10226
    p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
#line 10227
    l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 10228
    l_part_tile_size = (OPJ_UINT32 )0;
#line 10229
    l_begin_data = p_data;
#line 10231
    __cil_tmp18 = opj_j2k_write_sot(p_j2k, p_data, & l_current_nb_bytes_written, p_stream,
                                    p_manager);
    }
#line 10231
    if (! __cil_tmp18) {
#line 10232
      return (0);
    }
    {
#line 10235
    l_nb_bytes_written += l_current_nb_bytes_written;
#line 10236
    p_data += l_current_nb_bytes_written;
#line 10237
    p_total_data_size -= l_current_nb_bytes_written;
#line 10238
    l_part_tile_size += l_current_nb_bytes_written;
#line 10240
    l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 10241
    __cil_tmp19 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                    p_total_data_size, p_stream, p_manager);
    }
#line 10241
    if (! __cil_tmp19) {
#line 10242
      return (0);
    }
    {
#line 10245
    p_data += l_current_nb_bytes_written;
#line 10246
    l_nb_bytes_written += l_current_nb_bytes_written;
#line 10247
    p_total_data_size -= l_current_nb_bytes_written;
#line 10248
    l_part_tile_size += l_current_nb_bytes_written;
#line 10251
    opj_write_bytes_LE(l_begin_data + 6, l_part_tile_size, (OPJ_UINT32 )4);
    }
#line 10253
    if ((int )l_cp->rsiz >= 3) {
#line 10253
      if ((int )l_cp->rsiz <= 6) {
        {
#line 10254
        opj_j2k_update_tlm(p_j2k, l_part_tile_size);
        }
      }
    }
#line 10257
    (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 10225
    tilepartno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10260
  pino = (OPJ_UINT32 )1;
  {
#line 10260
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 10260
    if (! (pino <= l_tcp->numpocs)) {
#line 10260
      goto while_break___0;
    }
    {
#line 10261
    l_tcd->cur_pino = pino;
#line 10264
    tot_num_tp = opj_j2k_get_num_tp(l_cp, pino, p_j2k->m_current_tile_number);
#line 10265
    tilepartno = (OPJ_UINT32 )0;
    }
    {
#line 10265
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 10265
      if (! (tilepartno < tot_num_tp)) {
#line 10265
        goto while_break___1;
      }
      {
#line 10266
      p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
#line 10267
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 10268
      l_part_tile_size = (OPJ_UINT32 )0;
#line 10269
      l_begin_data = p_data;
#line 10271
      __cil_tmp21 = opj_j2k_write_sot(p_j2k, p_data, & l_current_nb_bytes_written,
                                      p_stream, p_manager);
      }
#line 10271
      if (! __cil_tmp21) {
#line 10272
        return (0);
      }
      {
#line 10275
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 10276
      p_data += l_current_nb_bytes_written;
#line 10277
      p_total_data_size -= l_current_nb_bytes_written;
#line 10278
      l_part_tile_size += l_current_nb_bytes_written;
#line 10280
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 10282
      __cil_tmp22 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                      p_total_data_size, p_stream, p_manager);
      }
#line 10282
      if (! __cil_tmp22) {
#line 10283
        return (0);
      }
      {
#line 10286
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 10287
      p_data += l_current_nb_bytes_written;
#line 10288
      p_total_data_size -= l_current_nb_bytes_written;
#line 10289
      l_part_tile_size += l_current_nb_bytes_written;
#line 10292
      opj_write_bytes_LE(l_begin_data + 6, l_part_tile_size, (OPJ_UINT32 )4);
      }
#line 10294
      if ((int )l_cp->rsiz >= 3) {
#line 10294
        if ((int )l_cp->rsiz <= 6) {
          {
#line 10295
          opj_j2k_update_tlm(p_j2k, l_part_tile_size);
          }
        }
      }
#line 10298
      (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 10265
      tilepartno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 10260
    pino ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 10302
  *p_data_written = l_nb_bytes_written;
#line 10304
  return (1);
}
}
#line 10307 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                   struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_tlm_size ;
  OPJ_OFF_T l_tlm_position ;
  OPJ_OFF_T l_current_position ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_OFF_T __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_SIZE_T __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 10319
  l_tlm_size = 5U * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;
#line 10320
  l_tlm_position = 6L + p_j2k->m_specific_param.m_encoder.m_tlm_start;
#line 10321
  l_current_position = opj_stream_tell(p_stream);
#line 10323
  __cil_tmp11 = opj_stream_seek(p_stream, l_tlm_position, p_manager);
  }
#line 10323
  if (! __cil_tmp11) {
#line 10324
    return (0);
  }
  {
#line 10327
  __cil_tmp12 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer,
                                      (OPJ_SIZE_T )l_tlm_size, p_manager);
  }
#line 10327
  if (__cil_tmp12 != (unsigned long )l_tlm_size) {
#line 10328
    return (0);
  }
  {
#line 10331
  __cil_tmp13 = opj_stream_seek(p_stream, l_current_position, p_manager);
  }
#line 10331
  if (! __cil_tmp13) {
#line 10332
    return (0);
  }
#line 10335
  return (1);
}
}
#line 10338 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                              struct opj_event_mgr *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 10347
  opj_tcd_destroy(p_j2k->m_tcd);
#line 10348
  p_j2k->m_tcd = (struct opj_tcd *)0;
  }
#line 10350
  if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
    {
#line 10351
    free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
#line 10352
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)0;
#line 10353
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = (OPJ_BYTE *)0;
    }
  }
#line 10356
  if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
    {
#line 10357
    free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
#line 10358
    p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)0;
    }
  }
#line 10361
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = (OPJ_UINT32 )0;
#line 10363
  return (1);
}
}
#line 10369 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 10379
  if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
    {
#line 10380
    free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 10381
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)0;
    }
  }
#line 10384
  p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 10386
  return (1);
}
}
#line 10389 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) 
{ 
  opj_codestream_info_t *l_cstr_info ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 10393
  l_cstr_info = (opj_codestream_info_t *)0;
#line 10440
  __cil_tmp8 = opj_j2k_calculate_tp(p_j2k, & p_j2k->m_cp, & p_j2k->m_specific_param.m_encoder.m_total_tile_parts,
                                    p_j2k->m_private_image, p_manager);
  }
#line 10440
  return (__cil_tmp8);
}
}
#line 10450 "/root/patron/new_21/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  opj_tcd_t *__cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 10460
  p_j2k->m_tcd = opj_tcd_create(0);
  }
#line 10462
  if (! p_j2k->m_tcd) {
    {
#line 10463
    opj_event_msg(p_manager, 1, "Not enough memory to create Tile Coder\n");
    }
#line 10464
    return (0);
  }
  {
#line 10467
  __cil_tmp8 = opj_tcd_init(p_j2k->m_tcd, p_j2k->m_private_image, & p_j2k->m_cp);
  }
#line 10467
  if (! __cil_tmp8) {
    {
#line 10468
    opj_tcd_destroy(p_j2k->m_tcd);
#line 10469
    p_j2k->m_tcd = (struct opj_tcd *)0;
    }
#line 10470
    return (0);
  }
#line 10473
  return (1);
}
}
#line 10476 "/root/patron/new_21/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 10483
  __cil_tmp7 = opj_j2k_pre_write_tile(p_j2k, p_tile_index, p_stream, p_manager);
  }
#line 10483
  if (! __cil_tmp7) {
    {
#line 10484
    opj_event_msg(p_manager, 1, "Error while opj_j2k_pre_write_tile with tile index = %d\n\230\001",
                  p_tile_index);
    }
#line 10485
    return (0);
  } else {
    {
#line 10488
    __cil_tmp8 = opj_j2k_post_write_tile(p_j2k, p_data, p_data_size, p_stream, p_manager);
    }
#line 10488
    if (! __cil_tmp8) {
      {
#line 10489
      opj_event_msg(p_manager, 1, "Error while opj_j2k_post_write_tile with tile index = %d\n",
                    p_tile_index);
      }
#line 10490
      return (0);
    }
  }
#line 10494
  return (1);
}
}
#line 37 "/root/patron/new_21/src/lib/openjp2/invert.c"
OPJ_BOOL opj_lupDecompose(OPJ_FLOAT32 *matrix , OPJ_UINT32 *permutations , OPJ_FLOAT32 *p_swap_area ,
                          OPJ_UINT32 nb_compo ) ;
#line 44
void opj_lupSolve(OPJ_FLOAT32 *pResult , OPJ_FLOAT32 *pMatrix , OPJ_FLOAT32 *pVector ,
                  OPJ_UINT32 *pPermutations , OPJ_UINT32 nb_compo , OPJ_FLOAT32 *p_intermediate_data ) ;
#line 54
void opj_lupInvert(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix , OPJ_UINT32 nb_compo ,
                   OPJ_UINT32 *pPermutations , OPJ_FLOAT32 *p_src_temp , OPJ_FLOAT32 *p_dest_temp ,
                   OPJ_FLOAT32 *p_swap_area ) ;
#line 70 "/root/patron/new_21/src/lib/openjp2/invert.c"
OPJ_BOOL opj_matrix_inversion_f(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix ,
                                OPJ_UINT32 nb_compo ) 
{ 
  OPJ_BYTE *l_data ;
  OPJ_UINT32 l_permutation_size ;
  OPJ_UINT32 l_swap_size ;
  OPJ_UINT32 l_total_size ;
  OPJ_UINT32 *lPermutations ;
  OPJ_FLOAT32 *l_double_data ;
  void *__cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 74
  l_data = (OPJ_BYTE *)0;
#line 75
  l_permutation_size = nb_compo * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 76
  l_swap_size = nb_compo * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 77
  l_total_size = l_permutation_size + 3U * l_swap_size;
#line 78
  lPermutations = (OPJ_UINT32 *)0;
#line 79
  l_double_data = (OPJ_FLOAT32 *)0;
#line 81
  __cil_tmp10 = malloc((unsigned long )l_total_size);
#line 81
  l_data = (OPJ_BYTE *)__cil_tmp10;
  }
#line 82
  if (l_data == (OPJ_BYTE *)0) {
#line 83
    return (0);
  }
  {
#line 85
  lPermutations = (OPJ_UINT32 *)l_data;
#line 86
  l_double_data = (OPJ_FLOAT32 *)(l_data + l_permutation_size);
#line 87
  memset(lPermutations, 0, (unsigned long )l_permutation_size);
#line 89
  __cil_tmp11 = opj_lupDecompose(pSrcMatrix, lPermutations, l_double_data, nb_compo);
  }
#line 89
  if (! __cil_tmp11) {
    {
#line 90
    free(l_data);
    }
#line 91
    return (0);
  }
  {
#line 94
  opj_lupInvert(pSrcMatrix, pDestMatrix, nb_compo, lPermutations, l_double_data, l_double_data + nb_compo,
                l_double_data + 2U * nb_compo);
#line 95
  free(l_data);
  }
#line 97
  return (1);
}
}
#line 106 "/root/patron/new_21/src/lib/openjp2/invert.c"
OPJ_BOOL opj_lupDecompose(OPJ_FLOAT32 *matrix , OPJ_UINT32 *permutations , OPJ_FLOAT32 *p_swap_area ,
                          OPJ_UINT32 nb_compo ) 
{ 
  OPJ_UINT32 *tmpPermutations ;
  OPJ_UINT32 *dstPermutations ;
  OPJ_UINT32 k2 ;
  OPJ_UINT32 t ;
  OPJ_FLOAT32 temp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_FLOAT32 p ;
  OPJ_UINT32 lLastColum ;
  OPJ_UINT32 lSwapSize ;
  OPJ_FLOAT32 *lTmpMatrix ;
  OPJ_FLOAT32 *lColumnMatrix ;
  OPJ_FLOAT32 *lDestMatrix ;
  OPJ_UINT32 offset ;
  OPJ_UINT32 lStride ;
  OPJ_UINT32 *__cil_tmp21 ;
  OPJ_FLOAT32 tmp ;
  OPJ_FLOAT32 *__cil_tmp23 ;
  OPJ_FLOAT32 *__cil_tmp24 ;
  OPJ_FLOAT32 *__cil_tmp25 ;
  OPJ_FLOAT32 *__cil_tmp26 ;

  {
#line 110
  tmpPermutations = permutations;
#line 112
  k2 = (OPJ_UINT32 )0;
#line 116
  lLastColum = nb_compo - 1U;
#line 117
  lSwapSize = nb_compo * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 118
  lTmpMatrix = matrix;
#line 120
  offset = (OPJ_UINT32 )1;
#line 121
  lStride = nb_compo - 1U;
#line 124
  i = (OPJ_UINT32 )0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < nb_compo)) {
#line 124
      goto while_break;
    }
#line 126
    __cil_tmp21 = tmpPermutations;
#line 126
    tmpPermutations ++;
#line 126
    *__cil_tmp21 = i;
#line 124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  tmpPermutations = permutations;
#line 130
  k = (OPJ_UINT32 )0;
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 130
    if (! (k < lLastColum)) {
#line 130
      goto while_break___0;
    }
#line 131
    p = (OPJ_FLOAT32 )0.;
#line 134
    lColumnMatrix = lTmpMatrix + k;
#line 137
    i = k;
    {
#line 137
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 137
      if (! (i < nb_compo)) {
#line 137
        goto while_break___1;
      }
#line 138
      if (*lColumnMatrix > (float )0) {
#line 138
        tmp = *lColumnMatrix;
      } else {
#line 138
        tmp = - *lColumnMatrix;
      }
#line 138
      temp = tmp;
#line 139
      if (temp > p) {
#line 140
        p = temp;
#line 141
        k2 = i;
      }
#line 144
      lColumnMatrix += nb_compo;
#line 137
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 148
    if ((double )p == 0.) {
#line 149
      return (0);
    }
#line 153
    if (k2 != k) {
      {
#line 156
      dstPermutations = (tmpPermutations + k2) - k;
#line 158
      t = *tmpPermutations;
#line 159
      *tmpPermutations = *dstPermutations;
#line 160
      *dstPermutations = t;
#line 163
      lColumnMatrix = lTmpMatrix + (k2 - k) * nb_compo;
#line 164
      memcpy(p_swap_area, lColumnMatrix, (unsigned long )lSwapSize);
#line 165
      memcpy(lColumnMatrix, lTmpMatrix, (unsigned long )lSwapSize);
#line 166
      memcpy(lTmpMatrix, p_swap_area, (unsigned long )lSwapSize);
      }
    }
#line 170
    lDestMatrix = lTmpMatrix + k;
#line 171
    lColumnMatrix = lDestMatrix + nb_compo;
#line 173
    __cil_tmp23 = lDestMatrix;
#line 173
    lDestMatrix ++;
#line 173
    temp = *__cil_tmp23;
#line 176
    i = offset;
    {
#line 176
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 176
      if (! (i < nb_compo)) {
#line 176
        goto while_break___2;
      }
#line 182
      p = *lColumnMatrix / temp;
#line 183
      __cil_tmp24 = lColumnMatrix;
#line 183
      lColumnMatrix ++;
#line 183
      *__cil_tmp24 = p;
#line 185
      j = offset;
      {
#line 185
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 185
        if (! (j < nb_compo)) {
#line 185
          goto while_break___3;
        }
#line 187
        __cil_tmp26 = lDestMatrix;
#line 187
        lDestMatrix ++;
#line 187
        __cil_tmp25 = lColumnMatrix;
#line 187
        lColumnMatrix ++;
#line 187
        *__cil_tmp25 -= p * *__cil_tmp26;
#line 185
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 190
      lDestMatrix -= lStride;
#line 192
      lColumnMatrix += k;
#line 176
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 196
    offset ++;
#line 198
    lStride --;
#line 200
    lTmpMatrix += nb_compo;
#line 202
    tmpPermutations ++;
#line 130
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 204
  return (1);
}
}
#line 207 "/root/patron/new_21/src/lib/openjp2/invert.c"
void opj_lupSolve(OPJ_FLOAT32 *pResult , OPJ_FLOAT32 *pMatrix , OPJ_FLOAT32 *pVector ,
                  OPJ_UINT32 *pPermutations , OPJ_UINT32 nb_compo , OPJ_FLOAT32 *p_intermediate_data ) 
{ 
  OPJ_INT32 k ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_FLOAT32 sum ;
  OPJ_FLOAT32 u ;
  OPJ_UINT32 lStride ;
  OPJ_FLOAT32 *lCurrentPtr ;
  OPJ_FLOAT32 *lIntermediatePtr ;
  OPJ_FLOAT32 *lDestPtr ;
  OPJ_FLOAT32 *lTmpMatrix ;
  OPJ_FLOAT32 *lLineMatrix ;
  OPJ_FLOAT32 *lBeginPtr ;
  OPJ_FLOAT32 *lGeneratedData ;
  OPJ_UINT32 *lCurrentPermutationPtr ;
  OPJ_FLOAT32 *__cil_tmp21 ;
  OPJ_FLOAT32 *__cil_tmp22 ;
  OPJ_FLOAT32 *__cil_tmp23 ;
  OPJ_UINT32 *__cil_tmp24 ;
  int tmp ;
  OPJ_FLOAT32 *__cil_tmp26 ;
  OPJ_FLOAT32 *__cil_tmp27 ;
  OPJ_FLOAT32 *__cil_tmp28 ;
  OPJ_FLOAT32 *__cil_tmp29 ;
  OPJ_FLOAT32 *__cil_tmp30 ;
  OPJ_FLOAT32 *__cil_tmp31 ;

  {
#line 217
  lStride = nb_compo + 1U;
#line 222
  lLineMatrix = pMatrix;
#line 223
  lBeginPtr = (pResult + nb_compo) - 1;
#line 225
  lCurrentPermutationPtr = pPermutations;
#line 228
  lIntermediatePtr = p_intermediate_data;
#line 229
  lGeneratedData = (p_intermediate_data + nb_compo) - 1;
#line 231
  i = (OPJ_UINT32 )0;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! (i < nb_compo)) {
#line 231
      goto while_break;
    }
#line 232
    sum = (OPJ_FLOAT32 )0.;
#line 233
    lCurrentPtr = p_intermediate_data;
#line 234
    lTmpMatrix = lLineMatrix;
#line 235
    j = (OPJ_UINT32 )1;
    {
#line 235
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 235
      if (! (j <= i)) {
#line 235
        goto while_break___0;
      }
#line 238
      __cil_tmp22 = lCurrentPtr;
#line 238
      lCurrentPtr ++;
#line 238
      __cil_tmp21 = lTmpMatrix;
#line 238
      lTmpMatrix ++;
#line 238
      sum += *__cil_tmp21 * *__cil_tmp22;
#line 235
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 241
    __cil_tmp24 = lCurrentPermutationPtr;
#line 241
    lCurrentPermutationPtr ++;
#line 241
    __cil_tmp23 = lIntermediatePtr;
#line 241
    lIntermediatePtr ++;
#line 241
    *__cil_tmp23 = *(pVector + *__cil_tmp24) - sum;
#line 242
    lLineMatrix += nb_compo;
#line 231
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  lLineMatrix = (pMatrix + nb_compo * nb_compo) - 1;
#line 249
  lDestPtr = pResult + nb_compo;
#line 253
  k = (OPJ_INT32 )nb_compo - 1;
  {
#line 253
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 253
    if (! (k != -1)) {
#line 253
      goto while_break___1;
    }
#line 254
    sum = (OPJ_FLOAT32 )0.;
#line 255
    lTmpMatrix = lLineMatrix;
#line 256
    __cil_tmp26 = lTmpMatrix;
#line 256
    lTmpMatrix ++;
#line 256
    u = *__cil_tmp26;
#line 257
    __cil_tmp27 = lDestPtr;
#line 257
    lDestPtr --;
#line 257
    lCurrentPtr = __cil_tmp27;
#line 258
    j = (OPJ_UINT32 )(k + 1);
    {
#line 258
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 258
      if (! (j < nb_compo)) {
#line 258
        goto while_break___2;
      }
#line 260
      __cil_tmp29 = lCurrentPtr;
#line 260
      lCurrentPtr ++;
#line 260
      __cil_tmp28 = lTmpMatrix;
#line 260
      lTmpMatrix ++;
#line 260
      sum += *__cil_tmp28 * *__cil_tmp29;
#line 258
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 263
    __cil_tmp31 = lGeneratedData;
#line 263
    lGeneratedData --;
#line 263
    __cil_tmp30 = lBeginPtr;
#line 263
    lBeginPtr --;
#line 263
    *__cil_tmp30 = (*__cil_tmp31 - sum) / u;
#line 264
    lLineMatrix -= lStride;
#line 253
    k --;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 269 "/root/patron/new_21/src/lib/openjp2/invert.c"
void opj_lupInvert(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix , OPJ_UINT32 nb_compo ,
                   OPJ_UINT32 *pPermutations , OPJ_FLOAT32 *p_src_temp , OPJ_FLOAT32 *p_dest_temp ,
                   OPJ_FLOAT32 *p_swap_area ) 
{ 
  OPJ_UINT32 j ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 *lCurrentPtr ;
  OPJ_FLOAT32 *lLineMatrix ;
  OPJ_UINT32 lSwapSize ;
  OPJ_FLOAT32 *__cil_tmp13 ;

  {
#line 279
  lLineMatrix = pDestMatrix;
#line 280
  lSwapSize = nb_compo * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 282
  j = (OPJ_UINT32 )0;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! (j < nb_compo)) {
#line 282
      goto while_break;
    }
    {
#line 283
    __cil_tmp13 = lLineMatrix;
#line 283
    lLineMatrix ++;
#line 283
    lCurrentPtr = __cil_tmp13;
#line 284
    memset(p_src_temp, 0, (unsigned long )lSwapSize);
#line 285
    *(p_src_temp + j) = (OPJ_FLOAT32 )1.;
#line 286
    opj_lupSolve(p_dest_temp, pSrcMatrix, p_src_temp, pPermutations, nb_compo, p_swap_area);
#line 288
    i = (OPJ_UINT32 )0;
    }
    {
#line 288
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 288
      if (! (i < nb_compo)) {
#line 288
        goto while_break___0;
      }
#line 289
      *lCurrentPtr = *(p_dest_temp + i);
#line 290
      lCurrentPtr += nb_compo;
#line 288
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 282
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 34 "/root/patron/new_21/src/lib/openjp2/image.c"
opj_image_t *opj_image_create0(void) 
{ 
  opj_image_t *image ;
  void *__cil_tmp2 ;

  {
  {
#line 35
  __cil_tmp2 = calloc((unsigned long )1, sizeof(opj_image_t ));
#line 35
  image = (opj_image_t *)__cil_tmp2;
  }
#line 36
  return (image);
}
}
#line 39 "/root/patron/new_21/src/lib/openjp2/image.c"
opj_image_t *opj_image_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                              OPJ_COLOR_SPACE clrspc ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_t *image ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_image_comp_t *comp ;
  void *__cil_tmp9 ;
  OPJ_UINT32 __cil_tmp10 ;

  {
  {
#line 41
  image = (opj_image_t *)((void *)0);
#line 43
  __cil_tmp6 = calloc((unsigned long )1, sizeof(opj_image_t ));
#line 43
  image = (opj_image_t *)__cil_tmp6;
  }
#line 44
  if (image) {
    {
#line 45
    image->color_space = clrspc;
#line 46
    image->numcomps = numcmpts;
#line 48
    __cil_tmp7 = calloc((unsigned long )1, (unsigned long )image->numcomps * sizeof(opj_image_comp_t ));
#line 48
    image->comps = (opj_image_comp_t *)__cil_tmp7;
    }
#line 49
    if (! image->comps) {
      {
#line 50
      fprintf(stderr, "Unable to allocate memory for image.\n");
#line 51
      opj_image_destroy(image);
      }
#line 52
      return ((opj_image_t *)((void *)0));
    }
#line 55
    compno = (OPJ_UINT32 )0;
    {
#line 55
    while (1) {
      while_continue: /* CIL Label */ ;
#line 55
      if (! (compno < numcmpts)) {
#line 55
        goto while_break;
      }
      {
#line 56
      comp = image->comps + compno;
#line 57
      comp->dx = (cmptparms + compno)->dx;
#line 58
      comp->dy = (cmptparms + compno)->dy;
#line 59
      comp->w = (cmptparms + compno)->w;
#line 60
      comp->h = (cmptparms + compno)->h;
#line 61
      comp->x0 = (cmptparms + compno)->x0;
#line 62
      comp->y0 = (cmptparms + compno)->y0;
#line 63
      comp->prec = (cmptparms + compno)->prec;
#line 64
      comp->bpp = (cmptparms + compno)->bpp;
#line 65
      comp->sgnd = (cmptparms + compno)->sgnd;
#line 66
      __cil_tmp9 = calloc((unsigned long )(comp->w * comp->h), sizeof(OPJ_INT32 ));
#line 66
      comp->data = (OPJ_INT32 *)__cil_tmp9;
      }
#line 67
      if (! comp->data) {
        {
#line 68
        fprintf(stderr, "Unable to allocate memory for image.\n");
#line 69
        opj_image_destroy(image);
        }
#line 70
        return ((opj_image_t *)((void *)0));
      }
#line 55
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 75
  return (image);
}
}
#line 78 "/root/patron/new_21/src/lib/openjp2/image.c"
void opj_image_destroy(opj_image_t *image ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_comp_t *image_comp ;
  OPJ_UINT32 __cil_tmp4 ;

  {
#line 79
  if (image) {
#line 80
    if (image->comps) {
#line 84
      compno = (OPJ_UINT32 )0;
      {
#line 84
      while (1) {
        while_continue: /* CIL Label */ ;
#line 84
        if (! (compno < image->numcomps)) {
#line 84
          goto while_break;
        }
#line 85
        image_comp = image->comps + compno;
#line 86
        if (image_comp->data) {
          {
#line 87
          free(image_comp->data);
          }
        }
#line 84
        compno ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 90
      free(image->comps);
      }
    }
#line 93
    if (image->icc_profile_buf) {
      {
#line 94
      free(image->icc_profile_buf);
      }
    }
    {
#line 97
    free(image);
    }
  }
  return;
}
}
#line 107 "/root/patron/new_21/src/lib/openjp2/image.c"
void opj_image_comp_header_update(opj_image_t *p_image_header , struct opj_cp *p_cp ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_INT32 l_x0 ;
  OPJ_INT32 l_y0 ;
  OPJ_INT32 l_x1 ;
  OPJ_INT32 l_y1 ;
  OPJ_INT32 l_comp_x0 ;
  OPJ_INT32 l_comp_y0 ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  opj_image_comp_t *l_img_comp ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  OPJ_INT32 __cil_tmp20 ;
  OPJ_INT32 __cil_tmp21 ;
  OPJ_INT32 __cil_tmp22 ;
  OPJ_INT32 __cil_tmp23 ;
  OPJ_INT32 __cil_tmp24 ;

  {
  {
#line 112
  l_img_comp = (opj_image_comp_t *)((void *)0);
#line 114
  l_x0 = opj_int_max((OPJ_INT32 )p_cp->tx0, (OPJ_INT32 )p_image_header->x0);
#line 115
  l_y0 = opj_int_max((OPJ_INT32 )p_cp->ty0, (OPJ_INT32 )p_image_header->y0);
#line 116
  l_x1 = opj_int_min((OPJ_INT32 )(p_cp->tx0 + p_cp->tw * p_cp->tdx), (OPJ_INT32 )p_image_header->x1);
#line 117
  l_y1 = opj_int_min((OPJ_INT32 )(p_cp->ty0 + p_cp->th * p_cp->tdy), (OPJ_INT32 )p_image_header->y1);
#line 119
  l_img_comp = p_image_header->comps;
#line 120
  i = (OPJ_UINT32 )0;
  }
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (i < p_image_header->numcomps)) {
#line 120
      goto while_break;
    }
    {
#line 121
    l_comp_x0 = opj_int_ceildiv(l_x0, (OPJ_INT32 )l_img_comp->dx);
#line 122
    l_comp_y0 = opj_int_ceildiv(l_y0, (OPJ_INT32 )l_img_comp->dy);
#line 123
    l_comp_x1 = opj_int_ceildiv(l_x1, (OPJ_INT32 )l_img_comp->dx);
#line 124
    l_comp_y1 = opj_int_ceildiv(l_y1, (OPJ_INT32 )l_img_comp->dy);
#line 125
    __cil_tmp23 = opj_int_ceildivpow2(l_comp_x1 - l_comp_x0, (OPJ_INT32 )l_img_comp->factor);
#line 125
    l_width = (OPJ_UINT32 )__cil_tmp23;
#line 126
    __cil_tmp24 = opj_int_ceildivpow2(l_comp_y1 - l_comp_y0, (OPJ_INT32 )l_img_comp->factor);
#line 126
    l_height = (OPJ_UINT32 )__cil_tmp24;
#line 127
    l_img_comp->w = l_width;
#line 128
    l_img_comp->h = l_height;
#line 129
    l_img_comp->x0 = (OPJ_UINT32 )l_comp_x0;
#line 130
    l_img_comp->y0 = (OPJ_UINT32 )l_comp_y0;
#line 131
    l_img_comp ++;
    }
#line 120
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 144 "/root/patron/new_21/src/lib/openjp2/image.c"
void opj_copy_image_header(opj_image_t *p_image_src , opj_image_t *p_image_dest ) 
{ 
  OPJ_UINT32 compno ;
  int tmp ;
  int tmp___0 ;
  opj_image_comp_t *image_comp ;
  OPJ_UINT32 __cil_tmp7 ;
  void *__cil_tmp8 ;
  OPJ_UINT32 __cil_tmp9 ;
  void *__cil_tmp10 ;

  {
#line 152
  p_image_dest->x0 = p_image_src->x0;
#line 153
  p_image_dest->y0 = p_image_src->y0;
#line 154
  p_image_dest->x1 = p_image_src->x1;
#line 155
  p_image_dest->y1 = p_image_src->y1;
#line 157
  if (p_image_dest->comps) {
#line 158
    compno = (OPJ_UINT32 )0;
    {
#line 158
    while (1) {
      while_continue: /* CIL Label */ ;
#line 158
      if (! (compno < p_image_dest->numcomps)) {
#line 158
        goto while_break;
      }
#line 159
      image_comp = p_image_dest->comps + compno;
#line 160
      if (image_comp->data) {
        {
#line 161
        free(image_comp->data);
        }
      }
#line 158
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 164
    free(p_image_dest->comps);
#line 165
    p_image_dest->comps = (opj_image_comp_t *)((void *)0);
    }
  }
  {
#line 168
  p_image_dest->numcomps = p_image_src->numcomps;
#line 170
  __cil_tmp8 = malloc((unsigned long )p_image_dest->numcomps * sizeof(opj_image_comp_t ));
#line 170
  p_image_dest->comps = (opj_image_comp_t *)__cil_tmp8;
  }
#line 171
  if (! p_image_dest->comps) {
#line 172
    p_image_dest->comps = (opj_image_comp_t *)((void *)0);
#line 173
    p_image_dest->numcomps = (OPJ_UINT32 )0;
#line 174
    return;
  }
#line 177
  compno = (OPJ_UINT32 )0;
  {
#line 177
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 177
    if (! (compno < p_image_dest->numcomps)) {
#line 177
      goto while_break___0;
    }
    {
#line 178
    memcpy(p_image_dest->comps + compno, p_image_src->comps + compno, sizeof(opj_image_comp_t ));
#line 181
    (p_image_dest->comps + compno)->data = (OPJ_INT32 *)((void *)0);
    }
#line 177
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 184
  p_image_dest->color_space = p_image_src->color_space;
#line 185
  p_image_dest->icc_profile_len = p_image_src->icc_profile_len;
#line 187
  if (p_image_dest->icc_profile_len) {
    {
#line 188
    __cil_tmp10 = malloc((unsigned long )p_image_dest->icc_profile_len);
#line 188
    p_image_dest->icc_profile_buf = (OPJ_BYTE *)__cil_tmp10;
    }
#line 189
    if (! p_image_dest->icc_profile_buf) {
#line 190
      p_image_dest->icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 191
      p_image_dest->icc_profile_len = (OPJ_UINT32 )0;
#line 192
      return;
    }
    {
#line 194
    memcpy(p_image_dest->icc_profile_buf, p_image_src->icc_profile_buf, (unsigned long )p_image_src->icc_profile_len);
    }
  } else {
#line 199
    p_image_dest->icc_profile_buf = (OPJ_BYTE *)((void *)0);
  }
#line 201
  return;
}
}
#line 204 "/root/patron/new_21/src/lib/openjp2/image.c"
opj_image_t *opj_image_tile_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                                   OPJ_COLOR_SPACE clrspc ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_t *image ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_image_comp_t *comp ;
  OPJ_UINT32 __cil_tmp9 ;

  {
  {
#line 206
  image = (opj_image_t *)0;
#line 208
  __cil_tmp6 = calloc((unsigned long )1, sizeof(opj_image_t ));
#line 208
  image = (opj_image_t *)__cil_tmp6;
  }
#line 209
  if (image) {
    {
#line 212
    image->color_space = clrspc;
#line 213
    image->numcomps = numcmpts;
#line 216
    __cil_tmp7 = calloc((unsigned long )image->numcomps, sizeof(opj_image_comp_t ));
#line 216
    image->comps = (opj_image_comp_t *)__cil_tmp7;
    }
#line 217
    if (! image->comps) {
      {
#line 218
      opj_image_destroy(image);
      }
#line 219
      return ((opj_image_t *)0);
    }
#line 223
    compno = (OPJ_UINT32 )0;
    {
#line 223
    while (1) {
      while_continue: /* CIL Label */ ;
#line 223
      if (! (compno < numcmpts)) {
#line 223
        goto while_break;
      }
#line 224
      comp = image->comps + compno;
#line 225
      comp->dx = (cmptparms + compno)->dx;
#line 226
      comp->dy = (cmptparms + compno)->dy;
#line 227
      comp->w = (cmptparms + compno)->w;
#line 228
      comp->h = (cmptparms + compno)->h;
#line 229
      comp->x0 = (cmptparms + compno)->x0;
#line 230
      comp->y0 = (cmptparms + compno)->y0;
#line 231
      comp->prec = (cmptparms + compno)->prec;
#line 232
      comp->sgnd = (cmptparms + compno)->sgnd;
#line 233
      comp->data = (OPJ_INT32 *)0;
#line 223
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 237
  return (image);
}
}
#line 39 "/root/patron/new_21/src/lib/openjp2/function_list.c"
opj_procedure_list_t *opj_procedure_list_create(void) 
{ 
  opj_procedure_list_t *l_validation ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 42
  __cil_tmp2 = calloc((unsigned long )1, sizeof(opj_procedure_list_t ));
#line 42
  l_validation = (opj_procedure_list_t *)__cil_tmp2;
  }
#line 43
  if (! l_validation) {
#line 45
    return ((opj_procedure_list_t *)0);
  }
  {
#line 48
  l_validation->m_nb_max_procedures = (OPJ_UINT32 )10;
#line 49
  __cil_tmp3 = calloc((unsigned long )10, sizeof(opj_procedure ));
#line 49
  l_validation->m_procedures = (opj_procedure *)__cil_tmp3;
  }
#line 50
  if (! l_validation->m_procedures) {
    {
#line 52
    free(l_validation);
    }
#line 53
    return ((opj_procedure_list_t *)0);
  }
#line 55
  return (l_validation);
}
}
#line 58 "/root/patron/new_21/src/lib/openjp2/function_list.c"
void opj_procedure_list_destroy(opj_procedure_list_t *p_list ) 
{ 


  {
#line 60
  if (! p_list) {
#line 62
    return;
  }
#line 65
  if (p_list->m_procedures) {
    {
#line 67
    free(p_list->m_procedures);
    }
  }
  {
#line 69
  free(p_list);
  }
  return;
}
}
#line 72 "/root/patron/new_21/src/lib/openjp2/function_list.c"
OPJ_BOOL opj_procedure_list_add_procedure(opj_procedure_list_t *p_validation_list ,
                                          opj_procedure p_procedure ) 
{ 
  opj_procedure *new_procedures ;
  void *__cil_tmp4 ;

  {
#line 74
  if (p_validation_list->m_nb_max_procedures == p_validation_list->m_nb_procedures) {
    {
#line 78
    p_validation_list->m_nb_max_procedures += (unsigned int )10;
#line 79
    __cil_tmp4 = realloc(p_validation_list->m_procedures, (unsigned long )p_validation_list->m_nb_max_procedures * sizeof(opj_procedure ));
#line 79
    new_procedures = (opj_procedure *)__cil_tmp4;
    }
#line 82
    if (! new_procedures) {
      {
#line 84
      free(p_validation_list->m_procedures);
#line 85
      p_validation_list->m_nb_max_procedures = (OPJ_UINT32 )0;
#line 86
      p_validation_list->m_nb_procedures = (OPJ_UINT32 )0;
#line 88
      fprintf(stderr, "Not enough memory to add a new validation procedure\n");
      }
#line 90
      return (0);
    } else {
#line 94
      p_validation_list->m_procedures = new_procedures;
    }
  }
#line 97
  *(p_validation_list->m_procedures + p_validation_list->m_nb_procedures) = p_procedure;
#line 98
  (p_validation_list->m_nb_procedures) ++;
#line 100
  return (1);
}
}
#line 103 "/root/patron/new_21/src/lib/openjp2/function_list.c"
OPJ_UINT32 opj_procedure_list_get_nb_procedures(opj_procedure_list_t *p_validation_list ) 
{ 


  {
#line 105
  return (p_validation_list->m_nb_procedures);
}
}
#line 108 "/root/patron/new_21/src/lib/openjp2/function_list.c"
opj_procedure *opj_procedure_list_get_first_procedure(opj_procedure_list_t *p_validation_list ) 
{ 


  {
#line 110
  return (p_validation_list->m_procedures);
}
}
#line 113 "/root/patron/new_21/src/lib/openjp2/function_list.c"
void opj_procedure_list_clear(opj_procedure_list_t *p_validation_list ) 
{ 


  {
#line 115
  p_validation_list->m_nb_procedures = (OPJ_UINT32 )0;
  return;
}
}
#line 76 "/root/patron/new_21/src/lib/openjp2/event.c"
static void opj_default_callback(char const   *msg , void *client_data ) 
{ 


  {
  return;
}
}
#line 86 "/root/patron/new_21/src/lib/openjp2/event.c"
OPJ_BOOL opj_event_msg(opj_event_mgr_t *p_event_mgr , OPJ_INT32 event_type , char const   *fmt 
                       , ...) 
{ 
  opj_msg_callback msg_handler ;
  void *l_data ;
  va_list arg ;
  size_t str_length ;
  char message[512] ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long tmp ;

  {
#line 88
  msg_handler = (opj_msg_callback )0;
#line 89
  l_data = (void *)0;
#line 91
  if (p_event_mgr != (opj_event_mgr_t *)0) {
    {
#line 93
    if (event_type == 1) {
#line 93
      goto case_1;
    }
#line 97
    if (event_type == 2) {
#line 97
      goto case_2;
    }
#line 101
    if (event_type == 4) {
#line 101
      goto case_4;
    }
#line 105
    goto switch_default;
    case_1: /* CIL Label */ 
#line 94
    msg_handler = p_event_mgr->error_handler;
#line 95
    l_data = p_event_mgr->m_error_data;
#line 96
    goto switch_break;
    case_2: /* CIL Label */ 
#line 98
    msg_handler = p_event_mgr->warning_handler;
#line 99
    l_data = p_event_mgr->m_warning_data;
#line 100
    goto switch_break;
    case_4: /* CIL Label */ 
#line 102
    msg_handler = p_event_mgr->info_handler;
#line 103
    l_data = p_event_mgr->m_info_data;
#line 104
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 106
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 108
    if (msg_handler == (opj_msg_callback )0) {
#line 109
      return (0);
    }
  } else {
#line 112
    return (0);
  }
#line 115
  if (fmt != (char const   *)0) {
#line 115
    if (p_event_mgr != (opj_event_mgr_t *)0) {
      {
#line 119
      memset((char *)message, 0, (unsigned long )512);
#line 121
      __builtin_va_start((void *)arg, fmt);
#line 123
      __cil_tmp9 = strlen(fmt);
      }
#line 123
      if (__cil_tmp9 > 512UL) {
#line 123
        tmp = (unsigned long )512;
      } else {
        {
#line 123
        __cil_tmp10 = strlen(fmt);
#line 123
        tmp = __cil_tmp10;
        }
      }
      {
#line 123
      str_length = tmp;
#line 126
      vsnprintf((char *)message, (unsigned long )512, fmt, (void *)arg);
#line 128
      __builtin_va_end((void *)arg);
#line 131
      (*msg_handler)((char const   *)((char *)message), l_data);
      }
    }
  }
#line 134
  return (1);
}
}
#line 137 "/root/patron/new_21/src/lib/openjp2/event.c"
void opj_set_default_event_handler(opj_event_mgr_t *p_manager ) 
{ 


  {
#line 139
  p_manager->m_error_data = (void *)0;
#line 140
  p_manager->m_warning_data = (void *)0;
#line 141
  p_manager->m_info_data = (void *)0;
#line 142
  p_manager->error_handler = & opj_default_callback;
#line 143
  p_manager->info_handler = & opj_default_callback;
#line 144
  p_manager->warning_handler = & opj_default_callback;
  return;
}
}
#line 47 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_write_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  int tmp ;

  {
  {
#line 49
  l_data_ptr = (OPJ_BYTE *)(& p_value) + p_nb_bytes;
#line 53
  memcpy(p_buffer, l_data_ptr, (unsigned long )p_nb_bytes);
  }
  return;
}
}
#line 56 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_write_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  int tmp ;
  OPJ_BYTE *__cil_tmp7 ;
  OPJ_BYTE *__cil_tmp8 ;

  {
#line 58
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + p_nb_bytes) - 1;
#line 63
  i = (OPJ_UINT32 )0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < p_nb_bytes)) {
#line 63
      goto while_break;
    }
#line 64
    __cil_tmp8 = l_data_ptr;
#line 64
    l_data_ptr --;
#line 64
    __cil_tmp7 = p_buffer;
#line 64
    p_buffer ++;
#line 64
    *__cil_tmp7 = *__cil_tmp8;
#line 63
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 68 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_read_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  int tmp ;

  {
  {
#line 70
  l_data_ptr = (OPJ_BYTE *)p_value;
#line 74
  *p_value = (OPJ_UINT32 )0;
#line 75
  memcpy((l_data_ptr + 4) - p_nb_bytes, p_buffer, (unsigned long )p_nb_bytes);
  }
  return;
}
}
#line 78 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_read_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  int tmp ;
  OPJ_BYTE *__cil_tmp7 ;
  OPJ_BYTE *__cil_tmp8 ;

  {
#line 80
  l_data_ptr = ((OPJ_BYTE *)p_value + p_nb_bytes) - 1;
#line 85
  *p_value = (OPJ_UINT32 )0;
#line 86
  i = (OPJ_UINT32 )0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < p_nb_bytes)) {
#line 86
      goto while_break;
    }
#line 87
    __cil_tmp8 = p_buffer;
#line 87
    p_buffer ++;
#line 87
    __cil_tmp7 = l_data_ptr;
#line 87
    l_data_ptr --;
#line 87
    *__cil_tmp7 = *__cil_tmp8;
#line 86
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 91 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_write_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 93
  l_data_ptr = (OPJ_BYTE *)(& p_value);
#line 94
  memcpy(p_buffer, l_data_ptr, sizeof(OPJ_FLOAT64 ));
  }
  return;
}
}
#line 97 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_write_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 99
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + sizeof(OPJ_FLOAT64 )) - 1;
#line 101
  i = (OPJ_UINT32 )0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT64 ))) {
#line 101
      goto while_break;
    }
#line 102
    __cil_tmp6 = l_data_ptr;
#line 102
    l_data_ptr --;
#line 102
    __cil_tmp5 = p_buffer;
#line 102
    p_buffer ++;
#line 102
    *__cil_tmp5 = *__cil_tmp6;
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 106 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_read_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 108
  l_data_ptr = (OPJ_BYTE *)p_value;
#line 109
  memcpy(l_data_ptr, p_buffer, sizeof(OPJ_FLOAT64 ));
  }
  return;
}
}
#line 112 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_read_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 114
  l_data_ptr = ((OPJ_BYTE *)p_value + sizeof(OPJ_FLOAT64 )) - 1;
#line 116
  i = (OPJ_UINT32 )0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT64 ))) {
#line 116
      goto while_break;
    }
#line 117
    __cil_tmp6 = p_buffer;
#line 117
    p_buffer ++;
#line 117
    __cil_tmp5 = l_data_ptr;
#line 117
    l_data_ptr --;
#line 117
    *__cil_tmp5 = *__cil_tmp6;
#line 116
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 121 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_write_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 123
  l_data_ptr = (OPJ_BYTE *)(& p_value);
#line 124
  memcpy(p_buffer, l_data_ptr, sizeof(OPJ_FLOAT32 ));
  }
  return;
}
}
#line 127 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_write_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 129
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + sizeof(OPJ_FLOAT32 )) - 1;
#line 131
  i = (OPJ_UINT32 )0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT32 ))) {
#line 131
      goto while_break;
    }
#line 132
    __cil_tmp6 = l_data_ptr;
#line 132
    l_data_ptr --;
#line 132
    __cil_tmp5 = p_buffer;
#line 132
    p_buffer ++;
#line 132
    *__cil_tmp5 = *__cil_tmp6;
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 136 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_read_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 138
  l_data_ptr = (OPJ_BYTE *)p_value;
#line 139
  memcpy(l_data_ptr, p_buffer, sizeof(OPJ_FLOAT32 ));
  }
  return;
}
}
#line 142 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_read_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 144
  l_data_ptr = ((OPJ_BYTE *)p_value + sizeof(OPJ_FLOAT32 )) - 1;
#line 146
  i = (OPJ_UINT32 )0;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT32 ))) {
#line 146
      goto while_break;
    }
#line 147
    __cil_tmp6 = p_buffer;
#line 147
    p_buffer ++;
#line 147
    __cil_tmp5 = l_data_ptr;
#line 147
    l_data_ptr --;
#line 147
    *__cil_tmp5 = *__cil_tmp6;
#line 146
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 151 "/root/patron/new_21/src/lib/openjp2/cio.c"
opj_stream_t *opj_stream_create(OPJ_SIZE_T p_buffer_size , OPJ_BOOL l_is_input ) 
{ 
  opj_stream_private_t *l_stream ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 153
  l_stream = (opj_stream_private_t *)0;
#line 154
  __cil_tmp4 = calloc((unsigned long )1, sizeof(opj_stream_private_t ));
#line 154
  l_stream = (opj_stream_private_t *)__cil_tmp4;
  }
#line 155
  if (! l_stream) {
#line 156
    return ((opj_stream_t *)0);
  }
  {
#line 159
  l_stream->m_buffer_size = p_buffer_size;
#line 160
  __cil_tmp5 = malloc(p_buffer_size);
#line 160
  l_stream->m_stored_data = (OPJ_BYTE *)__cil_tmp5;
  }
#line 161
  if (! l_stream->m_stored_data) {
    {
#line 162
    free(l_stream);
    }
#line 163
    return ((opj_stream_t *)0);
  }
#line 166
  l_stream->m_current_data = l_stream->m_stored_data;
#line 168
  if (l_is_input) {
#line 169
    l_stream->m_status |= 2;
#line 170
    l_stream->m_opj_skip = & opj_stream_read_skip;
#line 171
    l_stream->m_opj_seek = & opj_stream_read_seek;
  } else {
#line 174
    l_stream->m_status |= 1;
#line 175
    l_stream->m_opj_skip = & opj_stream_write_skip;
#line 176
    l_stream->m_opj_seek = & opj_stream_write_seek;
  }
#line 179
  l_stream->m_read_fn = & opj_stream_default_read;
#line 180
  l_stream->m_write_fn = & opj_stream_default_write;
#line 181
  l_stream->m_skip_fn = & opj_stream_default_skip;
#line 182
  l_stream->m_seek_fn = & opj_stream_default_seek;
#line 184
  return ((opj_stream_t *)l_stream);
}
}
#line 187 "/root/patron/new_21/src/lib/openjp2/cio.c"
opj_stream_t *opj_stream_default_create(OPJ_BOOL l_is_input ) 
{ 
  opj_stream_t *__cil_tmp2 ;

  {
  {
#line 189
  __cil_tmp2 = opj_stream_create((OPJ_SIZE_T )1048576, l_is_input);
  }
#line 189
  return (__cil_tmp2);
}
}
#line 192 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_stream_destroy(opj_stream_t *p_stream ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 194
  l_stream = (opj_stream_private_t *)p_stream;
#line 196
  if (l_stream) {
#line 197
    if (l_stream->m_free_user_data_fn) {
      {
#line 198
      (*(l_stream->m_free_user_data_fn))(l_stream->m_user_data);
      }
    }
    {
#line 200
    free(l_stream->m_stored_data);
#line 201
    l_stream->m_stored_data = (OPJ_BYTE *)0;
#line 202
    free(l_stream);
    }
  }
  return;
}
}
#line 206 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_stream_set_read_function(opj_stream_t *p_stream , opj_stream_read_fn p_function ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 208
  l_stream = (opj_stream_private_t *)p_stream;
#line 210
  if (! l_stream) {
#line 211
    return;
  } else
#line 210
  if (! ((int )l_stream->m_status & 2)) {
#line 211
    return;
  }
#line 214
  l_stream->m_read_fn = p_function;
  return;
}
}
#line 217 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_stream_set_seek_function(opj_stream_t *p_stream , opj_stream_seek_fn p_function ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 219
  l_stream = (opj_stream_private_t *)p_stream;
#line 221
  if (! l_stream) {
#line 222
    return;
  }
#line 224
  l_stream->m_seek_fn = p_function;
  return;
}
}
#line 227 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_stream_set_write_function(opj_stream_t *p_stream , opj_stream_write_fn p_function ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 229
  l_stream = (opj_stream_private_t *)p_stream;
#line 231
  if (! l_stream) {
#line 232
    return;
  } else
#line 231
  if (! ((int )l_stream->m_status & 1)) {
#line 232
    return;
  }
#line 235
  l_stream->m_write_fn = p_function;
  return;
}
}
#line 238 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_stream_set_skip_function(opj_stream_t *p_stream , opj_stream_skip_fn p_function ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 240
  l_stream = (opj_stream_private_t *)p_stream;
#line 242
  if (! l_stream) {
#line 243
    return;
  }
#line 246
  l_stream->m_skip_fn = p_function;
  return;
}
}
#line 249 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_stream_set_user_data(opj_stream_t *p_stream , void *p_data , opj_stream_free_user_data_fn p_function ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 251
  l_stream = (opj_stream_private_t *)p_stream;
#line 252
  if (! l_stream) {
#line 253
    return;
  }
#line 254
  l_stream->m_user_data = p_data;
#line 255
  l_stream->m_free_user_data_fn = p_function;
  return;
}
}
#line 258 "/root/patron/new_21/src/lib/openjp2/cio.c"
void opj_stream_set_user_data_length(opj_stream_t *p_stream , OPJ_UINT64 data_length ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 260
  l_stream = (opj_stream_private_t *)p_stream;
#line 261
  if (! l_stream) {
#line 262
    return;
  }
#line 263
  l_stream->m_user_data_length = data_length;
  return;
}
}
#line 266 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_read_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_SIZE_T l_read_nb_bytes ;
  OPJ_SIZE_T tmp ;
  OPJ_SIZE_T __cil_tmp7 ;
  OPJ_SIZE_T tmp___0 ;
  OPJ_SIZE_T __cil_tmp9 ;
  OPJ_SIZE_T tmp___1 ;

  {
#line 268
  l_read_nb_bytes = (OPJ_SIZE_T )0;
#line 269
  if (p_stream->m_bytes_in_buffer >= p_size) {
    {
#line 270
    memcpy(p_buffer, p_stream->m_current_data, p_size);
#line 271
    p_stream->m_current_data += p_size;
#line 272
    p_stream->m_bytes_in_buffer -= p_size;
#line 273
    l_read_nb_bytes += p_size;
#line 274
    p_stream->m_byte_offset += (OPJ_OFF_T )p_size;
    }
#line 275
    return (l_read_nb_bytes);
  }
#line 279
  if ((int )p_stream->m_status & 4) {
    {
#line 280
    l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 281
    memcpy(p_buffer, p_stream->m_current_data, p_stream->m_bytes_in_buffer);
#line 282
    p_stream->m_current_data += p_stream->m_bytes_in_buffer;
#line 283
    p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 284
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
    }
#line 285
    if (l_read_nb_bytes) {
#line 285
      tmp = l_read_nb_bytes;
    } else {
#line 285
      tmp = (OPJ_SIZE_T )(- 1);
    }
#line 285
    return (tmp);
  }
#line 289
  if (p_stream->m_bytes_in_buffer) {
    {
#line 290
    l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 291
    memcpy(p_buffer, p_stream->m_current_data, p_stream->m_bytes_in_buffer);
#line 292
    p_stream->m_current_data = p_stream->m_stored_data;
#line 293
    p_buffer += p_stream->m_bytes_in_buffer;
#line 294
    p_size -= p_stream->m_bytes_in_buffer;
#line 295
    p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 296
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
    }
  } else {
#line 302
    p_stream->m_current_data = p_stream->m_stored_data;
  }
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (p_size < p_stream->m_buffer_size) {
      {
#line 309
      p_stream->m_bytes_in_buffer = (*(p_stream->m_read_fn))(p_stream->m_stored_data,
                                                             p_stream->m_buffer_size,
                                                             p_stream->m_user_data);
      }
#line 311
      if (p_stream->m_bytes_in_buffer == 0xffffffffffffffffUL) {
        {
#line 313
        opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n");
#line 315
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 316
        p_stream->m_status |= 4;
        }
#line 318
        if (l_read_nb_bytes) {
#line 318
          tmp___0 = l_read_nb_bytes;
        } else {
#line 318
          tmp___0 = (OPJ_SIZE_T )(- 1);
        }
#line 318
        return (tmp___0);
      } else
#line 320
      if (p_stream->m_bytes_in_buffer < p_size) {
        {
#line 322
        l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 323
        memcpy(p_buffer, p_stream->m_current_data, p_stream->m_bytes_in_buffer);
#line 324
        p_stream->m_current_data = p_stream->m_stored_data;
#line 325
        p_buffer += p_stream->m_bytes_in_buffer;
#line 326
        p_size -= p_stream->m_bytes_in_buffer;
#line 327
        p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 328
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
        }
      } else {
        {
#line 331
        l_read_nb_bytes += p_size;
#line 332
        memcpy(p_buffer, p_stream->m_current_data, p_size);
#line 333
        p_stream->m_current_data += p_size;
#line 334
        p_stream->m_bytes_in_buffer -= p_size;
#line 335
        p_stream->m_byte_offset += (OPJ_OFF_T )p_size;
        }
#line 336
        return (l_read_nb_bytes);
      }
    } else {
      {
#line 341
      p_stream->m_bytes_in_buffer = (*(p_stream->m_read_fn))(p_buffer, p_size, p_stream->m_user_data);
      }
#line 343
      if (p_stream->m_bytes_in_buffer == 0xffffffffffffffffUL) {
        {
#line 345
        opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n");
#line 347
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 348
        p_stream->m_status |= 4;
        }
#line 350
        if (l_read_nb_bytes) {
#line 350
          tmp___1 = l_read_nb_bytes;
        } else {
#line 350
          tmp___1 = (OPJ_SIZE_T )(- 1);
        }
#line 350
        return (tmp___1);
      } else
#line 352
      if (p_stream->m_bytes_in_buffer < p_size) {
#line 354
        l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 355
        p_stream->m_current_data = p_stream->m_stored_data;
#line 356
        p_buffer += p_stream->m_bytes_in_buffer;
#line 357
        p_size -= p_stream->m_bytes_in_buffer;
#line 358
        p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 359
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
      } else {
#line 363
        l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 364
        p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 365
        p_stream->m_current_data = p_stream->m_stored_data;
#line 366
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 367
        return (l_read_nb_bytes);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 373 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_write_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                 OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_SIZE_T l_remaining_bytes ;
  OPJ_SIZE_T l_write_nb_bytes ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 378
  l_remaining_bytes = (OPJ_SIZE_T )0;
#line 379
  l_write_nb_bytes = (OPJ_SIZE_T )0;
#line 381
  if ((int )p_stream->m_status & 8) {
#line 382
    return ((OPJ_SIZE_T )(- 1));
  }
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 386
    l_remaining_bytes = p_stream->m_buffer_size - p_stream->m_bytes_in_buffer;
#line 389
    if (l_remaining_bytes >= p_size) {
      {
#line 390
      memcpy(p_stream->m_current_data, p_buffer, p_size);
#line 392
      p_stream->m_current_data += p_size;
#line 393
      p_stream->m_bytes_in_buffer += p_size;
#line 394
      l_write_nb_bytes += p_size;
#line 395
      p_stream->m_byte_offset += (OPJ_OFF_T )p_size;
      }
#line 397
      return (l_write_nb_bytes);
    }
#line 401
    if (l_remaining_bytes) {
      {
#line 402
      l_write_nb_bytes += l_remaining_bytes;
#line 404
      memcpy(p_stream->m_current_data, p_buffer, l_remaining_bytes);
#line 406
      p_stream->m_current_data = p_stream->m_stored_data;
#line 408
      p_buffer += l_remaining_bytes;
#line 409
      p_size -= l_remaining_bytes;
#line 410
      p_stream->m_bytes_in_buffer += l_remaining_bytes;
#line 411
      p_stream->m_byte_offset += (OPJ_OFF_T )l_remaining_bytes;
      }
    }
    {
#line 414
    __cil_tmp7 = opj_stream_flush(p_stream, p_event_mgr);
    }
#line 414
    if (! __cil_tmp7) {
#line 415
      return ((OPJ_SIZE_T )(- 1));
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 421 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_flush(opj_stream_private_t *p_stream , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_SIZE_T l_current_write_nb_bytes ;
  OPJ_SIZE_T __cil_tmp4 ;

  {
#line 424
  l_current_write_nb_bytes = (OPJ_SIZE_T )0;
#line 426
  p_stream->m_current_data = p_stream->m_stored_data;
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! p_stream->m_bytes_in_buffer) {
#line 428
      goto while_break;
    }
    {
#line 430
    l_current_write_nb_bytes = (*(p_stream->m_write_fn))(p_stream->m_current_data,
                                                         p_stream->m_bytes_in_buffer,
                                                         p_stream->m_user_data);
    }
#line 434
    if (l_current_write_nb_bytes == 0xffffffffffffffffUL) {
      {
#line 435
      p_stream->m_status |= 8;
#line 436
      opj_event_msg(p_event_mgr, 4, "Error on writing stream!\n\373\036j\347U");
      }
#line 438
      return (0);
    }
#line 441
    p_stream->m_current_data += l_current_write_nb_bytes;
#line 442
    p_stream->m_bytes_in_buffer -= l_current_write_nb_bytes;
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  p_stream->m_current_data = p_stream->m_stored_data;
#line 447
  return (1);
}
}
#line 450 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_read_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_OFF_T l_skip_nb_bytes ;
  OPJ_OFF_T l_current_skip_nb_bytes ;
  int tmp ;
  OPJ_OFF_T tmp___0 ;
  OPJ_OFF_T __cil_tmp8 ;
  OPJ_OFF_T tmp___1 ;

  {
#line 452
  l_skip_nb_bytes = (OPJ_OFF_T )0;
#line 453
  l_current_skip_nb_bytes = (OPJ_OFF_T )0;
#line 457
  if (p_stream->m_bytes_in_buffer >= (OPJ_SIZE_T )p_size) {
#line 458
    p_stream->m_current_data += p_size;
#line 461
    p_stream->m_bytes_in_buffer -= (OPJ_SIZE_T )p_size;
#line 462
    l_skip_nb_bytes += p_size;
#line 463
    p_stream->m_byte_offset += l_skip_nb_bytes;
#line 464
    return (l_skip_nb_bytes);
  }
#line 468
  if ((int )p_stream->m_status & 4) {
#line 469
    l_skip_nb_bytes += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 470
    p_stream->m_current_data += p_stream->m_bytes_in_buffer;
#line 471
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 472
    p_stream->m_byte_offset += l_skip_nb_bytes;
#line 473
    if (l_skip_nb_bytes) {
#line 473
      tmp___0 = l_skip_nb_bytes;
    } else {
#line 473
      tmp___0 = (OPJ_OFF_T )(- 1);
    }
#line 473
    return (tmp___0);
  }
#line 477
  if (p_stream->m_bytes_in_buffer) {
#line 478
    l_skip_nb_bytes += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 479
    p_stream->m_current_data = p_stream->m_stored_data;
#line 480
    p_size -= (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 481
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
  }
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    if (! (p_size > 0L)) {
#line 484
      goto while_break;
    }
    {
#line 486
    l_current_skip_nb_bytes = (*(p_stream->m_skip_fn))(p_size, p_stream->m_user_data);
    }
#line 487
    if (l_current_skip_nb_bytes == -1L) {
      {
#line 488
      opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n\035\037j\347U");
#line 490
      p_stream->m_status |= 4;
#line 491
      p_stream->m_byte_offset += l_skip_nb_bytes;
      }
#line 493
      if (l_skip_nb_bytes) {
#line 493
        tmp___1 = l_skip_nb_bytes;
      } else {
#line 493
        tmp___1 = (OPJ_OFF_T )(- 1);
      }
#line 493
      return (tmp___1);
    }
#line 495
    p_size -= l_current_skip_nb_bytes;
#line 496
    l_skip_nb_bytes += l_current_skip_nb_bytes;
  }
  while_break: /* CIL Label */ ;
  }
#line 499
  p_stream->m_byte_offset += l_skip_nb_bytes;
#line 501
  return (l_skip_nb_bytes);
}
}
#line 504 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_write_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                                opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_BOOL l_is_written ;
  OPJ_OFF_T l_current_skip_nb_bytes ;
  OPJ_OFF_T l_skip_nb_bytes ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_OFF_T __cil_tmp8 ;
  OPJ_OFF_T tmp ;

  {
#line 506
  l_is_written = 0;
#line 507
  l_current_skip_nb_bytes = (OPJ_OFF_T )0;
#line 508
  l_skip_nb_bytes = (OPJ_OFF_T )0;
#line 510
  if ((int )p_stream->m_status & 8) {
#line 511
    return ((OPJ_OFF_T )(- 1));
  }
  {
#line 515
  l_is_written = opj_stream_flush(p_stream, p_event_mgr);
  }
#line 516
  if (! l_is_written) {
#line 517
    p_stream->m_status |= 8;
#line 518
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 519
    return ((OPJ_OFF_T )(- 1));
  }
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! (p_size > 0L)) {
#line 523
      goto while_break;
    }
    {
#line 525
    l_current_skip_nb_bytes = (*(p_stream->m_skip_fn))(p_size, p_stream->m_user_data);
    }
#line 527
    if (l_current_skip_nb_bytes == -1L) {
      {
#line 528
      opj_event_msg(p_event_mgr, 4, "Stream error!\n");
#line 530
      p_stream->m_status |= 8;
#line 531
      p_stream->m_byte_offset += l_skip_nb_bytes;
      }
#line 533
      if (l_skip_nb_bytes) {
#line 533
        tmp = l_skip_nb_bytes;
      } else {
#line 533
        tmp = (OPJ_OFF_T )(- 1);
      }
#line 533
      return (tmp);
    }
#line 535
    p_size -= l_current_skip_nb_bytes;
#line 536
    l_skip_nb_bytes += l_current_skip_nb_bytes;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  p_stream->m_byte_offset += l_skip_nb_bytes;
#line 541
  return (l_skip_nb_bytes);
}
}
#line 544 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_tell(opj_stream_private_t *p_stream ) 
{ 


  {
#line 546
  return (p_stream->m_byte_offset);
}
}
#line 549 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_get_number_byte_left(opj_stream_private_t *p_stream ) 
{ 
  int tmp ;
  int tmp___0 ;
  OPJ_OFF_T tmp___1 ;

  {
#line 553
  if (p_stream->m_user_data_length) {
#line 553
    tmp___1 = (OPJ_OFF_T )p_stream->m_user_data_length - p_stream->m_byte_offset;
  } else {
#line 553
    tmp___1 = (long )0;
  }
#line 553
  return (tmp___1);
}
}
#line 558 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , opj_event_mgr_t *p_event_mgr ) 
{ 
  int tmp ;
  OPJ_OFF_T __cil_tmp5 ;

  {
  {
#line 561
  __cil_tmp5 = (*(p_stream->m_opj_skip))(p_stream, p_size, p_event_mgr);
  }
#line 561
  return (__cil_tmp5);
}
}
#line 564 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_read_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                              opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 567
  p_stream->m_current_data = p_stream->m_stored_data;
#line 568
  p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 570
  __cil_tmp4 = (*(p_stream->m_seek_fn))(p_size, p_stream->m_user_data);
  }
#line 570
  if (! __cil_tmp4) {
#line 571
    p_stream->m_status |= 4;
#line 572
    return (0);
  } else {
#line 576
    p_stream->m_status &= ~ 4;
#line 577
    p_stream->m_byte_offset = p_size;
  }
#line 581
  return (1);
}
}
#line 584 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_write_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 586
  __cil_tmp4 = opj_stream_flush(p_stream, p_event_mgr);
  }
#line 586
  if (! __cil_tmp4) {
#line 587
    p_stream->m_status |= 8;
#line 588
    return (0);
  }
  {
#line 591
  p_stream->m_current_data = p_stream->m_stored_data;
#line 592
  p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 594
  __cil_tmp5 = (*(p_stream->m_seek_fn))(p_size, p_stream->m_user_data);
  }
#line 594
  if (! __cil_tmp5) {
#line 595
    p_stream->m_status |= 8;
#line 596
    return (0);
  } else {
#line 599
    p_stream->m_byte_offset = p_size;
  }
#line 602
  return (1);
}
}
#line 605 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , struct opj_event_mgr *p_event_mgr ) 
{ 
  int tmp ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 608
  __cil_tmp5 = (*(p_stream->m_opj_seek))(p_stream, p_size, p_event_mgr);
  }
#line 608
  return (__cil_tmp5);
}
}
#line 611 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_has_seek(opj_stream_private_t *p_stream ) 
{ 


  {
#line 613
  return (p_stream->m_seek_fn != & opj_stream_default_seek);
}
}
#line 616 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_default_read(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 621
  return ((OPJ_SIZE_T )(- 1));
}
}
#line 624 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_default_write(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 629
  return ((OPJ_SIZE_T )(- 1));
}
}
#line 632 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_default_skip(OPJ_OFF_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 636
  return ((OPJ_OFF_T )(- 1));
}
}
#line 639 "/root/patron/new_21/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_default_seek(OPJ_OFF_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 643
  return (0);
}
}
#line 51 "/root/patron/new_21/src/lib/openjp2/bio.c"
void opj_bio_putbit(opj_bio_t *bio , OPJ_UINT32 b ) ;
#line 57
OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio ) ;
#line 63
OPJ_BOOL opj_bio_byteout(opj_bio_t *bio ) ;
#line 69
OPJ_BOOL opj_bio_bytein(opj_bio_t *bio ) ;
#line 81 "/root/patron/new_21/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_byteout(opj_bio_t *bio ) 
{ 
  int tmp ;
  OPJ_BYTE *__cil_tmp3 ;

  {
#line 82
  bio->buf = (bio->buf << 8) & 65535U;
#line 83
  if (bio->buf == 65280U) {
#line 83
    tmp = 7;
  } else {
#line 83
    tmp = 8;
  }
#line 83
  bio->ct = (OPJ_UINT32 )tmp;
#line 84
  if ((OPJ_SIZE_T )bio->bp >= (OPJ_SIZE_T )bio->end) {
#line 85
    return (0);
  }
#line 87
  __cil_tmp3 = bio->bp;
#line 87
  (bio->bp) ++;
#line 87
  *__cil_tmp3 = (OPJ_BYTE )(bio->buf >> 8);
#line 88
  return (1);
}
}
#line 91 "/root/patron/new_21/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_bytein(opj_bio_t *bio ) 
{ 
  int tmp ;
  OPJ_BYTE *__cil_tmp3 ;

  {
#line 92
  bio->buf = (bio->buf << 8) & 65535U;
#line 93
  if (bio->buf == 65280U) {
#line 93
    tmp = 7;
  } else {
#line 93
    tmp = 8;
  }
#line 93
  bio->ct = (OPJ_UINT32 )tmp;
#line 94
  if ((OPJ_SIZE_T )bio->bp >= (OPJ_SIZE_T )bio->end) {
#line 95
    return (0);
  }
#line 97
  __cil_tmp3 = bio->bp;
#line 97
  (bio->bp) ++;
#line 97
  bio->buf |= (unsigned int )*__cil_tmp3;
#line 98
  return (1);
}
}
#line 101 "/root/patron/new_21/src/lib/openjp2/bio.c"
void opj_bio_putbit(opj_bio_t *bio , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 102
  if (bio->ct == 0U) {
    {
#line 103
    opj_bio_byteout(bio);
    }
  }
#line 105
  __cil_tmp3 = bio->ct;
#line 105
  (bio->ct) --;
#line 106
  bio->buf |= b << bio->ct;
  return;
}
}
#line 109 "/root/patron/new_21/src/lib/openjp2/bio.c"
OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
#line 110
  if (bio->ct == 0U) {
    {
#line 111
    opj_bio_bytein(bio);
    }
  }
#line 113
  __cil_tmp2 = bio->ct;
#line 113
  (bio->ct) --;
#line 114
  return ((bio->buf >> bio->ct) & 1U);
}
}
#line 123 "/root/patron/new_21/src/lib/openjp2/bio.c"
opj_bio_t *opj_bio_create(void) 
{ 
  opj_bio_t *bio ;
  void *__cil_tmp2 ;

  {
  {
#line 124
  __cil_tmp2 = malloc(sizeof(opj_bio_t ));
#line 124
  bio = (opj_bio_t *)__cil_tmp2;
  }
#line 125
  return (bio);
}
}
#line 128 "/root/patron/new_21/src/lib/openjp2/bio.c"
void opj_bio_destroy(opj_bio_t *bio ) 
{ 


  {
#line 129
  if (bio) {
    {
#line 130
    free(bio);
    }
  }
  return;
}
}
#line 134 "/root/patron/new_21/src/lib/openjp2/bio.c"
ptrdiff_t opj_bio_numbytes(opj_bio_t *bio ) 
{ 


  {
#line 135
  return (bio->bp - bio->start);
}
}
#line 138 "/root/patron/new_21/src/lib/openjp2/bio.c"
void opj_bio_init_enc(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 139
  bio->start = bp;
#line 140
  bio->end = bp + len;
#line 141
  bio->bp = bp;
#line 142
  bio->buf = (OPJ_UINT32 )0;
#line 143
  bio->ct = (OPJ_UINT32 )8;
  return;
}
}
#line 146 "/root/patron/new_21/src/lib/openjp2/bio.c"
void opj_bio_init_dec(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 147
  bio->start = bp;
#line 148
  bio->end = bp + len;
#line 149
  bio->bp = bp;
#line 150
  bio->buf = (OPJ_UINT32 )0;
#line 151
  bio->ct = (OPJ_UINT32 )0;
  return;
}
}
#line 154 "/root/patron/new_21/src/lib/openjp2/bio.c"
void opj_bio_write(opj_bio_t *bio , OPJ_UINT32 v , OPJ_UINT32 n ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp5 ;

  {
#line 156
  i = n - 1U;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < n)) {
#line 156
      goto while_break;
    }
    {
#line 157
    opj_bio_putbit(bio, (v >> i) & 1U);
    }
#line 156
    __cil_tmp5 = i;
#line 156
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 161 "/root/patron/new_21/src/lib/openjp2/bio.c"
OPJ_UINT32 opj_bio_read(opj_bio_t *bio , OPJ_UINT32 n ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 v ;
  OPJ_UINT32 __cil_tmp5 ;
  OPJ_UINT32 __cil_tmp6 ;

  {
#line 164
  v = (OPJ_UINT32 )0;
#line 165
  i = n - 1U;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < n)) {
#line 165
      goto while_break;
    }
    {
#line 166
    __cil_tmp5 = opj_bio_getbit(bio);
    }
#line 166
    v += __cil_tmp5 << i;
#line 165
    __cil_tmp6 = i;
#line 165
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return (v);
}
}
#line 171 "/root/patron/new_21/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_flush(opj_bio_t *bio ) 
{ 
  OPJ_BOOL __cil_tmp2 ;
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 172
  bio->ct = (OPJ_UINT32 )0;
#line 173
  __cil_tmp2 = opj_bio_byteout(bio);
  }
#line 173
  if (! __cil_tmp2) {
#line 174
    return (0);
  }
#line 176
  if (bio->ct == 7U) {
    {
#line 177
    bio->ct = (OPJ_UINT32 )0;
#line 178
    __cil_tmp3 = opj_bio_byteout(bio);
    }
#line 178
    if (! __cil_tmp3) {
#line 179
      return (0);
    }
  }
#line 182
  return (1);
}
}
#line 185 "/root/patron/new_21/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_inalign(opj_bio_t *bio ) 
{ 
  OPJ_BOOL __cil_tmp2 ;

  {
#line 186
  bio->ct = (OPJ_UINT32 )0;
#line 187
  if ((bio->buf & 255U) == 255U) {
    {
#line 188
    __cil_tmp2 = opj_bio_bytein(bio);
    }
#line 188
    if (! __cil_tmp2) {
#line 189
      return (0);
    }
#line 191
    bio->ct = (OPJ_UINT32 )0;
  }
#line 193
  return (1);
}
}
#line 47 "/root/patron/new_21/src/bin/jp2/index.h"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) ;
#line 49 "/root/patron/new_21/src/bin/jp2/index.c"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) 
{ 
  int tileno ;
  int compno ;
  int layno ;
  int resno ;
  int precno ;
  int pack_nb ;
  int x ;
  int y ;
  FILE *stream ;
  double total_disto ;
  int tilepartno ;
  char disto_on ;
  char numpix_on ;
  FILE *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  OPJ_OFF_T start_pos ;
  OPJ_OFF_T end_ph_pos ;
  OPJ_OFF_T end_pos ;
  double disto ;
  int max_numdecompos ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int prec_max ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int prec_max___0 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int numprec ;
  int x0 ;
  double __cil_tmp40 ;
  int y0___15 ;
  double __cil_tmp42 ;
  int x1 ;
  int y1___16 ;
  int pcnx ;
  int pcx ;
  double __cil_tmp47 ;
  int pcy ;
  double __cil_tmp49 ;
  int precno_x ;
  double __cil_tmp51 ;
  int precno_y ;
  double __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int x0___0 ;
  double __cil_tmp62 ;
  int y0___17 ;
  double __cil_tmp64 ;
  int x1___0 ;
  int y1___18 ;
  int max_numprec ;
  int numprec___0 ;
  int __cil_tmp69 ;
  int numprec___1 ;
  int pcnx___0 ;
  int pcx___0 ;
  double __cil_tmp73 ;
  int pcy___0 ;
  double __cil_tmp75 ;
  int precno_x___0 ;
  double __cil_tmp77 ;
  int precno_y___0 ;
  double __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int max_numprec___0 ;
  int numprec___2 ;
  int __cil_tmp89 ;
  int x0___1 ;
  double __cil_tmp91 ;
  int y0___19 ;
  double __cil_tmp93 ;
  int x1___1 ;
  int y1___20 ;
  int numprec___3 ;
  int pcnx___1 ;
  int pcx___1 ;
  double __cil_tmp99 ;
  int pcy___1 ;
  double __cil_tmp101 ;
  int precno_x___1 ;
  double __cil_tmp103 ;
  int precno_y___1 ;
  double __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;

  {
#line 51
  stream = (FILE *)((void *)0);
#line 52
  total_disto = (double )0;
#line 63
  if (! cstr_info) {
#line 64
    return (1);
  }
  {
#line 66
  stream = fopen((char const   *)index___0, "w");
  }
#line 67
  if (! stream) {
    {
#line 68
    fprintf(stderr, "failed to open index file [%s] for writing\n", index___0);
    }
#line 69
    return (1);
  }
#line 72
  if ((cstr_info->tile + 0)->distotile) {
#line 73
    disto_on = (char )1;
  } else {
#line 75
    disto_on = (char )0;
  }
#line 77
  if ((cstr_info->tile + 0)->numpix) {
#line 78
    numpix_on = (char )1;
  } else {
#line 80
    numpix_on = (char )0;
  }
  {
#line 82
  fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
#line 83
  fprintf(stream, "%d\n", (int )cstr_info->prog);
#line 84
  fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
#line 85
  fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
#line 86
  fprintf(stream, "%d\n", cstr_info->numcomps);
#line 87
  fprintf(stream, "%d\n", cstr_info->numlayers);
#line 88
  fprintf(stream, "%d\n", *(cstr_info->numdecompos + 0));
#line 90
  resno = *(cstr_info->numdecompos + 0);
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (resno >= 0)) {
#line 90
      goto while_break;
    }
    {
#line 91
    fprintf(stream, "[%d,%d] \251", 1 << (cstr_info->tile + 0)->pdx[resno], 1 << (cstr_info->tile + 0)->pdx[resno]);
    }
#line 90
    __cil_tmp17 = resno;
#line 90
    resno --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  fprintf(stream, "\n");
#line 97
  fprintf(stream, "%d\n", cstr_info->main_head_start);
#line 99
  fprintf(stream, "%d\n", cstr_info->main_head_end);
#line 100
  fprintf(stream, "%d\n", cstr_info->codestream_size);
#line 102
  fprintf(stream, "\nINFO ON TILES\n");
#line 103
  fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts");
  }
#line 104
  if (disto_on) {
    {
#line 105
    fprintf(stream, "         disto");
    }
  }
#line 106
  if (numpix_on) {
    {
#line 107
    fprintf(stream, "     nbpix");
    }
  }
#line 108
  if ((int )disto_on) {
#line 108
    if ((int )numpix_on) {
      {
#line 109
      fprintf(stream, "  disto/nbpix");
      }
    }
  }
  {
#line 110
  fprintf(stream, "\n");
#line 112
  tileno = 0;
  }
  {
#line 112
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 112
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 112
      goto while_break___0;
    }
    {
#line 113
    fprintf(stream, "%4d %9d %9d %9d %9d", (cstr_info->tile + tileno)->tileno, (cstr_info->tile + tileno)->start_pos,
            (cstr_info->tile + tileno)->end_header, (cstr_info->tile + tileno)->end_pos,
            (cstr_info->tile + tileno)->num_tps);
    }
#line 119
    if (disto_on) {
      {
#line 120
      fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile);
      }
    }
#line 121
    if (numpix_on) {
      {
#line 122
      fprintf(stream, " %9d", (cstr_info->tile + tileno)->numpix);
      }
    }
#line 123
    if ((int )disto_on) {
#line 123
      if ((int )numpix_on) {
        {
#line 124
        fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile / (double )(cstr_info->tile + tileno)->numpix);
        }
      }
    }
    {
#line 125
    fprintf(stream, "\n");
    }
#line 112
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 128
  tileno = 0;
  {
#line 128
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 128
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 128
      goto while_break___1;
    }
#line 130
    disto = (double )0;
#line 131
    max_numdecompos = 0;
#line 132
    pack_nb = 0;
#line 134
    compno = 0;
    {
#line 134
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 134
      if (! (compno < cstr_info->numcomps)) {
#line 134
        goto while_break___2;
      }
#line 135
      if (max_numdecompos < *(cstr_info->numdecompos + compno)) {
#line 136
        max_numdecompos = *(cstr_info->numdecompos + compno);
      }
#line 134
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 139
    fprintf(stream, "\nTILE %d DETAILS\n", tileno);
#line 140
    fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
#line 141
    tilepartno = 0;
    }
    {
#line 141
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 141
      if (! (tilepartno < (cstr_info->tile + tileno)->num_tps)) {
#line 141
        goto while_break___3;
      }
      {
#line 142
      fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n\230\001", tilepartno, tileno,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pack, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_numpacks,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pos, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_header,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_pos);
      }
#line 141
      tilepartno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 151
    if ((int )cstr_info->prog == 0) {
      {
#line 152
      fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos");
      }
#line 153
      if (disto_on) {
        {
#line 154
        fprintf(stream, " disto");
        }
      }
      {
#line 155
      fprintf(stream, "\n");
#line 157
      layno = 0;
      }
      {
#line 157
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 157
        if (! (layno < cstr_info->numlayers)) {
#line 157
          goto while_break___4;
        }
#line 158
        resno = 0;
        {
#line 158
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 158
          if (! (resno < max_numdecompos + 1)) {
#line 158
            goto while_break___5;
          }
#line 159
          compno = 0;
          {
#line 159
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 159
            if (! (compno < cstr_info->numcomps)) {
#line 159
              goto while_break___6;
            }
#line 161
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 162
              goto while_break___6;
            }
#line 163
            prec_max = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 164
            precno = 0;
            {
#line 164
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 164
              if (! (precno < prec_max)) {
#line 164
                goto while_break___7;
              }
              {
#line 165
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 166
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 167
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 168
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 169
              fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6ld     %6ld %7ld", pack_nb,
                      tileno, layno, resno, compno, precno, start_pos, end_ph_pos,
                      end_pos);
              }
#line 171
              if (disto_on) {
                {
#line 172
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 173
              fprintf(stream, "\n");
#line 174
              total_disto += disto;
#line 175
              pack_nb ++;
              }
#line 164
              precno ++;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 159
            compno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 158
          resno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 157
        layno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else
#line 182
    if ((int )cstr_info->prog == 1) {
      {
#line 183
      fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
      }
#line 184
      if (disto_on) {
        {
#line 185
        fprintf(stream, " disto");
        }
      }
      {
#line 186
      fprintf(stream, "\n");
#line 188
      resno = 0;
      }
      {
#line 188
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 188
        if (! (resno < max_numdecompos + 1)) {
#line 188
          goto while_break___8;
        }
#line 189
        layno = 0;
        {
#line 189
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 189
          if (! (layno < cstr_info->numlayers)) {
#line 189
            goto while_break___9;
          }
#line 190
          compno = 0;
          {
#line 190
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 190
            if (! (compno < cstr_info->numcomps)) {
#line 190
              goto while_break___10;
            }
#line 192
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 193
              goto while_break___10;
            }
#line 194
            prec_max___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 195
            precno = 0;
            {
#line 195
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 195
              if (! (precno < prec_max___0)) {
#line 195
                goto while_break___11;
              }
              {
#line 196
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 197
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 198
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 199
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 200
              fprintf(stream, "%4d %6d %5d %7d %6d %6d %9ld   %9ld %7ld\230\001",
                      pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos,
                      end_pos);
              }
#line 202
              if (disto_on) {
                {
#line 203
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 204
              fprintf(stream, "\n");
#line 205
              total_disto += disto;
#line 206
              pack_nb ++;
              }
#line 195
              precno ++;
            }
            while_break___11: /* CIL Label */ ;
            }
#line 190
            compno ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 189
          layno ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 188
        resno ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else
#line 213
    if ((int )cstr_info->prog == 2) {
      {
#line 215
      fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos");
      }
#line 216
      if (disto_on) {
        {
#line 217
        fprintf(stream, " disto");
        }
      }
      {
#line 218
      fprintf(stream, "\n");
#line 220
      resno = 0;
      }
      {
#line 220
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 220
        if (! (resno < max_numdecompos + 1)) {
#line 220
          goto while_break___12;
        }
#line 221
        numprec = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 222
        precno = 0;
        {
#line 222
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 222
          if (! (precno < numprec)) {
#line 222
            goto while_break___13;
          }
          {
#line 224
          __cil_tmp40 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 224
          x0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp40 * cstr_info->tw) * cstr_info->tile_x;
#line 225
          __cil_tmp42 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 225
          y0___15 = cstr_info->tile_Ox + (int )__cil_tmp42 * cstr_info->tile_y;
#line 226
          x1 = x0 + cstr_info->tile_x;
#line 227
          y1___16 = y0___15 + cstr_info->tile_y;
#line 228
          compno = 0;
          }
          {
#line 228
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 228
            if (! (compno < cstr_info->numcomps)) {
#line 228
              goto while_break___14;
            }
            {
#line 229
            pcnx = (cstr_info->tile + tileno)->pw[resno];
#line 230
            __cil_tmp47 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 230
            pcx = (int )__cil_tmp47;
#line 231
            __cil_tmp49 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 231
            pcy = (int )__cil_tmp49;
#line 232
            __cil_tmp51 = floor((double )((float )precno / (float )pcnx));
#line 232
            precno_x = precno - (int )__cil_tmp51 * pcnx;
#line 233
            __cil_tmp53 = floor((double )((float )precno / (float )pcnx));
#line 233
            precno_y = (int )__cil_tmp53;
            }
#line 234
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 235
              goto while_break___14;
            }
#line 236
            y = y0___15;
            {
#line 236
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 236
              if (! (y < y1___16)) {
#line 236
                goto while_break___15;
              }
#line 237
              if (precno_y * pcy == y) {
#line 238
                x = x0;
                {
#line 238
                while (1) {
                  while_continue___16: /* CIL Label */ ;
#line 238
                  if (! (x < x1)) {
#line 238
                    goto while_break___16;
                  }
#line 239
                  if (precno_x * pcx == x) {
#line 240
                    layno = 0;
                    {
#line 240
                    while (1) {
                      while_continue___17: /* CIL Label */ ;
#line 240
                      if (! (layno < cstr_info->numlayers)) {
#line 240
                        goto while_break___17;
                      }
                      {
#line 241
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 242
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 243
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 244
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 245
                      fprintf(stream, "%4d %6d %5d %6d %6d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno, resno, precno, compno, layno, start_pos,
                              end_ph_pos, end_pos);
                      }
#line 247
                      if (disto_on) {
                        {
#line 248
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 249
                      fprintf(stream, "\n");
#line 250
                      total_disto += disto;
#line 251
                      pack_nb ++;
                      }
#line 240
                      layno ++;
                    }
                    while_break___17: /* CIL Label */ ;
                    }
                  }
#line 238
                  x ++;
                }
                while_break___16: /* CIL Label */ ;
                }
              }
#line 236
              y ++;
            }
            while_break___15: /* CIL Label */ ;
            }
#line 228
            compno ++;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 222
          precno ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 220
        resno ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    } else
#line 262
    if ((int )cstr_info->prog == 3) {
      {
#line 264
      __cil_tmp62 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 264
      x0___0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp62 * cstr_info->tw) * cstr_info->tile_x;
#line 265
      __cil_tmp64 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 265
      y0___17 = cstr_info->tile_Ox + (int )__cil_tmp64 * cstr_info->tile_y;
#line 266
      x1___0 = x0___0 + cstr_info->tile_x;
#line 267
      y1___18 = y0___17 + cstr_info->tile_y;
#line 270
      max_numprec = 0;
#line 271
      resno = 0;
      }
      {
#line 271
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 271
        if (! (resno < max_numdecompos + 1)) {
#line 271
          goto while_break___18;
        }
#line 272
        numprec___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 273
        if (numprec___0 > max_numprec) {
#line 274
          max_numprec = numprec___0;
        }
#line 271
        resno ++;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 277
      fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos");
      }
#line 278
      if (disto_on) {
        {
#line 279
        fprintf(stream, " disto");
        }
      }
      {
#line 280
      fprintf(stream, "\n");
#line 282
      precno = 0;
      }
      {
#line 282
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 282
        if (! (precno < max_numprec)) {
#line 282
          goto while_break___19;
        }
#line 283
        compno = 0;
        {
#line 283
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 283
          if (! (compno < cstr_info->numcomps)) {
#line 283
            goto while_break___20;
          }
#line 284
          resno = 0;
          {
#line 284
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 284
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 284
              goto while_break___21;
            }
            {
#line 285
            numprec___1 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 286
            pcnx___0 = (cstr_info->tile + tileno)->pw[resno];
#line 287
            __cil_tmp73 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 287
            pcx___0 = (int )__cil_tmp73;
#line 288
            __cil_tmp75 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 288
            pcy___0 = (int )__cil_tmp75;
#line 289
            __cil_tmp77 = floor((double )((float )precno / (float )pcnx___0));
#line 289
            precno_x___0 = precno - (int )__cil_tmp77 * pcnx___0;
#line 290
            __cil_tmp79 = floor((double )((float )precno / (float )pcnx___0));
#line 290
            precno_y___0 = (int )__cil_tmp79;
            }
#line 291
            if (precno >= numprec___1) {
#line 292
              goto while_continue___21;
            }
#line 293
            y = y0___17;
            {
#line 293
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 293
              if (! (y < y1___18)) {
#line 293
                goto while_break___22;
              }
#line 294
              if (precno_y___0 * pcy___0 == y) {
#line 295
                x = x0___0;
                {
#line 295
                while (1) {
                  while_continue___23: /* CIL Label */ ;
#line 295
                  if (! (x < x1___0)) {
#line 295
                    goto while_break___23;
                  }
#line 296
                  if (precno_x___0 * pcx___0 == x) {
#line 297
                    layno = 0;
                    {
#line 297
                    while (1) {
                      while_continue___24: /* CIL Label */ ;
#line 297
                      if (! (layno < cstr_info->numlayers)) {
#line 297
                        goto while_break___24;
                      }
                      {
#line 298
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 299
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 300
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 301
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 302
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno, precno, compno, resno, layno, start_pos,
                              end_ph_pos, end_pos);
                      }
#line 304
                      if (disto_on) {
                        {
#line 305
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 306
                      fprintf(stream, "\n");
#line 307
                      total_disto += disto;
#line 308
                      pack_nb ++;
                      }
#line 297
                      layno ++;
                    }
                    while_break___24: /* CIL Label */ ;
                    }
                  }
#line 295
                  x ++;
                }
                while_break___23: /* CIL Label */ ;
                }
              }
#line 293
              y ++;
            }
            while_break___22: /* CIL Label */ ;
            }
#line 284
            resno ++;
          }
          while_break___21: /* CIL Label */ ;
          }
#line 283
          compno ++;
        }
        while_break___20: /* CIL Label */ ;
        }
#line 282
        precno ++;
      }
      while_break___19: /* CIL Label */ ;
      }
    } else {
#line 321
      max_numprec___0 = 0;
#line 322
      resno = 0;
      {
#line 322
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 322
        if (! (resno < max_numdecompos + 1)) {
#line 322
          goto while_break___25;
        }
#line 323
        numprec___2 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 324
        if (numprec___2 > max_numprec___0) {
#line 325
          max_numprec___0 = numprec___2;
        }
#line 322
        resno ++;
      }
      while_break___25: /* CIL Label */ ;
      }
      {
#line 328
      fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos");
      }
#line 329
      if (disto_on) {
        {
#line 330
        fprintf(stream, " disto");
        }
      }
      {
#line 331
      fprintf(stream, "\n");
#line 333
      compno = 0;
      }
      {
#line 333
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 333
        if (! (compno < cstr_info->numcomps)) {
#line 333
          goto while_break___26;
        }
        {
#line 335
        __cil_tmp91 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 335
        x0___1 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp91 * cstr_info->tw) * cstr_info->tile_x;
#line 336
        __cil_tmp93 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 336
        y0___19 = cstr_info->tile_Ox + (int )__cil_tmp93 * cstr_info->tile_y;
#line 337
        x1___1 = x0___1 + cstr_info->tile_x;
#line 338
        y1___20 = y0___19 + cstr_info->tile_y;
#line 340
        precno = 0;
        }
        {
#line 340
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 340
          if (! (precno < max_numprec___0)) {
#line 340
            goto while_break___27;
          }
#line 341
          resno = 0;
          {
#line 341
          while (1) {
            while_continue___28: /* CIL Label */ ;
#line 341
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 341
              goto while_break___28;
            }
            {
#line 342
            numprec___3 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 343
            pcnx___1 = (cstr_info->tile + tileno)->pw[resno];
#line 344
            __cil_tmp99 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 344
            pcx___1 = (int )__cil_tmp99;
#line 345
            __cil_tmp101 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 345
            pcy___1 = (int )__cil_tmp101;
#line 346
            __cil_tmp103 = floor((double )((float )precno / (float )pcnx___1));
#line 346
            precno_x___1 = precno - (int )__cil_tmp103 * pcnx___1;
#line 347
            __cil_tmp105 = floor((double )((float )precno / (float )pcnx___1));
#line 347
            precno_y___1 = (int )__cil_tmp105;
            }
#line 348
            if (precno >= numprec___3) {
#line 349
              goto while_continue___28;
            }
#line 351
            y = y0___19;
            {
#line 351
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 351
              if (! (y < y1___20)) {
#line 351
                goto while_break___29;
              }
#line 352
              if (precno_y___1 * pcy___1 == y) {
#line 353
                x = x0___1;
                {
#line 353
                while (1) {
                  while_continue___30: /* CIL Label */ ;
#line 353
                  if (! (x < x1___1)) {
#line 353
                    goto while_break___30;
                  }
#line 354
                  if (precno_x___1 * pcx___1 == x) {
#line 355
                    layno = 0;
                    {
#line 355
                    while (1) {
                      while_continue___31: /* CIL Label */ ;
#line 355
                      if (! (layno < cstr_info->numlayers)) {
#line 355
                        goto while_break___31;
                      }
                      {
#line 356
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 357
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 358
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 359
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 360
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno, compno, precno, resno, layno, start_pos,
                              end_ph_pos, end_pos);
                      }
#line 362
                      if (disto_on) {
                        {
#line 363
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 364
                      fprintf(stream, "\n");
#line 365
                      total_disto += disto;
#line 366
                      pack_nb ++;
                      }
#line 355
                      layno ++;
                    }
                    while_break___31: /* CIL Label */ ;
                    }
                  }
#line 353
                  x ++;
                }
                while_break___30: /* CIL Label */ ;
                }
              }
#line 351
              y ++;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 341
            resno ++;
          }
          while_break___28: /* CIL Label */ ;
          }
#line 340
          precno ++;
        }
        while_break___27: /* CIL Label */ ;
        }
#line 333
        compno ++;
      }
      while_break___26: /* CIL Label */ ;
      }
    }
#line 128
    tileno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 378
  if (disto_on) {
    {
#line 379
    fprintf(stream, "%8e\n", cstr_info->D_max);
#line 380
    fprintf(stream, "%.8e\n", total_disto);
    }
  }
#line 384
  if (cstr_info->marknum) {
    {
#line 385
    fprintf(stream, "\nMARKER LIST\n");
#line 386
    fprintf(stream, "%d\n", cstr_info->marknum);
#line 387
    fprintf(stream, "type\tstart_pos    length\n");
#line 388
    x = 0;
    }
    {
#line 388
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 388
      if (! (x < cstr_info->marknum)) {
#line 388
        goto while_break___32;
      }
      {
#line 389
      fprintf(stream, "%X\t%9ld %9d\n\230\001", (int )(cstr_info->marker + x)->type,
              (cstr_info->marker + x)->pos, (cstr_info->marker + x)->len);
      }
#line 388
      x ++;
    }
    while_break___32: /* CIL Label */ ;
    }
  }
  {
#line 392
  fclose(stream);
#line 394
  fprintf(stderr, "Generated index file %s\n\230\001", index___0);
  }
#line 396
  return (0);
}
}
#line 281 "/usr/include/x86_64-linux-gnu/tiffio.h"
extern char const   *TIFFGetVersion(void) ;
#line 283
extern TIFFCodec *TIFFFindCODEC(uint16  ) ;
#line 284
extern TIFFCodec *TIFFRegisterCODEC(uint16  , char const   * , TIFFInitMethod  ) ;
#line 285
extern void TIFFUnRegisterCODEC(TIFFCodec * ) ;
#line 286
extern int TIFFIsCODECConfigured(uint16  ) ;
#line 287
extern TIFFCodec *TIFFGetConfiguredCODECs(void) ;
#line 293
extern void *_TIFFmalloc(tmsize_t s ) ;
#line 294
extern void *_TIFFcalloc(tmsize_t nmemb , tmsize_t siz ) ;
#line 295
extern void *_TIFFrealloc(void *p , tmsize_t s ) ;
#line 296
extern void _TIFFmemset(void *p , int v , tmsize_t c ) ;
#line 297
extern void _TIFFmemcpy(void *d , void const   *s , tmsize_t c ) ;
#line 298
extern int _TIFFmemcmp(void const   *p1 , void const   *p2 , tmsize_t c ) ;
#line 299
extern void _TIFFfree(void *p ) ;
#line 304
extern int TIFFGetTagListCount(TIFF * ) ;
#line 305
extern uint32 TIFFGetTagListEntry(TIFF * , int tag_index ) ;
#line 317
extern TIFFField *TIFFFindField(TIFF * , uint32  , TIFFDataType  ) ;
#line 318
extern TIFFField *TIFFFieldWithTag(TIFF * , uint32  ) ;
#line 319
extern TIFFField *TIFFFieldWithName(TIFF * , char const   * ) ;
#line 321
extern uint32 TIFFFieldTag(TIFFField * ) ;
#line 322
extern char const   *TIFFFieldName(TIFFField * ) ;
#line 323
extern TIFFDataType TIFFFieldDataType(TIFFField * ) ;
#line 324
extern int TIFFFieldPassCount(TIFFField * ) ;
#line 325
extern int TIFFFieldReadCount(TIFFField * ) ;
#line 326
extern int TIFFFieldWriteCount(TIFFField * ) ;
#line 338
extern TIFFTagMethods *TIFFAccessTagMethods(TIFF * ) ;
#line 339
extern void *TIFFGetClientInfo(TIFF * , char const   * ) ;
#line 340
extern void TIFFSetClientInfo(TIFF * , void * , char const   * ) ;
#line 342
extern void TIFFCleanup(TIFF *tif ) ;
#line 343
extern void TIFFClose(TIFF *tif ) ;
#line 344
extern int TIFFFlush(TIFF *tif ) ;
#line 345
extern int TIFFFlushData(TIFF *tif ) ;
#line 346
extern int TIFFGetField(TIFF *tif , uint32 tag  , ...) ;
#line 347
extern int TIFFVGetField(TIFF *tif , uint32 tag , va_list ap ) ;
#line 348
extern int TIFFGetFieldDefaulted(TIFF *tif , uint32 tag  , ...) ;
#line 349
extern int TIFFVGetFieldDefaulted(TIFF *tif , uint32 tag , va_list ap ) ;
#line 350
extern int TIFFReadDirectory(TIFF *tif ) ;
#line 351
extern int TIFFReadCustomDirectory(TIFF *tif , toff_t diroff , TIFFFieldArray *infoarray ) ;
#line 352
extern int TIFFReadEXIFDirectory(TIFF *tif , toff_t diroff ) ;
#line 353
extern uint64 TIFFScanlineSize64(TIFF *tif ) ;
#line 354
extern tmsize_t TIFFScanlineSize(TIFF *tif ) ;
#line 355
extern uint64 TIFFRasterScanlineSize64(TIFF *tif ) ;
#line 356
extern tmsize_t TIFFRasterScanlineSize(TIFF *tif ) ;
#line 357
extern uint64 TIFFStripSize64(TIFF *tif ) ;
#line 358
extern tmsize_t TIFFStripSize(TIFF *tif ) ;
#line 359
extern uint64 TIFFRawStripSize64(TIFF *tif , uint32 strip ) ;
#line 360
extern tmsize_t TIFFRawStripSize(TIFF *tif , uint32 strip ) ;
#line 361
extern uint64 TIFFVStripSize64(TIFF *tif , uint32 nrows ) ;
#line 362
extern tmsize_t TIFFVStripSize(TIFF *tif , uint32 nrows ) ;
#line 363
extern uint64 TIFFTileRowSize64(TIFF *tif ) ;
#line 364
extern tmsize_t TIFFTileRowSize(TIFF *tif ) ;
#line 365
extern uint64 TIFFTileSize64(TIFF *tif ) ;
#line 366
extern tmsize_t TIFFTileSize(TIFF *tif ) ;
#line 367
extern uint64 TIFFVTileSize64(TIFF *tif , uint32 nrows ) ;
#line 368
extern tmsize_t TIFFVTileSize(TIFF *tif , uint32 nrows ) ;
#line 369
extern uint32 TIFFDefaultStripSize(TIFF *tif , uint32 request ) ;
#line 370
extern void TIFFDefaultTileSize(TIFF * , uint32 * , uint32 * ) ;
#line 371
extern int TIFFFileno(TIFF * ) ;
#line 372
extern int TIFFSetFileno(TIFF * , int  ) ;
#line 373
extern thandle_t TIFFClientdata(TIFF * ) ;
#line 374
extern thandle_t TIFFSetClientdata(TIFF * , thandle_t  ) ;
#line 375
extern int TIFFGetMode(TIFF * ) ;
#line 376
extern int TIFFSetMode(TIFF * , int  ) ;
#line 377
extern int TIFFIsTiled(TIFF * ) ;
#line 378
extern int TIFFIsByteSwapped(TIFF * ) ;
#line 379
extern int TIFFIsUpSampled(TIFF * ) ;
#line 380
extern int TIFFIsMSB2LSB(TIFF * ) ;
#line 381
extern int TIFFIsBigEndian(TIFF * ) ;
#line 382
extern TIFFReadWriteProc TIFFGetReadProc(TIFF * ) ;
#line 383
extern TIFFReadWriteProc TIFFGetWriteProc(TIFF * ) ;
#line 384
extern TIFFSeekProc TIFFGetSeekProc(TIFF * ) ;
#line 385
extern TIFFCloseProc TIFFGetCloseProc(TIFF * ) ;
#line 386
extern TIFFSizeProc TIFFGetSizeProc(TIFF * ) ;
#line 387
extern TIFFMapFileProc TIFFGetMapFileProc(TIFF * ) ;
#line 388
extern TIFFUnmapFileProc TIFFGetUnmapFileProc(TIFF * ) ;
#line 389
extern uint32 TIFFCurrentRow(TIFF * ) ;
#line 390
extern uint16 TIFFCurrentDirectory(TIFF * ) ;
#line 391
extern uint16 TIFFNumberOfDirectories(TIFF * ) ;
#line 392
extern uint64 TIFFCurrentDirOffset(TIFF * ) ;
#line 393
extern uint32 TIFFCurrentStrip(TIFF * ) ;
#line 394
extern uint32 TIFFCurrentTile(TIFF *tif ) ;
#line 395
extern int TIFFReadBufferSetup(TIFF *tif , void *bp , tmsize_t size ) ;
#line 396
extern int TIFFWriteBufferSetup(TIFF *tif , void *bp , tmsize_t size ) ;
#line 397
extern int TIFFSetupStrips(TIFF * ) ;
#line 398
extern int TIFFWriteCheck(TIFF * , int  , char const   * ) ;
#line 399
extern void TIFFFreeDirectory(TIFF * ) ;
#line 400
extern int TIFFCreateDirectory(TIFF * ) ;
#line 401
extern int TIFFCreateCustomDirectory(TIFF * , TIFFFieldArray * ) ;
#line 402
extern int TIFFCreateEXIFDirectory(TIFF * ) ;
#line 403
extern int TIFFLastDirectory(TIFF * ) ;
#line 404
extern int TIFFSetDirectory(TIFF * , uint16  ) ;
#line 405
extern int TIFFSetSubDirectory(TIFF * , uint64  ) ;
#line 406
extern int TIFFUnlinkDirectory(TIFF * , uint16  ) ;
#line 407
extern int TIFFSetField(TIFF * , uint32   , ...) ;
#line 408
extern int TIFFVSetField(TIFF * , uint32  , va_list  ) ;
#line 409
extern int TIFFUnsetField(TIFF * , uint32  ) ;
#line 410
extern int TIFFWriteDirectory(TIFF * ) ;
#line 411
extern int TIFFWriteCustomDirectory(TIFF * , uint64 * ) ;
#line 412
extern int TIFFCheckpointDirectory(TIFF * ) ;
#line 413
extern int TIFFRewriteDirectory(TIFF * ) ;
#line 414
extern int TIFFDeferStrileArrayWriting(TIFF * ) ;
#line 415
extern int TIFFForceStrileArrayWriting(TIFF * ) ;
#line 425
extern void TIFFPrintDirectory(TIFF * , FILE * , long  ) ;
#line 426
extern int TIFFReadScanline(TIFF *tif , void *buf , uint32 row , uint16 sample ) ;
#line 427
extern int TIFFWriteScanline(TIFF *tif , void *buf , uint32 row , uint16 sample ) ;
#line 428
extern int TIFFReadRGBAImage(TIFF * , uint32  , uint32  , uint32 * , int  ) ;
#line 429
extern int TIFFReadRGBAImageOriented(TIFF * , uint32  , uint32  , uint32 * , int  ,
                                     int  ) ;
#line 432
extern int TIFFReadRGBAStrip(TIFF * , uint32  , uint32 * ) ;
#line 433
extern int TIFFReadRGBATile(TIFF * , uint32  , uint32  , uint32 * ) ;
#line 434
extern int TIFFReadRGBAStripExt(TIFF * , uint32  , uint32 * , int stop_on_error ) ;
#line 435
extern int TIFFReadRGBATileExt(TIFF * , uint32  , uint32  , uint32 * , int stop_on_error ) ;
#line 436
extern int TIFFRGBAImageOK(TIFF * , char [1024] ) ;
#line 437
extern int TIFFRGBAImageBegin(TIFFRGBAImage * , TIFF * , int  , char [1024] ) ;
#line 438
extern int TIFFRGBAImageGet(TIFFRGBAImage * , uint32 * , uint32  , uint32  ) ;
#line 439
extern void TIFFRGBAImageEnd(TIFFRGBAImage * ) ;
#line 440
extern TIFF *TIFFOpen(char const   * , char const   * ) ;
#line 444
extern TIFF *TIFFFdOpen(int  , char const   * , char const   * ) ;
#line 445
extern TIFF *TIFFClientOpen(char const   * , char const   * , thandle_t  , TIFFReadWriteProc  ,
                            TIFFReadWriteProc  , TIFFSeekProc  , TIFFCloseProc  ,
                            TIFFSizeProc  , TIFFMapFileProc  , TIFFUnmapFileProc  ) ;
#line 451
extern char const   *TIFFFileName(TIFF * ) ;
#line 452
extern char const   *TIFFSetFileName(TIFF * , char const   * ) ;
#line 453
extern void TIFFError(char const   * , char const   *  , ...) ;
#line 454
extern void TIFFErrorExt(thandle_t  , char const   * , char const   *  , ...) ;
#line 455
extern void TIFFWarning(char const   * , char const   *  , ...) ;
#line 456
extern void TIFFWarningExt(thandle_t  , char const   * , char const   *  , ...) ;
#line 457
extern TIFFErrorHandler TIFFSetErrorHandler(TIFFErrorHandler  ) ;
#line 458
extern TIFFErrorHandlerExt TIFFSetErrorHandlerExt(TIFFErrorHandlerExt  ) ;
#line 459
extern TIFFErrorHandler TIFFSetWarningHandler(TIFFErrorHandler  ) ;
#line 460
extern TIFFErrorHandlerExt TIFFSetWarningHandlerExt(TIFFErrorHandlerExt  ) ;
#line 461
extern TIFFExtendProc TIFFSetTagExtender(TIFFExtendProc  ) ;
#line 462
extern uint32 TIFFComputeTile(TIFF *tif , uint32 x , uint32 y , uint32 z , uint16 s ) ;
#line 463
extern int TIFFCheckTile(TIFF *tif , uint32 x , uint32 y , uint32 z , uint16 s ) ;
#line 464
extern uint32 TIFFNumberOfTiles(TIFF * ) ;
#line 465
extern tmsize_t TIFFReadTile(TIFF *tif , void *buf , uint32 x , uint32 y , uint32 z ,
                             uint16 s ) ;
#line 466
extern tmsize_t TIFFWriteTile(TIFF *tif , void *buf , uint32 x , uint32 y , uint32 z ,
                              uint16 s ) ;
#line 467
extern uint32 TIFFComputeStrip(TIFF * , uint32  , uint16  ) ;
#line 468
extern uint32 TIFFNumberOfStrips(TIFF * ) ;
#line 469
extern tmsize_t TIFFReadEncodedStrip(TIFF *tif , uint32 strip , void *buf , tmsize_t size ) ;
#line 470
extern tmsize_t TIFFReadRawStrip(TIFF *tif , uint32 strip , void *buf , tmsize_t size ) ;
#line 471
extern tmsize_t TIFFReadEncodedTile(TIFF *tif , uint32 tile , void *buf , tmsize_t size ) ;
#line 472
extern tmsize_t TIFFReadRawTile(TIFF *tif , uint32 tile , void *buf , tmsize_t size ) ;
#line 473
extern int TIFFReadFromUserBuffer(TIFF *tif , uint32 strile , void *inbuf , tmsize_t insize ,
                                  void *outbuf , tmsize_t outsize ) ;
#line 476
extern tmsize_t TIFFWriteEncodedStrip(TIFF *tif , uint32 strip , void *data , tmsize_t cc ) ;
#line 477
extern tmsize_t TIFFWriteRawStrip(TIFF *tif , uint32 strip , void *data , tmsize_t cc ) ;
#line 478
extern tmsize_t TIFFWriteEncodedTile(TIFF *tif , uint32 tile , void *data , tmsize_t cc ) ;
#line 479
extern tmsize_t TIFFWriteRawTile(TIFF *tif , uint32 tile , void *data , tmsize_t cc ) ;
#line 480
extern int TIFFDataWidth(TIFFDataType  ) ;
#line 481
extern void TIFFSetWriteOffset(TIFF *tif , toff_t off ) ;
#line 482
extern void TIFFSwabShort(uint16 * ) ;
#line 483
extern void TIFFSwabLong(uint32 * ) ;
#line 484
extern void TIFFSwabLong8(uint64 * ) ;
#line 485
extern void TIFFSwabFloat(float * ) ;
#line 486
extern void TIFFSwabDouble(double * ) ;
#line 487
extern void TIFFSwabArrayOfShort(uint16 *wp , tmsize_t n ) ;
#line 488
extern void TIFFSwabArrayOfTriples(uint8 *tp , tmsize_t n ) ;
#line 489
extern void TIFFSwabArrayOfLong(uint32 *lp , tmsize_t n ) ;
#line 490
extern void TIFFSwabArrayOfLong8(uint64 *lp , tmsize_t n ) ;
#line 491
extern void TIFFSwabArrayOfFloat(float *fp , tmsize_t n ) ;
#line 492
extern void TIFFSwabArrayOfDouble(double *dp , tmsize_t n ) ;
#line 493
extern void TIFFReverseBits(uint8 *cp , tmsize_t n ) ;
#line 494
extern unsigned char const   *TIFFGetBitRevTable(int  ) ;
#line 496
extern uint64 TIFFGetStrileOffset(TIFF *tif , uint32 strile ) ;
#line 497
extern uint64 TIFFGetStrileByteCount(TIFF *tif , uint32 strile ) ;
#line 498
extern uint64 TIFFGetStrileOffsetWithErr(TIFF *tif , uint32 strile , int *pbErr ) ;
#line 499
extern uint64 TIFFGetStrileByteCountWithErr(TIFF *tif , uint32 strile , int *pbErr ) ;
#line 505
extern double LogL16toY(int  ) ;
#line 506
extern double LogL10toY(int  ) ;
#line 507
extern void XYZtoRGB24(float * , uint8 * ) ;
#line 508
extern int uv_decode(double * , double * , int  ) ;
#line 509
extern void LogLuv24toXYZ(uint32  , float * ) ;
#line 510
extern void LogLuv32toXYZ(uint32  , float * ) ;
#line 518
extern int LogL16fromY(double  , int  ) ;
#line 519
extern int LogL10fromY(double  , int  ) ;
#line 520
extern int uv_encode(double  , double  , int  ) ;
#line 521
extern uint32 LogLuv24fromXYZ(float * , int  ) ;
#line 522
extern uint32 LogLuv32fromXYZ(float * , int  ) ;
#line 526
extern int TIFFCIELabToRGBInit(TIFFCIELabToRGB * , TIFFDisplay * , float * ) ;
#line 527
extern void TIFFCIELabToXYZ(TIFFCIELabToRGB * , uint32  , int32  , int32  , float * ,
                            float * , float * ) ;
#line 529
extern void TIFFXYZToRGB(TIFFCIELabToRGB * , float  , float  , float  , uint32 * ,
                         uint32 * , uint32 * ) ;
#line 532
extern int TIFFYCbCrToRGBInit(TIFFYCbCrToRGB * , float * , float * ) ;
#line 533
extern void TIFFYCbCrtoRGB(TIFFYCbCrToRGB * , uint32  , int32  , int32  , uint32 * ,
                           uint32 * , uint32 * ) ;
#line 553
extern int TIFFMergeFieldInfo(TIFF * , TIFFFieldInfo [] , uint32  ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type ) ;
#line 304
extern  __attribute__((__nothrow__)) int faccessat(int __fd , char const   *__file ,
                                                   int __type , int __flag ) ;
#line 334
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 376
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 384
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
#line 417
extern  __attribute__((__nothrow__)) int pipe(int __pipedes[2] ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 452
extern  __attribute__((__nothrow__)) __useconds_t ualarm(__useconds_t __value , __useconds_t __interval ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 469
extern int pause(void) ;
#line 473
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group ) ;
#line 478
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 483
extern  __attribute__((__nothrow__)) int lchown(char const   *__file , __uid_t __owner ,
                                                __gid_t __group ) ;
#line 491
extern  __attribute__((__nothrow__)) int fchownat(int __fd , char const   *__file ,
                                                  __uid_t __owner , __gid_t __group ,
                                                  int __flag ) ;
#line 497
extern  __attribute__((__nothrow__)) int chdir(char const   *__path ) ;
#line 501
extern  __attribute__((__nothrow__)) int fchdir(int __fd ) ;
#line 511
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 525
extern  __attribute__((__nothrow__)) char *getwd(char *__buf ) ;
#line 531
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 543
extern char **__environ ;
#line 551
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  __argv[] ,
                                                char * const  __envp[] ) ;
#line 557
extern  __attribute__((__nothrow__)) int fexecve(int __fd , char * const  __argv[] ,
                                                 char * const  __envp[] ) ;
#line 563
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  __argv[] ) ;
#line 568
extern  __attribute__((__nothrow__)) int execle(char const   *__path , char const   *__arg 
                                                , ...) ;
#line 573
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...) ;
#line 578
extern  __attribute__((__nothrow__)) int execvp(char const   *__file , char * const  __argv[] ) ;
#line 584
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...) ;
#line 598
extern  __attribute__((__nothrow__)) int nice(int __inc ) ;
#line 603
extern void _exit(int __status ) ;
#line 612
extern  __attribute__((__nothrow__)) long pathconf(char const   *__path , int __name ) ;
#line 616
extern  __attribute__((__nothrow__)) long fpathconf(int __fd , int __name ) ;
#line 619
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 623
extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf , size_t __len ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 637
extern  __attribute__((__nothrow__)) __pid_t __getpgid(__pid_t __pid ) ;
#line 639
extern  __attribute__((__nothrow__)) __pid_t getpgid(__pid_t __pid ) ;
#line 646
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 660
extern  __attribute__((__nothrow__)) int setpgrp(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 671
extern  __attribute__((__nothrow__)) __pid_t getsid(__pid_t __pid ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 689
extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] ) ;
#line 700
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 705
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 710
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 722
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 727
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 764
extern  __attribute__((__nothrow__)) int vfork(void) ;
#line 770
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 774
extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf , size_t __buflen ) ;
#line 779
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 784
extern  __attribute__((__nothrow__)) int ttyslot(void) ;
#line 789
extern  __attribute__((__nothrow__)) int link(char const   *__from , char const   *__to ) ;
#line 795
extern  __attribute__((__nothrow__)) int linkat(int __fromfd , char const   *__from ,
                                                int __tofd , char const   *__to ,
                                                int __flags ) ;
#line 802
extern  __attribute__((__nothrow__)) int symlink(char const   *__from , char const   *__to ) ;
#line 808
extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path , char *__buf ,
                                                      size_t __len ) ;
#line 815
extern  __attribute__((__nothrow__)) int symlinkat(char const   *__from , int __tofd ,
                                                   char const   *__to ) ;
#line 819
extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                        char *__buf , size_t __len ) ;
#line 825
extern  __attribute__((__nothrow__)) int unlink(char const   *__name ) ;
#line 829
extern  __attribute__((__nothrow__)) int unlinkat(int __fd , char const   *__name ,
                                                  int __flag ) ;
#line 834
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path ) ;
#line 838
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 841
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
#line 848
extern char *getlogin(void) ;
#line 856
extern int getlogin_r(char *__name , size_t __name_len ) ;
#line 861
extern  __attribute__((__nothrow__)) int setlogin(char const   *__name ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 55
extern int opterr ;
#line 59
extern int optopt ;
#line 91
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 877 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len ) ;
#line 884
extern  __attribute__((__nothrow__)) int sethostname(char const   *__name , size_t __len ) ;
#line 889
extern  __attribute__((__nothrow__)) int sethostid(long __id ) ;
#line 895
extern  __attribute__((__nothrow__)) int getdomainname(char *__name , size_t __len ) ;
#line 897
extern  __attribute__((__nothrow__)) int setdomainname(char const   *__name , size_t __len ) ;
#line 904
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 907
extern  __attribute__((__nothrow__)) int revoke(char const   *__file ) ;
#line 915
extern  __attribute__((__nothrow__)) int profil(unsigned short *__sample_buffer ,
                                                size_t __size , size_t __offset ,
                                                unsigned int __scale ) ;
#line 923
extern  __attribute__((__nothrow__)) int acct(char const   *__name ) ;
#line 927
extern  __attribute__((__nothrow__)) char *getusershell(void) ;
#line 928
extern  __attribute__((__nothrow__)) void endusershell(void) ;
#line 929
extern  __attribute__((__nothrow__)) void setusershell(void) ;
#line 935
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 942
extern  __attribute__((__nothrow__)) int chroot(char const   *__path ) ;
#line 946
extern char *getpass(char const   *__prompt ) ;
#line 954
extern int fsync(int __fd ) ;
#line 967
extern long gethostid(void) ;
#line 970
extern  __attribute__((__nothrow__)) void sync(void) ;
#line 976
extern  __attribute__((__nothrow__)) int getpagesize(void) ;
#line 981
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 991
extern  __attribute__((__nothrow__)) int truncate(char const   *__file , __off_t __length ) ;
#line 1014
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 1035
extern  __attribute__((__nothrow__)) int brk(void *__addr ) ;
#line 1041
extern  __attribute__((__nothrow__)) void *sbrk(intptr_t __delta ) ;
#line 1056
extern  __attribute__((__nothrow__)) long syscall(long __sysno  , ...) ;
#line 1079
extern int lockf(int __fd , int __cmd , __off_t __len ) ;
#line 1115
extern int fdatasync(int __fildes ) ;
#line 1124
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt ) ;
#line 1161
int getentropy(void *__buffer , size_t __length ) ;
#line 220 "/usr/include/zlib.h"
extern char const   *zlibVersion(void) ;
#line 250
extern int deflate(z_streamp strm , int flush ) ;
#line 363
extern int deflateEnd(z_streamp strm ) ;
#line 400
extern int inflate(z_streamp strm , int flush ) ;
#line 520
extern int inflateEnd(z_streamp strm ) ;
#line 611
extern int deflateSetDictionary(z_streamp strm , Bytef *dictionary , uInt dictLength ) ;
#line 655
extern int deflateGetDictionary(z_streamp strm , Bytef *dictionary , uInt *dictLength ) ;
#line 677
extern int deflateCopy(z_streamp dest , z_streamp source ) ;
#line 695
extern int deflateReset(z_streamp strm ) ;
#line 706
extern int deflateParams(z_streamp strm , int level , int strategy ) ;
#line 744
extern int deflateTune(z_streamp strm , int good_length , int max_lazy , int nice_length ,
                       int max_chain ) ;
#line 761
extern uLong deflateBound(z_streamp strm , uLong sourceLen ) ;
#line 776
extern int deflatePending(z_streamp strm , unsigned int *pending , int *bits ) ;
#line 791
extern int deflatePrime(z_streamp strm , int bits , int value ) ;
#line 808
extern int deflateSetHeader(z_streamp strm , gz_headerp head ) ;
#line 885
extern int inflateSetDictionary(z_streamp strm , Bytef *dictionary , uInt dictLength ) ;
#line 908
extern int inflateGetDictionary(z_streamp strm , Bytef *dictionary , uInt *dictLength ) ;
#line 923
extern int inflateSync(z_streamp strm ) ;
#line 942
extern int inflateCopy(z_streamp dest , z_streamp source ) ;
#line 958
extern int inflateReset(z_streamp strm ) ;
#line 968
extern int inflateReset2(z_streamp strm , int windowBits ) ;
#line 982
extern int inflatePrime(z_streamp strm , int bits , int value ) ;
#line 1003
extern long inflateMark(z_streamp strm ) ;
#line 1031
extern int inflateGetHeader(z_streamp strm , gz_headerp head ) ;
#line 1097
extern int inflateBack(z_streamp strm , in_func in , void *in_desc , out_func out ,
                       void *out_desc ) ;
#line 1167
extern int inflateBackEnd(z_streamp strm ) ;
#line 1175
extern uLong zlibCompileFlags(void) ;
#line 1228
extern int compress(Bytef *dest , uLongf *destLen , Bytef *source , uLong sourceLen ) ;
#line 1243
extern int compress2(Bytef *dest , uLongf *destLen , Bytef *source , uLong sourceLen ,
                     int level ) ;
#line 1259
extern uLong compressBound(uLong sourceLen ) ;
#line 1266
extern int uncompress(Bytef *dest , uLongf *destLen , Bytef *source , uLong sourceLen ) ;
#line 1284
extern int uncompress2(Bytef *dest , uLongf *destLen , Bytef *source , uLong *sourceLen ) ;
#line 1341
extern gzFile gzdopen(int fd , char const   *mode ) ;
#line 1364
extern int gzbuffer(gzFile file , unsigned int size ) ;
#line 1380
extern int gzsetparams(gzFile file , int level , int strategy ) ;
#line 1391
extern int gzread(gzFile file , voidp buf , unsigned int len ) ;
#line 1421
extern z_size_t gzfread(voidp buf , z_size_t size , z_size_t nitems , gzFile file ) ;
#line 1447
extern int gzwrite(gzFile file , voidpc buf , unsigned int len ) ;
#line 1455
extern z_size_t gzfwrite(voidpc buf , z_size_t size , z_size_t nitems , gzFile file ) ;
#line 1469
extern int gzprintf(gzFile file , char const   *format  , ...) ;
#line 1484
extern int gzputs(gzFile file , char const   *s ) ;
#line 1492
extern char *gzgets(gzFile file , char *buf , int len ) ;
#line 1505
extern int gzputc(gzFile file , int c ) ;
#line 1511
extern int gzgetc(gzFile file ) ;
#line 1520
extern int gzungetc(int c , gzFile file ) ;
#line 1532
extern int gzflush(gzFile file , int flush ) ;
#line 1567
extern int gzrewind(gzFile file ) ;
#line 1595
extern int gzeof(gzFile file ) ;
#line 1610
extern int gzdirect(gzFile file ) ;
#line 1631
extern int gzclose(gzFile file ) ;
#line 1644
extern int gzclose_r(gzFile file ) ;
#line 1645
extern int gzclose_w(gzFile file ) ;
#line 1656
extern char const   *gzerror(gzFile file , int *errnum ) ;
#line 1672
extern void gzclearerr(gzFile file ) ;
#line 1689
extern uLong adler32(uLong adler , Bytef *buf , uInt len ) ;
#line 1708
extern uLong adler32_z(uLong adler , Bytef *buf , z_size_t len ) ;
#line 1726
extern uLong crc32(uLong crc , Bytef *buf , uInt len ) ;
#line 1743
extern uLong crc32_z(uLong adler , Bytef *buf , z_size_t len ) ;
#line 1765
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1767
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 1769
extern int deflateInit2_(z_streamp strm , int level , int method , int windowBits ,
                         int memLevel , int strategy , char const   *version , int stream_size ) ;
#line 1773
extern int inflateInit2_(z_streamp strm , int windowBits , char const   *version ,
                         int stream_size ) ;
#line 1775
extern int inflateBackInit_(z_streamp strm , int windowBits , unsigned char *window ,
                            char const   *version , int stream_size ) ;
#line 1823
extern int gzgetc_(gzFile file ) ;
#line 1873
extern gzFile gzopen(char const   * , char const   * ) ;
#line 1874
extern off_t gzseek(gzFile  , off_t  , int  ) ;
#line 1875
extern off_t gztell(gzFile  ) ;
#line 1876
extern off_t gzoffset(gzFile  ) ;
#line 1877
extern uLong adler32_combine(uLong  , uLong  , off_t  ) ;
#line 1878
extern uLong crc32_combine(uLong  , uLong  , off_t  ) ;
#line 1889
extern char const   *zError(int  ) ;
#line 1890
extern int inflateSyncPoint(z_streamp  ) ;
#line 1891
extern z_crc_t *get_crc_table(void) ;
#line 1892
extern int inflateUndermine(z_streamp  , int  ) ;
#line 1893
extern int inflateValidate(z_streamp  , int  ) ;
#line 1894
extern unsigned long inflateCodesUsed(z_streamp  ) ;
#line 1895
extern int inflateResetKeep(z_streamp  ) ;
#line 1896
extern int deflateResetKeep(z_streamp  ) ;
#line 1903
extern int gzvprintf(gzFile file , char const   *format , va_list va ) ;
#line 49 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int setjmp(jmp_buf __env ) ;
#line 54
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag __env[1] ,
                                                     int __savemask ) ;
#line 58
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag __env[1] ) ;
#line 67
extern  __attribute__((__nothrow__)) void longjmp(struct __jmp_buf_tag __env[1] ,
                                                  int __val ) ;
#line 74
extern  __attribute__((__nothrow__)) void _longjmp(struct __jmp_buf_tag __env[1] ,
                                                   int __val ) ;
#line 93
extern  __attribute__((__nothrow__)) void siglongjmp(sigjmp_buf __env , int __val ) ;
#line 924 "/usr/include/png.h"
extern png_uint_32 png_access_version_number(void) ;
#line 929
extern void png_set_sig_bytes(png_structrp png_ptr , int num_bytes ) ;
#line 936
extern int png_sig_cmp(png_const_bytep sig , size_t start , size_t num_to_check ) ;
#line 945
extern png_structp png_create_read_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                          png_error_ptr error_fn , png_error_ptr warn_fn ) ;
#line 951
extern png_structp png_create_write_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                           png_error_ptr error_fn , png_error_ptr warn_fn ) ;
#line 956
extern size_t png_get_compression_buffer_size(png_const_structrp png_ptr ) ;
#line 959
extern void png_set_compression_buffer_size(png_structrp png_ptr , size_t size ) ;
#line 973
extern jmp_buf *png_set_longjmp_fn(png_structrp png_ptr , png_longjmp_ptr longjmp_fn ,
                                   size_t jmp_buf_size ) ;
#line 986
extern void png_longjmp(png_const_structrp png_ptr , int val ) ;
#line 991
extern int png_reset_zstream(png_structrp png_ptr ) ;
#line 996
extern png_structp png_create_read_struct_2(png_const_charp user_png_ver , png_voidp error_ptr ,
                                            png_error_ptr error_fn , png_error_ptr warn_fn ,
                                            png_voidp mem_ptr , png_malloc_ptr malloc_fn ,
                                            png_free_ptr free_fn ) ;
#line 1001
extern png_structp png_create_write_struct_2(png_const_charp user_png_ver , png_voidp error_ptr ,
                                             png_error_ptr error_fn , png_error_ptr warn_fn ,
                                             png_voidp mem_ptr , png_malloc_ptr malloc_fn ,
                                             png_free_ptr free_fn ) ;
#line 1009
extern void png_write_sig(png_structrp png_ptr ) ;
#line 1012
extern void png_write_chunk(png_structrp png_ptr , png_const_bytep chunk_name , png_const_bytep data ,
                            size_t length ) ;
#line 1016
extern void png_write_chunk_start(png_structrp png_ptr , png_const_bytep chunk_name ,
                                  png_uint_32 length ) ;
#line 1020
extern void png_write_chunk_data(png_structrp png_ptr , png_const_bytep data , size_t length ) ;
#line 1024
extern void png_write_chunk_end(png_structrp png_ptr ) ;
#line 1027
extern png_infop png_create_info_struct(png_const_structrp png_ptr ) ;
#line 1034
extern void png_info_init_3(png_infopp info_ptr , size_t png_info_struct_size ) ;
#line 1038
extern void png_write_info_before_PLTE(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1040
extern void png_write_info(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1045
extern void png_read_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1056
extern png_const_charp png_convert_to_rfc1123(png_structrp png_ptr , png_const_timep ptime ) ;
#line 1059
extern int png_convert_to_rfc1123_buffer(char out[29] , png_const_timep ptime ) ;
#line 1065
extern void png_convert_from_struct_tm(png_timep ptime , struct tm *ttime ) ;
#line 1069
extern void png_convert_from_time_t(png_timep ptime , time_t ttime ) ;
#line 1074
extern void png_set_expand(png_structrp png_ptr ) ;
#line 1075
extern void png_set_expand_gray_1_2_4_to_8(png_structrp png_ptr ) ;
#line 1076
extern void png_set_palette_to_rgb(png_structrp png_ptr ) ;
#line 1077
extern void png_set_tRNS_to_alpha(png_structrp png_ptr ) ;
#line 1084
extern void png_set_expand_16(png_structrp png_ptr ) ;
#line 1089
extern void png_set_bgr(png_structrp png_ptr ) ;
#line 1094
extern void png_set_gray_to_rgb(png_structrp png_ptr ) ;
#line 1104
extern void png_set_rgb_to_gray(png_structrp png_ptr , int error_action , double red ,
                                double green ) ;
#line 1106
extern void png_set_rgb_to_gray_fixed(png_structrp png_ptr , int error_action , png_fixed_point red ,
                                      png_fixed_point green ) ;
#line 1109
extern png_byte png_get_rgb_to_gray_status(png_const_structrp png_ptr ) ;
#line 1114
extern void png_build_grayscale_palette(int bit_depth , png_colorp palette ) ;
#line 1160
extern void png_set_alpha_mode(png_structrp png_ptr , int mode , double output_gamma ) ;
#line 1162
extern void png_set_alpha_mode_fixed(png_structrp png_ptr , int mode , png_fixed_point output_gamma ) ;
#line 1253
extern void png_set_strip_alpha(png_structrp png_ptr ) ;
#line 1258
extern void png_set_swap_alpha(png_structrp png_ptr ) ;
#line 1263
extern void png_set_invert_alpha(png_structrp png_ptr ) ;
#line 1268
extern void png_set_filler(png_structrp png_ptr , png_uint_32 filler , int flags ) ;
#line 1274
extern void png_set_add_alpha(png_structrp png_ptr , png_uint_32 filler , int flags ) ;
#line 1280
extern void png_set_swap(png_structrp png_ptr ) ;
#line 1285
extern void png_set_packing(png_structrp png_ptr ) ;
#line 1291
extern void png_set_packswap(png_structrp png_ptr ) ;
#line 1296
extern void png_set_shift(png_structrp png_ptr , png_const_color_8p true_bits ) ;
#line 1308
extern int png_set_interlace_handling(png_structrp png_ptr ) ;
#line 1313
extern void png_set_invert_mono(png_structrp png_ptr ) ;
#line 1322
extern void png_set_background(png_structrp png_ptr , png_const_color_16p background_color ,
                               int background_gamma_code , int need_expand , double background_gamma ) ;
#line 1325
extern void png_set_background_fixed(png_structrp png_ptr , png_const_color_16p background_color ,
                                     int background_gamma_code , int need_expand ,
                                     png_fixed_point background_gamma ) ;
#line 1338
extern void png_set_scale_16(png_structrp png_ptr ) ;
#line 1344
extern void png_set_strip_16(png_structrp png_ptr ) ;
#line 1351
extern void png_set_quantize(png_structrp png_ptr , png_colorp palette , int num_palette ,
                             int maximum_colors , png_const_uint_16p histogram , int full_quantize ) ;
#line 1373
extern void png_set_gamma(png_structrp png_ptr , double screen_gamma , double override_file_gamma ) ;
#line 1375
extern void png_set_gamma_fixed(png_structrp png_ptr , png_fixed_point screen_gamma ,
                                png_fixed_point override_file_gamma ) ;
#line 1381
extern void png_set_flush(png_structrp png_ptr , int nrows ) ;
#line 1383
extern void png_write_flush(png_structrp png_ptr ) ;
#line 1387
extern void png_start_read_image(png_structrp png_ptr ) ;
#line 1390
extern void png_read_update_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1395
extern void png_read_rows(png_structrp png_ptr , png_bytepp row , png_bytepp display_row ,
                          png_uint_32 num_rows ) ;
#line 1401
extern void png_read_row(png_structrp png_ptr , png_bytep row , png_bytep display_row ) ;
#line 1407
extern void png_read_image(png_structrp png_ptr , png_bytepp image ) ;
#line 1411
extern void png_write_row(png_structrp png_ptr , png_const_bytep row ) ;
#line 1419
extern void png_write_rows(png_structrp png_ptr , png_bytepp row , png_uint_32 num_rows ) ;
#line 1423
extern void png_write_image(png_structrp png_ptr , png_bytepp image ) ;
#line 1426
extern void png_write_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1431
extern void png_read_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1435
extern void png_destroy_info_struct(png_const_structrp png_ptr , png_infopp info_ptr_ptr ) ;
#line 1439
extern void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                                    png_infopp end_info_ptr_ptr ) ;
#line 1443
extern void png_destroy_write_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ) ;
#line 1447
extern void png_set_crc_action(png_structrp png_ptr , int crit_action , int ancil_action ) ;
#line 1478
extern void png_set_filter(png_structrp png_ptr , int method , int filters ) ;
#line 1508
extern void png_set_filter_heuristics(png_structrp png_ptr , int heuristic_method ,
                                      int num_weights , png_const_doublep filter_weights ,
                                      png_const_doublep filter_costs ) ;
#line 1511
extern void png_set_filter_heuristics_fixed(png_structrp png_ptr , int heuristic_method ,
                                            int num_weights , png_const_fixed_point_p filter_weights ,
                                            png_const_fixed_point_p filter_costs ) ;
#line 1531
extern void png_set_compression_level(png_structrp png_ptr , int level ) ;
#line 1534
extern void png_set_compression_mem_level(png_structrp png_ptr , int mem_level ) ;
#line 1537
extern void png_set_compression_strategy(png_structrp png_ptr , int strategy ) ;
#line 1543
extern void png_set_compression_window_bits(png_structrp png_ptr , int window_bits ) ;
#line 1546
extern void png_set_compression_method(png_structrp png_ptr , int method ) ;
#line 1552
extern void png_set_text_compression_level(png_structrp png_ptr , int level ) ;
#line 1555
extern void png_set_text_compression_mem_level(png_structrp png_ptr , int mem_level ) ;
#line 1558
extern void png_set_text_compression_strategy(png_structrp png_ptr , int strategy ) ;
#line 1564
extern void png_set_text_compression_window_bits(png_structrp png_ptr , int window_bits ) ;
#line 1567
extern void png_set_text_compression_method(png_structrp png_ptr , int method ) ;
#line 1583
extern void png_init_io(png_structrp png_ptr , png_FILE_p fp ) ;
#line 1594
extern void png_set_error_fn(png_structrp png_ptr , png_voidp error_ptr , png_error_ptr error_fn ,
                             png_error_ptr warning_fn ) ;
#line 1598
extern png_voidp png_get_error_ptr(png_const_structrp png_ptr ) ;
#line 1610
extern void png_set_write_fn(png_structrp png_ptr , png_voidp io_ptr , png_rw_ptr write_data_fn ,
                             png_flush_ptr output_flush_fn ) ;
#line 1614
extern void png_set_read_fn(png_structrp png_ptr , png_voidp io_ptr , png_rw_ptr read_data_fn ) ;
#line 1618
extern png_voidp png_get_io_ptr(png_const_structrp png_ptr ) ;
#line 1620
extern void png_set_read_status_fn(png_structrp png_ptr , png_read_status_ptr read_row_fn ) ;
#line 1623
extern void png_set_write_status_fn(png_structrp png_ptr , png_write_status_ptr write_row_fn ) ;
#line 1628
extern void png_set_mem_fn(png_structrp png_ptr , png_voidp mem_ptr , png_malloc_ptr malloc_fn ,
                           png_free_ptr free_fn ) ;
#line 1631
extern png_voidp png_get_mem_ptr(png_const_structrp png_ptr ) ;
#line 1635
extern void png_set_read_user_transform_fn(png_structrp png_ptr , png_user_transform_ptr read_user_transform_fn ) ;
#line 1640
extern void png_set_write_user_transform_fn(png_structrp png_ptr , png_user_transform_ptr write_user_transform_fn ) ;
#line 1645
extern void png_set_user_transform_info(png_structrp png_ptr , png_voidp user_transform_ptr ,
                                        int user_transform_depth , int user_transform_channels ) ;
#line 1649
extern png_voidp png_get_user_transform_ptr(png_const_structrp png_ptr ) ;
#line 1665
extern png_uint_32 png_get_current_row_number(png_const_structrp  ) ;
#line 1666
extern png_byte png_get_current_pass_number(png_const_structrp  ) ;
#line 1689
extern void png_set_read_user_chunk_fn(png_structrp png_ptr , png_voidp user_chunk_ptr ,
                                       png_user_chunk_ptr read_user_chunk_fn ) ;
#line 1694
extern png_voidp png_get_user_chunk_ptr(png_const_structrp png_ptr ) ;
#line 1701
extern void png_set_progressive_read_fn(png_structrp png_ptr , png_voidp progressive_ptr ,
                                        png_progressive_info_ptr info_fn , png_progressive_row_ptr row_fn ,
                                        png_progressive_end_ptr end_fn ) ;
#line 1706
extern png_voidp png_get_progressive_ptr(png_const_structrp png_ptr ) ;
#line 1710
extern void png_process_data(png_structrp png_ptr , png_inforp info_ptr , png_bytep buffer ,
                             size_t buffer_size ) ;
#line 1720
extern size_t png_process_data_pause(png_structrp  , int save ) ;
#line 1728
extern png_uint_32 png_process_data_skip(png_structrp  ) ;
#line 1735
extern void png_progressive_combine_row(png_const_structrp png_ptr , png_bytep old_row ,
                                        png_const_bytep new_row ) ;
#line 1739
extern png_voidp png_malloc(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1742
extern png_voidp png_calloc(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1746
extern png_voidp png_malloc_warn(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1750
extern void png_free(png_const_structrp png_ptr , png_voidp ptr ) ;
#line 1753
extern void png_free_data(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 free_me ,
                          int num ) ;
#line 1763
extern void png_data_freer(png_const_structrp png_ptr , png_inforp info_ptr , int freer ,
                           png_uint_32 mask ) ;
#line 1789
extern png_voidp png_malloc_default(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1791
extern void png_free_default(png_const_structrp png_ptr , png_voidp ptr ) ;
#line 1797
extern void png_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 1801
extern void png_chunk_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 1813
extern void png_warning(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1817
extern void png_chunk_warning(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1827
extern void png_benign_error(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1832
extern void png_chunk_benign_error(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1836
extern void png_set_benign_errors(png_structrp png_ptr , int allowed ) ;
#line 1861
extern png_uint_32 png_get_valid(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                 png_uint_32 flag ) ;
#line 1865
extern size_t png_get_rowbytes(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1872
extern png_bytepp png_get_rows(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1878
extern void png_set_rows(png_const_structrp png_ptr , png_inforp info_ptr , png_bytepp row_pointers ) ;
#line 1883
extern png_byte png_get_channels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1888
extern png_uint_32 png_get_image_width(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1892
extern png_uint_32 png_get_image_height(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1896
extern png_byte png_get_bit_depth(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1900
extern png_byte png_get_color_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1904
extern png_byte png_get_filter_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1908
extern png_byte png_get_interlace_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1912
extern png_byte png_get_compression_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1916
extern png_uint_32 png_get_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1918
extern png_uint_32 png_get_x_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1920
extern png_uint_32 png_get_y_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1924
extern float png_get_pixel_aspect_ratio(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1926
extern png_fixed_point png_get_pixel_aspect_ratio_fixed(png_const_structrp png_ptr ,
                                                        png_const_inforp info_ptr ) ;
#line 1930
extern png_int_32 png_get_x_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1932
extern png_int_32 png_get_y_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1934
extern png_int_32 png_get_x_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1936
extern png_int_32 png_get_y_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1943
extern png_const_bytep png_get_signature(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1948
extern png_uint_32 png_get_bKGD(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_color_16p *background ) ;
#line 1953
extern void png_set_bKGD(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_16p background ) ;
#line 1958
extern png_uint_32 png_get_cHRM(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                double *white_x , double *white_y , double *red_x ,
                                double *red_y , double *green_x , double *green_y ,
                                double *blue_x , double *blue_y ) ;
#line 1962
extern png_uint_32 png_get_cHRM_XYZ(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                    double *red_X , double *red_Y , double *red_Z ,
                                    double *green_X , double *green_Y , double *green_Z ,
                                    double *blue_X , double *blue_Y , double *blue_Z ) ;
#line 1966
extern png_uint_32 png_get_cHRM_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                      png_fixed_point *int_white_x , png_fixed_point *int_white_y ,
                                      png_fixed_point *int_red_x , png_fixed_point *int_red_y ,
                                      png_fixed_point *int_green_x , png_fixed_point *int_green_y ,
                                      png_fixed_point *int_blue_x , png_fixed_point *int_blue_y ) ;
#line 1972
extern png_uint_32 png_get_cHRM_XYZ_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                          png_fixed_point *int_red_X , png_fixed_point *int_red_Y ,
                                          png_fixed_point *int_red_Z , png_fixed_point *int_green_X ,
                                          png_fixed_point *int_green_Y , png_fixed_point *int_green_Z ,
                                          png_fixed_point *int_blue_X , png_fixed_point *int_blue_Y ,
                                          png_fixed_point *int_blue_Z ) ;
#line 1982
extern void png_set_cHRM(png_const_structrp png_ptr , png_inforp info_ptr , double white_x ,
                         double white_y , double red_x , double red_y , double green_x ,
                         double green_y , double blue_x , double blue_y ) ;
#line 1986
extern void png_set_cHRM_XYZ(png_const_structrp png_ptr , png_inforp info_ptr , double red_X ,
                             double red_Y , double red_Z , double green_X , double green_Y ,
                             double green_Z , double blue_X , double blue_Y , double blue_Z ) ;
#line 1990
extern void png_set_cHRM_fixed(png_const_structrp png_ptr , png_inforp info_ptr ,
                               png_fixed_point int_white_x , png_fixed_point int_white_y ,
                               png_fixed_point int_red_x , png_fixed_point int_red_y ,
                               png_fixed_point int_green_x , png_fixed_point int_green_y ,
                               png_fixed_point int_blue_x , png_fixed_point int_blue_y ) ;
#line 1996
extern void png_set_cHRM_XYZ_fixed(png_const_structrp png_ptr , png_inforp info_ptr ,
                                   png_fixed_point int_red_X , png_fixed_point int_red_Y ,
                                   png_fixed_point int_red_Z , png_fixed_point int_green_X ,
                                   png_fixed_point int_green_Y , png_fixed_point int_green_Z ,
                                   png_fixed_point int_blue_X , png_fixed_point int_blue_Y ,
                                   png_fixed_point int_blue_Z ) ;
#line 2005
extern png_uint_32 png_get_eXIf(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_bytep *exif ) ;
#line 2007
extern void png_set_eXIf(png_const_structrp png_ptr , png_inforp info_ptr , png_bytep exif ) ;
#line 2010
extern png_uint_32 png_get_eXIf_1(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                  png_uint_32 *num_exif , png_bytep *exif ) ;
#line 2012
extern void png_set_eXIf_1(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 num_exif ,
                           png_bytep exif ) ;
#line 2017
extern png_uint_32 png_get_gAMA(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                double *file_gamma ) ;
#line 2019
extern png_uint_32 png_get_gAMA_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                      png_fixed_point *int_file_gamma ) ;
#line 2025
extern void png_set_gAMA(png_const_structrp png_ptr , png_inforp info_ptr , double file_gamma ) ;
#line 2027
extern void png_set_gAMA_fixed(png_const_structrp png_ptr , png_inforp info_ptr ,
                               png_fixed_point int_file_gamma ) ;
#line 2032
extern png_uint_32 png_get_hIST(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_uint_16p *hist ) ;
#line 2034
extern void png_set_hIST(png_const_structrp png_ptr , png_inforp info_ptr , png_const_uint_16p hist ) ;
#line 2038
extern png_uint_32 png_get_IHDR(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_uint_32 *width , png_uint_32 *height , int *bit_depth ,
                                int *color_type , int *interlace_method , int *compression_method ,
                                int *filter_method ) ;
#line 2043
extern void png_set_IHDR(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 width ,
                         png_uint_32 height , int bit_depth , int color_type , int interlace_method ,
                         int compression_method , int filter_method ) ;
#line 2049
extern png_uint_32 png_get_oFFs(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_int_32 *offset_x , png_int_32 *offset_y , int *unit_type ) ;
#line 2055
extern void png_set_oFFs(png_const_structrp png_ptr , png_inforp info_ptr , png_int_32 offset_x ,
                         png_int_32 offset_y , int unit_type ) ;
#line 2061
extern png_uint_32 png_get_pCAL(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_charp *purpose , png_int_32 *X0 , png_int_32 *X1 ,
                                int *type , int *nparams , png_charp *units , png_charpp *params ) ;
#line 2068
extern void png_set_pCAL(png_const_structrp png_ptr , png_inforp info_ptr , png_const_charp purpose ,
                         png_int_32 X0 , png_int_32 X1 , int type , int nparams ,
                         png_const_charp units , png_charpp params ) ;
#line 2074
extern png_uint_32 png_get_pHYs(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_uint_32 *res_x , png_uint_32 *res_y , int *unit_type ) ;
#line 2080
extern void png_set_pHYs(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 res_x ,
                         png_uint_32 res_y , int unit_type ) ;
#line 2084
extern png_uint_32 png_get_PLTE(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_colorp *palette , int *num_palette ) ;
#line 2087
extern void png_set_PLTE(png_structrp png_ptr , png_inforp info_ptr , png_const_colorp palette ,
                         int num_palette ) ;
#line 2091
extern png_uint_32 png_get_sBIT(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_color_8p *sig_bit ) ;
#line 2096
extern void png_set_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_8p sig_bit ) ;
#line 2101
extern png_uint_32 png_get_sRGB(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                int *file_srgb_intent ) ;
#line 2106
extern void png_set_sRGB(png_const_structrp png_ptr , png_inforp info_ptr , int srgb_intent ) ;
#line 2108
extern void png_set_sRGB_gAMA_and_cHRM(png_const_structrp png_ptr , png_inforp info_ptr ,
                                       int srgb_intent ) ;
#line 2113
extern png_uint_32 png_get_iCCP(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_charpp name , int *compression_type , png_bytepp profile ,
                                png_uint_32 *proflen ) ;
#line 2119
extern void png_set_iCCP(png_const_structrp png_ptr , png_inforp info_ptr , png_const_charp name ,
                         int compression_type , png_const_bytep profile , png_uint_32 proflen ) ;
#line 2125
extern int png_get_sPLT(png_const_structrp png_ptr , png_inforp info_ptr , png_sPLT_tpp entries ) ;
#line 2130
extern void png_set_sPLT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_sPLT_tp entries ,
                         int nentries ) ;
#line 2136
extern int png_get_text(png_const_structrp png_ptr , png_inforp info_ptr , png_textp *text_ptr ,
                        int *num_text ) ;
#line 2148
extern void png_set_text(png_const_structrp png_ptr , png_inforp info_ptr , png_const_textp text_ptr ,
                         int num_text ) ;
#line 2153
extern png_uint_32 png_get_tIME(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_timep *mod_time ) ;
#line 2158
extern void png_set_tIME(png_const_structrp png_ptr , png_inforp info_ptr , png_const_timep mod_time ) ;
#line 2163
extern png_uint_32 png_get_tRNS(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_bytep *trans_alpha , int *num_trans , png_color_16p *trans_color ) ;
#line 2169
extern void png_set_tRNS(png_structrp png_ptr , png_inforp info_ptr , png_const_bytep trans_alpha ,
                         int num_trans , png_const_color_16p trans_color ) ;
#line 2175
extern png_uint_32 png_get_sCAL(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                int *unit , double *width , double *height ) ;
#line 2184
extern png_uint_32 png_get_sCAL_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                      int *unit , png_fixed_point *width , png_fixed_point *height ) ;
#line 2188
extern png_uint_32 png_get_sCAL_s(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                  int *unit , png_charpp swidth , png_charpp sheight ) ;
#line 2192
extern void png_set_sCAL(png_const_structrp png_ptr , png_inforp info_ptr , int unit ,
                         double width , double height ) ;
#line 2194
extern void png_set_sCAL_fixed(png_const_structrp png_ptr , png_inforp info_ptr ,
                               int unit , png_fixed_point width , png_fixed_point height ) ;
#line 2197
extern void png_set_sCAL_s(png_const_structrp png_ptr , png_inforp info_ptr , int unit ,
                           png_const_charp swidth , png_const_charp sheight ) ;
#line 2302
extern void png_set_keep_unknown_chunks(png_structrp png_ptr , int keep , png_const_bytep chunk_list ,
                                        int num_chunks ) ;
#line 2310
extern int png_handle_as_unknown(png_const_structrp png_ptr , png_const_bytep chunk_name ) ;
#line 2315
extern void png_set_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr ,
                                   png_const_unknown_chunkp unknowns , int num_unknowns ) ;
#line 2327
extern void png_set_unknown_chunk_location(png_const_structrp png_ptr , png_inforp info_ptr ,
                                           int chunk , int location ) ;
#line 2330
extern int png_get_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr ,
                                  png_unknown_chunkpp entries ) ;
#line 2338
extern void png_set_invalid(png_const_structrp png_ptr , png_inforp info_ptr , int mask ) ;
#line 2344
extern void png_read_png(png_structrp png_ptr , png_inforp info_ptr , int transforms ,
                         png_voidp params ) ;
#line 2348
extern void png_write_png(png_structrp png_ptr , png_inforp info_ptr , int transforms ,
                          png_voidp params ) ;
#line 2353
extern png_const_charp png_get_copyright(png_const_structrp png_ptr ) ;
#line 2355
extern png_const_charp png_get_header_ver(png_const_structrp png_ptr ) ;
#line 2357
extern png_const_charp png_get_header_version(png_const_structrp png_ptr ) ;
#line 2359
extern png_const_charp png_get_libpng_ver(png_const_structrp png_ptr ) ;
#line 2363
extern png_uint_32 png_permit_mng_features(png_structrp png_ptr , png_uint_32 mng_features_permitted ) ;
#line 2384
extern void png_set_user_limits(png_structrp png_ptr , png_uint_32 user_width_max ,
                                png_uint_32 user_height_max ) ;
#line 2386
extern png_uint_32 png_get_user_width_max(png_const_structrp png_ptr ) ;
#line 2388
extern png_uint_32 png_get_user_height_max(png_const_structrp png_ptr ) ;
#line 2391
extern void png_set_chunk_cache_max(png_structrp png_ptr , png_uint_32 user_chunk_cache_max ) ;
#line 2393
extern png_uint_32 png_get_chunk_cache_max(png_const_structrp png_ptr ) ;
#line 2396
extern void png_set_chunk_malloc_max(png_structrp png_ptr , png_alloc_size_t user_chunk_cache_max ) ;
#line 2398
extern png_alloc_size_t png_get_chunk_malloc_max(png_const_structrp png_ptr ) ;
#line 2403
extern png_uint_32 png_get_pixels_per_inch(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2406
extern png_uint_32 png_get_x_pixels_per_inch(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2409
extern png_uint_32 png_get_y_pixels_per_inch(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2412
extern float png_get_x_offset_inches(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2415
extern png_fixed_point png_get_x_offset_inches_fixed(png_const_structrp png_ptr ,
                                                     png_const_inforp info_ptr ) ;
#line 2419
extern float png_get_y_offset_inches(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2422
extern png_fixed_point png_get_y_offset_inches_fixed(png_const_structrp png_ptr ,
                                                     png_const_inforp info_ptr ) ;
#line 2427
extern png_uint_32 png_get_pHYs_dpi(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                    png_uint_32 *res_x , png_uint_32 *res_y , int *unit_type ) ;
#line 2435
extern png_uint_32 png_get_io_state(png_const_structrp png_ptr ) ;
#line 2441
extern png_uint_32 png_get_io_chunk_type(png_const_structrp png_ptr ) ;
#line 2567
extern png_uint_32 png_get_uint_32(png_const_bytep buf ) ;
#line 2568
extern png_uint_16 png_get_uint_16(png_const_bytep buf ) ;
#line 2569
extern png_int_32 png_get_int_32(png_const_bytep buf ) ;
#line 2572
extern png_uint_32 png_get_uint_31(png_const_structrp png_ptr , png_const_bytep buf ) ;
#line 2578
extern void png_save_uint_32(png_bytep buf , png_uint_32 i ) ;
#line 2581
extern void png_save_int_32(png_bytep buf , png_int_32 i ) ;
#line 2589
extern void png_save_uint_16(png_bytep buf , unsigned int i ) ;
#line 2635
extern void png_set_check_for_invalid_index(png_structrp png_ptr , int allowed ) ;
#line 2638
extern int png_get_palette_max(png_const_structp png_ptr , png_const_infop info_ptr ) ;
#line 3003
extern int png_image_begin_read_from_file(png_imagep image , char const   *file_name ) ;
#line 3009
extern int png_image_begin_read_from_stdio(png_imagep image , FILE *file ) ;
#line 3014
extern int png_image_begin_read_from_memory(png_imagep image , png_const_voidp memory ,
                                            size_t size ) ;
#line 3018
extern int png_image_finish_read(png_imagep image , png_const_colorp background ,
                                 void *buffer , png_int_32 row_stride , void *colormap ) ;
#line 3053
extern void png_image_free(png_imagep image ) ;
#line 3077
extern int png_image_write_to_file(png_imagep image , char const   *file , int convert_to_8bit ,
                                   void const   *buffer , png_int_32 row_stride ,
                                   void const   *colormap ) ;
#line 3082
extern int png_image_write_to_stdio(png_imagep image , FILE *file , int convert_to_8_bit ,
                                    void const   *buffer , png_int_32 row_stride ,
                                    void const   *colormap ) ;
#line 3109
extern int png_image_write_to_memory(png_imagep image , void *memory , png_alloc_size_t *memory_bytes ,
                                     int convert_to_8_bit , void const   *buffer ,
                                     png_int_32 row_stride , void const   *colormap ) ;
#line 3245
extern int png_set_option(png_structrp png_ptr , int option , int onoff ) ;
#line 3253
extern png_uint_32 png_get_acTL(png_structp png_ptr , png_infop info_ptr , png_uint_32 *num_frames ,
                                png_uint_32 *num_plays ) ;
#line 3256
extern png_uint_32 png_set_acTL(png_structp png_ptr , png_infop info_ptr , png_uint_32 num_frames ,
                                png_uint_32 num_plays ) ;
#line 3259
extern png_uint_32 png_get_num_frames(png_structp png_ptr , png_infop info_ptr ) ;
#line 3262
extern png_uint_32 png_get_num_plays(png_structp png_ptr , png_infop info_ptr ) ;
#line 3265
extern png_uint_32 png_get_next_frame_fcTL(png_structp png_ptr , png_infop info_ptr ,
                                           png_uint_32 *width , png_uint_32 *height ,
                                           png_uint_32 *x_offset , png_uint_32 *y_offset ,
                                           png_uint_16 *delay_num , png_uint_16 *delay_den ,
                                           png_byte *dispose_op , png_byte *blend_op ) ;
#line 3271
extern png_uint_32 png_set_next_frame_fcTL(png_structp png_ptr , png_infop info_ptr ,
                                           png_uint_32 width , png_uint_32 height ,
                                           png_uint_32 x_offset , png_uint_32 y_offset ,
                                           png_uint_16 delay_num , png_uint_16 delay_den ,
                                           png_byte dispose_op , png_byte blend_op ) ;
#line 3277
extern png_uint_32 png_get_next_frame_width(png_structp png_ptr , png_infop info_ptr ) ;
#line 3279
extern png_uint_32 png_get_next_frame_height(png_structp png_ptr , png_infop info_ptr ) ;
#line 3281
extern png_uint_32 png_get_next_frame_x_offset(png_structp png_ptr , png_infop info_ptr ) ;
#line 3283
extern png_uint_32 png_get_next_frame_y_offset(png_structp png_ptr , png_infop info_ptr ) ;
#line 3285
extern png_uint_16 png_get_next_frame_delay_num(png_structp png_ptr , png_infop info_ptr ) ;
#line 3287
extern png_uint_16 png_get_next_frame_delay_den(png_structp png_ptr , png_infop info_ptr ) ;
#line 3289
extern png_byte png_get_next_frame_dispose_op(png_structp png_ptr , png_infop info_ptr ) ;
#line 3291
extern png_byte png_get_next_frame_blend_op(png_structp png_ptr , png_infop info_ptr ) ;
#line 3293
extern png_byte png_get_first_frame_is_hidden(png_structp png_ptr , png_infop info_ptr ) ;
#line 3295
extern png_uint_32 png_set_first_frame_is_hidden(png_structp png_ptr , png_infop info_ptr ,
                                                 png_byte is_hidden ) ;
#line 3299
extern void png_read_frame_head(png_structp png_ptr , png_infop info_ptr ) ;
#line 3302
extern void png_set_progressive_frame_fn(png_structp png_ptr , png_progressive_frame_ptr frame_info_fn ,
                                         png_progressive_frame_ptr frame_end_fn ) ;
#line 3309
extern void png_write_frame_head(png_structp png_ptr , png_infop info_ptr , png_bytepp row_pointers ,
                                 png_uint_32 width , png_uint_32 height , png_uint_32 x_offset ,
                                 png_uint_32 y_offset , png_uint_16 delay_num , png_uint_16 delay_den ,
                                 png_byte dispose_op , png_byte blend_op ) ;
#line 3316
extern void png_write_frame_tail(png_structp png_ptr , png_infop info_ptr ) ;
#line 69 "/root/patron/new_21/src/bin/jp2/convert.h"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 70
int imagetotga(opj_image_t *image , char const   *outfile ) ;
#line 73
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 74
int imagetobmp(opj_image_t *image , char const   *outfile ) ;
#line 77
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 78
int imagetotif(opj_image_t *image , char const   *outfile ) ;
#line 85
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 86
int imagetopgx(opj_image_t *image , char const   *outfile ) ;
#line 88
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 89
int imagetopnm(opj_image_t *image , char const   *outfile ) ;
#line 92
int imagetoraw(opj_image_t *image , char const   *outfile ) ;
#line 93
int imagetorawl(opj_image_t *image , char const   *outfile ) ;
#line 94
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) ;
#line 95
opj_image_t *rawltoimage(char const   *filename , opj_cparameters_t *parameters ,
                         raw_cparameters_t *raw_cp ) ;
#line 98
int imagetopng(opj_image_t *image , char const   *write_idf ) ;
#line 99
opj_image_t *pngtoimage(char const   *read_idf , opj_cparameters_t *params ) ;
#line 62 "/root/patron/new_21/src/bin/jp2/convert.c"
static int int_floorlog2(int a ) 
{ 
  int l ;
  int __cil_tmp3 ;

  {
#line 64
  l = 0;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (a > 1)) {
#line 64
      goto while_break;
    }
#line 65
    a >>= 1;
#line 64
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return (l);
}
}
#line 101 "/root/patron/new_21/src/bin/jp2/convert.c"
static unsigned short get_ushort(unsigned short val ) 
{ 


  {
#line 106
  return (val);
}
}
#line 113 "/root/patron/new_21/src/bin/jp2/convert.c"
static int tga_readheader(FILE *fp , unsigned int *bits_per_pixel , unsigned int *width ,
                          unsigned int *height , int *flip_image ) 
{ 
  int palette_size ;
  unsigned char *tga ;
  unsigned char id_len ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned short cmap_len ;
  unsigned short cmap_entry_size ;
  unsigned short image_w ;
  unsigned short image_h ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned short __cil_tmp18 ;
  unsigned short __cil_tmp19 ;
  unsigned short __cil_tmp20 ;
  unsigned char *id ;
  void *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;

  {
#line 123
  if (! bits_per_pixel) {
#line 124
    return (0);
  } else
#line 123
  if (! width) {
#line 124
    return (0);
  } else
#line 123
  if (! height) {
#line 124
    return (0);
  } else
#line 123
  if (! flip_image) {
#line 124
    return (0);
  }
  {
#line 125
  __cil_tmp16 = malloc((unsigned long )18);
#line 125
  tga = (unsigned char *)__cil_tmp16;
#line 127
  __cil_tmp17 = fread(tga, (unsigned long )18, (unsigned long )1, fp);
  }
#line 127
  if (__cil_tmp17 != 1UL) {
    {
#line 129
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 130
    return (0);
  }
  {
#line 132
  id_len = (unsigned char )*(tga + 0);
#line 134
  image_type = (unsigned char )*(tga + 2);
#line 136
  cmap_len = get_ushort(*((unsigned short *)(tga + 5)));
#line 137
  cmap_entry_size = (unsigned short )((unsigned char )*(tga + 7));
#line 144
  image_w = get_ushort(*((unsigned short *)(tga + 12)));
#line 145
  image_h = get_ushort(*((unsigned short *)(tga + 14)));
#line 146
  pixel_depth = (unsigned char )*(tga + 16);
#line 147
  image_desc = (unsigned char )*(tga + 17);
#line 149
  free(tga);
#line 151
  *bits_per_pixel = (unsigned int )pixel_depth;
#line 152
  *width = (unsigned int )image_w;
#line 153
  *height = (unsigned int )image_h;
  }
#line 156
  if (id_len) {
    {
#line 158
    __cil_tmp22 = malloc((unsigned long )id_len);
#line 158
    id = (unsigned char *)__cil_tmp22;
#line 159
    __cil_tmp23 = fread(id, (unsigned long )id_len, (unsigned long )1, fp);
    }
#line 159
    if (! __cil_tmp23) {
      {
#line 161
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 162
      free(id);
      }
#line 163
      return (0);
    }
    {
#line 165
    free(id);
    }
  }
#line 171
  if ((int )image_type > 8) {
    {
#line 173
    fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
    }
#line 174
    return (0);
  }
#line 177
  *flip_image = ! ((int )image_desc & 32);
#line 180
  palette_size = (int )cmap_len * ((int )cmap_entry_size / 8);
#line 182
  if (palette_size > 0) {
    {
#line 184
    fprintf(stderr, "File contains a palette - not yet supported.");
#line 185
    fseek(fp, (long )palette_size, 1);
    }
  }
#line 187
  return (1);
}
}
#line 200 "/root/patron/new_21/src/bin/jp2/convert.c"
static int tga_writeheader(FILE *fp , int bits_per_pixel , int width , int height ,
                           OPJ_BOOL flip_image ) 
{ 
  unsigned short image_w ;
  unsigned short image_h ;
  unsigned short us0 ;
  unsigned char uc0 ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;

  {
#line 207
  if (! bits_per_pixel) {
#line 208
    return (0);
  } else
#line 207
  if (! width) {
#line 208
    return (0);
  } else
#line 207
  if (! height) {
#line 208
    return (0);
  }
#line 210
  pixel_depth = (unsigned char )0;
#line 212
  if (bits_per_pixel < 256) {
#line 213
    pixel_depth = (unsigned char )bits_per_pixel;
  } else {
    {
#line 215
    fprintf(stderr, "ERROR: Wrong bits per pixel inside tga_header");
    }
#line 216
    return (0);
  }
  {
#line 218
  uc0 = (unsigned char )0;
#line 220
  __cil_tmp13 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 220
  if (__cil_tmp13 != 1UL) {
#line 220
    goto fails;
  }
  {
#line 221
  __cil_tmp14 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 221
  if (__cil_tmp14 != 1UL) {
#line 221
    goto fails;
  }
  {
#line 223
  image_type = (unsigned char )2;
#line 224
  __cil_tmp15 = fwrite(& image_type, (unsigned long )1, (unsigned long )1, fp);
  }
#line 224
  if (__cil_tmp15 != 1UL) {
#line 224
    goto fails;
  }
  {
#line 226
  us0 = (unsigned short )0;
#line 227
  __cil_tmp16 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 227
  if (__cil_tmp16 != 1UL) {
#line 227
    goto fails;
  }
  {
#line 228
  __cil_tmp17 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 228
  if (__cil_tmp17 != 1UL) {
#line 228
    goto fails;
  }
  {
#line 229
  __cil_tmp18 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 229
  if (__cil_tmp18 != 1UL) {
#line 229
    goto fails;
  }
  {
#line 231
  __cil_tmp19 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 231
  if (__cil_tmp19 != 1UL) {
#line 231
    goto fails;
  }
  {
#line 232
  __cil_tmp20 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 232
  if (__cil_tmp20 != 1UL) {
#line 232
    goto fails;
  }
  {
#line 234
  image_w = (unsigned short )width;
#line 235
  image_h = (unsigned short )height;
#line 238
  __cil_tmp21 = fwrite(& image_w, (unsigned long )2, (unsigned long )1, fp);
  }
#line 238
  if (__cil_tmp21 != 1UL) {
#line 238
    goto fails;
  }
  {
#line 239
  __cil_tmp22 = fwrite(& image_h, (unsigned long )2, (unsigned long )1, fp);
  }
#line 239
  if (__cil_tmp22 != 1UL) {
#line 239
    goto fails;
  }
  {
#line 247
  __cil_tmp23 = fwrite(& pixel_depth, (unsigned long )1, (unsigned long )1, fp);
  }
#line 247
  if (__cil_tmp23 != 1UL) {
#line 247
    goto fails;
  }
#line 249
  image_desc = (unsigned char )8;
#line 251
  if (flip_image) {
#line 252
    image_desc |= 32;
  }
  {
#line 253
  __cil_tmp24 = fwrite(& image_desc, (unsigned long )1, (unsigned long )1, fp);
  }
#line 253
  if (__cil_tmp24 != 1UL) {
#line 253
    goto fails;
  }
#line 255
  return (1);
  fails: 
  {
#line 258
  fputs("\nwrite_tgaheader: write ERROR\n", stderr);
  }
#line 259
  return (0);
}
}
#line 262 "/root/patron/new_21/src/bin/jp2/convert.c"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  opj_image_t *image ;
  unsigned int image_width ;
  unsigned int image_height ;
  unsigned int pixel_bit_depth ;
  unsigned int x ;
  unsigned int y ;
  int flip_image ;
  opj_image_cmptparm_t cmptparm[4] ;
  int numcomps ;
  OPJ_COLOR_SPACE color_space ;
  OPJ_BOOL mono ;
  OPJ_BOOL save_alpha ;
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  FILE *__cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp23 ;
  opj_image_t *__cil_tmp24 ;
  OPJ_UINT32 tmp___1 ;
  OPJ_UINT32 tmp___2 ;
  int index___21 ;
  unsigned char r ;
  unsigned char g ;
  unsigned char b ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  unsigned char r___0 ;
  unsigned char g___0 ;
  unsigned char b___0 ;
  unsigned char a ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  unsigned int __cil_tmp46 ;

  {
  {
#line 267
  flip_image = 0;
#line 276
  f = fopen(filename, "rb");
  }
#line 277
  if (! f) {
    {
#line 278
    fprintf(stderr, "Failed to open %s for reading !!\n^\222j\347U", filename);
    }
#line 279
    return ((opj_image_t *)0);
  }
  {
#line 282
  __cil_tmp20 = tga_readheader(f, & pixel_bit_depth, & image_width, & image_height,
                               & flip_image);
  }
#line 282
  if (! __cil_tmp20) {
#line 283
    return ((opj_image_t *)((void *)0));
  }
#line 286
  if (! (pixel_bit_depth == 24U || pixel_bit_depth == 32U)) {
#line 287
    return ((opj_image_t *)((void *)0));
  }
  {
#line 290
  memset(& cmptparm[0], 0, 4UL * sizeof(opj_image_cmptparm_t ));
#line 292
  mono = pixel_bit_depth == 8U || pixel_bit_depth == 16U;
#line 293
  save_alpha = pixel_bit_depth == 16U || pixel_bit_depth == 32U;
  }
#line 295
  if (mono) {
#line 296
    color_space = (OPJ_COLOR_SPACE )2;
#line 297
    if (save_alpha) {
#line 297
      tmp = 2;
    } else {
#line 297
      tmp = 1;
    }
#line 297
    numcomps = tmp;
  } else {
#line 300
    if (save_alpha) {
#line 300
      tmp___0 = 4;
    } else {
#line 300
      tmp___0 = 3;
    }
#line 300
    numcomps = tmp___0;
#line 301
    color_space = (OPJ_COLOR_SPACE )1;
  }
#line 304
  subsampling_dx = parameters->subsampling_dx;
#line 305
  subsampling_dy = parameters->subsampling_dy;
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! (i < numcomps)) {
#line 307
      goto while_break;
    }
#line 308
    cmptparm[i].prec = (OPJ_UINT32 )8;
#line 309
    cmptparm[i].bpp = (OPJ_UINT32 )8;
#line 310
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 311
    cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 312
    cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 313
    cmptparm[i].w = image_width;
#line 314
    cmptparm[i].h = image_height;
#line 307
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
  }
#line 320
  if (! image) {
#line 321
    return ((opj_image_t *)((void *)0));
  }
#line 324
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 325
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 326
  if (! image->x0) {
#line 326
    tmp___1 = (OPJ_UINT32 )(image_width - 1U) * (OPJ_UINT32 )subsampling_dx + 1U;
  } else {
#line 326
    tmp___1 = (image->x0 + (OPJ_UINT32 )(image_width - 1U) * (OPJ_UINT32 )subsampling_dx) + 1U;
  }
#line 326
  image->x1 = tmp___1;
#line 327
  if (! image->y0) {
#line 327
    tmp___2 = (OPJ_UINT32 )(image_height - 1U) * (OPJ_UINT32 )subsampling_dy + 1U;
  } else {
#line 327
    tmp___2 = (image->y0 + (OPJ_UINT32 )(image_height - 1U) * (OPJ_UINT32 )subsampling_dy) + 1U;
  }
#line 327
  image->y1 = tmp___2;
#line 330
  y = (unsigned int )0;
  {
#line 330
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 330
    if (! (y < image_height)) {
#line 330
      goto while_break___0;
    }
#line 334
    if (flip_image) {
#line 335
      index___21 = (int )(((image_height - y) - 1U) * image_width);
    } else {
#line 337
      index___21 = (int )(y * image_width);
    }
#line 339
    if (numcomps == 3) {
#line 341
      x = (unsigned int )0;
      {
#line 341
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 341
        if (! (x < image_width)) {
#line 341
          goto while_break___1;
        }
        {
#line 345
        __cil_tmp31 = fread(& b, (unsigned long )1, (unsigned long )1, f);
        }
#line 345
        if (! __cil_tmp31) {
          {
#line 347
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 348
          opj_image_destroy(image);
          }
#line 349
          return ((opj_image_t *)((void *)0));
        }
        {
#line 351
        __cil_tmp32 = fread(& g, (unsigned long )1, (unsigned long )1, f);
        }
#line 351
        if (! __cil_tmp32) {
          {
#line 353
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 354
          opj_image_destroy(image);
          }
#line 355
          return ((opj_image_t *)((void *)0));
        }
        {
#line 357
        __cil_tmp33 = fread(& r, (unsigned long )1, (unsigned long )1, f);
        }
#line 357
        if (! __cil_tmp33) {
          {
#line 359
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 360
          opj_image_destroy(image);
          }
#line 361
          return ((opj_image_t *)((void *)0));
        }
#line 364
        *((image->comps + 0)->data + index___21) = (OPJ_INT32 )r;
#line 365
        *((image->comps + 1)->data + index___21) = (OPJ_INT32 )g;
#line 366
        *((image->comps + 2)->data + index___21) = (OPJ_INT32 )b;
#line 367
        index___21 ++;
#line 341
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 370
    if (numcomps == 4) {
#line 372
      x = (unsigned int )0;
      {
#line 372
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 372
        if (! (x < image_width)) {
#line 372
          goto while_break___2;
        }
        {
#line 375
        __cil_tmp40 = fread(& b___0, (unsigned long )1, (unsigned long )1, f);
        }
#line 375
        if (! __cil_tmp40) {
          {
#line 377
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 378
          opj_image_destroy(image);
          }
#line 379
          return ((opj_image_t *)((void *)0));
        }
        {
#line 381
        __cil_tmp41 = fread(& g___0, (unsigned long )1, (unsigned long )1, f);
        }
#line 381
        if (! __cil_tmp41) {
          {
#line 383
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 384
          opj_image_destroy(image);
          }
#line 385
          return ((opj_image_t *)((void *)0));
        }
        {
#line 387
        __cil_tmp42 = fread(& r___0, (unsigned long )1, (unsigned long )1, f);
        }
#line 387
        if (! __cil_tmp42) {
          {
#line 389
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 390
          opj_image_destroy(image);
          }
#line 391
          return ((opj_image_t *)((void *)0));
        }
        {
#line 393
        __cil_tmp43 = fread(& a, (unsigned long )1, (unsigned long )1, f);
        }
#line 393
        if (! __cil_tmp43) {
          {
#line 395
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 396
          opj_image_destroy(image);
          }
#line 397
          return ((opj_image_t *)((void *)0));
        }
#line 400
        *((image->comps + 0)->data + index___21) = (OPJ_INT32 )r___0;
#line 401
        *((image->comps + 1)->data + index___21) = (OPJ_INT32 )g___0;
#line 402
        *((image->comps + 2)->data + index___21) = (OPJ_INT32 )b___0;
#line 403
        *((image->comps + 3)->data + index___21) = (OPJ_INT32 )a;
#line 404
        index___21 ++;
#line 372
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 408
      fprintf(stderr, "Currently unsupported bit depth : %s\n", filename);
      }
    }
#line 330
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 411
  return (image);
}
}
#line 414 "/root/patron/new_21/src/bin/jp2/convert.c"
int imagetotga(opj_image_t *image , char const   *outfile ) 
{ 
  int width ;
  int height ;
  int bpp ;
  int x ;
  int y ;
  OPJ_BOOL write_alpha ;
  unsigned int i ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int fails ;
  unsigned int alpha_channel ;
  float r ;
  float g ;
  float b ;
  float a ;
  unsigned char value ;
  float scale ;
  FILE *fdest ;
  size_t res ;
  FILE *__cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  int tmp ;
  int __cil_tmp26 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int index___22 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  int __cil_tmp37 ;

  {
  {
#line 425
  fails = 1;
#line 427
  fdest = fopen(outfile, "wb");
  }
#line 428
  if (! fdest) {
    {
#line 429
    fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
    }
#line 430
    return (1);
  }
#line 433
  i = (unsigned int )0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (! (i < image->numcomps - 1U)) {
#line 433
      goto while_break;
    }
#line 434
    if ((image->comps + 0)->dx != (image->comps + (i + 1U))->dx) {
      {
      {
      {
#line 437
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
      }
      }
#line 438
      return (1);
    } else
#line 434
    if ((image->comps + 0)->dy != (image->comps + (i + 1U))->dy) {
      {
      {
      {
#line 437
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
      }
      }
#line 438
      return (1);
    } else
#line 434
    if ((image->comps + 0)->prec != (image->comps + (i + 1U))->prec) {
      {
      {
      {
#line 437
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
      }
      }
#line 438
      return (1);
    }
#line 433
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  width = (int )(image->comps + 0)->w;
#line 443
  height = (int )(image->comps + 0)->h;
#line 446
  write_alpha = image->numcomps == 2U || image->numcomps == 4U;
#line 449
  if (write_alpha) {
#line 449
    tmp = 32;
  } else {
#line 449
    tmp = 24;
  }
  {
#line 449
  bpp = tmp;
#line 451
  __cil_tmp26 = tga_writeheader(fdest, bpp, width, height, 1);
  }
#line 451
  if (! __cil_tmp26) {
#line 452
    goto fin;
  }
#line 454
  alpha_channel = image->numcomps - 1U;
#line 456
  scale = 255.f / (float )((1 << (image->comps + 0)->prec) - 1);
#line 458
  if ((image->comps + 0)->sgnd) {
#line 458
    tmp___0 = 1 << ((image->comps + 0)->prec - 1U);
  } else {
#line 458
    tmp___0 = 0;
  }
#line 458
  adjustR = tmp___0;
#line 459
  if ((image->comps + 1)->sgnd) {
#line 459
    tmp___1 = 1 << ((image->comps + 1)->prec - 1U);
  } else {
#line 459
    tmp___1 = 0;
  }
#line 459
  adjustG = tmp___1;
#line 460
  if ((image->comps + 2)->sgnd) {
#line 460
    tmp___2 = 1 << ((image->comps + 2)->prec - 1U);
  } else {
#line 460
    tmp___2 = 0;
  }
#line 460
  adjustB = tmp___2;
#line 462
  y = 0;
  {
#line 462
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 462
    if (! (y < height)) {
#line 462
      goto while_break___0;
    }
#line 464
    index___22 = (unsigned int )(y * width);
#line 466
    x = 0;
    {
#line 466
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 466
      if (! (x < width)) {
#line 466
        goto while_break___1;
      }
#line 468
      r = (float )(*((image->comps + 0)->data + index___22) + adjustR);
#line 470
      if (image->numcomps > 2U) {
#line 472
        g = (float )(*((image->comps + 1)->data + index___22) + adjustG);
#line 473
        b = (float )(*((image->comps + 2)->data + index___22) + adjustB);
      } else {
#line 477
        g = r;
#line 478
        b = r;
      }
#line 482
      if ((double )b > 255.) {
#line 482
        b = (float )255.;
      } else
#line 482
      if ((double )b < 0.) {
#line 482
        b = (float )0.;
      }
      {
#line 483
      value = (unsigned char )(b * scale);
#line 484
      res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 486
      if (res < 1UL) {
        {
#line 488
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 489
        goto fin;
      }
#line 491
      if ((double )g > 255.) {
#line 491
        g = (float )255.;
      } else
#line 491
      if ((double )g < 0.) {
#line 491
        g = (float )0.;
      }
      {
#line 492
      value = (unsigned char )(g * scale);
#line 493
      res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 495
      if (res < 1UL) {
        {
#line 497
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 498
        goto fin;
      }
#line 500
      if ((double )r > 255.) {
#line 500
        r = (float )255.;
      } else
#line 500
      if ((double )r < 0.) {
#line 500
        r = (float )0.;
      }
      {
#line 501
      value = (unsigned char )(r * scale);
#line 502
      res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 504
      if (res < 1UL) {
        {
#line 506
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 507
        goto fin;
      }
#line 510
      if (write_alpha) {
#line 512
        a = (float )*((image->comps + alpha_channel)->data + index___22);
#line 513
        if ((double )a > 255.) {
#line 513
          a = (float )255.;
        } else
#line 513
        if ((double )a < 0.) {
#line 513
          a = (float )0.;
        }
        {
#line 514
        value = (unsigned char )(a * scale);
#line 515
        res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
        }
#line 517
        if (res < 1UL) {
          {
#line 519
          fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
          }
#line 520
          goto fin;
        }
      }
#line 466
      __cil_tmp36 = index___22;
#line 466
      index___22 ++;
#line 466
      __cil_tmp35 = x;
#line 466
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 462
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 525
  fails = 0;
  fin: 
  {
#line 527
  fclose(fdest);
  }
#line 529
  return (fails);
}
}
#line 566 "/root/patron/new_21/src/bin/jp2/convert.c"
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[3] ;
  opj_image_t *image ;
  FILE *IN ;
  BITMAPFILEHEADER_t File_h ;
  BITMAPINFOHEADER_t Info_h ;
  unsigned char *RGB ;
  unsigned char *table_R ;
  unsigned char *table_G ;
  unsigned char *table_B ;
  unsigned int j ;
  unsigned int PAD ;
  unsigned int x ;
  unsigned int y ;
  int index___23 ;
  int gray_scale ;
  int has_color ;
  DWORD W ;
  DWORD H ;
  FILE *__cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  opj_image_t *__cil_tmp84 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 tmp___0 ;
  unsigned int tmp___1 ;
  void *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned char *scanline ;
  unsigned char *pixel ;
  int __cil_tmp92 ;
  unsigned int __cil_tmp93 ;
  unsigned int __cil_tmp94 ;
  void *__cil_tmp95 ;
  void *__cil_tmp96 ;
  void *__cil_tmp97 ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  unsigned int __cil_tmp101 ;
  DWORD __cil_tmp102 ;
  int tmp___2 ;
  int tmp___3 ;
  int __cil_tmp105 ;
  opj_image_t *__cil_tmp106 ;
  OPJ_UINT32 tmp___4 ;
  OPJ_UINT32 tmp___5 ;
  void *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  int __cil_tmp111 ;
  unsigned int __cil_tmp112 ;
  unsigned char pixel_index ;
  int __cil_tmp114 ;
  unsigned int __cil_tmp115 ;
  unsigned char *pix ;
  unsigned char *beyond ;
  int *gray ;
  int *red ;
  int *green ;
  int *blue ;
  unsigned int max ;
  int c ;
  int c1 ;
  unsigned char uc ;
  void *__cil_tmp126 ;
  void *__cil_tmp127 ;
  void *__cil_tmp128 ;
  int __cil_tmp129 ;
  int __cil_tmp130 ;
  int __cil_tmp131 ;
  unsigned int __cil_tmp132 ;
  int tmp___6 ;
  int tmp___7 ;
  int __cil_tmp135 ;
  opj_image_t *__cil_tmp136 ;
  OPJ_UINT32 tmp___8 ;
  OPJ_UINT32 tmp___9 ;
  void *__cil_tmp139 ;
  int __cil_tmp140 ;
  int __cil_tmp141 ;
  int __cil_tmp142 ;
  unsigned int __cil_tmp143 ;
  unsigned char *__cil_tmp144 ;
  int __cil_tmp145 ;
  int __cil_tmp146 ;
  int __cil_tmp147 ;
  int __cil_tmp148 ;
  int __cil_tmp149 ;
  unsigned int __cil_tmp150 ;
  unsigned char *__cil_tmp151 ;
  unsigned int __cil_tmp152 ;
  unsigned char *__cil_tmp153 ;
  int *__cil_tmp154 ;
  unsigned int __cil_tmp155 ;
  unsigned char *__cil_tmp156 ;
  int *__cil_tmp157 ;
  int *__cil_tmp158 ;
  int *__cil_tmp159 ;

  {
  {
#line 568
  subsampling_dx = parameters->subsampling_dx;
#line 569
  subsampling_dy = parameters->subsampling_dy;
#line 574
  image = (opj_image_t *)((void *)0);
#line 581
  PAD = (unsigned int )0;
#line 585
  gray_scale = 1;
#line 589
  IN = fopen(filename, "rb\223j\347U");
  }
#line 590
  if (! IN) {
    {
#line 592
    fprintf(stderr, "Failed to open %s for reading !!\n7\223j\347U", filename);
    }
#line 593
    return ((opj_image_t *)((void *)0));
  }
  {
#line 596
  __cil_tmp29 = getc(IN);
#line 596
  File_h.bfType = (WORD )__cil_tmp29;
#line 597
  __cil_tmp30 = getc(IN);
#line 597
  File_h.bfType = (WORD )((__cil_tmp30 << 8) + (int )File_h.bfType);
  }
#line 599
  if ((int )File_h.bfType != 19778) {
    {
#line 601
    fprintf(stderr, "Error, not a BMP file!\n");
#line 602
    fclose(IN);
    }
#line 603
    return ((opj_image_t *)((void *)0));
  }
  {
#line 607
  __cil_tmp31 = getc(IN);
#line 607
  File_h.bfSize = (DWORD )__cil_tmp31;
#line 608
  __cil_tmp32 = getc(IN);
#line 608
  File_h.bfSize = (DWORD )(__cil_tmp32 << 8) + File_h.bfSize;
#line 609
  __cil_tmp33 = getc(IN);
#line 609
  File_h.bfSize = (DWORD )(__cil_tmp33 << 16) + File_h.bfSize;
#line 610
  __cil_tmp34 = getc(IN);
#line 610
  File_h.bfSize = (DWORD )(__cil_tmp34 << 24) + File_h.bfSize;
#line 612
  __cil_tmp35 = getc(IN);
#line 612
  File_h.bfReserved1 = (WORD )__cil_tmp35;
#line 613
  __cil_tmp36 = getc(IN);
#line 613
  File_h.bfReserved1 = (WORD )((__cil_tmp36 << 8) + (int )File_h.bfReserved1);
#line 615
  __cil_tmp37 = getc(IN);
#line 615
  File_h.bfReserved2 = (WORD )__cil_tmp37;
#line 616
  __cil_tmp38 = getc(IN);
#line 616
  File_h.bfReserved2 = (WORD )((__cil_tmp38 << 8) + (int )File_h.bfReserved2);
#line 618
  __cil_tmp39 = getc(IN);
#line 618
  File_h.bfOffBits = (DWORD )__cil_tmp39;
#line 619
  __cil_tmp40 = getc(IN);
#line 619
  File_h.bfOffBits = (DWORD )(__cil_tmp40 << 8) + File_h.bfOffBits;
#line 620
  __cil_tmp41 = getc(IN);
#line 620
  File_h.bfOffBits = (DWORD )(__cil_tmp41 << 16) + File_h.bfOffBits;
#line 621
  __cil_tmp42 = getc(IN);
#line 621
  File_h.bfOffBits = (DWORD )(__cil_tmp42 << 24) + File_h.bfOffBits;
#line 626
  __cil_tmp43 = getc(IN);
#line 626
  Info_h.biSize = (DWORD )__cil_tmp43;
#line 627
  __cil_tmp44 = getc(IN);
#line 627
  Info_h.biSize = (DWORD )(__cil_tmp44 << 8) + Info_h.biSize;
#line 628
  __cil_tmp45 = getc(IN);
#line 628
  Info_h.biSize = (DWORD )(__cil_tmp45 << 16) + Info_h.biSize;
#line 629
  __cil_tmp46 = getc(IN);
#line 629
  Info_h.biSize = (DWORD )(__cil_tmp46 << 24) + Info_h.biSize;
  }
#line 631
  if (Info_h.biSize != 40U) {
    {
#line 633
    fprintf(stderr, "Error, unknown BMP header size %d\n", Info_h.biSize);
#line 634
    fclose(IN);
    }
#line 635
    return ((opj_image_t *)((void *)0));
  }
  {
#line 637
  __cil_tmp47 = getc(IN);
#line 637
  Info_h.biWidth = (DWORD )__cil_tmp47;
#line 638
  __cil_tmp48 = getc(IN);
#line 638
  Info_h.biWidth = (DWORD )(__cil_tmp48 << 8) + Info_h.biWidth;
#line 639
  __cil_tmp49 = getc(IN);
#line 639
  Info_h.biWidth = (DWORD )(__cil_tmp49 << 16) + Info_h.biWidth;
#line 640
  __cil_tmp50 = getc(IN);
#line 640
  Info_h.biWidth = (DWORD )(__cil_tmp50 << 24) + Info_h.biWidth;
#line 641
  w = (int )Info_h.biWidth;
#line 643
  __cil_tmp51 = getc(IN);
#line 643
  Info_h.biHeight = (DWORD )__cil_tmp51;
#line 644
  __cil_tmp52 = getc(IN);
#line 644
  Info_h.biHeight = (DWORD )(__cil_tmp52 << 8) + Info_h.biHeight;
#line 645
  __cil_tmp53 = getc(IN);
#line 645
  Info_h.biHeight = (DWORD )(__cil_tmp53 << 16) + Info_h.biHeight;
#line 646
  __cil_tmp54 = getc(IN);
#line 646
  Info_h.biHeight = (DWORD )(__cil_tmp54 << 24) + Info_h.biHeight;
#line 647
  h = (int )Info_h.biHeight;
#line 649
  __cil_tmp55 = getc(IN);
#line 649
  Info_h.biPlanes = (WORD )__cil_tmp55;
#line 650
  __cil_tmp56 = getc(IN);
#line 650
  Info_h.biPlanes = (WORD )((__cil_tmp56 << 8) + (int )Info_h.biPlanes);
#line 652
  __cil_tmp57 = getc(IN);
#line 652
  Info_h.biBitCount = (WORD )__cil_tmp57;
#line 653
  __cil_tmp58 = getc(IN);
#line 653
  Info_h.biBitCount = (WORD )((__cil_tmp58 << 8) + (int )Info_h.biBitCount);
#line 655
  __cil_tmp59 = getc(IN);
#line 655
  Info_h.biCompression = (DWORD )__cil_tmp59;
#line 656
  __cil_tmp60 = getc(IN);
#line 656
  Info_h.biCompression = (DWORD )(__cil_tmp60 << 8) + Info_h.biCompression;
#line 657
  __cil_tmp61 = getc(IN);
#line 657
  Info_h.biCompression = (DWORD )(__cil_tmp61 << 16) + Info_h.biCompression;
#line 658
  __cil_tmp62 = getc(IN);
#line 658
  Info_h.biCompression = (DWORD )(__cil_tmp62 << 24) + Info_h.biCompression;
#line 660
  __cil_tmp63 = getc(IN);
#line 660
  Info_h.biSizeImage = (DWORD )__cil_tmp63;
#line 661
  __cil_tmp64 = getc(IN);
#line 661
  Info_h.biSizeImage = (DWORD )(__cil_tmp64 << 8) + Info_h.biSizeImage;
#line 662
  __cil_tmp65 = getc(IN);
#line 662
  Info_h.biSizeImage = (DWORD )(__cil_tmp65 << 16) + Info_h.biSizeImage;
#line 663
  __cil_tmp66 = getc(IN);
#line 663
  Info_h.biSizeImage = (DWORD )(__cil_tmp66 << 24) + Info_h.biSizeImage;
#line 665
  __cil_tmp67 = getc(IN);
#line 665
  Info_h.biXpelsPerMeter = (DWORD )__cil_tmp67;
#line 666
  __cil_tmp68 = getc(IN);
#line 666
  Info_h.biXpelsPerMeter = (DWORD )(__cil_tmp68 << 8) + Info_h.biXpelsPerMeter;
#line 667
  __cil_tmp69 = getc(IN);
#line 667
  Info_h.biXpelsPerMeter = (DWORD )(__cil_tmp69 << 16) + Info_h.biXpelsPerMeter;
#line 668
  __cil_tmp70 = getc(IN);
#line 668
  Info_h.biXpelsPerMeter = (DWORD )(__cil_tmp70 << 24) + Info_h.biXpelsPerMeter;
#line 670
  __cil_tmp71 = getc(IN);
#line 670
  Info_h.biYpelsPerMeter = (DWORD )__cil_tmp71;
#line 671
  __cil_tmp72 = getc(IN);
#line 671
  Info_h.biYpelsPerMeter = (DWORD )(__cil_tmp72 << 8) + Info_h.biYpelsPerMeter;
#line 672
  __cil_tmp73 = getc(IN);
#line 672
  Info_h.biYpelsPerMeter = (DWORD )(__cil_tmp73 << 16) + Info_h.biYpelsPerMeter;
#line 673
  __cil_tmp74 = getc(IN);
#line 673
  Info_h.biYpelsPerMeter = (DWORD )(__cil_tmp74 << 24) + Info_h.biYpelsPerMeter;
#line 675
  __cil_tmp75 = getc(IN);
#line 675
  Info_h.biClrUsed = (DWORD )__cil_tmp75;
#line 676
  __cil_tmp76 = getc(IN);
#line 676
  Info_h.biClrUsed = (DWORD )(__cil_tmp76 << 8) + Info_h.biClrUsed;
#line 677
  __cil_tmp77 = getc(IN);
#line 677
  Info_h.biClrUsed = (DWORD )(__cil_tmp77 << 16) + Info_h.biClrUsed;
#line 678
  __cil_tmp78 = getc(IN);
#line 678
  Info_h.biClrUsed = (DWORD )(__cil_tmp78 << 24) + Info_h.biClrUsed;
#line 680
  __cil_tmp79 = getc(IN);
#line 680
  Info_h.biClrImportant = (DWORD )__cil_tmp79;
#line 681
  __cil_tmp80 = getc(IN);
#line 681
  Info_h.biClrImportant = (DWORD )(__cil_tmp80 << 8) + Info_h.biClrImportant;
#line 682
  __cil_tmp81 = getc(IN);
#line 682
  Info_h.biClrImportant = (DWORD )(__cil_tmp81 << 16) + Info_h.biClrImportant;
#line 683
  __cil_tmp82 = getc(IN);
#line 683
  Info_h.biClrImportant = (DWORD )(__cil_tmp82 << 24) + Info_h.biClrImportant;
  }
#line 687
  if ((int )Info_h.biBitCount == 24) {
    {
#line 689
    numcomps = 3;
#line 690
    color_space = (OPJ_COLOR_SPACE )1;
#line 692
    memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 693
    i = 0;
    }
    {
#line 693
    while (1) {
      while_continue: /* CIL Label */ ;
#line 693
      if (! (i < numcomps)) {
#line 693
        goto while_break;
      }
#line 695
      cmptparm[i].prec = (OPJ_UINT32 )8;
#line 696
      cmptparm[i].bpp = (OPJ_UINT32 )8;
#line 697
      cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 698
      cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 699
      cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 700
      cmptparm[i].w = (OPJ_UINT32 )w;
#line 701
      cmptparm[i].h = (OPJ_UINT32 )h;
#line 693
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 704
    image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
    }
#line 705
    if (! image) {
      {
#line 707
      fclose(IN);
      }
#line 708
      return ((opj_image_t *)((void *)0));
    }
#line 712
    image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 713
    image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 714
    if (! image->x0) {
#line 714
      tmp = (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx + 1U;
    } else {
#line 714
      tmp = (image->x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
    }
#line 714
    image->x1 = tmp;
#line 715
    if (! image->y0) {
#line 715
      tmp___0 = (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy + 1U;
    } else {
#line 715
      tmp___0 = (image->y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
    }
    {
#line 715
    image->y1 = tmp___0;
#line 720
    fseek(IN, (long )0, 0);
#line 721
    fseek(IN, (long )File_h.bfOffBits, 0);
#line 723
    W = Info_h.biWidth;
#line 724
    H = Info_h.biHeight;
    }
#line 728
    if ((3U * W) % 4U) {
#line 728
      tmp___1 = 4U - (3U * W) % 4U;
    } else {
#line 728
      tmp___1 = (unsigned int )0;
    }
    {
#line 728
    PAD = tmp___1;
#line 730
    __cil_tmp88 = malloc((unsigned long )((3U * W + PAD) * H) * sizeof(unsigned char ));
#line 730
    RGB = (unsigned char *)__cil_tmp88;
#line 733
    __cil_tmp89 = fread(RGB, sizeof(unsigned char ), (unsigned long )((3U * W + PAD) * H),
                        IN);
    }
#line 733
    if (__cil_tmp89 != (unsigned long )((3U * W + PAD) * H)) {
      {
#line 735
      free(RGB);
#line 736
      opj_image_destroy(image);
#line 737
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
      }
#line 738
      return ((opj_image_t *)((void *)0));
    }
#line 741
    index___23 = 0;
#line 743
    y = (unsigned int )0;
    {
#line 743
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 743
      if (! (y < H)) {
#line 743
        goto while_break___0;
      }
#line 745
      scanline = RGB + (3U * (unsigned int )W + PAD) * (((unsigned int )H - 1U) - (unsigned int )y);
#line 746
      x = (unsigned int )0;
      {
#line 746
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 746
        if (! (x < W)) {
#line 746
          goto while_break___1;
        }
#line 748
        pixel = scanline + 3U * x;
#line 749
        *((image->comps + 0)->data + index___23) = (OPJ_INT32 )*(pixel + 2);
#line 750
        *((image->comps + 1)->data + index___23) = (OPJ_INT32 )*(pixel + 1);
#line 751
        *((image->comps + 2)->data + index___23) = (OPJ_INT32 )*(pixel + 0);
#line 752
        index___23 ++;
#line 746
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 743
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 755
    free(RGB);
    }
  } else
#line 758
  if ((int )Info_h.biBitCount == 8) {
#line 758
    if (Info_h.biCompression == 0U) {
#line 760
      if (Info_h.biClrUsed == 0U) {
#line 760
        Info_h.biClrUsed = (DWORD )256;
      } else
#line 762
      if (Info_h.biClrUsed > 256U) {
#line 762
        Info_h.biClrUsed = (DWORD )256;
      }
      {
#line 764
      __cil_tmp95 = malloc(256UL * sizeof(unsigned char ));
#line 764
      table_R = (unsigned char *)__cil_tmp95;
#line 765
      __cil_tmp96 = malloc(256UL * sizeof(unsigned char ));
#line 765
      table_G = (unsigned char *)__cil_tmp96;
#line 766
      __cil_tmp97 = malloc(256UL * sizeof(unsigned char ));
#line 766
      table_B = (unsigned char *)__cil_tmp97;
#line 768
      has_color = 0;
#line 769
      j = (unsigned int )0;
      }
      {
#line 769
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 769
        if (! (j < Info_h.biClrUsed)) {
#line 769
          goto while_break___2;
        }
        {
#line 771
        __cil_tmp98 = getc(IN);
#line 771
        *(table_B + j) = (unsigned char )__cil_tmp98;
#line 772
        __cil_tmp99 = getc(IN);
#line 772
        *(table_G + j) = (unsigned char )__cil_tmp99;
#line 773
        __cil_tmp100 = getc(IN);
#line 773
        *(table_R + j) = (unsigned char )__cil_tmp100;
#line 774
        getc(IN);
#line 775
        has_color += ! ((int )*(table_R + j) == (int )*(table_G + j) && (int )*(table_R + j) == (int )*(table_B + j));
        }
#line 769
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 778
      if (has_color) {
#line 778
        gray_scale = 0;
      }
      {
#line 781
      fseek(IN, (long )0, 0);
#line 782
      fseek(IN, (long )File_h.bfOffBits, 0);
#line 784
      W = Info_h.biWidth;
#line 785
      H = Info_h.biHeight;
      }
#line 786
      if (Info_h.biWidth % 2U) {
#line 787
        W ++;
      }
#line 789
      if (gray_scale) {
#line 789
        tmp___2 = 1;
      } else {
#line 789
        tmp___2 = 3;
      }
#line 789
      numcomps = tmp___2;
#line 790
      if (gray_scale) {
#line 790
        tmp___3 = 2;
      } else {
#line 790
        tmp___3 = 1;
      }
      {
#line 790
      color_space = (OPJ_COLOR_SPACE )tmp___3;
#line 792
      memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 793
      i = 0;
      }
      {
#line 793
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 793
        if (! (i < numcomps)) {
#line 793
          goto while_break___3;
        }
#line 795
        cmptparm[i].prec = (OPJ_UINT32 )8;
#line 796
        cmptparm[i].bpp = (OPJ_UINT32 )8;
#line 797
        cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 798
        cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 799
        cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 800
        cmptparm[i].w = (OPJ_UINT32 )w;
#line 801
        cmptparm[i].h = (OPJ_UINT32 )h;
#line 793
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 804
      image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
      }
#line 805
      if (! image) {
        {
#line 807
        fclose(IN);
#line 808
        free(table_R);
#line 808
        free(table_G);
#line 808
        free(table_B);
        }
#line 809
        return ((opj_image_t *)((void *)0));
      }
#line 813
      image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 814
      image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 815
      if (! image->x0) {
#line 815
        tmp___4 = (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx + 1U;
      } else {
#line 815
        tmp___4 = (image->x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
      }
#line 815
      image->x1 = tmp___4;
#line 816
      if (! image->y0) {
#line 816
        tmp___5 = (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy + 1U;
      } else {
#line 816
        tmp___5 = (image->y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
      }
      {
#line 816
      image->y1 = tmp___5;
#line 820
      __cil_tmp109 = malloc((unsigned long )(W * H) * sizeof(unsigned char ));
#line 820
      RGB = (unsigned char *)__cil_tmp109;
#line 822
      __cil_tmp110 = fread(RGB, sizeof(unsigned char ), (unsigned long )(W * H), IN);
      }
#line 822
      if (__cil_tmp110 != (unsigned long )(W * H)) {
        {
#line 824
        free(table_R);
#line 825
        free(table_G);
#line 826
        free(table_B);
#line 827
        free(RGB);
#line 828
        opj_image_destroy(image);
#line 829
        fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
        }
#line 830
        return ((opj_image_t *)((void *)0));
      }
#line 832
      if (gray_scale) {
#line 834
        index___23 = 0;
#line 835
        j = (unsigned int )0;
        {
#line 835
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 835
          if (! (j < W * H)) {
#line 835
            goto while_break___4;
          }
#line 837
          if (j % W < W - 1U) {
#line 837
            if (Info_h.biWidth % 2U) {
#line 839
              *((image->comps + 0)->data + index___23) = (OPJ_INT32 )*(table_R + *(RGB + ((W * H - (j / W + 1U) * W) + j % W)));
#line 841
              index___23 ++;
            } else {
#line 837
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 837
          if (! (Info_h.biWidth % 2U)) {
#line 839
            *((image->comps + 0)->data + index___23) = (OPJ_INT32 )*(table_R + *(RGB + ((W * H - (j / W + 1U) * W) + j % W)));
#line 841
            index___23 ++;
          }
#line 835
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
#line 848
        index___23 = 0;
#line 849
        j = (unsigned int )0;
        {
#line 849
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 849
          if (! (j < W * H)) {
#line 849
            goto while_break___5;
          }
#line 851
          if (j % W < W - 1U) {
#line 851
            if (Info_h.biWidth % 2U) {
#line 854
              pixel_index = *(RGB + ((W * H - (j / W + 1U) * W) + j % W));
#line 856
              *((image->comps + 0)->data + index___23) = (OPJ_INT32 )*(table_R + pixel_index);
#line 857
              *((image->comps + 1)->data + index___23) = (OPJ_INT32 )*(table_G + pixel_index);
#line 858
              *((image->comps + 2)->data + index___23) = (OPJ_INT32 )*(table_B + pixel_index);
#line 859
              index___23 ++;
            } else {
#line 851
              goto _L___24;
            }
          } else
          _L___24: /* CIL Label */ 
#line 851
          if (! (Info_h.biWidth % 2U)) {
#line 854
            pixel_index = *(RGB + ((W * H - (j / W + 1U) * W) + j % W));
#line 856
            *((image->comps + 0)->data + index___23) = (OPJ_INT32 )*(table_R + pixel_index);
#line 857
            *((image->comps + 1)->data + index___23) = (OPJ_INT32 )*(table_G + pixel_index);
#line 858
            *((image->comps + 2)->data + index___23) = (OPJ_INT32 )*(table_B + pixel_index);
#line 859
            index___23 ++;
          }
#line 849
          j ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
      {
#line 863
      free(RGB);
#line 864
      free(table_R);
#line 865
      free(table_G);
#line 866
      free(table_B);
      }
    } else {
#line 758
      goto _L___25;
    }
  } else
  _L___25: /* CIL Label */ 
#line 869
  if ((int )Info_h.biBitCount == 8) {
#line 869
    if (Info_h.biCompression == 1U) {
#line 877
      if (Info_h.biClrUsed == 0U) {
#line 878
        Info_h.biClrUsed = (DWORD )256;
      } else
#line 879
      if (Info_h.biClrUsed > 256U) {
#line 880
        Info_h.biClrUsed = (DWORD )256;
      }
      {
#line 882
      __cil_tmp126 = malloc(256UL * sizeof(unsigned char ));
#line 882
      table_R = (unsigned char *)__cil_tmp126;
#line 883
      __cil_tmp127 = malloc(256UL * sizeof(unsigned char ));
#line 883
      table_G = (unsigned char *)__cil_tmp127;
#line 884
      __cil_tmp128 = malloc(256UL * sizeof(unsigned char ));
#line 884
      table_B = (unsigned char *)__cil_tmp128;
#line 886
      has_color = 0;
#line 887
      j = (unsigned int )0;
      }
      {
#line 887
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 887
        if (! (j < Info_h.biClrUsed)) {
#line 887
          goto while_break___6;
        }
        {
#line 889
        __cil_tmp129 = getc(IN);
#line 889
        *(table_B + j) = (unsigned char )__cil_tmp129;
#line 890
        __cil_tmp130 = getc(IN);
#line 890
        *(table_G + j) = (unsigned char )__cil_tmp130;
#line 891
        __cil_tmp131 = getc(IN);
#line 891
        *(table_R + j) = (unsigned char )__cil_tmp131;
#line 892
        getc(IN);
#line 893
        has_color += ! ((int )*(table_R + j) == (int )*(table_G + j) && (int )*(table_R + j) == (int )*(table_B + j));
        }
#line 887
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 896
      if (has_color) {
#line 897
        gray_scale = 0;
      }
#line 899
      if (gray_scale) {
#line 899
        tmp___6 = 1;
      } else {
#line 899
        tmp___6 = 3;
      }
#line 899
      numcomps = tmp___6;
#line 900
      if (gray_scale) {
#line 900
        tmp___7 = 2;
      } else {
#line 900
        tmp___7 = 1;
      }
      {
#line 900
      color_space = (OPJ_COLOR_SPACE )tmp___7;
#line 902
      memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 903
      i = 0;
      }
      {
#line 903
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 903
        if (! (i < numcomps)) {
#line 903
          goto while_break___7;
        }
#line 905
        cmptparm[i].prec = (OPJ_UINT32 )8;
#line 906
        cmptparm[i].bpp = (OPJ_UINT32 )8;
#line 907
        cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 908
        cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 909
        cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 910
        cmptparm[i].w = (OPJ_UINT32 )w;
#line 911
        cmptparm[i].h = (OPJ_UINT32 )h;
#line 903
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 914
      image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
      }
#line 915
      if (! image) {
        {
#line 917
        fclose(IN);
#line 918
        free(table_R);
#line 919
        free(table_G);
#line 920
        free(table_B);
        }
#line 921
        return ((opj_image_t *)((void *)0));
      }
#line 925
      image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 926
      image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 927
      if (! image->x0) {
#line 927
        tmp___8 = (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx + 1U;
      } else {
#line 927
        tmp___8 = (image->x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
      }
#line 927
      image->x1 = tmp___8;
#line 928
      if (! image->y0) {
#line 928
        tmp___9 = (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy + 1U;
      } else {
#line 928
        tmp___9 = (image->y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
      }
      {
#line 928
      image->y1 = tmp___9;
#line 933
      fseek(IN, (long )0, 0);
#line 934
      fseek(IN, (long )File_h.bfOffBits, 0);
#line 936
      W = Info_h.biWidth;
#line 937
      H = Info_h.biHeight;
#line 938
      __cil_tmp139 = calloc((unsigned long )1, (unsigned long )(W * H) * sizeof(unsigned char ));
#line 938
      RGB = (unsigned char *)__cil_tmp139;
#line 939
      beyond = RGB + W * H;
#line 940
      pix = beyond - W;
#line 941
      y = (unsigned int )0;
#line 941
      x = y;
      }
      {
#line 943
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 943
        if (! (y < H)) {
#line 943
          goto while_break___8;
        }
        {
#line 945
        c = getc(IN);
        }
#line 947
        if (c) {
          {
#line 949
          c1 = getc(IN);
#line 951
          i = 0;
          }
          {
#line 951
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 951
            if (! (pix < beyond && (i < c && x < W))) {
#line 951
              goto while_break___9;
            }
#line 952
            *pix = (unsigned char )c1;
#line 951
            __cil_tmp144 = pix;
#line 951
            pix ++;
#line 951
            __cil_tmp143 = x;
#line 951
            x ++;
#line 951
            __cil_tmp142 = i;
#line 951
            i ++;
          }
          while_break___9: /* CIL Label */ ;
          }
        } else {
          {
#line 956
          c = getc(IN);
          }
#line 958
          if (c == 0) {
#line 960
            x = (unsigned int )0;
#line 961
            y ++;
#line 962
            pix = (RGB + x) + ((H - y) - 1U) * W;
          } else
#line 964
          if (c == 1) {
#line 965
            goto while_break___8;
          } else
#line 966
          if (c == 2) {
            {
#line 968
            c = getc(IN);
#line 969
            x += (unsigned int )c;
#line 970
            c = getc(IN);
#line 971
            y += (unsigned int )c;
#line 972
            pix = (RGB + ((H - y) - 1U) * W) + x;
            }
          } else {
#line 976
            i = 0;
            {
#line 977
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 977
              if (! (pix < beyond && (i < c && x < W))) {
#line 977
                goto while_break___10;
              }
              {
#line 979
              c1 = getc(IN);
#line 980
              *pix = (unsigned char )c1;
              }
#line 977
              __cil_tmp151 = pix;
#line 977
              pix ++;
#line 977
              __cil_tmp150 = x;
#line 977
              x ++;
#line 977
              __cil_tmp149 = i;
#line 977
              i ++;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 982
            if (c & 1) {
              {
#line 983
              getc(IN);
              }
            }
          }
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 988
      if (gray_scale) {
#line 990
        gray = (image->comps + 0)->data;
#line 991
        pix = RGB;
#line 992
        max = W * H;
        {
#line 994
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 994
          __cil_tmp152 = max;
#line 994
          max --;
#line 994
          if (! __cil_tmp152) {
#line 994
            goto while_break___11;
          }
#line 996
          __cil_tmp153 = pix;
#line 996
          pix ++;
#line 996
          uc = *__cil_tmp153;
#line 998
          __cil_tmp154 = gray;
#line 998
          gray ++;
#line 998
          *__cil_tmp154 = (int )*(table_R + uc);
        }
        while_break___11: /* CIL Label */ ;
        }
      } else {
#line 1005
        red = (image->comps + 0)->data;
#line 1006
        green = (image->comps + 1)->data;
#line 1007
        blue = (image->comps + 2)->data;
#line 1008
        pix = RGB;
#line 1009
        max = W * H;
        {
#line 1011
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1011
          __cil_tmp155 = max;
#line 1011
          max --;
#line 1011
          if (! __cil_tmp155) {
#line 1011
            goto while_break___12;
          }
#line 1013
          __cil_tmp156 = pix;
#line 1013
          pix ++;
#line 1013
          uc = *__cil_tmp156;
#line 1015
          __cil_tmp157 = red;
#line 1015
          red ++;
#line 1015
          *__cil_tmp157 = (int )*(table_R + uc);
#line 1016
          __cil_tmp158 = green;
#line 1016
          green ++;
#line 1016
          *__cil_tmp158 = (int )*(table_G + uc);
#line 1017
          __cil_tmp159 = blue;
#line 1017
          blue ++;
#line 1017
          *__cil_tmp159 = (int )*(table_B + uc);
        }
        while_break___12: /* CIL Label */ ;
        }
      }
      {
#line 1020
      free(RGB);
#line 1021
      free(table_R);
#line 1022
      free(table_G);
#line 1023
      free(table_B);
      }
    } else {
      {
      {
#line 1027
      fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
              (int )Info_h.biBitCount);
      }
      }
    }
  } else {
    {
    {
#line 1027
    fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
            (int )Info_h.biBitCount);
    }
    }
  }
  {
#line 1031
  fclose(IN);
  }
#line 1032
  return (image);
}
}
#line 1035 "/root/patron/new_21/src/bin/jp2/convert.c"
int imagetobmp(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int pad ;
  FILE *fdest ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  FILE *__cil_tmp11 ;
  unsigned char rc ;
  unsigned char gc ;
  unsigned char bc ;
  int r ;
  int g ;
  int b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  FILE *__cil_tmp24 ;
  int __cil_tmp25 ;
  int r___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;

  {
#line 1038
  fdest = (FILE *)((void *)0);
#line 1041
  if ((image->comps + 0)->prec < 8U) {
    {
#line 1042
    fprintf(stderr, "Unsupported number of components: %d\n", (image->comps + 0)->prec);
    }
#line 1043
    return (1);
  }
#line 1045
  if (image->numcomps >= 3U) {
#line 1045
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 1045
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 1045
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 1045
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 1045
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 1045
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
                {
#line 1056
                fdest = fopen(outfile, "wb\225j\347U");
                }
#line 1057
                if (! fdest) {
                  {
#line 1058
                  fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
                  }
#line 1059
                  return (1);
                }
                {
#line 1062
                w = (int )(image->comps + 0)->w;
#line 1063
                h = (int )(image->comps + 0)->h;
#line 1065
                fprintf(fdest, "BM\225j\347U");
#line 1069
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) + 54)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 8)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 16)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 24)) & 255);
#line 1074
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1075
                fprintf(fdest, "%c%c%c%c\251", 54, (54 >> 8) & 255, (54 >> 16) & 255,
                        (54 >> 24) & 255);
#line 1079
                fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255,
                        (40 >> 24) & 255);
#line 1080
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(w & 255)),
                        (int )((unsigned char )(w >> 8)) & 255, (int )((unsigned char )(w >> 16)) & 255,
                        (int )((unsigned char )(w >> 24)) & 255);
#line 1084
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h & 255)),
                        (int )((unsigned char )(h >> 8)) & 255, (int )((unsigned char )(h >> 16)) & 255,
                        (int )((unsigned char )(h >> 24)) & 255);
#line 1088
                fprintf(fdest, "%c%c", 1, (1 >> 8) & 255);
#line 1089
                fprintf(fdest, "%c%c", 24, (24 >> 8) & 255);
#line 1090
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1091
                fprintf(fdest, "%c%c%c%c\251", (int )((unsigned char )((3 * h) * w + (3 * h) * (w % 2))) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 8)) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 16)) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 24)) & 255);
#line 1095
                fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                        (7834 >> 24) & 255);
#line 1096
                fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                        (7834 >> 24) & 255);
#line 1097
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1098
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
                }
#line 1100
                if ((image->comps + 0)->prec > 8U) {
                  {
#line 1101
                  adjustR = (int )(image->comps + 0)->prec - 8;
#line 1102
                  printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n",
                         (image->comps + 0)->prec);
                  }
                } else {
#line 1105
                  adjustR = 0;
                }
#line 1106
                if ((image->comps + 1)->prec > 8U) {
                  {
#line 1107
                  adjustG = (int )(image->comps + 1)->prec - 8;
#line 1108
                  printf("BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\n",
                         (image->comps + 1)->prec);
                  }
                } else {
#line 1111
                  adjustG = 0;
                }
#line 1112
                if ((image->comps + 2)->prec > 8U) {
                  {
#line 1113
                  adjustB = (int )(image->comps + 2)->prec - 8;
#line 1114
                  printf("BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\n",
                         (image->comps + 2)->prec);
                  }
                } else {
#line 1117
                  adjustB = 0;
                }
#line 1119
                i = 0;
                {
#line 1119
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 1119
                  if (! (i < w * h)) {
#line 1119
                    goto while_break;
                  }
#line 1123
                  r = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1124
                  if ((image->comps + 0)->sgnd) {
#line 1124
                    tmp = 1 << ((image->comps + 0)->prec - 1U);
                  } else {
#line 1124
                    tmp = 0;
                  }
#line 1124
                  r += tmp;
#line 1125
                  r = (r >> adjustR) + (r >> (adjustR - 1)) % 2;
#line 1126
                  if (r > 255) {
#line 1126
                    r = 255;
                  } else
#line 1126
                  if (r < 0) {
#line 1126
                    r = 0;
                  }
#line 1127
                  rc = (unsigned char )r;
#line 1129
                  g = *((image->comps + 1)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1130
                  if ((image->comps + 1)->sgnd) {
#line 1130
                    tmp___0 = 1 << ((image->comps + 1)->prec - 1U);
                  } else {
#line 1130
                    tmp___0 = 0;
                  }
#line 1130
                  g += tmp___0;
#line 1131
                  g = (g >> adjustG) + (g >> (adjustG - 1)) % 2;
#line 1132
                  if (g > 255) {
#line 1132
                    g = 255;
                  } else
#line 1132
                  if (g < 0) {
#line 1132
                    g = 0;
                  }
#line 1133
                  gc = (unsigned char )g;
#line 1135
                  b = *((image->comps + 2)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1136
                  if ((image->comps + 2)->sgnd) {
#line 1136
                    tmp___1 = 1 << ((image->comps + 2)->prec - 1U);
                  } else {
#line 1136
                    tmp___1 = 0;
                  }
#line 1136
                  b += tmp___1;
#line 1137
                  b = (b >> adjustB) + (b >> (adjustB - 1)) % 2;
#line 1138
                  if (b > 255) {
#line 1138
                    b = 255;
                  } else
#line 1138
                  if (b < 0) {
#line 1138
                    b = 0;
                  }
                  {
#line 1139
                  bc = (unsigned char )b;
#line 1141
                  fprintf(fdest, "%c%c%c", (int )bc, (int )gc, (int )rc);
                  }
#line 1143
                  if ((i + 1) % w == 0) {
#line 1144
                    if ((3 * w) % 4) {
#line 1144
                      tmp___2 = 4 - (3 * w) % 4;
                    } else {
#line 1144
                      tmp___2 = 0;
                    }
#line 1144
                    pad = tmp___2;
                    {
#line 1144
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
#line 1144
                      if (! (pad > 0)) {
#line 1144
                        goto while_break___0;
                      }
                      {
#line 1145
                      fprintf(fdest, "%c\225j\347U", 0);
                      }
#line 1144
                      __cil_tmp22 = pad;
#line 1144
                      pad --;
                    }
                    while_break___0: /* CIL Label */ ;
                    }
                  }
#line 1119
                  i ++;
                }
                while_break: /* CIL Label */ ;
                }
                {
#line 1148
                fclose(fdest);
                }
              } else {
#line 1045
                goto _L;
              }
            } else {
#line 1045
              goto _L;
            }
          } else {
#line 1045
            goto _L;
          }
        } else {
#line 1045
          goto _L;
        }
      } else {
#line 1045
        goto _L;
      }
    } else {
#line 1045
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    _L___26: /* CIL Label */ 
    _L___27: /* CIL Label */ 
    _L___28: /* CIL Label */ 
    _L___29: /* CIL Label */ 
    _L___30: /* CIL Label */ 
    {
#line 1155
    fdest = fopen(outfile, "wb");
#line 1156
    w = (int )(image->comps + 0)->w;
#line 1157
    h = (int )(image->comps + 0)->h;
#line 1159
    fprintf(fdest, "BM");
#line 1163
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(((h * w + 54) + 1024) + h * (w % 2))) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + h * (w % 2)) >> 8)) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + h * (w % 2)) >> 16)) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + w * (w % 2)) >> 24)) & 255);
#line 1167
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1168
    fprintf(fdest, "%c%c%c%c\251", 54, (1078 >> 8) & 255, (1078 >> 16) & 255, (1078 >> 24) & 255);
#line 1174
    fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255, (40 >> 24) & 255);
#line 1175
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(w & 255)), (int )((unsigned char )(w >> 8)) & 255,
            (int )((unsigned char )(w >> 16)) & 255, (int )((unsigned char )(w >> 24)) & 255);
#line 1179
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h & 255)), (int )((unsigned char )(h >> 8)) & 255,
            (int )((unsigned char )(h >> 16)) & 255, (int )((unsigned char )(h >> 24)) & 255);
#line 1183
    fprintf(fdest, "%c%c", 1, (1 >> 8) & 255);
#line 1184
    fprintf(fdest, "%c%c", 8, (8 >> 8) & 255);
#line 1185
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1186
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h * w + h * (w % 2))) & 255,
            (int )((unsigned char )((h * w + h * (w % 2)) >> 8)) & 255, (int )((unsigned char )((h * w + h * (w % 2)) >> 16)) & 255,
            (int )((unsigned char )((h * w + h * (w % 2)) >> 24)) & 255);
#line 1190
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1191
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1192
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
#line 1193
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
    }
#line 1195
    if ((image->comps + 0)->prec > 8U) {
      {
#line 1196
      adjustR = (int )(image->comps + 0)->prec - 8;
#line 1197
      printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", (image->comps + 0)->prec);
      }
    } else {
#line 1199
      adjustR = 0;
    }
#line 1201
    i = 0;
    {
#line 1201
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1201
      if (! (i < 256)) {
#line 1201
        goto while_break___1;
      }
      {
#line 1202
      fprintf(fdest, "%c%c%c%c\230\001", i, i, i, 0);
      }
#line 1201
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1205
    i = 0;
    {
#line 1205
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1205
      if (! (i < w * h)) {
#line 1205
        goto while_break___2;
      }
#line 1208
      r___0 = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1209
      if ((image->comps + 0)->sgnd) {
#line 1209
        tmp___3 = 1 << ((image->comps + 0)->prec - 1U);
      } else {
#line 1209
        tmp___3 = 0;
      }
#line 1209
      r___0 += tmp___3;
#line 1210
      r___0 = (r___0 >> adjustR) + (r___0 >> (adjustR - 1)) % 2;
#line 1211
      if (r___0 > 255) {
#line 1211
        r___0 = 255;
      } else
#line 1211
      if (r___0 < 0) {
#line 1211
        r___0 = 0;
      }
      {
#line 1213
      fprintf(fdest, "%c", (int )((unsigned char )r___0));
      }
#line 1215
      if ((i + 1) % w == 0) {
#line 1216
        if (w % 4) {
#line 1216
          tmp___4 = 4 - w % 4;
        } else {
#line 1216
          tmp___4 = 0;
        }
#line 1216
        pad = tmp___4;
        {
#line 1216
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1216
          if (! (pad > 0)) {
#line 1216
            goto while_break___3;
          }
          {
#line 1217
          fprintf(fdest, "%c", 0);
          }
#line 1216
          __cil_tmp29 = pad;
#line 1216
          pad --;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1205
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1220
    fclose(fdest);
    }
  }
#line 1223
  return (0);
}
}
#line 1233 "/root/patron/new_21/src/bin/jp2/convert.c"
static unsigned char readuchar(FILE *f ) 
{ 
  unsigned char c1 ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 1236
  __cil_tmp3 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1236
  if (! __cil_tmp3) {
    {
#line 1238
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1239
    return ((unsigned char )0);
  }
#line 1241
  return (c1);
}
}
#line 1244 "/root/patron/new_21/src/bin/jp2/convert.c"
static unsigned short readushort(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 1247
  __cil_tmp5 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1247
  if (! __cil_tmp5) {
    {
#line 1249
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1250
    return ((unsigned short )0);
  }
  {
#line 1252
  __cil_tmp6 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1252
  if (! __cil_tmp6) {
    {
#line 1254
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1255
    return ((unsigned short )0);
  }
#line 1257
  if (bigendian) {
#line 1258
    return ((unsigned short )(((int )c1 << 8) + (int )c2));
  } else {
#line 1260
    return ((unsigned short )(((int )c2 << 8) + (int )c1));
  }
}
}
#line 1263 "/root/patron/new_21/src/bin/jp2/convert.c"
static unsigned int readuint(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char c3 ;
  unsigned char c4 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  {
#line 1266
  __cil_tmp7 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1266
  if (! __cil_tmp7) {
    {
#line 1268
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1269
    return ((unsigned int )0);
  }
  {
#line 1271
  __cil_tmp8 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1271
  if (! __cil_tmp8) {
    {
#line 1273
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1274
    return ((unsigned int )0);
  }
  {
#line 1276
  __cil_tmp9 = fread(& c3, (unsigned long )1, (unsigned long )1, f);
  }
#line 1276
  if (! __cil_tmp9) {
    {
#line 1278
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1279
    return ((unsigned int )0);
  }
  {
#line 1281
  __cil_tmp10 = fread(& c4, (unsigned long )1, (unsigned long )1, f);
  }
#line 1281
  if (! __cil_tmp10) {
    {
#line 1283
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1284
    return ((unsigned int )0);
  }
#line 1286
  if (bigendian) {
#line 1287
    return ((((unsigned int )((int )c1 << 24) + (unsigned int )((int )c2 << 16)) + (unsigned int )((int )c3 << 8)) + (unsigned int )c4);
  } else {
#line 1289
    return ((((unsigned int )((int )c4 << 24) + (unsigned int )((int )c3 << 16)) + (unsigned int )((int )c2 << 8)) + (unsigned int )c1);
  }
}
}
#line 1292 "/root/patron/new_21/src/bin/jp2/convert.c"
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  int w ;
  int h ;
  int prec ;
  int i ;
  int numcomps ;
  int max ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm ;
  opj_image_t *image ;
  int adjustS ;
  int ushift ;
  int dshift ;
  int force8 ;
  char endian1 ;
  char endian2 ;
  char sign ;
  char signtmp[32] ;
  char temp[32] ;
  int bigendian ;
  opj_image_comp_t *comp ;
  FILE *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 tmp___0 ;
  opj_image_t *__cil_tmp29 ;
  int v ;
  unsigned char __cil_tmp31 ;
  unsigned char __cil_tmp32 ;
  unsigned char __cil_tmp33 ;
  unsigned short __cil_tmp34 ;
  unsigned short __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;

  {
  {
#line 1293
  f = (FILE *)((void *)0);
#line 1298
  image = (opj_image_t *)((void *)0);
#line 1306
  comp = (opj_image_comp_t *)((void *)0);
#line 1308
  numcomps = 1;
#line 1309
  color_space = (OPJ_COLOR_SPACE )2;
#line 1311
  memset(& cmptparm, 0, sizeof(opj_image_cmptparm_t ));
#line 1313
  max = 0;
#line 1315
  f = fopen(filename, "rb\226j\347U");
  }
#line 1316
  if (! f) {
    {
#line 1317
    fprintf(stderr, "Failed to open %s for reading !\n\230\001", filename);
    }
#line 1318
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1321
  fseek(f, (long )0, 0);
#line 1322
  __cil_tmp25 = fscanf(f, "PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d\226j\347U", (char *)temp,
                       & endian1, & endian2, (char *)signtmp, & prec, (char *)temp,
                       & w, (char *)temp, & h);
  }
#line 1322
  if (__cil_tmp25 != 9) {
    {
#line 1323
    fprintf(stderr, "ERROR: Failed to read the right number of element from the fscanf() function!\n");
    }
#line 1324
    return ((opj_image_t *)((void *)0));
  }
#line 1327
  i = 0;
#line 1328
  sign = (char )'+';
  {
#line 1329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1329
    if (! ((int )signtmp[i] != 0)) {
#line 1329
      goto while_break;
    }
#line 1330
    if ((int )signtmp[i] == 45) {
#line 1330
      sign = (char )'-';
    }
#line 1331
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1334
  fgetc(f);
  }
#line 1335
  if ((int )endian1 == 77) {
#line 1335
    if ((int )endian2 == 76) {
#line 1336
      bigendian = 1;
    } else {
#line 1335
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1337
  if ((int )endian2 == 77) {
#line 1337
    if ((int )endian1 == 76) {
#line 1338
      bigendian = 0;
    } else {
      {
      {
#line 1340
      fprintf(stderr, "Bad pgx header, please check input file\n\220");
      }
      }
#line 1341
      return ((opj_image_t *)((void *)0));
    }
  } else {
    {
    {
#line 1340
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
    }
#line 1341
    return ((opj_image_t *)((void *)0));
  }
#line 1346
  cmptparm.x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 1347
  cmptparm.y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 1348
  if (! cmptparm.x0) {
#line 1348
    tmp = (OPJ_UINT32 )((w - 1) * parameters->subsampling_dx + 1);
  } else {
#line 1348
    tmp = (cmptparm.x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )parameters->subsampling_dx) + 1U;
  }
#line 1348
  cmptparm.w = tmp;
#line 1349
  if (! cmptparm.y0) {
#line 1349
    tmp___0 = (OPJ_UINT32 )((h - 1) * parameters->subsampling_dy + 1);
  } else {
#line 1349
    tmp___0 = (cmptparm.y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )parameters->subsampling_dy) + 1U;
  }
#line 1349
  cmptparm.h = tmp___0;
#line 1351
  if ((int )sign == 45) {
#line 1352
    cmptparm.sgnd = (OPJ_UINT32 )1;
  } else {
#line 1354
    cmptparm.sgnd = (OPJ_UINT32 )0;
  }
#line 1356
  if (prec < 8) {
#line 1358
    force8 = 1;
#line 1359
    ushift = 8 - prec;
#line 1359
    dshift = prec - ushift;
#line 1360
    if (cmptparm.sgnd) {
#line 1360
      adjustS = 1 << (prec - 1);
    } else {
#line 1360
      adjustS = 0;
    }
#line 1361
    cmptparm.sgnd = (OPJ_UINT32 )0;
#line 1362
    prec = 8;
  } else {
#line 1364
    adjustS = 0;
#line 1364
    force8 = adjustS;
#line 1364
    dshift = force8;
#line 1364
    ushift = dshift;
  }
  {
#line 1366
  cmptparm.prec = (OPJ_UINT32 )prec;
#line 1367
  cmptparm.bpp = (OPJ_UINT32 )prec;
#line 1368
  cmptparm.dx = (OPJ_UINT32 )parameters->subsampling_dx;
#line 1369
  cmptparm.dy = (OPJ_UINT32 )parameters->subsampling_dy;
#line 1372
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm, color_space);
  }
#line 1373
  if (! image) {
    {
#line 1374
    fclose(f);
    }
#line 1375
    return ((opj_image_t *)((void *)0));
  }
#line 1378
  image->x0 = cmptparm.x0;
#line 1379
  image->y0 = cmptparm.x0;
#line 1380
  image->x1 = cmptparm.w;
#line 1381
  image->y1 = cmptparm.h;
#line 1385
  comp = image->comps + 0;
#line 1387
  i = 0;
  {
#line 1387
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1387
    if (! (i < w * h)) {
#line 1387
      goto while_break___0;
    }
#line 1389
    if (force8) {
      {
#line 1391
      __cil_tmp31 = readuchar(f);
#line 1391
      v = (int )__cil_tmp31 + adjustS;
#line 1392
      v = (v << ushift) + (v >> dshift);
#line 1393
      *(comp->data + i) = (OPJ_INT32 )((unsigned char )v);
      }
#line 1395
      if (v > max) {
#line 1395
        max = v;
      }
#line 1397
      goto while_continue___0;
    }
#line 1399
    if (comp->prec == 8U) {
#line 1400
      if (! comp->sgnd) {
        {
#line 1401
        __cil_tmp32 = readuchar(f);
#line 1401
        v = (int )__cil_tmp32;
        }
      } else {
        {
#line 1403
        __cil_tmp33 = readuchar(f);
#line 1403
        v = (int )((char )__cil_tmp33);
        }
      }
    } else
#line 1405
    if (comp->prec <= 16U) {
#line 1406
      if (! comp->sgnd) {
        {
#line 1407
        __cil_tmp34 = readushort(f, bigendian);
#line 1407
        v = (int )__cil_tmp34;
        }
      } else {
        {
#line 1409
        __cil_tmp35 = readushort(f, bigendian);
#line 1409
        v = (int )((short )__cil_tmp35);
        }
      }
    } else
#line 1412
    if (! comp->sgnd) {
      {
#line 1413
      __cil_tmp36 = readuint(f, bigendian);
#line 1413
      v = (int )__cil_tmp36;
      }
    } else {
      {
#line 1415
      __cil_tmp37 = readuint(f, bigendian);
#line 1415
      v = (int )__cil_tmp37;
      }
    }
#line 1418
    if (v > max) {
#line 1419
      max = v;
    }
#line 1420
    *(comp->data + i) = v;
#line 1387
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1422
  fclose(f);
#line 1423
  __cil_tmp39 = int_floorlog2(max);
#line 1423
  comp->bpp = (OPJ_UINT32 )__cil_tmp39 + 1U;
  }
#line 1425
  return (image);
}
}
#line 1430 "/root/patron/new_21/src/bin/jp2/convert.c"
__inline static int clamp(int value , int prec , int sgnd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1432
  if (sgnd) {
#line 1434
    if (prec <= 8) {
#line 1434
      if (value < -128) {
#line 1434
        tmp___0 = - 128;
      } else {
#line 1434
        if (value > 127) {
#line 1434
          tmp = 127;
        } else {
#line 1434
          tmp = value;
        }
#line 1434
        tmp___0 = tmp;
      }
#line 1434
      return (tmp___0);
    } else
#line 1435
    if (prec <= 16) {
#line 1435
      if (value < -32768) {
#line 1435
        tmp___2 = - 32768;
      } else {
#line 1435
        if (value > 32767) {
#line 1435
          tmp___1 = 32767;
        } else {
#line 1435
          tmp___1 = value;
        }
#line 1435
        tmp___2 = tmp___1;
      }
#line 1435
      return (tmp___2);
    } else {
#line 1436
      if (value < (-0x7FFFFFFF-1)) {
#line 1436
        tmp___4 = (-0x7FFFFFFF-1);
      } else {
#line 1436
        if (value > 2147483647) {
#line 1436
          tmp___3 = 2147483647;
        } else {
#line 1436
          tmp___3 = value;
        }
#line 1436
        tmp___4 = tmp___3;
      }
#line 1436
      return (tmp___4);
    }
  } else
#line 1440
  if (prec <= 8) {
#line 1440
    if (value < 0) {
#line 1440
      tmp___6 = 0;
    } else {
#line 1440
      if (value > 255) {
#line 1440
        tmp___5 = 255;
      } else {
#line 1440
        tmp___5 = value;
      }
#line 1440
      tmp___6 = tmp___5;
    }
#line 1440
    return (tmp___6);
  } else
#line 1441
  if (prec <= 16) {
#line 1441
    if (value < 0) {
#line 1441
      tmp___8 = 0;
    } else {
#line 1441
      if (value > 65535) {
#line 1441
        tmp___7 = 65535;
      } else {
#line 1441
        tmp___7 = value;
      }
#line 1441
      tmp___8 = tmp___7;
    }
#line 1441
    return (tmp___8);
  } else {
#line 1442
    return (value);
  }
}
}
#line 1446 "/root/patron/new_21/src/bin/jp2/convert.c"
int imagetopgx(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int j ;
  int fails ;
  unsigned int compno ;
  FILE *fdest ;
  opj_image_comp_t *comp ;
  char bname[256] ;
  char *name ;
  int nbytes ;
  size_t res ;
  size_t olen ;
  unsigned long __cil_tmp16 ;
  size_t dotpos ;
  size_t total ;
  void *__cil_tmp19 ;
  FILE *__cil_tmp20 ;
  int tmp ;
  int val ;
  int __cil_tmp23 ;
  int v ;
  unsigned char byte ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;

  {
#line 1449
  fails = 1;
#line 1451
  fdest = (FILE *)((void *)0);
#line 1453
  compno = (unsigned int )0;
  {
#line 1453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1453
    if (! (compno < image->numcomps)) {
#line 1453
      goto while_break;
    }
    {
#line 1455
    comp = image->comps + compno;
#line 1457
    name = (char *)bname;
#line 1458
    nbytes = 0;
#line 1460
    __cil_tmp16 = strlen(outfile);
#line 1460
    olen = __cil_tmp16;
#line 1461
    dotpos = olen - 4UL;
#line 1462
    total = ((dotpos + 1UL) + 1UL) + 4UL;
    }
#line 1464
    if ((int )*(outfile + dotpos) != 46) {
      {
#line 1467
      fprintf(stderr, "ERROR -> Impossible happen.j\347U");
      }
#line 1468
      goto fin;
    }
#line 1470
    if (total > 256UL) {
      {
#line 1472
      __cil_tmp19 = malloc(total + 1UL);
#line 1472
      name = (char *)__cil_tmp19;
      }
    }
    {
#line 1474
    strncpy(name, outfile, dotpos);
#line 1475
    sprintf(name + dotpos, "_%d.pgx", compno);
#line 1476
    fdest = fopen((char const   *)name, "wb\227j\347U");
    }
#line 1478
    if (total > 256UL) {
      {
#line 1478
      free(name);
      }
    }
#line 1479
    if (! fdest) {
      {
#line 1481
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", name);
      }
#line 1482
      goto fin;
    }
#line 1485
    w = (int )(image->comps + compno)->w;
#line 1486
    h = (int )(image->comps + compno)->h;
#line 1488
    if (comp->sgnd) {
#line 1488
      tmp = '-';
    } else {
#line 1488
      tmp = '+';
    }
    {
#line 1488
    fprintf(fdest, "PG ML %c %d %d %d\n", tmp, comp->prec, w, h);
    }
#line 1491
    if (comp->prec <= 8U) {
#line 1492
      nbytes = 1;
    } else
#line 1493
    if (comp->prec <= 16U) {
#line 1494
      nbytes = 2;
    } else {
#line 1496
      nbytes = 4;
    }
#line 1498
    i = 0;
    {
#line 1498
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1498
      if (! (i < w * h)) {
#line 1498
        goto while_break___0;
      }
      {
#line 1501
      __cil_tmp23 = clamp(*((image->comps + compno)->data + i), (int )comp->prec,
                          (int )comp->sgnd);
#line 1501
      val = __cil_tmp23;
#line 1504
      j = nbytes - 1;
      }
      {
#line 1504
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1504
        if (! (j >= 0)) {
#line 1504
          goto while_break___1;
        }
        {
#line 1506
        v = (int )(val >> j * 8);
#line 1507
        byte = (unsigned char )v;
#line 1508
        res = fwrite(& byte, (unsigned long )1, (unsigned long )1, fdest);
        }
#line 1510
        if (res < 1UL) {
          {
#line 1512
          fprintf(stderr, "failed to write 1 byte for %s\n", name);
          }
#line 1513
          goto fin;
        }
#line 1504
        __cil_tmp27 = j;
#line 1504
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1498
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1517
    fclose(fdest);
#line 1517
    fdest = (FILE *)((void *)0);
    }
#line 1453
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1519
  fails = 0;
  fin: 
#line 1521
  if (fdest) {
    {
#line 1521
    fclose(fdest);
    }
  }
#line 1523
  return (fails);
}
}
#line 1539 "/root/patron/new_21/src/bin/jp2/convert.c"
static char *skip_white(char *s ) 
{ 
  unsigned short const   **__cil_tmp2 ;

  {
  {
#line 1541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1541
    if (! *s) {
#line 1541
      goto while_break;
    }
#line 1543
    if ((int )*s == 10) {
#line 1543
      return ((char *)((void *)0));
    } else
#line 1543
    if ((int )*s == 13) {
#line 1543
      return ((char *)((void *)0));
    }
    {
#line 1544
    __cil_tmp2 = __ctype_b_loc();
    }
#line 1544
    if ((int )*(*__cil_tmp2 + (int )*s) & 8192) {
#line 1544
      s ++;
#line 1544
      goto while_continue;
    }
#line 1545
    return (s);
  }
  while_break: /* CIL Label */ ;
  }
#line 1547
  return ((char *)((void *)0));
}
}
#line 1550 "/root/patron/new_21/src/bin/jp2/convert.c"
static char *skip_int(char *start , int *out_n ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1555
  *out_n = 0;
#line 1555
  s = start;
#line 1557
  s = skip_white(start);
  }
#line 1558
  if (s == (void *)0) {
#line 1558
    return ((char *)((void *)0));
  }
#line 1559
  start = s;
  {
#line 1561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1561
    if (! *s) {
#line 1561
      goto while_break;
    }
    {
#line 1563
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1563
    if (! ((int )*(*__cil_tmp6 + (int )*s) & 2048)) {
#line 1563
      goto while_break;
    }
#line 1564
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1566
  c = *s;
#line 1566
  *s = (char )0;
#line 1566
  *out_n = atoi((char const   *)start);
#line 1566
  *s = c;
  }
#line 1567
  return (s);
}
}
#line 1570 "/root/patron/new_21/src/bin/jp2/convert.c"
static char *skip_idf(char *start , char out_idf[256] ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;

  {
  {
#line 1575
  s = skip_white(start);
  }
#line 1576
  if (s == (void *)0) {
#line 1576
    return ((char *)((void *)0));
  }
#line 1577
  start = s;
  {
#line 1579
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1579
    if (! *s) {
#line 1579
      goto while_break;
    }
    {
#line 1581
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1581
    if ((int )*(*__cil_tmp6 + (int )*s) & 1024) {
#line 1581
      s ++;
#line 1581
      goto while_continue;
    } else
#line 1581
    if ((int )*s == 95) {
#line 1581
      s ++;
#line 1581
      goto while_continue;
    }
#line 1582
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1584
  c = *s;
#line 1584
  *s = (char )0;
#line 1584
  strncpy(out_idf, (char const   *)start, (unsigned long )255);
#line 1584
  *s = c;
  }
#line 1585
  return (s);
}
}
#line 1588 "/root/patron/new_21/src/bin/jp2/convert.c"
static void read_pnm_header(FILE *reader , struct pnm_header *ph ) 
{ 
  char *s ;
  int format ;
  int have_wh ;
  int end ;
  int ttype ;
  char idf[256] ;
  char type[256] ;
  char line[256] ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  char *__cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  char *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 1595
  __cil_tmp11 = fgets((char *)line, 250, reader);
  }
#line 1595
  if (__cil_tmp11 == (void *)0) {
    {
#line 1597
    fprintf(stderr, "\nWARNING: fgets return a NULL valuej\347U");
    }
#line 1598
    return;
  }
#line 1601
  if ((int )line[0] != 80) {
    {
#line 1603
    fprintf(stderr, "read_pnm_header:PNM:magic P missing\n\347U");
    }
#line 1603
    return;
  }
  {
#line 1605
  format = atoi((char const   *)((char *)line + 1));
  }
#line 1606
  if (format < 1) {
    {
    {
#line 1608
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1609
    return;
  } else
#line 1606
  if (format > 7) {
    {
    {
#line 1608
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1609
    return;
  }
#line 1611
  ph->format = format;
#line 1612
  have_wh = 0;
#line 1612
  end = have_wh;
#line 1612
  ttype = end;
  {
#line 1614
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1614
    __cil_tmp13 = fgets((char *)line, 250, reader);
    }
#line 1614
    if (! __cil_tmp13) {
#line 1614
      goto while_break;
    }
#line 1616
    if ((int )*((char *)line) == 35) {
#line 1616
      goto while_continue;
    }
#line 1618
    s = (char *)line;
#line 1620
    if (format == 7) {
      {
#line 1622
      s = skip_idf(s, (char *)idf);
      }
#line 1624
      if (s == (void *)0) {
#line 1624
        return;
      } else
#line 1624
      if ((int )*s == 0) {
#line 1624
        return;
      }
      {
#line 1626
      __cil_tmp15 = strcmp((char const   *)((char *)idf), "ENDHDR");
      }
#line 1626
      if (__cil_tmp15 == 0) {
#line 1628
        end = 1;
#line 1628
        goto while_break;
      }
      {
#line 1630
      __cil_tmp16 = strcmp((char const   *)((char *)idf), "WIDTHU");
      }
#line 1630
      if (__cil_tmp16 == 0) {
        {
#line 1632
        s = skip_int(s, & ph->width);
        }
#line 1633
        if (s == (void *)0) {
#line 1633
          return;
        } else
#line 1633
        if ((int )*s == 0) {
#line 1633
          return;
        }
#line 1635
        goto while_continue;
      }
      {
#line 1637
      __cil_tmp18 = strcmp((char const   *)((char *)idf), "HEIGHT");
      }
#line 1637
      if (__cil_tmp18 == 0) {
        {
#line 1639
        s = skip_int(s, & ph->height);
        }
#line 1640
        if (s == (void *)0) {
#line 1640
          return;
        } else
#line 1640
        if ((int )*s == 0) {
#line 1640
          return;
        }
#line 1642
        goto while_continue;
      }
      {
#line 1644
      __cil_tmp20 = strcmp((char const   *)((char *)idf), "DEPTH");
      }
#line 1644
      if (__cil_tmp20 == 0) {
        {
#line 1646
        s = skip_int(s, & ph->depth);
        }
#line 1647
        if (s == (void *)0) {
#line 1647
          return;
        } else
#line 1647
        if ((int )*s == 0) {
#line 1647
          return;
        }
#line 1649
        goto while_continue;
      }
      {
#line 1651
      __cil_tmp22 = strcmp((char const   *)((char *)idf), "MAXVAL");
      }
#line 1651
      if (__cil_tmp22 == 0) {
        {
#line 1653
        s = skip_int(s, & ph->maxval);
        }
#line 1654
        if (s == (void *)0) {
#line 1654
          return;
        } else
#line 1654
        if ((int )*s == 0) {
#line 1654
          return;
        }
#line 1656
        goto while_continue;
      }
      {
#line 1658
      __cil_tmp24 = strcmp((char const   *)((char *)idf), "TUPLTYPE\220");
      }
#line 1658
      if (__cil_tmp24 == 0) {
        {
#line 1660
        s = skip_idf(s, (char *)type);
        }
#line 1661
        if (s == (void *)0) {
#line 1661
          return;
        } else
#line 1661
        if ((int )*s == 0) {
#line 1661
          return;
        }
        {
#line 1663
        __cil_tmp26 = strcmp((char const   *)((char *)type), "BLACKANDWHITE");
        }
#line 1663
        if (__cil_tmp26 == 0) {
#line 1665
          ph->bw = (char )1;
#line 1665
          ttype = 1;
#line 1665
          goto while_continue;
        }
        {
#line 1667
        __cil_tmp27 = strcmp((char const   *)((char *)type), "GRAYSCALE");
        }
#line 1667
        if (__cil_tmp27 == 0) {
#line 1669
          ph->gray = (char )1;
#line 1669
          ttype = 1;
#line 1669
          goto while_continue;
        }
        {
#line 1671
        __cil_tmp28 = strcmp((char const   *)((char *)type), "GRAYSCALE_ALPHA");
        }
#line 1671
        if (__cil_tmp28 == 0) {
#line 1673
          ph->graya = (char )1;
#line 1673
          ttype = 1;
#line 1673
          goto while_continue;
        }
        {
#line 1675
        __cil_tmp29 = strcmp((char const   *)((char *)type), "RGB");
        }
#line 1675
        if (__cil_tmp29 == 0) {
#line 1677
          ph->rgb = (char )1;
#line 1677
          ttype = 1;
#line 1677
          goto while_continue;
        }
        {
#line 1679
        __cil_tmp30 = strcmp((char const   *)((char *)type), "RGB_ALPHA");
        }
#line 1679
        if (__cil_tmp30 == 0) {
#line 1681
          ph->rgba = (char )1;
#line 1681
          ttype = 1;
#line 1681
          goto while_continue;
        }
        {
#line 1683
        fprintf(stderr, "read_pnm_header:unknown P7 TUPLTYPE %s\n", (char *)type);
        }
#line 1684
        return;
      }
      {
#line 1686
      fprintf(stderr, "read_pnm_header:unknown P7 idf %s\n", (char *)idf);
      }
#line 1687
      return;
    }
#line 1690
    if (! have_wh) {
      {
#line 1692
      s = skip_int(s, & ph->width);
#line 1694
      s = skip_int(s, & ph->height);
#line 1696
      have_wh = 1;
      }
#line 1698
      if (format == 1) {
#line 1698
        goto while_break;
      } else
#line 1698
      if (format == 4) {
#line 1698
        goto while_break;
      }
#line 1700
      goto while_continue;
    }
#line 1702
    if (format == 2) {
      _L: /* CIL Label */ 
      _L___31: /* CIL Label */ 
      _L___32: /* CIL Label */ 
      {
#line 1705
      s = skip_int(s, & ph->maxval);
      }
#line 1707
      if (ph->maxval > 65535) {
#line 1707
        return;
      }
    } else
#line 1702
    if (format == 3) {
#line 1702
      goto _L;
    } else
#line 1702
    if (format == 5) {
#line 1702
      goto _L;
    } else
#line 1702
    if (format == 6) {
#line 1702
      goto _L;
    }
#line 1709
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1711
  if (format == 2) {
    _L___33: /* CIL Label */ 
    _L___34: /* CIL Label */ 
#line 1713
    if (ph->maxval < 1) {
#line 1713
      return;
    } else
#line 1713
    if (ph->maxval > 65535) {
#line 1713
      return;
    }
  } else
#line 1711
  if (format == 3) {
#line 1711
    goto _L___33;
  } else
#line 1711
  if (format > 4) {
#line 1711
    goto _L___33;
  }
#line 1715
  if (ph->width < 1) {
#line 1715
    return;
  } else
#line 1715
  if (ph->height < 1) {
#line 1715
    return;
  }
#line 1717
  if (format == 7) {
#line 1719
    if (! end) {
      {
#line 1721
      fprintf(stderr, "read_pnm_header:P7 without ENDHDR\n");
      }
#line 1721
      return;
    }
#line 1723
    if (ph->depth < 1) {
#line 1723
      return;
    } else
#line 1723
    if (ph->depth > 4) {
#line 1723
      return;
    }
#line 1725
    if (ph->width) {
#line 1725
      if (ph->height) {
#line 1725
        if (ph->depth) {
#line 1725
          if (ph->maxval) {
#line 1725
            if (ttype) {
#line 1726
              ph->ok = (char )1;
            }
          }
        }
      }
    }
  } else
#line 1730
  if (format != 1) {
#line 1730
    if (format != 4) {
#line 1732
      if (ph->width) {
#line 1732
        if (ph->height) {
#line 1732
          if (ph->maxval) {
#line 1732
            ph->ok = (char )1;
          }
        }
      }
    } else {
#line 1730
      goto _L___35;
    }
  } else {
    _L___35: /* CIL Label */ 
#line 1736
    if (ph->width) {
#line 1736
      if (ph->height) {
#line 1736
        ph->ok = (char )1;
      }
    }
#line 1737
    ph->maxval = 255;
  }
  return;
}
}
#line 1742 "/root/patron/new_21/src/bin/jp2/convert.c"
static int has_prec(int val ) 
{ 


  {
#line 1744
  if (val < 2) {
#line 1744
    return (1);
  }
#line 1745
  if (val < 4) {
#line 1745
    return (2);
  }
#line 1746
  if (val < 8) {
#line 1746
    return (3);
  }
#line 1747
  if (val < 16) {
#line 1747
    return (4);
  }
#line 1748
  if (val < 32) {
#line 1748
    return (5);
  }
#line 1749
  if (val < 64) {
#line 1749
    return (6);
  }
#line 1750
  if (val < 128) {
#line 1750
    return (7);
  }
#line 1751
  if (val < 256) {
#line 1751
    return (8);
  }
#line 1752
  if (val < 512) {
#line 1752
    return (9);
  }
#line 1753
  if (val < 1024) {
#line 1753
    return (10);
  }
#line 1754
  if (val < 2048) {
#line 1754
    return (11);
  }
#line 1755
  if (val < 4096) {
#line 1755
    return (12);
  }
#line 1756
  if (val < 8192) {
#line 1756
    return (13);
  }
#line 1757
  if (val < 16384) {
#line 1757
    return (14);
  }
#line 1758
  if (val < 32768) {
#line 1758
    return (15);
  }
#line 1759
  return (16);
}
}
#line 1762 "/root/patron/new_21/src/bin/jp2/convert.c"
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *fp ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  int prec ;
  int format ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[4] ;
  opj_image_t *image ;
  struct pnm_header header_info ;
  FILE *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  opj_image_t *__cil_tmp20 ;
  unsigned int index___36 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned char c0 ;
  unsigned char c1 ;
  unsigned char one ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned int index___37 ;
  int __cil_tmp33 ;
  int tmp ;
  int __cil_tmp35 ;
  int x ;
  int y ;
  int bit ;
  unsigned char uc ;
  int __cil_tmp40 ;
  int tmp___0 ;
  unsigned char uc___0 ;
  unsigned long __cil_tmp43 ;
  int tmp___1 ;

  {
  {
#line 1763
  subsampling_dx = parameters->subsampling_dx;
#line 1764
  subsampling_dy = parameters->subsampling_dy;
#line 1766
  fp = (FILE *)((void *)0);
#line 1770
  image = (opj_image_t *)((void *)0);
#line 1773
  fp = fopen(filename, "rb\230j\347U");
  }
#line 1773
  if (fp == (void *)0) {
    {
#line 1775
    fprintf(stderr, "pnmtoimage:Failed to open %s for reading!\n", filename);
    }
#line 1776
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1778
  memset(& header_info, 0, sizeof(struct pnm_header ));
#line 1780
  read_pnm_header(fp, & header_info);
  }
#line 1782
  if (! header_info.ok) {
    {
#line 1782
    fclose(fp);
    }
#line 1782
    return ((opj_image_t *)((void *)0));
  }
#line 1784
  format = header_info.format;
  {
#line 1789
  if (format == 4) {
#line 1789
    goto case_4;
  }
#line 1789
  if (format == 1) {
#line 1789
    goto case_4;
  }
#line 1794
  if (format == 5) {
#line 1794
    goto case_5;
  }
#line 1794
  if (format == 2) {
#line 1794
    goto case_5;
  }
#line 1799
  if (format == 6) {
#line 1799
    goto case_6;
  }
#line 1799
  if (format == 3) {
#line 1799
    goto case_6;
  }
#line 1803
  if (format == 7) {
#line 1803
    goto case_7;
  }
#line 1807
  goto switch_default;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1790
  numcomps = 1;
#line 1791
  goto switch_break;
  case_5: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1795
  numcomps = 1;
#line 1796
  goto switch_break;
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 1800
  numcomps = 3;
#line 1801
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1804
  numcomps = header_info.depth;
#line 1805
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1807
  fclose(fp);
  }
#line 1807
  return ((opj_image_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 1809
  if (numcomps < 3) {
#line 1810
    color_space = (OPJ_COLOR_SPACE )2;
  } else {
#line 1812
    color_space = (OPJ_COLOR_SPACE )1;
  }
  {
#line 1814
  prec = has_prec(header_info.maxval);
  }
#line 1816
  if (prec < 8) {
#line 1816
    prec = 8;
  }
  {
#line 1818
  w = header_info.width;
#line 1819
  h = header_info.height;
#line 1820
  subsampling_dx = parameters->subsampling_dx;
#line 1821
  subsampling_dy = parameters->subsampling_dy;
#line 1823
  memset(& cmptparm[0], 0, (size_t )numcomps * sizeof(opj_image_cmptparm_t ));
#line 1825
  i = 0;
  }
  {
#line 1825
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1825
    if (! (i < numcomps)) {
#line 1825
      goto while_break;
    }
#line 1827
    cmptparm[i].prec = (OPJ_UINT32 )prec;
#line 1828
    cmptparm[i].bpp = (OPJ_UINT32 )prec;
#line 1829
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 1830
    cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 1831
    cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 1832
    cmptparm[i].w = (OPJ_UINT32 )w;
#line 1833
    cmptparm[i].h = (OPJ_UINT32 )h;
#line 1825
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1835
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
  }
#line 1837
  if (! image) {
    {
#line 1837
    fclose(fp);
    }
#line 1837
    return ((opj_image_t *)((void *)0));
  }
#line 1840
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 1841
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 1842
  image->x1 = (OPJ_UINT32 )((parameters->image_offset_x0 + (w - 1) * subsampling_dx) + 1);
#line 1843
  image->y1 = (OPJ_UINT32 )((parameters->image_offset_y0 + (h - 1) * subsampling_dy) + 1);
#line 1845
  if (format == 2) {
    _L___40: /* CIL Label */ 
#line 1849
    i = 0;
    {
#line 1849
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1849
      if (! (i < w * h)) {
#line 1849
        goto while_break___0;
      }
#line 1851
      compno = 0;
      {
#line 1851
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1851
        if (! (compno < numcomps)) {
#line 1851
          goto while_break___1;
        }
        {
#line 1853
        index___36 = (unsigned int )0;
#line 1854
        __cil_tmp22 = fscanf(fp, "%u", & index___36);
        }
#line 1854
        if (__cil_tmp22 != 1) {
          {
#line 1855
          fprintf(stderr, "\nWARNING: fscanf return a number of element different from the expected.\n");
          }
        }
#line 1857
        *((image->comps + compno)->data + i) = (OPJ_INT32 )(index___36 * 255U) / header_info.maxval;
#line 1851
        compno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1849
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 1845
  if (format == 3) {
#line 1845
    goto _L___40;
  } else
#line 1862
  if (format == 5) {
    _L: /* CIL Label */ 
    _L___39: /* CIL Label */ 
#line 1870
    one = (unsigned char )(prec < 9);
#line 1872
    i = 0;
    {
#line 1872
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1872
      if (! (i < w * h)) {
#line 1872
        goto while_break___2;
      }
#line 1874
      compno = 0;
      {
#line 1874
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1874
        if (! (compno < numcomps)) {
#line 1874
          goto while_break___3;
        }
        {
#line 1876
        __cil_tmp28 = fread(& c0, (unsigned long )1, (unsigned long )1, fp);
        }
#line 1876
        if (! __cil_tmp28) {
          {
#line 1878
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 1879
          opj_image_destroy(image);
          }
#line 1880
          return ((opj_image_t *)((void *)0));
        }
#line 1882
        if (one) {
#line 1884
          *((image->comps + compno)->data + i) = (OPJ_INT32 )c0;
        } else {
          {
#line 1888
          __cil_tmp29 = fread(& c1, (unsigned long )1, (unsigned long )1, fp);
          }
#line 1888
          if (! __cil_tmp29) {
            {
#line 1889
            fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
            }
          }
#line 1891
          *((image->comps + compno)->data + i) = ((int )c0 << 8) | (int )c1;
        }
#line 1874
        compno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1872
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 1862
  if (format == 6) {
#line 1862
    goto _L;
  } else
#line 1862
  if (format == 7) {
#line 1862
    if ((int )header_info.gray) {
#line 1862
      goto _L;
    } else
#line 1862
    if ((int )header_info.graya) {
#line 1862
      goto _L;
    } else
#line 1862
    if ((int )header_info.rgb) {
#line 1862
      goto _L;
    } else
#line 1862
    if ((int )header_info.rgba) {
#line 1862
      goto _L;
    } else {
#line 1862
      goto _L___38;
    }
  } else
  _L___38: /* CIL Label */ 
#line 1897
  if (format == 1) {
#line 1899
    i = 0;
    {
#line 1899
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1899
      if (! (i < w * h)) {
#line 1899
        goto while_break___4;
      }
      {
#line 1903
      __cil_tmp33 = fscanf(fp, "%u", & index___37);
      }
#line 1903
      if (__cil_tmp33 != 1) {
        {
#line 1904
        fprintf(stderr, "\nWARNING: fscanf return a number of element different from the expected.\n");
        }
      }
#line 1906
      if (index___37) {
#line 1906
        tmp = 0;
      } else {
#line 1906
        tmp = 255;
      }
#line 1906
      *((image->comps + 0)->data + i) = tmp;
#line 1899
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 1910
  if (format == 4) {
#line 1915
    i = 0;
#line 1916
    y = 0;
    {
#line 1916
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1916
      if (! (y < h)) {
#line 1916
        goto while_break___5;
      }
#line 1918
      bit = - 1;
#line 1918
      uc = (unsigned char )0;
#line 1920
      x = 0;
      {
#line 1920
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1920
        if (! (x < w)) {
#line 1920
          goto while_break___6;
        }
#line 1922
        if (bit == -1) {
          {
#line 1924
          bit = 7;
#line 1925
          __cil_tmp40 = getc(fp);
#line 1925
          uc = (unsigned char )__cil_tmp40;
          }
        }
#line 1927
        if (((int )uc >> bit) & 1) {
#line 1927
          tmp___0 = 0;
        } else {
#line 1927
          tmp___0 = 255;
        }
#line 1927
        *((image->comps + 0)->data + i) = tmp___0;
#line 1928
        bit --;
#line 1928
        i ++;
#line 1920
        x ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1916
      y ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else
#line 1933
  if (format == 7) {
#line 1933
    if ((int )header_info.bw) {
#line 1937
      i = 0;
      {
#line 1937
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1937
        if (! (i < w * h)) {
#line 1937
          goto while_break___7;
        }
        {
#line 1939
        __cil_tmp43 = fread(& uc___0, (unsigned long )1, (unsigned long )1, fp);
        }
#line 1939
        if (! __cil_tmp43) {
          {
#line 1940
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
          }
        }
#line 1941
        if ((int )uc___0 & 1) {
#line 1941
          tmp___1 = 0;
        } else {
#line 1941
          tmp___1 = 255;
        }
#line 1941
        *((image->comps + 0)->data + i) = tmp___1;
#line 1937
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
  {
#line 1944
  fclose(fp);
  }
#line 1946
  return (image);
}
}
#line 1949 "/root/patron/new_21/src/bin/jp2/convert.c"
int imagetopnm(opj_image_t *image , char const   *outfile ) 
{ 
  int *red ;
  int *green ;
  int *blue ;
  int *alpha ;
  int wr ;
  int hr ;
  int max ;
  int i ;
  unsigned int compno ;
  unsigned int ncomp ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int adjustA ;
  int fails ;
  int two ;
  int want_gray ;
  int has_alpha ;
  int triple ;
  int prec ;
  int v ;
  FILE *fdest ;
  char const   *tmp ;
  char *destname ;
  FILE *__cil_tmp27 ;
  char const   *tt ;
  char const   *tmp___41 ;
  char const   *__cil_tmp30 ;
  int tmp___42 ;
  char const   *__cil_tmp32 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int *__cil_tmp36 ;
  int *__cil_tmp37 ;
  int *__cil_tmp38 ;
  int *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  void *__cil_tmp41 ;
  size_t olen ;
  unsigned long __cil_tmp43 ;
  size_t dotpos ;
  FILE *__cil_tmp45 ;
  char const   *__cil_tmp46 ;
  int tmp___46 ;
  int *__cil_tmp48 ;
  int __cil_tmp49 ;
  unsigned int __cil_tmp50 ;

  {
#line 1958
  fdest = (FILE *)((void *)0);
#line 1959
  tmp = outfile;
#line 1962
  alpha = (int *)((void *)0);
#line 1964
  prec = (int )(image->comps + 0)->prec;
#line 1964
  if (prec > 16) {
    {
#line 1966
    fprintf(stderr, "%s:%d:imagetopnm\n\tprecision %d is larger than 16\n\t: refused.\n\266\230j\347U",
            "/root/patron/new_21/src/bin/jp2/convert.c\260\230j\347U", 1967, prec);
    }
#line 1968
    return (1);
  }
#line 1970
  has_alpha = 0;
#line 1970
  two = has_alpha;
#line 1970
  fails = 1;
#line 1971
  ncomp = image->numcomps;
  {
#line 1973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1973
    if (! *tmp) {
#line 1973
      goto while_break;
    }
#line 1973
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1973
  tmp -= 2;
#line 1974
  want_gray = (int )*tmp == 103 || (int )*tmp == 71;
#line 1975
  ncomp = image->numcomps;
#line 1977
  if (want_gray) {
#line 1977
    ncomp = (unsigned int )1;
  }
#line 1979
  if (ncomp == 2U) {
    _L: /* CIL Label */ 
    {
#line 1989
    fdest = fopen(outfile, "wb\230j\347U");
    }
#line 1991
    if (! fdest) {
      {
#line 1993
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
      }
#line 1994
      return (fails);
    }
#line 1996
    two = prec > 8;
#line 1997
    triple = ncomp > 2U;
#line 1998
    wr = (int )(image->comps + 0)->w;
#line 1998
    hr = (int )(image->comps + 0)->h;
#line 1999
    max = (1 << prec) - 1;
#line 1999
    has_alpha = ncomp == 4U || ncomp == 2U;
#line 2001
    red = (image->comps + 0)->data;
#line 2003
    if (triple) {
#line 2005
      green = (image->comps + 1)->data;
#line 2006
      blue = (image->comps + 2)->data;
    } else {
#line 2008
      blue = (int *)((void *)0);
#line 2008
      green = blue;
    }
#line 2010
    if (has_alpha) {
#line 2012
      if (triple) {
#line 2012
        strcpy((char *)tmp___41, "RGB_ALPHA");;
      } else {
#line 2012
        strcpy((char *)tmp___41, "GRAYSCALE_ALPHA");;
      }
      {
#line 2012
      tt = tmp___41;
#line 2014
      __cil_tmp30 = opj_version();
#line 2014
      fprintf(fdest, "P7\n# OpenJPEG-%s\nWIDTH %d\nHEIGHT %d\nDEPTH %d\nMAXVAL %d\nTUPLTYPE %s\nENDHDR\n",
              __cil_tmp30, wr, hr, ncomp, max, tt);
#line 2017
      alpha = (image->comps + (ncomp - 1U))->data;
      }
#line 2018
      if ((image->comps + (ncomp - 1U))->sgnd) {
#line 2018
        tmp___42 = 1 << ((image->comps + (ncomp - 1U))->prec - 1U);
      } else {
#line 2018
        tmp___42 = 0;
      }
#line 2018
      adjustA = tmp___42;
    } else {
      {
#line 2023
      __cil_tmp32 = opj_version();
#line 2023
      fprintf(fdest, "P6\n# OpenJPEG-%s\n%d %d\n%d\n", __cil_tmp32, wr, hr, max);
#line 2025
      adjustA = 0;
      }
    }
#line 2027
    if ((image->comps + 0)->sgnd) {
#line 2027
      tmp___43 = 1 << ((image->comps + 0)->prec - 1U);
    } else {
#line 2027
      tmp___43 = 0;
    }
#line 2027
    adjustR = tmp___43;
#line 2029
    if (triple) {
#line 2031
      if ((image->comps + 1)->sgnd) {
#line 2031
        tmp___44 = 1 << ((image->comps + 1)->prec - 1U);
      } else {
#line 2031
        tmp___44 = 0;
      }
#line 2031
      adjustG = tmp___44;
#line 2032
      if ((image->comps + 2)->sgnd) {
#line 2032
        tmp___45 = 1 << ((image->comps + 2)->prec - 1U);
      } else {
#line 2032
        tmp___45 = 0;
      }
#line 2032
      adjustB = tmp___45;
    } else {
#line 2034
      adjustB = 0;
#line 2034
      adjustG = adjustB;
    }
#line 2036
    i = 0;
    {
#line 2036
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2036
      if (! (i < wr * hr)) {
#line 2036
        goto while_break___0;
      }
#line 2038
      if (two) {
#line 2040
        v = *red + adjustR;
#line 2040
        red ++;
#line 2041
        if (v > 65535) {
#line 2041
          v = 65535;
        } else
#line 2041
        if (v < 0) {
#line 2041
          v = 0;
        }
        {
#line 2044
        fprintf(fdest, "%c%c\347U", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
        }
#line 2046
        if (triple) {
#line 2048
          v = *green + adjustG;
#line 2048
          green ++;
#line 2049
          if (v > 65535) {
#line 2049
            v = 65535;
          } else
#line 2049
          if (v < 0) {
#line 2049
            v = 0;
          }
          {
#line 2052
          fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
#line 2054
          v = *blue + adjustB;
#line 2054
          blue ++;
          }
#line 2055
          if (v > 65535) {
#line 2055
            v = 65535;
          } else
#line 2055
          if (v < 0) {
#line 2055
            v = 0;
          }
          {
#line 2058
          fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 2062
        if (has_alpha) {
#line 2064
          v = *alpha + adjustA;
#line 2064
          alpha ++;
#line 2065
          if (v > 65535) {
#line 2065
            v = 65535;
          } else
#line 2065
          if (v < 0) {
#line 2065
            v = 0;
          }
          {
#line 2068
          fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 2070
        goto while_continue___0;
      }
#line 2075
      __cil_tmp36 = red;
#line 2075
      red ++;
#line 2075
      v = *__cil_tmp36;
#line 2076
      if (v > 255) {
#line 2076
        v = 255;
      } else
#line 2076
      if (v < 0) {
#line 2076
        v = 0;
      }
      {
#line 2078
      fprintf(fdest, "%c", (int )((unsigned char )v));
      }
#line 2079
      if (triple) {
#line 2081
        __cil_tmp37 = green;
#line 2081
        green ++;
#line 2081
        v = *__cil_tmp37;
#line 2082
        if (v > 255) {
#line 2082
          v = 255;
        } else
#line 2082
        if (v < 0) {
#line 2082
          v = 0;
        }
        {
#line 2084
        fprintf(fdest, "%c", (int )((unsigned char )v));
#line 2085
        __cil_tmp38 = blue;
#line 2085
        blue ++;
#line 2085
        v = *__cil_tmp38;
        }
#line 2086
        if (v > 255) {
#line 2086
          v = 255;
        } else
#line 2086
        if (v < 0) {
#line 2086
          v = 0;
        }
        {
#line 2088
        fprintf(fdest, "%c", (int )((unsigned char )v));
        }
      }
#line 2090
      if (has_alpha) {
#line 2092
        __cil_tmp39 = alpha;
#line 2092
        alpha ++;
#line 2092
        v = *__cil_tmp39;
#line 2093
        if (v > 255) {
#line 2093
          v = 255;
        } else
#line 2093
        if (v < 0) {
#line 2093
          v = 0;
        }
        {
#line 2095
        fprintf(fdest, "%c", (int )((unsigned char )v));
        }
      }
#line 2036
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2099
    fclose(fdest);
    }
#line 2099
    return (0);
  } else
#line 1979
  if (ncomp > 2U) {
#line 1979
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 1979
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 1979
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 1979
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 1979
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 1979
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
#line 1979
                goto _L;
              }
            }
          }
        }
      }
    }
  }
#line 2104
  if (image->numcomps > ncomp) {
    {
#line 2106
    fprintf(stderr, "WARNING -> [PGM file] Only the first component\n");
#line 2107
    fprintf(stderr, "           is written to the file\n\230j\347U");
    }
  }
  {
#line 2109
  __cil_tmp40 = strlen(outfile);
#line 2109
  __cil_tmp41 = malloc(__cil_tmp40 + 8UL);
#line 2109
  destname = (char *)__cil_tmp41;
#line 2111
  compno = (unsigned int )0;
  }
  {
#line 2111
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2111
    if (! (compno < ncomp)) {
#line 2111
      goto while_break___1;
    }
#line 2113
    if (ncomp > 1U) {
      {
#line 2116
      __cil_tmp43 = strlen(outfile);
#line 2116
      olen = __cil_tmp43;
#line 2117
      dotpos = olen - 4UL;
#line 2119
      strncpy(destname, outfile, dotpos);
#line 2120
      sprintf(destname + dotpos, "_%d.pgm", compno);
      }
    } else {
      {
#line 2123
      sprintf(destname, "%s", outfile);
      }
    }
    {
#line 2125
    fdest = fopen((char const   *)destname, "wb");
    }
#line 2126
    if (! fdest) {
      {
#line 2128
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", destname);
#line 2129
      free(destname);
      }
#line 2130
      return (1);
    }
    {
#line 2132
    wr = (int )(image->comps + compno)->w;
#line 2132
    hr = (int )(image->comps + compno)->h;
#line 2133
    prec = (int )(image->comps + compno)->prec;
#line 2134
    max = (1 << prec) - 1;
#line 2136
    __cil_tmp46 = opj_version();
#line 2136
    fprintf(fdest, "P5\n#OpenJPEG-%s\n%d %d\n%d\n", __cil_tmp46, wr, hr, max);
#line 2139
    red = (image->comps + compno)->data;
    }
#line 2140
    if ((image->comps + compno)->sgnd) {
#line 2140
      tmp___46 = 1 << ((image->comps + compno)->prec - 1U);
    } else {
#line 2140
      tmp___46 = 0;
    }
#line 2140
    adjustR = tmp___46;
#line 2143
    if (prec > 8) {
#line 2145
      i = 0;
      {
#line 2145
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2145
        if (! (i < wr * hr)) {
#line 2145
          goto while_break___2;
        }
#line 2147
        v = *red + adjustR;
#line 2147
        red ++;
#line 2148
        if (v > 65535) {
#line 2148
          v = 65535;
        } else
#line 2148
        if (v < 0) {
#line 2148
          v = 0;
        }
        {
#line 2151
        fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
        }
#line 2153
        if (has_alpha) {
#line 2155
          __cil_tmp48 = alpha;
#line 2155
          alpha ++;
#line 2155
          v = *__cil_tmp48;
#line 2156
          if (v > 65535) {
#line 2156
            v = 65535;
          } else
#line 2156
          if (v < 0) {
#line 2156
            v = 0;
          }
          {
#line 2159
          fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 2145
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 2165
      i = 0;
      {
#line 2165
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2165
        if (! (i < wr * hr)) {
#line 2165
          goto while_break___3;
        }
#line 2167
        v = *red + adjustR;
#line 2167
        red ++;
#line 2168
        if (v > 255) {
#line 2168
          v = 255;
        } else
#line 2168
        if (v < 0) {
#line 2168
          v = 0;
        }
        {
#line 2170
        fprintf(fdest, "%c", (int )((unsigned char )v));
        }
#line 2165
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 2173
    fclose(fdest);
    }
#line 2111
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2175
  free(destname);
  }
#line 2177
  return (0);
}
}
#line 2187 "/root/patron/new_21/src/bin/jp2/convert.c"
int imagetotif(opj_image_t *image , char const   *outfile ) 
{ 
  int width ;
  int height ;
  int imgsize ;
  int bps ;
  int index___47 ;
  int adjust ;
  int sgnd ;
  int ushift ;
  int dshift ;
  int has_alpha ;
  int force16 ;
  TIFF *tif ;
  tdata_t buf ;
  tstrip_t strip ;
  tsize_t strip_size ;
  TIFF *__cil_tmp18 ;
  int tmp ;
  tmsize_t __cil_tmp20 ;
  void *__cil_tmp21 ;
  uint32 __cil_tmp22 ;
  unsigned char *dat8 ;
  tsize_t i ;
  tsize_t ssize ;
  tsize_t last_i ;
  int step ;
  int restx ;
  tmsize_t __cil_tmp29 ;
  int r ;
  int g ;
  int b ;
  int a ;
  int __cil_tmp34 ;
  int r___0 ;
  int g___0 ;
  int b___0 ;
  int a___0 ;
  int __cil_tmp39 ;
  int r___1 ;
  int g___1 ;
  int b___1 ;
  int a___1 ;
  int __cil_tmp44 ;
  int r___2 ;
  int g___2 ;
  int b___2 ;
  int a___2 ;
  int __cil_tmp49 ;
  tstrip_t __cil_tmp50 ;
  int step___0 ;
  tmsize_t __cil_tmp52 ;
  void *__cil_tmp53 ;
  uint32 __cil_tmp54 ;
  unsigned char *dat8___0 ;
  tsize_t i___0 ;
  tsize_t ssize___0 ;
  tmsize_t __cil_tmp58 ;
  int r___3 ;
  int a___3 ;
  int __cil_tmp61 ;
  int r___4 ;
  int a___4 ;
  int __cil_tmp64 ;
  tstrip_t __cil_tmp65 ;

  {
#line 2197
  has_alpha = 0;
#line 2197
  force16 = has_alpha;
#line 2197
  dshift = force16;
#line 2197
  ushift = dshift;
#line 2198
  bps = (int )(image->comps + 0)->prec;
#line 2200
  if (bps > 8) {
#line 2200
    if (bps < 16) {
#line 2202
      ushift = 16 - bps;
#line 2202
      dshift = bps - ushift;
#line 2203
      bps = 16;
#line 2203
      force16 = 1;
    }
  }
#line 2206
  if (bps != 8) {
#line 2206
    if (bps != 16) {
      {
#line 2208
      fprintf(stderr, "imagetotif: Bits=%d, Only 8 and 16 bits implemented\n\347U",
              bps);
#line 2210
      fprintf(stderr, "\tAborting\n\231j\347U");
      }
#line 2211
      return (1);
    }
  }
  {
#line 2213
  tif = TIFFOpen(outfile, "wb");
  }
#line 2215
  if (! tif) {
    {
#line 2217
    fprintf(stderr, "imagetotif:failed to open %s for writing\nV\231j\347U", outfile);
    }
#line 2218
    return (1);
  }
#line 2220
  sgnd = (int )(image->comps + 0)->sgnd;
#line 2221
  if (sgnd) {
#line 2221
    tmp = 1 << ((image->comps + 0)->prec - 1U);
  } else {
#line 2221
    tmp = 0;
  }
#line 2221
  adjust = tmp;
#line 2223
  if (image->numcomps >= 3U) {
#line 2223
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 2223
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 2223
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 2223
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 2223
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 2223
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
                {
#line 2231
                has_alpha = image->numcomps == 4U;
#line 2233
                width = (int )(image->comps + 0)->w;
#line 2234
                height = (int )(image->comps + 0)->h;
#line 2235
                imgsize = width * height;
#line 2237
                TIFFSetField(tif, (uint32 )256, width);
#line 2238
                TIFFSetField(tif, (uint32 )257, height);
#line 2239
                TIFFSetField(tif, (uint32 )277, 3 + has_alpha);
#line 2240
                TIFFSetField(tif, (uint32 )258, bps);
#line 2241
                TIFFSetField(tif, (uint32 )274, 1);
#line 2242
                TIFFSetField(tif, (uint32 )284, 1);
#line 2243
                TIFFSetField(tif, (uint32 )262, 2);
#line 2244
                TIFFSetField(tif, (uint32 )278, 1);
#line 2245
                strip_size = TIFFStripSize(tif);
#line 2246
                buf = _TIFFmalloc(strip_size);
#line 2247
                index___47 = 0;
#line 2249
                strip = (tstrip_t )0;
                }
                {
#line 2249
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 2249
                  if (! (strip < __cil_tmp22)) {
#line 2249
                    goto while_break;
                  }
                  {
#line 2252
                  last_i = (tsize_t )0;
#line 2254
                  ssize = TIFFStripSize(tif);
#line 2255
                  dat8 = (unsigned char *)buf;
                  }
#line 2257
                  if (bps == 8) {
#line 2259
                    step = 3 + has_alpha;
#line 2260
                    restx = step - 1;
#line 2262
                    i = (tsize_t )0;
                    {
#line 2262
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
#line 2262
                      if (! (i < ssize - (long )restx)) {
#line 2262
                        goto while_break___0;
                      }
#line 2264
                      a = 0;
#line 2266
                      if (index___47 < imgsize) {
#line 2268
                        r = *((image->comps + 0)->data + index___47);
#line 2269
                        g = *((image->comps + 1)->data + index___47);
#line 2270
                        b = *((image->comps + 2)->data + index___47);
#line 2271
                        if (has_alpha) {
#line 2271
                          a = *((image->comps + 3)->data + index___47);
                        }
#line 2273
                        if (sgnd) {
#line 2275
                          r += adjust;
#line 2276
                          g += adjust;
#line 2277
                          b += adjust;
#line 2278
                          if (has_alpha) {
#line 2278
                            a += adjust;
                          }
                        }
#line 2280
                        if (r > 255) {
#line 2280
                          r = 255;
                        } else
#line 2280
                        if (r < 0) {
#line 2280
                          r = 0;
                        }
#line 2281
                        *(dat8 + i) = (unsigned char )r;
#line 2282
                        if (g > 255) {
#line 2282
                          g = 255;
                        } else
#line 2282
                        if (g < 0) {
#line 2282
                          g = 0;
                        }
#line 2283
                        *(dat8 + (i + 1L)) = (unsigned char )g;
#line 2284
                        if (b > 255) {
#line 2284
                          b = 255;
                        } else
#line 2284
                        if (b < 0) {
#line 2284
                          b = 0;
                        }
#line 2285
                        *(dat8 + (i + 2L)) = (unsigned char )b;
#line 2286
                        if (has_alpha) {
#line 2288
                          if (a > 255) {
#line 2288
                            a = 255;
                          } else
#line 2288
                          if (a < 0) {
#line 2288
                            a = 0;
                          }
#line 2289
                          *(dat8 + (i + 3L)) = (unsigned char )a;
                        }
#line 2292
                        index___47 ++;
#line 2293
                        last_i = i + (long )step;
                      } else {
#line 2296
                        goto while_break___0;
                      }
#line 2262
                      i += (long )step;
                    }
                    while_break___0: /* CIL Label */ ;
                    }
#line 2299
                    if (last_i < ssize) {
#line 2301
                      i = last_i;
                      {
#line 2301
                      while (1) {
                        while_continue___1: /* CIL Label */ ;
#line 2301
                        if (! (i < ssize)) {
#line 2301
                          goto while_break___1;
                        }
#line 2303
                        a___0 = 0;
#line 2305
                        if (index___47 < imgsize) {
#line 2307
                          r___0 = *((image->comps + 0)->data + index___47);
#line 2308
                          g___0 = *((image->comps + 1)->data + index___47);
#line 2309
                          b___0 = *((image->comps + 2)->data + index___47);
#line 2310
                          if (has_alpha) {
#line 2310
                            a___0 = *((image->comps + 3)->data + index___47);
                          }
#line 2312
                          if (sgnd) {
#line 2314
                            r___0 += adjust;
#line 2315
                            g___0 += adjust;
#line 2316
                            b___0 += adjust;
#line 2317
                            if (has_alpha) {
#line 2317
                              a___0 += adjust;
                            }
                          }
#line 2319
                          if (r___0 > 255) {
#line 2319
                            r___0 = 255;
                          } else
#line 2319
                          if (r___0 < 0) {
#line 2319
                            r___0 = 0;
                          }
#line 2320
                          if (g___0 > 255) {
#line 2320
                            g___0 = 255;
                          } else
#line 2320
                          if (g___0 < 0) {
#line 2320
                            g___0 = 0;
                          }
#line 2321
                          if (b___0 > 255) {
#line 2321
                            b___0 = 255;
                          } else
#line 2321
                          if (b___0 < 0) {
#line 2321
                            b___0 = 0;
                          }
#line 2323
                          *(dat8 + i) = (unsigned char )r___0;
#line 2324
                          if (i + 1L < ssize) {
#line 2324
                            *(dat8 + (i + 1L)) = (unsigned char )g___0;
                          } else {
#line 2324
                            goto while_break___1;
                          }
#line 2325
                          if (i + 2L < ssize) {
#line 2325
                            *(dat8 + (i + 2L)) = (unsigned char )b___0;
                          } else {
#line 2325
                            goto while_break___1;
                          }
#line 2326
                          if (has_alpha) {
#line 2328
                            if (a___0 > 255) {
#line 2328
                              a___0 = 255;
                            } else
#line 2328
                            if (a___0 < 0) {
#line 2328
                              a___0 = 0;
                            }
#line 2330
                            if (i + 3L < ssize) {
#line 2330
                              *(dat8 + (i + 3L)) = (unsigned char )a___0;
                            } else {
#line 2330
                              goto while_break___1;
                            }
                          }
#line 2332
                          index___47 ++;
                        } else {
#line 2335
                          goto while_break___1;
                        }
#line 2301
                        i += (long )step;
                      }
                      while_break___1: /* CIL Label */ ;
                      }
                    }
                  } else
#line 2341
                  if (bps == 16) {
#line 2343
                    step = (6 + has_alpha) + has_alpha;
#line 2344
                    restx = step - 1;
#line 2346
                    i = (tsize_t )0;
                    {
#line 2346
                    while (1) {
                      while_continue___2: /* CIL Label */ ;
#line 2346
                      if (! (i < ssize - (long )restx)) {
#line 2346
                        goto while_break___2;
                      }
#line 2348
                      a___1 = 0;
#line 2350
                      if (index___47 < imgsize) {
#line 2352
                        r___1 = *((image->comps + 0)->data + index___47);
#line 2353
                        g___1 = *((image->comps + 1)->data + index___47);
#line 2354
                        b___1 = *((image->comps + 2)->data + index___47);
#line 2355
                        if (has_alpha) {
#line 2355
                          a___1 = *((image->comps + 3)->data + index___47);
                        }
#line 2357
                        if (sgnd) {
#line 2359
                          r___1 += adjust;
#line 2360
                          g___1 += adjust;
#line 2361
                          b___1 += adjust;
#line 2362
                          if (has_alpha) {
#line 2362
                            a___1 += adjust;
                          }
                        }
#line 2364
                        if (force16) {
#line 2366
                          r___1 = (r___1 << ushift) + (r___1 >> dshift);
#line 2367
                          g___1 = (g___1 << ushift) + (g___1 >> dshift);
#line 2368
                          b___1 = (b___1 << ushift) + (b___1 >> dshift);
#line 2369
                          if (has_alpha) {
#line 2369
                            a___1 = (a___1 << ushift) + (a___1 >> dshift);
                          }
                        }
#line 2371
                        if (r___1 > 65535) {
#line 2371
                          r___1 = 65535;
                        } else
#line 2371
                        if (r___1 < 0) {
#line 2371
                          r___1 = 0;
                        }
#line 2372
                        if (g___1 > 65535) {
#line 2372
                          g___1 = 65535;
                        } else
#line 2372
                        if (g___1 < 0) {
#line 2372
                          g___1 = 0;
                        }
#line 2373
                        if (b___1 > 65535) {
#line 2373
                          b___1 = 65535;
                        } else
#line 2373
                        if (b___1 < 0) {
#line 2373
                          b___1 = 0;
                        }
#line 2375
                        *(dat8 + i) = (unsigned char )r___1;
#line 2376
                        *(dat8 + (i + 1L)) = (unsigned char )(r___1 >> 8);
#line 2377
                        *(dat8 + (i + 2L)) = (unsigned char )g___1;
#line 2378
                        *(dat8 + (i + 3L)) = (unsigned char )(g___1 >> 8);
#line 2379
                        *(dat8 + (i + 4L)) = (unsigned char )b___1;
#line 2380
                        *(dat8 + (i + 5L)) = (unsigned char )(b___1 >> 8);
#line 2381
                        if (has_alpha) {
#line 2383
                          if (a___1 > 65535) {
#line 2383
                            a___1 = 65535;
                          } else
#line 2383
                          if (a___1 < 0) {
#line 2383
                            a___1 = 0;
                          }
#line 2384
                          *(dat8 + (i + 6L)) = (unsigned char )a___1;
#line 2385
                          *(dat8 + (i + 7L)) = (unsigned char )(a___1 >> 8);
                        }
#line 2387
                        index___47 ++;
#line 2388
                        last_i = i + (long )step;
                      } else {
#line 2391
                        goto while_break___2;
                      }
#line 2346
                      i += (long )step;
                    }
                    while_break___2: /* CIL Label */ ;
                    }
#line 2394
                    if (last_i < ssize) {
#line 2396
                      i = last_i;
                      {
#line 2396
                      while (1) {
                        while_continue___3: /* CIL Label */ ;
#line 2396
                        if (! (i < ssize)) {
#line 2396
                          goto while_break___3;
                        }
#line 2398
                        a___2 = 0;
#line 2400
                        if (index___47 < imgsize) {
#line 2402
                          r___2 = *((image->comps + 0)->data + index___47);
#line 2403
                          g___2 = *((image->comps + 1)->data + index___47);
#line 2404
                          b___2 = *((image->comps + 2)->data + index___47);
#line 2405
                          if (has_alpha) {
#line 2405
                            a___2 = *((image->comps + 3)->data + index___47);
                          }
#line 2407
                          if (sgnd) {
#line 2409
                            r___2 += adjust;
#line 2410
                            g___2 += adjust;
#line 2411
                            b___2 += adjust;
#line 2412
                            if (has_alpha) {
#line 2412
                              a___2 += adjust;
                            }
                          }
#line 2414
                          if (force16) {
#line 2416
                            r___2 = (r___2 << ushift) + (r___2 >> dshift);
#line 2417
                            g___2 = (g___2 << ushift) + (g___2 >> dshift);
#line 2418
                            b___2 = (b___2 << ushift) + (b___2 >> dshift);
#line 2419
                            if (has_alpha) {
#line 2419
                              a___2 = (a___2 << ushift) + (a___2 >> dshift);
                            }
                          }
#line 2421
                          if (r___2 > 65535) {
#line 2421
                            r___2 = 65535;
                          } else
#line 2421
                          if (r___2 < 0) {
#line 2421
                            r___2 = 0;
                          }
#line 2422
                          if (g___2 > 65535) {
#line 2422
                            g___2 = 65535;
                          } else
#line 2422
                          if (g___2 < 0) {
#line 2422
                            g___2 = 0;
                          }
#line 2423
                          if (b___2 > 65535) {
#line 2423
                            b___2 = 65535;
                          } else
#line 2423
                          if (b___2 < 0) {
#line 2423
                            b___2 = 0;
                          }
#line 2425
                          *(dat8 + i) = (unsigned char )r___2;
#line 2426
                          if (i + 1L < ssize) {
#line 2426
                            *(dat8 + (i + 1L)) = (unsigned char )(r___2 >> 8);
                          } else {
#line 2426
                            goto while_break___3;
                          }
#line 2427
                          if (i + 2L < ssize) {
#line 2427
                            *(dat8 + (i + 2L)) = (unsigned char )g___2;
                          } else {
#line 2427
                            goto while_break___3;
                          }
#line 2428
                          if (i + 3L < ssize) {
#line 2428
                            *(dat8 + (i + 3L)) = (unsigned char )(g___2 >> 8);
                          } else {
#line 2428
                            goto while_break___3;
                          }
#line 2429
                          if (i + 4L < ssize) {
#line 2429
                            *(dat8 + (i + 4L)) = (unsigned char )b___2;
                          } else {
#line 2429
                            goto while_break___3;
                          }
#line 2430
                          if (i + 5L < ssize) {
#line 2430
                            *(dat8 + (i + 5L)) = (unsigned char )(b___2 >> 8);
                          } else {
#line 2430
                            goto while_break___3;
                          }
#line 2432
                          if (has_alpha) {
#line 2434
                            if (a___2 > 65535) {
#line 2434
                              a___2 = 65535;
                            } else
#line 2434
                            if (a___2 < 0) {
#line 2434
                              a___2 = 0;
                            }
#line 2435
                            if (i + 6L < ssize) {
#line 2435
                              *(dat8 + (i + 6L)) = (unsigned char )a___2;
                            } else {
#line 2435
                              goto while_break___3;
                            }
#line 2436
                            if (i + 7L < ssize) {
#line 2436
                              *(dat8 + (i + 7L)) = (unsigned char )(a___2 >> 8);
                            } else {
#line 2436
                              goto while_break___3;
                            }
                          }
#line 2438
                          index___47 ++;
                        } else {
#line 2441
                          goto while_break___3;
                        }
#line 2396
                        i += (long )step;
                      }
                      while_break___3: /* CIL Label */ ;
                      }
                    }
                  }
                  {
#line 2446
                  TIFFWriteEncodedStrip(tif, strip, (void *)buf, strip_size);
                  }
#line 2249
                  strip ++;
                }
                while_break: /* CIL Label */ ;
                }
                {
#line 2449
                _TIFFfree((void *)buf);
#line 2450
                TIFFClose(tif);
                }
#line 2452
                return (0);
              }
            }
          }
        }
      }
    }
  }
#line 2455
  if (image->numcomps == 1U) {
    _L: /* CIL Label */ 
    {
#line 2463
    has_alpha = image->numcomps == 2U;
#line 2465
    width = (int )(image->comps + 0)->w;
#line 2466
    height = (int )(image->comps + 0)->h;
#line 2467
    imgsize = width * height;
#line 2470
    TIFFSetField(tif, (uint32 )256, width);
#line 2471
    TIFFSetField(tif, (uint32 )257, height);
#line 2472
    TIFFSetField(tif, (uint32 )277, 1 + has_alpha);
#line 2473
    TIFFSetField(tif, (uint32 )258, bps);
#line 2474
    TIFFSetField(tif, (uint32 )274, 1);
#line 2475
    TIFFSetField(tif, (uint32 )284, 1);
#line 2476
    TIFFSetField(tif, (uint32 )262, 1);
#line 2477
    TIFFSetField(tif, (uint32 )278, 1);
#line 2480
    strip_size = TIFFStripSize(tif);
#line 2481
    buf = _TIFFmalloc(strip_size);
#line 2482
    index___47 = 0;
#line 2484
    strip = (tstrip_t )0;
    }
    {
#line 2484
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2484
      if (! (strip < __cil_tmp54)) {
#line 2484
        goto while_break___4;
      }
      {
#line 2487
      __cil_tmp58 = TIFFStripSize(tif);
#line 2487
      ssize___0 = __cil_tmp58;
#line 2488
      dat8___0 = (unsigned char *)buf;
      }
#line 2490
      if (bps == 8) {
#line 2492
        step___0 = 1 + has_alpha;
#line 2494
        i___0 = (tsize_t )0;
        {
#line 2494
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2494
          if (! (i___0 < ssize___0)) {
#line 2494
            goto while_break___5;
          }
#line 2496
          if (index___47 < imgsize) {
#line 2498
            a___3 = 0;
#line 2500
            r___3 = *((image->comps + 0)->data + index___47);
#line 2501
            if (has_alpha) {
#line 2501
              a___3 = *((image->comps + 1)->data + index___47);
            }
#line 2503
            if (sgnd) {
#line 2505
              r___3 += adjust;
#line 2506
              if (has_alpha) {
#line 2506
                a___3 += adjust;
              }
            }
#line 2508
            if (r___3 > 255) {
#line 2508
              r___3 = 255;
            } else
#line 2508
            if (r___3 < 0) {
#line 2508
              r___3 = 0;
            }
#line 2509
            *(dat8___0 + i___0) = (unsigned char )r___3;
#line 2511
            if (has_alpha) {
#line 2513
              if (a___3 > 255) {
#line 2513
                a___3 = 255;
              } else
#line 2513
              if (a___3 < 0) {
#line 2513
                a___3 = 0;
              }
#line 2514
              *(dat8___0 + (i___0 + 1L)) = (unsigned char )a___3;
            }
#line 2516
            index___47 ++;
          } else {
#line 2519
            goto while_break___5;
          }
#line 2494
          i___0 += (long )step___0;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else
#line 2523
      if (bps == 16) {
#line 2525
        step___0 = (2 + has_alpha) + has_alpha;
#line 2527
        i___0 = (tsize_t )0;
        {
#line 2527
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2527
          if (! (i___0 < ssize___0)) {
#line 2527
            goto while_break___6;
          }
#line 2529
          if (index___47 < imgsize) {
#line 2531
            a___4 = 0;
#line 2533
            r___4 = *((image->comps + 0)->data + index___47);
#line 2534
            if (has_alpha) {
#line 2534
              a___4 = *((image->comps + 1)->data + index___47);
            }
#line 2536
            if (sgnd) {
#line 2538
              r___4 += adjust;
#line 2539
              if (has_alpha) {
#line 2539
                a___4 += adjust;
              }
            }
#line 2541
            if (force16) {
#line 2543
              r___4 = (r___4 << ushift) + (r___4 >> dshift);
#line 2544
              if (has_alpha) {
#line 2544
                a___4 = (a___4 << ushift) + (a___4 >> dshift);
              }
            }
#line 2546
            if (r___4 > 65535) {
#line 2546
              r___4 = 65535;
            } else
#line 2546
            if (r___4 < 0) {
#line 2546
              r___4 = 0;
            }
#line 2547
            *(dat8___0 + i___0) = (unsigned char )r___4;
#line 2548
            *(dat8___0 + (i___0 + 1L)) = (unsigned char )(r___4 >> 8);
#line 2549
            if (has_alpha) {
#line 2551
              if (a___4 > 65535) {
#line 2551
                a___4 = 65535;
              } else
#line 2551
              if (a___4 < 0) {
#line 2551
                a___4 = 0;
              }
#line 2552
              *(dat8___0 + (i___0 + 2L)) = (unsigned char )a___4;
#line 2553
              *(dat8___0 + (i___0 + 3L)) = (unsigned char )(a___4 >> 8);
            }
#line 2555
            index___47 ++;
          } else {
#line 2558
            goto while_break___6;
          }
#line 2527
          i___0 += (long )step___0;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 2561
      TIFFWriteEncodedStrip(tif, strip, (void *)buf, strip_size);
      }
#line 2484
      strip ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 2564
    _TIFFfree(buf);
#line 2565
    TIFFClose(tif);
    }
#line 2567
    return (0);
  } else
#line 2455
  if (image->numcomps == 2U) {
#line 2455
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 2455
      if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 2455
        if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 2455
          goto _L;
        }
      }
    }
  }
  {
#line 2570
  TIFFClose(tif);
#line 2572
  fprintf(stderr, "imagetotif: Bad color format.\n\tOnly RGB(A) and GRAY(A) has been implemented\n\220");
#line 2574
  fprintf(stderr, "\tFOUND: numcomps(%d)\n\tAborting\n", image->numcomps);
  }
#line 2577
  return (1);
}
}
#line 2584 "/root/patron/new_21/src/bin/jp2/convert.c"
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  TIFF *tif ;
  tdata_t buf ;
  tstrip_t strip ;
  tsize_t strip_size ;
  int j ;
  int numcomps ;
  int w ;
  int h ;
  int index___48 ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[4] ;
  opj_image_t *image ;
  int imgsize ;
  int has_alpha ;
  unsigned short tiBps ;
  unsigned short tiPhoto ;
  unsigned short tiSf ;
  unsigned short tiSpp ;
  unsigned short tiPC ;
  unsigned int tiWidth ;
  unsigned int tiHeight ;
  OPJ_BOOL is_cinema ;
  TIFF *__cil_tmp27 ;
  uint16 *sampleinfo ;
  uint16 extrasamples ;
  int __cil_tmp30 ;
  opj_image_t *__cil_tmp31 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 tmp___0 ;
  tmsize_t __cil_tmp34 ;
  void *__cil_tmp35 ;
  tmsize_t __cil_tmp36 ;
  uint32 __cil_tmp37 ;
  unsigned char *dat8 ;
  int step ;
  tsize_t i ;
  tsize_t ssize ;
  tmsize_t __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  tstrip_t __cil_tmp45 ;
  opj_image_t *__cil_tmp46 ;
  OPJ_UINT32 tmp___1 ;
  OPJ_UINT32 tmp___2 ;
  tmsize_t __cil_tmp49 ;
  void *__cil_tmp50 ;
  tmsize_t __cil_tmp51 ;
  uint32 __cil_tmp52 ;
  unsigned char *dat8___0 ;
  tsize_t i___0 ;
  tsize_t ssize___0 ;
  int step___0 ;
  tmsize_t __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  tstrip_t __cil_tmp60 ;

  {
  {
#line 2586
  subsampling_dx = parameters->subsampling_dx;
#line 2587
  subsampling_dy = parameters->subsampling_dy;
#line 2595
  image = (opj_image_t *)((void *)0);
#line 2596
  imgsize = 0;
#line 2597
  has_alpha = 0;
#line 2600
  is_cinema = (int )parameters->rsiz >= 3 && (int )parameters->rsiz <= 6;
#line 2602
  tif = TIFFOpen(filename, "r");
  }
#line 2604
  if (! tif) {
    {
#line 2606
    fprintf(stderr, "tiftoimage:Failed to open %s for reading\n", filename);
    }
#line 2607
    return ((opj_image_t *)0);
  }
  {
#line 2609
  tiPC = (unsigned short )0;
#line 2609
  tiSpp = tiPC;
#line 2609
  tiSf = tiSpp;
#line 2609
  tiPhoto = tiSf;
#line 2609
  tiBps = tiPhoto;
#line 2610
  tiHeight = (unsigned int )0;
#line 2610
  tiWidth = tiHeight;
#line 2612
  TIFFGetField(tif, (uint32 )256, & tiWidth);
#line 2613
  TIFFGetField(tif, (uint32 )257, & tiHeight);
#line 2614
  TIFFGetField(tif, (uint32 )258, & tiBps);
#line 2615
  TIFFGetField(tif, (uint32 )339, & tiSf);
#line 2616
  TIFFGetField(tif, (uint32 )277, & tiSpp);
#line 2617
  TIFFGetField(tif, (uint32 )262, & tiPhoto);
#line 2618
  TIFFGetField(tif, (uint32 )284, & tiPC);
#line 2619
  w = (int )tiWidth;
#line 2620
  h = (int )tiHeight;
  }
#line 2622
  if ((int )tiBps != 8) {
#line 2622
    if ((int )tiBps != 16) {
#line 2622
      if ((int )tiBps != 12) {
#line 2622
        tiBps = (unsigned short )0;
      }
    }
  }
#line 2623
  if ((int )tiPhoto != 1) {
#line 2623
    if ((int )tiPhoto != 2) {
#line 2623
      tiPhoto = (unsigned short )0;
    }
  }
#line 2625
  if (! tiBps) {
    _L: /* CIL Label */ 
#line 2627
    if (! tiBps) {
      {
#line 2628
      fprintf(stderr, "tiftoimage: Bits=%d, Only 8 and 16 bits implemented\n\230\001",
              (int )tiBps);
      }
    } else
#line 2631
    if (! tiPhoto) {
      {
#line 2632
      fprintf(stderr, "tiftoimage: Bad color format %d.\n\tOnly RGB(A) and GRAY(A) has been implemented\n",
              (int )tiPhoto);
      }
    }
    {
#line 2635
    fprintf(stderr, "\tAborting\n\232j\347U");
#line 2636
    TIFFClose(tif);
    }
#line 2638
    return ((opj_image_t *)((void *)0));
  } else
#line 2625
  if (! tiPhoto) {
#line 2625
    goto _L;
  }
  {
#line 2645
  TIFFGetFieldDefaulted(tif, (uint32 )338, & extrasamples, & sampleinfo);
  }
#line 2648
  if ((int )extrasamples >= 1) {
    {
#line 2652
    if ((int )*(sampleinfo + 0) == 0) {
#line 2652
      goto case_0;
    }
#line 2660
    if ((int )*(sampleinfo + 0) == 2) {
#line 2660
      goto case_2;
    }
#line 2660
    if ((int )*(sampleinfo + 0) == 1) {
#line 2660
      goto case_2;
    }
#line 2650
    goto switch_break;
    case_0: /* CIL Label */ 
#line 2655
    if ((int )tiSpp > 3) {
#line 2656
      has_alpha = 1;
    }
#line 2657
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 2661
    has_alpha = 1;
#line 2662
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 2666
  if ((int )tiSpp == 4) {
#line 2666
    has_alpha = 1;
  } else
#line 2666
  if ((int )tiSpp == 2) {
#line 2666
    has_alpha = 1;
  }
  {
#line 2671
  memset(& cmptparm[0], 0, 4UL * sizeof(opj_image_cmptparm_t ));
  }
#line 2673
  if ((int )tiPhoto == 2) {
#line 2673
    if (is_cinema) {
      {
#line 2674
      fprintf(stdout, "WARNING:\nInput image bitdepth is %d bits\nTIF conversion has automatically rescaled to 12-bits\nto comply with cinema profiles.\n\233j\347U",
              (int )tiBps);
      }
    }
  }
#line 2681
  if ((int )tiPhoto == 2) {
#line 2683
    numcomps = 3 + has_alpha;
#line 2684
    color_space = (OPJ_COLOR_SPACE )1;
#line 2687
    j = 0;
    {
#line 2687
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2687
      if (! (j < numcomps)) {
#line 2687
        goto while_break;
      }
#line 2689
      if (is_cinema) {
#line 2691
        cmptparm[j].prec = (OPJ_UINT32 )12;
#line 2692
        cmptparm[j].bpp = (OPJ_UINT32 )12;
      } else {
#line 2696
        cmptparm[j].prec = (OPJ_UINT32 )tiBps;
#line 2697
        cmptparm[j].bpp = (OPJ_UINT32 )tiBps;
      }
#line 2699
      cmptparm[j].dx = (OPJ_UINT32 )subsampling_dx;
#line 2700
      cmptparm[j].dy = (OPJ_UINT32 )subsampling_dy;
#line 2701
      cmptparm[j].w = (OPJ_UINT32 )w;
#line 2702
      cmptparm[j].h = (OPJ_UINT32 )h;
#line 2687
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2712
    image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
    }
#line 2715
    if (! image) {
      {
#line 2717
      TIFFClose(tif);
      }
#line 2718
      return ((opj_image_t *)((void *)0));
    }
#line 2722
    image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 2723
    image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 2724
    if (! image->x0) {
#line 2724
      tmp = (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx + 1U;
    } else {
#line 2724
      tmp = (image->x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
    }
#line 2724
    image->x1 = tmp;
#line 2726
    if (! image->y0) {
#line 2726
      tmp___0 = (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy + 1U;
    } else {
#line 2726
      tmp___0 = (image->y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
    }
    {
#line 2726
    image->y1 = tmp___0;
#line 2729
    __cil_tmp34 = TIFFStripSize(tif);
#line 2729
    __cil_tmp35 = _TIFFmalloc(__cil_tmp34);
#line 2729
    buf = __cil_tmp35;
#line 2731
    strip_size = TIFFStripSize(tif);
#line 2732
    index___48 = 0;
#line 2733
    imgsize = (int )((image->comps + 0)->w * (image->comps + 0)->h);
#line 2736
    strip = (tstrip_t )0;
    }
    {
#line 2736
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2736
      if (! (strip < __cil_tmp37)) {
#line 2736
        goto while_break___0;
      }
      {
#line 2741
      ssize = TIFFReadEncodedStrip(tif, strip, buf, strip_size);
#line 2742
      dat8 = (unsigned char *)buf;
      }
#line 2744
      if ((int )tiBps == 16) {
#line 2746
        step = (6 + has_alpha) + has_alpha;
#line 2748
        i = (tsize_t )0;
        {
#line 2748
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2748
          if (! (i < ssize)) {
#line 2748
            goto while_break___1;
          }
#line 2750
          if (index___48 < imgsize) {
#line 2752
            *((image->comps + 0)->data + index___48) = ((int )*(dat8 + (i + 1L)) << 8) | (int )*(dat8 + i);
#line 2753
            *((image->comps + 1)->data + index___48) = ((int )*(dat8 + (i + 3L)) << 8) | (int )*(dat8 + (i + 2L));
#line 2754
            *((image->comps + 2)->data + index___48) = ((int )*(dat8 + (i + 5L)) << 8) | (int )*(dat8 + (i + 4L));
#line 2755
            if (has_alpha) {
#line 2756
              *((image->comps + 3)->data + index___48) = ((int )*(dat8 + (i + 7L)) << 8) | (int )*(dat8 + (i + 6L));
            }
#line 2758
            if (is_cinema) {
#line 2762
              *((image->comps + 0)->data + index___48) = (*((image->comps + 0)->data + index___48) + 8) >> 4;
#line 2764
              *((image->comps + 1)->data + index___48) = (*((image->comps + 1)->data + index___48) + 8) >> 4;
#line 2766
              *((image->comps + 2)->data + index___48) = (*((image->comps + 2)->data + index___48) + 8) >> 4;
#line 2768
              if (has_alpha) {
#line 2769
                *((image->comps + 3)->data + index___48) = (*((image->comps + 3)->data + index___48) + 8) >> 4;
              }
            }
#line 2772
            index___48 ++;
          } else {
#line 2775
            goto while_break___1;
          }
#line 2748
          i += (long )step;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 2779
      if ((int )tiBps == 8) {
#line 2781
        step = 3 + has_alpha;
#line 2783
        i = (tsize_t )0;
        {
#line 2783
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2783
          if (! (i < ssize)) {
#line 2783
            goto while_break___2;
          }
#line 2785
          if (index___48 < imgsize) {
#line 2788
            *((image->comps + 0)->data + index___48) = (OPJ_INT32 )*(dat8 + i);
#line 2789
            *((image->comps + 1)->data + index___48) = (OPJ_INT32 )*(dat8 + (i + 1L));
#line 2790
            *((image->comps + 2)->data + index___48) = (OPJ_INT32 )*(dat8 + (i + 2L));
#line 2791
            if (has_alpha) {
#line 2792
              *((image->comps + 3)->data + index___48) = (OPJ_INT32 )*(dat8 + (i + 3L));
            }
#line 2795
            if (is_cinema) {
#line 2800
              *((image->comps + 0)->data + index___48) <<= 4;
#line 2801
              *((image->comps + 1)->data + index___48) <<= 4;
#line 2802
              *((image->comps + 2)->data + index___48) <<= 4;
#line 2803
              if (has_alpha) {
#line 2804
                *((image->comps + 3)->data + index___48) <<= 4;
              }
            }
#line 2807
            index___48 ++;
          } else {
#line 2810
            goto while_break___2;
          }
#line 2783
          i += (long )step;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else
#line 2814
      if ((int )tiBps == 12) {
#line 2816
        step = 9;
#line 2818
        i = (tsize_t )0;
        {
#line 2818
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2818
          if (! (i < ssize)) {
#line 2818
            goto while_break___3;
          }
#line 2820
          if ((index___48 < imgsize) & (index___48 + 1 < imgsize)) {
#line 2822
            *((image->comps + 0)->data + index___48) = ((int )*(dat8 + i) << 4) | ((int )*(dat8 + (i + 1L)) >> 4);
#line 2823
            *((image->comps + 1)->data + index___48) = (((int )*(dat8 + (i + 1L)) & 15) << 8) | (int )*(dat8 + (i + 2L));
#line 2825
            *((image->comps + 2)->data + index___48) = ((int )*(dat8 + (i + 3L)) << 4) | ((int )*(dat8 + (i + 4L)) >> 4);
#line 2826
            *((image->comps + 0)->data + (index___48 + 1)) = (((int )*(dat8 + (i + 4L)) & 15) << 8) | (int )*(dat8 + (i + 5L));
#line 2828
            *((image->comps + 1)->data + (index___48 + 1)) = ((int )*(dat8 + (i + 6L)) << 4) | ((int )*(dat8 + (i + 7L)) >> 4);
#line 2829
            *((image->comps + 2)->data + (index___48 + 1)) = (((int )*(dat8 + (i + 7L)) & 15) << 8) | (int )*(dat8 + (i + 8L));
#line 2831
            index___48 += 2;
          } else {
#line 2834
            goto while_break___3;
          }
#line 2818
          i += (long )step;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 2736
      strip ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2839
    _TIFFfree(buf);
#line 2840
    TIFFClose(tif);
    }
#line 2842
    return (image);
  }
#line 2845
  if ((int )tiPhoto == 1) {
#line 2847
    numcomps = 1 + has_alpha;
#line 2848
    color_space = (OPJ_COLOR_SPACE )2;
#line 2850
    j = 0;
    {
#line 2850
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2850
      if (! (j < numcomps)) {
#line 2850
        goto while_break___4;
      }
#line 2852
      cmptparm[j].prec = (OPJ_UINT32 )tiBps;
#line 2853
      cmptparm[j].bpp = (OPJ_UINT32 )tiBps;
#line 2854
      cmptparm[j].dx = (OPJ_UINT32 )subsampling_dx;
#line 2855
      cmptparm[j].dy = (OPJ_UINT32 )subsampling_dy;
#line 2856
      cmptparm[j].w = (OPJ_UINT32 )w;
#line 2857
      cmptparm[j].h = (OPJ_UINT32 )h;
#line 2850
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 2862
    image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
    }
#line 2865
    if (! image) {
      {
#line 2867
      TIFFClose(tif);
      }
#line 2868
      return ((opj_image_t *)((void *)0));
    }
#line 2872
    image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 2873
    image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 2874
    if (! image->x0) {
#line 2874
      tmp___1 = (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx + 1U;
    } else {
#line 2874
      tmp___1 = (image->x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
    }
#line 2874
    image->x1 = tmp___1;
#line 2876
    if (! image->y0) {
#line 2876
      tmp___2 = (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy + 1U;
    } else {
#line 2876
      tmp___2 = (image->y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
    }
    {
#line 2876
    image->y1 = tmp___2;
#line 2879
    __cil_tmp49 = TIFFStripSize(tif);
#line 2879
    __cil_tmp50 = _TIFFmalloc(__cil_tmp49);
#line 2879
    buf = __cil_tmp50;
#line 2881
    strip_size = TIFFStripSize(tif);
#line 2882
    index___48 = 0;
#line 2883
    imgsize = (int )((image->comps + 0)->w * (image->comps + 0)->h);
#line 2886
    strip = (tstrip_t )0;
    }
    {
#line 2886
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2886
      if (! (strip < __cil_tmp52)) {
#line 2886
        goto while_break___5;
      }
      {
#line 2892
      ssize___0 = TIFFReadEncodedStrip(tif, strip, buf, strip_size);
#line 2893
      dat8___0 = (unsigned char *)buf;
      }
#line 2895
      if ((int )tiBps == 16) {
#line 2897
        step___0 = (2 + has_alpha) + has_alpha;
#line 2899
        i___0 = (tsize_t )0;
        {
#line 2899
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2899
          if (! (i___0 < ssize___0)) {
#line 2899
            goto while_break___6;
          }
#line 2901
          if (index___48 < imgsize) {
#line 2903
            *((image->comps + 0)->data + index___48) = ((int )*(dat8___0 + (i___0 + 1L)) << 8) | (int )*(dat8___0 + i___0);
#line 2904
            if (has_alpha) {
#line 2905
              *((image->comps + 1)->data + index___48) = ((int )*(dat8___0 + (i___0 + 3L)) << 8) | (int )*(dat8___0 + (i___0 + 2L));
            }
#line 2906
            index___48 ++;
          } else {
#line 2909
            goto while_break___6;
          }
#line 2899
          i___0 += (long )step___0;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else
#line 2913
      if ((int )tiBps == 8) {
#line 2915
        step___0 = 1 + has_alpha;
#line 2917
        i___0 = (tsize_t )0;
        {
#line 2917
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2917
          if (! (i___0 < ssize___0)) {
#line 2917
            goto while_break___7;
          }
#line 2919
          if (index___48 < imgsize) {
#line 2921
            *((image->comps + 0)->data + index___48) = (OPJ_INT32 )*(dat8___0 + i___0);
#line 2922
            if (has_alpha) {
#line 2923
              *((image->comps + 1)->data + index___48) = (OPJ_INT32 )*(dat8___0 + (i___0 + 1L));
            }
#line 2924
            index___48 ++;
          } else {
#line 2927
            goto while_break___7;
          }
#line 2917
          i___0 += (long )step___0;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 2886
      strip ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 2932
    _TIFFfree(buf);
#line 2933
    TIFFClose(tif);
    }
  }
#line 2937
  return (image);
}
}
#line 2948 "/root/patron/new_21/src/bin/jp2/convert.c"
static opj_image_t *rawtoimage_common(char const   *filename , opj_cparameters_t *parameters ,
                                      raw_cparameters_t *raw_cp , OPJ_BOOL big_endian ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *f ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t *cmptparm ;
  opj_image_t *image ;
  unsigned short ch ;
  FILE *__cil_tmp17 ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;
  opj_image_t *__cil_tmp20 ;
  unsigned char value ;
  int nloop ;
  unsigned long __cil_tmp23 ;
  int tmp ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  unsigned short value___0 ;
  int nloop___0 ;
  unsigned char temp1 ;
  unsigned char temp2 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int tmp___0 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  unsigned long __cil_tmp36 ;

  {
#line 2949
  subsampling_dx = parameters->subsampling_dx;
#line 2950
  subsampling_dy = parameters->subsampling_dy;
#line 2952
  f = (FILE *)((void *)0);
#line 2956
  image = (opj_image_t *)((void *)0);
#line 2959
  if (! (((raw_cp->rawWidth & raw_cp->rawHeight) & raw_cp->rawComp) & raw_cp->rawBitDepth) == 0) {
    {
#line 2961
    fprintf(stderr, "\nError: invalid raw image parameters\n");
#line 2962
    fprintf(stderr, "Please use the Format option -F:\n");
#line 2963
    fprintf(stderr, "-F <width>,<height>,<ncomp>,<bitdepth>,{s,u}@<dx1>x<dy1>:...:<dxn>x<dyn>\n");
#line 2964
    fprintf(stderr, "If subsampling is omitted, 1x1 is assumed for all components\nU");
#line 2965
    fprintf(stderr, "Example: -i image.raw -o image.j2k -F 512,512,3,8,u@1x1:2x2:2x2\n\220");
#line 2966
    fprintf(stderr, "         for raw 512x512 image with 4:2:0 subsampling\n");
#line 2967
    fprintf(stderr, "Aborting.\n\231j\347U");
    }
#line 2968
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2971
  f = fopen(filename, "rb\231j\347U");
  }
#line 2972
  if (! f) {
    {
#line 2973
    fprintf(stderr, "Failed to open %s for reading !!\nT\234j\347U", filename);
#line 2974
    fprintf(stderr, "Aborting\n");
    }
#line 2975
    return ((opj_image_t *)((void *)0));
  }
#line 2977
  numcomps = raw_cp->rawComp;
#line 2980
  if (numcomps == 0) {
#line 2981
    color_space = (OPJ_COLOR_SPACE )2;
  } else
#line 2982
  if (numcomps >= 3) {
#line 2982
    if ((int )parameters->tcp_mct == 0) {
#line 2983
      color_space = (OPJ_COLOR_SPACE )3;
    } else {
#line 2982
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2984
  if (numcomps >= 3) {
#line 2984
    if ((int )parameters->tcp_mct != 2) {
#line 2985
      color_space = (OPJ_COLOR_SPACE )1;
    } else {
#line 2987
      color_space = (OPJ_COLOR_SPACE )-1;
    }
  } else {
#line 2987
    color_space = (OPJ_COLOR_SPACE )-1;
  }
  {
#line 2989
  w = raw_cp->rawWidth;
#line 2990
  h = raw_cp->rawHeight;
#line 2991
  __cil_tmp18 = calloc((unsigned long )numcomps, sizeof(opj_image_cmptparm_t ));
#line 2991
  cmptparm = (opj_image_cmptparm_t *)__cil_tmp18;
  }
#line 2992
  if (! cmptparm) {
    {
#line 2993
    fprintf(stderr, "Failed to allocate image components parameters !!\n");
#line 2994
    fprintf(stderr, "Aborting\n\r\234j\347U");
    }
#line 2995
    return ((opj_image_t *)((void *)0));
  }
#line 2998
  i = 0;
  {
#line 2998
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2998
    if (! (i < numcomps)) {
#line 2998
      goto while_break;
    }
#line 2999
    (cmptparm + i)->prec = (OPJ_UINT32 )raw_cp->rawBitDepth;
#line 3000
    (cmptparm + i)->bpp = (OPJ_UINT32 )raw_cp->rawBitDepth;
#line 3001
    (cmptparm + i)->sgnd = (OPJ_UINT32 )raw_cp->rawSigned;
#line 3002
    (cmptparm + i)->dx = (OPJ_UINT32 )(subsampling_dx * (raw_cp->rawComps + i)->dx);
#line 3003
    (cmptparm + i)->dy = (OPJ_UINT32 )(subsampling_dy * (raw_cp->rawComps + i)->dy);
#line 3004
    (cmptparm + i)->w = (OPJ_UINT32 )w;
#line 3005
    (cmptparm + i)->h = (OPJ_UINT32 )h;
#line 2998
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3008
  image = opj_image_create((OPJ_UINT32 )numcomps, cmptparm + 0, color_space);
#line 3009
  free(cmptparm);
  }
#line 3010
  if (! image) {
    {
#line 3011
    fclose(f);
    }
#line 3012
    return ((opj_image_t *)((void *)0));
  }
#line 3015
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 3016
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 3017
  image->x1 = ((OPJ_UINT32 )parameters->image_offset_x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
#line 3018
  image->y1 = ((OPJ_UINT32 )parameters->image_offset_y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
#line 3020
  if (raw_cp->rawBitDepth <= 8) {
#line 3022
    value = (unsigned char )0;
#line 3023
    compno = 0;
    {
#line 3023
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3023
      if (! (compno < numcomps)) {
#line 3023
        goto while_break___0;
      }
#line 3024
      nloop = (w * h) / ((raw_cp->rawComps + compno)->dx * (raw_cp->rawComps + compno)->dy);
#line 3025
      i = 0;
      {
#line 3025
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3025
        if (! (i < nloop)) {
#line 3025
          goto while_break___1;
        }
        {
#line 3026
        __cil_tmp23 = fread(& value, (unsigned long )1, (unsigned long )1, f);
        }
#line 3026
        if (! __cil_tmp23) {
          {
#line 3027
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 3028
          return ((opj_image_t *)((void *)0));
        }
#line 3030
        if (raw_cp->rawSigned) {
#line 3030
          tmp = (int )((char )value);
        } else {
#line 3030
          tmp = (int )value;
        }
#line 3030
        *((image->comps + compno)->data + i) = tmp;
#line 3025
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3023
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 3034
  if (raw_cp->rawBitDepth <= 16) {
#line 3037
    compno = 0;
    {
#line 3037
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3037
      if (! (compno < numcomps)) {
#line 3037
        goto while_break___2;
      }
#line 3038
      nloop___0 = (w * h) / ((raw_cp->rawComps + compno)->dx * (raw_cp->rawComps + compno)->dx);
#line 3039
      i = 0;
      {
#line 3039
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3039
        if (! (i < nloop___0)) {
#line 3039
          goto while_break___3;
        }
        {
#line 3042
        __cil_tmp31 = fread(& temp1, (unsigned long )1, (unsigned long )1, f);
        }
#line 3042
        if (! __cil_tmp31) {
          {
#line 3043
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 3044
          return ((opj_image_t *)((void *)0));
        }
        {
#line 3046
        __cil_tmp32 = fread(& temp2, (unsigned long )1, (unsigned long )1, f);
        }
#line 3046
        if (! __cil_tmp32) {
          {
#line 3047
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 3048
          return ((opj_image_t *)((void *)0));
        }
#line 3050
        if (big_endian) {
#line 3052
          value___0 = (unsigned short )(((int )temp1 << 8) + (int )temp2);
        } else {
#line 3056
          value___0 = (unsigned short )(((int )temp2 << 8) + (int )temp1);
        }
#line 3058
        if (raw_cp->rawSigned) {
#line 3058
          tmp___0 = (int )((short )value___0);
        } else {
#line 3058
          tmp___0 = (int )value___0;
        }
#line 3058
        *((image->comps + compno)->data + i) = tmp___0;
#line 3039
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3037
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 3063
    fprintf(stderr, "OpenJPEG cannot encode raw components with bit depth higher than 16 bits.\n\234j\347U");
    }
#line 3064
    return ((opj_image_t *)((void *)0));
  }
  {
#line 3067
  __cil_tmp36 = fread(& ch, (unsigned long )1, (unsigned long )1, f);
  }
#line 3067
  if (__cil_tmp36) {
    {
#line 3068
    fprintf(stderr, "Warning. End of raw file not reached... processing anyway\n\234j\347U");
    }
  }
  {
#line 3070
  fclose(f);
  }
#line 3072
  return (image);
}
}
#line 3075 "/root/patron/new_21/src/bin/jp2/convert.c"
opj_image_t *rawltoimage(char const   *filename , opj_cparameters_t *parameters ,
                         raw_cparameters_t *raw_cp ) 
{ 
  opj_image_t *__cil_tmp4 ;

  {
  {
#line 3076
  __cil_tmp4 = rawtoimage_common(filename, parameters, raw_cp, 0);
  }
#line 3076
  return (__cil_tmp4);
}
}
#line 3079 "/root/patron/new_21/src/bin/jp2/convert.c"
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) 
{ 
  opj_image_t *__cil_tmp4 ;

  {
  {
#line 3080
  __cil_tmp4 = rawtoimage_common(filename, parameters, raw_cp, 1);
  }
#line 3080
  return (__cil_tmp4);
}
}
// #line 3083 "/root/patron/new_21/src/bin/jp2/convert.c"
// static int imagetoraw_common(opj_image_t *image , char const   *outfile , OPJ_BOOL big_endian ) 
// { 
//   FILE *rawFile ;
//   size_t res ;
//   unsigned int compno ;
//   int w ;
//   int h ;
//   int fails ;
//   int line ;
//   int row ;
//   int curr ;
//   int mask ;
//   int *ptr ;
//   unsigned char uc ;
//   FILE *__cil_tmp16 ;
//   char const   *tmp ;
//   unsigned long __cil_tmp18 ;
//   int *__cil_tmp19 ;
//   int __cil_tmp20 ;
//   int __cil_tmp21 ;
//   unsigned long __cil_tmp22 ;
//   int *__cil_tmp23 ;
//   int __cil_tmp24 ;
//   int __cil_tmp25 ;
//   union __anonunion_120 uc16 ;
//   unsigned long __cil_tmp27 ;
//   int *__cil_tmp28 ;
//   int __cil_tmp29 ;
//   int __cil_tmp30 ;
//   union __anonunion_121 uc16___0 ;
//   unsigned long __cil_tmp32 ;
//   int *__cil_tmp33 ;
//   int __cil_tmp34 ;
//   int __cil_tmp35 ;
//   unsigned int __cil_tmp36 ;

//   {
// #line 3085
//   rawFile = (FILE *)((void *)0);
// #line 3094
//   if ((image->numcomps * image->x1) * image->y1 == 0U) {
//     {
// #line 3096
//     fprintf(stderr, "\nError: invalid raw image parameters\nU");
//     }
// #line 3097
//     return (1);
//   }
//   {
// #line 3100
//   rawFile = fopen(outfile, "wb");
//   }
// #line 3101
//   if (! rawFile) {
//     {
// #line 3102
//     fprintf(stderr, "Failed to open %s for writing !!\nw\234j\347U", outfile);
//     }
// #line 3103
//     return (1);
//   }
//   {
// #line 3106
//   fails = 1;
// #line 3107
//   fprintf(stdout, "Raw image characteristics: %d components\nt\233j\347U", image->numcomps);
// #line 3109
//   compno = (unsigned int )0;
//   }
//   {
// #line 3109
//   while (1) {
//     while_continue: /* CIL Label */ ;
// #line 3109
//     if (! (compno < image->numcomps)) {
// #line 3109
//       goto while_break;
//     }
// #line 3111
//     if ((image->comps + compno)->sgnd == 1U) {
// #line 3111
//       strcpy((char *)tmp, "signed");;
//     } else {
// #line 3111
//       strcpy((char *)tmp, "unsigned\220");;
//     }
//     {
// #line 3111
//     fprintf(stdout, "Component %d characteristics: %dx%dx%d %s\n", compno, (image->comps + compno)->w,
//             (image->comps + compno)->h, (image->comps + compno)->prec, tmp);
// #line 3114
//     w = (int )(image->comps + compno)->w;
// #line 3115
//     h = (int )(image->comps + compno)->h;
//     }
// #line 3117
//     if ((image->comps + compno)->prec <= 8U) {
// #line 3119
//       if ((image->comps + compno)->sgnd == 1U) {
// #line 3121
//         mask = (1 << (image->comps + compno)->prec) - 1;
// #line 3122
//         ptr = (image->comps + compno)->data;
// #line 3123
//         line = 0;
//         {
// #line 3123
//         while (1) {
//           while_continue___0: /* CIL Label */ ;
// #line 3123
//           if (! (line < h)) {
// #line 3123
//             goto while_break___0;
//           }
// #line 3124
//           row = 0;
//           {
// #line 3124
//           while (1) {
//             while_continue___1: /* CIL Label */ ;
// #line 3124
//             if (! (row < w)) {
// #line 3124
//               goto while_break___1;
//             }
// #line 3125
//             curr = *ptr;
// #line 3126
//             if (curr > 127) {
// #line 3126
//               curr = 127;
//             } else
// #line 3126
//             if (curr < -128) {
// #line 3126
//               curr = - 128;
//             }
//             {
// #line 3127
//             uc = (unsigned char )(curr & mask);
// #line 3128
//             res = fwrite(& uc, (unsigned long )1, (unsigned long )1, rawFile);
//             }
// #line 3129
//             if (res < 1UL) {
//               {
// #line 3130
//               fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
//               }
// #line 3131
//               goto fin;
//             }
// #line 3133
//             ptr ++;
// #line 3124
//             row ++;
//           }
//           while_break___1: /* CIL Label */ ;
//           }
// #line 3123
//           line ++;
//         }
//         while_break___0: /* CIL Label */ ;
//         }
//       } else
// #line 3137
//       if ((image->comps + compno)->sgnd == 0U) {
// #line 3139
//         mask = (1 << (image->comps + compno)->prec) - 1;
// #line 3140
//         ptr = (image->comps + compno)->data;
// #line 3141
//         line = 0;
//         {
// #line 3141
//         while (1) {
//           while_continue___2: /* CIL Label */ ;
// #line 3141
//           if (! (line < h)) {
// #line 3141
//             goto while_break___2;
//           }
// #line 3142
//           row = 0;
//           {
// #line 3142
//           while (1) {
//             while_continue___3: /* CIL Label */ ;
// #line 3142
//             if (! (row < w)) {
// #line 3142
//               goto while_break___3;
//             }
// #line 3143
//             curr = *ptr;
// #line 3144
//             if (curr > 255) {
// #line 3144
//               curr = 255;
//             } else
// #line 3144
//             if (curr < 0) {
// #line 3144
//               curr = 0;
//             }
//             {
// #line 3145
//             uc = (unsigned char )(curr & mask);
// #line 3146
//             res = fwrite(& uc, (unsigned long )1, (unsigned long )1, rawFile);
//             }
// #line 3147
//             if (res < 1UL) {
//               {
// #line 3148
//               fprintf(stderr, "failed to write 1 byte for %s\n\002", outfile);
//               }
// #line 3149
//               goto fin;
//             }
// #line 3151
//             ptr ++;
// #line 3142
//             row ++;
//           }
//           while_break___3: /* CIL Label */ ;
//           }
// #line 3141
//           line ++;
//         }
//         while_break___2: /* CIL Label */ ;
//         }
//       }
//     } else
// #line 3156
//     if ((image->comps + compno)->prec <= 16U) {
// #line 3158
//       if ((image->comps + compno)->sgnd == 1U) {
// #line 3161
//         mask = (1 << (image->comps + compno)->prec) - 1;
// #line 3162
//         ptr = (image->comps + compno)->data;
// #line 3163
//         line = 0;
//         {
// #line 3163
//         while (1) {
//           while_continue___4: /* CIL Label */ ;
// #line 3163
//           if (! (line < h)) {
// #line 3163
//             goto while_break___4;
//           }
// #line 3164
//           row = 0;
//           {
// #line 3164
//           while (1) {
//             while_continue___5: /* CIL Label */ ;
// #line 3164
//             if (! (row < w)) {
// #line 3164
//               goto while_break___5;
//             }
// #line 3165
//             curr = *ptr;
// #line 3166
//             if (curr > 32767) {
// #line 3166
//               curr = 32767;
//             } else
// #line 3166
//             if (curr < -32768) {
// #line 3166
//               curr = - 32768;
//             }
//             {
// #line 3167
//             uc16.val = (short )(curr & mask);
// #line 3168
//             res = fwrite((signed char *)uc16.vals, (unsigned long )1, (unsigned long )2,
//                          rawFile);
//             }
// #line 3169
//             if (res < 2UL) {
//               {
// #line 3170
//               fprintf(stderr, "failed to write 2 byte for %s\n", outfile);
//               }
// #line 3171
//               goto fin;
//             }
// #line 3173
//             ptr ++;
// #line 3164
//             row ++;
//           }
//           while_break___5: /* CIL Label */ ;
//           }
// #line 3163
//           line ++;
//         }
//         while_break___4: /* CIL Label */ ;
//         }
//       } else
// #line 3177
//       if ((image->comps + compno)->sgnd == 0U) {
// #line 3180
//         mask = (1 << (image->comps + compno)->prec) - 1;
// #line 3181
//         ptr = (image->comps + compno)->data;
// #line 3182
//         line = 0;
//         {
// #line 3182
//         while (1) {
//           while_continue___6: /* CIL Label */ ;
// #line 3182
//           if (! (line < h)) {
// #line 3182
//             goto while_break___6;
//           }
// #line 3183
//           row = 0;
//           {
// #line 3183
//           while (1) {
//             while_continue___7: /* CIL Label */ ;
// #line 3183
//             if (! (row < w)) {
// #line 3183
//               goto while_break___7;
//             }
// #line 3184
//             curr = *ptr;
// #line 3185
//             if (curr > 65536) {
// #line 3185
//               curr = 65536;
//             } else
// #line 3185
//             if (curr < 0) {
// #line 3185
//               curr = 0;
//             }
//             {
// #line 3186
//             uc16___0.val = (unsigned short )(curr & mask);
// #line 3187
//             res = fwrite((unsigned char *)uc16___0.vals, (unsigned long )1, (unsigned long )2,
//                          rawFile);
//             }
// #line 3188
//             if (res < 2UL) {
//               {
// #line 3189
//               fprintf(stderr, "failed to write 2 byte for %s\n", outfile);
//               }
// #line 3190
//               goto fin;
//             }
// #line 3192
//             ptr ++;
// #line 3183
//             row ++;
//           }
//           while_break___7: /* CIL Label */ ;
//           }
// #line 3182
//           line ++;
//         }
//         while_break___6: /* CIL Label */ ;
//         }
//       }
//     } else
// #line 3197
//     if ((image->comps + compno)->prec <= 32U) {
//       {
// #line 3199
//       fprintf(stderr, "More than 16 bits per component no handled yet\n");
//       }
// #line 3200
//       goto fin;
//     } else {
//       {
// #line 3204
//       fprintf(stderr, "Error: invalid precision: %d\n", (image->comps + compno)->prec);
//       }
// #line 3205
//       goto fin;
//     }
// #line 3109
//     compno ++;
//   }
//   while_break: /* CIL Label */ ;
//   }
// #line 3208
//   fails = 0;
//   fin: 
//   {
// #line 3210
//   fclose(rawFile);
//   }
// #line 3211
//   return (fails);
// }
// }
#line 3214 "/root/patron/new_21/src/bin/jp2/convert.c"
int imagetoraw(opj_image_t *image , char const   *outfile ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 3216
  __cil_tmp3 = 0;
  }
#line 3216
  return (__cil_tmp3);
}
}
#line 3219 "/root/patron/new_21/src/bin/jp2/convert.c"
int imagetorawl(opj_image_t *image , char const   *outfile ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 3221
  __cil_tmp3 = 0;
  }
#line 3221
  return (__cil_tmp3);
}
}
#line 3230 "/root/patron/new_21/src/bin/jp2/convert.c"
opj_image_t *pngtoimage(char const   *read_idf , opj_cparameters_t *params ) 
{ 
  png_structp png ;
  png_infop info ;
  double gamma___0 ;
  double display_exponent ;
  int bit_depth ;
  int interlace_type ;
  int compression_type ;
  int filter_type ;
  int unit ;
  png_uint_32 resx ;
  png_uint_32 resy ;
  unsigned int i ;
  unsigned int j ;
  png_uint_32 width ;
  png_uint_32 height ;
  int color_type ;
  int has_alpha ;
  int is16 ;
  unsigned char *s ;
  FILE *reader ;
  unsigned char **rows ;
  opj_image_t *image ;
  opj_image_cmptparm_t cmptparm[4] ;
  int sub_dx ;
  int sub_dy ;
  unsigned int nr_comp ;
  int *r ;
  int *g ;
  int *b ;
  int *a ;
  unsigned char sigbuf[8] ;
  FILE *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  int __cil_tmp36 ;
  png_structp __cil_tmp37 ;
  png_infop __cil_tmp38 ;
  jmp_buf *__cil_tmp39 ;
  int __cil_tmp40 ;
  png_uint_32 __cil_tmp41 ;
  png_uint_32 __cil_tmp42 ;
  int tmp ;
  png_uint_32 __cil_tmp44 ;
  png_byte __cil_tmp45 ;
  png_byte __cil_tmp46 ;
  void *__cil_tmp47 ;
  size_t __cil_tmp48 ;
  void *__cil_tmp49 ;
  opj_image_t *__cil_tmp50 ;
  int *__cil_tmp51 ;
  int *__cil_tmp52 ;
  int *__cil_tmp53 ;
  int *__cil_tmp54 ;
  int *__cil_tmp55 ;
  unsigned char *__cil_tmp56 ;
  int *__cil_tmp57 ;
  unsigned char *__cil_tmp58 ;
  int *__cil_tmp59 ;
  unsigned char *__cil_tmp60 ;
  int *__cil_tmp61 ;
  unsigned char *__cil_tmp62 ;

  {
  {
#line 3249
  a = (int *)((void *)0);
#line 3252
  reader = fopen(read_idf, "rb\235j\347U");
  }
#line 3252
  if (reader == (void *)0) {
    {
#line 3254
    fprintf(stderr, "pngtoimage: can not open %s\n\347U", read_idf);
    }
#line 3255
    return ((opj_image_t *)((void *)0));
  }
  {
#line 3257
  image = (opj_image_t *)((void *)0);
#line 3257
  png = (png_structp )((void *)0);
#line 3257
  rows = (unsigned char **)((void *)0);
#line 3259
  __cil_tmp36 = memcmp((unsigned char *)sigbuf, "\211PNG\r\n\032\n\251", (unsigned long )8);
  }
  {
#line 3259
  __cil_tmp35 = fread((unsigned char *)sigbuf, (unsigned long )1, (unsigned long )8,
                      reader);
  }
#line 3259
  if (__cil_tmp35 != 8UL) {
    {
    {
#line 3262
    fprintf(stderr, "pngtoimage: %s is no valid PNG file\n\347U", read_idf);
    }
    }
#line 3263
    goto fin;
  } else
#line 3259
  if (__cil_tmp36 != 0) {
    {
    {
#line 3262
    fprintf(stderr, "pngtoimage: %s is no valid PNG file\n\347U", read_idf);
    }
    }
#line 3263
    goto fin;
  }
  {
#line 3269
  display_exponent = 2.20000000001;
#line 3271
  png = png_create_read_struct("1.6.37", (void *)0, (png_error_ptr )((void *)0), (png_error_ptr )((void *)0));
  }
#line 3271
  if (png == (void *)0) {
#line 3273
    goto fin;
  }
  {
#line 3274
  info = png_create_info_struct(png);
  }
#line 3274
  if (info == (void *)0) {
#line 3275
    goto fin;
  }
  {
#line 3277
  __cil_tmp39 = png_set_longjmp_fn(png, & longjmp, sizeof(jmp_buf ));
#line 3277
  __cil_tmp40 = _setjmp((struct __jmp_buf_tag *)*__cil_tmp39);
  }
#line 3277
  if (__cil_tmp40) {
#line 3278
    goto fin;
  }
  {
#line 3280
  png_init_io(png, reader);
#line 3281
  png_set_sig_bytes(png, 8);
#line 3283
  png_read_info(png, info);
#line 3285
  __cil_tmp41 = png_get_IHDR(png, info, & width, & height, & bit_depth, & color_type,
                             & interlace_type, & compression_type, & filter_type);
  }
#line 3285
  if (__cil_tmp41 == 0U) {
#line 3288
    goto fin;
  }
#line 3295
  if (color_type == 3) {
    {
#line 3296
    png_set_expand(png);
    }
  } else
#line 3298
  if (color_type == 0) {
#line 3298
    if (bit_depth < 8) {
      {
#line 3299
      png_set_expand(png);
      }
    }
  }
  {
#line 3301
  __cil_tmp42 = png_get_valid(png, info, 16U);
  }
#line 3301
  if (__cil_tmp42) {
    {
#line 3302
    png_set_expand(png);
    }
  }
#line 3304
  is16 = bit_depth == 16;
#line 3308
  if (color_type == 0) {
    _L: /* CIL Label */ 
    {
#line 3311
    png_set_gray_to_rgb(png);
    }
#line 3312
    if (color_type == 0) {
#line 3312
      tmp = 2;
    } else {
#line 3312
      tmp = 6;
    }
#line 3312
    color_type = tmp;
  } else
#line 3308
  if (color_type == 4) {
#line 3308
    goto _L;
  }
  {
#line 3316
  __cil_tmp44 = png_get_gAMA(png, info, & gamma___0);
  }
#line 3316
  if (! __cil_tmp44) {
#line 3317
    gamma___0 = 0.454550000001;
  }
  {
#line 3319
  png_set_gamma(png, display_exponent, gamma___0);
#line 3321
  png_read_update_info(png, info);
#line 3323
  png_get_pHYs(png, info, & resx, & resy, & unit);
#line 3325
  __cil_tmp45 = png_get_color_type(png, info);
#line 3325
  color_type = (int )__cil_tmp45;
#line 3327
  has_alpha = color_type == 6;
#line 3329
  nr_comp = 3U + (unsigned int )has_alpha;
#line 3331
  __cil_tmp46 = png_get_bit_depth(png, info);
#line 3331
  bit_depth = (int )__cil_tmp46;
#line 3333
  __cil_tmp47 = calloc((unsigned long )(height + 1U), sizeof(unsigned char *));
#line 3333
  rows = (unsigned char **)__cil_tmp47;
#line 3334
  i = (unsigned int )0;
  }
  {
#line 3334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3334
    if (! (i < height)) {
#line 3334
      goto while_break;
    }
    {
#line 3335
    __cil_tmp48 = png_get_rowbytes(png, info);
#line 3335
    __cil_tmp49 = malloc(__cil_tmp48);
#line 3335
    *(rows + i) = (unsigned char *)__cil_tmp49;
    }
#line 3334
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3337
  png_read_image(png, rows);
#line 3339
  memset((opj_image_cmptparm_t *)cmptparm, 0, sizeof(cmptparm));
#line 3341
  sub_dx = params->subsampling_dx;
#line 3341
  sub_dy = params->subsampling_dy;
#line 3343
  i = (unsigned int )0;
  }
  {
#line 3343
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3343
    if (! (i < nr_comp)) {
#line 3343
      goto while_break___0;
    }
#line 3345
    cmptparm[i].prec = (OPJ_UINT32 )bit_depth;
#line 3347
    cmptparm[i].bpp = (OPJ_UINT32 )bit_depth;
#line 3348
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 3349
    cmptparm[i].dx = (OPJ_UINT32 )sub_dx;
#line 3350
    cmptparm[i].dy = (OPJ_UINT32 )sub_dy;
#line 3351
    cmptparm[i].w = (OPJ_UINT32 )width;
#line 3352
    cmptparm[i].h = (OPJ_UINT32 )height;
#line 3343
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3355
  image = opj_image_create(nr_comp, & cmptparm[0], (OPJ_COLOR_SPACE )1);
  }
#line 3357
  if (image == (void *)0) {
#line 3357
    goto fin;
  }
#line 3359
  image->x0 = (OPJ_UINT32 )params->image_offset_x0;
#line 3360
  image->y0 = (OPJ_UINT32 )params->image_offset_y0;
#line 3361
  image->x1 = (OPJ_UINT32 )(((image->x0 + (width - 1U) * (OPJ_UINT32 )sub_dx) + 1U) + image->x0);
#line 3362
  image->y1 = (OPJ_UINT32 )(((image->y0 + (height - 1U) * (OPJ_UINT32 )sub_dy) + 1U) + image->y0);
#line 3364
  r = (image->comps + 0)->data;
#line 3365
  g = (image->comps + 1)->data;
#line 3366
  b = (image->comps + 2)->data;
#line 3367
  if (has_alpha) {
#line 3367
    a = (image->comps + 3)->data;
  }
#line 3369
  i = (unsigned int )0;
  {
#line 3369
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3369
    if (! (i < height)) {
#line 3369
      goto while_break___1;
    }
#line 3371
    s = *(rows + i);
#line 3373
    j = (unsigned int )0;
    {
#line 3373
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3373
      if (! (j < width)) {
#line 3373
        goto while_break___2;
      }
#line 3375
      if (is16) {
#line 3377
        __cil_tmp51 = r;
#line 3377
        r ++;
#line 3377
        *__cil_tmp51 = ((int )*(s + 0) << 8) | (int )*(s + 1);
#line 3377
        s += 2;
#line 3379
        __cil_tmp52 = g;
#line 3379
        g ++;
#line 3379
        *__cil_tmp52 = ((int )*(s + 0) << 8) | (int )*(s + 1);
#line 3379
        s += 2;
#line 3381
        __cil_tmp53 = b;
#line 3381
        b ++;
#line 3381
        *__cil_tmp53 = ((int )*(s + 0) << 8) | (int )*(s + 1);
#line 3381
        s += 2;
#line 3383
        if (has_alpha) {
#line 3383
          __cil_tmp54 = a;
#line 3383
          a ++;
#line 3383
          *__cil_tmp54 = ((int )*(s + 0) << 8) | (int )*(s + 1);
#line 3383
          s += 2;
        }
#line 3385
        goto while_continue___2;
      }
#line 3387
      __cil_tmp56 = s;
#line 3387
      s ++;
#line 3387
      __cil_tmp55 = r;
#line 3387
      r ++;
#line 3387
      *__cil_tmp55 = (int )*__cil_tmp56;
#line 3387
      __cil_tmp58 = s;
#line 3387
      s ++;
#line 3387
      __cil_tmp57 = g;
#line 3387
      g ++;
#line 3387
      *__cil_tmp57 = (int )*__cil_tmp58;
#line 3387
      __cil_tmp60 = s;
#line 3387
      s ++;
#line 3387
      __cil_tmp59 = b;
#line 3387
      b ++;
#line 3387
      *__cil_tmp59 = (int )*__cil_tmp60;
#line 3389
      if (has_alpha) {
#line 3389
        __cil_tmp62 = s;
#line 3389
        s ++;
#line 3389
        __cil_tmp61 = a;
#line 3389
        a ++;
#line 3389
        *__cil_tmp61 = (int )*__cil_tmp62;
      }
#line 3373
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3369
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  fin: 
#line 3393
  if (rows) {
#line 3395
    i = (unsigned int )0;
    {
#line 3395
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3395
      if (! (i < height)) {
#line 3395
        goto while_break___3;
      }
      {
#line 3396
      free(*(rows + i));
      }
#line 3395
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 3397
    free(rows);
    }
  }
#line 3399
  if (png) {
    {
#line 3400
    png_destroy_read_struct(& png, & info, (png_infopp )((void *)0));
    }
  }
  {
#line 3402
  fclose(reader);
  }
#line 3404
  return (image);
}
}
#line 3408 "/root/patron/new_21/src/bin/jp2/convert.c"
int imagetopng(opj_image_t *image , char const   *write_idf ) 
{ 
  FILE *writer ;
  png_structp png ;
  png_infop info ;
  int *red ;
  int *green ;
  int *blue ;
  int *alpha ;
  unsigned char *row_buf ;
  unsigned char *d ;
  int has_alpha ;
  int width ;
  int height ;
  int nr_comp ;
  int color_type ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int adjustA ;
  int x ;
  int y ;
  int fails ;
  int prec ;
  int ushift ;
  int dshift ;
  int is16 ;
  int force16 ;
  int force8 ;
  unsigned short mask ;
  png_color_8 sig_bit ;
  FILE *__cil_tmp32 ;
  png_structp __cil_tmp33 ;
  png_infop __cil_tmp34 ;
  jmp_buf *__cil_tmp35 ;
  int __cil_tmp36 ;
  int v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp42 ;
  unsigned char *__cil_tmp43 ;
  unsigned char *__cil_tmp44 ;
  unsigned char *__cil_tmp45 ;
  unsigned char *__cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  unsigned char *__cil_tmp48 ;
  unsigned char *__cil_tmp49 ;
  unsigned char *__cil_tmp50 ;
  unsigned char *__cil_tmp51 ;
  unsigned char *__cil_tmp52 ;
  unsigned char *__cil_tmp53 ;
  unsigned char *__cil_tmp54 ;
  int v___0 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp58 ;
  unsigned char *__cil_tmp59 ;
  unsigned char *__cil_tmp60 ;
  int *__cil_tmp61 ;
  unsigned char *__cil_tmp62 ;
  unsigned char *__cil_tmp63 ;
  void *__cil_tmp64 ;
  unsigned char *__cil_tmp65 ;
  unsigned char *__cil_tmp66 ;

  {
#line 3418
  mask = (unsigned short )65535;
#line 3421
  dshift = 0;
#line 3421
  ushift = dshift;
#line 3421
  force8 = ushift;
#line 3421
  force16 = force8;
#line 3421
  is16 = force16;
#line 3421
  fails = 1;
#line 3422
  prec = (int )(image->comps + 0)->prec;
#line 3423
  nr_comp = (int )image->numcomps;
#line 3425
  if (prec > 8) {
#line 3425
    if (prec < 16) {
#line 3427
      ushift = 16 - prec;
#line 3427
      dshift = prec - ushift;
#line 3428
      prec = 16;
#line 3428
      force16 = 1;
    } else {
#line 3425
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3431
  if (prec < 8) {
#line 3431
    if (nr_comp > 1) {
#line 3433
      ushift = 8 - prec;
#line 3433
      dshift = 8 - ushift;
#line 3434
      prec = 8;
#line 3434
      force8 = 1;
    }
  }
#line 3437
  if (prec != 1) {
#line 3437
    if (prec != 2) {
#line 3437
      if (prec != 4) {
#line 3437
        if (prec != 8) {
#line 3437
          if (prec != 16) {
            {
#line 3439
            fprintf(stderr, "imagetopng: can not create %s\n\twrong bit_depth %d\n",
                    write_idf, prec);
            }
#line 3441
            return (fails);
          }
        }
      }
    }
  }
  {
#line 3443
  writer = fopen(write_idf, "wb\235j\347U");
  }
#line 3445
  if (writer == (void *)0) {
#line 3445
    return (fails);
  }
  {
#line 3447
  info = (png_infop )((void *)0);
#line 3447
  has_alpha = 0;
#line 3455
  png = png_create_write_struct("1.6.37", (void *)0, (png_error_ptr )((void *)0),
                                (png_error_ptr )((void *)0));
  }
#line 3459
  if (png == (void *)0) {
#line 3459
    goto fin;
  }
  {
#line 3463
  info = png_create_info_struct(png);
  }
#line 3465
  if (info == (void *)0) {
#line 3465
    goto fin;
  }
  {
#line 3470
  __cil_tmp35 = png_set_longjmp_fn(png, & longjmp, sizeof(jmp_buf ));
#line 3470
  __cil_tmp36 = _setjmp((struct __jmp_buf_tag *)*__cil_tmp35);
  }
#line 3470
  if (__cil_tmp36) {
#line 3470
    goto fin;
  }
  {
#line 3474
  png_init_io(png, writer);
#line 3493
  png_set_compression_level(png, 9);
  }
#line 3495
  if (prec == 16) {
#line 3495
    mask = (unsigned short )65535;
  } else
#line 3497
  if (prec == 8) {
#line 3497
    mask = (unsigned short )255;
  } else
#line 3499
  if (prec == 4) {
#line 3499
    mask = (unsigned short )15;
  } else
#line 3501
  if (prec == 2) {
#line 3501
    mask = (unsigned short )3;
  } else
#line 3503
  if (prec == 1) {
#line 3503
    mask = (unsigned short )1;
  }
#line 3505
  if (nr_comp >= 3) {
#line 3505
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 3505
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 3505
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 3505
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 3505
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 3505
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
#line 3515
                has_alpha = nr_comp > 3;
#line 3517
                is16 = prec == 16;
#line 3519
                width = (int )(image->comps + 0)->w;
#line 3520
                height = (int )(image->comps + 0)->h;
#line 3522
                red = (image->comps + 0)->data;
#line 3523
                green = (image->comps + 1)->data;
#line 3524
                blue = (image->comps + 2)->data;
#line 3526
                sig_bit.blue = (png_byte )prec;
#line 3526
                sig_bit.green = sig_bit.blue;
#line 3526
                sig_bit.red = sig_bit.green;
#line 3528
                if (has_alpha) {
#line 3530
                  sig_bit.alpha = (png_byte )prec;
#line 3531
                  alpha = (image->comps + 3)->data;
#line 3532
                  color_type = 6;
#line 3533
                  if ((image->comps + 3)->sgnd) {
#line 3533
                    tmp = 1 << ((image->comps + 3)->prec - 1U);
                  } else {
#line 3533
                    tmp = 0;
                  }
#line 3533
                  adjustA = tmp;
                } else {
#line 3537
                  sig_bit.alpha = (png_byte )0;
#line 3537
                  alpha = (int *)((void *)0);
#line 3538
                  color_type = 2;
#line 3539
                  adjustA = 0;
                }
                {
#line 3541
                png_set_sBIT(png, info, & sig_bit);
#line 3543
                png_set_IHDR(png, info, (png_uint_32 )width, (png_uint_32 )height,
                             prec, color_type, 0, 0, 0);
#line 3548
                png_set_gamma(png, 2.20000000001, 1. / 2.20000000001);
#line 3549
                png_set_sRGB(png, info, 0);
#line 3551
                png_write_info(png, info);
                }
#line 3553
                if (prec < 8) {
                  {
#line 3555
                  png_set_packing(png);
                  }
                }
                {
#line 3557
                printf("%s:%d:sgnd(%d,%d,%d) w(%d) h(%d) alpha(%d)\n", "/root/patron/new_21/src/bin/jp2/convert.c",
                       3557, (image->comps + 0)->sgnd, (image->comps + 1)->sgnd, (image->comps + 2)->sgnd,
                       width, height, has_alpha);
                }
#line 3561
                if ((image->comps + 0)->sgnd) {
#line 3561
                  tmp___0 = 1 << ((image->comps + 0)->prec - 1U);
                } else {
#line 3561
                  tmp___0 = 0;
                }
#line 3561
                adjustR = tmp___0;
#line 3562
                if ((image->comps + 1)->sgnd) {
#line 3562
                  tmp___1 = 1 << ((image->comps + 1)->prec - 1U);
                } else {
#line 3562
                  tmp___1 = 0;
                }
#line 3562
                adjustG = tmp___1;
#line 3563
                if ((image->comps + 2)->sgnd) {
#line 3563
                  tmp___2 = 1 << ((image->comps + 2)->prec - 1U);
                } else {
#line 3563
                  tmp___2 = 0;
                }
                {
#line 3563
                adjustB = tmp___2;
#line 3565
                __cil_tmp42 = malloc(((size_t )width * (size_t )nr_comp) * 2UL);
#line 3565
                row_buf = (unsigned char *)__cil_tmp42;
#line 3567
                y = 0;
                }
                {
#line 3567
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 3567
                  if (! (y < height)) {
#line 3567
                    goto while_break;
                  }
#line 3569
                  d = row_buf;
#line 3571
                  x = 0;
                  {
#line 3571
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
#line 3571
                    if (! (x < width)) {
#line 3571
                      goto while_break___0;
                    }
#line 3573
                    if (is16) {
#line 3575
                      v = *red + adjustR;
#line 3575
                      red ++;
#line 3576
                      if (v > 65535) {
#line 3576
                        v = 65535;
                      } else
#line 3576
                      if (v < 0) {
#line 3576
                        v = 0;
                      }
#line 3578
                      if (force16) {
#line 3578
                        v = (v << ushift) + (v >> dshift);
                      }
#line 3580
                      __cil_tmp43 = d;
#line 3580
                      d ++;
#line 3580
                      *__cil_tmp43 = (unsigned char )(v >> 8);
#line 3580
                      __cil_tmp44 = d;
#line 3580
                      d ++;
#line 3580
                      *__cil_tmp44 = (unsigned char )v;
#line 3582
                      v = *green + adjustG;
#line 3582
                      green ++;
#line 3583
                      if (v > 65535) {
#line 3583
                        v = 65535;
                      } else
#line 3583
                      if (v < 0) {
#line 3583
                        v = 0;
                      }
#line 3585
                      if (force16) {
#line 3585
                        v = (v << ushift) + (v >> dshift);
                      }
#line 3587
                      __cil_tmp45 = d;
#line 3587
                      d ++;
#line 3587
                      *__cil_tmp45 = (unsigned char )(v >> 8);
#line 3587
                      __cil_tmp46 = d;
#line 3587
                      d ++;
#line 3587
                      *__cil_tmp46 = (unsigned char )v;
#line 3589
                      v = *blue + adjustB;
#line 3589
                      blue ++;
#line 3590
                      if (v > 65535) {
#line 3590
                        v = 65535;
                      } else
#line 3590
                      if (v < 0) {
#line 3590
                        v = 0;
                      }
#line 3592
                      if (force16) {
#line 3592
                        v = (v << ushift) + (v >> dshift);
                      }
#line 3594
                      __cil_tmp47 = d;
#line 3594
                      d ++;
#line 3594
                      *__cil_tmp47 = (unsigned char )(v >> 8);
#line 3594
                      __cil_tmp48 = d;
#line 3594
                      d ++;
#line 3594
                      *__cil_tmp48 = (unsigned char )v;
#line 3596
                      if (has_alpha) {
#line 3598
                        v = *alpha + adjustA;
#line 3598
                        alpha ++;
#line 3599
                        if (v > 65535) {
#line 3599
                          v = 65535;
                        } else
#line 3599
                        if (v < 0) {
#line 3599
                          v = 0;
                        }
#line 3601
                        if (force16) {
#line 3601
                          v = (v << ushift) + (v >> dshift);
                        }
#line 3603
                        __cil_tmp49 = d;
#line 3603
                        d ++;
#line 3603
                        *__cil_tmp49 = (unsigned char )(v >> 8);
#line 3603
                        __cil_tmp50 = d;
#line 3603
                        d ++;
#line 3603
                        *__cil_tmp50 = (unsigned char )v;
                      }
#line 3605
                      goto while_continue___0;
                    }
#line 3608
                    v = *red + adjustR;
#line 3608
                    red ++;
#line 3609
                    if (v > 255) {
#line 3609
                      v = 255;
                    } else
#line 3609
                    if (v < 0) {
#line 3609
                      v = 0;
                    }
#line 3611
                    if (force8) {
#line 3611
                      v = (v << ushift) + (v >> dshift);
                    }
#line 3613
                    __cil_tmp51 = d;
#line 3613
                    d ++;
#line 3613
                    *__cil_tmp51 = (unsigned char )(v & (int )mask);
#line 3615
                    v = *green + adjustG;
#line 3615
                    green ++;
#line 3616
                    if (v > 255) {
#line 3616
                      v = 255;
                    } else
#line 3616
                    if (v < 0) {
#line 3616
                      v = 0;
                    }
#line 3618
                    if (force8) {
#line 3618
                      v = (v << ushift) + (v >> dshift);
                    }
#line 3620
                    __cil_tmp52 = d;
#line 3620
                    d ++;
#line 3620
                    *__cil_tmp52 = (unsigned char )(v & (int )mask);
#line 3622
                    v = *blue + adjustB;
#line 3622
                    blue ++;
#line 3623
                    if (v > 255) {
#line 3623
                      v = 255;
                    } else
#line 3623
                    if (v < 0) {
#line 3623
                      v = 0;
                    }
#line 3625
                    if (force8) {
#line 3625
                      v = (v << ushift) + (v >> dshift);
                    }
#line 3627
                    __cil_tmp53 = d;
#line 3627
                    d ++;
#line 3627
                    *__cil_tmp53 = (unsigned char )(v & (int )mask);
#line 3629
                    if (has_alpha) {
#line 3631
                      v = *alpha + adjustA;
#line 3631
                      alpha ++;
#line 3632
                      if (v > 255) {
#line 3632
                        v = 255;
                      } else
#line 3632
                      if (v < 0) {
#line 3632
                        v = 0;
                      }
#line 3634
                      if (force8) {
#line 3634
                        v = (v << ushift) + (v >> dshift);
                      }
#line 3636
                      __cil_tmp54 = d;
#line 3636
                      d ++;
#line 3636
                      *__cil_tmp54 = (unsigned char )(v & (int )mask);
                    }
#line 3571
                    x ++;
                  }
                  while_break___0: /* CIL Label */ ;
                  }
                  {
#line 3640
                  png_write_row(png, row_buf);
                  }
#line 3567
                  y ++;
                }
                while_break: /* CIL Label */ ;
                }
                {
#line 3643
                free(row_buf);
                }
              } else {
#line 3505
                goto _L___50;
              }
            } else {
#line 3505
              goto _L___50;
            }
          } else {
#line 3505
            goto _L___50;
          }
        } else {
#line 3505
          goto _L___50;
        }
      } else {
#line 3505
        goto _L___50;
      }
    } else {
#line 3505
      goto _L___50;
    }
  } else
  _L___50: /* CIL Label */ 
  _L___51: /* CIL Label */ 
  _L___52: /* CIL Label */ 
  _L___53: /* CIL Label */ 
  _L___54: /* CIL Label */ 
  _L___55: /* CIL Label */ 
#line 3647
  if (nr_comp == 1) {
    _L___49: /* CIL Label */ 
#line 3655
    red = (image->comps + 0)->data;
#line 3657
    sig_bit.gray = (png_byte )prec;
#line 3658
    sig_bit.alpha = (png_byte )0;
#line 3658
    sig_bit.blue = sig_bit.alpha;
#line 3658
    sig_bit.green = sig_bit.blue;
#line 3658
    sig_bit.red = sig_bit.green;
#line 3659
    alpha = (int *)((void *)0);
#line 3659
    adjustA = 0;
#line 3660
    color_type = 0;
#line 3662
    if (nr_comp == 2) {
#line 3664
      has_alpha = 1;
#line 3664
      sig_bit.alpha = (png_byte )prec;
#line 3665
      alpha = (image->comps + 1)->data;
#line 3666
      color_type = 4;
#line 3667
      if ((image->comps + 1)->sgnd) {
#line 3667
        tmp___3 = 1 << ((image->comps + 1)->prec - 1U);
      } else {
#line 3667
        tmp___3 = 0;
      }
#line 3667
      adjustA = tmp___3;
    }
    {
#line 3669
    width = (int )(image->comps + 0)->w;
#line 3670
    height = (int )(image->comps + 0)->h;
#line 3672
    png_set_IHDR(png, info, (png_uint_32 )width, (png_uint_32 )height, (int )sig_bit.gray,
                 color_type, 0, 0, 0);
#line 3677
    png_set_sBIT(png, info, & sig_bit);
#line 3679
    png_set_gamma(png, 2.20000000001, 1. / 2.20000000001);
#line 3680
    png_set_sRGB(png, info, 0);
#line 3682
    png_write_info(png, info);
    }
#line 3684
    if ((image->comps + 0)->sgnd) {
#line 3684
      tmp___4 = 1 << ((image->comps + 0)->prec - 1U);
    } else {
#line 3684
      tmp___4 = 0;
    }
#line 3684
    adjustR = tmp___4;
#line 3686
    if (prec < 8) {
      {
#line 3688
      png_set_packing(png);
      }
    }
#line 3691
    if (prec > 8) {
      {
#line 3693
      __cil_tmp58 = malloc(((size_t )width * (size_t )nr_comp) * sizeof(unsigned short ));
#line 3693
      row_buf = (unsigned char *)__cil_tmp58;
#line 3696
      y = 0;
      }
      {
#line 3696
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3696
        if (! (y < height)) {
#line 3696
          goto while_break___1;
        }
#line 3698
        d = row_buf;
#line 3700
        x = 0;
        {
#line 3700
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3700
          if (! (x < width)) {
#line 3700
            goto while_break___2;
          }
#line 3702
          v___0 = *red + adjustR;
#line 3702
          red ++;
#line 3703
          if (v___0 > 65535) {
#line 3703
            v___0 = 65535;
          } else
#line 3703
          if (v___0 < 0) {
#line 3703
            v___0 = 0;
          }
#line 3705
          if (force16) {
#line 3705
            v___0 = (v___0 << ushift) + (v___0 >> dshift);
          }
#line 3707
          __cil_tmp59 = d;
#line 3707
          d ++;
#line 3707
          *__cil_tmp59 = (unsigned char )(v___0 >> 8);
#line 3707
          __cil_tmp60 = d;
#line 3707
          d ++;
#line 3707
          *__cil_tmp60 = (unsigned char )v___0;
#line 3709
          if (has_alpha) {
#line 3711
            __cil_tmp61 = alpha;
#line 3711
            alpha ++;
#line 3711
            v___0 = *__cil_tmp61;
#line 3712
            if (v___0 > 65535) {
#line 3712
              v___0 = 65535;
            } else
#line 3712
            if (v___0 < 0) {
#line 3712
              v___0 = 0;
            }
#line 3714
            if (force16) {
#line 3714
              v___0 = (v___0 << ushift) + (v___0 >> dshift);
            }
#line 3716
            __cil_tmp62 = d;
#line 3716
            d ++;
#line 3716
            *__cil_tmp62 = (unsigned char )(v___0 >> 8);
#line 3716
            __cil_tmp63 = d;
#line 3716
            d ++;
#line 3716
            *__cil_tmp63 = (unsigned char )v___0;
          }
#line 3700
          x ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 3719
        png_write_row(png, row_buf);
        }
#line 3696
        y ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 3722
      free(row_buf);
      }
    } else {
      {
#line 3726
      __cil_tmp64 = calloc((size_t )width, (size_t )nr_comp * 2UL);
#line 3726
      row_buf = (unsigned char *)__cil_tmp64;
#line 3728
      y = 0;
      }
      {
#line 3728
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3728
        if (! (y < height)) {
#line 3728
          goto while_break___3;
        }
#line 3730
        d = row_buf;
#line 3732
        x = 0;
        {
#line 3732
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 3732
          if (! (x < width)) {
#line 3732
            goto while_break___4;
          }
#line 3734
          v___0 = *red + adjustR;
#line 3734
          red ++;
#line 3735
          if (v___0 > 255) {
#line 3735
            v___0 = 255;
          } else
#line 3735
          if (v___0 < 0) {
#line 3735
            v___0 = 0;
          }
#line 3737
          if (force8) {
#line 3737
            v___0 = (v___0 << ushift) + (v___0 >> dshift);
          }
#line 3739
          __cil_tmp65 = d;
#line 3739
          d ++;
#line 3739
          *__cil_tmp65 = (unsigned char )(v___0 & (int )mask);
#line 3741
          if (has_alpha) {
#line 3743
            v___0 = *alpha + adjustA;
#line 3743
            alpha ++;
#line 3744
            if (v___0 > 255) {
#line 3744
              v___0 = 255;
            } else
#line 3744
            if (v___0 < 0) {
#line 3744
              v___0 = 0;
            }
#line 3746
            if (force8) {
#line 3746
              v___0 = (v___0 << ushift) + (v___0 >> dshift);
            }
#line 3748
            __cil_tmp66 = d;
#line 3748
            d ++;
#line 3748
            *__cil_tmp66 = (unsigned char )(v___0 & (int )mask);
          }
#line 3732
          x ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 3752
        png_write_row(png, row_buf);
        }
#line 3728
        y ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 3755
      free(row_buf);
      }
    }
  } else
#line 3647
  if (nr_comp == 2) {
#line 3647
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 3647
      if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 3647
        if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 3647
          goto _L___49;
        } else {
          {
          {
          {
          {
#line 3760
          fprintf(stderr, "imagetopng: can not create %s\n", write_idf);
          }
          }
          }
          }
#line 3761
          goto fin;
        }
      } else {
        {
        {
        {
        {
#line 3760
        fprintf(stderr, "imagetopng: can not create %s\n", write_idf);
        }
        }
        }
        }
#line 3761
        goto fin;
      }
    } else {
      {
      {
      {
      {
#line 3760
      fprintf(stderr, "imagetopng: can not create %s\n", write_idf);
      }
      }
      }
      }
#line 3761
      goto fin;
    }
  } else {
    {
    {
    {
    {
#line 3760
    fprintf(stderr, "imagetopng: can not create %s\n", write_idf);
    }
    }
    }
    }
#line 3761
    goto fin;
  }
  {
#line 3763
  png_write_end(png, info);
#line 3765
  fails = 0;
  }
  fin: 
#line 3769
  if (png) {
    {
#line 3771
    png_destroy_write_struct(& png, & info);
    }
  }
  {
#line 3773
  fclose(writer);
  }
#line 3775
  if (fails) {
    {
#line 3775
    remove(write_idf);
    }
  }
#line 3777
  return (fails);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 183
extern int readdir_r(DIR *__dirp , struct dirent *__entry , struct dirent **__result ) ;
#line 209
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp ) ;
#line 215
extern  __attribute__((__nothrow__)) void seekdir(DIR *__dirp , long __pos ) ;
#line 218
extern  __attribute__((__nothrow__)) long telldir(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp ) ;
#line 255
extern int scandir(char const   *__dir , struct dirent ***__namelist , int (*__selector)(struct dirent * ) ,
                   int (*__cmp)(struct dirent ** , struct dirent ** ) ) ;
#line 325
extern  __attribute__((__nothrow__)) int alphasort(struct dirent **__e1 , struct dirent **__e2 ) ;
#line 353
extern  __attribute__((__nothrow__)) __ssize_t getdirentries(int __fd , char *__buf ,
                                                             size_t __nbytes , __off_t *__basep ) ;
#line 18 "/root/patron/new_21/src/bin/common/opj_getopt.h"
int opj_opterr ;
#line 19
int opj_optind ;
#line 20
int opj_optopt ;
#line 21
int opj_optreset ;
#line 22
char *opj_optarg ;
#line 24
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 25
int opj_getopt_long(int argc , char * const  argv[] , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) ;
#line 27
void reset_options_reading(void) ;
#line 41 "/root/patron/new_21/src/bin/common/color.h"
void color_sycc_to_rgb(opj_image_t *img ) ;
#line 42
extern void color_apply_icc_profile(opj_image_t *image ) ;
#line 98 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
int get_num_images(char *imgdirpath ) ;
#line 99
int load_images(dircnt_t *dirptr , char *imgdirpath ) ;
#line 100
int get_file_format(char const   *filename ) ;
#line 101
char get_next_file(int imageno , dircnt_t *dirptr , img_fol_t *img_fol , opj_dparameters_t *parameters ) ;
#line 102
static int infile_format(char const   *fname ) ;
#line 104
int parse_cmdline_decoder(int argc , char **argv , opj_dparameters_t *parameters ,
                          img_fol_t *img_fol , char *indexfilename ) ;
#line 105
int parse_DA_values(char *inArg , unsigned int *DA_x0 , unsigned int *DA_y0 , unsigned int *DA_x1 ,
                    unsigned int *DA_y1 ) ;
#line 108 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
static void decode_help_display(void) 
{ 
  char const   *__cil_tmp1 ;

  {
  {
#line 109
  __cil_tmp1 = opj_version();
#line 109
  fprintf(stdout, "\nThis is the opj_decompress utility from the OpenJPEG project.\nIt decompresses JPEG 2000 codestreams to various image formats.\nIt has been compiled against openjp2 library v%s.\n\n",
          __cil_tmp1);
#line 113
  fprintf(stdout, "Parameters:\n");
#line 114
  fprintf(stdout, "-----------\n");
#line 115
  fprintf(stdout, "\n");
#line 116
  fprintf(stdout, "  -ImgDir <directory> \n");
#line 117
  fprintf(stdout, "\tImage file Directory path \n");
#line 118
  fprintf(stdout, "  -OutFor <PBM|PGM|PPM|PNM|PAM|PGX|PNG|BMP|TIF|RAW|RAWL|TGA>\n");
#line 119
  fprintf(stdout, "    REQUIRED only if -ImgDir is used\n");
#line 120
  fprintf(stdout, "\tOutput format for decompressed images.\n\220");
#line 121
  fprintf(stdout, "  -i <compressed file>\n");
#line 122
  fprintf(stdout, "    REQUIRED only if an Input image directory is not specified\n");
#line 123
  fprintf(stdout, "    Currently accepts J2K-files, JP2-files and JPT-files. The file type\n\220");
#line 124
  fprintf(stdout, "    is identified based on its suffix.\n");
#line 125
  fprintf(stdout, "  -o <decompressed file>\n");
#line 126
  fprintf(stdout, "    REQUIRED\n");
#line 127
  fprintf(stdout, "    Currently accepts formats specified above (see OutFor option)\n");
#line 128
  fprintf(stdout, "    Binary data is written to the file (not ascii). If a PGX\n");
#line 129
  fprintf(stdout, "    filename is given, there will be as many output files as there are\n");
#line 130
  fprintf(stdout, "    components: an indice starting from 0 will then be appended to the\n");
#line 131
  fprintf(stdout, "    output filename, just before the \"pgx\" extension. If a PGM filename\n\220");
#line 132
  fprintf(stdout, "    is given and there are more than one component, only the first component\n");
#line 133
  fprintf(stdout, "    will be written to the file.\n");
#line 134
  fprintf(stdout, "  -r <reduce factor>\n");
#line 135
  fprintf(stdout, "    Set the number of highest resolution levels to be discarded. The\n");
#line 136
  fprintf(stdout, "    image resolution is effectively divided by 2 to the power of the\n");
#line 137
  fprintf(stdout, "    number of discarded levels. The reduce factor is limited by the\n");
#line 138
  fprintf(stdout, "    smallest total number of decomposition levels among tiles.\n");
#line 139
  fprintf(stdout, "  -l <number of quality layers to decode>\n");
#line 140
  fprintf(stdout, "    Set the maximum number of quality layers to decode. If there are\n");
#line 141
  fprintf(stdout, "    less quality layers than the specified number, all the quality layers\n");
#line 142
  fprintf(stdout, "    are decoded.\n");
#line 143
  fprintf(stdout, "  -x  \n");
#line 144
  fprintf(stdout, "    Create an index file *.Idx (-x index_name.Idx) \n");
#line 145
  fprintf(stdout, "  -d <x0,y0,x1,y1>\n");
#line 146
  fprintf(stdout, "    OPTIONAL\n");
#line 147
  fprintf(stdout, "    Decoding area\n");
#line 148
  fprintf(stdout, "    By default all the image is decoded.\n");
#line 149
  fprintf(stdout, "  -t <tile_number>\n");
#line 150
  fprintf(stdout, "    OPTIONAL\n");
#line 151
  fprintf(stdout, "    Set the tile number of the decoded tile. Follow the JPEG2000 convention from left-up to bottom-up\n");
#line 152
  fprintf(stdout, "    By default all tiles are decoded.\n");
#line 153
  fprintf(stdout, "\n");
#line 164
  fprintf(stdout, "\n");
  }
  return;
}
}
#line 169 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
int get_num_images(char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int num_images ;
  DIR *__cil_tmp5 ;
  struct dirent *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 172
  num_images = 0;
#line 176
  dir = opendir((char const   *)imgdirpath);
  }
#line 177
  if (! dir) {
    {
#line 178
    fprintf(stderr, "Could not open Folder %s\nl", imgdirpath);
    }
#line 179
    return (0);
  }
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 182
    content = readdir(dir);
    }
#line 182
    if (! (content != (void *)0)) {
#line 182
      goto while_break;
    }
    {
#line 183
    __cil_tmp8 = strcmp("..", (char const   *)((char *)content->d_name));
    }
    {
#line 183
    __cil_tmp7 = strcmp(".", (char const   *)((char *)content->d_name));
    }
#line 183
    if (__cil_tmp7 == 0) {
#line 184
      goto while_continue;
    } else
#line 183
    if (__cil_tmp8 == 0) {
#line 184
      goto while_continue;
    }
#line 185
    num_images ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return (num_images);
}
}
#line 191 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
int load_images(dircnt_t *dirptr , char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int i ;
  DIR *__cil_tmp6 ;
  struct dirent *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 194
  i = 0;
#line 198
  dir = opendir((char const   *)imgdirpath);
  }
#line 199
  if (! dir) {
    {
#line 200
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 201
    return (1);
  } else {
    {
#line 203
    fprintf(stderr, "Folder opened successfully\n");
    }
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    content = readdir(dir);
    }
#line 206
    if (! (content != (void *)0)) {
#line 206
      goto while_break;
    }
    {
#line 207
    __cil_tmp9 = strcmp("..\267j\347U", (char const   *)((char *)content->d_name));
    }
    {
#line 207
    __cil_tmp8 = strcmp(".\002", (char const   *)((char *)content->d_name));
    }
#line 207
    if (__cil_tmp8 == 0) {
#line 208
      goto while_continue;
    } else
#line 207
    if (__cil_tmp9 == 0) {
#line 208
      goto while_continue;
    }
    {
#line 210
    strcpy(*(dirptr->filename + i), (char const   *)((char *)content->d_name));
#line 211
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return (0);
}
}
#line 217 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
int get_file_format(char const   *filename ) 
{ 
  unsigned int i ;
  static char const   *extension[15] ;
  static int const   format[15] ;
  char *ext ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;

  {
  {
#line 219
  strcpy((char *)extension[0], "pgx");;
#line 219
  strcpy((char *)extension[1], "pnm");;
#line 219
  strcpy((char *)extension[2], "pgm");;
#line 219
  strcpy((char *)extension[3], "ppm");;
#line 219
  strcpy((char *)extension[4], "bmp");;
#line 219
  strcpy((char *)extension[5], "tif");;
#line 219
  strcpy((char *)extension[6], "raw");;
#line 219
  strcpy((char *)extension[7], "rawl");;
#line 219
  strcpy((char *)extension[8], "tga");;
#line 219
  strcpy((char *)extension[9], "png");;
#line 219
  strcpy((char *)extension[10], "j2k");;
#line 219
  strcpy((char *)extension[11], "jp2");;
#line 219
  strcpy((char *)extension[12], "jptj\347U");;
#line 219
  strcpy((char *)extension[13], "j2c");;
#line 219
  strcpy((char *)extension[14], "jpcj\347U");;
#line 220
  format[0] = 11;
#line 220
  format[1] = 10;
#line 220
  format[2] = 10;
#line 220
  format[3] = 10;
#line 220
  format[4] = 12;
#line 220
  format[5] = 14;
#line 220
  format[6] = 15;
#line 220
  format[7] = 18;
#line 220
  format[8] = 16;
#line 220
  format[9] = 17;
#line 220
  format[10] = 0;
#line 220
  format[11] = 1;
#line 220
  format[12] = 2;
#line 220
  format[13] = 0;
#line 220
  format[14] = 0;
#line 221
  __cil_tmp6 = strrchr(filename, '.');
#line 221
  ext = __cil_tmp6;
  }
#line 222
  if (ext == (void *)0) {
#line 223
    return (- 1);
  }
#line 224
  ext ++;
#line 225
  if (*ext) {
#line 226
    i = (unsigned int )0;
    {
#line 226
    while (1) {
      while_continue: /* CIL Label */ ;
#line 226
      if (! ((unsigned long )i < sizeof(format) / sizeof(*((int const   *)format)))) {
#line 226
        goto while_break;
      }
      {
#line 227
      __cil_tmp8 = strcasecmp((char const   *)ext, extension[i]);
      }
#line 227
      if (__cil_tmp8 == 0) {
#line 228
        return (format[i]);
      }
#line 226
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 233
  return (- 1);
}
}
#line 237 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
char get_next_file(int imageno , dircnt_t *dirptr , img_fol_t *img_fol , opj_dparameters_t *parameters ) 
{ 
  char image_filename[4096] ;
  char infilename[4096] ;
  char outfilename[4096] ;
  char temp_ofname[4096] ;
  char *temp_p ;
  char temp1[4096] ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 239
  strcpy((char *)temp1, "\002");;
#line 241
  strcpy((char *)image_filename, (char const   *)*(dirptr->filename + imageno));
#line 242
  fprintf(stderr, "File Number %d \"%s\"\n\347U", imageno, (char *)image_filename);
#line 243
  parameters->decod_format = infile_format((char const   *)((char *)image_filename));
  }
#line 244
  if (parameters->decod_format == -1) {
#line 245
    return ((char )1);
  }
  {
#line 246
  sprintf((char *)infilename, "%s/%s", img_fol->imgdirpath, (char *)image_filename);
#line 247
  strncpy((char *)parameters->infile, (char const   *)((char *)infilename), sizeof(infilename));
#line 250
  __cil_tmp12 = strtok((char *)image_filename, ".");
#line 250
  strcpy((char *)temp_ofname, (char const   *)__cil_tmp12);
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 251
    temp_p = strtok((char *)((void *)0), ".");
    }
#line 251
    if (! (temp_p != (void *)0)) {
#line 251
      goto while_break;
    }
    {
#line 252
    strcat((char *)temp_ofname, (char const   *)((char *)temp1));
#line 253
    sprintf((char *)temp1, ".%s", temp_p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  if ((int )img_fol->set_out_format == 1) {
    {
#line 256
    sprintf((char *)outfilename, "%s/%s.%s\230\001", img_fol->imgdirpath, (char *)temp_ofname,
            img_fol->out_format);
#line 257
    strncpy((char *)parameters->outfile, (char const   *)((char *)outfilename), sizeof(outfilename));
    }
  }
#line 259
  return ((char )0);
}
}
#line 268 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
static int infile_format(char const   *fname ) 
{ 
  FILE *reader ;
  char const   *s ;
  char const   *magic_s ;
  int ext_format ;
  int magic_format ;
  unsigned char buf[12] ;
  OPJ_SIZE_T l_nb_read ;
  FILE *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;

  {
  {
#line 276
  reader = fopen(fname, "rb\267j\347U");
  }
#line 278
  if (reader == (void *)0) {
#line 279
    return (- 2);
  }
  {
#line 281
  memset((unsigned char *)buf, 0, (unsigned long )12);
#line 282
  l_nb_read = fread((unsigned char *)buf, (unsigned long )1, (unsigned long )12, reader);
#line 283
  fclose(reader);
  }
#line 284
  if (l_nb_read != 12UL) {
#line 285
    return (- 1);
  }
  {
#line 289
  ext_format = get_file_format(fname);
  }
#line 291
  if (ext_format == 2) {
#line 292
    return (2);
  }
  {
#line 294
  __cil_tmp13 = memcmp((unsigned char *)buf, "\r\n\207\n", (unsigned long )4);
  }
  {
#line 294
  __cil_tmp12 = memcmp((unsigned char *)buf, "", (unsigned long )12);
  }
#line 294
  if (__cil_tmp12 == 0) {
#line 295
    magic_format = 1;
#line 296
    strcpy((char *)magic_s, ".jp2");;
  } else
#line 294
  if (__cil_tmp13 == 0) {
#line 295
    magic_format = 1;
#line 296
    strcpy((char *)magic_s, ".jp2");;
  } else {
    {
#line 298
    __cil_tmp14 = memcmp((unsigned char *)buf, "\377O\377Q\347U", (unsigned long )4);
    }
#line 298
    if (__cil_tmp14 == 0) {
#line 299
      magic_format = 0;
#line 300
      strcpy((char *)magic_s, ".j2k or .jpc or .j2c");;
    } else {
#line 303
      return (- 1);
    }
  }
#line 305
  if (magic_format == ext_format) {
#line 306
    return (ext_format);
  }
  {
#line 308
  __cil_tmp15 = strlen(fname);
#line 308
  s = (fname + __cil_tmp15) - 4;
#line 310
  fputs("\n===========================================\n", stderr);
#line 311
  fprintf(stderr, "The extension of this file is incorrect.\nFOUND %s. SHOULD BE %s\n",
          s, magic_s);
#line 313
  fputs("===========================================\n", stderr);
  }
#line 315
  return (magic_format);
}
}
#line 323 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
int parse_cmdline_decoder(int argc , char **argv , opj_dparameters_t *parameters ,
                          img_fol_t *img_fol , char *indexfilename ) 
{ 
  int totlen ;
  int c ;
  opj_option_t long_option[2] ;
  char const   optlist[16] ;
  int __cil_tmp10 ;
  char *infile ;
  int __cil_tmp12 ;
  char *outfile ;
  int __cil_tmp14 ;
  char outformat[50] ;
  char *of ;
  int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  void *__cil_tmp19 ;
  int size_optarg ;
  unsigned long __cil_tmp21 ;
  char *ROI_values ;
  void *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  char *index___56 ;

  {
#line 326
  strcpy((char *)long_option[0].name, "ImgDir");;
#line 326
  long_option[0].has_arg = 1;
#line 326
  long_option[0].flag = (int *)((void *)0);
#line 326
  long_option[0].val = 'y';
#line 326
  strcpy((char *)long_option[1].name, "OutFor");;
#line 326
  long_option[1].has_arg = 1;
#line 326
  long_option[1].flag = (int *)((void *)0);
#line 326
  long_option[1].val = 'O';
#line 331
  strcpy((char *)optlist, "i:o:r:l:x:d:t:h");;
#line 339
  totlen = (int )sizeof(long_option);
#line 340
  img_fol->set_out_format = (char )0;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 342
    c = opj_getopt_long(argc, (char * const  [])argv, (char const   *)optlist, (opj_option_t *)long_option,
                        totlen);
    }
#line 343
    if (c == -1) {
#line 344
      goto while_break;
    }
    {
#line 346
    if (c == 'i') {
#line 346
      goto case_105;
    }
#line 351
    if (c == 0) {
#line 351
      goto case_0;
    }
#line 353
    if (c == 1) {
#line 353
      goto case_1;
    }
#line 355
    if (c == 2) {
#line 355
      goto case_2;
    }
#line 357
    if (c == - 2) {
#line 357
      goto case_exp;
    }
#line 375
    if (c == 'o') {
#line 375
      goto case_111;
    }
#line 380
    if (c == 11) {
#line 380
      goto case_11;
    }
#line 382
    if (c == 10) {
#line 382
      goto case_10;
    }
#line 384
    if (c == 12) {
#line 384
      goto case_12;
    }
#line 386
    if (c == 14) {
#line 386
      goto case_14;
    }
#line 388
    if (c == 15) {
#line 388
      goto case_15;
    }
#line 390
    if (c == 18) {
#line 390
      goto case_18;
    }
#line 392
    if (c == 16) {
#line 392
      goto case_16;
    }
#line 394
    if (c == 17) {
#line 394
      goto case_17;
    }
#line 406
    if (c == 'O') {
#line 406
      goto case_79;
    }
#line 414
    if (c == 11) {
#line 414
      goto case_11___0;
    }
#line 417
    if (c == 10) {
#line 417
      goto case_10___0;
    }
#line 420
    if (c == 12) {
#line 420
      goto case_12___0;
    }
#line 423
    if (c == 14) {
#line 423
      goto case_14___0;
    }
#line 426
    if (c == 15) {
#line 426
      goto case_15___0;
    }
#line 429
    if (c == 18) {
#line 429
      goto case_18___0;
    }
#line 432
    if (c == 16) {
#line 432
      goto case_16___0;
    }
#line 435
    if (c == 17) {
#line 435
      goto case_17___0;
    }
#line 449
    if (c == 'r') {
#line 449
      goto case_114;
    }
#line 458
    if (c == 'l') {
#line 458
      goto case_108;
    }
#line 466
    if (c == 'h') {
#line 466
      goto case_104;
    }
#line 472
    if (c == 'y') {
#line 472
      goto case_121;
    }
#line 482
    if (c == 'd') {
#line 482
      goto case_100;
    }
#line 498
    if (c == 't') {
#line 498
      goto case_116;
    }
#line 507
    if (c == 'x') {
#line 507
      goto case_120;
    }
#line 587
    goto switch_default___2;
    case_105: /* CIL Label */ 
    {
#line 348
    infile = opj_optarg;
#line 349
    parameters->decod_format = infile_format((char const   *)infile);
    }
    {
#line 351
    if (parameters->decod_format == 0) {
#line 351
      goto case_0;
    }
#line 353
    if (parameters->decod_format == 1) {
#line 353
      goto case_1;
    }
#line 355
    if (parameters->decod_format == 2) {
#line 355
      goto case_2;
    }
#line 357
    if (parameters->decod_format == - 2) {
#line 357
      goto case_exp;
    }
#line 362
    goto switch_default;
    case_0: /* CIL Label */ 
#line 352
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 354
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 356
    goto switch_break___0;
    case_exp: /* CIL Label */ 
    {
#line 358
    fprintf(stderr, "!! infile cannot be read: %s !!\n\n", infile);
    }
#line 361
    return (1);
    switch_default: /* CIL Label */ 
    {
#line 363
    fprintf(stderr, "[ERROR] Unknown input file format: %s \n        Known file formats are *.j2k, *.jp2, *.jpc or *.jpt\n",
            infile);
    }
#line 367
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 369
    strncpy((char *)parameters->infile, (char const   *)infile, sizeof(parameters->infile) - 1UL);
    }
#line 371
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 377
    outfile = opj_optarg;
#line 378
    parameters->cod_format = get_file_format((char const   *)outfile);
    }
    {
#line 380
    if (parameters->cod_format == 11) {
#line 380
      goto case_11;
    }
#line 382
    if (parameters->cod_format == 10) {
#line 382
      goto case_10;
    }
#line 384
    if (parameters->cod_format == 12) {
#line 384
      goto case_12;
    }
#line 386
    if (parameters->cod_format == 14) {
#line 386
      goto case_14;
    }
#line 388
    if (parameters->cod_format == 15) {
#line 388
      goto case_15;
    }
#line 390
    if (parameters->cod_format == 18) {
#line 390
      goto case_18;
    }
#line 392
    if (parameters->cod_format == 16) {
#line 392
      goto case_16;
    }
#line 394
    if (parameters->cod_format == 17) {
#line 394
      goto case_17;
    }
#line 396
    goto switch_default___0;
    case_11: /* CIL Label */ 
#line 381
    goto switch_break___1;
    case_10: /* CIL Label */ 
#line 383
    goto switch_break___1;
    case_12: /* CIL Label */ 
#line 385
    goto switch_break___1;
    case_14: /* CIL Label */ 
#line 387
    goto switch_break___1;
    case_15: /* CIL Label */ 
#line 389
    goto switch_break___1;
    case_18: /* CIL Label */ 
#line 391
    goto switch_break___1;
    case_16: /* CIL Label */ 
#line 393
    goto switch_break___1;
    case_17: /* CIL Label */ 
#line 395
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 397
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n",
            outfile);
    }
#line 398
    return (1);
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 400
    strncpy((char *)parameters->outfile, (char const   *)outfile, sizeof(parameters->outfile) - 1UL);
    }
#line 402
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 409
    of = opj_optarg;
#line 410
    sprintf((char *)outformat, ".%sj\347U", of);
#line 411
    img_fol->set_out_format = (char )1;
#line 412
    parameters->cod_format = get_file_format((char const   *)((char *)outformat));
    }
    {
#line 414
    if (parameters->cod_format == 11) {
#line 414
      goto case_11___0;
    }
#line 417
    if (parameters->cod_format == 10) {
#line 417
      goto case_10___0;
    }
#line 420
    if (parameters->cod_format == 12) {
#line 420
      goto case_12___0;
    }
#line 423
    if (parameters->cod_format == 14) {
#line 423
      goto case_14___0;
    }
#line 426
    if (parameters->cod_format == 15) {
#line 426
      goto case_15___0;
    }
#line 429
    if (parameters->cod_format == 18) {
#line 429
      goto case_18___0;
    }
#line 432
    if (parameters->cod_format == 16) {
#line 432
      goto case_16___0;
    }
#line 435
    if (parameters->cod_format == 17) {
#line 435
      goto case_17___0;
    }
#line 438
    goto switch_default___1;
    case_11___0: /* CIL Label */ 
#line 415
    strcpy((char *)img_fol->out_format, "pgx");;
#line 416
    goto switch_break___2;
    case_10___0: /* CIL Label */ 
#line 418
    strcpy((char *)img_fol->out_format, "ppm");;
#line 419
    goto switch_break___2;
    case_12___0: /* CIL Label */ 
#line 421
    strcpy((char *)img_fol->out_format, "bmpj\347U");;
#line 422
    goto switch_break___2;
    case_14___0: /* CIL Label */ 
#line 424
    strcpy((char *)img_fol->out_format, "tif");;
#line 425
    goto switch_break___2;
    case_15___0: /* CIL Label */ 
#line 427
    strcpy((char *)img_fol->out_format, "rawj\347U");;
#line 428
    goto switch_break___2;
    case_18___0: /* CIL Label */ 
#line 430
    strcpy((char *)img_fol->out_format, "rawl\347U");;
#line 431
    goto switch_break___2;
    case_16___0: /* CIL Label */ 
#line 433
    strcpy((char *)img_fol->out_format, "raw");;
#line 434
    goto switch_break___2;
    case_17___0: /* CIL Label */ 
#line 436
    strcpy((char *)img_fol->out_format, "png");;
#line 437
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 439
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n",
            (char *)outformat);
    }
#line 440
    return (1);
#line 441
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 444
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 451
    sscanf((char const   *)opj_optarg, "%ud", & parameters->cp_reduce);
    }
#line 453
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 460
    sscanf((char const   *)opj_optarg, "%ud", & parameters->cp_layer);
    }
#line 462
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 467
    decode_help_display();
    }
#line 468
    return (1);
    case_121: /* CIL Label */ 
    {
#line 474
    __cil_tmp18 = strlen((char const   *)opj_optarg);
#line 474
    __cil_tmp19 = malloc(__cil_tmp18 + 1UL);
#line 474
    img_fol->imgdirpath = (char *)__cil_tmp19;
#line 475
    strcpy(img_fol->imgdirpath, (char const   *)opj_optarg);
#line 476
    img_fol->set_imgdir = (char )1;
    }
#line 478
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 484
    __cil_tmp21 = strlen((char const   *)opj_optarg);
#line 484
    size_optarg = (int )__cil_tmp21 + 1;
#line 485
    __cil_tmp23 = malloc((size_t )size_optarg);
#line 485
    ROI_values = (char *)__cil_tmp23;
#line 486
    *(ROI_values + 0) = (char )'\000';
#line 487
    __cil_tmp24 = strlen((char const   *)opj_optarg);
#line 487
    strncpy(ROI_values, (char const   *)opj_optarg, __cil_tmp24);
#line 488
    __cil_tmp25 = strlen((char const   *)opj_optarg);
#line 488
    *(ROI_values + __cil_tmp25) = (char )'\000';
#line 490
    parse_DA_values(ROI_values, & parameters->DA_x0, & parameters->DA_y0, & parameters->DA_x1,
                    & parameters->DA_y1);
#line 492
    free(ROI_values);
    }
#line 494
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 500
    sscanf((char const   *)opj_optarg, "%ud", & parameters->tile_index);
#line 501
    parameters->nb_tile_to_decode = (OPJ_UINT32 )1;
    }
#line 503
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 509
    index___56 = opj_optarg;
#line 510
    strncpy(indexfilename, (char const   *)index___56, (unsigned long )4096);
    }
#line 512
    goto switch_break;
    switch_default___2: /* CIL Label */ 
    {
#line 588
    fprintf(stderr, "[WARNING] An invalid option has been ignored.\n");
    }
#line 589
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 341
    if (! (c != -1)) {
#line 341
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 594
  if ((int )img_fol->set_imgdir == 1) {
#line 595
    if (! ((int )parameters->infile[0] == 0)) {
      {
#line 596
      fprintf(stderr, "[ERROR] options -ImgDir and -i cannot be used together.\n\220");
      }
#line 597
      return (1);
    }
#line 599
    if ((int )img_fol->set_out_format == 0) {
      {
#line 600
      fprintf(stderr, "[ERROR] When -ImgDir is used, -OutFor <FORMAT> must be used.\n");
#line 601
      fprintf(stderr, "Only one format allowed.\nValid format are PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA.\n");
      }
#line 603
      return (1);
    }
#line 605
    if (! ((int )parameters->outfile[0] == 0)) {
      {
#line 606
      fprintf(stderr, "[ERROR] options -ImgDir and -o cannot be used together.\n\220");
      }
#line 607
      return (1);
    }
  } else
#line 610
  if ((int )parameters->infile[0] == 0) {
    {
    {
#line 611
    fprintf(stderr, "[ERROR] Required parameters are missing\nExample: %s -i image.j2k -o image.pgm\n",
            *(argv + 0));
    }
    {
#line 613
    fprintf(stderr, "   Help: %s -h\n", *(argv + 0));
    }
    }
#line 614
    return (1);
  } else
#line 610
  if ((int )parameters->outfile[0] == 0) {
    {
    {
#line 611
    fprintf(stderr, "[ERROR] Required parameters are missing\nExample: %s -i image.j2k -o image.pgm\n",
            *(argv + 0));
    }
    {
#line 613
    fprintf(stderr, "   Help: %s -h\n", *(argv + 0));
    }
    }
#line 614
    return (1);
  }
#line 618
  return (0);
}
}
#line 627 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
int parse_DA_values(char *inArg , unsigned int *DA_x0 , unsigned int *DA_y0 , unsigned int *DA_x1 ,
                    unsigned int *DA_y1 ) 
{ 
  int it ;
  int values[4] ;
  char delims[2] ;
  char *result ;
  char *__cil_tmp10 ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 629
  it = 0;
#line 631
  strcpy((char *)delims, ",");;
#line 632
  result = (char *)((void *)0);
#line 633
  result = strtok(inArg, (char const   *)((char *)delims));
  }
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! (result != (void *)0 && it < 4)) {
#line 635
      goto while_break;
    }
    {
#line 636
    values[it] = atoi((char const   *)result);
#line 637
    result = strtok((char *)((void *)0), (char const   *)((char *)delims));
#line 638
    it ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 641
  if (it != 4) {
#line 642
    return (1);
  } else {
#line 645
    *DA_x0 = (OPJ_UINT32 )values[0];
#line 645
    *DA_y0 = (OPJ_UINT32 )values[1];
#line 646
    *DA_x1 = (OPJ_UINT32 )values[2];
#line 646
    *DA_y1 = (OPJ_UINT32 )values[3];
#line 647
    return (0);
  }
}
}
#line 656 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
static void error_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 658
  fprintf(stdout, "[ERROR] %s", msg);
  }
  return;
}
}
#line 663 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
static void warning_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 665
  fprintf(stdout, "[WARNING] %s", msg);
  }
  return;
}
}
#line 670 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
static void info_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 672
  fprintf(stdout, "[INFO] %s", msg);
  }
  return;
}
}
#line 680 "/root/patron/new_21/src/bin/jp2/opj_decompress.c"
int main(int argc , char **argv ) 
{ 
  opj_dparameters_t parameters ;
  opj_image_t *image ;
  opj_stream_t *l_stream ;
  opj_codec_t *l_codec ;
  opj_codestream_index_t *cstr_index ;
  char indexfilename[4096] ;
  OPJ_INT32 num_images ;
  OPJ_INT32 imageno ;
  img_fol_t img_fol ;
  dircnt_t *dirptr ;
  int failed ;
  int __cil_tmp14 ;
  int it_image ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  char __cil_tmp22 ;
  opj_stream_t *__cil_tmp23 ;
  opj_codec_t *__cil_tmp24 ;
  opj_codec_t *__cil_tmp25 ;
  opj_codec_t *__cil_tmp26 ;
  OPJ_BOOL __cil_tmp27 ;
  OPJ_BOOL __cil_tmp28 ;
  OPJ_BOOL __cil_tmp29 ;
  OPJ_BOOL __cil_tmp30 ;
  OPJ_BOOL __cil_tmp31 ;
  OPJ_BOOL __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  OPJ_INT32 __cil_tmp41 ;
  int tmp ;

  {
  {
#line 683
  image = (opj_image_t *)((void *)0);
#line 684
  l_stream = (opj_stream_t *)((void *)0);
#line 685
  l_codec = (opj_codec_t *)((void *)0);
#line 686
  cstr_index = (opj_codestream_index_t *)((void *)0);
#line 692
  dirptr = (dircnt_t *)((void *)0);
#line 693
  failed = 0;
#line 696
  opj_set_default_decoder_parameters(& parameters);
#line 699
  *((char *)indexfilename) = (char )0;
#line 702
  memset(& img_fol, 0, sizeof(img_fol_t ));
#line 705
  __cil_tmp14 = parse_cmdline_decoder(argc, argv, & parameters, & img_fol, (char *)indexfilename);
  }
#line 705
  if (__cil_tmp14 == 1) {
#line 706
    return (1);
  }
#line 710
  if ((int )img_fol.set_imgdir == 1) {
    {
#line 712
    num_images = get_num_images(img_fol.imgdirpath);
#line 714
    __cil_tmp17 = malloc(sizeof(dircnt_t ));
#line 714
    dirptr = (dircnt_t *)__cil_tmp17;
    }
#line 715
    if (dirptr) {
      {
#line 716
      __cil_tmp18 = malloc(((size_t )num_images * 4096UL) * sizeof(char ));
#line 716
      dirptr->filename_buf = (char *)__cil_tmp18;
#line 717
      __cil_tmp19 = malloc((size_t )num_images * sizeof(char *));
#line 717
      dirptr->filename = (char **)__cil_tmp19;
      }
#line 719
      if (! dirptr->filename_buf) {
#line 720
        return (1);
      }
#line 722
      it_image = 0;
      {
#line 722
      while (1) {
        while_continue: /* CIL Label */ ;
#line 722
        if (! (it_image < num_images)) {
#line 722
          goto while_break;
        }
#line 723
        *(dirptr->filename + it_image) = dirptr->filename_buf + it_image * 4096;
#line 722
        it_image ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 726
    __cil_tmp21 = load_images(dirptr, img_fol.imgdirpath);
    }
#line 726
    if (__cil_tmp21 == 1) {
#line 727
      return (1);
    }
#line 729
    if (num_images == 0) {
      {
#line 730
      fprintf(stdout, "Folder is empty\n\220");
      }
#line 731
      return (1);
    }
  } else {
#line 734
    num_images = 1;
  }
#line 738
  imageno = 0;
  {
#line 738
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 738
    if (! (imageno < num_images)) {
#line 738
      goto while_break___0;
    }
    {
#line 740
    fprintf(stderr, "\n\360\267j\347U");
    }
#line 742
    if ((int )img_fol.set_imgdir == 1) {
      {
#line 743
      __cil_tmp22 = get_next_file(imageno, dirptr, & img_fol, & parameters);
      }
#line 743
      if (__cil_tmp22) {
        {
#line 744
        fprintf(stderr, "skipping file...\n");
        }
#line 745
        goto while_continue___0;
      }
    }
    {
#line 752
    l_stream = opj_stream_create_default_file_stream((char const   *)((char *)parameters.infile),
                                                     1);
    }
#line 753
    if (! l_stream) {
      {
#line 754
      fprintf(stderr, "ERROR -> failed to create the stream from the file %s\n", (char *)parameters.infile);
      }
#line 755
      return (1);
    }
    {
#line 762
    if (parameters.decod_format == 0) {
#line 762
      goto case_0;
    }
#line 768
    if (parameters.decod_format == 1) {
#line 768
      goto case_1;
    }
#line 774
    if (parameters.decod_format == 2) {
#line 774
      goto case_2;
    }
#line 780
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 765
    l_codec = opj_create_decompress((OPJ_CODEC_FORMAT )0);
    }
#line 766
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 771
    l_codec = opj_create_decompress((OPJ_CODEC_FORMAT )2);
    }
#line 772
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 777
    l_codec = opj_create_decompress((OPJ_CODEC_FORMAT )1);
    }
#line 778
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 781
    fprintf(stderr, "skipping file..\n\220");
    }
    {
#line 782
    opj_stream_destroy(l_stream);
    }
#line 783
    goto while_continue___0;
    switch_break: /* CIL Label */ ;
    }
    {
#line 787
    opj_set_info_handler(l_codec, & info_callback, (void *)0);
#line 788
    opj_set_warning_handler(l_codec, & warning_callback, (void *)0);
#line 789
    opj_set_error_handler(l_codec, & error_callback, (void *)0);
#line 792
    __cil_tmp27 = opj_setup_decoder(l_codec, & parameters);
    }
#line 792
    if (! __cil_tmp27) {
      {
#line 793
      fprintf(stderr, "ERROR -> opj_compress: failed to setup the decoder\n");
#line 794
      opj_stream_destroy(l_stream);
#line 795
      opj_destroy_codec(l_codec);
      }
#line 796
      return (1);
    }
    {
#line 801
    __cil_tmp28 = opj_read_header(l_stream, l_codec, & image);
    }
#line 801
    if (! __cil_tmp28) {
      {
#line 802
      fprintf(stderr, "ERROR -> opj_decompress: failed to read the header\n");
#line 803
      opj_stream_destroy(l_stream);
#line 804
      opj_destroy_codec(l_codec);
#line 805
      opj_image_destroy(image);
      }
#line 806
      return (1);
    }
#line 809
    if (! parameters.nb_tile_to_decode) {
      {
#line 811
      __cil_tmp29 = opj_set_decode_area(l_codec, image, (OPJ_INT32 )parameters.DA_x0,
                                        (OPJ_INT32 )parameters.DA_y0, (OPJ_INT32 )parameters.DA_x1,
                                        (OPJ_INT32 )parameters.DA_y1);
      }
#line 811
      if (! __cil_tmp29) {
        {
#line 813
        fprintf(stderr, "ERROR -> opj_decompress: failed to set the decoded area\n\220");
#line 814
        opj_stream_destroy(l_stream);
#line 815
        opj_destroy_codec(l_codec);
#line 816
        opj_image_destroy(image);
        }
#line 817
        return (1);
      }
      {
#line 821
      __cil_tmp31 = opj_end_decompress(l_codec, l_stream);
      }
      {
#line 821
      __cil_tmp30 = opj_decode(l_codec, l_stream, image);
      }
#line 821
      if (! (__cil_tmp30 && __cil_tmp31)) {
        {
#line 822
        fprintf(stderr, "ERROR -> opj_decompress: failed to decode image!\n");
#line 823
        opj_destroy_codec(l_codec);
#line 824
        opj_stream_destroy(l_stream);
#line 825
        opj_image_destroy(image);
        }
#line 826
        return (1);
      }
    } else {
      {
#line 840
      __cil_tmp32 = opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index);
      }
#line 840
      if (! __cil_tmp32) {
        {
#line 841
        fprintf(stderr, "ERROR -> opj_decompress: failed to decode tile!\n\220");
#line 842
        opj_destroy_codec(l_codec);
#line 843
        opj_stream_destroy(l_stream);
#line 844
        opj_image_destroy(image);
        }
#line 845
        return (1);
      }
      {
#line 847
      fprintf(stdout, "tile %d is decoded!\n\n", parameters.tile_index);
      }
    }
    {
#line 851
    opj_stream_destroy(l_stream);
    }
#line 853
    if ((int )image->color_space == 3) {
      {
#line 854
      color_sycc_to_rgb(image);
      }
    }
#line 857
    if ((int )image->color_space != 3) {
#line 857
      if (image->numcomps == 3U) {
#line 857
        if ((image->comps + 0)->dx == (image->comps + 0)->dy) {
#line 857
          if ((image->comps + 1)->dx != 1U) {
#line 860
            image->color_space = (OPJ_COLOR_SPACE )3;
          } else {
#line 857
            goto _L;
          }
        } else {
#line 857
          goto _L;
        }
      } else {
#line 857
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    _L___57: /* CIL Label */ 
    _L___58: /* CIL Label */ 
#line 861
    if (image->numcomps <= 2U) {
#line 862
      image->color_space = (OPJ_COLOR_SPACE )2;
    }
#line 864
    if (image->icc_profile_buf) {
      {
#line 868
      free(image->icc_profile_buf);
#line 869
      image->icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 869
      image->icc_profile_len = (OPJ_UINT32 )0;
      }
    }
    {
#line 875
    if (parameters.cod_format == 10) {
#line 875
      goto case_10;
    }
#line 885
    if (parameters.cod_format == 11) {
#line 885
      goto case_11;
    }
#line 895
    if (parameters.cod_format == 12) {
#line 895
      goto case_12;
    }
#line 905
    if (parameters.cod_format == 14) {
#line 905
      goto case_14;
    }
#line 915
    if (parameters.cod_format == 15) {
#line 915
      goto case_15;
    }
#line 925
    if (parameters.cod_format == 18) {
#line 925
      goto case_18;
    }
#line 935
    if (parameters.cod_format == 16) {
#line 935
      goto case_16;
    }
#line 945
    if (parameters.cod_format == 17) {
#line 945
      goto case_17;
    }
#line 958
    goto switch_default___0;
    case_10: /* CIL Label */ 
    {
#line 876
    __cil_tmp33 = imagetopnm(image, (char const   *)((char *)parameters.outfile));
    }
#line 876
    if (__cil_tmp33) {
      {
#line 877
      fprintf(stderr, "[ERROR] Outfile %s not generated\n", (char *)parameters.outfile);
#line 878
      failed = 1;
      }
    } else {
      {
#line 881
      fprintf(stdout, "[INFO] Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 883
    goto switch_break___0;
    case_11: /* CIL Label */ 
    {
#line 886
    __cil_tmp34 = imagetopgx(image, (char const   *)((char *)parameters.outfile));
    }
#line 886
    if (__cil_tmp34) {
      {
#line 887
      fprintf(stderr, "[ERROR] Outfile %s not generated\n", (char *)parameters.outfile);
#line 888
      failed = 1;
      }
    } else {
      {
#line 891
      fprintf(stdout, "[INFO] Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 893
    goto switch_break___0;
    case_12: /* CIL Label */ 
    {
#line 896
    __cil_tmp35 = imagetobmp(image, (char const   *)((char *)parameters.outfile));
    }
#line 896
    if (__cil_tmp35) {
      {
#line 897
      fprintf(stderr, "[ERROR] Outfile %s not generated\n", (char *)parameters.outfile);
#line 898
      failed = 1;
      }
    } else {
      {
#line 901
      fprintf(stdout, "[INFO] Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 903
    goto switch_break___0;
    case_14: /* CIL Label */ 
    {
#line 906
    __cil_tmp36 = imagetotif(image, (char const   *)((char *)parameters.outfile));
    }
#line 906
    if (__cil_tmp36) {
      {
#line 907
      fprintf(stderr, "[ERROR] Outfile %s not generated\n", (char *)parameters.outfile);
#line 908
      failed = 1;
      }
    } else {
      {
#line 911
      fprintf(stdout, "[INFO] Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 913
    goto switch_break___0;
    case_15: /* CIL Label */ 
    {
#line 916
    __cil_tmp37 = imagetoraw(image, (char const   *)((char *)parameters.outfile));
    }
#line 916
    if (__cil_tmp37) {
      {
#line 917
      fprintf(stderr, "[ERROR] Error generating raw file. Outfile %s not generated\n",
              (char *)parameters.outfile);
#line 918
      failed = 1;
      }
    } else {
      {
#line 921
      fprintf(stdout, "[INFO] Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 923
    goto switch_break___0;
    case_18: /* CIL Label */ 
    {
#line 926
    __cil_tmp38 = imagetorawl(image, (char const   *)((char *)parameters.outfile));
    }
#line 926
    if (__cil_tmp38) {
      {
#line 927
      fprintf(stderr, "[ERROR] Error generating rawl file. Outfile %s not generated\n",
              (char *)parameters.outfile);
#line 928
      failed = 1;
      }
    } else {
      {
#line 931
      fprintf(stdout, "[INFO] Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 933
    goto switch_break___0;
    case_16: /* CIL Label */ 
    {
#line 936
    __cil_tmp39 = imagetotga(image, (char const   *)((char *)parameters.outfile));
    }
#line 936
    if (__cil_tmp39) {
      {
#line 937
      fprintf(stderr, "[ERROR] Error generating tga file. Outfile %s not generated\n",
              (char *)parameters.outfile);
#line 938
      failed = 1;
      }
    } else {
      {
#line 941
      fprintf(stdout, "[INFO] Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 943
    goto switch_break___0;
    case_17: /* CIL Label */ 
    {
#line 946
    __cil_tmp40 = imagetopng(image, (char const   *)((char *)parameters.outfile));
    }
#line 946
    if (__cil_tmp40) {
      {
#line 947
      fprintf(stderr, "[ERROR] Error generating png file. Outfile %s not generated\n",
              (char *)parameters.outfile);
#line 948
      failed = 1;
      }
    } else {
      {
#line 951
      fprintf(stdout, "[INFO] Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 953
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 959
    fprintf(stderr, "[ERROR] Outfile %s not generated\n", (char *)parameters.outfile);
    }
#line 960
    failed = 1;
    switch_break___0: /* CIL Label */ ;
    }
#line 964
    if (l_codec) {
      {
#line 965
      opj_destroy_codec(l_codec);
      }
    }
    {
#line 970
    opj_image_destroy(image);
#line 973
    opj_destroy_cstr_index(& cstr_index);
    }
#line 975
    if (failed) {
      {
#line 975
      remove((char const   *)((char *)parameters.outfile));
      }
    }
#line 738
    imageno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 977
  if (failed) {
#line 977
    tmp = 1;
  } else {
#line 977
    tmp = 0;
  }
#line 977
  return (tmp);
}
}
#line 46 "/root/patron/new_21/src/bin/common/opj_getopt.c"
int opj_opterr  =    1;
#line 47 "/root/patron/new_21/src/bin/common/opj_getopt.c"
int opj_optind  =    1;
#line 54 "/root/patron/new_21/src/bin/common/opj_getopt.c"
static char EMSG[1]  = {      "\250"};
#line 57 "/root/patron/new_21/src/bin/common/opj_getopt.c"
void reset_options_reading(void) 
{ 


  {
#line 58
  opj_opterr = 1;
#line 59
  opj_optind = 1;
  return;
}
}
#line 66 "/root/patron/new_21/src/bin/common/opj_getopt.c"
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ 
  static char *place ;
  char *oli ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 68
  place = (char *)EMSG;
#line 69
  oli = (char *)((void *)0);
#line 71
  if (opj_optreset) {
    _L: /* CIL Label */ 
#line 72
    opj_optreset = 0;
#line 73
    place = *(nargv + opj_optind);
#line 73
    if (opj_optind >= nargc) {
#line 74
      place = (char *)EMSG;
#line 75
      return (- 1);
    } else
#line 73
    if ((int )*place != 45) {
#line 74
      place = (char *)EMSG;
#line 75
      return (- 1);
    }
#line 77
    place ++;
#line 77
    if ((int )*(place + 1)) {
#line 77
      if ((int )*place == 45) {
#line 78
        opj_optind ++;
#line 79
        place = (char *)EMSG;
#line 80
        return (- 1);
      }
    }
  } else
#line 71
  if (! *place) {
#line 71
    goto _L;
  }
  {
#line 83
  oli = strchr(ostr, opj_optopt);
  }
#line 83
  __cil_tmp6 = place;
#line 83
  place ++;
#line 83
  opj_optopt = (int )*__cil_tmp6;
#line 83
  if (! oli) {
    _L___59: /* CIL Label */ 
#line 89
    if (opj_optopt == 45) {
#line 90
      return (- 1);
    }
#line 91
    if (! *place) {
#line 92
      opj_optind ++;
    }
#line 93
    if (opj_opterr) {
#line 93
      if ((int )*ostr != 58) {
        {
#line 94
        fprintf(stderr, "%s: illegal option -- %c\n", *(nargv + 0), opj_optopt);
        }
#line 96
        return ((int )'?');
      }
    }
  } else
#line 83
  if (opj_optopt == 58) {
#line 83
    goto _L___59;
  }
#line 99
  oli ++;
#line 99
  if ((int )*oli != 58) {
#line 100
    opj_optarg = (char *)((void *)0);
#line 101
    if (! *place) {
#line 102
      opj_optind ++;
    }
  } else {
#line 104
    if (*place) {
#line 105
      opj_optarg = place;
    } else {
#line 106
      opj_optind ++;
#line 106
      if (nargc <= opj_optind) {
#line 107
        place = (char *)EMSG;
#line 108
        if ((int )*ostr == 58) {
#line 109
          return ((int )':');
        }
#line 110
        if (opj_opterr) {
          {
#line 111
          fprintf(stderr, "%s: option requires an argument -- %c\n", *(nargv + 0),
                  opj_optopt);
          }
#line 114
          return ((int )'?');
        }
      } else {
#line 117
        opj_optarg = *(nargv + opj_optind);
      }
    }
#line 118
    place = (char *)EMSG;
#line 119
    opj_optind ++;
  }
#line 121
  return (opj_optopt);
}
}
#line 125 "/root/patron/new_21/src/bin/common/opj_getopt.c"
int opj_getopt_long(int argc , char * const  argv[] , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) 
{ 
  static int lastidx ;
  static int lastofs ;
  char *tmp ;
  int i ;
  int len ;
  char param ;
  char *arg ;
  opj_option_t *o ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  opj_option_t *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 130
  param = (char )1;
  again: 
#line 133
  if (! argv[opj_optind]) {
#line 134
    return (- 1);
  } else
#line 133
  if (opj_optind >= argc) {
#line 134
    return (- 1);
  } else
#line 133
  if ((int )*(argv[opj_optind]) != 45) {
#line 134
    return (- 1);
  }
#line 136
  if ((int )*(argv[opj_optind] + 0) == 45) {
#line 136
    if ((int )*(argv[opj_optind] + 1) == 0) {
#line 137
      if (opj_optind >= argc - 1) {
#line 138
        param = (char )0;
      } else
#line 141
      if ((int )*(argv[opj_optind + 1] + 0) == 45) {
#line 142
        param = (char )0;
      } else {
#line 145
        param = (char )2;
      }
    }
  }
#line 150
  if ((int )param == 0) {
#line 151
    opj_optind ++;
#line 152
    return ((int )'?');
  }
#line 155
  if ((int )*(argv[opj_optind] + 0) == 45) {
#line 156
    arg = argv[opj_optind] + 1;
#line 158
    o = longopts;
#line 159
    len = (int )sizeof(*(longopts + 0));
#line 161
    if ((int )param > 1) {
#line 162
      arg = argv[opj_optind + 1];
#line 163
      opj_optind ++;
    } else {
#line 166
      arg = argv[opj_optind] + 1;
    }
    {
#line 168
    __cil_tmp15 = strlen((char const   *)arg);
    }
#line 168
    if (__cil_tmp15 > 1UL) {
#line 169
      i = 0;
      {
#line 169
      while (1) {
        while_continue: /* CIL Label */ ;
#line 169
        if (! (i < totlen)) {
#line 169
          goto while_break;
        }
        {
#line 170
        __cil_tmp16 = strcmp(o->name, (char const   *)arg);
        }
#line 170
        if (! __cil_tmp16) {
#line 171
          if (o->has_arg == 0) {
#line 172
            if (argv[opj_optind + 1]) {
#line 172
              if (! ((int )*(argv[opj_optind + 1] + 0) == 45)) {
                {
#line 173
                fprintf(stderr, "%s: option does not require an argument. Ignoring %s\n",
                        arg, argv[opj_optind + 1]);
#line 174
                opj_optind ++;
                }
              }
            }
          } else {
#line 177
            opj_optarg = argv[opj_optind + 1];
#line 178
            if (opj_optarg) {
#line 179
              if ((int )*(opj_optarg + 0) == 45) {
#line 180
                if (opj_opterr) {
                  {
#line 181
                  fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                  }
#line 182
                  return ((int )'?');
                }
              }
            }
#line 186
            if (! opj_optarg) {
#line 186
              if (o->has_arg == 1) {
#line 187
                if (opj_opterr) {
                  {
#line 188
                  fprintf(stderr, "%s: option requires an argument \n\365\306j\347U",
                          arg);
                  }
#line 189
                  return ((int )'?');
                }
              }
            }
#line 192
            opj_optind ++;
          }
#line 194
          opj_optind ++;
#line 195
          if (o->flag) {
#line 196
            *(o->flag) = o->val;
          } else {
#line 198
            return (o->val);
          }
#line 199
          return (0);
        }
#line 169
        __cil_tmp17 = o;
#line 169
        o ++;
#line 169
        i += len;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 202
      fprintf(stderr, "Invalid option %s\n\306j\347U", arg);
#line 203
      opj_optind ++;
      }
#line 204
      return ((int )'?');
    } else {
#line 206
      if ((int )*optstring == 58) {
#line 206
        return (':');
      }
#line 207
      if (lastidx != opj_optind) {
#line 208
        lastidx = opj_optind;
#line 208
        lastofs = 0;
      }
      {
#line 210
      opj_optopt = (int )*(argv[opj_optind] + (lastofs + 1));
#line 211
      tmp = strchr(optstring, opj_optopt);
      }
#line 211
      if (tmp) {
#line 212
        if ((int )*tmp == 0) {
#line 213
          opj_optind ++;
#line 214
          goto again;
        }
#line 216
        if ((int )*(tmp + 1) == 58) {
#line 217
          if ((int )*(tmp + 2) == 58) {
            _L: /* CIL Label */ 
#line 218
            opj_optarg = (argv[opj_optind] + lastofs) + 2;
#line 218
            if (! *opj_optarg) {
#line 218
              opj_optarg = (char *)0;
            }
#line 219
            goto found;
          } else
#line 217
          if ((int )*(argv[opj_optind] + (lastofs + 2))) {
#line 217
            goto _L;
          }
#line 221
          opj_optarg = argv[opj_optind + 1];
#line 222
          if (opj_optarg) {
#line 223
            if ((int )*(opj_optarg + 0) == 45) {
#line 224
              if (opj_opterr) {
                {
#line 225
                fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                }
#line 226
                return ((int )'?');
              }
            }
          }
#line 230
          if (! opj_optarg) {
#line 231
            if (opj_opterr) {
              {
#line 232
              fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
              }
#line 233
              return ((int )'?');
            }
          }
#line 236
          opj_optind ++;
        } else {
#line 238
          lastofs ++;
#line 239
          return (opj_optopt);
        }
        found: 
#line 242
        opj_optind ++;
#line 243
        return (opj_optopt);
      } else {
        {
#line 245
        fprintf(stderr, "Invalid option %s\n", arg);
#line 246
        opj_optind ++;
        }
#line 247
        return ((int )'?');
      }
    }
  }
  {
#line 252
  fprintf(stderr, "Invalid option\n");
#line 253
  opj_optind ++;
  }
#line 254
  return ((int )'?');

}
}
#line 74 "/root/patron/new_21/src/bin/common/color.c"
static void sycc_to_rgb(int offset , int upb , int y , int cb , int cr , int *out_r ,
                        int *out_g , int *out_b ) 
{ 
  int r ;
  int g ;
  int b ;

  {
#line 79
  cb -= offset;
#line 79
  cr -= offset;
#line 80
  r = y + (int )(1.402 * (double )((float )cr));
#line 81
  if (r < 0) {
#line 81
    r = 0;
  } else
#line 81
  if (r > upb) {
#line 81
    r = upb;
  }
#line 81
  *out_r = r;
#line 83
  g = y - (int )(0.344 * (double )((float )cb) + 0.714 * (double )((float )cr));
#line 84
  if (g < 0) {
#line 84
    g = 0;
  } else
#line 84
  if (g > upb) {
#line 84
    g = upb;
  }
#line 84
  *out_g = g;
#line 86
  b = y + (int )(1.77200000001 * (double )((float )cb));
#line 87
  if (b < 0) {
#line 87
    b = 0;
  } else
#line 87
  if (b > upb) {
#line 87
    b = upb;
  }
#line 87
  *out_b = b;
  return;
}
}
#line 90 "/root/patron/new_21/src/bin/common/color.c"
static void sycc444_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int maxw ;
  int maxh ;
  int max ;
  int i ;
  int offset ;
  int upb ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
#line 96
  i = (int )(img->comps + 0)->prec;
#line 97
  offset = 1 << (i - 1);
#line 97
  upb = (1 << i) - 1;
#line 99
  maxw = (int )(img->comps + 0)->w;
#line 99
  maxh = (int )(img->comps + 0)->h;
#line 100
  max = maxw * maxh;
#line 102
  y = (int const   *)(img->comps + 0)->data;
#line 103
  cb = (int const   *)(img->comps + 1)->data;
#line 104
  cr = (int const   *)(img->comps + 2)->data;
#line 106
  __cil_tmp17 = malloc(sizeof(int ) * (size_t )max);
#line 106
  r = (int *)__cil_tmp17;
#line 106
  d0 = r;
#line 107
  __cil_tmp18 = malloc(sizeof(int ) * (size_t )max);
#line 107
  g = (int *)__cil_tmp18;
#line 107
  d1 = g;
#line 108
  __cil_tmp19 = malloc(sizeof(int ) * (size_t )max);
#line 108
  b = (int *)__cil_tmp19;
#line 108
  d2 = b;
#line 110
  i = 0;
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (i < max)) {
#line 110
      goto while_break;
    }
    {
#line 112
    sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 114
    y ++;
#line 114
    cb ++;
#line 114
    cr ++;
#line 114
    r ++;
#line 114
    g ++;
#line 114
    b ++;
    }
#line 110
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  free((img->comps + 0)->data);
#line 116
  (img->comps + 0)->data = d0;
#line 117
  free((img->comps + 1)->data);
#line 117
  (img->comps + 1)->data = d1;
#line 118
  free((img->comps + 2)->data);
#line 118
  (img->comps + 2)->data = d2;
  }
  return;
}
}
#line 122 "/root/patron/new_21/src/bin/common/color.c"
static void sycc422_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int maxw ;
  int maxh ;
  int max ;
  int offset ;
  int upb ;
  int i ;
  int j ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
  {
#line 129
  i = (int )(img->comps + 0)->prec;
#line 130
  offset = 1 << (i - 1);
#line 130
  upb = (1 << i) - 1;
#line 132
  maxw = (int )(img->comps + 0)->w;
#line 132
  maxh = (int )(img->comps + 0)->h;
#line 133
  max = maxw * maxh;
#line 135
  y = (int const   *)(img->comps + 0)->data;
#line 136
  cb = (int const   *)(img->comps + 1)->data;
#line 137
  cr = (int const   *)(img->comps + 2)->data;
#line 139
  __cil_tmp18 = malloc(sizeof(int ) * (size_t )max);
#line 139
  r = (int *)__cil_tmp18;
#line 139
  d0 = r;
#line 140
  __cil_tmp19 = malloc(sizeof(int ) * (size_t )max);
#line 140
  g = (int *)__cil_tmp19;
#line 140
  d1 = g;
#line 141
  __cil_tmp20 = malloc(sizeof(int ) * (size_t )max);
#line 141
  b = (int *)__cil_tmp20;
#line 141
  d2 = b;
#line 143
  i = 0;
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i < maxh)) {
#line 143
      goto while_break;
    }
#line 145
    j = 0;
    {
#line 145
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 145
      if (! ((OPJ_UINT32 )j < ((unsigned int )maxw & 4294967294U))) {
#line 145
        goto while_break___0;
      }
      {
#line 147
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 149
      y ++;
#line 149
      r ++;
#line 149
      g ++;
#line 149
      b ++;
#line 151
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 153
      y ++;
#line 153
      r ++;
#line 153
      g ++;
#line 153
      b ++;
#line 153
      cb ++;
#line 153
      cr ++;
      }
#line 145
      j += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 155
    if (j < maxw) {
      {
#line 156
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 157
      y ++;
#line 157
      r ++;
#line 157
      g ++;
#line 157
      b ++;
#line 157
      cb ++;
#line 157
      cr ++;
      }
    }
#line 143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 160
  free((img->comps + 0)->data);
#line 160
  (img->comps + 0)->data = d0;
#line 161
  free((img->comps + 1)->data);
#line 161
  (img->comps + 1)->data = d1;
#line 162
  free((img->comps + 2)->data);
#line 162
  (img->comps + 2)->data = d2;
#line 168
  (img->comps + 1)->w = (OPJ_UINT32 )maxw;
#line 168
  (img->comps + 1)->h = (OPJ_UINT32 )maxh;
#line 169
  (img->comps + 2)->w = (OPJ_UINT32 )maxw;
#line 169
  (img->comps + 2)->h = (OPJ_UINT32 )maxh;
#line 171
  (img->comps + 1)->dx = (img->comps + 0)->dx;
#line 172
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 173
  (img->comps + 1)->dy = (img->comps + 0)->dy;
#line 174
  (img->comps + 2)->dy = (img->comps + 0)->dy;
  }
  return;
}
}
#line 178 "/root/patron/new_21/src/bin/common/color.c"
static void sycc420_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int *nr ;
  int *ng ;
  int *nb ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int const   *ny ;
  int maxw ;
  int maxh ;
  int max ;
  int offset ;
  int upb ;
  int i ;
  int j ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;

  {
  {
#line 185
  i = (int )(img->comps + 0)->prec;
#line 186
  offset = 1 << (i - 1);
#line 186
  upb = (1 << i) - 1;
#line 188
  maxw = (int )(img->comps + 0)->w;
#line 188
  maxh = (int )(img->comps + 0)->h;
#line 189
  max = maxw * maxh;
#line 191
  y = (int const   *)(img->comps + 0)->data;
#line 192
  cb = (int const   *)(img->comps + 1)->data;
#line 193
  cr = (int const   *)(img->comps + 2)->data;
#line 195
  __cil_tmp22 = malloc(sizeof(int ) * (size_t )max);
#line 195
  r = (int *)__cil_tmp22;
#line 195
  d0 = r;
#line 196
  __cil_tmp23 = malloc(sizeof(int ) * (size_t )max);
#line 196
  g = (int *)__cil_tmp23;
#line 196
  d1 = g;
#line 197
  __cil_tmp24 = malloc(sizeof(int ) * (size_t )max);
#line 197
  b = (int *)__cil_tmp24;
#line 197
  d2 = b;
#line 199
  i = 0;
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! ((OPJ_UINT32 )i < ((unsigned int )maxh & 4294967294U))) {
#line 199
      goto while_break;
    }
#line 201
    ny = y + maxw;
#line 202
    nr = r + maxw;
#line 202
    ng = g + maxw;
#line 202
    nb = b + maxw;
#line 204
    j = 0;
    {
#line 204
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 204
      if (! ((OPJ_UINT32 )j < ((unsigned int )maxw & 4294967294U))) {
#line 204
        goto while_break___0;
      }
      {
#line 206
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 208
      y ++;
#line 208
      r ++;
#line 208
      g ++;
#line 208
      b ++;
#line 210
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 212
      y ++;
#line 212
      r ++;
#line 212
      g ++;
#line 212
      b ++;
#line 214
      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
#line 216
      ny ++;
#line 216
      nr ++;
#line 216
      ng ++;
#line 216
      nb ++;
#line 218
      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
#line 220
      ny ++;
#line 220
      nr ++;
#line 220
      ng ++;
#line 220
      nb ++;
#line 220
      cb ++;
#line 220
      cr ++;
      }
#line 204
      j += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 222
    if (j < maxw) {
      {
#line 224
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 226
      y ++;
#line 226
      r ++;
#line 226
      g ++;
#line 226
      b ++;
#line 228
      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
#line 230
      ny ++;
#line 230
      nr ++;
#line 230
      ng ++;
#line 230
      nb ++;
#line 230
      cb ++;
#line 230
      cr ++;
      }
    }
#line 232
    y += maxw;
#line 232
    r += maxw;
#line 232
    g += maxw;
#line 232
    b += maxw;
#line 199
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  if (i < maxh) {
#line 236
    j = 0;
    {
#line 236
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 236
      if (! ((OPJ_UINT32 )j < ((unsigned int )maxw & 4294967294U))) {
#line 236
        goto while_break___1;
      }
      {
#line 238
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 240
      y ++;
#line 240
      r ++;
#line 240
      g ++;
#line 240
      b ++;
#line 242
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 244
      y ++;
#line 244
      r ++;
#line 244
      g ++;
#line 244
      b ++;
#line 244
      cb ++;
#line 244
      cr ++;
      }
#line 236
      j += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 246
    if (j < maxw) {
      {
#line 248
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
      }
    }
  }
  {
#line 252
  free((img->comps + 0)->data);
#line 252
  (img->comps + 0)->data = d0;
#line 253
  free((img->comps + 1)->data);
#line 253
  (img->comps + 1)->data = d1;
#line 254
  free((img->comps + 2)->data);
#line 254
  (img->comps + 2)->data = d2;
#line 260
  (img->comps + 1)->w = (OPJ_UINT32 )maxw;
#line 260
  (img->comps + 1)->h = (OPJ_UINT32 )maxh;
#line 261
  (img->comps + 2)->w = (OPJ_UINT32 )maxw;
#line 261
  (img->comps + 2)->h = (OPJ_UINT32 )maxh;
#line 263
  (img->comps + 1)->dx = (img->comps + 0)->dx;
#line 264
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 265
  (img->comps + 1)->dy = (img->comps + 0)->dy;
#line 266
  (img->comps + 2)->dy = (img->comps + 0)->dy;
  }
  return;
}
}
#line 270 "/root/patron/new_21/src/bin/common/color.c"
void color_sycc_to_rgb(opj_image_t *img ) 
{ 


  {
#line 272
  if (img->numcomps < 3U) {
#line 274
    img->color_space = (OPJ_COLOR_SPACE )2;
#line 275
    return;
  }
#line 278
  if ((img->comps + 0)->dx == 1U) {
#line 278
    if ((img->comps + 1)->dx == 2U) {
#line 278
      if ((img->comps + 2)->dx == 2U) {
#line 278
        if ((img->comps + 0)->dy == 1U) {
#line 278
          if ((img->comps + 1)->dy == 2U) {
#line 278
            if ((img->comps + 2)->dy == 2U) {
              {
#line 285
              sycc420_to_rgb(img);
              }
            } else {
#line 278
              goto _L___64;
            }
          } else {
#line 278
            goto _L___64;
          }
        } else {
#line 278
          goto _L___64;
        }
      } else {
#line 278
        goto _L___64;
      }
    } else {
#line 278
      goto _L___64;
    }
  } else
  _L___64: /* CIL Label */ 
  _L___65: /* CIL Label */ 
  _L___66: /* CIL Label */ 
  _L___67: /* CIL Label */ 
  _L___68: /* CIL Label */ 
#line 288
  if ((img->comps + 0)->dx == 1U) {
#line 288
    if ((img->comps + 1)->dx == 2U) {
#line 288
      if ((img->comps + 2)->dx == 2U) {
#line 288
        if ((img->comps + 0)->dy == 1U) {
#line 288
          if ((img->comps + 1)->dy == 1U) {
#line 288
            if ((img->comps + 2)->dy == 1U) {
              {
#line 295
              sycc422_to_rgb(img);
              }
            } else {
#line 288
              goto _L;
            }
          } else {
#line 288
            goto _L;
          }
        } else {
#line 288
          goto _L;
        }
      } else {
#line 288
        goto _L;
      }
    } else {
#line 288
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  _L___60: /* CIL Label */ 
  _L___61: /* CIL Label */ 
  _L___62: /* CIL Label */ 
  _L___63: /* CIL Label */ 
#line 298
  if ((img->comps + 0)->dx == 1U) {
#line 298
    if ((img->comps + 1)->dx == 1U) {
#line 298
      if ((img->comps + 2)->dx == 1U) {
#line 298
        if ((img->comps + 0)->dy == 1U) {
#line 298
          if ((img->comps + 1)->dy == 1U) {
#line 298
            if ((img->comps + 2)->dy == 1U) {
              {
#line 305
              sycc444_to_rgb(img);
              }
            } else {
              {
              {
              {
              {
              {
              {
#line 309
              fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron/new_21/src/bin/common/color.c",
                      310);
              }
              }
              }
              }
              }
              }
#line 311
              return;
            }
          } else {
            {
            {
            {
            {
            {
            {
#line 309
            fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron/new_21/src/bin/common/color.c",
                    310);
            }
            }
            }
            }
            }
            }
#line 311
            return;
          }
        } else {
          {
          {
          {
          {
          {
          {
#line 309
          fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron/new_21/src/bin/common/color.c",
                  310);
          }
          }
          }
          }
          }
          }
#line 311
          return;
        }
      } else {
        {
        {
        {
        {
        {
        {
#line 309
        fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron/new_21/src/bin/common/color.c",
                310);
        }
        }
        }
        }
        }
        }
#line 311
        return;
      }
    } else {
      {
      {
      {
      {
      {
      {
#line 309
      fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron/new_21/src/bin/common/color.c",
              310);
      }
      }
      }
      }
      }
      }
#line 311
      return;
    }
  } else {
    {
    {
    {
    {
    {
    {
#line 309
    fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron/new_21/src/bin/common/color.c",
            310);
    }
    }
    }
    }
    }
    }
#line 311
    return;
  }
#line 313
  img->color_space = (OPJ_COLOR_SPACE )1;
  return;
}
}
