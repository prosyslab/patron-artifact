#include <stdio.h>
#include <stdint.h>

typedef int32_t Fixed;


	/*!Message from any scripting engine used in the presentation (ECMAScript, MPEG-J, ...) (Info).*/
#define	GF_SCRIPT_INFO                                          = 3
	/*!Indicates a send packet is not dispatched due to pending connections.*/
#define	GF_PENDING_PACKET					= 2
	/*!Indicates the end of a stream or of a file (Info).*/
#define	GF_EOS								= 1
	/*!Operation success (no error).*/
#define	GF_OK								= 0
	/*!\n*/
	/*!One of the input parameter is not correct or cannot be used in the current operating mode of the framework.*/
#define	GF_BAD_PARAM							= -1
	/*! Memory allocation failure.*/
#define	GF_OUT_OF_MEM							= -2
	/*! Input/Output failure (disk access, system call failures)*/
#define	GF_IO_ERR								= -3
	/*! The desired feature or operation is not supported by the framework*/
#define	GF_NOT_SUPPORTED						= -4
	/*! Input data has been corrupted*/
#define	GF_CORRUPTED_DATA						= -5
	/*! A modification was attempted on a scene node which could not be found*/
#define	GF_SG_UNKNOWN_NODE						= -6
	/*! The PROTO node interface does not match the nodes using it*/
#define	GF_SG_INVALID_PROTO						= -7
	/*! An error occured in the scripting engine*/
#define	GF_SCRIPT_ERROR							= -8
	/*! Buffer is too small to contain decoded data. Decoders shall use this error whenever they need to resize their output memory buffers*/
#define	GF_BUFFER_TOO_SMALL						= -9
	/*! The bitstream is not compliant to the specfication it refers to*/
#define	GF_NON_COMPLIANT_BITSTREAM				= -10
	/*! No filter could be found to handle the desired media type*/
#define	GF_FILTER_NOT_FOUND						= -11
	/*! The URL is not properly formatted or cannot be found*/
#define	GF_URL_ERROR							= -12
	/*! An service error has occured at the local side*/
#define	GF_SERVICE_ERROR						= -13
	/*! A service error has occured at the remote (server) side*/
#define	GF_REMOTE_SERVICE_ERROR					= -14
	/*! The desired stream could not be found in the service*/
#define	GF_STREAM_NOT_FOUND						= -15
    /*! The URL no longer exists*/
#define    GF_URL_REMOVED                          = -16

	/*! The IsoMedia file is not a valid one*/
#define	GF_ISOM_INVALID_FILE					= -20
	/*! The IsoMedia file is not complete. Either the file is being downloaded, or it has been truncated*/
#define	GF_ISOM_INCOMPLETE_FILE					= -21
	/*! The media in this IsoMedia track is not valid (usually due to a broken stream description)*/
#define	GF_ISOM_INVALID_MEDIA					= -22
	/*! The requested operation cannot happen in the current opening mode of the IsoMedia file*/
#define	GF_ISOM_INVALID_MODE					= -23
	/*! This IsoMedia track refers to media outside the file in an unknown way*/
#define	GF_ISOM_UNKNOWN_DATA_REF				= -24

	/*! An invalid MPEG-4 Object Descriptor was found*/
#define	GF_ODF_INVALID_DESCRIPTOR				= -30
	/*! An MPEG-4 Object Descriptor was found or added to a forbidden descriptor*/
#define	GF_ODF_FORBIDDEN_DESCRIPTOR				= -31
	/*! An invalid MPEG-4 BIFS command was detected*/
#define	GF_ODF_INVALID_COMMAND					= -32
	/*! The scene has been encoded using an unknown BIFS version*/
#define	GF_BIFS_UNKNOWN_VERSION					= -33

	/*! The remote IP address could not be solved*/
#define	GF_IP_ADDRESS_NOT_FOUND					= -40
	/*! The connection to the remote peer has failed*/
#define	GF_IP_CONNECTION_FAILURE				= -41
	/*! The network operation has failed*/
#define	GF_IP_NETWORK_FAILURE					= -42
	/*! The network connection has been closed*/
#define	GF_IP_CONNECTION_CLOSED					= -43
	/*! The network operation has failed because no data is available*/
#define	GF_IP_NETWORK_EMPTY						= -44

	/*! UDP connection did not receive any data at all. Signaled by client services to reconfigure network if possible*/
#define	GF_IP_UDP_TIMEOUT						= -46

	/*! Authentication with the remote host has failed*/
#define	GF_AUTHENTICATION_FAILURE				= -50
	/*! Script not ready for playback */
#define	GF_SCRIPT_NOT_READY						= -51
	/*! Bad configuration for the current context */
#define	GF_INVALID_CONFIGURATION				= -52
	/*! The element has not been found */
#define	GF_NOT_FOUND							= -53
	/*! Unexpected format of data */
#define	GF_PROFILE_NOT_SUPPORTED				= -54
	/*! filter PID config requires new instance of filter */
#define	GF_REQUIRES_NEW_INSTANCE = -56
	/*! filter PID config cannot be supported by this filter, no use trying to find an alternate input filter chain*/
#define	GF_FILTER_NOT_SUPPORTED = -5


struct __tag_bitstream
{
	/*original stream data*/
	FILE *stream;

	/*or original data*/
	char *original;
	/*the size of our buffer in bytes*/
	uint64_t size;
	/*current position in BYTES*/
	uint64_t position;
	/*the byte readen/written*/
	uint32_t current;
	/*the number of bits in the current byte*/
	uint32_t nbBits;
	/*the bitstream mode*/
	uint32_t bsmode;

	void *par;


	char *cache_write;
	uint32_t cache_write_size, buffer_written;

	int remove_emul_prevention_byte;
	uint32_t nb_zeros, nb_removed;

	void *usr_data;
	uint64_t bytes_out;
	uint32_t prevent_dispatch;

	uint64_t cookie;

	uint8_t *cache_read;
	uint32_t cache_read_size, cache_read_pos, cache_read_alloc;

	uint32_t total_bits_read;
	uint32_t overflow_state;
};

typedef struct __tag_bitstream GF_BitStream;

void init_source(GF_BitStream *bs, uint32_t *NbBits, uint32_t *NbComp, Fixed *m_ft) {
	FILE *f = fopen("dummy.c", "r");
	bs = (GF_BitStream *) malloc(sizeof(GF_BitStream));
	fscanf(f, "%d %d", NbBits, NbComp);
	m_ft = (Fixed *) malloc(sizeof(Fixed) * (*NbComp));
	fscanf(f, "%d %d %d", m_ft, m_ft + 1, m_ft + 2);
	fscanf(f, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d", &bs->size, &bs->position, &bs->current, &bs->nbBits, &bs->bsmode, &bs->par, &bs->cache_write, &bs->cache_write_size, &bs->buffer_written, &bs->remove_emul_prevention_byte, &bs->nb_zeros, &bs->nb_removed, &bs->usr_data, &bs->bytes_out, &bs->prevent_dispatch);
}	

uint32_t gf_bs_read_int(GF_BitStream *bs, uint32_t nBits)
{
	u32 ret;
	bs->total_bits_read+= nBits;

	ret = 0;
	while (nBits-- > 0) {
		ret <<= 1;
		ret |= gf_bs_read_bit(bs);
	}
	return ret;
}

uint32_t gf_bs_read_bit(GF_BitStream *bs)
{
	uint32_t ret;
	if (bs->nbBits == 0) {
		bs->current = gf_bs_read_byte(bs);
		bs->nbBits = 8;
	}
	ret = (bs->current >> 7) & 1;
	bs->current <<= 1;
	bs->nbBits--;
	return ret;
}

uint32_t gf_bs_read_byte(GF_BitStream *bs)
{
	uint32_t ret;
	if (bs->position >= bs->size) return 0;
	ret = bs->original[bs->position];
	bs->position++;
	return ret;
}

Fixed gf_muldiv(Fixed a, Fixed b, Fixed c)
{
	return (int32_t) (((int64_t) a * (int64_t) b) / c);
}

Fixed INT2FIX(int32_t x)
{
	return x << 16;
}

Fixed gf_tan(Fixed x)
{
	return INT2FIX(tan(x >> 16));
}

Fixed gf_sqrt(Fixed x)
{
	return INT2FIX(sqrt(x >> 16));
}

Fixed gf_divfix(Fixed a, Fixed b)
{
	return (int32_t) (((int64_t) a << 16) / b);
}

Fixed gf_mulfix(Fixed a, Fixed b)
{
	return (int32_t) (((int64_t) a * b) >> 16);
}

Fixed gf_muldiv(Fixed a, Fixed b, Fixed c)
{
	return (int32_t) (((int64_t) a * b) / c);
}


//Linear inverse Quantization for floats
Fixed Q_InverseQuantize(Fixed Min, Fixed Max, uint32_t NbBits, uint32_t value)
{
	if (!value) return Min;
	if (value == (uint32_t) ((1 << NbBits) - 1) ) return Max;
	return Min + gf_muldiv(Max - Min, INT2FIX(value), INT2FIX( (1 << NbBits) - 1) );
}

//SFRotation and SFVec3f are quantized as normalized vectors ,mapped on a cube
//in the UnitSphere (R=1.0)
int Q_DecCoordOnUnitSphere(GF_BitStream *bs, uint32_t NbBits, uint32_t NbComp, Fixed *m_ft)
{
	uint32_t i, orient, sign;
	int32_t value;
	Fixed tang[4], delta;
	int32_t dir;

	if (NbBits>32) return -1;
	if (NbComp != 2 && NbComp != 3) return -1;

	//only 2 or 3 comp in the quantized version
	dir = 1;
	if(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);
	orient = gf_bs_read_int(bs, 2);
	if ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;
	for(i=0; i<NbComp; i++) {
		value = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) ); // sink
		sign = (value >= 0) ? 1 : -1;
		m_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);
	}
	// delta = 1;
	// for (i=0; i<NbComp; i++) {
	// 	tang[i] = gf_tan(gf_mulfix(GF_PI/4, m_ft[i]) );
	// 	delta += gf_mulfix(tang[i], tang[i]);
	// }
	// delta = gf_divfix(INT2FIX(dir), gf_sqrt(delta) );
	// m_ft[orient] = delta;
	// for (i=0; i<NbComp; i++) {
	// 	m_ft[ (orient + i+1) % (NbComp+1) ] = gf_mulfix(tang[i], delta);
	// }
	return GF_OK;
}

int main(int argc, char **argv) {
	GF_BitStream *bs; 
	uint32_t NbBits; 
	uint32_t NbComp; 
	Fixed *m_ft;

	init_source(bs, &NbBits, &NbComp, m_ft);
	Q_DecCoordOnUnitSphere(bs, NbBits, NbComp, m_ft);

  	return 0;
}